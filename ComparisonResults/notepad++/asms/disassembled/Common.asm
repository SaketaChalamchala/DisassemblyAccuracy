.rdata:00000000 ;
.rdata:00000000 ; +-------------------------------------------------------------------------+
.rdata:00000000 ; |   This file has been generated by The Interactive Disassembler (IDA)    |
.rdata:00000000 ; |           Copyright (c) 2015 Hex-Rays, <support@hex-rays.com>           |
.rdata:00000000 ; |                      License info: 48-3677-7074-51                      |
.rdata:00000000 ; |             Michalis Polychronakis, Stony Brook University              |
.rdata:00000000 ; +-------------------------------------------------------------------------+
.rdata:00000000 ;
.rdata:00000000 ; Input MD5   : 9BF0C8A66DD00F48B7AD6E67B98B25C0
.rdata:00000000 ; Input CRC32 : 90FB121A
.rdata:00000000
.rdata:00000000 ; File Name   : C:\workspace\notepad-plus-plus-6.7.9.2\PowerEditor\visual.net\Unicode Debug\Common.obj
.rdata:00000000 ; Format      : COFF (X386MAGIC)
.rdata:00000000 ; includelib "libcpmtd"
.rdata:00000000 ; includelib "uuid.lib"
.rdata:00000000 ; must resolve: ?_Generic_object@?$_Error_objects@H@std@@2V_Generic_error_category@2@A
.rdata:00000000 ; must resolve: ?_Iostream_object@?$_Error_objects@H@std@@2V_Iostream_error_category@2@A
.rdata:00000000 ; must resolve: ?_System_object@?$_Error_objects@H@std@@2V_System_error_category@2@A
.rdata:00000000 ; must resolve: ?id@?$num_put@DV?$back_insert_iterator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@std@@2V0locale@2@A
.rdata:00000000 ; must resolve: ?id@?$num_put@_WV?$back_insert_iterator@V?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@@std@@@std@@2V0locale@2@A
.rdata:00000000 ; must resolve: ?id@?$numpunct@D@std@@2V0locale@2@A
.rdata:00000000 ; must resolve: ?id@?$numpunct@_W@std@@2V0locale@2@A
.rdata:00000000 ; includelib "LIBCMTD"
.rdata:00000000 ; includelib "OLDNAMES"
.rdata:00000000
.rdata:00000000                 include uni.inc ; see unicode subdir of ida for info on unicode
.rdata:00000000
.rdata:00000000                 .686p
.rdata:00000000                 .mmx
.rdata:00000000                 .model flat
.rdata:00000000
.rdata:00000000 ; ===========================================================================
.rdata:00000000
.rdata:00000000 ; Segment type: Pure data
.rdata:00000000 ; Segment permissions: Read
.rdata:00000000 _rdata          segment dword public 'DATA' use32
.rdata:00000000                 assume cs:_rdata
.rdata:00000000 ; wchar_t _SG117823
.rdata:00000000 $SG117823       dw 0                    ; DATA XREF: string2wstring(std::basic_string<char,std::char_traits<char>,std::allocator<char>> const &,uint):loc_9C0o
.rdata:00000002 ; char _SG118184
.rdata:00000002 $SG118184       db 0                    ; DATA XREF: wstring2string(std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>> const &,uint):loc_AB8o
.rdata:00000003 ; char _SG116465
.rdata:00000003 $SG116465       db 0                    ; DATA XREF: getFileContent(wchar_t const *)+3Fo
.rdata:00000004 ; wchar_t _SG118853
.rdata:00000004 $SG118853       dw 0                    ; DATA XREF: PathAppendW(std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>> &,std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>> const &)+2Ao
.rdata:00000006                 db    0
.rdata:00000007                 db    0
.rdata:00000008 ; wchar_t _SG118854
.rdata:00000008 $SG118854       dw 0                    ; DATA XREF: PathAppendW(std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>> &,std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>> const &)+42o
.rdata:0000000A                 db    0
.rdata:0000000B                 db    0
.rdata:0000000C ; wchar_t _SG118855
.rdata:0000000C $SG118855       dd offset $SG117378     ; DATA XREF: PathAppendW(std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>> &,std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>> const &)+5Ao
.rdata:00000010 ; wchar_t _SG118899
.rdata:00000010 $SG118899       dw 0                    ; DATA XREF: PathAppendW(std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>> &,std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>> const &):loc_1B83o
.rdata:00000012                 db    0
.rdata:00000013                 db    0
.rdata:00000014 ; wchar_t _SG118900
.rdata:00000014 $SG118900       dw 0                    ; DATA XREF: PathAppendW(std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>> &,std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>> const &)+A3o
.rdata:00000016                 db    0
.rdata:00000017                 db    0
.rdata:00000018 ; wchar_t _SG118918
.rdata:00000018 $SG118918       dw 0                    ; DATA XREF: PathAppendW(std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>> &,std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>> const &)+107o
.rdata:0000001A                 db    0
.rdata:0000001B                 db    0
.rdata:0000001C ; wchar_t _SG118955
.rdata:0000001C $SG118955       dw 0                    ; DATA XREF: PathAppendW(std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>> &,std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>> const &)+193o
.rdata:0000001E                 db    0
.rdata:0000001F                 db    0
.rdata:00000020 ; wchar_t _SG118956
.rdata:00000020 $SG118956       dw 0                    ; DATA XREF: PathAppendW(std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>> &,std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>> const &)+1D9o
.rdata:00000022                 db    0
.rdata:00000023                 db    0
.rdata:00000024 ; wchar_t _SG118957
.rdata:00000024 $SG118957       dd offset $SG117378     ; DATA XREF: PathAppendW(std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>> &,std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>> const &):loc_1D28o
.rdata:00000028 ; char _SG119128[]
.rdata:00000028 $SG119128       db 'invalid stod argument',0
.rdata:00000028                                         ; DATA XREF: stodLocale(std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>> const &,localeinfo_struct *,uint *)+74o
.rdata:0000003E                 align 10h
.rdata:00000040 ; char _SG119139[]
.rdata:00000040 $SG119139       db 'stod argument out of range',0
.rdata:00000040                                         ; DATA XREF: stodLocale(std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>> const &,localeinfo_struct *,uint *)+D2o
.rdata:0000005B                 align 4
.rdata:0000005C $SG117378       dw 0                    ; DATA XREF: .rdata:$SG118855o
.rdata:0000005C                                         ; .rdata:$SG118957o ...
.rdata:0000005E                 align 10h
.rdata:00000060 ; const WCHAR _SG116452
.rdata:00000060 $SG116452:                              ; DATA XREF: printInt(int)+14o
.rdata:00000060                 unicode 0, <%d>,0
.rdata:00000066                 align 4
.rdata:00000068 ; const WCHAR _SG116453
.rdata:00000068 $SG116453       dw 0                    ; DATA XREF: printInt(int)+28o
.rdata:0000006A                 align 4
.rdata:0000006C ; const WCHAR _SG116457
.rdata:0000006C $SG116457       dw 0                    ; DATA XREF: printStr(wchar_t const *)+5o
.rdata:0000006E                 align 10h
.rdata:00000070 ; wchar_t _SG116467
.rdata:00000070 $SG116467:                              ; DATA XREF: getFileContent(wchar_t const *)+56o
.rdata:00000070                 unicode 0, <rb>,0
.rdata:00000076                 align 4
.rdata:00000078 ; wchar_t _SG116488
.rdata:00000078 $SG116488       dw 0                    ; DATA XREF: relativeFilePathToFullFilePath(wchar_t const *)+35o
.rdata:0000007A                 db    0
.rdata:0000007B                 db    0
.rdata:0000007C ; wchar_t _SG116501
.rdata:0000007C $SG116501:                              ; DATA XREF: writeFileContent(wchar_t const *,char const *)+4o
.rdata:0000007C                 unicode 0, <w+>,0
.rdata:00000082                 align 4
.rdata:00000084 ; wchar_t _SG116507
.rdata:00000084 $SG116507:                              ; DATA XREF: writeLog(wchar_t const *,char const *)+4o
.rdata:00000084                 unicode 0, <a+>,0
.rdata:0000008A                 align 4
.rdata:0000008C $SG116524:                              ; DATA XREF: folderBrowser(HWND__ *,int,wchar_t const *)+64o
.rdata:0000008C                 unicode 0, <Select a folder to search from>,0
.rdata:000000CA                 align 4
.rdata:000000CC ; wchar_t _SG116546
.rdata:000000CC $SG116546       dw 0                    ; DATA XREF: getFolderName(HWND__ *,wchar_t const *)+35o
.rdata:000000CE                 db    0
.rdata:000000CF                 db    0
.rdata:000000D0 $SG116551:                              ; DATA XREF: getFolderName(HWND__ *,wchar_t const *)+9Do
.rdata:000000D0                 unicode 0, <Select a folder>,0
.rdata:000000F0 ; wchar_t _SG118718
.rdata:000000F0 $SG118718:                              ; DATA XREF: BuildMenuFileName(int,uint,std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>> const &)+6Do
.rdata:000000F0                 unicode 0, <1&0>,0
.rdata:000000F8 ; wchar_t _SG118721
.rdata:000000F8 $SG118721:                              ; DATA XREF: BuildMenuFileName(int,uint,std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>> const &):loc_CDEo
.rdata:000000F8                 unicode 0, <: >,0
.rdata:000000FE                 align 10h
.rdata:00000100 ; wchar_t _SG118761
.rdata:00000100 $SG118761:                              ; DATA XREF: BuildMenuFileName(int,uint,std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>> const &)+450o
.rdata:00000100                 unicode 0, <...>,0
.rdata:00000100 _rdata          ends
.rdata:00000100
.text$mn:00000108 ; ===========================================================================
.text$mn:00000108
.text$mn:00000108 ; Segment type: Pure code
.text$mn:00000108 ; Segment permissions: Read/Execute
.text$mn:00000108 _text$mn        segment para public 'CODE' use32
.text$mn:00000108                 assume cs:_text$mn
.text$mn:00000108                 ;org 108h
.text$mn:00000108                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text$mn:00000108
.text$mn:00000108 ; =============== S U B R O U T I N E =======================================
.text$mn:00000108
.text$mn:00000108 ; Attributes: bp-based frame
.text$mn:00000108
.text$mn:00000108 ; void __cdecl folderBrowser(HWND hDlg, int nIDDlgItem, const wchar_t *)
.text$mn:00000108                 public ?folderBrowser@@YAXPAUHWND__@@HPB_W@Z
.text$mn:00000108 ?folderBrowser@@YAXPAUHWND__@@HPB_W@Z proc near
.text$mn:00000108
.text$mn:00000108 Dst             = dword ptr -648h
.text$mn:00000108 var_644         = dword ptr -644h
.text$mn:00000108 var_640         = dword ptr -640h
.text$mn:00000108 var_63C         = dword ptr -63Ch
.text$mn:00000108 var_638         = dword ptr -638h
.text$mn:00000108 var_634         = dword ptr -634h
.text$mn:00000108 var_630         = dword ptr -630h
.text$mn:00000108 var_628         = dword ptr -628h
.text$mn:00000108 pidl            = dword ptr -624h
.text$mn:00000108 ppMalloc        = dword ptr -620h
.text$mn:00000108 var_61C         = byte ptr -61Ch
.text$mn:00000108 pszPath         = word ptr -414h
.text$mn:00000108 String          = word ptr -20Ch
.text$mn:00000108 var_4           = dword ptr -4
.text$mn:00000108 hDlg            = dword ptr  8
.text$mn:00000108 nIDDlgItem      = dword ptr  0Ch
.text$mn:00000108 arg_8           = dword ptr  10h
.text$mn:00000108
.text$mn:00000108                 push    ebp
.text$mn:00000109                 mov     ebp, esp
.text$mn:0000010B                 sub     esp, 648h
.text$mn:00000111                 mov     eax, dword ptr ds:___security_cookie
.text$mn:00000116                 xor     eax, ebp
.text$mn:00000118                 mov     [ebp+var_4], eax
.text$mn:0000011B                 mov     [ebp+ppMalloc], 0
.text$mn:00000125                 lea     eax, [ebp+ppMalloc]
.text$mn:0000012B                 push    eax             ; ppMalloc
.text$mn:0000012C                 call    dword ptr ds:__imp__SHGetMalloc@4 ; SHGetMalloc(x)
.text$mn:00000132                 test    eax, eax
.text$mn:00000134                 jnz     loc_281
.text$mn:0000013A                 push    20h ; ' '       ; Size
.text$mn:0000013C                 push    0               ; Val
.text$mn:0000013E                 lea     ecx, [ebp+Dst]
.text$mn:00000144                 push    ecx             ; Dst
.text$mn:00000145                 call    _memset
.text$mn:0000014A                 add     esp, 0Ch
.text$mn:0000014D                 mov     edx, [ebp+hDlg]
.text$mn:00000150                 mov     [ebp+Dst], edx
.text$mn:00000156                 mov     [ebp+var_644], 0
.text$mn:00000160                 lea     eax, [ebp+var_61C]
.text$mn:00000166                 mov     [ebp+var_640], eax
.text$mn:0000016C                 mov     [ebp+var_63C], offset $SG116524 ; "Select a folder to search from"
.text$mn:00000176                 mov     [ebp+var_638], 0
.text$mn:00000180                 mov     [ebp+var_634], offset ?BrowseCallbackProc@@YGHPAUHWND__@@IJJ@Z ; BrowseCallbackProc(HWND__ *,uint,long,long)
.text$mn:0000018A                 push    104h            ; cchMax
.text$mn:0000018F                 lea     ecx, [ebp+String]
.text$mn:00000195                 push    ecx             ; lpString
.text$mn:00000196                 mov     edx, [ebp+nIDDlgItem]
.text$mn:00000199                 push    edx             ; nIDDlgItem
.text$mn:0000019A                 mov     eax, [ebp+hDlg]
.text$mn:0000019D                 push    eax             ; hDlg
.text$mn:0000019E                 call    dword ptr ds:__imp__GetDlgItemTextW@16 ; GetDlgItemTextW(x,x,x,x)
.text$mn:000001A4                 mov     ecx, 2
.text$mn:000001A9                 imul    edx, ecx, 103h
.text$mn:000001AF                 mov     [ebp+var_628], edx
.text$mn:000001B5                 cmp     [ebp+var_628], 208h
.text$mn:000001BF                 jnb     short loc_1C3
.text$mn:000001C1                 jmp     short loc_1C8
.text$mn:000001C3 ; ---------------------------------------------------------------------------
.text$mn:000001C3
.text$mn:000001C3 loc_1C3:                                ; CODE XREF: folderBrowser(HWND__ *,int,wchar_t const *)+B7j
.text$mn:000001C3                 call    ___report_rangecheckfailure
.text$mn:000001C8
.text$mn:000001C8 loc_1C8:                                ; CODE XREF: folderBrowser(HWND__ *,int,wchar_t const *)+B9j
.text$mn:000001C8                 xor     eax, eax
.text$mn:000001CA                 mov     ecx, [ebp+var_628]
.text$mn:000001D0                 mov     [ebp+ecx+String], ax
.text$mn:000001D8                 mov     edx, 2
.text$mn:000001DD                 imul    eax, edx, 0
.text$mn:000001E0                 movzx   ecx, [ebp+eax+String]
.text$mn:000001E8                 test    ecx, ecx
.text$mn:000001EA                 jnz     short loc_1FD
.text$mn:000001EC                 cmp     [ebp+arg_8], 0
.text$mn:000001F0                 jz      short loc_1FD
.text$mn:000001F2                 mov     edx, [ebp+arg_8]
.text$mn:000001F5                 mov     [ebp+var_630], edx
.text$mn:000001FB                 jmp     short loc_209
.text$mn:000001FD ; ---------------------------------------------------------------------------
.text$mn:000001FD
.text$mn:000001FD loc_1FD:                                ; CODE XREF: folderBrowser(HWND__ *,int,wchar_t const *)+E2j
.text$mn:000001FD                                         ; folderBrowser(HWND__ *,int,wchar_t const *)+E8j
.text$mn:000001FD                 lea     eax, [ebp+String]
.text$mn:00000203                 mov     [ebp+var_630], eax
.text$mn:00000209
.text$mn:00000209 loc_209:                                ; CODE XREF: folderBrowser(HWND__ *,int,wchar_t const *)+F3j
.text$mn:00000209                 lea     ecx, [ebp+Dst]
.text$mn:0000020F                 push    ecx             ; lpbi
.text$mn:00000210                 call    dword ptr ds:__imp__SHBrowseForFolderW@4 ; SHBrowseForFolderW(x)
.text$mn:00000216                 mov     [ebp+pidl], eax
.text$mn:0000021C                 cmp     [ebp+pidl], 0
.text$mn:00000223                 jz      short loc_26D
.text$mn:00000225                 lea     edx, [ebp+pszPath]
.text$mn:0000022B                 push    edx             ; pszPath
.text$mn:0000022C                 mov     eax, [ebp+pidl]
.text$mn:00000232                 push    eax             ; pidl
.text$mn:00000233                 call    dword ptr ds:__imp__SHGetPathFromIDListW@8 ; SHGetPathFromIDListW(x,x)
.text$mn:00000239                 test    eax, eax
.text$mn:0000023B                 jz      short loc_252
.text$mn:0000023D                 lea     ecx, [ebp+pszPath]
.text$mn:00000243                 push    ecx             ; lpString
.text$mn:00000244                 mov     edx, [ebp+nIDDlgItem]
.text$mn:00000247                 push    edx             ; nIDDlgItem
.text$mn:00000248                 mov     eax, [ebp+hDlg]
.text$mn:0000024B                 push    eax             ; hDlg
.text$mn:0000024C                 call    dword ptr ds:__imp__SetDlgItemTextW@12 ; SetDlgItemTextW(x,x,x)
.text$mn:00000252
.text$mn:00000252 loc_252:                                ; CODE XREF: folderBrowser(HWND__ *,int,wchar_t const *)+133j
.text$mn:00000252                 mov     ecx, [ebp+pidl]
.text$mn:00000258                 push    ecx
.text$mn:00000259                 mov     edx, [ebp+ppMalloc]
.text$mn:0000025F                 mov     eax, [edx]
.text$mn:00000261                 mov     ecx, [ebp+ppMalloc]
.text$mn:00000267                 push    ecx
.text$mn:00000268                 mov     edx, [eax+14h]
.text$mn:0000026B                 call    edx
.text$mn:0000026D
.text$mn:0000026D loc_26D:                                ; CODE XREF: folderBrowser(HWND__ *,int,wchar_t const *)+11Bj
.text$mn:0000026D                 mov     eax, [ebp+ppMalloc]
.text$mn:00000273                 mov     ecx, [eax]
.text$mn:00000275                 mov     edx, [ebp+ppMalloc]
.text$mn:0000027B                 push    edx
.text$mn:0000027C                 mov     eax, [ecx+8]
.text$mn:0000027F                 call    eax
.text$mn:00000281
.text$mn:00000281 loc_281:                                ; CODE XREF: folderBrowser(HWND__ *,int,wchar_t const *)+2Cj
.text$mn:00000281                 mov     ecx, [ebp+var_4]
.text$mn:00000284                 xor     ecx, ebp
.text$mn:00000286                 call    @__security_check_cookie@4 ; __security_check_cookie(x)
.text$mn:0000028B                 mov     esp, ebp
.text$mn:0000028D                 pop     ebp
.text$mn:0000028E                 retn
.text$mn:0000028E ?folderBrowser@@YAXPAUHWND__@@HPB_W@Z endp
.text$mn:0000028E
.text$mn:0000028E ; ---------------------------------------------------------------------------
.text$mn:0000028F                 db 9 dup(0CCh)
.text$mn:00000298
.text$mn:00000298 ; =============== S U B R O U T I N E =======================================
.text$mn:00000298
.text$mn:00000298 ; Attributes: bp-based frame
.text$mn:00000298
.text$mn:00000298 ; class std::basic_string<wchar_t, struct std::char_traits<wchar_t>, class std::allocator<wchar_t>> __cdecl getFolderName(struct HWND__ *, wchar_t const *)
.text$mn:00000298                 public ?getFolderName@@YA?AV?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@PAUHWND__@@PB_W@Z
.text$mn:00000298 ?getFolderName@@YA?AV?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@PAUHWND__@@PB_W@Z proc near
.text$mn:00000298
.text$mn:00000298 Dst             = dword ptr -468h
.text$mn:00000298 var_464         = dword ptr -464h
.text$mn:00000298 var_460         = dword ptr -460h
.text$mn:00000298 var_45C         = dword ptr -45Ch
.text$mn:00000298 var_458         = dword ptr -458h
.text$mn:00000298 var_454         = dword ptr -454h
.text$mn:00000298 var_450         = dword ptr -450h
.text$mn:00000298 var_448         = dword ptr -448h
.text$mn:00000298 pidl            = dword ptr -444h
.text$mn:00000298 ppMalloc        = dword ptr -440h
.text$mn:00000298 var_43C         = byte ptr -43Ch
.text$mn:00000298 var_420         = byte ptr -420h
.text$mn:00000298 pszPath         = word ptr -218h
.text$mn:00000298 var_10          = dword ptr -10h
.text$mn:00000298 var_C           = dword ptr -0Ch
.text$mn:00000298 var_4           = dword ptr -4
.text$mn:00000298 arg_0           = dword ptr  8
.text$mn:00000298 arg_4           = dword ptr  0Ch
.text$mn:00000298 arg_8           = dword ptr  10h
.text$mn:00000298
.text$mn:00000298                 push    ebp
.text$mn:00000299                 mov     ebp, esp
.text$mn:0000029B                 push    0FFFFFFFFh
.text$mn:0000029D                 push    offset __ehhandler$?getFolderName@@YA?AV?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@PAUHWND__@@PB_W@Z
.text$mn:000002A2                 mov     eax, large fs:0
.text$mn:000002A8                 push    eax
.text$mn:000002A9                 sub     esp, 45Ch
.text$mn:000002AF                 mov     eax, dword ptr ds:___security_cookie
.text$mn:000002B4                 xor     eax, ebp
.text$mn:000002B6                 mov     [ebp+var_10], eax
.text$mn:000002B9                 push    eax
.text$mn:000002BA                 lea     eax, [ebp+var_C]
.text$mn:000002BD                 mov     large fs:0, eax
.text$mn:000002C3                 mov     [ebp+var_448], 0
.text$mn:000002CD                 push    offset $SG116546 ; Str
.text$mn:000002D2                 lea     ecx, [ebp+var_43C]
.text$mn:000002D8                 call    ??0?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QAE@PB_W@Z ; std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>>::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>>(wchar_t const *)
.text$mn:000002DD                 mov     [ebp+var_4], 1
.text$mn:000002E4                 mov     [ebp+ppMalloc], 0
.text$mn:000002EE                 lea     eax, [ebp+ppMalloc]
.text$mn:000002F4                 push    eax             ; ppMalloc
.text$mn:000002F5                 call    dword ptr ds:__imp__SHGetMalloc@4 ; SHGetMalloc(x)
.text$mn:000002FB                 test    eax, eax
.text$mn:000002FD                 jnz     loc_3D1
.text$mn:00000303                 push    20h ; ' '       ; Size
.text$mn:00000305                 push    0               ; Val
.text$mn:00000307                 lea     ecx, [ebp+Dst]
.text$mn:0000030D                 push    ecx             ; Dst
.text$mn:0000030E                 call    _memset
.text$mn:00000313                 add     esp, 0Ch
.text$mn:00000316                 mov     edx, [ebp+arg_4]
.text$mn:00000319                 mov     [ebp+Dst], edx
.text$mn:0000031F                 mov     [ebp+var_464], 0
.text$mn:00000329                 lea     eax, [ebp+var_420]
.text$mn:0000032F                 mov     [ebp+var_460], eax
.text$mn:00000335                 mov     [ebp+var_45C], offset $SG116551 ; "Select a folder"
.text$mn:0000033F                 mov     [ebp+var_458], 0
.text$mn:00000349                 mov     [ebp+var_454], offset ?BrowseCallbackProc@@YGHPAUHWND__@@IJJ@Z ; BrowseCallbackProc(HWND__ *,uint,long,long)
.text$mn:00000353                 mov     ecx, [ebp+arg_8]
.text$mn:00000356                 mov     [ebp+var_450], ecx
.text$mn:0000035C                 lea     edx, [ebp+Dst]
.text$mn:00000362                 push    edx             ; lpbi
.text$mn:00000363                 call    dword ptr ds:__imp__SHBrowseForFolderW@4 ; SHBrowseForFolderW(x)
.text$mn:00000369                 mov     [ebp+pidl], eax
.text$mn:0000036F                 cmp     [ebp+pidl], 0
.text$mn:00000376                 jz      short loc_3BD
.text$mn:00000378                 lea     eax, [ebp+pszPath]
.text$mn:0000037E                 push    eax             ; pszPath
.text$mn:0000037F                 mov     ecx, [ebp+pidl]
.text$mn:00000385                 push    ecx             ; pidl
.text$mn:00000386                 call    dword ptr ds:__imp__SHGetPathFromIDListW@8 ; SHGetPathFromIDListW(x,x)
.text$mn:0000038C                 test    eax, eax
.text$mn:0000038E                 jz      short loc_3A2
.text$mn:00000390                 lea     edx, [ebp+pszPath]
.text$mn:00000396                 push    edx             ; Str
.text$mn:00000397                 lea     ecx, [ebp+var_43C]
.text$mn:0000039D                 call    ??4?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QAEAAV01@PB_W@Z ; std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>>::operator=(wchar_t const *)
.text$mn:000003A2
.text$mn:000003A2 loc_3A2:                                ; CODE XREF: getFolderName(HWND__ *,wchar_t const *)+F6j
.text$mn:000003A2                 mov     eax, [ebp+pidl]
.text$mn:000003A8                 push    eax
.text$mn:000003A9                 mov     ecx, [ebp+ppMalloc]
.text$mn:000003AF                 mov     edx, [ecx]
.text$mn:000003B1                 mov     eax, [ebp+ppMalloc]
.text$mn:000003B7                 push    eax
.text$mn:000003B8                 mov     ecx, [edx+14h]
.text$mn:000003BB                 call    ecx
.text$mn:000003BD
.text$mn:000003BD loc_3BD:                                ; CODE XREF: getFolderName(HWND__ *,wchar_t const *)+DEj
.text$mn:000003BD                 mov     edx, [ebp+ppMalloc]
.text$mn:000003C3                 mov     eax, [edx]
.text$mn:000003C5                 mov     ecx, [ebp+ppMalloc]
.text$mn:000003CB                 push    ecx
.text$mn:000003CC                 mov     edx, [eax+8]
.text$mn:000003CF                 call    edx
.text$mn:000003D1
.text$mn:000003D1 loc_3D1:                                ; CODE XREF: getFolderName(HWND__ *,wchar_t const *)+65j
.text$mn:000003D1                 lea     eax, [ebp+var_43C]
.text$mn:000003D7                 push    eax
.text$mn:000003D8                 mov     ecx, [ebp+arg_0]
.text$mn:000003DB                 call    ??0?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QAE@$$QAV01@@Z ; std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>>::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>>(std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>> &&)
.text$mn:000003E0                 mov     ecx, [ebp+var_448]
.text$mn:000003E6                 or      ecx, 1
.text$mn:000003E9                 mov     [ebp+var_448], ecx
.text$mn:000003EF                 mov     byte ptr [ebp+var_4], 0
.text$mn:000003F3                 lea     ecx, [ebp+var_43C]
.text$mn:000003F9                 call    ??1?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QAE@XZ ; std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>>::~basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>>(void)
.text$mn:000003FE                 mov     eax, [ebp+arg_0]
.text$mn:00000401                 mov     ecx, [ebp+var_C]
.text$mn:00000404                 mov     large fs:0, ecx
.text$mn:0000040B                 pop     ecx
.text$mn:0000040C                 mov     ecx, [ebp+var_10]
.text$mn:0000040F                 xor     ecx, ebp
.text$mn:00000411                 call    @__security_check_cookie@4 ; __security_check_cookie(x)
.text$mn:00000416                 mov     esp, ebp
.text$mn:00000418                 pop     ebp
.text$mn:00000419                 retn
.text$mn:00000419 ?getFolderName@@YA?AV?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@PAUHWND__@@PB_W@Z endp
.text$mn:00000419
.text$mn:00000419 ; ---------------------------------------------------------------------------
.text$mn:0000041A                 db 0Eh dup(0CCh)
.text$mn:00000428
.text$mn:00000428 ; =============== S U B R O U T I N E =======================================
.text$mn:00000428
.text$mn:00000428 ; Attributes: bp-based frame
.text$mn:00000428
.text$mn:00000428 ; void __cdecl printInt(int)
.text$mn:00000428                 public ?printInt@@YAXH@Z
.text$mn:00000428 ?printInt@@YAXH@Z proc near
.text$mn:00000428
.text$mn:00000428 Text            = word ptr -44h
.text$mn:00000428 var_4           = dword ptr -4
.text$mn:00000428 arg_0           = dword ptr  8
.text$mn:00000428
.text$mn:00000428                 push    ebp
.text$mn:00000429                 mov     ebp, esp
.text$mn:0000042B                 sub     esp, 44h
.text$mn:0000042E                 mov     eax, dword ptr ds:___security_cookie
.text$mn:00000433                 xor     eax, ebp
.text$mn:00000435                 mov     [ebp+var_4], eax
.text$mn:00000438                 mov     eax, [ebp+arg_0]
.text$mn:0000043B                 push    eax
.text$mn:0000043C                 push    offset $SG116452 ; "%d"
.text$mn:00000441                 lea     ecx, [ebp+Text]
.text$mn:00000444                 push    ecx             ; LPWSTR
.text$mn:00000445                 call    dword ptr ds:__imp__wsprintfW
.text$mn:0000044B                 add     esp, 0Ch
.text$mn:0000044E                 push    0               ; uType
.text$mn:00000450                 push    offset $SG116453 ; lpCaption
.text$mn:00000455                 lea     edx, [ebp+Text]
.text$mn:00000458                 push    edx             ; lpText
.text$mn:00000459                 push    0               ; hWnd
.text$mn:0000045B                 call    dword ptr ds:__imp__MessageBoxW@16 ; MessageBoxW(x,x,x,x)
.text$mn:00000461                 mov     ecx, [ebp+var_4]
.text$mn:00000464                 xor     ecx, ebp
.text$mn:00000466                 call    @__security_check_cookie@4 ; __security_check_cookie(x)
.text$mn:0000046B                 mov     esp, ebp
.text$mn:0000046D                 pop     ebp
.text$mn:0000046E                 retn
.text$mn:0000046E ?printInt@@YAXH@Z endp
.text$mn:0000046E
.text$mn:0000046E ; ---------------------------------------------------------------------------
.text$mn:0000046F                 db 9 dup(0CCh)
.text$mn:00000478
.text$mn:00000478 ; =============== S U B R O U T I N E =======================================
.text$mn:00000478
.text$mn:00000478 ; Attributes: bp-based frame
.text$mn:00000478
.text$mn:00000478 ; void __cdecl printStr(LPCWSTR lpText)
.text$mn:00000478                 public ?printStr@@YAXPB_W@Z
.text$mn:00000478 ?printStr@@YAXPB_W@Z proc near
.text$mn:00000478
.text$mn:00000478 lpText          = dword ptr  8
.text$mn:00000478
.text$mn:00000478                 push    ebp
.text$mn:00000479                 mov     ebp, esp
.text$mn:0000047B                 push    0               ; uType
.text$mn:0000047D                 push    offset $SG116457 ; lpCaption
.text$mn:00000482                 mov     eax, [ebp+lpText]
.text$mn:00000485                 push    eax             ; lpText
.text$mn:00000486                 push    0               ; hWnd
.text$mn:00000488                 call    dword ptr ds:__imp__MessageBoxW@16 ; MessageBoxW(x,x,x,x)
.text$mn:0000048E                 pop     ebp
.text$mn:0000048F                 retn
.text$mn:0000048F ?printStr@@YAXPB_W@Z endp
.text$mn:0000048F
.text$mn:0000048F ; ---------------------------------------------------------------------------
.text$mn:00000490                 db 8 dup(0CCh)
.text$mn:00000498
.text$mn:00000498 ; =============== S U B R O U T I N E =======================================
.text$mn:00000498
.text$mn:00000498 ; Attributes: bp-based frame
.text$mn:00000498
.text$mn:00000498 ; void __cdecl writeLog(const wchar_t *Filename, const char *Str)
.text$mn:00000498                 public ?writeLog@@YAXPB_WPBD@Z
.text$mn:00000498 ?writeLog@@YAXPB_WPBD@Z proc near
.text$mn:00000498
.text$mn:00000498 File            = dword ptr -4
.text$mn:00000498 Filename        = dword ptr  8
.text$mn:00000498 Str             = dword ptr  0Ch
.text$mn:00000498
.text$mn:00000498                 push    ebp
.text$mn:00000499                 mov     ebp, esp
.text$mn:0000049B                 push    ecx
.text$mn:0000049C                 push    offset $SG116507 ; "a+"
.text$mn:000004A1                 mov     eax, [ebp+Filename]
.text$mn:000004A4                 push    eax             ; Filename
.text$mn:000004A5                 call    __wfopen
.text$mn:000004AA                 add     esp, 8
.text$mn:000004AD                 mov     [ebp+File], eax
.text$mn:000004B0                 mov     ecx, [ebp+File]
.text$mn:000004B3                 push    ecx             ; File
.text$mn:000004B4                 mov     edx, [ebp+Str]
.text$mn:000004B7                 push    edx             ; Str
.text$mn:000004B8                 call    _strlen
.text$mn:000004BD                 add     esp, 4
.text$mn:000004C0                 push    eax             ; Count
.text$mn:000004C1                 push    1               ; Size
.text$mn:000004C3                 mov     eax, [ebp+Str]
.text$mn:000004C6                 push    eax             ; Str
.text$mn:000004C7                 call    _fwrite
.text$mn:000004CC                 add     esp, 10h
.text$mn:000004CF                 mov     ecx, [ebp+File]
.text$mn:000004D2                 push    ecx             ; File
.text$mn:000004D3                 push    0Ah             ; Ch
.text$mn:000004D5                 call    _fputc
.text$mn:000004DA                 add     esp, 8
.text$mn:000004DD                 mov     edx, [ebp+File]
.text$mn:000004E0                 push    edx             ; File
.text$mn:000004E1                 call    _fflush
.text$mn:000004E6                 add     esp, 4
.text$mn:000004E9                 mov     eax, [ebp+File]
.text$mn:000004EC                 push    eax             ; File
.text$mn:000004ED                 call    _fclose
.text$mn:000004F2                 add     esp, 4
.text$mn:000004F5                 mov     esp, ebp
.text$mn:000004F7                 pop     ebp
.text$mn:000004F8                 retn
.text$mn:000004F8 ?writeLog@@YAXPB_WPBD@Z endp
.text$mn:000004F8
.text$mn:000004F8 ; ---------------------------------------------------------------------------
.text$mn:000004F9                 db 0Fh dup(0CCh)
.text$mn:00000508
.text$mn:00000508 ; =============== S U B R O U T I N E =======================================
.text$mn:00000508
.text$mn:00000508 ; Attributes: bp-based frame
.text$mn:00000508
.text$mn:00000508 ; int __cdecl filter(unsigned int, struct _EXCEPTION_POINTERS *)
.text$mn:00000508                 public ?filter@@YAHIPAU_EXCEPTION_POINTERS@@@Z
.text$mn:00000508 ?filter@@YAHIPAU_EXCEPTION_POINTERS@@@Z proc near
.text$mn:00000508
.text$mn:00000508 arg_0           = dword ptr  8
.text$mn:00000508
.text$mn:00000508                 push    ebp
.text$mn:00000509                 mov     ebp, esp
.text$mn:0000050B                 cmp     [ebp+arg_0], 0C0000005h
.text$mn:00000512                 jnz     short loc_51B
.text$mn:00000514                 mov     eax, 1
.text$mn:00000519                 jmp     short loc_51D
.text$mn:0000051B ; ---------------------------------------------------------------------------
.text$mn:0000051B
.text$mn:0000051B loc_51B:                                ; CODE XREF: filter(uint,_EXCEPTION_POINTERS *)+Aj
.text$mn:0000051B                 xor     eax, eax
.text$mn:0000051D
.text$mn:0000051D loc_51D:                                ; CODE XREF: filter(uint,_EXCEPTION_POINTERS *)+11j
.text$mn:0000051D                 pop     ebp
.text$mn:0000051E                 retn
.text$mn:0000051E ?filter@@YAHIPAU_EXCEPTION_POINTERS@@@Z endp
.text$mn:0000051E
.text$mn:0000051E ; ---------------------------------------------------------------------------
.text$mn:0000051F                 db 9 dup(0CCh)
.text$mn:00000528
.text$mn:00000528 ; =============== S U B R O U T I N E =======================================
.text$mn:00000528
.text$mn:00000528 ; Attributes: bp-based frame
.text$mn:00000528
.text$mn:00000528 ; int __cdecl purgeMenuItemString(int, LPCWSTR lpString, char)
.text$mn:00000528                 public ?purgeMenuItemString@@YA?AV?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@PB_W_N@Z
.text$mn:00000528 ?purgeMenuItemString@@YA?AV?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@PB_W_N@Z proc near
.text$mn:00000528
.text$mn:00000528 var_A8          = dword ptr -0A8h
.text$mn:00000528 var_A4          = dword ptr -0A4h
.text$mn:00000528 var_A0          = dword ptr -0A0h
.text$mn:00000528 var_9C          = dword ptr -9Ch
.text$mn:00000528 var_98          = dword ptr -98h
.text$mn:00000528 var_94          = dword ptr -94h
.text$mn:00000528 Str             = word ptr -90h
.text$mn:00000528 Dst             = byte ptr -8Eh
.text$mn:00000528 var_10          = dword ptr -10h
.text$mn:00000528 var_C           = dword ptr -0Ch
.text$mn:00000528 var_4           = dword ptr -4
.text$mn:00000528 arg_0           = dword ptr  8
.text$mn:00000528 lpString        = dword ptr  0Ch
.text$mn:00000528 arg_8           = byte ptr  10h
.text$mn:00000528
.text$mn:00000528                 push    ebp
.text$mn:00000529                 mov     ebp, esp
.text$mn:0000052B                 push    0FFFFFFFFh
.text$mn:0000052D                 push    offset __ehhandler$?purgeMenuItemString@@YA?AV?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@PB_W_N@Z
.text$mn:00000532                 mov     eax, large fs:0
.text$mn:00000538                 push    eax
.text$mn:00000539                 sub     esp, 9Ch
.text$mn:0000053F                 mov     eax, dword ptr ds:___security_cookie
.text$mn:00000544                 xor     eax, ebp
.text$mn:00000546                 mov     [ebp+var_10], eax
.text$mn:00000549                 push    eax
.text$mn:0000054A                 lea     eax, [ebp+var_C]
.text$mn:0000054D                 mov     large fs:0, eax
.text$mn:00000553                 mov     [ebp+var_A4], 0
.text$mn:0000055D                 mov     ax, $SG117378
.text$mn:00000563                 mov     [ebp+Str], ax
.text$mn:0000056A                 push    7Eh ; '~'       ; Size
.text$mn:0000056C                 push    0               ; Val
.text$mn:0000056E                 lea     ecx, [ebp+Dst]
.text$mn:00000574                 push    ecx             ; Dst
.text$mn:00000575                 call    _memset_0
.text$mn:0000057A                 add     esp, 0Ch
.text$mn:0000057D                 mov     [ebp+var_98], 0
.text$mn:00000587                 mov     edx, [ebp+lpString]
.text$mn:0000058A                 push    edx             ; lpString
.text$mn:0000058B                 call    dword ptr ds:__imp__lstrlenW@4 ; lstrlenW(x)
.text$mn:00000591                 mov     [ebp+var_A8], eax
.text$mn:00000597                 mov     [ebp+var_94], 0
.text$mn:000005A1                 jmp     short loc_5B2
.text$mn:000005A3 ; ---------------------------------------------------------------------------
.text$mn:000005A3
.text$mn:000005A3 loc_5A3:                                ; CODE XREF: purgeMenuItemString(wchar_t const *,bool):loc_67Bj
.text$mn:000005A3                 mov     eax, [ebp+var_94]
.text$mn:000005A9                 add     eax, 1
.text$mn:000005AC                 mov     [ebp+var_94], eax
.text$mn:000005B2
.text$mn:000005B2 loc_5B2:                                ; CODE XREF: purgeMenuItemString(wchar_t const *,bool)+79j
.text$mn:000005B2                 mov     ecx, [ebp+var_94]
.text$mn:000005B8                 cmp     ecx, [ebp+var_A8]
.text$mn:000005BE                 jnb     loc_680
.text$mn:000005C4                 mov     edx, [ebp+var_94]
.text$mn:000005CA                 mov     eax, [ebp+lpString]
.text$mn:000005CD                 movzx   ecx, word ptr [eax+edx*2]
.text$mn:000005D1                 cmp     ecx, 9
.text$mn:000005D4                 jnz     short loc_60B
.text$mn:000005D6                 mov     edx, [ebp+var_94]
.text$mn:000005DC                 shl     edx, 1
.text$mn:000005DE                 mov     [ebp+var_A0], edx
.text$mn:000005E4                 cmp     [ebp+var_A0], 80h ; 'Ç'
.text$mn:000005EE                 jnb     short loc_5F2
.text$mn:000005F0                 jmp     short loc_5F7
.text$mn:000005F2 ; ---------------------------------------------------------------------------
.text$mn:000005F2
.text$mn:000005F2 loc_5F2:                                ; CODE XREF: purgeMenuItemString(wchar_t const *,bool)+C6j
.text$mn:000005F2                 call    ___report_rangecheckfailure
.text$mn:000005F7
.text$mn:000005F7 loc_5F7:                                ; CODE XREF: purgeMenuItemString(wchar_t const *,bool)+C8j
.text$mn:000005F7                 xor     eax, eax
.text$mn:000005F9                 mov     ecx, [ebp+var_A0]
.text$mn:000005FF                 mov     [ebp+ecx+Str], ax
.text$mn:00000607                 jmp     short loc_680
.text$mn:00000609 ; ---------------------------------------------------------------------------
.text$mn:00000609                 jmp     short loc_67B
.text$mn:0000060B ; ---------------------------------------------------------------------------
.text$mn:0000060B
.text$mn:0000060B loc_60B:                                ; CODE XREF: purgeMenuItemString(wchar_t const *,bool)+ACj
.text$mn:0000060B                 mov     edx, [ebp+var_94]
.text$mn:00000611                 mov     eax, [ebp+lpString]
.text$mn:00000614                 movzx   ecx, word ptr [eax+edx*2]
.text$mn:00000618                 cmp     ecx, 26h ; '&'
.text$mn:0000061B                 jnz     short loc_651
.text$mn:0000061D                 movzx   edx, [ebp+arg_8]
.text$mn:00000621                 test    edx, edx
.text$mn:00000623                 jz      short loc_64F
.text$mn:00000625                 mov     eax, [ebp+var_98]
.text$mn:0000062B                 mov     ecx, [ebp+var_94]
.text$mn:00000631                 mov     edx, [ebp+lpString]
.text$mn:00000634                 mov     cx, [edx+ecx*2]
.text$mn:00000638                 mov     [ebp+eax*2+Str], cx
.text$mn:00000640                 mov     edx, [ebp+var_98]
.text$mn:00000646                 add     edx, 1
.text$mn:00000649                 mov     [ebp+var_98], edx
.text$mn:0000064F
.text$mn:0000064F loc_64F:                                ; CODE XREF: purgeMenuItemString(wchar_t const *,bool)+FBj
.text$mn:0000064F                 jmp     short loc_67B
.text$mn:00000651 ; ---------------------------------------------------------------------------
.text$mn:00000651
.text$mn:00000651 loc_651:                                ; CODE XREF: purgeMenuItemString(wchar_t const *,bool)+F3j
.text$mn:00000651                 mov     eax, [ebp+var_98]
.text$mn:00000657                 mov     ecx, [ebp+var_94]
.text$mn:0000065D                 mov     edx, [ebp+lpString]
.text$mn:00000660                 mov     cx, [edx+ecx*2]
.text$mn:00000664                 mov     [ebp+eax*2+Str], cx
.text$mn:0000066C                 mov     edx, [ebp+var_98]
.text$mn:00000672                 add     edx, 1
.text$mn:00000675                 mov     [ebp+var_98], edx
.text$mn:0000067B
.text$mn:0000067B loc_67B:                                ; CODE XREF: purgeMenuItemString(wchar_t const *,bool)+E1j
.text$mn:0000067B                                         ; purgeMenuItemString(wchar_t const *,bool):loc_64Fj
.text$mn:0000067B                 jmp     loc_5A3
.text$mn:00000680 ; ---------------------------------------------------------------------------
.text$mn:00000680
.text$mn:00000680 loc_680:                                ; CODE XREF: purgeMenuItemString(wchar_t const *,bool)+96j
.text$mn:00000680                                         ; purgeMenuItemString(wchar_t const *,bool)+DFj
.text$mn:00000680                 mov     eax, [ebp+var_98]
.text$mn:00000686                 shl     eax, 1
.text$mn:00000688                 mov     [ebp+var_9C], eax
.text$mn:0000068E                 cmp     [ebp+var_9C], 80h ; 'Ç'
.text$mn:00000698                 jnb     short loc_69C
.text$mn:0000069A                 jmp     short loc_6A1
.text$mn:0000069C ; ---------------------------------------------------------------------------
.text$mn:0000069C
.text$mn:0000069C loc_69C:                                ; CODE XREF: purgeMenuItemString(wchar_t const *,bool)+170j
.text$mn:0000069C                 call    ___report_rangecheckfailure
.text$mn:000006A1
.text$mn:000006A1 loc_6A1:                                ; CODE XREF: purgeMenuItemString(wchar_t const *,bool)+172j
.text$mn:000006A1                 xor     ecx, ecx
.text$mn:000006A3                 mov     edx, [ebp+var_9C]
.text$mn:000006A9                 mov     [ebp+edx+Str], cx
.text$mn:000006B1                 lea     eax, [ebp+Str]
.text$mn:000006B7                 push    eax             ; Str
.text$mn:000006B8                 mov     ecx, [ebp+arg_0]
.text$mn:000006BB                 call    ??0?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QAE@PB_W@Z ; std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>>::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>>(wchar_t const *)
.text$mn:000006C0                 mov     [ebp+var_4], 0
.text$mn:000006C7                 mov     ecx, [ebp+var_A4]
.text$mn:000006CD                 or      ecx, 1
.text$mn:000006D0                 mov     [ebp+var_A4], ecx
.text$mn:000006D6                 mov     eax, [ebp+arg_0]
.text$mn:000006D9                 mov     ecx, [ebp+var_C]
.text$mn:000006DC                 mov     large fs:0, ecx
.text$mn:000006E3                 pop     ecx
.text$mn:000006E4                 mov     ecx, [ebp+var_10]
.text$mn:000006E7                 xor     ecx, ebp
.text$mn:000006E9                 call    @__security_check_cookie@4 ; __security_check_cookie(x)
.text$mn:000006EE                 mov     esp, ebp
.text$mn:000006F0                 pop     ebp
.text$mn:000006F1                 retn
.text$mn:000006F1 ?purgeMenuItemString@@YA?AV?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@PB_W_N@Z endp
.text$mn:000006F1
.text$mn:000006F1 ; ---------------------------------------------------------------------------
.text$mn:000006F2                 align 8
.text$mn:000006F8
.text$mn:000006F8 ; =============== S U B R O U T I N E =======================================
.text$mn:000006F8
.text$mn:000006F8 ; Attributes: bp-based frame
.text$mn:000006F8
.text$mn:000006F8 ; class std::vector<class std::basic_string<wchar_t, struct std::char_traits<wchar_t>, class std::allocator<wchar_t>>, class std::allocator<class std::basic_string<wchar_t, struct std::char_traits<wchar_t>, class std::allocator<wchar_t>>>> __cdecl tokenizeString(class std::basic_string<wchar_t, struct std::char_traits<wchar_t>, class std::allocator<wchar_t>> const &, char)
.text$mn:000006F8                 public ?tokenizeString@@YA?AV?$vector@V?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@V?$allocator@V?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@@2@@std@@ABV?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@2@D@Z
.text$mn:000006F8 ?tokenizeString@@YA?AV?$vector@V?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@V?$allocator@V?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@@2@@std@@ABV?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@2@D@Z proc near
.text$mn:000006F8
.text$mn:000006F8 var_50          = byte ptr -50h
.text$mn:000006F8 var_40          = dword ptr -40h
.text$mn:000006F8 var_3C          = dword ptr -3Ch
.text$mn:000006F8 var_38          = dword ptr -38h
.text$mn:000006F8 var_34          = dword ptr -34h
.text$mn:000006F8 var_30          = dword ptr -30h
.text$mn:000006F8 var_2C          = byte ptr -2Ch
.text$mn:000006F8 var_10          = dword ptr -10h
.text$mn:000006F8 var_C           = dword ptr -0Ch
.text$mn:000006F8 var_4           = dword ptr -4
.text$mn:000006F8 arg_0           = dword ptr  8
.text$mn:000006F8 arg_4           = dword ptr  0Ch
.text$mn:000006F8 arg_8           = byte ptr  10h
.text$mn:000006F8
.text$mn:000006F8                 push    ebp
.text$mn:000006F9                 mov     ebp, esp
.text$mn:000006FB                 push    0FFFFFFFFh
.text$mn:000006FD                 push    offset __ehhandler$?tokenizeString@@YA?AV?$vector@V?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@V?$allocator@V?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@@2@@std@@ABV?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@2@D@Z
.text$mn:00000702                 mov     eax, large fs:0
.text$mn:00000708                 push    eax
.text$mn:00000709                 sub     esp, 44h
.text$mn:0000070C                 mov     eax, dword ptr ds:___security_cookie
.text$mn:00000711                 xor     eax, ebp
.text$mn:00000713                 mov     [ebp+var_10], eax
.text$mn:00000716                 push    eax
.text$mn:00000717                 lea     eax, [ebp+var_C]
.text$mn:0000071A                 mov     large fs:0, eax
.text$mn:00000720                 mov     [ebp+var_38], 0
.text$mn:00000727                 lea     ecx, [ebp+var_50]
.text$mn:0000072A                 call    ??0?$vector@V?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@V?$allocator@V?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@@2@@std@@QAE@XZ ; std::vector<std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>>,std::allocator<std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>>>>::vector<std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>>,std::allocator<std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>>>>(void)
.text$mn:0000072F                 mov     [ebp+var_4], 1
.text$mn:00000736                 push    0
.text$mn:00000738                 movsx   ax, [ebp+arg_8]
.text$mn:0000073D                 movzx   ecx, ax
.text$mn:00000740                 push    ecx
.text$mn:00000741                 mov     ecx, [ebp+arg_4]
.text$mn:00000744                 call    ?find_first_not_of@?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QBEI_WI@Z ; std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>>::find_first_not_of(wchar_t,uint)
.text$mn:00000749                 mov     [ebp+var_30], eax
.text$mn:0000074C                 mov     edx, [ebp+var_30]
.text$mn:0000074F                 push    edx
.text$mn:00000750                 movsx   ax, [ebp+arg_8]
.text$mn:00000755                 movzx   ecx, ax
.text$mn:00000758                 push    ecx
.text$mn:00000759                 mov     ecx, [ebp+arg_4]
.text$mn:0000075C                 call    ?find_first_of@?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QBEI_WI@Z ; std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>>::find_first_of(wchar_t,uint)
.text$mn:00000761                 mov     [ebp+var_34], eax
.text$mn:00000764
.text$mn:00000764 loc_764:                                ; CODE XREF: tokenizeString(std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>> const &,char)+EEj
.text$mn:00000764                 mov     edx, [ebp+var_34]
.text$mn:00000767                 cmp     edx, ds:?npos@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@2IB ; uint const std::basic_string<char,std::char_traits<char>,std::allocator<char>>::npos
.text$mn:0000076D                 jnz     short loc_77A
.text$mn:0000076F                 mov     eax, [ebp+var_30]
.text$mn:00000772                 cmp     eax, ds:?npos@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@2IB ; uint const std::basic_string<char,std::char_traits<char>,std::allocator<char>>::npos
.text$mn:00000778                 jz      short loc_7EB
.text$mn:0000077A
.text$mn:0000077A loc_77A:                                ; CODE XREF: tokenizeString(std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>> const &,char)+75j
.text$mn:0000077A                 mov     ecx, [ebp+var_34]
.text$mn:0000077D                 sub     ecx, [ebp+var_30]
.text$mn:00000780                 push    ecx
.text$mn:00000781                 mov     edx, [ebp+var_30]
.text$mn:00000784                 push    edx
.text$mn:00000785                 lea     eax, [ebp+var_2C]
.text$mn:00000788                 push    eax
.text$mn:00000789                 mov     ecx, [ebp+arg_4]
.text$mn:0000078C                 call    ?substr@?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QBE?AV12@II@Z ; std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>>::substr(uint,uint)
.text$mn:00000791                 mov     [ebp+var_3C], eax
.text$mn:00000794                 mov     ecx, [ebp+var_3C]
.text$mn:00000797                 mov     [ebp+var_40], ecx
.text$mn:0000079A                 mov     byte ptr [ebp+var_4], 2
.text$mn:0000079E                 mov     edx, [ebp+var_40]
.text$mn:000007A1                 push    edx
.text$mn:000007A2                 lea     ecx, [ebp+var_50]
.text$mn:000007A5                 call    ?push_back@?$vector@V?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@V?$allocator@V?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@@2@@std@@QAEX$$QAV?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@2@@Z ; std::vector<std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>>,std::allocator<std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>>>>::push_back(std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>> &&)
.text$mn:000007AA                 mov     byte ptr [ebp+var_4], 1
.text$mn:000007AE                 lea     ecx, [ebp+var_2C]
.text$mn:000007B1                 call    ??1?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QAE@XZ ; std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>>::~basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>>(void)
.text$mn:000007B6                 mov     eax, [ebp+var_34]
.text$mn:000007B9                 push    eax
.text$mn:000007BA                 movsx   cx, [ebp+arg_8]
.text$mn:000007BF                 movzx   edx, cx
.text$mn:000007C2                 push    edx
.text$mn:000007C3                 mov     ecx, [ebp+arg_4]
.text$mn:000007C6                 call    ?find_first_not_of@?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QBEI_WI@Z ; std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>>::find_first_not_of(wchar_t,uint)
.text$mn:000007CB                 mov     [ebp+var_30], eax
.text$mn:000007CE                 mov     eax, [ebp+var_30]
.text$mn:000007D1                 push    eax
.text$mn:000007D2                 movsx   cx, [ebp+arg_8]
.text$mn:000007D7                 movzx   edx, cx
.text$mn:000007DA                 push    edx
.text$mn:000007DB                 mov     ecx, [ebp+arg_4]
.text$mn:000007DE                 call    ?find_first_of@?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QBEI_WI@Z ; std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>>::find_first_of(wchar_t,uint)
.text$mn:000007E3                 mov     [ebp+var_34], eax
.text$mn:000007E6                 jmp     loc_764
.text$mn:000007EB ; ---------------------------------------------------------------------------
.text$mn:000007EB
.text$mn:000007EB loc_7EB:                                ; CODE XREF: tokenizeString(std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>> const &,char)+80j
.text$mn:000007EB                 lea     eax, [ebp+var_50]
.text$mn:000007EE                 push    eax
.text$mn:000007EF                 mov     ecx, [ebp+arg_0]
.text$mn:000007F2                 call    ??0?$vector@V?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@V?$allocator@V?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@@2@@std@@QAE@$$QAV01@@Z ; std::vector<std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>>,std::allocator<std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>>>>::vector<std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>>,std::allocator<std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>>>>(std::vector<std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>>,std::allocator<std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>>>> &&)
.text$mn:000007F7                 mov     ecx, [ebp+var_38]
.text$mn:000007FA                 or      ecx, 1
.text$mn:000007FD                 mov     [ebp+var_38], ecx
.text$mn:00000800                 mov     byte ptr [ebp+var_4], 0
.text$mn:00000804                 lea     ecx, [ebp+var_50]
.text$mn:00000807                 call    ??1?$vector@V?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@V?$allocator@V?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@@2@@std@@QAE@XZ ; std::vector<std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>>,std::allocator<std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>>>>::~vector<std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>>,std::allocator<std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>>>>(void)
.text$mn:0000080C                 mov     eax, [ebp+arg_0]
.text$mn:0000080F                 mov     ecx, [ebp+var_C]
.text$mn:00000812                 mov     large fs:0, ecx
.text$mn:00000819                 pop     ecx
.text$mn:0000081A                 mov     ecx, [ebp+var_10]
.text$mn:0000081D                 xor     ecx, ebp
.text$mn:0000081F                 call    @__security_check_cookie@4 ; __security_check_cookie(x)
.text$mn:00000824                 mov     esp, ebp
.text$mn:00000826                 pop     ebp
.text$mn:00000827                 retn
.text$mn:00000827 ?tokenizeString@@YA?AV?$vector@V?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@V?$allocator@V?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@@2@@std@@ABV?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@2@D@Z endp
.text$mn:00000827
.text$mn:00000828
.text$mn:00000828 ; =============== S U B R O U T I N E =======================================
.text$mn:00000828
.text$mn:00000828 ; Attributes: bp-based frame
.text$mn:00000828
.text$mn:00000828 ; void __cdecl ClientRectToScreenRect(HWND hWnd, struct tagRECT *)
.text$mn:00000828                 public ?ClientRectToScreenRect@@YAXPAUHWND__@@PAUtagRECT@@@Z
.text$mn:00000828 ?ClientRectToScreenRect@@YAXPAUHWND__@@PAUtagRECT@@@Z proc near
.text$mn:00000828
.text$mn:00000828 Point           = tagPOINT ptr -8
.text$mn:00000828 hWnd            = dword ptr  8
.text$mn:00000828 arg_4           = dword ptr  0Ch
.text$mn:00000828
.text$mn:00000828                 push    ebp
.text$mn:00000829                 mov     ebp, esp
.text$mn:0000082B                 sub     esp, 8
.text$mn:0000082E                 mov     eax, [ebp+arg_4]
.text$mn:00000831                 mov     ecx, [eax]
.text$mn:00000833                 mov     [ebp+Point.x], ecx
.text$mn:00000836                 mov     edx, [ebp+arg_4]
.text$mn:00000839                 mov     eax, [edx+4]
.text$mn:0000083C                 mov     [ebp+Point.y], eax
.text$mn:0000083F                 lea     ecx, [ebp+Point]
.text$mn:00000842                 push    ecx             ; lpPoint
.text$mn:00000843                 mov     edx, [ebp+hWnd]
.text$mn:00000846                 push    edx             ; hWnd
.text$mn:00000847                 call    dword ptr ds:__imp__ClientToScreen@8 ; ClientToScreen(x,x)
.text$mn:0000084D                 mov     eax, [ebp+arg_4]
.text$mn:00000850                 mov     ecx, [ebp+Point.x]
.text$mn:00000853                 mov     [eax], ecx
.text$mn:00000855                 mov     edx, [ebp+arg_4]
.text$mn:00000858                 mov     eax, [ebp+Point.y]
.text$mn:0000085B                 mov     [edx+4], eax
.text$mn:0000085E                 mov     ecx, [ebp+arg_4]
.text$mn:00000861                 mov     edx, [ecx+8]
.text$mn:00000864                 mov     [ebp+Point.x], edx
.text$mn:00000867                 mov     eax, [ebp+arg_4]
.text$mn:0000086A                 mov     ecx, [eax+0Ch]
.text$mn:0000086D                 mov     [ebp+Point.y], ecx
.text$mn:00000870                 lea     edx, [ebp+Point]
.text$mn:00000873                 push    edx             ; lpPoint
.text$mn:00000874                 mov     eax, [ebp+hWnd]
.text$mn:00000877                 push    eax             ; hWnd
.text$mn:00000878                 call    dword ptr ds:__imp__ClientToScreen@8 ; ClientToScreen(x,x)
.text$mn:0000087E                 mov     ecx, [ebp+arg_4]
.text$mn:00000881                 mov     edx, [ebp+Point.x]
.text$mn:00000884                 mov     [ecx+8], edx
.text$mn:00000887                 mov     eax, [ebp+arg_4]
.text$mn:0000088A                 mov     ecx, [ebp+Point.y]
.text$mn:0000088D                 mov     [eax+0Ch], ecx
.text$mn:00000890                 mov     esp, ebp
.text$mn:00000892                 pop     ebp
.text$mn:00000893                 retn
.text$mn:00000893 ?ClientRectToScreenRect@@YAXPAUHWND__@@PAUtagRECT@@@Z endp
.text$mn:00000893
.text$mn:00000893 ; ---------------------------------------------------------------------------
.text$mn:00000894                 align 8
.text$mn:00000898
.text$mn:00000898 ; =============== S U B R O U T I N E =======================================
.text$mn:00000898
.text$mn:00000898 ; Attributes: bp-based frame
.text$mn:00000898
.text$mn:00000898 ; void __cdecl ScreenRectToClientRect(HWND hWnd, struct tagRECT *)
.text$mn:00000898                 public ?ScreenRectToClientRect@@YAXPAUHWND__@@PAUtagRECT@@@Z
.text$mn:00000898 ?ScreenRectToClientRect@@YAXPAUHWND__@@PAUtagRECT@@@Z proc near
.text$mn:00000898
.text$mn:00000898 Point           = tagPOINT ptr -8
.text$mn:00000898 hWnd            = dword ptr  8
.text$mn:00000898 arg_4           = dword ptr  0Ch
.text$mn:00000898
.text$mn:00000898                 push    ebp
.text$mn:00000899                 mov     ebp, esp
.text$mn:0000089B                 sub     esp, 8
.text$mn:0000089E                 mov     eax, [ebp+arg_4]
.text$mn:000008A1                 mov     ecx, [eax]
.text$mn:000008A3                 mov     [ebp+Point.x], ecx
.text$mn:000008A6                 mov     edx, [ebp+arg_4]
.text$mn:000008A9                 mov     eax, [edx+4]
.text$mn:000008AC                 mov     [ebp+Point.y], eax
.text$mn:000008AF                 lea     ecx, [ebp+Point]
.text$mn:000008B2                 push    ecx             ; lpPoint
.text$mn:000008B3                 mov     edx, [ebp+hWnd]
.text$mn:000008B6                 push    edx             ; hWnd
.text$mn:000008B7                 call    dword ptr ds:__imp__ScreenToClient@8 ; ScreenToClient(x,x)
.text$mn:000008BD                 mov     eax, [ebp+arg_4]
.text$mn:000008C0                 mov     ecx, [ebp+Point.x]
.text$mn:000008C3                 mov     [eax], ecx
.text$mn:000008C5                 mov     edx, [ebp+arg_4]
.text$mn:000008C8                 mov     eax, [ebp+Point.y]
.text$mn:000008CB                 mov     [edx+4], eax
.text$mn:000008CE                 mov     ecx, [ebp+arg_4]
.text$mn:000008D1                 mov     edx, [ecx+8]
.text$mn:000008D4                 mov     [ebp+Point.x], edx
.text$mn:000008D7                 mov     eax, [ebp+arg_4]
.text$mn:000008DA                 mov     ecx, [eax+0Ch]
.text$mn:000008DD                 mov     [ebp+Point.y], ecx
.text$mn:000008E0                 lea     edx, [ebp+Point]
.text$mn:000008E3                 push    edx             ; lpPoint
.text$mn:000008E4                 mov     eax, [ebp+hWnd]
.text$mn:000008E7                 push    eax             ; hWnd
.text$mn:000008E8                 call    dword ptr ds:__imp__ScreenToClient@8 ; ScreenToClient(x,x)
.text$mn:000008EE                 mov     ecx, [ebp+arg_4]
.text$mn:000008F1                 mov     edx, [ebp+Point.x]
.text$mn:000008F4                 mov     [ecx+8], edx
.text$mn:000008F7                 mov     eax, [ebp+arg_4]
.text$mn:000008FA                 mov     ecx, [ebp+Point.y]
.text$mn:000008FD                 mov     [eax+0Ch], ecx
.text$mn:00000900                 mov     esp, ebp
.text$mn:00000902                 pop     ebp
.text$mn:00000903                 retn
.text$mn:00000903 ?ScreenRectToClientRect@@YAXPAUHWND__@@PAUtagRECT@@@Z endp
.text$mn:00000903
.text$mn:00000903 ; ---------------------------------------------------------------------------
.text$mn:00000904                 align 8
.text$mn:00000908
.text$mn:00000908 ; =============== S U B R O U T I N E =======================================
.text$mn:00000908
.text$mn:00000908 ; Attributes: bp-based frame
.text$mn:00000908
.text$mn:00000908 ; int __cdecl string2wstring(int, int, UINT CodePage)
.text$mn:00000908                 public ?string2wstring@@YA?AV?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@ABV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@2@I@Z
.text$mn:00000908 ?string2wstring@@YA?AV?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@ABV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@2@I@Z proc near
.text$mn:00000908
.text$mn:00000908 var_24          = byte ptr -24h
.text$mn:00000908 cchWideChar     = dword ptr -14h
.text$mn:00000908 var_10          = dword ptr -10h
.text$mn:00000908 var_C           = dword ptr -0Ch
.text$mn:00000908 var_4           = dword ptr -4
.text$mn:00000908 arg_0           = dword ptr  8
.text$mn:00000908 arg_4           = dword ptr  0Ch
.text$mn:00000908 CodePage        = dword ptr  10h
.text$mn:00000908
.text$mn:00000908                 push    ebp
.text$mn:00000909                 mov     ebp, esp
.text$mn:0000090B                 push    0FFFFFFFFh
.text$mn:0000090D                 push    offset __ehhandler$?string2wstring@@YA?AV?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@ABV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@2@I@Z
.text$mn:00000912                 mov     eax, large fs:0
.text$mn:00000918                 push    eax
.text$mn:00000919                 sub     esp, 18h
.text$mn:0000091C                 mov     eax, dword ptr ds:___security_cookie
.text$mn:00000921                 xor     eax, ebp
.text$mn:00000923                 push    eax
.text$mn:00000924                 lea     eax, [ebp+var_C]
.text$mn:00000927                 mov     large fs:0, eax
.text$mn:0000092D                 mov     [ebp+var_10], 0
.text$mn:00000934                 push    0               ; cchWideChar
.text$mn:00000936                 push    0               ; lpWideCharStr
.text$mn:00000938                 push    0FFFFFFFFh      ; cbMultiByte
.text$mn:0000093A                 mov     ecx, [ebp+arg_4]
.text$mn:0000093D                 call    ?c_str@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QBEPBDXZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char>>::c_str(void)
.text$mn:00000942                 push    eax             ; lpMultiByteStr
.text$mn:00000943                 push    0               ; dwFlags
.text$mn:00000945                 mov     eax, [ebp+CodePage]
.text$mn:00000948                 push    eax             ; CodePage
.text$mn:00000949                 call    dword ptr ds:__imp__MultiByteToWideChar@24 ; MultiByteToWideChar(x,x,x,x,x,x)
.text$mn:0000094F                 mov     [ebp+cchWideChar], eax
.text$mn:00000952                 cmp     [ebp+cchWideChar], 0
.text$mn:00000956                 jle     short loc_9C0
.text$mn:00000958                 mov     ecx, [ebp+cchWideChar]
.text$mn:0000095B                 push    ecx
.text$mn:0000095C                 lea     ecx, [ebp+var_24]
.text$mn:0000095F                 call    ??0?$vector@_WV?$allocator@_W@std@@@std@@QAE@I@Z ; std::vector<wchar_t,std::allocator<wchar_t>>::vector<wchar_t,std::allocator<wchar_t>>(uint)
.text$mn:00000964                 mov     [ebp+var_4], 1
.text$mn:0000096B                 mov     edx, [ebp+cchWideChar]
.text$mn:0000096E                 push    edx             ; cchWideChar
.text$mn:0000096F                 push    0
.text$mn:00000971                 lea     ecx, [ebp+var_24]
.text$mn:00000974                 call    ??A?$vector@_WV?$allocator@_W@std@@@std@@QAEAA_WI@Z ; std::vector<wchar_t,std::allocator<wchar_t>>::operator[](uint)
.text$mn:00000979                 push    eax             ; lpWideCharStr
.text$mn:0000097A                 push    0FFFFFFFFh      ; cbMultiByte
.text$mn:0000097C                 mov     ecx, [ebp+arg_4]
.text$mn:0000097F                 call    ?c_str@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QBEPBDXZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char>>::c_str(void)
.text$mn:00000984                 push    eax             ; lpMultiByteStr
.text$mn:00000985                 push    0               ; dwFlags
.text$mn:00000987                 mov     eax, [ebp+CodePage]
.text$mn:0000098A                 push    eax             ; CodePage
.text$mn:0000098B                 call    dword ptr ds:__imp__MultiByteToWideChar@24 ; MultiByteToWideChar(x,x,x,x,x,x)
.text$mn:00000991                 push    0
.text$mn:00000993                 lea     ecx, [ebp+var_24]
.text$mn:00000996                 call    ??A?$vector@_WV?$allocator@_W@std@@@std@@QAEAA_WI@Z ; std::vector<wchar_t,std::allocator<wchar_t>>::operator[](uint)
.text$mn:0000099B                 push    eax             ; Str
.text$mn:0000099C                 mov     ecx, [ebp+arg_0]
.text$mn:0000099F                 call    ??0?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QAE@PB_W@Z ; std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>>::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>>(wchar_t const *)
.text$mn:000009A4                 mov     ecx, [ebp+var_10]
.text$mn:000009A7                 or      ecx, 1
.text$mn:000009AA                 mov     [ebp+var_10], ecx
.text$mn:000009AD                 mov     byte ptr [ebp+var_4], 0
.text$mn:000009B1                 lea     ecx, [ebp+var_24]
.text$mn:000009B4                 call    ??1?$vector@_WV?$allocator@_W@std@@@std@@QAE@XZ ; std::vector<wchar_t,std::allocator<wchar_t>>::~vector<wchar_t,std::allocator<wchar_t>>(void)
.text$mn:000009B9                 mov     eax, [ebp+arg_0]
.text$mn:000009BC                 jmp     short loc_9E0
.text$mn:000009BE ; ---------------------------------------------------------------------------
.text$mn:000009BE                 jmp     short loc_9E0
.text$mn:000009C0 ; ---------------------------------------------------------------------------
.text$mn:000009C0
.text$mn:000009C0 loc_9C0:                                ; CODE XREF: string2wstring(std::basic_string<char,std::char_traits<char>,std::allocator<char>> const &,uint)+4Ej
.text$mn:000009C0                 push    offset $SG117823 ; Str
.text$mn:000009C5                 mov     ecx, [ebp+arg_0]
.text$mn:000009C8                 call    ??0?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QAE@PB_W@Z ; std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>>::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>>(wchar_t const *)
.text$mn:000009CD                 mov     [ebp+var_4], 0
.text$mn:000009D4                 mov     edx, [ebp+var_10]
.text$mn:000009D7                 or      edx, 1
.text$mn:000009DA                 mov     [ebp+var_10], edx
.text$mn:000009DD                 mov     eax, [ebp+arg_0]
.text$mn:000009E0
.text$mn:000009E0 loc_9E0:                                ; CODE XREF: string2wstring(std::basic_string<char,std::char_traits<char>,std::allocator<char>> const &,uint)+B4j
.text$mn:000009E0                                         ; string2wstring(std::basic_string<char,std::char_traits<char>,std::allocator<char>> const &,uint)+B6j
.text$mn:000009E0                 mov     ecx, [ebp+var_C]
.text$mn:000009E3                 mov     large fs:0, ecx
.text$mn:000009EA                 pop     ecx
.text$mn:000009EB                 mov     esp, ebp
.text$mn:000009ED                 pop     ebp
.text$mn:000009EE                 retn
.text$mn:000009EE ?string2wstring@@YA?AV?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@ABV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@2@I@Z endp
.text$mn:000009EE
.text$mn:000009EE ; ---------------------------------------------------------------------------
.text$mn:000009EF                 db 9 dup(0CCh)
.text$mn:000009F8
.text$mn:000009F8 ; =============== S U B R O U T I N E =======================================
.text$mn:000009F8
.text$mn:000009F8 ; Attributes: bp-based frame
.text$mn:000009F8
.text$mn:000009F8 ; int __cdecl wstring2string(int, int, UINT CodePage)
.text$mn:000009F8                 public ?wstring2string@@YA?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@ABV?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@2@I@Z
.text$mn:000009F8 ?wstring2string@@YA?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@ABV?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@2@I@Z proc near
.text$mn:000009F8
.text$mn:000009F8 var_24          = byte ptr -24h
.text$mn:000009F8 cbMultiByte     = dword ptr -14h
.text$mn:000009F8 var_10          = dword ptr -10h
.text$mn:000009F8 var_C           = dword ptr -0Ch
.text$mn:000009F8 var_4           = dword ptr -4
.text$mn:000009F8 arg_0           = dword ptr  8
.text$mn:000009F8 arg_4           = dword ptr  0Ch
.text$mn:000009F8 CodePage        = dword ptr  10h
.text$mn:000009F8
.text$mn:000009F8                 push    ebp
.text$mn:000009F9                 mov     ebp, esp
.text$mn:000009FB                 push    0FFFFFFFFh
.text$mn:000009FD                 push    offset __ehhandler$?wstring2string@@YA?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@ABV?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@2@I@Z
.text$mn:00000A02                 mov     eax, large fs:0
.text$mn:00000A08                 push    eax
.text$mn:00000A09                 sub     esp, 18h
.text$mn:00000A0C                 mov     eax, dword ptr ds:___security_cookie
.text$mn:00000A11                 xor     eax, ebp
.text$mn:00000A13                 push    eax
.text$mn:00000A14                 lea     eax, [ebp+var_C]
.text$mn:00000A17                 mov     large fs:0, eax
.text$mn:00000A1D                 mov     [ebp+var_10], 0
.text$mn:00000A24                 push    0               ; lpUsedDefaultChar
.text$mn:00000A26                 push    0               ; lpDefaultChar
.text$mn:00000A28                 push    0               ; cbMultiByte
.text$mn:00000A2A                 push    0               ; lpMultiByteStr
.text$mn:00000A2C                 push    0FFFFFFFFh      ; cchWideChar
.text$mn:00000A2E                 mov     ecx, [ebp+arg_4]
.text$mn:00000A31                 call    ?c_str@?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QBEPB_WXZ ; std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>>::c_str(void)
.text$mn:00000A36                 push    eax             ; lpWideCharStr
.text$mn:00000A37                 push    0               ; dwFlags
.text$mn:00000A39                 mov     eax, [ebp+CodePage]
.text$mn:00000A3C                 push    eax             ; CodePage
.text$mn:00000A3D                 call    dword ptr ds:__imp__WideCharToMultiByte@32 ; WideCharToMultiByte(x,x,x,x,x,x,x,x)
.text$mn:00000A43                 mov     [ebp+cbMultiByte], eax
.text$mn:00000A46                 cmp     [ebp+cbMultiByte], 0
.text$mn:00000A4A                 jle     short loc_AB8
.text$mn:00000A4C                 mov     ecx, [ebp+cbMultiByte]
.text$mn:00000A4F                 push    ecx             ; Size
.text$mn:00000A50                 lea     ecx, [ebp+var_24]
.text$mn:00000A53                 call    ??0?$vector@DV?$allocator@D@std@@@std@@QAE@I@Z ; std::vector<char,std::allocator<char>>::vector<char,std::allocator<char>>(uint)
.text$mn:00000A58                 mov     [ebp+var_4], 1
.text$mn:00000A5F                 push    0               ; lpUsedDefaultChar
.text$mn:00000A61                 push    0               ; lpDefaultChar
.text$mn:00000A63                 mov     edx, [ebp+cbMultiByte]
.text$mn:00000A66                 push    edx             ; cbMultiByte
.text$mn:00000A67                 push    0
.text$mn:00000A69                 lea     ecx, [ebp+var_24]
.text$mn:00000A6C                 call    ??A?$vector@DV?$allocator@D@std@@@std@@QAEAADI@Z ; std::vector<char,std::allocator<char>>::operator[](uint)
.text$mn:00000A71                 push    eax             ; lpMultiByteStr
.text$mn:00000A72                 push    0FFFFFFFFh      ; cchWideChar
.text$mn:00000A74                 mov     ecx, [ebp+arg_4]
.text$mn:00000A77                 call    ?c_str@?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QBEPB_WXZ ; std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>>::c_str(void)
.text$mn:00000A7C                 push    eax             ; lpWideCharStr
.text$mn:00000A7D                 push    0               ; dwFlags
.text$mn:00000A7F                 mov     eax, [ebp+CodePage]
.text$mn:00000A82                 push    eax             ; CodePage
.text$mn:00000A83                 call    dword ptr ds:__imp__WideCharToMultiByte@32 ; WideCharToMultiByte(x,x,x,x,x,x,x,x)
.text$mn:00000A89                 push    0
.text$mn:00000A8B                 lea     ecx, [ebp+var_24]
.text$mn:00000A8E                 call    ??A?$vector@DV?$allocator@D@std@@@std@@QAEAADI@Z ; std::vector<char,std::allocator<char>>::operator[](uint)
.text$mn:00000A93                 push    eax             ; Str
.text$mn:00000A94                 mov     ecx, [ebp+arg_0]
.text$mn:00000A97                 call    ??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@PBD@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char>>::basic_string<char,std::char_traits<char>,std::allocator<char>>(char const *)
.text$mn:00000A9C                 mov     ecx, [ebp+var_10]
.text$mn:00000A9F                 or      ecx, 1
.text$mn:00000AA2                 mov     [ebp+var_10], ecx
.text$mn:00000AA5                 mov     byte ptr [ebp+var_4], 0
.text$mn:00000AA9                 lea     ecx, [ebp+var_24]
.text$mn:00000AAC                 call    ??1?$vector@DV?$allocator@D@std@@@std@@QAE@XZ ; std::vector<char,std::allocator<char>>::~vector<char,std::allocator<char>>(void)
.text$mn:00000AB1                 mov     eax, [ebp+arg_0]
.text$mn:00000AB4                 jmp     short loc_AD8
.text$mn:00000AB6 ; ---------------------------------------------------------------------------
.text$mn:00000AB6                 jmp     short loc_AD8
.text$mn:00000AB8 ; ---------------------------------------------------------------------------
.text$mn:00000AB8
.text$mn:00000AB8 loc_AB8:                                ; CODE XREF: wstring2string(std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>> const &,uint)+52j
.text$mn:00000AB8                 push    offset $SG118184 ; Str
.text$mn:00000ABD                 mov     ecx, [ebp+arg_0]
.text$mn:00000AC0                 call    ??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@PBD@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char>>::basic_string<char,std::char_traits<char>,std::allocator<char>>(char const *)
.text$mn:00000AC5                 mov     [ebp+var_4], 0
.text$mn:00000ACC                 mov     edx, [ebp+var_10]
.text$mn:00000ACF                 or      edx, 1
.text$mn:00000AD2                 mov     [ebp+var_10], edx
.text$mn:00000AD5                 mov     eax, [ebp+arg_0]
.text$mn:00000AD8
.text$mn:00000AD8 loc_AD8:                                ; CODE XREF: wstring2string(std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>> const &,uint)+BCj
.text$mn:00000AD8                                         ; wstring2string(std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>> const &,uint)+BEj
.text$mn:00000AD8                 mov     ecx, [ebp+var_C]
.text$mn:00000ADB                 mov     large fs:0, ecx
.text$mn:00000AE2                 pop     ecx
.text$mn:00000AE3                 mov     esp, ebp
.text$mn:00000AE5                 pop     ebp
.text$mn:00000AE6                 retn
.text$mn:00000AE6 ?wstring2string@@YA?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@ABV?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@2@I@Z endp ; sp-analysis failed
.text$mn:00000AE6
.text$mn:00000AE6 ; ---------------------------------------------------------------------------
.text$mn:00000AE7                 align 4
.text$mn:00000AE8
.text$mn:00000AE8 ; =============== S U B R O U T I N E =======================================
.text$mn:00000AE8
.text$mn:00000AE8 ; Attributes: bp-based frame
.text$mn:00000AE8
.text$mn:00000AE8 ; bool __cdecl isInList(const wchar_t *Str1, LPCWSTR lpString)
.text$mn:00000AE8                 public ?isInList@@YA_NPB_W0@Z
.text$mn:00000AE8 ?isInList@@YA_NPB_W0@Z proc near
.text$mn:00000AE8
.text$mn:00000AE8 var_94          = dword ptr -94h
.text$mn:00000AE8 var_90          = dword ptr -90h
.text$mn:00000AE8 var_8C          = dword ptr -8Ch
.text$mn:00000AE8 var_88          = dword ptr -88h
.text$mn:00000AE8 Str2            = word ptr -84h
.text$mn:00000AE8 var_4           = dword ptr -4
.text$mn:00000AE8 Str1            = dword ptr  8
.text$mn:00000AE8 lpString        = dword ptr  0Ch
.text$mn:00000AE8
.text$mn:00000AE8                 push    ebp
.text$mn:00000AE9                 mov     ebp, esp
.text$mn:00000AEB                 sub     esp, 94h
.text$mn:00000AF1                 mov     eax, dword ptr ds:___security_cookie
.text$mn:00000AF6                 xor     eax, ebp
.text$mn:00000AF8                 mov     [ebp+var_4], eax
.text$mn:00000AFB                 cmp     [ebp+Str1], 0
.text$mn:00000AFF                 jz      short loc_B07
.text$mn:00000B01                 cmp     [ebp+lpString], 0
.text$mn:00000B05                 jnz     short loc_B0E
.text$mn:00000B07
.text$mn:00000B07 loc_B07:                                ; CODE XREF: isInList(wchar_t const *,wchar_t const *)+17j
.text$mn:00000B07                 xor     al, al
.text$mn:00000B09                 jmp     loc_C0A
.text$mn:00000B0E ; ---------------------------------------------------------------------------
.text$mn:00000B0E
.text$mn:00000B0E loc_B0E:                                ; CODE XREF: isInList(wchar_t const *,wchar_t const *)+1Dj
.text$mn:00000B0E                 mov     [ebp+var_8C], 0
.text$mn:00000B18                 mov     [ebp+var_88], 0
.text$mn:00000B22                 mov     eax, [ebp+lpString]
.text$mn:00000B25                 push    eax             ; lpString
.text$mn:00000B26                 call    dword ptr ds:__imp__lstrlenW@4 ; lstrlenW(x)
.text$mn:00000B2C                 mov     [ebp+var_94], eax
.text$mn:00000B32                 jmp     short loc_B43
.text$mn:00000B34 ; ---------------------------------------------------------------------------
.text$mn:00000B34
.text$mn:00000B34 loc_B34:                                ; CODE XREF: isInList(wchar_t const *,wchar_t const *):loc_C03j
.text$mn:00000B34                 mov     ecx, [ebp+var_8C]
.text$mn:00000B3A                 add     ecx, 1
.text$mn:00000B3D                 mov     [ebp+var_8C], ecx
.text$mn:00000B43
.text$mn:00000B43 loc_B43:                                ; CODE XREF: isInList(wchar_t const *,wchar_t const *)+4Aj
.text$mn:00000B43                 mov     edx, [ebp+var_8C]
.text$mn:00000B49                 cmp     edx, [ebp+var_94]
.text$mn:00000B4F                 ja      loc_C08
.text$mn:00000B55                 mov     eax, [ebp+var_8C]
.text$mn:00000B5B                 mov     ecx, [ebp+lpString]
.text$mn:00000B5E                 movzx   edx, word ptr [ecx+eax*2]
.text$mn:00000B62                 cmp     edx, 20h ; ' '
.text$mn:00000B65                 jz      short loc_B78
.text$mn:00000B67                 mov     eax, [ebp+var_8C]
.text$mn:00000B6D                 mov     ecx, [ebp+lpString]
.text$mn:00000B70                 movzx   edx, word ptr [ecx+eax*2]
.text$mn:00000B74                 test    edx, edx
.text$mn:00000B76                 jnz     short loc_BD9
.text$mn:00000B78
.text$mn:00000B78 loc_B78:                                ; CODE XREF: isInList(wchar_t const *,wchar_t const *)+7Dj
.text$mn:00000B78                 cmp     [ebp+var_88], 0
.text$mn:00000B7F                 jz      short loc_BD7
.text$mn:00000B81                 mov     eax, [ebp+var_88]
.text$mn:00000B87                 shl     eax, 1
.text$mn:00000B89                 mov     [ebp+var_90], eax
.text$mn:00000B8F                 cmp     [ebp+var_90], 80h ; 'Ç'
.text$mn:00000B99                 jnb     short loc_B9D
.text$mn:00000B9B                 jmp     short loc_BA2
.text$mn:00000B9D ; ---------------------------------------------------------------------------
.text$mn:00000B9D
.text$mn:00000B9D loc_B9D:                                ; CODE XREF: isInList(wchar_t const *,wchar_t const *)+B1j
.text$mn:00000B9D                 call    ___report_rangecheckfailure
.text$mn:00000BA2
.text$mn:00000BA2 loc_BA2:                                ; CODE XREF: isInList(wchar_t const *,wchar_t const *)+B3j
.text$mn:00000BA2                 xor     ecx, ecx
.text$mn:00000BA4                 mov     edx, [ebp+var_90]
.text$mn:00000BAA                 mov     [ebp+edx+Str2], cx
.text$mn:00000BB2                 mov     [ebp+var_88], 0
.text$mn:00000BBC                 lea     eax, [ebp+Str2]
.text$mn:00000BC2                 push    eax             ; Str2
.text$mn:00000BC3                 mov     ecx, [ebp+Str1]
.text$mn:00000BC6                 push    ecx             ; Str1
.text$mn:00000BC7                 call    _wcsicmp
.text$mn:00000BCC                 add     esp, 8
.text$mn:00000BCF                 test    eax, eax
.text$mn:00000BD1                 jnz     short loc_BD7
.text$mn:00000BD3                 mov     al, 1
.text$mn:00000BD5                 jmp     short loc_C0A
.text$mn:00000BD7 ; ---------------------------------------------------------------------------
.text$mn:00000BD7
.text$mn:00000BD7 loc_BD7:                                ; CODE XREF: isInList(wchar_t const *,wchar_t const *)+97j
.text$mn:00000BD7                                         ; isInList(wchar_t const *,wchar_t const *)+E9j
.text$mn:00000BD7                 jmp     short loc_C03
.text$mn:00000BD9 ; ---------------------------------------------------------------------------
.text$mn:00000BD9
.text$mn:00000BD9 loc_BD9:                                ; CODE XREF: isInList(wchar_t const *,wchar_t const *)+8Ej
.text$mn:00000BD9                 mov     edx, [ebp+var_88]
.text$mn:00000BDF                 mov     eax, [ebp+var_8C]
.text$mn:00000BE5                 mov     ecx, [ebp+lpString]
.text$mn:00000BE8                 mov     ax, [ecx+eax*2]
.text$mn:00000BEC                 mov     [ebp+edx*2+Str2], ax
.text$mn:00000BF4                 mov     ecx, [ebp+var_88]
.text$mn:00000BFA                 add     ecx, 1
.text$mn:00000BFD                 mov     [ebp+var_88], ecx
.text$mn:00000C03
.text$mn:00000C03 loc_C03:                                ; CODE XREF: isInList(wchar_t const *,wchar_t const *):loc_BD7j
.text$mn:00000C03                 jmp     loc_B34
.text$mn:00000C08 ; ---------------------------------------------------------------------------
.text$mn:00000C08
.text$mn:00000C08 loc_C08:                                ; CODE XREF: isInList(wchar_t const *,wchar_t const *)+67j
.text$mn:00000C08                 xor     al, al
.text$mn:00000C0A
.text$mn:00000C0A loc_C0A:                                ; CODE XREF: isInList(wchar_t const *,wchar_t const *)+21j
.text$mn:00000C0A                                         ; isInList(wchar_t const *,wchar_t const *)+EDj
.text$mn:00000C0A                 mov     ecx, [ebp+var_4]
.text$mn:00000C0D                 xor     ecx, ebp
.text$mn:00000C0F                 call    @__security_check_cookie@4 ; __security_check_cookie(x)
.text$mn:00000C14                 mov     esp, ebp
.text$mn:00000C16                 pop     ebp
.text$mn:00000C17                 retn
.text$mn:00000C17 ?isInList@@YA_NPB_W0@Z endp
.text$mn:00000C17
.text$mn:00000C18
.text$mn:00000C18 ; =============== S U B R O U T I N E =======================================
.text$mn:00000C18
.text$mn:00000C18 ; Attributes: bp-based frame
.text$mn:00000C18
.text$mn:00000C18 ; class std::basic_string<wchar_t, struct std::char_traits<wchar_t>, class std::allocator<wchar_t>> __cdecl BuildMenuFileName(int, unsigned int, class std::basic_string<wchar_t, struct std::char_traits<wchar_t>, class std::allocator<wchar_t>> const &)
.text$mn:00000C18                 public ?BuildMenuFileName@@YA?AV?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@HIABV12@@Z
.text$mn:00000C18 ?BuildMenuFileName@@YA?AV?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@HIABV12@@Z proc near
.text$mn:00000C18
.text$mn:00000C18 var_1B8         = byte ptr -1B8h
.text$mn:00000C18 var_1AC         = byte ptr -1ACh
.text$mn:00000C18 var_1A0         = byte ptr -1A0h
.text$mn:00000C18 var_194         = byte ptr -194h
.text$mn:00000C18 var_188         = dword ptr -188h
.text$mn:00000C18 var_184         = dword ptr -184h
.text$mn:00000C18 var_180         = dword ptr -180h
.text$mn:00000C18 var_17C         = dword ptr -17Ch
.text$mn:00000C18 var_178         = dword ptr -178h
.text$mn:00000C18 var_174         = dword ptr -174h
.text$mn:00000C18 var_170         = dword ptr -170h
.text$mn:00000C18 var_16C         = dword ptr -16Ch
.text$mn:00000C18 var_168         = dword ptr -168h
.text$mn:00000C18 var_164         = dword ptr -164h
.text$mn:00000C18 var_160         = dword ptr -160h
.text$mn:00000C18 var_15C         = dword ptr -15Ch
.text$mn:00000C18 var_158         = dword ptr -158h
.text$mn:00000C18 var_154         = dword ptr -154h
.text$mn:00000C18 var_150         = dword ptr -150h
.text$mn:00000C18 var_14C         = dword ptr -14Ch
.text$mn:00000C18 var_148         = byte ptr -148h
.text$mn:00000C18 var_138         = dword ptr -138h
.text$mn:00000C18 var_134         = dword ptr -134h
.text$mn:00000C18 var_130         = dword ptr -130h
.text$mn:00000C18 var_12C         = dword ptr -12Ch
.text$mn:00000C18 var_128         = dword ptr -128h
.text$mn:00000C18 var_124         = dword ptr -124h
.text$mn:00000C18 var_120         = dword ptr -120h
.text$mn:00000C18 var_11C         = dword ptr -11Ch
.text$mn:00000C18 var_118         = dword ptr -118h
.text$mn:00000C18 var_114         = dword ptr -114h
.text$mn:00000C18 var_110         = dword ptr -110h
.text$mn:00000C18 var_10C         = dword ptr -10Ch
.text$mn:00000C18 var_108         = dword ptr -108h
.text$mn:00000C18 var_104         = dword ptr -104h
.text$mn:00000C18 var_100         = dword ptr -100h
.text$mn:00000C18 var_FC          = dword ptr -0FCh
.text$mn:00000C18 var_F8          = dword ptr -0F8h
.text$mn:00000C18 var_F4          = dword ptr -0F4h
.text$mn:00000C18 var_F0          = dword ptr -0F0h
.text$mn:00000C18 var_EC          = dword ptr -0ECh
.text$mn:00000C18 var_E8          = dword ptr -0E8h
.text$mn:00000C18 var_E4          = dword ptr -0E4h
.text$mn:00000C18 var_E0          = dword ptr -0E0h
.text$mn:00000C18 var_DC          = dword ptr -0DCh
.text$mn:00000C18 var_D8          = dword ptr -0D8h
.text$mn:00000C18 var_D4          = dword ptr -0D4h
.text$mn:00000C18 var_D0          = byte ptr -0D0h
.text$mn:00000C18 var_C4          = dword ptr -0C4h
.text$mn:00000C18 var_C0          = dword ptr -0C0h
.text$mn:00000C18 var_B9          = byte ptr -0B9h
.text$mn:00000C18 var_B8          = byte ptr -0B8h
.text$mn:00000C18 var_9C          = byte ptr -9Ch
.text$mn:00000C18 var_80          = byte ptr -80h
.text$mn:00000C18 var_64          = byte ptr -64h
.text$mn:00000C18 var_48          = byte ptr -48h
.text$mn:00000C18 var_2C          = byte ptr -2Ch
.text$mn:00000C18 var_10          = dword ptr -10h
.text$mn:00000C18 var_C           = dword ptr -0Ch
.text$mn:00000C18 var_4           = dword ptr -4
.text$mn:00000C18 arg_0           = dword ptr  8
.text$mn:00000C18 arg_4           = dword ptr  0Ch
.text$mn:00000C18 arg_8           = dword ptr  10h
.text$mn:00000C18 arg_C           = dword ptr  14h
.text$mn:00000C18
.text$mn:00000C18                 push    ebp
.text$mn:00000C19                 mov     ebp, esp
.text$mn:00000C1B                 push    0FFFFFFFFh
.text$mn:00000C1D                 push    offset __ehhandler$?BuildMenuFileName@@YA?AV?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@HIABV12@@Z
.text$mn:00000C22                 mov     eax, large fs:0
.text$mn:00000C28                 push    eax
.text$mn:00000C29                 sub     esp, 1ACh
.text$mn:00000C2F                 mov     eax, dword ptr ds:___security_cookie
.text$mn:00000C34                 xor     eax, ebp
.text$mn:00000C36                 mov     [ebp+var_10], eax
.text$mn:00000C39                 push    esi
.text$mn:00000C3A                 push    eax
.text$mn:00000C3B                 lea     eax, [ebp+var_C]
.text$mn:00000C3E                 mov     large fs:0, eax
.text$mn:00000C44                 mov     [ebp+var_C4], 0
.text$mn:00000C4E                 lea     ecx, [ebp+var_2C]
.text$mn:00000C51                 call    ??0?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QAE@XZ ; std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>>::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>>(void)
.text$mn:00000C56                 mov     [ebp+var_4], 1
.text$mn:00000C5D                 cmp     [ebp+arg_8], 9
.text$mn:00000C61                 jnb     short loc_C7F
.text$mn:00000C63                 push    26h ; '&'
.text$mn:00000C65                 lea     ecx, [ebp+var_2C]
.text$mn:00000C68                 call    ?push_back@?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QAEX_W@Z ; std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>>::push_back(wchar_t)
.text$mn:00000C6D                 movzx   eax, word ptr [ebp+arg_8]
.text$mn:00000C71                 add     eax, 31h ; '1'
.text$mn:00000C74                 push    eax
.text$mn:00000C75                 lea     ecx, [ebp+var_2C]
.text$mn:00000C78                 call    ?push_back@?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QAEX_W@Z ; std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>>::push_back(wchar_t)
.text$mn:00000C7D                 jmp     short loc_CDE
.text$mn:00000C7F ; ---------------------------------------------------------------------------
.text$mn:00000C7F
.text$mn:00000C7F loc_C7F:                                ; CODE XREF: BuildMenuFileName(int,uint,std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>> const &)+49j
.text$mn:00000C7F                 cmp     [ebp+arg_8], 9
.text$mn:00000C83                 jnz     short loc_C94
.text$mn:00000C85                 push    offset $SG118718 ; "1&0"
.text$mn:00000C8A                 lea     ecx, [ebp+var_2C]
.text$mn:00000C8D                 call    ?append@?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QAEAAV12@PB_W@Z ; std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>>::append(wchar_t const *)
.text$mn:00000C92                 jmp     short loc_CDE
.text$mn:00000C94 ; ---------------------------------------------------------------------------
.text$mn:00000C94
.text$mn:00000C94 loc_C94:                                ; CODE XREF: BuildMenuFileName(int,uint,std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>> const &)+6Bj
.text$mn:00000C94                 mov     ecx, [ebp+arg_8]
.text$mn:00000C97                 add     ecx, 1
.text$mn:00000C9A                 push    ecx
.text$mn:00000C9B                 lea     edx, [ebp+var_9C]
.text$mn:00000CA1                 push    edx
.text$mn:00000CA2                 call    ?uintToString@@YA?AV?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@I@Z ; uintToString(uint)
.text$mn:00000CA7                 add     esp, 8
.text$mn:00000CAA                 mov     [ebp+var_FC], eax
.text$mn:00000CB0                 mov     eax, [ebp+var_FC]
.text$mn:00000CB6                 mov     [ebp+var_10C], eax
.text$mn:00000CBC                 mov     byte ptr [ebp+var_4], 2
.text$mn:00000CC0                 mov     ecx, [ebp+var_10C]
.text$mn:00000CC6                 push    ecx
.text$mn:00000CC7                 lea     ecx, [ebp+var_2C]
.text$mn:00000CCA                 call    ?append@?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QAEAAV12@ABV12@@Z ; std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>>::append(std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>> const &)
.text$mn:00000CCF                 mov     byte ptr [ebp+var_4], 1
.text$mn:00000CD3                 lea     ecx, [ebp+var_9C]
.text$mn:00000CD9                 call    ??1?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QAE@XZ ; std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>>::~basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>>(void)
.text$mn:00000CDE
.text$mn:00000CDE loc_CDE:                                ; CODE XREF: BuildMenuFileName(int,uint,std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>> const &)+65j
.text$mn:00000CDE                                         ; BuildMenuFileName(int,uint,std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>> const &)+7Aj
.text$mn:00000CDE                 push    offset $SG118721 ; ": "
.text$mn:00000CE3                 lea     ecx, [ebp+var_2C]
.text$mn:00000CE6                 call    ?append@?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QAEAAV12@PB_W@Z ; std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>>::append(wchar_t const *)
.text$mn:00000CEB                 cmp     [ebp+arg_4], 0
.text$mn:00000CEF                 jle     loc_E32
.text$mn:00000CF5                 mov     edx, [ebp+arg_4]
.text$mn:00000CF8                 add     edx, 1
.text$mn:00000CFB                 push    edx
.text$mn:00000CFC                 lea     ecx, [ebp+var_148]
.text$mn:00000D02                 call    ??0?$vector@_WV?$allocator@_W@std@@@std@@QAE@I@Z ; std::vector<wchar_t,std::allocator<wchar_t>>::vector<wchar_t,std::allocator<wchar_t>>(uint)
.text$mn:00000D07                 mov     byte ptr [ebp+var_4], 3
.text$mn:00000D0B                 push    0               ; dwFlags
.text$mn:00000D0D                 mov     eax, [ebp+arg_4]
.text$mn:00000D10                 add     eax, 1
.text$mn:00000D13                 push    eax             ; cchMax
.text$mn:00000D14                 mov     ecx, [ebp+arg_C]
.text$mn:00000D17                 call    ?c_str@?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QBEPB_WXZ ; std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>>::c_str(void)
.text$mn:00000D1C                 push    eax             ; pszSrc
.text$mn:00000D1D                 push    0
.text$mn:00000D1F                 lea     ecx, [ebp+var_148]
.text$mn:00000D25                 call    ??A?$vector@_WV?$allocator@_W@std@@@std@@QAEAA_WI@Z ; std::vector<wchar_t,std::allocator<wchar_t>>::operator[](uint)
.text$mn:00000D2A                 push    eax             ; pszOut
.text$mn:00000D2B                 call    dword ptr ds:__imp__PathCompactPathExW@16 ; PathCompactPathExW(x,x,x,x)
.text$mn:00000D31                 push    0
.text$mn:00000D33                 lea     ecx, [ebp+var_148]
.text$mn:00000D39                 call    ??A?$vector@_WV?$allocator@_W@std@@@std@@QAEAA_WI@Z ; std::vector<wchar_t,std::allocator<wchar_t>>::operator[](uint)
.text$mn:00000D3E                 push    eax             ; lpString
.text$mn:00000D3F                 call    dword ptr ds:__imp__lstrlenW@4 ; lstrlenW(x)
.text$mn:00000D45                 sub     esp, 0Ch
.text$mn:00000D48                 mov     ecx, esp
.text$mn:00000D4A                 mov     [ebp+var_170], esp
.text$mn:00000D50                 push    eax
.text$mn:00000D51                 push    ecx
.text$mn:00000D52                 lea     edx, [ebp+var_1B8]
.text$mn:00000D58                 push    edx
.text$mn:00000D59                 lea     ecx, [ebp+var_148]
.text$mn:00000D5F                 call    ?begin@?$vector@_WV?$allocator@_W@std@@@std@@QAE?AV?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@_W@std@@@std@@@2@XZ ; std::vector<wchar_t,std::allocator<wchar_t>>::begin(void)
.text$mn:00000D64                 mov     [ebp+var_120], eax
.text$mn:00000D6A                 mov     eax, [ebp+var_120]
.text$mn:00000D70                 mov     [ebp+var_128], eax
.text$mn:00000D76                 mov     byte ptr [ebp+var_4], 4
.text$mn:00000D7A                 mov     ecx, [ebp+var_128]
.text$mn:00000D80                 call    ??H?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@_W@std@@@std@@@std@@QBE?AV01@H@Z ; std::_Vector_iterator<std::_Vector_val<std::_Simple_types<wchar_t>>>::operator+(int)
.text$mn:00000D85                 mov     [ebp+var_130], eax
.text$mn:00000D8B                 mov     ecx, [ebp+var_130]
.text$mn:00000D91                 mov     [ebp+var_150], ecx
.text$mn:00000D97                 mov     byte ptr [ebp+var_4], 5
.text$mn:00000D9B                 sub     esp, 0Ch
.text$mn:00000D9E                 mov     edx, esp
.text$mn:00000DA0                 mov     [ebp+var_160], esp
.text$mn:00000DA6                 push    edx
.text$mn:00000DA7                 lea     ecx, [ebp+var_148]
.text$mn:00000DAD                 call    ?begin@?$vector@_WV?$allocator@_W@std@@@std@@QAE?AV?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@_W@std@@@std@@@2@XZ ; std::vector<wchar_t,std::allocator<wchar_t>>::begin(void)
.text$mn:00000DB2                 mov     [ebp+var_138], eax
.text$mn:00000DB8                 mov     eax, [ebp+var_138]
.text$mn:00000DBE                 mov     [ebp+var_168], eax
.text$mn:00000DC4                 mov     byte ptr [ebp+var_4], 6
.text$mn:00000DC8                 lea     ecx, [ebp+var_B8]
.text$mn:00000DCE                 push    ecx
.text$mn:00000DCF                 mov     byte ptr [ebp+var_4], 4
.text$mn:00000DD3                 call    ??$convertFileName@V?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@_W@std@@@std@@@std@@@@YA?AV?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@V?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@_W@std@@@std@@@1@0@Z ; convertFileName<std::_Vector_iterator<std::_Vector_val<std::_Simple_types<wchar_t>>>>(std::_Vector_iterator<std::_Vector_val<std::_Simple_types<wchar_t>>>,std::_Vector_iterator<std::_Vector_val<std::_Simple_types<wchar_t>>>)
.text$mn:00000DD8                 add     esp, 1Ch
.text$mn:00000DDB                 mov     [ebp+var_134], eax
.text$mn:00000DE1                 mov     edx, [ebp+var_134]
.text$mn:00000DE7                 mov     [ebp+var_124], edx
.text$mn:00000DED                 mov     byte ptr [ebp+var_4], 7
.text$mn:00000DF1                 mov     eax, [ebp+var_124]
.text$mn:00000DF7                 push    eax
.text$mn:00000DF8                 lea     ecx, [ebp+var_2C]
.text$mn:00000DFB                 call    ?append@?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QAEAAV12@ABV12@@Z ; std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>>::append(std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>> const &)
.text$mn:00000E00                 mov     byte ptr [ebp+var_4], 4
.text$mn:00000E04                 lea     ecx, [ebp+var_B8]
.text$mn:00000E0A                 call    ??1?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QAE@XZ ; std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>>::~basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>>(void)
.text$mn:00000E0F                 mov     byte ptr [ebp+var_4], 3
.text$mn:00000E13                 lea     ecx, [ebp+var_1B8]
.text$mn:00000E19                 call    ??1?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@_W@std@@@std@@@std@@QAE@XZ ; std::_Vector_iterator<std::_Vector_val<std::_Simple_types<wchar_t>>>::~_Vector_iterator<std::_Vector_val<std::_Simple_types<wchar_t>>>(void)
.text$mn:00000E1E                 mov     byte ptr [ebp+var_4], 1
.text$mn:00000E22                 lea     ecx, [ebp+var_148]
.text$mn:00000E28                 call    ??1?$vector@_WV?$allocator@_W@std@@@std@@QAE@XZ ; std::vector<wchar_t,std::allocator<wchar_t>>::~vector<wchar_t,std::allocator<wchar_t>>(void)
.text$mn:00000E2D                 jmp     loc_1155
.text$mn:00000E32 ; ---------------------------------------------------------------------------
.text$mn:00000E32
.text$mn:00000E32 loc_E32:                                ; CODE XREF: BuildMenuFileName(int,uint,std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>> const &)+D7j
.text$mn:00000E32                 lea     ecx, [ebp+var_D0]
.text$mn:00000E38                 push    ecx
.text$mn:00000E39                 mov     ecx, [ebp+arg_C]
.text$mn:00000E3C                 call    ?begin@?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QBE?AV?$_String_const_iterator@V?$_String_val@U?$_Simple_types@_W@std@@@std@@@2@XZ ; std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>>::begin(void)
.text$mn:00000E41                 mov     byte ptr [ebp+var_4], 8
.text$mn:00000E45                 cmp     [ebp+arg_4], 0
.text$mn:00000E49                 jnz     short loc_E74
.text$mn:00000E4B                 mov     ecx, [ebp+arg_C]
.text$mn:00000E4E                 call    ?c_str@?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QBEPB_WXZ ; std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>>::c_str(void)
.text$mn:00000E53                 push    eax             ; pszPath
.text$mn:00000E54                 call    dword ptr ds:__imp__PathFindFileNameW@4 ; PathFindFileNameW(x)
.text$mn:00000E5A                 mov     esi, eax
.text$mn:00000E5C                 mov     ecx, [ebp+arg_C]
.text$mn:00000E5F                 call    ?c_str@?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QBEPB_WXZ ; std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>>::c_str(void)
.text$mn:00000E64                 sub     esi, eax
.text$mn:00000E66                 sar     esi, 1
.text$mn:00000E68                 push    esi
.text$mn:00000E69                 lea     ecx, [ebp+var_D0]
.text$mn:00000E6F                 call    ??Y?$_String_const_iterator@V?$_String_val@U?$_Simple_types@_W@std@@@std@@@std@@QAEAAV01@H@Z ; std::_String_const_iterator<std::_String_val<std::_Simple_types<wchar_t>>>::operator+=(int)
.text$mn:00000E74
.text$mn:00000E74 loc_E74:                                ; CODE XREF: BuildMenuFileName(int,uint,std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>> const &)+231j
.text$mn:00000E74                 lea     edx, [ebp+var_D0]
.text$mn:00000E7A                 push    edx             ; std::_Iterator_base12 *
.text$mn:00000E7B                 lea     eax, [ebp+var_194]
.text$mn:00000E81                 push    eax
.text$mn:00000E82                 mov     ecx, [ebp+arg_C]
.text$mn:00000E85                 call    ?end@?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QBE?AV?$_String_const_iterator@V?$_String_val@U?$_Simple_types@_W@std@@@std@@@2@XZ ; std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>>::end(void)
.text$mn:00000E8A                 mov     [ebp+var_104], eax
.text$mn:00000E90                 mov     ecx, [ebp+var_104]
.text$mn:00000E96                 mov     [ebp+var_E0], ecx
.text$mn:00000E9C                 mov     byte ptr [ebp+var_4], 9
.text$mn:00000EA0                 mov     ecx, [ebp+var_E0]
.text$mn:00000EA6                 call    ??G?$_String_const_iterator@V?$_String_val@U?$_Simple_types@_W@std@@@std@@@std@@QBEHABV01@@Z ; std::_String_const_iterator<std::_String_val<std::_Simple_types<wchar_t>>>::operator-(std::_String_const_iterator<std::_String_val<std::_Simple_types<wchar_t>>> const &)
.text$mn:00000EAB                 cmp     eax, 104h
.text$mn:00000EB0                 jge     short loc_EBE
.text$mn:00000EB2                 mov     [ebp+var_C0], 1
.text$mn:00000EBC                 jmp     short loc_EC8
.text$mn:00000EBE ; ---------------------------------------------------------------------------
.text$mn:00000EBE
.text$mn:00000EBE loc_EBE:                                ; CODE XREF: BuildMenuFileName(int,uint,std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>> const &)+298j
.text$mn:00000EBE                 mov     [ebp+var_C0], 0
.text$mn:00000EC8
.text$mn:00000EC8 loc_EC8:                                ; CODE XREF: BuildMenuFileName(int,uint,std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>> const &)+2A4j
.text$mn:00000EC8                 mov     dl, byte ptr [ebp+var_C0]
.text$mn:00000ECE                 mov     [ebp+var_B9], dl
.text$mn:00000ED4                 mov     byte ptr [ebp+var_4], 8
.text$mn:00000ED8                 lea     ecx, [ebp+var_194]
.text$mn:00000EDE                 call    ??1?$_String_const_iterator@V?$_String_val@U?$_Simple_types@_W@std@@@std@@@std@@QAE@XZ ; std::_String_const_iterator<std::_String_val<std::_Simple_types<wchar_t>>>::~_String_const_iterator<std::_String_val<std::_Simple_types<wchar_t>>>(void)
.text$mn:00000EE3                 movzx   eax, [ebp+var_B9]
.text$mn:00000EEA                 test    eax, eax
.text$mn:00000EEC                 jz      loc_F8F
.text$mn:00000EF2                 sub     esp, 0Ch
.text$mn:00000EF5                 mov     ecx, esp
.text$mn:00000EF7                 mov     [ebp+var_14C], esp
.text$mn:00000EFD                 push    ecx
.text$mn:00000EFE                 mov     ecx, [ebp+arg_C]
.text$mn:00000F01                 call    ?end@?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QBE?AV?$_String_const_iterator@V?$_String_val@U?$_Simple_types@_W@std@@@std@@@2@XZ ; std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>>::end(void)
.text$mn:00000F06                 mov     [ebp+var_110], eax
.text$mn:00000F0C                 mov     edx, [ebp+var_110]
.text$mn:00000F12                 mov     [ebp+var_178], edx
.text$mn:00000F18                 mov     byte ptr [ebp+var_4], 0Ah
.text$mn:00000F1C                 sub     esp, 0Ch
.text$mn:00000F1F                 mov     ecx, esp
.text$mn:00000F21                 mov     [ebp+var_180], esp
.text$mn:00000F27                 lea     eax, [ebp+var_D0]
.text$mn:00000F2D                 push    eax             ; struct std::_Iterator_base12 *
.text$mn:00000F2E                 call    ??0?$_String_const_iterator@V?$_String_val@U?$_Simple_types@_W@std@@@std@@@std@@QAE@ABV01@@Z ; std::_String_const_iterator<std::_String_val<std::_Simple_types<wchar_t>>>::_String_const_iterator<std::_String_val<std::_Simple_types<wchar_t>>>(std::_String_const_iterator<std::_String_val<std::_Simple_types<wchar_t>>> const &)
.text$mn:00000F33                 mov     [ebp+var_E8], eax
.text$mn:00000F39                 mov     ecx, [ebp+var_E8]
.text$mn:00000F3F                 mov     [ebp+var_188], ecx
.text$mn:00000F45                 mov     byte ptr [ebp+var_4], 0Bh
.text$mn:00000F49                 lea     edx, [ebp+var_80]
.text$mn:00000F4C                 push    edx
.text$mn:00000F4D                 mov     byte ptr [ebp+var_4], 8
.text$mn:00000F51                 call    ??$convertFileName@V?$_String_const_iterator@V?$_String_val@U?$_Simple_types@_W@std@@@std@@@std@@@@YA?AV?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@V?$_String_const_iterator@V?$_String_val@U?$_Simple_types@_W@std@@@std@@@1@0@Z ; convertFileName<std::_String_const_iterator<std::_String_val<std::_Simple_types<wchar_t>>>>(std::_String_const_iterator<std::_String_val<std::_Simple_types<wchar_t>>>,std::_String_const_iterator<std::_String_val<std::_Simple_types<wchar_t>>>)
.text$mn:00000F56                 add     esp, 1Ch
.text$mn:00000F59                 mov     [ebp+var_114], eax
.text$mn:00000F5F                 mov     eax, [ebp+var_114]
.text$mn:00000F65                 mov     [ebp+var_F0], eax
.text$mn:00000F6B                 mov     byte ptr [ebp+var_4], 0Ch
.text$mn:00000F6F                 mov     ecx, [ebp+var_F0]
.text$mn:00000F75                 push    ecx
.text$mn:00000F76                 lea     ecx, [ebp+var_2C]
.text$mn:00000F79                 call    ?append@?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QAEAAV12@ABV12@@Z ; std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>>::append(std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>> const &)
.text$mn:00000F7E                 mov     byte ptr [ebp+var_4], 8
.text$mn:00000F82                 lea     ecx, [ebp+var_80]
.text$mn:00000F85                 call    ??1?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QAE@XZ ; std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>>::~basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>>(void)
.text$mn:00000F8A                 jmp     loc_1146
.text$mn:00000F8F ; ---------------------------------------------------------------------------
.text$mn:00000F8F
.text$mn:00000F8F loc_F8F:                                ; CODE XREF: BuildMenuFileName(int,uint,std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>> const &)+2D4j
.text$mn:00000F8F                 sub     esp, 0Ch
.text$mn:00000F92                 mov     edx, esp
.text$mn:00000F94                 mov     [ebp+var_154], esp
.text$mn:00000F9A                 push    3
.text$mn:00000F9C                 push    edx
.text$mn:00000F9D                 push    82h ; 'é'
.text$mn:00000FA2                 lea     eax, [ebp+var_1AC]
.text$mn:00000FA8                 push    eax
.text$mn:00000FA9                 lea     ecx, [ebp+var_D0]
.text$mn:00000FAF                 call    ??H?$_String_const_iterator@V?$_String_val@U?$_Simple_types@_W@std@@@std@@@std@@QBE?AV01@H@Z ; std::_String_const_iterator<std::_String_val<std::_Simple_types<wchar_t>>>::operator+(int)
.text$mn:00000FB4                 mov     [ebp+var_118], eax
.text$mn:00000FBA                 mov     ecx, [ebp+var_118]
.text$mn:00000FC0                 mov     [ebp+var_F8], ecx
.text$mn:00000FC6                 mov     byte ptr [ebp+var_4], 0Dh
.text$mn:00000FCA                 mov     ecx, [ebp+var_F8]
.text$mn:00000FD0                 call    ??G?$_String_const_iterator@V?$_String_val@U?$_Simple_types@_W@std@@@std@@@std@@QBE?AV01@H@Z ; std::_String_const_iterator<std::_String_val<std::_Simple_types<wchar_t>>>::operator-(int)
.text$mn:00000FD5                 mov     [ebp+var_11C], eax
.text$mn:00000FDB                 mov     edx, [ebp+var_11C]
.text$mn:00000FE1                 mov     [ebp+var_158], edx
.text$mn:00000FE7                 mov     byte ptr [ebp+var_4], 0Eh
.text$mn:00000FEB                 sub     esp, 0Ch
.text$mn:00000FEE                 mov     ecx, esp
.text$mn:00000FF0                 mov     [ebp+var_17C], esp
.text$mn:00000FF6                 lea     eax, [ebp+var_D0]
.text$mn:00000FFC                 push    eax             ; struct std::_Iterator_base12 *
.text$mn:00000FFD                 call    ??0?$_String_const_iterator@V?$_String_val@U?$_Simple_types@_W@std@@@std@@@std@@QAE@ABV01@@Z ; std::_String_const_iterator<std::_String_val<std::_Simple_types<wchar_t>>>::_String_const_iterator<std::_String_val<std::_Simple_types<wchar_t>>>(std::_String_const_iterator<std::_String_val<std::_Simple_types<wchar_t>>> const &)
.text$mn:00001002                 mov     [ebp+var_100], eax
.text$mn:00001008                 mov     ecx, [ebp+var_100]
.text$mn:0000100E                 mov     [ebp+var_15C], ecx
.text$mn:00001014                 mov     byte ptr [ebp+var_4], 0Fh
.text$mn:00001018                 lea     edx, [ebp+var_64]
.text$mn:0000101B                 push    edx
.text$mn:0000101C                 mov     byte ptr [ebp+var_4], 0Dh
.text$mn:00001020                 call    ??$convertFileName@V?$_String_const_iterator@V?$_String_val@U?$_Simple_types@_W@std@@@std@@@std@@@@YA?AV?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@V?$_String_const_iterator@V?$_String_val@U?$_Simple_types@_W@std@@@std@@@1@0@Z ; convertFileName<std::_String_const_iterator<std::_String_val<std::_Simple_types<wchar_t>>>>(std::_String_const_iterator<std::_String_val<std::_Simple_types<wchar_t>>>,std::_String_const_iterator<std::_String_val<std::_Simple_types<wchar_t>>>)
.text$mn:00001025                 add     esp, 1Ch
.text$mn:00001028                 mov     [ebp+var_12C], eax
.text$mn:0000102E                 mov     eax, [ebp+var_12C]
.text$mn:00001034                 mov     [ebp+var_108], eax
.text$mn:0000103A                 mov     byte ptr [ebp+var_4], 10h
.text$mn:0000103E                 mov     ecx, [ebp+var_108]
.text$mn:00001044                 push    ecx
.text$mn:00001045                 lea     ecx, [ebp+var_2C]
.text$mn:00001048                 call    ?append@?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QAEAAV12@ABV12@@Z ; std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>>::append(std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>> const &)
.text$mn:0000104D                 mov     byte ptr [ebp+var_4], 0Dh
.text$mn:00001051                 lea     ecx, [ebp+var_64]
.text$mn:00001054                 call    ??1?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QAE@XZ ; std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>>::~basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>>(void)
.text$mn:00001059                 mov     byte ptr [ebp+var_4], 8
.text$mn:0000105D                 lea     ecx, [ebp+var_1AC]
.text$mn:00001063                 call    ??1?$_String_const_iterator@V?$_String_val@U?$_Simple_types@_W@std@@@std@@@std@@QAE@XZ ; std::_String_const_iterator<std::_String_val<std::_Simple_types<wchar_t>>>::~_String_const_iterator<std::_String_val<std::_Simple_types<wchar_t>>>(void)
.text$mn:00001068                 push    offset $SG118761 ; "..."
.text$mn:0000106D                 lea     ecx, [ebp+var_2C]
.text$mn:00001070                 call    ?append@?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QAEAAV12@PB_W@Z ; std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>>::append(wchar_t const *)
.text$mn:00001075                 sub     esp, 0Ch
.text$mn:00001078                 mov     edx, esp
.text$mn:0000107A                 mov     [ebp+var_174], esp
.text$mn:00001080                 push    edx
.text$mn:00001081                 mov     ecx, [ebp+arg_C]
.text$mn:00001084                 call    ?end@?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QBE?AV?$_String_const_iterator@V?$_String_val@U?$_Simple_types@_W@std@@@std@@@2@XZ ; std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>>::end(void)
.text$mn:00001089                 mov     [ebp+var_D8], eax
.text$mn:0000108F                 mov     eax, [ebp+var_D8]
.text$mn:00001095                 mov     [ebp+var_164], eax
.text$mn:0000109B                 mov     byte ptr [ebp+var_4], 11h
.text$mn:0000109F                 sub     esp, 0Ch
.text$mn:000010A2                 mov     ecx, esp
.text$mn:000010A4                 mov     [ebp+var_184], esp
.text$mn:000010AA                 push    82h ; 'é'
.text$mn:000010AF                 push    ecx
.text$mn:000010B0                 lea     edx, [ebp+var_1A0]
.text$mn:000010B6                 push    edx
.text$mn:000010B7                 mov     ecx, [ebp+arg_C]
.text$mn:000010BA                 call    ?end@?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QBE?AV?$_String_const_iterator@V?$_String_val@U?$_Simple_types@_W@std@@@std@@@2@XZ ; std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>>::end(void)
.text$mn:000010BF                 mov     [ebp+var_DC], eax
.text$mn:000010C5                 mov     eax, [ebp+var_DC]
.text$mn:000010CB                 mov     [ebp+var_E4], eax
.text$mn:000010D1                 mov     byte ptr [ebp+var_4], 12h
.text$mn:000010D5                 mov     ecx, [ebp+var_E4]
.text$mn:000010DB                 call    ??G?$_String_const_iterator@V?$_String_val@U?$_Simple_types@_W@std@@@std@@@std@@QBE?AV01@H@Z ; std::_String_const_iterator<std::_String_val<std::_Simple_types<wchar_t>>>::operator-(int)
.text$mn:000010E0                 mov     [ebp+var_EC], eax
.text$mn:000010E6                 mov     ecx, [ebp+var_EC]
.text$mn:000010EC                 mov     [ebp+var_16C], ecx
.text$mn:000010F2                 mov     byte ptr [ebp+var_4], 13h
.text$mn:000010F6                 lea     edx, [ebp+var_48]
.text$mn:000010F9                 push    edx
.text$mn:000010FA                 mov     byte ptr [ebp+var_4], 14h
.text$mn:000010FE                 call    ??$convertFileName@V?$_String_const_iterator@V?$_String_val@U?$_Simple_types@_W@std@@@std@@@std@@@@YA?AV?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@V?$_String_const_iterator@V?$_String_val@U?$_Simple_types@_W@std@@@std@@@1@0@Z ; convertFileName<std::_String_const_iterator<std::_String_val<std::_Simple_types<wchar_t>>>>(std::_String_const_iterator<std::_String_val<std::_Simple_types<wchar_t>>>,std::_String_const_iterator<std::_String_val<std::_Simple_types<wchar_t>>>)
.text$mn:00001103                 add     esp, 1Ch
.text$mn:00001106                 mov     [ebp+var_F4], eax
.text$mn:0000110C                 mov     eax, [ebp+var_F4]
.text$mn:00001112                 mov     [ebp+var_D4], eax
.text$mn:00001118                 mov     byte ptr [ebp+var_4], 15h
.text$mn:0000111C                 mov     ecx, [ebp+var_D4]
.text$mn:00001122                 push    ecx
.text$mn:00001123                 lea     ecx, [ebp+var_2C]
.text$mn:00001126                 call    ?append@?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QAEAAV12@ABV12@@Z ; std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>>::append(std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>> const &)
.text$mn:0000112B                 mov     byte ptr [ebp+var_4], 14h
.text$mn:0000112F                 lea     ecx, [ebp+var_48]
.text$mn:00001132                 call    ??1?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QAE@XZ ; std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>>::~basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>>(void)
.text$mn:00001137                 mov     byte ptr [ebp+var_4], 8
.text$mn:0000113B                 lea     ecx, [ebp+var_1A0]
.text$mn:00001141                 call    ??1?$_String_const_iterator@V?$_String_val@U?$_Simple_types@_W@std@@@std@@@std@@QAE@XZ ; std::_String_const_iterator<std::_String_val<std::_Simple_types<wchar_t>>>::~_String_const_iterator<std::_String_val<std::_Simple_types<wchar_t>>>(void)
.text$mn:00001146
.text$mn:00001146 loc_1146:                               ; CODE XREF: BuildMenuFileName(int,uint,std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>> const &)+372j
.text$mn:00001146                 mov     byte ptr [ebp+var_4], 1
.text$mn:0000114A                 lea     ecx, [ebp+var_D0]
.text$mn:00001150                 call    ??1?$_String_const_iterator@V?$_String_val@U?$_Simple_types@_W@std@@@std@@@std@@QAE@XZ ; std::_String_const_iterator<std::_String_val<std::_Simple_types<wchar_t>>>::~_String_const_iterator<std::_String_val<std::_Simple_types<wchar_t>>>(void)
.text$mn:00001155
.text$mn:00001155 loc_1155:                               ; CODE XREF: BuildMenuFileName(int,uint,std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>> const &)+215j
.text$mn:00001155                 lea     edx, [ebp+var_2C]
.text$mn:00001158                 push    edx
.text$mn:00001159                 mov     ecx, [ebp+arg_0]
.text$mn:0000115C                 call    ??0?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QAE@$$QAV01@@Z ; std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>>::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>>(std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>> &&)
.text$mn:00001161                 mov     eax, [ebp+var_C4]
.text$mn:00001167                 or      eax, 1
.text$mn:0000116A                 mov     [ebp+var_C4], eax
.text$mn:00001170                 mov     byte ptr [ebp+var_4], 0
.text$mn:00001174                 lea     ecx, [ebp+var_2C]
.text$mn:00001177                 call    ??1?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QAE@XZ ; std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>>::~basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>>(void)
.text$mn:0000117C                 mov     eax, [ebp+arg_0]
.text$mn:0000117F                 mov     ecx, [ebp+var_C]
.text$mn:00001182                 mov     large fs:0, ecx
.text$mn:00001189                 pop     ecx
.text$mn:0000118A                 pop     esi
.text$mn:0000118B                 mov     ecx, [ebp+var_10]
.text$mn:0000118E                 xor     ecx, ebp
.text$mn:00001190                 call    @__security_check_cookie@4 ; __security_check_cookie(x)
.text$mn:00001195                 mov     esp, ebp
.text$mn:00001197                 pop     ebp
.text$mn:00001198                 retn
.text$mn:00001198 ?BuildMenuFileName@@YA?AV?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@HIABV12@@Z endp
.text$mn:00001198
.text$mn:00001198 ; ---------------------------------------------------------------------------
.text$mn:00001199                 db 0Fh dup(0CCh)
.text$mn:000011A8
.text$mn:000011A8 ; =============== S U B R O U T I N E =======================================
.text$mn:000011A8
.text$mn:000011A8 ; Attributes: bp-based frame
.text$mn:000011A8
.text$mn:000011A8 ; int __cdecl getFileContent(int, wchar_t *Filename)
.text$mn:000011A8                 public ?getFileContent@@YA?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@PB_W@Z
.text$mn:000011A8 ?getFileContent@@YA?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@PB_W@Z proc near
.text$mn:000011A8
.text$mn:000011A8 var_444         = dword ptr -444h
.text$mn:000011A8 var_440         = dword ptr -440h
.text$mn:000011A8 var_43C         = dword ptr -43Ch
.text$mn:000011A8 var_438         = dword ptr -438h
.text$mn:000011A8 File            = dword ptr -434h
.text$mn:000011A8 var_430         = dword ptr -430h
.text$mn:000011A8 var_42C         = byte ptr -42Ch
.text$mn:000011A8 DstBuf          = byte ptr -410h
.text$mn:000011A8 var_10          = dword ptr -10h
.text$mn:000011A8 var_C           = dword ptr -0Ch
.text$mn:000011A8 var_4           = dword ptr -4
.text$mn:000011A8 arg_0           = dword ptr  8
.text$mn:000011A8 Filename        = dword ptr  0Ch
.text$mn:000011A8
.text$mn:000011A8                 push    ebp
.text$mn:000011A9                 mov     ebp, esp
.text$mn:000011AB                 push    0FFFFFFFFh
.text$mn:000011AD                 push    offset __ehhandler$?getFileContent@@YA?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@PB_W@Z
.text$mn:000011B2                 mov     eax, large fs:0
.text$mn:000011B8                 push    eax
.text$mn:000011B9                 sub     esp, 438h
.text$mn:000011BF                 mov     eax, dword ptr ds:___security_cookie
.text$mn:000011C4                 xor     eax, ebp
.text$mn:000011C6                 mov     [ebp+var_10], eax
.text$mn:000011C9                 push    eax
.text$mn:000011CA                 lea     eax, [ebp+var_C]
.text$mn:000011CD                 mov     large fs:0, eax
.text$mn:000011D3                 mov     [ebp+var_438], 0
.text$mn:000011DD                 mov     [ebp+var_444], 400h
.text$mn:000011E7                 push    offset $SG116465 ; Str
.text$mn:000011EC                 lea     ecx, [ebp+var_42C]
.text$mn:000011F2                 call    ??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@PBD@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char>>::basic_string<char,std::char_traits<char>,std::allocator<char>>(char const *)
.text$mn:000011F7                 mov     [ebp+var_4], 1
.text$mn:000011FE                 push    offset $SG116467 ; "rb"
.text$mn:00001203                 mov     eax, [ebp+Filename]
.text$mn:00001206                 push    eax             ; Filename
.text$mn:00001207                 call    __wfopen
.text$mn:0000120C                 add     esp, 8
.text$mn:0000120F                 mov     [ebp+File], eax
.text$mn:00001215                 mov     [ebp+var_430], 0
.text$mn:0000121F
.text$mn:0000121F loc_121F:                               ; CODE XREF: getFileContent(wchar_t const *)+12Ej
.text$mn:0000121F                 mov     ecx, [ebp+File]
.text$mn:00001225                 push    ecx             ; File
.text$mn:00001226                 push    3FFh            ; Count
.text$mn:0000122B                 push    1               ; ElementSize
.text$mn:0000122D                 lea     edx, [ebp+DstBuf]
.text$mn:00001233                 push    edx             ; DstBuf
.text$mn:00001234                 call    _fread
.text$mn:00001239                 add     esp, 10h
.text$mn:0000123C                 mov     [ebp+var_430], eax
.text$mn:00001242                 cmp     [ebp+var_430], 0
.text$mn:00001249                 ja      short loc_1250
.text$mn:0000124B                 jmp     loc_12DC
.text$mn:00001250 ; ---------------------------------------------------------------------------
.text$mn:00001250
.text$mn:00001250 loc_1250:                               ; CODE XREF: getFileContent(wchar_t const *)+A1j
.text$mn:00001250                 cmp     [ebp+var_430], 3FFh
.text$mn:0000125A                 jb      short loc_1290
.text$mn:0000125C                 mov     eax, 1
.text$mn:00001261                 imul    ecx, eax, 3FFh
.text$mn:00001267                 mov     [ebp+var_43C], ecx
.text$mn:0000126D                 cmp     [ebp+var_43C], 400h
.text$mn:00001277                 jnb     short loc_127B
.text$mn:00001279                 jmp     short loc_1280
.text$mn:0000127B ; ---------------------------------------------------------------------------
.text$mn:0000127B
.text$mn:0000127B loc_127B:                               ; CODE XREF: getFileContent(wchar_t const *)+CFj
.text$mn:0000127B                 call    ___report_rangecheckfailure
.text$mn:00001280
.text$mn:00001280 loc_1280:                               ; CODE XREF: getFileContent(wchar_t const *)+D1j
.text$mn:00001280                 mov     edx, [ebp+var_43C]
.text$mn:00001286                 mov     [ebp+edx+DstBuf], 0
.text$mn:0000128E                 jmp     short loc_12BD
.text$mn:00001290 ; ---------------------------------------------------------------------------
.text$mn:00001290
.text$mn:00001290 loc_1290:                               ; CODE XREF: getFileContent(wchar_t const *)+B2j
.text$mn:00001290                 mov     eax, [ebp+var_430]
.text$mn:00001296                 mov     [ebp+var_440], eax
.text$mn:0000129C                 cmp     [ebp+var_440], 400h
.text$mn:000012A6                 jnb     short loc_12AA
.text$mn:000012A8                 jmp     short loc_12AF
.text$mn:000012AA ; ---------------------------------------------------------------------------
.text$mn:000012AA
.text$mn:000012AA loc_12AA:                               ; CODE XREF: getFileContent(wchar_t const *)+FEj
.text$mn:000012AA                 call    ___report_rangecheckfailure
.text$mn:000012AF
.text$mn:000012AF loc_12AF:                               ; CODE XREF: getFileContent(wchar_t const *)+100j
.text$mn:000012AF                 mov     ecx, [ebp+var_440]
.text$mn:000012B5                 mov     [ebp+ecx+DstBuf], 0
.text$mn:000012BD
.text$mn:000012BD loc_12BD:                               ; CODE XREF: getFileContent(wchar_t const *)+E6j
.text$mn:000012BD                 lea     edx, [ebp+DstBuf]
.text$mn:000012C3                 push    edx             ; Str
.text$mn:000012C4                 lea     ecx, [ebp+var_42C]
.text$mn:000012CA                 call    ??Y?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV01@PBD@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char>>::operator+=(char const *)
.text$mn:000012CF                 cmp     [ebp+var_430], 0
.text$mn:000012D6                 ja      loc_121F
.text$mn:000012DC
.text$mn:000012DC loc_12DC:                               ; CODE XREF: getFileContent(wchar_t const *)+A3j
.text$mn:000012DC                 mov     eax, [ebp+File]
.text$mn:000012E2                 push    eax             ; File
.text$mn:000012E3                 call    _fclose
.text$mn:000012E8                 add     esp, 4
.text$mn:000012EB                 lea     ecx, [ebp+var_42C]
.text$mn:000012F1                 push    ecx
.text$mn:000012F2                 mov     ecx, [ebp+arg_0]
.text$mn:000012F5                 call    ??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@$$QAV01@@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char>>::basic_string<char,std::char_traits<char>,std::allocator<char>>(std::basic_string<char,std::char_traits<char>,std::allocator<char>> &&)
.text$mn:000012FA                 mov     edx, [ebp+var_438]
.text$mn:00001300                 or      edx, 1
.text$mn:00001303                 mov     [ebp+var_438], edx
.text$mn:00001309                 mov     byte ptr [ebp+var_4], 0
.text$mn:0000130D                 lea     ecx, [ebp+var_42C]
.text$mn:00001313                 call    ??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char>>::~basic_string<char,std::char_traits<char>,std::allocator<char>>(void)
.text$mn:00001318                 mov     eax, [ebp+arg_0]
.text$mn:0000131B                 mov     ecx, [ebp+var_C]
.text$mn:0000131E                 mov     large fs:0, ecx
.text$mn:00001325                 pop     ecx
.text$mn:00001326                 mov     ecx, [ebp+var_10]
.text$mn:00001329                 xor     ecx, ebp
.text$mn:0000132B                 call    @__security_check_cookie@4 ; __security_check_cookie(x)
.text$mn:00001330                 mov     esp, ebp
.text$mn:00001332                 pop     ebp
.text$mn:00001333                 retn
.text$mn:00001333 ?getFileContent@@YA?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@PB_W@Z endp
.text$mn:00001333
.text$mn:00001333 ; ---------------------------------------------------------------------------
.text$mn:00001334                 align 8
.text$mn:00001338
.text$mn:00001338 ; =============== S U B R O U T I N E =======================================
.text$mn:00001338
.text$mn:00001338 ; Attributes: bp-based frame
.text$mn:00001338
.text$mn:00001338 ; int __cdecl relativeFilePathToFullFilePath(int, LPCWSTR pszPath)
.text$mn:00001338                 public ?relativeFilePathToFullFilePath@@YA?AV?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@PB_W@Z
.text$mn:00001338 ?relativeFilePathToFullFilePath@@YA?AV?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@PB_W@Z proc near
.text$mn:00001338
.text$mn:00001338 var_23C         = dword ptr -23Ch
.text$mn:00001338 var_238         = dword ptr -238h
.text$mn:00001338 var_234         = byte ptr -234h
.text$mn:00001338 Buffer          = word ptr -218h
.text$mn:00001338 var_10          = dword ptr -10h
.text$mn:00001338 var_C           = dword ptr -0Ch
.text$mn:00001338 var_4           = dword ptr -4
.text$mn:00001338 arg_0           = dword ptr  8
.text$mn:00001338 pszPath         = dword ptr  0Ch
.text$mn:00001338
.text$mn:00001338                 push    ebp
.text$mn:00001339                 mov     ebp, esp
.text$mn:0000133B                 push    0FFFFFFFFh
.text$mn:0000133D                 push    offset __ehhandler$?relativeFilePathToFullFilePath@@YA?AV?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@PB_W@Z
.text$mn:00001342                 mov     eax, large fs:0
.text$mn:00001348                 push    eax
.text$mn:00001349                 sub     esp, 230h
.text$mn:0000134F                 mov     eax, dword ptr ds:___security_cookie
.text$mn:00001354                 xor     eax, ebp
.text$mn:00001356                 mov     [ebp+var_10], eax
.text$mn:00001359                 push    eax
.text$mn:0000135A                 lea     eax, [ebp+var_C]
.text$mn:0000135D                 mov     large fs:0, eax
.text$mn:00001363                 mov     [ebp+var_238], 0
.text$mn:0000136D                 push    offset $SG116488 ; Str
.text$mn:00001372                 lea     ecx, [ebp+var_234]
.text$mn:00001378                 call    ??0?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QAE@PB_W@Z ; std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>>::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>>(wchar_t const *)
.text$mn:0000137D                 mov     [ebp+var_4], 1
.text$mn:00001384                 mov     eax, [ebp+pszPath]
.text$mn:00001387                 push    eax             ; pszPath
.text$mn:00001388                 call    dword ptr ds:__imp__PathIsRelativeW@4 ; PathIsRelativeW(x)
.text$mn:0000138E                 mov     [ebp+var_23C], eax
.text$mn:00001394                 cmp     [ebp+var_23C], 0
.text$mn:0000139B                 jz      short loc_13C9
.text$mn:0000139D                 push    0               ; lpFilePart
.text$mn:0000139F                 lea     ecx, [ebp+Buffer]
.text$mn:000013A5                 push    ecx             ; lpBuffer
.text$mn:000013A6                 push    104h            ; nBufferLength
.text$mn:000013AB                 mov     edx, [ebp+pszPath]
.text$mn:000013AE                 push    edx             ; lpFileName
.text$mn:000013AF                 call    dword ptr ds:__imp__GetFullPathNameW@16 ; GetFullPathNameW(x,x,x,x)
.text$mn:000013B5                 lea     eax, [ebp+Buffer]
.text$mn:000013BB                 push    eax             ; Str
.text$mn:000013BC                 lea     ecx, [ebp+var_234]
.text$mn:000013C2                 call    ??Y?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QAEAAV01@PB_W@Z ; std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>>::operator+=(wchar_t const *)
.text$mn:000013C7                 jmp     short loc_1437
.text$mn:000013C9 ; ---------------------------------------------------------------------------
.text$mn:000013C9
.text$mn:000013C9 loc_13C9:                               ; CODE XREF: relativeFilePathToFullFilePath(wchar_t const *)+63j
.text$mn:000013C9                 mov     ecx, 2
.text$mn:000013CE                 imul    edx, ecx, 0
.text$mn:000013D1                 mov     eax, [ebp+pszPath]
.text$mn:000013D4                 movzx   ecx, word ptr [eax+edx]
.text$mn:000013D8                 cmp     ecx, 5Ch ; '\'
.text$mn:000013DB                 jnz     short loc_13F1
.text$mn:000013DD                 mov     edx, 2
.text$mn:000013E2                 shl     edx, 0
.text$mn:000013E5                 mov     eax, [ebp+pszPath]
.text$mn:000013E8                 movzx   ecx, word ptr [eax+edx]
.text$mn:000013EC                 cmp     ecx, 5Ch ; '\'
.text$mn:000013EF                 jnz     short loc_1405
.text$mn:000013F1
.text$mn:000013F1 loc_13F1:                               ; CODE XREF: relativeFilePathToFullFilePath(wchar_t const *)+A3j
.text$mn:000013F1                 mov     edx, 2
.text$mn:000013F6                 imul    eax, edx, 0
.text$mn:000013F9                 mov     ecx, [ebp+pszPath]
.text$mn:000013FC                 movzx   edx, word ptr [ecx+eax]
.text$mn:00001400                 cmp     edx, 2Fh ; '/'
.text$mn:00001403                 jnz     short loc_1428
.text$mn:00001405
.text$mn:00001405 loc_1405:                               ; CODE XREF: relativeFilePathToFullFilePath(wchar_t const *)+B7j
.text$mn:00001405                 call    ?getDriveLetter@@YADXZ ; getDriveLetter(void)
.text$mn:0000140A                 cbw
.text$mn:0000140C                 movzx   ecx, ax
.text$mn:0000140F                 push    ecx
.text$mn:00001410                 lea     ecx, [ebp+var_234]
.text$mn:00001416                 call    ??Y?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QAEAAV01@_W@Z ; std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>>::operator+=(wchar_t)
.text$mn:0000141B                 push    3Ah ; ':'
.text$mn:0000141D                 lea     ecx, [ebp+var_234]
.text$mn:00001423                 call    ??Y?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QAEAAV01@_W@Z ; std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>>::operator+=(wchar_t)
.text$mn:00001428
.text$mn:00001428 loc_1428:                               ; CODE XREF: relativeFilePathToFullFilePath(wchar_t const *)+CBj
.text$mn:00001428                 mov     edx, [ebp+pszPath]
.text$mn:0000142B                 push    edx             ; Str
.text$mn:0000142C                 lea     ecx, [ebp+var_234]
.text$mn:00001432                 call    ??Y?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QAEAAV01@PB_W@Z ; std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>>::operator+=(wchar_t const *)
.text$mn:00001437
.text$mn:00001437 loc_1437:                               ; CODE XREF: relativeFilePathToFullFilePath(wchar_t const *)+8Fj
.text$mn:00001437                 lea     eax, [ebp+var_234]
.text$mn:0000143D                 push    eax
.text$mn:0000143E                 mov     ecx, [ebp+arg_0]
.text$mn:00001441                 call    ??0?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QAE@$$QAV01@@Z ; std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>>::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>>(std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>> &&)
.text$mn:00001446                 mov     ecx, [ebp+var_238]
.text$mn:0000144C                 or      ecx, 1
.text$mn:0000144F                 mov     [ebp+var_238], ecx
.text$mn:00001455                 mov     byte ptr [ebp+var_4], 0
.text$mn:00001459                 lea     ecx, [ebp+var_234]
.text$mn:0000145F                 call    ??1?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QAE@XZ ; std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>>::~basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>>(void)
.text$mn:00001464                 mov     eax, [ebp+arg_0]
.text$mn:00001467                 mov     ecx, [ebp+var_C]
.text$mn:0000146A                 mov     large fs:0, ecx
.text$mn:00001471                 pop     ecx
.text$mn:00001472                 mov     ecx, [ebp+var_10]
.text$mn:00001475                 xor     ecx, ebp
.text$mn:00001477                 call    @__security_check_cookie@4 ; __security_check_cookie(x)
.text$mn:0000147C                 mov     esp, ebp
.text$mn:0000147E                 pop     ebp
.text$mn:0000147F                 retn
.text$mn:0000147F ?relativeFilePathToFullFilePath@@YA?AV?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@PB_W@Z endp
.text$mn:0000147F
.text$mn:0000147F ; ---------------------------------------------------------------------------
.text$mn:00001480                 db 8 dup(0CCh)
.text$mn:00001488
.text$mn:00001488 ; =============== S U B R O U T I N E =======================================
.text$mn:00001488
.text$mn:00001488 ; Attributes: bp-based frame
.text$mn:00001488
.text$mn:00001488 ; void __cdecl writeFileContent(const wchar_t *Filename, const char *Str)
.text$mn:00001488                 public ?writeFileContent@@YAXPB_WPBD@Z
.text$mn:00001488 ?writeFileContent@@YAXPB_WPBD@Z proc near
.text$mn:00001488
.text$mn:00001488 File            = dword ptr -4
.text$mn:00001488 Filename        = dword ptr  8
.text$mn:00001488 Str             = dword ptr  0Ch
.text$mn:00001488
.text$mn:00001488                 push    ebp
.text$mn:00001489                 mov     ebp, esp
.text$mn:0000148B                 push    ecx
.text$mn:0000148C                 push    offset $SG116501 ; "w+"
.text$mn:00001491                 mov     eax, [ebp+Filename]
.text$mn:00001494                 push    eax             ; Filename
.text$mn:00001495                 call    __wfopen
.text$mn:0000149A                 add     esp, 8
.text$mn:0000149D                 mov     [ebp+File], eax
.text$mn:000014A0                 mov     ecx, [ebp+File]
.text$mn:000014A3                 push    ecx             ; File
.text$mn:000014A4                 mov     edx, [ebp+Str]
.text$mn:000014A7                 push    edx             ; Str
.text$mn:000014A8                 call    _strlen
.text$mn:000014AD                 add     esp, 4
.text$mn:000014B0                 push    eax             ; Count
.text$mn:000014B1                 push    1               ; Size
.text$mn:000014B3                 mov     eax, [ebp+Str]
.text$mn:000014B6                 push    eax             ; Str
.text$mn:000014B7                 call    _fwrite
.text$mn:000014BC                 add     esp, 10h
.text$mn:000014BF                 mov     ecx, [ebp+File]
.text$mn:000014C2                 push    ecx             ; File
.text$mn:000014C3                 call    _fflush
.text$mn:000014C8                 add     esp, 4
.text$mn:000014CB                 mov     edx, [ebp+File]
.text$mn:000014CE                 push    edx             ; File
.text$mn:000014CF                 call    _fclose
.text$mn:000014D4                 add     esp, 4
.text$mn:000014D7                 mov     esp, ebp
.text$mn:000014D9                 pop     ebp
.text$mn:000014DA                 retn
.text$mn:000014DA ?writeFileContent@@YAXPB_WPBD@Z endp
.text$mn:000014DA
.text$mn:000014DA ; ---------------------------------------------------------------------------
.text$mn:000014DB                 db 0Dh dup(0CCh)
.text$mn:000014E8
.text$mn:000014E8 ; =============== S U B R O U T I N E =======================================
.text$mn:000014E8
.text$mn:000014E8 ; Attributes: bp-based frame
.text$mn:000014E8
.text$mn:000014E8 ; const wchar_t *__thiscall WcharMbcsConvertor::char2wchar(WcharMbcsConvertor *this, LPCSTR lpMultiByteStr, UINT CodePage, int cbMultiByte, int *, int *)
.text$mn:000014E8                 public ?char2wchar@WcharMbcsConvertor@@QAEPB_WPBDIHPAH1@Z
.text$mn:000014E8 ?char2wchar@WcharMbcsConvertor@@QAEPB_WPBDIHPAH1@Z proc near
.text$mn:000014E8
.text$mn:000014E8 dwFlags         = dword ptr -14h
.text$mn:000014E8 var_10          = dword ptr -10h
.text$mn:000014E8 var_C           = dword ptr -0Ch
.text$mn:000014E8 var_8           = dword ptr -8
.text$mn:000014E8 cchWideChar     = dword ptr -4
.text$mn:000014E8 lpMultiByteStr  = dword ptr  8
.text$mn:000014E8 CodePage        = dword ptr  0Ch
.text$mn:000014E8 cbMultiByte     = dword ptr  10h
.text$mn:000014E8 arg_C           = dword ptr  14h
.text$mn:000014E8 arg_10          = dword ptr  18h
.text$mn:000014E8
.text$mn:000014E8                 push    ebp
.text$mn:000014E9                 mov     ebp, esp
.text$mn:000014EB                 sub     esp, 14h
.text$mn:000014EE                 mov     [ebp+var_8], ecx
.text$mn:000014F1                 cmp     [ebp+lpMultiByteStr], 0
.text$mn:000014F5                 jnz     short loc_14FE
.text$mn:000014F7                 xor     eax, eax
.text$mn:000014F9                 jmp     loc_16E4
.text$mn:000014FE ; ---------------------------------------------------------------------------
.text$mn:000014FE
.text$mn:000014FE loc_14FE:                               ; CODE XREF: WcharMbcsConvertor::char2wchar(char const *,uint,int,int *,int *)+Dj
.text$mn:000014FE                 cmp     [ebp+cbMultiByte], 0
.text$mn:00001502                 jz      short loc_151D
.text$mn:00001504                 cmp     [ebp+cbMultiByte], 0FFFFFFFFh
.text$mn:00001508                 jnz     short loc_1538
.text$mn:0000150A                 mov     eax, 1
.text$mn:0000150F                 imul    ecx, eax, 0
.text$mn:00001512                 mov     edx, [ebp+lpMultiByteStr]
.text$mn:00001515                 movsx   eax, byte ptr [edx+ecx]
.text$mn:00001519                 test    eax, eax
.text$mn:0000151B                 jnz     short loc_1538
.text$mn:0000151D
.text$mn:0000151D loc_151D:                               ; CODE XREF: WcharMbcsConvertor::char2wchar(char const *,uint,int,int *,int *)+1Aj
.text$mn:0000151D                 mov     ecx, [ebp+var_8]
.text$mn:00001520                 add     ecx, 8
.text$mn:00001523                 call    ?empty@?$StringBuffer@_W@WcharMbcsConvertor@@QAEXXZ ; WcharMbcsConvertor::StringBuffer<wchar_t>::empty(void)
.text$mn:00001528                 mov     ecx, [ebp+var_8]
.text$mn:0000152B                 add     ecx, 8
.text$mn:0000152E                 call    ??B?$StringBuffer@_W@WcharMbcsConvertor@@QAEPA_WXZ ; WcharMbcsConvertor::StringBuffer<wchar_t>::operator wchar_t *(void)
.text$mn:00001533                 jmp     loc_16E4
.text$mn:00001538 ; ---------------------------------------------------------------------------
.text$mn:00001538
.text$mn:00001538 loc_1538:                               ; CODE XREF: WcharMbcsConvertor::char2wchar(char const *,uint,int,int *,int *)+20j
.text$mn:00001538                                         ; WcharMbcsConvertor::char2wchar(char const *,uint,int,int *,int *)+33j
.text$mn:00001538                 mov     [ebp+var_C], 0
.text$mn:0000153F                 mov     [ebp+cchWideChar], 0
.text$mn:00001546                 cmp     [ebp+cbMultiByte], 0FFFFFFFFh
.text$mn:0000154A                 jnz     short loc_156C
.text$mn:0000154C                 push    0               ; cchWideChar
.text$mn:0000154E                 push    0               ; lpWideCharStr
.text$mn:00001550                 mov     ecx, [ebp+cbMultiByte]
.text$mn:00001553                 push    ecx             ; cbMultiByte
.text$mn:00001554                 mov     edx, [ebp+lpMultiByteStr]
.text$mn:00001557                 push    edx             ; lpMultiByteStr
.text$mn:00001558                 push    0               ; dwFlags
.text$mn:0000155A                 mov     eax, [ebp+CodePage]
.text$mn:0000155D                 push    eax             ; CodePage
.text$mn:0000155E                 call    dword ptr ds:__imp__MultiByteToWideChar@24 ; MultiByteToWideChar(x,x,x,x,x,x)
.text$mn:00001564                 mov     [ebp+cchWideChar], eax
.text$mn:00001567                 jmp     loc_1674
.text$mn:0000156C ; ---------------------------------------------------------------------------
.text$mn:0000156C
.text$mn:0000156C loc_156C:                               ; CODE XREF: WcharMbcsConvertor::char2wchar(char const *,uint,int,int *,int *)+62j
.text$mn:0000156C                 cmp     [ebp+cbMultiByte], 0FFFFFFFFh
.text$mn:00001570                 jz      short loc_15E0
.text$mn:00001572                 cmp     [ebp+CodePage], 0FDE9h
.text$mn:00001579                 jnz     short loc_15E0
.text$mn:0000157B                 mov     ecx, [ebp+cbMultiByte]
.text$mn:0000157E                 sub     ecx, 1
.text$mn:00001581                 push    ecx
.text$mn:00001582                 mov     edx, [ebp+lpMultiByteStr]
.text$mn:00001585                 push    edx
.text$mn:00001586                 call    ?characterStart@Utf8@@YAHPBDH@Z ; Utf8::characterStart(char const *,int)
.text$mn:0000158B                 add     esp, 8
.text$mn:0000158E                 mov     [ebp+var_10], eax
.text$mn:00001591                 cmp     [ebp+var_10], 0
.text$mn:00001595                 jz      short loc_15BD
.text$mn:00001597                 mov     eax, [ebp+cbMultiByte]
.text$mn:0000159A                 sub     eax, [ebp+var_10]
.text$mn:0000159D                 push    eax
.text$mn:0000159E                 mov     ecx, [ebp+lpMultiByteStr]
.text$mn:000015A1                 add     ecx, [ebp+var_10]
.text$mn:000015A4                 push    ecx
.text$mn:000015A5                 call    ?isValid@Utf8@@YA_NPBDH@Z ; Utf8::isValid(char const *,int)
.text$mn:000015AA                 add     esp, 8
.text$mn:000015AD                 movzx   edx, al
.text$mn:000015B0                 test    edx, edx
.text$mn:000015B2                 jnz     short loc_15BD
.text$mn:000015B4                 mov     eax, [ebp+cbMultiByte]
.text$mn:000015B7                 sub     eax, [ebp+var_10]
.text$mn:000015BA                 mov     [ebp+var_C], eax
.text$mn:000015BD
.text$mn:000015BD loc_15BD:                               ; CODE XREF: WcharMbcsConvertor::char2wchar(char const *,uint,int,int *,int *)+ADj
.text$mn:000015BD                                         ; WcharMbcsConvertor::char2wchar(char const *,uint,int,int *,int *)+CAj
.text$mn:000015BD                 push    0               ; cchWideChar
.text$mn:000015BF                 push    0               ; lpWideCharStr
.text$mn:000015C1                 mov     ecx, [ebp+cbMultiByte]
.text$mn:000015C4                 sub     ecx, [ebp+var_C]
.text$mn:000015C7                 push    ecx             ; cbMultiByte
.text$mn:000015C8                 mov     edx, [ebp+lpMultiByteStr]
.text$mn:000015CB                 push    edx             ; lpMultiByteStr
.text$mn:000015CC                 push    0               ; dwFlags
.text$mn:000015CE                 mov     eax, [ebp+CodePage]
.text$mn:000015D1                 push    eax             ; CodePage
.text$mn:000015D2                 call    dword ptr ds:__imp__MultiByteToWideChar@24 ; MultiByteToWideChar(x,x,x,x,x,x)
.text$mn:000015D8                 mov     [ebp+cchWideChar], eax
.text$mn:000015DB                 jmp     loc_1674
.text$mn:000015E0 ; ---------------------------------------------------------------------------
.text$mn:000015E0
.text$mn:000015E0 loc_15E0:                               ; CODE XREF: WcharMbcsConvertor::char2wchar(char const *,uint,int,int *,int *)+88j
.text$mn:000015E0                                         ; WcharMbcsConvertor::char2wchar(char const *,uint,int,int *,int *)+91j
.text$mn:000015E0                 cmp     [ebp+cbMultiByte], 0FFFFFFFFh
.text$mn:000015E4                 jnz     short loc_15EF
.text$mn:000015E6                 mov     [ebp+dwFlags], 0
.text$mn:000015ED                 jmp     short loc_15F6
.text$mn:000015EF ; ---------------------------------------------------------------------------
.text$mn:000015EF
.text$mn:000015EF loc_15EF:                               ; CODE XREF: WcharMbcsConvertor::char2wchar(char const *,uint,int,int *,int *)+FCj
.text$mn:000015EF                 mov     [ebp+dwFlags], 8
.text$mn:000015F6
.text$mn:000015F6 loc_15F6:                               ; CODE XREF: WcharMbcsConvertor::char2wchar(char const *,uint,int,int *,int *)+105j
.text$mn:000015F6                 push    0               ; cchWideChar
.text$mn:000015F8                 push    0               ; lpWideCharStr
.text$mn:000015FA                 mov     ecx, [ebp+cbMultiByte]
.text$mn:000015FD                 push    ecx             ; cbMultiByte
.text$mn:000015FE                 mov     edx, [ebp+lpMultiByteStr]
.text$mn:00001601                 push    edx             ; lpMultiByteStr
.text$mn:00001602                 mov     eax, [ebp+dwFlags]
.text$mn:00001605                 push    eax             ; dwFlags
.text$mn:00001606                 mov     ecx, [ebp+CodePage]
.text$mn:00001609                 push    ecx             ; CodePage
.text$mn:0000160A                 call    dword ptr ds:__imp__MultiByteToWideChar@24 ; MultiByteToWideChar(x,x,x,x,x,x)
.text$mn:00001610                 mov     [ebp+cchWideChar], eax
.text$mn:00001613                 cmp     [ebp+cchWideChar], 0
.text$mn:00001617                 jnz     short loc_1674
.text$mn:00001619                 call    dword ptr ds:__imp__GetLastError@0 ; GetLastError()
.text$mn:0000161F                 cmp     eax, 459h
.text$mn:00001624                 jnz     short loc_1674
.text$mn:00001626                 cmp     [ebp+cbMultiByte], 1
.text$mn:0000162A                 jle     short loc_164A
.text$mn:0000162C                 push    0               ; cchWideChar
.text$mn:0000162E                 push    0               ; lpWideCharStr
.text$mn:00001630                 mov     edx, [ebp+cbMultiByte]
.text$mn:00001633                 sub     edx, 1
.text$mn:00001636                 push    edx             ; cbMultiByte
.text$mn:00001637                 mov     eax, [ebp+lpMultiByteStr]
.text$mn:0000163A                 push    eax             ; lpMultiByteStr
.text$mn:0000163B                 push    8               ; dwFlags
.text$mn:0000163D                 mov     ecx, [ebp+CodePage]
.text$mn:00001640                 push    ecx             ; CodePage
.text$mn:00001641                 call    dword ptr ds:__imp__MultiByteToWideChar@24 ; MultiByteToWideChar(x,x,x,x,x,x)
.text$mn:00001647                 mov     [ebp+cchWideChar], eax
.text$mn:0000164A
.text$mn:0000164A loc_164A:                               ; CODE XREF: WcharMbcsConvertor::char2wchar(char const *,uint,int,int *,int *)+142j
.text$mn:0000164A                 cmp     [ebp+cchWideChar], 0
.text$mn:0000164E                 jnz     short loc_166D
.text$mn:00001650                 push    0               ; cchWideChar
.text$mn:00001652                 push    0               ; lpWideCharStr
.text$mn:00001654                 mov     edx, [ebp+cbMultiByte]
.text$mn:00001657                 push    edx             ; cbMultiByte
.text$mn:00001658                 mov     eax, [ebp+lpMultiByteStr]
.text$mn:0000165B                 push    eax             ; lpMultiByteStr
.text$mn:0000165C                 push    0               ; dwFlags
.text$mn:0000165E                 mov     ecx, [ebp+CodePage]
.text$mn:00001661                 push    ecx             ; CodePage
.text$mn:00001662                 call    dword ptr ds:__imp__MultiByteToWideChar@24 ; MultiByteToWideChar(x,x,x,x,x,x)
.text$mn:00001668                 mov     [ebp+cchWideChar], eax
.text$mn:0000166B                 jmp     short loc_1674
.text$mn:0000166D ; ---------------------------------------------------------------------------
.text$mn:0000166D
.text$mn:0000166D loc_166D:                               ; CODE XREF: WcharMbcsConvertor::char2wchar(char const *,uint,int,int *,int *)+166j
.text$mn:0000166D                 mov     [ebp+var_C], 1
.text$mn:00001674
.text$mn:00001674 loc_1674:                               ; CODE XREF: WcharMbcsConvertor::char2wchar(char const *,uint,int,int *,int *)+7Fj
.text$mn:00001674                                         ; WcharMbcsConvertor::char2wchar(char const *,uint,int,int *,int *)+F3j ...
.text$mn:00001674                 cmp     [ebp+cchWideChar], 0
.text$mn:00001678                 jle     short loc_16B2
.text$mn:0000167A                 mov     edx, [ebp+cchWideChar]
.text$mn:0000167D                 push    edx
.text$mn:0000167E                 mov     ecx, [ebp+var_8]
.text$mn:00001681                 add     ecx, 8
.text$mn:00001684                 call    ?sizeTo@?$StringBuffer@_W@WcharMbcsConvertor@@QAEXI@Z ; WcharMbcsConvertor::StringBuffer<wchar_t>::sizeTo(uint)
.text$mn:00001689                 mov     eax, [ebp+cchWideChar]
.text$mn:0000168C                 push    eax             ; cchWideChar
.text$mn:0000168D                 mov     ecx, [ebp+var_8]
.text$mn:00001690                 add     ecx, 8
.text$mn:00001693                 call    ??B?$StringBuffer@_W@WcharMbcsConvertor@@QAEPA_WXZ ; WcharMbcsConvertor::StringBuffer<wchar_t>::operator wchar_t *(void)
.text$mn:00001698                 push    eax             ; lpWideCharStr
.text$mn:00001699                 mov     ecx, [ebp+cbMultiByte]
.text$mn:0000169C                 sub     ecx, [ebp+var_C]
.text$mn:0000169F                 push    ecx             ; cbMultiByte
.text$mn:000016A0                 mov     edx, [ebp+lpMultiByteStr]
.text$mn:000016A3                 push    edx             ; lpMultiByteStr
.text$mn:000016A4                 push    0               ; dwFlags
.text$mn:000016A6                 mov     eax, [ebp+CodePage]
.text$mn:000016A9                 push    eax             ; CodePage
.text$mn:000016AA                 call    dword ptr ds:__imp__MultiByteToWideChar@24 ; MultiByteToWideChar(x,x,x,x,x,x)
.text$mn:000016B0                 jmp     short loc_16BD
.text$mn:000016B2 ; ---------------------------------------------------------------------------
.text$mn:000016B2
.text$mn:000016B2 loc_16B2:                               ; CODE XREF: WcharMbcsConvertor::char2wchar(char const *,uint,int,int *,int *)+190j
.text$mn:000016B2                 mov     ecx, [ebp+var_8]
.text$mn:000016B5                 add     ecx, 8
.text$mn:000016B8                 call    ?empty@?$StringBuffer@_W@WcharMbcsConvertor@@QAEXXZ ; WcharMbcsConvertor::StringBuffer<wchar_t>::empty(void)
.text$mn:000016BD
.text$mn:000016BD loc_16BD:                               ; CODE XREF: WcharMbcsConvertor::char2wchar(char const *,uint,int,int *,int *)+1C8j
.text$mn:000016BD                 cmp     [ebp+arg_C], 0
.text$mn:000016C1                 jz      short loc_16CB
.text$mn:000016C3                 mov     ecx, [ebp+arg_C]
.text$mn:000016C6                 mov     edx, [ebp+cchWideChar]
.text$mn:000016C9                 mov     [ecx], edx
.text$mn:000016CB
.text$mn:000016CB loc_16CB:                               ; CODE XREF: WcharMbcsConvertor::char2wchar(char const *,uint,int,int *,int *)+1D9j
.text$mn:000016CB                 cmp     [ebp+arg_10], 0
.text$mn:000016CF                 jz      short loc_16D9
.text$mn:000016D1                 mov     eax, [ebp+arg_10]
.text$mn:000016D4                 mov     ecx, [ebp+var_C]
.text$mn:000016D7                 mov     [eax], ecx
.text$mn:000016D9
.text$mn:000016D9 loc_16D9:                               ; CODE XREF: WcharMbcsConvertor::char2wchar(char const *,uint,int,int *,int *)+1E7j
.text$mn:000016D9                 mov     ecx, [ebp+var_8]
.text$mn:000016DC                 add     ecx, 8
.text$mn:000016DF                 call    ??B?$StringBuffer@_W@WcharMbcsConvertor@@QAEPA_WXZ ; WcharMbcsConvertor::StringBuffer<wchar_t>::operator wchar_t *(void)
.text$mn:000016E4
.text$mn:000016E4 loc_16E4:                               ; CODE XREF: WcharMbcsConvertor::char2wchar(char const *,uint,int,int *,int *)+11j
.text$mn:000016E4                                         ; WcharMbcsConvertor::char2wchar(char const *,uint,int,int *,int *)+4Bj
.text$mn:000016E4                 mov     esp, ebp
.text$mn:000016E6                 pop     ebp
.text$mn:000016E7                 retn    14h
.text$mn:000016E7 ?char2wchar@WcharMbcsConvertor@@QAEPB_WPBDIHPAH1@Z endp
.text$mn:000016E7
.text$mn:000016E7 ; ---------------------------------------------------------------------------
.text$mn:000016EA                 db 0Eh dup(0CCh)
.text$mn:000016F8
.text$mn:000016F8 ; =============== S U B R O U T I N E =======================================
.text$mn:000016F8
.text$mn:000016F8 ; Attributes: bp-based frame
.text$mn:000016F8
.text$mn:000016F8 ; const wchar_t *__thiscall WcharMbcsConvertor::char2wchar(WcharMbcsConvertor *this, LPCSTR lpMultiByteStr, UINT CodePage, int *, int *)
.text$mn:000016F8                 public ?char2wchar@WcharMbcsConvertor@@QAEPB_WPBDIPAH1@Z
.text$mn:000016F8 ?char2wchar@WcharMbcsConvertor@@QAEPB_WPBDIPAH1@Z proc near
.text$mn:000016F8
.text$mn:000016F8 var_8           = dword ptr -8
.text$mn:000016F8 cchWideChar     = dword ptr -4
.text$mn:000016F8 lpMultiByteStr  = dword ptr  8
.text$mn:000016F8 CodePage        = dword ptr  0Ch
.text$mn:000016F8 arg_8           = dword ptr  10h
.text$mn:000016F8 arg_C           = dword ptr  14h
.text$mn:000016F8
.text$mn:000016F8                 push    ebp
.text$mn:000016F9                 mov     ebp, esp
.text$mn:000016FB                 sub     esp, 8
.text$mn:000016FE                 mov     [ebp+var_8], ecx
.text$mn:00001701                 cmp     [ebp+lpMultiByteStr], 0
.text$mn:00001705                 jnz     short loc_170E
.text$mn:00001707                 xor     eax, eax
.text$mn:00001709                 jmp     loc_1831
.text$mn:0000170E ; ---------------------------------------------------------------------------
.text$mn:0000170E
.text$mn:0000170E loc_170E:                               ; CODE XREF: WcharMbcsConvertor::char2wchar(char const *,uint,int *,int *)+Dj
.text$mn:0000170E                 push    0               ; cchWideChar
.text$mn:00001710                 push    0               ; lpWideCharStr
.text$mn:00001712                 push    0FFFFFFFFh      ; cbMultiByte
.text$mn:00001714                 mov     eax, [ebp+lpMultiByteStr]
.text$mn:00001717                 push    eax             ; lpMultiByteStr
.text$mn:00001718                 push    0               ; dwFlags
.text$mn:0000171A                 mov     ecx, [ebp+CodePage]
.text$mn:0000171D                 push    ecx             ; CodePage
.text$mn:0000171E                 call    dword ptr ds:__imp__MultiByteToWideChar@24 ; MultiByteToWideChar(x,x,x,x,x,x)
.text$mn:00001724                 mov     [ebp+cchWideChar], eax
.text$mn:00001727                 cmp     [ebp+cchWideChar], 0
.text$mn:0000172B                 jle     loc_1809
.text$mn:00001731                 mov     edx, [ebp+cchWideChar]
.text$mn:00001734                 push    edx
.text$mn:00001735                 mov     ecx, [ebp+var_8]
.text$mn:00001738                 add     ecx, 8
.text$mn:0000173B                 call    ?sizeTo@?$StringBuffer@_W@WcharMbcsConvertor@@QAEXI@Z ; WcharMbcsConvertor::StringBuffer<wchar_t>::sizeTo(uint)
.text$mn:00001740                 mov     eax, [ebp+cchWideChar]
.text$mn:00001743                 push    eax             ; cchWideChar
.text$mn:00001744                 mov     ecx, [ebp+var_8]
.text$mn:00001747                 add     ecx, 8
.text$mn:0000174A                 call    ??B?$StringBuffer@_W@WcharMbcsConvertor@@QAEPA_WXZ ; WcharMbcsConvertor::StringBuffer<wchar_t>::operator wchar_t *(void)
.text$mn:0000174F                 push    eax             ; lpWideCharStr
.text$mn:00001750                 push    0FFFFFFFFh      ; cbMultiByte
.text$mn:00001752                 mov     ecx, [ebp+lpMultiByteStr]
.text$mn:00001755                 push    ecx             ; lpMultiByteStr
.text$mn:00001756                 push    0               ; dwFlags
.text$mn:00001758                 mov     edx, [ebp+CodePage]
.text$mn:0000175B                 push    edx             ; CodePage
.text$mn:0000175C                 call    dword ptr ds:__imp__MultiByteToWideChar@24 ; MultiByteToWideChar(x,x,x,x,x,x)
.text$mn:00001762                 mov     [ebp+cchWideChar], eax
.text$mn:00001765                 mov     eax, [ebp+lpMultiByteStr]
.text$mn:00001768                 push    eax             ; Str
.text$mn:00001769                 call    _strlen
.text$mn:0000176E                 add     esp, 4
.text$mn:00001771                 mov     ecx, [ebp+arg_8]
.text$mn:00001774                 cmp     [ecx], eax
.text$mn:00001776                 jnb     loc_1807
.text$mn:0000177C                 mov     edx, [ebp+lpMultiByteStr]
.text$mn:0000177F                 push    edx             ; Str
.text$mn:00001780                 call    _strlen
.text$mn:00001785                 add     esp, 4
.text$mn:00001788                 mov     ecx, [ebp+arg_C]
.text$mn:0000178B                 cmp     [ecx], eax
.text$mn:0000178D                 ja      short loc_1807
.text$mn:0000178F                 push    0               ; cchWideChar
.text$mn:00001791                 mov     ecx, [ebp+var_8]
.text$mn:00001794                 add     ecx, 8
.text$mn:00001797                 call    ??B?$StringBuffer@_W@WcharMbcsConvertor@@QAEPA_WXZ ; WcharMbcsConvertor::StringBuffer<wchar_t>::operator wchar_t *(void)
.text$mn:0000179C                 push    eax             ; lpWideCharStr
.text$mn:0000179D                 mov     edx, [ebp+arg_8]
.text$mn:000017A0                 mov     eax, [edx]
.text$mn:000017A2                 push    eax             ; cbMultiByte
.text$mn:000017A3                 mov     ecx, [ebp+lpMultiByteStr]
.text$mn:000017A6                 push    ecx             ; lpMultiByteStr
.text$mn:000017A7                 push    0               ; dwFlags
.text$mn:000017A9                 mov     edx, [ebp+CodePage]
.text$mn:000017AC                 push    edx             ; CodePage
.text$mn:000017AD                 call    dword ptr ds:__imp__MultiByteToWideChar@24 ; MultiByteToWideChar(x,x,x,x,x,x)
.text$mn:000017B3                 mov     ecx, [ebp+arg_8]
.text$mn:000017B6                 mov     [ecx], eax
.text$mn:000017B8                 push    0               ; cchWideChar
.text$mn:000017BA                 mov     ecx, [ebp+var_8]
.text$mn:000017BD                 add     ecx, 8
.text$mn:000017C0                 call    ??B?$StringBuffer@_W@WcharMbcsConvertor@@QAEPA_WXZ ; WcharMbcsConvertor::StringBuffer<wchar_t>::operator wchar_t *(void)
.text$mn:000017C5                 push    eax             ; lpWideCharStr
.text$mn:000017C6                 mov     edx, [ebp+arg_C]
.text$mn:000017C9                 mov     eax, [edx]
.text$mn:000017CB                 push    eax             ; cbMultiByte
.text$mn:000017CC                 mov     ecx, [ebp+lpMultiByteStr]
.text$mn:000017CF                 push    ecx             ; lpMultiByteStr
.text$mn:000017D0                 push    0               ; dwFlags
.text$mn:000017D2                 mov     edx, [ebp+CodePage]
.text$mn:000017D5                 push    edx             ; CodePage
.text$mn:000017D6                 call    dword ptr ds:__imp__MultiByteToWideChar@24 ; MultiByteToWideChar(x,x,x,x,x,x)
.text$mn:000017DC                 mov     ecx, [ebp+arg_C]
.text$mn:000017DF                 mov     [ecx], eax
.text$mn:000017E1                 mov     edx, [ebp+arg_8]
.text$mn:000017E4                 mov     eax, [edx]
.text$mn:000017E6                 cmp     eax, [ebp+cchWideChar]
.text$mn:000017E9                 jge     short loc_17F5
.text$mn:000017EB                 mov     ecx, [ebp+arg_C]
.text$mn:000017EE                 mov     edx, [ecx]
.text$mn:000017F0                 cmp     edx, [ebp+cchWideChar]
.text$mn:000017F3                 jl      short loc_1807
.text$mn:000017F5
.text$mn:000017F5 loc_17F5:                               ; CODE XREF: WcharMbcsConvertor::char2wchar(char const *,uint,int *,int *)+F1j
.text$mn:000017F5                 mov     eax, [ebp+arg_8]
.text$mn:000017F8                 mov     dword ptr [eax], 0
.text$mn:000017FE                 mov     ecx, [ebp+arg_C]
.text$mn:00001801                 mov     dword ptr [ecx], 0
.text$mn:00001807
.text$mn:00001807 loc_1807:                               ; CODE XREF: WcharMbcsConvertor::char2wchar(char const *,uint,int *,int *)+7Ej
.text$mn:00001807                                         ; WcharMbcsConvertor::char2wchar(char const *,uint,int *,int *)+95j ...
.text$mn:00001807                 jmp     short loc_1826
.text$mn:00001809 ; ---------------------------------------------------------------------------
.text$mn:00001809
.text$mn:00001809 loc_1809:                               ; CODE XREF: WcharMbcsConvertor::char2wchar(char const *,uint,int *,int *)+33j
.text$mn:00001809                 mov     ecx, [ebp+var_8]
.text$mn:0000180C                 add     ecx, 8
.text$mn:0000180F                 call    ?empty@?$StringBuffer@_W@WcharMbcsConvertor@@QAEXXZ ; WcharMbcsConvertor::StringBuffer<wchar_t>::empty(void)
.text$mn:00001814                 mov     edx, [ebp+arg_8]
.text$mn:00001817                 mov     dword ptr [edx], 0
.text$mn:0000181D                 mov     eax, [ebp+arg_C]
.text$mn:00001820                 mov     dword ptr [eax], 0
.text$mn:00001826
.text$mn:00001826 loc_1826:                               ; CODE XREF: WcharMbcsConvertor::char2wchar(char const *,uint,int *,int *):loc_1807j
.text$mn:00001826                 mov     ecx, [ebp+var_8]
.text$mn:00001829                 add     ecx, 8
.text$mn:0000182C                 call    ??B?$StringBuffer@_W@WcharMbcsConvertor@@QAEPA_WXZ ; WcharMbcsConvertor::StringBuffer<wchar_t>::operator wchar_t *(void)
.text$mn:00001831
.text$mn:00001831 loc_1831:                               ; CODE XREF: WcharMbcsConvertor::char2wchar(char const *,uint,int *,int *)+11j
.text$mn:00001831                 mov     esp, ebp
.text$mn:00001833                 pop     ebp
.text$mn:00001834                 retn    10h
.text$mn:00001834 ?char2wchar@WcharMbcsConvertor@@QAEPB_WPBDIPAH1@Z endp
.text$mn:00001834
.text$mn:00001834 ; ---------------------------------------------------------------------------
.text$mn:00001837                 align 4
.text$mn:00001838
.text$mn:00001838 ; =============== S U B R O U T I N E =======================================
.text$mn:00001838
.text$mn:00001838 ; Attributes: bp-based frame
.text$mn:00001838
.text$mn:00001838 ; const char *__thiscall WcharMbcsConvertor::wchar2char(WcharMbcsConvertor *this, LPCWSTR lpWideCharStr, UINT CodePage, int cchWideChar, int *)
.text$mn:00001838                 public ?wchar2char@WcharMbcsConvertor@@QAEPBDPB_WIHPAH@Z
.text$mn:00001838 ?wchar2char@WcharMbcsConvertor@@QAEPBDPB_WIHPAH@Z proc near
.text$mn:00001838
.text$mn:00001838 var_8           = dword ptr -8
.text$mn:00001838 cbMultiByte     = dword ptr -4
.text$mn:00001838 lpWideCharStr   = dword ptr  8
.text$mn:00001838 CodePage        = dword ptr  0Ch
.text$mn:00001838 cchWideChar     = dword ptr  10h
.text$mn:00001838 arg_C           = dword ptr  14h
.text$mn:00001838
.text$mn:00001838                 push    ebp
.text$mn:00001839                 mov     ebp, esp
.text$mn:0000183B                 sub     esp, 8
.text$mn:0000183E                 mov     [ebp+var_8], ecx
.text$mn:00001841                 cmp     [ebp+lpWideCharStr], 0
.text$mn:00001845                 jnz     short loc_184B
.text$mn:00001847                 xor     eax, eax
.text$mn:00001849                 jmp     short loc_18C1
.text$mn:0000184B ; ---------------------------------------------------------------------------
.text$mn:0000184B
.text$mn:0000184B loc_184B:                               ; CODE XREF: WcharMbcsConvertor::wchar2char(wchar_t const *,uint,int,int *)+Dj
.text$mn:0000184B                 push    0               ; lpUsedDefaultChar
.text$mn:0000184D                 push    0               ; lpDefaultChar
.text$mn:0000184F                 push    0               ; cbMultiByte
.text$mn:00001851                 push    0               ; lpMultiByteStr
.text$mn:00001853                 mov     eax, [ebp+cchWideChar]
.text$mn:00001856                 push    eax             ; cchWideChar
.text$mn:00001857                 mov     ecx, [ebp+lpWideCharStr]
.text$mn:0000185A                 push    ecx             ; lpWideCharStr
.text$mn:0000185B                 push    0               ; dwFlags
.text$mn:0000185D                 mov     edx, [ebp+CodePage]
.text$mn:00001860                 push    edx             ; CodePage
.text$mn:00001861                 call    dword ptr ds:__imp__WideCharToMultiByte@32 ; WideCharToMultiByte(x,x,x,x,x,x,x,x)
.text$mn:00001867                 mov     [ebp+cbMultiByte], eax
.text$mn:0000186A                 cmp     [ebp+cbMultiByte], 0
.text$mn:0000186E                 jle     short loc_18A3
.text$mn:00001870                 mov     eax, [ebp+cbMultiByte]
.text$mn:00001873                 push    eax
.text$mn:00001874                 mov     ecx, [ebp+var_8]
.text$mn:00001877                 call    ?sizeTo@?$StringBuffer@D@WcharMbcsConvertor@@QAEXI@Z ; WcharMbcsConvertor::StringBuffer<char>::sizeTo(uint)
.text$mn:0000187C                 push    0               ; lpUsedDefaultChar
.text$mn:0000187E                 push    0               ; lpDefaultChar
.text$mn:00001880                 mov     ecx, [ebp+cbMultiByte]
.text$mn:00001883                 push    ecx             ; cbMultiByte
.text$mn:00001884                 mov     ecx, [ebp+var_8]
.text$mn:00001887                 call    ??B?$StringBuffer@D@WcharMbcsConvertor@@QAEPADXZ ; WcharMbcsConvertor::StringBuffer<char>::operator char *(void)
.text$mn:0000188C                 push    eax             ; lpMultiByteStr
.text$mn:0000188D                 mov     edx, [ebp+cchWideChar]
.text$mn:00001890                 push    edx             ; cchWideChar
.text$mn:00001891                 mov     eax, [ebp+lpWideCharStr]
.text$mn:00001894                 push    eax             ; lpWideCharStr
.text$mn:00001895                 push    0               ; dwFlags
.text$mn:00001897                 mov     ecx, [ebp+CodePage]
.text$mn:0000189A                 push    ecx             ; CodePage
.text$mn:0000189B                 call    dword ptr ds:__imp__WideCharToMultiByte@32 ; WideCharToMultiByte(x,x,x,x,x,x,x,x)
.text$mn:000018A1                 jmp     short loc_18AB
.text$mn:000018A3 ; ---------------------------------------------------------------------------
.text$mn:000018A3
.text$mn:000018A3 loc_18A3:                               ; CODE XREF: WcharMbcsConvertor::wchar2char(wchar_t const *,uint,int,int *)+36j
.text$mn:000018A3                 mov     ecx, [ebp+var_8]
.text$mn:000018A6                 call    ?empty@?$StringBuffer@D@WcharMbcsConvertor@@QAEXXZ ; WcharMbcsConvertor::StringBuffer<char>::empty(void)
.text$mn:000018AB
.text$mn:000018AB loc_18AB:                               ; CODE XREF: WcharMbcsConvertor::wchar2char(wchar_t const *,uint,int,int *)+69j
.text$mn:000018AB                 cmp     [ebp+arg_C], 0
.text$mn:000018AF                 jz      short loc_18B9
.text$mn:000018B1                 mov     edx, [ebp+arg_C]
.text$mn:000018B4                 mov     eax, [ebp+cbMultiByte]
.text$mn:000018B7                 mov     [edx], eax
.text$mn:000018B9
.text$mn:000018B9 loc_18B9:                               ; CODE XREF: WcharMbcsConvertor::wchar2char(wchar_t const *,uint,int,int *)+77j
.text$mn:000018B9                 mov     ecx, [ebp+var_8]
.text$mn:000018BC                 call    ??B?$StringBuffer@D@WcharMbcsConvertor@@QAEPADXZ ; WcharMbcsConvertor::StringBuffer<char>::operator char *(void)
.text$mn:000018C1
.text$mn:000018C1 loc_18C1:                               ; CODE XREF: WcharMbcsConvertor::wchar2char(wchar_t const *,uint,int,int *)+11j
.text$mn:000018C1                 mov     esp, ebp
.text$mn:000018C3                 pop     ebp
.text$mn:000018C4                 retn    10h
.text$mn:000018C4 ?wchar2char@WcharMbcsConvertor@@QAEPBDPB_WIHPAH@Z endp
.text$mn:000018C4
.text$mn:000018C4 ; ---------------------------------------------------------------------------
.text$mn:000018C7                 align 4
.text$mn:000018C8
.text$mn:000018C8 ; =============== S U B R O U T I N E =======================================
.text$mn:000018C8
.text$mn:000018C8 ; Attributes: bp-based frame
.text$mn:000018C8
.text$mn:000018C8 ; const char *__thiscall WcharMbcsConvertor::wchar2char(WcharMbcsConvertor *this, LPCWSTR lpWideCharStr, UINT CodePage, __int32 *, __int32 *)
.text$mn:000018C8                 public ?wchar2char@WcharMbcsConvertor@@QAEPBDPB_WIPAJ1@Z
.text$mn:000018C8 ?wchar2char@WcharMbcsConvertor@@QAEPBDPB_WIPAJ1@Z proc near
.text$mn:000018C8
.text$mn:000018C8 var_8           = dword ptr -8
.text$mn:000018C8 cbMultiByte     = dword ptr -4
.text$mn:000018C8 lpWideCharStr   = dword ptr  8
.text$mn:000018C8 CodePage        = dword ptr  0Ch
.text$mn:000018C8 arg_8           = dword ptr  10h
.text$mn:000018C8 arg_C           = dword ptr  14h
.text$mn:000018C8
.text$mn:000018C8                 push    ebp
.text$mn:000018C9                 mov     ebp, esp
.text$mn:000018CB                 sub     esp, 8
.text$mn:000018CE                 mov     [ebp+var_8], ecx
.text$mn:000018D1                 cmp     [ebp+lpWideCharStr], 0
.text$mn:000018D5                 jnz     short loc_18DE
.text$mn:000018D7                 xor     eax, eax
.text$mn:000018D9                 jmp     loc_19D7
.text$mn:000018DE ; ---------------------------------------------------------------------------
.text$mn:000018DE
.text$mn:000018DE loc_18DE:                               ; CODE XREF: WcharMbcsConvertor::wchar2char(wchar_t const *,uint,long *,long *)+Dj
.text$mn:000018DE                 push    0               ; lpUsedDefaultChar
.text$mn:000018E0                 push    0               ; lpDefaultChar
.text$mn:000018E2                 push    0               ; cbMultiByte
.text$mn:000018E4                 push    0               ; lpMultiByteStr
.text$mn:000018E6                 push    0FFFFFFFFh      ; cchWideChar
.text$mn:000018E8                 mov     eax, [ebp+lpWideCharStr]
.text$mn:000018EB                 push    eax             ; lpWideCharStr
.text$mn:000018EC                 push    0               ; dwFlags
.text$mn:000018EE                 mov     ecx, [ebp+CodePage]
.text$mn:000018F1                 push    ecx             ; CodePage
.text$mn:000018F2                 call    dword ptr ds:__imp__WideCharToMultiByte@32 ; WideCharToMultiByte(x,x,x,x,x,x,x,x)
.text$mn:000018F8                 mov     [ebp+cbMultiByte], eax
.text$mn:000018FB                 cmp     [ebp+cbMultiByte], 0
.text$mn:000018FF                 jle     loc_19C7
.text$mn:00001905                 mov     edx, [ebp+cbMultiByte]
.text$mn:00001908                 push    edx
.text$mn:00001909                 mov     ecx, [ebp+var_8]
.text$mn:0000190C                 call    ?sizeTo@?$StringBuffer@D@WcharMbcsConvertor@@QAEXI@Z ; WcharMbcsConvertor::StringBuffer<char>::sizeTo(uint)
.text$mn:00001911                 push    0               ; lpUsedDefaultChar
.text$mn:00001913                 push    0               ; lpDefaultChar
.text$mn:00001915                 mov     eax, [ebp+cbMultiByte]
.text$mn:00001918                 push    eax             ; cbMultiByte
.text$mn:00001919                 mov     ecx, [ebp+var_8]
.text$mn:0000191C                 call    ??B?$StringBuffer@D@WcharMbcsConvertor@@QAEPADXZ ; WcharMbcsConvertor::StringBuffer<char>::operator char *(void)
.text$mn:00001921                 push    eax             ; lpMultiByteStr
.text$mn:00001922                 push    0FFFFFFFFh      ; cchWideChar
.text$mn:00001924                 mov     ecx, [ebp+lpWideCharStr]
.text$mn:00001927                 push    ecx             ; lpWideCharStr
.text$mn:00001928                 push    0               ; dwFlags
.text$mn:0000192A                 mov     edx, [ebp+CodePage]
.text$mn:0000192D                 push    edx             ; CodePage
.text$mn:0000192E                 call    dword ptr ds:__imp__WideCharToMultiByte@32 ; WideCharToMultiByte(x,x,x,x,x,x,x,x)
.text$mn:00001934                 mov     [ebp+cbMultiByte], eax
.text$mn:00001937                 mov     eax, [ebp+lpWideCharStr]
.text$mn:0000193A                 push    eax             ; lpString
.text$mn:0000193B                 call    dword ptr ds:__imp__lstrlenW@4 ; lstrlenW(x)
.text$mn:00001941                 mov     ecx, [ebp+arg_8]
.text$mn:00001944                 cmp     [ecx], eax
.text$mn:00001946                 jge     short loc_19C5
.text$mn:00001948                 mov     edx, [ebp+lpWideCharStr]
.text$mn:0000194B                 push    edx             ; lpString
.text$mn:0000194C                 call    dword ptr ds:__imp__lstrlenW@4 ; lstrlenW(x)
.text$mn:00001952                 mov     ecx, [ebp+arg_C]
.text$mn:00001955                 cmp     [ecx], eax
.text$mn:00001957                 jge     short loc_19C5
.text$mn:00001959                 push    0               ; lpUsedDefaultChar
.text$mn:0000195B                 push    0               ; lpDefaultChar
.text$mn:0000195D                 push    0               ; cbMultiByte
.text$mn:0000195F                 push    0               ; lpMultiByteStr
.text$mn:00001961                 mov     edx, [ebp+arg_8]
.text$mn:00001964                 mov     eax, [edx]
.text$mn:00001966                 push    eax             ; cchWideChar
.text$mn:00001967                 mov     ecx, [ebp+lpWideCharStr]
.text$mn:0000196A                 push    ecx             ; lpWideCharStr
.text$mn:0000196B                 push    0               ; dwFlags
.text$mn:0000196D                 mov     edx, [ebp+CodePage]
.text$mn:00001970                 push    edx             ; CodePage
.text$mn:00001971                 call    dword ptr ds:__imp__WideCharToMultiByte@32 ; WideCharToMultiByte(x,x,x,x,x,x,x,x)
.text$mn:00001977                 mov     ecx, [ebp+arg_8]
.text$mn:0000197A                 mov     [ecx], eax
.text$mn:0000197C                 push    0               ; lpUsedDefaultChar
.text$mn:0000197E                 push    0               ; lpDefaultChar
.text$mn:00001980                 push    0               ; cbMultiByte
.text$mn:00001982                 push    0               ; lpMultiByteStr
.text$mn:00001984                 mov     edx, [ebp+arg_C]
.text$mn:00001987                 mov     eax, [edx]
.text$mn:00001989                 push    eax             ; cchWideChar
.text$mn:0000198A                 mov     ecx, [ebp+lpWideCharStr]
.text$mn:0000198D                 push    ecx             ; lpWideCharStr
.text$mn:0000198E                 push    0               ; dwFlags
.text$mn:00001990                 mov     edx, [ebp+CodePage]
.text$mn:00001993                 push    edx             ; CodePage
.text$mn:00001994                 call    dword ptr ds:__imp__WideCharToMultiByte@32 ; WideCharToMultiByte(x,x,x,x,x,x,x,x)
.text$mn:0000199A                 mov     ecx, [ebp+arg_C]
.text$mn:0000199D                 mov     [ecx], eax
.text$mn:0000199F                 mov     edx, [ebp+arg_8]
.text$mn:000019A2                 mov     eax, [edx]
.text$mn:000019A4                 cmp     eax, [ebp+cbMultiByte]
.text$mn:000019A7                 jge     short loc_19B3
.text$mn:000019A9                 mov     ecx, [ebp+arg_C]
.text$mn:000019AC                 mov     edx, [ecx]
.text$mn:000019AE                 cmp     edx, [ebp+cbMultiByte]
.text$mn:000019B1                 jl      short loc_19C5
.text$mn:000019B3
.text$mn:000019B3 loc_19B3:                               ; CODE XREF: WcharMbcsConvertor::wchar2char(wchar_t const *,uint,long *,long *)+DFj
.text$mn:000019B3                 mov     eax, [ebp+arg_8]
.text$mn:000019B6                 mov     dword ptr [eax], 0
.text$mn:000019BC                 mov     ecx, [ebp+arg_C]
.text$mn:000019BF                 mov     dword ptr [ecx], 0
.text$mn:000019C5
.text$mn:000019C5 loc_19C5:                               ; CODE XREF: WcharMbcsConvertor::wchar2char(wchar_t const *,uint,long *,long *)+7Ej
.text$mn:000019C5                                         ; WcharMbcsConvertor::wchar2char(wchar_t const *,uint,long *,long *)+8Fj ...
.text$mn:000019C5                 jmp     short loc_19CF
.text$mn:000019C7 ; ---------------------------------------------------------------------------
.text$mn:000019C7
.text$mn:000019C7 loc_19C7:                               ; CODE XREF: WcharMbcsConvertor::wchar2char(wchar_t const *,uint,long *,long *)+37j
.text$mn:000019C7                 mov     ecx, [ebp+var_8]
.text$mn:000019CA                 call    ?empty@?$StringBuffer@D@WcharMbcsConvertor@@QAEXXZ ; WcharMbcsConvertor::StringBuffer<char>::empty(void)
.text$mn:000019CF
.text$mn:000019CF loc_19CF:                               ; CODE XREF: WcharMbcsConvertor::wchar2char(wchar_t const *,uint,long *,long *):loc_19C5j
.text$mn:000019CF                 mov     ecx, [ebp+var_8]
.text$mn:000019D2                 call    ??B?$StringBuffer@D@WcharMbcsConvertor@@QAEPADXZ ; WcharMbcsConvertor::StringBuffer<char>::operator char *(void)
.text$mn:000019D7
.text$mn:000019D7 loc_19D7:                               ; CODE XREF: WcharMbcsConvertor::wchar2char(wchar_t const *,uint,long *,long *)+11j
.text$mn:000019D7                 mov     esp, ebp
.text$mn:000019D9                 pop     ebp
.text$mn:000019DA                 retn    10h
.text$mn:000019DA ?wchar2char@WcharMbcsConvertor@@QAEPBDPB_WIPAJ1@Z endp
.text$mn:000019DA
.text$mn:000019DA ; ---------------------------------------------------------------------------
.text$mn:000019DD                 db 0Bh dup(0CCh)
.text$mn:000019E8
.text$mn:000019E8 ; =============== S U B R O U T I N E =======================================
.text$mn:000019E8
.text$mn:000019E8 ; Attributes: bp-based frame
.text$mn:000019E8
.text$mn:000019E8 ; class std::basic_string<wchar_t, struct std::char_traits<wchar_t>, class std::allocator<wchar_t>> __cdecl PathRemoveFileSpecW(class std::basic_string<wchar_t, struct std::char_traits<wchar_t>, class std::allocator<wchar_t>> &)
.text$mn:000019E8                 public ?PathRemoveFileSpecW@@YA?AV?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@AAV12@@Z
.text$mn:000019E8 ?PathRemoveFileSpecW@@YA?AV?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@AAV12@@Z proc near
.text$mn:000019E8
.text$mn:000019E8 var_14          = dword ptr -14h
.text$mn:000019E8 var_10          = dword ptr -10h
.text$mn:000019E8 var_C           = dword ptr -0Ch
.text$mn:000019E8 var_4           = dword ptr -4
.text$mn:000019E8 arg_0           = dword ptr  8
.text$mn:000019E8 arg_4           = dword ptr  0Ch
.text$mn:000019E8
.text$mn:000019E8                 push    ebp
.text$mn:000019E9                 mov     ebp, esp
.text$mn:000019EB                 push    0FFFFFFFFh
.text$mn:000019ED                 push    offset __ehhandler$?PathRemoveFileSpecW@@YA?AV?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@AAV12@@Z
.text$mn:000019F2                 mov     eax, large fs:0
.text$mn:000019F8                 push    eax
.text$mn:000019F9                 sub     esp, 8
.text$mn:000019FC                 mov     eax, dword ptr ds:___security_cookie
.text$mn:00001A01                 xor     eax, ebp
.text$mn:00001A03                 push    eax
.text$mn:00001A04                 lea     eax, [ebp+var_C]
.text$mn:00001A07                 mov     large fs:0, eax
.text$mn:00001A0D                 mov     [ebp+var_14], 0
.text$mn:00001A14                 mov     eax, ds:?npos@?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@2IB ; uint const std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>>::npos
.text$mn:00001A19                 push    eax
.text$mn:00001A1A                 push    5Ch ; '\'
.text$mn:00001A1C                 mov     ecx, [ebp+arg_4]
.text$mn:00001A1F                 call    ?find_last_of@?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QBEI_WI@Z ; std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>>::find_last_of(wchar_t,uint)
.text$mn:00001A24                 mov     [ebp+var_10], eax
.text$mn:00001A27                 mov     ecx, [ebp+var_10]
.text$mn:00001A2A                 cmp     ecx, ds:?npos@?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@2IB ; uint const std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>>::npos
.text$mn:00001A30                 jnz     short loc_1A69
.text$mn:00001A32                 mov     ecx, [ebp+arg_4]
.text$mn:00001A35                 call    ?size@?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QBEIXZ ; std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>>::size(void)
.text$mn:00001A3A                 cmp     eax, 2
.text$mn:00001A3D                 jb      short loc_1A5D
.text$mn:00001A3F                 push    1
.text$mn:00001A41                 mov     ecx, [ebp+arg_4]
.text$mn:00001A44                 call    ??A?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QAEAA_WI@Z ; std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>>::operator[](uint)
.text$mn:00001A49                 movzx   edx, word ptr [eax]
.text$mn:00001A4C                 cmp     edx, 3Ah ; ':'
.text$mn:00001A4F                 jnz     short loc_1A5D
.text$mn:00001A51                 push    2
.text$mn:00001A53                 mov     ecx, [ebp+arg_4]
.text$mn:00001A56                 call    ?erase@?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QAEAAV12@I@Z ; std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>>::erase(uint)
.text$mn:00001A5B                 jmp     short loc_1A67
.text$mn:00001A5D ; ---------------------------------------------------------------------------
.text$mn:00001A5D
.text$mn:00001A5D loc_1A5D:                               ; CODE XREF: PathRemoveFileSpecW(std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>> &)+55j
.text$mn:00001A5D                                         ; PathRemoveFileSpecW(std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>> &)+67j
.text$mn:00001A5D                 push    0
.text$mn:00001A5F                 mov     ecx, [ebp+arg_4]
.text$mn:00001A62                 call    ?erase@?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QAEAAV12@I@Z ; std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>>::erase(uint)
.text$mn:00001A67
.text$mn:00001A67 loc_1A67:                               ; CODE XREF: PathRemoveFileSpecW(std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>> &)+73j
.text$mn:00001A67                 jmp     short loc_1AC5
.text$mn:00001A69 ; ---------------------------------------------------------------------------
.text$mn:00001A69
.text$mn:00001A69 loc_1A69:                               ; CODE XREF: PathRemoveFileSpecW(std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>> &)+48j
.text$mn:00001A69                 cmp     [ebp+var_10], 2
.text$mn:00001A6D                 jnz     short loc_1A9A
.text$mn:00001A6F                 push    1
.text$mn:00001A71                 mov     ecx, [ebp+arg_4]
.text$mn:00001A74                 call    ??A?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QAEAA_WI@Z ; std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>>::operator[](uint)
.text$mn:00001A79                 movzx   eax, word ptr [eax]
.text$mn:00001A7C                 cmp     eax, 3Ah ; ':'
.text$mn:00001A7F                 jnz     short loc_1A9A
.text$mn:00001A81                 mov     ecx, [ebp+arg_4]
.text$mn:00001A84                 call    ?size@?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QBEIXZ ; std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>>::size(void)
.text$mn:00001A89                 cmp     eax, 3
.text$mn:00001A8C                 jb      short loc_1A9A
.text$mn:00001A8E                 push    3
.text$mn:00001A90                 mov     ecx, [ebp+arg_4]
.text$mn:00001A93                 call    ?erase@?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QAEAAV12@I@Z ; std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>>::erase(uint)
.text$mn:00001A98                 jmp     short loc_1AC5
.text$mn:00001A9A ; ---------------------------------------------------------------------------
.text$mn:00001A9A
.text$mn:00001A9A loc_1A9A:                               ; CODE XREF: PathRemoveFileSpecW(std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>> &)+85j
.text$mn:00001A9A                                         ; PathRemoveFileSpecW(std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>> &)+97j ...
.text$mn:00001A9A                 cmp     [ebp+var_10], 0
.text$mn:00001A9E                 jnz     short loc_1AB9
.text$mn:00001AA0                 mov     ecx, [ebp+arg_4]
.text$mn:00001AA3                 call    ?size@?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QBEIXZ ; std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>>::size(void)
.text$mn:00001AA8                 cmp     eax, 1
.text$mn:00001AAB                 jbe     short loc_1AB9
.text$mn:00001AAD                 push    1
.text$mn:00001AAF                 mov     ecx, [ebp+arg_4]
.text$mn:00001AB2                 call    ?erase@?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QAEAAV12@I@Z ; std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>>::erase(uint)
.text$mn:00001AB7                 jmp     short loc_1AC5
.text$mn:00001AB9 ; ---------------------------------------------------------------------------
.text$mn:00001AB9
.text$mn:00001AB9 loc_1AB9:                               ; CODE XREF: PathRemoveFileSpecW(std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>> &)+B6j
.text$mn:00001AB9                                         ; PathRemoveFileSpecW(std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>> &)+C3j
.text$mn:00001AB9                 mov     ecx, [ebp+var_10]
.text$mn:00001ABC                 push    ecx
.text$mn:00001ABD                 mov     ecx, [ebp+arg_4]
.text$mn:00001AC0                 call    ?erase@?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QAEAAV12@I@Z ; std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>>::erase(uint)
.text$mn:00001AC5
.text$mn:00001AC5 loc_1AC5:                               ; CODE XREF: PathRemoveFileSpecW(std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>> &):loc_1A67j
.text$mn:00001AC5                                         ; PathRemoveFileSpecW(std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>> &)+B0j ...
.text$mn:00001AC5                 mov     edx, [ebp+arg_4]
.text$mn:00001AC8                 push    edx
.text$mn:00001AC9                 mov     ecx, [ebp+arg_0]
.text$mn:00001ACC                 call    ??0?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QAE@ABV01@@Z ; std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>>::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>>(std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>> const &)
.text$mn:00001AD1                 mov     [ebp+var_4], 0
.text$mn:00001AD8                 mov     eax, [ebp+var_14]
.text$mn:00001ADB                 or      eax, 1
.text$mn:00001ADE                 mov     [ebp+var_14], eax
.text$mn:00001AE1                 mov     eax, [ebp+arg_0]
.text$mn:00001AE4                 mov     ecx, [ebp+var_C]
.text$mn:00001AE7                 mov     large fs:0, ecx
.text$mn:00001AEE                 pop     ecx
.text$mn:00001AEF                 mov     esp, ebp
.text$mn:00001AF1                 pop     ebp
.text$mn:00001AF2                 retn
.text$mn:00001AF2 ?PathRemoveFileSpecW@@YA?AV?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@AAV12@@Z endp
.text$mn:00001AF2
.text$mn:00001AF2 ; ---------------------------------------------------------------------------
.text$mn:00001AF3                 align 8
.text$mn:00001AF8
.text$mn:00001AF8 ; =============== S U B R O U T I N E =======================================
.text$mn:00001AF8
.text$mn:00001AF8 ; Attributes: bp-based frame
.text$mn:00001AF8
.text$mn:00001AF8 ; class std::basic_string<wchar_t, struct std::char_traits<wchar_t>, class std::allocator<wchar_t>> __cdecl PathAppendW(class std::basic_string<wchar_t, struct std::char_traits<wchar_t>, class std::allocator<wchar_t>> &, class std::basic_string<wchar_t, struct std::char_traits<wchar_t>, class std::allocator<wchar_t>> const &)
.text$mn:00001AF8                 public ?PathAppendW@@YA?AV?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@AAV12@ABV12@@Z
.text$mn:00001AF8 ?PathAppendW@@YA?AV?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@AAV12@ABV12@@Z proc near
.text$mn:00001AF8
.text$mn:00001AF8 var_10          = dword ptr -10h
.text$mn:00001AF8 var_C           = dword ptr -0Ch
.text$mn:00001AF8 var_4           = dword ptr -4
.text$mn:00001AF8 arg_0           = dword ptr  8
.text$mn:00001AF8 arg_4           = dword ptr  0Ch
.text$mn:00001AF8 arg_8           = dword ptr  10h
.text$mn:00001AF8
.text$mn:00001AF8                 push    ebp
.text$mn:00001AF9                 mov     ebp, esp
.text$mn:00001AFB                 push    0FFFFFFFFh
.text$mn:00001AFD                 push    offset __ehhandler$?PathAppendW@@YA?AV?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@AAV12@ABV12@@Z
.text$mn:00001B02                 mov     eax, large fs:0
.text$mn:00001B08                 push    eax
.text$mn:00001B09                 push    ecx
.text$mn:00001B0A                 mov     eax, dword ptr ds:___security_cookie
.text$mn:00001B0F                 xor     eax, ebp
.text$mn:00001B11                 push    eax
.text$mn:00001B12                 lea     eax, [ebp+var_C]
.text$mn:00001B15                 mov     large fs:0, eax
.text$mn:00001B1B                 mov     [ebp+var_10], 0
.text$mn:00001B22                 push    offset $SG118853 ; Str
.text$mn:00001B27                 mov     eax, [ebp+arg_4]
.text$mn:00001B2A                 push    eax             ; int
.text$mn:00001B2B                 call    ??$?8_WU?$char_traits@_W@std@@V?$allocator@_W@1@@std@@YA_NABV?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@0@PB_W@Z ; std::operator==<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>>(std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>> const &,wchar_t const *)
.text$mn:00001B30                 add     esp, 8
.text$mn:00001B33                 movzx   ecx, al
.text$mn:00001B36                 test    ecx, ecx
.text$mn:00001B38                 jz      short loc_1B83
.text$mn:00001B3A                 push    offset $SG118854 ; Str
.text$mn:00001B3F                 mov     edx, [ebp+arg_8]
.text$mn:00001B42                 push    edx             ; int
.text$mn:00001B43                 call    ??$?8_WU?$char_traits@_W@std@@V?$allocator@_W@1@@std@@YA_NABV?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@0@PB_W@Z ; std::operator==<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>>(std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>> const &,wchar_t const *)
.text$mn:00001B48                 add     esp, 8
.text$mn:00001B4B                 movzx   eax, al
.text$mn:00001B4E                 test    eax, eax
.text$mn:00001B50                 jz      short loc_1B83
.text$mn:00001B52                 push    offset $SG118855 ; Str
.text$mn:00001B57                 mov     ecx, [ebp+arg_4]
.text$mn:00001B5A                 call    ??4?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QAEAAV01@PB_W@Z ; std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>>::operator=(wchar_t const *)
.text$mn:00001B5F                 mov     ecx, [ebp+arg_4]
.text$mn:00001B62                 push    ecx
.text$mn:00001B63                 mov     ecx, [ebp+arg_0]
.text$mn:00001B66                 call    ??0?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QAE@ABV01@@Z ; std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>>::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>>(std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>> const &)
.text$mn:00001B6B                 mov     [ebp+var_4], 0
.text$mn:00001B72                 mov     edx, [ebp+var_10]
.text$mn:00001B75                 or      edx, 1
.text$mn:00001B78                 mov     [ebp+var_10], edx
.text$mn:00001B7B                 mov     eax, [ebp+arg_0]
.text$mn:00001B7E                 jmp     loc_1D60
.text$mn:00001B83 ; ---------------------------------------------------------------------------
.text$mn:00001B83
.text$mn:00001B83 loc_1B83:                               ; CODE XREF: PathAppendW(std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>> &,std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>> const &)+40j
.text$mn:00001B83                                         ; PathAppendW(std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>> &,std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>> const &)+58j
.text$mn:00001B83                 push    offset $SG118899 ; Str
.text$mn:00001B88                 mov     eax, [ebp+arg_4]
.text$mn:00001B8B                 push    eax             ; int
.text$mn:00001B8C                 call    ??$?8_WU?$char_traits@_W@std@@V?$allocator@_W@1@@std@@YA_NABV?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@0@PB_W@Z ; std::operator==<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>>(std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>> const &,wchar_t const *)
.text$mn:00001B91                 add     esp, 8
.text$mn:00001B94                 movzx   ecx, al
.text$mn:00001B97                 test    ecx, ecx
.text$mn:00001B99                 jz      short loc_1BE3
.text$mn:00001B9B                 push    offset $SG118900 ; Str
.text$mn:00001BA0                 mov     edx, [ebp+arg_8]
.text$mn:00001BA3                 push    edx             ; int
.text$mn:00001BA4                 call    ??$?9_WU?$char_traits@_W@std@@V?$allocator@_W@1@@std@@YA_NABV?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@0@PB_W@Z ; std::operator!=<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>>(std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>> const &,wchar_t const *)
.text$mn:00001BA9                 add     esp, 8
.text$mn:00001BAC                 movzx   eax, al
.text$mn:00001BAF                 test    eax, eax
.text$mn:00001BB1                 jz      short loc_1BE3
.text$mn:00001BB3                 mov     ecx, [ebp+arg_8]
.text$mn:00001BB6                 push    ecx
.text$mn:00001BB7                 mov     ecx, [ebp+arg_4]
.text$mn:00001BBA                 call    ??4?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QAEAAV01@ABV01@@Z ; std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>>::operator=(std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>> const &)
.text$mn:00001BBF                 mov     edx, [ebp+arg_4]
.text$mn:00001BC2                 push    edx
.text$mn:00001BC3                 mov     ecx, [ebp+arg_0]
.text$mn:00001BC6                 call    ??0?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QAE@ABV01@@Z ; std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>>::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>>(std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>> const &)
.text$mn:00001BCB                 mov     [ebp+var_4], 0
.text$mn:00001BD2                 mov     eax, [ebp+var_10]
.text$mn:00001BD5                 or      eax, 1
.text$mn:00001BD8                 mov     [ebp+var_10], eax
.text$mn:00001BDB                 mov     eax, [ebp+arg_0]
.text$mn:00001BDE                 jmp     loc_1D60
.text$mn:00001BE3 ; ---------------------------------------------------------------------------
.text$mn:00001BE3
.text$mn:00001BE3 loc_1BE3:                               ; CODE XREF: PathAppendW(std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>> &,std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>> const &)+A1j
.text$mn:00001BE3                                         ; PathAppendW(std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>> &,std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>> const &)+B9j
.text$mn:00001BE3                 mov     ecx, [ebp+arg_4]
.text$mn:00001BE6                 call    ?length@?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QBEIXZ ; std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>>::length(void)
.text$mn:00001BEB                 sub     eax, 1
.text$mn:00001BEE                 push    eax
.text$mn:00001BEF                 mov     ecx, [ebp+arg_4]
.text$mn:00001BF2                 call    ??A?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QAEAA_WI@Z ; std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>>::operator[](uint)
.text$mn:00001BF7                 movzx   ecx, word ptr [eax]
.text$mn:00001BFA                 cmp     ecx, 5Ch ; '\'
.text$mn:00001BFD                 jnz     short loc_1C6F
.text$mn:00001BFF                 push    offset $SG118918 ; Str
.text$mn:00001C04                 mov     edx, [ebp+arg_8]
.text$mn:00001C07                 push    edx             ; int
.text$mn:00001C08                 call    ??$?9_WU?$char_traits@_W@std@@V?$allocator@_W@1@@std@@YA_NABV?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@0@PB_W@Z ; std::operator!=<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>>(std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>> const &,wchar_t const *)
.text$mn:00001C0D                 add     esp, 8
.text$mn:00001C10                 movzx   eax, al
.text$mn:00001C13                 test    eax, eax
.text$mn:00001C15                 jz      short loc_1C6F
.text$mn:00001C17                 push    0
.text$mn:00001C19                 mov     ecx, [ebp+arg_8]
.text$mn:00001C1C                 call    ??A?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QBEAB_WI@Z ; std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>>::operator[](uint)
.text$mn:00001C21                 movzx   ecx, word ptr [eax]
.text$mn:00001C24                 cmp     ecx, 5Ch ; '\'
.text$mn:00001C27                 jnz     short loc_1C6F
.text$mn:00001C29                 push    1
.text$mn:00001C2B                 mov     ecx, [ebp+arg_4]
.text$mn:00001C2E                 call    ?length@?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QBEIXZ ; std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>>::length(void)
.text$mn:00001C33                 sub     eax, 1
.text$mn:00001C36                 push    eax
.text$mn:00001C37                 mov     ecx, [ebp+arg_4]
.text$mn:00001C3A                 call    ?erase@?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QAEAAV12@II@Z ; std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>>::erase(uint,uint)
.text$mn:00001C3F                 mov     edx, [ebp+arg_8]
.text$mn:00001C42                 push    edx
.text$mn:00001C43                 mov     ecx, [ebp+arg_4]
.text$mn:00001C46                 call    ??Y?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QAEAAV01@ABV01@@Z ; std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>>::operator+=(std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>> const &)
.text$mn:00001C4B                 mov     eax, [ebp+arg_4]
.text$mn:00001C4E                 push    eax
.text$mn:00001C4F                 mov     ecx, [ebp+arg_0]
.text$mn:00001C52                 call    ??0?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QAE@ABV01@@Z ; std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>>::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>>(std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>> const &)
.text$mn:00001C57                 mov     [ebp+var_4], 0
.text$mn:00001C5E                 mov     ecx, [ebp+var_10]
.text$mn:00001C61                 or      ecx, 1
.text$mn:00001C64                 mov     [ebp+var_10], ecx
.text$mn:00001C67                 mov     eax, [ebp+arg_0]
.text$mn:00001C6A                 jmp     loc_1D60
.text$mn:00001C6F ; ---------------------------------------------------------------------------
.text$mn:00001C6F
.text$mn:00001C6F loc_1C6F:                               ; CODE XREF: PathAppendW(std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>> &,std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>> const &)+105j
.text$mn:00001C6F                                         ; PathAppendW(std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>> &,std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>> const &)+11Dj ...
.text$mn:00001C6F                 mov     ecx, [ebp+arg_4]
.text$mn:00001C72                 call    ?length@?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QBEIXZ ; std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>>::length(void)
.text$mn:00001C77                 sub     eax, 1
.text$mn:00001C7A                 push    eax
.text$mn:00001C7B                 mov     ecx, [ebp+arg_4]
.text$mn:00001C7E                 call    ??A?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QAEAA_WI@Z ; std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>>::operator[](uint)
.text$mn:00001C83                 movzx   edx, word ptr [eax]
.text$mn:00001C86                 cmp     edx, 5Ch ; '\'
.text$mn:00001C89                 jnz     short loc_1CB5
.text$mn:00001C8B                 push    offset $SG118955 ; Str
.text$mn:00001C90                 mov     eax, [ebp+arg_8]
.text$mn:00001C93                 push    eax             ; int
.text$mn:00001C94                 call    ??$?9_WU?$char_traits@_W@std@@V?$allocator@_W@1@@std@@YA_NABV?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@0@PB_W@Z ; std::operator!=<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>>(std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>> const &,wchar_t const *)
.text$mn:00001C99                 add     esp, 8
.text$mn:00001C9C                 movzx   ecx, al
.text$mn:00001C9F                 test    ecx, ecx
.text$mn:00001CA1                 jz      short loc_1CB5
.text$mn:00001CA3                 push    0
.text$mn:00001CA5                 mov     ecx, [ebp+arg_8]
.text$mn:00001CA8                 call    ??A?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QBEAB_WI@Z ; std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>>::operator[](uint)
.text$mn:00001CAD                 movzx   edx, word ptr [eax]
.text$mn:00001CB0                 cmp     edx, 5Ch ; '\'
.text$mn:00001CB3                 jnz     short loc_1CFB
.text$mn:00001CB5
.text$mn:00001CB5 loc_1CB5:                               ; CODE XREF: PathAppendW(std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>> &,std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>> const &)+191j
.text$mn:00001CB5                                         ; PathAppendW(std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>> &,std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>> const &)+1A9j
.text$mn:00001CB5                 mov     ecx, [ebp+arg_4]
.text$mn:00001CB8                 call    ?length@?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QBEIXZ ; std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>>::length(void)
.text$mn:00001CBD                 sub     eax, 1
.text$mn:00001CC0                 push    eax
.text$mn:00001CC1                 mov     ecx, [ebp+arg_4]
.text$mn:00001CC4                 call    ??A?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QAEAA_WI@Z ; std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>>::operator[](uint)
.text$mn:00001CC9                 movzx   eax, word ptr [eax]
.text$mn:00001CCC                 cmp     eax, 5Ch ; '\'
.text$mn:00001CCF                 jz      short loc_1D28
.text$mn:00001CD1                 push    offset $SG118956 ; Str
.text$mn:00001CD6                 mov     ecx, [ebp+arg_8]
.text$mn:00001CD9                 push    ecx             ; int
.text$mn:00001CDA                 call    ??$?9_WU?$char_traits@_W@std@@V?$allocator@_W@1@@std@@YA_NABV?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@0@PB_W@Z ; std::operator!=<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>>(std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>> const &,wchar_t const *)
.text$mn:00001CDF                 add     esp, 8
.text$mn:00001CE2                 movzx   edx, al
.text$mn:00001CE5                 test    edx, edx
.text$mn:00001CE7                 jz      short loc_1D28
.text$mn:00001CE9                 push    0
.text$mn:00001CEB                 mov     ecx, [ebp+arg_8]
.text$mn:00001CEE                 call    ??A?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QBEAB_WI@Z ; std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>>::operator[](uint)
.text$mn:00001CF3                 movzx   eax, word ptr [eax]
.text$mn:00001CF6                 cmp     eax, 5Ch ; '\'
.text$mn:00001CF9                 jnz     short loc_1D28
.text$mn:00001CFB
.text$mn:00001CFB loc_1CFB:                               ; CODE XREF: PathAppendW(std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>> &,std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>> const &)+1BBj
.text$mn:00001CFB                 mov     ecx, [ebp+arg_8]
.text$mn:00001CFE                 push    ecx
.text$mn:00001CFF                 mov     ecx, [ebp+arg_4]
.text$mn:00001D02                 call    ??Y?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QAEAAV01@ABV01@@Z ; std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>>::operator+=(std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>> const &)
.text$mn:00001D07                 mov     edx, [ebp+arg_4]
.text$mn:00001D0A                 push    edx
.text$mn:00001D0B                 mov     ecx, [ebp+arg_0]
.text$mn:00001D0E                 call    ??0?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QAE@ABV01@@Z ; std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>>::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>>(std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>> const &)
.text$mn:00001D13                 mov     [ebp+var_4], 0
.text$mn:00001D1A                 mov     eax, [ebp+var_10]
.text$mn:00001D1D                 or      eax, 1
.text$mn:00001D20                 mov     [ebp+var_10], eax
.text$mn:00001D23                 mov     eax, [ebp+arg_0]
.text$mn:00001D26                 jmp     short loc_1D60
.text$mn:00001D28 ; ---------------------------------------------------------------------------
.text$mn:00001D28
.text$mn:00001D28 loc_1D28:                               ; CODE XREF: PathAppendW(std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>> &,std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>> const &)+1D7j
.text$mn:00001D28                                         ; PathAppendW(std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>> &,std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>> const &)+1EFj ...
.text$mn:00001D28                 push    offset $SG118957 ; Str
.text$mn:00001D2D                 mov     ecx, [ebp+arg_4]
.text$mn:00001D30                 call    ??Y?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QAEAAV01@PB_W@Z ; std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>>::operator+=(wchar_t const *)
.text$mn:00001D35                 mov     ecx, [ebp+arg_8]
.text$mn:00001D38                 push    ecx
.text$mn:00001D39                 mov     ecx, [ebp+arg_4]
.text$mn:00001D3C                 call    ??Y?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QAEAAV01@ABV01@@Z ; std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>>::operator+=(std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>> const &)
.text$mn:00001D41                 mov     edx, [ebp+arg_4]
.text$mn:00001D44                 push    edx
.text$mn:00001D45                 mov     ecx, [ebp+arg_0]
.text$mn:00001D48                 call    ??0?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QAE@ABV01@@Z ; std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>>::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>>(std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>> const &)
.text$mn:00001D4D                 mov     [ebp+var_4], 0
.text$mn:00001D54                 mov     eax, [ebp+var_10]
.text$mn:00001D57                 or      eax, 1
.text$mn:00001D5A                 mov     [ebp+var_10], eax
.text$mn:00001D5D                 mov     eax, [ebp+arg_0]
.text$mn:00001D60
.text$mn:00001D60 loc_1D60:                               ; CODE XREF: PathAppendW(std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>> &,std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>> const &)+86j
.text$mn:00001D60                                         ; PathAppendW(std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>> &,std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>> const &)+E6j ...
.text$mn:00001D60                 mov     ecx, [ebp+var_C]
.text$mn:00001D63                 mov     large fs:0, ecx
.text$mn:00001D6A                 pop     ecx
.text$mn:00001D6B                 mov     esp, ebp
.text$mn:00001D6D                 pop     ebp
.text$mn:00001D6E                 retn
.text$mn:00001D6E ?PathAppendW@@YA?AV?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@AAV12@ABV12@@Z endp
.text$mn:00001D6E
.text$mn:00001D6E ; ---------------------------------------------------------------------------
.text$mn:00001D6F                 db 9 dup(0CCh)
.text$mn:00001D78
.text$mn:00001D78 ; =============== S U B R O U T I N E =======================================
.text$mn:00001D78
.text$mn:00001D78 ; Attributes: bp-based frame
.text$mn:00001D78
.text$mn:00001D78 ; unsigned __int32 __cdecl getCtrlBgColor(HWND hWnd)
.text$mn:00001D78                 public ?getCtrlBgColor@@YAKPAUHWND__@@@Z
.text$mn:00001D78 ?getCtrlBgColor@@YAKPAUHWND__@@@Z proc near
.text$mn:00001D78
.text$mn:00001D78 var_28          = dword ptr -28h
.text$mn:00001D78 var_24          = dword ptr -24h
.text$mn:00001D78 h               = dword ptr -20h
.text$mn:00001D78 hdc             = dword ptr -1Ch
.text$mn:00001D78 var_18          = dword ptr -18h
.text$mn:00001D78 Rect            = tagRECT ptr -14h
.text$mn:00001D78 var_4           = dword ptr -4
.text$mn:00001D78 hWnd            = dword ptr  8
.text$mn:00001D78
.text$mn:00001D78                 push    ebp
.text$mn:00001D79                 mov     ebp, esp
.text$mn:00001D7B                 sub     esp, 28h
.text$mn:00001D7E                 mov     eax, dword ptr ds:___security_cookie
.text$mn:00001D83                 xor     eax, ebp
.text$mn:00001D85                 mov     [ebp+var_4], eax
.text$mn:00001D88                 mov     [ebp+var_24], 0FFFFFFFFh
.text$mn:00001D8F                 cmp     [ebp+hWnd], 0
.text$mn:00001D93                 jz      loc_1E74
.text$mn:00001D99                 mov     eax, [ebp+hWnd]
.text$mn:00001D9C                 push    eax             ; hWnd
.text$mn:00001D9D                 call    dword ptr ds:__imp__IsWindow@4 ; IsWindow(x)
.text$mn:00001DA3                 test    eax, eax
.text$mn:00001DA5                 jz      loc_1E74
.text$mn:00001DAB                 lea     ecx, [ebp+Rect]
.text$mn:00001DAE                 push    ecx             ; lpRect
.text$mn:00001DAF                 mov     edx, [ebp+hWnd]
.text$mn:00001DB2                 push    edx             ; hWnd
.text$mn:00001DB3                 call    dword ptr ds:__imp__GetClientRect@8 ; GetClientRect(x,x)
.text$mn:00001DB9                 test    eax, eax
.text$mn:00001DBB                 jz      loc_1E74
.text$mn:00001DC1                 mov     eax, [ebp+hWnd]
.text$mn:00001DC4                 push    eax             ; hWnd
.text$mn:00001DC5                 call    dword ptr ds:__imp__GetDC@4 ; GetDC(x)
.text$mn:00001DCB                 mov     [ebp+hdc], eax
.text$mn:00001DCE                 cmp     [ebp+hdc], 0
.text$mn:00001DD2                 jz      loc_1E74
.text$mn:00001DD8                 mov     ecx, [ebp+hdc]
.text$mn:00001DDB                 push    ecx             ; hdc
.text$mn:00001DDC                 call    dword ptr ds:__imp__CreateCompatibleDC@4 ; CreateCompatibleDC(x)
.text$mn:00001DE2                 mov     [ebp+var_18], eax
.text$mn:00001DE5                 cmp     [ebp+var_18], 0
.text$mn:00001DE9                 jz      short loc_1E66
.text$mn:00001DEB                 mov     edx, [ebp+Rect.bottom]
.text$mn:00001DEE                 push    edx             ; cy
.text$mn:00001DEF                 mov     eax, [ebp+Rect.right]
.text$mn:00001DF2                 push    eax             ; cx
.text$mn:00001DF3                 mov     ecx, [ebp+hdc]
.text$mn:00001DF6                 push    ecx             ; hdc
.text$mn:00001DF7                 call    dword ptr ds:__imp__CreateCompatibleBitmap@12 ; CreateCompatibleBitmap(x,x,x)
.text$mn:00001DFD                 mov     [ebp+h], eax
.text$mn:00001E00                 cmp     [ebp+h], 0
.text$mn:00001E04                 jz      short loc_1E5C
.text$mn:00001E06                 mov     edx, [ebp+h]
.text$mn:00001E09                 push    edx             ; h
.text$mn:00001E0A                 mov     eax, [ebp+var_18]
.text$mn:00001E0D                 push    eax             ; hdc
.text$mn:00001E0E                 call    dword ptr ds:__imp__SelectObject@8 ; SelectObject(x,x)
.text$mn:00001E14                 mov     [ebp+var_28], eax
.text$mn:00001E17                 cmp     [ebp+var_28], 0
.text$mn:00001E1B                 jz      short loc_1E52
.text$mn:00001E1D                 push    0               ; lParam
.text$mn:00001E1F                 mov     ecx, [ebp+var_18]
.text$mn:00001E22                 push    ecx             ; wParam
.text$mn:00001E23                 push    14h             ; Msg
.text$mn:00001E25                 mov     edx, [ebp+hWnd]
.text$mn:00001E28                 push    edx             ; hWnd
.text$mn:00001E29                 call    dword ptr ds:__imp__SendMessageW@16 ; SendMessageW(x,x,x,x)
.text$mn:00001E2F                 test    eax, eax
.text$mn:00001E31                 jz      short loc_1E44
.text$mn:00001E33                 push    2               ; y
.text$mn:00001E35                 push    2               ; x
.text$mn:00001E37                 mov     eax, [ebp+var_18]
.text$mn:00001E3A                 push    eax             ; hdc
.text$mn:00001E3B                 call    dword ptr ds:__imp__GetPixel@12 ; GetPixel(x,x,x)
.text$mn:00001E41                 mov     [ebp+var_24], eax
.text$mn:00001E44
.text$mn:00001E44 loc_1E44:                               ; CODE XREF: getCtrlBgColor(HWND__ *)+B9j
.text$mn:00001E44                 mov     ecx, [ebp+var_28]
.text$mn:00001E47                 push    ecx             ; h
.text$mn:00001E48                 mov     edx, [ebp+var_18]
.text$mn:00001E4B                 push    edx             ; hdc
.text$mn:00001E4C                 call    dword ptr ds:__imp__SelectObject@8 ; SelectObject(x,x)
.text$mn:00001E52
.text$mn:00001E52 loc_1E52:                               ; CODE XREF: getCtrlBgColor(HWND__ *)+A3j
.text$mn:00001E52                 mov     eax, [ebp+h]
.text$mn:00001E55                 push    eax             ; ho
.text$mn:00001E56                 call    dword ptr ds:__imp__DeleteObject@4 ; DeleteObject(x)
.text$mn:00001E5C
.text$mn:00001E5C loc_1E5C:                               ; CODE XREF: getCtrlBgColor(HWND__ *)+8Cj
.text$mn:00001E5C                 mov     ecx, [ebp+var_18]
.text$mn:00001E5F                 push    ecx             ; hdc
.text$mn:00001E60                 call    dword ptr ds:__imp__DeleteDC@4 ; DeleteDC(x)
.text$mn:00001E66
.text$mn:00001E66 loc_1E66:                               ; CODE XREF: getCtrlBgColor(HWND__ *)+71j
.text$mn:00001E66                 mov     edx, [ebp+hdc]
.text$mn:00001E69                 push    edx             ; hDC
.text$mn:00001E6A                 mov     eax, [ebp+hWnd]
.text$mn:00001E6D                 push    eax             ; hWnd
.text$mn:00001E6E                 call    dword ptr ds:__imp__ReleaseDC@8 ; ReleaseDC(x,x)
.text$mn:00001E74
.text$mn:00001E74 loc_1E74:                               ; CODE XREF: getCtrlBgColor(HWND__ *)+1Bj
.text$mn:00001E74                                         ; getCtrlBgColor(HWND__ *)+2Dj ...
.text$mn:00001E74                 mov     eax, [ebp+var_24]
.text$mn:00001E77                 mov     ecx, [ebp+var_4]
.text$mn:00001E7A                 xor     ecx, ebp
.text$mn:00001E7C                 call    @__security_check_cookie@4 ; __security_check_cookie(x)
.text$mn:00001E81                 mov     esp, ebp
.text$mn:00001E83                 pop     ebp
.text$mn:00001E84                 retn
.text$mn:00001E84 ?getCtrlBgColor@@YAKPAUHWND__@@@Z endp
.text$mn:00001E84
.text$mn:00001E84 ; ---------------------------------------------------------------------------
.text$mn:00001E85                 align 4
.text$mn:00001E88
.text$mn:00001E88 ; =============== S U B R O U T I N E =======================================
.text$mn:00001E88
.text$mn:00001E88 ; Attributes: bp-based frame
.text$mn:00001E88
.text$mn:00001E88 ; class std::basic_string<wchar_t, struct std::char_traits<wchar_t>, class std::allocator<wchar_t>> __cdecl stringToUpper(class std::basic_string<wchar_t, struct std::char_traits<wchar_t>, class std::allocator<wchar_t>>)
.text$mn:00001E88                 public ?stringToUpper@@YA?AV?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@V12@@Z
.text$mn:00001E88 ?stringToUpper@@YA?AV?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@V12@@Z proc near
.text$mn:00001E88
.text$mn:00001E88 var_44          = byte ptr -44h
.text$mn:00001E88 var_38          = dword ptr -38h
.text$mn:00001E88 var_34          = dword ptr -34h
.text$mn:00001E88 var_30          = dword ptr -30h
.text$mn:00001E88 var_2C          = dword ptr -2Ch
.text$mn:00001E88 var_28          = dword ptr -28h
.text$mn:00001E88 var_24          = dword ptr -24h
.text$mn:00001E88 var_20          = dword ptr -20h
.text$mn:00001E88 var_1C          = dword ptr -1Ch
.text$mn:00001E88 var_18          = dword ptr -18h
.text$mn:00001E88 var_14          = dword ptr -14h
.text$mn:00001E88 var_10          = dword ptr -10h
.text$mn:00001E88 var_C           = dword ptr -0Ch
.text$mn:00001E88 var_4           = dword ptr -4
.text$mn:00001E88 arg_0           = dword ptr  8
.text$mn:00001E88 arg_4           = byte ptr  0Ch
.text$mn:00001E88
.text$mn:00001E88                 push    ebp
.text$mn:00001E89                 mov     ebp, esp
.text$mn:00001E8B                 push    0FFFFFFFFh
.text$mn:00001E8D                 push    offset __ehhandler$?stringToUpper@@YA?AV?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@V12@@Z
.text$mn:00001E92                 mov     eax, large fs:0
.text$mn:00001E98                 push    eax
.text$mn:00001E99                 sub     esp, 38h
.text$mn:00001E9C                 mov     eax, dword ptr ds:___security_cookie
.text$mn:00001EA1                 xor     eax, ebp
.text$mn:00001EA3                 push    eax
.text$mn:00001EA4                 lea     eax, [ebp+var_C]
.text$mn:00001EA7                 mov     large fs:0, eax
.text$mn:00001EAD                 mov     [ebp+var_10], 0
.text$mn:00001EB4                 mov     [ebp+var_4], 1
.text$mn:00001EBB                 push    offset _toupper
.text$mn:00001EC0                 sub     esp, 0Ch
.text$mn:00001EC3                 mov     eax, esp
.text$mn:00001EC5                 mov     [ebp+var_20], esp
.text$mn:00001EC8                 push    eax
.text$mn:00001EC9                 lea     ecx, [ebp+arg_4]
.text$mn:00001ECC                 call    ?begin@?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QAE?AV?$_String_iterator@V?$_String_val@U?$_Simple_types@_W@std@@@std@@@2@XZ ; std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>>::begin(void)
.text$mn:00001ED1                 mov     [ebp+var_14], eax
.text$mn:00001ED4                 mov     ecx, [ebp+var_14]
.text$mn:00001ED7                 mov     [ebp+var_24], ecx
.text$mn:00001EDA                 mov     byte ptr [ebp+var_4], 2
.text$mn:00001EDE                 sub     esp, 0Ch
.text$mn:00001EE1                 mov     edx, esp
.text$mn:00001EE3                 mov     [ebp+var_28], esp
.text$mn:00001EE6                 push    edx
.text$mn:00001EE7                 lea     ecx, [ebp+arg_4]
.text$mn:00001EEA                 call    ?end@?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QAE?AV?$_String_iterator@V?$_String_val@U?$_Simple_types@_W@std@@@std@@@2@XZ ; std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>>::end(void)
.text$mn:00001EEF                 mov     [ebp+var_18], eax
.text$mn:00001EF2                 mov     eax, [ebp+var_18]
.text$mn:00001EF5                 mov     [ebp+var_2C], eax
.text$mn:00001EF8                 mov     byte ptr [ebp+var_4], 3
.text$mn:00001EFC                 sub     esp, 0Ch
.text$mn:00001EFF                 mov     ecx, esp
.text$mn:00001F01                 mov     [ebp+var_30], esp
.text$mn:00001F04                 push    ecx
.text$mn:00001F05                 lea     ecx, [ebp+arg_4]
.text$mn:00001F08                 call    ?begin@?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QAE?AV?$_String_iterator@V?$_String_val@U?$_Simple_types@_W@std@@@std@@@2@XZ ; std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>>::begin(void)
.text$mn:00001F0D                 mov     [ebp+var_1C], eax
.text$mn:00001F10                 mov     edx, [ebp+var_1C]
.text$mn:00001F13                 mov     [ebp+var_34], edx
.text$mn:00001F16                 mov     byte ptr [ebp+var_4], 4
.text$mn:00001F1A                 lea     eax, [ebp+var_44]
.text$mn:00001F1D                 push    eax
.text$mn:00001F1E                 mov     byte ptr [ebp+var_4], 1
.text$mn:00001F22                 call    ??$transform@V?$_String_iterator@V?$_String_val@U?$_Simple_types@_W@std@@@std@@@std@@V12@P6AHH@Z@std@@YA?AV?$_String_iterator@V?$_String_val@U?$_Simple_types@_W@std@@@std@@@0@V10@00P6AHH@Z@Z ; std::transform<std::_String_iterator<std::_String_val<std::_Simple_types<wchar_t>>>,std::_String_iterator<std::_String_val<std::_Simple_types<wchar_t>>>,int (*)(int)>(std::_String_iterator<std::_String_val<std::_Simple_types<wchar_t>>>,std::_String_iterator<std::_String_val<std::_Simple_types<wchar_t>>>,std::_String_iterator<std::_String_val<std::_Simple_types<wchar_t>>>,int (*)(int))
.text$mn:00001F27                 add     esp, 2Ch
.text$mn:00001F2A                 mov     [ebp+var_38], eax
.text$mn:00001F2D                 lea     ecx, [ebp+var_44]
.text$mn:00001F30                 call    ??1?$_String_iterator@V?$_String_val@U?$_Simple_types@_W@std@@@std@@@std@@QAE@XZ ; std::_String_iterator<std::_String_val<std::_Simple_types<wchar_t>>>::~_String_iterator<std::_String_val<std::_Simple_types<wchar_t>>>(void)
.text$mn:00001F35                 lea     ecx, [ebp+arg_4]
.text$mn:00001F38                 push    ecx
.text$mn:00001F39                 mov     ecx, [ebp+arg_0]
.text$mn:00001F3C                 call    ??0?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QAE@$$QAV01@@Z ; std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>>::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>>(std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>> &&)
.text$mn:00001F41                 mov     edx, [ebp+var_10]
.text$mn:00001F44                 or      edx, 1
.text$mn:00001F47                 mov     [ebp+var_10], edx
.text$mn:00001F4A                 mov     byte ptr [ebp+var_4], 0
.text$mn:00001F4E                 lea     ecx, [ebp+arg_4]
.text$mn:00001F51                 call    ??1?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QAE@XZ ; std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>>::~basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>>(void)
.text$mn:00001F56                 mov     eax, [ebp+arg_0]
.text$mn:00001F59                 mov     ecx, [ebp+var_C]
.text$mn:00001F5C                 mov     large fs:0, ecx
.text$mn:00001F63                 pop     ecx
.text$mn:00001F64                 mov     esp, ebp
.text$mn:00001F66                 pop     ebp
.text$mn:00001F67                 retn
.text$mn:00001F67 ?stringToUpper@@YA?AV?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@V12@@Z endp
.text$mn:00001F67
.text$mn:00001F68
.text$mn:00001F68 ; =============== S U B R O U T I N E =======================================
.text$mn:00001F68
.text$mn:00001F68 ; Attributes: bp-based frame
.text$mn:00001F68
.text$mn:00001F68 ; class std::basic_string<wchar_t, struct std::char_traits<wchar_t>, class std::allocator<wchar_t>> __cdecl stringReplace(class std::basic_string<wchar_t, struct std::char_traits<wchar_t>, class std::allocator<wchar_t>>, class std::basic_string<wchar_t, struct std::char_traits<wchar_t>, class std::allocator<wchar_t>> const &, class std::basic_string<wchar_t, struct std::char_traits<wchar_t>, class std::allocator<wchar_t>> const &)
.text$mn:00001F68                 public ?stringReplace@@YA?AV?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@V12@ABV12@1@Z
.text$mn:00001F68 ?stringReplace@@YA?AV?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@V12@ABV12@1@Z proc near
.text$mn:00001F68
.text$mn:00001F68 var_14          = dword ptr -14h
.text$mn:00001F68 var_10          = dword ptr -10h
.text$mn:00001F68 var_C           = dword ptr -0Ch
.text$mn:00001F68 var_4           = dword ptr -4
.text$mn:00001F68 arg_0           = dword ptr  8
.text$mn:00001F68 arg_4           = byte ptr  0Ch
.text$mn:00001F68 arg_20          = dword ptr  28h
.text$mn:00001F68 arg_24          = dword ptr  2Ch
.text$mn:00001F68
.text$mn:00001F68                 push    ebp
.text$mn:00001F69                 mov     ebp, esp
.text$mn:00001F6B                 push    0FFFFFFFFh
.text$mn:00001F6D                 push    offset __ehhandler$?stringReplace@@YA?AV?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@V12@ABV12@1@Z
.text$mn:00001F72                 mov     eax, large fs:0
.text$mn:00001F78                 push    eax
.text$mn:00001F79                 sub     esp, 8
.text$mn:00001F7C                 mov     eax, dword ptr ds:___security_cookie
.text$mn:00001F81                 xor     eax, ebp
.text$mn:00001F83                 push    eax
.text$mn:00001F84                 lea     eax, [ebp+var_C]
.text$mn:00001F87                 mov     large fs:0, eax
.text$mn:00001F8D                 mov     [ebp+var_14], 0
.text$mn:00001F94                 mov     [ebp+var_4], 1
.text$mn:00001F9B                 mov     [ebp+var_10], 0
.text$mn:00001FA2
.text$mn:00001FA2 loc_1FA2:                               ; CODE XREF: stringReplace(std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>>,std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>> const &,std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>> const &)+7Fj
.text$mn:00001FA2                 mov     eax, [ebp+var_10]
.text$mn:00001FA5                 push    eax
.text$mn:00001FA6                 mov     ecx, [ebp+arg_20]
.text$mn:00001FA9                 push    ecx
.text$mn:00001FAA                 lea     ecx, [ebp+arg_4]
.text$mn:00001FAD                 call    ?find@?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QBEIABV12@I@Z ; std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>>::find(std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>> const &,uint)
.text$mn:00001FB2                 mov     [ebp+var_10], eax
.text$mn:00001FB5                 mov     edx, [ebp+var_10]
.text$mn:00001FB8                 cmp     edx, ds:?npos@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@2IB ; uint const std::basic_string<char,std::char_traits<char>,std::allocator<char>>::npos
.text$mn:00001FBE                 jz      short loc_1FE9
.text$mn:00001FC0                 mov     eax, [ebp+arg_24]
.text$mn:00001FC3                 push    eax
.text$mn:00001FC4                 mov     ecx, [ebp+arg_20]
.text$mn:00001FC7                 call    ?length@?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QBEIXZ ; std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>>::length(void)
.text$mn:00001FCC                 push    eax
.text$mn:00001FCD                 mov     ecx, [ebp+var_10]
.text$mn:00001FD0                 push    ecx
.text$mn:00001FD1                 lea     ecx, [ebp+arg_4]
.text$mn:00001FD4                 call    ?replace@?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QAEAAV12@IIABV12@@Z ; std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>>::replace(uint,uint,std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>> const &)
.text$mn:00001FD9                 mov     ecx, [ebp+arg_24]
.text$mn:00001FDC                 call    ?length@?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QBEIXZ ; std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>>::length(void)
.text$mn:00001FE1                 add     eax, [ebp+var_10]
.text$mn:00001FE4                 mov     [ebp+var_10], eax
.text$mn:00001FE7                 jmp     short loc_1FA2
.text$mn:00001FE9 ; ---------------------------------------------------------------------------
.text$mn:00001FE9
.text$mn:00001FE9 loc_1FE9:                               ; CODE XREF: stringReplace(std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>>,std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>> const &,std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>> const &)+56j
.text$mn:00001FE9                 lea     edx, [ebp+arg_4]
.text$mn:00001FEC                 push    edx
.text$mn:00001FED                 mov     ecx, [ebp+arg_0]
.text$mn:00001FF0                 call    ??0?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QAE@$$QAV01@@Z ; std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>>::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>>(std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>> &&)
.text$mn:00001FF5                 mov     eax, [ebp+var_14]
.text$mn:00001FF8                 or      eax, 1
.text$mn:00001FFB                 mov     [ebp+var_14], eax
.text$mn:00001FFE                 mov     byte ptr [ebp+var_4], 0
.text$mn:00002002                 lea     ecx, [ebp+arg_4]
.text$mn:00002005                 call    ??1?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QAE@XZ ; std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>>::~basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>>(void)
.text$mn:0000200A                 mov     eax, [ebp+arg_0]
.text$mn:0000200D                 mov     ecx, [ebp+var_C]
.text$mn:00002010                 mov     large fs:0, ecx
.text$mn:00002017                 pop     ecx
.text$mn:00002018                 mov     esp, ebp
.text$mn:0000201A                 pop     ebp
.text$mn:0000201B                 retn
.text$mn:0000201B ?stringReplace@@YA?AV?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@V12@ABV12@1@Z endp
.text$mn:0000201B
.text$mn:0000201B ; ---------------------------------------------------------------------------
.text$mn:0000201C                 db 0Ch dup(0CCh)
.text$mn:00002028
.text$mn:00002028 ; =============== S U B R O U T I N E =======================================
.text$mn:00002028
.text$mn:00002028 ; Attributes: bp-based frame
.text$mn:00002028
.text$mn:00002028 ; class std::vector<class std::basic_string<wchar_t, struct std::char_traits<wchar_t>, class std::allocator<wchar_t>>, class std::allocator<class std::basic_string<wchar_t, struct std::char_traits<wchar_t>, class std::allocator<wchar_t>>>> __cdecl stringSplit(class std::basic_string<wchar_t, struct std::char_traits<wchar_t>, class std::allocator<wchar_t>> const &, class std::basic_string<wchar_t, struct std::char_traits<wchar_t>, class std::allocator<wchar_t>> const &)
.text$mn:00002028                 public ?stringSplit@@YA?AV?$vector@V?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@V?$allocator@V?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@@2@@std@@ABV?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@2@0@Z
.text$mn:00002028 ?stringSplit@@YA?AV?$vector@V?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@V?$allocator@V?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@@2@@std@@ABV?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@2@0@Z proc near
.text$mn:00002028
.text$mn:00002028 var_78          = byte ptr -78h
.text$mn:00002028 var_68          = dword ptr -68h
.text$mn:00002028 var_64          = dword ptr -64h
.text$mn:00002028 var_60          = dword ptr -60h
.text$mn:00002028 var_5C          = dword ptr -5Ch
.text$mn:00002028 var_58          = dword ptr -58h
.text$mn:00002028 var_54          = dword ptr -54h
.text$mn:00002028 var_50          = dword ptr -50h
.text$mn:00002028 var_4C          = dword ptr -4Ch
.text$mn:00002028 var_48          = byte ptr -48h
.text$mn:00002028 var_2C          = byte ptr -2Ch
.text$mn:00002028 var_10          = dword ptr -10h
.text$mn:00002028 var_C           = dword ptr -0Ch
.text$mn:00002028 var_4           = dword ptr -4
.text$mn:00002028 arg_0           = dword ptr  8
.text$mn:00002028 arg_4           = dword ptr  0Ch
.text$mn:00002028 arg_8           = dword ptr  10h
.text$mn:00002028
.text$mn:00002028                 push    ebp
.text$mn:00002029                 mov     ebp, esp
.text$mn:0000202B                 push    0FFFFFFFFh
.text$mn:0000202D                 push    offset __ehhandler$?stringSplit@@YA?AV?$vector@V?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@V?$allocator@V?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@@2@@std@@ABV?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@2@0@Z
.text$mn:00002032                 mov     eax, large fs:0
.text$mn:00002038                 push    eax
.text$mn:00002039                 sub     esp, 6Ch
.text$mn:0000203C                 mov     eax, dword ptr ds:___security_cookie
.text$mn:00002041                 xor     eax, ebp
.text$mn:00002043                 mov     [ebp+var_10], eax
.text$mn:00002046                 push    eax
.text$mn:00002047                 lea     eax, [ebp+var_C]
.text$mn:0000204A                 mov     large fs:0, eax
.text$mn:00002050                 mov     [ebp+var_54], 0
.text$mn:00002057                 mov     [ebp+var_4C], 0
.text$mn:0000205E                 push    0
.text$mn:00002060                 mov     eax, [ebp+arg_8]
.text$mn:00002063                 push    eax
.text$mn:00002064                 mov     ecx, [ebp+arg_4]
.text$mn:00002067                 call    ?find@?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QBEIABV12@I@Z ; std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>>::find(std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>> const &,uint)
.text$mn:0000206C                 mov     [ebp+var_50], eax
.text$mn:0000206F                 lea     ecx, [ebp+var_78]
.text$mn:00002072                 call    ??0?$vector@V?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@V?$allocator@V?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@@2@@std@@QAE@XZ ; std::vector<std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>>,std::allocator<std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>>>>::vector<std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>>,std::allocator<std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>>>>(void)
.text$mn:00002077                 mov     [ebp+var_4], 1
.text$mn:0000207E                 mov     ecx, [ebp+arg_8]
.text$mn:00002081                 call    ?length@?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QBEIXZ ; std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>>::length(void)
.text$mn:00002086                 mov     [ebp+var_58], eax
.text$mn:00002089
.text$mn:00002089 loc_2089:                               ; CODE XREF: stringSplit(std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>> const &,std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>> const &)+C4j
.text$mn:00002089                 mov     ecx, [ebp+var_50]
.text$mn:0000208C                 cmp     ecx, ds:?npos@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@2IB ; uint const std::basic_string<char,std::char_traits<char>,std::allocator<char>>::npos
.text$mn:00002092                 jz      short loc_20EE
.text$mn:00002094                 mov     edx, [ebp+var_50]
.text$mn:00002097                 sub     edx, [ebp+var_4C]
.text$mn:0000209A                 push    edx
.text$mn:0000209B                 mov     eax, [ebp+var_4C]
.text$mn:0000209E                 push    eax
.text$mn:0000209F                 lea     ecx, [ebp+var_48]
.text$mn:000020A2                 push    ecx
.text$mn:000020A3                 mov     ecx, [ebp+arg_4]
.text$mn:000020A6                 call    ?substr@?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QBE?AV12@II@Z ; std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>>::substr(uint,uint)
.text$mn:000020AB                 mov     [ebp+var_64], eax
.text$mn:000020AE                 mov     edx, [ebp+var_64]
.text$mn:000020B1                 mov     [ebp+var_68], edx
.text$mn:000020B4                 mov     byte ptr [ebp+var_4], 2
.text$mn:000020B8                 mov     eax, [ebp+var_68]
.text$mn:000020BB                 push    eax
.text$mn:000020BC                 lea     ecx, [ebp+var_78]
.text$mn:000020BF                 call    ?push_back@?$vector@V?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@V?$allocator@V?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@@2@@std@@QAEX$$QAV?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@2@@Z ; std::vector<std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>>,std::allocator<std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>>>>::push_back(std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>> &&)
.text$mn:000020C4                 mov     byte ptr [ebp+var_4], 1
.text$mn:000020C8                 lea     ecx, [ebp+var_48]
.text$mn:000020CB                 call    ??1?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QAE@XZ ; std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>>::~basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>>(void)
.text$mn:000020D0                 mov     ecx, [ebp+var_50]
.text$mn:000020D3                 add     ecx, [ebp+var_58]
.text$mn:000020D6                 mov     [ebp+var_4C], ecx
.text$mn:000020D9                 mov     edx, [ebp+var_4C]
.text$mn:000020DC                 push    edx
.text$mn:000020DD                 mov     eax, [ebp+arg_8]
.text$mn:000020E0                 push    eax
.text$mn:000020E1                 mov     ecx, [ebp+arg_4]
.text$mn:000020E4                 call    ?find@?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QBEIABV12@I@Z ; std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>>::find(std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>> const &,uint)
.text$mn:000020E9                 mov     [ebp+var_50], eax
.text$mn:000020EC                 jmp     short loc_2089
.text$mn:000020EE ; ---------------------------------------------------------------------------
.text$mn:000020EE
.text$mn:000020EE loc_20EE:                               ; CODE XREF: stringSplit(std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>> const &,std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>> const &)+6Aj
.text$mn:000020EE                 mov     ecx, [ebp+var_50]
.text$mn:000020F1                 push    ecx
.text$mn:000020F2                 mov     edx, [ebp+var_4C]
.text$mn:000020F5                 push    edx
.text$mn:000020F6                 lea     eax, [ebp+var_2C]
.text$mn:000020F9                 push    eax
.text$mn:000020FA                 mov     ecx, [ebp+arg_4]
.text$mn:000020FD                 call    ?substr@?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QBE?AV12@II@Z ; std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>>::substr(uint,uint)
.text$mn:00002102                 mov     [ebp+var_60], eax
.text$mn:00002105                 mov     ecx, [ebp+var_60]
.text$mn:00002108                 mov     [ebp+var_5C], ecx
.text$mn:0000210B                 mov     byte ptr [ebp+var_4], 3
.text$mn:0000210F                 mov     edx, [ebp+var_5C]
.text$mn:00002112                 push    edx
.text$mn:00002113                 lea     ecx, [ebp+var_78]
.text$mn:00002116                 call    ?push_back@?$vector@V?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@V?$allocator@V?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@@2@@std@@QAEX$$QAV?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@2@@Z ; std::vector<std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>>,std::allocator<std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>>>>::push_back(std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>> &&)
.text$mn:0000211B                 mov     byte ptr [ebp+var_4], 1
.text$mn:0000211F                 lea     ecx, [ebp+var_2C]
.text$mn:00002122                 call    ??1?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QAE@XZ ; std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>>::~basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>>(void)
.text$mn:00002127                 lea     eax, [ebp+var_78]
.text$mn:0000212A                 push    eax
.text$mn:0000212B                 mov     ecx, [ebp+arg_0]
.text$mn:0000212E                 call    ??0?$vector@V?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@V?$allocator@V?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@@2@@std@@QAE@$$QAV01@@Z ; std::vector<std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>>,std::allocator<std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>>>>::vector<std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>>,std::allocator<std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>>>>(std::vector<std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>>,std::allocator<std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>>>> &&)
.text$mn:00002133                 mov     ecx, [ebp+var_54]
.text$mn:00002136                 or      ecx, 1
.text$mn:00002139                 mov     [ebp+var_54], ecx
.text$mn:0000213C                 mov     byte ptr [ebp+var_4], 0
.text$mn:00002140                 lea     ecx, [ebp+var_78]
.text$mn:00002143                 call    ??1?$vector@V?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@V?$allocator@V?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@@2@@std@@QAE@XZ ; std::vector<std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>>,std::allocator<std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>>>>::~vector<std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>>,std::allocator<std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>>>>(void)
.text$mn:00002148                 mov     eax, [ebp+arg_0]
.text$mn:0000214B                 mov     ecx, [ebp+var_C]
.text$mn:0000214E                 mov     large fs:0, ecx
.text$mn:00002155                 pop     ecx
.text$mn:00002156                 mov     ecx, [ebp+var_10]
.text$mn:00002159                 xor     ecx, ebp
.text$mn:0000215B                 call    @__security_check_cookie@4 ; __security_check_cookie(x)
.text$mn:00002160                 mov     esp, ebp
.text$mn:00002162                 pop     ebp
.text$mn:00002163                 retn
.text$mn:00002163 ?stringSplit@@YA?AV?$vector@V?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@V?$allocator@V?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@@2@@std@@ABV?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@2@0@Z endp
.text$mn:00002163
.text$mn:00002163 ; ---------------------------------------------------------------------------
.text$mn:00002164                 align 8
.text$mn:00002168
.text$mn:00002168 ; =============== S U B R O U T I N E =======================================
.text$mn:00002168
.text$mn:00002168 ; Attributes: bp-based frame
.text$mn:00002168
.text$mn:00002168 ; class std::basic_string<wchar_t, struct std::char_traits<wchar_t>, class std::allocator<wchar_t>> __cdecl stringJoin(class std::vector<class std::basic_string<wchar_t, struct std::char_traits<wchar_t>, class std::allocator<wchar_t>>, class std::allocator<class std::basic_string<wchar_t, struct std::char_traits<wchar_t>, class std::allocator<wchar_t>>>> const &, class std::basic_string<wchar_t, struct std::char_traits<wchar_t>, class std::allocator<wchar_t>> const &)
.text$mn:00002168                 public ?stringJoin@@YA?AV?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@ABV?$vector@V?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@V?$allocator@V?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@@2@@2@ABV12@@Z
.text$mn:00002168 ?stringJoin@@YA?AV?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@ABV?$vector@V?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@V?$allocator@V?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@@2@@2@ABV12@@Z proc near
.text$mn:00002168
.text$mn:00002168 var_38          = dword ptr -38h
.text$mn:00002168 var_34          = dword ptr -34h
.text$mn:00002168 var_30          = dword ptr -30h
.text$mn:00002168 var_2C          = byte ptr -2Ch
.text$mn:00002168 var_10          = dword ptr -10h
.text$mn:00002168 var_C           = dword ptr -0Ch
.text$mn:00002168 var_4           = dword ptr -4
.text$mn:00002168 arg_0           = dword ptr  8
.text$mn:00002168 arg_4           = dword ptr  0Ch
.text$mn:00002168 arg_8           = dword ptr  10h
.text$mn:00002168
.text$mn:00002168                 push    ebp
.text$mn:00002169                 mov     ebp, esp
.text$mn:0000216B                 push    0FFFFFFFFh
.text$mn:0000216D                 push    offset __ehhandler$?stringJoin@@YA?AV?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@ABV?$vector@V?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@V?$allocator@V?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@@2@@2@ABV12@@Z
.text$mn:00002172                 mov     eax, large fs:0
.text$mn:00002178                 push    eax
.text$mn:00002179                 sub     esp, 2Ch
.text$mn:0000217C                 mov     eax, dword ptr ds:___security_cookie
.text$mn:00002181                 xor     eax, ebp
.text$mn:00002183                 mov     [ebp+var_10], eax
.text$mn:00002186                 push    eax
.text$mn:00002187                 lea     eax, [ebp+var_C]
.text$mn:0000218A                 mov     large fs:0, eax
.text$mn:00002190                 mov     [ebp+var_38], 0
.text$mn:00002197                 lea     ecx, [ebp+var_2C]
.text$mn:0000219A                 call    ??0?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QAE@XZ ; std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>>::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>>(void)
.text$mn:0000219F                 mov     [ebp+var_4], 1
.text$mn:000021A6                 mov     ecx, [ebp+arg_4]
.text$mn:000021A9                 call    ?size@?$vector@V?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@V?$allocator@V?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@@2@@std@@QBEIXZ ; std::vector<std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>>,std::allocator<std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>>>>::size(void)
.text$mn:000021AE                 mov     [ebp+var_34], eax
.text$mn:000021B1                 mov     [ebp+var_30], 0
.text$mn:000021B8                 jmp     short loc_21C3
.text$mn:000021BA ; ---------------------------------------------------------------------------
.text$mn:000021BA
.text$mn:000021BA loc_21BA:                               ; CODE XREF: stringJoin(std::vector<std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>>,std::allocator<std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>>>> const &,std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>> const &):loc_21F7j
.text$mn:000021BA                 mov     eax, [ebp+var_30]
.text$mn:000021BD                 add     eax, 1
.text$mn:000021C0                 mov     [ebp+var_30], eax
.text$mn:000021C3
.text$mn:000021C3 loc_21C3:                               ; CODE XREF: stringJoin(std::vector<std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>>,std::allocator<std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>>>> const &,std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>> const &)+50j
.text$mn:000021C3                 mov     ecx, [ebp+var_30]
.text$mn:000021C6                 cmp     ecx, [ebp+var_34]
.text$mn:000021C9                 jnb     short loc_21F9
.text$mn:000021CB                 mov     edx, [ebp+var_30]
.text$mn:000021CE                 push    edx
.text$mn:000021CF                 mov     ecx, [ebp+arg_4]
.text$mn:000021D2                 call    ?at@?$vector@V?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@V?$allocator@V?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@@2@@std@@QBEABV?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@2@I@Z ; std::vector<std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>>,std::allocator<std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>>>>::at(uint)
.text$mn:000021D7                 push    eax
.text$mn:000021D8                 lea     ecx, [ebp+var_2C]
.text$mn:000021DB                 call    ??Y?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QAEAAV01@ABV01@@Z ; std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>>::operator+=(std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>> const &)
.text$mn:000021E0                 mov     eax, [ebp+var_34]
.text$mn:000021E3                 sub     eax, 1
.text$mn:000021E6                 cmp     [ebp+var_30], eax
.text$mn:000021E9                 jz      short loc_21F7
.text$mn:000021EB                 mov     ecx, [ebp+arg_8]
.text$mn:000021EE                 push    ecx
.text$mn:000021EF                 lea     ecx, [ebp+var_2C]
.text$mn:000021F2                 call    ??Y?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QAEAAV01@ABV01@@Z ; std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>>::operator+=(std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>> const &)
.text$mn:000021F7
.text$mn:000021F7 loc_21F7:                               ; CODE XREF: stringJoin(std::vector<std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>>,std::allocator<std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>>>> const &,std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>> const &)+81j
.text$mn:000021F7                 jmp     short loc_21BA
.text$mn:000021F9 ; ---------------------------------------------------------------------------
.text$mn:000021F9
.text$mn:000021F9 loc_21F9:                               ; CODE XREF: stringJoin(std::vector<std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>>,std::allocator<std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>>>> const &,std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>> const &)+61j
.text$mn:000021F9                 lea     edx, [ebp+var_2C]
.text$mn:000021FC                 push    edx
.text$mn:000021FD                 mov     ecx, [ebp+arg_0]
.text$mn:00002200                 call    ??0?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QAE@$$QAV01@@Z ; std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>>::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>>(std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>> &&)
.text$mn:00002205                 mov     eax, [ebp+var_38]
.text$mn:00002208                 or      eax, 1
.text$mn:0000220B                 mov     [ebp+var_38], eax
.text$mn:0000220E                 mov     byte ptr [ebp+var_4], 0
.text$mn:00002212                 lea     ecx, [ebp+var_2C]
.text$mn:00002215                 call    ??1?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QAE@XZ ; std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>>::~basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>>(void)
.text$mn:0000221A                 mov     eax, [ebp+arg_0]
.text$mn:0000221D                 mov     ecx, [ebp+var_C]
.text$mn:00002220                 mov     large fs:0, ecx
.text$mn:00002227                 pop     ecx
.text$mn:00002228                 mov     ecx, [ebp+var_10]
.text$mn:0000222B                 xor     ecx, ebp
.text$mn:0000222D                 call    @__security_check_cookie@4 ; __security_check_cookie(x)
.text$mn:00002232                 mov     esp, ebp
.text$mn:00002234                 pop     ebp
.text$mn:00002235                 retn
.text$mn:00002235 ?stringJoin@@YA?AV?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@ABV?$vector@V?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@V?$allocator@V?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@@2@@2@ABV12@@Z endp
.text$mn:00002235
.text$mn:00002235 ; ---------------------------------------------------------------------------
.text$mn:00002236                 align 4
.text$mn:00002238
.text$mn:00002238 ; =============== S U B R O U T I N E =======================================
.text$mn:00002238
.text$mn:00002238 ; Attributes: bp-based frame
.text$mn:00002238
.text$mn:00002238 ; class std::basic_string<wchar_t, struct std::char_traits<wchar_t>, class std::allocator<wchar_t>> __cdecl stringTakeWhileAdmissable(class std::basic_string<wchar_t, struct std::char_traits<wchar_t>, class std::allocator<wchar_t>> const &, class std::basic_string<wchar_t, struct std::char_traits<wchar_t>, class std::allocator<wchar_t>> const &)
.text$mn:00002238                 public ?stringTakeWhileAdmissable@@YA?AV?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@ABV12@0@Z
.text$mn:00002238 ?stringTakeWhileAdmissable@@YA?AV?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@ABV12@0@Z proc near
.text$mn:00002238
.text$mn:00002238 var_14          = dword ptr -14h
.text$mn:00002238 var_10          = dword ptr -10h
.text$mn:00002238 var_C           = dword ptr -0Ch
.text$mn:00002238 var_4           = dword ptr -4
.text$mn:00002238 arg_0           = dword ptr  8
.text$mn:00002238 arg_4           = dword ptr  0Ch
.text$mn:00002238 arg_8           = dword ptr  10h
.text$mn:00002238
.text$mn:00002238                 push    ebp
.text$mn:00002239                 mov     ebp, esp
.text$mn:0000223B                 push    0FFFFFFFFh
.text$mn:0000223D                 push    offset __ehhandler$?stringTakeWhileAdmissable@@YA?AV?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@ABV12@0@Z
.text$mn:00002242                 mov     eax, large fs:0
.text$mn:00002248                 push    eax
.text$mn:00002249                 sub     esp, 8
.text$mn:0000224C                 mov     eax, dword ptr ds:___security_cookie
.text$mn:00002251                 xor     eax, ebp
.text$mn:00002253                 push    eax
.text$mn:00002254                 lea     eax, [ebp+var_C]
.text$mn:00002257                 mov     large fs:0, eax
.text$mn:0000225D                 mov     [ebp+var_10], 0
.text$mn:00002264                 push    0
.text$mn:00002266                 mov     eax, [ebp+arg_8]
.text$mn:00002269                 push    eax
.text$mn:0000226A                 mov     ecx, [ebp+arg_4]
.text$mn:0000226D                 call    ?find_first_not_of@?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QBEIABV12@I@Z ; std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>>::find_first_not_of(std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>> const &,uint)
.text$mn:00002272                 mov     [ebp+var_14], eax
.text$mn:00002275                 mov     ecx, [ebp+var_14]
.text$mn:00002278                 cmp     ecx, ds:?npos@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@2IB ; uint const std::basic_string<char,std::char_traits<char>,std::allocator<char>>::npos
.text$mn:0000227E                 jnz     short loc_22A3
.text$mn:00002280                 mov     edx, [ebp+arg_4]
.text$mn:00002283                 push    edx
.text$mn:00002284                 mov     ecx, [ebp+arg_0]
.text$mn:00002287                 call    ??0?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QAE@ABV01@@Z ; std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>>::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>>(std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>> const &)
.text$mn:0000228C                 mov     [ebp+var_4], 0
.text$mn:00002293                 mov     eax, [ebp+var_10]
.text$mn:00002296                 or      eax, 1
.text$mn:00002299                 mov     [ebp+var_10], eax
.text$mn:0000229C                 mov     eax, [ebp+arg_0]
.text$mn:0000229F                 jmp     short loc_22C8
.text$mn:000022A1 ; ---------------------------------------------------------------------------
.text$mn:000022A1                 jmp     short loc_22C8
.text$mn:000022A3 ; ---------------------------------------------------------------------------
.text$mn:000022A3
.text$mn:000022A3 loc_22A3:                               ; CODE XREF: stringTakeWhileAdmissable(std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>> const &,std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>> const &)+46j
.text$mn:000022A3                 mov     ecx, [ebp+var_14]
.text$mn:000022A6                 push    ecx
.text$mn:000022A7                 push    0
.text$mn:000022A9                 mov     edx, [ebp+arg_0]
.text$mn:000022AC                 push    edx
.text$mn:000022AD                 mov     ecx, [ebp+arg_4]
.text$mn:000022B0                 call    ?substr@?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QBE?AV12@II@Z ; std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>>::substr(uint,uint)
.text$mn:000022B5                 mov     [ebp+var_4], 0
.text$mn:000022BC                 mov     eax, [ebp+var_10]
.text$mn:000022BF                 or      eax, 1
.text$mn:000022C2                 mov     [ebp+var_10], eax
.text$mn:000022C5                 mov     eax, [ebp+arg_0]
.text$mn:000022C8
.text$mn:000022C8 loc_22C8:                               ; CODE XREF: stringTakeWhileAdmissable(std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>> const &,std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>> const &)+67j
.text$mn:000022C8                                         ; stringTakeWhileAdmissable(std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>> const &,std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>> const &)+69j
.text$mn:000022C8                 mov     ecx, [ebp+var_C]
.text$mn:000022CB                 mov     large fs:0, ecx
.text$mn:000022D2                 pop     ecx
.text$mn:000022D3                 mov     esp, ebp
.text$mn:000022D5                 pop     ebp
.text$mn:000022D6                 retn
.text$mn:000022D6 ?stringTakeWhileAdmissable@@YA?AV?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@ABV12@0@Z endp
.text$mn:000022D6
.text$mn:000022D6 ; ---------------------------------------------------------------------------
.text$mn:000022D7                 align 4
.text$mn:000022D8
.text$mn:000022D8 ; =============== S U B R O U T I N E =======================================
.text$mn:000022D8
.text$mn:000022D8 ; Attributes: bp-based frame
.text$mn:000022D8
.text$mn:000022D8 ; int __cdecl stodLocale(int, _locale_t Locale, int)
.text$mn:000022D8                 public ?stodLocale@@YANABV?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@PAUlocaleinfo_struct@@PAI@Z
.text$mn:000022D8 ?stodLocale@@YANABV?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@PAUlocaleinfo_struct@@PAI@Z proc near
.text$mn:000022D8
.text$mn:000022D8 var_3C          = qword ptr -3Ch
.text$mn:000022D8 var_34          = dword ptr -34h
.text$mn:000022D8 var_30          = dword ptr -30h
.text$mn:000022D8 var_2C          = dword ptr -2Ch
.text$mn:000022D8 var_28          = dword ptr -28h
.text$mn:000022D8 EndPtr          = dword ptr -24h
.text$mn:000022D8 var_20          = dword ptr -20h
.text$mn:000022D8 var_1C          = dword ptr -1Ch
.text$mn:000022D8 var_18          = dword ptr -18h
.text$mn:000022D8 var_14          = dword ptr -14h
.text$mn:000022D8 Str             = dword ptr -10h
.text$mn:000022D8 var_C           = dword ptr -0Ch
.text$mn:000022D8 var_4           = dword ptr -4
.text$mn:000022D8 arg_0           = dword ptr  8
.text$mn:000022D8 Locale          = dword ptr  0Ch
.text$mn:000022D8 arg_8           = dword ptr  10h
.text$mn:000022D8
.text$mn:000022D8                 push    ebp
.text$mn:000022D9                 mov     ebp, esp
.text$mn:000022DB                 push    0FFFFFFFFh
.text$mn:000022DD                 push    offset __ehhandler$?stodLocale@@YANABV?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@PAUlocaleinfo_struct@@PAI@Z
.text$mn:000022E2                 mov     eax, large fs:0
.text$mn:000022E8                 push    eax
.text$mn:000022E9                 sub     esp, 30h
.text$mn:000022EC                 mov     eax, dword ptr ds:___security_cookie
.text$mn:000022F1                 xor     eax, ebp
.text$mn:000022F3                 push    eax
.text$mn:000022F4                 lea     eax, [ebp+var_C]
.text$mn:000022F7                 mov     large fs:0, eax
.text$mn:000022FD                 mov     ecx, [ebp+arg_0]
.text$mn:00002300                 call    ?c_str@?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QBEPB_WXZ ; std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>>::c_str(void)
.text$mn:00002305                 mov     [ebp+Str], eax
.text$mn:00002308                 call    __errno
.text$mn:0000230D                 mov     dword ptr [eax], 0
.text$mn:00002313                 mov     eax, [ebp+Locale]
.text$mn:00002316                 push    eax             ; Locale
.text$mn:00002317                 lea     ecx, [ebp+EndPtr]
.text$mn:0000231A                 push    ecx             ; EndPtr
.text$mn:0000231B                 mov     edx, [ebp+Str]
.text$mn:0000231E                 push    edx             ; Str
.text$mn:0000231F                 call    __wcstod_l
.text$mn:00002324                 add     esp, 0Ch
.text$mn:00002327                 fstp    [ebp+var_3C]
.text$mn:0000232A                 mov     eax, [ebp+Str]
.text$mn:0000232D                 cmp     eax, [ebp+EndPtr]
.text$mn:00002330                 jnz     short loc_2386
.text$mn:00002332                 push    0Ch             ; unsigned int
.text$mn:00002334                 call    ??2@YAPAXI@Z    ; operator new(uint)
.text$mn:00002339                 add     esp, 4
.text$mn:0000233C                 mov     [ebp+var_14], eax
.text$mn:0000233F                 mov     [ebp+var_4], 0
.text$mn:00002346                 cmp     [ebp+var_14], 0
.text$mn:0000234A                 jz      short loc_235E
.text$mn:0000234C                 push    offset $SG119128 ; "invalid stod argument"
.text$mn:00002351                 mov     ecx, [ebp+var_14] ; this
.text$mn:00002354                 call    ??0invalid_argument@std@@QAE@PBD@Z ; std::invalid_argument::invalid_argument(char const *)
.text$mn:00002359                 mov     [ebp+var_18], eax
.text$mn:0000235C                 jmp     short loc_2365
.text$mn:0000235E ; ---------------------------------------------------------------------------
.text$mn:0000235E
.text$mn:0000235E loc_235E:                               ; CODE XREF: stodLocale(std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>> const &,localeinfo_struct *,uint *)+72j
.text$mn:0000235E                 mov     [ebp+var_18], 0
.text$mn:00002365
.text$mn:00002365 loc_2365:                               ; CODE XREF: stodLocale(std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>> const &,localeinfo_struct *,uint *)+84j
.text$mn:00002365                 mov     ecx, [ebp+var_18]
.text$mn:00002368                 mov     [ebp+var_28], ecx
.text$mn:0000236B                 mov     [ebp+var_4], 0FFFFFFFFh
.text$mn:00002372                 mov     edx, [ebp+var_28]
.text$mn:00002375                 mov     [ebp+var_2C], edx
.text$mn:00002378                 push    offset __TI4PAVinvalid_argument@std@@
.text$mn:0000237D                 lea     eax, [ebp+var_2C]
.text$mn:00002380                 push    eax
.text$mn:00002381                 call    __CxxThrowException@8 ; _CxxThrowException(x,x)
.text$mn:00002386 ; ---------------------------------------------------------------------------
.text$mn:00002386
.text$mn:00002386 loc_2386:                               ; CODE XREF: stodLocale(std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>> const &,localeinfo_struct *,uint *)+58j
.text$mn:00002386                 call    __errno
.text$mn:0000238B                 cmp     dword ptr [eax], 22h ; '"'
.text$mn:0000238E                 jnz     short loc_23E4
.text$mn:00002390                 push    0Ch             ; unsigned int
.text$mn:00002392                 call    ??2@YAPAXI@Z    ; operator new(uint)
.text$mn:00002397                 add     esp, 4
.text$mn:0000239A                 mov     [ebp+var_1C], eax
.text$mn:0000239D                 mov     [ebp+var_4], 1
.text$mn:000023A4                 cmp     [ebp+var_1C], 0
.text$mn:000023A8                 jz      short loc_23BC
.text$mn:000023AA                 push    offset $SG119139 ; "stod argument out of range"
.text$mn:000023AF                 mov     ecx, [ebp+var_1C] ; this
.text$mn:000023B2                 call    ??0out_of_range@std@@QAE@PBD@Z ; std::out_of_range::out_of_range(char const *)
.text$mn:000023B7                 mov     [ebp+var_20], eax
.text$mn:000023BA                 jmp     short loc_23C3
.text$mn:000023BC ; ---------------------------------------------------------------------------
.text$mn:000023BC
.text$mn:000023BC loc_23BC:                               ; CODE XREF: stodLocale(std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>> const &,localeinfo_struct *,uint *)+D0j
.text$mn:000023BC                 mov     [ebp+var_20], 0
.text$mn:000023C3
.text$mn:000023C3 loc_23C3:                               ; CODE XREF: stodLocale(std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>> const &,localeinfo_struct *,uint *)+E2j
.text$mn:000023C3                 mov     ecx, [ebp+var_20]
.text$mn:000023C6                 mov     [ebp+var_30], ecx
.text$mn:000023C9                 mov     [ebp+var_4], 0FFFFFFFFh
.text$mn:000023D0                 mov     edx, [ebp+var_30]
.text$mn:000023D3                 mov     [ebp+var_34], edx
.text$mn:000023D6                 push    offset __TI4PAVout_of_range@std@@
.text$mn:000023DB                 lea     eax, [ebp+var_34]
.text$mn:000023DE                 push    eax
.text$mn:000023DF                 call    __CxxThrowException@8 ; _CxxThrowException(x,x)
.text$mn:000023E4 ; ---------------------------------------------------------------------------
.text$mn:000023E4
.text$mn:000023E4 loc_23E4:                               ; CODE XREF: stodLocale(std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>> const &,localeinfo_struct *,uint *)+B6j
.text$mn:000023E4                 cmp     [ebp+arg_8], 0
.text$mn:000023E8                 jz      short loc_23F7
.text$mn:000023EA                 mov     ecx, [ebp+EndPtr]
.text$mn:000023ED                 sub     ecx, [ebp+Str]
.text$mn:000023F0                 sar     ecx, 1
.text$mn:000023F2                 mov     edx, [ebp+arg_8]
.text$mn:000023F5                 mov     [edx], ecx
.text$mn:000023F7
.text$mn:000023F7 loc_23F7:                               ; CODE XREF: stodLocale(std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>> const &,localeinfo_struct *,uint *)+110j
.text$mn:000023F7                 fld     [ebp+var_3C]
.text$mn:000023FA                 mov     ecx, [ebp+var_C]
.text$mn:000023FD                 mov     large fs:0, ecx
.text$mn:00002404                 pop     ecx
.text$mn:00002405                 mov     esp, ebp
.text$mn:00002407                 pop     ebp
.text$mn:00002408                 retn
.text$mn:00002408 ?stodLocale@@YANABV?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@PAUlocaleinfo_struct@@PAI@Z endp
.text$mn:00002408
.text$mn:00002408 ; ---------------------------------------------------------------------------
.text$mn:00002409                 db 0Fh dup(0CCh)
.text$mn:00002418
.text$mn:00002418 ; =============== S U B R O U T I N E =======================================
.text$mn:00002418
.text$mn:00002418 ; Attributes: bp-based frame
.text$mn:00002418
.text$mn:00002418 ; int __cdecl str2Clipboard(int, HWND hWndNewOwner)
.text$mn:00002418                 public ?str2Clipboard@@YA_NABV?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@PAUHWND__@@@Z
.text$mn:00002418 ?str2Clipboard@@YA_NABV?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@PAUHWND__@@@Z proc near
.text$mn:00002418
.text$mn:00002418 uFormat         = dword ptr -10h
.text$mn:00002418 Dst             = dword ptr -0Ch
.text$mn:00002418 dwBytes         = dword ptr -8
.text$mn:00002418 hMem            = dword ptr -4
.text$mn:00002418 arg_0           = dword ptr  8
.text$mn:00002418 hWndNewOwner    = dword ptr  0Ch
.text$mn:00002418
.text$mn:00002418                 push    ebp
.text$mn:00002419                 mov     ebp, esp
.text$mn:0000241B                 sub     esp, 10h
.text$mn:0000241E                 mov     ecx, [ebp+arg_0]
.text$mn:00002421                 call    ?size@?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QBEIXZ ; std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>>::size(void)
.text$mn:00002426                 lea     eax, [eax+eax+2]
.text$mn:0000242A                 mov     [ebp+dwBytes], eax
.text$mn:0000242D                 mov     ecx, [ebp+dwBytes]
.text$mn:00002430                 push    ecx             ; dwBytes
.text$mn:00002431                 push    2               ; uFlags
.text$mn:00002433                 call    dword ptr ds:__imp__GlobalAlloc@8 ; GlobalAlloc(x,x)
.text$mn:00002439                 mov     [ebp+hMem], eax
.text$mn:0000243C                 cmp     [ebp+hMem], 0
.text$mn:00002440                 jnz     short loc_2449
.text$mn:00002442                 xor     al, al
.text$mn:00002444                 jmp     loc_252C
.text$mn:00002449 ; ---------------------------------------------------------------------------
.text$mn:00002449
.text$mn:00002449 loc_2449:                               ; CODE XREF: str2Clipboard(std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>> const &,HWND__ *)+28j
.text$mn:00002449                 mov     edx, [ebp+hWndNewOwner]
.text$mn:0000244C                 push    edx             ; hWndNewOwner
.text$mn:0000244D                 call    dword ptr ds:__imp__OpenClipboard@4 ; OpenClipboard(x)
.text$mn:00002453                 test    eax, eax
.text$mn:00002455                 jnz     short loc_246E
.text$mn:00002457                 mov     eax, [ebp+hMem]
.text$mn:0000245A                 push    eax             ; hMem
.text$mn:0000245B                 call    dword ptr ds:__imp__GlobalFree@4 ; GlobalFree(x)
.text$mn:00002461                 call    dword ptr ds:__imp__CloseClipboard@0 ; CloseClipboard()
.text$mn:00002467                 xor     al, al
.text$mn:00002469                 jmp     loc_252C
.text$mn:0000246E ; ---------------------------------------------------------------------------
.text$mn:0000246E
.text$mn:0000246E loc_246E:                               ; CODE XREF: str2Clipboard(std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>> const &,HWND__ *)+3Dj
.text$mn:0000246E                 call    dword ptr ds:__imp__EmptyClipboard@0 ; EmptyClipboard()
.text$mn:00002474                 test    eax, eax
.text$mn:00002476                 jnz     short loc_248F
.text$mn:00002478                 mov     ecx, [ebp+hMem]
.text$mn:0000247B                 push    ecx             ; hMem
.text$mn:0000247C                 call    dword ptr ds:__imp__GlobalFree@4 ; GlobalFree(x)
.text$mn:00002482                 call    dword ptr ds:__imp__CloseClipboard@0 ; CloseClipboard()
.text$mn:00002488                 xor     al, al
.text$mn:0000248A                 jmp     loc_252C
.text$mn:0000248F ; ---------------------------------------------------------------------------
.text$mn:0000248F
.text$mn:0000248F loc_248F:                               ; CODE XREF: str2Clipboard(std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>> const &,HWND__ *)+5Ej
.text$mn:0000248F                 mov     edx, [ebp+hMem]
.text$mn:00002492                 push    edx             ; hMem
.text$mn:00002493                 call    dword ptr ds:__imp__GlobalLock@4 ; GlobalLock(x)
.text$mn:00002499                 mov     [ebp+Dst], eax
.text$mn:0000249C                 cmp     [ebp+Dst], 0
.text$mn:000024A0                 jnz     short loc_24C0
.text$mn:000024A2                 mov     eax, [ebp+hMem]
.text$mn:000024A5                 push    eax             ; hMem
.text$mn:000024A6                 call    dword ptr ds:__imp__GlobalUnlock@4 ; GlobalUnlock(x)
.text$mn:000024AC                 mov     ecx, [ebp+hMem]
.text$mn:000024AF                 push    ecx             ; hMem
.text$mn:000024B0                 call    dword ptr ds:__imp__GlobalFree@4 ; GlobalFree(x)
.text$mn:000024B6                 call    dword ptr ds:__imp__CloseClipboard@0 ; CloseClipboard()
.text$mn:000024BC                 xor     al, al
.text$mn:000024BE                 jmp     short loc_252C
.text$mn:000024C0 ; ---------------------------------------------------------------------------
.text$mn:000024C0
.text$mn:000024C0 loc_24C0:                               ; CODE XREF: str2Clipboard(std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>> const &,HWND__ *)+88j
.text$mn:000024C0                 mov     ecx, [ebp+arg_0]
.text$mn:000024C3                 call    ?c_str@?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QBEPB_WXZ ; std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>>::c_str(void)
.text$mn:000024C8                 push    eax             ; Src
.text$mn:000024C9                 mov     edx, [ebp+dwBytes]
.text$mn:000024CC                 shr     edx, 1
.text$mn:000024CE                 push    edx             ; SizeInWords
.text$mn:000024CF                 mov     eax, [ebp+Dst]
.text$mn:000024D2                 push    eax             ; Dst
.text$mn:000024D3                 call    _wcscpy_s
.text$mn:000024D8                 add     esp, 0Ch
.text$mn:000024DB                 mov     ecx, [ebp+hMem]
.text$mn:000024DE                 push    ecx             ; hMem
.text$mn:000024DF                 call    dword ptr ds:__imp__GlobalUnlock@4 ; GlobalUnlock(x)
.text$mn:000024E5                 mov     [ebp+uFormat], 0Dh
.text$mn:000024EC                 mov     edx, [ebp+hMem]
.text$mn:000024EF                 push    edx             ; hMem
.text$mn:000024F0                 mov     eax, [ebp+uFormat]
.text$mn:000024F3                 push    eax             ; uFormat
.text$mn:000024F4                 call    dword ptr ds:__imp__SetClipboardData@8 ; SetClipboardData(x,x)
.text$mn:000024FA                 test    eax, eax
.text$mn:000024FC                 jnz     short loc_251C
.text$mn:000024FE                 mov     ecx, [ebp+hMem]
.text$mn:00002501                 push    ecx             ; hMem
.text$mn:00002502                 call    dword ptr ds:__imp__GlobalUnlock@4 ; GlobalUnlock(x)
.text$mn:00002508                 mov     edx, [ebp+hMem]
.text$mn:0000250B                 push    edx             ; hMem
.text$mn:0000250C                 call    dword ptr ds:__imp__GlobalFree@4 ; GlobalFree(x)
.text$mn:00002512                 call    dword ptr ds:__imp__CloseClipboard@0 ; CloseClipboard()
.text$mn:00002518                 xor     al, al
.text$mn:0000251A                 jmp     short loc_252C
.text$mn:0000251C ; ---------------------------------------------------------------------------
.text$mn:0000251C
.text$mn:0000251C loc_251C:                               ; CODE XREF: str2Clipboard(std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>> const &,HWND__ *)+E4j
.text$mn:0000251C                 call    dword ptr ds:__imp__CloseClipboard@0 ; CloseClipboard()
.text$mn:00002522                 test    eax, eax
.text$mn:00002524                 jnz     short loc_252A
.text$mn:00002526                 xor     al, al
.text$mn:00002528                 jmp     short loc_252C
.text$mn:0000252A ; ---------------------------------------------------------------------------
.text$mn:0000252A
.text$mn:0000252A loc_252A:                               ; CODE XREF: str2Clipboard(std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>> const &,HWND__ *)+10Cj
.text$mn:0000252A                 mov     al, 1
.text$mn:0000252C
.text$mn:0000252C loc_252C:                               ; CODE XREF: str2Clipboard(std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>> const &,HWND__ *)+2Cj
.text$mn:0000252C                                         ; str2Clipboard(std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>> const &,HWND__ *)+51j ...
.text$mn:0000252C                 mov     esp, ebp
.text$mn:0000252E                 pop     ebp
.text$mn:0000252F                 retn
.text$mn:0000252F ?str2Clipboard@@YA_NABV?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@PAUHWND__@@@Z endp
.text$mn:0000252F
.text$mn:0000252F ; ---------------------------------------------------------------------------
.text$mn:00002530                 db 8 dup(0CCh)
.text$mn:00002538
.text$mn:00002538 ; =============== S U B R O U T I N E =======================================
.text$mn:00002538
.text$mn:00002538 ; Attributes: bp-based frame
.text$mn:00002538
.text$mn:00002538 ; bool __cdecl Utf8::isSingleByte(unsigned char)
.text$mn:00002538 ?isSingleByte@Utf8@@YA_NE@Z proc near   ; CODE XREF: Utf8::isValid(char const *,int)+16p
.text$mn:00002538
.text$mn:00002538 var_4           = dword ptr -4
.text$mn:00002538 arg_0           = byte ptr  8
.text$mn:00002538
.text$mn:00002538                 push    ebp
.text$mn:00002539                 mov     ebp, esp
.text$mn:0000253B                 push    ecx
.text$mn:0000253C                 movzx   eax, [ebp+arg_0]
.text$mn:00002540                 cmp     eax, 80h ; 'Ç'
.text$mn:00002545                 jge     short loc_2550
.text$mn:00002547                 mov     [ebp+var_4], 1
.text$mn:0000254E                 jmp     short loc_2557
.text$mn:00002550 ; ---------------------------------------------------------------------------
.text$mn:00002550
.text$mn:00002550 loc_2550:                               ; CODE XREF: Utf8::isSingleByte(uchar)+Dj
.text$mn:00002550                 mov     [ebp+var_4], 0
.text$mn:00002557
.text$mn:00002557 loc_2557:                               ; CODE XREF: Utf8::isSingleByte(uchar)+16j
.text$mn:00002557                 mov     al, byte ptr [ebp+var_4]
.text$mn:0000255A                 mov     esp, ebp
.text$mn:0000255C                 pop     ebp
.text$mn:0000255D                 retn
.text$mn:0000255D ?isSingleByte@Utf8@@YA_NE@Z endp
.text$mn:0000255D
.text$mn:0000255D ; ---------------------------------------------------------------------------
.text$mn:0000255E                 db 0Ah dup(0CCh)
.text$mn:00002568
.text$mn:00002568 ; =============== S U B R O U T I N E =======================================
.text$mn:00002568
.text$mn:00002568 ; Attributes: bp-based frame
.text$mn:00002568
.text$mn:00002568 ; bool __cdecl Utf8::isFirstOfMultibyte(unsigned char)
.text$mn:00002568 ?isFirstOfMultibyte@Utf8@@YA_NE@Z proc near
.text$mn:00002568                                         ; CODE XREF: Utf8::isValid(char const *,int)+3Cp
.text$mn:00002568
.text$mn:00002568 var_4           = dword ptr -4
.text$mn:00002568 arg_0           = byte ptr  8
.text$mn:00002568
.text$mn:00002568                 push    ebp
.text$mn:00002569                 mov     ebp, esp
.text$mn:0000256B                 push    ecx
.text$mn:0000256C                 movzx   eax, [ebp+arg_0]
.text$mn:00002570                 cmp     eax, 0C2h ; '-'
.text$mn:00002575                 jl      short loc_258C
.text$mn:00002577                 movzx   ecx, [ebp+arg_0]
.text$mn:0000257B                 cmp     ecx, 0F5h ; ')'
.text$mn:00002581                 jge     short loc_258C
.text$mn:00002583                 mov     [ebp+var_4], 1
.text$mn:0000258A                 jmp     short loc_2593
.text$mn:0000258C ; ---------------------------------------------------------------------------
.text$mn:0000258C
.text$mn:0000258C loc_258C:                               ; CODE XREF: Utf8::isFirstOfMultibyte(uchar)+Dj
.text$mn:0000258C                                         ; Utf8::isFirstOfMultibyte(uchar)+19j
.text$mn:0000258C                 mov     [ebp+var_4], 0
.text$mn:00002593
.text$mn:00002593 loc_2593:                               ; CODE XREF: Utf8::isFirstOfMultibyte(uchar)+22j
.text$mn:00002593                 mov     al, byte ptr [ebp+var_4]
.text$mn:00002596                 mov     esp, ebp
.text$mn:00002598                 pop     ebp
.text$mn:00002599                 retn
.text$mn:00002599 ?isFirstOfMultibyte@Utf8@@YA_NE@Z endp
.text$mn:00002599
.text$mn:00002599 ; ---------------------------------------------------------------------------
.text$mn:0000259A                 db 0Eh dup(0CCh)
.text$mn:000025A8
.text$mn:000025A8 ; =============== S U B R O U T I N E =======================================
.text$mn:000025A8
.text$mn:000025A8 ; Attributes: bp-based frame
.text$mn:000025A8
.text$mn:000025A8 ; bool __cdecl Utf8::isContinuation(unsigned char)
.text$mn:000025A8 ?isContinuation@Utf8@@YA_NE@Z proc near ; CODE XREF: Utf8::isValid(char const *,int)+A0p
.text$mn:000025A8                                         ; Utf8::characterStart(char const *,int)+27p
.text$mn:000025A8
.text$mn:000025A8 var_4           = dword ptr -4
.text$mn:000025A8 arg_0           = byte ptr  8
.text$mn:000025A8
.text$mn:000025A8                 push    ebp
.text$mn:000025A9                 mov     ebp, esp
.text$mn:000025AB                 push    ecx
.text$mn:000025AC                 movzx   eax, [ebp+arg_0]
.text$mn:000025B0                 and     eax, 0C0h
.text$mn:000025B5                 cmp     eax, 80h ; 'Ç'
.text$mn:000025BA                 jnz     short loc_25C5
.text$mn:000025BC                 mov     [ebp+var_4], 1
.text$mn:000025C3                 jmp     short loc_25CC
.text$mn:000025C5 ; ---------------------------------------------------------------------------
.text$mn:000025C5
.text$mn:000025C5 loc_25C5:                               ; CODE XREF: Utf8::isContinuation(uchar)+12j
.text$mn:000025C5                 mov     [ebp+var_4], 0
.text$mn:000025CC
.text$mn:000025CC loc_25CC:                               ; CODE XREF: Utf8::isContinuation(uchar)+1Bj
.text$mn:000025CC                 mov     al, byte ptr [ebp+var_4]
.text$mn:000025CF                 mov     esp, ebp
.text$mn:000025D1                 pop     ebp
.text$mn:000025D2                 retn
.text$mn:000025D2 ?isContinuation@Utf8@@YA_NE@Z endp
.text$mn:000025D2
.text$mn:000025D2 ; ---------------------------------------------------------------------------
.text$mn:000025D3                 align 8
.text$mn:000025D8
.text$mn:000025D8 ; =============== S U B R O U T I N E =======================================
.text$mn:000025D8
.text$mn:000025D8 ; Attributes: bp-based frame
.text$mn:000025D8
.text$mn:000025D8 ; int __cdecl Utf8::continuationBytes(unsigned char)
.text$mn:000025D8 ?continuationBytes@Utf8@@YAHE@Z proc near
.text$mn:000025D8                                         ; CODE XREF: Utf8::isValid(char const *,int)+5Fp
.text$mn:000025D8
.text$mn:000025D8 var_4           = dword ptr -4
.text$mn:000025D8 arg_0           = byte ptr  8
.text$mn:000025D8
.text$mn:000025D8                 push    ebp
.text$mn:000025D9                 mov     ebp, esp
.text$mn:000025DB                 push    ecx
.text$mn:000025DC                 movzx   eax, [ebp+arg_0]
.text$mn:000025E0                 cmp     eax, 0C0h ; '+'
.text$mn:000025E5                 jge     short loc_25F0
.text$mn:000025E7                 mov     [ebp+var_4], 0
.text$mn:000025EE                 jmp     short loc_2604
.text$mn:000025F0 ; ---------------------------------------------------------------------------
.text$mn:000025F0
.text$mn:000025F0 loc_25F0:                               ; CODE XREF: Utf8::continuationBytes(uchar)+Dj
.text$mn:000025F0                 movzx   ecx, [ebp+arg_0]
.text$mn:000025F4                 and     ecx, 30h
.text$mn:000025F7                 sar     ecx, 4
.text$mn:000025FA                 movsx   edx, ds:?_len@?1??continuationBytes@Utf8@@YAHE@Z@4QBDB[ecx] ; char const * const `Utf8::continuationBytes(uchar)'::`2'::_len
.text$mn:00002601                 mov     [ebp+var_4], edx
.text$mn:00002604
.text$mn:00002604 loc_2604:                               ; CODE XREF: Utf8::continuationBytes(uchar)+16j
.text$mn:00002604                 mov     eax, [ebp+var_4]
.text$mn:00002607                 mov     esp, ebp
.text$mn:00002609                 pop     ebp
.text$mn:0000260A                 retn
.text$mn:0000260A ?continuationBytes@Utf8@@YAHE@Z endp
.text$mn:0000260A
.text$mn:0000260A ; ---------------------------------------------------------------------------
.text$mn:0000260B                 db 0Dh dup(0CCh)
.text$mn:00002618
.text$mn:00002618 ; =============== S U B R O U T I N E =======================================
.text$mn:00002618
.text$mn:00002618 ; Attributes: bp-based frame
.text$mn:00002618
.text$mn:00002618 ; bool __cdecl Utf8::isValid(char const *, int)
.text$mn:00002618 ?isValid@Utf8@@YA_NPBDH@Z proc near     ; CODE XREF: WcharMbcsConvertor::char2wchar(char const *,uint,int,int *,int *)+BDp
.text$mn:00002618
.text$mn:00002618 var_8           = dword ptr -8
.text$mn:00002618 var_4           = dword ptr -4
.text$mn:00002618 arg_0           = dword ptr  8
.text$mn:00002618 arg_4           = dword ptr  0Ch
.text$mn:00002618
.text$mn:00002618                 push    ebp
.text$mn:00002619                 mov     ebp, esp
.text$mn:0000261B                 sub     esp, 8
.text$mn:0000261E                 mov     eax, 1
.text$mn:00002623                 imul    ecx, eax, 0
.text$mn:00002626                 mov     edx, [ebp+arg_0]
.text$mn:00002629                 movzx   eax, byte ptr [edx+ecx]
.text$mn:0000262D                 push    eax
.text$mn:0000262E                 call    ?isSingleByte@Utf8@@YA_NE@Z ; Utf8::isSingleByte(uchar)
.text$mn:00002633                 add     esp, 4
.text$mn:00002636                 movzx   ecx, al
.text$mn:00002639                 test    ecx, ecx
.text$mn:0000263B                 jz      short loc_2644
.text$mn:0000263D                 mov     al, 1
.text$mn:0000263F                 jmp     loc_26CF
.text$mn:00002644 ; ---------------------------------------------------------------------------
.text$mn:00002644
.text$mn:00002644 loc_2644:                               ; CODE XREF: Utf8::isValid(char const *,int)+23j
.text$mn:00002644                 mov     edx, 1
.text$mn:00002649                 imul    eax, edx, 0
.text$mn:0000264C                 mov     ecx, [ebp+arg_0]
.text$mn:0000264F                 movzx   edx, byte ptr [ecx+eax]
.text$mn:00002653                 push    edx
.text$mn:00002654                 call    ?isFirstOfMultibyte@Utf8@@YA_NE@Z ; Utf8::isFirstOfMultibyte(uchar)
.text$mn:00002659                 add     esp, 4
.text$mn:0000265C                 movzx   eax, al
.text$mn:0000265F                 test    eax, eax
.text$mn:00002661                 jnz     short loc_2667
.text$mn:00002663                 xor     al, al
.text$mn:00002665                 jmp     short loc_26CF
.text$mn:00002667 ; ---------------------------------------------------------------------------
.text$mn:00002667
.text$mn:00002667 loc_2667:                               ; CODE XREF: Utf8::isValid(char const *,int)+49j
.text$mn:00002667                 mov     ecx, 1
.text$mn:0000266C                 imul    edx, ecx, 0
.text$mn:0000266F                 mov     eax, [ebp+arg_0]
.text$mn:00002672                 movzx   ecx, byte ptr [eax+edx]
.text$mn:00002676                 push    ecx
.text$mn:00002677                 call    ?continuationBytes@Utf8@@YAHE@Z ; Utf8::continuationBytes(uchar)
.text$mn:0000267C                 add     esp, 4
.text$mn:0000267F                 mov     [ebp+var_8], eax
.text$mn:00002682                 mov     edx, [ebp+var_8]
.text$mn:00002685                 add     edx, 1
.text$mn:00002688                 cmp     [ebp+arg_4], edx
.text$mn:0000268B                 jge     short loc_2691
.text$mn:0000268D                 xor     al, al
.text$mn:0000268F                 jmp     short loc_26CF
.text$mn:00002691 ; ---------------------------------------------------------------------------
.text$mn:00002691
.text$mn:00002691 loc_2691:                               ; CODE XREF: Utf8::isValid(char const *,int)+73j
.text$mn:00002691                 mov     eax, [ebp+var_8]
.text$mn:00002694                 mov     [ebp+var_4], eax
.text$mn:00002697                 jmp     short loc_26A2
.text$mn:00002699 ; ---------------------------------------------------------------------------
.text$mn:00002699
.text$mn:00002699 loc_2699:                               ; CODE XREF: Utf8::isValid(char const *,int):loc_26CBj
.text$mn:00002699                 mov     ecx, [ebp+var_4]
.text$mn:0000269C                 sub     ecx, 1
.text$mn:0000269F                 mov     [ebp+var_4], ecx
.text$mn:000026A2
.text$mn:000026A2 loc_26A2:                               ; CODE XREF: Utf8::isValid(char const *,int)+7Fj
.text$mn:000026A2                 cmp     [ebp+var_4], 0
.text$mn:000026A6                 jle     short loc_26CD
.text$mn:000026A8                 mov     edx, [ebp+arg_0]
.text$mn:000026AB                 add     edx, 1
.text$mn:000026AE                 mov     [ebp+arg_0], edx
.text$mn:000026B1                 mov     eax, [ebp+arg_0]
.text$mn:000026B4                 movzx   ecx, byte ptr [eax]
.text$mn:000026B7                 push    ecx
.text$mn:000026B8                 call    ?isContinuation@Utf8@@YA_NE@Z ; Utf8::isContinuation(uchar)
.text$mn:000026BD                 add     esp, 4
.text$mn:000026C0                 movzx   edx, al
.text$mn:000026C3                 test    edx, edx
.text$mn:000026C5                 jnz     short loc_26CB
.text$mn:000026C7                 xor     al, al
.text$mn:000026C9                 jmp     short loc_26CF
.text$mn:000026CB ; ---------------------------------------------------------------------------
.text$mn:000026CB
.text$mn:000026CB loc_26CB:                               ; CODE XREF: Utf8::isValid(char const *,int)+ADj
.text$mn:000026CB                 jmp     short loc_2699
.text$mn:000026CD ; ---------------------------------------------------------------------------
.text$mn:000026CD
.text$mn:000026CD loc_26CD:                               ; CODE XREF: Utf8::isValid(char const *,int)+8Ej
.text$mn:000026CD                 mov     al, 1
.text$mn:000026CF
.text$mn:000026CF loc_26CF:                               ; CODE XREF: Utf8::isValid(char const *,int)+27j
.text$mn:000026CF                                         ; Utf8::isValid(char const *,int)+4Dj ...
.text$mn:000026CF                 mov     esp, ebp
.text$mn:000026D1                 pop     ebp
.text$mn:000026D2                 retn
.text$mn:000026D2 ?isValid@Utf8@@YA_NPBDH@Z endp
.text$mn:000026D2
.text$mn:000026D2 ; ---------------------------------------------------------------------------
.text$mn:000026D3                 align 8
.text$mn:000026D8
.text$mn:000026D8 ; =============== S U B R O U T I N E =======================================
.text$mn:000026D8
.text$mn:000026D8 ; Attributes: bp-based frame
.text$mn:000026D8
.text$mn:000026D8 ; int __cdecl Utf8::characterStart(char const *, int)
.text$mn:000026D8 ?characterStart@Utf8@@YAHPBDH@Z proc near
.text$mn:000026D8                                         ; CODE XREF: WcharMbcsConvertor::char2wchar(char const *,uint,int,int *,int *)+9Ep
.text$mn:000026D8
.text$mn:000026D8 var_4           = dword ptr -4
.text$mn:000026D8 arg_0           = dword ptr  8
.text$mn:000026D8 arg_4           = dword ptr  0Ch
.text$mn:000026D8
.text$mn:000026D8                 push    ebp
.text$mn:000026D9                 mov     ebp, esp
.text$mn:000026DB                 push    ecx
.text$mn:000026DC                 mov     [ebp+var_4], 0
.text$mn:000026E3
.text$mn:000026E3 loc_26E3:                               ; CODE XREF: Utf8::characterStart(char const *,int)+3Fj
.text$mn:000026E3                 mov     eax, [ebp+var_4]
.text$mn:000026E6                 cmp     eax, [ebp+arg_4]
.text$mn:000026E9                 jge     short loc_2719
.text$mn:000026EB                 cmp     [ebp+var_4], 5
.text$mn:000026EF                 jge     short loc_2719
.text$mn:000026F1                 mov     ecx, [ebp+arg_4]
.text$mn:000026F4                 sub     ecx, [ebp+var_4]
.text$mn:000026F7                 mov     edx, [ebp+arg_0]
.text$mn:000026FA                 movzx   eax, byte ptr [edx+ecx]
.text$mn:000026FE                 push    eax
.text$mn:000026FF                 call    ?isContinuation@Utf8@@YA_NE@Z ; Utf8::isContinuation(uchar)
.text$mn:00002704                 add     esp, 4
.text$mn:00002707                 movzx   ecx, al
.text$mn:0000270A                 test    ecx, ecx
.text$mn:0000270C                 jz      short loc_2719
.text$mn:0000270E                 mov     edx, [ebp+var_4]
.text$mn:00002711                 add     edx, 1
.text$mn:00002714                 mov     [ebp+var_4], edx
.text$mn:00002717                 jmp     short loc_26E3
.text$mn:00002719 ; ---------------------------------------------------------------------------
.text$mn:00002719
.text$mn:00002719 loc_2719:                               ; CODE XREF: Utf8::characterStart(char const *,int)+11j
.text$mn:00002719                                         ; Utf8::characterStart(char const *,int)+17j ...
.text$mn:00002719                 mov     eax, [ebp+arg_4]
.text$mn:0000271C                 sub     eax, [ebp+var_4]
.text$mn:0000271F                 mov     esp, ebp
.text$mn:00002721                 pop     ebp
.text$mn:00002722                 retn
.text$mn:00002722 ?characterStart@Utf8@@YAHPBDH@Z endp
.text$mn:00002722
.text$mn:00002722 ; ---------------------------------------------------------------------------
.text$mn:00002723                 align 8
.text$mn:00002728
.text$mn:00002728 ; =============== S U B R O U T I N E =======================================
.text$mn:00002728
.text$mn:00002728 ; Attributes: bp-based frame
.text$mn:00002728
.text$mn:00002728 ; char __cdecl getDriveLetter()
.text$mn:00002728                 public ?getDriveLetter@@YADXZ
.text$mn:00002728 ?getDriveLetter@@YADXZ proc near        ; CODE XREF: relativeFilePathToFullFilePath(wchar_t const *):loc_1405p
.text$mn:00002728
.text$mn:00002728 var_214         = dword ptr -214h
.text$mn:00002728 var_20D         = byte ptr -20Dh
.text$mn:00002728 Buffer          = word ptr -20Ch
.text$mn:00002728 var_4           = dword ptr -4
.text$mn:00002728
.text$mn:00002728                 push    ebp
.text$mn:00002729                 mov     ebp, esp
.text$mn:0000272B                 sub     esp, 214h
.text$mn:00002731                 mov     eax, dword ptr ds:___security_cookie
.text$mn:00002736                 xor     eax, ebp
.text$mn:00002738                 mov     [ebp+var_4], eax
.text$mn:0000273B                 mov     [ebp+var_20D], 0
.text$mn:00002742                 lea     eax, [ebp+Buffer]
.text$mn:00002748                 push    eax             ; lpBuffer
.text$mn:00002749                 push    104h            ; nBufferLength
.text$mn:0000274E                 call    dword ptr ds:__imp__GetCurrentDirectoryW@8 ; GetCurrentDirectoryW(x,x)
.text$mn:00002754                 lea     ecx, [ebp+Buffer]
.text$mn:0000275A                 push    ecx             ; pszPath
.text$mn:0000275B                 call    dword ptr ds:__imp__PathGetDriveNumberW@4 ; PathGetDriveNumberW(x)
.text$mn:00002761                 mov     [ebp+var_214], eax
.text$mn:00002767                 cmp     [ebp+var_214], 0FFFFFFFFh
.text$mn:0000276E                 jz      short loc_2780
.text$mn:00002770                 movsx   edx, byte ptr [ebp+var_214]
.text$mn:00002777                 add     edx, 41h ; 'A'
.text$mn:0000277A                 mov     [ebp+var_20D], dl
.text$mn:00002780
.text$mn:00002780 loc_2780:                               ; CODE XREF: getDriveLetter(void)+46j
.text$mn:00002780                 mov     al, [ebp+var_20D]
.text$mn:00002786                 mov     ecx, [ebp+var_4]
.text$mn:00002789                 xor     ecx, ebp
.text$mn:0000278B                 call    @__security_check_cookie@4 ; __security_check_cookie(x)
.text$mn:00002790                 mov     esp, ebp
.text$mn:00002792                 pop     ebp
.text$mn:00002793                 retn
.text$mn:00002793 ?getDriveLetter@@YADXZ endp
.text$mn:00002793
.text$mn:00002793 ; ---------------------------------------------------------------------------
.text$mn:00002794                 align 8
.text$mn:00002798
.text$mn:00002798 ; =============== S U B R O U T I N E =======================================
.text$mn:00002798
.text$mn:00002798 ; Attributes: bp-based frame
.text$mn:00002798
.text$mn:00002798 ; int __stdcall BrowseCallbackProc(HWND hWnd, int, int, LPARAM lParam)
.text$mn:00002798 ?BrowseCallbackProc@@YGHPAUHWND__@@IJJ@Z proc near
.text$mn:00002798                                         ; DATA XREF: folderBrowser(HWND__ *,int,wchar_t const *)+78o
.text$mn:00002798                                         ; getFolderName(HWND__ *,wchar_t const *)+B1o
.text$mn:00002798
.text$mn:00002798 hWnd            = dword ptr  8
.text$mn:00002798 arg_4           = dword ptr  0Ch
.text$mn:00002798 lParam          = dword ptr  14h
.text$mn:00002798
.text$mn:00002798                 push    ebp
.text$mn:00002799                 mov     ebp, esp
.text$mn:0000279B                 cmp     [ebp+arg_4], 1
.text$mn:0000279F                 jnz     short loc_27BC
.text$mn:000027A1                 cmp     [ebp+lParam], 0
.text$mn:000027A5                 jz      short loc_27BC
.text$mn:000027A7                 mov     eax, [ebp+lParam]
.text$mn:000027AA                 push    eax             ; lParam
.text$mn:000027AB                 push    1               ; wParam
.text$mn:000027AD                 push    467h            ; Msg
.text$mn:000027B2                 mov     ecx, [ebp+hWnd]
.text$mn:000027B5                 push    ecx             ; hWnd
.text$mn:000027B6                 call    dword ptr ds:__imp__SendMessageW@16 ; SendMessageW(x,x,x,x)
.text$mn:000027BC
.text$mn:000027BC loc_27BC:                               ; CODE XREF: BrowseCallbackProc(HWND__ *,uint,long,long)+7j
.text$mn:000027BC                                         ; BrowseCallbackProc(HWND__ *,uint,long,long)+Dj
.text$mn:000027BC                 xor     eax, eax
.text$mn:000027BE                 pop     ebp
.text$mn:000027BF                 retn    10h
.text$mn:000027BF ?BrowseCallbackProc@@YGHPAUHWND__@@IJJ@Z endp
.text$mn:000027BF
.text$mn:000027BF ; ---------------------------------------------------------------------------
.text$mn:000027C2                 align 8
.text$mn:000027C8
.text$mn:000027C8 ; =============== S U B R O U T I N E =======================================
.text$mn:000027C8
.text$mn:000027C8 ; Attributes: bp-based frame
.text$mn:000027C8
.text$mn:000027C8 ; class std::basic_string<wchar_t, struct std::char_traits<wchar_t>, class std::allocator<wchar_t>> __cdecl intToString(int)
.text$mn:000027C8                 public ?intToString@@YA?AV?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@H@Z
.text$mn:000027C8 ?intToString@@YA?AV?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@H@Z proc near
.text$mn:000027C8
.text$mn:000027C8 var_6C          = dword ptr -6Ch
.text$mn:000027C8 var_68          = dword ptr -68h
.text$mn:000027C8 var_64          = dword ptr -64h
.text$mn:000027C8 var_60          = dword ptr -60h
.text$mn:000027C8 var_5C          = byte ptr -5Ch
.text$mn:000027C8 var_4C          = dword ptr -4Ch
.text$mn:000027C8 var_48          = dword ptr -48h
.text$mn:000027C8 var_44          = dword ptr -44h
.text$mn:000027C8 var_40          = dword ptr -40h
.text$mn:000027C8 var_3C          = dword ptr -3Ch
.text$mn:000027C8 var_38          = dword ptr -38h
.text$mn:000027C8 var_34          = word ptr -34h
.text$mn:000027C8 var_32          = word ptr -32h
.text$mn:000027C8 var_30          = word ptr -30h
.text$mn:000027C8 var_2D          = byte ptr -2Dh
.text$mn:000027C8 var_2C          = byte ptr -2Ch
.text$mn:000027C8 var_10          = dword ptr -10h
.text$mn:000027C8 var_C           = dword ptr -0Ch
.text$mn:000027C8 var_4           = dword ptr -4
.text$mn:000027C8 arg_0           = dword ptr  8
.text$mn:000027C8 arg_4           = dword ptr  0Ch
.text$mn:000027C8
.text$mn:000027C8                 push    ebp
.text$mn:000027C9                 mov     ebp, esp
.text$mn:000027CB                 push    0FFFFFFFFh
.text$mn:000027CD                 push    offset __ehhandler$?intToString@@YA?AV?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@H@Z
.text$mn:000027D2                 mov     eax, large fs:0
.text$mn:000027D8                 push    eax
.text$mn:000027D9                 sub     esp, 60h
.text$mn:000027DC                 mov     eax, dword ptr ds:___security_cookie
.text$mn:000027E1                 xor     eax, ebp
.text$mn:000027E3                 mov     [ebp+var_10], eax
.text$mn:000027E6                 push    eax
.text$mn:000027E7                 lea     eax, [ebp+var_C]
.text$mn:000027EA                 mov     large fs:0, eax
.text$mn:000027F0                 mov     [ebp+var_3C], 0
.text$mn:000027F7                 lea     ecx, [ebp+var_5C]
.text$mn:000027FA                 call    ??0?$vector@_WV?$allocator@_W@std@@@std@@QAE@XZ ; std::vector<wchar_t,std::allocator<wchar_t>>::vector<wchar_t,std::allocator<wchar_t>>(void)
.text$mn:000027FF                 mov     [ebp+var_4], 1
.text$mn:00002806                 cmp     [ebp+arg_4], 0
.text$mn:0000280A                 jge     short loc_2815
.text$mn:0000280C                 mov     [ebp+var_38], 1
.text$mn:00002813                 jmp     short loc_281C
.text$mn:00002815 ; ---------------------------------------------------------------------------
.text$mn:00002815
.text$mn:00002815 loc_2815:                               ; CODE XREF: intToString(int)+42j
.text$mn:00002815                 mov     [ebp+var_38], 0
.text$mn:0000281C
.text$mn:0000281C loc_281C:                               ; CODE XREF: intToString(int)+4Bj
.text$mn:0000281C                 mov     al, byte ptr [ebp+var_38]
.text$mn:0000281F                 mov     [ebp+var_2D], al
.text$mn:00002822                 mov     eax, [ebp+arg_4]
.text$mn:00002825                 cdq
.text$mn:00002826                 mov     ecx, 0Ah
.text$mn:0000282B                 idiv    ecx
.text$mn:0000282D                 push    edx             ; X
.text$mn:0000282E                 call    _abs
.text$mn:00002833                 add     esp, 4
.text$mn:00002836                 movzx   edx, ax
.text$mn:00002839                 add     edx, 30h ; '0'
.text$mn:0000283C                 mov     [ebp+var_34], dx
.text$mn:00002840                 lea     eax, [ebp+var_34]
.text$mn:00002843                 push    eax
.text$mn:00002844                 lea     ecx, [ebp+var_5C]
.text$mn:00002847                 call    ?push_back@?$vector@_WV?$allocator@_W@std@@@std@@QAEX$$QA_W@Z ; std::vector<wchar_t,std::allocator<wchar_t>>::push_back(wchar_t &&)
.text$mn:0000284C                 mov     eax, [ebp+arg_4]
.text$mn:0000284F                 cdq
.text$mn:00002850                 mov     ecx, 0Ah
.text$mn:00002855                 idiv    ecx
.text$mn:00002857                 mov     [ebp+arg_4], eax
.text$mn:0000285A
.text$mn:0000285A loc_285A:                               ; CODE XREF: intToString(int)+D0j
.text$mn:0000285A                 cmp     [ebp+arg_4], 0
.text$mn:0000285E                 jz      short loc_289A
.text$mn:00002860                 mov     eax, [ebp+arg_4]
.text$mn:00002863                 cdq
.text$mn:00002864                 mov     ecx, 0Ah
.text$mn:00002869                 idiv    ecx
.text$mn:0000286B                 push    edx             ; X
.text$mn:0000286C                 call    _abs
.text$mn:00002871                 add     esp, 4
.text$mn:00002874                 movzx   edx, ax
.text$mn:00002877                 add     edx, 30h ; '0'
.text$mn:0000287A                 mov     [ebp+var_32], dx
.text$mn:0000287E                 lea     eax, [ebp+var_32]
.text$mn:00002881                 push    eax
.text$mn:00002882                 lea     ecx, [ebp+var_5C]
.text$mn:00002885                 call    ?push_back@?$vector@_WV?$allocator@_W@std@@@std@@QAEX$$QA_W@Z ; std::vector<wchar_t,std::allocator<wchar_t>>::push_back(wchar_t &&)
.text$mn:0000288A                 mov     eax, [ebp+arg_4]
.text$mn:0000288D                 cdq
.text$mn:0000288E                 mov     ecx, 0Ah
.text$mn:00002893                 idiv    ecx
.text$mn:00002895                 mov     [ebp+arg_4], eax
.text$mn:00002898                 jmp     short loc_285A
.text$mn:0000289A ; ---------------------------------------------------------------------------
.text$mn:0000289A
.text$mn:0000289A loc_289A:                               ; CODE XREF: intToString(int)+96j
.text$mn:0000289A                 movzx   edx, [ebp+var_2D]
.text$mn:0000289E                 test    edx, edx
.text$mn:000028A0                 jz      short loc_28B7
.text$mn:000028A2                 mov     eax, 2Dh ; '-'
.text$mn:000028A7                 mov     [ebp+var_30], ax
.text$mn:000028AB                 lea     ecx, [ebp+var_30]
.text$mn:000028AE                 push    ecx
.text$mn:000028AF                 lea     ecx, [ebp+var_5C]
.text$mn:000028B2                 call    ?push_back@?$vector@_WV?$allocator@_W@std@@@std@@QAEX$$QA_W@Z ; std::vector<wchar_t,std::allocator<wchar_t>>::push_back(wchar_t &&)
.text$mn:000028B7
.text$mn:000028B7 loc_28B7:                               ; CODE XREF: intToString(int)+D8j
.text$mn:000028B7                 sub     esp, 0Ch
.text$mn:000028BA                 mov     edx, esp
.text$mn:000028BC                 mov     [ebp+var_64], esp
.text$mn:000028BF                 push    edx
.text$mn:000028C0                 lea     ecx, [ebp+var_5C]
.text$mn:000028C3                 call    ?rend@?$vector@_WV?$allocator@_W@std@@@std@@QAE?AV?$reverse_iterator@V?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@_W@std@@@std@@@std@@@2@XZ ; std::vector<wchar_t,std::allocator<wchar_t>>::rend(void)
.text$mn:000028C8                 mov     [ebp+var_4C], eax
.text$mn:000028CB                 mov     eax, [ebp+var_4C]
.text$mn:000028CE                 mov     [ebp+var_60], eax
.text$mn:000028D1                 mov     byte ptr [ebp+var_4], 2
.text$mn:000028D5                 sub     esp, 0Ch
.text$mn:000028D8                 mov     ecx, esp
.text$mn:000028DA                 mov     [ebp+var_6C], esp
.text$mn:000028DD                 push    ecx
.text$mn:000028DE                 lea     ecx, [ebp+var_5C]
.text$mn:000028E1                 call    ?rbegin@?$vector@_WV?$allocator@_W@std@@@std@@QAE?AV?$reverse_iterator@V?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@_W@std@@@std@@@std@@@2@XZ ; std::vector<wchar_t,std::allocator<wchar_t>>::rbegin(void)
.text$mn:000028E6                 mov     [ebp+var_40], eax
.text$mn:000028E9                 mov     edx, [ebp+var_40]
.text$mn:000028EC                 mov     [ebp+var_68], edx
.text$mn:000028EF                 mov     byte ptr [ebp+var_4], 3
.text$mn:000028F3                 mov     byte ptr [ebp+var_4], 1
.text$mn:000028F7                 lea     ecx, [ebp+var_2C]
.text$mn:000028FA                 call    ??$?0V?$reverse_iterator@V?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@_W@std@@@std@@@std@@@std@@X@?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QAE@V?$reverse_iterator@V?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@_W@std@@@std@@@std@@@1@0@Z ; std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>>::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>>(std::reverse_iterator<std::_Vector_iterator<std::_Vector_val<std::_Simple_types<wchar_t>>>>,std::reverse_iterator<std::_Vector_iterator<std::_Vector_val<std::_Simple_types<wchar_t>>>>)
.text$mn:000028FF                 mov     [ebp+var_48], eax
.text$mn:00002902                 mov     eax, [ebp+var_48]
.text$mn:00002905                 mov     [ebp+var_44], eax
.text$mn:00002908                 mov     byte ptr [ebp+var_4], 4
.text$mn:0000290C                 mov     ecx, [ebp+var_44]
.text$mn:0000290F                 push    ecx
.text$mn:00002910                 mov     ecx, [ebp+arg_0]
.text$mn:00002913                 call    ??0?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QAE@$$QAV01@@Z ; std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>>::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>>(std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>> &&)
.text$mn:00002918                 mov     edx, [ebp+var_3C]
.text$mn:0000291B                 or      edx, 1
.text$mn:0000291E                 mov     [ebp+var_3C], edx
.text$mn:00002921                 mov     byte ptr [ebp+var_4], 1
.text$mn:00002925                 lea     ecx, [ebp+var_2C]
.text$mn:00002928                 call    ??1?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QAE@XZ ; std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>>::~basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>>(void)
.text$mn:0000292D                 mov     byte ptr [ebp+var_4], 0
.text$mn:00002931                 lea     ecx, [ebp+var_5C]
.text$mn:00002934                 call    ??1?$vector@_WV?$allocator@_W@std@@@std@@QAE@XZ ; std::vector<wchar_t,std::allocator<wchar_t>>::~vector<wchar_t,std::allocator<wchar_t>>(void)
.text$mn:00002939                 mov     eax, [ebp+arg_0]
.text$mn:0000293C                 mov     ecx, [ebp+var_C]
.text$mn:0000293F                 mov     large fs:0, ecx
.text$mn:00002946                 pop     ecx
.text$mn:00002947                 mov     ecx, [ebp+var_10]
.text$mn:0000294A                 xor     ecx, ebp
.text$mn:0000294C                 call    @__security_check_cookie@4 ; __security_check_cookie(x)
.text$mn:00002951                 mov     esp, ebp
.text$mn:00002953                 pop     ebp
.text$mn:00002954                 retn
.text$mn:00002954 ?intToString@@YA?AV?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@H@Z endp
.text$mn:00002954
.text$mn:00002954 ; ---------------------------------------------------------------------------
.text$mn:00002955                 align 4
.text$mn:00002958
.text$mn:00002958 ; =============== S U B R O U T I N E =======================================
.text$mn:00002958
.text$mn:00002958 ; Attributes: bp-based frame
.text$mn:00002958
.text$mn:00002958 ; class std::basic_string<wchar_t, struct std::char_traits<wchar_t>, class std::allocator<wchar_t>> __cdecl uintToString(unsigned int)
.text$mn:00002958                 public ?uintToString@@YA?AV?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@I@Z
.text$mn:00002958 ?uintToString@@YA?AV?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@I@Z proc near
.text$mn:00002958                                         ; CODE XREF: BuildMenuFileName(int,uint,std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>> const &)+8Ap
.text$mn:00002958
.text$mn:00002958 var_64          = dword ptr -64h
.text$mn:00002958 var_60          = dword ptr -60h
.text$mn:00002958 var_5C          = dword ptr -5Ch
.text$mn:00002958 var_58          = dword ptr -58h
.text$mn:00002958 var_54          = byte ptr -54h
.text$mn:00002958 var_44          = dword ptr -44h
.text$mn:00002958 var_40          = dword ptr -40h
.text$mn:00002958 var_3C          = dword ptr -3Ch
.text$mn:00002958 var_38          = dword ptr -38h
.text$mn:00002958 var_34          = dword ptr -34h
.text$mn:00002958 var_30          = word ptr -30h
.text$mn:00002958 var_2E          = word ptr -2Eh
.text$mn:00002958 var_2C          = byte ptr -2Ch
.text$mn:00002958 var_10          = dword ptr -10h
.text$mn:00002958 var_C           = dword ptr -0Ch
.text$mn:00002958 var_4           = dword ptr -4
.text$mn:00002958 arg_0           = dword ptr  8
.text$mn:00002958 arg_4           = dword ptr  0Ch
.text$mn:00002958
.text$mn:00002958                 push    ebp
.text$mn:00002959                 mov     ebp, esp
.text$mn:0000295B                 push    0FFFFFFFFh
.text$mn:0000295D                 push    offset __ehhandler$?uintToString@@YA?AV?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@I@Z
.text$mn:00002962                 mov     eax, large fs:0
.text$mn:00002968                 push    eax
.text$mn:00002969                 sub     esp, 58h
.text$mn:0000296C                 mov     eax, dword ptr ds:___security_cookie
.text$mn:00002971                 xor     eax, ebp
.text$mn:00002973                 mov     [ebp+var_10], eax
.text$mn:00002976                 push    eax
.text$mn:00002977                 lea     eax, [ebp+var_C]
.text$mn:0000297A                 mov     large fs:0, eax
.text$mn:00002980                 mov     [ebp+var_34], 0
.text$mn:00002987                 lea     ecx, [ebp+var_54]
.text$mn:0000298A                 call    ??0?$vector@_WV?$allocator@_W@std@@@std@@QAE@XZ ; std::vector<wchar_t,std::allocator<wchar_t>>::vector<wchar_t,std::allocator<wchar_t>>(void)
.text$mn:0000298F                 mov     [ebp+var_4], 1
.text$mn:00002996                 mov     eax, [ebp+arg_4]
.text$mn:00002999                 xor     edx, edx
.text$mn:0000299B                 mov     ecx, 0Ah
.text$mn:000029A0                 div     ecx
.text$mn:000029A2                 movzx   edx, dx
.text$mn:000029A5                 add     edx, 30h ; '0'
.text$mn:000029A8                 mov     [ebp+var_30], dx
.text$mn:000029AC                 lea     eax, [ebp+var_30]
.text$mn:000029AF                 push    eax
.text$mn:000029B0                 lea     ecx, [ebp+var_54]
.text$mn:000029B3                 call    ?push_back@?$vector@_WV?$allocator@_W@std@@@std@@QAEX$$QA_W@Z ; std::vector<wchar_t,std::allocator<wchar_t>>::push_back(wchar_t &&)
.text$mn:000029B8                 mov     eax, [ebp+arg_4]
.text$mn:000029BB                 xor     edx, edx
.text$mn:000029BD                 mov     ecx, 0Ah
.text$mn:000029C2                 div     ecx
.text$mn:000029C4                 mov     [ebp+arg_4], eax
.text$mn:000029C7
.text$mn:000029C7 loc_29C7:                               ; CODE XREF: uintToString(uint)+A6j
.text$mn:000029C7                 cmp     [ebp+arg_4], 0
.text$mn:000029CB                 jz      short loc_2A00
.text$mn:000029CD                 mov     eax, [ebp+arg_4]
.text$mn:000029D0                 xor     edx, edx
.text$mn:000029D2                 mov     ecx, 0Ah
.text$mn:000029D7                 div     ecx
.text$mn:000029D9                 movzx   edx, dx
.text$mn:000029DC                 add     edx, 30h ; '0'
.text$mn:000029DF                 mov     [ebp+var_2E], dx
.text$mn:000029E3                 lea     eax, [ebp+var_2E]
.text$mn:000029E6                 push    eax
.text$mn:000029E7                 lea     ecx, [ebp+var_54]
.text$mn:000029EA                 call    ?push_back@?$vector@_WV?$allocator@_W@std@@@std@@QAEX$$QA_W@Z ; std::vector<wchar_t,std::allocator<wchar_t>>::push_back(wchar_t &&)
.text$mn:000029EF                 mov     eax, [ebp+arg_4]
.text$mn:000029F2                 xor     edx, edx
.text$mn:000029F4                 mov     ecx, 0Ah
.text$mn:000029F9                 div     ecx
.text$mn:000029FB                 mov     [ebp+arg_4], eax
.text$mn:000029FE                 jmp     short loc_29C7
.text$mn:00002A00 ; ---------------------------------------------------------------------------
.text$mn:00002A00
.text$mn:00002A00 loc_2A00:                               ; CODE XREF: uintToString(uint)+73j
.text$mn:00002A00                 sub     esp, 0Ch
.text$mn:00002A03                 mov     edx, esp
.text$mn:00002A05                 mov     [ebp+var_5C], esp
.text$mn:00002A08                 push    edx
.text$mn:00002A09                 lea     ecx, [ebp+var_54]
.text$mn:00002A0C                 call    ?rend@?$vector@_WV?$allocator@_W@std@@@std@@QAE?AV?$reverse_iterator@V?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@_W@std@@@std@@@std@@@2@XZ ; std::vector<wchar_t,std::allocator<wchar_t>>::rend(void)
.text$mn:00002A11                 mov     [ebp+var_3C], eax
.text$mn:00002A14                 mov     eax, [ebp+var_3C]
.text$mn:00002A17                 mov     [ebp+var_58], eax
.text$mn:00002A1A                 mov     byte ptr [ebp+var_4], 2
.text$mn:00002A1E                 sub     esp, 0Ch
.text$mn:00002A21                 mov     ecx, esp
.text$mn:00002A23                 mov     [ebp+var_64], esp
.text$mn:00002A26                 push    ecx
.text$mn:00002A27                 lea     ecx, [ebp+var_54]
.text$mn:00002A2A                 call    ?rbegin@?$vector@_WV?$allocator@_W@std@@@std@@QAE?AV?$reverse_iterator@V?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@_W@std@@@std@@@std@@@2@XZ ; std::vector<wchar_t,std::allocator<wchar_t>>::rbegin(void)
.text$mn:00002A2F                 mov     [ebp+var_44], eax
.text$mn:00002A32                 mov     edx, [ebp+var_44]
.text$mn:00002A35                 mov     [ebp+var_60], edx
.text$mn:00002A38                 mov     byte ptr [ebp+var_4], 3
.text$mn:00002A3C                 mov     byte ptr [ebp+var_4], 1
.text$mn:00002A40                 lea     ecx, [ebp+var_2C]
.text$mn:00002A43                 call    ??$?0V?$reverse_iterator@V?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@_W@std@@@std@@@std@@@std@@X@?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QAE@V?$reverse_iterator@V?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@_W@std@@@std@@@std@@@1@0@Z ; std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>>::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>>(std::reverse_iterator<std::_Vector_iterator<std::_Vector_val<std::_Simple_types<wchar_t>>>>,std::reverse_iterator<std::_Vector_iterator<std::_Vector_val<std::_Simple_types<wchar_t>>>>)
.text$mn:00002A48                 mov     [ebp+var_40], eax
.text$mn:00002A4B                 mov     eax, [ebp+var_40]
.text$mn:00002A4E                 mov     [ebp+var_38], eax
.text$mn:00002A51                 mov     byte ptr [ebp+var_4], 4
.text$mn:00002A55                 mov     ecx, [ebp+var_38]
.text$mn:00002A58                 push    ecx
.text$mn:00002A59                 mov     ecx, [ebp+arg_0]
.text$mn:00002A5C                 call    ??0?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QAE@$$QAV01@@Z ; std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>>::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>>(std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>> &&)
.text$mn:00002A61                 mov     edx, [ebp+var_34]
.text$mn:00002A64                 or      edx, 1
.text$mn:00002A67                 mov     [ebp+var_34], edx
.text$mn:00002A6A                 mov     byte ptr [ebp+var_4], 1
.text$mn:00002A6E                 lea     ecx, [ebp+var_2C]
.text$mn:00002A71                 call    ??1?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QAE@XZ ; std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>>::~basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>>(void)
.text$mn:00002A76                 mov     byte ptr [ebp+var_4], 0
.text$mn:00002A7A                 lea     ecx, [ebp+var_54]
.text$mn:00002A7D                 call    ??1?$vector@_WV?$allocator@_W@std@@@std@@QAE@XZ ; std::vector<wchar_t,std::allocator<wchar_t>>::~vector<wchar_t,std::allocator<wchar_t>>(void)
.text$mn:00002A82                 mov     eax, [ebp+arg_0]
.text$mn:00002A85                 mov     ecx, [ebp+var_C]
.text$mn:00002A88                 mov     large fs:0, ecx
.text$mn:00002A8F                 pop     ecx
.text$mn:00002A90                 mov     ecx, [ebp+var_10]
.text$mn:00002A93                 xor     ecx, ebp
.text$mn:00002A95                 call    @__security_check_cookie@4 ; __security_check_cookie(x)
.text$mn:00002A9A                 mov     esp, ebp
.text$mn:00002A9C                 pop     ebp
.text$mn:00002A9D                 retn
.text$mn:00002A9D ?uintToString@@YA?AV?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@I@Z endp
.text$mn:00002A9D
.text$mn:00002A9D ; ---------------------------------------------------------------------------
.text$mn:00002A9E                 align 10h
.text$mn:00002A9E _text$mn        ends
.text$mn:00002A9E
.text$x:00002AA0 ; ===========================================================================
.text$x:00002AA0
.text$x:00002AA0 ; Segment type: Pure code
.text$x:00002AA0 ; Segment permissions: Read/Execute
.text$x:00002AA0 _text$x         segment para public 'CODE' use32
.text$x:00002AA0                 assume cs:_text$x
.text$x:00002AA0                 ;org 2AA0h
.text$x:00002AA0                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text$x:00002AA0
.text$x:00002AA0 ; =============== S U B R O U T I N E =======================================
.text$x:00002AA0
.text$x:00002AA0
.text$x:00002AA0 __unwindfunclet$?getFolderName@@YA?AV?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@PAUHWND__@@PB_W@Z$0 proc near
.text$x:00002AA0                                         ; DATA XREF: .xdata$x:0000DDB4o
.text$x:00002AA0                 lea     ecx, [ebp-43Ch]
.text$x:00002AA6                 jmp     ??1?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QAE@XZ ; std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>>::~basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>>(void)
.text$x:00002AA6 __unwindfunclet$?getFolderName@@YA?AV?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@PAUHWND__@@PB_W@Z$0 endp
.text$x:00002AA6
.text$x:00002AAB
.text$x:00002AAB ; =============== S U B R O U T I N E =======================================
.text$x:00002AAB
.text$x:00002AAB
.text$x:00002AAB __unwindfunclet$?getFolderName@@YA?AV?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@PAUHWND__@@PB_W@Z$1 proc near
.text$x:00002AAB                                         ; DATA XREF: .xdata$x:0000DDACo
.text$x:00002AAB                 mov     eax, [ebp-448h]
.text$x:00002AB1                 and     eax, 1
.text$x:00002AB4                 jz      locret_2AC9
.text$x:00002ABA                 and     dword ptr [ebp-448h], 0FFFFFFFEh
.text$x:00002AC1                 mov     ecx, [ebp+8]
.text$x:00002AC4                 jmp     ??1?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QAE@XZ ; std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>>::~basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>>(void)
.text$x:00002AC9 ; ---------------------------------------------------------------------------
.text$x:00002AC9
.text$x:00002AC9 locret_2AC9:                            ; CODE XREF: __unwindfunclet$?getFolderName@@YA?AV?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@PAUHWND__@@PB_W@Z$1+9j
.text$x:00002AC9                 retn
.text$x:00002AC9 __unwindfunclet$?getFolderName@@YA?AV?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@PAUHWND__@@PB_W@Z$1 endp
.text$x:00002AC9
.text$x:00002ACA
.text$x:00002ACA ; =============== S U B R O U T I N E =======================================
.text$x:00002ACA
.text$x:00002ACA
.text$x:00002ACA __ehhandler$?getFolderName@@YA?AV?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@PAUHWND__@@PB_W@Z proc near
.text$x:00002ACA                                         ; DATA XREF: getFolderName(HWND__ *,wchar_t const *)+5o
.text$x:00002ACA
.text$x:00002ACA arg_4           = dword ptr  8
.text$x:00002ACA
.text$x:00002ACA                 mov     edx, [esp+arg_4]
.text$x:00002ACE                 lea     eax, [edx+0Ch]
.text$x:00002AD1                 mov     ecx, [edx-460h]
.text$x:00002AD7                 xor     ecx, eax
.text$x:00002AD9                 call    @__security_check_cookie@4 ; __security_check_cookie(x)
.text$x:00002ADE                 mov     ecx, [edx-4]
.text$x:00002AE1                 xor     ecx, eax
.text$x:00002AE3                 call    @__security_check_cookie@4 ; __security_check_cookie(x)
.text$x:00002AE8                 mov     eax, offset __ehfuncinfo$?getFolderName@@YA?AV?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@PAUHWND__@@PB_W@Z
.text$x:00002AED                 jmp     ___CxxFrameHandler3
.text$x:00002AED __ehhandler$?getFolderName@@YA?AV?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@PAUHWND__@@PB_W@Z endp
.text$x:00002AED
.text$x:00002AF2
.text$x:00002AF2 ; =============== S U B R O U T I N E =======================================
.text$x:00002AF2
.text$x:00002AF2
.text$x:00002AF2 __unwindfunclet$?purgeMenuItemString@@YA?AV?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@PB_W_N@Z$0 proc near
.text$x:00002AF2                                         ; DATA XREF: .xdata$x:0000DD34o
.text$x:00002AF2                 mov     eax, [ebp-0A4h]
.text$x:00002AF8                 and     eax, 1
.text$x:00002AFB                 jz      locret_2B10
.text$x:00002B01                 and     dword ptr [ebp-0A4h], 0FFFFFFFEh
.text$x:00002B08                 mov     ecx, [ebp+8]
.text$x:00002B0B                 jmp     ??1?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QAE@XZ ; std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>>::~basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>>(void)
.text$x:00002B10 ; ---------------------------------------------------------------------------
.text$x:00002B10
.text$x:00002B10 locret_2B10:                            ; CODE XREF: __unwindfunclet$?purgeMenuItemString@@YA?AV?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@PB_W_N@Z$0+9j
.text$x:00002B10                 retn
.text$x:00002B10 __unwindfunclet$?purgeMenuItemString@@YA?AV?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@PB_W_N@Z$0 endp
.text$x:00002B10
.text$x:00002B11
.text$x:00002B11 ; =============== S U B R O U T I N E =======================================
.text$x:00002B11
.text$x:00002B11
.text$x:00002B11 __ehhandler$?purgeMenuItemString@@YA?AV?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@PB_W_N@Z proc near
.text$x:00002B11                                         ; DATA XREF: purgeMenuItemString(wchar_t const *,bool)+5o
.text$x:00002B11
.text$x:00002B11 arg_4           = dword ptr  8
.text$x:00002B11
.text$x:00002B11                 mov     edx, [esp+arg_4]
.text$x:00002B15                 lea     eax, [edx+0Ch]
.text$x:00002B18                 mov     ecx, [edx-0A0h]
.text$x:00002B1E                 xor     ecx, eax
.text$x:00002B20                 call    @__security_check_cookie@4 ; __security_check_cookie(x)
.text$x:00002B25                 mov     ecx, [edx-4]
.text$x:00002B28                 xor     ecx, eax
.text$x:00002B2A                 call    @__security_check_cookie@4 ; __security_check_cookie(x)
.text$x:00002B2F                 mov     eax, offset __ehfuncinfo$?purgeMenuItemString@@YA?AV?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@PB_W_N@Z
.text$x:00002B34                 jmp     ___CxxFrameHandler3
.text$x:00002B34 __ehhandler$?purgeMenuItemString@@YA?AV?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@PB_W_N@Z endp
.text$x:00002B34
.text$x:00002B39
.text$x:00002B39 ; =============== S U B R O U T I N E =======================================
.text$x:00002B39
.text$x:00002B39
.text$x:00002B39 __unwindfunclet$?tokenizeString@@YA?AV?$vector@V?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@V?$allocator@V?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@@2@@std@@ABV?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@2@D@Z$0 proc near
.text$x:00002B39                                         ; DATA XREF: .xdata$x:0000DDC4o
.text$x:00002B39                 lea     ecx, [ebp-50h]
.text$x:00002B3C                 jmp     ??1?$vector@V?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@V?$allocator@V?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@@2@@std@@QAE@XZ ; std::vector<std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>>,std::allocator<std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>>>>::~vector<std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>>,std::allocator<std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>>>>(void)
.text$x:00002B3C __unwindfunclet$?tokenizeString@@YA?AV?$vector@V?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@V?$allocator@V?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@@2@@std@@ABV?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@2@D@Z$0 endp
.text$x:00002B3C
.text$x:00002B41
.text$x:00002B41 ; =============== S U B R O U T I N E =======================================
.text$x:00002B41
.text$x:00002B41
.text$x:00002B41 __unwindfunclet$?tokenizeString@@YA?AV?$vector@V?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@V?$allocator@V?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@@2@@std@@ABV?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@2@D@Z$1 proc near
.text$x:00002B41                                         ; DATA XREF: .xdata$x:0000DDCCo
.text$x:00002B41                 lea     ecx, [ebp-2Ch]
.text$x:00002B44                 jmp     ??1?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QAE@XZ ; std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>>::~basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>>(void)
.text$x:00002B44 __unwindfunclet$?tokenizeString@@YA?AV?$vector@V?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@V?$allocator@V?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@@2@@std@@ABV?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@2@D@Z$1 endp
.text$x:00002B44
.text$x:00002B49
.text$x:00002B49 ; =============== S U B R O U T I N E =======================================
.text$x:00002B49
.text$x:00002B49
.text$x:00002B49 __unwindfunclet$?tokenizeString@@YA?AV?$vector@V?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@V?$allocator@V?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@@2@@std@@ABV?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@2@D@Z$2 proc near
.text$x:00002B49                                         ; DATA XREF: .xdata$x:0000DDBCo
.text$x:00002B49                 mov     eax, [ebp-38h]
.text$x:00002B4C                 and     eax, 1
.text$x:00002B4F                 jz      locret_2B61
.text$x:00002B55                 and     dword ptr [ebp-38h], 0FFFFFFFEh
.text$x:00002B59                 mov     ecx, [ebp+8]
.text$x:00002B5C                 jmp     ??1?$vector@V?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@V?$allocator@V?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@@2@@std@@QAE@XZ ; std::vector<std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>>,std::allocator<std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>>>>::~vector<std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>>,std::allocator<std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>>>>(void)
.text$x:00002B61 ; ---------------------------------------------------------------------------
.text$x:00002B61
.text$x:00002B61 locret_2B61:                            ; CODE XREF: __unwindfunclet$?tokenizeString@@YA?AV?$vector@V?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@V?$allocator@V?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@@2@@std@@ABV?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@2@D@Z$2+6j
.text$x:00002B61                 retn
.text$x:00002B61 __unwindfunclet$?tokenizeString@@YA?AV?$vector@V?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@V?$allocator@V?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@@2@@std@@ABV?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@2@D@Z$2 endp
.text$x:00002B61
.text$x:00002B62
.text$x:00002B62 ; =============== S U B R O U T I N E =======================================
.text$x:00002B62
.text$x:00002B62
.text$x:00002B62 __ehhandler$?tokenizeString@@YA?AV?$vector@V?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@V?$allocator@V?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@@2@@std@@ABV?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@2@D@Z proc near
.text$x:00002B62                                         ; DATA XREF: tokenizeString(std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>> const &,char)+5o
.text$x:00002B62
.text$x:00002B62 arg_4           = dword ptr  8
.text$x:00002B62
.text$x:00002B62                 mov     edx, [esp+arg_4]
.text$x:00002B66                 lea     eax, [edx+0Ch]
.text$x:00002B69                 mov     ecx, [edx-48h]
.text$x:00002B6C                 xor     ecx, eax
.text$x:00002B6E                 call    @__security_check_cookie@4 ; __security_check_cookie(x)
.text$x:00002B73                 mov     ecx, [edx-4]
.text$x:00002B76                 xor     ecx, eax
.text$x:00002B78                 call    @__security_check_cookie@4 ; __security_check_cookie(x)
.text$x:00002B7D                 mov     eax, offset __ehfuncinfo$?tokenizeString@@YA?AV?$vector@V?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@V?$allocator@V?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@@2@@std@@ABV?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@2@D@Z
.text$x:00002B82                 jmp     ___CxxFrameHandler3
.text$x:00002B82 __ehhandler$?tokenizeString@@YA?AV?$vector@V?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@V?$allocator@V?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@@2@@std@@ABV?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@2@D@Z endp
.text$x:00002B82
.text$x:00002B87
.text$x:00002B87 ; =============== S U B R O U T I N E =======================================
.text$x:00002B87
.text$x:00002B87
.text$x:00002B87 __unwindfunclet$?string2wstring@@YA?AV?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@ABV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@2@I@Z$0 proc near
.text$x:00002B87                                         ; DATA XREF: .xdata$x:0000DDA4o
.text$x:00002B87                 lea     ecx, [ebp-24h]
.text$x:00002B8A                 jmp     ??1?$vector@_WV?$allocator@_W@std@@@std@@QAE@XZ ; std::vector<wchar_t,std::allocator<wchar_t>>::~vector<wchar_t,std::allocator<wchar_t>>(void)
.text$x:00002B8A __unwindfunclet$?string2wstring@@YA?AV?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@ABV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@2@I@Z$0 endp
.text$x:00002B8A
.text$x:00002B8F
.text$x:00002B8F ; =============== S U B R O U T I N E =======================================
.text$x:00002B8F
.text$x:00002B8F
.text$x:00002B8F __unwindfunclet$?string2wstring@@YA?AV?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@ABV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@2@I@Z$1 proc near
.text$x:00002B8F                                         ; DATA XREF: .xdata$x:0000DD9Co
.text$x:00002B8F                 mov     eax, [ebp-10h]
.text$x:00002B92                 and     eax, 1
.text$x:00002B95                 jz      locret_2BA7
.text$x:00002B9B                 and     dword ptr [ebp-10h], 0FFFFFFFEh
.text$x:00002B9F                 mov     ecx, [ebp+8]
.text$x:00002BA2                 jmp     ??1?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QAE@XZ ; std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>>::~basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>>(void)
.text$x:00002BA7 ; ---------------------------------------------------------------------------
.text$x:00002BA7
.text$x:00002BA7 locret_2BA7:                            ; CODE XREF: __unwindfunclet$?string2wstring@@YA?AV?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@ABV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@2@I@Z$1+6j
.text$x:00002BA7                 retn
.text$x:00002BA7 __unwindfunclet$?string2wstring@@YA?AV?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@ABV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@2@I@Z$1 endp
.text$x:00002BA7
.text$x:00002BA8
.text$x:00002BA8 ; =============== S U B R O U T I N E =======================================
.text$x:00002BA8
.text$x:00002BA8
.text$x:00002BA8 __ehhandler$?string2wstring@@YA?AV?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@ABV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@2@I@Z proc near
.text$x:00002BA8                                         ; DATA XREF: string2wstring(std::basic_string<char,std::char_traits<char>,std::allocator<char>> const &,uint)+5o
.text$x:00002BA8
.text$x:00002BA8 arg_4           = dword ptr  8
.text$x:00002BA8
.text$x:00002BA8                 mov     edx, [esp+arg_4]
.text$x:00002BAC                 lea     eax, [edx+0Ch]
.text$x:00002BAF                 mov     ecx, [edx-1Ch]
.text$x:00002BB2                 xor     ecx, eax
.text$x:00002BB4                 call    @__security_check_cookie@4 ; __security_check_cookie(x)
.text$x:00002BB9                 mov     eax, offset __ehfuncinfo$?string2wstring@@YA?AV?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@ABV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@2@I@Z
.text$x:00002BBE                 jmp     ___CxxFrameHandler3
.text$x:00002BBE __ehhandler$?string2wstring@@YA?AV?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@ABV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@2@I@Z endp
.text$x:00002BBE
.text$x:00002BC3
.text$x:00002BC3 ; =============== S U B R O U T I N E =======================================
.text$x:00002BC3
.text$x:00002BC3
.text$x:00002BC3 __unwindfunclet$?wstring2string@@YA?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@ABV?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@2@I@Z$0 proc near
.text$x:00002BC3                                         ; DATA XREF: .xdata$x:0000DD94o
.text$x:00002BC3                 lea     ecx, [ebp-24h]
.text$x:00002BC6                 jmp     ??1?$vector@DV?$allocator@D@std@@@std@@QAE@XZ ; std::vector<char,std::allocator<char>>::~vector<char,std::allocator<char>>(void)
.text$x:00002BC6 __unwindfunclet$?wstring2string@@YA?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@ABV?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@2@I@Z$0 endp
.text$x:00002BC6
.text$x:00002BCB
.text$x:00002BCB ; =============== S U B R O U T I N E =======================================
.text$x:00002BCB
.text$x:00002BCB
.text$x:00002BCB __unwindfunclet$?wstring2string@@YA?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@ABV?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@2@I@Z$1 proc near
.text$x:00002BCB                                         ; DATA XREF: .xdata$x:0000DD8Co
.text$x:00002BCB                 mov     eax, [ebp-10h]
.text$x:00002BCE                 and     eax, 1
.text$x:00002BD1                 jz      locret_2BE3
.text$x:00002BD7                 and     dword ptr [ebp-10h], 0FFFFFFFEh
.text$x:00002BDB                 mov     ecx, [ebp+8]
.text$x:00002BDE                 jmp     ??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char>>::~basic_string<char,std::char_traits<char>,std::allocator<char>>(void)
.text$x:00002BE3 ; ---------------------------------------------------------------------------
.text$x:00002BE3
.text$x:00002BE3 locret_2BE3:                            ; CODE XREF: __unwindfunclet$?wstring2string@@YA?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@ABV?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@2@I@Z$1+6j
.text$x:00002BE3                 retn
.text$x:00002BE3 __unwindfunclet$?wstring2string@@YA?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@ABV?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@2@I@Z$1 endp
.text$x:00002BE3
.text$x:00002BE4
.text$x:00002BE4 ; =============== S U B R O U T I N E =======================================
.text$x:00002BE4
.text$x:00002BE4
.text$x:00002BE4 __ehhandler$?wstring2string@@YA?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@ABV?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@2@I@Z proc near
.text$x:00002BE4                                         ; DATA XREF: wstring2string(std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>> const &,uint)+5o
.text$x:00002BE4
.text$x:00002BE4 arg_4           = dword ptr  8
.text$x:00002BE4
.text$x:00002BE4                 mov     edx, [esp+arg_4]
.text$x:00002BE8                 lea     eax, [edx+0Ch]
.text$x:00002BEB                 mov     ecx, [edx-1Ch]
.text$x:00002BEE                 xor     ecx, eax
.text$x:00002BF0                 call    @__security_check_cookie@4 ; __security_check_cookie(x)
.text$x:00002BF5                 mov     eax, offset __ehfuncinfo$?wstring2string@@YA?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@ABV?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@2@I@Z
.text$x:00002BFA                 jmp     ___CxxFrameHandler3
.text$x:00002BFA __ehhandler$?wstring2string@@YA?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@ABV?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@2@I@Z endp
.text$x:00002BFA
.text$x:00002BFF
.text$x:00002BFF ; =============== S U B R O U T I N E =======================================
.text$x:00002BFF
.text$x:00002BFF
.text$x:00002BFF __unwindfunclet$?BuildMenuFileName@@YA?AV?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@HIABV12@@Z$0 proc near
.text$x:00002BFF                                         ; DATA XREF: .xdata$x:0000E0FCo
.text$x:00002BFF                 lea     ecx, [ebp-2Ch]
.text$x:00002C02                 jmp     ??1?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QAE@XZ ; std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>>::~basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>>(void)
.text$x:00002C02 __unwindfunclet$?BuildMenuFileName@@YA?AV?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@HIABV12@@Z$0 endp
.text$x:00002C02
.text$x:00002C07
.text$x:00002C07 ; =============== S U B R O U T I N E =======================================
.text$x:00002C07
.text$x:00002C07
.text$x:00002C07 __unwindfunclet$?BuildMenuFileName@@YA?AV?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@HIABV12@@Z$1 proc near
.text$x:00002C07                                         ; DATA XREF: .xdata$x:0000E104o
.text$x:00002C07                 lea     ecx, [ebp-9Ch]
.text$x:00002C0D                 jmp     ??1?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QAE@XZ ; std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>>::~basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>>(void)
.text$x:00002C0D __unwindfunclet$?BuildMenuFileName@@YA?AV?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@HIABV12@@Z$1 endp
.text$x:00002C0D
.text$x:00002C12
.text$x:00002C12 ; =============== S U B R O U T I N E =======================================
.text$x:00002C12
.text$x:00002C12
.text$x:00002C12 __unwindfunclet$?BuildMenuFileName@@YA?AV?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@HIABV12@@Z$2 proc near
.text$x:00002C12                                         ; DATA XREF: .xdata$x:0000E10Co
.text$x:00002C12                 lea     ecx, [ebp-148h]
.text$x:00002C18                 jmp     ??1?$vector@_WV?$allocator@_W@std@@@std@@QAE@XZ ; std::vector<wchar_t,std::allocator<wchar_t>>::~vector<wchar_t,std::allocator<wchar_t>>(void)
.text$x:00002C18 __unwindfunclet$?BuildMenuFileName@@YA?AV?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@HIABV12@@Z$2 endp
.text$x:00002C18
.text$x:00002C1D
.text$x:00002C1D ; =============== S U B R O U T I N E =======================================
.text$x:00002C1D
.text$x:00002C1D
.text$x:00002C1D __unwindfunclet$?BuildMenuFileName@@YA?AV?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@HIABV12@@Z$3 proc near
.text$x:00002C1D                                         ; DATA XREF: .xdata$x:0000E114o
.text$x:00002C1D                 lea     ecx, [ebp-1B8h]
.text$x:00002C23                 jmp     ??1?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@_W@std@@@std@@@std@@QAE@XZ ; std::_Vector_iterator<std::_Vector_val<std::_Simple_types<wchar_t>>>::~_Vector_iterator<std::_Vector_val<std::_Simple_types<wchar_t>>>(void)
.text$x:00002C23 __unwindfunclet$?BuildMenuFileName@@YA?AV?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@HIABV12@@Z$3 endp
.text$x:00002C23
.text$x:00002C28
.text$x:00002C28 ; =============== S U B R O U T I N E =======================================
.text$x:00002C28
.text$x:00002C28
.text$x:00002C28 __unwindfunclet$?BuildMenuFileName@@YA?AV?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@HIABV12@@Z$4 proc near
.text$x:00002C28                                         ; DATA XREF: .xdata$x:0000E11Co
.text$x:00002C28                 mov     ecx, [ebp-170h]
.text$x:00002C2E                 jmp     ??1?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@_W@std@@@std@@@std@@QAE@XZ ; std::_Vector_iterator<std::_Vector_val<std::_Simple_types<wchar_t>>>::~_Vector_iterator<std::_Vector_val<std::_Simple_types<wchar_t>>>(void)
.text$x:00002C2E __unwindfunclet$?BuildMenuFileName@@YA?AV?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@HIABV12@@Z$4 endp
.text$x:00002C2E
.text$x:00002C33
.text$x:00002C33 ; =============== S U B R O U T I N E =======================================
.text$x:00002C33
.text$x:00002C33
.text$x:00002C33 __unwindfunclet$?BuildMenuFileName@@YA?AV?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@HIABV12@@Z$5 proc near
.text$x:00002C33                                         ; DATA XREF: .xdata$x:0000E124o
.text$x:00002C33                 mov     ecx, [ebp-160h]
.text$x:00002C39                 jmp     ??1?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@_W@std@@@std@@@std@@QAE@XZ ; std::_Vector_iterator<std::_Vector_val<std::_Simple_types<wchar_t>>>::~_Vector_iterator<std::_Vector_val<std::_Simple_types<wchar_t>>>(void)
.text$x:00002C39 __unwindfunclet$?BuildMenuFileName@@YA?AV?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@HIABV12@@Z$5 endp
.text$x:00002C39
.text$x:00002C3E
.text$x:00002C3E ; =============== S U B R O U T I N E =======================================
.text$x:00002C3E
.text$x:00002C3E
.text$x:00002C3E __unwindfunclet$?BuildMenuFileName@@YA?AV?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@HIABV12@@Z$6 proc near
.text$x:00002C3E                                         ; DATA XREF: .xdata$x:0000E12Co
.text$x:00002C3E                 lea     ecx, [ebp-0B8h]
.text$x:00002C44                 jmp     ??1?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QAE@XZ ; std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>>::~basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>>(void)
.text$x:00002C44 __unwindfunclet$?BuildMenuFileName@@YA?AV?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@HIABV12@@Z$6 endp
.text$x:00002C44
.text$x:00002C49
.text$x:00002C49 ; =============== S U B R O U T I N E =======================================
.text$x:00002C49
.text$x:00002C49
.text$x:00002C49 __unwindfunclet$?BuildMenuFileName@@YA?AV?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@HIABV12@@Z$7 proc near
.text$x:00002C49                                         ; DATA XREF: .xdata$x:0000E134o
.text$x:00002C49                 lea     ecx, [ebp-0D0h]
.text$x:00002C4F                 jmp     ??1?$_String_const_iterator@V?$_String_val@U?$_Simple_types@_W@std@@@std@@@std@@QAE@XZ ; std::_String_const_iterator<std::_String_val<std::_Simple_types<wchar_t>>>::~_String_const_iterator<std::_String_val<std::_Simple_types<wchar_t>>>(void)
.text$x:00002C4F __unwindfunclet$?BuildMenuFileName@@YA?AV?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@HIABV12@@Z$7 endp
.text$x:00002C4F
.text$x:00002C54
.text$x:00002C54 ; =============== S U B R O U T I N E =======================================
.text$x:00002C54
.text$x:00002C54
.text$x:00002C54 __unwindfunclet$?BuildMenuFileName@@YA?AV?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@HIABV12@@Z$8 proc near
.text$x:00002C54                                         ; DATA XREF: .xdata$x:0000E13Co
.text$x:00002C54                 lea     ecx, [ebp-194h]
.text$x:00002C5A                 jmp     ??1?$_String_const_iterator@V?$_String_val@U?$_Simple_types@_W@std@@@std@@@std@@QAE@XZ ; std::_String_const_iterator<std::_String_val<std::_Simple_types<wchar_t>>>::~_String_const_iterator<std::_String_val<std::_Simple_types<wchar_t>>>(void)
.text$x:00002C5A __unwindfunclet$?BuildMenuFileName@@YA?AV?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@HIABV12@@Z$8 endp
.text$x:00002C5A
.text$x:00002C5F
.text$x:00002C5F ; =============== S U B R O U T I N E =======================================
.text$x:00002C5F
.text$x:00002C5F
.text$x:00002C5F __unwindfunclet$?BuildMenuFileName@@YA?AV?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@HIABV12@@Z$9 proc near
.text$x:00002C5F                                         ; DATA XREF: .xdata$x:0000E144o
.text$x:00002C5F                 mov     ecx, [ebp-14Ch]
.text$x:00002C65                 jmp     ??1?$_String_const_iterator@V?$_String_val@U?$_Simple_types@_W@std@@@std@@@std@@QAE@XZ ; std::_String_const_iterator<std::_String_val<std::_Simple_types<wchar_t>>>::~_String_const_iterator<std::_String_val<std::_Simple_types<wchar_t>>>(void)
.text$x:00002C65 __unwindfunclet$?BuildMenuFileName@@YA?AV?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@HIABV12@@Z$9 endp
.text$x:00002C65
.text$x:00002C6A
.text$x:00002C6A ; =============== S U B R O U T I N E =======================================
.text$x:00002C6A
.text$x:00002C6A
.text$x:00002C6A __unwindfunclet$?BuildMenuFileName@@YA?AV?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@HIABV12@@Z$10 proc near
.text$x:00002C6A                                         ; DATA XREF: .xdata$x:0000E14Co
.text$x:00002C6A                 mov     ecx, [ebp-180h]
.text$x:00002C70                 jmp     ??1?$_String_const_iterator@V?$_String_val@U?$_Simple_types@_W@std@@@std@@@std@@QAE@XZ ; std::_String_const_iterator<std::_String_val<std::_Simple_types<wchar_t>>>::~_String_const_iterator<std::_String_val<std::_Simple_types<wchar_t>>>(void)
.text$x:00002C70 __unwindfunclet$?BuildMenuFileName@@YA?AV?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@HIABV12@@Z$10 endp
.text$x:00002C70
.text$x:00002C75
.text$x:00002C75 ; =============== S U B R O U T I N E =======================================
.text$x:00002C75
.text$x:00002C75
.text$x:00002C75 __unwindfunclet$?BuildMenuFileName@@YA?AV?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@HIABV12@@Z$11 proc near
.text$x:00002C75                                         ; DATA XREF: .xdata$x:0000E154o
.text$x:00002C75                 lea     ecx, [ebp-80h]
.text$x:00002C78                 jmp     ??1?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QAE@XZ ; std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>>::~basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>>(void)
.text$x:00002C78 __unwindfunclet$?BuildMenuFileName@@YA?AV?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@HIABV12@@Z$11 endp
.text$x:00002C78
.text$x:00002C7D
.text$x:00002C7D ; =============== S U B R O U T I N E =======================================
.text$x:00002C7D
.text$x:00002C7D
.text$x:00002C7D __unwindfunclet$?BuildMenuFileName@@YA?AV?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@HIABV12@@Z$12 proc near
.text$x:00002C7D                                         ; DATA XREF: .xdata$x:0000E15Co
.text$x:00002C7D                 lea     ecx, [ebp-1ACh]
.text$x:00002C83                 jmp     ??1?$_String_const_iterator@V?$_String_val@U?$_Simple_types@_W@std@@@std@@@std@@QAE@XZ ; std::_String_const_iterator<std::_String_val<std::_Simple_types<wchar_t>>>::~_String_const_iterator<std::_String_val<std::_Simple_types<wchar_t>>>(void)
.text$x:00002C83 __unwindfunclet$?BuildMenuFileName@@YA?AV?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@HIABV12@@Z$12 endp
.text$x:00002C83
.text$x:00002C88
.text$x:00002C88 ; =============== S U B R O U T I N E =======================================
.text$x:00002C88
.text$x:00002C88
.text$x:00002C88 __unwindfunclet$?BuildMenuFileName@@YA?AV?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@HIABV12@@Z$13 proc near
.text$x:00002C88                                         ; DATA XREF: .xdata$x:0000E164o
.text$x:00002C88                 mov     ecx, [ebp-154h]
.text$x:00002C8E                 jmp     ??1?$_String_const_iterator@V?$_String_val@U?$_Simple_types@_W@std@@@std@@@std@@QAE@XZ ; std::_String_const_iterator<std::_String_val<std::_Simple_types<wchar_t>>>::~_String_const_iterator<std::_String_val<std::_Simple_types<wchar_t>>>(void)
.text$x:00002C8E __unwindfunclet$?BuildMenuFileName@@YA?AV?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@HIABV12@@Z$13 endp
.text$x:00002C8E
.text$x:00002C93
.text$x:00002C93 ; =============== S U B R O U T I N E =======================================
.text$x:00002C93
.text$x:00002C93
.text$x:00002C93 __unwindfunclet$?BuildMenuFileName@@YA?AV?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@HIABV12@@Z$14 proc near
.text$x:00002C93                                         ; DATA XREF: .xdata$x:0000E16Co
.text$x:00002C93                 mov     ecx, [ebp-17Ch]
.text$x:00002C99                 jmp     ??1?$_String_const_iterator@V?$_String_val@U?$_Simple_types@_W@std@@@std@@@std@@QAE@XZ ; std::_String_const_iterator<std::_String_val<std::_Simple_types<wchar_t>>>::~_String_const_iterator<std::_String_val<std::_Simple_types<wchar_t>>>(void)
.text$x:00002C99 __unwindfunclet$?BuildMenuFileName@@YA?AV?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@HIABV12@@Z$14 endp
.text$x:00002C99
.text$x:00002C9E
.text$x:00002C9E ; =============== S U B R O U T I N E =======================================
.text$x:00002C9E
.text$x:00002C9E
.text$x:00002C9E __unwindfunclet$?BuildMenuFileName@@YA?AV?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@HIABV12@@Z$15 proc near
.text$x:00002C9E                                         ; DATA XREF: .xdata$x:0000E174o
.text$x:00002C9E                 lea     ecx, [ebp-64h]
.text$x:00002CA1                 jmp     ??1?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QAE@XZ ; std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>>::~basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>>(void)
.text$x:00002CA1 __unwindfunclet$?BuildMenuFileName@@YA?AV?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@HIABV12@@Z$15 endp
.text$x:00002CA1
.text$x:00002CA6
.text$x:00002CA6 ; =============== S U B R O U T I N E =======================================
.text$x:00002CA6
.text$x:00002CA6
.text$x:00002CA6 __unwindfunclet$?BuildMenuFileName@@YA?AV?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@HIABV12@@Z$16 proc near
.text$x:00002CA6                                         ; DATA XREF: .xdata$x:0000E17Co
.text$x:00002CA6                 mov     ecx, [ebp-174h]
.text$x:00002CAC                 jmp     ??1?$_String_const_iterator@V?$_String_val@U?$_Simple_types@_W@std@@@std@@@std@@QAE@XZ ; std::_String_const_iterator<std::_String_val<std::_Simple_types<wchar_t>>>::~_String_const_iterator<std::_String_val<std::_Simple_types<wchar_t>>>(void)
.text$x:00002CAC __unwindfunclet$?BuildMenuFileName@@YA?AV?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@HIABV12@@Z$16 endp
.text$x:00002CAC
.text$x:00002CB1
.text$x:00002CB1 ; =============== S U B R O U T I N E =======================================
.text$x:00002CB1
.text$x:00002CB1
.text$x:00002CB1 __unwindfunclet$?BuildMenuFileName@@YA?AV?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@HIABV12@@Z$17 proc near
.text$x:00002CB1                                         ; DATA XREF: .xdata$x:0000E184o
.text$x:00002CB1                                         ; .xdata$x:0000E194o
.text$x:00002CB1                 lea     ecx, [ebp-1A0h]
.text$x:00002CB7                 jmp     ??1?$_String_const_iterator@V?$_String_val@U?$_Simple_types@_W@std@@@std@@@std@@QAE@XZ ; std::_String_const_iterator<std::_String_val<std::_Simple_types<wchar_t>>>::~_String_const_iterator<std::_String_val<std::_Simple_types<wchar_t>>>(void)
.text$x:00002CB7 __unwindfunclet$?BuildMenuFileName@@YA?AV?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@HIABV12@@Z$17 endp
.text$x:00002CB7
.text$x:00002CBC
.text$x:00002CBC ; =============== S U B R O U T I N E =======================================
.text$x:00002CBC
.text$x:00002CBC
.text$x:00002CBC __unwindfunclet$?BuildMenuFileName@@YA?AV?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@HIABV12@@Z$18 proc near
.text$x:00002CBC                                         ; DATA XREF: .xdata$x:0000E18Co
.text$x:00002CBC                 mov     ecx, [ebp-184h]
.text$x:00002CC2                 jmp     ??1?$_String_const_iterator@V?$_String_val@U?$_Simple_types@_W@std@@@std@@@std@@QAE@XZ ; std::_String_const_iterator<std::_String_val<std::_Simple_types<wchar_t>>>::~_String_const_iterator<std::_String_val<std::_Simple_types<wchar_t>>>(void)
.text$x:00002CC2 __unwindfunclet$?BuildMenuFileName@@YA?AV?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@HIABV12@@Z$18 endp
.text$x:00002CC2
.text$x:00002CC7
.text$x:00002CC7 ; =============== S U B R O U T I N E =======================================
.text$x:00002CC7
.text$x:00002CC7
.text$x:00002CC7 __unwindfunclet$?BuildMenuFileName@@YA?AV?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@HIABV12@@Z$19 proc near
.text$x:00002CC7                                         ; DATA XREF: .xdata$x:0000E19Co
.text$x:00002CC7                 lea     ecx, [ebp-48h]
.text$x:00002CCA                 jmp     ??1?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QAE@XZ ; std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>>::~basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>>(void)
.text$x:00002CCA __unwindfunclet$?BuildMenuFileName@@YA?AV?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@HIABV12@@Z$19 endp
.text$x:00002CCA
.text$x:00002CCF
.text$x:00002CCF ; =============== S U B R O U T I N E =======================================
.text$x:00002CCF
.text$x:00002CCF
.text$x:00002CCF __unwindfunclet$?BuildMenuFileName@@YA?AV?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@HIABV12@@Z$20 proc near
.text$x:00002CCF                                         ; DATA XREF: .xdata$x:0000E0F4o
.text$x:00002CCF                 mov     eax, [ebp-0C4h]
.text$x:00002CD5                 and     eax, 1
.text$x:00002CD8                 jz      locret_2CED
.text$x:00002CDE                 and     dword ptr [ebp-0C4h], 0FFFFFFFEh
.text$x:00002CE5                 mov     ecx, [ebp+8]
.text$x:00002CE8                 jmp     ??1?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QAE@XZ ; std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>>::~basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>>(void)
.text$x:00002CED ; ---------------------------------------------------------------------------
.text$x:00002CED
.text$x:00002CED locret_2CED:                            ; CODE XREF: __unwindfunclet$?BuildMenuFileName@@YA?AV?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@HIABV12@@Z$20+9j
.text$x:00002CED                 retn
.text$x:00002CED __unwindfunclet$?BuildMenuFileName@@YA?AV?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@HIABV12@@Z$20 endp
.text$x:00002CED
.text$x:00002CEE
.text$x:00002CEE ; =============== S U B R O U T I N E =======================================
.text$x:00002CEE
.text$x:00002CEE
.text$x:00002CEE __ehhandler$?BuildMenuFileName@@YA?AV?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@HIABV12@@Z proc near
.text$x:00002CEE                                         ; DATA XREF: BuildMenuFileName(int,uint,std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>> const &)+5o
.text$x:00002CEE
.text$x:00002CEE arg_4           = dword ptr  8
.text$x:00002CEE
.text$x:00002CEE                 mov     edx, [esp+arg_4]
.text$x:00002CF2                 lea     eax, [edx+0Ch]
.text$x:00002CF5                 mov     ecx, [edx-1B4h]
.text$x:00002CFB                 xor     ecx, eax
.text$x:00002CFD                 call    @__security_check_cookie@4 ; __security_check_cookie(x)
.text$x:00002D02                 mov     ecx, [edx-4]
.text$x:00002D05                 xor     ecx, eax
.text$x:00002D07                 call    @__security_check_cookie@4 ; __security_check_cookie(x)
.text$x:00002D0C                 mov     eax, offset __ehfuncinfo$?BuildMenuFileName@@YA?AV?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@HIABV12@@Z
.text$x:00002D11                 jmp     ___CxxFrameHandler3
.text$x:00002D11 __ehhandler$?BuildMenuFileName@@YA?AV?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@HIABV12@@Z endp
.text$x:00002D11
.text$x:00002D16
.text$x:00002D16 ; =============== S U B R O U T I N E =======================================
.text$x:00002D16
.text$x:00002D16
.text$x:00002D16 __unwindfunclet$?getFileContent@@YA?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@PB_W@Z$0 proc near
.text$x:00002D16                                         ; DATA XREF: .xdata$x:0000DD84o
.text$x:00002D16                 lea     ecx, [ebp-42Ch]
.text$x:00002D1C                 jmp     ??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char>>::~basic_string<char,std::char_traits<char>,std::allocator<char>>(void)
.text$x:00002D1C __unwindfunclet$?getFileContent@@YA?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@PB_W@Z$0 endp
.text$x:00002D1C
.text$x:00002D21
.text$x:00002D21 ; =============== S U B R O U T I N E =======================================
.text$x:00002D21
.text$x:00002D21
.text$x:00002D21 __unwindfunclet$?getFileContent@@YA?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@PB_W@Z$1 proc near
.text$x:00002D21                                         ; DATA XREF: .xdata$x:0000DD7Co
.text$x:00002D21                 mov     eax, [ebp-438h]
.text$x:00002D27                 and     eax, 1
.text$x:00002D2A                 jz      locret_2D3F
.text$x:00002D30                 and     dword ptr [ebp-438h], 0FFFFFFFEh
.text$x:00002D37                 mov     ecx, [ebp+8]
.text$x:00002D3A                 jmp     ??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char>>::~basic_string<char,std::char_traits<char>,std::allocator<char>>(void)
.text$x:00002D3F ; ---------------------------------------------------------------------------
.text$x:00002D3F
.text$x:00002D3F locret_2D3F:                            ; CODE XREF: __unwindfunclet$?getFileContent@@YA?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@PB_W@Z$1+9j
.text$x:00002D3F                 retn
.text$x:00002D3F __unwindfunclet$?getFileContent@@YA?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@PB_W@Z$1 endp
.text$x:00002D3F
.text$x:00002D40
.text$x:00002D40 ; =============== S U B R O U T I N E =======================================
.text$x:00002D40
.text$x:00002D40
.text$x:00002D40 __ehhandler$?getFileContent@@YA?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@PB_W@Z proc near
.text$x:00002D40                                         ; DATA XREF: getFileContent(wchar_t const *)+5o
.text$x:00002D40
.text$x:00002D40 arg_4           = dword ptr  8
.text$x:00002D40
.text$x:00002D40                 mov     edx, [esp+arg_4]
.text$x:00002D44                 lea     eax, [edx+0Ch]
.text$x:00002D47                 mov     ecx, [edx-43Ch]
.text$x:00002D4D                 xor     ecx, eax
.text$x:00002D4F                 call    @__security_check_cookie@4 ; __security_check_cookie(x)
.text$x:00002D54                 mov     ecx, [edx-4]
.text$x:00002D57                 xor     ecx, eax
.text$x:00002D59                 call    @__security_check_cookie@4 ; __security_check_cookie(x)
.text$x:00002D5E                 mov     eax, offset __ehfuncinfo$?getFileContent@@YA?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@PB_W@Z
.text$x:00002D63                 jmp     ___CxxFrameHandler3
.text$x:00002D63 __ehhandler$?getFileContent@@YA?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@PB_W@Z endp
.text$x:00002D63
.text$x:00002D68
.text$x:00002D68 ; =============== S U B R O U T I N E =======================================
.text$x:00002D68
.text$x:00002D68
.text$x:00002D68 __unwindfunclet$?relativeFilePathToFullFilePath@@YA?AV?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@PB_W@Z$0 proc near
.text$x:00002D68                                         ; DATA XREF: .xdata$x:0000DD74o
.text$x:00002D68                 lea     ecx, [ebp-234h]
.text$x:00002D6E                 jmp     ??1?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QAE@XZ ; std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>>::~basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>>(void)
.text$x:00002D6E __unwindfunclet$?relativeFilePathToFullFilePath@@YA?AV?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@PB_W@Z$0 endp
.text$x:00002D6E
.text$x:00002D73
.text$x:00002D73 ; =============== S U B R O U T I N E =======================================
.text$x:00002D73
.text$x:00002D73
.text$x:00002D73 __unwindfunclet$?relativeFilePathToFullFilePath@@YA?AV?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@PB_W@Z$1 proc near
.text$x:00002D73                                         ; DATA XREF: .xdata$x:0000DD6Co
.text$x:00002D73                 mov     eax, [ebp-238h]
.text$x:00002D79                 and     eax, 1
.text$x:00002D7C                 jz      locret_2D91
.text$x:00002D82                 and     dword ptr [ebp-238h], 0FFFFFFFEh
.text$x:00002D89                 mov     ecx, [ebp+8]
.text$x:00002D8C                 jmp     ??1?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QAE@XZ ; std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>>::~basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>>(void)
.text$x:00002D91 ; ---------------------------------------------------------------------------
.text$x:00002D91
.text$x:00002D91 locret_2D91:                            ; CODE XREF: __unwindfunclet$?relativeFilePathToFullFilePath@@YA?AV?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@PB_W@Z$1+9j
.text$x:00002D91                 retn
.text$x:00002D91 __unwindfunclet$?relativeFilePathToFullFilePath@@YA?AV?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@PB_W@Z$1 endp
.text$x:00002D91
.text$x:00002D92
.text$x:00002D92 ; =============== S U B R O U T I N E =======================================
.text$x:00002D92
.text$x:00002D92
.text$x:00002D92 __ehhandler$?relativeFilePathToFullFilePath@@YA?AV?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@PB_W@Z proc near
.text$x:00002D92                                         ; DATA XREF: relativeFilePathToFullFilePath(wchar_t const *)+5o
.text$x:00002D92
.text$x:00002D92 arg_4           = dword ptr  8
.text$x:00002D92
.text$x:00002D92                 mov     edx, [esp+arg_4]
.text$x:00002D96                 lea     eax, [edx+0Ch]
.text$x:00002D99                 mov     ecx, [edx-234h]
.text$x:00002D9F                 xor     ecx, eax
.text$x:00002DA1                 call    @__security_check_cookie@4 ; __security_check_cookie(x)
.text$x:00002DA6                 mov     ecx, [edx-4]
.text$x:00002DA9                 xor     ecx, eax
.text$x:00002DAB                 call    @__security_check_cookie@4 ; __security_check_cookie(x)
.text$x:00002DB0                 mov     eax, offset __ehfuncinfo$?relativeFilePathToFullFilePath@@YA?AV?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@PB_W@Z
.text$x:00002DB5                 jmp     ___CxxFrameHandler3
.text$x:00002DB5 __ehhandler$?relativeFilePathToFullFilePath@@YA?AV?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@PB_W@Z endp
.text$x:00002DB5
.text$x:00002DBA
.text$x:00002DBA ; =============== S U B R O U T I N E =======================================
.text$x:00002DBA
.text$x:00002DBA
.text$x:00002DBA __unwindfunclet$?PathRemoveFileSpecW@@YA?AV?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@AAV12@@Z$0 proc near
.text$x:00002DBA                                         ; DATA XREF: .xdata$x:0000DD2Co
.text$x:00002DBA                 mov     eax, [ebp-14h]
.text$x:00002DBD                 and     eax, 1
.text$x:00002DC0                 jz      locret_2DD2
.text$x:00002DC6                 and     dword ptr [ebp-14h], 0FFFFFFFEh
.text$x:00002DCA                 mov     ecx, [ebp+8]
.text$x:00002DCD                 jmp     ??1?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QAE@XZ ; std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>>::~basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>>(void)
.text$x:00002DD2 ; ---------------------------------------------------------------------------
.text$x:00002DD2
.text$x:00002DD2 locret_2DD2:                            ; CODE XREF: __unwindfunclet$?PathRemoveFileSpecW@@YA?AV?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@AAV12@@Z$0+6j
.text$x:00002DD2                 retn
.text$x:00002DD2 __unwindfunclet$?PathRemoveFileSpecW@@YA?AV?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@AAV12@@Z$0 endp
.text$x:00002DD2
.text$x:00002DD3
.text$x:00002DD3 ; =============== S U B R O U T I N E =======================================
.text$x:00002DD3
.text$x:00002DD3
.text$x:00002DD3 __ehhandler$?PathRemoveFileSpecW@@YA?AV?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@AAV12@@Z proc near
.text$x:00002DD3                                         ; DATA XREF: PathRemoveFileSpecW(std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>> &)+5o
.text$x:00002DD3
.text$x:00002DD3 arg_4           = dword ptr  8
.text$x:00002DD3
.text$x:00002DD3                 mov     edx, [esp+arg_4]
.text$x:00002DD7                 lea     eax, [edx+0Ch]
.text$x:00002DDA                 mov     ecx, [edx-0Ch]
.text$x:00002DDD                 xor     ecx, eax
.text$x:00002DDF                 call    @__security_check_cookie@4 ; __security_check_cookie(x)
.text$x:00002DE4                 mov     eax, offset __ehfuncinfo$?PathRemoveFileSpecW@@YA?AV?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@AAV12@@Z
.text$x:00002DE9                 jmp     ___CxxFrameHandler3
.text$x:00002DE9 __ehhandler$?PathRemoveFileSpecW@@YA?AV?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@AAV12@@Z endp
.text$x:00002DE9
.text$x:00002DEE
.text$x:00002DEE ; =============== S U B R O U T I N E =======================================
.text$x:00002DEE
.text$x:00002DEE
.text$x:00002DEE __unwindfunclet$?PathAppendW@@YA?AV?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@AAV12@ABV12@@Z$0 proc near
.text$x:00002DEE                                         ; DATA XREF: .xdata$x:0000DD24o
.text$x:00002DEE                 mov     eax, [ebp-10h]
.text$x:00002DF1                 and     eax, 1
.text$x:00002DF4                 jz      locret_2E06
.text$x:00002DFA                 and     dword ptr [ebp-10h], 0FFFFFFFEh
.text$x:00002DFE                 mov     ecx, [ebp+8]
.text$x:00002E01                 jmp     ??1?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QAE@XZ ; std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>>::~basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>>(void)
.text$x:00002E06 ; ---------------------------------------------------------------------------
.text$x:00002E06
.text$x:00002E06 locret_2E06:                            ; CODE XREF: __unwindfunclet$?PathAppendW@@YA?AV?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@AAV12@ABV12@@Z$0+6j
.text$x:00002E06                 retn
.text$x:00002E06 __unwindfunclet$?PathAppendW@@YA?AV?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@AAV12@ABV12@@Z$0 endp
.text$x:00002E06
.text$x:00002E07
.text$x:00002E07 ; =============== S U B R O U T I N E =======================================
.text$x:00002E07
.text$x:00002E07
.text$x:00002E07 __ehhandler$?PathAppendW@@YA?AV?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@AAV12@ABV12@@Z proc near
.text$x:00002E07                                         ; DATA XREF: PathAppendW(std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>> &,std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>> const &)+5o
.text$x:00002E07
.text$x:00002E07 arg_4           = dword ptr  8
.text$x:00002E07
.text$x:00002E07                 mov     edx, [esp+arg_4]
.text$x:00002E0B                 lea     eax, [edx+0Ch]
.text$x:00002E0E                 mov     ecx, [edx-8]
.text$x:00002E11                 xor     ecx, eax
.text$x:00002E13                 call    @__security_check_cookie@4 ; __security_check_cookie(x)
.text$x:00002E18                 mov     eax, offset __ehfuncinfo$?PathAppendW@@YA?AV?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@AAV12@ABV12@@Z
.text$x:00002E1D                 jmp     ___CxxFrameHandler3
.text$x:00002E1D __ehhandler$?PathAppendW@@YA?AV?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@AAV12@ABV12@@Z endp
.text$x:00002E1D
.text$x:00002E22
.text$x:00002E22 ; =============== S U B R O U T I N E =======================================
.text$x:00002E22
.text$x:00002E22
.text$x:00002E22 __unwindfunclet$?stringToUpper@@YA?AV?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@V12@@Z$0 proc near
.text$x:00002E22                                         ; DATA XREF: .xdata$x:0000E0D4o
.text$x:00002E22                 lea     ecx, [ebp+0Ch]
.text$x:00002E25                 jmp     ??1?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QAE@XZ ; std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>>::~basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>>(void)
.text$x:00002E25 __unwindfunclet$?stringToUpper@@YA?AV?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@V12@@Z$0 endp
.text$x:00002E25
.text$x:00002E2A
.text$x:00002E2A ; =============== S U B R O U T I N E =======================================
.text$x:00002E2A
.text$x:00002E2A
.text$x:00002E2A __unwindfunclet$?stringToUpper@@YA?AV?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@V12@@Z$1 proc near
.text$x:00002E2A                                         ; DATA XREF: .xdata$x:0000E0DCo
.text$x:00002E2A                 mov     ecx, [ebp-20h]
.text$x:00002E2D                 jmp     ??1?$_String_iterator@V?$_String_val@U?$_Simple_types@_W@std@@@std@@@std@@QAE@XZ ; std::_String_iterator<std::_String_val<std::_Simple_types<wchar_t>>>::~_String_iterator<std::_String_val<std::_Simple_types<wchar_t>>>(void)
.text$x:00002E2D __unwindfunclet$?stringToUpper@@YA?AV?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@V12@@Z$1 endp
.text$x:00002E2D
.text$x:00002E32
.text$x:00002E32 ; =============== S U B R O U T I N E =======================================
.text$x:00002E32
.text$x:00002E32
.text$x:00002E32 __unwindfunclet$?stringToUpper@@YA?AV?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@V12@@Z$2 proc near
.text$x:00002E32                                         ; DATA XREF: .xdata$x:0000E0E4o
.text$x:00002E32                 mov     ecx, [ebp-28h]
.text$x:00002E35                 jmp     ??1?$_String_iterator@V?$_String_val@U?$_Simple_types@_W@std@@@std@@@std@@QAE@XZ ; std::_String_iterator<std::_String_val<std::_Simple_types<wchar_t>>>::~_String_iterator<std::_String_val<std::_Simple_types<wchar_t>>>(void)
.text$x:00002E35 __unwindfunclet$?stringToUpper@@YA?AV?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@V12@@Z$2 endp
.text$x:00002E35
.text$x:00002E3A
.text$x:00002E3A ; =============== S U B R O U T I N E =======================================
.text$x:00002E3A
.text$x:00002E3A
.text$x:00002E3A __unwindfunclet$?stringToUpper@@YA?AV?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@V12@@Z$3 proc near
.text$x:00002E3A                                         ; DATA XREF: .xdata$x:0000E0ECo
.text$x:00002E3A                 mov     ecx, [ebp-30h]
.text$x:00002E3D                 jmp     ??1?$_String_iterator@V?$_String_val@U?$_Simple_types@_W@std@@@std@@@std@@QAE@XZ ; std::_String_iterator<std::_String_val<std::_Simple_types<wchar_t>>>::~_String_iterator<std::_String_val<std::_Simple_types<wchar_t>>>(void)
.text$x:00002E3D __unwindfunclet$?stringToUpper@@YA?AV?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@V12@@Z$3 endp
.text$x:00002E3D
.text$x:00002E42
.text$x:00002E42 ; =============== S U B R O U T I N E =======================================
.text$x:00002E42
.text$x:00002E42
.text$x:00002E42 __unwindfunclet$?stringToUpper@@YA?AV?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@V12@@Z$5 proc near
.text$x:00002E42                                         ; DATA XREF: .xdata$x:0000E0CCo
.text$x:00002E42                 mov     eax, [ebp-10h]
.text$x:00002E45                 and     eax, 1
.text$x:00002E48                 jz      locret_2E5A
.text$x:00002E4E                 and     dword ptr [ebp-10h], 0FFFFFFFEh
.text$x:00002E52                 mov     ecx, [ebp+8]
.text$x:00002E55                 jmp     ??1?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QAE@XZ ; std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>>::~basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>>(void)
.text$x:00002E5A ; ---------------------------------------------------------------------------
.text$x:00002E5A
.text$x:00002E5A locret_2E5A:                            ; CODE XREF: __unwindfunclet$?stringToUpper@@YA?AV?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@V12@@Z$5+6j
.text$x:00002E5A                 retn
.text$x:00002E5A __unwindfunclet$?stringToUpper@@YA?AV?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@V12@@Z$5 endp
.text$x:00002E5A
.text$x:00002E5B
.text$x:00002E5B ; =============== S U B R O U T I N E =======================================
.text$x:00002E5B
.text$x:00002E5B
.text$x:00002E5B __ehhandler$?stringToUpper@@YA?AV?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@V12@@Z proc near
.text$x:00002E5B                                         ; DATA XREF: stringToUpper(std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>>)+5o
.text$x:00002E5B
.text$x:00002E5B arg_4           = dword ptr  8
.text$x:00002E5B
.text$x:00002E5B                 mov     edx, [esp+arg_4]
.text$x:00002E5F                 lea     eax, [edx+0Ch]
.text$x:00002E62                 mov     ecx, [edx-3Ch]
.text$x:00002E65                 xor     ecx, eax
.text$x:00002E67                 call    @__security_check_cookie@4 ; __security_check_cookie(x)
.text$x:00002E6C                 mov     eax, offset __ehfuncinfo$?stringToUpper@@YA?AV?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@V12@@Z
.text$x:00002E71                 jmp     ___CxxFrameHandler3
.text$x:00002E71 __ehhandler$?stringToUpper@@YA?AV?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@V12@@Z endp
.text$x:00002E71
.text$x:00002E76
.text$x:00002E76 ; =============== S U B R O U T I N E =======================================
.text$x:00002E76
.text$x:00002E76
.text$x:00002E76 __unwindfunclet$?stringReplace@@YA?AV?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@V12@ABV12@1@Z$0 proc near
.text$x:00002E76                                         ; DATA XREF: .xdata$x:0000DD64o
.text$x:00002E76                 lea     ecx, [ebp+0Ch]
.text$x:00002E79                 jmp     ??1?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QAE@XZ ; std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>>::~basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>>(void)
.text$x:00002E79 __unwindfunclet$?stringReplace@@YA?AV?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@V12@ABV12@1@Z$0 endp
.text$x:00002E79
.text$x:00002E7E
.text$x:00002E7E ; =============== S U B R O U T I N E =======================================
.text$x:00002E7E
.text$x:00002E7E
.text$x:00002E7E __unwindfunclet$?stringReplace@@YA?AV?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@V12@ABV12@1@Z$1 proc near
.text$x:00002E7E                                         ; DATA XREF: .xdata$x:0000DD5Co
.text$x:00002E7E                 mov     eax, [ebp-14h]
.text$x:00002E81                 and     eax, 1
.text$x:00002E84                 jz      locret_2E96
.text$x:00002E8A                 and     dword ptr [ebp-14h], 0FFFFFFFEh
.text$x:00002E8E                 mov     ecx, [ebp+8]
.text$x:00002E91                 jmp     ??1?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QAE@XZ ; std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>>::~basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>>(void)
.text$x:00002E96 ; ---------------------------------------------------------------------------
.text$x:00002E96
.text$x:00002E96 locret_2E96:                            ; CODE XREF: __unwindfunclet$?stringReplace@@YA?AV?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@V12@ABV12@1@Z$1+6j
.text$x:00002E96                 retn
.text$x:00002E96 __unwindfunclet$?stringReplace@@YA?AV?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@V12@ABV12@1@Z$1 endp
.text$x:00002E96
.text$x:00002E97
.text$x:00002E97 ; =============== S U B R O U T I N E =======================================
.text$x:00002E97
.text$x:00002E97
.text$x:00002E97 __ehhandler$?stringReplace@@YA?AV?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@V12@ABV12@1@Z proc near
.text$x:00002E97                                         ; DATA XREF: stringReplace(std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>>,std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>> const &,std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>> const &)+5o
.text$x:00002E97
.text$x:00002E97 arg_4           = dword ptr  8
.text$x:00002E97
.text$x:00002E97                 mov     edx, [esp+arg_4]
.text$x:00002E9B                 lea     eax, [edx+0Ch]
.text$x:00002E9E                 mov     ecx, [edx-0Ch]
.text$x:00002EA1                 xor     ecx, eax
.text$x:00002EA3                 call    @__security_check_cookie@4 ; __security_check_cookie(x)
.text$x:00002EA8                 mov     eax, offset __ehfuncinfo$?stringReplace@@YA?AV?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@V12@ABV12@1@Z
.text$x:00002EAD                 jmp     ___CxxFrameHandler3
.text$x:00002EAD __ehhandler$?stringReplace@@YA?AV?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@V12@ABV12@1@Z endp
.text$x:00002EAD
.text$x:00002EB2
.text$x:00002EB2 ; =============== S U B R O U T I N E =======================================
.text$x:00002EB2
.text$x:00002EB2
.text$x:00002EB2 __unwindfunclet$?stringSplit@@YA?AV?$vector@V?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@V?$allocator@V?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@@2@@std@@ABV?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@2@0@Z$0 proc near
.text$x:00002EB2                                         ; DATA XREF: .xdata$x:0000DDDCo
.text$x:00002EB2                 lea     ecx, [ebp-78h]
.text$x:00002EB5                 jmp     ??1?$vector@V?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@V?$allocator@V?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@@2@@std@@QAE@XZ ; std::vector<std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>>,std::allocator<std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>>>>::~vector<std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>>,std::allocator<std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>>>>(void)
.text$x:00002EB5 __unwindfunclet$?stringSplit@@YA?AV?$vector@V?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@V?$allocator@V?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@@2@@std@@ABV?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@2@0@Z$0 endp
.text$x:00002EB5
.text$x:00002EBA
.text$x:00002EBA ; =============== S U B R O U T I N E =======================================
.text$x:00002EBA
.text$x:00002EBA
.text$x:00002EBA __unwindfunclet$?stringSplit@@YA?AV?$vector@V?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@V?$allocator@V?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@@2@@std@@ABV?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@2@0@Z$1 proc near
.text$x:00002EBA                                         ; DATA XREF: .xdata$x:0000DDE4o
.text$x:00002EBA                 lea     ecx, [ebp-48h]
.text$x:00002EBD                 jmp     ??1?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QAE@XZ ; std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>>::~basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>>(void)
.text$x:00002EBD __unwindfunclet$?stringSplit@@YA?AV?$vector@V?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@V?$allocator@V?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@@2@@std@@ABV?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@2@0@Z$1 endp
.text$x:00002EBD
.text$x:00002EC2
.text$x:00002EC2 ; =============== S U B R O U T I N E =======================================
.text$x:00002EC2
.text$x:00002EC2
.text$x:00002EC2 __unwindfunclet$?stringSplit@@YA?AV?$vector@V?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@V?$allocator@V?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@@2@@std@@ABV?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@2@0@Z$2 proc near
.text$x:00002EC2                                         ; DATA XREF: .xdata$x:0000DDECo
.text$x:00002EC2                 lea     ecx, [ebp-2Ch]
.text$x:00002EC5                 jmp     ??1?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QAE@XZ ; std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>>::~basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>>(void)
.text$x:00002EC5 __unwindfunclet$?stringSplit@@YA?AV?$vector@V?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@V?$allocator@V?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@@2@@std@@ABV?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@2@0@Z$2 endp
.text$x:00002EC5
.text$x:00002ECA
.text$x:00002ECA ; =============== S U B R O U T I N E =======================================
.text$x:00002ECA
.text$x:00002ECA
.text$x:00002ECA __unwindfunclet$?stringSplit@@YA?AV?$vector@V?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@V?$allocator@V?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@@2@@std@@ABV?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@2@0@Z$3 proc near
.text$x:00002ECA                                         ; DATA XREF: .xdata$x:0000DDD4o
.text$x:00002ECA                 mov     eax, [ebp-54h]
.text$x:00002ECD                 and     eax, 1
.text$x:00002ED0                 jz      locret_2EE2
.text$x:00002ED6                 and     dword ptr [ebp-54h], 0FFFFFFFEh
.text$x:00002EDA                 mov     ecx, [ebp+8]
.text$x:00002EDD                 jmp     ??1?$vector@V?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@V?$allocator@V?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@@2@@std@@QAE@XZ ; std::vector<std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>>,std::allocator<std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>>>>::~vector<std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>>,std::allocator<std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>>>>(void)
.text$x:00002EE2 ; ---------------------------------------------------------------------------
.text$x:00002EE2
.text$x:00002EE2 locret_2EE2:                            ; CODE XREF: __unwindfunclet$?stringSplit@@YA?AV?$vector@V?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@V?$allocator@V?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@@2@@std@@ABV?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@2@0@Z$3+6j
.text$x:00002EE2                 retn
.text$x:00002EE2 __unwindfunclet$?stringSplit@@YA?AV?$vector@V?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@V?$allocator@V?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@@2@@std@@ABV?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@2@0@Z$3 endp
.text$x:00002EE2
.text$x:00002EE3
.text$x:00002EE3 ; =============== S U B R O U T I N E =======================================
.text$x:00002EE3
.text$x:00002EE3
.text$x:00002EE3 __ehhandler$?stringSplit@@YA?AV?$vector@V?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@V?$allocator@V?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@@2@@std@@ABV?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@2@0@Z proc near
.text$x:00002EE3                                         ; DATA XREF: stringSplit(std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>> const &,std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>> const &)+5o
.text$x:00002EE3
.text$x:00002EE3 arg_4           = dword ptr  8
.text$x:00002EE3
.text$x:00002EE3                 mov     edx, [esp+arg_4]
.text$x:00002EE7                 lea     eax, [edx+0Ch]
.text$x:00002EEA                 mov     ecx, [edx-70h]
.text$x:00002EED                 xor     ecx, eax
.text$x:00002EEF                 call    @__security_check_cookie@4 ; __security_check_cookie(x)
.text$x:00002EF4                 mov     ecx, [edx-4]
.text$x:00002EF7                 xor     ecx, eax
.text$x:00002EF9                 call    @__security_check_cookie@4 ; __security_check_cookie(x)
.text$x:00002EFE                 mov     eax, offset __ehfuncinfo$?stringSplit@@YA?AV?$vector@V?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@V?$allocator@V?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@@2@@std@@ABV?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@2@0@Z
.text$x:00002F03                 jmp     ___CxxFrameHandler3
.text$x:00002F03 __ehhandler$?stringSplit@@YA?AV?$vector@V?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@V?$allocator@V?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@@2@@std@@ABV?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@2@0@Z endp
.text$x:00002F03
.text$x:00002F08
.text$x:00002F08 ; =============== S U B R O U T I N E =======================================
.text$x:00002F08
.text$x:00002F08
.text$x:00002F08 __unwindfunclet$?stringJoin@@YA?AV?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@ABV?$vector@V?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@V?$allocator@V?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@@2@@2@ABV12@@Z$0 proc near
.text$x:00002F08                                         ; DATA XREF: .xdata$x:0000DD54o
.text$x:00002F08                 lea     ecx, [ebp-2Ch]
.text$x:00002F0B                 jmp     ??1?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QAE@XZ ; std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>>::~basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>>(void)
.text$x:00002F0B __unwindfunclet$?stringJoin@@YA?AV?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@ABV?$vector@V?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@V?$allocator@V?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@@2@@2@ABV12@@Z$0 endp
.text$x:00002F0B
.text$x:00002F10
.text$x:00002F10 ; =============== S U B R O U T I N E =======================================
.text$x:00002F10
.text$x:00002F10
.text$x:00002F10 __unwindfunclet$?stringJoin@@YA?AV?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@ABV?$vector@V?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@V?$allocator@V?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@@2@@2@ABV12@@Z$1 proc near
.text$x:00002F10                                         ; DATA XREF: .xdata$x:0000DD4Co
.text$x:00002F10                 mov     eax, [ebp-38h]
.text$x:00002F13                 and     eax, 1
.text$x:00002F16                 jz      locret_2F28
.text$x:00002F1C                 and     dword ptr [ebp-38h], 0FFFFFFFEh
.text$x:00002F20                 mov     ecx, [ebp+8]
.text$x:00002F23                 jmp     ??1?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QAE@XZ ; std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>>::~basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>>(void)
.text$x:00002F28 ; ---------------------------------------------------------------------------
.text$x:00002F28
.text$x:00002F28 locret_2F28:                            ; CODE XREF: __unwindfunclet$?stringJoin@@YA?AV?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@ABV?$vector@V?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@V?$allocator@V?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@@2@@2@ABV12@@Z$1+6j
.text$x:00002F28                 retn
.text$x:00002F28 __unwindfunclet$?stringJoin@@YA?AV?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@ABV?$vector@V?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@V?$allocator@V?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@@2@@2@ABV12@@Z$1 endp
.text$x:00002F28
.text$x:00002F29
.text$x:00002F29 ; =============== S U B R O U T I N E =======================================
.text$x:00002F29
.text$x:00002F29
.text$x:00002F29 __ehhandler$?stringJoin@@YA?AV?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@ABV?$vector@V?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@V?$allocator@V?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@@2@@2@ABV12@@Z proc near
.text$x:00002F29                                         ; DATA XREF: stringJoin(std::vector<std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>>,std::allocator<std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>>>> const &,std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>> const &)+5o
.text$x:00002F29
.text$x:00002F29 arg_4           = dword ptr  8
.text$x:00002F29
.text$x:00002F29                 mov     edx, [esp+arg_4]
.text$x:00002F2D                 lea     eax, [edx+0Ch]
.text$x:00002F30                 mov     ecx, [edx-30h]
.text$x:00002F33                 xor     ecx, eax
.text$x:00002F35                 call    @__security_check_cookie@4 ; __security_check_cookie(x)
.text$x:00002F3A                 mov     ecx, [edx-4]
.text$x:00002F3D                 xor     ecx, eax
.text$x:00002F3F                 call    @__security_check_cookie@4 ; __security_check_cookie(x)
.text$x:00002F44                 mov     eax, offset __ehfuncinfo$?stringJoin@@YA?AV?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@ABV?$vector@V?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@V?$allocator@V?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@@2@@2@ABV12@@Z
.text$x:00002F49                 jmp     ___CxxFrameHandler3
.text$x:00002F49 __ehhandler$?stringJoin@@YA?AV?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@ABV?$vector@V?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@V?$allocator@V?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@@2@@2@ABV12@@Z endp
.text$x:00002F49
.text$x:00002F4E
.text$x:00002F4E ; =============== S U B R O U T I N E =======================================
.text$x:00002F4E
.text$x:00002F4E
.text$x:00002F4E __unwindfunclet$?stringTakeWhileAdmissable@@YA?AV?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@ABV12@0@Z$0 proc near
.text$x:00002F4E                                         ; DATA XREF: .xdata$x:0000DD1Co
.text$x:00002F4E                 mov     eax, [ebp-10h]
.text$x:00002F51                 and     eax, 1
.text$x:00002F54                 jz      locret_2F66
.text$x:00002F5A                 and     dword ptr [ebp-10h], 0FFFFFFFEh
.text$x:00002F5E                 mov     ecx, [ebp+8]
.text$x:00002F61                 jmp     ??1?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QAE@XZ ; std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>>::~basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>>(void)
.text$x:00002F66 ; ---------------------------------------------------------------------------
.text$x:00002F66
.text$x:00002F66 locret_2F66:                            ; CODE XREF: __unwindfunclet$?stringTakeWhileAdmissable@@YA?AV?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@ABV12@0@Z$0+6j
.text$x:00002F66                 retn
.text$x:00002F66 __unwindfunclet$?stringTakeWhileAdmissable@@YA?AV?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@ABV12@0@Z$0 endp
.text$x:00002F66
.text$x:00002F67
.text$x:00002F67 ; =============== S U B R O U T I N E =======================================
.text$x:00002F67
.text$x:00002F67
.text$x:00002F67 __ehhandler$?stringTakeWhileAdmissable@@YA?AV?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@ABV12@0@Z proc near
.text$x:00002F67                                         ; DATA XREF: stringTakeWhileAdmissable(std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>> const &,std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>> const &)+5o
.text$x:00002F67
.text$x:00002F67 arg_4           = dword ptr  8
.text$x:00002F67
.text$x:00002F67                 mov     edx, [esp+arg_4]
.text$x:00002F6B                 lea     eax, [edx+0Ch]
.text$x:00002F6E                 mov     ecx, [edx-0Ch]
.text$x:00002F71                 xor     ecx, eax
.text$x:00002F73                 call    @__security_check_cookie@4 ; __security_check_cookie(x)
.text$x:00002F78                 mov     eax, offset __ehfuncinfo$?stringTakeWhileAdmissable@@YA?AV?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@ABV12@0@Z
.text$x:00002F7D                 jmp     ___CxxFrameHandler3
.text$x:00002F7D __ehhandler$?stringTakeWhileAdmissable@@YA?AV?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@ABV12@0@Z endp
.text$x:00002F7D
.text$x:00002F82
.text$x:00002F82 ; =============== S U B R O U T I N E =======================================
.text$x:00002F82
.text$x:00002F82
.text$x:00002F82 __unwindfunclet$?stodLocale@@YANABV?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@PAUlocaleinfo_struct@@PAI@Z$0 proc near
.text$x:00002F82                                         ; DATA XREF: .xdata$x:0000DD3Co
.text$x:00002F82                 mov     eax, [ebp-14h]
.text$x:00002F85                 push    eax             ; void *
.text$x:00002F86                 call    ??3@YAXPAX@Z    ; operator delete(void *)
.text$x:00002F8B                 pop     ecx
.text$x:00002F8C                 retn
.text$x:00002F8C __unwindfunclet$?stodLocale@@YANABV?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@PAUlocaleinfo_struct@@PAI@Z$0 endp
.text$x:00002F8C
.text$x:00002F8D
.text$x:00002F8D ; =============== S U B R O U T I N E =======================================
.text$x:00002F8D
.text$x:00002F8D
.text$x:00002F8D __unwindfunclet$?stodLocale@@YANABV?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@PAUlocaleinfo_struct@@PAI@Z$1 proc near
.text$x:00002F8D                                         ; DATA XREF: .xdata$x:0000DD44o
.text$x:00002F8D                 mov     eax, [ebp-1Ch]
.text$x:00002F90                 push    eax             ; void *
.text$x:00002F91                 call    ??3@YAXPAX@Z    ; operator delete(void *)
.text$x:00002F96                 pop     ecx
.text$x:00002F97                 retn
.text$x:00002F97 __unwindfunclet$?stodLocale@@YANABV?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@PAUlocaleinfo_struct@@PAI@Z$1 endp
.text$x:00002F97
.text$x:00002F98
.text$x:00002F98 ; =============== S U B R O U T I N E =======================================
.text$x:00002F98
.text$x:00002F98
.text$x:00002F98 __ehhandler$?stodLocale@@YANABV?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@PAUlocaleinfo_struct@@PAI@Z proc near
.text$x:00002F98                                         ; DATA XREF: stodLocale(std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>> const &,localeinfo_struct *,uint *)+5o
.text$x:00002F98
.text$x:00002F98 arg_4           = dword ptr  8
.text$x:00002F98
.text$x:00002F98                 mov     edx, [esp+arg_4]
.text$x:00002F9C                 lea     eax, [edx+0Ch]
.text$x:00002F9F                 mov     ecx, [edx-34h]
.text$x:00002FA2                 xor     ecx, eax
.text$x:00002FA4                 call    @__security_check_cookie@4 ; __security_check_cookie(x)
.text$x:00002FA9                 mov     eax, offset __ehfuncinfo$?stodLocale@@YANABV?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@PAUlocaleinfo_struct@@PAI@Z
.text$x:00002FAE                 jmp     ___CxxFrameHandler3
.text$x:00002FAE __ehhandler$?stodLocale@@YANABV?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@PAUlocaleinfo_struct@@PAI@Z endp
.text$x:00002FAE
.text$x:00002FB3
.text$x:00002FB3 ; =============== S U B R O U T I N E =======================================
.text$x:00002FB3
.text$x:00002FB3
.text$x:00002FB3 __unwindfunclet$?intToString@@YA?AV?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@H@Z$0 proc near
.text$x:00002FB3                                         ; DATA XREF: .xdata$x:0000E0ACo
.text$x:00002FB3                 lea     ecx, [ebp-5Ch]
.text$x:00002FB6                 jmp     ??1?$vector@_WV?$allocator@_W@std@@@std@@QAE@XZ ; std::vector<wchar_t,std::allocator<wchar_t>>::~vector<wchar_t,std::allocator<wchar_t>>(void)
.text$x:00002FB6 __unwindfunclet$?intToString@@YA?AV?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@H@Z$0 endp
.text$x:00002FB6
.text$x:00002FBB
.text$x:00002FBB ; =============== S U B R O U T I N E =======================================
.text$x:00002FBB
.text$x:00002FBB
.text$x:00002FBB __unwindfunclet$?intToString@@YA?AV?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@H@Z$1 proc near
.text$x:00002FBB                                         ; DATA XREF: .xdata$x:0000E0B4o
.text$x:00002FBB                 mov     ecx, [ebp-64h]
.text$x:00002FBE                 jmp     ??1?$reverse_iterator@V?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@_W@std@@@std@@@std@@@std@@QAE@XZ ; std::reverse_iterator<std::_Vector_iterator<std::_Vector_val<std::_Simple_types<wchar_t>>>>::~reverse_iterator<std::_Vector_iterator<std::_Vector_val<std::_Simple_types<wchar_t>>>>(void)
.text$x:00002FBE __unwindfunclet$?intToString@@YA?AV?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@H@Z$1 endp
.text$x:00002FBE
.text$x:00002FC3
.text$x:00002FC3 ; =============== S U B R O U T I N E =======================================
.text$x:00002FC3
.text$x:00002FC3
.text$x:00002FC3 __unwindfunclet$?intToString@@YA?AV?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@H@Z$2 proc near
.text$x:00002FC3                                         ; DATA XREF: .xdata$x:0000E0BCo
.text$x:00002FC3                 mov     ecx, [ebp-6Ch]
.text$x:00002FC6                 jmp     ??1?$reverse_iterator@V?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@_W@std@@@std@@@std@@@std@@QAE@XZ ; std::reverse_iterator<std::_Vector_iterator<std::_Vector_val<std::_Simple_types<wchar_t>>>>::~reverse_iterator<std::_Vector_iterator<std::_Vector_val<std::_Simple_types<wchar_t>>>>(void)
.text$x:00002FC6 __unwindfunclet$?intToString@@YA?AV?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@H@Z$2 endp
.text$x:00002FC6
.text$x:00002FCB
.text$x:00002FCB ; =============== S U B R O U T I N E =======================================
.text$x:00002FCB
.text$x:00002FCB
.text$x:00002FCB __unwindfunclet$?intToString@@YA?AV?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@H@Z$3 proc near
.text$x:00002FCB                                         ; DATA XREF: .xdata$x:0000E0C4o
.text$x:00002FCB                 lea     ecx, [ebp-2Ch]
.text$x:00002FCE                 jmp     ??1?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QAE@XZ ; std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>>::~basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>>(void)
.text$x:00002FCE __unwindfunclet$?intToString@@YA?AV?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@H@Z$3 endp
.text$x:00002FCE
.text$x:00002FD3
.text$x:00002FD3 ; =============== S U B R O U T I N E =======================================
.text$x:00002FD3
.text$x:00002FD3
.text$x:00002FD3 __unwindfunclet$?intToString@@YA?AV?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@H@Z$4 proc near
.text$x:00002FD3                                         ; DATA XREF: .xdata$x:0000E0A4o
.text$x:00002FD3                 mov     eax, [ebp-3Ch]
.text$x:00002FD6                 and     eax, 1
.text$x:00002FD9                 jz      locret_2FEB
.text$x:00002FDF                 and     dword ptr [ebp-3Ch], 0FFFFFFFEh
.text$x:00002FE3                 mov     ecx, [ebp+8]
.text$x:00002FE6                 jmp     ??1?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QAE@XZ ; std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>>::~basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>>(void)
.text$x:00002FEB ; ---------------------------------------------------------------------------
.text$x:00002FEB
.text$x:00002FEB locret_2FEB:                            ; CODE XREF: __unwindfunclet$?intToString@@YA?AV?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@H@Z$4+6j
.text$x:00002FEB                 retn
.text$x:00002FEB __unwindfunclet$?intToString@@YA?AV?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@H@Z$4 endp
.text$x:00002FEB
.text$x:00002FEC
.text$x:00002FEC ; =============== S U B R O U T I N E =======================================
.text$x:00002FEC
.text$x:00002FEC
.text$x:00002FEC __ehhandler$?intToString@@YA?AV?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@H@Z proc near
.text$x:00002FEC                                         ; DATA XREF: intToString(int)+5o
.text$x:00002FEC
.text$x:00002FEC arg_4           = dword ptr  8
.text$x:00002FEC
.text$x:00002FEC                 mov     edx, [esp+arg_4]
.text$x:00002FF0                 lea     eax, [edx+0Ch]
.text$x:00002FF3                 mov     ecx, [edx-64h]
.text$x:00002FF6                 xor     ecx, eax
.text$x:00002FF8                 call    @__security_check_cookie@4 ; __security_check_cookie(x)
.text$x:00002FFD                 mov     ecx, [edx-4]
.text$x:00003000                 xor     ecx, eax
.text$x:00003002                 call    @__security_check_cookie@4 ; __security_check_cookie(x)
.text$x:00003007                 mov     eax, offset __ehfuncinfo$?intToString@@YA?AV?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@H@Z
.text$x:0000300C                 jmp     ___CxxFrameHandler3
.text$x:0000300C __ehhandler$?intToString@@YA?AV?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@H@Z endp
.text$x:0000300C
.text$x:00003011
.text$x:00003011 ; =============== S U B R O U T I N E =======================================
.text$x:00003011
.text$x:00003011
.text$x:00003011 __unwindfunclet$?uintToString@@YA?AV?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@I@Z$0 proc near
.text$x:00003011                                         ; DATA XREF: .xdata$x:0000E084o
.text$x:00003011                 lea     ecx, [ebp-54h]
.text$x:00003014                 jmp     ??1?$vector@_WV?$allocator@_W@std@@@std@@QAE@XZ ; std::vector<wchar_t,std::allocator<wchar_t>>::~vector<wchar_t,std::allocator<wchar_t>>(void)
.text$x:00003014 __unwindfunclet$?uintToString@@YA?AV?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@I@Z$0 endp
.text$x:00003014
.text$x:00003019
.text$x:00003019 ; =============== S U B R O U T I N E =======================================
.text$x:00003019
.text$x:00003019
.text$x:00003019 __unwindfunclet$?uintToString@@YA?AV?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@I@Z$1 proc near
.text$x:00003019                                         ; DATA XREF: .xdata$x:0000E08Co
.text$x:00003019                 mov     ecx, [ebp-5Ch]
.text$x:0000301C                 jmp     ??1?$reverse_iterator@V?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@_W@std@@@std@@@std@@@std@@QAE@XZ ; std::reverse_iterator<std::_Vector_iterator<std::_Vector_val<std::_Simple_types<wchar_t>>>>::~reverse_iterator<std::_Vector_iterator<std::_Vector_val<std::_Simple_types<wchar_t>>>>(void)
.text$x:0000301C __unwindfunclet$?uintToString@@YA?AV?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@I@Z$1 endp
.text$x:0000301C
.text$x:00003021
.text$x:00003021 ; =============== S U B R O U T I N E =======================================
.text$x:00003021
.text$x:00003021
.text$x:00003021 __unwindfunclet$?uintToString@@YA?AV?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@I@Z$2 proc near
.text$x:00003021                                         ; DATA XREF: .xdata$x:0000E094o
.text$x:00003021                 mov     ecx, [ebp-64h]
.text$x:00003024                 jmp     ??1?$reverse_iterator@V?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@_W@std@@@std@@@std@@@std@@QAE@XZ ; std::reverse_iterator<std::_Vector_iterator<std::_Vector_val<std::_Simple_types<wchar_t>>>>::~reverse_iterator<std::_Vector_iterator<std::_Vector_val<std::_Simple_types<wchar_t>>>>(void)
.text$x:00003024 __unwindfunclet$?uintToString@@YA?AV?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@I@Z$2 endp
.text$x:00003024
.text$x:00003029
.text$x:00003029 ; =============== S U B R O U T I N E =======================================
.text$x:00003029
.text$x:00003029
.text$x:00003029 __unwindfunclet$?uintToString@@YA?AV?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@I@Z$3 proc near
.text$x:00003029                                         ; DATA XREF: .xdata$x:0000E09Co
.text$x:00003029                 lea     ecx, [ebp-2Ch]
.text$x:0000302C                 jmp     ??1?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QAE@XZ ; std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>>::~basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>>(void)
.text$x:0000302C __unwindfunclet$?uintToString@@YA?AV?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@I@Z$3 endp
.text$x:0000302C
.text$x:00003031
.text$x:00003031 ; =============== S U B R O U T I N E =======================================
.text$x:00003031
.text$x:00003031
.text$x:00003031 __unwindfunclet$?uintToString@@YA?AV?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@I@Z$4 proc near
.text$x:00003031                                         ; DATA XREF: .xdata$x:0000E07Co
.text$x:00003031                 mov     eax, [ebp-34h]
.text$x:00003034                 and     eax, 1
.text$x:00003037                 jz      locret_3049
.text$x:0000303D                 and     dword ptr [ebp-34h], 0FFFFFFFEh
.text$x:00003041                 mov     ecx, [ebp+8]
.text$x:00003044                 jmp     ??1?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QAE@XZ ; std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>>::~basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>>(void)
.text$x:00003049 ; ---------------------------------------------------------------------------
.text$x:00003049
.text$x:00003049 locret_3049:                            ; CODE XREF: __unwindfunclet$?uintToString@@YA?AV?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@I@Z$4+6j
.text$x:00003049                 retn
.text$x:00003049 __unwindfunclet$?uintToString@@YA?AV?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@I@Z$4 endp
.text$x:00003049
.text$x:0000304A
.text$x:0000304A ; =============== S U B R O U T I N E =======================================
.text$x:0000304A
.text$x:0000304A
.text$x:0000304A __ehhandler$?uintToString@@YA?AV?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@I@Z proc near
.text$x:0000304A                                         ; DATA XREF: uintToString(uint)+5o
.text$x:0000304A
.text$x:0000304A arg_4           = dword ptr  8
.text$x:0000304A
.text$x:0000304A                 mov     edx, [esp+arg_4]
.text$x:0000304E                 lea     eax, [edx+0Ch]
.text$x:00003051                 mov     ecx, [edx-5Ch]
.text$x:00003054                 xor     ecx, eax
.text$x:00003056                 call    @__security_check_cookie@4 ; __security_check_cookie(x)
.text$x:0000305B                 mov     ecx, [edx-4]
.text$x:0000305E                 xor     ecx, eax
.text$x:00003060                 call    @__security_check_cookie@4 ; __security_check_cookie(x)
.text$x:00003065                 mov     eax, offset __ehfuncinfo$?uintToString@@YA?AV?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@I@Z
.text$x:0000306A                 jmp     ___CxxFrameHandler3
.text$x:0000306A __ehhandler$?uintToString@@YA?AV?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@I@Z endp
.text$x:0000306A
.text$x:0000306A ; ---------------------------------------------------------------------------
.text$x:0000306F                 align 10h
.text$x:0000306F _text$x         ends
.text$x:0000306F
.text$mn:00003070 ; ===========================================================================
.text$mn:00003070
.text$mn:00003070 ; Segment type: Pure code
.text$mn:00003070 ; Segment permissions: Read/Execute
.text$mn:00003070 _text$mn        segment para public 'CODE' use32
.text$mn:00003070                 assume cs:_text$mn
.text$mn:00003070                 ;org 3070h
.text$mn:00003070 ; COMDAT (pick any)
.text$mn:00003070                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text$mn:00003070
.text$mn:00003070 ; =============== S U B R O U T I N E =======================================
.text$mn:00003070
.text$mn:00003070 ; Attributes: bp-based frame
.text$mn:00003070
.text$mn:00003070 ; public: __thiscall std::basic_string<wchar_t, struct std::char_traits<wchar_t>, class std::allocator<wchar_t>>::basic_string<wchar_t, struct std::char_traits<wchar_t>, class std::allocator<wchar_t>>(class std::reverse_iterator<class std::_Vector_iterator<class std::_Vector_val<struct std::_Simple_types<wchar_t>>>>, class std::reverse_iterator<class std::_Vector_iterator<class std::_Vector_val<struct std::_Simple_types<wchar_t>>>>)
.text$mn:00003070                 public ??$?0V?$reverse_iterator@V?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@_W@std@@@std@@@std@@@std@@X@?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QAE@V?$reverse_iterator@V?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@_W@std@@@std@@@std@@@1@0@Z
.text$mn:00003070 ??$?0V?$reverse_iterator@V?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@_W@std@@@std@@@std@@@std@@X@?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QAE@V?$reverse_iterator@V?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@_W@std@@@std@@@std@@@1@0@Z proc near
.text$mn:00003070                                         ; CODE XREF: intToString(int)+132p
.text$mn:00003070                                         ; uintToString(uint)+EBp
.text$mn:00003070
.text$mn:00003070 var_2C          = dword ptr -2Ch
.text$mn:00003070 var_28          = dword ptr -28h
.text$mn:00003070 var_24          = dword ptr -24h
.text$mn:00003070 var_20          = dword ptr -20h
.text$mn:00003070 var_1C          = dword ptr -1Ch
.text$mn:00003070 var_18          = dword ptr -18h
.text$mn:00003070 var_14          = dword ptr -14h
.text$mn:00003070 var_F           = byte ptr -0Fh
.text$mn:00003070 var_E           = byte ptr -0Eh
.text$mn:00003070 var_D           = byte ptr -0Dh
.text$mn:00003070 var_C           = dword ptr -0Ch
.text$mn:00003070 var_4           = dword ptr -4
.text$mn:00003070 arg_0           = byte ptr  8
.text$mn:00003070 arg_C           = byte ptr  14h
.text$mn:00003070
.text$mn:00003070                 push    ebp
.text$mn:00003071                 mov     ebp, esp
.text$mn:00003073                 push    0FFFFFFFFh
.text$mn:00003075                 push    offset __ehhandler$??$?0V?$reverse_iterator@V?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@_W@std@@@std@@@std@@@std@@X@?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QAE@V?$reverse_iterator@V?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@_W@std@@@std@@@std@@@1@0@Z
.text$mn:0000307A                 mov     eax, large fs:0
.text$mn:00003080                 push    eax
.text$mn:00003081                 sub     esp, 20h
.text$mn:00003084                 mov     eax, dword ptr ds:___security_cookie
.text$mn:00003089                 xor     eax, ebp
.text$mn:0000308B                 push    eax
.text$mn:0000308C                 lea     eax, [ebp+var_C]
.text$mn:0000308F                 mov     large fs:0, eax
.text$mn:00003095                 mov     [ebp+var_14], ecx
.text$mn:00003098                 mov     [ebp+var_4], 1
.text$mn:0000309F                 lea     ecx, [ebp+var_E]
.text$mn:000030A2                 call    ??0?$allocator@_W@std@@QAE@XZ ; std::allocator<wchar_t>::allocator<wchar_t>(void)
.text$mn:000030A7                 push    eax
.text$mn:000030A8                 mov     ecx, [ebp+var_14]
.text$mn:000030AB                 call    ??0?$_String_alloc@$0A@U?$_String_base_types@_WV?$allocator@_W@std@@@std@@@std@@QAE@ABV?$allocator@_W@1@@Z ; std::_String_alloc<0,std::_String_base_types<wchar_t,std::allocator<wchar_t>>>::_String_alloc<0,std::_String_base_types<wchar_t,std::allocator<wchar_t>>>(std::allocator<wchar_t> const &)
.text$mn:000030B0                 mov     byte ptr [ebp+var_4], 2
.text$mn:000030B4                 push    0
.text$mn:000030B6                 push    0
.text$mn:000030B8                 mov     ecx, [ebp+var_14]
.text$mn:000030BB                 call    ?_Tidy@?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QAEX_NI@Z ; std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>>::_Tidy(bool,uint)
.text$mn:000030C0                 lea     eax, [ebp+arg_0]
.text$mn:000030C3                 push    eax
.text$mn:000030C4                 lea     ecx, [ebp+var_F]
.text$mn:000030C7                 push    ecx
.text$mn:000030C8                 call    ??$_Iter_cat@V?$reverse_iterator@V?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@_W@std@@@std@@@std@@@std@@@std@@YA?AUrandom_access_iterator_tag@0@ABV?$reverse_iterator@V?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@_W@std@@@std@@@std@@@0@@Z ; std::_Iter_cat<std::reverse_iterator<std::_Vector_iterator<std::_Vector_val<std::_Simple_types<wchar_t>>>>>(std::reverse_iterator<std::_Vector_iterator<std::_Vector_val<std::_Simple_types<wchar_t>>>> const &)
.text$mn:000030CD                 add     esp, 8
.text$mn:000030D0                 mov     dl, [eax]
.text$mn:000030D2                 mov     [ebp+var_D], dl
.text$mn:000030D5                 movzx   eax, [ebp+var_D]
.text$mn:000030D9                 push    eax
.text$mn:000030DA                 sub     esp, 0Ch
.text$mn:000030DD                 mov     ecx, esp
.text$mn:000030DF                 mov     [ebp+var_20], esp
.text$mn:000030E2                 lea     edx, [ebp+arg_C]
.text$mn:000030E5                 push    edx             ; struct std::_Iterator_base12 *
.text$mn:000030E6                 call    ??0?$reverse_iterator@V?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@_W@std@@@std@@@std@@@std@@QAE@ABV01@@Z ; std::reverse_iterator<std::_Vector_iterator<std::_Vector_val<std::_Simple_types<wchar_t>>>>::reverse_iterator<std::_Vector_iterator<std::_Vector_val<std::_Simple_types<wchar_t>>>>(std::reverse_iterator<std::_Vector_iterator<std::_Vector_val<std::_Simple_types<wchar_t>>>> const &)
.text$mn:000030EB                 mov     [ebp+var_18], eax
.text$mn:000030EE                 mov     eax, [ebp+var_18]
.text$mn:000030F1                 mov     [ebp+var_24], eax
.text$mn:000030F4                 mov     byte ptr [ebp+var_4], 3
.text$mn:000030F8                 sub     esp, 0Ch
.text$mn:000030FB                 mov     ecx, esp
.text$mn:000030FD                 mov     [ebp+var_28], esp
.text$mn:00003100                 lea     edx, [ebp+arg_0]
.text$mn:00003103                 push    edx             ; struct std::_Iterator_base12 *
.text$mn:00003104                 call    ??0?$reverse_iterator@V?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@_W@std@@@std@@@std@@@std@@QAE@ABV01@@Z ; std::reverse_iterator<std::_Vector_iterator<std::_Vector_val<std::_Simple_types<wchar_t>>>>::reverse_iterator<std::_Vector_iterator<std::_Vector_val<std::_Simple_types<wchar_t>>>>(std::reverse_iterator<std::_Vector_iterator<std::_Vector_val<std::_Simple_types<wchar_t>>>> const &)
.text$mn:00003109                 mov     [ebp+var_1C], eax
.text$mn:0000310C                 mov     eax, [ebp+var_1C]
.text$mn:0000310F                 mov     [ebp+var_2C], eax
.text$mn:00003112                 mov     byte ptr [ebp+var_4], 4
.text$mn:00003116                 mov     byte ptr [ebp+var_4], 2
.text$mn:0000311A                 mov     ecx, [ebp+var_14]
.text$mn:0000311D                 call    ??$_Construct@V?$reverse_iterator@V?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@_W@std@@@std@@@std@@@std@@@?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QAEXV?$reverse_iterator@V?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@_W@std@@@std@@@std@@@1@0Uforward_iterator_tag@1@@Z ; std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>>::_Construct<std::reverse_iterator<std::_Vector_iterator<std::_Vector_val<std::_Simple_types<wchar_t>>>>>(std::reverse_iterator<std::_Vector_iterator<std::_Vector_val<std::_Simple_types<wchar_t>>>>,std::reverse_iterator<std::_Vector_iterator<std::_Vector_val<std::_Simple_types<wchar_t>>>>,std::forward_iterator_tag)
.text$mn:00003122                 mov     byte ptr [ebp+var_4], 0
.text$mn:00003126                 lea     ecx, [ebp+arg_0]
.text$mn:00003129                 call    ??1?$reverse_iterator@V?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@_W@std@@@std@@@std@@@std@@QAE@XZ ; std::reverse_iterator<std::_Vector_iterator<std::_Vector_val<std::_Simple_types<wchar_t>>>>::~reverse_iterator<std::_Vector_iterator<std::_Vector_val<std::_Simple_types<wchar_t>>>>(void)
.text$mn:0000312E                 mov     [ebp+var_4], 0FFFFFFFFh
.text$mn:00003135                 lea     ecx, [ebp+arg_C]
.text$mn:00003138                 call    ??1?$reverse_iterator@V?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@_W@std@@@std@@@std@@@std@@QAE@XZ ; std::reverse_iterator<std::_Vector_iterator<std::_Vector_val<std::_Simple_types<wchar_t>>>>::~reverse_iterator<std::_Vector_iterator<std::_Vector_val<std::_Simple_types<wchar_t>>>>(void)
.text$mn:0000313D                 mov     eax, [ebp+var_14]
.text$mn:00003140                 mov     ecx, [ebp+var_C]
.text$mn:00003143                 mov     large fs:0, ecx
.text$mn:0000314A                 pop     ecx
.text$mn:0000314B                 mov     esp, ebp
.text$mn:0000314D                 pop     ebp
.text$mn:0000314E                 retn    18h
.text$mn:0000314E ??$?0V?$reverse_iterator@V?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@_W@std@@@std@@@std@@@std@@X@?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QAE@V?$reverse_iterator@V?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@_W@std@@@std@@@std@@@1@0@Z endp
.text$mn:0000314E
.text$mn:0000314E ; ---------------------------------------------------------------------------
.text$mn:00003151                 align 4
.text$mn:00003151 _text$mn        ends
.text$mn:00003151
.text$x:00003154 ; ===========================================================================
.text$x:00003154
.text$x:00003154 ; Segment type: Pure code
.text$x:00003154 ; Segment permissions: Read/Execute
.text$x:00003154 _text$x         segment para public 'CODE' use32
.text$x:00003154                 assume cs:_text$x
.text$x:00003154                 ;org 3154h
.text$x:00003154 ; COMDAT (pick associative to section at 3070)
.text$x:00003154                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text$x:00003154
.text$x:00003154 ; =============== S U B R O U T I N E =======================================
.text$x:00003154
.text$x:00003154
.text$x:00003154 __unwindfunclet$??$?0V?$reverse_iterator@V?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@_W@std@@@std@@@std@@@std@@X@?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QAE@V?$reverse_iterator@V?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@_W@std@@@std@@@std@@@1@0@Z$0 proc near
.text$x:00003154                                         ; DATA XREF: .xdata$x:0000EB10o
.text$x:00003154                 lea     ecx, [ebp+14h]
.text$x:00003157                 jmp     ??1?$reverse_iterator@V?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@_W@std@@@std@@@std@@@std@@QAE@XZ ; std::reverse_iterator<std::_Vector_iterator<std::_Vector_val<std::_Simple_types<wchar_t>>>>::~reverse_iterator<std::_Vector_iterator<std::_Vector_val<std::_Simple_types<wchar_t>>>>(void)
.text$x:00003157 __unwindfunclet$??$?0V?$reverse_iterator@V?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@_W@std@@@std@@@std@@@std@@X@?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QAE@V?$reverse_iterator@V?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@_W@std@@@std@@@std@@@1@0@Z$0 endp
.text$x:00003157
.text$x:0000315C
.text$x:0000315C ; =============== S U B R O U T I N E =======================================
.text$x:0000315C
.text$x:0000315C
.text$x:0000315C __unwindfunclet$??$?0V?$reverse_iterator@V?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@_W@std@@@std@@@std@@@std@@X@?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QAE@V?$reverse_iterator@V?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@_W@std@@@std@@@std@@@1@0@Z$1 proc near
.text$x:0000315C                                         ; DATA XREF: .xdata$x:0000EB18o
.text$x:0000315C                 lea     ecx, [ebp+8]
.text$x:0000315F                 jmp     ??1?$reverse_iterator@V?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@_W@std@@@std@@@std@@@std@@QAE@XZ ; std::reverse_iterator<std::_Vector_iterator<std::_Vector_val<std::_Simple_types<wchar_t>>>>::~reverse_iterator<std::_Vector_iterator<std::_Vector_val<std::_Simple_types<wchar_t>>>>(void)
.text$x:0000315F __unwindfunclet$??$?0V?$reverse_iterator@V?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@_W@std@@@std@@@std@@@std@@X@?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QAE@V?$reverse_iterator@V?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@_W@std@@@std@@@std@@@1@0@Z$1 endp
.text$x:0000315F
.text$x:00003164
.text$x:00003164 ; =============== S U B R O U T I N E =======================================
.text$x:00003164
.text$x:00003164
.text$x:00003164 __unwindfunclet$??$?0V?$reverse_iterator@V?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@_W@std@@@std@@@std@@@std@@X@?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QAE@V?$reverse_iterator@V?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@_W@std@@@std@@@std@@@1@0@Z$2 proc near
.text$x:00003164                                         ; DATA XREF: .xdata$x:0000EB20o
.text$x:00003164                 mov     ecx, [ebp-14h]
.text$x:00003167                 jmp     ??1?$_String_alloc@$0A@U?$_String_base_types@_WV?$allocator@_W@std@@@std@@@std@@QAE@XZ ; std::_String_alloc<0,std::_String_base_types<wchar_t,std::allocator<wchar_t>>>::~_String_alloc<0,std::_String_base_types<wchar_t,std::allocator<wchar_t>>>(void)
.text$x:00003167 __unwindfunclet$??$?0V?$reverse_iterator@V?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@_W@std@@@std@@@std@@@std@@X@?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QAE@V?$reverse_iterator@V?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@_W@std@@@std@@@std@@@1@0@Z$2 endp
.text$x:00003167
.text$x:0000316C
.text$x:0000316C ; =============== S U B R O U T I N E =======================================
.text$x:0000316C
.text$x:0000316C
.text$x:0000316C __unwindfunclet$??$?0V?$reverse_iterator@V?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@_W@std@@@std@@@std@@@std@@X@?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QAE@V?$reverse_iterator@V?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@_W@std@@@std@@@std@@@1@0@Z$3 proc near
.text$x:0000316C                                         ; DATA XREF: .xdata$x:0000EB28o
.text$x:0000316C                 mov     ecx, [ebp-20h]
.text$x:0000316F                 jmp     ??1?$reverse_iterator@V?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@_W@std@@@std@@@std@@@std@@QAE@XZ ; std::reverse_iterator<std::_Vector_iterator<std::_Vector_val<std::_Simple_types<wchar_t>>>>::~reverse_iterator<std::_Vector_iterator<std::_Vector_val<std::_Simple_types<wchar_t>>>>(void)
.text$x:0000316F __unwindfunclet$??$?0V?$reverse_iterator@V?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@_W@std@@@std@@@std@@@std@@X@?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QAE@V?$reverse_iterator@V?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@_W@std@@@std@@@std@@@1@0@Z$3 endp
.text$x:0000316F
.text$x:00003174
.text$x:00003174 ; =============== S U B R O U T I N E =======================================
.text$x:00003174
.text$x:00003174
.text$x:00003174 __unwindfunclet$??$?0V?$reverse_iterator@V?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@_W@std@@@std@@@std@@@std@@X@?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QAE@V?$reverse_iterator@V?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@_W@std@@@std@@@std@@@1@0@Z$4 proc near
.text$x:00003174                                         ; DATA XREF: .xdata$x:0000EB30o
.text$x:00003174                 mov     ecx, [ebp-28h]
.text$x:00003177                 jmp     ??1?$reverse_iterator@V?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@_W@std@@@std@@@std@@@std@@QAE@XZ ; std::reverse_iterator<std::_Vector_iterator<std::_Vector_val<std::_Simple_types<wchar_t>>>>::~reverse_iterator<std::_Vector_iterator<std::_Vector_val<std::_Simple_types<wchar_t>>>>(void)
.text$x:00003177 __unwindfunclet$??$?0V?$reverse_iterator@V?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@_W@std@@@std@@@std@@@std@@X@?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QAE@V?$reverse_iterator@V?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@_W@std@@@std@@@std@@@1@0@Z$4 endp
.text$x:00003177
.text$x:0000317C
.text$x:0000317C ; =============== S U B R O U T I N E =======================================
.text$x:0000317C
.text$x:0000317C
.text$x:0000317C __ehhandler$??$?0V?$reverse_iterator@V?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@_W@std@@@std@@@std@@@std@@X@?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QAE@V?$reverse_iterator@V?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@_W@std@@@std@@@std@@@1@0@Z proc near
.text$x:0000317C                                         ; DATA XREF: std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>>::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>>(std::reverse_iterator<std::_Vector_iterator<std::_Vector_val<std::_Simple_types<wchar_t>>>>,std::reverse_iterator<std::_Vector_iterator<std::_Vector_val<std::_Simple_types<wchar_t>>>>)+5o
.text$x:0000317C
.text$x:0000317C arg_4           = dword ptr  8
.text$x:0000317C
.text$x:0000317C                 mov     edx, [esp+arg_4]
.text$x:00003180                 lea     eax, [edx+0Ch]
.text$x:00003183                 mov     ecx, [edx-24h]
.text$x:00003186                 xor     ecx, eax
.text$x:00003188                 call    @__security_check_cookie@4 ; __security_check_cookie(x)
.text$x:0000318D                 mov     eax, offset __ehfuncinfo$??$?0V?$reverse_iterator@V?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@_W@std@@@std@@@std@@@std@@X@?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QAE@V?$reverse_iterator@V?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@_W@std@@@std@@@std@@@1@0@Z
.text$x:00003192                 jmp     ___CxxFrameHandler3
.text$x:00003192 __ehhandler$??$?0V?$reverse_iterator@V?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@_W@std@@@std@@@std@@@std@@X@?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QAE@V?$reverse_iterator@V?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@_W@std@@@std@@@std@@@1@0@Z endp
.text$x:00003192
.text$x:00003192 ; ---------------------------------------------------------------------------
.text$x:00003197                 align 4
.text$x:00003197 _text$x         ends
.text$x:00003197
.text$mn:00003198 ; ===========================================================================
.text$mn:00003198
.text$mn:00003198 ; Segment type: Pure code
.text$mn:00003198 ; Segment permissions: Read/Execute
.text$mn:00003198 _text$mn        segment para public 'CODE' use32
.text$mn:00003198                 assume cs:_text$mn
.text$mn:00003198                 ;org 3198h
.text$mn:00003198 ; COMDAT (pick any)
.text$mn:00003198                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text$mn:00003198
.text$mn:00003198 ; =============== S U B R O U T I N E =======================================
.text$mn:00003198
.text$mn:00003198 ; Attributes: bp-based frame
.text$mn:00003198
.text$mn:00003198 ; bool __cdecl std::operator==<class std::_Vector_iterator<class std::_Vector_val<struct std::_Simple_types<wchar_t>>>, class std::_Vector_iterator<class std::_Vector_val<struct std::_Simple_types<wchar_t>>>>(class std::reverse_iterator<class std::_Vector_iterator<class std::_Vector_val<struct std::_Simple_types<wchar_t>>>> const &, class std::reverse_iterator<class std::_Vector_iterator<class std::_Vector_val<struct std::_Simple_types<wchar_t>>>> const &)
.text$mn:00003198                 public ??$?8V?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@_W@std@@@std@@@std@@V01@@std@@YA_NABV?$reverse_iterator@V?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@_W@std@@@std@@@std@@@0@0@Z
.text$mn:00003198 ??$?8V?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@_W@std@@@std@@@std@@V01@@std@@YA_NABV?$reverse_iterator@V?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@_W@std@@@std@@@std@@@0@0@Z proc near
.text$mn:00003198                                         ; CODE XREF: std::operator!=<std::_Vector_iterator<std::_Vector_val<std::_Simple_types<wchar_t>>>,std::_Vector_iterator<std::_Vector_val<std::_Simple_types<wchar_t>>>>(std::reverse_iterator<std::_Vector_iterator<std::_Vector_val<std::_Simple_types<wchar_t>>>> const &,std::reverse_iterator<std::_Vector_iterator<std::_Vector_val<std::_Simple_types<wchar_t>>>> const &)+Cp
.text$mn:00003198
.text$mn:00003198 arg_0           = dword ptr  8
.text$mn:00003198 arg_4           = dword ptr  0Ch
.text$mn:00003198
.text$mn:00003198                 push    ebp
.text$mn:00003199                 mov     ebp, esp
.text$mn:0000319B                 mov     eax, [ebp+arg_4]
.text$mn:0000319E                 push    eax
.text$mn:0000319F                 mov     ecx, [ebp+arg_0]
.text$mn:000031A2                 call    ??$_Equal@V?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@_W@std@@@std@@@std@@U?$iterator@Urandom_access_iterator_tag@std@@_WHPA_WAA_W@2@@?$_Revranit@V?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@_W@std@@@std@@@std@@U?$iterator@Urandom_access_iterator_tag@std@@_WHPA_WAA_W@2@@std@@QBE_NABV01@@Z ; std::_Revranit<std::_Vector_iterator<std::_Vector_val<std::_Simple_types<wchar_t>>>,std::iterator<std::random_access_iterator_tag,wchar_t,int,wchar_t *,wchar_t &>>::_Equal<std::_Vector_iterator<std::_Vector_val<std::_Simple_types<wchar_t>>>,std::iterator<std::random_access_iterator_tag,wchar_t,int,wchar_t *,wchar_t &>>(std::_Revranit<std::_Vector_iterator<std::_Vector_val<std::_Simple_types<wchar_t>>>,std::iterator<std::random_access_iterator_tag,wchar_t,int,wchar_t *,wchar_t &>> const &)
.text$mn:000031A7                 pop     ebp
.text$mn:000031A8                 retn
.text$mn:000031A8 ??$?8V?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@_W@std@@@std@@@std@@V01@@std@@YA_NABV?$reverse_iterator@V?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@_W@std@@@std@@@std@@@0@0@Z endp
.text$mn:000031A8
.text$mn:000031A8 ; ---------------------------------------------------------------------------
.text$mn:000031A9                 align 4
.text$mn:000031A9 _text$mn        ends
.text$mn:000031A9
.text$mn:000031AC ; ===========================================================================
.text$mn:000031AC
.text$mn:000031AC ; Segment type: Pure code
.text$mn:000031AC ; Segment permissions: Read/Execute
.text$mn:000031AC _text$mn        segment para public 'CODE' use32
.text$mn:000031AC                 assume cs:_text$mn
.text$mn:000031AC                 ;org 31ACh
.text$mn:000031AC ; COMDAT (pick any)
.text$mn:000031AC                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text$mn:000031AC
.text$mn:000031AC ; =============== S U B R O U T I N E =======================================
.text$mn:000031AC
.text$mn:000031AC ; Attributes: bp-based frame
.text$mn:000031AC
.text$mn:000031AC ; bool __cdecl std::operator==<class std::allocator<wchar_t>, class std::allocator<wchar_t>>(struct std::_Wrap_alloc<class std::allocator<wchar_t>> const &, struct std::_Wrap_alloc<class std::allocator<wchar_t>> const &)
.text$mn:000031AC                 public ??$?8V?$allocator@_W@std@@V01@@std@@YA_NABU?$_Wrap_alloc@V?$allocator@_W@std@@@0@0@Z
.text$mn:000031AC ??$?8V?$allocator@_W@std@@V01@@std@@YA_NABU?$_Wrap_alloc@V?$allocator@_W@std@@@0@0@Z proc near
.text$mn:000031AC                                         ; CODE XREF: std::operator!=<std::allocator<wchar_t>,std::allocator<wchar_t>>(std::_Wrap_alloc<std::allocator<wchar_t>> const &,std::_Wrap_alloc<std::allocator<wchar_t>> const &)+Cp
.text$mn:000031AC
.text$mn:000031AC var_2           = byte ptr -2
.text$mn:000031AC var_1           = byte ptr -1
.text$mn:000031AC arg_0           = dword ptr  8
.text$mn:000031AC arg_4           = dword ptr  0Ch
.text$mn:000031AC
.text$mn:000031AC                 push    ebp
.text$mn:000031AD                 mov     ebp, esp
.text$mn:000031AF                 push    ecx
.text$mn:000031B0                 mov     eax, [ebp+arg_4]
.text$mn:000031B3                 push    eax
.text$mn:000031B4                 lea     ecx, [ebp+var_1]
.text$mn:000031B7                 call    ??0?$allocator@_W@std@@QAE@ABV01@@Z ; std::allocator<wchar_t>::allocator<wchar_t>(std::allocator<wchar_t> const &)
.text$mn:000031BC                 push    eax
.text$mn:000031BD                 mov     ecx, [ebp+arg_0]
.text$mn:000031C0                 push    ecx
.text$mn:000031C1                 lea     ecx, [ebp+var_2]
.text$mn:000031C4                 call    ??0?$allocator@_W@std@@QAE@ABV01@@Z ; std::allocator<wchar_t>::allocator<wchar_t>(std::allocator<wchar_t> const &)
.text$mn:000031C9                 push    eax
.text$mn:000031CA                 call    ??$?8_W_W@std@@YA_NABV?$allocator@_W@0@0@Z ; std::operator==<wchar_t,wchar_t>(std::allocator<wchar_t> const &,std::allocator<wchar_t> const &)
.text$mn:000031CF                 add     esp, 8
.text$mn:000031D2                 mov     esp, ebp
.text$mn:000031D4                 pop     ebp
.text$mn:000031D5                 retn
.text$mn:000031D5 ??$?8V?$allocator@_W@std@@V01@@std@@YA_NABU?$_Wrap_alloc@V?$allocator@_W@std@@@0@0@Z endp
.text$mn:000031D5
.text$mn:000031D5 ; ---------------------------------------------------------------------------
.text$mn:000031D6                 align 4
.text$mn:000031D6 _text$mn        ends
.text$mn:000031D6
.text$mn:000031D8 ; ===========================================================================
.text$mn:000031D8
.text$mn:000031D8 ; Segment type: Pure code
.text$mn:000031D8 ; Segment permissions: Read/Execute
.text$mn:000031D8 _text$mn        segment para public 'CODE' use32
.text$mn:000031D8                 assume cs:_text$mn
.text$mn:000031D8                 ;org 31D8h
.text$mn:000031D8 ; COMDAT (pick any)
.text$mn:000031D8                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text$mn:000031D8
.text$mn:000031D8 ; =============== S U B R O U T I N E =======================================
.text$mn:000031D8
.text$mn:000031D8 ; Attributes: bp-based frame
.text$mn:000031D8
.text$mn:000031D8 ; int __cdecl std::operator==<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>>(int, wchar_t *Str)
.text$mn:000031D8                 public ??$?8_WU?$char_traits@_W@std@@V?$allocator@_W@1@@std@@YA_NABV?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@0@PB_W@Z
.text$mn:000031D8 ??$?8_WU?$char_traits@_W@std@@V?$allocator@_W@1@@std@@YA_NABV?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@0@PB_W@Z proc near
.text$mn:000031D8                                         ; CODE XREF: PathAppendW(std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>> &,std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>> const &)+33p
.text$mn:000031D8                                         ; PathAppendW(std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>> &,std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>> const &)+4Bp ...
.text$mn:000031D8
.text$mn:000031D8 var_4           = dword ptr -4
.text$mn:000031D8 arg_0           = dword ptr  8
.text$mn:000031D8 Str             = dword ptr  0Ch
.text$mn:000031D8
.text$mn:000031D8                 push    ebp
.text$mn:000031D9                 mov     ebp, esp
.text$mn:000031DB                 push    ecx
.text$mn:000031DC                 mov     eax, [ebp+Str]
.text$mn:000031DF                 push    eax             ; Str
.text$mn:000031E0                 mov     ecx, [ebp+arg_0]
.text$mn:000031E3                 call    ?compare@?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QBEHPB_W@Z ; std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>>::compare(wchar_t const *)
.text$mn:000031E8                 test    eax, eax
.text$mn:000031EA                 jnz     short loc_31F5
.text$mn:000031EC                 mov     [ebp+var_4], 1
.text$mn:000031F3                 jmp     short loc_31FC
.text$mn:000031F5 ; ---------------------------------------------------------------------------
.text$mn:000031F5
.text$mn:000031F5 loc_31F5:                               ; CODE XREF: std::operator==<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>>(std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>> const &,wchar_t const *)+12j
.text$mn:000031F5                 mov     [ebp+var_4], 0
.text$mn:000031FC
.text$mn:000031FC loc_31FC:                               ; CODE XREF: std::operator==<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>>(std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>> const &,wchar_t const *)+1Bj
.text$mn:000031FC                 mov     al, byte ptr [ebp+var_4]
.text$mn:000031FF                 mov     esp, ebp
.text$mn:00003201                 pop     ebp
.text$mn:00003202                 retn
.text$mn:00003202 ??$?8_WU?$char_traits@_W@std@@V?$allocator@_W@1@@std@@YA_NABV?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@0@PB_W@Z endp
.text$mn:00003202
.text$mn:00003202 ; ---------------------------------------------------------------------------
.text$mn:00003203                 align 4
.text$mn:00003203 _text$mn        ends
.text$mn:00003203
.text$mn:00003204 ; ===========================================================================
.text$mn:00003204
.text$mn:00003204 ; Segment type: Pure code
.text$mn:00003204 ; Segment permissions: Read/Execute
.text$mn:00003204 _text$mn        segment para public 'CODE' use32
.text$mn:00003204                 assume cs:_text$mn
.text$mn:00003204                 ;org 3204h
.text$mn:00003204 ; COMDAT (pick any)
.text$mn:00003204                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text$mn:00003204
.text$mn:00003204 ; =============== S U B R O U T I N E =======================================
.text$mn:00003204
.text$mn:00003204 ; Attributes: bp-based frame
.text$mn:00003204
.text$mn:00003204 ; bool __cdecl std::operator==<wchar_t, wchar_t>(class std::allocator<wchar_t> const &, class std::allocator<wchar_t> const &)
.text$mn:00003204                 public ??$?8_W_W@std@@YA_NABV?$allocator@_W@0@0@Z
.text$mn:00003204 ??$?8_W_W@std@@YA_NABV?$allocator@_W@0@0@Z proc near
.text$mn:00003204                                         ; CODE XREF: std::operator==<std::allocator<wchar_t>,std::allocator<wchar_t>>(std::_Wrap_alloc<std::allocator<wchar_t>> const &,std::_Wrap_alloc<std::allocator<wchar_t>> const &)+1Ep
.text$mn:00003204                 push    ebp
.text$mn:00003205                 mov     ebp, esp
.text$mn:00003207                 mov     al, 1
.text$mn:00003209                 pop     ebp
.text$mn:0000320A                 retn
.text$mn:0000320A ??$?8_W_W@std@@YA_NABV?$allocator@_W@0@0@Z endp
.text$mn:0000320A
.text$mn:0000320A ; ---------------------------------------------------------------------------
.text$mn:0000320B                 align 4
.text$mn:0000320B _text$mn        ends
.text$mn:0000320B
.text$mn:0000320C ; ===========================================================================
.text$mn:0000320C
.text$mn:0000320C ; Segment type: Pure code
.text$mn:0000320C ; Segment permissions: Read/Execute
.text$mn:0000320C _text$mn        segment para public 'CODE' use32
.text$mn:0000320C                 assume cs:_text$mn
.text$mn:0000320C                 ;org 320Ch
.text$mn:0000320C ; COMDAT (pick any)
.text$mn:0000320C                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text$mn:0000320C
.text$mn:0000320C ; =============== S U B R O U T I N E =======================================
.text$mn:0000320C
.text$mn:0000320C ; Attributes: bp-based frame
.text$mn:0000320C
.text$mn:0000320C ; bool __cdecl std::operator!=<class std::_Vector_iterator<class std::_Vector_val<struct std::_Simple_types<wchar_t>>>, class std::_Vector_iterator<class std::_Vector_val<struct std::_Simple_types<wchar_t>>>>(class std::reverse_iterator<class std::_Vector_iterator<class std::_Vector_val<struct std::_Simple_types<wchar_t>>>> const &, class std::reverse_iterator<class std::_Vector_iterator<class std::_Vector_val<struct std::_Simple_types<wchar_t>>>> const &)
.text$mn:0000320C                 public ??$?9V?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@_W@std@@@std@@@std@@V01@@std@@YA_NABV?$reverse_iterator@V?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@_W@std@@@std@@@std@@@0@0@Z
.text$mn:0000320C ??$?9V?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@_W@std@@@std@@@std@@V01@@std@@YA_NABV?$reverse_iterator@V?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@_W@std@@@std@@@std@@@0@0@Z proc near
.text$mn:0000320C                                         ; CODE XREF: std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>>::_Construct<std::reverse_iterator<std::_Vector_iterator<std::_Vector_val<std::_Simple_types<wchar_t>>>>>(std::reverse_iterator<std::_Vector_iterator<std::_Vector_val<std::_Simple_types<wchar_t>>>>,std::reverse_iterator<std::_Vector_iterator<std::_Vector_val<std::_Simple_types<wchar_t>>>>,std::forward_iterator_tag)+FDp
.text$mn:0000320C                                         ; std::_Debug_range2<std::reverse_iterator<std::_Vector_iterator<std::_Vector_val<std::_Simple_types<wchar_t>>>>>(std::reverse_iterator<std::_Vector_iterator<std::_Vector_val<std::_Simple_types<wchar_t>>>>,std::reverse_iterator<std::_Vector_iterator<std::_Vector_val<std::_Simple_types<wchar_t>>>>,wchar_t const *,uint,std::random_access_iterator_tag)+31p ...
.text$mn:0000320C
.text$mn:0000320C var_4           = dword ptr -4
.text$mn:0000320C arg_0           = dword ptr  8
.text$mn:0000320C arg_4           = dword ptr  0Ch
.text$mn:0000320C
.text$mn:0000320C                 push    ebp
.text$mn:0000320D                 mov     ebp, esp
.text$mn:0000320F                 push    ecx
.text$mn:00003210                 mov     eax, [ebp+arg_4]
.text$mn:00003213                 push    eax
.text$mn:00003214                 mov     ecx, [ebp+arg_0]
.text$mn:00003217                 push    ecx
.text$mn:00003218                 call    ??$?8V?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@_W@std@@@std@@@std@@V01@@std@@YA_NABV?$reverse_iterator@V?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@_W@std@@@std@@@std@@@0@0@Z ; std::operator==<std::_Vector_iterator<std::_Vector_val<std::_Simple_types<wchar_t>>>,std::_Vector_iterator<std::_Vector_val<std::_Simple_types<wchar_t>>>>(std::reverse_iterator<std::_Vector_iterator<std::_Vector_val<std::_Simple_types<wchar_t>>>> const &,std::reverse_iterator<std::_Vector_iterator<std::_Vector_val<std::_Simple_types<wchar_t>>>> const &)
.text$mn:0000321D                 add     esp, 8
.text$mn:00003220                 movzx   edx, al
.text$mn:00003223                 test    edx, edx
.text$mn:00003225                 jnz     short loc_3230
.text$mn:00003227                 mov     [ebp+var_4], 1
.text$mn:0000322E                 jmp     short loc_3237
.text$mn:00003230 ; ---------------------------------------------------------------------------
.text$mn:00003230
.text$mn:00003230 loc_3230:                               ; CODE XREF: std::operator!=<std::_Vector_iterator<std::_Vector_val<std::_Simple_types<wchar_t>>>,std::_Vector_iterator<std::_Vector_val<std::_Simple_types<wchar_t>>>>(std::reverse_iterator<std::_Vector_iterator<std::_Vector_val<std::_Simple_types<wchar_t>>>> const &,std::reverse_iterator<std::_Vector_iterator<std::_Vector_val<std::_Simple_types<wchar_t>>>> const &)+19j
.text$mn:00003230                 mov     [ebp+var_4], 0
.text$mn:00003237
.text$mn:00003237 loc_3237:                               ; CODE XREF: std::operator!=<std::_Vector_iterator<std::_Vector_val<std::_Simple_types<wchar_t>>>,std::_Vector_iterator<std::_Vector_val<std::_Simple_types<wchar_t>>>>(std::reverse_iterator<std::_Vector_iterator<std::_Vector_val<std::_Simple_types<wchar_t>>>> const &,std::reverse_iterator<std::_Vector_iterator<std::_Vector_val<std::_Simple_types<wchar_t>>>> const &)+22j
.text$mn:00003237                 mov     al, byte ptr [ebp+var_4]
.text$mn:0000323A                 mov     esp, ebp
.text$mn:0000323C                 pop     ebp
.text$mn:0000323D                 retn
.text$mn:0000323D ??$?9V?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@_W@std@@@std@@@std@@V01@@std@@YA_NABV?$reverse_iterator@V?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@_W@std@@@std@@@std@@@0@0@Z endp
.text$mn:0000323D
.text$mn:0000323D ; ---------------------------------------------------------------------------
.text$mn:0000323E                 align 10h
.text$mn:0000323E _text$mn        ends
.text$mn:0000323E
.text$mn:00003240 ; ===========================================================================
.text$mn:00003240
.text$mn:00003240 ; Segment type: Pure code
.text$mn:00003240 ; Segment permissions: Read/Execute
.text$mn:00003240 _text$mn        segment para public 'CODE' use32
.text$mn:00003240                 assume cs:_text$mn
.text$mn:00003240                 ;org 3240h
.text$mn:00003240 ; COMDAT (pick any)
.text$mn:00003240                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text$mn:00003240
.text$mn:00003240 ; =============== S U B R O U T I N E =======================================
.text$mn:00003240
.text$mn:00003240 ; Attributes: bp-based frame
.text$mn:00003240
.text$mn:00003240 ; bool __cdecl std::operator!=<class std::allocator<wchar_t>, class std::allocator<wchar_t>>(struct std::_Wrap_alloc<class std::allocator<wchar_t>> const &, struct std::_Wrap_alloc<class std::allocator<wchar_t>> const &)
.text$mn:00003240                 public ??$?9V?$allocator@_W@std@@V01@@std@@YA_NABU?$_Wrap_alloc@V?$allocator@_W@std@@@0@0@Z
.text$mn:00003240 ??$?9V?$allocator@_W@std@@V01@@std@@YA_NABU?$_Wrap_alloc@V?$allocator@_W@std@@@0@0@Z proc near
.text$mn:00003240                                         ; CODE XREF: std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>>::operator=(std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>> const &)+2Bp
.text$mn:00003240
.text$mn:00003240 var_4           = dword ptr -4
.text$mn:00003240 arg_0           = dword ptr  8
.text$mn:00003240 arg_4           = dword ptr  0Ch
.text$mn:00003240
.text$mn:00003240                 push    ebp
.text$mn:00003241                 mov     ebp, esp
.text$mn:00003243                 push    ecx
.text$mn:00003244                 mov     eax, [ebp+arg_4]
.text$mn:00003247                 push    eax
.text$mn:00003248                 mov     ecx, [ebp+arg_0]
.text$mn:0000324B                 push    ecx
.text$mn:0000324C                 call    ??$?8V?$allocator@_W@std@@V01@@std@@YA_NABU?$_Wrap_alloc@V?$allocator@_W@std@@@0@0@Z ; std::operator==<std::allocator<wchar_t>,std::allocator<wchar_t>>(std::_Wrap_alloc<std::allocator<wchar_t>> const &,std::_Wrap_alloc<std::allocator<wchar_t>> const &)
.text$mn:00003251                 add     esp, 8
.text$mn:00003254                 movzx   edx, al
.text$mn:00003257                 test    edx, edx
.text$mn:00003259                 jnz     short loc_3264
.text$mn:0000325B                 mov     [ebp+var_4], 1
.text$mn:00003262                 jmp     short loc_326B
.text$mn:00003264 ; ---------------------------------------------------------------------------
.text$mn:00003264
.text$mn:00003264 loc_3264:                               ; CODE XREF: std::operator!=<std::allocator<wchar_t>,std::allocator<wchar_t>>(std::_Wrap_alloc<std::allocator<wchar_t>> const &,std::_Wrap_alloc<std::allocator<wchar_t>> const &)+19j
.text$mn:00003264                 mov     [ebp+var_4], 0
.text$mn:0000326B
.text$mn:0000326B loc_326B:                               ; CODE XREF: std::operator!=<std::allocator<wchar_t>,std::allocator<wchar_t>>(std::_Wrap_alloc<std::allocator<wchar_t>> const &,std::_Wrap_alloc<std::allocator<wchar_t>> const &)+22j
.text$mn:0000326B                 mov     al, byte ptr [ebp+var_4]
.text$mn:0000326E                 mov     esp, ebp
.text$mn:00003270                 pop     ebp
.text$mn:00003271                 retn
.text$mn:00003271 ??$?9V?$allocator@_W@std@@V01@@std@@YA_NABU?$_Wrap_alloc@V?$allocator@_W@std@@@0@0@Z endp
.text$mn:00003271
.text$mn:00003271 ; ---------------------------------------------------------------------------
.text$mn:00003272                 align 4
.text$mn:00003272 _text$mn        ends
.text$mn:00003272
.text$mn:00003274 ; ===========================================================================
.text$mn:00003274
.text$mn:00003274 ; Segment type: Pure code
.text$mn:00003274 ; Segment permissions: Read/Execute
.text$mn:00003274 _text$mn        segment para public 'CODE' use32
.text$mn:00003274                 assume cs:_text$mn
.text$mn:00003274                 ;org 3274h
.text$mn:00003274 ; COMDAT (pick any)
.text$mn:00003274                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text$mn:00003274
.text$mn:00003274 ; =============== S U B R O U T I N E =======================================
.text$mn:00003274
.text$mn:00003274 ; Attributes: bp-based frame
.text$mn:00003274
.text$mn:00003274 ; int __cdecl std::operator!=<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>>(int, wchar_t *Str)
.text$mn:00003274                 public ??$?9_WU?$char_traits@_W@std@@V?$allocator@_W@1@@std@@YA_NABV?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@0@PB_W@Z
.text$mn:00003274 ??$?9_WU?$char_traits@_W@std@@V?$allocator@_W@1@@std@@YA_NABV?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@0@PB_W@Z proc near
.text$mn:00003274                                         ; CODE XREF: PathAppendW(std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>> &,std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>> const &)+ACp
.text$mn:00003274                                         ; PathAppendW(std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>> &,std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>> const &)+110p ...
.text$mn:00003274
.text$mn:00003274 var_4           = dword ptr -4
.text$mn:00003274 arg_0           = dword ptr  8
.text$mn:00003274 Str             = dword ptr  0Ch
.text$mn:00003274
.text$mn:00003274                 push    ebp
.text$mn:00003275                 mov     ebp, esp
.text$mn:00003277                 push    ecx
.text$mn:00003278                 mov     eax, [ebp+Str]
.text$mn:0000327B                 push    eax             ; Str
.text$mn:0000327C                 mov     ecx, [ebp+arg_0]
.text$mn:0000327F                 push    ecx             ; int
.text$mn:00003280                 call    ??$?8_WU?$char_traits@_W@std@@V?$allocator@_W@1@@std@@YA_NABV?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@0@PB_W@Z ; std::operator==<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>>(std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>> const &,wchar_t const *)
.text$mn:00003285                 add     esp, 8
.text$mn:00003288                 movzx   edx, al
.text$mn:0000328B                 test    edx, edx
.text$mn:0000328D                 jnz     short loc_3298
.text$mn:0000328F                 mov     [ebp+var_4], 1
.text$mn:00003296                 jmp     short loc_329F
.text$mn:00003298 ; ---------------------------------------------------------------------------
.text$mn:00003298
.text$mn:00003298 loc_3298:                               ; CODE XREF: std::operator!=<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>>(std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>> const &,wchar_t const *)+19j
.text$mn:00003298                 mov     [ebp+var_4], 0
.text$mn:0000329F
.text$mn:0000329F loc_329F:                               ; CODE XREF: std::operator!=<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>>(std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>> const &,wchar_t const *)+22j
.text$mn:0000329F                 mov     al, byte ptr [ebp+var_4]
.text$mn:000032A2                 mov     esp, ebp
.text$mn:000032A4                 pop     ebp
.text$mn:000032A5                 retn
.text$mn:000032A5 ??$?9_WU?$char_traits@_W@std@@V?$allocator@_W@1@@std@@YA_NABV?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@0@PB_W@Z endp
.text$mn:000032A5
.text$mn:000032A5 ; ---------------------------------------------------------------------------
.text$mn:000032A6                 align 4
.text$mn:000032A6 _text$mn        ends
.text$mn:000032A6
.text$mn:000032A8 ; ===========================================================================
.text$mn:000032A8
.text$mn:000032A8 ; Segment type: Pure code
.text$mn:000032A8 ; Segment permissions: Read/Execute
.text$mn:000032A8 _text$mn        segment para public 'CODE' use32
.text$mn:000032A8                 assume cs:_text$mn
.text$mn:000032A8                 ;org 32A8h
.text$mn:000032A8 ; COMDAT (pick any)
.text$mn:000032A8                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text$mn:000032A8
.text$mn:000032A8 ; =============== S U B R O U T I N E =======================================
.text$mn:000032A8
.text$mn:000032A8 ; Attributes: bp-based frame
.text$mn:000032A8
.text$mn:000032A8 ; int __cdecl std::operator-<class std::_Vector_iterator<class std::_Vector_val<struct std::_Simple_types<wchar_t>>>, class std::_Vector_iterator<class std::_Vector_val<struct std::_Simple_types<wchar_t>>>>(class std::reverse_iterator<class std::_Vector_iterator<class std::_Vector_val<struct std::_Simple_types<wchar_t>>>> const &, class std::reverse_iterator<class std::_Vector_iterator<class std::_Vector_val<struct std::_Simple_types<wchar_t>>>> const &)
.text$mn:000032A8                 public ??$?GV?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@_W@std@@@std@@@std@@V01@@std@@YAHABV?$reverse_iterator@V?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@_W@std@@@std@@@std@@@0@0@Z
.text$mn:000032A8 ??$?GV?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@_W@std@@@std@@@std@@V01@@std@@YAHABV?$reverse_iterator@V?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@_W@std@@@std@@@std@@@0@0@Z proc near
.text$mn:000032A8                                         ; CODE XREF: std::_Distance2<std::reverse_iterator<std::_Vector_iterator<std::_Vector_val<std::_Simple_types<wchar_t>>>>,uint>(std::reverse_iterator<std::_Vector_iterator<std::_Vector_val<std::_Simple_types<wchar_t>>>>,std::reverse_iterator<std::_Vector_iterator<std::_Vector_val<std::_Simple_types<wchar_t>>>>,uint &,std::random_access_iterator_tag)+74p
.text$mn:000032A8
.text$mn:000032A8 var_38          = byte ptr -38h
.text$mn:000032A8 var_2C          = byte ptr -2Ch
.text$mn:000032A8 var_20          = dword ptr -20h
.text$mn:000032A8 var_1C          = dword ptr -1Ch
.text$mn:000032A8 var_18          = dword ptr -18h
.text$mn:000032A8 var_14          = dword ptr -14h
.text$mn:000032A8 var_10          = dword ptr -10h
.text$mn:000032A8 var_C           = dword ptr -0Ch
.text$mn:000032A8 var_4           = dword ptr -4
.text$mn:000032A8 arg_0           = dword ptr  8
.text$mn:000032A8 arg_4           = dword ptr  0Ch
.text$mn:000032A8
.text$mn:000032A8                 push    ebp
.text$mn:000032A9                 mov     ebp, esp
.text$mn:000032AB                 push    0FFFFFFFFh
.text$mn:000032AD                 push    offset __ehhandler$??$?GV?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@_W@std@@@std@@@std@@V01@@std@@YAHABV?$reverse_iterator@V?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@_W@std@@@std@@@std@@@0@0@Z
.text$mn:000032B2                 mov     eax, large fs:0
.text$mn:000032B8                 push    eax
.text$mn:000032B9                 sub     esp, 2Ch
.text$mn:000032BC                 mov     eax, dword ptr ds:___security_cookie
.text$mn:000032C1                 xor     eax, ebp
.text$mn:000032C3                 push    eax
.text$mn:000032C4                 lea     eax, [ebp+var_C]
.text$mn:000032C7                 mov     large fs:0, eax
.text$mn:000032CD                 lea     eax, [ebp+var_38]
.text$mn:000032D0                 push    eax
.text$mn:000032D1                 mov     ecx, [ebp+arg_0]
.text$mn:000032D4                 call    ?base@?$_Revranit@V?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@_W@std@@@std@@@std@@U?$iterator@Urandom_access_iterator_tag@std@@_WHPA_WAA_W@2@@std@@QBE?AV?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@_W@std@@@std@@@2@XZ ; std::_Revranit<std::_Vector_iterator<std::_Vector_val<std::_Simple_types<wchar_t>>>,std::iterator<std::random_access_iterator_tag,wchar_t,int,wchar_t *,wchar_t &>>::base(void)
.text$mn:000032D9                 mov     [ebp+var_10], eax
.text$mn:000032DC                 mov     ecx, [ebp+var_10]
.text$mn:000032DF                 mov     [ebp+var_14], ecx
.text$mn:000032E2                 mov     [ebp+var_4], 0
.text$mn:000032E9                 mov     edx, [ebp+var_14]
.text$mn:000032EC                 push    edx             ; std::_Iterator_base12 *
.text$mn:000032ED                 lea     eax, [ebp+var_2C]
.text$mn:000032F0                 push    eax
.text$mn:000032F1                 mov     ecx, [ebp+arg_4]
.text$mn:000032F4                 call    ?base@?$_Revranit@V?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@_W@std@@@std@@@std@@U?$iterator@Urandom_access_iterator_tag@std@@_WHPA_WAA_W@2@@std@@QBE?AV?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@_W@std@@@std@@@2@XZ ; std::_Revranit<std::_Vector_iterator<std::_Vector_val<std::_Simple_types<wchar_t>>>,std::iterator<std::random_access_iterator_tag,wchar_t,int,wchar_t *,wchar_t &>>::base(void)
.text$mn:000032F9                 mov     [ebp+var_18], eax
.text$mn:000032FC                 mov     ecx, [ebp+var_18]
.text$mn:000032FF                 mov     [ebp+var_1C], ecx
.text$mn:00003302                 mov     byte ptr [ebp+var_4], 1
.text$mn:00003306                 mov     ecx, [ebp+var_1C]
.text$mn:00003309                 call    ??G?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@_W@std@@@std@@@std@@QBEHABV?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@_W@std@@@std@@@1@@Z ; std::_Vector_iterator<std::_Vector_val<std::_Simple_types<wchar_t>>>::operator-(std::_Vector_const_iterator<std::_Vector_val<std::_Simple_types<wchar_t>>> const &)
.text$mn:0000330E                 mov     [ebp+var_20], eax
.text$mn:00003311                 mov     byte ptr [ebp+var_4], 0
.text$mn:00003315                 lea     ecx, [ebp+var_2C]
.text$mn:00003318                 call    ??1?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@_W@std@@@std@@@std@@QAE@XZ ; std::_Vector_iterator<std::_Vector_val<std::_Simple_types<wchar_t>>>::~_Vector_iterator<std::_Vector_val<std::_Simple_types<wchar_t>>>(void)
.text$mn:0000331D                 mov     [ebp+var_4], 0FFFFFFFFh
.text$mn:00003324                 lea     ecx, [ebp+var_38]
.text$mn:00003327                 call    ??1?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@_W@std@@@std@@@std@@QAE@XZ ; std::_Vector_iterator<std::_Vector_val<std::_Simple_types<wchar_t>>>::~_Vector_iterator<std::_Vector_val<std::_Simple_types<wchar_t>>>(void)
.text$mn:0000332C                 mov     eax, [ebp+var_20]
.text$mn:0000332F                 mov     ecx, [ebp+var_C]
.text$mn:00003332                 mov     large fs:0, ecx
.text$mn:00003339                 pop     ecx
.text$mn:0000333A                 mov     esp, ebp
.text$mn:0000333C                 pop     ebp
.text$mn:0000333D                 retn
.text$mn:0000333D ??$?GV?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@_W@std@@@std@@@std@@V01@@std@@YAHABV?$reverse_iterator@V?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@_W@std@@@std@@@std@@@0@0@Z endp
.text$mn:0000333D
.text$mn:0000333D ; ---------------------------------------------------------------------------
.text$mn:0000333E                 align 10h
.text$mn:0000333E _text$mn        ends
.text$mn:0000333E
.text$x:00003340 ; ===========================================================================
.text$x:00003340
.text$x:00003340 ; Segment type: Pure code
.text$x:00003340 ; Segment permissions: Read/Execute
.text$x:00003340 _text$x         segment para public 'CODE' use32
.text$x:00003340                 assume cs:_text$x
.text$x:00003340                 ;org 3340h
.text$x:00003340 ; COMDAT (pick associative to section at 32A8)
.text$x:00003340                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text$x:00003340
.text$x:00003340 ; =============== S U B R O U T I N E =======================================
.text$x:00003340
.text$x:00003340
.text$x:00003340 __unwindfunclet$??$?GV?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@_W@std@@@std@@@std@@V01@@std@@YAHABV?$reverse_iterator@V?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@_W@std@@@std@@@std@@@0@0@Z$0 proc near
.text$x:00003340                                         ; DATA XREF: .xdata$x:0000F1E4o
.text$x:00003340                 lea     ecx, [ebp-38h]
.text$x:00003343                 jmp     ??1?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@_W@std@@@std@@@std@@QAE@XZ ; std::_Vector_iterator<std::_Vector_val<std::_Simple_types<wchar_t>>>::~_Vector_iterator<std::_Vector_val<std::_Simple_types<wchar_t>>>(void)
.text$x:00003343 __unwindfunclet$??$?GV?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@_W@std@@@std@@@std@@V01@@std@@YAHABV?$reverse_iterator@V?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@_W@std@@@std@@@std@@@0@0@Z$0 endp
.text$x:00003343
.text$x:00003348
.text$x:00003348 ; =============== S U B R O U T I N E =======================================
.text$x:00003348
.text$x:00003348
.text$x:00003348 __unwindfunclet$??$?GV?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@_W@std@@@std@@@std@@V01@@std@@YAHABV?$reverse_iterator@V?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@_W@std@@@std@@@std@@@0@0@Z$1 proc near
.text$x:00003348                                         ; DATA XREF: .xdata$x:0000F1ECo
.text$x:00003348                 lea     ecx, [ebp-2Ch]
.text$x:0000334B                 jmp     ??1?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@_W@std@@@std@@@std@@QAE@XZ ; std::_Vector_iterator<std::_Vector_val<std::_Simple_types<wchar_t>>>::~_Vector_iterator<std::_Vector_val<std::_Simple_types<wchar_t>>>(void)
.text$x:0000334B __unwindfunclet$??$?GV?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@_W@std@@@std@@@std@@V01@@std@@YAHABV?$reverse_iterator@V?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@_W@std@@@std@@@std@@@0@0@Z$1 endp
.text$x:0000334B
.text$x:00003350
.text$x:00003350 ; =============== S U B R O U T I N E =======================================
.text$x:00003350
.text$x:00003350
.text$x:00003350 __ehhandler$??$?GV?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@_W@std@@@std@@@std@@V01@@std@@YAHABV?$reverse_iterator@V?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@_W@std@@@std@@@std@@@0@0@Z proc near
.text$x:00003350                                         ; DATA XREF: std::operator-<std::_Vector_iterator<std::_Vector_val<std::_Simple_types<wchar_t>>>,std::_Vector_iterator<std::_Vector_val<std::_Simple_types<wchar_t>>>>(std::reverse_iterator<std::_Vector_iterator<std::_Vector_val<std::_Simple_types<wchar_t>>>> const &,std::reverse_iterator<std::_Vector_iterator<std::_Vector_val<std::_Simple_types<wchar_t>>>> const &)+5o
.text$x:00003350
.text$x:00003350 arg_4           = dword ptr  8
.text$x:00003350
.text$x:00003350                 mov     edx, [esp+arg_4]
.text$x:00003354                 lea     eax, [edx+0Ch]
.text$x:00003357                 mov     ecx, [edx-30h]
.text$x:0000335A                 xor     ecx, eax
.text$x:0000335C                 call    @__security_check_cookie@4 ; __security_check_cookie(x)
.text$x:00003361                 mov     eax, offset __ehfuncinfo$??$?GV?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@_W@std@@@std@@@std@@V01@@std@@YAHABV?$reverse_iterator@V?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@_W@std@@@std@@@std@@@0@0@Z
.text$x:00003366                 jmp     ___CxxFrameHandler3
.text$x:00003366 __ehhandler$??$?GV?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@_W@std@@@std@@@std@@V01@@std@@YAHABV?$reverse_iterator@V?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@_W@std@@@std@@@std@@@0@0@Z endp
.text$x:00003366
.text$x:00003366 ; ---------------------------------------------------------------------------
.text$x:0000336B                 align 4
.text$x:0000336B _text$x         ends
.text$x:0000336B
.text$mn:0000336C ; ===========================================================================
.text$mn:0000336C
.text$mn:0000336C ; Segment type: Pure code
.text$mn:0000336C ; Segment permissions: Read/Execute
.text$mn:0000336C _text$mn        segment para public 'CODE' use32
.text$mn:0000336C                 assume cs:_text$mn
.text$mn:0000336C                 ;org 336Ch
.text$mn:0000336C ; COMDAT (pick any)
.text$mn:0000336C                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text$mn:0000336C
.text$mn:0000336C ; =============== S U B R O U T I N E =======================================
.text$mn:0000336C
.text$mn:0000336C ; Attributes: bp-based frame
.text$mn:0000336C
.text$mn:0000336C ; bool __cdecl std::operator<<class std::_Vector_iterator<class std::_Vector_val<struct std::_Simple_types<wchar_t>>>, class std::_Vector_iterator<class std::_Vector_val<struct std::_Simple_types<wchar_t>>>>(class std::reverse_iterator<class std::_Vector_iterator<class std::_Vector_val<struct std::_Simple_types<wchar_t>>>> const &, class std::reverse_iterator<class std::_Vector_iterator<class std::_Vector_val<struct std::_Simple_types<wchar_t>>>> const &)
.text$mn:0000336C                 public ??$?MV?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@_W@std@@@std@@@std@@V01@@std@@YA_NABV?$reverse_iterator@V?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@_W@std@@@std@@@std@@@0@0@Z
.text$mn:0000336C ??$?MV?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@_W@std@@@std@@@std@@V01@@std@@YA_NABV?$reverse_iterator@V?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@_W@std@@@std@@@std@@@0@0@Z proc near
.text$mn:0000336C                                         ; CODE XREF: std::_Debug_range2<std::reverse_iterator<std::_Vector_iterator<std::_Vector_val<std::_Simple_types<wchar_t>>>>>(std::reverse_iterator<std::_Vector_iterator<std::_Vector_val<std::_Simple_types<wchar_t>>>>,std::reverse_iterator<std::_Vector_iterator<std::_Vector_val<std::_Simple_types<wchar_t>>>>,wchar_t const *,uint,std::random_access_iterator_tag)+70p
.text$mn:0000336C
.text$mn:0000336C arg_0           = dword ptr  8
.text$mn:0000336C arg_4           = dword ptr  0Ch
.text$mn:0000336C
.text$mn:0000336C                 push    ebp
.text$mn:0000336D                 mov     ebp, esp
.text$mn:0000336F                 mov     eax, [ebp+arg_4]
.text$mn:00003372                 push    eax
.text$mn:00003373                 mov     ecx, [ebp+arg_0]
.text$mn:00003376                 call    ??$_Less@V?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@_W@std@@@std@@@std@@U?$iterator@Urandom_access_iterator_tag@std@@_WHPA_WAA_W@2@@?$_Revranit@V?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@_W@std@@@std@@@std@@U?$iterator@Urandom_access_iterator_tag@std@@_WHPA_WAA_W@2@@std@@QBE_NABV01@@Z ; std::_Revranit<std::_Vector_iterator<std::_Vector_val<std::_Simple_types<wchar_t>>>,std::iterator<std::random_access_iterator_tag,wchar_t,int,wchar_t *,wchar_t &>>::_Less<std::_Vector_iterator<std::_Vector_val<std::_Simple_types<wchar_t>>>,std::iterator<std::random_access_iterator_tag,wchar_t,int,wchar_t *,wchar_t &>>(std::_Revranit<std::_Vector_iterator<std::_Vector_val<std::_Simple_types<wchar_t>>>,std::iterator<std::random_access_iterator_tag,wchar_t,int,wchar_t *,wchar_t &>> const &)
.text$mn:0000337B                 pop     ebp
.text$mn:0000337C                 retn
.text$mn:0000337C ??$?MV?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@_W@std@@@std@@@std@@V01@@std@@YA_NABV?$reverse_iterator@V?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@_W@std@@@std@@@std@@@0@0@Z endp
.text$mn:0000337C
.text$mn:0000337C ; ---------------------------------------------------------------------------
.text$mn:0000337D                 align 10h
.text$mn:0000337D _text$mn        ends
.text$mn:0000337D
.text$mn:00003380 ; ===========================================================================
.text$mn:00003380
.text$mn:00003380 ; Segment type: Pure code
.text$mn:00003380 ; Segment permissions: Read/Execute
.text$mn:00003380 _text$mn        segment para public 'CODE' use32
.text$mn:00003380                 assume cs:_text$mn
.text$mn:00003380                 ;org 3380h
.text$mn:00003380 ; COMDAT (pick any)
.text$mn:00003380                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text$mn:00003380
.text$mn:00003380 ; =============== S U B R O U T I N E =======================================
.text$mn:00003380
.text$mn:00003380 ; Attributes: bp-based frame
.text$mn:00003380
.text$mn:00003380 ; char * __cdecl std::_Allocate<char>(unsigned int, char *)
.text$mn:00003380                 public ??$_Allocate@D@std@@YAPADIPAD@Z
.text$mn:00003380 ??$_Allocate@D@std@@YAPADIPAD@Z proc near
.text$mn:00003380                                         ; CODE XREF: std::allocator<char>::allocate(uint)+Dp
.text$mn:00003380
.text$mn:00003380 var_4           = dword ptr -4
.text$mn:00003380 arg_0           = dword ptr  8
.text$mn:00003380
.text$mn:00003380                 push    ebp
.text$mn:00003381                 mov     ebp, esp
.text$mn:00003383                 push    ecx
.text$mn:00003384                 mov     [ebp+var_4], 0
.text$mn:0000338B                 cmp     [ebp+arg_0], 0
.text$mn:0000338F                 jnz     short loc_3393
.text$mn:00003391                 jmp     short loc_33B3
.text$mn:00003393 ; ---------------------------------------------------------------------------
.text$mn:00003393
.text$mn:00003393 loc_3393:                               ; CODE XREF: std::_Allocate<char>(uint,char *)+Fj
.text$mn:00003393                 cmp     [ebp+arg_0], 0FFFFFFFFh
.text$mn:00003397                 ja      short loc_33AE
.text$mn:00003399                 mov     eax, [ebp+arg_0]
.text$mn:0000339C                 push    eax             ; unsigned int
.text$mn:0000339D                 call    ??2@YAPAXI@Z    ; operator new(uint)
.text$mn:000033A2                 add     esp, 4
.text$mn:000033A5                 mov     [ebp+var_4], eax
.text$mn:000033A8                 cmp     [ebp+var_4], 0
.text$mn:000033AC                 jnz     short loc_33B3
.text$mn:000033AE
.text$mn:000033AE loc_33AE:                               ; CODE XREF: std::_Allocate<char>(uint,char *)+17j
.text$mn:000033AE                 call    ?_Xbad_alloc@std@@YAXXZ ; std::_Xbad_alloc(void)
.text$mn:000033B3
.text$mn:000033B3 loc_33B3:                               ; CODE XREF: std::_Allocate<char>(uint,char *)+11j
.text$mn:000033B3                                         ; std::_Allocate<char>(uint,char *)+2Cj
.text$mn:000033B3                 mov     eax, [ebp+var_4]
.text$mn:000033B6                 mov     esp, ebp
.text$mn:000033B8                 pop     ebp
.text$mn:000033B9                 retn
.text$mn:000033B9 ??$_Allocate@D@std@@YAPADIPAD@Z endp
.text$mn:000033B9
.text$mn:000033B9 ; ---------------------------------------------------------------------------
.text$mn:000033BA                 align 4
.text$mn:000033BA _text$mn        ends
.text$mn:000033BA
.text$mn:000033BC ; ===========================================================================
.text$mn:000033BC
.text$mn:000033BC ; Segment type: Pure code
.text$mn:000033BC ; Segment permissions: Read/Execute
.text$mn:000033BC _text$mn        segment para public 'CODE' use32
.text$mn:000033BC                 assume cs:_text$mn
.text$mn:000033BC                 ;org 33BCh
.text$mn:000033BC ; COMDAT (pick any)
.text$mn:000033BC                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text$mn:000033BC
.text$mn:000033BC ; =============== S U B R O U T I N E =======================================
.text$mn:000033BC
.text$mn:000033BC ; Attributes: bp-based frame
.text$mn:000033BC
.text$mn:000033BC ; struct std::_Container_proxy * __cdecl std::_Allocate<struct std::_Container_proxy>(unsigned int, struct std::_Container_proxy *)
.text$mn:000033BC                 public ??$_Allocate@U_Container_proxy@std@@@std@@YAPAU_Container_proxy@0@IPAU10@@Z
.text$mn:000033BC ??$_Allocate@U_Container_proxy@std@@@std@@YAPAU_Container_proxy@0@IPAU10@@Z proc near
.text$mn:000033BC                                         ; CODE XREF: std::allocator<std::_Container_proxy>::allocate(uint)+Dp
.text$mn:000033BC
.text$mn:000033BC var_4           = dword ptr -4
.text$mn:000033BC arg_0           = dword ptr  8
.text$mn:000033BC
.text$mn:000033BC                 push    ebp
.text$mn:000033BD                 mov     ebp, esp
.text$mn:000033BF                 push    ecx
.text$mn:000033C0                 mov     [ebp+var_4], 0
.text$mn:000033C7                 cmp     [ebp+arg_0], 0
.text$mn:000033CB                 jnz     short loc_33CF
.text$mn:000033CD                 jmp     short loc_33F5
.text$mn:000033CF ; ---------------------------------------------------------------------------
.text$mn:000033CF
.text$mn:000033CF loc_33CF:                               ; CODE XREF: std::_Allocate<std::_Container_proxy>(uint,std::_Container_proxy *)+Fj
.text$mn:000033CF                 cmp     [ebp+arg_0], 1FFFFFFFh
.text$mn:000033D6                 ja      short loc_33F0
.text$mn:000033D8                 mov     eax, [ebp+arg_0]
.text$mn:000033DB                 shl     eax, 3
.text$mn:000033DE                 push    eax             ; unsigned int
.text$mn:000033DF                 call    ??2@YAPAXI@Z    ; operator new(uint)
.text$mn:000033E4                 add     esp, 4
.text$mn:000033E7                 mov     [ebp+var_4], eax
.text$mn:000033EA                 cmp     [ebp+var_4], 0
.text$mn:000033EE                 jnz     short loc_33F5
.text$mn:000033F0
.text$mn:000033F0 loc_33F0:                               ; CODE XREF: std::_Allocate<std::_Container_proxy>(uint,std::_Container_proxy *)+1Aj
.text$mn:000033F0                 call    ?_Xbad_alloc@std@@YAXXZ ; std::_Xbad_alloc(void)
.text$mn:000033F5
.text$mn:000033F5 loc_33F5:                               ; CODE XREF: std::_Allocate<std::_Container_proxy>(uint,std::_Container_proxy *)+11j
.text$mn:000033F5                                         ; std::_Allocate<std::_Container_proxy>(uint,std::_Container_proxy *)+32j
.text$mn:000033F5                 mov     eax, [ebp+var_4]
.text$mn:000033F8                 mov     esp, ebp
.text$mn:000033FA                 pop     ebp
.text$mn:000033FB                 retn
.text$mn:000033FB ??$_Allocate@U_Container_proxy@std@@@std@@YAPAU_Container_proxy@0@IPAU10@@Z endp
.text$mn:000033FB
.text$mn:000033FB _text$mn        ends
.text$mn:000033FB
.text$mn:000033FC ; ===========================================================================
.text$mn:000033FC
.text$mn:000033FC ; Segment type: Pure code
.text$mn:000033FC ; Segment permissions: Read/Execute
.text$mn:000033FC _text$mn        segment para public 'CODE' use32
.text$mn:000033FC                 assume cs:_text$mn
.text$mn:000033FC                 ;org 33FCh
.text$mn:000033FC ; COMDAT (pick any)
.text$mn:000033FC                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text$mn:000033FC
.text$mn:000033FC ; =============== S U B R O U T I N E =======================================
.text$mn:000033FC
.text$mn:000033FC ; Attributes: bp-based frame
.text$mn:000033FC
.text$mn:000033FC ; class std::basic_string<wchar_t, struct std::char_traits<wchar_t>, class std::allocator<wchar_t>> * __cdecl std::_Allocate<class std::basic_string<wchar_t, struct std::char_traits<wchar_t>, class std::allocator<wchar_t>>>(unsigned int, class std::basic_string<wchar_t, struct std::char_traits<wchar_t>, class std::allocator<wchar_t>> *)
.text$mn:000033FC                 public ??$_Allocate@V?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@@std@@YAPAV?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@0@IPAV10@@Z
.text$mn:000033FC ??$_Allocate@V?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@@std@@YAPAV?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@0@IPAV10@@Z proc near
.text$mn:000033FC                                         ; CODE XREF: std::allocator<std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>>>::allocate(uint)+Dp
.text$mn:000033FC
.text$mn:000033FC var_4           = dword ptr -4
.text$mn:000033FC arg_0           = dword ptr  8
.text$mn:000033FC
.text$mn:000033FC                 push    ebp
.text$mn:000033FD                 mov     ebp, esp
.text$mn:000033FF                 push    ecx
.text$mn:00003400                 mov     [ebp+var_4], 0
.text$mn:00003407                 cmp     [ebp+arg_0], 0
.text$mn:0000340B                 jnz     short loc_340F
.text$mn:0000340D                 jmp     short loc_3433
.text$mn:0000340F ; ---------------------------------------------------------------------------
.text$mn:0000340F
.text$mn:0000340F loc_340F:                               ; CODE XREF: std::_Allocate<std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>>>(uint,std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>> *)+Fj
.text$mn:0000340F                 cmp     [ebp+arg_0], 9249249h
.text$mn:00003416                 ja      short loc_342E
.text$mn:00003418                 imul    eax, [ebp+arg_0], 1Ch
.text$mn:0000341C                 push    eax             ; unsigned int
.text$mn:0000341D                 call    ??2@YAPAXI@Z    ; operator new(uint)
.text$mn:00003422                 add     esp, 4
.text$mn:00003425                 mov     [ebp+var_4], eax
.text$mn:00003428                 cmp     [ebp+var_4], 0
.text$mn:0000342C                 jnz     short loc_3433
.text$mn:0000342E
.text$mn:0000342E loc_342E:                               ; CODE XREF: std::_Allocate<std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>>>(uint,std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>> *)+1Aj
.text$mn:0000342E                 call    ?_Xbad_alloc@std@@YAXXZ ; std::_Xbad_alloc(void)
.text$mn:00003433
.text$mn:00003433 loc_3433:                               ; CODE XREF: std::_Allocate<std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>>>(uint,std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>> *)+11j
.text$mn:00003433                                         ; std::_Allocate<std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>>>(uint,std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>> *)+30j
.text$mn:00003433                 mov     eax, [ebp+var_4]
.text$mn:00003436                 mov     esp, ebp
.text$mn:00003438                 pop     ebp
.text$mn:00003439                 retn
.text$mn:00003439 ??$_Allocate@V?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@@std@@YAPAV?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@0@IPAV10@@Z endp
.text$mn:00003439
.text$mn:00003439 ; ---------------------------------------------------------------------------
.text$mn:0000343A                 align 4
.text$mn:0000343A _text$mn        ends
.text$mn:0000343A
.text$mn:0000343C ; ===========================================================================
.text$mn:0000343C
.text$mn:0000343C ; Segment type: Pure code
.text$mn:0000343C ; Segment permissions: Read/Execute
.text$mn:0000343C _text$mn        segment para public 'CODE' use32
.text$mn:0000343C                 assume cs:_text$mn
.text$mn:0000343C                 ;org 343Ch
.text$mn:0000343C ; COMDAT (pick any)
.text$mn:0000343C                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text$mn:0000343C
.text$mn:0000343C ; =============== S U B R O U T I N E =======================================
.text$mn:0000343C
.text$mn:0000343C ; Attributes: bp-based frame
.text$mn:0000343C
.text$mn:0000343C ; wchar_t * __cdecl std::_Allocate<wchar_t>(unsigned int, wchar_t *)
.text$mn:0000343C                 public ??$_Allocate@_W@std@@YAPA_WIPA_W@Z
.text$mn:0000343C ??$_Allocate@_W@std@@YAPA_WIPA_W@Z proc near
.text$mn:0000343C                                         ; CODE XREF: std::allocator<wchar_t>::allocate(uint)+Dp
.text$mn:0000343C
.text$mn:0000343C var_4           = dword ptr -4
.text$mn:0000343C arg_0           = dword ptr  8
.text$mn:0000343C
.text$mn:0000343C                 push    ebp
.text$mn:0000343D                 mov     ebp, esp
.text$mn:0000343F                 push    ecx
.text$mn:00003440                 mov     [ebp+var_4], 0
.text$mn:00003447                 cmp     [ebp+arg_0], 0
.text$mn:0000344B                 jnz     short loc_344F
.text$mn:0000344D                 jmp     short loc_3474
.text$mn:0000344F ; ---------------------------------------------------------------------------
.text$mn:0000344F
.text$mn:0000344F loc_344F:                               ; CODE XREF: std::_Allocate<wchar_t>(uint,wchar_t *)+Fj
.text$mn:0000344F                 cmp     [ebp+arg_0], 7FFFFFFFh
.text$mn:00003456                 ja      short loc_346F
.text$mn:00003458                 mov     eax, [ebp+arg_0]
.text$mn:0000345B                 shl     eax, 1
.text$mn:0000345D                 push    eax             ; unsigned int
.text$mn:0000345E                 call    ??2@YAPAXI@Z    ; operator new(uint)
.text$mn:00003463                 add     esp, 4
.text$mn:00003466                 mov     [ebp+var_4], eax
.text$mn:00003469                 cmp     [ebp+var_4], 0
.text$mn:0000346D                 jnz     short loc_3474
.text$mn:0000346F
.text$mn:0000346F loc_346F:                               ; CODE XREF: std::_Allocate<wchar_t>(uint,wchar_t *)+1Aj
.text$mn:0000346F                 call    ?_Xbad_alloc@std@@YAXXZ ; std::_Xbad_alloc(void)
.text$mn:00003474
.text$mn:00003474 loc_3474:                               ; CODE XREF: std::_Allocate<wchar_t>(uint,wchar_t *)+11j
.text$mn:00003474                                         ; std::_Allocate<wchar_t>(uint,wchar_t *)+31j
.text$mn:00003474                 mov     eax, [ebp+var_4]
.text$mn:00003477                 mov     esp, ebp
.text$mn:00003479                 pop     ebp
.text$mn:0000347A                 retn
.text$mn:0000347A ??$_Allocate@_W@std@@YAPA_WIPA_W@Z endp
.text$mn:0000347A
.text$mn:0000347A ; ---------------------------------------------------------------------------
.text$mn:0000347B                 align 4
.text$mn:0000347B _text$mn        ends
.text$mn:0000347B
.text$mn:0000347C ; ===========================================================================
.text$mn:0000347C
.text$mn:0000347C ; Segment type: Pure code
.text$mn:0000347C ; Segment permissions: Read/Execute
.text$mn:0000347C _text$mn        segment para public 'CODE' use32
.text$mn:0000347C                 assume cs:_text$mn
.text$mn:0000347C                 ;org 347Ch
.text$mn:0000347C ; COMDAT (pick any)
.text$mn:0000347C                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text$mn:0000347C
.text$mn:0000347C ; =============== S U B R O U T I N E =======================================
.text$mn:0000347C
.text$mn:0000347C ; Attributes: bp-based frame
.text$mn:0000347C
.text$mn:0000347C ; public: void __thiscall std::basic_string<wchar_t, struct std::char_traits<wchar_t>, class std::allocator<wchar_t>>::_Construct<class std::reverse_iterator<class std::_Vector_iterator<class std::_Vector_val<struct std::_Simple_types<wchar_t>>>>>(class std::reverse_iterator<class std::_Vector_iterator<class std::_Vector_val<struct std::_Simple_types<wchar_t>>>>, class std::reverse_iterator<class std::_Vector_iterator<class std::_Vector_val<struct std::_Simple_types<wchar_t>>>>, struct std::forward_iterator_tag)
.text$mn:0000347C                 public ??$_Construct@V?$reverse_iterator@V?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@_W@std@@@std@@@std@@@std@@@?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QAEXV?$reverse_iterator@V?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@_W@std@@@std@@@std@@@1@0Uforward_iterator_tag@1@@Z
.text$mn:0000347C ??$_Construct@V?$reverse_iterator@V?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@_W@std@@@std@@@std@@@std@@@?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QAEXV?$reverse_iterator@V?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@_W@std@@@std@@@std@@@1@0Uforward_iterator_tag@1@@Z proc near
.text$mn:0000347C                                         ; CODE XREF: std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>>::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>>(std::reverse_iterator<std::_Vector_iterator<std::_Vector_val<std::_Simple_types<wchar_t>>>>,std::reverse_iterator<std::_Vector_iterator<std::_Vector_val<std::_Simple_types<wchar_t>>>>)+ADp
.text$mn:0000347C
.text$mn:0000347C var_48          = dword ptr -48h
.text$mn:0000347C var_44          = dword ptr -44h
.text$mn:0000347C var_40          = dword ptr -40h
.text$mn:0000347C var_3C          = dword ptr -3Ch
.text$mn:0000347C var_38          = dword ptr -38h
.text$mn:0000347C var_34          = dword ptr -34h
.text$mn:0000347C var_30          = dword ptr -30h
.text$mn:0000347C var_2C          = dword ptr -2Ch
.text$mn:0000347C var_28          = dword ptr -28h
.text$mn:0000347C var_24          = dword ptr -24h
.text$mn:0000347C var_20          = dword ptr -20h
.text$mn:0000347C var_1C          = dword ptr -1Ch
.text$mn:0000347C var_18          = dword ptr -18h
.text$mn:0000347C var_14          = dword ptr -14h
.text$mn:0000347C var_10          = dword ptr -10h
.text$mn:0000347C var_C           = dword ptr -0Ch
.text$mn:0000347C var_4           = dword ptr -4
.text$mn:0000347C arg_0           = byte ptr  8
.text$mn:0000347C arg_C           = dword ptr  14h
.text$mn:0000347C
.text$mn:0000347C ; FUNCTION CHUNK AT .text$mn:000035C0 SIZE 00000009 BYTES
.text$mn:0000347C ; FUNCTION CHUNK AT .text$mn:000035D0 SIZE 0000002F BYTES
.text$mn:0000347C
.text$mn:0000347C                 push    ebp
.text$mn:0000347D                 mov     ebp, esp
.text$mn:0000347F                 push    0FFFFFFFFh
.text$mn:00003481                 push    offset __ehhandler$??$_Construct@V?$reverse_iterator@V?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@_W@std@@@std@@@std@@@std@@@?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QAEXV?$reverse_iterator@V?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@_W@std@@@std@@@std@@@1@0Uforward_iterator_tag@1@@Z
.text$mn:00003486                 mov     eax, large fs:0
.text$mn:0000348C                 push    eax
.text$mn:0000348D                 push    ecx
.text$mn:0000348E                 sub     esp, 38h
.text$mn:00003491                 push    ebx
.text$mn:00003492                 push    esi
.text$mn:00003493                 push    edi
.text$mn:00003494                 mov     eax, dword ptr ds:___security_cookie
.text$mn:00003499                 xor     eax, ebp
.text$mn:0000349B                 push    eax
.text$mn:0000349C                 lea     eax, [ebp+var_C]
.text$mn:0000349F                 mov     large fs:0, eax
.text$mn:000034A5                 mov     [ebp+var_10], esp
.text$mn:000034A8                 mov     [ebp+var_14], ecx
.text$mn:000034AB                 mov     [ebp+var_4], 1
.text$mn:000034B2                 push    34Bh            ; unsigned int
.text$mn:000034B7                 push    offset ??_C@_1IO@FEAPGJBD@?$AAC?$AA?3?$AA?2?$AAP?$AAr?$AAo?$AAg?$AAr?$AAa?$AAm?$AA?5?$AAF?$AAi?$AAl?$AAe?$AAs?$AA?5?$AA?$CI?$AAx?$AA8?$AA6?$AA?$CJ?$AA?2?$AAM?$AAi?$AAc?$AAr?$AAo?$AAs?$AAo?$AAf?$AAt@ ; "C:\\Program Files (x86)\\Microsoft Visu"...
.text$mn:000034BC                 sub     esp, 0Ch
.text$mn:000034BF                 mov     ecx, esp
.text$mn:000034C1                 mov     [ebp+var_2C], esp
.text$mn:000034C4                 lea     eax, [ebp+arg_C]
.text$mn:000034C7                 push    eax             ; int
.text$mn:000034C8                 call    ??0?$reverse_iterator@V?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@_W@std@@@std@@@std@@@std@@QAE@ABV01@@Z ; std::reverse_iterator<std::_Vector_iterator<std::_Vector_val<std::_Simple_types<wchar_t>>>>::reverse_iterator<std::_Vector_iterator<std::_Vector_val<std::_Simple_types<wchar_t>>>>(std::reverse_iterator<std::_Vector_iterator<std::_Vector_val<std::_Simple_types<wchar_t>>>> const &)
.text$mn:000034CD                 mov     [ebp+var_1C], eax
.text$mn:000034D0                 mov     ecx, [ebp+var_1C]
.text$mn:000034D3                 mov     [ebp+var_30], ecx
.text$mn:000034D6                 mov     byte ptr [ebp+var_4], 2
.text$mn:000034DA                 sub     esp, 0Ch
.text$mn:000034DD                 mov     ecx, esp
.text$mn:000034DF                 mov     [ebp+var_34], esp
.text$mn:000034E2                 lea     edx, [ebp+arg_0]
.text$mn:000034E5                 push    edx             ; struct std::_Iterator_base12 *
.text$mn:000034E6                 call    ??0?$reverse_iterator@V?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@_W@std@@@std@@@std@@@std@@QAE@ABV01@@Z ; std::reverse_iterator<std::_Vector_iterator<std::_Vector_val<std::_Simple_types<wchar_t>>>>::reverse_iterator<std::_Vector_iterator<std::_Vector_val<std::_Simple_types<wchar_t>>>>(std::reverse_iterator<std::_Vector_iterator<std::_Vector_val<std::_Simple_types<wchar_t>>>> const &)
.text$mn:000034EB                 mov     [ebp+var_20], eax
.text$mn:000034EE                 mov     eax, [ebp+var_20]
.text$mn:000034F1                 mov     [ebp+var_38], eax
.text$mn:000034F4                 mov     byte ptr [ebp+var_4], 3
.text$mn:000034F8                 mov     byte ptr [ebp+var_4], 1
.text$mn:000034FC                 call    ??$_Debug_range@V?$reverse_iterator@V?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@_W@std@@@std@@@std@@@std@@@std@@YAXV?$reverse_iterator@V?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@_W@std@@@std@@@std@@@0@0PB_WI@Z ; std::_Debug_range<std::reverse_iterator<std::_Vector_iterator<std::_Vector_val<std::_Simple_types<wchar_t>>>>>(std::reverse_iterator<std::_Vector_iterator<std::_Vector_val<std::_Simple_types<wchar_t>>>>,std::reverse_iterator<std::_Vector_iterator<std::_Vector_val<std::_Simple_types<wchar_t>>>>,wchar_t const *,uint)
.text$mn:00003501                 add     esp, 20h
.text$mn:00003504                 mov     [ebp+var_18], 0
.text$mn:0000350B                 lea     ecx, [ebp+var_18]
.text$mn:0000350E                 push    ecx
.text$mn:0000350F                 sub     esp, 0Ch
.text$mn:00003512                 mov     ecx, esp
.text$mn:00003514                 mov     [ebp+var_3C], esp
.text$mn:00003517                 lea     edx, [ebp+arg_C]
.text$mn:0000351A                 push    edx             ; struct std::_Iterator_base12 *
.text$mn:0000351B                 call    ??0?$reverse_iterator@V?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@_W@std@@@std@@@std@@@std@@QAE@ABV01@@Z ; std::reverse_iterator<std::_Vector_iterator<std::_Vector_val<std::_Simple_types<wchar_t>>>>::reverse_iterator<std::_Vector_iterator<std::_Vector_val<std::_Simple_types<wchar_t>>>>(std::reverse_iterator<std::_Vector_iterator<std::_Vector_val<std::_Simple_types<wchar_t>>>> const &)
.text$mn:00003520                 mov     [ebp+var_24], eax
.text$mn:00003523                 mov     eax, [ebp+var_24]
.text$mn:00003526                 mov     [ebp+var_40], eax
.text$mn:00003529                 mov     byte ptr [ebp+var_4], 4
.text$mn:0000352D                 sub     esp, 0Ch
.text$mn:00003530                 mov     ecx, esp
.text$mn:00003532                 mov     [ebp+var_44], esp
.text$mn:00003535                 lea     edx, [ebp+arg_0]
.text$mn:00003538                 push    edx             ; struct std::_Iterator_base12 *
.text$mn:00003539                 call    ??0?$reverse_iterator@V?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@_W@std@@@std@@@std@@@std@@QAE@ABV01@@Z ; std::reverse_iterator<std::_Vector_iterator<std::_Vector_val<std::_Simple_types<wchar_t>>>>::reverse_iterator<std::_Vector_iterator<std::_Vector_val<std::_Simple_types<wchar_t>>>>(std::reverse_iterator<std::_Vector_iterator<std::_Vector_val<std::_Simple_types<wchar_t>>>> const &)
.text$mn:0000353E                 mov     [ebp+var_28], eax
.text$mn:00003541                 mov     eax, [ebp+var_28]
.text$mn:00003544                 mov     [ebp+var_48], eax
.text$mn:00003547                 mov     byte ptr [ebp+var_4], 5
.text$mn:0000354B                 mov     byte ptr [ebp+var_4], 1
.text$mn:0000354F                 call    ??$_Distance@V?$reverse_iterator@V?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@_W@std@@@std@@@std@@@std@@I@std@@YAXV?$reverse_iterator@V?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@_W@std@@@std@@@std@@@0@0AAI@Z ; std::_Distance<std::reverse_iterator<std::_Vector_iterator<std::_Vector_val<std::_Simple_types<wchar_t>>>>,uint>(std::reverse_iterator<std::_Vector_iterator<std::_Vector_val<std::_Simple_types<wchar_t>>>>,std::reverse_iterator<std::_Vector_iterator<std::_Vector_val<std::_Simple_types<wchar_t>>>>,uint &)
.text$mn:00003554                 add     esp, 1Ch
.text$mn:00003557                 mov     ecx, [ebp+var_18]
.text$mn:0000355A                 push    ecx
.text$mn:0000355B                 mov     ecx, [ebp+var_14]
.text$mn:0000355E                 call    ?reserve@?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QAEXI@Z ; std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>>::reserve(uint)
.text$mn:00003563                 mov     byte ptr [ebp+var_4], 6
.text$mn:00003567                 jmp     short loc_3571
.text$mn:00003569 ; ---------------------------------------------------------------------------
.text$mn:00003569
.text$mn:00003569 loc_3569:                               ; CODE XREF: std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>>::_Construct<std::reverse_iterator<std::_Vector_iterator<std::_Vector_val<std::_Simple_types<wchar_t>>>>>(std::reverse_iterator<std::_Vector_iterator<std::_Vector_val<std::_Simple_types<wchar_t>>>>,std::reverse_iterator<std::_Vector_iterator<std::_Vector_val<std::_Simple_types<wchar_t>>>>,std::forward_iterator_tag)+125j
.text$mn:00003569                 lea     ecx, [ebp+arg_0]
.text$mn:0000356C                 call    ??E?$reverse_iterator@V?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@_W@std@@@std@@@std@@@std@@QAEAAV01@XZ ; std::reverse_iterator<std::_Vector_iterator<std::_Vector_val<std::_Simple_types<wchar_t>>>>::operator++(void)
.text$mn:00003571
.text$mn:00003571 loc_3571:                               ; CODE XREF: std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>>::_Construct<std::reverse_iterator<std::_Vector_iterator<std::_Vector_val<std::_Simple_types<wchar_t>>>>>(std::reverse_iterator<std::_Vector_iterator<std::_Vector_val<std::_Simple_types<wchar_t>>>>,std::reverse_iterator<std::_Vector_iterator<std::_Vector_val<std::_Simple_types<wchar_t>>>>,std::forward_iterator_tag)+EBj
.text$mn:00003571                 lea     edx, [ebp+arg_C]
.text$mn:00003574                 push    edx
.text$mn:00003575                 lea     eax, [ebp+arg_0]
.text$mn:00003578                 push    eax
.text$mn:00003579                 call    ??$?9V?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@_W@std@@@std@@@std@@V01@@std@@YA_NABV?$reverse_iterator@V?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@_W@std@@@std@@@std@@@0@0@Z ; std::operator!=<std::_Vector_iterator<std::_Vector_val<std::_Simple_types<wchar_t>>>,std::_Vector_iterator<std::_Vector_val<std::_Simple_types<wchar_t>>>>(std::reverse_iterator<std::_Vector_iterator<std::_Vector_val<std::_Simple_types<wchar_t>>>> const &,std::reverse_iterator<std::_Vector_iterator<std::_Vector_val<std::_Simple_types<wchar_t>>>> const &)
.text$mn:0000357E                 add     esp, 8
.text$mn:00003581                 movzx   ecx, al
.text$mn:00003584                 test    ecx, ecx
.text$mn:00003586                 jz      short loc_35A3
.text$mn:00003588                 lea     ecx, [ebp+arg_0]
.text$mn:0000358B                 call    ??D?$_Revranit@V?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@_W@std@@@std@@@std@@U?$iterator@Urandom_access_iterator_tag@std@@_WHPA_WAA_W@2@@std@@QBEAA_WXZ ; std::_Revranit<std::_Vector_iterator<std::_Vector_val<std::_Simple_types<wchar_t>>>,std::iterator<std::random_access_iterator_tag,wchar_t,int,wchar_t *,wchar_t &>>::operator*(void)
.text$mn:00003590                 mov     dx, [eax]
.text$mn:00003593                 movzx   eax, dx
.text$mn:00003596                 push    eax
.text$mn:00003597                 push    1
.text$mn:00003599                 mov     ecx, [ebp+var_14]
.text$mn:0000359C                 call    ?append@?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QAEAAV12@I_W@Z ; std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>>::append(uint,wchar_t)
.text$mn:000035A1                 jmp     short loc_3569
.text$mn:000035A3 ; ---------------------------------------------------------------------------
.text$mn:000035A3
.text$mn:000035A3 loc_35A3:                               ; CODE XREF: std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>>::_Construct<std::reverse_iterator<std::_Vector_iterator<std::_Vector_val<std::_Simple_types<wchar_t>>>>>(std::reverse_iterator<std::_Vector_iterator<std::_Vector_val<std::_Simple_types<wchar_t>>>>,std::reverse_iterator<std::_Vector_iterator<std::_Vector_val<std::_Simple_types<wchar_t>>>>,std::forward_iterator_tag)+10Aj
.text$mn:000035A3                 jmp     short loc_35C0
.text$mn:000035A3 ??$_Construct@V?$reverse_iterator@V?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@_W@std@@@std@@@std@@@std@@@?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QAEXV?$reverse_iterator@V?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@_W@std@@@std@@@std@@@1@0Uforward_iterator_tag@1@@Z endp
.text$mn:000035A3
.text$mn:000035A5
.text$mn:000035A5 ; =============== S U B R O U T I N E =======================================
.text$mn:000035A5
.text$mn:000035A5 ; Attributes: noreturn
.text$mn:000035A5
.text$mn:000035A5 __catch$??$_Construct@V?$reverse_iterator@V?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@_W@std@@@std@@@std@@@std@@@?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QAEXV?$reverse_iterator@V?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@_W@std@@@std@@@std@@@1@0Uforward_iterator_tag@1@@Z$0 proc near
.text$mn:000035A5                                         ; DATA XREF: .xdata$x:0000EE1Co
.text$mn:000035A5                 push    0
.text$mn:000035A7                 push    1
.text$mn:000035A9                 mov     ecx, [ebp-14h]
.text$mn:000035AC                 call    ?_Tidy@?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QAEX_NI@Z ; std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>>::_Tidy(bool,uint)
.text$mn:000035B1                 push    0
.text$mn:000035B3                 push    0
.text$mn:000035B5                 call    __CxxThrowException@8 ; _CxxThrowException(x,x)
.text$mn:000035B5 __catch$??$_Construct@V?$reverse_iterator@V?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@_W@std@@@std@@@std@@@std@@@?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QAEXV?$reverse_iterator@V?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@_W@std@@@std@@@std@@@1@0Uforward_iterator_tag@1@@Z$0 endp
.text$mn:000035B5
.text$mn:000035BA ; ---------------------------------------------------------------------------
.text$mn:000035BA                 mov     eax, offset $LN16
.text$mn:000035BF                 retn
.text$mn:000035C0 ; ---------------------------------------------------------------------------
.text$mn:000035C0 ; START OF FUNCTION CHUNK FOR ??$_Construct@V?$reverse_iterator@V?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@_W@std@@@std@@@std@@@std@@@?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QAEXV?$reverse_iterator@V?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@_W@std@@@std@@@std@@@1@0Uforward_iterator_tag@1@@Z
.text$mn:000035C0
.text$mn:000035C0 loc_35C0:                               ; CODE XREF: std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>>::_Construct<std::reverse_iterator<std::_Vector_iterator<std::_Vector_val<std::_Simple_types<wchar_t>>>>>(std::reverse_iterator<std::_Vector_iterator<std::_Vector_val<std::_Simple_types<wchar_t>>>>,std::reverse_iterator<std::_Vector_iterator<std::_Vector_val<std::_Simple_types<wchar_t>>>>,std::forward_iterator_tag):loc_35A3j
.text$mn:000035C0                 mov     [ebp+var_4], 1
.text$mn:000035C7                 jmp     short loc_35D0
.text$mn:000035C7 ; END OF FUNCTION CHUNK FOR ??$_Construct@V?$reverse_iterator@V?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@_W@std@@@std@@@std@@@std@@@?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QAEXV?$reverse_iterator@V?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@_W@std@@@std@@@std@@@1@0Uforward_iterator_tag@1@@Z
.text$mn:000035C9
.text$mn:000035C9 ; =============== S U B R O U T I N E =======================================
.text$mn:000035C9
.text$mn:000035C9
.text$mn:000035C9 $LN16           proc near               ; DATA XREF: .text$mn:000035BAo
.text$mn:000035C9                 mov     dword ptr [ebp-4], 1
.text$mn:000035C9 $LN16           endp ; sp-analysis failed
.text$mn:000035C9
.text$mn:000035D0 ; START OF FUNCTION CHUNK FOR ??$_Construct@V?$reverse_iterator@V?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@_W@std@@@std@@@std@@@std@@@?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QAEXV?$reverse_iterator@V?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@_W@std@@@std@@@std@@@1@0Uforward_iterator_tag@1@@Z
.text$mn:000035D0
.text$mn:000035D0 loc_35D0:                               ; CODE XREF: std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>>::_Construct<std::reverse_iterator<std::_Vector_iterator<std::_Vector_val<std::_Simple_types<wchar_t>>>>>(std::reverse_iterator<std::_Vector_iterator<std::_Vector_val<std::_Simple_types<wchar_t>>>>,std::reverse_iterator<std::_Vector_iterator<std::_Vector_val<std::_Simple_types<wchar_t>>>>,std::forward_iterator_tag)+14Bj
.text$mn:000035D0                 mov     byte ptr [ebp+var_4], 0
.text$mn:000035D4                 lea     ecx, [ebp+arg_0]
.text$mn:000035D7                 call    ??1?$reverse_iterator@V?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@_W@std@@@std@@@std@@@std@@QAE@XZ ; std::reverse_iterator<std::_Vector_iterator<std::_Vector_val<std::_Simple_types<wchar_t>>>>::~reverse_iterator<std::_Vector_iterator<std::_Vector_val<std::_Simple_types<wchar_t>>>>(void)
.text$mn:000035DC                 mov     [ebp+var_4], 0FFFFFFFFh
.text$mn:000035E3                 lea     ecx, [ebp+arg_C]
.text$mn:000035E6                 call    ??1?$reverse_iterator@V?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@_W@std@@@std@@@std@@@std@@QAE@XZ ; std::reverse_iterator<std::_Vector_iterator<std::_Vector_val<std::_Simple_types<wchar_t>>>>::~reverse_iterator<std::_Vector_iterator<std::_Vector_val<std::_Simple_types<wchar_t>>>>(void)
.text$mn:000035EB                 mov     ecx, [ebp+var_C]
.text$mn:000035EE                 mov     large fs:0, ecx
.text$mn:000035F5                 pop     ecx
.text$mn:000035F6                 pop     edi
.text$mn:000035F7                 pop     esi
.text$mn:000035F8                 pop     ebx
.text$mn:000035F9                 mov     esp, ebp
.text$mn:000035FB                 pop     ebp
.text$mn:000035FC                 retn    1Ch
.text$mn:000035FC ; END OF FUNCTION CHUNK FOR ??$_Construct@V?$reverse_iterator@V?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@_W@std@@@std@@@std@@@std@@@?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QAEXV?$reverse_iterator@V?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@_W@std@@@std@@@std@@@1@0Uforward_iterator_tag@1@@Z
.text$mn:000035FC ; ---------------------------------------------------------------------------
.text$mn:000035FF                 align 10h
.text$mn:000035FF _text$mn        ends
.text$mn:000035FF
.text$x:00003600 ; ===========================================================================
.text$x:00003600
.text$x:00003600 ; Segment type: Pure code
.text$x:00003600 ; Segment permissions: Read/Execute
.text$x:00003600 _text$x         segment para public 'CODE' use32
.text$x:00003600                 assume cs:_text$x
.text$x:00003600                 ;org 3600h
.text$x:00003600 ; COMDAT (pick associative to section at 347C)
.text$x:00003600                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text$x:00003600
.text$x:00003600 ; =============== S U B R O U T I N E =======================================
.text$x:00003600
.text$x:00003600
.text$x:00003600 __unwindfunclet$??$_Construct@V?$reverse_iterator@V?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@_W@std@@@std@@@std@@@std@@@?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QAEXV?$reverse_iterator@V?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@_W@std@@@std@@@std@@@1@0Uforward_iterator_tag@1@@Z$2 proc near
.text$x:00003600                                         ; DATA XREF: .xdata$x:0000EE5Co
.text$x:00003600                 lea     ecx, [ebp+14h]
.text$x:00003603                 jmp     ??1?$reverse_iterator@V?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@_W@std@@@std@@@std@@@std@@QAE@XZ ; std::reverse_iterator<std::_Vector_iterator<std::_Vector_val<std::_Simple_types<wchar_t>>>>::~reverse_iterator<std::_Vector_iterator<std::_Vector_val<std::_Simple_types<wchar_t>>>>(void)
.text$x:00003603 __unwindfunclet$??$_Construct@V?$reverse_iterator@V?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@_W@std@@@std@@@std@@@std@@@?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QAEXV?$reverse_iterator@V?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@_W@std@@@std@@@std@@@1@0Uforward_iterator_tag@1@@Z$2 endp
.text$x:00003603
.text$x:00003608
.text$x:00003608 ; =============== S U B R O U T I N E =======================================
.text$x:00003608
.text$x:00003608
.text$x:00003608 __unwindfunclet$??$_Construct@V?$reverse_iterator@V?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@_W@std@@@std@@@std@@@std@@@?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QAEXV?$reverse_iterator@V?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@_W@std@@@std@@@std@@@1@0Uforward_iterator_tag@1@@Z$3 proc near
.text$x:00003608                                         ; DATA XREF: .xdata$x:0000EE64o
.text$x:00003608                 lea     ecx, [ebp+8]
.text$x:0000360B                 jmp     ??1?$reverse_iterator@V?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@_W@std@@@std@@@std@@@std@@QAE@XZ ; std::reverse_iterator<std::_Vector_iterator<std::_Vector_val<std::_Simple_types<wchar_t>>>>::~reverse_iterator<std::_Vector_iterator<std::_Vector_val<std::_Simple_types<wchar_t>>>>(void)
.text$x:0000360B __unwindfunclet$??$_Construct@V?$reverse_iterator@V?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@_W@std@@@std@@@std@@@std@@@?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QAEXV?$reverse_iterator@V?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@_W@std@@@std@@@std@@@1@0Uforward_iterator_tag@1@@Z$3 endp
.text$x:0000360B
.text$x:00003610
.text$x:00003610 ; =============== S U B R O U T I N E =======================================
.text$x:00003610
.text$x:00003610
.text$x:00003610 __unwindfunclet$??$_Construct@V?$reverse_iterator@V?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@_W@std@@@std@@@std@@@std@@@?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QAEXV?$reverse_iterator@V?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@_W@std@@@std@@@std@@@1@0Uforward_iterator_tag@1@@Z$4 proc near
.text$x:00003610                                         ; DATA XREF: .xdata$x:0000EE6Co
.text$x:00003610                 mov     ecx, [ebp-2Ch]
.text$x:00003613                 jmp     ??1?$reverse_iterator@V?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@_W@std@@@std@@@std@@@std@@QAE@XZ ; std::reverse_iterator<std::_Vector_iterator<std::_Vector_val<std::_Simple_types<wchar_t>>>>::~reverse_iterator<std::_Vector_iterator<std::_Vector_val<std::_Simple_types<wchar_t>>>>(void)
.text$x:00003613 __unwindfunclet$??$_Construct@V?$reverse_iterator@V?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@_W@std@@@std@@@std@@@std@@@?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QAEXV?$reverse_iterator@V?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@_W@std@@@std@@@std@@@1@0Uforward_iterator_tag@1@@Z$4 endp
.text$x:00003613
.text$x:00003618
.text$x:00003618 ; =============== S U B R O U T I N E =======================================
.text$x:00003618
.text$x:00003618
.text$x:00003618 __unwindfunclet$??$_Construct@V?$reverse_iterator@V?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@_W@std@@@std@@@std@@@std@@@?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QAEXV?$reverse_iterator@V?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@_W@std@@@std@@@std@@@1@0Uforward_iterator_tag@1@@Z$5 proc near
.text$x:00003618                                         ; DATA XREF: .xdata$x:0000EE74o
.text$x:00003618                 mov     ecx, [ebp-34h]
.text$x:0000361B                 jmp     ??1?$reverse_iterator@V?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@_W@std@@@std@@@std@@@std@@QAE@XZ ; std::reverse_iterator<std::_Vector_iterator<std::_Vector_val<std::_Simple_types<wchar_t>>>>::~reverse_iterator<std::_Vector_iterator<std::_Vector_val<std::_Simple_types<wchar_t>>>>(void)
.text$x:0000361B __unwindfunclet$??$_Construct@V?$reverse_iterator@V?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@_W@std@@@std@@@std@@@std@@@?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QAEXV?$reverse_iterator@V?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@_W@std@@@std@@@std@@@1@0Uforward_iterator_tag@1@@Z$5 endp
.text$x:0000361B
.text$x:00003620
.text$x:00003620 ; =============== S U B R O U T I N E =======================================
.text$x:00003620
.text$x:00003620
.text$x:00003620 __unwindfunclet$??$_Construct@V?$reverse_iterator@V?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@_W@std@@@std@@@std@@@std@@@?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QAEXV?$reverse_iterator@V?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@_W@std@@@std@@@std@@@1@0Uforward_iterator_tag@1@@Z$6 proc near
.text$x:00003620                                         ; DATA XREF: .xdata$x:0000EE7Co
.text$x:00003620                 mov     ecx, [ebp-3Ch]
.text$x:00003623                 jmp     ??1?$reverse_iterator@V?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@_W@std@@@std@@@std@@@std@@QAE@XZ ; std::reverse_iterator<std::_Vector_iterator<std::_Vector_val<std::_Simple_types<wchar_t>>>>::~reverse_iterator<std::_Vector_iterator<std::_Vector_val<std::_Simple_types<wchar_t>>>>(void)
.text$x:00003623 __unwindfunclet$??$_Construct@V?$reverse_iterator@V?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@_W@std@@@std@@@std@@@std@@@?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QAEXV?$reverse_iterator@V?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@_W@std@@@std@@@std@@@1@0Uforward_iterator_tag@1@@Z$6 endp
.text$x:00003623
.text$x:00003628
.text$x:00003628 ; =============== S U B R O U T I N E =======================================
.text$x:00003628
.text$x:00003628
.text$x:00003628 __unwindfunclet$??$_Construct@V?$reverse_iterator@V?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@_W@std@@@std@@@std@@@std@@@?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QAEXV?$reverse_iterator@V?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@_W@std@@@std@@@std@@@1@0Uforward_iterator_tag@1@@Z$7 proc near
.text$x:00003628                                         ; DATA XREF: .xdata$x:0000EE84o
.text$x:00003628                 mov     ecx, [ebp-44h]
.text$x:0000362B                 jmp     ??1?$reverse_iterator@V?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@_W@std@@@std@@@std@@@std@@QAE@XZ ; std::reverse_iterator<std::_Vector_iterator<std::_Vector_val<std::_Simple_types<wchar_t>>>>::~reverse_iterator<std::_Vector_iterator<std::_Vector_val<std::_Simple_types<wchar_t>>>>(void)
.text$x:0000362B __unwindfunclet$??$_Construct@V?$reverse_iterator@V?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@_W@std@@@std@@@std@@@std@@@?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QAEXV?$reverse_iterator@V?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@_W@std@@@std@@@std@@@1@0Uforward_iterator_tag@1@@Z$7 endp
.text$x:0000362B
.text$x:00003630
.text$x:00003630 ; =============== S U B R O U T I N E =======================================
.text$x:00003630
.text$x:00003630
.text$x:00003630 __ehhandler$??$_Construct@V?$reverse_iterator@V?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@_W@std@@@std@@@std@@@std@@@?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QAEXV?$reverse_iterator@V?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@_W@std@@@std@@@std@@@1@0Uforward_iterator_tag@1@@Z proc near
.text$x:00003630                                         ; DATA XREF: std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>>::_Construct<std::reverse_iterator<std::_Vector_iterator<std::_Vector_val<std::_Simple_types<wchar_t>>>>>(std::reverse_iterator<std::_Vector_iterator<std::_Vector_val<std::_Simple_types<wchar_t>>>>,std::reverse_iterator<std::_Vector_iterator<std::_Vector_val<std::_Simple_types<wchar_t>>>>,std::forward_iterator_tag)+5o
.text$x:00003630
.text$x:00003630 arg_4           = dword ptr  8
.text$x:00003630
.text$x:00003630                 mov     edx, [esp+arg_4]
.text$x:00003634                 lea     eax, [edx+0Ch]
.text$x:00003637                 mov     ecx, [edx-4Ch]
.text$x:0000363A                 xor     ecx, eax
.text$x:0000363C                 call    @__security_check_cookie@4 ; __security_check_cookie(x)
.text$x:00003641                 mov     eax, offset __ehfuncinfo$??$_Construct@V?$reverse_iterator@V?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@_W@std@@@std@@@std@@@std@@@?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QAEXV?$reverse_iterator@V?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@_W@std@@@std@@@std@@@1@0Uforward_iterator_tag@1@@Z
.text$x:00003646                 jmp     ___CxxFrameHandler3
.text$x:00003646 __ehhandler$??$_Construct@V?$reverse_iterator@V?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@_W@std@@@std@@@std@@@std@@@?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QAEXV?$reverse_iterator@V?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@_W@std@@@std@@@std@@@1@0Uforward_iterator_tag@1@@Z endp
.text$x:00003646
.text$x:00003646 ; ---------------------------------------------------------------------------
.text$x:0000364B                 align 4
.text$x:0000364B _text$x         ends
.text$x:0000364B
.text$mn:0000364C ; ===========================================================================
.text$mn:0000364C
.text$mn:0000364C ; Segment type: Pure code
.text$mn:0000364C ; Segment permissions: Read/Execute
.text$mn:0000364C _text$mn        segment para public 'CODE' use32
.text$mn:0000364C                 assume cs:_text$mn
.text$mn:0000364C                 ;org 364Ch
.text$mn:0000364C ; COMDAT (pick any)
.text$mn:0000364C                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text$mn:0000364C
.text$mn:0000364C ; =============== S U B R O U T I N E =======================================
.text$mn:0000364C
.text$mn:0000364C ; Attributes: bp-based frame
.text$mn:0000364C
.text$mn:0000364C ; int __cdecl std::_Debug_pointer<int __cdecl (int)>(int, wchar_t *, unsigned int)
.text$mn:0000364C                 public ??$_Debug_pointer@$$A6AHH@Z@std@@YAXP6AHH@ZPB_WI@Z
.text$mn:0000364C ??$_Debug_pointer@$$A6AHH@Z@std@@YAXP6AHH@ZPB_WI@Z proc near
.text$mn:0000364C                                         ; CODE XREF: std::transform<std::_String_iterator<std::_String_val<std::_Simple_types<wchar_t>>>,std::_String_iterator<std::_String_val<std::_Simple_types<wchar_t>>>,int (*)(int)>(std::_String_iterator<std::_String_val<std::_Simple_types<wchar_t>>>,std::_String_iterator<std::_String_val<std::_Simple_types<wchar_t>>>,std::_String_iterator<std::_String_val<std::_Simple_types<wchar_t>>>,int (*)(int))+A9p
.text$mn:0000364C
.text$mn:0000364C arg_0           = dword ptr  8
.text$mn:0000364C arg_4           = dword ptr  0Ch
.text$mn:0000364C arg_8           = dword ptr  10h
.text$mn:0000364C
.text$mn:0000364C                 push    ebp
.text$mn:0000364D                 mov     ebp, esp
.text$mn:0000364F                 cmp     [ebp+arg_0], 0
.text$mn:00003653                 jnz     short loc_366A
.text$mn:00003655                 mov     eax, [ebp+arg_8]
.text$mn:00003658                 push    eax             ; unsigned int
.text$mn:00003659                 mov     ecx, [ebp+arg_4]
.text$mn:0000365C                 push    ecx             ; wchar_t *
.text$mn:0000365D                 push    offset ??_C@_1CK@EOPGIILJ@?$AAi?$AAn?$AAv?$AAa?$AAl?$AAi?$AAd?$AA?5?$AAn?$AAu?$AAl?$AAl?$AA?5?$AAp?$AAo?$AAi?$AAn?$AAt?$AAe?$AAr?$AA?$AA@ ; "invalid null pointer"
.text$mn:00003662                 call    ?_Debug_message@std@@YAXPB_W0I@Z ; std::_Debug_message(wchar_t const *,wchar_t const *,uint)
.text$mn:00003667                 add     esp, 0Ch
.text$mn:0000366A
.text$mn:0000366A loc_366A:                               ; CODE XREF: std::_Debug_pointer<int (int)>(int (*)(int),wchar_t const *,uint)+7j
.text$mn:0000366A                 pop     ebp
.text$mn:0000366B                 retn
.text$mn:0000366B ??$_Debug_pointer@$$A6AHH@Z@std@@YAXP6AHH@ZPB_WI@Z endp
.text$mn:0000366B
.text$mn:0000366B _text$mn        ends
.text$mn:0000366B
.text$mn:0000366C ; ===========================================================================
.text$mn:0000366C
.text$mn:0000366C ; Segment type: Pure code
.text$mn:0000366C ; Segment permissions: Read/Execute
.text$mn:0000366C _text$mn        segment para public 'CODE' use32
.text$mn:0000366C                 assume cs:_text$mn
.text$mn:0000366C                 ;org 366Ch
.text$mn:0000366C ; COMDAT (pick any)
.text$mn:0000366C                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text$mn:0000366C
.text$mn:0000366C ; =============== S U B R O U T I N E =======================================
.text$mn:0000366C
.text$mn:0000366C ; Attributes: bp-based frame
.text$mn:0000366C
.text$mn:0000366C ; int __cdecl std::_Debug_pointer<char>(int, wchar_t *, unsigned int)
.text$mn:0000366C                 public ??$_Debug_pointer@D@std@@YAXPBDPB_WI@Z
.text$mn:0000366C ??$_Debug_pointer@D@std@@YAXPBDPB_WI@Z proc near
.text$mn:0000366C                                         ; CODE XREF: std::basic_string<char,std::char_traits<char>,std::allocator<char>>::append(char const *)+15p
.text$mn:0000366C                                         ; std::basic_string<char,std::char_traits<char>,std::allocator<char>>::append(char const *,uint)+1Dp ...
.text$mn:0000366C
.text$mn:0000366C arg_0           = dword ptr  8
.text$mn:0000366C arg_4           = dword ptr  0Ch
.text$mn:0000366C arg_8           = dword ptr  10h
.text$mn:0000366C
.text$mn:0000366C                 push    ebp
.text$mn:0000366D                 mov     ebp, esp
.text$mn:0000366F                 cmp     [ebp+arg_0], 0
.text$mn:00003673                 jnz     short loc_368A
.text$mn:00003675                 mov     eax, [ebp+arg_8]
.text$mn:00003678                 push    eax             ; unsigned int
.text$mn:00003679                 mov     ecx, [ebp+arg_4]
.text$mn:0000367C                 push    ecx             ; wchar_t *
.text$mn:0000367D                 push    offset ??_C@_1CK@EOPGIILJ@?$AAi?$AAn?$AAv?$AAa?$AAl?$AAi?$AAd?$AA?5?$AAn?$AAu?$AAl?$AAl?$AA?5?$AAp?$AAo?$AAi?$AAn?$AAt?$AAe?$AAr?$AA?$AA@ ; "invalid null pointer"
.text$mn:00003682                 call    ?_Debug_message@std@@YAXPB_W0I@Z ; std::_Debug_message(wchar_t const *,wchar_t const *,uint)
.text$mn:00003687                 add     esp, 0Ch
.text$mn:0000368A
.text$mn:0000368A loc_368A:                               ; CODE XREF: std::_Debug_pointer<char>(char const *,wchar_t const *,uint)+7j
.text$mn:0000368A                 pop     ebp
.text$mn:0000368B                 retn
.text$mn:0000368B ??$_Debug_pointer@D@std@@YAXPBDPB_WI@Z endp
.text$mn:0000368B
.text$mn:0000368B _text$mn        ends
.text$mn:0000368B
.text$mn:0000368C ; ===========================================================================
.text$mn:0000368C
.text$mn:0000368C ; Segment type: Pure code
.text$mn:0000368C ; Segment permissions: Read/Execute
.text$mn:0000368C _text$mn        segment para public 'CODE' use32
.text$mn:0000368C                 assume cs:_text$mn
.text$mn:0000368C                 ;org 368Ch
.text$mn:0000368C ; COMDAT (pick any)
.text$mn:0000368C                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text$mn:0000368C
.text$mn:0000368C ; =============== S U B R O U T I N E =======================================
.text$mn:0000368C
.text$mn:0000368C ; Attributes: bp-based frame
.text$mn:0000368C
.text$mn:0000368C ; void __cdecl std::_Debug_pointer<class std::_String_iterator<class std::_String_val<struct std::_Simple_types<wchar_t>>>>(class std::_String_iterator<class std::_String_val<struct std::_Simple_types<wchar_t>>> &, wchar_t const *, unsigned int)
.text$mn:0000368C                 public ??$_Debug_pointer@V?$_String_iterator@V?$_String_val@U?$_Simple_types@_W@std@@@std@@@std@@@std@@YAXAAV?$_String_iterator@V?$_String_val@U?$_Simple_types@_W@std@@@std@@@0@PB_WI@Z
.text$mn:0000368C ??$_Debug_pointer@V?$_String_iterator@V?$_String_val@U?$_Simple_types@_W@std@@@std@@@std@@@std@@YAXAAV?$_String_iterator@V?$_String_val@U?$_Simple_types@_W@std@@@std@@@0@PB_WI@Z proc near
.text$mn:0000368C                                         ; CODE XREF: std::_Debug_range2<std::_String_iterator<std::_String_val<std::_Simple_types<wchar_t>>>>(std::_String_iterator<std::_String_val<std::_Simple_types<wchar_t>>>,std::_String_iterator<std::_String_val<std::_Simple_types<wchar_t>>>,wchar_t const *,uint,std::random_access_iterator_tag)+48p
.text$mn:0000368C                                         ; std::_Debug_range2<std::_String_iterator<std::_String_val<std::_Simple_types<wchar_t>>>>(std::_String_iterator<std::_String_val<std::_Simple_types<wchar_t>>>,std::_String_iterator<std::_String_val<std::_Simple_types<wchar_t>>>,wchar_t const *,uint,std::random_access_iterator_tag)+5Cp ...
.text$mn:0000368C                 push    ebp
.text$mn:0000368D                 mov     ebp, esp
.text$mn:0000368F                 pop     ebp
.text$mn:00003690                 retn
.text$mn:00003690 ??$_Debug_pointer@V?$_String_iterator@V?$_String_val@U?$_Simple_types@_W@std@@@std@@@std@@@std@@YAXAAV?$_String_iterator@V?$_String_val@U?$_Simple_types@_W@std@@@std@@@0@PB_WI@Z endp
.text$mn:00003690
.text$mn:00003690 ; ---------------------------------------------------------------------------
.text$mn:00003691                 align 4
.text$mn:00003691 _text$mn        ends
.text$mn:00003691
.text$mn:00003694 ; ===========================================================================
.text$mn:00003694
.text$mn:00003694 ; Segment type: Pure code
.text$mn:00003694 ; Segment permissions: Read/Execute
.text$mn:00003694 _text$mn        segment para public 'CODE' use32
.text$mn:00003694                 assume cs:_text$mn
.text$mn:00003694                 ;org 3694h
.text$mn:00003694 ; COMDAT (pick any)
.text$mn:00003694                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text$mn:00003694
.text$mn:00003694 ; =============== S U B R O U T I N E =======================================
.text$mn:00003694
.text$mn:00003694 ; Attributes: bp-based frame
.text$mn:00003694
.text$mn:00003694 ; int __cdecl std::_Debug_pointer<std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>>>(int, wchar_t *, unsigned int)
.text$mn:00003694                 public ??$_Debug_pointer@V?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@@std@@YAXPAV?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@0@PB_WI@Z
.text$mn:00003694 ??$_Debug_pointer@V?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@@std@@YAXPAV?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@0@PB_WI@Z proc near
.text$mn:00003694                                         ; CODE XREF: std::_Debug_range2<std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>> *>(std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>> *,std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>> *,wchar_t const *,uint,std::random_access_iterator_tag)+17p
.text$mn:00003694                                         ; std::_Debug_range2<std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>> *>(std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>> *,std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>> *,wchar_t const *,uint,std::random_access_iterator_tag)+2Bp ...
.text$mn:00003694
.text$mn:00003694 arg_0           = dword ptr  8
.text$mn:00003694 arg_4           = dword ptr  0Ch
.text$mn:00003694 arg_8           = dword ptr  10h
.text$mn:00003694
.text$mn:00003694                 push    ebp
.text$mn:00003695                 mov     ebp, esp
.text$mn:00003697                 cmp     [ebp+arg_0], 0
.text$mn:0000369B                 jnz     short loc_36B2
.text$mn:0000369D                 mov     eax, [ebp+arg_8]
.text$mn:000036A0                 push    eax             ; unsigned int
.text$mn:000036A1                 mov     ecx, [ebp+arg_4]
.text$mn:000036A4                 push    ecx             ; wchar_t *
.text$mn:000036A5                 push    offset ??_C@_1CK@EOPGIILJ@?$AAi?$AAn?$AAv?$AAa?$AAl?$AAi?$AAd?$AA?5?$AAn?$AAu?$AAl?$AAl?$AA?5?$AAp?$AAo?$AAi?$AAn?$AAt?$AAe?$AAr?$AA?$AA@ ; "invalid null pointer"
.text$mn:000036AA                 call    ?_Debug_message@std@@YAXPB_W0I@Z ; std::_Debug_message(wchar_t const *,wchar_t const *,uint)
.text$mn:000036AF                 add     esp, 0Ch
.text$mn:000036B2
.text$mn:000036B2 loc_36B2:                               ; CODE XREF: std::_Debug_pointer<std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>>>(std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>> *,wchar_t const *,uint)+7j
.text$mn:000036B2                 pop     ebp
.text$mn:000036B3                 retn
.text$mn:000036B3 ??$_Debug_pointer@V?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@@std@@YAXPAV?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@0@PB_WI@Z endp
.text$mn:000036B3
.text$mn:000036B3 _text$mn        ends
.text$mn:000036B3
.text$mn:000036B4 ; ===========================================================================
.text$mn:000036B4
.text$mn:000036B4 ; Segment type: Pure code
.text$mn:000036B4 ; Segment permissions: Read/Execute
.text$mn:000036B4 _text$mn        segment para public 'CODE' use32
.text$mn:000036B4                 assume cs:_text$mn
.text$mn:000036B4                 ;org 36B4h
.text$mn:000036B4 ; COMDAT (pick any)
.text$mn:000036B4                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text$mn:000036B4
.text$mn:000036B4 ; =============== S U B R O U T I N E =======================================
.text$mn:000036B4
.text$mn:000036B4 ; Attributes: bp-based frame
.text$mn:000036B4
.text$mn:000036B4 ; void __cdecl std::_Debug_pointer<class std::reverse_iterator<class std::_Vector_iterator<class std::_Vector_val<struct std::_Simple_types<wchar_t>>>>>(class std::reverse_iterator<class std::_Vector_iterator<class std::_Vector_val<struct std::_Simple_types<wchar_t>>>> &, wchar_t const *, unsigned int)
.text$mn:000036B4                 public ??$_Debug_pointer@V?$reverse_iterator@V?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@_W@std@@@std@@@std@@@std@@@std@@YAXAAV?$reverse_iterator@V?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@_W@std@@@std@@@std@@@0@PB_WI@Z
.text$mn:000036B4 ??$_Debug_pointer@V?$reverse_iterator@V?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@_W@std@@@std@@@std@@@std@@@std@@YAXAAV?$reverse_iterator@V?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@_W@std@@@std@@@std@@@0@PB_WI@Z proc near
.text$mn:000036B4                                         ; CODE XREF: std::_Debug_range2<std::reverse_iterator<std::_Vector_iterator<std::_Vector_val<std::_Simple_types<wchar_t>>>>>(std::reverse_iterator<std::_Vector_iterator<std::_Vector_val<std::_Simple_types<wchar_t>>>>,std::reverse_iterator<std::_Vector_iterator<std::_Vector_val<std::_Simple_types<wchar_t>>>>,wchar_t const *,uint,std::random_access_iterator_tag)+4Cp
.text$mn:000036B4                                         ; std::_Debug_range2<std::reverse_iterator<std::_Vector_iterator<std::_Vector_val<std::_Simple_types<wchar_t>>>>>(std::reverse_iterator<std::_Vector_iterator<std::_Vector_val<std::_Simple_types<wchar_t>>>>,std::reverse_iterator<std::_Vector_iterator<std::_Vector_val<std::_Simple_types<wchar_t>>>>,wchar_t const *,uint,std::random_access_iterator_tag)+60p ...
.text$mn:000036B4                 push    ebp
.text$mn:000036B5                 mov     ebp, esp
.text$mn:000036B7                 pop     ebp
.text$mn:000036B8                 retn
.text$mn:000036B8 ??$_Debug_pointer@V?$reverse_iterator@V?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@_W@std@@@std@@@std@@@std@@@std@@YAXAAV?$reverse_iterator@V?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@_W@std@@@std@@@std@@@0@PB_WI@Z endp
.text$mn:000036B8
.text$mn:000036B8 ; ---------------------------------------------------------------------------
.text$mn:000036B9                 align 4
.text$mn:000036B9 _text$mn        ends
.text$mn:000036B9
.text$mn:000036BC ; ===========================================================================
.text$mn:000036BC
.text$mn:000036BC ; Segment type: Pure code
.text$mn:000036BC ; Segment permissions: Read/Execute
.text$mn:000036BC _text$mn        segment para public 'CODE' use32
.text$mn:000036BC                 assume cs:_text$mn
.text$mn:000036BC                 ;org 36BCh
.text$mn:000036BC ; COMDAT (pick any)
.text$mn:000036BC                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text$mn:000036BC
.text$mn:000036BC ; =============== S U B R O U T I N E =======================================
.text$mn:000036BC
.text$mn:000036BC ; Attributes: bp-based frame
.text$mn:000036BC
.text$mn:000036BC ; int __cdecl std::_Debug_pointer<wchar_t>(int, wchar_t *, unsigned int)
.text$mn:000036BC                 public ??$_Debug_pointer@_W@std@@YAXPA_WPB_WI@Z
.text$mn:000036BC ??$_Debug_pointer@_W@std@@YAXPA_WPB_WI@Z proc near
.text$mn:000036BC                                         ; CODE XREF: std::_Debug_range2<wchar_t *>(wchar_t *,wchar_t *,wchar_t const *,uint,std::random_access_iterator_tag)+17p
.text$mn:000036BC                                         ; std::_Debug_range2<wchar_t *>(wchar_t *,wchar_t *,wchar_t const *,uint,std::random_access_iterator_tag)+2Bp ...
.text$mn:000036BC
.text$mn:000036BC arg_0           = dword ptr  8
.text$mn:000036BC arg_4           = dword ptr  0Ch
.text$mn:000036BC arg_8           = dword ptr  10h
.text$mn:000036BC
.text$mn:000036BC                 push    ebp
.text$mn:000036BD                 mov     ebp, esp
.text$mn:000036BF                 cmp     [ebp+arg_0], 0
.text$mn:000036C3                 jnz     short loc_36DA
.text$mn:000036C5                 mov     eax, [ebp+arg_8]
.text$mn:000036C8                 push    eax             ; unsigned int
.text$mn:000036C9                 mov     ecx, [ebp+arg_4]
.text$mn:000036CC                 push    ecx             ; wchar_t *
.text$mn:000036CD                 push    offset ??_C@_1CK@EOPGIILJ@?$AAi?$AAn?$AAv?$AAa?$AAl?$AAi?$AAd?$AA?5?$AAn?$AAu?$AAl?$AAl?$AA?5?$AAp?$AAo?$AAi?$AAn?$AAt?$AAe?$AAr?$AA?$AA@ ; "invalid null pointer"
.text$mn:000036D2                 call    ?_Debug_message@std@@YAXPB_W0I@Z ; std::_Debug_message(wchar_t const *,wchar_t const *,uint)
.text$mn:000036D7                 add     esp, 0Ch
.text$mn:000036DA
.text$mn:000036DA loc_36DA:                               ; CODE XREF: std::_Debug_pointer<wchar_t>(wchar_t *,wchar_t const *,uint)+7j
.text$mn:000036DA                 pop     ebp
.text$mn:000036DB                 retn
.text$mn:000036DB ??$_Debug_pointer@_W@std@@YAXPA_WPB_WI@Z endp
.text$mn:000036DB
.text$mn:000036DB _text$mn        ends
.text$mn:000036DB
.text$mn:000036DC ; ===========================================================================
.text$mn:000036DC
.text$mn:000036DC ; Segment type: Pure code
.text$mn:000036DC ; Segment permissions: Read/Execute
.text$mn:000036DC _text$mn        segment para public 'CODE' use32
.text$mn:000036DC                 assume cs:_text$mn
.text$mn:000036DC                 ;org 36DCh
.text$mn:000036DC ; COMDAT (pick any)
.text$mn:000036DC                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text$mn:000036DC
.text$mn:000036DC ; =============== S U B R O U T I N E =======================================
.text$mn:000036DC
.text$mn:000036DC ; Attributes: bp-based frame
.text$mn:000036DC
.text$mn:000036DC ; int __cdecl std::_Debug_pointer<wchar_t>(int, wchar_t *, unsigned int)
.text$mn:000036DC                 public ??$_Debug_pointer@_W@std@@YAXPB_W0I@Z
.text$mn:000036DC ??$_Debug_pointer@_W@std@@YAXPB_W0I@Z proc near
.text$mn:000036DC                                         ; CODE XREF: std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>>::append(wchar_t const *)+15p
.text$mn:000036DC                                         ; std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>>::append(wchar_t const *,uint)+1Dp ...
.text$mn:000036DC
.text$mn:000036DC arg_0           = dword ptr  8
.text$mn:000036DC arg_4           = dword ptr  0Ch
.text$mn:000036DC arg_8           = dword ptr  10h
.text$mn:000036DC
.text$mn:000036DC                 push    ebp
.text$mn:000036DD                 mov     ebp, esp
.text$mn:000036DF                 cmp     [ebp+arg_0], 0
.text$mn:000036E3                 jnz     short loc_36FA
.text$mn:000036E5                 mov     eax, [ebp+arg_8]
.text$mn:000036E8                 push    eax             ; unsigned int
.text$mn:000036E9                 mov     ecx, [ebp+arg_4]
.text$mn:000036EC                 push    ecx             ; wchar_t *
.text$mn:000036ED                 push    offset ??_C@_1CK@EOPGIILJ@?$AAi?$AAn?$AAv?$AAa?$AAl?$AAi?$AAd?$AA?5?$AAn?$AAu?$AAl?$AAl?$AA?5?$AAp?$AAo?$AAi?$AAn?$AAt?$AAe?$AAr?$AA?$AA@ ; "invalid null pointer"
.text$mn:000036F2                 call    ?_Debug_message@std@@YAXPB_W0I@Z ; std::_Debug_message(wchar_t const *,wchar_t const *,uint)
.text$mn:000036F7                 add     esp, 0Ch
.text$mn:000036FA
.text$mn:000036FA loc_36FA:                               ; CODE XREF: std::_Debug_pointer<wchar_t>(wchar_t const *,wchar_t const *,uint)+7j
.text$mn:000036FA                 pop     ebp
.text$mn:000036FB                 retn
.text$mn:000036FB ??$_Debug_pointer@_W@std@@YAXPB_W0I@Z endp
.text$mn:000036FB
.text$mn:000036FB _text$mn        ends
.text$mn:000036FB
.text$mn:000036FC ; ===========================================================================
.text$mn:000036FC
.text$mn:000036FC ; Segment type: Pure code
.text$mn:000036FC ; Segment permissions: Read/Execute
.text$mn:000036FC _text$mn        segment para public 'CODE' use32
.text$mn:000036FC                 assume cs:_text$mn
.text$mn:000036FC                 ;org 36FCh
.text$mn:000036FC ; COMDAT (pick any)
.text$mn:000036FC                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text$mn:000036FC
.text$mn:000036FC ; =============== S U B R O U T I N E =======================================
.text$mn:000036FC
.text$mn:000036FC ; Attributes: bp-based frame
.text$mn:000036FC
.text$mn:000036FC ; int __cdecl std::_Debug_range2<std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>> *>(int, int, wchar_t *, unsigned int)
.text$mn:000036FC                 public ??$_Debug_range2@PAV?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@@std@@YAXPAV?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@0@0PB_WIUrandom_access_iterator_tag@0@@Z
.text$mn:000036FC ??$_Debug_range2@PAV?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@@std@@YAXPAV?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@0@0PB_WIUrandom_access_iterator_tag@0@@Z proc near
.text$mn:000036FC                                         ; CODE XREF: std::_Debug_range<std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>> *>(std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>> *,std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>> *,wchar_t const *,uint)+2Ap
.text$mn:000036FC
.text$mn:000036FC arg_0           = dword ptr  8
.text$mn:000036FC arg_4           = dword ptr  0Ch
.text$mn:000036FC arg_8           = dword ptr  10h
.text$mn:000036FC arg_C           = dword ptr  14h
.text$mn:000036FC
.text$mn:000036FC                 push    ebp
.text$mn:000036FD                 mov     ebp, esp
.text$mn:000036FF                 mov     eax, [ebp+arg_0]
.text$mn:00003702                 cmp     eax, [ebp+arg_4]
.text$mn:00003705                 jz      short loc_374C
.text$mn:00003707                 mov     ecx, [ebp+arg_C]
.text$mn:0000370A                 push    ecx             ; unsigned int
.text$mn:0000370B                 mov     edx, [ebp+arg_8]
.text$mn:0000370E                 push    edx             ; wchar_t *
.text$mn:0000370F                 mov     eax, [ebp+arg_0]
.text$mn:00003712                 push    eax             ; int
.text$mn:00003713                 call    ??$_Debug_pointer@V?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@@std@@YAXPAV?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@0@PB_WI@Z ; std::_Debug_pointer<std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>>>(std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>> *,wchar_t const *,uint)
.text$mn:00003718                 add     esp, 0Ch
.text$mn:0000371B                 mov     ecx, [ebp+arg_C]
.text$mn:0000371E                 push    ecx             ; unsigned int
.text$mn:0000371F                 mov     edx, [ebp+arg_8]
.text$mn:00003722                 push    edx             ; wchar_t *
.text$mn:00003723                 mov     eax, [ebp+arg_4]
.text$mn:00003726                 push    eax             ; int
.text$mn:00003727                 call    ??$_Debug_pointer@V?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@@std@@YAXPAV?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@0@PB_WI@Z ; std::_Debug_pointer<std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>>>(std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>> *,wchar_t const *,uint)
.text$mn:0000372C                 add     esp, 0Ch
.text$mn:0000372F                 mov     ecx, [ebp+arg_4]
.text$mn:00003732                 cmp     ecx, [ebp+arg_0]
.text$mn:00003735                 jnb     short loc_374C
.text$mn:00003737                 mov     edx, [ebp+arg_C]
.text$mn:0000373A                 push    edx             ; unsigned int
.text$mn:0000373B                 mov     eax, [ebp+arg_8]
.text$mn:0000373E                 push    eax             ; wchar_t *
.text$mn:0000373F                 push    offset ??_C@_1CO@DGLIKNHI@?$AAi?$AAn?$AAv?$AAa?$AAl?$AAi?$AAd?$AA?5?$AAi?$AAt?$AAe?$AAr?$AAa?$AAt?$AAo?$AAr?$AA?5?$AAr?$AAa?$AAn?$AAg?$AAe?$AA?$AA@ ; "invalid iterator range"
.text$mn:00003744                 call    ?_Debug_message@std@@YAXPB_W0I@Z ; std::_Debug_message(wchar_t const *,wchar_t const *,uint)
.text$mn:00003749                 add     esp, 0Ch
.text$mn:0000374C
.text$mn:0000374C loc_374C:                               ; CODE XREF: std::_Debug_range2<std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>> *>(std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>> *,std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>> *,wchar_t const *,uint,std::random_access_iterator_tag)+9j
.text$mn:0000374C                                         ; std::_Debug_range2<std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>> *>(std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>> *,std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>> *,wchar_t const *,uint,std::random_access_iterator_tag)+39j
.text$mn:0000374C                 pop     ebp
.text$mn:0000374D                 retn
.text$mn:0000374D ??$_Debug_range2@PAV?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@@std@@YAXPAV?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@0@0PB_WIUrandom_access_iterator_tag@0@@Z endp
.text$mn:0000374D
.text$mn:0000374D ; ---------------------------------------------------------------------------
.text$mn:0000374E                 align 10h
.text$mn:0000374E _text$mn        ends
.text$mn:0000374E
.text$mn:00003750 ; ===========================================================================
.text$mn:00003750
.text$mn:00003750 ; Segment type: Pure code
.text$mn:00003750 ; Segment permissions: Read/Execute
.text$mn:00003750 _text$mn        segment para public 'CODE' use32
.text$mn:00003750                 assume cs:_text$mn
.text$mn:00003750                 ;org 3750h
.text$mn:00003750 ; COMDAT (pick any)
.text$mn:00003750                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text$mn:00003750
.text$mn:00003750 ; =============== S U B R O U T I N E =======================================
.text$mn:00003750
.text$mn:00003750 ; Attributes: bp-based frame
.text$mn:00003750
.text$mn:00003750 ; int __cdecl std::_Debug_range2<wchar_t *>(int, int, wchar_t *, unsigned int)
.text$mn:00003750                 public ??$_Debug_range2@PA_W@std@@YAXPA_W0PB_WIUrandom_access_iterator_tag@0@@Z
.text$mn:00003750 ??$_Debug_range2@PA_W@std@@YAXPA_W0PB_WIUrandom_access_iterator_tag@0@@Z proc near
.text$mn:00003750                                         ; CODE XREF: std::_Debug_range<wchar_t *>(wchar_t *,wchar_t *,wchar_t const *,uint)+2Ap
.text$mn:00003750
.text$mn:00003750 arg_0           = dword ptr  8
.text$mn:00003750 arg_4           = dword ptr  0Ch
.text$mn:00003750 arg_8           = dword ptr  10h
.text$mn:00003750 arg_C           = dword ptr  14h
.text$mn:00003750
.text$mn:00003750                 push    ebp
.text$mn:00003751                 mov     ebp, esp
.text$mn:00003753                 mov     eax, [ebp+arg_0]
.text$mn:00003756                 cmp     eax, [ebp+arg_4]
.text$mn:00003759                 jz      short loc_37A0
.text$mn:0000375B                 mov     ecx, [ebp+arg_C]
.text$mn:0000375E                 push    ecx             ; unsigned int
.text$mn:0000375F                 mov     edx, [ebp+arg_8]
.text$mn:00003762                 push    edx             ; wchar_t *
.text$mn:00003763                 mov     eax, [ebp+arg_0]
.text$mn:00003766                 push    eax             ; int
.text$mn:00003767                 call    ??$_Debug_pointer@_W@std@@YAXPA_WPB_WI@Z ; std::_Debug_pointer<wchar_t>(wchar_t *,wchar_t const *,uint)
.text$mn:0000376C                 add     esp, 0Ch
.text$mn:0000376F                 mov     ecx, [ebp+arg_C]
.text$mn:00003772                 push    ecx             ; unsigned int
.text$mn:00003773                 mov     edx, [ebp+arg_8]
.text$mn:00003776                 push    edx             ; wchar_t *
.text$mn:00003777                 mov     eax, [ebp+arg_4]
.text$mn:0000377A                 push    eax             ; int
.text$mn:0000377B                 call    ??$_Debug_pointer@_W@std@@YAXPA_WPB_WI@Z ; std::_Debug_pointer<wchar_t>(wchar_t *,wchar_t const *,uint)
.text$mn:00003780                 add     esp, 0Ch
.text$mn:00003783                 mov     ecx, [ebp+arg_4]
.text$mn:00003786                 cmp     ecx, [ebp+arg_0]
.text$mn:00003789                 jnb     short loc_37A0
.text$mn:0000378B                 mov     edx, [ebp+arg_C]
.text$mn:0000378E                 push    edx             ; unsigned int
.text$mn:0000378F                 mov     eax, [ebp+arg_8]
.text$mn:00003792                 push    eax             ; wchar_t *
.text$mn:00003793                 push    offset ??_C@_1CO@DGLIKNHI@?$AAi?$AAn?$AAv?$AAa?$AAl?$AAi?$AAd?$AA?5?$AAi?$AAt?$AAe?$AAr?$AAa?$AAt?$AAo?$AAr?$AA?5?$AAr?$AAa?$AAn?$AAg?$AAe?$AA?$AA@ ; "invalid iterator range"
.text$mn:00003798                 call    ?_Debug_message@std@@YAXPB_W0I@Z ; std::_Debug_message(wchar_t const *,wchar_t const *,uint)
.text$mn:0000379D                 add     esp, 0Ch
.text$mn:000037A0
.text$mn:000037A0 loc_37A0:                               ; CODE XREF: std::_Debug_range2<wchar_t *>(wchar_t *,wchar_t *,wchar_t const *,uint,std::random_access_iterator_tag)+9j
.text$mn:000037A0                                         ; std::_Debug_range2<wchar_t *>(wchar_t *,wchar_t *,wchar_t const *,uint,std::random_access_iterator_tag)+39j
.text$mn:000037A0                 pop     ebp
.text$mn:000037A1                 retn
.text$mn:000037A1 ??$_Debug_range2@PA_W@std@@YAXPA_W0PB_WIUrandom_access_iterator_tag@0@@Z endp
.text$mn:000037A1
.text$mn:000037A1 ; ---------------------------------------------------------------------------
.text$mn:000037A2                 align 4
.text$mn:000037A2 _text$mn        ends
.text$mn:000037A2
.text$mn:000037A4 ; ===========================================================================
.text$mn:000037A4
.text$mn:000037A4 ; Segment type: Pure code
.text$mn:000037A4 ; Segment permissions: Read/Execute
.text$mn:000037A4 _text$mn        segment para public 'CODE' use32
.text$mn:000037A4                 assume cs:_text$mn
.text$mn:000037A4                 ;org 37A4h
.text$mn:000037A4 ; COMDAT (pick any)
.text$mn:000037A4                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text$mn:000037A4
.text$mn:000037A4 ; =============== S U B R O U T I N E =======================================
.text$mn:000037A4
.text$mn:000037A4 ; Attributes: bp-based frame
.text$mn:000037A4
.text$mn:000037A4 ; int __cdecl std::_Debug_range2<std::_String_iterator<std::_String_val<std::_Simple_types<wchar_t>>>>(char, int, int, char, int, int, wchar_t *, unsigned int)
.text$mn:000037A4                 public ??$_Debug_range2@V?$_String_iterator@V?$_String_val@U?$_Simple_types@_W@std@@@std@@@std@@@std@@YAXV?$_String_iterator@V?$_String_val@U?$_Simple_types@_W@std@@@std@@@0@0PB_WIUrandom_access_iterator_tag@0@@Z
.text$mn:000037A4 ??$_Debug_range2@V?$_String_iterator@V?$_String_val@U?$_Simple_types@_W@std@@@std@@@std@@@std@@YAXV?$_String_iterator@V?$_String_val@U?$_Simple_types@_W@std@@@std@@@0@0PB_WIUrandom_access_iterator_tag@0@@Z proc near
.text$mn:000037A4                                         ; CODE XREF: std::_Debug_range<std::_String_iterator<std::_String_val<std::_Simple_types<wchar_t>>>>(std::_String_iterator<std::_String_val<std::_Simple_types<wchar_t>>>,std::_String_iterator<std::_String_val<std::_Simple_types<wchar_t>>>,wchar_t const *,uint)+8Ap
.text$mn:000037A4
.text$mn:000037A4 var_C           = dword ptr -0Ch
.text$mn:000037A4 var_4           = dword ptr -4
.text$mn:000037A4 arg_0           = byte ptr  8
.text$mn:000037A4 arg_C           = byte ptr  14h
.text$mn:000037A4 arg_18          = dword ptr  20h
.text$mn:000037A4 arg_1C          = dword ptr  24h
.text$mn:000037A4
.text$mn:000037A4                 push    ebp
.text$mn:000037A5                 mov     ebp, esp
.text$mn:000037A7                 push    0FFFFFFFFh
.text$mn:000037A9                 push    offset __ehhandler$??$_Debug_range2@V?$_String_iterator@V?$_String_val@U?$_Simple_types@_W@std@@@std@@@std@@@std@@YAXV?$_String_iterator@V?$_String_val@U?$_Simple_types@_W@std@@@std@@@0@0PB_WIUrandom_access_iterator_tag@0@@Z
.text$mn:000037AE                 mov     eax, large fs:0
.text$mn:000037B4                 push    eax
.text$mn:000037B5                 mov     eax, dword ptr ds:___security_cookie
.text$mn:000037BA                 xor     eax, ebp
.text$mn:000037BC                 push    eax
.text$mn:000037BD                 lea     eax, [ebp+var_C]
.text$mn:000037C0                 mov     large fs:0, eax
.text$mn:000037C6                 mov     [ebp+var_4], 1
.text$mn:000037CD                 lea     eax, [ebp+arg_C]
.text$mn:000037D0                 push    eax             ; std::_Iterator_base12 *
.text$mn:000037D1                 lea     ecx, [ebp+arg_0]
.text$mn:000037D4                 call    ??9?$_String_const_iterator@V?$_String_val@U?$_Simple_types@_W@std@@@std@@@std@@QBE_NABV01@@Z ; std::_String_const_iterator<std::_String_val<std::_Simple_types<wchar_t>>>::operator!=(std::_String_const_iterator<std::_String_val<std::_Simple_types<wchar_t>>> const &)
.text$mn:000037D9                 movzx   ecx, al
.text$mn:000037DC                 test    ecx, ecx
.text$mn:000037DE                 jz      short loc_3830
.text$mn:000037E0                 mov     edx, [ebp+arg_1C]
.text$mn:000037E3                 push    edx
.text$mn:000037E4                 mov     eax, [ebp+arg_18]
.text$mn:000037E7                 push    eax
.text$mn:000037E8                 lea     ecx, [ebp+arg_0]
.text$mn:000037EB                 push    ecx
.text$mn:000037EC                 call    ??$_Debug_pointer@V?$_String_iterator@V?$_String_val@U?$_Simple_types@_W@std@@@std@@@std@@@std@@YAXAAV?$_String_iterator@V?$_String_val@U?$_Simple_types@_W@std@@@std@@@0@PB_WI@Z ; std::_Debug_pointer<std::_String_iterator<std::_String_val<std::_Simple_types<wchar_t>>>>(std::_String_iterator<std::_String_val<std::_Simple_types<wchar_t>>> &,wchar_t const *,uint)
.text$mn:000037F1                 add     esp, 0Ch
.text$mn:000037F4                 mov     edx, [ebp+arg_1C]
.text$mn:000037F7                 push    edx
.text$mn:000037F8                 mov     eax, [ebp+arg_18]
.text$mn:000037FB                 push    eax
.text$mn:000037FC                 lea     ecx, [ebp+arg_C]
.text$mn:000037FF                 push    ecx
.text$mn:00003800                 call    ??$_Debug_pointer@V?$_String_iterator@V?$_String_val@U?$_Simple_types@_W@std@@@std@@@std@@@std@@YAXAAV?$_String_iterator@V?$_String_val@U?$_Simple_types@_W@std@@@std@@@0@PB_WI@Z ; std::_Debug_pointer<std::_String_iterator<std::_String_val<std::_Simple_types<wchar_t>>>>(std::_String_iterator<std::_String_val<std::_Simple_types<wchar_t>>> &,wchar_t const *,uint)
.text$mn:00003805                 add     esp, 0Ch
.text$mn:00003808                 lea     edx, [ebp+arg_0]
.text$mn:0000380B                 push    edx             ; std::_Iterator_base12 *
.text$mn:0000380C                 lea     ecx, [ebp+arg_C]
.text$mn:0000380F                 call    ??M?$_String_const_iterator@V?$_String_val@U?$_Simple_types@_W@std@@@std@@@std@@QBE_NABV01@@Z ; std::_String_const_iterator<std::_String_val<std::_Simple_types<wchar_t>>>::operator<(std::_String_const_iterator<std::_String_val<std::_Simple_types<wchar_t>>> const &)
.text$mn:00003814                 movzx   eax, al
.text$mn:00003817                 test    eax, eax
.text$mn:00003819                 jz      short loc_3830
.text$mn:0000381B                 mov     ecx, [ebp+arg_1C]
.text$mn:0000381E                 push    ecx             ; unsigned int
.text$mn:0000381F                 mov     edx, [ebp+arg_18]
.text$mn:00003822                 push    edx             ; wchar_t *
.text$mn:00003823                 push    offset ??_C@_1CO@DGLIKNHI@?$AAi?$AAn?$AAv?$AAa?$AAl?$AAi?$AAd?$AA?5?$AAi?$AAt?$AAe?$AAr?$AAa?$AAt?$AAo?$AAr?$AA?5?$AAr?$AAa?$AAn?$AAg?$AAe?$AA?$AA@ ; "invalid iterator range"
.text$mn:00003828                 call    ?_Debug_message@std@@YAXPB_W0I@Z ; std::_Debug_message(wchar_t const *,wchar_t const *,uint)
.text$mn:0000382D                 add     esp, 0Ch
.text$mn:00003830
.text$mn:00003830 loc_3830:                               ; CODE XREF: std::_Debug_range2<std::_String_iterator<std::_String_val<std::_Simple_types<wchar_t>>>>(std::_String_iterator<std::_String_val<std::_Simple_types<wchar_t>>>,std::_String_iterator<std::_String_val<std::_Simple_types<wchar_t>>>,wchar_t const *,uint,std::random_access_iterator_tag)+3Aj
.text$mn:00003830                                         ; std::_Debug_range2<std::_String_iterator<std::_String_val<std::_Simple_types<wchar_t>>>>(std::_String_iterator<std::_String_val<std::_Simple_types<wchar_t>>>,std::_String_iterator<std::_String_val<std::_Simple_types<wchar_t>>>,wchar_t const *,uint,std::random_access_iterator_tag)+75j
.text$mn:00003830                 mov     byte ptr [ebp+var_4], 0
.text$mn:00003834                 lea     ecx, [ebp+arg_0]
.text$mn:00003837                 call    ??1?$_String_iterator@V?$_String_val@U?$_Simple_types@_W@std@@@std@@@std@@QAE@XZ ; std::_String_iterator<std::_String_val<std::_Simple_types<wchar_t>>>::~_String_iterator<std::_String_val<std::_Simple_types<wchar_t>>>(void)
.text$mn:0000383C                 mov     [ebp+var_4], 0FFFFFFFFh
.text$mn:00003843                 lea     ecx, [ebp+arg_C]
.text$mn:00003846                 call    ??1?$_String_iterator@V?$_String_val@U?$_Simple_types@_W@std@@@std@@@std@@QAE@XZ ; std::_String_iterator<std::_String_val<std::_Simple_types<wchar_t>>>::~_String_iterator<std::_String_val<std::_Simple_types<wchar_t>>>(void)
.text$mn:0000384B                 mov     ecx, [ebp+var_C]
.text$mn:0000384E                 mov     large fs:0, ecx
.text$mn:00003855                 pop     ecx
.text$mn:00003856                 mov     esp, ebp
.text$mn:00003858                 pop     ebp
.text$mn:00003859                 retn
.text$mn:00003859 ??$_Debug_range2@V?$_String_iterator@V?$_String_val@U?$_Simple_types@_W@std@@@std@@@std@@@std@@YAXV?$_String_iterator@V?$_String_val@U?$_Simple_types@_W@std@@@std@@@0@0PB_WIUrandom_access_iterator_tag@0@@Z endp
.text$mn:00003859
.text$mn:00003859 ; ---------------------------------------------------------------------------
.text$mn:0000385A                 align 4
.text$mn:0000385A _text$mn        ends
.text$mn:0000385A
.text$x:0000385C ; ===========================================================================
.text$x:0000385C
.text$x:0000385C ; Segment type: Pure code
.text$x:0000385C ; Segment permissions: Read/Execute
.text$x:0000385C _text$x         segment para public 'CODE' use32
.text$x:0000385C                 assume cs:_text$x
.text$x:0000385C                 ;org 385Ch
.text$x:0000385C ; COMDAT (pick associative to section at 37A4)
.text$x:0000385C                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text$x:0000385C
.text$x:0000385C ; =============== S U B R O U T I N E =======================================
.text$x:0000385C
.text$x:0000385C
.text$x:0000385C __unwindfunclet$??$_Debug_range2@V?$_String_iterator@V?$_String_val@U?$_Simple_types@_W@std@@@std@@@std@@@std@@YAXV?$_String_iterator@V?$_String_val@U?$_Simple_types@_W@std@@@std@@@0@0PB_WIUrandom_access_iterator_tag@0@@Z$0 proc near
.text$x:0000385C                                         ; DATA XREF: .xdata$x:0000EFFCo
.text$x:0000385C                 lea     ecx, [ebp+14h]
.text$x:0000385F                 jmp     ??1?$_String_iterator@V?$_String_val@U?$_Simple_types@_W@std@@@std@@@std@@QAE@XZ ; std::_String_iterator<std::_String_val<std::_Simple_types<wchar_t>>>::~_String_iterator<std::_String_val<std::_Simple_types<wchar_t>>>(void)
.text$x:0000385F __unwindfunclet$??$_Debug_range2@V?$_String_iterator@V?$_String_val@U?$_Simple_types@_W@std@@@std@@@std@@@std@@YAXV?$_String_iterator@V?$_String_val@U?$_Simple_types@_W@std@@@std@@@0@0PB_WIUrandom_access_iterator_tag@0@@Z$0 endp
.text$x:0000385F
.text$x:00003864
.text$x:00003864 ; =============== S U B R O U T I N E =======================================
.text$x:00003864
.text$x:00003864
.text$x:00003864 __unwindfunclet$??$_Debug_range2@V?$_String_iterator@V?$_String_val@U?$_Simple_types@_W@std@@@std@@@std@@@std@@YAXV?$_String_iterator@V?$_String_val@U?$_Simple_types@_W@std@@@std@@@0@0PB_WIUrandom_access_iterator_tag@0@@Z$1 proc near
.text$x:00003864                                         ; DATA XREF: .xdata$x:0000F004o
.text$x:00003864                 lea     ecx, [ebp+8]
.text$x:00003867                 jmp     ??1?$_String_iterator@V?$_String_val@U?$_Simple_types@_W@std@@@std@@@std@@QAE@XZ ; std::_String_iterator<std::_String_val<std::_Simple_types<wchar_t>>>::~_String_iterator<std::_String_val<std::_Simple_types<wchar_t>>>(void)
.text$x:00003867 __unwindfunclet$??$_Debug_range2@V?$_String_iterator@V?$_String_val@U?$_Simple_types@_W@std@@@std@@@std@@@std@@YAXV?$_String_iterator@V?$_String_val@U?$_Simple_types@_W@std@@@std@@@0@0PB_WIUrandom_access_iterator_tag@0@@Z$1 endp
.text$x:00003867
.text$x:0000386C
.text$x:0000386C ; =============== S U B R O U T I N E =======================================
.text$x:0000386C
.text$x:0000386C
.text$x:0000386C __ehhandler$??$_Debug_range2@V?$_String_iterator@V?$_String_val@U?$_Simple_types@_W@std@@@std@@@std@@@std@@YAXV?$_String_iterator@V?$_String_val@U?$_Simple_types@_W@std@@@std@@@0@0PB_WIUrandom_access_iterator_tag@0@@Z proc near
.text$x:0000386C                                         ; DATA XREF: std::_Debug_range2<std::_String_iterator<std::_String_val<std::_Simple_types<wchar_t>>>>(std::_String_iterator<std::_String_val<std::_Simple_types<wchar_t>>>,std::_String_iterator<std::_String_val<std::_Simple_types<wchar_t>>>,wchar_t const *,uint,std::random_access_iterator_tag)+5o
.text$x:0000386C
.text$x:0000386C arg_4           = dword ptr  8
.text$x:0000386C
.text$x:0000386C                 mov     edx, [esp+arg_4]
.text$x:00003870                 lea     eax, [edx+0Ch]
.text$x:00003873                 mov     ecx, [edx-4]
.text$x:00003876                 xor     ecx, eax
.text$x:00003878                 call    @__security_check_cookie@4 ; __security_check_cookie(x)
.text$x:0000387D                 mov     eax, offset __ehfuncinfo$??$_Debug_range2@V?$_String_iterator@V?$_String_val@U?$_Simple_types@_W@std@@@std@@@std@@@std@@YAXV?$_String_iterator@V?$_String_val@U?$_Simple_types@_W@std@@@std@@@0@0PB_WIUrandom_access_iterator_tag@0@@Z
.text$x:00003882                 jmp     ___CxxFrameHandler3
.text$x:00003882 __ehhandler$??$_Debug_range2@V?$_String_iterator@V?$_String_val@U?$_Simple_types@_W@std@@@std@@@std@@@std@@YAXV?$_String_iterator@V?$_String_val@U?$_Simple_types@_W@std@@@std@@@0@0PB_WIUrandom_access_iterator_tag@0@@Z endp
.text$x:00003882
.text$x:00003882 ; ---------------------------------------------------------------------------
.text$x:00003887                 align 4
.text$x:00003887 _text$x         ends
.text$x:00003887
.text$mn:00003888 ; ===========================================================================
.text$mn:00003888
.text$mn:00003888 ; Segment type: Pure code
.text$mn:00003888 ; Segment permissions: Read/Execute
.text$mn:00003888 _text$mn        segment para public 'CODE' use32
.text$mn:00003888                 assume cs:_text$mn
.text$mn:00003888                 ;org 3888h
.text$mn:00003888 ; COMDAT (pick any)
.text$mn:00003888                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text$mn:00003888
.text$mn:00003888 ; =============== S U B R O U T I N E =======================================
.text$mn:00003888
.text$mn:00003888 ; Attributes: bp-based frame
.text$mn:00003888
.text$mn:00003888 ; int __cdecl std::_Debug_range2<std::reverse_iterator<std::_Vector_iterator<std::_Vector_val<std::_Simple_types<wchar_t>>>>>(char, int, int, char, int, int, wchar_t *, unsigned int)
.text$mn:00003888                 public ??$_Debug_range2@V?$reverse_iterator@V?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@_W@std@@@std@@@std@@@std@@@std@@YAXV?$reverse_iterator@V?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@_W@std@@@std@@@std@@@0@0PB_WIUrandom_access_iterator_tag@0@@Z
.text$mn:00003888 ??$_Debug_range2@V?$reverse_iterator@V?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@_W@std@@@std@@@std@@@std@@@std@@YAXV?$reverse_iterator@V?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@_W@std@@@std@@@std@@@0@0PB_WIUrandom_access_iterator_tag@0@@Z proc near
.text$mn:00003888                                         ; CODE XREF: std::_Debug_range<std::reverse_iterator<std::_Vector_iterator<std::_Vector_val<std::_Simple_types<wchar_t>>>>>(std::reverse_iterator<std::_Vector_iterator<std::_Vector_val<std::_Simple_types<wchar_t>>>>,std::reverse_iterator<std::_Vector_iterator<std::_Vector_val<std::_Simple_types<wchar_t>>>>,wchar_t const *,uint)+8Ap
.text$mn:00003888
.text$mn:00003888 var_C           = dword ptr -0Ch
.text$mn:00003888 var_4           = dword ptr -4
.text$mn:00003888 arg_0           = byte ptr  8
.text$mn:00003888 arg_C           = byte ptr  14h
.text$mn:00003888 arg_18          = dword ptr  20h
.text$mn:00003888 arg_1C          = dword ptr  24h
.text$mn:00003888
.text$mn:00003888                 push    ebp
.text$mn:00003889                 mov     ebp, esp
.text$mn:0000388B                 push    0FFFFFFFFh
.text$mn:0000388D                 push    offset __ehhandler$??$_Debug_range2@V?$reverse_iterator@V?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@_W@std@@@std@@@std@@@std@@@std@@YAXV?$reverse_iterator@V?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@_W@std@@@std@@@std@@@0@0PB_WIUrandom_access_iterator_tag@0@@Z
.text$mn:00003892                 mov     eax, large fs:0
.text$mn:00003898                 push    eax
.text$mn:00003899                 mov     eax, dword ptr ds:___security_cookie
.text$mn:0000389E                 xor     eax, ebp
.text$mn:000038A0                 push    eax
.text$mn:000038A1                 lea     eax, [ebp+var_C]
.text$mn:000038A4                 mov     large fs:0, eax
.text$mn:000038AA                 mov     [ebp+var_4], 1
.text$mn:000038B1                 lea     eax, [ebp+arg_C]
.text$mn:000038B4                 push    eax
.text$mn:000038B5                 lea     ecx, [ebp+arg_0]
.text$mn:000038B8                 push    ecx
.text$mn:000038B9                 call    ??$?9V?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@_W@std@@@std@@@std@@V01@@std@@YA_NABV?$reverse_iterator@V?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@_W@std@@@std@@@std@@@0@0@Z ; std::operator!=<std::_Vector_iterator<std::_Vector_val<std::_Simple_types<wchar_t>>>,std::_Vector_iterator<std::_Vector_val<std::_Simple_types<wchar_t>>>>(std::reverse_iterator<std::_Vector_iterator<std::_Vector_val<std::_Simple_types<wchar_t>>>> const &,std::reverse_iterator<std::_Vector_iterator<std::_Vector_val<std::_Simple_types<wchar_t>>>> const &)
.text$mn:000038BE                 add     esp, 8
.text$mn:000038C1                 movzx   edx, al
.text$mn:000038C4                 test    edx, edx
.text$mn:000038C6                 jz      short loc_391C
.text$mn:000038C8                 mov     eax, [ebp+arg_1C]
.text$mn:000038CB                 push    eax
.text$mn:000038CC                 mov     ecx, [ebp+arg_18]
.text$mn:000038CF                 push    ecx
.text$mn:000038D0                 lea     edx, [ebp+arg_0]
.text$mn:000038D3                 push    edx
.text$mn:000038D4                 call    ??$_Debug_pointer@V?$reverse_iterator@V?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@_W@std@@@std@@@std@@@std@@@std@@YAXAAV?$reverse_iterator@V?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@_W@std@@@std@@@std@@@0@PB_WI@Z ; std::_Debug_pointer<std::reverse_iterator<std::_Vector_iterator<std::_Vector_val<std::_Simple_types<wchar_t>>>>>(std::reverse_iterator<std::_Vector_iterator<std::_Vector_val<std::_Simple_types<wchar_t>>>> &,wchar_t const *,uint)
.text$mn:000038D9                 add     esp, 0Ch
.text$mn:000038DC                 mov     eax, [ebp+arg_1C]
.text$mn:000038DF                 push    eax
.text$mn:000038E0                 mov     ecx, [ebp+arg_18]
.text$mn:000038E3                 push    ecx
.text$mn:000038E4                 lea     edx, [ebp+arg_C]
.text$mn:000038E7                 push    edx
.text$mn:000038E8                 call    ??$_Debug_pointer@V?$reverse_iterator@V?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@_W@std@@@std@@@std@@@std@@@std@@YAXAAV?$reverse_iterator@V?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@_W@std@@@std@@@std@@@0@PB_WI@Z ; std::_Debug_pointer<std::reverse_iterator<std::_Vector_iterator<std::_Vector_val<std::_Simple_types<wchar_t>>>>>(std::reverse_iterator<std::_Vector_iterator<std::_Vector_val<std::_Simple_types<wchar_t>>>> &,wchar_t const *,uint)
.text$mn:000038ED                 add     esp, 0Ch
.text$mn:000038F0                 lea     eax, [ebp+arg_0]
.text$mn:000038F3                 push    eax
.text$mn:000038F4                 lea     ecx, [ebp+arg_C]
.text$mn:000038F7                 push    ecx
.text$mn:000038F8                 call    ??$?MV?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@_W@std@@@std@@@std@@V01@@std@@YA_NABV?$reverse_iterator@V?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@_W@std@@@std@@@std@@@0@0@Z ; std::operator<<std::_Vector_iterator<std::_Vector_val<std::_Simple_types<wchar_t>>>,std::_Vector_iterator<std::_Vector_val<std::_Simple_types<wchar_t>>>>(std::reverse_iterator<std::_Vector_iterator<std::_Vector_val<std::_Simple_types<wchar_t>>>> const &,std::reverse_iterator<std::_Vector_iterator<std::_Vector_val<std::_Simple_types<wchar_t>>>> const &)
.text$mn:000038FD                 add     esp, 8
.text$mn:00003900                 movzx   edx, al
.text$mn:00003903                 test    edx, edx
.text$mn:00003905                 jz      short loc_391C
.text$mn:00003907                 mov     eax, [ebp+arg_1C]
.text$mn:0000390A                 push    eax             ; unsigned int
.text$mn:0000390B                 mov     ecx, [ebp+arg_18]
.text$mn:0000390E                 push    ecx             ; wchar_t *
.text$mn:0000390F                 push    offset ??_C@_1CO@DGLIKNHI@?$AAi?$AAn?$AAv?$AAa?$AAl?$AAi?$AAd?$AA?5?$AAi?$AAt?$AAe?$AAr?$AAa?$AAt?$AAo?$AAr?$AA?5?$AAr?$AAa?$AAn?$AAg?$AAe?$AA?$AA@ ; "invalid iterator range"
.text$mn:00003914                 call    ?_Debug_message@std@@YAXPB_W0I@Z ; std::_Debug_message(wchar_t const *,wchar_t const *,uint)
.text$mn:00003919                 add     esp, 0Ch
.text$mn:0000391C
.text$mn:0000391C loc_391C:                               ; CODE XREF: std::_Debug_range2<std::reverse_iterator<std::_Vector_iterator<std::_Vector_val<std::_Simple_types<wchar_t>>>>>(std::reverse_iterator<std::_Vector_iterator<std::_Vector_val<std::_Simple_types<wchar_t>>>>,std::reverse_iterator<std::_Vector_iterator<std::_Vector_val<std::_Simple_types<wchar_t>>>>,wchar_t const *,uint,std::random_access_iterator_tag)+3Ej
.text$mn:0000391C                                         ; std::_Debug_range2<std::reverse_iterator<std::_Vector_iterator<std::_Vector_val<std::_Simple_types<wchar_t>>>>>(std::reverse_iterator<std::_Vector_iterator<std::_Vector_val<std::_Simple_types<wchar_t>>>>,std::reverse_iterator<std::_Vector_iterator<std::_Vector_val<std::_Simple_types<wchar_t>>>>,wchar_t const *,uint,std::random_access_iterator_tag)+7Dj
.text$mn:0000391C                 mov     byte ptr [ebp+var_4], 0
.text$mn:00003920                 lea     ecx, [ebp+arg_0]
.text$mn:00003923                 call    ??1?$reverse_iterator@V?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@_W@std@@@std@@@std@@@std@@QAE@XZ ; std::reverse_iterator<std::_Vector_iterator<std::_Vector_val<std::_Simple_types<wchar_t>>>>::~reverse_iterator<std::_Vector_iterator<std::_Vector_val<std::_Simple_types<wchar_t>>>>(void)
.text$mn:00003928                 mov     [ebp+var_4], 0FFFFFFFFh
.text$mn:0000392F                 lea     ecx, [ebp+arg_C]
.text$mn:00003932                 call    ??1?$reverse_iterator@V?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@_W@std@@@std@@@std@@@std@@QAE@XZ ; std::reverse_iterator<std::_Vector_iterator<std::_Vector_val<std::_Simple_types<wchar_t>>>>::~reverse_iterator<std::_Vector_iterator<std::_Vector_val<std::_Simple_types<wchar_t>>>>(void)
.text$mn:00003937                 mov     ecx, [ebp+var_C]
.text$mn:0000393A                 mov     large fs:0, ecx
.text$mn:00003941                 pop     ecx
.text$mn:00003942                 mov     esp, ebp
.text$mn:00003944                 pop     ebp
.text$mn:00003945                 retn
.text$mn:00003945 ??$_Debug_range2@V?$reverse_iterator@V?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@_W@std@@@std@@@std@@@std@@@std@@YAXV?$reverse_iterator@V?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@_W@std@@@std@@@std@@@0@0PB_WIUrandom_access_iterator_tag@0@@Z endp
.text$mn:00003945
.text$mn:00003945 ; ---------------------------------------------------------------------------
.text$mn:00003946                 align 4
.text$mn:00003946 _text$mn        ends
.text$mn:00003946
.text$x:00003948 ; ===========================================================================
.text$x:00003948
.text$x:00003948 ; Segment type: Pure code
.text$x:00003948 ; Segment permissions: Read/Execute
.text$x:00003948 _text$x         segment para public 'CODE' use32
.text$x:00003948                 assume cs:_text$x
.text$x:00003948                 ;org 3948h
.text$x:00003948 ; COMDAT (pick associative to section at 3888)
.text$x:00003948                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text$x:00003948
.text$x:00003948 ; =============== S U B R O U T I N E =======================================
.text$x:00003948
.text$x:00003948
.text$x:00003948 __unwindfunclet$??$_Debug_range2@V?$reverse_iterator@V?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@_W@std@@@std@@@std@@@std@@@std@@YAXV?$reverse_iterator@V?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@_W@std@@@std@@@std@@@0@0PB_WIUrandom_access_iterator_tag@0@@Z$0 proc near
.text$x:00003948                                         ; DATA XREF: .xdata$x:0000F124o
.text$x:00003948                 lea     ecx, [ebp+14h]
.text$x:0000394B                 jmp     ??1?$reverse_iterator@V?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@_W@std@@@std@@@std@@@std@@QAE@XZ ; std::reverse_iterator<std::_Vector_iterator<std::_Vector_val<std::_Simple_types<wchar_t>>>>::~reverse_iterator<std::_Vector_iterator<std::_Vector_val<std::_Simple_types<wchar_t>>>>(void)
.text$x:0000394B __unwindfunclet$??$_Debug_range2@V?$reverse_iterator@V?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@_W@std@@@std@@@std@@@std@@@std@@YAXV?$reverse_iterator@V?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@_W@std@@@std@@@std@@@0@0PB_WIUrandom_access_iterator_tag@0@@Z$0 endp
.text$x:0000394B
.text$x:00003950
.text$x:00003950 ; =============== S U B R O U T I N E =======================================
.text$x:00003950
.text$x:00003950
.text$x:00003950 __unwindfunclet$??$_Debug_range2@V?$reverse_iterator@V?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@_W@std@@@std@@@std@@@std@@@std@@YAXV?$reverse_iterator@V?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@_W@std@@@std@@@std@@@0@0PB_WIUrandom_access_iterator_tag@0@@Z$1 proc near
.text$x:00003950                                         ; DATA XREF: .xdata$x:0000F12Co
.text$x:00003950                 lea     ecx, [ebp+8]
.text$x:00003953                 jmp     ??1?$reverse_iterator@V?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@_W@std@@@std@@@std@@@std@@QAE@XZ ; std::reverse_iterator<std::_Vector_iterator<std::_Vector_val<std::_Simple_types<wchar_t>>>>::~reverse_iterator<std::_Vector_iterator<std::_Vector_val<std::_Simple_types<wchar_t>>>>(void)
.text$x:00003953 __unwindfunclet$??$_Debug_range2@V?$reverse_iterator@V?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@_W@std@@@std@@@std@@@std@@@std@@YAXV?$reverse_iterator@V?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@_W@std@@@std@@@std@@@0@0PB_WIUrandom_access_iterator_tag@0@@Z$1 endp
.text$x:00003953
.text$x:00003958
.text$x:00003958 ; =============== S U B R O U T I N E =======================================
.text$x:00003958
.text$x:00003958
.text$x:00003958 __ehhandler$??$_Debug_range2@V?$reverse_iterator@V?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@_W@std@@@std@@@std@@@std@@@std@@YAXV?$reverse_iterator@V?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@_W@std@@@std@@@std@@@0@0PB_WIUrandom_access_iterator_tag@0@@Z proc near
.text$x:00003958                                         ; DATA XREF: std::_Debug_range2<std::reverse_iterator<std::_Vector_iterator<std::_Vector_val<std::_Simple_types<wchar_t>>>>>(std::reverse_iterator<std::_Vector_iterator<std::_Vector_val<std::_Simple_types<wchar_t>>>>,std::reverse_iterator<std::_Vector_iterator<std::_Vector_val<std::_Simple_types<wchar_t>>>>,wchar_t const *,uint,std::random_access_iterator_tag)+5o
.text$x:00003958
.text$x:00003958 arg_4           = dword ptr  8
.text$x:00003958
.text$x:00003958                 mov     edx, [esp+arg_4]
.text$x:0000395C                 lea     eax, [edx+0Ch]
.text$x:0000395F                 mov     ecx, [edx-4]
.text$x:00003962                 xor     ecx, eax
.text$x:00003964                 call    @__security_check_cookie@4 ; __security_check_cookie(x)
.text$x:00003969                 mov     eax, offset __ehfuncinfo$??$_Debug_range2@V?$reverse_iterator@V?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@_W@std@@@std@@@std@@@std@@@std@@YAXV?$reverse_iterator@V?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@_W@std@@@std@@@std@@@0@0PB_WIUrandom_access_iterator_tag@0@@Z
.text$x:0000396E                 jmp     ___CxxFrameHandler3
.text$x:0000396E __ehhandler$??$_Debug_range2@V?$reverse_iterator@V?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@_W@std@@@std@@@std@@@std@@@std@@YAXV?$reverse_iterator@V?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@_W@std@@@std@@@std@@@0@0PB_WIUrandom_access_iterator_tag@0@@Z endp
.text$x:0000396E
.text$x:0000396E ; ---------------------------------------------------------------------------
.text$x:00003973                 align 4
.text$x:00003973 _text$x         ends
.text$x:00003973
.text$mn:00003974 ; ===========================================================================
.text$mn:00003974
.text$mn:00003974 ; Segment type: Pure code
.text$mn:00003974 ; Segment permissions: Read/Execute
.text$mn:00003974 _text$mn        segment para public 'CODE' use32
.text$mn:00003974                 assume cs:_text$mn
.text$mn:00003974                 ;org 3974h
.text$mn:00003974 ; COMDAT (pick any)
.text$mn:00003974                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text$mn:00003974
.text$mn:00003974 ; =============== S U B R O U T I N E =======================================
.text$mn:00003974
.text$mn:00003974 ; Attributes: bp-based frame
.text$mn:00003974
.text$mn:00003974 ; int __cdecl std::_Debug_range<std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>> *>(int, int, wchar_t *, unsigned int)
.text$mn:00003974                 public ??$_Debug_range@PAV?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@@std@@YAXPAV?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@0@0PB_WI@Z
.text$mn:00003974 ??$_Debug_range@PAV?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@@std@@YAXPAV?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@0@0PB_WI@Z proc near
.text$mn:00003974                                         ; CODE XREF: std::_Uninit_move<std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>> *,std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>> *,std::allocator<std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>>>,std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>>>(std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>> *,std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>> *,std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>> *,std::_Wrap_alloc<std::allocator<std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>>>> &,std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>> *,std::_Nonscalar_ptr_iterator_tag)+3Cp
.text$mn:00003974
.text$mn:00003974 var_1           = byte ptr -1
.text$mn:00003974 arg_0           = dword ptr  8
.text$mn:00003974 arg_4           = dword ptr  0Ch
.text$mn:00003974 arg_8           = dword ptr  10h
.text$mn:00003974 arg_C           = dword ptr  14h
.text$mn:00003974
.text$mn:00003974                 push    ebp
.text$mn:00003975                 mov     ebp, esp
.text$mn:00003977                 push    ecx
.text$mn:00003978                 lea     eax, [ebp+arg_0]
.text$mn:0000397B                 push    eax
.text$mn:0000397C                 lea     ecx, [ebp+var_1]
.text$mn:0000397F                 push    ecx
.text$mn:00003980                 call    ??$_Iter_cat@PAV?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@@std@@YA?AUrandom_access_iterator_tag@0@ABQAV?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@0@@Z ; std::_Iter_cat<std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>> *>(std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>> * const &)
.text$mn:00003985                 add     esp, 8
.text$mn:00003988                 mov     dl, [eax]
.text$mn:0000398A                 movzx   eax, dl
.text$mn:0000398D                 push    eax
.text$mn:0000398E                 mov     ecx, [ebp+arg_C]
.text$mn:00003991                 push    ecx             ; unsigned int
.text$mn:00003992                 mov     edx, [ebp+arg_8]
.text$mn:00003995                 push    edx             ; wchar_t *
.text$mn:00003996                 mov     eax, [ebp+arg_4]
.text$mn:00003999                 push    eax             ; int
.text$mn:0000399A                 mov     ecx, [ebp+arg_0]
.text$mn:0000399D                 push    ecx             ; int
.text$mn:0000399E                 call    ??$_Debug_range2@PAV?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@@std@@YAXPAV?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@0@0PB_WIUrandom_access_iterator_tag@0@@Z ; std::_Debug_range2<std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>> *>(std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>> *,std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>> *,wchar_t const *,uint,std::random_access_iterator_tag)
.text$mn:000039A3                 add     esp, 14h
.text$mn:000039A6                 mov     esp, ebp
.text$mn:000039A8                 pop     ebp
.text$mn:000039A9                 retn
.text$mn:000039A9 ??$_Debug_range@PAV?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@@std@@YAXPAV?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@0@0PB_WI@Z endp
.text$mn:000039A9
.text$mn:000039A9 ; ---------------------------------------------------------------------------
.text$mn:000039AA                 align 4
.text$mn:000039AA _text$mn        ends
.text$mn:000039AA
.text$mn:000039AC ; ===========================================================================
.text$mn:000039AC
.text$mn:000039AC ; Segment type: Pure code
.text$mn:000039AC ; Segment permissions: Read/Execute
.text$mn:000039AC _text$mn        segment para public 'CODE' use32
.text$mn:000039AC                 assume cs:_text$mn
.text$mn:000039AC                 ;org 39ACh
.text$mn:000039AC ; COMDAT (pick any)
.text$mn:000039AC                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text$mn:000039AC
.text$mn:000039AC ; =============== S U B R O U T I N E =======================================
.text$mn:000039AC
.text$mn:000039AC ; Attributes: bp-based frame
.text$mn:000039AC
.text$mn:000039AC ; int __cdecl std::_Debug_range<wchar_t *>(int, int, wchar_t *, unsigned int)
.text$mn:000039AC                 public ??$_Debug_range@PA_W@std@@YAXPA_W0PB_WI@Z
.text$mn:000039AC ??$_Debug_range@PA_W@std@@YAXPA_W0PB_WI@Z proc near
.text$mn:000039AC                                         ; CODE XREF: std::_Uninit_move<wchar_t,wchar_t,wchar_t>(wchar_t *,wchar_t *,wchar_t *,std::_Wrap_alloc<std::allocator<wchar_t>> &,wchar_t *,std::_Scalar_ptr_iterator_tag)+16p
.text$mn:000039AC
.text$mn:000039AC var_1           = byte ptr -1
.text$mn:000039AC arg_0           = dword ptr  8
.text$mn:000039AC arg_4           = dword ptr  0Ch
.text$mn:000039AC arg_8           = dword ptr  10h
.text$mn:000039AC arg_C           = dword ptr  14h
.text$mn:000039AC
.text$mn:000039AC                 push    ebp
.text$mn:000039AD                 mov     ebp, esp
.text$mn:000039AF                 push    ecx
.text$mn:000039B0                 lea     eax, [ebp+arg_0]
.text$mn:000039B3                 push    eax
.text$mn:000039B4                 lea     ecx, [ebp+var_1]
.text$mn:000039B7                 push    ecx
.text$mn:000039B8                 call    ??$_Iter_cat@PA_W@std@@YA?AUrandom_access_iterator_tag@0@ABQA_W@Z ; std::_Iter_cat<wchar_t *>(wchar_t * const &)
.text$mn:000039BD                 add     esp, 8
.text$mn:000039C0                 mov     dl, [eax]
.text$mn:000039C2                 movzx   eax, dl
.text$mn:000039C5                 push    eax
.text$mn:000039C6                 mov     ecx, [ebp+arg_C]
.text$mn:000039C9                 push    ecx             ; unsigned int
.text$mn:000039CA                 mov     edx, [ebp+arg_8]
.text$mn:000039CD                 push    edx             ; wchar_t *
.text$mn:000039CE                 mov     eax, [ebp+arg_4]
.text$mn:000039D1                 push    eax             ; int
.text$mn:000039D2                 mov     ecx, [ebp+arg_0]
.text$mn:000039D5                 push    ecx             ; int
.text$mn:000039D6                 call    ??$_Debug_range2@PA_W@std@@YAXPA_W0PB_WIUrandom_access_iterator_tag@0@@Z ; std::_Debug_range2<wchar_t *>(wchar_t *,wchar_t *,wchar_t const *,uint,std::random_access_iterator_tag)
.text$mn:000039DB                 add     esp, 14h
.text$mn:000039DE                 mov     esp, ebp
.text$mn:000039E0                 pop     ebp
.text$mn:000039E1                 retn
.text$mn:000039E1 ??$_Debug_range@PA_W@std@@YAXPA_W0PB_WI@Z endp
.text$mn:000039E1
.text$mn:000039E1 ; ---------------------------------------------------------------------------
.text$mn:000039E2                 align 4
.text$mn:000039E2 _text$mn        ends
.text$mn:000039E2
.text$mn:000039E4 ; ===========================================================================
.text$mn:000039E4
.text$mn:000039E4 ; Segment type: Pure code
.text$mn:000039E4 ; Segment permissions: Read/Execute
.text$mn:000039E4 _text$mn        segment para public 'CODE' use32
.text$mn:000039E4                 assume cs:_text$mn
.text$mn:000039E4                 ;org 39E4h
.text$mn:000039E4 ; COMDAT (pick any)
.text$mn:000039E4                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text$mn:000039E4
.text$mn:000039E4 ; =============== S U B R O U T I N E =======================================
.text$mn:000039E4
.text$mn:000039E4 ; Attributes: bp-based frame
.text$mn:000039E4
.text$mn:000039E4 ; int __cdecl std::_Debug_range<std::_String_iterator<std::_String_val<std::_Simple_types<wchar_t>>>>(char, int, int, int, int, int, wchar_t *, unsigned int)
.text$mn:000039E4                 public ??$_Debug_range@V?$_String_iterator@V?$_String_val@U?$_Simple_types@_W@std@@@std@@@std@@@std@@YAXV?$_String_iterator@V?$_String_val@U?$_Simple_types@_W@std@@@std@@@0@0PB_WI@Z
.text$mn:000039E4 ??$_Debug_range@V?$_String_iterator@V?$_String_val@U?$_Simple_types@_W@std@@@std@@@std@@@std@@YAXV?$_String_iterator@V?$_String_val@U?$_Simple_types@_W@std@@@std@@@0@0PB_WI@Z proc near
.text$mn:000039E4                                         ; CODE XREF: std::transform<std::_String_iterator<std::_String_val<std::_Simple_types<wchar_t>>>,std::_String_iterator<std::_String_val<std::_Simple_types<wchar_t>>>,int (*)(int)>(std::_String_iterator<std::_String_val<std::_Simple_types<wchar_t>>>,std::_String_iterator<std::_String_val<std::_Simple_types<wchar_t>>>,std::_String_iterator<std::_String_val<std::_Simple_types<wchar_t>>>,int (*)(int))+7Dp
.text$mn:000039E4
.text$mn:000039E4 var_28          = dword ptr -28h
.text$mn:000039E4 var_24          = dword ptr -24h
.text$mn:000039E4 var_20          = dword ptr -20h
.text$mn:000039E4 var_1C          = dword ptr -1Ch
.text$mn:000039E4 var_18          = dword ptr -18h
.text$mn:000039E4 var_14          = dword ptr -14h
.text$mn:000039E4 var_D           = byte ptr -0Dh
.text$mn:000039E4 var_C           = dword ptr -0Ch
.text$mn:000039E4 var_4           = dword ptr -4
.text$mn:000039E4 arg_0           = byte ptr  8
.text$mn:000039E4 arg_C           = dword ptr  14h
.text$mn:000039E4 arg_18          = dword ptr  20h
.text$mn:000039E4 arg_1C          = dword ptr  24h
.text$mn:000039E4
.text$mn:000039E4                 push    ebp
.text$mn:000039E5                 mov     ebp, esp
.text$mn:000039E7                 push    0FFFFFFFFh
.text$mn:000039E9                 push    offset __ehhandler$??$_Debug_range@V?$_String_iterator@V?$_String_val@U?$_Simple_types@_W@std@@@std@@@std@@@std@@YAXV?$_String_iterator@V?$_String_val@U?$_Simple_types@_W@std@@@std@@@0@0PB_WI@Z
.text$mn:000039EE                 mov     eax, large fs:0
.text$mn:000039F4                 push    eax
.text$mn:000039F5                 sub     esp, 1Ch
.text$mn:000039F8                 mov     eax, dword ptr ds:___security_cookie
.text$mn:000039FD                 xor     eax, ebp
.text$mn:000039FF                 push    eax
.text$mn:00003A00                 lea     eax, [ebp+var_C]
.text$mn:00003A03                 mov     large fs:0, eax
.text$mn:00003A09                 mov     [ebp+var_4], 1
.text$mn:00003A10                 lea     eax, [ebp+arg_0]
.text$mn:00003A13                 push    eax
.text$mn:00003A14                 lea     ecx, [ebp+var_D]
.text$mn:00003A17                 push    ecx
.text$mn:00003A18                 call    ??$_Iter_cat@V?$_String_iterator@V?$_String_val@U?$_Simple_types@_W@std@@@std@@@std@@@std@@YA?AUrandom_access_iterator_tag@0@ABV?$_String_iterator@V?$_String_val@U?$_Simple_types@_W@std@@@std@@@0@@Z ; std::_Iter_cat<std::_String_iterator<std::_String_val<std::_Simple_types<wchar_t>>>>(std::_String_iterator<std::_String_val<std::_Simple_types<wchar_t>>> const &)
.text$mn:00003A1D                 add     esp, 8
.text$mn:00003A20                 mov     dl, [eax]
.text$mn:00003A22                 movzx   eax, dl
.text$mn:00003A25                 push    eax
.text$mn:00003A26                 mov     ecx, [ebp+arg_1C]
.text$mn:00003A29                 push    ecx             ; unsigned int
.text$mn:00003A2A                 mov     edx, [ebp+arg_18]
.text$mn:00003A2D                 push    edx             ; wchar_t *
.text$mn:00003A2E                 sub     esp, 0Ch
.text$mn:00003A31                 mov     ecx, esp
.text$mn:00003A33                 mov     [ebp+var_1C], esp
.text$mn:00003A36                 lea     eax, [ebp+arg_C]
.text$mn:00003A39                 push    eax             ; int
.text$mn:00003A3A                 call    ??0?$_String_iterator@V?$_String_val@U?$_Simple_types@_W@std@@@std@@@std@@QAE@ABV01@@Z ; std::_String_iterator<std::_String_val<std::_Simple_types<wchar_t>>>::_String_iterator<std::_String_val<std::_Simple_types<wchar_t>>>(std::_String_iterator<std::_String_val<std::_Simple_types<wchar_t>>> const &)
.text$mn:00003A3F                 mov     [ebp+var_14], eax
.text$mn:00003A42                 mov     ecx, [ebp+var_14]
.text$mn:00003A45                 mov     [ebp+var_20], ecx
.text$mn:00003A48                 mov     byte ptr [ebp+var_4], 2
.text$mn:00003A4C                 sub     esp, 0Ch
.text$mn:00003A4F                 mov     ecx, esp
.text$mn:00003A51                 mov     [ebp+var_24], esp
.text$mn:00003A54                 lea     edx, [ebp+arg_0]
.text$mn:00003A57                 push    edx             ; struct std::_Iterator_base12 *
.text$mn:00003A58                 call    ??0?$_String_iterator@V?$_String_val@U?$_Simple_types@_W@std@@@std@@@std@@QAE@ABV01@@Z ; std::_String_iterator<std::_String_val<std::_Simple_types<wchar_t>>>::_String_iterator<std::_String_val<std::_Simple_types<wchar_t>>>(std::_String_iterator<std::_String_val<std::_Simple_types<wchar_t>>> const &)
.text$mn:00003A5D                 mov     [ebp+var_18], eax
.text$mn:00003A60                 mov     eax, [ebp+var_18]
.text$mn:00003A63                 mov     [ebp+var_28], eax
.text$mn:00003A66                 mov     byte ptr [ebp+var_4], 3
.text$mn:00003A6A                 mov     byte ptr [ebp+var_4], 1
.text$mn:00003A6E                 call    ??$_Debug_range2@V?$_String_iterator@V?$_String_val@U?$_Simple_types@_W@std@@@std@@@std@@@std@@YAXV?$_String_iterator@V?$_String_val@U?$_Simple_types@_W@std@@@std@@@0@0PB_WIUrandom_access_iterator_tag@0@@Z ; std::_Debug_range2<std::_String_iterator<std::_String_val<std::_Simple_types<wchar_t>>>>(std::_String_iterator<std::_String_val<std::_Simple_types<wchar_t>>>,std::_String_iterator<std::_String_val<std::_Simple_types<wchar_t>>>,wchar_t const *,uint,std::random_access_iterator_tag)
.text$mn:00003A73                 add     esp, 24h
.text$mn:00003A76                 mov     byte ptr [ebp+var_4], 0
.text$mn:00003A7A                 lea     ecx, [ebp+arg_0]
.text$mn:00003A7D                 call    ??1?$_String_iterator@V?$_String_val@U?$_Simple_types@_W@std@@@std@@@std@@QAE@XZ ; std::_String_iterator<std::_String_val<std::_Simple_types<wchar_t>>>::~_String_iterator<std::_String_val<std::_Simple_types<wchar_t>>>(void)
.text$mn:00003A82                 mov     [ebp+var_4], 0FFFFFFFFh
.text$mn:00003A89                 lea     ecx, [ebp+arg_C]
.text$mn:00003A8C                 call    ??1?$_String_iterator@V?$_String_val@U?$_Simple_types@_W@std@@@std@@@std@@QAE@XZ ; std::_String_iterator<std::_String_val<std::_Simple_types<wchar_t>>>::~_String_iterator<std::_String_val<std::_Simple_types<wchar_t>>>(void)
.text$mn:00003A91                 mov     ecx, [ebp+var_C]
.text$mn:00003A94                 mov     large fs:0, ecx
.text$mn:00003A9B                 pop     ecx
.text$mn:00003A9C                 mov     esp, ebp
.text$mn:00003A9E                 pop     ebp
.text$mn:00003A9F                 retn
.text$mn:00003A9F ??$_Debug_range@V?$_String_iterator@V?$_String_val@U?$_Simple_types@_W@std@@@std@@@std@@@std@@YAXV?$_String_iterator@V?$_String_val@U?$_Simple_types@_W@std@@@std@@@0@0PB_WI@Z endp
.text$mn:00003A9F
.text$mn:00003A9F _text$mn        ends
.text$mn:00003A9F
.text$x:00003AA0 ; ===========================================================================
.text$x:00003AA0
.text$x:00003AA0 ; Segment type: Pure code
.text$x:00003AA0 ; Segment permissions: Read/Execute
.text$x:00003AA0 _text$x         segment para public 'CODE' use32
.text$x:00003AA0                 assume cs:_text$x
.text$x:00003AA0                 ;org 3AA0h
.text$x:00003AA0 ; COMDAT (pick associative to section at 39E4)
.text$x:00003AA0                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text$x:00003AA0
.text$x:00003AA0 ; =============== S U B R O U T I N E =======================================
.text$x:00003AA0
.text$x:00003AA0
.text$x:00003AA0 __unwindfunclet$??$_Debug_range@V?$_String_iterator@V?$_String_val@U?$_Simple_types@_W@std@@@std@@@std@@@std@@YAXV?$_String_iterator@V?$_String_val@U?$_Simple_types@_W@std@@@std@@@0@0PB_WI@Z$0 proc near
.text$x:00003AA0                                         ; DATA XREF: .xdata$x:0000EE9Co
.text$x:00003AA0                 lea     ecx, [ebp+14h]
.text$x:00003AA3                 jmp     ??1?$_String_iterator@V?$_String_val@U?$_Simple_types@_W@std@@@std@@@std@@QAE@XZ ; std::_String_iterator<std::_String_val<std::_Simple_types<wchar_t>>>::~_String_iterator<std::_String_val<std::_Simple_types<wchar_t>>>(void)
.text$x:00003AA3 __unwindfunclet$??$_Debug_range@V?$_String_iterator@V?$_String_val@U?$_Simple_types@_W@std@@@std@@@std@@@std@@YAXV?$_String_iterator@V?$_String_val@U?$_Simple_types@_W@std@@@std@@@0@0PB_WI@Z$0 endp
.text$x:00003AA3
.text$x:00003AA8
.text$x:00003AA8 ; =============== S U B R O U T I N E =======================================
.text$x:00003AA8
.text$x:00003AA8
.text$x:00003AA8 __unwindfunclet$??$_Debug_range@V?$_String_iterator@V?$_String_val@U?$_Simple_types@_W@std@@@std@@@std@@@std@@YAXV?$_String_iterator@V?$_String_val@U?$_Simple_types@_W@std@@@std@@@0@0PB_WI@Z$1 proc near
.text$x:00003AA8                                         ; DATA XREF: .xdata$x:0000EEA4o
.text$x:00003AA8                 lea     ecx, [ebp+8]
.text$x:00003AAB                 jmp     ??1?$_String_iterator@V?$_String_val@U?$_Simple_types@_W@std@@@std@@@std@@QAE@XZ ; std::_String_iterator<std::_String_val<std::_Simple_types<wchar_t>>>::~_String_iterator<std::_String_val<std::_Simple_types<wchar_t>>>(void)
.text$x:00003AAB __unwindfunclet$??$_Debug_range@V?$_String_iterator@V?$_String_val@U?$_Simple_types@_W@std@@@std@@@std@@@std@@YAXV?$_String_iterator@V?$_String_val@U?$_Simple_types@_W@std@@@std@@@0@0PB_WI@Z$1 endp
.text$x:00003AAB
.text$x:00003AB0
.text$x:00003AB0 ; =============== S U B R O U T I N E =======================================
.text$x:00003AB0
.text$x:00003AB0
.text$x:00003AB0 __unwindfunclet$??$_Debug_range@V?$_String_iterator@V?$_String_val@U?$_Simple_types@_W@std@@@std@@@std@@@std@@YAXV?$_String_iterator@V?$_String_val@U?$_Simple_types@_W@std@@@std@@@0@0PB_WI@Z$2 proc near
.text$x:00003AB0                                         ; DATA XREF: .xdata$x:0000EEACo
.text$x:00003AB0                 mov     ecx, [ebp-1Ch]
.text$x:00003AB3                 jmp     ??1?$_String_iterator@V?$_String_val@U?$_Simple_types@_W@std@@@std@@@std@@QAE@XZ ; std::_String_iterator<std::_String_val<std::_Simple_types<wchar_t>>>::~_String_iterator<std::_String_val<std::_Simple_types<wchar_t>>>(void)
.text$x:00003AB3 __unwindfunclet$??$_Debug_range@V?$_String_iterator@V?$_String_val@U?$_Simple_types@_W@std@@@std@@@std@@@std@@YAXV?$_String_iterator@V?$_String_val@U?$_Simple_types@_W@std@@@std@@@0@0PB_WI@Z$2 endp
.text$x:00003AB3
.text$x:00003AB8
.text$x:00003AB8 ; =============== S U B R O U T I N E =======================================
.text$x:00003AB8
.text$x:00003AB8
.text$x:00003AB8 __unwindfunclet$??$_Debug_range@V?$_String_iterator@V?$_String_val@U?$_Simple_types@_W@std@@@std@@@std@@@std@@YAXV?$_String_iterator@V?$_String_val@U?$_Simple_types@_W@std@@@std@@@0@0PB_WI@Z$3 proc near
.text$x:00003AB8                                         ; DATA XREF: .xdata$x:0000EEB4o
.text$x:00003AB8                 mov     ecx, [ebp-24h]
.text$x:00003ABB                 jmp     ??1?$_String_iterator@V?$_String_val@U?$_Simple_types@_W@std@@@std@@@std@@QAE@XZ ; std::_String_iterator<std::_String_val<std::_Simple_types<wchar_t>>>::~_String_iterator<std::_String_val<std::_Simple_types<wchar_t>>>(void)
.text$x:00003ABB __unwindfunclet$??$_Debug_range@V?$_String_iterator@V?$_String_val@U?$_Simple_types@_W@std@@@std@@@std@@@std@@YAXV?$_String_iterator@V?$_String_val@U?$_Simple_types@_W@std@@@std@@@0@0PB_WI@Z$3 endp
.text$x:00003ABB
.text$x:00003AC0
.text$x:00003AC0 ; =============== S U B R O U T I N E =======================================
.text$x:00003AC0
.text$x:00003AC0
.text$x:00003AC0 __ehhandler$??$_Debug_range@V?$_String_iterator@V?$_String_val@U?$_Simple_types@_W@std@@@std@@@std@@@std@@YAXV?$_String_iterator@V?$_String_val@U?$_Simple_types@_W@std@@@std@@@0@0PB_WI@Z proc near
.text$x:00003AC0                                         ; DATA XREF: std::_Debug_range<std::_String_iterator<std::_String_val<std::_Simple_types<wchar_t>>>>(std::_String_iterator<std::_String_val<std::_Simple_types<wchar_t>>>,std::_String_iterator<std::_String_val<std::_Simple_types<wchar_t>>>,wchar_t const *,uint)+5o
.text$x:00003AC0
.text$x:00003AC0 arg_4           = dword ptr  8
.text$x:00003AC0
.text$x:00003AC0                 mov     edx, [esp+arg_4]
.text$x:00003AC4                 lea     eax, [edx+0Ch]
.text$x:00003AC7                 mov     ecx, [edx-20h]
.text$x:00003ACA                 xor     ecx, eax
.text$x:00003ACC                 call    @__security_check_cookie@4 ; __security_check_cookie(x)
.text$x:00003AD1                 mov     eax, offset __ehfuncinfo$??$_Debug_range@V?$_String_iterator@V?$_String_val@U?$_Simple_types@_W@std@@@std@@@std@@@std@@YAXV?$_String_iterator@V?$_String_val@U?$_Simple_types@_W@std@@@std@@@0@0PB_WI@Z
.text$x:00003AD6                 jmp     ___CxxFrameHandler3
.text$x:00003AD6 __ehhandler$??$_Debug_range@V?$_String_iterator@V?$_String_val@U?$_Simple_types@_W@std@@@std@@@std@@@std@@YAXV?$_String_iterator@V?$_String_val@U?$_Simple_types@_W@std@@@std@@@0@0PB_WI@Z endp
.text$x:00003AD6
.text$x:00003AD6 ; ---------------------------------------------------------------------------
.text$x:00003ADB                 align 4
.text$x:00003ADB _text$x         ends
.text$x:00003ADB
.text$mn:00003ADC ; ===========================================================================
.text$mn:00003ADC
.text$mn:00003ADC ; Segment type: Pure code
.text$mn:00003ADC ; Segment permissions: Read/Execute
.text$mn:00003ADC _text$mn        segment para public 'CODE' use32
.text$mn:00003ADC                 assume cs:_text$mn
.text$mn:00003ADC                 ;org 3ADCh
.text$mn:00003ADC ; COMDAT (pick any)
.text$mn:00003ADC                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text$mn:00003ADC
.text$mn:00003ADC ; =============== S U B R O U T I N E =======================================
.text$mn:00003ADC
.text$mn:00003ADC ; Attributes: bp-based frame
.text$mn:00003ADC
.text$mn:00003ADC ; int __cdecl std::_Debug_range<std::reverse_iterator<std::_Vector_iterator<std::_Vector_val<std::_Simple_types<wchar_t>>>>>(char, int, int, int, int, int, wchar_t *, unsigned int)
.text$mn:00003ADC                 public ??$_Debug_range@V?$reverse_iterator@V?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@_W@std@@@std@@@std@@@std@@@std@@YAXV?$reverse_iterator@V?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@_W@std@@@std@@@std@@@0@0PB_WI@Z
.text$mn:00003ADC ??$_Debug_range@V?$reverse_iterator@V?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@_W@std@@@std@@@std@@@std@@@std@@YAXV?$reverse_iterator@V?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@_W@std@@@std@@@std@@@0@0PB_WI@Z proc near
.text$mn:00003ADC                                         ; CODE XREF: std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>>::_Construct<std::reverse_iterator<std::_Vector_iterator<std::_Vector_val<std::_Simple_types<wchar_t>>>>>(std::reverse_iterator<std::_Vector_iterator<std::_Vector_val<std::_Simple_types<wchar_t>>>>,std::reverse_iterator<std::_Vector_iterator<std::_Vector_val<std::_Simple_types<wchar_t>>>>,std::forward_iterator_tag)+80p
.text$mn:00003ADC
.text$mn:00003ADC var_28          = dword ptr -28h
.text$mn:00003ADC var_24          = dword ptr -24h
.text$mn:00003ADC var_20          = dword ptr -20h
.text$mn:00003ADC var_1C          = dword ptr -1Ch
.text$mn:00003ADC var_18          = dword ptr -18h
.text$mn:00003ADC var_14          = dword ptr -14h
.text$mn:00003ADC var_D           = byte ptr -0Dh
.text$mn:00003ADC var_C           = dword ptr -0Ch
.text$mn:00003ADC var_4           = dword ptr -4
.text$mn:00003ADC arg_0           = byte ptr  8
.text$mn:00003ADC arg_C           = dword ptr  14h
.text$mn:00003ADC arg_18          = dword ptr  20h
.text$mn:00003ADC arg_1C          = dword ptr  24h
.text$mn:00003ADC
.text$mn:00003ADC                 push    ebp
.text$mn:00003ADD                 mov     ebp, esp
.text$mn:00003ADF                 push    0FFFFFFFFh
.text$mn:00003AE1                 push    offset __ehhandler$??$_Debug_range@V?$reverse_iterator@V?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@_W@std@@@std@@@std@@@std@@@std@@YAXV?$reverse_iterator@V?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@_W@std@@@std@@@std@@@0@0PB_WI@Z
.text$mn:00003AE6                 mov     eax, large fs:0
.text$mn:00003AEC                 push    eax
.text$mn:00003AED                 sub     esp, 1Ch
.text$mn:00003AF0                 mov     eax, dword ptr ds:___security_cookie
.text$mn:00003AF5                 xor     eax, ebp
.text$mn:00003AF7                 push    eax
.text$mn:00003AF8                 lea     eax, [ebp+var_C]
.text$mn:00003AFB                 mov     large fs:0, eax
.text$mn:00003B01                 mov     [ebp+var_4], 1
.text$mn:00003B08                 lea     eax, [ebp+arg_0]
.text$mn:00003B0B                 push    eax
.text$mn:00003B0C                 lea     ecx, [ebp+var_D]
.text$mn:00003B0F                 push    ecx
.text$mn:00003B10                 call    ??$_Iter_cat@V?$reverse_iterator@V?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@_W@std@@@std@@@std@@@std@@@std@@YA?AUrandom_access_iterator_tag@0@ABV?$reverse_iterator@V?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@_W@std@@@std@@@std@@@0@@Z ; std::_Iter_cat<std::reverse_iterator<std::_Vector_iterator<std::_Vector_val<std::_Simple_types<wchar_t>>>>>(std::reverse_iterator<std::_Vector_iterator<std::_Vector_val<std::_Simple_types<wchar_t>>>> const &)
.text$mn:00003B15                 add     esp, 8
.text$mn:00003B18                 mov     dl, [eax]
.text$mn:00003B1A                 movzx   eax, dl
.text$mn:00003B1D                 push    eax
.text$mn:00003B1E                 mov     ecx, [ebp+arg_1C]
.text$mn:00003B21                 push    ecx             ; unsigned int
.text$mn:00003B22                 mov     edx, [ebp+arg_18]
.text$mn:00003B25                 push    edx             ; wchar_t *
.text$mn:00003B26                 sub     esp, 0Ch
.text$mn:00003B29                 mov     ecx, esp
.text$mn:00003B2B                 mov     [ebp+var_1C], esp
.text$mn:00003B2E                 lea     eax, [ebp+arg_C]
.text$mn:00003B31                 push    eax             ; int
.text$mn:00003B32                 call    ??0?$reverse_iterator@V?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@_W@std@@@std@@@std@@@std@@QAE@ABV01@@Z ; std::reverse_iterator<std::_Vector_iterator<std::_Vector_val<std::_Simple_types<wchar_t>>>>::reverse_iterator<std::_Vector_iterator<std::_Vector_val<std::_Simple_types<wchar_t>>>>(std::reverse_iterator<std::_Vector_iterator<std::_Vector_val<std::_Simple_types<wchar_t>>>> const &)
.text$mn:00003B37                 mov     [ebp+var_14], eax
.text$mn:00003B3A                 mov     ecx, [ebp+var_14]
.text$mn:00003B3D                 mov     [ebp+var_20], ecx
.text$mn:00003B40                 mov     byte ptr [ebp+var_4], 2
.text$mn:00003B44                 sub     esp, 0Ch
.text$mn:00003B47                 mov     ecx, esp
.text$mn:00003B49                 mov     [ebp+var_24], esp
.text$mn:00003B4C                 lea     edx, [ebp+arg_0]
.text$mn:00003B4F                 push    edx             ; struct std::_Iterator_base12 *
.text$mn:00003B50                 call    ??0?$reverse_iterator@V?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@_W@std@@@std@@@std@@@std@@QAE@ABV01@@Z ; std::reverse_iterator<std::_Vector_iterator<std::_Vector_val<std::_Simple_types<wchar_t>>>>::reverse_iterator<std::_Vector_iterator<std::_Vector_val<std::_Simple_types<wchar_t>>>>(std::reverse_iterator<std::_Vector_iterator<std::_Vector_val<std::_Simple_types<wchar_t>>>> const &)
.text$mn:00003B55                 mov     [ebp+var_18], eax
.text$mn:00003B58                 mov     eax, [ebp+var_18]
.text$mn:00003B5B                 mov     [ebp+var_28], eax
.text$mn:00003B5E                 mov     byte ptr [ebp+var_4], 3
.text$mn:00003B62                 mov     byte ptr [ebp+var_4], 1
.text$mn:00003B66                 call    ??$_Debug_range2@V?$reverse_iterator@V?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@_W@std@@@std@@@std@@@std@@@std@@YAXV?$reverse_iterator@V?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@_W@std@@@std@@@std@@@0@0PB_WIUrandom_access_iterator_tag@0@@Z ; std::_Debug_range2<std::reverse_iterator<std::_Vector_iterator<std::_Vector_val<std::_Simple_types<wchar_t>>>>>(std::reverse_iterator<std::_Vector_iterator<std::_Vector_val<std::_Simple_types<wchar_t>>>>,std::reverse_iterator<std::_Vector_iterator<std::_Vector_val<std::_Simple_types<wchar_t>>>>,wchar_t const *,uint,std::random_access_iterator_tag)
.text$mn:00003B6B                 add     esp, 24h
.text$mn:00003B6E                 mov     byte ptr [ebp+var_4], 0
.text$mn:00003B72                 lea     ecx, [ebp+arg_0]
.text$mn:00003B75                 call    ??1?$reverse_iterator@V?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@_W@std@@@std@@@std@@@std@@QAE@XZ ; std::reverse_iterator<std::_Vector_iterator<std::_Vector_val<std::_Simple_types<wchar_t>>>>::~reverse_iterator<std::_Vector_iterator<std::_Vector_val<std::_Simple_types<wchar_t>>>>(void)
.text$mn:00003B7A                 mov     [ebp+var_4], 0FFFFFFFFh
.text$mn:00003B81                 lea     ecx, [ebp+arg_C]
.text$mn:00003B84                 call    ??1?$reverse_iterator@V?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@_W@std@@@std@@@std@@@std@@QAE@XZ ; std::reverse_iterator<std::_Vector_iterator<std::_Vector_val<std::_Simple_types<wchar_t>>>>::~reverse_iterator<std::_Vector_iterator<std::_Vector_val<std::_Simple_types<wchar_t>>>>(void)
.text$mn:00003B89                 mov     ecx, [ebp+var_C]
.text$mn:00003B8C                 mov     large fs:0, ecx
.text$mn:00003B93                 pop     ecx
.text$mn:00003B94                 mov     esp, ebp
.text$mn:00003B96                 pop     ebp
.text$mn:00003B97                 retn
.text$mn:00003B97 ??$_Debug_range@V?$reverse_iterator@V?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@_W@std@@@std@@@std@@@std@@@std@@YAXV?$reverse_iterator@V?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@_W@std@@@std@@@std@@@0@0PB_WI@Z endp
.text$mn:00003B97
.text$mn:00003B97 _text$mn        ends
.text$mn:00003B97
.text$x:00003B98 ; ===========================================================================
.text$x:00003B98
.text$x:00003B98 ; Segment type: Pure code
.text$x:00003B98 ; Segment permissions: Read/Execute
.text$x:00003B98 _text$x         segment para public 'CODE' use32
.text$x:00003B98                 assume cs:_text$x
.text$x:00003B98                 ;org 3B98h
.text$x:00003B98 ; COMDAT (pick associative to section at 3ADC)
.text$x:00003B98                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text$x:00003B98
.text$x:00003B98 ; =============== S U B R O U T I N E =======================================
.text$x:00003B98
.text$x:00003B98
.text$x:00003B98 __unwindfunclet$??$_Debug_range@V?$reverse_iterator@V?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@_W@std@@@std@@@std@@@std@@@std@@YAXV?$reverse_iterator@V?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@_W@std@@@std@@@std@@@0@0PB_WI@Z$0 proc near
.text$x:00003B98                                         ; DATA XREF: .xdata$x:0000EF74o
.text$x:00003B98                 lea     ecx, [ebp+14h]
.text$x:00003B9B                 jmp     ??1?$reverse_iterator@V?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@_W@std@@@std@@@std@@@std@@QAE@XZ ; std::reverse_iterator<std::_Vector_iterator<std::_Vector_val<std::_Simple_types<wchar_t>>>>::~reverse_iterator<std::_Vector_iterator<std::_Vector_val<std::_Simple_types<wchar_t>>>>(void)
.text$x:00003B9B __unwindfunclet$??$_Debug_range@V?$reverse_iterator@V?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@_W@std@@@std@@@std@@@std@@@std@@YAXV?$reverse_iterator@V?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@_W@std@@@std@@@std@@@0@0PB_WI@Z$0 endp
.text$x:00003B9B
.text$x:00003BA0
.text$x:00003BA0 ; =============== S U B R O U T I N E =======================================
.text$x:00003BA0
.text$x:00003BA0
.text$x:00003BA0 __unwindfunclet$??$_Debug_range@V?$reverse_iterator@V?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@_W@std@@@std@@@std@@@std@@@std@@YAXV?$reverse_iterator@V?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@_W@std@@@std@@@std@@@0@0PB_WI@Z$1 proc near
.text$x:00003BA0                                         ; DATA XREF: .xdata$x:0000EF7Co
.text$x:00003BA0                 lea     ecx, [ebp+8]
.text$x:00003BA3                 jmp     ??1?$reverse_iterator@V?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@_W@std@@@std@@@std@@@std@@QAE@XZ ; std::reverse_iterator<std::_Vector_iterator<std::_Vector_val<std::_Simple_types<wchar_t>>>>::~reverse_iterator<std::_Vector_iterator<std::_Vector_val<std::_Simple_types<wchar_t>>>>(void)
.text$x:00003BA3 __unwindfunclet$??$_Debug_range@V?$reverse_iterator@V?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@_W@std@@@std@@@std@@@std@@@std@@YAXV?$reverse_iterator@V?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@_W@std@@@std@@@std@@@0@0PB_WI@Z$1 endp
.text$x:00003BA3
.text$x:00003BA8
.text$x:00003BA8 ; =============== S U B R O U T I N E =======================================
.text$x:00003BA8
.text$x:00003BA8
.text$x:00003BA8 __unwindfunclet$??$_Debug_range@V?$reverse_iterator@V?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@_W@std@@@std@@@std@@@std@@@std@@YAXV?$reverse_iterator@V?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@_W@std@@@std@@@std@@@0@0PB_WI@Z$2 proc near
.text$x:00003BA8                                         ; DATA XREF: .xdata$x:0000EF84o
.text$x:00003BA8                 mov     ecx, [ebp-1Ch]
.text$x:00003BAB                 jmp     ??1?$reverse_iterator@V?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@_W@std@@@std@@@std@@@std@@QAE@XZ ; std::reverse_iterator<std::_Vector_iterator<std::_Vector_val<std::_Simple_types<wchar_t>>>>::~reverse_iterator<std::_Vector_iterator<std::_Vector_val<std::_Simple_types<wchar_t>>>>(void)
.text$x:00003BAB __unwindfunclet$??$_Debug_range@V?$reverse_iterator@V?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@_W@std@@@std@@@std@@@std@@@std@@YAXV?$reverse_iterator@V?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@_W@std@@@std@@@std@@@0@0PB_WI@Z$2 endp
.text$x:00003BAB
.text$x:00003BB0
.text$x:00003BB0 ; =============== S U B R O U T I N E =======================================
.text$x:00003BB0
.text$x:00003BB0
.text$x:00003BB0 __unwindfunclet$??$_Debug_range@V?$reverse_iterator@V?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@_W@std@@@std@@@std@@@std@@@std@@YAXV?$reverse_iterator@V?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@_W@std@@@std@@@std@@@0@0PB_WI@Z$3 proc near
.text$x:00003BB0                                         ; DATA XREF: .xdata$x:0000EF8Co
.text$x:00003BB0                 mov     ecx, [ebp-24h]
.text$x:00003BB3                 jmp     ??1?$reverse_iterator@V?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@_W@std@@@std@@@std@@@std@@QAE@XZ ; std::reverse_iterator<std::_Vector_iterator<std::_Vector_val<std::_Simple_types<wchar_t>>>>::~reverse_iterator<std::_Vector_iterator<std::_Vector_val<std::_Simple_types<wchar_t>>>>(void)
.text$x:00003BB3 __unwindfunclet$??$_Debug_range@V?$reverse_iterator@V?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@_W@std@@@std@@@std@@@std@@@std@@YAXV?$reverse_iterator@V?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@_W@std@@@std@@@std@@@0@0PB_WI@Z$3 endp
.text$x:00003BB3
.text$x:00003BB8
.text$x:00003BB8 ; =============== S U B R O U T I N E =======================================
.text$x:00003BB8
.text$x:00003BB8
.text$x:00003BB8 __ehhandler$??$_Debug_range@V?$reverse_iterator@V?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@_W@std@@@std@@@std@@@std@@@std@@YAXV?$reverse_iterator@V?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@_W@std@@@std@@@std@@@0@0PB_WI@Z proc near
.text$x:00003BB8                                         ; DATA XREF: std::_Debug_range<std::reverse_iterator<std::_Vector_iterator<std::_Vector_val<std::_Simple_types<wchar_t>>>>>(std::reverse_iterator<std::_Vector_iterator<std::_Vector_val<std::_Simple_types<wchar_t>>>>,std::reverse_iterator<std::_Vector_iterator<std::_Vector_val<std::_Simple_types<wchar_t>>>>,wchar_t const *,uint)+5o
.text$x:00003BB8
.text$x:00003BB8 arg_4           = dword ptr  8
.text$x:00003BB8
.text$x:00003BB8                 mov     edx, [esp+arg_4]
.text$x:00003BBC                 lea     eax, [edx+0Ch]
.text$x:00003BBF                 mov     ecx, [edx-20h]
.text$x:00003BC2                 xor     ecx, eax
.text$x:00003BC4                 call    @__security_check_cookie@4 ; __security_check_cookie(x)
.text$x:00003BC9                 mov     eax, offset __ehfuncinfo$??$_Debug_range@V?$reverse_iterator@V?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@_W@std@@@std@@@std@@@std@@@std@@YAXV?$reverse_iterator@V?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@_W@std@@@std@@@std@@@0@0PB_WI@Z
.text$x:00003BCE                 jmp     ___CxxFrameHandler3
.text$x:00003BCE __ehhandler$??$_Debug_range@V?$reverse_iterator@V?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@_W@std@@@std@@@std@@@std@@@std@@YAXV?$reverse_iterator@V?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@_W@std@@@std@@@std@@@0@0PB_WI@Z endp
.text$x:00003BCE
.text$x:00003BCE ; ---------------------------------------------------------------------------
.text$x:00003BD3                 align 4
.text$x:00003BD3 _text$x         ends
.text$x:00003BD3
.text$mn:00003BD4 ; ===========================================================================
.text$mn:00003BD4
.text$mn:00003BD4 ; Segment type: Pure code
.text$mn:00003BD4 ; Segment permissions: Read/Execute
.text$mn:00003BD4 _text$mn        segment para public 'CODE' use32
.text$mn:00003BD4                 assume cs:_text$mn
.text$mn:00003BD4                 ;org 3BD4h
.text$mn:00003BD4 ; COMDAT (pick any)
.text$mn:00003BD4                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text$mn:00003BD4
.text$mn:00003BD4 ; =============== S U B R O U T I N E =======================================
.text$mn:00003BD4
.text$mn:00003BD4 ; Attributes: bp-based frame
.text$mn:00003BD4
.text$mn:00003BD4 ; void __cdecl std::_Destroy_range<struct std::_Wrap_alloc<class std::allocator<char>>>(char *, char *, struct std::_Wrap_alloc<class std::allocator<char>> &)
.text$mn:00003BD4                 public ??$_Destroy_range@U?$_Wrap_alloc@V?$allocator@D@std@@@std@@@std@@YAXPAD0AAU?$_Wrap_alloc@V?$allocator@D@std@@@0@@Z
.text$mn:00003BD4 ??$_Destroy_range@U?$_Wrap_alloc@V?$allocator@D@std@@@std@@@std@@YAXPAD0AAU?$_Wrap_alloc@V?$allocator@D@std@@@0@@Z proc near
.text$mn:00003BD4                                         ; CODE XREF: std::vector<char,std::allocator<char>>::_Destroy(char *,char *)+21p
.text$mn:00003BD4
.text$mn:00003BD4 var_1           = byte ptr -1
.text$mn:00003BD4 arg_0           = dword ptr  8
.text$mn:00003BD4 arg_4           = dword ptr  0Ch
.text$mn:00003BD4 arg_8           = dword ptr  10h
.text$mn:00003BD4
.text$mn:00003BD4                 push    ebp
.text$mn:00003BD5                 mov     ebp, esp
.text$mn:00003BD7                 push    ecx
.text$mn:00003BD8                 mov     eax, [ebp+arg_4]
.text$mn:00003BDB                 push    eax
.text$mn:00003BDC                 mov     ecx, [ebp+arg_0]
.text$mn:00003BDF                 push    ecx
.text$mn:00003BE0                 call    ??$_Ptr_cat@DD@std@@YA?AU_Scalar_ptr_iterator_tag@0@PAD0@Z ; std::_Ptr_cat<char,char>(char *,char *)
.text$mn:00003BE5                 add     esp, 8
.text$mn:00003BE8                 mov     [ebp+var_1], al
.text$mn:00003BEB                 movzx   edx, [ebp+var_1]
.text$mn:00003BEF                 push    edx
.text$mn:00003BF0                 mov     eax, [ebp+arg_8]
.text$mn:00003BF3                 push    eax
.text$mn:00003BF4                 mov     ecx, [ebp+arg_4]
.text$mn:00003BF7                 push    ecx
.text$mn:00003BF8                 mov     edx, [ebp+arg_0]
.text$mn:00003BFB                 push    edx
.text$mn:00003BFC                 call    ??$_Destroy_range@U?$_Wrap_alloc@V?$allocator@D@std@@@std@@@std@@YAXPAD0AAU?$_Wrap_alloc@V?$allocator@D@std@@@0@U_Scalar_ptr_iterator_tag@0@@Z ; std::_Destroy_range<std::_Wrap_alloc<std::allocator<char>>>(char *,char *,std::_Wrap_alloc<std::allocator<char>> &,std::_Scalar_ptr_iterator_tag)
.text$mn:00003C01                 add     esp, 10h
.text$mn:00003C04                 mov     esp, ebp
.text$mn:00003C06                 pop     ebp
.text$mn:00003C07                 retn
.text$mn:00003C07 ??$_Destroy_range@U?$_Wrap_alloc@V?$allocator@D@std@@@std@@@std@@YAXPAD0AAU?$_Wrap_alloc@V?$allocator@D@std@@@0@@Z endp
.text$mn:00003C07
.text$mn:00003C07 _text$mn        ends
.text$mn:00003C07
.text$mn:00003C08 ; ===========================================================================
.text$mn:00003C08
.text$mn:00003C08 ; Segment type: Pure code
.text$mn:00003C08 ; Segment permissions: Read/Execute
.text$mn:00003C08 _text$mn        segment para public 'CODE' use32
.text$mn:00003C08                 assume cs:_text$mn
.text$mn:00003C08                 ;org 3C08h
.text$mn:00003C08 ; COMDAT (pick any)
.text$mn:00003C08                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text$mn:00003C08
.text$mn:00003C08 ; =============== S U B R O U T I N E =======================================
.text$mn:00003C08
.text$mn:00003C08 ; Attributes: bp-based frame
.text$mn:00003C08
.text$mn:00003C08 ; void __cdecl std::_Destroy_range<struct std::_Wrap_alloc<class std::allocator<char>>>(char *, char *, struct std::_Wrap_alloc<class std::allocator<char>> &, struct std::_Scalar_ptr_iterator_tag)
.text$mn:00003C08                 public ??$_Destroy_range@U?$_Wrap_alloc@V?$allocator@D@std@@@std@@@std@@YAXPAD0AAU?$_Wrap_alloc@V?$allocator@D@std@@@0@U_Scalar_ptr_iterator_tag@0@@Z
.text$mn:00003C08 ??$_Destroy_range@U?$_Wrap_alloc@V?$allocator@D@std@@@std@@@std@@YAXPAD0AAU?$_Wrap_alloc@V?$allocator@D@std@@@0@U_Scalar_ptr_iterator_tag@0@@Z proc near
.text$mn:00003C08                                         ; CODE XREF: std::_Destroy_range<std::_Wrap_alloc<std::allocator<char>>>(char *,char *,std::_Wrap_alloc<std::allocator<char>> &)+28p
.text$mn:00003C08                 push    ebp
.text$mn:00003C09                 mov     ebp, esp
.text$mn:00003C0B                 pop     ebp
.text$mn:00003C0C                 retn
.text$mn:00003C0C ??$_Destroy_range@U?$_Wrap_alloc@V?$allocator@D@std@@@std@@@std@@YAXPAD0AAU?$_Wrap_alloc@V?$allocator@D@std@@@0@U_Scalar_ptr_iterator_tag@0@@Z endp
.text$mn:00003C0C
.text$mn:00003C0C ; ---------------------------------------------------------------------------
.text$mn:00003C0D                 align 10h
.text$mn:00003C0D _text$mn        ends
.text$mn:00003C0D
.text$mn:00003C10 ; ===========================================================================
.text$mn:00003C10
.text$mn:00003C10 ; Segment type: Pure code
.text$mn:00003C10 ; Segment permissions: Read/Execute
.text$mn:00003C10 _text$mn        segment para public 'CODE' use32
.text$mn:00003C10                 assume cs:_text$mn
.text$mn:00003C10                 ;org 3C10h
.text$mn:00003C10 ; COMDAT (pick any)
.text$mn:00003C10                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text$mn:00003C10
.text$mn:00003C10 ; =============== S U B R O U T I N E =======================================
.text$mn:00003C10
.text$mn:00003C10 ; Attributes: bp-based frame
.text$mn:00003C10
.text$mn:00003C10 ; void __cdecl std::_Destroy_range<struct std::_Wrap_alloc<class std::allocator<class std::basic_string<wchar_t, struct std::char_traits<wchar_t>, class std::allocator<wchar_t>>>>>(class std::basic_string<wchar_t, struct std::char_traits<wchar_t>, class std::allocator<wchar_t>> *, class std::basic_string<wchar_t, struct std::char_traits<wchar_t>, class std::allocator<wchar_t>> *, struct std::_Wrap_alloc<class std::allocator<class std::basic_string<wchar_t, struct std::char_traits<wchar_t>, class std::allocator<wchar_t>>>> &)
.text$mn:00003C10                 public ??$_Destroy_range@U?$_Wrap_alloc@V?$allocator@V?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@@std@@@std@@@std@@YAXPAV?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@0@0AAU?$_Wrap_alloc@V?$allocator@V?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@@std@@@0@@Z
.text$mn:00003C10 ??$_Destroy_range@U?$_Wrap_alloc@V?$allocator@V?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@@std@@@std@@@std@@YAXPAV?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@0@0AAU?$_Wrap_alloc@V?$allocator@V?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@@std@@@0@@Z proc near
.text$mn:00003C10                                         ; CODE XREF: std::vector<std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>>,std::allocator<std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>>>>::_Destroy(std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>> *,std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>> *)+21p
.text$mn:00003C10
.text$mn:00003C10 var_1           = byte ptr -1
.text$mn:00003C10 arg_0           = dword ptr  8
.text$mn:00003C10 arg_4           = dword ptr  0Ch
.text$mn:00003C10 arg_8           = dword ptr  10h
.text$mn:00003C10
.text$mn:00003C10                 push    ebp
.text$mn:00003C11                 mov     ebp, esp
.text$mn:00003C13                 push    ecx
.text$mn:00003C14                 mov     eax, [ebp+arg_4]
.text$mn:00003C17                 push    eax
.text$mn:00003C18                 mov     ecx, [ebp+arg_0]
.text$mn:00003C1B                 push    ecx
.text$mn:00003C1C                 call    ??$_Ptr_cat@V?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@V12@@std@@YA?AU_Nonscalar_ptr_iterator_tag@0@PAV?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@0@0@Z ; std::_Ptr_cat<std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>>,std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>>>(std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>> *,std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>> *)
.text$mn:00003C21                 add     esp, 8
.text$mn:00003C24                 mov     [ebp+var_1], al
.text$mn:00003C27                 movzx   edx, [ebp+var_1]
.text$mn:00003C2B                 push    edx
.text$mn:00003C2C                 mov     eax, [ebp+arg_8]
.text$mn:00003C2F                 push    eax
.text$mn:00003C30                 mov     ecx, [ebp+arg_4]
.text$mn:00003C33                 push    ecx
.text$mn:00003C34                 mov     edx, [ebp+arg_0]
.text$mn:00003C37                 push    edx
.text$mn:00003C38                 call    ??$_Destroy_range@U?$_Wrap_alloc@V?$allocator@V?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@@std@@@std@@@std@@YAXPAV?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@0@0AAU?$_Wrap_alloc@V?$allocator@V?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@@std@@@0@U_Nonscalar_ptr_iterator_tag@0@@Z ; std::_Destroy_range<std::_Wrap_alloc<std::allocator<std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>>>>>(std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>> *,std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>> *,std::_Wrap_alloc<std::allocator<std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>>>> &,std::_Nonscalar_ptr_iterator_tag)
.text$mn:00003C3D                 add     esp, 10h
.text$mn:00003C40                 mov     esp, ebp
.text$mn:00003C42                 pop     ebp
.text$mn:00003C43                 retn
.text$mn:00003C43 ??$_Destroy_range@U?$_Wrap_alloc@V?$allocator@V?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@@std@@@std@@@std@@YAXPAV?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@0@0AAU?$_Wrap_alloc@V?$allocator@V?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@@std@@@0@@Z endp
.text$mn:00003C43
.text$mn:00003C43 _text$mn        ends
.text$mn:00003C43
.text$mn:00003C44 ; ===========================================================================
.text$mn:00003C44
.text$mn:00003C44 ; Segment type: Pure code
.text$mn:00003C44 ; Segment permissions: Read/Execute
.text$mn:00003C44 _text$mn        segment para public 'CODE' use32
.text$mn:00003C44                 assume cs:_text$mn
.text$mn:00003C44                 ;org 3C44h
.text$mn:00003C44 ; COMDAT (pick any)
.text$mn:00003C44                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text$mn:00003C44
.text$mn:00003C44 ; =============== S U B R O U T I N E =======================================
.text$mn:00003C44
.text$mn:00003C44 ; Attributes: bp-based frame
.text$mn:00003C44
.text$mn:00003C44 ; void __cdecl std::_Destroy_range<struct std::_Wrap_alloc<class std::allocator<class std::basic_string<wchar_t, struct std::char_traits<wchar_t>, class std::allocator<wchar_t>>>>>(class std::basic_string<wchar_t, struct std::char_traits<wchar_t>, class std::allocator<wchar_t>> *, class std::basic_string<wchar_t, struct std::char_traits<wchar_t>, class std::allocator<wchar_t>> *, struct std::_Wrap_alloc<class std::allocator<class std::basic_string<wchar_t, struct std::char_traits<wchar_t>, class std::allocator<wchar_t>>>> &, struct std::_Nonscalar_ptr_iterator_tag)
.text$mn:00003C44                 public ??$_Destroy_range@U?$_Wrap_alloc@V?$allocator@V?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@@std@@@std@@@std@@YAXPAV?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@0@0AAU?$_Wrap_alloc@V?$allocator@V?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@@std@@@0@U_Nonscalar_ptr_iterator_tag@0@@Z
.text$mn:00003C44 ??$_Destroy_range@U?$_Wrap_alloc@V?$allocator@V?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@@std@@@std@@@std@@YAXPAV?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@0@0AAU?$_Wrap_alloc@V?$allocator@V?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@@std@@@0@U_Nonscalar_ptr_iterator_tag@0@@Z proc near
.text$mn:00003C44                                         ; CODE XREF: std::_Destroy_range<std::_Wrap_alloc<std::allocator<std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>>>>>(std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>> *,std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>> *,std::_Wrap_alloc<std::allocator<std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>>>> &)+28p
.text$mn:00003C44
.text$mn:00003C44 arg_0           = dword ptr  8
.text$mn:00003C44 arg_4           = dword ptr  0Ch
.text$mn:00003C44 arg_8           = dword ptr  10h
.text$mn:00003C44
.text$mn:00003C44                 push    ebp
.text$mn:00003C45                 mov     ebp, esp
.text$mn:00003C47                 jmp     short loc_3C52
.text$mn:00003C49 ; ---------------------------------------------------------------------------
.text$mn:00003C49
.text$mn:00003C49 loc_3C49:                               ; CODE XREF: std::_Destroy_range<std::_Wrap_alloc<std::allocator<std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>>>>>(std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>> *,std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>> *,std::_Wrap_alloc<std::allocator<std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>>>> &,std::_Nonscalar_ptr_iterator_tag)+22j
.text$mn:00003C49                 mov     eax, [ebp+arg_0]
.text$mn:00003C4C                 add     eax, 1Ch
.text$mn:00003C4F                 mov     [ebp+arg_0], eax
.text$mn:00003C52
.text$mn:00003C52 loc_3C52:                               ; CODE XREF: std::_Destroy_range<std::_Wrap_alloc<std::allocator<std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>>>>>(std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>> *,std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>> *,std::_Wrap_alloc<std::allocator<std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>>>> &,std::_Nonscalar_ptr_iterator_tag)+3j
.text$mn:00003C52                 mov     ecx, [ebp+arg_0]
.text$mn:00003C55                 cmp     ecx, [ebp+arg_4]
.text$mn:00003C58                 jz      short loc_3C68
.text$mn:00003C5A                 mov     edx, [ebp+arg_0]
.text$mn:00003C5D                 push    edx
.text$mn:00003C5E                 mov     ecx, [ebp+arg_8]
.text$mn:00003C61                 call    ??$destroy@V?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@@?$_Wrap_alloc@V?$allocator@V?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@@std@@@std@@QAEXPAV?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@1@@Z ; std::_Wrap_alloc<std::allocator<std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>>>>::destroy<std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>>>(std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>> *)
.text$mn:00003C66                 jmp     short loc_3C49
.text$mn:00003C68 ; ---------------------------------------------------------------------------
.text$mn:00003C68
.text$mn:00003C68 loc_3C68:                               ; CODE XREF: std::_Destroy_range<std::_Wrap_alloc<std::allocator<std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>>>>>(std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>> *,std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>> *,std::_Wrap_alloc<std::allocator<std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>>>> &,std::_Nonscalar_ptr_iterator_tag)+14j
.text$mn:00003C68                 pop     ebp
.text$mn:00003C69                 retn
.text$mn:00003C69 ??$_Destroy_range@U?$_Wrap_alloc@V?$allocator@V?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@@std@@@std@@@std@@YAXPAV?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@0@0AAU?$_Wrap_alloc@V?$allocator@V?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@@std@@@0@U_Nonscalar_ptr_iterator_tag@0@@Z endp
.text$mn:00003C69
.text$mn:00003C69 ; ---------------------------------------------------------------------------
.text$mn:00003C6A                 align 4
.text$mn:00003C6A _text$mn        ends
.text$mn:00003C6A
.text$mn:00003C6C ; ===========================================================================
.text$mn:00003C6C
.text$mn:00003C6C ; Segment type: Pure code
.text$mn:00003C6C ; Segment permissions: Read/Execute
.text$mn:00003C6C _text$mn        segment para public 'CODE' use32
.text$mn:00003C6C                 assume cs:_text$mn
.text$mn:00003C6C                 ;org 3C6Ch
.text$mn:00003C6C ; COMDAT (pick any)
.text$mn:00003C6C                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text$mn:00003C6C
.text$mn:00003C6C ; =============== S U B R O U T I N E =======================================
.text$mn:00003C6C
.text$mn:00003C6C ; Attributes: bp-based frame
.text$mn:00003C6C
.text$mn:00003C6C ; void __cdecl std::_Destroy_range<struct std::_Wrap_alloc<class std::allocator<wchar_t>>>(wchar_t *, wchar_t *, struct std::_Wrap_alloc<class std::allocator<wchar_t>> &)
.text$mn:00003C6C                 public ??$_Destroy_range@U?$_Wrap_alloc@V?$allocator@_W@std@@@std@@@std@@YAXPA_W0AAU?$_Wrap_alloc@V?$allocator@_W@std@@@0@@Z
.text$mn:00003C6C ??$_Destroy_range@U?$_Wrap_alloc@V?$allocator@_W@std@@@std@@@std@@YAXPA_W0AAU?$_Wrap_alloc@V?$allocator@_W@std@@@0@@Z proc near
.text$mn:00003C6C                                         ; CODE XREF: std::vector<wchar_t,std::allocator<wchar_t>>::_Destroy(wchar_t *,wchar_t *)+21p
.text$mn:00003C6C
.text$mn:00003C6C var_1           = byte ptr -1
.text$mn:00003C6C arg_0           = dword ptr  8
.text$mn:00003C6C arg_4           = dword ptr  0Ch
.text$mn:00003C6C arg_8           = dword ptr  10h
.text$mn:00003C6C
.text$mn:00003C6C                 push    ebp
.text$mn:00003C6D                 mov     ebp, esp
.text$mn:00003C6F                 push    ecx
.text$mn:00003C70                 mov     eax, [ebp+arg_4]
.text$mn:00003C73                 push    eax
.text$mn:00003C74                 mov     ecx, [ebp+arg_0]
.text$mn:00003C77                 push    ecx
.text$mn:00003C78                 call    ??$_Ptr_cat@_W_W@std@@YA?AU_Scalar_ptr_iterator_tag@0@PA_W0@Z ; std::_Ptr_cat<wchar_t,wchar_t>(wchar_t *,wchar_t *)
.text$mn:00003C7D                 add     esp, 8
.text$mn:00003C80                 mov     [ebp+var_1], al
.text$mn:00003C83                 movzx   edx, [ebp+var_1]
.text$mn:00003C87                 push    edx
.text$mn:00003C88                 mov     eax, [ebp+arg_8]
.text$mn:00003C8B                 push    eax
.text$mn:00003C8C                 mov     ecx, [ebp+arg_4]
.text$mn:00003C8F                 push    ecx
.text$mn:00003C90                 mov     edx, [ebp+arg_0]
.text$mn:00003C93                 push    edx
.text$mn:00003C94                 call    ??$_Destroy_range@U?$_Wrap_alloc@V?$allocator@_W@std@@@std@@@std@@YAXPA_W0AAU?$_Wrap_alloc@V?$allocator@_W@std@@@0@U_Scalar_ptr_iterator_tag@0@@Z ; std::_Destroy_range<std::_Wrap_alloc<std::allocator<wchar_t>>>(wchar_t *,wchar_t *,std::_Wrap_alloc<std::allocator<wchar_t>> &,std::_Scalar_ptr_iterator_tag)
.text$mn:00003C99                 add     esp, 10h
.text$mn:00003C9C                 mov     esp, ebp
.text$mn:00003C9E                 pop     ebp
.text$mn:00003C9F                 retn
.text$mn:00003C9F ??$_Destroy_range@U?$_Wrap_alloc@V?$allocator@_W@std@@@std@@@std@@YAXPA_W0AAU?$_Wrap_alloc@V?$allocator@_W@std@@@0@@Z endp
.text$mn:00003C9F
.text$mn:00003C9F _text$mn        ends
.text$mn:00003C9F
.text$mn:00003CA0 ; ===========================================================================
.text$mn:00003CA0
.text$mn:00003CA0 ; Segment type: Pure code
.text$mn:00003CA0 ; Segment permissions: Read/Execute
.text$mn:00003CA0 _text$mn        segment para public 'CODE' use32
.text$mn:00003CA0                 assume cs:_text$mn
.text$mn:00003CA0                 ;org 3CA0h
.text$mn:00003CA0 ; COMDAT (pick any)
.text$mn:00003CA0                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text$mn:00003CA0
.text$mn:00003CA0 ; =============== S U B R O U T I N E =======================================
.text$mn:00003CA0
.text$mn:00003CA0 ; Attributes: bp-based frame
.text$mn:00003CA0
.text$mn:00003CA0 ; void __cdecl std::_Destroy_range<struct std::_Wrap_alloc<class std::allocator<wchar_t>>>(wchar_t *, wchar_t *, struct std::_Wrap_alloc<class std::allocator<wchar_t>> &, struct std::_Scalar_ptr_iterator_tag)
.text$mn:00003CA0                 public ??$_Destroy_range@U?$_Wrap_alloc@V?$allocator@_W@std@@@std@@@std@@YAXPA_W0AAU?$_Wrap_alloc@V?$allocator@_W@std@@@0@U_Scalar_ptr_iterator_tag@0@@Z
.text$mn:00003CA0 ??$_Destroy_range@U?$_Wrap_alloc@V?$allocator@_W@std@@@std@@@std@@YAXPA_W0AAU?$_Wrap_alloc@V?$allocator@_W@std@@@0@U_Scalar_ptr_iterator_tag@0@@Z proc near
.text$mn:00003CA0                                         ; CODE XREF: std::_Destroy_range<std::_Wrap_alloc<std::allocator<wchar_t>>>(wchar_t *,wchar_t *,std::_Wrap_alloc<std::allocator<wchar_t>> &)+28p
.text$mn:00003CA0                 push    ebp
.text$mn:00003CA1                 mov     ebp, esp
.text$mn:00003CA3                 pop     ebp
.text$mn:00003CA4                 retn
.text$mn:00003CA4 ??$_Destroy_range@U?$_Wrap_alloc@V?$allocator@_W@std@@@std@@@std@@YAXPA_W0AAU?$_Wrap_alloc@V?$allocator@_W@std@@@0@U_Scalar_ptr_iterator_tag@0@@Z endp
.text$mn:00003CA4
.text$mn:00003CA4 ; ---------------------------------------------------------------------------
.text$mn:00003CA5                 align 4
.text$mn:00003CA5 _text$mn        ends
.text$mn:00003CA5
.text$mn:00003CA8 ; ===========================================================================
.text$mn:00003CA8
.text$mn:00003CA8 ; Segment type: Pure code
.text$mn:00003CA8 ; Segment permissions: Read/Execute
.text$mn:00003CA8 _text$mn        segment para public 'CODE' use32
.text$mn:00003CA8                 assume cs:_text$mn
.text$mn:00003CA8                 ;org 3CA8h
.text$mn:00003CA8 ; COMDAT (pick any)
.text$mn:00003CA8                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text$mn:00003CA8
.text$mn:00003CA8 ; =============== S U B R O U T I N E =======================================
.text$mn:00003CA8
.text$mn:00003CA8 ; Attributes: bp-based frame
.text$mn:00003CA8
.text$mn:00003CA8 ; void __cdecl std::_Distance2<class std::reverse_iterator<class std::_Vector_iterator<class std::_Vector_val<struct std::_Simple_types<wchar_t>>>>, unsigned int>(class std::reverse_iterator<class std::_Vector_iterator<class std::_Vector_val<struct std::_Simple_types<wchar_t>>>>, class std::reverse_iterator<class std::_Vector_iterator<class std::_Vector_val<struct std::_Simple_types<wchar_t>>>>, unsigned int &, struct std::random_access_iterator_tag)
.text$mn:00003CA8                 public ??$_Distance2@V?$reverse_iterator@V?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@_W@std@@@std@@@std@@@std@@I@std@@YAXV?$reverse_iterator@V?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@_W@std@@@std@@@std@@@0@0AAIUrandom_access_iterator_tag@0@@Z
.text$mn:00003CA8 ??$_Distance2@V?$reverse_iterator@V?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@_W@std@@@std@@@std@@@std@@I@std@@YAXV?$reverse_iterator@V?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@_W@std@@@std@@@std@@@0@0AAIUrandom_access_iterator_tag@0@@Z proc near
.text$mn:00003CA8                                         ; CODE XREF: std::_Distance<std::reverse_iterator<std::_Vector_iterator<std::_Vector_val<std::_Simple_types<wchar_t>>>>,uint>(std::reverse_iterator<std::_Vector_iterator<std::_Vector_val<std::_Simple_types<wchar_t>>>>,std::reverse_iterator<std::_Vector_iterator<std::_Vector_val<std::_Simple_types<wchar_t>>>>,uint &)+86p
.text$mn:00003CA8
.text$mn:00003CA8 var_C           = dword ptr -0Ch
.text$mn:00003CA8 var_4           = dword ptr -4
.text$mn:00003CA8 arg_0           = byte ptr  8
.text$mn:00003CA8 arg_C           = byte ptr  14h
.text$mn:00003CA8 arg_18          = dword ptr  20h
.text$mn:00003CA8
.text$mn:00003CA8                 push    ebp
.text$mn:00003CA9                 mov     ebp, esp
.text$mn:00003CAB                 push    0FFFFFFFFh
.text$mn:00003CAD                 push    offset __ehhandler$??$_Distance2@V?$reverse_iterator@V?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@_W@std@@@std@@@std@@@std@@I@std@@YAXV?$reverse_iterator@V?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@_W@std@@@std@@@std@@@0@0AAIUrandom_access_iterator_tag@0@@Z
.text$mn:00003CB2                 mov     eax, large fs:0
.text$mn:00003CB8                 push    eax
.text$mn:00003CB9                 mov     eax, dword ptr ds:___security_cookie
.text$mn:00003CBE                 xor     eax, ebp
.text$mn:00003CC0                 push    eax
.text$mn:00003CC1                 lea     eax, [ebp+var_C]
.text$mn:00003CC4                 mov     large fs:0, eax
.text$mn:00003CCA                 mov     [ebp+var_4], 1
.text$mn:00003CD1                 lea     eax, [ebp+arg_C]
.text$mn:00003CD4                 push    eax
.text$mn:00003CD5                 lea     ecx, [ebp+arg_0]
.text$mn:00003CD8                 push    ecx
.text$mn:00003CD9                 call    ??$?9V?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@_W@std@@@std@@@std@@V01@@std@@YA_NABV?$reverse_iterator@V?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@_W@std@@@std@@@std@@@0@0@Z ; std::operator!=<std::_Vector_iterator<std::_Vector_val<std::_Simple_types<wchar_t>>>,std::_Vector_iterator<std::_Vector_val<std::_Simple_types<wchar_t>>>>(std::reverse_iterator<std::_Vector_iterator<std::_Vector_val<std::_Simple_types<wchar_t>>>> const &,std::reverse_iterator<std::_Vector_iterator<std::_Vector_val<std::_Simple_types<wchar_t>>>> const &)
.text$mn:00003CDE                 add     esp, 8
.text$mn:00003CE1                 movzx   edx, al
.text$mn:00003CE4                 test    edx, edx
.text$mn:00003CE6                 jz      short loc_3D14
.text$mn:00003CE8                 push    2E9h
.text$mn:00003CED                 push    offset ??_C@_1JA@EADLBAJ@?$AAC?$AA?3?$AA?2?$AAP?$AAr?$AAo?$AAg?$AAr?$AAa?$AAm?$AA?5?$AAF?$AAi?$AAl?$AAe?$AAs?$AA?5?$AA?$CI?$AAx?$AA8?$AA6?$AA?$CJ?$AA?2?$AAM?$AAi?$AAc?$AAr?$AAo?$AAs?$AAo?$AAf?$AAt@ ; "C:\\Program Files (x86)\\Microsoft Visu"...
.text$mn:00003CF2                 lea     eax, [ebp+arg_0]
.text$mn:00003CF5                 push    eax
.text$mn:00003CF6                 call    ??$_Debug_pointer@V?$reverse_iterator@V?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@_W@std@@@std@@@std@@@std@@@std@@YAXAAV?$reverse_iterator@V?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@_W@std@@@std@@@std@@@0@PB_WI@Z ; std::_Debug_pointer<std::reverse_iterator<std::_Vector_iterator<std::_Vector_val<std::_Simple_types<wchar_t>>>>>(std::reverse_iterator<std::_Vector_iterator<std::_Vector_val<std::_Simple_types<wchar_t>>>> &,wchar_t const *,uint)
.text$mn:00003CFB                 add     esp, 0Ch
.text$mn:00003CFE                 push    2EAh
.text$mn:00003D03                 push    offset ??_C@_1JA@EADLBAJ@?$AAC?$AA?3?$AA?2?$AAP?$AAr?$AAo?$AAg?$AAr?$AAa?$AAm?$AA?5?$AAF?$AAi?$AAl?$AAe?$AAs?$AA?5?$AA?$CI?$AAx?$AA8?$AA6?$AA?$CJ?$AA?2?$AAM?$AAi?$AAc?$AAr?$AAo?$AAs?$AAo?$AAf?$AAt@ ; "C:\\Program Files (x86)\\Microsoft Visu"...
.text$mn:00003D08                 lea     ecx, [ebp+arg_C]
.text$mn:00003D0B                 push    ecx
.text$mn:00003D0C                 call    ??$_Debug_pointer@V?$reverse_iterator@V?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@_W@std@@@std@@@std@@@std@@@std@@YAXAAV?$reverse_iterator@V?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@_W@std@@@std@@@std@@@0@PB_WI@Z ; std::_Debug_pointer<std::reverse_iterator<std::_Vector_iterator<std::_Vector_val<std::_Simple_types<wchar_t>>>>>(std::reverse_iterator<std::_Vector_iterator<std::_Vector_val<std::_Simple_types<wchar_t>>>> &,wchar_t const *,uint)
.text$mn:00003D11                 add     esp, 0Ch
.text$mn:00003D14
.text$mn:00003D14 loc_3D14:                               ; CODE XREF: std::_Distance2<std::reverse_iterator<std::_Vector_iterator<std::_Vector_val<std::_Simple_types<wchar_t>>>>,uint>(std::reverse_iterator<std::_Vector_iterator<std::_Vector_val<std::_Simple_types<wchar_t>>>>,std::reverse_iterator<std::_Vector_iterator<std::_Vector_val<std::_Simple_types<wchar_t>>>>,uint &,std::random_access_iterator_tag)+3Ej
.text$mn:00003D14                 lea     edx, [ebp+arg_0]
.text$mn:00003D17                 push    edx
.text$mn:00003D18                 lea     eax, [ebp+arg_C]
.text$mn:00003D1B                 push    eax
.text$mn:00003D1C                 call    ??$?GV?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@_W@std@@@std@@@std@@V01@@std@@YAHABV?$reverse_iterator@V?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@_W@std@@@std@@@std@@@0@0@Z ; std::operator-<std::_Vector_iterator<std::_Vector_val<std::_Simple_types<wchar_t>>>,std::_Vector_iterator<std::_Vector_val<std::_Simple_types<wchar_t>>>>(std::reverse_iterator<std::_Vector_iterator<std::_Vector_val<std::_Simple_types<wchar_t>>>> const &,std::reverse_iterator<std::_Vector_iterator<std::_Vector_val<std::_Simple_types<wchar_t>>>> const &)
.text$mn:00003D21                 add     esp, 8
.text$mn:00003D24                 mov     ecx, [ebp+arg_18]
.text$mn:00003D27                 add     eax, [ecx]
.text$mn:00003D29                 mov     edx, [ebp+arg_18]
.text$mn:00003D2C                 mov     [edx], eax
.text$mn:00003D2E                 mov     byte ptr [ebp+var_4], 0
.text$mn:00003D32                 lea     ecx, [ebp+arg_0]
.text$mn:00003D35                 call    ??1?$reverse_iterator@V?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@_W@std@@@std@@@std@@@std@@QAE@XZ ; std::reverse_iterator<std::_Vector_iterator<std::_Vector_val<std::_Simple_types<wchar_t>>>>::~reverse_iterator<std::_Vector_iterator<std::_Vector_val<std::_Simple_types<wchar_t>>>>(void)
.text$mn:00003D3A                 mov     [ebp+var_4], 0FFFFFFFFh
.text$mn:00003D41                 lea     ecx, [ebp+arg_C]
.text$mn:00003D44                 call    ??1?$reverse_iterator@V?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@_W@std@@@std@@@std@@@std@@QAE@XZ ; std::reverse_iterator<std::_Vector_iterator<std::_Vector_val<std::_Simple_types<wchar_t>>>>::~reverse_iterator<std::_Vector_iterator<std::_Vector_val<std::_Simple_types<wchar_t>>>>(void)
.text$mn:00003D49                 mov     ecx, [ebp+var_C]
.text$mn:00003D4C                 mov     large fs:0, ecx
.text$mn:00003D53                 pop     ecx
.text$mn:00003D54                 mov     esp, ebp
.text$mn:00003D56                 pop     ebp
.text$mn:00003D57                 retn
.text$mn:00003D57 ??$_Distance2@V?$reverse_iterator@V?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@_W@std@@@std@@@std@@@std@@I@std@@YAXV?$reverse_iterator@V?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@_W@std@@@std@@@std@@@0@0AAIUrandom_access_iterator_tag@0@@Z endp
.text$mn:00003D57
.text$mn:00003D57 _text$mn        ends
.text$mn:00003D57
.text$x:00003D58 ; ===========================================================================
.text$x:00003D58
.text$x:00003D58 ; Segment type: Pure code
.text$x:00003D58 ; Segment permissions: Read/Execute
.text$x:00003D58 _text$x         segment para public 'CODE' use32
.text$x:00003D58                 assume cs:_text$x
.text$x:00003D58                 ;org 3D58h
.text$x:00003D58 ; COMDAT (pick associative to section at 3CA8)
.text$x:00003D58                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text$x:00003D58
.text$x:00003D58 ; =============== S U B R O U T I N E =======================================
.text$x:00003D58
.text$x:00003D58
.text$x:00003D58 __unwindfunclet$??$_Distance2@V?$reverse_iterator@V?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@_W@std@@@std@@@std@@@std@@I@std@@YAXV?$reverse_iterator@V?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@_W@std@@@std@@@std@@@0@0AAIUrandom_access_iterator_tag@0@@Z$0 proc near
.text$x:00003D58                                         ; DATA XREF: .xdata$x:0000F158o
.text$x:00003D58                 lea     ecx, [ebp+14h]
.text$x:00003D5B                 jmp     ??1?$reverse_iterator@V?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@_W@std@@@std@@@std@@@std@@QAE@XZ ; std::reverse_iterator<std::_Vector_iterator<std::_Vector_val<std::_Simple_types<wchar_t>>>>::~reverse_iterator<std::_Vector_iterator<std::_Vector_val<std::_Simple_types<wchar_t>>>>(void)
.text$x:00003D5B __unwindfunclet$??$_Distance2@V?$reverse_iterator@V?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@_W@std@@@std@@@std@@@std@@I@std@@YAXV?$reverse_iterator@V?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@_W@std@@@std@@@std@@@0@0AAIUrandom_access_iterator_tag@0@@Z$0 endp
.text$x:00003D5B
.text$x:00003D60
.text$x:00003D60 ; =============== S U B R O U T I N E =======================================
.text$x:00003D60
.text$x:00003D60
.text$x:00003D60 __unwindfunclet$??$_Distance2@V?$reverse_iterator@V?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@_W@std@@@std@@@std@@@std@@I@std@@YAXV?$reverse_iterator@V?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@_W@std@@@std@@@std@@@0@0AAIUrandom_access_iterator_tag@0@@Z$1 proc near
.text$x:00003D60                                         ; DATA XREF: .xdata$x:0000F160o
.text$x:00003D60                 lea     ecx, [ebp+8]
.text$x:00003D63                 jmp     ??1?$reverse_iterator@V?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@_W@std@@@std@@@std@@@std@@QAE@XZ ; std::reverse_iterator<std::_Vector_iterator<std::_Vector_val<std::_Simple_types<wchar_t>>>>::~reverse_iterator<std::_Vector_iterator<std::_Vector_val<std::_Simple_types<wchar_t>>>>(void)
.text$x:00003D63 __unwindfunclet$??$_Distance2@V?$reverse_iterator@V?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@_W@std@@@std@@@std@@@std@@I@std@@YAXV?$reverse_iterator@V?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@_W@std@@@std@@@std@@@0@0AAIUrandom_access_iterator_tag@0@@Z$1 endp
.text$x:00003D63
.text$x:00003D68
.text$x:00003D68 ; =============== S U B R O U T I N E =======================================
.text$x:00003D68
.text$x:00003D68
.text$x:00003D68 __ehhandler$??$_Distance2@V?$reverse_iterator@V?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@_W@std@@@std@@@std@@@std@@I@std@@YAXV?$reverse_iterator@V?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@_W@std@@@std@@@std@@@0@0AAIUrandom_access_iterator_tag@0@@Z proc near
.text$x:00003D68                                         ; DATA XREF: std::_Distance2<std::reverse_iterator<std::_Vector_iterator<std::_Vector_val<std::_Simple_types<wchar_t>>>>,uint>(std::reverse_iterator<std::_Vector_iterator<std::_Vector_val<std::_Simple_types<wchar_t>>>>,std::reverse_iterator<std::_Vector_iterator<std::_Vector_val<std::_Simple_types<wchar_t>>>>,uint &,std::random_access_iterator_tag)+5o
.text$x:00003D68
.text$x:00003D68 arg_4           = dword ptr  8
.text$x:00003D68
.text$x:00003D68                 mov     edx, [esp+arg_4]
.text$x:00003D6C                 lea     eax, [edx+0Ch]
.text$x:00003D6F                 mov     ecx, [edx-4]
.text$x:00003D72                 xor     ecx, eax
.text$x:00003D74                 call    @__security_check_cookie@4 ; __security_check_cookie(x)
.text$x:00003D79                 mov     eax, offset __ehfuncinfo$??$_Distance2@V?$reverse_iterator@V?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@_W@std@@@std@@@std@@@std@@I@std@@YAXV?$reverse_iterator@V?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@_W@std@@@std@@@std@@@0@0AAIUrandom_access_iterator_tag@0@@Z
.text$x:00003D7E                 jmp     ___CxxFrameHandler3
.text$x:00003D7E __ehhandler$??$_Distance2@V?$reverse_iterator@V?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@_W@std@@@std@@@std@@@std@@I@std@@YAXV?$reverse_iterator@V?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@_W@std@@@std@@@std@@@0@0AAIUrandom_access_iterator_tag@0@@Z endp
.text$x:00003D7E
.text$x:00003D7E ; ---------------------------------------------------------------------------
.text$x:00003D83                 align 4
.text$x:00003D83 _text$x         ends
.text$x:00003D83
.text$mn:00003D84 ; ===========================================================================
.text$mn:00003D84
.text$mn:00003D84 ; Segment type: Pure code
.text$mn:00003D84 ; Segment permissions: Read/Execute
.text$mn:00003D84 _text$mn        segment para public 'CODE' use32
.text$mn:00003D84                 assume cs:_text$mn
.text$mn:00003D84                 ;org 3D84h
.text$mn:00003D84 ; COMDAT (pick any)
.text$mn:00003D84                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text$mn:00003D84
.text$mn:00003D84 ; =============== S U B R O U T I N E =======================================
.text$mn:00003D84
.text$mn:00003D84 ; Attributes: bp-based frame
.text$mn:00003D84
.text$mn:00003D84 ; void __cdecl std::_Distance<class std::reverse_iterator<class std::_Vector_iterator<class std::_Vector_val<struct std::_Simple_types<wchar_t>>>>, unsigned int>(class std::reverse_iterator<class std::_Vector_iterator<class std::_Vector_val<struct std::_Simple_types<wchar_t>>>>, class std::reverse_iterator<class std::_Vector_iterator<class std::_Vector_val<struct std::_Simple_types<wchar_t>>>>, unsigned int &)
.text$mn:00003D84                 public ??$_Distance@V?$reverse_iterator@V?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@_W@std@@@std@@@std@@@std@@I@std@@YAXV?$reverse_iterator@V?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@_W@std@@@std@@@std@@@0@0AAI@Z
.text$mn:00003D84 ??$_Distance@V?$reverse_iterator@V?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@_W@std@@@std@@@std@@@std@@I@std@@YAXV?$reverse_iterator@V?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@_W@std@@@std@@@std@@@0@0AAI@Z proc near
.text$mn:00003D84                                         ; CODE XREF: std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>>::_Construct<std::reverse_iterator<std::_Vector_iterator<std::_Vector_val<std::_Simple_types<wchar_t>>>>>(std::reverse_iterator<std::_Vector_iterator<std::_Vector_val<std::_Simple_types<wchar_t>>>>,std::reverse_iterator<std::_Vector_iterator<std::_Vector_val<std::_Simple_types<wchar_t>>>>,std::forward_iterator_tag)+D3p
.text$mn:00003D84
.text$mn:00003D84 var_28          = dword ptr -28h
.text$mn:00003D84 var_24          = dword ptr -24h
.text$mn:00003D84 var_20          = dword ptr -20h
.text$mn:00003D84 var_1C          = dword ptr -1Ch
.text$mn:00003D84 var_18          = dword ptr -18h
.text$mn:00003D84 var_14          = dword ptr -14h
.text$mn:00003D84 var_D           = byte ptr -0Dh
.text$mn:00003D84 var_C           = dword ptr -0Ch
.text$mn:00003D84 var_4           = dword ptr -4
.text$mn:00003D84 arg_0           = byte ptr  8
.text$mn:00003D84 arg_C           = byte ptr  14h
.text$mn:00003D84 arg_18          = dword ptr  20h
.text$mn:00003D84
.text$mn:00003D84                 push    ebp
.text$mn:00003D85                 mov     ebp, esp
.text$mn:00003D87                 push    0FFFFFFFFh
.text$mn:00003D89                 push    offset __ehhandler$??$_Distance@V?$reverse_iterator@V?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@_W@std@@@std@@@std@@@std@@I@std@@YAXV?$reverse_iterator@V?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@_W@std@@@std@@@std@@@0@0AAI@Z
.text$mn:00003D8E                 mov     eax, large fs:0
.text$mn:00003D94                 push    eax
.text$mn:00003D95                 sub     esp, 1Ch
.text$mn:00003D98                 mov     eax, dword ptr ds:___security_cookie
.text$mn:00003D9D                 xor     eax, ebp
.text$mn:00003D9F                 push    eax
.text$mn:00003DA0                 lea     eax, [ebp+var_C]
.text$mn:00003DA3                 mov     large fs:0, eax
.text$mn:00003DA9                 mov     [ebp+var_4], 1
.text$mn:00003DB0                 lea     eax, [ebp+arg_0]
.text$mn:00003DB3                 push    eax
.text$mn:00003DB4                 lea     ecx, [ebp+var_D]
.text$mn:00003DB7                 push    ecx
.text$mn:00003DB8                 call    ??$_Iter_cat@V?$reverse_iterator@V?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@_W@std@@@std@@@std@@@std@@@std@@YA?AUrandom_access_iterator_tag@0@ABV?$reverse_iterator@V?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@_W@std@@@std@@@std@@@0@@Z ; std::_Iter_cat<std::reverse_iterator<std::_Vector_iterator<std::_Vector_val<std::_Simple_types<wchar_t>>>>>(std::reverse_iterator<std::_Vector_iterator<std::_Vector_val<std::_Simple_types<wchar_t>>>> const &)
.text$mn:00003DBD                 add     esp, 8
.text$mn:00003DC0                 mov     dl, [eax]
.text$mn:00003DC2                 movzx   eax, dl
.text$mn:00003DC5                 push    eax
.text$mn:00003DC6                 mov     ecx, [ebp+arg_18]
.text$mn:00003DC9                 push    ecx
.text$mn:00003DCA                 sub     esp, 0Ch
.text$mn:00003DCD                 mov     ecx, esp
.text$mn:00003DCF                 mov     [ebp+var_1C], esp
.text$mn:00003DD2                 lea     edx, [ebp+arg_C]
.text$mn:00003DD5                 push    edx             ; struct std::_Iterator_base12 *
.text$mn:00003DD6                 call    ??0?$reverse_iterator@V?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@_W@std@@@std@@@std@@@std@@QAE@ABV01@@Z ; std::reverse_iterator<std::_Vector_iterator<std::_Vector_val<std::_Simple_types<wchar_t>>>>::reverse_iterator<std::_Vector_iterator<std::_Vector_val<std::_Simple_types<wchar_t>>>>(std::reverse_iterator<std::_Vector_iterator<std::_Vector_val<std::_Simple_types<wchar_t>>>> const &)
.text$mn:00003DDB                 mov     [ebp+var_14], eax
.text$mn:00003DDE                 mov     eax, [ebp+var_14]
.text$mn:00003DE1                 mov     [ebp+var_20], eax
.text$mn:00003DE4                 mov     byte ptr [ebp+var_4], 2
.text$mn:00003DE8                 sub     esp, 0Ch
.text$mn:00003DEB                 mov     ecx, esp
.text$mn:00003DED                 mov     [ebp+var_24], esp
.text$mn:00003DF0                 lea     edx, [ebp+arg_0]
.text$mn:00003DF3                 push    edx             ; struct std::_Iterator_base12 *
.text$mn:00003DF4                 call    ??0?$reverse_iterator@V?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@_W@std@@@std@@@std@@@std@@QAE@ABV01@@Z ; std::reverse_iterator<std::_Vector_iterator<std::_Vector_val<std::_Simple_types<wchar_t>>>>::reverse_iterator<std::_Vector_iterator<std::_Vector_val<std::_Simple_types<wchar_t>>>>(std::reverse_iterator<std::_Vector_iterator<std::_Vector_val<std::_Simple_types<wchar_t>>>> const &)
.text$mn:00003DF9                 mov     [ebp+var_18], eax
.text$mn:00003DFC                 mov     eax, [ebp+var_18]
.text$mn:00003DFF                 mov     [ebp+var_28], eax
.text$mn:00003E02                 mov     byte ptr [ebp+var_4], 3
.text$mn:00003E06                 mov     byte ptr [ebp+var_4], 1
.text$mn:00003E0A                 call    ??$_Distance2@V?$reverse_iterator@V?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@_W@std@@@std@@@std@@@std@@I@std@@YAXV?$reverse_iterator@V?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@_W@std@@@std@@@std@@@0@0AAIUrandom_access_iterator_tag@0@@Z ; std::_Distance2<std::reverse_iterator<std::_Vector_iterator<std::_Vector_val<std::_Simple_types<wchar_t>>>>,uint>(std::reverse_iterator<std::_Vector_iterator<std::_Vector_val<std::_Simple_types<wchar_t>>>>,std::reverse_iterator<std::_Vector_iterator<std::_Vector_val<std::_Simple_types<wchar_t>>>>,uint &,std::random_access_iterator_tag)
.text$mn:00003E0F                 add     esp, 20h
.text$mn:00003E12                 mov     byte ptr [ebp+var_4], 0
.text$mn:00003E16                 lea     ecx, [ebp+arg_0]
.text$mn:00003E19                 call    ??1?$reverse_iterator@V?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@_W@std@@@std@@@std@@@std@@QAE@XZ ; std::reverse_iterator<std::_Vector_iterator<std::_Vector_val<std::_Simple_types<wchar_t>>>>::~reverse_iterator<std::_Vector_iterator<std::_Vector_val<std::_Simple_types<wchar_t>>>>(void)
.text$mn:00003E1E                 mov     [ebp+var_4], 0FFFFFFFFh
.text$mn:00003E25                 lea     ecx, [ebp+arg_C]
.text$mn:00003E28                 call    ??1?$reverse_iterator@V?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@_W@std@@@std@@@std@@@std@@QAE@XZ ; std::reverse_iterator<std::_Vector_iterator<std::_Vector_val<std::_Simple_types<wchar_t>>>>::~reverse_iterator<std::_Vector_iterator<std::_Vector_val<std::_Simple_types<wchar_t>>>>(void)
.text$mn:00003E2D                 mov     ecx, [ebp+var_C]
.text$mn:00003E30                 mov     large fs:0, ecx
.text$mn:00003E37                 pop     ecx
.text$mn:00003E38                 mov     esp, ebp
.text$mn:00003E3A                 pop     ebp
.text$mn:00003E3B                 retn
.text$mn:00003E3B ??$_Distance@V?$reverse_iterator@V?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@_W@std@@@std@@@std@@@std@@I@std@@YAXV?$reverse_iterator@V?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@_W@std@@@std@@@std@@@0@0AAI@Z endp
.text$mn:00003E3B
.text$mn:00003E3B _text$mn        ends
.text$mn:00003E3B
.text$x:00003E3C ; ===========================================================================
.text$x:00003E3C
.text$x:00003E3C ; Segment type: Pure code
.text$x:00003E3C ; Segment permissions: Read/Execute
.text$x:00003E3C _text$x         segment para public 'CODE' use32
.text$x:00003E3C                 assume cs:_text$x
.text$x:00003E3C                 ;org 3E3Ch
.text$x:00003E3C ; COMDAT (pick associative to section at 3D84)
.text$x:00003E3C                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text$x:00003E3C
.text$x:00003E3C ; =============== S U B R O U T I N E =======================================
.text$x:00003E3C
.text$x:00003E3C
.text$x:00003E3C __unwindfunclet$??$_Distance@V?$reverse_iterator@V?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@_W@std@@@std@@@std@@@std@@I@std@@YAXV?$reverse_iterator@V?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@_W@std@@@std@@@std@@@0@0AAI@Z$0 proc near
.text$x:00003E3C                                         ; DATA XREF: .xdata$x:0000EFB8o
.text$x:00003E3C                 lea     ecx, [ebp+14h]
.text$x:00003E3F                 jmp     ??1?$reverse_iterator@V?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@_W@std@@@std@@@std@@@std@@QAE@XZ ; std::reverse_iterator<std::_Vector_iterator<std::_Vector_val<std::_Simple_types<wchar_t>>>>::~reverse_iterator<std::_Vector_iterator<std::_Vector_val<std::_Simple_types<wchar_t>>>>(void)
.text$x:00003E3F __unwindfunclet$??$_Distance@V?$reverse_iterator@V?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@_W@std@@@std@@@std@@@std@@I@std@@YAXV?$reverse_iterator@V?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@_W@std@@@std@@@std@@@0@0AAI@Z$0 endp
.text$x:00003E3F
.text$x:00003E44
.text$x:00003E44 ; =============== S U B R O U T I N E =======================================
.text$x:00003E44
.text$x:00003E44
.text$x:00003E44 __unwindfunclet$??$_Distance@V?$reverse_iterator@V?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@_W@std@@@std@@@std@@@std@@I@std@@YAXV?$reverse_iterator@V?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@_W@std@@@std@@@std@@@0@0AAI@Z$1 proc near
.text$x:00003E44                                         ; DATA XREF: .xdata$x:0000EFC0o
.text$x:00003E44                 lea     ecx, [ebp+8]
.text$x:00003E47                 jmp     ??1?$reverse_iterator@V?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@_W@std@@@std@@@std@@@std@@QAE@XZ ; std::reverse_iterator<std::_Vector_iterator<std::_Vector_val<std::_Simple_types<wchar_t>>>>::~reverse_iterator<std::_Vector_iterator<std::_Vector_val<std::_Simple_types<wchar_t>>>>(void)
.text$x:00003E47 __unwindfunclet$??$_Distance@V?$reverse_iterator@V?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@_W@std@@@std@@@std@@@std@@I@std@@YAXV?$reverse_iterator@V?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@_W@std@@@std@@@std@@@0@0AAI@Z$1 endp
.text$x:00003E47
.text$x:00003E4C
.text$x:00003E4C ; =============== S U B R O U T I N E =======================================
.text$x:00003E4C
.text$x:00003E4C
.text$x:00003E4C __unwindfunclet$??$_Distance@V?$reverse_iterator@V?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@_W@std@@@std@@@std@@@std@@I@std@@YAXV?$reverse_iterator@V?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@_W@std@@@std@@@std@@@0@0AAI@Z$2 proc near
.text$x:00003E4C                                         ; DATA XREF: .xdata$x:0000EFC8o
.text$x:00003E4C                 mov     ecx, [ebp-1Ch]
.text$x:00003E4F                 jmp     ??1?$reverse_iterator@V?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@_W@std@@@std@@@std@@@std@@QAE@XZ ; std::reverse_iterator<std::_Vector_iterator<std::_Vector_val<std::_Simple_types<wchar_t>>>>::~reverse_iterator<std::_Vector_iterator<std::_Vector_val<std::_Simple_types<wchar_t>>>>(void)
.text$x:00003E4F __unwindfunclet$??$_Distance@V?$reverse_iterator@V?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@_W@std@@@std@@@std@@@std@@I@std@@YAXV?$reverse_iterator@V?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@_W@std@@@std@@@std@@@0@0AAI@Z$2 endp
.text$x:00003E4F
.text$x:00003E54
.text$x:00003E54 ; =============== S U B R O U T I N E =======================================
.text$x:00003E54
.text$x:00003E54
.text$x:00003E54 __unwindfunclet$??$_Distance@V?$reverse_iterator@V?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@_W@std@@@std@@@std@@@std@@I@std@@YAXV?$reverse_iterator@V?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@_W@std@@@std@@@std@@@0@0AAI@Z$3 proc near
.text$x:00003E54                                         ; DATA XREF: .xdata$x:0000EFD0o
.text$x:00003E54                 mov     ecx, [ebp-24h]
.text$x:00003E57                 jmp     ??1?$reverse_iterator@V?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@_W@std@@@std@@@std@@@std@@QAE@XZ ; std::reverse_iterator<std::_Vector_iterator<std::_Vector_val<std::_Simple_types<wchar_t>>>>::~reverse_iterator<std::_Vector_iterator<std::_Vector_val<std::_Simple_types<wchar_t>>>>(void)
.text$x:00003E57 __unwindfunclet$??$_Distance@V?$reverse_iterator@V?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@_W@std@@@std@@@std@@@std@@I@std@@YAXV?$reverse_iterator@V?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@_W@std@@@std@@@std@@@0@0AAI@Z$3 endp
.text$x:00003E57
.text$x:00003E5C
.text$x:00003E5C ; =============== S U B R O U T I N E =======================================
.text$x:00003E5C
.text$x:00003E5C
.text$x:00003E5C __ehhandler$??$_Distance@V?$reverse_iterator@V?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@_W@std@@@std@@@std@@@std@@I@std@@YAXV?$reverse_iterator@V?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@_W@std@@@std@@@std@@@0@0AAI@Z proc near
.text$x:00003E5C                                         ; DATA XREF: std::_Distance<std::reverse_iterator<std::_Vector_iterator<std::_Vector_val<std::_Simple_types<wchar_t>>>>,uint>(std::reverse_iterator<std::_Vector_iterator<std::_Vector_val<std::_Simple_types<wchar_t>>>>,std::reverse_iterator<std::_Vector_iterator<std::_Vector_val<std::_Simple_types<wchar_t>>>>,uint &)+5o
.text$x:00003E5C
.text$x:00003E5C arg_4           = dword ptr  8
.text$x:00003E5C
.text$x:00003E5C                 mov     edx, [esp+arg_4]
.text$x:00003E60                 lea     eax, [edx+0Ch]
.text$x:00003E63                 mov     ecx, [edx-20h]
.text$x:00003E66                 xor     ecx, eax
.text$x:00003E68                 call    @__security_check_cookie@4 ; __security_check_cookie(x)
.text$x:00003E6D                 mov     eax, offset __ehfuncinfo$??$_Distance@V?$reverse_iterator@V?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@_W@std@@@std@@@std@@@std@@I@std@@YAXV?$reverse_iterator@V?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@_W@std@@@std@@@std@@@0@0AAI@Z
.text$x:00003E72                 jmp     ___CxxFrameHandler3
.text$x:00003E72 __ehhandler$??$_Distance@V?$reverse_iterator@V?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@_W@std@@@std@@@std@@@std@@I@std@@YAXV?$reverse_iterator@V?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@_W@std@@@std@@@std@@@0@0AAI@Z endp
.text$x:00003E72
.text$x:00003E72 ; ---------------------------------------------------------------------------
.text$x:00003E77                 align 4
.text$x:00003E77 _text$x         ends
.text$x:00003E77
.text$mn:00003E78 ; ===========================================================================
.text$mn:00003E78
.text$mn:00003E78 ; Segment type: Pure code
.text$mn:00003E78 ; Segment permissions: Read/Execute
.text$mn:00003E78 _text$mn        segment para public 'CODE' use32
.text$mn:00003E78                 assume cs:_text$mn
.text$mn:00003E78                 ;org 3E78h
.text$mn:00003E78 ; COMDAT (pick any)
.text$mn:00003E78                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text$mn:00003E78
.text$mn:00003E78 ; =============== S U B R O U T I N E =======================================
.text$mn:00003E78
.text$mn:00003E78 ; Attributes: bp-based frame
.text$mn:00003E78
.text$mn:00003E78 ; public: bool __thiscall std::_Revranit<class std::_Vector_iterator<class std::_Vector_val<struct std::_Simple_types<wchar_t>>>, struct std::iterator<struct std::random_access_iterator_tag, wchar_t, int, wchar_t *, wchar_t &>>::_Equal<class std::_Vector_iterator<class std::_Vector_val<struct std::_Simple_types<wchar_t>>>, struct std::iterator<struct std::random_access_iterator_tag, wchar_t, int, wchar_t *, wchar_t &>>(class std::_Revranit<class std::_Vector_iterator<class std::_Vector_val<struct std::_Simple_types<wchar_t>>>, struct std::iterator<struct std::random_access_iterator_tag, wchar_t, int, wchar_t *, wchar_t &>> const &)const
.text$mn:00003E78                 public ??$_Equal@V?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@_W@std@@@std@@@std@@U?$iterator@Urandom_access_iterator_tag@std@@_WHPA_WAA_W@2@@?$_Revranit@V?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@_W@std@@@std@@@std@@U?$iterator@Urandom_access_iterator_tag@std@@_WHPA_WAA_W@2@@std@@QBE_NABV01@@Z
.text$mn:00003E78 ??$_Equal@V?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@_W@std@@@std@@@std@@U?$iterator@Urandom_access_iterator_tag@std@@_WHPA_WAA_W@2@@?$_Revranit@V?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@_W@std@@@std@@@std@@U?$iterator@Urandom_access_iterator_tag@std@@_WHPA_WAA_W@2@@std@@QBE_NABV01@@Z proc near
.text$mn:00003E78                                         ; CODE XREF: std::operator==<std::_Vector_iterator<std::_Vector_val<std::_Simple_types<wchar_t>>>,std::_Vector_iterator<std::_Vector_val<std::_Simple_types<wchar_t>>>>(std::reverse_iterator<std::_Vector_iterator<std::_Vector_val<std::_Simple_types<wchar_t>>>> const &,std::reverse_iterator<std::_Vector_iterator<std::_Vector_val<std::_Simple_types<wchar_t>>>> const &)+Ap
.text$mn:00003E78
.text$mn:00003E78 var_28          = byte ptr -28h
.text$mn:00003E78 var_1C          = dword ptr -1Ch
.text$mn:00003E78 var_18          = dword ptr -18h
.text$mn:00003E78 var_14          = dword ptr -14h
.text$mn:00003E78 var_D           = byte ptr -0Dh
.text$mn:00003E78 var_C           = dword ptr -0Ch
.text$mn:00003E78 var_4           = dword ptr -4
.text$mn:00003E78 arg_0           = dword ptr  8
.text$mn:00003E78
.text$mn:00003E78                 push    ebp
.text$mn:00003E79                 mov     ebp, esp
.text$mn:00003E7B                 push    0FFFFFFFFh
.text$mn:00003E7D                 push    offset __ehhandler$??$_Equal@V?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@_W@std@@@std@@@std@@U?$iterator@Urandom_access_iterator_tag@std@@_WHPA_WAA_W@2@@?$_Revranit@V?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@_W@std@@@std@@@std@@U?$iterator@Urandom_access_iterator_tag@std@@_WHPA_WAA_W@2@@std@@QBE_NABV01@@Z
.text$mn:00003E82                 mov     eax, large fs:0
.text$mn:00003E88                 push    eax
.text$mn:00003E89                 sub     esp, 1Ch
.text$mn:00003E8C                 mov     eax, dword ptr ds:___security_cookie
.text$mn:00003E91                 xor     eax, ebp
.text$mn:00003E93                 push    eax
.text$mn:00003E94                 lea     eax, [ebp+var_C]
.text$mn:00003E97                 mov     large fs:0, eax
.text$mn:00003E9D                 mov     [ebp+var_1C], ecx
.text$mn:00003EA0                 lea     eax, [ebp+var_28]
.text$mn:00003EA3                 push    eax
.text$mn:00003EA4                 mov     ecx, [ebp+arg_0]
.text$mn:00003EA7                 call    ?base@?$_Revranit@V?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@_W@std@@@std@@@std@@U?$iterator@Urandom_access_iterator_tag@std@@_WHPA_WAA_W@2@@std@@QBE?AV?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@_W@std@@@std@@@2@XZ ; std::_Revranit<std::_Vector_iterator<std::_Vector_val<std::_Simple_types<wchar_t>>>,std::iterator<std::random_access_iterator_tag,wchar_t,int,wchar_t *,wchar_t &>>::base(void)
.text$mn:00003EAC                 mov     [ebp+var_14], eax
.text$mn:00003EAF                 mov     ecx, [ebp+var_14]
.text$mn:00003EB2                 mov     [ebp+var_18], ecx
.text$mn:00003EB5                 mov     [ebp+var_4], 0
.text$mn:00003EBC                 mov     edx, [ebp+var_18]
.text$mn:00003EBF                 push    edx             ; std::_Iterator_base12 *
.text$mn:00003EC0                 mov     ecx, [ebp+var_1C]
.text$mn:00003EC3                 call    ??8?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@_W@std@@@std@@@std@@QBE_NABV01@@Z ; std::_Vector_const_iterator<std::_Vector_val<std::_Simple_types<wchar_t>>>::operator==(std::_Vector_const_iterator<std::_Vector_val<std::_Simple_types<wchar_t>>> const &)
.text$mn:00003EC8                 mov     [ebp+var_D], al
.text$mn:00003ECB                 mov     [ebp+var_4], 0FFFFFFFFh
.text$mn:00003ED2                 lea     ecx, [ebp+var_28]
.text$mn:00003ED5                 call    ??1?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@_W@std@@@std@@@std@@QAE@XZ ; std::_Vector_iterator<std::_Vector_val<std::_Simple_types<wchar_t>>>::~_Vector_iterator<std::_Vector_val<std::_Simple_types<wchar_t>>>(void)
.text$mn:00003EDA                 mov     al, [ebp+var_D]
.text$mn:00003EDD                 mov     ecx, [ebp+var_C]
.text$mn:00003EE0                 mov     large fs:0, ecx
.text$mn:00003EE7                 pop     ecx
.text$mn:00003EE8                 mov     esp, ebp
.text$mn:00003EEA                 pop     ebp
.text$mn:00003EEB                 retn    4
.text$mn:00003EEB ??$_Equal@V?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@_W@std@@@std@@@std@@U?$iterator@Urandom_access_iterator_tag@std@@_WHPA_WAA_W@2@@?$_Revranit@V?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@_W@std@@@std@@@std@@U?$iterator@Urandom_access_iterator_tag@std@@_WHPA_WAA_W@2@@std@@QBE_NABV01@@Z endp
.text$mn:00003EEB
.text$mn:00003EEB ; ---------------------------------------------------------------------------
.text$mn:00003EEE                 align 10h
.text$mn:00003EEE _text$mn        ends
.text$mn:00003EEE
.text$x:00003EF0 ; ===========================================================================
.text$x:00003EF0
.text$x:00003EF0 ; Segment type: Pure code
.text$x:00003EF0 ; Segment permissions: Read/Execute
.text$x:00003EF0 _text$x         segment para public 'CODE' use32
.text$x:00003EF0                 assume cs:_text$x
.text$x:00003EF0                 ;org 3EF0h
.text$x:00003EF0 ; COMDAT (pick associative to section at 3E78)
.text$x:00003EF0                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text$x:00003EF0
.text$x:00003EF0 ; =============== S U B R O U T I N E =======================================
.text$x:00003EF0
.text$x:00003EF0
.text$x:00003EF0 __unwindfunclet$??$_Equal@V?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@_W@std@@@std@@@std@@U?$iterator@Urandom_access_iterator_tag@std@@_WHPA_WAA_W@2@@?$_Revranit@V?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@_W@std@@@std@@@std@@U?$iterator@Urandom_access_iterator_tag@std@@_WHPA_WAA_W@2@@std@@QBE_NABV01@@Z$0 proc near
.text$x:00003EF0                                         ; DATA XREF: .xdata$x:0000F218o
.text$x:00003EF0                 lea     ecx, [ebp-28h]
.text$x:00003EF3                 jmp     ??1?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@_W@std@@@std@@@std@@QAE@XZ ; std::_Vector_iterator<std::_Vector_val<std::_Simple_types<wchar_t>>>::~_Vector_iterator<std::_Vector_val<std::_Simple_types<wchar_t>>>(void)
.text$x:00003EF3 __unwindfunclet$??$_Equal@V?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@_W@std@@@std@@@std@@U?$iterator@Urandom_access_iterator_tag@std@@_WHPA_WAA_W@2@@?$_Revranit@V?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@_W@std@@@std@@@std@@U?$iterator@Urandom_access_iterator_tag@std@@_WHPA_WAA_W@2@@std@@QBE_NABV01@@Z$0 endp
.text$x:00003EF3
.text$x:00003EF8
.text$x:00003EF8 ; =============== S U B R O U T I N E =======================================
.text$x:00003EF8
.text$x:00003EF8
.text$x:00003EF8 __ehhandler$??$_Equal@V?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@_W@std@@@std@@@std@@U?$iterator@Urandom_access_iterator_tag@std@@_WHPA_WAA_W@2@@?$_Revranit@V?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@_W@std@@@std@@@std@@U?$iterator@Urandom_access_iterator_tag@std@@_WHPA_WAA_W@2@@std@@QBE_NABV01@@Z proc near
.text$x:00003EF8                                         ; DATA XREF: std::_Revranit<std::_Vector_iterator<std::_Vector_val<std::_Simple_types<wchar_t>>>,std::iterator<std::random_access_iterator_tag,wchar_t,int,wchar_t *,wchar_t &>>::_Equal<std::_Vector_iterator<std::_Vector_val<std::_Simple_types<wchar_t>>>,std::iterator<std::random_access_iterator_tag,wchar_t,int,wchar_t *,wchar_t &>>(std::_Revranit<std::_Vector_iterator<std::_Vector_val<std::_Simple_types<wchar_t>>>,std::iterator<std::random_access_iterator_tag,wchar_t,int,wchar_t *,wchar_t &>> const &)+5o
.text$x:00003EF8
.text$x:00003EF8 arg_4           = dword ptr  8
.text$x:00003EF8
.text$x:00003EF8                 mov     edx, [esp+arg_4]
.text$x:00003EFC                 lea     eax, [edx+0Ch]
.text$x:00003EFF                 mov     ecx, [edx-20h]
.text$x:00003F02                 xor     ecx, eax
.text$x:00003F04                 call    @__security_check_cookie@4 ; __security_check_cookie(x)
.text$x:00003F09                 mov     eax, offset __ehfuncinfo$??$_Equal@V?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@_W@std@@@std@@@std@@U?$iterator@Urandom_access_iterator_tag@std@@_WHPA_WAA_W@2@@?$_Revranit@V?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@_W@std@@@std@@@std@@U?$iterator@Urandom_access_iterator_tag@std@@_WHPA_WAA_W@2@@std@@QBE_NABV01@@Z
.text$x:00003F0E                 jmp     ___CxxFrameHandler3
.text$x:00003F0E __ehhandler$??$_Equal@V?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@_W@std@@@std@@@std@@U?$iterator@Urandom_access_iterator_tag@std@@_WHPA_WAA_W@2@@?$_Revranit@V?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@_W@std@@@std@@@std@@U?$iterator@Urandom_access_iterator_tag@std@@_WHPA_WAA_W@2@@std@@QBE_NABV01@@Z endp
.text$x:00003F0E
.text$x:00003F0E ; ---------------------------------------------------------------------------
.text$x:00003F13                 align 4
.text$x:00003F13 _text$x         ends
.text$x:00003F13
.text$mn:00003F14 ; ===========================================================================
.text$mn:00003F14
.text$mn:00003F14 ; Segment type: Pure code
.text$mn:00003F14 ; Segment permissions: Read/Execute
.text$mn:00003F14 _text$mn        segment para public 'CODE' use32
.text$mn:00003F14                 assume cs:_text$mn
.text$mn:00003F14                 ;org 3F14h
.text$mn:00003F14 ; COMDAT (pick any)
.text$mn:00003F14                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text$mn:00003F14
.text$mn:00003F14 ; =============== S U B R O U T I N E =======================================
.text$mn:00003F14
.text$mn:00003F14 ; Attributes: bp-based frame
.text$mn:00003F14
.text$mn:00003F14 ; wchar_t * __cdecl std::_Fill_n<wchar_t *, unsigned int, wchar_t>(wchar_t *, unsigned int, wchar_t const &)
.text$mn:00003F14                 public ??$_Fill_n@PA_WI_W@std@@YAPA_WPA_WIAB_W@Z
.text$mn:00003F14 ??$_Fill_n@PA_WI_W@std@@YAPA_WPA_WIAB_W@Z proc near
.text$mn:00003F14                                         ; CODE XREF: std::_Uninit_def_fill_n<wchar_t,uint,wchar_t>(wchar_t *,uint,std::_Wrap_alloc<std::allocator<wchar_t>> &,wchar_t *,std::_Scalar_ptr_iterator_tag)+16p
.text$mn:00003F14
.text$mn:00003F14 arg_0           = dword ptr  8
.text$mn:00003F14 arg_4           = dword ptr  0Ch
.text$mn:00003F14 arg_8           = dword ptr  10h
.text$mn:00003F14
.text$mn:00003F14                 push    ebp
.text$mn:00003F15                 mov     ebp, esp
.text$mn:00003F17                 jmp     short loc_3F2B
.text$mn:00003F19 ; ---------------------------------------------------------------------------
.text$mn:00003F19
.text$mn:00003F19 loc_3F19:                               ; CODE XREF: std::_Fill_n<wchar_t *,uint,wchar_t>(wchar_t *,uint,wchar_t const &)+29j
.text$mn:00003F19                 mov     eax, [ebp+arg_4]
.text$mn:00003F1C                 sub     eax, 1
.text$mn:00003F1F                 mov     [ebp+arg_4], eax
.text$mn:00003F22                 mov     ecx, [ebp+arg_0]
.text$mn:00003F25                 add     ecx, 2
.text$mn:00003F28                 mov     [ebp+arg_0], ecx
.text$mn:00003F2B
.text$mn:00003F2B loc_3F2B:                               ; CODE XREF: std::_Fill_n<wchar_t *,uint,wchar_t>(wchar_t *,uint,wchar_t const &)+3j
.text$mn:00003F2B                 cmp     [ebp+arg_4], 0
.text$mn:00003F2F                 jbe     short loc_3F3F
.text$mn:00003F31                 mov     edx, [ebp+arg_0]
.text$mn:00003F34                 mov     eax, [ebp+arg_8]
.text$mn:00003F37                 mov     cx, [eax]
.text$mn:00003F3A                 mov     [edx], cx
.text$mn:00003F3D                 jmp     short loc_3F19
.text$mn:00003F3F ; ---------------------------------------------------------------------------
.text$mn:00003F3F
.text$mn:00003F3F loc_3F3F:                               ; CODE XREF: std::_Fill_n<wchar_t *,uint,wchar_t>(wchar_t *,uint,wchar_t const &)+1Bj
.text$mn:00003F3F                 mov     eax, [ebp+arg_0]
.text$mn:00003F42                 pop     ebp
.text$mn:00003F43                 retn
.text$mn:00003F43 ??$_Fill_n@PA_WI_W@std@@YAPA_WPA_WIAB_W@Z endp
.text$mn:00003F43
.text$mn:00003F43 _text$mn        ends
.text$mn:00003F43
.text$mn:00003F44 ; ===========================================================================
.text$mn:00003F44
.text$mn:00003F44 ; Segment type: Pure code
.text$mn:00003F44 ; Segment permissions: Read/Execute
.text$mn:00003F44 _text$mn        segment para public 'CODE' use32
.text$mn:00003F44                 assume cs:_text$mn
.text$mn:00003F44                 ;org 3F44h
.text$mn:00003F44 ; COMDAT (pick any)
.text$mn:00003F44                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text$mn:00003F44
.text$mn:00003F44 ; =============== S U B R O U T I N E =======================================
.text$mn:00003F44
.text$mn:00003F44 ; Attributes: bp-based frame
.text$mn:00003F44
.text$mn:00003F44 ; struct std::integral_constant<bool, 1> __cdecl std::_Is_checked<class std::_String_iterator<class std::_String_val<struct std::_Simple_types<wchar_t>>>>(class std::_String_iterator<class std::_String_val<struct std::_Simple_types<wchar_t>>>)
.text$mn:00003F44                 public ??$_Is_checked@V?$_String_iterator@V?$_String_val@U?$_Simple_types@_W@std@@@std@@@std@@@std@@YA?AU?$integral_constant@_N$00@0@V?$_String_iterator@V?$_String_val@U?$_Simple_types@_W@std@@@std@@@0@@Z
.text$mn:00003F44 ??$_Is_checked@V?$_String_iterator@V?$_String_val@U?$_Simple_types@_W@std@@@std@@@std@@@std@@YA?AU?$integral_constant@_N$00@0@V?$_String_iterator@V?$_String_val@U?$_Simple_types@_W@std@@@std@@@0@@Z proc near
.text$mn:00003F44                                         ; CODE XREF: std::transform<std::_String_iterator<std::_String_val<std::_Simple_types<wchar_t>>>,std::_String_iterator<std::_String_val<std::_Simple_types<wchar_t>>>,int (*)(int)>(std::_String_iterator<std::_String_val<std::_Simple_types<wchar_t>>>,std::_String_iterator<std::_String_val<std::_Simple_types<wchar_t>>>,std::_String_iterator<std::_String_val<std::_Simple_types<wchar_t>>>,int (*)(int))+EAp
.text$mn:00003F44
.text$mn:00003F44 var_E           = byte ptr -0Eh
.text$mn:00003F44 var_D           = byte ptr -0Dh
.text$mn:00003F44 var_C           = dword ptr -0Ch
.text$mn:00003F44 var_4           = dword ptr -4
.text$mn:00003F44 arg_0           = byte ptr  8
.text$mn:00003F44
.text$mn:00003F44                 push    ebp
.text$mn:00003F45                 mov     ebp, esp
.text$mn:00003F47                 push    0FFFFFFFFh
.text$mn:00003F49                 push    offset __ehhandler$??$_Is_checked@V?$_String_iterator@V?$_String_val@U?$_Simple_types@_W@std@@@std@@@std@@@std@@YA?AU?$integral_constant@_N$00@0@V?$_String_iterator@V?$_String_val@U?$_Simple_types@_W@std@@@std@@@0@@Z
.text$mn:00003F4E                 mov     eax, large fs:0
.text$mn:00003F54                 push    eax
.text$mn:00003F55                 push    ecx
.text$mn:00003F56                 mov     eax, dword ptr ds:___security_cookie
.text$mn:00003F5B                 xor     eax, ebp
.text$mn:00003F5D                 push    eax
.text$mn:00003F5E                 lea     eax, [ebp+var_C]
.text$mn:00003F61                 mov     large fs:0, eax
.text$mn:00003F67                 mov     [ebp+var_4], 0
.text$mn:00003F6E                 xor     eax, eax
.text$mn:00003F70                 mov     [ebp+var_D], al
.text$mn:00003F73                 mov     cl, [ebp+var_D]
.text$mn:00003F76                 mov     [ebp+var_E], cl
.text$mn:00003F79                 mov     [ebp+var_4], 0FFFFFFFFh
.text$mn:00003F80                 lea     ecx, [ebp+arg_0]
.text$mn:00003F83                 call    ??1?$_String_iterator@V?$_String_val@U?$_Simple_types@_W@std@@@std@@@std@@QAE@XZ ; std::_String_iterator<std::_String_val<std::_Simple_types<wchar_t>>>::~_String_iterator<std::_String_val<std::_Simple_types<wchar_t>>>(void)
.text$mn:00003F88                 mov     al, [ebp+var_E]
.text$mn:00003F8B                 mov     ecx, [ebp+var_C]
.text$mn:00003F8E                 mov     large fs:0, ecx
.text$mn:00003F95                 pop     ecx
.text$mn:00003F96                 mov     esp, ebp
.text$mn:00003F98                 pop     ebp
.text$mn:00003F99                 retn
.text$mn:00003F99 ??$_Is_checked@V?$_String_iterator@V?$_String_val@U?$_Simple_types@_W@std@@@std@@@std@@@std@@YA?AU?$integral_constant@_N$00@0@V?$_String_iterator@V?$_String_val@U?$_Simple_types@_W@std@@@std@@@0@@Z endp
.text$mn:00003F99
.text$mn:00003F99 ; ---------------------------------------------------------------------------
.text$mn:00003F9A                 align 4
.text$mn:00003F9A _text$mn        ends
.text$mn:00003F9A
.text$x:00003F9C ; ===========================================================================
.text$x:00003F9C
.text$x:00003F9C ; Segment type: Pure code
.text$x:00003F9C ; Segment permissions: Read/Execute
.text$x:00003F9C _text$x         segment para public 'CODE' use32
.text$x:00003F9C                 assume cs:_text$x
.text$x:00003F9C                 ;org 3F9Ch
.text$x:00003F9C ; COMDAT (pick associative to section at 3F44)
.text$x:00003F9C                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text$x:00003F9C
.text$x:00003F9C ; =============== S U B R O U T I N E =======================================
.text$x:00003F9C
.text$x:00003F9C
.text$x:00003F9C __unwindfunclet$??$_Is_checked@V?$_String_iterator@V?$_String_val@U?$_Simple_types@_W@std@@@std@@@std@@@std@@YA?AU?$integral_constant@_N$00@0@V?$_String_iterator@V?$_String_val@U?$_Simple_types@_W@std@@@std@@@0@@Z$0 proc near
.text$x:00003F9C                                         ; DATA XREF: .xdata$x:0000EF0Co
.text$x:00003F9C                 lea     ecx, [ebp+8]
.text$x:00003F9F                 jmp     ??1?$_String_iterator@V?$_String_val@U?$_Simple_types@_W@std@@@std@@@std@@QAE@XZ ; std::_String_iterator<std::_String_val<std::_Simple_types<wchar_t>>>::~_String_iterator<std::_String_val<std::_Simple_types<wchar_t>>>(void)
.text$x:00003F9F __unwindfunclet$??$_Is_checked@V?$_String_iterator@V?$_String_val@U?$_Simple_types@_W@std@@@std@@@std@@@std@@YA?AU?$integral_constant@_N$00@0@V?$_String_iterator@V?$_String_val@U?$_Simple_types@_W@std@@@std@@@0@@Z$0 endp
.text$x:00003F9F
.text$x:00003FA4
.text$x:00003FA4 ; =============== S U B R O U T I N E =======================================
.text$x:00003FA4
.text$x:00003FA4
.text$x:00003FA4 __ehhandler$??$_Is_checked@V?$_String_iterator@V?$_String_val@U?$_Simple_types@_W@std@@@std@@@std@@@std@@YA?AU?$integral_constant@_N$00@0@V?$_String_iterator@V?$_String_val@U?$_Simple_types@_W@std@@@std@@@0@@Z proc near
.text$x:00003FA4                                         ; DATA XREF: std::_Is_checked<std::_String_iterator<std::_String_val<std::_Simple_types<wchar_t>>>>(std::_String_iterator<std::_String_val<std::_Simple_types<wchar_t>>>)+5o
.text$x:00003FA4
.text$x:00003FA4 arg_4           = dword ptr  8
.text$x:00003FA4
.text$x:00003FA4                 mov     edx, [esp+arg_4]
.text$x:00003FA8                 lea     eax, [edx+0Ch]
.text$x:00003FAB                 mov     ecx, [edx-8]
.text$x:00003FAE                 xor     ecx, eax
.text$x:00003FB0                 call    @__security_check_cookie@4 ; __security_check_cookie(x)
.text$x:00003FB5                 mov     eax, offset __ehfuncinfo$??$_Is_checked@V?$_String_iterator@V?$_String_val@U?$_Simple_types@_W@std@@@std@@@std@@@std@@YA?AU?$integral_constant@_N$00@0@V?$_String_iterator@V?$_String_val@U?$_Simple_types@_W@std@@@std@@@0@@Z
.text$x:00003FBA                 jmp     ___CxxFrameHandler3
.text$x:00003FBA __ehhandler$??$_Is_checked@V?$_String_iterator@V?$_String_val@U?$_Simple_types@_W@std@@@std@@@std@@@std@@YA?AU?$integral_constant@_N$00@0@V?$_String_iterator@V?$_String_val@U?$_Simple_types@_W@std@@@std@@@0@@Z endp
.text$x:00003FBA
.text$x:00003FBA ; ---------------------------------------------------------------------------
.text$x:00003FBF                 align 10h
.text$x:00003FBF _text$x         ends
.text$x:00003FBF
.text$mn:00003FC0 ; ===========================================================================
.text$mn:00003FC0
.text$mn:00003FC0 ; Segment type: Pure code
.text$mn:00003FC0 ; Segment permissions: Read/Execute
.text$mn:00003FC0 _text$mn        segment para public 'CODE' use32
.text$mn:00003FC0                 assume cs:_text$mn
.text$mn:00003FC0                 ;org 3FC0h
.text$mn:00003FC0 ; COMDAT (pick any)
.text$mn:00003FC0                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text$mn:00003FC0
.text$mn:00003FC0 ; =============== S U B R O U T I N E =======================================
.text$mn:00003FC0
.text$mn:00003FC0 ; Attributes: bp-based frame
.text$mn:00003FC0
.text$mn:00003FC0 ; struct std::random_access_iterator_tag __cdecl std::_Iter_cat<class std::basic_string<wchar_t, struct std::char_traits<wchar_t>, class std::allocator<wchar_t>> *>(class std::basic_string<wchar_t, struct std::char_traits<wchar_t>, class std::allocator<wchar_t>> * const &)
.text$mn:00003FC0                 public ??$_Iter_cat@PAV?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@@std@@YA?AUrandom_access_iterator_tag@0@ABQAV?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@0@@Z
.text$mn:00003FC0 ??$_Iter_cat@PAV?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@@std@@YA?AUrandom_access_iterator_tag@0@ABQAV?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@0@@Z proc near
.text$mn:00003FC0                                         ; CODE XREF: std::_Debug_range<std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>> *>(std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>> *,std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>> *,wchar_t const *,uint)+Cp
.text$mn:00003FC0
.text$mn:00003FC0 var_1           = byte ptr -1
.text$mn:00003FC0 arg_0           = dword ptr  8
.text$mn:00003FC0
.text$mn:00003FC0                 push    ebp
.text$mn:00003FC1                 mov     ebp, esp
.text$mn:00003FC3                 push    ecx
.text$mn:00003FC4                 mov     eax, [ebp+arg_0]
.text$mn:00003FC7                 mov     cl, [ebp+var_1]
.text$mn:00003FCA                 mov     [eax], cl
.text$mn:00003FCC                 mov     eax, [ebp+arg_0]
.text$mn:00003FCF                 mov     esp, ebp
.text$mn:00003FD1                 pop     ebp
.text$mn:00003FD2                 retn
.text$mn:00003FD2 ??$_Iter_cat@PAV?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@@std@@YA?AUrandom_access_iterator_tag@0@ABQAV?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@0@@Z endp
.text$mn:00003FD2
.text$mn:00003FD2 ; ---------------------------------------------------------------------------
.text$mn:00003FD3                 align 4
.text$mn:00003FD3 _text$mn        ends
.text$mn:00003FD3
.text$mn:00003FD4 ; ===========================================================================
.text$mn:00003FD4
.text$mn:00003FD4 ; Segment type: Pure code
.text$mn:00003FD4 ; Segment permissions: Read/Execute
.text$mn:00003FD4 _text$mn        segment para public 'CODE' use32
.text$mn:00003FD4                 assume cs:_text$mn
.text$mn:00003FD4                 ;org 3FD4h
.text$mn:00003FD4 ; COMDAT (pick any)
.text$mn:00003FD4                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text$mn:00003FD4
.text$mn:00003FD4 ; =============== S U B R O U T I N E =======================================
.text$mn:00003FD4
.text$mn:00003FD4 ; Attributes: bp-based frame
.text$mn:00003FD4
.text$mn:00003FD4 ; struct std::random_access_iterator_tag __cdecl std::_Iter_cat<wchar_t *>(wchar_t * const &)
.text$mn:00003FD4                 public ??$_Iter_cat@PA_W@std@@YA?AUrandom_access_iterator_tag@0@ABQA_W@Z
.text$mn:00003FD4 ??$_Iter_cat@PA_W@std@@YA?AUrandom_access_iterator_tag@0@ABQA_W@Z proc near
.text$mn:00003FD4                                         ; CODE XREF: std::_Debug_range<wchar_t *>(wchar_t *,wchar_t *,wchar_t const *,uint)+Cp
.text$mn:00003FD4                                         ; std::_Transform1<wchar_t *,std::_String_iterator<std::_String_val<std::_Simple_types<wchar_t>>>,int (*)(int)>(wchar_t *,wchar_t *,std::_String_iterator<std::_String_val<std::_Simple_types<wchar_t>>>,int (*)(int),std::integral_constant<bool,1>)+51p
.text$mn:00003FD4
.text$mn:00003FD4 var_1           = byte ptr -1
.text$mn:00003FD4 arg_0           = dword ptr  8
.text$mn:00003FD4
.text$mn:00003FD4                 push    ebp
.text$mn:00003FD5                 mov     ebp, esp
.text$mn:00003FD7                 push    ecx
.text$mn:00003FD8                 mov     eax, [ebp+arg_0]
.text$mn:00003FDB                 mov     cl, [ebp+var_1]
.text$mn:00003FDE                 mov     [eax], cl
.text$mn:00003FE0                 mov     eax, [ebp+arg_0]
.text$mn:00003FE3                 mov     esp, ebp
.text$mn:00003FE5                 pop     ebp
.text$mn:00003FE6                 retn
.text$mn:00003FE6 ??$_Iter_cat@PA_W@std@@YA?AUrandom_access_iterator_tag@0@ABQA_W@Z endp
.text$mn:00003FE6
.text$mn:00003FE6 ; ---------------------------------------------------------------------------
.text$mn:00003FE7                 align 4
.text$mn:00003FE7 _text$mn        ends
.text$mn:00003FE7
.text$mn:00003FE8 ; ===========================================================================
.text$mn:00003FE8
.text$mn:00003FE8 ; Segment type: Pure code
.text$mn:00003FE8 ; Segment permissions: Read/Execute
.text$mn:00003FE8 _text$mn        segment para public 'CODE' use32
.text$mn:00003FE8                 assume cs:_text$mn
.text$mn:00003FE8                 ;org 3FE8h
.text$mn:00003FE8 ; COMDAT (pick any)
.text$mn:00003FE8                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text$mn:00003FE8
.text$mn:00003FE8 ; =============== S U B R O U T I N E =======================================
.text$mn:00003FE8
.text$mn:00003FE8 ; Attributes: bp-based frame
.text$mn:00003FE8
.text$mn:00003FE8 ; struct std::random_access_iterator_tag __cdecl std::_Iter_cat<class std::_String_iterator<class std::_String_val<struct std::_Simple_types<wchar_t>>>>(class std::_String_iterator<class std::_String_val<struct std::_Simple_types<wchar_t>>> const &)
.text$mn:00003FE8                 public ??$_Iter_cat@V?$_String_iterator@V?$_String_val@U?$_Simple_types@_W@std@@@std@@@std@@@std@@YA?AUrandom_access_iterator_tag@0@ABV?$_String_iterator@V?$_String_val@U?$_Simple_types@_W@std@@@std@@@0@@Z
.text$mn:00003FE8 ??$_Iter_cat@V?$_String_iterator@V?$_String_val@U?$_Simple_types@_W@std@@@std@@@std@@@std@@YA?AUrandom_access_iterator_tag@0@ABV?$_String_iterator@V?$_String_val@U?$_Simple_types@_W@std@@@std@@@0@@Z proc near
.text$mn:00003FE8                                         ; CODE XREF: std::_Debug_range<std::_String_iterator<std::_String_val<std::_Simple_types<wchar_t>>>>(std::_String_iterator<std::_String_val<std::_Simple_types<wchar_t>>>,std::_String_iterator<std::_String_val<std::_Simple_types<wchar_t>>>,wchar_t const *,uint)+34p
.text$mn:00003FE8                                         ; std::_Transform1<wchar_t *,std::_String_iterator<std::_String_val<std::_Simple_types<wchar_t>>>,int (*)(int)>(wchar_t *,wchar_t *,std::_String_iterator<std::_String_val<std::_Simple_types<wchar_t>>>,int (*)(int),std::integral_constant<bool,1>)+3Bp
.text$mn:00003FE8
.text$mn:00003FE8 var_1           = byte ptr -1
.text$mn:00003FE8 arg_0           = dword ptr  8
.text$mn:00003FE8
.text$mn:00003FE8                 push    ebp
.text$mn:00003FE9                 mov     ebp, esp
.text$mn:00003FEB                 push    ecx
.text$mn:00003FEC                 mov     eax, [ebp+arg_0]
.text$mn:00003FEF                 mov     cl, [ebp+var_1]
.text$mn:00003FF2                 mov     [eax], cl
.text$mn:00003FF4                 mov     eax, [ebp+arg_0]
.text$mn:00003FF7                 mov     esp, ebp
.text$mn:00003FF9                 pop     ebp
.text$mn:00003FFA                 retn
.text$mn:00003FFA ??$_Iter_cat@V?$_String_iterator@V?$_String_val@U?$_Simple_types@_W@std@@@std@@@std@@@std@@YA?AUrandom_access_iterator_tag@0@ABV?$_String_iterator@V?$_String_val@U?$_Simple_types@_W@std@@@std@@@0@@Z endp
.text$mn:00003FFA
.text$mn:00003FFA ; ---------------------------------------------------------------------------
.text$mn:00003FFB                 align 4
.text$mn:00003FFB _text$mn        ends
.text$mn:00003FFB
.text$mn:00003FFC ; ===========================================================================
.text$mn:00003FFC
.text$mn:00003FFC ; Segment type: Pure code
.text$mn:00003FFC ; Segment permissions: Read/Execute
.text$mn:00003FFC _text$mn        segment para public 'CODE' use32
.text$mn:00003FFC                 assume cs:_text$mn
.text$mn:00003FFC                 ;org 3FFCh
.text$mn:00003FFC ; COMDAT (pick any)
.text$mn:00003FFC                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text$mn:00003FFC
.text$mn:00003FFC ; =============== S U B R O U T I N E =======================================
.text$mn:00003FFC
.text$mn:00003FFC ; Attributes: bp-based frame
.text$mn:00003FFC
.text$mn:00003FFC ; struct std::random_access_iterator_tag __cdecl std::_Iter_cat<class std::reverse_iterator<class std::_Vector_iterator<class std::_Vector_val<struct std::_Simple_types<wchar_t>>>>>(class std::reverse_iterator<class std::_Vector_iterator<class std::_Vector_val<struct std::_Simple_types<wchar_t>>>> const &)
.text$mn:00003FFC                 public ??$_Iter_cat@V?$reverse_iterator@V?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@_W@std@@@std@@@std@@@std@@@std@@YA?AUrandom_access_iterator_tag@0@ABV?$reverse_iterator@V?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@_W@std@@@std@@@std@@@0@@Z
.text$mn:00003FFC ??$_Iter_cat@V?$reverse_iterator@V?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@_W@std@@@std@@@std@@@std@@@std@@YA?AUrandom_access_iterator_tag@0@ABV?$reverse_iterator@V?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@_W@std@@@std@@@std@@@0@@Z proc near
.text$mn:00003FFC                                         ; CODE XREF: std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>>::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>>(std::reverse_iterator<std::_Vector_iterator<std::_Vector_val<std::_Simple_types<wchar_t>>>>,std::reverse_iterator<std::_Vector_iterator<std::_Vector_val<std::_Simple_types<wchar_t>>>>)+58p
.text$mn:00003FFC                                         ; std::_Debug_range<std::reverse_iterator<std::_Vector_iterator<std::_Vector_val<std::_Simple_types<wchar_t>>>>>(std::reverse_iterator<std::_Vector_iterator<std::_Vector_val<std::_Simple_types<wchar_t>>>>,std::reverse_iterator<std::_Vector_iterator<std::_Vector_val<std::_Simple_types<wchar_t>>>>,wchar_t const *,uint)+34p ...
.text$mn:00003FFC
.text$mn:00003FFC var_1           = byte ptr -1
.text$mn:00003FFC arg_0           = dword ptr  8
.text$mn:00003FFC
.text$mn:00003FFC                 push    ebp
.text$mn:00003FFD                 mov     ebp, esp
.text$mn:00003FFF                 push    ecx
.text$mn:00004000                 mov     eax, [ebp+arg_0]
.text$mn:00004003                 mov     cl, [ebp+var_1]
.text$mn:00004006                 mov     [eax], cl
.text$mn:00004008                 mov     eax, [ebp+arg_0]
.text$mn:0000400B                 mov     esp, ebp
.text$mn:0000400D                 pop     ebp
.text$mn:0000400E                 retn
.text$mn:0000400E ??$_Iter_cat@V?$reverse_iterator@V?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@_W@std@@@std@@@std@@@std@@@std@@YA?AUrandom_access_iterator_tag@0@ABV?$reverse_iterator@V?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@_W@std@@@std@@@std@@@0@@Z endp
.text$mn:0000400E
.text$mn:0000400E ; ---------------------------------------------------------------------------
.text$mn:0000400F                 align 10h
.text$mn:0000400F _text$mn        ends
.text$mn:0000400F
.text$mn:00004010 ; ===========================================================================
.text$mn:00004010
.text$mn:00004010 ; Segment type: Pure code
.text$mn:00004010 ; Segment permissions: Read/Execute
.text$mn:00004010 _text$mn        segment para public 'CODE' use32
.text$mn:00004010                 assume cs:_text$mn
.text$mn:00004010                 ;org 4010h
.text$mn:00004010 ; COMDAT (pick any)
.text$mn:00004010                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text$mn:00004010
.text$mn:00004010 ; =============== S U B R O U T I N E =======================================
.text$mn:00004010
.text$mn:00004010 ; Attributes: bp-based frame
.text$mn:00004010
.text$mn:00004010 ; public: bool __thiscall std::_Revranit<class std::_Vector_iterator<class std::_Vector_val<struct std::_Simple_types<wchar_t>>>, struct std::iterator<struct std::random_access_iterator_tag, wchar_t, int, wchar_t *, wchar_t &>>::_Less<class std::_Vector_iterator<class std::_Vector_val<struct std::_Simple_types<wchar_t>>>, struct std::iterator<struct std::random_access_iterator_tag, wchar_t, int, wchar_t *, wchar_t &>>(class std::_Revranit<class std::_Vector_iterator<class std::_Vector_val<struct std::_Simple_types<wchar_t>>>, struct std::iterator<struct std::random_access_iterator_tag, wchar_t, int, wchar_t *, wchar_t &>> const &)const
.text$mn:00004010                 public ??$_Less@V?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@_W@std@@@std@@@std@@U?$iterator@Urandom_access_iterator_tag@std@@_WHPA_WAA_W@2@@?$_Revranit@V?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@_W@std@@@std@@@std@@U?$iterator@Urandom_access_iterator_tag@std@@_WHPA_WAA_W@2@@std@@QBE_NABV01@@Z
.text$mn:00004010 ??$_Less@V?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@_W@std@@@std@@@std@@U?$iterator@Urandom_access_iterator_tag@std@@_WHPA_WAA_W@2@@?$_Revranit@V?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@_W@std@@@std@@@std@@U?$iterator@Urandom_access_iterator_tag@std@@_WHPA_WAA_W@2@@std@@QBE_NABV01@@Z proc near
.text$mn:00004010                                         ; CODE XREF: std::operator<<std::_Vector_iterator<std::_Vector_val<std::_Simple_types<wchar_t>>>,std::_Vector_iterator<std::_Vector_val<std::_Simple_types<wchar_t>>>>(std::reverse_iterator<std::_Vector_iterator<std::_Vector_val<std::_Simple_types<wchar_t>>>> const &,std::reverse_iterator<std::_Vector_iterator<std::_Vector_val<std::_Simple_types<wchar_t>>>> const &)+Ap
.text$mn:00004010
.text$mn:00004010 var_28          = byte ptr -28h
.text$mn:00004010 var_1C          = dword ptr -1Ch
.text$mn:00004010 var_18          = dword ptr -18h
.text$mn:00004010 var_14          = dword ptr -14h
.text$mn:00004010 var_D           = byte ptr -0Dh
.text$mn:00004010 var_C           = dword ptr -0Ch
.text$mn:00004010 var_4           = dword ptr -4
.text$mn:00004010 arg_0           = dword ptr  8
.text$mn:00004010
.text$mn:00004010                 push    ebp
.text$mn:00004011                 mov     ebp, esp
.text$mn:00004013                 push    0FFFFFFFFh
.text$mn:00004015                 push    offset __ehhandler$??$_Less@V?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@_W@std@@@std@@@std@@U?$iterator@Urandom_access_iterator_tag@std@@_WHPA_WAA_W@2@@?$_Revranit@V?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@_W@std@@@std@@@std@@U?$iterator@Urandom_access_iterator_tag@std@@_WHPA_WAA_W@2@@std@@QBE_NABV01@@Z
.text$mn:0000401A                 mov     eax, large fs:0
.text$mn:00004020                 push    eax
.text$mn:00004021                 sub     esp, 1Ch
.text$mn:00004024                 mov     eax, dword ptr ds:___security_cookie
.text$mn:00004029                 xor     eax, ebp
.text$mn:0000402B                 push    eax
.text$mn:0000402C                 lea     eax, [ebp+var_C]
.text$mn:0000402F                 mov     large fs:0, eax
.text$mn:00004035                 mov     [ebp+var_14], ecx
.text$mn:00004038                 mov     eax, [ebp+var_14]
.text$mn:0000403B                 push    eax             ; std::_Iterator_base12 *
.text$mn:0000403C                 lea     ecx, [ebp+var_28]
.text$mn:0000403F                 push    ecx
.text$mn:00004040                 mov     ecx, [ebp+arg_0]
.text$mn:00004043                 call    ?base@?$_Revranit@V?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@_W@std@@@std@@@std@@U?$iterator@Urandom_access_iterator_tag@std@@_WHPA_WAA_W@2@@std@@QBE?AV?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@_W@std@@@std@@@2@XZ ; std::_Revranit<std::_Vector_iterator<std::_Vector_val<std::_Simple_types<wchar_t>>>,std::iterator<std::random_access_iterator_tag,wchar_t,int,wchar_t *,wchar_t &>>::base(void)
.text$mn:00004048                 mov     [ebp+var_18], eax
.text$mn:0000404B                 mov     edx, [ebp+var_18]
.text$mn:0000404E                 mov     [ebp+var_1C], edx
.text$mn:00004051                 mov     [ebp+var_4], 0
.text$mn:00004058                 mov     ecx, [ebp+var_1C]
.text$mn:0000405B                 call    ??M?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@_W@std@@@std@@@std@@QBE_NABV01@@Z ; std::_Vector_const_iterator<std::_Vector_val<std::_Simple_types<wchar_t>>>::operator<(std::_Vector_const_iterator<std::_Vector_val<std::_Simple_types<wchar_t>>> const &)
.text$mn:00004060                 mov     [ebp+var_D], al
.text$mn:00004063                 mov     [ebp+var_4], 0FFFFFFFFh
.text$mn:0000406A                 lea     ecx, [ebp+var_28]
.text$mn:0000406D                 call    ??1?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@_W@std@@@std@@@std@@QAE@XZ ; std::_Vector_iterator<std::_Vector_val<std::_Simple_types<wchar_t>>>::~_Vector_iterator<std::_Vector_val<std::_Simple_types<wchar_t>>>(void)
.text$mn:00004072                 mov     al, [ebp+var_D]
.text$mn:00004075                 mov     ecx, [ebp+var_C]
.text$mn:00004078                 mov     large fs:0, ecx
.text$mn:0000407F                 pop     ecx
.text$mn:00004080                 mov     esp, ebp
.text$mn:00004082                 pop     ebp
.text$mn:00004083                 retn    4
.text$mn:00004083 ??$_Less@V?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@_W@std@@@std@@@std@@U?$iterator@Urandom_access_iterator_tag@std@@_WHPA_WAA_W@2@@?$_Revranit@V?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@_W@std@@@std@@@std@@U?$iterator@Urandom_access_iterator_tag@std@@_WHPA_WAA_W@2@@std@@QBE_NABV01@@Z endp
.text$mn:00004083
.text$mn:00004083 ; ---------------------------------------------------------------------------
.text$mn:00004086                 align 4
.text$mn:00004086 _text$mn        ends
.text$mn:00004086
.text$x:00004088 ; ===========================================================================
.text$x:00004088
.text$x:00004088 ; Segment type: Pure code
.text$x:00004088 ; Segment permissions: Read/Execute
.text$x:00004088 _text$x         segment para public 'CODE' use32
.text$x:00004088                 assume cs:_text$x
.text$x:00004088                 ;org 4088h
.text$x:00004088 ; COMDAT (pick associative to section at 4010)
.text$x:00004088                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text$x:00004088
.text$x:00004088 ; =============== S U B R O U T I N E =======================================
.text$x:00004088
.text$x:00004088
.text$x:00004088 __unwindfunclet$??$_Less@V?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@_W@std@@@std@@@std@@U?$iterator@Urandom_access_iterator_tag@std@@_WHPA_WAA_W@2@@?$_Revranit@V?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@_W@std@@@std@@@std@@U?$iterator@Urandom_access_iterator_tag@std@@_WHPA_WAA_W@2@@std@@QBE_NABV01@@Z$0 proc near
.text$x:00004088                                         ; DATA XREF: .xdata$x:0000F244o
.text$x:00004088                 lea     ecx, [ebp-28h]
.text$x:0000408B                 jmp     ??1?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@_W@std@@@std@@@std@@QAE@XZ ; std::_Vector_iterator<std::_Vector_val<std::_Simple_types<wchar_t>>>::~_Vector_iterator<std::_Vector_val<std::_Simple_types<wchar_t>>>(void)
.text$x:0000408B __unwindfunclet$??$_Less@V?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@_W@std@@@std@@@std@@U?$iterator@Urandom_access_iterator_tag@std@@_WHPA_WAA_W@2@@?$_Revranit@V?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@_W@std@@@std@@@std@@U?$iterator@Urandom_access_iterator_tag@std@@_WHPA_WAA_W@2@@std@@QBE_NABV01@@Z$0 endp
.text$x:0000408B
.text$x:00004090
.text$x:00004090 ; =============== S U B R O U T I N E =======================================
.text$x:00004090
.text$x:00004090
.text$x:00004090 __ehhandler$??$_Less@V?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@_W@std@@@std@@@std@@U?$iterator@Urandom_access_iterator_tag@std@@_WHPA_WAA_W@2@@?$_Revranit@V?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@_W@std@@@std@@@std@@U?$iterator@Urandom_access_iterator_tag@std@@_WHPA_WAA_W@2@@std@@QBE_NABV01@@Z proc near
.text$x:00004090                                         ; DATA XREF: std::_Revranit<std::_Vector_iterator<std::_Vector_val<std::_Simple_types<wchar_t>>>,std::iterator<std::random_access_iterator_tag,wchar_t,int,wchar_t *,wchar_t &>>::_Less<std::_Vector_iterator<std::_Vector_val<std::_Simple_types<wchar_t>>>,std::iterator<std::random_access_iterator_tag,wchar_t,int,wchar_t *,wchar_t &>>(std::_Revranit<std::_Vector_iterator<std::_Vector_val<std::_Simple_types<wchar_t>>>,std::iterator<std::random_access_iterator_tag,wchar_t,int,wchar_t *,wchar_t &>> const &)+5o
.text$x:00004090
.text$x:00004090 arg_4           = dword ptr  8
.text$x:00004090
.text$x:00004090                 mov     edx, [esp+arg_4]
.text$x:00004094                 lea     eax, [edx+0Ch]
.text$x:00004097                 mov     ecx, [edx-20h]
.text$x:0000409A                 xor     ecx, eax
.text$x:0000409C                 call    @__security_check_cookie@4 ; __security_check_cookie(x)
.text$x:000040A1                 mov     eax, offset __ehfuncinfo$??$_Less@V?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@_W@std@@@std@@@std@@U?$iterator@Urandom_access_iterator_tag@std@@_WHPA_WAA_W@2@@?$_Revranit@V?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@_W@std@@@std@@@std@@U?$iterator@Urandom_access_iterator_tag@std@@_WHPA_WAA_W@2@@std@@QBE_NABV01@@Z
.text$x:000040A6                 jmp     ___CxxFrameHandler3
.text$x:000040A6 __ehhandler$??$_Less@V?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@_W@std@@@std@@@std@@U?$iterator@Urandom_access_iterator_tag@std@@_WHPA_WAA_W@2@@?$_Revranit@V?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@_W@std@@@std@@@std@@U?$iterator@Urandom_access_iterator_tag@std@@_WHPA_WAA_W@2@@std@@QBE_NABV01@@Z endp
.text$x:000040A6
.text$x:000040A6 ; ---------------------------------------------------------------------------
.text$x:000040AB                 align 4
.text$x:000040AB _text$x         ends
.text$x:000040AB
.text$mn:000040AC ; ===========================================================================
.text$mn:000040AC
.text$mn:000040AC ; Segment type: Pure code
.text$mn:000040AC ; Segment permissions: Read/Execute
.text$mn:000040AC _text$mn        segment para public 'CODE' use32
.text$mn:000040AC                 assume cs:_text$mn
.text$mn:000040AC                 ;org 40ACh
.text$mn:000040AC ; COMDAT (pick any)
.text$mn:000040AC                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text$mn:000040AC
.text$mn:000040AC ; =============== S U B R O U T I N E =======================================
.text$mn:000040AC
.text$mn:000040AC ; Attributes: bp-based frame
.text$mn:000040AC
.text$mn:000040AC ; struct std::_Scalar_ptr_iterator_tag __cdecl std::_Ptr_cat<char, char>(char *, char *)
.text$mn:000040AC                 public ??$_Ptr_cat@DD@std@@YA?AU_Scalar_ptr_iterator_tag@0@PAD0@Z
.text$mn:000040AC ??$_Ptr_cat@DD@std@@YA?AU_Scalar_ptr_iterator_tag@0@PAD0@Z proc near
.text$mn:000040AC                                         ; CODE XREF: std::_Destroy_range<std::_Wrap_alloc<std::allocator<char>>>(char *,char *,std::_Wrap_alloc<std::allocator<char>> &)+Cp
.text$mn:000040AC                                         ; std::_Uninitialized_default_fill_n<char *,uint,std::_Wrap_alloc<std::allocator<char>>>(char *,uint,std::_Wrap_alloc<std::allocator<char>> &)+Cp
.text$mn:000040AC
.text$mn:000040AC var_1           = byte ptr -1
.text$mn:000040AC
.text$mn:000040AC                 push    ebp
.text$mn:000040AD                 mov     ebp, esp
.text$mn:000040AF                 push    ecx
.text$mn:000040B0                 mov     al, [ebp+var_1]
.text$mn:000040B3                 mov     esp, ebp
.text$mn:000040B5                 pop     ebp
.text$mn:000040B6                 retn
.text$mn:000040B6 ??$_Ptr_cat@DD@std@@YA?AU_Scalar_ptr_iterator_tag@0@PAD0@Z endp
.text$mn:000040B6
.text$mn:000040B6 ; ---------------------------------------------------------------------------
.text$mn:000040B7                 align 4
.text$mn:000040B7 _text$mn        ends
.text$mn:000040B7
.text$mn:000040B8 ; ===========================================================================
.text$mn:000040B8
.text$mn:000040B8 ; Segment type: Pure code
.text$mn:000040B8 ; Segment permissions: Read/Execute
.text$mn:000040B8 _text$mn        segment para public 'CODE' use32
.text$mn:000040B8                 assume cs:_text$mn
.text$mn:000040B8                 ;org 40B8h
.text$mn:000040B8 ; COMDAT (pick any)
.text$mn:000040B8                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text$mn:000040B8
.text$mn:000040B8 ; =============== S U B R O U T I N E =======================================
.text$mn:000040B8
.text$mn:000040B8 ; Attributes: bp-based frame
.text$mn:000040B8
.text$mn:000040B8 ; struct std::_Nonscalar_ptr_iterator_tag __cdecl std::_Ptr_cat<class std::basic_string<wchar_t, struct std::char_traits<wchar_t>, class std::allocator<wchar_t>>, class std::basic_string<wchar_t, struct std::char_traits<wchar_t>, class std::allocator<wchar_t>>>(class std::basic_string<wchar_t, struct std::char_traits<wchar_t>, class std::allocator<wchar_t>> *, class std::basic_string<wchar_t, struct std::char_traits<wchar_t>, class std::allocator<wchar_t>> *)
.text$mn:000040B8                 public ??$_Ptr_cat@V?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@V12@@std@@YA?AU_Nonscalar_ptr_iterator_tag@0@PAV?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@0@0@Z
.text$mn:000040B8 ??$_Ptr_cat@V?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@V12@@std@@YA?AU_Nonscalar_ptr_iterator_tag@0@PAV?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@0@0@Z proc near
.text$mn:000040B8                                         ; CODE XREF: std::_Destroy_range<std::_Wrap_alloc<std::allocator<std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>>>>>(std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>> *,std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>> *,std::_Wrap_alloc<std::allocator<std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>>>> &)+Cp
.text$mn:000040B8                                         ; std::_Uninit_move<std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>> *,std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>> *,std::_Wrap_alloc<std::allocator<std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>>>>>(std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>> *,std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>> *,std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>> *,std::_Wrap_alloc<std::allocator<std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>>>> &)+Cp
.text$mn:000040B8
.text$mn:000040B8 var_1           = byte ptr -1
.text$mn:000040B8
.text$mn:000040B8                 push    ebp
.text$mn:000040B9                 mov     ebp, esp
.text$mn:000040BB                 push    ecx
.text$mn:000040BC                 mov     al, [ebp+var_1]
.text$mn:000040BF                 mov     esp, ebp
.text$mn:000040C1                 pop     ebp
.text$mn:000040C2                 retn
.text$mn:000040C2 ??$_Ptr_cat@V?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@V12@@std@@YA?AU_Nonscalar_ptr_iterator_tag@0@PAV?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@0@0@Z endp
.text$mn:000040C2
.text$mn:000040C2 ; ---------------------------------------------------------------------------
.text$mn:000040C3                 align 4
.text$mn:000040C3 _text$mn        ends
.text$mn:000040C3
.text$mn:000040C4 ; ===========================================================================
.text$mn:000040C4
.text$mn:000040C4 ; Segment type: Pure code
.text$mn:000040C4 ; Segment permissions: Read/Execute
.text$mn:000040C4 _text$mn        segment para public 'CODE' use32
.text$mn:000040C4                 assume cs:_text$mn
.text$mn:000040C4                 ;org 40C4h
.text$mn:000040C4 ; COMDAT (pick any)
.text$mn:000040C4                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text$mn:000040C4
.text$mn:000040C4 ; =============== S U B R O U T I N E =======================================
.text$mn:000040C4
.text$mn:000040C4 ; Attributes: bp-based frame
.text$mn:000040C4
.text$mn:000040C4 ; struct std::_Scalar_ptr_iterator_tag __cdecl std::_Ptr_cat<wchar_t, wchar_t>(wchar_t *, wchar_t *)
.text$mn:000040C4                 public ??$_Ptr_cat@_W_W@std@@YA?AU_Scalar_ptr_iterator_tag@0@PA_W0@Z
.text$mn:000040C4 ??$_Ptr_cat@_W_W@std@@YA?AU_Scalar_ptr_iterator_tag@0@PA_W0@Z proc near
.text$mn:000040C4                                         ; CODE XREF: std::_Destroy_range<std::_Wrap_alloc<std::allocator<wchar_t>>>(wchar_t *,wchar_t *,std::_Wrap_alloc<std::allocator<wchar_t>> &)+Cp
.text$mn:000040C4                                         ; std::_Uninit_move<wchar_t *,wchar_t *,std::_Wrap_alloc<std::allocator<wchar_t>>>(wchar_t *,wchar_t *,wchar_t *,std::_Wrap_alloc<std::allocator<wchar_t>> &)+Cp ...
.text$mn:000040C4
.text$mn:000040C4 var_1           = byte ptr -1
.text$mn:000040C4
.text$mn:000040C4                 push    ebp
.text$mn:000040C5                 mov     ebp, esp
.text$mn:000040C7                 push    ecx
.text$mn:000040C8                 mov     al, [ebp+var_1]
.text$mn:000040CB                 mov     esp, ebp
.text$mn:000040CD                 pop     ebp
.text$mn:000040CE                 retn
.text$mn:000040CE ??$_Ptr_cat@_W_W@std@@YA?AU_Scalar_ptr_iterator_tag@0@PA_W0@Z endp
.text$mn:000040CE
.text$mn:000040CE ; ---------------------------------------------------------------------------
.text$mn:000040CF                 align 10h
.text$mn:000040CF _text$mn        ends
.text$mn:000040CF
.text$mn:000040D0 ; ===========================================================================
.text$mn:000040D0
.text$mn:000040D0 ; Segment type: Pure code
.text$mn:000040D0 ; Segment permissions: Read/Execute
.text$mn:000040D0 _text$mn        segment para public 'CODE' use32
.text$mn:000040D0                 assume cs:_text$mn
.text$mn:000040D0                 ;org 40D0h
.text$mn:000040D0 ; COMDAT (pick any)
.text$mn:000040D0                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text$mn:000040D0
.text$mn:000040D0 ; =============== S U B R O U T I N E =======================================
.text$mn:000040D0
.text$mn:000040D0 ; Attributes: bp-based frame
.text$mn:000040D0
.text$mn:000040D0 ; class std::basic_string<wchar_t, struct std::char_traits<wchar_t>, class std::allocator<wchar_t>> * & __cdecl std::_Rechecked<class std::basic_string<wchar_t, struct std::char_traits<wchar_t>, class std::allocator<wchar_t>> *, class std::basic_string<wchar_t, struct std::char_traits<wchar_t>, class std::allocator<wchar_t>> *>(class std::basic_string<wchar_t, struct std::char_traits<wchar_t>, class std::allocator<wchar_t>> * &, class std::basic_string<wchar_t, struct std::char_traits<wchar_t>, class std::allocator<wchar_t>> *)
.text$mn:000040D0                 public ??$_Rechecked@PAV?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@PAV12@@std@@YAAAPAV?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@0@AAPAV10@PAV10@@Z
.text$mn:000040D0 ??$_Rechecked@PAV?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@PAV12@@std@@YAAAPAV?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@0@AAPAV10@PAV10@@Z proc near
.text$mn:000040D0                                         ; CODE XREF: std::_Uninitialized_move<std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>> *,std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>> *,std::_Wrap_alloc<std::allocator<std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>>>>>(std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>> *,std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>> *,std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>> *,std::_Wrap_alloc<std::allocator<std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>>>> &)+3Bp
.text$mn:000040D0
.text$mn:000040D0 arg_0           = dword ptr  8
.text$mn:000040D0 arg_4           = dword ptr  0Ch
.text$mn:000040D0
.text$mn:000040D0                 push    ebp
.text$mn:000040D1                 mov     ebp, esp
.text$mn:000040D3                 mov     eax, [ebp+arg_0]
.text$mn:000040D6                 mov     ecx, [ebp+arg_4]
.text$mn:000040D9                 mov     [eax], ecx
.text$mn:000040DB                 mov     eax, [ebp+arg_0]
.text$mn:000040DE                 pop     ebp
.text$mn:000040DF                 retn
.text$mn:000040DF ??$_Rechecked@PAV?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@PAV12@@std@@YAAAPAV?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@0@AAPAV10@PAV10@@Z endp
.text$mn:000040DF
.text$mn:000040DF _text$mn        ends
.text$mn:000040DF
.text$mn:000040E0 ; ===========================================================================
.text$mn:000040E0
.text$mn:000040E0 ; Segment type: Pure code
.text$mn:000040E0 ; Segment permissions: Read/Execute
.text$mn:000040E0 _text$mn        segment para public 'CODE' use32
.text$mn:000040E0                 assume cs:_text$mn
.text$mn:000040E0                 ;org 40E0h
.text$mn:000040E0 ; COMDAT (pick any)
.text$mn:000040E0                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text$mn:000040E0
.text$mn:000040E0 ; =============== S U B R O U T I N E =======================================
.text$mn:000040E0
.text$mn:000040E0 ; Attributes: bp-based frame
.text$mn:000040E0
.text$mn:000040E0 ; wchar_t * & __cdecl std::_Rechecked<wchar_t *, wchar_t *>(wchar_t * &, wchar_t *)
.text$mn:000040E0                 public ??$_Rechecked@PA_WPA_W@std@@YAAAPA_WAAPA_WPA_W@Z
.text$mn:000040E0 ??$_Rechecked@PA_WPA_W@std@@YAAAPA_WAAPA_WPA_W@Z proc near
.text$mn:000040E0                                         ; CODE XREF: std::_Uninitialized_move<wchar_t *,wchar_t *,std::_Wrap_alloc<std::allocator<wchar_t>>>(wchar_t *,wchar_t *,wchar_t *,std::_Wrap_alloc<std::allocator<wchar_t>> &)+3Bp
.text$mn:000040E0
.text$mn:000040E0 arg_0           = dword ptr  8
.text$mn:000040E0 arg_4           = dword ptr  0Ch
.text$mn:000040E0
.text$mn:000040E0                 push    ebp
.text$mn:000040E1                 mov     ebp, esp
.text$mn:000040E3                 mov     eax, [ebp+arg_0]
.text$mn:000040E6                 mov     ecx, [ebp+arg_4]
.text$mn:000040E9                 mov     [eax], ecx
.text$mn:000040EB                 mov     eax, [ebp+arg_0]
.text$mn:000040EE                 pop     ebp
.text$mn:000040EF                 retn
.text$mn:000040EF ??$_Rechecked@PA_WPA_W@std@@YAAAPA_WAAPA_WPA_W@Z endp
.text$mn:000040EF
.text$mn:000040EF _text$mn        ends
.text$mn:000040EF
.text$mn:000040F0 ; ===========================================================================
.text$mn:000040F0
.text$mn:000040F0 ; Segment type: Pure code
.text$mn:000040F0 ; Segment permissions: Read/Execute
.text$mn:000040F0 _text$mn        segment para public 'CODE' use32
.text$mn:000040F0                 assume cs:_text$mn
.text$mn:000040F0                 ;org 40F0h
.text$mn:000040F0 ; COMDAT (pick any)
.text$mn:000040F0                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text$mn:000040F0
.text$mn:000040F0 ; =============== S U B R O U T I N E =======================================
.text$mn:000040F0
.text$mn:000040F0 ; Attributes: bp-based frame
.text$mn:000040F0
.text$mn:000040F0 ; class std::_String_iterator<class std::_String_val<struct std::_Simple_types<wchar_t>>> __cdecl std::_Transform1<wchar_t *, class std::_String_iterator<class std::_String_val<struct std::_Simple_types<wchar_t>>>, int (__cdecl *)(int)>(wchar_t *, wchar_t *, class std::_String_iterator<class std::_String_val<struct std::_Simple_types<wchar_t>>>, int (__cdecl *)(int), struct std::integral_constant<bool, 1>)
.text$mn:000040F0                 public ??$_Transform1@PA_WV?$_String_iterator@V?$_String_val@U?$_Simple_types@_W@std@@@std@@@std@@P6AHH@Z@std@@YA?AV?$_String_iterator@V?$_String_val@U?$_Simple_types@_W@std@@@std@@@0@PA_W0V10@P6AHH@ZU?$integral_constant@_N$00@0@@Z
.text$mn:000040F0 ??$_Transform1@PA_WV?$_String_iterator@V?$_String_val@U?$_Simple_types@_W@std@@@std@@@std@@P6AHH@Z@std@@YA?AV?$_String_iterator@V?$_String_val@U?$_Simple_types@_W@std@@@std@@@0@PA_W0V10@P6AHH@ZU?$integral_constant@_N$00@0@@Z proc near
.text$mn:000040F0                                         ; CODE XREF: std::transform<std::_String_iterator<std::_String_val<std::_Simple_types<wchar_t>>>,std::_String_iterator<std::_String_val<std::_Simple_types<wchar_t>>>,int (*)(int)>(std::_String_iterator<std::_String_val<std::_Simple_types<wchar_t>>>,std::_String_iterator<std::_String_val<std::_Simple_types<wchar_t>>>,std::_String_iterator<std::_String_val<std::_Simple_types<wchar_t>>>,int (*)(int))+18Cp
.text$mn:000040F0
.text$mn:000040F0 var_24          = dword ptr -24h
.text$mn:000040F0 var_20          = dword ptr -20h
.text$mn:000040F0 var_1C          = dword ptr -1Ch
.text$mn:000040F0 var_18          = dword ptr -18h
.text$mn:000040F0 var_14          = dword ptr -14h
.text$mn:000040F0 var_E           = byte ptr -0Eh
.text$mn:000040F0 var_D           = byte ptr -0Dh
.text$mn:000040F0 var_C           = dword ptr -0Ch
.text$mn:000040F0 var_4           = dword ptr -4
.text$mn:000040F0 arg_0           = dword ptr  8
.text$mn:000040F0 arg_4           = dword ptr  0Ch
.text$mn:000040F0 arg_8           = dword ptr  10h
.text$mn:000040F0 arg_C           = byte ptr  14h
.text$mn:000040F0 arg_18          = dword ptr  20h
.text$mn:000040F0
.text$mn:000040F0                 push    ebp
.text$mn:000040F1                 mov     ebp, esp
.text$mn:000040F3                 push    0FFFFFFFFh
.text$mn:000040F5                 push    offset __ehhandler$??$_Transform1@PA_WV?$_String_iterator@V?$_String_val@U?$_Simple_types@_W@std@@@std@@@std@@P6AHH@Z@std@@YA?AV?$_String_iterator@V?$_String_val@U?$_Simple_types@_W@std@@@std@@@0@PA_W0V10@P6AHH@ZU?$integral_constant@_N$00@0@@Z
.text$mn:000040FA                 mov     eax, large fs:0
.text$mn:00004100                 push    eax
.text$mn:00004101                 sub     esp, 18h
.text$mn:00004104                 mov     eax, dword ptr ds:___security_cookie
.text$mn:00004109                 xor     eax, ebp
.text$mn:0000410B                 push    eax
.text$mn:0000410C                 lea     eax, [ebp+var_C]
.text$mn:0000410F                 mov     large fs:0, eax
.text$mn:00004115                 mov     [ebp+var_14], 0
.text$mn:0000411C                 mov     [ebp+var_4], 1
.text$mn:00004123                 lea     eax, [ebp+arg_C]
.text$mn:00004126                 push    eax
.text$mn:00004127                 lea     ecx, [ebp+var_D]
.text$mn:0000412A                 push    ecx
.text$mn:0000412B                 call    ??$_Iter_cat@V?$_String_iterator@V?$_String_val@U?$_Simple_types@_W@std@@@std@@@std@@@std@@YA?AUrandom_access_iterator_tag@0@ABV?$_String_iterator@V?$_String_val@U?$_Simple_types@_W@std@@@std@@@0@@Z ; std::_Iter_cat<std::_String_iterator<std::_String_val<std::_Simple_types<wchar_t>>>>(std::_String_iterator<std::_String_val<std::_Simple_types<wchar_t>>> const &)
.text$mn:00004130                 add     esp, 8
.text$mn:00004133                 mov     dl, [eax]
.text$mn:00004135                 movzx   eax, dl
.text$mn:00004138                 push    eax
.text$mn:00004139                 lea     ecx, [ebp+arg_4]
.text$mn:0000413C                 push    ecx
.text$mn:0000413D                 lea     edx, [ebp+var_E]
.text$mn:00004140                 push    edx
.text$mn:00004141                 call    ??$_Iter_cat@PA_W@std@@YA?AUrandom_access_iterator_tag@0@ABQA_W@Z ; std::_Iter_cat<wchar_t *>(wchar_t * const &)
.text$mn:00004146                 add     esp, 8
.text$mn:00004149                 mov     al, [eax]
.text$mn:0000414B                 movzx   ecx, al
.text$mn:0000414E                 push    ecx
.text$mn:0000414F                 mov     edx, [ebp+arg_18]
.text$mn:00004152                 push    edx
.text$mn:00004153                 sub     esp, 0Ch
.text$mn:00004156                 mov     ecx, esp
.text$mn:00004158                 mov     [ebp+var_1C], esp
.text$mn:0000415B                 lea     eax, [ebp+arg_C]
.text$mn:0000415E                 push    eax             ; struct std::_Iterator_base12 *
.text$mn:0000415F                 call    ??0?$_String_iterator@V?$_String_val@U?$_Simple_types@_W@std@@@std@@@std@@QAE@ABV01@@Z ; std::_String_iterator<std::_String_val<std::_Simple_types<wchar_t>>>::_String_iterator<std::_String_val<std::_Simple_types<wchar_t>>>(std::_String_iterator<std::_String_val<std::_Simple_types<wchar_t>>> const &)
.text$mn:00004164                 mov     [ebp+var_18], eax
.text$mn:00004167                 mov     ecx, [ebp+var_18]
.text$mn:0000416A                 mov     [ebp+var_20], ecx
.text$mn:0000416D                 mov     byte ptr [ebp+var_4], 2
.text$mn:00004171                 mov     edx, [ebp+arg_8]
.text$mn:00004174                 push    edx
.text$mn:00004175                 mov     eax, [ebp+arg_4]
.text$mn:00004178                 push    eax
.text$mn:00004179                 mov     ecx, [ebp+arg_0]
.text$mn:0000417C                 push    ecx
.text$mn:0000417D                 mov     byte ptr [ebp+var_4], 1
.text$mn:00004181                 call    ??$_Transform1@PA_WV?$_String_iterator@V?$_String_val@U?$_Simple_types@_W@std@@@std@@@std@@P6AHH@Z@std@@YA?AV?$_String_iterator@V?$_String_val@U?$_Simple_types@_W@std@@@std@@@0@PA_W0V10@P6AHH@ZUrandom_access_iterator_tag@0@3@Z ; std::_Transform1<wchar_t *,std::_String_iterator<std::_String_val<std::_Simple_types<wchar_t>>>,int (*)(int)>(wchar_t *,wchar_t *,std::_String_iterator<std::_String_val<std::_Simple_types<wchar_t>>>,int (*)(int),std::random_access_iterator_tag,std::random_access_iterator_tag)
.text$mn:00004186                 add     esp, 24h
.text$mn:00004189                 mov     [ebp+var_24], eax
.text$mn:0000418C                 mov     edx, [ebp+var_14]
.text$mn:0000418F                 or      edx, 1
.text$mn:00004192                 mov     [ebp+var_14], edx
.text$mn:00004195                 mov     byte ptr [ebp+var_4], 0
.text$mn:00004199                 lea     ecx, [ebp+arg_C]
.text$mn:0000419C                 call    ??1?$_String_iterator@V?$_String_val@U?$_Simple_types@_W@std@@@std@@@std@@QAE@XZ ; std::_String_iterator<std::_String_val<std::_Simple_types<wchar_t>>>::~_String_iterator<std::_String_val<std::_Simple_types<wchar_t>>>(void)
.text$mn:000041A1                 mov     eax, [ebp+arg_0]
.text$mn:000041A4                 mov     ecx, [ebp+var_C]
.text$mn:000041A7                 mov     large fs:0, ecx
.text$mn:000041AE                 pop     ecx
.text$mn:000041AF                 mov     esp, ebp
.text$mn:000041B1                 pop     ebp
.text$mn:000041B2                 retn
.text$mn:000041B2 ??$_Transform1@PA_WV?$_String_iterator@V?$_String_val@U?$_Simple_types@_W@std@@@std@@@std@@P6AHH@Z@std@@YA?AV?$_String_iterator@V?$_String_val@U?$_Simple_types@_W@std@@@std@@@0@PA_W0V10@P6AHH@ZU?$integral_constant@_N$00@0@@Z endp
.text$mn:000041B2
.text$mn:000041B2 ; ---------------------------------------------------------------------------
.text$mn:000041B3                 align 4
.text$mn:000041B3 _text$mn        ends
.text$mn:000041B3
.text$x:000041B4 ; ===========================================================================
.text$x:000041B4
.text$x:000041B4 ; Segment type: Pure code
.text$x:000041B4 ; Segment permissions: Read/Execute
.text$x:000041B4 _text$x         segment para public 'CODE' use32
.text$x:000041B4                 assume cs:_text$x
.text$x:000041B4                 ;org 41B4h
.text$x:000041B4 ; COMDAT (pick associative to section at 40F0)
.text$x:000041B4                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text$x:000041B4
.text$x:000041B4 ; =============== S U B R O U T I N E =======================================
.text$x:000041B4
.text$x:000041B4
.text$x:000041B4 __unwindfunclet$??$_Transform1@PA_WV?$_String_iterator@V?$_String_val@U?$_Simple_types@_W@std@@@std@@@std@@P6AHH@Z@std@@YA?AV?$_String_iterator@V?$_String_val@U?$_Simple_types@_W@std@@@std@@@0@PA_W0V10@P6AHH@ZU?$integral_constant@_N$00@0@@Z$0 proc near
.text$x:000041B4                                         ; DATA XREF: .xdata$x:0000EF40o
.text$x:000041B4                 lea     ecx, [ebp+14h]
.text$x:000041B7                 jmp     ??1?$_String_iterator@V?$_String_val@U?$_Simple_types@_W@std@@@std@@@std@@QAE@XZ ; std::_String_iterator<std::_String_val<std::_Simple_types<wchar_t>>>::~_String_iterator<std::_String_val<std::_Simple_types<wchar_t>>>(void)
.text$x:000041B7 __unwindfunclet$??$_Transform1@PA_WV?$_String_iterator@V?$_String_val@U?$_Simple_types@_W@std@@@std@@@std@@P6AHH@Z@std@@YA?AV?$_String_iterator@V?$_String_val@U?$_Simple_types@_W@std@@@std@@@0@PA_W0V10@P6AHH@ZU?$integral_constant@_N$00@0@@Z$0 endp
.text$x:000041B7
.text$x:000041BC
.text$x:000041BC ; =============== S U B R O U T I N E =======================================
.text$x:000041BC
.text$x:000041BC
.text$x:000041BC __unwindfunclet$??$_Transform1@PA_WV?$_String_iterator@V?$_String_val@U?$_Simple_types@_W@std@@@std@@@std@@P6AHH@Z@std@@YA?AV?$_String_iterator@V?$_String_val@U?$_Simple_types@_W@std@@@std@@@0@PA_W0V10@P6AHH@ZU?$integral_constant@_N$00@0@@Z$1 proc near
.text$x:000041BC                                         ; DATA XREF: .xdata$x:0000EF48o
.text$x:000041BC                 mov     ecx, [ebp-1Ch]
.text$x:000041BF                 jmp     ??1?$_String_iterator@V?$_String_val@U?$_Simple_types@_W@std@@@std@@@std@@QAE@XZ ; std::_String_iterator<std::_String_val<std::_Simple_types<wchar_t>>>::~_String_iterator<std::_String_val<std::_Simple_types<wchar_t>>>(void)
.text$x:000041BF __unwindfunclet$??$_Transform1@PA_WV?$_String_iterator@V?$_String_val@U?$_Simple_types@_W@std@@@std@@@std@@P6AHH@Z@std@@YA?AV?$_String_iterator@V?$_String_val@U?$_Simple_types@_W@std@@@std@@@0@PA_W0V10@P6AHH@ZU?$integral_constant@_N$00@0@@Z$1 endp
.text$x:000041BF
.text$x:000041C4
.text$x:000041C4 ; =============== S U B R O U T I N E =======================================
.text$x:000041C4
.text$x:000041C4
.text$x:000041C4 __unwindfunclet$??$_Transform1@PA_WV?$_String_iterator@V?$_String_val@U?$_Simple_types@_W@std@@@std@@@std@@P6AHH@Z@std@@YA?AV?$_String_iterator@V?$_String_val@U?$_Simple_types@_W@std@@@std@@@0@PA_W0V10@P6AHH@ZU?$integral_constant@_N$00@0@@Z$2 proc near
.text$x:000041C4                                         ; DATA XREF: .xdata$x:0000EF38o
.text$x:000041C4                 mov     eax, [ebp-14h]
.text$x:000041C7                 and     eax, 1
.text$x:000041CA                 jz      $LN6_4
.text$x:000041D0                 and     dword ptr [ebp-14h], 0FFFFFFFEh
.text$x:000041D4                 mov     ecx, [ebp+8]
.text$x:000041D7                 jmp     ??1?$_String_iterator@V?$_String_val@U?$_Simple_types@_W@std@@@std@@@std@@QAE@XZ ; std::_String_iterator<std::_String_val<std::_Simple_types<wchar_t>>>::~_String_iterator<std::_String_val<std::_Simple_types<wchar_t>>>(void)
.text$x:000041DC ; ---------------------------------------------------------------------------
.text$x:000041DC
.text$x:000041DC $LN6_4:                                 ; CODE XREF: __unwindfunclet$??$_Transform1@PA_WV?$_String_iterator@V?$_String_val@U?$_Simple_types@_W@std@@@std@@@std@@P6AHH@Z@std@@YA?AV?$_String_iterator@V?$_String_val@U?$_Simple_types@_W@std@@@std@@@0@PA_W0V10@P6AHH@ZU?$integral_constant@_N$00@0@@Z$2+6j
.text$x:000041DC                 retn
.text$x:000041DC __unwindfunclet$??$_Transform1@PA_WV?$_String_iterator@V?$_String_val@U?$_Simple_types@_W@std@@@std@@@std@@P6AHH@Z@std@@YA?AV?$_String_iterator@V?$_String_val@U?$_Simple_types@_W@std@@@std@@@0@PA_W0V10@P6AHH@ZU?$integral_constant@_N$00@0@@Z$2 endp
.text$x:000041DC
.text$x:000041DD
.text$x:000041DD ; =============== S U B R O U T I N E =======================================
.text$x:000041DD
.text$x:000041DD
.text$x:000041DD __ehhandler$??$_Transform1@PA_WV?$_String_iterator@V?$_String_val@U?$_Simple_types@_W@std@@@std@@@std@@P6AHH@Z@std@@YA?AV?$_String_iterator@V?$_String_val@U?$_Simple_types@_W@std@@@std@@@0@PA_W0V10@P6AHH@ZU?$integral_constant@_N$00@0@@Z proc near
.text$x:000041DD                                         ; DATA XREF: std::_Transform1<wchar_t *,std::_String_iterator<std::_String_val<std::_Simple_types<wchar_t>>>,int (*)(int)>(wchar_t *,wchar_t *,std::_String_iterator<std::_String_val<std::_Simple_types<wchar_t>>>,int (*)(int),std::integral_constant<bool,1>)+5o
.text$x:000041DD
.text$x:000041DD arg_4           = dword ptr  8
.text$x:000041DD
.text$x:000041DD                 mov     edx, [esp+arg_4]
.text$x:000041E1                 lea     eax, [edx+0Ch]
.text$x:000041E4                 mov     ecx, [edx-1Ch]
.text$x:000041E7                 xor     ecx, eax
.text$x:000041E9                 call    @__security_check_cookie@4 ; __security_check_cookie(x)
.text$x:000041EE                 mov     eax, offset __ehfuncinfo$??$_Transform1@PA_WV?$_String_iterator@V?$_String_val@U?$_Simple_types@_W@std@@@std@@@std@@P6AHH@Z@std@@YA?AV?$_String_iterator@V?$_String_val@U?$_Simple_types@_W@std@@@std@@@0@PA_W0V10@P6AHH@ZU?$integral_constant@_N$00@0@@Z
.text$x:000041F3                 jmp     ___CxxFrameHandler3
.text$x:000041F3 __ehhandler$??$_Transform1@PA_WV?$_String_iterator@V?$_String_val@U?$_Simple_types@_W@std@@@std@@@std@@P6AHH@Z@std@@YA?AV?$_String_iterator@V?$_String_val@U?$_Simple_types@_W@std@@@std@@@0@PA_W0V10@P6AHH@ZU?$integral_constant@_N$00@0@@Z endp
.text$x:000041F3
.text$x:000041F3 _text$x         ends
.text$x:000041F3
.text$mn:000041F8 ; ===========================================================================
.text$mn:000041F8
.text$mn:000041F8 ; Segment type: Pure code
.text$mn:000041F8 ; Segment permissions: Read/Execute
.text$mn:000041F8 _text$mn        segment para public 'CODE' use32
.text$mn:000041F8                 assume cs:_text$mn
.text$mn:000041F8                 ;org 41F8h
.text$mn:000041F8 ; COMDAT (pick any)
.text$mn:000041F8                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text$mn:000041F8
.text$mn:000041F8 ; =============== S U B R O U T I N E =======================================
.text$mn:000041F8
.text$mn:000041F8 ; Attributes: bp-based frame
.text$mn:000041F8
.text$mn:000041F8 ; class std::_String_iterator<class std::_String_val<struct std::_Simple_types<wchar_t>>> __cdecl std::_Transform1<wchar_t *, class std::_String_iterator<class std::_String_val<struct std::_Simple_types<wchar_t>>>, int (__cdecl *)(int)>(wchar_t *, wchar_t *, class std::_String_iterator<class std::_String_val<struct std::_Simple_types<wchar_t>>>, int (__cdecl *)(int), struct std::random_access_iterator_tag, struct std::random_access_iterator_tag)
.text$mn:000041F8                 public ??$_Transform1@PA_WV?$_String_iterator@V?$_String_val@U?$_Simple_types@_W@std@@@std@@@std@@P6AHH@Z@std@@YA?AV?$_String_iterator@V?$_String_val@U?$_Simple_types@_W@std@@@std@@@0@PA_W0V10@P6AHH@ZUrandom_access_iterator_tag@0@3@Z
.text$mn:000041F8 ??$_Transform1@PA_WV?$_String_iterator@V?$_String_val@U?$_Simple_types@_W@std@@@std@@@std@@P6AHH@Z@std@@YA?AV?$_String_iterator@V?$_String_val@U?$_Simple_types@_W@std@@@std@@@0@PA_W0V10@P6AHH@ZUrandom_access_iterator_tag@0@3@Z proc near
.text$mn:000041F8                                         ; CODE XREF: std::_Transform1<wchar_t *,std::_String_iterator<std::_String_val<std::_Simple_types<wchar_t>>>,int (*)(int)>(wchar_t *,wchar_t *,std::_String_iterator<std::_String_val<std::_Simple_types<wchar_t>>>,int (*)(int),std::integral_constant<bool,1>)+91p
.text$mn:000041F8
.text$mn:000041F8 var_2C          = byte ptr -2Ch
.text$mn:000041F8 var_20          = dword ptr -20h
.text$mn:000041F8 var_1C          = dword ptr -1Ch
.text$mn:000041F8 var_18          = dword ptr -18h
.text$mn:000041F8 var_14          = dword ptr -14h
.text$mn:000041F8 var_10          = dword ptr -10h
.text$mn:000041F8 var_C           = dword ptr -0Ch
.text$mn:000041F8 var_4           = dword ptr -4
.text$mn:000041F8 arg_0           = dword ptr  8
.text$mn:000041F8 arg_4           = dword ptr  0Ch
.text$mn:000041F8 arg_8           = dword ptr  10h
.text$mn:000041F8 arg_C           = byte ptr  14h
.text$mn:000041F8 arg_18          = dword ptr  20h
.text$mn:000041F8
.text$mn:000041F8                 push    ebp
.text$mn:000041F9                 mov     ebp, esp
.text$mn:000041FB                 push    0FFFFFFFFh
.text$mn:000041FD                 push    offset __ehhandler$??$_Transform1@PA_WV?$_String_iterator@V?$_String_val@U?$_Simple_types@_W@std@@@std@@@std@@P6AHH@Z@std@@YA?AV?$_String_iterator@V?$_String_val@U?$_Simple_types@_W@std@@@std@@@0@PA_W0V10@P6AHH@ZUrandom_access_iterator_tag@0@3@Z
.text$mn:00004202                 mov     eax, large fs:0
.text$mn:00004208                 push    eax
.text$mn:00004209                 sub     esp, 20h
.text$mn:0000420C                 mov     eax, dword ptr ds:___security_cookie
.text$mn:00004211                 xor     eax, ebp
.text$mn:00004213                 push    eax
.text$mn:00004214                 lea     eax, [ebp+var_C]
.text$mn:00004217                 mov     large fs:0, eax
.text$mn:0000421D                 mov     [ebp+var_10], 0
.text$mn:00004224                 mov     [ebp+var_4], 1
.text$mn:0000422B                 mov     eax, [ebp+arg_8]
.text$mn:0000422E                 sub     eax, [ebp+arg_4]
.text$mn:00004231                 sar     eax, 1
.text$mn:00004233                 push    eax
.text$mn:00004234                 lea     ecx, [ebp+var_2C]
.text$mn:00004237                 push    ecx
.text$mn:00004238                 lea     ecx, [ebp+arg_C]
.text$mn:0000423B                 call    ??H?$_String_iterator@V?$_String_val@U?$_Simple_types@_W@std@@@std@@@std@@QBE?AV01@H@Z ; std::_String_iterator<std::_String_val<std::_Simple_types<wchar_t>>>::operator+(int)
.text$mn:00004240                 mov     byte ptr [ebp+var_4], 2
.text$mn:00004244                 mov     edx, [ebp+arg_18]
.text$mn:00004247                 push    edx
.text$mn:00004248                 sub     esp, 0Ch
.text$mn:0000424B                 mov     ecx, esp
.text$mn:0000424D                 mov     [ebp+var_1C], esp
.text$mn:00004250                 lea     eax, [ebp+arg_C]
.text$mn:00004253                 push    eax             ; struct std::_Iterator_base12 *
.text$mn:00004254                 call    ??0?$_String_iterator@V?$_String_val@U?$_Simple_types@_W@std@@@std@@@std@@QAE@ABV01@@Z ; std::_String_iterator<std::_String_val<std::_Simple_types<wchar_t>>>::_String_iterator<std::_String_val<std::_Simple_types<wchar_t>>>(std::_String_iterator<std::_String_val<std::_Simple_types<wchar_t>>> const &)
.text$mn:00004259                 mov     [ebp+var_14], eax
.text$mn:0000425C                 mov     ecx, [ebp+var_14]
.text$mn:0000425F                 mov     [ebp+var_20], ecx
.text$mn:00004262                 mov     byte ptr [ebp+var_4], 3
.text$mn:00004266                 mov     byte ptr [ebp+var_4], 2
.text$mn:0000426A                 call    ??$_Unchecked@V?$_String_val@U?$_Simple_types@_W@std@@@std@@@std@@YAPA_WV?$_String_iterator@V?$_String_val@U?$_Simple_types@_W@std@@@std@@@0@@Z ; std::_Unchecked<std::_String_val<std::_Simple_types<wchar_t>>>(std::_String_iterator<std::_String_val<std::_Simple_types<wchar_t>>>)
.text$mn:0000426F                 add     esp, 0Ch
.text$mn:00004272                 mov     [ebp+var_18], eax
.text$mn:00004275                 mov     edx, [ebp+var_18]
.text$mn:00004278                 push    edx
.text$mn:00004279                 mov     eax, [ebp+arg_8]
.text$mn:0000427C                 push    eax
.text$mn:0000427D                 mov     ecx, [ebp+arg_4]
.text$mn:00004280                 push    ecx
.text$mn:00004281                 call    ??$_Transform@PA_WPA_WP6AHH@Z@std@@YAPA_WPA_W00P6AHH@Z@Z ; std::_Transform<wchar_t *,wchar_t *,int (*)(int)>(wchar_t *,wchar_t *,wchar_t *,int (*)(int))
.text$mn:00004286                 add     esp, 10h
.text$mn:00004289                 lea     edx, [ebp+var_2C]
.text$mn:0000428C                 push    edx             ; struct std::_Iterator_base12 *
.text$mn:0000428D                 mov     ecx, [ebp+arg_0]
.text$mn:00004290                 call    ??0?$_String_iterator@V?$_String_val@U?$_Simple_types@_W@std@@@std@@@std@@QAE@ABV01@@Z ; std::_String_iterator<std::_String_val<std::_Simple_types<wchar_t>>>::_String_iterator<std::_String_val<std::_Simple_types<wchar_t>>>(std::_String_iterator<std::_String_val<std::_Simple_types<wchar_t>>> const &)
.text$mn:00004295                 mov     eax, [ebp+var_10]
.text$mn:00004298                 or      eax, 1
.text$mn:0000429B                 mov     [ebp+var_10], eax
.text$mn:0000429E                 mov     byte ptr [ebp+var_4], 1
.text$mn:000042A2                 lea     ecx, [ebp+var_2C]
.text$mn:000042A5                 call    ??1?$_String_iterator@V?$_String_val@U?$_Simple_types@_W@std@@@std@@@std@@QAE@XZ ; std::_String_iterator<std::_String_val<std::_Simple_types<wchar_t>>>::~_String_iterator<std::_String_val<std::_Simple_types<wchar_t>>>(void)
.text$mn:000042AA                 mov     byte ptr [ebp+var_4], 0
.text$mn:000042AE                 lea     ecx, [ebp+arg_C]
.text$mn:000042B1                 call    ??1?$_String_iterator@V?$_String_val@U?$_Simple_types@_W@std@@@std@@@std@@QAE@XZ ; std::_String_iterator<std::_String_val<std::_Simple_types<wchar_t>>>::~_String_iterator<std::_String_val<std::_Simple_types<wchar_t>>>(void)
.text$mn:000042B6                 mov     eax, [ebp+arg_0]
.text$mn:000042B9                 mov     ecx, [ebp+var_C]
.text$mn:000042BC                 mov     large fs:0, ecx
.text$mn:000042C3                 pop     ecx
.text$mn:000042C4                 mov     esp, ebp
.text$mn:000042C6                 pop     ebp
.text$mn:000042C7                 retn
.text$mn:000042C7 ??$_Transform1@PA_WV?$_String_iterator@V?$_String_val@U?$_Simple_types@_W@std@@@std@@@std@@P6AHH@Z@std@@YA?AV?$_String_iterator@V?$_String_val@U?$_Simple_types@_W@std@@@std@@@0@PA_W0V10@P6AHH@ZUrandom_access_iterator_tag@0@3@Z endp
.text$mn:000042C7
.text$mn:000042C7 _text$mn        ends
.text$mn:000042C7
.text$x:000042C8 ; ===========================================================================
.text$x:000042C8
.text$x:000042C8 ; Segment type: Pure code
.text$x:000042C8 ; Segment permissions: Read/Execute
.text$x:000042C8 _text$x         segment para public 'CODE' use32
.text$x:000042C8                 assume cs:_text$x
.text$x:000042C8                 ;org 42C8h
.text$x:000042C8 ; COMDAT (pick associative to section at 41F8)
.text$x:000042C8                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text$x:000042C8
.text$x:000042C8 ; =============== S U B R O U T I N E =======================================
.text$x:000042C8
.text$x:000042C8
.text$x:000042C8 __unwindfunclet$??$_Transform1@PA_WV?$_String_iterator@V?$_String_val@U?$_Simple_types@_W@std@@@std@@@std@@P6AHH@Z@std@@YA?AV?$_String_iterator@V?$_String_val@U?$_Simple_types@_W@std@@@std@@@0@PA_W0V10@P6AHH@ZUrandom_access_iterator_tag@0@3@Z$0 proc near
.text$x:000042C8                                         ; DATA XREF: .xdata$x:0000F038o
.text$x:000042C8                 lea     ecx, [ebp+14h]
.text$x:000042CB                 jmp     ??1?$_String_iterator@V?$_String_val@U?$_Simple_types@_W@std@@@std@@@std@@QAE@XZ ; std::_String_iterator<std::_String_val<std::_Simple_types<wchar_t>>>::~_String_iterator<std::_String_val<std::_Simple_types<wchar_t>>>(void)
.text$x:000042CB __unwindfunclet$??$_Transform1@PA_WV?$_String_iterator@V?$_String_val@U?$_Simple_types@_W@std@@@std@@@std@@P6AHH@Z@std@@YA?AV?$_String_iterator@V?$_String_val@U?$_Simple_types@_W@std@@@std@@@0@PA_W0V10@P6AHH@ZUrandom_access_iterator_tag@0@3@Z$0 endp
.text$x:000042CB
.text$x:000042D0
.text$x:000042D0 ; =============== S U B R O U T I N E =======================================
.text$x:000042D0
.text$x:000042D0
.text$x:000042D0 __unwindfunclet$??$_Transform1@PA_WV?$_String_iterator@V?$_String_val@U?$_Simple_types@_W@std@@@std@@@std@@P6AHH@Z@std@@YA?AV?$_String_iterator@V?$_String_val@U?$_Simple_types@_W@std@@@std@@@0@PA_W0V10@P6AHH@ZUrandom_access_iterator_tag@0@3@Z$1 proc near
.text$x:000042D0                                         ; DATA XREF: .xdata$x:0000F040o
.text$x:000042D0                 lea     ecx, [ebp-2Ch]
.text$x:000042D3                 jmp     ??1?$_String_iterator@V?$_String_val@U?$_Simple_types@_W@std@@@std@@@std@@QAE@XZ ; std::_String_iterator<std::_String_val<std::_Simple_types<wchar_t>>>::~_String_iterator<std::_String_val<std::_Simple_types<wchar_t>>>(void)
.text$x:000042D3 __unwindfunclet$??$_Transform1@PA_WV?$_String_iterator@V?$_String_val@U?$_Simple_types@_W@std@@@std@@@std@@P6AHH@Z@std@@YA?AV?$_String_iterator@V?$_String_val@U?$_Simple_types@_W@std@@@std@@@0@PA_W0V10@P6AHH@ZUrandom_access_iterator_tag@0@3@Z$1 endp
.text$x:000042D3
.text$x:000042D8
.text$x:000042D8 ; =============== S U B R O U T I N E =======================================
.text$x:000042D8
.text$x:000042D8
.text$x:000042D8 __unwindfunclet$??$_Transform1@PA_WV?$_String_iterator@V?$_String_val@U?$_Simple_types@_W@std@@@std@@@std@@P6AHH@Z@std@@YA?AV?$_String_iterator@V?$_String_val@U?$_Simple_types@_W@std@@@std@@@0@PA_W0V10@P6AHH@ZUrandom_access_iterator_tag@0@3@Z$2 proc near
.text$x:000042D8                                         ; DATA XREF: .xdata$x:0000F048o
.text$x:000042D8                 mov     ecx, [ebp-1Ch]
.text$x:000042DB                 jmp     ??1?$_String_iterator@V?$_String_val@U?$_Simple_types@_W@std@@@std@@@std@@QAE@XZ ; std::_String_iterator<std::_String_val<std::_Simple_types<wchar_t>>>::~_String_iterator<std::_String_val<std::_Simple_types<wchar_t>>>(void)
.text$x:000042DB __unwindfunclet$??$_Transform1@PA_WV?$_String_iterator@V?$_String_val@U?$_Simple_types@_W@std@@@std@@@std@@P6AHH@Z@std@@YA?AV?$_String_iterator@V?$_String_val@U?$_Simple_types@_W@std@@@std@@@0@PA_W0V10@P6AHH@ZUrandom_access_iterator_tag@0@3@Z$2 endp
.text$x:000042DB
.text$x:000042E0
.text$x:000042E0 ; =============== S U B R O U T I N E =======================================
.text$x:000042E0
.text$x:000042E0
.text$x:000042E0 __unwindfunclet$??$_Transform1@PA_WV?$_String_iterator@V?$_String_val@U?$_Simple_types@_W@std@@@std@@@std@@P6AHH@Z@std@@YA?AV?$_String_iterator@V?$_String_val@U?$_Simple_types@_W@std@@@std@@@0@PA_W0V10@P6AHH@ZUrandom_access_iterator_tag@0@3@Z$3 proc near
.text$x:000042E0                                         ; DATA XREF: .xdata$x:0000F030o
.text$x:000042E0                 mov     eax, [ebp-10h]
.text$x:000042E3                 and     eax, 1
.text$x:000042E6                 jz      $LN7
.text$x:000042EC                 and     dword ptr [ebp-10h], 0FFFFFFFEh
.text$x:000042F0                 mov     ecx, [ebp+8]
.text$x:000042F3                 jmp     ??1?$_String_iterator@V?$_String_val@U?$_Simple_types@_W@std@@@std@@@std@@QAE@XZ ; std::_String_iterator<std::_String_val<std::_Simple_types<wchar_t>>>::~_String_iterator<std::_String_val<std::_Simple_types<wchar_t>>>(void)
.text$x:000042F8 ; ---------------------------------------------------------------------------
.text$x:000042F8
.text$x:000042F8 $LN7:                                   ; CODE XREF: __unwindfunclet$??$_Transform1@PA_WV?$_String_iterator@V?$_String_val@U?$_Simple_types@_W@std@@@std@@@std@@P6AHH@Z@std@@YA?AV?$_String_iterator@V?$_String_val@U?$_Simple_types@_W@std@@@std@@@0@PA_W0V10@P6AHH@ZUrandom_access_iterator_tag@0@3@Z$3+6j
.text$x:000042F8                 retn
.text$x:000042F8 __unwindfunclet$??$_Transform1@PA_WV?$_String_iterator@V?$_String_val@U?$_Simple_types@_W@std@@@std@@@std@@P6AHH@Z@std@@YA?AV?$_String_iterator@V?$_String_val@U?$_Simple_types@_W@std@@@std@@@0@PA_W0V10@P6AHH@ZUrandom_access_iterator_tag@0@3@Z$3 endp
.text$x:000042F8
.text$x:000042F9
.text$x:000042F9 ; =============== S U B R O U T I N E =======================================
.text$x:000042F9
.text$x:000042F9
.text$x:000042F9 __ehhandler$??$_Transform1@PA_WV?$_String_iterator@V?$_String_val@U?$_Simple_types@_W@std@@@std@@@std@@P6AHH@Z@std@@YA?AV?$_String_iterator@V?$_String_val@U?$_Simple_types@_W@std@@@std@@@0@PA_W0V10@P6AHH@ZUrandom_access_iterator_tag@0@3@Z proc near
.text$x:000042F9                                         ; DATA XREF: std::_Transform1<wchar_t *,std::_String_iterator<std::_String_val<std::_Simple_types<wchar_t>>>,int (*)(int)>(wchar_t *,wchar_t *,std::_String_iterator<std::_String_val<std::_Simple_types<wchar_t>>>,int (*)(int),std::random_access_iterator_tag,std::random_access_iterator_tag)+5o
.text$x:000042F9
.text$x:000042F9 arg_4           = dword ptr  8
.text$x:000042F9
.text$x:000042F9                 mov     edx, [esp+arg_4]
.text$x:000042FD                 lea     eax, [edx+0Ch]
.text$x:00004300                 mov     ecx, [edx-24h]
.text$x:00004303                 xor     ecx, eax
.text$x:00004305                 call    @__security_check_cookie@4 ; __security_check_cookie(x)
.text$x:0000430A                 mov     eax, offset __ehfuncinfo$??$_Transform1@PA_WV?$_String_iterator@V?$_String_val@U?$_Simple_types@_W@std@@@std@@@std@@P6AHH@Z@std@@YA?AV?$_String_iterator@V?$_String_val@U?$_Simple_types@_W@std@@@std@@@0@PA_W0V10@P6AHH@ZUrandom_access_iterator_tag@0@3@Z
.text$x:0000430F                 jmp     ___CxxFrameHandler3
.text$x:0000430F __ehhandler$??$_Transform1@PA_WV?$_String_iterator@V?$_String_val@U?$_Simple_types@_W@std@@@std@@@std@@P6AHH@Z@std@@YA?AV?$_String_iterator@V?$_String_val@U?$_Simple_types@_W@std@@@std@@@0@PA_W0V10@P6AHH@ZUrandom_access_iterator_tag@0@3@Z endp
.text$x:0000430F
.text$x:0000430F _text$x         ends
.text$x:0000430F
.text$mn:00004314 ; ===========================================================================
.text$mn:00004314
.text$mn:00004314 ; Segment type: Pure code
.text$mn:00004314 ; Segment permissions: Read/Execute
.text$mn:00004314 _text$mn        segment para public 'CODE' use32
.text$mn:00004314                 assume cs:_text$mn
.text$mn:00004314                 ;org 4314h
.text$mn:00004314 ; COMDAT (pick any)
.text$mn:00004314                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text$mn:00004314
.text$mn:00004314 ; =============== S U B R O U T I N E =======================================
.text$mn:00004314
.text$mn:00004314 ; Attributes: bp-based frame
.text$mn:00004314
.text$mn:00004314 ; wchar_t * __cdecl std::_Transform<wchar_t *, wchar_t *, int (__cdecl *)(int)>(wchar_t *, wchar_t *, wchar_t *, int (__cdecl *)(int))
.text$mn:00004314                 public ??$_Transform@PA_WPA_WP6AHH@Z@std@@YAPA_WPA_W00P6AHH@Z@Z
.text$mn:00004314 ??$_Transform@PA_WPA_WP6AHH@Z@std@@YAPA_WPA_W00P6AHH@Z@Z proc near
.text$mn:00004314                                         ; CODE XREF: std::_Transform1<wchar_t *,std::_String_iterator<std::_String_val<std::_Simple_types<wchar_t>>>,int (*)(int)>(wchar_t *,wchar_t *,std::_String_iterator<std::_String_val<std::_Simple_types<wchar_t>>>,int (*)(int),std::random_access_iterator_tag,std::random_access_iterator_tag)+89p
.text$mn:00004314
.text$mn:00004314 arg_0           = dword ptr  8
.text$mn:00004314 arg_4           = dword ptr  0Ch
.text$mn:00004314 arg_8           = dword ptr  10h
.text$mn:00004314 arg_C           = dword ptr  14h
.text$mn:00004314
.text$mn:00004314                 push    ebp
.text$mn:00004315                 mov     ebp, esp
.text$mn:00004317                 jmp     short loc_432B
.text$mn:00004319 ; ---------------------------------------------------------------------------
.text$mn:00004319
.text$mn:00004319 loc_4319:                               ; CODE XREF: std::_Transform<wchar_t *,wchar_t *,int (*)(int)>(wchar_t *,wchar_t *,wchar_t *,int (*)(int))+32j
.text$mn:00004319                 mov     eax, [ebp+arg_0]
.text$mn:0000431C                 add     eax, 2
.text$mn:0000431F                 mov     [ebp+arg_0], eax
.text$mn:00004322                 mov     ecx, [ebp+arg_8]
.text$mn:00004325                 add     ecx, 2
.text$mn:00004328                 mov     [ebp+arg_8], ecx
.text$mn:0000432B
.text$mn:0000432B loc_432B:                               ; CODE XREF: std::_Transform<wchar_t *,wchar_t *,int (*)(int)>(wchar_t *,wchar_t *,wchar_t *,int (*)(int))+3j
.text$mn:0000432B                 mov     edx, [ebp+arg_0]
.text$mn:0000432E                 cmp     edx, [ebp+arg_4]
.text$mn:00004331                 jz      short loc_4348
.text$mn:00004333                 mov     eax, [ebp+arg_0]
.text$mn:00004336                 movzx   ecx, word ptr [eax]
.text$mn:00004339                 push    ecx
.text$mn:0000433A                 call    [ebp+arg_C]
.text$mn:0000433D                 add     esp, 4
.text$mn:00004340                 mov     edx, [ebp+arg_8]
.text$mn:00004343                 mov     [edx], ax
.text$mn:00004346                 jmp     short loc_4319
.text$mn:00004348 ; ---------------------------------------------------------------------------
.text$mn:00004348
.text$mn:00004348 loc_4348:                               ; CODE XREF: std::_Transform<wchar_t *,wchar_t *,int (*)(int)>(wchar_t *,wchar_t *,wchar_t *,int (*)(int))+1Dj
.text$mn:00004348                 mov     eax, [ebp+arg_8]
.text$mn:0000434B                 pop     ebp
.text$mn:0000434C                 retn
.text$mn:0000434C ??$_Transform@PA_WPA_WP6AHH@Z@std@@YAPA_WPA_W00P6AHH@Z@Z endp
.text$mn:0000434C
.text$mn:0000434C ; ---------------------------------------------------------------------------
.text$mn:0000434D                 align 10h
.text$mn:0000434D _text$mn        ends
.text$mn:0000434D
.text$mn:00004350 ; ===========================================================================
.text$mn:00004350
.text$mn:00004350 ; Segment type: Pure code
.text$mn:00004350 ; Segment permissions: Read/Execute
.text$mn:00004350 _text$mn        segment para public 'CODE' use32
.text$mn:00004350                 assume cs:_text$mn
.text$mn:00004350                 ;org 4350h
.text$mn:00004350 ; COMDAT (pick any)
.text$mn:00004350                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text$mn:00004350
.text$mn:00004350 ; =============== S U B R O U T I N E =======================================
.text$mn:00004350
.text$mn:00004350 ; Attributes: bp-based frame
.text$mn:00004350
.text$mn:00004350 ; protected: class std::basic_string<wchar_t, struct std::char_traits<wchar_t>, class std::allocator<wchar_t>> * __thiscall std::vector<class std::basic_string<wchar_t, struct std::char_traits<wchar_t>, class std::allocator<wchar_t>>, class std::allocator<class std::basic_string<wchar_t, struct std::char_traits<wchar_t>, class std::allocator<wchar_t>>>>::_Umove<class std::basic_string<wchar_t, struct std::char_traits<wchar_t>, class std::allocator<wchar_t>> *>(class std::basic_string<wchar_t, struct std::char_traits<wchar_t>, class std::allocator<wchar_t>> *, class std::basic_string<wchar_t, struct std::char_traits<wchar_t>, class std::allocator<wchar_t>> *, class std::basic_string<wchar_t, struct std::char_traits<wchar_t>, class std::allocator<wchar_t>> *)
.text$mn:00004350                 public ??$_Umove@PAV?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@@?$vector@V?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@V?$allocator@V?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@@2@@std@@IAEPAV?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@1@PAV21@00@Z
.text$mn:00004350 ??$_Umove@PAV?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@@?$vector@V?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@V?$allocator@V?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@@2@@std@@IAEPAV?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@1@PAV21@00@Z proc near
.text$mn:00004350                                         ; CODE XREF: std::vector<std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>>,std::allocator<std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>>>>::_Reallocate(uint)+65p
.text$mn:00004350
.text$mn:00004350 var_8           = dword ptr -8
.text$mn:00004350 var_1           = byte ptr -1
.text$mn:00004350 arg_0           = dword ptr  8
.text$mn:00004350 arg_4           = dword ptr  0Ch
.text$mn:00004350 arg_8           = dword ptr  10h
.text$mn:00004350
.text$mn:00004350                 push    ebp
.text$mn:00004351                 mov     ebp, esp
.text$mn:00004353                 sub     esp, 8
.text$mn:00004356                 mov     [ebp+var_8], ecx
.text$mn:00004359                 lea     eax, [ebp+var_1]
.text$mn:0000435C                 push    eax
.text$mn:0000435D                 mov     ecx, [ebp+var_8]
.text$mn:00004360                 call    ?_Getal@?$_Vector_alloc@$0A@U?$_Vec_base_types@V?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@V?$allocator@V?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@@2@@std@@@std@@QBE?AU?$_Wrap_alloc@V?$allocator@V?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@@std@@@2@XZ ; std::_Vector_alloc<0,std::_Vec_base_types<std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>>,std::allocator<std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>>>>>::_Getal(void)
.text$mn:00004365                 lea     ecx, [ebp+var_1]
.text$mn:00004368                 push    ecx
.text$mn:00004369                 mov     edx, [ebp+arg_8]
.text$mn:0000436C                 push    edx
.text$mn:0000436D                 mov     eax, [ebp+arg_4]
.text$mn:00004370                 push    eax
.text$mn:00004371                 mov     ecx, [ebp+arg_0]
.text$mn:00004374                 push    ecx
.text$mn:00004375                 call    ??$_Uninitialized_move@PAV?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@PAV12@U?$_Wrap_alloc@V?$allocator@V?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@@std@@@2@@std@@YAPAV?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@0@PAV10@00AAU?$_Wrap_alloc@V?$allocator@V?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@@std@@@0@@Z ; std::_Uninitialized_move<std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>> *,std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>> *,std::_Wrap_alloc<std::allocator<std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>>>>>(std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>> *,std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>> *,std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>> *,std::_Wrap_alloc<std::allocator<std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>>>> &)
.text$mn:0000437A                 add     esp, 10h
.text$mn:0000437D                 mov     esp, ebp
.text$mn:0000437F                 pop     ebp
.text$mn:00004380                 retn    0Ch
.text$mn:00004380 ??$_Umove@PAV?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@@?$vector@V?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@V?$allocator@V?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@@2@@std@@IAEPAV?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@1@PAV21@00@Z endp
.text$mn:00004380
.text$mn:00004380 ; ---------------------------------------------------------------------------
.text$mn:00004383                 align 4
.text$mn:00004383 _text$mn        ends
.text$mn:00004383
.text$mn:00004384 ; ===========================================================================
.text$mn:00004384
.text$mn:00004384 ; Segment type: Pure code
.text$mn:00004384 ; Segment permissions: Read/Execute
.text$mn:00004384 _text$mn        segment para public 'CODE' use32
.text$mn:00004384                 assume cs:_text$mn
.text$mn:00004384                 ;org 4384h
.text$mn:00004384 ; COMDAT (pick any)
.text$mn:00004384                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text$mn:00004384
.text$mn:00004384 ; =============== S U B R O U T I N E =======================================
.text$mn:00004384
.text$mn:00004384 ; Attributes: bp-based frame
.text$mn:00004384
.text$mn:00004384 ; protected: wchar_t * __thiscall std::vector<wchar_t, class std::allocator<wchar_t>>::_Umove<wchar_t *>(wchar_t *, wchar_t *, wchar_t *)
.text$mn:00004384                 public ??$_Umove@PA_W@?$vector@_WV?$allocator@_W@std@@@std@@IAEPA_WPA_W00@Z
.text$mn:00004384 ??$_Umove@PA_W@?$vector@_WV?$allocator@_W@std@@@std@@IAEPA_WPA_W00@Z proc near
.text$mn:00004384                                         ; CODE XREF: std::vector<wchar_t,std::allocator<wchar_t>>::_Reallocate(uint)+65p
.text$mn:00004384
.text$mn:00004384 var_8           = dword ptr -8
.text$mn:00004384 var_1           = byte ptr -1
.text$mn:00004384 arg_0           = dword ptr  8
.text$mn:00004384 arg_4           = dword ptr  0Ch
.text$mn:00004384 arg_8           = dword ptr  10h
.text$mn:00004384
.text$mn:00004384                 push    ebp
.text$mn:00004385                 mov     ebp, esp
.text$mn:00004387                 sub     esp, 8
.text$mn:0000438A                 mov     [ebp+var_8], ecx
.text$mn:0000438D                 lea     eax, [ebp+var_1]
.text$mn:00004390                 push    eax
.text$mn:00004391                 mov     ecx, [ebp+var_8]
.text$mn:00004394                 call    ?_Getal@?$_Vector_alloc@$0A@U?$_Vec_base_types@_WV?$allocator@_W@std@@@std@@@std@@QBE?AU?$_Wrap_alloc@V?$allocator@_W@std@@@2@XZ ; std::_Vector_alloc<0,std::_Vec_base_types<wchar_t,std::allocator<wchar_t>>>::_Getal(void)
.text$mn:00004399                 lea     ecx, [ebp+var_1]
.text$mn:0000439C                 push    ecx
.text$mn:0000439D                 mov     edx, [ebp+arg_8]
.text$mn:000043A0                 push    edx
.text$mn:000043A1                 mov     eax, [ebp+arg_4]
.text$mn:000043A4                 push    eax
.text$mn:000043A5                 mov     ecx, [ebp+arg_0]
.text$mn:000043A8                 push    ecx
.text$mn:000043A9                 call    ??$_Uninitialized_move@PA_WPA_WU?$_Wrap_alloc@V?$allocator@_W@std@@@std@@@std@@YAPA_WPA_W00AAU?$_Wrap_alloc@V?$allocator@_W@std@@@0@@Z ; std::_Uninitialized_move<wchar_t *,wchar_t *,std::_Wrap_alloc<std::allocator<wchar_t>>>(wchar_t *,wchar_t *,wchar_t *,std::_Wrap_alloc<std::allocator<wchar_t>> &)
.text$mn:000043AE                 add     esp, 10h
.text$mn:000043B1                 mov     esp, ebp
.text$mn:000043B3                 pop     ebp
.text$mn:000043B4                 retn    0Ch
.text$mn:000043B4 ??$_Umove@PA_W@?$vector@_WV?$allocator@_W@std@@@std@@IAEPA_WPA_W00@Z endp
.text$mn:000043B4
.text$mn:000043B4 ; ---------------------------------------------------------------------------
.text$mn:000043B7                 align 4
.text$mn:000043B7 _text$mn        ends
.text$mn:000043B7
.text$mn:000043B8 ; ===========================================================================
.text$mn:000043B8
.text$mn:000043B8 ; Segment type: Pure code
.text$mn:000043B8 ; Segment permissions: Read/Execute
.text$mn:000043B8 _text$mn        segment para public 'CODE' use32
.text$mn:000043B8                 assume cs:_text$mn
.text$mn:000043B8                 ;org 43B8h
.text$mn:000043B8 ; COMDAT (pick any)
.text$mn:000043B8                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text$mn:000043B8
.text$mn:000043B8 ; =============== S U B R O U T I N E =======================================
.text$mn:000043B8
.text$mn:000043B8 ; Attributes: bp-based frame
.text$mn:000043B8
.text$mn:000043B8 ; class std::basic_string<wchar_t, struct std::char_traits<wchar_t>, class std::allocator<wchar_t>> * __cdecl std::_Unchecked<class std::basic_string<wchar_t, struct std::char_traits<wchar_t>, class std::allocator<wchar_t>> *>(class std::basic_string<wchar_t, struct std::char_traits<wchar_t>, class std::allocator<wchar_t>> *)
.text$mn:000043B8                 public ??$_Unchecked@PAV?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@@std@@YAPAV?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@0@PAV10@@Z
.text$mn:000043B8 ??$_Unchecked@PAV?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@@std@@YAPAV?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@0@PAV10@@Z proc near
.text$mn:000043B8                                         ; CODE XREF: std::_Uninitialized_move<std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>> *,std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>> *,std::_Wrap_alloc<std::allocator<std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>>>>>(std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>> *,std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>> *,std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>> *,std::_Wrap_alloc<std::allocator<std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>>>> &)+Bp
.text$mn:000043B8                                         ; std::_Uninitialized_move<std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>> *,std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>> *,std::_Wrap_alloc<std::allocator<std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>>>>>(std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>> *,std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>> *,std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>> *,std::_Wrap_alloc<std::allocator<std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>>>> &)+18p ...
.text$mn:000043B8
.text$mn:000043B8 arg_0           = dword ptr  8
.text$mn:000043B8
.text$mn:000043B8                 push    ebp
.text$mn:000043B9                 mov     ebp, esp
.text$mn:000043BB                 mov     eax, [ebp+arg_0]
.text$mn:000043BE                 pop     ebp
.text$mn:000043BF                 retn
.text$mn:000043BF ??$_Unchecked@PAV?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@@std@@YAPAV?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@0@PAV10@@Z endp
.text$mn:000043BF
.text$mn:000043BF _text$mn        ends
.text$mn:000043BF
.text$mn:000043C0 ; ===========================================================================
.text$mn:000043C0
.text$mn:000043C0 ; Segment type: Pure code
.text$mn:000043C0 ; Segment permissions: Read/Execute
.text$mn:000043C0 _text$mn        segment para public 'CODE' use32
.text$mn:000043C0                 assume cs:_text$mn
.text$mn:000043C0                 ;org 43C0h
.text$mn:000043C0 ; COMDAT (pick any)
.text$mn:000043C0                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text$mn:000043C0
.text$mn:000043C0 ; =============== S U B R O U T I N E =======================================
.text$mn:000043C0
.text$mn:000043C0 ; Attributes: bp-based frame
.text$mn:000043C0
.text$mn:000043C0 ; wchar_t * __cdecl std::_Unchecked<wchar_t *>(wchar_t *)
.text$mn:000043C0                 public ??$_Unchecked@PA_W@std@@YAPA_WPA_W@Z
.text$mn:000043C0 ??$_Unchecked@PA_W@std@@YAPA_WPA_W@Z proc near
.text$mn:000043C0                                         ; CODE XREF: std::_Uninitialized_move<wchar_t *,wchar_t *,std::_Wrap_alloc<std::allocator<wchar_t>>>(wchar_t *,wchar_t *,wchar_t *,std::_Wrap_alloc<std::allocator<wchar_t>> &)+Bp
.text$mn:000043C0                                         ; std::_Uninitialized_move<wchar_t *,wchar_t *,std::_Wrap_alloc<std::allocator<wchar_t>>>(wchar_t *,wchar_t *,wchar_t *,std::_Wrap_alloc<std::allocator<wchar_t>> &)+18p ...
.text$mn:000043C0
.text$mn:000043C0 arg_0           = dword ptr  8
.text$mn:000043C0
.text$mn:000043C0                 push    ebp
.text$mn:000043C1                 mov     ebp, esp
.text$mn:000043C3                 mov     eax, [ebp+arg_0]
.text$mn:000043C6                 pop     ebp
.text$mn:000043C7                 retn
.text$mn:000043C7 ??$_Unchecked@PA_W@std@@YAPA_WPA_W@Z endp
.text$mn:000043C7
.text$mn:000043C7 _text$mn        ends
.text$mn:000043C7
.text$mn:000043C8 ; ===========================================================================
.text$mn:000043C8
.text$mn:000043C8 ; Segment type: Pure code
.text$mn:000043C8 ; Segment permissions: Read/Execute
.text$mn:000043C8 _text$mn        segment para public 'CODE' use32
.text$mn:000043C8                 assume cs:_text$mn
.text$mn:000043C8                 ;org 43C8h
.text$mn:000043C8 ; COMDAT (pick any)
.text$mn:000043C8                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text$mn:000043C8
.text$mn:000043C8 ; =============== S U B R O U T I N E =======================================
.text$mn:000043C8
.text$mn:000043C8 ; Attributes: bp-based frame
.text$mn:000043C8
.text$mn:000043C8 ; wchar_t * __cdecl std::_Unchecked<class std::_String_val<struct std::_Simple_types<wchar_t>>>(class std::_String_iterator<class std::_String_val<struct std::_Simple_types<wchar_t>>>)
.text$mn:000043C8                 public ??$_Unchecked@V?$_String_val@U?$_Simple_types@_W@std@@@std@@@std@@YAPA_WV?$_String_iterator@V?$_String_val@U?$_Simple_types@_W@std@@@std@@@0@@Z
.text$mn:000043C8 ??$_Unchecked@V?$_String_val@U?$_Simple_types@_W@std@@@std@@@std@@YAPA_WV?$_String_iterator@V?$_String_val@U?$_Simple_types@_W@std@@@std@@@0@@Z proc near
.text$mn:000043C8                                         ; CODE XREF: std::_Transform1<wchar_t *,std::_String_iterator<std::_String_val<std::_Simple_types<wchar_t>>>,int (*)(int)>(wchar_t *,wchar_t *,std::_String_iterator<std::_String_val<std::_Simple_types<wchar_t>>>,int (*)(int),std::random_access_iterator_tag,std::random_access_iterator_tag)+72p
.text$mn:000043C8                                         ; std::transform<std::_String_iterator<std::_String_val<std::_Simple_types<wchar_t>>>,std::_String_iterator<std::_String_val<std::_Simple_types<wchar_t>>>,int (*)(int)>(std::_String_iterator<std::_String_val<std::_Simple_types<wchar_t>>>,std::_String_iterator<std::_String_val<std::_Simple_types<wchar_t>>>,std::_String_iterator<std::_String_val<std::_Simple_types<wchar_t>>>,int (*)(int))+144p ...
.text$mn:000043C8
.text$mn:000043C8 var_10          = dword ptr -10h
.text$mn:000043C8 var_C           = dword ptr -0Ch
.text$mn:000043C8 var_4           = dword ptr -4
.text$mn:000043C8 arg_0           = byte ptr  8
.text$mn:000043C8
.text$mn:000043C8                 push    ebp
.text$mn:000043C9                 mov     ebp, esp
.text$mn:000043CB                 push    0FFFFFFFFh
.text$mn:000043CD                 push    offset __ehhandler$??$_Unchecked@V?$_String_val@U?$_Simple_types@_W@std@@@std@@@std@@YAPA_WV?$_String_iterator@V?$_String_val@U?$_Simple_types@_W@std@@@std@@@0@@Z
.text$mn:000043D2                 mov     eax, large fs:0
.text$mn:000043D8                 push    eax
.text$mn:000043D9                 push    ecx
.text$mn:000043DA                 mov     eax, dword ptr ds:___security_cookie
.text$mn:000043DF                 xor     eax, ebp
.text$mn:000043E1                 push    eax
.text$mn:000043E2                 lea     eax, [ebp+var_C]
.text$mn:000043E5                 mov     large fs:0, eax
.text$mn:000043EB                 mov     [ebp+var_4], 0
.text$mn:000043F2                 lea     ecx, [ebp+arg_0]
.text$mn:000043F5                 call    ?_Unchecked@?$_String_iterator@V?$_String_val@U?$_Simple_types@_W@std@@@std@@@std@@QBEPA_WXZ ; std::_String_iterator<std::_String_val<std::_Simple_types<wchar_t>>>::_Unchecked(void)
.text$mn:000043FA                 mov     [ebp+var_10], eax
.text$mn:000043FD                 mov     [ebp+var_4], 0FFFFFFFFh
.text$mn:00004404                 lea     ecx, [ebp+arg_0]
.text$mn:00004407                 call    ??1?$_String_iterator@V?$_String_val@U?$_Simple_types@_W@std@@@std@@@std@@QAE@XZ ; std::_String_iterator<std::_String_val<std::_Simple_types<wchar_t>>>::~_String_iterator<std::_String_val<std::_Simple_types<wchar_t>>>(void)
.text$mn:0000440C                 mov     eax, [ebp+var_10]
.text$mn:0000440F                 mov     ecx, [ebp+var_C]
.text$mn:00004412                 mov     large fs:0, ecx
.text$mn:00004419                 pop     ecx
.text$mn:0000441A                 mov     esp, ebp
.text$mn:0000441C                 pop     ebp
.text$mn:0000441D                 retn
.text$mn:0000441D ??$_Unchecked@V?$_String_val@U?$_Simple_types@_W@std@@@std@@@std@@YAPA_WV?$_String_iterator@V?$_String_val@U?$_Simple_types@_W@std@@@std@@@0@@Z endp
.text$mn:0000441D
.text$mn:0000441D ; ---------------------------------------------------------------------------
.text$mn:0000441E                 align 10h
.text$mn:0000441E _text$mn        ends
.text$mn:0000441E
.text$x:00004420 ; ===========================================================================
.text$x:00004420
.text$x:00004420 ; Segment type: Pure code
.text$x:00004420 ; Segment permissions: Read/Execute
.text$x:00004420 _text$x         segment para public 'CODE' use32
.text$x:00004420                 assume cs:_text$x
.text$x:00004420                 ;org 4420h
.text$x:00004420 ; COMDAT (pick associative to section at 43C8)
.text$x:00004420                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text$x:00004420
.text$x:00004420 ; =============== S U B R O U T I N E =======================================
.text$x:00004420
.text$x:00004420
.text$x:00004420 __unwindfunclet$??$_Unchecked@V?$_String_val@U?$_Simple_types@_W@std@@@std@@@std@@YAPA_WV?$_String_iterator@V?$_String_val@U?$_Simple_types@_W@std@@@std@@@0@@Z$0 proc near
.text$x:00004420                                         ; DATA XREF: .xdata$x:0000EEE0o
.text$x:00004420                 lea     ecx, [ebp+8]
.text$x:00004423                 jmp     ??1?$_String_iterator@V?$_String_val@U?$_Simple_types@_W@std@@@std@@@std@@QAE@XZ ; std::_String_iterator<std::_String_val<std::_Simple_types<wchar_t>>>::~_String_iterator<std::_String_val<std::_Simple_types<wchar_t>>>(void)
.text$x:00004423 __unwindfunclet$??$_Unchecked@V?$_String_val@U?$_Simple_types@_W@std@@@std@@@std@@YAPA_WV?$_String_iterator@V?$_String_val@U?$_Simple_types@_W@std@@@std@@@0@@Z$0 endp
.text$x:00004423
.text$x:00004428
.text$x:00004428 ; =============== S U B R O U T I N E =======================================
.text$x:00004428
.text$x:00004428
.text$x:00004428 __ehhandler$??$_Unchecked@V?$_String_val@U?$_Simple_types@_W@std@@@std@@@std@@YAPA_WV?$_String_iterator@V?$_String_val@U?$_Simple_types@_W@std@@@std@@@0@@Z proc near
.text$x:00004428                                         ; DATA XREF: std::_Unchecked<std::_String_val<std::_Simple_types<wchar_t>>>(std::_String_iterator<std::_String_val<std::_Simple_types<wchar_t>>>)+5o
.text$x:00004428
.text$x:00004428 arg_4           = dword ptr  8
.text$x:00004428
.text$x:00004428                 mov     edx, [esp+arg_4]
.text$x:0000442C                 lea     eax, [edx+0Ch]
.text$x:0000442F                 mov     ecx, [edx-8]
.text$x:00004432                 xor     ecx, eax
.text$x:00004434                 call    @__security_check_cookie@4 ; __security_check_cookie(x)
.text$x:00004439                 mov     eax, offset __ehfuncinfo$??$_Unchecked@V?$_String_val@U?$_Simple_types@_W@std@@@std@@@std@@YAPA_WV?$_String_iterator@V?$_String_val@U?$_Simple_types@_W@std@@@std@@@0@@Z
.text$x:0000443E                 jmp     ___CxxFrameHandler3
.text$x:0000443E __ehhandler$??$_Unchecked@V?$_String_val@U?$_Simple_types@_W@std@@@std@@@std@@YAPA_WV?$_String_iterator@V?$_String_val@U?$_Simple_types@_W@std@@@std@@@0@@Z endp
.text$x:0000443E
.text$x:0000443E ; ---------------------------------------------------------------------------
.text$x:00004443                 align 4
.text$x:00004443 _text$x         ends
.text$x:00004443
.text$mn:00004444 ; ===========================================================================
.text$mn:00004444
.text$mn:00004444 ; Segment type: Pure code
.text$mn:00004444 ; Segment permissions: Read/Execute
.text$mn:00004444 _text$mn        segment para public 'CODE' use32
.text$mn:00004444                 assume cs:_text$mn
.text$mn:00004444                 ;org 4444h
.text$mn:00004444 ; COMDAT (pick any)
.text$mn:00004444                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text$mn:00004444
.text$mn:00004444 ; =============== S U B R O U T I N E =======================================
.text$mn:00004444
.text$mn:00004444 ; Attributes: bp-based frame
.text$mn:00004444
.text$mn:00004444 ; int __cdecl std::_Uninit_def_fill_n<char,unsigned int,char>(char *Dst, size_t Size)
.text$mn:00004444                 public ??$_Uninit_def_fill_n@DID@std@@YAXPADIAAU?$_Wrap_alloc@V?$allocator@D@std@@@0@0U_Scalar_ptr_iterator_tag@0@@Z
.text$mn:00004444 ??$_Uninit_def_fill_n@DID@std@@YAXPADIAAU?$_Wrap_alloc@V?$allocator@D@std@@@0@0U_Scalar_ptr_iterator_tag@0@@Z proc near
.text$mn:00004444                                         ; CODE XREF: std::_Uninitialized_default_fill_n<char *,uint,std::_Wrap_alloc<std::allocator<char>>>(char *,uint,std::_Wrap_alloc<std::allocator<char>> &)+35p
.text$mn:00004444
.text$mn:00004444 Dst             = dword ptr  8
.text$mn:00004444 Size            = dword ptr  0Ch
.text$mn:00004444
.text$mn:00004444                 push    ebp
.text$mn:00004445                 mov     ebp, esp
.text$mn:00004447                 push    0               ; char
.text$mn:00004449                 mov     eax, [ebp+Size]
.text$mn:0000444C                 push    eax             ; Size
.text$mn:0000444D                 mov     ecx, [ebp+Dst]
.text$mn:00004450                 push    ecx             ; Dst
.text$mn:00004451                 call    ?_Fill_n@std@@YAPADPADID@Z ; std::_Fill_n(char *,uint,char)
.text$mn:00004456                 add     esp, 0Ch
.text$mn:00004459                 pop     ebp
.text$mn:0000445A                 retn
.text$mn:0000445A ??$_Uninit_def_fill_n@DID@std@@YAXPADIAAU?$_Wrap_alloc@V?$allocator@D@std@@@0@0U_Scalar_ptr_iterator_tag@0@@Z endp
.text$mn:0000445A
.text$mn:0000445A ; ---------------------------------------------------------------------------
.text$mn:0000445B                 align 4
.text$mn:0000445B _text$mn        ends
.text$mn:0000445B
.text$mn:0000445C ; ===========================================================================
.text$mn:0000445C
.text$mn:0000445C ; Segment type: Pure code
.text$mn:0000445C ; Segment permissions: Read/Execute
.text$mn:0000445C _text$mn        segment para public 'CODE' use32
.text$mn:0000445C                 assume cs:_text$mn
.text$mn:0000445C                 ;org 445Ch
.text$mn:0000445C ; COMDAT (pick any)
.text$mn:0000445C                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text$mn:0000445C
.text$mn:0000445C ; =============== S U B R O U T I N E =======================================
.text$mn:0000445C
.text$mn:0000445C ; Attributes: bp-based frame
.text$mn:0000445C
.text$mn:0000445C ; void __cdecl std::_Uninit_def_fill_n<wchar_t, unsigned int, wchar_t>(wchar_t *, unsigned int, struct std::_Wrap_alloc<class std::allocator<wchar_t>> &, wchar_t *, struct std::_Scalar_ptr_iterator_tag)
.text$mn:0000445C                 public ??$_Uninit_def_fill_n@_WI_W@std@@YAXPA_WIAAU?$_Wrap_alloc@V?$allocator@_W@std@@@0@0U_Scalar_ptr_iterator_tag@0@@Z
.text$mn:0000445C ??$_Uninit_def_fill_n@_WI_W@std@@YAXPA_WIAAU?$_Wrap_alloc@V?$allocator@_W@std@@@0@0U_Scalar_ptr_iterator_tag@0@@Z proc near
.text$mn:0000445C                                         ; CODE XREF: std::_Uninitialized_default_fill_n<wchar_t *,uint,std::_Wrap_alloc<std::allocator<wchar_t>>>(wchar_t *,uint,std::_Wrap_alloc<std::allocator<wchar_t>> &)+35p
.text$mn:0000445C
.text$mn:0000445C var_2           = word ptr -2
.text$mn:0000445C arg_0           = dword ptr  8
.text$mn:0000445C arg_4           = dword ptr  0Ch
.text$mn:0000445C
.text$mn:0000445C                 push    ebp
.text$mn:0000445D                 mov     ebp, esp
.text$mn:0000445F                 push    ecx
.text$mn:00004460                 xor     eax, eax
.text$mn:00004462                 mov     [ebp+var_2], ax
.text$mn:00004466                 lea     ecx, [ebp+var_2]
.text$mn:00004469                 push    ecx
.text$mn:0000446A                 mov     edx, [ebp+arg_4]
.text$mn:0000446D                 push    edx
.text$mn:0000446E                 mov     eax, [ebp+arg_0]
.text$mn:00004471                 push    eax
.text$mn:00004472                 call    ??$_Fill_n@PA_WI_W@std@@YAPA_WPA_WIAB_W@Z ; std::_Fill_n<wchar_t *,uint,wchar_t>(wchar_t *,uint,wchar_t const &)
.text$mn:00004477                 add     esp, 0Ch
.text$mn:0000447A                 mov     esp, ebp
.text$mn:0000447C                 pop     ebp
.text$mn:0000447D                 retn
.text$mn:0000447D ??$_Uninit_def_fill_n@_WI_W@std@@YAXPA_WIAAU?$_Wrap_alloc@V?$allocator@_W@std@@@0@0U_Scalar_ptr_iterator_tag@0@@Z endp
.text$mn:0000447D
.text$mn:0000447D ; ---------------------------------------------------------------------------
.text$mn:0000447E                 align 10h
.text$mn:0000447E _text$mn        ends
.text$mn:0000447E
.text$mn:00004480 ; ===========================================================================
.text$mn:00004480
.text$mn:00004480 ; Segment type: Pure code
.text$mn:00004480 ; Segment permissions: Read/Execute
.text$mn:00004480 _text$mn        segment para public 'CODE' use32
.text$mn:00004480                 assume cs:_text$mn
.text$mn:00004480                 ;org 4480h
.text$mn:00004480 ; COMDAT (pick any)
.text$mn:00004480                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text$mn:00004480
.text$mn:00004480 ; =============== S U B R O U T I N E =======================================
.text$mn:00004480
.text$mn:00004480 ; Attributes: bp-based frame
.text$mn:00004480
.text$mn:00004480 ; int __cdecl std::_Uninit_move<std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>> *,std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>> *,std::_Wrap_alloc<std::allocator<std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>>>>>(int, int, void *, int)
.text$mn:00004480                 public ??$_Uninit_move@PAV?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@PAV12@U?$_Wrap_alloc@V?$allocator@V?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@@std@@@2@@std@@YAPAV?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@0@PAV10@00AAU?$_Wrap_alloc@V?$allocator@V?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@@std@@@0@@Z
.text$mn:00004480 ??$_Uninit_move@PAV?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@PAV12@U?$_Wrap_alloc@V?$allocator@V?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@@std@@@2@@std@@YAPAV?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@0@PAV10@00AAU?$_Wrap_alloc@V?$allocator@V?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@@std@@@0@@Z proc near
.text$mn:00004480                                         ; CODE XREF: std::_Uninitialized_move<std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>> *,std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>> *,std::_Wrap_alloc<std::allocator<std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>>>>>(std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>> *,std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>> *,std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>> *,std::_Wrap_alloc<std::allocator<std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>>>> &)+2Ep
.text$mn:00004480
.text$mn:00004480 var_1           = byte ptr -1
.text$mn:00004480 arg_0           = dword ptr  8
.text$mn:00004480 arg_4           = dword ptr  0Ch
.text$mn:00004480 arg_8           = dword ptr  10h
.text$mn:00004480 arg_C           = dword ptr  14h
.text$mn:00004480
.text$mn:00004480                 push    ebp
.text$mn:00004481                 mov     ebp, esp
.text$mn:00004483                 push    ecx
.text$mn:00004484                 mov     eax, [ebp+arg_8]
.text$mn:00004487                 push    eax
.text$mn:00004488                 mov     ecx, [ebp+arg_0]
.text$mn:0000448B                 push    ecx
.text$mn:0000448C                 call    ??$_Ptr_cat@V?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@V12@@std@@YA?AU_Nonscalar_ptr_iterator_tag@0@PAV?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@0@0@Z ; std::_Ptr_cat<std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>>,std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>>>(std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>> *,std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>> *)
.text$mn:00004491                 add     esp, 8
.text$mn:00004494                 mov     [ebp+var_1], al
.text$mn:00004497                 movzx   edx, [ebp+var_1]
.text$mn:0000449B                 push    edx
.text$mn:0000449C                 mov     eax, [ebp+arg_0]
.text$mn:0000449F                 push    eax
.text$mn:000044A0                 call    ??$_Val_type@PAV?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@@std@@YAPAV?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@0@PAV10@@Z ; std::_Val_type<std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>> *>(std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>> *)
.text$mn:000044A5                 add     esp, 4
.text$mn:000044A8                 push    eax
.text$mn:000044A9                 mov     ecx, [ebp+arg_C]
.text$mn:000044AC                 push    ecx             ; int
.text$mn:000044AD                 mov     edx, [ebp+arg_8]
.text$mn:000044B0                 push    edx             ; void *
.text$mn:000044B1                 mov     eax, [ebp+arg_4]
.text$mn:000044B4                 push    eax             ; int
.text$mn:000044B5                 mov     ecx, [ebp+arg_0]
.text$mn:000044B8                 push    ecx             ; int
.text$mn:000044B9                 call    ??$_Uninit_move@PAV?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@PAV12@V?$allocator@V?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@@2@V12@@std@@YAPAV?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@0@PAV10@00AAU?$_Wrap_alloc@V?$allocator@V?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@@std@@@0@0U_Nonscalar_ptr_iterator_tag@0@@Z ; std::_Uninit_move<std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>> *,std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>> *,std::allocator<std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>>>,std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>>>(std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>> *,std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>> *,std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>> *,std::_Wrap_alloc<std::allocator<std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>>>> &,std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>> *,std::_Nonscalar_ptr_iterator_tag)
.text$mn:000044BE                 add     esp, 18h
.text$mn:000044C1                 mov     esp, ebp
.text$mn:000044C3                 pop     ebp
.text$mn:000044C4                 retn
.text$mn:000044C4 ??$_Uninit_move@PAV?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@PAV12@U?$_Wrap_alloc@V?$allocator@V?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@@std@@@2@@std@@YAPAV?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@0@PAV10@00AAU?$_Wrap_alloc@V?$allocator@V?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@@std@@@0@@Z endp
.text$mn:000044C4
.text$mn:000044C4 ; ---------------------------------------------------------------------------
.text$mn:000044C5                 align 4
.text$mn:000044C5 _text$mn        ends
.text$mn:000044C5
.text$mn:000044C8 ; ===========================================================================
.text$mn:000044C8
.text$mn:000044C8 ; Segment type: Pure code
.text$mn:000044C8 ; Segment permissions: Read/Execute
.text$mn:000044C8 _text$mn        segment para public 'CODE' use32
.text$mn:000044C8                 assume cs:_text$mn
.text$mn:000044C8                 ;org 44C8h
.text$mn:000044C8 ; COMDAT (pick any)
.text$mn:000044C8                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text$mn:000044C8
.text$mn:000044C8 ; =============== S U B R O U T I N E =======================================
.text$mn:000044C8
.text$mn:000044C8 ; Attributes: bp-based frame
.text$mn:000044C8
.text$mn:000044C8 ; int __cdecl std::_Uninit_move<std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>> *,std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>> *,std::allocator<std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>>>,std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>>>(int, int, void *, int)
.text$mn:000044C8                 public ??$_Uninit_move@PAV?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@PAV12@V?$allocator@V?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@@2@V12@@std@@YAPAV?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@0@PAV10@00AAU?$_Wrap_alloc@V?$allocator@V?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@@std@@@0@0U_Nonscalar_ptr_iterator_tag@0@@Z
.text$mn:000044C8 ??$_Uninit_move@PAV?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@PAV12@V?$allocator@V?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@@2@V12@@std@@YAPAV?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@0@PAV10@00AAU?$_Wrap_alloc@V?$allocator@V?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@@std@@@0@0U_Nonscalar_ptr_iterator_tag@0@@Z proc near
.text$mn:000044C8                                         ; CODE XREF: std::_Uninit_move<std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>> *,std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>> *,std::_Wrap_alloc<std::allocator<std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>>>>>(std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>> *,std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>> *,std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>> *,std::_Wrap_alloc<std::allocator<std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>>>> &)+39p
.text$mn:000044C8
.text$mn:000044C8 var_14          = dword ptr -14h
.text$mn:000044C8 var_10          = dword ptr -10h
.text$mn:000044C8 var_C           = dword ptr -0Ch
.text$mn:000044C8 var_4           = dword ptr -4
.text$mn:000044C8 arg_0           = dword ptr  8
.text$mn:000044C8 arg_4           = dword ptr  0Ch
.text$mn:000044C8 arg_8           = dword ptr  10h
.text$mn:000044C8 arg_C           = dword ptr  14h
.text$mn:000044C8
.text$mn:000044C8 ; FUNCTION CHUNK AT .text$mn:0000458F SIZE 00000009 BYTES
.text$mn:000044C8 ; FUNCTION CHUNK AT .text$mn:0000459F SIZE 00000015 BYTES
.text$mn:000044C8
.text$mn:000044C8                 push    ebp
.text$mn:000044C9                 mov     ebp, esp
.text$mn:000044CB                 push    0FFFFFFFFh
.text$mn:000044CD                 push    offset __ehhandler$??$_Uninit_move@PAV?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@PAV12@V?$allocator@V?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@@2@V12@@std@@YAPAV?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@0@PAV10@00AAU?$_Wrap_alloc@V?$allocator@V?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@@std@@@0@0U_Nonscalar_ptr_iterator_tag@0@@Z
.text$mn:000044D2                 mov     eax, large fs:0
.text$mn:000044D8                 push    eax
.text$mn:000044D9                 push    ecx
.text$mn:000044DA                 push    ecx
.text$mn:000044DB                 push    ebx
.text$mn:000044DC                 push    esi
.text$mn:000044DD                 push    edi
.text$mn:000044DE                 mov     eax, dword ptr ds:___security_cookie
.text$mn:000044E3                 xor     eax, ebp
.text$mn:000044E5                 push    eax
.text$mn:000044E6                 lea     eax, [ebp+var_C]
.text$mn:000044E9                 mov     large fs:0, eax
.text$mn:000044EF                 mov     [ebp+var_10], esp
.text$mn:000044F2                 push    1B6h            ; unsigned int
.text$mn:000044F7                 push    offset ??_C@_1IO@LKIDJAMC@?$AAC?$AA?3?$AA?2?$AAP?$AAr?$AAo?$AAg?$AAr?$AAa?$AAm?$AA?5?$AAF?$AAi?$AAl?$AAe?$AAs?$AA?5?$AA?$CI?$AAx?$AA8?$AA6?$AA?$CJ?$AA?2?$AAM?$AAi?$AAc?$AAr?$AAo?$AAs?$AAo?$AAf?$AAt@ ; "C:\\Program Files (x86)\\Microsoft Visu"...
.text$mn:000044FC                 mov     eax, [ebp+arg_4]
.text$mn:000044FF                 push    eax             ; int
.text$mn:00004500                 mov     ecx, [ebp+arg_0]
.text$mn:00004503                 push    ecx             ; int
.text$mn:00004504                 call    ??$_Debug_range@PAV?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@@std@@YAXPAV?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@0@0PB_WI@Z ; std::_Debug_range<std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>> *>(std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>> *,std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>> *,wchar_t const *,uint)
.text$mn:00004509                 add     esp, 10h
.text$mn:0000450C                 push    1B7h            ; unsigned int
.text$mn:00004511                 push    offset ??_C@_1IO@LKIDJAMC@?$AAC?$AA?3?$AA?2?$AAP?$AAr?$AAo?$AAg?$AAr?$AAa?$AAm?$AA?5?$AAF?$AAi?$AAl?$AAe?$AAs?$AA?5?$AA?$CI?$AAx?$AA8?$AA6?$AA?$CJ?$AA?2?$AAM?$AAi?$AAc?$AAr?$AAo?$AAs?$AAo?$AAf?$AAt@ ; "C:\\Program Files (x86)\\Microsoft Visu"...
.text$mn:00004516                 mov     edx, [ebp+arg_8]
.text$mn:00004519                 push    edx             ; int
.text$mn:0000451A                 call    ??$_Debug_pointer@V?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@@std@@YAXPAV?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@0@PB_WI@Z ; std::_Debug_pointer<std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>>>(std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>> *,wchar_t const *,uint)
.text$mn:0000451F                 add     esp, 0Ch
.text$mn:00004522                 mov     eax, [ebp+arg_8]
.text$mn:00004525                 mov     [ebp+var_14], eax
.text$mn:00004528                 mov     [ebp+var_4], 0
.text$mn:0000452F                 jmp     short loc_4543
.text$mn:00004531 ; ---------------------------------------------------------------------------
.text$mn:00004531
.text$mn:00004531 loc_4531:                               ; CODE XREF: std::_Uninit_move<std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>> *,std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>> *,std::allocator<std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>>>,std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>>>(std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>> *,std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>> *,std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>> *,std::_Wrap_alloc<std::allocator<std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>>>> &,std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>> *,std::_Nonscalar_ptr_iterator_tag)+93j
.text$mn:00004531                 mov     ecx, [ebp+arg_8]
.text$mn:00004534                 add     ecx, 1Ch
.text$mn:00004537                 mov     [ebp+arg_8], ecx
.text$mn:0000453A                 mov     edx, [ebp+arg_0]
.text$mn:0000453D                 add     edx, 1Ch
.text$mn:00004540                 mov     [ebp+arg_0], edx
.text$mn:00004543
.text$mn:00004543 loc_4543:                               ; CODE XREF: std::_Uninit_move<std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>> *,std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>> *,std::allocator<std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>>>,std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>>>(std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>> *,std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>> *,std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>> *,std::_Wrap_alloc<std::allocator<std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>>>> &,std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>> *,std::_Nonscalar_ptr_iterator_tag)+67j
.text$mn:00004543                 mov     eax, [ebp+arg_0]
.text$mn:00004546                 cmp     eax, [ebp+arg_4]
.text$mn:00004549                 jz      short loc_455D
.text$mn:0000454B                 mov     ecx, [ebp+arg_0]
.text$mn:0000454E                 push    ecx             ; int
.text$mn:0000454F                 mov     edx, [ebp+arg_8]
.text$mn:00004552                 push    edx             ; void *
.text$mn:00004553                 mov     ecx, [ebp+arg_C]
.text$mn:00004556                 call    ??$construct@V?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@V12@@?$_Wrap_alloc@V?$allocator@V?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@@std@@@std@@QAEXPAV?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@1@$$QAV21@@Z ; std::_Wrap_alloc<std::allocator<std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>>>>::construct<std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>>,std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>>>(std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>> *,std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>> &&)
.text$mn:0000455B                 jmp     short loc_4531
.text$mn:0000455D ; ---------------------------------------------------------------------------
.text$mn:0000455D
.text$mn:0000455D loc_455D:                               ; CODE XREF: std::_Uninit_move<std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>> *,std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>> *,std::allocator<std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>>>,std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>>>(std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>> *,std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>> *,std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>> *,std::_Wrap_alloc<std::allocator<std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>>>> &,std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>> *,std::_Nonscalar_ptr_iterator_tag)+81j
.text$mn:0000455D                 jmp     short loc_458F
.text$mn:0000455D ??$_Uninit_move@PAV?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@PAV12@V?$allocator@V?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@@2@V12@@std@@YAPAV?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@0@PAV10@00AAU?$_Wrap_alloc@V?$allocator@V?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@@std@@@0@0U_Nonscalar_ptr_iterator_tag@0@@Z endp
.text$mn:0000455D
.text$mn:0000455F
.text$mn:0000455F ; =============== S U B R O U T I N E =======================================
.text$mn:0000455F
.text$mn:0000455F ; Attributes: noreturn
.text$mn:0000455F
.text$mn:0000455F __catch$??$_Uninit_move@PAV?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@PAV12@V?$allocator@V?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@@2@V12@@std@@YAPAV?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@0@PAV10@00AAU?$_Wrap_alloc@V?$allocator@V?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@@std@@@0@0U_Nonscalar_ptr_iterator_tag@0@@Z$0 proc near
.text$mn:0000455F                                         ; DATA XREF: .xdata$x:0000F194o
.text$mn:0000455F                 jmp     short loc_456A
.text$mn:00004561 ; ---------------------------------------------------------------------------
.text$mn:00004561
.text$mn:00004561 loc_4561:                               ; CODE XREF: __catch$??$_Uninit_move@PAV?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@PAV12@V?$allocator@V?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@@2@V12@@std@@YAPAV?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@0@PAV10@00AAU?$_Wrap_alloc@V?$allocator@V?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@@std@@@0@0U_Nonscalar_ptr_iterator_tag@0@@Z$0+1Fj
.text$mn:00004561                 mov     eax, [ebp-14h]
.text$mn:00004564                 add     eax, 1Ch
.text$mn:00004567                 mov     [ebp-14h], eax
.text$mn:0000456A
.text$mn:0000456A loc_456A:                               ; CODE XREF: __catch$??$_Uninit_move@PAV?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@PAV12@V?$allocator@V?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@@2@V12@@std@@YAPAV?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@0@PAV10@00AAU?$_Wrap_alloc@V?$allocator@V?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@@std@@@0@0U_Nonscalar_ptr_iterator_tag@0@@Z$0j
.text$mn:0000456A                 mov     ecx, [ebp-14h]
.text$mn:0000456D                 cmp     ecx, [ebp+10h]
.text$mn:00004570                 jz      short loc_4580
.text$mn:00004572                 mov     edx, [ebp-14h]
.text$mn:00004575                 push    edx
.text$mn:00004576                 mov     ecx, [ebp+14h]
.text$mn:00004579                 call    ??$destroy@V?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@@?$_Wrap_alloc@V?$allocator@V?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@@std@@@std@@QAEXPAV?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@1@@Z ; std::_Wrap_alloc<std::allocator<std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>>>>::destroy<std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>>>(std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>> *)
.text$mn:0000457E                 jmp     short loc_4561
.text$mn:00004580 ; ---------------------------------------------------------------------------
.text$mn:00004580
.text$mn:00004580 loc_4580:                               ; CODE XREF: __catch$??$_Uninit_move@PAV?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@PAV12@V?$allocator@V?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@@2@V12@@std@@YAPAV?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@0@PAV10@00AAU?$_Wrap_alloc@V?$allocator@V?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@@std@@@0@0U_Nonscalar_ptr_iterator_tag@0@@Z$0+11j
.text$mn:00004580                 push    0
.text$mn:00004582                 push    0
.text$mn:00004584                 call    __CxxThrowException@8 ; _CxxThrowException(x,x)
.text$mn:00004584 __catch$??$_Uninit_move@PAV?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@PAV12@V?$allocator@V?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@@2@V12@@std@@YAPAV?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@0@PAV10@00AAU?$_Wrap_alloc@V?$allocator@V?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@@std@@@0@0U_Nonscalar_ptr_iterator_tag@0@@Z$0 endp
.text$mn:00004584
.text$mn:00004589 ; ---------------------------------------------------------------------------
.text$mn:00004589                 mov     eax, offset $LN13
.text$mn:0000458E                 retn
.text$mn:0000458F ; ---------------------------------------------------------------------------
.text$mn:0000458F ; START OF FUNCTION CHUNK FOR ??$_Uninit_move@PAV?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@PAV12@V?$allocator@V?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@@2@V12@@std@@YAPAV?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@0@PAV10@00AAU?$_Wrap_alloc@V?$allocator@V?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@@std@@@0@0U_Nonscalar_ptr_iterator_tag@0@@Z
.text$mn:0000458F
.text$mn:0000458F loc_458F:                               ; CODE XREF: std::_Uninit_move<std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>> *,std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>> *,std::allocator<std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>>>,std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>>>(std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>> *,std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>> *,std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>> *,std::_Wrap_alloc<std::allocator<std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>>>> &,std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>> *,std::_Nonscalar_ptr_iterator_tag):loc_455Dj
.text$mn:0000458F                 mov     [ebp+var_4], 0FFFFFFFFh
.text$mn:00004596                 jmp     short loc_459F
.text$mn:00004596 ; END OF FUNCTION CHUNK FOR ??$_Uninit_move@PAV?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@PAV12@V?$allocator@V?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@@2@V12@@std@@YAPAV?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@0@PAV10@00AAU?$_Wrap_alloc@V?$allocator@V?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@@std@@@0@0U_Nonscalar_ptr_iterator_tag@0@@Z
.text$mn:00004598
.text$mn:00004598 ; =============== S U B R O U T I N E =======================================
.text$mn:00004598
.text$mn:00004598
.text$mn:00004598 $LN13           proc near               ; DATA XREF: .text$mn:00004589o
.text$mn:00004598                 mov     dword ptr [ebp-4], 0FFFFFFFFh
.text$mn:00004598 $LN13           endp ; sp-analysis failed
.text$mn:00004598
.text$mn:0000459F ; START OF FUNCTION CHUNK FOR ??$_Uninit_move@PAV?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@PAV12@V?$allocator@V?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@@2@V12@@std@@YAPAV?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@0@PAV10@00AAU?$_Wrap_alloc@V?$allocator@V?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@@std@@@0@0U_Nonscalar_ptr_iterator_tag@0@@Z
.text$mn:0000459F
.text$mn:0000459F loc_459F:                               ; CODE XREF: std::_Uninit_move<std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>> *,std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>> *,std::allocator<std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>>>,std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>>>(std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>> *,std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>> *,std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>> *,std::_Wrap_alloc<std::allocator<std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>>>> &,std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>> *,std::_Nonscalar_ptr_iterator_tag)+CEj
.text$mn:0000459F                 mov     eax, [ebp+arg_8]
.text$mn:000045A2                 mov     ecx, [ebp+var_C]
.text$mn:000045A5                 mov     large fs:0, ecx
.text$mn:000045AC                 pop     ecx
.text$mn:000045AD                 pop     edi
.text$mn:000045AE                 pop     esi
.text$mn:000045AF                 pop     ebx
.text$mn:000045B0                 mov     esp, ebp
.text$mn:000045B2                 pop     ebp
.text$mn:000045B3                 retn
.text$mn:000045B3 ; END OF FUNCTION CHUNK FOR ??$_Uninit_move@PAV?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@PAV12@V?$allocator@V?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@@2@V12@@std@@YAPAV?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@0@PAV10@00AAU?$_Wrap_alloc@V?$allocator@V?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@@std@@@0@0U_Nonscalar_ptr_iterator_tag@0@@Z
.text$mn:000045B3 _text$mn        ends
.text$mn:000045B3
.text$x:000045B4 ; ===========================================================================
.text$x:000045B4
.text$x:000045B4 ; Segment type: Pure code
.text$x:000045B4 ; Segment permissions: Read/Execute
.text$x:000045B4 _text$x         segment para public 'CODE' use32
.text$x:000045B4                 assume cs:_text$x
.text$x:000045B4                 ;org 45B4h
.text$x:000045B4 ; COMDAT (pick associative to section at 44C8)
.text$x:000045B4                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text$x:000045B4
.text$x:000045B4 ; =============== S U B R O U T I N E =======================================
.text$x:000045B4
.text$x:000045B4
.text$x:000045B4 __ehhandler$??$_Uninit_move@PAV?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@PAV12@V?$allocator@V?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@@2@V12@@std@@YAPAV?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@0@PAV10@00AAU?$_Wrap_alloc@V?$allocator@V?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@@std@@@0@0U_Nonscalar_ptr_iterator_tag@0@@Z proc near
.text$x:000045B4                                         ; DATA XREF: std::_Uninit_move<std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>> *,std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>> *,std::allocator<std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>>>,std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>>>(std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>> *,std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>> *,std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>> *,std::_Wrap_alloc<std::allocator<std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>>>> &,std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>> *,std::_Nonscalar_ptr_iterator_tag)+5o
.text$x:000045B4
.text$x:000045B4 arg_4           = dword ptr  8
.text$x:000045B4
.text$x:000045B4                 mov     edx, [esp+arg_4]
.text$x:000045B8                 lea     eax, [edx+0Ch]
.text$x:000045BB                 mov     ecx, [edx-18h]
.text$x:000045BE                 xor     ecx, eax
.text$x:000045C0                 call    @__security_check_cookie@4 ; __security_check_cookie(x)
.text$x:000045C5                 mov     eax, offset __ehfuncinfo$??$_Uninit_move@PAV?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@PAV12@V?$allocator@V?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@@2@V12@@std@@YAPAV?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@0@PAV10@00AAU?$_Wrap_alloc@V?$allocator@V?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@@std@@@0@0U_Nonscalar_ptr_iterator_tag@0@@Z
.text$x:000045CA                 jmp     ___CxxFrameHandler3
.text$x:000045CA __ehhandler$??$_Uninit_move@PAV?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@PAV12@V?$allocator@V?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@@2@V12@@std@@YAPAV?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@0@PAV10@00AAU?$_Wrap_alloc@V?$allocator@V?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@@std@@@0@0U_Nonscalar_ptr_iterator_tag@0@@Z endp
.text$x:000045CA
.text$x:000045CA ; ---------------------------------------------------------------------------
.text$x:000045CF                 align 10h
.text$x:000045CF _text$x         ends
.text$x:000045CF
.text$mn:000045D0 ; ===========================================================================
.text$mn:000045D0
.text$mn:000045D0 ; Segment type: Pure code
.text$mn:000045D0 ; Segment permissions: Read/Execute
.text$mn:000045D0 _text$mn        segment para public 'CODE' use32
.text$mn:000045D0                 assume cs:_text$mn
.text$mn:000045D0                 ;org 45D0h
.text$mn:000045D0 ; COMDAT (pick any)
.text$mn:000045D0                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text$mn:000045D0
.text$mn:000045D0 ; =============== S U B R O U T I N E =======================================
.text$mn:000045D0
.text$mn:000045D0 ; Attributes: bp-based frame
.text$mn:000045D0
.text$mn:000045D0 ; int __cdecl std::_Uninit_move<wchar_t *,wchar_t *,std::_Wrap_alloc<std::allocator<wchar_t>>>(void *Src, int, void *Dst, int)
.text$mn:000045D0                 public ??$_Uninit_move@PA_WPA_WU?$_Wrap_alloc@V?$allocator@_W@std@@@std@@@std@@YAPA_WPA_W00AAU?$_Wrap_alloc@V?$allocator@_W@std@@@0@@Z
.text$mn:000045D0 ??$_Uninit_move@PA_WPA_WU?$_Wrap_alloc@V?$allocator@_W@std@@@std@@@std@@YAPA_WPA_W00AAU?$_Wrap_alloc@V?$allocator@_W@std@@@0@@Z proc near
.text$mn:000045D0                                         ; CODE XREF: std::_Uninitialized_move<wchar_t *,wchar_t *,std::_Wrap_alloc<std::allocator<wchar_t>>>(wchar_t *,wchar_t *,wchar_t *,std::_Wrap_alloc<std::allocator<wchar_t>> &)+2Ep
.text$mn:000045D0
.text$mn:000045D0 var_1           = byte ptr -1
.text$mn:000045D0 Src             = dword ptr  8
.text$mn:000045D0 arg_4           = dword ptr  0Ch
.text$mn:000045D0 Dst             = dword ptr  10h
.text$mn:000045D0 arg_C           = dword ptr  14h
.text$mn:000045D0
.text$mn:000045D0                 push    ebp
.text$mn:000045D1                 mov     ebp, esp
.text$mn:000045D3                 push    ecx
.text$mn:000045D4                 mov     eax, [ebp+Dst]
.text$mn:000045D7                 push    eax
.text$mn:000045D8                 mov     ecx, [ebp+Src]
.text$mn:000045DB                 push    ecx
.text$mn:000045DC                 call    ??$_Ptr_cat@_W_W@std@@YA?AU_Scalar_ptr_iterator_tag@0@PA_W0@Z ; std::_Ptr_cat<wchar_t,wchar_t>(wchar_t *,wchar_t *)
.text$mn:000045E1                 add     esp, 8
.text$mn:000045E4                 mov     [ebp+var_1], al
.text$mn:000045E7                 movzx   edx, [ebp+var_1]
.text$mn:000045EB                 push    edx
.text$mn:000045EC                 mov     eax, [ebp+Src]
.text$mn:000045EF                 push    eax
.text$mn:000045F0                 call    ??$_Val_type@PA_W@std@@YAPA_WPA_W@Z ; std::_Val_type<wchar_t *>(wchar_t *)
.text$mn:000045F5                 add     esp, 4
.text$mn:000045F8                 push    eax
.text$mn:000045F9                 mov     ecx, [ebp+arg_C]
.text$mn:000045FC                 push    ecx
.text$mn:000045FD                 mov     edx, [ebp+Dst]
.text$mn:00004600                 push    edx             ; Dst
.text$mn:00004601                 mov     eax, [ebp+arg_4]
.text$mn:00004604                 push    eax             ; int
.text$mn:00004605                 mov     ecx, [ebp+Src]
.text$mn:00004608                 push    ecx             ; Src
.text$mn:00004609                 call    ??$_Uninit_move@_W_W_W@std@@YAPA_WPA_W00AAU?$_Wrap_alloc@V?$allocator@_W@std@@@0@0U_Scalar_ptr_iterator_tag@0@@Z ; std::_Uninit_move<wchar_t,wchar_t,wchar_t>(wchar_t *,wchar_t *,wchar_t *,std::_Wrap_alloc<std::allocator<wchar_t>> &,wchar_t *,std::_Scalar_ptr_iterator_tag)
.text$mn:0000460E                 add     esp, 18h
.text$mn:00004611                 mov     esp, ebp
.text$mn:00004613                 pop     ebp
.text$mn:00004614                 retn
.text$mn:00004614 ??$_Uninit_move@PA_WPA_WU?$_Wrap_alloc@V?$allocator@_W@std@@@std@@@std@@YAPA_WPA_W00AAU?$_Wrap_alloc@V?$allocator@_W@std@@@0@@Z endp
.text$mn:00004614
.text$mn:00004614 ; ---------------------------------------------------------------------------
.text$mn:00004615                 align 4
.text$mn:00004615 _text$mn        ends
.text$mn:00004615
.text$mn:00004618 ; ===========================================================================
.text$mn:00004618
.text$mn:00004618 ; Segment type: Pure code
.text$mn:00004618 ; Segment permissions: Read/Execute
.text$mn:00004618 _text$mn        segment para public 'CODE' use32
.text$mn:00004618                 assume cs:_text$mn
.text$mn:00004618                 ;org 4618h
.text$mn:00004618 ; COMDAT (pick any)
.text$mn:00004618                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text$mn:00004618
.text$mn:00004618 ; =============== S U B R O U T I N E =======================================
.text$mn:00004618
.text$mn:00004618 ; Attributes: bp-based frame
.text$mn:00004618
.text$mn:00004618 ; int __cdecl std::_Uninit_move<wchar_t,wchar_t,wchar_t>(void *Src, int, void *Dst)
.text$mn:00004618                 public ??$_Uninit_move@_W_W_W@std@@YAPA_WPA_W00AAU?$_Wrap_alloc@V?$allocator@_W@std@@@0@0U_Scalar_ptr_iterator_tag@0@@Z
.text$mn:00004618 ??$_Uninit_move@_W_W_W@std@@YAPA_WPA_W00AAU?$_Wrap_alloc@V?$allocator@_W@std@@@0@0U_Scalar_ptr_iterator_tag@0@@Z proc near
.text$mn:00004618                                         ; CODE XREF: std::_Uninit_move<wchar_t *,wchar_t *,std::_Wrap_alloc<std::allocator<wchar_t>>>(wchar_t *,wchar_t *,wchar_t *,std::_Wrap_alloc<std::allocator<wchar_t>> &)+39p
.text$mn:00004618
.text$mn:00004618 var_4           = dword ptr -4
.text$mn:00004618 Src             = dword ptr  8
.text$mn:00004618 arg_4           = dword ptr  0Ch
.text$mn:00004618 Dst             = dword ptr  10h
.text$mn:00004618
.text$mn:00004618                 push    ebp
.text$mn:00004619                 mov     ebp, esp
.text$mn:0000461B                 push    ecx
.text$mn:0000461C                 push    1D6h            ; unsigned int
.text$mn:00004621                 push    offset ??_C@_1IO@LKIDJAMC@?$AAC?$AA?3?$AA?2?$AAP?$AAr?$AAo?$AAg?$AAr?$AAa?$AAm?$AA?5?$AAF?$AAi?$AAl?$AAe?$AAs?$AA?5?$AA?$CI?$AAx?$AA8?$AA6?$AA?$CJ?$AA?2?$AAM?$AAi?$AAc?$AAr?$AAo?$AAs?$AAo?$AAf?$AAt@ ; "C:\\Program Files (x86)\\Microsoft Visu"...
.text$mn:00004626                 mov     eax, [ebp+arg_4]
.text$mn:00004629                 push    eax             ; int
.text$mn:0000462A                 mov     ecx, [ebp+Src]
.text$mn:0000462D                 push    ecx             ; int
.text$mn:0000462E                 call    ??$_Debug_range@PA_W@std@@YAXPA_W0PB_WI@Z ; std::_Debug_range<wchar_t *>(wchar_t *,wchar_t *,wchar_t const *,uint)
.text$mn:00004633                 add     esp, 10h
.text$mn:00004636                 push    1D7h            ; unsigned int
.text$mn:0000463B                 push    offset ??_C@_1IO@LKIDJAMC@?$AAC?$AA?3?$AA?2?$AAP?$AAr?$AAo?$AAg?$AAr?$AAa?$AAm?$AA?5?$AAF?$AAi?$AAl?$AAe?$AAs?$AA?5?$AA?$CI?$AAx?$AA8?$AA6?$AA?$CJ?$AA?2?$AAM?$AAi?$AAc?$AAr?$AAo?$AAs?$AAo?$AAf?$AAt@ ; "C:\\Program Files (x86)\\Microsoft Visu"...
.text$mn:00004640                 mov     edx, [ebp+Dst]
.text$mn:00004643                 push    edx             ; int
.text$mn:00004644                 call    ??$_Debug_pointer@_W@std@@YAXPA_WPB_WI@Z ; std::_Debug_pointer<wchar_t>(wchar_t *,wchar_t const *,uint)
.text$mn:00004649                 add     esp, 0Ch
.text$mn:0000464C                 mov     eax, [ebp+arg_4]
.text$mn:0000464F                 sub     eax, [ebp+Src]
.text$mn:00004652                 sar     eax, 1
.text$mn:00004654                 mov     [ebp+var_4], eax
.text$mn:00004657                 mov     ecx, [ebp+var_4]
.text$mn:0000465A                 shl     ecx, 1
.text$mn:0000465C                 push    ecx             ; Size
.text$mn:0000465D                 mov     edx, [ebp+Src]
.text$mn:00004660                 push    edx             ; Src
.text$mn:00004661                 mov     eax, [ebp+Dst]
.text$mn:00004664                 push    eax             ; Dst
.text$mn:00004665                 call    _memmove
.text$mn:0000466A                 add     esp, 0Ch
.text$mn:0000466D                 mov     ecx, [ebp+var_4]
.text$mn:00004670                 lea     eax, [eax+ecx*2]
.text$mn:00004673                 mov     esp, ebp
.text$mn:00004675                 pop     ebp
.text$mn:00004676                 retn
.text$mn:00004676 ??$_Uninit_move@_W_W_W@std@@YAPA_WPA_W00AAU?$_Wrap_alloc@V?$allocator@_W@std@@@0@0U_Scalar_ptr_iterator_tag@0@@Z endp
.text$mn:00004676
.text$mn:00004676 ; ---------------------------------------------------------------------------
.text$mn:00004677                 align 4
.text$mn:00004677 _text$mn        ends
.text$mn:00004677
.text$mn:00004678 ; ===========================================================================
.text$mn:00004678
.text$mn:00004678 ; Segment type: Pure code
.text$mn:00004678 ; Segment permissions: Read/Execute
.text$mn:00004678 _text$mn        segment para public 'CODE' use32
.text$mn:00004678                 assume cs:_text$mn
.text$mn:00004678                 ;org 4678h
.text$mn:00004678 ; COMDAT (pick any)
.text$mn:00004678                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text$mn:00004678
.text$mn:00004678 ; =============== S U B R O U T I N E =======================================
.text$mn:00004678
.text$mn:00004678 ; Attributes: bp-based frame
.text$mn:00004678
.text$mn:00004678 ; int __cdecl std::_Uninitialized_default_fill_n<char *,unsigned int,std::_Wrap_alloc<std::allocator<char>>>(char *Dst, size_t Size, int)
.text$mn:00004678                 public ??$_Uninitialized_default_fill_n@PADIU?$_Wrap_alloc@V?$allocator@D@std@@@std@@@std@@YAXPADIAAU?$_Wrap_alloc@V?$allocator@D@std@@@0@@Z
.text$mn:00004678 ??$_Uninitialized_default_fill_n@PADIU?$_Wrap_alloc@V?$allocator@D@std@@@std@@@std@@YAXPADIAAU?$_Wrap_alloc@V?$allocator@D@std@@@0@@Z proc near
.text$mn:00004678                                         ; CODE XREF: std::vector<char,std::allocator<char>>::vector<char,std::allocator<char>>(uint)+79p
.text$mn:00004678
.text$mn:00004678 var_1           = byte ptr -1
.text$mn:00004678 Dst             = dword ptr  8
.text$mn:00004678 Size            = dword ptr  0Ch
.text$mn:00004678 arg_8           = dword ptr  10h
.text$mn:00004678
.text$mn:00004678                 push    ebp
.text$mn:00004679                 mov     ebp, esp
.text$mn:0000467B                 push    ecx
.text$mn:0000467C                 mov     eax, [ebp+Dst]
.text$mn:0000467F                 push    eax
.text$mn:00004680                 mov     ecx, [ebp+Dst]
.text$mn:00004683                 push    ecx
.text$mn:00004684                 call    ??$_Ptr_cat@DD@std@@YA?AU_Scalar_ptr_iterator_tag@0@PAD0@Z ; std::_Ptr_cat<char,char>(char *,char *)
.text$mn:00004689                 add     esp, 8
.text$mn:0000468C                 mov     [ebp+var_1], al
.text$mn:0000468F                 movzx   edx, [ebp+var_1]
.text$mn:00004693                 push    edx
.text$mn:00004694                 mov     eax, [ebp+Dst]
.text$mn:00004697                 push    eax
.text$mn:00004698                 call    ??$_Val_type@PAD@std@@YAPADPAD@Z ; std::_Val_type<char *>(char *)
.text$mn:0000469D                 add     esp, 4
.text$mn:000046A0                 push    eax
.text$mn:000046A1                 mov     ecx, [ebp+arg_8]
.text$mn:000046A4                 push    ecx
.text$mn:000046A5                 mov     edx, [ebp+Size]
.text$mn:000046A8                 push    edx             ; Size
.text$mn:000046A9                 mov     eax, [ebp+Dst]
.text$mn:000046AC                 push    eax             ; Dst
.text$mn:000046AD                 call    ??$_Uninit_def_fill_n@DID@std@@YAXPADIAAU?$_Wrap_alloc@V?$allocator@D@std@@@0@0U_Scalar_ptr_iterator_tag@0@@Z ; std::_Uninit_def_fill_n<char,uint,char>(char *,uint,std::_Wrap_alloc<std::allocator<char>> &,char *,std::_Scalar_ptr_iterator_tag)
.text$mn:000046B2                 add     esp, 14h
.text$mn:000046B5                 mov     esp, ebp
.text$mn:000046B7                 pop     ebp
.text$mn:000046B8                 retn
.text$mn:000046B8 ??$_Uninitialized_default_fill_n@PADIU?$_Wrap_alloc@V?$allocator@D@std@@@std@@@std@@YAXPADIAAU?$_Wrap_alloc@V?$allocator@D@std@@@0@@Z endp
.text$mn:000046B8
.text$mn:000046B8 ; ---------------------------------------------------------------------------
.text$mn:000046B9                 align 4
.text$mn:000046B9 _text$mn        ends
.text$mn:000046B9
.text$mn:000046BC ; ===========================================================================
.text$mn:000046BC
.text$mn:000046BC ; Segment type: Pure code
.text$mn:000046BC ; Segment permissions: Read/Execute
.text$mn:000046BC _text$mn        segment para public 'CODE' use32
.text$mn:000046BC                 assume cs:_text$mn
.text$mn:000046BC                 ;org 46BCh
.text$mn:000046BC ; COMDAT (pick any)
.text$mn:000046BC                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text$mn:000046BC
.text$mn:000046BC ; =============== S U B R O U T I N E =======================================
.text$mn:000046BC
.text$mn:000046BC ; Attributes: bp-based frame
.text$mn:000046BC
.text$mn:000046BC ; void __cdecl std::_Uninitialized_default_fill_n<wchar_t *, unsigned int, struct std::_Wrap_alloc<class std::allocator<wchar_t>>>(wchar_t *, unsigned int, struct std::_Wrap_alloc<class std::allocator<wchar_t>> &)
.text$mn:000046BC                 public ??$_Uninitialized_default_fill_n@PA_WIU?$_Wrap_alloc@V?$allocator@_W@std@@@std@@@std@@YAXPA_WIAAU?$_Wrap_alloc@V?$allocator@_W@std@@@0@@Z
.text$mn:000046BC ??$_Uninitialized_default_fill_n@PA_WIU?$_Wrap_alloc@V?$allocator@_W@std@@@std@@@std@@YAXPA_WIAAU?$_Wrap_alloc@V?$allocator@_W@std@@@0@@Z proc near
.text$mn:000046BC                                         ; CODE XREF: std::vector<wchar_t,std::allocator<wchar_t>>::vector<wchar_t,std::allocator<wchar_t>>(uint)+79p
.text$mn:000046BC
.text$mn:000046BC var_1           = byte ptr -1
.text$mn:000046BC arg_0           = dword ptr  8
.text$mn:000046BC arg_4           = dword ptr  0Ch
.text$mn:000046BC arg_8           = dword ptr  10h
.text$mn:000046BC
.text$mn:000046BC                 push    ebp
.text$mn:000046BD                 mov     ebp, esp
.text$mn:000046BF                 push    ecx
.text$mn:000046C0                 mov     eax, [ebp+arg_0]
.text$mn:000046C3                 push    eax
.text$mn:000046C4                 mov     ecx, [ebp+arg_0]
.text$mn:000046C7                 push    ecx
.text$mn:000046C8                 call    ??$_Ptr_cat@_W_W@std@@YA?AU_Scalar_ptr_iterator_tag@0@PA_W0@Z ; std::_Ptr_cat<wchar_t,wchar_t>(wchar_t *,wchar_t *)
.text$mn:000046CD                 add     esp, 8
.text$mn:000046D0                 mov     [ebp+var_1], al
.text$mn:000046D3                 movzx   edx, [ebp+var_1]
.text$mn:000046D7                 push    edx
.text$mn:000046D8                 mov     eax, [ebp+arg_0]
.text$mn:000046DB                 push    eax
.text$mn:000046DC                 call    ??$_Val_type@PA_W@std@@YAPA_WPA_W@Z ; std::_Val_type<wchar_t *>(wchar_t *)
.text$mn:000046E1                 add     esp, 4
.text$mn:000046E4                 push    eax
.text$mn:000046E5                 mov     ecx, [ebp+arg_8]
.text$mn:000046E8                 push    ecx
.text$mn:000046E9                 mov     edx, [ebp+arg_4]
.text$mn:000046EC                 push    edx
.text$mn:000046ED                 mov     eax, [ebp+arg_0]
.text$mn:000046F0                 push    eax
.text$mn:000046F1                 call    ??$_Uninit_def_fill_n@_WI_W@std@@YAXPA_WIAAU?$_Wrap_alloc@V?$allocator@_W@std@@@0@0U_Scalar_ptr_iterator_tag@0@@Z ; std::_Uninit_def_fill_n<wchar_t,uint,wchar_t>(wchar_t *,uint,std::_Wrap_alloc<std::allocator<wchar_t>> &,wchar_t *,std::_Scalar_ptr_iterator_tag)
.text$mn:000046F6                 add     esp, 14h
.text$mn:000046F9                 mov     esp, ebp
.text$mn:000046FB                 pop     ebp
.text$mn:000046FC                 retn
.text$mn:000046FC ??$_Uninitialized_default_fill_n@PA_WIU?$_Wrap_alloc@V?$allocator@_W@std@@@std@@@std@@YAXPA_WIAAU?$_Wrap_alloc@V?$allocator@_W@std@@@0@@Z endp
.text$mn:000046FC
.text$mn:000046FC ; ---------------------------------------------------------------------------
.text$mn:000046FD                 align 10h
.text$mn:000046FD _text$mn        ends
.text$mn:000046FD
.text$mn:00004700 ; ===========================================================================
.text$mn:00004700
.text$mn:00004700 ; Segment type: Pure code
.text$mn:00004700 ; Segment permissions: Read/Execute
.text$mn:00004700 _text$mn        segment para public 'CODE' use32
.text$mn:00004700                 assume cs:_text$mn
.text$mn:00004700                 ;org 4700h
.text$mn:00004700 ; COMDAT (pick any)
.text$mn:00004700                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text$mn:00004700
.text$mn:00004700 ; =============== S U B R O U T I N E =======================================
.text$mn:00004700
.text$mn:00004700 ; Attributes: bp-based frame
.text$mn:00004700
.text$mn:00004700 ; class std::basic_string<wchar_t, struct std::char_traits<wchar_t>, class std::allocator<wchar_t>> * __cdecl std::_Uninitialized_move<class std::basic_string<wchar_t, struct std::char_traits<wchar_t>, class std::allocator<wchar_t>> *, class std::basic_string<wchar_t, struct std::char_traits<wchar_t>, class std::allocator<wchar_t>> *, struct std::_Wrap_alloc<class std::allocator<class std::basic_string<wchar_t, struct std::char_traits<wchar_t>, class std::allocator<wchar_t>>>>>(class std::basic_string<wchar_t, struct std::char_traits<wchar_t>, class std::allocator<wchar_t>> *, class std::basic_string<wchar_t, struct std::char_traits<wchar_t>, class std::allocator<wchar_t>> *, class std::basic_string<wchar_t, struct std::char_traits<wchar_t>, class std::allocator<wchar_t>> *, struct std::_Wrap_alloc<class std::allocator<class std::basic_string<wchar_t, struct std::char_traits<wchar_t>, class std::allocator<wchar_t>>>> &)
.text$mn:00004700                 public ??$_Uninitialized_move@PAV?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@PAV12@U?$_Wrap_alloc@V?$allocator@V?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@@std@@@2@@std@@YAPAV?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@0@PAV10@00AAU?$_Wrap_alloc@V?$allocator@V?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@@std@@@0@@Z
.text$mn:00004700 ??$_Uninitialized_move@PAV?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@PAV12@U?$_Wrap_alloc@V?$allocator@V?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@@std@@@2@@std@@YAPAV?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@0@PAV10@00AAU?$_Wrap_alloc@V?$allocator@V?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@@std@@@0@@Z proc near
.text$mn:00004700                                         ; CODE XREF: std::vector<std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>>,std::allocator<std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>>>>::_Umove<std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>> *>(std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>> *,std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>> *,std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>> *)+25p
.text$mn:00004700
.text$mn:00004700 arg_0           = dword ptr  8
.text$mn:00004700 arg_4           = dword ptr  0Ch
.text$mn:00004700 arg_8           = dword ptr  10h
.text$mn:00004700 arg_C           = dword ptr  14h
.text$mn:00004700
.text$mn:00004700                 push    ebp
.text$mn:00004701                 mov     ebp, esp
.text$mn:00004703                 mov     eax, [ebp+arg_C]
.text$mn:00004706                 push    eax             ; int
.text$mn:00004707                 mov     ecx, [ebp+arg_8]
.text$mn:0000470A                 push    ecx
.text$mn:0000470B                 call    ??$_Unchecked@PAV?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@@std@@YAPAV?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@0@PAV10@@Z ; std::_Unchecked<std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>> *>(std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>> *)
.text$mn:00004710                 add     esp, 4
.text$mn:00004713                 push    eax             ; void *
.text$mn:00004714                 mov     edx, [ebp+arg_4]
.text$mn:00004717                 push    edx
.text$mn:00004718                 call    ??$_Unchecked@PAV?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@@std@@YAPAV?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@0@PAV10@@Z ; std::_Unchecked<std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>> *>(std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>> *)
.text$mn:0000471D                 add     esp, 4
.text$mn:00004720                 push    eax             ; int
.text$mn:00004721                 mov     eax, [ebp+arg_0]
.text$mn:00004724                 push    eax
.text$mn:00004725                 call    ??$_Unchecked@PAV?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@@std@@YAPAV?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@0@PAV10@@Z ; std::_Unchecked<std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>> *>(std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>> *)
.text$mn:0000472A                 add     esp, 4
.text$mn:0000472D                 push    eax             ; int
.text$mn:0000472E                 call    ??$_Uninit_move@PAV?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@PAV12@U?$_Wrap_alloc@V?$allocator@V?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@@std@@@2@@std@@YAPAV?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@0@PAV10@00AAU?$_Wrap_alloc@V?$allocator@V?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@@std@@@0@@Z ; std::_Uninit_move<std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>> *,std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>> *,std::_Wrap_alloc<std::allocator<std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>>>>>(std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>> *,std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>> *,std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>> *,std::_Wrap_alloc<std::allocator<std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>>>> &)
.text$mn:00004733                 add     esp, 10h
.text$mn:00004736                 push    eax
.text$mn:00004737                 lea     ecx, [ebp+arg_8]
.text$mn:0000473A                 push    ecx
.text$mn:0000473B                 call    ??$_Rechecked@PAV?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@PAV12@@std@@YAAAPAV?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@0@AAPAV10@PAV10@@Z ; std::_Rechecked<std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>> *,std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>> *>(std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>> * &,std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>> *)
.text$mn:00004740                 add     esp, 8
.text$mn:00004743                 mov     eax, [eax]
.text$mn:00004745                 pop     ebp
.text$mn:00004746                 retn
.text$mn:00004746 ??$_Uninitialized_move@PAV?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@PAV12@U?$_Wrap_alloc@V?$allocator@V?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@@std@@@2@@std@@YAPAV?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@0@PAV10@00AAU?$_Wrap_alloc@V?$allocator@V?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@@std@@@0@@Z endp
.text$mn:00004746
.text$mn:00004746 ; ---------------------------------------------------------------------------
.text$mn:00004747                 align 4
.text$mn:00004747 _text$mn        ends
.text$mn:00004747
.text$mn:00004748 ; ===========================================================================
.text$mn:00004748
.text$mn:00004748 ; Segment type: Pure code
.text$mn:00004748 ; Segment permissions: Read/Execute
.text$mn:00004748 _text$mn        segment para public 'CODE' use32
.text$mn:00004748                 assume cs:_text$mn
.text$mn:00004748                 ;org 4748h
.text$mn:00004748 ; COMDAT (pick any)
.text$mn:00004748                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text$mn:00004748
.text$mn:00004748 ; =============== S U B R O U T I N E =======================================
.text$mn:00004748
.text$mn:00004748 ; Attributes: bp-based frame
.text$mn:00004748
.text$mn:00004748 ; wchar_t * __cdecl std::_Uninitialized_move<wchar_t *, wchar_t *, struct std::_Wrap_alloc<class std::allocator<wchar_t>>>(wchar_t *, wchar_t *, wchar_t *, struct std::_Wrap_alloc<class std::allocator<wchar_t>> &)
.text$mn:00004748                 public ??$_Uninitialized_move@PA_WPA_WU?$_Wrap_alloc@V?$allocator@_W@std@@@std@@@std@@YAPA_WPA_W00AAU?$_Wrap_alloc@V?$allocator@_W@std@@@0@@Z
.text$mn:00004748 ??$_Uninitialized_move@PA_WPA_WU?$_Wrap_alloc@V?$allocator@_W@std@@@std@@@std@@YAPA_WPA_W00AAU?$_Wrap_alloc@V?$allocator@_W@std@@@0@@Z proc near
.text$mn:00004748                                         ; CODE XREF: std::vector<wchar_t,std::allocator<wchar_t>>::_Umove<wchar_t *>(wchar_t *,wchar_t *,wchar_t *)+25p
.text$mn:00004748
.text$mn:00004748 arg_0           = dword ptr  8
.text$mn:00004748 arg_4           = dword ptr  0Ch
.text$mn:00004748 arg_8           = dword ptr  10h
.text$mn:00004748 arg_C           = dword ptr  14h
.text$mn:00004748
.text$mn:00004748                 push    ebp
.text$mn:00004749                 mov     ebp, esp
.text$mn:0000474B                 mov     eax, [ebp+arg_C]
.text$mn:0000474E                 push    eax             ; int
.text$mn:0000474F                 mov     ecx, [ebp+arg_8]
.text$mn:00004752                 push    ecx
.text$mn:00004753                 call    ??$_Unchecked@PA_W@std@@YAPA_WPA_W@Z ; std::_Unchecked<wchar_t *>(wchar_t *)
.text$mn:00004758                 add     esp, 4
.text$mn:0000475B                 push    eax             ; Dst
.text$mn:0000475C                 mov     edx, [ebp+arg_4]
.text$mn:0000475F                 push    edx
.text$mn:00004760                 call    ??$_Unchecked@PA_W@std@@YAPA_WPA_W@Z ; std::_Unchecked<wchar_t *>(wchar_t *)
.text$mn:00004765                 add     esp, 4
.text$mn:00004768                 push    eax             ; int
.text$mn:00004769                 mov     eax, [ebp+arg_0]
.text$mn:0000476C                 push    eax
.text$mn:0000476D                 call    ??$_Unchecked@PA_W@std@@YAPA_WPA_W@Z ; std::_Unchecked<wchar_t *>(wchar_t *)
.text$mn:00004772                 add     esp, 4
.text$mn:00004775                 push    eax             ; Src
.text$mn:00004776                 call    ??$_Uninit_move@PA_WPA_WU?$_Wrap_alloc@V?$allocator@_W@std@@@std@@@std@@YAPA_WPA_W00AAU?$_Wrap_alloc@V?$allocator@_W@std@@@0@@Z ; std::_Uninit_move<wchar_t *,wchar_t *,std::_Wrap_alloc<std::allocator<wchar_t>>>(wchar_t *,wchar_t *,wchar_t *,std::_Wrap_alloc<std::allocator<wchar_t>> &)
.text$mn:0000477B                 add     esp, 10h
.text$mn:0000477E                 push    eax
.text$mn:0000477F                 lea     ecx, [ebp+arg_8]
.text$mn:00004782                 push    ecx
.text$mn:00004783                 call    ??$_Rechecked@PA_WPA_W@std@@YAAAPA_WAAPA_WPA_W@Z ; std::_Rechecked<wchar_t *,wchar_t *>(wchar_t * &,wchar_t *)
.text$mn:00004788                 add     esp, 8
.text$mn:0000478B                 mov     eax, [eax]
.text$mn:0000478D                 pop     ebp
.text$mn:0000478E                 retn
.text$mn:0000478E ??$_Uninitialized_move@PA_WPA_WU?$_Wrap_alloc@V?$allocator@_W@std@@@std@@@std@@YAPA_WPA_W00AAU?$_Wrap_alloc@V?$allocator@_W@std@@@0@@Z endp
.text$mn:0000478E
.text$mn:0000478E ; ---------------------------------------------------------------------------
.text$mn:0000478F                 align 10h
.text$mn:0000478F _text$mn        ends
.text$mn:0000478F
.text$mn:00004790 ; ===========================================================================
.text$mn:00004790
.text$mn:00004790 ; Segment type: Pure code
.text$mn:00004790 ; Segment permissions: Read/Execute
.text$mn:00004790 _text$mn        segment para public 'CODE' use32
.text$mn:00004790                 assume cs:_text$mn
.text$mn:00004790                 ;org 4790h
.text$mn:00004790 ; COMDAT (pick any)
.text$mn:00004790                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text$mn:00004790
.text$mn:00004790 ; =============== S U B R O U T I N E =======================================
.text$mn:00004790
.text$mn:00004790 ; Attributes: bp-based frame
.text$mn:00004790
.text$mn:00004790 ; char * __cdecl std::_Val_type<char *>(char *)
.text$mn:00004790                 public ??$_Val_type@PAD@std@@YAPADPAD@Z
.text$mn:00004790 ??$_Val_type@PAD@std@@YAPADPAD@Z proc near
.text$mn:00004790                                         ; CODE XREF: std::_Uninitialized_default_fill_n<char *,uint,std::_Wrap_alloc<std::allocator<char>>>(char *,uint,std::_Wrap_alloc<std::allocator<char>> &)+20p
.text$mn:00004790                 push    ebp
.text$mn:00004791                 mov     ebp, esp
.text$mn:00004793                 xor     eax, eax
.text$mn:00004795                 pop     ebp
.text$mn:00004796                 retn
.text$mn:00004796 ??$_Val_type@PAD@std@@YAPADPAD@Z endp
.text$mn:00004796
.text$mn:00004796 ; ---------------------------------------------------------------------------
.text$mn:00004797                 align 4
.text$mn:00004797 _text$mn        ends
.text$mn:00004797
.text$mn:00004798 ; ===========================================================================
.text$mn:00004798
.text$mn:00004798 ; Segment type: Pure code
.text$mn:00004798 ; Segment permissions: Read/Execute
.text$mn:00004798 _text$mn        segment para public 'CODE' use32
.text$mn:00004798                 assume cs:_text$mn
.text$mn:00004798                 ;org 4798h
.text$mn:00004798 ; COMDAT (pick any)
.text$mn:00004798                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text$mn:00004798
.text$mn:00004798 ; =============== S U B R O U T I N E =======================================
.text$mn:00004798
.text$mn:00004798 ; Attributes: bp-based frame
.text$mn:00004798
.text$mn:00004798 ; class std::basic_string<wchar_t, struct std::char_traits<wchar_t>, class std::allocator<wchar_t>> * __cdecl std::_Val_type<class std::basic_string<wchar_t, struct std::char_traits<wchar_t>, class std::allocator<wchar_t>> *>(class std::basic_string<wchar_t, struct std::char_traits<wchar_t>, class std::allocator<wchar_t>> *)
.text$mn:00004798                 public ??$_Val_type@PAV?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@@std@@YAPAV?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@0@PAV10@@Z
.text$mn:00004798 ??$_Val_type@PAV?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@@std@@YAPAV?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@0@PAV10@@Z proc near
.text$mn:00004798                                         ; CODE XREF: std::_Uninit_move<std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>> *,std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>> *,std::_Wrap_alloc<std::allocator<std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>>>>>(std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>> *,std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>> *,std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>> *,std::_Wrap_alloc<std::allocator<std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>>>> &)+20p
.text$mn:00004798                 push    ebp
.text$mn:00004799                 mov     ebp, esp
.text$mn:0000479B                 xor     eax, eax
.text$mn:0000479D                 pop     ebp
.text$mn:0000479E                 retn
.text$mn:0000479E ??$_Val_type@PAV?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@@std@@YAPAV?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@0@PAV10@@Z endp
.text$mn:0000479E
.text$mn:0000479E ; ---------------------------------------------------------------------------
.text$mn:0000479F                 align 10h
.text$mn:0000479F _text$mn        ends
.text$mn:0000479F
.text$mn:000047A0 ; ===========================================================================
.text$mn:000047A0
.text$mn:000047A0 ; Segment type: Pure code
.text$mn:000047A0 ; Segment permissions: Read/Execute
.text$mn:000047A0 _text$mn        segment para public 'CODE' use32
.text$mn:000047A0                 assume cs:_text$mn
.text$mn:000047A0                 ;org 47A0h
.text$mn:000047A0 ; COMDAT (pick any)
.text$mn:000047A0                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text$mn:000047A0
.text$mn:000047A0 ; =============== S U B R O U T I N E =======================================
.text$mn:000047A0
.text$mn:000047A0 ; Attributes: bp-based frame
.text$mn:000047A0
.text$mn:000047A0 ; wchar_t * __cdecl std::_Val_type<wchar_t *>(wchar_t *)
.text$mn:000047A0                 public ??$_Val_type@PA_W@std@@YAPA_WPA_W@Z
.text$mn:000047A0 ??$_Val_type@PA_W@std@@YAPA_WPA_W@Z proc near
.text$mn:000047A0                                         ; CODE XREF: std::_Uninit_move<wchar_t *,wchar_t *,std::_Wrap_alloc<std::allocator<wchar_t>>>(wchar_t *,wchar_t *,wchar_t *,std::_Wrap_alloc<std::allocator<wchar_t>> &)+20p
.text$mn:000047A0                                         ; std::_Uninitialized_default_fill_n<wchar_t *,uint,std::_Wrap_alloc<std::allocator<wchar_t>>>(wchar_t *,uint,std::_Wrap_alloc<std::allocator<wchar_t>> &)+20p
.text$mn:000047A0                 push    ebp
.text$mn:000047A1                 mov     ebp, esp
.text$mn:000047A3                 xor     eax, eax
.text$mn:000047A5                 pop     ebp
.text$mn:000047A6                 retn
.text$mn:000047A6 ??$_Val_type@PA_W@std@@YAPA_WPA_W@Z endp
.text$mn:000047A6
.text$mn:000047A6 ; ---------------------------------------------------------------------------
.text$mn:000047A7                 align 4
.text$mn:000047A7 _text$mn        ends
.text$mn:000047A7
.text$mn:000047A8 ; ===========================================================================
.text$mn:000047A8
.text$mn:000047A8 ; Segment type: Pure code
.text$mn:000047A8 ; Segment permissions: Read/Execute
.text$mn:000047A8 _text$mn        segment para public 'CODE' use32
.text$mn:000047A8                 assume cs:_text$mn
.text$mn:000047A8                 ;org 47A8h
.text$mn:000047A8 ; COMDAT (pick any)
.text$mn:000047A8                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text$mn:000047A8
.text$mn:000047A8 ; =============== S U B R O U T I N E =======================================
.text$mn:000047A8
.text$mn:000047A8 ; Attributes: bp-based frame
.text$mn:000047A8
.text$mn:000047A8 ; char * __cdecl std::addressof<char>(char &)
.text$mn:000047A8                 public ??$addressof@D@std@@YAPADAAD@Z
.text$mn:000047A8 ??$addressof@D@std@@YAPADAAD@Z proc near
.text$mn:000047A8                                         ; CODE XREF: std::_String_val<std::_Simple_types<char>>::_Myptr(void)+19p
.text$mn:000047A8                                         ; std::_String_val<std::_Simple_types<char>>::_Myptr(void)+19p ...
.text$mn:000047A8
.text$mn:000047A8 arg_0           = dword ptr  8
.text$mn:000047A8
.text$mn:000047A8                 push    ebp
.text$mn:000047A9                 mov     ebp, esp
.text$mn:000047AB                 mov     eax, [ebp+arg_0]
.text$mn:000047AE                 pop     ebp
.text$mn:000047AF                 retn
.text$mn:000047AF ??$addressof@D@std@@YAPADAAD@Z endp
.text$mn:000047AF
.text$mn:000047AF _text$mn        ends
.text$mn:000047AF
.text$mn:000047B0 ; ===========================================================================
.text$mn:000047B0
.text$mn:000047B0 ; Segment type: Pure code
.text$mn:000047B0 ; Segment permissions: Read/Execute
.text$mn:000047B0 _text$mn        segment para public 'CODE' use32
.text$mn:000047B0                 assume cs:_text$mn
.text$mn:000047B0                 ;org 47B0h
.text$mn:000047B0 ; COMDAT (pick any)
.text$mn:000047B0                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text$mn:000047B0
.text$mn:000047B0 ; =============== S U B R O U T I N E =======================================
.text$mn:000047B0
.text$mn:000047B0 ; Attributes: bp-based frame
.text$mn:000047B0
.text$mn:000047B0 ; class std::basic_string<wchar_t, struct std::char_traits<wchar_t>, class std::allocator<wchar_t>> * __cdecl std::addressof<class std::basic_string<wchar_t, struct std::char_traits<wchar_t>, class std::allocator<wchar_t>>>(class std::basic_string<wchar_t, struct std::char_traits<wchar_t>, class std::allocator<wchar_t>> &)
.text$mn:000047B0                 public ??$addressof@V?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@@std@@YAPAV?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@0@AAV10@@Z
.text$mn:000047B0 ??$addressof@V?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@@std@@YAPAV?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@0@AAV10@@Z proc near
.text$mn:000047B0                                         ; CODE XREF: std::vector<std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>>,std::allocator<std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>>>>::push_back(std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>> &&)+Dp
.text$mn:000047B0                                         ; std::vector<std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>>,std::allocator<std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>>>>::push_back(std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>> &&)+2Dp
.text$mn:000047B0
.text$mn:000047B0 arg_0           = dword ptr  8
.text$mn:000047B0
.text$mn:000047B0                 push    ebp
.text$mn:000047B1                 mov     ebp, esp
.text$mn:000047B3                 mov     eax, [ebp+arg_0]
.text$mn:000047B6                 pop     ebp
.text$mn:000047B7                 retn
.text$mn:000047B7 ??$addressof@V?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@@std@@YAPAV?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@0@AAV10@@Z endp
.text$mn:000047B7
.text$mn:000047B7 _text$mn        ends
.text$mn:000047B7
.text$mn:000047B8 ; ===========================================================================
.text$mn:000047B8
.text$mn:000047B8 ; Segment type: Pure code
.text$mn:000047B8 ; Segment permissions: Read/Execute
.text$mn:000047B8 _text$mn        segment para public 'CODE' use32
.text$mn:000047B8                 assume cs:_text$mn
.text$mn:000047B8                 ;org 47B8h
.text$mn:000047B8 ; COMDAT (pick any)
.text$mn:000047B8                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text$mn:000047B8
.text$mn:000047B8 ; =============== S U B R O U T I N E =======================================
.text$mn:000047B8
.text$mn:000047B8 ; Attributes: bp-based frame
.text$mn:000047B8
.text$mn:000047B8 ; wchar_t * __cdecl std::addressof<wchar_t>(wchar_t &)
.text$mn:000047B8                 public ??$addressof@_W@std@@YAPA_WAA_W@Z
.text$mn:000047B8 ??$addressof@_W@std@@YAPA_WAA_W@Z proc near
.text$mn:000047B8                                         ; CODE XREF: std::_String_val<std::_Simple_types<wchar_t>>::_Myptr(void)+19p
.text$mn:000047B8                                         ; std::_String_val<std::_Simple_types<wchar_t>>::_Myptr(void)+19p ...
.text$mn:000047B8
.text$mn:000047B8 arg_0           = dword ptr  8
.text$mn:000047B8
.text$mn:000047B8                 push    ebp
.text$mn:000047B9                 mov     ebp, esp
.text$mn:000047BB                 mov     eax, [ebp+arg_0]
.text$mn:000047BE                 pop     ebp
.text$mn:000047BF                 retn
.text$mn:000047BF ??$addressof@_W@std@@YAPA_WAA_W@Z endp
.text$mn:000047BF
.text$mn:000047BF _text$mn        ends
.text$mn:000047BF
.text$mn:000047C0 ; ===========================================================================
.text$mn:000047C0
.text$mn:000047C0 ; Segment type: Pure code
.text$mn:000047C0 ; Segment permissions: Read/Execute
.text$mn:000047C0 _text$mn        segment para public 'CODE' use32
.text$mn:000047C0                 assume cs:_text$mn
.text$mn:000047C0                 ;org 47C0h
.text$mn:000047C0 ; COMDAT (pick any)
.text$mn:000047C0                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text$mn:000047C0
.text$mn:000047C0 ; =============== S U B R O U T I N E =======================================
.text$mn:000047C0
.text$mn:000047C0 ; Attributes: bp-based frame
.text$mn:000047C0
.text$mn:000047C0 ; int __stdcall std::_Wrap_alloc<std::allocator<char>>::construct<char *,char * &>(void *, int)
.text$mn:000047C0                 public ??$construct@PADAAPAD@?$_Wrap_alloc@V?$allocator@D@std@@@std@@QAEXPAPADAAPAD@Z
.text$mn:000047C0 ??$construct@PADAAPAD@?$_Wrap_alloc@V?$allocator@D@std@@@std@@QAEXPAPADAAPAD@Z proc near
.text$mn:000047C0                                         ; CODE XREF: std::basic_string<char,std::char_traits<char>,std::allocator<char>>::_Assign_rv(std::basic_string<char,std::char_traits<char>,std::allocator<char>> &&)+50p
.text$mn:000047C0                                         ; $LN19+4Bp
.text$mn:000047C0
.text$mn:000047C0 var_4           = dword ptr -4
.text$mn:000047C0 arg_0           = dword ptr  8
.text$mn:000047C0 arg_4           = dword ptr  0Ch
.text$mn:000047C0
.text$mn:000047C0                 push    ebp
.text$mn:000047C1                 mov     ebp, esp
.text$mn:000047C3                 push    ecx
.text$mn:000047C4                 mov     [ebp+var_4], ecx
.text$mn:000047C7                 mov     eax, [ebp+arg_4]
.text$mn:000047CA                 push    eax
.text$mn:000047CB                 call    ??$forward@AAPAD@std@@YAAAPADAAPAD@Z ; std::forward<char * &>(char * &)
.text$mn:000047D0                 add     esp, 4
.text$mn:000047D3                 push    eax             ; int
.text$mn:000047D4                 mov     ecx, [ebp+arg_0]
.text$mn:000047D7                 push    ecx             ; void *
.text$mn:000047D8                 mov     edx, [ebp+var_4]
.text$mn:000047DB                 push    edx             ; int
.text$mn:000047DC                 call    ??$construct@PADAAPAD@?$allocator_traits@V?$allocator@D@std@@@std@@SAXAAV?$allocator@D@1@PAPADAAPAD@Z ; std::allocator_traits<std::allocator<char>>::construct<char *,char * &>(std::allocator<char> &,char * *,char * &)
.text$mn:000047E1                 add     esp, 0Ch
.text$mn:000047E4                 mov     esp, ebp
.text$mn:000047E6                 pop     ebp
.text$mn:000047E7                 retn    8
.text$mn:000047E7 ??$construct@PADAAPAD@?$_Wrap_alloc@V?$allocator@D@std@@@std@@QAEXPAPADAAPAD@Z endp
.text$mn:000047E7
.text$mn:000047E7 ; ---------------------------------------------------------------------------
.text$mn:000047EA                 align 4
.text$mn:000047EA _text$mn        ends
.text$mn:000047EA
.text$mn:000047EC ; ===========================================================================
.text$mn:000047EC
.text$mn:000047EC ; Segment type: Pure code
.text$mn:000047EC ; Segment permissions: Read/Execute
.text$mn:000047EC _text$mn        segment para public 'CODE' use32
.text$mn:000047EC                 assume cs:_text$mn
.text$mn:000047EC                 ;org 47ECh
.text$mn:000047EC ; COMDAT (pick any)
.text$mn:000047EC                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text$mn:000047EC
.text$mn:000047EC ; =============== S U B R O U T I N E =======================================
.text$mn:000047EC
.text$mn:000047EC ; Attributes: bp-based frame
.text$mn:000047EC
.text$mn:000047EC ; int __stdcall std::allocator<char>::construct<char *,char * &>(void *, int)
.text$mn:000047EC                 public ??$construct@PADAAPAD@?$allocator@D@std@@QAEXPAPADAAPAD@Z
.text$mn:000047EC ??$construct@PADAAPAD@?$allocator@D@std@@QAEXPAPADAAPAD@Z proc near
.text$mn:000047EC                                         ; CODE XREF: std::allocator_traits<std::allocator<char>>::construct<char *,char * &>(std::allocator<char> &,char * *,char * &)+17p
.text$mn:000047EC
.text$mn:000047EC var_1C          = dword ptr -1Ch
.text$mn:000047EC var_18          = dword ptr -18h
.text$mn:000047EC var_14          = dword ptr -14h
.text$mn:000047EC var_10          = dword ptr -10h
.text$mn:000047EC var_C           = dword ptr -0Ch
.text$mn:000047EC var_4           = dword ptr -4
.text$mn:000047EC arg_0           = dword ptr  8
.text$mn:000047EC arg_4           = dword ptr  0Ch
.text$mn:000047EC
.text$mn:000047EC                 push    ebp
.text$mn:000047ED                 mov     ebp, esp
.text$mn:000047EF                 push    0FFFFFFFFh
.text$mn:000047F1                 push    offset __ehhandler$??$construct@PADAAPAD@?$allocator@D@std@@QAEXPAPADAAPAD@Z
.text$mn:000047F6                 mov     eax, large fs:0
.text$mn:000047FC                 push    eax
.text$mn:000047FD                 sub     esp, 10h
.text$mn:00004800                 mov     eax, dword ptr ds:___security_cookie
.text$mn:00004805                 xor     eax, ebp
.text$mn:00004807                 push    eax
.text$mn:00004808                 lea     eax, [ebp+var_C]
.text$mn:0000480B                 mov     large fs:0, eax
.text$mn:00004811                 mov     [ebp+var_18], ecx
.text$mn:00004814                 mov     eax, [ebp+arg_0]
.text$mn:00004817                 push    eax             ; void *
.text$mn:00004818                 push    4               ; unsigned int
.text$mn:0000481A                 call    ??2@YAPAXIPAX@Z ; operator new(uint,void *)
.text$mn:0000481F                 add     esp, 8
.text$mn:00004822                 mov     [ebp+var_10], eax
.text$mn:00004825                 mov     [ebp+var_4], 0
.text$mn:0000482C                 cmp     [ebp+var_10], 0
.text$mn:00004830                 jz      short loc_484D
.text$mn:00004832                 mov     ecx, [ebp+arg_4]
.text$mn:00004835                 push    ecx
.text$mn:00004836                 call    ??$forward@AAPAD@std@@YAAAPADAAPAD@Z ; std::forward<char * &>(char * &)
.text$mn:0000483B                 add     esp, 4
.text$mn:0000483E                 mov     edx, [ebp+var_10]
.text$mn:00004841                 mov     eax, [eax]
.text$mn:00004843                 mov     [edx], eax
.text$mn:00004845                 mov     ecx, [ebp+var_10]
.text$mn:00004848                 mov     [ebp+var_14], ecx
.text$mn:0000484B                 jmp     short loc_4854
.text$mn:0000484D ; ---------------------------------------------------------------------------
.text$mn:0000484D
.text$mn:0000484D loc_484D:                               ; CODE XREF: std::allocator<char>::construct<char *,char * &>(char * *,char * &)+44j
.text$mn:0000484D                 mov     [ebp+var_14], 0
.text$mn:00004854
.text$mn:00004854 loc_4854:                               ; CODE XREF: std::allocator<char>::construct<char *,char * &>(char * *,char * &)+5Fj
.text$mn:00004854                 mov     edx, [ebp+var_14]
.text$mn:00004857                 mov     [ebp+var_1C], edx
.text$mn:0000485A                 mov     [ebp+var_4], 0FFFFFFFFh
.text$mn:00004861                 mov     ecx, [ebp+var_C]
.text$mn:00004864                 mov     large fs:0, ecx
.text$mn:0000486B                 pop     ecx
.text$mn:0000486C                 mov     esp, ebp
.text$mn:0000486E                 pop     ebp
.text$mn:0000486F                 retn    8
.text$mn:0000486F ??$construct@PADAAPAD@?$allocator@D@std@@QAEXPAPADAAPAD@Z endp
.text$mn:0000486F
.text$mn:0000486F ; ---------------------------------------------------------------------------
.text$mn:00004872                 align 4
.text$mn:00004872 _text$mn        ends
.text$mn:00004872
.text$x:00004874 ; ===========================================================================
.text$x:00004874
.text$x:00004874 ; Segment type: Pure code
.text$x:00004874 ; Segment permissions: Read/Execute
.text$x:00004874 _text$x         segment para public 'CODE' use32
.text$x:00004874                 assume cs:_text$x
.text$x:00004874                 ;org 4874h
.text$x:00004874 ; COMDAT (pick associative to section at 47EC)
.text$x:00004874                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text$x:00004874
.text$x:00004874 ; =============== S U B R O U T I N E =======================================
.text$x:00004874
.text$x:00004874
.text$x:00004874 __unwindfunclet$??$construct@PADAAPAD@?$allocator@D@std@@QAEXPAPADAAPAD@Z$0 proc near
.text$x:00004874                                         ; DATA XREF: .xdata$x:0000F0CCo
.text$x:00004874                 mov     eax, [ebp+8]
.text$x:00004877                 push    eax
.text$x:00004878                 mov     eax, [ebp-10h]
.text$x:0000487B                 push    eax             ; void *
.text$x:0000487C                 call    ??3@YAXPAX0@Z   ; operator delete(void *,void *)
.text$x:00004881                 add     esp, 8
.text$x:00004884                 retn
.text$x:00004884 __unwindfunclet$??$construct@PADAAPAD@?$allocator@D@std@@QAEXPAPADAAPAD@Z$0 endp
.text$x:00004884
.text$x:00004885
.text$x:00004885 ; =============== S U B R O U T I N E =======================================
.text$x:00004885
.text$x:00004885
.text$x:00004885 __ehhandler$??$construct@PADAAPAD@?$allocator@D@std@@QAEXPAPADAAPAD@Z proc near
.text$x:00004885                                         ; DATA XREF: std::allocator<char>::construct<char *,char * &>(char * *,char * &)+5o
.text$x:00004885
.text$x:00004885 arg_4           = dword ptr  8
.text$x:00004885
.text$x:00004885                 mov     edx, [esp+arg_4]
.text$x:00004889                 lea     eax, [edx+0Ch]
.text$x:0000488C                 mov     ecx, [edx-14h]
.text$x:0000488F                 xor     ecx, eax
.text$x:00004891                 call    @__security_check_cookie@4 ; __security_check_cookie(x)
.text$x:00004896                 mov     eax, offset __ehfuncinfo$??$construct@PADAAPAD@?$allocator@D@std@@QAEXPAPADAAPAD@Z
.text$x:0000489B                 jmp     ___CxxFrameHandler3
.text$x:0000489B __ehhandler$??$construct@PADAAPAD@?$allocator@D@std@@QAEXPAPADAAPAD@Z endp
.text$x:0000489B
.text$x:0000489B _text$x         ends
.text$x:0000489B
.text$mn:000048A0 ; ===========================================================================
.text$mn:000048A0
.text$mn:000048A0 ; Segment type: Pure code
.text$mn:000048A0 ; Segment permissions: Read/Execute
.text$mn:000048A0 _text$mn        segment para public 'CODE' use32
.text$mn:000048A0                 assume cs:_text$mn
.text$mn:000048A0                 ;org 48A0h
.text$mn:000048A0 ; COMDAT (pick any)
.text$mn:000048A0                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text$mn:000048A0
.text$mn:000048A0 ; =============== S U B R O U T I N E =======================================
.text$mn:000048A0
.text$mn:000048A0 ; Attributes: bp-based frame
.text$mn:000048A0
.text$mn:000048A0 ; int __cdecl std::allocator_traits<std::allocator<char>>::construct<char *,char * &>(int, void *, int)
.text$mn:000048A0                 public ??$construct@PADAAPAD@?$allocator_traits@V?$allocator@D@std@@@std@@SAXAAV?$allocator@D@1@PAPADAAPAD@Z
.text$mn:000048A0 ??$construct@PADAAPAD@?$allocator_traits@V?$allocator@D@std@@@std@@SAXAAV?$allocator@D@1@PAPADAAPAD@Z proc near
.text$mn:000048A0                                         ; CODE XREF: std::_Wrap_alloc<std::allocator<char>>::construct<char *,char * &>(char * *,char * &)+1Cp
.text$mn:000048A0
.text$mn:000048A0 arg_0           = dword ptr  8
.text$mn:000048A0 arg_4           = dword ptr  0Ch
.text$mn:000048A0 arg_8           = dword ptr  10h
.text$mn:000048A0
.text$mn:000048A0                 push    ebp
.text$mn:000048A1                 mov     ebp, esp
.text$mn:000048A3                 mov     eax, [ebp+arg_8]
.text$mn:000048A6                 push    eax
.text$mn:000048A7                 call    ??$forward@AAPAD@std@@YAAAPADAAPAD@Z ; std::forward<char * &>(char * &)
.text$mn:000048AC                 add     esp, 4
.text$mn:000048AF                 push    eax             ; int
.text$mn:000048B0                 mov     ecx, [ebp+arg_4]
.text$mn:000048B3                 push    ecx             ; void *
.text$mn:000048B4                 mov     ecx, [ebp+arg_0]
.text$mn:000048B7                 call    ??$construct@PADAAPAD@?$allocator@D@std@@QAEXPAPADAAPAD@Z ; std::allocator<char>::construct<char *,char * &>(char * *,char * &)
.text$mn:000048BC                 pop     ebp
.text$mn:000048BD                 retn
.text$mn:000048BD ??$construct@PADAAPAD@?$allocator_traits@V?$allocator@D@std@@@std@@SAXAAV?$allocator@D@1@PAPADAAPAD@Z endp
.text$mn:000048BD
.text$mn:000048BD ; ---------------------------------------------------------------------------
.text$mn:000048BE                 align 10h
.text$mn:000048BE _text$mn        ends
.text$mn:000048BE
.text$mn:000048C0 ; ===========================================================================
.text$mn:000048C0
.text$mn:000048C0 ; Segment type: Pure code
.text$mn:000048C0 ; Segment permissions: Read/Execute
.text$mn:000048C0 _text$mn        segment para public 'CODE' use32
.text$mn:000048C0                 assume cs:_text$mn
.text$mn:000048C0                 ;org 48C0h
.text$mn:000048C0 ; COMDAT (pick any)
.text$mn:000048C0                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text$mn:000048C0
.text$mn:000048C0 ; =============== S U B R O U T I N E =======================================
.text$mn:000048C0
.text$mn:000048C0 ; Attributes: bp-based frame
.text$mn:000048C0
.text$mn:000048C0 ; int __stdcall std::_Wrap_alloc<std::allocator<wchar_t>>::construct<wchar_t *,wchar_t * &>(void *, int)
.text$mn:000048C0                 public ??$construct@PA_WAAPA_W@?$_Wrap_alloc@V?$allocator@_W@std@@@std@@QAEXPAPA_WAAPA_W@Z
.text$mn:000048C0 ??$construct@PA_WAAPA_W@?$_Wrap_alloc@V?$allocator@_W@std@@@std@@QAEXPAPA_WAAPA_W@Z proc near
.text$mn:000048C0                                         ; CODE XREF: std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>>::_Assign_rv(std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>> &&)+50p
.text$mn:000048C0                                         ; $LN19_0+4Bp
.text$mn:000048C0
.text$mn:000048C0 var_4           = dword ptr -4
.text$mn:000048C0 arg_0           = dword ptr  8
.text$mn:000048C0 arg_4           = dword ptr  0Ch
.text$mn:000048C0
.text$mn:000048C0                 push    ebp
.text$mn:000048C1                 mov     ebp, esp
.text$mn:000048C3                 push    ecx
.text$mn:000048C4                 mov     [ebp+var_4], ecx
.text$mn:000048C7                 mov     eax, [ebp+arg_4]
.text$mn:000048CA                 push    eax
.text$mn:000048CB                 call    ??$forward@AAPA_W@std@@YAAAPA_WAAPA_W@Z ; std::forward<wchar_t * &>(wchar_t * &)
.text$mn:000048D0                 add     esp, 4
.text$mn:000048D3                 push    eax             ; int
.text$mn:000048D4                 mov     ecx, [ebp+arg_0]
.text$mn:000048D7                 push    ecx             ; void *
.text$mn:000048D8                 mov     edx, [ebp+var_4]
.text$mn:000048DB                 push    edx             ; int
.text$mn:000048DC                 call    ??$construct@PA_WAAPA_W@?$allocator_traits@V?$allocator@_W@std@@@std@@SAXAAV?$allocator@_W@1@PAPA_WAAPA_W@Z ; std::allocator_traits<std::allocator<wchar_t>>::construct<wchar_t *,wchar_t * &>(std::allocator<wchar_t> &,wchar_t * *,wchar_t * &)
.text$mn:000048E1                 add     esp, 0Ch
.text$mn:000048E4                 mov     esp, ebp
.text$mn:000048E6                 pop     ebp
.text$mn:000048E7                 retn    8
.text$mn:000048E7 ??$construct@PA_WAAPA_W@?$_Wrap_alloc@V?$allocator@_W@std@@@std@@QAEXPAPA_WAAPA_W@Z endp
.text$mn:000048E7
.text$mn:000048E7 ; ---------------------------------------------------------------------------
.text$mn:000048EA                 align 4
.text$mn:000048EA _text$mn        ends
.text$mn:000048EA
.text$mn:000048EC ; ===========================================================================
.text$mn:000048EC
.text$mn:000048EC ; Segment type: Pure code
.text$mn:000048EC ; Segment permissions: Read/Execute
.text$mn:000048EC _text$mn        segment para public 'CODE' use32
.text$mn:000048EC                 assume cs:_text$mn
.text$mn:000048EC                 ;org 48ECh
.text$mn:000048EC ; COMDAT (pick any)
.text$mn:000048EC                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text$mn:000048EC
.text$mn:000048EC ; =============== S U B R O U T I N E =======================================
.text$mn:000048EC
.text$mn:000048EC ; Attributes: bp-based frame
.text$mn:000048EC
.text$mn:000048EC ; int __stdcall std::allocator<wchar_t>::construct<wchar_t *,wchar_t * &>(void *, int)
.text$mn:000048EC                 public ??$construct@PA_WAAPA_W@?$allocator@_W@std@@QAEXPAPA_WAAPA_W@Z
.text$mn:000048EC ??$construct@PA_WAAPA_W@?$allocator@_W@std@@QAEXPAPA_WAAPA_W@Z proc near
.text$mn:000048EC                                         ; CODE XREF: std::allocator_traits<std::allocator<wchar_t>>::construct<wchar_t *,wchar_t * &>(std::allocator<wchar_t> &,wchar_t * *,wchar_t * &)+17p
.text$mn:000048EC
.text$mn:000048EC var_1C          = dword ptr -1Ch
.text$mn:000048EC var_18          = dword ptr -18h
.text$mn:000048EC var_14          = dword ptr -14h
.text$mn:000048EC var_10          = dword ptr -10h
.text$mn:000048EC var_C           = dword ptr -0Ch
.text$mn:000048EC var_4           = dword ptr -4
.text$mn:000048EC arg_0           = dword ptr  8
.text$mn:000048EC arg_4           = dword ptr  0Ch
.text$mn:000048EC
.text$mn:000048EC                 push    ebp
.text$mn:000048ED                 mov     ebp, esp
.text$mn:000048EF                 push    0FFFFFFFFh
.text$mn:000048F1                 push    offset __ehhandler$??$construct@PA_WAAPA_W@?$allocator@_W@std@@QAEXPAPA_WAAPA_W@Z
.text$mn:000048F6                 mov     eax, large fs:0
.text$mn:000048FC                 push    eax
.text$mn:000048FD                 sub     esp, 10h
.text$mn:00004900                 mov     eax, dword ptr ds:___security_cookie
.text$mn:00004905                 xor     eax, ebp
.text$mn:00004907                 push    eax
.text$mn:00004908                 lea     eax, [ebp+var_C]
.text$mn:0000490B                 mov     large fs:0, eax
.text$mn:00004911                 mov     [ebp+var_18], ecx
.text$mn:00004914                 mov     eax, [ebp+arg_0]
.text$mn:00004917                 push    eax             ; void *
.text$mn:00004918                 push    4               ; unsigned int
.text$mn:0000491A                 call    ??2@YAPAXIPAX@Z ; operator new(uint,void *)
.text$mn:0000491F                 add     esp, 8
.text$mn:00004922                 mov     [ebp+var_10], eax
.text$mn:00004925                 mov     [ebp+var_4], 0
.text$mn:0000492C                 cmp     [ebp+var_10], 0
.text$mn:00004930                 jz      short loc_494D
.text$mn:00004932                 mov     ecx, [ebp+arg_4]
.text$mn:00004935                 push    ecx
.text$mn:00004936                 call    ??$forward@AAPA_W@std@@YAAAPA_WAAPA_W@Z ; std::forward<wchar_t * &>(wchar_t * &)
.text$mn:0000493B                 add     esp, 4
.text$mn:0000493E                 mov     edx, [ebp+var_10]
.text$mn:00004941                 mov     eax, [eax]
.text$mn:00004943                 mov     [edx], eax
.text$mn:00004945                 mov     ecx, [ebp+var_10]
.text$mn:00004948                 mov     [ebp+var_14], ecx
.text$mn:0000494B                 jmp     short loc_4954
.text$mn:0000494D ; ---------------------------------------------------------------------------
.text$mn:0000494D
.text$mn:0000494D loc_494D:                               ; CODE XREF: std::allocator<wchar_t>::construct<wchar_t *,wchar_t * &>(wchar_t * *,wchar_t * &)+44j
.text$mn:0000494D                 mov     [ebp+var_14], 0
.text$mn:00004954
.text$mn:00004954 loc_4954:                               ; CODE XREF: std::allocator<wchar_t>::construct<wchar_t *,wchar_t * &>(wchar_t * *,wchar_t * &)+5Fj
.text$mn:00004954                 mov     edx, [ebp+var_14]
.text$mn:00004957                 mov     [ebp+var_1C], edx
.text$mn:0000495A                 mov     [ebp+var_4], 0FFFFFFFFh
.text$mn:00004961                 mov     ecx, [ebp+var_C]
.text$mn:00004964                 mov     large fs:0, ecx
.text$mn:0000496B                 pop     ecx
.text$mn:0000496C                 mov     esp, ebp
.text$mn:0000496E                 pop     ebp
.text$mn:0000496F                 retn    8
.text$mn:0000496F ??$construct@PA_WAAPA_W@?$allocator@_W@std@@QAEXPAPA_WAAPA_W@Z endp
.text$mn:0000496F
.text$mn:0000496F ; ---------------------------------------------------------------------------
.text$mn:00004972                 align 4
.text$mn:00004972 _text$mn        ends
.text$mn:00004972
.text$x:00004974 ; ===========================================================================
.text$x:00004974
.text$x:00004974 ; Segment type: Pure code
.text$x:00004974 ; Segment permissions: Read/Execute
.text$x:00004974 _text$x         segment para public 'CODE' use32
.text$x:00004974                 assume cs:_text$x
.text$x:00004974                 ;org 4974h
.text$x:00004974 ; COMDAT (pick associative to section at 48EC)
.text$x:00004974                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text$x:00004974
.text$x:00004974 ; =============== S U B R O U T I N E =======================================
.text$x:00004974
.text$x:00004974
.text$x:00004974 __unwindfunclet$??$construct@PA_WAAPA_W@?$allocator@_W@std@@QAEXPAPA_WAAPA_W@Z$0 proc near
.text$x:00004974                                         ; DATA XREF: .xdata$x:0000F0F8o
.text$x:00004974                 mov     eax, [ebp+8]
.text$x:00004977                 push    eax
.text$x:00004978                 mov     eax, [ebp-10h]
.text$x:0000497B                 push    eax             ; void *
.text$x:0000497C                 call    ??3@YAXPAX0@Z   ; operator delete(void *,void *)
.text$x:00004981                 add     esp, 8
.text$x:00004984                 retn
.text$x:00004984 __unwindfunclet$??$construct@PA_WAAPA_W@?$allocator@_W@std@@QAEXPAPA_WAAPA_W@Z$0 endp
.text$x:00004984
.text$x:00004985
.text$x:00004985 ; =============== S U B R O U T I N E =======================================
.text$x:00004985
.text$x:00004985
.text$x:00004985 __ehhandler$??$construct@PA_WAAPA_W@?$allocator@_W@std@@QAEXPAPA_WAAPA_W@Z proc near
.text$x:00004985                                         ; DATA XREF: std::allocator<wchar_t>::construct<wchar_t *,wchar_t * &>(wchar_t * *,wchar_t * &)+5o
.text$x:00004985
.text$x:00004985 arg_4           = dword ptr  8
.text$x:00004985
.text$x:00004985                 mov     edx, [esp+arg_4]
.text$x:00004989                 lea     eax, [edx+0Ch]
.text$x:0000498C                 mov     ecx, [edx-14h]
.text$x:0000498F                 xor     ecx, eax
.text$x:00004991                 call    @__security_check_cookie@4 ; __security_check_cookie(x)
.text$x:00004996                 mov     eax, offset __ehfuncinfo$??$construct@PA_WAAPA_W@?$allocator@_W@std@@QAEXPAPA_WAAPA_W@Z
.text$x:0000499B                 jmp     ___CxxFrameHandler3
.text$x:0000499B __ehhandler$??$construct@PA_WAAPA_W@?$allocator@_W@std@@QAEXPAPA_WAAPA_W@Z endp
.text$x:0000499B
.text$x:0000499B _text$x         ends
.text$x:0000499B
.text$mn:000049A0 ; ===========================================================================
.text$mn:000049A0
.text$mn:000049A0 ; Segment type: Pure code
.text$mn:000049A0 ; Segment permissions: Read/Execute
.text$mn:000049A0 _text$mn        segment para public 'CODE' use32
.text$mn:000049A0                 assume cs:_text$mn
.text$mn:000049A0                 ;org 49A0h
.text$mn:000049A0 ; COMDAT (pick any)
.text$mn:000049A0                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text$mn:000049A0
.text$mn:000049A0 ; =============== S U B R O U T I N E =======================================
.text$mn:000049A0
.text$mn:000049A0 ; Attributes: bp-based frame
.text$mn:000049A0
.text$mn:000049A0 ; int __cdecl std::allocator_traits<std::allocator<wchar_t>>::construct<wchar_t *,wchar_t * &>(int, void *, int)
.text$mn:000049A0                 public ??$construct@PA_WAAPA_W@?$allocator_traits@V?$allocator@_W@std@@@std@@SAXAAV?$allocator@_W@1@PAPA_WAAPA_W@Z
.text$mn:000049A0 ??$construct@PA_WAAPA_W@?$allocator_traits@V?$allocator@_W@std@@@std@@SAXAAV?$allocator@_W@1@PAPA_WAAPA_W@Z proc near
.text$mn:000049A0                                         ; CODE XREF: std::_Wrap_alloc<std::allocator<wchar_t>>::construct<wchar_t *,wchar_t * &>(wchar_t * *,wchar_t * &)+1Cp
.text$mn:000049A0
.text$mn:000049A0 arg_0           = dword ptr  8
.text$mn:000049A0 arg_4           = dword ptr  0Ch
.text$mn:000049A0 arg_8           = dword ptr  10h
.text$mn:000049A0
.text$mn:000049A0                 push    ebp
.text$mn:000049A1                 mov     ebp, esp
.text$mn:000049A3                 mov     eax, [ebp+arg_8]
.text$mn:000049A6                 push    eax
.text$mn:000049A7                 call    ??$forward@AAPA_W@std@@YAAAPA_WAAPA_W@Z ; std::forward<wchar_t * &>(wchar_t * &)
.text$mn:000049AC                 add     esp, 4
.text$mn:000049AF                 push    eax             ; int
.text$mn:000049B0                 mov     ecx, [ebp+arg_4]
.text$mn:000049B3                 push    ecx             ; void *
.text$mn:000049B4                 mov     ecx, [ebp+arg_0]
.text$mn:000049B7                 call    ??$construct@PA_WAAPA_W@?$allocator@_W@std@@QAEXPAPA_WAAPA_W@Z ; std::allocator<wchar_t>::construct<wchar_t *,wchar_t * &>(wchar_t * *,wchar_t * &)
.text$mn:000049BC                 pop     ebp
.text$mn:000049BD                 retn
.text$mn:000049BD ??$construct@PA_WAAPA_W@?$allocator_traits@V?$allocator@_W@std@@@std@@SAXAAV?$allocator@_W@1@PAPA_WAAPA_W@Z endp
.text$mn:000049BD
.text$mn:000049BD ; ---------------------------------------------------------------------------
.text$mn:000049BE                 align 10h
.text$mn:000049BE _text$mn        ends
.text$mn:000049BE
.text$mn:000049C0 ; ===========================================================================
.text$mn:000049C0
.text$mn:000049C0 ; Segment type: Pure code
.text$mn:000049C0 ; Segment permissions: Read/Execute
.text$mn:000049C0 _text$mn        segment para public 'CODE' use32
.text$mn:000049C0                 assume cs:_text$mn
.text$mn:000049C0                 ;org 49C0h
.text$mn:000049C0 ; COMDAT (pick any)
.text$mn:000049C0                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text$mn:000049C0
.text$mn:000049C0 ; =============== S U B R O U T I N E =======================================
.text$mn:000049C0
.text$mn:000049C0 ; Attributes: bp-based frame
.text$mn:000049C0
.text$mn:000049C0 ; int __stdcall std::_Wrap_alloc<std::allocator<std::_Container_proxy>>::construct<std::_Container_proxy,std::_Container_proxy>(void *, int)
.text$mn:000049C0                 public ??$construct@U_Container_proxy@std@@U12@@?$_Wrap_alloc@V?$allocator@U_Container_proxy@std@@@std@@@std@@QAEXPAU_Container_proxy@1@$$QAU21@@Z
.text$mn:000049C0 ??$construct@U_Container_proxy@std@@U12@@?$_Wrap_alloc@V?$allocator@U_Container_proxy@std@@@std@@@std@@QAEXPAU_Container_proxy@1@$$QAU21@@Z proc near
.text$mn:000049C0                                         ; CODE XREF: std::_Vector_alloc<0,std::_Vec_base_types<char,std::allocator<char>>>::_Alloc_proxy(void)+32p
.text$mn:000049C0                                         ; std::_Vector_alloc<0,std::_Vec_base_types<std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>>,std::allocator<std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>>>>>::_Alloc_proxy(void)+32p ...
.text$mn:000049C0
.text$mn:000049C0 var_4           = dword ptr -4
.text$mn:000049C0 arg_0           = dword ptr  8
.text$mn:000049C0 arg_4           = dword ptr  0Ch
.text$mn:000049C0
.text$mn:000049C0                 push    ebp
.text$mn:000049C1                 mov     ebp, esp
.text$mn:000049C3                 push    ecx
.text$mn:000049C4                 mov     [ebp+var_4], ecx
.text$mn:000049C7                 mov     eax, [ebp+arg_4]
.text$mn:000049CA                 push    eax
.text$mn:000049CB                 call    ??$forward@U_Container_proxy@std@@@std@@YA$$QAU_Container_proxy@0@AAU10@@Z ; std::forward<std::_Container_proxy>(std::_Container_proxy &)
.text$mn:000049D0                 add     esp, 4
.text$mn:000049D3                 push    eax             ; int
.text$mn:000049D4                 mov     ecx, [ebp+arg_0]
.text$mn:000049D7                 push    ecx             ; void *
.text$mn:000049D8                 mov     edx, [ebp+var_4]
.text$mn:000049DB                 push    edx             ; int
.text$mn:000049DC                 call    ??$construct@U_Container_proxy@std@@U12@@?$allocator_traits@V?$allocator@U_Container_proxy@std@@@std@@@std@@SAXAAV?$allocator@U_Container_proxy@std@@@1@PAU_Container_proxy@1@$$QAU31@@Z ; std::allocator_traits<std::allocator<std::_Container_proxy>>::construct<std::_Container_proxy,std::_Container_proxy>(std::allocator<std::_Container_proxy> &,std::_Container_proxy *,std::_Container_proxy &&)
.text$mn:000049E1                 add     esp, 0Ch
.text$mn:000049E4                 mov     esp, ebp
.text$mn:000049E6                 pop     ebp
.text$mn:000049E7                 retn    8
.text$mn:000049E7 ??$construct@U_Container_proxy@std@@U12@@?$_Wrap_alloc@V?$allocator@U_Container_proxy@std@@@std@@@std@@QAEXPAU_Container_proxy@1@$$QAU21@@Z endp
.text$mn:000049E7
.text$mn:000049E7 ; ---------------------------------------------------------------------------
.text$mn:000049EA                 align 4
.text$mn:000049EA _text$mn        ends
.text$mn:000049EA
.text$mn:000049EC ; ===========================================================================
.text$mn:000049EC
.text$mn:000049EC ; Segment type: Pure code
.text$mn:000049EC ; Segment permissions: Read/Execute
.text$mn:000049EC _text$mn        segment para public 'CODE' use32
.text$mn:000049EC                 assume cs:_text$mn
.text$mn:000049EC                 ;org 49ECh
.text$mn:000049EC ; COMDAT (pick any)
.text$mn:000049EC                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text$mn:000049EC
.text$mn:000049EC ; =============== S U B R O U T I N E =======================================
.text$mn:000049EC
.text$mn:000049EC ; Attributes: bp-based frame
.text$mn:000049EC
.text$mn:000049EC ; int __stdcall std::allocator<std::_Container_proxy>::construct<std::_Container_proxy,std::_Container_proxy>(void *, int)
.text$mn:000049EC                 public ??$construct@U_Container_proxy@std@@U12@@?$allocator@U_Container_proxy@std@@@std@@QAEXPAU_Container_proxy@1@$$QAU21@@Z
.text$mn:000049EC ??$construct@U_Container_proxy@std@@U12@@?$allocator@U_Container_proxy@std@@@std@@QAEXPAU_Container_proxy@1@$$QAU21@@Z proc near
.text$mn:000049EC                                         ; CODE XREF: std::allocator_traits<std::allocator<std::_Container_proxy>>::construct<std::_Container_proxy,std::_Container_proxy>(std::allocator<std::_Container_proxy> &,std::_Container_proxy *,std::_Container_proxy &&)+17p
.text$mn:000049EC                                         ; std::_String_alloc<0,std::_String_base_types<char,std::allocator<char>>>::_Alloc_proxy(void)+32p ...
.text$mn:000049EC
.text$mn:000049EC var_1C          = dword ptr -1Ch
.text$mn:000049EC var_18          = dword ptr -18h
.text$mn:000049EC var_14          = dword ptr -14h
.text$mn:000049EC var_10          = dword ptr -10h
.text$mn:000049EC var_C           = dword ptr -0Ch
.text$mn:000049EC var_4           = dword ptr -4
.text$mn:000049EC arg_0           = dword ptr  8
.text$mn:000049EC arg_4           = dword ptr  0Ch
.text$mn:000049EC
.text$mn:000049EC                 push    ebp
.text$mn:000049ED                 mov     ebp, esp
.text$mn:000049EF                 push    0FFFFFFFFh
.text$mn:000049F1                 push    offset __ehhandler$??$construct@U_Container_proxy@std@@U12@@?$allocator@U_Container_proxy@std@@@std@@QAEXPAU_Container_proxy@1@$$QAU21@@Z
.text$mn:000049F6                 mov     eax, large fs:0
.text$mn:000049FC                 push    eax
.text$mn:000049FD                 sub     esp, 10h
.text$mn:00004A00                 mov     eax, dword ptr ds:___security_cookie
.text$mn:00004A05                 xor     eax, ebp
.text$mn:00004A07                 push    eax
.text$mn:00004A08                 lea     eax, [ebp+var_C]
.text$mn:00004A0B                 mov     large fs:0, eax
.text$mn:00004A11                 mov     [ebp+var_18], ecx
.text$mn:00004A14                 mov     eax, [ebp+arg_0]
.text$mn:00004A17                 push    eax             ; void *
.text$mn:00004A18                 push    8               ; unsigned int
.text$mn:00004A1A                 call    ??2@YAPAXIPAX@Z ; operator new(uint,void *)
.text$mn:00004A1F                 add     esp, 8
.text$mn:00004A22                 mov     [ebp+var_10], eax
.text$mn:00004A25                 mov     [ebp+var_4], 0
.text$mn:00004A2C                 cmp     [ebp+var_10], 0
.text$mn:00004A30                 jz      short loc_4A53
.text$mn:00004A32                 mov     ecx, [ebp+arg_4]
.text$mn:00004A35                 push    ecx
.text$mn:00004A36                 call    ??$forward@U_Container_proxy@std@@@std@@YA$$QAU_Container_proxy@0@AAU10@@Z ; std::forward<std::_Container_proxy>(std::_Container_proxy &)
.text$mn:00004A3B                 add     esp, 4
.text$mn:00004A3E                 mov     edx, [eax]
.text$mn:00004A40                 mov     eax, [eax+4]
.text$mn:00004A43                 mov     ecx, [ebp+var_10]
.text$mn:00004A46                 mov     [ecx], edx
.text$mn:00004A48                 mov     [ecx+4], eax
.text$mn:00004A4B                 mov     edx, [ebp+var_10]
.text$mn:00004A4E                 mov     [ebp+var_14], edx
.text$mn:00004A51                 jmp     short loc_4A5A
.text$mn:00004A53 ; ---------------------------------------------------------------------------
.text$mn:00004A53
.text$mn:00004A53 loc_4A53:                               ; CODE XREF: std::allocator<std::_Container_proxy>::construct<std::_Container_proxy,std::_Container_proxy>(std::_Container_proxy *,std::_Container_proxy &&)+44j
.text$mn:00004A53                 mov     [ebp+var_14], 0
.text$mn:00004A5A
.text$mn:00004A5A loc_4A5A:                               ; CODE XREF: std::allocator<std::_Container_proxy>::construct<std::_Container_proxy,std::_Container_proxy>(std::_Container_proxy *,std::_Container_proxy &&)+65j
.text$mn:00004A5A                 mov     eax, [ebp+var_14]
.text$mn:00004A5D                 mov     [ebp+var_1C], eax
.text$mn:00004A60                 mov     [ebp+var_4], 0FFFFFFFFh
.text$mn:00004A67                 mov     ecx, [ebp+var_C]
.text$mn:00004A6A                 mov     large fs:0, ecx
.text$mn:00004A71                 pop     ecx
.text$mn:00004A72                 mov     esp, ebp
.text$mn:00004A74                 pop     ebp
.text$mn:00004A75                 retn    8
.text$mn:00004A75 ??$construct@U_Container_proxy@std@@U12@@?$allocator@U_Container_proxy@std@@@std@@QAEXPAU_Container_proxy@1@$$QAU21@@Z endp
.text$mn:00004A75
.text$mn:00004A75 _text$mn        ends
.text$mn:00004A75
.text$x:00004A78 ; ===========================================================================
.text$x:00004A78
.text$x:00004A78 ; Segment type: Pure code
.text$x:00004A78 ; Segment permissions: Read/Execute
.text$x:00004A78 _text$x         segment para public 'CODE' use32
.text$x:00004A78                 assume cs:_text$x
.text$x:00004A78                 ;org 4A78h
.text$x:00004A78 ; COMDAT (pick associative to section at 49EC)
.text$x:00004A78                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text$x:00004A78
.text$x:00004A78 ; =============== S U B R O U T I N E =======================================
.text$x:00004A78
.text$x:00004A78
.text$x:00004A78 __unwindfunclet$??$construct@U_Container_proxy@std@@U12@@?$allocator@U_Container_proxy@std@@@std@@QAEXPAU_Container_proxy@1@$$QAU21@@Z$0 proc near
.text$x:00004A78                                         ; DATA XREF: .xdata$x:0000EDE8o
.text$x:00004A78                 mov     eax, [ebp+8]
.text$x:00004A7B                 push    eax
.text$x:00004A7C                 mov     eax, [ebp-10h]
.text$x:00004A7F                 push    eax             ; void *
.text$x:00004A80                 call    ??3@YAXPAX0@Z   ; operator delete(void *,void *)
.text$x:00004A85                 add     esp, 8
.text$x:00004A88                 retn
.text$x:00004A88 __unwindfunclet$??$construct@U_Container_proxy@std@@U12@@?$allocator@U_Container_proxy@std@@@std@@QAEXPAU_Container_proxy@1@$$QAU21@@Z$0 endp
.text$x:00004A88
.text$x:00004A89
.text$x:00004A89 ; =============== S U B R O U T I N E =======================================
.text$x:00004A89
.text$x:00004A89
.text$x:00004A89 __ehhandler$??$construct@U_Container_proxy@std@@U12@@?$allocator@U_Container_proxy@std@@@std@@QAEXPAU_Container_proxy@1@$$QAU21@@Z proc near
.text$x:00004A89                                         ; DATA XREF: std::allocator<std::_Container_proxy>::construct<std::_Container_proxy,std::_Container_proxy>(std::_Container_proxy *,std::_Container_proxy &&)+5o
.text$x:00004A89
.text$x:00004A89 arg_4           = dword ptr  8
.text$x:00004A89
.text$x:00004A89                 mov     edx, [esp+arg_4]
.text$x:00004A8D                 lea     eax, [edx+0Ch]
.text$x:00004A90                 mov     ecx, [edx-14h]
.text$x:00004A93                 xor     ecx, eax
.text$x:00004A95                 call    @__security_check_cookie@4 ; __security_check_cookie(x)
.text$x:00004A9A                 mov     eax, offset __ehfuncinfo$??$construct@U_Container_proxy@std@@U12@@?$allocator@U_Container_proxy@std@@@std@@QAEXPAU_Container_proxy@1@$$QAU21@@Z
.text$x:00004A9F                 jmp     ___CxxFrameHandler3
.text$x:00004A9F __ehhandler$??$construct@U_Container_proxy@std@@U12@@?$allocator@U_Container_proxy@std@@@std@@QAEXPAU_Container_proxy@1@$$QAU21@@Z endp
.text$x:00004A9F
.text$x:00004A9F _text$x         ends
.text$x:00004A9F
.text$mn:00004AA4 ; ===========================================================================
.text$mn:00004AA4
.text$mn:00004AA4 ; Segment type: Pure code
.text$mn:00004AA4 ; Segment permissions: Read/Execute
.text$mn:00004AA4 _text$mn        segment para public 'CODE' use32
.text$mn:00004AA4                 assume cs:_text$mn
.text$mn:00004AA4                 ;org 4AA4h
.text$mn:00004AA4 ; COMDAT (pick any)
.text$mn:00004AA4                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text$mn:00004AA4
.text$mn:00004AA4 ; =============== S U B R O U T I N E =======================================
.text$mn:00004AA4
.text$mn:00004AA4 ; Attributes: bp-based frame
.text$mn:00004AA4
.text$mn:00004AA4 ; int __cdecl std::allocator_traits<std::allocator<std::_Container_proxy>>::construct<std::_Container_proxy,std::_Container_proxy>(int, void *, int)
.text$mn:00004AA4                 public ??$construct@U_Container_proxy@std@@U12@@?$allocator_traits@V?$allocator@U_Container_proxy@std@@@std@@@std@@SAXAAV?$allocator@U_Container_proxy@std@@@1@PAU_Container_proxy@1@$$QAU31@@Z
.text$mn:00004AA4 ??$construct@U_Container_proxy@std@@U12@@?$allocator_traits@V?$allocator@U_Container_proxy@std@@@std@@@std@@SAXAAV?$allocator@U_Container_proxy@std@@@1@PAU_Container_proxy@1@$$QAU31@@Z proc near
.text$mn:00004AA4                                         ; CODE XREF: std::_Wrap_alloc<std::allocator<std::_Container_proxy>>::construct<std::_Container_proxy,std::_Container_proxy>(std::_Container_proxy *,std::_Container_proxy &&)+1Cp
.text$mn:00004AA4
.text$mn:00004AA4 arg_0           = dword ptr  8
.text$mn:00004AA4 arg_4           = dword ptr  0Ch
.text$mn:00004AA4 arg_8           = dword ptr  10h
.text$mn:00004AA4
.text$mn:00004AA4                 push    ebp
.text$mn:00004AA5                 mov     ebp, esp
.text$mn:00004AA7                 mov     eax, [ebp+arg_8]
.text$mn:00004AAA                 push    eax
.text$mn:00004AAB                 call    ??$forward@U_Container_proxy@std@@@std@@YA$$QAU_Container_proxy@0@AAU10@@Z ; std::forward<std::_Container_proxy>(std::_Container_proxy &)
.text$mn:00004AB0                 add     esp, 4
.text$mn:00004AB3                 push    eax             ; int
.text$mn:00004AB4                 mov     ecx, [ebp+arg_4]
.text$mn:00004AB7                 push    ecx             ; void *
.text$mn:00004AB8                 mov     ecx, [ebp+arg_0]
.text$mn:00004ABB                 call    ??$construct@U_Container_proxy@std@@U12@@?$allocator@U_Container_proxy@std@@@std@@QAEXPAU_Container_proxy@1@$$QAU21@@Z ; std::allocator<std::_Container_proxy>::construct<std::_Container_proxy,std::_Container_proxy>(std::_Container_proxy *,std::_Container_proxy &&)
.text$mn:00004AC0                 pop     ebp
.text$mn:00004AC1                 retn
.text$mn:00004AC1 ??$construct@U_Container_proxy@std@@U12@@?$allocator_traits@V?$allocator@U_Container_proxy@std@@@std@@@std@@SAXAAV?$allocator@U_Container_proxy@std@@@1@PAU_Container_proxy@1@$$QAU31@@Z endp
.text$mn:00004AC1
.text$mn:00004AC1 ; ---------------------------------------------------------------------------
.text$mn:00004AC2                 align 4
.text$mn:00004AC2 _text$mn        ends
.text$mn:00004AC2
.text$mn:00004AC4 ; ===========================================================================
.text$mn:00004AC4
.text$mn:00004AC4 ; Segment type: Pure code
.text$mn:00004AC4 ; Segment permissions: Read/Execute
.text$mn:00004AC4 _text$mn        segment para public 'CODE' use32
.text$mn:00004AC4                 assume cs:_text$mn
.text$mn:00004AC4                 ;org 4AC4h
.text$mn:00004AC4 ; COMDAT (pick any)
.text$mn:00004AC4                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text$mn:00004AC4
.text$mn:00004AC4 ; =============== S U B R O U T I N E =======================================
.text$mn:00004AC4
.text$mn:00004AC4 ; Attributes: bp-based frame
.text$mn:00004AC4
.text$mn:00004AC4 ; int __stdcall std::_Wrap_alloc<std::allocator<std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>>>>::construct<std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>>,std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>>>(void *, int)
.text$mn:00004AC4                 public ??$construct@V?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@V12@@?$_Wrap_alloc@V?$allocator@V?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@@std@@@std@@QAEXPAV?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@1@$$QAV21@@Z
.text$mn:00004AC4 ??$construct@V?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@V12@@?$_Wrap_alloc@V?$allocator@V?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@@std@@@std@@QAEXPAV?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@1@$$QAV21@@Z proc near
.text$mn:00004AC4                                         ; CODE XREF: std::_Uninit_move<std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>> *,std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>> *,std::allocator<std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>>>,std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>>>(std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>> *,std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>> *,std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>> *,std::_Wrap_alloc<std::allocator<std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>>>> &,std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>> *,std::_Nonscalar_ptr_iterator_tag)+8Ep
.text$mn:00004AC4                                         ; std::vector<std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>>,std::allocator<std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>>>>::push_back(std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>> &&)+9Dp ...
.text$mn:00004AC4
.text$mn:00004AC4 var_4           = dword ptr -4
.text$mn:00004AC4 arg_0           = dword ptr  8
.text$mn:00004AC4 arg_4           = dword ptr  0Ch
.text$mn:00004AC4
.text$mn:00004AC4                 push    ebp
.text$mn:00004AC5                 mov     ebp, esp
.text$mn:00004AC7                 push    ecx
.text$mn:00004AC8                 mov     [ebp+var_4], ecx
.text$mn:00004ACB                 mov     eax, [ebp+arg_4]
.text$mn:00004ACE                 push    eax
.text$mn:00004ACF                 call    ??$forward@V?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@@std@@YA$$QAV?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@0@AAV10@@Z ; std::forward<std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>>>(std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>> &)
.text$mn:00004AD4                 add     esp, 4
.text$mn:00004AD7                 push    eax             ; int
.text$mn:00004AD8                 mov     ecx, [ebp+arg_0]
.text$mn:00004ADB                 push    ecx             ; void *
.text$mn:00004ADC                 mov     edx, [ebp+var_4]
.text$mn:00004ADF                 push    edx             ; int
.text$mn:00004AE0                 call    ??$construct@V?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@V12@@?$allocator_traits@V?$allocator@V?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@@std@@@std@@SAXAAV?$allocator@V?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@@1@PAV?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@1@$$QAV31@@Z ; std::allocator_traits<std::allocator<std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>>>>::construct<std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>>,std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>>>(std::allocator<std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>>> &,std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>> *,std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>> &&)
.text$mn:00004AE5                 add     esp, 0Ch
.text$mn:00004AE8                 mov     esp, ebp
.text$mn:00004AEA                 pop     ebp
.text$mn:00004AEB                 retn    8
.text$mn:00004AEB ??$construct@V?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@V12@@?$_Wrap_alloc@V?$allocator@V?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@@std@@@std@@QAEXPAV?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@1@$$QAV21@@Z endp
.text$mn:00004AEB
.text$mn:00004AEB ; ---------------------------------------------------------------------------
.text$mn:00004AEE                 align 10h
.text$mn:00004AEE _text$mn        ends
.text$mn:00004AEE
.text$mn:00004AF0 ; ===========================================================================
.text$mn:00004AF0
.text$mn:00004AF0 ; Segment type: Pure code
.text$mn:00004AF0 ; Segment permissions: Read/Execute
.text$mn:00004AF0 _text$mn        segment para public 'CODE' use32
.text$mn:00004AF0                 assume cs:_text$mn
.text$mn:00004AF0                 ;org 4AF0h
.text$mn:00004AF0 ; COMDAT (pick any)
.text$mn:00004AF0                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text$mn:00004AF0
.text$mn:00004AF0 ; =============== S U B R O U T I N E =======================================
.text$mn:00004AF0
.text$mn:00004AF0 ; Attributes: bp-based frame
.text$mn:00004AF0
.text$mn:00004AF0 ; int __stdcall std::allocator<std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>>>::construct<std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>>,std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>>>(void *, int)
.text$mn:00004AF0                 public ??$construct@V?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@V12@@?$allocator@V?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@@std@@QAEXPAV?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@1@$$QAV21@@Z
.text$mn:00004AF0 ??$construct@V?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@V12@@?$allocator@V?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@@std@@QAEXPAV?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@1@$$QAV21@@Z proc near
.text$mn:00004AF0                                         ; CODE XREF: std::allocator_traits<std::allocator<std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>>>>::construct<std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>>,std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>>>(std::allocator<std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>>> &,std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>> *,std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>> &&)+17p
.text$mn:00004AF0
.text$mn:00004AF0 var_1C          = dword ptr -1Ch
.text$mn:00004AF0 var_18          = dword ptr -18h
.text$mn:00004AF0 var_14          = dword ptr -14h
.text$mn:00004AF0 var_10          = dword ptr -10h
.text$mn:00004AF0 var_C           = dword ptr -0Ch
.text$mn:00004AF0 var_4           = dword ptr -4
.text$mn:00004AF0 arg_0           = dword ptr  8
.text$mn:00004AF0 arg_4           = dword ptr  0Ch
.text$mn:00004AF0
.text$mn:00004AF0                 push    ebp
.text$mn:00004AF1                 mov     ebp, esp
.text$mn:00004AF3                 push    0FFFFFFFFh
.text$mn:00004AF5                 push    offset __ehhandler$??$construct@V?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@V12@@?$allocator@V?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@@std@@QAEXPAV?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@1@$$QAV21@@Z
.text$mn:00004AFA                 mov     eax, large fs:0
.text$mn:00004B00                 push    eax
.text$mn:00004B01                 sub     esp, 10h
.text$mn:00004B04                 mov     eax, dword ptr ds:___security_cookie
.text$mn:00004B09                 xor     eax, ebp
.text$mn:00004B0B                 push    eax
.text$mn:00004B0C                 lea     eax, [ebp+var_C]
.text$mn:00004B0F                 mov     large fs:0, eax
.text$mn:00004B15                 mov     [ebp+var_18], ecx
.text$mn:00004B18                 mov     eax, [ebp+arg_0]
.text$mn:00004B1B                 push    eax             ; void *
.text$mn:00004B1C                 push    1Ch             ; unsigned int
.text$mn:00004B1E                 call    ??2@YAPAXIPAX@Z ; operator new(uint,void *)
.text$mn:00004B23                 add     esp, 8
.text$mn:00004B26                 mov     [ebp+var_10], eax
.text$mn:00004B29                 mov     [ebp+var_4], 0
.text$mn:00004B30                 cmp     [ebp+var_10], 0
.text$mn:00004B34                 jz      short loc_4B50
.text$mn:00004B36                 mov     ecx, [ebp+arg_4]
.text$mn:00004B39                 push    ecx
.text$mn:00004B3A                 call    ??$forward@V?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@@std@@YA$$QAV?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@0@AAV10@@Z ; std::forward<std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>>>(std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>> &)
.text$mn:00004B3F                 add     esp, 4
.text$mn:00004B42                 push    eax
.text$mn:00004B43                 mov     ecx, [ebp+var_10]
.text$mn:00004B46                 call    ??0?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QAE@$$QAV01@@Z ; std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>>::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>>(std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>> &&)
.text$mn:00004B4B                 mov     [ebp+var_14], eax
.text$mn:00004B4E                 jmp     short loc_4B57
.text$mn:00004B50 ; ---------------------------------------------------------------------------
.text$mn:00004B50
.text$mn:00004B50 loc_4B50:                               ; CODE XREF: std::allocator<std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>>>::construct<std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>>,std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>>>(std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>> *,std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>> &&)+44j
.text$mn:00004B50                 mov     [ebp+var_14], 0
.text$mn:00004B57
.text$mn:00004B57 loc_4B57:                               ; CODE XREF: std::allocator<std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>>>::construct<std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>>,std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>>>(std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>> *,std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>> &&)+5Ej
.text$mn:00004B57                 mov     edx, [ebp+var_14]
.text$mn:00004B5A                 mov     [ebp+var_1C], edx
.text$mn:00004B5D                 mov     [ebp+var_4], 0FFFFFFFFh
.text$mn:00004B64                 mov     ecx, [ebp+var_C]
.text$mn:00004B67                 mov     large fs:0, ecx
.text$mn:00004B6E                 pop     ecx
.text$mn:00004B6F                 mov     esp, ebp
.text$mn:00004B71                 pop     ebp
.text$mn:00004B72                 retn    8
.text$mn:00004B72 ??$construct@V?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@V12@@?$allocator@V?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@@std@@QAEXPAV?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@1@$$QAV21@@Z endp
.text$mn:00004B72
.text$mn:00004B72 ; ---------------------------------------------------------------------------
.text$mn:00004B75                 align 4
.text$mn:00004B75 _text$mn        ends
.text$mn:00004B75
.text$x:00004B78 ; ===========================================================================
.text$x:00004B78
.text$x:00004B78 ; Segment type: Pure code
.text$x:00004B78 ; Segment permissions: Read/Execute
.text$x:00004B78 _text$x         segment para public 'CODE' use32
.text$x:00004B78                 assume cs:_text$x
.text$x:00004B78                 ;org 4B78h
.text$x:00004B78 ; COMDAT (pick associative to section at 4AF0)
.text$x:00004B78                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text$x:00004B78
.text$x:00004B78 ; =============== S U B R O U T I N E =======================================
.text$x:00004B78
.text$x:00004B78
.text$x:00004B78 __unwindfunclet$??$construct@V?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@V12@@?$allocator@V?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@@std@@QAEXPAV?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@1@$$QAV21@@Z$0 proc near
.text$x:00004B78                                         ; DATA XREF: .xdata$x:0000F074o
.text$x:00004B78                 mov     eax, [ebp+8]
.text$x:00004B7B                 push    eax
.text$x:00004B7C                 mov     eax, [ebp-10h]
.text$x:00004B7F                 push    eax             ; void *
.text$x:00004B80                 call    ??3@YAXPAX0@Z   ; operator delete(void *,void *)
.text$x:00004B85                 add     esp, 8
.text$x:00004B88                 retn
.text$x:00004B88 __unwindfunclet$??$construct@V?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@V12@@?$allocator@V?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@@std@@QAEXPAV?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@1@$$QAV21@@Z$0 endp
.text$x:00004B88
.text$x:00004B89
.text$x:00004B89 ; =============== S U B R O U T I N E =======================================
.text$x:00004B89
.text$x:00004B89
.text$x:00004B89 __ehhandler$??$construct@V?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@V12@@?$allocator@V?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@@std@@QAEXPAV?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@1@$$QAV21@@Z proc near
.text$x:00004B89                                         ; DATA XREF: std::allocator<std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>>>::construct<std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>>,std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>>>(std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>> *,std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>> &&)+5o
.text$x:00004B89
.text$x:00004B89 arg_4           = dword ptr  8
.text$x:00004B89
.text$x:00004B89                 mov     edx, [esp+arg_4]
.text$x:00004B8D                 lea     eax, [edx+0Ch]
.text$x:00004B90                 mov     ecx, [edx-14h]
.text$x:00004B93                 xor     ecx, eax
.text$x:00004B95                 call    @__security_check_cookie@4 ; __security_check_cookie(x)
.text$x:00004B9A                 mov     eax, offset __ehfuncinfo$??$construct@V?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@V12@@?$allocator@V?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@@std@@QAEXPAV?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@1@$$QAV21@@Z
.text$x:00004B9F                 jmp     ___CxxFrameHandler3
.text$x:00004B9F __ehhandler$??$construct@V?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@V12@@?$allocator@V?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@@std@@QAEXPAV?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@1@$$QAV21@@Z endp
.text$x:00004B9F
.text$x:00004B9F _text$x         ends
.text$x:00004B9F
.text$mn:00004BA4 ; ===========================================================================
.text$mn:00004BA4
.text$mn:00004BA4 ; Segment type: Pure code
.text$mn:00004BA4 ; Segment permissions: Read/Execute
.text$mn:00004BA4 _text$mn        segment para public 'CODE' use32
.text$mn:00004BA4                 assume cs:_text$mn
.text$mn:00004BA4                 ;org 4BA4h
.text$mn:00004BA4 ; COMDAT (pick any)
.text$mn:00004BA4                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text$mn:00004BA4
.text$mn:00004BA4 ; =============== S U B R O U T I N E =======================================
.text$mn:00004BA4
.text$mn:00004BA4 ; Attributes: bp-based frame
.text$mn:00004BA4
.text$mn:00004BA4 ; int __cdecl std::allocator_traits<std::allocator<std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>>>>::construct<std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>>,std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>>>(int, void *, int)
.text$mn:00004BA4                 public ??$construct@V?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@V12@@?$allocator_traits@V?$allocator@V?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@@std@@@std@@SAXAAV?$allocator@V?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@@1@PAV?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@1@$$QAV31@@Z
.text$mn:00004BA4 ??$construct@V?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@V12@@?$allocator_traits@V?$allocator@V?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@@std@@@std@@SAXAAV?$allocator@V?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@@1@PAV?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@1@$$QAV31@@Z proc near
.text$mn:00004BA4                                         ; CODE XREF: std::_Wrap_alloc<std::allocator<std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>>>>::construct<std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>>,std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>>>(std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>> *,std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>> &&)+1Cp
.text$mn:00004BA4
.text$mn:00004BA4 arg_0           = dword ptr  8
.text$mn:00004BA4 arg_4           = dword ptr  0Ch
.text$mn:00004BA4 arg_8           = dword ptr  10h
.text$mn:00004BA4
.text$mn:00004BA4                 push    ebp
.text$mn:00004BA5                 mov     ebp, esp
.text$mn:00004BA7                 mov     eax, [ebp+arg_8]
.text$mn:00004BAA                 push    eax
.text$mn:00004BAB                 call    ??$forward@V?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@@std@@YA$$QAV?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@0@AAV10@@Z ; std::forward<std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>>>(std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>> &)
.text$mn:00004BB0                 add     esp, 4
.text$mn:00004BB3                 push    eax             ; int
.text$mn:00004BB4                 mov     ecx, [ebp+arg_4]
.text$mn:00004BB7                 push    ecx             ; void *
.text$mn:00004BB8                 mov     ecx, [ebp+arg_0]
.text$mn:00004BBB                 call    ??$construct@V?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@V12@@?$allocator@V?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@@std@@QAEXPAV?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@1@$$QAV21@@Z ; std::allocator<std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>>>::construct<std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>>,std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>>>(std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>> *,std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>> &&)
.text$mn:00004BC0                 pop     ebp
.text$mn:00004BC1                 retn
.text$mn:00004BC1 ??$construct@V?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@V12@@?$allocator_traits@V?$allocator@V?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@@std@@@std@@SAXAAV?$allocator@V?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@@1@PAV?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@1@$$QAV31@@Z endp
.text$mn:00004BC1
.text$mn:00004BC1 ; ---------------------------------------------------------------------------
.text$mn:00004BC2                 align 4
.text$mn:00004BC2 _text$mn        ends
.text$mn:00004BC2
.text$mn:00004BC4 ; ===========================================================================
.text$mn:00004BC4
.text$mn:00004BC4 ; Segment type: Pure code
.text$mn:00004BC4 ; Segment permissions: Read/Execute
.text$mn:00004BC4 _text$mn        segment para public 'CODE' use32
.text$mn:00004BC4                 assume cs:_text$mn
.text$mn:00004BC4                 ;org 4BC4h
.text$mn:00004BC4 ; COMDAT (pick any)
.text$mn:00004BC4                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text$mn:00004BC4
.text$mn:00004BC4 ; =============== S U B R O U T I N E =======================================
.text$mn:00004BC4
.text$mn:00004BC4 ; Attributes: bp-based frame
.text$mn:00004BC4
.text$mn:00004BC4 ; int __stdcall std::_Wrap_alloc<std::allocator<wchar_t>>::construct<wchar_t,wchar_t>(void *, int)
.text$mn:00004BC4                 public ??$construct@_W_W@?$_Wrap_alloc@V?$allocator@_W@std@@@std@@QAEXPA_W$$QA_W@Z
.text$mn:00004BC4 ??$construct@_W_W@?$_Wrap_alloc@V?$allocator@_W@std@@@std@@QAEXPA_W$$QA_W@Z proc near
.text$mn:00004BC4                                         ; CODE XREF: std::vector<wchar_t,std::allocator<wchar_t>>::push_back(wchar_t &&)+99p
.text$mn:00004BC4                                         ; std::vector<wchar_t,std::allocator<wchar_t>>::push_back(wchar_t &&)+FFp
.text$mn:00004BC4
.text$mn:00004BC4 var_4           = dword ptr -4
.text$mn:00004BC4 arg_0           = dword ptr  8
.text$mn:00004BC4 arg_4           = dword ptr  0Ch
.text$mn:00004BC4
.text$mn:00004BC4                 push    ebp
.text$mn:00004BC5                 mov     ebp, esp
.text$mn:00004BC7                 push    ecx
.text$mn:00004BC8                 mov     [ebp+var_4], ecx
.text$mn:00004BCB                 mov     eax, [ebp+arg_4]
.text$mn:00004BCE                 push    eax
.text$mn:00004BCF                 call    ??$forward@_W@std@@YA$$QA_WAA_W@Z ; std::forward<wchar_t>(wchar_t &)
.text$mn:00004BD4                 add     esp, 4
.text$mn:00004BD7                 push    eax             ; int
.text$mn:00004BD8                 mov     ecx, [ebp+arg_0]
.text$mn:00004BDB                 push    ecx             ; void *
.text$mn:00004BDC                 mov     edx, [ebp+var_4]
.text$mn:00004BDF                 push    edx             ; int
.text$mn:00004BE0                 call    ??$construct@_W_W@?$allocator_traits@V?$allocator@_W@std@@@std@@SAXAAV?$allocator@_W@1@PA_W$$QA_W@Z ; std::allocator_traits<std::allocator<wchar_t>>::construct<wchar_t,wchar_t>(std::allocator<wchar_t> &,wchar_t *,wchar_t &&)
.text$mn:00004BE5                 add     esp, 0Ch
.text$mn:00004BE8                 mov     esp, ebp
.text$mn:00004BEA                 pop     ebp
.text$mn:00004BEB                 retn    8
.text$mn:00004BEB ??$construct@_W_W@?$_Wrap_alloc@V?$allocator@_W@std@@@std@@QAEXPA_W$$QA_W@Z endp
.text$mn:00004BEB
.text$mn:00004BEB ; ---------------------------------------------------------------------------
.text$mn:00004BEE                 align 10h
.text$mn:00004BEE _text$mn        ends
.text$mn:00004BEE
.text$mn:00004BF0 ; ===========================================================================
.text$mn:00004BF0
.text$mn:00004BF0 ; Segment type: Pure code
.text$mn:00004BF0 ; Segment permissions: Read/Execute
.text$mn:00004BF0 _text$mn        segment para public 'CODE' use32
.text$mn:00004BF0                 assume cs:_text$mn
.text$mn:00004BF0                 ;org 4BF0h
.text$mn:00004BF0 ; COMDAT (pick any)
.text$mn:00004BF0                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text$mn:00004BF0
.text$mn:00004BF0 ; =============== S U B R O U T I N E =======================================
.text$mn:00004BF0
.text$mn:00004BF0 ; Attributes: bp-based frame
.text$mn:00004BF0
.text$mn:00004BF0 ; int __stdcall std::allocator<wchar_t>::construct<wchar_t,wchar_t>(void *, int)
.text$mn:00004BF0                 public ??$construct@_W_W@?$allocator@_W@std@@QAEXPA_W$$QA_W@Z
.text$mn:00004BF0 ??$construct@_W_W@?$allocator@_W@std@@QAEXPA_W$$QA_W@Z proc near
.text$mn:00004BF0                                         ; CODE XREF: std::allocator_traits<std::allocator<wchar_t>>::construct<wchar_t,wchar_t>(std::allocator<wchar_t> &,wchar_t *,wchar_t &&)+17p
.text$mn:00004BF0
.text$mn:00004BF0 var_1C          = dword ptr -1Ch
.text$mn:00004BF0 var_18          = dword ptr -18h
.text$mn:00004BF0 var_14          = dword ptr -14h
.text$mn:00004BF0 var_10          = dword ptr -10h
.text$mn:00004BF0 var_C           = dword ptr -0Ch
.text$mn:00004BF0 var_4           = dword ptr -4
.text$mn:00004BF0 arg_0           = dword ptr  8
.text$mn:00004BF0 arg_4           = dword ptr  0Ch
.text$mn:00004BF0
.text$mn:00004BF0                 push    ebp
.text$mn:00004BF1                 mov     ebp, esp
.text$mn:00004BF3                 push    0FFFFFFFFh
.text$mn:00004BF5                 push    offset __ehhandler$??$construct@_W_W@?$allocator@_W@std@@QAEXPA_W$$QA_W@Z
.text$mn:00004BFA                 mov     eax, large fs:0
.text$mn:00004C00                 push    eax
.text$mn:00004C01                 sub     esp, 10h
.text$mn:00004C04                 mov     eax, dword ptr ds:___security_cookie
.text$mn:00004C09                 xor     eax, ebp
.text$mn:00004C0B                 push    eax
.text$mn:00004C0C                 lea     eax, [ebp+var_C]
.text$mn:00004C0F                 mov     large fs:0, eax
.text$mn:00004C15                 mov     [ebp+var_18], ecx
.text$mn:00004C18                 mov     eax, [ebp+arg_0]
.text$mn:00004C1B                 push    eax             ; void *
.text$mn:00004C1C                 push    2               ; unsigned int
.text$mn:00004C1E                 call    ??2@YAPAXIPAX@Z ; operator new(uint,void *)
.text$mn:00004C23                 add     esp, 8
.text$mn:00004C26                 mov     [ebp+var_10], eax
.text$mn:00004C29                 mov     [ebp+var_4], 0
.text$mn:00004C30                 cmp     [ebp+var_10], 0
.text$mn:00004C34                 jz      short loc_4C53
.text$mn:00004C36                 mov     ecx, [ebp+arg_4]
.text$mn:00004C39                 push    ecx
.text$mn:00004C3A                 call    ??$forward@_W@std@@YA$$QA_WAA_W@Z ; std::forward<wchar_t>(wchar_t &)
.text$mn:00004C3F                 add     esp, 4
.text$mn:00004C42                 mov     edx, [ebp+var_10]
.text$mn:00004C45                 mov     ax, [eax]
.text$mn:00004C48                 mov     [edx], ax
.text$mn:00004C4B                 mov     ecx, [ebp+var_10]
.text$mn:00004C4E                 mov     [ebp+var_14], ecx
.text$mn:00004C51                 jmp     short loc_4C5A
.text$mn:00004C53 ; ---------------------------------------------------------------------------
.text$mn:00004C53
.text$mn:00004C53 loc_4C53:                               ; CODE XREF: std::allocator<wchar_t>::construct<wchar_t,wchar_t>(wchar_t *,wchar_t &&)+44j
.text$mn:00004C53                 mov     [ebp+var_14], 0
.text$mn:00004C5A
.text$mn:00004C5A loc_4C5A:                               ; CODE XREF: std::allocator<wchar_t>::construct<wchar_t,wchar_t>(wchar_t *,wchar_t &&)+61j
.text$mn:00004C5A                 mov     edx, [ebp+var_14]
.text$mn:00004C5D                 mov     [ebp+var_1C], edx
.text$mn:00004C60                 mov     [ebp+var_4], 0FFFFFFFFh
.text$mn:00004C67                 mov     ecx, [ebp+var_C]
.text$mn:00004C6A                 mov     large fs:0, ecx
.text$mn:00004C71                 pop     ecx
.text$mn:00004C72                 mov     esp, ebp
.text$mn:00004C74                 pop     ebp
.text$mn:00004C75                 retn    8
.text$mn:00004C75 ??$construct@_W_W@?$allocator@_W@std@@QAEXPA_W$$QA_W@Z endp
.text$mn:00004C75
.text$mn:00004C75 _text$mn        ends
.text$mn:00004C75
.text$x:00004C78 ; ===========================================================================
.text$x:00004C78
.text$x:00004C78 ; Segment type: Pure code
.text$x:00004C78 ; Segment permissions: Read/Execute
.text$x:00004C78 _text$x         segment para public 'CODE' use32
.text$x:00004C78                 assume cs:_text$x
.text$x:00004C78                 ;org 4C78h
.text$x:00004C78 ; COMDAT (pick associative to section at 4BF0)
.text$x:00004C78                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text$x:00004C78
.text$x:00004C78 ; =============== S U B R O U T I N E =======================================
.text$x:00004C78
.text$x:00004C78
.text$x:00004C78 __unwindfunclet$??$construct@_W_W@?$allocator@_W@std@@QAEXPA_W$$QA_W@Z$0 proc near
.text$x:00004C78                                         ; DATA XREF: .xdata$x:0000F0A0o
.text$x:00004C78                 mov     eax, [ebp+8]
.text$x:00004C7B                 push    eax
.text$x:00004C7C                 mov     eax, [ebp-10h]
.text$x:00004C7F                 push    eax             ; void *
.text$x:00004C80                 call    ??3@YAXPAX0@Z   ; operator delete(void *,void *)
.text$x:00004C85                 add     esp, 8
.text$x:00004C88                 retn
.text$x:00004C88 __unwindfunclet$??$construct@_W_W@?$allocator@_W@std@@QAEXPA_W$$QA_W@Z$0 endp
.text$x:00004C88
.text$x:00004C89
.text$x:00004C89 ; =============== S U B R O U T I N E =======================================
.text$x:00004C89
.text$x:00004C89
.text$x:00004C89 __ehhandler$??$construct@_W_W@?$allocator@_W@std@@QAEXPA_W$$QA_W@Z proc near
.text$x:00004C89                                         ; DATA XREF: std::allocator<wchar_t>::construct<wchar_t,wchar_t>(wchar_t *,wchar_t &&)+5o
.text$x:00004C89
.text$x:00004C89 arg_4           = dword ptr  8
.text$x:00004C89
.text$x:00004C89                 mov     edx, [esp+arg_4]
.text$x:00004C8D                 lea     eax, [edx+0Ch]
.text$x:00004C90                 mov     ecx, [edx-14h]
.text$x:00004C93                 xor     ecx, eax
.text$x:00004C95                 call    @__security_check_cookie@4 ; __security_check_cookie(x)
.text$x:00004C9A                 mov     eax, offset __ehfuncinfo$??$construct@_W_W@?$allocator@_W@std@@QAEXPA_W$$QA_W@Z
.text$x:00004C9F                 jmp     ___CxxFrameHandler3
.text$x:00004C9F __ehhandler$??$construct@_W_W@?$allocator@_W@std@@QAEXPA_W$$QA_W@Z endp
.text$x:00004C9F
.text$x:00004C9F _text$x         ends
.text$x:00004C9F
.text$mn:00004CA4 ; ===========================================================================
.text$mn:00004CA4
.text$mn:00004CA4 ; Segment type: Pure code
.text$mn:00004CA4 ; Segment permissions: Read/Execute
.text$mn:00004CA4 _text$mn        segment para public 'CODE' use32
.text$mn:00004CA4                 assume cs:_text$mn
.text$mn:00004CA4                 ;org 4CA4h
.text$mn:00004CA4 ; COMDAT (pick any)
.text$mn:00004CA4                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text$mn:00004CA4
.text$mn:00004CA4 ; =============== S U B R O U T I N E =======================================
.text$mn:00004CA4
.text$mn:00004CA4 ; Attributes: bp-based frame
.text$mn:00004CA4
.text$mn:00004CA4 ; int __cdecl std::allocator_traits<std::allocator<wchar_t>>::construct<wchar_t,wchar_t>(int, void *, int)
.text$mn:00004CA4                 public ??$construct@_W_W@?$allocator_traits@V?$allocator@_W@std@@@std@@SAXAAV?$allocator@_W@1@PA_W$$QA_W@Z
.text$mn:00004CA4 ??$construct@_W_W@?$allocator_traits@V?$allocator@_W@std@@@std@@SAXAAV?$allocator@_W@1@PA_W$$QA_W@Z proc near
.text$mn:00004CA4                                         ; CODE XREF: std::_Wrap_alloc<std::allocator<wchar_t>>::construct<wchar_t,wchar_t>(wchar_t *,wchar_t &&)+1Cp
.text$mn:00004CA4
.text$mn:00004CA4 arg_0           = dword ptr  8
.text$mn:00004CA4 arg_4           = dword ptr  0Ch
.text$mn:00004CA4 arg_8           = dword ptr  10h
.text$mn:00004CA4
.text$mn:00004CA4                 push    ebp
.text$mn:00004CA5                 mov     ebp, esp
.text$mn:00004CA7                 mov     eax, [ebp+arg_8]
.text$mn:00004CAA                 push    eax
.text$mn:00004CAB                 call    ??$forward@_W@std@@YA$$QA_WAA_W@Z ; std::forward<wchar_t>(wchar_t &)
.text$mn:00004CB0                 add     esp, 4
.text$mn:00004CB3                 push    eax             ; int
.text$mn:00004CB4                 mov     ecx, [ebp+arg_4]
.text$mn:00004CB7                 push    ecx             ; void *
.text$mn:00004CB8                 mov     ecx, [ebp+arg_0]
.text$mn:00004CBB                 call    ??$construct@_W_W@?$allocator@_W@std@@QAEXPA_W$$QA_W@Z ; std::allocator<wchar_t>::construct<wchar_t,wchar_t>(wchar_t *,wchar_t &&)
.text$mn:00004CC0                 pop     ebp
.text$mn:00004CC1                 retn
.text$mn:00004CC1 ??$construct@_W_W@?$allocator_traits@V?$allocator@_W@std@@@std@@SAXAAV?$allocator@_W@1@PA_W$$QA_W@Z endp
.text$mn:00004CC1
.text$mn:00004CC1 ; ---------------------------------------------------------------------------
.text$mn:00004CC2                 align 4
.text$mn:00004CC2 _text$mn        ends
.text$mn:00004CC2
.text$mn:00004CC4 ; ===========================================================================
.text$mn:00004CC4
.text$mn:00004CC4 ; Segment type: Pure code
.text$mn:00004CC4 ; Segment permissions: Read/Execute
.text$mn:00004CC4 _text$mn        segment para public 'CODE' use32
.text$mn:00004CC4                 assume cs:_text$mn
.text$mn:00004CC4                 ;org 4CC4h
.text$mn:00004CC4 ; COMDAT (pick any)
.text$mn:00004CC4                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text$mn:00004CC4
.text$mn:00004CC4 ; =============== S U B R O U T I N E =======================================
.text$mn:00004CC4
.text$mn:00004CC4 ; Attributes: bp-based frame
.text$mn:00004CC4
.text$mn:00004CC4 ; class std::basic_string<wchar_t, struct std::char_traits<wchar_t>, class std::allocator<wchar_t>> __cdecl convertFileName<class std::_String_const_iterator<class std::_String_val<struct std::_Simple_types<wchar_t>>>>(class std::_String_const_iterator<class std::_String_val<struct std::_Simple_types<wchar_t>>>, class std::_String_const_iterator<class std::_String_val<struct std::_Simple_types<wchar_t>>>)
.text$mn:00004CC4                 public ??$convertFileName@V?$_String_const_iterator@V?$_String_val@U?$_Simple_types@_W@std@@@std@@@std@@@@YA?AV?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@V?$_String_const_iterator@V?$_String_val@U?$_Simple_types@_W@std@@@std@@@1@0@Z
.text$mn:00004CC4 ??$convertFileName@V?$_String_const_iterator@V?$_String_val@U?$_Simple_types@_W@std@@@std@@@std@@@@YA?AV?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@V?$_String_const_iterator@V?$_String_val@U?$_Simple_types@_W@std@@@std@@@1@0@Z proc near
.text$mn:00004CC4                                         ; CODE XREF: BuildMenuFileName(int,uint,std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>> const &)+339p
.text$mn:00004CC4                                         ; BuildMenuFileName(int,uint,std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>> const &)+408p ...
.text$mn:00004CC4
.text$mn:00004CC4 var_3C          = byte ptr -3Ch
.text$mn:00004CC4 var_30          = dword ptr -30h
.text$mn:00004CC4 var_2C          = byte ptr -2Ch
.text$mn:00004CC4 var_10          = dword ptr -10h
.text$mn:00004CC4 var_C           = dword ptr -0Ch
.text$mn:00004CC4 var_4           = dword ptr -4
.text$mn:00004CC4 arg_0           = dword ptr  8
.text$mn:00004CC4 arg_4           = byte ptr  0Ch
.text$mn:00004CC4 arg_10          = byte ptr  18h
.text$mn:00004CC4
.text$mn:00004CC4                 push    ebp
.text$mn:00004CC5                 mov     ebp, esp
.text$mn:00004CC7                 push    0FFFFFFFFh
.text$mn:00004CC9                 push    offset __ehhandler$??$convertFileName@V?$_String_const_iterator@V?$_String_val@U?$_Simple_types@_W@std@@@std@@@std@@@@YA?AV?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@V?$_String_const_iterator@V?$_String_val@U?$_Simple_types@_W@std@@@std@@@1@0@Z
.text$mn:00004CCE                 mov     eax, large fs:0
.text$mn:00004CD4                 push    eax
.text$mn:00004CD5                 sub     esp, 30h
.text$mn:00004CD8                 mov     eax, dword ptr ds:___security_cookie
.text$mn:00004CDD                 xor     eax, ebp
.text$mn:00004CDF                 mov     [ebp+var_10], eax
.text$mn:00004CE2                 push    eax
.text$mn:00004CE3                 lea     eax, [ebp+var_C]
.text$mn:00004CE6                 mov     large fs:0, eax
.text$mn:00004CEC                 mov     [ebp+var_30], 0
.text$mn:00004CF3                 mov     [ebp+var_4], 2
.text$mn:00004CFA                 lea     ecx, [ebp+var_2C]
.text$mn:00004CFD                 call    ??0?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QAE@XZ ; std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>>::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>>(void)
.text$mn:00004D02                 mov     byte ptr [ebp+var_4], 3
.text$mn:00004D06                 lea     eax, [ebp+arg_4]
.text$mn:00004D09                 push    eax             ; struct std::_Iterator_base12 *
.text$mn:00004D0A                 lea     ecx, [ebp+var_3C]
.text$mn:00004D0D                 call    ??0?$_String_const_iterator@V?$_String_val@U?$_Simple_types@_W@std@@@std@@@std@@QAE@ABV01@@Z ; std::_String_const_iterator<std::_String_val<std::_Simple_types<wchar_t>>>::_String_const_iterator<std::_String_val<std::_Simple_types<wchar_t>>>(std::_String_const_iterator<std::_String_val<std::_Simple_types<wchar_t>>> const &)
.text$mn:00004D12                 mov     byte ptr [ebp+var_4], 4
.text$mn:00004D16                 jmp     short loc_4D20
.text$mn:00004D18 ; ---------------------------------------------------------------------------
.text$mn:00004D18
.text$mn:00004D18 loc_4D18:                               ; CODE XREF: convertFileName<std::_String_const_iterator<std::_String_val<std::_Simple_types<wchar_t>>>>(std::_String_const_iterator<std::_String_val<std::_Simple_types<wchar_t>>>,std::_String_const_iterator<std::_String_val<std::_Simple_types<wchar_t>>>)+A0j
.text$mn:00004D18                 lea     ecx, [ebp+var_3C]
.text$mn:00004D1B                 call    ??E?$_String_const_iterator@V?$_String_val@U?$_Simple_types@_W@std@@@std@@@std@@QAEAAV01@XZ ; std::_String_const_iterator<std::_String_val<std::_Simple_types<wchar_t>>>::operator++(void)
.text$mn:00004D20
.text$mn:00004D20 loc_4D20:                               ; CODE XREF: convertFileName<std::_String_const_iterator<std::_String_val<std::_Simple_types<wchar_t>>>>(std::_String_const_iterator<std::_String_val<std::_Simple_types<wchar_t>>>,std::_String_const_iterator<std::_String_val<std::_Simple_types<wchar_t>>>)+52j
.text$mn:00004D20                 lea     ecx, [ebp+arg_10]
.text$mn:00004D23                 push    ecx             ; std::_Iterator_base12 *
.text$mn:00004D24                 lea     ecx, [ebp+var_3C]
.text$mn:00004D27                 call    ??9?$_String_const_iterator@V?$_String_val@U?$_Simple_types@_W@std@@@std@@@std@@QBE_NABV01@@Z ; std::_String_const_iterator<std::_String_val<std::_Simple_types<wchar_t>>>::operator!=(std::_String_const_iterator<std::_String_val<std::_Simple_types<wchar_t>>> const &)
.text$mn:00004D2C                 movzx   edx, al
.text$mn:00004D2F                 test    edx, edx
.text$mn:00004D31                 jz      short loc_4D66
.text$mn:00004D33                 lea     ecx, [ebp+var_3C]
.text$mn:00004D36                 call    ??D?$_String_const_iterator@V?$_String_val@U?$_Simple_types@_W@std@@@std@@@std@@QBEAB_WXZ ; std::_String_const_iterator<std::_String_val<std::_Simple_types<wchar_t>>>::operator*(void)
.text$mn:00004D3B                 movzx   eax, word ptr [eax]
.text$mn:00004D3E                 cmp     eax, 26h ; '&'
.text$mn:00004D41                 jnz     short loc_4D4D
.text$mn:00004D43                 push    26h ; '&'
.text$mn:00004D45                 lea     ecx, [ebp+var_2C]
.text$mn:00004D48                 call    ?push_back@?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QAEX_W@Z ; std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>>::push_back(wchar_t)
.text$mn:00004D4D
.text$mn:00004D4D loc_4D4D:                               ; CODE XREF: convertFileName<std::_String_const_iterator<std::_String_val<std::_Simple_types<wchar_t>>>>(std::_String_const_iterator<std::_String_val<std::_Simple_types<wchar_t>>>,std::_String_const_iterator<std::_String_val<std::_Simple_types<wchar_t>>>)+7Dj
.text$mn:00004D4D                 lea     ecx, [ebp+var_3C]
.text$mn:00004D50                 call    ??D?$_String_const_iterator@V?$_String_val@U?$_Simple_types@_W@std@@@std@@@std@@QBEAB_WXZ ; std::_String_const_iterator<std::_String_val<std::_Simple_types<wchar_t>>>::operator*(void)
.text$mn:00004D55                 mov     cx, [eax]
.text$mn:00004D58                 movzx   edx, cx
.text$mn:00004D5B                 push    edx
.text$mn:00004D5C                 lea     ecx, [ebp+var_2C]
.text$mn:00004D5F                 call    ?push_back@?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QAEX_W@Z ; std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>>::push_back(wchar_t)
.text$mn:00004D64                 jmp     short loc_4D18
.text$mn:00004D66 ; ---------------------------------------------------------------------------
.text$mn:00004D66
.text$mn:00004D66 loc_4D66:                               ; CODE XREF: convertFileName<std::_String_const_iterator<std::_String_val<std::_Simple_types<wchar_t>>>>(std::_String_const_iterator<std::_String_val<std::_Simple_types<wchar_t>>>,std::_String_const_iterator<std::_String_val<std::_Simple_types<wchar_t>>>)+6Dj
.text$mn:00004D66                 mov     byte ptr [ebp+var_4], 3
.text$mn:00004D6A                 lea     ecx, [ebp+var_3C]
.text$mn:00004D6D                 call    ??1?$_String_const_iterator@V?$_String_val@U?$_Simple_types@_W@std@@@std@@@std@@QAE@XZ ; std::_String_const_iterator<std::_String_val<std::_Simple_types<wchar_t>>>::~_String_const_iterator<std::_String_val<std::_Simple_types<wchar_t>>>(void)
.text$mn:00004D72                 lea     eax, [ebp+var_2C]
.text$mn:00004D75                 push    eax
.text$mn:00004D76                 mov     ecx, [ebp+arg_0]
.text$mn:00004D79                 call    ??0?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QAE@$$QAV01@@Z ; std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>>::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>>(std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>> &&)
.text$mn:00004D7E                 mov     ecx, [ebp+var_30]
.text$mn:00004D81                 or      ecx, 1
.text$mn:00004D84                 mov     [ebp+var_30], ecx
.text$mn:00004D87                 mov     byte ptr [ebp+var_4], 2
.text$mn:00004D8B                 lea     ecx, [ebp+var_2C]
.text$mn:00004D8E                 call    ??1?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QAE@XZ ; std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>>::~basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>>(void)
.text$mn:00004D93                 mov     byte ptr [ebp+var_4], 1
.text$mn:00004D97                 lea     ecx, [ebp+arg_4]
.text$mn:00004D9A                 call    ??1?$_String_const_iterator@V?$_String_val@U?$_Simple_types@_W@std@@@std@@@std@@QAE@XZ ; std::_String_const_iterator<std::_String_val<std::_Simple_types<wchar_t>>>::~_String_const_iterator<std::_String_val<std::_Simple_types<wchar_t>>>(void)
.text$mn:00004D9F                 mov     byte ptr [ebp+var_4], 0
.text$mn:00004DA3                 lea     ecx, [ebp+arg_10]
.text$mn:00004DA6                 call    ??1?$_String_const_iterator@V?$_String_val@U?$_Simple_types@_W@std@@@std@@@std@@QAE@XZ ; std::_String_const_iterator<std::_String_val<std::_Simple_types<wchar_t>>>::~_String_const_iterator<std::_String_val<std::_Simple_types<wchar_t>>>(void)
.text$mn:00004DAB                 mov     eax, [ebp+arg_0]
.text$mn:00004DAE                 mov     ecx, [ebp+var_C]
.text$mn:00004DB1                 mov     large fs:0, ecx
.text$mn:00004DB8                 pop     ecx
.text$mn:00004DB9                 mov     ecx, [ebp+var_10]
.text$mn:00004DBC                 xor     ecx, ebp
.text$mn:00004DBE                 call    @__security_check_cookie@4 ; __security_check_cookie(x)
.text$mn:00004DC3                 mov     esp, ebp
.text$mn:00004DC5                 pop     ebp
.text$mn:00004DC6                 retn
.text$mn:00004DC6 ??$convertFileName@V?$_String_const_iterator@V?$_String_val@U?$_Simple_types@_W@std@@@std@@@std@@@@YA?AV?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@V?$_String_const_iterator@V?$_String_val@U?$_Simple_types@_W@std@@@std@@@1@0@Z endp
.text$mn:00004DC6
.text$mn:00004DC6 ; ---------------------------------------------------------------------------
.text$mn:00004DC7                 align 4
.text$mn:00004DC7 _text$mn        ends
.text$mn:00004DC7
.text$x:00004DC8 ; ===========================================================================
.text$x:00004DC8
.text$x:00004DC8 ; Segment type: Pure code
.text$x:00004DC8 ; Segment permissions: Read/Execute
.text$x:00004DC8 _text$x         segment para public 'CODE' use32
.text$x:00004DC8                 assume cs:_text$x
.text$x:00004DC8                 ;org 4DC8h
.text$x:00004DC8 ; COMDAT (pick associative to section at 4CC4)
.text$x:00004DC8                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text$x:00004DC8
.text$x:00004DC8 ; =============== S U B R O U T I N E =======================================
.text$x:00004DC8
.text$x:00004DC8
.text$x:00004DC8 __unwindfunclet$??$convertFileName@V?$_String_const_iterator@V?$_String_val@U?$_Simple_types@_W@std@@@std@@@std@@@@YA?AV?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@V?$_String_const_iterator@V?$_String_val@U?$_Simple_types@_W@std@@@std@@@1@0@Z$0 proc near
.text$x:00004DC8                                         ; DATA XREF: .xdata$x:0000EC9Co
.text$x:00004DC8                 lea     ecx, [ebp+18h]
.text$x:00004DCB                 jmp     ??1?$_String_const_iterator@V?$_String_val@U?$_Simple_types@_W@std@@@std@@@std@@QAE@XZ ; std::_String_const_iterator<std::_String_val<std::_Simple_types<wchar_t>>>::~_String_const_iterator<std::_String_val<std::_Simple_types<wchar_t>>>(void)
.text$x:00004DCB __unwindfunclet$??$convertFileName@V?$_String_const_iterator@V?$_String_val@U?$_Simple_types@_W@std@@@std@@@std@@@@YA?AV?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@V?$_String_const_iterator@V?$_String_val@U?$_Simple_types@_W@std@@@std@@@1@0@Z$0 endp
.text$x:00004DCB
.text$x:00004DD0
.text$x:00004DD0 ; =============== S U B R O U T I N E =======================================
.text$x:00004DD0
.text$x:00004DD0
.text$x:00004DD0 __unwindfunclet$??$convertFileName@V?$_String_const_iterator@V?$_String_val@U?$_Simple_types@_W@std@@@std@@@std@@@@YA?AV?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@V?$_String_const_iterator@V?$_String_val@U?$_Simple_types@_W@std@@@std@@@1@0@Z$1 proc near
.text$x:00004DD0                                         ; DATA XREF: .xdata$x:0000ECA4o
.text$x:00004DD0                 lea     ecx, [ebp+0Ch]
.text$x:00004DD3                 jmp     ??1?$_String_const_iterator@V?$_String_val@U?$_Simple_types@_W@std@@@std@@@std@@QAE@XZ ; std::_String_const_iterator<std::_String_val<std::_Simple_types<wchar_t>>>::~_String_const_iterator<std::_String_val<std::_Simple_types<wchar_t>>>(void)
.text$x:00004DD3 __unwindfunclet$??$convertFileName@V?$_String_const_iterator@V?$_String_val@U?$_Simple_types@_W@std@@@std@@@std@@@@YA?AV?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@V?$_String_const_iterator@V?$_String_val@U?$_Simple_types@_W@std@@@std@@@1@0@Z$1 endp
.text$x:00004DD3
.text$x:00004DD8
.text$x:00004DD8 ; =============== S U B R O U T I N E =======================================
.text$x:00004DD8
.text$x:00004DD8
.text$x:00004DD8 __unwindfunclet$??$convertFileName@V?$_String_const_iterator@V?$_String_val@U?$_Simple_types@_W@std@@@std@@@std@@@@YA?AV?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@V?$_String_const_iterator@V?$_String_val@U?$_Simple_types@_W@std@@@std@@@1@0@Z$2 proc near
.text$x:00004DD8                                         ; DATA XREF: .xdata$x:0000ECACo
.text$x:00004DD8                 lea     ecx, [ebp-2Ch]
.text$x:00004DDB                 jmp     ??1?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QAE@XZ ; std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>>::~basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>>(void)
.text$x:00004DDB __unwindfunclet$??$convertFileName@V?$_String_const_iterator@V?$_String_val@U?$_Simple_types@_W@std@@@std@@@std@@@@YA?AV?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@V?$_String_const_iterator@V?$_String_val@U?$_Simple_types@_W@std@@@std@@@1@0@Z$2 endp
.text$x:00004DDB
.text$x:00004DE0
.text$x:00004DE0 ; =============== S U B R O U T I N E =======================================
.text$x:00004DE0
.text$x:00004DE0
.text$x:00004DE0 __unwindfunclet$??$convertFileName@V?$_String_const_iterator@V?$_String_val@U?$_Simple_types@_W@std@@@std@@@std@@@@YA?AV?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@V?$_String_const_iterator@V?$_String_val@U?$_Simple_types@_W@std@@@std@@@1@0@Z$3 proc near
.text$x:00004DE0                                         ; DATA XREF: .xdata$x:0000ECB4o
.text$x:00004DE0                 lea     ecx, [ebp-3Ch]
.text$x:00004DE3                 jmp     ??1?$_String_const_iterator@V?$_String_val@U?$_Simple_types@_W@std@@@std@@@std@@QAE@XZ ; std::_String_const_iterator<std::_String_val<std::_Simple_types<wchar_t>>>::~_String_const_iterator<std::_String_val<std::_Simple_types<wchar_t>>>(void)
.text$x:00004DE3 __unwindfunclet$??$convertFileName@V?$_String_const_iterator@V?$_String_val@U?$_Simple_types@_W@std@@@std@@@std@@@@YA?AV?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@V?$_String_const_iterator@V?$_String_val@U?$_Simple_types@_W@std@@@std@@@1@0@Z$3 endp
.text$x:00004DE3
.text$x:00004DE8
.text$x:00004DE8 ; =============== S U B R O U T I N E =======================================
.text$x:00004DE8
.text$x:00004DE8
.text$x:00004DE8 __unwindfunclet$??$convertFileName@V?$_String_const_iterator@V?$_String_val@U?$_Simple_types@_W@std@@@std@@@std@@@@YA?AV?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@V?$_String_const_iterator@V?$_String_val@U?$_Simple_types@_W@std@@@std@@@1@0@Z$4 proc near
.text$x:00004DE8                                         ; DATA XREF: .xdata$x:0000EC94o
.text$x:00004DE8                 mov     eax, [ebp-30h]
.text$x:00004DEB                 and     eax, 1
.text$x:00004DEE                 jz      $LN12_0
.text$x:00004DF4                 and     dword ptr [ebp-30h], 0FFFFFFFEh
.text$x:00004DF8                 mov     ecx, [ebp+8]
.text$x:00004DFB                 jmp     ??1?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QAE@XZ ; std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>>::~basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>>(void)
.text$x:00004E00 ; ---------------------------------------------------------------------------
.text$x:00004E00
.text$x:00004E00 $LN12_0:                                ; CODE XREF: __unwindfunclet$??$convertFileName@V?$_String_const_iterator@V?$_String_val@U?$_Simple_types@_W@std@@@std@@@std@@@@YA?AV?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@V?$_String_const_iterator@V?$_String_val@U?$_Simple_types@_W@std@@@std@@@1@0@Z$4+6j
.text$x:00004E00                 retn
.text$x:00004E00 __unwindfunclet$??$convertFileName@V?$_String_const_iterator@V?$_String_val@U?$_Simple_types@_W@std@@@std@@@std@@@@YA?AV?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@V?$_String_const_iterator@V?$_String_val@U?$_Simple_types@_W@std@@@std@@@1@0@Z$4 endp
.text$x:00004E00
.text$x:00004E01
.text$x:00004E01 ; =============== S U B R O U T I N E =======================================
.text$x:00004E01
.text$x:00004E01
.text$x:00004E01 __ehhandler$??$convertFileName@V?$_String_const_iterator@V?$_String_val@U?$_Simple_types@_W@std@@@std@@@std@@@@YA?AV?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@V?$_String_const_iterator@V?$_String_val@U?$_Simple_types@_W@std@@@std@@@1@0@Z proc near
.text$x:00004E01                                         ; DATA XREF: convertFileName<std::_String_const_iterator<std::_String_val<std::_Simple_types<wchar_t>>>>(std::_String_const_iterator<std::_String_val<std::_Simple_types<wchar_t>>>,std::_String_const_iterator<std::_String_val<std::_Simple_types<wchar_t>>>)+5o
.text$x:00004E01
.text$x:00004E01 arg_4           = dword ptr  8
.text$x:00004E01
.text$x:00004E01                 mov     edx, [esp+arg_4]
.text$x:00004E05                 lea     eax, [edx+0Ch]
.text$x:00004E08                 mov     ecx, [edx-34h]
.text$x:00004E0B                 xor     ecx, eax
.text$x:00004E0D                 call    @__security_check_cookie@4 ; __security_check_cookie(x)
.text$x:00004E12                 mov     ecx, [edx-4]
.text$x:00004E15                 xor     ecx, eax
.text$x:00004E17                 call    @__security_check_cookie@4 ; __security_check_cookie(x)
.text$x:00004E1C                 mov     eax, offset __ehfuncinfo$??$convertFileName@V?$_String_const_iterator@V?$_String_val@U?$_Simple_types@_W@std@@@std@@@std@@@@YA?AV?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@V?$_String_const_iterator@V?$_String_val@U?$_Simple_types@_W@std@@@std@@@1@0@Z
.text$x:00004E21                 jmp     ___CxxFrameHandler3
.text$x:00004E21 __ehhandler$??$convertFileName@V?$_String_const_iterator@V?$_String_val@U?$_Simple_types@_W@std@@@std@@@std@@@@YA?AV?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@V?$_String_const_iterator@V?$_String_val@U?$_Simple_types@_W@std@@@std@@@1@0@Z endp
.text$x:00004E21
.text$x:00004E21 ; ---------------------------------------------------------------------------
.text$x:00004E26                 align 4
.text$x:00004E26 _text$x         ends
.text$x:00004E26
.text$mn:00004E28 ; ===========================================================================
.text$mn:00004E28
.text$mn:00004E28 ; Segment type: Pure code
.text$mn:00004E28 ; Segment permissions: Read/Execute
.text$mn:00004E28 _text$mn        segment para public 'CODE' use32
.text$mn:00004E28                 assume cs:_text$mn
.text$mn:00004E28                 ;org 4E28h
.text$mn:00004E28 ; COMDAT (pick any)
.text$mn:00004E28                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text$mn:00004E28
.text$mn:00004E28 ; =============== S U B R O U T I N E =======================================
.text$mn:00004E28
.text$mn:00004E28 ; Attributes: bp-based frame
.text$mn:00004E28
.text$mn:00004E28 ; class std::basic_string<wchar_t, struct std::char_traits<wchar_t>, class std::allocator<wchar_t>> __cdecl convertFileName<class std::_Vector_iterator<class std::_Vector_val<struct std::_Simple_types<wchar_t>>>>(class std::_Vector_iterator<class std::_Vector_val<struct std::_Simple_types<wchar_t>>>, class std::_Vector_iterator<class std::_Vector_val<struct std::_Simple_types<wchar_t>>>)
.text$mn:00004E28                 public ??$convertFileName@V?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@_W@std@@@std@@@std@@@@YA?AV?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@V?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@_W@std@@@std@@@1@0@Z
.text$mn:00004E28 ??$convertFileName@V?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@_W@std@@@std@@@std@@@@YA?AV?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@V?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@_W@std@@@std@@@1@0@Z proc near
.text$mn:00004E28                                         ; CODE XREF: BuildMenuFileName(int,uint,std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>> const &)+1BBp
.text$mn:00004E28
.text$mn:00004E28 var_3C          = byte ptr -3Ch
.text$mn:00004E28 var_30          = dword ptr -30h
.text$mn:00004E28 var_2C          = byte ptr -2Ch
.text$mn:00004E28 var_10          = dword ptr -10h
.text$mn:00004E28 var_C           = dword ptr -0Ch
.text$mn:00004E28 var_4           = dword ptr -4
.text$mn:00004E28 arg_0           = dword ptr  8
.text$mn:00004E28 arg_4           = byte ptr  0Ch
.text$mn:00004E28 arg_10          = byte ptr  18h
.text$mn:00004E28
.text$mn:00004E28                 push    ebp
.text$mn:00004E29                 mov     ebp, esp
.text$mn:00004E2B                 push    0FFFFFFFFh
.text$mn:00004E2D                 push    offset __ehhandler$??$convertFileName@V?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@_W@std@@@std@@@std@@@@YA?AV?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@V?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@_W@std@@@std@@@1@0@Z
.text$mn:00004E32                 mov     eax, large fs:0
.text$mn:00004E38                 push    eax
.text$mn:00004E39                 sub     esp, 30h
.text$mn:00004E3C                 mov     eax, dword ptr ds:___security_cookie
.text$mn:00004E41                 xor     eax, ebp
.text$mn:00004E43                 mov     [ebp+var_10], eax
.text$mn:00004E46                 push    eax
.text$mn:00004E47                 lea     eax, [ebp+var_C]
.text$mn:00004E4A                 mov     large fs:0, eax
.text$mn:00004E50                 mov     [ebp+var_30], 0
.text$mn:00004E57                 mov     [ebp+var_4], 2
.text$mn:00004E5E                 lea     ecx, [ebp+var_2C]
.text$mn:00004E61                 call    ??0?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QAE@XZ ; std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>>::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>>(void)
.text$mn:00004E66                 mov     byte ptr [ebp+var_4], 3
.text$mn:00004E6A                 lea     eax, [ebp+arg_4]
.text$mn:00004E6D                 push    eax             ; struct std::_Iterator_base12 *
.text$mn:00004E6E                 lea     ecx, [ebp+var_3C]
.text$mn:00004E71                 call    ??0?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@_W@std@@@std@@@std@@QAE@ABV01@@Z ; std::_Vector_iterator<std::_Vector_val<std::_Simple_types<wchar_t>>>::_Vector_iterator<std::_Vector_val<std::_Simple_types<wchar_t>>>(std::_Vector_iterator<std::_Vector_val<std::_Simple_types<wchar_t>>> const &)
.text$mn:00004E76                 mov     byte ptr [ebp+var_4], 4
.text$mn:00004E7A                 jmp     short loc_4E84
.text$mn:00004E7C ; ---------------------------------------------------------------------------
.text$mn:00004E7C
.text$mn:00004E7C loc_4E7C:                               ; CODE XREF: convertFileName<std::_Vector_iterator<std::_Vector_val<std::_Simple_types<wchar_t>>>>(std::_Vector_iterator<std::_Vector_val<std::_Simple_types<wchar_t>>>,std::_Vector_iterator<std::_Vector_val<std::_Simple_types<wchar_t>>>)+A0j
.text$mn:00004E7C                 lea     ecx, [ebp+var_3C]
.text$mn:00004E7F                 call    ??E?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@_W@std@@@std@@@std@@QAEAAV01@XZ ; std::_Vector_iterator<std::_Vector_val<std::_Simple_types<wchar_t>>>::operator++(void)
.text$mn:00004E84
.text$mn:00004E84 loc_4E84:                               ; CODE XREF: convertFileName<std::_Vector_iterator<std::_Vector_val<std::_Simple_types<wchar_t>>>>(std::_Vector_iterator<std::_Vector_val<std::_Simple_types<wchar_t>>>,std::_Vector_iterator<std::_Vector_val<std::_Simple_types<wchar_t>>>)+52j
.text$mn:00004E84                 lea     ecx, [ebp+arg_10]
.text$mn:00004E87                 push    ecx             ; std::_Iterator_base12 *
.text$mn:00004E88                 lea     ecx, [ebp+var_3C]
.text$mn:00004E8B                 call    ??9?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@_W@std@@@std@@@std@@QBE_NABV01@@Z ; std::_Vector_const_iterator<std::_Vector_val<std::_Simple_types<wchar_t>>>::operator!=(std::_Vector_const_iterator<std::_Vector_val<std::_Simple_types<wchar_t>>> const &)
.text$mn:00004E90                 movzx   edx, al
.text$mn:00004E93                 test    edx, edx
.text$mn:00004E95                 jz      short loc_4ECA
.text$mn:00004E97                 lea     ecx, [ebp+var_3C]
.text$mn:00004E9A                 call    ??D?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@_W@std@@@std@@@std@@QBEAA_WXZ ; std::_Vector_iterator<std::_Vector_val<std::_Simple_types<wchar_t>>>::operator*(void)
.text$mn:00004E9F                 movzx   eax, word ptr [eax]
.text$mn:00004EA2                 cmp     eax, 26h ; '&'
.text$mn:00004EA5                 jnz     short loc_4EB1
.text$mn:00004EA7                 push    26h ; '&'
.text$mn:00004EA9                 lea     ecx, [ebp+var_2C]
.text$mn:00004EAC                 call    ?push_back@?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QAEX_W@Z ; std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>>::push_back(wchar_t)
.text$mn:00004EB1
.text$mn:00004EB1 loc_4EB1:                               ; CODE XREF: convertFileName<std::_Vector_iterator<std::_Vector_val<std::_Simple_types<wchar_t>>>>(std::_Vector_iterator<std::_Vector_val<std::_Simple_types<wchar_t>>>,std::_Vector_iterator<std::_Vector_val<std::_Simple_types<wchar_t>>>)+7Dj
.text$mn:00004EB1                 lea     ecx, [ebp+var_3C]
.text$mn:00004EB4                 call    ??D?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@_W@std@@@std@@@std@@QBEAA_WXZ ; std::_Vector_iterator<std::_Vector_val<std::_Simple_types<wchar_t>>>::operator*(void)
.text$mn:00004EB9                 mov     cx, [eax]
.text$mn:00004EBC                 movzx   edx, cx
.text$mn:00004EBF                 push    edx
.text$mn:00004EC0                 lea     ecx, [ebp+var_2C]
.text$mn:00004EC3                 call    ?push_back@?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QAEX_W@Z ; std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>>::push_back(wchar_t)
.text$mn:00004EC8                 jmp     short loc_4E7C
.text$mn:00004ECA ; ---------------------------------------------------------------------------
.text$mn:00004ECA
.text$mn:00004ECA loc_4ECA:                               ; CODE XREF: convertFileName<std::_Vector_iterator<std::_Vector_val<std::_Simple_types<wchar_t>>>>(std::_Vector_iterator<std::_Vector_val<std::_Simple_types<wchar_t>>>,std::_Vector_iterator<std::_Vector_val<std::_Simple_types<wchar_t>>>)+6Dj
.text$mn:00004ECA                 mov     byte ptr [ebp+var_4], 3
.text$mn:00004ECE                 lea     ecx, [ebp+var_3C]
.text$mn:00004ED1                 call    ??1?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@_W@std@@@std@@@std@@QAE@XZ ; std::_Vector_iterator<std::_Vector_val<std::_Simple_types<wchar_t>>>::~_Vector_iterator<std::_Vector_val<std::_Simple_types<wchar_t>>>(void)
.text$mn:00004ED6                 lea     eax, [ebp+var_2C]
.text$mn:00004ED9                 push    eax
.text$mn:00004EDA                 mov     ecx, [ebp+arg_0]
.text$mn:00004EDD                 call    ??0?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QAE@$$QAV01@@Z ; std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>>::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>>(std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>> &&)
.text$mn:00004EE2                 mov     ecx, [ebp+var_30]
.text$mn:00004EE5                 or      ecx, 1
.text$mn:00004EE8                 mov     [ebp+var_30], ecx
.text$mn:00004EEB                 mov     byte ptr [ebp+var_4], 2
.text$mn:00004EEF                 lea     ecx, [ebp+var_2C]
.text$mn:00004EF2                 call    ??1?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QAE@XZ ; std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>>::~basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>>(void)
.text$mn:00004EF7                 mov     byte ptr [ebp+var_4], 1
.text$mn:00004EFB                 lea     ecx, [ebp+arg_4]
.text$mn:00004EFE                 call    ??1?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@_W@std@@@std@@@std@@QAE@XZ ; std::_Vector_iterator<std::_Vector_val<std::_Simple_types<wchar_t>>>::~_Vector_iterator<std::_Vector_val<std::_Simple_types<wchar_t>>>(void)
.text$mn:00004F03                 mov     byte ptr [ebp+var_4], 0
.text$mn:00004F07                 lea     ecx, [ebp+arg_10]
.text$mn:00004F0A                 call    ??1?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@_W@std@@@std@@@std@@QAE@XZ ; std::_Vector_iterator<std::_Vector_val<std::_Simple_types<wchar_t>>>::~_Vector_iterator<std::_Vector_val<std::_Simple_types<wchar_t>>>(void)
.text$mn:00004F0F                 mov     eax, [ebp+arg_0]
.text$mn:00004F12                 mov     ecx, [ebp+var_C]
.text$mn:00004F15                 mov     large fs:0, ecx
.text$mn:00004F1C                 pop     ecx
.text$mn:00004F1D                 mov     ecx, [ebp+var_10]
.text$mn:00004F20                 xor     ecx, ebp
.text$mn:00004F22                 call    @__security_check_cookie@4 ; __security_check_cookie(x)
.text$mn:00004F27                 mov     esp, ebp
.text$mn:00004F29                 pop     ebp
.text$mn:00004F2A                 retn
.text$mn:00004F2A ??$convertFileName@V?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@_W@std@@@std@@@std@@@@YA?AV?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@V?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@_W@std@@@std@@@1@0@Z endp
.text$mn:00004F2A
.text$mn:00004F2A ; ---------------------------------------------------------------------------
.text$mn:00004F2B                 align 4
.text$mn:00004F2B _text$mn        ends
.text$mn:00004F2B
.text$x:00004F2C ; ===========================================================================
.text$x:00004F2C
.text$x:00004F2C ; Segment type: Pure code
.text$x:00004F2C ; Segment permissions: Read/Execute
.text$x:00004F2C _text$x         segment para public 'CODE' use32
.text$x:00004F2C                 assume cs:_text$x
.text$x:00004F2C                 ;org 4F2Ch
.text$x:00004F2C ; COMDAT (pick associative to section at 4E28)
.text$x:00004F2C                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text$x:00004F2C
.text$x:00004F2C ; =============== S U B R O U T I N E =======================================
.text$x:00004F2C
.text$x:00004F2C
.text$x:00004F2C __unwindfunclet$??$convertFileName@V?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@_W@std@@@std@@@std@@@@YA?AV?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@V?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@_W@std@@@std@@@1@0@Z$0 proc near
.text$x:00004F2C                                         ; DATA XREF: .xdata$x:0000EC50o
.text$x:00004F2C                 lea     ecx, [ebp+18h]
.text$x:00004F2F                 jmp     ??1?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@_W@std@@@std@@@std@@QAE@XZ ; std::_Vector_iterator<std::_Vector_val<std::_Simple_types<wchar_t>>>::~_Vector_iterator<std::_Vector_val<std::_Simple_types<wchar_t>>>(void)
.text$x:00004F2F __unwindfunclet$??$convertFileName@V?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@_W@std@@@std@@@std@@@@YA?AV?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@V?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@_W@std@@@std@@@1@0@Z$0 endp
.text$x:00004F2F
.text$x:00004F34
.text$x:00004F34 ; =============== S U B R O U T I N E =======================================
.text$x:00004F34
.text$x:00004F34
.text$x:00004F34 __unwindfunclet$??$convertFileName@V?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@_W@std@@@std@@@std@@@@YA?AV?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@V?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@_W@std@@@std@@@1@0@Z$1 proc near
.text$x:00004F34                                         ; DATA XREF: .xdata$x:0000EC58o
.text$x:00004F34                 lea     ecx, [ebp+0Ch]
.text$x:00004F37                 jmp     ??1?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@_W@std@@@std@@@std@@QAE@XZ ; std::_Vector_iterator<std::_Vector_val<std::_Simple_types<wchar_t>>>::~_Vector_iterator<std::_Vector_val<std::_Simple_types<wchar_t>>>(void)
.text$x:00004F37 __unwindfunclet$??$convertFileName@V?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@_W@std@@@std@@@std@@@@YA?AV?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@V?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@_W@std@@@std@@@1@0@Z$1 endp
.text$x:00004F37
.text$x:00004F3C
.text$x:00004F3C ; =============== S U B R O U T I N E =======================================
.text$x:00004F3C
.text$x:00004F3C
.text$x:00004F3C __unwindfunclet$??$convertFileName@V?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@_W@std@@@std@@@std@@@@YA?AV?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@V?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@_W@std@@@std@@@1@0@Z$2 proc near
.text$x:00004F3C                                         ; DATA XREF: .xdata$x:0000EC60o
.text$x:00004F3C                 lea     ecx, [ebp-2Ch]
.text$x:00004F3F                 jmp     ??1?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QAE@XZ ; std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>>::~basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>>(void)
.text$x:00004F3F __unwindfunclet$??$convertFileName@V?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@_W@std@@@std@@@std@@@@YA?AV?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@V?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@_W@std@@@std@@@1@0@Z$2 endp
.text$x:00004F3F
.text$x:00004F44
.text$x:00004F44 ; =============== S U B R O U T I N E =======================================
.text$x:00004F44
.text$x:00004F44
.text$x:00004F44 __unwindfunclet$??$convertFileName@V?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@_W@std@@@std@@@std@@@@YA?AV?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@V?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@_W@std@@@std@@@1@0@Z$3 proc near
.text$x:00004F44                                         ; DATA XREF: .xdata$x:0000EC68o
.text$x:00004F44                 lea     ecx, [ebp-3Ch]
.text$x:00004F47                 jmp     ??1?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@_W@std@@@std@@@std@@QAE@XZ ; std::_Vector_iterator<std::_Vector_val<std::_Simple_types<wchar_t>>>::~_Vector_iterator<std::_Vector_val<std::_Simple_types<wchar_t>>>(void)
.text$x:00004F47 __unwindfunclet$??$convertFileName@V?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@_W@std@@@std@@@std@@@@YA?AV?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@V?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@_W@std@@@std@@@1@0@Z$3 endp
.text$x:00004F47
.text$x:00004F4C
.text$x:00004F4C ; =============== S U B R O U T I N E =======================================
.text$x:00004F4C
.text$x:00004F4C
.text$x:00004F4C __unwindfunclet$??$convertFileName@V?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@_W@std@@@std@@@std@@@@YA?AV?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@V?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@_W@std@@@std@@@1@0@Z$4 proc near
.text$x:00004F4C                                         ; DATA XREF: .xdata$x:0000EC48o
.text$x:00004F4C                 mov     eax, [ebp-30h]
.text$x:00004F4F                 and     eax, 1
.text$x:00004F52                 jz      $LN12
.text$x:00004F58                 and     dword ptr [ebp-30h], 0FFFFFFFEh
.text$x:00004F5C                 mov     ecx, [ebp+8]
.text$x:00004F5F                 jmp     ??1?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QAE@XZ ; std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>>::~basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>>(void)
.text$x:00004F64 ; ---------------------------------------------------------------------------
.text$x:00004F64
.text$x:00004F64 $LN12:                                  ; CODE XREF: __unwindfunclet$??$convertFileName@V?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@_W@std@@@std@@@std@@@@YA?AV?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@V?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@_W@std@@@std@@@1@0@Z$4+6j
.text$x:00004F64                 retn
.text$x:00004F64 __unwindfunclet$??$convertFileName@V?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@_W@std@@@std@@@std@@@@YA?AV?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@V?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@_W@std@@@std@@@1@0@Z$4 endp
.text$x:00004F64
.text$x:00004F65
.text$x:00004F65 ; =============== S U B R O U T I N E =======================================
.text$x:00004F65
.text$x:00004F65
.text$x:00004F65 __ehhandler$??$convertFileName@V?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@_W@std@@@std@@@std@@@@YA?AV?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@V?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@_W@std@@@std@@@1@0@Z proc near
.text$x:00004F65                                         ; DATA XREF: convertFileName<std::_Vector_iterator<std::_Vector_val<std::_Simple_types<wchar_t>>>>(std::_Vector_iterator<std::_Vector_val<std::_Simple_types<wchar_t>>>,std::_Vector_iterator<std::_Vector_val<std::_Simple_types<wchar_t>>>)+5o
.text$x:00004F65
.text$x:00004F65 arg_4           = dword ptr  8
.text$x:00004F65
.text$x:00004F65                 mov     edx, [esp+arg_4]
.text$x:00004F69                 lea     eax, [edx+0Ch]
.text$x:00004F6C                 mov     ecx, [edx-34h]
.text$x:00004F6F                 xor     ecx, eax
.text$x:00004F71                 call    @__security_check_cookie@4 ; __security_check_cookie(x)
.text$x:00004F76                 mov     ecx, [edx-4]
.text$x:00004F79                 xor     ecx, eax
.text$x:00004F7B                 call    @__security_check_cookie@4 ; __security_check_cookie(x)
.text$x:00004F80                 mov     eax, offset __ehfuncinfo$??$convertFileName@V?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@_W@std@@@std@@@std@@@@YA?AV?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@V?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@_W@std@@@std@@@1@0@Z
.text$x:00004F85                 jmp     ___CxxFrameHandler3
.text$x:00004F85 __ehhandler$??$convertFileName@V?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@_W@std@@@std@@@std@@@@YA?AV?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@V?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@_W@std@@@std@@@1@0@Z endp
.text$x:00004F85
.text$x:00004F85 ; ---------------------------------------------------------------------------
.text$x:00004F8A                 align 4
.text$x:00004F8A _text$x         ends
.text$x:00004F8A
.text$mn:00004F8C ; ===========================================================================
.text$mn:00004F8C
.text$mn:00004F8C ; Segment type: Pure code
.text$mn:00004F8C ; Segment permissions: Read/Execute
.text$mn:00004F8C _text$mn        segment para public 'CODE' use32
.text$mn:00004F8C                 assume cs:_text$mn
.text$mn:00004F8C                 ;org 4F8Ch
.text$mn:00004F8C ; COMDAT (pick any)
.text$mn:00004F8C                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text$mn:00004F8C
.text$mn:00004F8C ; =============== S U B R O U T I N E =======================================
.text$mn:00004F8C
.text$mn:00004F8C ; Attributes: bp-based frame
.text$mn:00004F8C
.text$mn:00004F8C ; public: void __thiscall std::_Wrap_alloc<class std::allocator<char>>::destroy<char *>(char * *)
.text$mn:00004F8C                 public ??$destroy@PAD@?$_Wrap_alloc@V?$allocator@D@std@@@std@@QAEXPAPAD@Z
.text$mn:00004F8C ??$destroy@PAD@?$_Wrap_alloc@V?$allocator@D@std@@@std@@QAEXPAPAD@Z proc near
.text$mn:00004F8C                                         ; CODE XREF: std::basic_string<char,std::char_traits<char>,std::allocator<char>>::_Tidy(bool,uint)+3Ap
.text$mn:00004F8C
.text$mn:00004F8C var_4           = dword ptr -4
.text$mn:00004F8C arg_0           = dword ptr  8
.text$mn:00004F8C
.text$mn:00004F8C                 push    ebp
.text$mn:00004F8D                 mov     ebp, esp
.text$mn:00004F8F                 push    ecx
.text$mn:00004F90                 mov     [ebp+var_4], ecx
.text$mn:00004F93                 mov     eax, [ebp+arg_0]
.text$mn:00004F96                 push    eax
.text$mn:00004F97                 mov     ecx, [ebp+var_4]
.text$mn:00004F9A                 push    ecx
.text$mn:00004F9B                 call    ??$destroy@PAD@?$allocator_traits@V?$allocator@D@std@@@std@@SAXAAV?$allocator@D@1@PAPAD@Z ; std::allocator_traits<std::allocator<char>>::destroy<char *>(std::allocator<char> &,char * *)
.text$mn:00004FA0                 add     esp, 8
.text$mn:00004FA3                 mov     esp, ebp
.text$mn:00004FA5                 pop     ebp
.text$mn:00004FA6                 retn    4
.text$mn:00004FA6 ??$destroy@PAD@?$_Wrap_alloc@V?$allocator@D@std@@@std@@QAEXPAPAD@Z endp
.text$mn:00004FA6
.text$mn:00004FA6 ; ---------------------------------------------------------------------------
.text$mn:00004FA9                 align 4
.text$mn:00004FA9 _text$mn        ends
.text$mn:00004FA9
.text$mn:00004FAC ; ===========================================================================
.text$mn:00004FAC
.text$mn:00004FAC ; Segment type: Pure code
.text$mn:00004FAC ; Segment permissions: Read/Execute
.text$mn:00004FAC _text$mn        segment para public 'CODE' use32
.text$mn:00004FAC                 assume cs:_text$mn
.text$mn:00004FAC                 ;org 4FACh
.text$mn:00004FAC ; COMDAT (pick any)
.text$mn:00004FAC                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text$mn:00004FAC
.text$mn:00004FAC ; =============== S U B R O U T I N E =======================================
.text$mn:00004FAC
.text$mn:00004FAC ; Attributes: bp-based frame
.text$mn:00004FAC
.text$mn:00004FAC ; public: void __thiscall std::allocator<char>::destroy<char *>(char * *)
.text$mn:00004FAC                 public ??$destroy@PAD@?$allocator@D@std@@QAEXPAPAD@Z
.text$mn:00004FAC ??$destroy@PAD@?$allocator@D@std@@QAEXPAPAD@Z proc near
.text$mn:00004FAC                                         ; CODE XREF: std::allocator_traits<std::allocator<char>>::destroy<char *>(std::allocator<char> &,char * *)+Ap
.text$mn:00004FAC
.text$mn:00004FAC var_4           = dword ptr -4
.text$mn:00004FAC
.text$mn:00004FAC                 push    ebp
.text$mn:00004FAD                 mov     ebp, esp
.text$mn:00004FAF                 push    ecx
.text$mn:00004FB0                 mov     [ebp+var_4], ecx
.text$mn:00004FB3                 mov     esp, ebp
.text$mn:00004FB5                 pop     ebp
.text$mn:00004FB6                 retn    4
.text$mn:00004FB6 ??$destroy@PAD@?$allocator@D@std@@QAEXPAPAD@Z endp
.text$mn:00004FB6
.text$mn:00004FB6 ; ---------------------------------------------------------------------------
.text$mn:00004FB9                 align 4
.text$mn:00004FB9 _text$mn        ends
.text$mn:00004FB9
.text$mn:00004FBC ; ===========================================================================
.text$mn:00004FBC
.text$mn:00004FBC ; Segment type: Pure code
.text$mn:00004FBC ; Segment permissions: Read/Execute
.text$mn:00004FBC _text$mn        segment para public 'CODE' use32
.text$mn:00004FBC                 assume cs:_text$mn
.text$mn:00004FBC                 ;org 4FBCh
.text$mn:00004FBC ; COMDAT (pick any)
.text$mn:00004FBC                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text$mn:00004FBC
.text$mn:00004FBC ; =============== S U B R O U T I N E =======================================
.text$mn:00004FBC
.text$mn:00004FBC ; Attributes: bp-based frame
.text$mn:00004FBC
.text$mn:00004FBC ; public: static void __cdecl std::allocator_traits<class std::allocator<char>>::destroy<char *>(class std::allocator<char> &, char * *)
.text$mn:00004FBC                 public ??$destroy@PAD@?$allocator_traits@V?$allocator@D@std@@@std@@SAXAAV?$allocator@D@1@PAPAD@Z
.text$mn:00004FBC ??$destroy@PAD@?$allocator_traits@V?$allocator@D@std@@@std@@SAXAAV?$allocator@D@1@PAPAD@Z proc near
.text$mn:00004FBC                                         ; CODE XREF: std::_Wrap_alloc<std::allocator<char>>::destroy<char *>(char * *)+Fp
.text$mn:00004FBC
.text$mn:00004FBC arg_0           = dword ptr  8
.text$mn:00004FBC arg_4           = dword ptr  0Ch
.text$mn:00004FBC
.text$mn:00004FBC                 push    ebp
.text$mn:00004FBD                 mov     ebp, esp
.text$mn:00004FBF                 mov     eax, [ebp+arg_4]
.text$mn:00004FC2                 push    eax
.text$mn:00004FC3                 mov     ecx, [ebp+arg_0]
.text$mn:00004FC6                 call    ??$destroy@PAD@?$allocator@D@std@@QAEXPAPAD@Z ; std::allocator<char>::destroy<char *>(char * *)
.text$mn:00004FCB                 pop     ebp
.text$mn:00004FCC                 retn
.text$mn:00004FCC ??$destroy@PAD@?$allocator_traits@V?$allocator@D@std@@@std@@SAXAAV?$allocator@D@1@PAPAD@Z endp
.text$mn:00004FCC
.text$mn:00004FCC ; ---------------------------------------------------------------------------
.text$mn:00004FCD                 align 10h
.text$mn:00004FCD _text$mn        ends
.text$mn:00004FCD
.text$mn:00004FD0 ; ===========================================================================
.text$mn:00004FD0
.text$mn:00004FD0 ; Segment type: Pure code
.text$mn:00004FD0 ; Segment permissions: Read/Execute
.text$mn:00004FD0 _text$mn        segment para public 'CODE' use32
.text$mn:00004FD0                 assume cs:_text$mn
.text$mn:00004FD0                 ;org 4FD0h
.text$mn:00004FD0 ; COMDAT (pick any)
.text$mn:00004FD0                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text$mn:00004FD0
.text$mn:00004FD0 ; =============== S U B R O U T I N E =======================================
.text$mn:00004FD0
.text$mn:00004FD0 ; Attributes: bp-based frame
.text$mn:00004FD0
.text$mn:00004FD0 ; public: void __thiscall std::_Wrap_alloc<class std::allocator<wchar_t>>::destroy<wchar_t *>(wchar_t * *)
.text$mn:00004FD0                 public ??$destroy@PA_W@?$_Wrap_alloc@V?$allocator@_W@std@@@std@@QAEXPAPA_W@Z
.text$mn:00004FD0 ??$destroy@PA_W@?$_Wrap_alloc@V?$allocator@_W@std@@@std@@QAEXPAPA_W@Z proc near
.text$mn:00004FD0                                         ; CODE XREF: std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>>::_Tidy(bool,uint)+3Ap
.text$mn:00004FD0
.text$mn:00004FD0 var_4           = dword ptr -4
.text$mn:00004FD0 arg_0           = dword ptr  8
.text$mn:00004FD0
.text$mn:00004FD0                 push    ebp
.text$mn:00004FD1                 mov     ebp, esp
.text$mn:00004FD3                 push    ecx
.text$mn:00004FD4                 mov     [ebp+var_4], ecx
.text$mn:00004FD7                 mov     eax, [ebp+arg_0]
.text$mn:00004FDA                 push    eax
.text$mn:00004FDB                 mov     ecx, [ebp+var_4]
.text$mn:00004FDE                 push    ecx
.text$mn:00004FDF                 call    ??$destroy@PA_W@?$allocator_traits@V?$allocator@_W@std@@@std@@SAXAAV?$allocator@_W@1@PAPA_W@Z ; std::allocator_traits<std::allocator<wchar_t>>::destroy<wchar_t *>(std::allocator<wchar_t> &,wchar_t * *)
.text$mn:00004FE4                 add     esp, 8
.text$mn:00004FE7                 mov     esp, ebp
.text$mn:00004FE9                 pop     ebp
.text$mn:00004FEA                 retn    4
.text$mn:00004FEA ??$destroy@PA_W@?$_Wrap_alloc@V?$allocator@_W@std@@@std@@QAEXPAPA_W@Z endp
.text$mn:00004FEA
.text$mn:00004FEA ; ---------------------------------------------------------------------------
.text$mn:00004FED                 align 10h
.text$mn:00004FED _text$mn        ends
.text$mn:00004FED
.text$mn:00004FF0 ; ===========================================================================
.text$mn:00004FF0
.text$mn:00004FF0 ; Segment type: Pure code
.text$mn:00004FF0 ; Segment permissions: Read/Execute
.text$mn:00004FF0 _text$mn        segment para public 'CODE' use32
.text$mn:00004FF0                 assume cs:_text$mn
.text$mn:00004FF0                 ;org 4FF0h
.text$mn:00004FF0 ; COMDAT (pick any)
.text$mn:00004FF0                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text$mn:00004FF0
.text$mn:00004FF0 ; =============== S U B R O U T I N E =======================================
.text$mn:00004FF0
.text$mn:00004FF0 ; Attributes: bp-based frame
.text$mn:00004FF0
.text$mn:00004FF0 ; public: void __thiscall std::allocator<wchar_t>::destroy<wchar_t *>(wchar_t * *)
.text$mn:00004FF0                 public ??$destroy@PA_W@?$allocator@_W@std@@QAEXPAPA_W@Z
.text$mn:00004FF0 ??$destroy@PA_W@?$allocator@_W@std@@QAEXPAPA_W@Z proc near
.text$mn:00004FF0                                         ; CODE XREF: std::allocator_traits<std::allocator<wchar_t>>::destroy<wchar_t *>(std::allocator<wchar_t> &,wchar_t * *)+Ap
.text$mn:00004FF0
.text$mn:00004FF0 var_4           = dword ptr -4
.text$mn:00004FF0
.text$mn:00004FF0                 push    ebp
.text$mn:00004FF1                 mov     ebp, esp
.text$mn:00004FF3                 push    ecx
.text$mn:00004FF4                 mov     [ebp+var_4], ecx
.text$mn:00004FF7                 mov     esp, ebp
.text$mn:00004FF9                 pop     ebp
.text$mn:00004FFA                 retn    4
.text$mn:00004FFA ??$destroy@PA_W@?$allocator@_W@std@@QAEXPAPA_W@Z endp
.text$mn:00004FFA
.text$mn:00004FFA ; ---------------------------------------------------------------------------
.text$mn:00004FFD                 align 10h
.text$mn:00004FFD _text$mn        ends
.text$mn:00004FFD
.text$mn:00005000 ; ===========================================================================
.text$mn:00005000
.text$mn:00005000 ; Segment type: Pure code
.text$mn:00005000 ; Segment permissions: Read/Execute
.text$mn:00005000 _text$mn        segment para public 'CODE' use32
.text$mn:00005000                 assume cs:_text$mn
.text$mn:00005000                 ;org 5000h
.text$mn:00005000 ; COMDAT (pick any)
.text$mn:00005000                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text$mn:00005000
.text$mn:00005000 ; =============== S U B R O U T I N E =======================================
.text$mn:00005000
.text$mn:00005000 ; Attributes: bp-based frame
.text$mn:00005000
.text$mn:00005000 ; public: static void __cdecl std::allocator_traits<class std::allocator<wchar_t>>::destroy<wchar_t *>(class std::allocator<wchar_t> &, wchar_t * *)
.text$mn:00005000                 public ??$destroy@PA_W@?$allocator_traits@V?$allocator@_W@std@@@std@@SAXAAV?$allocator@_W@1@PAPA_W@Z
.text$mn:00005000 ??$destroy@PA_W@?$allocator_traits@V?$allocator@_W@std@@@std@@SAXAAV?$allocator@_W@1@PAPA_W@Z proc near
.text$mn:00005000                                         ; CODE XREF: std::_Wrap_alloc<std::allocator<wchar_t>>::destroy<wchar_t *>(wchar_t * *)+Fp
.text$mn:00005000
.text$mn:00005000 arg_0           = dword ptr  8
.text$mn:00005000 arg_4           = dword ptr  0Ch
.text$mn:00005000
.text$mn:00005000                 push    ebp
.text$mn:00005001                 mov     ebp, esp
.text$mn:00005003                 mov     eax, [ebp+arg_4]
.text$mn:00005006                 push    eax
.text$mn:00005007                 mov     ecx, [ebp+arg_0]
.text$mn:0000500A                 call    ??$destroy@PA_W@?$allocator@_W@std@@QAEXPAPA_W@Z ; std::allocator<wchar_t>::destroy<wchar_t *>(wchar_t * *)
.text$mn:0000500F                 pop     ebp
.text$mn:00005010                 retn
.text$mn:00005010 ??$destroy@PA_W@?$allocator_traits@V?$allocator@_W@std@@@std@@SAXAAV?$allocator@_W@1@PAPA_W@Z endp
.text$mn:00005010
.text$mn:00005010 ; ---------------------------------------------------------------------------
.text$mn:00005011                 align 4
.text$mn:00005011 _text$mn        ends
.text$mn:00005011
.text$mn:00005014 ; ===========================================================================
.text$mn:00005014
.text$mn:00005014 ; Segment type: Pure code
.text$mn:00005014 ; Segment permissions: Read/Execute
.text$mn:00005014 _text$mn        segment para public 'CODE' use32
.text$mn:00005014                 assume cs:_text$mn
.text$mn:00005014                 ;org 5014h
.text$mn:00005014 ; COMDAT (pick any)
.text$mn:00005014                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text$mn:00005014
.text$mn:00005014 ; =============== S U B R O U T I N E =======================================
.text$mn:00005014
.text$mn:00005014 ; Attributes: bp-based frame
.text$mn:00005014
.text$mn:00005014 ; public: void __thiscall std::_Wrap_alloc<class std::allocator<struct std::_Container_proxy>>::destroy<struct std::_Container_proxy>(struct std::_Container_proxy *)
.text$mn:00005014                 public ??$destroy@U_Container_proxy@std@@@?$_Wrap_alloc@V?$allocator@U_Container_proxy@std@@@std@@@std@@QAEXPAU_Container_proxy@1@@Z
.text$mn:00005014 ??$destroy@U_Container_proxy@std@@@?$_Wrap_alloc@V?$allocator@U_Container_proxy@std@@@std@@@std@@QAEXPAU_Container_proxy@1@@Z proc near
.text$mn:00005014                                         ; CODE XREF: std::_Vector_alloc<0,std::_Vec_base_types<char,std::allocator<char>>>::_Free_proxy(void)+22p
.text$mn:00005014                                         ; std::_Vector_alloc<0,std::_Vec_base_types<std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>>,std::allocator<std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>>>>>::_Free_proxy(void)+22p ...
.text$mn:00005014
.text$mn:00005014 var_4           = dword ptr -4
.text$mn:00005014 arg_0           = dword ptr  8
.text$mn:00005014
.text$mn:00005014                 push    ebp
.text$mn:00005015                 mov     ebp, esp
.text$mn:00005017                 push    ecx
.text$mn:00005018                 mov     [ebp+var_4], ecx
.text$mn:0000501B                 mov     eax, [ebp+arg_0]
.text$mn:0000501E                 push    eax
.text$mn:0000501F                 mov     ecx, [ebp+var_4]
.text$mn:00005022                 push    ecx
.text$mn:00005023                 call    ??$destroy@U_Container_proxy@std@@@?$allocator_traits@V?$allocator@U_Container_proxy@std@@@std@@@std@@SAXAAV?$allocator@U_Container_proxy@std@@@1@PAU_Container_proxy@1@@Z ; std::allocator_traits<std::allocator<std::_Container_proxy>>::destroy<std::_Container_proxy>(std::allocator<std::_Container_proxy> &,std::_Container_proxy *)
.text$mn:00005028                 add     esp, 8
.text$mn:0000502B                 mov     esp, ebp
.text$mn:0000502D                 pop     ebp
.text$mn:0000502E                 retn    4
.text$mn:0000502E ??$destroy@U_Container_proxy@std@@@?$_Wrap_alloc@V?$allocator@U_Container_proxy@std@@@std@@@std@@QAEXPAU_Container_proxy@1@@Z endp
.text$mn:0000502E
.text$mn:0000502E ; ---------------------------------------------------------------------------
.text$mn:00005031                 align 4
.text$mn:00005031 _text$mn        ends
.text$mn:00005031
.text$mn:00005034 ; ===========================================================================
.text$mn:00005034
.text$mn:00005034 ; Segment type: Pure code
.text$mn:00005034 ; Segment permissions: Read/Execute
.text$mn:00005034 _text$mn        segment para public 'CODE' use32
.text$mn:00005034                 assume cs:_text$mn
.text$mn:00005034                 ;org 5034h
.text$mn:00005034 ; COMDAT (pick any)
.text$mn:00005034                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text$mn:00005034
.text$mn:00005034 ; =============== S U B R O U T I N E =======================================
.text$mn:00005034
.text$mn:00005034 ; Attributes: bp-based frame
.text$mn:00005034
.text$mn:00005034 ; public: void __thiscall std::allocator<struct std::_Container_proxy>::destroy<struct std::_Container_proxy>(struct std::_Container_proxy *)
.text$mn:00005034                 public ??$destroy@U_Container_proxy@std@@@?$allocator@U_Container_proxy@std@@@std@@QAEXPAU_Container_proxy@1@@Z
.text$mn:00005034 ??$destroy@U_Container_proxy@std@@@?$allocator@U_Container_proxy@std@@@std@@QAEXPAU_Container_proxy@1@@Z proc near
.text$mn:00005034                                         ; CODE XREF: std::allocator_traits<std::allocator<std::_Container_proxy>>::destroy<std::_Container_proxy>(std::allocator<std::_Container_proxy> &,std::_Container_proxy *)+Ap
.text$mn:00005034                                         ; std::_String_alloc<0,std::_String_base_types<char,std::allocator<char>>>::_Free_proxy(void)+22p ...
.text$mn:00005034
.text$mn:00005034 var_4           = dword ptr -4
.text$mn:00005034
.text$mn:00005034                 push    ebp
.text$mn:00005035                 mov     ebp, esp
.text$mn:00005037                 push    ecx
.text$mn:00005038                 mov     [ebp+var_4], ecx
.text$mn:0000503B                 mov     esp, ebp
.text$mn:0000503D                 pop     ebp
.text$mn:0000503E                 retn    4
.text$mn:0000503E ??$destroy@U_Container_proxy@std@@@?$allocator@U_Container_proxy@std@@@std@@QAEXPAU_Container_proxy@1@@Z endp
.text$mn:0000503E
.text$mn:0000503E ; ---------------------------------------------------------------------------
.text$mn:00005041                 align 4
.text$mn:00005041 _text$mn        ends
.text$mn:00005041
.text$mn:00005044 ; ===========================================================================
.text$mn:00005044
.text$mn:00005044 ; Segment type: Pure code
.text$mn:00005044 ; Segment permissions: Read/Execute
.text$mn:00005044 _text$mn        segment para public 'CODE' use32
.text$mn:00005044                 assume cs:_text$mn
.text$mn:00005044                 ;org 5044h
.text$mn:00005044 ; COMDAT (pick any)
.text$mn:00005044                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text$mn:00005044
.text$mn:00005044 ; =============== S U B R O U T I N E =======================================
.text$mn:00005044
.text$mn:00005044 ; Attributes: bp-based frame
.text$mn:00005044
.text$mn:00005044 ; public: static void __cdecl std::allocator_traits<class std::allocator<struct std::_Container_proxy>>::destroy<struct std::_Container_proxy>(class std::allocator<struct std::_Container_proxy> &, struct std::_Container_proxy *)
.text$mn:00005044                 public ??$destroy@U_Container_proxy@std@@@?$allocator_traits@V?$allocator@U_Container_proxy@std@@@std@@@std@@SAXAAV?$allocator@U_Container_proxy@std@@@1@PAU_Container_proxy@1@@Z
.text$mn:00005044 ??$destroy@U_Container_proxy@std@@@?$allocator_traits@V?$allocator@U_Container_proxy@std@@@std@@@std@@SAXAAV?$allocator@U_Container_proxy@std@@@1@PAU_Container_proxy@1@@Z proc near
.text$mn:00005044                                         ; CODE XREF: std::_Wrap_alloc<std::allocator<std::_Container_proxy>>::destroy<std::_Container_proxy>(std::_Container_proxy *)+Fp
.text$mn:00005044
.text$mn:00005044 arg_0           = dword ptr  8
.text$mn:00005044 arg_4           = dword ptr  0Ch
.text$mn:00005044
.text$mn:00005044                 push    ebp
.text$mn:00005045                 mov     ebp, esp
.text$mn:00005047                 mov     eax, [ebp+arg_4]
.text$mn:0000504A                 push    eax
.text$mn:0000504B                 mov     ecx, [ebp+arg_0]
.text$mn:0000504E                 call    ??$destroy@U_Container_proxy@std@@@?$allocator@U_Container_proxy@std@@@std@@QAEXPAU_Container_proxy@1@@Z ; std::allocator<std::_Container_proxy>::destroy<std::_Container_proxy>(std::_Container_proxy *)
.text$mn:00005053                 pop     ebp
.text$mn:00005054                 retn
.text$mn:00005054 ??$destroy@U_Container_proxy@std@@@?$allocator_traits@V?$allocator@U_Container_proxy@std@@@std@@@std@@SAXAAV?$allocator@U_Container_proxy@std@@@1@PAU_Container_proxy@1@@Z endp
.text$mn:00005054
.text$mn:00005054 ; ---------------------------------------------------------------------------
.text$mn:00005055                 align 4
.text$mn:00005055 _text$mn        ends
.text$mn:00005055
.text$mn:00005058 ; ===========================================================================
.text$mn:00005058
.text$mn:00005058 ; Segment type: Pure code
.text$mn:00005058 ; Segment permissions: Read/Execute
.text$mn:00005058 _text$mn        segment para public 'CODE' use32
.text$mn:00005058                 assume cs:_text$mn
.text$mn:00005058                 ;org 5058h
.text$mn:00005058 ; COMDAT (pick any)
.text$mn:00005058                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text$mn:00005058
.text$mn:00005058 ; =============== S U B R O U T I N E =======================================
.text$mn:00005058
.text$mn:00005058 ; Attributes: bp-based frame
.text$mn:00005058
.text$mn:00005058 ; public: void __thiscall std::_Wrap_alloc<class std::allocator<class std::basic_string<wchar_t, struct std::char_traits<wchar_t>, class std::allocator<wchar_t>>>>::destroy<class std::basic_string<wchar_t, struct std::char_traits<wchar_t>, class std::allocator<wchar_t>>>(class std::basic_string<wchar_t, struct std::char_traits<wchar_t>, class std::allocator<wchar_t>> *)
.text$mn:00005058                 public ??$destroy@V?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@@?$_Wrap_alloc@V?$allocator@V?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@@std@@@std@@QAEXPAV?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@1@@Z
.text$mn:00005058 ??$destroy@V?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@@?$_Wrap_alloc@V?$allocator@V?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@@std@@@std@@QAEXPAV?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@1@@Z proc near
.text$mn:00005058                                         ; CODE XREF: std::_Destroy_range<std::_Wrap_alloc<std::allocator<std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>>>>>(std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>> *,std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>> *,std::_Wrap_alloc<std::allocator<std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>>>> &,std::_Nonscalar_ptr_iterator_tag)+1Dp
.text$mn:00005058                                         ; __catch$??$_Uninit_move@PAV?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@PAV12@V?$allocator@V?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@@2@V12@@std@@YAPAV?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@0@PAV10@00AAU?$_Wrap_alloc@V?$allocator@V?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@@std@@@0@0U_Nonscalar_ptr_iterator_tag@0@@Z$0+1Ap
.text$mn:00005058
.text$mn:00005058 var_4           = dword ptr -4
.text$mn:00005058 arg_0           = dword ptr  8
.text$mn:00005058
.text$mn:00005058                 push    ebp
.text$mn:00005059                 mov     ebp, esp
.text$mn:0000505B                 push    ecx
.text$mn:0000505C                 mov     [ebp+var_4], ecx
.text$mn:0000505F                 mov     eax, [ebp+arg_0]
.text$mn:00005062                 push    eax
.text$mn:00005063                 mov     ecx, [ebp+var_4]
.text$mn:00005066                 push    ecx
.text$mn:00005067                 call    ??$destroy@V?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@@?$allocator_traits@V?$allocator@V?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@@std@@@std@@SAXAAV?$allocator@V?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@@1@PAV?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@1@@Z ; std::allocator_traits<std::allocator<std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>>>>::destroy<std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>>>(std::allocator<std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>>> &,std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>> *)
.text$mn:0000506C                 add     esp, 8
.text$mn:0000506F                 mov     esp, ebp
.text$mn:00005071                 pop     ebp
.text$mn:00005072                 retn    4
.text$mn:00005072 ??$destroy@V?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@@?$_Wrap_alloc@V?$allocator@V?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@@std@@@std@@QAEXPAV?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@1@@Z endp
.text$mn:00005072
.text$mn:00005072 ; ---------------------------------------------------------------------------
.text$mn:00005075                 align 4
.text$mn:00005075 _text$mn        ends
.text$mn:00005075
.text$mn:00005078 ; ===========================================================================
.text$mn:00005078
.text$mn:00005078 ; Segment type: Pure code
.text$mn:00005078 ; Segment permissions: Read/Execute
.text$mn:00005078 _text$mn        segment para public 'CODE' use32
.text$mn:00005078                 assume cs:_text$mn
.text$mn:00005078                 ;org 5078h
.text$mn:00005078 ; COMDAT (pick any)
.text$mn:00005078                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text$mn:00005078
.text$mn:00005078 ; =============== S U B R O U T I N E =======================================
.text$mn:00005078
.text$mn:00005078 ; Attributes: bp-based frame
.text$mn:00005078
.text$mn:00005078 ; public: void __thiscall std::allocator<class std::basic_string<wchar_t, struct std::char_traits<wchar_t>, class std::allocator<wchar_t>>>::destroy<class std::basic_string<wchar_t, struct std::char_traits<wchar_t>, class std::allocator<wchar_t>>>(class std::basic_string<wchar_t, struct std::char_traits<wchar_t>, class std::allocator<wchar_t>> *)
.text$mn:00005078                 public ??$destroy@V?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@@?$allocator@V?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@@std@@QAEXPAV?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@1@@Z
.text$mn:00005078 ??$destroy@V?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@@?$allocator@V?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@@std@@QAEXPAV?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@1@@Z proc near
.text$mn:00005078                                         ; CODE XREF: std::allocator_traits<std::allocator<std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>>>>::destroy<std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>>>(std::allocator<std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>>> &,std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>> *)+Ap
.text$mn:00005078
.text$mn:00005078 var_4           = dword ptr -4
.text$mn:00005078 arg_0           = dword ptr  8
.text$mn:00005078
.text$mn:00005078                 push    ebp
.text$mn:00005079                 mov     ebp, esp
.text$mn:0000507B                 push    ecx
.text$mn:0000507C                 mov     [ebp+var_4], ecx
.text$mn:0000507F                 push    0
.text$mn:00005081                 mov     ecx, [ebp+arg_0]
.text$mn:00005084                 call    ??_G?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QAEPAXI@Z ; std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>>::`scalar deleting destructor'(uint)
.text$mn:00005089                 mov     esp, ebp
.text$mn:0000508B                 pop     ebp
.text$mn:0000508C                 retn    4
.text$mn:0000508C ??$destroy@V?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@@?$allocator@V?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@@std@@QAEXPAV?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@1@@Z endp
.text$mn:0000508C
.text$mn:0000508C ; ---------------------------------------------------------------------------
.text$mn:0000508F                 align 10h
.text$mn:0000508F _text$mn        ends
.text$mn:0000508F
.text$mn:00005090 ; ===========================================================================
.text$mn:00005090
.text$mn:00005090 ; Segment type: Pure code
.text$mn:00005090 ; Segment permissions: Read/Execute
.text$mn:00005090 _text$mn        segment para public 'CODE' use32
.text$mn:00005090                 assume cs:_text$mn
.text$mn:00005090                 ;org 5090h
.text$mn:00005090 ; COMDAT (pick any)
.text$mn:00005090                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text$mn:00005090
.text$mn:00005090 ; =============== S U B R O U T I N E =======================================
.text$mn:00005090
.text$mn:00005090 ; Attributes: bp-based frame
.text$mn:00005090
.text$mn:00005090 ; public: static void __cdecl std::allocator_traits<class std::allocator<class std::basic_string<wchar_t, struct std::char_traits<wchar_t>, class std::allocator<wchar_t>>>>::destroy<class std::basic_string<wchar_t, struct std::char_traits<wchar_t>, class std::allocator<wchar_t>>>(class std::allocator<class std::basic_string<wchar_t, struct std::char_traits<wchar_t>, class std::allocator<wchar_t>>> &, class std::basic_string<wchar_t, struct std::char_traits<wchar_t>, class std::allocator<wchar_t>> *)
.text$mn:00005090                 public ??$destroy@V?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@@?$allocator_traits@V?$allocator@V?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@@std@@@std@@SAXAAV?$allocator@V?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@@1@PAV?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@1@@Z
.text$mn:00005090 ??$destroy@V?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@@?$allocator_traits@V?$allocator@V?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@@std@@@std@@SAXAAV?$allocator@V?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@@1@PAV?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@1@@Z proc near
.text$mn:00005090                                         ; CODE XREF: std::_Wrap_alloc<std::allocator<std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>>>>::destroy<std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>>>(std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>> *)+Fp
.text$mn:00005090
.text$mn:00005090 arg_0           = dword ptr  8
.text$mn:00005090 arg_4           = dword ptr  0Ch
.text$mn:00005090
.text$mn:00005090                 push    ebp
.text$mn:00005091                 mov     ebp, esp
.text$mn:00005093                 mov     eax, [ebp+arg_4]
.text$mn:00005096                 push    eax
.text$mn:00005097                 mov     ecx, [ebp+arg_0]
.text$mn:0000509A                 call    ??$destroy@V?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@@?$allocator@V?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@@std@@QAEXPAV?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@1@@Z ; std::allocator<std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>>>::destroy<std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>>>(std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>> *)
.text$mn:0000509F                 pop     ebp
.text$mn:000050A0                 retn
.text$mn:000050A0 ??$destroy@V?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@@?$allocator_traits@V?$allocator@V?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@@std@@@std@@SAXAAV?$allocator@V?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@@1@PAV?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@1@@Z endp
.text$mn:000050A0
.text$mn:000050A0 ; ---------------------------------------------------------------------------
.text$mn:000050A1                 align 4
.text$mn:000050A1 _text$mn        ends
.text$mn:000050A1
.text$mn:000050A4 ; ===========================================================================
.text$mn:000050A4
.text$mn:000050A4 ; Segment type: Pure code
.text$mn:000050A4 ; Segment permissions: Read/Execute
.text$mn:000050A4 _text$mn        segment para public 'CODE' use32
.text$mn:000050A4                 assume cs:_text$mn
.text$mn:000050A4                 ;org 50A4h
.text$mn:000050A4 ; COMDAT (pick any)
.text$mn:000050A4                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text$mn:000050A4
.text$mn:000050A4 ; =============== S U B R O U T I N E =======================================
.text$mn:000050A4
.text$mn:000050A4 ; Attributes: bp-based frame
.text$mn:000050A4
.text$mn:000050A4 ; char * & __cdecl std::forward<char * &>(char * &)
.text$mn:000050A4                 public ??$forward@AAPAD@std@@YAAAPADAAPAD@Z
.text$mn:000050A4 ??$forward@AAPAD@std@@YAAAPADAAPAD@Z proc near
.text$mn:000050A4                                         ; CODE XREF: std::_Wrap_alloc<std::allocator<char>>::construct<char *,char * &>(char * *,char * &)+Bp
.text$mn:000050A4                                         ; std::allocator<char>::construct<char *,char * &>(char * *,char * &)+4Ap ...
.text$mn:000050A4
.text$mn:000050A4 arg_0           = dword ptr  8
.text$mn:000050A4
.text$mn:000050A4                 push    ebp
.text$mn:000050A5                 mov     ebp, esp
.text$mn:000050A7                 mov     eax, [ebp+arg_0]
.text$mn:000050AA                 pop     ebp
.text$mn:000050AB                 retn
.text$mn:000050AB ??$forward@AAPAD@std@@YAAAPADAAPAD@Z endp
.text$mn:000050AB
.text$mn:000050AB _text$mn        ends
.text$mn:000050AB
.text$mn:000050AC ; ===========================================================================
.text$mn:000050AC
.text$mn:000050AC ; Segment type: Pure code
.text$mn:000050AC ; Segment permissions: Read/Execute
.text$mn:000050AC _text$mn        segment para public 'CODE' use32
.text$mn:000050AC                 assume cs:_text$mn
.text$mn:000050AC                 ;org 50ACh
.text$mn:000050AC ; COMDAT (pick any)
.text$mn:000050AC                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text$mn:000050AC
.text$mn:000050AC ; =============== S U B R O U T I N E =======================================
.text$mn:000050AC
.text$mn:000050AC ; Attributes: bp-based frame
.text$mn:000050AC
.text$mn:000050AC ; wchar_t * & __cdecl std::forward<wchar_t * &>(wchar_t * &)
.text$mn:000050AC                 public ??$forward@AAPA_W@std@@YAAAPA_WAAPA_W@Z
.text$mn:000050AC ??$forward@AAPA_W@std@@YAAAPA_WAAPA_W@Z proc near
.text$mn:000050AC                                         ; CODE XREF: std::_Wrap_alloc<std::allocator<wchar_t>>::construct<wchar_t *,wchar_t * &>(wchar_t * *,wchar_t * &)+Bp
.text$mn:000050AC                                         ; std::allocator<wchar_t>::construct<wchar_t *,wchar_t * &>(wchar_t * *,wchar_t * &)+4Ap ...
.text$mn:000050AC
.text$mn:000050AC arg_0           = dword ptr  8
.text$mn:000050AC
.text$mn:000050AC                 push    ebp
.text$mn:000050AD                 mov     ebp, esp
.text$mn:000050AF                 mov     eax, [ebp+arg_0]
.text$mn:000050B2                 pop     ebp
.text$mn:000050B3                 retn
.text$mn:000050B3 ??$forward@AAPA_W@std@@YAAAPA_WAAPA_W@Z endp
.text$mn:000050B3
.text$mn:000050B3 _text$mn        ends
.text$mn:000050B3
.text$mn:000050B4 ; ===========================================================================
.text$mn:000050B4
.text$mn:000050B4 ; Segment type: Pure code
.text$mn:000050B4 ; Segment permissions: Read/Execute
.text$mn:000050B4 _text$mn        segment para public 'CODE' use32
.text$mn:000050B4                 assume cs:_text$mn
.text$mn:000050B4                 ;org 50B4h
.text$mn:000050B4 ; COMDAT (pick any)
.text$mn:000050B4                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text$mn:000050B4
.text$mn:000050B4 ; =============== S U B R O U T I N E =======================================
.text$mn:000050B4
.text$mn:000050B4 ; Attributes: bp-based frame
.text$mn:000050B4
.text$mn:000050B4 ; struct std::_Container_proxy && __cdecl std::forward<struct std::_Container_proxy>(struct std::_Container_proxy &)
.text$mn:000050B4                 public ??$forward@U_Container_proxy@std@@@std@@YA$$QAU_Container_proxy@0@AAU10@@Z
.text$mn:000050B4 ??$forward@U_Container_proxy@std@@@std@@YA$$QAU_Container_proxy@0@AAU10@@Z proc near
.text$mn:000050B4                                         ; CODE XREF: std::_Wrap_alloc<std::allocator<std::_Container_proxy>>::construct<std::_Container_proxy,std::_Container_proxy>(std::_Container_proxy *,std::_Container_proxy &&)+Bp
.text$mn:000050B4                                         ; std::allocator<std::_Container_proxy>::construct<std::_Container_proxy,std::_Container_proxy>(std::_Container_proxy *,std::_Container_proxy &&)+4Ap ...
.text$mn:000050B4
.text$mn:000050B4 arg_0           = dword ptr  8
.text$mn:000050B4
.text$mn:000050B4                 push    ebp
.text$mn:000050B5                 mov     ebp, esp
.text$mn:000050B7                 mov     eax, [ebp+arg_0]
.text$mn:000050BA                 pop     ebp
.text$mn:000050BB                 retn
.text$mn:000050BB ??$forward@U_Container_proxy@std@@@std@@YA$$QAU_Container_proxy@0@AAU10@@Z endp
.text$mn:000050BB
.text$mn:000050BB _text$mn        ends
.text$mn:000050BB
.text$mn:000050BC ; ===========================================================================
.text$mn:000050BC
.text$mn:000050BC ; Segment type: Pure code
.text$mn:000050BC ; Segment permissions: Read/Execute
.text$mn:000050BC _text$mn        segment para public 'CODE' use32
.text$mn:000050BC                 assume cs:_text$mn
.text$mn:000050BC                 ;org 50BCh
.text$mn:000050BC ; COMDAT (pick any)
.text$mn:000050BC                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text$mn:000050BC
.text$mn:000050BC ; =============== S U B R O U T I N E =======================================
.text$mn:000050BC
.text$mn:000050BC ; Attributes: bp-based frame
.text$mn:000050BC
.text$mn:000050BC ; class std::basic_string<char, struct std::char_traits<char>, class std::allocator<char>> && __cdecl std::forward<class std::basic_string<char, struct std::char_traits<char>, class std::allocator<char>>>(class std::basic_string<char, struct std::char_traits<char>, class std::allocator<char>> &)
.text$mn:000050BC                 public ??$forward@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@YA$$QAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@0@AAV10@@Z
.text$mn:000050BC ??$forward@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@YA$$QAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@0@AAV10@@Z proc near
.text$mn:000050BC                                         ; CODE XREF: std::basic_string<char,std::char_traits<char>,std::allocator<char>>::basic_string<char,std::char_traits<char>,std::allocator<char>>(std::basic_string<char,std::char_traits<char>,std::allocator<char>> &&)+54p
.text$mn:000050BC
.text$mn:000050BC arg_0           = dword ptr  8
.text$mn:000050BC
.text$mn:000050BC                 push    ebp
.text$mn:000050BD                 mov     ebp, esp
.text$mn:000050BF                 mov     eax, [ebp+arg_0]
.text$mn:000050C2                 pop     ebp
.text$mn:000050C3                 retn
.text$mn:000050C3 ??$forward@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@YA$$QAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@0@AAV10@@Z endp
.text$mn:000050C3
.text$mn:000050C3 _text$mn        ends
.text$mn:000050C3
.text$mn:000050C4 ; ===========================================================================
.text$mn:000050C4
.text$mn:000050C4 ; Segment type: Pure code
.text$mn:000050C4 ; Segment permissions: Read/Execute
.text$mn:000050C4 _text$mn        segment para public 'CODE' use32
.text$mn:000050C4                 assume cs:_text$mn
.text$mn:000050C4                 ;org 50C4h
.text$mn:000050C4 ; COMDAT (pick any)
.text$mn:000050C4                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text$mn:000050C4
.text$mn:000050C4 ; =============== S U B R O U T I N E =======================================
.text$mn:000050C4
.text$mn:000050C4 ; Attributes: bp-based frame
.text$mn:000050C4
.text$mn:000050C4 ; class std::basic_string<wchar_t, struct std::char_traits<wchar_t>, class std::allocator<wchar_t>> && __cdecl std::forward<class std::basic_string<wchar_t, struct std::char_traits<wchar_t>, class std::allocator<wchar_t>>>(class std::basic_string<wchar_t, struct std::char_traits<wchar_t>, class std::allocator<wchar_t>> &)
.text$mn:000050C4                 public ??$forward@V?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@@std@@YA$$QAV?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@0@AAV10@@Z
.text$mn:000050C4 ??$forward@V?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@@std@@YA$$QAV?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@0@AAV10@@Z proc near
.text$mn:000050C4                                         ; CODE XREF: std::_Wrap_alloc<std::allocator<std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>>>>::construct<std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>>,std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>>>(std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>> *,std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>> &&)+Bp
.text$mn:000050C4                                         ; std::allocator<std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>>>::construct<std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>>,std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>>>(std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>> *,std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>> &&)+4Ap ...
.text$mn:000050C4
.text$mn:000050C4 arg_0           = dword ptr  8
.text$mn:000050C4
.text$mn:000050C4                 push    ebp
.text$mn:000050C5                 mov     ebp, esp
.text$mn:000050C7                 mov     eax, [ebp+arg_0]
.text$mn:000050CA                 pop     ebp
.text$mn:000050CB                 retn
.text$mn:000050CB ??$forward@V?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@@std@@YA$$QAV?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@0@AAV10@@Z endp
.text$mn:000050CB
.text$mn:000050CB _text$mn        ends
.text$mn:000050CB
.text$mn:000050CC ; ===========================================================================
.text$mn:000050CC
.text$mn:000050CC ; Segment type: Pure code
.text$mn:000050CC ; Segment permissions: Read/Execute
.text$mn:000050CC _text$mn        segment para public 'CODE' use32
.text$mn:000050CC                 assume cs:_text$mn
.text$mn:000050CC                 ;org 50CCh
.text$mn:000050CC ; COMDAT (pick any)
.text$mn:000050CC                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text$mn:000050CC
.text$mn:000050CC ; =============== S U B R O U T I N E =======================================
.text$mn:000050CC
.text$mn:000050CC ; Attributes: bp-based frame
.text$mn:000050CC
.text$mn:000050CC ; class std::vector<class std::basic_string<wchar_t, struct std::char_traits<wchar_t>, class std::allocator<wchar_t>>, class std::allocator<class std::basic_string<wchar_t, struct std::char_traits<wchar_t>, class std::allocator<wchar_t>>>> && __cdecl std::forward<class std::vector<class std::basic_string<wchar_t, struct std::char_traits<wchar_t>, class std::allocator<wchar_t>>, class std::allocator<class std::basic_string<wchar_t, struct std::char_traits<wchar_t>, class std::allocator<wchar_t>>>>>(class std::vector<class std::basic_string<wchar_t, struct std::char_traits<wchar_t>, class std::allocator<wchar_t>>, class std::allocator<class std::basic_string<wchar_t, struct std::char_traits<wchar_t>, class std::allocator<wchar_t>>>> &)
.text$mn:000050CC                 public ??$forward@V?$vector@V?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@V?$allocator@V?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@@2@@std@@@std@@YA$$QAV?$vector@V?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@V?$allocator@V?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@@2@@0@AAV10@@Z
.text$mn:000050CC ??$forward@V?$vector@V?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@V?$allocator@V?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@@2@@std@@@std@@YA$$QAV?$vector@V?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@V?$allocator@V?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@@2@@0@AAV10@@Z proc near
.text$mn:000050CC                                         ; CODE XREF: std::vector<std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>>,std::allocator<std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>>>>::vector<std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>>,std::allocator<std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>>>>(std::vector<std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>>,std::allocator<std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>>>> &&)+52p
.text$mn:000050CC
.text$mn:000050CC arg_0           = dword ptr  8
.text$mn:000050CC
.text$mn:000050CC                 push    ebp
.text$mn:000050CD                 mov     ebp, esp
.text$mn:000050CF                 mov     eax, [ebp+arg_0]
.text$mn:000050D2                 pop     ebp
.text$mn:000050D3                 retn
.text$mn:000050D3 ??$forward@V?$vector@V?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@V?$allocator@V?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@@2@@std@@@std@@YA$$QAV?$vector@V?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@V?$allocator@V?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@@2@@0@AAV10@@Z endp
.text$mn:000050D3
.text$mn:000050D3 _text$mn        ends
.text$mn:000050D3
.text$mn:000050D4 ; ===========================================================================
.text$mn:000050D4
.text$mn:000050D4 ; Segment type: Pure code
.text$mn:000050D4 ; Segment permissions: Read/Execute
.text$mn:000050D4 _text$mn        segment para public 'CODE' use32
.text$mn:000050D4                 assume cs:_text$mn
.text$mn:000050D4                 ;org 50D4h
.text$mn:000050D4 ; COMDAT (pick any)
.text$mn:000050D4                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text$mn:000050D4
.text$mn:000050D4 ; =============== S U B R O U T I N E =======================================
.text$mn:000050D4
.text$mn:000050D4 ; Attributes: bp-based frame
.text$mn:000050D4
.text$mn:000050D4 ; wchar_t && __cdecl std::forward<wchar_t>(wchar_t &)
.text$mn:000050D4                 public ??$forward@_W@std@@YA$$QA_WAA_W@Z
.text$mn:000050D4 ??$forward@_W@std@@YA$$QA_WAA_W@Z proc near
.text$mn:000050D4                                         ; CODE XREF: std::_Wrap_alloc<std::allocator<wchar_t>>::construct<wchar_t,wchar_t>(wchar_t *,wchar_t &&)+Bp
.text$mn:000050D4                                         ; std::allocator<wchar_t>::construct<wchar_t,wchar_t>(wchar_t *,wchar_t &&)+4Ap ...
.text$mn:000050D4
.text$mn:000050D4 arg_0           = dword ptr  8
.text$mn:000050D4
.text$mn:000050D4                 push    ebp
.text$mn:000050D5                 mov     ebp, esp
.text$mn:000050D7                 mov     eax, [ebp+arg_0]
.text$mn:000050DA                 pop     ebp
.text$mn:000050DB                 retn
.text$mn:000050DB ??$forward@_W@std@@YA$$QA_WAA_W@Z endp
.text$mn:000050DB
.text$mn:000050DB _text$mn        ends
.text$mn:000050DB
.text$mn:000050DC ; ===========================================================================
.text$mn:000050DC
.text$mn:000050DC ; Segment type: Pure code
.text$mn:000050DC ; Segment permissions: Read/Execute
.text$mn:000050DC _text$mn        segment para public 'CODE' use32
.text$mn:000050DC                 assume cs:_text$mn
.text$mn:000050DC                 ;org 50DCh
.text$mn:000050DC ; COMDAT (pick any)
.text$mn:000050DC                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text$mn:000050DC
.text$mn:000050DC ; =============== S U B R O U T I N E =======================================
.text$mn:000050DC
.text$mn:000050DC ; Attributes: bp-based frame
.text$mn:000050DC
.text$mn:000050DC ; class std::_String_iterator<class std::_String_val<struct std::_Simple_types<wchar_t>>> __cdecl std::transform<class std::_String_iterator<class std::_String_val<struct std::_Simple_types<wchar_t>>>, class std::_String_iterator<class std::_String_val<struct std::_Simple_types<wchar_t>>>, int (__cdecl *)(int)>(class std::_String_iterator<class std::_String_val<struct std::_Simple_types<wchar_t>>>, class std::_String_iterator<class std::_String_val<struct std::_Simple_types<wchar_t>>>, class std::_String_iterator<class std::_String_val<struct std::_Simple_types<wchar_t>>>, int (__cdecl *)(int))
.text$mn:000050DC                 public ??$transform@V?$_String_iterator@V?$_String_val@U?$_Simple_types@_W@std@@@std@@@std@@V12@P6AHH@Z@std@@YA?AV?$_String_iterator@V?$_String_val@U?$_Simple_types@_W@std@@@std@@@0@V10@00P6AHH@Z@Z
.text$mn:000050DC ??$transform@V?$_String_iterator@V?$_String_val@U?$_Simple_types@_W@std@@@std@@@std@@V12@P6AHH@Z@std@@YA?AV?$_String_iterator@V?$_String_val@U?$_Simple_types@_W@std@@@std@@@0@V10@00P6AHH@Z@Z proc near
.text$mn:000050DC                                         ; CODE XREF: stringToUpper(std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>>)+9Ap
.text$mn:000050DC
.text$mn:000050DC var_68          = dword ptr -68h
.text$mn:000050DC var_64          = dword ptr -64h
.text$mn:000050DC var_60          = dword ptr -60h
.text$mn:000050DC var_5C          = dword ptr -5Ch
.text$mn:000050DC var_58          = dword ptr -58h
.text$mn:000050DC var_54          = dword ptr -54h
.text$mn:000050DC var_50          = dword ptr -50h
.text$mn:000050DC var_4C          = dword ptr -4Ch
.text$mn:000050DC var_48          = dword ptr -48h
.text$mn:000050DC var_44          = dword ptr -44h
.text$mn:000050DC var_40          = dword ptr -40h
.text$mn:000050DC var_3C          = dword ptr -3Ch
.text$mn:000050DC var_38          = dword ptr -38h
.text$mn:000050DC var_34          = dword ptr -34h
.text$mn:000050DC var_30          = dword ptr -30h
.text$mn:000050DC var_2C          = dword ptr -2Ch
.text$mn:000050DC var_28          = dword ptr -28h
.text$mn:000050DC var_24          = dword ptr -24h
.text$mn:000050DC var_20          = dword ptr -20h
.text$mn:000050DC var_1C          = dword ptr -1Ch
.text$mn:000050DC var_18          = dword ptr -18h
.text$mn:000050DC var_14          = dword ptr -14h
.text$mn:000050DC var_E           = byte ptr -0Eh
.text$mn:000050DC var_D           = byte ptr -0Dh
.text$mn:000050DC var_C           = dword ptr -0Ch
.text$mn:000050DC var_4           = dword ptr -4
.text$mn:000050DC arg_0           = dword ptr  8
.text$mn:000050DC arg_4           = byte ptr  0Ch
.text$mn:000050DC arg_10          = dword ptr  18h
.text$mn:000050DC arg_1C          = byte ptr  24h
.text$mn:000050DC arg_28          = dword ptr  30h
.text$mn:000050DC
.text$mn:000050DC                 push    ebp
.text$mn:000050DD                 mov     ebp, esp
.text$mn:000050DF                 push    0FFFFFFFFh
.text$mn:000050E1                 push    offset __ehhandler$??$transform@V?$_String_iterator@V?$_String_val@U?$_Simple_types@_W@std@@@std@@@std@@V12@P6AHH@Z@std@@YA?AV?$_String_iterator@V?$_String_val@U?$_Simple_types@_W@std@@@std@@@0@V10@00P6AHH@Z@Z
.text$mn:000050E6                 mov     eax, large fs:0
.text$mn:000050EC                 push    eax
.text$mn:000050ED                 sub     esp, 5Ch
.text$mn:000050F0                 mov     eax, dword ptr ds:___security_cookie
.text$mn:000050F5                 xor     eax, ebp
.text$mn:000050F7                 push    eax
.text$mn:000050F8                 lea     eax, [ebp+var_C]
.text$mn:000050FB                 mov     large fs:0, eax
.text$mn:00005101                 mov     [ebp+var_14], 0
.text$mn:00005108                 mov     [ebp+var_4], 3
.text$mn:0000510F                 push    3FDh            ; unsigned int
.text$mn:00005114                 push    offset ??_C@_1JC@HALMDPKM@?$AAC?$AA?3?$AA?2?$AAP?$AAr?$AAo?$AAg?$AAr?$AAa?$AAm?$AA?5?$AAF?$AAi?$AAl?$AAe?$AAs?$AA?5?$AA?$CI?$AAx?$AA8?$AA6?$AA?$CJ?$AA?2?$AAM?$AAi?$AAc?$AAr?$AAo?$AAs?$AAo?$AAf?$AAt@ ; "C:\\Program Files (x86)\\Microsoft Visu"...
.text$mn:00005119                 sub     esp, 0Ch
.text$mn:0000511C                 mov     ecx, esp
.text$mn:0000511E                 mov     [ebp+var_38], esp
.text$mn:00005121                 lea     eax, [ebp+arg_10]
.text$mn:00005124                 push    eax             ; int
.text$mn:00005125                 call    ??0?$_String_iterator@V?$_String_val@U?$_Simple_types@_W@std@@@std@@@std@@QAE@ABV01@@Z ; std::_String_iterator<std::_String_val<std::_Simple_types<wchar_t>>>::_String_iterator<std::_String_val<std::_Simple_types<wchar_t>>>(std::_String_iterator<std::_String_val<std::_Simple_types<wchar_t>>> const &)
.text$mn:0000512A                 mov     [ebp+var_18], eax
.text$mn:0000512D                 mov     ecx, [ebp+var_18]
.text$mn:00005130                 mov     [ebp+var_3C], ecx
.text$mn:00005133                 mov     byte ptr [ebp+var_4], 4
.text$mn:00005137                 sub     esp, 0Ch
.text$mn:0000513A                 mov     ecx, esp
.text$mn:0000513C                 mov     [ebp+var_40], esp
.text$mn:0000513F                 lea     edx, [ebp+arg_4]
.text$mn:00005142                 push    edx             ; struct std::_Iterator_base12 *
.text$mn:00005143                 call    ??0?$_String_iterator@V?$_String_val@U?$_Simple_types@_W@std@@@std@@@std@@QAE@ABV01@@Z ; std::_String_iterator<std::_String_val<std::_Simple_types<wchar_t>>>::_String_iterator<std::_String_val<std::_Simple_types<wchar_t>>>(std::_String_iterator<std::_String_val<std::_Simple_types<wchar_t>>> const &)
.text$mn:00005148                 mov     [ebp+var_1C], eax
.text$mn:0000514B                 mov     eax, [ebp+var_1C]
.text$mn:0000514E                 mov     [ebp+var_44], eax
.text$mn:00005151                 mov     byte ptr [ebp+var_4], 5
.text$mn:00005155                 mov     byte ptr [ebp+var_4], 3
.text$mn:00005159                 call    ??$_Debug_range@V?$_String_iterator@V?$_String_val@U?$_Simple_types@_W@std@@@std@@@std@@@std@@YAXV?$_String_iterator@V?$_String_val@U?$_Simple_types@_W@std@@@std@@@0@0PB_WI@Z ; std::_Debug_range<std::_String_iterator<std::_String_val<std::_Simple_types<wchar_t>>>>(std::_String_iterator<std::_String_val<std::_Simple_types<wchar_t>>>,std::_String_iterator<std::_String_val<std::_Simple_types<wchar_t>>>,wchar_t const *,uint)
.text$mn:0000515E                 add     esp, 20h
.text$mn:00005161                 push    3FEh
.text$mn:00005166                 push    offset ??_C@_1JC@HALMDPKM@?$AAC?$AA?3?$AA?2?$AAP?$AAr?$AAo?$AAg?$AAr?$AAa?$AAm?$AA?5?$AAF?$AAi?$AAl?$AAe?$AAs?$AA?5?$AA?$CI?$AAx?$AA8?$AA6?$AA?$CJ?$AA?2?$AAM?$AAi?$AAc?$AAr?$AAo?$AAs?$AAo?$AAf?$AAt@ ; "C:\\Program Files (x86)\\Microsoft Visu"...
.text$mn:0000516B                 lea     ecx, [ebp+arg_1C]
.text$mn:0000516E                 push    ecx
.text$mn:0000516F                 call    ??$_Debug_pointer@V?$_String_iterator@V?$_String_val@U?$_Simple_types@_W@std@@@std@@@std@@@std@@YAXAAV?$_String_iterator@V?$_String_val@U?$_Simple_types@_W@std@@@std@@@0@PB_WI@Z ; std::_Debug_pointer<std::_String_iterator<std::_String_val<std::_Simple_types<wchar_t>>>>(std::_String_iterator<std::_String_val<std::_Simple_types<wchar_t>>> &,wchar_t const *,uint)
.text$mn:00005174                 add     esp, 0Ch
.text$mn:00005177                 push    3FFh            ; unsigned int
.text$mn:0000517C                 push    offset ??_C@_1JC@HALMDPKM@?$AAC?$AA?3?$AA?2?$AAP?$AAr?$AAo?$AAg?$AAr?$AAa?$AAm?$AA?5?$AAF?$AAi?$AAl?$AAe?$AAs?$AA?5?$AA?$CI?$AAx?$AA8?$AA6?$AA?$CJ?$AA?2?$AAM?$AAi?$AAc?$AAr?$AAo?$AAs?$AAo?$AAf?$AAt@ ; "C:\\Program Files (x86)\\Microsoft Visu"...
.text$mn:00005181                 mov     edx, [ebp+arg_28]
.text$mn:00005184                 push    edx             ; int
.text$mn:00005185                 call    ??$_Debug_pointer@$$A6AHH@Z@std@@YAXP6AHH@ZPB_WI@Z ; std::_Debug_pointer<int (int)>(int (*)(int),wchar_t const *,uint)
.text$mn:0000518A                 add     esp, 0Ch
.text$mn:0000518D                 lea     eax, [ebp+arg_10]
.text$mn:00005190                 push    eax             ; std::_Iterator_base12 *
.text$mn:00005191                 lea     ecx, [ebp+arg_4]
.text$mn:00005194                 call    ??9?$_String_const_iterator@V?$_String_val@U?$_Simple_types@_W@std@@@std@@@std@@QBE_NABV01@@Z ; std::_String_const_iterator<std::_String_val<std::_Simple_types<wchar_t>>>::operator!=(std::_String_const_iterator<std::_String_val<std::_Simple_types<wchar_t>>> const &)
.text$mn:00005199                 movzx   ecx, al
.text$mn:0000519C                 test    ecx, ecx
.text$mn:0000519E                 jz      loc_52A5
.text$mn:000051A4                 sub     esp, 0Ch
.text$mn:000051A7                 mov     ecx, esp
.text$mn:000051A9                 mov     [ebp+var_48], esp
.text$mn:000051AC                 lea     edx, [ebp+arg_1C]
.text$mn:000051AF                 push    edx             ; struct std::_Iterator_base12 *
.text$mn:000051B0                 call    ??0?$_String_iterator@V?$_String_val@U?$_Simple_types@_W@std@@@std@@@std@@QAE@ABV01@@Z ; std::_String_iterator<std::_String_val<std::_Simple_types<wchar_t>>>::_String_iterator<std::_String_val<std::_Simple_types<wchar_t>>>(std::_String_iterator<std::_String_val<std::_Simple_types<wchar_t>>> const &)
.text$mn:000051B5                 mov     [ebp+var_20], eax
.text$mn:000051B8                 mov     eax, [ebp+var_20]
.text$mn:000051BB                 mov     [ebp+var_4C], eax
.text$mn:000051BE                 mov     byte ptr [ebp+var_4], 6
.text$mn:000051C2                 mov     byte ptr [ebp+var_4], 3
.text$mn:000051C6                 call    ??$_Is_checked@V?$_String_iterator@V?$_String_val@U?$_Simple_types@_W@std@@@std@@@std@@@std@@YA?AU?$integral_constant@_N$00@0@V?$_String_iterator@V?$_String_val@U?$_Simple_types@_W@std@@@std@@@0@@Z ; std::_Is_checked<std::_String_iterator<std::_String_val<std::_Simple_types<wchar_t>>>>(std::_String_iterator<std::_String_val<std::_Simple_types<wchar_t>>>)
.text$mn:000051CB                 add     esp, 0Ch
.text$mn:000051CE                 mov     [ebp+var_D], al
.text$mn:000051D1                 mov     cl, [ebp+var_D]
.text$mn:000051D4                 mov     [ebp+var_E], cl
.text$mn:000051D7                 movzx   edx, [ebp+var_E]
.text$mn:000051DB                 push    edx
.text$mn:000051DC                 mov     eax, [ebp+arg_28]
.text$mn:000051DF                 push    eax
.text$mn:000051E0                 sub     esp, 0Ch
.text$mn:000051E3                 mov     ecx, esp
.text$mn:000051E5                 mov     [ebp+var_50], esp
.text$mn:000051E8                 lea     edx, [ebp+arg_1C]
.text$mn:000051EB                 push    edx             ; struct std::_Iterator_base12 *
.text$mn:000051EC                 call    ??0?$_String_iterator@V?$_String_val@U?$_Simple_types@_W@std@@@std@@@std@@QAE@ABV01@@Z ; std::_String_iterator<std::_String_val<std::_Simple_types<wchar_t>>>::_String_iterator<std::_String_val<std::_Simple_types<wchar_t>>>(std::_String_iterator<std::_String_val<std::_Simple_types<wchar_t>>> const &)
.text$mn:000051F1                 mov     [ebp+var_24], eax
.text$mn:000051F4                 mov     eax, [ebp+var_24]
.text$mn:000051F7                 mov     [ebp+var_54], eax
.text$mn:000051FA                 mov     byte ptr [ebp+var_4], 7
.text$mn:000051FE                 sub     esp, 0Ch
.text$mn:00005201                 mov     ecx, esp
.text$mn:00005203                 mov     [ebp+var_58], esp
.text$mn:00005206                 lea     edx, [ebp+arg_10]
.text$mn:00005209                 push    edx             ; struct std::_Iterator_base12 *
.text$mn:0000520A                 call    ??0?$_String_iterator@V?$_String_val@U?$_Simple_types@_W@std@@@std@@@std@@QAE@ABV01@@Z ; std::_String_iterator<std::_String_val<std::_Simple_types<wchar_t>>>::_String_iterator<std::_String_val<std::_Simple_types<wchar_t>>>(std::_String_iterator<std::_String_val<std::_Simple_types<wchar_t>>> const &)
.text$mn:0000520F                 mov     [ebp+var_28], eax
.text$mn:00005212                 mov     eax, [ebp+var_28]
.text$mn:00005215                 mov     [ebp+var_5C], eax
.text$mn:00005218                 mov     byte ptr [ebp+var_4], 8
.text$mn:0000521C                 mov     byte ptr [ebp+var_4], 7
.text$mn:00005220                 call    ??$_Unchecked@V?$_String_val@U?$_Simple_types@_W@std@@@std@@@std@@YAPA_WV?$_String_iterator@V?$_String_val@U?$_Simple_types@_W@std@@@std@@@0@@Z ; std::_Unchecked<std::_String_val<std::_Simple_types<wchar_t>>>(std::_String_iterator<std::_String_val<std::_Simple_types<wchar_t>>>)
.text$mn:00005225                 add     esp, 0Ch
.text$mn:00005228                 mov     [ebp+var_2C], eax
.text$mn:0000522B                 mov     ecx, [ebp+var_2C]
.text$mn:0000522E                 push    ecx
.text$mn:0000522F                 sub     esp, 0Ch
.text$mn:00005232                 mov     ecx, esp
.text$mn:00005234                 mov     [ebp+var_60], esp
.text$mn:00005237                 lea     edx, [ebp+arg_4]
.text$mn:0000523A                 push    edx             ; struct std::_Iterator_base12 *
.text$mn:0000523B                 call    ??0?$_String_iterator@V?$_String_val@U?$_Simple_types@_W@std@@@std@@@std@@QAE@ABV01@@Z ; std::_String_iterator<std::_String_val<std::_Simple_types<wchar_t>>>::_String_iterator<std::_String_val<std::_Simple_types<wchar_t>>>(std::_String_iterator<std::_String_val<std::_Simple_types<wchar_t>>> const &)
.text$mn:00005240                 mov     [ebp+var_30], eax
.text$mn:00005243                 mov     eax, [ebp+var_30]
.text$mn:00005246                 mov     [ebp+var_64], eax
.text$mn:00005249                 mov     byte ptr [ebp+var_4], 9
.text$mn:0000524D                 mov     byte ptr [ebp+var_4], 7
.text$mn:00005251                 call    ??$_Unchecked@V?$_String_val@U?$_Simple_types@_W@std@@@std@@@std@@YAPA_WV?$_String_iterator@V?$_String_val@U?$_Simple_types@_W@std@@@std@@@0@@Z ; std::_Unchecked<std::_String_val<std::_Simple_types<wchar_t>>>(std::_String_iterator<std::_String_val<std::_Simple_types<wchar_t>>>)
.text$mn:00005256                 add     esp, 0Ch
.text$mn:00005259                 mov     [ebp+var_34], eax
.text$mn:0000525C                 mov     ecx, [ebp+var_34]
.text$mn:0000525F                 push    ecx
.text$mn:00005260                 mov     edx, [ebp+arg_0]
.text$mn:00005263                 push    edx
.text$mn:00005264                 mov     byte ptr [ebp+var_4], 3
.text$mn:00005268                 call    ??$_Transform1@PA_WV?$_String_iterator@V?$_String_val@U?$_Simple_types@_W@std@@@std@@@std@@P6AHH@Z@std@@YA?AV?$_String_iterator@V?$_String_val@U?$_Simple_types@_W@std@@@std@@@0@PA_W0V10@P6AHH@ZU?$integral_constant@_N$00@0@@Z ; std::_Transform1<wchar_t *,std::_String_iterator<std::_String_val<std::_Simple_types<wchar_t>>>,int (*)(int)>(wchar_t *,wchar_t *,std::_String_iterator<std::_String_val<std::_Simple_types<wchar_t>>>,int (*)(int),std::integral_constant<bool,1>)
.text$mn:0000526D                 add     esp, 20h
.text$mn:00005270                 mov     [ebp+var_68], eax
.text$mn:00005273                 mov     eax, [ebp+var_14]
.text$mn:00005276                 or      eax, 1
.text$mn:00005279                 mov     [ebp+var_14], eax
.text$mn:0000527C                 mov     byte ptr [ebp+var_4], 2
.text$mn:00005280                 lea     ecx, [ebp+arg_4]
.text$mn:00005283                 call    ??1?$_String_iterator@V?$_String_val@U?$_Simple_types@_W@std@@@std@@@std@@QAE@XZ ; std::_String_iterator<std::_String_val<std::_Simple_types<wchar_t>>>::~_String_iterator<std::_String_val<std::_Simple_types<wchar_t>>>(void)
.text$mn:00005288                 mov     byte ptr [ebp+var_4], 1
.text$mn:0000528C                 lea     ecx, [ebp+arg_10]
.text$mn:0000528F                 call    ??1?$_String_iterator@V?$_String_val@U?$_Simple_types@_W@std@@@std@@@std@@QAE@XZ ; std::_String_iterator<std::_String_val<std::_Simple_types<wchar_t>>>::~_String_iterator<std::_String_val<std::_Simple_types<wchar_t>>>(void)
.text$mn:00005294                 mov     byte ptr [ebp+var_4], 0
.text$mn:00005298                 lea     ecx, [ebp+arg_1C]
.text$mn:0000529B                 call    ??1?$_String_iterator@V?$_String_val@U?$_Simple_types@_W@std@@@std@@@std@@QAE@XZ ; std::_String_iterator<std::_String_val<std::_Simple_types<wchar_t>>>::~_String_iterator<std::_String_val<std::_Simple_types<wchar_t>>>(void)
.text$mn:000052A0                 mov     eax, [ebp+arg_0]
.text$mn:000052A3                 jmp     short loc_52E1
.text$mn:000052A5 ; ---------------------------------------------------------------------------
.text$mn:000052A5
.text$mn:000052A5 loc_52A5:                               ; CODE XREF: std::transform<std::_String_iterator<std::_String_val<std::_Simple_types<wchar_t>>>,std::_String_iterator<std::_String_val<std::_Simple_types<wchar_t>>>,int (*)(int)>(std::_String_iterator<std::_String_val<std::_Simple_types<wchar_t>>>,std::_String_iterator<std::_String_val<std::_Simple_types<wchar_t>>>,std::_String_iterator<std::_String_val<std::_Simple_types<wchar_t>>>,int (*)(int))+C2j
.text$mn:000052A5                 lea     ecx, [ebp+arg_1C]
.text$mn:000052A8                 push    ecx             ; struct std::_Iterator_base12 *
.text$mn:000052A9                 mov     ecx, [ebp+arg_0]
.text$mn:000052AC                 call    ??0?$_String_iterator@V?$_String_val@U?$_Simple_types@_W@std@@@std@@@std@@QAE@ABV01@@Z ; std::_String_iterator<std::_String_val<std::_Simple_types<wchar_t>>>::_String_iterator<std::_String_val<std::_Simple_types<wchar_t>>>(std::_String_iterator<std::_String_val<std::_Simple_types<wchar_t>>> const &)
.text$mn:000052B1                 mov     edx, [ebp+var_14]
.text$mn:000052B4                 or      edx, 1
.text$mn:000052B7                 mov     [ebp+var_14], edx
.text$mn:000052BA                 mov     byte ptr [ebp+var_4], 2
.text$mn:000052BE                 lea     ecx, [ebp+arg_4]
.text$mn:000052C1                 call    ??1?$_String_iterator@V?$_String_val@U?$_Simple_types@_W@std@@@std@@@std@@QAE@XZ ; std::_String_iterator<std::_String_val<std::_Simple_types<wchar_t>>>::~_String_iterator<std::_String_val<std::_Simple_types<wchar_t>>>(void)
.text$mn:000052C6                 mov     byte ptr [ebp+var_4], 1
.text$mn:000052CA                 lea     ecx, [ebp+arg_10]
.text$mn:000052CD                 call    ??1?$_String_iterator@V?$_String_val@U?$_Simple_types@_W@std@@@std@@@std@@QAE@XZ ; std::_String_iterator<std::_String_val<std::_Simple_types<wchar_t>>>::~_String_iterator<std::_String_val<std::_Simple_types<wchar_t>>>(void)
.text$mn:000052D2                 mov     byte ptr [ebp+var_4], 0
.text$mn:000052D6                 lea     ecx, [ebp+arg_1C]
.text$mn:000052D9                 call    ??1?$_String_iterator@V?$_String_val@U?$_Simple_types@_W@std@@@std@@@std@@QAE@XZ ; std::_String_iterator<std::_String_val<std::_Simple_types<wchar_t>>>::~_String_iterator<std::_String_val<std::_Simple_types<wchar_t>>>(void)
.text$mn:000052DE                 mov     eax, [ebp+arg_0]
.text$mn:000052E1
.text$mn:000052E1 loc_52E1:                               ; CODE XREF: std::transform<std::_String_iterator<std::_String_val<std::_Simple_types<wchar_t>>>,std::_String_iterator<std::_String_val<std::_Simple_types<wchar_t>>>,int (*)(int)>(std::_String_iterator<std::_String_val<std::_Simple_types<wchar_t>>>,std::_String_iterator<std::_String_val<std::_Simple_types<wchar_t>>>,std::_String_iterator<std::_String_val<std::_Simple_types<wchar_t>>>,int (*)(int))+1C7j
.text$mn:000052E1                 mov     ecx, [ebp+var_C]
.text$mn:000052E4                 mov     large fs:0, ecx
.text$mn:000052EB                 pop     ecx
.text$mn:000052EC                 mov     esp, ebp
.text$mn:000052EE                 pop     ebp
.text$mn:000052EF                 retn
.text$mn:000052EF ??$transform@V?$_String_iterator@V?$_String_val@U?$_Simple_types@_W@std@@@std@@@std@@V12@P6AHH@Z@std@@YA?AV?$_String_iterator@V?$_String_val@U?$_Simple_types@_W@std@@@std@@@0@V10@00P6AHH@Z@Z endp
.text$mn:000052EF
.text$mn:000052EF _text$mn        ends
.text$mn:000052EF
.text$x:000052F0 ; ===========================================================================
.text$x:000052F0
.text$x:000052F0 ; Segment type: Pure code
.text$x:000052F0 ; Segment permissions: Read/Execute
.text$x:000052F0 _text$x         segment para public 'CODE' use32
.text$x:000052F0                 assume cs:_text$x
.text$x:000052F0                 ;org 52F0h
.text$x:000052F0 ; COMDAT (pick associative to section at 50DC)
.text$x:000052F0                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text$x:000052F0
.text$x:000052F0 ; =============== S U B R O U T I N E =======================================
.text$x:000052F0
.text$x:000052F0
.text$x:000052F0 __unwindfunclet$??$transform@V?$_String_iterator@V?$_String_val@U?$_Simple_types@_W@std@@@std@@@std@@V12@P6AHH@Z@std@@YA?AV?$_String_iterator@V?$_String_val@U?$_Simple_types@_W@std@@@std@@@0@V10@00P6AHH@Z@Z$0 proc near
.text$x:000052F0                                         ; DATA XREF: .xdata$x:0000EDA0o
.text$x:000052F0                 lea     ecx, [ebp+24h]
.text$x:000052F3                 jmp     ??1?$_String_iterator@V?$_String_val@U?$_Simple_types@_W@std@@@std@@@std@@QAE@XZ ; std::_String_iterator<std::_String_val<std::_Simple_types<wchar_t>>>::~_String_iterator<std::_String_val<std::_Simple_types<wchar_t>>>(void)
.text$x:000052F3 __unwindfunclet$??$transform@V?$_String_iterator@V?$_String_val@U?$_Simple_types@_W@std@@@std@@@std@@V12@P6AHH@Z@std@@YA?AV?$_String_iterator@V?$_String_val@U?$_Simple_types@_W@std@@@std@@@0@V10@00P6AHH@Z@Z$0 endp
.text$x:000052F3
.text$x:000052F8
.text$x:000052F8 ; =============== S U B R O U T I N E =======================================
.text$x:000052F8
.text$x:000052F8
.text$x:000052F8 __unwindfunclet$??$transform@V?$_String_iterator@V?$_String_val@U?$_Simple_types@_W@std@@@std@@@std@@V12@P6AHH@Z@std@@YA?AV?$_String_iterator@V?$_String_val@U?$_Simple_types@_W@std@@@std@@@0@V10@00P6AHH@Z@Z$1 proc near
.text$x:000052F8                                         ; DATA XREF: .xdata$x:0000EDA8o
.text$x:000052F8                 lea     ecx, [ebp+18h]
.text$x:000052FB                 jmp     ??1?$_String_iterator@V?$_String_val@U?$_Simple_types@_W@std@@@std@@@std@@QAE@XZ ; std::_String_iterator<std::_String_val<std::_Simple_types<wchar_t>>>::~_String_iterator<std::_String_val<std::_Simple_types<wchar_t>>>(void)
.text$x:000052FB __unwindfunclet$??$transform@V?$_String_iterator@V?$_String_val@U?$_Simple_types@_W@std@@@std@@@std@@V12@P6AHH@Z@std@@YA?AV?$_String_iterator@V?$_String_val@U?$_Simple_types@_W@std@@@std@@@0@V10@00P6AHH@Z@Z$1 endp
.text$x:000052FB
.text$x:00005300
.text$x:00005300 ; =============== S U B R O U T I N E =======================================
.text$x:00005300
.text$x:00005300
.text$x:00005300 __unwindfunclet$??$transform@V?$_String_iterator@V?$_String_val@U?$_Simple_types@_W@std@@@std@@@std@@V12@P6AHH@Z@std@@YA?AV?$_String_iterator@V?$_String_val@U?$_Simple_types@_W@std@@@std@@@0@V10@00P6AHH@Z@Z$2 proc near
.text$x:00005300                                         ; DATA XREF: .xdata$x:0000EDB0o
.text$x:00005300                 lea     ecx, [ebp+0Ch]
.text$x:00005303                 jmp     ??1?$_String_iterator@V?$_String_val@U?$_Simple_types@_W@std@@@std@@@std@@QAE@XZ ; std::_String_iterator<std::_String_val<std::_Simple_types<wchar_t>>>::~_String_iterator<std::_String_val<std::_Simple_types<wchar_t>>>(void)
.text$x:00005303 __unwindfunclet$??$transform@V?$_String_iterator@V?$_String_val@U?$_Simple_types@_W@std@@@std@@@std@@V12@P6AHH@Z@std@@YA?AV?$_String_iterator@V?$_String_val@U?$_Simple_types@_W@std@@@std@@@0@V10@00P6AHH@Z@Z$2 endp
.text$x:00005303
.text$x:00005308
.text$x:00005308 ; =============== S U B R O U T I N E =======================================
.text$x:00005308
.text$x:00005308
.text$x:00005308 __unwindfunclet$??$transform@V?$_String_iterator@V?$_String_val@U?$_Simple_types@_W@std@@@std@@@std@@V12@P6AHH@Z@std@@YA?AV?$_String_iterator@V?$_String_val@U?$_Simple_types@_W@std@@@std@@@0@V10@00P6AHH@Z@Z$3 proc near
.text$x:00005308                                         ; DATA XREF: .xdata$x:0000EDB8o
.text$x:00005308                 mov     ecx, [ebp-38h]
.text$x:0000530B                 jmp     ??1?$_String_iterator@V?$_String_val@U?$_Simple_types@_W@std@@@std@@@std@@QAE@XZ ; std::_String_iterator<std::_String_val<std::_Simple_types<wchar_t>>>::~_String_iterator<std::_String_val<std::_Simple_types<wchar_t>>>(void)
.text$x:0000530B __unwindfunclet$??$transform@V?$_String_iterator@V?$_String_val@U?$_Simple_types@_W@std@@@std@@@std@@V12@P6AHH@Z@std@@YA?AV?$_String_iterator@V?$_String_val@U?$_Simple_types@_W@std@@@std@@@0@V10@00P6AHH@Z@Z$3 endp
.text$x:0000530B
.text$x:00005310
.text$x:00005310 ; =============== S U B R O U T I N E =======================================
.text$x:00005310
.text$x:00005310
.text$x:00005310 __unwindfunclet$??$transform@V?$_String_iterator@V?$_String_val@U?$_Simple_types@_W@std@@@std@@@std@@V12@P6AHH@Z@std@@YA?AV?$_String_iterator@V?$_String_val@U?$_Simple_types@_W@std@@@std@@@0@V10@00P6AHH@Z@Z$4 proc near
.text$x:00005310                                         ; DATA XREF: .xdata$x:0000EDC0o
.text$x:00005310                 mov     ecx, [ebp-40h]
.text$x:00005313                 jmp     ??1?$_String_iterator@V?$_String_val@U?$_Simple_types@_W@std@@@std@@@std@@QAE@XZ ; std::_String_iterator<std::_String_val<std::_Simple_types<wchar_t>>>::~_String_iterator<std::_String_val<std::_Simple_types<wchar_t>>>(void)
.text$x:00005313 __unwindfunclet$??$transform@V?$_String_iterator@V?$_String_val@U?$_Simple_types@_W@std@@@std@@@std@@V12@P6AHH@Z@std@@YA?AV?$_String_iterator@V?$_String_val@U?$_Simple_types@_W@std@@@std@@@0@V10@00P6AHH@Z@Z$4 endp
.text$x:00005313
.text$x:00005318
.text$x:00005318 ; =============== S U B R O U T I N E =======================================
.text$x:00005318
.text$x:00005318
.text$x:00005318 __unwindfunclet$??$transform@V?$_String_iterator@V?$_String_val@U?$_Simple_types@_W@std@@@std@@@std@@V12@P6AHH@Z@std@@YA?AV?$_String_iterator@V?$_String_val@U?$_Simple_types@_W@std@@@std@@@0@V10@00P6AHH@Z@Z$5 proc near
.text$x:00005318                                         ; DATA XREF: .xdata$x:0000EDC8o
.text$x:00005318                 mov     ecx, [ebp-48h]
.text$x:0000531B                 jmp     ??1?$_String_iterator@V?$_String_val@U?$_Simple_types@_W@std@@@std@@@std@@QAE@XZ ; std::_String_iterator<std::_String_val<std::_Simple_types<wchar_t>>>::~_String_iterator<std::_String_val<std::_Simple_types<wchar_t>>>(void)
.text$x:0000531B __unwindfunclet$??$transform@V?$_String_iterator@V?$_String_val@U?$_Simple_types@_W@std@@@std@@@std@@V12@P6AHH@Z@std@@YA?AV?$_String_iterator@V?$_String_val@U?$_Simple_types@_W@std@@@std@@@0@V10@00P6AHH@Z@Z$5 endp
.text$x:0000531B
.text$x:00005320
.text$x:00005320 ; =============== S U B R O U T I N E =======================================
.text$x:00005320
.text$x:00005320
.text$x:00005320 __unwindfunclet$??$transform@V?$_String_iterator@V?$_String_val@U?$_Simple_types@_W@std@@@std@@@std@@V12@P6AHH@Z@std@@YA?AV?$_String_iterator@V?$_String_val@U?$_Simple_types@_W@std@@@std@@@0@V10@00P6AHH@Z@Z$6 proc near
.text$x:00005320                                         ; DATA XREF: .xdata$x:0000EDD0o
.text$x:00005320                 mov     ecx, [ebp-50h]
.text$x:00005323                 jmp     ??1?$_String_iterator@V?$_String_val@U?$_Simple_types@_W@std@@@std@@@std@@QAE@XZ ; std::_String_iterator<std::_String_val<std::_Simple_types<wchar_t>>>::~_String_iterator<std::_String_val<std::_Simple_types<wchar_t>>>(void)
.text$x:00005323 __unwindfunclet$??$transform@V?$_String_iterator@V?$_String_val@U?$_Simple_types@_W@std@@@std@@@std@@V12@P6AHH@Z@std@@YA?AV?$_String_iterator@V?$_String_val@U?$_Simple_types@_W@std@@@std@@@0@V10@00P6AHH@Z@Z$6 endp
.text$x:00005323
.text$x:00005328
.text$x:00005328 ; =============== S U B R O U T I N E =======================================
.text$x:00005328
.text$x:00005328
.text$x:00005328 __unwindfunclet$??$transform@V?$_String_iterator@V?$_String_val@U?$_Simple_types@_W@std@@@std@@@std@@V12@P6AHH@Z@std@@YA?AV?$_String_iterator@V?$_String_val@U?$_Simple_types@_W@std@@@std@@@0@V10@00P6AHH@Z@Z$7 proc near
.text$x:00005328                                         ; DATA XREF: .xdata$x:0000EDD8o
.text$x:00005328                 mov     ecx, [ebp-58h]
.text$x:0000532B                 jmp     ??1?$_String_iterator@V?$_String_val@U?$_Simple_types@_W@std@@@std@@@std@@QAE@XZ ; std::_String_iterator<std::_String_val<std::_Simple_types<wchar_t>>>::~_String_iterator<std::_String_val<std::_Simple_types<wchar_t>>>(void)
.text$x:0000532B __unwindfunclet$??$transform@V?$_String_iterator@V?$_String_val@U?$_Simple_types@_W@std@@@std@@@std@@V12@P6AHH@Z@std@@YA?AV?$_String_iterator@V?$_String_val@U?$_Simple_types@_W@std@@@std@@@0@V10@00P6AHH@Z@Z$7 endp
.text$x:0000532B
.text$x:00005330
.text$x:00005330 ; =============== S U B R O U T I N E =======================================
.text$x:00005330
.text$x:00005330
.text$x:00005330 __unwindfunclet$??$transform@V?$_String_iterator@V?$_String_val@U?$_Simple_types@_W@std@@@std@@@std@@V12@P6AHH@Z@std@@YA?AV?$_String_iterator@V?$_String_val@U?$_Simple_types@_W@std@@@std@@@0@V10@00P6AHH@Z@Z$8 proc near
.text$x:00005330                                         ; DATA XREF: .xdata$x:0000EDE0o
.text$x:00005330                 mov     ecx, [ebp-60h]
.text$x:00005333                 jmp     ??1?$_String_iterator@V?$_String_val@U?$_Simple_types@_W@std@@@std@@@std@@QAE@XZ ; std::_String_iterator<std::_String_val<std::_Simple_types<wchar_t>>>::~_String_iterator<std::_String_val<std::_Simple_types<wchar_t>>>(void)
.text$x:00005333 __unwindfunclet$??$transform@V?$_String_iterator@V?$_String_val@U?$_Simple_types@_W@std@@@std@@@std@@V12@P6AHH@Z@std@@YA?AV?$_String_iterator@V?$_String_val@U?$_Simple_types@_W@std@@@std@@@0@V10@00P6AHH@Z@Z$8 endp
.text$x:00005333
.text$x:00005338
.text$x:00005338 ; =============== S U B R O U T I N E =======================================
.text$x:00005338
.text$x:00005338
.text$x:00005338 __unwindfunclet$??$transform@V?$_String_iterator@V?$_String_val@U?$_Simple_types@_W@std@@@std@@@std@@V12@P6AHH@Z@std@@YA?AV?$_String_iterator@V?$_String_val@U?$_Simple_types@_W@std@@@std@@@0@V10@00P6AHH@Z@Z$9 proc near
.text$x:00005338                                         ; DATA XREF: .xdata$x:0000ED98o
.text$x:00005338                 mov     eax, [ebp-14h]
.text$x:0000533B                 and     eax, 1
.text$x:0000533E                 jz      $LN14
.text$x:00005344                 and     dword ptr [ebp-14h], 0FFFFFFFEh
.text$x:00005348                 mov     ecx, [ebp+8]
.text$x:0000534B                 jmp     ??1?$_String_iterator@V?$_String_val@U?$_Simple_types@_W@std@@@std@@@std@@QAE@XZ ; std::_String_iterator<std::_String_val<std::_Simple_types<wchar_t>>>::~_String_iterator<std::_String_val<std::_Simple_types<wchar_t>>>(void)
.text$x:00005350 ; ---------------------------------------------------------------------------
.text$x:00005350
.text$x:00005350 $LN14:                                  ; CODE XREF: __unwindfunclet$??$transform@V?$_String_iterator@V?$_String_val@U?$_Simple_types@_W@std@@@std@@@std@@V12@P6AHH@Z@std@@YA?AV?$_String_iterator@V?$_String_val@U?$_Simple_types@_W@std@@@std@@@0@V10@00P6AHH@Z@Z$9+6j
.text$x:00005350                 retn
.text$x:00005350 __unwindfunclet$??$transform@V?$_String_iterator@V?$_String_val@U?$_Simple_types@_W@std@@@std@@@std@@V12@P6AHH@Z@std@@YA?AV?$_String_iterator@V?$_String_val@U?$_Simple_types@_W@std@@@std@@@0@V10@00P6AHH@Z@Z$9 endp
.text$x:00005350
.text$x:00005351
.text$x:00005351 ; =============== S U B R O U T I N E =======================================
.text$x:00005351
.text$x:00005351
.text$x:00005351 __ehhandler$??$transform@V?$_String_iterator@V?$_String_val@U?$_Simple_types@_W@std@@@std@@@std@@V12@P6AHH@Z@std@@YA?AV?$_String_iterator@V?$_String_val@U?$_Simple_types@_W@std@@@std@@@0@V10@00P6AHH@Z@Z proc near
.text$x:00005351                                         ; DATA XREF: std::transform<std::_String_iterator<std::_String_val<std::_Simple_types<wchar_t>>>,std::_String_iterator<std::_String_val<std::_Simple_types<wchar_t>>>,int (*)(int)>(std::_String_iterator<std::_String_val<std::_Simple_types<wchar_t>>>,std::_String_iterator<std::_String_val<std::_Simple_types<wchar_t>>>,std::_String_iterator<std::_String_val<std::_Simple_types<wchar_t>>>,int (*)(int))+5o
.text$x:00005351
.text$x:00005351 arg_4           = dword ptr  8
.text$x:00005351
.text$x:00005351                 mov     edx, [esp+arg_4]
.text$x:00005355                 lea     eax, [edx+0Ch]
.text$x:00005358                 mov     ecx, [edx-60h]
.text$x:0000535B                 xor     ecx, eax
.text$x:0000535D                 call    @__security_check_cookie@4 ; __security_check_cookie(x)
.text$x:00005362                 mov     eax, offset __ehfuncinfo$??$transform@V?$_String_iterator@V?$_String_val@U?$_Simple_types@_W@std@@@std@@@std@@V12@P6AHH@Z@std@@YA?AV?$_String_iterator@V?$_String_val@U?$_Simple_types@_W@std@@@std@@@0@V10@00P6AHH@Z@Z
.text$x:00005367                 jmp     ___CxxFrameHandler3
.text$x:00005367 __ehhandler$??$transform@V?$_String_iterator@V?$_String_val@U?$_Simple_types@_W@std@@@std@@@std@@V12@P6AHH@Z@std@@YA?AV?$_String_iterator@V?$_String_val@U?$_Simple_types@_W@std@@@std@@@0@V10@00P6AHH@Z@Z endp
.text$x:00005367
.text$x:00005367 _text$x         ends
.text$x:00005367
.text$mn:0000536C ; ===========================================================================
.text$mn:0000536C
.text$mn:0000536C ; Segment type: Pure code
.text$mn:0000536C ; Segment permissions: Read/Execute
.text$mn:0000536C _text$mn        segment para public 'CODE' use32
.text$mn:0000536C                 assume cs:_text$mn
.text$mn:0000536C                 ;org 536Ch
.text$mn:0000536C ; COMDAT (pick any)
.text$mn:0000536C                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text$mn:0000536C
.text$mn:0000536C ; =============== S U B R O U T I N E =======================================
.text$mn:0000536C
.text$mn:0000536C ; Attributes: bp-based frame
.text$mn:0000536C
.text$mn:0000536C ; public: __thiscall WcharMbcsConvertor::StringBuffer<char>::StringBuffer<char>(void)
.text$mn:0000536C                 public ??0?$StringBuffer@D@WcharMbcsConvertor@@QAE@XZ
.text$mn:0000536C ??0?$StringBuffer@D@WcharMbcsConvertor@@QAE@XZ proc near
.text$mn:0000536C                                         ; CODE XREF: WcharMbcsConvertor::WcharMbcsConvertor(void)+29p
.text$mn:0000536C
.text$mn:0000536C var_4           = dword ptr -4
.text$mn:0000536C
.text$mn:0000536C                 push    ebp
.text$mn:0000536D                 mov     ebp, esp
.text$mn:0000536F                 push    ecx
.text$mn:00005370                 mov     [ebp+var_4], ecx
.text$mn:00005373                 mov     eax, [ebp+var_4]
.text$mn:00005376                 mov     dword ptr [eax], 0
.text$mn:0000537C                 mov     ecx, [ebp+var_4]
.text$mn:0000537F                 mov     dword ptr [ecx+4], 0
.text$mn:00005386                 mov     eax, [ebp+var_4]
.text$mn:00005389                 mov     esp, ebp
.text$mn:0000538B                 pop     ebp
.text$mn:0000538C                 retn
.text$mn:0000538C ??0?$StringBuffer@D@WcharMbcsConvertor@@QAE@XZ endp
.text$mn:0000538C
.text$mn:0000538C ; ---------------------------------------------------------------------------
.text$mn:0000538D                 align 10h
.text$mn:0000538D _text$mn        ends
.text$mn:0000538D
.text$mn:00005390 ; ===========================================================================
.text$mn:00005390
.text$mn:00005390 ; Segment type: Pure code
.text$mn:00005390 ; Segment permissions: Read/Execute
.text$mn:00005390 _text$mn        segment para public 'CODE' use32
.text$mn:00005390                 assume cs:_text$mn
.text$mn:00005390                 ;org 5390h
.text$mn:00005390 ; COMDAT (pick any)
.text$mn:00005390                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text$mn:00005390
.text$mn:00005390 ; =============== S U B R O U T I N E =======================================
.text$mn:00005390
.text$mn:00005390 ; Attributes: bp-based frame
.text$mn:00005390
.text$mn:00005390 ; public: __thiscall WcharMbcsConvertor::StringBuffer<wchar_t>::StringBuffer<wchar_t>(void)
.text$mn:00005390                 public ??0?$StringBuffer@_W@WcharMbcsConvertor@@QAE@XZ
.text$mn:00005390 ??0?$StringBuffer@_W@WcharMbcsConvertor@@QAE@XZ proc near
.text$mn:00005390                                         ; CODE XREF: WcharMbcsConvertor::WcharMbcsConvertor(void)+3Bp
.text$mn:00005390
.text$mn:00005390 var_4           = dword ptr -4
.text$mn:00005390
.text$mn:00005390                 push    ebp
.text$mn:00005391                 mov     ebp, esp
.text$mn:00005393                 push    ecx
.text$mn:00005394                 mov     [ebp+var_4], ecx
.text$mn:00005397                 mov     eax, [ebp+var_4]
.text$mn:0000539A                 mov     dword ptr [eax], 0
.text$mn:000053A0                 mov     ecx, [ebp+var_4]
.text$mn:000053A3                 mov     dword ptr [ecx+4], 0
.text$mn:000053AA                 mov     eax, [ebp+var_4]
.text$mn:000053AD                 mov     esp, ebp
.text$mn:000053AF                 pop     ebp
.text$mn:000053B0                 retn
.text$mn:000053B0 ??0?$StringBuffer@_W@WcharMbcsConvertor@@QAE@XZ endp
.text$mn:000053B0
.text$mn:000053B0 ; ---------------------------------------------------------------------------
.text$mn:000053B1                 align 4
.text$mn:000053B1 _text$mn        ends
.text$mn:000053B1
.text$mn:000053B4 ; ===========================================================================
.text$mn:000053B4
.text$mn:000053B4 ; Segment type: Pure code
.text$mn:000053B4 ; Segment permissions: Read/Execute
.text$mn:000053B4 _text$mn        segment para public 'CODE' use32
.text$mn:000053B4                 assume cs:_text$mn
.text$mn:000053B4                 ;org 53B4h
.text$mn:000053B4 ; COMDAT (pick any)
.text$mn:000053B4                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text$mn:000053B4
.text$mn:000053B4 ; =============== S U B R O U T I N E =======================================
.text$mn:000053B4
.text$mn:000053B4 ; Attributes: bp-based frame
.text$mn:000053B4
.text$mn:000053B4 ; int __stdcall std::_Iterator012<std::random_access_iterator_tag,wchar_t,int,wchar_t const *,wchar_t const &,std::_Iterator_base12>::_Iterator012<std::random_access_iterator_tag,wchar_t,int,wchar_t const *,wchar_t const &,std::_Iterator_base12>(struct std::_Iterator_base12 *)
.text$mn:000053B4                 public ??0?$_Iterator012@Urandom_access_iterator_tag@std@@_WHPB_WAB_WU_Iterator_base12@2@@std@@QAE@ABU01@@Z
.text$mn:000053B4 ??0?$_Iterator012@Urandom_access_iterator_tag@std@@_WHPB_WAB_WU_Iterator_base12@2@@std@@QAE@ABU01@@Z proc near
.text$mn:000053B4                                         ; CODE XREF: std::_String_const_iterator<std::_String_val<std::_Simple_types<wchar_t>>>::_String_const_iterator<std::_String_val<std::_Simple_types<wchar_t>>>(std::_String_const_iterator<std::_String_val<std::_Simple_types<wchar_t>>> const &)+2Dp
.text$mn:000053B4                                         ; std::_Vector_const_iterator<std::_Vector_val<std::_Simple_types<wchar_t>>>::_Vector_const_iterator<std::_Vector_val<std::_Simple_types<wchar_t>>>(std::_Vector_const_iterator<std::_Vector_val<std::_Simple_types<wchar_t>>> const &)+2Dp
.text$mn:000053B4
.text$mn:000053B4 var_10          = dword ptr -10h
.text$mn:000053B4 var_C           = dword ptr -0Ch
.text$mn:000053B4 var_4           = dword ptr -4
.text$mn:000053B4 arg_0           = dword ptr  8
.text$mn:000053B4
.text$mn:000053B4                 push    ebp
.text$mn:000053B5                 mov     ebp, esp
.text$mn:000053B7                 push    0FFFFFFFFh
.text$mn:000053B9                 push    offset __ehhandler$??0?$_Iterator012@Urandom_access_iterator_tag@std@@_WHPB_WAB_WU_Iterator_base12@2@@std@@QAE@ABU01@@Z
.text$mn:000053BE                 mov     eax, large fs:0
.text$mn:000053C4                 push    eax
.text$mn:000053C5                 push    ecx
.text$mn:000053C6                 mov     eax, dword ptr ds:___security_cookie
.text$mn:000053CB                 xor     eax, ebp
.text$mn:000053CD                 push    eax
.text$mn:000053CE                 lea     eax, [ebp+var_C]
.text$mn:000053D1                 mov     large fs:0, eax
.text$mn:000053D7                 mov     [ebp+var_10], ecx
.text$mn:000053DA                 mov     eax, [ebp+arg_0]
.text$mn:000053DD                 push    eax             ; struct std::_Iterator_base12 *
.text$mn:000053DE                 mov     ecx, [ebp+var_10] ; this
.text$mn:000053E1                 call    ??0_Iterator_base12@std@@QAE@ABU01@@Z ; std::_Iterator_base12::_Iterator_base12(std::_Iterator_base12 const &)
.text$mn:000053E6                 mov     [ebp+var_4], 0
.text$mn:000053ED                 mov     [ebp+var_4], 0FFFFFFFFh
.text$mn:000053F4                 mov     eax, [ebp+var_10]
.text$mn:000053F7                 mov     ecx, [ebp+var_C]
.text$mn:000053FA                 mov     large fs:0, ecx
.text$mn:00005401                 pop     ecx
.text$mn:00005402                 mov     esp, ebp
.text$mn:00005404                 pop     ebp
.text$mn:00005405                 retn    4
.text$mn:00005405 ??0?$_Iterator012@Urandom_access_iterator_tag@std@@_WHPB_WAB_WU_Iterator_base12@2@@std@@QAE@ABU01@@Z endp
.text$mn:00005405
.text$mn:00005405 _text$mn        ends
.text$mn:00005405
.text$x:00005408 ; ===========================================================================
.text$x:00005408
.text$x:00005408 ; Segment type: Pure code
.text$x:00005408 ; Segment permissions: Read/Execute
.text$x:00005408 _text$x         segment para public 'CODE' use32
.text$x:00005408                 assume cs:_text$x
.text$x:00005408                 ;org 5408h
.text$x:00005408 ; COMDAT (pick associative to section at 53B4)
.text$x:00005408                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text$x:00005408
.text$x:00005408 ; =============== S U B R O U T I N E =======================================
.text$x:00005408
.text$x:00005408
.text$x:00005408 __unwindfunclet$??0?$_Iterator012@Urandom_access_iterator_tag@std@@_WHPB_WAB_WU_Iterator_base12@2@@std@@QAE@ABU01@@Z$0 proc near
.text$x:00005408                                         ; DATA XREF: .xdata$x:0000E80Co
.text$x:00005408                 mov     ecx, [ebp-10h]  ; this
.text$x:0000540B                 jmp     ??1_Iterator_base12@std@@QAE@XZ ; std::_Iterator_base12::~_Iterator_base12(void)
.text$x:0000540B __unwindfunclet$??0?$_Iterator012@Urandom_access_iterator_tag@std@@_WHPB_WAB_WU_Iterator_base12@2@@std@@QAE@ABU01@@Z$0 endp
.text$x:0000540B
.text$x:00005410
.text$x:00005410 ; =============== S U B R O U T I N E =======================================
.text$x:00005410
.text$x:00005410
.text$x:00005410 __ehhandler$??0?$_Iterator012@Urandom_access_iterator_tag@std@@_WHPB_WAB_WU_Iterator_base12@2@@std@@QAE@ABU01@@Z proc near
.text$x:00005410                                         ; DATA XREF: std::_Iterator012<std::random_access_iterator_tag,wchar_t,int,wchar_t const *,wchar_t const &,std::_Iterator_base12>::_Iterator012<std::random_access_iterator_tag,wchar_t,int,wchar_t const *,wchar_t const &,std::_Iterator_base12>(std::_Iterator012<std::random_access_iterator_tag,wchar_t,int,wchar_t const *,wchar_t const &,std::_Iterator_base12> const &)+5o
.text$x:00005410
.text$x:00005410 arg_4           = dword ptr  8
.text$x:00005410
.text$x:00005410                 mov     edx, [esp+arg_4]
.text$x:00005414                 lea     eax, [edx+0Ch]
.text$x:00005417                 mov     ecx, [edx-8]
.text$x:0000541A                 xor     ecx, eax
.text$x:0000541C                 call    @__security_check_cookie@4 ; __security_check_cookie(x)
.text$x:00005421                 mov     eax, offset __ehfuncinfo$??0?$_Iterator012@Urandom_access_iterator_tag@std@@_WHPB_WAB_WU_Iterator_base12@2@@std@@QAE@ABU01@@Z
.text$x:00005426                 jmp     ___CxxFrameHandler3
.text$x:00005426 __ehhandler$??0?$_Iterator012@Urandom_access_iterator_tag@std@@_WHPB_WAB_WU_Iterator_base12@2@@std@@QAE@ABU01@@Z endp
.text$x:00005426
.text$x:00005426 ; ---------------------------------------------------------------------------
.text$x:0000542B                 align 4
.text$x:0000542B _text$x         ends
.text$x:0000542B
.text$mn:0000542C ; ===========================================================================
.text$mn:0000542C
.text$mn:0000542C ; Segment type: Pure code
.text$mn:0000542C ; Segment permissions: Read/Execute
.text$mn:0000542C _text$mn        segment para public 'CODE' use32
.text$mn:0000542C                 assume cs:_text$mn
.text$mn:0000542C                 ;org 542Ch
.text$mn:0000542C ; COMDAT (pick any)
.text$mn:0000542C                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text$mn:0000542C
.text$mn:0000542C ; =============== S U B R O U T I N E =======================================
.text$mn:0000542C
.text$mn:0000542C ; Attributes: bp-based frame
.text$mn:0000542C
.text$mn:0000542C ; public: __thiscall std::_Iterator012<struct std::random_access_iterator_tag, wchar_t, int, wchar_t const *, wchar_t const &, struct std::_Iterator_base12>::_Iterator012<struct std::random_access_iterator_tag, wchar_t, int, wchar_t const *, wchar_t const &, struct std::_Iterator_base12>(void)
.text$mn:0000542C                 public ??0?$_Iterator012@Urandom_access_iterator_tag@std@@_WHPB_WAB_WU_Iterator_base12@2@@std@@QAE@XZ
.text$mn:0000542C ??0?$_Iterator012@Urandom_access_iterator_tag@std@@_WHPB_WAB_WU_Iterator_base12@2@@std@@QAE@XZ proc near
.text$mn:0000542C                                         ; CODE XREF: std::_String_const_iterator<std::_String_val<std::_Simple_types<wchar_t>>>::_String_const_iterator<std::_String_val<std::_Simple_types<wchar_t>>>(wchar_t const *,std::_Container_base12 const *)+29p
.text$mn:0000542C                                         ; std::_Vector_const_iterator<std::_Vector_val<std::_Simple_types<wchar_t>>>::_Vector_const_iterator<std::_Vector_val<std::_Simple_types<wchar_t>>>(wchar_t *,std::_Container_base12 const *)+29p
.text$mn:0000542C
.text$mn:0000542C var_10          = dword ptr -10h
.text$mn:0000542C var_C           = dword ptr -0Ch
.text$mn:0000542C var_4           = dword ptr -4
.text$mn:0000542C
.text$mn:0000542C                 push    ebp
.text$mn:0000542D                 mov     ebp, esp
.text$mn:0000542F                 push    0FFFFFFFFh
.text$mn:00005431                 push    offset __ehhandler$??0?$_Iterator012@Urandom_access_iterator_tag@std@@_WHPB_WAB_WU_Iterator_base12@2@@std@@QAE@XZ
.text$mn:00005436                 mov     eax, large fs:0
.text$mn:0000543C                 push    eax
.text$mn:0000543D                 push    ecx
.text$mn:0000543E                 mov     eax, dword ptr ds:___security_cookie
.text$mn:00005443                 xor     eax, ebp
.text$mn:00005445                 push    eax
.text$mn:00005446                 lea     eax, [ebp+var_C]
.text$mn:00005449                 mov     large fs:0, eax
.text$mn:0000544F                 mov     [ebp+var_10], ecx
.text$mn:00005452                 mov     ecx, [ebp+var_10] ; this
.text$mn:00005455                 call    ??0_Iterator_base12@std@@QAE@XZ ; std::_Iterator_base12::_Iterator_base12(void)
.text$mn:0000545A                 mov     [ebp+var_4], 0
.text$mn:00005461                 mov     [ebp+var_4], 0FFFFFFFFh
.text$mn:00005468                 mov     eax, [ebp+var_10]
.text$mn:0000546B                 mov     ecx, [ebp+var_C]
.text$mn:0000546E                 mov     large fs:0, ecx
.text$mn:00005475                 pop     ecx
.text$mn:00005476                 mov     esp, ebp
.text$mn:00005478                 pop     ebp
.text$mn:00005479                 retn
.text$mn:00005479 ??0?$_Iterator012@Urandom_access_iterator_tag@std@@_WHPB_WAB_WU_Iterator_base12@2@@std@@QAE@XZ endp
.text$mn:00005479
.text$mn:00005479 ; ---------------------------------------------------------------------------
.text$mn:0000547A                 align 4
.text$mn:0000547A _text$mn        ends
.text$mn:0000547A
.text$x:0000547C ; ===========================================================================
.text$x:0000547C
.text$x:0000547C ; Segment type: Pure code
.text$x:0000547C ; Segment permissions: Read/Execute
.text$x:0000547C _text$x         segment para public 'CODE' use32
.text$x:0000547C                 assume cs:_text$x
.text$x:0000547C                 ;org 547Ch
.text$x:0000547C ; COMDAT (pick associative to section at 542C)
.text$x:0000547C                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text$x:0000547C
.text$x:0000547C ; =============== S U B R O U T I N E =======================================
.text$x:0000547C
.text$x:0000547C
.text$x:0000547C __unwindfunclet$??0?$_Iterator012@Urandom_access_iterator_tag@std@@_WHPB_WAB_WU_Iterator_base12@2@@std@@QAE@XZ$0 proc near
.text$x:0000547C                                         ; DATA XREF: .xdata$x:0000E7B4o
.text$x:0000547C                 mov     ecx, [ebp-10h]  ; this
.text$x:0000547F                 jmp     ??1_Iterator_base12@std@@QAE@XZ ; std::_Iterator_base12::~_Iterator_base12(void)
.text$x:0000547F __unwindfunclet$??0?$_Iterator012@Urandom_access_iterator_tag@std@@_WHPB_WAB_WU_Iterator_base12@2@@std@@QAE@XZ$0 endp
.text$x:0000547F
.text$x:00005484
.text$x:00005484 ; =============== S U B R O U T I N E =======================================
.text$x:00005484
.text$x:00005484
.text$x:00005484 __ehhandler$??0?$_Iterator012@Urandom_access_iterator_tag@std@@_WHPB_WAB_WU_Iterator_base12@2@@std@@QAE@XZ proc near
.text$x:00005484                                         ; DATA XREF: std::_Iterator012<std::random_access_iterator_tag,wchar_t,int,wchar_t const *,wchar_t const &,std::_Iterator_base12>::_Iterator012<std::random_access_iterator_tag,wchar_t,int,wchar_t const *,wchar_t const &,std::_Iterator_base12>(void)+5o
.text$x:00005484
.text$x:00005484 arg_4           = dword ptr  8
.text$x:00005484
.text$x:00005484                 mov     edx, [esp+arg_4]
.text$x:00005488                 lea     eax, [edx+0Ch]
.text$x:0000548B                 mov     ecx, [edx-8]
.text$x:0000548E                 xor     ecx, eax
.text$x:00005490                 call    @__security_check_cookie@4 ; __security_check_cookie(x)
.text$x:00005495                 mov     eax, offset __ehfuncinfo$??0?$_Iterator012@Urandom_access_iterator_tag@std@@_WHPB_WAB_WU_Iterator_base12@2@@std@@QAE@XZ
.text$x:0000549A                 jmp     ___CxxFrameHandler3
.text$x:0000549A __ehhandler$??0?$_Iterator012@Urandom_access_iterator_tag@std@@_WHPB_WAB_WU_Iterator_base12@2@@std@@QAE@XZ endp
.text$x:0000549A
.text$x:0000549A ; ---------------------------------------------------------------------------
.text$x:0000549F                 align 10h
.text$x:0000549F _text$x         ends
.text$x:0000549F
.text$mn:000054A0 ; ===========================================================================
.text$mn:000054A0
.text$mn:000054A0 ; Segment type: Pure code
.text$mn:000054A0 ; Segment permissions: Read/Execute
.text$mn:000054A0 _text$mn        segment para public 'CODE' use32
.text$mn:000054A0                 assume cs:_text$mn
.text$mn:000054A0                 ;org 54A0h
.text$mn:000054A0 ; COMDAT (pick any)
.text$mn:000054A0                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text$mn:000054A0
.text$mn:000054A0 ; =============== S U B R O U T I N E =======================================
.text$mn:000054A0
.text$mn:000054A0 ; Attributes: bp-based frame
.text$mn:000054A0
.text$mn:000054A0 ; int __stdcall std::_Revranit<std::_Vector_iterator<std::_Vector_val<std::_Simple_types<wchar_t>>>,std::iterator<std::random_access_iterator_tag,wchar_t,int,wchar_t *,wchar_t &>>::_Revranit<std::_Vector_iterator<std::_Vector_val<std::_Simple_types<wchar_t>>>,std::iterator<std::random_access_iterator_tag,wchar_t,int,wchar_t *,wchar_t &>>(struct std::_Iterator_base12 *)
.text$mn:000054A0                 public ??0?$_Revranit@V?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@_W@std@@@std@@@std@@U?$iterator@Urandom_access_iterator_tag@std@@_WHPA_WAA_W@2@@std@@QAE@ABV01@@Z
.text$mn:000054A0 ??0?$_Revranit@V?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@_W@std@@@std@@@std@@U?$iterator@Urandom_access_iterator_tag@std@@_WHPA_WAA_W@2@@std@@QAE@ABV01@@Z proc near
.text$mn:000054A0                                         ; CODE XREF: std::reverse_iterator<std::_Vector_iterator<std::_Vector_val<std::_Simple_types<wchar_t>>>>::reverse_iterator<std::_Vector_iterator<std::_Vector_val<std::_Simple_types<wchar_t>>>>(std::reverse_iterator<std::_Vector_iterator<std::_Vector_val<std::_Simple_types<wchar_t>>>> const &)+2Dp
.text$mn:000054A0
.text$mn:000054A0 var_10          = dword ptr -10h
.text$mn:000054A0 var_C           = dword ptr -0Ch
.text$mn:000054A0 var_4           = dword ptr -4
.text$mn:000054A0 arg_0           = dword ptr  8
.text$mn:000054A0
.text$mn:000054A0                 push    ebp
.text$mn:000054A1                 mov     ebp, esp
.text$mn:000054A3                 push    0FFFFFFFFh
.text$mn:000054A5                 push    offset __ehhandler$??0?$_Revranit@V?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@_W@std@@@std@@@std@@U?$iterator@Urandom_access_iterator_tag@std@@_WHPA_WAA_W@2@@std@@QAE@ABV01@@Z
.text$mn:000054AA                 mov     eax, large fs:0
.text$mn:000054B0                 push    eax
.text$mn:000054B1                 push    ecx
.text$mn:000054B2                 mov     eax, dword ptr ds:___security_cookie
.text$mn:000054B7                 xor     eax, ebp
.text$mn:000054B9                 push    eax
.text$mn:000054BA                 lea     eax, [ebp+var_C]
.text$mn:000054BD                 mov     large fs:0, eax
.text$mn:000054C3                 mov     [ebp+var_10], ecx
.text$mn:000054C6                 mov     eax, [ebp+arg_0]
.text$mn:000054C9                 push    eax             ; struct std::_Iterator_base12 *
.text$mn:000054CA                 mov     ecx, [ebp+var_10]
.text$mn:000054CD                 call    ??0?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@_W@std@@@std@@@std@@QAE@ABV01@@Z ; std::_Vector_iterator<std::_Vector_val<std::_Simple_types<wchar_t>>>::_Vector_iterator<std::_Vector_val<std::_Simple_types<wchar_t>>>(std::_Vector_iterator<std::_Vector_val<std::_Simple_types<wchar_t>>> const &)
.text$mn:000054D2                 mov     [ebp+var_4], 0
.text$mn:000054D9                 mov     [ebp+var_4], 0FFFFFFFFh
.text$mn:000054E0                 mov     eax, [ebp+var_10]
.text$mn:000054E3                 mov     ecx, [ebp+var_C]
.text$mn:000054E6                 mov     large fs:0, ecx
.text$mn:000054ED                 pop     ecx
.text$mn:000054EE                 mov     esp, ebp
.text$mn:000054F0                 pop     ebp
.text$mn:000054F1                 retn    4
.text$mn:000054F1 ??0?$_Revranit@V?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@_W@std@@@std@@@std@@U?$iterator@Urandom_access_iterator_tag@std@@_WHPA_WAA_W@2@@std@@QAE@ABV01@@Z endp
.text$mn:000054F1
.text$mn:000054F1 _text$mn        ends
.text$mn:000054F1
.text$x:000054F4 ; ===========================================================================
.text$x:000054F4
.text$x:000054F4 ; Segment type: Pure code
.text$x:000054F4 ; Segment permissions: Read/Execute
.text$x:000054F4 _text$x         segment para public 'CODE' use32
.text$x:000054F4                 assume cs:_text$x
.text$x:000054F4                 ;org 54F4h
.text$x:000054F4 ; COMDAT (pick associative to section at 54A0)
.text$x:000054F4                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text$x:000054F4
.text$x:000054F4 ; =============== S U B R O U T I N E =======================================
.text$x:000054F4
.text$x:000054F4
.text$x:000054F4 __unwindfunclet$??0?$_Revranit@V?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@_W@std@@@std@@@std@@U?$iterator@Urandom_access_iterator_tag@std@@_WHPA_WAA_W@2@@std@@QAE@ABV01@@Z$0 proc near
.text$x:000054F4                                         ; DATA XREF: .xdata$x:0000EA2Co
.text$x:000054F4                 mov     ecx, [ebp-10h]
.text$x:000054F7                 jmp     ??1?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@_W@std@@@std@@@std@@QAE@XZ ; std::_Vector_iterator<std::_Vector_val<std::_Simple_types<wchar_t>>>::~_Vector_iterator<std::_Vector_val<std::_Simple_types<wchar_t>>>(void)
.text$x:000054F7 __unwindfunclet$??0?$_Revranit@V?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@_W@std@@@std@@@std@@U?$iterator@Urandom_access_iterator_tag@std@@_WHPA_WAA_W@2@@std@@QAE@ABV01@@Z$0 endp
.text$x:000054F7
.text$x:000054FC
.text$x:000054FC ; =============== S U B R O U T I N E =======================================
.text$x:000054FC
.text$x:000054FC
.text$x:000054FC __ehhandler$??0?$_Revranit@V?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@_W@std@@@std@@@std@@U?$iterator@Urandom_access_iterator_tag@std@@_WHPA_WAA_W@2@@std@@QAE@ABV01@@Z proc near
.text$x:000054FC                                         ; DATA XREF: std::_Revranit<std::_Vector_iterator<std::_Vector_val<std::_Simple_types<wchar_t>>>,std::iterator<std::random_access_iterator_tag,wchar_t,int,wchar_t *,wchar_t &>>::_Revranit<std::_Vector_iterator<std::_Vector_val<std::_Simple_types<wchar_t>>>,std::iterator<std::random_access_iterator_tag,wchar_t,int,wchar_t *,wchar_t &>>(std::_Revranit<std::_Vector_iterator<std::_Vector_val<std::_Simple_types<wchar_t>>>,std::iterator<std::random_access_iterator_tag,wchar_t,int,wchar_t *,wchar_t &>> const &)+5o
.text$x:000054FC
.text$x:000054FC arg_4           = dword ptr  8
.text$x:000054FC
.text$x:000054FC                 mov     edx, [esp+arg_4]
.text$x:00005500                 lea     eax, [edx+0Ch]
.text$x:00005503                 mov     ecx, [edx-8]
.text$x:00005506                 xor     ecx, eax
.text$x:00005508                 call    @__security_check_cookie@4 ; __security_check_cookie(x)
.text$x:0000550D                 mov     eax, offset __ehfuncinfo$??0?$_Revranit@V?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@_W@std@@@std@@@std@@U?$iterator@Urandom_access_iterator_tag@std@@_WHPA_WAA_W@2@@std@@QAE@ABV01@@Z
.text$x:00005512                 jmp     ___CxxFrameHandler3
.text$x:00005512 __ehhandler$??0?$_Revranit@V?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@_W@std@@@std@@@std@@U?$iterator@Urandom_access_iterator_tag@std@@_WHPA_WAA_W@2@@std@@QAE@ABV01@@Z endp
.text$x:00005512
.text$x:00005512 ; ---------------------------------------------------------------------------
.text$x:00005517                 align 4
.text$x:00005517 _text$x         ends
.text$x:00005517
.text$mn:00005518 ; ===========================================================================
.text$mn:00005518
.text$mn:00005518 ; Segment type: Pure code
.text$mn:00005518 ; Segment permissions: Read/Execute
.text$mn:00005518 _text$mn        segment para public 'CODE' use32
.text$mn:00005518                 assume cs:_text$mn
.text$mn:00005518                 ;org 5518h
.text$mn:00005518 ; COMDAT (pick any)
.text$mn:00005518                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text$mn:00005518
.text$mn:00005518 ; =============== S U B R O U T I N E =======================================
.text$mn:00005518
.text$mn:00005518 ; Attributes: bp-based frame
.text$mn:00005518
.text$mn:00005518 ; public: __thiscall std::_Revranit<class std::_Vector_iterator<class std::_Vector_val<struct std::_Simple_types<wchar_t>>>, struct std::iterator<struct std::random_access_iterator_tag, wchar_t, int, wchar_t *, wchar_t &>>::_Revranit<class std::_Vector_iterator<class std::_Vector_val<struct std::_Simple_types<wchar_t>>>, struct std::iterator<struct std::random_access_iterator_tag, wchar_t, int, wchar_t *, wchar_t &>>(class std::_Vector_iterator<class std::_Vector_val<struct std::_Simple_types<wchar_t>>>)
.text$mn:00005518                 public ??0?$_Revranit@V?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@_W@std@@@std@@@std@@U?$iterator@Urandom_access_iterator_tag@std@@_WHPA_WAA_W@2@@std@@QAE@V?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@_W@std@@@std@@@1@@Z
.text$mn:00005518 ??0?$_Revranit@V?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@_W@std@@@std@@@std@@U?$iterator@Urandom_access_iterator_tag@std@@_WHPA_WAA_W@2@@std@@QAE@V?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@_W@std@@@std@@@1@@Z proc near
.text$mn:00005518                                         ; CODE XREF: std::reverse_iterator<std::_Vector_iterator<std::_Vector_val<std::_Simple_types<wchar_t>>>>::reverse_iterator<std::_Vector_iterator<std::_Vector_val<std::_Simple_types<wchar_t>>>>(std::_Vector_iterator<std::_Vector_val<std::_Simple_types<wchar_t>>>)+54p
.text$mn:00005518
.text$mn:00005518 var_10          = dword ptr -10h
.text$mn:00005518 var_C           = dword ptr -0Ch
.text$mn:00005518 var_4           = dword ptr -4
.text$mn:00005518 arg_0           = byte ptr  8
.text$mn:00005518
.text$mn:00005518                 push    ebp
.text$mn:00005519                 mov     ebp, esp
.text$mn:0000551B                 push    0FFFFFFFFh
.text$mn:0000551D                 push    offset __ehhandler$??0?$_Revranit@V?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@_W@std@@@std@@@std@@U?$iterator@Urandom_access_iterator_tag@std@@_WHPA_WAA_W@2@@std@@QAE@V?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@_W@std@@@std@@@1@@Z
.text$mn:00005522                 mov     eax, large fs:0
.text$mn:00005528                 push    eax
.text$mn:00005529                 push    ecx
.text$mn:0000552A                 mov     eax, dword ptr ds:___security_cookie
.text$mn:0000552F                 xor     eax, ebp
.text$mn:00005531                 push    eax
.text$mn:00005532                 lea     eax, [ebp+var_C]
.text$mn:00005535                 mov     large fs:0, eax
.text$mn:0000553B                 mov     [ebp+var_10], ecx
.text$mn:0000553E                 mov     [ebp+var_4], 0
.text$mn:00005545                 lea     eax, [ebp+arg_0]
.text$mn:00005548                 push    eax             ; struct std::_Iterator_base12 *
.text$mn:00005549                 mov     ecx, [ebp+var_10]
.text$mn:0000554C                 call    ??0?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@_W@std@@@std@@@std@@QAE@ABV01@@Z ; std::_Vector_iterator<std::_Vector_val<std::_Simple_types<wchar_t>>>::_Vector_iterator<std::_Vector_val<std::_Simple_types<wchar_t>>>(std::_Vector_iterator<std::_Vector_val<std::_Simple_types<wchar_t>>> const &)
.text$mn:00005551                 mov     byte ptr [ebp+var_4], 1
.text$mn:00005555                 mov     [ebp+var_4], 0FFFFFFFFh
.text$mn:0000555C                 lea     ecx, [ebp+arg_0]
.text$mn:0000555F                 call    ??1?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@_W@std@@@std@@@std@@QAE@XZ ; std::_Vector_iterator<std::_Vector_val<std::_Simple_types<wchar_t>>>::~_Vector_iterator<std::_Vector_val<std::_Simple_types<wchar_t>>>(void)
.text$mn:00005564                 mov     eax, [ebp+var_10]
.text$mn:00005567                 mov     ecx, [ebp+var_C]
.text$mn:0000556A                 mov     large fs:0, ecx
.text$mn:00005571                 pop     ecx
.text$mn:00005572                 mov     esp, ebp
.text$mn:00005574                 pop     ebp
.text$mn:00005575                 retn    0Ch
.text$mn:00005575 ??0?$_Revranit@V?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@_W@std@@@std@@@std@@U?$iterator@Urandom_access_iterator_tag@std@@_WHPA_WAA_W@2@@std@@QAE@V?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@_W@std@@@std@@@1@@Z endp
.text$mn:00005575
.text$mn:00005575 _text$mn        ends
.text$mn:00005575
.text$x:00005578 ; ===========================================================================
.text$x:00005578
.text$x:00005578 ; Segment type: Pure code
.text$x:00005578 ; Segment permissions: Read/Execute
.text$x:00005578 _text$x         segment para public 'CODE' use32
.text$x:00005578                 assume cs:_text$x
.text$x:00005578                 ;org 5578h
.text$x:00005578 ; COMDAT (pick associative to section at 5518)
.text$x:00005578                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text$x:00005578
.text$x:00005578 ; =============== S U B R O U T I N E =======================================
.text$x:00005578
.text$x:00005578
.text$x:00005578 __unwindfunclet$??0?$_Revranit@V?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@_W@std@@@std@@@std@@U?$iterator@Urandom_access_iterator_tag@std@@_WHPA_WAA_W@2@@std@@QAE@V?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@_W@std@@@std@@@1@@Z$0 proc near
.text$x:00005578                                         ; DATA XREF: .xdata$x:0000E974o
.text$x:00005578                 lea     ecx, [ebp+8]
.text$x:0000557B                 jmp     ??1?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@_W@std@@@std@@@std@@QAE@XZ ; std::_Vector_iterator<std::_Vector_val<std::_Simple_types<wchar_t>>>::~_Vector_iterator<std::_Vector_val<std::_Simple_types<wchar_t>>>(void)
.text$x:0000557B __unwindfunclet$??0?$_Revranit@V?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@_W@std@@@std@@@std@@U?$iterator@Urandom_access_iterator_tag@std@@_WHPA_WAA_W@2@@std@@QAE@V?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@_W@std@@@std@@@1@@Z$0 endp
.text$x:0000557B
.text$x:00005580
.text$x:00005580 ; =============== S U B R O U T I N E =======================================
.text$x:00005580
.text$x:00005580
.text$x:00005580 __unwindfunclet$??0?$_Revranit@V?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@_W@std@@@std@@@std@@U?$iterator@Urandom_access_iterator_tag@std@@_WHPA_WAA_W@2@@std@@QAE@V?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@_W@std@@@std@@@1@@Z$1 proc near
.text$x:00005580                                         ; DATA XREF: .xdata$x:0000E97Co
.text$x:00005580                 mov     ecx, [ebp-10h]
.text$x:00005583                 jmp     ??1?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@_W@std@@@std@@@std@@QAE@XZ ; std::_Vector_iterator<std::_Vector_val<std::_Simple_types<wchar_t>>>::~_Vector_iterator<std::_Vector_val<std::_Simple_types<wchar_t>>>(void)
.text$x:00005583 __unwindfunclet$??0?$_Revranit@V?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@_W@std@@@std@@@std@@U?$iterator@Urandom_access_iterator_tag@std@@_WHPA_WAA_W@2@@std@@QAE@V?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@_W@std@@@std@@@1@@Z$1 endp
.text$x:00005583
.text$x:00005588
.text$x:00005588 ; =============== S U B R O U T I N E =======================================
.text$x:00005588
.text$x:00005588
.text$x:00005588 __ehhandler$??0?$_Revranit@V?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@_W@std@@@std@@@std@@U?$iterator@Urandom_access_iterator_tag@std@@_WHPA_WAA_W@2@@std@@QAE@V?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@_W@std@@@std@@@1@@Z proc near
.text$x:00005588                                         ; DATA XREF: std::_Revranit<std::_Vector_iterator<std::_Vector_val<std::_Simple_types<wchar_t>>>,std::iterator<std::random_access_iterator_tag,wchar_t,int,wchar_t *,wchar_t &>>::_Revranit<std::_Vector_iterator<std::_Vector_val<std::_Simple_types<wchar_t>>>,std::iterator<std::random_access_iterator_tag,wchar_t,int,wchar_t *,wchar_t &>>(std::_Vector_iterator<std::_Vector_val<std::_Simple_types<wchar_t>>>)+5o
.text$x:00005588
.text$x:00005588 arg_4           = dword ptr  8
.text$x:00005588
.text$x:00005588                 mov     edx, [esp+arg_4]
.text$x:0000558C                 lea     eax, [edx+0Ch]
.text$x:0000558F                 mov     ecx, [edx-8]
.text$x:00005592                 xor     ecx, eax
.text$x:00005594                 call    @__security_check_cookie@4 ; __security_check_cookie(x)
.text$x:00005599                 mov     eax, offset __ehfuncinfo$??0?$_Revranit@V?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@_W@std@@@std@@@std@@U?$iterator@Urandom_access_iterator_tag@std@@_WHPA_WAA_W@2@@std@@QAE@V?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@_W@std@@@std@@@1@@Z
.text$x:0000559E                 jmp     ___CxxFrameHandler3
.text$x:0000559E __ehhandler$??0?$_Revranit@V?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@_W@std@@@std@@@std@@U?$iterator@Urandom_access_iterator_tag@std@@_WHPA_WAA_W@2@@std@@QAE@V?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@_W@std@@@std@@@1@@Z endp
.text$x:0000559E
.text$x:0000559E ; ---------------------------------------------------------------------------
.text$x:000055A3                 align 4
.text$x:000055A3 _text$x         ends
.text$x:000055A3
.text$mn:000055A4 ; ===========================================================================
.text$mn:000055A4
.text$mn:000055A4 ; Segment type: Pure code
.text$mn:000055A4 ; Segment permissions: Read/Execute
.text$mn:000055A4 _text$mn        segment para public 'CODE' use32
.text$mn:000055A4                 assume cs:_text$mn
.text$mn:000055A4                 ;org 55A4h
.text$mn:000055A4 ; COMDAT (pick any)
.text$mn:000055A4                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text$mn:000055A4
.text$mn:000055A4 ; =============== S U B R O U T I N E =======================================
.text$mn:000055A4
.text$mn:000055A4 ; Attributes: bp-based frame
.text$mn:000055A4
.text$mn:000055A4 ; public: __thiscall std::_String_alloc<0, struct std::_String_base_types<char, class std::allocator<char>>>::_String_alloc<0, struct std::_String_base_types<char, class std::allocator<char>>>(class std::allocator<char> const &)
.text$mn:000055A4                 public ??0?$_String_alloc@$0A@U?$_String_base_types@DV?$allocator@D@std@@@std@@@std@@QAE@ABV?$allocator@D@1@@Z
.text$mn:000055A4 ??0?$_String_alloc@$0A@U?$_String_base_types@DV?$allocator@D@std@@@std@@@std@@QAE@ABV?$allocator@D@1@@Z proc near
.text$mn:000055A4                                         ; CODE XREF: std::basic_string<char,std::char_traits<char>,std::allocator<char>>::basic_string<char,std::char_traits<char>,std::allocator<char>>(std::basic_string<char,std::char_traits<char>,std::allocator<char>> &&)+38p
.text$mn:000055A4                                         ; std::basic_string<char,std::char_traits<char>,std::allocator<char>>::basic_string<char,std::char_traits<char>,std::allocator<char>>(char const *)+34p
.text$mn:000055A4
.text$mn:000055A4 var_10          = dword ptr -10h
.text$mn:000055A4 var_C           = dword ptr -0Ch
.text$mn:000055A4 var_4           = dword ptr -4
.text$mn:000055A4
.text$mn:000055A4                 push    ebp
.text$mn:000055A5                 mov     ebp, esp
.text$mn:000055A7                 push    0FFFFFFFFh
.text$mn:000055A9                 push    offset __ehhandler$??0?$_String_alloc@$0A@U?$_String_base_types@DV?$allocator@D@std@@@std@@@std@@QAE@ABV?$allocator@D@1@@Z
.text$mn:000055AE                 mov     eax, large fs:0
.text$mn:000055B4                 push    eax
.text$mn:000055B5                 push    ecx
.text$mn:000055B6                 mov     eax, dword ptr ds:___security_cookie
.text$mn:000055BB                 xor     eax, ebp
.text$mn:000055BD                 push    eax
.text$mn:000055BE                 lea     eax, [ebp+var_C]
.text$mn:000055C1                 mov     large fs:0, eax
.text$mn:000055C7                 mov     [ebp+var_10], ecx
.text$mn:000055CA                 mov     ecx, [ebp+var_10]
.text$mn:000055CD                 call    ??0?$_String_val@U?$_Simple_types@D@std@@@std@@QAE@XZ ; std::_String_val<std::_Simple_types<char>>::_String_val<std::_Simple_types<char>>(void)
.text$mn:000055D2                 mov     [ebp+var_4], 0
.text$mn:000055D9                 mov     ecx, [ebp+var_10]
.text$mn:000055DC                 call    ?_Alloc_proxy@?$_String_alloc@$0A@U?$_String_base_types@DV?$allocator@D@std@@@std@@@std@@QAEXXZ ; std::_String_alloc<0,std::_String_base_types<char,std::allocator<char>>>::_Alloc_proxy(void)
.text$mn:000055E1                 mov     [ebp+var_4], 0FFFFFFFFh
.text$mn:000055E8                 mov     eax, [ebp+var_10]
.text$mn:000055EB                 mov     ecx, [ebp+var_C]
.text$mn:000055EE                 mov     large fs:0, ecx
.text$mn:000055F5                 pop     ecx
.text$mn:000055F6                 mov     esp, ebp
.text$mn:000055F8                 pop     ebp
.text$mn:000055F9                 retn    4
.text$mn:000055F9 ??0?$_String_alloc@$0A@U?$_String_base_types@DV?$allocator@D@std@@@std@@@std@@QAE@ABV?$allocator@D@1@@Z endp
.text$mn:000055F9
.text$mn:000055F9 _text$mn        ends
.text$mn:000055F9
.text$x:000055FC ; ===========================================================================
.text$x:000055FC
.text$x:000055FC ; Segment type: Pure code
.text$x:000055FC ; Segment permissions: Read/Execute
.text$x:000055FC _text$x         segment para public 'CODE' use32
.text$x:000055FC                 assume cs:_text$x
.text$x:000055FC                 ;org 55FCh
.text$x:000055FC ; COMDAT (pick associative to section at 55A4)
.text$x:000055FC                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text$x:000055FC
.text$x:000055FC ; =============== S U B R O U T I N E =======================================
.text$x:000055FC
.text$x:000055FC
.text$x:000055FC __unwindfunclet$??0?$_String_alloc@$0A@U?$_String_base_types@DV?$allocator@D@std@@@std@@@std@@QAE@ABV?$allocator@D@1@@Z$0 proc near
.text$x:000055FC                                         ; DATA XREF: .xdata$x:0000D59Co
.text$x:000055FC                 mov     ecx, [ebp-10h]
.text$x:000055FF                 jmp     ??1?$_String_val@U?$_Simple_types@D@std@@@std@@QAE@XZ ; std::_String_val<std::_Simple_types<char>>::~_String_val<std::_Simple_types<char>>(void)
.text$x:000055FF __unwindfunclet$??0?$_String_alloc@$0A@U?$_String_base_types@DV?$allocator@D@std@@@std@@@std@@QAE@ABV?$allocator@D@1@@Z$0 endp
.text$x:000055FF
.text$x:00005604
.text$x:00005604 ; =============== S U B R O U T I N E =======================================
.text$x:00005604
.text$x:00005604
.text$x:00005604 __ehhandler$??0?$_String_alloc@$0A@U?$_String_base_types@DV?$allocator@D@std@@@std@@@std@@QAE@ABV?$allocator@D@1@@Z proc near
.text$x:00005604                                         ; DATA XREF: std::_String_alloc<0,std::_String_base_types<char,std::allocator<char>>>::_String_alloc<0,std::_String_base_types<char,std::allocator<char>>>(std::allocator<char> const &)+5o
.text$x:00005604
.text$x:00005604 arg_4           = dword ptr  8
.text$x:00005604
.text$x:00005604                 mov     edx, [esp+arg_4]
.text$x:00005608                 lea     eax, [edx+0Ch]
.text$x:0000560B                 mov     ecx, [edx-8]
.text$x:0000560E                 xor     ecx, eax
.text$x:00005610                 call    @__security_check_cookie@4 ; __security_check_cookie(x)
.text$x:00005615                 mov     eax, offset __ehfuncinfo$??0?$_String_alloc@$0A@U?$_String_base_types@DV?$allocator@D@std@@@std@@@std@@QAE@ABV?$allocator@D@1@@Z
.text$x:0000561A                 jmp     ___CxxFrameHandler3
.text$x:0000561A __ehhandler$??0?$_String_alloc@$0A@U?$_String_base_types@DV?$allocator@D@std@@@std@@@std@@QAE@ABV?$allocator@D@1@@Z endp
.text$x:0000561A
.text$x:0000561A ; ---------------------------------------------------------------------------
.text$x:0000561F                 align 10h
.text$x:0000561F _text$x         ends
.text$x:0000561F
.text$mn:00005620 ; ===========================================================================
.text$mn:00005620
.text$mn:00005620 ; Segment type: Pure code
.text$mn:00005620 ; Segment permissions: Read/Execute
.text$mn:00005620 _text$mn        segment para public 'CODE' use32
.text$mn:00005620                 assume cs:_text$mn
.text$mn:00005620                 ;org 5620h
.text$mn:00005620 ; COMDAT (pick any)
.text$mn:00005620                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text$mn:00005620
.text$mn:00005620 ; =============== S U B R O U T I N E =======================================
.text$mn:00005620
.text$mn:00005620 ; Attributes: bp-based frame
.text$mn:00005620
.text$mn:00005620 ; public: __thiscall std::_String_alloc<0, struct std::_String_base_types<wchar_t, class std::allocator<wchar_t>>>::_String_alloc<0, struct std::_String_base_types<wchar_t, class std::allocator<wchar_t>>>(class std::allocator<wchar_t> const &)
.text$mn:00005620                 public ??0?$_String_alloc@$0A@U?$_String_base_types@_WV?$allocator@_W@std@@@std@@@std@@QAE@ABV?$allocator@_W@1@@Z
.text$mn:00005620 ??0?$_String_alloc@$0A@U?$_String_base_types@_WV?$allocator@_W@std@@@std@@@std@@QAE@ABV?$allocator@_W@1@@Z proc near
.text$mn:00005620                                         ; CODE XREF: std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>>::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>>(std::reverse_iterator<std::_Vector_iterator<std::_Vector_val<std::_Simple_types<wchar_t>>>>,std::reverse_iterator<std::_Vector_iterator<std::_Vector_val<std::_Simple_types<wchar_t>>>>)+3Bp
.text$mn:00005620                                         ; std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>>::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>>(std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>> &&)+38p ...
.text$mn:00005620
.text$mn:00005620 var_10          = dword ptr -10h
.text$mn:00005620 var_C           = dword ptr -0Ch
.text$mn:00005620 var_4           = dword ptr -4
.text$mn:00005620
.text$mn:00005620                 push    ebp
.text$mn:00005621                 mov     ebp, esp
.text$mn:00005623                 push    0FFFFFFFFh
.text$mn:00005625                 push    offset __ehhandler$??0?$_String_alloc@$0A@U?$_String_base_types@_WV?$allocator@_W@std@@@std@@@std@@QAE@ABV?$allocator@_W@1@@Z
.text$mn:0000562A                 mov     eax, large fs:0
.text$mn:00005630                 push    eax
.text$mn:00005631                 push    ecx
.text$mn:00005632                 mov     eax, dword ptr ds:___security_cookie
.text$mn:00005637                 xor     eax, ebp
.text$mn:00005639                 push    eax
.text$mn:0000563A                 lea     eax, [ebp+var_C]
.text$mn:0000563D                 mov     large fs:0, eax
.text$mn:00005643                 mov     [ebp+var_10], ecx
.text$mn:00005646                 mov     ecx, [ebp+var_10]
.text$mn:00005649                 call    ??0?$_String_val@U?$_Simple_types@_W@std@@@std@@QAE@XZ ; std::_String_val<std::_Simple_types<wchar_t>>::_String_val<std::_Simple_types<wchar_t>>(void)
.text$mn:0000564E                 mov     [ebp+var_4], 0
.text$mn:00005655                 mov     ecx, [ebp+var_10]
.text$mn:00005658                 call    ?_Alloc_proxy@?$_String_alloc@$0A@U?$_String_base_types@_WV?$allocator@_W@std@@@std@@@std@@QAEXXZ ; std::_String_alloc<0,std::_String_base_types<wchar_t,std::allocator<wchar_t>>>::_Alloc_proxy(void)
.text$mn:0000565D                 mov     [ebp+var_4], 0FFFFFFFFh
.text$mn:00005664                 mov     eax, [ebp+var_10]
.text$mn:00005667                 mov     ecx, [ebp+var_C]
.text$mn:0000566A                 mov     large fs:0, ecx
.text$mn:00005671                 pop     ecx
.text$mn:00005672                 mov     esp, ebp
.text$mn:00005674                 pop     ebp
.text$mn:00005675                 retn    4
.text$mn:00005675 ??0?$_String_alloc@$0A@U?$_String_base_types@_WV?$allocator@_W@std@@@std@@@std@@QAE@ABV?$allocator@_W@1@@Z endp
.text$mn:00005675
.text$mn:00005675 _text$mn        ends
.text$mn:00005675
.text$x:00005678 ; ===========================================================================
.text$x:00005678
.text$x:00005678 ; Segment type: Pure code
.text$x:00005678 ; Segment permissions: Read/Execute
.text$x:00005678 _text$x         segment para public 'CODE' use32
.text$x:00005678                 assume cs:_text$x
.text$x:00005678                 ;org 5678h
.text$x:00005678 ; COMDAT (pick associative to section at 5620)
.text$x:00005678                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text$x:00005678
.text$x:00005678 ; =============== S U B R O U T I N E =======================================
.text$x:00005678
.text$x:00005678
.text$x:00005678 __unwindfunclet$??0?$_String_alloc@$0A@U?$_String_base_types@_WV?$allocator@_W@std@@@std@@@std@@QAE@ABV?$allocator@_W@1@@Z$0 proc near
.text$x:00005678                                         ; DATA XREF: .xdata$x:0000D998o
.text$x:00005678                 mov     ecx, [ebp-10h]
.text$x:0000567B                 jmp     ??1?$_String_val@U?$_Simple_types@_W@std@@@std@@QAE@XZ ; std::_String_val<std::_Simple_types<wchar_t>>::~_String_val<std::_Simple_types<wchar_t>>(void)
.text$x:0000567B __unwindfunclet$??0?$_String_alloc@$0A@U?$_String_base_types@_WV?$allocator@_W@std@@@std@@@std@@QAE@ABV?$allocator@_W@1@@Z$0 endp
.text$x:0000567B
.text$x:00005680
.text$x:00005680 ; =============== S U B R O U T I N E =======================================
.text$x:00005680
.text$x:00005680
.text$x:00005680 __ehhandler$??0?$_String_alloc@$0A@U?$_String_base_types@_WV?$allocator@_W@std@@@std@@@std@@QAE@ABV?$allocator@_W@1@@Z proc near
.text$x:00005680                                         ; DATA XREF: std::_String_alloc<0,std::_String_base_types<wchar_t,std::allocator<wchar_t>>>::_String_alloc<0,std::_String_base_types<wchar_t,std::allocator<wchar_t>>>(std::allocator<wchar_t> const &)+5o
.text$x:00005680
.text$x:00005680 arg_4           = dword ptr  8
.text$x:00005680
.text$x:00005680                 mov     edx, [esp+arg_4]
.text$x:00005684                 lea     eax, [edx+0Ch]
.text$x:00005687                 mov     ecx, [edx-8]
.text$x:0000568A                 xor     ecx, eax
.text$x:0000568C                 call    @__security_check_cookie@4 ; __security_check_cookie(x)
.text$x:00005691                 mov     eax, offset __ehfuncinfo$??0?$_String_alloc@$0A@U?$_String_base_types@_WV?$allocator@_W@std@@@std@@@std@@QAE@ABV?$allocator@_W@1@@Z
.text$x:00005696                 jmp     ___CxxFrameHandler3
.text$x:00005696 __ehhandler$??0?$_String_alloc@$0A@U?$_String_base_types@_WV?$allocator@_W@std@@@std@@@std@@QAE@ABV?$allocator@_W@1@@Z endp
.text$x:00005696
.text$x:00005696 ; ---------------------------------------------------------------------------
.text$x:0000569B                 align 4
.text$x:0000569B _text$x         ends
.text$x:0000569B
.text$mn:0000569C ; ===========================================================================
.text$mn:0000569C
.text$mn:0000569C ; Segment type: Pure code
.text$mn:0000569C ; Segment permissions: Read/Execute
.text$mn:0000569C _text$mn        segment para public 'CODE' use32
.text$mn:0000569C                 assume cs:_text$mn
.text$mn:0000569C                 ;org 569Ch
.text$mn:0000569C ; COMDAT (pick any)
.text$mn:0000569C                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text$mn:0000569C
.text$mn:0000569C ; =============== S U B R O U T I N E =======================================
.text$mn:0000569C
.text$mn:0000569C ; Attributes: bp-based frame
.text$mn:0000569C
.text$mn:0000569C ; int __stdcall std::_String_const_iterator<std::_String_val<std::_Simple_types<wchar_t>>>::_String_const_iterator<std::_String_val<std::_Simple_types<wchar_t>>>(struct std::_Iterator_base12 *)
.text$mn:0000569C                 public ??0?$_String_const_iterator@V?$_String_val@U?$_Simple_types@_W@std@@@std@@@std@@QAE@ABV01@@Z
.text$mn:0000569C ??0?$_String_const_iterator@V?$_String_val@U?$_Simple_types@_W@std@@@std@@@std@@QAE@ABV01@@Z proc near
.text$mn:0000569C                                         ; CODE XREF: BuildMenuFileName(int,uint,std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>> const &)+316p
.text$mn:0000569C                                         ; BuildMenuFileName(int,uint,std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>> const &)+3E5p ...
.text$mn:0000569C
.text$mn:0000569C var_10          = dword ptr -10h
.text$mn:0000569C var_C           = dword ptr -0Ch
.text$mn:0000569C var_4           = dword ptr -4
.text$mn:0000569C arg_0           = dword ptr  8
.text$mn:0000569C
.text$mn:0000569C                 push    ebp
.text$mn:0000569D                 mov     ebp, esp
.text$mn:0000569F                 push    0FFFFFFFFh
.text$mn:000056A1                 push    offset __ehhandler$??0?$_String_const_iterator@V?$_String_val@U?$_Simple_types@_W@std@@@std@@@std@@QAE@ABV01@@Z
.text$mn:000056A6                 mov     eax, large fs:0
.text$mn:000056AC                 push    eax
.text$mn:000056AD                 push    ecx
.text$mn:000056AE                 mov     eax, dword ptr ds:___security_cookie
.text$mn:000056B3                 xor     eax, ebp
.text$mn:000056B5                 push    eax
.text$mn:000056B6                 lea     eax, [ebp+var_C]
.text$mn:000056B9                 mov     large fs:0, eax
.text$mn:000056BF                 mov     [ebp+var_10], ecx
.text$mn:000056C2                 mov     eax, [ebp+arg_0]
.text$mn:000056C5                 push    eax             ; struct std::_Iterator_base12 *
.text$mn:000056C6                 mov     ecx, [ebp+var_10]
.text$mn:000056C9                 call    ??0?$_Iterator012@Urandom_access_iterator_tag@std@@_WHPB_WAB_WU_Iterator_base12@2@@std@@QAE@ABU01@@Z ; std::_Iterator012<std::random_access_iterator_tag,wchar_t,int,wchar_t const *,wchar_t const &,std::_Iterator_base12>::_Iterator012<std::random_access_iterator_tag,wchar_t,int,wchar_t const *,wchar_t const &,std::_Iterator_base12>(std::_Iterator012<std::random_access_iterator_tag,wchar_t,int,wchar_t const *,wchar_t const &,std::_Iterator_base12> const &)
.text$mn:000056CE                 mov     [ebp+var_4], 0
.text$mn:000056D5                 mov     ecx, [ebp+var_10]
.text$mn:000056D8                 mov     edx, [ebp+arg_0]
.text$mn:000056DB                 mov     eax, [edx+8]
.text$mn:000056DE                 mov     [ecx+8], eax
.text$mn:000056E1                 mov     [ebp+var_4], 0FFFFFFFFh
.text$mn:000056E8                 mov     eax, [ebp+var_10]
.text$mn:000056EB                 mov     ecx, [ebp+var_C]
.text$mn:000056EE                 mov     large fs:0, ecx
.text$mn:000056F5                 pop     ecx
.text$mn:000056F6                 mov     esp, ebp
.text$mn:000056F8                 pop     ebp
.text$mn:000056F9                 retn    4
.text$mn:000056F9 ??0?$_String_const_iterator@V?$_String_val@U?$_Simple_types@_W@std@@@std@@@std@@QAE@ABV01@@Z endp
.text$mn:000056F9
.text$mn:000056F9 _text$mn        ends
.text$mn:000056F9
.text$x:000056FC ; ===========================================================================
.text$x:000056FC
.text$x:000056FC ; Segment type: Pure code
.text$x:000056FC ; Segment permissions: Read/Execute
.text$x:000056FC _text$x         segment para public 'CODE' use32
.text$x:000056FC                 assume cs:_text$x
.text$x:000056FC                 ;org 56FCh
.text$x:000056FC ; COMDAT (pick associative to section at 569C)
.text$x:000056FC                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text$x:000056FC
.text$x:000056FC ; =============== S U B R O U T I N E =======================================
.text$x:000056FC
.text$x:000056FC
.text$x:000056FC __unwindfunclet$??0?$_String_const_iterator@V?$_String_val@U?$_Simple_types@_W@std@@@std@@@std@@QAE@ABV01@@Z$0 proc near
.text$x:000056FC                                         ; DATA XREF: .xdata$x:0000EBF8o
.text$x:000056FC                 mov     ecx, [ebp-10h]
.text$x:000056FF                 jmp     ??1?$_Iterator012@Urandom_access_iterator_tag@std@@_WHPB_WAB_WU_Iterator_base12@2@@std@@QAE@XZ ; std::_Iterator012<std::random_access_iterator_tag,wchar_t,int,wchar_t const *,wchar_t const &,std::_Iterator_base12>::~_Iterator012<std::random_access_iterator_tag,wchar_t,int,wchar_t const *,wchar_t const &,std::_Iterator_base12>(void)
.text$x:000056FF __unwindfunclet$??0?$_String_const_iterator@V?$_String_val@U?$_Simple_types@_W@std@@@std@@@std@@QAE@ABV01@@Z$0 endp
.text$x:000056FF
.text$x:00005704
.text$x:00005704 ; =============== S U B R O U T I N E =======================================
.text$x:00005704
.text$x:00005704
.text$x:00005704 __ehhandler$??0?$_String_const_iterator@V?$_String_val@U?$_Simple_types@_W@std@@@std@@@std@@QAE@ABV01@@Z proc near
.text$x:00005704                                         ; DATA XREF: std::_String_const_iterator<std::_String_val<std::_Simple_types<wchar_t>>>::_String_const_iterator<std::_String_val<std::_Simple_types<wchar_t>>>(std::_String_const_iterator<std::_String_val<std::_Simple_types<wchar_t>>> const &)+5o
.text$x:00005704
.text$x:00005704 arg_4           = dword ptr  8
.text$x:00005704
.text$x:00005704                 mov     edx, [esp+arg_4]
.text$x:00005708                 lea     eax, [edx+0Ch]
.text$x:0000570B                 mov     ecx, [edx-8]
.text$x:0000570E                 xor     ecx, eax
.text$x:00005710                 call    @__security_check_cookie@4 ; __security_check_cookie(x)
.text$x:00005715                 mov     eax, offset __ehfuncinfo$??0?$_String_const_iterator@V?$_String_val@U?$_Simple_types@_W@std@@@std@@@std@@QAE@ABV01@@Z
.text$x:0000571A                 jmp     ___CxxFrameHandler3
.text$x:0000571A __ehhandler$??0?$_String_const_iterator@V?$_String_val@U?$_Simple_types@_W@std@@@std@@@std@@QAE@ABV01@@Z endp
.text$x:0000571A
.text$x:0000571A ; ---------------------------------------------------------------------------
.text$x:0000571F                 align 10h
.text$x:0000571F _text$x         ends
.text$x:0000571F
.text$mn:00005720 ; ===========================================================================
.text$mn:00005720
.text$mn:00005720 ; Segment type: Pure code
.text$mn:00005720 ; Segment permissions: Read/Execute
.text$mn:00005720 _text$mn        segment para public 'CODE' use32
.text$mn:00005720                 assume cs:_text$mn
.text$mn:00005720                 ;org 5720h
.text$mn:00005720 ; COMDAT (pick any)
.text$mn:00005720                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text$mn:00005720
.text$mn:00005720 ; =============== S U B R O U T I N E =======================================
.text$mn:00005720
.text$mn:00005720 ; Attributes: bp-based frame
.text$mn:00005720
.text$mn:00005720 ; int __stdcall std::_String_const_iterator<std::_String_val<std::_Simple_types<wchar_t>>>::_String_const_iterator<std::_String_val<std::_Simple_types<wchar_t>>>(int, struct std::_Container_base12 *)
.text$mn:00005720                 public ??0?$_String_const_iterator@V?$_String_val@U?$_Simple_types@_W@std@@@std@@@std@@QAE@PB_WPBU_Container_base12@1@@Z
.text$mn:00005720 ??0?$_String_const_iterator@V?$_String_val@U?$_Simple_types@_W@std@@@std@@@std@@QAE@PB_WPBU_Container_base12@1@@Z proc near
.text$mn:00005720                                         ; CODE XREF: std::_String_iterator<std::_String_val<std::_Simple_types<wchar_t>>>::_String_iterator<std::_String_val<std::_Simple_types<wchar_t>>>(wchar_t *,std::_Container_base12 const *)+31p
.text$mn:00005720                                         ; std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>>::begin(void)+3Fp ...
.text$mn:00005720
.text$mn:00005720 var_10          = dword ptr -10h
.text$mn:00005720 var_C           = dword ptr -0Ch
.text$mn:00005720 var_4           = dword ptr -4
.text$mn:00005720 arg_0           = dword ptr  8
.text$mn:00005720 arg_4           = dword ptr  0Ch
.text$mn:00005720
.text$mn:00005720                 push    ebp
.text$mn:00005721                 mov     ebp, esp
.text$mn:00005723                 push    0FFFFFFFFh
.text$mn:00005725                 push    offset __ehhandler$??0?$_String_const_iterator@V?$_String_val@U?$_Simple_types@_W@std@@@std@@@std@@QAE@PB_WPBU_Container_base12@1@@Z
.text$mn:0000572A                 mov     eax, large fs:0
.text$mn:00005730                 push    eax
.text$mn:00005731                 push    ecx
.text$mn:00005732                 mov     eax, dword ptr ds:___security_cookie
.text$mn:00005737                 xor     eax, ebp
.text$mn:00005739                 push    eax
.text$mn:0000573A                 lea     eax, [ebp+var_C]
.text$mn:0000573D                 mov     large fs:0, eax
.text$mn:00005743                 mov     [ebp+var_10], ecx
.text$mn:00005746                 mov     ecx, [ebp+var_10]
.text$mn:00005749                 call    ??0?$_Iterator012@Urandom_access_iterator_tag@std@@_WHPB_WAB_WU_Iterator_base12@2@@std@@QAE@XZ ; std::_Iterator012<std::random_access_iterator_tag,wchar_t,int,wchar_t const *,wchar_t const &,std::_Iterator_base12>::_Iterator012<std::random_access_iterator_tag,wchar_t,int,wchar_t const *,wchar_t const &,std::_Iterator_base12>(void)
.text$mn:0000574E                 mov     [ebp+var_4], 0
.text$mn:00005755                 mov     eax, [ebp+arg_4]
.text$mn:00005758                 push    eax             ; struct std::_Container_base12 *
.text$mn:00005759                 mov     ecx, [ebp+var_10] ; this
.text$mn:0000575C                 call    ?_Adopt@_Iterator_base12@std@@QAEXPBU_Container_base12@2@@Z ; std::_Iterator_base12::_Adopt(std::_Container_base12 const *)
.text$mn:00005761                 mov     ecx, [ebp+var_10]
.text$mn:00005764                 mov     edx, [ebp+arg_0]
.text$mn:00005767                 mov     [ecx+8], edx
.text$mn:0000576A                 mov     [ebp+var_4], 0FFFFFFFFh
.text$mn:00005771                 mov     eax, [ebp+var_10]
.text$mn:00005774                 mov     ecx, [ebp+var_C]
.text$mn:00005777                 mov     large fs:0, ecx
.text$mn:0000577E                 pop     ecx
.text$mn:0000577F                 mov     esp, ebp
.text$mn:00005781                 pop     ebp
.text$mn:00005782                 retn    8
.text$mn:00005782 ??0?$_String_const_iterator@V?$_String_val@U?$_Simple_types@_W@std@@@std@@@std@@QAE@PB_WPBU_Container_base12@1@@Z endp
.text$mn:00005782
.text$mn:00005782 ; ---------------------------------------------------------------------------
.text$mn:00005785                 align 4
.text$mn:00005785 _text$mn        ends
.text$mn:00005785
.text$x:00005788 ; ===========================================================================
.text$x:00005788
.text$x:00005788 ; Segment type: Pure code
.text$x:00005788 ; Segment permissions: Read/Execute
.text$x:00005788 _text$x         segment para public 'CODE' use32
.text$x:00005788                 assume cs:_text$x
.text$x:00005788                 ;org 5788h
.text$x:00005788 ; COMDAT (pick associative to section at 5720)
.text$x:00005788                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text$x:00005788
.text$x:00005788 ; =============== S U B R O U T I N E =======================================
.text$x:00005788
.text$x:00005788
.text$x:00005788 __unwindfunclet$??0?$_String_const_iterator@V?$_String_val@U?$_Simple_types@_W@std@@@std@@@std@@QAE@PB_WPBU_Container_base12@1@@Z$0 proc near
.text$x:00005788                                         ; DATA XREF: .xdata$x:0000EB38o
.text$x:00005788                 mov     ecx, [ebp-10h]
.text$x:0000578B                 jmp     ??1?$_Iterator012@Urandom_access_iterator_tag@std@@_WHPB_WAB_WU_Iterator_base12@2@@std@@QAE@XZ ; std::_Iterator012<std::random_access_iterator_tag,wchar_t,int,wchar_t const *,wchar_t const &,std::_Iterator_base12>::~_Iterator012<std::random_access_iterator_tag,wchar_t,int,wchar_t const *,wchar_t const &,std::_Iterator_base12>(void)
.text$x:0000578B __unwindfunclet$??0?$_String_const_iterator@V?$_String_val@U?$_Simple_types@_W@std@@@std@@@std@@QAE@PB_WPBU_Container_base12@1@@Z$0 endp
.text$x:0000578B
.text$x:00005790
.text$x:00005790 ; =============== S U B R O U T I N E =======================================
.text$x:00005790
.text$x:00005790
.text$x:00005790 __ehhandler$??0?$_String_const_iterator@V?$_String_val@U?$_Simple_types@_W@std@@@std@@@std@@QAE@PB_WPBU_Container_base12@1@@Z proc near
.text$x:00005790                                         ; DATA XREF: std::_String_const_iterator<std::_String_val<std::_Simple_types<wchar_t>>>::_String_const_iterator<std::_String_val<std::_Simple_types<wchar_t>>>(wchar_t const *,std::_Container_base12 const *)+5o
.text$x:00005790
.text$x:00005790 arg_4           = dword ptr  8
.text$x:00005790
.text$x:00005790                 mov     edx, [esp+arg_4]
.text$x:00005794                 lea     eax, [edx+0Ch]
.text$x:00005797                 mov     ecx, [edx-8]
.text$x:0000579A                 xor     ecx, eax
.text$x:0000579C                 call    @__security_check_cookie@4 ; __security_check_cookie(x)
.text$x:000057A1                 mov     eax, offset __ehfuncinfo$??0?$_String_const_iterator@V?$_String_val@U?$_Simple_types@_W@std@@@std@@@std@@QAE@PB_WPBU_Container_base12@1@@Z
.text$x:000057A6                 jmp     ___CxxFrameHandler3
.text$x:000057A6 __ehhandler$??0?$_String_const_iterator@V?$_String_val@U?$_Simple_types@_W@std@@@std@@@std@@QAE@PB_WPBU_Container_base12@1@@Z endp
.text$x:000057A6
.text$x:000057A6 ; ---------------------------------------------------------------------------
.text$x:000057AB                 align 4
.text$x:000057AB _text$x         ends
.text$x:000057AB
.text$mn:000057AC ; ===========================================================================
.text$mn:000057AC
.text$mn:000057AC ; Segment type: Pure code
.text$mn:000057AC ; Segment permissions: Read/Execute
.text$mn:000057AC _text$mn        segment para public 'CODE' use32
.text$mn:000057AC                 assume cs:_text$mn
.text$mn:000057AC                 ;org 57ACh
.text$mn:000057AC ; COMDAT (pick any)
.text$mn:000057AC                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text$mn:000057AC
.text$mn:000057AC ; =============== S U B R O U T I N E =======================================
.text$mn:000057AC
.text$mn:000057AC ; Attributes: bp-based frame
.text$mn:000057AC
.text$mn:000057AC ; int __stdcall std::_String_iterator<std::_String_val<std::_Simple_types<wchar_t>>>::_String_iterator<std::_String_val<std::_Simple_types<wchar_t>>>(struct std::_Iterator_base12 *)
.text$mn:000057AC                 public ??0?$_String_iterator@V?$_String_val@U?$_Simple_types@_W@std@@@std@@@std@@QAE@ABV01@@Z
.text$mn:000057AC ??0?$_String_iterator@V?$_String_val@U?$_Simple_types@_W@std@@@std@@@std@@QAE@ABV01@@Z proc near
.text$mn:000057AC                                         ; CODE XREF: std::_Debug_range<std::_String_iterator<std::_String_val<std::_Simple_types<wchar_t>>>>(std::_String_iterator<std::_String_val<std::_Simple_types<wchar_t>>>,std::_String_iterator<std::_String_val<std::_Simple_types<wchar_t>>>,wchar_t const *,uint)+56p
.text$mn:000057AC                                         ; std::_Debug_range<std::_String_iterator<std::_String_val<std::_Simple_types<wchar_t>>>>(std::_String_iterator<std::_String_val<std::_Simple_types<wchar_t>>>,std::_String_iterator<std::_String_val<std::_Simple_types<wchar_t>>>,wchar_t const *,uint)+74p ...
.text$mn:000057AC
.text$mn:000057AC var_10          = dword ptr -10h
.text$mn:000057AC var_C           = dword ptr -0Ch
.text$mn:000057AC var_4           = dword ptr -4
.text$mn:000057AC arg_0           = dword ptr  8
.text$mn:000057AC
.text$mn:000057AC                 push    ebp
.text$mn:000057AD                 mov     ebp, esp
.text$mn:000057AF                 push    0FFFFFFFFh
.text$mn:000057B1                 push    offset __ehhandler$??0?$_String_iterator@V?$_String_val@U?$_Simple_types@_W@std@@@std@@@std@@QAE@ABV01@@Z
.text$mn:000057B6                 mov     eax, large fs:0
.text$mn:000057BC                 push    eax
.text$mn:000057BD                 push    ecx
.text$mn:000057BE                 mov     eax, dword ptr ds:___security_cookie
.text$mn:000057C3                 xor     eax, ebp
.text$mn:000057C5                 push    eax
.text$mn:000057C6                 lea     eax, [ebp+var_C]
.text$mn:000057C9                 mov     large fs:0, eax
.text$mn:000057CF                 mov     [ebp+var_10], ecx
.text$mn:000057D2                 mov     eax, [ebp+arg_0]
.text$mn:000057D5                 push    eax             ; struct std::_Iterator_base12 *
.text$mn:000057D6                 mov     ecx, [ebp+var_10]
.text$mn:000057D9                 call    ??0?$_String_const_iterator@V?$_String_val@U?$_Simple_types@_W@std@@@std@@@std@@QAE@ABV01@@Z ; std::_String_const_iterator<std::_String_val<std::_Simple_types<wchar_t>>>::_String_const_iterator<std::_String_val<std::_Simple_types<wchar_t>>>(std::_String_const_iterator<std::_String_val<std::_Simple_types<wchar_t>>> const &)
.text$mn:000057DE                 mov     [ebp+var_4], 0
.text$mn:000057E5                 mov     [ebp+var_4], 0FFFFFFFFh
.text$mn:000057EC                 mov     eax, [ebp+var_10]
.text$mn:000057EF                 mov     ecx, [ebp+var_C]
.text$mn:000057F2                 mov     large fs:0, ecx
.text$mn:000057F9                 pop     ecx
.text$mn:000057FA                 mov     esp, ebp
.text$mn:000057FC                 pop     ebp
.text$mn:000057FD                 retn    4
.text$mn:000057FD ??0?$_String_iterator@V?$_String_val@U?$_Simple_types@_W@std@@@std@@@std@@QAE@ABV01@@Z endp
.text$mn:000057FD
.text$mn:000057FD _text$mn        ends
.text$mn:000057FD
.text$x:00005800 ; ===========================================================================
.text$x:00005800
.text$x:00005800 ; Segment type: Pure code
.text$x:00005800 ; Segment permissions: Read/Execute
.text$x:00005800 _text$x         segment para public 'CODE' use32
.text$x:00005800                 assume cs:_text$x
.text$x:00005800                 ;org 5800h
.text$x:00005800 ; COMDAT (pick associative to section at 57AC)
.text$x:00005800                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text$x:00005800
.text$x:00005800 ; =============== S U B R O U T I N E =======================================
.text$x:00005800
.text$x:00005800
.text$x:00005800 __unwindfunclet$??0?$_String_iterator@V?$_String_val@U?$_Simple_types@_W@std@@@std@@@std@@QAE@ABV01@@Z$0 proc near
.text$x:00005800                                         ; DATA XREF: .xdata$x:0000ED48o
.text$x:00005800                 mov     ecx, [ebp-10h]
.text$x:00005803                 jmp     ??1?$_String_const_iterator@V?$_String_val@U?$_Simple_types@_W@std@@@std@@@std@@QAE@XZ ; std::_String_const_iterator<std::_String_val<std::_Simple_types<wchar_t>>>::~_String_const_iterator<std::_String_val<std::_Simple_types<wchar_t>>>(void)
.text$x:00005803 __unwindfunclet$??0?$_String_iterator@V?$_String_val@U?$_Simple_types@_W@std@@@std@@@std@@QAE@ABV01@@Z$0 endp
.text$x:00005803
.text$x:00005808
.text$x:00005808 ; =============== S U B R O U T I N E =======================================
.text$x:00005808
.text$x:00005808
.text$x:00005808 __ehhandler$??0?$_String_iterator@V?$_String_val@U?$_Simple_types@_W@std@@@std@@@std@@QAE@ABV01@@Z proc near
.text$x:00005808                                         ; DATA XREF: std::_String_iterator<std::_String_val<std::_Simple_types<wchar_t>>>::_String_iterator<std::_String_val<std::_Simple_types<wchar_t>>>(std::_String_iterator<std::_String_val<std::_Simple_types<wchar_t>>> const &)+5o
.text$x:00005808
.text$x:00005808 arg_4           = dword ptr  8
.text$x:00005808
.text$x:00005808                 mov     edx, [esp+arg_4]
.text$x:0000580C                 lea     eax, [edx+0Ch]
.text$x:0000580F                 mov     ecx, [edx-8]
.text$x:00005812                 xor     ecx, eax
.text$x:00005814                 call    @__security_check_cookie@4 ; __security_check_cookie(x)
.text$x:00005819                 mov     eax, offset __ehfuncinfo$??0?$_String_iterator@V?$_String_val@U?$_Simple_types@_W@std@@@std@@@std@@QAE@ABV01@@Z
.text$x:0000581E                 jmp     ___CxxFrameHandler3
.text$x:0000581E __ehhandler$??0?$_String_iterator@V?$_String_val@U?$_Simple_types@_W@std@@@std@@@std@@QAE@ABV01@@Z endp
.text$x:0000581E
.text$x:0000581E ; ---------------------------------------------------------------------------
.text$x:00005823                 align 4
.text$x:00005823 _text$x         ends
.text$x:00005823
.text$mn:00005824 ; ===========================================================================
.text$mn:00005824
.text$mn:00005824 ; Segment type: Pure code
.text$mn:00005824 ; Segment permissions: Read/Execute
.text$mn:00005824 _text$mn        segment para public 'CODE' use32
.text$mn:00005824                 assume cs:_text$mn
.text$mn:00005824                 ;org 5824h
.text$mn:00005824 ; COMDAT (pick any)
.text$mn:00005824                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text$mn:00005824
.text$mn:00005824 ; =============== S U B R O U T I N E =======================================
.text$mn:00005824
.text$mn:00005824 ; Attributes: bp-based frame
.text$mn:00005824
.text$mn:00005824 ; int __stdcall std::_String_iterator<std::_String_val<std::_Simple_types<wchar_t>>>::_String_iterator<std::_String_val<std::_Simple_types<wchar_t>>>(int, struct std::_Container_base12 *)
.text$mn:00005824                 public ??0?$_String_iterator@V?$_String_val@U?$_Simple_types@_W@std@@@std@@@std@@QAE@PA_WPBU_Container_base12@1@@Z
.text$mn:00005824 ??0?$_String_iterator@V?$_String_val@U?$_Simple_types@_W@std@@@std@@@std@@QAE@PA_WPBU_Container_base12@1@@Z proc near
.text$mn:00005824                                         ; CODE XREF: std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>>::begin(void)+3Fp
.text$mn:00005824                                         ; std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>>::end(void)+48p
.text$mn:00005824
.text$mn:00005824 var_10          = dword ptr -10h
.text$mn:00005824 var_C           = dword ptr -0Ch
.text$mn:00005824 var_4           = dword ptr -4
.text$mn:00005824 arg_0           = dword ptr  8
.text$mn:00005824 arg_4           = dword ptr  0Ch
.text$mn:00005824
.text$mn:00005824                 push    ebp
.text$mn:00005825                 mov     ebp, esp
.text$mn:00005827                 push    0FFFFFFFFh
.text$mn:00005829                 push    offset __ehhandler$??0?$_String_iterator@V?$_String_val@U?$_Simple_types@_W@std@@@std@@@std@@QAE@PA_WPBU_Container_base12@1@@Z
.text$mn:0000582E                 mov     eax, large fs:0
.text$mn:00005834                 push    eax
.text$mn:00005835                 push    ecx
.text$mn:00005836                 mov     eax, dword ptr ds:___security_cookie
.text$mn:0000583B                 xor     eax, ebp
.text$mn:0000583D                 push    eax
.text$mn:0000583E                 lea     eax, [ebp+var_C]
.text$mn:00005841                 mov     large fs:0, eax
.text$mn:00005847                 mov     [ebp+var_10], ecx
.text$mn:0000584A                 mov     eax, [ebp+arg_4]
.text$mn:0000584D                 push    eax             ; struct std::_Container_base12 *
.text$mn:0000584E                 mov     ecx, [ebp+arg_0]
.text$mn:00005851                 push    ecx             ; int
.text$mn:00005852                 mov     ecx, [ebp+var_10]
.text$mn:00005855                 call    ??0?$_String_const_iterator@V?$_String_val@U?$_Simple_types@_W@std@@@std@@@std@@QAE@PB_WPBU_Container_base12@1@@Z ; std::_String_const_iterator<std::_String_val<std::_Simple_types<wchar_t>>>::_String_const_iterator<std::_String_val<std::_Simple_types<wchar_t>>>(wchar_t const *,std::_Container_base12 const *)
.text$mn:0000585A                 mov     [ebp+var_4], 0
.text$mn:00005861                 mov     [ebp+var_4], 0FFFFFFFFh
.text$mn:00005868                 mov     eax, [ebp+var_10]
.text$mn:0000586B                 mov     ecx, [ebp+var_C]
.text$mn:0000586E                 mov     large fs:0, ecx
.text$mn:00005875                 pop     ecx
.text$mn:00005876                 mov     esp, ebp
.text$mn:00005878                 pop     ebp
.text$mn:00005879                 retn    8
.text$mn:00005879 ??0?$_String_iterator@V?$_String_val@U?$_Simple_types@_W@std@@@std@@@std@@QAE@PA_WPBU_Container_base12@1@@Z endp
.text$mn:00005879
.text$mn:00005879 _text$mn        ends
.text$mn:00005879
.text$x:0000587C ; ===========================================================================
.text$x:0000587C
.text$x:0000587C ; Segment type: Pure code
.text$x:0000587C ; Segment permissions: Read/Execute
.text$x:0000587C _text$x         segment para public 'CODE' use32
.text$x:0000587C                 assume cs:_text$x
.text$x:0000587C                 ;org 587Ch
.text$x:0000587C ; COMDAT (pick associative to section at 5824)
.text$x:0000587C                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text$x:0000587C
.text$x:0000587C ; =============== S U B R O U T I N E =======================================
.text$x:0000587C
.text$x:0000587C
.text$x:0000587C __unwindfunclet$??0?$_String_iterator@V?$_String_val@U?$_Simple_types@_W@std@@@std@@@std@@QAE@PA_WPBU_Container_base12@1@@Z$0 proc near
.text$x:0000587C                                         ; DATA XREF: .xdata$x:0000ECBCo
.text$x:0000587C                 mov     ecx, [ebp-10h]
.text$x:0000587F                 jmp     ??1?$_String_const_iterator@V?$_String_val@U?$_Simple_types@_W@std@@@std@@@std@@QAE@XZ ; std::_String_const_iterator<std::_String_val<std::_Simple_types<wchar_t>>>::~_String_const_iterator<std::_String_val<std::_Simple_types<wchar_t>>>(void)
.text$x:0000587F __unwindfunclet$??0?$_String_iterator@V?$_String_val@U?$_Simple_types@_W@std@@@std@@@std@@QAE@PA_WPBU_Container_base12@1@@Z$0 endp
.text$x:0000587F
.text$x:00005884
.text$x:00005884 ; =============== S U B R O U T I N E =======================================
.text$x:00005884
.text$x:00005884
.text$x:00005884 __ehhandler$??0?$_String_iterator@V?$_String_val@U?$_Simple_types@_W@std@@@std@@@std@@QAE@PA_WPBU_Container_base12@1@@Z proc near
.text$x:00005884                                         ; DATA XREF: std::_String_iterator<std::_String_val<std::_Simple_types<wchar_t>>>::_String_iterator<std::_String_val<std::_Simple_types<wchar_t>>>(wchar_t *,std::_Container_base12 const *)+5o
.text$x:00005884
.text$x:00005884 arg_4           = dword ptr  8
.text$x:00005884
.text$x:00005884                 mov     edx, [esp+arg_4]
.text$x:00005888                 lea     eax, [edx+0Ch]
.text$x:0000588B                 mov     ecx, [edx-8]
.text$x:0000588E                 xor     ecx, eax
.text$x:00005890                 call    @__security_check_cookie@4 ; __security_check_cookie(x)
.text$x:00005895                 mov     eax, offset __ehfuncinfo$??0?$_String_iterator@V?$_String_val@U?$_Simple_types@_W@std@@@std@@@std@@QAE@PA_WPBU_Container_base12@1@@Z
.text$x:0000589A                 jmp     ___CxxFrameHandler3
.text$x:0000589A __ehhandler$??0?$_String_iterator@V?$_String_val@U?$_Simple_types@_W@std@@@std@@@std@@QAE@PA_WPBU_Container_base12@1@@Z endp
.text$x:0000589A
.text$x:0000589A ; ---------------------------------------------------------------------------
.text$x:0000589F                 align 10h
.text$x:0000589F _text$x         ends
.text$x:0000589F
.text$mn:000058A0 ; ===========================================================================
.text$mn:000058A0
.text$mn:000058A0 ; Segment type: Pure code
.text$mn:000058A0 ; Segment permissions: Read/Execute
.text$mn:000058A0 _text$mn        segment para public 'CODE' use32
.text$mn:000058A0                 assume cs:_text$mn
.text$mn:000058A0                 ;org 58A0h
.text$mn:000058A0 ; COMDAT (pick any)
.text$mn:000058A0                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text$mn:000058A0
.text$mn:000058A0 ; =============== S U B R O U T I N E =======================================
.text$mn:000058A0
.text$mn:000058A0 ; Attributes: bp-based frame
.text$mn:000058A0
.text$mn:000058A0 ; public: __thiscall std::_String_val<struct std::_Simple_types<char>>::_String_val<struct std::_Simple_types<char>>(void)
.text$mn:000058A0                 public ??0?$_String_val@U?$_Simple_types@D@std@@@std@@QAE@XZ
.text$mn:000058A0 ??0?$_String_val@U?$_Simple_types@D@std@@@std@@QAE@XZ proc near
.text$mn:000058A0                                         ; CODE XREF: std::_String_alloc<0,std::_String_base_types<char,std::allocator<char>>>::_String_alloc<0,std::_String_base_types<char,std::allocator<char>>>(std::allocator<char> const &)+29p
.text$mn:000058A0
.text$mn:000058A0 var_10          = dword ptr -10h
.text$mn:000058A0 var_C           = dword ptr -0Ch
.text$mn:000058A0 var_4           = dword ptr -4
.text$mn:000058A0
.text$mn:000058A0                 push    ebp
.text$mn:000058A1                 mov     ebp, esp
.text$mn:000058A3                 push    0FFFFFFFFh
.text$mn:000058A5                 push    offset __ehhandler$??0?$_String_val@U?$_Simple_types@D@std@@@std@@QAE@XZ
.text$mn:000058AA                 mov     eax, large fs:0
.text$mn:000058B0                 push    eax
.text$mn:000058B1                 push    ecx
.text$mn:000058B2                 mov     eax, dword ptr ds:___security_cookie
.text$mn:000058B7                 xor     eax, ebp
.text$mn:000058B9                 push    eax
.text$mn:000058BA                 lea     eax, [ebp+var_C]
.text$mn:000058BD                 mov     large fs:0, eax
.text$mn:000058C3                 mov     [ebp+var_10], ecx
.text$mn:000058C6                 mov     ecx, [ebp+var_10] ; this
.text$mn:000058C9                 call    ??0_Container_base12@std@@QAE@XZ ; std::_Container_base12::_Container_base12(void)
.text$mn:000058CE                 mov     [ebp+var_4], 0
.text$mn:000058D5                 mov     eax, [ebp+var_10]
.text$mn:000058D8                 mov     dword ptr [eax+14h], 0
.text$mn:000058DF                 mov     ecx, [ebp+var_10]
.text$mn:000058E2                 mov     dword ptr [ecx+18h], 0
.text$mn:000058E9                 mov     [ebp+var_4], 0FFFFFFFFh
.text$mn:000058F0                 mov     eax, [ebp+var_10]
.text$mn:000058F3                 mov     ecx, [ebp+var_C]
.text$mn:000058F6                 mov     large fs:0, ecx
.text$mn:000058FD                 pop     ecx
.text$mn:000058FE                 mov     esp, ebp
.text$mn:00005900                 pop     ebp
.text$mn:00005901                 retn
.text$mn:00005901 ??0?$_String_val@U?$_Simple_types@D@std@@@std@@QAE@XZ endp
.text$mn:00005901
.text$mn:00005901 ; ---------------------------------------------------------------------------
.text$mn:00005902                 align 4
.text$mn:00005902 _text$mn        ends
.text$mn:00005902
.text$x:00005904 ; ===========================================================================
.text$x:00005904
.text$x:00005904 ; Segment type: Pure code
.text$x:00005904 ; Segment permissions: Read/Execute
.text$x:00005904 _text$x         segment para public 'CODE' use32
.text$x:00005904                 assume cs:_text$x
.text$x:00005904                 ;org 5904h
.text$x:00005904 ; COMDAT (pick associative to section at 58A0)
.text$x:00005904                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text$x:00005904
.text$x:00005904 ; =============== S U B R O U T I N E =======================================
.text$x:00005904
.text$x:00005904
.text$x:00005904 __unwindfunclet$??0?$_String_val@U?$_Simple_types@D@std@@@std@@QAE@XZ$0 proc near
.text$x:00005904                                         ; DATA XREF: .xdata$x:0000D544o
.text$x:00005904                 mov     ecx, [ebp-10h]  ; this
.text$x:00005907                 jmp     ??1_Container_base12@std@@QAE@XZ ; std::_Container_base12::~_Container_base12(void)
.text$x:00005907 __unwindfunclet$??0?$_String_val@U?$_Simple_types@D@std@@@std@@QAE@XZ$0 endp
.text$x:00005907
.text$x:0000590C
.text$x:0000590C ; =============== S U B R O U T I N E =======================================
.text$x:0000590C
.text$x:0000590C
.text$x:0000590C __ehhandler$??0?$_String_val@U?$_Simple_types@D@std@@@std@@QAE@XZ proc near
.text$x:0000590C                                         ; DATA XREF: std::_String_val<std::_Simple_types<char>>::_String_val<std::_Simple_types<char>>(void)+5o
.text$x:0000590C
.text$x:0000590C arg_4           = dword ptr  8
.text$x:0000590C
.text$x:0000590C                 mov     edx, [esp+arg_4]
.text$x:00005910                 lea     eax, [edx+0Ch]
.text$x:00005913                 mov     ecx, [edx-8]
.text$x:00005916                 xor     ecx, eax
.text$x:00005918                 call    @__security_check_cookie@4 ; __security_check_cookie(x)
.text$x:0000591D                 mov     eax, offset __ehfuncinfo$??0?$_String_val@U?$_Simple_types@D@std@@@std@@QAE@XZ
.text$x:00005922                 jmp     ___CxxFrameHandler3
.text$x:00005922 __ehhandler$??0?$_String_val@U?$_Simple_types@D@std@@@std@@QAE@XZ endp
.text$x:00005922
.text$x:00005922 ; ---------------------------------------------------------------------------
.text$x:00005927                 align 4
.text$x:00005927 _text$x         ends
.text$x:00005927
.text$mn:00005928 ; ===========================================================================
.text$mn:00005928
.text$mn:00005928 ; Segment type: Pure code
.text$mn:00005928 ; Segment permissions: Read/Execute
.text$mn:00005928 _text$mn        segment para public 'CODE' use32
.text$mn:00005928                 assume cs:_text$mn
.text$mn:00005928                 ;org 5928h
.text$mn:00005928 ; COMDAT (pick any)
.text$mn:00005928                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text$mn:00005928
.text$mn:00005928 ; =============== S U B R O U T I N E =======================================
.text$mn:00005928
.text$mn:00005928 ; Attributes: bp-based frame
.text$mn:00005928
.text$mn:00005928 ; public: __thiscall std::_String_val<struct std::_Simple_types<wchar_t>>::_String_val<struct std::_Simple_types<wchar_t>>(void)
.text$mn:00005928                 public ??0?$_String_val@U?$_Simple_types@_W@std@@@std@@QAE@XZ
.text$mn:00005928 ??0?$_String_val@U?$_Simple_types@_W@std@@@std@@QAE@XZ proc near
.text$mn:00005928                                         ; CODE XREF: std::_String_alloc<0,std::_String_base_types<wchar_t,std::allocator<wchar_t>>>::_String_alloc<0,std::_String_base_types<wchar_t,std::allocator<wchar_t>>>(std::allocator<wchar_t> const &)+29p
.text$mn:00005928
.text$mn:00005928 var_10          = dword ptr -10h
.text$mn:00005928 var_C           = dword ptr -0Ch
.text$mn:00005928 var_4           = dword ptr -4
.text$mn:00005928
.text$mn:00005928                 push    ebp
.text$mn:00005929                 mov     ebp, esp
.text$mn:0000592B                 push    0FFFFFFFFh
.text$mn:0000592D                 push    offset __ehhandler$??0?$_String_val@U?$_Simple_types@_W@std@@@std@@QAE@XZ
.text$mn:00005932                 mov     eax, large fs:0
.text$mn:00005938                 push    eax
.text$mn:00005939                 push    ecx
.text$mn:0000593A                 mov     eax, dword ptr ds:___security_cookie
.text$mn:0000593F                 xor     eax, ebp
.text$mn:00005941                 push    eax
.text$mn:00005942                 lea     eax, [ebp+var_C]
.text$mn:00005945                 mov     large fs:0, eax
.text$mn:0000594B                 mov     [ebp+var_10], ecx
.text$mn:0000594E                 mov     ecx, [ebp+var_10] ; this
.text$mn:00005951                 call    ??0_Container_base12@std@@QAE@XZ ; std::_Container_base12::_Container_base12(void)
.text$mn:00005956                 mov     [ebp+var_4], 0
.text$mn:0000595D                 mov     eax, [ebp+var_10]
.text$mn:00005960                 mov     dword ptr [eax+14h], 0
.text$mn:00005967                 mov     ecx, [ebp+var_10]
.text$mn:0000596A                 mov     dword ptr [ecx+18h], 0
.text$mn:00005971                 mov     [ebp+var_4], 0FFFFFFFFh
.text$mn:00005978                 mov     eax, [ebp+var_10]
.text$mn:0000597B                 mov     ecx, [ebp+var_C]
.text$mn:0000597E                 mov     large fs:0, ecx
.text$mn:00005985                 pop     ecx
.text$mn:00005986                 mov     esp, ebp
.text$mn:00005988                 pop     ebp
.text$mn:00005989                 retn
.text$mn:00005989 ??0?$_String_val@U?$_Simple_types@_W@std@@@std@@QAE@XZ endp
.text$mn:00005989
.text$mn:00005989 ; ---------------------------------------------------------------------------
.text$mn:0000598A                 align 4
.text$mn:0000598A _text$mn        ends
.text$mn:0000598A
.text$x:0000598C ; ===========================================================================
.text$x:0000598C
.text$x:0000598C ; Segment type: Pure code
.text$x:0000598C ; Segment permissions: Read/Execute
.text$x:0000598C _text$x         segment para public 'CODE' use32
.text$x:0000598C                 assume cs:_text$x
.text$x:0000598C                 ;org 598Ch
.text$x:0000598C ; COMDAT (pick associative to section at 5928)
.text$x:0000598C                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text$x:0000598C
.text$x:0000598C ; =============== S U B R O U T I N E =======================================
.text$x:0000598C
.text$x:0000598C
.text$x:0000598C __unwindfunclet$??0?$_String_val@U?$_Simple_types@_W@std@@@std@@QAE@XZ$0 proc near
.text$x:0000598C                                         ; DATA XREF: .xdata$x:0000D940o
.text$x:0000598C                 mov     ecx, [ebp-10h]  ; this
.text$x:0000598F                 jmp     ??1_Container_base12@std@@QAE@XZ ; std::_Container_base12::~_Container_base12(void)
.text$x:0000598F __unwindfunclet$??0?$_String_val@U?$_Simple_types@_W@std@@@std@@QAE@XZ$0 endp
.text$x:0000598F
.text$x:00005994
.text$x:00005994 ; =============== S U B R O U T I N E =======================================
.text$x:00005994
.text$x:00005994
.text$x:00005994 __ehhandler$??0?$_String_val@U?$_Simple_types@_W@std@@@std@@QAE@XZ proc near
.text$x:00005994                                         ; DATA XREF: std::_String_val<std::_Simple_types<wchar_t>>::_String_val<std::_Simple_types<wchar_t>>(void)+5o
.text$x:00005994
.text$x:00005994 arg_4           = dword ptr  8
.text$x:00005994
.text$x:00005994                 mov     edx, [esp+arg_4]
.text$x:00005998                 lea     eax, [edx+0Ch]
.text$x:0000599B                 mov     ecx, [edx-8]
.text$x:0000599E                 xor     ecx, eax
.text$x:000059A0                 call    @__security_check_cookie@4 ; __security_check_cookie(x)
.text$x:000059A5                 mov     eax, offset __ehfuncinfo$??0?$_String_val@U?$_Simple_types@_W@std@@@std@@QAE@XZ
.text$x:000059AA                 jmp     ___CxxFrameHandler3
.text$x:000059AA __ehhandler$??0?$_String_val@U?$_Simple_types@_W@std@@@std@@QAE@XZ endp
.text$x:000059AA
.text$x:000059AA ; ---------------------------------------------------------------------------
.text$x:000059AF                 align 10h
.text$x:000059AF _text$x         ends
.text$x:000059AF
.text$mn:000059B0 ; ===========================================================================
.text$mn:000059B0
.text$mn:000059B0 ; Segment type: Pure code
.text$mn:000059B0 ; Segment permissions: Read/Execute
.text$mn:000059B0 _text$mn        segment para public 'CODE' use32
.text$mn:000059B0                 assume cs:_text$mn
.text$mn:000059B0                 ;org 59B0h
.text$mn:000059B0 ; COMDAT (pick any)
.text$mn:000059B0                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text$mn:000059B0
.text$mn:000059B0 ; =============== S U B R O U T I N E =======================================
.text$mn:000059B0
.text$mn:000059B0 ; Attributes: bp-based frame
.text$mn:000059B0
.text$mn:000059B0 ; public: __thiscall std::_Vector_alloc<0, struct std::_Vec_base_types<char, class std::allocator<char>>>::_Vector_alloc<0, struct std::_Vec_base_types<char, class std::allocator<char>>>(class std::allocator<char> const &)
.text$mn:000059B0                 public ??0?$_Vector_alloc@$0A@U?$_Vec_base_types@DV?$allocator@D@std@@@std@@@std@@QAE@ABV?$allocator@D@1@@Z
.text$mn:000059B0 ??0?$_Vector_alloc@$0A@U?$_Vec_base_types@DV?$allocator@D@std@@@std@@@std@@QAE@ABV?$allocator@D@1@@Z proc near
.text$mn:000059B0                                         ; CODE XREF: std::vector<char,std::allocator<char>>::vector<char,std::allocator<char>>(uint)+3Bp
.text$mn:000059B0
.text$mn:000059B0 var_10          = dword ptr -10h
.text$mn:000059B0 var_C           = dword ptr -0Ch
.text$mn:000059B0 var_4           = dword ptr -4
.text$mn:000059B0
.text$mn:000059B0                 push    ebp
.text$mn:000059B1                 mov     ebp, esp
.text$mn:000059B3                 push    0FFFFFFFFh
.text$mn:000059B5                 push    offset __ehhandler$??0?$_Vector_alloc@$0A@U?$_Vec_base_types@DV?$allocator@D@std@@@std@@@std@@QAE@ABV?$allocator@D@1@@Z
.text$mn:000059BA                 mov     eax, large fs:0
.text$mn:000059C0                 push    eax
.text$mn:000059C1                 push    ecx
.text$mn:000059C2                 mov     eax, dword ptr ds:___security_cookie
.text$mn:000059C7                 xor     eax, ebp
.text$mn:000059C9                 push    eax
.text$mn:000059CA                 lea     eax, [ebp+var_C]
.text$mn:000059CD                 mov     large fs:0, eax
.text$mn:000059D3                 mov     [ebp+var_10], ecx
.text$mn:000059D6                 mov     ecx, [ebp+var_10]
.text$mn:000059D9                 call    ??0?$_Vector_val@U?$_Simple_types@D@std@@@std@@QAE@XZ ; std::_Vector_val<std::_Simple_types<char>>::_Vector_val<std::_Simple_types<char>>(void)
.text$mn:000059DE                 mov     [ebp+var_4], 0
.text$mn:000059E5                 mov     ecx, [ebp+var_10]
.text$mn:000059E8                 call    ?_Alloc_proxy@?$_Vector_alloc@$0A@U?$_Vec_base_types@DV?$allocator@D@std@@@std@@@std@@QAEXXZ ; std::_Vector_alloc<0,std::_Vec_base_types<char,std::allocator<char>>>::_Alloc_proxy(void)
.text$mn:000059ED                 mov     [ebp+var_4], 0FFFFFFFFh
.text$mn:000059F4                 mov     eax, [ebp+var_10]
.text$mn:000059F7                 mov     ecx, [ebp+var_C]
.text$mn:000059FA                 mov     large fs:0, ecx
.text$mn:00005A01                 pop     ecx
.text$mn:00005A02                 mov     esp, ebp
.text$mn:00005A04                 pop     ebp
.text$mn:00005A05                 retn    4
.text$mn:00005A05 ??0?$_Vector_alloc@$0A@U?$_Vec_base_types@DV?$allocator@D@std@@@std@@@std@@QAE@ABV?$allocator@D@1@@Z endp
.text$mn:00005A05
.text$mn:00005A05 _text$mn        ends
.text$mn:00005A05
.text$x:00005A08 ; ===========================================================================
.text$x:00005A08
.text$x:00005A08 ; Segment type: Pure code
.text$x:00005A08 ; Segment permissions: Read/Execute
.text$x:00005A08 _text$x         segment para public 'CODE' use32
.text$x:00005A08                 assume cs:_text$x
.text$x:00005A08                 ;org 5A08h
.text$x:00005A08 ; COMDAT (pick associative to section at 59B0)
.text$x:00005A08                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text$x:00005A08
.text$x:00005A08 ; =============== S U B R O U T I N E =======================================
.text$x:00005A08
.text$x:00005A08
.text$x:00005A08 __unwindfunclet$??0?$_Vector_alloc@$0A@U?$_Vec_base_types@DV?$allocator@D@std@@@std@@@std@@QAE@ABV?$allocator@D@1@@Z$0 proc near
.text$x:00005A08                                         ; DATA XREF: .xdata$x:0000E6D0o
.text$x:00005A08                 mov     ecx, [ebp-10h]
.text$x:00005A0B                 jmp     ??1?$_Vector_val@U?$_Simple_types@D@std@@@std@@QAE@XZ ; std::_Vector_val<std::_Simple_types<char>>::~_Vector_val<std::_Simple_types<char>>(void)
.text$x:00005A0B __unwindfunclet$??0?$_Vector_alloc@$0A@U?$_Vec_base_types@DV?$allocator@D@std@@@std@@@std@@QAE@ABV?$allocator@D@1@@Z$0 endp
.text$x:00005A0B
.text$x:00005A10
.text$x:00005A10 ; =============== S U B R O U T I N E =======================================
.text$x:00005A10
.text$x:00005A10
.text$x:00005A10 __ehhandler$??0?$_Vector_alloc@$0A@U?$_Vec_base_types@DV?$allocator@D@std@@@std@@@std@@QAE@ABV?$allocator@D@1@@Z proc near
.text$x:00005A10                                         ; DATA XREF: std::_Vector_alloc<0,std::_Vec_base_types<char,std::allocator<char>>>::_Vector_alloc<0,std::_Vec_base_types<char,std::allocator<char>>>(std::allocator<char> const &)+5o
.text$x:00005A10
.text$x:00005A10 arg_4           = dword ptr  8
.text$x:00005A10
.text$x:00005A10                 mov     edx, [esp+arg_4]
.text$x:00005A14                 lea     eax, [edx+0Ch]
.text$x:00005A17                 mov     ecx, [edx-8]
.text$x:00005A1A                 xor     ecx, eax
.text$x:00005A1C                 call    @__security_check_cookie@4 ; __security_check_cookie(x)
.text$x:00005A21                 mov     eax, offset __ehfuncinfo$??0?$_Vector_alloc@$0A@U?$_Vec_base_types@DV?$allocator@D@std@@@std@@@std@@QAE@ABV?$allocator@D@1@@Z
.text$x:00005A26                 jmp     ___CxxFrameHandler3
.text$x:00005A26 __ehhandler$??0?$_Vector_alloc@$0A@U?$_Vec_base_types@DV?$allocator@D@std@@@std@@@std@@QAE@ABV?$allocator@D@1@@Z endp
.text$x:00005A26
.text$x:00005A26 ; ---------------------------------------------------------------------------
.text$x:00005A2B                 align 4
.text$x:00005A2B _text$x         ends
.text$x:00005A2B
.text$mn:00005A2C ; ===========================================================================
.text$mn:00005A2C
.text$mn:00005A2C ; Segment type: Pure code
.text$mn:00005A2C ; Segment permissions: Read/Execute
.text$mn:00005A2C _text$mn        segment para public 'CODE' use32
.text$mn:00005A2C                 assume cs:_text$mn
.text$mn:00005A2C                 ;org 5A2Ch
.text$mn:00005A2C ; COMDAT (pick any)
.text$mn:00005A2C                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text$mn:00005A2C
.text$mn:00005A2C ; =============== S U B R O U T I N E =======================================
.text$mn:00005A2C
.text$mn:00005A2C ; Attributes: bp-based frame
.text$mn:00005A2C
.text$mn:00005A2C ; public: __thiscall std::_Vector_alloc<0, struct std::_Vec_base_types<class std::basic_string<wchar_t, struct std::char_traits<wchar_t>, class std::allocator<wchar_t>>, class std::allocator<class std::basic_string<wchar_t, struct std::char_traits<wchar_t>, class std::allocator<wchar_t>>>>>::_Vector_alloc<0, struct std::_Vec_base_types<class std::basic_string<wchar_t, struct std::char_traits<wchar_t>, class std::allocator<wchar_t>>, class std::allocator<class std::basic_string<wchar_t, struct std::char_traits<wchar_t>, class std::allocator<wchar_t>>>>>(class std::allocator<class std::basic_string<wchar_t, struct std::char_traits<wchar_t>, class std::allocator<wchar_t>>> const &)
.text$mn:00005A2C                 public ??0?$_Vector_alloc@$0A@U?$_Vec_base_types@V?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@V?$allocator@V?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@@2@@std@@@std@@QAE@ABV?$allocator@V?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@@1@@Z
.text$mn:00005A2C ??0?$_Vector_alloc@$0A@U?$_Vec_base_types@V?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@V?$allocator@V?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@@2@@std@@@std@@QAE@ABV?$allocator@V?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@@1@@Z proc near
.text$mn:00005A2C                                         ; CODE XREF: std::vector<std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>>,std::allocator<std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>>>>::vector<std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>>,std::allocator<std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>>>>(std::vector<std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>>,std::allocator<std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>>>> &&)+38p
.text$mn:00005A2C                                         ; std::vector<std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>>,std::allocator<std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>>>>::vector<std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>>,std::allocator<std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>>>>(void)+34p
.text$mn:00005A2C
.text$mn:00005A2C var_10          = dword ptr -10h
.text$mn:00005A2C var_C           = dword ptr -0Ch
.text$mn:00005A2C var_4           = dword ptr -4
.text$mn:00005A2C
.text$mn:00005A2C                 push    ebp
.text$mn:00005A2D                 mov     ebp, esp
.text$mn:00005A2F                 push    0FFFFFFFFh
.text$mn:00005A31                 push    offset __ehhandler$??0?$_Vector_alloc@$0A@U?$_Vec_base_types@V?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@V?$allocator@V?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@@2@@std@@@std@@QAE@ABV?$allocator@V?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@@1@@Z
.text$mn:00005A36                 mov     eax, large fs:0
.text$mn:00005A3C                 push    eax
.text$mn:00005A3D                 push    ecx
.text$mn:00005A3E                 mov     eax, dword ptr ds:___security_cookie
.text$mn:00005A43                 xor     eax, ebp
.text$mn:00005A45                 push    eax
.text$mn:00005A46                 lea     eax, [ebp+var_C]
.text$mn:00005A49                 mov     large fs:0, eax
.text$mn:00005A4F                 mov     [ebp+var_10], ecx
.text$mn:00005A52                 mov     ecx, [ebp+var_10]
.text$mn:00005A55                 call    ??0?$_Vector_val@U?$_Simple_types@V?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@@std@@@std@@QAE@XZ ; std::_Vector_val<std::_Simple_types<std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>>>>::_Vector_val<std::_Simple_types<std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>>>>(void)
.text$mn:00005A5A                 mov     [ebp+var_4], 0
.text$mn:00005A61                 mov     ecx, [ebp+var_10]
.text$mn:00005A64                 call    ?_Alloc_proxy@?$_Vector_alloc@$0A@U?$_Vec_base_types@V?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@V?$allocator@V?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@@2@@std@@@std@@QAEXXZ ; std::_Vector_alloc<0,std::_Vec_base_types<std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>>,std::allocator<std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>>>>>::_Alloc_proxy(void)
.text$mn:00005A69                 mov     [ebp+var_4], 0FFFFFFFFh
.text$mn:00005A70                 mov     eax, [ebp+var_10]
.text$mn:00005A73                 mov     ecx, [ebp+var_C]
.text$mn:00005A76                 mov     large fs:0, ecx
.text$mn:00005A7D                 pop     ecx
.text$mn:00005A7E                 mov     esp, ebp
.text$mn:00005A80                 pop     ebp
.text$mn:00005A81                 retn    4
.text$mn:00005A81 ??0?$_Vector_alloc@$0A@U?$_Vec_base_types@V?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@V?$allocator@V?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@@2@@std@@@std@@QAE@ABV?$allocator@V?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@@1@@Z endp
.text$mn:00005A81
.text$mn:00005A81 _text$mn        ends
.text$mn:00005A81
.text$x:00005A84 ; ===========================================================================
.text$x:00005A84
.text$x:00005A84 ; Segment type: Pure code
.text$x:00005A84 ; Segment permissions: Read/Execute
.text$x:00005A84 _text$x         segment para public 'CODE' use32
.text$x:00005A84                 assume cs:_text$x
.text$x:00005A84                 ;org 5A84h
.text$x:00005A84 ; COMDAT (pick associative to section at 5A2C)
.text$x:00005A84                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text$x:00005A84
.text$x:00005A84 ; =============== S U B R O U T I N E =======================================
.text$x:00005A84
.text$x:00005A84
.text$x:00005A84 __unwindfunclet$??0?$_Vector_alloc@$0A@U?$_Vec_base_types@V?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@V?$allocator@V?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@@2@@std@@@std@@QAE@ABV?$allocator@V?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@@1@@Z$0 proc near
.text$x:00005A84                                         ; DATA XREF: .xdata$x:0000E25Co
.text$x:00005A84                 mov     ecx, [ebp-10h]
.text$x:00005A87                 jmp     ??1?$_Vector_val@U?$_Simple_types@V?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@@std@@@std@@QAE@XZ ; std::_Vector_val<std::_Simple_types<std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>>>>::~_Vector_val<std::_Simple_types<std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>>>>(void)
.text$x:00005A87 __unwindfunclet$??0?$_Vector_alloc@$0A@U?$_Vec_base_types@V?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@V?$allocator@V?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@@2@@std@@@std@@QAE@ABV?$allocator@V?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@@1@@Z$0 endp
.text$x:00005A87
.text$x:00005A8C
.text$x:00005A8C ; =============== S U B R O U T I N E =======================================
.text$x:00005A8C
.text$x:00005A8C
.text$x:00005A8C __ehhandler$??0?$_Vector_alloc@$0A@U?$_Vec_base_types@V?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@V?$allocator@V?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@@2@@std@@@std@@QAE@ABV?$allocator@V?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@@1@@Z proc near
.text$x:00005A8C                                         ; DATA XREF: std::_Vector_alloc<0,std::_Vec_base_types<std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>>,std::allocator<std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>>>>>::_Vector_alloc<0,std::_Vec_base_types<std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>>,std::allocator<std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>>>>>(std::allocator<std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>>> const &)+5o
.text$x:00005A8C
.text$x:00005A8C arg_4           = dword ptr  8
.text$x:00005A8C
.text$x:00005A8C                 mov     edx, [esp+arg_4]
.text$x:00005A90                 lea     eax, [edx+0Ch]
.text$x:00005A93                 mov     ecx, [edx-8]
.text$x:00005A96                 xor     ecx, eax
.text$x:00005A98                 call    @__security_check_cookie@4 ; __security_check_cookie(x)
.text$x:00005A9D                 mov     eax, offset __ehfuncinfo$??0?$_Vector_alloc@$0A@U?$_Vec_base_types@V?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@V?$allocator@V?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@@2@@std@@@std@@QAE@ABV?$allocator@V?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@@1@@Z
.text$x:00005AA2                 jmp     ___CxxFrameHandler3
.text$x:00005AA2 __ehhandler$??0?$_Vector_alloc@$0A@U?$_Vec_base_types@V?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@V?$allocator@V?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@@2@@std@@@std@@QAE@ABV?$allocator@V?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@@1@@Z endp
.text$x:00005AA2
.text$x:00005AA2 ; ---------------------------------------------------------------------------
.text$x:00005AA7                 align 4
.text$x:00005AA7 _text$x         ends
.text$x:00005AA7
.text$mn:00005AA8 ; ===========================================================================
.text$mn:00005AA8
.text$mn:00005AA8 ; Segment type: Pure code
.text$mn:00005AA8 ; Segment permissions: Read/Execute
.text$mn:00005AA8 _text$mn        segment para public 'CODE' use32
.text$mn:00005AA8                 assume cs:_text$mn
.text$mn:00005AA8                 ;org 5AA8h
.text$mn:00005AA8 ; COMDAT (pick any)
.text$mn:00005AA8                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text$mn:00005AA8
.text$mn:00005AA8 ; =============== S U B R O U T I N E =======================================
.text$mn:00005AA8
.text$mn:00005AA8 ; Attributes: bp-based frame
.text$mn:00005AA8
.text$mn:00005AA8 ; public: __thiscall std::_Vector_alloc<0, struct std::_Vec_base_types<wchar_t, class std::allocator<wchar_t>>>::_Vector_alloc<0, struct std::_Vec_base_types<wchar_t, class std::allocator<wchar_t>>>(class std::allocator<wchar_t> const &)
.text$mn:00005AA8                 public ??0?$_Vector_alloc@$0A@U?$_Vec_base_types@_WV?$allocator@_W@std@@@std@@@std@@QAE@ABV?$allocator@_W@1@@Z
.text$mn:00005AA8 ??0?$_Vector_alloc@$0A@U?$_Vec_base_types@_WV?$allocator@_W@std@@@std@@@std@@QAE@ABV?$allocator@_W@1@@Z proc near
.text$mn:00005AA8                                         ; CODE XREF: std::vector<wchar_t,std::allocator<wchar_t>>::vector<wchar_t,std::allocator<wchar_t>>(uint)+3Bp
.text$mn:00005AA8                                         ; std::vector<wchar_t,std::allocator<wchar_t>>::vector<wchar_t,std::allocator<wchar_t>>(void)+34p
.text$mn:00005AA8
.text$mn:00005AA8 var_10          = dword ptr -10h
.text$mn:00005AA8 var_C           = dword ptr -0Ch
.text$mn:00005AA8 var_4           = dword ptr -4
.text$mn:00005AA8
.text$mn:00005AA8                 push    ebp
.text$mn:00005AA9                 mov     ebp, esp
.text$mn:00005AAB                 push    0FFFFFFFFh
.text$mn:00005AAD                 push    offset __ehhandler$??0?$_Vector_alloc@$0A@U?$_Vec_base_types@_WV?$allocator@_W@std@@@std@@@std@@QAE@ABV?$allocator@_W@1@@Z
.text$mn:00005AB2                 mov     eax, large fs:0
.text$mn:00005AB8                 push    eax
.text$mn:00005AB9                 push    ecx
.text$mn:00005ABA                 mov     eax, dword ptr ds:___security_cookie
.text$mn:00005ABF                 xor     eax, ebp
.text$mn:00005AC1                 push    eax
.text$mn:00005AC2                 lea     eax, [ebp+var_C]
.text$mn:00005AC5                 mov     large fs:0, eax
.text$mn:00005ACB                 mov     [ebp+var_10], ecx
.text$mn:00005ACE                 mov     ecx, [ebp+var_10]
.text$mn:00005AD1                 call    ??0?$_Vector_val@U?$_Simple_types@_W@std@@@std@@QAE@XZ ; std::_Vector_val<std::_Simple_types<wchar_t>>::_Vector_val<std::_Simple_types<wchar_t>>(void)
.text$mn:00005AD6                 mov     [ebp+var_4], 0
.text$mn:00005ADD                 mov     ecx, [ebp+var_10]
.text$mn:00005AE0                 call    ?_Alloc_proxy@?$_Vector_alloc@$0A@U?$_Vec_base_types@_WV?$allocator@_W@std@@@std@@@std@@QAEXXZ ; std::_Vector_alloc<0,std::_Vec_base_types<wchar_t,std::allocator<wchar_t>>>::_Alloc_proxy(void)
.text$mn:00005AE5                 mov     [ebp+var_4], 0FFFFFFFFh
.text$mn:00005AEC                 mov     eax, [ebp+var_10]
.text$mn:00005AEF                 mov     ecx, [ebp+var_C]
.text$mn:00005AF2                 mov     large fs:0, ecx
.text$mn:00005AF9                 pop     ecx
.text$mn:00005AFA                 mov     esp, ebp
.text$mn:00005AFC                 pop     ebp
.text$mn:00005AFD                 retn    4
.text$mn:00005AFD ??0?$_Vector_alloc@$0A@U?$_Vec_base_types@_WV?$allocator@_W@std@@@std@@@std@@QAE@ABV?$allocator@_W@1@@Z endp
.text$mn:00005AFD
.text$mn:00005AFD _text$mn        ends
.text$mn:00005AFD
.text$x:00005B00 ; ===========================================================================
.text$x:00005B00
.text$x:00005B00 ; Segment type: Pure code
.text$x:00005B00 ; Segment permissions: Read/Execute
.text$x:00005B00 _text$x         segment para public 'CODE' use32
.text$x:00005B00                 assume cs:_text$x
.text$x:00005B00                 ;org 5B00h
.text$x:00005B00 ; COMDAT (pick associative to section at 5AA8)
.text$x:00005B00                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text$x:00005B00
.text$x:00005B00 ; =============== S U B R O U T I N E =======================================
.text$x:00005B00
.text$x:00005B00
.text$x:00005B00 __unwindfunclet$??0?$_Vector_alloc@$0A@U?$_Vec_base_types@_WV?$allocator@_W@std@@@std@@@std@@QAE@ABV?$allocator@_W@1@@Z$0 proc near
.text$x:00005B00                                         ; DATA XREF: .xdata$x:0000E414o
.text$x:00005B00                 mov     ecx, [ebp-10h]
.text$x:00005B03                 jmp     ??1?$_Vector_val@U?$_Simple_types@_W@std@@@std@@QAE@XZ ; std::_Vector_val<std::_Simple_types<wchar_t>>::~_Vector_val<std::_Simple_types<wchar_t>>(void)
.text$x:00005B03 __unwindfunclet$??0?$_Vector_alloc@$0A@U?$_Vec_base_types@_WV?$allocator@_W@std@@@std@@@std@@QAE@ABV?$allocator@_W@1@@Z$0 endp
.text$x:00005B03
.text$x:00005B08
.text$x:00005B08 ; =============== S U B R O U T I N E =======================================
.text$x:00005B08
.text$x:00005B08
.text$x:00005B08 __ehhandler$??0?$_Vector_alloc@$0A@U?$_Vec_base_types@_WV?$allocator@_W@std@@@std@@@std@@QAE@ABV?$allocator@_W@1@@Z proc near
.text$x:00005B08                                         ; DATA XREF: std::_Vector_alloc<0,std::_Vec_base_types<wchar_t,std::allocator<wchar_t>>>::_Vector_alloc<0,std::_Vec_base_types<wchar_t,std::allocator<wchar_t>>>(std::allocator<wchar_t> const &)+5o
.text$x:00005B08
.text$x:00005B08 arg_4           = dword ptr  8
.text$x:00005B08
.text$x:00005B08                 mov     edx, [esp+arg_4]
.text$x:00005B0C                 lea     eax, [edx+0Ch]
.text$x:00005B0F                 mov     ecx, [edx-8]
.text$x:00005B12                 xor     ecx, eax
.text$x:00005B14                 call    @__security_check_cookie@4 ; __security_check_cookie(x)
.text$x:00005B19                 mov     eax, offset __ehfuncinfo$??0?$_Vector_alloc@$0A@U?$_Vec_base_types@_WV?$allocator@_W@std@@@std@@@std@@QAE@ABV?$allocator@_W@1@@Z
.text$x:00005B1E                 jmp     ___CxxFrameHandler3
.text$x:00005B1E __ehhandler$??0?$_Vector_alloc@$0A@U?$_Vec_base_types@_WV?$allocator@_W@std@@@std@@@std@@QAE@ABV?$allocator@_W@1@@Z endp
.text$x:00005B1E
.text$x:00005B1E ; ---------------------------------------------------------------------------
.text$x:00005B23                 align 4
.text$x:00005B23 _text$x         ends
.text$x:00005B23
.text$mn:00005B24 ; ===========================================================================
.text$mn:00005B24
.text$mn:00005B24 ; Segment type: Pure code
.text$mn:00005B24 ; Segment permissions: Read/Execute
.text$mn:00005B24 _text$mn        segment para public 'CODE' use32
.text$mn:00005B24                 assume cs:_text$mn
.text$mn:00005B24                 ;org 5B24h
.text$mn:00005B24 ; COMDAT (pick any)
.text$mn:00005B24                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text$mn:00005B24
.text$mn:00005B24 ; =============== S U B R O U T I N E =======================================
.text$mn:00005B24
.text$mn:00005B24 ; Attributes: bp-based frame
.text$mn:00005B24
.text$mn:00005B24 ; int __stdcall std::_Vector_const_iterator<std::_Vector_val<std::_Simple_types<wchar_t>>>::_Vector_const_iterator<std::_Vector_val<std::_Simple_types<wchar_t>>>(struct std::_Iterator_base12 *)
.text$mn:00005B24                 public ??0?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@_W@std@@@std@@@std@@QAE@ABV01@@Z
.text$mn:00005B24 ??0?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@_W@std@@@std@@@std@@QAE@ABV01@@Z proc near
.text$mn:00005B24                                         ; CODE XREF: std::_Vector_iterator<std::_Vector_val<std::_Simple_types<wchar_t>>>::_Vector_iterator<std::_Vector_val<std::_Simple_types<wchar_t>>>(std::_Vector_iterator<std::_Vector_val<std::_Simple_types<wchar_t>>> const &)+2Dp
.text$mn:00005B24
.text$mn:00005B24 var_10          = dword ptr -10h
.text$mn:00005B24 var_C           = dword ptr -0Ch
.text$mn:00005B24 var_4           = dword ptr -4
.text$mn:00005B24 arg_0           = dword ptr  8
.text$mn:00005B24
.text$mn:00005B24                 push    ebp
.text$mn:00005B25                 mov     ebp, esp
.text$mn:00005B27                 push    0FFFFFFFFh
.text$mn:00005B29                 push    offset __ehhandler$??0?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@_W@std@@@std@@@std@@QAE@ABV01@@Z
.text$mn:00005B2E                 mov     eax, large fs:0
.text$mn:00005B34                 push    eax
.text$mn:00005B35                 push    ecx
.text$mn:00005B36                 mov     eax, dword ptr ds:___security_cookie
.text$mn:00005B3B                 xor     eax, ebp
.text$mn:00005B3D                 push    eax
.text$mn:00005B3E                 lea     eax, [ebp+var_C]
.text$mn:00005B41                 mov     large fs:0, eax
.text$mn:00005B47                 mov     [ebp+var_10], ecx
.text$mn:00005B4A                 mov     eax, [ebp+arg_0]
.text$mn:00005B4D                 push    eax             ; struct std::_Iterator_base12 *
.text$mn:00005B4E                 mov     ecx, [ebp+var_10]
.text$mn:00005B51                 call    ??0?$_Iterator012@Urandom_access_iterator_tag@std@@_WHPB_WAB_WU_Iterator_base12@2@@std@@QAE@ABU01@@Z ; std::_Iterator012<std::random_access_iterator_tag,wchar_t,int,wchar_t const *,wchar_t const &,std::_Iterator_base12>::_Iterator012<std::random_access_iterator_tag,wchar_t,int,wchar_t const *,wchar_t const &,std::_Iterator_base12>(std::_Iterator012<std::random_access_iterator_tag,wchar_t,int,wchar_t const *,wchar_t const &,std::_Iterator_base12> const &)
.text$mn:00005B56                 mov     [ebp+var_4], 0
.text$mn:00005B5D                 mov     ecx, [ebp+var_10]
.text$mn:00005B60                 mov     edx, [ebp+arg_0]
.text$mn:00005B63                 mov     eax, [edx+8]
.text$mn:00005B66                 mov     [ecx+8], eax
.text$mn:00005B69                 mov     [ebp+var_4], 0FFFFFFFFh
.text$mn:00005B70                 mov     eax, [ebp+var_10]
.text$mn:00005B73                 mov     ecx, [ebp+var_C]
.text$mn:00005B76                 mov     large fs:0, ecx
.text$mn:00005B7D                 pop     ecx
.text$mn:00005B7E                 mov     esp, ebp
.text$mn:00005B80                 pop     ebp
.text$mn:00005B81                 retn    4
.text$mn:00005B81 ??0?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@_W@std@@@std@@@std@@QAE@ABV01@@Z endp
.text$mn:00005B81
.text$mn:00005B81 _text$mn        ends
.text$mn:00005B81
.text$x:00005B84 ; ===========================================================================
.text$x:00005B84
.text$x:00005B84 ; Segment type: Pure code
.text$x:00005B84 ; Segment permissions: Read/Execute
.text$x:00005B84 _text$x         segment para public 'CODE' use32
.text$x:00005B84                 assume cs:_text$x
.text$x:00005B84                 ;org 5B84h
.text$x:00005B84 ; COMDAT (pick associative to section at 5B24)
.text$x:00005B84                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text$x:00005B84
.text$x:00005B84 ; =============== S U B R O U T I N E =======================================
.text$x:00005B84
.text$x:00005B84
.text$x:00005B84 __unwindfunclet$??0?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@_W@std@@@std@@@std@@QAE@ABV01@@Z$0 proc near
.text$x:00005B84                                         ; DATA XREF: .xdata$x:0000E890o
.text$x:00005B84                 mov     ecx, [ebp-10h]
.text$x:00005B87                 jmp     ??1?$_Iterator012@Urandom_access_iterator_tag@std@@_WHPB_WAB_WU_Iterator_base12@2@@std@@QAE@XZ ; std::_Iterator012<std::random_access_iterator_tag,wchar_t,int,wchar_t const *,wchar_t const &,std::_Iterator_base12>::~_Iterator012<std::random_access_iterator_tag,wchar_t,int,wchar_t const *,wchar_t const &,std::_Iterator_base12>(void)
.text$x:00005B87 __unwindfunclet$??0?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@_W@std@@@std@@@std@@QAE@ABV01@@Z$0 endp
.text$x:00005B87
.text$x:00005B8C
.text$x:00005B8C ; =============== S U B R O U T I N E =======================================
.text$x:00005B8C
.text$x:00005B8C
.text$x:00005B8C __ehhandler$??0?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@_W@std@@@std@@@std@@QAE@ABV01@@Z proc near
.text$x:00005B8C                                         ; DATA XREF: std::_Vector_const_iterator<std::_Vector_val<std::_Simple_types<wchar_t>>>::_Vector_const_iterator<std::_Vector_val<std::_Simple_types<wchar_t>>>(std::_Vector_const_iterator<std::_Vector_val<std::_Simple_types<wchar_t>>> const &)+5o
.text$x:00005B8C
.text$x:00005B8C arg_4           = dword ptr  8
.text$x:00005B8C
.text$x:00005B8C                 mov     edx, [esp+arg_4]
.text$x:00005B90                 lea     eax, [edx+0Ch]
.text$x:00005B93                 mov     ecx, [edx-8]
.text$x:00005B96                 xor     ecx, eax
.text$x:00005B98                 call    @__security_check_cookie@4 ; __security_check_cookie(x)
.text$x:00005B9D                 mov     eax, offset __ehfuncinfo$??0?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@_W@std@@@std@@@std@@QAE@ABV01@@Z
.text$x:00005BA2                 jmp     ___CxxFrameHandler3
.text$x:00005BA2 __ehhandler$??0?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@_W@std@@@std@@@std@@QAE@ABV01@@Z endp
.text$x:00005BA2
.text$x:00005BA2 ; ---------------------------------------------------------------------------
.text$x:00005BA7                 align 4
.text$x:00005BA7 _text$x         ends
.text$x:00005BA7
.text$mn:00005BA8 ; ===========================================================================
.text$mn:00005BA8
.text$mn:00005BA8 ; Segment type: Pure code
.text$mn:00005BA8 ; Segment permissions: Read/Execute
.text$mn:00005BA8 _text$mn        segment para public 'CODE' use32
.text$mn:00005BA8                 assume cs:_text$mn
.text$mn:00005BA8                 ;org 5BA8h
.text$mn:00005BA8 ; COMDAT (pick any)
.text$mn:00005BA8                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text$mn:00005BA8
.text$mn:00005BA8 ; =============== S U B R O U T I N E =======================================
.text$mn:00005BA8
.text$mn:00005BA8 ; Attributes: bp-based frame
.text$mn:00005BA8
.text$mn:00005BA8 ; int __stdcall std::_Vector_const_iterator<std::_Vector_val<std::_Simple_types<wchar_t>>>::_Vector_const_iterator<std::_Vector_val<std::_Simple_types<wchar_t>>>(int, struct std::_Container_base12 *)
.text$mn:00005BA8                 public ??0?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@_W@std@@@std@@@std@@QAE@PA_WPBU_Container_base12@1@@Z
.text$mn:00005BA8 ??0?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@_W@std@@@std@@@std@@QAE@PA_WPBU_Container_base12@1@@Z proc near
.text$mn:00005BA8                                         ; CODE XREF: std::_Vector_iterator<std::_Vector_val<std::_Simple_types<wchar_t>>>::_Vector_iterator<std::_Vector_val<std::_Simple_types<wchar_t>>>(wchar_t *,std::_Container_base12 const *)+31p
.text$mn:00005BA8
.text$mn:00005BA8 var_10          = dword ptr -10h
.text$mn:00005BA8 var_C           = dword ptr -0Ch
.text$mn:00005BA8 var_4           = dword ptr -4
.text$mn:00005BA8 arg_0           = dword ptr  8
.text$mn:00005BA8 arg_4           = dword ptr  0Ch
.text$mn:00005BA8
.text$mn:00005BA8                 push    ebp
.text$mn:00005BA9                 mov     ebp, esp
.text$mn:00005BAB                 push    0FFFFFFFFh
.text$mn:00005BAD                 push    offset __ehhandler$??0?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@_W@std@@@std@@@std@@QAE@PA_WPBU_Container_base12@1@@Z
.text$mn:00005BB2                 mov     eax, large fs:0
.text$mn:00005BB8                 push    eax
.text$mn:00005BB9                 push    ecx
.text$mn:00005BBA                 mov     eax, dword ptr ds:___security_cookie
.text$mn:00005BBF                 xor     eax, ebp
.text$mn:00005BC1                 push    eax
.text$mn:00005BC2                 lea     eax, [ebp+var_C]
.text$mn:00005BC5                 mov     large fs:0, eax
.text$mn:00005BCB                 mov     [ebp+var_10], ecx
.text$mn:00005BCE                 mov     ecx, [ebp+var_10]
.text$mn:00005BD1                 call    ??0?$_Iterator012@Urandom_access_iterator_tag@std@@_WHPB_WAB_WU_Iterator_base12@2@@std@@QAE@XZ ; std::_Iterator012<std::random_access_iterator_tag,wchar_t,int,wchar_t const *,wchar_t const &,std::_Iterator_base12>::_Iterator012<std::random_access_iterator_tag,wchar_t,int,wchar_t const *,wchar_t const &,std::_Iterator_base12>(void)
.text$mn:00005BD6                 mov     [ebp+var_4], 0
.text$mn:00005BDD                 mov     eax, [ebp+var_10]
.text$mn:00005BE0                 mov     ecx, [ebp+arg_0]
.text$mn:00005BE3                 mov     [eax+8], ecx
.text$mn:00005BE6                 mov     edx, [ebp+arg_4]
.text$mn:00005BE9                 push    edx             ; struct std::_Container_base12 *
.text$mn:00005BEA                 mov     ecx, [ebp+var_10] ; this
.text$mn:00005BED                 call    ?_Adopt@_Iterator_base12@std@@QAEXPBU_Container_base12@2@@Z ; std::_Iterator_base12::_Adopt(std::_Container_base12 const *)
.text$mn:00005BF2                 mov     [ebp+var_4], 0FFFFFFFFh
.text$mn:00005BF9                 mov     eax, [ebp+var_10]
.text$mn:00005BFC                 mov     ecx, [ebp+var_C]
.text$mn:00005BFF                 mov     large fs:0, ecx
.text$mn:00005C06                 pop     ecx
.text$mn:00005C07                 mov     esp, ebp
.text$mn:00005C09                 pop     ebp
.text$mn:00005C0A                 retn    8
.text$mn:00005C0A ??0?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@_W@std@@@std@@@std@@QAE@PA_WPBU_Container_base12@1@@Z endp
.text$mn:00005C0A
.text$mn:00005C0A ; ---------------------------------------------------------------------------
.text$mn:00005C0D                 align 10h
.text$mn:00005C0D _text$mn        ends
.text$mn:00005C0D
.text$x:00005C10 ; ===========================================================================
.text$x:00005C10
.text$x:00005C10 ; Segment type: Pure code
.text$x:00005C10 ; Segment permissions: Read/Execute
.text$x:00005C10 _text$x         segment para public 'CODE' use32
.text$x:00005C10                 assume cs:_text$x
.text$x:00005C10                 ;org 5C10h
.text$x:00005C10 ; COMDAT (pick associative to section at 5BA8)
.text$x:00005C10                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text$x:00005C10
.text$x:00005C10 ; =============== S U B R O U T I N E =======================================
.text$x:00005C10
.text$x:00005C10
.text$x:00005C10 __unwindfunclet$??0?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@_W@std@@@std@@@std@@QAE@PA_WPBU_Container_base12@1@@Z$0 proc near
.text$x:00005C10                                         ; DATA XREF: .xdata$x:0000E838o
.text$x:00005C10                 mov     ecx, [ebp-10h]
.text$x:00005C13                 jmp     ??1?$_Iterator012@Urandom_access_iterator_tag@std@@_WHPB_WAB_WU_Iterator_base12@2@@std@@QAE@XZ ; std::_Iterator012<std::random_access_iterator_tag,wchar_t,int,wchar_t const *,wchar_t const &,std::_Iterator_base12>::~_Iterator012<std::random_access_iterator_tag,wchar_t,int,wchar_t const *,wchar_t const &,std::_Iterator_base12>(void)
.text$x:00005C13 __unwindfunclet$??0?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@_W@std@@@std@@@std@@QAE@PA_WPBU_Container_base12@1@@Z$0 endp
.text$x:00005C13
.text$x:00005C18
.text$x:00005C18 ; =============== S U B R O U T I N E =======================================
.text$x:00005C18
.text$x:00005C18
.text$x:00005C18 __ehhandler$??0?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@_W@std@@@std@@@std@@QAE@PA_WPBU_Container_base12@1@@Z proc near
.text$x:00005C18                                         ; DATA XREF: std::_Vector_const_iterator<std::_Vector_val<std::_Simple_types<wchar_t>>>::_Vector_const_iterator<std::_Vector_val<std::_Simple_types<wchar_t>>>(wchar_t *,std::_Container_base12 const *)+5o
.text$x:00005C18
.text$x:00005C18 arg_4           = dword ptr  8
.text$x:00005C18
.text$x:00005C18                 mov     edx, [esp+arg_4]
.text$x:00005C1C                 lea     eax, [edx+0Ch]
.text$x:00005C1F                 mov     ecx, [edx-8]
.text$x:00005C22                 xor     ecx, eax
.text$x:00005C24                 call    @__security_check_cookie@4 ; __security_check_cookie(x)
.text$x:00005C29                 mov     eax, offset __ehfuncinfo$??0?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@_W@std@@@std@@@std@@QAE@PA_WPBU_Container_base12@1@@Z
.text$x:00005C2E                 jmp     ___CxxFrameHandler3
.text$x:00005C2E __ehhandler$??0?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@_W@std@@@std@@@std@@QAE@PA_WPBU_Container_base12@1@@Z endp
.text$x:00005C2E
.text$x:00005C2E ; ---------------------------------------------------------------------------
.text$x:00005C33                 align 4
.text$x:00005C33 _text$x         ends
.text$x:00005C33
.text$mn:00005C34 ; ===========================================================================
.text$mn:00005C34
.text$mn:00005C34 ; Segment type: Pure code
.text$mn:00005C34 ; Segment permissions: Read/Execute
.text$mn:00005C34 _text$mn        segment para public 'CODE' use32
.text$mn:00005C34                 assume cs:_text$mn
.text$mn:00005C34                 ;org 5C34h
.text$mn:00005C34 ; COMDAT (pick any)
.text$mn:00005C34                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text$mn:00005C34
.text$mn:00005C34 ; =============== S U B R O U T I N E =======================================
.text$mn:00005C34
.text$mn:00005C34 ; Attributes: bp-based frame
.text$mn:00005C34
.text$mn:00005C34 ; int __stdcall std::_Vector_iterator<std::_Vector_val<std::_Simple_types<wchar_t>>>::_Vector_iterator<std::_Vector_val<std::_Simple_types<wchar_t>>>(struct std::_Iterator_base12 *)
.text$mn:00005C34                 public ??0?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@_W@std@@@std@@@std@@QAE@ABV01@@Z
.text$mn:00005C34 ??0?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@_W@std@@@std@@@std@@QAE@ABV01@@Z proc near
.text$mn:00005C34                                         ; CODE XREF: convertFileName<std::_Vector_iterator<std::_Vector_val<std::_Simple_types<wchar_t>>>>(std::_Vector_iterator<std::_Vector_val<std::_Simple_types<wchar_t>>>,std::_Vector_iterator<std::_Vector_val<std::_Simple_types<wchar_t>>>)+49p
.text$mn:00005C34                                         ; std::_Revranit<std::_Vector_iterator<std::_Vector_val<std::_Simple_types<wchar_t>>>,std::iterator<std::random_access_iterator_tag,wchar_t,int,wchar_t *,wchar_t &>>::_Revranit<std::_Vector_iterator<std::_Vector_val<std::_Simple_types<wchar_t>>>,std::iterator<std::random_access_iterator_tag,wchar_t,int,wchar_t *,wchar_t &>>(std::_Revranit<std::_Vector_iterator<std::_Vector_val<std::_Simple_types<wchar_t>>>,std::iterator<std::random_access_iterator_tag,wchar_t,int,wchar_t *,wchar_t &>> const &)+2Dp ...
.text$mn:00005C34
.text$mn:00005C34 var_10          = dword ptr -10h
.text$mn:00005C34 var_C           = dword ptr -0Ch
.text$mn:00005C34 var_4           = dword ptr -4
.text$mn:00005C34 arg_0           = dword ptr  8
.text$mn:00005C34
.text$mn:00005C34                 push    ebp
.text$mn:00005C35                 mov     ebp, esp
.text$mn:00005C37                 push    0FFFFFFFFh
.text$mn:00005C39                 push    offset __ehhandler$??0?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@_W@std@@@std@@@std@@QAE@ABV01@@Z
.text$mn:00005C3E                 mov     eax, large fs:0
.text$mn:00005C44                 push    eax
.text$mn:00005C45                 push    ecx
.text$mn:00005C46                 mov     eax, dword ptr ds:___security_cookie
.text$mn:00005C4B                 xor     eax, ebp
.text$mn:00005C4D                 push    eax
.text$mn:00005C4E                 lea     eax, [ebp+var_C]
.text$mn:00005C51                 mov     large fs:0, eax
.text$mn:00005C57                 mov     [ebp+var_10], ecx
.text$mn:00005C5A                 mov     eax, [ebp+arg_0]
.text$mn:00005C5D                 push    eax             ; struct std::_Iterator_base12 *
.text$mn:00005C5E                 mov     ecx, [ebp+var_10]
.text$mn:00005C61                 call    ??0?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@_W@std@@@std@@@std@@QAE@ABV01@@Z ; std::_Vector_const_iterator<std::_Vector_val<std::_Simple_types<wchar_t>>>::_Vector_const_iterator<std::_Vector_val<std::_Simple_types<wchar_t>>>(std::_Vector_const_iterator<std::_Vector_val<std::_Simple_types<wchar_t>>> const &)
.text$mn:00005C66                 mov     [ebp+var_4], 0
.text$mn:00005C6D                 mov     [ebp+var_4], 0FFFFFFFFh
.text$mn:00005C74                 mov     eax, [ebp+var_10]
.text$mn:00005C77                 mov     ecx, [ebp+var_C]
.text$mn:00005C7A                 mov     large fs:0, ecx
.text$mn:00005C81                 pop     ecx
.text$mn:00005C82                 mov     esp, ebp
.text$mn:00005C84                 pop     ebp
.text$mn:00005C85                 retn    4
.text$mn:00005C85 ??0?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@_W@std@@@std@@@std@@QAE@ABV01@@Z endp
.text$mn:00005C85
.text$mn:00005C85 _text$mn        ends
.text$mn:00005C85
.text$x:00005C88 ; ===========================================================================
.text$x:00005C88
.text$x:00005C88 ; Segment type: Pure code
.text$x:00005C88 ; Segment permissions: Read/Execute
.text$x:00005C88 _text$x         segment para public 'CODE' use32
.text$x:00005C88                 assume cs:_text$x
.text$x:00005C88                 ;org 5C88h
.text$x:00005C88 ; COMDAT (pick associative to section at 5C34)
.text$x:00005C88                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text$x:00005C88
.text$x:00005C88 ; =============== S U B R O U T I N E =======================================
.text$x:00005C88
.text$x:00005C88
.text$x:00005C88 __unwindfunclet$??0?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@_W@std@@@std@@@std@@QAE@ABV01@@Z$0 proc near
.text$x:00005C88                                         ; DATA XREF: .xdata$x:0000E948o
.text$x:00005C88                 mov     ecx, [ebp-10h]
.text$x:00005C8B                 jmp     ??1?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@_W@std@@@std@@@std@@QAE@XZ ; std::_Vector_const_iterator<std::_Vector_val<std::_Simple_types<wchar_t>>>::~_Vector_const_iterator<std::_Vector_val<std::_Simple_types<wchar_t>>>(void)
.text$x:00005C8B __unwindfunclet$??0?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@_W@std@@@std@@@std@@QAE@ABV01@@Z$0 endp
.text$x:00005C8B
.text$x:00005C90
.text$x:00005C90 ; =============== S U B R O U T I N E =======================================
.text$x:00005C90
.text$x:00005C90
.text$x:00005C90 __ehhandler$??0?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@_W@std@@@std@@@std@@QAE@ABV01@@Z proc near
.text$x:00005C90                                         ; DATA XREF: std::_Vector_iterator<std::_Vector_val<std::_Simple_types<wchar_t>>>::_Vector_iterator<std::_Vector_val<std::_Simple_types<wchar_t>>>(std::_Vector_iterator<std::_Vector_val<std::_Simple_types<wchar_t>>> const &)+5o
.text$x:00005C90
.text$x:00005C90 arg_4           = dword ptr  8
.text$x:00005C90
.text$x:00005C90                 mov     edx, [esp+arg_4]
.text$x:00005C94                 lea     eax, [edx+0Ch]
.text$x:00005C97                 mov     ecx, [edx-8]
.text$x:00005C9A                 xor     ecx, eax
.text$x:00005C9C                 call    @__security_check_cookie@4 ; __security_check_cookie(x)
.text$x:00005CA1                 mov     eax, offset __ehfuncinfo$??0?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@_W@std@@@std@@@std@@QAE@ABV01@@Z
.text$x:00005CA6                 jmp     ___CxxFrameHandler3
.text$x:00005CA6 __ehhandler$??0?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@_W@std@@@std@@@std@@QAE@ABV01@@Z endp
.text$x:00005CA6
.text$x:00005CA6 ; ---------------------------------------------------------------------------
.text$x:00005CAB                 align 4
.text$x:00005CAB _text$x         ends
.text$x:00005CAB
.text$mn:00005CAC ; ===========================================================================
.text$mn:00005CAC
.text$mn:00005CAC ; Segment type: Pure code
.text$mn:00005CAC ; Segment permissions: Read/Execute
.text$mn:00005CAC _text$mn        segment para public 'CODE' use32
.text$mn:00005CAC                 assume cs:_text$mn
.text$mn:00005CAC                 ;org 5CACh
.text$mn:00005CAC ; COMDAT (pick any)
.text$mn:00005CAC                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text$mn:00005CAC
.text$mn:00005CAC ; =============== S U B R O U T I N E =======================================
.text$mn:00005CAC
.text$mn:00005CAC ; Attributes: bp-based frame
.text$mn:00005CAC
.text$mn:00005CAC ; int __stdcall std::_Vector_iterator<std::_Vector_val<std::_Simple_types<wchar_t>>>::_Vector_iterator<std::_Vector_val<std::_Simple_types<wchar_t>>>(int, struct std::_Container_base12 *)
.text$mn:00005CAC                 public ??0?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@_W@std@@@std@@@std@@QAE@PA_WPBU_Container_base12@1@@Z
.text$mn:00005CAC ??0?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@_W@std@@@std@@@std@@QAE@PA_WPBU_Container_base12@1@@Z proc near
.text$mn:00005CAC                                         ; CODE XREF: std::vector<wchar_t,std::allocator<wchar_t>>::begin(void)+3Dp
.text$mn:00005CAC                                         ; std::vector<wchar_t,std::allocator<wchar_t>>::end(void)+3Dp
.text$mn:00005CAC
.text$mn:00005CAC var_10          = dword ptr -10h
.text$mn:00005CAC var_C           = dword ptr -0Ch
.text$mn:00005CAC var_4           = dword ptr -4
.text$mn:00005CAC arg_0           = dword ptr  8
.text$mn:00005CAC arg_4           = dword ptr  0Ch
.text$mn:00005CAC
.text$mn:00005CAC                 push    ebp
.text$mn:00005CAD                 mov     ebp, esp
.text$mn:00005CAF                 push    0FFFFFFFFh
.text$mn:00005CB1                 push    offset __ehhandler$??0?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@_W@std@@@std@@@std@@QAE@PA_WPBU_Container_base12@1@@Z
.text$mn:00005CB6                 mov     eax, large fs:0
.text$mn:00005CBC                 push    eax
.text$mn:00005CBD                 push    ecx
.text$mn:00005CBE                 mov     eax, dword ptr ds:___security_cookie
.text$mn:00005CC3                 xor     eax, ebp
.text$mn:00005CC5                 push    eax
.text$mn:00005CC6                 lea     eax, [ebp+var_C]
.text$mn:00005CC9                 mov     large fs:0, eax
.text$mn:00005CCF                 mov     [ebp+var_10], ecx
.text$mn:00005CD2                 mov     eax, [ebp+arg_4]
.text$mn:00005CD5                 push    eax             ; struct std::_Container_base12 *
.text$mn:00005CD6                 mov     ecx, [ebp+arg_0]
.text$mn:00005CD9                 push    ecx             ; int
.text$mn:00005CDA                 mov     ecx, [ebp+var_10]
.text$mn:00005CDD                 call    ??0?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@_W@std@@@std@@@std@@QAE@PA_WPBU_Container_base12@1@@Z ; std::_Vector_const_iterator<std::_Vector_val<std::_Simple_types<wchar_t>>>::_Vector_const_iterator<std::_Vector_val<std::_Simple_types<wchar_t>>>(wchar_t *,std::_Container_base12 const *)
.text$mn:00005CE2                 mov     [ebp+var_4], 0
.text$mn:00005CE9                 mov     [ebp+var_4], 0FFFFFFFFh
.text$mn:00005CF0                 mov     eax, [ebp+var_10]
.text$mn:00005CF3                 mov     ecx, [ebp+var_C]
.text$mn:00005CF6                 mov     large fs:0, ecx
.text$mn:00005CFD                 pop     ecx
.text$mn:00005CFE                 mov     esp, ebp
.text$mn:00005D00                 pop     ebp
.text$mn:00005D01                 retn    8
.text$mn:00005D01 ??0?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@_W@std@@@std@@@std@@QAE@PA_WPBU_Container_base12@1@@Z endp
.text$mn:00005D01
.text$mn:00005D01 _text$mn        ends
.text$mn:00005D01
.text$x:00005D04 ; ===========================================================================
.text$x:00005D04
.text$x:00005D04 ; Segment type: Pure code
.text$x:00005D04 ; Segment permissions: Read/Execute
.text$x:00005D04 _text$x         segment para public 'CODE' use32
.text$x:00005D04                 assume cs:_text$x
.text$x:00005D04                 ;org 5D04h
.text$x:00005D04 ; COMDAT (pick associative to section at 5CAC)
.text$x:00005D04                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text$x:00005D04
.text$x:00005D04 ; =============== S U B R O U T I N E =======================================
.text$x:00005D04
.text$x:00005D04
.text$x:00005D04 __unwindfunclet$??0?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@_W@std@@@std@@@std@@QAE@PA_WPBU_Container_base12@1@@Z$0 proc near
.text$x:00005D04                                         ; DATA XREF: .xdata$x:0000E8BCo
.text$x:00005D04                 mov     ecx, [ebp-10h]
.text$x:00005D07                 jmp     ??1?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@_W@std@@@std@@@std@@QAE@XZ ; std::_Vector_const_iterator<std::_Vector_val<std::_Simple_types<wchar_t>>>::~_Vector_const_iterator<std::_Vector_val<std::_Simple_types<wchar_t>>>(void)
.text$x:00005D07 __unwindfunclet$??0?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@_W@std@@@std@@@std@@QAE@PA_WPBU_Container_base12@1@@Z$0 endp
.text$x:00005D07
.text$x:00005D0C
.text$x:00005D0C ; =============== S U B R O U T I N E =======================================
.text$x:00005D0C
.text$x:00005D0C
.text$x:00005D0C __ehhandler$??0?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@_W@std@@@std@@@std@@QAE@PA_WPBU_Container_base12@1@@Z proc near
.text$x:00005D0C                                         ; DATA XREF: std::_Vector_iterator<std::_Vector_val<std::_Simple_types<wchar_t>>>::_Vector_iterator<std::_Vector_val<std::_Simple_types<wchar_t>>>(wchar_t *,std::_Container_base12 const *)+5o
.text$x:00005D0C
.text$x:00005D0C arg_4           = dword ptr  8
.text$x:00005D0C
.text$x:00005D0C                 mov     edx, [esp+arg_4]
.text$x:00005D10                 lea     eax, [edx+0Ch]
.text$x:00005D13                 mov     ecx, [edx-8]
.text$x:00005D16                 xor     ecx, eax
.text$x:00005D18                 call    @__security_check_cookie@4 ; __security_check_cookie(x)
.text$x:00005D1D                 mov     eax, offset __ehfuncinfo$??0?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@_W@std@@@std@@@std@@QAE@PA_WPBU_Container_base12@1@@Z
.text$x:00005D22                 jmp     ___CxxFrameHandler3
.text$x:00005D22 __ehhandler$??0?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@_W@std@@@std@@@std@@QAE@PA_WPBU_Container_base12@1@@Z endp
.text$x:00005D22
.text$x:00005D22 ; ---------------------------------------------------------------------------
.text$x:00005D27                 align 4
.text$x:00005D27 _text$x         ends
.text$x:00005D27
.text$mn:00005D28 ; ===========================================================================
.text$mn:00005D28
.text$mn:00005D28 ; Segment type: Pure code
.text$mn:00005D28 ; Segment permissions: Read/Execute
.text$mn:00005D28 _text$mn        segment para public 'CODE' use32
.text$mn:00005D28                 assume cs:_text$mn
.text$mn:00005D28                 ;org 5D28h
.text$mn:00005D28 ; COMDAT (pick any)
.text$mn:00005D28                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text$mn:00005D28
.text$mn:00005D28 ; =============== S U B R O U T I N E =======================================
.text$mn:00005D28
.text$mn:00005D28 ; Attributes: bp-based frame
.text$mn:00005D28
.text$mn:00005D28 ; public: __thiscall std::_Vector_val<struct std::_Simple_types<char>>::_Vector_val<struct std::_Simple_types<char>>(void)
.text$mn:00005D28                 public ??0?$_Vector_val@U?$_Simple_types@D@std@@@std@@QAE@XZ
.text$mn:00005D28 ??0?$_Vector_val@U?$_Simple_types@D@std@@@std@@QAE@XZ proc near
.text$mn:00005D28                                         ; CODE XREF: std::_Vector_alloc<0,std::_Vec_base_types<char,std::allocator<char>>>::_Vector_alloc<0,std::_Vec_base_types<char,std::allocator<char>>>(std::allocator<char> const &)+29p
.text$mn:00005D28
.text$mn:00005D28 var_10          = dword ptr -10h
.text$mn:00005D28 var_C           = dword ptr -0Ch
.text$mn:00005D28 var_4           = dword ptr -4
.text$mn:00005D28
.text$mn:00005D28                 push    ebp
.text$mn:00005D29                 mov     ebp, esp
.text$mn:00005D2B                 push    0FFFFFFFFh
.text$mn:00005D2D                 push    offset __ehhandler$??0?$_Vector_val@U?$_Simple_types@D@std@@@std@@QAE@XZ
.text$mn:00005D32                 mov     eax, large fs:0
.text$mn:00005D38                 push    eax
.text$mn:00005D39                 push    ecx
.text$mn:00005D3A                 mov     eax, dword ptr ds:___security_cookie
.text$mn:00005D3F                 xor     eax, ebp
.text$mn:00005D41                 push    eax
.text$mn:00005D42                 lea     eax, [ebp+var_C]
.text$mn:00005D45                 mov     large fs:0, eax
.text$mn:00005D4B                 mov     [ebp+var_10], ecx
.text$mn:00005D4E                 mov     ecx, [ebp+var_10] ; this
.text$mn:00005D51                 call    ??0_Container_base12@std@@QAE@XZ ; std::_Container_base12::_Container_base12(void)
.text$mn:00005D56                 mov     [ebp+var_4], 0
.text$mn:00005D5D                 mov     eax, [ebp+var_10]
.text$mn:00005D60                 mov     dword ptr [eax+4], 0
.text$mn:00005D67                 mov     ecx, [ebp+var_10]
.text$mn:00005D6A                 mov     dword ptr [ecx+8], 0
.text$mn:00005D71                 mov     edx, [ebp+var_10]
.text$mn:00005D74                 mov     dword ptr [edx+0Ch], 0
.text$mn:00005D7B                 mov     [ebp+var_4], 0FFFFFFFFh
.text$mn:00005D82                 mov     eax, [ebp+var_10]
.text$mn:00005D85                 mov     ecx, [ebp+var_C]
.text$mn:00005D88                 mov     large fs:0, ecx
.text$mn:00005D8F                 pop     ecx
.text$mn:00005D90                 mov     esp, ebp
.text$mn:00005D92                 pop     ebp
.text$mn:00005D93                 retn
.text$mn:00005D93 ??0?$_Vector_val@U?$_Simple_types@D@std@@@std@@QAE@XZ endp
.text$mn:00005D93
.text$mn:00005D93 _text$mn        ends
.text$mn:00005D93
.text$x:00005D94 ; ===========================================================================
.text$x:00005D94
.text$x:00005D94 ; Segment type: Pure code
.text$x:00005D94 ; Segment permissions: Read/Execute
.text$x:00005D94 _text$x         segment para public 'CODE' use32
.text$x:00005D94                 assume cs:_text$x
.text$x:00005D94                 ;org 5D94h
.text$x:00005D94 ; COMDAT (pick associative to section at 5D28)
.text$x:00005D94                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text$x:00005D94
.text$x:00005D94 ; =============== S U B R O U T I N E =======================================
.text$x:00005D94
.text$x:00005D94
.text$x:00005D94 __unwindfunclet$??0?$_Vector_val@U?$_Simple_types@D@std@@@std@@QAE@XZ$0 proc near
.text$x:00005D94                                         ; DATA XREF: .xdata$x:0000E678o
.text$x:00005D94                 mov     ecx, [ebp-10h]  ; this
.text$x:00005D97                 jmp     ??1_Container_base12@std@@QAE@XZ ; std::_Container_base12::~_Container_base12(void)
.text$x:00005D97 __unwindfunclet$??0?$_Vector_val@U?$_Simple_types@D@std@@@std@@QAE@XZ$0 endp
.text$x:00005D97
.text$x:00005D9C
.text$x:00005D9C ; =============== S U B R O U T I N E =======================================
.text$x:00005D9C
.text$x:00005D9C
.text$x:00005D9C __ehhandler$??0?$_Vector_val@U?$_Simple_types@D@std@@@std@@QAE@XZ proc near
.text$x:00005D9C                                         ; DATA XREF: std::_Vector_val<std::_Simple_types<char>>::_Vector_val<std::_Simple_types<char>>(void)+5o
.text$x:00005D9C
.text$x:00005D9C arg_4           = dword ptr  8
.text$x:00005D9C
.text$x:00005D9C                 mov     edx, [esp+arg_4]
.text$x:00005DA0                 lea     eax, [edx+0Ch]
.text$x:00005DA3                 mov     ecx, [edx-8]
.text$x:00005DA6                 xor     ecx, eax
.text$x:00005DA8                 call    @__security_check_cookie@4 ; __security_check_cookie(x)
.text$x:00005DAD                 mov     eax, offset __ehfuncinfo$??0?$_Vector_val@U?$_Simple_types@D@std@@@std@@QAE@XZ
.text$x:00005DB2                 jmp     ___CxxFrameHandler3
.text$x:00005DB2 __ehhandler$??0?$_Vector_val@U?$_Simple_types@D@std@@@std@@QAE@XZ endp
.text$x:00005DB2
.text$x:00005DB2 ; ---------------------------------------------------------------------------
.text$x:00005DB7                 align 4
.text$x:00005DB7 _text$x         ends
.text$x:00005DB7
.text$mn:00005DB8 ; ===========================================================================
.text$mn:00005DB8
.text$mn:00005DB8 ; Segment type: Pure code
.text$mn:00005DB8 ; Segment permissions: Read/Execute
.text$mn:00005DB8 _text$mn        segment para public 'CODE' use32
.text$mn:00005DB8                 assume cs:_text$mn
.text$mn:00005DB8                 ;org 5DB8h
.text$mn:00005DB8 ; COMDAT (pick any)
.text$mn:00005DB8                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text$mn:00005DB8
.text$mn:00005DB8 ; =============== S U B R O U T I N E =======================================
.text$mn:00005DB8
.text$mn:00005DB8 ; Attributes: bp-based frame
.text$mn:00005DB8
.text$mn:00005DB8 ; public: __thiscall std::_Vector_val<struct std::_Simple_types<class std::basic_string<wchar_t, struct std::char_traits<wchar_t>, class std::allocator<wchar_t>>>>::_Vector_val<struct std::_Simple_types<class std::basic_string<wchar_t, struct std::char_traits<wchar_t>, class std::allocator<wchar_t>>>>(void)
.text$mn:00005DB8                 public ??0?$_Vector_val@U?$_Simple_types@V?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@@std@@@std@@QAE@XZ
.text$mn:00005DB8 ??0?$_Vector_val@U?$_Simple_types@V?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@@std@@@std@@QAE@XZ proc near
.text$mn:00005DB8                                         ; CODE XREF: std::_Vector_alloc<0,std::_Vec_base_types<std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>>,std::allocator<std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>>>>>::_Vector_alloc<0,std::_Vec_base_types<std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>>,std::allocator<std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>>>>>(std::allocator<std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>>> const &)+29p
.text$mn:00005DB8
.text$mn:00005DB8 var_10          = dword ptr -10h
.text$mn:00005DB8 var_C           = dword ptr -0Ch
.text$mn:00005DB8 var_4           = dword ptr -4
.text$mn:00005DB8
.text$mn:00005DB8                 push    ebp
.text$mn:00005DB9                 mov     ebp, esp
.text$mn:00005DBB                 push    0FFFFFFFFh
.text$mn:00005DBD                 push    offset __ehhandler$??0?$_Vector_val@U?$_Simple_types@V?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@@std@@@std@@QAE@XZ
.text$mn:00005DC2                 mov     eax, large fs:0
.text$mn:00005DC8                 push    eax
.text$mn:00005DC9                 push    ecx
.text$mn:00005DCA                 mov     eax, dword ptr ds:___security_cookie
.text$mn:00005DCF                 xor     eax, ebp
.text$mn:00005DD1                 push    eax
.text$mn:00005DD2                 lea     eax, [ebp+var_C]
.text$mn:00005DD5                 mov     large fs:0, eax
.text$mn:00005DDB                 mov     [ebp+var_10], ecx
.text$mn:00005DDE                 mov     ecx, [ebp+var_10] ; this
.text$mn:00005DE1                 call    ??0_Container_base12@std@@QAE@XZ ; std::_Container_base12::_Container_base12(void)
.text$mn:00005DE6                 mov     [ebp+var_4], 0
.text$mn:00005DED                 mov     eax, [ebp+var_10]
.text$mn:00005DF0                 mov     dword ptr [eax+4], 0
.text$mn:00005DF7                 mov     ecx, [ebp+var_10]
.text$mn:00005DFA                 mov     dword ptr [ecx+8], 0
.text$mn:00005E01                 mov     edx, [ebp+var_10]
.text$mn:00005E04                 mov     dword ptr [edx+0Ch], 0
.text$mn:00005E0B                 mov     [ebp+var_4], 0FFFFFFFFh
.text$mn:00005E12                 mov     eax, [ebp+var_10]
.text$mn:00005E15                 mov     ecx, [ebp+var_C]
.text$mn:00005E18                 mov     large fs:0, ecx
.text$mn:00005E1F                 pop     ecx
.text$mn:00005E20                 mov     esp, ebp
.text$mn:00005E22                 pop     ebp
.text$mn:00005E23                 retn
.text$mn:00005E23 ??0?$_Vector_val@U?$_Simple_types@V?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@@std@@@std@@QAE@XZ endp
.text$mn:00005E23
.text$mn:00005E23 _text$mn        ends
.text$mn:00005E23
.text$x:00005E24 ; ===========================================================================
.text$x:00005E24
.text$x:00005E24 ; Segment type: Pure code
.text$x:00005E24 ; Segment permissions: Read/Execute
.text$x:00005E24 _text$x         segment para public 'CODE' use32
.text$x:00005E24                 assume cs:_text$x
.text$x:00005E24                 ;org 5E24h
.text$x:00005E24 ; COMDAT (pick associative to section at 5DB8)
.text$x:00005E24                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text$x:00005E24
.text$x:00005E24 ; =============== S U B R O U T I N E =======================================
.text$x:00005E24
.text$x:00005E24
.text$x:00005E24 __unwindfunclet$??0?$_Vector_val@U?$_Simple_types@V?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@@std@@@std@@QAE@XZ$0 proc near
.text$x:00005E24                                         ; DATA XREF: .xdata$x:0000E204o
.text$x:00005E24                 mov     ecx, [ebp-10h]  ; this
.text$x:00005E27                 jmp     ??1_Container_base12@std@@QAE@XZ ; std::_Container_base12::~_Container_base12(void)
.text$x:00005E27 __unwindfunclet$??0?$_Vector_val@U?$_Simple_types@V?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@@std@@@std@@QAE@XZ$0 endp
.text$x:00005E27
.text$x:00005E2C
.text$x:00005E2C ; =============== S U B R O U T I N E =======================================
.text$x:00005E2C
.text$x:00005E2C
.text$x:00005E2C __ehhandler$??0?$_Vector_val@U?$_Simple_types@V?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@@std@@@std@@QAE@XZ proc near
.text$x:00005E2C                                         ; DATA XREF: std::_Vector_val<std::_Simple_types<std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>>>>::_Vector_val<std::_Simple_types<std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>>>>(void)+5o
.text$x:00005E2C
.text$x:00005E2C arg_4           = dword ptr  8
.text$x:00005E2C
.text$x:00005E2C                 mov     edx, [esp+arg_4]
.text$x:00005E30                 lea     eax, [edx+0Ch]
.text$x:00005E33                 mov     ecx, [edx-8]
.text$x:00005E36                 xor     ecx, eax
.text$x:00005E38                 call    @__security_check_cookie@4 ; __security_check_cookie(x)
.text$x:00005E3D                 mov     eax, offset __ehfuncinfo$??0?$_Vector_val@U?$_Simple_types@V?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@@std@@@std@@QAE@XZ
.text$x:00005E42                 jmp     ___CxxFrameHandler3
.text$x:00005E42 __ehhandler$??0?$_Vector_val@U?$_Simple_types@V?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@@std@@@std@@QAE@XZ endp
.text$x:00005E42
.text$x:00005E42 ; ---------------------------------------------------------------------------
.text$x:00005E47                 align 4
.text$x:00005E47 _text$x         ends
.text$x:00005E47
.text$mn:00005E48 ; ===========================================================================
.text$mn:00005E48
.text$mn:00005E48 ; Segment type: Pure code
.text$mn:00005E48 ; Segment permissions: Read/Execute
.text$mn:00005E48 _text$mn        segment para public 'CODE' use32
.text$mn:00005E48                 assume cs:_text$mn
.text$mn:00005E48                 ;org 5E48h
.text$mn:00005E48 ; COMDAT (pick any)
.text$mn:00005E48                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text$mn:00005E48
.text$mn:00005E48 ; =============== S U B R O U T I N E =======================================
.text$mn:00005E48
.text$mn:00005E48 ; Attributes: bp-based frame
.text$mn:00005E48
.text$mn:00005E48 ; public: __thiscall std::_Vector_val<struct std::_Simple_types<wchar_t>>::_Vector_val<struct std::_Simple_types<wchar_t>>(void)
.text$mn:00005E48                 public ??0?$_Vector_val@U?$_Simple_types@_W@std@@@std@@QAE@XZ
.text$mn:00005E48 ??0?$_Vector_val@U?$_Simple_types@_W@std@@@std@@QAE@XZ proc near
.text$mn:00005E48                                         ; CODE XREF: std::_Vector_alloc<0,std::_Vec_base_types<wchar_t,std::allocator<wchar_t>>>::_Vector_alloc<0,std::_Vec_base_types<wchar_t,std::allocator<wchar_t>>>(std::allocator<wchar_t> const &)+29p
.text$mn:00005E48
.text$mn:00005E48 var_10          = dword ptr -10h
.text$mn:00005E48 var_C           = dword ptr -0Ch
.text$mn:00005E48 var_4           = dword ptr -4
.text$mn:00005E48
.text$mn:00005E48                 push    ebp
.text$mn:00005E49                 mov     ebp, esp
.text$mn:00005E4B                 push    0FFFFFFFFh
.text$mn:00005E4D                 push    offset __ehhandler$??0?$_Vector_val@U?$_Simple_types@_W@std@@@std@@QAE@XZ
.text$mn:00005E52                 mov     eax, large fs:0
.text$mn:00005E58                 push    eax
.text$mn:00005E59                 push    ecx
.text$mn:00005E5A                 mov     eax, dword ptr ds:___security_cookie
.text$mn:00005E5F                 xor     eax, ebp
.text$mn:00005E61                 push    eax
.text$mn:00005E62                 lea     eax, [ebp+var_C]
.text$mn:00005E65                 mov     large fs:0, eax
.text$mn:00005E6B                 mov     [ebp+var_10], ecx
.text$mn:00005E6E                 mov     ecx, [ebp+var_10] ; this
.text$mn:00005E71                 call    ??0_Container_base12@std@@QAE@XZ ; std::_Container_base12::_Container_base12(void)
.text$mn:00005E76                 mov     [ebp+var_4], 0
.text$mn:00005E7D                 mov     eax, [ebp+var_10]
.text$mn:00005E80                 mov     dword ptr [eax+4], 0
.text$mn:00005E87                 mov     ecx, [ebp+var_10]
.text$mn:00005E8A                 mov     dword ptr [ecx+8], 0
.text$mn:00005E91                 mov     edx, [ebp+var_10]
.text$mn:00005E94                 mov     dword ptr [edx+0Ch], 0
.text$mn:00005E9B                 mov     [ebp+var_4], 0FFFFFFFFh
.text$mn:00005EA2                 mov     eax, [ebp+var_10]
.text$mn:00005EA5                 mov     ecx, [ebp+var_C]
.text$mn:00005EA8                 mov     large fs:0, ecx
.text$mn:00005EAF                 pop     ecx
.text$mn:00005EB0                 mov     esp, ebp
.text$mn:00005EB2                 pop     ebp
.text$mn:00005EB3                 retn
.text$mn:00005EB3 ??0?$_Vector_val@U?$_Simple_types@_W@std@@@std@@QAE@XZ endp
.text$mn:00005EB3
.text$mn:00005EB3 _text$mn        ends
.text$mn:00005EB3
.text$x:00005EB4 ; ===========================================================================
.text$x:00005EB4
.text$x:00005EB4 ; Segment type: Pure code
.text$x:00005EB4 ; Segment permissions: Read/Execute
.text$x:00005EB4 _text$x         segment para public 'CODE' use32
.text$x:00005EB4                 assume cs:_text$x
.text$x:00005EB4                 ;org 5EB4h
.text$x:00005EB4 ; COMDAT (pick associative to section at 5E48)
.text$x:00005EB4                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text$x:00005EB4
.text$x:00005EB4 ; =============== S U B R O U T I N E =======================================
.text$x:00005EB4
.text$x:00005EB4
.text$x:00005EB4 __unwindfunclet$??0?$_Vector_val@U?$_Simple_types@_W@std@@@std@@QAE@XZ$0 proc near
.text$x:00005EB4                                         ; DATA XREF: .xdata$x:0000E3BCo
.text$x:00005EB4                 mov     ecx, [ebp-10h]  ; this
.text$x:00005EB7                 jmp     ??1_Container_base12@std@@QAE@XZ ; std::_Container_base12::~_Container_base12(void)
.text$x:00005EB7 __unwindfunclet$??0?$_Vector_val@U?$_Simple_types@_W@std@@@std@@QAE@XZ$0 endp
.text$x:00005EB7
.text$x:00005EBC
.text$x:00005EBC ; =============== S U B R O U T I N E =======================================
.text$x:00005EBC
.text$x:00005EBC
.text$x:00005EBC __ehhandler$??0?$_Vector_val@U?$_Simple_types@_W@std@@@std@@QAE@XZ proc near
.text$x:00005EBC                                         ; DATA XREF: std::_Vector_val<std::_Simple_types<wchar_t>>::_Vector_val<std::_Simple_types<wchar_t>>(void)+5o
.text$x:00005EBC
.text$x:00005EBC arg_4           = dword ptr  8
.text$x:00005EBC
.text$x:00005EBC                 mov     edx, [esp+arg_4]
.text$x:00005EC0                 lea     eax, [edx+0Ch]
.text$x:00005EC3                 mov     ecx, [edx-8]
.text$x:00005EC6                 xor     ecx, eax
.text$x:00005EC8                 call    @__security_check_cookie@4 ; __security_check_cookie(x)
.text$x:00005ECD                 mov     eax, offset __ehfuncinfo$??0?$_Vector_val@U?$_Simple_types@_W@std@@@std@@QAE@XZ
.text$x:00005ED2                 jmp     ___CxxFrameHandler3
.text$x:00005ED2 __ehhandler$??0?$_Vector_val@U?$_Simple_types@_W@std@@@std@@QAE@XZ endp
.text$x:00005ED2
.text$x:00005ED2 ; ---------------------------------------------------------------------------
.text$x:00005ED7                 align 4
.text$x:00005ED7 _text$x         ends
.text$x:00005ED7
.text$mn:00005ED8 ; ===========================================================================
.text$mn:00005ED8
.text$mn:00005ED8 ; Segment type: Pure code
.text$mn:00005ED8 ; Segment permissions: Read/Execute
.text$mn:00005ED8 _text$mn        segment para public 'CODE' use32
.text$mn:00005ED8                 assume cs:_text$mn
.text$mn:00005ED8                 ;org 5ED8h
.text$mn:00005ED8 ; COMDAT (pick any)
.text$mn:00005ED8                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text$mn:00005ED8
.text$mn:00005ED8 ; =============== S U B R O U T I N E =======================================
.text$mn:00005ED8
.text$mn:00005ED8 ; Attributes: bp-based frame
.text$mn:00005ED8
.text$mn:00005ED8 ; public: __thiscall std::_Wrap_alloc<class std::allocator<char>>::_Wrap_alloc<class std::allocator<char>>(void)
.text$mn:00005ED8                 public ??0?$_Wrap_alloc@V?$allocator@D@std@@@std@@QAE@XZ
.text$mn:00005ED8 ??0?$_Wrap_alloc@V?$allocator@D@std@@@std@@QAE@XZ proc near
.text$mn:00005ED8                                         ; CODE XREF: std::_String_alloc<0,std::_String_base_types<char,std::allocator<char>>>::_Getal(void)+Ap
.text$mn:00005ED8                                         ; std::_Vector_alloc<0,std::_Vec_base_types<char,std::allocator<char>>>::_Getal(void)+Ap
.text$mn:00005ED8
.text$mn:00005ED8 var_4           = dword ptr -4
.text$mn:00005ED8
.text$mn:00005ED8                 push    ebp
.text$mn:00005ED9                 mov     ebp, esp
.text$mn:00005EDB                 push    ecx
.text$mn:00005EDC                 mov     [ebp+var_4], ecx
.text$mn:00005EDF                 mov     ecx, [ebp+var_4]
.text$mn:00005EE2                 call    ??0?$allocator@D@std@@QAE@XZ ; std::allocator<char>::allocator<char>(void)
.text$mn:00005EE7                 mov     eax, [ebp+var_4]
.text$mn:00005EEA                 mov     esp, ebp
.text$mn:00005EEC                 pop     ebp
.text$mn:00005EED                 retn
.text$mn:00005EED ??0?$_Wrap_alloc@V?$allocator@D@std@@@std@@QAE@XZ endp
.text$mn:00005EED
.text$mn:00005EED ; ---------------------------------------------------------------------------
.text$mn:00005EEE                 align 10h
.text$mn:00005EEE _text$mn        ends
.text$mn:00005EEE
.text$mn:00005EF0 ; ===========================================================================
.text$mn:00005EF0
.text$mn:00005EF0 ; Segment type: Pure code
.text$mn:00005EF0 ; Segment permissions: Read/Execute
.text$mn:00005EF0 _text$mn        segment para public 'CODE' use32
.text$mn:00005EF0                 assume cs:_text$mn
.text$mn:00005EF0                 ;org 5EF0h
.text$mn:00005EF0 ; COMDAT (pick any)
.text$mn:00005EF0                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text$mn:00005EF0
.text$mn:00005EF0 ; =============== S U B R O U T I N E =======================================
.text$mn:00005EF0
.text$mn:00005EF0 ; Attributes: bp-based frame
.text$mn:00005EF0
.text$mn:00005EF0 ; public: __thiscall std::_Wrap_alloc<class std::allocator<struct std::_Container_proxy>>::_Wrap_alloc<class std::allocator<struct std::_Container_proxy>>(void)
.text$mn:00005EF0                 public ??0?$_Wrap_alloc@V?$allocator@U_Container_proxy@std@@@std@@@std@@QAE@XZ
.text$mn:00005EF0 ??0?$_Wrap_alloc@V?$allocator@U_Container_proxy@std@@@std@@@std@@QAE@XZ proc near
.text$mn:00005EF0                                         ; CODE XREF: std::_Vector_alloc<0,std::_Vec_base_types<char,std::allocator<char>>>::_Alloc_proxy(void)+Cp
.text$mn:00005EF0                                         ; std::_Vector_alloc<0,std::_Vec_base_types<std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>>,std::allocator<std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>>>>>::_Alloc_proxy(void)+Cp ...
.text$mn:00005EF0
.text$mn:00005EF0 var_4           = dword ptr -4
.text$mn:00005EF0
.text$mn:00005EF0                 push    ebp
.text$mn:00005EF1                 mov     ebp, esp
.text$mn:00005EF3                 push    ecx
.text$mn:00005EF4                 mov     [ebp+var_4], ecx
.text$mn:00005EF7                 mov     ecx, [ebp+var_4]
.text$mn:00005EFA                 call    ??0?$allocator@U_Container_proxy@std@@@std@@QAE@XZ ; std::allocator<std::_Container_proxy>::allocator<std::_Container_proxy>(void)
.text$mn:00005EFF                 mov     eax, [ebp+var_4]
.text$mn:00005F02                 mov     esp, ebp
.text$mn:00005F04                 pop     ebp
.text$mn:00005F05                 retn
.text$mn:00005F05 ??0?$_Wrap_alloc@V?$allocator@U_Container_proxy@std@@@std@@@std@@QAE@XZ endp
.text$mn:00005F05
.text$mn:00005F05 ; ---------------------------------------------------------------------------
.text$mn:00005F06                 align 4
.text$mn:00005F06 _text$mn        ends
.text$mn:00005F06
.text$mn:00005F08 ; ===========================================================================
.text$mn:00005F08
.text$mn:00005F08 ; Segment type: Pure code
.text$mn:00005F08 ; Segment permissions: Read/Execute
.text$mn:00005F08 _text$mn        segment para public 'CODE' use32
.text$mn:00005F08                 assume cs:_text$mn
.text$mn:00005F08                 ;org 5F08h
.text$mn:00005F08 ; COMDAT (pick any)
.text$mn:00005F08                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text$mn:00005F08
.text$mn:00005F08 ; =============== S U B R O U T I N E =======================================
.text$mn:00005F08
.text$mn:00005F08 ; Attributes: bp-based frame
.text$mn:00005F08
.text$mn:00005F08 ; public: __thiscall std::_Wrap_alloc<class std::allocator<class std::basic_string<wchar_t, struct std::char_traits<wchar_t>, class std::allocator<wchar_t>>>>::_Wrap_alloc<class std::allocator<class std::basic_string<wchar_t, struct std::char_traits<wchar_t>, class std::allocator<wchar_t>>>>(void)
.text$mn:00005F08                 public ??0?$_Wrap_alloc@V?$allocator@V?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@@std@@@std@@QAE@XZ
.text$mn:00005F08 ??0?$_Wrap_alloc@V?$allocator@V?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@@std@@@std@@QAE@XZ proc near
.text$mn:00005F08                                         ; CODE XREF: std::_Vector_alloc<0,std::_Vec_base_types<std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>>,std::allocator<std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>>>>>::_Getal(void)+Ap
.text$mn:00005F08
.text$mn:00005F08 var_4           = dword ptr -4
.text$mn:00005F08
.text$mn:00005F08                 push    ebp
.text$mn:00005F09                 mov     ebp, esp
.text$mn:00005F0B                 push    ecx
.text$mn:00005F0C                 mov     [ebp+var_4], ecx
.text$mn:00005F0F                 mov     ecx, [ebp+var_4]
.text$mn:00005F12                 call    ??0?$allocator@V?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@@std@@QAE@XZ ; std::allocator<std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>>>::allocator<std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>>>(void)
.text$mn:00005F17                 mov     eax, [ebp+var_4]
.text$mn:00005F1A                 mov     esp, ebp
.text$mn:00005F1C                 pop     ebp
.text$mn:00005F1D                 retn
.text$mn:00005F1D ??0?$_Wrap_alloc@V?$allocator@V?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@@std@@@std@@QAE@XZ endp
.text$mn:00005F1D
.text$mn:00005F1D ; ---------------------------------------------------------------------------
.text$mn:00005F1E                 align 10h
.text$mn:00005F1E _text$mn        ends
.text$mn:00005F1E
.text$mn:00005F20 ; ===========================================================================
.text$mn:00005F20
.text$mn:00005F20 ; Segment type: Pure code
.text$mn:00005F20 ; Segment permissions: Read/Execute
.text$mn:00005F20 _text$mn        segment para public 'CODE' use32
.text$mn:00005F20                 assume cs:_text$mn
.text$mn:00005F20                 ;org 5F20h
.text$mn:00005F20 ; COMDAT (pick any)
.text$mn:00005F20                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text$mn:00005F20
.text$mn:00005F20 ; =============== S U B R O U T I N E =======================================
.text$mn:00005F20
.text$mn:00005F20 ; Attributes: bp-based frame
.text$mn:00005F20
.text$mn:00005F20 ; public: __thiscall std::_Wrap_alloc<class std::allocator<wchar_t>>::_Wrap_alloc<class std::allocator<wchar_t>>(class std::allocator<wchar_t> const &)
.text$mn:00005F20                 public ??0?$_Wrap_alloc@V?$allocator@_W@std@@@std@@QAE@ABV?$allocator@_W@1@@Z
.text$mn:00005F20 ??0?$_Wrap_alloc@V?$allocator@_W@std@@@std@@QAE@ABV?$allocator@_W@1@@Z proc near
.text$mn:00005F20                                         ; CODE XREF: std::_Wrap_alloc<std::allocator<wchar_t>>::select_on_container_copy_construction(void)+1Dp
.text$mn:00005F20
.text$mn:00005F20 var_4           = dword ptr -4
.text$mn:00005F20 arg_0           = dword ptr  8
.text$mn:00005F20
.text$mn:00005F20                 push    ebp
.text$mn:00005F21                 mov     ebp, esp
.text$mn:00005F23                 push    ecx
.text$mn:00005F24                 mov     [ebp+var_4], ecx
.text$mn:00005F27                 mov     eax, [ebp+arg_0]
.text$mn:00005F2A                 push    eax
.text$mn:00005F2B                 mov     ecx, [ebp+var_4]
.text$mn:00005F2E                 call    ??0?$allocator@_W@std@@QAE@ABV01@@Z ; std::allocator<wchar_t>::allocator<wchar_t>(std::allocator<wchar_t> const &)
.text$mn:00005F33                 mov     eax, [ebp+var_4]
.text$mn:00005F36                 mov     esp, ebp
.text$mn:00005F38                 pop     ebp
.text$mn:00005F39                 retn    4
.text$mn:00005F39 ??0?$_Wrap_alloc@V?$allocator@_W@std@@@std@@QAE@ABV?$allocator@_W@1@@Z endp
.text$mn:00005F39
.text$mn:00005F39 _text$mn        ends
.text$mn:00005F39
.text$mn:00005F3C ; ===========================================================================
.text$mn:00005F3C
.text$mn:00005F3C ; Segment type: Pure code
.text$mn:00005F3C ; Segment permissions: Read/Execute
.text$mn:00005F3C _text$mn        segment para public 'CODE' use32
.text$mn:00005F3C                 assume cs:_text$mn
.text$mn:00005F3C                 ;org 5F3Ch
.text$mn:00005F3C ; COMDAT (pick any)
.text$mn:00005F3C                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text$mn:00005F3C
.text$mn:00005F3C ; =============== S U B R O U T I N E =======================================
.text$mn:00005F3C
.text$mn:00005F3C ; Attributes: bp-based frame
.text$mn:00005F3C
.text$mn:00005F3C ; public: __thiscall std::_Wrap_alloc<class std::allocator<wchar_t>>::_Wrap_alloc<class std::allocator<wchar_t>>(void)
.text$mn:00005F3C                 public ??0?$_Wrap_alloc@V?$allocator@_W@std@@@std@@QAE@XZ
.text$mn:00005F3C ??0?$_Wrap_alloc@V?$allocator@_W@std@@@std@@QAE@XZ proc near
.text$mn:00005F3C                                         ; CODE XREF: std::_String_alloc<0,std::_String_base_types<wchar_t,std::allocator<wchar_t>>>::_Getal(void)+Ap
.text$mn:00005F3C                                         ; std::_Vector_alloc<0,std::_Vec_base_types<wchar_t,std::allocator<wchar_t>>>::_Getal(void)+Ap
.text$mn:00005F3C
.text$mn:00005F3C var_4           = dword ptr -4
.text$mn:00005F3C
.text$mn:00005F3C                 push    ebp
.text$mn:00005F3D                 mov     ebp, esp
.text$mn:00005F3F                 push    ecx
.text$mn:00005F40                 mov     [ebp+var_4], ecx
.text$mn:00005F43                 mov     ecx, [ebp+var_4]
.text$mn:00005F46                 call    ??0?$allocator@_W@std@@QAE@XZ ; std::allocator<wchar_t>::allocator<wchar_t>(void)
.text$mn:00005F4B                 mov     eax, [ebp+var_4]
.text$mn:00005F4E                 mov     esp, ebp
.text$mn:00005F50                 pop     ebp
.text$mn:00005F51                 retn
.text$mn:00005F51 ??0?$_Wrap_alloc@V?$allocator@_W@std@@@std@@QAE@XZ endp
.text$mn:00005F51
.text$mn:00005F51 ; ---------------------------------------------------------------------------
.text$mn:00005F52                 align 4
.text$mn:00005F52 _text$mn        ends
.text$mn:00005F52
.text$mn:00005F54 ; ===========================================================================
.text$mn:00005F54
.text$mn:00005F54 ; Segment type: Pure code
.text$mn:00005F54 ; Segment permissions: Read/Execute
.text$mn:00005F54 _text$mn        segment para public 'CODE' use32
.text$mn:00005F54                 assume cs:_text$mn
.text$mn:00005F54                 ;org 5F54h
.text$mn:00005F54 ; COMDAT (pick any)
.text$mn:00005F54                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text$mn:00005F54
.text$mn:00005F54 ; =============== S U B R O U T I N E =======================================
.text$mn:00005F54
.text$mn:00005F54 ; Attributes: bp-based frame
.text$mn:00005F54
.text$mn:00005F54 ; public: __thiscall std::allocator<char>::allocator<char>(void)
.text$mn:00005F54                 public ??0?$allocator@D@std@@QAE@XZ
.text$mn:00005F54 ??0?$allocator@D@std@@QAE@XZ proc near  ; CODE XREF: std::_Wrap_alloc<std::allocator<char>>::_Wrap_alloc<std::allocator<char>>(void)+Ap
.text$mn:00005F54                                         ; std::basic_string<char,std::char_traits<char>,std::allocator<char>>::basic_string<char,std::char_traits<char>,std::allocator<char>>(char const *)+2Bp ...
.text$mn:00005F54
.text$mn:00005F54 var_4           = dword ptr -4
.text$mn:00005F54
.text$mn:00005F54                 push    ebp
.text$mn:00005F55                 mov     ebp, esp
.text$mn:00005F57                 push    ecx
.text$mn:00005F58                 mov     [ebp+var_4], ecx
.text$mn:00005F5B                 mov     eax, [ebp+var_4]
.text$mn:00005F5E                 mov     esp, ebp
.text$mn:00005F60                 pop     ebp
.text$mn:00005F61                 retn
.text$mn:00005F61 ??0?$allocator@D@std@@QAE@XZ endp
.text$mn:00005F61
.text$mn:00005F61 ; ---------------------------------------------------------------------------
.text$mn:00005F62                 align 4
.text$mn:00005F62 _text$mn        ends
.text$mn:00005F62
.text$mn:00005F64 ; ===========================================================================
.text$mn:00005F64
.text$mn:00005F64 ; Segment type: Pure code
.text$mn:00005F64 ; Segment permissions: Read/Execute
.text$mn:00005F64 _text$mn        segment para public 'CODE' use32
.text$mn:00005F64                 assume cs:_text$mn
.text$mn:00005F64                 ;org 5F64h
.text$mn:00005F64 ; COMDAT (pick any)
.text$mn:00005F64                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text$mn:00005F64
.text$mn:00005F64 ; =============== S U B R O U T I N E =======================================
.text$mn:00005F64
.text$mn:00005F64 ; Attributes: bp-based frame
.text$mn:00005F64
.text$mn:00005F64 ; public: __thiscall std::allocator<struct std::_Container_proxy>::allocator<struct std::_Container_proxy>(void)
.text$mn:00005F64                 public ??0?$allocator@U_Container_proxy@std@@@std@@QAE@XZ
.text$mn:00005F64 ??0?$allocator@U_Container_proxy@std@@@std@@QAE@XZ proc near
.text$mn:00005F64                                         ; CODE XREF: std::_Wrap_alloc<std::allocator<std::_Container_proxy>>::_Wrap_alloc<std::allocator<std::_Container_proxy>>(void)+Ap
.text$mn:00005F64                                         ; std::_String_alloc<0,std::_String_base_types<char,std::allocator<char>>>::_Alloc_proxy(void)+Cp ...
.text$mn:00005F64
.text$mn:00005F64 var_4           = dword ptr -4
.text$mn:00005F64
.text$mn:00005F64                 push    ebp
.text$mn:00005F65                 mov     ebp, esp
.text$mn:00005F67                 push    ecx
.text$mn:00005F68                 mov     [ebp+var_4], ecx
.text$mn:00005F6B                 mov     eax, [ebp+var_4]
.text$mn:00005F6E                 mov     esp, ebp
.text$mn:00005F70                 pop     ebp
.text$mn:00005F71                 retn
.text$mn:00005F71 ??0?$allocator@U_Container_proxy@std@@@std@@QAE@XZ endp
.text$mn:00005F71
.text$mn:00005F71 ; ---------------------------------------------------------------------------
.text$mn:00005F72                 align 4
.text$mn:00005F72 _text$mn        ends
.text$mn:00005F72
.text$mn:00005F74 ; ===========================================================================
.text$mn:00005F74
.text$mn:00005F74 ; Segment type: Pure code
.text$mn:00005F74 ; Segment permissions: Read/Execute
.text$mn:00005F74 _text$mn        segment para public 'CODE' use32
.text$mn:00005F74                 assume cs:_text$mn
.text$mn:00005F74                 ;org 5F74h
.text$mn:00005F74 ; COMDAT (pick any)
.text$mn:00005F74                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text$mn:00005F74
.text$mn:00005F74 ; =============== S U B R O U T I N E =======================================
.text$mn:00005F74
.text$mn:00005F74 ; Attributes: bp-based frame
.text$mn:00005F74
.text$mn:00005F74 ; public: __thiscall std::allocator<class std::basic_string<wchar_t, struct std::char_traits<wchar_t>, class std::allocator<wchar_t>>>::allocator<class std::basic_string<wchar_t, struct std::char_traits<wchar_t>, class std::allocator<wchar_t>>>(void)
.text$mn:00005F74                 public ??0?$allocator@V?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@@std@@QAE@XZ
.text$mn:00005F74 ??0?$allocator@V?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@@std@@QAE@XZ proc near
.text$mn:00005F74                                         ; CODE XREF: std::_Wrap_alloc<std::allocator<std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>>>>::_Wrap_alloc<std::allocator<std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>>>>(void)+Ap
.text$mn:00005F74                                         ; std::vector<std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>>,std::allocator<std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>>>>::vector<std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>>,std::allocator<std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>>>>(void)+2Bp
.text$mn:00005F74
.text$mn:00005F74 var_4           = dword ptr -4
.text$mn:00005F74
.text$mn:00005F74                 push    ebp
.text$mn:00005F75                 mov     ebp, esp
.text$mn:00005F77                 push    ecx
.text$mn:00005F78                 mov     [ebp+var_4], ecx
.text$mn:00005F7B                 mov     eax, [ebp+var_4]
.text$mn:00005F7E                 mov     esp, ebp
.text$mn:00005F80                 pop     ebp
.text$mn:00005F81                 retn
.text$mn:00005F81 ??0?$allocator@V?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@@std@@QAE@XZ endp
.text$mn:00005F81
.text$mn:00005F81 ; ---------------------------------------------------------------------------
.text$mn:00005F82                 align 4
.text$mn:00005F82 _text$mn        ends
.text$mn:00005F82
.text$mn:00005F84 ; ===========================================================================
.text$mn:00005F84
.text$mn:00005F84 ; Segment type: Pure code
.text$mn:00005F84 ; Segment permissions: Read/Execute
.text$mn:00005F84 _text$mn        segment para public 'CODE' use32
.text$mn:00005F84                 assume cs:_text$mn
.text$mn:00005F84                 ;org 5F84h
.text$mn:00005F84 ; COMDAT (pick any)
.text$mn:00005F84                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text$mn:00005F84
.text$mn:00005F84 ; =============== S U B R O U T I N E =======================================
.text$mn:00005F84
.text$mn:00005F84 ; Attributes: bp-based frame
.text$mn:00005F84
.text$mn:00005F84 ; public: __thiscall std::allocator<wchar_t>::allocator<wchar_t>(class std::allocator<wchar_t> const &)
.text$mn:00005F84                 public ??0?$allocator@_W@std@@QAE@ABV01@@Z
.text$mn:00005F84 ??0?$allocator@_W@std@@QAE@ABV01@@Z proc near
.text$mn:00005F84                                         ; CODE XREF: std::operator==<std::allocator<wchar_t>,std::allocator<wchar_t>>(std::_Wrap_alloc<std::allocator<wchar_t>> const &,std::_Wrap_alloc<std::allocator<wchar_t>> const &)+Bp
.text$mn:00005F84                                         ; std::operator==<std::allocator<wchar_t>,std::allocator<wchar_t>>(std::_Wrap_alloc<std::allocator<wchar_t>> const &,std::_Wrap_alloc<std::allocator<wchar_t>> const &)+18p ...
.text$mn:00005F84
.text$mn:00005F84 var_4           = dword ptr -4
.text$mn:00005F84
.text$mn:00005F84                 push    ebp
.text$mn:00005F85                 mov     ebp, esp
.text$mn:00005F87                 push    ecx
.text$mn:00005F88                 mov     [ebp+var_4], ecx
.text$mn:00005F8B                 mov     eax, [ebp+var_4]
.text$mn:00005F8E                 mov     esp, ebp
.text$mn:00005F90                 pop     ebp
.text$mn:00005F91                 retn    4
.text$mn:00005F91 ??0?$allocator@_W@std@@QAE@ABV01@@Z endp
.text$mn:00005F91
.text$mn:00005F91 _text$mn        ends
.text$mn:00005F91
.text$mn:00005F94 ; ===========================================================================
.text$mn:00005F94
.text$mn:00005F94 ; Segment type: Pure code
.text$mn:00005F94 ; Segment permissions: Read/Execute
.text$mn:00005F94 _text$mn        segment para public 'CODE' use32
.text$mn:00005F94                 assume cs:_text$mn
.text$mn:00005F94                 ;org 5F94h
.text$mn:00005F94 ; COMDAT (pick any)
.text$mn:00005F94                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text$mn:00005F94
.text$mn:00005F94 ; =============== S U B R O U T I N E =======================================
.text$mn:00005F94
.text$mn:00005F94 ; Attributes: bp-based frame
.text$mn:00005F94
.text$mn:00005F94 ; public: __thiscall std::allocator<wchar_t>::allocator<wchar_t>(void)
.text$mn:00005F94                 public ??0?$allocator@_W@std@@QAE@XZ
.text$mn:00005F94 ??0?$allocator@_W@std@@QAE@XZ proc near ; CODE XREF: std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>>::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>>(std::reverse_iterator<std::_Vector_iterator<std::_Vector_val<std::_Simple_types<wchar_t>>>>,std::reverse_iterator<std::_Vector_iterator<std::_Vector_val<std::_Simple_types<wchar_t>>>>)+32p
.text$mn:00005F94                                         ; std::_Wrap_alloc<std::allocator<wchar_t>>::_Wrap_alloc<std::allocator<wchar_t>>(void)+Ap ...
.text$mn:00005F94
.text$mn:00005F94 var_4           = dword ptr -4
.text$mn:00005F94
.text$mn:00005F94                 push    ebp
.text$mn:00005F95                 mov     ebp, esp
.text$mn:00005F97                 push    ecx
.text$mn:00005F98                 mov     [ebp+var_4], ecx
.text$mn:00005F9B                 mov     eax, [ebp+var_4]
.text$mn:00005F9E                 mov     esp, ebp
.text$mn:00005FA0                 pop     ebp
.text$mn:00005FA1                 retn
.text$mn:00005FA1 ??0?$allocator@_W@std@@QAE@XZ endp
.text$mn:00005FA1
.text$mn:00005FA1 ; ---------------------------------------------------------------------------
.text$mn:00005FA2                 align 4
.text$mn:00005FA2 _text$mn        ends
.text$mn:00005FA2
.text$mn:00005FA4 ; ===========================================================================
.text$mn:00005FA4
.text$mn:00005FA4 ; Segment type: Pure code
.text$mn:00005FA4 ; Segment permissions: Read/Execute
.text$mn:00005FA4 _text$mn        segment para public 'CODE' use32
.text$mn:00005FA4                 assume cs:_text$mn
.text$mn:00005FA4                 ;org 5FA4h
.text$mn:00005FA4 ; COMDAT (pick any)
.text$mn:00005FA4                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text$mn:00005FA4
.text$mn:00005FA4 ; =============== S U B R O U T I N E =======================================
.text$mn:00005FA4
.text$mn:00005FA4 ; Attributes: bp-based frame
.text$mn:00005FA4
.text$mn:00005FA4 ; public: __thiscall std::basic_string<char, struct std::char_traits<char>, class std::allocator<char>>::basic_string<char, struct std::char_traits<char>, class std::allocator<char>>(class std::basic_string<char, struct std::char_traits<char>, class std::allocator<char>> &&)
.text$mn:00005FA4                 public ??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@$$QAV01@@Z
.text$mn:00005FA4 ??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@$$QAV01@@Z proc near
.text$mn:00005FA4                                         ; CODE XREF: getFileContent(wchar_t const *)+14Dp
.text$mn:00005FA4
.text$mn:00005FA4 var_14          = dword ptr -14h
.text$mn:00005FA4 var_D           = byte ptr -0Dh
.text$mn:00005FA4 var_C           = dword ptr -0Ch
.text$mn:00005FA4 var_4           = dword ptr -4
.text$mn:00005FA4 arg_0           = dword ptr  8
.text$mn:00005FA4
.text$mn:00005FA4                 push    ebp
.text$mn:00005FA5                 mov     ebp, esp
.text$mn:00005FA7                 push    0FFFFFFFFh
.text$mn:00005FA9                 push    offset __ehhandler$??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@$$QAV01@@Z
.text$mn:00005FAE                 mov     eax, large fs:0
.text$mn:00005FB4                 push    eax
.text$mn:00005FB5                 sub     esp, 8
.text$mn:00005FB8                 mov     eax, dword ptr ds:___security_cookie
.text$mn:00005FBD                 xor     eax, ebp
.text$mn:00005FBF                 push    eax
.text$mn:00005FC0                 lea     eax, [ebp+var_C]
.text$mn:00005FC3                 mov     large fs:0, eax
.text$mn:00005FC9                 mov     [ebp+var_14], ecx
.text$mn:00005FCC                 lea     eax, [ebp+var_D]
.text$mn:00005FCF                 push    eax
.text$mn:00005FD0                 mov     ecx, [ebp+arg_0]
.text$mn:00005FD3                 call    ?_Getal@?$_String_alloc@$0A@U?$_String_base_types@DV?$allocator@D@std@@@std@@@std@@QBE?AU?$_Wrap_alloc@V?$allocator@D@std@@@2@XZ ; std::_String_alloc<0,std::_String_base_types<char,std::allocator<char>>>::_Getal(void)
.text$mn:00005FD8                 push    eax
.text$mn:00005FD9                 mov     ecx, [ebp+var_14]
.text$mn:00005FDC                 call    ??0?$_String_alloc@$0A@U?$_String_base_types@DV?$allocator@D@std@@@std@@@std@@QAE@ABV?$allocator@D@1@@Z ; std::_String_alloc<0,std::_String_base_types<char,std::allocator<char>>>::_String_alloc<0,std::_String_base_types<char,std::allocator<char>>>(std::allocator<char> const &)
.text$mn:00005FE1                 mov     [ebp+var_4], 0
.text$mn:00005FE8                 push    0               ; Size
.text$mn:00005FEA                 push    0               ; char
.text$mn:00005FEC                 mov     ecx, [ebp+var_14]
.text$mn:00005FEF                 call    ?_Tidy@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEX_NI@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char>>::_Tidy(bool,uint)
.text$mn:00005FF4                 mov     ecx, [ebp+arg_0]
.text$mn:00005FF7                 push    ecx
.text$mn:00005FF8                 call    ??$forward@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@YA$$QAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@0@AAV10@@Z ; std::forward<std::basic_string<char,std::char_traits<char>,std::allocator<char>>>(std::basic_string<char,std::char_traits<char>,std::allocator<char>> &)
.text$mn:00005FFD                 add     esp, 4
.text$mn:00006000                 push    eax
.text$mn:00006001                 mov     ecx, [ebp+var_14]
.text$mn:00006004                 call    ?_Assign_rv@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEX$$QAV12@@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char>>::_Assign_rv(std::basic_string<char,std::char_traits<char>,std::allocator<char>> &&)
.text$mn:00006009                 mov     [ebp+var_4], 0FFFFFFFFh
.text$mn:00006010                 mov     eax, [ebp+var_14]
.text$mn:00006013                 mov     ecx, [ebp+var_C]
.text$mn:00006016                 mov     large fs:0, ecx
.text$mn:0000601D                 pop     ecx
.text$mn:0000601E                 mov     esp, ebp
.text$mn:00006020                 pop     ebp
.text$mn:00006021                 retn    4
.text$mn:00006021 ??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@$$QAV01@@Z endp
.text$mn:00006021
.text$mn:00006021 _text$mn        ends
.text$mn:00006021
.text$x:00006024 ; ===========================================================================
.text$x:00006024
.text$x:00006024 ; Segment type: Pure code
.text$x:00006024 ; Segment permissions: Read/Execute
.text$x:00006024 _text$x         segment para public 'CODE' use32
.text$x:00006024                 assume cs:_text$x
.text$x:00006024                 ;org 6024h
.text$x:00006024 ; COMDAT (pick associative to section at 5FA4)
.text$x:00006024                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text$x:00006024
.text$x:00006024 ; =============== S U B R O U T I N E =======================================
.text$x:00006024
.text$x:00006024
.text$x:00006024 __unwindfunclet$??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@$$QAV01@@Z$0 proc near
.text$x:00006024                                         ; DATA XREF: .xdata$x:0000D620o
.text$x:00006024                 mov     ecx, [ebp-14h]
.text$x:00006027                 jmp     ??1?$_String_alloc@$0A@U?$_String_base_types@DV?$allocator@D@std@@@std@@@std@@QAE@XZ ; std::_String_alloc<0,std::_String_base_types<char,std::allocator<char>>>::~_String_alloc<0,std::_String_base_types<char,std::allocator<char>>>(void)
.text$x:00006027 __unwindfunclet$??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@$$QAV01@@Z$0 endp
.text$x:00006027
.text$x:0000602C
.text$x:0000602C ; =============== S U B R O U T I N E =======================================
.text$x:0000602C
.text$x:0000602C
.text$x:0000602C __ehhandler$??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@$$QAV01@@Z proc near
.text$x:0000602C                                         ; DATA XREF: std::basic_string<char,std::char_traits<char>,std::allocator<char>>::basic_string<char,std::char_traits<char>,std::allocator<char>>(std::basic_string<char,std::char_traits<char>,std::allocator<char>> &&)+5o
.text$x:0000602C
.text$x:0000602C arg_4           = dword ptr  8
.text$x:0000602C
.text$x:0000602C                 mov     edx, [esp+arg_4]
.text$x:00006030                 lea     eax, [edx+0Ch]
.text$x:00006033                 mov     ecx, [edx-0Ch]
.text$x:00006036                 xor     ecx, eax
.text$x:00006038                 call    @__security_check_cookie@4 ; __security_check_cookie(x)
.text$x:0000603D                 mov     eax, offset __ehfuncinfo$??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@$$QAV01@@Z
.text$x:00006042                 jmp     ___CxxFrameHandler3
.text$x:00006042 __ehhandler$??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@$$QAV01@@Z endp
.text$x:00006042
.text$x:00006042 ; ---------------------------------------------------------------------------
.text$x:00006047                 align 4
.text$x:00006047 _text$x         ends
.text$x:00006047
.text$mn:00006048 ; ===========================================================================
.text$mn:00006048
.text$mn:00006048 ; Segment type: Pure code
.text$mn:00006048 ; Segment permissions: Read/Execute
.text$mn:00006048 _text$mn        segment para public 'CODE' use32
.text$mn:00006048                 assume cs:_text$mn
.text$mn:00006048                 ;org 6048h
.text$mn:00006048 ; COMDAT (pick any)
.text$mn:00006048                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text$mn:00006048
.text$mn:00006048 ; =============== S U B R O U T I N E =======================================
.text$mn:00006048
.text$mn:00006048 ; Attributes: bp-based frame
.text$mn:00006048
.text$mn:00006048 ; int __stdcall std::basic_string<char,std::char_traits<char>,std::allocator<char>>::basic_string<char,std::char_traits<char>,std::allocator<char>>(char *Str)
.text$mn:00006048                 public ??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@PBD@Z
.text$mn:00006048 ??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@PBD@Z proc near
.text$mn:00006048                                         ; CODE XREF: wstring2string(std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>> const &,uint)+9Fp
.text$mn:00006048                                         ; wstring2string(std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>> const &,uint)+C8p ...
.text$mn:00006048
.text$mn:00006048 var_14          = dword ptr -14h
.text$mn:00006048 var_D           = byte ptr -0Dh
.text$mn:00006048 var_C           = dword ptr -0Ch
.text$mn:00006048 var_4           = dword ptr -4
.text$mn:00006048 Str             = dword ptr  8
.text$mn:00006048
.text$mn:00006048                 push    ebp
.text$mn:00006049                 mov     ebp, esp
.text$mn:0000604B                 push    0FFFFFFFFh
.text$mn:0000604D                 push    offset __ehhandler$??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@PBD@Z
.text$mn:00006052                 mov     eax, large fs:0
.text$mn:00006058                 push    eax
.text$mn:00006059                 sub     esp, 8
.text$mn:0000605C                 mov     eax, dword ptr ds:___security_cookie
.text$mn:00006061                 xor     eax, ebp
.text$mn:00006063                 push    eax
.text$mn:00006064                 lea     eax, [ebp+var_C]
.text$mn:00006067                 mov     large fs:0, eax
.text$mn:0000606D                 mov     [ebp+var_14], ecx
.text$mn:00006070                 lea     ecx, [ebp+var_D]
.text$mn:00006073                 call    ??0?$allocator@D@std@@QAE@XZ ; std::allocator<char>::allocator<char>(void)
.text$mn:00006078                 push    eax
.text$mn:00006079                 mov     ecx, [ebp+var_14]
.text$mn:0000607C                 call    ??0?$_String_alloc@$0A@U?$_String_base_types@DV?$allocator@D@std@@@std@@@std@@QAE@ABV?$allocator@D@1@@Z ; std::_String_alloc<0,std::_String_base_types<char,std::allocator<char>>>::_String_alloc<0,std::_String_base_types<char,std::allocator<char>>>(std::allocator<char> const &)
.text$mn:00006081                 mov     [ebp+var_4], 0
.text$mn:00006088                 push    0               ; Size
.text$mn:0000608A                 push    0               ; char
.text$mn:0000608C                 mov     ecx, [ebp+var_14]
.text$mn:0000608F                 call    ?_Tidy@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEX_NI@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char>>::_Tidy(bool,uint)
.text$mn:00006094                 mov     eax, [ebp+Str]
.text$mn:00006097                 push    eax             ; Str
.text$mn:00006098                 mov     ecx, [ebp+var_14]
.text$mn:0000609B                 call    ?assign@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV12@PBD@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char>>::assign(char const *)
.text$mn:000060A0                 mov     [ebp+var_4], 0FFFFFFFFh
.text$mn:000060A7                 mov     eax, [ebp+var_14]
.text$mn:000060AA                 mov     ecx, [ebp+var_C]
.text$mn:000060AD                 mov     large fs:0, ecx
.text$mn:000060B4                 pop     ecx
.text$mn:000060B5                 mov     esp, ebp
.text$mn:000060B7                 pop     ebp
.text$mn:000060B8                 retn    4
.text$mn:000060B8 ??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@PBD@Z endp
.text$mn:000060B8
.text$mn:000060B8 ; ---------------------------------------------------------------------------
.text$mn:000060BB                 align 4
.text$mn:000060BB _text$mn        ends
.text$mn:000060BB
.text$x:000060BC ; ===========================================================================
.text$x:000060BC
.text$x:000060BC ; Segment type: Pure code
.text$x:000060BC ; Segment permissions: Read/Execute
.text$x:000060BC _text$x         segment para public 'CODE' use32
.text$x:000060BC                 assume cs:_text$x
.text$x:000060BC                 ;org 60BCh
.text$x:000060BC ; COMDAT (pick associative to section at 6048)
.text$x:000060BC                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text$x:000060BC
.text$x:000060BC ; =============== S U B R O U T I N E =======================================
.text$x:000060BC
.text$x:000060BC
.text$x:000060BC __unwindfunclet$??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@PBD@Z$0 proc near
.text$x:000060BC                                         ; DATA XREF: .xdata$x:0000D5F4o
.text$x:000060BC                 mov     ecx, [ebp-14h]
.text$x:000060BF                 jmp     ??1?$_String_alloc@$0A@U?$_String_base_types@DV?$allocator@D@std@@@std@@@std@@QAE@XZ ; std::_String_alloc<0,std::_String_base_types<char,std::allocator<char>>>::~_String_alloc<0,std::_String_base_types<char,std::allocator<char>>>(void)
.text$x:000060BF __unwindfunclet$??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@PBD@Z$0 endp
.text$x:000060BF
.text$x:000060C4
.text$x:000060C4 ; =============== S U B R O U T I N E =======================================
.text$x:000060C4
.text$x:000060C4
.text$x:000060C4 __ehhandler$??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@PBD@Z proc near
.text$x:000060C4                                         ; DATA XREF: std::basic_string<char,std::char_traits<char>,std::allocator<char>>::basic_string<char,std::char_traits<char>,std::allocator<char>>(char const *)+5o
.text$x:000060C4
.text$x:000060C4 arg_4           = dword ptr  8
.text$x:000060C4
.text$x:000060C4                 mov     edx, [esp+arg_4]
.text$x:000060C8                 lea     eax, [edx+0Ch]
.text$x:000060CB                 mov     ecx, [edx-0Ch]
.text$x:000060CE                 xor     ecx, eax
.text$x:000060D0                 call    @__security_check_cookie@4 ; __security_check_cookie(x)
.text$x:000060D5                 mov     eax, offset __ehfuncinfo$??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@PBD@Z
.text$x:000060DA                 jmp     ___CxxFrameHandler3
.text$x:000060DA __ehhandler$??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@PBD@Z endp
.text$x:000060DA
.text$x:000060DA ; ---------------------------------------------------------------------------
.text$x:000060DF                 align 10h
.text$x:000060DF _text$x         ends
.text$x:000060DF
.text$mn:000060E0 ; ===========================================================================
.text$mn:000060E0
.text$mn:000060E0 ; Segment type: Pure code
.text$mn:000060E0 ; Segment permissions: Read/Execute
.text$mn:000060E0 _text$mn        segment para public 'CODE' use32
.text$mn:000060E0                 assume cs:_text$mn
.text$mn:000060E0                 ;org 60E0h
.text$mn:000060E0 ; COMDAT (pick any)
.text$mn:000060E0                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text$mn:000060E0
.text$mn:000060E0 ; =============== S U B R O U T I N E =======================================
.text$mn:000060E0
.text$mn:000060E0 ; Attributes: bp-based frame
.text$mn:000060E0
.text$mn:000060E0 ; public: __thiscall std::basic_string<wchar_t, struct std::char_traits<wchar_t>, class std::allocator<wchar_t>>::basic_string<wchar_t, struct std::char_traits<wchar_t>, class std::allocator<wchar_t>>(class std::basic_string<wchar_t, struct std::char_traits<wchar_t>, class std::allocator<wchar_t>> &&)
.text$mn:000060E0                 public ??0?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QAE@$$QAV01@@Z
.text$mn:000060E0 ??0?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QAE@$$QAV01@@Z proc near
.text$mn:000060E0                                         ; CODE XREF: getFolderName(HWND__ *,wchar_t const *)+143p
.text$mn:000060E0                                         ; BuildMenuFileName(int,uint,std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>> const &)+544p ...
.text$mn:000060E0
.text$mn:000060E0 var_14          = dword ptr -14h
.text$mn:000060E0 var_D           = byte ptr -0Dh
.text$mn:000060E0 var_C           = dword ptr -0Ch
.text$mn:000060E0 var_4           = dword ptr -4
.text$mn:000060E0 arg_0           = dword ptr  8
.text$mn:000060E0
.text$mn:000060E0                 push    ebp
.text$mn:000060E1                 mov     ebp, esp
.text$mn:000060E3                 push    0FFFFFFFFh
.text$mn:000060E5                 push    offset __ehhandler$??0?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QAE@$$QAV01@@Z
.text$mn:000060EA                 mov     eax, large fs:0
.text$mn:000060F0                 push    eax
.text$mn:000060F1                 sub     esp, 8
.text$mn:000060F4                 mov     eax, dword ptr ds:___security_cookie
.text$mn:000060F9                 xor     eax, ebp
.text$mn:000060FB                 push    eax
.text$mn:000060FC                 lea     eax, [ebp+var_C]
.text$mn:000060FF                 mov     large fs:0, eax
.text$mn:00006105                 mov     [ebp+var_14], ecx
.text$mn:00006108                 lea     eax, [ebp+var_D]
.text$mn:0000610B                 push    eax
.text$mn:0000610C                 mov     ecx, [ebp+arg_0]
.text$mn:0000610F                 call    ?_Getal@?$_String_alloc@$0A@U?$_String_base_types@_WV?$allocator@_W@std@@@std@@@std@@QBE?AU?$_Wrap_alloc@V?$allocator@_W@std@@@2@XZ ; std::_String_alloc<0,std::_String_base_types<wchar_t,std::allocator<wchar_t>>>::_Getal(void)
.text$mn:00006114                 push    eax
.text$mn:00006115                 mov     ecx, [ebp+var_14]
.text$mn:00006118                 call    ??0?$_String_alloc@$0A@U?$_String_base_types@_WV?$allocator@_W@std@@@std@@@std@@QAE@ABV?$allocator@_W@1@@Z ; std::_String_alloc<0,std::_String_base_types<wchar_t,std::allocator<wchar_t>>>::_String_alloc<0,std::_String_base_types<wchar_t,std::allocator<wchar_t>>>(std::allocator<wchar_t> const &)
.text$mn:0000611D                 mov     [ebp+var_4], 0
.text$mn:00006124                 push    0
.text$mn:00006126                 push    0
.text$mn:00006128                 mov     ecx, [ebp+var_14]
.text$mn:0000612B                 call    ?_Tidy@?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QAEX_NI@Z ; std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>>::_Tidy(bool,uint)
.text$mn:00006130                 mov     ecx, [ebp+arg_0]
.text$mn:00006133                 push    ecx
.text$mn:00006134                 call    ??$forward@V?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@@std@@YA$$QAV?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@0@AAV10@@Z ; std::forward<std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>>>(std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>> &)
.text$mn:00006139                 add     esp, 4
.text$mn:0000613C                 push    eax
.text$mn:0000613D                 mov     ecx, [ebp+var_14]
.text$mn:00006140                 call    ?_Assign_rv@?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QAEX$$QAV12@@Z ; std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>>::_Assign_rv(std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>> &&)
.text$mn:00006145                 mov     [ebp+var_4], 0FFFFFFFFh
.text$mn:0000614C                 mov     eax, [ebp+var_14]
.text$mn:0000614F                 mov     ecx, [ebp+var_C]
.text$mn:00006152                 mov     large fs:0, ecx
.text$mn:00006159                 pop     ecx
.text$mn:0000615A                 mov     esp, ebp
.text$mn:0000615C                 pop     ebp
.text$mn:0000615D                 retn    4
.text$mn:0000615D ??0?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QAE@$$QAV01@@Z endp
.text$mn:0000615D
.text$mn:0000615D _text$mn        ends
.text$mn:0000615D
.text$x:00006160 ; ===========================================================================
.text$x:00006160
.text$x:00006160 ; Segment type: Pure code
.text$x:00006160 ; Segment permissions: Read/Execute
.text$x:00006160 _text$x         segment para public 'CODE' use32
.text$x:00006160                 assume cs:_text$x
.text$x:00006160                 ;org 6160h
.text$x:00006160 ; COMDAT (pick associative to section at 60E0)
.text$x:00006160                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text$x:00006160
.text$x:00006160 ; =============== S U B R O U T I N E =======================================
.text$x:00006160
.text$x:00006160
.text$x:00006160 __unwindfunclet$??0?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QAE@$$QAV01@@Z$0 proc near
.text$x:00006160                                         ; DATA XREF: .xdata$x:0000DAA0o
.text$x:00006160                 mov     ecx, [ebp-14h]
.text$x:00006163                 jmp     ??1?$_String_alloc@$0A@U?$_String_base_types@_WV?$allocator@_W@std@@@std@@@std@@QAE@XZ ; std::_String_alloc<0,std::_String_base_types<wchar_t,std::allocator<wchar_t>>>::~_String_alloc<0,std::_String_base_types<wchar_t,std::allocator<wchar_t>>>(void)
.text$x:00006163 __unwindfunclet$??0?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QAE@$$QAV01@@Z$0 endp
.text$x:00006163
.text$x:00006168
.text$x:00006168 ; =============== S U B R O U T I N E =======================================
.text$x:00006168
.text$x:00006168
.text$x:00006168 __ehhandler$??0?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QAE@$$QAV01@@Z proc near
.text$x:00006168                                         ; DATA XREF: std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>>::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>>(std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>> &&)+5o
.text$x:00006168
.text$x:00006168 arg_4           = dword ptr  8
.text$x:00006168
.text$x:00006168                 mov     edx, [esp+arg_4]
.text$x:0000616C                 lea     eax, [edx+0Ch]
.text$x:0000616F                 mov     ecx, [edx-0Ch]
.text$x:00006172                 xor     ecx, eax
.text$x:00006174                 call    @__security_check_cookie@4 ; __security_check_cookie(x)
.text$x:00006179                 mov     eax, offset __ehfuncinfo$??0?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QAE@$$QAV01@@Z
.text$x:0000617E                 jmp     ___CxxFrameHandler3
.text$x:0000617E __ehhandler$??0?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QAE@$$QAV01@@Z endp
.text$x:0000617E
.text$x:0000617E ; ---------------------------------------------------------------------------
.text$x:00006183                 align 4
.text$x:00006183 _text$x         ends
.text$x:00006183
.text$mn:00006184 ; ===========================================================================
.text$mn:00006184
.text$mn:00006184 ; Segment type: Pure code
.text$mn:00006184 ; Segment permissions: Read/Execute
.text$mn:00006184 _text$mn        segment para public 'CODE' use32
.text$mn:00006184                 assume cs:_text$mn
.text$mn:00006184                 ;org 6184h
.text$mn:00006184 ; COMDAT (pick any)
.text$mn:00006184                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text$mn:00006184
.text$mn:00006184 ; =============== S U B R O U T I N E =======================================
.text$mn:00006184
.text$mn:00006184 ; Attributes: bp-based frame
.text$mn:00006184
.text$mn:00006184 ; public: __thiscall std::basic_string<wchar_t, struct std::char_traits<wchar_t>, class std::allocator<wchar_t>>::basic_string<wchar_t, struct std::char_traits<wchar_t>, class std::allocator<wchar_t>>(class std::basic_string<wchar_t, struct std::char_traits<wchar_t>, class std::allocator<wchar_t>> const &)
.text$mn:00006184                 public ??0?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QAE@ABV01@@Z
.text$mn:00006184 ??0?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QAE@ABV01@@Z proc near
.text$mn:00006184                                         ; CODE XREF: PathRemoveFileSpecW(std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>> &)+E4p
.text$mn:00006184                                         ; PathAppendW(std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>> &,std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>> const &)+6Ep ...
.text$mn:00006184
.text$mn:00006184 var_14          = dword ptr -14h
.text$mn:00006184 var_E           = byte ptr -0Eh
.text$mn:00006184 var_D           = byte ptr -0Dh
.text$mn:00006184 var_C           = dword ptr -0Ch
.text$mn:00006184 var_4           = dword ptr -4
.text$mn:00006184 arg_0           = dword ptr  8
.text$mn:00006184
.text$mn:00006184                 push    ebp
.text$mn:00006185                 mov     ebp, esp
.text$mn:00006187                 push    0FFFFFFFFh
.text$mn:00006189                 push    offset __ehhandler$??0?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QAE@ABV01@@Z
.text$mn:0000618E                 mov     eax, large fs:0
.text$mn:00006194                 push    eax
.text$mn:00006195                 sub     esp, 8
.text$mn:00006198                 mov     eax, dword ptr ds:___security_cookie
.text$mn:0000619D                 xor     eax, ebp
.text$mn:0000619F                 push    eax
.text$mn:000061A0                 lea     eax, [ebp+var_C]
.text$mn:000061A3                 mov     large fs:0, eax
.text$mn:000061A9                 mov     [ebp+var_14], ecx
.text$mn:000061AC                 lea     eax, [ebp+var_D]
.text$mn:000061AF                 push    eax
.text$mn:000061B0                 lea     ecx, [ebp+var_E]
.text$mn:000061B3                 push    ecx
.text$mn:000061B4                 mov     ecx, [ebp+arg_0]
.text$mn:000061B7                 call    ?_Getal@?$_String_alloc@$0A@U?$_String_base_types@_WV?$allocator@_W@std@@@std@@@std@@QBE?AU?$_Wrap_alloc@V?$allocator@_W@std@@@2@XZ ; std::_String_alloc<0,std::_String_base_types<wchar_t,std::allocator<wchar_t>>>::_Getal(void)
.text$mn:000061BC                 mov     ecx, eax
.text$mn:000061BE                 call    ?select_on_container_copy_construction@?$_Wrap_alloc@V?$allocator@_W@std@@@std@@QBE?AU12@XZ ; std::_Wrap_alloc<std::allocator<wchar_t>>::select_on_container_copy_construction(void)
.text$mn:000061C3                 push    eax
.text$mn:000061C4                 mov     ecx, [ebp+var_14]
.text$mn:000061C7                 call    ??0?$_String_alloc@$0A@U?$_String_base_types@_WV?$allocator@_W@std@@@std@@@std@@QAE@ABV?$allocator@_W@1@@Z ; std::_String_alloc<0,std::_String_base_types<wchar_t,std::allocator<wchar_t>>>::_String_alloc<0,std::_String_base_types<wchar_t,std::allocator<wchar_t>>>(std::allocator<wchar_t> const &)
.text$mn:000061CC                 mov     [ebp+var_4], 0
.text$mn:000061D3                 push    0
.text$mn:000061D5                 push    0
.text$mn:000061D7                 mov     ecx, [ebp+var_14]
.text$mn:000061DA                 call    ?_Tidy@?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QAEX_NI@Z ; std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>>::_Tidy(bool,uint)
.text$mn:000061DF                 mov     edx, ds:?npos@?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@2IB ; uint const std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>>::npos
.text$mn:000061E5                 push    edx
.text$mn:000061E6                 push    0
.text$mn:000061E8                 mov     eax, [ebp+arg_0]
.text$mn:000061EB                 push    eax
.text$mn:000061EC                 mov     ecx, [ebp+var_14]
.text$mn:000061EF                 call    ?assign@?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QAEAAV12@ABV12@II@Z ; std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>>::assign(std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>> const &,uint,uint)
.text$mn:000061F4                 mov     [ebp+var_4], 0FFFFFFFFh
.text$mn:000061FB                 mov     eax, [ebp+var_14]
.text$mn:000061FE                 mov     ecx, [ebp+var_C]
.text$mn:00006201                 mov     large fs:0, ecx
.text$mn:00006208                 pop     ecx
.text$mn:00006209                 mov     esp, ebp
.text$mn:0000620B                 pop     ebp
.text$mn:0000620C                 retn    4
.text$mn:0000620C ??0?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QAE@ABV01@@Z endp
.text$mn:0000620C
.text$mn:0000620C ; ---------------------------------------------------------------------------
.text$mn:0000620F                 align 10h
.text$mn:0000620F _text$mn        ends
.text$mn:0000620F
.text$x:00006210 ; ===========================================================================
.text$x:00006210
.text$x:00006210 ; Segment type: Pure code
.text$x:00006210 ; Segment permissions: Read/Execute
.text$x:00006210 _text$x         segment para public 'CODE' use32
.text$x:00006210                 assume cs:_text$x
.text$x:00006210                 ;org 6210h
.text$x:00006210 ; COMDAT (pick associative to section at 6184)
.text$x:00006210                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text$x:00006210
.text$x:00006210 ; =============== S U B R O U T I N E =======================================
.text$x:00006210
.text$x:00006210
.text$x:00006210 __unwindfunclet$??0?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QAE@ABV01@@Z$0 proc near
.text$x:00006210                                         ; DATA XREF: .xdata$x:0000D9F0o
.text$x:00006210                 mov     ecx, [ebp-14h]
.text$x:00006213                 jmp     ??1?$_String_alloc@$0A@U?$_String_base_types@_WV?$allocator@_W@std@@@std@@@std@@QAE@XZ ; std::_String_alloc<0,std::_String_base_types<wchar_t,std::allocator<wchar_t>>>::~_String_alloc<0,std::_String_base_types<wchar_t,std::allocator<wchar_t>>>(void)
.text$x:00006213 __unwindfunclet$??0?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QAE@ABV01@@Z$0 endp
.text$x:00006213
.text$x:00006218
.text$x:00006218 ; =============== S U B R O U T I N E =======================================
.text$x:00006218
.text$x:00006218
.text$x:00006218 __ehhandler$??0?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QAE@ABV01@@Z proc near
.text$x:00006218                                         ; DATA XREF: std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>>::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>>(std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>> const &)+5o
.text$x:00006218
.text$x:00006218 arg_4           = dword ptr  8
.text$x:00006218
.text$x:00006218                 mov     edx, [esp+arg_4]
.text$x:0000621C                 lea     eax, [edx+0Ch]
.text$x:0000621F                 mov     ecx, [edx-0Ch]
.text$x:00006222                 xor     ecx, eax
.text$x:00006224                 call    @__security_check_cookie@4 ; __security_check_cookie(x)
.text$x:00006229                 mov     eax, offset __ehfuncinfo$??0?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QAE@ABV01@@Z
.text$x:0000622E                 jmp     ___CxxFrameHandler3
.text$x:0000622E __ehhandler$??0?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QAE@ABV01@@Z endp
.text$x:0000622E
.text$x:0000622E ; ---------------------------------------------------------------------------
.text$x:00006233                 align 4
.text$x:00006233 _text$x         ends
.text$x:00006233
.text$mn:00006234 ; ===========================================================================
.text$mn:00006234
.text$mn:00006234 ; Segment type: Pure code
.text$mn:00006234 ; Segment permissions: Read/Execute
.text$mn:00006234 _text$mn        segment para public 'CODE' use32
.text$mn:00006234                 assume cs:_text$mn
.text$mn:00006234                 ;org 6234h
.text$mn:00006234 ; COMDAT (pick any)
.text$mn:00006234                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text$mn:00006234
.text$mn:00006234 ; =============== S U B R O U T I N E =======================================
.text$mn:00006234
.text$mn:00006234 ; Attributes: bp-based frame
.text$mn:00006234
.text$mn:00006234 ; public: __thiscall std::basic_string<wchar_t, struct std::char_traits<wchar_t>, class std::allocator<wchar_t>>::basic_string<wchar_t, struct std::char_traits<wchar_t>, class std::allocator<wchar_t>>(class std::basic_string<wchar_t, struct std::char_traits<wchar_t>, class std::allocator<wchar_t>> const &, unsigned int, unsigned int, class std::allocator<wchar_t> const &)
.text$mn:00006234                 public ??0?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QAE@ABV01@IIABV?$allocator@_W@1@@Z
.text$mn:00006234 ??0?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QAE@ABV01@IIABV?$allocator@_W@1@@Z proc near
.text$mn:00006234                                         ; CODE XREF: std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>>::substr(uint,uint)+4Bp
.text$mn:00006234
.text$mn:00006234 var_10          = dword ptr -10h
.text$mn:00006234 var_C           = dword ptr -0Ch
.text$mn:00006234 var_4           = dword ptr -4
.text$mn:00006234 arg_0           = dword ptr  8
.text$mn:00006234 arg_4           = dword ptr  0Ch
.text$mn:00006234 arg_8           = dword ptr  10h
.text$mn:00006234 arg_C           = dword ptr  14h
.text$mn:00006234
.text$mn:00006234                 push    ebp
.text$mn:00006235                 mov     ebp, esp
.text$mn:00006237                 push    0FFFFFFFFh
.text$mn:00006239                 push    offset __ehhandler$??0?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QAE@ABV01@IIABV?$allocator@_W@1@@Z
.text$mn:0000623E                 mov     eax, large fs:0
.text$mn:00006244                 push    eax
.text$mn:00006245                 push    ecx
.text$mn:00006246                 mov     eax, dword ptr ds:___security_cookie
.text$mn:0000624B                 xor     eax, ebp
.text$mn:0000624D                 push    eax
.text$mn:0000624E                 lea     eax, [ebp+var_C]
.text$mn:00006251                 mov     large fs:0, eax
.text$mn:00006257                 mov     [ebp+var_10], ecx
.text$mn:0000625A                 mov     eax, [ebp+arg_C]
.text$mn:0000625D                 push    eax
.text$mn:0000625E                 mov     ecx, [ebp+var_10]
.text$mn:00006261                 call    ??0?$_String_alloc@$0A@U?$_String_base_types@_WV?$allocator@_W@std@@@std@@@std@@QAE@ABV?$allocator@_W@1@@Z ; std::_String_alloc<0,std::_String_base_types<wchar_t,std::allocator<wchar_t>>>::_String_alloc<0,std::_String_base_types<wchar_t,std::allocator<wchar_t>>>(std::allocator<wchar_t> const &)
.text$mn:00006266                 mov     [ebp+var_4], 0
.text$mn:0000626D                 push    0
.text$mn:0000626F                 push    0
.text$mn:00006271                 mov     ecx, [ebp+var_10]
.text$mn:00006274                 call    ?_Tidy@?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QAEX_NI@Z ; std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>>::_Tidy(bool,uint)
.text$mn:00006279                 mov     ecx, [ebp+arg_8]
.text$mn:0000627C                 push    ecx
.text$mn:0000627D                 mov     edx, [ebp+arg_4]
.text$mn:00006280                 push    edx
.text$mn:00006281                 mov     eax, [ebp+arg_0]
.text$mn:00006284                 push    eax
.text$mn:00006285                 mov     ecx, [ebp+var_10]
.text$mn:00006288                 call    ?assign@?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QAEAAV12@ABV12@II@Z ; std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>>::assign(std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>> const &,uint,uint)
.text$mn:0000628D                 mov     [ebp+var_4], 0FFFFFFFFh
.text$mn:00006294                 mov     eax, [ebp+var_10]
.text$mn:00006297                 mov     ecx, [ebp+var_C]
.text$mn:0000629A                 mov     large fs:0, ecx
.text$mn:000062A1                 pop     ecx
.text$mn:000062A2                 mov     esp, ebp
.text$mn:000062A4                 pop     ebp
.text$mn:000062A5                 retn    10h
.text$mn:000062A5 ??0?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QAE@ABV01@IIABV?$allocator@_W@1@@Z endp
.text$mn:000062A5
.text$mn:000062A5 _text$mn        ends
.text$mn:000062A5
.text$x:000062A8 ; ===========================================================================
.text$x:000062A8
.text$x:000062A8 ; Segment type: Pure code
.text$x:000062A8 ; Segment permissions: Read/Execute
.text$x:000062A8 _text$x         segment para public 'CODE' use32
.text$x:000062A8                 assume cs:_text$x
.text$x:000062A8                 ;org 62A8h
.text$x:000062A8 ; COMDAT (pick associative to section at 6234)
.text$x:000062A8                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text$x:000062A8
.text$x:000062A8 ; =============== S U B R O U T I N E =======================================
.text$x:000062A8
.text$x:000062A8
.text$x:000062A8 __unwindfunclet$??0?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QAE@ABV01@IIABV?$allocator@_W@1@@Z$0 proc near
.text$x:000062A8                                         ; DATA XREF: .xdata$x:0000DA48o
.text$x:000062A8                 mov     ecx, [ebp-10h]
.text$x:000062AB                 jmp     ??1?$_String_alloc@$0A@U?$_String_base_types@_WV?$allocator@_W@std@@@std@@@std@@QAE@XZ ; std::_String_alloc<0,std::_String_base_types<wchar_t,std::allocator<wchar_t>>>::~_String_alloc<0,std::_String_base_types<wchar_t,std::allocator<wchar_t>>>(void)
.text$x:000062AB __unwindfunclet$??0?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QAE@ABV01@IIABV?$allocator@_W@1@@Z$0 endp
.text$x:000062AB
.text$x:000062B0
.text$x:000062B0 ; =============== S U B R O U T I N E =======================================
.text$x:000062B0
.text$x:000062B0
.text$x:000062B0 __ehhandler$??0?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QAE@ABV01@IIABV?$allocator@_W@1@@Z proc near
.text$x:000062B0                                         ; DATA XREF: std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>>::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>>(std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>> const &,uint,uint,std::allocator<wchar_t> const &)+5o
.text$x:000062B0
.text$x:000062B0 arg_4           = dword ptr  8
.text$x:000062B0
.text$x:000062B0                 mov     edx, [esp+arg_4]
.text$x:000062B4                 lea     eax, [edx+0Ch]
.text$x:000062B7                 mov     ecx, [edx-8]
.text$x:000062BA                 xor     ecx, eax
.text$x:000062BC                 call    @__security_check_cookie@4 ; __security_check_cookie(x)
.text$x:000062C1                 mov     eax, offset __ehfuncinfo$??0?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QAE@ABV01@IIABV?$allocator@_W@1@@Z
.text$x:000062C6                 jmp     ___CxxFrameHandler3
.text$x:000062C6 __ehhandler$??0?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QAE@ABV01@IIABV?$allocator@_W@1@@Z endp
.text$x:000062C6
.text$x:000062C6 ; ---------------------------------------------------------------------------
.text$x:000062CB                 align 4
.text$x:000062CB _text$x         ends
.text$x:000062CB
.text$mn:000062CC ; ===========================================================================
.text$mn:000062CC
.text$mn:000062CC ; Segment type: Pure code
.text$mn:000062CC ; Segment permissions: Read/Execute
.text$mn:000062CC _text$mn        segment para public 'CODE' use32
.text$mn:000062CC                 assume cs:_text$mn
.text$mn:000062CC                 ;org 62CCh
.text$mn:000062CC ; COMDAT (pick any)
.text$mn:000062CC                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text$mn:000062CC
.text$mn:000062CC ; =============== S U B R O U T I N E =======================================
.text$mn:000062CC
.text$mn:000062CC ; Attributes: bp-based frame
.text$mn:000062CC
.text$mn:000062CC ; int __stdcall std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>>::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>>(wchar_t *Str)
.text$mn:000062CC                 public ??0?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QAE@PB_W@Z
.text$mn:000062CC ??0?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QAE@PB_W@Z proc near
.text$mn:000062CC                                         ; CODE XREF: getFolderName(HWND__ *,wchar_t const *)+40p
.text$mn:000062CC                                         ; purgeMenuItemString(wchar_t const *,bool)+193p ...
.text$mn:000062CC
.text$mn:000062CC var_14          = dword ptr -14h
.text$mn:000062CC var_D           = byte ptr -0Dh
.text$mn:000062CC var_C           = dword ptr -0Ch
.text$mn:000062CC var_4           = dword ptr -4
.text$mn:000062CC Str             = dword ptr  8
.text$mn:000062CC
.text$mn:000062CC                 push    ebp
.text$mn:000062CD                 mov     ebp, esp
.text$mn:000062CF                 push    0FFFFFFFFh
.text$mn:000062D1                 push    offset __ehhandler$??0?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QAE@PB_W@Z
.text$mn:000062D6                 mov     eax, large fs:0
.text$mn:000062DC                 push    eax
.text$mn:000062DD                 sub     esp, 8
.text$mn:000062E0                 mov     eax, dword ptr ds:___security_cookie
.text$mn:000062E5                 xor     eax, ebp
.text$mn:000062E7                 push    eax
.text$mn:000062E8                 lea     eax, [ebp+var_C]
.text$mn:000062EB                 mov     large fs:0, eax
.text$mn:000062F1                 mov     [ebp+var_14], ecx
.text$mn:000062F4                 lea     ecx, [ebp+var_D]
.text$mn:000062F7                 call    ??0?$allocator@_W@std@@QAE@XZ ; std::allocator<wchar_t>::allocator<wchar_t>(void)
.text$mn:000062FC                 push    eax
.text$mn:000062FD                 mov     ecx, [ebp+var_14]
.text$mn:00006300                 call    ??0?$_String_alloc@$0A@U?$_String_base_types@_WV?$allocator@_W@std@@@std@@@std@@QAE@ABV?$allocator@_W@1@@Z ; std::_String_alloc<0,std::_String_base_types<wchar_t,std::allocator<wchar_t>>>::_String_alloc<0,std::_String_base_types<wchar_t,std::allocator<wchar_t>>>(std::allocator<wchar_t> const &)
.text$mn:00006305                 mov     [ebp+var_4], 0
.text$mn:0000630C                 push    0
.text$mn:0000630E                 push    0
.text$mn:00006310                 mov     ecx, [ebp+var_14]
.text$mn:00006313                 call    ?_Tidy@?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QAEX_NI@Z ; std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>>::_Tidy(bool,uint)
.text$mn:00006318                 mov     eax, [ebp+Str]
.text$mn:0000631B                 push    eax             ; Str
.text$mn:0000631C                 mov     ecx, [ebp+var_14]
.text$mn:0000631F                 call    ?assign@?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QAEAAV12@PB_W@Z ; std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>>::assign(wchar_t const *)
.text$mn:00006324                 mov     [ebp+var_4], 0FFFFFFFFh
.text$mn:0000632B                 mov     eax, [ebp+var_14]
.text$mn:0000632E                 mov     ecx, [ebp+var_C]
.text$mn:00006331                 mov     large fs:0, ecx
.text$mn:00006338                 pop     ecx
.text$mn:00006339                 mov     esp, ebp
.text$mn:0000633B                 pop     ebp
.text$mn:0000633C                 retn    4
.text$mn:0000633C ??0?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QAE@PB_W@Z endp
.text$mn:0000633C
.text$mn:0000633C ; ---------------------------------------------------------------------------
.text$mn:0000633F                 align 10h
.text$mn:0000633F _text$mn        ends
.text$mn:0000633F
.text$x:00006340 ; ===========================================================================
.text$x:00006340
.text$x:00006340 ; Segment type: Pure code
.text$x:00006340 ; Segment permissions: Read/Execute
.text$x:00006340 _text$x         segment para public 'CODE' use32
.text$x:00006340                 assume cs:_text$x
.text$x:00006340                 ;org 6340h
.text$x:00006340 ; COMDAT (pick associative to section at 62CC)
.text$x:00006340                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text$x:00006340
.text$x:00006340 ; =============== S U B R O U T I N E =======================================
.text$x:00006340
.text$x:00006340
.text$x:00006340 __unwindfunclet$??0?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QAE@PB_W@Z$0 proc near
.text$x:00006340                                         ; DATA XREF: .xdata$x:0000DA74o
.text$x:00006340                 mov     ecx, [ebp-14h]
.text$x:00006343                 jmp     ??1?$_String_alloc@$0A@U?$_String_base_types@_WV?$allocator@_W@std@@@std@@@std@@QAE@XZ ; std::_String_alloc<0,std::_String_base_types<wchar_t,std::allocator<wchar_t>>>::~_String_alloc<0,std::_String_base_types<wchar_t,std::allocator<wchar_t>>>(void)
.text$x:00006343 __unwindfunclet$??0?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QAE@PB_W@Z$0 endp
.text$x:00006343
.text$x:00006348
.text$x:00006348 ; =============== S U B R O U T I N E =======================================
.text$x:00006348
.text$x:00006348
.text$x:00006348 __ehhandler$??0?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QAE@PB_W@Z proc near
.text$x:00006348                                         ; DATA XREF: std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>>::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>>(wchar_t const *)+5o
.text$x:00006348
.text$x:00006348 arg_4           = dword ptr  8
.text$x:00006348
.text$x:00006348                 mov     edx, [esp+arg_4]
.text$x:0000634C                 lea     eax, [edx+0Ch]
.text$x:0000634F                 mov     ecx, [edx-0Ch]
.text$x:00006352                 xor     ecx, eax
.text$x:00006354                 call    @__security_check_cookie@4 ; __security_check_cookie(x)
.text$x:00006359                 mov     eax, offset __ehfuncinfo$??0?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QAE@PB_W@Z
.text$x:0000635E                 jmp     ___CxxFrameHandler3
.text$x:0000635E __ehhandler$??0?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QAE@PB_W@Z endp
.text$x:0000635E
.text$x:0000635E ; ---------------------------------------------------------------------------
.text$x:00006363                 align 4
.text$x:00006363 _text$x         ends
.text$x:00006363
.text$mn:00006364 ; ===========================================================================
.text$mn:00006364
.text$mn:00006364 ; Segment type: Pure code
.text$mn:00006364 ; Segment permissions: Read/Execute
.text$mn:00006364 _text$mn        segment para public 'CODE' use32
.text$mn:00006364                 assume cs:_text$mn
.text$mn:00006364                 ;org 6364h
.text$mn:00006364 ; COMDAT (pick any)
.text$mn:00006364                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text$mn:00006364
.text$mn:00006364 ; =============== S U B R O U T I N E =======================================
.text$mn:00006364
.text$mn:00006364 ; Attributes: bp-based frame
.text$mn:00006364
.text$mn:00006364 ; public: __thiscall std::basic_string<wchar_t, struct std::char_traits<wchar_t>, class std::allocator<wchar_t>>::basic_string<wchar_t, struct std::char_traits<wchar_t>, class std::allocator<wchar_t>>(void)
.text$mn:00006364                 public ??0?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QAE@XZ
.text$mn:00006364 ??0?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QAE@XZ proc near
.text$mn:00006364                                         ; CODE XREF: BuildMenuFileName(int,uint,std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>> const &)+39p
.text$mn:00006364                                         ; stringJoin(std::vector<std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>>,std::allocator<std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>>>> const &,std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>> const &)+32p ...
.text$mn:00006364
.text$mn:00006364 var_14          = dword ptr -14h
.text$mn:00006364 var_D           = byte ptr -0Dh
.text$mn:00006364 var_C           = dword ptr -0Ch
.text$mn:00006364 var_4           = dword ptr -4
.text$mn:00006364
.text$mn:00006364                 push    ebp
.text$mn:00006365                 mov     ebp, esp
.text$mn:00006367                 push    0FFFFFFFFh
.text$mn:00006369                 push    offset __ehhandler$??0?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QAE@XZ
.text$mn:0000636E                 mov     eax, large fs:0
.text$mn:00006374                 push    eax
.text$mn:00006375                 sub     esp, 8
.text$mn:00006378                 mov     eax, dword ptr ds:___security_cookie
.text$mn:0000637D                 xor     eax, ebp
.text$mn:0000637F                 push    eax
.text$mn:00006380                 lea     eax, [ebp+var_C]
.text$mn:00006383                 mov     large fs:0, eax
.text$mn:00006389                 mov     [ebp+var_14], ecx
.text$mn:0000638C                 lea     ecx, [ebp+var_D]
.text$mn:0000638F                 call    ??0?$allocator@_W@std@@QAE@XZ ; std::allocator<wchar_t>::allocator<wchar_t>(void)
.text$mn:00006394                 push    eax
.text$mn:00006395                 mov     ecx, [ebp+var_14]
.text$mn:00006398                 call    ??0?$_String_alloc@$0A@U?$_String_base_types@_WV?$allocator@_W@std@@@std@@@std@@QAE@ABV?$allocator@_W@1@@Z ; std::_String_alloc<0,std::_String_base_types<wchar_t,std::allocator<wchar_t>>>::_String_alloc<0,std::_String_base_types<wchar_t,std::allocator<wchar_t>>>(std::allocator<wchar_t> const &)
.text$mn:0000639D                 mov     [ebp+var_4], 0
.text$mn:000063A4                 push    0
.text$mn:000063A6                 push    0
.text$mn:000063A8                 mov     ecx, [ebp+var_14]
.text$mn:000063AB                 call    ?_Tidy@?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QAEX_NI@Z ; std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>>::_Tidy(bool,uint)
.text$mn:000063B0                 mov     [ebp+var_4], 0FFFFFFFFh
.text$mn:000063B7                 mov     eax, [ebp+var_14]
.text$mn:000063BA                 mov     ecx, [ebp+var_C]
.text$mn:000063BD                 mov     large fs:0, ecx
.text$mn:000063C4                 pop     ecx
.text$mn:000063C5                 mov     esp, ebp
.text$mn:000063C7                 pop     ebp
.text$mn:000063C8                 retn
.text$mn:000063C8 ??0?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QAE@XZ endp
.text$mn:000063C8
.text$mn:000063C8 ; ---------------------------------------------------------------------------
.text$mn:000063C9                 align 4
.text$mn:000063C9 _text$mn        ends
.text$mn:000063C9
.text$x:000063CC ; ===========================================================================
.text$x:000063CC
.text$x:000063CC ; Segment type: Pure code
.text$x:000063CC ; Segment permissions: Read/Execute
.text$x:000063CC _text$x         segment para public 'CODE' use32
.text$x:000063CC                 assume cs:_text$x
.text$x:000063CC                 ;org 63CCh
.text$x:000063CC ; COMDAT (pick associative to section at 6364)
.text$x:000063CC                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text$x:000063CC
.text$x:000063CC ; =============== S U B R O U T I N E =======================================
.text$x:000063CC
.text$x:000063CC
.text$x:000063CC __unwindfunclet$??0?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QAE@XZ$0 proc near
.text$x:000063CC                                         ; DATA XREF: .xdata$x:0000DA1Co
.text$x:000063CC                 mov     ecx, [ebp-14h]
.text$x:000063CF                 jmp     ??1?$_String_alloc@$0A@U?$_String_base_types@_WV?$allocator@_W@std@@@std@@@std@@QAE@XZ ; std::_String_alloc<0,std::_String_base_types<wchar_t,std::allocator<wchar_t>>>::~_String_alloc<0,std::_String_base_types<wchar_t,std::allocator<wchar_t>>>(void)
.text$x:000063CF __unwindfunclet$??0?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QAE@XZ$0 endp
.text$x:000063CF
.text$x:000063D4
.text$x:000063D4 ; =============== S U B R O U T I N E =======================================
.text$x:000063D4
.text$x:000063D4
.text$x:000063D4 __ehhandler$??0?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QAE@XZ proc near
.text$x:000063D4                                         ; DATA XREF: std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>>::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>>(void)+5o
.text$x:000063D4
.text$x:000063D4 arg_4           = dword ptr  8
.text$x:000063D4
.text$x:000063D4                 mov     edx, [esp+arg_4]
.text$x:000063D8                 lea     eax, [edx+0Ch]
.text$x:000063DB                 mov     ecx, [edx-0Ch]
.text$x:000063DE                 xor     ecx, eax
.text$x:000063E0                 call    @__security_check_cookie@4 ; __security_check_cookie(x)
.text$x:000063E5                 mov     eax, offset __ehfuncinfo$??0?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QAE@XZ
.text$x:000063EA                 jmp     ___CxxFrameHandler3
.text$x:000063EA __ehhandler$??0?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QAE@XZ endp
.text$x:000063EA
.text$x:000063EA ; ---------------------------------------------------------------------------
.text$x:000063EF                 align 10h
.text$x:000063EF _text$x         ends
.text$x:000063EF
.text$mn:000063F0 ; ===========================================================================
.text$mn:000063F0
.text$mn:000063F0 ; Segment type: Pure code
.text$mn:000063F0 ; Segment permissions: Read/Execute
.text$mn:000063F0 _text$mn        segment para public 'CODE' use32
.text$mn:000063F0                 assume cs:_text$mn
.text$mn:000063F0                 ;org 63F0h
.text$mn:000063F0 ; COMDAT (pick any)
.text$mn:000063F0                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text$mn:000063F0
.text$mn:000063F0 ; =============== S U B R O U T I N E =======================================
.text$mn:000063F0
.text$mn:000063F0 ; Attributes: bp-based frame
.text$mn:000063F0
.text$mn:000063F0 ; int __stdcall std::reverse_iterator<std::_Vector_iterator<std::_Vector_val<std::_Simple_types<wchar_t>>>>::reverse_iterator<std::_Vector_iterator<std::_Vector_val<std::_Simple_types<wchar_t>>>>(struct std::_Iterator_base12 *)
.text$mn:000063F0                 public ??0?$reverse_iterator@V?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@_W@std@@@std@@@std@@@std@@QAE@ABV01@@Z
.text$mn:000063F0 ??0?$reverse_iterator@V?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@_W@std@@@std@@@std@@@std@@QAE@ABV01@@Z proc near
.text$mn:000063F0                                         ; CODE XREF: std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>>::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>>(std::reverse_iterator<std::_Vector_iterator<std::_Vector_val<std::_Simple_types<wchar_t>>>>,std::reverse_iterator<std::_Vector_iterator<std::_Vector_val<std::_Simple_types<wchar_t>>>>)+76p
.text$mn:000063F0                                         ; std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>>::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>>(std::reverse_iterator<std::_Vector_iterator<std::_Vector_val<std::_Simple_types<wchar_t>>>>,std::reverse_iterator<std::_Vector_iterator<std::_Vector_val<std::_Simple_types<wchar_t>>>>)+94p ...
.text$mn:000063F0
.text$mn:000063F0 var_10          = dword ptr -10h
.text$mn:000063F0 var_C           = dword ptr -0Ch
.text$mn:000063F0 var_4           = dword ptr -4
.text$mn:000063F0 arg_0           = dword ptr  8
.text$mn:000063F0
.text$mn:000063F0                 push    ebp
.text$mn:000063F1                 mov     ebp, esp
.text$mn:000063F3                 push    0FFFFFFFFh
.text$mn:000063F5                 push    offset __ehhandler$??0?$reverse_iterator@V?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@_W@std@@@std@@@std@@@std@@QAE@ABV01@@Z
.text$mn:000063FA                 mov     eax, large fs:0
.text$mn:00006400                 push    eax
.text$mn:00006401                 push    ecx
.text$mn:00006402                 mov     eax, dword ptr ds:___security_cookie
.text$mn:00006407                 xor     eax, ebp
.text$mn:00006409                 push    eax
.text$mn:0000640A                 lea     eax, [ebp+var_C]
.text$mn:0000640D                 mov     large fs:0, eax
.text$mn:00006413                 mov     [ebp+var_10], ecx
.text$mn:00006416                 mov     eax, [ebp+arg_0]
.text$mn:00006419                 push    eax             ; struct std::_Iterator_base12 *
.text$mn:0000641A                 mov     ecx, [ebp+var_10]
.text$mn:0000641D                 call    ??0?$_Revranit@V?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@_W@std@@@std@@@std@@U?$iterator@Urandom_access_iterator_tag@std@@_WHPA_WAA_W@2@@std@@QAE@ABV01@@Z ; std::_Revranit<std::_Vector_iterator<std::_Vector_val<std::_Simple_types<wchar_t>>>,std::iterator<std::random_access_iterator_tag,wchar_t,int,wchar_t *,wchar_t &>>::_Revranit<std::_Vector_iterator<std::_Vector_val<std::_Simple_types<wchar_t>>>,std::iterator<std::random_access_iterator_tag,wchar_t,int,wchar_t *,wchar_t &>>(std::_Revranit<std::_Vector_iterator<std::_Vector_val<std::_Simple_types<wchar_t>>>,std::iterator<std::random_access_iterator_tag,wchar_t,int,wchar_t *,wchar_t &>> const &)
.text$mn:00006422                 mov     [ebp+var_4], 0
.text$mn:00006429                 mov     [ebp+var_4], 0FFFFFFFFh
.text$mn:00006430                 mov     eax, [ebp+var_10]
.text$mn:00006433                 mov     ecx, [ebp+var_C]
.text$mn:00006436                 mov     large fs:0, ecx
.text$mn:0000643D                 pop     ecx
.text$mn:0000643E                 mov     esp, ebp
.text$mn:00006440                 pop     ebp
.text$mn:00006441                 retn    4
.text$mn:00006441 ??0?$reverse_iterator@V?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@_W@std@@@std@@@std@@@std@@QAE@ABV01@@Z endp
.text$mn:00006441
.text$mn:00006441 _text$mn        ends
.text$mn:00006441
.text$x:00006444 ; ===========================================================================
.text$x:00006444
.text$x:00006444 ; Segment type: Pure code
.text$x:00006444 ; Segment permissions: Read/Execute
.text$x:00006444 _text$x         segment para public 'CODE' use32
.text$x:00006444                 assume cs:_text$x
.text$x:00006444                 ;org 6444h
.text$x:00006444 ; COMDAT (pick associative to section at 63F0)
.text$x:00006444                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text$x:00006444
.text$x:00006444 ; =============== S U B R O U T I N E =======================================
.text$x:00006444
.text$x:00006444
.text$x:00006444 __unwindfunclet$??0?$reverse_iterator@V?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@_W@std@@@std@@@std@@@std@@QAE@ABV01@@Z$0 proc near
.text$x:00006444                                         ; DATA XREF: .xdata$x:0000EAC0o
.text$x:00006444                 mov     ecx, [ebp-10h]
.text$x:00006447                 jmp     ??1?$_Revranit@V?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@_W@std@@@std@@@std@@U?$iterator@Urandom_access_iterator_tag@std@@_WHPA_WAA_W@2@@std@@QAE@XZ ; std::_Revranit<std::_Vector_iterator<std::_Vector_val<std::_Simple_types<wchar_t>>>,std::iterator<std::random_access_iterator_tag,wchar_t,int,wchar_t *,wchar_t &>>::~_Revranit<std::_Vector_iterator<std::_Vector_val<std::_Simple_types<wchar_t>>>,std::iterator<std::random_access_iterator_tag,wchar_t,int,wchar_t *,wchar_t &>>(void)
.text$x:00006447 __unwindfunclet$??0?$reverse_iterator@V?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@_W@std@@@std@@@std@@@std@@QAE@ABV01@@Z$0 endp
.text$x:00006447
.text$x:0000644C
.text$x:0000644C ; =============== S U B R O U T I N E =======================================
.text$x:0000644C
.text$x:0000644C
.text$x:0000644C __ehhandler$??0?$reverse_iterator@V?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@_W@std@@@std@@@std@@@std@@QAE@ABV01@@Z proc near
.text$x:0000644C                                         ; DATA XREF: std::reverse_iterator<std::_Vector_iterator<std::_Vector_val<std::_Simple_types<wchar_t>>>>::reverse_iterator<std::_Vector_iterator<std::_Vector_val<std::_Simple_types<wchar_t>>>>(std::reverse_iterator<std::_Vector_iterator<std::_Vector_val<std::_Simple_types<wchar_t>>>> const &)+5o
.text$x:0000644C
.text$x:0000644C arg_4           = dword ptr  8
.text$x:0000644C
.text$x:0000644C                 mov     edx, [esp+arg_4]
.text$x:00006450                 lea     eax, [edx+0Ch]
.text$x:00006453                 mov     ecx, [edx-8]
.text$x:00006456                 xor     ecx, eax
.text$x:00006458                 call    @__security_check_cookie@4 ; __security_check_cookie(x)
.text$x:0000645D                 mov     eax, offset __ehfuncinfo$??0?$reverse_iterator@V?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@_W@std@@@std@@@std@@@std@@QAE@ABV01@@Z
.text$x:00006462                 jmp     ___CxxFrameHandler3
.text$x:00006462 __ehhandler$??0?$reverse_iterator@V?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@_W@std@@@std@@@std@@@std@@QAE@ABV01@@Z endp
.text$x:00006462
.text$x:00006462 ; ---------------------------------------------------------------------------
.text$x:00006467                 align 4
.text$x:00006467 _text$x         ends
.text$x:00006467
.text$mn:00006468 ; ===========================================================================
.text$mn:00006468
.text$mn:00006468 ; Segment type: Pure code
.text$mn:00006468 ; Segment permissions: Read/Execute
.text$mn:00006468 _text$mn        segment para public 'CODE' use32
.text$mn:00006468                 assume cs:_text$mn
.text$mn:00006468                 ;org 6468h
.text$mn:00006468 ; COMDAT (pick any)
.text$mn:00006468                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text$mn:00006468
.text$mn:00006468 ; =============== S U B R O U T I N E =======================================
.text$mn:00006468
.text$mn:00006468 ; Attributes: bp-based frame
.text$mn:00006468
.text$mn:00006468 ; public: __thiscall std::reverse_iterator<class std::_Vector_iterator<class std::_Vector_val<struct std::_Simple_types<wchar_t>>>>::reverse_iterator<class std::_Vector_iterator<class std::_Vector_val<struct std::_Simple_types<wchar_t>>>>(class std::_Vector_iterator<class std::_Vector_val<struct std::_Simple_types<wchar_t>>>)
.text$mn:00006468                 public ??0?$reverse_iterator@V?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@_W@std@@@std@@@std@@@std@@QAE@V?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@_W@std@@@std@@@1@@Z
.text$mn:00006468 ??0?$reverse_iterator@V?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@_W@std@@@std@@@std@@@std@@QAE@V?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@_W@std@@@std@@@1@@Z proc near
.text$mn:00006468                                         ; CODE XREF: std::vector<wchar_t,std::allocator<wchar_t>>::rbegin(void)+57p
.text$mn:00006468                                         ; std::vector<wchar_t,std::allocator<wchar_t>>::rend(void)+57p
.text$mn:00006468
.text$mn:00006468 var_20          = dword ptr -20h
.text$mn:00006468 var_1C          = dword ptr -1Ch
.text$mn:00006468 var_18          = dword ptr -18h
.text$mn:00006468 var_14          = dword ptr -14h
.text$mn:00006468 var_10          = dword ptr -10h
.text$mn:00006468 var_C           = dword ptr -0Ch
.text$mn:00006468 var_4           = dword ptr -4
.text$mn:00006468 arg_0           = byte ptr  8
.text$mn:00006468
.text$mn:00006468                 push    ebp
.text$mn:00006469                 mov     ebp, esp
.text$mn:0000646B                 push    0FFFFFFFFh
.text$mn:0000646D                 push    offset __ehhandler$??0?$reverse_iterator@V?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@_W@std@@@std@@@std@@@std@@QAE@V?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@_W@std@@@std@@@1@@Z
.text$mn:00006472                 mov     eax, large fs:0
.text$mn:00006478                 push    eax
.text$mn:00006479                 sub     esp, 14h
.text$mn:0000647C                 mov     eax, dword ptr ds:___security_cookie
.text$mn:00006481                 xor     eax, ebp
.text$mn:00006483                 push    eax
.text$mn:00006484                 lea     eax, [ebp+var_C]
.text$mn:00006487                 mov     large fs:0, eax
.text$mn:0000648D                 mov     [ebp+var_10], ecx
.text$mn:00006490                 mov     [ebp+var_4], 0
.text$mn:00006497                 sub     esp, 0Ch
.text$mn:0000649A                 mov     ecx, esp
.text$mn:0000649C                 mov     [ebp+var_18], esp
.text$mn:0000649F                 lea     eax, [ebp+arg_0]
.text$mn:000064A2                 push    eax             ; struct std::_Iterator_base12 *
.text$mn:000064A3                 call    ??0?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@_W@std@@@std@@@std@@QAE@ABV01@@Z ; std::_Vector_iterator<std::_Vector_val<std::_Simple_types<wchar_t>>>::_Vector_iterator<std::_Vector_val<std::_Simple_types<wchar_t>>>(std::_Vector_iterator<std::_Vector_val<std::_Simple_types<wchar_t>>> const &)
.text$mn:000064A8                 mov     [ebp+var_14], eax
.text$mn:000064AB                 mov     ecx, [ebp+var_14]
.text$mn:000064AE                 mov     [ebp+var_1C], ecx
.text$mn:000064B1                 mov     byte ptr [ebp+var_4], 1
.text$mn:000064B5                 mov     byte ptr [ebp+var_4], 0
.text$mn:000064B9                 mov     ecx, [ebp+var_10]
.text$mn:000064BC                 call    ??0?$_Revranit@V?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@_W@std@@@std@@@std@@U?$iterator@Urandom_access_iterator_tag@std@@_WHPA_WAA_W@2@@std@@QAE@V?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@_W@std@@@std@@@1@@Z ; std::_Revranit<std::_Vector_iterator<std::_Vector_val<std::_Simple_types<wchar_t>>>,std::iterator<std::random_access_iterator_tag,wchar_t,int,wchar_t *,wchar_t &>>::_Revranit<std::_Vector_iterator<std::_Vector_val<std::_Simple_types<wchar_t>>>,std::iterator<std::random_access_iterator_tag,wchar_t,int,wchar_t *,wchar_t &>>(std::_Vector_iterator<std::_Vector_val<std::_Simple_types<wchar_t>>>)
.text$mn:000064C1                 mov     [ebp+var_20], eax
.text$mn:000064C4                 mov     byte ptr [ebp+var_4], 2
.text$mn:000064C8                 mov     [ebp+var_4], 0FFFFFFFFh
.text$mn:000064CF                 lea     ecx, [ebp+arg_0]
.text$mn:000064D2                 call    ??1?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@_W@std@@@std@@@std@@QAE@XZ ; std::_Vector_iterator<std::_Vector_val<std::_Simple_types<wchar_t>>>::~_Vector_iterator<std::_Vector_val<std::_Simple_types<wchar_t>>>(void)
.text$mn:000064D7                 mov     eax, [ebp+var_10]
.text$mn:000064DA                 mov     ecx, [ebp+var_C]
.text$mn:000064DD                 mov     large fs:0, ecx
.text$mn:000064E4                 pop     ecx
.text$mn:000064E5                 mov     esp, ebp
.text$mn:000064E7                 pop     ebp
.text$mn:000064E8                 retn    0Ch
.text$mn:000064E8 ??0?$reverse_iterator@V?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@_W@std@@@std@@@std@@@std@@QAE@V?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@_W@std@@@std@@@1@@Z endp
.text$mn:000064E8
.text$mn:000064E8 ; ---------------------------------------------------------------------------
.text$mn:000064EB                 align 4
.text$mn:000064EB _text$mn        ends
.text$mn:000064EB
.text$x:000064EC ; ===========================================================================
.text$x:000064EC
.text$x:000064EC ; Segment type: Pure code
.text$x:000064EC ; Segment permissions: Read/Execute
.text$x:000064EC _text$x         segment para public 'CODE' use32
.text$x:000064EC                 assume cs:_text$x
.text$x:000064EC                 ;org 64ECh
.text$x:000064EC ; COMDAT (pick associative to section at 6468)
.text$x:000064EC                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text$x:000064EC
.text$x:000064EC ; =============== S U B R O U T I N E =======================================
.text$x:000064EC
.text$x:000064EC
.text$x:000064EC __unwindfunclet$??0?$reverse_iterator@V?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@_W@std@@@std@@@std@@@std@@QAE@V?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@_W@std@@@std@@@1@@Z$0 proc near
.text$x:000064EC                                         ; DATA XREF: .xdata$x:0000EA58o
.text$x:000064EC                 lea     ecx, [ebp+8]
.text$x:000064EF                 jmp     ??1?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@_W@std@@@std@@@std@@QAE@XZ ; std::_Vector_iterator<std::_Vector_val<std::_Simple_types<wchar_t>>>::~_Vector_iterator<std::_Vector_val<std::_Simple_types<wchar_t>>>(void)
.text$x:000064EF __unwindfunclet$??0?$reverse_iterator@V?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@_W@std@@@std@@@std@@@std@@QAE@V?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@_W@std@@@std@@@1@@Z$0 endp
.text$x:000064EF
.text$x:000064F4
.text$x:000064F4 ; =============== S U B R O U T I N E =======================================
.text$x:000064F4
.text$x:000064F4
.text$x:000064F4 __unwindfunclet$??0?$reverse_iterator@V?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@_W@std@@@std@@@std@@@std@@QAE@V?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@_W@std@@@std@@@1@@Z$1 proc near
.text$x:000064F4                                         ; DATA XREF: .xdata$x:0000EA60o
.text$x:000064F4                 mov     ecx, [ebp-18h]
.text$x:000064F7                 jmp     ??1?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@_W@std@@@std@@@std@@QAE@XZ ; std::_Vector_iterator<std::_Vector_val<std::_Simple_types<wchar_t>>>::~_Vector_iterator<std::_Vector_val<std::_Simple_types<wchar_t>>>(void)
.text$x:000064F7 __unwindfunclet$??0?$reverse_iterator@V?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@_W@std@@@std@@@std@@@std@@QAE@V?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@_W@std@@@std@@@1@@Z$1 endp
.text$x:000064F7
.text$x:000064FC
.text$x:000064FC ; =============== S U B R O U T I N E =======================================
.text$x:000064FC
.text$x:000064FC
.text$x:000064FC __unwindfunclet$??0?$reverse_iterator@V?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@_W@std@@@std@@@std@@@std@@QAE@V?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@_W@std@@@std@@@1@@Z$2 proc near
.text$x:000064FC                                         ; DATA XREF: .xdata$x:0000EA68o
.text$x:000064FC                 mov     ecx, [ebp-10h]
.text$x:000064FF                 jmp     ??1?$_Revranit@V?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@_W@std@@@std@@@std@@U?$iterator@Urandom_access_iterator_tag@std@@_WHPA_WAA_W@2@@std@@QAE@XZ ; std::_Revranit<std::_Vector_iterator<std::_Vector_val<std::_Simple_types<wchar_t>>>,std::iterator<std::random_access_iterator_tag,wchar_t,int,wchar_t *,wchar_t &>>::~_Revranit<std::_Vector_iterator<std::_Vector_val<std::_Simple_types<wchar_t>>>,std::iterator<std::random_access_iterator_tag,wchar_t,int,wchar_t *,wchar_t &>>(void)
.text$x:000064FF __unwindfunclet$??0?$reverse_iterator@V?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@_W@std@@@std@@@std@@@std@@QAE@V?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@_W@std@@@std@@@1@@Z$2 endp
.text$x:000064FF
.text$x:00006504
.text$x:00006504 ; =============== S U B R O U T I N E =======================================
.text$x:00006504
.text$x:00006504
.text$x:00006504 __ehhandler$??0?$reverse_iterator@V?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@_W@std@@@std@@@std@@@std@@QAE@V?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@_W@std@@@std@@@1@@Z proc near
.text$x:00006504                                         ; DATA XREF: std::reverse_iterator<std::_Vector_iterator<std::_Vector_val<std::_Simple_types<wchar_t>>>>::reverse_iterator<std::_Vector_iterator<std::_Vector_val<std::_Simple_types<wchar_t>>>>(std::_Vector_iterator<std::_Vector_val<std::_Simple_types<wchar_t>>>)+5o
.text$x:00006504
.text$x:00006504 arg_4           = dword ptr  8
.text$x:00006504
.text$x:00006504                 mov     edx, [esp+arg_4]
.text$x:00006508                 lea     eax, [edx+0Ch]
.text$x:0000650B                 mov     ecx, [edx-18h]
.text$x:0000650E                 xor     ecx, eax
.text$x:00006510                 call    @__security_check_cookie@4 ; __security_check_cookie(x)
.text$x:00006515                 mov     eax, offset __ehfuncinfo$??0?$reverse_iterator@V?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@_W@std@@@std@@@std@@@std@@QAE@V?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@_W@std@@@std@@@1@@Z
.text$x:0000651A                 jmp     ___CxxFrameHandler3
.text$x:0000651A __ehhandler$??0?$reverse_iterator@V?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@_W@std@@@std@@@std@@@std@@QAE@V?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@_W@std@@@std@@@1@@Z endp
.text$x:0000651A
.text$x:0000651A ; ---------------------------------------------------------------------------
.text$x:0000651F                 align 10h
.text$x:0000651F _text$x         ends
.text$x:0000651F
.text$mn:00006520 ; ===========================================================================
.text$mn:00006520
.text$mn:00006520 ; Segment type: Pure code
.text$mn:00006520 ; Segment permissions: Read/Execute
.text$mn:00006520 _text$mn        segment para public 'CODE' use32
.text$mn:00006520                 assume cs:_text$mn
.text$mn:00006520                 ;org 6520h
.text$mn:00006520 ; COMDAT (pick any)
.text$mn:00006520                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text$mn:00006520
.text$mn:00006520 ; =============== S U B R O U T I N E =======================================
.text$mn:00006520
.text$mn:00006520 ; Attributes: bp-based frame
.text$mn:00006520
.text$mn:00006520 ; int __cdecl std::vector<char,std::allocator<char>>::vector<char,std::allocator<char>>(size_t Size)
.text$mn:00006520                 public ??0?$vector@DV?$allocator@D@std@@@std@@QAE@I@Z
.text$mn:00006520 ??0?$vector@DV?$allocator@D@std@@@std@@QAE@I@Z proc near
.text$mn:00006520                                         ; CODE XREF: wstring2string(std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>> const &,uint)+5Bp
.text$mn:00006520
.text$mn:00006520 var_18          = dword ptr -18h
.text$mn:00006520 var_12          = byte ptr -12h
.text$mn:00006520 var_11          = dword ptr -11h
.text$mn:00006520 var_C           = dword ptr -0Ch
.text$mn:00006520 var_4           = dword ptr -4
.text$mn:00006520 Size            = dword ptr  8
.text$mn:00006520
.text$mn:00006520 ; FUNCTION CHUNK AT .text$mn:000065C9 SIZE 00000009 BYTES
.text$mn:00006520 ; FUNCTION CHUNK AT .text$mn:000065D9 SIZE 0000001E BYTES
.text$mn:00006520
.text$mn:00006520                 push    ebp
.text$mn:00006521                 mov     ebp, esp
.text$mn:00006523                 push    0FFFFFFFFh
.text$mn:00006525                 push    offset __ehhandler$??0?$vector@DV?$allocator@D@std@@@std@@QAE@I@Z
.text$mn:0000652A                 mov     eax, large fs:0
.text$mn:00006530                 push    eax
.text$mn:00006531                 push    ecx
.text$mn:00006532                 sub     esp, 8
.text$mn:00006535                 push    ebx
.text$mn:00006536                 push    esi
.text$mn:00006537                 push    edi
.text$mn:00006538                 mov     eax, dword ptr ds:___security_cookie
.text$mn:0000653D                 xor     eax, ebp
.text$mn:0000653F                 push    eax
.text$mn:00006540                 lea     eax, [ebp+var_C]
.text$mn:00006543                 mov     large fs:0, eax
.text$mn:00006549                 mov     [ebp+var_11+1], esp
.text$mn:0000654C                 mov     [ebp+var_18], ecx
.text$mn:0000654F                 lea     ecx, [ebp+var_12]
.text$mn:00006552                 call    ??0?$allocator@D@std@@QAE@XZ ; std::allocator<char>::allocator<char>(void)
.text$mn:00006557                 push    eax
.text$mn:00006558                 mov     ecx, [ebp+var_18]
.text$mn:0000655B                 call    ??0?$_Vector_alloc@$0A@U?$_Vec_base_types@DV?$allocator@D@std@@@std@@@std@@QAE@ABV?$allocator@D@1@@Z ; std::_Vector_alloc<0,std::_Vec_base_types<char,std::allocator<char>>>::_Vector_alloc<0,std::_Vec_base_types<char,std::allocator<char>>>(std::allocator<char> const &)
.text$mn:00006560                 mov     [ebp+var_4], 0
.text$mn:00006567                 mov     eax, [ebp+Size]
.text$mn:0000656A                 push    eax
.text$mn:0000656B                 mov     ecx, [ebp+var_18]
.text$mn:0000656E                 call    ?_Buy@?$vector@DV?$allocator@D@std@@@std@@IAE_NI@Z ; std::vector<char,std::allocator<char>>::_Buy(uint)
.text$mn:00006573                 movzx   ecx, al
.text$mn:00006576                 test    ecx, ecx
.text$mn:00006578                 jz      short loc_65D9
.text$mn:0000657A                 lea     edx, [ebp+var_11]
.text$mn:0000657D                 push    edx
.text$mn:0000657E                 mov     ecx, [ebp+var_18]
.text$mn:00006581                 call    ?_Getal@?$_Vector_alloc@$0A@U?$_Vec_base_types@DV?$allocator@D@std@@@std@@@std@@QBE?AU?$_Wrap_alloc@V?$allocator@D@std@@@2@XZ ; std::_Vector_alloc<0,std::_Vec_base_types<char,std::allocator<char>>>::_Getal(void)
.text$mn:00006586                 mov     byte ptr [ebp+var_4], 1
.text$mn:0000658A                 lea     eax, [ebp+var_11]
.text$mn:0000658D                 push    eax             ; int
.text$mn:0000658E                 mov     ecx, [ebp+Size]
.text$mn:00006591                 push    ecx             ; Size
.text$mn:00006592                 mov     edx, [ebp+var_18]
.text$mn:00006595                 mov     eax, [edx+4]
.text$mn:00006598                 push    eax             ; Dst
.text$mn:00006599                 call    ??$_Uninitialized_default_fill_n@PADIU?$_Wrap_alloc@V?$allocator@D@std@@@std@@@std@@YAXPADIAAU?$_Wrap_alloc@V?$allocator@D@std@@@0@@Z ; std::_Uninitialized_default_fill_n<char *,uint,std::_Wrap_alloc<std::allocator<char>>>(char *,uint,std::_Wrap_alloc<std::allocator<char>> &)
.text$mn:0000659E                 add     esp, 0Ch
.text$mn:000065A1                 mov     ecx, [ebp+var_18]
.text$mn:000065A4                 mov     edx, [ecx+8]
.text$mn:000065A7                 add     edx, [ebp+Size]
.text$mn:000065AA                 mov     eax, [ebp+var_18]
.text$mn:000065AD                 mov     [eax+8], edx
.text$mn:000065B0                 jmp     short loc_65C9
.text$mn:000065B0 ??0?$vector@DV?$allocator@D@std@@@std@@QAE@I@Z endp
.text$mn:000065B0
.text$mn:000065B2
.text$mn:000065B2 ; =============== S U B R O U T I N E =======================================
.text$mn:000065B2
.text$mn:000065B2 ; Attributes: noreturn
.text$mn:000065B2
.text$mn:000065B2 __catch$??0?$vector@DV?$allocator@D@std@@@std@@QAE@I@Z$0 proc near
.text$mn:000065B2                                         ; DATA XREF: .xdata$x:0000E730o
.text$mn:000065B2                 mov     ecx, [ebp-18h]
.text$mn:000065B5                 call    ?_Tidy@?$vector@DV?$allocator@D@std@@@std@@IAEXXZ ; std::vector<char,std::allocator<char>>::_Tidy(void)
.text$mn:000065BA                 push    0
.text$mn:000065BC                 push    0
.text$mn:000065BE                 call    __CxxThrowException@8 ; _CxxThrowException(x,x)
.text$mn:000065BE __catch$??0?$vector@DV?$allocator@D@std@@@std@@QAE@I@Z$0 endp
.text$mn:000065BE
.text$mn:000065C3 ; ---------------------------------------------------------------------------
.text$mn:000065C3                 mov     eax, offset $LN9_1
.text$mn:000065C8                 retn
.text$mn:000065C9 ; ---------------------------------------------------------------------------
.text$mn:000065C9 ; START OF FUNCTION CHUNK FOR ??0?$vector@DV?$allocator@D@std@@@std@@QAE@I@Z
.text$mn:000065C9
.text$mn:000065C9 loc_65C9:                               ; CODE XREF: std::vector<char,std::allocator<char>>::vector<char,std::allocator<char>>(uint)+90j
.text$mn:000065C9                 mov     [ebp+var_4], 0
.text$mn:000065D0                 jmp     short loc_65D9
.text$mn:000065D0 ; END OF FUNCTION CHUNK FOR ??0?$vector@DV?$allocator@D@std@@@std@@QAE@I@Z
.text$mn:000065D2
.text$mn:000065D2 ; =============== S U B R O U T I N E =======================================
.text$mn:000065D2
.text$mn:000065D2
.text$mn:000065D2 $LN9_1          proc near               ; DATA XREF: .text$mn:000065C3o
.text$mn:000065D2                 mov     dword ptr [ebp-4], 0
.text$mn:000065D2 $LN9_1          endp ; sp-analysis failed
.text$mn:000065D2
.text$mn:000065D9 ; START OF FUNCTION CHUNK FOR ??0?$vector@DV?$allocator@D@std@@@std@@QAE@I@Z
.text$mn:000065D9
.text$mn:000065D9 loc_65D9:                               ; CODE XREF: std::vector<char,std::allocator<char>>::vector<char,std::allocator<char>>(uint)+58j
.text$mn:000065D9                                         ; std::vector<char,std::allocator<char>>::vector<char,std::allocator<char>>(uint)+B0j
.text$mn:000065D9                 mov     [ebp+var_4], 0FFFFFFFFh
.text$mn:000065E0                 mov     eax, [ebp+var_18]
.text$mn:000065E3                 mov     ecx, [ebp+var_C]
.text$mn:000065E6                 mov     large fs:0, ecx
.text$mn:000065ED                 pop     ecx
.text$mn:000065EE                 pop     edi
.text$mn:000065EF                 pop     esi
.text$mn:000065F0                 pop     ebx
.text$mn:000065F1                 mov     esp, ebp
.text$mn:000065F3                 pop     ebp
.text$mn:000065F4                 retn    4
.text$mn:000065F4 ; END OF FUNCTION CHUNK FOR ??0?$vector@DV?$allocator@D@std@@@std@@QAE@I@Z
.text$mn:000065F4 ; ---------------------------------------------------------------------------
.text$mn:000065F7                 align 4
.text$mn:000065F7 _text$mn        ends
.text$mn:000065F7
.text$x:000065F8 ; ===========================================================================
.text$x:000065F8
.text$x:000065F8 ; Segment type: Pure code
.text$x:000065F8 ; Segment permissions: Read/Execute
.text$x:000065F8 _text$x         segment para public 'CODE' use32
.text$x:000065F8                 assume cs:_text$x
.text$x:000065F8                 ;org 65F8h
.text$x:000065F8 ; COMDAT (pick associative to section at 6520)
.text$x:000065F8                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text$x:000065F8
.text$x:000065F8 ; =============== S U B R O U T I N E =======================================
.text$x:000065F8
.text$x:000065F8
.text$x:000065F8 __unwindfunclet$??0?$vector@DV?$allocator@D@std@@@std@@QAE@I@Z$2 proc near
.text$x:000065F8                                         ; DATA XREF: .xdata$x:0000E74Co
.text$x:000065F8                 mov     ecx, [ebp-18h]
.text$x:000065FB                 jmp     ??1?$_Vector_alloc@$0A@U?$_Vec_base_types@DV?$allocator@D@std@@@std@@@std@@QAE@XZ ; std::_Vector_alloc<0,std::_Vec_base_types<char,std::allocator<char>>>::~_Vector_alloc<0,std::_Vec_base_types<char,std::allocator<char>>>(void)
.text$x:000065FB __unwindfunclet$??0?$vector@DV?$allocator@D@std@@@std@@QAE@I@Z$2 endp
.text$x:000065FB
.text$x:00006600
.text$x:00006600 ; =============== S U B R O U T I N E =======================================
.text$x:00006600
.text$x:00006600
.text$x:00006600 __ehhandler$??0?$vector@DV?$allocator@D@std@@@std@@QAE@I@Z proc near
.text$x:00006600                                         ; DATA XREF: std::vector<char,std::allocator<char>>::vector<char,std::allocator<char>>(uint)+5o
.text$x:00006600
.text$x:00006600 arg_4           = dword ptr  8
.text$x:00006600
.text$x:00006600                 mov     edx, [esp+arg_4]
.text$x:00006604                 lea     eax, [edx+0Ch]
.text$x:00006607                 mov     ecx, [edx-1Ch]
.text$x:0000660A                 xor     ecx, eax
.text$x:0000660C                 call    @__security_check_cookie@4 ; __security_check_cookie(x)
.text$x:00006611                 mov     eax, offset __ehfuncinfo$??0?$vector@DV?$allocator@D@std@@@std@@QAE@I@Z
.text$x:00006616                 jmp     ___CxxFrameHandler3
.text$x:00006616 __ehhandler$??0?$vector@DV?$allocator@D@std@@@std@@QAE@I@Z endp
.text$x:00006616
.text$x:00006616 ; ---------------------------------------------------------------------------
.text$x:0000661B                 align 4
.text$x:0000661B _text$x         ends
.text$x:0000661B
.text$mn:0000661C ; ===========================================================================
.text$mn:0000661C
.text$mn:0000661C ; Segment type: Pure code
.text$mn:0000661C ; Segment permissions: Read/Execute
.text$mn:0000661C _text$mn        segment para public 'CODE' use32
.text$mn:0000661C                 assume cs:_text$mn
.text$mn:0000661C                 ;org 661Ch
.text$mn:0000661C ; COMDAT (pick any)
.text$mn:0000661C                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text$mn:0000661C
.text$mn:0000661C ; =============== S U B R O U T I N E =======================================
.text$mn:0000661C
.text$mn:0000661C ; Attributes: bp-based frame
.text$mn:0000661C
.text$mn:0000661C ; public: __thiscall std::vector<class std::basic_string<wchar_t, struct std::char_traits<wchar_t>, class std::allocator<wchar_t>>, class std::allocator<class std::basic_string<wchar_t, struct std::char_traits<wchar_t>, class std::allocator<wchar_t>>>>::vector<class std::basic_string<wchar_t, struct std::char_traits<wchar_t>, class std::allocator<wchar_t>>, class std::allocator<class std::basic_string<wchar_t, struct std::char_traits<wchar_t>, class std::allocator<wchar_t>>>>(class std::vector<class std::basic_string<wchar_t, struct std::char_traits<wchar_t>, class std::allocator<wchar_t>>, class std::allocator<class std::basic_string<wchar_t, struct std::char_traits<wchar_t>, class std::allocator<wchar_t>>>> &&)
.text$mn:0000661C                 public ??0?$vector@V?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@V?$allocator@V?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@@2@@std@@QAE@$$QAV01@@Z
.text$mn:0000661C ??0?$vector@V?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@V?$allocator@V?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@@2@@std@@QAE@$$QAV01@@Z proc near
.text$mn:0000661C                                         ; CODE XREF: tokenizeString(std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>> const &,char)+FAp
.text$mn:0000661C                                         ; stringSplit(std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>> const &,std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>> const &)+106p
.text$mn:0000661C
.text$mn:0000661C var_14          = dword ptr -14h
.text$mn:0000661C var_E           = byte ptr -0Eh
.text$mn:0000661C var_D           = byte ptr -0Dh
.text$mn:0000661C var_C           = dword ptr -0Ch
.text$mn:0000661C var_4           = dword ptr -4
.text$mn:0000661C arg_0           = dword ptr  8
.text$mn:0000661C
.text$mn:0000661C                 push    ebp
.text$mn:0000661D                 mov     ebp, esp
.text$mn:0000661F                 push    0FFFFFFFFh
.text$mn:00006621                 push    offset __ehhandler$??0?$vector@V?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@V?$allocator@V?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@@2@@std@@QAE@$$QAV01@@Z
.text$mn:00006626                 mov     eax, large fs:0
.text$mn:0000662C                 push    eax
.text$mn:0000662D                 sub     esp, 8
.text$mn:00006630                 mov     eax, dword ptr ds:___security_cookie
.text$mn:00006635                 xor     eax, ebp
.text$mn:00006637                 push    eax
.text$mn:00006638                 lea     eax, [ebp+var_C]
.text$mn:0000663B                 mov     large fs:0, eax
.text$mn:00006641                 mov     [ebp+var_14], ecx
.text$mn:00006644                 lea     eax, [ebp+var_E]
.text$mn:00006647                 push    eax
.text$mn:00006648                 mov     ecx, [ebp+arg_0]
.text$mn:0000664B                 call    ?_Getal@?$_Vector_alloc@$0A@U?$_Vec_base_types@V?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@V?$allocator@V?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@@2@@std@@@std@@QBE?AU?$_Wrap_alloc@V?$allocator@V?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@@std@@@2@XZ ; std::_Vector_alloc<0,std::_Vec_base_types<std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>>,std::allocator<std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>>>>>::_Getal(void)
.text$mn:00006650                 push    eax
.text$mn:00006651                 mov     ecx, [ebp+var_14]
.text$mn:00006654                 call    ??0?$_Vector_alloc@$0A@U?$_Vec_base_types@V?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@V?$allocator@V?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@@2@@std@@@std@@QAE@ABV?$allocator@V?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@@1@@Z ; std::_Vector_alloc<0,std::_Vec_base_types<std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>>,std::allocator<std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>>>>>::_Vector_alloc<0,std::_Vec_base_types<std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>>,std::allocator<std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>>>>>(std::allocator<std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>>> const &)
.text$mn:00006659                 mov     [ebp+var_4], 0
.text$mn:00006660                 xor     ecx, ecx
.text$mn:00006662                 mov     [ebp+var_D], cl
.text$mn:00006665                 movzx   edx, [ebp+var_D]
.text$mn:00006669                 push    edx             ; int
.text$mn:0000666A                 mov     eax, [ebp+arg_0]
.text$mn:0000666D                 push    eax
.text$mn:0000666E                 call    ??$forward@V?$vector@V?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@V?$allocator@V?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@@2@@std@@@std@@YA$$QAV?$vector@V?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@V?$allocator@V?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@@2@@0@AAV10@@Z ; std::forward<std::vector<std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>>,std::allocator<std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>>>>>(std::vector<std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>>,std::allocator<std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>>>> &)
.text$mn:00006673                 add     esp, 4
.text$mn:00006676                 push    eax             ; struct std::_Container_base12 *
.text$mn:00006677                 mov     ecx, [ebp+var_14]
.text$mn:0000667A                 call    ?_Assign_rv@?$vector@V?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@V?$allocator@V?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@@2@@std@@QAEX$$QAV12@U?$integral_constant@_N$00@2@@Z ; std::vector<std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>>,std::allocator<std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>>>>::_Assign_rv(std::vector<std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>>,std::allocator<std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>>>> &&,std::integral_constant<bool,1>)
.text$mn:0000667F                 mov     [ebp+var_4], 0FFFFFFFFh
.text$mn:00006686                 mov     eax, [ebp+var_14]
.text$mn:00006689                 mov     ecx, [ebp+var_C]
.text$mn:0000668C                 mov     large fs:0, ecx
.text$mn:00006693                 pop     ecx
.text$mn:00006694                 mov     esp, ebp
.text$mn:00006696                 pop     ebp
.text$mn:00006697                 retn    4
.text$mn:00006697 ??0?$vector@V?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@V?$allocator@V?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@@2@@std@@QAE@$$QAV01@@Z endp
.text$mn:00006697
.text$mn:00006697 ; ---------------------------------------------------------------------------
.text$mn:0000669A                 align 4
.text$mn:0000669A _text$mn        ends
.text$mn:0000669A
.text$x:0000669C ; ===========================================================================
.text$x:0000669C
.text$x:0000669C ; Segment type: Pure code
.text$x:0000669C ; Segment permissions: Read/Execute
.text$x:0000669C _text$x         segment para public 'CODE' use32
.text$x:0000669C                 assume cs:_text$x
.text$x:0000669C                 ;org 669Ch
.text$x:0000669C ; COMDAT (pick associative to section at 661C)
.text$x:0000669C                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text$x:0000669C
.text$x:0000669C ; =============== S U B R O U T I N E =======================================
.text$x:0000669C
.text$x:0000669C
.text$x:0000669C __unwindfunclet$??0?$vector@V?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@V?$allocator@V?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@@2@@std@@QAE@$$QAV01@@Z$0 proc near
.text$x:0000669C                                         ; DATA XREF: .xdata$x:0000E2E0o
.text$x:0000669C                 mov     ecx, [ebp-14h]
.text$x:0000669F                 jmp     ??1?$_Vector_alloc@$0A@U?$_Vec_base_types@V?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@V?$allocator@V?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@@2@@std@@@std@@QAE@XZ ; std::_Vector_alloc<0,std::_Vec_base_types<std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>>,std::allocator<std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>>>>>::~_Vector_alloc<0,std::_Vec_base_types<std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>>,std::allocator<std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>>>>>(void)
.text$x:0000669F __unwindfunclet$??0?$vector@V?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@V?$allocator@V?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@@2@@std@@QAE@$$QAV01@@Z$0 endp
.text$x:0000669F
.text$x:000066A4
.text$x:000066A4 ; =============== S U B R O U T I N E =======================================
.text$x:000066A4
.text$x:000066A4
.text$x:000066A4 __ehhandler$??0?$vector@V?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@V?$allocator@V?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@@2@@std@@QAE@$$QAV01@@Z proc near
.text$x:000066A4                                         ; DATA XREF: std::vector<std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>>,std::allocator<std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>>>>::vector<std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>>,std::allocator<std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>>>>(std::vector<std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>>,std::allocator<std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>>>> &&)+5o
.text$x:000066A4
.text$x:000066A4 arg_4           = dword ptr  8
.text$x:000066A4
.text$x:000066A4                 mov     edx, [esp+arg_4]
.text$x:000066A8                 lea     eax, [edx+0Ch]
.text$x:000066AB                 mov     ecx, [edx-0Ch]
.text$x:000066AE                 xor     ecx, eax
.text$x:000066B0                 call    @__security_check_cookie@4 ; __security_check_cookie(x)
.text$x:000066B5                 mov     eax, offset __ehfuncinfo$??0?$vector@V?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@V?$allocator@V?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@@2@@std@@QAE@$$QAV01@@Z
.text$x:000066BA                 jmp     ___CxxFrameHandler3
.text$x:000066BA __ehhandler$??0?$vector@V?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@V?$allocator@V?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@@2@@std@@QAE@$$QAV01@@Z endp
.text$x:000066BA
.text$x:000066BA ; ---------------------------------------------------------------------------
.text$x:000066BF                 align 10h
.text$x:000066BF _text$x         ends
.text$x:000066BF
.text$mn:000066C0 ; ===========================================================================
.text$mn:000066C0
.text$mn:000066C0 ; Segment type: Pure code
.text$mn:000066C0 ; Segment permissions: Read/Execute
.text$mn:000066C0 _text$mn        segment para public 'CODE' use32
.text$mn:000066C0                 assume cs:_text$mn
.text$mn:000066C0                 ;org 66C0h
.text$mn:000066C0 ; COMDAT (pick any)
.text$mn:000066C0                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text$mn:000066C0
.text$mn:000066C0 ; =============== S U B R O U T I N E =======================================
.text$mn:000066C0
.text$mn:000066C0 ; Attributes: bp-based frame
.text$mn:000066C0
.text$mn:000066C0 ; public: __thiscall std::vector<class std::basic_string<wchar_t, struct std::char_traits<wchar_t>, class std::allocator<wchar_t>>, class std::allocator<class std::basic_string<wchar_t, struct std::char_traits<wchar_t>, class std::allocator<wchar_t>>>>::vector<class std::basic_string<wchar_t, struct std::char_traits<wchar_t>, class std::allocator<wchar_t>>, class std::allocator<class std::basic_string<wchar_t, struct std::char_traits<wchar_t>, class std::allocator<wchar_t>>>>(void)
.text$mn:000066C0                 public ??0?$vector@V?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@V?$allocator@V?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@@2@@std@@QAE@XZ
.text$mn:000066C0 ??0?$vector@V?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@V?$allocator@V?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@@2@@std@@QAE@XZ proc near
.text$mn:000066C0                                         ; CODE XREF: tokenizeString(std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>> const &,char)+32p
.text$mn:000066C0                                         ; stringSplit(std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>> const &,std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>> const &)+4Ap
.text$mn:000066C0
.text$mn:000066C0 var_14          = dword ptr -14h
.text$mn:000066C0 var_D           = byte ptr -0Dh
.text$mn:000066C0 var_C           = dword ptr -0Ch
.text$mn:000066C0 var_4           = dword ptr -4
.text$mn:000066C0
.text$mn:000066C0                 push    ebp
.text$mn:000066C1                 mov     ebp, esp
.text$mn:000066C3                 push    0FFFFFFFFh
.text$mn:000066C5                 push    offset __ehhandler$??0?$vector@V?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@V?$allocator@V?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@@2@@std@@QAE@XZ
.text$mn:000066CA                 mov     eax, large fs:0
.text$mn:000066D0                 push    eax
.text$mn:000066D1                 sub     esp, 8
.text$mn:000066D4                 mov     eax, dword ptr ds:___security_cookie
.text$mn:000066D9                 xor     eax, ebp
.text$mn:000066DB                 push    eax
.text$mn:000066DC                 lea     eax, [ebp+var_C]
.text$mn:000066DF                 mov     large fs:0, eax
.text$mn:000066E5                 mov     [ebp+var_14], ecx
.text$mn:000066E8                 lea     ecx, [ebp+var_D]
.text$mn:000066EB                 call    ??0?$allocator@V?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@@std@@QAE@XZ ; std::allocator<std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>>>::allocator<std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>>>(void)
.text$mn:000066F0                 push    eax
.text$mn:000066F1                 mov     ecx, [ebp+var_14]
.text$mn:000066F4                 call    ??0?$_Vector_alloc@$0A@U?$_Vec_base_types@V?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@V?$allocator@V?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@@2@@std@@@std@@QAE@ABV?$allocator@V?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@@1@@Z ; std::_Vector_alloc<0,std::_Vec_base_types<std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>>,std::allocator<std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>>>>>::_Vector_alloc<0,std::_Vec_base_types<std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>>,std::allocator<std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>>>>>(std::allocator<std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>>> const &)
.text$mn:000066F9                 mov     [ebp+var_4], 0
.text$mn:00006700                 mov     [ebp+var_4], 0FFFFFFFFh
.text$mn:00006707                 mov     eax, [ebp+var_14]
.text$mn:0000670A                 mov     ecx, [ebp+var_C]
.text$mn:0000670D                 mov     large fs:0, ecx
.text$mn:00006714                 pop     ecx
.text$mn:00006715                 mov     esp, ebp
.text$mn:00006717                 pop     ebp
.text$mn:00006718                 retn
.text$mn:00006718 ??0?$vector@V?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@V?$allocator@V?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@@2@@std@@QAE@XZ endp
.text$mn:00006718
.text$mn:00006718 ; ---------------------------------------------------------------------------
.text$mn:00006719                 align 4
.text$mn:00006719 _text$mn        ends
.text$mn:00006719
.text$x:0000671C ; ===========================================================================
.text$x:0000671C
.text$x:0000671C ; Segment type: Pure code
.text$x:0000671C ; Segment permissions: Read/Execute
.text$x:0000671C _text$x         segment para public 'CODE' use32
.text$x:0000671C                 assume cs:_text$x
.text$x:0000671C                 ;org 671Ch
.text$x:0000671C ; COMDAT (pick associative to section at 66C0)
.text$x:0000671C                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text$x:0000671C
.text$x:0000671C ; =============== S U B R O U T I N E =======================================
.text$x:0000671C
.text$x:0000671C
.text$x:0000671C __unwindfunclet$??0?$vector@V?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@V?$allocator@V?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@@2@@std@@QAE@XZ$0 proc near
.text$x:0000671C                                         ; DATA XREF: .xdata$x:0000E2B4o
.text$x:0000671C                 mov     ecx, [ebp-14h]
.text$x:0000671F                 jmp     ??1?$_Vector_alloc@$0A@U?$_Vec_base_types@V?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@V?$allocator@V?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@@2@@std@@@std@@QAE@XZ ; std::_Vector_alloc<0,std::_Vec_base_types<std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>>,std::allocator<std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>>>>>::~_Vector_alloc<0,std::_Vec_base_types<std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>>,std::allocator<std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>>>>>(void)
.text$x:0000671F __unwindfunclet$??0?$vector@V?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@V?$allocator@V?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@@2@@std@@QAE@XZ$0 endp
.text$x:0000671F
.text$x:00006724
.text$x:00006724 ; =============== S U B R O U T I N E =======================================
.text$x:00006724
.text$x:00006724
.text$x:00006724 __ehhandler$??0?$vector@V?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@V?$allocator@V?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@@2@@std@@QAE@XZ proc near
.text$x:00006724                                         ; DATA XREF: std::vector<std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>>,std::allocator<std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>>>>::vector<std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>>,std::allocator<std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>>>>(void)+5o
.text$x:00006724
.text$x:00006724 arg_4           = dword ptr  8
.text$x:00006724
.text$x:00006724                 mov     edx, [esp+arg_4]
.text$x:00006728                 lea     eax, [edx+0Ch]
.text$x:0000672B                 mov     ecx, [edx-0Ch]
.text$x:0000672E                 xor     ecx, eax
.text$x:00006730                 call    @__security_check_cookie@4 ; __security_check_cookie(x)
.text$x:00006735                 mov     eax, offset __ehfuncinfo$??0?$vector@V?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@V?$allocator@V?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@@2@@std@@QAE@XZ
.text$x:0000673A                 jmp     ___CxxFrameHandler3
.text$x:0000673A __ehhandler$??0?$vector@V?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@V?$allocator@V?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@@2@@std@@QAE@XZ endp
.text$x:0000673A
.text$x:0000673A ; ---------------------------------------------------------------------------
.text$x:0000673F                 align 10h
.text$x:0000673F _text$x         ends
.text$x:0000673F
.text$mn:00006740 ; ===========================================================================
.text$mn:00006740
.text$mn:00006740 ; Segment type: Pure code
.text$mn:00006740 ; Segment permissions: Read/Execute
.text$mn:00006740 _text$mn        segment para public 'CODE' use32
.text$mn:00006740                 assume cs:_text$mn
.text$mn:00006740                 ;org 6740h
.text$mn:00006740 ; COMDAT (pick any)
.text$mn:00006740                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text$mn:00006740
.text$mn:00006740 ; =============== S U B R O U T I N E =======================================
.text$mn:00006740
.text$mn:00006740 ; Attributes: bp-based frame
.text$mn:00006740
.text$mn:00006740 ; public: __thiscall std::vector<wchar_t, class std::allocator<wchar_t>>::vector<wchar_t, class std::allocator<wchar_t>>(unsigned int)
.text$mn:00006740                 public ??0?$vector@_WV?$allocator@_W@std@@@std@@QAE@I@Z
.text$mn:00006740 ??0?$vector@_WV?$allocator@_W@std@@@std@@QAE@I@Z proc near
.text$mn:00006740                                         ; CODE XREF: string2wstring(std::basic_string<char,std::char_traits<char>,std::allocator<char>> const &,uint)+57p
.text$mn:00006740                                         ; BuildMenuFileName(int,uint,std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>> const &)+EAp
.text$mn:00006740
.text$mn:00006740 var_18          = dword ptr -18h
.text$mn:00006740 var_12          = byte ptr -12h
.text$mn:00006740 var_11          = byte ptr -11h
.text$mn:00006740 var_10          = dword ptr -10h
.text$mn:00006740 var_C           = dword ptr -0Ch
.text$mn:00006740 var_4           = dword ptr -4
.text$mn:00006740 arg_0           = dword ptr  8
.text$mn:00006740
.text$mn:00006740 ; FUNCTION CHUNK AT .text$mn:000067EC SIZE 00000009 BYTES
.text$mn:00006740 ; FUNCTION CHUNK AT .text$mn:000067FC SIZE 0000001E BYTES
.text$mn:00006740
.text$mn:00006740                 push    ebp
.text$mn:00006741                 mov     ebp, esp
.text$mn:00006743                 push    0FFFFFFFFh
.text$mn:00006745                 push    offset __ehhandler$??0?$vector@_WV?$allocator@_W@std@@@std@@QAE@I@Z
.text$mn:0000674A                 mov     eax, large fs:0
.text$mn:00006750                 push    eax
.text$mn:00006751                 push    ecx
.text$mn:00006752                 sub     esp, 8
.text$mn:00006755                 push    ebx
.text$mn:00006756                 push    esi
.text$mn:00006757                 push    edi
.text$mn:00006758                 mov     eax, dword ptr ds:___security_cookie
.text$mn:0000675D                 xor     eax, ebp
.text$mn:0000675F                 push    eax
.text$mn:00006760                 lea     eax, [ebp+var_C]
.text$mn:00006763                 mov     large fs:0, eax
.text$mn:00006769                 mov     [ebp+var_10], esp
.text$mn:0000676C                 mov     [ebp+var_18], ecx
.text$mn:0000676F                 lea     ecx, [ebp+var_12]
.text$mn:00006772                 call    ??0?$allocator@_W@std@@QAE@XZ ; std::allocator<wchar_t>::allocator<wchar_t>(void)
.text$mn:00006777                 push    eax
.text$mn:00006778                 mov     ecx, [ebp+var_18]
.text$mn:0000677B                 call    ??0?$_Vector_alloc@$0A@U?$_Vec_base_types@_WV?$allocator@_W@std@@@std@@@std@@QAE@ABV?$allocator@_W@1@@Z ; std::_Vector_alloc<0,std::_Vec_base_types<wchar_t,std::allocator<wchar_t>>>::_Vector_alloc<0,std::_Vec_base_types<wchar_t,std::allocator<wchar_t>>>(std::allocator<wchar_t> const &)
.text$mn:00006780                 mov     [ebp+var_4], 0
.text$mn:00006787                 mov     eax, [ebp+arg_0]
.text$mn:0000678A                 push    eax
.text$mn:0000678B                 mov     ecx, [ebp+var_18]
.text$mn:0000678E                 call    ?_Buy@?$vector@_WV?$allocator@_W@std@@@std@@IAE_NI@Z ; std::vector<wchar_t,std::allocator<wchar_t>>::_Buy(uint)
.text$mn:00006793                 movzx   ecx, al
.text$mn:00006796                 test    ecx, ecx
.text$mn:00006798                 jz      short loc_67FC
.text$mn:0000679A                 lea     edx, [ebp+var_11]
.text$mn:0000679D                 push    edx
.text$mn:0000679E                 mov     ecx, [ebp+var_18]
.text$mn:000067A1                 call    ?_Getal@?$_Vector_alloc@$0A@U?$_Vec_base_types@_WV?$allocator@_W@std@@@std@@@std@@QBE?AU?$_Wrap_alloc@V?$allocator@_W@std@@@2@XZ ; std::_Vector_alloc<0,std::_Vec_base_types<wchar_t,std::allocator<wchar_t>>>::_Getal(void)
.text$mn:000067A6                 mov     byte ptr [ebp+var_4], 1
.text$mn:000067AA                 lea     eax, [ebp+var_11]
.text$mn:000067AD                 push    eax
.text$mn:000067AE                 mov     ecx, [ebp+arg_0]
.text$mn:000067B1                 push    ecx
.text$mn:000067B2                 mov     edx, [ebp+var_18]
.text$mn:000067B5                 mov     eax, [edx+4]
.text$mn:000067B8                 push    eax
.text$mn:000067B9                 call    ??$_Uninitialized_default_fill_n@PA_WIU?$_Wrap_alloc@V?$allocator@_W@std@@@std@@@std@@YAXPA_WIAAU?$_Wrap_alloc@V?$allocator@_W@std@@@0@@Z ; std::_Uninitialized_default_fill_n<wchar_t *,uint,std::_Wrap_alloc<std::allocator<wchar_t>>>(wchar_t *,uint,std::_Wrap_alloc<std::allocator<wchar_t>> &)
.text$mn:000067BE                 add     esp, 0Ch
.text$mn:000067C1                 mov     ecx, [ebp+var_18]
.text$mn:000067C4                 mov     edx, [ecx+8]
.text$mn:000067C7                 mov     eax, [ebp+arg_0]
.text$mn:000067CA                 lea     ecx, [edx+eax*2]
.text$mn:000067CD                 mov     edx, [ebp+var_18]
.text$mn:000067D0                 mov     [edx+8], ecx
.text$mn:000067D3                 jmp     short loc_67EC
.text$mn:000067D3 ??0?$vector@_WV?$allocator@_W@std@@@std@@QAE@I@Z endp
.text$mn:000067D3
.text$mn:000067D5
.text$mn:000067D5 ; =============== S U B R O U T I N E =======================================
.text$mn:000067D5
.text$mn:000067D5 ; Attributes: noreturn
.text$mn:000067D5
.text$mn:000067D5 __catch$??0?$vector@_WV?$allocator@_W@std@@@std@@QAE@I@Z$0 proc near
.text$mn:000067D5                                         ; DATA XREF: .xdata$x:0000E4A0o
.text$mn:000067D5                 mov     ecx, [ebp-18h]
.text$mn:000067D8                 call    ?_Tidy@?$vector@_WV?$allocator@_W@std@@@std@@IAEXXZ ; std::vector<wchar_t,std::allocator<wchar_t>>::_Tidy(void)
.text$mn:000067DD                 push    0
.text$mn:000067DF                 push    0
.text$mn:000067E1                 call    __CxxThrowException@8 ; _CxxThrowException(x,x)
.text$mn:000067E1 __catch$??0?$vector@_WV?$allocator@_W@std@@@std@@QAE@I@Z$0 endp
.text$mn:000067E1
.text$mn:000067E6 ; ---------------------------------------------------------------------------
.text$mn:000067E6                 mov     eax, offset $LN9_0
.text$mn:000067EB                 retn
.text$mn:000067EC ; ---------------------------------------------------------------------------
.text$mn:000067EC ; START OF FUNCTION CHUNK FOR ??0?$vector@_WV?$allocator@_W@std@@@std@@QAE@I@Z
.text$mn:000067EC
.text$mn:000067EC loc_67EC:                               ; CODE XREF: std::vector<wchar_t,std::allocator<wchar_t>>::vector<wchar_t,std::allocator<wchar_t>>(uint)+93j
.text$mn:000067EC                 mov     [ebp+var_4], 0
.text$mn:000067F3                 jmp     short loc_67FC
.text$mn:000067F3 ; END OF FUNCTION CHUNK FOR ??0?$vector@_WV?$allocator@_W@std@@@std@@QAE@I@Z
.text$mn:000067F5
.text$mn:000067F5 ; =============== S U B R O U T I N E =======================================
.text$mn:000067F5
.text$mn:000067F5
.text$mn:000067F5 $LN9_0          proc near               ; DATA XREF: .text$mn:000067E6o
.text$mn:000067F5                 mov     dword ptr [ebp-4], 0
.text$mn:000067F5 $LN9_0          endp ; sp-analysis failed
.text$mn:000067F5
.text$mn:000067FC ; START OF FUNCTION CHUNK FOR ??0?$vector@_WV?$allocator@_W@std@@@std@@QAE@I@Z
.text$mn:000067FC
.text$mn:000067FC loc_67FC:                               ; CODE XREF: std::vector<wchar_t,std::allocator<wchar_t>>::vector<wchar_t,std::allocator<wchar_t>>(uint)+58j
.text$mn:000067FC                                         ; std::vector<wchar_t,std::allocator<wchar_t>>::vector<wchar_t,std::allocator<wchar_t>>(uint)+B3j
.text$mn:000067FC                 mov     [ebp+var_4], 0FFFFFFFFh
.text$mn:00006803                 mov     eax, [ebp+var_18]
.text$mn:00006806                 mov     ecx, [ebp+var_C]
.text$mn:00006809                 mov     large fs:0, ecx
.text$mn:00006810                 pop     ecx
.text$mn:00006811                 pop     edi
.text$mn:00006812                 pop     esi
.text$mn:00006813                 pop     ebx
.text$mn:00006814                 mov     esp, ebp
.text$mn:00006816                 pop     ebp
.text$mn:00006817                 retn    4
.text$mn:00006817 ; END OF FUNCTION CHUNK FOR ??0?$vector@_WV?$allocator@_W@std@@@std@@QAE@I@Z
.text$mn:00006817 ; ---------------------------------------------------------------------------
.text$mn:0000681A                 align 4
.text$mn:0000681A _text$mn        ends
.text$mn:0000681A
.text$x:0000681C ; ===========================================================================
.text$x:0000681C
.text$x:0000681C ; Segment type: Pure code
.text$x:0000681C ; Segment permissions: Read/Execute
.text$x:0000681C _text$x         segment para public 'CODE' use32
.text$x:0000681C                 assume cs:_text$x
.text$x:0000681C                 ;org 681Ch
.text$x:0000681C ; COMDAT (pick associative to section at 6740)
.text$x:0000681C                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text$x:0000681C
.text$x:0000681C ; =============== S U B R O U T I N E =======================================
.text$x:0000681C
.text$x:0000681C
.text$x:0000681C __unwindfunclet$??0?$vector@_WV?$allocator@_W@std@@@std@@QAE@I@Z$2 proc near
.text$x:0000681C                                         ; DATA XREF: .xdata$x:0000E4BCo
.text$x:0000681C                 mov     ecx, [ebp-18h]
.text$x:0000681F                 jmp     ??1?$_Vector_alloc@$0A@U?$_Vec_base_types@_WV?$allocator@_W@std@@@std@@@std@@QAE@XZ ; std::_Vector_alloc<0,std::_Vec_base_types<wchar_t,std::allocator<wchar_t>>>::~_Vector_alloc<0,std::_Vec_base_types<wchar_t,std::allocator<wchar_t>>>(void)
.text$x:0000681F __unwindfunclet$??0?$vector@_WV?$allocator@_W@std@@@std@@QAE@I@Z$2 endp
.text$x:0000681F
.text$x:00006824
.text$x:00006824 ; =============== S U B R O U T I N E =======================================
.text$x:00006824
.text$x:00006824
.text$x:00006824 __ehhandler$??0?$vector@_WV?$allocator@_W@std@@@std@@QAE@I@Z proc near
.text$x:00006824                                         ; DATA XREF: std::vector<wchar_t,std::allocator<wchar_t>>::vector<wchar_t,std::allocator<wchar_t>>(uint)+5o
.text$x:00006824
.text$x:00006824 arg_4           = dword ptr  8
.text$x:00006824
.text$x:00006824                 mov     edx, [esp+arg_4]
.text$x:00006828                 lea     eax, [edx+0Ch]
.text$x:0000682B                 mov     ecx, [edx-1Ch]
.text$x:0000682E                 xor     ecx, eax
.text$x:00006830                 call    @__security_check_cookie@4 ; __security_check_cookie(x)
.text$x:00006835                 mov     eax, offset __ehfuncinfo$??0?$vector@_WV?$allocator@_W@std@@@std@@QAE@I@Z
.text$x:0000683A                 jmp     ___CxxFrameHandler3
.text$x:0000683A __ehhandler$??0?$vector@_WV?$allocator@_W@std@@@std@@QAE@I@Z endp
.text$x:0000683A
.text$x:0000683A ; ---------------------------------------------------------------------------
.text$x:0000683F                 align 10h
.text$x:0000683F _text$x         ends
.text$x:0000683F
.text$mn:00006840 ; ===========================================================================
.text$mn:00006840
.text$mn:00006840 ; Segment type: Pure code
.text$mn:00006840 ; Segment permissions: Read/Execute
.text$mn:00006840 _text$mn        segment para public 'CODE' use32
.text$mn:00006840                 assume cs:_text$mn
.text$mn:00006840                 ;org 6840h
.text$mn:00006840 ; COMDAT (pick any)
.text$mn:00006840                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text$mn:00006840
.text$mn:00006840 ; =============== S U B R O U T I N E =======================================
.text$mn:00006840
.text$mn:00006840 ; Attributes: bp-based frame
.text$mn:00006840
.text$mn:00006840 ; public: __thiscall std::vector<wchar_t, class std::allocator<wchar_t>>::vector<wchar_t, class std::allocator<wchar_t>>(void)
.text$mn:00006840                 public ??0?$vector@_WV?$allocator@_W@std@@@std@@QAE@XZ
.text$mn:00006840 ??0?$vector@_WV?$allocator@_W@std@@@std@@QAE@XZ proc near
.text$mn:00006840                                         ; CODE XREF: intToString(int)+32p
.text$mn:00006840                                         ; uintToString(uint)+32p
.text$mn:00006840
.text$mn:00006840 var_14          = dword ptr -14h
.text$mn:00006840 var_D           = byte ptr -0Dh
.text$mn:00006840 var_C           = dword ptr -0Ch
.text$mn:00006840 var_4           = dword ptr -4
.text$mn:00006840
.text$mn:00006840                 push    ebp
.text$mn:00006841                 mov     ebp, esp
.text$mn:00006843                 push    0FFFFFFFFh
.text$mn:00006845                 push    offset __ehhandler$??0?$vector@_WV?$allocator@_W@std@@@std@@QAE@XZ
.text$mn:0000684A                 mov     eax, large fs:0
.text$mn:00006850                 push    eax
.text$mn:00006851                 sub     esp, 8
.text$mn:00006854                 mov     eax, dword ptr ds:___security_cookie
.text$mn:00006859                 xor     eax, ebp
.text$mn:0000685B                 push    eax
.text$mn:0000685C                 lea     eax, [ebp+var_C]
.text$mn:0000685F                 mov     large fs:0, eax
.text$mn:00006865                 mov     [ebp+var_14], ecx
.text$mn:00006868                 lea     ecx, [ebp+var_D]
.text$mn:0000686B                 call    ??0?$allocator@_W@std@@QAE@XZ ; std::allocator<wchar_t>::allocator<wchar_t>(void)
.text$mn:00006870                 push    eax
.text$mn:00006871                 mov     ecx, [ebp+var_14]
.text$mn:00006874                 call    ??0?$_Vector_alloc@$0A@U?$_Vec_base_types@_WV?$allocator@_W@std@@@std@@@std@@QAE@ABV?$allocator@_W@1@@Z ; std::_Vector_alloc<0,std::_Vec_base_types<wchar_t,std::allocator<wchar_t>>>::_Vector_alloc<0,std::_Vec_base_types<wchar_t,std::allocator<wchar_t>>>(std::allocator<wchar_t> const &)
.text$mn:00006879                 mov     [ebp+var_4], 0
.text$mn:00006880                 mov     [ebp+var_4], 0FFFFFFFFh
.text$mn:00006887                 mov     eax, [ebp+var_14]
.text$mn:0000688A                 mov     ecx, [ebp+var_C]
.text$mn:0000688D                 mov     large fs:0, ecx
.text$mn:00006894                 pop     ecx
.text$mn:00006895                 mov     esp, ebp
.text$mn:00006897                 pop     ebp
.text$mn:00006898                 retn
.text$mn:00006898 ??0?$vector@_WV?$allocator@_W@std@@@std@@QAE@XZ endp
.text$mn:00006898
.text$mn:00006898 ; ---------------------------------------------------------------------------
.text$mn:00006899                 align 4
.text$mn:00006899 _text$mn        ends
.text$mn:00006899
.text$x:0000689C ; ===========================================================================
.text$x:0000689C
.text$x:0000689C ; Segment type: Pure code
.text$x:0000689C ; Segment permissions: Read/Execute
.text$x:0000689C _text$x         segment para public 'CODE' use32
.text$x:0000689C                 assume cs:_text$x
.text$x:0000689C                 ;org 689Ch
.text$x:0000689C ; COMDAT (pick associative to section at 6840)
.text$x:0000689C                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text$x:0000689C
.text$x:0000689C ; =============== S U B R O U T I N E =======================================
.text$x:0000689C
.text$x:0000689C
.text$x:0000689C __unwindfunclet$??0?$vector@_WV?$allocator@_W@std@@@std@@QAE@XZ$0 proc near
.text$x:0000689C                                         ; DATA XREF: .xdata$x:0000E46Co
.text$x:0000689C                 mov     ecx, [ebp-14h]
.text$x:0000689F                 jmp     ??1?$_Vector_alloc@$0A@U?$_Vec_base_types@_WV?$allocator@_W@std@@@std@@@std@@QAE@XZ ; std::_Vector_alloc<0,std::_Vec_base_types<wchar_t,std::allocator<wchar_t>>>::~_Vector_alloc<0,std::_Vec_base_types<wchar_t,std::allocator<wchar_t>>>(void)
.text$x:0000689F __unwindfunclet$??0?$vector@_WV?$allocator@_W@std@@@std@@QAE@XZ$0 endp
.text$x:0000689F
.text$x:000068A4
.text$x:000068A4 ; =============== S U B R O U T I N E =======================================
.text$x:000068A4
.text$x:000068A4
.text$x:000068A4 __ehhandler$??0?$vector@_WV?$allocator@_W@std@@@std@@QAE@XZ proc near
.text$x:000068A4                                         ; DATA XREF: std::vector<wchar_t,std::allocator<wchar_t>>::vector<wchar_t,std::allocator<wchar_t>>(void)+5o
.text$x:000068A4
.text$x:000068A4 arg_4           = dword ptr  8
.text$x:000068A4
.text$x:000068A4                 mov     edx, [esp+arg_4]
.text$x:000068A8                 lea     eax, [edx+0Ch]
.text$x:000068AB                 mov     ecx, [edx-0Ch]
.text$x:000068AE                 xor     ecx, eax
.text$x:000068B0                 call    @__security_check_cookie@4 ; __security_check_cookie(x)
.text$x:000068B5                 mov     eax, offset __ehfuncinfo$??0?$vector@_WV?$allocator@_W@std@@@std@@QAE@XZ
.text$x:000068BA                 jmp     ___CxxFrameHandler3
.text$x:000068BA __ehhandler$??0?$vector@_WV?$allocator@_W@std@@@std@@QAE@XZ endp
.text$x:000068BA
.text$x:000068BA ; ---------------------------------------------------------------------------
.text$x:000068BF                 align 10h
.text$x:000068BF _text$x         ends
.text$x:000068BF
.text$mn:000068C0 ; ===========================================================================
.text$mn:000068C0
.text$mn:000068C0 ; Segment type: Pure code
.text$mn:000068C0 ; Segment permissions: Read/Execute
.text$mn:000068C0 _text$mn        segment para public 'CODE' use32
.text$mn:000068C0                 assume cs:_text$mn
.text$mn:000068C0                 ;org 68C0h
.text$mn:000068C0 ; COMDAT (pick any)
.text$mn:000068C0                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text$mn:000068C0
.text$mn:000068C0 ; =============== S U B R O U T I N E =======================================
.text$mn:000068C0
.text$mn:000068C0 ; Attributes: bp-based frame
.text$mn:000068C0
.text$mn:000068C0 ; _DWORD __thiscall WcharMbcsConvertor::WcharMbcsConvertor(WcharMbcsConvertor *__hidden this)
.text$mn:000068C0                 public ??0WcharMbcsConvertor@@IAE@XZ
.text$mn:000068C0 ??0WcharMbcsConvertor@@IAE@XZ proc near ; CODE XREF: `dynamic initializer for 'WcharMbcsConvertor * WcharMbcsConvertor::_pSelf''(void)+42p
.text$mn:000068C0
.text$mn:000068C0 var_10          = dword ptr -10h
.text$mn:000068C0 var_C           = dword ptr -0Ch
.text$mn:000068C0 var_4           = dword ptr -4
.text$mn:000068C0
.text$mn:000068C0                 push    ebp
.text$mn:000068C1                 mov     ebp, esp
.text$mn:000068C3                 push    0FFFFFFFFh
.text$mn:000068C5                 push    offset __ehhandler$??0WcharMbcsConvertor@@IAE@XZ
.text$mn:000068CA                 mov     eax, large fs:0
.text$mn:000068D0                 push    eax
.text$mn:000068D1                 push    ecx
.text$mn:000068D2                 mov     eax, dword ptr ds:___security_cookie
.text$mn:000068D7                 xor     eax, ebp
.text$mn:000068D9                 push    eax
.text$mn:000068DA                 lea     eax, [ebp+var_C]
.text$mn:000068DD                 mov     large fs:0, eax
.text$mn:000068E3                 mov     [ebp+var_10], ecx
.text$mn:000068E6                 mov     ecx, [ebp+var_10]
.text$mn:000068E9                 call    ??0?$StringBuffer@D@WcharMbcsConvertor@@QAE@XZ ; WcharMbcsConvertor::StringBuffer<char>::StringBuffer<char>(void)
.text$mn:000068EE                 mov     [ebp+var_4], 0
.text$mn:000068F5                 mov     ecx, [ebp+var_10]
.text$mn:000068F8                 add     ecx, 8
.text$mn:000068FB                 call    ??0?$StringBuffer@_W@WcharMbcsConvertor@@QAE@XZ ; WcharMbcsConvertor::StringBuffer<wchar_t>::StringBuffer<wchar_t>(void)
.text$mn:00006900                 mov     byte ptr [ebp+var_4], 1
.text$mn:00006904                 mov     [ebp+var_4], 0FFFFFFFFh
.text$mn:0000690B                 mov     eax, [ebp+var_10]
.text$mn:0000690E                 mov     ecx, [ebp+var_C]
.text$mn:00006911                 mov     large fs:0, ecx
.text$mn:00006918                 pop     ecx
.text$mn:00006919                 mov     esp, ebp
.text$mn:0000691B                 pop     ebp
.text$mn:0000691C                 retn
.text$mn:0000691C ??0WcharMbcsConvertor@@IAE@XZ endp
.text$mn:0000691C
.text$mn:0000691C ; ---------------------------------------------------------------------------
.text$mn:0000691D                 align 10h
.text$mn:0000691D _text$mn        ends
.text$mn:0000691D
.text$x:00006920 ; ===========================================================================
.text$x:00006920
.text$x:00006920 ; Segment type: Pure code
.text$x:00006920 ; Segment permissions: Read/Execute
.text$x:00006920 _text$x         segment para public 'CODE' use32
.text$x:00006920                 assume cs:_text$x
.text$x:00006920                 ;org 6920h
.text$x:00006920 ; COMDAT (pick associative to section at 68C0)
.text$x:00006920                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text$x:00006920
.text$x:00006920 ; =============== S U B R O U T I N E =======================================
.text$x:00006920
.text$x:00006920
.text$x:00006920 __unwindfunclet$??0WcharMbcsConvertor@@IAE@XZ$0 proc near
.text$x:00006920                                         ; DATA XREF: .xdata$x:0000E1A4o
.text$x:00006920                 mov     ecx, [ebp-10h]
.text$x:00006923                 jmp     ??1?$StringBuffer@D@WcharMbcsConvertor@@QAE@XZ ; WcharMbcsConvertor::StringBuffer<char>::~StringBuffer<char>(void)
.text$x:00006923 __unwindfunclet$??0WcharMbcsConvertor@@IAE@XZ$0 endp
.text$x:00006923
.text$x:00006928
.text$x:00006928 ; =============== S U B R O U T I N E =======================================
.text$x:00006928
.text$x:00006928
.text$x:00006928 __unwindfunclet$??0WcharMbcsConvertor@@IAE@XZ$1 proc near
.text$x:00006928                                         ; DATA XREF: .xdata$x:0000E1ACo
.text$x:00006928                 mov     ecx, [ebp-10h]
.text$x:0000692B                 add     ecx, 8
.text$x:0000692E                 jmp     ??1?$StringBuffer@_W@WcharMbcsConvertor@@QAE@XZ ; WcharMbcsConvertor::StringBuffer<wchar_t>::~StringBuffer<wchar_t>(void)
.text$x:0000692E __unwindfunclet$??0WcharMbcsConvertor@@IAE@XZ$1 endp
.text$x:0000692E
.text$x:00006933
.text$x:00006933 ; =============== S U B R O U T I N E =======================================
.text$x:00006933
.text$x:00006933
.text$x:00006933 __ehhandler$??0WcharMbcsConvertor@@IAE@XZ proc near
.text$x:00006933                                         ; DATA XREF: WcharMbcsConvertor::WcharMbcsConvertor(void)+5o
.text$x:00006933
.text$x:00006933 arg_4           = dword ptr  8
.text$x:00006933
.text$x:00006933                 mov     edx, [esp+arg_4]
.text$x:00006937                 lea     eax, [edx+0Ch]
.text$x:0000693A                 mov     ecx, [edx-8]
.text$x:0000693D                 xor     ecx, eax
.text$x:0000693F                 call    @__security_check_cookie@4 ; __security_check_cookie(x)
.text$x:00006944                 mov     eax, offset __ehfuncinfo$??0WcharMbcsConvertor@@IAE@XZ
.text$x:00006949                 jmp     ___CxxFrameHandler3
.text$x:00006949 __ehhandler$??0WcharMbcsConvertor@@IAE@XZ endp
.text$x:00006949
.text$x:00006949 ; ---------------------------------------------------------------------------
.text$x:0000694E                 align 10h
.text$x:0000694E _text$x         ends
.text$x:0000694E
.text$mn:00006950 ; ===========================================================================
.text$mn:00006950
.text$mn:00006950 ; Segment type: Pure code
.text$mn:00006950 ; Segment permissions: Read/Execute
.text$mn:00006950 _text$mn        segment para public 'CODE' use32
.text$mn:00006950                 assume cs:_text$mn
.text$mn:00006950                 ;org 6950h
.text$mn:00006950 ; COMDAT (pick any)
.text$mn:00006950                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text$mn:00006950
.text$mn:00006950 ; =============== S U B R O U T I N E =======================================
.text$mn:00006950
.text$mn:00006950 ; Attributes: bp-based frame
.text$mn:00006950
.text$mn:00006950 ; _DWORD __thiscall std::_Container_base12::_Container_base12(std::_Container_base12 *__hidden this)
.text$mn:00006950                 public ??0_Container_base12@std@@QAE@XZ
.text$mn:00006950 ??0_Container_base12@std@@QAE@XZ proc near
.text$mn:00006950                                         ; CODE XREF: std::_String_val<std::_Simple_types<char>>::_String_val<std::_Simple_types<char>>(void)+29p
.text$mn:00006950                                         ; std::_String_val<std::_Simple_types<wchar_t>>::_String_val<std::_Simple_types<wchar_t>>(void)+29p ...
.text$mn:00006950
.text$mn:00006950 var_4           = dword ptr -4
.text$mn:00006950
.text$mn:00006950                 push    ebp
.text$mn:00006951                 mov     ebp, esp
.text$mn:00006953                 push    ecx
.text$mn:00006954                 mov     [ebp+var_4], ecx
.text$mn:00006957                 mov     eax, [ebp+var_4]
.text$mn:0000695A                 mov     dword ptr [eax], 0
.text$mn:00006960                 mov     eax, [ebp+var_4]
.text$mn:00006963                 mov     esp, ebp
.text$mn:00006965                 pop     ebp
.text$mn:00006966                 retn
.text$mn:00006966 ??0_Container_base12@std@@QAE@XZ endp
.text$mn:00006966
.text$mn:00006966 ; ---------------------------------------------------------------------------
.text$mn:00006967                 align 4
.text$mn:00006967 _text$mn        ends
.text$mn:00006967
.text$mn:00006968 ; ===========================================================================
.text$mn:00006968
.text$mn:00006968 ; Segment type: Pure code
.text$mn:00006968 ; Segment permissions: Read/Execute
.text$mn:00006968 _text$mn        segment para public 'CODE' use32
.text$mn:00006968                 assume cs:_text$mn
.text$mn:00006968                 ;org 6968h
.text$mn:00006968 ; COMDAT (pick any)
.text$mn:00006968                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text$mn:00006968
.text$mn:00006968 ; =============== S U B R O U T I N E =======================================
.text$mn:00006968
.text$mn:00006968 ; Attributes: bp-based frame
.text$mn:00006968
.text$mn:00006968 ; _DWORD __thiscall std::_Container_proxy::_Container_proxy(std::_Container_proxy *__hidden this)
.text$mn:00006968                 public ??0_Container_proxy@std@@QAE@XZ
.text$mn:00006968 ??0_Container_proxy@std@@QAE@XZ proc near
.text$mn:00006968                                         ; CODE XREF: std::_String_alloc<0,std::_String_base_types<char,std::allocator<char>>>::_Alloc_proxy(void)+23p
.text$mn:00006968                                         ; std::_String_alloc<0,std::_String_base_types<wchar_t,std::allocator<wchar_t>>>::_Alloc_proxy(void)+23p ...
.text$mn:00006968
.text$mn:00006968 var_4           = dword ptr -4
.text$mn:00006968
.text$mn:00006968                 push    ebp
.text$mn:00006969                 mov     ebp, esp
.text$mn:0000696B                 push    ecx
.text$mn:0000696C                 mov     [ebp+var_4], ecx
.text$mn:0000696F                 mov     eax, [ebp+var_4]
.text$mn:00006972                 mov     dword ptr [eax], 0
.text$mn:00006978                 mov     ecx, [ebp+var_4]
.text$mn:0000697B                 mov     dword ptr [ecx+4], 0
.text$mn:00006982                 mov     eax, [ebp+var_4]
.text$mn:00006985                 mov     esp, ebp
.text$mn:00006987                 pop     ebp
.text$mn:00006988                 retn
.text$mn:00006988 ??0_Container_proxy@std@@QAE@XZ endp
.text$mn:00006988
.text$mn:00006988 ; ---------------------------------------------------------------------------
.text$mn:00006989                 align 4
.text$mn:00006989 _text$mn        ends
.text$mn:00006989
.text$mn:0000698C ; ===========================================================================
.text$mn:0000698C
.text$mn:0000698C ; Segment type: Pure code
.text$mn:0000698C ; Segment permissions: Read/Execute
.text$mn:0000698C _text$mn        segment para public 'CODE' use32
.text$mn:0000698C                 assume cs:_text$mn
.text$mn:0000698C                 ;org 698Ch
.text$mn:0000698C ; COMDAT (pick any)
.text$mn:0000698C                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text$mn:0000698C
.text$mn:0000698C ; =============== S U B R O U T I N E =======================================
.text$mn:0000698C
.text$mn:0000698C ; Attributes: bp-based frame
.text$mn:0000698C
.text$mn:0000698C ; _DWORD __thiscall std::_Generic_error_category::_Generic_error_category(std::_Generic_error_category *__hidden this)
.text$mn:0000698C                 public ??0_Generic_error_category@std@@QAE@XZ
.text$mn:0000698C ??0_Generic_error_category@std@@QAE@XZ proc near
.text$mn:0000698C                                         ; CODE XREF: std::_Iostream_error_category::_Iostream_error_category(void)+29p
.text$mn:0000698C                                         ; std::_System_error_category::_System_error_category(void)+29p ...
.text$mn:0000698C
.text$mn:0000698C var_10          = dword ptr -10h
.text$mn:0000698C var_C           = dword ptr -0Ch
.text$mn:0000698C var_4           = dword ptr -4
.text$mn:0000698C
.text$mn:0000698C                 push    ebp
.text$mn:0000698D                 mov     ebp, esp
.text$mn:0000698F                 push    0FFFFFFFFh
.text$mn:00006991                 push    offset __ehhandler$??0_Generic_error_category@std@@QAE@XZ
.text$mn:00006996                 mov     eax, large fs:0
.text$mn:0000699C                 push    eax
.text$mn:0000699D                 push    ecx
.text$mn:0000699E                 mov     eax, dword ptr ds:___security_cookie
.text$mn:000069A3                 xor     eax, ebp
.text$mn:000069A5                 push    eax
.text$mn:000069A6                 lea     eax, [ebp+var_C]
.text$mn:000069A9                 mov     large fs:0, eax
.text$mn:000069AF                 mov     [ebp+var_10], ecx
.text$mn:000069B2                 mov     ecx, [ebp+var_10] ; this
.text$mn:000069B5                 call    ??0error_category@std@@QAE@XZ ; std::error_category::error_category(void)
.text$mn:000069BA                 mov     [ebp+var_4], 0
.text$mn:000069C1                 mov     eax, [ebp+var_10]
.text$mn:000069C4                 mov     dword ptr [eax], offset ??_7_Generic_error_category@std@@6B@ ; const std::_Generic_error_category::`vftable'
.text$mn:000069CA                 mov     [ebp+var_4], 0FFFFFFFFh
.text$mn:000069D1                 mov     eax, [ebp+var_10]
.text$mn:000069D4                 mov     ecx, [ebp+var_C]
.text$mn:000069D7                 mov     large fs:0, ecx
.text$mn:000069DE                 pop     ecx
.text$mn:000069DF                 mov     esp, ebp
.text$mn:000069E1                 pop     ebp
.text$mn:000069E2                 retn
.text$mn:000069E2 ??0_Generic_error_category@std@@QAE@XZ endp
.text$mn:000069E2
.text$mn:000069E2 ; ---------------------------------------------------------------------------
.text$mn:000069E3                 align 4
.text$mn:000069E3 _text$mn        ends
.text$mn:000069E3
.text$x:000069E4 ; ===========================================================================
.text$x:000069E4
.text$x:000069E4 ; Segment type: Pure code
.text$x:000069E4 ; Segment permissions: Read/Execute
.text$x:000069E4 _text$x         segment para public 'CODE' use32
.text$x:000069E4                 assume cs:_text$x
.text$x:000069E4                 ;org 69E4h
.text$x:000069E4 ; COMDAT (pick associative to section at 698C)
.text$x:000069E4                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text$x:000069E4
.text$x:000069E4 ; =============== S U B R O U T I N E =======================================
.text$x:000069E4
.text$x:000069E4
.text$x:000069E4 __unwindfunclet$??0_Generic_error_category@std@@QAE@XZ$0 proc near
.text$x:000069E4                                         ; DATA XREF: .xdata$x:0000D7B4o
.text$x:000069E4                 mov     ecx, [ebp-10h]  ; this
.text$x:000069E7                 jmp     ??1error_category@std@@UAE@XZ ; std::error_category::~error_category(void)
.text$x:000069E7 __unwindfunclet$??0_Generic_error_category@std@@QAE@XZ$0 endp
.text$x:000069E7
.text$x:000069EC
.text$x:000069EC ; =============== S U B R O U T I N E =======================================
.text$x:000069EC
.text$x:000069EC
.text$x:000069EC __ehhandler$??0_Generic_error_category@std@@QAE@XZ proc near
.text$x:000069EC                                         ; DATA XREF: std::_Generic_error_category::_Generic_error_category(void)+5o
.text$x:000069EC
.text$x:000069EC arg_4           = dword ptr  8
.text$x:000069EC
.text$x:000069EC                 mov     edx, [esp+arg_4]
.text$x:000069F0                 lea     eax, [edx+0Ch]
.text$x:000069F3                 mov     ecx, [edx-8]
.text$x:000069F6                 xor     ecx, eax
.text$x:000069F8                 call    @__security_check_cookie@4 ; __security_check_cookie(x)
.text$x:000069FD                 mov     eax, offset __ehfuncinfo$??0_Generic_error_category@std@@QAE@XZ
.text$x:00006A02                 jmp     ___CxxFrameHandler3
.text$x:00006A02 __ehhandler$??0_Generic_error_category@std@@QAE@XZ endp
.text$x:00006A02
.text$x:00006A02 ; ---------------------------------------------------------------------------
.text$x:00006A07                 align 4
.text$x:00006A07 _text$x         ends
.text$x:00006A07
.text$mn:00006A08 ; ===========================================================================
.text$mn:00006A08
.text$mn:00006A08 ; Segment type: Pure code
.text$mn:00006A08 ; Segment permissions: Read/Execute
.text$mn:00006A08 _text$mn        segment para public 'CODE' use32
.text$mn:00006A08                 assume cs:_text$mn
.text$mn:00006A08                 ;org 6A08h
.text$mn:00006A08 ; COMDAT (pick any)
.text$mn:00006A08                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text$mn:00006A08
.text$mn:00006A08 ; =============== S U B R O U T I N E =======================================
.text$mn:00006A08
.text$mn:00006A08 ; Attributes: bp-based frame
.text$mn:00006A08
.text$mn:00006A08 ; _DWORD __thiscall std::_Iostream_error_category::_Iostream_error_category(std::_Iostream_error_category *__hidden this)
.text$mn:00006A08                 public ??0_Iostream_error_category@std@@QAE@XZ
.text$mn:00006A08 ??0_Iostream_error_category@std@@QAE@XZ proc near
.text$mn:00006A08                                         ; CODE XREF: `dynamic initializer for 'std::_Iostream_error_category std::_Error_objects<int>::_Iostream_object''(void)+8p
.text$mn:00006A08
.text$mn:00006A08 var_10          = dword ptr -10h
.text$mn:00006A08 var_C           = dword ptr -0Ch
.text$mn:00006A08 var_4           = dword ptr -4
.text$mn:00006A08
.text$mn:00006A08                 push    ebp
.text$mn:00006A09                 mov     ebp, esp
.text$mn:00006A0B                 push    0FFFFFFFFh
.text$mn:00006A0D                 push    offset __ehhandler$??0_Iostream_error_category@std@@QAE@XZ
.text$mn:00006A12                 mov     eax, large fs:0
.text$mn:00006A18                 push    eax
.text$mn:00006A19                 push    ecx
.text$mn:00006A1A                 mov     eax, dword ptr ds:___security_cookie
.text$mn:00006A1F                 xor     eax, ebp
.text$mn:00006A21                 push    eax
.text$mn:00006A22                 lea     eax, [ebp+var_C]
.text$mn:00006A25                 mov     large fs:0, eax
.text$mn:00006A2B                 mov     [ebp+var_10], ecx
.text$mn:00006A2E                 mov     ecx, [ebp+var_10] ; this
.text$mn:00006A31                 call    ??0_Generic_error_category@std@@QAE@XZ ; std::_Generic_error_category::_Generic_error_category(void)
.text$mn:00006A36                 mov     [ebp+var_4], 0
.text$mn:00006A3D                 mov     eax, [ebp+var_10]
.text$mn:00006A40                 mov     dword ptr [eax], offset ??_7_Iostream_error_category@std@@6B@ ; const std::_Iostream_error_category::`vftable'
.text$mn:00006A46                 mov     [ebp+var_4], 0FFFFFFFFh
.text$mn:00006A4D                 mov     eax, [ebp+var_10]
.text$mn:00006A50                 mov     ecx, [ebp+var_C]
.text$mn:00006A53                 mov     large fs:0, ecx
.text$mn:00006A5A                 pop     ecx
.text$mn:00006A5B                 mov     esp, ebp
.text$mn:00006A5D                 pop     ebp
.text$mn:00006A5E                 retn
.text$mn:00006A5E ??0_Iostream_error_category@std@@QAE@XZ endp
.text$mn:00006A5E
.text$mn:00006A5E ; ---------------------------------------------------------------------------
.text$mn:00006A5F                 align 10h
.text$mn:00006A5F _text$mn        ends
.text$mn:00006A5F
.text$x:00006A60 ; ===========================================================================
.text$x:00006A60
.text$x:00006A60 ; Segment type: Pure code
.text$x:00006A60 ; Segment permissions: Read/Execute
.text$x:00006A60 _text$x         segment para public 'CODE' use32
.text$x:00006A60                 assume cs:_text$x
.text$x:00006A60                 ;org 6A60h
.text$x:00006A60 ; COMDAT (pick associative to section at 6A08)
.text$x:00006A60                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text$x:00006A60
.text$x:00006A60 ; =============== S U B R O U T I N E =======================================
.text$x:00006A60
.text$x:00006A60
.text$x:00006A60 __unwindfunclet$??0_Iostream_error_category@std@@QAE@XZ$0 proc near
.text$x:00006A60                                         ; DATA XREF: .xdata$x:0000D838o
.text$x:00006A60                 mov     ecx, [ebp-10h]  ; this
.text$x:00006A63                 jmp     ??1_Generic_error_category@std@@UAE@XZ ; std::_Generic_error_category::~_Generic_error_category(void)
.text$x:00006A63 __unwindfunclet$??0_Iostream_error_category@std@@QAE@XZ$0 endp
.text$x:00006A63
.text$x:00006A68
.text$x:00006A68 ; =============== S U B R O U T I N E =======================================
.text$x:00006A68
.text$x:00006A68
.text$x:00006A68 __ehhandler$??0_Iostream_error_category@std@@QAE@XZ proc near
.text$x:00006A68                                         ; DATA XREF: std::_Iostream_error_category::_Iostream_error_category(void)+5o
.text$x:00006A68
.text$x:00006A68 arg_4           = dword ptr  8
.text$x:00006A68
.text$x:00006A68                 mov     edx, [esp+arg_4]
.text$x:00006A6C                 lea     eax, [edx+0Ch]
.text$x:00006A6F                 mov     ecx, [edx-8]
.text$x:00006A72                 xor     ecx, eax
.text$x:00006A74                 call    @__security_check_cookie@4 ; __security_check_cookie(x)
.text$x:00006A79                 mov     eax, offset __ehfuncinfo$??0_Iostream_error_category@std@@QAE@XZ
.text$x:00006A7E                 jmp     ___CxxFrameHandler3
.text$x:00006A7E __ehhandler$??0_Iostream_error_category@std@@QAE@XZ endp
.text$x:00006A7E
.text$x:00006A7E ; ---------------------------------------------------------------------------
.text$x:00006A83                 align 4
.text$x:00006A83 _text$x         ends
.text$x:00006A83
.text$mn:00006A84 ; ===========================================================================
.text$mn:00006A84
.text$mn:00006A84 ; Segment type: Pure code
.text$mn:00006A84 ; Segment permissions: Read/Execute
.text$mn:00006A84 _text$mn        segment para public 'CODE' use32
.text$mn:00006A84                 assume cs:_text$mn
.text$mn:00006A84                 ;org 6A84h
.text$mn:00006A84 ; COMDAT (pick any)
.text$mn:00006A84                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text$mn:00006A84
.text$mn:00006A84 ; =============== S U B R O U T I N E =======================================
.text$mn:00006A84
.text$mn:00006A84 ; Attributes: bp-based frame
.text$mn:00006A84
.text$mn:00006A84 ; _DWORD __thiscall std::_Iterator_base12::_Iterator_base12(std::_Iterator_base12 *this, const struct std::_Iterator_base12 *)
.text$mn:00006A84                 public ??0_Iterator_base12@std@@QAE@ABU01@@Z
.text$mn:00006A84 ??0_Iterator_base12@std@@QAE@ABU01@@Z proc near
.text$mn:00006A84                                         ; CODE XREF: std::_Iterator012<std::random_access_iterator_tag,wchar_t,int,wchar_t const *,wchar_t const &,std::_Iterator_base12>::_Iterator012<std::random_access_iterator_tag,wchar_t,int,wchar_t const *,wchar_t const &,std::_Iterator_base12>(std::_Iterator012<std::random_access_iterator_tag,wchar_t,int,wchar_t const *,wchar_t const &,std::_Iterator_base12> const &)+2Dp
.text$mn:00006A84
.text$mn:00006A84 var_4           = dword ptr -4
.text$mn:00006A84 arg_0           = dword ptr  8
.text$mn:00006A84
.text$mn:00006A84                 push    ebp
.text$mn:00006A85                 mov     ebp, esp
.text$mn:00006A87                 push    ecx
.text$mn:00006A88                 mov     [ebp+var_4], ecx
.text$mn:00006A8B                 mov     eax, [ebp+var_4]
.text$mn:00006A8E                 mov     dword ptr [eax], 0
.text$mn:00006A94                 mov     ecx, [ebp+var_4]
.text$mn:00006A97                 mov     dword ptr [ecx+4], 0
.text$mn:00006A9E                 mov     edx, [ebp+arg_0]
.text$mn:00006AA1                 push    edx
.text$mn:00006AA2                 mov     ecx, [ebp+var_4]
.text$mn:00006AA5                 call    ??4_Iterator_base12@std@@QAEAAU01@ABU01@@Z ; std::_Iterator_base12::operator=(std::_Iterator_base12 const &)
.text$mn:00006AAA                 mov     eax, [ebp+var_4]
.text$mn:00006AAD                 mov     esp, ebp
.text$mn:00006AAF                 pop     ebp
.text$mn:00006AB0                 retn    4
.text$mn:00006AB0 ??0_Iterator_base12@std@@QAE@ABU01@@Z endp
.text$mn:00006AB0
.text$mn:00006AB0 ; ---------------------------------------------------------------------------
.text$mn:00006AB3                 align 4
.text$mn:00006AB3 _text$mn        ends
.text$mn:00006AB3
.text$mn:00006AB4 ; ===========================================================================
.text$mn:00006AB4
.text$mn:00006AB4 ; Segment type: Pure code
.text$mn:00006AB4 ; Segment permissions: Read/Execute
.text$mn:00006AB4 _text$mn        segment para public 'CODE' use32
.text$mn:00006AB4                 assume cs:_text$mn
.text$mn:00006AB4                 ;org 6AB4h
.text$mn:00006AB4 ; COMDAT (pick any)
.text$mn:00006AB4                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text$mn:00006AB4
.text$mn:00006AB4 ; =============== S U B R O U T I N E =======================================
.text$mn:00006AB4
.text$mn:00006AB4 ; Attributes: bp-based frame
.text$mn:00006AB4
.text$mn:00006AB4 ; _DWORD __thiscall std::_Iterator_base12::_Iterator_base12(std::_Iterator_base12 *__hidden this)
.text$mn:00006AB4                 public ??0_Iterator_base12@std@@QAE@XZ
.text$mn:00006AB4 ??0_Iterator_base12@std@@QAE@XZ proc near
.text$mn:00006AB4                                         ; CODE XREF: std::_Iterator012<std::random_access_iterator_tag,wchar_t,int,wchar_t const *,wchar_t const &,std::_Iterator_base12>::_Iterator012<std::random_access_iterator_tag,wchar_t,int,wchar_t const *,wchar_t const &,std::_Iterator_base12>(void)+29p
.text$mn:00006AB4
.text$mn:00006AB4 var_4           = dword ptr -4
.text$mn:00006AB4
.text$mn:00006AB4                 push    ebp
.text$mn:00006AB5                 mov     ebp, esp
.text$mn:00006AB7                 push    ecx
.text$mn:00006AB8                 mov     [ebp+var_4], ecx
.text$mn:00006ABB                 mov     eax, [ebp+var_4]
.text$mn:00006ABE                 mov     dword ptr [eax], 0
.text$mn:00006AC4                 mov     ecx, [ebp+var_4]
.text$mn:00006AC7                 mov     dword ptr [ecx+4], 0
.text$mn:00006ACE                 mov     eax, [ebp+var_4]
.text$mn:00006AD1                 mov     esp, ebp
.text$mn:00006AD3                 pop     ebp
.text$mn:00006AD4                 retn
.text$mn:00006AD4 ??0_Iterator_base12@std@@QAE@XZ endp
.text$mn:00006AD4
.text$mn:00006AD4 ; ---------------------------------------------------------------------------
.text$mn:00006AD5                 align 4
.text$mn:00006AD5 _text$mn        ends
.text$mn:00006AD5
.text$mn:00006AD8 ; ===========================================================================
.text$mn:00006AD8
.text$mn:00006AD8 ; Segment type: Pure code
.text$mn:00006AD8 ; Segment permissions: Read/Execute
.text$mn:00006AD8 _text$mn        segment para public 'CODE' use32
.text$mn:00006AD8                 assume cs:_text$mn
.text$mn:00006AD8                 ;org 6AD8h
.text$mn:00006AD8 ; COMDAT (pick any)
.text$mn:00006AD8                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text$mn:00006AD8
.text$mn:00006AD8 ; =============== S U B R O U T I N E =======================================
.text$mn:00006AD8
.text$mn:00006AD8 ; Attributes: bp-based frame
.text$mn:00006AD8
.text$mn:00006AD8 ; _DWORD __thiscall std::_System_error_category::_System_error_category(std::_System_error_category *__hidden this)
.text$mn:00006AD8                 public ??0_System_error_category@std@@QAE@XZ
.text$mn:00006AD8 ??0_System_error_category@std@@QAE@XZ proc near
.text$mn:00006AD8                                         ; CODE XREF: `dynamic initializer for 'std::_System_error_category std::_Error_objects<int>::_System_object''(void)+8p
.text$mn:00006AD8
.text$mn:00006AD8 var_10          = dword ptr -10h
.text$mn:00006AD8 var_C           = dword ptr -0Ch
.text$mn:00006AD8 var_4           = dword ptr -4
.text$mn:00006AD8
.text$mn:00006AD8                 push    ebp
.text$mn:00006AD9                 mov     ebp, esp
.text$mn:00006ADB                 push    0FFFFFFFFh
.text$mn:00006ADD                 push    offset __ehhandler$??0_System_error_category@std@@QAE@XZ
.text$mn:00006AE2                 mov     eax, large fs:0
.text$mn:00006AE8                 push    eax
.text$mn:00006AE9                 push    ecx
.text$mn:00006AEA                 mov     eax, dword ptr ds:___security_cookie
.text$mn:00006AEF                 xor     eax, ebp
.text$mn:00006AF1                 push    eax
.text$mn:00006AF2                 lea     eax, [ebp+var_C]
.text$mn:00006AF5                 mov     large fs:0, eax
.text$mn:00006AFB                 mov     [ebp+var_10], ecx
.text$mn:00006AFE                 mov     ecx, [ebp+var_10] ; this
.text$mn:00006B01                 call    ??0_Generic_error_category@std@@QAE@XZ ; std::_Generic_error_category::_Generic_error_category(void)
.text$mn:00006B06                 mov     [ebp+var_4], 0
.text$mn:00006B0D                 mov     eax, [ebp+var_10]
.text$mn:00006B10                 mov     dword ptr [eax], offset ??_7_System_error_category@std@@6B@ ; const std::_System_error_category::`vftable'
.text$mn:00006B16                 mov     [ebp+var_4], 0FFFFFFFFh
.text$mn:00006B1D                 mov     eax, [ebp+var_10]
.text$mn:00006B20                 mov     ecx, [ebp+var_C]
.text$mn:00006B23                 mov     large fs:0, ecx
.text$mn:00006B2A                 pop     ecx
.text$mn:00006B2B                 mov     esp, ebp
.text$mn:00006B2D                 pop     ebp
.text$mn:00006B2E                 retn
.text$mn:00006B2E ??0_System_error_category@std@@QAE@XZ endp
.text$mn:00006B2E
.text$mn:00006B2E ; ---------------------------------------------------------------------------
.text$mn:00006B2F                 align 10h
.text$mn:00006B2F _text$mn        ends
.text$mn:00006B2F
.text$x:00006B30 ; ===========================================================================
.text$x:00006B30
.text$x:00006B30 ; Segment type: Pure code
.text$x:00006B30 ; Segment permissions: Read/Execute
.text$x:00006B30 _text$x         segment para public 'CODE' use32
.text$x:00006B30                 assume cs:_text$x
.text$x:00006B30                 ;org 6B30h
.text$x:00006B30 ; COMDAT (pick associative to section at 6AD8)
.text$x:00006B30                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text$x:00006B30
.text$x:00006B30 ; =============== S U B R O U T I N E =======================================
.text$x:00006B30
.text$x:00006B30
.text$x:00006B30 __unwindfunclet$??0_System_error_category@std@@QAE@XZ$0 proc near
.text$x:00006B30                                         ; DATA XREF: .xdata$x:0000D8BCo
.text$x:00006B30                 mov     ecx, [ebp-10h]  ; this
.text$x:00006B33                 jmp     ??1_Generic_error_category@std@@UAE@XZ ; std::_Generic_error_category::~_Generic_error_category(void)
.text$x:00006B33 __unwindfunclet$??0_System_error_category@std@@QAE@XZ$0 endp
.text$x:00006B33
.text$x:00006B38
.text$x:00006B38 ; =============== S U B R O U T I N E =======================================
.text$x:00006B38
.text$x:00006B38
.text$x:00006B38 __ehhandler$??0_System_error_category@std@@QAE@XZ proc near
.text$x:00006B38                                         ; DATA XREF: std::_System_error_category::_System_error_category(void)+5o
.text$x:00006B38
.text$x:00006B38 arg_4           = dword ptr  8
.text$x:00006B38
.text$x:00006B38                 mov     edx, [esp+arg_4]
.text$x:00006B3C                 lea     eax, [edx+0Ch]
.text$x:00006B3F                 mov     ecx, [edx-8]
.text$x:00006B42                 xor     ecx, eax
.text$x:00006B44                 call    @__security_check_cookie@4 ; __security_check_cookie(x)
.text$x:00006B49                 mov     eax, offset __ehfuncinfo$??0_System_error_category@std@@QAE@XZ
.text$x:00006B4E                 jmp     ___CxxFrameHandler3
.text$x:00006B4E __ehhandler$??0_System_error_category@std@@QAE@XZ endp
.text$x:00006B4E
.text$x:00006B4E ; ---------------------------------------------------------------------------
.text$x:00006B53                 align 4
.text$x:00006B53 _text$x         ends
.text$x:00006B53
.text$mn:00006B54 ; ===========================================================================
.text$mn:00006B54
.text$mn:00006B54 ; Segment type: Pure code
.text$mn:00006B54 ; Segment permissions: Read/Execute
.text$mn:00006B54 _text$mn        segment para public 'CODE' use32
.text$mn:00006B54                 assume cs:_text$mn
.text$mn:00006B54                 ;org 6B54h
.text$mn:00006B54 ; COMDAT (pick any)
.text$mn:00006B54                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text$mn:00006B54
.text$mn:00006B54 ; =============== S U B R O U T I N E =======================================
.text$mn:00006B54
.text$mn:00006B54 ; Attributes: bp-based frame
.text$mn:00006B54
.text$mn:00006B54 ; _DWORD __thiscall std::error_category::error_category(std::error_category *__hidden this)
.text$mn:00006B54                 public ??0error_category@std@@QAE@XZ
.text$mn:00006B54 ??0error_category@std@@QAE@XZ proc near ; CODE XREF: std::_Generic_error_category::_Generic_error_category(void)+29p
.text$mn:00006B54
.text$mn:00006B54 var_4           = dword ptr -4
.text$mn:00006B54
.text$mn:00006B54                 push    ebp
.text$mn:00006B55                 mov     ebp, esp
.text$mn:00006B57                 push    ecx
.text$mn:00006B58                 mov     [ebp+var_4], ecx
.text$mn:00006B5B                 mov     eax, [ebp+var_4]
.text$mn:00006B5E                 mov     dword ptr [eax], offset ??_7error_category@std@@6B@ ; const std::error_category::`vftable'
.text$mn:00006B64                 mov     eax, [ebp+var_4]
.text$mn:00006B67                 mov     esp, ebp
.text$mn:00006B69                 pop     ebp
.text$mn:00006B6A                 retn
.text$mn:00006B6A ??0error_category@std@@QAE@XZ endp
.text$mn:00006B6A
.text$mn:00006B6A ; ---------------------------------------------------------------------------
.text$mn:00006B6B                 align 4
.text$mn:00006B6B _text$mn        ends
.text$mn:00006B6B
.text$mn:00006B6C ; ===========================================================================
.text$mn:00006B6C
.text$mn:00006B6C ; Segment type: Pure code
.text$mn:00006B6C ; Segment permissions: Read/Execute
.text$mn:00006B6C _text$mn        segment para public 'CODE' use32
.text$mn:00006B6C                 assume cs:_text$mn
.text$mn:00006B6C                 ;org 6B6Ch
.text$mn:00006B6C ; COMDAT (pick any)
.text$mn:00006B6C                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text$mn:00006B6C
.text$mn:00006B6C ; =============== S U B R O U T I N E =======================================
.text$mn:00006B6C
.text$mn:00006B6C ; Attributes: bp-based frame
.text$mn:00006B6C
.text$mn:00006B6C ; _DWORD __thiscall std::error_condition::error_condition(std::error_condition *this, int, const struct std::error_category *)
.text$mn:00006B6C                 public ??0error_condition@std@@QAE@HABVerror_category@1@@Z
.text$mn:00006B6C ??0error_condition@std@@QAE@HABVerror_category@1@@Z proc near
.text$mn:00006B6C                                         ; CODE XREF: std::_System_error_category::default_error_condition(int)+24p
.text$mn:00006B6C                                         ; std::_System_error_category::default_error_condition(int)+3Dp ...
.text$mn:00006B6C
.text$mn:00006B6C var_4           = dword ptr -4
.text$mn:00006B6C arg_0           = dword ptr  8
.text$mn:00006B6C arg_4           = dword ptr  0Ch
.text$mn:00006B6C
.text$mn:00006B6C                 push    ebp
.text$mn:00006B6D                 mov     ebp, esp
.text$mn:00006B6F                 push    ecx
.text$mn:00006B70                 mov     [ebp+var_4], ecx
.text$mn:00006B73                 mov     eax, [ebp+var_4]
.text$mn:00006B76                 mov     ecx, [ebp+arg_0]
.text$mn:00006B79                 mov     [eax], ecx
.text$mn:00006B7B                 mov     edx, [ebp+var_4]
.text$mn:00006B7E                 mov     eax, [ebp+arg_4]
.text$mn:00006B81                 mov     [edx+4], eax
.text$mn:00006B84                 mov     eax, [ebp+var_4]
.text$mn:00006B87                 mov     esp, ebp
.text$mn:00006B89                 pop     ebp
.text$mn:00006B8A                 retn    8
.text$mn:00006B8A ??0error_condition@std@@QAE@HABVerror_category@1@@Z endp
.text$mn:00006B8A
.text$mn:00006B8A ; ---------------------------------------------------------------------------
.text$mn:00006B8D                 align 10h
.text$mn:00006B8D _text$mn        ends
.text$mn:00006B8D
.text$mn:00006B90 ; ===========================================================================
.text$mn:00006B90
.text$mn:00006B90 ; Segment type: Pure code
.text$mn:00006B90 ; Segment permissions: Read/Execute
.text$mn:00006B90 _text$mn        segment para public 'CODE' use32
.text$mn:00006B90                 assume cs:_text$mn
.text$mn:00006B90                 ;org 6B90h
.text$mn:00006B90 ; COMDAT (pick any)
.text$mn:00006B90                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text$mn:00006B90
.text$mn:00006B90 ; =============== S U B R O U T I N E =======================================
.text$mn:00006B90
.text$mn:00006B90 ; Attributes: bp-based frame
.text$mn:00006B90
.text$mn:00006B90 ; _DWORD __thiscall std::locale::id::id(std::locale::id *this, unsigned int)
.text$mn:00006B90                 public ??0id@locale@std@@QAE@I@Z
.text$mn:00006B90 ??0id@locale@std@@QAE@I@Z proc near     ; CODE XREF: `dynamic initializer for 'std::locale::id std::num_put<char,std::back_insert_iterator<std::basic_string<char,std::char_traits<char>,std::allocator<char>>>>::id''(void)+Ap
.text$mn:00006B90                                         ; `dynamic initializer for 'std::locale::id std::num_put<wchar_t,std::back_insert_iterator<std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>>>>::id''(void)+Ap ...
.text$mn:00006B90
.text$mn:00006B90 var_4           = dword ptr -4
.text$mn:00006B90 arg_0           = dword ptr  8
.text$mn:00006B90
.text$mn:00006B90                 push    ebp
.text$mn:00006B91                 mov     ebp, esp
.text$mn:00006B93                 push    ecx
.text$mn:00006B94                 mov     [ebp+var_4], ecx
.text$mn:00006B97                 mov     eax, [ebp+var_4]
.text$mn:00006B9A                 mov     ecx, [ebp+arg_0]
.text$mn:00006B9D                 mov     [eax], ecx
.text$mn:00006B9F                 mov     eax, [ebp+var_4]
.text$mn:00006BA2                 mov     esp, ebp
.text$mn:00006BA4                 pop     ebp
.text$mn:00006BA5                 retn    4
.text$mn:00006BA5 ??0id@locale@std@@QAE@I@Z endp
.text$mn:00006BA5
.text$mn:00006BA5 _text$mn        ends
.text$mn:00006BA5
.text$mn:00006BA8 ; ===========================================================================
.text$mn:00006BA8
.text$mn:00006BA8 ; Segment type: Pure code
.text$mn:00006BA8 ; Segment permissions: Read/Execute
.text$mn:00006BA8 _text$mn        segment para public 'CODE' use32
.text$mn:00006BA8                 assume cs:_text$mn
.text$mn:00006BA8                 ;org 6BA8h
.text$mn:00006BA8 ; COMDAT (pick any)
.text$mn:00006BA8                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text$mn:00006BA8
.text$mn:00006BA8 ; =============== S U B R O U T I N E =======================================
.text$mn:00006BA8
.text$mn:00006BA8 ; Attributes: bp-based frame
.text$mn:00006BA8
.text$mn:00006BA8 ; _DWORD __thiscall std::invalid_argument::invalid_argument(std::invalid_argument *this, const char *)
.text$mn:00006BA8                 public ??0invalid_argument@std@@QAE@PBD@Z
.text$mn:00006BA8 ??0invalid_argument@std@@QAE@PBD@Z proc near
.text$mn:00006BA8                                         ; CODE XREF: stodLocale(std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>> const &,localeinfo_struct *,uint *)+7Cp
.text$mn:00006BA8
.text$mn:00006BA8 var_10          = dword ptr -10h
.text$mn:00006BA8 var_C           = dword ptr -0Ch
.text$mn:00006BA8 var_4           = dword ptr -4
.text$mn:00006BA8 arg_0           = dword ptr  8
.text$mn:00006BA8
.text$mn:00006BA8                 push    ebp
.text$mn:00006BA9                 mov     ebp, esp
.text$mn:00006BAB                 push    0FFFFFFFFh
.text$mn:00006BAD                 push    offset __ehhandler$??0invalid_argument@std@@QAE@PBD@Z
.text$mn:00006BB2                 mov     eax, large fs:0
.text$mn:00006BB8                 push    eax
.text$mn:00006BB9                 push    ecx
.text$mn:00006BBA                 mov     eax, dword ptr ds:___security_cookie
.text$mn:00006BBF                 xor     eax, ebp
.text$mn:00006BC1                 push    eax
.text$mn:00006BC2                 lea     eax, [ebp+var_C]
.text$mn:00006BC5                 mov     large fs:0, eax
.text$mn:00006BCB                 mov     [ebp+var_10], ecx
.text$mn:00006BCE                 mov     eax, [ebp+arg_0]
.text$mn:00006BD1                 push    eax             ; char *
.text$mn:00006BD2                 mov     ecx, [ebp+var_10] ; this
.text$mn:00006BD5                 call    ??0logic_error@std@@QAE@PBD@Z ; std::logic_error::logic_error(char const *)
.text$mn:00006BDA                 mov     [ebp+var_4], 0
.text$mn:00006BE1                 mov     ecx, [ebp+var_10]
.text$mn:00006BE4                 mov     dword ptr [ecx], offset ??_7invalid_argument@std@@6B@ ; const std::invalid_argument::`vftable'
.text$mn:00006BEA                 mov     [ebp+var_4], 0FFFFFFFFh
.text$mn:00006BF1                 mov     eax, [ebp+var_10]
.text$mn:00006BF4                 mov     ecx, [ebp+var_C]
.text$mn:00006BF7                 mov     large fs:0, ecx
.text$mn:00006BFE                 pop     ecx
.text$mn:00006BFF                 mov     esp, ebp
.text$mn:00006C01                 pop     ebp
.text$mn:00006C02                 retn    4
.text$mn:00006C02 ??0invalid_argument@std@@QAE@PBD@Z endp
.text$mn:00006C02
.text$mn:00006C02 ; ---------------------------------------------------------------------------
.text$mn:00006C05                 align 4
.text$mn:00006C05 _text$mn        ends
.text$mn:00006C05
.text$x:00006C08 ; ===========================================================================
.text$x:00006C08
.text$x:00006C08 ; Segment type: Pure code
.text$x:00006C08 ; Segment permissions: Read/Execute
.text$x:00006C08 _text$x         segment para public 'CODE' use32
.text$x:00006C08                 assume cs:_text$x
.text$x:00006C08                 ;org 6C08h
.text$x:00006C08 ; COMDAT (pick associative to section at 6BA8)
.text$x:00006C08                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text$x:00006C08
.text$x:00006C08 ; =============== S U B R O U T I N E =======================================
.text$x:00006C08
.text$x:00006C08
.text$x:00006C08 __unwindfunclet$??0invalid_argument@std@@QAE@PBD@Z$0 proc near
.text$x:00006C08                                         ; DATA XREF: .xdata$x:0000D704o
.text$x:00006C08                 mov     ecx, [ebp-10h]  ; this
.text$x:00006C0B                 jmp     ??1logic_error@std@@UAE@XZ ; std::logic_error::~logic_error(void)
.text$x:00006C0B __unwindfunclet$??0invalid_argument@std@@QAE@PBD@Z$0 endp
.text$x:00006C0B
.text$x:00006C10
.text$x:00006C10 ; =============== S U B R O U T I N E =======================================
.text$x:00006C10
.text$x:00006C10
.text$x:00006C10 __ehhandler$??0invalid_argument@std@@QAE@PBD@Z proc near
.text$x:00006C10                                         ; DATA XREF: std::invalid_argument::invalid_argument(char const *)+5o
.text$x:00006C10
.text$x:00006C10 arg_4           = dword ptr  8
.text$x:00006C10
.text$x:00006C10                 mov     edx, [esp+arg_4]
.text$x:00006C14                 lea     eax, [edx+0Ch]
.text$x:00006C17                 mov     ecx, [edx-8]
.text$x:00006C1A                 xor     ecx, eax
.text$x:00006C1C                 call    @__security_check_cookie@4 ; __security_check_cookie(x)
.text$x:00006C21                 mov     eax, offset __ehfuncinfo$??0invalid_argument@std@@QAE@PBD@Z
.text$x:00006C26                 jmp     ___CxxFrameHandler3
.text$x:00006C26 __ehhandler$??0invalid_argument@std@@QAE@PBD@Z endp
.text$x:00006C26
.text$x:00006C26 ; ---------------------------------------------------------------------------
.text$x:00006C2B                 align 4
.text$x:00006C2B _text$x         ends
.text$x:00006C2B
.text$mn:00006C2C ; ===========================================================================
.text$mn:00006C2C
.text$mn:00006C2C ; Segment type: Pure code
.text$mn:00006C2C ; Segment permissions: Read/Execute
.text$mn:00006C2C _text$mn        segment para public 'CODE' use32
.text$mn:00006C2C                 assume cs:_text$mn
.text$mn:00006C2C                 ;org 6C2Ch
.text$mn:00006C2C ; COMDAT (pick any)
.text$mn:00006C2C                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text$mn:00006C2C
.text$mn:00006C2C ; =============== S U B R O U T I N E =======================================
.text$mn:00006C2C
.text$mn:00006C2C ; Attributes: bp-based frame
.text$mn:00006C2C
.text$mn:00006C2C ; _DWORD __thiscall std::logic_error::logic_error(std::logic_error *this, const char *)
.text$mn:00006C2C                 public ??0logic_error@std@@QAE@PBD@Z
.text$mn:00006C2C ??0logic_error@std@@QAE@PBD@Z proc near ; CODE XREF: std::invalid_argument::invalid_argument(char const *)+2Dp
.text$mn:00006C2C                                         ; std::out_of_range::out_of_range(char const *)+2Dp
.text$mn:00006C2C
.text$mn:00006C2C var_10          = dword ptr -10h
.text$mn:00006C2C var_C           = dword ptr -0Ch
.text$mn:00006C2C var_4           = dword ptr -4
.text$mn:00006C2C arg_0           = dword ptr  8
.text$mn:00006C2C
.text$mn:00006C2C                 push    ebp
.text$mn:00006C2D                 mov     ebp, esp
.text$mn:00006C2F                 push    0FFFFFFFFh
.text$mn:00006C31                 push    offset __ehhandler$??0logic_error@std@@QAE@PBD@Z
.text$mn:00006C36                 mov     eax, large fs:0
.text$mn:00006C3C                 push    eax
.text$mn:00006C3D                 push    ecx
.text$mn:00006C3E                 mov     eax, dword ptr ds:___security_cookie
.text$mn:00006C43                 xor     eax, ebp
.text$mn:00006C45                 push    eax
.text$mn:00006C46                 lea     eax, [ebp+var_C]
.text$mn:00006C49                 mov     large fs:0, eax
.text$mn:00006C4F                 mov     [ebp+var_10], ecx
.text$mn:00006C52                 lea     eax, [ebp+arg_0]
.text$mn:00006C55                 push    eax             ; char **
.text$mn:00006C56                 mov     ecx, [ebp+var_10] ; this
.text$mn:00006C59                 call    ??0exception@std@@QAE@ABQBD@Z ; std::exception::exception(char const * const &)
.text$mn:00006C5E                 mov     [ebp+var_4], 0
.text$mn:00006C65                 mov     ecx, [ebp+var_10]
.text$mn:00006C68                 mov     dword ptr [ecx], offset ??_7logic_error@std@@6B@ ; const std::logic_error::`vftable'
.text$mn:00006C6E                 mov     [ebp+var_4], 0FFFFFFFFh
.text$mn:00006C75                 mov     eax, [ebp+var_10]
.text$mn:00006C78                 mov     ecx, [ebp+var_C]
.text$mn:00006C7B                 mov     large fs:0, ecx
.text$mn:00006C82                 pop     ecx
.text$mn:00006C83                 mov     esp, ebp
.text$mn:00006C85                 pop     ebp
.text$mn:00006C86                 retn    4
.text$mn:00006C86 ??0logic_error@std@@QAE@PBD@Z endp
.text$mn:00006C86
.text$mn:00006C86 ; ---------------------------------------------------------------------------
.text$mn:00006C89                 align 4
.text$mn:00006C89 _text$mn        ends
.text$mn:00006C89
.text$x:00006C8C ; ===========================================================================
.text$x:00006C8C
.text$x:00006C8C ; Segment type: Pure code
.text$x:00006C8C ; Segment permissions: Read/Execute
.text$x:00006C8C _text$x         segment para public 'CODE' use32
.text$x:00006C8C                 assume cs:_text$x
.text$x:00006C8C                 ;org 6C8Ch
.text$x:00006C8C ; COMDAT (pick associative to section at 6C2C)
.text$x:00006C8C                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text$x:00006C8C
.text$x:00006C8C ; =============== S U B R O U T I N E =======================================
.text$x:00006C8C
.text$x:00006C8C
.text$x:00006C8C __unwindfunclet$??0logic_error@std@@QAE@PBD@Z$0 proc near
.text$x:00006C8C                                         ; DATA XREF: .xdata$x:0000D4ECo
.text$x:00006C8C                 mov     ecx, [ebp-10h]  ; this
.text$x:00006C8F                 jmp     ??1exception@std@@UAE@XZ ; std::exception::~exception(void)
.text$x:00006C8F __unwindfunclet$??0logic_error@std@@QAE@PBD@Z$0 endp
.text$x:00006C8F
.text$x:00006C94
.text$x:00006C94 ; =============== S U B R O U T I N E =======================================
.text$x:00006C94
.text$x:00006C94
.text$x:00006C94 __ehhandler$??0logic_error@std@@QAE@PBD@Z proc near
.text$x:00006C94                                         ; DATA XREF: std::logic_error::logic_error(char const *)+5o
.text$x:00006C94
.text$x:00006C94 arg_4           = dword ptr  8
.text$x:00006C94
.text$x:00006C94                 mov     edx, [esp+arg_4]
.text$x:00006C98                 lea     eax, [edx+0Ch]
.text$x:00006C9B                 mov     ecx, [edx-8]
.text$x:00006C9E                 xor     ecx, eax
.text$x:00006CA0                 call    @__security_check_cookie@4 ; __security_check_cookie(x)
.text$x:00006CA5                 mov     eax, offset __ehfuncinfo$??0logic_error@std@@QAE@PBD@Z
.text$x:00006CAA                 jmp     ___CxxFrameHandler3
.text$x:00006CAA __ehhandler$??0logic_error@std@@QAE@PBD@Z endp
.text$x:00006CAA
.text$x:00006CAA ; ---------------------------------------------------------------------------
.text$x:00006CAF                 align 10h
.text$x:00006CAF _text$x         ends
.text$x:00006CAF
.text$mn:00006CB0 ; ===========================================================================
.text$mn:00006CB0
.text$mn:00006CB0 ; Segment type: Pure code
.text$mn:00006CB0 ; Segment permissions: Read/Execute
.text$mn:00006CB0 _text$mn        segment para public 'CODE' use32
.text$mn:00006CB0                 assume cs:_text$mn
.text$mn:00006CB0                 ;org 6CB0h
.text$mn:00006CB0 ; COMDAT (pick any)
.text$mn:00006CB0                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text$mn:00006CB0
.text$mn:00006CB0 ; =============== S U B R O U T I N E =======================================
.text$mn:00006CB0
.text$mn:00006CB0 ; Attributes: bp-based frame
.text$mn:00006CB0
.text$mn:00006CB0 ; _DWORD __thiscall std::out_of_range::out_of_range(std::out_of_range *this, const char *)
.text$mn:00006CB0                 public ??0out_of_range@std@@QAE@PBD@Z
.text$mn:00006CB0 ??0out_of_range@std@@QAE@PBD@Z proc near
.text$mn:00006CB0                                         ; CODE XREF: stodLocale(std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>> const &,localeinfo_struct *,uint *)+DAp
.text$mn:00006CB0
.text$mn:00006CB0 var_10          = dword ptr -10h
.text$mn:00006CB0 var_C           = dword ptr -0Ch
.text$mn:00006CB0 var_4           = dword ptr -4
.text$mn:00006CB0 arg_0           = dword ptr  8
.text$mn:00006CB0
.text$mn:00006CB0                 push    ebp
.text$mn:00006CB1                 mov     ebp, esp
.text$mn:00006CB3                 push    0FFFFFFFFh
.text$mn:00006CB5                 push    offset __ehhandler$??0out_of_range@std@@QAE@PBD@Z
.text$mn:00006CBA                 mov     eax, large fs:0
.text$mn:00006CC0                 push    eax
.text$mn:00006CC1                 push    ecx
.text$mn:00006CC2                 mov     eax, dword ptr ds:___security_cookie
.text$mn:00006CC7                 xor     eax, ebp
.text$mn:00006CC9                 push    eax
.text$mn:00006CCA                 lea     eax, [ebp+var_C]
.text$mn:00006CCD                 mov     large fs:0, eax
.text$mn:00006CD3                 mov     [ebp+var_10], ecx
.text$mn:00006CD6                 mov     eax, [ebp+arg_0]
.text$mn:00006CD9                 push    eax             ; char *
.text$mn:00006CDA                 mov     ecx, [ebp+var_10] ; this
.text$mn:00006CDD                 call    ??0logic_error@std@@QAE@PBD@Z ; std::logic_error::logic_error(char const *)
.text$mn:00006CE2                 mov     [ebp+var_4], 0
.text$mn:00006CE9                 mov     ecx, [ebp+var_10]
.text$mn:00006CEC                 mov     dword ptr [ecx], offset ??_7out_of_range@std@@6B@ ; const std::out_of_range::`vftable'
.text$mn:00006CF2                 mov     [ebp+var_4], 0FFFFFFFFh
.text$mn:00006CF9                 mov     eax, [ebp+var_10]
.text$mn:00006CFC                 mov     ecx, [ebp+var_C]
.text$mn:00006CFF                 mov     large fs:0, ecx
.text$mn:00006D06                 pop     ecx
.text$mn:00006D07                 mov     esp, ebp
.text$mn:00006D09                 pop     ebp
.text$mn:00006D0A                 retn    4
.text$mn:00006D0A ??0out_of_range@std@@QAE@PBD@Z endp
.text$mn:00006D0A
.text$mn:00006D0A ; ---------------------------------------------------------------------------
.text$mn:00006D0D                 align 10h
.text$mn:00006D0D _text$mn        ends
.text$mn:00006D0D
.text$x:00006D10 ; ===========================================================================
.text$x:00006D10
.text$x:00006D10 ; Segment type: Pure code
.text$x:00006D10 ; Segment permissions: Read/Execute
.text$x:00006D10 _text$x         segment para public 'CODE' use32
.text$x:00006D10                 assume cs:_text$x
.text$x:00006D10                 ;org 6D10h
.text$x:00006D10 ; COMDAT (pick associative to section at 6CB0)
.text$x:00006D10                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text$x:00006D10
.text$x:00006D10 ; =============== S U B R O U T I N E =======================================
.text$x:00006D10
.text$x:00006D10
.text$x:00006D10 __unwindfunclet$??0out_of_range@std@@QAE@PBD@Z$0 proc near
.text$x:00006D10                                         ; DATA XREF: .xdata$x:0000D75Co
.text$x:00006D10                 mov     ecx, [ebp-10h]  ; this
.text$x:00006D13                 jmp     ??1logic_error@std@@UAE@XZ ; std::logic_error::~logic_error(void)
.text$x:00006D13 __unwindfunclet$??0out_of_range@std@@QAE@PBD@Z$0 endp
.text$x:00006D13
.text$x:00006D18
.text$x:00006D18 ; =============== S U B R O U T I N E =======================================
.text$x:00006D18
.text$x:00006D18
.text$x:00006D18 __ehhandler$??0out_of_range@std@@QAE@PBD@Z proc near
.text$x:00006D18                                         ; DATA XREF: std::out_of_range::out_of_range(char const *)+5o
.text$x:00006D18
.text$x:00006D18 arg_4           = dword ptr  8
.text$x:00006D18
.text$x:00006D18                 mov     edx, [esp+arg_4]
.text$x:00006D1C                 lea     eax, [edx+0Ch]
.text$x:00006D1F                 mov     ecx, [edx-8]
.text$x:00006D22                 xor     ecx, eax
.text$x:00006D24                 call    @__security_check_cookie@4 ; __security_check_cookie(x)
.text$x:00006D29                 mov     eax, offset __ehfuncinfo$??0out_of_range@std@@QAE@PBD@Z
.text$x:00006D2E                 jmp     ___CxxFrameHandler3
.text$x:00006D2E __ehhandler$??0out_of_range@std@@QAE@PBD@Z endp
.text$x:00006D2E
.text$x:00006D2E ; ---------------------------------------------------------------------------
.text$x:00006D33                 align 4
.text$x:00006D33 _text$x         ends
.text$x:00006D33
.text$mn:00006D34 ; ===========================================================================
.text$mn:00006D34
.text$mn:00006D34 ; Segment type: Pure code
.text$mn:00006D34 ; Segment permissions: Read/Execute
.text$mn:00006D34 _text$mn        segment para public 'CODE' use32
.text$mn:00006D34                 assume cs:_text$mn
.text$mn:00006D34                 ;org 6D34h
.text$mn:00006D34 ; COMDAT (pick any)
.text$mn:00006D34                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text$mn:00006D34
.text$mn:00006D34 ; =============== S U B R O U T I N E =======================================
.text$mn:00006D34
.text$mn:00006D34 ; Attributes: bp-based frame
.text$mn:00006D34
.text$mn:00006D34 ; public: __thiscall WcharMbcsConvertor::StringBuffer<char>::~StringBuffer<char>(void)
.text$mn:00006D34                 public ??1?$StringBuffer@D@WcharMbcsConvertor@@QAE@XZ
.text$mn:00006D34 ??1?$StringBuffer@D@WcharMbcsConvertor@@QAE@XZ proc near
.text$mn:00006D34                                         ; CODE XREF: __unwindfunclet$??0WcharMbcsConvertor@@IAE@XZ$0+3j
.text$mn:00006D34
.text$mn:00006D34 var_8           = dword ptr -8
.text$mn:00006D34 var_4           = dword ptr -4
.text$mn:00006D34
.text$mn:00006D34                 push    ebp
.text$mn:00006D35                 mov     ebp, esp
.text$mn:00006D37                 sub     esp, 8
.text$mn:00006D3A                 mov     [ebp+var_4], ecx
.text$mn:00006D3D                 mov     eax, [ebp+var_4]
.text$mn:00006D40                 cmp     dword ptr [eax], 0
.text$mn:00006D43                 jz      short loc_6D5A
.text$mn:00006D45                 mov     ecx, [ebp+var_4]
.text$mn:00006D48                 mov     edx, [ecx+4]
.text$mn:00006D4B                 mov     [ebp+var_8], edx
.text$mn:00006D4E                 mov     eax, [ebp+var_8]
.text$mn:00006D51                 push    eax             ; void *
.text$mn:00006D52                 call    ??_V@YAXPAX@Z   ; operator delete[](void *)
.text$mn:00006D57                 add     esp, 4
.text$mn:00006D5A
.text$mn:00006D5A loc_6D5A:                               ; CODE XREF: WcharMbcsConvertor::StringBuffer<char>::~StringBuffer<char>(void)+Fj
.text$mn:00006D5A                 mov     esp, ebp
.text$mn:00006D5C                 pop     ebp
.text$mn:00006D5D                 retn
.text$mn:00006D5D ??1?$StringBuffer@D@WcharMbcsConvertor@@QAE@XZ endp
.text$mn:00006D5D
.text$mn:00006D5D ; ---------------------------------------------------------------------------
.text$mn:00006D5E                 align 10h
.text$mn:00006D5E _text$mn        ends
.text$mn:00006D5E
.text$mn:00006D60 ; ===========================================================================
.text$mn:00006D60
.text$mn:00006D60 ; Segment type: Pure code
.text$mn:00006D60 ; Segment permissions: Read/Execute
.text$mn:00006D60 _text$mn        segment para public 'CODE' use32
.text$mn:00006D60                 assume cs:_text$mn
.text$mn:00006D60                 ;org 6D60h
.text$mn:00006D60 ; COMDAT (pick any)
.text$mn:00006D60                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text$mn:00006D60
.text$mn:00006D60 ; =============== S U B R O U T I N E =======================================
.text$mn:00006D60
.text$mn:00006D60 ; Attributes: bp-based frame
.text$mn:00006D60
.text$mn:00006D60 ; public: __thiscall WcharMbcsConvertor::StringBuffer<wchar_t>::~StringBuffer<wchar_t>(void)
.text$mn:00006D60                 public ??1?$StringBuffer@_W@WcharMbcsConvertor@@QAE@XZ
.text$mn:00006D60 ??1?$StringBuffer@_W@WcharMbcsConvertor@@QAE@XZ proc near
.text$mn:00006D60                                         ; CODE XREF: __unwindfunclet$??0WcharMbcsConvertor@@IAE@XZ$1+6j
.text$mn:00006D60
.text$mn:00006D60 var_8           = dword ptr -8
.text$mn:00006D60 var_4           = dword ptr -4
.text$mn:00006D60
.text$mn:00006D60                 push    ebp
.text$mn:00006D61                 mov     ebp, esp
.text$mn:00006D63                 sub     esp, 8
.text$mn:00006D66                 mov     [ebp+var_4], ecx
.text$mn:00006D69                 mov     eax, [ebp+var_4]
.text$mn:00006D6C                 cmp     dword ptr [eax], 0
.text$mn:00006D6F                 jz      short loc_6D86
.text$mn:00006D71                 mov     ecx, [ebp+var_4]
.text$mn:00006D74                 mov     edx, [ecx+4]
.text$mn:00006D77                 mov     [ebp+var_8], edx
.text$mn:00006D7A                 mov     eax, [ebp+var_8]
.text$mn:00006D7D                 push    eax             ; void *
.text$mn:00006D7E                 call    ??_V@YAXPAX@Z   ; operator delete[](void *)
.text$mn:00006D83                 add     esp, 4
.text$mn:00006D86
.text$mn:00006D86 loc_6D86:                               ; CODE XREF: WcharMbcsConvertor::StringBuffer<wchar_t>::~StringBuffer<wchar_t>(void)+Fj
.text$mn:00006D86                 mov     esp, ebp
.text$mn:00006D88                 pop     ebp
.text$mn:00006D89                 retn
.text$mn:00006D89 ??1?$StringBuffer@_W@WcharMbcsConvertor@@QAE@XZ endp
.text$mn:00006D89
.text$mn:00006D89 ; ---------------------------------------------------------------------------
.text$mn:00006D8A                 align 4
.text$mn:00006D8A _text$mn        ends
.text$mn:00006D8A
.text$mn:00006D8C ; ===========================================================================
.text$mn:00006D8C
.text$mn:00006D8C ; Segment type: Pure code
.text$mn:00006D8C ; Segment permissions: Read/Execute
.text$mn:00006D8C _text$mn        segment para public 'CODE' use32
.text$mn:00006D8C                 assume cs:_text$mn
.text$mn:00006D8C                 ;org 6D8Ch
.text$mn:00006D8C ; COMDAT (pick any)
.text$mn:00006D8C                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text$mn:00006D8C
.text$mn:00006D8C ; =============== S U B R O U T I N E =======================================
.text$mn:00006D8C
.text$mn:00006D8C ; Attributes: bp-based frame
.text$mn:00006D8C
.text$mn:00006D8C ; public: __thiscall std::_Iterator012<struct std::random_access_iterator_tag, wchar_t, int, wchar_t const *, wchar_t const &, struct std::_Iterator_base12>::~_Iterator012<struct std::random_access_iterator_tag, wchar_t, int, wchar_t const *, wchar_t const &, struct std::_Iterator_base12>(void)
.text$mn:00006D8C                 public ??1?$_Iterator012@Urandom_access_iterator_tag@std@@_WHPB_WAB_WU_Iterator_base12@2@@std@@QAE@XZ
.text$mn:00006D8C ??1?$_Iterator012@Urandom_access_iterator_tag@std@@_WHPB_WAB_WU_Iterator_base12@2@@std@@QAE@XZ proc near
.text$mn:00006D8C                                         ; CODE XREF: __unwindfunclet$??0?$_String_const_iterator@V?$_String_val@U?$_Simple_types@_W@std@@@std@@@std@@QAE@ABV01@@Z$0+3j
.text$mn:00006D8C                                         ; __unwindfunclet$??0?$_String_const_iterator@V?$_String_val@U?$_Simple_types@_W@std@@@std@@@std@@QAE@PB_WPBU_Container_base12@1@@Z$0+3j ...
.text$mn:00006D8C
.text$mn:00006D8C var_10          = dword ptr -10h
.text$mn:00006D8C var_C           = dword ptr -0Ch
.text$mn:00006D8C var_4           = dword ptr -4
.text$mn:00006D8C
.text$mn:00006D8C                 push    ebp
.text$mn:00006D8D                 mov     ebp, esp
.text$mn:00006D8F                 push    0FFFFFFFFh
.text$mn:00006D91                 push    offset __ehhandler$??1?$_Iterator012@Urandom_access_iterator_tag@std@@_WHPB_WAB_WU_Iterator_base12@2@@std@@QAE@XZ
.text$mn:00006D96                 mov     eax, large fs:0
.text$mn:00006D9C                 push    eax
.text$mn:00006D9D                 push    ecx
.text$mn:00006D9E                 mov     eax, dword ptr ds:___security_cookie
.text$mn:00006DA3                 xor     eax, ebp
.text$mn:00006DA5                 push    eax
.text$mn:00006DA6                 lea     eax, [ebp+var_C]
.text$mn:00006DA9                 mov     large fs:0, eax
.text$mn:00006DAF                 mov     [ebp+var_10], ecx
.text$mn:00006DB2                 mov     [ebp+var_4], 0
.text$mn:00006DB9                 mov     [ebp+var_4], 0FFFFFFFFh
.text$mn:00006DC0                 mov     ecx, [ebp+var_10] ; this
.text$mn:00006DC3                 call    ??1_Iterator_base12@std@@QAE@XZ ; std::_Iterator_base12::~_Iterator_base12(void)
.text$mn:00006DC8                 mov     ecx, [ebp+var_C]
.text$mn:00006DCB                 mov     large fs:0, ecx
.text$mn:00006DD2                 pop     ecx
.text$mn:00006DD3                 mov     esp, ebp
.text$mn:00006DD5                 pop     ebp
.text$mn:00006DD6                 retn
.text$mn:00006DD6 ??1?$_Iterator012@Urandom_access_iterator_tag@std@@_WHPB_WAB_WU_Iterator_base12@2@@std@@QAE@XZ endp
.text$mn:00006DD6
.text$mn:00006DD6 ; ---------------------------------------------------------------------------
.text$mn:00006DD7                 align 4
.text$mn:00006DD7 _text$mn        ends
.text$mn:00006DD7
.text$x:00006DD8 ; ===========================================================================
.text$x:00006DD8
.text$x:00006DD8 ; Segment type: Pure code
.text$x:00006DD8 ; Segment permissions: Read/Execute
.text$x:00006DD8 _text$x         segment para public 'CODE' use32
.text$x:00006DD8                 assume cs:_text$x
.text$x:00006DD8                 ;org 6DD8h
.text$x:00006DD8 ; COMDAT (pick associative to section at 6D8C)
.text$x:00006DD8                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text$x:00006DD8
.text$x:00006DD8 ; =============== S U B R O U T I N E =======================================
.text$x:00006DD8
.text$x:00006DD8
.text$x:00006DD8 __unwindfunclet$??1?$_Iterator012@Urandom_access_iterator_tag@std@@_WHPB_WAB_WU_Iterator_base12@2@@std@@QAE@XZ$0 proc near
.text$x:00006DD8                                         ; DATA XREF: .xdata$x:0000E7E0o
.text$x:00006DD8                 mov     ecx, [ebp-10h]  ; this
.text$x:00006DDB                 jmp     ??1_Iterator_base12@std@@QAE@XZ ; std::_Iterator_base12::~_Iterator_base12(void)
.text$x:00006DDB __unwindfunclet$??1?$_Iterator012@Urandom_access_iterator_tag@std@@_WHPB_WAB_WU_Iterator_base12@2@@std@@QAE@XZ$0 endp
.text$x:00006DDB
.text$x:00006DE0
.text$x:00006DE0 ; =============== S U B R O U T I N E =======================================
.text$x:00006DE0
.text$x:00006DE0
.text$x:00006DE0 __ehhandler$??1?$_Iterator012@Urandom_access_iterator_tag@std@@_WHPB_WAB_WU_Iterator_base12@2@@std@@QAE@XZ proc near
.text$x:00006DE0                                         ; DATA XREF: std::_Iterator012<std::random_access_iterator_tag,wchar_t,int,wchar_t const *,wchar_t const &,std::_Iterator_base12>::~_Iterator012<std::random_access_iterator_tag,wchar_t,int,wchar_t const *,wchar_t const &,std::_Iterator_base12>(void)+5o
.text$x:00006DE0
.text$x:00006DE0 arg_4           = dword ptr  8
.text$x:00006DE0
.text$x:00006DE0                 mov     edx, [esp+arg_4]
.text$x:00006DE4                 lea     eax, [edx+0Ch]
.text$x:00006DE7                 mov     ecx, [edx-8]
.text$x:00006DEA                 xor     ecx, eax
.text$x:00006DEC                 call    @__security_check_cookie@4 ; __security_check_cookie(x)
.text$x:00006DF1                 mov     eax, offset __ehfuncinfo$??1?$_Iterator012@Urandom_access_iterator_tag@std@@_WHPB_WAB_WU_Iterator_base12@2@@std@@QAE@XZ
.text$x:00006DF6                 jmp     ___CxxFrameHandler3
.text$x:00006DF6 __ehhandler$??1?$_Iterator012@Urandom_access_iterator_tag@std@@_WHPB_WAB_WU_Iterator_base12@2@@std@@QAE@XZ endp
.text$x:00006DF6
.text$x:00006DF6 ; ---------------------------------------------------------------------------
.text$x:00006DFB                 align 4
.text$x:00006DFB _text$x         ends
.text$x:00006DFB
.text$mn:00006DFC ; ===========================================================================
.text$mn:00006DFC
.text$mn:00006DFC ; Segment type: Pure code
.text$mn:00006DFC ; Segment permissions: Read/Execute
.text$mn:00006DFC _text$mn        segment para public 'CODE' use32
.text$mn:00006DFC                 assume cs:_text$mn
.text$mn:00006DFC                 ;org 6DFCh
.text$mn:00006DFC ; COMDAT (pick any)
.text$mn:00006DFC                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text$mn:00006DFC
.text$mn:00006DFC ; =============== S U B R O U T I N E =======================================
.text$mn:00006DFC
.text$mn:00006DFC ; Attributes: bp-based frame
.text$mn:00006DFC
.text$mn:00006DFC ; public: __thiscall std::_Revranit<class std::_Vector_iterator<class std::_Vector_val<struct std::_Simple_types<wchar_t>>>, struct std::iterator<struct std::random_access_iterator_tag, wchar_t, int, wchar_t *, wchar_t &>>::~_Revranit<class std::_Vector_iterator<class std::_Vector_val<struct std::_Simple_types<wchar_t>>>, struct std::iterator<struct std::random_access_iterator_tag, wchar_t, int, wchar_t *, wchar_t &>>(void)
.text$mn:00006DFC                 public ??1?$_Revranit@V?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@_W@std@@@std@@@std@@U?$iterator@Urandom_access_iterator_tag@std@@_WHPA_WAA_W@2@@std@@QAE@XZ
.text$mn:00006DFC ??1?$_Revranit@V?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@_W@std@@@std@@@std@@U?$iterator@Urandom_access_iterator_tag@std@@_WHPA_WAA_W@2@@std@@QAE@XZ proc near
.text$mn:00006DFC                                         ; CODE XREF: __unwindfunclet$??0?$reverse_iterator@V?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@_W@std@@@std@@@std@@@std@@QAE@ABV01@@Z$0+3j
.text$mn:00006DFC                                         ; __unwindfunclet$??0?$reverse_iterator@V?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@_W@std@@@std@@@std@@@std@@QAE@V?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@_W@std@@@std@@@1@@Z$2+3j ...
.text$mn:00006DFC
.text$mn:00006DFC var_10          = dword ptr -10h
.text$mn:00006DFC var_C           = dword ptr -0Ch
.text$mn:00006DFC var_4           = dword ptr -4
.text$mn:00006DFC
.text$mn:00006DFC                 push    ebp
.text$mn:00006DFD                 mov     ebp, esp
.text$mn:00006DFF                 push    0FFFFFFFFh
.text$mn:00006E01                 push    offset __ehhandler$??1?$_Revranit@V?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@_W@std@@@std@@@std@@U?$iterator@Urandom_access_iterator_tag@std@@_WHPA_WAA_W@2@@std@@QAE@XZ
.text$mn:00006E06                 mov     eax, large fs:0
.text$mn:00006E0C                 push    eax
.text$mn:00006E0D                 push    ecx
.text$mn:00006E0E                 mov     eax, dword ptr ds:___security_cookie
.text$mn:00006E13                 xor     eax, ebp
.text$mn:00006E15                 push    eax
.text$mn:00006E16                 lea     eax, [ebp+var_C]
.text$mn:00006E19                 mov     large fs:0, eax
.text$mn:00006E1F                 mov     [ebp+var_10], ecx
.text$mn:00006E22                 mov     [ebp+var_4], 0
.text$mn:00006E29                 mov     [ebp+var_4], 0FFFFFFFFh
.text$mn:00006E30                 mov     ecx, [ebp+var_10]
.text$mn:00006E33                 call    ??1?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@_W@std@@@std@@@std@@QAE@XZ ; std::_Vector_iterator<std::_Vector_val<std::_Simple_types<wchar_t>>>::~_Vector_iterator<std::_Vector_val<std::_Simple_types<wchar_t>>>(void)
.text$mn:00006E38                 mov     ecx, [ebp+var_C]
.text$mn:00006E3B                 mov     large fs:0, ecx
.text$mn:00006E42                 pop     ecx
.text$mn:00006E43                 mov     esp, ebp
.text$mn:00006E45                 pop     ebp
.text$mn:00006E46                 retn
.text$mn:00006E46 ??1?$_Revranit@V?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@_W@std@@@std@@@std@@U?$iterator@Urandom_access_iterator_tag@std@@_WHPA_WAA_W@2@@std@@QAE@XZ endp
.text$mn:00006E46
.text$mn:00006E46 ; ---------------------------------------------------------------------------
.text$mn:00006E47                 align 4
.text$mn:00006E47 _text$mn        ends
.text$mn:00006E47
.text$x:00006E48 ; ===========================================================================
.text$x:00006E48
.text$x:00006E48 ; Segment type: Pure code
.text$x:00006E48 ; Segment permissions: Read/Execute
.text$x:00006E48 _text$x         segment para public 'CODE' use32
.text$x:00006E48                 assume cs:_text$x
.text$x:00006E48                 ;org 6E48h
.text$x:00006E48 ; COMDAT (pick associative to section at 6DFC)
.text$x:00006E48                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text$x:00006E48
.text$x:00006E48 ; =============== S U B R O U T I N E =======================================
.text$x:00006E48
.text$x:00006E48
.text$x:00006E48 __unwindfunclet$??1?$_Revranit@V?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@_W@std@@@std@@@std@@U?$iterator@Urandom_access_iterator_tag@std@@_WHPA_WAA_W@2@@std@@QAE@XZ$0 proc near
.text$x:00006E48                                         ; DATA XREF: .xdata$x:0000EA00o
.text$x:00006E48                 mov     ecx, [ebp-10h]
.text$x:00006E4B                 jmp     ??1?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@_W@std@@@std@@@std@@QAE@XZ ; std::_Vector_iterator<std::_Vector_val<std::_Simple_types<wchar_t>>>::~_Vector_iterator<std::_Vector_val<std::_Simple_types<wchar_t>>>(void)
.text$x:00006E4B __unwindfunclet$??1?$_Revranit@V?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@_W@std@@@std@@@std@@U?$iterator@Urandom_access_iterator_tag@std@@_WHPA_WAA_W@2@@std@@QAE@XZ$0 endp
.text$x:00006E4B
.text$x:00006E50
.text$x:00006E50 ; =============== S U B R O U T I N E =======================================
.text$x:00006E50
.text$x:00006E50
.text$x:00006E50 __ehhandler$??1?$_Revranit@V?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@_W@std@@@std@@@std@@U?$iterator@Urandom_access_iterator_tag@std@@_WHPA_WAA_W@2@@std@@QAE@XZ proc near
.text$x:00006E50                                         ; DATA XREF: std::_Revranit<std::_Vector_iterator<std::_Vector_val<std::_Simple_types<wchar_t>>>,std::iterator<std::random_access_iterator_tag,wchar_t,int,wchar_t *,wchar_t &>>::~_Revranit<std::_Vector_iterator<std::_Vector_val<std::_Simple_types<wchar_t>>>,std::iterator<std::random_access_iterator_tag,wchar_t,int,wchar_t *,wchar_t &>>(void)+5o
.text$x:00006E50
.text$x:00006E50 arg_4           = dword ptr  8
.text$x:00006E50
.text$x:00006E50                 mov     edx, [esp+arg_4]
.text$x:00006E54                 lea     eax, [edx+0Ch]
.text$x:00006E57                 mov     ecx, [edx-8]
.text$x:00006E5A                 xor     ecx, eax
.text$x:00006E5C                 call    @__security_check_cookie@4 ; __security_check_cookie(x)
.text$x:00006E61                 mov     eax, offset __ehfuncinfo$??1?$_Revranit@V?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@_W@std@@@std@@@std@@U?$iterator@Urandom_access_iterator_tag@std@@_WHPA_WAA_W@2@@std@@QAE@XZ
.text$x:00006E66                 jmp     ___CxxFrameHandler3
.text$x:00006E66 __ehhandler$??1?$_Revranit@V?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@_W@std@@@std@@@std@@U?$iterator@Urandom_access_iterator_tag@std@@_WHPA_WAA_W@2@@std@@QAE@XZ endp
.text$x:00006E66
.text$x:00006E66 ; ---------------------------------------------------------------------------
.text$x:00006E6B                 align 4
.text$x:00006E6B _text$x         ends
.text$x:00006E6B
.text$mn:00006E6C ; ===========================================================================
.text$mn:00006E6C
.text$mn:00006E6C ; Segment type: Pure code
.text$mn:00006E6C ; Segment permissions: Read/Execute
.text$mn:00006E6C _text$mn        segment para public 'CODE' use32
.text$mn:00006E6C                 assume cs:_text$mn
.text$mn:00006E6C                 ;org 6E6Ch
.text$mn:00006E6C ; COMDAT (pick any)
.text$mn:00006E6C                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text$mn:00006E6C
.text$mn:00006E6C ; =============== S U B R O U T I N E =======================================
.text$mn:00006E6C
.text$mn:00006E6C ; Attributes: bp-based frame
.text$mn:00006E6C
.text$mn:00006E6C ; public: __thiscall std::_String_alloc<0, struct std::_String_base_types<char, class std::allocator<char>>>::~_String_alloc<0, struct std::_String_base_types<char, class std::allocator<char>>>(void)
.text$mn:00006E6C                 public ??1?$_String_alloc@$0A@U?$_String_base_types@DV?$allocator@D@std@@@std@@@std@@QAE@XZ
.text$mn:00006E6C ??1?$_String_alloc@$0A@U?$_String_base_types@DV?$allocator@D@std@@@std@@@std@@QAE@XZ proc near
.text$mn:00006E6C                                         ; CODE XREF: __unwindfunclet$??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@$$QAV01@@Z$0+3j
.text$mn:00006E6C                                         ; __unwindfunclet$??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@PBD@Z$0+3j ...
.text$mn:00006E6C
.text$mn:00006E6C var_10          = dword ptr -10h
.text$mn:00006E6C var_C           = dword ptr -0Ch
.text$mn:00006E6C var_4           = dword ptr -4
.text$mn:00006E6C
.text$mn:00006E6C                 push    ebp
.text$mn:00006E6D                 mov     ebp, esp
.text$mn:00006E6F                 push    0FFFFFFFFh
.text$mn:00006E71                 push    offset __ehhandler$??1?$_String_alloc@$0A@U?$_String_base_types@DV?$allocator@D@std@@@std@@@std@@QAE@XZ
.text$mn:00006E76                 mov     eax, large fs:0
.text$mn:00006E7C                 push    eax
.text$mn:00006E7D                 push    ecx
.text$mn:00006E7E                 mov     eax, dword ptr ds:___security_cookie
.text$mn:00006E83                 xor     eax, ebp
.text$mn:00006E85                 push    eax
.text$mn:00006E86                 lea     eax, [ebp+var_C]
.text$mn:00006E89                 mov     large fs:0, eax
.text$mn:00006E8F                 mov     [ebp+var_10], ecx
.text$mn:00006E92                 mov     [ebp+var_4], 0
.text$mn:00006E99                 mov     ecx, [ebp+var_10]
.text$mn:00006E9C                 call    ?_Free_proxy@?$_String_alloc@$0A@U?$_String_base_types@DV?$allocator@D@std@@@std@@@std@@QAEXXZ ; std::_String_alloc<0,std::_String_base_types<char,std::allocator<char>>>::_Free_proxy(void)
.text$mn:00006EA1                 mov     [ebp+var_4], 0FFFFFFFFh
.text$mn:00006EA8                 mov     ecx, [ebp+var_10]
.text$mn:00006EAB                 call    ??1?$_String_val@U?$_Simple_types@D@std@@@std@@QAE@XZ ; std::_String_val<std::_Simple_types<char>>::~_String_val<std::_Simple_types<char>>(void)
.text$mn:00006EB0                 mov     ecx, [ebp+var_C]
.text$mn:00006EB3                 mov     large fs:0, ecx
.text$mn:00006EBA                 pop     ecx
.text$mn:00006EBB                 mov     esp, ebp
.text$mn:00006EBD                 pop     ebp
.text$mn:00006EBE                 retn
.text$mn:00006EBE ??1?$_String_alloc@$0A@U?$_String_base_types@DV?$allocator@D@std@@@std@@@std@@QAE@XZ endp
.text$mn:00006EBE
.text$mn:00006EBE ; ---------------------------------------------------------------------------
.text$mn:00006EBF                 align 10h
.text$mn:00006EBF _text$mn        ends
.text$mn:00006EBF
.text$x:00006EC0 ; ===========================================================================
.text$x:00006EC0
.text$x:00006EC0 ; Segment type: Pure code
.text$x:00006EC0 ; Segment permissions: Read/Execute
.text$x:00006EC0 _text$x         segment para public 'CODE' use32
.text$x:00006EC0                 assume cs:_text$x
.text$x:00006EC0                 ;org 6EC0h
.text$x:00006EC0 ; COMDAT (pick associative to section at 6E6C)
.text$x:00006EC0                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text$x:00006EC0
.text$x:00006EC0 ; =============== S U B R O U T I N E =======================================
.text$x:00006EC0
.text$x:00006EC0
.text$x:00006EC0 __unwindfunclet$??1?$_String_alloc@$0A@U?$_String_base_types@DV?$allocator@D@std@@@std@@@std@@QAE@XZ$0 proc near
.text$x:00006EC0                                         ; DATA XREF: .xdata$x:0000D5C8o
.text$x:00006EC0                 mov     ecx, [ebp-10h]
.text$x:00006EC3                 jmp     ??1?$_String_val@U?$_Simple_types@D@std@@@std@@QAE@XZ ; std::_String_val<std::_Simple_types<char>>::~_String_val<std::_Simple_types<char>>(void)
.text$x:00006EC3 __unwindfunclet$??1?$_String_alloc@$0A@U?$_String_base_types@DV?$allocator@D@std@@@std@@@std@@QAE@XZ$0 endp
.text$x:00006EC3
.text$x:00006EC8
.text$x:00006EC8 ; =============== S U B R O U T I N E =======================================
.text$x:00006EC8
.text$x:00006EC8
.text$x:00006EC8 __ehhandler$??1?$_String_alloc@$0A@U?$_String_base_types@DV?$allocator@D@std@@@std@@@std@@QAE@XZ proc near
.text$x:00006EC8                                         ; DATA XREF: std::_String_alloc<0,std::_String_base_types<char,std::allocator<char>>>::~_String_alloc<0,std::_String_base_types<char,std::allocator<char>>>(void)+5o
.text$x:00006EC8
.text$x:00006EC8 arg_4           = dword ptr  8
.text$x:00006EC8
.text$x:00006EC8                 mov     edx, [esp+arg_4]
.text$x:00006ECC                 lea     eax, [edx+0Ch]
.text$x:00006ECF                 mov     ecx, [edx-8]
.text$x:00006ED2                 xor     ecx, eax
.text$x:00006ED4                 call    @__security_check_cookie@4 ; __security_check_cookie(x)
.text$x:00006ED9                 mov     eax, offset __ehfuncinfo$??1?$_String_alloc@$0A@U?$_String_base_types@DV?$allocator@D@std@@@std@@@std@@QAE@XZ
.text$x:00006EDE                 jmp     ___CxxFrameHandler3
.text$x:00006EDE __ehhandler$??1?$_String_alloc@$0A@U?$_String_base_types@DV?$allocator@D@std@@@std@@@std@@QAE@XZ endp
.text$x:00006EDE
.text$x:00006EDE ; ---------------------------------------------------------------------------
.text$x:00006EE3                 align 4
.text$x:00006EE3 _text$x         ends
.text$x:00006EE3
.text$mn:00006EE4 ; ===========================================================================
.text$mn:00006EE4
.text$mn:00006EE4 ; Segment type: Pure code
.text$mn:00006EE4 ; Segment permissions: Read/Execute
.text$mn:00006EE4 _text$mn        segment para public 'CODE' use32
.text$mn:00006EE4                 assume cs:_text$mn
.text$mn:00006EE4                 ;org 6EE4h
.text$mn:00006EE4 ; COMDAT (pick any)
.text$mn:00006EE4                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text$mn:00006EE4
.text$mn:00006EE4 ; =============== S U B R O U T I N E =======================================
.text$mn:00006EE4
.text$mn:00006EE4 ; Attributes: bp-based frame
.text$mn:00006EE4
.text$mn:00006EE4 ; public: __thiscall std::_String_alloc<0, struct std::_String_base_types<wchar_t, class std::allocator<wchar_t>>>::~_String_alloc<0, struct std::_String_base_types<wchar_t, class std::allocator<wchar_t>>>(void)
.text$mn:00006EE4                 public ??1?$_String_alloc@$0A@U?$_String_base_types@_WV?$allocator@_W@std@@@std@@@std@@QAE@XZ
.text$mn:00006EE4 ??1?$_String_alloc@$0A@U?$_String_base_types@_WV?$allocator@_W@std@@@std@@@std@@QAE@XZ proc near
.text$mn:00006EE4                                         ; CODE XREF: __unwindfunclet$??$?0V?$reverse_iterator@V?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@_W@std@@@std@@@std@@@std@@X@?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QAE@V?$reverse_iterator@V?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@_W@std@@@std@@@std@@@1@0@Z$2+3j
.text$mn:00006EE4                                         ; __unwindfunclet$??0?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QAE@$$QAV01@@Z$0+3j ...
.text$mn:00006EE4
.text$mn:00006EE4 var_10          = dword ptr -10h
.text$mn:00006EE4 var_C           = dword ptr -0Ch
.text$mn:00006EE4 var_4           = dword ptr -4
.text$mn:00006EE4
.text$mn:00006EE4                 push    ebp
.text$mn:00006EE5                 mov     ebp, esp
.text$mn:00006EE7                 push    0FFFFFFFFh
.text$mn:00006EE9                 push    offset __ehhandler$??1?$_String_alloc@$0A@U?$_String_base_types@_WV?$allocator@_W@std@@@std@@@std@@QAE@XZ
.text$mn:00006EEE                 mov     eax, large fs:0
.text$mn:00006EF4                 push    eax
.text$mn:00006EF5                 push    ecx
.text$mn:00006EF6                 mov     eax, dword ptr ds:___security_cookie
.text$mn:00006EFB                 xor     eax, ebp
.text$mn:00006EFD                 push    eax
.text$mn:00006EFE                 lea     eax, [ebp+var_C]
.text$mn:00006F01                 mov     large fs:0, eax
.text$mn:00006F07                 mov     [ebp+var_10], ecx
.text$mn:00006F0A                 mov     [ebp+var_4], 0
.text$mn:00006F11                 mov     ecx, [ebp+var_10]
.text$mn:00006F14                 call    ?_Free_proxy@?$_String_alloc@$0A@U?$_String_base_types@_WV?$allocator@_W@std@@@std@@@std@@QAEXXZ ; std::_String_alloc<0,std::_String_base_types<wchar_t,std::allocator<wchar_t>>>::_Free_proxy(void)
.text$mn:00006F19                 mov     [ebp+var_4], 0FFFFFFFFh
.text$mn:00006F20                 mov     ecx, [ebp+var_10]
.text$mn:00006F23                 call    ??1?$_String_val@U?$_Simple_types@_W@std@@@std@@QAE@XZ ; std::_String_val<std::_Simple_types<wchar_t>>::~_String_val<std::_Simple_types<wchar_t>>(void)
.text$mn:00006F28                 mov     ecx, [ebp+var_C]
.text$mn:00006F2B                 mov     large fs:0, ecx
.text$mn:00006F32                 pop     ecx
.text$mn:00006F33                 mov     esp, ebp
.text$mn:00006F35                 pop     ebp
.text$mn:00006F36                 retn
.text$mn:00006F36 ??1?$_String_alloc@$0A@U?$_String_base_types@_WV?$allocator@_W@std@@@std@@@std@@QAE@XZ endp
.text$mn:00006F36
.text$mn:00006F36 ; ---------------------------------------------------------------------------
.text$mn:00006F37                 align 4
.text$mn:00006F37 _text$mn        ends
.text$mn:00006F37
.text$x:00006F38 ; ===========================================================================
.text$x:00006F38
.text$x:00006F38 ; Segment type: Pure code
.text$x:00006F38 ; Segment permissions: Read/Execute
.text$x:00006F38 _text$x         segment para public 'CODE' use32
.text$x:00006F38                 assume cs:_text$x
.text$x:00006F38                 ;org 6F38h
.text$x:00006F38 ; COMDAT (pick associative to section at 6EE4)
.text$x:00006F38                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text$x:00006F38
.text$x:00006F38 ; =============== S U B R O U T I N E =======================================
.text$x:00006F38
.text$x:00006F38
.text$x:00006F38 __unwindfunclet$??1?$_String_alloc@$0A@U?$_String_base_types@_WV?$allocator@_W@std@@@std@@@std@@QAE@XZ$0 proc near
.text$x:00006F38                                         ; DATA XREF: .xdata$x:0000D9C4o
.text$x:00006F38                 mov     ecx, [ebp-10h]
.text$x:00006F3B                 jmp     ??1?$_String_val@U?$_Simple_types@_W@std@@@std@@QAE@XZ ; std::_String_val<std::_Simple_types<wchar_t>>::~_String_val<std::_Simple_types<wchar_t>>(void)
.text$x:00006F3B __unwindfunclet$??1?$_String_alloc@$0A@U?$_String_base_types@_WV?$allocator@_W@std@@@std@@@std@@QAE@XZ$0 endp
.text$x:00006F3B
.text$x:00006F40
.text$x:00006F40 ; =============== S U B R O U T I N E =======================================
.text$x:00006F40
.text$x:00006F40
.text$x:00006F40 __ehhandler$??1?$_String_alloc@$0A@U?$_String_base_types@_WV?$allocator@_W@std@@@std@@@std@@QAE@XZ proc near
.text$x:00006F40                                         ; DATA XREF: std::_String_alloc<0,std::_String_base_types<wchar_t,std::allocator<wchar_t>>>::~_String_alloc<0,std::_String_base_types<wchar_t,std::allocator<wchar_t>>>(void)+5o
.text$x:00006F40
.text$x:00006F40 arg_4           = dword ptr  8
.text$x:00006F40
.text$x:00006F40                 mov     edx, [esp+arg_4]
.text$x:00006F44                 lea     eax, [edx+0Ch]
.text$x:00006F47                 mov     ecx, [edx-8]
.text$x:00006F4A                 xor     ecx, eax
.text$x:00006F4C                 call    @__security_check_cookie@4 ; __security_check_cookie(x)
.text$x:00006F51                 mov     eax, offset __ehfuncinfo$??1?$_String_alloc@$0A@U?$_String_base_types@_WV?$allocator@_W@std@@@std@@@std@@QAE@XZ
.text$x:00006F56                 jmp     ___CxxFrameHandler3
.text$x:00006F56 __ehhandler$??1?$_String_alloc@$0A@U?$_String_base_types@_WV?$allocator@_W@std@@@std@@@std@@QAE@XZ endp
.text$x:00006F56
.text$x:00006F56 ; ---------------------------------------------------------------------------
.text$x:00006F5B                 align 4
.text$x:00006F5B _text$x         ends
.text$x:00006F5B
.text$mn:00006F5C ; ===========================================================================
.text$mn:00006F5C
.text$mn:00006F5C ; Segment type: Pure code
.text$mn:00006F5C ; Segment permissions: Read/Execute
.text$mn:00006F5C _text$mn        segment para public 'CODE' use32
.text$mn:00006F5C                 assume cs:_text$mn
.text$mn:00006F5C                 ;org 6F5Ch
.text$mn:00006F5C ; COMDAT (pick any)
.text$mn:00006F5C                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text$mn:00006F5C
.text$mn:00006F5C ; =============== S U B R O U T I N E =======================================
.text$mn:00006F5C
.text$mn:00006F5C ; Attributes: bp-based frame
.text$mn:00006F5C
.text$mn:00006F5C ; public: __thiscall std::_String_const_iterator<class std::_String_val<struct std::_Simple_types<wchar_t>>>::~_String_const_iterator<class std::_String_val<struct std::_Simple_types<wchar_t>>>(void)
.text$mn:00006F5C                 public ??1?$_String_const_iterator@V?$_String_val@U?$_Simple_types@_W@std@@@std@@@std@@QAE@XZ
.text$mn:00006F5C ??1?$_String_const_iterator@V?$_String_val@U?$_Simple_types@_W@std@@@std@@@std@@QAE@XZ proc near
.text$mn:00006F5C                                         ; CODE XREF: BuildMenuFileName(int,uint,std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>> const &)+2C6p
.text$mn:00006F5C                                         ; BuildMenuFileName(int,uint,std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>> const &)+44Bp ...
.text$mn:00006F5C
.text$mn:00006F5C var_10          = dword ptr -10h
.text$mn:00006F5C var_C           = dword ptr -0Ch
.text$mn:00006F5C var_4           = dword ptr -4
.text$mn:00006F5C
.text$mn:00006F5C                 push    ebp
.text$mn:00006F5D                 mov     ebp, esp
.text$mn:00006F5F                 push    0FFFFFFFFh
.text$mn:00006F61                 push    offset __ehhandler$??1?$_String_const_iterator@V?$_String_val@U?$_Simple_types@_W@std@@@std@@@std@@QAE@XZ
.text$mn:00006F66                 mov     eax, large fs:0
.text$mn:00006F6C                 push    eax
.text$mn:00006F6D                 push    ecx
.text$mn:00006F6E                 mov     eax, dword ptr ds:___security_cookie
.text$mn:00006F73                 xor     eax, ebp
.text$mn:00006F75                 push    eax
.text$mn:00006F76                 lea     eax, [ebp+var_C]
.text$mn:00006F79                 mov     large fs:0, eax
.text$mn:00006F7F                 mov     [ebp+var_10], ecx
.text$mn:00006F82                 mov     [ebp+var_4], 0
.text$mn:00006F89                 mov     [ebp+var_4], 0FFFFFFFFh
.text$mn:00006F90                 mov     ecx, [ebp+var_10]
.text$mn:00006F93                 call    ??1?$_Iterator012@Urandom_access_iterator_tag@std@@_WHPB_WAB_WU_Iterator_base12@2@@std@@QAE@XZ ; std::_Iterator012<std::random_access_iterator_tag,wchar_t,int,wchar_t const *,wchar_t const &,std::_Iterator_base12>::~_Iterator012<std::random_access_iterator_tag,wchar_t,int,wchar_t const *,wchar_t const &,std::_Iterator_base12>(void)
.text$mn:00006F98                 mov     ecx, [ebp+var_C]
.text$mn:00006F9B                 mov     large fs:0, ecx
.text$mn:00006FA2                 pop     ecx
.text$mn:00006FA3                 mov     esp, ebp
.text$mn:00006FA5                 pop     ebp
.text$mn:00006FA6                 retn
.text$mn:00006FA6 ??1?$_String_const_iterator@V?$_String_val@U?$_Simple_types@_W@std@@@std@@@std@@QAE@XZ endp
.text$mn:00006FA6
.text$mn:00006FA6 ; ---------------------------------------------------------------------------
.text$mn:00006FA7                 align 4
.text$mn:00006FA7 _text$mn        ends
.text$mn:00006FA7
.text$x:00006FA8 ; ===========================================================================
.text$x:00006FA8
.text$x:00006FA8 ; Segment type: Pure code
.text$x:00006FA8 ; Segment permissions: Read/Execute
.text$x:00006FA8 _text$x         segment para public 'CODE' use32
.text$x:00006FA8                 assume cs:_text$x
.text$x:00006FA8                 ;org 6FA8h
.text$x:00006FA8 ; COMDAT (pick associative to section at 6F5C)
.text$x:00006FA8                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text$x:00006FA8
.text$x:00006FA8 ; =============== S U B R O U T I N E =======================================
.text$x:00006FA8
.text$x:00006FA8
.text$x:00006FA8 __unwindfunclet$??1?$_String_const_iterator@V?$_String_val@U?$_Simple_types@_W@std@@@std@@@std@@QAE@XZ$0 proc near
.text$x:00006FA8                                         ; DATA XREF: .xdata$x:0000EBCCo
.text$x:00006FA8                 mov     ecx, [ebp-10h]
.text$x:00006FAB                 jmp     ??1?$_Iterator012@Urandom_access_iterator_tag@std@@_WHPB_WAB_WU_Iterator_base12@2@@std@@QAE@XZ ; std::_Iterator012<std::random_access_iterator_tag,wchar_t,int,wchar_t const *,wchar_t const &,std::_Iterator_base12>::~_Iterator012<std::random_access_iterator_tag,wchar_t,int,wchar_t const *,wchar_t const &,std::_Iterator_base12>(void)
.text$x:00006FAB __unwindfunclet$??1?$_String_const_iterator@V?$_String_val@U?$_Simple_types@_W@std@@@std@@@std@@QAE@XZ$0 endp
.text$x:00006FAB
.text$x:00006FB0
.text$x:00006FB0 ; =============== S U B R O U T I N E =======================================
.text$x:00006FB0
.text$x:00006FB0
.text$x:00006FB0 __ehhandler$??1?$_String_const_iterator@V?$_String_val@U?$_Simple_types@_W@std@@@std@@@std@@QAE@XZ proc near
.text$x:00006FB0                                         ; DATA XREF: std::_String_const_iterator<std::_String_val<std::_Simple_types<wchar_t>>>::~_String_const_iterator<std::_String_val<std::_Simple_types<wchar_t>>>(void)+5o
.text$x:00006FB0
.text$x:00006FB0 arg_4           = dword ptr  8
.text$x:00006FB0
.text$x:00006FB0                 mov     edx, [esp+arg_4]
.text$x:00006FB4                 lea     eax, [edx+0Ch]
.text$x:00006FB7                 mov     ecx, [edx-8]
.text$x:00006FBA                 xor     ecx, eax
.text$x:00006FBC                 call    @__security_check_cookie@4 ; __security_check_cookie(x)
.text$x:00006FC1                 mov     eax, offset __ehfuncinfo$??1?$_String_const_iterator@V?$_String_val@U?$_Simple_types@_W@std@@@std@@@std@@QAE@XZ
.text$x:00006FC6                 jmp     ___CxxFrameHandler3
.text$x:00006FC6 __ehhandler$??1?$_String_const_iterator@V?$_String_val@U?$_Simple_types@_W@std@@@std@@@std@@QAE@XZ endp
.text$x:00006FC6
.text$x:00006FC6 ; ---------------------------------------------------------------------------
.text$x:00006FCB                 align 4
.text$x:00006FCB _text$x         ends
.text$x:00006FCB
.text$mn:00006FCC ; ===========================================================================
.text$mn:00006FCC
.text$mn:00006FCC ; Segment type: Pure code
.text$mn:00006FCC ; Segment permissions: Read/Execute
.text$mn:00006FCC _text$mn        segment para public 'CODE' use32
.text$mn:00006FCC                 assume cs:_text$mn
.text$mn:00006FCC                 ;org 6FCCh
.text$mn:00006FCC ; COMDAT (pick any)
.text$mn:00006FCC                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text$mn:00006FCC
.text$mn:00006FCC ; =============== S U B R O U T I N E =======================================
.text$mn:00006FCC
.text$mn:00006FCC ; Attributes: bp-based frame
.text$mn:00006FCC
.text$mn:00006FCC ; public: __thiscall std::_String_iterator<class std::_String_val<struct std::_Simple_types<wchar_t>>>::~_String_iterator<class std::_String_val<struct std::_Simple_types<wchar_t>>>(void)
.text$mn:00006FCC                 public ??1?$_String_iterator@V?$_String_val@U?$_Simple_types@_W@std@@@std@@@std@@QAE@XZ
.text$mn:00006FCC ??1?$_String_iterator@V?$_String_val@U?$_Simple_types@_W@std@@@std@@@std@@QAE@XZ proc near
.text$mn:00006FCC                                         ; CODE XREF: stringToUpper(std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>>)+A8p
.text$mn:00006FCC                                         ; __unwindfunclet$?stringToUpper@@YA?AV?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@V12@@Z$1+3j ...
.text$mn:00006FCC
.text$mn:00006FCC var_10          = dword ptr -10h
.text$mn:00006FCC var_C           = dword ptr -0Ch
.text$mn:00006FCC var_4           = dword ptr -4
.text$mn:00006FCC
.text$mn:00006FCC                 push    ebp
.text$mn:00006FCD                 mov     ebp, esp
.text$mn:00006FCF                 push    0FFFFFFFFh
.text$mn:00006FD1                 push    offset __ehhandler$??1?$_String_iterator@V?$_String_val@U?$_Simple_types@_W@std@@@std@@@std@@QAE@XZ
.text$mn:00006FD6                 mov     eax, large fs:0
.text$mn:00006FDC                 push    eax
.text$mn:00006FDD                 push    ecx
.text$mn:00006FDE                 mov     eax, dword ptr ds:___security_cookie
.text$mn:00006FE3                 xor     eax, ebp
.text$mn:00006FE5                 push    eax
.text$mn:00006FE6                 lea     eax, [ebp+var_C]
.text$mn:00006FE9                 mov     large fs:0, eax
.text$mn:00006FEF                 mov     [ebp+var_10], ecx
.text$mn:00006FF2                 mov     [ebp+var_4], 0
.text$mn:00006FF9                 mov     [ebp+var_4], 0FFFFFFFFh
.text$mn:00007000                 mov     ecx, [ebp+var_10]
.text$mn:00007003                 call    ??1?$_String_const_iterator@V?$_String_val@U?$_Simple_types@_W@std@@@std@@@std@@QAE@XZ ; std::_String_const_iterator<std::_String_val<std::_Simple_types<wchar_t>>>::~_String_const_iterator<std::_String_val<std::_Simple_types<wchar_t>>>(void)
.text$mn:00007008                 mov     ecx, [ebp+var_C]
.text$mn:0000700B                 mov     large fs:0, ecx
.text$mn:00007012                 pop     ecx
.text$mn:00007013                 mov     esp, ebp
.text$mn:00007015                 pop     ebp
.text$mn:00007016                 retn
.text$mn:00007016 ??1?$_String_iterator@V?$_String_val@U?$_Simple_types@_W@std@@@std@@@std@@QAE@XZ endp
.text$mn:00007016
.text$mn:00007016 ; ---------------------------------------------------------------------------
.text$mn:00007017                 align 4
.text$mn:00007017 _text$mn        ends
.text$mn:00007017
.text$x:00007018 ; ===========================================================================
.text$x:00007018
.text$x:00007018 ; Segment type: Pure code
.text$x:00007018 ; Segment permissions: Read/Execute
.text$x:00007018 _text$x         segment para public 'CODE' use32
.text$x:00007018                 assume cs:_text$x
.text$x:00007018                 ;org 7018h
.text$x:00007018 ; COMDAT (pick associative to section at 6FCC)
.text$x:00007018                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text$x:00007018
.text$x:00007018 ; =============== S U B R O U T I N E =======================================
.text$x:00007018
.text$x:00007018
.text$x:00007018 __unwindfunclet$??1?$_String_iterator@V?$_String_val@U?$_Simple_types@_W@std@@@std@@@std@@QAE@XZ$0 proc near
.text$x:00007018                                         ; DATA XREF: .xdata$x:0000ED1Co
.text$x:00007018                 mov     ecx, [ebp-10h]
.text$x:0000701B                 jmp     ??1?$_String_const_iterator@V?$_String_val@U?$_Simple_types@_W@std@@@std@@@std@@QAE@XZ ; std::_String_const_iterator<std::_String_val<std::_Simple_types<wchar_t>>>::~_String_const_iterator<std::_String_val<std::_Simple_types<wchar_t>>>(void)
.text$x:0000701B __unwindfunclet$??1?$_String_iterator@V?$_String_val@U?$_Simple_types@_W@std@@@std@@@std@@QAE@XZ$0 endp
.text$x:0000701B
.text$x:00007020
.text$x:00007020 ; =============== S U B R O U T I N E =======================================
.text$x:00007020
.text$x:00007020
.text$x:00007020 __ehhandler$??1?$_String_iterator@V?$_String_val@U?$_Simple_types@_W@std@@@std@@@std@@QAE@XZ proc near
.text$x:00007020                                         ; DATA XREF: std::_String_iterator<std::_String_val<std::_Simple_types<wchar_t>>>::~_String_iterator<std::_String_val<std::_Simple_types<wchar_t>>>(void)+5o
.text$x:00007020
.text$x:00007020 arg_4           = dword ptr  8
.text$x:00007020
.text$x:00007020                 mov     edx, [esp+arg_4]
.text$x:00007024                 lea     eax, [edx+0Ch]
.text$x:00007027                 mov     ecx, [edx-8]
.text$x:0000702A                 xor     ecx, eax
.text$x:0000702C                 call    @__security_check_cookie@4 ; __security_check_cookie(x)
.text$x:00007031                 mov     eax, offset __ehfuncinfo$??1?$_String_iterator@V?$_String_val@U?$_Simple_types@_W@std@@@std@@@std@@QAE@XZ
.text$x:00007036                 jmp     ___CxxFrameHandler3
.text$x:00007036 __ehhandler$??1?$_String_iterator@V?$_String_val@U?$_Simple_types@_W@std@@@std@@@std@@QAE@XZ endp
.text$x:00007036
.text$x:00007036 ; ---------------------------------------------------------------------------
.text$x:0000703B                 align 4
.text$x:0000703B _text$x         ends
.text$x:0000703B
.text$mn:0000703C ; ===========================================================================
.text$mn:0000703C
.text$mn:0000703C ; Segment type: Pure code
.text$mn:0000703C ; Segment permissions: Read/Execute
.text$mn:0000703C _text$mn        segment para public 'CODE' use32
.text$mn:0000703C                 assume cs:_text$mn
.text$mn:0000703C                 ;org 703Ch
.text$mn:0000703C ; COMDAT (pick any)
.text$mn:0000703C                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text$mn:0000703C
.text$mn:0000703C ; =============== S U B R O U T I N E =======================================
.text$mn:0000703C
.text$mn:0000703C ; Attributes: bp-based frame
.text$mn:0000703C
.text$mn:0000703C ; public: __thiscall std::_String_val<struct std::_Simple_types<char>>::~_String_val<struct std::_Simple_types<char>>(void)
.text$mn:0000703C                 public ??1?$_String_val@U?$_Simple_types@D@std@@@std@@QAE@XZ
.text$mn:0000703C ??1?$_String_val@U?$_Simple_types@D@std@@@std@@QAE@XZ proc near
.text$mn:0000703C                                         ; CODE XREF: __unwindfunclet$??0?$_String_alloc@$0A@U?$_String_base_types@DV?$allocator@D@std@@@std@@@std@@QAE@ABV?$allocator@D@1@@Z$0+3j
.text$mn:0000703C                                         ; std::_String_alloc<0,std::_String_base_types<char,std::allocator<char>>>::~_String_alloc<0,std::_String_base_types<char,std::allocator<char>>>(void)+3Fp ...
.text$mn:0000703C
.text$mn:0000703C var_10          = dword ptr -10h
.text$mn:0000703C var_C           = dword ptr -0Ch
.text$mn:0000703C var_4           = dword ptr -4
.text$mn:0000703C
.text$mn:0000703C                 push    ebp
.text$mn:0000703D                 mov     ebp, esp
.text$mn:0000703F                 push    0FFFFFFFFh
.text$mn:00007041                 push    offset __ehhandler$??1?$_String_val@U?$_Simple_types@D@std@@@std@@QAE@XZ
.text$mn:00007046                 mov     eax, large fs:0
.text$mn:0000704C                 push    eax
.text$mn:0000704D                 push    ecx
.text$mn:0000704E                 mov     eax, dword ptr ds:___security_cookie
.text$mn:00007053                 xor     eax, ebp
.text$mn:00007055                 push    eax
.text$mn:00007056                 lea     eax, [ebp+var_C]
.text$mn:00007059                 mov     large fs:0, eax
.text$mn:0000705F                 mov     [ebp+var_10], ecx
.text$mn:00007062                 mov     [ebp+var_4], 0
.text$mn:00007069                 mov     [ebp+var_4], 0FFFFFFFFh
.text$mn:00007070                 mov     ecx, [ebp+var_10] ; this
.text$mn:00007073                 call    ??1_Container_base12@std@@QAE@XZ ; std::_Container_base12::~_Container_base12(void)
.text$mn:00007078                 mov     ecx, [ebp+var_C]
.text$mn:0000707B                 mov     large fs:0, ecx
.text$mn:00007082                 pop     ecx
.text$mn:00007083                 mov     esp, ebp
.text$mn:00007085                 pop     ebp
.text$mn:00007086                 retn
.text$mn:00007086 ??1?$_String_val@U?$_Simple_types@D@std@@@std@@QAE@XZ endp
.text$mn:00007086
.text$mn:00007086 ; ---------------------------------------------------------------------------
.text$mn:00007087                 align 4
.text$mn:00007087 _text$mn        ends
.text$mn:00007087
.text$x:00007088 ; ===========================================================================
.text$x:00007088
.text$x:00007088 ; Segment type: Pure code
.text$x:00007088 ; Segment permissions: Read/Execute
.text$x:00007088 _text$x         segment para public 'CODE' use32
.text$x:00007088                 assume cs:_text$x
.text$x:00007088                 ;org 7088h
.text$x:00007088 ; COMDAT (pick associative to section at 703C)
.text$x:00007088                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text$x:00007088
.text$x:00007088 ; =============== S U B R O U T I N E =======================================
.text$x:00007088
.text$x:00007088
.text$x:00007088 __unwindfunclet$??1?$_String_val@U?$_Simple_types@D@std@@@std@@QAE@XZ$0 proc near
.text$x:00007088                                         ; DATA XREF: .xdata$x:0000D570o
.text$x:00007088                 mov     ecx, [ebp-10h]  ; this
.text$x:0000708B                 jmp     ??1_Container_base12@std@@QAE@XZ ; std::_Container_base12::~_Container_base12(void)
.text$x:0000708B __unwindfunclet$??1?$_String_val@U?$_Simple_types@D@std@@@std@@QAE@XZ$0 endp
.text$x:0000708B
.text$x:00007090
.text$x:00007090 ; =============== S U B R O U T I N E =======================================
.text$x:00007090
.text$x:00007090
.text$x:00007090 __ehhandler$??1?$_String_val@U?$_Simple_types@D@std@@@std@@QAE@XZ proc near
.text$x:00007090                                         ; DATA XREF: std::_String_val<std::_Simple_types<char>>::~_String_val<std::_Simple_types<char>>(void)+5o
.text$x:00007090
.text$x:00007090 arg_4           = dword ptr  8
.text$x:00007090
.text$x:00007090                 mov     edx, [esp+arg_4]
.text$x:00007094                 lea     eax, [edx+0Ch]
.text$x:00007097                 mov     ecx, [edx-8]
.text$x:0000709A                 xor     ecx, eax
.text$x:0000709C                 call    @__security_check_cookie@4 ; __security_check_cookie(x)
.text$x:000070A1                 mov     eax, offset __ehfuncinfo$??1?$_String_val@U?$_Simple_types@D@std@@@std@@QAE@XZ
.text$x:000070A6                 jmp     ___CxxFrameHandler3
.text$x:000070A6 __ehhandler$??1?$_String_val@U?$_Simple_types@D@std@@@std@@QAE@XZ endp
.text$x:000070A6
.text$x:000070A6 ; ---------------------------------------------------------------------------
.text$x:000070AB                 align 4
.text$x:000070AB _text$x         ends
.text$x:000070AB
.text$mn:000070AC ; ===========================================================================
.text$mn:000070AC
.text$mn:000070AC ; Segment type: Pure code
.text$mn:000070AC ; Segment permissions: Read/Execute
.text$mn:000070AC _text$mn        segment para public 'CODE' use32
.text$mn:000070AC                 assume cs:_text$mn
.text$mn:000070AC                 ;org 70ACh
.text$mn:000070AC ; COMDAT (pick any)
.text$mn:000070AC                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text$mn:000070AC
.text$mn:000070AC ; =============== S U B R O U T I N E =======================================
.text$mn:000070AC
.text$mn:000070AC ; Attributes: bp-based frame
.text$mn:000070AC
.text$mn:000070AC ; public: __thiscall std::_String_val<struct std::_Simple_types<wchar_t>>::~_String_val<struct std::_Simple_types<wchar_t>>(void)
.text$mn:000070AC                 public ??1?$_String_val@U?$_Simple_types@_W@std@@@std@@QAE@XZ
.text$mn:000070AC ??1?$_String_val@U?$_Simple_types@_W@std@@@std@@QAE@XZ proc near
.text$mn:000070AC                                         ; CODE XREF: __unwindfunclet$??0?$_String_alloc@$0A@U?$_String_base_types@_WV?$allocator@_W@std@@@std@@@std@@QAE@ABV?$allocator@_W@1@@Z$0+3j
.text$mn:000070AC                                         ; std::_String_alloc<0,std::_String_base_types<wchar_t,std::allocator<wchar_t>>>::~_String_alloc<0,std::_String_base_types<wchar_t,std::allocator<wchar_t>>>(void)+3Fp ...
.text$mn:000070AC
.text$mn:000070AC var_10          = dword ptr -10h
.text$mn:000070AC var_C           = dword ptr -0Ch
.text$mn:000070AC var_4           = dword ptr -4
.text$mn:000070AC
.text$mn:000070AC                 push    ebp
.text$mn:000070AD                 mov     ebp, esp
.text$mn:000070AF                 push    0FFFFFFFFh
.text$mn:000070B1                 push    offset __ehhandler$??1?$_String_val@U?$_Simple_types@_W@std@@@std@@QAE@XZ
.text$mn:000070B6                 mov     eax, large fs:0
.text$mn:000070BC                 push    eax
.text$mn:000070BD                 push    ecx
.text$mn:000070BE                 mov     eax, dword ptr ds:___security_cookie
.text$mn:000070C3                 xor     eax, ebp
.text$mn:000070C5                 push    eax
.text$mn:000070C6                 lea     eax, [ebp+var_C]
.text$mn:000070C9                 mov     large fs:0, eax
.text$mn:000070CF                 mov     [ebp+var_10], ecx
.text$mn:000070D2                 mov     [ebp+var_4], 0
.text$mn:000070D9                 mov     [ebp+var_4], 0FFFFFFFFh
.text$mn:000070E0                 mov     ecx, [ebp+var_10] ; this
.text$mn:000070E3                 call    ??1_Container_base12@std@@QAE@XZ ; std::_Container_base12::~_Container_base12(void)
.text$mn:000070E8                 mov     ecx, [ebp+var_C]
.text$mn:000070EB                 mov     large fs:0, ecx
.text$mn:000070F2                 pop     ecx
.text$mn:000070F3                 mov     esp, ebp
.text$mn:000070F5                 pop     ebp
.text$mn:000070F6                 retn
.text$mn:000070F6 ??1?$_String_val@U?$_Simple_types@_W@std@@@std@@QAE@XZ endp
.text$mn:000070F6
.text$mn:000070F6 ; ---------------------------------------------------------------------------
.text$mn:000070F7                 align 4
.text$mn:000070F7 _text$mn        ends
.text$mn:000070F7
.text$x:000070F8 ; ===========================================================================
.text$x:000070F8
.text$x:000070F8 ; Segment type: Pure code
.text$x:000070F8 ; Segment permissions: Read/Execute
.text$x:000070F8 _text$x         segment para public 'CODE' use32
.text$x:000070F8                 assume cs:_text$x
.text$x:000070F8                 ;org 70F8h
.text$x:000070F8 ; COMDAT (pick associative to section at 70AC)
.text$x:000070F8                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text$x:000070F8
.text$x:000070F8 ; =============== S U B R O U T I N E =======================================
.text$x:000070F8
.text$x:000070F8
.text$x:000070F8 __unwindfunclet$??1?$_String_val@U?$_Simple_types@_W@std@@@std@@QAE@XZ$0 proc near
.text$x:000070F8                                         ; DATA XREF: .xdata$x:0000D96Co
.text$x:000070F8                 mov     ecx, [ebp-10h]  ; this
.text$x:000070FB                 jmp     ??1_Container_base12@std@@QAE@XZ ; std::_Container_base12::~_Container_base12(void)
.text$x:000070FB __unwindfunclet$??1?$_String_val@U?$_Simple_types@_W@std@@@std@@QAE@XZ$0 endp
.text$x:000070FB
.text$x:00007100
.text$x:00007100 ; =============== S U B R O U T I N E =======================================
.text$x:00007100
.text$x:00007100
.text$x:00007100 __ehhandler$??1?$_String_val@U?$_Simple_types@_W@std@@@std@@QAE@XZ proc near
.text$x:00007100                                         ; DATA XREF: std::_String_val<std::_Simple_types<wchar_t>>::~_String_val<std::_Simple_types<wchar_t>>(void)+5o
.text$x:00007100
.text$x:00007100 arg_4           = dword ptr  8
.text$x:00007100
.text$x:00007100                 mov     edx, [esp+arg_4]
.text$x:00007104                 lea     eax, [edx+0Ch]
.text$x:00007107                 mov     ecx, [edx-8]
.text$x:0000710A                 xor     ecx, eax
.text$x:0000710C                 call    @__security_check_cookie@4 ; __security_check_cookie(x)
.text$x:00007111                 mov     eax, offset __ehfuncinfo$??1?$_String_val@U?$_Simple_types@_W@std@@@std@@QAE@XZ
.text$x:00007116                 jmp     ___CxxFrameHandler3
.text$x:00007116 __ehhandler$??1?$_String_val@U?$_Simple_types@_W@std@@@std@@QAE@XZ endp
.text$x:00007116
.text$x:00007116 ; ---------------------------------------------------------------------------
.text$x:0000711B                 align 4
.text$x:0000711B _text$x         ends
.text$x:0000711B
.text$mn:0000711C ; ===========================================================================
.text$mn:0000711C
.text$mn:0000711C ; Segment type: Pure code
.text$mn:0000711C ; Segment permissions: Read/Execute
.text$mn:0000711C _text$mn        segment para public 'CODE' use32
.text$mn:0000711C                 assume cs:_text$mn
.text$mn:0000711C                 ;org 711Ch
.text$mn:0000711C ; COMDAT (pick any)
.text$mn:0000711C                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text$mn:0000711C
.text$mn:0000711C ; =============== S U B R O U T I N E =======================================
.text$mn:0000711C
.text$mn:0000711C ; Attributes: bp-based frame
.text$mn:0000711C
.text$mn:0000711C ; public: __thiscall std::_Vector_alloc<0, struct std::_Vec_base_types<char, class std::allocator<char>>>::~_Vector_alloc<0, struct std::_Vec_base_types<char, class std::allocator<char>>>(void)
.text$mn:0000711C                 public ??1?$_Vector_alloc@$0A@U?$_Vec_base_types@DV?$allocator@D@std@@@std@@@std@@QAE@XZ
.text$mn:0000711C ??1?$_Vector_alloc@$0A@U?$_Vec_base_types@DV?$allocator@D@std@@@std@@@std@@QAE@XZ proc near
.text$mn:0000711C                                         ; CODE XREF: __unwindfunclet$??0?$vector@DV?$allocator@D@std@@@std@@QAE@I@Z$2+3j
.text$mn:0000711C                                         ; std::vector<char,std::allocator<char>>::~vector<char,std::allocator<char>>(void)+3Fp ...
.text$mn:0000711C
.text$mn:0000711C var_10          = dword ptr -10h
.text$mn:0000711C var_C           = dword ptr -0Ch
.text$mn:0000711C var_4           = dword ptr -4
.text$mn:0000711C
.text$mn:0000711C                 push    ebp
.text$mn:0000711D                 mov     ebp, esp
.text$mn:0000711F                 push    0FFFFFFFFh
.text$mn:00007121                 push    offset __ehhandler$??1?$_Vector_alloc@$0A@U?$_Vec_base_types@DV?$allocator@D@std@@@std@@@std@@QAE@XZ
.text$mn:00007126                 mov     eax, large fs:0
.text$mn:0000712C                 push    eax
.text$mn:0000712D                 push    ecx
.text$mn:0000712E                 mov     eax, dword ptr ds:___security_cookie
.text$mn:00007133                 xor     eax, ebp
.text$mn:00007135                 push    eax
.text$mn:00007136                 lea     eax, [ebp+var_C]
.text$mn:00007139                 mov     large fs:0, eax
.text$mn:0000713F                 mov     [ebp+var_10], ecx
.text$mn:00007142                 mov     [ebp+var_4], 0
.text$mn:00007149                 mov     ecx, [ebp+var_10]
.text$mn:0000714C                 call    ?_Free_proxy@?$_Vector_alloc@$0A@U?$_Vec_base_types@DV?$allocator@D@std@@@std@@@std@@QAEXXZ ; std::_Vector_alloc<0,std::_Vec_base_types<char,std::allocator<char>>>::_Free_proxy(void)
.text$mn:00007151                 mov     [ebp+var_4], 0FFFFFFFFh
.text$mn:00007158                 mov     ecx, [ebp+var_10]
.text$mn:0000715B                 call    ??1?$_Vector_val@U?$_Simple_types@D@std@@@std@@QAE@XZ ; std::_Vector_val<std::_Simple_types<char>>::~_Vector_val<std::_Simple_types<char>>(void)
.text$mn:00007160                 mov     ecx, [ebp+var_C]
.text$mn:00007163                 mov     large fs:0, ecx
.text$mn:0000716A                 pop     ecx
.text$mn:0000716B                 mov     esp, ebp
.text$mn:0000716D                 pop     ebp
.text$mn:0000716E                 retn
.text$mn:0000716E ??1?$_Vector_alloc@$0A@U?$_Vec_base_types@DV?$allocator@D@std@@@std@@@std@@QAE@XZ endp
.text$mn:0000716E
.text$mn:0000716E ; ---------------------------------------------------------------------------
.text$mn:0000716F                 align 10h
.text$mn:0000716F _text$mn        ends
.text$mn:0000716F
.text$x:00007170 ; ===========================================================================
.text$x:00007170
.text$x:00007170 ; Segment type: Pure code
.text$x:00007170 ; Segment permissions: Read/Execute
.text$x:00007170 _text$x         segment para public 'CODE' use32
.text$x:00007170                 assume cs:_text$x
.text$x:00007170                 ;org 7170h
.text$x:00007170 ; COMDAT (pick associative to section at 711C)
.text$x:00007170                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text$x:00007170
.text$x:00007170 ; =============== S U B R O U T I N E =======================================
.text$x:00007170
.text$x:00007170
.text$x:00007170 __unwindfunclet$??1?$_Vector_alloc@$0A@U?$_Vec_base_types@DV?$allocator@D@std@@@std@@@std@@QAE@XZ$0 proc near
.text$x:00007170                                         ; DATA XREF: .xdata$x:0000E6FCo
.text$x:00007170                 mov     ecx, [ebp-10h]
.text$x:00007173                 jmp     ??1?$_Vector_val@U?$_Simple_types@D@std@@@std@@QAE@XZ ; std::_Vector_val<std::_Simple_types<char>>::~_Vector_val<std::_Simple_types<char>>(void)
.text$x:00007173 __unwindfunclet$??1?$_Vector_alloc@$0A@U?$_Vec_base_types@DV?$allocator@D@std@@@std@@@std@@QAE@XZ$0 endp
.text$x:00007173
.text$x:00007178
.text$x:00007178 ; =============== S U B R O U T I N E =======================================
.text$x:00007178
.text$x:00007178
.text$x:00007178 __ehhandler$??1?$_Vector_alloc@$0A@U?$_Vec_base_types@DV?$allocator@D@std@@@std@@@std@@QAE@XZ proc near
.text$x:00007178                                         ; DATA XREF: std::_Vector_alloc<0,std::_Vec_base_types<char,std::allocator<char>>>::~_Vector_alloc<0,std::_Vec_base_types<char,std::allocator<char>>>(void)+5o
.text$x:00007178
.text$x:00007178 arg_4           = dword ptr  8
.text$x:00007178
.text$x:00007178                 mov     edx, [esp+arg_4]
.text$x:0000717C                 lea     eax, [edx+0Ch]
.text$x:0000717F                 mov     ecx, [edx-8]
.text$x:00007182                 xor     ecx, eax
.text$x:00007184                 call    @__security_check_cookie@4 ; __security_check_cookie(x)
.text$x:00007189                 mov     eax, offset __ehfuncinfo$??1?$_Vector_alloc@$0A@U?$_Vec_base_types@DV?$allocator@D@std@@@std@@@std@@QAE@XZ
.text$x:0000718E                 jmp     ___CxxFrameHandler3
.text$x:0000718E __ehhandler$??1?$_Vector_alloc@$0A@U?$_Vec_base_types@DV?$allocator@D@std@@@std@@@std@@QAE@XZ endp
.text$x:0000718E
.text$x:0000718E ; ---------------------------------------------------------------------------
.text$x:00007193                 align 4
.text$x:00007193 _text$x         ends
.text$x:00007193
.text$mn:00007194 ; ===========================================================================
.text$mn:00007194
.text$mn:00007194 ; Segment type: Pure code
.text$mn:00007194 ; Segment permissions: Read/Execute
.text$mn:00007194 _text$mn        segment para public 'CODE' use32
.text$mn:00007194                 assume cs:_text$mn
.text$mn:00007194                 ;org 7194h
.text$mn:00007194 ; COMDAT (pick any)
.text$mn:00007194                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text$mn:00007194
.text$mn:00007194 ; =============== S U B R O U T I N E =======================================
.text$mn:00007194
.text$mn:00007194 ; Attributes: bp-based frame
.text$mn:00007194
.text$mn:00007194 ; public: __thiscall std::_Vector_alloc<0, struct std::_Vec_base_types<class std::basic_string<wchar_t, struct std::char_traits<wchar_t>, class std::allocator<wchar_t>>, class std::allocator<class std::basic_string<wchar_t, struct std::char_traits<wchar_t>, class std::allocator<wchar_t>>>>>::~_Vector_alloc<0, struct std::_Vec_base_types<class std::basic_string<wchar_t, struct std::char_traits<wchar_t>, class std::allocator<wchar_t>>, class std::allocator<class std::basic_string<wchar_t, struct std::char_traits<wchar_t>, class std::allocator<wchar_t>>>>>(void)
.text$mn:00007194                 public ??1?$_Vector_alloc@$0A@U?$_Vec_base_types@V?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@V?$allocator@V?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@@2@@std@@@std@@QAE@XZ
.text$mn:00007194 ??1?$_Vector_alloc@$0A@U?$_Vec_base_types@V?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@V?$allocator@V?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@@2@@std@@@std@@QAE@XZ proc near
.text$mn:00007194                                         ; CODE XREF: __unwindfunclet$??0?$vector@V?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@V?$allocator@V?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@@2@@std@@QAE@$$QAV01@@Z$0+3j
.text$mn:00007194                                         ; __unwindfunclet$??0?$vector@V?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@V?$allocator@V?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@@2@@std@@QAE@XZ$0+3j ...
.text$mn:00007194
.text$mn:00007194 var_10          = dword ptr -10h
.text$mn:00007194 var_C           = dword ptr -0Ch
.text$mn:00007194 var_4           = dword ptr -4
.text$mn:00007194
.text$mn:00007194                 push    ebp
.text$mn:00007195                 mov     ebp, esp
.text$mn:00007197                 push    0FFFFFFFFh
.text$mn:00007199                 push    offset __ehhandler$??1?$_Vector_alloc@$0A@U?$_Vec_base_types@V?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@V?$allocator@V?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@@2@@std@@@std@@QAE@XZ
.text$mn:0000719E                 mov     eax, large fs:0
.text$mn:000071A4                 push    eax
.text$mn:000071A5                 push    ecx
.text$mn:000071A6                 mov     eax, dword ptr ds:___security_cookie
.text$mn:000071AB                 xor     eax, ebp
.text$mn:000071AD                 push    eax
.text$mn:000071AE                 lea     eax, [ebp+var_C]
.text$mn:000071B1                 mov     large fs:0, eax
.text$mn:000071B7                 mov     [ebp+var_10], ecx
.text$mn:000071BA                 mov     [ebp+var_4], 0
.text$mn:000071C1                 mov     ecx, [ebp+var_10]
.text$mn:000071C4                 call    ?_Free_proxy@?$_Vector_alloc@$0A@U?$_Vec_base_types@V?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@V?$allocator@V?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@@2@@std@@@std@@QAEXXZ ; std::_Vector_alloc<0,std::_Vec_base_types<std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>>,std::allocator<std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>>>>>::_Free_proxy(void)
.text$mn:000071C9                 mov     [ebp+var_4], 0FFFFFFFFh
.text$mn:000071D0                 mov     ecx, [ebp+var_10]
.text$mn:000071D3                 call    ??1?$_Vector_val@U?$_Simple_types@V?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@@std@@@std@@QAE@XZ ; std::_Vector_val<std::_Simple_types<std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>>>>::~_Vector_val<std::_Simple_types<std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>>>>(void)
.text$mn:000071D8                 mov     ecx, [ebp+var_C]
.text$mn:000071DB                 mov     large fs:0, ecx
.text$mn:000071E2                 pop     ecx
.text$mn:000071E3                 mov     esp, ebp
.text$mn:000071E5                 pop     ebp
.text$mn:000071E6                 retn
.text$mn:000071E6 ??1?$_Vector_alloc@$0A@U?$_Vec_base_types@V?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@V?$allocator@V?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@@2@@std@@@std@@QAE@XZ endp
.text$mn:000071E6
.text$mn:000071E6 ; ---------------------------------------------------------------------------
.text$mn:000071E7                 align 4
.text$mn:000071E7 _text$mn        ends
.text$mn:000071E7
.text$x:000071E8 ; ===========================================================================
.text$x:000071E8
.text$x:000071E8 ; Segment type: Pure code
.text$x:000071E8 ; Segment permissions: Read/Execute
.text$x:000071E8 _text$x         segment para public 'CODE' use32
.text$x:000071E8                 assume cs:_text$x
.text$x:000071E8                 ;org 71E8h
.text$x:000071E8 ; COMDAT (pick associative to section at 7194)
.text$x:000071E8                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text$x:000071E8
.text$x:000071E8 ; =============== S U B R O U T I N E =======================================
.text$x:000071E8
.text$x:000071E8
.text$x:000071E8 __unwindfunclet$??1?$_Vector_alloc@$0A@U?$_Vec_base_types@V?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@V?$allocator@V?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@@2@@std@@@std@@QAE@XZ$0 proc near
.text$x:000071E8                                         ; DATA XREF: .xdata$x:0000E288o
.text$x:000071E8                 mov     ecx, [ebp-10h]
.text$x:000071EB                 jmp     ??1?$_Vector_val@U?$_Simple_types@V?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@@std@@@std@@QAE@XZ ; std::_Vector_val<std::_Simple_types<std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>>>>::~_Vector_val<std::_Simple_types<std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>>>>(void)
.text$x:000071EB __unwindfunclet$??1?$_Vector_alloc@$0A@U?$_Vec_base_types@V?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@V?$allocator@V?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@@2@@std@@@std@@QAE@XZ$0 endp
.text$x:000071EB
.text$x:000071F0
.text$x:000071F0 ; =============== S U B R O U T I N E =======================================
.text$x:000071F0
.text$x:000071F0
.text$x:000071F0 __ehhandler$??1?$_Vector_alloc@$0A@U?$_Vec_base_types@V?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@V?$allocator@V?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@@2@@std@@@std@@QAE@XZ proc near
.text$x:000071F0                                         ; DATA XREF: std::_Vector_alloc<0,std::_Vec_base_types<std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>>,std::allocator<std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>>>>>::~_Vector_alloc<0,std::_Vec_base_types<std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>>,std::allocator<std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>>>>>(void)+5o
.text$x:000071F0
.text$x:000071F0 arg_4           = dword ptr  8
.text$x:000071F0
.text$x:000071F0                 mov     edx, [esp+arg_4]
.text$x:000071F4                 lea     eax, [edx+0Ch]
.text$x:000071F7                 mov     ecx, [edx-8]
.text$x:000071FA                 xor     ecx, eax
.text$x:000071FC                 call    @__security_check_cookie@4 ; __security_check_cookie(x)
.text$x:00007201                 mov     eax, offset __ehfuncinfo$??1?$_Vector_alloc@$0A@U?$_Vec_base_types@V?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@V?$allocator@V?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@@2@@std@@@std@@QAE@XZ
.text$x:00007206                 jmp     ___CxxFrameHandler3
.text$x:00007206 __ehhandler$??1?$_Vector_alloc@$0A@U?$_Vec_base_types@V?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@V?$allocator@V?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@@2@@std@@@std@@QAE@XZ endp
.text$x:00007206
.text$x:00007206 ; ---------------------------------------------------------------------------
.text$x:0000720B                 align 4
.text$x:0000720B _text$x         ends
.text$x:0000720B
.text$mn:0000720C ; ===========================================================================
.text$mn:0000720C
.text$mn:0000720C ; Segment type: Pure code
.text$mn:0000720C ; Segment permissions: Read/Execute
.text$mn:0000720C _text$mn        segment para public 'CODE' use32
.text$mn:0000720C                 assume cs:_text$mn
.text$mn:0000720C                 ;org 720Ch
.text$mn:0000720C ; COMDAT (pick any)
.text$mn:0000720C                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text$mn:0000720C
.text$mn:0000720C ; =============== S U B R O U T I N E =======================================
.text$mn:0000720C
.text$mn:0000720C ; Attributes: bp-based frame
.text$mn:0000720C
.text$mn:0000720C ; public: __thiscall std::_Vector_alloc<0, struct std::_Vec_base_types<wchar_t, class std::allocator<wchar_t>>>::~_Vector_alloc<0, struct std::_Vec_base_types<wchar_t, class std::allocator<wchar_t>>>(void)
.text$mn:0000720C                 public ??1?$_Vector_alloc@$0A@U?$_Vec_base_types@_WV?$allocator@_W@std@@@std@@@std@@QAE@XZ
.text$mn:0000720C ??1?$_Vector_alloc@$0A@U?$_Vec_base_types@_WV?$allocator@_W@std@@@std@@@std@@QAE@XZ proc near
.text$mn:0000720C                                         ; CODE XREF: __unwindfunclet$??0?$vector@_WV?$allocator@_W@std@@@std@@QAE@I@Z$2+3j
.text$mn:0000720C                                         ; __unwindfunclet$??0?$vector@_WV?$allocator@_W@std@@@std@@QAE@XZ$0+3j ...
.text$mn:0000720C
.text$mn:0000720C var_10          = dword ptr -10h
.text$mn:0000720C var_C           = dword ptr -0Ch
.text$mn:0000720C var_4           = dword ptr -4
.text$mn:0000720C
.text$mn:0000720C                 push    ebp
.text$mn:0000720D                 mov     ebp, esp
.text$mn:0000720F                 push    0FFFFFFFFh
.text$mn:00007211                 push    offset __ehhandler$??1?$_Vector_alloc@$0A@U?$_Vec_base_types@_WV?$allocator@_W@std@@@std@@@std@@QAE@XZ
.text$mn:00007216                 mov     eax, large fs:0
.text$mn:0000721C                 push    eax
.text$mn:0000721D                 push    ecx
.text$mn:0000721E                 mov     eax, dword ptr ds:___security_cookie
.text$mn:00007223                 xor     eax, ebp
.text$mn:00007225                 push    eax
.text$mn:00007226                 lea     eax, [ebp+var_C]
.text$mn:00007229                 mov     large fs:0, eax
.text$mn:0000722F                 mov     [ebp+var_10], ecx
.text$mn:00007232                 mov     [ebp+var_4], 0
.text$mn:00007239                 mov     ecx, [ebp+var_10]
.text$mn:0000723C                 call    ?_Free_proxy@?$_Vector_alloc@$0A@U?$_Vec_base_types@_WV?$allocator@_W@std@@@std@@@std@@QAEXXZ ; std::_Vector_alloc<0,std::_Vec_base_types<wchar_t,std::allocator<wchar_t>>>::_Free_proxy(void)
.text$mn:00007241                 mov     [ebp+var_4], 0FFFFFFFFh
.text$mn:00007248                 mov     ecx, [ebp+var_10]
.text$mn:0000724B                 call    ??1?$_Vector_val@U?$_Simple_types@_W@std@@@std@@QAE@XZ ; std::_Vector_val<std::_Simple_types<wchar_t>>::~_Vector_val<std::_Simple_types<wchar_t>>(void)
.text$mn:00007250                 mov     ecx, [ebp+var_C]
.text$mn:00007253                 mov     large fs:0, ecx
.text$mn:0000725A                 pop     ecx
.text$mn:0000725B                 mov     esp, ebp
.text$mn:0000725D                 pop     ebp
.text$mn:0000725E                 retn
.text$mn:0000725E ??1?$_Vector_alloc@$0A@U?$_Vec_base_types@_WV?$allocator@_W@std@@@std@@@std@@QAE@XZ endp
.text$mn:0000725E
.text$mn:0000725E ; ---------------------------------------------------------------------------
.text$mn:0000725F                 align 10h
.text$mn:0000725F _text$mn        ends
.text$mn:0000725F
.text$x:00007260 ; ===========================================================================
.text$x:00007260
.text$x:00007260 ; Segment type: Pure code
.text$x:00007260 ; Segment permissions: Read/Execute
.text$x:00007260 _text$x         segment para public 'CODE' use32
.text$x:00007260                 assume cs:_text$x
.text$x:00007260                 ;org 7260h
.text$x:00007260 ; COMDAT (pick associative to section at 720C)
.text$x:00007260                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text$x:00007260
.text$x:00007260 ; =============== S U B R O U T I N E =======================================
.text$x:00007260
.text$x:00007260
.text$x:00007260 __unwindfunclet$??1?$_Vector_alloc@$0A@U?$_Vec_base_types@_WV?$allocator@_W@std@@@std@@@std@@QAE@XZ$0 proc near
.text$x:00007260                                         ; DATA XREF: .xdata$x:0000E440o
.text$x:00007260                 mov     ecx, [ebp-10h]
.text$x:00007263                 jmp     ??1?$_Vector_val@U?$_Simple_types@_W@std@@@std@@QAE@XZ ; std::_Vector_val<std::_Simple_types<wchar_t>>::~_Vector_val<std::_Simple_types<wchar_t>>(void)
.text$x:00007263 __unwindfunclet$??1?$_Vector_alloc@$0A@U?$_Vec_base_types@_WV?$allocator@_W@std@@@std@@@std@@QAE@XZ$0 endp
.text$x:00007263
.text$x:00007268
.text$x:00007268 ; =============== S U B R O U T I N E =======================================
.text$x:00007268
.text$x:00007268
.text$x:00007268 __ehhandler$??1?$_Vector_alloc@$0A@U?$_Vec_base_types@_WV?$allocator@_W@std@@@std@@@std@@QAE@XZ proc near
.text$x:00007268                                         ; DATA XREF: std::_Vector_alloc<0,std::_Vec_base_types<wchar_t,std::allocator<wchar_t>>>::~_Vector_alloc<0,std::_Vec_base_types<wchar_t,std::allocator<wchar_t>>>(void)+5o
.text$x:00007268
.text$x:00007268 arg_4           = dword ptr  8
.text$x:00007268
.text$x:00007268                 mov     edx, [esp+arg_4]
.text$x:0000726C                 lea     eax, [edx+0Ch]
.text$x:0000726F                 mov     ecx, [edx-8]
.text$x:00007272                 xor     ecx, eax
.text$x:00007274                 call    @__security_check_cookie@4 ; __security_check_cookie(x)
.text$x:00007279                 mov     eax, offset __ehfuncinfo$??1?$_Vector_alloc@$0A@U?$_Vec_base_types@_WV?$allocator@_W@std@@@std@@@std@@QAE@XZ
.text$x:0000727E                 jmp     ___CxxFrameHandler3
.text$x:0000727E __ehhandler$??1?$_Vector_alloc@$0A@U?$_Vec_base_types@_WV?$allocator@_W@std@@@std@@@std@@QAE@XZ endp
.text$x:0000727E
.text$x:0000727E ; ---------------------------------------------------------------------------
.text$x:00007283                 align 4
.text$x:00007283 _text$x         ends
.text$x:00007283
.text$mn:00007284 ; ===========================================================================
.text$mn:00007284
.text$mn:00007284 ; Segment type: Pure code
.text$mn:00007284 ; Segment permissions: Read/Execute
.text$mn:00007284 _text$mn        segment para public 'CODE' use32
.text$mn:00007284                 assume cs:_text$mn
.text$mn:00007284                 ;org 7284h
.text$mn:00007284 ; COMDAT (pick any)
.text$mn:00007284                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text$mn:00007284
.text$mn:00007284 ; =============== S U B R O U T I N E =======================================
.text$mn:00007284
.text$mn:00007284 ; Attributes: bp-based frame
.text$mn:00007284
.text$mn:00007284 ; public: __thiscall std::_Vector_const_iterator<class std::_Vector_val<struct std::_Simple_types<wchar_t>>>::~_Vector_const_iterator<class std::_Vector_val<struct std::_Simple_types<wchar_t>>>(void)
.text$mn:00007284                 public ??1?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@_W@std@@@std@@@std@@QAE@XZ
.text$mn:00007284 ??1?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@_W@std@@@std@@@std@@QAE@XZ proc near
.text$mn:00007284                                         ; CODE XREF: __unwindfunclet$??0?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@_W@std@@@std@@@std@@QAE@ABV01@@Z$0+3j
.text$mn:00007284                                         ; __unwindfunclet$??0?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@_W@std@@@std@@@std@@QAE@PA_WPBU_Container_base12@1@@Z$0+3j ...
.text$mn:00007284
.text$mn:00007284 var_10          = dword ptr -10h
.text$mn:00007284 var_C           = dword ptr -0Ch
.text$mn:00007284 var_4           = dword ptr -4
.text$mn:00007284
.text$mn:00007284                 push    ebp
.text$mn:00007285                 mov     ebp, esp
.text$mn:00007287                 push    0FFFFFFFFh
.text$mn:00007289                 push    offset __ehhandler$??1?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@_W@std@@@std@@@std@@QAE@XZ
.text$mn:0000728E                 mov     eax, large fs:0
.text$mn:00007294                 push    eax
.text$mn:00007295                 push    ecx
.text$mn:00007296                 mov     eax, dword ptr ds:___security_cookie
.text$mn:0000729B                 xor     eax, ebp
.text$mn:0000729D                 push    eax
.text$mn:0000729E                 lea     eax, [ebp+var_C]
.text$mn:000072A1                 mov     large fs:0, eax
.text$mn:000072A7                 mov     [ebp+var_10], ecx
.text$mn:000072AA                 mov     [ebp+var_4], 0
.text$mn:000072B1                 mov     [ebp+var_4], 0FFFFFFFFh
.text$mn:000072B8                 mov     ecx, [ebp+var_10]
.text$mn:000072BB                 call    ??1?$_Iterator012@Urandom_access_iterator_tag@std@@_WHPB_WAB_WU_Iterator_base12@2@@std@@QAE@XZ ; std::_Iterator012<std::random_access_iterator_tag,wchar_t,int,wchar_t const *,wchar_t const &,std::_Iterator_base12>::~_Iterator012<std::random_access_iterator_tag,wchar_t,int,wchar_t const *,wchar_t const &,std::_Iterator_base12>(void)
.text$mn:000072C0                 mov     ecx, [ebp+var_C]
.text$mn:000072C3                 mov     large fs:0, ecx
.text$mn:000072CA                 pop     ecx
.text$mn:000072CB                 mov     esp, ebp
.text$mn:000072CD                 pop     ebp
.text$mn:000072CE                 retn
.text$mn:000072CE ??1?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@_W@std@@@std@@@std@@QAE@XZ endp
.text$mn:000072CE
.text$mn:000072CE ; ---------------------------------------------------------------------------
.text$mn:000072CF                 align 10h
.text$mn:000072CF _text$mn        ends
.text$mn:000072CF
.text$x:000072D0 ; ===========================================================================
.text$x:000072D0
.text$x:000072D0 ; Segment type: Pure code
.text$x:000072D0 ; Segment permissions: Read/Execute
.text$x:000072D0 _text$x         segment para public 'CODE' use32
.text$x:000072D0                 assume cs:_text$x
.text$x:000072D0                 ;org 72D0h
.text$x:000072D0 ; COMDAT (pick associative to section at 7284)
.text$x:000072D0                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text$x:000072D0
.text$x:000072D0 ; =============== S U B R O U T I N E =======================================
.text$x:000072D0
.text$x:000072D0
.text$x:000072D0 __unwindfunclet$??1?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@_W@std@@@std@@@std@@QAE@XZ$0 proc near
.text$x:000072D0                                         ; DATA XREF: .xdata$x:0000E864o
.text$x:000072D0                 mov     ecx, [ebp-10h]
.text$x:000072D3                 jmp     ??1?$_Iterator012@Urandom_access_iterator_tag@std@@_WHPB_WAB_WU_Iterator_base12@2@@std@@QAE@XZ ; std::_Iterator012<std::random_access_iterator_tag,wchar_t,int,wchar_t const *,wchar_t const &,std::_Iterator_base12>::~_Iterator012<std::random_access_iterator_tag,wchar_t,int,wchar_t const *,wchar_t const &,std::_Iterator_base12>(void)
.text$x:000072D3 __unwindfunclet$??1?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@_W@std@@@std@@@std@@QAE@XZ$0 endp
.text$x:000072D3
.text$x:000072D8
.text$x:000072D8 ; =============== S U B R O U T I N E =======================================
.text$x:000072D8
.text$x:000072D8
.text$x:000072D8 __ehhandler$??1?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@_W@std@@@std@@@std@@QAE@XZ proc near
.text$x:000072D8                                         ; DATA XREF: std::_Vector_const_iterator<std::_Vector_val<std::_Simple_types<wchar_t>>>::~_Vector_const_iterator<std::_Vector_val<std::_Simple_types<wchar_t>>>(void)+5o
.text$x:000072D8
.text$x:000072D8 arg_4           = dword ptr  8
.text$x:000072D8
.text$x:000072D8                 mov     edx, [esp+arg_4]
.text$x:000072DC                 lea     eax, [edx+0Ch]
.text$x:000072DF                 mov     ecx, [edx-8]
.text$x:000072E2                 xor     ecx, eax
.text$x:000072E4                 call    @__security_check_cookie@4 ; __security_check_cookie(x)
.text$x:000072E9                 mov     eax, offset __ehfuncinfo$??1?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@_W@std@@@std@@@std@@QAE@XZ
.text$x:000072EE                 jmp     ___CxxFrameHandler3
.text$x:000072EE __ehhandler$??1?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@_W@std@@@std@@@std@@QAE@XZ endp
.text$x:000072EE
.text$x:000072EE ; ---------------------------------------------------------------------------
.text$x:000072F3                 align 4
.text$x:000072F3 _text$x         ends
.text$x:000072F3
.text$mn:000072F4 ; ===========================================================================
.text$mn:000072F4
.text$mn:000072F4 ; Segment type: Pure code
.text$mn:000072F4 ; Segment permissions: Read/Execute
.text$mn:000072F4 _text$mn        segment para public 'CODE' use32
.text$mn:000072F4                 assume cs:_text$mn
.text$mn:000072F4                 ;org 72F4h
.text$mn:000072F4 ; COMDAT (pick any)
.text$mn:000072F4                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text$mn:000072F4
.text$mn:000072F4 ; =============== S U B R O U T I N E =======================================
.text$mn:000072F4
.text$mn:000072F4 ; Attributes: bp-based frame
.text$mn:000072F4
.text$mn:000072F4 ; public: __thiscall std::_Vector_iterator<class std::_Vector_val<struct std::_Simple_types<wchar_t>>>::~_Vector_iterator<class std::_Vector_val<struct std::_Simple_types<wchar_t>>>(void)
.text$mn:000072F4                 public ??1?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@_W@std@@@std@@@std@@QAE@XZ
.text$mn:000072F4 ??1?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@_W@std@@@std@@@std@@QAE@XZ proc near
.text$mn:000072F4                                         ; CODE XREF: BuildMenuFileName(int,uint,std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>> const &)+201p
.text$mn:000072F4                                         ; __unwindfunclet$?BuildMenuFileName@@YA?AV?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@HIABV12@@Z$3+6j ...
.text$mn:000072F4
.text$mn:000072F4 var_10          = dword ptr -10h
.text$mn:000072F4 var_C           = dword ptr -0Ch
.text$mn:000072F4 var_4           = dword ptr -4
.text$mn:000072F4
.text$mn:000072F4                 push    ebp
.text$mn:000072F5                 mov     ebp, esp
.text$mn:000072F7                 push    0FFFFFFFFh
.text$mn:000072F9                 push    offset __ehhandler$??1?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@_W@std@@@std@@@std@@QAE@XZ
.text$mn:000072FE                 mov     eax, large fs:0
.text$mn:00007304                 push    eax
.text$mn:00007305                 push    ecx
.text$mn:00007306                 mov     eax, dword ptr ds:___security_cookie
.text$mn:0000730B                 xor     eax, ebp
.text$mn:0000730D                 push    eax
.text$mn:0000730E                 lea     eax, [ebp+var_C]
.text$mn:00007311                 mov     large fs:0, eax
.text$mn:00007317                 mov     [ebp+var_10], ecx
.text$mn:0000731A                 mov     [ebp+var_4], 0
.text$mn:00007321                 mov     [ebp+var_4], 0FFFFFFFFh
.text$mn:00007328                 mov     ecx, [ebp+var_10]
.text$mn:0000732B                 call    ??1?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@_W@std@@@std@@@std@@QAE@XZ ; std::_Vector_const_iterator<std::_Vector_val<std::_Simple_types<wchar_t>>>::~_Vector_const_iterator<std::_Vector_val<std::_Simple_types<wchar_t>>>(void)
.text$mn:00007330                 mov     ecx, [ebp+var_C]
.text$mn:00007333                 mov     large fs:0, ecx
.text$mn:0000733A                 pop     ecx
.text$mn:0000733B                 mov     esp, ebp
.text$mn:0000733D                 pop     ebp
.text$mn:0000733E                 retn
.text$mn:0000733E ??1?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@_W@std@@@std@@@std@@QAE@XZ endp
.text$mn:0000733E
.text$mn:0000733E ; ---------------------------------------------------------------------------
.text$mn:0000733F                 align 10h
.text$mn:0000733F _text$mn        ends
.text$mn:0000733F
.text$x:00007340 ; ===========================================================================
.text$x:00007340
.text$x:00007340 ; Segment type: Pure code
.text$x:00007340 ; Segment permissions: Read/Execute
.text$x:00007340 _text$x         segment para public 'CODE' use32
.text$x:00007340                 assume cs:_text$x
.text$x:00007340                 ;org 7340h
.text$x:00007340 ; COMDAT (pick associative to section at 72F4)
.text$x:00007340                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text$x:00007340
.text$x:00007340 ; =============== S U B R O U T I N E =======================================
.text$x:00007340
.text$x:00007340
.text$x:00007340 __unwindfunclet$??1?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@_W@std@@@std@@@std@@QAE@XZ$0 proc near
.text$x:00007340                                         ; DATA XREF: .xdata$x:0000E91Co
.text$x:00007340                 mov     ecx, [ebp-10h]
.text$x:00007343                 jmp     ??1?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@_W@std@@@std@@@std@@QAE@XZ ; std::_Vector_const_iterator<std::_Vector_val<std::_Simple_types<wchar_t>>>::~_Vector_const_iterator<std::_Vector_val<std::_Simple_types<wchar_t>>>(void)
.text$x:00007343 __unwindfunclet$??1?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@_W@std@@@std@@@std@@QAE@XZ$0 endp
.text$x:00007343
.text$x:00007348
.text$x:00007348 ; =============== S U B R O U T I N E =======================================
.text$x:00007348
.text$x:00007348
.text$x:00007348 __ehhandler$??1?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@_W@std@@@std@@@std@@QAE@XZ proc near
.text$x:00007348                                         ; DATA XREF: std::_Vector_iterator<std::_Vector_val<std::_Simple_types<wchar_t>>>::~_Vector_iterator<std::_Vector_val<std::_Simple_types<wchar_t>>>(void)+5o
.text$x:00007348
.text$x:00007348 arg_4           = dword ptr  8
.text$x:00007348
.text$x:00007348                 mov     edx, [esp+arg_4]
.text$x:0000734C                 lea     eax, [edx+0Ch]
.text$x:0000734F                 mov     ecx, [edx-8]
.text$x:00007352                 xor     ecx, eax
.text$x:00007354                 call    @__security_check_cookie@4 ; __security_check_cookie(x)
.text$x:00007359                 mov     eax, offset __ehfuncinfo$??1?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@_W@std@@@std@@@std@@QAE@XZ
.text$x:0000735E                 jmp     ___CxxFrameHandler3
.text$x:0000735E __ehhandler$??1?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@_W@std@@@std@@@std@@QAE@XZ endp
.text$x:0000735E
.text$x:0000735E ; ---------------------------------------------------------------------------
.text$x:00007363                 align 4
.text$x:00007363 _text$x         ends
.text$x:00007363
.text$mn:00007364 ; ===========================================================================
.text$mn:00007364
.text$mn:00007364 ; Segment type: Pure code
.text$mn:00007364 ; Segment permissions: Read/Execute
.text$mn:00007364 _text$mn        segment para public 'CODE' use32
.text$mn:00007364                 assume cs:_text$mn
.text$mn:00007364                 ;org 7364h
.text$mn:00007364 ; COMDAT (pick any)
.text$mn:00007364                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text$mn:00007364
.text$mn:00007364 ; =============== S U B R O U T I N E =======================================
.text$mn:00007364
.text$mn:00007364 ; Attributes: bp-based frame
.text$mn:00007364
.text$mn:00007364 ; public: __thiscall std::_Vector_val<struct std::_Simple_types<char>>::~_Vector_val<struct std::_Simple_types<char>>(void)
.text$mn:00007364                 public ??1?$_Vector_val@U?$_Simple_types@D@std@@@std@@QAE@XZ
.text$mn:00007364 ??1?$_Vector_val@U?$_Simple_types@D@std@@@std@@QAE@XZ proc near
.text$mn:00007364                                         ; CODE XREF: __unwindfunclet$??0?$_Vector_alloc@$0A@U?$_Vec_base_types@DV?$allocator@D@std@@@std@@@std@@QAE@ABV?$allocator@D@1@@Z$0+3j
.text$mn:00007364                                         ; std::_Vector_alloc<0,std::_Vec_base_types<char,std::allocator<char>>>::~_Vector_alloc<0,std::_Vec_base_types<char,std::allocator<char>>>(void)+3Fp ...
.text$mn:00007364
.text$mn:00007364 var_10          = dword ptr -10h
.text$mn:00007364 var_C           = dword ptr -0Ch
.text$mn:00007364 var_4           = dword ptr -4
.text$mn:00007364
.text$mn:00007364                 push    ebp
.text$mn:00007365                 mov     ebp, esp
.text$mn:00007367                 push    0FFFFFFFFh
.text$mn:00007369                 push    offset __ehhandler$??1?$_Vector_val@U?$_Simple_types@D@std@@@std@@QAE@XZ
.text$mn:0000736E                 mov     eax, large fs:0
.text$mn:00007374                 push    eax
.text$mn:00007375                 push    ecx
.text$mn:00007376                 mov     eax, dword ptr ds:___security_cookie
.text$mn:0000737B                 xor     eax, ebp
.text$mn:0000737D                 push    eax
.text$mn:0000737E                 lea     eax, [ebp+var_C]
.text$mn:00007381                 mov     large fs:0, eax
.text$mn:00007387                 mov     [ebp+var_10], ecx
.text$mn:0000738A                 mov     [ebp+var_4], 0
.text$mn:00007391                 mov     [ebp+var_4], 0FFFFFFFFh
.text$mn:00007398                 mov     ecx, [ebp+var_10] ; this
.text$mn:0000739B                 call    ??1_Container_base12@std@@QAE@XZ ; std::_Container_base12::~_Container_base12(void)
.text$mn:000073A0                 mov     ecx, [ebp+var_C]
.text$mn:000073A3                 mov     large fs:0, ecx
.text$mn:000073AA                 pop     ecx
.text$mn:000073AB                 mov     esp, ebp
.text$mn:000073AD                 pop     ebp
.text$mn:000073AE                 retn
.text$mn:000073AE ??1?$_Vector_val@U?$_Simple_types@D@std@@@std@@QAE@XZ endp
.text$mn:000073AE
.text$mn:000073AE ; ---------------------------------------------------------------------------
.text$mn:000073AF                 align 10h
.text$mn:000073AF _text$mn        ends
.text$mn:000073AF
.text$x:000073B0 ; ===========================================================================
.text$x:000073B0
.text$x:000073B0 ; Segment type: Pure code
.text$x:000073B0 ; Segment permissions: Read/Execute
.text$x:000073B0 _text$x         segment para public 'CODE' use32
.text$x:000073B0                 assume cs:_text$x
.text$x:000073B0                 ;org 73B0h
.text$x:000073B0 ; COMDAT (pick associative to section at 7364)
.text$x:000073B0                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text$x:000073B0
.text$x:000073B0 ; =============== S U B R O U T I N E =======================================
.text$x:000073B0
.text$x:000073B0
.text$x:000073B0 __unwindfunclet$??1?$_Vector_val@U?$_Simple_types@D@std@@@std@@QAE@XZ$0 proc near
.text$x:000073B0                                         ; DATA XREF: .xdata$x:0000E6A4o
.text$x:000073B0                 mov     ecx, [ebp-10h]  ; this
.text$x:000073B3                 jmp     ??1_Container_base12@std@@QAE@XZ ; std::_Container_base12::~_Container_base12(void)
.text$x:000073B3 __unwindfunclet$??1?$_Vector_val@U?$_Simple_types@D@std@@@std@@QAE@XZ$0 endp
.text$x:000073B3
.text$x:000073B8
.text$x:000073B8 ; =============== S U B R O U T I N E =======================================
.text$x:000073B8
.text$x:000073B8
.text$x:000073B8 __ehhandler$??1?$_Vector_val@U?$_Simple_types@D@std@@@std@@QAE@XZ proc near
.text$x:000073B8                                         ; DATA XREF: std::_Vector_val<std::_Simple_types<char>>::~_Vector_val<std::_Simple_types<char>>(void)+5o
.text$x:000073B8
.text$x:000073B8 arg_4           = dword ptr  8
.text$x:000073B8
.text$x:000073B8                 mov     edx, [esp+arg_4]
.text$x:000073BC                 lea     eax, [edx+0Ch]
.text$x:000073BF                 mov     ecx, [edx-8]
.text$x:000073C2                 xor     ecx, eax
.text$x:000073C4                 call    @__security_check_cookie@4 ; __security_check_cookie(x)
.text$x:000073C9                 mov     eax, offset __ehfuncinfo$??1?$_Vector_val@U?$_Simple_types@D@std@@@std@@QAE@XZ
.text$x:000073CE                 jmp     ___CxxFrameHandler3
.text$x:000073CE __ehhandler$??1?$_Vector_val@U?$_Simple_types@D@std@@@std@@QAE@XZ endp
.text$x:000073CE
.text$x:000073CE ; ---------------------------------------------------------------------------
.text$x:000073D3                 align 4
.text$x:000073D3 _text$x         ends
.text$x:000073D3
.text$mn:000073D4 ; ===========================================================================
.text$mn:000073D4
.text$mn:000073D4 ; Segment type: Pure code
.text$mn:000073D4 ; Segment permissions: Read/Execute
.text$mn:000073D4 _text$mn        segment para public 'CODE' use32
.text$mn:000073D4                 assume cs:_text$mn
.text$mn:000073D4                 ;org 73D4h
.text$mn:000073D4 ; COMDAT (pick any)
.text$mn:000073D4                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text$mn:000073D4
.text$mn:000073D4 ; =============== S U B R O U T I N E =======================================
.text$mn:000073D4
.text$mn:000073D4 ; Attributes: bp-based frame
.text$mn:000073D4
.text$mn:000073D4 ; public: __thiscall std::_Vector_val<struct std::_Simple_types<class std::basic_string<wchar_t, struct std::char_traits<wchar_t>, class std::allocator<wchar_t>>>>::~_Vector_val<struct std::_Simple_types<class std::basic_string<wchar_t, struct std::char_traits<wchar_t>, class std::allocator<wchar_t>>>>(void)
.text$mn:000073D4                 public ??1?$_Vector_val@U?$_Simple_types@V?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@@std@@@std@@QAE@XZ
.text$mn:000073D4 ??1?$_Vector_val@U?$_Simple_types@V?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@@std@@@std@@QAE@XZ proc near
.text$mn:000073D4                                         ; CODE XREF: __unwindfunclet$??0?$_Vector_alloc@$0A@U?$_Vec_base_types@V?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@V?$allocator@V?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@@2@@std@@@std@@QAE@ABV?$allocator@V?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@@1@@Z$0+3j
.text$mn:000073D4                                         ; std::_Vector_alloc<0,std::_Vec_base_types<std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>>,std::allocator<std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>>>>>::~_Vector_alloc<0,std::_Vec_base_types<std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>>,std::allocator<std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>>>>>(void)+3Fp ...
.text$mn:000073D4
.text$mn:000073D4 var_10          = dword ptr -10h
.text$mn:000073D4 var_C           = dword ptr -0Ch
.text$mn:000073D4 var_4           = dword ptr -4
.text$mn:000073D4
.text$mn:000073D4                 push    ebp
.text$mn:000073D5                 mov     ebp, esp
.text$mn:000073D7                 push    0FFFFFFFFh
.text$mn:000073D9                 push    offset __ehhandler$??1?$_Vector_val@U?$_Simple_types@V?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@@std@@@std@@QAE@XZ
.text$mn:000073DE                 mov     eax, large fs:0
.text$mn:000073E4                 push    eax
.text$mn:000073E5                 push    ecx
.text$mn:000073E6                 mov     eax, dword ptr ds:___security_cookie
.text$mn:000073EB                 xor     eax, ebp
.text$mn:000073ED                 push    eax
.text$mn:000073EE                 lea     eax, [ebp+var_C]
.text$mn:000073F1                 mov     large fs:0, eax
.text$mn:000073F7                 mov     [ebp+var_10], ecx
.text$mn:000073FA                 mov     [ebp+var_4], 0
.text$mn:00007401                 mov     [ebp+var_4], 0FFFFFFFFh
.text$mn:00007408                 mov     ecx, [ebp+var_10] ; this
.text$mn:0000740B                 call    ??1_Container_base12@std@@QAE@XZ ; std::_Container_base12::~_Container_base12(void)
.text$mn:00007410                 mov     ecx, [ebp+var_C]
.text$mn:00007413                 mov     large fs:0, ecx
.text$mn:0000741A                 pop     ecx
.text$mn:0000741B                 mov     esp, ebp
.text$mn:0000741D                 pop     ebp
.text$mn:0000741E                 retn
.text$mn:0000741E ??1?$_Vector_val@U?$_Simple_types@V?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@@std@@@std@@QAE@XZ endp
.text$mn:0000741E
.text$mn:0000741E ; ---------------------------------------------------------------------------
.text$mn:0000741F                 align 10h
.text$mn:0000741F _text$mn        ends
.text$mn:0000741F
.text$x:00007420 ; ===========================================================================
.text$x:00007420
.text$x:00007420 ; Segment type: Pure code
.text$x:00007420 ; Segment permissions: Read/Execute
.text$x:00007420 _text$x         segment para public 'CODE' use32
.text$x:00007420                 assume cs:_text$x
.text$x:00007420                 ;org 7420h
.text$x:00007420 ; COMDAT (pick associative to section at 73D4)
.text$x:00007420                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text$x:00007420
.text$x:00007420 ; =============== S U B R O U T I N E =======================================
.text$x:00007420
.text$x:00007420
.text$x:00007420 __unwindfunclet$??1?$_Vector_val@U?$_Simple_types@V?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@@std@@@std@@QAE@XZ$0 proc near
.text$x:00007420                                         ; DATA XREF: .xdata$x:0000E230o
.text$x:00007420                 mov     ecx, [ebp-10h]  ; this
.text$x:00007423                 jmp     ??1_Container_base12@std@@QAE@XZ ; std::_Container_base12::~_Container_base12(void)
.text$x:00007423 __unwindfunclet$??1?$_Vector_val@U?$_Simple_types@V?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@@std@@@std@@QAE@XZ$0 endp
.text$x:00007423
.text$x:00007428
.text$x:00007428 ; =============== S U B R O U T I N E =======================================
.text$x:00007428
.text$x:00007428
.text$x:00007428 __ehhandler$??1?$_Vector_val@U?$_Simple_types@V?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@@std@@@std@@QAE@XZ proc near
.text$x:00007428                                         ; DATA XREF: std::_Vector_val<std::_Simple_types<std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>>>>::~_Vector_val<std::_Simple_types<std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>>>>(void)+5o
.text$x:00007428
.text$x:00007428 arg_4           = dword ptr  8
.text$x:00007428
.text$x:00007428                 mov     edx, [esp+arg_4]
.text$x:0000742C                 lea     eax, [edx+0Ch]
.text$x:0000742F                 mov     ecx, [edx-8]
.text$x:00007432                 xor     ecx, eax
.text$x:00007434                 call    @__security_check_cookie@4 ; __security_check_cookie(x)
.text$x:00007439                 mov     eax, offset __ehfuncinfo$??1?$_Vector_val@U?$_Simple_types@V?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@@std@@@std@@QAE@XZ
.text$x:0000743E                 jmp     ___CxxFrameHandler3
.text$x:0000743E __ehhandler$??1?$_Vector_val@U?$_Simple_types@V?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@@std@@@std@@QAE@XZ endp
.text$x:0000743E
.text$x:0000743E ; ---------------------------------------------------------------------------
.text$x:00007443                 align 4
.text$x:00007443 _text$x         ends
.text$x:00007443
.text$mn:00007444 ; ===========================================================================
.text$mn:00007444
.text$mn:00007444 ; Segment type: Pure code
.text$mn:00007444 ; Segment permissions: Read/Execute
.text$mn:00007444 _text$mn        segment para public 'CODE' use32
.text$mn:00007444                 assume cs:_text$mn
.text$mn:00007444                 ;org 7444h
.text$mn:00007444 ; COMDAT (pick any)
.text$mn:00007444                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text$mn:00007444
.text$mn:00007444 ; =============== S U B R O U T I N E =======================================
.text$mn:00007444
.text$mn:00007444 ; Attributes: bp-based frame
.text$mn:00007444
.text$mn:00007444 ; public: __thiscall std::_Vector_val<struct std::_Simple_types<wchar_t>>::~_Vector_val<struct std::_Simple_types<wchar_t>>(void)
.text$mn:00007444                 public ??1?$_Vector_val@U?$_Simple_types@_W@std@@@std@@QAE@XZ
.text$mn:00007444 ??1?$_Vector_val@U?$_Simple_types@_W@std@@@std@@QAE@XZ proc near
.text$mn:00007444                                         ; CODE XREF: __unwindfunclet$??0?$_Vector_alloc@$0A@U?$_Vec_base_types@_WV?$allocator@_W@std@@@std@@@std@@QAE@ABV?$allocator@_W@1@@Z$0+3j
.text$mn:00007444                                         ; std::_Vector_alloc<0,std::_Vec_base_types<wchar_t,std::allocator<wchar_t>>>::~_Vector_alloc<0,std::_Vec_base_types<wchar_t,std::allocator<wchar_t>>>(void)+3Fp ...
.text$mn:00007444
.text$mn:00007444 var_10          = dword ptr -10h
.text$mn:00007444 var_C           = dword ptr -0Ch
.text$mn:00007444 var_4           = dword ptr -4
.text$mn:00007444
.text$mn:00007444                 push    ebp
.text$mn:00007445                 mov     ebp, esp
.text$mn:00007447                 push    0FFFFFFFFh
.text$mn:00007449                 push    offset __ehhandler$??1?$_Vector_val@U?$_Simple_types@_W@std@@@std@@QAE@XZ
.text$mn:0000744E                 mov     eax, large fs:0
.text$mn:00007454                 push    eax
.text$mn:00007455                 push    ecx
.text$mn:00007456                 mov     eax, dword ptr ds:___security_cookie
.text$mn:0000745B                 xor     eax, ebp
.text$mn:0000745D                 push    eax
.text$mn:0000745E                 lea     eax, [ebp+var_C]
.text$mn:00007461                 mov     large fs:0, eax
.text$mn:00007467                 mov     [ebp+var_10], ecx
.text$mn:0000746A                 mov     [ebp+var_4], 0
.text$mn:00007471                 mov     [ebp+var_4], 0FFFFFFFFh
.text$mn:00007478                 mov     ecx, [ebp+var_10] ; this
.text$mn:0000747B                 call    ??1_Container_base12@std@@QAE@XZ ; std::_Container_base12::~_Container_base12(void)
.text$mn:00007480                 mov     ecx, [ebp+var_C]
.text$mn:00007483                 mov     large fs:0, ecx
.text$mn:0000748A                 pop     ecx
.text$mn:0000748B                 mov     esp, ebp
.text$mn:0000748D                 pop     ebp
.text$mn:0000748E                 retn
.text$mn:0000748E ??1?$_Vector_val@U?$_Simple_types@_W@std@@@std@@QAE@XZ endp
.text$mn:0000748E
.text$mn:0000748E ; ---------------------------------------------------------------------------
.text$mn:0000748F                 align 10h
.text$mn:0000748F _text$mn        ends
.text$mn:0000748F
.text$x:00007490 ; ===========================================================================
.text$x:00007490
.text$x:00007490 ; Segment type: Pure code
.text$x:00007490 ; Segment permissions: Read/Execute
.text$x:00007490 _text$x         segment para public 'CODE' use32
.text$x:00007490                 assume cs:_text$x
.text$x:00007490                 ;org 7490h
.text$x:00007490 ; COMDAT (pick associative to section at 7444)
.text$x:00007490                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text$x:00007490
.text$x:00007490 ; =============== S U B R O U T I N E =======================================
.text$x:00007490
.text$x:00007490
.text$x:00007490 __unwindfunclet$??1?$_Vector_val@U?$_Simple_types@_W@std@@@std@@QAE@XZ$0 proc near
.text$x:00007490                                         ; DATA XREF: .xdata$x:0000E3E8o
.text$x:00007490                 mov     ecx, [ebp-10h]  ; this
.text$x:00007493                 jmp     ??1_Container_base12@std@@QAE@XZ ; std::_Container_base12::~_Container_base12(void)
.text$x:00007493 __unwindfunclet$??1?$_Vector_val@U?$_Simple_types@_W@std@@@std@@QAE@XZ$0 endp
.text$x:00007493
.text$x:00007498
.text$x:00007498 ; =============== S U B R O U T I N E =======================================
.text$x:00007498
.text$x:00007498
.text$x:00007498 __ehhandler$??1?$_Vector_val@U?$_Simple_types@_W@std@@@std@@QAE@XZ proc near
.text$x:00007498                                         ; DATA XREF: std::_Vector_val<std::_Simple_types<wchar_t>>::~_Vector_val<std::_Simple_types<wchar_t>>(void)+5o
.text$x:00007498
.text$x:00007498 arg_4           = dword ptr  8
.text$x:00007498
.text$x:00007498                 mov     edx, [esp+arg_4]
.text$x:0000749C                 lea     eax, [edx+0Ch]
.text$x:0000749F                 mov     ecx, [edx-8]
.text$x:000074A2                 xor     ecx, eax
.text$x:000074A4                 call    @__security_check_cookie@4 ; __security_check_cookie(x)
.text$x:000074A9                 mov     eax, offset __ehfuncinfo$??1?$_Vector_val@U?$_Simple_types@_W@std@@@std@@QAE@XZ
.text$x:000074AE                 jmp     ___CxxFrameHandler3
.text$x:000074AE __ehhandler$??1?$_Vector_val@U?$_Simple_types@_W@std@@@std@@QAE@XZ endp
.text$x:000074AE
.text$x:000074AE ; ---------------------------------------------------------------------------
.text$x:000074B3                 align 4
.text$x:000074B3 _text$x         ends
.text$x:000074B3
.text$mn:000074B4 ; ===========================================================================
.text$mn:000074B4
.text$mn:000074B4 ; Segment type: Pure code
.text$mn:000074B4 ; Segment permissions: Read/Execute
.text$mn:000074B4 _text$mn        segment para public 'CODE' use32
.text$mn:000074B4                 assume cs:_text$mn
.text$mn:000074B4                 ;org 74B4h
.text$mn:000074B4 ; COMDAT (pick any)
.text$mn:000074B4                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text$mn:000074B4
.text$mn:000074B4 ; =============== S U B R O U T I N E =======================================
.text$mn:000074B4
.text$mn:000074B4 ; Attributes: bp-based frame
.text$mn:000074B4
.text$mn:000074B4 ; public: __thiscall std::basic_string<char, struct std::char_traits<char>, class std::allocator<char>>::~basic_string<char, struct std::char_traits<char>, class std::allocator<char>>(void)
.text$mn:000074B4                 public ??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ
.text$mn:000074B4 ??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ proc near
.text$mn:000074B4                                         ; CODE XREF: getFileContent(wchar_t const *)+16Bp
.text$mn:000074B4                                         ; __unwindfunclet$?wstring2string@@YA?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@ABV?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@2@I@Z$1+13j ...
.text$mn:000074B4
.text$mn:000074B4 var_10          = dword ptr -10h
.text$mn:000074B4 var_C           = dword ptr -0Ch
.text$mn:000074B4 var_4           = dword ptr -4
.text$mn:000074B4
.text$mn:000074B4                 push    ebp
.text$mn:000074B5                 mov     ebp, esp
.text$mn:000074B7                 push    0FFFFFFFFh
.text$mn:000074B9                 push    offset __ehhandler$??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ
.text$mn:000074BE                 mov     eax, large fs:0
.text$mn:000074C4                 push    eax
.text$mn:000074C5                 push    ecx
.text$mn:000074C6                 mov     eax, dword ptr ds:___security_cookie
.text$mn:000074CB                 xor     eax, ebp
.text$mn:000074CD                 push    eax
.text$mn:000074CE                 lea     eax, [ebp+var_C]
.text$mn:000074D1                 mov     large fs:0, eax
.text$mn:000074D7                 mov     [ebp+var_10], ecx
.text$mn:000074DA                 mov     [ebp+var_4], 0
.text$mn:000074E1                 push    0               ; Size
.text$mn:000074E3                 push    1               ; char
.text$mn:000074E5                 mov     ecx, [ebp+var_10]
.text$mn:000074E8                 call    ?_Tidy@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEX_NI@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char>>::_Tidy(bool,uint)
.text$mn:000074ED                 mov     [ebp+var_4], 0FFFFFFFFh
.text$mn:000074F4                 mov     ecx, [ebp+var_10]
.text$mn:000074F7                 call    ??1?$_String_alloc@$0A@U?$_String_base_types@DV?$allocator@D@std@@@std@@@std@@QAE@XZ ; std::_String_alloc<0,std::_String_base_types<char,std::allocator<char>>>::~_String_alloc<0,std::_String_base_types<char,std::allocator<char>>>(void)
.text$mn:000074FC                 mov     ecx, [ebp+var_C]
.text$mn:000074FF                 mov     large fs:0, ecx
.text$mn:00007506                 pop     ecx
.text$mn:00007507                 mov     esp, ebp
.text$mn:00007509                 pop     ebp
.text$mn:0000750A                 retn
.text$mn:0000750A ??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ endp
.text$mn:0000750A
.text$mn:0000750A ; ---------------------------------------------------------------------------
.text$mn:0000750B                 align 4
.text$mn:0000750B _text$mn        ends
.text$mn:0000750B
.text$x:0000750C ; ===========================================================================
.text$x:0000750C
.text$x:0000750C ; Segment type: Pure code
.text$x:0000750C ; Segment permissions: Read/Execute
.text$x:0000750C _text$x         segment para public 'CODE' use32
.text$x:0000750C                 assume cs:_text$x
.text$x:0000750C                 ;org 750Ch
.text$x:0000750C ; COMDAT (pick associative to section at 74B4)
.text$x:0000750C                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text$x:0000750C
.text$x:0000750C ; =============== S U B R O U T I N E =======================================
.text$x:0000750C
.text$x:0000750C
.text$x:0000750C __unwindfunclet$??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ$0 proc near
.text$x:0000750C                                         ; DATA XREF: .xdata$x:0000D64Co
.text$x:0000750C                 mov     ecx, [ebp-10h]
.text$x:0000750F                 jmp     ??1?$_String_alloc@$0A@U?$_String_base_types@DV?$allocator@D@std@@@std@@@std@@QAE@XZ ; std::_String_alloc<0,std::_String_base_types<char,std::allocator<char>>>::~_String_alloc<0,std::_String_base_types<char,std::allocator<char>>>(void)
.text$x:0000750F __unwindfunclet$??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ$0 endp
.text$x:0000750F
.text$x:00007514
.text$x:00007514 ; =============== S U B R O U T I N E =======================================
.text$x:00007514
.text$x:00007514
.text$x:00007514 __ehhandler$??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ proc near
.text$x:00007514                                         ; DATA XREF: std::basic_string<char,std::char_traits<char>,std::allocator<char>>::~basic_string<char,std::char_traits<char>,std::allocator<char>>(void)+5o
.text$x:00007514
.text$x:00007514 arg_4           = dword ptr  8
.text$x:00007514
.text$x:00007514                 mov     edx, [esp+arg_4]
.text$x:00007518                 lea     eax, [edx+0Ch]
.text$x:0000751B                 mov     ecx, [edx-8]
.text$x:0000751E                 xor     ecx, eax
.text$x:00007520                 call    @__security_check_cookie@4 ; __security_check_cookie(x)
.text$x:00007525                 mov     eax, offset __ehfuncinfo$??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ
.text$x:0000752A                 jmp     ___CxxFrameHandler3
.text$x:0000752A __ehhandler$??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ endp
.text$x:0000752A
.text$x:0000752A ; ---------------------------------------------------------------------------
.text$x:0000752F                 align 10h
.text$x:0000752F _text$x         ends
.text$x:0000752F
.text$mn:00007530 ; ===========================================================================
.text$mn:00007530
.text$mn:00007530 ; Segment type: Pure code
.text$mn:00007530 ; Segment permissions: Read/Execute
.text$mn:00007530 _text$mn        segment para public 'CODE' use32
.text$mn:00007530                 assume cs:_text$mn
.text$mn:00007530                 ;org 7530h
.text$mn:00007530 ; COMDAT (pick any)
.text$mn:00007530                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text$mn:00007530
.text$mn:00007530 ; =============== S U B R O U T I N E =======================================
.text$mn:00007530
.text$mn:00007530 ; Attributes: bp-based frame
.text$mn:00007530
.text$mn:00007530 ; public: __thiscall std::basic_string<wchar_t, struct std::char_traits<wchar_t>, class std::allocator<wchar_t>>::~basic_string<wchar_t, struct std::char_traits<wchar_t>, class std::allocator<wchar_t>>(void)
.text$mn:00007530                 public ??1?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QAE@XZ
.text$mn:00007530 ??1?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QAE@XZ proc near
.text$mn:00007530                                         ; CODE XREF: getFolderName(HWND__ *,wchar_t const *)+161p
.text$mn:00007530                                         ; tokenizeString(std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>> const &,char)+B9p ...
.text$mn:00007530
.text$mn:00007530 var_10          = dword ptr -10h
.text$mn:00007530 var_C           = dword ptr -0Ch
.text$mn:00007530 var_4           = dword ptr -4
.text$mn:00007530
.text$mn:00007530                 push    ebp
.text$mn:00007531                 mov     ebp, esp
.text$mn:00007533                 push    0FFFFFFFFh
.text$mn:00007535                 push    offset __ehhandler$??1?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QAE@XZ
.text$mn:0000753A                 mov     eax, large fs:0
.text$mn:00007540                 push    eax
.text$mn:00007541                 push    ecx
.text$mn:00007542                 mov     eax, dword ptr ds:___security_cookie
.text$mn:00007547                 xor     eax, ebp
.text$mn:00007549                 push    eax
.text$mn:0000754A                 lea     eax, [ebp+var_C]
.text$mn:0000754D                 mov     large fs:0, eax
.text$mn:00007553                 mov     [ebp+var_10], ecx
.text$mn:00007556                 mov     [ebp+var_4], 0
.text$mn:0000755D                 push    0
.text$mn:0000755F                 push    1
.text$mn:00007561                 mov     ecx, [ebp+var_10]
.text$mn:00007564                 call    ?_Tidy@?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QAEX_NI@Z ; std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>>::_Tidy(bool,uint)
.text$mn:00007569                 mov     [ebp+var_4], 0FFFFFFFFh
.text$mn:00007570                 mov     ecx, [ebp+var_10]
.text$mn:00007573                 call    ??1?$_String_alloc@$0A@U?$_String_base_types@_WV?$allocator@_W@std@@@std@@@std@@QAE@XZ ; std::_String_alloc<0,std::_String_base_types<wchar_t,std::allocator<wchar_t>>>::~_String_alloc<0,std::_String_base_types<wchar_t,std::allocator<wchar_t>>>(void)
.text$mn:00007578                 mov     ecx, [ebp+var_C]
.text$mn:0000757B                 mov     large fs:0, ecx
.text$mn:00007582                 pop     ecx
.text$mn:00007583                 mov     esp, ebp
.text$mn:00007585                 pop     ebp
.text$mn:00007586                 retn
.text$mn:00007586 ??1?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QAE@XZ endp
.text$mn:00007586
.text$mn:00007586 ; ---------------------------------------------------------------------------
.text$mn:00007587                 align 4
.text$mn:00007587 _text$mn        ends
.text$mn:00007587
.text$x:00007588 ; ===========================================================================
.text$x:00007588
.text$x:00007588 ; Segment type: Pure code
.text$x:00007588 ; Segment permissions: Read/Execute
.text$x:00007588 _text$x         segment para public 'CODE' use32
.text$x:00007588                 assume cs:_text$x
.text$x:00007588                 ;org 7588h
.text$x:00007588 ; COMDAT (pick associative to section at 7530)
.text$x:00007588                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text$x:00007588
.text$x:00007588 ; =============== S U B R O U T I N E =======================================
.text$x:00007588
.text$x:00007588
.text$x:00007588 __unwindfunclet$??1?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QAE@XZ$0 proc near
.text$x:00007588                                         ; DATA XREF: .xdata$x:0000DACCo
.text$x:00007588                 mov     ecx, [ebp-10h]
.text$x:0000758B                 jmp     ??1?$_String_alloc@$0A@U?$_String_base_types@_WV?$allocator@_W@std@@@std@@@std@@QAE@XZ ; std::_String_alloc<0,std::_String_base_types<wchar_t,std::allocator<wchar_t>>>::~_String_alloc<0,std::_String_base_types<wchar_t,std::allocator<wchar_t>>>(void)
.text$x:0000758B __unwindfunclet$??1?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QAE@XZ$0 endp
.text$x:0000758B
.text$x:00007590
.text$x:00007590 ; =============== S U B R O U T I N E =======================================
.text$x:00007590
.text$x:00007590
.text$x:00007590 __ehhandler$??1?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QAE@XZ proc near
.text$x:00007590                                         ; DATA XREF: std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>>::~basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>>(void)+5o
.text$x:00007590
.text$x:00007590 arg_4           = dword ptr  8
.text$x:00007590
.text$x:00007590                 mov     edx, [esp+arg_4]
.text$x:00007594                 lea     eax, [edx+0Ch]
.text$x:00007597                 mov     ecx, [edx-8]
.text$x:0000759A                 xor     ecx, eax
.text$x:0000759C                 call    @__security_check_cookie@4 ; __security_check_cookie(x)
.text$x:000075A1                 mov     eax, offset __ehfuncinfo$??1?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QAE@XZ
.text$x:000075A6                 jmp     ___CxxFrameHandler3
.text$x:000075A6 __ehhandler$??1?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QAE@XZ endp
.text$x:000075A6
.text$x:000075A6 ; ---------------------------------------------------------------------------
.text$x:000075AB                 align 4
.text$x:000075AB _text$x         ends
.text$x:000075AB
.text$mn:000075AC ; ===========================================================================
.text$mn:000075AC
.text$mn:000075AC ; Segment type: Pure code
.text$mn:000075AC ; Segment permissions: Read/Execute
.text$mn:000075AC _text$mn        segment para public 'CODE' use32
.text$mn:000075AC                 assume cs:_text$mn
.text$mn:000075AC                 ;org 75ACh
.text$mn:000075AC ; COMDAT (pick any)
.text$mn:000075AC                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text$mn:000075AC
.text$mn:000075AC ; =============== S U B R O U T I N E =======================================
.text$mn:000075AC
.text$mn:000075AC ; Attributes: bp-based frame
.text$mn:000075AC
.text$mn:000075AC ; public: __thiscall std::reverse_iterator<class std::_Vector_iterator<class std::_Vector_val<struct std::_Simple_types<wchar_t>>>>::~reverse_iterator<class std::_Vector_iterator<class std::_Vector_val<struct std::_Simple_types<wchar_t>>>>(void)
.text$mn:000075AC                 public ??1?$reverse_iterator@V?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@_W@std@@@std@@@std@@@std@@QAE@XZ
.text$mn:000075AC ??1?$reverse_iterator@V?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@_W@std@@@std@@@std@@@std@@QAE@XZ proc near
.text$mn:000075AC                                         ; CODE XREF: __unwindfunclet$?intToString@@YA?AV?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@H@Z$1+3j
.text$mn:000075AC                                         ; __unwindfunclet$?intToString@@YA?AV?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@H@Z$2+3j ...
.text$mn:000075AC
.text$mn:000075AC var_10          = dword ptr -10h
.text$mn:000075AC var_C           = dword ptr -0Ch
.text$mn:000075AC var_4           = dword ptr -4
.text$mn:000075AC
.text$mn:000075AC                 push    ebp
.text$mn:000075AD                 mov     ebp, esp
.text$mn:000075AF                 push    0FFFFFFFFh
.text$mn:000075B1                 push    offset __ehhandler$??1?$reverse_iterator@V?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@_W@std@@@std@@@std@@@std@@QAE@XZ
.text$mn:000075B6                 mov     eax, large fs:0
.text$mn:000075BC                 push    eax
.text$mn:000075BD                 push    ecx
.text$mn:000075BE                 mov     eax, dword ptr ds:___security_cookie
.text$mn:000075C3                 xor     eax, ebp
.text$mn:000075C5                 push    eax
.text$mn:000075C6                 lea     eax, [ebp+var_C]
.text$mn:000075C9                 mov     large fs:0, eax
.text$mn:000075CF                 mov     [ebp+var_10], ecx
.text$mn:000075D2                 mov     [ebp+var_4], 0
.text$mn:000075D9                 mov     [ebp+var_4], 0FFFFFFFFh
.text$mn:000075E0                 mov     ecx, [ebp+var_10]
.text$mn:000075E3                 call    ??1?$_Revranit@V?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@_W@std@@@std@@@std@@U?$iterator@Urandom_access_iterator_tag@std@@_WHPA_WAA_W@2@@std@@QAE@XZ ; std::_Revranit<std::_Vector_iterator<std::_Vector_val<std::_Simple_types<wchar_t>>>,std::iterator<std::random_access_iterator_tag,wchar_t,int,wchar_t *,wchar_t &>>::~_Revranit<std::_Vector_iterator<std::_Vector_val<std::_Simple_types<wchar_t>>>,std::iterator<std::random_access_iterator_tag,wchar_t,int,wchar_t *,wchar_t &>>(void)
.text$mn:000075E8                 mov     ecx, [ebp+var_C]
.text$mn:000075EB                 mov     large fs:0, ecx
.text$mn:000075F2                 pop     ecx
.text$mn:000075F3                 mov     esp, ebp
.text$mn:000075F5                 pop     ebp
.text$mn:000075F6                 retn
.text$mn:000075F6 ??1?$reverse_iterator@V?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@_W@std@@@std@@@std@@@std@@QAE@XZ endp
.text$mn:000075F6
.text$mn:000075F6 ; ---------------------------------------------------------------------------
.text$mn:000075F7                 align 4
.text$mn:000075F7 _text$mn        ends
.text$mn:000075F7
.text$x:000075F8 ; ===========================================================================
.text$x:000075F8
.text$x:000075F8 ; Segment type: Pure code
.text$x:000075F8 ; Segment permissions: Read/Execute
.text$x:000075F8 _text$x         segment para public 'CODE' use32
.text$x:000075F8                 assume cs:_text$x
.text$x:000075F8                 ;org 75F8h
.text$x:000075F8 ; COMDAT (pick associative to section at 75AC)
.text$x:000075F8                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text$x:000075F8
.text$x:000075F8 ; =============== S U B R O U T I N E =======================================
.text$x:000075F8
.text$x:000075F8
.text$x:000075F8 __unwindfunclet$??1?$reverse_iterator@V?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@_W@std@@@std@@@std@@@std@@QAE@XZ$0 proc near
.text$x:000075F8                                         ; DATA XREF: .xdata$x:0000EA94o
.text$x:000075F8                 mov     ecx, [ebp-10h]
.text$x:000075FB                 jmp     ??1?$_Revranit@V?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@_W@std@@@std@@@std@@U?$iterator@Urandom_access_iterator_tag@std@@_WHPA_WAA_W@2@@std@@QAE@XZ ; std::_Revranit<std::_Vector_iterator<std::_Vector_val<std::_Simple_types<wchar_t>>>,std::iterator<std::random_access_iterator_tag,wchar_t,int,wchar_t *,wchar_t &>>::~_Revranit<std::_Vector_iterator<std::_Vector_val<std::_Simple_types<wchar_t>>>,std::iterator<std::random_access_iterator_tag,wchar_t,int,wchar_t *,wchar_t &>>(void)
.text$x:000075FB __unwindfunclet$??1?$reverse_iterator@V?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@_W@std@@@std@@@std@@@std@@QAE@XZ$0 endp
.text$x:000075FB
.text$x:00007600
.text$x:00007600 ; =============== S U B R O U T I N E =======================================
.text$x:00007600
.text$x:00007600
.text$x:00007600 __ehhandler$??1?$reverse_iterator@V?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@_W@std@@@std@@@std@@@std@@QAE@XZ proc near
.text$x:00007600                                         ; DATA XREF: std::reverse_iterator<std::_Vector_iterator<std::_Vector_val<std::_Simple_types<wchar_t>>>>::~reverse_iterator<std::_Vector_iterator<std::_Vector_val<std::_Simple_types<wchar_t>>>>(void)+5o
.text$x:00007600
.text$x:00007600 arg_4           = dword ptr  8
.text$x:00007600
.text$x:00007600                 mov     edx, [esp+arg_4]
.text$x:00007604                 lea     eax, [edx+0Ch]
.text$x:00007607                 mov     ecx, [edx-8]
.text$x:0000760A                 xor     ecx, eax
.text$x:0000760C                 call    @__security_check_cookie@4 ; __security_check_cookie(x)
.text$x:00007611                 mov     eax, offset __ehfuncinfo$??1?$reverse_iterator@V?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@_W@std@@@std@@@std@@@std@@QAE@XZ
.text$x:00007616                 jmp     ___CxxFrameHandler3
.text$x:00007616 __ehhandler$??1?$reverse_iterator@V?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@_W@std@@@std@@@std@@@std@@QAE@XZ endp
.text$x:00007616
.text$x:00007616 ; ---------------------------------------------------------------------------
.text$x:0000761B                 align 4
.text$x:0000761B _text$x         ends
.text$x:0000761B
.text$mn:0000761C ; ===========================================================================
.text$mn:0000761C
.text$mn:0000761C ; Segment type: Pure code
.text$mn:0000761C ; Segment permissions: Read/Execute
.text$mn:0000761C _text$mn        segment para public 'CODE' use32
.text$mn:0000761C                 assume cs:_text$mn
.text$mn:0000761C                 ;org 761Ch
.text$mn:0000761C ; COMDAT (pick any)
.text$mn:0000761C                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text$mn:0000761C
.text$mn:0000761C ; =============== S U B R O U T I N E =======================================
.text$mn:0000761C
.text$mn:0000761C ; Attributes: bp-based frame
.text$mn:0000761C
.text$mn:0000761C ; public: __thiscall std::vector<char, class std::allocator<char>>::~vector<char, class std::allocator<char>>(void)
.text$mn:0000761C                 public ??1?$vector@DV?$allocator@D@std@@@std@@QAE@XZ
.text$mn:0000761C ??1?$vector@DV?$allocator@D@std@@@std@@QAE@XZ proc near
.text$mn:0000761C                                         ; CODE XREF: wstring2string(std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>> const &,uint)+B4p
.text$mn:0000761C                                         ; __unwindfunclet$?wstring2string@@YA?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@ABV?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@2@I@Z$0+3j
.text$mn:0000761C
.text$mn:0000761C var_10          = dword ptr -10h
.text$mn:0000761C var_C           = dword ptr -0Ch
.text$mn:0000761C var_4           = dword ptr -4
.text$mn:0000761C
.text$mn:0000761C                 push    ebp
.text$mn:0000761D                 mov     ebp, esp
.text$mn:0000761F                 push    0FFFFFFFFh
.text$mn:00007621                 push    offset __ehhandler$??1?$vector@DV?$allocator@D@std@@@std@@QAE@XZ
.text$mn:00007626                 mov     eax, large fs:0
.text$mn:0000762C                 push    eax
.text$mn:0000762D                 push    ecx
.text$mn:0000762E                 mov     eax, dword ptr ds:___security_cookie
.text$mn:00007633                 xor     eax, ebp
.text$mn:00007635                 push    eax
.text$mn:00007636                 lea     eax, [ebp+var_C]
.text$mn:00007639                 mov     large fs:0, eax
.text$mn:0000763F                 mov     [ebp+var_10], ecx
.text$mn:00007642                 mov     [ebp+var_4], 0
.text$mn:00007649                 mov     ecx, [ebp+var_10]
.text$mn:0000764C                 call    ?_Tidy@?$vector@DV?$allocator@D@std@@@std@@IAEXXZ ; std::vector<char,std::allocator<char>>::_Tidy(void)
.text$mn:00007651                 mov     [ebp+var_4], 0FFFFFFFFh
.text$mn:00007658                 mov     ecx, [ebp+var_10]
.text$mn:0000765B                 call    ??1?$_Vector_alloc@$0A@U?$_Vec_base_types@DV?$allocator@D@std@@@std@@@std@@QAE@XZ ; std::_Vector_alloc<0,std::_Vec_base_types<char,std::allocator<char>>>::~_Vector_alloc<0,std::_Vec_base_types<char,std::allocator<char>>>(void)
.text$mn:00007660                 mov     ecx, [ebp+var_C]
.text$mn:00007663                 mov     large fs:0, ecx
.text$mn:0000766A                 pop     ecx
.text$mn:0000766B                 mov     esp, ebp
.text$mn:0000766D                 pop     ebp
.text$mn:0000766E                 retn
.text$mn:0000766E ??1?$vector@DV?$allocator@D@std@@@std@@QAE@XZ endp
.text$mn:0000766E
.text$mn:0000766E ; ---------------------------------------------------------------------------
.text$mn:0000766F                 align 10h
.text$mn:0000766F _text$mn        ends
.text$mn:0000766F
.text$x:00007670 ; ===========================================================================
.text$x:00007670
.text$x:00007670 ; Segment type: Pure code
.text$x:00007670 ; Segment permissions: Read/Execute
.text$x:00007670 _text$x         segment para public 'CODE' use32
.text$x:00007670                 assume cs:_text$x
.text$x:00007670                 ;org 7670h
.text$x:00007670 ; COMDAT (pick associative to section at 761C)
.text$x:00007670                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text$x:00007670
.text$x:00007670 ; =============== S U B R O U T I N E =======================================
.text$x:00007670
.text$x:00007670
.text$x:00007670 __unwindfunclet$??1?$vector@DV?$allocator@D@std@@@std@@QAE@XZ$0 proc near
.text$x:00007670                                         ; DATA XREF: .xdata$x:0000E788o
.text$x:00007670                 mov     ecx, [ebp-10h]
.text$x:00007673                 jmp     ??1?$_Vector_alloc@$0A@U?$_Vec_base_types@DV?$allocator@D@std@@@std@@@std@@QAE@XZ ; std::_Vector_alloc<0,std::_Vec_base_types<char,std::allocator<char>>>::~_Vector_alloc<0,std::_Vec_base_types<char,std::allocator<char>>>(void)
.text$x:00007673 __unwindfunclet$??1?$vector@DV?$allocator@D@std@@@std@@QAE@XZ$0 endp
.text$x:00007673
.text$x:00007678
.text$x:00007678 ; =============== S U B R O U T I N E =======================================
.text$x:00007678
.text$x:00007678
.text$x:00007678 __ehhandler$??1?$vector@DV?$allocator@D@std@@@std@@QAE@XZ proc near
.text$x:00007678                                         ; DATA XREF: std::vector<char,std::allocator<char>>::~vector<char,std::allocator<char>>(void)+5o
.text$x:00007678
.text$x:00007678 arg_4           = dword ptr  8
.text$x:00007678
.text$x:00007678                 mov     edx, [esp+arg_4]
.text$x:0000767C                 lea     eax, [edx+0Ch]
.text$x:0000767F                 mov     ecx, [edx-8]
.text$x:00007682                 xor     ecx, eax
.text$x:00007684                 call    @__security_check_cookie@4 ; __security_check_cookie(x)
.text$x:00007689                 mov     eax, offset __ehfuncinfo$??1?$vector@DV?$allocator@D@std@@@std@@QAE@XZ
.text$x:0000768E                 jmp     ___CxxFrameHandler3
.text$x:0000768E __ehhandler$??1?$vector@DV?$allocator@D@std@@@std@@QAE@XZ endp
.text$x:0000768E
.text$x:0000768E ; ---------------------------------------------------------------------------
.text$x:00007693                 align 4
.text$x:00007693 _text$x         ends
.text$x:00007693
.text$mn:00007694 ; ===========================================================================
.text$mn:00007694
.text$mn:00007694 ; Segment type: Pure code
.text$mn:00007694 ; Segment permissions: Read/Execute
.text$mn:00007694 _text$mn        segment para public 'CODE' use32
.text$mn:00007694                 assume cs:_text$mn
.text$mn:00007694                 ;org 7694h
.text$mn:00007694 ; COMDAT (pick any)
.text$mn:00007694                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text$mn:00007694
.text$mn:00007694 ; =============== S U B R O U T I N E =======================================
.text$mn:00007694
.text$mn:00007694 ; Attributes: bp-based frame
.text$mn:00007694
.text$mn:00007694 ; public: __thiscall std::vector<class std::basic_string<wchar_t, struct std::char_traits<wchar_t>, class std::allocator<wchar_t>>, class std::allocator<class std::basic_string<wchar_t, struct std::char_traits<wchar_t>, class std::allocator<wchar_t>>>>::~vector<class std::basic_string<wchar_t, struct std::char_traits<wchar_t>, class std::allocator<wchar_t>>, class std::allocator<class std::basic_string<wchar_t, struct std::char_traits<wchar_t>, class std::allocator<wchar_t>>>>(void)
.text$mn:00007694                 public ??1?$vector@V?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@V?$allocator@V?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@@2@@std@@QAE@XZ
.text$mn:00007694 ??1?$vector@V?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@V?$allocator@V?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@@2@@std@@QAE@XZ proc near
.text$mn:00007694                                         ; CODE XREF: tokenizeString(std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>> const &,char)+10Fp
.text$mn:00007694                                         ; stringSplit(std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>> const &,std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>> const &)+11Bp ...
.text$mn:00007694
.text$mn:00007694 var_10          = dword ptr -10h
.text$mn:00007694 var_C           = dword ptr -0Ch
.text$mn:00007694 var_4           = dword ptr -4
.text$mn:00007694
.text$mn:00007694                 push    ebp
.text$mn:00007695                 mov     ebp, esp
.text$mn:00007697                 push    0FFFFFFFFh
.text$mn:00007699                 push    offset __ehhandler$??1?$vector@V?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@V?$allocator@V?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@@2@@std@@QAE@XZ
.text$mn:0000769E                 mov     eax, large fs:0
.text$mn:000076A4                 push    eax
.text$mn:000076A5                 push    ecx
.text$mn:000076A6                 mov     eax, dword ptr ds:___security_cookie
.text$mn:000076AB                 xor     eax, ebp
.text$mn:000076AD                 push    eax
.text$mn:000076AE                 lea     eax, [ebp+var_C]
.text$mn:000076B1                 mov     large fs:0, eax
.text$mn:000076B7                 mov     [ebp+var_10], ecx
.text$mn:000076BA                 mov     [ebp+var_4], 0
.text$mn:000076C1                 mov     ecx, [ebp+var_10]
.text$mn:000076C4                 call    ?_Tidy@?$vector@V?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@V?$allocator@V?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@@2@@std@@IAEXXZ ; std::vector<std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>>,std::allocator<std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>>>>::_Tidy(void)
.text$mn:000076C9                 mov     [ebp+var_4], 0FFFFFFFFh
.text$mn:000076D0                 mov     ecx, [ebp+var_10]
.text$mn:000076D3                 call    ??1?$_Vector_alloc@$0A@U?$_Vec_base_types@V?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@V?$allocator@V?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@@2@@std@@@std@@QAE@XZ ; std::_Vector_alloc<0,std::_Vec_base_types<std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>>,std::allocator<std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>>>>>::~_Vector_alloc<0,std::_Vec_base_types<std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>>,std::allocator<std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>>>>>(void)
.text$mn:000076D8                 mov     ecx, [ebp+var_C]
.text$mn:000076DB                 mov     large fs:0, ecx
.text$mn:000076E2                 pop     ecx
.text$mn:000076E3                 mov     esp, ebp
.text$mn:000076E5                 pop     ebp
.text$mn:000076E6                 retn
.text$mn:000076E6 ??1?$vector@V?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@V?$allocator@V?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@@2@@std@@QAE@XZ endp
.text$mn:000076E6
.text$mn:000076E6 ; ---------------------------------------------------------------------------
.text$mn:000076E7                 align 4
.text$mn:000076E7 _text$mn        ends
.text$mn:000076E7
.text$x:000076E8 ; ===========================================================================
.text$x:000076E8
.text$x:000076E8 ; Segment type: Pure code
.text$x:000076E8 ; Segment permissions: Read/Execute
.text$x:000076E8 _text$x         segment para public 'CODE' use32
.text$x:000076E8                 assume cs:_text$x
.text$x:000076E8                 ;org 76E8h
.text$x:000076E8 ; COMDAT (pick associative to section at 7694)
.text$x:000076E8                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text$x:000076E8
.text$x:000076E8 ; =============== S U B R O U T I N E =======================================
.text$x:000076E8
.text$x:000076E8
.text$x:000076E8 __unwindfunclet$??1?$vector@V?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@V?$allocator@V?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@@2@@std@@QAE@XZ$0 proc near
.text$x:000076E8                                         ; DATA XREF: .xdata$x:0000E30Co
.text$x:000076E8                 mov     ecx, [ebp-10h]
.text$x:000076EB                 jmp     ??1?$_Vector_alloc@$0A@U?$_Vec_base_types@V?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@V?$allocator@V?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@@2@@std@@@std@@QAE@XZ ; std::_Vector_alloc<0,std::_Vec_base_types<std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>>,std::allocator<std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>>>>>::~_Vector_alloc<0,std::_Vec_base_types<std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>>,std::allocator<std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>>>>>(void)
.text$x:000076EB __unwindfunclet$??1?$vector@V?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@V?$allocator@V?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@@2@@std@@QAE@XZ$0 endp
.text$x:000076EB
.text$x:000076F0
.text$x:000076F0 ; =============== S U B R O U T I N E =======================================
.text$x:000076F0
.text$x:000076F0
.text$x:000076F0 __ehhandler$??1?$vector@V?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@V?$allocator@V?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@@2@@std@@QAE@XZ proc near
.text$x:000076F0                                         ; DATA XREF: std::vector<std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>>,std::allocator<std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>>>>::~vector<std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>>,std::allocator<std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>>>>(void)+5o
.text$x:000076F0
.text$x:000076F0 arg_4           = dword ptr  8
.text$x:000076F0
.text$x:000076F0                 mov     edx, [esp+arg_4]
.text$x:000076F4                 lea     eax, [edx+0Ch]
.text$x:000076F7                 mov     ecx, [edx-8]
.text$x:000076FA                 xor     ecx, eax
.text$x:000076FC                 call    @__security_check_cookie@4 ; __security_check_cookie(x)
.text$x:00007701                 mov     eax, offset __ehfuncinfo$??1?$vector@V?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@V?$allocator@V?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@@2@@std@@QAE@XZ
.text$x:00007706                 jmp     ___CxxFrameHandler3
.text$x:00007706 __ehhandler$??1?$vector@V?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@V?$allocator@V?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@@2@@std@@QAE@XZ endp
.text$x:00007706
.text$x:00007706 ; ---------------------------------------------------------------------------
.text$x:0000770B                 align 4
.text$x:0000770B _text$x         ends
.text$x:0000770B
.text$mn:0000770C ; ===========================================================================
.text$mn:0000770C
.text$mn:0000770C ; Segment type: Pure code
.text$mn:0000770C ; Segment permissions: Read/Execute
.text$mn:0000770C _text$mn        segment para public 'CODE' use32
.text$mn:0000770C                 assume cs:_text$mn
.text$mn:0000770C                 ;org 770Ch
.text$mn:0000770C ; COMDAT (pick any)
.text$mn:0000770C                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text$mn:0000770C
.text$mn:0000770C ; =============== S U B R O U T I N E =======================================
.text$mn:0000770C
.text$mn:0000770C ; Attributes: bp-based frame
.text$mn:0000770C
.text$mn:0000770C ; public: __thiscall std::vector<wchar_t, class std::allocator<wchar_t>>::~vector<wchar_t, class std::allocator<wchar_t>>(void)
.text$mn:0000770C                 public ??1?$vector@_WV?$allocator@_W@std@@@std@@QAE@XZ
.text$mn:0000770C ??1?$vector@_WV?$allocator@_W@std@@@std@@QAE@XZ proc near
.text$mn:0000770C                                         ; CODE XREF: string2wstring(std::basic_string<char,std::char_traits<char>,std::allocator<char>> const &,uint)+ACp
.text$mn:0000770C                                         ; BuildMenuFileName(int,uint,std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>> const &)+210p ...
.text$mn:0000770C
.text$mn:0000770C var_10          = dword ptr -10h
.text$mn:0000770C var_C           = dword ptr -0Ch
.text$mn:0000770C var_4           = dword ptr -4
.text$mn:0000770C
.text$mn:0000770C                 push    ebp
.text$mn:0000770D                 mov     ebp, esp
.text$mn:0000770F                 push    0FFFFFFFFh
.text$mn:00007711                 push    offset __ehhandler$??1?$vector@_WV?$allocator@_W@std@@@std@@QAE@XZ
.text$mn:00007716                 mov     eax, large fs:0
.text$mn:0000771C                 push    eax
.text$mn:0000771D                 push    ecx
.text$mn:0000771E                 mov     eax, dword ptr ds:___security_cookie
.text$mn:00007723                 xor     eax, ebp
.text$mn:00007725                 push    eax
.text$mn:00007726                 lea     eax, [ebp+var_C]
.text$mn:00007729                 mov     large fs:0, eax
.text$mn:0000772F                 mov     [ebp+var_10], ecx
.text$mn:00007732                 mov     [ebp+var_4], 0
.text$mn:00007739                 mov     ecx, [ebp+var_10]
.text$mn:0000773C                 call    ?_Tidy@?$vector@_WV?$allocator@_W@std@@@std@@IAEXXZ ; std::vector<wchar_t,std::allocator<wchar_t>>::_Tidy(void)
.text$mn:00007741                 mov     [ebp+var_4], 0FFFFFFFFh
.text$mn:00007748                 mov     ecx, [ebp+var_10]
.text$mn:0000774B                 call    ??1?$_Vector_alloc@$0A@U?$_Vec_base_types@_WV?$allocator@_W@std@@@std@@@std@@QAE@XZ ; std::_Vector_alloc<0,std::_Vec_base_types<wchar_t,std::allocator<wchar_t>>>::~_Vector_alloc<0,std::_Vec_base_types<wchar_t,std::allocator<wchar_t>>>(void)
.text$mn:00007750                 mov     ecx, [ebp+var_C]
.text$mn:00007753                 mov     large fs:0, ecx
.text$mn:0000775A                 pop     ecx
.text$mn:0000775B                 mov     esp, ebp
.text$mn:0000775D                 pop     ebp
.text$mn:0000775E                 retn
.text$mn:0000775E ??1?$vector@_WV?$allocator@_W@std@@@std@@QAE@XZ endp
.text$mn:0000775E
.text$mn:0000775E ; ---------------------------------------------------------------------------
.text$mn:0000775F                 align 10h
.text$mn:0000775F _text$mn        ends
.text$mn:0000775F
.text$x:00007760 ; ===========================================================================
.text$x:00007760
.text$x:00007760 ; Segment type: Pure code
.text$x:00007760 ; Segment permissions: Read/Execute
.text$x:00007760 _text$x         segment para public 'CODE' use32
.text$x:00007760                 assume cs:_text$x
.text$x:00007760                 ;org 7760h
.text$x:00007760 ; COMDAT (pick associative to section at 770C)
.text$x:00007760                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text$x:00007760
.text$x:00007760 ; =============== S U B R O U T I N E =======================================
.text$x:00007760
.text$x:00007760
.text$x:00007760 __unwindfunclet$??1?$vector@_WV?$allocator@_W@std@@@std@@QAE@XZ$0 proc near
.text$x:00007760                                         ; DATA XREF: .xdata$x:0000E4F8o
.text$x:00007760                 mov     ecx, [ebp-10h]
.text$x:00007763                 jmp     ??1?$_Vector_alloc@$0A@U?$_Vec_base_types@_WV?$allocator@_W@std@@@std@@@std@@QAE@XZ ; std::_Vector_alloc<0,std::_Vec_base_types<wchar_t,std::allocator<wchar_t>>>::~_Vector_alloc<0,std::_Vec_base_types<wchar_t,std::allocator<wchar_t>>>(void)
.text$x:00007763 __unwindfunclet$??1?$vector@_WV?$allocator@_W@std@@@std@@QAE@XZ$0 endp
.text$x:00007763
.text$x:00007768
.text$x:00007768 ; =============== S U B R O U T I N E =======================================
.text$x:00007768
.text$x:00007768
.text$x:00007768 __ehhandler$??1?$vector@_WV?$allocator@_W@std@@@std@@QAE@XZ proc near
.text$x:00007768                                         ; DATA XREF: std::vector<wchar_t,std::allocator<wchar_t>>::~vector<wchar_t,std::allocator<wchar_t>>(void)+5o
.text$x:00007768
.text$x:00007768 arg_4           = dword ptr  8
.text$x:00007768
.text$x:00007768                 mov     edx, [esp+arg_4]
.text$x:0000776C                 lea     eax, [edx+0Ch]
.text$x:0000776F                 mov     ecx, [edx-8]
.text$x:00007772                 xor     ecx, eax
.text$x:00007774                 call    @__security_check_cookie@4 ; __security_check_cookie(x)
.text$x:00007779                 mov     eax, offset __ehfuncinfo$??1?$vector@_WV?$allocator@_W@std@@@std@@QAE@XZ
.text$x:0000777E                 jmp     ___CxxFrameHandler3
.text$x:0000777E __ehhandler$??1?$vector@_WV?$allocator@_W@std@@@std@@QAE@XZ endp
.text$x:0000777E
.text$x:0000777E ; ---------------------------------------------------------------------------
.text$x:00007783                 align 4
.text$x:00007783 _text$x         ends
.text$x:00007783
.text$mn:00007784 ; ===========================================================================
.text$mn:00007784
.text$mn:00007784 ; Segment type: Pure code
.text$mn:00007784 ; Segment permissions: Read/Execute
.text$mn:00007784 _text$mn        segment para public 'CODE' use32
.text$mn:00007784                 assume cs:_text$mn
.text$mn:00007784                 ;org 7784h
.text$mn:00007784 ; COMDAT (pick any)
.text$mn:00007784                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text$mn:00007784
.text$mn:00007784 ; =============== S U B R O U T I N E =======================================
.text$mn:00007784
.text$mn:00007784 ; Attributes: bp-based frame
.text$mn:00007784
.text$mn:00007784 ; _DWORD __thiscall std::_Container_base12::~_Container_base12(std::_Container_base12 *__hidden this)
.text$mn:00007784                 public ??1_Container_base12@std@@QAE@XZ
.text$mn:00007784 ??1_Container_base12@std@@QAE@XZ proc near
.text$mn:00007784                                         ; CODE XREF: __unwindfunclet$??0?$_String_val@U?$_Simple_types@D@std@@@std@@QAE@XZ$0+3j
.text$mn:00007784                                         ; __unwindfunclet$??0?$_String_val@U?$_Simple_types@_W@std@@@std@@QAE@XZ$0+3j ...
.text$mn:00007784
.text$mn:00007784 var_4           = dword ptr -4
.text$mn:00007784
.text$mn:00007784                 push    ebp
.text$mn:00007785                 mov     ebp, esp
.text$mn:00007787                 push    ecx
.text$mn:00007788                 mov     [ebp+var_4], ecx
.text$mn:0000778B                 mov     ecx, [ebp+var_4] ; this
.text$mn:0000778E                 call    ?_Orphan_all@_Container_base12@std@@QAEXXZ ; std::_Container_base12::_Orphan_all(void)
.text$mn:00007793                 mov     esp, ebp
.text$mn:00007795                 pop     ebp
.text$mn:00007796                 retn
.text$mn:00007796 ??1_Container_base12@std@@QAE@XZ endp
.text$mn:00007796
.text$mn:00007796 ; ---------------------------------------------------------------------------
.text$mn:00007797                 align 4
.text$mn:00007797 _text$mn        ends
.text$mn:00007797
.text$mn:00007798 ; ===========================================================================
.text$mn:00007798
.text$mn:00007798 ; Segment type: Pure code
.text$mn:00007798 ; Segment permissions: Read/Execute
.text$mn:00007798 _text$mn        segment para public 'CODE' use32
.text$mn:00007798                 assume cs:_text$mn
.text$mn:00007798                 ;org 7798h
.text$mn:00007798 ; COMDAT (pick any)
.text$mn:00007798                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text$mn:00007798
.text$mn:00007798 ; =============== S U B R O U T I N E =======================================
.text$mn:00007798
.text$mn:00007798 ; Attributes: bp-based frame
.text$mn:00007798
.text$mn:00007798 ; _DWORD __thiscall std::_Generic_error_category::~_Generic_error_category(std::_Generic_error_category *__hidden this)
.text$mn:00007798                 public ??1_Generic_error_category@std@@UAE@XZ
.text$mn:00007798 ??1_Generic_error_category@std@@UAE@XZ proc near
.text$mn:00007798                                         ; CODE XREF: __unwindfunclet$??0_Iostream_error_category@std@@QAE@XZ$0+3j
.text$mn:00007798                                         ; __unwindfunclet$??0_System_error_category@std@@QAE@XZ$0+3j ...
.text$mn:00007798
.text$mn:00007798 var_10          = dword ptr -10h
.text$mn:00007798 var_C           = dword ptr -0Ch
.text$mn:00007798 var_4           = dword ptr -4
.text$mn:00007798
.text$mn:00007798                 push    ebp
.text$mn:00007799                 mov     ebp, esp
.text$mn:0000779B                 push    0FFFFFFFFh
.text$mn:0000779D                 push    offset __ehhandler$??1_Generic_error_category@std@@UAE@XZ
.text$mn:000077A2                 mov     eax, large fs:0
.text$mn:000077A8                 push    eax
.text$mn:000077A9                 push    ecx
.text$mn:000077AA                 mov     eax, dword ptr ds:___security_cookie
.text$mn:000077AF                 xor     eax, ebp
.text$mn:000077B1                 push    eax
.text$mn:000077B2                 lea     eax, [ebp+var_C]
.text$mn:000077B5                 mov     large fs:0, eax
.text$mn:000077BB                 mov     [ebp+var_10], ecx
.text$mn:000077BE                 mov     [ebp+var_4], 0
.text$mn:000077C5                 mov     [ebp+var_4], 0FFFFFFFFh
.text$mn:000077CC                 mov     ecx, [ebp+var_10] ; this
.text$mn:000077CF                 call    ??1error_category@std@@UAE@XZ ; std::error_category::~error_category(void)
.text$mn:000077D4                 mov     ecx, [ebp+var_C]
.text$mn:000077D7                 mov     large fs:0, ecx
.text$mn:000077DE                 pop     ecx
.text$mn:000077DF                 mov     esp, ebp
.text$mn:000077E1                 pop     ebp
.text$mn:000077E2                 retn
.text$mn:000077E2 ??1_Generic_error_category@std@@UAE@XZ endp
.text$mn:000077E2
.text$mn:000077E2 ; ---------------------------------------------------------------------------
.text$mn:000077E3                 align 4
.text$mn:000077E3 _text$mn        ends
.text$mn:000077E3
.text$x:000077E4 ; ===========================================================================
.text$x:000077E4
.text$x:000077E4 ; Segment type: Pure code
.text$x:000077E4 ; Segment permissions: Read/Execute
.text$x:000077E4 _text$x         segment para public 'CODE' use32
.text$x:000077E4                 assume cs:_text$x
.text$x:000077E4                 ;org 77E4h
.text$x:000077E4 ; COMDAT (pick associative to section at 7798)
.text$x:000077E4                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text$x:000077E4
.text$x:000077E4 ; =============== S U B R O U T I N E =======================================
.text$x:000077E4
.text$x:000077E4
.text$x:000077E4 __unwindfunclet$??1_Generic_error_category@std@@UAE@XZ$0 proc near
.text$x:000077E4                                         ; DATA XREF: .xdata$x:0000D80Co
.text$x:000077E4                 mov     ecx, [ebp-10h]  ; this
.text$x:000077E7                 jmp     ??1error_category@std@@UAE@XZ ; std::error_category::~error_category(void)
.text$x:000077E7 __unwindfunclet$??1_Generic_error_category@std@@UAE@XZ$0 endp
.text$x:000077E7
.text$x:000077EC
.text$x:000077EC ; =============== S U B R O U T I N E =======================================
.text$x:000077EC
.text$x:000077EC
.text$x:000077EC __ehhandler$??1_Generic_error_category@std@@UAE@XZ proc near
.text$x:000077EC                                         ; DATA XREF: std::_Generic_error_category::~_Generic_error_category(void)+5o
.text$x:000077EC
.text$x:000077EC arg_4           = dword ptr  8
.text$x:000077EC
.text$x:000077EC                 mov     edx, [esp+arg_4]
.text$x:000077F0                 lea     eax, [edx+0Ch]
.text$x:000077F3                 mov     ecx, [edx-8]
.text$x:000077F6                 xor     ecx, eax
.text$x:000077F8                 call    @__security_check_cookie@4 ; __security_check_cookie(x)
.text$x:000077FD                 mov     eax, offset __ehfuncinfo$??1_Generic_error_category@std@@UAE@XZ
.text$x:00007802                 jmp     ___CxxFrameHandler3
.text$x:00007802 __ehhandler$??1_Generic_error_category@std@@UAE@XZ endp
.text$x:00007802
.text$x:00007802 ; ---------------------------------------------------------------------------
.text$x:00007807                 align 4
.text$x:00007807 _text$x         ends
.text$x:00007807
.text$mn:00007808 ; ===========================================================================
.text$mn:00007808
.text$mn:00007808 ; Segment type: Pure code
.text$mn:00007808 ; Segment permissions: Read/Execute
.text$mn:00007808 _text$mn        segment para public 'CODE' use32
.text$mn:00007808                 assume cs:_text$mn
.text$mn:00007808                 ;org 7808h
.text$mn:00007808 ; COMDAT (pick any)
.text$mn:00007808                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text$mn:00007808
.text$mn:00007808 ; =============== S U B R O U T I N E =======================================
.text$mn:00007808
.text$mn:00007808 ; Attributes: bp-based frame
.text$mn:00007808
.text$mn:00007808 ; _DWORD __thiscall std::_Iostream_error_category::~_Iostream_error_category(std::_Iostream_error_category *__hidden this)
.text$mn:00007808                 public ??1_Iostream_error_category@std@@UAE@XZ
.text$mn:00007808 ??1_Iostream_error_category@std@@UAE@XZ proc near
.text$mn:00007808                                         ; CODE XREF: std::_Iostream_error_category::`scalar deleting destructor'(uint)+Ap
.text$mn:00007808                                         ; `dynamic atexit destructor for 'std::_Iostream_error_category std::_Error_objects<int>::_Iostream_object''(void)+8p
.text$mn:00007808
.text$mn:00007808 var_10          = dword ptr -10h
.text$mn:00007808 var_C           = dword ptr -0Ch
.text$mn:00007808 var_4           = dword ptr -4
.text$mn:00007808
.text$mn:00007808                 push    ebp
.text$mn:00007809                 mov     ebp, esp
.text$mn:0000780B                 push    0FFFFFFFFh
.text$mn:0000780D                 push    offset __ehhandler$??1_Iostream_error_category@std@@UAE@XZ
.text$mn:00007812                 mov     eax, large fs:0
.text$mn:00007818                 push    eax
.text$mn:00007819                 push    ecx
.text$mn:0000781A                 mov     eax, dword ptr ds:___security_cookie
.text$mn:0000781F                 xor     eax, ebp
.text$mn:00007821                 push    eax
.text$mn:00007822                 lea     eax, [ebp+var_C]
.text$mn:00007825                 mov     large fs:0, eax
.text$mn:0000782B                 mov     [ebp+var_10], ecx
.text$mn:0000782E                 mov     [ebp+var_4], 0
.text$mn:00007835                 mov     [ebp+var_4], 0FFFFFFFFh
.text$mn:0000783C                 mov     ecx, [ebp+var_10] ; this
.text$mn:0000783F                 call    ??1_Generic_error_category@std@@UAE@XZ ; std::_Generic_error_category::~_Generic_error_category(void)
.text$mn:00007844                 mov     ecx, [ebp+var_C]
.text$mn:00007847                 mov     large fs:0, ecx
.text$mn:0000784E                 pop     ecx
.text$mn:0000784F                 mov     esp, ebp
.text$mn:00007851                 pop     ebp
.text$mn:00007852                 retn
.text$mn:00007852 ??1_Iostream_error_category@std@@UAE@XZ endp
.text$mn:00007852
.text$mn:00007852 ; ---------------------------------------------------------------------------
.text$mn:00007853                 align 4
.text$mn:00007853 _text$mn        ends
.text$mn:00007853
.text$x:00007854 ; ===========================================================================
.text$x:00007854
.text$x:00007854 ; Segment type: Pure code
.text$x:00007854 ; Segment permissions: Read/Execute
.text$x:00007854 _text$x         segment para public 'CODE' use32
.text$x:00007854                 assume cs:_text$x
.text$x:00007854                 ;org 7854h
.text$x:00007854 ; COMDAT (pick associative to section at 7808)
.text$x:00007854                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text$x:00007854
.text$x:00007854 ; =============== S U B R O U T I N E =======================================
.text$x:00007854
.text$x:00007854
.text$x:00007854 __unwindfunclet$??1_Iostream_error_category@std@@UAE@XZ$0 proc near
.text$x:00007854                                         ; DATA XREF: .xdata$x:0000D890o
.text$x:00007854                 mov     ecx, [ebp-10h]  ; this
.text$x:00007857                 jmp     ??1_Generic_error_category@std@@UAE@XZ ; std::_Generic_error_category::~_Generic_error_category(void)
.text$x:00007857 __unwindfunclet$??1_Iostream_error_category@std@@UAE@XZ$0 endp
.text$x:00007857
.text$x:0000785C
.text$x:0000785C ; =============== S U B R O U T I N E =======================================
.text$x:0000785C
.text$x:0000785C
.text$x:0000785C __ehhandler$??1_Iostream_error_category@std@@UAE@XZ proc near
.text$x:0000785C                                         ; DATA XREF: std::_Iostream_error_category::~_Iostream_error_category(void)+5o
.text$x:0000785C
.text$x:0000785C arg_4           = dword ptr  8
.text$x:0000785C
.text$x:0000785C                 mov     edx, [esp+arg_4]
.text$x:00007860                 lea     eax, [edx+0Ch]
.text$x:00007863                 mov     ecx, [edx-8]
.text$x:00007866                 xor     ecx, eax
.text$x:00007868                 call    @__security_check_cookie@4 ; __security_check_cookie(x)
.text$x:0000786D                 mov     eax, offset __ehfuncinfo$??1_Iostream_error_category@std@@UAE@XZ
.text$x:00007872                 jmp     ___CxxFrameHandler3
.text$x:00007872 __ehhandler$??1_Iostream_error_category@std@@UAE@XZ endp
.text$x:00007872
.text$x:00007872 ; ---------------------------------------------------------------------------
.text$x:00007877                 align 4
.text$x:00007877 _text$x         ends
.text$x:00007877
.text$mn:00007878 ; ===========================================================================
.text$mn:00007878
.text$mn:00007878 ; Segment type: Pure code
.text$mn:00007878 ; Segment permissions: Read/Execute
.text$mn:00007878 _text$mn        segment para public 'CODE' use32
.text$mn:00007878                 assume cs:_text$mn
.text$mn:00007878                 ;org 7878h
.text$mn:00007878 ; COMDAT (pick any)
.text$mn:00007878                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text$mn:00007878
.text$mn:00007878 ; =============== S U B R O U T I N E =======================================
.text$mn:00007878
.text$mn:00007878 ; Attributes: bp-based frame
.text$mn:00007878
.text$mn:00007878 ; _DWORD __thiscall std::_Iterator_base12::~_Iterator_base12(std::_Iterator_base12 *__hidden this)
.text$mn:00007878                 public ??1_Iterator_base12@std@@QAE@XZ
.text$mn:00007878 ??1_Iterator_base12@std@@QAE@XZ proc near
.text$mn:00007878                                         ; CODE XREF: __unwindfunclet$??0?$_Iterator012@Urandom_access_iterator_tag@std@@_WHPB_WAB_WU_Iterator_base12@2@@std@@QAE@ABU01@@Z$0+3j
.text$mn:00007878                                         ; __unwindfunclet$??0?$_Iterator012@Urandom_access_iterator_tag@std@@_WHPB_WAB_WU_Iterator_base12@2@@std@@QAE@XZ$0+3j ...
.text$mn:00007878
.text$mn:00007878 var_14          = byte ptr -14h
.text$mn:00007878 var_10          = dword ptr -10h
.text$mn:00007878 var_C           = dword ptr -0Ch
.text$mn:00007878 var_4           = dword ptr -4
.text$mn:00007878
.text$mn:00007878                 push    ebp
.text$mn:00007879                 mov     ebp, esp
.text$mn:0000787B                 push    0FFFFFFFFh
.text$mn:0000787D                 push    offset __ehhandler$??1_Iterator_base12@std@@QAE@XZ
.text$mn:00007882                 mov     eax, large fs:0
.text$mn:00007888                 push    eax
.text$mn:00007889                 sub     esp, 8
.text$mn:0000788C                 mov     eax, dword ptr ds:___security_cookie
.text$mn:00007891                 xor     eax, ebp
.text$mn:00007893                 push    eax
.text$mn:00007894                 lea     eax, [ebp+var_C]
.text$mn:00007897                 mov     large fs:0, eax
.text$mn:0000789D                 mov     [ebp+var_10], ecx
.text$mn:000078A0                 push    3               ; int
.text$mn:000078A2                 lea     ecx, [ebp+var_14] ; this
.text$mn:000078A5                 call    ??0_Lockit@std@@QAE@H@Z ; std::_Lockit::_Lockit(int)
.text$mn:000078AA                 mov     [ebp+var_4], 0
.text$mn:000078B1                 mov     ecx, [ebp+var_10] ; this
.text$mn:000078B4                 call    ?_Orphan_me@_Iterator_base12@std@@QAEXXZ ; std::_Iterator_base12::_Orphan_me(void)
.text$mn:000078B9                 mov     [ebp+var_4], 0FFFFFFFFh
.text$mn:000078C0                 lea     ecx, [ebp+var_14] ; this
.text$mn:000078C3                 call    ??1_Lockit@std@@QAE@XZ ; std::_Lockit::~_Lockit(void)
.text$mn:000078C8                 mov     ecx, [ebp+var_C]
.text$mn:000078CB                 mov     large fs:0, ecx
.text$mn:000078D2                 pop     ecx
.text$mn:000078D3                 mov     esp, ebp
.text$mn:000078D5                 pop     ebp
.text$mn:000078D6                 retn
.text$mn:000078D6 ??1_Iterator_base12@std@@QAE@XZ endp
.text$mn:000078D6
.text$mn:000078D6 ; ---------------------------------------------------------------------------
.text$mn:000078D7                 align 4
.text$mn:000078D7 _text$mn        ends
.text$mn:000078D7
.text$x:000078D8 ; ===========================================================================
.text$x:000078D8
.text$x:000078D8 ; Segment type: Pure code
.text$x:000078D8 ; Segment permissions: Read/Execute
.text$x:000078D8 _text$x         segment para public 'CODE' use32
.text$x:000078D8                 assume cs:_text$x
.text$x:000078D8                 ;org 78D8h
.text$x:000078D8 ; COMDAT (pick associative to section at 7878)
.text$x:000078D8                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text$x:000078D8
.text$x:000078D8 ; =============== S U B R O U T I N E =======================================
.text$x:000078D8
.text$x:000078D8
.text$x:000078D8 __unwindfunclet$??1_Iterator_base12@std@@QAE@XZ$0 proc near
.text$x:000078D8                                         ; DATA XREF: .xdata$x:0000D48Co
.text$x:000078D8                 lea     ecx, [ebp-14h]  ; this
.text$x:000078DB                 jmp     ??1_Lockit@std@@QAE@XZ ; std::_Lockit::~_Lockit(void)
.text$x:000078DB __unwindfunclet$??1_Iterator_base12@std@@QAE@XZ$0 endp
.text$x:000078DB
.text$x:000078E0
.text$x:000078E0 ; =============== S U B R O U T I N E =======================================
.text$x:000078E0
.text$x:000078E0
.text$x:000078E0 __ehhandler$??1_Iterator_base12@std@@QAE@XZ proc near
.text$x:000078E0                                         ; DATA XREF: std::_Iterator_base12::~_Iterator_base12(void)+5o
.text$x:000078E0
.text$x:000078E0 arg_4           = dword ptr  8
.text$x:000078E0
.text$x:000078E0                 mov     edx, [esp+arg_4]
.text$x:000078E4                 lea     eax, [edx+0Ch]
.text$x:000078E7                 mov     ecx, [edx-0Ch]
.text$x:000078EA                 xor     ecx, eax
.text$x:000078EC                 call    @__security_check_cookie@4 ; __security_check_cookie(x)
.text$x:000078F1                 mov     eax, offset __ehfuncinfo$??1_Iterator_base12@std@@QAE@XZ
.text$x:000078F6                 jmp     ___CxxFrameHandler3
.text$x:000078F6 __ehhandler$??1_Iterator_base12@std@@QAE@XZ endp
.text$x:000078F6
.text$x:000078F6 ; ---------------------------------------------------------------------------
.text$x:000078FB                 align 4
.text$x:000078FB _text$x         ends
.text$x:000078FB
.text$mn:000078FC ; ===========================================================================
.text$mn:000078FC
.text$mn:000078FC ; Segment type: Pure code
.text$mn:000078FC ; Segment permissions: Read/Execute
.text$mn:000078FC _text$mn        segment para public 'CODE' use32
.text$mn:000078FC                 assume cs:_text$mn
.text$mn:000078FC                 ;org 78FCh
.text$mn:000078FC ; COMDAT (pick any)
.text$mn:000078FC                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text$mn:000078FC
.text$mn:000078FC ; =============== S U B R O U T I N E =======================================
.text$mn:000078FC
.text$mn:000078FC ; Attributes: bp-based frame
.text$mn:000078FC
.text$mn:000078FC ; _DWORD __thiscall std::_System_error_category::~_System_error_category(std::_System_error_category *__hidden this)
.text$mn:000078FC                 public ??1_System_error_category@std@@UAE@XZ
.text$mn:000078FC ??1_System_error_category@std@@UAE@XZ proc near
.text$mn:000078FC                                         ; CODE XREF: std::_System_error_category::`scalar deleting destructor'(uint)+Ap
.text$mn:000078FC                                         ; `dynamic atexit destructor for 'std::_System_error_category std::_Error_objects<int>::_System_object''(void)+8p
.text$mn:000078FC
.text$mn:000078FC var_10          = dword ptr -10h
.text$mn:000078FC var_C           = dword ptr -0Ch
.text$mn:000078FC var_4           = dword ptr -4
.text$mn:000078FC
.text$mn:000078FC                 push    ebp
.text$mn:000078FD                 mov     ebp, esp
.text$mn:000078FF                 push    0FFFFFFFFh
.text$mn:00007901                 push    offset __ehhandler$??1_System_error_category@std@@UAE@XZ
.text$mn:00007906                 mov     eax, large fs:0
.text$mn:0000790C                 push    eax
.text$mn:0000790D                 push    ecx
.text$mn:0000790E                 mov     eax, dword ptr ds:___security_cookie
.text$mn:00007913                 xor     eax, ebp
.text$mn:00007915                 push    eax
.text$mn:00007916                 lea     eax, [ebp+var_C]
.text$mn:00007919                 mov     large fs:0, eax
.text$mn:0000791F                 mov     [ebp+var_10], ecx
.text$mn:00007922                 mov     [ebp+var_4], 0
.text$mn:00007929                 mov     [ebp+var_4], 0FFFFFFFFh
.text$mn:00007930                 mov     ecx, [ebp+var_10] ; this
.text$mn:00007933                 call    ??1_Generic_error_category@std@@UAE@XZ ; std::_Generic_error_category::~_Generic_error_category(void)
.text$mn:00007938                 mov     ecx, [ebp+var_C]
.text$mn:0000793B                 mov     large fs:0, ecx
.text$mn:00007942                 pop     ecx
.text$mn:00007943                 mov     esp, ebp
.text$mn:00007945                 pop     ebp
.text$mn:00007946                 retn
.text$mn:00007946 ??1_System_error_category@std@@UAE@XZ endp
.text$mn:00007946
.text$mn:00007946 ; ---------------------------------------------------------------------------
.text$mn:00007947                 align 4
.text$mn:00007947 _text$mn        ends
.text$mn:00007947
.text$x:00007948 ; ===========================================================================
.text$x:00007948
.text$x:00007948 ; Segment type: Pure code
.text$x:00007948 ; Segment permissions: Read/Execute
.text$x:00007948 _text$x         segment para public 'CODE' use32
.text$x:00007948                 assume cs:_text$x
.text$x:00007948                 ;org 7948h
.text$x:00007948 ; COMDAT (pick associative to section at 78FC)
.text$x:00007948                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text$x:00007948
.text$x:00007948 ; =============== S U B R O U T I N E =======================================
.text$x:00007948
.text$x:00007948
.text$x:00007948 __unwindfunclet$??1_System_error_category@std@@UAE@XZ$0 proc near
.text$x:00007948                                         ; DATA XREF: .xdata$x:0000D914o
.text$x:00007948                 mov     ecx, [ebp-10h]  ; this
.text$x:0000794B                 jmp     ??1_Generic_error_category@std@@UAE@XZ ; std::_Generic_error_category::~_Generic_error_category(void)
.text$x:0000794B __unwindfunclet$??1_System_error_category@std@@UAE@XZ$0 endp
.text$x:0000794B
.text$x:00007950
.text$x:00007950 ; =============== S U B R O U T I N E =======================================
.text$x:00007950
.text$x:00007950
.text$x:00007950 __ehhandler$??1_System_error_category@std@@UAE@XZ proc near
.text$x:00007950                                         ; DATA XREF: std::_System_error_category::~_System_error_category(void)+5o
.text$x:00007950
.text$x:00007950 arg_4           = dword ptr  8
.text$x:00007950
.text$x:00007950                 mov     edx, [esp+arg_4]
.text$x:00007954                 lea     eax, [edx+0Ch]
.text$x:00007957                 mov     ecx, [edx-8]
.text$x:0000795A                 xor     ecx, eax
.text$x:0000795C                 call    @__security_check_cookie@4 ; __security_check_cookie(x)
.text$x:00007961                 mov     eax, offset __ehfuncinfo$??1_System_error_category@std@@UAE@XZ
.text$x:00007966                 jmp     ___CxxFrameHandler3
.text$x:00007966 __ehhandler$??1_System_error_category@std@@UAE@XZ endp
.text$x:00007966
.text$x:00007966 ; ---------------------------------------------------------------------------
.text$x:0000796B                 align 4
.text$x:0000796B _text$x         ends
.text$x:0000796B
.text$mn:0000796C ; ===========================================================================
.text$mn:0000796C
.text$mn:0000796C ; Segment type: Pure code
.text$mn:0000796C ; Segment permissions: Read/Execute
.text$mn:0000796C _text$mn        segment para public 'CODE' use32
.text$mn:0000796C                 assume cs:_text$mn
.text$mn:0000796C                 ;org 796Ch
.text$mn:0000796C ; COMDAT (pick any)
.text$mn:0000796C                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text$mn:0000796C
.text$mn:0000796C ; =============== S U B R O U T I N E =======================================
.text$mn:0000796C
.text$mn:0000796C ; Attributes: bp-based frame
.text$mn:0000796C
.text$mn:0000796C ; _DWORD __thiscall std::error_category::~error_category(std::error_category *__hidden this)
.text$mn:0000796C                 public ??1error_category@std@@UAE@XZ
.text$mn:0000796C ??1error_category@std@@UAE@XZ proc near ; CODE XREF: __unwindfunclet$??0_Generic_error_category@std@@QAE@XZ$0+3j
.text$mn:0000796C                                         ; std::_Generic_error_category::~_Generic_error_category(void)+37p ...
.text$mn:0000796C
.text$mn:0000796C var_4           = dword ptr -4
.text$mn:0000796C
.text$mn:0000796C                 push    ebp
.text$mn:0000796D                 mov     ebp, esp
.text$mn:0000796F                 push    ecx
.text$mn:00007970                 mov     [ebp+var_4], ecx
.text$mn:00007973                 mov     eax, [ebp+var_4]
.text$mn:00007976                 mov     dword ptr [eax], offset ??_7error_category@std@@6B@ ; const std::error_category::`vftable'
.text$mn:0000797C                 mov     esp, ebp
.text$mn:0000797E                 pop     ebp
.text$mn:0000797F                 retn
.text$mn:0000797F ??1error_category@std@@UAE@XZ endp
.text$mn:0000797F
.text$mn:0000797F _text$mn        ends
.text$mn:0000797F
.text$mn:00007980 ; ===========================================================================
.text$mn:00007980
.text$mn:00007980 ; Segment type: Pure code
.text$mn:00007980 ; Segment permissions: Read/Execute
.text$mn:00007980 _text$mn        segment para public 'CODE' use32
.text$mn:00007980                 assume cs:_text$mn
.text$mn:00007980                 ;org 7980h
.text$mn:00007980 ; COMDAT (pick any)
.text$mn:00007980                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text$mn:00007980
.text$mn:00007980 ; =============== S U B R O U T I N E =======================================
.text$mn:00007980
.text$mn:00007980 ; Attributes: bp-based frame
.text$mn:00007980
.text$mn:00007980 ; _DWORD __thiscall std::invalid_argument::~invalid_argument(std::invalid_argument *__hidden this)
.text$mn:00007980                 public ??1invalid_argument@std@@UAE@XZ
.text$mn:00007980 ??1invalid_argument@std@@UAE@XZ proc near
.text$mn:00007980                                         ; CODE XREF: std::invalid_argument::`scalar deleting destructor'(uint)+Ap
.text$mn:00007980
.text$mn:00007980 var_10          = dword ptr -10h
.text$mn:00007980 var_C           = dword ptr -0Ch
.text$mn:00007980 var_4           = dword ptr -4
.text$mn:00007980
.text$mn:00007980                 push    ebp
.text$mn:00007981                 mov     ebp, esp
.text$mn:00007983                 push    0FFFFFFFFh
.text$mn:00007985                 push    offset __ehhandler$??1invalid_argument@std@@UAE@XZ
.text$mn:0000798A                 mov     eax, large fs:0
.text$mn:00007990                 push    eax
.text$mn:00007991                 push    ecx
.text$mn:00007992                 mov     eax, dword ptr ds:___security_cookie
.text$mn:00007997                 xor     eax, ebp
.text$mn:00007999                 push    eax
.text$mn:0000799A                 lea     eax, [ebp+var_C]
.text$mn:0000799D                 mov     large fs:0, eax
.text$mn:000079A3                 mov     [ebp+var_10], ecx
.text$mn:000079A6                 mov     [ebp+var_4], 0
.text$mn:000079AD                 mov     [ebp+var_4], 0FFFFFFFFh
.text$mn:000079B4                 mov     ecx, [ebp+var_10] ; this
.text$mn:000079B7                 call    ??1logic_error@std@@UAE@XZ ; std::logic_error::~logic_error(void)
.text$mn:000079BC                 mov     ecx, [ebp+var_C]
.text$mn:000079BF                 mov     large fs:0, ecx
.text$mn:000079C6                 pop     ecx
.text$mn:000079C7                 mov     esp, ebp
.text$mn:000079C9                 pop     ebp
.text$mn:000079CA                 retn
.text$mn:000079CA ??1invalid_argument@std@@UAE@XZ endp
.text$mn:000079CA
.text$mn:000079CA ; ---------------------------------------------------------------------------
.text$mn:000079CB                 align 4
.text$mn:000079CB _text$mn        ends
.text$mn:000079CB
.text$x:000079CC ; ===========================================================================
.text$x:000079CC
.text$x:000079CC ; Segment type: Pure code
.text$x:000079CC ; Segment permissions: Read/Execute
.text$x:000079CC _text$x         segment para public 'CODE' use32
.text$x:000079CC                 assume cs:_text$x
.text$x:000079CC                 ;org 79CCh
.text$x:000079CC ; COMDAT (pick associative to section at 7980)
.text$x:000079CC                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text$x:000079CC
.text$x:000079CC ; =============== S U B R O U T I N E =======================================
.text$x:000079CC
.text$x:000079CC
.text$x:000079CC __unwindfunclet$??1invalid_argument@std@@UAE@XZ$0 proc near
.text$x:000079CC                                         ; DATA XREF: .xdata$x:0000D730o
.text$x:000079CC                 mov     ecx, [ebp-10h]  ; this
.text$x:000079CF                 jmp     ??1logic_error@std@@UAE@XZ ; std::logic_error::~logic_error(void)
.text$x:000079CF __unwindfunclet$??1invalid_argument@std@@UAE@XZ$0 endp
.text$x:000079CF
.text$x:000079D4
.text$x:000079D4 ; =============== S U B R O U T I N E =======================================
.text$x:000079D4
.text$x:000079D4
.text$x:000079D4 __ehhandler$??1invalid_argument@std@@UAE@XZ proc near
.text$x:000079D4                                         ; DATA XREF: std::invalid_argument::~invalid_argument(void)+5o
.text$x:000079D4
.text$x:000079D4 arg_4           = dword ptr  8
.text$x:000079D4
.text$x:000079D4                 mov     edx, [esp+arg_4]
.text$x:000079D8                 lea     eax, [edx+0Ch]
.text$x:000079DB                 mov     ecx, [edx-8]
.text$x:000079DE                 xor     ecx, eax
.text$x:000079E0                 call    @__security_check_cookie@4 ; __security_check_cookie(x)
.text$x:000079E5                 mov     eax, offset __ehfuncinfo$??1invalid_argument@std@@UAE@XZ
.text$x:000079EA                 jmp     ___CxxFrameHandler3
.text$x:000079EA __ehhandler$??1invalid_argument@std@@UAE@XZ endp
.text$x:000079EA
.text$x:000079EA ; ---------------------------------------------------------------------------
.text$x:000079EF                 align 10h
.text$x:000079EF _text$x         ends
.text$x:000079EF
.text$mn:000079F0 ; ===========================================================================
.text$mn:000079F0
.text$mn:000079F0 ; Segment type: Pure code
.text$mn:000079F0 ; Segment permissions: Read/Execute
.text$mn:000079F0 _text$mn        segment para public 'CODE' use32
.text$mn:000079F0                 assume cs:_text$mn
.text$mn:000079F0                 ;org 79F0h
.text$mn:000079F0 ; COMDAT (pick any)
.text$mn:000079F0                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text$mn:000079F0
.text$mn:000079F0 ; =============== S U B R O U T I N E =======================================
.text$mn:000079F0
.text$mn:000079F0 ; Attributes: bp-based frame
.text$mn:000079F0
.text$mn:000079F0 ; _DWORD __thiscall std::logic_error::~logic_error(std::logic_error *__hidden this)
.text$mn:000079F0                 public ??1logic_error@std@@UAE@XZ
.text$mn:000079F0 ??1logic_error@std@@UAE@XZ proc near    ; CODE XREF: __unwindfunclet$??0invalid_argument@std@@QAE@PBD@Z$0+3j
.text$mn:000079F0                                         ; __unwindfunclet$??0out_of_range@std@@QAE@PBD@Z$0+3j ...
.text$mn:000079F0
.text$mn:000079F0 var_10          = dword ptr -10h
.text$mn:000079F0 var_C           = dword ptr -0Ch
.text$mn:000079F0 var_4           = dword ptr -4
.text$mn:000079F0
.text$mn:000079F0                 push    ebp
.text$mn:000079F1                 mov     ebp, esp
.text$mn:000079F3                 push    0FFFFFFFFh
.text$mn:000079F5                 push    offset __ehhandler$??1logic_error@std@@UAE@XZ
.text$mn:000079FA                 mov     eax, large fs:0
.text$mn:00007A00                 push    eax
.text$mn:00007A01                 push    ecx
.text$mn:00007A02                 mov     eax, dword ptr ds:___security_cookie
.text$mn:00007A07                 xor     eax, ebp
.text$mn:00007A09                 push    eax
.text$mn:00007A0A                 lea     eax, [ebp+var_C]
.text$mn:00007A0D                 mov     large fs:0, eax
.text$mn:00007A13                 mov     [ebp+var_10], ecx
.text$mn:00007A16                 mov     [ebp+var_4], 0
.text$mn:00007A1D                 mov     [ebp+var_4], 0FFFFFFFFh
.text$mn:00007A24                 mov     ecx, [ebp+var_10] ; this
.text$mn:00007A27                 call    ??1exception@std@@UAE@XZ ; std::exception::~exception(void)
.text$mn:00007A2C                 mov     ecx, [ebp+var_C]
.text$mn:00007A2F                 mov     large fs:0, ecx
.text$mn:00007A36                 pop     ecx
.text$mn:00007A37                 mov     esp, ebp
.text$mn:00007A39                 pop     ebp
.text$mn:00007A3A                 retn
.text$mn:00007A3A ??1logic_error@std@@UAE@XZ endp
.text$mn:00007A3A
.text$mn:00007A3A ; ---------------------------------------------------------------------------
.text$mn:00007A3B                 align 4
.text$mn:00007A3B _text$mn        ends
.text$mn:00007A3B
.text$x:00007A3C ; ===========================================================================
.text$x:00007A3C
.text$x:00007A3C ; Segment type: Pure code
.text$x:00007A3C ; Segment permissions: Read/Execute
.text$x:00007A3C _text$x         segment para public 'CODE' use32
.text$x:00007A3C                 assume cs:_text$x
.text$x:00007A3C                 ;org 7A3Ch
.text$x:00007A3C ; COMDAT (pick associative to section at 79F0)
.text$x:00007A3C                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text$x:00007A3C
.text$x:00007A3C ; =============== S U B R O U T I N E =======================================
.text$x:00007A3C
.text$x:00007A3C
.text$x:00007A3C __unwindfunclet$??1logic_error@std@@UAE@XZ$0 proc near
.text$x:00007A3C                                         ; DATA XREF: .xdata$x:0000D518o
.text$x:00007A3C                 mov     ecx, [ebp-10h]  ; this
.text$x:00007A3F                 jmp     ??1exception@std@@UAE@XZ ; std::exception::~exception(void)
.text$x:00007A3F __unwindfunclet$??1logic_error@std@@UAE@XZ$0 endp
.text$x:00007A3F
.text$x:00007A44
.text$x:00007A44 ; =============== S U B R O U T I N E =======================================
.text$x:00007A44
.text$x:00007A44
.text$x:00007A44 __ehhandler$??1logic_error@std@@UAE@XZ proc near
.text$x:00007A44                                         ; DATA XREF: std::logic_error::~logic_error(void)+5o
.text$x:00007A44
.text$x:00007A44 arg_4           = dword ptr  8
.text$x:00007A44
.text$x:00007A44                 mov     edx, [esp+arg_4]
.text$x:00007A48                 lea     eax, [edx+0Ch]
.text$x:00007A4B                 mov     ecx, [edx-8]
.text$x:00007A4E                 xor     ecx, eax
.text$x:00007A50                 call    @__security_check_cookie@4 ; __security_check_cookie(x)
.text$x:00007A55                 mov     eax, offset __ehfuncinfo$??1logic_error@std@@UAE@XZ
.text$x:00007A5A                 jmp     ___CxxFrameHandler3
.text$x:00007A5A __ehhandler$??1logic_error@std@@UAE@XZ endp
.text$x:00007A5A
.text$x:00007A5A ; ---------------------------------------------------------------------------
.text$x:00007A5F                 align 10h
.text$x:00007A5F _text$x         ends
.text$x:00007A5F
.text$mn:00007A60 ; ===========================================================================
.text$mn:00007A60
.text$mn:00007A60 ; Segment type: Pure code
.text$mn:00007A60 ; Segment permissions: Read/Execute
.text$mn:00007A60 _text$mn        segment para public 'CODE' use32
.text$mn:00007A60                 assume cs:_text$mn
.text$mn:00007A60                 ;org 7A60h
.text$mn:00007A60 ; COMDAT (pick any)
.text$mn:00007A60                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text$mn:00007A60
.text$mn:00007A60 ; =============== S U B R O U T I N E =======================================
.text$mn:00007A60
.text$mn:00007A60 ; Attributes: bp-based frame
.text$mn:00007A60
.text$mn:00007A60 ; _DWORD __thiscall std::out_of_range::~out_of_range(std::out_of_range *__hidden this)
.text$mn:00007A60                 public ??1out_of_range@std@@UAE@XZ
.text$mn:00007A60 ??1out_of_range@std@@UAE@XZ proc near   ; CODE XREF: std::out_of_range::`scalar deleting destructor'(uint)+Ap
.text$mn:00007A60
.text$mn:00007A60 var_10          = dword ptr -10h
.text$mn:00007A60 var_C           = dword ptr -0Ch
.text$mn:00007A60 var_4           = dword ptr -4
.text$mn:00007A60
.text$mn:00007A60                 push    ebp
.text$mn:00007A61                 mov     ebp, esp
.text$mn:00007A63                 push    0FFFFFFFFh
.text$mn:00007A65                 push    offset __ehhandler$??1out_of_range@std@@UAE@XZ
.text$mn:00007A6A                 mov     eax, large fs:0
.text$mn:00007A70                 push    eax
.text$mn:00007A71                 push    ecx
.text$mn:00007A72                 mov     eax, dword ptr ds:___security_cookie
.text$mn:00007A77                 xor     eax, ebp
.text$mn:00007A79                 push    eax
.text$mn:00007A7A                 lea     eax, [ebp+var_C]
.text$mn:00007A7D                 mov     large fs:0, eax
.text$mn:00007A83                 mov     [ebp+var_10], ecx
.text$mn:00007A86                 mov     [ebp+var_4], 0
.text$mn:00007A8D                 mov     [ebp+var_4], 0FFFFFFFFh
.text$mn:00007A94                 mov     ecx, [ebp+var_10] ; this
.text$mn:00007A97                 call    ??1logic_error@std@@UAE@XZ ; std::logic_error::~logic_error(void)
.text$mn:00007A9C                 mov     ecx, [ebp+var_C]
.text$mn:00007A9F                 mov     large fs:0, ecx
.text$mn:00007AA6                 pop     ecx
.text$mn:00007AA7                 mov     esp, ebp
.text$mn:00007AA9                 pop     ebp
.text$mn:00007AAA                 retn
.text$mn:00007AAA ??1out_of_range@std@@UAE@XZ endp
.text$mn:00007AAA
.text$mn:00007AAA ; ---------------------------------------------------------------------------
.text$mn:00007AAB                 align 4
.text$mn:00007AAB _text$mn        ends
.text$mn:00007AAB
.text$x:00007AAC ; ===========================================================================
.text$x:00007AAC
.text$x:00007AAC ; Segment type: Pure code
.text$x:00007AAC ; Segment permissions: Read/Execute
.text$x:00007AAC _text$x         segment para public 'CODE' use32
.text$x:00007AAC                 assume cs:_text$x
.text$x:00007AAC                 ;org 7AACh
.text$x:00007AAC ; COMDAT (pick associative to section at 7A60)
.text$x:00007AAC                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text$x:00007AAC
.text$x:00007AAC ; =============== S U B R O U T I N E =======================================
.text$x:00007AAC
.text$x:00007AAC
.text$x:00007AAC __unwindfunclet$??1out_of_range@std@@UAE@XZ$0 proc near
.text$x:00007AAC                                         ; DATA XREF: .xdata$x:0000D788o
.text$x:00007AAC                 mov     ecx, [ebp-10h]  ; this
.text$x:00007AAF                 jmp     ??1logic_error@std@@UAE@XZ ; std::logic_error::~logic_error(void)
.text$x:00007AAF __unwindfunclet$??1out_of_range@std@@UAE@XZ$0 endp
.text$x:00007AAF
.text$x:00007AB4
.text$x:00007AB4 ; =============== S U B R O U T I N E =======================================
.text$x:00007AB4
.text$x:00007AB4
.text$x:00007AB4 __ehhandler$??1out_of_range@std@@UAE@XZ proc near
.text$x:00007AB4                                         ; DATA XREF: std::out_of_range::~out_of_range(void)+5o
.text$x:00007AB4
.text$x:00007AB4 arg_4           = dword ptr  8
.text$x:00007AB4
.text$x:00007AB4                 mov     edx, [esp+arg_4]
.text$x:00007AB8                 lea     eax, [edx+0Ch]
.text$x:00007ABB                 mov     ecx, [edx-8]
.text$x:00007ABE                 xor     ecx, eax
.text$x:00007AC0                 call    @__security_check_cookie@4 ; __security_check_cookie(x)
.text$x:00007AC5                 mov     eax, offset __ehfuncinfo$??1out_of_range@std@@UAE@XZ
.text$x:00007ACA                 jmp     ___CxxFrameHandler3
.text$x:00007ACA __ehhandler$??1out_of_range@std@@UAE@XZ endp
.text$x:00007ACA
.text$x:00007ACA ; ---------------------------------------------------------------------------
.text$x:00007ACF                 align 10h
.text$x:00007ACF _text$x         ends
.text$x:00007ACF
.text$mn:00007AD0 ; ===========================================================================
.text$mn:00007AD0
.text$mn:00007AD0 ; Segment type: Pure code
.text$mn:00007AD0 ; Segment permissions: Read/Execute
.text$mn:00007AD0 _text$mn        segment para public 'CODE' use32
.text$mn:00007AD0                 assume cs:_text$mn
.text$mn:00007AD0                 ;org 7AD0h
.text$mn:00007AD0 ; COMDAT (pick any)
.text$mn:00007AD0                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text$mn:00007AD0
.text$mn:00007AD0 ; =============== S U B R O U T I N E =======================================
.text$mn:00007AD0
.text$mn:00007AD0 ; Attributes: bp-based frame
.text$mn:00007AD0
.text$mn:00007AD0 ; void *__cdecl operator new(unsigned int, void *)
.text$mn:00007AD0                 public ??2@YAPAXIPAX@Z
.text$mn:00007AD0 ??2@YAPAXIPAX@Z proc near               ; CODE XREF: std::allocator<char>::construct<char *,char * &>(char * *,char * &)+2Ep
.text$mn:00007AD0                                         ; std::allocator<wchar_t>::construct<wchar_t *,wchar_t * &>(wchar_t * *,wchar_t * &)+2Ep ...
.text$mn:00007AD0
.text$mn:00007AD0 arg_4           = dword ptr  0Ch
.text$mn:00007AD0
.text$mn:00007AD0                 push    ebp
.text$mn:00007AD1                 mov     ebp, esp
.text$mn:00007AD3                 mov     eax, [ebp+arg_4]
.text$mn:00007AD6                 pop     ebp
.text$mn:00007AD7                 retn
.text$mn:00007AD7 ??2@YAPAXIPAX@Z endp
.text$mn:00007AD7
.text$mn:00007AD7 _text$mn        ends
.text$mn:00007AD7
.text$mn:00007AD8 ; ===========================================================================
.text$mn:00007AD8
.text$mn:00007AD8 ; Segment type: Pure code
.text$mn:00007AD8 ; Segment permissions: Read/Execute
.text$mn:00007AD8 _text$mn        segment para public 'CODE' use32
.text$mn:00007AD8                 assume cs:_text$mn
.text$mn:00007AD8                 ;org 7AD8h
.text$mn:00007AD8 ; COMDAT (pick any)
.text$mn:00007AD8                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text$mn:00007AD8
.text$mn:00007AD8 ; =============== S U B R O U T I N E =======================================
.text$mn:00007AD8
.text$mn:00007AD8 ; Attributes: bp-based frame
.text$mn:00007AD8
.text$mn:00007AD8 ; void __cdecl operator delete(void *)
.text$mn:00007AD8                 public ??3@YAXPAX0@Z
.text$mn:00007AD8 ??3@YAXPAX0@Z   proc near               ; CODE XREF: __unwindfunclet$??$construct@PADAAPAD@?$allocator@D@std@@QAEXPAPADAAPAD@Z$0+8p
.text$mn:00007AD8                                         ; __unwindfunclet$??$construct@PA_WAAPA_W@?$allocator@_W@std@@QAEXPAPA_WAAPA_W@Z$0+8p ...
.text$mn:00007AD8                 push    ebp
.text$mn:00007AD9                 mov     ebp, esp
.text$mn:00007ADB                 pop     ebp
.text$mn:00007ADC                 retn
.text$mn:00007ADC ??3@YAXPAX0@Z   endp
.text$mn:00007ADC
.text$mn:00007ADC ; ---------------------------------------------------------------------------
.text$mn:00007ADD                 align 10h
.text$mn:00007ADD _text$mn        ends
.text$mn:00007ADD
.text$mn:00007AE0 ; ===========================================================================
.text$mn:00007AE0
.text$mn:00007AE0 ; Segment type: Pure code
.text$mn:00007AE0 ; Segment permissions: Read/Execute
.text$mn:00007AE0 _text$mn        segment para public 'CODE' use32
.text$mn:00007AE0                 assume cs:_text$mn
.text$mn:00007AE0                 ;org 7AE0h
.text$mn:00007AE0 ; COMDAT (pick any)
.text$mn:00007AE0                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text$mn:00007AE0
.text$mn:00007AE0 ; =============== S U B R O U T I N E =======================================
.text$mn:00007AE0
.text$mn:00007AE0 ; Attributes: bp-based frame
.text$mn:00007AE0
.text$mn:00007AE0 ; public: class std::basic_string<wchar_t, struct std::char_traits<wchar_t>, class std::allocator<wchar_t>> & __thiscall std::basic_string<wchar_t, struct std::char_traits<wchar_t>, class std::allocator<wchar_t>>::operator=(class std::basic_string<wchar_t, struct std::char_traits<wchar_t>, class std::allocator<wchar_t>> const &)
.text$mn:00007AE0                 public ??4?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QAEAAV01@ABV01@@Z
.text$mn:00007AE0 ??4?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QAEAAV01@ABV01@@Z proc near
.text$mn:00007AE0                                         ; CODE XREF: PathAppendW(std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>> &,std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>> const &)+C2p
.text$mn:00007AE0
.text$mn:00007AE0 var_8           = dword ptr -8
.text$mn:00007AE0 var_3           = byte ptr -3
.text$mn:00007AE0 var_2           = byte ptr -2
.text$mn:00007AE0 var_1           = byte ptr -1
.text$mn:00007AE0 arg_0           = dword ptr  8
.text$mn:00007AE0
.text$mn:00007AE0                 push    ebp
.text$mn:00007AE1                 mov     ebp, esp
.text$mn:00007AE3                 sub     esp, 8
.text$mn:00007AE6                 mov     [ebp+var_8], ecx
.text$mn:00007AE9                 mov     eax, [ebp+var_8]
.text$mn:00007AEC                 cmp     eax, [ebp+arg_0]
.text$mn:00007AEF                 jz      short loc_7B4B
.text$mn:00007AF1                 lea     ecx, [ebp+var_1]
.text$mn:00007AF4                 push    ecx
.text$mn:00007AF5                 mov     ecx, [ebp+arg_0]
.text$mn:00007AF8                 call    ?_Getal@?$_String_alloc@$0A@U?$_String_base_types@_WV?$allocator@_W@std@@@std@@@std@@QBE?AU?$_Wrap_alloc@V?$allocator@_W@std@@@2@XZ ; std::_String_alloc<0,std::_String_base_types<wchar_t,std::allocator<wchar_t>>>::_Getal(void)
.text$mn:00007AFD                 push    eax
.text$mn:00007AFE                 lea     edx, [ebp+var_2]
.text$mn:00007B01                 push    edx
.text$mn:00007B02                 mov     ecx, [ebp+var_8]
.text$mn:00007B05                 call    ?_Getal@?$_String_alloc@$0A@U?$_String_base_types@_WV?$allocator@_W@std@@@std@@@std@@QBE?AU?$_Wrap_alloc@V?$allocator@_W@std@@@2@XZ ; std::_String_alloc<0,std::_String_base_types<wchar_t,std::allocator<wchar_t>>>::_Getal(void)
.text$mn:00007B0A                 push    eax
.text$mn:00007B0B                 call    ??$?9V?$allocator@_W@std@@V01@@std@@YA_NABU?$_Wrap_alloc@V?$allocator@_W@std@@@0@0@Z ; std::operator!=<std::allocator<wchar_t>,std::allocator<wchar_t>>(std::_Wrap_alloc<std::allocator<wchar_t>> const &,std::_Wrap_alloc<std::allocator<wchar_t>> const &)
.text$mn:00007B10                 add     esp, 8
.text$mn:00007B13                 movzx   eax, al
.text$mn:00007B16                 test    eax, eax
.text$mn:00007B18                 jz      short loc_7B3F
.text$mn:00007B1A                 xor     ecx, ecx
.text$mn:00007B1C                 jz      short loc_7B3F
.text$mn:00007B1E                 push    0
.text$mn:00007B20                 push    1
.text$mn:00007B22                 mov     ecx, [ebp+var_8]
.text$mn:00007B25                 call    ?_Tidy@?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QAEX_NI@Z ; std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>>::_Tidy(bool,uint)
.text$mn:00007B2A                 lea     edx, [ebp+var_3]
.text$mn:00007B2D                 push    edx
.text$mn:00007B2E                 mov     ecx, [ebp+arg_0]
.text$mn:00007B31                 call    ?_Getal@?$_String_alloc@$0A@U?$_String_base_types@_WV?$allocator@_W@std@@@std@@@std@@QBE?AU?$_Wrap_alloc@V?$allocator@_W@std@@@2@XZ ; std::_String_alloc<0,std::_String_base_types<wchar_t,std::allocator<wchar_t>>>::_Getal(void)
.text$mn:00007B36                 push    eax
.text$mn:00007B37                 mov     ecx, [ebp+var_8]
.text$mn:00007B3A                 call    ?_Change_alloc@?$_String_alloc@$0A@U?$_String_base_types@_WV?$allocator@_W@std@@@std@@@std@@QAEXABU?$_Wrap_alloc@V?$allocator@_W@std@@@2@@Z ; std::_String_alloc<0,std::_String_base_types<wchar_t,std::allocator<wchar_t>>>::_Change_alloc(std::_Wrap_alloc<std::allocator<wchar_t>> const &)
.text$mn:00007B3F
.text$mn:00007B3F loc_7B3F:                               ; CODE XREF: std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>>::operator=(std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>> const &)+38j
.text$mn:00007B3F                                         ; std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>>::operator=(std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>> const &)+3Cj
.text$mn:00007B3F                 mov     eax, [ebp+arg_0]
.text$mn:00007B42                 push    eax
.text$mn:00007B43                 mov     ecx, [ebp+var_8]
.text$mn:00007B46                 call    ?assign@?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QAEAAV12@ABV12@@Z ; std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>>::assign(std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>> const &)
.text$mn:00007B4B
.text$mn:00007B4B loc_7B4B:                               ; CODE XREF: std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>>::operator=(std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>> const &)+Fj
.text$mn:00007B4B                 mov     eax, [ebp+var_8]
.text$mn:00007B4E                 mov     esp, ebp
.text$mn:00007B50                 pop     ebp
.text$mn:00007B51                 retn    4
.text$mn:00007B51 ??4?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QAEAAV01@ABV01@@Z endp
.text$mn:00007B51
.text$mn:00007B51 _text$mn        ends
.text$mn:00007B51
.text$mn:00007B54 ; ===========================================================================
.text$mn:00007B54
.text$mn:00007B54 ; Segment type: Pure code
.text$mn:00007B54 ; Segment permissions: Read/Execute
.text$mn:00007B54 _text$mn        segment para public 'CODE' use32
.text$mn:00007B54                 assume cs:_text$mn
.text$mn:00007B54                 ;org 7B54h
.text$mn:00007B54 ; COMDAT (pick any)
.text$mn:00007B54                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text$mn:00007B54
.text$mn:00007B54 ; =============== S U B R O U T I N E =======================================
.text$mn:00007B54
.text$mn:00007B54 ; Attributes: bp-based frame
.text$mn:00007B54
.text$mn:00007B54 ; int __stdcall std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>>::operator=(wchar_t *Str)
.text$mn:00007B54                 public ??4?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QAEAAV01@PB_W@Z
.text$mn:00007B54 ??4?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QAEAAV01@PB_W@Z proc near
.text$mn:00007B54                                         ; CODE XREF: getFolderName(HWND__ *,wchar_t const *)+105p
.text$mn:00007B54                                         ; PathAppendW(std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>> &,std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>> const &)+62p
.text$mn:00007B54
.text$mn:00007B54 var_4           = dword ptr -4
.text$mn:00007B54 Str             = dword ptr  8
.text$mn:00007B54
.text$mn:00007B54                 push    ebp
.text$mn:00007B55                 mov     ebp, esp
.text$mn:00007B57                 push    ecx
.text$mn:00007B58                 mov     [ebp+var_4], ecx
.text$mn:00007B5B                 mov     eax, [ebp+Str]
.text$mn:00007B5E                 push    eax             ; Str
.text$mn:00007B5F                 mov     ecx, [ebp+var_4]
.text$mn:00007B62                 call    ?assign@?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QAEAAV12@PB_W@Z ; std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>>::assign(wchar_t const *)
.text$mn:00007B67                 mov     esp, ebp
.text$mn:00007B69                 pop     ebp
.text$mn:00007B6A                 retn    4
.text$mn:00007B6A ??4?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QAEAAV01@PB_W@Z endp
.text$mn:00007B6A
.text$mn:00007B6A ; ---------------------------------------------------------------------------
.text$mn:00007B6D                 align 10h
.text$mn:00007B6D _text$mn        ends
.text$mn:00007B6D
.text$mn:00007B70 ; ===========================================================================
.text$mn:00007B70
.text$mn:00007B70 ; Segment type: Pure code
.text$mn:00007B70 ; Segment permissions: Read/Execute
.text$mn:00007B70 _text$mn        segment para public 'CODE' use32
.text$mn:00007B70                 assume cs:_text$mn
.text$mn:00007B70                 ;org 7B70h
.text$mn:00007B70 ; COMDAT (pick any)
.text$mn:00007B70                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text$mn:00007B70
.text$mn:00007B70 ; =============== S U B R O U T I N E =======================================
.text$mn:00007B70
.text$mn:00007B70 ; Attributes: bp-based frame
.text$mn:00007B70
.text$mn:00007B70 ; public: struct std::_Iterator_base12 & __thiscall std::_Iterator_base12::operator=(struct std::_Iterator_base12 const &)
.text$mn:00007B70                 public ??4_Iterator_base12@std@@QAEAAU01@ABU01@@Z
.text$mn:00007B70 ??4_Iterator_base12@std@@QAEAAU01@ABU01@@Z proc near
.text$mn:00007B70                                         ; CODE XREF: std::_Iterator_base12::_Iterator_base12(std::_Iterator_base12 const &)+21p
.text$mn:00007B70
.text$mn:00007B70 var_14          = byte ptr -14h
.text$mn:00007B70 var_10          = dword ptr -10h
.text$mn:00007B70 var_C           = dword ptr -0Ch
.text$mn:00007B70 var_4           = dword ptr -4
.text$mn:00007B70 arg_0           = dword ptr  8
.text$mn:00007B70
.text$mn:00007B70                 push    ebp
.text$mn:00007B71                 mov     ebp, esp
.text$mn:00007B73                 push    0FFFFFFFFh
.text$mn:00007B75                 push    offset __ehhandler$??4_Iterator_base12@std@@QAEAAU01@ABU01@@Z
.text$mn:00007B7A                 mov     eax, large fs:0
.text$mn:00007B80                 push    eax
.text$mn:00007B81                 sub     esp, 8
.text$mn:00007B84                 mov     eax, dword ptr ds:___security_cookie
.text$mn:00007B89                 xor     eax, ebp
.text$mn:00007B8B                 push    eax
.text$mn:00007B8C                 lea     eax, [ebp+var_C]
.text$mn:00007B8F                 mov     large fs:0, eax
.text$mn:00007B95                 mov     [ebp+var_10], ecx
.text$mn:00007B98                 mov     eax, [ebp+var_10]
.text$mn:00007B9B                 mov     ecx, [ebp+arg_0]
.text$mn:00007B9E                 mov     edx, [eax]
.text$mn:00007BA0                 cmp     edx, [ecx]
.text$mn:00007BA2                 jnz     short loc_7BA6
.text$mn:00007BA4                 jmp     short loc_7BE8
.text$mn:00007BA6 ; ---------------------------------------------------------------------------
.text$mn:00007BA6
.text$mn:00007BA6 loc_7BA6:                               ; CODE XREF: std::_Iterator_base12::operator=(std::_Iterator_base12 const &)+32j
.text$mn:00007BA6                 mov     eax, [ebp+arg_0]
.text$mn:00007BA9                 cmp     dword ptr [eax], 0
.text$mn:00007BAC                 jz      short loc_7BC0
.text$mn:00007BAE                 mov     ecx, [ebp+arg_0]
.text$mn:00007BB1                 mov     edx, [ecx]
.text$mn:00007BB3                 mov     eax, [edx]
.text$mn:00007BB5                 push    eax             ; struct std::_Container_base12 *
.text$mn:00007BB6                 mov     ecx, [ebp+var_10] ; this
.text$mn:00007BB9                 call    ?_Adopt@_Iterator_base12@std@@QAEXPBU_Container_base12@2@@Z ; std::_Iterator_base12::_Adopt(std::_Container_base12 const *)
.text$mn:00007BBE                 jmp     short loc_7BE8
.text$mn:00007BC0 ; ---------------------------------------------------------------------------
.text$mn:00007BC0
.text$mn:00007BC0 loc_7BC0:                               ; CODE XREF: std::_Iterator_base12::operator=(std::_Iterator_base12 const &)+3Cj
.text$mn:00007BC0                 push    3               ; int
.text$mn:00007BC2                 lea     ecx, [ebp+var_14] ; this
.text$mn:00007BC5                 call    ??0_Lockit@std@@QAE@H@Z ; std::_Lockit::_Lockit(int)
.text$mn:00007BCA                 mov     [ebp+var_4], 0
.text$mn:00007BD1                 mov     ecx, [ebp+var_10] ; this
.text$mn:00007BD4                 call    ?_Orphan_me@_Iterator_base12@std@@QAEXXZ ; std::_Iterator_base12::_Orphan_me(void)
.text$mn:00007BD9                 mov     [ebp+var_4], 0FFFFFFFFh
.text$mn:00007BE0                 lea     ecx, [ebp+var_14] ; this
.text$mn:00007BE3                 call    ??1_Lockit@std@@QAE@XZ ; std::_Lockit::~_Lockit(void)
.text$mn:00007BE8
.text$mn:00007BE8 loc_7BE8:                               ; CODE XREF: std::_Iterator_base12::operator=(std::_Iterator_base12 const &)+34j
.text$mn:00007BE8                                         ; std::_Iterator_base12::operator=(std::_Iterator_base12 const &)+4Ej
.text$mn:00007BE8                 mov     eax, [ebp+var_10]
.text$mn:00007BEB                 mov     ecx, [ebp+var_C]
.text$mn:00007BEE                 mov     large fs:0, ecx
.text$mn:00007BF5                 pop     ecx
.text$mn:00007BF6                 mov     esp, ebp
.text$mn:00007BF8                 pop     ebp
.text$mn:00007BF9                 retn    4
.text$mn:00007BF9 ??4_Iterator_base12@std@@QAEAAU01@ABU01@@Z endp
.text$mn:00007BF9
.text$mn:00007BF9 _text$mn        ends
.text$mn:00007BF9
.text$x:00007BFC ; ===========================================================================
.text$x:00007BFC
.text$x:00007BFC ; Segment type: Pure code
.text$x:00007BFC ; Segment permissions: Read/Execute
.text$x:00007BFC _text$x         segment para public 'CODE' use32
.text$x:00007BFC                 assume cs:_text$x
.text$x:00007BFC                 ;org 7BFCh
.text$x:00007BFC ; COMDAT (pick associative to section at 7B70)
.text$x:00007BFC                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text$x:00007BFC
.text$x:00007BFC ; =============== S U B R O U T I N E =======================================
.text$x:00007BFC
.text$x:00007BFC
.text$x:00007BFC __unwindfunclet$??4_Iterator_base12@std@@QAEAAU01@ABU01@@Z$0 proc near
.text$x:00007BFC                                         ; DATA XREF: .xdata$x:0000D460o
.text$x:00007BFC                 lea     ecx, [ebp-14h]  ; this
.text$x:00007BFF                 jmp     ??1_Lockit@std@@QAE@XZ ; std::_Lockit::~_Lockit(void)
.text$x:00007BFF __unwindfunclet$??4_Iterator_base12@std@@QAEAAU01@ABU01@@Z$0 endp
.text$x:00007BFF
.text$x:00007C04
.text$x:00007C04 ; =============== S U B R O U T I N E =======================================
.text$x:00007C04
.text$x:00007C04
.text$x:00007C04 __ehhandler$??4_Iterator_base12@std@@QAEAAU01@ABU01@@Z proc near
.text$x:00007C04                                         ; DATA XREF: std::_Iterator_base12::operator=(std::_Iterator_base12 const &)+5o
.text$x:00007C04
.text$x:00007C04 arg_4           = dword ptr  8
.text$x:00007C04
.text$x:00007C04                 mov     edx, [esp+arg_4]
.text$x:00007C08                 lea     eax, [edx+0Ch]
.text$x:00007C0B                 mov     ecx, [edx-0Ch]
.text$x:00007C0E                 xor     ecx, eax
.text$x:00007C10                 call    @__security_check_cookie@4 ; __security_check_cookie(x)
.text$x:00007C15                 mov     eax, offset __ehfuncinfo$??4_Iterator_base12@std@@QAEAAU01@ABU01@@Z
.text$x:00007C1A                 jmp     ___CxxFrameHandler3
.text$x:00007C1A __ehhandler$??4_Iterator_base12@std@@QAEAAU01@ABU01@@Z endp
.text$x:00007C1A
.text$x:00007C1A ; ---------------------------------------------------------------------------
.text$x:00007C1F                 align 10h
.text$x:00007C1F _text$x         ends
.text$x:00007C1F
.text$mn:00007C20 ; ===========================================================================
.text$mn:00007C20
.text$mn:00007C20 ; Segment type: Pure code
.text$mn:00007C20 ; Segment permissions: Read/Execute
.text$mn:00007C20 _text$mn        segment para public 'CODE' use32
.text$mn:00007C20                 assume cs:_text$mn
.text$mn:00007C20                 ;org 7C20h
.text$mn:00007C20 ; COMDAT (pick any)
.text$mn:00007C20                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text$mn:00007C20
.text$mn:00007C20 ; =============== S U B R O U T I N E =======================================
.text$mn:00007C20
.text$mn:00007C20 ; Attributes: bp-based frame
.text$mn:00007C20
.text$mn:00007C20 ; int __stdcall std::_String_const_iterator<std::_String_val<std::_Simple_types<wchar_t>>>::operator==(std::_Iterator_base12 *)
.text$mn:00007C20                 public ??8?$_String_const_iterator@V?$_String_val@U?$_Simple_types@_W@std@@@std@@@std@@QBE_NABV01@@Z
.text$mn:00007C20 ??8?$_String_const_iterator@V?$_String_val@U?$_Simple_types@_W@std@@@std@@@std@@QBE_NABV01@@Z proc near
.text$mn:00007C20                                         ; CODE XREF: std::_String_const_iterator<std::_String_val<std::_Simple_types<wchar_t>>>::operator!=(std::_String_const_iterator<std::_String_val<std::_Simple_types<wchar_t>>> const &)+10p
.text$mn:00007C20
.text$mn:00007C20 var_8           = dword ptr -8
.text$mn:00007C20 var_4           = dword ptr -4
.text$mn:00007C20 arg_0           = dword ptr  8
.text$mn:00007C20
.text$mn:00007C20                 push    ebp
.text$mn:00007C21                 mov     ebp, esp
.text$mn:00007C23                 sub     esp, 8
.text$mn:00007C26                 mov     [ebp+var_4], ecx
.text$mn:00007C29                 mov     eax, [ebp+arg_0]
.text$mn:00007C2C                 push    eax             ; std::_Iterator_base12 *
.text$mn:00007C2D                 mov     ecx, [ebp+var_4]
.text$mn:00007C30                 call    ?_Compat@?$_String_const_iterator@V?$_String_val@U?$_Simple_types@_W@std@@@std@@@std@@QBEXABV12@@Z ; std::_String_const_iterator<std::_String_val<std::_Simple_types<wchar_t>>>::_Compat(std::_String_const_iterator<std::_String_val<std::_Simple_types<wchar_t>>> const &)
.text$mn:00007C35                 mov     ecx, [ebp+var_4]
.text$mn:00007C38                 mov     edx, [ebp+arg_0]
.text$mn:00007C3B                 mov     eax, [ecx+8]
.text$mn:00007C3E                 cmp     eax, [edx+8]
.text$mn:00007C41                 jnz     short loc_7C4C
.text$mn:00007C43                 mov     [ebp+var_8], 1
.text$mn:00007C4A                 jmp     short loc_7C53
.text$mn:00007C4C ; ---------------------------------------------------------------------------
.text$mn:00007C4C
.text$mn:00007C4C loc_7C4C:                               ; CODE XREF: std::_String_const_iterator<std::_String_val<std::_Simple_types<wchar_t>>>::operator==(std::_String_const_iterator<std::_String_val<std::_Simple_types<wchar_t>>> const &)+21j
.text$mn:00007C4C                 mov     [ebp+var_8], 0
.text$mn:00007C53
.text$mn:00007C53 loc_7C53:                               ; CODE XREF: std::_String_const_iterator<std::_String_val<std::_Simple_types<wchar_t>>>::operator==(std::_String_const_iterator<std::_String_val<std::_Simple_types<wchar_t>>> const &)+2Aj
.text$mn:00007C53                 mov     al, byte ptr [ebp+var_8]
.text$mn:00007C56                 mov     esp, ebp
.text$mn:00007C58                 pop     ebp
.text$mn:00007C59                 retn    4
.text$mn:00007C59 ??8?$_String_const_iterator@V?$_String_val@U?$_Simple_types@_W@std@@@std@@@std@@QBE_NABV01@@Z endp
.text$mn:00007C59
.text$mn:00007C59 _text$mn        ends
.text$mn:00007C59
.text$mn:00007C5C ; ===========================================================================
.text$mn:00007C5C
.text$mn:00007C5C ; Segment type: Pure code
.text$mn:00007C5C ; Segment permissions: Read/Execute
.text$mn:00007C5C _text$mn        segment para public 'CODE' use32
.text$mn:00007C5C                 assume cs:_text$mn
.text$mn:00007C5C                 ;org 7C5Ch
.text$mn:00007C5C ; COMDAT (pick any)
.text$mn:00007C5C                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text$mn:00007C5C
.text$mn:00007C5C ; =============== S U B R O U T I N E =======================================
.text$mn:00007C5C
.text$mn:00007C5C ; Attributes: bp-based frame
.text$mn:00007C5C
.text$mn:00007C5C ; int __stdcall std::_Vector_const_iterator<std::_Vector_val<std::_Simple_types<wchar_t>>>::operator==(std::_Iterator_base12 *)
.text$mn:00007C5C                 public ??8?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@_W@std@@@std@@@std@@QBE_NABV01@@Z
.text$mn:00007C5C ??8?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@_W@std@@@std@@@std@@QBE_NABV01@@Z proc near
.text$mn:00007C5C                                         ; CODE XREF: std::_Revranit<std::_Vector_iterator<std::_Vector_val<std::_Simple_types<wchar_t>>>,std::iterator<std::random_access_iterator_tag,wchar_t,int,wchar_t *,wchar_t &>>::_Equal<std::_Vector_iterator<std::_Vector_val<std::_Simple_types<wchar_t>>>,std::iterator<std::random_access_iterator_tag,wchar_t,int,wchar_t *,wchar_t &>>(std::_Revranit<std::_Vector_iterator<std::_Vector_val<std::_Simple_types<wchar_t>>>,std::iterator<std::random_access_iterator_tag,wchar_t,int,wchar_t *,wchar_t &>> const &)+4Bp
.text$mn:00007C5C                                         ; std::_Vector_const_iterator<std::_Vector_val<std::_Simple_types<wchar_t>>>::operator!=(std::_Vector_const_iterator<std::_Vector_val<std::_Simple_types<wchar_t>>> const &)+10p
.text$mn:00007C5C
.text$mn:00007C5C var_8           = dword ptr -8
.text$mn:00007C5C var_4           = dword ptr -4
.text$mn:00007C5C arg_0           = dword ptr  8
.text$mn:00007C5C
.text$mn:00007C5C                 push    ebp
.text$mn:00007C5D                 mov     ebp, esp
.text$mn:00007C5F                 sub     esp, 8
.text$mn:00007C62                 mov     [ebp+var_4], ecx
.text$mn:00007C65                 mov     eax, [ebp+arg_0]
.text$mn:00007C68                 push    eax             ; std::_Iterator_base12 *
.text$mn:00007C69                 mov     ecx, [ebp+var_4]
.text$mn:00007C6C                 call    ?_Compat@?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@_W@std@@@std@@@std@@QBEXABV12@@Z ; std::_Vector_const_iterator<std::_Vector_val<std::_Simple_types<wchar_t>>>::_Compat(std::_Vector_const_iterator<std::_Vector_val<std::_Simple_types<wchar_t>>> const &)
.text$mn:00007C71                 mov     ecx, [ebp+var_4]
.text$mn:00007C74                 mov     edx, [ebp+arg_0]
.text$mn:00007C77                 mov     eax, [ecx+8]
.text$mn:00007C7A                 cmp     eax, [edx+8]
.text$mn:00007C7D                 jnz     short loc_7C88
.text$mn:00007C7F                 mov     [ebp+var_8], 1
.text$mn:00007C86                 jmp     short loc_7C8F
.text$mn:00007C88 ; ---------------------------------------------------------------------------
.text$mn:00007C88
.text$mn:00007C88 loc_7C88:                               ; CODE XREF: std::_Vector_const_iterator<std::_Vector_val<std::_Simple_types<wchar_t>>>::operator==(std::_Vector_const_iterator<std::_Vector_val<std::_Simple_types<wchar_t>>> const &)+21j
.text$mn:00007C88                 mov     [ebp+var_8], 0
.text$mn:00007C8F
.text$mn:00007C8F loc_7C8F:                               ; CODE XREF: std::_Vector_const_iterator<std::_Vector_val<std::_Simple_types<wchar_t>>>::operator==(std::_Vector_const_iterator<std::_Vector_val<std::_Simple_types<wchar_t>>> const &)+2Aj
.text$mn:00007C8F                 mov     al, byte ptr [ebp+var_8]
.text$mn:00007C92                 mov     esp, ebp
.text$mn:00007C94                 pop     ebp
.text$mn:00007C95                 retn    4
.text$mn:00007C95 ??8?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@_W@std@@@std@@@std@@QBE_NABV01@@Z endp
.text$mn:00007C95
.text$mn:00007C95 _text$mn        ends
.text$mn:00007C95
.text$mn:00007C98 ; ===========================================================================
.text$mn:00007C98
.text$mn:00007C98 ; Segment type: Pure code
.text$mn:00007C98 ; Segment permissions: Read/Execute
.text$mn:00007C98 _text$mn        segment para public 'CODE' use32
.text$mn:00007C98                 assume cs:_text$mn
.text$mn:00007C98                 ;org 7C98h
.text$mn:00007C98 ; COMDAT (pick any)
.text$mn:00007C98                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text$mn:00007C98
.text$mn:00007C98 ; =============== S U B R O U T I N E =======================================
.text$mn:00007C98
.text$mn:00007C98 ; Attributes: bp-based frame
.text$mn:00007C98
.text$mn:00007C98 ; public: bool __thiscall std::error_category::operator==(class std::error_category const &)const
.text$mn:00007C98                 public ??8error_category@std@@QBE_NABV01@@Z
.text$mn:00007C98 ??8error_category@std@@QBE_NABV01@@Z proc near
.text$mn:00007C98                                         ; CODE XREF: std::error_condition::operator==(std::error_condition const &)+1Dp
.text$mn:00007C98                                         ; std::error_category::equivalent(std::error_code const &,int)+15p
.text$mn:00007C98
.text$mn:00007C98 var_8           = dword ptr -8
.text$mn:00007C98 var_4           = dword ptr -4
.text$mn:00007C98 arg_0           = dword ptr  8
.text$mn:00007C98
.text$mn:00007C98                 push    ebp
.text$mn:00007C99                 mov     ebp, esp
.text$mn:00007C9B                 sub     esp, 8
.text$mn:00007C9E                 mov     [ebp+var_8], ecx
.text$mn:00007CA1                 mov     eax, [ebp+var_8]
.text$mn:00007CA4                 cmp     eax, [ebp+arg_0]
.text$mn:00007CA7                 jnz     short loc_7CB2
.text$mn:00007CA9                 mov     [ebp+var_4], 1
.text$mn:00007CB0                 jmp     short loc_7CB9
.text$mn:00007CB2 ; ---------------------------------------------------------------------------
.text$mn:00007CB2
.text$mn:00007CB2 loc_7CB2:                               ; CODE XREF: std::error_category::operator==(std::error_category const &)+Fj
.text$mn:00007CB2                 mov     [ebp+var_4], 0
.text$mn:00007CB9
.text$mn:00007CB9 loc_7CB9:                               ; CODE XREF: std::error_category::operator==(std::error_category const &)+18j
.text$mn:00007CB9                 mov     al, byte ptr [ebp+var_4]
.text$mn:00007CBC                 mov     esp, ebp
.text$mn:00007CBE                 pop     ebp
.text$mn:00007CBF                 retn    4
.text$mn:00007CBF ??8error_category@std@@QBE_NABV01@@Z endp
.text$mn:00007CBF
.text$mn:00007CBF ; ---------------------------------------------------------------------------
.text$mn:00007CC2                 align 4
.text$mn:00007CC2 _text$mn        ends
.text$mn:00007CC2
.text$mn:00007CC4 ; ===========================================================================
.text$mn:00007CC4
.text$mn:00007CC4 ; Segment type: Pure code
.text$mn:00007CC4 ; Segment permissions: Read/Execute
.text$mn:00007CC4 _text$mn        segment para public 'CODE' use32
.text$mn:00007CC4                 assume cs:_text$mn
.text$mn:00007CC4                 ;org 7CC4h
.text$mn:00007CC4 ; COMDAT (pick any)
.text$mn:00007CC4                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text$mn:00007CC4
.text$mn:00007CC4 ; =============== S U B R O U T I N E =======================================
.text$mn:00007CC4
.text$mn:00007CC4 ; Attributes: bp-based frame
.text$mn:00007CC4
.text$mn:00007CC4 ; int __stdcall std::error_condition::operator==(std::error_condition *)
.text$mn:00007CC4                 public ??8error_condition@std@@QBE_NABV01@@Z
.text$mn:00007CC4 ??8error_condition@std@@QBE_NABV01@@Z proc near
.text$mn:00007CC4                                         ; CODE XREF: std::error_category::equivalent(int,std::error_condition const &)+24p
.text$mn:00007CC4
.text$mn:00007CC4 var_8           = dword ptr -8
.text$mn:00007CC4 var_4           = dword ptr -4
.text$mn:00007CC4 arg_0           = dword ptr  8
.text$mn:00007CC4
.text$mn:00007CC4                 push    ebp
.text$mn:00007CC5                 mov     ebp, esp
.text$mn:00007CC7                 sub     esp, 8
.text$mn:00007CCA                 push    esi
.text$mn:00007CCB                 mov     [ebp+var_4], ecx
.text$mn:00007CCE                 mov     ecx, [ebp+arg_0] ; this
.text$mn:00007CD1                 call    ?category@error_condition@std@@QBEABVerror_category@2@XZ ; std::error_condition::category(void)
.text$mn:00007CD6                 push    eax
.text$mn:00007CD7                 mov     ecx, [ebp+var_4] ; this
.text$mn:00007CDA                 call    ?category@error_condition@std@@QBEABVerror_category@2@XZ ; std::error_condition::category(void)
.text$mn:00007CDF                 mov     ecx, eax
.text$mn:00007CE1                 call    ??8error_category@std@@QBE_NABV01@@Z ; std::error_category::operator==(std::error_category const &)
.text$mn:00007CE6                 movzx   eax, al
.text$mn:00007CE9                 test    eax, eax
.text$mn:00007CEB                 jz      short loc_7D0C
.text$mn:00007CED                 mov     ecx, [ebp+var_4] ; this
.text$mn:00007CF0                 call    ?value@error_condition@std@@QBEHXZ ; std::error_condition::value(void)
.text$mn:00007CF5                 mov     esi, eax
.text$mn:00007CF7                 mov     ecx, [ebp+arg_0] ; this
.text$mn:00007CFA                 call    ?value@error_condition@std@@QBEHXZ ; std::error_condition::value(void)
.text$mn:00007CFF                 cmp     esi, eax
.text$mn:00007D01                 jnz     short loc_7D0C
.text$mn:00007D03                 mov     [ebp+var_8], 1
.text$mn:00007D0A                 jmp     short loc_7D13
.text$mn:00007D0C ; ---------------------------------------------------------------------------
.text$mn:00007D0C
.text$mn:00007D0C loc_7D0C:                               ; CODE XREF: std::error_condition::operator==(std::error_condition const &)+27j
.text$mn:00007D0C                                         ; std::error_condition::operator==(std::error_condition const &)+3Dj
.text$mn:00007D0C                 mov     [ebp+var_8], 0
.text$mn:00007D13
.text$mn:00007D13 loc_7D13:                               ; CODE XREF: std::error_condition::operator==(std::error_condition const &)+46j
.text$mn:00007D13                 mov     al, byte ptr [ebp+var_8]
.text$mn:00007D16                 pop     esi
.text$mn:00007D17                 mov     esp, ebp
.text$mn:00007D19                 pop     ebp
.text$mn:00007D1A                 retn    4
.text$mn:00007D1A ??8error_condition@std@@QBE_NABV01@@Z endp
.text$mn:00007D1A
.text$mn:00007D1A ; ---------------------------------------------------------------------------
.text$mn:00007D1D                 align 10h
.text$mn:00007D1D _text$mn        ends
.text$mn:00007D1D
.text$mn:00007D20 ; ===========================================================================
.text$mn:00007D20
.text$mn:00007D20 ; Segment type: Pure code
.text$mn:00007D20 ; Segment permissions: Read/Execute
.text$mn:00007D20 _text$mn        segment para public 'CODE' use32
.text$mn:00007D20                 assume cs:_text$mn
.text$mn:00007D20                 ;org 7D20h
.text$mn:00007D20 ; COMDAT (pick any)
.text$mn:00007D20                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text$mn:00007D20
.text$mn:00007D20 ; =============== S U B R O U T I N E =======================================
.text$mn:00007D20
.text$mn:00007D20 ; Attributes: bp-based frame
.text$mn:00007D20
.text$mn:00007D20 ; int __stdcall std::_String_const_iterator<std::_String_val<std::_Simple_types<wchar_t>>>::operator!=(std::_Iterator_base12 *)
.text$mn:00007D20                 public ??9?$_String_const_iterator@V?$_String_val@U?$_Simple_types@_W@std@@@std@@@std@@QBE_NABV01@@Z
.text$mn:00007D20 ??9?$_String_const_iterator@V?$_String_val@U?$_Simple_types@_W@std@@@std@@@std@@QBE_NABV01@@Z proc near
.text$mn:00007D20                                         ; CODE XREF: std::_Debug_range2<std::_String_iterator<std::_String_val<std::_Simple_types<wchar_t>>>>(std::_String_iterator<std::_String_val<std::_Simple_types<wchar_t>>>,std::_String_iterator<std::_String_val<std::_Simple_types<wchar_t>>>,wchar_t const *,uint,std::random_access_iterator_tag)+30p
.text$mn:00007D20                                         ; convertFileName<std::_String_const_iterator<std::_String_val<std::_Simple_types<wchar_t>>>>(std::_String_const_iterator<std::_String_val<std::_Simple_types<wchar_t>>>,std::_String_const_iterator<std::_String_val<std::_Simple_types<wchar_t>>>)+63p ...
.text$mn:00007D20
.text$mn:00007D20 var_8           = dword ptr -8
.text$mn:00007D20 var_4           = dword ptr -4
.text$mn:00007D20 arg_0           = dword ptr  8
.text$mn:00007D20
.text$mn:00007D20                 push    ebp
.text$mn:00007D21                 mov     ebp, esp
.text$mn:00007D23                 sub     esp, 8
.text$mn:00007D26                 mov     [ebp+var_8], ecx
.text$mn:00007D29                 mov     eax, [ebp+arg_0]
.text$mn:00007D2C                 push    eax             ; std::_Iterator_base12 *
.text$mn:00007D2D                 mov     ecx, [ebp+var_8]
.text$mn:00007D30                 call    ??8?$_String_const_iterator@V?$_String_val@U?$_Simple_types@_W@std@@@std@@@std@@QBE_NABV01@@Z ; std::_String_const_iterator<std::_String_val<std::_Simple_types<wchar_t>>>::operator==(std::_String_const_iterator<std::_String_val<std::_Simple_types<wchar_t>>> const &)
.text$mn:00007D35                 movzx   ecx, al
.text$mn:00007D38                 test    ecx, ecx
.text$mn:00007D3A                 jnz     short loc_7D45
.text$mn:00007D3C                 mov     [ebp+var_4], 1
.text$mn:00007D43                 jmp     short loc_7D4C
.text$mn:00007D45 ; ---------------------------------------------------------------------------
.text$mn:00007D45
.text$mn:00007D45 loc_7D45:                               ; CODE XREF: std::_String_const_iterator<std::_String_val<std::_Simple_types<wchar_t>>>::operator!=(std::_String_const_iterator<std::_String_val<std::_Simple_types<wchar_t>>> const &)+1Aj
.text$mn:00007D45                 mov     [ebp+var_4], 0
.text$mn:00007D4C
.text$mn:00007D4C loc_7D4C:                               ; CODE XREF: std::_String_const_iterator<std::_String_val<std::_Simple_types<wchar_t>>>::operator!=(std::_String_const_iterator<std::_String_val<std::_Simple_types<wchar_t>>> const &)+23j
.text$mn:00007D4C                 mov     al, byte ptr [ebp+var_4]
.text$mn:00007D4F                 mov     esp, ebp
.text$mn:00007D51                 pop     ebp
.text$mn:00007D52                 retn    4
.text$mn:00007D52 ??9?$_String_const_iterator@V?$_String_val@U?$_Simple_types@_W@std@@@std@@@std@@QBE_NABV01@@Z endp
.text$mn:00007D52
.text$mn:00007D52 ; ---------------------------------------------------------------------------
.text$mn:00007D55                 align 4
.text$mn:00007D55 _text$mn        ends
.text$mn:00007D55
.text$mn:00007D58 ; ===========================================================================
.text$mn:00007D58
.text$mn:00007D58 ; Segment type: Pure code
.text$mn:00007D58 ; Segment permissions: Read/Execute
.text$mn:00007D58 _text$mn        segment para public 'CODE' use32
.text$mn:00007D58                 assume cs:_text$mn
.text$mn:00007D58                 ;org 7D58h
.text$mn:00007D58 ; COMDAT (pick any)
.text$mn:00007D58                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text$mn:00007D58
.text$mn:00007D58 ; =============== S U B R O U T I N E =======================================
.text$mn:00007D58
.text$mn:00007D58 ; Attributes: bp-based frame
.text$mn:00007D58
.text$mn:00007D58 ; int __stdcall std::_Vector_const_iterator<std::_Vector_val<std::_Simple_types<wchar_t>>>::operator!=(std::_Iterator_base12 *)
.text$mn:00007D58                 public ??9?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@_W@std@@@std@@@std@@QBE_NABV01@@Z
.text$mn:00007D58 ??9?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@_W@std@@@std@@@std@@QBE_NABV01@@Z proc near
.text$mn:00007D58                                         ; CODE XREF: convertFileName<std::_Vector_iterator<std::_Vector_val<std::_Simple_types<wchar_t>>>>(std::_Vector_iterator<std::_Vector_val<std::_Simple_types<wchar_t>>>,std::_Vector_iterator<std::_Vector_val<std::_Simple_types<wchar_t>>>)+63p
.text$mn:00007D58
.text$mn:00007D58 var_8           = dword ptr -8
.text$mn:00007D58 var_4           = dword ptr -4
.text$mn:00007D58 arg_0           = dword ptr  8
.text$mn:00007D58
.text$mn:00007D58                 push    ebp
.text$mn:00007D59                 mov     ebp, esp
.text$mn:00007D5B                 sub     esp, 8
.text$mn:00007D5E                 mov     [ebp+var_8], ecx
.text$mn:00007D61                 mov     eax, [ebp+arg_0]
.text$mn:00007D64                 push    eax             ; std::_Iterator_base12 *
.text$mn:00007D65                 mov     ecx, [ebp+var_8]
.text$mn:00007D68                 call    ??8?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@_W@std@@@std@@@std@@QBE_NABV01@@Z ; std::_Vector_const_iterator<std::_Vector_val<std::_Simple_types<wchar_t>>>::operator==(std::_Vector_const_iterator<std::_Vector_val<std::_Simple_types<wchar_t>>> const &)
.text$mn:00007D6D                 movzx   ecx, al
.text$mn:00007D70                 test    ecx, ecx
.text$mn:00007D72                 jnz     short loc_7D7D
.text$mn:00007D74                 mov     [ebp+var_4], 1
.text$mn:00007D7B                 jmp     short loc_7D84
.text$mn:00007D7D ; ---------------------------------------------------------------------------
.text$mn:00007D7D
.text$mn:00007D7D loc_7D7D:                               ; CODE XREF: std::_Vector_const_iterator<std::_Vector_val<std::_Simple_types<wchar_t>>>::operator!=(std::_Vector_const_iterator<std::_Vector_val<std::_Simple_types<wchar_t>>> const &)+1Aj
.text$mn:00007D7D                 mov     [ebp+var_4], 0
.text$mn:00007D84
.text$mn:00007D84 loc_7D84:                               ; CODE XREF: std::_Vector_const_iterator<std::_Vector_val<std::_Simple_types<wchar_t>>>::operator!=(std::_Vector_const_iterator<std::_Vector_val<std::_Simple_types<wchar_t>>> const &)+23j
.text$mn:00007D84                 mov     al, byte ptr [ebp+var_4]
.text$mn:00007D87                 mov     esp, ebp
.text$mn:00007D89                 pop     ebp
.text$mn:00007D8A                 retn    4
.text$mn:00007D8A ??9?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@_W@std@@@std@@@std@@QBE_NABV01@@Z endp
.text$mn:00007D8A
.text$mn:00007D8A ; ---------------------------------------------------------------------------
.text$mn:00007D8D                 align 10h
.text$mn:00007D8D _text$mn        ends
.text$mn:00007D8D
.text$mn:00007D90 ; ===========================================================================
.text$mn:00007D90
.text$mn:00007D90 ; Segment type: Pure code
.text$mn:00007D90 ; Segment permissions: Read/Execute
.text$mn:00007D90 _text$mn        segment para public 'CODE' use32
.text$mn:00007D90                 assume cs:_text$mn
.text$mn:00007D90                 ;org 7D90h
.text$mn:00007D90 ; COMDAT (pick any)
.text$mn:00007D90                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text$mn:00007D90
.text$mn:00007D90 ; =============== S U B R O U T I N E =======================================
.text$mn:00007D90
.text$mn:00007D90 ; Attributes: bp-based frame
.text$mn:00007D90
.text$mn:00007D90 ; public: wchar_t & __thiscall std::basic_string<wchar_t, struct std::char_traits<wchar_t>, class std::allocator<wchar_t>>::operator[](unsigned int)
.text$mn:00007D90                 public ??A?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QAEAA_WI@Z
.text$mn:00007D90 ??A?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QAEAA_WI@Z proc near
.text$mn:00007D90                                         ; CODE XREF: PathRemoveFileSpecW(std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>> &)+5Cp
.text$mn:00007D90                                         ; PathRemoveFileSpecW(std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>> &)+8Cp ...
.text$mn:00007D90
.text$mn:00007D90 var_4           = dword ptr -4
.text$mn:00007D90 arg_0           = dword ptr  8
.text$mn:00007D90
.text$mn:00007D90                 push    ebp
.text$mn:00007D91                 mov     ebp, esp
.text$mn:00007D93                 push    ecx
.text$mn:00007D94                 mov     [ebp+var_4], ecx
.text$mn:00007D97                 mov     eax, [ebp+var_4]
.text$mn:00007D9A                 mov     ecx, [eax+14h]
.text$mn:00007D9D                 cmp     ecx, [ebp+arg_0]
.text$mn:00007DA0                 jnb     short loc_7DB9
.text$mn:00007DA2                 push    695h            ; unsigned int
.text$mn:00007DA7                 push    offset ??_C@_1IO@FEAPGJBD@?$AAC?$AA?3?$AA?2?$AAP?$AAr?$AAo?$AAg?$AAr?$AAa?$AAm?$AA?5?$AAF?$AAi?$AAl?$AAe?$AAs?$AA?5?$AA?$CI?$AAx?$AA8?$AA6?$AA?$CJ?$AA?2?$AAM?$AAi?$AAc?$AAr?$AAo?$AAs?$AAo?$AAf?$AAt@ ; "C:\\Program Files (x86)\\Microsoft Visu"...
.text$mn:00007DAC                 push    offset ??_C@_1DM@GMPLOCPK@?$AAs?$AAt?$AAr?$AAi?$AAn?$AAg?$AA?5?$AAs?$AAu?$AAb?$AAs?$AAc?$AAr?$AAi?$AAp?$AAt?$AA?5?$AAo?$AAu?$AAt?$AA?5?$AAo?$AAf?$AA?5?$AAr?$AAa?$AAn?$AAg?$AAe?$AA?$AA@ ; "string subscript out of range"
.text$mn:00007DB1                 call    ?_Debug_message@std@@YAXPB_W0I@Z ; std::_Debug_message(wchar_t const *,wchar_t const *,uint)
.text$mn:00007DB6                 add     esp, 0Ch
.text$mn:00007DB9
.text$mn:00007DB9 loc_7DB9:                               ; CODE XREF: std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>>::operator[](uint)+10j
.text$mn:00007DB9                 mov     ecx, [ebp+var_4]
.text$mn:00007DBC                 call    ?_Myptr@?$_String_val@U?$_Simple_types@_W@std@@@std@@QAEPA_WXZ ; std::_String_val<std::_Simple_types<wchar_t>>::_Myptr(void)
.text$mn:00007DC1                 mov     edx, [ebp+arg_0]
.text$mn:00007DC4                 lea     eax, [eax+edx*2]
.text$mn:00007DC7                 mov     esp, ebp
.text$mn:00007DC9                 pop     ebp
.text$mn:00007DCA                 retn    4
.text$mn:00007DCA ??A?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QAEAA_WI@Z endp
.text$mn:00007DCA
.text$mn:00007DCA ; ---------------------------------------------------------------------------
.text$mn:00007DCD                 align 10h
.text$mn:00007DCD _text$mn        ends
.text$mn:00007DCD
.text$mn:00007DD0 ; ===========================================================================
.text$mn:00007DD0
.text$mn:00007DD0 ; Segment type: Pure code
.text$mn:00007DD0 ; Segment permissions: Read/Execute
.text$mn:00007DD0 _text$mn        segment para public 'CODE' use32
.text$mn:00007DD0                 assume cs:_text$mn
.text$mn:00007DD0                 ;org 7DD0h
.text$mn:00007DD0 ; COMDAT (pick any)
.text$mn:00007DD0                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text$mn:00007DD0
.text$mn:00007DD0 ; =============== S U B R O U T I N E =======================================
.text$mn:00007DD0
.text$mn:00007DD0 ; Attributes: bp-based frame
.text$mn:00007DD0
.text$mn:00007DD0 ; public: wchar_t const & __thiscall std::basic_string<wchar_t, struct std::char_traits<wchar_t>, class std::allocator<wchar_t>>::operator[](unsigned int)const
.text$mn:00007DD0                 public ??A?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QBEAB_WI@Z
.text$mn:00007DD0 ??A?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QBEAB_WI@Z proc near
.text$mn:00007DD0                                         ; CODE XREF: PathAppendW(std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>> &,std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>> const &)+124p
.text$mn:00007DD0                                         ; PathAppendW(std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>> &,std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>> const &)+1B0p ...
.text$mn:00007DD0
.text$mn:00007DD0 var_4           = dword ptr -4
.text$mn:00007DD0 arg_0           = dword ptr  8
.text$mn:00007DD0
.text$mn:00007DD0                 push    ebp
.text$mn:00007DD1                 mov     ebp, esp
.text$mn:00007DD3                 push    ecx
.text$mn:00007DD4                 mov     [ebp+var_4], ecx
.text$mn:00007DD7                 mov     eax, [ebp+var_4]
.text$mn:00007DDA                 mov     ecx, [eax+14h]
.text$mn:00007DDD                 cmp     ecx, [ebp+arg_0]
.text$mn:00007DE0                 jnb     short loc_7DF9
.text$mn:00007DE2                 push    6A2h            ; unsigned int
.text$mn:00007DE7                 push    offset ??_C@_1IO@FEAPGJBD@?$AAC?$AA?3?$AA?2?$AAP?$AAr?$AAo?$AAg?$AAr?$AAa?$AAm?$AA?5?$AAF?$AAi?$AAl?$AAe?$AAs?$AA?5?$AA?$CI?$AAx?$AA8?$AA6?$AA?$CJ?$AA?2?$AAM?$AAi?$AAc?$AAr?$AAo?$AAs?$AAo?$AAf?$AAt@ ; "C:\\Program Files (x86)\\Microsoft Visu"...
.text$mn:00007DEC                 push    offset ??_C@_1DM@GMPLOCPK@?$AAs?$AAt?$AAr?$AAi?$AAn?$AAg?$AA?5?$AAs?$AAu?$AAb?$AAs?$AAc?$AAr?$AAi?$AAp?$AAt?$AA?5?$AAo?$AAu?$AAt?$AA?5?$AAo?$AAf?$AA?5?$AAr?$AAa?$AAn?$AAg?$AAe?$AA?$AA@ ; "string subscript out of range"
.text$mn:00007DF1                 call    ?_Debug_message@std@@YAXPB_W0I@Z ; std::_Debug_message(wchar_t const *,wchar_t const *,uint)
.text$mn:00007DF6                 add     esp, 0Ch
.text$mn:00007DF9
.text$mn:00007DF9 loc_7DF9:                               ; CODE XREF: std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>>::operator[](uint)+10j
.text$mn:00007DF9                 mov     ecx, [ebp+var_4]
.text$mn:00007DFC                 call    ?_Myptr@?$_String_val@U?$_Simple_types@_W@std@@@std@@QBEPB_WXZ ; std::_String_val<std::_Simple_types<wchar_t>>::_Myptr(void)
.text$mn:00007E01                 mov     edx, [ebp+arg_0]
.text$mn:00007E04                 lea     eax, [eax+edx*2]
.text$mn:00007E07                 mov     esp, ebp
.text$mn:00007E09                 pop     ebp
.text$mn:00007E0A                 retn    4
.text$mn:00007E0A ??A?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QBEAB_WI@Z endp
.text$mn:00007E0A
.text$mn:00007E0A ; ---------------------------------------------------------------------------
.text$mn:00007E0D                 align 10h
.text$mn:00007E0D _text$mn        ends
.text$mn:00007E0D
.text$mn:00007E10 ; ===========================================================================
.text$mn:00007E10
.text$mn:00007E10 ; Segment type: Pure code
.text$mn:00007E10 ; Segment permissions: Read/Execute
.text$mn:00007E10 _text$mn        segment para public 'CODE' use32
.text$mn:00007E10                 assume cs:_text$mn
.text$mn:00007E10                 ;org 7E10h
.text$mn:00007E10 ; COMDAT (pick any)
.text$mn:00007E10                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text$mn:00007E10
.text$mn:00007E10 ; =============== S U B R O U T I N E =======================================
.text$mn:00007E10
.text$mn:00007E10 ; Attributes: bp-based frame
.text$mn:00007E10
.text$mn:00007E10 ; public: char & __thiscall std::vector<char, class std::allocator<char>>::operator[](unsigned int)
.text$mn:00007E10                 public ??A?$vector@DV?$allocator@D@std@@@std@@QAEAADI@Z
.text$mn:00007E10 ??A?$vector@DV?$allocator@D@std@@@std@@QAEAADI@Z proc near
.text$mn:00007E10                                         ; CODE XREF: wstring2string(std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>> const &,uint)+74p
.text$mn:00007E10                                         ; wstring2string(std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>> const &,uint)+96p
.text$mn:00007E10
.text$mn:00007E10 var_4           = dword ptr -4
.text$mn:00007E10 arg_0           = dword ptr  8
.text$mn:00007E10
.text$mn:00007E10                 push    ebp
.text$mn:00007E11                 mov     ebp, esp
.text$mn:00007E13                 push    ecx
.text$mn:00007E14                 mov     [ebp+var_4], ecx
.text$mn:00007E17                 mov     ecx, [ebp+var_4]
.text$mn:00007E1A                 call    ?size@?$vector@DV?$allocator@D@std@@@std@@QBEIXZ ; std::vector<char,std::allocator<char>>::size(void)
.text$mn:00007E1F                 cmp     eax, [ebp+arg_0]
.text$mn:00007E22                 ja      short loc_7E8C
.text$mn:00007E24                 push    4B1h            ; unsigned int
.text$mn:00007E29                 push    offset ??_C@_1IM@EINEHPHE@?$AAC?$AA?3?$AA?2?$AAP?$AAr?$AAo?$AAg?$AAr?$AAa?$AAm?$AA?5?$AAF?$AAi?$AAl?$AAe?$AAs?$AA?5?$AA?$CI?$AAx?$AA8?$AA6?$AA?$CJ?$AA?2?$AAM?$AAi?$AAc?$AAr?$AAo?$AAs?$AAo?$AAf?$AAt@ ; "C:\\Program Files (x86)\\Microsoft Visu"...
.text$mn:00007E2E                 push    offset ??_C@_1DM@LHGCHCBA@?$AAv?$AAe?$AAc?$AAt?$AAo?$AAr?$AA?5?$AAs?$AAu?$AAb?$AAs?$AAc?$AAr?$AAi?$AAp?$AAt?$AA?5?$AAo?$AAu?$AAt?$AA?5?$AAo?$AAf?$AA?5?$AAr?$AAa?$AAn?$AAg?$AAe?$AA?$AA@ ; "vector subscript out of range"
.text$mn:00007E33                 call    ?_Debug_message@std@@YAXPB_W0I@Z ; std::_Debug_message(wchar_t const *,wchar_t const *,uint)
.text$mn:00007E38                 add     esp, 0Ch
.text$mn:00007E3B                 mov     eax, offset ??_C@_0CE@OFMIGAMM@Standard?5C?$CL?$CL?5Libraries?5Out?5of?5Ra@ ; "Standard C++ Libraries Out of Range"
.text$mn:00007E40                 test    eax, eax
.text$mn:00007E42                 jz      short loc_7E48
.text$mn:00007E44                 xor     ecx, ecx
.text$mn:00007E46                 jnz     short loc_7E6E
.text$mn:00007E48
.text$mn:00007E48 loc_7E48:                               ; CODE XREF: std::vector<char,std::allocator<char>>::operator[](uint)+32j
.text$mn:00007E48                 push    offset ??_C@_1FG@IBPIFFN@?$AA?$CC?$AAS?$AAt?$AAa?$AAn?$AAd?$AAa?$AAr?$AAd?$AA?5?$AAC?$AA?$CL?$AA?$CL?$AA?5?$AAL?$AAi?$AAb?$AAr?$AAa?$AAr?$AAi?$AAe?$AAs?$AA?5?$AAO?$AAu?$AAt?$AA?5?$AAo?$AAf?$AA?5?$AAR@ ; "\"Standard C++ Libraries Out of Range\""...
.text$mn:00007E4D                 push    offset ??_C@_15GANGMFKL@?$AA?$CF?$AAs?$AA?$AA@ ; "%s"
.text$mn:00007E52                 push    0
.text$mn:00007E54                 push    4B2h
.text$mn:00007E59                 push    offset ??_C@_1IM@EINEHPHE@?$AAC?$AA?3?$AA?2?$AAP?$AAr?$AAo?$AAg?$AAr?$AAa?$AAm?$AA?5?$AAF?$AAi?$AAl?$AAe?$AAs?$AA?5?$AA?$CI?$AAx?$AA8?$AA6?$AA?$CJ?$AA?2?$AAM?$AAi?$AAc?$AAr?$AAo?$AAs?$AAo?$AAf?$AAt@ ; "C:\\Program Files (x86)\\Microsoft Visu"...
.text$mn:00007E5E                 push    2
.text$mn:00007E60                 call    __CrtDbgReportW
.text$mn:00007E65                 add     esp, 18h
.text$mn:00007E68                 cmp     eax, 1
.text$mn:00007E6B                 jnz     short loc_7E6E
.text$mn:00007E6D                 int     3               ; Trap to Debugger
.text$mn:00007E6E
.text$mn:00007E6E loc_7E6E:                               ; CODE XREF: std::vector<char,std::allocator<char>>::operator[](uint)+36j
.text$mn:00007E6E                                         ; std::vector<char,std::allocator<char>>::operator[](uint)+5Bj
.text$mn:00007E6E                 push    0
.text$mn:00007E70                 push    4B2h
.text$mn:00007E75                 push    offset ??_C@_1IM@EINEHPHE@?$AAC?$AA?3?$AA?2?$AAP?$AAr?$AAo?$AAg?$AAr?$AAa?$AAm?$AA?5?$AAF?$AAi?$AAl?$AAe?$AAs?$AA?5?$AA?$CI?$AAx?$AA8?$AA6?$AA?$CJ?$AA?2?$AAM?$AAi?$AAc?$AAr?$AAo?$AAs?$AAo?$AAf?$AAt@ ; "C:\\Program Files (x86)\\Microsoft Visu"...
.text$mn:00007E7A                 push    offset ??_C@_1HG@EBINAPHK@?$AAs?$AAt?$AAd?$AA?3?$AA?3?$AAv?$AAe?$AAc?$AAt?$AAo?$AAr?$AA?$DM?$AAc?$AAh?$AAa?$AAr?$AA?0?$AAc?$AAl?$AAa?$AAs?$AAs?$AA?5?$AAs?$AAt?$AAd?$AA?3?$AA?3?$AAa?$AAl?$AAl?$AAo@ ; "std::vector<char,class std::allocator<c"...
.text$mn:00007E7F                 push    offset ??_C@_1BO@MEPPHOO@?$AA?$CC?$AAo?$AAu?$AAt?$AA?5?$AAo?$AAf?$AA?5?$AAr?$AAa?$AAn?$AAg?$AAe?$AA?$CC?$AA?$AA@ ; "\"out of range\""
.text$mn:00007E84                 call    __invalid_parameter
.text$mn:00007E89                 add     esp, 14h
.text$mn:00007E8C
.text$mn:00007E8C loc_7E8C:                               ; CODE XREF: std::vector<char,std::allocator<char>>::operator[](uint)+12j
.text$mn:00007E8C                 mov     eax, [ebp+var_4]
.text$mn:00007E8F                 mov     eax, [eax+4]
.text$mn:00007E92                 add     eax, [ebp+arg_0]
.text$mn:00007E95                 mov     esp, ebp
.text$mn:00007E97                 pop     ebp
.text$mn:00007E98                 retn    4
.text$mn:00007E98 ??A?$vector@DV?$allocator@D@std@@@std@@QAEAADI@Z endp
.text$mn:00007E98
.text$mn:00007E98 ; ---------------------------------------------------------------------------
.text$mn:00007E9B                 align 4
.text$mn:00007E9B _text$mn        ends
.text$mn:00007E9B
.text$mn:00007E9C ; ===========================================================================
.text$mn:00007E9C
.text$mn:00007E9C ; Segment type: Pure code
.text$mn:00007E9C ; Segment permissions: Read/Execute
.text$mn:00007E9C _text$mn        segment para public 'CODE' use32
.text$mn:00007E9C                 assume cs:_text$mn
.text$mn:00007E9C                 ;org 7E9Ch
.text$mn:00007E9C ; COMDAT (pick any)
.text$mn:00007E9C                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text$mn:00007E9C
.text$mn:00007E9C ; =============== S U B R O U T I N E =======================================
.text$mn:00007E9C
.text$mn:00007E9C ; Attributes: bp-based frame
.text$mn:00007E9C
.text$mn:00007E9C ; public: wchar_t & __thiscall std::vector<wchar_t, class std::allocator<wchar_t>>::operator[](unsigned int)
.text$mn:00007E9C                 public ??A?$vector@_WV?$allocator@_W@std@@@std@@QAEAA_WI@Z
.text$mn:00007E9C ??A?$vector@_WV?$allocator@_W@std@@@std@@QAEAA_WI@Z proc near
.text$mn:00007E9C                                         ; CODE XREF: string2wstring(std::basic_string<char,std::char_traits<char>,std::allocator<char>> const &,uint)+6Cp
.text$mn:00007E9C                                         ; string2wstring(std::basic_string<char,std::char_traits<char>,std::allocator<char>> const &,uint)+8Ep ...
.text$mn:00007E9C
.text$mn:00007E9C var_4           = dword ptr -4
.text$mn:00007E9C arg_0           = dword ptr  8
.text$mn:00007E9C
.text$mn:00007E9C                 push    ebp
.text$mn:00007E9D                 mov     ebp, esp
.text$mn:00007E9F                 push    ecx
.text$mn:00007EA0                 mov     [ebp+var_4], ecx
.text$mn:00007EA3                 mov     ecx, [ebp+var_4]
.text$mn:00007EA6                 call    ?size@?$vector@_WV?$allocator@_W@std@@@std@@QBEIXZ ; std::vector<wchar_t,std::allocator<wchar_t>>::size(void)
.text$mn:00007EAB                 cmp     eax, [ebp+arg_0]
.text$mn:00007EAE                 ja      short loc_7F18
.text$mn:00007EB0                 push    4B1h            ; unsigned int
.text$mn:00007EB5                 push    offset ??_C@_1IM@EINEHPHE@?$AAC?$AA?3?$AA?2?$AAP?$AAr?$AAo?$AAg?$AAr?$AAa?$AAm?$AA?5?$AAF?$AAi?$AAl?$AAe?$AAs?$AA?5?$AA?$CI?$AAx?$AA8?$AA6?$AA?$CJ?$AA?2?$AAM?$AAi?$AAc?$AAr?$AAo?$AAs?$AAo?$AAf?$AAt@ ; "C:\\Program Files (x86)\\Microsoft Visu"...
.text$mn:00007EBA                 push    offset ??_C@_1DM@LHGCHCBA@?$AAv?$AAe?$AAc?$AAt?$AAo?$AAr?$AA?5?$AAs?$AAu?$AAb?$AAs?$AAc?$AAr?$AAi?$AAp?$AAt?$AA?5?$AAo?$AAu?$AAt?$AA?5?$AAo?$AAf?$AA?5?$AAr?$AAa?$AAn?$AAg?$AAe?$AA?$AA@ ; "vector subscript out of range"
.text$mn:00007EBF                 call    ?_Debug_message@std@@YAXPB_W0I@Z ; std::_Debug_message(wchar_t const *,wchar_t const *,uint)
.text$mn:00007EC4                 add     esp, 0Ch
.text$mn:00007EC7                 mov     eax, offset ??_C@_0CE@OFMIGAMM@Standard?5C?$CL?$CL?5Libraries?5Out?5of?5Ra@ ; "Standard C++ Libraries Out of Range"
.text$mn:00007ECC                 test    eax, eax
.text$mn:00007ECE                 jz      short loc_7ED4
.text$mn:00007ED0                 xor     ecx, ecx
.text$mn:00007ED2                 jnz     short loc_7EFA
.text$mn:00007ED4
.text$mn:00007ED4 loc_7ED4:                               ; CODE XREF: std::vector<wchar_t,std::allocator<wchar_t>>::operator[](uint)+32j
.text$mn:00007ED4                 push    offset ??_C@_1FG@IBPIFFN@?$AA?$CC?$AAS?$AAt?$AAa?$AAn?$AAd?$AAa?$AAr?$AAd?$AA?5?$AAC?$AA?$CL?$AA?$CL?$AA?5?$AAL?$AAi?$AAb?$AAr?$AAa?$AAr?$AAi?$AAe?$AAs?$AA?5?$AAO?$AAu?$AAt?$AA?5?$AAo?$AAf?$AA?5?$AAR@ ; "\"Standard C++ Libraries Out of Range\""...
.text$mn:00007ED9                 push    offset ??_C@_15GANGMFKL@?$AA?$CF?$AAs?$AA?$AA@ ; "%s"
.text$mn:00007EDE                 push    0
.text$mn:00007EE0                 push    4B2h
.text$mn:00007EE5                 push    offset ??_C@_1IM@EINEHPHE@?$AAC?$AA?3?$AA?2?$AAP?$AAr?$AAo?$AAg?$AAr?$AAa?$AAm?$AA?5?$AAF?$AAi?$AAl?$AAe?$AAs?$AA?5?$AA?$CI?$AAx?$AA8?$AA6?$AA?$CJ?$AA?2?$AAM?$AAi?$AAc?$AAr?$AAo?$AAs?$AAo?$AAf?$AAt@ ; "C:\\Program Files (x86)\\Microsoft Visu"...
.text$mn:00007EEA                 push    2
.text$mn:00007EEC                 call    __CrtDbgReportW
.text$mn:00007EF1                 add     esp, 18h
.text$mn:00007EF4                 cmp     eax, 1
.text$mn:00007EF7                 jnz     short loc_7EFA
.text$mn:00007EF9                 int     3               ; Trap to Debugger
.text$mn:00007EFA
.text$mn:00007EFA loc_7EFA:                               ; CODE XREF: std::vector<wchar_t,std::allocator<wchar_t>>::operator[](uint)+36j
.text$mn:00007EFA                                         ; std::vector<wchar_t,std::allocator<wchar_t>>::operator[](uint)+5Bj
.text$mn:00007EFA                 push    0
.text$mn:00007EFC                 push    4B2h
.text$mn:00007F01                 push    offset ??_C@_1IM@EINEHPHE@?$AAC?$AA?3?$AA?2?$AAP?$AAr?$AAo?$AAg?$AAr?$AAa?$AAm?$AA?5?$AAF?$AAi?$AAl?$AAe?$AAs?$AA?5?$AA?$CI?$AAx?$AA8?$AA6?$AA?$CJ?$AA?2?$AAM?$AAi?$AAc?$AAr?$AAo?$AAs?$AAo?$AAf?$AAt@ ; "C:\\Program Files (x86)\\Microsoft Visu"...
.text$mn:00007F06                 push    offset ??_C@_1IC@MBIJKJB@?$AAs?$AAt?$AAd?$AA?3?$AA?3?$AAv?$AAe?$AAc?$AAt?$AAo?$AAr?$AA?$DM?$AAw?$AAc?$AAh?$AAa?$AAr?$AA_?$AAt?$AA?0?$AAc?$AAl?$AAa?$AAs?$AAs?$AA?5?$AAs?$AAt?$AAd?$AA?3?$AA?3?$AAa@ ; "std::vector<wchar_t,class std::allocato"...
.text$mn:00007F0B                 push    offset ??_C@_1BO@MEPPHOO@?$AA?$CC?$AAo?$AAu?$AAt?$AA?5?$AAo?$AAf?$AA?5?$AAr?$AAa?$AAn?$AAg?$AAe?$AA?$CC?$AA?$AA@ ; "\"out of range\""
.text$mn:00007F10                 call    __invalid_parameter
.text$mn:00007F15                 add     esp, 14h
.text$mn:00007F18
.text$mn:00007F18 loc_7F18:                               ; CODE XREF: std::vector<wchar_t,std::allocator<wchar_t>>::operator[](uint)+12j
.text$mn:00007F18                 mov     eax, [ebp+var_4]
.text$mn:00007F1B                 mov     ecx, [eax+4]
.text$mn:00007F1E                 mov     edx, [ebp+arg_0]
.text$mn:00007F21                 lea     eax, [ecx+edx*2]
.text$mn:00007F24                 mov     esp, ebp
.text$mn:00007F26                 pop     ebp
.text$mn:00007F27                 retn    4
.text$mn:00007F27 ??A?$vector@_WV?$allocator@_W@std@@@std@@QAEAA_WI@Z endp
.text$mn:00007F27
.text$mn:00007F27 ; ---------------------------------------------------------------------------
.text$mn:00007F2A                 align 4
.text$mn:00007F2A _text$mn        ends
.text$mn:00007F2A
.text$mn:00007F2C ; ===========================================================================
.text$mn:00007F2C
.text$mn:00007F2C ; Segment type: Pure code
.text$mn:00007F2C ; Segment permissions: Read/Execute
.text$mn:00007F2C _text$mn        segment para public 'CODE' use32
.text$mn:00007F2C                 assume cs:_text$mn
.text$mn:00007F2C                 ;org 7F2Ch
.text$mn:00007F2C ; COMDAT (pick any)
.text$mn:00007F2C                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text$mn:00007F2C
.text$mn:00007F2C ; =============== S U B R O U T I N E =======================================
.text$mn:00007F2C
.text$mn:00007F2C ; Attributes: bp-based frame
.text$mn:00007F2C
.text$mn:00007F2C ; public: __thiscall WcharMbcsConvertor::StringBuffer<char>::operator char *(void)
.text$mn:00007F2C                 public ??B?$StringBuffer@D@WcharMbcsConvertor@@QAEPADXZ
.text$mn:00007F2C ??B?$StringBuffer@D@WcharMbcsConvertor@@QAEPADXZ proc near
.text$mn:00007F2C                                         ; CODE XREF: WcharMbcsConvertor::wchar2char(wchar_t const *,uint,int,int *)+4Fp
.text$mn:00007F2C                                         ; WcharMbcsConvertor::wchar2char(wchar_t const *,uint,int,int *)+84p ...
.text$mn:00007F2C
.text$mn:00007F2C var_4           = dword ptr -4
.text$mn:00007F2C
.text$mn:00007F2C                 push    ebp
.text$mn:00007F2D                 mov     ebp, esp
.text$mn:00007F2F                 push    ecx
.text$mn:00007F30                 mov     [ebp+var_4], ecx
.text$mn:00007F33                 mov     eax, [ebp+var_4]
.text$mn:00007F36                 mov     eax, [eax+4]
.text$mn:00007F39                 mov     esp, ebp
.text$mn:00007F3B                 pop     ebp
.text$mn:00007F3C                 retn
.text$mn:00007F3C ??B?$StringBuffer@D@WcharMbcsConvertor@@QAEPADXZ endp
.text$mn:00007F3C
.text$mn:00007F3C ; ---------------------------------------------------------------------------
.text$mn:00007F3D                 align 10h
.text$mn:00007F3D _text$mn        ends
.text$mn:00007F3D
.text$mn:00007F40 ; ===========================================================================
.text$mn:00007F40
.text$mn:00007F40 ; Segment type: Pure code
.text$mn:00007F40 ; Segment permissions: Read/Execute
.text$mn:00007F40 _text$mn        segment para public 'CODE' use32
.text$mn:00007F40                 assume cs:_text$mn
.text$mn:00007F40                 ;org 7F40h
.text$mn:00007F40 ; COMDAT (pick any)
.text$mn:00007F40                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text$mn:00007F40
.text$mn:00007F40 ; =============== S U B R O U T I N E =======================================
.text$mn:00007F40
.text$mn:00007F40 ; Attributes: bp-based frame
.text$mn:00007F40
.text$mn:00007F40 ; public: __thiscall WcharMbcsConvertor::StringBuffer<wchar_t>::operator wchar_t *(void)
.text$mn:00007F40                 public ??B?$StringBuffer@_W@WcharMbcsConvertor@@QAEPA_WXZ
.text$mn:00007F40 ??B?$StringBuffer@_W@WcharMbcsConvertor@@QAEPA_WXZ proc near
.text$mn:00007F40                                         ; CODE XREF: WcharMbcsConvertor::char2wchar(char const *,uint,int,int *,int *)+46p
.text$mn:00007F40                                         ; WcharMbcsConvertor::char2wchar(char const *,uint,int,int *,int *)+1ABp ...
.text$mn:00007F40
.text$mn:00007F40 var_4           = dword ptr -4
.text$mn:00007F40
.text$mn:00007F40                 push    ebp
.text$mn:00007F41                 mov     ebp, esp
.text$mn:00007F43                 push    ecx
.text$mn:00007F44                 mov     [ebp+var_4], ecx
.text$mn:00007F47                 mov     eax, [ebp+var_4]
.text$mn:00007F4A                 mov     eax, [eax+4]
.text$mn:00007F4D                 mov     esp, ebp
.text$mn:00007F4F                 pop     ebp
.text$mn:00007F50                 retn
.text$mn:00007F50 ??B?$StringBuffer@_W@WcharMbcsConvertor@@QAEPA_WXZ endp
.text$mn:00007F50
.text$mn:00007F50 ; ---------------------------------------------------------------------------
.text$mn:00007F51                 align 4
.text$mn:00007F51 _text$mn        ends
.text$mn:00007F51
.text$mn:00007F54 ; ===========================================================================
.text$mn:00007F54
.text$mn:00007F54 ; Segment type: Pure code
.text$mn:00007F54 ; Segment permissions: Read/Execute
.text$mn:00007F54 _text$mn        segment para public 'CODE' use32
.text$mn:00007F54                 assume cs:_text$mn
.text$mn:00007F54                 ;org 7F54h
.text$mn:00007F54 ; COMDAT (pick any)
.text$mn:00007F54                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text$mn:00007F54
.text$mn:00007F54 ; =============== S U B R O U T I N E =======================================
.text$mn:00007F54
.text$mn:00007F54 ; Attributes: bp-based frame
.text$mn:00007F54
.text$mn:00007F54 ; public: wchar_t & __thiscall std::_Revranit<class std::_Vector_iterator<class std::_Vector_val<struct std::_Simple_types<wchar_t>>>, struct std::iterator<struct std::random_access_iterator_tag, wchar_t, int, wchar_t *, wchar_t &>>::operator*(void)const
.text$mn:00007F54                 public ??D?$_Revranit@V?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@_W@std@@@std@@@std@@U?$iterator@Urandom_access_iterator_tag@std@@_WHPA_WAA_W@2@@std@@QBEAA_WXZ
.text$mn:00007F54 ??D?$_Revranit@V?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@_W@std@@@std@@@std@@U?$iterator@Urandom_access_iterator_tag@std@@_WHPA_WAA_W@2@@std@@QBEAA_WXZ proc near
.text$mn:00007F54                                         ; CODE XREF: std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>>::_Construct<std::reverse_iterator<std::_Vector_iterator<std::_Vector_val<std::_Simple_types<wchar_t>>>>>(std::reverse_iterator<std::_Vector_iterator<std::_Vector_val<std::_Simple_types<wchar_t>>>>,std::reverse_iterator<std::_Vector_iterator<std::_Vector_val<std::_Simple_types<wchar_t>>>>,std::forward_iterator_tag)+10Fp
.text$mn:00007F54
.text$mn:00007F54 var_20          = byte ptr -20h
.text$mn:00007F54 var_14          = dword ptr -14h
.text$mn:00007F54 var_10          = dword ptr -10h
.text$mn:00007F54 var_C           = dword ptr -0Ch
.text$mn:00007F54 var_4           = dword ptr -4
.text$mn:00007F54
.text$mn:00007F54                 push    ebp
.text$mn:00007F55                 mov     ebp, esp
.text$mn:00007F57                 push    0FFFFFFFFh
.text$mn:00007F59                 push    offset __ehhandler$??D?$_Revranit@V?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@_W@std@@@std@@@std@@U?$iterator@Urandom_access_iterator_tag@std@@_WHPA_WAA_W@2@@std@@QBEAA_WXZ
.text$mn:00007F5E                 mov     eax, large fs:0
.text$mn:00007F64                 push    eax
.text$mn:00007F65                 sub     esp, 14h
.text$mn:00007F68                 mov     eax, dword ptr ds:___security_cookie
.text$mn:00007F6D                 xor     eax, ebp
.text$mn:00007F6F                 push    eax
.text$mn:00007F70                 lea     eax, [ebp+var_C]
.text$mn:00007F73                 mov     large fs:0, eax
.text$mn:00007F79                 mov     [ebp+var_10], ecx
.text$mn:00007F7C                 mov     eax, [ebp+var_10]
.text$mn:00007F7F                 push    eax             ; struct std::_Iterator_base12 *
.text$mn:00007F80                 lea     ecx, [ebp+var_20]
.text$mn:00007F83                 call    ??0?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@_W@std@@@std@@@std@@QAE@ABV01@@Z ; std::_Vector_iterator<std::_Vector_val<std::_Simple_types<wchar_t>>>::_Vector_iterator<std::_Vector_val<std::_Simple_types<wchar_t>>>(std::_Vector_iterator<std::_Vector_val<std::_Simple_types<wchar_t>>> const &)
.text$mn:00007F88                 mov     [ebp+var_4], 0
.text$mn:00007F8F                 lea     ecx, [ebp+var_20]
.text$mn:00007F92                 call    ??F?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@_W@std@@@std@@@std@@QAEAAV01@XZ ; std::_Vector_iterator<std::_Vector_val<std::_Simple_types<wchar_t>>>::operator--(void)
.text$mn:00007F97                 mov     ecx, eax
.text$mn:00007F99                 call    ??D?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@_W@std@@@std@@@std@@QBEAA_WXZ ; std::_Vector_iterator<std::_Vector_val<std::_Simple_types<wchar_t>>>::operator*(void)
.text$mn:00007F9E                 mov     [ebp+var_14], eax
.text$mn:00007FA1                 mov     [ebp+var_4], 0FFFFFFFFh
.text$mn:00007FA8                 lea     ecx, [ebp+var_20]
.text$mn:00007FAB                 call    ??1?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@_W@std@@@std@@@std@@QAE@XZ ; std::_Vector_iterator<std::_Vector_val<std::_Simple_types<wchar_t>>>::~_Vector_iterator<std::_Vector_val<std::_Simple_types<wchar_t>>>(void)
.text$mn:00007FB0                 mov     eax, [ebp+var_14]
.text$mn:00007FB3                 mov     ecx, [ebp+var_C]
.text$mn:00007FB6                 mov     large fs:0, ecx
.text$mn:00007FBD                 pop     ecx
.text$mn:00007FBE                 mov     esp, ebp
.text$mn:00007FC0                 pop     ebp
.text$mn:00007FC1                 retn
.text$mn:00007FC1 ??D?$_Revranit@V?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@_W@std@@@std@@@std@@U?$iterator@Urandom_access_iterator_tag@std@@_WHPA_WAA_W@2@@std@@QBEAA_WXZ endp
.text$mn:00007FC1
.text$mn:00007FC1 ; ---------------------------------------------------------------------------
.text$mn:00007FC2                 align 4
.text$mn:00007FC2 _text$mn        ends
.text$mn:00007FC2
.text$x:00007FC4 ; ===========================================================================
.text$x:00007FC4
.text$x:00007FC4 ; Segment type: Pure code
.text$x:00007FC4 ; Segment permissions: Read/Execute
.text$x:00007FC4 _text$x         segment para public 'CODE' use32
.text$x:00007FC4                 assume cs:_text$x
.text$x:00007FC4                 ;org 7FC4h
.text$x:00007FC4 ; COMDAT (pick associative to section at 7F54)
.text$x:00007FC4                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text$x:00007FC4
.text$x:00007FC4 ; =============== S U B R O U T I N E =======================================
.text$x:00007FC4
.text$x:00007FC4
.text$x:00007FC4 __unwindfunclet$??D?$_Revranit@V?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@_W@std@@@std@@@std@@U?$iterator@Urandom_access_iterator_tag@std@@_WHPA_WAA_W@2@@std@@QBEAA_WXZ$0 proc near
.text$x:00007FC4                                         ; DATA XREF: .xdata$x:0000E9D4o
.text$x:00007FC4                 lea     ecx, [ebp-20h]
.text$x:00007FC7                 jmp     ??1?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@_W@std@@@std@@@std@@QAE@XZ ; std::_Vector_iterator<std::_Vector_val<std::_Simple_types<wchar_t>>>::~_Vector_iterator<std::_Vector_val<std::_Simple_types<wchar_t>>>(void)
.text$x:00007FC7 __unwindfunclet$??D?$_Revranit@V?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@_W@std@@@std@@@std@@U?$iterator@Urandom_access_iterator_tag@std@@_WHPA_WAA_W@2@@std@@QBEAA_WXZ$0 endp
.text$x:00007FC7
.text$x:00007FCC
.text$x:00007FCC ; =============== S U B R O U T I N E =======================================
.text$x:00007FCC
.text$x:00007FCC
.text$x:00007FCC __ehhandler$??D?$_Revranit@V?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@_W@std@@@std@@@std@@U?$iterator@Urandom_access_iterator_tag@std@@_WHPA_WAA_W@2@@std@@QBEAA_WXZ proc near
.text$x:00007FCC                                         ; DATA XREF: std::_Revranit<std::_Vector_iterator<std::_Vector_val<std::_Simple_types<wchar_t>>>,std::iterator<std::random_access_iterator_tag,wchar_t,int,wchar_t *,wchar_t &>>::operator*(void)+5o
.text$x:00007FCC
.text$x:00007FCC arg_4           = dword ptr  8
.text$x:00007FCC
.text$x:00007FCC                 mov     edx, [esp+arg_4]
.text$x:00007FD0                 lea     eax, [edx+0Ch]
.text$x:00007FD3                 mov     ecx, [edx-18h]
.text$x:00007FD6                 xor     ecx, eax
.text$x:00007FD8                 call    @__security_check_cookie@4 ; __security_check_cookie(x)
.text$x:00007FDD                 mov     eax, offset __ehfuncinfo$??D?$_Revranit@V?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@_W@std@@@std@@@std@@U?$iterator@Urandom_access_iterator_tag@std@@_WHPA_WAA_W@2@@std@@QBEAA_WXZ
.text$x:00007FE2                 jmp     ___CxxFrameHandler3
.text$x:00007FE2 __ehhandler$??D?$_Revranit@V?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@_W@std@@@std@@@std@@U?$iterator@Urandom_access_iterator_tag@std@@_WHPA_WAA_W@2@@std@@QBEAA_WXZ endp
.text$x:00007FE2
.text$x:00007FE2 ; ---------------------------------------------------------------------------
.text$x:00007FE7                 align 4
.text$x:00007FE7 _text$x         ends
.text$x:00007FE7
.text$mn:00007FE8 ; ===========================================================================
.text$mn:00007FE8
.text$mn:00007FE8 ; Segment type: Pure code
.text$mn:00007FE8 ; Segment permissions: Read/Execute
.text$mn:00007FE8 _text$mn        segment para public 'CODE' use32
.text$mn:00007FE8                 assume cs:_text$mn
.text$mn:00007FE8                 ;org 7FE8h
.text$mn:00007FE8 ; COMDAT (pick any)
.text$mn:00007FE8                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text$mn:00007FE8
.text$mn:00007FE8 ; =============== S U B R O U T I N E =======================================
.text$mn:00007FE8
.text$mn:00007FE8 ; Attributes: bp-based frame
.text$mn:00007FE8
.text$mn:00007FE8 ; public: wchar_t const & __thiscall std::_String_const_iterator<class std::_String_val<struct std::_Simple_types<wchar_t>>>::operator*(void)const
.text$mn:00007FE8                 public ??D?$_String_const_iterator@V?$_String_val@U?$_Simple_types@_W@std@@@std@@@std@@QBEAB_WXZ
.text$mn:00007FE8 ??D?$_String_const_iterator@V?$_String_val@U?$_Simple_types@_W@std@@@std@@@std@@QBEAB_WXZ proc near
.text$mn:00007FE8                                         ; CODE XREF: convertFileName<std::_String_const_iterator<std::_String_val<std::_Simple_types<wchar_t>>>>(std::_String_const_iterator<std::_String_val<std::_Simple_types<wchar_t>>>,std::_String_const_iterator<std::_String_val<std::_Simple_types<wchar_t>>>)+72p
.text$mn:00007FE8                                         ; convertFileName<std::_String_const_iterator<std::_String_val<std::_Simple_types<wchar_t>>>>(std::_String_const_iterator<std::_String_val<std::_Simple_types<wchar_t>>>,std::_String_const_iterator<std::_String_val<std::_Simple_types<wchar_t>>>)+8Cp
.text$mn:00007FE8
.text$mn:00007FE8 var_4           = dword ptr -4
.text$mn:00007FE8
.text$mn:00007FE8                 push    ebp
.text$mn:00007FE9                 mov     ebp, esp
.text$mn:00007FEB                 push    ecx
.text$mn:00007FEC                 push    esi
.text$mn:00007FED                 mov     [ebp+var_4], ecx
.text$mn:00007FF0                 mov     ecx, [ebp+var_4] ; this
.text$mn:00007FF3                 call    ?_Getcont@_Iterator_base12@std@@QBEPBU_Container_base12@2@XZ ; std::_Iterator_base12::_Getcont(void)
.text$mn:00007FF8                 test    eax, eax
.text$mn:00007FFA                 jz      short loc_8043
.text$mn:00007FFC                 mov     eax, [ebp+var_4]
.text$mn:00007FFF                 cmp     dword ptr [eax+8], 0
.text$mn:00008003                 jz      short loc_8043
.text$mn:00008005                 mov     ecx, [ebp+var_4] ; this
.text$mn:00008008                 call    ?_Getcont@_Iterator_base12@std@@QBEPBU_Container_base12@2@XZ ; std::_Iterator_base12::_Getcont(void)
.text$mn:0000800D                 mov     ecx, eax
.text$mn:0000800F                 call    ?_Myptr@?$_String_val@U?$_Simple_types@_W@std@@@std@@QAEPA_WXZ ; std::_String_val<std::_Simple_types<wchar_t>>::_Myptr(void)
.text$mn:00008014                 mov     ecx, [ebp+var_4]
.text$mn:00008017                 cmp     [ecx+8], eax
.text$mn:0000801A                 jb      short loc_8043
.text$mn:0000801C                 mov     ecx, [ebp+var_4] ; this
.text$mn:0000801F                 call    ?_Getcont@_Iterator_base12@std@@QBEPBU_Container_base12@2@XZ ; std::_Iterator_base12::_Getcont(void)
.text$mn:00008024                 mov     ecx, eax
.text$mn:00008026                 call    ?_Myptr@?$_String_val@U?$_Simple_types@_W@std@@@std@@QAEPA_WXZ ; std::_String_val<std::_Simple_types<wchar_t>>::_Myptr(void)
.text$mn:0000802B                 mov     esi, eax
.text$mn:0000802D                 mov     ecx, [ebp+var_4] ; this
.text$mn:00008030                 call    ?_Getcont@_Iterator_base12@std@@QBEPBU_Container_base12@2@XZ ; std::_Iterator_base12::_Getcont(void)
.text$mn:00008035                 mov     edx, [eax+14h]
.text$mn:00008038                 lea     eax, [esi+edx*2]
.text$mn:0000803B                 mov     ecx, [ebp+var_4]
.text$mn:0000803E                 cmp     eax, [ecx+8]
.text$mn:00008041                 ja      short loc_80A2
.text$mn:00008043
.text$mn:00008043 loc_8043:                               ; CODE XREF: std::_String_const_iterator<std::_String_val<std::_Simple_types<wchar_t>>>::operator*(void)+12j
.text$mn:00008043                                         ; std::_String_const_iterator<std::_String_val<std::_Simple_types<wchar_t>>>::operator*(void)+1Bj ...
.text$mn:00008043                 push    4Fh ; 'O'       ; unsigned int
.text$mn:00008045                 push    offset ??_C@_1IO@FEAPGJBD@?$AAC?$AA?3?$AA?2?$AAP?$AAr?$AAo?$AAg?$AAr?$AAa?$AAm?$AA?5?$AAF?$AAi?$AAl?$AAe?$AAs?$AA?5?$AA?$CI?$AAx?$AA8?$AA6?$AA?$CJ?$AA?2?$AAM?$AAi?$AAc?$AAr?$AAo?$AAs?$AAo?$AAf?$AAt@ ; "C:\\Program Files (x86)\\Microsoft Visu"...
.text$mn:0000804A                 push    offset ??_C@_1EG@CNCHLAOB@?$AAs?$AAt?$AAr?$AAi?$AAn?$AAg?$AA?5?$AAi?$AAt?$AAe?$AAr?$AAa?$AAt?$AAo?$AAr?$AA?5?$AAn?$AAo?$AAt?$AA?5?$AAd?$AAe?$AAr?$AAe?$AAf?$AAe?$AAr?$AAe?$AAn?$AAc?$AAa?$AAb@ ; "string iterator not dereferencable"
.text$mn:0000804F                 call    ?_Debug_message@std@@YAXPB_W0I@Z ; std::_Debug_message(wchar_t const *,wchar_t const *,uint)
.text$mn:00008054                 add     esp, 0Ch
.text$mn:00008057                 mov     edx, offset ??_C@_0CE@OFMIGAMM@Standard?5C?$CL?$CL?5Libraries?5Out?5of?5Ra@ ; "Standard C++ Libraries Out of Range"
.text$mn:0000805C                 test    edx, edx
.text$mn:0000805E                 jz      short loc_8064
.text$mn:00008060                 xor     eax, eax
.text$mn:00008062                 jnz     short loc_8087
.text$mn:00008064
.text$mn:00008064 loc_8064:                               ; CODE XREF: std::_String_const_iterator<std::_String_val<std::_Simple_types<wchar_t>>>::operator*(void)+76j
.text$mn:00008064                 push    offset ??_C@_1FG@IBPIFFN@?$AA?$CC?$AAS?$AAt?$AAa?$AAn?$AAd?$AAa?$AAr?$AAd?$AA?5?$AAC?$AA?$CL?$AA?$CL?$AA?5?$AAL?$AAi?$AAb?$AAr?$AAa?$AAr?$AAi?$AAe?$AAs?$AA?5?$AAO?$AAu?$AAt?$AA?5?$AAo?$AAf?$AA?5?$AAR@ ; "\"Standard C++ Libraries Out of Range\""...
.text$mn:00008069                 push    offset ??_C@_15GANGMFKL@?$AA?$CF?$AAs?$AA?$AA@ ; "%s"
.text$mn:0000806E                 push    0
.text$mn:00008070                 push    50h ; 'P'
.text$mn:00008072                 push    offset ??_C@_1IO@FEAPGJBD@?$AAC?$AA?3?$AA?2?$AAP?$AAr?$AAo?$AAg?$AAr?$AAa?$AAm?$AA?5?$AAF?$AAi?$AAl?$AAe?$AAs?$AA?5?$AA?$CI?$AAx?$AA8?$AA6?$AA?$CJ?$AA?2?$AAM?$AAi?$AAc?$AAr?$AAo?$AAs?$AAo?$AAf?$AAt@ ; "C:\\Program Files (x86)\\Microsoft Visu"...
.text$mn:00008077                 push    2
.text$mn:00008079                 call    __CrtDbgReportW
.text$mn:0000807E                 add     esp, 18h
.text$mn:00008081                 cmp     eax, 1
.text$mn:00008084                 jnz     short loc_8087
.text$mn:00008086                 int     3               ; Trap to Debugger
.text$mn:00008087
.text$mn:00008087 loc_8087:                               ; CODE XREF: std::_String_const_iterator<std::_String_val<std::_Simple_types<wchar_t>>>::operator*(void)+7Aj
.text$mn:00008087                                         ; std::_String_const_iterator<std::_String_val<std::_Simple_types<wchar_t>>>::operator*(void)+9Cj
.text$mn:00008087                 push    0
.text$mn:00008089                 push    50h ; 'P'
.text$mn:0000808B                 push    offset ??_C@_1IO@FEAPGJBD@?$AAC?$AA?3?$AA?2?$AAP?$AAr?$AAo?$AAg?$AAr?$AAa?$AAm?$AA?5?$AAF?$AAi?$AAl?$AAe?$AAs?$AA?5?$AA?$CI?$AAx?$AA8?$AA6?$AA?$CJ?$AA?2?$AAM?$AAi?$AAc?$AAr?$AAo?$AAs?$AAo?$AAf?$AAt@ ; "C:\\Program Files (x86)\\Microsoft Visu"...
.text$mn:00008090                 push    offset ??_C@_1MM@BFHGHMKD@?$AAs?$AAt?$AAd?$AA?3?$AA?3?$AA_?$AAS?$AAt?$AAr?$AAi?$AAn?$AAg?$AA_?$AAc?$AAo?$AAn?$AAs?$AAt?$AA_?$AAi?$AAt?$AAe?$AAr?$AAa?$AAt?$AAo?$AAr?$AA?$DM?$AAc?$AAl?$AAa?$AAs@ ; "std::_String_const_iterator<class std::"...
.text$mn:00008095                 push    offset ??_C@_1BO@MEPPHOO@?$AA?$CC?$AAo?$AAu?$AAt?$AA?5?$AAo?$AAf?$AA?5?$AAr?$AAa?$AAn?$AAg?$AAe?$AA?$CC?$AA?$AA@ ; "\"out of range\""
.text$mn:0000809A                 call    __invalid_parameter
.text$mn:0000809F                 add     esp, 14h
.text$mn:000080A2
.text$mn:000080A2 loc_80A2:                               ; CODE XREF: std::_String_const_iterator<std::_String_val<std::_Simple_types<wchar_t>>>::operator*(void)+59j
.text$mn:000080A2                 mov     edx, [ebp+var_4]
.text$mn:000080A5                 mov     eax, [edx+8]
.text$mn:000080A8                 pop     esi
.text$mn:000080A9                 mov     esp, ebp
.text$mn:000080AB                 pop     ebp
.text$mn:000080AC                 retn
.text$mn:000080AC ??D?$_String_const_iterator@V?$_String_val@U?$_Simple_types@_W@std@@@std@@@std@@QBEAB_WXZ endp
.text$mn:000080AC
.text$mn:000080AC ; ---------------------------------------------------------------------------
.text$mn:000080AD                 align 10h
.text$mn:000080AD _text$mn        ends
.text$mn:000080AD
.text$mn:000080B0 ; ===========================================================================
.text$mn:000080B0
.text$mn:000080B0 ; Segment type: Pure code
.text$mn:000080B0 ; Segment permissions: Read/Execute
.text$mn:000080B0 _text$mn        segment para public 'CODE' use32
.text$mn:000080B0                 assume cs:_text$mn
.text$mn:000080B0                 ;org 80B0h
.text$mn:000080B0 ; COMDAT (pick any)
.text$mn:000080B0                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text$mn:000080B0
.text$mn:000080B0 ; =============== S U B R O U T I N E =======================================
.text$mn:000080B0
.text$mn:000080B0 ; Attributes: bp-based frame
.text$mn:000080B0
.text$mn:000080B0 ; public: wchar_t const & __thiscall std::_Vector_const_iterator<class std::_Vector_val<struct std::_Simple_types<wchar_t>>>::operator*(void)const
.text$mn:000080B0                 public ??D?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@_W@std@@@std@@@std@@QBEAB_WXZ
.text$mn:000080B0 ??D?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@_W@std@@@std@@@std@@QBEAB_WXZ proc near
.text$mn:000080B0                                         ; CODE XREF: std::_Vector_iterator<std::_Vector_val<std::_Simple_types<wchar_t>>>::operator*(void)+Ap
.text$mn:000080B0
.text$mn:000080B0 var_4           = dword ptr -4
.text$mn:000080B0
.text$mn:000080B0                 push    ebp
.text$mn:000080B1                 mov     ebp, esp
.text$mn:000080B3                 push    ecx
.text$mn:000080B4                 mov     [ebp+var_4], ecx
.text$mn:000080B7                 mov     ecx, [ebp+var_4] ; this
.text$mn:000080BA                 call    ?_Getcont@_Iterator_base12@std@@QBEPBU_Container_base12@2@XZ ; std::_Iterator_base12::_Getcont(void)
.text$mn:000080BF                 test    eax, eax
.text$mn:000080C1                 jz      short loc_80F2
.text$mn:000080C3                 mov     eax, [ebp+var_4]
.text$mn:000080C6                 cmp     dword ptr [eax+8], 0
.text$mn:000080CA                 jz      short loc_80F2
.text$mn:000080CC                 mov     ecx, [ebp+var_4] ; this
.text$mn:000080CF                 call    ?_Getcont@_Iterator_base12@std@@QBEPBU_Container_base12@2@XZ ; std::_Iterator_base12::_Getcont(void)
.text$mn:000080D4                 mov     ecx, [ebp+var_4]
.text$mn:000080D7                 mov     edx, [ecx+8]
.text$mn:000080DA                 cmp     edx, [eax+4]
.text$mn:000080DD                 jb      short loc_80F2
.text$mn:000080DF                 mov     ecx, [ebp+var_4] ; this
.text$mn:000080E2                 call    ?_Getcont@_Iterator_base12@std@@QBEPBU_Container_base12@2@XZ ; std::_Iterator_base12::_Getcont(void)
.text$mn:000080E7                 mov     ecx, [ebp+var_4]
.text$mn:000080EA                 mov     edx, [eax+8]
.text$mn:000080ED                 cmp     edx, [ecx+8]
.text$mn:000080F0                 ja      short loc_8151
.text$mn:000080F2
.text$mn:000080F2 loc_80F2:                               ; CODE XREF: std::_Vector_const_iterator<std::_Vector_val<std::_Simple_types<wchar_t>>>::operator*(void)+11j
.text$mn:000080F2                                         ; std::_Vector_const_iterator<std::_Vector_val<std::_Simple_types<wchar_t>>>::operator*(void)+1Aj ...
.text$mn:000080F2                 push    48h ; 'H'       ; unsigned int
.text$mn:000080F4                 push    offset ??_C@_1IM@EINEHPHE@?$AAC?$AA?3?$AA?2?$AAP?$AAr?$AAo?$AAg?$AAr?$AAa?$AAm?$AA?5?$AAF?$AAi?$AAl?$AAe?$AAs?$AA?5?$AA?$CI?$AAx?$AA8?$AA6?$AA?$CJ?$AA?2?$AAM?$AAi?$AAc?$AAr?$AAo?$AAs?$AAo?$AAf?$AAt@ ; "C:\\Program Files (x86)\\Microsoft Visu"...
.text$mn:000080F9                 push    offset ??_C@_1EG@FOHJJHAC@?$AAv?$AAe?$AAc?$AAt?$AAo?$AAr?$AA?5?$AAi?$AAt?$AAe?$AAr?$AAa?$AAt?$AAo?$AAr?$AA?5?$AAn?$AAo?$AAt?$AA?5?$AAd?$AAe?$AAr?$AAe?$AAf?$AAe?$AAr?$AAe?$AAn?$AAc?$AAa?$AAb@ ; "vector iterator not dereferencable"
.text$mn:000080FE                 call    ?_Debug_message@std@@YAXPB_W0I@Z ; std::_Debug_message(wchar_t const *,wchar_t const *,uint)
.text$mn:00008103                 add     esp, 0Ch
.text$mn:00008106                 mov     eax, offset ??_C@_0CE@OFMIGAMM@Standard?5C?$CL?$CL?5Libraries?5Out?5of?5Ra@ ; "Standard C++ Libraries Out of Range"
.text$mn:0000810B                 test    eax, eax
.text$mn:0000810D                 jz      short loc_8113
.text$mn:0000810F                 xor     ecx, ecx
.text$mn:00008111                 jnz     short loc_8136
.text$mn:00008113
.text$mn:00008113 loc_8113:                               ; CODE XREF: std::_Vector_const_iterator<std::_Vector_val<std::_Simple_types<wchar_t>>>::operator*(void)+5Dj
.text$mn:00008113                 push    offset ??_C@_1FG@IBPIFFN@?$AA?$CC?$AAS?$AAt?$AAa?$AAn?$AAd?$AAa?$AAr?$AAd?$AA?5?$AAC?$AA?$CL?$AA?$CL?$AA?5?$AAL?$AAi?$AAb?$AAr?$AAa?$AAr?$AAi?$AAe?$AAs?$AA?5?$AAO?$AAu?$AAt?$AA?5?$AAo?$AAf?$AA?5?$AAR@ ; "\"Standard C++ Libraries Out of Range\""...
.text$mn:00008118                 push    offset ??_C@_15GANGMFKL@?$AA?$CF?$AAs?$AA?$AA@ ; "%s"
.text$mn:0000811D                 push    0
.text$mn:0000811F                 push    49h ; 'I'
.text$mn:00008121                 push    offset ??_C@_1IM@EINEHPHE@?$AAC?$AA?3?$AA?2?$AAP?$AAr?$AAo?$AAg?$AAr?$AAa?$AAm?$AA?5?$AAF?$AAi?$AAl?$AAe?$AAs?$AA?5?$AA?$CI?$AAx?$AA8?$AA6?$AA?$CJ?$AA?2?$AAM?$AAi?$AAc?$AAr?$AAo?$AAs?$AAo?$AAf?$AAt@ ; "C:\\Program Files (x86)\\Microsoft Visu"...
.text$mn:00008126                 push    2
.text$mn:00008128                 call    __CrtDbgReportW
.text$mn:0000812D                 add     esp, 18h
.text$mn:00008130                 cmp     eax, 1
.text$mn:00008133                 jnz     short loc_8136
.text$mn:00008135                 int     3               ; Trap to Debugger
.text$mn:00008136
.text$mn:00008136 loc_8136:                               ; CODE XREF: std::_Vector_const_iterator<std::_Vector_val<std::_Simple_types<wchar_t>>>::operator*(void)+61j
.text$mn:00008136                                         ; std::_Vector_const_iterator<std::_Vector_val<std::_Simple_types<wchar_t>>>::operator*(void)+83j
.text$mn:00008136                 push    0
.text$mn:00008138                 push    49h ; 'I'
.text$mn:0000813A                 push    offset ??_C@_1IM@EINEHPHE@?$AAC?$AA?3?$AA?2?$AAP?$AAr?$AAo?$AAg?$AAr?$AAa?$AAm?$AA?5?$AAF?$AAi?$AAl?$AAe?$AAs?$AA?5?$AA?$CI?$AAx?$AA8?$AA6?$AA?$CJ?$AA?2?$AAM?$AAi?$AAc?$AAr?$AAo?$AAs?$AAo?$AAf?$AAt@ ; "C:\\Program Files (x86)\\Microsoft Visu"...
.text$mn:0000813F                 push    offset ??_C@_1MM@BKDBGIKM@?$AAs?$AAt?$AAd?$AA?3?$AA?3?$AA_?$AAV?$AAe?$AAc?$AAt?$AAo?$AAr?$AA_?$AAc?$AAo?$AAn?$AAs?$AAt?$AA_?$AAi?$AAt?$AAe?$AAr?$AAa?$AAt?$AAo?$AAr?$AA?$DM?$AAc?$AAl?$AAa?$AAs@ ; "std::_Vector_const_iterator<class std::"...
.text$mn:00008144                 push    offset ??_C@_1BO@MEPPHOO@?$AA?$CC?$AAo?$AAu?$AAt?$AA?5?$AAo?$AAf?$AA?5?$AAr?$AAa?$AAn?$AAg?$AAe?$AA?$CC?$AA?$AA@ ; "\"out of range\""
.text$mn:00008149                 call    __invalid_parameter
.text$mn:0000814E                 add     esp, 14h
.text$mn:00008151
.text$mn:00008151 loc_8151:                               ; CODE XREF: std::_Vector_const_iterator<std::_Vector_val<std::_Simple_types<wchar_t>>>::operator*(void)+40j
.text$mn:00008151                 mov     eax, [ebp+var_4]
.text$mn:00008154                 mov     eax, [eax+8]
.text$mn:00008157                 mov     esp, ebp
.text$mn:00008159                 pop     ebp
.text$mn:0000815A                 retn
.text$mn:0000815A ??D?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@_W@std@@@std@@@std@@QBEAB_WXZ endp
.text$mn:0000815A
.text$mn:0000815A ; ---------------------------------------------------------------------------
.text$mn:0000815B                 align 4
.text$mn:0000815B _text$mn        ends
.text$mn:0000815B
.text$mn:0000815C ; ===========================================================================
.text$mn:0000815C
.text$mn:0000815C ; Segment type: Pure code
.text$mn:0000815C ; Segment permissions: Read/Execute
.text$mn:0000815C _text$mn        segment para public 'CODE' use32
.text$mn:0000815C                 assume cs:_text$mn
.text$mn:0000815C                 ;org 815Ch
.text$mn:0000815C ; COMDAT (pick any)
.text$mn:0000815C                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text$mn:0000815C
.text$mn:0000815C ; =============== S U B R O U T I N E =======================================
.text$mn:0000815C
.text$mn:0000815C ; Attributes: bp-based frame
.text$mn:0000815C
.text$mn:0000815C ; public: wchar_t & __thiscall std::_Vector_iterator<class std::_Vector_val<struct std::_Simple_types<wchar_t>>>::operator*(void)const
.text$mn:0000815C                 public ??D?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@_W@std@@@std@@@std@@QBEAA_WXZ
.text$mn:0000815C ??D?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@_W@std@@@std@@@std@@QBEAA_WXZ proc near
.text$mn:0000815C                                         ; CODE XREF: convertFileName<std::_Vector_iterator<std::_Vector_val<std::_Simple_types<wchar_t>>>>(std::_Vector_iterator<std::_Vector_val<std::_Simple_types<wchar_t>>>,std::_Vector_iterator<std::_Vector_val<std::_Simple_types<wchar_t>>>)+72p
.text$mn:0000815C                                         ; convertFileName<std::_Vector_iterator<std::_Vector_val<std::_Simple_types<wchar_t>>>>(std::_Vector_iterator<std::_Vector_val<std::_Simple_types<wchar_t>>>,std::_Vector_iterator<std::_Vector_val<std::_Simple_types<wchar_t>>>)+8Cp ...
.text$mn:0000815C
.text$mn:0000815C var_4           = dword ptr -4
.text$mn:0000815C
.text$mn:0000815C                 push    ebp
.text$mn:0000815D                 mov     ebp, esp
.text$mn:0000815F                 push    ecx
.text$mn:00008160                 mov     [ebp+var_4], ecx
.text$mn:00008163                 mov     ecx, [ebp+var_4]
.text$mn:00008166                 call    ??D?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@_W@std@@@std@@@std@@QBEAB_WXZ ; std::_Vector_const_iterator<std::_Vector_val<std::_Simple_types<wchar_t>>>::operator*(void)
.text$mn:0000816B                 mov     esp, ebp
.text$mn:0000816D                 pop     ebp
.text$mn:0000816E                 retn
.text$mn:0000816E ??D?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@_W@std@@@std@@@std@@QBEAA_WXZ endp
.text$mn:0000816E
.text$mn:0000816E ; ---------------------------------------------------------------------------
.text$mn:0000816F                 align 10h
.text$mn:0000816F _text$mn        ends
.text$mn:0000816F
.text$mn:00008170 ; ===========================================================================
.text$mn:00008170
.text$mn:00008170 ; Segment type: Pure code
.text$mn:00008170 ; Segment permissions: Read/Execute
.text$mn:00008170 _text$mn        segment para public 'CODE' use32
.text$mn:00008170                 assume cs:_text$mn
.text$mn:00008170                 ;org 8170h
.text$mn:00008170 ; COMDAT (pick any)
.text$mn:00008170                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text$mn:00008170
.text$mn:00008170 ; =============== S U B R O U T I N E =======================================
.text$mn:00008170
.text$mn:00008170 ; Attributes: bp-based frame
.text$mn:00008170
.text$mn:00008170 ; public: class std::_Revranit<class std::_Vector_iterator<class std::_Vector_val<struct std::_Simple_types<wchar_t>>>, struct std::iterator<struct std::random_access_iterator_tag, wchar_t, int, wchar_t *, wchar_t &>> & __thiscall std::_Revranit<class std::_Vector_iterator<class std::_Vector_val<struct std::_Simple_types<wchar_t>>>, struct std::iterator<struct std::random_access_iterator_tag, wchar_t, int, wchar_t *, wchar_t &>>::operator++(void)
.text$mn:00008170                 public ??E?$_Revranit@V?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@_W@std@@@std@@@std@@U?$iterator@Urandom_access_iterator_tag@std@@_WHPA_WAA_W@2@@std@@QAEAAV01@XZ
.text$mn:00008170 ??E?$_Revranit@V?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@_W@std@@@std@@@std@@U?$iterator@Urandom_access_iterator_tag@std@@_WHPA_WAA_W@2@@std@@QAEAAV01@XZ proc near
.text$mn:00008170                                         ; CODE XREF: std::reverse_iterator<std::_Vector_iterator<std::_Vector_val<std::_Simple_types<wchar_t>>>>::operator++(void)+Ap
.text$mn:00008170
.text$mn:00008170 var_4           = dword ptr -4
.text$mn:00008170
.text$mn:00008170                 push    ebp
.text$mn:00008171                 mov     ebp, esp
.text$mn:00008173                 push    ecx
.text$mn:00008174                 mov     [ebp+var_4], ecx
.text$mn:00008177                 mov     ecx, [ebp+var_4]
.text$mn:0000817A                 call    ??F?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@_W@std@@@std@@@std@@QAEAAV01@XZ ; std::_Vector_iterator<std::_Vector_val<std::_Simple_types<wchar_t>>>::operator--(void)
.text$mn:0000817F                 mov     eax, [ebp+var_4]
.text$mn:00008182                 mov     esp, ebp
.text$mn:00008184                 pop     ebp
.text$mn:00008185                 retn
.text$mn:00008185 ??E?$_Revranit@V?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@_W@std@@@std@@@std@@U?$iterator@Urandom_access_iterator_tag@std@@_WHPA_WAA_W@2@@std@@QAEAAV01@XZ endp
.text$mn:00008185
.text$mn:00008185 ; ---------------------------------------------------------------------------
.text$mn:00008186                 align 4
.text$mn:00008186 _text$mn        ends
.text$mn:00008186
.text$mn:00008188 ; ===========================================================================
.text$mn:00008188
.text$mn:00008188 ; Segment type: Pure code
.text$mn:00008188 ; Segment permissions: Read/Execute
.text$mn:00008188 _text$mn        segment para public 'CODE' use32
.text$mn:00008188                 assume cs:_text$mn
.text$mn:00008188                 ;org 8188h
.text$mn:00008188 ; COMDAT (pick any)
.text$mn:00008188                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text$mn:00008188
.text$mn:00008188 ; =============== S U B R O U T I N E =======================================
.text$mn:00008188
.text$mn:00008188 ; Attributes: bp-based frame
.text$mn:00008188
.text$mn:00008188 ; public: class std::_String_const_iterator<class std::_String_val<struct std::_Simple_types<wchar_t>>> & __thiscall std::_String_const_iterator<class std::_String_val<struct std::_Simple_types<wchar_t>>>::operator++(void)
.text$mn:00008188                 public ??E?$_String_const_iterator@V?$_String_val@U?$_Simple_types@_W@std@@@std@@@std@@QAEAAV01@XZ
.text$mn:00008188 ??E?$_String_const_iterator@V?$_String_val@U?$_Simple_types@_W@std@@@std@@@std@@QAEAAV01@XZ proc near
.text$mn:00008188                                         ; CODE XREF: convertFileName<std::_String_const_iterator<std::_String_val<std::_Simple_types<wchar_t>>>>(std::_String_const_iterator<std::_String_val<std::_Simple_types<wchar_t>>>,std::_String_const_iterator<std::_String_val<std::_Simple_types<wchar_t>>>)+57p
.text$mn:00008188
.text$mn:00008188 var_4           = dword ptr -4
.text$mn:00008188
.text$mn:00008188                 push    ebp
.text$mn:00008189                 mov     ebp, esp
.text$mn:0000818B                 push    ecx
.text$mn:0000818C                 push    esi
.text$mn:0000818D                 mov     [ebp+var_4], ecx
.text$mn:00008190                 mov     ecx, [ebp+var_4] ; this
.text$mn:00008193                 call    ?_Getcont@_Iterator_base12@std@@QBEPBU_Container_base12@2@XZ ; std::_Iterator_base12::_Getcont(void)
.text$mn:00008198                 test    eax, eax
.text$mn:0000819A                 jz      short loc_81CC
.text$mn:0000819C                 mov     eax, [ebp+var_4]
.text$mn:0000819F                 cmp     dword ptr [eax+8], 0
.text$mn:000081A3                 jz      short loc_81CC
.text$mn:000081A5                 mov     ecx, [ebp+var_4] ; this
.text$mn:000081A8                 call    ?_Getcont@_Iterator_base12@std@@QBEPBU_Container_base12@2@XZ ; std::_Iterator_base12::_Getcont(void)
.text$mn:000081AD                 mov     ecx, eax
.text$mn:000081AF                 call    ?_Myptr@?$_String_val@U?$_Simple_types@_W@std@@@std@@QAEPA_WXZ ; std::_String_val<std::_Simple_types<wchar_t>>::_Myptr(void)
.text$mn:000081B4                 mov     esi, eax
.text$mn:000081B6                 mov     ecx, [ebp+var_4] ; this
.text$mn:000081B9                 call    ?_Getcont@_Iterator_base12@std@@QBEPBU_Container_base12@2@XZ ; std::_Iterator_base12::_Getcont(void)
.text$mn:000081BE                 mov     ecx, [eax+14h]
.text$mn:000081C1                 lea     edx, [esi+ecx*2]
.text$mn:000081C4                 mov     eax, [ebp+var_4]
.text$mn:000081C7                 cmp     edx, [eax+8]
.text$mn:000081CA                 ja      short loc_822B
.text$mn:000081CC
.text$mn:000081CC loc_81CC:                               ; CODE XREF: std::_String_const_iterator<std::_String_val<std::_Simple_types<wchar_t>>>::operator++(void)+12j
.text$mn:000081CC                                         ; std::_String_const_iterator<std::_String_val<std::_Simple_types<wchar_t>>>::operator++(void)+1Bj
.text$mn:000081CC                 push    6Dh ; 'm'       ; unsigned int
.text$mn:000081CE                 push    offset ??_C@_1IO@FEAPGJBD@?$AAC?$AA?3?$AA?2?$AAP?$AAr?$AAo?$AAg?$AAr?$AAa?$AAm?$AA?5?$AAF?$AAi?$AAl?$AAe?$AAs?$AA?5?$AA?$CI?$AAx?$AA8?$AA6?$AA?$CJ?$AA?2?$AAM?$AAi?$AAc?$AAr?$AAo?$AAs?$AAo?$AAf?$AAt@ ; "C:\\Program Files (x86)\\Microsoft Visu"...
.text$mn:000081D3                 push    offset ??_C@_1EE@HAKOGNPH@?$AAs?$AAt?$AAr?$AAi?$AAn?$AAg?$AA?5?$AAi?$AAt?$AAe?$AAr?$AAa?$AAt?$AAo?$AAr?$AA?5?$AAn?$AAo?$AAt?$AA?5?$AAi?$AAn?$AAc?$AAr?$AAe?$AAm?$AAe?$AAn?$AAt?$AAa?$AAb?$AAl@ ; "string iterator not incrementable"
.text$mn:000081D8                 call    ?_Debug_message@std@@YAXPB_W0I@Z ; std::_Debug_message(wchar_t const *,wchar_t const *,uint)
.text$mn:000081DD                 add     esp, 0Ch
.text$mn:000081E0                 mov     ecx, offset ??_C@_0CE@OFMIGAMM@Standard?5C?$CL?$CL?5Libraries?5Out?5of?5Ra@ ; "Standard C++ Libraries Out of Range"
.text$mn:000081E5                 test    ecx, ecx
.text$mn:000081E7                 jz      short loc_81ED
.text$mn:000081E9                 xor     edx, edx
.text$mn:000081EB                 jnz     short loc_8210
.text$mn:000081ED
.text$mn:000081ED loc_81ED:                               ; CODE XREF: std::_String_const_iterator<std::_String_val<std::_Simple_types<wchar_t>>>::operator++(void)+5Fj
.text$mn:000081ED                 push    offset ??_C@_1FG@IBPIFFN@?$AA?$CC?$AAS?$AAt?$AAa?$AAn?$AAd?$AAa?$AAr?$AAd?$AA?5?$AAC?$AA?$CL?$AA?$CL?$AA?5?$AAL?$AAi?$AAb?$AAr?$AAa?$AAr?$AAi?$AAe?$AAs?$AA?5?$AAO?$AAu?$AAt?$AA?5?$AAo?$AAf?$AA?5?$AAR@ ; "\"Standard C++ Libraries Out of Range\""...
.text$mn:000081F2                 push    offset ??_C@_15GANGMFKL@?$AA?$CF?$AAs?$AA?$AA@ ; "%s"
.text$mn:000081F7                 push    0
.text$mn:000081F9                 push    6Eh ; 'n'
.text$mn:000081FB                 push    offset ??_C@_1IO@FEAPGJBD@?$AAC?$AA?3?$AA?2?$AAP?$AAr?$AAo?$AAg?$AAr?$AAa?$AAm?$AA?5?$AAF?$AAi?$AAl?$AAe?$AAs?$AA?5?$AA?$CI?$AAx?$AA8?$AA6?$AA?$CJ?$AA?2?$AAM?$AAi?$AAc?$AAr?$AAo?$AAs?$AAo?$AAf?$AAt@ ; "C:\\Program Files (x86)\\Microsoft Visu"...
.text$mn:00008200                 push    2
.text$mn:00008202                 call    __CrtDbgReportW
.text$mn:00008207                 add     esp, 18h
.text$mn:0000820A                 cmp     eax, 1
.text$mn:0000820D                 jnz     short loc_8210
.text$mn:0000820F                 int     3               ; Trap to Debugger
.text$mn:00008210
.text$mn:00008210 loc_8210:                               ; CODE XREF: std::_String_const_iterator<std::_String_val<std::_Simple_types<wchar_t>>>::operator++(void)+63j
.text$mn:00008210                                         ; std::_String_const_iterator<std::_String_val<std::_Simple_types<wchar_t>>>::operator++(void)+85j
.text$mn:00008210                 push    0
.text$mn:00008212                 push    6Eh ; 'n'
.text$mn:00008214                 push    offset ??_C@_1IO@FEAPGJBD@?$AAC?$AA?3?$AA?2?$AAP?$AAr?$AAo?$AAg?$AAr?$AAa?$AAm?$AA?5?$AAF?$AAi?$AAl?$AAe?$AAs?$AA?5?$AA?$CI?$AAx?$AA8?$AA6?$AA?$CJ?$AA?2?$AAM?$AAi?$AAc?$AAr?$AAo?$AAs?$AAo?$AAf?$AAt@ ; "C:\\Program Files (x86)\\Microsoft Visu"...
.text$mn:00008219                 push    offset ??_C@_1MO@GAPGDMNB@?$AAs?$AAt?$AAd?$AA?3?$AA?3?$AA_?$AAS?$AAt?$AAr?$AAi?$AAn?$AAg?$AA_?$AAc?$AAo?$AAn?$AAs?$AAt?$AA_?$AAi?$AAt?$AAe?$AAr?$AAa?$AAt?$AAo?$AAr?$AA?$DM?$AAc?$AAl?$AAa?$AAs@ ; "std::_String_const_iterator<class std::"...
.text$mn:0000821E                 push    offset ??_C@_1BO@MEPPHOO@?$AA?$CC?$AAo?$AAu?$AAt?$AA?5?$AAo?$AAf?$AA?5?$AAr?$AAa?$AAn?$AAg?$AAe?$AA?$CC?$AA?$AA@ ; "\"out of range\""
.text$mn:00008223                 call    __invalid_parameter
.text$mn:00008228                 add     esp, 14h
.text$mn:0000822B
.text$mn:0000822B loc_822B:                               ; CODE XREF: std::_String_const_iterator<std::_String_val<std::_Simple_types<wchar_t>>>::operator++(void)+42j
.text$mn:0000822B                 mov     ecx, [ebp+var_4]
.text$mn:0000822E                 mov     edx, [ecx+8]
.text$mn:00008231                 add     edx, 2
.text$mn:00008234                 mov     eax, [ebp+var_4]
.text$mn:00008237                 mov     [eax+8], edx
.text$mn:0000823A                 mov     eax, [ebp+var_4]
.text$mn:0000823D                 pop     esi
.text$mn:0000823E                 mov     esp, ebp
.text$mn:00008240                 pop     ebp
.text$mn:00008241                 retn
.text$mn:00008241 ??E?$_String_const_iterator@V?$_String_val@U?$_Simple_types@_W@std@@@std@@@std@@QAEAAV01@XZ endp
.text$mn:00008241
.text$mn:00008241 ; ---------------------------------------------------------------------------
.text$mn:00008242                 align 4
.text$mn:00008242 _text$mn        ends
.text$mn:00008242
.text$mn:00008244 ; ===========================================================================
.text$mn:00008244
.text$mn:00008244 ; Segment type: Pure code
.text$mn:00008244 ; Segment permissions: Read/Execute
.text$mn:00008244 _text$mn        segment para public 'CODE' use32
.text$mn:00008244                 assume cs:_text$mn
.text$mn:00008244                 ;org 8244h
.text$mn:00008244 ; COMDAT (pick any)
.text$mn:00008244                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text$mn:00008244
.text$mn:00008244 ; =============== S U B R O U T I N E =======================================
.text$mn:00008244
.text$mn:00008244 ; Attributes: bp-based frame
.text$mn:00008244
.text$mn:00008244 ; public: class std::_Vector_const_iterator<class std::_Vector_val<struct std::_Simple_types<wchar_t>>> & __thiscall std::_Vector_const_iterator<class std::_Vector_val<struct std::_Simple_types<wchar_t>>>::operator++(void)
.text$mn:00008244                 public ??E?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@_W@std@@@std@@@std@@QAEAAV01@XZ
.text$mn:00008244 ??E?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@_W@std@@@std@@@std@@QAEAAV01@XZ proc near
.text$mn:00008244                                         ; CODE XREF: std::_Vector_iterator<std::_Vector_val<std::_Simple_types<wchar_t>>>::operator++(void)+Ap
.text$mn:00008244
.text$mn:00008244 var_4           = dword ptr -4
.text$mn:00008244
.text$mn:00008244                 push    ebp
.text$mn:00008245                 mov     ebp, esp
.text$mn:00008247                 push    ecx
.text$mn:00008248                 mov     [ebp+var_4], ecx
.text$mn:0000824B                 mov     ecx, [ebp+var_4] ; this
.text$mn:0000824E                 call    ?_Getcont@_Iterator_base12@std@@QBEPBU_Container_base12@2@XZ ; std::_Iterator_base12::_Getcont(void)
.text$mn:00008253                 test    eax, eax
.text$mn:00008255                 jz      short loc_8273
.text$mn:00008257                 mov     eax, [ebp+var_4]
.text$mn:0000825A                 cmp     dword ptr [eax+8], 0
.text$mn:0000825E                 jz      short loc_8273
.text$mn:00008260                 mov     ecx, [ebp+var_4] ; this
.text$mn:00008263                 call    ?_Getcont@_Iterator_base12@std@@QBEPBU_Container_base12@2@XZ ; std::_Iterator_base12::_Getcont(void)
.text$mn:00008268                 mov     ecx, [ebp+var_4]
.text$mn:0000826B                 mov     edx, [eax+8]
.text$mn:0000826E                 cmp     edx, [ecx+8]
.text$mn:00008271                 ja      short loc_82D2
.text$mn:00008273
.text$mn:00008273 loc_8273:                               ; CODE XREF: std::_Vector_const_iterator<std::_Vector_val<std::_Simple_types<wchar_t>>>::operator++(void)+11j
.text$mn:00008273                                         ; std::_Vector_const_iterator<std::_Vector_val<std::_Simple_types<wchar_t>>>::operator++(void)+1Aj
.text$mn:00008273                 push    65h ; 'e'       ; unsigned int
.text$mn:00008275                 push    offset ??_C@_1IM@EINEHPHE@?$AAC?$AA?3?$AA?2?$AAP?$AAr?$AAo?$AAg?$AAr?$AAa?$AAm?$AA?5?$AAF?$AAi?$AAl?$AAe?$AAs?$AA?5?$AA?$CI?$AAx?$AA8?$AA6?$AA?$CJ?$AA?2?$AAM?$AAi?$AAc?$AAr?$AAo?$AAs?$AAo?$AAf?$AAt@ ; "C:\\Program Files (x86)\\Microsoft Visu"...
.text$mn:0000827A                 push    offset ??_C@_1EE@EJDKCLKB@?$AAv?$AAe?$AAc?$AAt?$AAo?$AAr?$AA?5?$AAi?$AAt?$AAe?$AAr?$AAa?$AAt?$AAo?$AAr?$AA?5?$AAn?$AAo?$AAt?$AA?5?$AAi?$AAn?$AAc?$AAr?$AAe?$AAm?$AAe?$AAn?$AAt?$AAa?$AAb?$AAl@ ; "vector iterator not incrementable"
.text$mn:0000827F                 call    ?_Debug_message@std@@YAXPB_W0I@Z ; std::_Debug_message(wchar_t const *,wchar_t const *,uint)
.text$mn:00008284                 add     esp, 0Ch
.text$mn:00008287                 mov     eax, offset ??_C@_0CE@OFMIGAMM@Standard?5C?$CL?$CL?5Libraries?5Out?5of?5Ra@ ; "Standard C++ Libraries Out of Range"
.text$mn:0000828C                 test    eax, eax
.text$mn:0000828E                 jz      short loc_8294
.text$mn:00008290                 xor     ecx, ecx
.text$mn:00008292                 jnz     short loc_82B7
.text$mn:00008294
.text$mn:00008294 loc_8294:                               ; CODE XREF: std::_Vector_const_iterator<std::_Vector_val<std::_Simple_types<wchar_t>>>::operator++(void)+4Aj
.text$mn:00008294                 push    offset ??_C@_1FG@IBPIFFN@?$AA?$CC?$AAS?$AAt?$AAa?$AAn?$AAd?$AAa?$AAr?$AAd?$AA?5?$AAC?$AA?$CL?$AA?$CL?$AA?5?$AAL?$AAi?$AAb?$AAr?$AAa?$AAr?$AAi?$AAe?$AAs?$AA?5?$AAO?$AAu?$AAt?$AA?5?$AAo?$AAf?$AA?5?$AAR@ ; "\"Standard C++ Libraries Out of Range\""...
.text$mn:00008299                 push    offset ??_C@_15GANGMFKL@?$AA?$CF?$AAs?$AA?$AA@ ; "%s"
.text$mn:0000829E                 push    0
.text$mn:000082A0                 push    66h ; 'f'
.text$mn:000082A2                 push    offset ??_C@_1IM@EINEHPHE@?$AAC?$AA?3?$AA?2?$AAP?$AAr?$AAo?$AAg?$AAr?$AAa?$AAm?$AA?5?$AAF?$AAi?$AAl?$AAe?$AAs?$AA?5?$AA?$CI?$AAx?$AA8?$AA6?$AA?$CJ?$AA?2?$AAM?$AAi?$AAc?$AAr?$AAo?$AAs?$AAo?$AAf?$AAt@ ; "C:\\Program Files (x86)\\Microsoft Visu"...
.text$mn:000082A7                 push    2
.text$mn:000082A9                 call    __CrtDbgReportW
.text$mn:000082AE                 add     esp, 18h
.text$mn:000082B1                 cmp     eax, 1
.text$mn:000082B4                 jnz     short loc_82B7
.text$mn:000082B6                 int     3               ; Trap to Debugger
.text$mn:000082B7
.text$mn:000082B7 loc_82B7:                               ; CODE XREF: std::_Vector_const_iterator<std::_Vector_val<std::_Simple_types<wchar_t>>>::operator++(void)+4Ej
.text$mn:000082B7                                         ; std::_Vector_const_iterator<std::_Vector_val<std::_Simple_types<wchar_t>>>::operator++(void)+70j
.text$mn:000082B7                 push    0
.text$mn:000082B9                 push    66h ; 'f'
.text$mn:000082BB                 push    offset ??_C@_1IM@EINEHPHE@?$AAC?$AA?3?$AA?2?$AAP?$AAr?$AAo?$AAg?$AAr?$AAa?$AAm?$AA?5?$AAF?$AAi?$AAl?$AAe?$AAs?$AA?5?$AA?$CI?$AAx?$AA8?$AA6?$AA?$CJ?$AA?2?$AAM?$AAi?$AAc?$AAr?$AAo?$AAs?$AAo?$AAf?$AAt@ ; "C:\\Program Files (x86)\\Microsoft Visu"...
.text$mn:000082C0                 push    offset ??_C@_1MO@PNLEPLCE@?$AAs?$AAt?$AAd?$AA?3?$AA?3?$AA_?$AAV?$AAe?$AAc?$AAt?$AAo?$AAr?$AA_?$AAc?$AAo?$AAn?$AAs?$AAt?$AA_?$AAi?$AAt?$AAe?$AAr?$AAa?$AAt?$AAo?$AAr?$AA?$DM?$AAc?$AAl?$AAa?$AAs@ ; "std::_Vector_const_iterator<class std::"...
.text$mn:000082C5                 push    offset ??_C@_1BO@MEPPHOO@?$AA?$CC?$AAo?$AAu?$AAt?$AA?5?$AAo?$AAf?$AA?5?$AAr?$AAa?$AAn?$AAg?$AAe?$AA?$CC?$AA?$AA@ ; "\"out of range\""
.text$mn:000082CA                 call    __invalid_parameter
.text$mn:000082CF                 add     esp, 14h
.text$mn:000082D2
.text$mn:000082D2 loc_82D2:                               ; CODE XREF: std::_Vector_const_iterator<std::_Vector_val<std::_Simple_types<wchar_t>>>::operator++(void)+2Dj
.text$mn:000082D2                 mov     eax, [ebp+var_4]
.text$mn:000082D5                 mov     ecx, [eax+8]
.text$mn:000082D8                 add     ecx, 2
.text$mn:000082DB                 mov     edx, [ebp+var_4]
.text$mn:000082DE                 mov     [edx+8], ecx
.text$mn:000082E1                 mov     eax, [ebp+var_4]
.text$mn:000082E4                 mov     esp, ebp
.text$mn:000082E6                 pop     ebp
.text$mn:000082E7                 retn
.text$mn:000082E7 ??E?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@_W@std@@@std@@@std@@QAEAAV01@XZ endp
.text$mn:000082E7
.text$mn:000082E7 _text$mn        ends
.text$mn:000082E7
.text$mn:000082E8 ; ===========================================================================
.text$mn:000082E8
.text$mn:000082E8 ; Segment type: Pure code
.text$mn:000082E8 ; Segment permissions: Read/Execute
.text$mn:000082E8 _text$mn        segment para public 'CODE' use32
.text$mn:000082E8                 assume cs:_text$mn
.text$mn:000082E8                 ;org 82E8h
.text$mn:000082E8 ; COMDAT (pick any)
.text$mn:000082E8                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text$mn:000082E8
.text$mn:000082E8 ; =============== S U B R O U T I N E =======================================
.text$mn:000082E8
.text$mn:000082E8 ; Attributes: bp-based frame
.text$mn:000082E8
.text$mn:000082E8 ; public: class std::_Vector_iterator<class std::_Vector_val<struct std::_Simple_types<wchar_t>>> & __thiscall std::_Vector_iterator<class std::_Vector_val<struct std::_Simple_types<wchar_t>>>::operator++(void)
.text$mn:000082E8                 public ??E?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@_W@std@@@std@@@std@@QAEAAV01@XZ
.text$mn:000082E8 ??E?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@_W@std@@@std@@@std@@QAEAAV01@XZ proc near
.text$mn:000082E8                                         ; CODE XREF: convertFileName<std::_Vector_iterator<std::_Vector_val<std::_Simple_types<wchar_t>>>>(std::_Vector_iterator<std::_Vector_val<std::_Simple_types<wchar_t>>>,std::_Vector_iterator<std::_Vector_val<std::_Simple_types<wchar_t>>>)+57p
.text$mn:000082E8
.text$mn:000082E8 var_4           = dword ptr -4
.text$mn:000082E8
.text$mn:000082E8                 push    ebp
.text$mn:000082E9                 mov     ebp, esp
.text$mn:000082EB                 push    ecx
.text$mn:000082EC                 mov     [ebp+var_4], ecx
.text$mn:000082EF                 mov     ecx, [ebp+var_4]
.text$mn:000082F2                 call    ??E?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@_W@std@@@std@@@std@@QAEAAV01@XZ ; std::_Vector_const_iterator<std::_Vector_val<std::_Simple_types<wchar_t>>>::operator++(void)
.text$mn:000082F7                 mov     eax, [ebp+var_4]
.text$mn:000082FA                 mov     esp, ebp
.text$mn:000082FC                 pop     ebp
.text$mn:000082FD                 retn
.text$mn:000082FD ??E?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@_W@std@@@std@@@std@@QAEAAV01@XZ endp
.text$mn:000082FD
.text$mn:000082FD ; ---------------------------------------------------------------------------
.text$mn:000082FE                 align 10h
.text$mn:000082FE _text$mn        ends
.text$mn:000082FE
.text$mn:00008300 ; ===========================================================================
.text$mn:00008300
.text$mn:00008300 ; Segment type: Pure code
.text$mn:00008300 ; Segment permissions: Read/Execute
.text$mn:00008300 _text$mn        segment para public 'CODE' use32
.text$mn:00008300                 assume cs:_text$mn
.text$mn:00008300                 ;org 8300h
.text$mn:00008300 ; COMDAT (pick any)
.text$mn:00008300                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text$mn:00008300
.text$mn:00008300 ; =============== S U B R O U T I N E =======================================
.text$mn:00008300
.text$mn:00008300 ; Attributes: bp-based frame
.text$mn:00008300
.text$mn:00008300 ; public: class std::reverse_iterator<class std::_Vector_iterator<class std::_Vector_val<struct std::_Simple_types<wchar_t>>>> & __thiscall std::reverse_iterator<class std::_Vector_iterator<class std::_Vector_val<struct std::_Simple_types<wchar_t>>>>::operator++(void)
.text$mn:00008300                 public ??E?$reverse_iterator@V?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@_W@std@@@std@@@std@@@std@@QAEAAV01@XZ
.text$mn:00008300 ??E?$reverse_iterator@V?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@_W@std@@@std@@@std@@@std@@QAEAAV01@XZ proc near
.text$mn:00008300                                         ; CODE XREF: std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>>::_Construct<std::reverse_iterator<std::_Vector_iterator<std::_Vector_val<std::_Simple_types<wchar_t>>>>>(std::reverse_iterator<std::_Vector_iterator<std::_Vector_val<std::_Simple_types<wchar_t>>>>,std::reverse_iterator<std::_Vector_iterator<std::_Vector_val<std::_Simple_types<wchar_t>>>>,std::forward_iterator_tag)+F0p
.text$mn:00008300
.text$mn:00008300 var_4           = dword ptr -4
.text$mn:00008300
.text$mn:00008300                 push    ebp
.text$mn:00008301                 mov     ebp, esp
.text$mn:00008303                 push    ecx
.text$mn:00008304                 mov     [ebp+var_4], ecx
.text$mn:00008307                 mov     ecx, [ebp+var_4]
.text$mn:0000830A                 call    ??E?$_Revranit@V?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@_W@std@@@std@@@std@@U?$iterator@Urandom_access_iterator_tag@std@@_WHPA_WAA_W@2@@std@@QAEAAV01@XZ ; std::_Revranit<std::_Vector_iterator<std::_Vector_val<std::_Simple_types<wchar_t>>>,std::iterator<std::random_access_iterator_tag,wchar_t,int,wchar_t *,wchar_t &>>::operator++(void)
.text$mn:0000830F                 mov     eax, [ebp+var_4]
.text$mn:00008312                 mov     esp, ebp
.text$mn:00008314                 pop     ebp
.text$mn:00008315                 retn
.text$mn:00008315 ??E?$reverse_iterator@V?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@_W@std@@@std@@@std@@@std@@QAEAAV01@XZ endp
.text$mn:00008315
.text$mn:00008315 ; ---------------------------------------------------------------------------
.text$mn:00008316                 align 4
.text$mn:00008316 _text$mn        ends
.text$mn:00008316
.text$mn:00008318 ; ===========================================================================
.text$mn:00008318
.text$mn:00008318 ; Segment type: Pure code
.text$mn:00008318 ; Segment permissions: Read/Execute
.text$mn:00008318 _text$mn        segment para public 'CODE' use32
.text$mn:00008318                 assume cs:_text$mn
.text$mn:00008318                 ;org 8318h
.text$mn:00008318 ; COMDAT (pick any)
.text$mn:00008318                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text$mn:00008318
.text$mn:00008318 ; =============== S U B R O U T I N E =======================================
.text$mn:00008318
.text$mn:00008318 ; Attributes: bp-based frame
.text$mn:00008318
.text$mn:00008318 ; public: class std::_Vector_const_iterator<class std::_Vector_val<struct std::_Simple_types<wchar_t>>> & __thiscall std::_Vector_const_iterator<class std::_Vector_val<struct std::_Simple_types<wchar_t>>>::operator--(void)
.text$mn:00008318                 public ??F?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@_W@std@@@std@@@std@@QAEAAV01@XZ
.text$mn:00008318 ??F?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@_W@std@@@std@@@std@@QAEAAV01@XZ proc near
.text$mn:00008318                                         ; CODE XREF: std::_Vector_iterator<std::_Vector_val<std::_Simple_types<wchar_t>>>::operator--(void)+Ap
.text$mn:00008318
.text$mn:00008318 var_4           = dword ptr -4
.text$mn:00008318
.text$mn:00008318                 push    ebp
.text$mn:00008319                 mov     ebp, esp
.text$mn:0000831B                 push    ecx
.text$mn:0000831C                 mov     [ebp+var_4], ecx
.text$mn:0000831F                 mov     ecx, [ebp+var_4] ; this
.text$mn:00008322                 call    ?_Getcont@_Iterator_base12@std@@QBEPBU_Container_base12@2@XZ ; std::_Iterator_base12::_Getcont(void)
.text$mn:00008327                 test    eax, eax
.text$mn:00008329                 jz      short loc_8347
.text$mn:0000832B                 mov     eax, [ebp+var_4]
.text$mn:0000832E                 cmp     dword ptr [eax+8], 0
.text$mn:00008332                 jz      short loc_8347
.text$mn:00008334                 mov     ecx, [ebp+var_4] ; this
.text$mn:00008337                 call    ?_Getcont@_Iterator_base12@std@@QBEPBU_Container_base12@2@XZ ; std::_Iterator_base12::_Getcont(void)
.text$mn:0000833C                 mov     ecx, [ebp+var_4]
.text$mn:0000833F                 mov     edx, [ecx+8]
.text$mn:00008342                 cmp     edx, [eax+4]
.text$mn:00008345                 ja      short loc_83AF
.text$mn:00008347
.text$mn:00008347 loc_8347:                               ; CODE XREF: std::_Vector_const_iterator<std::_Vector_val<std::_Simple_types<wchar_t>>>::operator--(void)+11j
.text$mn:00008347                                         ; std::_Vector_const_iterator<std::_Vector_val<std::_Simple_types<wchar_t>>>::operator--(void)+1Aj
.text$mn:00008347                 push    82h ; 'é'       ; unsigned int
.text$mn:0000834C                 push    offset ??_C@_1IM@EINEHPHE@?$AAC?$AA?3?$AA?2?$AAP?$AAr?$AAo?$AAg?$AAr?$AAa?$AAm?$AA?5?$AAF?$AAi?$AAl?$AAe?$AAs?$AA?5?$AA?$CI?$AAx?$AA8?$AA6?$AA?$CJ?$AA?2?$AAM?$AAi?$AAc?$AAr?$AAo?$AAs?$AAo?$AAf?$AAt@ ; "C:\\Program Files (x86)\\Microsoft Visu"...
.text$mn:00008351                 push    offset ??_C@_1EE@OEIJAKGE@?$AAv?$AAe?$AAc?$AAt?$AAo?$AAr?$AA?5?$AAi?$AAt?$AAe?$AAr?$AAa?$AAt?$AAo?$AAr?$AA?5?$AAn?$AAo?$AAt?$AA?5?$AAd?$AAe?$AAc?$AAr?$AAe?$AAm?$AAe?$AAn?$AAt?$AAa?$AAb?$AAl@ ; "vector iterator not decrementable"
.text$mn:00008356                 call    ?_Debug_message@std@@YAXPB_W0I@Z ; std::_Debug_message(wchar_t const *,wchar_t const *,uint)
.text$mn:0000835B                 add     esp, 0Ch
.text$mn:0000835E                 mov     eax, offset ??_C@_0CE@OFMIGAMM@Standard?5C?$CL?$CL?5Libraries?5Out?5of?5Ra@ ; "Standard C++ Libraries Out of Range"
.text$mn:00008363                 test    eax, eax
.text$mn:00008365                 jz      short loc_836B
.text$mn:00008367                 xor     ecx, ecx
.text$mn:00008369                 jnz     short loc_8391
.text$mn:0000836B
.text$mn:0000836B loc_836B:                               ; CODE XREF: std::_Vector_const_iterator<std::_Vector_val<std::_Simple_types<wchar_t>>>::operator--(void)+4Dj
.text$mn:0000836B                 push    offset ??_C@_1FG@IBPIFFN@?$AA?$CC?$AAS?$AAt?$AAa?$AAn?$AAd?$AAa?$AAr?$AAd?$AA?5?$AAC?$AA?$CL?$AA?$CL?$AA?5?$AAL?$AAi?$AAb?$AAr?$AAa?$AAr?$AAi?$AAe?$AAs?$AA?5?$AAO?$AAu?$AAt?$AA?5?$AAo?$AAf?$AA?5?$AAR@ ; "\"Standard C++ Libraries Out of Range\""...
.text$mn:00008370                 push    offset ??_C@_15GANGMFKL@?$AA?$CF?$AAs?$AA?$AA@ ; "%s"
.text$mn:00008375                 push    0
.text$mn:00008377                 push    83h ; 'â'
.text$mn:0000837C                 push    offset ??_C@_1IM@EINEHPHE@?$AAC?$AA?3?$AA?2?$AAP?$AAr?$AAo?$AAg?$AAr?$AAa?$AAm?$AA?5?$AAF?$AAi?$AAl?$AAe?$AAs?$AA?5?$AA?$CI?$AAx?$AA8?$AA6?$AA?$CJ?$AA?2?$AAM?$AAi?$AAc?$AAr?$AAo?$AAs?$AAo?$AAf?$AAt@ ; "C:\\Program Files (x86)\\Microsoft Visu"...
.text$mn:00008381                 push    2
.text$mn:00008383                 call    __CrtDbgReportW
.text$mn:00008388                 add     esp, 18h
.text$mn:0000838B                 cmp     eax, 1
.text$mn:0000838E                 jnz     short loc_8391
.text$mn:00008390                 int     3               ; Trap to Debugger
.text$mn:00008391
.text$mn:00008391 loc_8391:                               ; CODE XREF: std::_Vector_const_iterator<std::_Vector_val<std::_Simple_types<wchar_t>>>::operator--(void)+51j
.text$mn:00008391                                         ; std::_Vector_const_iterator<std::_Vector_val<std::_Simple_types<wchar_t>>>::operator--(void)+76j
.text$mn:00008391                 push    0
.text$mn:00008393                 push    83h ; 'â'
.text$mn:00008398                 push    offset ??_C@_1IM@EINEHPHE@?$AAC?$AA?3?$AA?2?$AAP?$AAr?$AAo?$AAg?$AAr?$AAa?$AAm?$AA?5?$AAF?$AAi?$AAl?$AAe?$AAs?$AA?5?$AA?$CI?$AAx?$AA8?$AA6?$AA?$CJ?$AA?2?$AAM?$AAi?$AAc?$AAr?$AAo?$AAs?$AAo?$AAf?$AAt@ ; "C:\\Program Files (x86)\\Microsoft Visu"...
.text$mn:0000839D                 push    offset ??_C@_1MO@OIGEHOF@?$AAs?$AAt?$AAd?$AA?3?$AA?3?$AA_?$AAV?$AAe?$AAc?$AAt?$AAo?$AAr?$AA_?$AAc?$AAo?$AAn?$AAs?$AAt?$AA_?$AAi?$AAt?$AAe?$AAr?$AAa?$AAt?$AAo?$AAr?$AA?$DM?$AAc?$AAl?$AAa?$AAs@ ; "std::_Vector_const_iterator<class std::"...
.text$mn:000083A2                 push    offset ??_C@_1BO@MEPPHOO@?$AA?$CC?$AAo?$AAu?$AAt?$AA?5?$AAo?$AAf?$AA?5?$AAr?$AAa?$AAn?$AAg?$AAe?$AA?$CC?$AA?$AA@ ; "\"out of range\""
.text$mn:000083A7                 call    __invalid_parameter
.text$mn:000083AC                 add     esp, 14h
.text$mn:000083AF
.text$mn:000083AF loc_83AF:                               ; CODE XREF: std::_Vector_const_iterator<std::_Vector_val<std::_Simple_types<wchar_t>>>::operator--(void)+2Dj
.text$mn:000083AF                 mov     eax, [ebp+var_4]
.text$mn:000083B2                 mov     ecx, [eax+8]
.text$mn:000083B5                 sub     ecx, 2
.text$mn:000083B8                 mov     edx, [ebp+var_4]
.text$mn:000083BB                 mov     [edx+8], ecx
.text$mn:000083BE                 mov     eax, [ebp+var_4]
.text$mn:000083C1                 mov     esp, ebp
.text$mn:000083C3                 pop     ebp
.text$mn:000083C4                 retn
.text$mn:000083C4 ??F?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@_W@std@@@std@@@std@@QAEAAV01@XZ endp
.text$mn:000083C4
.text$mn:000083C4 ; ---------------------------------------------------------------------------
.text$mn:000083C5                 align 4
.text$mn:000083C5 _text$mn        ends
.text$mn:000083C5
.text$mn:000083C8 ; ===========================================================================
.text$mn:000083C8
.text$mn:000083C8 ; Segment type: Pure code
.text$mn:000083C8 ; Segment permissions: Read/Execute
.text$mn:000083C8 _text$mn        segment para public 'CODE' use32
.text$mn:000083C8                 assume cs:_text$mn
.text$mn:000083C8                 ;org 83C8h
.text$mn:000083C8 ; COMDAT (pick any)
.text$mn:000083C8                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text$mn:000083C8
.text$mn:000083C8 ; =============== S U B R O U T I N E =======================================
.text$mn:000083C8
.text$mn:000083C8 ; Attributes: bp-based frame
.text$mn:000083C8
.text$mn:000083C8 ; public: class std::_Vector_iterator<class std::_Vector_val<struct std::_Simple_types<wchar_t>>> & __thiscall std::_Vector_iterator<class std::_Vector_val<struct std::_Simple_types<wchar_t>>>::operator--(void)
.text$mn:000083C8                 public ??F?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@_W@std@@@std@@@std@@QAEAAV01@XZ
.text$mn:000083C8 ??F?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@_W@std@@@std@@@std@@QAEAAV01@XZ proc near
.text$mn:000083C8                                         ; CODE XREF: std::_Revranit<std::_Vector_iterator<std::_Vector_val<std::_Simple_types<wchar_t>>>,std::iterator<std::random_access_iterator_tag,wchar_t,int,wchar_t *,wchar_t &>>::operator*(void)+3Ep
.text$mn:000083C8                                         ; std::_Revranit<std::_Vector_iterator<std::_Vector_val<std::_Simple_types<wchar_t>>>,std::iterator<std::random_access_iterator_tag,wchar_t,int,wchar_t *,wchar_t &>>::operator++(void)+Ap
.text$mn:000083C8
.text$mn:000083C8 var_4           = dword ptr -4
.text$mn:000083C8
.text$mn:000083C8                 push    ebp
.text$mn:000083C9                 mov     ebp, esp
.text$mn:000083CB                 push    ecx
.text$mn:000083CC                 mov     [ebp+var_4], ecx
.text$mn:000083CF                 mov     ecx, [ebp+var_4]
.text$mn:000083D2                 call    ??F?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@_W@std@@@std@@@std@@QAEAAV01@XZ ; std::_Vector_const_iterator<std::_Vector_val<std::_Simple_types<wchar_t>>>::operator--(void)
.text$mn:000083D7                 mov     eax, [ebp+var_4]
.text$mn:000083DA                 mov     esp, ebp
.text$mn:000083DC                 pop     ebp
.text$mn:000083DD                 retn
.text$mn:000083DD ??F?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@_W@std@@@std@@@std@@QAEAAV01@XZ endp
.text$mn:000083DD
.text$mn:000083DD ; ---------------------------------------------------------------------------
.text$mn:000083DE                 align 10h
.text$mn:000083DE _text$mn        ends
.text$mn:000083DE
.text$mn:000083E0 ; ===========================================================================
.text$mn:000083E0
.text$mn:000083E0 ; Segment type: Pure code
.text$mn:000083E0 ; Segment permissions: Read/Execute
.text$mn:000083E0 _text$mn        segment para public 'CODE' use32
.text$mn:000083E0                 assume cs:_text$mn
.text$mn:000083E0                 ;org 83E0h
.text$mn:000083E0 ; COMDAT (pick any)
.text$mn:000083E0                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text$mn:000083E0
.text$mn:000083E0 ; =============== S U B R O U T I N E =======================================
.text$mn:000083E0
.text$mn:000083E0 ; Attributes: bp-based frame
.text$mn:000083E0
.text$mn:000083E0 ; public: class std::_String_const_iterator<class std::_String_val<struct std::_Simple_types<wchar_t>>> __thiscall std::_String_const_iterator<class std::_String_val<struct std::_Simple_types<wchar_t>>>::operator-(int)const
.text$mn:000083E0                 public ??G?$_String_const_iterator@V?$_String_val@U?$_Simple_types@_W@std@@@std@@@std@@QBE?AV01@H@Z
.text$mn:000083E0 ??G?$_String_const_iterator@V?$_String_val@U?$_Simple_types@_W@std@@@std@@@std@@QBE?AV01@H@Z proc near
.text$mn:000083E0                                         ; CODE XREF: BuildMenuFileName(int,uint,std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>> const &)+3B8p
.text$mn:000083E0                                         ; BuildMenuFileName(int,uint,std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>> const &)+4C3p
.text$mn:000083E0
.text$mn:000083E0 var_20          = byte ptr -20h
.text$mn:000083E0 var_14          = dword ptr -14h
.text$mn:000083E0 var_10          = dword ptr -10h
.text$mn:000083E0 var_C           = dword ptr -0Ch
.text$mn:000083E0 var_4           = dword ptr -4
.text$mn:000083E0 arg_0           = dword ptr  8
.text$mn:000083E0 arg_4           = dword ptr  0Ch
.text$mn:000083E0
.text$mn:000083E0                 push    ebp
.text$mn:000083E1                 mov     ebp, esp
.text$mn:000083E3                 push    0FFFFFFFFh
.text$mn:000083E5                 push    offset __ehhandler$??G?$_String_const_iterator@V?$_String_val@U?$_Simple_types@_W@std@@@std@@@std@@QBE?AV01@H@Z
.text$mn:000083EA                 mov     eax, large fs:0
.text$mn:000083F0                 push    eax
.text$mn:000083F1                 sub     esp, 14h
.text$mn:000083F4                 mov     eax, dword ptr ds:___security_cookie
.text$mn:000083F9                 xor     eax, ebp
.text$mn:000083FB                 push    eax
.text$mn:000083FC                 lea     eax, [ebp+var_C]
.text$mn:000083FF                 mov     large fs:0, eax
.text$mn:00008405                 mov     [ebp+var_14], ecx
.text$mn:00008408                 mov     [ebp+var_10], 0
.text$mn:0000840F                 mov     eax, [ebp+var_14]
.text$mn:00008412                 push    eax             ; struct std::_Iterator_base12 *
.text$mn:00008413                 lea     ecx, [ebp+var_20]
.text$mn:00008416                 call    ??0?$_String_const_iterator@V?$_String_val@U?$_Simple_types@_W@std@@@std@@@std@@QAE@ABV01@@Z ; std::_String_const_iterator<std::_String_val<std::_Simple_types<wchar_t>>>::_String_const_iterator<std::_String_val<std::_Simple_types<wchar_t>>>(std::_String_const_iterator<std::_String_val<std::_Simple_types<wchar_t>>> const &)
.text$mn:0000841B                 mov     [ebp+var_4], 1
.text$mn:00008422                 mov     ecx, [ebp+arg_4]
.text$mn:00008425                 push    ecx
.text$mn:00008426                 lea     ecx, [ebp+var_20]
.text$mn:00008429                 call    ??Z?$_String_const_iterator@V?$_String_val@U?$_Simple_types@_W@std@@@std@@@std@@QAEAAV01@H@Z ; std::_String_const_iterator<std::_String_val<std::_Simple_types<wchar_t>>>::operator-=(int)
.text$mn:0000842E                 push    eax             ; struct std::_Iterator_base12 *
.text$mn:0000842F                 mov     ecx, [ebp+arg_0]
.text$mn:00008432                 call    ??0?$_String_const_iterator@V?$_String_val@U?$_Simple_types@_W@std@@@std@@@std@@QAE@ABV01@@Z ; std::_String_const_iterator<std::_String_val<std::_Simple_types<wchar_t>>>::_String_const_iterator<std::_String_val<std::_Simple_types<wchar_t>>>(std::_String_const_iterator<std::_String_val<std::_Simple_types<wchar_t>>> const &)
.text$mn:00008437                 mov     edx, [ebp+var_10]
.text$mn:0000843A                 or      edx, 1
.text$mn:0000843D                 mov     [ebp+var_10], edx
.text$mn:00008440                 mov     byte ptr [ebp+var_4], 0
.text$mn:00008444                 lea     ecx, [ebp+var_20]
.text$mn:00008447                 call    ??1?$_String_const_iterator@V?$_String_val@U?$_Simple_types@_W@std@@@std@@@std@@QAE@XZ ; std::_String_const_iterator<std::_String_val<std::_Simple_types<wchar_t>>>::~_String_const_iterator<std::_String_val<std::_Simple_types<wchar_t>>>(void)
.text$mn:0000844C                 mov     eax, [ebp+arg_0]
.text$mn:0000844F                 mov     ecx, [ebp+var_C]
.text$mn:00008452                 mov     large fs:0, ecx
.text$mn:00008459                 pop     ecx
.text$mn:0000845A                 mov     esp, ebp
.text$mn:0000845C                 pop     ebp
.text$mn:0000845D                 retn    8
.text$mn:0000845D ??G?$_String_const_iterator@V?$_String_val@U?$_Simple_types@_W@std@@@std@@@std@@QBE?AV01@H@Z endp
.text$mn:0000845D
.text$mn:0000845D _text$mn        ends
.text$mn:0000845D
.text$x:00008460 ; ===========================================================================
.text$x:00008460
.text$x:00008460 ; Segment type: Pure code
.text$x:00008460 ; Segment permissions: Read/Execute
.text$x:00008460 _text$x         segment para public 'CODE' use32
.text$x:00008460                 assume cs:_text$x
.text$x:00008460                 ;org 8460h
.text$x:00008460 ; COMDAT (pick associative to section at 83E0)
.text$x:00008460                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text$x:00008460
.text$x:00008460 ; =============== S U B R O U T I N E =======================================
.text$x:00008460
.text$x:00008460
.text$x:00008460 __unwindfunclet$??G?$_String_const_iterator@V?$_String_val@U?$_Simple_types@_W@std@@@std@@@std@@QBE?AV01@H@Z$0 proc near
.text$x:00008460                                         ; DATA XREF: .xdata$x:0000EBA0o
.text$x:00008460                 lea     ecx, [ebp-20h]
.text$x:00008463                 jmp     ??1?$_String_const_iterator@V?$_String_val@U?$_Simple_types@_W@std@@@std@@@std@@QAE@XZ ; std::_String_const_iterator<std::_String_val<std::_Simple_types<wchar_t>>>::~_String_const_iterator<std::_String_val<std::_Simple_types<wchar_t>>>(void)
.text$x:00008463 __unwindfunclet$??G?$_String_const_iterator@V?$_String_val@U?$_Simple_types@_W@std@@@std@@@std@@QBE?AV01@H@Z$0 endp
.text$x:00008463
.text$x:00008468
.text$x:00008468 ; =============== S U B R O U T I N E =======================================
.text$x:00008468
.text$x:00008468
.text$x:00008468 __unwindfunclet$??G?$_String_const_iterator@V?$_String_val@U?$_Simple_types@_W@std@@@std@@@std@@QBE?AV01@H@Z$1 proc near
.text$x:00008468                                         ; DATA XREF: .xdata$x:0000EB98o
.text$x:00008468                 mov     eax, [ebp-10h]
.text$x:0000846B                 and     eax, 1
.text$x:0000846E                 jz      $LN5_1
.text$x:00008474                 and     dword ptr [ebp-10h], 0FFFFFFFEh
.text$x:00008478                 mov     ecx, [ebp+8]
.text$x:0000847B                 jmp     ??1?$_String_const_iterator@V?$_String_val@U?$_Simple_types@_W@std@@@std@@@std@@QAE@XZ ; std::_String_const_iterator<std::_String_val<std::_Simple_types<wchar_t>>>::~_String_const_iterator<std::_String_val<std::_Simple_types<wchar_t>>>(void)
.text$x:00008480 ; ---------------------------------------------------------------------------
.text$x:00008480
.text$x:00008480 $LN5_1:                                 ; CODE XREF: __unwindfunclet$??G?$_String_const_iterator@V?$_String_val@U?$_Simple_types@_W@std@@@std@@@std@@QBE?AV01@H@Z$1+6j
.text$x:00008480                 retn
.text$x:00008480 __unwindfunclet$??G?$_String_const_iterator@V?$_String_val@U?$_Simple_types@_W@std@@@std@@@std@@QBE?AV01@H@Z$1 endp
.text$x:00008480
.text$x:00008481
.text$x:00008481 ; =============== S U B R O U T I N E =======================================
.text$x:00008481
.text$x:00008481
.text$x:00008481 __ehhandler$??G?$_String_const_iterator@V?$_String_val@U?$_Simple_types@_W@std@@@std@@@std@@QBE?AV01@H@Z proc near
.text$x:00008481                                         ; DATA XREF: std::_String_const_iterator<std::_String_val<std::_Simple_types<wchar_t>>>::operator-(int)+5o
.text$x:00008481
.text$x:00008481 arg_4           = dword ptr  8
.text$x:00008481
.text$x:00008481                 mov     edx, [esp+arg_4]
.text$x:00008485                 lea     eax, [edx+0Ch]
.text$x:00008488                 mov     ecx, [edx-18h]
.text$x:0000848B                 xor     ecx, eax
.text$x:0000848D                 call    @__security_check_cookie@4 ; __security_check_cookie(x)
.text$x:00008492                 mov     eax, offset __ehfuncinfo$??G?$_String_const_iterator@V?$_String_val@U?$_Simple_types@_W@std@@@std@@@std@@QBE?AV01@H@Z
.text$x:00008497                 jmp     ___CxxFrameHandler3
.text$x:00008497 __ehhandler$??G?$_String_const_iterator@V?$_String_val@U?$_Simple_types@_W@std@@@std@@@std@@QBE?AV01@H@Z endp
.text$x:00008497
.text$x:00008497 _text$x         ends
.text$x:00008497
.text$mn:0000849C ; ===========================================================================
.text$mn:0000849C
.text$mn:0000849C ; Segment type: Pure code
.text$mn:0000849C ; Segment permissions: Read/Execute
.text$mn:0000849C _text$mn        segment para public 'CODE' use32
.text$mn:0000849C                 assume cs:_text$mn
.text$mn:0000849C                 ;org 849Ch
.text$mn:0000849C ; COMDAT (pick any)
.text$mn:0000849C                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text$mn:0000849C
.text$mn:0000849C ; =============== S U B R O U T I N E =======================================
.text$mn:0000849C
.text$mn:0000849C ; Attributes: bp-based frame
.text$mn:0000849C
.text$mn:0000849C ; int __stdcall std::_String_const_iterator<std::_String_val<std::_Simple_types<wchar_t>>>::operator-(std::_Iterator_base12 *)
.text$mn:0000849C                 public ??G?$_String_const_iterator@V?$_String_val@U?$_Simple_types@_W@std@@@std@@@std@@QBEHABV01@@Z
.text$mn:0000849C ??G?$_String_const_iterator@V?$_String_val@U?$_Simple_types@_W@std@@@std@@@std@@QBEHABV01@@Z proc near
.text$mn:0000849C                                         ; CODE XREF: BuildMenuFileName(int,uint,std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>> const &)+28Ep
.text$mn:0000849C                                         ; std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>>::_Pdif(std::_String_const_iterator<std::_String_val<std::_Simple_types<wchar_t>>>,std::_String_const_iterator<std::_String_val<std::_Simple_types<wchar_t>>>)+42p
.text$mn:0000849C
.text$mn:0000849C var_4           = dword ptr -4
.text$mn:0000849C arg_0           = dword ptr  8
.text$mn:0000849C
.text$mn:0000849C                 push    ebp
.text$mn:0000849D                 mov     ebp, esp
.text$mn:0000849F                 push    ecx
.text$mn:000084A0                 mov     [ebp+var_4], ecx
.text$mn:000084A3                 mov     eax, [ebp+arg_0]
.text$mn:000084A6                 push    eax             ; std::_Iterator_base12 *
.text$mn:000084A7                 mov     ecx, [ebp+var_4]
.text$mn:000084AA                 call    ?_Compat@?$_String_const_iterator@V?$_String_val@U?$_Simple_types@_W@std@@@std@@@std@@QBEXABV12@@Z ; std::_String_const_iterator<std::_String_val<std::_Simple_types<wchar_t>>>::_Compat(std::_String_const_iterator<std::_String_val<std::_Simple_types<wchar_t>>> const &)
.text$mn:000084AF                 mov     ecx, [ebp+var_4]
.text$mn:000084B2                 mov     edx, [ebp+arg_0]
.text$mn:000084B5                 mov     eax, [ecx+8]
.text$mn:000084B8                 sub     eax, [edx+8]
.text$mn:000084BB                 sar     eax, 1
.text$mn:000084BD                 mov     esp, ebp
.text$mn:000084BF                 pop     ebp
.text$mn:000084C0                 retn    4
.text$mn:000084C0 ??G?$_String_const_iterator@V?$_String_val@U?$_Simple_types@_W@std@@@std@@@std@@QBEHABV01@@Z endp
.text$mn:000084C0
.text$mn:000084C0 ; ---------------------------------------------------------------------------
.text$mn:000084C3                 align 4
.text$mn:000084C3 _text$mn        ends
.text$mn:000084C3
.text$mn:000084C4 ; ===========================================================================
.text$mn:000084C4
.text$mn:000084C4 ; Segment type: Pure code
.text$mn:000084C4 ; Segment permissions: Read/Execute
.text$mn:000084C4 _text$mn        segment para public 'CODE' use32
.text$mn:000084C4                 assume cs:_text$mn
.text$mn:000084C4                 ;org 84C4h
.text$mn:000084C4 ; COMDAT (pick any)
.text$mn:000084C4                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text$mn:000084C4
.text$mn:000084C4 ; =============== S U B R O U T I N E =======================================
.text$mn:000084C4
.text$mn:000084C4 ; Attributes: bp-based frame
.text$mn:000084C4
.text$mn:000084C4 ; int __stdcall std::_Vector_const_iterator<std::_Vector_val<std::_Simple_types<wchar_t>>>::operator-(std::_Iterator_base12 *)
.text$mn:000084C4                 public ??G?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@_W@std@@@std@@@std@@QBEHABV01@@Z
.text$mn:000084C4 ??G?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@_W@std@@@std@@@std@@QBEHABV01@@Z proc near
.text$mn:000084C4                                         ; CODE XREF: std::_Vector_iterator<std::_Vector_val<std::_Simple_types<wchar_t>>>::operator-(std::_Vector_const_iterator<std::_Vector_val<std::_Simple_types<wchar_t>>> const &)+Ep
.text$mn:000084C4
.text$mn:000084C4 var_4           = dword ptr -4
.text$mn:000084C4 arg_0           = dword ptr  8
.text$mn:000084C4
.text$mn:000084C4                 push    ebp
.text$mn:000084C5                 mov     ebp, esp
.text$mn:000084C7                 push    ecx
.text$mn:000084C8                 mov     [ebp+var_4], ecx
.text$mn:000084CB                 mov     eax, [ebp+arg_0]
.text$mn:000084CE                 push    eax             ; std::_Iterator_base12 *
.text$mn:000084CF                 mov     ecx, [ebp+var_4]
.text$mn:000084D2                 call    ?_Compat@?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@_W@std@@@std@@@std@@QBEXABV12@@Z ; std::_Vector_const_iterator<std::_Vector_val<std::_Simple_types<wchar_t>>>::_Compat(std::_Vector_const_iterator<std::_Vector_val<std::_Simple_types<wchar_t>>> const &)
.text$mn:000084D7                 mov     ecx, [ebp+var_4]
.text$mn:000084DA                 mov     edx, [ebp+arg_0]
.text$mn:000084DD                 mov     eax, [ecx+8]
.text$mn:000084E0                 sub     eax, [edx+8]
.text$mn:000084E3                 sar     eax, 1
.text$mn:000084E5                 mov     esp, ebp
.text$mn:000084E7                 pop     ebp
.text$mn:000084E8                 retn    4
.text$mn:000084E8 ??G?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@_W@std@@@std@@@std@@QBEHABV01@@Z endp
.text$mn:000084E8
.text$mn:000084E8 ; ---------------------------------------------------------------------------
.text$mn:000084EB                 align 4
.text$mn:000084EB _text$mn        ends
.text$mn:000084EB
.text$mn:000084EC ; ===========================================================================
.text$mn:000084EC
.text$mn:000084EC ; Segment type: Pure code
.text$mn:000084EC ; Segment permissions: Read/Execute
.text$mn:000084EC _text$mn        segment para public 'CODE' use32
.text$mn:000084EC                 assume cs:_text$mn
.text$mn:000084EC                 ;org 84ECh
.text$mn:000084EC ; COMDAT (pick any)
.text$mn:000084EC                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text$mn:000084EC
.text$mn:000084EC ; =============== S U B R O U T I N E =======================================
.text$mn:000084EC
.text$mn:000084EC ; Attributes: bp-based frame
.text$mn:000084EC
.text$mn:000084EC ; int __stdcall std::_Vector_iterator<std::_Vector_val<std::_Simple_types<wchar_t>>>::operator-(std::_Iterator_base12 *)
.text$mn:000084EC                 public ??G?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@_W@std@@@std@@@std@@QBEHABV?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@_W@std@@@std@@@1@@Z
.text$mn:000084EC ??G?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@_W@std@@@std@@@std@@QBEHABV?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@_W@std@@@std@@@1@@Z proc near
.text$mn:000084EC                                         ; CODE XREF: std::operator-<std::_Vector_iterator<std::_Vector_val<std::_Simple_types<wchar_t>>>,std::_Vector_iterator<std::_Vector_val<std::_Simple_types<wchar_t>>>>(std::reverse_iterator<std::_Vector_iterator<std::_Vector_val<std::_Simple_types<wchar_t>>>> const &,std::reverse_iterator<std::_Vector_iterator<std::_Vector_val<std::_Simple_types<wchar_t>>>> const &)+61p
.text$mn:000084EC
.text$mn:000084EC var_4           = dword ptr -4
.text$mn:000084EC arg_0           = dword ptr  8
.text$mn:000084EC
.text$mn:000084EC                 push    ebp
.text$mn:000084ED                 mov     ebp, esp
.text$mn:000084EF                 push    ecx
.text$mn:000084F0                 mov     [ebp+var_4], ecx
.text$mn:000084F3                 mov     eax, [ebp+arg_0]
.text$mn:000084F6                 push    eax             ; std::_Iterator_base12 *
.text$mn:000084F7                 mov     ecx, [ebp+var_4]
.text$mn:000084FA                 call    ??G?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@_W@std@@@std@@@std@@QBEHABV01@@Z ; std::_Vector_const_iterator<std::_Vector_val<std::_Simple_types<wchar_t>>>::operator-(std::_Vector_const_iterator<std::_Vector_val<std::_Simple_types<wchar_t>>> const &)
.text$mn:000084FF                 mov     esp, ebp
.text$mn:00008501                 pop     ebp
.text$mn:00008502                 retn    4
.text$mn:00008502 ??G?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@_W@std@@@std@@@std@@QBEHABV?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@_W@std@@@std@@@1@@Z endp
.text$mn:00008502
.text$mn:00008502 ; ---------------------------------------------------------------------------
.text$mn:00008505                 align 4
.text$mn:00008505 _text$mn        ends
.text$mn:00008505
.text$mn:00008508 ; ===========================================================================
.text$mn:00008508
.text$mn:00008508 ; Segment type: Pure code
.text$mn:00008508 ; Segment permissions: Read/Execute
.text$mn:00008508 _text$mn        segment para public 'CODE' use32
.text$mn:00008508                 assume cs:_text$mn
.text$mn:00008508                 ;org 8508h
.text$mn:00008508 ; COMDAT (pick any)
.text$mn:00008508                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text$mn:00008508
.text$mn:00008508 ; =============== S U B R O U T I N E =======================================
.text$mn:00008508
.text$mn:00008508 ; Attributes: bp-based frame
.text$mn:00008508
.text$mn:00008508 ; public: class std::_String_const_iterator<class std::_String_val<struct std::_Simple_types<wchar_t>>> __thiscall std::_String_const_iterator<class std::_String_val<struct std::_Simple_types<wchar_t>>>::operator+(int)const
.text$mn:00008508                 public ??H?$_String_const_iterator@V?$_String_val@U?$_Simple_types@_W@std@@@std@@@std@@QBE?AV01@H@Z
.text$mn:00008508 ??H?$_String_const_iterator@V?$_String_val@U?$_Simple_types@_W@std@@@std@@@std@@QBE?AV01@H@Z proc near
.text$mn:00008508                                         ; CODE XREF: BuildMenuFileName(int,uint,std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>> const &)+397p
.text$mn:00008508
.text$mn:00008508 var_20          = byte ptr -20h
.text$mn:00008508 var_14          = dword ptr -14h
.text$mn:00008508 var_10          = dword ptr -10h
.text$mn:00008508 var_C           = dword ptr -0Ch
.text$mn:00008508 var_4           = dword ptr -4
.text$mn:00008508 arg_0           = dword ptr  8
.text$mn:00008508 arg_4           = dword ptr  0Ch
.text$mn:00008508
.text$mn:00008508                 push    ebp
.text$mn:00008509                 mov     ebp, esp
.text$mn:0000850B                 push    0FFFFFFFFh
.text$mn:0000850D                 push    offset __ehhandler$??H?$_String_const_iterator@V?$_String_val@U?$_Simple_types@_W@std@@@std@@@std@@QBE?AV01@H@Z
.text$mn:00008512                 mov     eax, large fs:0
.text$mn:00008518                 push    eax
.text$mn:00008519                 sub     esp, 14h
.text$mn:0000851C                 mov     eax, dword ptr ds:___security_cookie
.text$mn:00008521                 xor     eax, ebp
.text$mn:00008523                 push    eax
.text$mn:00008524                 lea     eax, [ebp+var_C]
.text$mn:00008527                 mov     large fs:0, eax
.text$mn:0000852D                 mov     [ebp+var_14], ecx
.text$mn:00008530                 mov     [ebp+var_10], 0
.text$mn:00008537                 mov     eax, [ebp+var_14]
.text$mn:0000853A                 push    eax             ; struct std::_Iterator_base12 *
.text$mn:0000853B                 lea     ecx, [ebp+var_20]
.text$mn:0000853E                 call    ??0?$_String_const_iterator@V?$_String_val@U?$_Simple_types@_W@std@@@std@@@std@@QAE@ABV01@@Z ; std::_String_const_iterator<std::_String_val<std::_Simple_types<wchar_t>>>::_String_const_iterator<std::_String_val<std::_Simple_types<wchar_t>>>(std::_String_const_iterator<std::_String_val<std::_Simple_types<wchar_t>>> const &)
.text$mn:00008543                 mov     [ebp+var_4], 1
.text$mn:0000854A                 mov     ecx, [ebp+arg_4]
.text$mn:0000854D                 push    ecx
.text$mn:0000854E                 lea     ecx, [ebp+var_20]
.text$mn:00008551                 call    ??Y?$_String_const_iterator@V?$_String_val@U?$_Simple_types@_W@std@@@std@@@std@@QAEAAV01@H@Z ; std::_String_const_iterator<std::_String_val<std::_Simple_types<wchar_t>>>::operator+=(int)
.text$mn:00008556                 push    eax             ; struct std::_Iterator_base12 *
.text$mn:00008557                 mov     ecx, [ebp+arg_0]
.text$mn:0000855A                 call    ??0?$_String_const_iterator@V?$_String_val@U?$_Simple_types@_W@std@@@std@@@std@@QAE@ABV01@@Z ; std::_String_const_iterator<std::_String_val<std::_Simple_types<wchar_t>>>::_String_const_iterator<std::_String_val<std::_Simple_types<wchar_t>>>(std::_String_const_iterator<std::_String_val<std::_Simple_types<wchar_t>>> const &)
.text$mn:0000855F                 mov     edx, [ebp+var_10]
.text$mn:00008562                 or      edx, 1
.text$mn:00008565                 mov     [ebp+var_10], edx
.text$mn:00008568                 mov     byte ptr [ebp+var_4], 0
.text$mn:0000856C                 lea     ecx, [ebp+var_20]
.text$mn:0000856F                 call    ??1?$_String_const_iterator@V?$_String_val@U?$_Simple_types@_W@std@@@std@@@std@@QAE@XZ ; std::_String_const_iterator<std::_String_val<std::_Simple_types<wchar_t>>>::~_String_const_iterator<std::_String_val<std::_Simple_types<wchar_t>>>(void)
.text$mn:00008574                 mov     eax, [ebp+arg_0]
.text$mn:00008577                 mov     ecx, [ebp+var_C]
.text$mn:0000857A                 mov     large fs:0, ecx
.text$mn:00008581                 pop     ecx
.text$mn:00008582                 mov     esp, ebp
.text$mn:00008584                 pop     ebp
.text$mn:00008585                 retn    8
.text$mn:00008585 ??H?$_String_const_iterator@V?$_String_val@U?$_Simple_types@_W@std@@@std@@@std@@QBE?AV01@H@Z endp
.text$mn:00008585
.text$mn:00008585 _text$mn        ends
.text$mn:00008585
.text$x:00008588 ; ===========================================================================
.text$x:00008588
.text$x:00008588 ; Segment type: Pure code
.text$x:00008588 ; Segment permissions: Read/Execute
.text$x:00008588 _text$x         segment para public 'CODE' use32
.text$x:00008588                 assume cs:_text$x
.text$x:00008588                 ;org 8588h
.text$x:00008588 ; COMDAT (pick associative to section at 8508)
.text$x:00008588                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text$x:00008588
.text$x:00008588 ; =============== S U B R O U T I N E =======================================
.text$x:00008588
.text$x:00008588
.text$x:00008588 __unwindfunclet$??H?$_String_const_iterator@V?$_String_val@U?$_Simple_types@_W@std@@@std@@@std@@QBE?AV01@H@Z$0 proc near
.text$x:00008588                                         ; DATA XREF: .xdata$x:0000EB6Co
.text$x:00008588                 lea     ecx, [ebp-20h]
.text$x:0000858B                 jmp     ??1?$_String_const_iterator@V?$_String_val@U?$_Simple_types@_W@std@@@std@@@std@@QAE@XZ ; std::_String_const_iterator<std::_String_val<std::_Simple_types<wchar_t>>>::~_String_const_iterator<std::_String_val<std::_Simple_types<wchar_t>>>(void)
.text$x:0000858B __unwindfunclet$??H?$_String_const_iterator@V?$_String_val@U?$_Simple_types@_W@std@@@std@@@std@@QBE?AV01@H@Z$0 endp
.text$x:0000858B
.text$x:00008590
.text$x:00008590 ; =============== S U B R O U T I N E =======================================
.text$x:00008590
.text$x:00008590
.text$x:00008590 __unwindfunclet$??H?$_String_const_iterator@V?$_String_val@U?$_Simple_types@_W@std@@@std@@@std@@QBE?AV01@H@Z$1 proc near
.text$x:00008590                                         ; DATA XREF: .xdata$x:0000EB64o
.text$x:00008590                 mov     eax, [ebp-10h]
.text$x:00008593                 and     eax, 1
.text$x:00008596                 jz      $LN5_0
.text$x:0000859C                 and     dword ptr [ebp-10h], 0FFFFFFFEh
.text$x:000085A0                 mov     ecx, [ebp+8]
.text$x:000085A3                 jmp     ??1?$_String_const_iterator@V?$_String_val@U?$_Simple_types@_W@std@@@std@@@std@@QAE@XZ ; std::_String_const_iterator<std::_String_val<std::_Simple_types<wchar_t>>>::~_String_const_iterator<std::_String_val<std::_Simple_types<wchar_t>>>(void)
.text$x:000085A8 ; ---------------------------------------------------------------------------
.text$x:000085A8
.text$x:000085A8 $LN5_0:                                 ; CODE XREF: __unwindfunclet$??H?$_String_const_iterator@V?$_String_val@U?$_Simple_types@_W@std@@@std@@@std@@QBE?AV01@H@Z$1+6j
.text$x:000085A8                 retn
.text$x:000085A8 __unwindfunclet$??H?$_String_const_iterator@V?$_String_val@U?$_Simple_types@_W@std@@@std@@@std@@QBE?AV01@H@Z$1 endp
.text$x:000085A8
.text$x:000085A9
.text$x:000085A9 ; =============== S U B R O U T I N E =======================================
.text$x:000085A9
.text$x:000085A9
.text$x:000085A9 __ehhandler$??H?$_String_const_iterator@V?$_String_val@U?$_Simple_types@_W@std@@@std@@@std@@QBE?AV01@H@Z proc near
.text$x:000085A9                                         ; DATA XREF: std::_String_const_iterator<std::_String_val<std::_Simple_types<wchar_t>>>::operator+(int)+5o
.text$x:000085A9
.text$x:000085A9 arg_4           = dword ptr  8
.text$x:000085A9
.text$x:000085A9                 mov     edx, [esp+arg_4]
.text$x:000085AD                 lea     eax, [edx+0Ch]
.text$x:000085B0                 mov     ecx, [edx-18h]
.text$x:000085B3                 xor     ecx, eax
.text$x:000085B5                 call    @__security_check_cookie@4 ; __security_check_cookie(x)
.text$x:000085BA                 mov     eax, offset __ehfuncinfo$??H?$_String_const_iterator@V?$_String_val@U?$_Simple_types@_W@std@@@std@@@std@@QBE?AV01@H@Z
.text$x:000085BF                 jmp     ___CxxFrameHandler3
.text$x:000085BF __ehhandler$??H?$_String_const_iterator@V?$_String_val@U?$_Simple_types@_W@std@@@std@@@std@@QBE?AV01@H@Z endp
.text$x:000085BF
.text$x:000085BF _text$x         ends
.text$x:000085BF
.text$mn:000085C4 ; ===========================================================================
.text$mn:000085C4
.text$mn:000085C4 ; Segment type: Pure code
.text$mn:000085C4 ; Segment permissions: Read/Execute
.text$mn:000085C4 _text$mn        segment para public 'CODE' use32
.text$mn:000085C4                 assume cs:_text$mn
.text$mn:000085C4                 ;org 85C4h
.text$mn:000085C4 ; COMDAT (pick any)
.text$mn:000085C4                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text$mn:000085C4
.text$mn:000085C4 ; =============== S U B R O U T I N E =======================================
.text$mn:000085C4
.text$mn:000085C4 ; Attributes: bp-based frame
.text$mn:000085C4
.text$mn:000085C4 ; public: class std::_String_iterator<class std::_String_val<struct std::_Simple_types<wchar_t>>> __thiscall std::_String_iterator<class std::_String_val<struct std::_Simple_types<wchar_t>>>::operator+(int)const
.text$mn:000085C4                 public ??H?$_String_iterator@V?$_String_val@U?$_Simple_types@_W@std@@@std@@@std@@QBE?AV01@H@Z
.text$mn:000085C4 ??H?$_String_iterator@V?$_String_val@U?$_Simple_types@_W@std@@@std@@@std@@QBE?AV01@H@Z proc near
.text$mn:000085C4                                         ; CODE XREF: std::_Transform1<wchar_t *,std::_String_iterator<std::_String_val<std::_Simple_types<wchar_t>>>,int (*)(int)>(wchar_t *,wchar_t *,std::_String_iterator<std::_String_val<std::_Simple_types<wchar_t>>>,int (*)(int),std::random_access_iterator_tag,std::random_access_iterator_tag)+43p
.text$mn:000085C4                                         ; std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>>::insert(std::_String_const_iterator<std::_String_val<std::_Simple_types<wchar_t>>>,wchar_t)+E3p
.text$mn:000085C4
.text$mn:000085C4 var_20          = byte ptr -20h
.text$mn:000085C4 var_14          = dword ptr -14h
.text$mn:000085C4 var_10          = dword ptr -10h
.text$mn:000085C4 var_C           = dword ptr -0Ch
.text$mn:000085C4 var_4           = dword ptr -4
.text$mn:000085C4 arg_0           = dword ptr  8
.text$mn:000085C4 arg_4           = dword ptr  0Ch
.text$mn:000085C4
.text$mn:000085C4                 push    ebp
.text$mn:000085C5                 mov     ebp, esp
.text$mn:000085C7                 push    0FFFFFFFFh
.text$mn:000085C9                 push    offset __ehhandler$??H?$_String_iterator@V?$_String_val@U?$_Simple_types@_W@std@@@std@@@std@@QBE?AV01@H@Z
.text$mn:000085CE                 mov     eax, large fs:0
.text$mn:000085D4                 push    eax
.text$mn:000085D5                 sub     esp, 14h
.text$mn:000085D8                 mov     eax, dword ptr ds:___security_cookie
.text$mn:000085DD                 xor     eax, ebp
.text$mn:000085DF                 push    eax
.text$mn:000085E0                 lea     eax, [ebp+var_C]
.text$mn:000085E3                 mov     large fs:0, eax
.text$mn:000085E9                 mov     [ebp+var_14], ecx
.text$mn:000085EC                 mov     [ebp+var_10], 0
.text$mn:000085F3                 mov     eax, [ebp+var_14]
.text$mn:000085F6                 push    eax             ; struct std::_Iterator_base12 *
.text$mn:000085F7                 lea     ecx, [ebp+var_20]
.text$mn:000085FA                 call    ??0?$_String_iterator@V?$_String_val@U?$_Simple_types@_W@std@@@std@@@std@@QAE@ABV01@@Z ; std::_String_iterator<std::_String_val<std::_Simple_types<wchar_t>>>::_String_iterator<std::_String_val<std::_Simple_types<wchar_t>>>(std::_String_iterator<std::_String_val<std::_Simple_types<wchar_t>>> const &)
.text$mn:000085FF                 mov     [ebp+var_4], 1
.text$mn:00008606                 mov     ecx, [ebp+arg_4]
.text$mn:00008609                 push    ecx
.text$mn:0000860A                 lea     ecx, [ebp+var_20]
.text$mn:0000860D                 call    ??Y?$_String_iterator@V?$_String_val@U?$_Simple_types@_W@std@@@std@@@std@@QAEAAV01@H@Z ; std::_String_iterator<std::_String_val<std::_Simple_types<wchar_t>>>::operator+=(int)
.text$mn:00008612                 push    eax             ; struct std::_Iterator_base12 *
.text$mn:00008613                 mov     ecx, [ebp+arg_0]
.text$mn:00008616                 call    ??0?$_String_iterator@V?$_String_val@U?$_Simple_types@_W@std@@@std@@@std@@QAE@ABV01@@Z ; std::_String_iterator<std::_String_val<std::_Simple_types<wchar_t>>>::_String_iterator<std::_String_val<std::_Simple_types<wchar_t>>>(std::_String_iterator<std::_String_val<std::_Simple_types<wchar_t>>> const &)
.text$mn:0000861B                 mov     edx, [ebp+var_10]
.text$mn:0000861E                 or      edx, 1
.text$mn:00008621                 mov     [ebp+var_10], edx
.text$mn:00008624                 mov     byte ptr [ebp+var_4], 0
.text$mn:00008628                 lea     ecx, [ebp+var_20]
.text$mn:0000862B                 call    ??1?$_String_iterator@V?$_String_val@U?$_Simple_types@_W@std@@@std@@@std@@QAE@XZ ; std::_String_iterator<std::_String_val<std::_Simple_types<wchar_t>>>::~_String_iterator<std::_String_val<std::_Simple_types<wchar_t>>>(void)
.text$mn:00008630                 mov     eax, [ebp+arg_0]
.text$mn:00008633                 mov     ecx, [ebp+var_C]
.text$mn:00008636                 mov     large fs:0, ecx
.text$mn:0000863D                 pop     ecx
.text$mn:0000863E                 mov     esp, ebp
.text$mn:00008640                 pop     ebp
.text$mn:00008641                 retn    8
.text$mn:00008641 ??H?$_String_iterator@V?$_String_val@U?$_Simple_types@_W@std@@@std@@@std@@QBE?AV01@H@Z endp
.text$mn:00008641
.text$mn:00008641 _text$mn        ends
.text$mn:00008641
.text$x:00008644 ; ===========================================================================
.text$x:00008644
.text$x:00008644 ; Segment type: Pure code
.text$x:00008644 ; Segment permissions: Read/Execute
.text$x:00008644 _text$x         segment para public 'CODE' use32
.text$x:00008644                 assume cs:_text$x
.text$x:00008644                 ;org 8644h
.text$x:00008644 ; COMDAT (pick associative to section at 85C4)
.text$x:00008644                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text$x:00008644
.text$x:00008644 ; =============== S U B R O U T I N E =======================================
.text$x:00008644
.text$x:00008644
.text$x:00008644 __unwindfunclet$??H?$_String_iterator@V?$_String_val@U?$_Simple_types@_W@std@@@std@@@std@@QBE?AV01@H@Z$0 proc near
.text$x:00008644                                         ; DATA XREF: .xdata$x:0000ECF0o
.text$x:00008644                 lea     ecx, [ebp-20h]
.text$x:00008647                 jmp     ??1?$_String_iterator@V?$_String_val@U?$_Simple_types@_W@std@@@std@@@std@@QAE@XZ ; std::_String_iterator<std::_String_val<std::_Simple_types<wchar_t>>>::~_String_iterator<std::_String_val<std::_Simple_types<wchar_t>>>(void)
.text$x:00008647 __unwindfunclet$??H?$_String_iterator@V?$_String_val@U?$_Simple_types@_W@std@@@std@@@std@@QBE?AV01@H@Z$0 endp
.text$x:00008647
.text$x:0000864C
.text$x:0000864C ; =============== S U B R O U T I N E =======================================
.text$x:0000864C
.text$x:0000864C
.text$x:0000864C __unwindfunclet$??H?$_String_iterator@V?$_String_val@U?$_Simple_types@_W@std@@@std@@@std@@QBE?AV01@H@Z$1 proc near
.text$x:0000864C                                         ; DATA XREF: .xdata$x:0000ECE8o
.text$x:0000864C                 mov     eax, [ebp-10h]
.text$x:0000864F                 and     eax, 1
.text$x:00008652                 jz      $LN5_2
.text$x:00008658                 and     dword ptr [ebp-10h], 0FFFFFFFEh
.text$x:0000865C                 mov     ecx, [ebp+8]
.text$x:0000865F                 jmp     ??1?$_String_iterator@V?$_String_val@U?$_Simple_types@_W@std@@@std@@@std@@QAE@XZ ; std::_String_iterator<std::_String_val<std::_Simple_types<wchar_t>>>::~_String_iterator<std::_String_val<std::_Simple_types<wchar_t>>>(void)
.text$x:00008664 ; ---------------------------------------------------------------------------
.text$x:00008664
.text$x:00008664 $LN5_2:                                 ; CODE XREF: __unwindfunclet$??H?$_String_iterator@V?$_String_val@U?$_Simple_types@_W@std@@@std@@@std@@QBE?AV01@H@Z$1+6j
.text$x:00008664                 retn
.text$x:00008664 __unwindfunclet$??H?$_String_iterator@V?$_String_val@U?$_Simple_types@_W@std@@@std@@@std@@QBE?AV01@H@Z$1 endp
.text$x:00008664
.text$x:00008665
.text$x:00008665 ; =============== S U B R O U T I N E =======================================
.text$x:00008665
.text$x:00008665
.text$x:00008665 __ehhandler$??H?$_String_iterator@V?$_String_val@U?$_Simple_types@_W@std@@@std@@@std@@QBE?AV01@H@Z proc near
.text$x:00008665                                         ; DATA XREF: std::_String_iterator<std::_String_val<std::_Simple_types<wchar_t>>>::operator+(int)+5o
.text$x:00008665
.text$x:00008665 arg_4           = dword ptr  8
.text$x:00008665
.text$x:00008665                 mov     edx, [esp+arg_4]
.text$x:00008669                 lea     eax, [edx+0Ch]
.text$x:0000866C                 mov     ecx, [edx-18h]
.text$x:0000866F                 xor     ecx, eax
.text$x:00008671                 call    @__security_check_cookie@4 ; __security_check_cookie(x)
.text$x:00008676                 mov     eax, offset __ehfuncinfo$??H?$_String_iterator@V?$_String_val@U?$_Simple_types@_W@std@@@std@@@std@@QBE?AV01@H@Z
.text$x:0000867B                 jmp     ___CxxFrameHandler3
.text$x:0000867B __ehhandler$??H?$_String_iterator@V?$_String_val@U?$_Simple_types@_W@std@@@std@@@std@@QBE?AV01@H@Z endp
.text$x:0000867B
.text$x:0000867B _text$x         ends
.text$x:0000867B
.text$mn:00008680 ; ===========================================================================
.text$mn:00008680
.text$mn:00008680 ; Segment type: Pure code
.text$mn:00008680 ; Segment permissions: Read/Execute
.text$mn:00008680 _text$mn        segment para public 'CODE' use32
.text$mn:00008680                 assume cs:_text$mn
.text$mn:00008680                 ;org 8680h
.text$mn:00008680 ; COMDAT (pick any)
.text$mn:00008680                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text$mn:00008680
.text$mn:00008680 ; =============== S U B R O U T I N E =======================================
.text$mn:00008680
.text$mn:00008680 ; Attributes: bp-based frame
.text$mn:00008680
.text$mn:00008680 ; public: class std::_Vector_iterator<class std::_Vector_val<struct std::_Simple_types<wchar_t>>> __thiscall std::_Vector_iterator<class std::_Vector_val<struct std::_Simple_types<wchar_t>>>::operator+(int)const
.text$mn:00008680                 public ??H?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@_W@std@@@std@@@std@@QBE?AV01@H@Z
.text$mn:00008680 ??H?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@_W@std@@@std@@@std@@QBE?AV01@H@Z proc near
.text$mn:00008680                                         ; CODE XREF: BuildMenuFileName(int,uint,std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>> const &)+168p
.text$mn:00008680
.text$mn:00008680 var_20          = byte ptr -20h
.text$mn:00008680 var_14          = dword ptr -14h
.text$mn:00008680 var_10          = dword ptr -10h
.text$mn:00008680 var_C           = dword ptr -0Ch
.text$mn:00008680 var_4           = dword ptr -4
.text$mn:00008680 arg_0           = dword ptr  8
.text$mn:00008680 arg_4           = dword ptr  0Ch
.text$mn:00008680
.text$mn:00008680                 push    ebp
.text$mn:00008681                 mov     ebp, esp
.text$mn:00008683                 push    0FFFFFFFFh
.text$mn:00008685                 push    offset __ehhandler$??H?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@_W@std@@@std@@@std@@QBE?AV01@H@Z
.text$mn:0000868A                 mov     eax, large fs:0
.text$mn:00008690                 push    eax
.text$mn:00008691                 sub     esp, 14h
.text$mn:00008694                 mov     eax, dword ptr ds:___security_cookie
.text$mn:00008699                 xor     eax, ebp
.text$mn:0000869B                 push    eax
.text$mn:0000869C                 lea     eax, [ebp+var_C]
.text$mn:0000869F                 mov     large fs:0, eax
.text$mn:000086A5                 mov     [ebp+var_14], ecx
.text$mn:000086A8                 mov     [ebp+var_10], 0
.text$mn:000086AF                 mov     eax, [ebp+var_14]
.text$mn:000086B2                 push    eax             ; struct std::_Iterator_base12 *
.text$mn:000086B3                 lea     ecx, [ebp+var_20]
.text$mn:000086B6                 call    ??0?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@_W@std@@@std@@@std@@QAE@ABV01@@Z ; std::_Vector_iterator<std::_Vector_val<std::_Simple_types<wchar_t>>>::_Vector_iterator<std::_Vector_val<std::_Simple_types<wchar_t>>>(std::_Vector_iterator<std::_Vector_val<std::_Simple_types<wchar_t>>> const &)
.text$mn:000086BB                 mov     [ebp+var_4], 1
.text$mn:000086C2                 mov     ecx, [ebp+arg_4]
.text$mn:000086C5                 push    ecx
.text$mn:000086C6                 lea     ecx, [ebp+var_20]
.text$mn:000086C9                 call    ??Y?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@_W@std@@@std@@@std@@QAEAAV01@H@Z ; std::_Vector_iterator<std::_Vector_val<std::_Simple_types<wchar_t>>>::operator+=(int)
.text$mn:000086CE                 push    eax             ; struct std::_Iterator_base12 *
.text$mn:000086CF                 mov     ecx, [ebp+arg_0]
.text$mn:000086D2                 call    ??0?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@_W@std@@@std@@@std@@QAE@ABV01@@Z ; std::_Vector_iterator<std::_Vector_val<std::_Simple_types<wchar_t>>>::_Vector_iterator<std::_Vector_val<std::_Simple_types<wchar_t>>>(std::_Vector_iterator<std::_Vector_val<std::_Simple_types<wchar_t>>> const &)
.text$mn:000086D7                 mov     edx, [ebp+var_10]
.text$mn:000086DA                 or      edx, 1
.text$mn:000086DD                 mov     [ebp+var_10], edx
.text$mn:000086E0                 mov     byte ptr [ebp+var_4], 0
.text$mn:000086E4                 lea     ecx, [ebp+var_20]
.text$mn:000086E7                 call    ??1?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@_W@std@@@std@@@std@@QAE@XZ ; std::_Vector_iterator<std::_Vector_val<std::_Simple_types<wchar_t>>>::~_Vector_iterator<std::_Vector_val<std::_Simple_types<wchar_t>>>(void)
.text$mn:000086EC                 mov     eax, [ebp+arg_0]
.text$mn:000086EF                 mov     ecx, [ebp+var_C]
.text$mn:000086F2                 mov     large fs:0, ecx
.text$mn:000086F9                 pop     ecx
.text$mn:000086FA                 mov     esp, ebp
.text$mn:000086FC                 pop     ebp
.text$mn:000086FD                 retn    8
.text$mn:000086FD ??H?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@_W@std@@@std@@@std@@QBE?AV01@H@Z endp
.text$mn:000086FD
.text$mn:000086FD _text$mn        ends
.text$mn:000086FD
.text$x:00008700 ; ===========================================================================
.text$x:00008700
.text$x:00008700 ; Segment type: Pure code
.text$x:00008700 ; Segment permissions: Read/Execute
.text$x:00008700 _text$x         segment para public 'CODE' use32
.text$x:00008700                 assume cs:_text$x
.text$x:00008700                 ;org 8700h
.text$x:00008700 ; COMDAT (pick associative to section at 8680)
.text$x:00008700                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text$x:00008700
.text$x:00008700 ; =============== S U B R O U T I N E =======================================
.text$x:00008700
.text$x:00008700
.text$x:00008700 __unwindfunclet$??H?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@_W@std@@@std@@@std@@QBE?AV01@H@Z$0 proc near
.text$x:00008700                                         ; DATA XREF: .xdata$x:0000E8F0o
.text$x:00008700                 lea     ecx, [ebp-20h]
.text$x:00008703                 jmp     ??1?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@_W@std@@@std@@@std@@QAE@XZ ; std::_Vector_iterator<std::_Vector_val<std::_Simple_types<wchar_t>>>::~_Vector_iterator<std::_Vector_val<std::_Simple_types<wchar_t>>>(void)
.text$x:00008703 __unwindfunclet$??H?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@_W@std@@@std@@@std@@QBE?AV01@H@Z$0 endp
.text$x:00008703
.text$x:00008708
.text$x:00008708 ; =============== S U B R O U T I N E =======================================
.text$x:00008708
.text$x:00008708
.text$x:00008708 __unwindfunclet$??H?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@_W@std@@@std@@@std@@QBE?AV01@H@Z$1 proc near
.text$x:00008708                                         ; DATA XREF: .xdata$x:0000E8E8o
.text$x:00008708                 mov     eax, [ebp-10h]
.text$x:0000870B                 and     eax, 1
.text$x:0000870E                 jz      $LN5
.text$x:00008714                 and     dword ptr [ebp-10h], 0FFFFFFFEh
.text$x:00008718                 mov     ecx, [ebp+8]
.text$x:0000871B                 jmp     ??1?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@_W@std@@@std@@@std@@QAE@XZ ; std::_Vector_iterator<std::_Vector_val<std::_Simple_types<wchar_t>>>::~_Vector_iterator<std::_Vector_val<std::_Simple_types<wchar_t>>>(void)
.text$x:00008720 ; ---------------------------------------------------------------------------
.text$x:00008720
.text$x:00008720 $LN5:                                   ; CODE XREF: __unwindfunclet$??H?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@_W@std@@@std@@@std@@QBE?AV01@H@Z$1+6j
.text$x:00008720                 retn
.text$x:00008720 __unwindfunclet$??H?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@_W@std@@@std@@@std@@QBE?AV01@H@Z$1 endp
.text$x:00008720
.text$x:00008721
.text$x:00008721 ; =============== S U B R O U T I N E =======================================
.text$x:00008721
.text$x:00008721
.text$x:00008721 __ehhandler$??H?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@_W@std@@@std@@@std@@QBE?AV01@H@Z proc near
.text$x:00008721                                         ; DATA XREF: std::_Vector_iterator<std::_Vector_val<std::_Simple_types<wchar_t>>>::operator+(int)+5o
.text$x:00008721
.text$x:00008721 arg_4           = dword ptr  8
.text$x:00008721
.text$x:00008721                 mov     edx, [esp+arg_4]
.text$x:00008725                 lea     eax, [edx+0Ch]
.text$x:00008728                 mov     ecx, [edx-18h]
.text$x:0000872B                 xor     ecx, eax
.text$x:0000872D                 call    @__security_check_cookie@4 ; __security_check_cookie(x)
.text$x:00008732                 mov     eax, offset __ehfuncinfo$??H?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@_W@std@@@std@@@std@@QBE?AV01@H@Z
.text$x:00008737                 jmp     ___CxxFrameHandler3
.text$x:00008737 __ehhandler$??H?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@_W@std@@@std@@@std@@QBE?AV01@H@Z endp
.text$x:00008737
.text$x:00008737 _text$x         ends
.text$x:00008737
.text$mn:0000873C ; ===========================================================================
.text$mn:0000873C
.text$mn:0000873C ; Segment type: Pure code
.text$mn:0000873C ; Segment permissions: Read/Execute
.text$mn:0000873C _text$mn        segment para public 'CODE' use32
.text$mn:0000873C                 assume cs:_text$mn
.text$mn:0000873C                 ;org 873Ch
.text$mn:0000873C ; COMDAT (pick any)
.text$mn:0000873C                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text$mn:0000873C
.text$mn:0000873C ; =============== S U B R O U T I N E =======================================
.text$mn:0000873C
.text$mn:0000873C ; Attributes: bp-based frame
.text$mn:0000873C
.text$mn:0000873C ; int __stdcall std::_String_const_iterator<std::_String_val<std::_Simple_types<wchar_t>>>::operator<(std::_Iterator_base12 *)
.text$mn:0000873C                 public ??M?$_String_const_iterator@V?$_String_val@U?$_Simple_types@_W@std@@@std@@@std@@QBE_NABV01@@Z
.text$mn:0000873C ??M?$_String_const_iterator@V?$_String_val@U?$_Simple_types@_W@std@@@std@@@std@@QBE_NABV01@@Z proc near
.text$mn:0000873C                                         ; CODE XREF: std::_Debug_range2<std::_String_iterator<std::_String_val<std::_Simple_types<wchar_t>>>>(std::_String_iterator<std::_String_val<std::_Simple_types<wchar_t>>>,std::_String_iterator<std::_String_val<std::_Simple_types<wchar_t>>>,wchar_t const *,uint,std::random_access_iterator_tag)+6Bp
.text$mn:0000873C
.text$mn:0000873C var_8           = dword ptr -8
.text$mn:0000873C var_4           = dword ptr -4
.text$mn:0000873C arg_0           = dword ptr  8
.text$mn:0000873C
.text$mn:0000873C                 push    ebp
.text$mn:0000873D                 mov     ebp, esp
.text$mn:0000873F                 sub     esp, 8
.text$mn:00008742                 mov     [ebp+var_4], ecx
.text$mn:00008745                 mov     eax, [ebp+arg_0]
.text$mn:00008748                 push    eax             ; std::_Iterator_base12 *
.text$mn:00008749                 mov     ecx, [ebp+var_4]
.text$mn:0000874C                 call    ?_Compat@?$_String_const_iterator@V?$_String_val@U?$_Simple_types@_W@std@@@std@@@std@@QBEXABV12@@Z ; std::_String_const_iterator<std::_String_val<std::_Simple_types<wchar_t>>>::_Compat(std::_String_const_iterator<std::_String_val<std::_Simple_types<wchar_t>>> const &)
.text$mn:00008751                 mov     ecx, [ebp+var_4]
.text$mn:00008754                 mov     edx, [ebp+arg_0]
.text$mn:00008757                 mov     eax, [ecx+8]
.text$mn:0000875A                 cmp     eax, [edx+8]
.text$mn:0000875D                 jnb     short loc_8768
.text$mn:0000875F                 mov     [ebp+var_8], 1
.text$mn:00008766                 jmp     short loc_876F
.text$mn:00008768 ; ---------------------------------------------------------------------------
.text$mn:00008768
.text$mn:00008768 loc_8768:                               ; CODE XREF: std::_String_const_iterator<std::_String_val<std::_Simple_types<wchar_t>>>::operator<(std::_String_const_iterator<std::_String_val<std::_Simple_types<wchar_t>>> const &)+21j
.text$mn:00008768                 mov     [ebp+var_8], 0
.text$mn:0000876F
.text$mn:0000876F loc_876F:                               ; CODE XREF: std::_String_const_iterator<std::_String_val<std::_Simple_types<wchar_t>>>::operator<(std::_String_const_iterator<std::_String_val<std::_Simple_types<wchar_t>>> const &)+2Aj
.text$mn:0000876F                 mov     al, byte ptr [ebp+var_8]
.text$mn:00008772                 mov     esp, ebp
.text$mn:00008774                 pop     ebp
.text$mn:00008775                 retn    4
.text$mn:00008775 ??M?$_String_const_iterator@V?$_String_val@U?$_Simple_types@_W@std@@@std@@@std@@QBE_NABV01@@Z endp
.text$mn:00008775
.text$mn:00008775 _text$mn        ends
.text$mn:00008775
.text$mn:00008778 ; ===========================================================================
.text$mn:00008778
.text$mn:00008778 ; Segment type: Pure code
.text$mn:00008778 ; Segment permissions: Read/Execute
.text$mn:00008778 _text$mn        segment para public 'CODE' use32
.text$mn:00008778                 assume cs:_text$mn
.text$mn:00008778                 ;org 8778h
.text$mn:00008778 ; COMDAT (pick any)
.text$mn:00008778                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text$mn:00008778
.text$mn:00008778 ; =============== S U B R O U T I N E =======================================
.text$mn:00008778
.text$mn:00008778 ; Attributes: bp-based frame
.text$mn:00008778
.text$mn:00008778 ; int __stdcall std::_Vector_const_iterator<std::_Vector_val<std::_Simple_types<wchar_t>>>::operator<(std::_Iterator_base12 *)
.text$mn:00008778                 public ??M?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@_W@std@@@std@@@std@@QBE_NABV01@@Z
.text$mn:00008778 ??M?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@_W@std@@@std@@@std@@QBE_NABV01@@Z proc near
.text$mn:00008778                                         ; CODE XREF: std::_Revranit<std::_Vector_iterator<std::_Vector_val<std::_Simple_types<wchar_t>>>,std::iterator<std::random_access_iterator_tag,wchar_t,int,wchar_t *,wchar_t &>>::_Less<std::_Vector_iterator<std::_Vector_val<std::_Simple_types<wchar_t>>>,std::iterator<std::random_access_iterator_tag,wchar_t,int,wchar_t *,wchar_t &>>(std::_Revranit<std::_Vector_iterator<std::_Vector_val<std::_Simple_types<wchar_t>>>,std::iterator<std::random_access_iterator_tag,wchar_t,int,wchar_t *,wchar_t &>> const &)+4Bp
.text$mn:00008778
.text$mn:00008778 var_8           = dword ptr -8
.text$mn:00008778 var_4           = dword ptr -4
.text$mn:00008778 arg_0           = dword ptr  8
.text$mn:00008778
.text$mn:00008778                 push    ebp
.text$mn:00008779                 mov     ebp, esp
.text$mn:0000877B                 sub     esp, 8
.text$mn:0000877E                 mov     [ebp+var_4], ecx
.text$mn:00008781                 mov     eax, [ebp+arg_0]
.text$mn:00008784                 push    eax             ; std::_Iterator_base12 *
.text$mn:00008785                 mov     ecx, [ebp+var_4]
.text$mn:00008788                 call    ?_Compat@?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@_W@std@@@std@@@std@@QBEXABV12@@Z ; std::_Vector_const_iterator<std::_Vector_val<std::_Simple_types<wchar_t>>>::_Compat(std::_Vector_const_iterator<std::_Vector_val<std::_Simple_types<wchar_t>>> const &)
.text$mn:0000878D                 mov     ecx, [ebp+var_4]
.text$mn:00008790                 mov     edx, [ebp+arg_0]
.text$mn:00008793                 mov     eax, [ecx+8]
.text$mn:00008796                 cmp     eax, [edx+8]
.text$mn:00008799                 jnb     short loc_87A4
.text$mn:0000879B                 mov     [ebp+var_8], 1
.text$mn:000087A2                 jmp     short loc_87AB
.text$mn:000087A4 ; ---------------------------------------------------------------------------
.text$mn:000087A4
.text$mn:000087A4 loc_87A4:                               ; CODE XREF: std::_Vector_const_iterator<std::_Vector_val<std::_Simple_types<wchar_t>>>::operator<(std::_Vector_const_iterator<std::_Vector_val<std::_Simple_types<wchar_t>>> const &)+21j
.text$mn:000087A4                 mov     [ebp+var_8], 0
.text$mn:000087AB
.text$mn:000087AB loc_87AB:                               ; CODE XREF: std::_Vector_const_iterator<std::_Vector_val<std::_Simple_types<wchar_t>>>::operator<(std::_Vector_const_iterator<std::_Vector_val<std::_Simple_types<wchar_t>>> const &)+2Aj
.text$mn:000087AB                 mov     al, byte ptr [ebp+var_8]
.text$mn:000087AE                 mov     esp, ebp
.text$mn:000087B0                 pop     ebp
.text$mn:000087B1                 retn    4
.text$mn:000087B1 ??M?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@_W@std@@@std@@@std@@QBE_NABV01@@Z endp
.text$mn:000087B1
.text$mn:000087B1 _text$mn        ends
.text$mn:000087B1
.text$mn:000087B4 ; ===========================================================================
.text$mn:000087B4
.text$mn:000087B4 ; Segment type: Pure code
.text$mn:000087B4 ; Segment permissions: Read/Execute
.text$mn:000087B4 _text$mn        segment para public 'CODE' use32
.text$mn:000087B4                 assume cs:_text$mn
.text$mn:000087B4                 ;org 87B4h
.text$mn:000087B4 ; COMDAT (pick any)
.text$mn:000087B4                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text$mn:000087B4
.text$mn:000087B4 ; =============== S U B R O U T I N E =======================================
.text$mn:000087B4
.text$mn:000087B4 ; Attributes: bp-based frame
.text$mn:000087B4
.text$mn:000087B4 ; public: class std::_String_const_iterator<class std::_String_val<struct std::_Simple_types<wchar_t>>> & __thiscall std::_String_const_iterator<class std::_String_val<struct std::_Simple_types<wchar_t>>>::operator+=(int)
.text$mn:000087B4                 public ??Y?$_String_const_iterator@V?$_String_val@U?$_Simple_types@_W@std@@@std@@@std@@QAEAAV01@H@Z
.text$mn:000087B4 ??Y?$_String_const_iterator@V?$_String_val@U?$_Simple_types@_W@std@@@std@@@std@@QAEAAV01@H@Z proc near
.text$mn:000087B4                                         ; CODE XREF: BuildMenuFileName(int,uint,std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>> const &)+257p
.text$mn:000087B4                                         ; std::_String_const_iterator<std::_String_val<std::_Simple_types<wchar_t>>>::operator+(int)+49p ...
.text$mn:000087B4
.text$mn:000087B4 var_4           = dword ptr -4
.text$mn:000087B4 arg_0           = dword ptr  8
.text$mn:000087B4
.text$mn:000087B4                 push    ebp
.text$mn:000087B5                 mov     ebp, esp
.text$mn:000087B7                 push    ecx
.text$mn:000087B8                 push    esi
.text$mn:000087B9                 mov     [ebp+var_4], ecx
.text$mn:000087BC                 mov     ecx, [ebp+var_4] ; this
.text$mn:000087BF                 call    ?_Getcont@_Iterator_base12@std@@QBEPBU_Container_base12@2@XZ ; std::_Iterator_base12::_Getcont(void)
.text$mn:000087C4                 test    eax, eax
.text$mn:000087C6                 jz      short loc_881F
.text$mn:000087C8                 mov     eax, [ebp+var_4]
.text$mn:000087CB                 cmp     dword ptr [eax+8], 0
.text$mn:000087CF                 jz      short loc_881F
.text$mn:000087D1                 mov     ecx, [ebp+var_4]
.text$mn:000087D4                 mov     edx, [ecx+8]
.text$mn:000087D7                 mov     eax, [ebp+arg_0]
.text$mn:000087DA                 lea     esi, [edx+eax*2]
.text$mn:000087DD                 mov     ecx, [ebp+var_4] ; this
.text$mn:000087E0                 call    ?_Getcont@_Iterator_base12@std@@QBEPBU_Container_base12@2@XZ ; std::_Iterator_base12::_Getcont(void)
.text$mn:000087E5                 mov     ecx, eax
.text$mn:000087E7                 call    ?_Myptr@?$_String_val@U?$_Simple_types@_W@std@@@std@@QAEPA_WXZ ; std::_String_val<std::_Simple_types<wchar_t>>::_Myptr(void)
.text$mn:000087EC                 cmp     esi, eax
.text$mn:000087EE                 jb      short loc_881F
.text$mn:000087F0                 mov     ecx, [ebp+var_4] ; this
.text$mn:000087F3                 call    ?_Getcont@_Iterator_base12@std@@QBEPBU_Container_base12@2@XZ ; std::_Iterator_base12::_Getcont(void)
.text$mn:000087F8                 mov     ecx, eax
.text$mn:000087FA                 call    ?_Myptr@?$_String_val@U?$_Simple_types@_W@std@@@std@@QAEPA_WXZ ; std::_String_val<std::_Simple_types<wchar_t>>::_Myptr(void)
.text$mn:000087FF                 mov     esi, eax
.text$mn:00008801                 mov     ecx, [ebp+var_4] ; this
.text$mn:00008804                 call    ?_Getcont@_Iterator_base12@std@@QBEPBU_Container_base12@2@XZ ; std::_Iterator_base12::_Getcont(void)
.text$mn:00008809                 mov     ecx, [eax+14h]
.text$mn:0000880C                 lea     edx, [esi+ecx*2]
.text$mn:0000880F                 mov     eax, [ebp+var_4]
.text$mn:00008812                 mov     ecx, [eax+8]
.text$mn:00008815                 mov     eax, [ebp+arg_0]
.text$mn:00008818                 lea     ecx, [ecx+eax*2]
.text$mn:0000881B                 cmp     edx, ecx
.text$mn:0000881D                 jnb     short loc_8887
.text$mn:0000881F
.text$mn:0000881F loc_881F:                               ; CODE XREF: std::_String_const_iterator<std::_String_val<std::_Simple_types<wchar_t>>>::operator+=(int)+12j
.text$mn:0000881F                                         ; std::_String_const_iterator<std::_String_val<std::_Simple_types<wchar_t>>>::operator+=(int)+1Bj ...
.text$mn:0000881F                 push    0A8h ; '¿'      ; unsigned int
.text$mn:00008824                 push    offset ??_C@_1IO@FEAPGJBD@?$AAC?$AA?3?$AA?2?$AAP?$AAr?$AAo?$AAg?$AAr?$AAa?$AAm?$AA?5?$AAF?$AAi?$AAl?$AAe?$AAs?$AA?5?$AA?$CI?$AAx?$AA8?$AA6?$AA?$CJ?$AA?2?$AAM?$AAi?$AAc?$AAr?$AAo?$AAs?$AAo?$AAf?$AAt@ ; "C:\\Program Files (x86)\\Microsoft Visu"...
.text$mn:00008829                 push    offset ??_C@_1EM@MEFKBKGF@?$AAs?$AAt?$AAr?$AAi?$AAn?$AAg?$AA?5?$AAi?$AAt?$AAe?$AAr?$AAa?$AAt?$AAo?$AAr?$AA?5?$AA?$CL?$AA?5?$AAo?$AAf?$AAf?$AAs?$AAe?$AAt?$AA?5?$AAo?$AAu?$AAt?$AA?5?$AAo?$AAf?$AA?5@ ; "string iterator + offset out of range"
.text$mn:0000882E                 call    ?_Debug_message@std@@YAXPB_W0I@Z ; std::_Debug_message(wchar_t const *,wchar_t const *,uint)
.text$mn:00008833                 add     esp, 0Ch
.text$mn:00008836                 mov     edx, offset ??_C@_0CE@OFMIGAMM@Standard?5C?$CL?$CL?5Libraries?5Out?5of?5Ra@ ; "Standard C++ Libraries Out of Range"
.text$mn:0000883B                 test    edx, edx
.text$mn:0000883D                 jz      short loc_8843
.text$mn:0000883F                 xor     eax, eax
.text$mn:00008841                 jnz     short loc_8869
.text$mn:00008843
.text$mn:00008843 loc_8843:                               ; CODE XREF: std::_String_const_iterator<std::_String_val<std::_Simple_types<wchar_t>>>::operator+=(int)+89j
.text$mn:00008843                 push    offset ??_C@_1FG@IBPIFFN@?$AA?$CC?$AAS?$AAt?$AAa?$AAn?$AAd?$AAa?$AAr?$AAd?$AA?5?$AAC?$AA?$CL?$AA?$CL?$AA?5?$AAL?$AAi?$AAb?$AAr?$AAa?$AAr?$AAi?$AAe?$AAs?$AA?5?$AAO?$AAu?$AAt?$AA?5?$AAo?$AAf?$AA?5?$AAR@ ; "\"Standard C++ Libraries Out of Range\""...
.text$mn:00008848                 push    offset ??_C@_15GANGMFKL@?$AA?$CF?$AAs?$AA?$AA@ ; "%s"
.text$mn:0000884D                 push    0
.text$mn:0000884F                 push    0A9h ; '¬'
.text$mn:00008854                 push    offset ??_C@_1IO@FEAPGJBD@?$AAC?$AA?3?$AA?2?$AAP?$AAr?$AAo?$AAg?$AAr?$AAa?$AAm?$AA?5?$AAF?$AAi?$AAl?$AAe?$AAs?$AA?5?$AA?$CI?$AAx?$AA8?$AA6?$AA?$CJ?$AA?2?$AAM?$AAi?$AAc?$AAr?$AAo?$AAs?$AAo?$AAf?$AAt@ ; "C:\\Program Files (x86)\\Microsoft Visu"...
.text$mn:00008859                 push    2
.text$mn:0000885B                 call    __CrtDbgReportW
.text$mn:00008860                 add     esp, 18h
.text$mn:00008863                 cmp     eax, 1
.text$mn:00008866                 jnz     short loc_8869
.text$mn:00008868                 int     3               ; Trap to Debugger
.text$mn:00008869
.text$mn:00008869 loc_8869:                               ; CODE XREF: std::_String_const_iterator<std::_String_val<std::_Simple_types<wchar_t>>>::operator+=(int)+8Dj
.text$mn:00008869                                         ; std::_String_const_iterator<std::_String_val<std::_Simple_types<wchar_t>>>::operator+=(int)+B2j
.text$mn:00008869                 push    0
.text$mn:0000886B                 push    0A9h ; '¬'
.text$mn:00008870                 push    offset ??_C@_1IO@FEAPGJBD@?$AAC?$AA?3?$AA?2?$AAP?$AAr?$AAo?$AAg?$AAr?$AAa?$AAm?$AA?5?$AAF?$AAi?$AAl?$AAe?$AAs?$AA?5?$AA?$CI?$AAx?$AA8?$AA6?$AA?$CJ?$AA?2?$AAM?$AAi?$AAc?$AAr?$AAo?$AAs?$AAo?$AAf?$AAt@ ; "C:\\Program Files (x86)\\Microsoft Visu"...
.text$mn:00008875                 push    offset ??_C@_1MO@BFIEDEJC@?$AAs?$AAt?$AAd?$AA?3?$AA?3?$AA_?$AAS?$AAt?$AAr?$AAi?$AAn?$AAg?$AA_?$AAc?$AAo?$AAn?$AAs?$AAt?$AA_?$AAi?$AAt?$AAe?$AAr?$AAa?$AAt?$AAo?$AAr?$AA?$DM?$AAc?$AAl?$AAa?$AAs@ ; "std::_String_const_iterator<class std::"...
.text$mn:0000887A                 push    offset ??_C@_1BO@MEPPHOO@?$AA?$CC?$AAo?$AAu?$AAt?$AA?5?$AAo?$AAf?$AA?5?$AAr?$AAa?$AAn?$AAg?$AAe?$AA?$CC?$AA?$AA@ ; "\"out of range\""
.text$mn:0000887F                 call    __invalid_parameter
.text$mn:00008884                 add     esp, 14h
.text$mn:00008887
.text$mn:00008887 loc_8887:                               ; CODE XREF: std::_String_const_iterator<std::_String_val<std::_Simple_types<wchar_t>>>::operator+=(int)+69j
.text$mn:00008887                 mov     edx, [ebp+var_4]
.text$mn:0000888A                 mov     eax, [edx+8]
.text$mn:0000888D                 mov     ecx, [ebp+arg_0]
.text$mn:00008890                 lea     edx, [eax+ecx*2]
.text$mn:00008893                 mov     eax, [ebp+var_4]
.text$mn:00008896                 mov     [eax+8], edx
.text$mn:00008899                 mov     eax, [ebp+var_4]
.text$mn:0000889C                 pop     esi
.text$mn:0000889D                 mov     esp, ebp
.text$mn:0000889F                 pop     ebp
.text$mn:000088A0                 retn    4
.text$mn:000088A0 ??Y?$_String_const_iterator@V?$_String_val@U?$_Simple_types@_W@std@@@std@@@std@@QAEAAV01@H@Z endp
.text$mn:000088A0
.text$mn:000088A0 ; ---------------------------------------------------------------------------
.text$mn:000088A3                 align 4
.text$mn:000088A3 _text$mn        ends
.text$mn:000088A3
.text$mn:000088A4 ; ===========================================================================
.text$mn:000088A4
.text$mn:000088A4 ; Segment type: Pure code
.text$mn:000088A4 ; Segment permissions: Read/Execute
.text$mn:000088A4 _text$mn        segment para public 'CODE' use32
.text$mn:000088A4                 assume cs:_text$mn
.text$mn:000088A4                 ;org 88A4h
.text$mn:000088A4 ; COMDAT (pick any)
.text$mn:000088A4                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text$mn:000088A4
.text$mn:000088A4 ; =============== S U B R O U T I N E =======================================
.text$mn:000088A4
.text$mn:000088A4 ; Attributes: bp-based frame
.text$mn:000088A4
.text$mn:000088A4 ; public: class std::_String_iterator<class std::_String_val<struct std::_Simple_types<wchar_t>>> & __thiscall std::_String_iterator<class std::_String_val<struct std::_Simple_types<wchar_t>>>::operator+=(int)
.text$mn:000088A4                 public ??Y?$_String_iterator@V?$_String_val@U?$_Simple_types@_W@std@@@std@@@std@@QAEAAV01@H@Z
.text$mn:000088A4 ??Y?$_String_iterator@V?$_String_val@U?$_Simple_types@_W@std@@@std@@@std@@QAEAAV01@H@Z proc near
.text$mn:000088A4                                         ; CODE XREF: std::_String_iterator<std::_String_val<std::_Simple_types<wchar_t>>>::operator+(int)+49p
.text$mn:000088A4
.text$mn:000088A4 var_4           = dword ptr -4
.text$mn:000088A4 arg_0           = dword ptr  8
.text$mn:000088A4
.text$mn:000088A4                 push    ebp
.text$mn:000088A5                 mov     ebp, esp
.text$mn:000088A7                 push    ecx
.text$mn:000088A8                 mov     [ebp+var_4], ecx
.text$mn:000088AB                 mov     eax, [ebp+arg_0]
.text$mn:000088AE                 push    eax
.text$mn:000088AF                 mov     ecx, [ebp+var_4]
.text$mn:000088B2                 call    ??Y?$_String_const_iterator@V?$_String_val@U?$_Simple_types@_W@std@@@std@@@std@@QAEAAV01@H@Z ; std::_String_const_iterator<std::_String_val<std::_Simple_types<wchar_t>>>::operator+=(int)
.text$mn:000088B7                 mov     eax, [ebp+var_4]
.text$mn:000088BA                 mov     esp, ebp
.text$mn:000088BC                 pop     ebp
.text$mn:000088BD                 retn    4
.text$mn:000088BD ??Y?$_String_iterator@V?$_String_val@U?$_Simple_types@_W@std@@@std@@@std@@QAEAAV01@H@Z endp
.text$mn:000088BD
.text$mn:000088BD _text$mn        ends
.text$mn:000088BD
.text$mn:000088C0 ; ===========================================================================
.text$mn:000088C0
.text$mn:000088C0 ; Segment type: Pure code
.text$mn:000088C0 ; Segment permissions: Read/Execute
.text$mn:000088C0 _text$mn        segment para public 'CODE' use32
.text$mn:000088C0                 assume cs:_text$mn
.text$mn:000088C0                 ;org 88C0h
.text$mn:000088C0 ; COMDAT (pick any)
.text$mn:000088C0                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text$mn:000088C0
.text$mn:000088C0 ; =============== S U B R O U T I N E =======================================
.text$mn:000088C0
.text$mn:000088C0 ; Attributes: bp-based frame
.text$mn:000088C0
.text$mn:000088C0 ; public: class std::_Vector_const_iterator<class std::_Vector_val<struct std::_Simple_types<wchar_t>>> & __thiscall std::_Vector_const_iterator<class std::_Vector_val<struct std::_Simple_types<wchar_t>>>::operator+=(int)
.text$mn:000088C0                 public ??Y?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@_W@std@@@std@@@std@@QAEAAV01@H@Z
.text$mn:000088C0 ??Y?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@_W@std@@@std@@@std@@QAEAAV01@H@Z proc near
.text$mn:000088C0                                         ; CODE XREF: std::_Vector_iterator<std::_Vector_val<std::_Simple_types<wchar_t>>>::operator+=(int)+Ep
.text$mn:000088C0
.text$mn:000088C0 var_4           = dword ptr -4
.text$mn:000088C0 arg_0           = dword ptr  8
.text$mn:000088C0
.text$mn:000088C0                 push    ebp
.text$mn:000088C1                 mov     ebp, esp
.text$mn:000088C3                 push    ecx
.text$mn:000088C4                 push    esi
.text$mn:000088C5                 mov     [ebp+var_4], ecx
.text$mn:000088C8                 mov     ecx, [ebp+var_4] ; this
.text$mn:000088CB                 call    ?_Getcont@_Iterator_base12@std@@QBEPBU_Container_base12@2@XZ ; std::_Iterator_base12::_Getcont(void)
.text$mn:000088D0                 test    eax, eax
.text$mn:000088D2                 jz      short loc_8906
.text$mn:000088D4                 mov     eax, [ebp+var_4]
.text$mn:000088D7                 mov     ecx, [eax+8]
.text$mn:000088DA                 mov     edx, [ebp+arg_0]
.text$mn:000088DD                 lea     esi, [ecx+edx*2]
.text$mn:000088E0                 mov     ecx, [ebp+var_4] ; this
.text$mn:000088E3                 call    ?_Getcont@_Iterator_base12@std@@QBEPBU_Container_base12@2@XZ ; std::_Iterator_base12::_Getcont(void)
.text$mn:000088E8                 cmp     esi, [eax+4]
.text$mn:000088EB                 jb      short loc_8906
.text$mn:000088ED                 mov     ecx, [ebp+var_4] ; this
.text$mn:000088F0                 call    ?_Getcont@_Iterator_base12@std@@QBEPBU_Container_base12@2@XZ ; std::_Iterator_base12::_Getcont(void)
.text$mn:000088F5                 mov     ecx, [ebp+var_4]
.text$mn:000088F8                 mov     edx, [ecx+8]
.text$mn:000088FB                 mov     ecx, [ebp+arg_0]
.text$mn:000088FE                 lea     edx, [edx+ecx*2]
.text$mn:00008901                 cmp     [eax+8], edx
.text$mn:00008904                 jnb     short loc_896E
.text$mn:00008906
.text$mn:00008906 loc_8906:                               ; CODE XREF: std::_Vector_const_iterator<std::_Vector_val<std::_Simple_types<wchar_t>>>::operator+=(int)+12j
.text$mn:00008906                                         ; std::_Vector_const_iterator<std::_Vector_val<std::_Simple_types<wchar_t>>>::operator+=(int)+2Bj
.text$mn:00008906                 push    9Fh ; 'ƒ'       ; unsigned int
.text$mn:0000890B                 push    offset ??_C@_1IM@EINEHPHE@?$AAC?$AA?3?$AA?2?$AAP?$AAr?$AAo?$AAg?$AAr?$AAa?$AAm?$AA?5?$AAF?$AAi?$AAl?$AAe?$AAs?$AA?5?$AA?$CI?$AAx?$AA8?$AA6?$AA?$CJ?$AA?2?$AAM?$AAi?$AAc?$AAr?$AAo?$AAs?$AAo?$AAf?$AAt@ ; "C:\\Program Files (x86)\\Microsoft Visu"...
.text$mn:00008910                 push    offset ??_C@_1EM@FKAOCOMF@?$AAv?$AAe?$AAc?$AAt?$AAo?$AAr?$AA?5?$AAi?$AAt?$AAe?$AAr?$AAa?$AAt?$AAo?$AAr?$AA?5?$AA?$CL?$AA?5?$AAo?$AAf?$AAf?$AAs?$AAe?$AAt?$AA?5?$AAo?$AAu?$AAt?$AA?5?$AAo?$AAf?$AA?5@ ; "vector iterator + offset out of range"
.text$mn:00008915                 call    ?_Debug_message@std@@YAXPB_W0I@Z ; std::_Debug_message(wchar_t const *,wchar_t const *,uint)
.text$mn:0000891A                 add     esp, 0Ch
.text$mn:0000891D                 mov     eax, offset ??_C@_0CE@OFMIGAMM@Standard?5C?$CL?$CL?5Libraries?5Out?5of?5Ra@ ; "Standard C++ Libraries Out of Range"
.text$mn:00008922                 test    eax, eax
.text$mn:00008924                 jz      short loc_892A
.text$mn:00008926                 xor     ecx, ecx
.text$mn:00008928                 jnz     short loc_8950
.text$mn:0000892A
.text$mn:0000892A loc_892A:                               ; CODE XREF: std::_Vector_const_iterator<std::_Vector_val<std::_Simple_types<wchar_t>>>::operator+=(int)+64j
.text$mn:0000892A                 push    offset ??_C@_1FG@IBPIFFN@?$AA?$CC?$AAS?$AAt?$AAa?$AAn?$AAd?$AAa?$AAr?$AAd?$AA?5?$AAC?$AA?$CL?$AA?$CL?$AA?5?$AAL?$AAi?$AAb?$AAr?$AAa?$AAr?$AAi?$AAe?$AAs?$AA?5?$AAO?$AAu?$AAt?$AA?5?$AAo?$AAf?$AA?5?$AAR@ ; "\"Standard C++ Libraries Out of Range\""...
.text$mn:0000892F                 push    offset ??_C@_15GANGMFKL@?$AA?$CF?$AAs?$AA?$AA@ ; "%s"
.text$mn:00008934                 push    0
.text$mn:00008936                 push    0A0h ; 'á'
.text$mn:0000893B                 push    offset ??_C@_1IM@EINEHPHE@?$AAC?$AA?3?$AA?2?$AAP?$AAr?$AAo?$AAg?$AAr?$AAa?$AAm?$AA?5?$AAF?$AAi?$AAl?$AAe?$AAs?$AA?5?$AA?$CI?$AAx?$AA8?$AA6?$AA?$CJ?$AA?2?$AAM?$AAi?$AAc?$AAr?$AAo?$AAs?$AAo?$AAf?$AAt@ ; "C:\\Program Files (x86)\\Microsoft Visu"...
.text$mn:00008940                 push    2
.text$mn:00008942                 call    __CrtDbgReportW
.text$mn:00008947                 add     esp, 18h
.text$mn:0000894A                 cmp     eax, 1
.text$mn:0000894D                 jnz     short loc_8950
.text$mn:0000894F                 int     3               ; Trap to Debugger
.text$mn:00008950
.text$mn:00008950 loc_8950:                               ; CODE XREF: std::_Vector_const_iterator<std::_Vector_val<std::_Simple_types<wchar_t>>>::operator+=(int)+68j
.text$mn:00008950                                         ; std::_Vector_const_iterator<std::_Vector_val<std::_Simple_types<wchar_t>>>::operator+=(int)+8Dj
.text$mn:00008950                 push    0
.text$mn:00008952                 push    0A0h ; 'á'
.text$mn:00008957                 push    offset ??_C@_1IM@EINEHPHE@?$AAC?$AA?3?$AA?2?$AAP?$AAr?$AAo?$AAg?$AAr?$AAa?$AAm?$AA?5?$AAF?$AAi?$AAl?$AAe?$AAs?$AA?5?$AA?$CI?$AAx?$AA8?$AA6?$AA?$CJ?$AA?2?$AAM?$AAi?$AAc?$AAr?$AAo?$AAs?$AAo?$AAf?$AAt@ ; "C:\\Program Files (x86)\\Microsoft Visu"...
.text$mn:0000895C                 push    offset ??_C@_1MO@IIMGPDGH@?$AAs?$AAt?$AAd?$AA?3?$AA?3?$AA_?$AAV?$AAe?$AAc?$AAt?$AAo?$AAr?$AA_?$AAc?$AAo?$AAn?$AAs?$AAt?$AA_?$AAi?$AAt?$AAe?$AAr?$AAa?$AAt?$AAo?$AAr?$AA?$DM?$AAc?$AAl?$AAa?$AAs@ ; "std::_Vector_const_iterator<class std::"...
.text$mn:00008961                 push    offset ??_C@_1BO@MEPPHOO@?$AA?$CC?$AAo?$AAu?$AAt?$AA?5?$AAo?$AAf?$AA?5?$AAr?$AAa?$AAn?$AAg?$AAe?$AA?$CC?$AA?$AA@ ; "\"out of range\""
.text$mn:00008966                 call    __invalid_parameter
.text$mn:0000896B                 add     esp, 14h
.text$mn:0000896E
.text$mn:0000896E loc_896E:                               ; CODE XREF: std::_Vector_const_iterator<std::_Vector_val<std::_Simple_types<wchar_t>>>::operator+=(int)+44j
.text$mn:0000896E                 mov     eax, [ebp+var_4]
.text$mn:00008971                 mov     ecx, [eax+8]
.text$mn:00008974                 mov     edx, [ebp+arg_0]
.text$mn:00008977                 lea     eax, [ecx+edx*2]
.text$mn:0000897A                 mov     ecx, [ebp+var_4]
.text$mn:0000897D                 mov     [ecx+8], eax
.text$mn:00008980                 mov     eax, [ebp+var_4]
.text$mn:00008983                 pop     esi
.text$mn:00008984                 mov     esp, ebp
.text$mn:00008986                 pop     ebp
.text$mn:00008987                 retn    4
.text$mn:00008987 ??Y?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@_W@std@@@std@@@std@@QAEAAV01@H@Z endp
.text$mn:00008987
.text$mn:00008987 ; ---------------------------------------------------------------------------
.text$mn:0000898A                 align 4
.text$mn:0000898A _text$mn        ends
.text$mn:0000898A
.text$mn:0000898C ; ===========================================================================
.text$mn:0000898C
.text$mn:0000898C ; Segment type: Pure code
.text$mn:0000898C ; Segment permissions: Read/Execute
.text$mn:0000898C _text$mn        segment para public 'CODE' use32
.text$mn:0000898C                 assume cs:_text$mn
.text$mn:0000898C                 ;org 898Ch
.text$mn:0000898C ; COMDAT (pick any)
.text$mn:0000898C                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text$mn:0000898C
.text$mn:0000898C ; =============== S U B R O U T I N E =======================================
.text$mn:0000898C
.text$mn:0000898C ; Attributes: bp-based frame
.text$mn:0000898C
.text$mn:0000898C ; public: class std::_Vector_iterator<class std::_Vector_val<struct std::_Simple_types<wchar_t>>> & __thiscall std::_Vector_iterator<class std::_Vector_val<struct std::_Simple_types<wchar_t>>>::operator+=(int)
.text$mn:0000898C                 public ??Y?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@_W@std@@@std@@@std@@QAEAAV01@H@Z
.text$mn:0000898C ??Y?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@_W@std@@@std@@@std@@QAEAAV01@H@Z proc near
.text$mn:0000898C                                         ; CODE XREF: std::_Vector_iterator<std::_Vector_val<std::_Simple_types<wchar_t>>>::operator+(int)+49p
.text$mn:0000898C
.text$mn:0000898C var_4           = dword ptr -4
.text$mn:0000898C arg_0           = dword ptr  8
.text$mn:0000898C
.text$mn:0000898C                 push    ebp
.text$mn:0000898D                 mov     ebp, esp
.text$mn:0000898F                 push    ecx
.text$mn:00008990                 mov     [ebp+var_4], ecx
.text$mn:00008993                 mov     eax, [ebp+arg_0]
.text$mn:00008996                 push    eax
.text$mn:00008997                 mov     ecx, [ebp+var_4]
.text$mn:0000899A                 call    ??Y?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@_W@std@@@std@@@std@@QAEAAV01@H@Z ; std::_Vector_const_iterator<std::_Vector_val<std::_Simple_types<wchar_t>>>::operator+=(int)
.text$mn:0000899F                 mov     eax, [ebp+var_4]
.text$mn:000089A2                 mov     esp, ebp
.text$mn:000089A4                 pop     ebp
.text$mn:000089A5                 retn    4
.text$mn:000089A5 ??Y?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@_W@std@@@std@@@std@@QAEAAV01@H@Z endp
.text$mn:000089A5
.text$mn:000089A5 _text$mn        ends
.text$mn:000089A5
.text$mn:000089A8 ; ===========================================================================
.text$mn:000089A8
.text$mn:000089A8 ; Segment type: Pure code
.text$mn:000089A8 ; Segment permissions: Read/Execute
.text$mn:000089A8 _text$mn        segment para public 'CODE' use32
.text$mn:000089A8                 assume cs:_text$mn
.text$mn:000089A8                 ;org 89A8h
.text$mn:000089A8 ; COMDAT (pick any)
.text$mn:000089A8                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text$mn:000089A8
.text$mn:000089A8 ; =============== S U B R O U T I N E =======================================
.text$mn:000089A8
.text$mn:000089A8 ; Attributes: bp-based frame
.text$mn:000089A8
.text$mn:000089A8 ; int __stdcall std::basic_string<char,std::char_traits<char>,std::allocator<char>>::operator+=(char *Str)
.text$mn:000089A8                 public ??Y?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV01@PBD@Z
.text$mn:000089A8 ??Y?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV01@PBD@Z proc near
.text$mn:000089A8                                         ; CODE XREF: getFileContent(wchar_t const *)+122p
.text$mn:000089A8
.text$mn:000089A8 var_4           = dword ptr -4
.text$mn:000089A8 Str             = dword ptr  8
.text$mn:000089A8
.text$mn:000089A8                 push    ebp
.text$mn:000089A9                 mov     ebp, esp
.text$mn:000089AB                 push    ecx
.text$mn:000089AC                 mov     [ebp+var_4], ecx
.text$mn:000089AF                 mov     eax, [ebp+Str]
.text$mn:000089B2                 push    eax             ; Str
.text$mn:000089B3                 mov     ecx, [ebp+var_4]
.text$mn:000089B6                 call    ?append@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV12@PBD@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char>>::append(char const *)
.text$mn:000089BB                 mov     esp, ebp
.text$mn:000089BD                 pop     ebp
.text$mn:000089BE                 retn    4
.text$mn:000089BE ??Y?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV01@PBD@Z endp
.text$mn:000089BE
.text$mn:000089BE ; ---------------------------------------------------------------------------
.text$mn:000089C1                 align 4
.text$mn:000089C1 _text$mn        ends
.text$mn:000089C1
.text$mn:000089C4 ; ===========================================================================
.text$mn:000089C4
.text$mn:000089C4 ; Segment type: Pure code
.text$mn:000089C4 ; Segment permissions: Read/Execute
.text$mn:000089C4 _text$mn        segment para public 'CODE' use32
.text$mn:000089C4                 assume cs:_text$mn
.text$mn:000089C4                 ;org 89C4h
.text$mn:000089C4 ; COMDAT (pick any)
.text$mn:000089C4                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text$mn:000089C4
.text$mn:000089C4 ; =============== S U B R O U T I N E =======================================
.text$mn:000089C4
.text$mn:000089C4 ; Attributes: bp-based frame
.text$mn:000089C4
.text$mn:000089C4 ; public: class std::basic_string<wchar_t, struct std::char_traits<wchar_t>, class std::allocator<wchar_t>> & __thiscall std::basic_string<wchar_t, struct std::char_traits<wchar_t>, class std::allocator<wchar_t>>::operator+=(class std::basic_string<wchar_t, struct std::char_traits<wchar_t>, class std::allocator<wchar_t>> const &)
.text$mn:000089C4                 public ??Y?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QAEAAV01@ABV01@@Z
.text$mn:000089C4 ??Y?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QAEAAV01@ABV01@@Z proc near
.text$mn:000089C4                                         ; CODE XREF: PathAppendW(std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>> &,std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>> const &)+14Ep
.text$mn:000089C4                                         ; PathAppendW(std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>> &,std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>> const &)+20Ap ...
.text$mn:000089C4
.text$mn:000089C4 var_4           = dword ptr -4
.text$mn:000089C4 arg_0           = dword ptr  8
.text$mn:000089C4
.text$mn:000089C4                 push    ebp
.text$mn:000089C5                 mov     ebp, esp
.text$mn:000089C7                 push    ecx
.text$mn:000089C8                 mov     [ebp+var_4], ecx
.text$mn:000089CB                 mov     eax, [ebp+arg_0]
.text$mn:000089CE                 push    eax
.text$mn:000089CF                 mov     ecx, [ebp+var_4]
.text$mn:000089D2                 call    ?append@?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QAEAAV12@ABV12@@Z ; std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>>::append(std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>> const &)
.text$mn:000089D7                 mov     esp, ebp
.text$mn:000089D9                 pop     ebp
.text$mn:000089DA                 retn    4
.text$mn:000089DA ??Y?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QAEAAV01@ABV01@@Z endp
.text$mn:000089DA
.text$mn:000089DA ; ---------------------------------------------------------------------------
.text$mn:000089DD                 align 10h
.text$mn:000089DD _text$mn        ends
.text$mn:000089DD
.text$mn:000089E0 ; ===========================================================================
.text$mn:000089E0
.text$mn:000089E0 ; Segment type: Pure code
.text$mn:000089E0 ; Segment permissions: Read/Execute
.text$mn:000089E0 _text$mn        segment para public 'CODE' use32
.text$mn:000089E0                 assume cs:_text$mn
.text$mn:000089E0                 ;org 89E0h
.text$mn:000089E0 ; COMDAT (pick any)
.text$mn:000089E0                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text$mn:000089E0
.text$mn:000089E0 ; =============== S U B R O U T I N E =======================================
.text$mn:000089E0
.text$mn:000089E0 ; Attributes: bp-based frame
.text$mn:000089E0
.text$mn:000089E0 ; int __stdcall std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>>::operator+=(wchar_t *Str)
.text$mn:000089E0                 public ??Y?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QAEAAV01@PB_W@Z
.text$mn:000089E0 ??Y?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QAEAAV01@PB_W@Z proc near
.text$mn:000089E0                                         ; CODE XREF: relativeFilePathToFullFilePath(wchar_t const *)+8Ap
.text$mn:000089E0                                         ; relativeFilePathToFullFilePath(wchar_t const *)+FAp ...
.text$mn:000089E0
.text$mn:000089E0 var_4           = dword ptr -4
.text$mn:000089E0 Str             = dword ptr  8
.text$mn:000089E0
.text$mn:000089E0                 push    ebp
.text$mn:000089E1                 mov     ebp, esp
.text$mn:000089E3                 push    ecx
.text$mn:000089E4                 mov     [ebp+var_4], ecx
.text$mn:000089E7                 mov     eax, [ebp+Str]
.text$mn:000089EA                 push    eax             ; Str
.text$mn:000089EB                 mov     ecx, [ebp+var_4]
.text$mn:000089EE                 call    ?append@?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QAEAAV12@PB_W@Z ; std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>>::append(wchar_t const *)
.text$mn:000089F3                 mov     esp, ebp
.text$mn:000089F5                 pop     ebp
.text$mn:000089F6                 retn    4
.text$mn:000089F6 ??Y?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QAEAAV01@PB_W@Z endp
.text$mn:000089F6
.text$mn:000089F6 ; ---------------------------------------------------------------------------
.text$mn:000089F9                 align 4
.text$mn:000089F9 _text$mn        ends
.text$mn:000089F9
.text$mn:000089FC ; ===========================================================================
.text$mn:000089FC
.text$mn:000089FC ; Segment type: Pure code
.text$mn:000089FC ; Segment permissions: Read/Execute
.text$mn:000089FC _text$mn        segment para public 'CODE' use32
.text$mn:000089FC                 assume cs:_text$mn
.text$mn:000089FC                 ;org 89FCh
.text$mn:000089FC ; COMDAT (pick any)
.text$mn:000089FC                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text$mn:000089FC
.text$mn:000089FC ; =============== S U B R O U T I N E =======================================
.text$mn:000089FC
.text$mn:000089FC ; Attributes: bp-based frame
.text$mn:000089FC
.text$mn:000089FC ; public: class std::basic_string<wchar_t, struct std::char_traits<wchar_t>, class std::allocator<wchar_t>> & __thiscall std::basic_string<wchar_t, struct std::char_traits<wchar_t>, class std::allocator<wchar_t>>::operator+=(wchar_t)
.text$mn:000089FC                 public ??Y?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QAEAAV01@_W@Z
.text$mn:000089FC ??Y?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QAEAAV01@_W@Z proc near
.text$mn:000089FC                                         ; CODE XREF: relativeFilePathToFullFilePath(wchar_t const *)+DEp
.text$mn:000089FC                                         ; relativeFilePathToFullFilePath(wchar_t const *)+EBp
.text$mn:000089FC
.text$mn:000089FC var_4           = dword ptr -4
.text$mn:000089FC arg_0           = word ptr  8
.text$mn:000089FC
.text$mn:000089FC                 push    ebp
.text$mn:000089FD                 mov     ebp, esp
.text$mn:000089FF                 push    ecx
.text$mn:00008A00                 mov     [ebp+var_4], ecx
.text$mn:00008A03                 movzx   eax, [ebp+arg_0]
.text$mn:00008A07                 push    eax
.text$mn:00008A08                 push    1
.text$mn:00008A0A                 mov     ecx, [ebp+var_4]
.text$mn:00008A0D                 call    ?append@?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QAEAAV12@I_W@Z ; std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>>::append(uint,wchar_t)
.text$mn:00008A12                 mov     esp, ebp
.text$mn:00008A14                 pop     ebp
.text$mn:00008A15                 retn    4
.text$mn:00008A15 ??Y?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QAEAAV01@_W@Z endp
.text$mn:00008A15
.text$mn:00008A15 _text$mn        ends
.text$mn:00008A15
.text$mn:00008A18 ; ===========================================================================
.text$mn:00008A18
.text$mn:00008A18 ; Segment type: Pure code
.text$mn:00008A18 ; Segment permissions: Read/Execute
.text$mn:00008A18 _text$mn        segment para public 'CODE' use32
.text$mn:00008A18                 assume cs:_text$mn
.text$mn:00008A18                 ;org 8A18h
.text$mn:00008A18 ; COMDAT (pick any)
.text$mn:00008A18                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text$mn:00008A18
.text$mn:00008A18 ; =============== S U B R O U T I N E =======================================
.text$mn:00008A18
.text$mn:00008A18 ; Attributes: bp-based frame
.text$mn:00008A18
.text$mn:00008A18 ; public: class std::_String_const_iterator<class std::_String_val<struct std::_Simple_types<wchar_t>>> & __thiscall std::_String_const_iterator<class std::_String_val<struct std::_Simple_types<wchar_t>>>::operator-=(int)
.text$mn:00008A18                 public ??Z?$_String_const_iterator@V?$_String_val@U?$_Simple_types@_W@std@@@std@@@std@@QAEAAV01@H@Z
.text$mn:00008A18 ??Z?$_String_const_iterator@V?$_String_val@U?$_Simple_types@_W@std@@@std@@@std@@QAEAAV01@H@Z proc near
.text$mn:00008A18                                         ; CODE XREF: std::_String_const_iterator<std::_String_val<std::_Simple_types<wchar_t>>>::operator-(int)+49p
.text$mn:00008A18
.text$mn:00008A18 var_4           = dword ptr -4
.text$mn:00008A18 arg_0           = dword ptr  8
.text$mn:00008A18
.text$mn:00008A18                 push    ebp
.text$mn:00008A19                 mov     ebp, esp
.text$mn:00008A1B                 push    ecx
.text$mn:00008A1C                 mov     [ebp+var_4], ecx
.text$mn:00008A1F                 mov     eax, [ebp+arg_0]
.text$mn:00008A22                 neg     eax
.text$mn:00008A24                 push    eax
.text$mn:00008A25                 mov     ecx, [ebp+var_4]
.text$mn:00008A28                 call    ??Y?$_String_const_iterator@V?$_String_val@U?$_Simple_types@_W@std@@@std@@@std@@QAEAAV01@H@Z ; std::_String_const_iterator<std::_String_val<std::_Simple_types<wchar_t>>>::operator+=(int)
.text$mn:00008A2D                 mov     esp, ebp
.text$mn:00008A2F                 pop     ebp
.text$mn:00008A30                 retn    4
.text$mn:00008A30 ??Z?$_String_const_iterator@V?$_String_val@U?$_Simple_types@_W@std@@@std@@@std@@QAEAAV01@H@Z endp
.text$mn:00008A30
.text$mn:00008A30 ; ---------------------------------------------------------------------------
.text$mn:00008A33                 align 4
.text$mn:00008A33 _text$mn        ends
.text$mn:00008A33
.text$mn:00008A34 ; ===========================================================================
.text$mn:00008A34
.text$mn:00008A34 ; Segment type: Pure code
.text$mn:00008A34 ; Segment permissions: Read/Execute
.text$mn:00008A34 _text$mn        segment para public 'CODE' use32
.text$mn:00008A34                 assume cs:_text$mn
.text$mn:00008A34                 ;org 8A34h
.text$mn:00008A34 ; COMDAT (pick any)
.text$mn:00008A34                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text$mn:00008A34
.text$mn:00008A34 ; =============== S U B R O U T I N E =======================================
.text$mn:00008A34
.text$mn:00008A34 ; Attributes: bp-based frame
.text$mn:00008A34
.text$mn:00008A34 ; public: void * __thiscall std::basic_string<wchar_t, struct std::char_traits<wchar_t>, class std::allocator<wchar_t>>::`scalar deleting destructor'(unsigned int)
.text$mn:00008A34                 public ??_G?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QAEPAXI@Z
.text$mn:00008A34 ??_G?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QAEPAXI@Z proc near
.text$mn:00008A34                                         ; CODE XREF: std::allocator<std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>>>::destroy<std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>>>(std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>> *)+Cp
.text$mn:00008A34
.text$mn:00008A34 var_4           = dword ptr -4
.text$mn:00008A34 arg_0           = dword ptr  8
.text$mn:00008A34
.text$mn:00008A34                 push    ebp
.text$mn:00008A35                 mov     ebp, esp
.text$mn:00008A37                 push    ecx
.text$mn:00008A38                 mov     [ebp+var_4], ecx
.text$mn:00008A3B                 mov     ecx, [ebp+var_4]
.text$mn:00008A3E                 call    ??1?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QAE@XZ ; std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>>::~basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>>(void)
.text$mn:00008A43                 mov     eax, [ebp+arg_0]
.text$mn:00008A46                 and     eax, 1
.text$mn:00008A49                 jz      short loc_8A57
.text$mn:00008A4B                 mov     ecx, [ebp+var_4]
.text$mn:00008A4E                 push    ecx             ; void *
.text$mn:00008A4F                 call    ??3@YAXPAX@Z    ; operator delete(void *)
.text$mn:00008A54                 add     esp, 4
.text$mn:00008A57
.text$mn:00008A57 loc_8A57:                               ; CODE XREF: std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>>::`scalar deleting destructor'(uint)+15j
.text$mn:00008A57                 mov     eax, [ebp+var_4]
.text$mn:00008A5A                 mov     esp, ebp
.text$mn:00008A5C                 pop     ebp
.text$mn:00008A5D                 retn    4
.text$mn:00008A5D ??_G?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QAEPAXI@Z endp
.text$mn:00008A5D
.text$mn:00008A5D _text$mn        ends
.text$mn:00008A5D
.text$mn:00008A60 ; ===========================================================================
.text$mn:00008A60
.text$mn:00008A60 ; Segment type: Pure code
.text$mn:00008A60 ; Segment permissions: Read/Execute
.text$mn:00008A60 _text$mn        segment para public 'CODE' use32
.text$mn:00008A60                 assume cs:_text$mn
.text$mn:00008A60                 ;org 8A60h
.text$mn:00008A60 ; COMDAT (pick any)
.text$mn:00008A60                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text$mn:00008A60
.text$mn:00008A60 ; =============== S U B R O U T I N E =======================================
.text$mn:00008A60
.text$mn:00008A60 ; Attributes: bp-based frame
.text$mn:00008A60
.text$mn:00008A60 ; public: virtual void * __thiscall std::_Generic_error_category::`scalar deleting destructor'(unsigned int)
.text$mn:00008A60                 public ??_G_Generic_error_category@std@@UAEPAXI@Z
.text$mn:00008A60 ??_G_Generic_error_category@std@@UAEPAXI@Z proc near
.text$mn:00008A60
.text$mn:00008A60 var_4           = dword ptr -4
.text$mn:00008A60 arg_0           = dword ptr  8
.text$mn:00008A60
.text$mn:00008A60                 push    ebp
.text$mn:00008A61                 mov     ebp, esp
.text$mn:00008A63                 push    ecx
.text$mn:00008A64                 mov     [ebp+var_4], ecx
.text$mn:00008A67                 mov     ecx, [ebp+var_4] ; this
.text$mn:00008A6A                 call    ??1_Generic_error_category@std@@UAE@XZ ; std::_Generic_error_category::~_Generic_error_category(void)
.text$mn:00008A6F                 mov     eax, [ebp+arg_0]
.text$mn:00008A72                 and     eax, 1
.text$mn:00008A75                 jz      short loc_8A83
.text$mn:00008A77                 mov     ecx, [ebp+var_4]
.text$mn:00008A7A                 push    ecx             ; void *
.text$mn:00008A7B                 call    ??3@YAXPAX@Z    ; operator delete(void *)
.text$mn:00008A80                 add     esp, 4
.text$mn:00008A83
.text$mn:00008A83 loc_8A83:                               ; CODE XREF: std::_Generic_error_category::`scalar deleting destructor'(uint)+15j
.text$mn:00008A83                 mov     eax, [ebp+var_4]
.text$mn:00008A86                 mov     esp, ebp
.text$mn:00008A88                 pop     ebp
.text$mn:00008A89                 retn    4
.text$mn:00008A89 ??_G_Generic_error_category@std@@UAEPAXI@Z endp
.text$mn:00008A89
.text$mn:00008A89 _text$mn        ends
.text$mn:00008A89
.text$mn:00008A8C ; ===========================================================================
.text$mn:00008A8C
.text$mn:00008A8C ; Segment type: Pure code
.text$mn:00008A8C ; Segment permissions: Read/Execute
.text$mn:00008A8C _text$mn        segment para public 'CODE' use32
.text$mn:00008A8C                 assume cs:_text$mn
.text$mn:00008A8C                 ;org 8A8Ch
.text$mn:00008A8C ; COMDAT (pick any)
.text$mn:00008A8C                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text$mn:00008A8C
.text$mn:00008A8C ; =============== S U B R O U T I N E =======================================
.text$mn:00008A8C
.text$mn:00008A8C ; Attributes: bp-based frame
.text$mn:00008A8C
.text$mn:00008A8C ; public: virtual void * __thiscall std::_Iostream_error_category::`scalar deleting destructor'(unsigned int)
.text$mn:00008A8C                 public ??_G_Iostream_error_category@std@@UAEPAXI@Z
.text$mn:00008A8C ??_G_Iostream_error_category@std@@UAEPAXI@Z proc near
.text$mn:00008A8C
.text$mn:00008A8C var_4           = dword ptr -4
.text$mn:00008A8C arg_0           = dword ptr  8
.text$mn:00008A8C
.text$mn:00008A8C                 push    ebp
.text$mn:00008A8D                 mov     ebp, esp
.text$mn:00008A8F                 push    ecx
.text$mn:00008A90                 mov     [ebp+var_4], ecx
.text$mn:00008A93                 mov     ecx, [ebp+var_4] ; this
.text$mn:00008A96                 call    ??1_Iostream_error_category@std@@UAE@XZ ; std::_Iostream_error_category::~_Iostream_error_category(void)
.text$mn:00008A9B                 mov     eax, [ebp+arg_0]
.text$mn:00008A9E                 and     eax, 1
.text$mn:00008AA1                 jz      short loc_8AAF
.text$mn:00008AA3                 mov     ecx, [ebp+var_4]
.text$mn:00008AA6                 push    ecx             ; void *
.text$mn:00008AA7                 call    ??3@YAXPAX@Z    ; operator delete(void *)
.text$mn:00008AAC                 add     esp, 4
.text$mn:00008AAF
.text$mn:00008AAF loc_8AAF:                               ; CODE XREF: std::_Iostream_error_category::`scalar deleting destructor'(uint)+15j
.text$mn:00008AAF                 mov     eax, [ebp+var_4]
.text$mn:00008AB2                 mov     esp, ebp
.text$mn:00008AB4                 pop     ebp
.text$mn:00008AB5                 retn    4
.text$mn:00008AB5 ??_G_Iostream_error_category@std@@UAEPAXI@Z endp
.text$mn:00008AB5
.text$mn:00008AB5 _text$mn        ends
.text$mn:00008AB5
.text$mn:00008AB8 ; ===========================================================================
.text$mn:00008AB8
.text$mn:00008AB8 ; Segment type: Pure code
.text$mn:00008AB8 ; Segment permissions: Read/Execute
.text$mn:00008AB8 _text$mn        segment para public 'CODE' use32
.text$mn:00008AB8                 assume cs:_text$mn
.text$mn:00008AB8                 ;org 8AB8h
.text$mn:00008AB8 ; COMDAT (pick any)
.text$mn:00008AB8                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text$mn:00008AB8
.text$mn:00008AB8 ; =============== S U B R O U T I N E =======================================
.text$mn:00008AB8
.text$mn:00008AB8 ; Attributes: bp-based frame
.text$mn:00008AB8
.text$mn:00008AB8 ; public: virtual void * __thiscall std::_System_error_category::`scalar deleting destructor'(unsigned int)
.text$mn:00008AB8                 public ??_G_System_error_category@std@@UAEPAXI@Z
.text$mn:00008AB8 ??_G_System_error_category@std@@UAEPAXI@Z proc near
.text$mn:00008AB8
.text$mn:00008AB8 var_4           = dword ptr -4
.text$mn:00008AB8 arg_0           = dword ptr  8
.text$mn:00008AB8
.text$mn:00008AB8                 push    ebp
.text$mn:00008AB9                 mov     ebp, esp
.text$mn:00008ABB                 push    ecx
.text$mn:00008ABC                 mov     [ebp+var_4], ecx
.text$mn:00008ABF                 mov     ecx, [ebp+var_4] ; this
.text$mn:00008AC2                 call    ??1_System_error_category@std@@UAE@XZ ; std::_System_error_category::~_System_error_category(void)
.text$mn:00008AC7                 mov     eax, [ebp+arg_0]
.text$mn:00008ACA                 and     eax, 1
.text$mn:00008ACD                 jz      short loc_8ADB
.text$mn:00008ACF                 mov     ecx, [ebp+var_4]
.text$mn:00008AD2                 push    ecx             ; void *
.text$mn:00008AD3                 call    ??3@YAXPAX@Z    ; operator delete(void *)
.text$mn:00008AD8                 add     esp, 4
.text$mn:00008ADB
.text$mn:00008ADB loc_8ADB:                               ; CODE XREF: std::_System_error_category::`scalar deleting destructor'(uint)+15j
.text$mn:00008ADB                 mov     eax, [ebp+var_4]
.text$mn:00008ADE                 mov     esp, ebp
.text$mn:00008AE0                 pop     ebp
.text$mn:00008AE1                 retn    4
.text$mn:00008AE1 ??_G_System_error_category@std@@UAEPAXI@Z endp
.text$mn:00008AE1
.text$mn:00008AE1 _text$mn        ends
.text$mn:00008AE1
.text$mn:00008AE4 ; ===========================================================================
.text$mn:00008AE4
.text$mn:00008AE4 ; Segment type: Pure code
.text$mn:00008AE4 ; Segment permissions: Read/Execute
.text$mn:00008AE4 _text$mn        segment para public 'CODE' use32
.text$mn:00008AE4                 assume cs:_text$mn
.text$mn:00008AE4                 ;org 8AE4h
.text$mn:00008AE4 ; COMDAT (pick any)
.text$mn:00008AE4                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text$mn:00008AE4
.text$mn:00008AE4 ; =============== S U B R O U T I N E =======================================
.text$mn:00008AE4
.text$mn:00008AE4 ; Attributes: bp-based frame
.text$mn:00008AE4
.text$mn:00008AE4 ; public: virtual void * __thiscall std::error_category::`scalar deleting destructor'(unsigned int)
.text$mn:00008AE4                 public ??_Gerror_category@std@@UAEPAXI@Z
.text$mn:00008AE4 ??_Gerror_category@std@@UAEPAXI@Z proc near
.text$mn:00008AE4
.text$mn:00008AE4 var_4           = dword ptr -4
.text$mn:00008AE4 arg_0           = dword ptr  8
.text$mn:00008AE4
.text$mn:00008AE4                 push    ebp
.text$mn:00008AE5                 mov     ebp, esp
.text$mn:00008AE7                 push    ecx
.text$mn:00008AE8                 mov     [ebp+var_4], ecx
.text$mn:00008AEB                 mov     ecx, [ebp+var_4] ; this
.text$mn:00008AEE                 call    ??1error_category@std@@UAE@XZ ; std::error_category::~error_category(void)
.text$mn:00008AF3                 mov     eax, [ebp+arg_0]
.text$mn:00008AF6                 and     eax, 1
.text$mn:00008AF9                 jz      short loc_8B07
.text$mn:00008AFB                 mov     ecx, [ebp+var_4]
.text$mn:00008AFE                 push    ecx             ; void *
.text$mn:00008AFF                 call    ??3@YAXPAX@Z    ; operator delete(void *)
.text$mn:00008B04                 add     esp, 4
.text$mn:00008B07
.text$mn:00008B07 loc_8B07:                               ; CODE XREF: std::error_category::`scalar deleting destructor'(uint)+15j
.text$mn:00008B07                 mov     eax, [ebp+var_4]
.text$mn:00008B0A                 mov     esp, ebp
.text$mn:00008B0C                 pop     ebp
.text$mn:00008B0D                 retn    4
.text$mn:00008B0D ??_Gerror_category@std@@UAEPAXI@Z endp
.text$mn:00008B0D
.text$mn:00008B0D _text$mn        ends
.text$mn:00008B0D
.text$mn:00008B10 ; ===========================================================================
.text$mn:00008B10
.text$mn:00008B10 ; Segment type: Pure code
.text$mn:00008B10 ; Segment permissions: Read/Execute
.text$mn:00008B10 _text$mn        segment para public 'CODE' use32
.text$mn:00008B10                 assume cs:_text$mn
.text$mn:00008B10                 ;org 8B10h
.text$mn:00008B10 ; COMDAT (pick any)
.text$mn:00008B10                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text$mn:00008B10
.text$mn:00008B10 ; =============== S U B R O U T I N E =======================================
.text$mn:00008B10
.text$mn:00008B10 ; Attributes: bp-based frame
.text$mn:00008B10
.text$mn:00008B10 ; public: virtual void * __thiscall std::invalid_argument::`scalar deleting destructor'(unsigned int)
.text$mn:00008B10                 public ??_Ginvalid_argument@std@@UAEPAXI@Z
.text$mn:00008B10 ??_Ginvalid_argument@std@@UAEPAXI@Z proc near
.text$mn:00008B10
.text$mn:00008B10 var_4           = dword ptr -4
.text$mn:00008B10 arg_0           = dword ptr  8
.text$mn:00008B10
.text$mn:00008B10                 push    ebp
.text$mn:00008B11                 mov     ebp, esp
.text$mn:00008B13                 push    ecx
.text$mn:00008B14                 mov     [ebp+var_4], ecx
.text$mn:00008B17                 mov     ecx, [ebp+var_4] ; this
.text$mn:00008B1A                 call    ??1invalid_argument@std@@UAE@XZ ; std::invalid_argument::~invalid_argument(void)
.text$mn:00008B1F                 mov     eax, [ebp+arg_0]
.text$mn:00008B22                 and     eax, 1
.text$mn:00008B25                 jz      short loc_8B33
.text$mn:00008B27                 mov     ecx, [ebp+var_4]
.text$mn:00008B2A                 push    ecx             ; void *
.text$mn:00008B2B                 call    ??3@YAXPAX@Z    ; operator delete(void *)
.text$mn:00008B30                 add     esp, 4
.text$mn:00008B33
.text$mn:00008B33 loc_8B33:                               ; CODE XREF: std::invalid_argument::`scalar deleting destructor'(uint)+15j
.text$mn:00008B33                 mov     eax, [ebp+var_4]
.text$mn:00008B36                 mov     esp, ebp
.text$mn:00008B38                 pop     ebp
.text$mn:00008B39                 retn    4
.text$mn:00008B39 ??_Ginvalid_argument@std@@UAEPAXI@Z endp
.text$mn:00008B39
.text$mn:00008B39 _text$mn        ends
.text$mn:00008B39
.text$mn:00008B3C ; ===========================================================================
.text$mn:00008B3C
.text$mn:00008B3C ; Segment type: Pure code
.text$mn:00008B3C ; Segment permissions: Read/Execute
.text$mn:00008B3C _text$mn        segment para public 'CODE' use32
.text$mn:00008B3C                 assume cs:_text$mn
.text$mn:00008B3C                 ;org 8B3Ch
.text$mn:00008B3C ; COMDAT (pick any)
.text$mn:00008B3C                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text$mn:00008B3C
.text$mn:00008B3C ; =============== S U B R O U T I N E =======================================
.text$mn:00008B3C
.text$mn:00008B3C ; Attributes: bp-based frame
.text$mn:00008B3C
.text$mn:00008B3C ; public: virtual void * __thiscall std::logic_error::`scalar deleting destructor'(unsigned int)
.text$mn:00008B3C                 public ??_Glogic_error@std@@UAEPAXI@Z
.text$mn:00008B3C ??_Glogic_error@std@@UAEPAXI@Z proc near
.text$mn:00008B3C
.text$mn:00008B3C var_4           = dword ptr -4
.text$mn:00008B3C arg_0           = dword ptr  8
.text$mn:00008B3C
.text$mn:00008B3C                 push    ebp
.text$mn:00008B3D                 mov     ebp, esp
.text$mn:00008B3F                 push    ecx
.text$mn:00008B40                 mov     [ebp+var_4], ecx
.text$mn:00008B43                 mov     ecx, [ebp+var_4] ; this
.text$mn:00008B46                 call    ??1logic_error@std@@UAE@XZ ; std::logic_error::~logic_error(void)
.text$mn:00008B4B                 mov     eax, [ebp+arg_0]
.text$mn:00008B4E                 and     eax, 1
.text$mn:00008B51                 jz      short loc_8B5F
.text$mn:00008B53                 mov     ecx, [ebp+var_4]
.text$mn:00008B56                 push    ecx             ; void *
.text$mn:00008B57                 call    ??3@YAXPAX@Z    ; operator delete(void *)
.text$mn:00008B5C                 add     esp, 4
.text$mn:00008B5F
.text$mn:00008B5F loc_8B5F:                               ; CODE XREF: std::logic_error::`scalar deleting destructor'(uint)+15j
.text$mn:00008B5F                 mov     eax, [ebp+var_4]
.text$mn:00008B62                 mov     esp, ebp
.text$mn:00008B64                 pop     ebp
.text$mn:00008B65                 retn    4
.text$mn:00008B65 ??_Glogic_error@std@@UAEPAXI@Z endp
.text$mn:00008B65
.text$mn:00008B65 _text$mn        ends
.text$mn:00008B65
.text$mn:00008B68 ; ===========================================================================
.text$mn:00008B68
.text$mn:00008B68 ; Segment type: Pure code
.text$mn:00008B68 ; Segment permissions: Read/Execute
.text$mn:00008B68 _text$mn        segment para public 'CODE' use32
.text$mn:00008B68                 assume cs:_text$mn
.text$mn:00008B68                 ;org 8B68h
.text$mn:00008B68 ; COMDAT (pick any)
.text$mn:00008B68                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text$mn:00008B68
.text$mn:00008B68 ; =============== S U B R O U T I N E =======================================
.text$mn:00008B68
.text$mn:00008B68 ; Attributes: bp-based frame
.text$mn:00008B68
.text$mn:00008B68 ; public: virtual void * __thiscall std::out_of_range::`scalar deleting destructor'(unsigned int)
.text$mn:00008B68                 public ??_Gout_of_range@std@@UAEPAXI@Z
.text$mn:00008B68 ??_Gout_of_range@std@@UAEPAXI@Z proc near
.text$mn:00008B68
.text$mn:00008B68 var_4           = dword ptr -4
.text$mn:00008B68 arg_0           = dword ptr  8
.text$mn:00008B68
.text$mn:00008B68                 push    ebp
.text$mn:00008B69                 mov     ebp, esp
.text$mn:00008B6B                 push    ecx
.text$mn:00008B6C                 mov     [ebp+var_4], ecx
.text$mn:00008B6F                 mov     ecx, [ebp+var_4] ; this
.text$mn:00008B72                 call    ??1out_of_range@std@@UAE@XZ ; std::out_of_range::~out_of_range(void)
.text$mn:00008B77                 mov     eax, [ebp+arg_0]
.text$mn:00008B7A                 and     eax, 1
.text$mn:00008B7D                 jz      short loc_8B8B
.text$mn:00008B7F                 mov     ecx, [ebp+var_4]
.text$mn:00008B82                 push    ecx             ; void *
.text$mn:00008B83                 call    ??3@YAXPAX@Z    ; operator delete(void *)
.text$mn:00008B88                 add     esp, 4
.text$mn:00008B8B
.text$mn:00008B8B loc_8B8B:                               ; CODE XREF: std::out_of_range::`scalar deleting destructor'(uint)+15j
.text$mn:00008B8B                 mov     eax, [ebp+var_4]
.text$mn:00008B8E                 mov     esp, ebp
.text$mn:00008B90                 pop     ebp
.text$mn:00008B91                 retn    4
.text$mn:00008B91 ??_Gout_of_range@std@@UAEPAXI@Z endp
.text$mn:00008B91
.text$mn:00008B91 _text$mn        ends
.text$mn:00008B91
.text$di:00008B94 ; ===========================================================================
.text$di:00008B94
.text$di:00008B94 ; Segment type: Pure code
.text$di:00008B94 ; Segment permissions: Read/Execute
.text$di:00008B94 _text$di        segment para public 'CODE' use32
.text$di:00008B94                 assume cs:_text$di
.text$di:00008B94                 ;org 8B94h
.text$di:00008B94 ; COMDAT (pick any)
.text$di:00008B94                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text$di:00008B94
.text$di:00008B94 ; =============== S U B R O U T I N E =======================================
.text$di:00008B94
.text$di:00008B94 ; Attributes: bp-based frame
.text$di:00008B94
.text$di:00008B94 ; void __cdecl `dynamic initializer for 'public: static class std::_Generic_error_category std::_Error_objects<int>::_Generic_object''(void)
.text$di:00008B94 ??__E?_Generic_object@?$_Error_objects@H@std@@2V_Generic_error_category@2@A@@YAXXZ proc near
.text$di:00008B94                                         ; DATA XREF: .CRT$XCU:void (*std::_Error_objects<int>::_Generic_object$initializer$)(void)o
.text$di:00008B94                 push    ebp
.text$di:00008B95                 mov     ebp, esp
.text$di:00008B97                 mov     ecx, offset ?_Generic_object@?$_Error_objects@H@std@@2V_Generic_error_category@2@A ; this
.text$di:00008B9C                 call    ??0_Generic_error_category@std@@QAE@XZ ; std::_Generic_error_category::_Generic_error_category(void)
.text$di:00008BA1                 push    offset ??__F?_Generic_object@?$_Error_objects@H@std@@2V_Generic_error_category@2@A@@YAXXZ ; void (__cdecl *)()
.text$di:00008BA6                 call    _atexit
.text$di:00008BAB                 add     esp, 4
.text$di:00008BAE                 pop     ebp
.text$di:00008BAF                 retn
.text$di:00008BAF ??__E?_Generic_object@?$_Error_objects@H@std@@2V_Generic_error_category@2@A@@YAXXZ endp
.text$di:00008BAF
.text$di:00008BAF _text$di        ends
.text$di:00008BAF
.text$di:00008BB0 ; ===========================================================================
.text$di:00008BB0
.text$di:00008BB0 ; Segment type: Pure code
.text$di:00008BB0 ; Segment permissions: Read/Execute
.text$di:00008BB0 _text$di        segment para public 'CODE' use32
.text$di:00008BB0                 assume cs:_text$di
.text$di:00008BB0                 ;org 8BB0h
.text$di:00008BB0 ; COMDAT (pick any)
.text$di:00008BB0                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text$di:00008BB0
.text$di:00008BB0 ; =============== S U B R O U T I N E =======================================
.text$di:00008BB0
.text$di:00008BB0 ; Attributes: bp-based frame
.text$di:00008BB0
.text$di:00008BB0 ; void __cdecl `dynamic initializer for 'public: static class std::_Iostream_error_category std::_Error_objects<int>::_Iostream_object''(void)
.text$di:00008BB0 ??__E?_Iostream_object@?$_Error_objects@H@std@@2V_Iostream_error_category@2@A@@YAXXZ proc near
.text$di:00008BB0                                         ; DATA XREF: .CRT$XCU:void (*std::_Error_objects<int>::_Iostream_object$initializer$)(void)o
.text$di:00008BB0                 push    ebp
.text$di:00008BB1                 mov     ebp, esp
.text$di:00008BB3                 mov     ecx, offset ?_Iostream_object@?$_Error_objects@H@std@@2V_Iostream_error_category@2@A ; this
.text$di:00008BB8                 call    ??0_Iostream_error_category@std@@QAE@XZ ; std::_Iostream_error_category::_Iostream_error_category(void)
.text$di:00008BBD                 push    offset ??__F?_Iostream_object@?$_Error_objects@H@std@@2V_Iostream_error_category@2@A@@YAXXZ ; void (__cdecl *)()
.text$di:00008BC2                 call    _atexit
.text$di:00008BC7                 add     esp, 4
.text$di:00008BCA                 pop     ebp
.text$di:00008BCB                 retn
.text$di:00008BCB ??__E?_Iostream_object@?$_Error_objects@H@std@@2V_Iostream_error_category@2@A@@YAXXZ endp
.text$di:00008BCB
.text$di:00008BCB _text$di        ends
.text$di:00008BCB
.text$di:00008BCC ; ===========================================================================
.text$di:00008BCC
.text$di:00008BCC ; Segment type: Pure code
.text$di:00008BCC ; Segment permissions: Read/Execute
.text$di:00008BCC _text$di        segment para public 'CODE' use32
.text$di:00008BCC                 assume cs:_text$di
.text$di:00008BCC                 ;org 8BCCh
.text$di:00008BCC ; COMDAT (pick any)
.text$di:00008BCC                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text$di:00008BCC
.text$di:00008BCC ; =============== S U B R O U T I N E =======================================
.text$di:00008BCC
.text$di:00008BCC ; Attributes: bp-based frame
.text$di:00008BCC
.text$di:00008BCC ; void __cdecl `dynamic initializer for 'public: static class std::_System_error_category std::_Error_objects<int>::_System_object''(void)
.text$di:00008BCC ??__E?_System_object@?$_Error_objects@H@std@@2V_System_error_category@2@A@@YAXXZ proc near
.text$di:00008BCC                                         ; DATA XREF: .CRT$XCU:void (*std::_Error_objects<int>::_System_object$initializer$)(void)o
.text$di:00008BCC                 push    ebp
.text$di:00008BCD                 mov     ebp, esp
.text$di:00008BCF                 mov     ecx, offset ?_System_object@?$_Error_objects@H@std@@2V_System_error_category@2@A ; this
.text$di:00008BD4                 call    ??0_System_error_category@std@@QAE@XZ ; std::_System_error_category::_System_error_category(void)
.text$di:00008BD9                 push    offset ??__F?_System_object@?$_Error_objects@H@std@@2V_System_error_category@2@A@@YAXXZ ; void (__cdecl *)()
.text$di:00008BDE                 call    _atexit
.text$di:00008BE3                 add     esp, 4
.text$di:00008BE6                 pop     ebp
.text$di:00008BE7                 retn
.text$di:00008BE7 ??__E?_System_object@?$_Error_objects@H@std@@2V_System_error_category@2@A@@YAXXZ endp
.text$di:00008BE7
.text$di:00008BE7 _text$di        ends
.text$di:00008BE7
.text$di:00008BE8 ; ===========================================================================
.text$di:00008BE8
.text$di:00008BE8 ; Segment type: Pure code
.text$di:00008BE8 ; Segment permissions: Read/Execute
.text$di:00008BE8 _text$di        segment para public 'CODE' use32
.text$di:00008BE8                 assume cs:_text$di
.text$di:00008BE8                 ;org 8BE8h
.text$di:00008BE8 ; COMDAT (pick any)
.text$di:00008BE8                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text$di:00008BE8
.text$di:00008BE8 ; =============== S U B R O U T I N E =======================================
.text$di:00008BE8
.text$di:00008BE8 ; Attributes: bp-based frame
.text$di:00008BE8
.text$di:00008BE8 ; void __cdecl `dynamic initializer for 'protected: static class WcharMbcsConvertor * WcharMbcsConvertor::_pSelf''(void)
.text$di:00008BE8 ??__E?_pSelf@WcharMbcsConvertor@@1PAV1@A@@YAXXZ proc near
.text$di:00008BE8                                         ; DATA XREF: .CRT$XCU:void (*WcharMbcsConvertor::_pSelf$initializer$)(void)o
.text$di:00008BE8
.text$di:00008BE8 var_18          = dword ptr -18h
.text$di:00008BE8 var_14          = dword ptr -14h
.text$di:00008BE8 var_10          = dword ptr -10h
.text$di:00008BE8 var_C           = dword ptr -0Ch
.text$di:00008BE8 var_4           = dword ptr -4
.text$di:00008BE8
.text$di:00008BE8                 push    ebp
.text$di:00008BE9                 mov     ebp, esp
.text$di:00008BEB                 push    0FFFFFFFFh
.text$di:00008BED                 push    offset __ehhandler$??__E?_pSelf@WcharMbcsConvertor@@1PAV1@A@@YAXXZ
.text$di:00008BF2                 mov     eax, large fs:0
.text$di:00008BF8                 push    eax
.text$di:00008BF9                 sub     esp, 0Ch
.text$di:00008BFC                 mov     eax, dword ptr ds:___security_cookie
.text$di:00008C01                 xor     eax, ebp
.text$di:00008C03                 push    eax
.text$di:00008C04                 lea     eax, [ebp+var_C]
.text$di:00008C07                 mov     large fs:0, eax
.text$di:00008C0D                 push    10h             ; unsigned int
.text$di:00008C0F                 call    ??2@YAPAXI@Z    ; operator new(uint)
.text$di:00008C14                 add     esp, 4
.text$di:00008C17                 mov     [ebp+var_10], eax
.text$di:00008C1A                 mov     [ebp+var_4], 0
.text$di:00008C21                 cmp     [ebp+var_10], 0
.text$di:00008C25                 jz      short loc_8C34
.text$di:00008C27                 mov     ecx, [ebp+var_10] ; this
.text$di:00008C2A                 call    ??0WcharMbcsConvertor@@IAE@XZ ; WcharMbcsConvertor::WcharMbcsConvertor(void)
.text$di:00008C2F                 mov     [ebp+var_14], eax
.text$di:00008C32                 jmp     short loc_8C3B
.text$di:00008C34 ; ---------------------------------------------------------------------------
.text$di:00008C34
.text$di:00008C34 loc_8C34:                               ; CODE XREF: `dynamic initializer for 'WcharMbcsConvertor * WcharMbcsConvertor::_pSelf''(void)+3Dj
.text$di:00008C34                 mov     [ebp+var_14], 0
.text$di:00008C3B
.text$di:00008C3B loc_8C3B:                               ; CODE XREF: `dynamic initializer for 'WcharMbcsConvertor * WcharMbcsConvertor::_pSelf''(void)+4Aj
.text$di:00008C3B                 mov     eax, [ebp+var_14]
.text$di:00008C3E                 mov     [ebp+var_18], eax
.text$di:00008C41                 mov     [ebp+var_4], 0FFFFFFFFh
.text$di:00008C48                 mov     ecx, [ebp+var_18]
.text$di:00008C4B                 mov     ds:?_pSelf@WcharMbcsConvertor@@1PAV1@A, ecx ; WcharMbcsConvertor * WcharMbcsConvertor::_pSelf
.text$di:00008C51                 mov     ecx, [ebp+var_C]
.text$di:00008C54                 mov     large fs:0, ecx
.text$di:00008C5B                 pop     ecx
.text$di:00008C5C                 mov     esp, ebp
.text$di:00008C5E                 pop     ebp
.text$di:00008C5F                 retn
.text$di:00008C5F ??__E?_pSelf@WcharMbcsConvertor@@1PAV1@A@@YAXXZ endp
.text$di:00008C5F
.text$di:00008C5F _text$di        ends
.text$di:00008C5F
.text$x:00008C60 ; ===========================================================================
.text$x:00008C60
.text$x:00008C60 ; Segment type: Pure code
.text$x:00008C60 ; Segment permissions: Read/Execute
.text$x:00008C60 _text$x         segment para public 'CODE' use32
.text$x:00008C60                 assume cs:_text$x
.text$x:00008C60                 ;org 8C60h
.text$x:00008C60 ; COMDAT (pick associative to section at 8BE8)
.text$x:00008C60                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text$x:00008C60
.text$x:00008C60 ; =============== S U B R O U T I N E =======================================
.text$x:00008C60
.text$x:00008C60
.text$x:00008C60 __unwindfunclet$??__E?_pSelf@WcharMbcsConvertor@@1PAV1@A@@YAXXZ$0 proc near
.text$x:00008C60                                         ; DATA XREF: .xdata$x:0000E1D8o
.text$x:00008C60                 mov     eax, [ebp-10h]
.text$x:00008C63                 push    eax             ; void *
.text$x:00008C64                 call    ??3@YAXPAX@Z    ; operator delete(void *)
.text$x:00008C69                 pop     ecx
.text$x:00008C6A                 retn
.text$x:00008C6A __unwindfunclet$??__E?_pSelf@WcharMbcsConvertor@@1PAV1@A@@YAXXZ$0 endp
.text$x:00008C6A
.text$x:00008C6B
.text$x:00008C6B ; =============== S U B R O U T I N E =======================================
.text$x:00008C6B
.text$x:00008C6B
.text$x:00008C6B __ehhandler$??__E?_pSelf@WcharMbcsConvertor@@1PAV1@A@@YAXXZ proc near
.text$x:00008C6B                                         ; DATA XREF: `dynamic initializer for 'WcharMbcsConvertor * WcharMbcsConvertor::_pSelf''(void)+5o
.text$x:00008C6B
.text$x:00008C6B arg_4           = dword ptr  8
.text$x:00008C6B
.text$x:00008C6B                 mov     edx, [esp+arg_4]
.text$x:00008C6F                 lea     eax, [edx+0Ch]
.text$x:00008C72                 mov     ecx, [edx-10h]
.text$x:00008C75                 xor     ecx, eax
.text$x:00008C77                 call    @__security_check_cookie@4 ; __security_check_cookie(x)
.text$x:00008C7C                 mov     eax, offset __ehfuncinfo$??__E?_pSelf@WcharMbcsConvertor@@1PAV1@A@@YAXXZ
.text$x:00008C81                 jmp     ___CxxFrameHandler3
.text$x:00008C81 __ehhandler$??__E?_pSelf@WcharMbcsConvertor@@1PAV1@A@@YAXXZ endp
.text$x:00008C81
.text$x:00008C81 ; ---------------------------------------------------------------------------
.text$x:00008C86                 align 4
.text$x:00008C86 _text$x         ends
.text$x:00008C86
.text$di:00008C88 ; ===========================================================================
.text$di:00008C88
.text$di:00008C88 ; Segment type: Pure code
.text$di:00008C88 ; Segment permissions: Read/Execute
.text$di:00008C88 _text$di        segment para public 'CODE' use32
.text$di:00008C88                 assume cs:_text$di
.text$di:00008C88                 ;org 8C88h
.text$di:00008C88 ; COMDAT (pick any)
.text$di:00008C88                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text$di:00008C88
.text$di:00008C88 ; =============== S U B R O U T I N E =======================================
.text$di:00008C88
.text$di:00008C88 ; Attributes: bp-based frame
.text$di:00008C88
.text$di:00008C88 ; void __cdecl `dynamic initializer for 'public: static class std::locale::id std::num_put<char, class std::back_insert_iterator<class std::basic_string<char, struct std::char_traits<char>, class std::allocator<char>>>>::id''(void)
.text$di:00008C88 ??__E?id@?$num_put@DV?$back_insert_iterator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@std@@2V0locale@2@A@@YAXXZ proc near
.text$di:00008C88                                         ; DATA XREF: .CRT$XCU:void (*std::num_put<char,std::back_insert_iterator<std::basic_string<char,std::char_traits<char>,std::allocator<char>>>>::id$initializer$)(void)o
.text$di:00008C88                 push    ebp
.text$di:00008C89                 mov     ebp, esp
.text$di:00008C8B                 push    0               ; unsigned int
.text$di:00008C8D                 mov     ecx, offset ?id@?$num_put@DV?$back_insert_iterator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@std@@2V0locale@2@A ; this
.text$di:00008C92                 call    ??0id@locale@std@@QAE@I@Z ; std::locale::id::id(uint)
.text$di:00008C97                 pop     ebp
.text$di:00008C98                 retn
.text$di:00008C98 ??__E?id@?$num_put@DV?$back_insert_iterator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@std@@2V0locale@2@A@@YAXXZ endp
.text$di:00008C98
.text$di:00008C98 ; ---------------------------------------------------------------------------
.text$di:00008C99                 align 4
.text$di:00008C99 _text$di        ends
.text$di:00008C99
.text$di:00008C9C ; ===========================================================================
.text$di:00008C9C
.text$di:00008C9C ; Segment type: Pure code
.text$di:00008C9C ; Segment permissions: Read/Execute
.text$di:00008C9C _text$di        segment para public 'CODE' use32
.text$di:00008C9C                 assume cs:_text$di
.text$di:00008C9C                 ;org 8C9Ch
.text$di:00008C9C ; COMDAT (pick any)
.text$di:00008C9C                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text$di:00008C9C
.text$di:00008C9C ; =============== S U B R O U T I N E =======================================
.text$di:00008C9C
.text$di:00008C9C ; Attributes: bp-based frame
.text$di:00008C9C
.text$di:00008C9C ; void __cdecl `dynamic initializer for 'public: static class std::locale::id std::num_put<wchar_t, class std::back_insert_iterator<class std::basic_string<wchar_t, struct std::char_traits<wchar_t>, class std::allocator<wchar_t>>>>::id''(void)
.text$di:00008C9C ??__E?id@?$num_put@_WV?$back_insert_iterator@V?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@@std@@@std@@2V0locale@2@A@@YAXXZ proc near
.text$di:00008C9C                                         ; DATA XREF: .CRT$XCU:void (*std::num_put<wchar_t,std::back_insert_iterator<std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>>>>::id$initializer$)(void)o
.text$di:00008C9C                 push    ebp
.text$di:00008C9D                 mov     ebp, esp
.text$di:00008C9F                 push    0               ; unsigned int
.text$di:00008CA1                 mov     ecx, offset ?id@?$num_put@_WV?$back_insert_iterator@V?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@@std@@@std@@2V0locale@2@A ; this
.text$di:00008CA6                 call    ??0id@locale@std@@QAE@I@Z ; std::locale::id::id(uint)
.text$di:00008CAB                 pop     ebp
.text$di:00008CAC                 retn
.text$di:00008CAC ??__E?id@?$num_put@_WV?$back_insert_iterator@V?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@@std@@@std@@2V0locale@2@A@@YAXXZ endp
.text$di:00008CAC
.text$di:00008CAC ; ---------------------------------------------------------------------------
.text$di:00008CAD                 align 10h
.text$di:00008CAD _text$di        ends
.text$di:00008CAD
.text$di:00008CB0 ; ===========================================================================
.text$di:00008CB0
.text$di:00008CB0 ; Segment type: Pure code
.text$di:00008CB0 ; Segment permissions: Read/Execute
.text$di:00008CB0 _text$di        segment para public 'CODE' use32
.text$di:00008CB0                 assume cs:_text$di
.text$di:00008CB0                 ;org 8CB0h
.text$di:00008CB0 ; COMDAT (pick any)
.text$di:00008CB0                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text$di:00008CB0
.text$di:00008CB0 ; =============== S U B R O U T I N E =======================================
.text$di:00008CB0
.text$di:00008CB0 ; Attributes: bp-based frame
.text$di:00008CB0
.text$di:00008CB0 ; void __cdecl `dynamic initializer for 'public: static class std::locale::id std::numpunct<char>::id''(void)
.text$di:00008CB0 ??__E?id@?$numpunct@D@std@@2V0locale@2@A@@YAXXZ proc near
.text$di:00008CB0                                         ; DATA XREF: .CRT$XCU:void (*std::numpunct<char>::id$initializer$)(void)o
.text$di:00008CB0                 push    ebp
.text$di:00008CB1                 mov     ebp, esp
.text$di:00008CB3                 push    0               ; unsigned int
.text$di:00008CB5                 mov     ecx, offset ?id@?$numpunct@D@std@@2V0locale@2@A ; this
.text$di:00008CBA                 call    ??0id@locale@std@@QAE@I@Z ; std::locale::id::id(uint)
.text$di:00008CBF                 pop     ebp
.text$di:00008CC0                 retn
.text$di:00008CC0 ??__E?id@?$numpunct@D@std@@2V0locale@2@A@@YAXXZ endp
.text$di:00008CC0
.text$di:00008CC0 ; ---------------------------------------------------------------------------
.text$di:00008CC1                 align 4
.text$di:00008CC1 _text$di        ends
.text$di:00008CC1
.text$di:00008CC4 ; ===========================================================================
.text$di:00008CC4
.text$di:00008CC4 ; Segment type: Pure code
.text$di:00008CC4 ; Segment permissions: Read/Execute
.text$di:00008CC4 _text$di        segment para public 'CODE' use32
.text$di:00008CC4                 assume cs:_text$di
.text$di:00008CC4                 ;org 8CC4h
.text$di:00008CC4 ; COMDAT (pick any)
.text$di:00008CC4                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text$di:00008CC4
.text$di:00008CC4 ; =============== S U B R O U T I N E =======================================
.text$di:00008CC4
.text$di:00008CC4 ; Attributes: bp-based frame
.text$di:00008CC4
.text$di:00008CC4 ; void __cdecl `dynamic initializer for 'public: static class std::locale::id std::numpunct<wchar_t>::id''(void)
.text$di:00008CC4 ??__E?id@?$numpunct@_W@std@@2V0locale@2@A@@YAXXZ proc near
.text$di:00008CC4                                         ; DATA XREF: .CRT$XCU:void (*std::numpunct<wchar_t>::id$initializer$)(void)o
.text$di:00008CC4                 push    ebp
.text$di:00008CC5                 mov     ebp, esp
.text$di:00008CC7                 push    0               ; unsigned int
.text$di:00008CC9                 mov     ecx, offset ?id@?$numpunct@_W@std@@2V0locale@2@A ; this
.text$di:00008CCE                 call    ??0id@locale@std@@QAE@I@Z ; std::locale::id::id(uint)
.text$di:00008CD3                 pop     ebp
.text$di:00008CD4                 retn
.text$di:00008CD4 ??__E?id@?$numpunct@_W@std@@2V0locale@2@A@@YAXXZ endp
.text$di:00008CD4
.text$di:00008CD4 ; ---------------------------------------------------------------------------
.text$di:00008CD5                 align 4
.text$di:00008CD5 _text$di        ends
.text$di:00008CD5
.text$di:00008CD8 ; ===========================================================================
.text$di:00008CD8
.text$di:00008CD8 ; Segment type: Pure code
.text$di:00008CD8 ; Segment permissions: Read/Execute
.text$di:00008CD8 _text$di        segment para public 'CODE' use32
.text$di:00008CD8                 assume cs:_text$di
.text$di:00008CD8                 ;org 8CD8h
.text$di:00008CD8 ; COMDAT (pick any)
.text$di:00008CD8                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text$di:00008CD8
.text$di:00008CD8 ; =============== S U B R O U T I N E =======================================
.text$di:00008CD8
.text$di:00008CD8 ; Attributes: bp-based frame
.text$di:00008CD8
.text$di:00008CD8 ; void __cdecl std::`dynamic initializer for 'allocator_arg''(void)
.text$di:00008CD8 ??__Eallocator_arg@std@@YAXXZ proc near ; DATA XREF: .CRT$XCU:_allocator_arg$initializer$o
.text$di:00008CD8
.text$di:00008CD8 var_1           = byte ptr -1
.text$di:00008CD8
.text$di:00008CD8                 push    ebp
.text$di:00008CD9                 mov     ebp, esp
.text$di:00008CDB                 push    ecx
.text$di:00008CDC                 xor     eax, eax
.text$di:00008CDE                 mov     [ebp+var_1], al
.text$di:00008CE1                 mov     esp, ebp
.text$di:00008CE3                 pop     ebp
.text$di:00008CE4                 retn
.text$di:00008CE4 ??__Eallocator_arg@std@@YAXXZ endp
.text$di:00008CE4
.text$di:00008CE4 ; ---------------------------------------------------------------------------
.text$di:00008CE5                 align 4
.text$di:00008CE5 _text$di        ends
.text$di:00008CE5
.text$di:00008CE8 ; ===========================================================================
.text$di:00008CE8
.text$di:00008CE8 ; Segment type: Pure code
.text$di:00008CE8 ; Segment permissions: Read/Execute
.text$di:00008CE8 _text$di        segment para public 'CODE' use32
.text$di:00008CE8                 assume cs:_text$di
.text$di:00008CE8                 ;org 8CE8h
.text$di:00008CE8 ; COMDAT (pick any)
.text$di:00008CE8                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text$di:00008CE8
.text$di:00008CE8 ; =============== S U B R O U T I N E =======================================
.text$di:00008CE8
.text$di:00008CE8 ; Attributes: bp-based frame
.text$di:00008CE8
.text$di:00008CE8 ; void __cdecl std::`dynamic initializer for 'piecewise_construct''(void)
.text$di:00008CE8 ??__Epiecewise_construct@std@@YAXXZ proc near
.text$di:00008CE8                                         ; DATA XREF: .CRT$XCU:_piecewise_construct$initializer$o
.text$di:00008CE8
.text$di:00008CE8 var_1           = byte ptr -1
.text$di:00008CE8
.text$di:00008CE8                 push    ebp
.text$di:00008CE9                 mov     ebp, esp
.text$di:00008CEB                 push    ecx
.text$di:00008CEC                 xor     eax, eax
.text$di:00008CEE                 mov     [ebp+var_1], al
.text$di:00008CF1                 mov     esp, ebp
.text$di:00008CF3                 pop     ebp
.text$di:00008CF4                 retn
.text$di:00008CF4 ??__Epiecewise_construct@std@@YAXXZ endp
.text$di:00008CF4
.text$di:00008CF4 ; ---------------------------------------------------------------------------
.text$di:00008CF5                 align 4
.text$di:00008CF5 _text$di        ends
.text$di:00008CF5
.text$yd:00008CF8 ; ===========================================================================
.text$yd:00008CF8
.text$yd:00008CF8 ; Segment type: Pure code
.text$yd:00008CF8 ; Segment permissions: Read/Execute
.text$yd:00008CF8 _text$yd        segment para public 'CODE' use32
.text$yd:00008CF8                 assume cs:_text$yd
.text$yd:00008CF8                 ;org 8CF8h
.text$yd:00008CF8 ; COMDAT (pick any)
.text$yd:00008CF8                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text$yd:00008CF8
.text$yd:00008CF8 ; =============== S U B R O U T I N E =======================================
.text$yd:00008CF8
.text$yd:00008CF8 ; Attributes: bp-based frame
.text$yd:00008CF8
.text$yd:00008CF8 ; void __cdecl `dynamic atexit destructor for 'public: static std::_Generic_error_category std::_Error_objects<int>::_Generic_object''()
.text$yd:00008CF8 ??__F?_Generic_object@?$_Error_objects@H@std@@2V_Generic_error_category@2@A@@YAXXZ proc near
.text$yd:00008CF8                                         ; DATA XREF: `dynamic initializer for 'std::_Generic_error_category std::_Error_objects<int>::_Generic_object''(void)+Do
.text$yd:00008CF8                 push    ebp
.text$yd:00008CF9                 mov     ebp, esp
.text$yd:00008CFB                 mov     ecx, offset ?_Generic_object@?$_Error_objects@H@std@@2V_Generic_error_category@2@A ; this
.text$yd:00008D00                 call    ??1_Generic_error_category@std@@UAE@XZ ; std::_Generic_error_category::~_Generic_error_category(void)
.text$yd:00008D05                 pop     ebp
.text$yd:00008D06                 retn
.text$yd:00008D06 ??__F?_Generic_object@?$_Error_objects@H@std@@2V_Generic_error_category@2@A@@YAXXZ endp
.text$yd:00008D06
.text$yd:00008D06 ; ---------------------------------------------------------------------------
.text$yd:00008D07                 align 4
.text$yd:00008D07 _text$yd        ends
.text$yd:00008D07
.text$yd:00008D08 ; ===========================================================================
.text$yd:00008D08
.text$yd:00008D08 ; Segment type: Pure code
.text$yd:00008D08 ; Segment permissions: Read/Execute
.text$yd:00008D08 _text$yd        segment para public 'CODE' use32
.text$yd:00008D08                 assume cs:_text$yd
.text$yd:00008D08                 ;org 8D08h
.text$yd:00008D08 ; COMDAT (pick any)
.text$yd:00008D08                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text$yd:00008D08
.text$yd:00008D08 ; =============== S U B R O U T I N E =======================================
.text$yd:00008D08
.text$yd:00008D08 ; Attributes: bp-based frame
.text$yd:00008D08
.text$yd:00008D08 ; void __cdecl `dynamic atexit destructor for 'public: static std::_Iostream_error_category std::_Error_objects<int>::_Iostream_object''()
.text$yd:00008D08 ??__F?_Iostream_object@?$_Error_objects@H@std@@2V_Iostream_error_category@2@A@@YAXXZ proc near
.text$yd:00008D08                                         ; DATA XREF: `dynamic initializer for 'std::_Iostream_error_category std::_Error_objects<int>::_Iostream_object''(void)+Do
.text$yd:00008D08                 push    ebp
.text$yd:00008D09                 mov     ebp, esp
.text$yd:00008D0B                 mov     ecx, offset ?_Iostream_object@?$_Error_objects@H@std@@2V_Iostream_error_category@2@A ; this
.text$yd:00008D10                 call    ??1_Iostream_error_category@std@@UAE@XZ ; std::_Iostream_error_category::~_Iostream_error_category(void)
.text$yd:00008D15                 pop     ebp
.text$yd:00008D16                 retn
.text$yd:00008D16 ??__F?_Iostream_object@?$_Error_objects@H@std@@2V_Iostream_error_category@2@A@@YAXXZ endp
.text$yd:00008D16
.text$yd:00008D16 ; ---------------------------------------------------------------------------
.text$yd:00008D17                 align 4
.text$yd:00008D17 _text$yd        ends
.text$yd:00008D17
.text$yd:00008D18 ; ===========================================================================
.text$yd:00008D18
.text$yd:00008D18 ; Segment type: Pure code
.text$yd:00008D18 ; Segment permissions: Read/Execute
.text$yd:00008D18 _text$yd        segment para public 'CODE' use32
.text$yd:00008D18                 assume cs:_text$yd
.text$yd:00008D18                 ;org 8D18h
.text$yd:00008D18 ; COMDAT (pick any)
.text$yd:00008D18                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text$yd:00008D18
.text$yd:00008D18 ; =============== S U B R O U T I N E =======================================
.text$yd:00008D18
.text$yd:00008D18 ; Attributes: bp-based frame
.text$yd:00008D18
.text$yd:00008D18 ; void __cdecl `dynamic atexit destructor for 'public: static std::_System_error_category std::_Error_objects<int>::_System_object''()
.text$yd:00008D18 ??__F?_System_object@?$_Error_objects@H@std@@2V_System_error_category@2@A@@YAXXZ proc near
.text$yd:00008D18                                         ; DATA XREF: `dynamic initializer for 'std::_System_error_category std::_Error_objects<int>::_System_object''(void)+Do
.text$yd:00008D18                 push    ebp
.text$yd:00008D19                 mov     ebp, esp
.text$yd:00008D1B                 mov     ecx, offset ?_System_object@?$_Error_objects@H@std@@2V_System_error_category@2@A ; this
.text$yd:00008D20                 call    ??1_System_error_category@std@@UAE@XZ ; std::_System_error_category::~_System_error_category(void)
.text$yd:00008D25                 pop     ebp
.text$yd:00008D26                 retn
.text$yd:00008D26 ??__F?_System_object@?$_Error_objects@H@std@@2V_System_error_category@2@A@@YAXXZ endp
.text$yd:00008D26
.text$yd:00008D26 ; ---------------------------------------------------------------------------
.text$yd:00008D27                 align 4
.text$yd:00008D27 _text$yd        ends
.text$yd:00008D27
.text$mn:00008D28 ; ===========================================================================
.text$mn:00008D28
.text$mn:00008D28 ; Segment type: Pure code
.text$mn:00008D28 ; Segment permissions: Read/Execute
.text$mn:00008D28 _text$mn        segment para public 'CODE' use32
.text$mn:00008D28                 assume cs:_text$mn
.text$mn:00008D28                 ;org 8D28h
.text$mn:00008D28 ; COMDAT (pick any)
.text$mn:00008D28                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text$mn:00008D28
.text$mn:00008D28 ; =============== S U B R O U T I N E =======================================
.text$mn:00008D28
.text$mn:00008D28 ; Attributes: bp-based frame
.text$mn:00008D28
.text$mn:00008D28 ; void __thiscall std::_Iterator_base12::_Adopt(std::_Iterator_base12 *this, const struct std::_Container_base12 *)
.text$mn:00008D28                 public ?_Adopt@_Iterator_base12@std@@QAEXPBU_Container_base12@2@@Z
.text$mn:00008D28 ?_Adopt@_Iterator_base12@std@@QAEXPBU_Container_base12@2@@Z proc near
.text$mn:00008D28                                         ; CODE XREF: std::_String_const_iterator<std::_String_val<std::_Simple_types<wchar_t>>>::_String_const_iterator<std::_String_val<std::_Simple_types<wchar_t>>>(wchar_t const *,std::_Container_base12 const *)+3Cp
.text$mn:00008D28                                         ; std::_Vector_const_iterator<std::_Vector_val<std::_Simple_types<wchar_t>>>::_Vector_const_iterator<std::_Vector_val<std::_Simple_types<wchar_t>>>(wchar_t *,std::_Container_base12 const *)+45p ...
.text$mn:00008D28
.text$mn:00008D28 var_1C          = byte ptr -1Ch
.text$mn:00008D28 var_18          = byte ptr -18h
.text$mn:00008D28 var_14          = dword ptr -14h
.text$mn:00008D28 var_10          = dword ptr -10h
.text$mn:00008D28 var_C           = dword ptr -0Ch
.text$mn:00008D28 var_4           = dword ptr -4
.text$mn:00008D28 arg_0           = dword ptr  8
.text$mn:00008D28
.text$mn:00008D28                 push    ebp
.text$mn:00008D29                 mov     ebp, esp
.text$mn:00008D2B                 push    0FFFFFFFFh
.text$mn:00008D2D                 push    offset __ehhandler$?_Adopt@_Iterator_base12@std@@QAEXPBU_Container_base12@2@@Z
.text$mn:00008D32                 mov     eax, large fs:0
.text$mn:00008D38                 push    eax
.text$mn:00008D39                 sub     esp, 10h
.text$mn:00008D3C                 mov     eax, dword ptr ds:___security_cookie
.text$mn:00008D41                 xor     eax, ebp
.text$mn:00008D43                 push    eax
.text$mn:00008D44                 lea     eax, [ebp+var_C]
.text$mn:00008D47                 mov     large fs:0, eax
.text$mn:00008D4D                 mov     [ebp+var_10], ecx
.text$mn:00008D50                 cmp     [ebp+arg_0], 0
.text$mn:00008D54                 jnz     short loc_8D80
.text$mn:00008D56                 push    3               ; int
.text$mn:00008D58                 lea     ecx, [ebp+var_18] ; this
.text$mn:00008D5B                 call    ??0_Lockit@std@@QAE@H@Z ; std::_Lockit::_Lockit(int)
.text$mn:00008D60                 mov     [ebp+var_4], 0
.text$mn:00008D67                 mov     ecx, [ebp+var_10] ; this
.text$mn:00008D6A                 call    ?_Orphan_me@_Iterator_base12@std@@QAEXXZ ; std::_Iterator_base12::_Orphan_me(void)
.text$mn:00008D6F                 mov     [ebp+var_4], 0FFFFFFFFh
.text$mn:00008D76                 lea     ecx, [ebp+var_18] ; this
.text$mn:00008D79                 call    ??1_Lockit@std@@QAE@XZ ; std::_Lockit::~_Lockit(void)
.text$mn:00008D7E                 jmp     short loc_8DD7
.text$mn:00008D80 ; ---------------------------------------------------------------------------
.text$mn:00008D80
.text$mn:00008D80 loc_8D80:                               ; CODE XREF: std::_Iterator_base12::_Adopt(std::_Container_base12 const *)+2Cj
.text$mn:00008D80                 mov     eax, [ebp+arg_0]
.text$mn:00008D83                 mov     ecx, [eax]
.text$mn:00008D85                 mov     [ebp+var_14], ecx
.text$mn:00008D88                 mov     edx, [ebp+var_10]
.text$mn:00008D8B                 mov     eax, [edx]
.text$mn:00008D8D                 cmp     eax, [ebp+var_14]
.text$mn:00008D90                 jz      short loc_8DD7
.text$mn:00008D92                 push    3               ; int
.text$mn:00008D94                 lea     ecx, [ebp+var_1C] ; this
.text$mn:00008D97                 call    ??0_Lockit@std@@QAE@H@Z ; std::_Lockit::_Lockit(int)
.text$mn:00008D9C                 mov     [ebp+var_4], 1
.text$mn:00008DA3                 mov     ecx, [ebp+var_10] ; this
.text$mn:00008DA6                 call    ?_Orphan_me@_Iterator_base12@std@@QAEXXZ ; std::_Iterator_base12::_Orphan_me(void)
.text$mn:00008DAB                 mov     ecx, [ebp+var_10]
.text$mn:00008DAE                 mov     edx, [ebp+var_14]
.text$mn:00008DB1                 mov     eax, [edx+4]
.text$mn:00008DB4                 mov     [ecx+4], eax
.text$mn:00008DB7                 mov     ecx, [ebp+var_14]
.text$mn:00008DBA                 mov     edx, [ebp+var_10]
.text$mn:00008DBD                 mov     [ecx+4], edx
.text$mn:00008DC0                 mov     eax, [ebp+var_10]
.text$mn:00008DC3                 mov     ecx, [ebp+var_14]
.text$mn:00008DC6                 mov     [eax], ecx
.text$mn:00008DC8                 mov     [ebp+var_4], 0FFFFFFFFh
.text$mn:00008DCF                 lea     ecx, [ebp+var_1C] ; this
.text$mn:00008DD2                 call    ??1_Lockit@std@@QAE@XZ ; std::_Lockit::~_Lockit(void)
.text$mn:00008DD7
.text$mn:00008DD7 loc_8DD7:                               ; CODE XREF: std::_Iterator_base12::_Adopt(std::_Container_base12 const *)+56j
.text$mn:00008DD7                                         ; std::_Iterator_base12::_Adopt(std::_Container_base12 const *)+68j
.text$mn:00008DD7                 mov     ecx, [ebp+var_C]
.text$mn:00008DDA                 mov     large fs:0, ecx
.text$mn:00008DE1                 pop     ecx
.text$mn:00008DE2                 mov     esp, ebp
.text$mn:00008DE4                 pop     ebp
.text$mn:00008DE5                 retn    4
.text$mn:00008DE5 ?_Adopt@_Iterator_base12@std@@QAEXPBU_Container_base12@2@@Z endp
.text$mn:00008DE5
.text$mn:00008DE5 _text$mn        ends
.text$mn:00008DE5
.text$x:00008DE8 ; ===========================================================================
.text$x:00008DE8
.text$x:00008DE8 ; Segment type: Pure code
.text$x:00008DE8 ; Segment permissions: Read/Execute
.text$x:00008DE8 _text$x         segment para public 'CODE' use32
.text$x:00008DE8                 assume cs:_text$x
.text$x:00008DE8                 ;org 8DE8h
.text$x:00008DE8 ; COMDAT (pick associative to section at 8D28)
.text$x:00008DE8                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text$x:00008DE8
.text$x:00008DE8 ; =============== S U B R O U T I N E =======================================
.text$x:00008DE8
.text$x:00008DE8
.text$x:00008DE8 __unwindfunclet$?_Adopt@_Iterator_base12@std@@QAEXPBU_Container_base12@2@@Z$0 proc near
.text$x:00008DE8                                         ; DATA XREF: .xdata$x:0000D4B8o
.text$x:00008DE8                 lea     ecx, [ebp-18h]  ; this
.text$x:00008DEB                 jmp     ??1_Lockit@std@@QAE@XZ ; std::_Lockit::~_Lockit(void)
.text$x:00008DEB __unwindfunclet$?_Adopt@_Iterator_base12@std@@QAEXPBU_Container_base12@2@@Z$0 endp
.text$x:00008DEB
.text$x:00008DF0
.text$x:00008DF0 ; =============== S U B R O U T I N E =======================================
.text$x:00008DF0
.text$x:00008DF0
.text$x:00008DF0 __unwindfunclet$?_Adopt@_Iterator_base12@std@@QAEXPBU_Container_base12@2@@Z$1 proc near
.text$x:00008DF0                                         ; DATA XREF: .xdata$x:0000D4C0o
.text$x:00008DF0                 lea     ecx, [ebp-1Ch]  ; this
.text$x:00008DF3                 jmp     ??1_Lockit@std@@QAE@XZ ; std::_Lockit::~_Lockit(void)
.text$x:00008DF3 __unwindfunclet$?_Adopt@_Iterator_base12@std@@QAEXPBU_Container_base12@2@@Z$1 endp
.text$x:00008DF3
.text$x:00008DF8
.text$x:00008DF8 ; =============== S U B R O U T I N E =======================================
.text$x:00008DF8
.text$x:00008DF8
.text$x:00008DF8 __ehhandler$?_Adopt@_Iterator_base12@std@@QAEXPBU_Container_base12@2@@Z proc near
.text$x:00008DF8                                         ; DATA XREF: std::_Iterator_base12::_Adopt(std::_Container_base12 const *)+5o
.text$x:00008DF8
.text$x:00008DF8 arg_4           = dword ptr  8
.text$x:00008DF8
.text$x:00008DF8                 mov     edx, [esp+arg_4]
.text$x:00008DFC                 lea     eax, [edx+0Ch]
.text$x:00008DFF                 mov     ecx, [edx-14h]
.text$x:00008E02                 xor     ecx, eax
.text$x:00008E04                 call    @__security_check_cookie@4 ; __security_check_cookie(x)
.text$x:00008E09                 mov     eax, offset __ehfuncinfo$?_Adopt@_Iterator_base12@std@@QAEXPBU_Container_base12@2@@Z
.text$x:00008E0E                 jmp     ___CxxFrameHandler3
.text$x:00008E0E __ehhandler$?_Adopt@_Iterator_base12@std@@QAEXPBU_Container_base12@2@@Z endp
.text$x:00008E0E
.text$x:00008E0E ; ---------------------------------------------------------------------------
.text$x:00008E13                 align 4
.text$x:00008E13 _text$x         ends
.text$x:00008E13
.text$mn:00008E14 ; ===========================================================================
.text$mn:00008E14
.text$mn:00008E14 ; Segment type: Pure code
.text$mn:00008E14 ; Segment permissions: Read/Execute
.text$mn:00008E14 _text$mn        segment para public 'CODE' use32
.text$mn:00008E14                 assume cs:_text$mn
.text$mn:00008E14                 ;org 8E14h
.text$mn:00008E14 ; COMDAT (pick any)
.text$mn:00008E14                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text$mn:00008E14
.text$mn:00008E14 ; =============== S U B R O U T I N E =======================================
.text$mn:00008E14
.text$mn:00008E14 ; Attributes: bp-based frame
.text$mn:00008E14
.text$mn:00008E14 ; public: void __thiscall std::_String_alloc<0, struct std::_String_base_types<char, class std::allocator<char>>>::_Alloc_proxy(void)
.text$mn:00008E14                 public ?_Alloc_proxy@?$_String_alloc@$0A@U?$_String_base_types@DV?$allocator@D@std@@@std@@@std@@QAEXXZ
.text$mn:00008E14 ?_Alloc_proxy@?$_String_alloc@$0A@U?$_String_base_types@DV?$allocator@D@std@@@std@@@std@@QAEXXZ proc near
.text$mn:00008E14                                         ; CODE XREF: std::_String_alloc<0,std::_String_base_types<char,std::allocator<char>>>::_String_alloc<0,std::_String_base_types<char,std::allocator<char>>>(std::allocator<char> const &)+38p
.text$mn:00008E14
.text$mn:00008E14 var_10          = byte ptr -10h
.text$mn:00008E14 var_8           = dword ptr -8
.text$mn:00008E14 var_1           = byte ptr -1
.text$mn:00008E14
.text$mn:00008E14                 push    ebp
.text$mn:00008E15                 mov     ebp, esp
.text$mn:00008E17                 sub     esp, 10h
.text$mn:00008E1A                 mov     [ebp+var_8], ecx
.text$mn:00008E1D                 lea     ecx, [ebp+var_1]
.text$mn:00008E20                 call    ??0?$allocator@U_Container_proxy@std@@@std@@QAE@XZ ; std::allocator<std::_Container_proxy>::allocator<std::_Container_proxy>(void)
.text$mn:00008E25                 push    1
.text$mn:00008E27                 lea     ecx, [ebp+var_1]
.text$mn:00008E2A                 call    ?allocate@?$allocator@U_Container_proxy@std@@@std@@QAEPAU_Container_proxy@2@I@Z ; std::allocator<std::_Container_proxy>::allocate(uint)
.text$mn:00008E2F                 mov     ecx, [ebp+var_8]
.text$mn:00008E32                 mov     [ecx], eax
.text$mn:00008E34                 lea     ecx, [ebp+var_10] ; this
.text$mn:00008E37                 call    ??0_Container_proxy@std@@QAE@XZ ; std::_Container_proxy::_Container_proxy(void)
.text$mn:00008E3C                 push    eax             ; int
.text$mn:00008E3D                 mov     edx, [ebp+var_8]
.text$mn:00008E40                 mov     eax, [edx]
.text$mn:00008E42                 push    eax             ; void *
.text$mn:00008E43                 lea     ecx, [ebp+var_1]
.text$mn:00008E46                 call    ??$construct@U_Container_proxy@std@@U12@@?$allocator@U_Container_proxy@std@@@std@@QAEXPAU_Container_proxy@1@$$QAU21@@Z ; std::allocator<std::_Container_proxy>::construct<std::_Container_proxy,std::_Container_proxy>(std::_Container_proxy *,std::_Container_proxy &&)
.text$mn:00008E4B                 mov     ecx, [ebp+var_8]
.text$mn:00008E4E                 mov     edx, [ecx]
.text$mn:00008E50                 mov     eax, [ebp+var_8]
.text$mn:00008E53                 mov     [edx], eax
.text$mn:00008E55                 mov     esp, ebp
.text$mn:00008E57                 pop     ebp
.text$mn:00008E58                 retn
.text$mn:00008E58 ?_Alloc_proxy@?$_String_alloc@$0A@U?$_String_base_types@DV?$allocator@D@std@@@std@@@std@@QAEXXZ endp
.text$mn:00008E58
.text$mn:00008E58 ; ---------------------------------------------------------------------------
.text$mn:00008E59                 align 4
.text$mn:00008E59 _text$mn        ends
.text$mn:00008E59
.text$mn:00008E5C ; ===========================================================================
.text$mn:00008E5C
.text$mn:00008E5C ; Segment type: Pure code
.text$mn:00008E5C ; Segment permissions: Read/Execute
.text$mn:00008E5C _text$mn        segment para public 'CODE' use32
.text$mn:00008E5C                 assume cs:_text$mn
.text$mn:00008E5C                 ;org 8E5Ch
.text$mn:00008E5C ; COMDAT (pick any)
.text$mn:00008E5C                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text$mn:00008E5C
.text$mn:00008E5C ; =============== S U B R O U T I N E =======================================
.text$mn:00008E5C
.text$mn:00008E5C ; Attributes: bp-based frame
.text$mn:00008E5C
.text$mn:00008E5C ; public: void __thiscall std::_String_alloc<0, struct std::_String_base_types<wchar_t, class std::allocator<wchar_t>>>::_Alloc_proxy(void)
.text$mn:00008E5C                 public ?_Alloc_proxy@?$_String_alloc@$0A@U?$_String_base_types@_WV?$allocator@_W@std@@@std@@@std@@QAEXXZ
.text$mn:00008E5C ?_Alloc_proxy@?$_String_alloc@$0A@U?$_String_base_types@_WV?$allocator@_W@std@@@std@@@std@@QAEXXZ proc near
.text$mn:00008E5C                                         ; CODE XREF: std::_String_alloc<0,std::_String_base_types<wchar_t,std::allocator<wchar_t>>>::_String_alloc<0,std::_String_base_types<wchar_t,std::allocator<wchar_t>>>(std::allocator<wchar_t> const &)+38p
.text$mn:00008E5C
.text$mn:00008E5C var_10          = byte ptr -10h
.text$mn:00008E5C var_8           = dword ptr -8
.text$mn:00008E5C var_1           = byte ptr -1
.text$mn:00008E5C
.text$mn:00008E5C                 push    ebp
.text$mn:00008E5D                 mov     ebp, esp
.text$mn:00008E5F                 sub     esp, 10h
.text$mn:00008E62                 mov     [ebp+var_8], ecx
.text$mn:00008E65                 lea     ecx, [ebp+var_1]
.text$mn:00008E68                 call    ??0?$allocator@U_Container_proxy@std@@@std@@QAE@XZ ; std::allocator<std::_Container_proxy>::allocator<std::_Container_proxy>(void)
.text$mn:00008E6D                 push    1
.text$mn:00008E6F                 lea     ecx, [ebp+var_1]
.text$mn:00008E72                 call    ?allocate@?$allocator@U_Container_proxy@std@@@std@@QAEPAU_Container_proxy@2@I@Z ; std::allocator<std::_Container_proxy>::allocate(uint)
.text$mn:00008E77                 mov     ecx, [ebp+var_8]
.text$mn:00008E7A                 mov     [ecx], eax
.text$mn:00008E7C                 lea     ecx, [ebp+var_10] ; this
.text$mn:00008E7F                 call    ??0_Container_proxy@std@@QAE@XZ ; std::_Container_proxy::_Container_proxy(void)
.text$mn:00008E84                 push    eax             ; int
.text$mn:00008E85                 mov     edx, [ebp+var_8]
.text$mn:00008E88                 mov     eax, [edx]
.text$mn:00008E8A                 push    eax             ; void *
.text$mn:00008E8B                 lea     ecx, [ebp+var_1]
.text$mn:00008E8E                 call    ??$construct@U_Container_proxy@std@@U12@@?$allocator@U_Container_proxy@std@@@std@@QAEXPAU_Container_proxy@1@$$QAU21@@Z ; std::allocator<std::_Container_proxy>::construct<std::_Container_proxy,std::_Container_proxy>(std::_Container_proxy *,std::_Container_proxy &&)
.text$mn:00008E93                 mov     ecx, [ebp+var_8]
.text$mn:00008E96                 mov     edx, [ecx]
.text$mn:00008E98                 mov     eax, [ebp+var_8]
.text$mn:00008E9B                 mov     [edx], eax
.text$mn:00008E9D                 mov     esp, ebp
.text$mn:00008E9F                 pop     ebp
.text$mn:00008EA0                 retn
.text$mn:00008EA0 ?_Alloc_proxy@?$_String_alloc@$0A@U?$_String_base_types@_WV?$allocator@_W@std@@@std@@@std@@QAEXXZ endp
.text$mn:00008EA0
.text$mn:00008EA0 ; ---------------------------------------------------------------------------
.text$mn:00008EA1                 align 4
.text$mn:00008EA1 _text$mn        ends
.text$mn:00008EA1
.text$mn:00008EA4 ; ===========================================================================
.text$mn:00008EA4
.text$mn:00008EA4 ; Segment type: Pure code
.text$mn:00008EA4 ; Segment permissions: Read/Execute
.text$mn:00008EA4 _text$mn        segment para public 'CODE' use32
.text$mn:00008EA4                 assume cs:_text$mn
.text$mn:00008EA4                 ;org 8EA4h
.text$mn:00008EA4 ; COMDAT (pick any)
.text$mn:00008EA4                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text$mn:00008EA4
.text$mn:00008EA4 ; =============== S U B R O U T I N E =======================================
.text$mn:00008EA4
.text$mn:00008EA4 ; Attributes: bp-based frame
.text$mn:00008EA4
.text$mn:00008EA4 ; public: void __thiscall std::_Vector_alloc<0, struct std::_Vec_base_types<char, class std::allocator<char>>>::_Alloc_proxy(void)
.text$mn:00008EA4                 public ?_Alloc_proxy@?$_Vector_alloc@$0A@U?$_Vec_base_types@DV?$allocator@D@std@@@std@@@std@@QAEXXZ
.text$mn:00008EA4 ?_Alloc_proxy@?$_Vector_alloc@$0A@U?$_Vec_base_types@DV?$allocator@D@std@@@std@@@std@@QAEXXZ proc near
.text$mn:00008EA4                                         ; CODE XREF: std::_Vector_alloc<0,std::_Vec_base_types<char,std::allocator<char>>>::_Vector_alloc<0,std::_Vec_base_types<char,std::allocator<char>>>(std::allocator<char> const &)+38p
.text$mn:00008EA4
.text$mn:00008EA4 var_10          = byte ptr -10h
.text$mn:00008EA4 var_8           = dword ptr -8
.text$mn:00008EA4 var_1           = byte ptr -1
.text$mn:00008EA4
.text$mn:00008EA4                 push    ebp
.text$mn:00008EA5                 mov     ebp, esp
.text$mn:00008EA7                 sub     esp, 10h
.text$mn:00008EAA                 mov     [ebp+var_8], ecx
.text$mn:00008EAD                 lea     ecx, [ebp+var_1]
.text$mn:00008EB0                 call    ??0?$_Wrap_alloc@V?$allocator@U_Container_proxy@std@@@std@@@std@@QAE@XZ ; std::_Wrap_alloc<std::allocator<std::_Container_proxy>>::_Wrap_alloc<std::allocator<std::_Container_proxy>>(void)
.text$mn:00008EB5                 push    1
.text$mn:00008EB7                 lea     ecx, [ebp+var_1]
.text$mn:00008EBA                 call    ?allocate@?$_Wrap_alloc@V?$allocator@U_Container_proxy@std@@@std@@@std@@QAEPAU_Container_proxy@2@I@Z ; std::_Wrap_alloc<std::allocator<std::_Container_proxy>>::allocate(uint)
.text$mn:00008EBF                 mov     ecx, [ebp+var_8]
.text$mn:00008EC2                 mov     [ecx], eax
.text$mn:00008EC4                 lea     ecx, [ebp+var_10] ; this
.text$mn:00008EC7                 call    ??0_Container_proxy@std@@QAE@XZ ; std::_Container_proxy::_Container_proxy(void)
.text$mn:00008ECC                 push    eax             ; int
.text$mn:00008ECD                 mov     edx, [ebp+var_8]
.text$mn:00008ED0                 mov     eax, [edx]
.text$mn:00008ED2                 push    eax             ; void *
.text$mn:00008ED3                 lea     ecx, [ebp+var_1]
.text$mn:00008ED6                 call    ??$construct@U_Container_proxy@std@@U12@@?$_Wrap_alloc@V?$allocator@U_Container_proxy@std@@@std@@@std@@QAEXPAU_Container_proxy@1@$$QAU21@@Z ; std::_Wrap_alloc<std::allocator<std::_Container_proxy>>::construct<std::_Container_proxy,std::_Container_proxy>(std::_Container_proxy *,std::_Container_proxy &&)
.text$mn:00008EDB                 mov     ecx, [ebp+var_8]
.text$mn:00008EDE                 mov     edx, [ecx]
.text$mn:00008EE0                 mov     eax, [ebp+var_8]
.text$mn:00008EE3                 mov     [edx], eax
.text$mn:00008EE5                 mov     esp, ebp
.text$mn:00008EE7                 pop     ebp
.text$mn:00008EE8                 retn
.text$mn:00008EE8 ?_Alloc_proxy@?$_Vector_alloc@$0A@U?$_Vec_base_types@DV?$allocator@D@std@@@std@@@std@@QAEXXZ endp
.text$mn:00008EE8
.text$mn:00008EE8 ; ---------------------------------------------------------------------------
.text$mn:00008EE9                 align 4
.text$mn:00008EE9 _text$mn        ends
.text$mn:00008EE9
.text$mn:00008EEC ; ===========================================================================
.text$mn:00008EEC
.text$mn:00008EEC ; Segment type: Pure code
.text$mn:00008EEC ; Segment permissions: Read/Execute
.text$mn:00008EEC _text$mn        segment para public 'CODE' use32
.text$mn:00008EEC                 assume cs:_text$mn
.text$mn:00008EEC                 ;org 8EECh
.text$mn:00008EEC ; COMDAT (pick any)
.text$mn:00008EEC                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text$mn:00008EEC
.text$mn:00008EEC ; =============== S U B R O U T I N E =======================================
.text$mn:00008EEC
.text$mn:00008EEC ; Attributes: bp-based frame
.text$mn:00008EEC
.text$mn:00008EEC ; public: void __thiscall std::_Vector_alloc<0, struct std::_Vec_base_types<class std::basic_string<wchar_t, struct std::char_traits<wchar_t>, class std::allocator<wchar_t>>, class std::allocator<class std::basic_string<wchar_t, struct std::char_traits<wchar_t>, class std::allocator<wchar_t>>>>>::_Alloc_proxy(void)
.text$mn:00008EEC                 public ?_Alloc_proxy@?$_Vector_alloc@$0A@U?$_Vec_base_types@V?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@V?$allocator@V?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@@2@@std@@@std@@QAEXXZ
.text$mn:00008EEC ?_Alloc_proxy@?$_Vector_alloc@$0A@U?$_Vec_base_types@V?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@V?$allocator@V?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@@2@@std@@@std@@QAEXXZ proc near
.text$mn:00008EEC                                         ; CODE XREF: std::_Vector_alloc<0,std::_Vec_base_types<std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>>,std::allocator<std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>>>>>::_Vector_alloc<0,std::_Vec_base_types<std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>>,std::allocator<std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>>>>>(std::allocator<std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>>> const &)+38p
.text$mn:00008EEC
.text$mn:00008EEC var_10          = byte ptr -10h
.text$mn:00008EEC var_8           = dword ptr -8
.text$mn:00008EEC var_1           = byte ptr -1
.text$mn:00008EEC
.text$mn:00008EEC                 push    ebp
.text$mn:00008EED                 mov     ebp, esp
.text$mn:00008EEF                 sub     esp, 10h
.text$mn:00008EF2                 mov     [ebp+var_8], ecx
.text$mn:00008EF5                 lea     ecx, [ebp+var_1]
.text$mn:00008EF8                 call    ??0?$_Wrap_alloc@V?$allocator@U_Container_proxy@std@@@std@@@std@@QAE@XZ ; std::_Wrap_alloc<std::allocator<std::_Container_proxy>>::_Wrap_alloc<std::allocator<std::_Container_proxy>>(void)
.text$mn:00008EFD                 push    1
.text$mn:00008EFF                 lea     ecx, [ebp+var_1]
.text$mn:00008F02                 call    ?allocate@?$_Wrap_alloc@V?$allocator@U_Container_proxy@std@@@std@@@std@@QAEPAU_Container_proxy@2@I@Z ; std::_Wrap_alloc<std::allocator<std::_Container_proxy>>::allocate(uint)
.text$mn:00008F07                 mov     ecx, [ebp+var_8]
.text$mn:00008F0A                 mov     [ecx], eax
.text$mn:00008F0C                 lea     ecx, [ebp+var_10] ; this
.text$mn:00008F0F                 call    ??0_Container_proxy@std@@QAE@XZ ; std::_Container_proxy::_Container_proxy(void)
.text$mn:00008F14                 push    eax             ; int
.text$mn:00008F15                 mov     edx, [ebp+var_8]
.text$mn:00008F18                 mov     eax, [edx]
.text$mn:00008F1A                 push    eax             ; void *
.text$mn:00008F1B                 lea     ecx, [ebp+var_1]
.text$mn:00008F1E                 call    ??$construct@U_Container_proxy@std@@U12@@?$_Wrap_alloc@V?$allocator@U_Container_proxy@std@@@std@@@std@@QAEXPAU_Container_proxy@1@$$QAU21@@Z ; std::_Wrap_alloc<std::allocator<std::_Container_proxy>>::construct<std::_Container_proxy,std::_Container_proxy>(std::_Container_proxy *,std::_Container_proxy &&)
.text$mn:00008F23                 mov     ecx, [ebp+var_8]
.text$mn:00008F26                 mov     edx, [ecx]
.text$mn:00008F28                 mov     eax, [ebp+var_8]
.text$mn:00008F2B                 mov     [edx], eax
.text$mn:00008F2D                 mov     esp, ebp
.text$mn:00008F2F                 pop     ebp
.text$mn:00008F30                 retn
.text$mn:00008F30 ?_Alloc_proxy@?$_Vector_alloc@$0A@U?$_Vec_base_types@V?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@V?$allocator@V?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@@2@@std@@@std@@QAEXXZ endp
.text$mn:00008F30
.text$mn:00008F30 ; ---------------------------------------------------------------------------
.text$mn:00008F31                 align 4
.text$mn:00008F31 _text$mn        ends
.text$mn:00008F31
.text$mn:00008F34 ; ===========================================================================
.text$mn:00008F34
.text$mn:00008F34 ; Segment type: Pure code
.text$mn:00008F34 ; Segment permissions: Read/Execute
.text$mn:00008F34 _text$mn        segment para public 'CODE' use32
.text$mn:00008F34                 assume cs:_text$mn
.text$mn:00008F34                 ;org 8F34h
.text$mn:00008F34 ; COMDAT (pick any)
.text$mn:00008F34                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text$mn:00008F34
.text$mn:00008F34 ; =============== S U B R O U T I N E =======================================
.text$mn:00008F34
.text$mn:00008F34 ; Attributes: bp-based frame
.text$mn:00008F34
.text$mn:00008F34 ; public: void __thiscall std::_Vector_alloc<0, struct std::_Vec_base_types<wchar_t, class std::allocator<wchar_t>>>::_Alloc_proxy(void)
.text$mn:00008F34                 public ?_Alloc_proxy@?$_Vector_alloc@$0A@U?$_Vec_base_types@_WV?$allocator@_W@std@@@std@@@std@@QAEXXZ
.text$mn:00008F34 ?_Alloc_proxy@?$_Vector_alloc@$0A@U?$_Vec_base_types@_WV?$allocator@_W@std@@@std@@@std@@QAEXXZ proc near
.text$mn:00008F34                                         ; CODE XREF: std::_Vector_alloc<0,std::_Vec_base_types<wchar_t,std::allocator<wchar_t>>>::_Vector_alloc<0,std::_Vec_base_types<wchar_t,std::allocator<wchar_t>>>(std::allocator<wchar_t> const &)+38p
.text$mn:00008F34
.text$mn:00008F34 var_10          = byte ptr -10h
.text$mn:00008F34 var_8           = dword ptr -8
.text$mn:00008F34 var_1           = byte ptr -1
.text$mn:00008F34
.text$mn:00008F34                 push    ebp
.text$mn:00008F35                 mov     ebp, esp
.text$mn:00008F37                 sub     esp, 10h
.text$mn:00008F3A                 mov     [ebp+var_8], ecx
.text$mn:00008F3D                 lea     ecx, [ebp+var_1]
.text$mn:00008F40                 call    ??0?$_Wrap_alloc@V?$allocator@U_Container_proxy@std@@@std@@@std@@QAE@XZ ; std::_Wrap_alloc<std::allocator<std::_Container_proxy>>::_Wrap_alloc<std::allocator<std::_Container_proxy>>(void)
.text$mn:00008F45                 push    1
.text$mn:00008F47                 lea     ecx, [ebp+var_1]
.text$mn:00008F4A                 call    ?allocate@?$_Wrap_alloc@V?$allocator@U_Container_proxy@std@@@std@@@std@@QAEPAU_Container_proxy@2@I@Z ; std::_Wrap_alloc<std::allocator<std::_Container_proxy>>::allocate(uint)
.text$mn:00008F4F                 mov     ecx, [ebp+var_8]
.text$mn:00008F52                 mov     [ecx], eax
.text$mn:00008F54                 lea     ecx, [ebp+var_10] ; this
.text$mn:00008F57                 call    ??0_Container_proxy@std@@QAE@XZ ; std::_Container_proxy::_Container_proxy(void)
.text$mn:00008F5C                 push    eax             ; int
.text$mn:00008F5D                 mov     edx, [ebp+var_8]
.text$mn:00008F60                 mov     eax, [edx]
.text$mn:00008F62                 push    eax             ; void *
.text$mn:00008F63                 lea     ecx, [ebp+var_1]
.text$mn:00008F66                 call    ??$construct@U_Container_proxy@std@@U12@@?$_Wrap_alloc@V?$allocator@U_Container_proxy@std@@@std@@@std@@QAEXPAU_Container_proxy@1@$$QAU21@@Z ; std::_Wrap_alloc<std::allocator<std::_Container_proxy>>::construct<std::_Container_proxy,std::_Container_proxy>(std::_Container_proxy *,std::_Container_proxy &&)
.text$mn:00008F6B                 mov     ecx, [ebp+var_8]
.text$mn:00008F6E                 mov     edx, [ecx]
.text$mn:00008F70                 mov     eax, [ebp+var_8]
.text$mn:00008F73                 mov     [edx], eax
.text$mn:00008F75                 mov     esp, ebp
.text$mn:00008F77                 pop     ebp
.text$mn:00008F78                 retn
.text$mn:00008F78 ?_Alloc_proxy@?$_Vector_alloc@$0A@U?$_Vec_base_types@_WV?$allocator@_W@std@@@std@@@std@@QAEXXZ endp
.text$mn:00008F78
.text$mn:00008F78 ; ---------------------------------------------------------------------------
.text$mn:00008F79                 align 4
.text$mn:00008F79 _text$mn        ends
.text$mn:00008F79
.text$mn:00008F7C ; ===========================================================================
.text$mn:00008F7C
.text$mn:00008F7C ; Segment type: Pure code
.text$mn:00008F7C ; Segment permissions: Read/Execute
.text$mn:00008F7C _text$mn        segment para public 'CODE' use32
.text$mn:00008F7C                 assume cs:_text$mn
.text$mn:00008F7C                 ;org 8F7Ch
.text$mn:00008F7C ; COMDAT (pick any)
.text$mn:00008F7C                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text$mn:00008F7C
.text$mn:00008F7C ; =============== S U B R O U T I N E =======================================
.text$mn:00008F7C
.text$mn:00008F7C ; Attributes: bp-based frame
.text$mn:00008F7C
.text$mn:00008F7C ; public: void __thiscall std::basic_string<char, struct std::char_traits<char>, class std::allocator<char>>::_Assign_rv(class std::basic_string<char, struct std::char_traits<char>, class std::allocator<char>> &&)
.text$mn:00008F7C                 public ?_Assign_rv@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEX$$QAV12@@Z
.text$mn:00008F7C ?_Assign_rv@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEX$$QAV12@@Z proc near
.text$mn:00008F7C                                         ; CODE XREF: std::basic_string<char,std::char_traits<char>,std::allocator<char>>::basic_string<char,std::char_traits<char>,std::allocator<char>>(std::basic_string<char,std::char_traits<char>,std::allocator<char>> &&)+60p
.text$mn:00008F7C
.text$mn:00008F7C var_8           = dword ptr -8
.text$mn:00008F7C var_1           = byte ptr -1
.text$mn:00008F7C arg_0           = dword ptr  8
.text$mn:00008F7C
.text$mn:00008F7C                 push    ebp
.text$mn:00008F7D                 mov     ebp, esp
.text$mn:00008F7F                 sub     esp, 8
.text$mn:00008F82                 mov     [ebp+var_8], ecx
.text$mn:00008F85                 mov     eax, [ebp+arg_0]
.text$mn:00008F88                 cmp     dword ptr [eax+18h], 10h
.text$mn:00008F8C                 jnb     short loc_8FB0
.text$mn:00008F8E                 mov     ecx, [ebp+arg_0]
.text$mn:00008F91                 mov     edx, [ecx+14h]
.text$mn:00008F94                 add     edx, 1
.text$mn:00008F97                 push    edx             ; Size
.text$mn:00008F98                 mov     eax, [ebp+arg_0]
.text$mn:00008F9B                 add     eax, 4
.text$mn:00008F9E                 push    eax             ; Src
.text$mn:00008F9F                 mov     ecx, [ebp+var_8]
.text$mn:00008FA2                 add     ecx, 4
.text$mn:00008FA5                 push    ecx             ; Dst
.text$mn:00008FA6                 call    ?move@?$char_traits@D@std@@SAPADPADPBDI@Z ; std::char_traits<char>::move(char *,char const *,uint)
.text$mn:00008FAB                 add     esp, 0Ch
.text$mn:00008FAE                 jmp     short loc_8FDB
.text$mn:00008FB0 ; ---------------------------------------------------------------------------
.text$mn:00008FB0
.text$mn:00008FB0 loc_8FB0:                               ; CODE XREF: std::basic_string<char,std::char_traits<char>,std::allocator<char>>::_Assign_rv(std::basic_string<char,std::char_traits<char>,std::allocator<char>> &&)+10j
.text$mn:00008FB0                 mov     edx, [ebp+arg_0]
.text$mn:00008FB3                 add     edx, 4
.text$mn:00008FB6                 push    edx             ; int
.text$mn:00008FB7                 mov     eax, [ebp+var_8]
.text$mn:00008FBA                 add     eax, 4
.text$mn:00008FBD                 push    eax             ; void *
.text$mn:00008FBE                 lea     ecx, [ebp+var_1]
.text$mn:00008FC1                 push    ecx
.text$mn:00008FC2                 mov     ecx, [ebp+var_8]
.text$mn:00008FC5                 call    ?_Getal@?$_String_alloc@$0A@U?$_String_base_types@DV?$allocator@D@std@@@std@@@std@@QBE?AU?$_Wrap_alloc@V?$allocator@D@std@@@2@XZ ; std::_String_alloc<0,std::_String_base_types<char,std::allocator<char>>>::_Getal(void)
.text$mn:00008FCA                 mov     ecx, eax
.text$mn:00008FCC                 call    ??$construct@PADAAPAD@?$_Wrap_alloc@V?$allocator@D@std@@@std@@QAEXPAPADAAPAD@Z ; std::_Wrap_alloc<std::allocator<char>>::construct<char *,char * &>(char * *,char * &)
.text$mn:00008FD1                 mov     edx, [ebp+arg_0]
.text$mn:00008FD4                 mov     dword ptr [edx+4], 0
.text$mn:00008FDB
.text$mn:00008FDB loc_8FDB:                               ; CODE XREF: std::basic_string<char,std::char_traits<char>,std::allocator<char>>::_Assign_rv(std::basic_string<char,std::char_traits<char>,std::allocator<char>> &&)+32j
.text$mn:00008FDB                 mov     eax, [ebp+var_8]
.text$mn:00008FDE                 mov     ecx, [ebp+arg_0]
.text$mn:00008FE1                 mov     edx, [ecx+14h]
.text$mn:00008FE4                 mov     [eax+14h], edx
.text$mn:00008FE7                 mov     eax, [ebp+var_8]
.text$mn:00008FEA                 mov     ecx, [ebp+arg_0]
.text$mn:00008FED                 mov     edx, [ecx+18h]
.text$mn:00008FF0                 mov     [eax+18h], edx
.text$mn:00008FF3                 push    0               ; Size
.text$mn:00008FF5                 push    0               ; char
.text$mn:00008FF7                 mov     ecx, [ebp+arg_0]
.text$mn:00008FFA                 call    ?_Tidy@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEX_NI@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char>>::_Tidy(bool,uint)
.text$mn:00008FFF                 mov     esp, ebp
.text$mn:00009001                 pop     ebp
.text$mn:00009002                 retn    4
.text$mn:00009002 ?_Assign_rv@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEX$$QAV12@@Z endp
.text$mn:00009002
.text$mn:00009002 ; ---------------------------------------------------------------------------
.text$mn:00009005                 align 4
.text$mn:00009005 _text$mn        ends
.text$mn:00009005
.text$mn:00009008 ; ===========================================================================
.text$mn:00009008
.text$mn:00009008 ; Segment type: Pure code
.text$mn:00009008 ; Segment permissions: Read/Execute
.text$mn:00009008 _text$mn        segment para public 'CODE' use32
.text$mn:00009008                 assume cs:_text$mn
.text$mn:00009008                 ;org 9008h
.text$mn:00009008 ; COMDAT (pick any)
.text$mn:00009008                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text$mn:00009008
.text$mn:00009008 ; =============== S U B R O U T I N E =======================================
.text$mn:00009008
.text$mn:00009008 ; Attributes: bp-based frame
.text$mn:00009008
.text$mn:00009008 ; public: void __thiscall std::basic_string<wchar_t, struct std::char_traits<wchar_t>, class std::allocator<wchar_t>>::_Assign_rv(class std::basic_string<wchar_t, struct std::char_traits<wchar_t>, class std::allocator<wchar_t>> &&)
.text$mn:00009008                 public ?_Assign_rv@?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QAEX$$QAV12@@Z
.text$mn:00009008 ?_Assign_rv@?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QAEX$$QAV12@@Z proc near
.text$mn:00009008                                         ; CODE XREF: std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>>::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>>(std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>> &&)+60p
.text$mn:00009008
.text$mn:00009008 var_8           = dword ptr -8
.text$mn:00009008 var_1           = byte ptr -1
.text$mn:00009008 arg_0           = dword ptr  8
.text$mn:00009008
.text$mn:00009008                 push    ebp
.text$mn:00009009                 mov     ebp, esp
.text$mn:0000900B                 sub     esp, 8
.text$mn:0000900E                 mov     [ebp+var_8], ecx
.text$mn:00009011                 mov     eax, [ebp+arg_0]
.text$mn:00009014                 cmp     dword ptr [eax+18h], 8
.text$mn:00009018                 jnb     short loc_903C
.text$mn:0000901A                 mov     ecx, [ebp+arg_0]
.text$mn:0000901D                 mov     edx, [ecx+14h]
.text$mn:00009020                 add     edx, 1
.text$mn:00009023                 push    edx             ; int
.text$mn:00009024                 mov     eax, [ebp+arg_0]
.text$mn:00009027                 add     eax, 4
.text$mn:0000902A                 push    eax             ; Src
.text$mn:0000902B                 mov     ecx, [ebp+var_8]
.text$mn:0000902E                 add     ecx, 4
.text$mn:00009031                 push    ecx             ; Dst
.text$mn:00009032                 call    ?move@?$char_traits@_W@std@@SAPA_WPA_WPB_WI@Z ; std::char_traits<wchar_t>::move(wchar_t *,wchar_t const *,uint)
.text$mn:00009037                 add     esp, 0Ch
.text$mn:0000903A                 jmp     short loc_9067
.text$mn:0000903C ; ---------------------------------------------------------------------------
.text$mn:0000903C
.text$mn:0000903C loc_903C:                               ; CODE XREF: std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>>::_Assign_rv(std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>> &&)+10j
.text$mn:0000903C                 mov     edx, [ebp+arg_0]
.text$mn:0000903F                 add     edx, 4
.text$mn:00009042                 push    edx             ; int
.text$mn:00009043                 mov     eax, [ebp+var_8]
.text$mn:00009046                 add     eax, 4
.text$mn:00009049                 push    eax             ; void *
.text$mn:0000904A                 lea     ecx, [ebp+var_1]
.text$mn:0000904D                 push    ecx
.text$mn:0000904E                 mov     ecx, [ebp+var_8]
.text$mn:00009051                 call    ?_Getal@?$_String_alloc@$0A@U?$_String_base_types@_WV?$allocator@_W@std@@@std@@@std@@QBE?AU?$_Wrap_alloc@V?$allocator@_W@std@@@2@XZ ; std::_String_alloc<0,std::_String_base_types<wchar_t,std::allocator<wchar_t>>>::_Getal(void)
.text$mn:00009056                 mov     ecx, eax
.text$mn:00009058                 call    ??$construct@PA_WAAPA_W@?$_Wrap_alloc@V?$allocator@_W@std@@@std@@QAEXPAPA_WAAPA_W@Z ; std::_Wrap_alloc<std::allocator<wchar_t>>::construct<wchar_t *,wchar_t * &>(wchar_t * *,wchar_t * &)
.text$mn:0000905D                 mov     edx, [ebp+arg_0]
.text$mn:00009060                 mov     dword ptr [edx+4], 0
.text$mn:00009067
.text$mn:00009067 loc_9067:                               ; CODE XREF: std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>>::_Assign_rv(std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>> &&)+32j
.text$mn:00009067                 mov     eax, [ebp+var_8]
.text$mn:0000906A                 mov     ecx, [ebp+arg_0]
.text$mn:0000906D                 mov     edx, [ecx+14h]
.text$mn:00009070                 mov     [eax+14h], edx
.text$mn:00009073                 mov     eax, [ebp+var_8]
.text$mn:00009076                 mov     ecx, [ebp+arg_0]
.text$mn:00009079                 mov     edx, [ecx+18h]
.text$mn:0000907C                 mov     [eax+18h], edx
.text$mn:0000907F                 push    0
.text$mn:00009081                 push    0
.text$mn:00009083                 mov     ecx, [ebp+arg_0]
.text$mn:00009086                 call    ?_Tidy@?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QAEX_NI@Z ; std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>>::_Tidy(bool,uint)
.text$mn:0000908B                 mov     esp, ebp
.text$mn:0000908D                 pop     ebp
.text$mn:0000908E                 retn    4
.text$mn:0000908E ?_Assign_rv@?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QAEX$$QAV12@@Z endp
.text$mn:0000908E
.text$mn:0000908E ; ---------------------------------------------------------------------------
.text$mn:00009091                 align 4
.text$mn:00009091 _text$mn        ends
.text$mn:00009091
.text$mn:00009094 ; ===========================================================================
.text$mn:00009094
.text$mn:00009094 ; Segment type: Pure code
.text$mn:00009094 ; Segment permissions: Read/Execute
.text$mn:00009094 _text$mn        segment para public 'CODE' use32
.text$mn:00009094                 assume cs:_text$mn
.text$mn:00009094                 ;org 9094h
.text$mn:00009094 ; COMDAT (pick any)
.text$mn:00009094                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text$mn:00009094
.text$mn:00009094 ; =============== S U B R O U T I N E =======================================
.text$mn:00009094
.text$mn:00009094 ; Attributes: bp-based frame
.text$mn:00009094
.text$mn:00009094 ; int __stdcall std::vector<std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>>,std::allocator<std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>>>>::_Assign_rv(struct std::_Container_base12 *, int)
.text$mn:00009094                 public ?_Assign_rv@?$vector@V?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@V?$allocator@V?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@@2@@std@@QAEX$$QAV12@U?$integral_constant@_N$00@2@@Z
.text$mn:00009094 ?_Assign_rv@?$vector@V?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@V?$allocator@V?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@@2@@std@@QAEX$$QAV12@U?$integral_constant@_N$00@2@@Z proc near
.text$mn:00009094                                         ; CODE XREF: std::vector<std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>>,std::allocator<std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>>>>::vector<std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>>,std::allocator<std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>>>>(std::vector<std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>>,std::allocator<std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>>>> &&)+5Ep
.text$mn:00009094
.text$mn:00009094 var_4           = dword ptr -4
.text$mn:00009094 arg_0           = dword ptr  8
.text$mn:00009094
.text$mn:00009094                 push    ebp
.text$mn:00009095                 mov     ebp, esp
.text$mn:00009097                 push    ecx
.text$mn:00009098                 mov     [ebp+var_4], ecx
.text$mn:0000909B                 mov     eax, [ebp+arg_0]
.text$mn:0000909E                 push    eax             ; struct std::_Container_base12 *
.text$mn:0000909F                 mov     ecx, [ebp+var_4] ; this
.text$mn:000090A2                 call    ?_Swap_all@_Container_base12@std@@QAEXAAU12@@Z ; std::_Container_base12::_Swap_all(std::_Container_base12 &)
.text$mn:000090A7                 mov     ecx, [ebp+var_4]
.text$mn:000090AA                 mov     edx, [ebp+arg_0]
.text$mn:000090AD                 mov     eax, [edx+4]
.text$mn:000090B0                 mov     [ecx+4], eax
.text$mn:000090B3                 mov     ecx, [ebp+var_4]
.text$mn:000090B6                 mov     edx, [ebp+arg_0]
.text$mn:000090B9                 mov     eax, [edx+8]
.text$mn:000090BC                 mov     [ecx+8], eax
.text$mn:000090BF                 mov     ecx, [ebp+var_4]
.text$mn:000090C2                 mov     edx, [ebp+arg_0]
.text$mn:000090C5                 mov     eax, [edx+0Ch]
.text$mn:000090C8                 mov     [ecx+0Ch], eax
.text$mn:000090CB                 mov     ecx, [ebp+arg_0]
.text$mn:000090CE                 mov     dword ptr [ecx+4], 0
.text$mn:000090D5                 mov     edx, [ebp+arg_0]
.text$mn:000090D8                 mov     dword ptr [edx+8], 0
.text$mn:000090DF                 mov     eax, [ebp+arg_0]
.text$mn:000090E2                 mov     dword ptr [eax+0Ch], 0
.text$mn:000090E9                 mov     esp, ebp
.text$mn:000090EB                 pop     ebp
.text$mn:000090EC                 retn    8
.text$mn:000090EC ?_Assign_rv@?$vector@V?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@V?$allocator@V?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@@2@@std@@QAEX$$QAV12@U?$integral_constant@_N$00@2@@Z endp
.text$mn:000090EC
.text$mn:000090EC ; ---------------------------------------------------------------------------
.text$mn:000090EF                 align 10h
.text$mn:000090EF _text$mn        ends
.text$mn:000090EF
.text$mn:000090F0 ; ===========================================================================
.text$mn:000090F0
.text$mn:000090F0 ; Segment type: Pure code
.text$mn:000090F0 ; Segment permissions: Read/Execute
.text$mn:000090F0 _text$mn        segment para public 'CODE' use32
.text$mn:000090F0                 assume cs:_text$mn
.text$mn:000090F0                 ;org 90F0h
.text$mn:000090F0 ; COMDAT (pick any)
.text$mn:000090F0                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text$mn:000090F0
.text$mn:000090F0 ; =============== S U B R O U T I N E =======================================
.text$mn:000090F0
.text$mn:000090F0 ; Attributes: bp-based frame
.text$mn:000090F0
.text$mn:000090F0 ; protected: bool __thiscall std::vector<char, class std::allocator<char>>::_Buy(unsigned int)
.text$mn:000090F0                 public ?_Buy@?$vector@DV?$allocator@D@std@@@std@@IAE_NI@Z
.text$mn:000090F0 ?_Buy@?$vector@DV?$allocator@D@std@@@std@@IAE_NI@Z proc near
.text$mn:000090F0                                         ; CODE XREF: std::vector<char,std::allocator<char>>::vector<char,std::allocator<char>>(uint)+4Ep
.text$mn:000090F0
.text$mn:000090F0 var_8           = dword ptr -8
.text$mn:000090F0 var_1           = byte ptr -1
.text$mn:000090F0 arg_0           = dword ptr  8
.text$mn:000090F0
.text$mn:000090F0                 push    ebp
.text$mn:000090F1                 mov     ebp, esp
.text$mn:000090F3                 sub     esp, 8
.text$mn:000090F6                 mov     [ebp+var_8], ecx
.text$mn:000090F9                 mov     eax, [ebp+var_8]
.text$mn:000090FC                 mov     dword ptr [eax+4], 0
.text$mn:00009103                 mov     ecx, [ebp+var_8]
.text$mn:00009106                 mov     dword ptr [ecx+8], 0
.text$mn:0000910D                 mov     edx, [ebp+var_8]
.text$mn:00009110                 mov     dword ptr [edx+0Ch], 0
.text$mn:00009117                 cmp     [ebp+arg_0], 0
.text$mn:0000911B                 jnz     short loc_9123
.text$mn:0000911D                 xor     al, al
.text$mn:0000911F                 jmp     short loc_9174
.text$mn:00009121 ; ---------------------------------------------------------------------------
.text$mn:00009121                 jmp     short loc_9172
.text$mn:00009123 ; ---------------------------------------------------------------------------
.text$mn:00009123
.text$mn:00009123 loc_9123:                               ; CODE XREF: std::vector<char,std::allocator<char>>::_Buy(uint)+2Bj
.text$mn:00009123                 mov     ecx, [ebp+var_8]
.text$mn:00009126                 call    ?max_size@?$vector@DV?$allocator@D@std@@@std@@QBEIXZ ; std::vector<char,std::allocator<char>>::max_size(void)
.text$mn:0000912B                 cmp     eax, [ebp+arg_0]
.text$mn:0000912E                 jnb     short loc_913A
.text$mn:00009130                 mov     ecx, [ebp+var_8]
.text$mn:00009133                 call    ?_Xlen@?$vector@DV?$allocator@D@std@@@std@@IBEXXZ ; std::vector<char,std::allocator<char>>::_Xlen(void)
.text$mn:00009138                 jmp     short loc_9172
.text$mn:0000913A ; ---------------------------------------------------------------------------
.text$mn:0000913A
.text$mn:0000913A loc_913A:                               ; CODE XREF: std::vector<char,std::allocator<char>>::_Buy(uint)+3Ej
.text$mn:0000913A                 mov     eax, [ebp+arg_0]
.text$mn:0000913D                 push    eax
.text$mn:0000913E                 lea     ecx, [ebp+var_1]
.text$mn:00009141                 push    ecx
.text$mn:00009142                 mov     ecx, [ebp+var_8]
.text$mn:00009145                 call    ?_Getal@?$_Vector_alloc@$0A@U?$_Vec_base_types@DV?$allocator@D@std@@@std@@@std@@QBE?AU?$_Wrap_alloc@V?$allocator@D@std@@@2@XZ ; std::_Vector_alloc<0,std::_Vec_base_types<char,std::allocator<char>>>::_Getal(void)
.text$mn:0000914A                 mov     ecx, eax
.text$mn:0000914C                 call    ?allocate@?$_Wrap_alloc@V?$allocator@D@std@@@std@@QAEPADI@Z ; std::_Wrap_alloc<std::allocator<char>>::allocate(uint)
.text$mn:00009151                 mov     edx, [ebp+var_8]
.text$mn:00009154                 mov     [edx+4], eax
.text$mn:00009157                 mov     eax, [ebp+var_8]
.text$mn:0000915A                 mov     ecx, [ebp+var_8]
.text$mn:0000915D                 mov     edx, [ecx+4]
.text$mn:00009160                 mov     [eax+8], edx
.text$mn:00009163                 mov     eax, [ebp+var_8]
.text$mn:00009166                 mov     ecx, [eax+4]
.text$mn:00009169                 add     ecx, [ebp+arg_0]
.text$mn:0000916C                 mov     edx, [ebp+var_8]
.text$mn:0000916F                 mov     [edx+0Ch], ecx
.text$mn:00009172
.text$mn:00009172 loc_9172:                               ; CODE XREF: std::vector<char,std::allocator<char>>::_Buy(uint)+31j
.text$mn:00009172                                         ; std::vector<char,std::allocator<char>>::_Buy(uint)+48j
.text$mn:00009172                 mov     al, 1
.text$mn:00009174
.text$mn:00009174 loc_9174:                               ; CODE XREF: std::vector<char,std::allocator<char>>::_Buy(uint)+2Fj
.text$mn:00009174                 mov     esp, ebp
.text$mn:00009176                 pop     ebp
.text$mn:00009177                 retn    4
.text$mn:00009177 ?_Buy@?$vector@DV?$allocator@D@std@@@std@@IAE_NI@Z endp
.text$mn:00009177
.text$mn:00009177 ; ---------------------------------------------------------------------------
.text$mn:0000917A                 align 4
.text$mn:0000917A _text$mn        ends
.text$mn:0000917A
.text$mn:0000917C ; ===========================================================================
.text$mn:0000917C
.text$mn:0000917C ; Segment type: Pure code
.text$mn:0000917C ; Segment permissions: Read/Execute
.text$mn:0000917C _text$mn        segment para public 'CODE' use32
.text$mn:0000917C                 assume cs:_text$mn
.text$mn:0000917C                 ;org 917Ch
.text$mn:0000917C ; COMDAT (pick any)
.text$mn:0000917C                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text$mn:0000917C
.text$mn:0000917C ; =============== S U B R O U T I N E =======================================
.text$mn:0000917C
.text$mn:0000917C ; Attributes: bp-based frame
.text$mn:0000917C
.text$mn:0000917C ; protected: bool __thiscall std::vector<wchar_t, class std::allocator<wchar_t>>::_Buy(unsigned int)
.text$mn:0000917C                 public ?_Buy@?$vector@_WV?$allocator@_W@std@@@std@@IAE_NI@Z
.text$mn:0000917C ?_Buy@?$vector@_WV?$allocator@_W@std@@@std@@IAE_NI@Z proc near
.text$mn:0000917C                                         ; CODE XREF: std::vector<wchar_t,std::allocator<wchar_t>>::vector<wchar_t,std::allocator<wchar_t>>(uint)+4Ep
.text$mn:0000917C
.text$mn:0000917C var_8           = dword ptr -8
.text$mn:0000917C var_1           = byte ptr -1
.text$mn:0000917C arg_0           = dword ptr  8
.text$mn:0000917C
.text$mn:0000917C                 push    ebp
.text$mn:0000917D                 mov     ebp, esp
.text$mn:0000917F                 sub     esp, 8
.text$mn:00009182                 mov     [ebp+var_8], ecx
.text$mn:00009185                 mov     eax, [ebp+var_8]
.text$mn:00009188                 mov     dword ptr [eax+4], 0
.text$mn:0000918F                 mov     ecx, [ebp+var_8]
.text$mn:00009192                 mov     dword ptr [ecx+8], 0
.text$mn:00009199                 mov     edx, [ebp+var_8]
.text$mn:0000919C                 mov     dword ptr [edx+0Ch], 0
.text$mn:000091A3                 cmp     [ebp+arg_0], 0
.text$mn:000091A7                 jnz     short loc_91AF
.text$mn:000091A9                 xor     al, al
.text$mn:000091AB                 jmp     short loc_9203
.text$mn:000091AD ; ---------------------------------------------------------------------------
.text$mn:000091AD                 jmp     short loc_9201
.text$mn:000091AF ; ---------------------------------------------------------------------------
.text$mn:000091AF
.text$mn:000091AF loc_91AF:                               ; CODE XREF: std::vector<wchar_t,std::allocator<wchar_t>>::_Buy(uint)+2Bj
.text$mn:000091AF                 mov     ecx, [ebp+var_8]
.text$mn:000091B2                 call    ?max_size@?$vector@_WV?$allocator@_W@std@@@std@@QBEIXZ ; std::vector<wchar_t,std::allocator<wchar_t>>::max_size(void)
.text$mn:000091B7                 cmp     eax, [ebp+arg_0]
.text$mn:000091BA                 jnb     short loc_91C6
.text$mn:000091BC                 mov     ecx, [ebp+var_8]
.text$mn:000091BF                 call    ?_Xlen@?$vector@_WV?$allocator@_W@std@@@std@@IBEXXZ ; std::vector<wchar_t,std::allocator<wchar_t>>::_Xlen(void)
.text$mn:000091C4                 jmp     short loc_9201
.text$mn:000091C6 ; ---------------------------------------------------------------------------
.text$mn:000091C6
.text$mn:000091C6 loc_91C6:                               ; CODE XREF: std::vector<wchar_t,std::allocator<wchar_t>>::_Buy(uint)+3Ej
.text$mn:000091C6                 mov     eax, [ebp+arg_0]
.text$mn:000091C9                 push    eax
.text$mn:000091CA                 lea     ecx, [ebp+var_1]
.text$mn:000091CD                 push    ecx
.text$mn:000091CE                 mov     ecx, [ebp+var_8]
.text$mn:000091D1                 call    ?_Getal@?$_Vector_alloc@$0A@U?$_Vec_base_types@_WV?$allocator@_W@std@@@std@@@std@@QBE?AU?$_Wrap_alloc@V?$allocator@_W@std@@@2@XZ ; std::_Vector_alloc<0,std::_Vec_base_types<wchar_t,std::allocator<wchar_t>>>::_Getal(void)
.text$mn:000091D6                 mov     ecx, eax
.text$mn:000091D8                 call    ?allocate@?$_Wrap_alloc@V?$allocator@_W@std@@@std@@QAEPA_WI@Z ; std::_Wrap_alloc<std::allocator<wchar_t>>::allocate(uint)
.text$mn:000091DD                 mov     edx, [ebp+var_8]
.text$mn:000091E0                 mov     [edx+4], eax
.text$mn:000091E3                 mov     eax, [ebp+var_8]
.text$mn:000091E6                 mov     ecx, [ebp+var_8]
.text$mn:000091E9                 mov     edx, [ecx+4]
.text$mn:000091EC                 mov     [eax+8], edx
.text$mn:000091EF                 mov     eax, [ebp+var_8]
.text$mn:000091F2                 mov     ecx, [eax+4]
.text$mn:000091F5                 mov     edx, [ebp+arg_0]
.text$mn:000091F8                 lea     eax, [ecx+edx*2]
.text$mn:000091FB                 mov     ecx, [ebp+var_8]
.text$mn:000091FE                 mov     [ecx+0Ch], eax
.text$mn:00009201
.text$mn:00009201 loc_9201:                               ; CODE XREF: std::vector<wchar_t,std::allocator<wchar_t>>::_Buy(uint)+31j
.text$mn:00009201                                         ; std::vector<wchar_t,std::allocator<wchar_t>>::_Buy(uint)+48j
.text$mn:00009201                 mov     al, 1
.text$mn:00009203
.text$mn:00009203 loc_9203:                               ; CODE XREF: std::vector<wchar_t,std::allocator<wchar_t>>::_Buy(uint)+2Fj
.text$mn:00009203                 mov     esp, ebp
.text$mn:00009205                 pop     ebp
.text$mn:00009206                 retn    4
.text$mn:00009206 ?_Buy@?$vector@_WV?$allocator@_W@std@@@std@@IAE_NI@Z endp
.text$mn:00009206
.text$mn:00009206 ; ---------------------------------------------------------------------------
.text$mn:00009209                 align 4
.text$mn:00009209 _text$mn        ends
.text$mn:00009209
.text$mn:0000920C ; ===========================================================================
.text$mn:0000920C
.text$mn:0000920C ; Segment type: Pure code
.text$mn:0000920C ; Segment permissions: Read/Execute
.text$mn:0000920C _text$mn        segment para public 'CODE' use32
.text$mn:0000920C                 assume cs:_text$mn
.text$mn:0000920C                 ;org 920Ch
.text$mn:0000920C ; COMDAT (pick any)
.text$mn:0000920C                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text$mn:0000920C
.text$mn:0000920C ; =============== S U B R O U T I N E =======================================
.text$mn:0000920C
.text$mn:0000920C ; Attributes: bp-based frame
.text$mn:0000920C
.text$mn:0000920C ; public: void __thiscall std::_String_alloc<0, struct std::_String_base_types<wchar_t, class std::allocator<wchar_t>>>::_Change_alloc(struct std::_Wrap_alloc<class std::allocator<wchar_t>> const &)
.text$mn:0000920C                 public ?_Change_alloc@?$_String_alloc@$0A@U?$_String_base_types@_WV?$allocator@_W@std@@@std@@@std@@QAEXABU?$_Wrap_alloc@V?$allocator@_W@std@@@2@@Z
.text$mn:0000920C ?_Change_alloc@?$_String_alloc@$0A@U?$_String_base_types@_WV?$allocator@_W@std@@@std@@@std@@QAEXABU?$_Wrap_alloc@V?$allocator@_W@std@@@2@@Z proc near
.text$mn:0000920C                                         ; CODE XREF: std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>>::operator=(std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>> const &)+5Ap
.text$mn:0000920C
.text$mn:0000920C var_4           = dword ptr -4
.text$mn:0000920C
.text$mn:0000920C                 push    ebp
.text$mn:0000920D                 mov     ebp, esp
.text$mn:0000920F                 push    ecx
.text$mn:00009210                 mov     [ebp+var_4], ecx
.text$mn:00009213                 mov     esp, ebp
.text$mn:00009215                 pop     ebp
.text$mn:00009216                 retn    4
.text$mn:00009216 ?_Change_alloc@?$_String_alloc@$0A@U?$_String_base_types@_WV?$allocator@_W@std@@@std@@@std@@QAEXABU?$_Wrap_alloc@V?$allocator@_W@std@@@2@@Z endp
.text$mn:00009216
.text$mn:00009216 ; ---------------------------------------------------------------------------
.text$mn:00009219                 align 4
.text$mn:00009219 _text$mn        ends
.text$mn:00009219
.text$mn:0000921C ; ===========================================================================
.text$mn:0000921C
.text$mn:0000921C ; Segment type: Pure code
.text$mn:0000921C ; Segment permissions: Read/Execute
.text$mn:0000921C _text$mn        segment para public 'CODE' use32
.text$mn:0000921C                 assume cs:_text$mn
.text$mn:0000921C                 ;org 921Ch
.text$mn:0000921C ; COMDAT (pick any)
.text$mn:0000921C                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text$mn:0000921C
.text$mn:0000921C ; =============== S U B R O U T I N E =======================================
.text$mn:0000921C
.text$mn:0000921C ; Attributes: bp-based frame
.text$mn:0000921C
.text$mn:0000921C ; public: void __thiscall std::basic_string<wchar_t, struct std::char_traits<wchar_t>, class std::allocator<wchar_t>>::_Chassign(unsigned int, unsigned int, wchar_t)
.text$mn:0000921C                 public ?_Chassign@?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QAEXII_W@Z
.text$mn:0000921C ?_Chassign@?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QAEXII_W@Z proc near
.text$mn:0000921C                                         ; CODE XREF: std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>>::append(uint,wchar_t)+5Cp
.text$mn:0000921C                                         ; std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>>::insert(uint,uint,wchar_t)+A1p
.text$mn:0000921C
.text$mn:0000921C var_4           = dword ptr -4
.text$mn:0000921C arg_0           = dword ptr  8
.text$mn:0000921C arg_4           = dword ptr  0Ch
.text$mn:0000921C arg_8           = word ptr  10h
.text$mn:0000921C
.text$mn:0000921C                 push    ebp
.text$mn:0000921D                 mov     ebp, esp
.text$mn:0000921F                 push    ecx
.text$mn:00009220                 mov     [ebp+var_4], ecx
.text$mn:00009223                 cmp     [ebp+arg_4], 1
.text$mn:00009227                 jnz     short loc_9246
.text$mn:00009229                 lea     eax, [ebp+arg_8]
.text$mn:0000922C                 push    eax
.text$mn:0000922D                 mov     ecx, [ebp+var_4]
.text$mn:00009230                 call    ?_Myptr@?$_String_val@U?$_Simple_types@_W@std@@@std@@QAEPA_WXZ ; std::_String_val<std::_Simple_types<wchar_t>>::_Myptr(void)
.text$mn:00009235                 mov     ecx, [ebp+arg_0]
.text$mn:00009238                 lea     edx, [eax+ecx*2]
.text$mn:0000923B                 push    edx
.text$mn:0000923C                 call    ?assign@?$char_traits@_W@std@@SAXAA_WAB_W@Z ; std::char_traits<wchar_t>::assign(wchar_t &,wchar_t const &)
.text$mn:00009241                 add     esp, 8
.text$mn:00009244                 jmp     short loc_9266
.text$mn:00009246 ; ---------------------------------------------------------------------------
.text$mn:00009246
.text$mn:00009246 loc_9246:                               ; CODE XREF: std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>>::_Chassign(uint,uint,wchar_t)+Bj
.text$mn:00009246                 movzx   eax, [ebp+arg_8]
.text$mn:0000924A                 push    eax
.text$mn:0000924B                 mov     ecx, [ebp+arg_4]
.text$mn:0000924E                 push    ecx
.text$mn:0000924F                 mov     ecx, [ebp+var_4]
.text$mn:00009252                 call    ?_Myptr@?$_String_val@U?$_Simple_types@_W@std@@@std@@QAEPA_WXZ ; std::_String_val<std::_Simple_types<wchar_t>>::_Myptr(void)
.text$mn:00009257                 mov     edx, [ebp+arg_0]
.text$mn:0000925A                 lea     eax, [eax+edx*2]
.text$mn:0000925D                 push    eax
.text$mn:0000925E                 call    ?assign@?$char_traits@_W@std@@SAPA_WPA_WI_W@Z ; std::char_traits<wchar_t>::assign(wchar_t *,uint,wchar_t)
.text$mn:00009263                 add     esp, 0Ch
.text$mn:00009266
.text$mn:00009266 loc_9266:                               ; CODE XREF: std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>>::_Chassign(uint,uint,wchar_t)+28j
.text$mn:00009266                 mov     esp, ebp
.text$mn:00009268                 pop     ebp
.text$mn:00009269                 retn    0Ch
.text$mn:00009269 ?_Chassign@?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QAEXII_W@Z endp
.text$mn:00009269
.text$mn:00009269 _text$mn        ends
.text$mn:00009269
.text$mn:0000926C ; ===========================================================================
.text$mn:0000926C
.text$mn:0000926C ; Segment type: Pure code
.text$mn:0000926C ; Segment permissions: Read/Execute
.text$mn:0000926C _text$mn        segment para public 'CODE' use32
.text$mn:0000926C                 assume cs:_text$mn
.text$mn:0000926C                 ;org 926Ch
.text$mn:0000926C ; COMDAT (pick any)
.text$mn:0000926C                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text$mn:0000926C
.text$mn:0000926C ; =============== S U B R O U T I N E =======================================
.text$mn:0000926C
.text$mn:0000926C ; Attributes: bp-based frame
.text$mn:0000926C
.text$mn:0000926C ; void __thiscall std::_Iterator_base12::_Clrcont(std::_Iterator_base12 *__hidden this)
.text$mn:0000926C                 public ?_Clrcont@_Iterator_base12@std@@QAEXXZ
.text$mn:0000926C ?_Clrcont@_Iterator_base12@std@@QAEXXZ proc near
.text$mn:0000926C                                         ; CODE XREF: std::vector<std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>>,std::allocator<std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>>>>::_Orphan_range(std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>> *,std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>> *)+80p
.text$mn:0000926C                                         ; std::vector<wchar_t,std::allocator<wchar_t>>::_Orphan_range(wchar_t *,wchar_t *)+80p
.text$mn:0000926C
.text$mn:0000926C var_4           = dword ptr -4
.text$mn:0000926C
.text$mn:0000926C                 push    ebp
.text$mn:0000926D                 mov     ebp, esp
.text$mn:0000926F                 push    ecx
.text$mn:00009270                 mov     [ebp+var_4], ecx
.text$mn:00009273                 mov     eax, [ebp+var_4]
.text$mn:00009276                 mov     dword ptr [eax], 0
.text$mn:0000927C                 mov     esp, ebp
.text$mn:0000927E                 pop     ebp
.text$mn:0000927F                 retn
.text$mn:0000927F ?_Clrcont@_Iterator_base12@std@@QAEXXZ endp
.text$mn:0000927F
.text$mn:0000927F _text$mn        ends
.text$mn:0000927F
.text$mn:00009280 ; ===========================================================================
.text$mn:00009280
.text$mn:00009280 ; Segment type: Pure code
.text$mn:00009280 ; Segment permissions: Read/Execute
.text$mn:00009280 _text$mn        segment para public 'CODE' use32
.text$mn:00009280                 assume cs:_text$mn
.text$mn:00009280                 ;org 9280h
.text$mn:00009280 ; COMDAT (pick any)
.text$mn:00009280                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text$mn:00009280
.text$mn:00009280 ; =============== S U B R O U T I N E =======================================
.text$mn:00009280
.text$mn:00009280 ; Attributes: bp-based frame
.text$mn:00009280
.text$mn:00009280 ; int __stdcall std::_String_const_iterator<std::_String_val<std::_Simple_types<wchar_t>>>::_Compat(std::_Iterator_base12 *)
.text$mn:00009280                 public ?_Compat@?$_String_const_iterator@V?$_String_val@U?$_Simple_types@_W@std@@@std@@@std@@QBEXABV12@@Z
.text$mn:00009280 ?_Compat@?$_String_const_iterator@V?$_String_val@U?$_Simple_types@_W@std@@@std@@@std@@QBEXABV12@@Z proc near
.text$mn:00009280                                         ; CODE XREF: std::_String_const_iterator<std::_String_val<std::_Simple_types<wchar_t>>>::operator==(std::_String_const_iterator<std::_String_val<std::_Simple_types<wchar_t>>> const &)+10p
.text$mn:00009280                                         ; std::_String_const_iterator<std::_String_val<std::_Simple_types<wchar_t>>>::operator-(std::_String_const_iterator<std::_String_val<std::_Simple_types<wchar_t>>> const &)+Ep ...
.text$mn:00009280
.text$mn:00009280 var_4           = dword ptr -4
.text$mn:00009280 arg_0           = dword ptr  8
.text$mn:00009280
.text$mn:00009280                 push    ebp
.text$mn:00009281                 mov     ebp, esp
.text$mn:00009283                 push    ecx
.text$mn:00009284                 push    esi
.text$mn:00009285                 mov     [ebp+var_4], ecx
.text$mn:00009288                 mov     ecx, [ebp+var_4] ; this
.text$mn:0000928B                 call    ?_Getcont@_Iterator_base12@std@@QBEPBU_Container_base12@2@XZ ; std::_Iterator_base12::_Getcont(void)
.text$mn:00009290                 test    eax, eax
.text$mn:00009292                 jz      short loc_92AA
.text$mn:00009294                 mov     ecx, [ebp+var_4] ; this
.text$mn:00009297                 call    ?_Getcont@_Iterator_base12@std@@QBEPBU_Container_base12@2@XZ ; std::_Iterator_base12::_Getcont(void)
.text$mn:0000929C                 mov     esi, eax
.text$mn:0000929E                 mov     ecx, [ebp+arg_0] ; this
.text$mn:000092A1                 call    ?_Getcont@_Iterator_base12@std@@QBEPBU_Container_base12@2@XZ ; std::_Iterator_base12::_Getcont(void)
.text$mn:000092A6                 cmp     esi, eax
.text$mn:000092A8                 jz      short loc_9312
.text$mn:000092AA
.text$mn:000092AA loc_92AA:                               ; CODE XREF: std::_String_const_iterator<std::_String_val<std::_Simple_types<wchar_t>>>::_Compat(std::_String_const_iterator<std::_String_val<std::_Simple_types<wchar_t>>> const &)+12j
.text$mn:000092AA                 push    0FAh ; '·'      ; unsigned int
.text$mn:000092AF                 push    offset ??_C@_1IO@FEAPGJBD@?$AAC?$AA?3?$AA?2?$AAP?$AAr?$AAo?$AAg?$AAr?$AAa?$AAm?$AA?5?$AAF?$AAi?$AAl?$AAe?$AAs?$AA?5?$AA?$CI?$AAx?$AA8?$AA6?$AA?$CJ?$AA?2?$AAM?$AAi?$AAc?$AAr?$AAo?$AAs?$AAo?$AAf?$AAt@ ; "C:\\Program Files (x86)\\Microsoft Visu"...
.text$mn:000092B4                 push    offset ??_C@_1DM@KDEKGMPF@?$AAs?$AAt?$AAr?$AAi?$AAn?$AAg?$AA?5?$AAi?$AAt?$AAe?$AAr?$AAa?$AAt?$AAo?$AAr?$AAs?$AA?5?$AAi?$AAn?$AAc?$AAo?$AAm?$AAp?$AAa?$AAt?$AAi?$AAb?$AAl?$AAe?$AA?$AA@ ; "string iterators incompatible"
.text$mn:000092B9                 call    ?_Debug_message@std@@YAXPB_W0I@Z ; std::_Debug_message(wchar_t const *,wchar_t const *,uint)
.text$mn:000092BE                 add     esp, 0Ch
.text$mn:000092C1                 mov     eax, offset ??_C@_0CI@FNPHFCCM@Standard?5C?$CL?$CL?5Libraries?5Invalid?5A@ ; "Standard C++ Libraries Invalid Argument"
.text$mn:000092C6                 test    eax, eax
.text$mn:000092C8                 jz      short loc_92CE
.text$mn:000092CA                 xor     ecx, ecx
.text$mn:000092CC                 jnz     short loc_92F4
.text$mn:000092CE
.text$mn:000092CE loc_92CE:                               ; CODE XREF: std::_String_const_iterator<std::_String_val<std::_Simple_types<wchar_t>>>::_Compat(std::_String_const_iterator<std::_String_val<std::_Simple_types<wchar_t>>> const &)+48j
.text$mn:000092CE                 push    offset ??_C@_1FO@GJIHNDLM@?$AA?$CC?$AAS?$AAt?$AAa?$AAn?$AAd?$AAa?$AAr?$AAd?$AA?5?$AAC?$AA?$CL?$AA?$CL?$AA?5?$AAL?$AAi?$AAb?$AAr?$AAa?$AAr?$AAi?$AAe?$AAs?$AA?5?$AAI?$AAn?$AAv?$AAa?$AAl?$AAi?$AAd?$AA?5@ ; "\"Standard C++ Libraries Invalid Argume"...
.text$mn:000092D3                 push    offset ??_C@_15GANGMFKL@?$AA?$CF?$AAs?$AA?$AA@ ; "%s"
.text$mn:000092D8                 push    0
.text$mn:000092DA                 push    0FBh ; 'v'
.text$mn:000092DF                 push    offset ??_C@_1IO@FEAPGJBD@?$AAC?$AA?3?$AA?2?$AAP?$AAr?$AAo?$AAg?$AAr?$AAa?$AAm?$AA?5?$AAF?$AAi?$AAl?$AAe?$AAs?$AA?5?$AA?$CI?$AAx?$AA8?$AA6?$AA?$CJ?$AA?2?$AAM?$AAi?$AAc?$AAr?$AAo?$AAs?$AAo?$AAf?$AAt@ ; "C:\\Program Files (x86)\\Microsoft Visu"...
.text$mn:000092E4                 push    2
.text$mn:000092E6                 call    __CrtDbgReportW
.text$mn:000092EB                 add     esp, 18h
.text$mn:000092EE                 cmp     eax, 1
.text$mn:000092F1                 jnz     short loc_92F4
.text$mn:000092F3                 int     3               ; Trap to Debugger
.text$mn:000092F4
.text$mn:000092F4 loc_92F4:                               ; CODE XREF: std::_String_const_iterator<std::_String_val<std::_Simple_types<wchar_t>>>::_Compat(std::_String_const_iterator<std::_String_val<std::_Simple_types<wchar_t>>> const &)+4Cj
.text$mn:000092F4                                         ; std::_String_const_iterator<std::_String_val<std::_Simple_types<wchar_t>>>::_Compat(std::_String_const_iterator<std::_String_val<std::_Simple_types<wchar_t>>> const &)+71j
.text$mn:000092F4                 push    0
.text$mn:000092F6                 push    0FBh ; 'v'
.text$mn:000092FB                 push    offset ??_C@_1IO@FEAPGJBD@?$AAC?$AA?3?$AA?2?$AAP?$AAr?$AAo?$AAg?$AAr?$AAa?$AAm?$AA?5?$AAF?$AAi?$AAl?$AAe?$AAs?$AA?5?$AA?$CI?$AAx?$AA8?$AA6?$AA?$CJ?$AA?2?$AAM?$AAi?$AAc?$AAr?$AAo?$AAs?$AAo?$AAf?$AAt@ ; "C:\\Program Files (x86)\\Microsoft Visu"...
.text$mn:00009300                 push    offset ??_C@_1MG@CLNEOJNJ@?$AAs?$AAt?$AAd?$AA?3?$AA?3?$AA_?$AAS?$AAt?$AAr?$AAi?$AAn?$AAg?$AA_?$AAc?$AAo?$AAn?$AAs?$AAt?$AA_?$AAi?$AAt?$AAe?$AAr?$AAa?$AAt?$AAo?$AAr?$AA?$DM?$AAc?$AAl?$AAa?$AAs@ ; "std::_String_const_iterator<class std::"...
.text$mn:00009305                 push    offset ??_C@_1CG@JNLFBNGN@?$AA?$CC?$AAi?$AAn?$AAv?$AAa?$AAl?$AAi?$AAd?$AA?5?$AAa?$AAr?$AAg?$AAu?$AAm?$AAe?$AAn?$AAt?$AA?$CC?$AA?$AA@ ; "\"invalid argument\""
.text$mn:0000930A                 call    __invalid_parameter
.text$mn:0000930F                 add     esp, 14h
.text$mn:00009312
.text$mn:00009312 loc_9312:                               ; CODE XREF: std::_String_const_iterator<std::_String_val<std::_Simple_types<wchar_t>>>::_Compat(std::_String_const_iterator<std::_String_val<std::_Simple_types<wchar_t>>> const &)+28j
.text$mn:00009312                 pop     esi
.text$mn:00009313                 mov     esp, ebp
.text$mn:00009315                 pop     ebp
.text$mn:00009316                 retn    4
.text$mn:00009316 ?_Compat@?$_String_const_iterator@V?$_String_val@U?$_Simple_types@_W@std@@@std@@@std@@QBEXABV12@@Z endp
.text$mn:00009316
.text$mn:00009316 ; ---------------------------------------------------------------------------
.text$mn:00009319                 align 4
.text$mn:00009319 _text$mn        ends
.text$mn:00009319
.text$mn:0000931C ; ===========================================================================
.text$mn:0000931C
.text$mn:0000931C ; Segment type: Pure code
.text$mn:0000931C ; Segment permissions: Read/Execute
.text$mn:0000931C _text$mn        segment para public 'CODE' use32
.text$mn:0000931C                 assume cs:_text$mn
.text$mn:0000931C                 ;org 931Ch
.text$mn:0000931C ; COMDAT (pick any)
.text$mn:0000931C                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text$mn:0000931C
.text$mn:0000931C ; =============== S U B R O U T I N E =======================================
.text$mn:0000931C
.text$mn:0000931C ; Attributes: bp-based frame
.text$mn:0000931C
.text$mn:0000931C ; int __stdcall std::_Vector_const_iterator<std::_Vector_val<std::_Simple_types<wchar_t>>>::_Compat(std::_Iterator_base12 *)
.text$mn:0000931C                 public ?_Compat@?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@_W@std@@@std@@@std@@QBEXABV12@@Z
.text$mn:0000931C ?_Compat@?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@_W@std@@@std@@@std@@QBEXABV12@@Z proc near
.text$mn:0000931C                                         ; CODE XREF: std::_Vector_const_iterator<std::_Vector_val<std::_Simple_types<wchar_t>>>::operator==(std::_Vector_const_iterator<std::_Vector_val<std::_Simple_types<wchar_t>>> const &)+10p
.text$mn:0000931C                                         ; std::_Vector_const_iterator<std::_Vector_val<std::_Simple_types<wchar_t>>>::operator-(std::_Vector_const_iterator<std::_Vector_val<std::_Simple_types<wchar_t>>> const &)+Ep ...
.text$mn:0000931C
.text$mn:0000931C var_4           = dword ptr -4
.text$mn:0000931C arg_0           = dword ptr  8
.text$mn:0000931C
.text$mn:0000931C                 push    ebp
.text$mn:0000931D                 mov     ebp, esp
.text$mn:0000931F                 push    ecx
.text$mn:00009320                 push    esi
.text$mn:00009321                 mov     [ebp+var_4], ecx
.text$mn:00009324                 mov     ecx, [ebp+var_4] ; this
.text$mn:00009327                 call    ?_Getcont@_Iterator_base12@std@@QBEPBU_Container_base12@2@XZ ; std::_Iterator_base12::_Getcont(void)
.text$mn:0000932C                 test    eax, eax
.text$mn:0000932E                 jz      short loc_9346
.text$mn:00009330                 mov     ecx, [ebp+var_4] ; this
.text$mn:00009333                 call    ?_Getcont@_Iterator_base12@std@@QBEPBU_Container_base12@2@XZ ; std::_Iterator_base12::_Getcont(void)
.text$mn:00009338                 mov     esi, eax
.text$mn:0000933A                 mov     ecx, [ebp+arg_0] ; this
.text$mn:0000933D                 call    ?_Getcont@_Iterator_base12@std@@QBEPBU_Container_base12@2@XZ ; std::_Iterator_base12::_Getcont(void)
.text$mn:00009342                 cmp     esi, eax
.text$mn:00009344                 jz      short loc_93AE
.text$mn:00009346
.text$mn:00009346 loc_9346:                               ; CODE XREF: std::_Vector_const_iterator<std::_Vector_val<std::_Simple_types<wchar_t>>>::_Compat(std::_Vector_const_iterator<std::_Vector_val<std::_Simple_types<wchar_t>>> const &)+12j
.text$mn:00009346                 push    0F0h ; '='      ; unsigned int
.text$mn:0000934B                 push    offset ??_C@_1IM@EINEHPHE@?$AAC?$AA?3?$AA?2?$AAP?$AAr?$AAo?$AAg?$AAr?$AAa?$AAm?$AA?5?$AAF?$AAi?$AAl?$AAe?$AAs?$AA?5?$AA?$CI?$AAx?$AA8?$AA6?$AA?$CJ?$AA?2?$AAM?$AAi?$AAc?$AAr?$AAo?$AAs?$AAo?$AAf?$AAt@ ; "C:\\Program Files (x86)\\Microsoft Visu"...
.text$mn:00009350                 push    offset ??_C@_1DM@HINDPMBP@?$AAv?$AAe?$AAc?$AAt?$AAo?$AAr?$AA?5?$AAi?$AAt?$AAe?$AAr?$AAa?$AAt?$AAo?$AAr?$AAs?$AA?5?$AAi?$AAn?$AAc?$AAo?$AAm?$AAp?$AAa?$AAt?$AAi?$AAb?$AAl?$AAe?$AA?$AA@ ; "vector iterators incompatible"
.text$mn:00009355                 call    ?_Debug_message@std@@YAXPB_W0I@Z ; std::_Debug_message(wchar_t const *,wchar_t const *,uint)
.text$mn:0000935A                 add     esp, 0Ch
.text$mn:0000935D                 mov     eax, offset ??_C@_0CI@FNPHFCCM@Standard?5C?$CL?$CL?5Libraries?5Invalid?5A@ ; "Standard C++ Libraries Invalid Argument"
.text$mn:00009362                 test    eax, eax
.text$mn:00009364                 jz      short loc_936A
.text$mn:00009366                 xor     ecx, ecx
.text$mn:00009368                 jnz     short loc_9390
.text$mn:0000936A
.text$mn:0000936A loc_936A:                               ; CODE XREF: std::_Vector_const_iterator<std::_Vector_val<std::_Simple_types<wchar_t>>>::_Compat(std::_Vector_const_iterator<std::_Vector_val<std::_Simple_types<wchar_t>>> const &)+48j
.text$mn:0000936A                 push    offset ??_C@_1FO@GJIHNDLM@?$AA?$CC?$AAS?$AAt?$AAa?$AAn?$AAd?$AAa?$AAr?$AAd?$AA?5?$AAC?$AA?$CL?$AA?$CL?$AA?5?$AAL?$AAi?$AAb?$AAr?$AAa?$AAr?$AAi?$AAe?$AAs?$AA?5?$AAI?$AAn?$AAv?$AAa?$AAl?$AAi?$AAd?$AA?5@ ; "\"Standard C++ Libraries Invalid Argume"...
.text$mn:0000936F                 push    offset ??_C@_15GANGMFKL@?$AA?$CF?$AAs?$AA?$AA@ ; "%s"
.text$mn:00009374                 push    0
.text$mn:00009376                 push    0F1h ; '±'
.text$mn:0000937B                 push    offset ??_C@_1IM@EINEHPHE@?$AAC?$AA?3?$AA?2?$AAP?$AAr?$AAo?$AAg?$AAr?$AAa?$AAm?$AA?5?$AAF?$AAi?$AAl?$AAe?$AAs?$AA?5?$AA?$CI?$AAx?$AA8?$AA6?$AA?$CJ?$AA?2?$AAM?$AAi?$AAc?$AAr?$AAo?$AAs?$AAo?$AAf?$AAt@ ; "C:\\Program Files (x86)\\Microsoft Visu"...
.text$mn:00009380                 push    2
.text$mn:00009382                 call    __CrtDbgReportW
.text$mn:00009387                 add     esp, 18h
.text$mn:0000938A                 cmp     eax, 1
.text$mn:0000938D                 jnz     short loc_9390
.text$mn:0000938F                 int     3               ; Trap to Debugger
.text$mn:00009390
.text$mn:00009390 loc_9390:                               ; CODE XREF: std::_Vector_const_iterator<std::_Vector_val<std::_Simple_types<wchar_t>>>::_Compat(std::_Vector_const_iterator<std::_Vector_val<std::_Simple_types<wchar_t>>> const &)+4Cj
.text$mn:00009390                                         ; std::_Vector_const_iterator<std::_Vector_val<std::_Simple_types<wchar_t>>>::_Compat(std::_Vector_const_iterator<std::_Vector_val<std::_Simple_types<wchar_t>>> const &)+71j
.text$mn:00009390                 push    0
.text$mn:00009392                 push    0F1h ; '±'
.text$mn:00009397                 push    offset ??_C@_1IM@EINEHPHE@?$AAC?$AA?3?$AA?2?$AAP?$AAr?$AAo?$AAg?$AAr?$AAa?$AAm?$AA?5?$AAF?$AAi?$AAl?$AAe?$AAs?$AA?5?$AA?$CI?$AAx?$AA8?$AA6?$AA?$CJ?$AA?2?$AAM?$AAi?$AAc?$AAr?$AAo?$AAs?$AAo?$AAf?$AAt@ ; "C:\\Program Files (x86)\\Microsoft Visu"...
.text$mn:0000939C                 push    offset ??_C@_1MG@HLEJMPCF@?$AAs?$AAt?$AAd?$AA?3?$AA?3?$AA_?$AAV?$AAe?$AAc?$AAt?$AAo?$AAr?$AA_?$AAc?$AAo?$AAn?$AAs?$AAt?$AA_?$AAi?$AAt?$AAe?$AAr?$AAa?$AAt?$AAo?$AAr?$AA?$DM?$AAc?$AAl?$AAa?$AAs@ ; "std::_Vector_const_iterator<class std::"...
.text$mn:000093A1                 push    offset ??_C@_1CG@JNLFBNGN@?$AA?$CC?$AAi?$AAn?$AAv?$AAa?$AAl?$AAi?$AAd?$AA?5?$AAa?$AAr?$AAg?$AAu?$AAm?$AAe?$AAn?$AAt?$AA?$CC?$AA?$AA@ ; "\"invalid argument\""
.text$mn:000093A6                 call    __invalid_parameter
.text$mn:000093AB                 add     esp, 14h
.text$mn:000093AE
.text$mn:000093AE loc_93AE:                               ; CODE XREF: std::_Vector_const_iterator<std::_Vector_val<std::_Simple_types<wchar_t>>>::_Compat(std::_Vector_const_iterator<std::_Vector_val<std::_Simple_types<wchar_t>>> const &)+28j
.text$mn:000093AE                 pop     esi
.text$mn:000093AF                 mov     esp, ebp
.text$mn:000093B1                 pop     ebp
.text$mn:000093B2                 retn    4
.text$mn:000093B2 ?_Compat@?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@_W@std@@@std@@@std@@QBEXABV12@@Z endp
.text$mn:000093B2
.text$mn:000093B2 ; ---------------------------------------------------------------------------
.text$mn:000093B5                 align 4
.text$mn:000093B5 _text$mn        ends
.text$mn:000093B5
.text$mn:000093B8 ; ===========================================================================
.text$mn:000093B8
.text$mn:000093B8 ; Segment type: Pure code
.text$mn:000093B8 ; Segment permissions: Read/Execute
.text$mn:000093B8 _text$mn        segment para public 'CODE' use32
.text$mn:000093B8                 assume cs:_text$mn
.text$mn:000093B8                 ;org 93B8h
.text$mn:000093B8 ; COMDAT (pick any)
.text$mn:000093B8                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text$mn:000093B8
.text$mn:000093B8 ; =============== S U B R O U T I N E =======================================
.text$mn:000093B8
.text$mn:000093B8 ; Attributes: bp-based frame
.text$mn:000093B8
.text$mn:000093B8 ; public: void __thiscall std::basic_string<char, struct std::char_traits<char>, class std::allocator<char>>::_Copy(unsigned int, unsigned int)
.text$mn:000093B8                 public ?_Copy@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEXII@Z
.text$mn:000093B8 ?_Copy@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEXII@Z proc near
.text$mn:000093B8                                         ; CODE XREF: std::basic_string<char,std::char_traits<char>,std::allocator<char>>::_Grow(uint,bool)+37p
.text$mn:000093B8
.text$mn:000093B8 var_20          = dword ptr -20h
.text$mn:000093B8 var_1C          = dword ptr -1Ch
.text$mn:000093B8 var_18          = dword ptr -18h
.text$mn:000093B8 var_11          = byte ptr -11h
.text$mn:000093B8 var_10          = dword ptr -10h
.text$mn:000093B8 var_C           = byte ptr -0Ch
.text$mn:000093B8 var_4           = dword ptr -4
.text$mn:000093B8 arg_0           = dword ptr  8
.text$mn:000093B8
.text$mn:000093B8 ; FUNCTION CHUNK AT .text$mn:000094DA SIZE 00000009 BYTES
.text$mn:000093B8
.text$mn:000093B8                 push    ebp
.text$mn:000093B9                 mov     ebp, esp
.text$mn:000093BB                 push    0FFFFFFFFh
.text$mn:000093BD                 push    offset __ehhandler$?_Copy@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEXII@Z
.text$mn:000093C2                 mov     eax, large fs:0
.text$mn:000093C8                 push    eax
.text$mn:000093C9                 push    ecx
.text$mn:000093CA                 sub     esp, 10h
.text$mn:000093CD                 push    ebx
.text$mn:000093CE                 push    esi
.text$mn:000093CF                 push    edi
.text$mn:000093D0                 mov     eax, dword ptr ds:___security_cookie
.text$mn:000093D5                 xor     eax, ebp
.text$mn:000093D7                 push    eax
.text$mn:000093D8                 lea     eax, [ebp+var_C]
.text$mn:000093DB                 mov     large fs:0, eax
.text$mn:000093E1                 mov     [ebp+var_10], esp
.text$mn:000093E4                 mov     [ebp+var_18], ecx
.text$mn:000093E7                 mov     eax, [ebp+arg_0]
.text$mn:000093EA                 or      eax, 0Fh
.text$mn:000093ED                 mov     [ebp+var_1C], eax
.text$mn:000093F0                 mov     ecx, [ebp+var_18]
.text$mn:000093F3                 call    ?max_size@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QBEIXZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char>>::max_size(void)
.text$mn:000093F8                 cmp     eax, [ebp+var_1C]
.text$mn:000093FB                 jnb     short loc_9405
.text$mn:000093FD                 mov     ecx, [ebp+arg_0]
.text$mn:00009400                 mov     [ebp+var_1C], ecx
.text$mn:00009403                 jmp     short loc_9457
.text$mn:00009405 ; ---------------------------------------------------------------------------
.text$mn:00009405
.text$mn:00009405 loc_9405:                               ; CODE XREF: std::basic_string<char,std::char_traits<char>,std::allocator<char>>::_Copy(uint,uint)+43j
.text$mn:00009405                 mov     edx, [ebp+var_18]
.text$mn:00009408                 mov     ecx, [edx+18h]
.text$mn:0000940B                 shr     ecx, 1
.text$mn:0000940D                 mov     eax, [ebp+var_1C]
.text$mn:00009410                 xor     edx, edx
.text$mn:00009412                 mov     esi, 3
.text$mn:00009417                 div     esi
.text$mn:00009419                 cmp     ecx, eax
.text$mn:0000941B                 ja      short loc_941F
.text$mn:0000941D                 jmp     short loc_9457
.text$mn:0000941F ; ---------------------------------------------------------------------------
.text$mn:0000941F
.text$mn:0000941F loc_941F:                               ; CODE XREF: std::basic_string<char,std::char_traits<char>,std::allocator<char>>::_Copy(uint,uint)+63j
.text$mn:0000941F                 mov     ecx, [ebp+var_18]
.text$mn:00009422                 call    ?max_size@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QBEIXZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char>>::max_size(void)
.text$mn:00009427                 mov     edx, [ebp+var_18]
.text$mn:0000942A                 mov     ecx, [edx+18h]
.text$mn:0000942D                 shr     ecx, 1
.text$mn:0000942F                 sub     eax, ecx
.text$mn:00009431                 mov     edx, [ebp+var_18]
.text$mn:00009434                 cmp     [edx+18h], eax
.text$mn:00009437                 ja      short loc_944C
.text$mn:00009439                 mov     eax, [ebp+var_18]
.text$mn:0000943C                 mov     ecx, [eax+18h]
.text$mn:0000943F                 shr     ecx, 1
.text$mn:00009441                 mov     edx, [ebp+var_18]
.text$mn:00009444                 add     ecx, [edx+18h]
.text$mn:00009447                 mov     [ebp+var_1C], ecx
.text$mn:0000944A                 jmp     short loc_9457
.text$mn:0000944C ; ---------------------------------------------------------------------------
.text$mn:0000944C
.text$mn:0000944C loc_944C:                               ; CODE XREF: std::basic_string<char,std::char_traits<char>,std::allocator<char>>::_Copy(uint,uint)+7Fj
.text$mn:0000944C                 mov     ecx, [ebp+var_18]
.text$mn:0000944F                 call    ?max_size@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QBEIXZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char>>::max_size(void)
.text$mn:00009454                 mov     [ebp+var_1C], eax
.text$mn:00009457
.text$mn:00009457 loc_9457:                               ; CODE XREF: std::basic_string<char,std::char_traits<char>,std::allocator<char>>::_Copy(uint,uint)+4Bj
.text$mn:00009457                                         ; std::basic_string<char,std::char_traits<char>,std::allocator<char>>::_Copy(uint,uint)+65j ...
.text$mn:00009457                 mov     [ebp+var_4], 0
.text$mn:0000945E                 mov     eax, [ebp+var_1C]
.text$mn:00009461                 add     eax, 1
.text$mn:00009464                 push    eax
.text$mn:00009465                 lea     ecx, [ebp+var_11]
.text$mn:00009468                 push    ecx
.text$mn:00009469                 mov     ecx, [ebp+var_18]
.text$mn:0000946C                 call    ?_Getal@?$_String_alloc@$0A@U?$_String_base_types@DV?$allocator@D@std@@@std@@@std@@QBE?AU?$_Wrap_alloc@V?$allocator@D@std@@@2@XZ ; std::_String_alloc<0,std::_String_base_types<char,std::allocator<char>>>::_Getal(void)
.text$mn:00009471                 mov     ecx, eax
.text$mn:00009473                 call    ?allocate@?$_Wrap_alloc@V?$allocator@D@std@@@std@@QAEPADI@Z ; std::_Wrap_alloc<std::allocator<char>>::allocate(uint)
.text$mn:00009478                 mov     [ebp+var_20], eax
.text$mn:0000947B                 jmp     short loc_94DA
.text$mn:0000947B ?_Copy@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEXII@Z endp
.text$mn:0000947B
.text$mn:0000947D
.text$mn:0000947D ; =============== S U B R O U T I N E =======================================
.text$mn:0000947D
.text$mn:0000947D
.text$mn:0000947D __catch$?_Copy@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEXII@Z$0 proc near
.text$mn:0000947D                                         ; DATA XREF: .xdata$x:0000D680o
.text$mn:0000947D
.text$mn:0000947D ; FUNCTION CHUNK AT .text$mn:000094C4 SIZE 00000009 BYTES
.text$mn:0000947D ; FUNCTION CHUNK AT .text$mn:000094D4 SIZE 00000006 BYTES
.text$mn:0000947D
.text$mn:0000947D                 mov     [ebp-10h], esp
.text$mn:00009480                 mov     edx, [ebp+8]
.text$mn:00009483                 mov     [ebp-1Ch], edx
.text$mn:00009486                 mov     byte ptr [ebp-4], 2
.text$mn:0000948A                 mov     eax, [ebp-1Ch]
.text$mn:0000948D                 add     eax, 1
.text$mn:00009490                 push    eax
.text$mn:00009491                 lea     ecx, [ebp-12h]
.text$mn:00009494                 push    ecx
.text$mn:00009495                 mov     ecx, [ebp-18h]
.text$mn:00009498                 call    ?_Getal@?$_String_alloc@$0A@U?$_String_base_types@DV?$allocator@D@std@@@std@@@std@@QBE?AU?$_Wrap_alloc@V?$allocator@D@std@@@2@XZ ; std::_String_alloc<0,std::_String_base_types<char,std::allocator<char>>>::_Getal(void)
.text$mn:0000949D                 mov     ecx, eax
.text$mn:0000949F                 call    ?allocate@?$_Wrap_alloc@V?$allocator@D@std@@@std@@QAEPADI@Z ; std::_Wrap_alloc<std::allocator<char>>::allocate(uint)
.text$mn:000094A4                 mov     [ebp-20h], eax
.text$mn:000094A7                 jmp     short loc_94C4
.text$mn:000094A7 __catch$?_Copy@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEXII@Z$0 endp
.text$mn:000094A7
.text$mn:000094A9
.text$mn:000094A9 ; =============== S U B R O U T I N E =======================================
.text$mn:000094A9
.text$mn:000094A9 ; Attributes: noreturn
.text$mn:000094A9
.text$mn:000094A9 __catch$?_Copy@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEXII@Z$1 proc near
.text$mn:000094A9                                         ; DATA XREF: .xdata$x:0000D690o
.text$mn:000094A9                 push    0               ; Size
.text$mn:000094AB                 push    1               ; char
.text$mn:000094AD                 mov     ecx, [ebp-18h]
.text$mn:000094B0                 call    ?_Tidy@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEX_NI@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char>>::_Tidy(bool,uint)
.text$mn:000094B5                 push    0
.text$mn:000094B7                 push    0
.text$mn:000094B9                 call    __CxxThrowException@8 ; _CxxThrowException(x,x)
.text$mn:000094B9 __catch$?_Copy@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEXII@Z$1 endp
.text$mn:000094B9
.text$mn:000094BE ; ---------------------------------------------------------------------------
.text$mn:000094BE                 mov     eax, offset $LN17
.text$mn:000094C3                 retn
.text$mn:000094C4 ; ---------------------------------------------------------------------------
.text$mn:000094C4 ; START OF FUNCTION CHUNK FOR __catch$?_Copy@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEXII@Z$0
.text$mn:000094C4
.text$mn:000094C4 loc_94C4:                               ; CODE XREF: __catch$?_Copy@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEXII@Z$0+2Aj
.text$mn:000094C4                 mov     dword ptr [ebp-4], 1
.text$mn:000094CB                 jmp     short loc_94D4
.text$mn:000094CB ; END OF FUNCTION CHUNK FOR __catch$?_Copy@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEXII@Z$0
.text$mn:000094CD
.text$mn:000094CD ; =============== S U B R O U T I N E =======================================
.text$mn:000094CD
.text$mn:000094CD
.text$mn:000094CD $LN17           proc near               ; DATA XREF: .text$mn:000094BEo
.text$mn:000094CD                 mov     dword ptr [ebp-4], 1
.text$mn:000094CD $LN17           endp ; sp-analysis failed
.text$mn:000094CD
.text$mn:000094D4 ; START OF FUNCTION CHUNK FOR __catch$?_Copy@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEXII@Z$0
.text$mn:000094D4
.text$mn:000094D4 loc_94D4:                               ; CODE XREF: __catch$?_Copy@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEXII@Z$0+4Ej
.text$mn:000094D4                 mov     eax, offset $LN19
.text$mn:000094D9                 retn
.text$mn:000094D9 ; END OF FUNCTION CHUNK FOR __catch$?_Copy@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEXII@Z$0
.text$mn:000094DA ; ---------------------------------------------------------------------------
.text$mn:000094DA ; START OF FUNCTION CHUNK FOR ?_Copy@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEXII@Z
.text$mn:000094DA
.text$mn:000094DA loc_94DA:                               ; CODE XREF: std::basic_string<char,std::char_traits<char>,std::allocator<char>>::_Copy(uint,uint)+C3j
.text$mn:000094DA                 mov     [ebp+var_4], 0FFFFFFFFh
.text$mn:000094E1                 jmp     short loc_94EA
.text$mn:000094E1 ; END OF FUNCTION CHUNK FOR ?_Copy@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEXII@Z
.text$mn:000094E3
.text$mn:000094E3 ; =============== S U B R O U T I N E =======================================
.text$mn:000094E3
.text$mn:000094E3
.text$mn:000094E3 $LN19           proc near               ; DATA XREF: __catch$?_Copy@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEXII@Z$0:loc_94D4o
.text$mn:000094E3                 mov     dword ptr [ebp-4], 0FFFFFFFFh
.text$mn:000094EA
.text$mn:000094EA loc_94EA:                               ; CODE XREF: std::basic_string<char,std::char_traits<char>,std::allocator<char>>::_Copy(uint,uint)+129j
.text$mn:000094EA                 cmp     dword ptr [ebp+0Ch], 0
.text$mn:000094EE                 jbe     short loc_9509
.text$mn:000094F0                 mov     edx, [ebp+0Ch]
.text$mn:000094F3                 push    edx             ; Size
.text$mn:000094F4                 mov     ecx, [ebp-18h]
.text$mn:000094F7                 call    ?_Myptr@?$_String_val@U?$_Simple_types@D@std@@@std@@QAEPADXZ ; std::_String_val<std::_Simple_types<char>>::_Myptr(void)
.text$mn:000094FC                 push    eax             ; Src
.text$mn:000094FD                 mov     eax, [ebp-20h]
.text$mn:00009500                 push    eax             ; Dst
.text$mn:00009501                 call    ?copy@?$char_traits@D@std@@SAPADPADPBDI@Z ; std::char_traits<char>::copy(char *,char const *,uint)
.text$mn:00009506                 add     esp, 0Ch
.text$mn:00009509
.text$mn:00009509 loc_9509:                               ; CODE XREF: $LN19+Bj
.text$mn:00009509                 push    0               ; Size
.text$mn:0000950B                 push    1               ; char
.text$mn:0000950D                 mov     ecx, [ebp-18h]
.text$mn:00009510                 call    ?_Tidy@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEX_NI@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char>>::_Tidy(bool,uint)
.text$mn:00009515                 lea     ecx, [ebp-20h]
.text$mn:00009518                 push    ecx             ; int
.text$mn:00009519                 mov     edx, [ebp-18h]
.text$mn:0000951C                 add     edx, 4
.text$mn:0000951F                 push    edx             ; void *
.text$mn:00009520                 lea     eax, [ebp-13h]
.text$mn:00009523                 push    eax
.text$mn:00009524                 mov     ecx, [ebp-18h]
.text$mn:00009527                 call    ?_Getal@?$_String_alloc@$0A@U?$_String_base_types@DV?$allocator@D@std@@@std@@@std@@QBE?AU?$_Wrap_alloc@V?$allocator@D@std@@@2@XZ ; std::_String_alloc<0,std::_String_base_types<char,std::allocator<char>>>::_Getal(void)
.text$mn:0000952C                 mov     ecx, eax
.text$mn:0000952E                 call    ??$construct@PADAAPAD@?$_Wrap_alloc@V?$allocator@D@std@@@std@@QAEXPAPADAAPAD@Z ; std::_Wrap_alloc<std::allocator<char>>::construct<char *,char * &>(char * *,char * &)
.text$mn:00009533                 mov     ecx, [ebp-18h]
.text$mn:00009536                 mov     edx, [ebp-1Ch]
.text$mn:00009539                 mov     [ecx+18h], edx
.text$mn:0000953C                 mov     eax, [ebp+0Ch]
.text$mn:0000953F                 push    eax
.text$mn:00009540                 mov     ecx, [ebp-18h]
.text$mn:00009543                 call    ?_Eos@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEXI@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char>>::_Eos(uint)
.text$mn:00009548                 mov     ecx, [ebp-0Ch]
.text$mn:0000954B                 mov     large fs:0, ecx
.text$mn:00009552                 pop     ecx
.text$mn:00009553                 pop     edi
.text$mn:00009554                 pop     esi
.text$mn:00009555                 pop     ebx
.text$mn:00009556                 mov     esp, ebp
.text$mn:00009558                 pop     ebp
.text$mn:00009559                 retn    8
.text$mn:00009559 $LN19           endp ; sp-analysis failed
.text$mn:00009559
.text$mn:00009559 _text$mn        ends
.text$mn:00009559
.text$x:0000955C ; ===========================================================================
.text$x:0000955C
.text$x:0000955C ; Segment type: Pure code
.text$x:0000955C ; Segment permissions: Read/Execute
.text$x:0000955C _text$x         segment para public 'CODE' use32
.text$x:0000955C                 assume cs:_text$x
.text$x:0000955C                 ;org 955Ch
.text$x:0000955C ; COMDAT (pick associative to section at 93B8)
.text$x:0000955C                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text$x:0000955C
.text$x:0000955C ; =============== S U B R O U T I N E =======================================
.text$x:0000955C
.text$x:0000955C
.text$x:0000955C __ehhandler$?_Copy@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEXII@Z proc near
.text$x:0000955C                                         ; DATA XREF: std::basic_string<char,std::char_traits<char>,std::allocator<char>>::_Copy(uint,uint)+5o
.text$x:0000955C
.text$x:0000955C arg_4           = dword ptr  8
.text$x:0000955C
.text$x:0000955C                 mov     edx, [esp+arg_4]
.text$x:00009560                 lea     eax, [edx+0Ch]
.text$x:00009563                 mov     ecx, [edx-24h]
.text$x:00009566                 xor     ecx, eax
.text$x:00009568                 call    @__security_check_cookie@4 ; __security_check_cookie(x)
.text$x:0000956D                 mov     eax, offset __ehfuncinfo$?_Copy@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEXII@Z
.text$x:00009572                 jmp     ___CxxFrameHandler3
.text$x:00009572 __ehhandler$?_Copy@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEXII@Z endp
.text$x:00009572
.text$x:00009572 ; ---------------------------------------------------------------------------
.text$x:00009577                 align 4
.text$x:00009577 _text$x         ends
.text$x:00009577
.text$mn:00009578 ; ===========================================================================
.text$mn:00009578
.text$mn:00009578 ; Segment type: Pure code
.text$mn:00009578 ; Segment permissions: Read/Execute
.text$mn:00009578 _text$mn        segment para public 'CODE' use32
.text$mn:00009578                 assume cs:_text$mn
.text$mn:00009578                 ;org 9578h
.text$mn:00009578 ; COMDAT (pick any)
.text$mn:00009578                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text$mn:00009578
.text$mn:00009578 ; =============== S U B R O U T I N E =======================================
.text$mn:00009578
.text$mn:00009578 ; Attributes: bp-based frame
.text$mn:00009578
.text$mn:00009578 ; public: void __thiscall std::basic_string<wchar_t, struct std::char_traits<wchar_t>, class std::allocator<wchar_t>>::_Copy(unsigned int, unsigned int)
.text$mn:00009578                 public ?_Copy@?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QAEXII@Z
.text$mn:00009578 ?_Copy@?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QAEXII@Z proc near
.text$mn:00009578                                         ; CODE XREF: std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>>::_Grow(uint,bool)+37p
.text$mn:00009578
.text$mn:00009578 var_20          = dword ptr -20h
.text$mn:00009578 var_1C          = dword ptr -1Ch
.text$mn:00009578 var_18          = dword ptr -18h
.text$mn:00009578 var_11          = byte ptr -11h
.text$mn:00009578 var_10          = dword ptr -10h
.text$mn:00009578 var_C           = byte ptr -0Ch
.text$mn:00009578 var_4           = dword ptr -4
.text$mn:00009578 arg_0           = dword ptr  8
.text$mn:00009578
.text$mn:00009578 ; FUNCTION CHUNK AT .text$mn:0000969A SIZE 00000009 BYTES
.text$mn:00009578
.text$mn:00009578                 push    ebp
.text$mn:00009579                 mov     ebp, esp
.text$mn:0000957B                 push    0FFFFFFFFh
.text$mn:0000957D                 push    offset __ehhandler$?_Copy@?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QAEXII@Z
.text$mn:00009582                 mov     eax, large fs:0
.text$mn:00009588                 push    eax
.text$mn:00009589                 push    ecx
.text$mn:0000958A                 sub     esp, 10h
.text$mn:0000958D                 push    ebx
.text$mn:0000958E                 push    esi
.text$mn:0000958F                 push    edi
.text$mn:00009590                 mov     eax, dword ptr ds:___security_cookie
.text$mn:00009595                 xor     eax, ebp
.text$mn:00009597                 push    eax
.text$mn:00009598                 lea     eax, [ebp+var_C]
.text$mn:0000959B                 mov     large fs:0, eax
.text$mn:000095A1                 mov     [ebp+var_10], esp
.text$mn:000095A4                 mov     [ebp+var_18], ecx
.text$mn:000095A7                 mov     eax, [ebp+arg_0]
.text$mn:000095AA                 or      eax, 7
.text$mn:000095AD                 mov     [ebp+var_1C], eax
.text$mn:000095B0                 mov     ecx, [ebp+var_18]
.text$mn:000095B3                 call    ?max_size@?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QBEIXZ ; std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>>::max_size(void)
.text$mn:000095B8                 cmp     eax, [ebp+var_1C]
.text$mn:000095BB                 jnb     short loc_95C5
.text$mn:000095BD                 mov     ecx, [ebp+arg_0]
.text$mn:000095C0                 mov     [ebp+var_1C], ecx
.text$mn:000095C3                 jmp     short loc_9617
.text$mn:000095C5 ; ---------------------------------------------------------------------------
.text$mn:000095C5
.text$mn:000095C5 loc_95C5:                               ; CODE XREF: std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>>::_Copy(uint,uint)+43j
.text$mn:000095C5                 mov     edx, [ebp+var_18]
.text$mn:000095C8                 mov     ecx, [edx+18h]
.text$mn:000095CB                 shr     ecx, 1
.text$mn:000095CD                 mov     eax, [ebp+var_1C]
.text$mn:000095D0                 xor     edx, edx
.text$mn:000095D2                 mov     esi, 3
.text$mn:000095D7                 div     esi
.text$mn:000095D9                 cmp     ecx, eax
.text$mn:000095DB                 ja      short loc_95DF
.text$mn:000095DD                 jmp     short loc_9617
.text$mn:000095DF ; ---------------------------------------------------------------------------
.text$mn:000095DF
.text$mn:000095DF loc_95DF:                               ; CODE XREF: std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>>::_Copy(uint,uint)+63j
.text$mn:000095DF                 mov     ecx, [ebp+var_18]
.text$mn:000095E2                 call    ?max_size@?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QBEIXZ ; std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>>::max_size(void)
.text$mn:000095E7                 mov     edx, [ebp+var_18]
.text$mn:000095EA                 mov     ecx, [edx+18h]
.text$mn:000095ED                 shr     ecx, 1
.text$mn:000095EF                 sub     eax, ecx
.text$mn:000095F1                 mov     edx, [ebp+var_18]
.text$mn:000095F4                 cmp     [edx+18h], eax
.text$mn:000095F7                 ja      short loc_960C
.text$mn:000095F9                 mov     eax, [ebp+var_18]
.text$mn:000095FC                 mov     ecx, [eax+18h]
.text$mn:000095FF                 shr     ecx, 1
.text$mn:00009601                 mov     edx, [ebp+var_18]
.text$mn:00009604                 add     ecx, [edx+18h]
.text$mn:00009607                 mov     [ebp+var_1C], ecx
.text$mn:0000960A                 jmp     short loc_9617
.text$mn:0000960C ; ---------------------------------------------------------------------------
.text$mn:0000960C
.text$mn:0000960C loc_960C:                               ; CODE XREF: std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>>::_Copy(uint,uint)+7Fj
.text$mn:0000960C                 mov     ecx, [ebp+var_18]
.text$mn:0000960F                 call    ?max_size@?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QBEIXZ ; std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>>::max_size(void)
.text$mn:00009614                 mov     [ebp+var_1C], eax
.text$mn:00009617
.text$mn:00009617 loc_9617:                               ; CODE XREF: std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>>::_Copy(uint,uint)+4Bj
.text$mn:00009617                                         ; std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>>::_Copy(uint,uint)+65j ...
.text$mn:00009617                 mov     [ebp+var_4], 0
.text$mn:0000961E                 mov     eax, [ebp+var_1C]
.text$mn:00009621                 add     eax, 1
.text$mn:00009624                 push    eax
.text$mn:00009625                 lea     ecx, [ebp+var_11]
.text$mn:00009628                 push    ecx
.text$mn:00009629                 mov     ecx, [ebp+var_18]
.text$mn:0000962C                 call    ?_Getal@?$_String_alloc@$0A@U?$_String_base_types@_WV?$allocator@_W@std@@@std@@@std@@QBE?AU?$_Wrap_alloc@V?$allocator@_W@std@@@2@XZ ; std::_String_alloc<0,std::_String_base_types<wchar_t,std::allocator<wchar_t>>>::_Getal(void)
.text$mn:00009631                 mov     ecx, eax
.text$mn:00009633                 call    ?allocate@?$_Wrap_alloc@V?$allocator@_W@std@@@std@@QAEPA_WI@Z ; std::_Wrap_alloc<std::allocator<wchar_t>>::allocate(uint)
.text$mn:00009638                 mov     [ebp+var_20], eax
.text$mn:0000963B                 jmp     short loc_969A
.text$mn:0000963B ?_Copy@?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QAEXII@Z endp
.text$mn:0000963B
.text$mn:0000963D
.text$mn:0000963D ; =============== S U B R O U T I N E =======================================
.text$mn:0000963D
.text$mn:0000963D
.text$mn:0000963D __catch$?_Copy@?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QAEXII@Z$0 proc near
.text$mn:0000963D                                         ; DATA XREF: .xdata$x:0000DC64o
.text$mn:0000963D
.text$mn:0000963D ; FUNCTION CHUNK AT .text$mn:00009684 SIZE 00000009 BYTES
.text$mn:0000963D ; FUNCTION CHUNK AT .text$mn:00009694 SIZE 00000006 BYTES
.text$mn:0000963D
.text$mn:0000963D                 mov     [ebp-10h], esp
.text$mn:00009640                 mov     edx, [ebp+8]
.text$mn:00009643                 mov     [ebp-1Ch], edx
.text$mn:00009646                 mov     byte ptr [ebp-4], 2
.text$mn:0000964A                 mov     eax, [ebp-1Ch]
.text$mn:0000964D                 add     eax, 1
.text$mn:00009650                 push    eax
.text$mn:00009651                 lea     ecx, [ebp-12h]
.text$mn:00009654                 push    ecx
.text$mn:00009655                 mov     ecx, [ebp-18h]
.text$mn:00009658                 call    ?_Getal@?$_String_alloc@$0A@U?$_String_base_types@_WV?$allocator@_W@std@@@std@@@std@@QBE?AU?$_Wrap_alloc@V?$allocator@_W@std@@@2@XZ ; std::_String_alloc<0,std::_String_base_types<wchar_t,std::allocator<wchar_t>>>::_Getal(void)
.text$mn:0000965D                 mov     ecx, eax
.text$mn:0000965F                 call    ?allocate@?$_Wrap_alloc@V?$allocator@_W@std@@@std@@QAEPA_WI@Z ; std::_Wrap_alloc<std::allocator<wchar_t>>::allocate(uint)
.text$mn:00009664                 mov     [ebp-20h], eax
.text$mn:00009667                 jmp     short loc_9684
.text$mn:00009667 __catch$?_Copy@?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QAEXII@Z$0 endp
.text$mn:00009667
.text$mn:00009669
.text$mn:00009669 ; =============== S U B R O U T I N E =======================================
.text$mn:00009669
.text$mn:00009669 ; Attributes: noreturn
.text$mn:00009669
.text$mn:00009669 __catch$?_Copy@?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QAEXII@Z$1 proc near
.text$mn:00009669                                         ; DATA XREF: .xdata$x:0000DC74o
.text$mn:00009669                 push    0
.text$mn:0000966B                 push    1
.text$mn:0000966D                 mov     ecx, [ebp-18h]
.text$mn:00009670                 call    ?_Tidy@?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QAEX_NI@Z ; std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>>::_Tidy(bool,uint)
.text$mn:00009675                 push    0
.text$mn:00009677                 push    0
.text$mn:00009679                 call    __CxxThrowException@8 ; _CxxThrowException(x,x)
.text$mn:00009679 __catch$?_Copy@?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QAEXII@Z$1 endp
.text$mn:00009679
.text$mn:0000967E ; ---------------------------------------------------------------------------
.text$mn:0000967E                 mov     eax, offset $LN17_0
.text$mn:00009683                 retn
.text$mn:00009684 ; ---------------------------------------------------------------------------
.text$mn:00009684 ; START OF FUNCTION CHUNK FOR __catch$?_Copy@?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QAEXII@Z$0
.text$mn:00009684
.text$mn:00009684 loc_9684:                               ; CODE XREF: __catch$?_Copy@?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QAEXII@Z$0+2Aj
.text$mn:00009684                 mov     dword ptr [ebp-4], 1
.text$mn:0000968B                 jmp     short loc_9694
.text$mn:0000968B ; END OF FUNCTION CHUNK FOR __catch$?_Copy@?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QAEXII@Z$0
.text$mn:0000968D
.text$mn:0000968D ; =============== S U B R O U T I N E =======================================
.text$mn:0000968D
.text$mn:0000968D
.text$mn:0000968D $LN17_0         proc near               ; DATA XREF: .text$mn:0000967Eo
.text$mn:0000968D                 mov     dword ptr [ebp-4], 1
.text$mn:0000968D $LN17_0         endp ; sp-analysis failed
.text$mn:0000968D
.text$mn:00009694 ; START OF FUNCTION CHUNK FOR __catch$?_Copy@?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QAEXII@Z$0
.text$mn:00009694
.text$mn:00009694 loc_9694:                               ; CODE XREF: __catch$?_Copy@?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QAEXII@Z$0+4Ej
.text$mn:00009694                 mov     eax, offset $LN19_0
.text$mn:00009699                 retn
.text$mn:00009699 ; END OF FUNCTION CHUNK FOR __catch$?_Copy@?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QAEXII@Z$0
.text$mn:0000969A ; ---------------------------------------------------------------------------
.text$mn:0000969A ; START OF FUNCTION CHUNK FOR ?_Copy@?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QAEXII@Z
.text$mn:0000969A
.text$mn:0000969A loc_969A:                               ; CODE XREF: std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>>::_Copy(uint,uint)+C3j
.text$mn:0000969A                 mov     [ebp+var_4], 0FFFFFFFFh
.text$mn:000096A1                 jmp     short loc_96AA
.text$mn:000096A1 ; END OF FUNCTION CHUNK FOR ?_Copy@?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QAEXII@Z
.text$mn:000096A3
.text$mn:000096A3 ; =============== S U B R O U T I N E =======================================
.text$mn:000096A3
.text$mn:000096A3
.text$mn:000096A3 $LN19_0         proc near               ; DATA XREF: __catch$?_Copy@?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QAEXII@Z$0:loc_9694o
.text$mn:000096A3                 mov     dword ptr [ebp-4], 0FFFFFFFFh
.text$mn:000096AA
.text$mn:000096AA loc_96AA:                               ; CODE XREF: std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>>::_Copy(uint,uint)+129j
.text$mn:000096AA                 cmp     dword ptr [ebp+0Ch], 0
.text$mn:000096AE                 jbe     short loc_96C9
.text$mn:000096B0                 mov     edx, [ebp+0Ch]
.text$mn:000096B3                 push    edx             ; int
.text$mn:000096B4                 mov     ecx, [ebp-18h]
.text$mn:000096B7                 call    ?_Myptr@?$_String_val@U?$_Simple_types@_W@std@@@std@@QAEPA_WXZ ; std::_String_val<std::_Simple_types<wchar_t>>::_Myptr(void)
.text$mn:000096BC                 push    eax             ; Src
.text$mn:000096BD                 mov     eax, [ebp-20h]
.text$mn:000096C0                 push    eax             ; Dst
.text$mn:000096C1                 call    ?copy@?$char_traits@_W@std@@SAPA_WPA_WPB_WI@Z ; std::char_traits<wchar_t>::copy(wchar_t *,wchar_t const *,uint)
.text$mn:000096C6                 add     esp, 0Ch
.text$mn:000096C9
.text$mn:000096C9 loc_96C9:                               ; CODE XREF: $LN19_0+Bj
.text$mn:000096C9                 push    0
.text$mn:000096CB                 push    1
.text$mn:000096CD                 mov     ecx, [ebp-18h]
.text$mn:000096D0                 call    ?_Tidy@?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QAEX_NI@Z ; std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>>::_Tidy(bool,uint)
.text$mn:000096D5                 lea     ecx, [ebp-20h]
.text$mn:000096D8                 push    ecx             ; int
.text$mn:000096D9                 mov     edx, [ebp-18h]
.text$mn:000096DC                 add     edx, 4
.text$mn:000096DF                 push    edx             ; void *
.text$mn:000096E0                 lea     eax, [ebp-13h]
.text$mn:000096E3                 push    eax
.text$mn:000096E4                 mov     ecx, [ebp-18h]
.text$mn:000096E7                 call    ?_Getal@?$_String_alloc@$0A@U?$_String_base_types@_WV?$allocator@_W@std@@@std@@@std@@QBE?AU?$_Wrap_alloc@V?$allocator@_W@std@@@2@XZ ; std::_String_alloc<0,std::_String_base_types<wchar_t,std::allocator<wchar_t>>>::_Getal(void)
.text$mn:000096EC                 mov     ecx, eax
.text$mn:000096EE                 call    ??$construct@PA_WAAPA_W@?$_Wrap_alloc@V?$allocator@_W@std@@@std@@QAEXPAPA_WAAPA_W@Z ; std::_Wrap_alloc<std::allocator<wchar_t>>::construct<wchar_t *,wchar_t * &>(wchar_t * *,wchar_t * &)
.text$mn:000096F3                 mov     ecx, [ebp-18h]
.text$mn:000096F6                 mov     edx, [ebp-1Ch]
.text$mn:000096F9                 mov     [ecx+18h], edx
.text$mn:000096FC                 mov     eax, [ebp+0Ch]
.text$mn:000096FF                 push    eax
.text$mn:00009700                 mov     ecx, [ebp-18h]
.text$mn:00009703                 call    ?_Eos@?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QAEXI@Z ; std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>>::_Eos(uint)
.text$mn:00009708                 mov     ecx, [ebp-0Ch]
.text$mn:0000970B                 mov     large fs:0, ecx
.text$mn:00009712                 pop     ecx
.text$mn:00009713                 pop     edi
.text$mn:00009714                 pop     esi
.text$mn:00009715                 pop     ebx
.text$mn:00009716                 mov     esp, ebp
.text$mn:00009718                 pop     ebp
.text$mn:00009719                 retn    8
.text$mn:00009719 $LN19_0         endp ; sp-analysis failed
.text$mn:00009719
.text$mn:00009719 _text$mn        ends
.text$mn:00009719
.text$x:0000971C ; ===========================================================================
.text$x:0000971C
.text$x:0000971C ; Segment type: Pure code
.text$x:0000971C ; Segment permissions: Read/Execute
.text$x:0000971C _text$x         segment para public 'CODE' use32
.text$x:0000971C                 assume cs:_text$x
.text$x:0000971C                 ;org 971Ch
.text$x:0000971C ; COMDAT (pick associative to section at 9578)
.text$x:0000971C                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text$x:0000971C
.text$x:0000971C ; =============== S U B R O U T I N E =======================================
.text$x:0000971C
.text$x:0000971C
.text$x:0000971C __ehhandler$?_Copy@?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QAEXII@Z proc near
.text$x:0000971C                                         ; DATA XREF: std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>>::_Copy(uint,uint)+5o
.text$x:0000971C
.text$x:0000971C arg_4           = dword ptr  8
.text$x:0000971C
.text$x:0000971C                 mov     edx, [esp+arg_4]
.text$x:00009720                 lea     eax, [edx+0Ch]
.text$x:00009723                 mov     ecx, [edx-24h]
.text$x:00009726                 xor     ecx, eax
.text$x:00009728                 call    @__security_check_cookie@4 ; __security_check_cookie(x)
.text$x:0000972D                 mov     eax, offset __ehfuncinfo$?_Copy@?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QAEXII@Z
.text$x:00009732                 jmp     ___CxxFrameHandler3
.text$x:00009732 __ehhandler$?_Copy@?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QAEXII@Z endp
.text$x:00009732
.text$x:00009732 ; ---------------------------------------------------------------------------
.text$x:00009737                 align 4
.text$x:00009737 _text$x         ends
.text$x:00009737
.text$mn:00009738 ; ===========================================================================
.text$mn:00009738
.text$mn:00009738 ; Segment type: Pure code
.text$mn:00009738 ; Segment permissions: Read/Execute
.text$mn:00009738 _text$mn        segment para public 'CODE' use32
.text$mn:00009738                 assume cs:_text$mn
.text$mn:00009738                 ;org 9738h
.text$mn:00009738 ; COMDAT (pick any)
.text$mn:00009738                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text$mn:00009738
.text$mn:00009738 ; =============== S U B R O U T I N E =======================================
.text$mn:00009738
.text$mn:00009738 ; Attributes: bp-based frame
.text$mn:00009738
.text$mn:00009738 ; protected: void __thiscall std::vector<char, class std::allocator<char>>::_Destroy(char *, char *)
.text$mn:00009738                 public ?_Destroy@?$vector@DV?$allocator@D@std@@@std@@IAEXPAD0@Z
.text$mn:00009738 ?_Destroy@?$vector@DV?$allocator@D@std@@@std@@IAEXPAD0@Z proc near
.text$mn:00009738                                         ; CODE XREF: std::vector<char,std::allocator<char>>::_Tidy(void)+2Bp
.text$mn:00009738
.text$mn:00009738 var_8           = dword ptr -8
.text$mn:00009738 var_1           = byte ptr -1
.text$mn:00009738 arg_0           = dword ptr  8
.text$mn:00009738 arg_4           = dword ptr  0Ch
.text$mn:00009738
.text$mn:00009738                 push    ebp
.text$mn:00009739                 mov     ebp, esp
.text$mn:0000973B                 sub     esp, 8
.text$mn:0000973E                 mov     [ebp+var_8], ecx
.text$mn:00009741                 lea     eax, [ebp+var_1]
.text$mn:00009744                 push    eax
.text$mn:00009745                 mov     ecx, [ebp+var_8]
.text$mn:00009748                 call    ?_Getal@?$_Vector_alloc@$0A@U?$_Vec_base_types@DV?$allocator@D@std@@@std@@@std@@QBE?AU?$_Wrap_alloc@V?$allocator@D@std@@@2@XZ ; std::_Vector_alloc<0,std::_Vec_base_types<char,std::allocator<char>>>::_Getal(void)
.text$mn:0000974D                 lea     ecx, [ebp+var_1]
.text$mn:00009750                 push    ecx
.text$mn:00009751                 mov     edx, [ebp+arg_4]
.text$mn:00009754                 push    edx
.text$mn:00009755                 mov     eax, [ebp+arg_0]
.text$mn:00009758                 push    eax
.text$mn:00009759                 call    ??$_Destroy_range@U?$_Wrap_alloc@V?$allocator@D@std@@@std@@@std@@YAXPAD0AAU?$_Wrap_alloc@V?$allocator@D@std@@@0@@Z ; std::_Destroy_range<std::_Wrap_alloc<std::allocator<char>>>(char *,char *,std::_Wrap_alloc<std::allocator<char>> &)
.text$mn:0000975E                 add     esp, 0Ch
.text$mn:00009761                 mov     esp, ebp
.text$mn:00009763                 pop     ebp
.text$mn:00009764                 retn    8
.text$mn:00009764 ?_Destroy@?$vector@DV?$allocator@D@std@@@std@@IAEXPAD0@Z endp
.text$mn:00009764
.text$mn:00009764 ; ---------------------------------------------------------------------------
.text$mn:00009767                 align 4
.text$mn:00009767 _text$mn        ends
.text$mn:00009767
.text$mn:00009768 ; ===========================================================================
.text$mn:00009768
.text$mn:00009768 ; Segment type: Pure code
.text$mn:00009768 ; Segment permissions: Read/Execute
.text$mn:00009768 _text$mn        segment para public 'CODE' use32
.text$mn:00009768                 assume cs:_text$mn
.text$mn:00009768                 ;org 9768h
.text$mn:00009768 ; COMDAT (pick any)
.text$mn:00009768                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text$mn:00009768
.text$mn:00009768 ; =============== S U B R O U T I N E =======================================
.text$mn:00009768
.text$mn:00009768 ; Attributes: bp-based frame
.text$mn:00009768
.text$mn:00009768 ; protected: void __thiscall std::vector<class std::basic_string<wchar_t, struct std::char_traits<wchar_t>, class std::allocator<wchar_t>>, class std::allocator<class std::basic_string<wchar_t, struct std::char_traits<wchar_t>, class std::allocator<wchar_t>>>>::_Destroy(class std::basic_string<wchar_t, struct std::char_traits<wchar_t>, class std::allocator<wchar_t>> *, class std::basic_string<wchar_t, struct std::char_traits<wchar_t>, class std::allocator<wchar_t>> *)
.text$mn:00009768                 public ?_Destroy@?$vector@V?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@V?$allocator@V?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@@2@@std@@IAEXPAV?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@2@0@Z
.text$mn:00009768 ?_Destroy@?$vector@V?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@V?$allocator@V?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@@2@@std@@IAEXPAV?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@2@0@Z proc near
.text$mn:00009768                                         ; CODE XREF: std::vector<std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>>,std::allocator<std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>>>>::_Reallocate(uint)+CBp
.text$mn:00009768                                         ; std::vector<std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>>,std::allocator<std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>>>>::_Tidy(void)+2Bp
.text$mn:00009768
.text$mn:00009768 var_8           = dword ptr -8
.text$mn:00009768 var_1           = byte ptr -1
.text$mn:00009768 arg_0           = dword ptr  8
.text$mn:00009768 arg_4           = dword ptr  0Ch
.text$mn:00009768
.text$mn:00009768                 push    ebp
.text$mn:00009769                 mov     ebp, esp
.text$mn:0000976B                 sub     esp, 8
.text$mn:0000976E                 mov     [ebp+var_8], ecx
.text$mn:00009771                 lea     eax, [ebp+var_1]
.text$mn:00009774                 push    eax
.text$mn:00009775                 mov     ecx, [ebp+var_8]
.text$mn:00009778                 call    ?_Getal@?$_Vector_alloc@$0A@U?$_Vec_base_types@V?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@V?$allocator@V?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@@2@@std@@@std@@QBE?AU?$_Wrap_alloc@V?$allocator@V?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@@std@@@2@XZ ; std::_Vector_alloc<0,std::_Vec_base_types<std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>>,std::allocator<std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>>>>>::_Getal(void)
.text$mn:0000977D                 lea     ecx, [ebp+var_1]
.text$mn:00009780                 push    ecx
.text$mn:00009781                 mov     edx, [ebp+arg_4]
.text$mn:00009784                 push    edx
.text$mn:00009785                 mov     eax, [ebp+arg_0]
.text$mn:00009788                 push    eax
.text$mn:00009789                 call    ??$_Destroy_range@U?$_Wrap_alloc@V?$allocator@V?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@@std@@@std@@@std@@YAXPAV?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@0@0AAU?$_Wrap_alloc@V?$allocator@V?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@@std@@@0@@Z ; std::_Destroy_range<std::_Wrap_alloc<std::allocator<std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>>>>>(std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>> *,std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>> *,std::_Wrap_alloc<std::allocator<std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>>>> &)
.text$mn:0000978E                 add     esp, 0Ch
.text$mn:00009791                 mov     esp, ebp
.text$mn:00009793                 pop     ebp
.text$mn:00009794                 retn    8
.text$mn:00009794 ?_Destroy@?$vector@V?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@V?$allocator@V?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@@2@@std@@IAEXPAV?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@2@0@Z endp
.text$mn:00009794
.text$mn:00009794 ; ---------------------------------------------------------------------------
.text$mn:00009797                 align 4
.text$mn:00009797 _text$mn        ends
.text$mn:00009797
.text$mn:00009798 ; ===========================================================================
.text$mn:00009798
.text$mn:00009798 ; Segment type: Pure code
.text$mn:00009798 ; Segment permissions: Read/Execute
.text$mn:00009798 _text$mn        segment para public 'CODE' use32
.text$mn:00009798                 assume cs:_text$mn
.text$mn:00009798                 ;org 9798h
.text$mn:00009798 ; COMDAT (pick any)
.text$mn:00009798                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text$mn:00009798
.text$mn:00009798 ; =============== S U B R O U T I N E =======================================
.text$mn:00009798
.text$mn:00009798 ; Attributes: bp-based frame
.text$mn:00009798
.text$mn:00009798 ; protected: void __thiscall std::vector<wchar_t, class std::allocator<wchar_t>>::_Destroy(wchar_t *, wchar_t *)
.text$mn:00009798                 public ?_Destroy@?$vector@_WV?$allocator@_W@std@@@std@@IAEXPA_W0@Z
.text$mn:00009798 ?_Destroy@?$vector@_WV?$allocator@_W@std@@@std@@IAEXPA_W0@Z proc near
.text$mn:00009798                                         ; CODE XREF: std::vector<wchar_t,std::allocator<wchar_t>>::_Reallocate(uint)+CBp
.text$mn:00009798                                         ; std::vector<wchar_t,std::allocator<wchar_t>>::_Tidy(void)+2Bp
.text$mn:00009798
.text$mn:00009798 var_8           = dword ptr -8
.text$mn:00009798 var_1           = byte ptr -1
.text$mn:00009798 arg_0           = dword ptr  8
.text$mn:00009798 arg_4           = dword ptr  0Ch
.text$mn:00009798
.text$mn:00009798                 push    ebp
.text$mn:00009799                 mov     ebp, esp
.text$mn:0000979B                 sub     esp, 8
.text$mn:0000979E                 mov     [ebp+var_8], ecx
.text$mn:000097A1                 lea     eax, [ebp+var_1]
.text$mn:000097A4                 push    eax
.text$mn:000097A5                 mov     ecx, [ebp+var_8]
.text$mn:000097A8                 call    ?_Getal@?$_Vector_alloc@$0A@U?$_Vec_base_types@_WV?$allocator@_W@std@@@std@@@std@@QBE?AU?$_Wrap_alloc@V?$allocator@_W@std@@@2@XZ ; std::_Vector_alloc<0,std::_Vec_base_types<wchar_t,std::allocator<wchar_t>>>::_Getal(void)
.text$mn:000097AD                 lea     ecx, [ebp+var_1]
.text$mn:000097B0                 push    ecx
.text$mn:000097B1                 mov     edx, [ebp+arg_4]
.text$mn:000097B4                 push    edx
.text$mn:000097B5                 mov     eax, [ebp+arg_0]
.text$mn:000097B8                 push    eax
.text$mn:000097B9                 call    ??$_Destroy_range@U?$_Wrap_alloc@V?$allocator@_W@std@@@std@@@std@@YAXPA_W0AAU?$_Wrap_alloc@V?$allocator@_W@std@@@0@@Z ; std::_Destroy_range<std::_Wrap_alloc<std::allocator<wchar_t>>>(wchar_t *,wchar_t *,std::_Wrap_alloc<std::allocator<wchar_t>> &)
.text$mn:000097BE                 add     esp, 0Ch
.text$mn:000097C1                 mov     esp, ebp
.text$mn:000097C3                 pop     ebp
.text$mn:000097C4                 retn    8
.text$mn:000097C4 ?_Destroy@?$vector@_WV?$allocator@_W@std@@@std@@IAEXPA_W0@Z endp
.text$mn:000097C4
.text$mn:000097C4 ; ---------------------------------------------------------------------------
.text$mn:000097C7                 align 4
.text$mn:000097C7 _text$mn        ends
.text$mn:000097C7
.text$mn:000097C8 ; ===========================================================================
.text$mn:000097C8
.text$mn:000097C8 ; Segment type: Pure code
.text$mn:000097C8 ; Segment permissions: Read/Execute
.text$mn:000097C8 _text$mn        segment para public 'CODE' use32
.text$mn:000097C8                 assume cs:_text$mn
.text$mn:000097C8                 ;org 97C8h
.text$mn:000097C8 ; COMDAT (pick any)
.text$mn:000097C8                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text$mn:000097C8
.text$mn:000097C8 ; =============== S U B R O U T I N E =======================================
.text$mn:000097C8
.text$mn:000097C8 ; Attributes: bp-based frame
.text$mn:000097C8
.text$mn:000097C8 ; public: void __thiscall std::basic_string<char, struct std::char_traits<char>, class std::allocator<char>>::_Eos(unsigned int)
.text$mn:000097C8                 public ?_Eos@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEXI@Z
.text$mn:000097C8 ?_Eos@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEXI@Z proc near
.text$mn:000097C8                                         ; CODE XREF: $LN19+60p
.text$mn:000097C8                                         ; std::basic_string<char,std::char_traits<char>,std::allocator<char>>::_Grow(uint,bool)+83p ...
.text$mn:000097C8
.text$mn:000097C8 var_8           = dword ptr -8
.text$mn:000097C8 var_1           = byte ptr -1
.text$mn:000097C8 arg_0           = dword ptr  8
.text$mn:000097C8
.text$mn:000097C8                 push    ebp
.text$mn:000097C9                 mov     ebp, esp
.text$mn:000097CB                 sub     esp, 8
.text$mn:000097CE                 mov     [ebp+var_8], ecx
.text$mn:000097D1                 mov     [ebp+var_1], 0
.text$mn:000097D5                 mov     eax, [ebp+var_8]
.text$mn:000097D8                 mov     ecx, [ebp+arg_0]
.text$mn:000097DB                 mov     [eax+14h], ecx
.text$mn:000097DE                 lea     edx, [ebp+var_1]
.text$mn:000097E1                 push    edx
.text$mn:000097E2                 mov     ecx, [ebp+var_8]
.text$mn:000097E5                 call    ?_Myptr@?$_String_val@U?$_Simple_types@D@std@@@std@@QAEPADXZ ; std::_String_val<std::_Simple_types<char>>::_Myptr(void)
.text$mn:000097EA                 add     eax, [ebp+arg_0]
.text$mn:000097ED                 push    eax
.text$mn:000097EE                 call    ?assign@?$char_traits@D@std@@SAXAADABD@Z ; std::char_traits<char>::assign(char &,char const &)
.text$mn:000097F3                 add     esp, 8
.text$mn:000097F6                 mov     esp, ebp
.text$mn:000097F8                 pop     ebp
.text$mn:000097F9                 retn    4
.text$mn:000097F9 ?_Eos@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEXI@Z endp
.text$mn:000097F9
.text$mn:000097F9 _text$mn        ends
.text$mn:000097F9
.text$mn:000097FC ; ===========================================================================
.text$mn:000097FC
.text$mn:000097FC ; Segment type: Pure code
.text$mn:000097FC ; Segment permissions: Read/Execute
.text$mn:000097FC _text$mn        segment para public 'CODE' use32
.text$mn:000097FC                 assume cs:_text$mn
.text$mn:000097FC                 ;org 97FCh
.text$mn:000097FC ; COMDAT (pick any)
.text$mn:000097FC                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text$mn:000097FC
.text$mn:000097FC ; =============== S U B R O U T I N E =======================================
.text$mn:000097FC
.text$mn:000097FC ; Attributes: bp-based frame
.text$mn:000097FC
.text$mn:000097FC ; public: void __thiscall std::basic_string<wchar_t, struct std::char_traits<wchar_t>, class std::allocator<wchar_t>>::_Eos(unsigned int)
.text$mn:000097FC                 public ?_Eos@?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QAEXI@Z
.text$mn:000097FC ?_Eos@?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QAEXI@Z proc near
.text$mn:000097FC                                         ; CODE XREF: $LN19_0+60p
.text$mn:000097FC                                         ; std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>>::_Grow(uint,bool)+83p ...
.text$mn:000097FC
.text$mn:000097FC var_8           = dword ptr -8
.text$mn:000097FC var_2           = word ptr -2
.text$mn:000097FC arg_0           = dword ptr  8
.text$mn:000097FC
.text$mn:000097FC                 push    ebp
.text$mn:000097FD                 mov     ebp, esp
.text$mn:000097FF                 sub     esp, 8
.text$mn:00009802                 mov     [ebp+var_8], ecx
.text$mn:00009805                 xor     eax, eax
.text$mn:00009807                 mov     [ebp+var_2], ax
.text$mn:0000980B                 mov     ecx, [ebp+var_8]
.text$mn:0000980E                 mov     edx, [ebp+arg_0]
.text$mn:00009811                 mov     [ecx+14h], edx
.text$mn:00009814                 lea     eax, [ebp+var_2]
.text$mn:00009817                 push    eax
.text$mn:00009818                 mov     ecx, [ebp+var_8]
.text$mn:0000981B                 call    ?_Myptr@?$_String_val@U?$_Simple_types@_W@std@@@std@@QAEPA_WXZ ; std::_String_val<std::_Simple_types<wchar_t>>::_Myptr(void)
.text$mn:00009820                 mov     ecx, [ebp+arg_0]
.text$mn:00009823                 lea     edx, [eax+ecx*2]
.text$mn:00009826                 push    edx
.text$mn:00009827                 call    ?assign@?$char_traits@_W@std@@SAXAA_WAB_W@Z ; std::char_traits<wchar_t>::assign(wchar_t &,wchar_t const &)
.text$mn:0000982C                 add     esp, 8
.text$mn:0000982F                 mov     esp, ebp
.text$mn:00009831                 pop     ebp
.text$mn:00009832                 retn    4
.text$mn:00009832 ?_Eos@?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QAEXI@Z endp
.text$mn:00009832
.text$mn:00009832 ; ---------------------------------------------------------------------------
.text$mn:00009835                 align 4
.text$mn:00009835 _text$mn        ends
.text$mn:00009835
.text$mn:00009838 ; ===========================================================================
.text$mn:00009838
.text$mn:00009838 ; Segment type: Pure code
.text$mn:00009838 ; Segment permissions: Read/Execute
.text$mn:00009838 _text$mn        segment para public 'CODE' use32
.text$mn:00009838                 assume cs:_text$mn
.text$mn:00009838                 ;org 9838h
.text$mn:00009838 ; COMDAT (pick any)
.text$mn:00009838                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text$mn:00009838
.text$mn:00009838 ; =============== S U B R O U T I N E =======================================
.text$mn:00009838
.text$mn:00009838 ; Attributes: bp-based frame
.text$mn:00009838
.text$mn:00009838 ; char *__cdecl std::_Fill_n(char *Dst, size_t Size, char)
.text$mn:00009838                 public ?_Fill_n@std@@YAPADPADID@Z
.text$mn:00009838 ?_Fill_n@std@@YAPADPADID@Z proc near    ; CODE XREF: std::_Uninit_def_fill_n<char,uint,char>(char *,uint,std::_Wrap_alloc<std::allocator<char>> &,char *,std::_Scalar_ptr_iterator_tag)+Dp
.text$mn:00009838
.text$mn:00009838 Dst             = dword ptr  8
.text$mn:00009838 Size            = dword ptr  0Ch
.text$mn:00009838 arg_8           = byte ptr  10h
.text$mn:00009838
.text$mn:00009838                 push    ebp
.text$mn:00009839                 mov     ebp, esp
.text$mn:0000983B                 mov     eax, [ebp+Size]
.text$mn:0000983E                 push    eax             ; Size
.text$mn:0000983F                 movsx   ecx, [ebp+arg_8]
.text$mn:00009843                 push    ecx             ; Val
.text$mn:00009844                 mov     edx, [ebp+Dst]
.text$mn:00009847                 push    edx             ; Dst
.text$mn:00009848                 call    _memset
.text$mn:0000984D                 add     esp, 0Ch
.text$mn:00009850                 mov     eax, [ebp+Dst]
.text$mn:00009853                 add     eax, [ebp+Size]
.text$mn:00009856                 pop     ebp
.text$mn:00009857                 retn
.text$mn:00009857 ?_Fill_n@std@@YAPADPADID@Z endp
.text$mn:00009857
.text$mn:00009857 _text$mn        ends
.text$mn:00009857
.text$mn:00009858 ; ===========================================================================
.text$mn:00009858
.text$mn:00009858 ; Segment type: Pure code
.text$mn:00009858 ; Segment permissions: Read/Execute
.text$mn:00009858 _text$mn        segment para public 'CODE' use32
.text$mn:00009858                 assume cs:_text$mn
.text$mn:00009858                 ;org 9858h
.text$mn:00009858 ; COMDAT (pick any)
.text$mn:00009858                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text$mn:00009858
.text$mn:00009858 ; =============== S U B R O U T I N E =======================================
.text$mn:00009858
.text$mn:00009858 ; Attributes: bp-based frame
.text$mn:00009858
.text$mn:00009858 ; public: void __thiscall std::_String_alloc<0, struct std::_String_base_types<char, class std::allocator<char>>>::_Free_proxy(void)
.text$mn:00009858                 public ?_Free_proxy@?$_String_alloc@$0A@U?$_String_base_types@DV?$allocator@D@std@@@std@@@std@@QAEXXZ
.text$mn:00009858 ?_Free_proxy@?$_String_alloc@$0A@U?$_String_base_types@DV?$allocator@D@std@@@std@@@std@@QAEXXZ proc near
.text$mn:00009858                                         ; CODE XREF: std::_String_alloc<0,std::_String_base_types<char,std::allocator<char>>>::~_String_alloc<0,std::_String_base_types<char,std::allocator<char>>>(void)+30p
.text$mn:00009858
.text$mn:00009858 var_8           = dword ptr -8
.text$mn:00009858 var_1           = byte ptr -1
.text$mn:00009858
.text$mn:00009858                 push    ebp
.text$mn:00009859                 mov     ebp, esp
.text$mn:0000985B                 sub     esp, 8
.text$mn:0000985E                 mov     [ebp+var_8], ecx
.text$mn:00009861                 lea     ecx, [ebp+var_1]
.text$mn:00009864                 call    ??0?$allocator@U_Container_proxy@std@@@std@@QAE@XZ ; std::allocator<std::_Container_proxy>::allocator<std::_Container_proxy>(void)
.text$mn:00009869                 mov     ecx, [ebp+var_8] ; this
.text$mn:0000986C                 call    ?_Orphan_all@_Container_base12@std@@QAEXXZ ; std::_Container_base12::_Orphan_all(void)
.text$mn:00009871                 mov     eax, [ebp+var_8]
.text$mn:00009874                 mov     ecx, [eax]
.text$mn:00009876                 push    ecx
.text$mn:00009877                 lea     ecx, [ebp+var_1]
.text$mn:0000987A                 call    ??$destroy@U_Container_proxy@std@@@?$allocator@U_Container_proxy@std@@@std@@QAEXPAU_Container_proxy@1@@Z ; std::allocator<std::_Container_proxy>::destroy<std::_Container_proxy>(std::_Container_proxy *)
.text$mn:0000987F                 push    1               ; int
.text$mn:00009881                 mov     edx, [ebp+var_8]
.text$mn:00009884                 mov     eax, [edx]
.text$mn:00009886                 push    eax             ; void *
.text$mn:00009887                 lea     ecx, [ebp+var_1]
.text$mn:0000988A                 call    ?deallocate@?$allocator@U_Container_proxy@std@@@std@@QAEXPAU_Container_proxy@2@I@Z ; std::allocator<std::_Container_proxy>::deallocate(std::_Container_proxy *,uint)
.text$mn:0000988F                 mov     ecx, [ebp+var_8]
.text$mn:00009892                 mov     dword ptr [ecx], 0
.text$mn:00009898                 mov     esp, ebp
.text$mn:0000989A                 pop     ebp
.text$mn:0000989B                 retn
.text$mn:0000989B ?_Free_proxy@?$_String_alloc@$0A@U?$_String_base_types@DV?$allocator@D@std@@@std@@@std@@QAEXXZ endp
.text$mn:0000989B
.text$mn:0000989B _text$mn        ends
.text$mn:0000989B
.text$mn:0000989C ; ===========================================================================
.text$mn:0000989C
.text$mn:0000989C ; Segment type: Pure code
.text$mn:0000989C ; Segment permissions: Read/Execute
.text$mn:0000989C _text$mn        segment para public 'CODE' use32
.text$mn:0000989C                 assume cs:_text$mn
.text$mn:0000989C                 ;org 989Ch
.text$mn:0000989C ; COMDAT (pick any)
.text$mn:0000989C                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text$mn:0000989C
.text$mn:0000989C ; =============== S U B R O U T I N E =======================================
.text$mn:0000989C
.text$mn:0000989C ; Attributes: bp-based frame
.text$mn:0000989C
.text$mn:0000989C ; public: void __thiscall std::_String_alloc<0, struct std::_String_base_types<wchar_t, class std::allocator<wchar_t>>>::_Free_proxy(void)
.text$mn:0000989C                 public ?_Free_proxy@?$_String_alloc@$0A@U?$_String_base_types@_WV?$allocator@_W@std@@@std@@@std@@QAEXXZ
.text$mn:0000989C ?_Free_proxy@?$_String_alloc@$0A@U?$_String_base_types@_WV?$allocator@_W@std@@@std@@@std@@QAEXXZ proc near
.text$mn:0000989C                                         ; CODE XREF: std::_String_alloc<0,std::_String_base_types<wchar_t,std::allocator<wchar_t>>>::~_String_alloc<0,std::_String_base_types<wchar_t,std::allocator<wchar_t>>>(void)+30p
.text$mn:0000989C
.text$mn:0000989C var_8           = dword ptr -8
.text$mn:0000989C var_1           = byte ptr -1
.text$mn:0000989C
.text$mn:0000989C                 push    ebp
.text$mn:0000989D                 mov     ebp, esp
.text$mn:0000989F                 sub     esp, 8
.text$mn:000098A2                 mov     [ebp+var_8], ecx
.text$mn:000098A5                 lea     ecx, [ebp+var_1]
.text$mn:000098A8                 call    ??0?$allocator@U_Container_proxy@std@@@std@@QAE@XZ ; std::allocator<std::_Container_proxy>::allocator<std::_Container_proxy>(void)
.text$mn:000098AD                 mov     ecx, [ebp+var_8] ; this
.text$mn:000098B0                 call    ?_Orphan_all@_Container_base12@std@@QAEXXZ ; std::_Container_base12::_Orphan_all(void)
.text$mn:000098B5                 mov     eax, [ebp+var_8]
.text$mn:000098B8                 mov     ecx, [eax]
.text$mn:000098BA                 push    ecx
.text$mn:000098BB                 lea     ecx, [ebp+var_1]
.text$mn:000098BE                 call    ??$destroy@U_Container_proxy@std@@@?$allocator@U_Container_proxy@std@@@std@@QAEXPAU_Container_proxy@1@@Z ; std::allocator<std::_Container_proxy>::destroy<std::_Container_proxy>(std::_Container_proxy *)
.text$mn:000098C3                 push    1               ; int
.text$mn:000098C5                 mov     edx, [ebp+var_8]
.text$mn:000098C8                 mov     eax, [edx]
.text$mn:000098CA                 push    eax             ; void *
.text$mn:000098CB                 lea     ecx, [ebp+var_1]
.text$mn:000098CE                 call    ?deallocate@?$allocator@U_Container_proxy@std@@@std@@QAEXPAU_Container_proxy@2@I@Z ; std::allocator<std::_Container_proxy>::deallocate(std::_Container_proxy *,uint)
.text$mn:000098D3                 mov     ecx, [ebp+var_8]
.text$mn:000098D6                 mov     dword ptr [ecx], 0
.text$mn:000098DC                 mov     esp, ebp
.text$mn:000098DE                 pop     ebp
.text$mn:000098DF                 retn
.text$mn:000098DF ?_Free_proxy@?$_String_alloc@$0A@U?$_String_base_types@_WV?$allocator@_W@std@@@std@@@std@@QAEXXZ endp
.text$mn:000098DF
.text$mn:000098DF _text$mn        ends
.text$mn:000098DF
.text$mn:000098E0 ; ===========================================================================
.text$mn:000098E0
.text$mn:000098E0 ; Segment type: Pure code
.text$mn:000098E0 ; Segment permissions: Read/Execute
.text$mn:000098E0 _text$mn        segment para public 'CODE' use32
.text$mn:000098E0                 assume cs:_text$mn
.text$mn:000098E0                 ;org 98E0h
.text$mn:000098E0 ; COMDAT (pick any)
.text$mn:000098E0                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text$mn:000098E0
.text$mn:000098E0 ; =============== S U B R O U T I N E =======================================
.text$mn:000098E0
.text$mn:000098E0 ; Attributes: bp-based frame
.text$mn:000098E0
.text$mn:000098E0 ; public: void __thiscall std::_Vector_alloc<0, struct std::_Vec_base_types<char, class std::allocator<char>>>::_Free_proxy(void)
.text$mn:000098E0                 public ?_Free_proxy@?$_Vector_alloc@$0A@U?$_Vec_base_types@DV?$allocator@D@std@@@std@@@std@@QAEXXZ
.text$mn:000098E0 ?_Free_proxy@?$_Vector_alloc@$0A@U?$_Vec_base_types@DV?$allocator@D@std@@@std@@@std@@QAEXXZ proc near
.text$mn:000098E0                                         ; CODE XREF: std::_Vector_alloc<0,std::_Vec_base_types<char,std::allocator<char>>>::~_Vector_alloc<0,std::_Vec_base_types<char,std::allocator<char>>>(void)+30p
.text$mn:000098E0
.text$mn:000098E0 var_8           = dword ptr -8
.text$mn:000098E0 var_1           = byte ptr -1
.text$mn:000098E0
.text$mn:000098E0                 push    ebp
.text$mn:000098E1                 mov     ebp, esp
.text$mn:000098E3                 sub     esp, 8
.text$mn:000098E6                 mov     [ebp+var_8], ecx
.text$mn:000098E9                 lea     ecx, [ebp+var_1]
.text$mn:000098EC                 call    ??0?$_Wrap_alloc@V?$allocator@U_Container_proxy@std@@@std@@@std@@QAE@XZ ; std::_Wrap_alloc<std::allocator<std::_Container_proxy>>::_Wrap_alloc<std::allocator<std::_Container_proxy>>(void)
.text$mn:000098F1                 mov     ecx, [ebp+var_8] ; this
.text$mn:000098F4                 call    ?_Orphan_all@_Container_base12@std@@QAEXXZ ; std::_Container_base12::_Orphan_all(void)
.text$mn:000098F9                 mov     eax, [ebp+var_8]
.text$mn:000098FC                 mov     ecx, [eax]
.text$mn:000098FE                 push    ecx
.text$mn:000098FF                 lea     ecx, [ebp+var_1]
.text$mn:00009902                 call    ??$destroy@U_Container_proxy@std@@@?$_Wrap_alloc@V?$allocator@U_Container_proxy@std@@@std@@@std@@QAEXPAU_Container_proxy@1@@Z ; std::_Wrap_alloc<std::allocator<std::_Container_proxy>>::destroy<std::_Container_proxy>(std::_Container_proxy *)
.text$mn:00009907                 push    1               ; int
.text$mn:00009909                 mov     edx, [ebp+var_8]
.text$mn:0000990C                 mov     eax, [edx]
.text$mn:0000990E                 push    eax             ; void *
.text$mn:0000990F                 lea     ecx, [ebp+var_1]
.text$mn:00009912                 call    ?deallocate@?$_Wrap_alloc@V?$allocator@U_Container_proxy@std@@@std@@@std@@QAEXPAU_Container_proxy@2@I@Z ; std::_Wrap_alloc<std::allocator<std::_Container_proxy>>::deallocate(std::_Container_proxy *,uint)
.text$mn:00009917                 mov     ecx, [ebp+var_8]
.text$mn:0000991A                 mov     dword ptr [ecx], 0
.text$mn:00009920                 mov     esp, ebp
.text$mn:00009922                 pop     ebp
.text$mn:00009923                 retn
.text$mn:00009923 ?_Free_proxy@?$_Vector_alloc@$0A@U?$_Vec_base_types@DV?$allocator@D@std@@@std@@@std@@QAEXXZ endp
.text$mn:00009923
.text$mn:00009923 _text$mn        ends
.text$mn:00009923
.text$mn:00009924 ; ===========================================================================
.text$mn:00009924
.text$mn:00009924 ; Segment type: Pure code
.text$mn:00009924 ; Segment permissions: Read/Execute
.text$mn:00009924 _text$mn        segment para public 'CODE' use32
.text$mn:00009924                 assume cs:_text$mn
.text$mn:00009924                 ;org 9924h
.text$mn:00009924 ; COMDAT (pick any)
.text$mn:00009924                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text$mn:00009924
.text$mn:00009924 ; =============== S U B R O U T I N E =======================================
.text$mn:00009924
.text$mn:00009924 ; Attributes: bp-based frame
.text$mn:00009924
.text$mn:00009924 ; public: void __thiscall std::_Vector_alloc<0, struct std::_Vec_base_types<class std::basic_string<wchar_t, struct std::char_traits<wchar_t>, class std::allocator<wchar_t>>, class std::allocator<class std::basic_string<wchar_t, struct std::char_traits<wchar_t>, class std::allocator<wchar_t>>>>>::_Free_proxy(void)
.text$mn:00009924                 public ?_Free_proxy@?$_Vector_alloc@$0A@U?$_Vec_base_types@V?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@V?$allocator@V?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@@2@@std@@@std@@QAEXXZ
.text$mn:00009924 ?_Free_proxy@?$_Vector_alloc@$0A@U?$_Vec_base_types@V?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@V?$allocator@V?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@@2@@std@@@std@@QAEXXZ proc near
.text$mn:00009924                                         ; CODE XREF: std::_Vector_alloc<0,std::_Vec_base_types<std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>>,std::allocator<std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>>>>>::~_Vector_alloc<0,std::_Vec_base_types<std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>>,std::allocator<std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>>>>>(void)+30p
.text$mn:00009924
.text$mn:00009924 var_8           = dword ptr -8
.text$mn:00009924 var_1           = byte ptr -1
.text$mn:00009924
.text$mn:00009924                 push    ebp
.text$mn:00009925                 mov     ebp, esp
.text$mn:00009927                 sub     esp, 8
.text$mn:0000992A                 mov     [ebp+var_8], ecx
.text$mn:0000992D                 lea     ecx, [ebp+var_1]
.text$mn:00009930                 call    ??0?$_Wrap_alloc@V?$allocator@U_Container_proxy@std@@@std@@@std@@QAE@XZ ; std::_Wrap_alloc<std::allocator<std::_Container_proxy>>::_Wrap_alloc<std::allocator<std::_Container_proxy>>(void)
.text$mn:00009935                 mov     ecx, [ebp+var_8] ; this
.text$mn:00009938                 call    ?_Orphan_all@_Container_base12@std@@QAEXXZ ; std::_Container_base12::_Orphan_all(void)
.text$mn:0000993D                 mov     eax, [ebp+var_8]
.text$mn:00009940                 mov     ecx, [eax]
.text$mn:00009942                 push    ecx
.text$mn:00009943                 lea     ecx, [ebp+var_1]
.text$mn:00009946                 call    ??$destroy@U_Container_proxy@std@@@?$_Wrap_alloc@V?$allocator@U_Container_proxy@std@@@std@@@std@@QAEXPAU_Container_proxy@1@@Z ; std::_Wrap_alloc<std::allocator<std::_Container_proxy>>::destroy<std::_Container_proxy>(std::_Container_proxy *)
.text$mn:0000994B                 push    1               ; int
.text$mn:0000994D                 mov     edx, [ebp+var_8]
.text$mn:00009950                 mov     eax, [edx]
.text$mn:00009952                 push    eax             ; void *
.text$mn:00009953                 lea     ecx, [ebp+var_1]
.text$mn:00009956                 call    ?deallocate@?$_Wrap_alloc@V?$allocator@U_Container_proxy@std@@@std@@@std@@QAEXPAU_Container_proxy@2@I@Z ; std::_Wrap_alloc<std::allocator<std::_Container_proxy>>::deallocate(std::_Container_proxy *,uint)
.text$mn:0000995B                 mov     ecx, [ebp+var_8]
.text$mn:0000995E                 mov     dword ptr [ecx], 0
.text$mn:00009964                 mov     esp, ebp
.text$mn:00009966                 pop     ebp
.text$mn:00009967                 retn
.text$mn:00009967 ?_Free_proxy@?$_Vector_alloc@$0A@U?$_Vec_base_types@V?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@V?$allocator@V?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@@2@@std@@@std@@QAEXXZ endp
.text$mn:00009967
.text$mn:00009967 _text$mn        ends
.text$mn:00009967
.text$mn:00009968 ; ===========================================================================
.text$mn:00009968
.text$mn:00009968 ; Segment type: Pure code
.text$mn:00009968 ; Segment permissions: Read/Execute
.text$mn:00009968 _text$mn        segment para public 'CODE' use32
.text$mn:00009968                 assume cs:_text$mn
.text$mn:00009968                 ;org 9968h
.text$mn:00009968 ; COMDAT (pick any)
.text$mn:00009968                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text$mn:00009968
.text$mn:00009968 ; =============== S U B R O U T I N E =======================================
.text$mn:00009968
.text$mn:00009968 ; Attributes: bp-based frame
.text$mn:00009968
.text$mn:00009968 ; public: void __thiscall std::_Vector_alloc<0, struct std::_Vec_base_types<wchar_t, class std::allocator<wchar_t>>>::_Free_proxy(void)
.text$mn:00009968                 public ?_Free_proxy@?$_Vector_alloc@$0A@U?$_Vec_base_types@_WV?$allocator@_W@std@@@std@@@std@@QAEXXZ
.text$mn:00009968 ?_Free_proxy@?$_Vector_alloc@$0A@U?$_Vec_base_types@_WV?$allocator@_W@std@@@std@@@std@@QAEXXZ proc near
.text$mn:00009968                                         ; CODE XREF: std::_Vector_alloc<0,std::_Vec_base_types<wchar_t,std::allocator<wchar_t>>>::~_Vector_alloc<0,std::_Vec_base_types<wchar_t,std::allocator<wchar_t>>>(void)+30p
.text$mn:00009968
.text$mn:00009968 var_8           = dword ptr -8
.text$mn:00009968 var_1           = byte ptr -1
.text$mn:00009968
.text$mn:00009968                 push    ebp
.text$mn:00009969                 mov     ebp, esp
.text$mn:0000996B                 sub     esp, 8
.text$mn:0000996E                 mov     [ebp+var_8], ecx
.text$mn:00009971                 lea     ecx, [ebp+var_1]
.text$mn:00009974                 call    ??0?$_Wrap_alloc@V?$allocator@U_Container_proxy@std@@@std@@@std@@QAE@XZ ; std::_Wrap_alloc<std::allocator<std::_Container_proxy>>::_Wrap_alloc<std::allocator<std::_Container_proxy>>(void)
.text$mn:00009979                 mov     ecx, [ebp+var_8] ; this
.text$mn:0000997C                 call    ?_Orphan_all@_Container_base12@std@@QAEXXZ ; std::_Container_base12::_Orphan_all(void)
.text$mn:00009981                 mov     eax, [ebp+var_8]
.text$mn:00009984                 mov     ecx, [eax]
.text$mn:00009986                 push    ecx
.text$mn:00009987                 lea     ecx, [ebp+var_1]
.text$mn:0000998A                 call    ??$destroy@U_Container_proxy@std@@@?$_Wrap_alloc@V?$allocator@U_Container_proxy@std@@@std@@@std@@QAEXPAU_Container_proxy@1@@Z ; std::_Wrap_alloc<std::allocator<std::_Container_proxy>>::destroy<std::_Container_proxy>(std::_Container_proxy *)
.text$mn:0000998F                 push    1               ; int
.text$mn:00009991                 mov     edx, [ebp+var_8]
.text$mn:00009994                 mov     eax, [edx]
.text$mn:00009996                 push    eax             ; void *
.text$mn:00009997                 lea     ecx, [ebp+var_1]
.text$mn:0000999A                 call    ?deallocate@?$_Wrap_alloc@V?$allocator@U_Container_proxy@std@@@std@@@std@@QAEXPAU_Container_proxy@2@I@Z ; std::_Wrap_alloc<std::allocator<std::_Container_proxy>>::deallocate(std::_Container_proxy *,uint)
.text$mn:0000999F                 mov     ecx, [ebp+var_8]
.text$mn:000099A2                 mov     dword ptr [ecx], 0
.text$mn:000099A8                 mov     esp, ebp
.text$mn:000099AA                 pop     ebp
.text$mn:000099AB                 retn
.text$mn:000099AB ?_Free_proxy@?$_Vector_alloc@$0A@U?$_Vec_base_types@_WV?$allocator@_W@std@@@std@@@std@@QAEXXZ endp
.text$mn:000099AB
.text$mn:000099AB _text$mn        ends
.text$mn:000099AB
.text$mn:000099AC ; ===========================================================================
.text$mn:000099AC
.text$mn:000099AC ; Segment type: Pure code
.text$mn:000099AC ; Segment permissions: Read/Execute
.text$mn:000099AC _text$mn        segment para public 'CODE' use32
.text$mn:000099AC                 assume cs:_text$mn
.text$mn:000099AC                 ;org 99ACh
.text$mn:000099AC ; COMDAT (pick any)
.text$mn:000099AC                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text$mn:000099AC
.text$mn:000099AC ; =============== S U B R O U T I N E =======================================
.text$mn:000099AC
.text$mn:000099AC ; Attributes: bp-based frame
.text$mn:000099AC
.text$mn:000099AC ; public: struct std::_Wrap_alloc<class std::allocator<char>> __thiscall std::_String_alloc<0, struct std::_String_base_types<char, class std::allocator<char>>>::_Getal(void)const
.text$mn:000099AC                 public ?_Getal@?$_String_alloc@$0A@U?$_String_base_types@DV?$allocator@D@std@@@std@@@std@@QBE?AU?$_Wrap_alloc@V?$allocator@D@std@@@2@XZ
.text$mn:000099AC ?_Getal@?$_String_alloc@$0A@U?$_String_base_types@DV?$allocator@D@std@@@std@@@std@@QBE?AU?$_Wrap_alloc@V?$allocator@D@std@@@2@XZ proc near
.text$mn:000099AC                                         ; CODE XREF: std::basic_string<char,std::char_traits<char>,std::allocator<char>>::basic_string<char,std::char_traits<char>,std::allocator<char>>(std::basic_string<char,std::char_traits<char>,std::allocator<char>> &&)+2Fp
.text$mn:000099AC                                         ; std::basic_string<char,std::char_traits<char>,std::allocator<char>>::_Assign_rv(std::basic_string<char,std::char_traits<char>,std::allocator<char>> &&)+49p ...
.text$mn:000099AC
.text$mn:000099AC var_4           = dword ptr -4
.text$mn:000099AC arg_0           = dword ptr  8
.text$mn:000099AC
.text$mn:000099AC                 push    ebp
.text$mn:000099AD                 mov     ebp, esp
.text$mn:000099AF                 push    ecx
.text$mn:000099B0                 mov     [ebp+var_4], ecx
.text$mn:000099B3                 mov     ecx, [ebp+arg_0]
.text$mn:000099B6                 call    ??0?$_Wrap_alloc@V?$allocator@D@std@@@std@@QAE@XZ ; std::_Wrap_alloc<std::allocator<char>>::_Wrap_alloc<std::allocator<char>>(void)
.text$mn:000099BB                 mov     eax, [ebp+arg_0]
.text$mn:000099BE                 mov     esp, ebp
.text$mn:000099C0                 pop     ebp
.text$mn:000099C1                 retn    4
.text$mn:000099C1 ?_Getal@?$_String_alloc@$0A@U?$_String_base_types@DV?$allocator@D@std@@@std@@@std@@QBE?AU?$_Wrap_alloc@V?$allocator@D@std@@@2@XZ endp
.text$mn:000099C1
.text$mn:000099C1 _text$mn        ends
.text$mn:000099C1
.text$mn:000099C4 ; ===========================================================================
.text$mn:000099C4
.text$mn:000099C4 ; Segment type: Pure code
.text$mn:000099C4 ; Segment permissions: Read/Execute
.text$mn:000099C4 _text$mn        segment para public 'CODE' use32
.text$mn:000099C4                 assume cs:_text$mn
.text$mn:000099C4                 ;org 99C4h
.text$mn:000099C4 ; COMDAT (pick any)
.text$mn:000099C4                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text$mn:000099C4
.text$mn:000099C4 ; =============== S U B R O U T I N E =======================================
.text$mn:000099C4
.text$mn:000099C4 ; Attributes: bp-based frame
.text$mn:000099C4
.text$mn:000099C4 ; public: struct std::_Wrap_alloc<class std::allocator<wchar_t>> __thiscall std::_String_alloc<0, struct std::_String_base_types<wchar_t, class std::allocator<wchar_t>>>::_Getal(void)const
.text$mn:000099C4                 public ?_Getal@?$_String_alloc@$0A@U?$_String_base_types@_WV?$allocator@_W@std@@@std@@@std@@QBE?AU?$_Wrap_alloc@V?$allocator@_W@std@@@2@XZ
.text$mn:000099C4 ?_Getal@?$_String_alloc@$0A@U?$_String_base_types@_WV?$allocator@_W@std@@@std@@@std@@QBE?AU?$_Wrap_alloc@V?$allocator@_W@std@@@2@XZ proc near
.text$mn:000099C4                                         ; CODE XREF: std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>>::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>>(std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>> &&)+2Fp
.text$mn:000099C4                                         ; std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>>::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>>(std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>> const &)+33p ...
.text$mn:000099C4
.text$mn:000099C4 var_4           = dword ptr -4
.text$mn:000099C4 arg_0           = dword ptr  8
.text$mn:000099C4
.text$mn:000099C4                 push    ebp
.text$mn:000099C5                 mov     ebp, esp
.text$mn:000099C7                 push    ecx
.text$mn:000099C8                 mov     [ebp+var_4], ecx
.text$mn:000099CB                 mov     ecx, [ebp+arg_0]
.text$mn:000099CE                 call    ??0?$_Wrap_alloc@V?$allocator@_W@std@@@std@@QAE@XZ ; std::_Wrap_alloc<std::allocator<wchar_t>>::_Wrap_alloc<std::allocator<wchar_t>>(void)
.text$mn:000099D3                 mov     eax, [ebp+arg_0]
.text$mn:000099D6                 mov     esp, ebp
.text$mn:000099D8                 pop     ebp
.text$mn:000099D9                 retn    4
.text$mn:000099D9 ?_Getal@?$_String_alloc@$0A@U?$_String_base_types@_WV?$allocator@_W@std@@@std@@@std@@QBE?AU?$_Wrap_alloc@V?$allocator@_W@std@@@2@XZ endp
.text$mn:000099D9
.text$mn:000099D9 _text$mn        ends
.text$mn:000099D9
.text$mn:000099DC ; ===========================================================================
.text$mn:000099DC
.text$mn:000099DC ; Segment type: Pure code
.text$mn:000099DC ; Segment permissions: Read/Execute
.text$mn:000099DC _text$mn        segment para public 'CODE' use32
.text$mn:000099DC                 assume cs:_text$mn
.text$mn:000099DC                 ;org 99DCh
.text$mn:000099DC ; COMDAT (pick any)
.text$mn:000099DC                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text$mn:000099DC
.text$mn:000099DC ; =============== S U B R O U T I N E =======================================
.text$mn:000099DC
.text$mn:000099DC ; Attributes: bp-based frame
.text$mn:000099DC
.text$mn:000099DC ; public: struct std::_Wrap_alloc<class std::allocator<char>> __thiscall std::_Vector_alloc<0, struct std::_Vec_base_types<char, class std::allocator<char>>>::_Getal(void)const
.text$mn:000099DC                 public ?_Getal@?$_Vector_alloc@$0A@U?$_Vec_base_types@DV?$allocator@D@std@@@std@@@std@@QBE?AU?$_Wrap_alloc@V?$allocator@D@std@@@2@XZ
.text$mn:000099DC ?_Getal@?$_Vector_alloc@$0A@U?$_Vec_base_types@DV?$allocator@D@std@@@std@@@std@@QBE?AU?$_Wrap_alloc@V?$allocator@D@std@@@2@XZ proc near
.text$mn:000099DC                                         ; CODE XREF: std::vector<char,std::allocator<char>>::vector<char,std::allocator<char>>(uint)+61p
.text$mn:000099DC                                         ; std::vector<char,std::allocator<char>>::_Buy(uint)+55p ...
.text$mn:000099DC
.text$mn:000099DC var_4           = dword ptr -4
.text$mn:000099DC arg_0           = dword ptr  8
.text$mn:000099DC
.text$mn:000099DC                 push    ebp
.text$mn:000099DD                 mov     ebp, esp
.text$mn:000099DF                 push    ecx
.text$mn:000099E0                 mov     [ebp+var_4], ecx
.text$mn:000099E3                 mov     ecx, [ebp+arg_0]
.text$mn:000099E6                 call    ??0?$_Wrap_alloc@V?$allocator@D@std@@@std@@QAE@XZ ; std::_Wrap_alloc<std::allocator<char>>::_Wrap_alloc<std::allocator<char>>(void)
.text$mn:000099EB                 mov     eax, [ebp+arg_0]
.text$mn:000099EE                 mov     esp, ebp
.text$mn:000099F0                 pop     ebp
.text$mn:000099F1                 retn    4
.text$mn:000099F1 ?_Getal@?$_Vector_alloc@$0A@U?$_Vec_base_types@DV?$allocator@D@std@@@std@@@std@@QBE?AU?$_Wrap_alloc@V?$allocator@D@std@@@2@XZ endp
.text$mn:000099F1
.text$mn:000099F1 _text$mn        ends
.text$mn:000099F1
.text$mn:000099F4 ; ===========================================================================
.text$mn:000099F4
.text$mn:000099F4 ; Segment type: Pure code
.text$mn:000099F4 ; Segment permissions: Read/Execute
.text$mn:000099F4 _text$mn        segment para public 'CODE' use32
.text$mn:000099F4                 assume cs:_text$mn
.text$mn:000099F4                 ;org 99F4h
.text$mn:000099F4 ; COMDAT (pick any)
.text$mn:000099F4                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text$mn:000099F4
.text$mn:000099F4 ; =============== S U B R O U T I N E =======================================
.text$mn:000099F4
.text$mn:000099F4 ; Attributes: bp-based frame
.text$mn:000099F4
.text$mn:000099F4 ; public: struct std::_Wrap_alloc<class std::allocator<class std::basic_string<wchar_t, struct std::char_traits<wchar_t>, class std::allocator<wchar_t>>>> __thiscall std::_Vector_alloc<0, struct std::_Vec_base_types<class std::basic_string<wchar_t, struct std::char_traits<wchar_t>, class std::allocator<wchar_t>>, class std::allocator<class std::basic_string<wchar_t, struct std::char_traits<wchar_t>, class std::allocator<wchar_t>>>>>::_Getal(void)const
.text$mn:000099F4                 public ?_Getal@?$_Vector_alloc@$0A@U?$_Vec_base_types@V?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@V?$allocator@V?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@@2@@std@@@std@@QBE?AU?$_Wrap_alloc@V?$allocator@V?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@@std@@@2@XZ
.text$mn:000099F4 ?_Getal@?$_Vector_alloc@$0A@U?$_Vec_base_types@V?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@V?$allocator@V?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@@2@@std@@@std@@QBE?AU?$_Wrap_alloc@V?$allocator@V?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@@std@@@2@XZ proc near
.text$mn:000099F4                                         ; CODE XREF: std::vector<std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>>,std::allocator<std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>>>>::_Umove<std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>> *>(std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>> *,std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>> *,std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>> *)+10p
.text$mn:000099F4                                         ; std::vector<std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>>,std::allocator<std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>>>>::vector<std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>>,std::allocator<std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>>>>(std::vector<std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>>,std::allocator<std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>>>> &&)+2Fp ...
.text$mn:000099F4
.text$mn:000099F4 var_4           = dword ptr -4
.text$mn:000099F4 arg_0           = dword ptr  8
.text$mn:000099F4
.text$mn:000099F4                 push    ebp
.text$mn:000099F5                 mov     ebp, esp
.text$mn:000099F7                 push    ecx
.text$mn:000099F8                 mov     [ebp+var_4], ecx
.text$mn:000099FB                 mov     ecx, [ebp+arg_0]
.text$mn:000099FE                 call    ??0?$_Wrap_alloc@V?$allocator@V?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@@std@@@std@@QAE@XZ ; std::_Wrap_alloc<std::allocator<std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>>>>::_Wrap_alloc<std::allocator<std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>>>>(void)
.text$mn:00009A03                 mov     eax, [ebp+arg_0]
.text$mn:00009A06                 mov     esp, ebp
.text$mn:00009A08                 pop     ebp
.text$mn:00009A09                 retn    4
.text$mn:00009A09 ?_Getal@?$_Vector_alloc@$0A@U?$_Vec_base_types@V?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@V?$allocator@V?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@@2@@std@@@std@@QBE?AU?$_Wrap_alloc@V?$allocator@V?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@@std@@@2@XZ endp
.text$mn:00009A09
.text$mn:00009A09 _text$mn        ends
.text$mn:00009A09
.text$mn:00009A0C ; ===========================================================================
.text$mn:00009A0C
.text$mn:00009A0C ; Segment type: Pure code
.text$mn:00009A0C ; Segment permissions: Read/Execute
.text$mn:00009A0C _text$mn        segment para public 'CODE' use32
.text$mn:00009A0C                 assume cs:_text$mn
.text$mn:00009A0C                 ;org 9A0Ch
.text$mn:00009A0C ; COMDAT (pick any)
.text$mn:00009A0C                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text$mn:00009A0C
.text$mn:00009A0C ; =============== S U B R O U T I N E =======================================
.text$mn:00009A0C
.text$mn:00009A0C ; Attributes: bp-based frame
.text$mn:00009A0C
.text$mn:00009A0C ; public: struct std::_Wrap_alloc<class std::allocator<wchar_t>> __thiscall std::_Vector_alloc<0, struct std::_Vec_base_types<wchar_t, class std::allocator<wchar_t>>>::_Getal(void)const
.text$mn:00009A0C                 public ?_Getal@?$_Vector_alloc@$0A@U?$_Vec_base_types@_WV?$allocator@_W@std@@@std@@@std@@QBE?AU?$_Wrap_alloc@V?$allocator@_W@std@@@2@XZ
.text$mn:00009A0C ?_Getal@?$_Vector_alloc@$0A@U?$_Vec_base_types@_WV?$allocator@_W@std@@@std@@@std@@QBE?AU?$_Wrap_alloc@V?$allocator@_W@std@@@2@XZ proc near
.text$mn:00009A0C                                         ; CODE XREF: std::vector<wchar_t,std::allocator<wchar_t>>::_Umove<wchar_t *>(wchar_t *,wchar_t *,wchar_t *)+10p
.text$mn:00009A0C                                         ; std::vector<wchar_t,std::allocator<wchar_t>>::vector<wchar_t,std::allocator<wchar_t>>(uint)+61p ...
.text$mn:00009A0C
.text$mn:00009A0C var_4           = dword ptr -4
.text$mn:00009A0C arg_0           = dword ptr  8
.text$mn:00009A0C
.text$mn:00009A0C                 push    ebp
.text$mn:00009A0D                 mov     ebp, esp
.text$mn:00009A0F                 push    ecx
.text$mn:00009A10                 mov     [ebp+var_4], ecx
.text$mn:00009A13                 mov     ecx, [ebp+arg_0]
.text$mn:00009A16                 call    ??0?$_Wrap_alloc@V?$allocator@_W@std@@@std@@QAE@XZ ; std::_Wrap_alloc<std::allocator<wchar_t>>::_Wrap_alloc<std::allocator<wchar_t>>(void)
.text$mn:00009A1B                 mov     eax, [ebp+arg_0]
.text$mn:00009A1E                 mov     esp, ebp
.text$mn:00009A20                 pop     ebp
.text$mn:00009A21                 retn    4
.text$mn:00009A21 ?_Getal@?$_Vector_alloc@$0A@U?$_Vec_base_types@_WV?$allocator@_W@std@@@std@@@std@@QBE?AU?$_Wrap_alloc@V?$allocator@_W@std@@@2@XZ endp
.text$mn:00009A21
.text$mn:00009A21 _text$mn        ends
.text$mn:00009A21
.text$mn:00009A24 ; ===========================================================================
.text$mn:00009A24
.text$mn:00009A24 ; Segment type: Pure code
.text$mn:00009A24 ; Segment permissions: Read/Execute
.text$mn:00009A24 _text$mn        segment para public 'CODE' use32
.text$mn:00009A24                 assume cs:_text$mn
.text$mn:00009A24                 ;org 9A24h
.text$mn:00009A24 ; COMDAT (pick any)
.text$mn:00009A24                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text$mn:00009A24
.text$mn:00009A24 ; =============== S U B R O U T I N E =======================================
.text$mn:00009A24
.text$mn:00009A24 ; Attributes: bp-based frame
.text$mn:00009A24
.text$mn:00009A24 ; const struct std::_Container_base12 *__thiscall std::_Iterator_base12::_Getcont(std::_Iterator_base12 *__hidden this)
.text$mn:00009A24                 public ?_Getcont@_Iterator_base12@std@@QBEPBU_Container_base12@2@XZ
.text$mn:00009A24 ?_Getcont@_Iterator_base12@std@@QBEPBU_Container_base12@2@XZ proc near
.text$mn:00009A24                                         ; CODE XREF: std::_String_const_iterator<std::_String_val<std::_Simple_types<wchar_t>>>::operator*(void)+Bp
.text$mn:00009A24                                         ; std::_String_const_iterator<std::_String_val<std::_Simple_types<wchar_t>>>::operator*(void)+20p ...
.text$mn:00009A24
.text$mn:00009A24 var_8           = dword ptr -8
.text$mn:00009A24 var_4           = dword ptr -4
.text$mn:00009A24
.text$mn:00009A24                 push    ebp
.text$mn:00009A25                 mov     ebp, esp
.text$mn:00009A27                 sub     esp, 8
.text$mn:00009A2A                 mov     [ebp+var_4], ecx
.text$mn:00009A2D                 mov     eax, [ebp+var_4]
.text$mn:00009A30                 cmp     dword ptr [eax], 0
.text$mn:00009A33                 jnz     short loc_9A3E
.text$mn:00009A35                 mov     [ebp+var_8], 0
.text$mn:00009A3C                 jmp     short loc_9A48
.text$mn:00009A3E ; ---------------------------------------------------------------------------
.text$mn:00009A3E
.text$mn:00009A3E loc_9A3E:                               ; CODE XREF: std::_Iterator_base12::_Getcont(void)+Fj
.text$mn:00009A3E                 mov     ecx, [ebp+var_4]
.text$mn:00009A41                 mov     edx, [ecx]
.text$mn:00009A43                 mov     eax, [edx]
.text$mn:00009A45                 mov     [ebp+var_8], eax
.text$mn:00009A48
.text$mn:00009A48 loc_9A48:                               ; CODE XREF: std::_Iterator_base12::_Getcont(void)+18j
.text$mn:00009A48                 mov     eax, [ebp+var_8]
.text$mn:00009A4B                 mov     esp, ebp
.text$mn:00009A4D                 pop     ebp
.text$mn:00009A4E                 retn
.text$mn:00009A4E ?_Getcont@_Iterator_base12@std@@QBEPBU_Container_base12@2@XZ endp
.text$mn:00009A4E
.text$mn:00009A4E ; ---------------------------------------------------------------------------
.text$mn:00009A4F                 align 10h
.text$mn:00009A4F _text$mn        ends
.text$mn:00009A4F
.text$mn:00009A50 ; ===========================================================================
.text$mn:00009A50
.text$mn:00009A50 ; Segment type: Pure code
.text$mn:00009A50 ; Segment permissions: Read/Execute
.text$mn:00009A50 _text$mn        segment para public 'CODE' use32
.text$mn:00009A50                 assume cs:_text$mn
.text$mn:00009A50                 ;org 9A50h
.text$mn:00009A50 ; COMDAT (pick any)
.text$mn:00009A50                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text$mn:00009A50
.text$mn:00009A50 ; =============== S U B R O U T I N E =======================================
.text$mn:00009A50
.text$mn:00009A50 ; Attributes: bp-based frame
.text$mn:00009A50
.text$mn:00009A50 ; struct std::_Iterator_base12 **__thiscall std::_Container_base12::_Getpfirst(std::_Container_base12 *__hidden this)
.text$mn:00009A50                 public ?_Getpfirst@_Container_base12@std@@QBEPAPAU_Iterator_base12@2@XZ
.text$mn:00009A50 ?_Getpfirst@_Container_base12@std@@QBEPAPAU_Iterator_base12@2@XZ proc near
.text$mn:00009A50                                         ; CODE XREF: std::vector<std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>>,std::allocator<std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>>>>::_Orphan_range(std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>> *,std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>> *)+3Cp
.text$mn:00009A50                                         ; std::vector<wchar_t,std::allocator<wchar_t>>::_Orphan_range(wchar_t *,wchar_t *)+3Cp
.text$mn:00009A50
.text$mn:00009A50 var_8           = dword ptr -8
.text$mn:00009A50 var_4           = dword ptr -4
.text$mn:00009A50
.text$mn:00009A50                 push    ebp
.text$mn:00009A51                 mov     ebp, esp
.text$mn:00009A53                 sub     esp, 8
.text$mn:00009A56                 mov     [ebp+var_4], ecx
.text$mn:00009A59                 mov     eax, [ebp+var_4]
.text$mn:00009A5C                 cmp     dword ptr [eax], 0
.text$mn:00009A5F                 jnz     short loc_9A6A
.text$mn:00009A61                 mov     [ebp+var_8], 0
.text$mn:00009A68                 jmp     short loc_9A75
.text$mn:00009A6A ; ---------------------------------------------------------------------------
.text$mn:00009A6A
.text$mn:00009A6A loc_9A6A:                               ; CODE XREF: std::_Container_base12::_Getpfirst(void)+Fj
.text$mn:00009A6A                 mov     ecx, [ebp+var_4]
.text$mn:00009A6D                 mov     edx, [ecx]
.text$mn:00009A6F                 add     edx, 4
.text$mn:00009A72                 mov     [ebp+var_8], edx
.text$mn:00009A75
.text$mn:00009A75 loc_9A75:                               ; CODE XREF: std::_Container_base12::_Getpfirst(void)+18j
.text$mn:00009A75                 mov     eax, [ebp+var_8]
.text$mn:00009A78                 mov     esp, ebp
.text$mn:00009A7A                 pop     ebp
.text$mn:00009A7B                 retn
.text$mn:00009A7B ?_Getpfirst@_Container_base12@std@@QBEPAPAU_Iterator_base12@2@XZ endp
.text$mn:00009A7B
.text$mn:00009A7B _text$mn        ends
.text$mn:00009A7B
.text$mn:00009A7C ; ===========================================================================
.text$mn:00009A7C
.text$mn:00009A7C ; Segment type: Pure code
.text$mn:00009A7C ; Segment permissions: Read/Execute
.text$mn:00009A7C _text$mn        segment para public 'CODE' use32
.text$mn:00009A7C                 assume cs:_text$mn
.text$mn:00009A7C                 ;org 9A7Ch
.text$mn:00009A7C ; COMDAT (pick any)
.text$mn:00009A7C                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text$mn:00009A7C
.text$mn:00009A7C ; =============== S U B R O U T I N E =======================================
.text$mn:00009A7C
.text$mn:00009A7C ; Attributes: bp-based frame
.text$mn:00009A7C
.text$mn:00009A7C ; struct std::_Iterator_base12 **__thiscall std::_Iterator_base12::_Getpnext(std::_Iterator_base12 *__hidden this)
.text$mn:00009A7C                 public ?_Getpnext@_Iterator_base12@std@@QAEPAPAU12@XZ
.text$mn:00009A7C ?_Getpnext@_Iterator_base12@std@@QAEPAPAU12@XZ proc near
.text$mn:00009A7C                                         ; CODE XREF: std::vector<std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>>,std::allocator<std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>>>>::_Orphan_range(std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>> *,std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>> *)+71p
.text$mn:00009A7C                                         ; std::vector<std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>>,std::allocator<std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>>>>::_Orphan_range(std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>> *,std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>> *)+8Ap ...
.text$mn:00009A7C
.text$mn:00009A7C var_4           = dword ptr -4
.text$mn:00009A7C
.text$mn:00009A7C                 push    ebp
.text$mn:00009A7D                 mov     ebp, esp
.text$mn:00009A7F                 push    ecx
.text$mn:00009A80                 mov     [ebp+var_4], ecx
.text$mn:00009A83                 mov     eax, [ebp+var_4]
.text$mn:00009A86                 add     eax, 4
.text$mn:00009A89                 mov     esp, ebp
.text$mn:00009A8B                 pop     ebp
.text$mn:00009A8C                 retn
.text$mn:00009A8C ?_Getpnext@_Iterator_base12@std@@QAEPAPAU12@XZ endp
.text$mn:00009A8C
.text$mn:00009A8C ; ---------------------------------------------------------------------------
.text$mn:00009A8D                 align 10h
.text$mn:00009A8D _text$mn        ends
.text$mn:00009A8D
.text$mn:00009A90 ; ===========================================================================
.text$mn:00009A90
.text$mn:00009A90 ; Segment type: Pure code
.text$mn:00009A90 ; Segment permissions: Read/Execute
.text$mn:00009A90 _text$mn        segment para public 'CODE' use32
.text$mn:00009A90                 assume cs:_text$mn
.text$mn:00009A90                 ;org 9A90h
.text$mn:00009A90 ; COMDAT (pick any)
.text$mn:00009A90                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text$mn:00009A90
.text$mn:00009A90 ; =============== S U B R O U T I N E =======================================
.text$mn:00009A90
.text$mn:00009A90 ; Attributes: bp-based frame
.text$mn:00009A90
.text$mn:00009A90 ; public: bool __thiscall std::basic_string<char, struct std::char_traits<char>, class std::allocator<char>>::_Grow(unsigned int, bool)
.text$mn:00009A90                 public ?_Grow@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE_NI_N@Z
.text$mn:00009A90 ?_Grow@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE_NI_N@Z proc near
.text$mn:00009A90                                         ; CODE XREF: std::basic_string<char,std::char_traits<char>,std::allocator<char>>::append(std::basic_string<char,std::char_traits<char>,std::allocator<char>> const &,uint,uint)+6Dp
.text$mn:00009A90                                         ; std::basic_string<char,std::char_traits<char>,std::allocator<char>>::append(char const *,uint)+8Cp ...
.text$mn:00009A90
.text$mn:00009A90 var_C           = dword ptr -0Ch
.text$mn:00009A90 Size            = dword ptr -8
.text$mn:00009A90 var_4           = dword ptr -4
.text$mn:00009A90 arg_0           = dword ptr  8
.text$mn:00009A90 arg_4           = byte ptr  0Ch
.text$mn:00009A90
.text$mn:00009A90                 push    ebp
.text$mn:00009A91                 mov     ebp, esp
.text$mn:00009A93                 sub     esp, 0Ch
.text$mn:00009A96                 mov     [ebp+var_4], ecx
.text$mn:00009A99                 mov     ecx, [ebp+var_4]
.text$mn:00009A9C                 call    ?max_size@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QBEIXZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char>>::max_size(void)
.text$mn:00009AA1                 cmp     eax, [ebp+arg_0]
.text$mn:00009AA4                 jnb     short loc_9AAE
.text$mn:00009AA6                 mov     ecx, [ebp+var_4]
.text$mn:00009AA9                 call    ?_Xlen@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QBEXXZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char>>::_Xlen(void)
.text$mn:00009AAE
.text$mn:00009AAE loc_9AAE:                               ; CODE XREF: std::basic_string<char,std::char_traits<char>,std::allocator<char>>::_Grow(uint,bool)+14j
.text$mn:00009AAE                 mov     eax, [ebp+var_4]
.text$mn:00009AB1                 mov     ecx, [eax+18h]
.text$mn:00009AB4                 cmp     ecx, [ebp+arg_0]
.text$mn:00009AB7                 jnb     short loc_9ACE
.text$mn:00009AB9                 mov     edx, [ebp+var_4]
.text$mn:00009ABC                 mov     eax, [edx+14h]
.text$mn:00009ABF                 push    eax
.text$mn:00009AC0                 mov     ecx, [ebp+arg_0]
.text$mn:00009AC3                 push    ecx
.text$mn:00009AC4                 mov     ecx, [ebp+var_4]
.text$mn:00009AC7                 call    ?_Copy@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEXII@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char>>::_Copy(uint,uint)
.text$mn:00009ACC                 jmp     short loc_9B18
.text$mn:00009ACE ; ---------------------------------------------------------------------------
.text$mn:00009ACE
.text$mn:00009ACE loc_9ACE:                               ; CODE XREF: std::basic_string<char,std::char_traits<char>,std::allocator<char>>::_Grow(uint,bool)+27j
.text$mn:00009ACE                 movzx   edx, [ebp+arg_4]
.text$mn:00009AD2                 test    edx, edx
.text$mn:00009AD4                 jz      short loc_9B08
.text$mn:00009AD6                 cmp     [ebp+arg_0], 10h
.text$mn:00009ADA                 jnb     short loc_9B08
.text$mn:00009ADC                 mov     eax, [ebp+var_4]
.text$mn:00009ADF                 mov     ecx, [ebp+arg_0]
.text$mn:00009AE2                 cmp     ecx, [eax+14h]
.text$mn:00009AE5                 jnb     short loc_9AEF
.text$mn:00009AE7                 mov     edx, [ebp+arg_0]
.text$mn:00009AEA                 mov     [ebp+Size], edx
.text$mn:00009AED                 jmp     short loc_9AF8
.text$mn:00009AEF ; ---------------------------------------------------------------------------
.text$mn:00009AEF
.text$mn:00009AEF loc_9AEF:                               ; CODE XREF: std::basic_string<char,std::char_traits<char>,std::allocator<char>>::_Grow(uint,bool)+55j
.text$mn:00009AEF                 mov     eax, [ebp+var_4]
.text$mn:00009AF2                 mov     ecx, [eax+14h]
.text$mn:00009AF5                 mov     [ebp+Size], ecx
.text$mn:00009AF8
.text$mn:00009AF8 loc_9AF8:                               ; CODE XREF: std::basic_string<char,std::char_traits<char>,std::allocator<char>>::_Grow(uint,bool)+5Dj
.text$mn:00009AF8                 mov     edx, [ebp+Size]
.text$mn:00009AFB                 push    edx             ; Size
.text$mn:00009AFC                 push    1               ; char
.text$mn:00009AFE                 mov     ecx, [ebp+var_4]
.text$mn:00009B01                 call    ?_Tidy@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEX_NI@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char>>::_Tidy(bool,uint)
.text$mn:00009B06                 jmp     short loc_9B18
.text$mn:00009B08 ; ---------------------------------------------------------------------------
.text$mn:00009B08
.text$mn:00009B08 loc_9B08:                               ; CODE XREF: std::basic_string<char,std::char_traits<char>,std::allocator<char>>::_Grow(uint,bool)+44j
.text$mn:00009B08                                         ; std::basic_string<char,std::char_traits<char>,std::allocator<char>>::_Grow(uint,bool)+4Aj
.text$mn:00009B08                 cmp     [ebp+arg_0], 0
.text$mn:00009B0C                 jnz     short loc_9B18
.text$mn:00009B0E                 push    0
.text$mn:00009B10                 mov     ecx, [ebp+var_4]
.text$mn:00009B13                 call    ?_Eos@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEXI@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char>>::_Eos(uint)
.text$mn:00009B18
.text$mn:00009B18 loc_9B18:                               ; CODE XREF: std::basic_string<char,std::char_traits<char>,std::allocator<char>>::_Grow(uint,bool)+3Cj
.text$mn:00009B18                                         ; std::basic_string<char,std::char_traits<char>,std::allocator<char>>::_Grow(uint,bool)+76j ...
.text$mn:00009B18                 cmp     [ebp+arg_0], 0
.text$mn:00009B1C                 jbe     short loc_9B27
.text$mn:00009B1E                 mov     [ebp+var_C], 1
.text$mn:00009B25                 jmp     short loc_9B2E
.text$mn:00009B27 ; ---------------------------------------------------------------------------
.text$mn:00009B27
.text$mn:00009B27 loc_9B27:                               ; CODE XREF: std::basic_string<char,std::char_traits<char>,std::allocator<char>>::_Grow(uint,bool)+8Cj
.text$mn:00009B27                 mov     [ebp+var_C], 0
.text$mn:00009B2E
.text$mn:00009B2E loc_9B2E:                               ; CODE XREF: std::basic_string<char,std::char_traits<char>,std::allocator<char>>::_Grow(uint,bool)+95j
.text$mn:00009B2E                 mov     al, byte ptr [ebp+var_C]
.text$mn:00009B31                 mov     esp, ebp
.text$mn:00009B33                 pop     ebp
.text$mn:00009B34                 retn    8
.text$mn:00009B34 ?_Grow@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE_NI_N@Z endp
.text$mn:00009B34
.text$mn:00009B34 ; ---------------------------------------------------------------------------
.text$mn:00009B37                 align 4
.text$mn:00009B37 _text$mn        ends
.text$mn:00009B37
.text$mn:00009B38 ; ===========================================================================
.text$mn:00009B38
.text$mn:00009B38 ; Segment type: Pure code
.text$mn:00009B38 ; Segment permissions: Read/Execute
.text$mn:00009B38 _text$mn        segment para public 'CODE' use32
.text$mn:00009B38                 assume cs:_text$mn
.text$mn:00009B38                 ;org 9B38h
.text$mn:00009B38 ; COMDAT (pick any)
.text$mn:00009B38                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text$mn:00009B38
.text$mn:00009B38 ; =============== S U B R O U T I N E =======================================
.text$mn:00009B38
.text$mn:00009B38 ; Attributes: bp-based frame
.text$mn:00009B38
.text$mn:00009B38 ; public: bool __thiscall std::basic_string<wchar_t, struct std::char_traits<wchar_t>, class std::allocator<wchar_t>>::_Grow(unsigned int, bool)
.text$mn:00009B38                 public ?_Grow@?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QAE_NI_N@Z
.text$mn:00009B38 ?_Grow@?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QAE_NI_N@Z proc near
.text$mn:00009B38                                         ; CODE XREF: std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>>::append(std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>> const &,uint,uint)+6Dp
.text$mn:00009B38                                         ; std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>>::append(uint,wchar_t)+3Dp ...
.text$mn:00009B38
.text$mn:00009B38 var_C           = dword ptr -0Ch
.text$mn:00009B38 var_8           = dword ptr -8
.text$mn:00009B38 var_4           = dword ptr -4
.text$mn:00009B38 arg_0           = dword ptr  8
.text$mn:00009B38 arg_4           = byte ptr  0Ch
.text$mn:00009B38
.text$mn:00009B38                 push    ebp
.text$mn:00009B39                 mov     ebp, esp
.text$mn:00009B3B                 sub     esp, 0Ch
.text$mn:00009B3E                 mov     [ebp+var_4], ecx
.text$mn:00009B41                 mov     ecx, [ebp+var_4]
.text$mn:00009B44                 call    ?max_size@?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QBEIXZ ; std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>>::max_size(void)
.text$mn:00009B49                 cmp     eax, [ebp+arg_0]
.text$mn:00009B4C                 jnb     short loc_9B56
.text$mn:00009B4E                 mov     ecx, [ebp+var_4]
.text$mn:00009B51                 call    ?_Xlen@?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QBEXXZ ; std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>>::_Xlen(void)
.text$mn:00009B56
.text$mn:00009B56 loc_9B56:                               ; CODE XREF: std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>>::_Grow(uint,bool)+14j
.text$mn:00009B56                 mov     eax, [ebp+var_4]
.text$mn:00009B59                 mov     ecx, [eax+18h]
.text$mn:00009B5C                 cmp     ecx, [ebp+arg_0]
.text$mn:00009B5F                 jnb     short loc_9B76
.text$mn:00009B61                 mov     edx, [ebp+var_4]
.text$mn:00009B64                 mov     eax, [edx+14h]
.text$mn:00009B67                 push    eax
.text$mn:00009B68                 mov     ecx, [ebp+arg_0]
.text$mn:00009B6B                 push    ecx
.text$mn:00009B6C                 mov     ecx, [ebp+var_4]
.text$mn:00009B6F                 call    ?_Copy@?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QAEXII@Z ; std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>>::_Copy(uint,uint)
.text$mn:00009B74                 jmp     short loc_9BC0
.text$mn:00009B76 ; ---------------------------------------------------------------------------
.text$mn:00009B76
.text$mn:00009B76 loc_9B76:                               ; CODE XREF: std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>>::_Grow(uint,bool)+27j
.text$mn:00009B76                 movzx   edx, [ebp+arg_4]
.text$mn:00009B7A                 test    edx, edx
.text$mn:00009B7C                 jz      short loc_9BB0
.text$mn:00009B7E                 cmp     [ebp+arg_0], 8
.text$mn:00009B82                 jnb     short loc_9BB0
.text$mn:00009B84                 mov     eax, [ebp+var_4]
.text$mn:00009B87                 mov     ecx, [ebp+arg_0]
.text$mn:00009B8A                 cmp     ecx, [eax+14h]
.text$mn:00009B8D                 jnb     short loc_9B97
.text$mn:00009B8F                 mov     edx, [ebp+arg_0]
.text$mn:00009B92                 mov     [ebp+var_8], edx
.text$mn:00009B95                 jmp     short loc_9BA0
.text$mn:00009B97 ; ---------------------------------------------------------------------------
.text$mn:00009B97
.text$mn:00009B97 loc_9B97:                               ; CODE XREF: std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>>::_Grow(uint,bool)+55j
.text$mn:00009B97                 mov     eax, [ebp+var_4]
.text$mn:00009B9A                 mov     ecx, [eax+14h]
.text$mn:00009B9D                 mov     [ebp+var_8], ecx
.text$mn:00009BA0
.text$mn:00009BA0 loc_9BA0:                               ; CODE XREF: std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>>::_Grow(uint,bool)+5Dj
.text$mn:00009BA0                 mov     edx, [ebp+var_8]
.text$mn:00009BA3                 push    edx
.text$mn:00009BA4                 push    1
.text$mn:00009BA6                 mov     ecx, [ebp+var_4]
.text$mn:00009BA9                 call    ?_Tidy@?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QAEX_NI@Z ; std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>>::_Tidy(bool,uint)
.text$mn:00009BAE                 jmp     short loc_9BC0
.text$mn:00009BB0 ; ---------------------------------------------------------------------------
.text$mn:00009BB0
.text$mn:00009BB0 loc_9BB0:                               ; CODE XREF: std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>>::_Grow(uint,bool)+44j
.text$mn:00009BB0                                         ; std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>>::_Grow(uint,bool)+4Aj
.text$mn:00009BB0                 cmp     [ebp+arg_0], 0
.text$mn:00009BB4                 jnz     short loc_9BC0
.text$mn:00009BB6                 push    0
.text$mn:00009BB8                 mov     ecx, [ebp+var_4]
.text$mn:00009BBB                 call    ?_Eos@?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QAEXI@Z ; std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>>::_Eos(uint)
.text$mn:00009BC0
.text$mn:00009BC0 loc_9BC0:                               ; CODE XREF: std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>>::_Grow(uint,bool)+3Cj
.text$mn:00009BC0                                         ; std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>>::_Grow(uint,bool)+76j ...
.text$mn:00009BC0                 cmp     [ebp+arg_0], 0
.text$mn:00009BC4                 jbe     short loc_9BCF
.text$mn:00009BC6                 mov     [ebp+var_C], 1
.text$mn:00009BCD                 jmp     short loc_9BD6
.text$mn:00009BCF ; ---------------------------------------------------------------------------
.text$mn:00009BCF
.text$mn:00009BCF loc_9BCF:                               ; CODE XREF: std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>>::_Grow(uint,bool)+8Cj
.text$mn:00009BCF                 mov     [ebp+var_C], 0
.text$mn:00009BD6
.text$mn:00009BD6 loc_9BD6:                               ; CODE XREF: std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>>::_Grow(uint,bool)+95j
.text$mn:00009BD6                 mov     al, byte ptr [ebp+var_C]
.text$mn:00009BD9                 mov     esp, ebp
.text$mn:00009BDB                 pop     ebp
.text$mn:00009BDC                 retn    8
.text$mn:00009BDC ?_Grow@?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QAE_NI_N@Z endp
.text$mn:00009BDC
.text$mn:00009BDC ; ---------------------------------------------------------------------------
.text$mn:00009BDF                 align 10h
.text$mn:00009BDF _text$mn        ends
.text$mn:00009BDF
.text$mn:00009BE0 ; ===========================================================================
.text$mn:00009BE0
.text$mn:00009BE0 ; Segment type: Pure code
.text$mn:00009BE0 ; Segment permissions: Read/Execute
.text$mn:00009BE0 _text$mn        segment para public 'CODE' use32
.text$mn:00009BE0                 assume cs:_text$mn
.text$mn:00009BE0                 ;org 9BE0h
.text$mn:00009BE0 ; COMDAT (pick any)
.text$mn:00009BE0                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text$mn:00009BE0
.text$mn:00009BE0 ; =============== S U B R O U T I N E =======================================
.text$mn:00009BE0
.text$mn:00009BE0 ; Attributes: bp-based frame
.text$mn:00009BE0
.text$mn:00009BE0 ; protected: unsigned int __thiscall std::vector<class std::basic_string<wchar_t, struct std::char_traits<wchar_t>, class std::allocator<wchar_t>>, class std::allocator<class std::basic_string<wchar_t, struct std::char_traits<wchar_t>, class std::allocator<wchar_t>>>>::_Grow_to(unsigned int)const
.text$mn:00009BE0                 public ?_Grow_to@?$vector@V?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@V?$allocator@V?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@@2@@std@@IBEII@Z
.text$mn:00009BE0 ?_Grow_to@?$vector@V?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@V?$allocator@V?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@@2@@std@@IBEII@Z proc near
.text$mn:00009BE0                                         ; CODE XREF: std::vector<std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>>,std::allocator<std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>>>>::_Reserve(uint)+45p
.text$mn:00009BE0
.text$mn:00009BE0 var_C           = dword ptr -0Ch
.text$mn:00009BE0 var_8           = dword ptr -8
.text$mn:00009BE0 var_4           = dword ptr -4
.text$mn:00009BE0 arg_0           = dword ptr  8
.text$mn:00009BE0
.text$mn:00009BE0                 push    ebp
.text$mn:00009BE1                 mov     ebp, esp
.text$mn:00009BE3                 sub     esp, 0Ch
.text$mn:00009BE6                 mov     [ebp+var_8], ecx
.text$mn:00009BE9                 mov     ecx, [ebp+var_8]
.text$mn:00009BEC                 call    ?capacity@?$vector@V?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@V?$allocator@V?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@@2@@std@@QBEIXZ ; std::vector<std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>>,std::allocator<std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>>>>::capacity(void)
.text$mn:00009BF1                 mov     [ebp+var_4], eax
.text$mn:00009BF4                 mov     ecx, [ebp+var_8]
.text$mn:00009BF7                 call    ?max_size@?$vector@V?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@V?$allocator@V?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@@2@@std@@QBEIXZ ; std::vector<std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>>,std::allocator<std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>>>>::max_size(void)
.text$mn:00009BFC                 mov     ecx, [ebp+var_4]
.text$mn:00009BFF                 shr     ecx, 1
.text$mn:00009C01                 sub     eax, ecx
.text$mn:00009C03                 cmp     eax, [ebp+var_4]
.text$mn:00009C06                 jnb     short loc_9C11
.text$mn:00009C08                 mov     [ebp+var_C], 0
.text$mn:00009C0F                 jmp     short loc_9C1C
.text$mn:00009C11 ; ---------------------------------------------------------------------------
.text$mn:00009C11
.text$mn:00009C11 loc_9C11:                               ; CODE XREF: std::vector<std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>>,std::allocator<std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>>>>::_Grow_to(uint)+26j
.text$mn:00009C11                 mov     edx, [ebp+var_4]
.text$mn:00009C14                 shr     edx, 1
.text$mn:00009C16                 add     edx, [ebp+var_4]
.text$mn:00009C19                 mov     [ebp+var_C], edx
.text$mn:00009C1C
.text$mn:00009C1C loc_9C1C:                               ; CODE XREF: std::vector<std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>>,std::allocator<std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>>>>::_Grow_to(uint)+2Fj
.text$mn:00009C1C                 mov     eax, [ebp+var_C]
.text$mn:00009C1F                 mov     [ebp+var_4], eax
.text$mn:00009C22                 mov     ecx, [ebp+var_4]
.text$mn:00009C25                 cmp     ecx, [ebp+arg_0]
.text$mn:00009C28                 jnb     short loc_9C30
.text$mn:00009C2A                 mov     edx, [ebp+arg_0]
.text$mn:00009C2D                 mov     [ebp+var_4], edx
.text$mn:00009C30
.text$mn:00009C30 loc_9C30:                               ; CODE XREF: std::vector<std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>>,std::allocator<std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>>>>::_Grow_to(uint)+48j
.text$mn:00009C30                 mov     eax, [ebp+var_4]
.text$mn:00009C33                 mov     esp, ebp
.text$mn:00009C35                 pop     ebp
.text$mn:00009C36                 retn    4
.text$mn:00009C36 ?_Grow_to@?$vector@V?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@V?$allocator@V?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@@2@@std@@IBEII@Z endp
.text$mn:00009C36
.text$mn:00009C36 ; ---------------------------------------------------------------------------
.text$mn:00009C39                 align 4
.text$mn:00009C39 _text$mn        ends
.text$mn:00009C39
.text$mn:00009C3C ; ===========================================================================
.text$mn:00009C3C
.text$mn:00009C3C ; Segment type: Pure code
.text$mn:00009C3C ; Segment permissions: Read/Execute
.text$mn:00009C3C _text$mn        segment para public 'CODE' use32
.text$mn:00009C3C                 assume cs:_text$mn
.text$mn:00009C3C                 ;org 9C3Ch
.text$mn:00009C3C ; COMDAT (pick any)
.text$mn:00009C3C                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text$mn:00009C3C
.text$mn:00009C3C ; =============== S U B R O U T I N E =======================================
.text$mn:00009C3C
.text$mn:00009C3C ; Attributes: bp-based frame
.text$mn:00009C3C
.text$mn:00009C3C ; protected: unsigned int __thiscall std::vector<wchar_t, class std::allocator<wchar_t>>::_Grow_to(unsigned int)const
.text$mn:00009C3C                 public ?_Grow_to@?$vector@_WV?$allocator@_W@std@@@std@@IBEII@Z
.text$mn:00009C3C ?_Grow_to@?$vector@_WV?$allocator@_W@std@@@std@@IBEII@Z proc near
.text$mn:00009C3C                                         ; CODE XREF: std::vector<wchar_t,std::allocator<wchar_t>>::_Reserve(uint)+45p
.text$mn:00009C3C
.text$mn:00009C3C var_C           = dword ptr -0Ch
.text$mn:00009C3C var_8           = dword ptr -8
.text$mn:00009C3C var_4           = dword ptr -4
.text$mn:00009C3C arg_0           = dword ptr  8
.text$mn:00009C3C
.text$mn:00009C3C                 push    ebp
.text$mn:00009C3D                 mov     ebp, esp
.text$mn:00009C3F                 sub     esp, 0Ch
.text$mn:00009C42                 mov     [ebp+var_8], ecx
.text$mn:00009C45                 mov     ecx, [ebp+var_8]
.text$mn:00009C48                 call    ?capacity@?$vector@_WV?$allocator@_W@std@@@std@@QBEIXZ ; std::vector<wchar_t,std::allocator<wchar_t>>::capacity(void)
.text$mn:00009C4D                 mov     [ebp+var_4], eax
.text$mn:00009C50                 mov     ecx, [ebp+var_8]
.text$mn:00009C53                 call    ?max_size@?$vector@_WV?$allocator@_W@std@@@std@@QBEIXZ ; std::vector<wchar_t,std::allocator<wchar_t>>::max_size(void)
.text$mn:00009C58                 mov     ecx, [ebp+var_4]
.text$mn:00009C5B                 shr     ecx, 1
.text$mn:00009C5D                 sub     eax, ecx
.text$mn:00009C5F                 cmp     eax, [ebp+var_4]
.text$mn:00009C62                 jnb     short loc_9C6D
.text$mn:00009C64                 mov     [ebp+var_C], 0
.text$mn:00009C6B                 jmp     short loc_9C78
.text$mn:00009C6D ; ---------------------------------------------------------------------------
.text$mn:00009C6D
.text$mn:00009C6D loc_9C6D:                               ; CODE XREF: std::vector<wchar_t,std::allocator<wchar_t>>::_Grow_to(uint)+26j
.text$mn:00009C6D                 mov     edx, [ebp+var_4]
.text$mn:00009C70                 shr     edx, 1
.text$mn:00009C72                 add     edx, [ebp+var_4]
.text$mn:00009C75                 mov     [ebp+var_C], edx
.text$mn:00009C78
.text$mn:00009C78 loc_9C78:                               ; CODE XREF: std::vector<wchar_t,std::allocator<wchar_t>>::_Grow_to(uint)+2Fj
.text$mn:00009C78                 mov     eax, [ebp+var_C]
.text$mn:00009C7B                 mov     [ebp+var_4], eax
.text$mn:00009C7E                 mov     ecx, [ebp+var_4]
.text$mn:00009C81                 cmp     ecx, [ebp+arg_0]
.text$mn:00009C84                 jnb     short loc_9C8C
.text$mn:00009C86                 mov     edx, [ebp+arg_0]
.text$mn:00009C89                 mov     [ebp+var_4], edx
.text$mn:00009C8C
.text$mn:00009C8C loc_9C8C:                               ; CODE XREF: std::vector<wchar_t,std::allocator<wchar_t>>::_Grow_to(uint)+48j
.text$mn:00009C8C                 mov     eax, [ebp+var_4]
.text$mn:00009C8F                 mov     esp, ebp
.text$mn:00009C91                 pop     ebp
.text$mn:00009C92                 retn    4
.text$mn:00009C92 ?_Grow_to@?$vector@_WV?$allocator@_W@std@@@std@@IBEII@Z endp
.text$mn:00009C92
.text$mn:00009C92 ; ---------------------------------------------------------------------------
.text$mn:00009C95                 align 4
.text$mn:00009C95 _text$mn        ends
.text$mn:00009C95
.text$mn:00009C98 ; ===========================================================================
.text$mn:00009C98
.text$mn:00009C98 ; Segment type: Pure code
.text$mn:00009C98 ; Segment permissions: Read/Execute
.text$mn:00009C98 _text$mn        segment para public 'CODE' use32
.text$mn:00009C98                 assume cs:_text$mn
.text$mn:00009C98                 ;org 9C98h
.text$mn:00009C98 ; COMDAT (pick any)
.text$mn:00009C98                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text$mn:00009C98
.text$mn:00009C98 ; =============== S U B R O U T I N E =======================================
.text$mn:00009C98
.text$mn:00009C98 ; Attributes: bp-based frame
.text$mn:00009C98
.text$mn:00009C98 ; public: bool __thiscall std::basic_string<char, struct std::char_traits<char>, class std::allocator<char>>::_Inside(char const *)
.text$mn:00009C98                 public ?_Inside@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE_NPBD@Z
.text$mn:00009C98 ?_Inside@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE_NPBD@Z proc near
.text$mn:00009C98                                         ; CODE XREF: std::basic_string<char,std::char_traits<char>,std::allocator<char>>::append(char const *,uint)+2Cp
.text$mn:00009C98                                         ; std::basic_string<char,std::char_traits<char>,std::allocator<char>>::assign(char const *,uint)+2Ap
.text$mn:00009C98
.text$mn:00009C98 var_4           = dword ptr -4
.text$mn:00009C98 arg_0           = dword ptr  8
.text$mn:00009C98
.text$mn:00009C98                 push    ebp
.text$mn:00009C99                 mov     ebp, esp
.text$mn:00009C9B                 push    ecx
.text$mn:00009C9C                 mov     [ebp+var_4], ecx
.text$mn:00009C9F                 cmp     [ebp+arg_0], 0
.text$mn:00009CA3                 jz      short loc_9CC5
.text$mn:00009CA5                 mov     ecx, [ebp+var_4]
.text$mn:00009CA8                 call    ?_Myptr@?$_String_val@U?$_Simple_types@D@std@@@std@@QAEPADXZ ; std::_String_val<std::_Simple_types<char>>::_Myptr(void)
.text$mn:00009CAD                 cmp     [ebp+arg_0], eax
.text$mn:00009CB0                 jb      short loc_9CC5
.text$mn:00009CB2                 mov     ecx, [ebp+var_4]
.text$mn:00009CB5                 call    ?_Myptr@?$_String_val@U?$_Simple_types@D@std@@@std@@QAEPADXZ ; std::_String_val<std::_Simple_types<char>>::_Myptr(void)
.text$mn:00009CBA                 mov     ecx, [ebp+var_4]
.text$mn:00009CBD                 add     eax, [ecx+14h]
.text$mn:00009CC0                 cmp     eax, [ebp+arg_0]
.text$mn:00009CC3                 ja      short loc_9CCB
.text$mn:00009CC5
.text$mn:00009CC5 loc_9CC5:                               ; CODE XREF: std::basic_string<char,std::char_traits<char>,std::allocator<char>>::_Inside(char const *)+Bj
.text$mn:00009CC5                                         ; std::basic_string<char,std::char_traits<char>,std::allocator<char>>::_Inside(char const *)+18j
.text$mn:00009CC5                 xor     al, al
.text$mn:00009CC7                 jmp     short loc_9CCD
.text$mn:00009CC9 ; ---------------------------------------------------------------------------
.text$mn:00009CC9                 jmp     short loc_9CCD
.text$mn:00009CCB ; ---------------------------------------------------------------------------
.text$mn:00009CCB
.text$mn:00009CCB loc_9CCB:                               ; CODE XREF: std::basic_string<char,std::char_traits<char>,std::allocator<char>>::_Inside(char const *)+2Bj
.text$mn:00009CCB                 mov     al, 1
.text$mn:00009CCD
.text$mn:00009CCD loc_9CCD:                               ; CODE XREF: std::basic_string<char,std::char_traits<char>,std::allocator<char>>::_Inside(char const *)+2Fj
.text$mn:00009CCD                                         ; std::basic_string<char,std::char_traits<char>,std::allocator<char>>::_Inside(char const *)+31j
.text$mn:00009CCD                 mov     esp, ebp
.text$mn:00009CCF                 pop     ebp
.text$mn:00009CD0                 retn    4
.text$mn:00009CD0 ?_Inside@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE_NPBD@Z endp
.text$mn:00009CD0
.text$mn:00009CD0 ; ---------------------------------------------------------------------------
.text$mn:00009CD3                 align 4
.text$mn:00009CD3 _text$mn        ends
.text$mn:00009CD3
.text$mn:00009CD4 ; ===========================================================================
.text$mn:00009CD4
.text$mn:00009CD4 ; Segment type: Pure code
.text$mn:00009CD4 ; Segment permissions: Read/Execute
.text$mn:00009CD4 _text$mn        segment para public 'CODE' use32
.text$mn:00009CD4                 assume cs:_text$mn
.text$mn:00009CD4                 ;org 9CD4h
.text$mn:00009CD4 ; COMDAT (pick any)
.text$mn:00009CD4                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text$mn:00009CD4
.text$mn:00009CD4 ; =============== S U B R O U T I N E =======================================
.text$mn:00009CD4
.text$mn:00009CD4 ; Attributes: bp-based frame
.text$mn:00009CD4
.text$mn:00009CD4 ; public: bool __thiscall std::basic_string<wchar_t, struct std::char_traits<wchar_t>, class std::allocator<wchar_t>>::_Inside(wchar_t const *)
.text$mn:00009CD4                 public ?_Inside@?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QAE_NPB_W@Z
.text$mn:00009CD4 ?_Inside@?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QAE_NPB_W@Z proc near
.text$mn:00009CD4                                         ; CODE XREF: std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>>::append(wchar_t const *,uint)+2Cp
.text$mn:00009CD4                                         ; std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>>::assign(wchar_t const *,uint)+2Ap
.text$mn:00009CD4
.text$mn:00009CD4 var_4           = dword ptr -4
.text$mn:00009CD4 arg_0           = dword ptr  8
.text$mn:00009CD4
.text$mn:00009CD4                 push    ebp
.text$mn:00009CD5                 mov     ebp, esp
.text$mn:00009CD7                 push    ecx
.text$mn:00009CD8                 mov     [ebp+var_4], ecx
.text$mn:00009CDB                 cmp     [ebp+arg_0], 0
.text$mn:00009CDF                 jz      short loc_9D04
.text$mn:00009CE1                 mov     ecx, [ebp+var_4]
.text$mn:00009CE4                 call    ?_Myptr@?$_String_val@U?$_Simple_types@_W@std@@@std@@QAEPA_WXZ ; std::_String_val<std::_Simple_types<wchar_t>>::_Myptr(void)
.text$mn:00009CE9                 cmp     [ebp+arg_0], eax
.text$mn:00009CEC                 jb      short loc_9D04
.text$mn:00009CEE                 mov     ecx, [ebp+var_4]
.text$mn:00009CF1                 call    ?_Myptr@?$_String_val@U?$_Simple_types@_W@std@@@std@@QAEPA_WXZ ; std::_String_val<std::_Simple_types<wchar_t>>::_Myptr(void)
.text$mn:00009CF6                 mov     ecx, [ebp+var_4]
.text$mn:00009CF9                 mov     edx, [ecx+14h]
.text$mn:00009CFC                 lea     eax, [eax+edx*2]
.text$mn:00009CFF                 cmp     eax, [ebp+arg_0]
.text$mn:00009D02                 ja      short loc_9D0A
.text$mn:00009D04
.text$mn:00009D04 loc_9D04:                               ; CODE XREF: std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>>::_Inside(wchar_t const *)+Bj
.text$mn:00009D04                                         ; std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>>::_Inside(wchar_t const *)+18j
.text$mn:00009D04                 xor     al, al
.text$mn:00009D06                 jmp     short loc_9D0C
.text$mn:00009D08 ; ---------------------------------------------------------------------------
.text$mn:00009D08                 jmp     short loc_9D0C
.text$mn:00009D0A ; ---------------------------------------------------------------------------
.text$mn:00009D0A
.text$mn:00009D0A loc_9D0A:                               ; CODE XREF: std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>>::_Inside(wchar_t const *)+2Ej
.text$mn:00009D0A                 mov     al, 1
.text$mn:00009D0C
.text$mn:00009D0C loc_9D0C:                               ; CODE XREF: std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>>::_Inside(wchar_t const *)+32j
.text$mn:00009D0C                                         ; std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>>::_Inside(wchar_t const *)+34j
.text$mn:00009D0C                 mov     esp, ebp
.text$mn:00009D0E                 pop     ebp
.text$mn:00009D0F                 retn    4
.text$mn:00009D0F ?_Inside@?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QAE_NPB_W@Z endp
.text$mn:00009D0F
.text$mn:00009D0F ; ---------------------------------------------------------------------------
.text$mn:00009D12                 align 4
.text$mn:00009D12 _text$mn        ends
.text$mn:00009D12
.text$mn:00009D14 ; ===========================================================================
.text$mn:00009D14
.text$mn:00009D14 ; Segment type: Pure code
.text$mn:00009D14 ; Segment permissions: Read/Execute
.text$mn:00009D14 _text$mn        segment para public 'CODE' use32
.text$mn:00009D14                 assume cs:_text$mn
.text$mn:00009D14                 ;org 9D14h
.text$mn:00009D14 ; COMDAT (pick any)
.text$mn:00009D14                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text$mn:00009D14
.text$mn:00009D14 ; =============== S U B R O U T I N E =======================================
.text$mn:00009D14
.text$mn:00009D14 ; Attributes: bp-based frame
.text$mn:00009D14
.text$mn:00009D14 ; protected: bool __thiscall std::vector<class std::basic_string<wchar_t, struct std::char_traits<wchar_t>, class std::allocator<wchar_t>>, class std::allocator<class std::basic_string<wchar_t, struct std::char_traits<wchar_t>, class std::allocator<wchar_t>>>>::_Inside(class std::basic_string<wchar_t, struct std::char_traits<wchar_t>, class std::allocator<wchar_t>> const *)const
.text$mn:00009D14                 public ?_Inside@?$vector@V?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@V?$allocator@V?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@@2@@std@@IBE_NPBV?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@2@@Z
.text$mn:00009D14 ?_Inside@?$vector@V?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@V?$allocator@V?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@@2@@std@@IBE_NPBV?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@2@@Z proc near
.text$mn:00009D14                                         ; CODE XREF: std::vector<std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>>,std::allocator<std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>>>>::push_back(std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>> &&)+19p
.text$mn:00009D14
.text$mn:00009D14 var_8           = dword ptr -8
.text$mn:00009D14 var_4           = dword ptr -4
.text$mn:00009D14 arg_0           = dword ptr  8
.text$mn:00009D14
.text$mn:00009D14                 push    ebp
.text$mn:00009D15                 mov     ebp, esp
.text$mn:00009D17                 sub     esp, 8
.text$mn:00009D1A                 mov     [ebp+var_4], ecx
.text$mn:00009D1D                 mov     eax, [ebp+var_4]
.text$mn:00009D20                 mov     ecx, [ebp+arg_0]
.text$mn:00009D23                 cmp     ecx, [eax+8]
.text$mn:00009D26                 jnb     short loc_9D3C
.text$mn:00009D28                 mov     edx, [ebp+var_4]
.text$mn:00009D2B                 mov     eax, [edx+4]
.text$mn:00009D2E                 cmp     eax, [ebp+arg_0]
.text$mn:00009D31                 ja      short loc_9D3C
.text$mn:00009D33                 mov     [ebp+var_8], 1
.text$mn:00009D3A                 jmp     short loc_9D43
.text$mn:00009D3C ; ---------------------------------------------------------------------------
.text$mn:00009D3C
.text$mn:00009D3C loc_9D3C:                               ; CODE XREF: std::vector<std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>>,std::allocator<std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>>>>::_Inside(std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>> const *)+12j
.text$mn:00009D3C                                         ; std::vector<std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>>,std::allocator<std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>>>>::_Inside(std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>> const *)+1Dj
.text$mn:00009D3C                 mov     [ebp+var_8], 0
.text$mn:00009D43
.text$mn:00009D43 loc_9D43:                               ; CODE XREF: std::vector<std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>>,std::allocator<std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>>>>::_Inside(std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>> const *)+26j
.text$mn:00009D43                 mov     al, byte ptr [ebp+var_8]
.text$mn:00009D46                 mov     esp, ebp
.text$mn:00009D48                 pop     ebp
.text$mn:00009D49                 retn    4
.text$mn:00009D49 ?_Inside@?$vector@V?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@V?$allocator@V?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@@2@@std@@IBE_NPBV?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@2@@Z endp
.text$mn:00009D49
.text$mn:00009D49 _text$mn        ends
.text$mn:00009D49
.text$mn:00009D4C ; ===========================================================================
.text$mn:00009D4C
.text$mn:00009D4C ; Segment type: Pure code
.text$mn:00009D4C ; Segment permissions: Read/Execute
.text$mn:00009D4C _text$mn        segment para public 'CODE' use32
.text$mn:00009D4C                 assume cs:_text$mn
.text$mn:00009D4C                 ;org 9D4Ch
.text$mn:00009D4C ; COMDAT (pick any)
.text$mn:00009D4C                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text$mn:00009D4C
.text$mn:00009D4C ; =============== S U B R O U T I N E =======================================
.text$mn:00009D4C
.text$mn:00009D4C ; Attributes: bp-based frame
.text$mn:00009D4C
.text$mn:00009D4C ; protected: bool __thiscall std::vector<wchar_t, class std::allocator<wchar_t>>::_Inside(wchar_t const *)const
.text$mn:00009D4C                 public ?_Inside@?$vector@_WV?$allocator@_W@std@@@std@@IBE_NPB_W@Z
.text$mn:00009D4C ?_Inside@?$vector@_WV?$allocator@_W@std@@@std@@IBE_NPB_W@Z proc near
.text$mn:00009D4C                                         ; CODE XREF: std::vector<wchar_t,std::allocator<wchar_t>>::push_back(wchar_t &&)+19p
.text$mn:00009D4C
.text$mn:00009D4C var_8           = dword ptr -8
.text$mn:00009D4C var_4           = dword ptr -4
.text$mn:00009D4C arg_0           = dword ptr  8
.text$mn:00009D4C
.text$mn:00009D4C                 push    ebp
.text$mn:00009D4D                 mov     ebp, esp
.text$mn:00009D4F                 sub     esp, 8
.text$mn:00009D52                 mov     [ebp+var_4], ecx
.text$mn:00009D55                 mov     eax, [ebp+var_4]
.text$mn:00009D58                 mov     ecx, [ebp+arg_0]
.text$mn:00009D5B                 cmp     ecx, [eax+8]
.text$mn:00009D5E                 jnb     short loc_9D74
.text$mn:00009D60                 mov     edx, [ebp+var_4]
.text$mn:00009D63                 mov     eax, [edx+4]
.text$mn:00009D66                 cmp     eax, [ebp+arg_0]
.text$mn:00009D69                 ja      short loc_9D74
.text$mn:00009D6B                 mov     [ebp+var_8], 1
.text$mn:00009D72                 jmp     short loc_9D7B
.text$mn:00009D74 ; ---------------------------------------------------------------------------
.text$mn:00009D74
.text$mn:00009D74 loc_9D74:                               ; CODE XREF: std::vector<wchar_t,std::allocator<wchar_t>>::_Inside(wchar_t const *)+12j
.text$mn:00009D74                                         ; std::vector<wchar_t,std::allocator<wchar_t>>::_Inside(wchar_t const *)+1Dj
.text$mn:00009D74                 mov     [ebp+var_8], 0
.text$mn:00009D7B
.text$mn:00009D7B loc_9D7B:                               ; CODE XREF: std::vector<wchar_t,std::allocator<wchar_t>>::_Inside(wchar_t const *)+26j
.text$mn:00009D7B                 mov     al, byte ptr [ebp+var_8]
.text$mn:00009D7E                 mov     esp, ebp
.text$mn:00009D80                 pop     ebp
.text$mn:00009D81                 retn    4
.text$mn:00009D81 ?_Inside@?$vector@_WV?$allocator@_W@std@@@std@@IBE_NPB_W@Z endp
.text$mn:00009D81
.text$mn:00009D81 _text$mn        ends
.text$mn:00009D81
.text$mn:00009D84 ; ===========================================================================
.text$mn:00009D84
.text$mn:00009D84 ; Segment type: Pure code
.text$mn:00009D84 ; Segment permissions: Read/Execute
.text$mn:00009D84 _text$mn        segment para public 'CODE' use32
.text$mn:00009D84                 assume cs:_text$mn
.text$mn:00009D84                 ;org 9D84h
.text$mn:00009D84 ; COMDAT (pick any)
.text$mn:00009D84                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text$mn:00009D84
.text$mn:00009D84 ; =============== S U B R O U T I N E =======================================
.text$mn:00009D84
.text$mn:00009D84 ; Attributes: bp-based frame
.text$mn:00009D84
.text$mn:00009D84 ; public: char * __thiscall std::_String_val<struct std::_Simple_types<char>>::_Myptr(void)
.text$mn:00009D84                 public ?_Myptr@?$_String_val@U?$_Simple_types@D@std@@@std@@QAEPADXZ
.text$mn:00009D84 ?_Myptr@?$_String_val@U?$_Simple_types@D@std@@@std@@QAEPADXZ proc near
.text$mn:00009D84                                         ; CODE XREF: $LN19+14p
.text$mn:00009D84                                         ; std::basic_string<char,std::char_traits<char>,std::allocator<char>>::_Eos(uint)+1Dp ...
.text$mn:00009D84
.text$mn:00009D84 var_8           = dword ptr -8
.text$mn:00009D84 var_4           = dword ptr -4
.text$mn:00009D84
.text$mn:00009D84                 push    ebp
.text$mn:00009D85                 mov     ebp, esp
.text$mn:00009D87                 sub     esp, 8
.text$mn:00009D8A                 mov     [ebp+var_4], ecx
.text$mn:00009D8D                 mov     eax, [ebp+var_4]
.text$mn:00009D90                 cmp     dword ptr [eax+18h], 10h
.text$mn:00009D94                 jb      short loc_9DAA
.text$mn:00009D96                 mov     ecx, [ebp+var_4]
.text$mn:00009D99                 mov     edx, [ecx+4]
.text$mn:00009D9C                 push    edx
.text$mn:00009D9D                 call    ??$addressof@D@std@@YAPADAAD@Z ; std::addressof<char>(char &)
.text$mn:00009DA2                 add     esp, 4
.text$mn:00009DA5                 mov     [ebp+var_8], eax
.text$mn:00009DA8                 jmp     short loc_9DB3
.text$mn:00009DAA ; ---------------------------------------------------------------------------
.text$mn:00009DAA
.text$mn:00009DAA loc_9DAA:                               ; CODE XREF: std::_String_val<std::_Simple_types<char>>::_Myptr(void)+10j
.text$mn:00009DAA                 mov     eax, [ebp+var_4]
.text$mn:00009DAD                 add     eax, 4
.text$mn:00009DB0                 mov     [ebp+var_8], eax
.text$mn:00009DB3
.text$mn:00009DB3 loc_9DB3:                               ; CODE XREF: std::_String_val<std::_Simple_types<char>>::_Myptr(void)+24j
.text$mn:00009DB3                 mov     eax, [ebp+var_8]
.text$mn:00009DB6                 mov     esp, ebp
.text$mn:00009DB8                 pop     ebp
.text$mn:00009DB9                 retn
.text$mn:00009DB9 ?_Myptr@?$_String_val@U?$_Simple_types@D@std@@@std@@QAEPADXZ endp
.text$mn:00009DB9
.text$mn:00009DB9 ; ---------------------------------------------------------------------------
.text$mn:00009DBA                 align 4
.text$mn:00009DBA _text$mn        ends
.text$mn:00009DBA
.text$mn:00009DBC ; ===========================================================================
.text$mn:00009DBC
.text$mn:00009DBC ; Segment type: Pure code
.text$mn:00009DBC ; Segment permissions: Read/Execute
.text$mn:00009DBC _text$mn        segment para public 'CODE' use32
.text$mn:00009DBC                 assume cs:_text$mn
.text$mn:00009DBC                 ;org 9DBCh
.text$mn:00009DBC ; COMDAT (pick any)
.text$mn:00009DBC                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text$mn:00009DBC
.text$mn:00009DBC ; =============== S U B R O U T I N E =======================================
.text$mn:00009DBC
.text$mn:00009DBC ; Attributes: bp-based frame
.text$mn:00009DBC
.text$mn:00009DBC ; public: char const * __thiscall std::_String_val<struct std::_Simple_types<char>>::_Myptr(void)const
.text$mn:00009DBC                 public ?_Myptr@?$_String_val@U?$_Simple_types@D@std@@@std@@QBEPBDXZ
.text$mn:00009DBC ?_Myptr@?$_String_val@U?$_Simple_types@D@std@@@std@@QBEPBDXZ proc near
.text$mn:00009DBC                                         ; CODE XREF: std::basic_string<char,std::char_traits<char>,std::allocator<char>>::append(std::basic_string<char,std::char_traits<char>,std::allocator<char>> const &,uint,uint)+80p
.text$mn:00009DBC                                         ; std::basic_string<char,std::char_traits<char>,std::allocator<char>>::assign(std::basic_string<char,std::char_traits<char>,std::allocator<char>> const &,uint,uint)+7Dp ...
.text$mn:00009DBC
.text$mn:00009DBC var_8           = dword ptr -8
.text$mn:00009DBC var_4           = dword ptr -4
.text$mn:00009DBC
.text$mn:00009DBC                 push    ebp
.text$mn:00009DBD                 mov     ebp, esp
.text$mn:00009DBF                 sub     esp, 8
.text$mn:00009DC2                 mov     [ebp+var_4], ecx
.text$mn:00009DC5                 mov     eax, [ebp+var_4]
.text$mn:00009DC8                 cmp     dword ptr [eax+18h], 10h
.text$mn:00009DCC                 jb      short loc_9DE2
.text$mn:00009DCE                 mov     ecx, [ebp+var_4]
.text$mn:00009DD1                 mov     edx, [ecx+4]
.text$mn:00009DD4                 push    edx
.text$mn:00009DD5                 call    ??$addressof@D@std@@YAPADAAD@Z ; std::addressof<char>(char &)
.text$mn:00009DDA                 add     esp, 4
.text$mn:00009DDD                 mov     [ebp+var_8], eax
.text$mn:00009DE0                 jmp     short loc_9DEB
.text$mn:00009DE2 ; ---------------------------------------------------------------------------
.text$mn:00009DE2
.text$mn:00009DE2 loc_9DE2:                               ; CODE XREF: std::_String_val<std::_Simple_types<char>>::_Myptr(void)+10j
.text$mn:00009DE2                 mov     eax, [ebp+var_4]
.text$mn:00009DE5                 add     eax, 4
.text$mn:00009DE8                 mov     [ebp+var_8], eax
.text$mn:00009DEB
.text$mn:00009DEB loc_9DEB:                               ; CODE XREF: std::_String_val<std::_Simple_types<char>>::_Myptr(void)+24j
.text$mn:00009DEB                 mov     eax, [ebp+var_8]
.text$mn:00009DEE                 mov     esp, ebp
.text$mn:00009DF0                 pop     ebp
.text$mn:00009DF1                 retn
.text$mn:00009DF1 ?_Myptr@?$_String_val@U?$_Simple_types@D@std@@@std@@QBEPBDXZ endp
.text$mn:00009DF1
.text$mn:00009DF1 ; ---------------------------------------------------------------------------
.text$mn:00009DF2                 align 4
.text$mn:00009DF2 _text$mn        ends
.text$mn:00009DF2
.text$mn:00009DF4 ; ===========================================================================
.text$mn:00009DF4
.text$mn:00009DF4 ; Segment type: Pure code
.text$mn:00009DF4 ; Segment permissions: Read/Execute
.text$mn:00009DF4 _text$mn        segment para public 'CODE' use32
.text$mn:00009DF4                 assume cs:_text$mn
.text$mn:00009DF4                 ;org 9DF4h
.text$mn:00009DF4 ; COMDAT (pick any)
.text$mn:00009DF4                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text$mn:00009DF4
.text$mn:00009DF4 ; =============== S U B R O U T I N E =======================================
.text$mn:00009DF4
.text$mn:00009DF4 ; Attributes: bp-based frame
.text$mn:00009DF4
.text$mn:00009DF4 ; public: wchar_t * __thiscall std::_String_val<struct std::_Simple_types<wchar_t>>::_Myptr(void)
.text$mn:00009DF4                 public ?_Myptr@?$_String_val@U?$_Simple_types@_W@std@@@std@@QAEPA_WXZ
.text$mn:00009DF4 ?_Myptr@?$_String_val@U?$_Simple_types@_W@std@@@std@@QAEPA_WXZ proc near
.text$mn:00009DF4                                         ; CODE XREF: std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>>::operator[](uint)+2Cp
.text$mn:00009DF4                                         ; std::_String_const_iterator<std::_String_val<std::_Simple_types<wchar_t>>>::operator*(void)+27p ...
.text$mn:00009DF4
.text$mn:00009DF4 var_8           = dword ptr -8
.text$mn:00009DF4 var_4           = dword ptr -4
.text$mn:00009DF4
.text$mn:00009DF4                 push    ebp
.text$mn:00009DF5                 mov     ebp, esp
.text$mn:00009DF7                 sub     esp, 8
.text$mn:00009DFA                 mov     [ebp+var_4], ecx
.text$mn:00009DFD                 mov     eax, [ebp+var_4]
.text$mn:00009E00                 cmp     dword ptr [eax+18h], 8
.text$mn:00009E04                 jb      short loc_9E1A
.text$mn:00009E06                 mov     ecx, [ebp+var_4]
.text$mn:00009E09                 mov     edx, [ecx+4]
.text$mn:00009E0C                 push    edx
.text$mn:00009E0D                 call    ??$addressof@_W@std@@YAPA_WAA_W@Z ; std::addressof<wchar_t>(wchar_t &)
.text$mn:00009E12                 add     esp, 4
.text$mn:00009E15                 mov     [ebp+var_8], eax
.text$mn:00009E18                 jmp     short loc_9E23
.text$mn:00009E1A ; ---------------------------------------------------------------------------
.text$mn:00009E1A
.text$mn:00009E1A loc_9E1A:                               ; CODE XREF: std::_String_val<std::_Simple_types<wchar_t>>::_Myptr(void)+10j
.text$mn:00009E1A                 mov     eax, [ebp+var_4]
.text$mn:00009E1D                 add     eax, 4
.text$mn:00009E20                 mov     [ebp+var_8], eax
.text$mn:00009E23
.text$mn:00009E23 loc_9E23:                               ; CODE XREF: std::_String_val<std::_Simple_types<wchar_t>>::_Myptr(void)+24j
.text$mn:00009E23                 mov     eax, [ebp+var_8]
.text$mn:00009E26                 mov     esp, ebp
.text$mn:00009E28                 pop     ebp
.text$mn:00009E29                 retn
.text$mn:00009E29 ?_Myptr@?$_String_val@U?$_Simple_types@_W@std@@@std@@QAEPA_WXZ endp
.text$mn:00009E29
.text$mn:00009E29 ; ---------------------------------------------------------------------------
.text$mn:00009E2A                 align 4
.text$mn:00009E2A _text$mn        ends
.text$mn:00009E2A
.text$mn:00009E2C ; ===========================================================================
.text$mn:00009E2C
.text$mn:00009E2C ; Segment type: Pure code
.text$mn:00009E2C ; Segment permissions: Read/Execute
.text$mn:00009E2C _text$mn        segment para public 'CODE' use32
.text$mn:00009E2C                 assume cs:_text$mn
.text$mn:00009E2C                 ;org 9E2Ch
.text$mn:00009E2C ; COMDAT (pick any)
.text$mn:00009E2C                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text$mn:00009E2C
.text$mn:00009E2C ; =============== S U B R O U T I N E =======================================
.text$mn:00009E2C
.text$mn:00009E2C ; Attributes: bp-based frame
.text$mn:00009E2C
.text$mn:00009E2C ; public: wchar_t const * __thiscall std::_String_val<struct std::_Simple_types<wchar_t>>::_Myptr(void)const
.text$mn:00009E2C                 public ?_Myptr@?$_String_val@U?$_Simple_types@_W@std@@@std@@QBEPB_WXZ
.text$mn:00009E2C ?_Myptr@?$_String_val@U?$_Simple_types@_W@std@@@std@@QBEPB_WXZ proc near
.text$mn:00009E2C                                         ; CODE XREF: std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>>::operator[](uint)+2Cp
.text$mn:00009E2C                                         ; std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>>::append(std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>> const &,uint,uint)+80p ...
.text$mn:00009E2C
.text$mn:00009E2C var_8           = dword ptr -8
.text$mn:00009E2C var_4           = dword ptr -4
.text$mn:00009E2C
.text$mn:00009E2C                 push    ebp
.text$mn:00009E2D                 mov     ebp, esp
.text$mn:00009E2F                 sub     esp, 8
.text$mn:00009E32                 mov     [ebp+var_4], ecx
.text$mn:00009E35                 mov     eax, [ebp+var_4]
.text$mn:00009E38                 cmp     dword ptr [eax+18h], 8
.text$mn:00009E3C                 jb      short loc_9E52
.text$mn:00009E3E                 mov     ecx, [ebp+var_4]
.text$mn:00009E41                 mov     edx, [ecx+4]
.text$mn:00009E44                 push    edx
.text$mn:00009E45                 call    ??$addressof@_W@std@@YAPA_WAA_W@Z ; std::addressof<wchar_t>(wchar_t &)
.text$mn:00009E4A                 add     esp, 4
.text$mn:00009E4D                 mov     [ebp+var_8], eax
.text$mn:00009E50                 jmp     short loc_9E5B
.text$mn:00009E52 ; ---------------------------------------------------------------------------
.text$mn:00009E52
.text$mn:00009E52 loc_9E52:                               ; CODE XREF: std::_String_val<std::_Simple_types<wchar_t>>::_Myptr(void)+10j
.text$mn:00009E52                 mov     eax, [ebp+var_4]
.text$mn:00009E55                 add     eax, 4
.text$mn:00009E58                 mov     [ebp+var_8], eax
.text$mn:00009E5B
.text$mn:00009E5B loc_9E5B:                               ; CODE XREF: std::_String_val<std::_Simple_types<wchar_t>>::_Myptr(void)+24j
.text$mn:00009E5B                 mov     eax, [ebp+var_8]
.text$mn:00009E5E                 mov     esp, ebp
.text$mn:00009E60                 pop     ebp
.text$mn:00009E61                 retn
.text$mn:00009E61 ?_Myptr@?$_String_val@U?$_Simple_types@_W@std@@@std@@QBEPB_WXZ endp
.text$mn:00009E61
.text$mn:00009E61 ; ---------------------------------------------------------------------------
.text$mn:00009E62                 align 4
.text$mn:00009E62 _text$mn        ends
.text$mn:00009E62
.text$mn:00009E64 ; ===========================================================================
.text$mn:00009E64
.text$mn:00009E64 ; Segment type: Pure code
.text$mn:00009E64 ; Segment permissions: Read/Execute
.text$mn:00009E64 _text$mn        segment para public 'CODE' use32
.text$mn:00009E64                 assume cs:_text$mn
.text$mn:00009E64                 ;org 9E64h
.text$mn:00009E64 ; COMDAT (pick any)
.text$mn:00009E64                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text$mn:00009E64
.text$mn:00009E64 ; =============== S U B R O U T I N E =======================================
.text$mn:00009E64
.text$mn:00009E64 ; Attributes: bp-based frame
.text$mn:00009E64
.text$mn:00009E64 ; void __thiscall std::_Container_base12::_Orphan_all(std::_Container_base12 *__hidden this)
.text$mn:00009E64                 public ?_Orphan_all@_Container_base12@std@@QAEXXZ
.text$mn:00009E64 ?_Orphan_all@_Container_base12@std@@QAEXXZ proc near
.text$mn:00009E64                                         ; CODE XREF: std::_Container_base12::~_Container_base12(void)+Ap
.text$mn:00009E64                                         ; std::_String_alloc<0,std::_String_base_types<char,std::allocator<char>>>::_Free_proxy(void)+14p ...
.text$mn:00009E64
.text$mn:00009E64 var_18          = byte ptr -18h
.text$mn:00009E64 var_14          = dword ptr -14h
.text$mn:00009E64 var_10          = dword ptr -10h
.text$mn:00009E64 var_C           = dword ptr -0Ch
.text$mn:00009E64 var_4           = dword ptr -4
.text$mn:00009E64
.text$mn:00009E64                 push    ebp
.text$mn:00009E65                 mov     ebp, esp
.text$mn:00009E67                 push    0FFFFFFFFh
.text$mn:00009E69                 push    offset __ehhandler$?_Orphan_all@_Container_base12@std@@QAEXXZ
.text$mn:00009E6E                 mov     eax, large fs:0
.text$mn:00009E74                 push    eax
.text$mn:00009E75                 sub     esp, 0Ch
.text$mn:00009E78                 mov     eax, dword ptr ds:___security_cookie
.text$mn:00009E7D                 xor     eax, ebp
.text$mn:00009E7F                 push    eax
.text$mn:00009E80                 lea     eax, [ebp+var_C]
.text$mn:00009E83                 mov     large fs:0, eax
.text$mn:00009E89                 mov     [ebp+var_14], ecx
.text$mn:00009E8C                 mov     eax, [ebp+var_14]
.text$mn:00009E8F                 cmp     dword ptr [eax], 0
.text$mn:00009E92                 jz      short loc_9EEF
.text$mn:00009E94                 push    3               ; int
.text$mn:00009E96                 lea     ecx, [ebp+var_18] ; this
.text$mn:00009E99                 call    ??0_Lockit@std@@QAE@H@Z ; std::_Lockit::_Lockit(int)
.text$mn:00009E9E                 mov     [ebp+var_4], 0
.text$mn:00009EA5                 mov     ecx, [ebp+var_14]
.text$mn:00009EA8                 mov     edx, [ecx]
.text$mn:00009EAA                 add     edx, 4
.text$mn:00009EAD                 mov     [ebp+var_10], edx
.text$mn:00009EB0                 jmp     short loc_9EBF
.text$mn:00009EB2 ; ---------------------------------------------------------------------------
.text$mn:00009EB2
.text$mn:00009EB2 loc_9EB2:                               ; CODE XREF: std::_Container_base12::_Orphan_all(void)+6Ej
.text$mn:00009EB2                 mov     eax, [ebp+var_10]
.text$mn:00009EB5                 mov     ecx, [eax]
.text$mn:00009EB7                 mov     edx, [ebp+var_10]
.text$mn:00009EBA                 mov     eax, [ecx+4]
.text$mn:00009EBD                 mov     [edx], eax
.text$mn:00009EBF
.text$mn:00009EBF loc_9EBF:                               ; CODE XREF: std::_Container_base12::_Orphan_all(void)+4Cj
.text$mn:00009EBF                 mov     ecx, [ebp+var_10]
.text$mn:00009EC2                 cmp     dword ptr [ecx], 0
.text$mn:00009EC5                 jz      short loc_9ED4
.text$mn:00009EC7                 mov     edx, [ebp+var_10]
.text$mn:00009ECA                 mov     eax, [edx]
.text$mn:00009ECC                 mov     dword ptr [eax], 0
.text$mn:00009ED2                 jmp     short loc_9EB2
.text$mn:00009ED4 ; ---------------------------------------------------------------------------
.text$mn:00009ED4
.text$mn:00009ED4 loc_9ED4:                               ; CODE XREF: std::_Container_base12::_Orphan_all(void)+61j
.text$mn:00009ED4                 mov     ecx, [ebp+var_14]
.text$mn:00009ED7                 mov     edx, [ecx]
.text$mn:00009ED9                 mov     dword ptr [edx+4], 0
.text$mn:00009EE0                 mov     [ebp+var_4], 0FFFFFFFFh
.text$mn:00009EE7                 lea     ecx, [ebp+var_18] ; this
.text$mn:00009EEA                 call    ??1_Lockit@std@@QAE@XZ ; std::_Lockit::~_Lockit(void)
.text$mn:00009EEF
.text$mn:00009EEF loc_9EEF:                               ; CODE XREF: std::_Container_base12::_Orphan_all(void)+2Ej
.text$mn:00009EEF                 mov     ecx, [ebp+var_C]
.text$mn:00009EF2                 mov     large fs:0, ecx
.text$mn:00009EF9                 pop     ecx
.text$mn:00009EFA                 mov     esp, ebp
.text$mn:00009EFC                 pop     ebp
.text$mn:00009EFD                 retn
.text$mn:00009EFD ?_Orphan_all@_Container_base12@std@@QAEXXZ endp
.text$mn:00009EFD
.text$mn:00009EFD ; ---------------------------------------------------------------------------
.text$mn:00009EFE                 align 10h
.text$mn:00009EFE _text$mn        ends
.text$mn:00009EFE
.text$x:00009F00 ; ===========================================================================
.text$x:00009F00
.text$x:00009F00 ; Segment type: Pure code
.text$x:00009F00 ; Segment permissions: Read/Execute
.text$x:00009F00 _text$x         segment para public 'CODE' use32
.text$x:00009F00                 assume cs:_text$x
.text$x:00009F00                 ;org 9F00h
.text$x:00009F00 ; COMDAT (pick associative to section at 9E64)
.text$x:00009F00                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text$x:00009F00
.text$x:00009F00 ; =============== S U B R O U T I N E =======================================
.text$x:00009F00
.text$x:00009F00
.text$x:00009F00 __unwindfunclet$?_Orphan_all@_Container_base12@std@@QAEXXZ$0 proc near
.text$x:00009F00                                         ; DATA XREF: .xdata$x:0000D408o
.text$x:00009F00                 lea     ecx, [ebp-18h]  ; this
.text$x:00009F03                 jmp     ??1_Lockit@std@@QAE@XZ ; std::_Lockit::~_Lockit(void)
.text$x:00009F03 __unwindfunclet$?_Orphan_all@_Container_base12@std@@QAEXXZ$0 endp
.text$x:00009F03
.text$x:00009F08
.text$x:00009F08 ; =============== S U B R O U T I N E =======================================
.text$x:00009F08
.text$x:00009F08
.text$x:00009F08 __ehhandler$?_Orphan_all@_Container_base12@std@@QAEXXZ proc near
.text$x:00009F08                                         ; DATA XREF: std::_Container_base12::_Orphan_all(void)+5o
.text$x:00009F08
.text$x:00009F08 arg_4           = dword ptr  8
.text$x:00009F08
.text$x:00009F08                 mov     edx, [esp+arg_4]
.text$x:00009F0C                 lea     eax, [edx+0Ch]
.text$x:00009F0F                 mov     ecx, [edx-10h]
.text$x:00009F12                 xor     ecx, eax
.text$x:00009F14                 call    @__security_check_cookie@4 ; __security_check_cookie(x)
.text$x:00009F19                 mov     eax, offset __ehfuncinfo$?_Orphan_all@_Container_base12@std@@QAEXXZ
.text$x:00009F1E                 jmp     ___CxxFrameHandler3
.text$x:00009F1E __ehhandler$?_Orphan_all@_Container_base12@std@@QAEXXZ endp
.text$x:00009F1E
.text$x:00009F1E ; ---------------------------------------------------------------------------
.text$x:00009F23                 align 4
.text$x:00009F23 _text$x         ends
.text$x:00009F23
.text$mn:00009F24 ; ===========================================================================
.text$mn:00009F24
.text$mn:00009F24 ; Segment type: Pure code
.text$mn:00009F24 ; Segment permissions: Read/Execute
.text$mn:00009F24 _text$mn        segment para public 'CODE' use32
.text$mn:00009F24                 assume cs:_text$mn
.text$mn:00009F24                 ;org 9F24h
.text$mn:00009F24 ; COMDAT (pick any)
.text$mn:00009F24                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text$mn:00009F24
.text$mn:00009F24 ; =============== S U B R O U T I N E =======================================
.text$mn:00009F24
.text$mn:00009F24 ; Attributes: bp-based frame
.text$mn:00009F24
.text$mn:00009F24 ; void __thiscall std::_Iterator_base12::_Orphan_me(std::_Iterator_base12 *__hidden this)
.text$mn:00009F24                 public ?_Orphan_me@_Iterator_base12@std@@QAEXXZ
.text$mn:00009F24 ?_Orphan_me@_Iterator_base12@std@@QAEXXZ proc near
.text$mn:00009F24                                         ; CODE XREF: std::_Iterator_base12::~_Iterator_base12(void)+3Cp
.text$mn:00009F24                                         ; std::_Iterator_base12::operator=(std::_Iterator_base12 const &)+64p ...
.text$mn:00009F24
.text$mn:00009F24 var_8           = dword ptr -8
.text$mn:00009F24 var_4           = dword ptr -4
.text$mn:00009F24
.text$mn:00009F24                 push    ebp
.text$mn:00009F25                 mov     ebp, esp
.text$mn:00009F27                 sub     esp, 8
.text$mn:00009F2A                 mov     [ebp+var_8], ecx
.text$mn:00009F2D                 mov     eax, [ebp+var_8]
.text$mn:00009F30                 cmp     dword ptr [eax], 0
.text$mn:00009F33                 jz      short loc_9F92
.text$mn:00009F35                 mov     ecx, [ebp+var_8]
.text$mn:00009F38                 mov     edx, [ecx]
.text$mn:00009F3A                 add     edx, 4
.text$mn:00009F3D                 mov     [ebp+var_4], edx
.text$mn:00009F40
.text$mn:00009F40 loc_9F40:                               ; CODE XREF: std::_Iterator_base12::_Orphan_me(void)+39j
.text$mn:00009F40                 mov     eax, [ebp+var_4]
.text$mn:00009F43                 cmp     dword ptr [eax], 0
.text$mn:00009F46                 jz      short loc_9F5F
.text$mn:00009F48                 mov     ecx, [ebp+var_4]
.text$mn:00009F4B                 mov     edx, [ecx]
.text$mn:00009F4D                 cmp     edx, [ebp+var_8]
.text$mn:00009F50                 jz      short loc_9F5F
.text$mn:00009F52                 mov     eax, [ebp+var_4]
.text$mn:00009F55                 mov     ecx, [eax]
.text$mn:00009F57                 add     ecx, 4
.text$mn:00009F5A                 mov     [ebp+var_4], ecx
.text$mn:00009F5D                 jmp     short loc_9F40
.text$mn:00009F5F ; ---------------------------------------------------------------------------
.text$mn:00009F5F
.text$mn:00009F5F loc_9F5F:                               ; CODE XREF: std::_Iterator_base12::_Orphan_me(void)+22j
.text$mn:00009F5F                                         ; std::_Iterator_base12::_Orphan_me(void)+2Cj
.text$mn:00009F5F                 mov     edx, [ebp+var_4]
.text$mn:00009F62                 cmp     dword ptr [edx], 0
.text$mn:00009F65                 jnz     short loc_9F7E
.text$mn:00009F67                 push    0C9h ; '+'      ; unsigned int
.text$mn:00009F6C                 push    offset ??_C@_1JA@EADLBAJ@?$AAC?$AA?3?$AA?2?$AAP?$AAr?$AAo?$AAg?$AAr?$AAa?$AAm?$AA?5?$AAF?$AAi?$AAl?$AAe?$AAs?$AA?5?$AA?$CI?$AAx?$AA8?$AA6?$AA?$CJ?$AA?2?$AAM?$AAi?$AAc?$AAr?$AAo?$AAs?$AAo?$AAf?$AAt@ ; "C:\\Program Files (x86)\\Microsoft Visu"...
.text$mn:00009F71                 push    offset ??_C@_1DC@POOIKBAO@?$AAI?$AAT?$AAE?$AAR?$AAA?$AAT?$AAO?$AAR?$AA?5?$AAL?$AAI?$AAS?$AAT?$AA?5?$AAC?$AAO?$AAR?$AAR?$AAU?$AAP?$AAT?$AAE?$AAD?$AA?$CB?$AA?$AA@ ; "ITERATOR LIST CORRUPTED!"
.text$mn:00009F76                 call    ?_Debug_message@std@@YAXPB_W0I@Z ; std::_Debug_message(wchar_t const *,wchar_t const *,uint)
.text$mn:00009F7B                 add     esp, 0Ch
.text$mn:00009F7E
.text$mn:00009F7E loc_9F7E:                               ; CODE XREF: std::_Iterator_base12::_Orphan_me(void)+41j
.text$mn:00009F7E                 mov     eax, [ebp+var_4]
.text$mn:00009F81                 mov     ecx, [ebp+var_8]
.text$mn:00009F84                 mov     edx, [ecx+4]
.text$mn:00009F87                 mov     [eax], edx
.text$mn:00009F89                 mov     eax, [ebp+var_8]
.text$mn:00009F8C                 mov     dword ptr [eax], 0
.text$mn:00009F92
.text$mn:00009F92 loc_9F92:                               ; CODE XREF: std::_Iterator_base12::_Orphan_me(void)+Fj
.text$mn:00009F92                 mov     esp, ebp
.text$mn:00009F94                 pop     ebp
.text$mn:00009F95                 retn
.text$mn:00009F95 ?_Orphan_me@_Iterator_base12@std@@QAEXXZ endp
.text$mn:00009F95
.text$mn:00009F95 ; ---------------------------------------------------------------------------
.text$mn:00009F96                 align 4
.text$mn:00009F96 _text$mn        ends
.text$mn:00009F96
.text$mn:00009F98 ; ===========================================================================
.text$mn:00009F98
.text$mn:00009F98 ; Segment type: Pure code
.text$mn:00009F98 ; Segment permissions: Read/Execute
.text$mn:00009F98 _text$mn        segment para public 'CODE' use32
.text$mn:00009F98                 assume cs:_text$mn
.text$mn:00009F98                 ;org 9F98h
.text$mn:00009F98 ; COMDAT (pick any)
.text$mn:00009F98                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text$mn:00009F98
.text$mn:00009F98 ; =============== S U B R O U T I N E =======================================
.text$mn:00009F98
.text$mn:00009F98 ; Attributes: bp-based frame
.text$mn:00009F98
.text$mn:00009F98 ; protected: void __thiscall std::vector<class std::basic_string<wchar_t, struct std::char_traits<wchar_t>, class std::allocator<wchar_t>>, class std::allocator<class std::basic_string<wchar_t, struct std::char_traits<wchar_t>, class std::allocator<wchar_t>>>>::_Orphan_range(class std::basic_string<wchar_t, struct std::char_traits<wchar_t>, class std::allocator<wchar_t>> *, class std::basic_string<wchar_t, struct std::char_traits<wchar_t>, class std::allocator<wchar_t>> *)const
.text$mn:00009F98                 public ?_Orphan_range@?$vector@V?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@V?$allocator@V?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@@2@@std@@IBEXPAV?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@2@0@Z
.text$mn:00009F98 ?_Orphan_range@?$vector@V?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@V?$allocator@V?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@@2@@std@@IBEXPAV?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@2@0@Z proc near
.text$mn:00009F98                                         ; CODE XREF: std::vector<std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>>,std::allocator<std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>>>>::push_back(std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>> &&)+6Fp
.text$mn:00009F98                                         ; std::vector<std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>>,std::allocator<std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>>>>::push_back(std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>> &&)+DCp
.text$mn:00009F98
.text$mn:00009F98 var_18          = byte ptr -18h
.text$mn:00009F98 var_14          = dword ptr -14h
.text$mn:00009F98 var_10          = dword ptr -10h
.text$mn:00009F98 var_C           = dword ptr -0Ch
.text$mn:00009F98 var_4           = dword ptr -4
.text$mn:00009F98 arg_0           = dword ptr  8
.text$mn:00009F98 arg_4           = dword ptr  0Ch
.text$mn:00009F98
.text$mn:00009F98                 push    ebp
.text$mn:00009F99                 mov     ebp, esp
.text$mn:00009F9B                 push    0FFFFFFFFh
.text$mn:00009F9D                 push    offset __ehhandler$?_Orphan_range@?$vector@V?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@V?$allocator@V?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@@2@@std@@IBEXPAV?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@2@0@Z
.text$mn:00009FA2                 mov     eax, large fs:0
.text$mn:00009FA8                 push    eax
.text$mn:00009FA9                 sub     esp, 0Ch
.text$mn:00009FAC                 mov     eax, dword ptr ds:___security_cookie
.text$mn:00009FB1                 xor     eax, ebp
.text$mn:00009FB3                 push    eax
.text$mn:00009FB4                 lea     eax, [ebp+var_C]
.text$mn:00009FB7                 mov     large fs:0, eax
.text$mn:00009FBD                 mov     [ebp+var_14], ecx
.text$mn:00009FC0                 push    3               ; int
.text$mn:00009FC2                 lea     ecx, [ebp+var_18] ; this
.text$mn:00009FC5                 call    ??0_Lockit@std@@QAE@H@Z ; std::_Lockit::_Lockit(int)
.text$mn:00009FCA                 mov     [ebp+var_4], 0
.text$mn:00009FD1                 mov     ecx, [ebp+var_14] ; this
.text$mn:00009FD4                 call    ?_Getpfirst@_Container_base12@std@@QBEPAPAU_Iterator_base12@2@XZ ; std::_Container_base12::_Getpfirst(void)
.text$mn:00009FD9                 mov     [ebp+var_10], eax
.text$mn:00009FDC                 cmp     [ebp+var_10], 0
.text$mn:00009FE0                 jz      short loc_A030
.text$mn:00009FE2
.text$mn:00009FE2 loc_9FE2:                               ; CODE XREF: std::vector<std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>>,std::allocator<std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>>>>::_Orphan_range(std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>> *,std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>> *):loc_A02Ej
.text$mn:00009FE2                 mov     eax, [ebp+var_10]
.text$mn:00009FE5                 cmp     dword ptr [eax], 0
.text$mn:00009FE8                 jz      short loc_A030
.text$mn:00009FEA                 mov     ecx, [ebp+var_10]
.text$mn:00009FED                 mov     edx, [ecx]
.text$mn:00009FEF                 mov     eax, [edx+8]
.text$mn:00009FF2                 cmp     eax, [ebp+arg_0]
.text$mn:00009FF5                 jb      short loc_A004
.text$mn:00009FF7                 mov     ecx, [ebp+var_10]
.text$mn:00009FFA                 mov     edx, [ecx]
.text$mn:00009FFC                 mov     eax, [ebp+arg_4]
.text$mn:00009FFF                 cmp     eax, [edx+8]
.text$mn:0000A002                 jnb     short loc_A013
.text$mn:0000A004
.text$mn:0000A004 loc_A004:                               ; CODE XREF: std::vector<std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>>,std::allocator<std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>>>>::_Orphan_range(std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>> *,std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>> *)+5Dj
.text$mn:0000A004                 mov     ecx, [ebp+var_10]
.text$mn:0000A007                 mov     ecx, [ecx]      ; this
.text$mn:0000A009                 call    ?_Getpnext@_Iterator_base12@std@@QAEPAPAU12@XZ ; std::_Iterator_base12::_Getpnext(void)
.text$mn:0000A00E                 mov     [ebp+var_10], eax
.text$mn:0000A011                 jmp     short loc_A02E
.text$mn:0000A013 ; ---------------------------------------------------------------------------
.text$mn:0000A013
.text$mn:0000A013 loc_A013:                               ; CODE XREF: std::vector<std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>>,std::allocator<std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>>>>::_Orphan_range(std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>> *,std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>> *)+6Aj
.text$mn:0000A013                 mov     edx, [ebp+var_10]
.text$mn:0000A016                 mov     ecx, [edx]      ; this
.text$mn:0000A018                 call    ?_Clrcont@_Iterator_base12@std@@QAEXXZ ; std::_Iterator_base12::_Clrcont(void)
.text$mn:0000A01D                 mov     eax, [ebp+var_10]
.text$mn:0000A020                 mov     ecx, [eax]      ; this
.text$mn:0000A022                 call    ?_Getpnext@_Iterator_base12@std@@QAEPAPAU12@XZ ; std::_Iterator_base12::_Getpnext(void)
.text$mn:0000A027                 mov     ecx, [ebp+var_10]
.text$mn:0000A02A                 mov     edx, [eax]
.text$mn:0000A02C                 mov     [ecx], edx
.text$mn:0000A02E
.text$mn:0000A02E loc_A02E:                               ; CODE XREF: std::vector<std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>>,std::allocator<std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>>>>::_Orphan_range(std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>> *,std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>> *)+79j
.text$mn:0000A02E                 jmp     short loc_9FE2
.text$mn:0000A030 ; ---------------------------------------------------------------------------
.text$mn:0000A030
.text$mn:0000A030 loc_A030:                               ; CODE XREF: std::vector<std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>>,std::allocator<std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>>>>::_Orphan_range(std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>> *,std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>> *)+48j
.text$mn:0000A030                                         ; std::vector<std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>>,std::allocator<std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>>>>::_Orphan_range(std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>> *,std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>> *)+50j
.text$mn:0000A030                 mov     [ebp+var_4], 0FFFFFFFFh
.text$mn:0000A037                 lea     ecx, [ebp+var_18] ; this
.text$mn:0000A03A                 call    ??1_Lockit@std@@QAE@XZ ; std::_Lockit::~_Lockit(void)
.text$mn:0000A03F                 mov     ecx, [ebp+var_C]
.text$mn:0000A042                 mov     large fs:0, ecx
.text$mn:0000A049                 pop     ecx
.text$mn:0000A04A                 mov     esp, ebp
.text$mn:0000A04C                 pop     ebp
.text$mn:0000A04D                 retn    8
.text$mn:0000A04D ?_Orphan_range@?$vector@V?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@V?$allocator@V?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@@2@@std@@IBEXPAV?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@2@0@Z endp
.text$mn:0000A04D
.text$mn:0000A04D _text$mn        ends
.text$mn:0000A04D
.text$x:0000A050 ; ===========================================================================
.text$x:0000A050
.text$x:0000A050 ; Segment type: Pure code
.text$x:0000A050 ; Segment permissions: Read/Execute
.text$x:0000A050 _text$x         segment para public 'CODE' use32
.text$x:0000A050                 assume cs:_text$x
.text$x:0000A050                 ;org 0A050h
.text$x:0000A050 ; COMDAT (pick associative to section at 9F98)
.text$x:0000A050                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text$x:0000A050
.text$x:0000A050 ; =============== S U B R O U T I N E =======================================
.text$x:0000A050
.text$x:0000A050
.text$x:0000A050 __unwindfunclet$?_Orphan_range@?$vector@V?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@V?$allocator@V?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@@2@@std@@IBEXPAV?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@2@0@Z$0 proc near
.text$x:0000A050                                         ; DATA XREF: .xdata$x:0000E390o
.text$x:0000A050                 lea     ecx, [ebp-18h]  ; this
.text$x:0000A053                 jmp     ??1_Lockit@std@@QAE@XZ ; std::_Lockit::~_Lockit(void)
.text$x:0000A053 __unwindfunclet$?_Orphan_range@?$vector@V?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@V?$allocator@V?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@@2@@std@@IBEXPAV?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@2@0@Z$0 endp
.text$x:0000A053
.text$x:0000A058
.text$x:0000A058 ; =============== S U B R O U T I N E =======================================
.text$x:0000A058
.text$x:0000A058
.text$x:0000A058 __ehhandler$?_Orphan_range@?$vector@V?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@V?$allocator@V?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@@2@@std@@IBEXPAV?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@2@0@Z proc near
.text$x:0000A058                                         ; DATA XREF: std::vector<std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>>,std::allocator<std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>>>>::_Orphan_range(std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>> *,std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>> *)+5o
.text$x:0000A058
.text$x:0000A058 arg_4           = dword ptr  8
.text$x:0000A058
.text$x:0000A058                 mov     edx, [esp+arg_4]
.text$x:0000A05C                 lea     eax, [edx+0Ch]
.text$x:0000A05F                 mov     ecx, [edx-10h]
.text$x:0000A062                 xor     ecx, eax
.text$x:0000A064                 call    @__security_check_cookie@4 ; __security_check_cookie(x)
.text$x:0000A069                 mov     eax, offset __ehfuncinfo$?_Orphan_range@?$vector@V?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@V?$allocator@V?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@@2@@std@@IBEXPAV?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@2@0@Z
.text$x:0000A06E                 jmp     ___CxxFrameHandler3
.text$x:0000A06E __ehhandler$?_Orphan_range@?$vector@V?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@V?$allocator@V?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@@2@@std@@IBEXPAV?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@2@0@Z endp
.text$x:0000A06E
.text$x:0000A06E ; ---------------------------------------------------------------------------
.text$x:0000A073                 align 4
.text$x:0000A073 _text$x         ends
.text$x:0000A073
.text$mn:0000A074 ; ===========================================================================
.text$mn:0000A074
.text$mn:0000A074 ; Segment type: Pure code
.text$mn:0000A074 ; Segment permissions: Read/Execute
.text$mn:0000A074 _text$mn        segment para public 'CODE' use32
.text$mn:0000A074                 assume cs:_text$mn
.text$mn:0000A074                 ;org 0A074h
.text$mn:0000A074 ; COMDAT (pick any)
.text$mn:0000A074                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text$mn:0000A074
.text$mn:0000A074 ; =============== S U B R O U T I N E =======================================
.text$mn:0000A074
.text$mn:0000A074 ; Attributes: bp-based frame
.text$mn:0000A074
.text$mn:0000A074 ; protected: void __thiscall std::vector<wchar_t, class std::allocator<wchar_t>>::_Orphan_range(wchar_t *, wchar_t *)const
.text$mn:0000A074                 public ?_Orphan_range@?$vector@_WV?$allocator@_W@std@@@std@@IBEXPA_W0@Z
.text$mn:0000A074 ?_Orphan_range@?$vector@_WV?$allocator@_W@std@@@std@@IBEXPA_W0@Z proc near
.text$mn:0000A074                                         ; CODE XREF: std::vector<wchar_t,std::allocator<wchar_t>>::push_back(wchar_t &&)+69p
.text$mn:0000A074                                         ; std::vector<wchar_t,std::allocator<wchar_t>>::push_back(wchar_t &&)+D8p
.text$mn:0000A074
.text$mn:0000A074 var_18          = byte ptr -18h
.text$mn:0000A074 var_14          = dword ptr -14h
.text$mn:0000A074 var_10          = dword ptr -10h
.text$mn:0000A074 var_C           = dword ptr -0Ch
.text$mn:0000A074 var_4           = dword ptr -4
.text$mn:0000A074 arg_0           = dword ptr  8
.text$mn:0000A074 arg_4           = dword ptr  0Ch
.text$mn:0000A074
.text$mn:0000A074                 push    ebp
.text$mn:0000A075                 mov     ebp, esp
.text$mn:0000A077                 push    0FFFFFFFFh
.text$mn:0000A079                 push    offset __ehhandler$?_Orphan_range@?$vector@_WV?$allocator@_W@std@@@std@@IBEXPA_W0@Z
.text$mn:0000A07E                 mov     eax, large fs:0
.text$mn:0000A084                 push    eax
.text$mn:0000A085                 sub     esp, 0Ch
.text$mn:0000A088                 mov     eax, dword ptr ds:___security_cookie
.text$mn:0000A08D                 xor     eax, ebp
.text$mn:0000A08F                 push    eax
.text$mn:0000A090                 lea     eax, [ebp+var_C]
.text$mn:0000A093                 mov     large fs:0, eax
.text$mn:0000A099                 mov     [ebp+var_14], ecx
.text$mn:0000A09C                 push    3               ; int
.text$mn:0000A09E                 lea     ecx, [ebp+var_18] ; this
.text$mn:0000A0A1                 call    ??0_Lockit@std@@QAE@H@Z ; std::_Lockit::_Lockit(int)
.text$mn:0000A0A6                 mov     [ebp+var_4], 0
.text$mn:0000A0AD                 mov     ecx, [ebp+var_14] ; this
.text$mn:0000A0B0                 call    ?_Getpfirst@_Container_base12@std@@QBEPAPAU_Iterator_base12@2@XZ ; std::_Container_base12::_Getpfirst(void)
.text$mn:0000A0B5                 mov     [ebp+var_10], eax
.text$mn:0000A0B8                 cmp     [ebp+var_10], 0
.text$mn:0000A0BC                 jz      short loc_A10C
.text$mn:0000A0BE
.text$mn:0000A0BE loc_A0BE:                               ; CODE XREF: std::vector<wchar_t,std::allocator<wchar_t>>::_Orphan_range(wchar_t *,wchar_t *):loc_A10Aj
.text$mn:0000A0BE                 mov     eax, [ebp+var_10]
.text$mn:0000A0C1                 cmp     dword ptr [eax], 0
.text$mn:0000A0C4                 jz      short loc_A10C
.text$mn:0000A0C6                 mov     ecx, [ebp+var_10]
.text$mn:0000A0C9                 mov     edx, [ecx]
.text$mn:0000A0CB                 mov     eax, [edx+8]
.text$mn:0000A0CE                 cmp     eax, [ebp+arg_0]
.text$mn:0000A0D1                 jb      short loc_A0E0
.text$mn:0000A0D3                 mov     ecx, [ebp+var_10]
.text$mn:0000A0D6                 mov     edx, [ecx]
.text$mn:0000A0D8                 mov     eax, [ebp+arg_4]
.text$mn:0000A0DB                 cmp     eax, [edx+8]
.text$mn:0000A0DE                 jnb     short loc_A0EF
.text$mn:0000A0E0
.text$mn:0000A0E0 loc_A0E0:                               ; CODE XREF: std::vector<wchar_t,std::allocator<wchar_t>>::_Orphan_range(wchar_t *,wchar_t *)+5Dj
.text$mn:0000A0E0                 mov     ecx, [ebp+var_10]
.text$mn:0000A0E3                 mov     ecx, [ecx]      ; this
.text$mn:0000A0E5                 call    ?_Getpnext@_Iterator_base12@std@@QAEPAPAU12@XZ ; std::_Iterator_base12::_Getpnext(void)
.text$mn:0000A0EA                 mov     [ebp+var_10], eax
.text$mn:0000A0ED                 jmp     short loc_A10A
.text$mn:0000A0EF ; ---------------------------------------------------------------------------
.text$mn:0000A0EF
.text$mn:0000A0EF loc_A0EF:                               ; CODE XREF: std::vector<wchar_t,std::allocator<wchar_t>>::_Orphan_range(wchar_t *,wchar_t *)+6Aj
.text$mn:0000A0EF                 mov     edx, [ebp+var_10]
.text$mn:0000A0F2                 mov     ecx, [edx]      ; this
.text$mn:0000A0F4                 call    ?_Clrcont@_Iterator_base12@std@@QAEXXZ ; std::_Iterator_base12::_Clrcont(void)
.text$mn:0000A0F9                 mov     eax, [ebp+var_10]
.text$mn:0000A0FC                 mov     ecx, [eax]      ; this
.text$mn:0000A0FE                 call    ?_Getpnext@_Iterator_base12@std@@QAEPAPAU12@XZ ; std::_Iterator_base12::_Getpnext(void)
.text$mn:0000A103                 mov     ecx, [ebp+var_10]
.text$mn:0000A106                 mov     edx, [eax]
.text$mn:0000A108                 mov     [ecx], edx
.text$mn:0000A10A
.text$mn:0000A10A loc_A10A:                               ; CODE XREF: std::vector<wchar_t,std::allocator<wchar_t>>::_Orphan_range(wchar_t *,wchar_t *)+79j
.text$mn:0000A10A                 jmp     short loc_A0BE
.text$mn:0000A10C ; ---------------------------------------------------------------------------
.text$mn:0000A10C
.text$mn:0000A10C loc_A10C:                               ; CODE XREF: std::vector<wchar_t,std::allocator<wchar_t>>::_Orphan_range(wchar_t *,wchar_t *)+48j
.text$mn:0000A10C                                         ; std::vector<wchar_t,std::allocator<wchar_t>>::_Orphan_range(wchar_t *,wchar_t *)+50j
.text$mn:0000A10C                 mov     [ebp+var_4], 0FFFFFFFFh
.text$mn:0000A113                 lea     ecx, [ebp+var_18] ; this
.text$mn:0000A116                 call    ??1_Lockit@std@@QAE@XZ ; std::_Lockit::~_Lockit(void)
.text$mn:0000A11B                 mov     ecx, [ebp+var_C]
.text$mn:0000A11E                 mov     large fs:0, ecx
.text$mn:0000A125                 pop     ecx
.text$mn:0000A126                 mov     esp, ebp
.text$mn:0000A128                 pop     ebp
.text$mn:0000A129                 retn    8
.text$mn:0000A129 ?_Orphan_range@?$vector@_WV?$allocator@_W@std@@@std@@IBEXPA_W0@Z endp
.text$mn:0000A129
.text$mn:0000A129 _text$mn        ends
.text$mn:0000A129
.text$x:0000A12C ; ===========================================================================
.text$x:0000A12C
.text$x:0000A12C ; Segment type: Pure code
.text$x:0000A12C ; Segment permissions: Read/Execute
.text$x:0000A12C _text$x         segment para public 'CODE' use32
.text$x:0000A12C                 assume cs:_text$x
.text$x:0000A12C                 ;org 0A12Ch
.text$x:0000A12C ; COMDAT (pick associative to section at A074)
.text$x:0000A12C                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text$x:0000A12C
.text$x:0000A12C ; =============== S U B R O U T I N E =======================================
.text$x:0000A12C
.text$x:0000A12C
.text$x:0000A12C __unwindfunclet$?_Orphan_range@?$vector@_WV?$allocator@_W@std@@@std@@IBEXPA_W0@Z$0 proc near
.text$x:0000A12C                                         ; DATA XREF: .xdata$x:0000E64Co
.text$x:0000A12C                 lea     ecx, [ebp-18h]  ; this
.text$x:0000A12F                 jmp     ??1_Lockit@std@@QAE@XZ ; std::_Lockit::~_Lockit(void)
.text$x:0000A12F __unwindfunclet$?_Orphan_range@?$vector@_WV?$allocator@_W@std@@@std@@IBEXPA_W0@Z$0 endp
.text$x:0000A12F
.text$x:0000A134
.text$x:0000A134 ; =============== S U B R O U T I N E =======================================
.text$x:0000A134
.text$x:0000A134
.text$x:0000A134 __ehhandler$?_Orphan_range@?$vector@_WV?$allocator@_W@std@@@std@@IBEXPA_W0@Z proc near
.text$x:0000A134                                         ; DATA XREF: std::vector<wchar_t,std::allocator<wchar_t>>::_Orphan_range(wchar_t *,wchar_t *)+5o
.text$x:0000A134
.text$x:0000A134 arg_4           = dword ptr  8
.text$x:0000A134
.text$x:0000A134                 mov     edx, [esp+arg_4]
.text$x:0000A138                 lea     eax, [edx+0Ch]
.text$x:0000A13B                 mov     ecx, [edx-10h]
.text$x:0000A13E                 xor     ecx, eax
.text$x:0000A140                 call    @__security_check_cookie@4 ; __security_check_cookie(x)
.text$x:0000A145                 mov     eax, offset __ehfuncinfo$?_Orphan_range@?$vector@_WV?$allocator@_W@std@@@std@@IBEXPA_W0@Z
.text$x:0000A14A                 jmp     ___CxxFrameHandler3
.text$x:0000A14A __ehhandler$?_Orphan_range@?$vector@_WV?$allocator@_W@std@@@std@@IBEXPA_W0@Z endp
.text$x:0000A14A
.text$x:0000A14A ; ---------------------------------------------------------------------------
.text$x:0000A14F                 align 10h
.text$x:0000A14F _text$x         ends
.text$x:0000A14F
.text$mn:0000A150 ; ===========================================================================
.text$mn:0000A150
.text$mn:0000A150 ; Segment type: Pure code
.text$mn:0000A150 ; Segment permissions: Read/Execute
.text$mn:0000A150 _text$mn        segment para public 'CODE' use32
.text$mn:0000A150                 assume cs:_text$mn
.text$mn:0000A150                 ;org 0A150h
.text$mn:0000A150 ; COMDAT (pick any)
.text$mn:0000A150                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text$mn:0000A150
.text$mn:0000A150 ; =============== S U B R O U T I N E =======================================
.text$mn:0000A150
.text$mn:0000A150 ; Attributes: bp-based frame
.text$mn:0000A150
.text$mn:0000A150 ; public: static unsigned int __cdecl std::basic_string<wchar_t, struct std::char_traits<wchar_t>, class std::allocator<wchar_t>>::_Pdif(class std::_String_const_iterator<class std::_String_val<struct std::_Simple_types<wchar_t>>>, class std::_String_const_iterator<class std::_String_val<struct std::_Simple_types<wchar_t>>>)
.text$mn:0000A150                 public ?_Pdif@?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@SAIV?$_String_const_iterator@V?$_String_val@U?$_Simple_types@_W@std@@@std@@@2@0@Z
.text$mn:0000A150 ?_Pdif@?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@SAIV?$_String_const_iterator@V?$_String_val@U?$_Simple_types@_W@std@@@std@@@2@0@Z proc near
.text$mn:0000A150                                         ; CODE XREF: std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>>::insert(std::_String_const_iterator<std::_String_val<std::_Simple_types<wchar_t>>>,wchar_t)+8Fp
.text$mn:0000A150
.text$mn:0000A150 var_14          = dword ptr -14h
.text$mn:0000A150 var_10          = dword ptr -10h
.text$mn:0000A150 var_C           = dword ptr -0Ch
.text$mn:0000A150 var_4           = dword ptr -4
.text$mn:0000A150 arg_0           = byte ptr  8
.text$mn:0000A150 arg_8           = dword ptr  10h
.text$mn:0000A150 arg_C           = byte ptr  14h
.text$mn:0000A150
.text$mn:0000A150                 push    ebp
.text$mn:0000A151                 mov     ebp, esp
.text$mn:0000A153                 push    0FFFFFFFFh
.text$mn:0000A155                 push    offset __ehhandler$?_Pdif@?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@SAIV?$_String_const_iterator@V?$_String_val@U?$_Simple_types@_W@std@@@std@@@2@0@Z
.text$mn:0000A15A                 mov     eax, large fs:0
.text$mn:0000A160                 push    eax
.text$mn:0000A161                 sub     esp, 8
.text$mn:0000A164                 mov     eax, dword ptr ds:___security_cookie
.text$mn:0000A169                 xor     eax, ebp
.text$mn:0000A16B                 push    eax
.text$mn:0000A16C                 lea     eax, [ebp+var_C]
.text$mn:0000A16F                 mov     large fs:0, eax
.text$mn:0000A175                 mov     [ebp+var_4], 1
.text$mn:0000A17C                 cmp     [ebp+arg_8], 0
.text$mn:0000A180                 jnz     short loc_A18B
.text$mn:0000A182                 mov     [ebp+var_10], 0
.text$mn:0000A189                 jmp     short loc_A19A
.text$mn:0000A18B ; ---------------------------------------------------------------------------
.text$mn:0000A18B
.text$mn:0000A18B loc_A18B:                               ; CODE XREF: std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>>::_Pdif(std::_String_const_iterator<std::_String_val<std::_Simple_types<wchar_t>>>,std::_String_const_iterator<std::_String_val<std::_Simple_types<wchar_t>>>)+30j
.text$mn:0000A18B                 lea     eax, [ebp+arg_C]
.text$mn:0000A18E                 push    eax             ; std::_Iterator_base12 *
.text$mn:0000A18F                 lea     ecx, [ebp+arg_0]
.text$mn:0000A192                 call    ??G?$_String_const_iterator@V?$_String_val@U?$_Simple_types@_W@std@@@std@@@std@@QBEHABV01@@Z ; std::_String_const_iterator<std::_String_val<std::_Simple_types<wchar_t>>>::operator-(std::_String_const_iterator<std::_String_val<std::_Simple_types<wchar_t>>> const &)
.text$mn:0000A197                 mov     [ebp+var_10], eax
.text$mn:0000A19A
.text$mn:0000A19A loc_A19A:                               ; CODE XREF: std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>>::_Pdif(std::_String_const_iterator<std::_String_val<std::_Simple_types<wchar_t>>>,std::_String_const_iterator<std::_String_val<std::_Simple_types<wchar_t>>>)+39j
.text$mn:0000A19A                 mov     ecx, [ebp+var_10]
.text$mn:0000A19D                 mov     [ebp+var_14], ecx
.text$mn:0000A1A0                 mov     byte ptr [ebp+var_4], 0
.text$mn:0000A1A4                 lea     ecx, [ebp+arg_0]
.text$mn:0000A1A7                 call    ??1?$_String_const_iterator@V?$_String_val@U?$_Simple_types@_W@std@@@std@@@std@@QAE@XZ ; std::_String_const_iterator<std::_String_val<std::_Simple_types<wchar_t>>>::~_String_const_iterator<std::_String_val<std::_Simple_types<wchar_t>>>(void)
.text$mn:0000A1AC                 mov     [ebp+var_4], 0FFFFFFFFh
.text$mn:0000A1B3                 lea     ecx, [ebp+arg_C]
.text$mn:0000A1B6                 call    ??1?$_String_const_iterator@V?$_String_val@U?$_Simple_types@_W@std@@@std@@@std@@QAE@XZ ; std::_String_const_iterator<std::_String_val<std::_Simple_types<wchar_t>>>::~_String_const_iterator<std::_String_val<std::_Simple_types<wchar_t>>>(void)
.text$mn:0000A1BB                 mov     eax, [ebp+var_14]
.text$mn:0000A1BE                 mov     ecx, [ebp+var_C]
.text$mn:0000A1C1                 mov     large fs:0, ecx
.text$mn:0000A1C8                 pop     ecx
.text$mn:0000A1C9                 mov     esp, ebp
.text$mn:0000A1CB                 pop     ebp
.text$mn:0000A1CC                 retn
.text$mn:0000A1CC ?_Pdif@?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@SAIV?$_String_const_iterator@V?$_String_val@U?$_Simple_types@_W@std@@@std@@@2@0@Z endp
.text$mn:0000A1CC
.text$mn:0000A1CC ; ---------------------------------------------------------------------------
.text$mn:0000A1CD                 align 10h
.text$mn:0000A1CD _text$mn        ends
.text$mn:0000A1CD
.text$x:0000A1D0 ; ===========================================================================
.text$x:0000A1D0
.text$x:0000A1D0 ; Segment type: Pure code
.text$x:0000A1D0 ; Segment permissions: Read/Execute
.text$x:0000A1D0 _text$x         segment para public 'CODE' use32
.text$x:0000A1D0                 assume cs:_text$x
.text$x:0000A1D0                 ;org 0A1D0h
.text$x:0000A1D0 ; COMDAT (pick associative to section at A150)
.text$x:0000A1D0                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text$x:0000A1D0
.text$x:0000A1D0 ; =============== S U B R O U T I N E =======================================
.text$x:0000A1D0
.text$x:0000A1D0
.text$x:0000A1D0 __unwindfunclet$?_Pdif@?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@SAIV?$_String_const_iterator@V?$_String_val@U?$_Simple_types@_W@std@@@std@@@2@0@Z$0 proc near
.text$x:0000A1D0                                         ; DATA XREF: .xdata$x:0000DCE8o
.text$x:0000A1D0                 lea     ecx, [ebp+14h]
.text$x:0000A1D3                 jmp     ??1?$_String_const_iterator@V?$_String_val@U?$_Simple_types@_W@std@@@std@@@std@@QAE@XZ ; std::_String_const_iterator<std::_String_val<std::_Simple_types<wchar_t>>>::~_String_const_iterator<std::_String_val<std::_Simple_types<wchar_t>>>(void)
.text$x:0000A1D3 __unwindfunclet$?_Pdif@?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@SAIV?$_String_const_iterator@V?$_String_val@U?$_Simple_types@_W@std@@@std@@@2@0@Z$0 endp
.text$x:0000A1D3
.text$x:0000A1D8
.text$x:0000A1D8 ; =============== S U B R O U T I N E =======================================
.text$x:0000A1D8
.text$x:0000A1D8
.text$x:0000A1D8 __unwindfunclet$?_Pdif@?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@SAIV?$_String_const_iterator@V?$_String_val@U?$_Simple_types@_W@std@@@std@@@2@0@Z$1 proc near
.text$x:0000A1D8                                         ; DATA XREF: .xdata$x:0000DCF0o
.text$x:0000A1D8                 lea     ecx, [ebp+8]
.text$x:0000A1DB                 jmp     ??1?$_String_const_iterator@V?$_String_val@U?$_Simple_types@_W@std@@@std@@@std@@QAE@XZ ; std::_String_const_iterator<std::_String_val<std::_Simple_types<wchar_t>>>::~_String_const_iterator<std::_String_val<std::_Simple_types<wchar_t>>>(void)
.text$x:0000A1DB __unwindfunclet$?_Pdif@?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@SAIV?$_String_const_iterator@V?$_String_val@U?$_Simple_types@_W@std@@@std@@@2@0@Z$1 endp
.text$x:0000A1DB
.text$x:0000A1E0
.text$x:0000A1E0 ; =============== S U B R O U T I N E =======================================
.text$x:0000A1E0
.text$x:0000A1E0
.text$x:0000A1E0 __ehhandler$?_Pdif@?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@SAIV?$_String_const_iterator@V?$_String_val@U?$_Simple_types@_W@std@@@std@@@2@0@Z proc near
.text$x:0000A1E0                                         ; DATA XREF: std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>>::_Pdif(std::_String_const_iterator<std::_String_val<std::_Simple_types<wchar_t>>>,std::_String_const_iterator<std::_String_val<std::_Simple_types<wchar_t>>>)+5o
.text$x:0000A1E0
.text$x:0000A1E0 arg_4           = dword ptr  8
.text$x:0000A1E0
.text$x:0000A1E0                 mov     edx, [esp+arg_4]
.text$x:0000A1E4                 lea     eax, [edx+0Ch]
.text$x:0000A1E7                 mov     ecx, [edx-0Ch]
.text$x:0000A1EA                 xor     ecx, eax
.text$x:0000A1EC                 call    @__security_check_cookie@4 ; __security_check_cookie(x)
.text$x:0000A1F1                 mov     eax, offset __ehfuncinfo$?_Pdif@?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@SAIV?$_String_const_iterator@V?$_String_val@U?$_Simple_types@_W@std@@@std@@@2@0@Z
.text$x:0000A1F6                 jmp     ___CxxFrameHandler3
.text$x:0000A1F6 __ehhandler$?_Pdif@?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@SAIV?$_String_const_iterator@V?$_String_val@U?$_Simple_types@_W@std@@@std@@@2@0@Z endp
.text$x:0000A1F6
.text$x:0000A1F6 ; ---------------------------------------------------------------------------
.text$x:0000A1FB                 align 4
.text$x:0000A1FB _text$x         ends
.text$x:0000A1FB
.text$mn:0000A1FC ; ===========================================================================
.text$mn:0000A1FC
.text$mn:0000A1FC ; Segment type: Pure code
.text$mn:0000A1FC ; Segment permissions: Read/Execute
.text$mn:0000A1FC _text$mn        segment para public 'CODE' use32
.text$mn:0000A1FC                 assume cs:_text$mn
.text$mn:0000A1FC                 ;org 0A1FCh
.text$mn:0000A1FC ; COMDAT (pick any)
.text$mn:0000A1FC                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text$mn:0000A1FC
.text$mn:0000A1FC ; =============== S U B R O U T I N E =======================================
.text$mn:0000A1FC
.text$mn:0000A1FC ; Attributes: bp-based frame
.text$mn:0000A1FC
.text$mn:0000A1FC ; protected: void __thiscall std::vector<class std::basic_string<wchar_t, struct std::char_traits<wchar_t>, class std::allocator<wchar_t>>, class std::allocator<class std::basic_string<wchar_t, struct std::char_traits<wchar_t>, class std::allocator<wchar_t>>>>::_Reallocate(unsigned int)
.text$mn:0000A1FC                 public ?_Reallocate@?$vector@V?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@V?$allocator@V?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@@2@@std@@IAEXI@Z
.text$mn:0000A1FC ?_Reallocate@?$vector@V?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@V?$allocator@V?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@@2@@std@@IAEXI@Z proc near
.text$mn:0000A1FC                                         ; CODE XREF: std::vector<std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>>,std::allocator<std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>>>>::_Reserve(uint)+4Ep
.text$mn:0000A1FC
.text$mn:0000A1FC var_20          = dword ptr -20h
.text$mn:0000A1FC var_1C          = dword ptr -1Ch
.text$mn:0000A1FC var_18          = dword ptr -18h
.text$mn:0000A1FC var_13          = byte ptr -13h
.text$mn:0000A1FC var_11          = byte ptr -11h
.text$mn:0000A1FC var_10          = dword ptr -10h
.text$mn:0000A1FC var_C           = dword ptr -0Ch
.text$mn:0000A1FC var_4           = dword ptr -4
.text$mn:0000A1FC arg_0           = dword ptr  8
.text$mn:0000A1FC
.text$mn:0000A1FC ; FUNCTION CHUNK AT .text$mn:0000A292 SIZE 00000009 BYTES
.text$mn:0000A1FC ; FUNCTION CHUNK AT .text$mn:0000A2A2 SIZE 00000098 BYTES
.text$mn:0000A1FC
.text$mn:0000A1FC                 push    ebp
.text$mn:0000A1FD                 mov     ebp, esp
.text$mn:0000A1FF                 push    0FFFFFFFFh
.text$mn:0000A201                 push    offset __ehhandler$?_Reallocate@?$vector@V?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@V?$allocator@V?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@@2@@std@@IAEXI@Z
.text$mn:0000A206                 mov     eax, large fs:0
.text$mn:0000A20C                 push    eax
.text$mn:0000A20D                 push    ecx
.text$mn:0000A20E                 sub     esp, 10h
.text$mn:0000A211                 push    ebx
.text$mn:0000A212                 push    esi
.text$mn:0000A213                 push    edi
.text$mn:0000A214                 mov     eax, dword ptr ds:___security_cookie
.text$mn:0000A219                 xor     eax, ebp
.text$mn:0000A21B                 push    eax
.text$mn:0000A21C                 lea     eax, [ebp+var_C]
.text$mn:0000A21F                 mov     large fs:0, eax
.text$mn:0000A225                 mov     [ebp+var_10], esp
.text$mn:0000A228                 mov     [ebp+var_18], ecx
.text$mn:0000A22B                 mov     eax, [ebp+arg_0]
.text$mn:0000A22E                 push    eax
.text$mn:0000A22F                 lea     ecx, [ebp+var_11]
.text$mn:0000A232                 push    ecx
.text$mn:0000A233                 mov     ecx, [ebp+var_18]
.text$mn:0000A236                 call    ?_Getal@?$_Vector_alloc@$0A@U?$_Vec_base_types@V?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@V?$allocator@V?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@@2@@std@@@std@@QBE?AU?$_Wrap_alloc@V?$allocator@V?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@@std@@@2@XZ ; std::_Vector_alloc<0,std::_Vec_base_types<std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>>,std::allocator<std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>>>>>::_Getal(void)
.text$mn:0000A23B                 mov     ecx, eax
.text$mn:0000A23D                 call    ?allocate@?$_Wrap_alloc@V?$allocator@V?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@@std@@@std@@QAEPAV?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@2@I@Z ; std::_Wrap_alloc<std::allocator<std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>>>>::allocate(uint)
.text$mn:0000A242                 mov     [ebp+var_1C], eax
.text$mn:0000A245                 mov     [ebp+var_4], 0
.text$mn:0000A24C                 mov     edx, [ebp+var_1C]
.text$mn:0000A24F                 push    edx
.text$mn:0000A250                 mov     eax, [ebp+var_18]
.text$mn:0000A253                 mov     ecx, [eax+8]
.text$mn:0000A256                 push    ecx
.text$mn:0000A257                 mov     edx, [ebp+var_18]
.text$mn:0000A25A                 mov     eax, [edx+4]
.text$mn:0000A25D                 push    eax
.text$mn:0000A25E                 mov     ecx, [ebp+var_18]
.text$mn:0000A261                 call    ??$_Umove@PAV?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@@?$vector@V?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@V?$allocator@V?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@@2@@std@@IAEPAV?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@1@PAV21@00@Z ; std::vector<std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>>,std::allocator<std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>>>>::_Umove<std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>> *>(std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>> *,std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>> *,std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>> *)
.text$mn:0000A266                 jmp     short loc_A292
.text$mn:0000A266 ?_Reallocate@?$vector@V?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@V?$allocator@V?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@@2@@std@@IAEXI@Z endp
.text$mn:0000A266
.text$mn:0000A268
.text$mn:0000A268 ; =============== S U B R O U T I N E =======================================
.text$mn:0000A268
.text$mn:0000A268 ; Attributes: noreturn
.text$mn:0000A268
.text$mn:0000A268 __catch$?_Reallocate@?$vector@V?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@V?$allocator@V?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@@2@@std@@IAEXI@Z$0 proc near
.text$mn:0000A268                                         ; DATA XREF: .xdata$x:0000E340o
.text$mn:0000A268                 mov     ecx, [ebp+8]
.text$mn:0000A26B                 push    ecx             ; int
.text$mn:0000A26C                 mov     edx, [ebp-1Ch]
.text$mn:0000A26F                 push    edx             ; void *
.text$mn:0000A270                 lea     eax, [ebp-12h]
.text$mn:0000A273                 push    eax
.text$mn:0000A274                 mov     ecx, [ebp-18h]
.text$mn:0000A277                 call    ?_Getal@?$_Vector_alloc@$0A@U?$_Vec_base_types@V?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@V?$allocator@V?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@@2@@std@@@std@@QBE?AU?$_Wrap_alloc@V?$allocator@V?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@@std@@@2@XZ ; std::_Vector_alloc<0,std::_Vec_base_types<std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>>,std::allocator<std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>>>>>::_Getal(void)
.text$mn:0000A27C                 mov     ecx, eax
.text$mn:0000A27E                 call    ?deallocate@?$_Wrap_alloc@V?$allocator@V?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@@std@@@std@@QAEXPAV?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@2@I@Z ; std::_Wrap_alloc<std::allocator<std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>>>>::deallocate(std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>> *,uint)
.text$mn:0000A283                 push    0
.text$mn:0000A285                 push    0
.text$mn:0000A287                 call    __CxxThrowException@8 ; _CxxThrowException(x,x)
.text$mn:0000A287 __catch$?_Reallocate@?$vector@V?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@V?$allocator@V?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@@2@@std@@IAEXI@Z$0 endp
.text$mn:0000A287
.text$mn:0000A28C ; ---------------------------------------------------------------------------
.text$mn:0000A28C                 mov     eax, offset $LN8
.text$mn:0000A291                 retn
.text$mn:0000A292 ; ---------------------------------------------------------------------------
.text$mn:0000A292 ; START OF FUNCTION CHUNK FOR ?_Reallocate@?$vector@V?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@V?$allocator@V?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@@2@@std@@IAEXI@Z
.text$mn:0000A292
.text$mn:0000A292 loc_A292:                               ; CODE XREF: std::vector<std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>>,std::allocator<std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>>>>::_Reallocate(uint)+6Aj
.text$mn:0000A292                 mov     [ebp+var_4], 0FFFFFFFFh
.text$mn:0000A299                 jmp     short loc_A2A2
.text$mn:0000A299 ; END OF FUNCTION CHUNK FOR ?_Reallocate@?$vector@V?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@V?$allocator@V?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@@2@@std@@IAEXI@Z
.text$mn:0000A29B
.text$mn:0000A29B ; =============== S U B R O U T I N E =======================================
.text$mn:0000A29B
.text$mn:0000A29B
.text$mn:0000A29B $LN8            proc near               ; DATA XREF: .text$mn:0000A28Co
.text$mn:0000A29B                 mov     dword ptr [ebp-4], 0FFFFFFFFh
.text$mn:0000A29B $LN8            endp ; sp-analysis failed
.text$mn:0000A29B
.text$mn:0000A2A2 ; START OF FUNCTION CHUNK FOR ?_Reallocate@?$vector@V?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@V?$allocator@V?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@@2@@std@@IAEXI@Z
.text$mn:0000A2A2
.text$mn:0000A2A2 loc_A2A2:                               ; CODE XREF: std::vector<std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>>,std::allocator<std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>>>>::_Reallocate(uint)+9Dj
.text$mn:0000A2A2                 mov     ecx, [ebp+var_18]
.text$mn:0000A2A5                 call    ?size@?$vector@V?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@V?$allocator@V?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@@2@@std@@QBEIXZ ; std::vector<std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>>,std::allocator<std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>>>>::size(void)
.text$mn:0000A2AA                 mov     [ebp+var_20], eax
.text$mn:0000A2AD                 mov     ecx, [ebp+var_18]
.text$mn:0000A2B0                 cmp     dword ptr [ecx+4], 0
.text$mn:0000A2B4                 jz      short loc_A2FB
.text$mn:0000A2B6                 mov     edx, [ebp+var_18]
.text$mn:0000A2B9                 mov     eax, [edx+8]
.text$mn:0000A2BC                 push    eax
.text$mn:0000A2BD                 mov     ecx, [ebp+var_18]
.text$mn:0000A2C0                 mov     edx, [ecx+4]
.text$mn:0000A2C3                 push    edx
.text$mn:0000A2C4                 mov     ecx, [ebp+var_18]
.text$mn:0000A2C7                 call    ?_Destroy@?$vector@V?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@V?$allocator@V?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@@2@@std@@IAEXPAV?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@2@0@Z ; std::vector<std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>>,std::allocator<std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>>>>::_Destroy(std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>> *,std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>> *)
.text$mn:0000A2CC                 mov     eax, [ebp+var_18]
.text$mn:0000A2CF                 mov     ecx, [ebp+var_18]
.text$mn:0000A2D2                 mov     eax, [eax+0Ch]
.text$mn:0000A2D5                 sub     eax, [ecx+4]
.text$mn:0000A2D8                 cdq
.text$mn:0000A2D9                 mov     ecx, 1Ch
.text$mn:0000A2DE                 idiv    ecx
.text$mn:0000A2E0                 push    eax             ; int
.text$mn:0000A2E1                 mov     edx, [ebp+var_18]
.text$mn:0000A2E4                 mov     eax, [edx+4]
.text$mn:0000A2E7                 push    eax             ; void *
.text$mn:0000A2E8                 lea     ecx, [ebp+var_13]
.text$mn:0000A2EB                 push    ecx
.text$mn:0000A2EC                 mov     ecx, [ebp+var_18]
.text$mn:0000A2EF                 call    ?_Getal@?$_Vector_alloc@$0A@U?$_Vec_base_types@V?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@V?$allocator@V?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@@2@@std@@@std@@QBE?AU?$_Wrap_alloc@V?$allocator@V?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@@std@@@2@XZ ; std::_Vector_alloc<0,std::_Vec_base_types<std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>>,std::allocator<std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>>>>>::_Getal(void)
.text$mn:0000A2F4                 mov     ecx, eax
.text$mn:0000A2F6                 call    ?deallocate@?$_Wrap_alloc@V?$allocator@V?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@@std@@@std@@QAEXPAV?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@2@I@Z ; std::_Wrap_alloc<std::allocator<std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>>>>::deallocate(std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>> *,uint)
.text$mn:0000A2FB
.text$mn:0000A2FB loc_A2FB:                               ; CODE XREF: std::vector<std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>>,std::allocator<std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>>>>::_Reallocate(uint)+B8j
.text$mn:0000A2FB                 mov     ecx, [ebp+var_18] ; this
.text$mn:0000A2FE                 call    ?_Orphan_all@_Container_base12@std@@QAEXXZ ; std::_Container_base12::_Orphan_all(void)
.text$mn:0000A303                 imul    edx, [ebp+arg_0], 1Ch
.text$mn:0000A307                 add     edx, [ebp+var_1C]
.text$mn:0000A30A                 mov     eax, [ebp+var_18]
.text$mn:0000A30D                 mov     [eax+0Ch], edx
.text$mn:0000A310                 imul    ecx, [ebp+var_20], 1Ch
.text$mn:0000A314                 add     ecx, [ebp+var_1C]
.text$mn:0000A317                 mov     edx, [ebp+var_18]
.text$mn:0000A31A                 mov     [edx+8], ecx
.text$mn:0000A31D                 mov     eax, [ebp+var_18]
.text$mn:0000A320                 mov     ecx, [ebp+var_1C]
.text$mn:0000A323                 mov     [eax+4], ecx
.text$mn:0000A326                 mov     ecx, [ebp+var_C]
.text$mn:0000A329                 mov     large fs:0, ecx
.text$mn:0000A330                 pop     ecx
.text$mn:0000A331                 pop     edi
.text$mn:0000A332                 pop     esi
.text$mn:0000A333                 pop     ebx
.text$mn:0000A334                 mov     esp, ebp
.text$mn:0000A336                 pop     ebp
.text$mn:0000A337                 retn    4
.text$mn:0000A337 ; END OF FUNCTION CHUNK FOR ?_Reallocate@?$vector@V?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@V?$allocator@V?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@@2@@std@@IAEXI@Z
.text$mn:0000A337 ; ---------------------------------------------------------------------------
.text$mn:0000A33A                 align 4
.text$mn:0000A33A _text$mn        ends
.text$mn:0000A33A
.text$x:0000A33C ; ===========================================================================
.text$x:0000A33C
.text$x:0000A33C ; Segment type: Pure code
.text$x:0000A33C ; Segment permissions: Read/Execute
.text$x:0000A33C _text$x         segment para public 'CODE' use32
.text$x:0000A33C                 assume cs:_text$x
.text$x:0000A33C                 ;org 0A33Ch
.text$x:0000A33C ; COMDAT (pick associative to section at A1FC)
.text$x:0000A33C                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text$x:0000A33C
.text$x:0000A33C ; =============== S U B R O U T I N E =======================================
.text$x:0000A33C
.text$x:0000A33C
.text$x:0000A33C __ehhandler$?_Reallocate@?$vector@V?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@V?$allocator@V?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@@2@@std@@IAEXI@Z proc near
.text$x:0000A33C                                         ; DATA XREF: std::vector<std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>>,std::allocator<std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>>>>::_Reallocate(uint)+5o
.text$x:0000A33C
.text$x:0000A33C arg_4           = dword ptr  8
.text$x:0000A33C
.text$x:0000A33C                 mov     edx, [esp+arg_4]
.text$x:0000A340                 lea     eax, [edx+0Ch]
.text$x:0000A343                 mov     ecx, [edx-24h]
.text$x:0000A346                 xor     ecx, eax
.text$x:0000A348                 call    @__security_check_cookie@4 ; __security_check_cookie(x)
.text$x:0000A34D                 mov     eax, offset __ehfuncinfo$?_Reallocate@?$vector@V?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@V?$allocator@V?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@@2@@std@@IAEXI@Z
.text$x:0000A352                 jmp     ___CxxFrameHandler3
.text$x:0000A352 __ehhandler$?_Reallocate@?$vector@V?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@V?$allocator@V?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@@2@@std@@IAEXI@Z endp
.text$x:0000A352
.text$x:0000A352 ; ---------------------------------------------------------------------------
.text$x:0000A357                 align 4
.text$x:0000A357 _text$x         ends
.text$x:0000A357
.text$mn:0000A358 ; ===========================================================================
.text$mn:0000A358
.text$mn:0000A358 ; Segment type: Pure code
.text$mn:0000A358 ; Segment permissions: Read/Execute
.text$mn:0000A358 _text$mn        segment para public 'CODE' use32
.text$mn:0000A358                 assume cs:_text$mn
.text$mn:0000A358                 ;org 0A358h
.text$mn:0000A358 ; COMDAT (pick any)
.text$mn:0000A358                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text$mn:0000A358
.text$mn:0000A358 ; =============== S U B R O U T I N E =======================================
.text$mn:0000A358
.text$mn:0000A358 ; Attributes: bp-based frame
.text$mn:0000A358
.text$mn:0000A358 ; protected: void __thiscall std::vector<wchar_t, class std::allocator<wchar_t>>::_Reallocate(unsigned int)
.text$mn:0000A358                 public ?_Reallocate@?$vector@_WV?$allocator@_W@std@@@std@@IAEXI@Z
.text$mn:0000A358 ?_Reallocate@?$vector@_WV?$allocator@_W@std@@@std@@IAEXI@Z proc near
.text$mn:0000A358                                         ; CODE XREF: std::vector<wchar_t,std::allocator<wchar_t>>::_Reserve(uint)+4Ep
.text$mn:0000A358
.text$mn:0000A358 var_20          = dword ptr -20h
.text$mn:0000A358 var_1C          = dword ptr -1Ch
.text$mn:0000A358 var_18          = dword ptr -18h
.text$mn:0000A358 var_13          = byte ptr -13h
.text$mn:0000A358 var_11          = byte ptr -11h
.text$mn:0000A358 var_10          = dword ptr -10h
.text$mn:0000A358 var_C           = dword ptr -0Ch
.text$mn:0000A358 var_4           = dword ptr -4
.text$mn:0000A358 arg_0           = dword ptr  8
.text$mn:0000A358
.text$mn:0000A358 ; FUNCTION CHUNK AT .text$mn:0000A3EE SIZE 00000009 BYTES
.text$mn:0000A358 ; FUNCTION CHUNK AT .text$mn:0000A3FE SIZE 00000096 BYTES
.text$mn:0000A358
.text$mn:0000A358                 push    ebp
.text$mn:0000A359                 mov     ebp, esp
.text$mn:0000A35B                 push    0FFFFFFFFh
.text$mn:0000A35D                 push    offset __ehhandler$?_Reallocate@?$vector@_WV?$allocator@_W@std@@@std@@IAEXI@Z
.text$mn:0000A362                 mov     eax, large fs:0
.text$mn:0000A368                 push    eax
.text$mn:0000A369                 push    ecx
.text$mn:0000A36A                 sub     esp, 10h
.text$mn:0000A36D                 push    ebx
.text$mn:0000A36E                 push    esi
.text$mn:0000A36F                 push    edi
.text$mn:0000A370                 mov     eax, dword ptr ds:___security_cookie
.text$mn:0000A375                 xor     eax, ebp
.text$mn:0000A377                 push    eax
.text$mn:0000A378                 lea     eax, [ebp+var_C]
.text$mn:0000A37B                 mov     large fs:0, eax
.text$mn:0000A381                 mov     [ebp+var_10], esp
.text$mn:0000A384                 mov     [ebp+var_18], ecx
.text$mn:0000A387                 mov     eax, [ebp+arg_0]
.text$mn:0000A38A                 push    eax
.text$mn:0000A38B                 lea     ecx, [ebp+var_11]
.text$mn:0000A38E                 push    ecx
.text$mn:0000A38F                 mov     ecx, [ebp+var_18]
.text$mn:0000A392                 call    ?_Getal@?$_Vector_alloc@$0A@U?$_Vec_base_types@_WV?$allocator@_W@std@@@std@@@std@@QBE?AU?$_Wrap_alloc@V?$allocator@_W@std@@@2@XZ ; std::_Vector_alloc<0,std::_Vec_base_types<wchar_t,std::allocator<wchar_t>>>::_Getal(void)
.text$mn:0000A397                 mov     ecx, eax
.text$mn:0000A399                 call    ?allocate@?$_Wrap_alloc@V?$allocator@_W@std@@@std@@QAEPA_WI@Z ; std::_Wrap_alloc<std::allocator<wchar_t>>::allocate(uint)
.text$mn:0000A39E                 mov     [ebp+var_1C], eax
.text$mn:0000A3A1                 mov     [ebp+var_4], 0
.text$mn:0000A3A8                 mov     edx, [ebp+var_1C]
.text$mn:0000A3AB                 push    edx
.text$mn:0000A3AC                 mov     eax, [ebp+var_18]
.text$mn:0000A3AF                 mov     ecx, [eax+8]
.text$mn:0000A3B2                 push    ecx
.text$mn:0000A3B3                 mov     edx, [ebp+var_18]
.text$mn:0000A3B6                 mov     eax, [edx+4]
.text$mn:0000A3B9                 push    eax
.text$mn:0000A3BA                 mov     ecx, [ebp+var_18]
.text$mn:0000A3BD                 call    ??$_Umove@PA_W@?$vector@_WV?$allocator@_W@std@@@std@@IAEPA_WPA_W00@Z ; std::vector<wchar_t,std::allocator<wchar_t>>::_Umove<wchar_t *>(wchar_t *,wchar_t *,wchar_t *)
.text$mn:0000A3C2                 jmp     short loc_A3EE
.text$mn:0000A3C2 ?_Reallocate@?$vector@_WV?$allocator@_W@std@@@std@@IAEXI@Z endp
.text$mn:0000A3C2
.text$mn:0000A3C4
.text$mn:0000A3C4 ; =============== S U B R O U T I N E =======================================
.text$mn:0000A3C4
.text$mn:0000A3C4 ; Attributes: noreturn
.text$mn:0000A3C4
.text$mn:0000A3C4 __catch$?_Reallocate@?$vector@_WV?$allocator@_W@std@@@std@@IAEXI@Z$0 proc near
.text$mn:0000A3C4                                         ; DATA XREF: .xdata$x:0000E5FCo
.text$mn:0000A3C4                 mov     ecx, [ebp+8]
.text$mn:0000A3C7                 push    ecx             ; int
.text$mn:0000A3C8                 mov     edx, [ebp-1Ch]
.text$mn:0000A3CB                 push    edx             ; void *
.text$mn:0000A3CC                 lea     eax, [ebp-12h]
.text$mn:0000A3CF                 push    eax
.text$mn:0000A3D0                 mov     ecx, [ebp-18h]
.text$mn:0000A3D3                 call    ?_Getal@?$_Vector_alloc@$0A@U?$_Vec_base_types@_WV?$allocator@_W@std@@@std@@@std@@QBE?AU?$_Wrap_alloc@V?$allocator@_W@std@@@2@XZ ; std::_Vector_alloc<0,std::_Vec_base_types<wchar_t,std::allocator<wchar_t>>>::_Getal(void)
.text$mn:0000A3D8                 mov     ecx, eax
.text$mn:0000A3DA                 call    ?deallocate@?$_Wrap_alloc@V?$allocator@_W@std@@@std@@QAEXPA_WI@Z ; std::_Wrap_alloc<std::allocator<wchar_t>>::deallocate(wchar_t *,uint)
.text$mn:0000A3DF                 push    0
.text$mn:0000A3E1                 push    0
.text$mn:0000A3E3                 call    __CxxThrowException@8 ; _CxxThrowException(x,x)
.text$mn:0000A3E3 __catch$?_Reallocate@?$vector@_WV?$allocator@_W@std@@@std@@IAEXI@Z$0 endp
.text$mn:0000A3E3
.text$mn:0000A3E8 ; ---------------------------------------------------------------------------
.text$mn:0000A3E8                 mov     eax, offset $LN8_0
.text$mn:0000A3ED                 retn
.text$mn:0000A3EE ; ---------------------------------------------------------------------------
.text$mn:0000A3EE ; START OF FUNCTION CHUNK FOR ?_Reallocate@?$vector@_WV?$allocator@_W@std@@@std@@IAEXI@Z
.text$mn:0000A3EE
.text$mn:0000A3EE loc_A3EE:                               ; CODE XREF: std::vector<wchar_t,std::allocator<wchar_t>>::_Reallocate(uint)+6Aj
.text$mn:0000A3EE                 mov     [ebp+var_4], 0FFFFFFFFh
.text$mn:0000A3F5                 jmp     short loc_A3FE
.text$mn:0000A3F5 ; END OF FUNCTION CHUNK FOR ?_Reallocate@?$vector@_WV?$allocator@_W@std@@@std@@IAEXI@Z
.text$mn:0000A3F7
.text$mn:0000A3F7 ; =============== S U B R O U T I N E =======================================
.text$mn:0000A3F7
.text$mn:0000A3F7
.text$mn:0000A3F7 $LN8_0          proc near               ; DATA XREF: .text$mn:0000A3E8o
.text$mn:0000A3F7                 mov     dword ptr [ebp-4], 0FFFFFFFFh
.text$mn:0000A3F7 $LN8_0          endp ; sp-analysis failed
.text$mn:0000A3F7
.text$mn:0000A3FE ; START OF FUNCTION CHUNK FOR ?_Reallocate@?$vector@_WV?$allocator@_W@std@@@std@@IAEXI@Z
.text$mn:0000A3FE
.text$mn:0000A3FE loc_A3FE:                               ; CODE XREF: std::vector<wchar_t,std::allocator<wchar_t>>::_Reallocate(uint)+9Dj
.text$mn:0000A3FE                 mov     ecx, [ebp+var_18]
.text$mn:0000A401                 call    ?size@?$vector@_WV?$allocator@_W@std@@@std@@QBEIXZ ; std::vector<wchar_t,std::allocator<wchar_t>>::size(void)
.text$mn:0000A406                 mov     [ebp+var_20], eax
.text$mn:0000A409                 mov     ecx, [ebp+var_18]
.text$mn:0000A40C                 cmp     dword ptr [ecx+4], 0
.text$mn:0000A410                 jz      short loc_A451
.text$mn:0000A412                 mov     edx, [ebp+var_18]
.text$mn:0000A415                 mov     eax, [edx+8]
.text$mn:0000A418                 push    eax
.text$mn:0000A419                 mov     ecx, [ebp+var_18]
.text$mn:0000A41C                 mov     edx, [ecx+4]
.text$mn:0000A41F                 push    edx
.text$mn:0000A420                 mov     ecx, [ebp+var_18]
.text$mn:0000A423                 call    ?_Destroy@?$vector@_WV?$allocator@_W@std@@@std@@IAEXPA_W0@Z ; std::vector<wchar_t,std::allocator<wchar_t>>::_Destroy(wchar_t *,wchar_t *)
.text$mn:0000A428                 mov     eax, [ebp+var_18]
.text$mn:0000A42B                 mov     ecx, [ebp+var_18]
.text$mn:0000A42E                 mov     edx, [eax+0Ch]
.text$mn:0000A431                 sub     edx, [ecx+4]
.text$mn:0000A434                 sar     edx, 1
.text$mn:0000A436                 push    edx             ; int
.text$mn:0000A437                 mov     eax, [ebp+var_18]
.text$mn:0000A43A                 mov     ecx, [eax+4]
.text$mn:0000A43D                 push    ecx             ; void *
.text$mn:0000A43E                 lea     edx, [ebp+var_13]
.text$mn:0000A441                 push    edx
.text$mn:0000A442                 mov     ecx, [ebp+var_18]
.text$mn:0000A445                 call    ?_Getal@?$_Vector_alloc@$0A@U?$_Vec_base_types@_WV?$allocator@_W@std@@@std@@@std@@QBE?AU?$_Wrap_alloc@V?$allocator@_W@std@@@2@XZ ; std::_Vector_alloc<0,std::_Vec_base_types<wchar_t,std::allocator<wchar_t>>>::_Getal(void)
.text$mn:0000A44A                 mov     ecx, eax
.text$mn:0000A44C                 call    ?deallocate@?$_Wrap_alloc@V?$allocator@_W@std@@@std@@QAEXPA_WI@Z ; std::_Wrap_alloc<std::allocator<wchar_t>>::deallocate(wchar_t *,uint)
.text$mn:0000A451
.text$mn:0000A451 loc_A451:                               ; CODE XREF: std::vector<wchar_t,std::allocator<wchar_t>>::_Reallocate(uint)+B8j
.text$mn:0000A451                 mov     ecx, [ebp+var_18] ; this
.text$mn:0000A454                 call    ?_Orphan_all@_Container_base12@std@@QAEXXZ ; std::_Container_base12::_Orphan_all(void)
.text$mn:0000A459                 mov     eax, [ebp+arg_0]
.text$mn:0000A45C                 mov     ecx, [ebp+var_1C]
.text$mn:0000A45F                 lea     edx, [ecx+eax*2]
.text$mn:0000A462                 mov     eax, [ebp+var_18]
.text$mn:0000A465                 mov     [eax+0Ch], edx
.text$mn:0000A468                 mov     ecx, [ebp+var_20]
.text$mn:0000A46B                 mov     edx, [ebp+var_1C]
.text$mn:0000A46E                 lea     eax, [edx+ecx*2]
.text$mn:0000A471                 mov     ecx, [ebp+var_18]
.text$mn:0000A474                 mov     [ecx+8], eax
.text$mn:0000A477                 mov     edx, [ebp+var_18]
.text$mn:0000A47A                 mov     eax, [ebp+var_1C]
.text$mn:0000A47D                 mov     [edx+4], eax
.text$mn:0000A480                 mov     ecx, [ebp+var_C]
.text$mn:0000A483                 mov     large fs:0, ecx
.text$mn:0000A48A                 pop     ecx
.text$mn:0000A48B                 pop     edi
.text$mn:0000A48C                 pop     esi
.text$mn:0000A48D                 pop     ebx
.text$mn:0000A48E                 mov     esp, ebp
.text$mn:0000A490                 pop     ebp
.text$mn:0000A491                 retn    4
.text$mn:0000A491 ; END OF FUNCTION CHUNK FOR ?_Reallocate@?$vector@_WV?$allocator@_W@std@@@std@@IAEXI@Z
.text$mn:0000A491 _text$mn        ends
.text$mn:0000A491
.text$x:0000A494 ; ===========================================================================
.text$x:0000A494
.text$x:0000A494 ; Segment type: Pure code
.text$x:0000A494 ; Segment permissions: Read/Execute
.text$x:0000A494 _text$x         segment para public 'CODE' use32
.text$x:0000A494                 assume cs:_text$x
.text$x:0000A494                 ;org 0A494h
.text$x:0000A494 ; COMDAT (pick associative to section at A358)
.text$x:0000A494                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text$x:0000A494
.text$x:0000A494 ; =============== S U B R O U T I N E =======================================
.text$x:0000A494
.text$x:0000A494
.text$x:0000A494 __ehhandler$?_Reallocate@?$vector@_WV?$allocator@_W@std@@@std@@IAEXI@Z proc near
.text$x:0000A494                                         ; DATA XREF: std::vector<wchar_t,std::allocator<wchar_t>>::_Reallocate(uint)+5o
.text$x:0000A494
.text$x:0000A494 arg_4           = dword ptr  8
.text$x:0000A494
.text$x:0000A494                 mov     edx, [esp+arg_4]
.text$x:0000A498                 lea     eax, [edx+0Ch]
.text$x:0000A49B                 mov     ecx, [edx-24h]
.text$x:0000A49E                 xor     ecx, eax
.text$x:0000A4A0                 call    @__security_check_cookie@4 ; __security_check_cookie(x)
.text$x:0000A4A5                 mov     eax, offset __ehfuncinfo$?_Reallocate@?$vector@_WV?$allocator@_W@std@@@std@@IAEXI@Z
.text$x:0000A4AA                 jmp     ___CxxFrameHandler3
.text$x:0000A4AA __ehhandler$?_Reallocate@?$vector@_WV?$allocator@_W@std@@@std@@IAEXI@Z endp
.text$x:0000A4AA
.text$x:0000A4AA ; ---------------------------------------------------------------------------
.text$x:0000A4AF                 align 10h
.text$x:0000A4AF _text$x         ends
.text$x:0000A4AF
.text$mn:0000A4B0 ; ===========================================================================
.text$mn:0000A4B0
.text$mn:0000A4B0 ; Segment type: Pure code
.text$mn:0000A4B0 ; Segment permissions: Read/Execute
.text$mn:0000A4B0 _text$mn        segment para public 'CODE' use32
.text$mn:0000A4B0                 assume cs:_text$mn
.text$mn:0000A4B0                 ;org 0A4B0h
.text$mn:0000A4B0 ; COMDAT (pick any)
.text$mn:0000A4B0                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text$mn:0000A4B0
.text$mn:0000A4B0 ; =============== S U B R O U T I N E =======================================
.text$mn:0000A4B0
.text$mn:0000A4B0 ; Attributes: bp-based frame
.text$mn:0000A4B0
.text$mn:0000A4B0 ; protected: void __thiscall std::vector<class std::basic_string<wchar_t, struct std::char_traits<wchar_t>, class std::allocator<wchar_t>>, class std::allocator<class std::basic_string<wchar_t, struct std::char_traits<wchar_t>, class std::allocator<wchar_t>>>>::_Reserve(unsigned int)
.text$mn:0000A4B0                 public ?_Reserve@?$vector@V?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@V?$allocator@V?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@@2@@std@@IAEXI@Z
.text$mn:0000A4B0 ?_Reserve@?$vector@V?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@V?$allocator@V?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@@2@@std@@IAEXI@Z proc near
.text$mn:0000A4B0                                         ; CODE XREF: std::vector<std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>>,std::allocator<std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>>>>::push_back(std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>> &&)+59p
.text$mn:0000A4B0                                         ; std::vector<std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>>,std::allocator<std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>>>>::push_back(std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>> &&)+C6p
.text$mn:0000A4B0
.text$mn:0000A4B0 var_4           = dword ptr -4
.text$mn:0000A4B0 arg_0           = dword ptr  8
.text$mn:0000A4B0
.text$mn:0000A4B0                 push    ebp
.text$mn:0000A4B1                 mov     ebp, esp
.text$mn:0000A4B3                 push    ecx
.text$mn:0000A4B4                 push    esi
.text$mn:0000A4B5                 mov     [ebp+var_4], ecx
.text$mn:0000A4B8                 mov     ecx, [ebp+var_4]
.text$mn:0000A4BB                 call    ?_Unused_capacity@?$vector@V?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@V?$allocator@V?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@@2@@std@@QBEIXZ ; std::vector<std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>>,std::allocator<std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>>>>::_Unused_capacity(void)
.text$mn:0000A4C0                 cmp     eax, [ebp+arg_0]
.text$mn:0000A4C3                 jnb     short loc_A503
.text$mn:0000A4C5                 mov     ecx, [ebp+var_4]
.text$mn:0000A4C8                 call    ?max_size@?$vector@V?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@V?$allocator@V?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@@2@@std@@QBEIXZ ; std::vector<std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>>,std::allocator<std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>>>>::max_size(void)
.text$mn:0000A4CD                 mov     esi, eax
.text$mn:0000A4CF                 mov     ecx, [ebp+var_4]
.text$mn:0000A4D2                 call    ?size@?$vector@V?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@V?$allocator@V?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@@2@@std@@QBEIXZ ; std::vector<std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>>,std::allocator<std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>>>>::size(void)
.text$mn:0000A4D7                 sub     esi, eax
.text$mn:0000A4D9                 cmp     esi, [ebp+arg_0]
.text$mn:0000A4DC                 jnb     short loc_A4E6
.text$mn:0000A4DE                 mov     ecx, [ebp+var_4]
.text$mn:0000A4E1                 call    ?_Xlen@?$vector@V?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@V?$allocator@V?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@@2@@std@@IBEXXZ ; std::vector<std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>>,std::allocator<std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>>>>::_Xlen(void)
.text$mn:0000A4E6
.text$mn:0000A4E6 loc_A4E6:                               ; CODE XREF: std::vector<std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>>,std::allocator<std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>>>>::_Reserve(uint)+2Cj
.text$mn:0000A4E6                 mov     ecx, [ebp+var_4]
.text$mn:0000A4E9                 call    ?size@?$vector@V?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@V?$allocator@V?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@@2@@std@@QBEIXZ ; std::vector<std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>>,std::allocator<std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>>>>::size(void)
.text$mn:0000A4EE                 add     eax, [ebp+arg_0]
.text$mn:0000A4F1                 push    eax
.text$mn:0000A4F2                 mov     ecx, [ebp+var_4]
.text$mn:0000A4F5                 call    ?_Grow_to@?$vector@V?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@V?$allocator@V?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@@2@@std@@IBEII@Z ; std::vector<std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>>,std::allocator<std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>>>>::_Grow_to(uint)
.text$mn:0000A4FA                 push    eax
.text$mn:0000A4FB                 mov     ecx, [ebp+var_4]
.text$mn:0000A4FE                 call    ?_Reallocate@?$vector@V?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@V?$allocator@V?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@@2@@std@@IAEXI@Z ; std::vector<std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>>,std::allocator<std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>>>>::_Reallocate(uint)
.text$mn:0000A503
.text$mn:0000A503 loc_A503:                               ; CODE XREF: std::vector<std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>>,std::allocator<std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>>>>::_Reserve(uint)+13j
.text$mn:0000A503                 pop     esi
.text$mn:0000A504                 mov     esp, ebp
.text$mn:0000A506                 pop     ebp
.text$mn:0000A507                 retn    4
.text$mn:0000A507 ?_Reserve@?$vector@V?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@V?$allocator@V?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@@2@@std@@IAEXI@Z endp
.text$mn:0000A507
.text$mn:0000A507 ; ---------------------------------------------------------------------------
.text$mn:0000A50A                 align 4
.text$mn:0000A50A _text$mn        ends
.text$mn:0000A50A
.text$mn:0000A50C ; ===========================================================================
.text$mn:0000A50C
.text$mn:0000A50C ; Segment type: Pure code
.text$mn:0000A50C ; Segment permissions: Read/Execute
.text$mn:0000A50C _text$mn        segment para public 'CODE' use32
.text$mn:0000A50C                 assume cs:_text$mn
.text$mn:0000A50C                 ;org 0A50Ch
.text$mn:0000A50C ; COMDAT (pick any)
.text$mn:0000A50C                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text$mn:0000A50C
.text$mn:0000A50C ; =============== S U B R O U T I N E =======================================
.text$mn:0000A50C
.text$mn:0000A50C ; Attributes: bp-based frame
.text$mn:0000A50C
.text$mn:0000A50C ; protected: void __thiscall std::vector<wchar_t, class std::allocator<wchar_t>>::_Reserve(unsigned int)
.text$mn:0000A50C                 public ?_Reserve@?$vector@_WV?$allocator@_W@std@@@std@@IAEXI@Z
.text$mn:0000A50C ?_Reserve@?$vector@_WV?$allocator@_W@std@@@std@@IAEXI@Z proc near
.text$mn:0000A50C                                         ; CODE XREF: std::vector<wchar_t,std::allocator<wchar_t>>::push_back(wchar_t &&)+53p
.text$mn:0000A50C                                         ; std::vector<wchar_t,std::allocator<wchar_t>>::push_back(wchar_t &&)+C2p
.text$mn:0000A50C
.text$mn:0000A50C var_4           = dword ptr -4
.text$mn:0000A50C arg_0           = dword ptr  8
.text$mn:0000A50C
.text$mn:0000A50C                 push    ebp
.text$mn:0000A50D                 mov     ebp, esp
.text$mn:0000A50F                 push    ecx
.text$mn:0000A510                 push    esi
.text$mn:0000A511                 mov     [ebp+var_4], ecx
.text$mn:0000A514                 mov     ecx, [ebp+var_4]
.text$mn:0000A517                 call    ?_Unused_capacity@?$vector@_WV?$allocator@_W@std@@@std@@QBEIXZ ; std::vector<wchar_t,std::allocator<wchar_t>>::_Unused_capacity(void)
.text$mn:0000A51C                 cmp     eax, [ebp+arg_0]
.text$mn:0000A51F                 jnb     short loc_A55F
.text$mn:0000A521                 mov     ecx, [ebp+var_4]
.text$mn:0000A524                 call    ?max_size@?$vector@_WV?$allocator@_W@std@@@std@@QBEIXZ ; std::vector<wchar_t,std::allocator<wchar_t>>::max_size(void)
.text$mn:0000A529                 mov     esi, eax
.text$mn:0000A52B                 mov     ecx, [ebp+var_4]
.text$mn:0000A52E                 call    ?size@?$vector@_WV?$allocator@_W@std@@@std@@QBEIXZ ; std::vector<wchar_t,std::allocator<wchar_t>>::size(void)
.text$mn:0000A533                 sub     esi, eax
.text$mn:0000A535                 cmp     esi, [ebp+arg_0]
.text$mn:0000A538                 jnb     short loc_A542
.text$mn:0000A53A                 mov     ecx, [ebp+var_4]
.text$mn:0000A53D                 call    ?_Xlen@?$vector@_WV?$allocator@_W@std@@@std@@IBEXXZ ; std::vector<wchar_t,std::allocator<wchar_t>>::_Xlen(void)
.text$mn:0000A542
.text$mn:0000A542 loc_A542:                               ; CODE XREF: std::vector<wchar_t,std::allocator<wchar_t>>::_Reserve(uint)+2Cj
.text$mn:0000A542                 mov     ecx, [ebp+var_4]
.text$mn:0000A545                 call    ?size@?$vector@_WV?$allocator@_W@std@@@std@@QBEIXZ ; std::vector<wchar_t,std::allocator<wchar_t>>::size(void)
.text$mn:0000A54A                 add     eax, [ebp+arg_0]
.text$mn:0000A54D                 push    eax
.text$mn:0000A54E                 mov     ecx, [ebp+var_4]
.text$mn:0000A551                 call    ?_Grow_to@?$vector@_WV?$allocator@_W@std@@@std@@IBEII@Z ; std::vector<wchar_t,std::allocator<wchar_t>>::_Grow_to(uint)
.text$mn:0000A556                 push    eax
.text$mn:0000A557                 mov     ecx, [ebp+var_4]
.text$mn:0000A55A                 call    ?_Reallocate@?$vector@_WV?$allocator@_W@std@@@std@@IAEXI@Z ; std::vector<wchar_t,std::allocator<wchar_t>>::_Reallocate(uint)
.text$mn:0000A55F
.text$mn:0000A55F loc_A55F:                               ; CODE XREF: std::vector<wchar_t,std::allocator<wchar_t>>::_Reserve(uint)+13j
.text$mn:0000A55F                 pop     esi
.text$mn:0000A560                 mov     esp, ebp
.text$mn:0000A562                 pop     ebp
.text$mn:0000A563                 retn    4
.text$mn:0000A563 ?_Reserve@?$vector@_WV?$allocator@_W@std@@@std@@IAEXI@Z endp
.text$mn:0000A563
.text$mn:0000A563 ; ---------------------------------------------------------------------------
.text$mn:0000A566                 align 4
.text$mn:0000A566 _text$mn        ends
.text$mn:0000A566
.text$mn:0000A568 ; ===========================================================================
.text$mn:0000A568
.text$mn:0000A568 ; Segment type: Pure code
.text$mn:0000A568 ; Segment permissions: Read/Execute
.text$mn:0000A568 _text$mn        segment para public 'CODE' use32
.text$mn:0000A568                 assume cs:_text$mn
.text$mn:0000A568                 ;org 0A568h
.text$mn:0000A568 ; COMDAT (pick any)
.text$mn:0000A568                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text$mn:0000A568
.text$mn:0000A568 ; =============== S U B R O U T I N E =======================================
.text$mn:0000A568
.text$mn:0000A568 ; Attributes: bp-based frame
.text$mn:0000A568
.text$mn:0000A568 ; void __thiscall std::_Container_base12::_Swap_all(std::_Container_base12 *this, struct std::_Container_base12 *)
.text$mn:0000A568                 public ?_Swap_all@_Container_base12@std@@QAEXAAU12@@Z
.text$mn:0000A568 ?_Swap_all@_Container_base12@std@@QAEXAAU12@@Z proc near
.text$mn:0000A568                                         ; CODE XREF: std::vector<std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>>,std::allocator<std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>>>>::_Assign_rv(std::vector<std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>>,std::allocator<std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>>>> &&,std::integral_constant<bool,1>)+Ep
.text$mn:0000A568
.text$mn:0000A568 var_18          = byte ptr -18h
.text$mn:0000A568 var_14          = dword ptr -14h
.text$mn:0000A568 var_10          = dword ptr -10h
.text$mn:0000A568 var_C           = dword ptr -0Ch
.text$mn:0000A568 var_4           = dword ptr -4
.text$mn:0000A568 arg_0           = dword ptr  8
.text$mn:0000A568
.text$mn:0000A568                 push    ebp
.text$mn:0000A569                 mov     ebp, esp
.text$mn:0000A56B                 push    0FFFFFFFFh
.text$mn:0000A56D                 push    offset __ehhandler$?_Swap_all@_Container_base12@std@@QAEXAAU12@@Z
.text$mn:0000A572                 mov     eax, large fs:0
.text$mn:0000A578                 push    eax
.text$mn:0000A579                 sub     esp, 0Ch
.text$mn:0000A57C                 mov     eax, dword ptr ds:___security_cookie
.text$mn:0000A581                 xor     eax, ebp
.text$mn:0000A583                 push    eax
.text$mn:0000A584                 lea     eax, [ebp+var_C]
.text$mn:0000A587                 mov     large fs:0, eax
.text$mn:0000A58D                 mov     [ebp+var_10], ecx
.text$mn:0000A590                 push    3               ; int
.text$mn:0000A592                 lea     ecx, [ebp+var_18] ; this
.text$mn:0000A595                 call    ??0_Lockit@std@@QAE@H@Z ; std::_Lockit::_Lockit(int)
.text$mn:0000A59A                 mov     [ebp+var_4], 0
.text$mn:0000A5A1                 mov     eax, [ebp+var_10]
.text$mn:0000A5A4                 mov     ecx, [eax]
.text$mn:0000A5A6                 mov     [ebp+var_14], ecx
.text$mn:0000A5A9                 mov     edx, [ebp+var_10]
.text$mn:0000A5AC                 mov     eax, [ebp+arg_0]
.text$mn:0000A5AF                 mov     ecx, [eax]
.text$mn:0000A5B1                 mov     [edx], ecx
.text$mn:0000A5B3                 mov     edx, [ebp+arg_0]
.text$mn:0000A5B6                 mov     eax, [ebp+var_14]
.text$mn:0000A5B9                 mov     [edx], eax
.text$mn:0000A5BB                 mov     ecx, [ebp+var_10]
.text$mn:0000A5BE                 cmp     dword ptr [ecx], 0
.text$mn:0000A5C1                 jz      short loc_A5CD
.text$mn:0000A5C3                 mov     edx, [ebp+var_10]
.text$mn:0000A5C6                 mov     eax, [edx]
.text$mn:0000A5C8                 mov     ecx, [ebp+var_10]
.text$mn:0000A5CB                 mov     [eax], ecx
.text$mn:0000A5CD
.text$mn:0000A5CD loc_A5CD:                               ; CODE XREF: std::_Container_base12::_Swap_all(std::_Container_base12 &)+59j
.text$mn:0000A5CD                 mov     edx, [ebp+arg_0]
.text$mn:0000A5D0                 cmp     dword ptr [edx], 0
.text$mn:0000A5D3                 jz      short loc_A5DF
.text$mn:0000A5D5                 mov     eax, [ebp+arg_0]
.text$mn:0000A5D8                 mov     ecx, [eax]
.text$mn:0000A5DA                 mov     edx, [ebp+arg_0]
.text$mn:0000A5DD                 mov     [ecx], edx
.text$mn:0000A5DF
.text$mn:0000A5DF loc_A5DF:                               ; CODE XREF: std::_Container_base12::_Swap_all(std::_Container_base12 &)+6Bj
.text$mn:0000A5DF                 mov     [ebp+var_4], 0FFFFFFFFh
.text$mn:0000A5E6                 lea     ecx, [ebp+var_18] ; this
.text$mn:0000A5E9                 call    ??1_Lockit@std@@QAE@XZ ; std::_Lockit::~_Lockit(void)
.text$mn:0000A5EE                 mov     ecx, [ebp+var_C]
.text$mn:0000A5F1                 mov     large fs:0, ecx
.text$mn:0000A5F8                 pop     ecx
.text$mn:0000A5F9                 mov     esp, ebp
.text$mn:0000A5FB                 pop     ebp
.text$mn:0000A5FC                 retn    4
.text$mn:0000A5FC ?_Swap_all@_Container_base12@std@@QAEXAAU12@@Z endp
.text$mn:0000A5FC
.text$mn:0000A5FC ; ---------------------------------------------------------------------------
.text$mn:0000A5FF                 align 10h
.text$mn:0000A5FF _text$mn        ends
.text$mn:0000A5FF
.text$x:0000A600 ; ===========================================================================
.text$x:0000A600
.text$x:0000A600 ; Segment type: Pure code
.text$x:0000A600 ; Segment permissions: Read/Execute
.text$x:0000A600 _text$x         segment para public 'CODE' use32
.text$x:0000A600                 assume cs:_text$x
.text$x:0000A600                 ;org 0A600h
.text$x:0000A600 ; COMDAT (pick associative to section at A568)
.text$x:0000A600                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text$x:0000A600
.text$x:0000A600 ; =============== S U B R O U T I N E =======================================
.text$x:0000A600
.text$x:0000A600
.text$x:0000A600 __unwindfunclet$?_Swap_all@_Container_base12@std@@QAEXAAU12@@Z$0 proc near
.text$x:0000A600                                         ; DATA XREF: .xdata$x:0000D434o
.text$x:0000A600                 lea     ecx, [ebp-18h]  ; this
.text$x:0000A603                 jmp     ??1_Lockit@std@@QAE@XZ ; std::_Lockit::~_Lockit(void)
.text$x:0000A603 __unwindfunclet$?_Swap_all@_Container_base12@std@@QAEXAAU12@@Z$0 endp
.text$x:0000A603
.text$x:0000A608
.text$x:0000A608 ; =============== S U B R O U T I N E =======================================
.text$x:0000A608
.text$x:0000A608
.text$x:0000A608 __ehhandler$?_Swap_all@_Container_base12@std@@QAEXAAU12@@Z proc near
.text$x:0000A608                                         ; DATA XREF: std::_Container_base12::_Swap_all(std::_Container_base12 &)+5o
.text$x:0000A608
.text$x:0000A608 arg_4           = dword ptr  8
.text$x:0000A608
.text$x:0000A608                 mov     edx, [esp+arg_4]
.text$x:0000A60C                 lea     eax, [edx+0Ch]
.text$x:0000A60F                 mov     ecx, [edx-10h]
.text$x:0000A612                 xor     ecx, eax
.text$x:0000A614                 call    @__security_check_cookie@4 ; __security_check_cookie(x)
.text$x:0000A619                 mov     eax, offset __ehfuncinfo$?_Swap_all@_Container_base12@std@@QAEXAAU12@@Z
.text$x:0000A61E                 jmp     ___CxxFrameHandler3
.text$x:0000A61E __ehhandler$?_Swap_all@_Container_base12@std@@QAEXAAU12@@Z endp
.text$x:0000A61E
.text$x:0000A61E ; ---------------------------------------------------------------------------
.text$x:0000A623                 align 4
.text$x:0000A623 _text$x         ends
.text$x:0000A623
.text$mn:0000A624 ; ===========================================================================
.text$mn:0000A624
.text$mn:0000A624 ; Segment type: Pure code
.text$mn:0000A624 ; Segment permissions: Read/Execute
.text$mn:0000A624 _text$mn        segment para public 'CODE' use32
.text$mn:0000A624                 assume cs:_text$mn
.text$mn:0000A624                 ;org 0A624h
.text$mn:0000A624 ; COMDAT (pick any)
.text$mn:0000A624                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text$mn:0000A624
.text$mn:0000A624 ; =============== S U B R O U T I N E =======================================
.text$mn:0000A624
.text$mn:0000A624 ; Attributes: bp-based frame
.text$mn:0000A624
.text$mn:0000A624 ; int __stdcall std::basic_string<char,std::char_traits<char>,std::allocator<char>>::_Tidy(char, size_t Size)
.text$mn:0000A624                 public ?_Tidy@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEX_NI@Z
.text$mn:0000A624 ?_Tidy@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEX_NI@Z proc near
.text$mn:0000A624                                         ; CODE XREF: std::basic_string<char,std::char_traits<char>,std::allocator<char>>::basic_string<char,std::char_traits<char>,std::allocator<char>>(std::basic_string<char,std::char_traits<char>,std::allocator<char>> &&)+4Bp
.text$mn:0000A624                                         ; std::basic_string<char,std::char_traits<char>,std::allocator<char>>::basic_string<char,std::char_traits<char>,std::allocator<char>>(char const *)+47p ...
.text$mn:0000A624
.text$mn:0000A624 var_C           = dword ptr -0Ch
.text$mn:0000A624 var_8           = dword ptr -8
.text$mn:0000A624 var_2           = byte ptr -2
.text$mn:0000A624 var_1           = byte ptr -1
.text$mn:0000A624 arg_0           = byte ptr  8
.text$mn:0000A624 Size            = dword ptr  0Ch
.text$mn:0000A624
.text$mn:0000A624                 push    ebp
.text$mn:0000A625                 mov     ebp, esp
.text$mn:0000A627                 sub     esp, 0Ch
.text$mn:0000A62A                 mov     [ebp+var_8], ecx
.text$mn:0000A62D                 movzx   eax, [ebp+arg_0]
.text$mn:0000A631                 test    eax, eax
.text$mn:0000A633                 jnz     short loc_A637
.text$mn:0000A635                 jmp     short loc_A6AA
.text$mn:0000A637 ; ---------------------------------------------------------------------------
.text$mn:0000A637
.text$mn:0000A637 loc_A637:                               ; CODE XREF: std::basic_string<char,std::char_traits<char>,std::allocator<char>>::_Tidy(bool,uint)+Fj
.text$mn:0000A637                 mov     ecx, [ebp+var_8]
.text$mn:0000A63A                 cmp     dword ptr [ecx+18h], 10h
.text$mn:0000A63E                 jb      short loc_A6AA
.text$mn:0000A640                 mov     edx, [ebp+var_8]
.text$mn:0000A643                 mov     eax, [edx+4]
.text$mn:0000A646                 mov     [ebp+var_C], eax
.text$mn:0000A649                 mov     ecx, [ebp+var_8]
.text$mn:0000A64C                 add     ecx, 4
.text$mn:0000A64F                 push    ecx
.text$mn:0000A650                 lea     edx, [ebp+var_1]
.text$mn:0000A653                 push    edx
.text$mn:0000A654                 mov     ecx, [ebp+var_8]
.text$mn:0000A657                 call    ?_Getal@?$_String_alloc@$0A@U?$_String_base_types@DV?$allocator@D@std@@@std@@@std@@QBE?AU?$_Wrap_alloc@V?$allocator@D@std@@@2@XZ ; std::_String_alloc<0,std::_String_base_types<char,std::allocator<char>>>::_Getal(void)
.text$mn:0000A65C                 mov     ecx, eax
.text$mn:0000A65E                 call    ??$destroy@PAD@?$_Wrap_alloc@V?$allocator@D@std@@@std@@QAEXPAPAD@Z ; std::_Wrap_alloc<std::allocator<char>>::destroy<char *>(char * *)
.text$mn:0000A663                 cmp     [ebp+Size], 0
.text$mn:0000A667                 jbe     short loc_A689
.text$mn:0000A669                 mov     eax, [ebp+Size]
.text$mn:0000A66C                 push    eax             ; Size
.text$mn:0000A66D                 mov     ecx, [ebp+var_C]
.text$mn:0000A670                 push    ecx
.text$mn:0000A671                 call    ??$addressof@D@std@@YAPADAAD@Z ; std::addressof<char>(char &)
.text$mn:0000A676                 add     esp, 4
.text$mn:0000A679                 push    eax             ; Src
.text$mn:0000A67A                 mov     edx, [ebp+var_8]
.text$mn:0000A67D                 add     edx, 4
.text$mn:0000A680                 push    edx             ; Dst
.text$mn:0000A681                 call    ?copy@?$char_traits@D@std@@SAPADPADPBDI@Z ; std::char_traits<char>::copy(char *,char const *,uint)
.text$mn:0000A686                 add     esp, 0Ch
.text$mn:0000A689
.text$mn:0000A689 loc_A689:                               ; CODE XREF: std::basic_string<char,std::char_traits<char>,std::allocator<char>>::_Tidy(bool,uint)+43j
.text$mn:0000A689                 mov     eax, [ebp+var_8]
.text$mn:0000A68C                 mov     ecx, [eax+18h]
.text$mn:0000A68F                 add     ecx, 1
.text$mn:0000A692                 push    ecx             ; int
.text$mn:0000A693                 mov     edx, [ebp+var_C]
.text$mn:0000A696                 push    edx             ; void *
.text$mn:0000A697                 lea     eax, [ebp+var_2]
.text$mn:0000A69A                 push    eax
.text$mn:0000A69B                 mov     ecx, [ebp+var_8]
.text$mn:0000A69E                 call    ?_Getal@?$_String_alloc@$0A@U?$_String_base_types@DV?$allocator@D@std@@@std@@@std@@QBE?AU?$_Wrap_alloc@V?$allocator@D@std@@@2@XZ ; std::_String_alloc<0,std::_String_base_types<char,std::allocator<char>>>::_Getal(void)
.text$mn:0000A6A3                 mov     ecx, eax
.text$mn:0000A6A5                 call    ?deallocate@?$_Wrap_alloc@V?$allocator@D@std@@@std@@QAEXPADI@Z ; std::_Wrap_alloc<std::allocator<char>>::deallocate(char *,uint)
.text$mn:0000A6AA
.text$mn:0000A6AA loc_A6AA:                               ; CODE XREF: std::basic_string<char,std::char_traits<char>,std::allocator<char>>::_Tidy(bool,uint)+11j
.text$mn:0000A6AA                                         ; std::basic_string<char,std::char_traits<char>,std::allocator<char>>::_Tidy(bool,uint)+1Aj
.text$mn:0000A6AA                 mov     ecx, [ebp+var_8]
.text$mn:0000A6AD                 mov     dword ptr [ecx+18h], 0Fh
.text$mn:0000A6B4                 mov     edx, [ebp+Size]
.text$mn:0000A6B7                 push    edx
.text$mn:0000A6B8                 mov     ecx, [ebp+var_8]
.text$mn:0000A6BB                 call    ?_Eos@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEXI@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char>>::_Eos(uint)
.text$mn:0000A6C0                 mov     esp, ebp
.text$mn:0000A6C2                 pop     ebp
.text$mn:0000A6C3                 retn    8
.text$mn:0000A6C3 ?_Tidy@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEX_NI@Z endp
.text$mn:0000A6C3
.text$mn:0000A6C3 ; ---------------------------------------------------------------------------
.text$mn:0000A6C6                 align 4
.text$mn:0000A6C6 _text$mn        ends
.text$mn:0000A6C6
.text$mn:0000A6C8 ; ===========================================================================
.text$mn:0000A6C8
.text$mn:0000A6C8 ; Segment type: Pure code
.text$mn:0000A6C8 ; Segment permissions: Read/Execute
.text$mn:0000A6C8 _text$mn        segment para public 'CODE' use32
.text$mn:0000A6C8                 assume cs:_text$mn
.text$mn:0000A6C8                 ;org 0A6C8h
.text$mn:0000A6C8 ; COMDAT (pick any)
.text$mn:0000A6C8                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text$mn:0000A6C8
.text$mn:0000A6C8 ; =============== S U B R O U T I N E =======================================
.text$mn:0000A6C8
.text$mn:0000A6C8 ; Attributes: bp-based frame
.text$mn:0000A6C8
.text$mn:0000A6C8 ; public: void __thiscall std::basic_string<wchar_t, struct std::char_traits<wchar_t>, class std::allocator<wchar_t>>::_Tidy(bool, unsigned int)
.text$mn:0000A6C8                 public ?_Tidy@?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QAEX_NI@Z
.text$mn:0000A6C8 ?_Tidy@?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QAEX_NI@Z proc near
.text$mn:0000A6C8                                         ; CODE XREF: std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>>::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>>(std::reverse_iterator<std::_Vector_iterator<std::_Vector_val<std::_Simple_types<wchar_t>>>>,std::reverse_iterator<std::_Vector_iterator<std::_Vector_val<std::_Simple_types<wchar_t>>>>)+4Bp
.text$mn:0000A6C8                                         ; __catch$??$_Construct@V?$reverse_iterator@V?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@_W@std@@@std@@@std@@@std@@@?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QAEXV?$reverse_iterator@V?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@_W@std@@@std@@@std@@@1@0Uforward_iterator_tag@1@@Z$0+7p ...
.text$mn:0000A6C8
.text$mn:0000A6C8 var_C           = dword ptr -0Ch
.text$mn:0000A6C8 var_8           = dword ptr -8
.text$mn:0000A6C8 var_2           = byte ptr -2
.text$mn:0000A6C8 var_1           = byte ptr -1
.text$mn:0000A6C8 arg_0           = byte ptr  8
.text$mn:0000A6C8 arg_4           = dword ptr  0Ch
.text$mn:0000A6C8
.text$mn:0000A6C8                 push    ebp
.text$mn:0000A6C9                 mov     ebp, esp
.text$mn:0000A6CB                 sub     esp, 0Ch
.text$mn:0000A6CE                 mov     [ebp+var_8], ecx
.text$mn:0000A6D1                 movzx   eax, [ebp+arg_0]
.text$mn:0000A6D5                 test    eax, eax
.text$mn:0000A6D7                 jnz     short loc_A6DB
.text$mn:0000A6D9                 jmp     short loc_A74E
.text$mn:0000A6DB ; ---------------------------------------------------------------------------
.text$mn:0000A6DB
.text$mn:0000A6DB loc_A6DB:                               ; CODE XREF: std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>>::_Tidy(bool,uint)+Fj
.text$mn:0000A6DB                 mov     ecx, [ebp+var_8]
.text$mn:0000A6DE                 cmp     dword ptr [ecx+18h], 8
.text$mn:0000A6E2                 jb      short loc_A74E
.text$mn:0000A6E4                 mov     edx, [ebp+var_8]
.text$mn:0000A6E7                 mov     eax, [edx+4]
.text$mn:0000A6EA                 mov     [ebp+var_C], eax
.text$mn:0000A6ED                 mov     ecx, [ebp+var_8]
.text$mn:0000A6F0                 add     ecx, 4
.text$mn:0000A6F3                 push    ecx
.text$mn:0000A6F4                 lea     edx, [ebp+var_1]
.text$mn:0000A6F7                 push    edx
.text$mn:0000A6F8                 mov     ecx, [ebp+var_8]
.text$mn:0000A6FB                 call    ?_Getal@?$_String_alloc@$0A@U?$_String_base_types@_WV?$allocator@_W@std@@@std@@@std@@QBE?AU?$_Wrap_alloc@V?$allocator@_W@std@@@2@XZ ; std::_String_alloc<0,std::_String_base_types<wchar_t,std::allocator<wchar_t>>>::_Getal(void)
.text$mn:0000A700                 mov     ecx, eax
.text$mn:0000A702                 call    ??$destroy@PA_W@?$_Wrap_alloc@V?$allocator@_W@std@@@std@@QAEXPAPA_W@Z ; std::_Wrap_alloc<std::allocator<wchar_t>>::destroy<wchar_t *>(wchar_t * *)
.text$mn:0000A707                 cmp     [ebp+arg_4], 0
.text$mn:0000A70B                 jbe     short loc_A72D
.text$mn:0000A70D                 mov     eax, [ebp+arg_4]
.text$mn:0000A710                 push    eax             ; int
.text$mn:0000A711                 mov     ecx, [ebp+var_C]
.text$mn:0000A714                 push    ecx
.text$mn:0000A715                 call    ??$addressof@_W@std@@YAPA_WAA_W@Z ; std::addressof<wchar_t>(wchar_t &)
.text$mn:0000A71A                 add     esp, 4
.text$mn:0000A71D                 push    eax             ; Src
.text$mn:0000A71E                 mov     edx, [ebp+var_8]
.text$mn:0000A721                 add     edx, 4
.text$mn:0000A724                 push    edx             ; Dst
.text$mn:0000A725                 call    ?copy@?$char_traits@_W@std@@SAPA_WPA_WPB_WI@Z ; std::char_traits<wchar_t>::copy(wchar_t *,wchar_t const *,uint)
.text$mn:0000A72A                 add     esp, 0Ch
.text$mn:0000A72D
.text$mn:0000A72D loc_A72D:                               ; CODE XREF: std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>>::_Tidy(bool,uint)+43j
.text$mn:0000A72D                 mov     eax, [ebp+var_8]
.text$mn:0000A730                 mov     ecx, [eax+18h]
.text$mn:0000A733                 add     ecx, 1
.text$mn:0000A736                 push    ecx             ; int
.text$mn:0000A737                 mov     edx, [ebp+var_C]
.text$mn:0000A73A                 push    edx             ; void *
.text$mn:0000A73B                 lea     eax, [ebp+var_2]
.text$mn:0000A73E                 push    eax
.text$mn:0000A73F                 mov     ecx, [ebp+var_8]
.text$mn:0000A742                 call    ?_Getal@?$_String_alloc@$0A@U?$_String_base_types@_WV?$allocator@_W@std@@@std@@@std@@QBE?AU?$_Wrap_alloc@V?$allocator@_W@std@@@2@XZ ; std::_String_alloc<0,std::_String_base_types<wchar_t,std::allocator<wchar_t>>>::_Getal(void)
.text$mn:0000A747                 mov     ecx, eax
.text$mn:0000A749                 call    ?deallocate@?$_Wrap_alloc@V?$allocator@_W@std@@@std@@QAEXPA_WI@Z ; std::_Wrap_alloc<std::allocator<wchar_t>>::deallocate(wchar_t *,uint)
.text$mn:0000A74E
.text$mn:0000A74E loc_A74E:                               ; CODE XREF: std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>>::_Tidy(bool,uint)+11j
.text$mn:0000A74E                                         ; std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>>::_Tidy(bool,uint)+1Aj
.text$mn:0000A74E                 mov     ecx, [ebp+var_8]
.text$mn:0000A751                 mov     dword ptr [ecx+18h], 7
.text$mn:0000A758                 mov     edx, [ebp+arg_4]
.text$mn:0000A75B                 push    edx
.text$mn:0000A75C                 mov     ecx, [ebp+var_8]
.text$mn:0000A75F                 call    ?_Eos@?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QAEXI@Z ; std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>>::_Eos(uint)
.text$mn:0000A764                 mov     esp, ebp
.text$mn:0000A766                 pop     ebp
.text$mn:0000A767                 retn    8
.text$mn:0000A767 ?_Tidy@?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QAEX_NI@Z endp
.text$mn:0000A767
.text$mn:0000A767 ; ---------------------------------------------------------------------------
.text$mn:0000A76A                 align 4
.text$mn:0000A76A _text$mn        ends
.text$mn:0000A76A
.text$mn:0000A76C ; ===========================================================================
.text$mn:0000A76C
.text$mn:0000A76C ; Segment type: Pure code
.text$mn:0000A76C ; Segment permissions: Read/Execute
.text$mn:0000A76C _text$mn        segment para public 'CODE' use32
.text$mn:0000A76C                 assume cs:_text$mn
.text$mn:0000A76C                 ;org 0A76Ch
.text$mn:0000A76C ; COMDAT (pick any)
.text$mn:0000A76C                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text$mn:0000A76C
.text$mn:0000A76C ; =============== S U B R O U T I N E =======================================
.text$mn:0000A76C
.text$mn:0000A76C ; Attributes: bp-based frame
.text$mn:0000A76C
.text$mn:0000A76C ; protected: void __thiscall std::vector<char, class std::allocator<char>>::_Tidy(void)
.text$mn:0000A76C                 public ?_Tidy@?$vector@DV?$allocator@D@std@@@std@@IAEXXZ
.text$mn:0000A76C ?_Tidy@?$vector@DV?$allocator@D@std@@@std@@IAEXXZ proc near
.text$mn:0000A76C                                         ; CODE XREF: __catch$??0?$vector@DV?$allocator@D@std@@@std@@QAE@I@Z$0+3p
.text$mn:0000A76C                                         ; std::vector<char,std::allocator<char>>::~vector<char,std::allocator<char>>(void)+30p
.text$mn:0000A76C
.text$mn:0000A76C var_8           = dword ptr -8
.text$mn:0000A76C var_1           = byte ptr -1
.text$mn:0000A76C
.text$mn:0000A76C                 push    ebp
.text$mn:0000A76D                 mov     ebp, esp
.text$mn:0000A76F                 sub     esp, 8
.text$mn:0000A772                 mov     [ebp+var_8], ecx
.text$mn:0000A775                 mov     eax, [ebp+var_8]
.text$mn:0000A778                 cmp     dword ptr [eax+4], 0
.text$mn:0000A77C                 jz      short loc_A7E1
.text$mn:0000A77E                 mov     ecx, [ebp+var_8] ; this
.text$mn:0000A781                 call    ?_Orphan_all@_Container_base12@std@@QAEXXZ ; std::_Container_base12::_Orphan_all(void)
.text$mn:0000A786                 mov     ecx, [ebp+var_8]
.text$mn:0000A789                 mov     edx, [ecx+8]
.text$mn:0000A78C                 push    edx
.text$mn:0000A78D                 mov     eax, [ebp+var_8]
.text$mn:0000A790                 mov     ecx, [eax+4]
.text$mn:0000A793                 push    ecx
.text$mn:0000A794                 mov     ecx, [ebp+var_8]
.text$mn:0000A797                 call    ?_Destroy@?$vector@DV?$allocator@D@std@@@std@@IAEXPAD0@Z ; std::vector<char,std::allocator<char>>::_Destroy(char *,char *)
.text$mn:0000A79C                 mov     edx, [ebp+var_8]
.text$mn:0000A79F                 mov     eax, [ebp+var_8]
.text$mn:0000A7A2                 mov     ecx, [edx+0Ch]
.text$mn:0000A7A5                 sub     ecx, [eax+4]
.text$mn:0000A7A8                 push    ecx             ; int
.text$mn:0000A7A9                 mov     edx, [ebp+var_8]
.text$mn:0000A7AC                 mov     eax, [edx+4]
.text$mn:0000A7AF                 push    eax             ; void *
.text$mn:0000A7B0                 lea     ecx, [ebp+var_1]
.text$mn:0000A7B3                 push    ecx
.text$mn:0000A7B4                 mov     ecx, [ebp+var_8]
.text$mn:0000A7B7                 call    ?_Getal@?$_Vector_alloc@$0A@U?$_Vec_base_types@DV?$allocator@D@std@@@std@@@std@@QBE?AU?$_Wrap_alloc@V?$allocator@D@std@@@2@XZ ; std::_Vector_alloc<0,std::_Vec_base_types<char,std::allocator<char>>>::_Getal(void)
.text$mn:0000A7BC                 mov     ecx, eax
.text$mn:0000A7BE                 call    ?deallocate@?$_Wrap_alloc@V?$allocator@D@std@@@std@@QAEXPADI@Z ; std::_Wrap_alloc<std::allocator<char>>::deallocate(char *,uint)
.text$mn:0000A7C3                 mov     edx, [ebp+var_8]
.text$mn:0000A7C6                 mov     dword ptr [edx+4], 0
.text$mn:0000A7CD                 mov     eax, [ebp+var_8]
.text$mn:0000A7D0                 mov     dword ptr [eax+8], 0
.text$mn:0000A7D7                 mov     ecx, [ebp+var_8]
.text$mn:0000A7DA                 mov     dword ptr [ecx+0Ch], 0
.text$mn:0000A7E1
.text$mn:0000A7E1 loc_A7E1:                               ; CODE XREF: std::vector<char,std::allocator<char>>::_Tidy(void)+10j
.text$mn:0000A7E1                 mov     esp, ebp
.text$mn:0000A7E3                 pop     ebp
.text$mn:0000A7E4                 retn
.text$mn:0000A7E4 ?_Tidy@?$vector@DV?$allocator@D@std@@@std@@IAEXXZ endp
.text$mn:0000A7E4
.text$mn:0000A7E4 ; ---------------------------------------------------------------------------
.text$mn:0000A7E5                 align 4
.text$mn:0000A7E5 _text$mn        ends
.text$mn:0000A7E5
.text$mn:0000A7E8 ; ===========================================================================
.text$mn:0000A7E8
.text$mn:0000A7E8 ; Segment type: Pure code
.text$mn:0000A7E8 ; Segment permissions: Read/Execute
.text$mn:0000A7E8 _text$mn        segment para public 'CODE' use32
.text$mn:0000A7E8                 assume cs:_text$mn
.text$mn:0000A7E8                 ;org 0A7E8h
.text$mn:0000A7E8 ; COMDAT (pick any)
.text$mn:0000A7E8                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text$mn:0000A7E8
.text$mn:0000A7E8 ; =============== S U B R O U T I N E =======================================
.text$mn:0000A7E8
.text$mn:0000A7E8 ; Attributes: bp-based frame
.text$mn:0000A7E8
.text$mn:0000A7E8 ; protected: void __thiscall std::vector<class std::basic_string<wchar_t, struct std::char_traits<wchar_t>, class std::allocator<wchar_t>>, class std::allocator<class std::basic_string<wchar_t, struct std::char_traits<wchar_t>, class std::allocator<wchar_t>>>>::_Tidy(void)
.text$mn:0000A7E8                 public ?_Tidy@?$vector@V?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@V?$allocator@V?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@@2@@std@@IAEXXZ
.text$mn:0000A7E8 ?_Tidy@?$vector@V?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@V?$allocator@V?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@@2@@std@@IAEXXZ proc near
.text$mn:0000A7E8                                         ; CODE XREF: std::vector<std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>>,std::allocator<std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>>>>::~vector<std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>>,std::allocator<std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>>>>(void)+30p
.text$mn:0000A7E8
.text$mn:0000A7E8 var_8           = dword ptr -8
.text$mn:0000A7E8 var_1           = byte ptr -1
.text$mn:0000A7E8
.text$mn:0000A7E8                 push    ebp
.text$mn:0000A7E9                 mov     ebp, esp
.text$mn:0000A7EB                 sub     esp, 8
.text$mn:0000A7EE                 mov     [ebp+var_8], ecx
.text$mn:0000A7F1                 mov     eax, [ebp+var_8]
.text$mn:0000A7F4                 cmp     dword ptr [eax+4], 0
.text$mn:0000A7F8                 jz      short loc_A867
.text$mn:0000A7FA                 mov     ecx, [ebp+var_8] ; this
.text$mn:0000A7FD                 call    ?_Orphan_all@_Container_base12@std@@QAEXXZ ; std::_Container_base12::_Orphan_all(void)
.text$mn:0000A802                 mov     ecx, [ebp+var_8]
.text$mn:0000A805                 mov     edx, [ecx+8]
.text$mn:0000A808                 push    edx
.text$mn:0000A809                 mov     eax, [ebp+var_8]
.text$mn:0000A80C                 mov     ecx, [eax+4]
.text$mn:0000A80F                 push    ecx
.text$mn:0000A810                 mov     ecx, [ebp+var_8]
.text$mn:0000A813                 call    ?_Destroy@?$vector@V?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@V?$allocator@V?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@@2@@std@@IAEXPAV?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@2@0@Z ; std::vector<std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>>,std::allocator<std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>>>>::_Destroy(std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>> *,std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>> *)
.text$mn:0000A818                 mov     edx, [ebp+var_8]
.text$mn:0000A81B                 mov     eax, [ebp+var_8]
.text$mn:0000A81E                 mov     ecx, [edx+0Ch]
.text$mn:0000A821                 sub     ecx, [eax+4]
.text$mn:0000A824                 mov     eax, ecx
.text$mn:0000A826                 cdq
.text$mn:0000A827                 mov     ecx, 1Ch
.text$mn:0000A82C                 idiv    ecx
.text$mn:0000A82E                 push    eax             ; int
.text$mn:0000A82F                 mov     edx, [ebp+var_8]
.text$mn:0000A832                 mov     eax, [edx+4]
.text$mn:0000A835                 push    eax             ; void *
.text$mn:0000A836                 lea     ecx, [ebp+var_1]
.text$mn:0000A839                 push    ecx
.text$mn:0000A83A                 mov     ecx, [ebp+var_8]
.text$mn:0000A83D                 call    ?_Getal@?$_Vector_alloc@$0A@U?$_Vec_base_types@V?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@V?$allocator@V?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@@2@@std@@@std@@QBE?AU?$_Wrap_alloc@V?$allocator@V?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@@std@@@2@XZ ; std::_Vector_alloc<0,std::_Vec_base_types<std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>>,std::allocator<std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>>>>>::_Getal(void)
.text$mn:0000A842                 mov     ecx, eax
.text$mn:0000A844                 call    ?deallocate@?$_Wrap_alloc@V?$allocator@V?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@@std@@@std@@QAEXPAV?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@2@I@Z ; std::_Wrap_alloc<std::allocator<std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>>>>::deallocate(std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>> *,uint)
.text$mn:0000A849                 mov     edx, [ebp+var_8]
.text$mn:0000A84C                 mov     dword ptr [edx+4], 0
.text$mn:0000A853                 mov     eax, [ebp+var_8]
.text$mn:0000A856                 mov     dword ptr [eax+8], 0
.text$mn:0000A85D                 mov     ecx, [ebp+var_8]
.text$mn:0000A860                 mov     dword ptr [ecx+0Ch], 0
.text$mn:0000A867
.text$mn:0000A867 loc_A867:                               ; CODE XREF: std::vector<std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>>,std::allocator<std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>>>>::_Tidy(void)+10j
.text$mn:0000A867                 mov     esp, ebp
.text$mn:0000A869                 pop     ebp
.text$mn:0000A86A                 retn
.text$mn:0000A86A ?_Tidy@?$vector@V?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@V?$allocator@V?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@@2@@std@@IAEXXZ endp
.text$mn:0000A86A
.text$mn:0000A86A ; ---------------------------------------------------------------------------
.text$mn:0000A86B                 align 4
.text$mn:0000A86B _text$mn        ends
.text$mn:0000A86B
.text$mn:0000A86C ; ===========================================================================
.text$mn:0000A86C
.text$mn:0000A86C ; Segment type: Pure code
.text$mn:0000A86C ; Segment permissions: Read/Execute
.text$mn:0000A86C _text$mn        segment para public 'CODE' use32
.text$mn:0000A86C                 assume cs:_text$mn
.text$mn:0000A86C                 ;org 0A86Ch
.text$mn:0000A86C ; COMDAT (pick any)
.text$mn:0000A86C                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text$mn:0000A86C
.text$mn:0000A86C ; =============== S U B R O U T I N E =======================================
.text$mn:0000A86C
.text$mn:0000A86C ; Attributes: bp-based frame
.text$mn:0000A86C
.text$mn:0000A86C ; protected: void __thiscall std::vector<wchar_t, class std::allocator<wchar_t>>::_Tidy(void)
.text$mn:0000A86C                 public ?_Tidy@?$vector@_WV?$allocator@_W@std@@@std@@IAEXXZ
.text$mn:0000A86C ?_Tidy@?$vector@_WV?$allocator@_W@std@@@std@@IAEXXZ proc near
.text$mn:0000A86C                                         ; CODE XREF: __catch$??0?$vector@_WV?$allocator@_W@std@@@std@@QAE@I@Z$0+3p
.text$mn:0000A86C                                         ; std::vector<wchar_t,std::allocator<wchar_t>>::~vector<wchar_t,std::allocator<wchar_t>>(void)+30p
.text$mn:0000A86C
.text$mn:0000A86C var_8           = dword ptr -8
.text$mn:0000A86C var_1           = byte ptr -1
.text$mn:0000A86C
.text$mn:0000A86C                 push    ebp
.text$mn:0000A86D                 mov     ebp, esp
.text$mn:0000A86F                 sub     esp, 8
.text$mn:0000A872                 mov     [ebp+var_8], ecx
.text$mn:0000A875                 mov     eax, [ebp+var_8]
.text$mn:0000A878                 cmp     dword ptr [eax+4], 0
.text$mn:0000A87C                 jz      short loc_A8E3
.text$mn:0000A87E                 mov     ecx, [ebp+var_8] ; this
.text$mn:0000A881                 call    ?_Orphan_all@_Container_base12@std@@QAEXXZ ; std::_Container_base12::_Orphan_all(void)
.text$mn:0000A886                 mov     ecx, [ebp+var_8]
.text$mn:0000A889                 mov     edx, [ecx+8]
.text$mn:0000A88C                 push    edx
.text$mn:0000A88D                 mov     eax, [ebp+var_8]
.text$mn:0000A890                 mov     ecx, [eax+4]
.text$mn:0000A893                 push    ecx
.text$mn:0000A894                 mov     ecx, [ebp+var_8]
.text$mn:0000A897                 call    ?_Destroy@?$vector@_WV?$allocator@_W@std@@@std@@IAEXPA_W0@Z ; std::vector<wchar_t,std::allocator<wchar_t>>::_Destroy(wchar_t *,wchar_t *)
.text$mn:0000A89C                 mov     edx, [ebp+var_8]
.text$mn:0000A89F                 mov     eax, [ebp+var_8]
.text$mn:0000A8A2                 mov     ecx, [edx+0Ch]
.text$mn:0000A8A5                 sub     ecx, [eax+4]
.text$mn:0000A8A8                 sar     ecx, 1
.text$mn:0000A8AA                 push    ecx             ; int
.text$mn:0000A8AB                 mov     edx, [ebp+var_8]
.text$mn:0000A8AE                 mov     eax, [edx+4]
.text$mn:0000A8B1                 push    eax             ; void *
.text$mn:0000A8B2                 lea     ecx, [ebp+var_1]
.text$mn:0000A8B5                 push    ecx
.text$mn:0000A8B6                 mov     ecx, [ebp+var_8]
.text$mn:0000A8B9                 call    ?_Getal@?$_Vector_alloc@$0A@U?$_Vec_base_types@_WV?$allocator@_W@std@@@std@@@std@@QBE?AU?$_Wrap_alloc@V?$allocator@_W@std@@@2@XZ ; std::_Vector_alloc<0,std::_Vec_base_types<wchar_t,std::allocator<wchar_t>>>::_Getal(void)
.text$mn:0000A8BE                 mov     ecx, eax
.text$mn:0000A8C0                 call    ?deallocate@?$_Wrap_alloc@V?$allocator@_W@std@@@std@@QAEXPA_WI@Z ; std::_Wrap_alloc<std::allocator<wchar_t>>::deallocate(wchar_t *,uint)
.text$mn:0000A8C5                 mov     edx, [ebp+var_8]
.text$mn:0000A8C8                 mov     dword ptr [edx+4], 0
.text$mn:0000A8CF                 mov     eax, [ebp+var_8]
.text$mn:0000A8D2                 mov     dword ptr [eax+8], 0
.text$mn:0000A8D9                 mov     ecx, [ebp+var_8]
.text$mn:0000A8DC                 mov     dword ptr [ecx+0Ch], 0
.text$mn:0000A8E3
.text$mn:0000A8E3 loc_A8E3:                               ; CODE XREF: std::vector<wchar_t,std::allocator<wchar_t>>::_Tidy(void)+10j
.text$mn:0000A8E3                 mov     esp, ebp
.text$mn:0000A8E5                 pop     ebp
.text$mn:0000A8E6                 retn
.text$mn:0000A8E6 ?_Tidy@?$vector@_WV?$allocator@_W@std@@@std@@IAEXXZ endp
.text$mn:0000A8E6
.text$mn:0000A8E6 ; ---------------------------------------------------------------------------
.text$mn:0000A8E7                 align 4
.text$mn:0000A8E7 _text$mn        ends
.text$mn:0000A8E7
.text$mn:0000A8E8 ; ===========================================================================
.text$mn:0000A8E8
.text$mn:0000A8E8 ; Segment type: Pure code
.text$mn:0000A8E8 ; Segment permissions: Read/Execute
.text$mn:0000A8E8 _text$mn        segment para public 'CODE' use32
.text$mn:0000A8E8                 assume cs:_text$mn
.text$mn:0000A8E8                 ;org 0A8E8h
.text$mn:0000A8E8 ; COMDAT (pick any)
.text$mn:0000A8E8                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text$mn:0000A8E8
.text$mn:0000A8E8 ; =============== S U B R O U T I N E =======================================
.text$mn:0000A8E8
.text$mn:0000A8E8 ; Attributes: bp-based frame
.text$mn:0000A8E8
.text$mn:0000A8E8 ; public: wchar_t * __thiscall std::_String_iterator<class std::_String_val<struct std::_Simple_types<wchar_t>>>::_Unchecked(void)const
.text$mn:0000A8E8                 public ?_Unchecked@?$_String_iterator@V?$_String_val@U?$_Simple_types@_W@std@@@std@@@std@@QBEPA_WXZ
.text$mn:0000A8E8 ?_Unchecked@?$_String_iterator@V?$_String_val@U?$_Simple_types@_W@std@@@std@@@std@@QBEPA_WXZ proc near
.text$mn:0000A8E8                                         ; CODE XREF: std::_Unchecked<std::_String_val<std::_Simple_types<wchar_t>>>(std::_String_iterator<std::_String_val<std::_Simple_types<wchar_t>>>)+2Dp
.text$mn:0000A8E8
.text$mn:0000A8E8 var_4           = dword ptr -4
.text$mn:0000A8E8
.text$mn:0000A8E8                 push    ebp
.text$mn:0000A8E9                 mov     ebp, esp
.text$mn:0000A8EB                 push    ecx
.text$mn:0000A8EC                 mov     [ebp+var_4], ecx
.text$mn:0000A8EF                 mov     eax, [ebp+var_4]
.text$mn:0000A8F2                 mov     eax, [eax+8]
.text$mn:0000A8F5                 mov     esp, ebp
.text$mn:0000A8F7                 pop     ebp
.text$mn:0000A8F8                 retn
.text$mn:0000A8F8 ?_Unchecked@?$_String_iterator@V?$_String_val@U?$_Simple_types@_W@std@@@std@@@std@@QBEPA_WXZ endp
.text$mn:0000A8F8
.text$mn:0000A8F8 ; ---------------------------------------------------------------------------
.text$mn:0000A8F9                 align 4
.text$mn:0000A8F9 _text$mn        ends
.text$mn:0000A8F9
.text$mn:0000A8FC ; ===========================================================================
.text$mn:0000A8FC
.text$mn:0000A8FC ; Segment type: Pure code
.text$mn:0000A8FC ; Segment permissions: Read/Execute
.text$mn:0000A8FC _text$mn        segment para public 'CODE' use32
.text$mn:0000A8FC                 assume cs:_text$mn
.text$mn:0000A8FC                 ;org 0A8FCh
.text$mn:0000A8FC ; COMDAT (pick any)
.text$mn:0000A8FC                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text$mn:0000A8FC
.text$mn:0000A8FC ; =============== S U B R O U T I N E =======================================
.text$mn:0000A8FC
.text$mn:0000A8FC ; Attributes: bp-based frame
.text$mn:0000A8FC
.text$mn:0000A8FC ; public: unsigned int __thiscall std::vector<class std::basic_string<wchar_t, struct std::char_traits<wchar_t>, class std::allocator<wchar_t>>, class std::allocator<class std::basic_string<wchar_t, struct std::char_traits<wchar_t>, class std::allocator<wchar_t>>>>::_Unused_capacity(void)const
.text$mn:0000A8FC                 public ?_Unused_capacity@?$vector@V?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@V?$allocator@V?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@@2@@std@@QBEIXZ
.text$mn:0000A8FC ?_Unused_capacity@?$vector@V?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@V?$allocator@V?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@@2@@std@@QBEIXZ proc near
.text$mn:0000A8FC                                         ; CODE XREF: std::vector<std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>>,std::allocator<std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>>>>::_Reserve(uint)+Bp
.text$mn:0000A8FC
.text$mn:0000A8FC var_4           = dword ptr -4
.text$mn:0000A8FC
.text$mn:0000A8FC                 push    ebp
.text$mn:0000A8FD                 mov     ebp, esp
.text$mn:0000A8FF                 push    ecx
.text$mn:0000A900                 mov     [ebp+var_4], ecx
.text$mn:0000A903                 mov     eax, [ebp+var_4]
.text$mn:0000A906                 mov     ecx, [ebp+var_4]
.text$mn:0000A909                 mov     eax, [eax+0Ch]
.text$mn:0000A90C                 sub     eax, [ecx+8]
.text$mn:0000A90F                 cdq
.text$mn:0000A910                 mov     ecx, 1Ch
.text$mn:0000A915                 idiv    ecx
.text$mn:0000A917                 mov     esp, ebp
.text$mn:0000A919                 pop     ebp
.text$mn:0000A91A                 retn
.text$mn:0000A91A ?_Unused_capacity@?$vector@V?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@V?$allocator@V?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@@2@@std@@QBEIXZ endp
.text$mn:0000A91A
.text$mn:0000A91A ; ---------------------------------------------------------------------------
.text$mn:0000A91B                 align 4
.text$mn:0000A91B _text$mn        ends
.text$mn:0000A91B
.text$mn:0000A91C ; ===========================================================================
.text$mn:0000A91C
.text$mn:0000A91C ; Segment type: Pure code
.text$mn:0000A91C ; Segment permissions: Read/Execute
.text$mn:0000A91C _text$mn        segment para public 'CODE' use32
.text$mn:0000A91C                 assume cs:_text$mn
.text$mn:0000A91C                 ;org 0A91Ch
.text$mn:0000A91C ; COMDAT (pick any)
.text$mn:0000A91C                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text$mn:0000A91C
.text$mn:0000A91C ; =============== S U B R O U T I N E =======================================
.text$mn:0000A91C
.text$mn:0000A91C ; Attributes: bp-based frame
.text$mn:0000A91C
.text$mn:0000A91C ; public: unsigned int __thiscall std::vector<wchar_t, class std::allocator<wchar_t>>::_Unused_capacity(void)const
.text$mn:0000A91C                 public ?_Unused_capacity@?$vector@_WV?$allocator@_W@std@@@std@@QBEIXZ
.text$mn:0000A91C ?_Unused_capacity@?$vector@_WV?$allocator@_W@std@@@std@@QBEIXZ proc near
.text$mn:0000A91C                                         ; CODE XREF: std::vector<wchar_t,std::allocator<wchar_t>>::_Reserve(uint)+Bp
.text$mn:0000A91C
.text$mn:0000A91C var_4           = dword ptr -4
.text$mn:0000A91C
.text$mn:0000A91C                 push    ebp
.text$mn:0000A91D                 mov     ebp, esp
.text$mn:0000A91F                 push    ecx
.text$mn:0000A920                 mov     [ebp+var_4], ecx
.text$mn:0000A923                 mov     eax, [ebp+var_4]
.text$mn:0000A926                 mov     ecx, [ebp+var_4]
.text$mn:0000A929                 mov     eax, [eax+0Ch]
.text$mn:0000A92C                 sub     eax, [ecx+8]
.text$mn:0000A92F                 sar     eax, 1
.text$mn:0000A931                 mov     esp, ebp
.text$mn:0000A933                 pop     ebp
.text$mn:0000A934                 retn
.text$mn:0000A934 ?_Unused_capacity@?$vector@_WV?$allocator@_W@std@@@std@@QBEIXZ endp
.text$mn:0000A934
.text$mn:0000A934 ; ---------------------------------------------------------------------------
.text$mn:0000A935                 align 4
.text$mn:0000A935 _text$mn        ends
.text$mn:0000A935
.text$mn:0000A938 ; ===========================================================================
.text$mn:0000A938
.text$mn:0000A938 ; Segment type: Pure code
.text$mn:0000A938 ; Segment permissions: Read/Execute
.text$mn:0000A938 _text$mn        segment para public 'CODE' use32
.text$mn:0000A938                 assume cs:_text$mn
.text$mn:0000A938                 ;org 0A938h
.text$mn:0000A938 ; COMDAT (pick any)
.text$mn:0000A938                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text$mn:0000A938
.text$mn:0000A938 ; =============== S U B R O U T I N E =======================================
.text$mn:0000A938
.text$mn:0000A938 ; Attributes: bp-based frame
.text$mn:0000A938
.text$mn:0000A938 ; public: void __thiscall std::basic_string<char, struct std::char_traits<char>, class std::allocator<char>>::_Xlen(void)const
.text$mn:0000A938                 public ?_Xlen@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QBEXXZ
.text$mn:0000A938 ?_Xlen@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QBEXXZ proc near
.text$mn:0000A938                                         ; CODE XREF: std::basic_string<char,std::char_traits<char>,std::allocator<char>>::_Grow(uint,bool)+19p
.text$mn:0000A938                                         ; std::basic_string<char,std::char_traits<char>,std::allocator<char>>::append(std::basic_string<char,std::char_traits<char>,std::allocator<char>> const &,uint,uint)+4Dp ...
.text$mn:0000A938
.text$mn:0000A938 var_4           = dword ptr -4
.text$mn:0000A938
.text$mn:0000A938                 push    ebp
.text$mn:0000A939                 mov     ebp, esp
.text$mn:0000A93B                 push    ecx
.text$mn:0000A93C                 mov     [ebp+var_4], ecx
.text$mn:0000A93F                 push    offset ??_C@_0BA@JFNIOLAK@string?5too?5long?$AA@ ; "string too long"
.text$mn:0000A944                 call    ?_Xlength_error@std@@YAXPBD@Z ; std::_Xlength_error(char const *)
.text$mn:0000A949                 mov     esp, ebp
.text$mn:0000A94B                 pop     ebp
.text$mn:0000A94C                 retn
.text$mn:0000A94C ?_Xlen@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QBEXXZ endp
.text$mn:0000A94C
.text$mn:0000A94C ; ---------------------------------------------------------------------------
.text$mn:0000A94D                 align 10h
.text$mn:0000A94D _text$mn        ends
.text$mn:0000A94D
.text$mn:0000A950 ; ===========================================================================
.text$mn:0000A950
.text$mn:0000A950 ; Segment type: Pure code
.text$mn:0000A950 ; Segment permissions: Read/Execute
.text$mn:0000A950 _text$mn        segment para public 'CODE' use32
.text$mn:0000A950                 assume cs:_text$mn
.text$mn:0000A950                 ;org 0A950h
.text$mn:0000A950 ; COMDAT (pick any)
.text$mn:0000A950                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text$mn:0000A950
.text$mn:0000A950 ; =============== S U B R O U T I N E =======================================
.text$mn:0000A950
.text$mn:0000A950 ; Attributes: bp-based frame
.text$mn:0000A950
.text$mn:0000A950 ; public: void __thiscall std::basic_string<wchar_t, struct std::char_traits<wchar_t>, class std::allocator<wchar_t>>::_Xlen(void)const
.text$mn:0000A950                 public ?_Xlen@?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QBEXXZ
.text$mn:0000A950 ?_Xlen@?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QBEXXZ proc near
.text$mn:0000A950                                         ; CODE XREF: std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>>::_Grow(uint,bool)+19p
.text$mn:0000A950                                         ; std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>>::append(std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>> const &,uint,uint)+4Dp ...
.text$mn:0000A950
.text$mn:0000A950 var_4           = dword ptr -4
.text$mn:0000A950
.text$mn:0000A950                 push    ebp
.text$mn:0000A951                 mov     ebp, esp
.text$mn:0000A953                 push    ecx
.text$mn:0000A954                 mov     [ebp+var_4], ecx
.text$mn:0000A957                 push    offset ??_C@_0BA@JFNIOLAK@string?5too?5long?$AA@ ; "string too long"
.text$mn:0000A95C                 call    ?_Xlength_error@std@@YAXPBD@Z ; std::_Xlength_error(char const *)
.text$mn:0000A961                 mov     esp, ebp
.text$mn:0000A963                 pop     ebp
.text$mn:0000A964                 retn
.text$mn:0000A964 ?_Xlen@?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QBEXXZ endp
.text$mn:0000A964
.text$mn:0000A964 ; ---------------------------------------------------------------------------
.text$mn:0000A965                 align 4
.text$mn:0000A965 _text$mn        ends
.text$mn:0000A965
.text$mn:0000A968 ; ===========================================================================
.text$mn:0000A968
.text$mn:0000A968 ; Segment type: Pure code
.text$mn:0000A968 ; Segment permissions: Read/Execute
.text$mn:0000A968 _text$mn        segment para public 'CODE' use32
.text$mn:0000A968                 assume cs:_text$mn
.text$mn:0000A968                 ;org 0A968h
.text$mn:0000A968 ; COMDAT (pick any)
.text$mn:0000A968                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text$mn:0000A968
.text$mn:0000A968 ; =============== S U B R O U T I N E =======================================
.text$mn:0000A968
.text$mn:0000A968 ; Attributes: bp-based frame
.text$mn:0000A968
.text$mn:0000A968 ; protected: void __thiscall std::vector<char, class std::allocator<char>>::_Xlen(void)const
.text$mn:0000A968                 public ?_Xlen@?$vector@DV?$allocator@D@std@@@std@@IBEXXZ
.text$mn:0000A968 ?_Xlen@?$vector@DV?$allocator@D@std@@@std@@IBEXXZ proc near
.text$mn:0000A968                                         ; CODE XREF: std::vector<char,std::allocator<char>>::_Buy(uint)+43p
.text$mn:0000A968
.text$mn:0000A968 var_4           = dword ptr -4
.text$mn:0000A968
.text$mn:0000A968                 push    ebp
.text$mn:0000A969                 mov     ebp, esp
.text$mn:0000A96B                 push    ecx
.text$mn:0000A96C                 mov     [ebp+var_4], ecx
.text$mn:0000A96F                 push    offset ??_C@_0BD@OLBABOEK@vector?$DMT?$DO?5too?5long?$AA@ ; "vector<T> too long"
.text$mn:0000A974                 call    ?_Xlength_error@std@@YAXPBD@Z ; std::_Xlength_error(char const *)
.text$mn:0000A979                 mov     esp, ebp
.text$mn:0000A97B                 pop     ebp
.text$mn:0000A97C                 retn
.text$mn:0000A97C ?_Xlen@?$vector@DV?$allocator@D@std@@@std@@IBEXXZ endp
.text$mn:0000A97C
.text$mn:0000A97C ; ---------------------------------------------------------------------------
.text$mn:0000A97D                 align 10h
.text$mn:0000A97D _text$mn        ends
.text$mn:0000A97D
.text$mn:0000A980 ; ===========================================================================
.text$mn:0000A980
.text$mn:0000A980 ; Segment type: Pure code
.text$mn:0000A980 ; Segment permissions: Read/Execute
.text$mn:0000A980 _text$mn        segment para public 'CODE' use32
.text$mn:0000A980                 assume cs:_text$mn
.text$mn:0000A980                 ;org 0A980h
.text$mn:0000A980 ; COMDAT (pick any)
.text$mn:0000A980                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text$mn:0000A980
.text$mn:0000A980 ; =============== S U B R O U T I N E =======================================
.text$mn:0000A980
.text$mn:0000A980 ; Attributes: bp-based frame
.text$mn:0000A980
.text$mn:0000A980 ; protected: void __thiscall std::vector<class std::basic_string<wchar_t, struct std::char_traits<wchar_t>, class std::allocator<wchar_t>>, class std::allocator<class std::basic_string<wchar_t, struct std::char_traits<wchar_t>, class std::allocator<wchar_t>>>>::_Xlen(void)const
.text$mn:0000A980                 public ?_Xlen@?$vector@V?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@V?$allocator@V?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@@2@@std@@IBEXXZ
.text$mn:0000A980 ?_Xlen@?$vector@V?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@V?$allocator@V?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@@2@@std@@IBEXXZ proc near
.text$mn:0000A980                                         ; CODE XREF: std::vector<std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>>,std::allocator<std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>>>>::_Reserve(uint)+31p
.text$mn:0000A980
.text$mn:0000A980 var_4           = dword ptr -4
.text$mn:0000A980
.text$mn:0000A980                 push    ebp
.text$mn:0000A981                 mov     ebp, esp
.text$mn:0000A983                 push    ecx
.text$mn:0000A984                 mov     [ebp+var_4], ecx
.text$mn:0000A987                 push    offset ??_C@_0BD@OLBABOEK@vector?$DMT?$DO?5too?5long?$AA@ ; "vector<T> too long"
.text$mn:0000A98C                 call    ?_Xlength_error@std@@YAXPBD@Z ; std::_Xlength_error(char const *)
.text$mn:0000A991                 mov     esp, ebp
.text$mn:0000A993                 pop     ebp
.text$mn:0000A994                 retn
.text$mn:0000A994 ?_Xlen@?$vector@V?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@V?$allocator@V?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@@2@@std@@IBEXXZ endp
.text$mn:0000A994
.text$mn:0000A994 ; ---------------------------------------------------------------------------
.text$mn:0000A995                 align 4
.text$mn:0000A995 _text$mn        ends
.text$mn:0000A995
.text$mn:0000A998 ; ===========================================================================
.text$mn:0000A998
.text$mn:0000A998 ; Segment type: Pure code
.text$mn:0000A998 ; Segment permissions: Read/Execute
.text$mn:0000A998 _text$mn        segment para public 'CODE' use32
.text$mn:0000A998                 assume cs:_text$mn
.text$mn:0000A998                 ;org 0A998h
.text$mn:0000A998 ; COMDAT (pick any)
.text$mn:0000A998                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text$mn:0000A998
.text$mn:0000A998 ; =============== S U B R O U T I N E =======================================
.text$mn:0000A998
.text$mn:0000A998 ; Attributes: bp-based frame
.text$mn:0000A998
.text$mn:0000A998 ; protected: void __thiscall std::vector<wchar_t, class std::allocator<wchar_t>>::_Xlen(void)const
.text$mn:0000A998                 public ?_Xlen@?$vector@_WV?$allocator@_W@std@@@std@@IBEXXZ
.text$mn:0000A998 ?_Xlen@?$vector@_WV?$allocator@_W@std@@@std@@IBEXXZ proc near
.text$mn:0000A998                                         ; CODE XREF: std::vector<wchar_t,std::allocator<wchar_t>>::_Buy(uint)+43p
.text$mn:0000A998                                         ; std::vector<wchar_t,std::allocator<wchar_t>>::_Reserve(uint)+31p
.text$mn:0000A998
.text$mn:0000A998 var_4           = dword ptr -4
.text$mn:0000A998
.text$mn:0000A998                 push    ebp
.text$mn:0000A999                 mov     ebp, esp
.text$mn:0000A99B                 push    ecx
.text$mn:0000A99C                 mov     [ebp+var_4], ecx
.text$mn:0000A99F                 push    offset ??_C@_0BD@OLBABOEK@vector?$DMT?$DO?5too?5long?$AA@ ; "vector<T> too long"
.text$mn:0000A9A4                 call    ?_Xlength_error@std@@YAXPBD@Z ; std::_Xlength_error(char const *)
.text$mn:0000A9A9                 mov     esp, ebp
.text$mn:0000A9AB                 pop     ebp
.text$mn:0000A9AC                 retn
.text$mn:0000A9AC ?_Xlen@?$vector@_WV?$allocator@_W@std@@@std@@IBEXXZ endp
.text$mn:0000A9AC
.text$mn:0000A9AC ; ---------------------------------------------------------------------------
.text$mn:0000A9AD                 align 10h
.text$mn:0000A9AD _text$mn        ends
.text$mn:0000A9AD
.text$mn:0000A9B0 ; ===========================================================================
.text$mn:0000A9B0
.text$mn:0000A9B0 ; Segment type: Pure code
.text$mn:0000A9B0 ; Segment permissions: Read/Execute
.text$mn:0000A9B0 _text$mn        segment para public 'CODE' use32
.text$mn:0000A9B0                 assume cs:_text$mn
.text$mn:0000A9B0                 ;org 0A9B0h
.text$mn:0000A9B0 ; COMDAT (pick any)
.text$mn:0000A9B0                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text$mn:0000A9B0
.text$mn:0000A9B0 ; =============== S U B R O U T I N E =======================================
.text$mn:0000A9B0
.text$mn:0000A9B0 ; Attributes: bp-based frame
.text$mn:0000A9B0
.text$mn:0000A9B0 ; public: void __thiscall std::basic_string<char, struct std::char_traits<char>, class std::allocator<char>>::_Xran(void)const
.text$mn:0000A9B0                 public ?_Xran@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QBEXXZ
.text$mn:0000A9B0 ?_Xran@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QBEXXZ proc near
.text$mn:0000A9B0                                         ; CODE XREF: std::basic_string<char,std::char_traits<char>,std::allocator<char>>::append(std::basic_string<char,std::char_traits<char>,std::allocator<char>> const &,uint,uint)+19p
.text$mn:0000A9B0                                         ; std::basic_string<char,std::char_traits<char>,std::allocator<char>>::assign(std::basic_string<char,std::char_traits<char>,std::allocator<char>> const &,uint,uint)+19p ...
.text$mn:0000A9B0
.text$mn:0000A9B0 var_4           = dword ptr -4
.text$mn:0000A9B0
.text$mn:0000A9B0                 push    ebp
.text$mn:0000A9B1                 mov     ebp, esp
.text$mn:0000A9B3                 push    ecx
.text$mn:0000A9B4                 mov     [ebp+var_4], ecx
.text$mn:0000A9B7                 push    offset ??_C@_0BI@CFPLBAOH@invalid?5string?5position?$AA@ ; "invalid string position"
.text$mn:0000A9BC                 call    ?_Xout_of_range@std@@YAXPBD@Z ; std::_Xout_of_range(char const *)
.text$mn:0000A9C1                 mov     esp, ebp
.text$mn:0000A9C3                 pop     ebp
.text$mn:0000A9C4                 retn
.text$mn:0000A9C4 ?_Xran@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QBEXXZ endp
.text$mn:0000A9C4
.text$mn:0000A9C4 ; ---------------------------------------------------------------------------
.text$mn:0000A9C5                 align 4
.text$mn:0000A9C5 _text$mn        ends
.text$mn:0000A9C5
.text$mn:0000A9C8 ; ===========================================================================
.text$mn:0000A9C8
.text$mn:0000A9C8 ; Segment type: Pure code
.text$mn:0000A9C8 ; Segment permissions: Read/Execute
.text$mn:0000A9C8 _text$mn        segment para public 'CODE' use32
.text$mn:0000A9C8                 assume cs:_text$mn
.text$mn:0000A9C8                 ;org 0A9C8h
.text$mn:0000A9C8 ; COMDAT (pick any)
.text$mn:0000A9C8                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text$mn:0000A9C8
.text$mn:0000A9C8 ; =============== S U B R O U T I N E =======================================
.text$mn:0000A9C8
.text$mn:0000A9C8 ; Attributes: bp-based frame
.text$mn:0000A9C8
.text$mn:0000A9C8 ; public: void __thiscall std::basic_string<wchar_t, struct std::char_traits<wchar_t>, class std::allocator<wchar_t>>::_Xran(void)const
.text$mn:0000A9C8                 public ?_Xran@?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QBEXXZ
.text$mn:0000A9C8 ?_Xran@?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QBEXXZ proc near
.text$mn:0000A9C8                                         ; CODE XREF: std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>>::append(std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>> const &,uint,uint)+19p
.text$mn:0000A9C8                                         ; std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>>::assign(std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>> const &,uint,uint)+19p ...
.text$mn:0000A9C8
.text$mn:0000A9C8 var_4           = dword ptr -4
.text$mn:0000A9C8
.text$mn:0000A9C8                 push    ebp
.text$mn:0000A9C9                 mov     ebp, esp
.text$mn:0000A9CB                 push    ecx
.text$mn:0000A9CC                 mov     [ebp+var_4], ecx
.text$mn:0000A9CF                 push    offset ??_C@_0BI@CFPLBAOH@invalid?5string?5position?$AA@ ; "invalid string position"
.text$mn:0000A9D4                 call    ?_Xout_of_range@std@@YAXPBD@Z ; std::_Xout_of_range(char const *)
.text$mn:0000A9D9                 mov     esp, ebp
.text$mn:0000A9DB                 pop     ebp
.text$mn:0000A9DC                 retn
.text$mn:0000A9DC ?_Xran@?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QBEXXZ endp
.text$mn:0000A9DC
.text$mn:0000A9DC ; ---------------------------------------------------------------------------
.text$mn:0000A9DD                 align 10h
.text$mn:0000A9DD _text$mn        ends
.text$mn:0000A9DD
.text$mn:0000A9E0 ; ===========================================================================
.text$mn:0000A9E0
.text$mn:0000A9E0 ; Segment type: Pure code
.text$mn:0000A9E0 ; Segment permissions: Read/Execute
.text$mn:0000A9E0 _text$mn        segment para public 'CODE' use32
.text$mn:0000A9E0                 assume cs:_text$mn
.text$mn:0000A9E0                 ;org 0A9E0h
.text$mn:0000A9E0 ; COMDAT (pick any)
.text$mn:0000A9E0                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text$mn:0000A9E0
.text$mn:0000A9E0 ; =============== S U B R O U T I N E =======================================
.text$mn:0000A9E0
.text$mn:0000A9E0 ; Attributes: bp-based frame
.text$mn:0000A9E0
.text$mn:0000A9E0 ; protected: void __thiscall std::vector<class std::basic_string<wchar_t, struct std::char_traits<wchar_t>, class std::allocator<wchar_t>>, class std::allocator<class std::basic_string<wchar_t, struct std::char_traits<wchar_t>, class std::allocator<wchar_t>>>>::_Xran(void)const
.text$mn:0000A9E0                 public ?_Xran@?$vector@V?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@V?$allocator@V?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@@2@@std@@IBEXXZ
.text$mn:0000A9E0 ?_Xran@?$vector@V?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@V?$allocator@V?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@@2@@std@@IBEXXZ proc near
.text$mn:0000A9E0                                         ; CODE XREF: std::vector<std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>>,std::allocator<std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>>>>::at(uint)+17p
.text$mn:0000A9E0
.text$mn:0000A9E0 var_4           = dword ptr -4
.text$mn:0000A9E0
.text$mn:0000A9E0                 push    ebp
.text$mn:0000A9E1                 mov     ebp, esp
.text$mn:0000A9E3                 push    ecx
.text$mn:0000A9E4                 mov     [ebp+var_4], ecx
.text$mn:0000A9E7                 push    offset ??_C@_0BM@NMJKDPPO@invalid?5vector?$DMT?$DO?5subscript?$AA@ ; "invalid vector<T> subscript"
.text$mn:0000A9EC                 call    ?_Xout_of_range@std@@YAXPBD@Z ; std::_Xout_of_range(char const *)
.text$mn:0000A9F1                 mov     esp, ebp
.text$mn:0000A9F3                 pop     ebp
.text$mn:0000A9F4                 retn
.text$mn:0000A9F4 ?_Xran@?$vector@V?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@V?$allocator@V?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@@2@@std@@IBEXXZ endp
.text$mn:0000A9F4
.text$mn:0000A9F4 ; ---------------------------------------------------------------------------
.text$mn:0000A9F5                 align 4
.text$mn:0000A9F5 _text$mn        ends
.text$mn:0000A9F5
.text$mn:0000A9F8 ; ===========================================================================
.text$mn:0000A9F8
.text$mn:0000A9F8 ; Segment type: Pure code
.text$mn:0000A9F8 ; Segment permissions: Read/Execute
.text$mn:0000A9F8 _text$mn        segment para public 'CODE' use32
.text$mn:0000A9F8                 assume cs:_text$mn
.text$mn:0000A9F8                 ;org 0A9F8h
.text$mn:0000A9F8 ; COMDAT (pick any)
.text$mn:0000A9F8                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text$mn:0000A9F8
.text$mn:0000A9F8 ; =============== S U B R O U T I N E =======================================
.text$mn:0000A9F8
.text$mn:0000A9F8 ; Attributes: bp-based frame
.text$mn:0000A9F8
.text$mn:0000A9F8 ; public: char * __thiscall std::_Wrap_alloc<class std::allocator<char>>::allocate(unsigned int)
.text$mn:0000A9F8                 public ?allocate@?$_Wrap_alloc@V?$allocator@D@std@@@std@@QAEPADI@Z
.text$mn:0000A9F8 ?allocate@?$_Wrap_alloc@V?$allocator@D@std@@@std@@QAEPADI@Z proc near
.text$mn:0000A9F8                                         ; CODE XREF: std::vector<char,std::allocator<char>>::_Buy(uint)+5Cp
.text$mn:0000A9F8                                         ; std::basic_string<char,std::char_traits<char>,std::allocator<char>>::_Copy(uint,uint)+BBp ...
.text$mn:0000A9F8
.text$mn:0000A9F8 var_4           = dword ptr -4
.text$mn:0000A9F8 arg_0           = dword ptr  8
.text$mn:0000A9F8
.text$mn:0000A9F8                 push    ebp
.text$mn:0000A9F9                 mov     ebp, esp
.text$mn:0000A9FB                 push    ecx
.text$mn:0000A9FC                 mov     [ebp+var_4], ecx
.text$mn:0000A9FF                 mov     eax, [ebp+arg_0]
.text$mn:0000AA02                 push    eax
.text$mn:0000AA03                 mov     ecx, [ebp+var_4]
.text$mn:0000AA06                 call    ?allocate@?$allocator@D@std@@QAEPADI@Z ; std::allocator<char>::allocate(uint)
.text$mn:0000AA0B                 mov     esp, ebp
.text$mn:0000AA0D                 pop     ebp
.text$mn:0000AA0E                 retn    4
.text$mn:0000AA0E ?allocate@?$_Wrap_alloc@V?$allocator@D@std@@@std@@QAEPADI@Z endp
.text$mn:0000AA0E
.text$mn:0000AA0E ; ---------------------------------------------------------------------------
.text$mn:0000AA11                 align 4
.text$mn:0000AA11 _text$mn        ends
.text$mn:0000AA11
.text$mn:0000AA14 ; ===========================================================================
.text$mn:0000AA14
.text$mn:0000AA14 ; Segment type: Pure code
.text$mn:0000AA14 ; Segment permissions: Read/Execute
.text$mn:0000AA14 _text$mn        segment para public 'CODE' use32
.text$mn:0000AA14                 assume cs:_text$mn
.text$mn:0000AA14                 ;org 0AA14h
.text$mn:0000AA14 ; COMDAT (pick any)
.text$mn:0000AA14                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text$mn:0000AA14
.text$mn:0000AA14 ; =============== S U B R O U T I N E =======================================
.text$mn:0000AA14
.text$mn:0000AA14 ; Attributes: bp-based frame
.text$mn:0000AA14
.text$mn:0000AA14 ; public: struct std::_Container_proxy * __thiscall std::_Wrap_alloc<class std::allocator<struct std::_Container_proxy>>::allocate(unsigned int)
.text$mn:0000AA14                 public ?allocate@?$_Wrap_alloc@V?$allocator@U_Container_proxy@std@@@std@@@std@@QAEPAU_Container_proxy@2@I@Z
.text$mn:0000AA14 ?allocate@?$_Wrap_alloc@V?$allocator@U_Container_proxy@std@@@std@@@std@@QAEPAU_Container_proxy@2@I@Z proc near
.text$mn:0000AA14                                         ; CODE XREF: std::_Vector_alloc<0,std::_Vec_base_types<char,std::allocator<char>>>::_Alloc_proxy(void)+16p
.text$mn:0000AA14                                         ; std::_Vector_alloc<0,std::_Vec_base_types<std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>>,std::allocator<std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>>>>>::_Alloc_proxy(void)+16p ...
.text$mn:0000AA14
.text$mn:0000AA14 var_4           = dword ptr -4
.text$mn:0000AA14 arg_0           = dword ptr  8
.text$mn:0000AA14
.text$mn:0000AA14                 push    ebp
.text$mn:0000AA15                 mov     ebp, esp
.text$mn:0000AA17                 push    ecx
.text$mn:0000AA18                 mov     [ebp+var_4], ecx
.text$mn:0000AA1B                 mov     eax, [ebp+arg_0]
.text$mn:0000AA1E                 push    eax
.text$mn:0000AA1F                 mov     ecx, [ebp+var_4]
.text$mn:0000AA22                 call    ?allocate@?$allocator@U_Container_proxy@std@@@std@@QAEPAU_Container_proxy@2@I@Z ; std::allocator<std::_Container_proxy>::allocate(uint)
.text$mn:0000AA27                 mov     esp, ebp
.text$mn:0000AA29                 pop     ebp
.text$mn:0000AA2A                 retn    4
.text$mn:0000AA2A ?allocate@?$_Wrap_alloc@V?$allocator@U_Container_proxy@std@@@std@@@std@@QAEPAU_Container_proxy@2@I@Z endp
.text$mn:0000AA2A
.text$mn:0000AA2A ; ---------------------------------------------------------------------------
.text$mn:0000AA2D                 align 10h
.text$mn:0000AA2D _text$mn        ends
.text$mn:0000AA2D
.text$mn:0000AA30 ; ===========================================================================
.text$mn:0000AA30
.text$mn:0000AA30 ; Segment type: Pure code
.text$mn:0000AA30 ; Segment permissions: Read/Execute
.text$mn:0000AA30 _text$mn        segment para public 'CODE' use32
.text$mn:0000AA30                 assume cs:_text$mn
.text$mn:0000AA30                 ;org 0AA30h
.text$mn:0000AA30 ; COMDAT (pick any)
.text$mn:0000AA30                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text$mn:0000AA30
.text$mn:0000AA30 ; =============== S U B R O U T I N E =======================================
.text$mn:0000AA30
.text$mn:0000AA30 ; Attributes: bp-based frame
.text$mn:0000AA30
.text$mn:0000AA30 ; public: class std::basic_string<wchar_t, struct std::char_traits<wchar_t>, class std::allocator<wchar_t>> * __thiscall std::_Wrap_alloc<class std::allocator<class std::basic_string<wchar_t, struct std::char_traits<wchar_t>, class std::allocator<wchar_t>>>>::allocate(unsigned int)
.text$mn:0000AA30                 public ?allocate@?$_Wrap_alloc@V?$allocator@V?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@@std@@@std@@QAEPAV?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@2@I@Z
.text$mn:0000AA30 ?allocate@?$_Wrap_alloc@V?$allocator@V?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@@std@@@std@@QAEPAV?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@2@I@Z proc near
.text$mn:0000AA30                                         ; CODE XREF: std::vector<std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>>,std::allocator<std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>>>>::_Reallocate(uint)+41p
.text$mn:0000AA30
.text$mn:0000AA30 var_4           = dword ptr -4
.text$mn:0000AA30 arg_0           = dword ptr  8
.text$mn:0000AA30
.text$mn:0000AA30                 push    ebp
.text$mn:0000AA31                 mov     ebp, esp
.text$mn:0000AA33                 push    ecx
.text$mn:0000AA34                 mov     [ebp+var_4], ecx
.text$mn:0000AA37                 mov     eax, [ebp+arg_0]
.text$mn:0000AA3A                 push    eax
.text$mn:0000AA3B                 mov     ecx, [ebp+var_4]
.text$mn:0000AA3E                 call    ?allocate@?$allocator@V?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@@std@@QAEPAV?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@2@I@Z ; std::allocator<std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>>>::allocate(uint)
.text$mn:0000AA43                 mov     esp, ebp
.text$mn:0000AA45                 pop     ebp
.text$mn:0000AA46                 retn    4
.text$mn:0000AA46 ?allocate@?$_Wrap_alloc@V?$allocator@V?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@@std@@@std@@QAEPAV?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@2@I@Z endp
.text$mn:0000AA46
.text$mn:0000AA46 ; ---------------------------------------------------------------------------
.text$mn:0000AA49                 align 4
.text$mn:0000AA49 _text$mn        ends
.text$mn:0000AA49
.text$mn:0000AA4C ; ===========================================================================
.text$mn:0000AA4C
.text$mn:0000AA4C ; Segment type: Pure code
.text$mn:0000AA4C ; Segment permissions: Read/Execute
.text$mn:0000AA4C _text$mn        segment para public 'CODE' use32
.text$mn:0000AA4C                 assume cs:_text$mn
.text$mn:0000AA4C                 ;org 0AA4Ch
.text$mn:0000AA4C ; COMDAT (pick any)
.text$mn:0000AA4C                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text$mn:0000AA4C
.text$mn:0000AA4C ; =============== S U B R O U T I N E =======================================
.text$mn:0000AA4C
.text$mn:0000AA4C ; Attributes: bp-based frame
.text$mn:0000AA4C
.text$mn:0000AA4C ; public: wchar_t * __thiscall std::_Wrap_alloc<class std::allocator<wchar_t>>::allocate(unsigned int)
.text$mn:0000AA4C                 public ?allocate@?$_Wrap_alloc@V?$allocator@_W@std@@@std@@QAEPA_WI@Z
.text$mn:0000AA4C ?allocate@?$_Wrap_alloc@V?$allocator@_W@std@@@std@@QAEPA_WI@Z proc near
.text$mn:0000AA4C                                         ; CODE XREF: std::vector<wchar_t,std::allocator<wchar_t>>::_Buy(uint)+5Cp
.text$mn:0000AA4C                                         ; std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>>::_Copy(uint,uint)+BBp ...
.text$mn:0000AA4C
.text$mn:0000AA4C var_4           = dword ptr -4
.text$mn:0000AA4C arg_0           = dword ptr  8
.text$mn:0000AA4C
.text$mn:0000AA4C                 push    ebp
.text$mn:0000AA4D                 mov     ebp, esp
.text$mn:0000AA4F                 push    ecx
.text$mn:0000AA50                 mov     [ebp+var_4], ecx
.text$mn:0000AA53                 mov     eax, [ebp+arg_0]
.text$mn:0000AA56                 push    eax
.text$mn:0000AA57                 mov     ecx, [ebp+var_4]
.text$mn:0000AA5A                 call    ?allocate@?$allocator@_W@std@@QAEPA_WI@Z ; std::allocator<wchar_t>::allocate(uint)
.text$mn:0000AA5F                 mov     esp, ebp
.text$mn:0000AA61                 pop     ebp
.text$mn:0000AA62                 retn    4
.text$mn:0000AA62 ?allocate@?$_Wrap_alloc@V?$allocator@_W@std@@@std@@QAEPA_WI@Z endp
.text$mn:0000AA62
.text$mn:0000AA62 ; ---------------------------------------------------------------------------
.text$mn:0000AA65                 align 4
.text$mn:0000AA65 _text$mn        ends
.text$mn:0000AA65
.text$mn:0000AA68 ; ===========================================================================
.text$mn:0000AA68
.text$mn:0000AA68 ; Segment type: Pure code
.text$mn:0000AA68 ; Segment permissions: Read/Execute
.text$mn:0000AA68 _text$mn        segment para public 'CODE' use32
.text$mn:0000AA68                 assume cs:_text$mn
.text$mn:0000AA68                 ;org 0AA68h
.text$mn:0000AA68 ; COMDAT (pick any)
.text$mn:0000AA68                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text$mn:0000AA68
.text$mn:0000AA68 ; =============== S U B R O U T I N E =======================================
.text$mn:0000AA68
.text$mn:0000AA68 ; Attributes: bp-based frame
.text$mn:0000AA68
.text$mn:0000AA68 ; public: char * __thiscall std::allocator<char>::allocate(unsigned int)
.text$mn:0000AA68                 public ?allocate@?$allocator@D@std@@QAEPADI@Z
.text$mn:0000AA68 ?allocate@?$allocator@D@std@@QAEPADI@Z proc near
.text$mn:0000AA68                                         ; CODE XREF: std::_Wrap_alloc<std::allocator<char>>::allocate(uint)+Ep
.text$mn:0000AA68
.text$mn:0000AA68 var_4           = dword ptr -4
.text$mn:0000AA68 arg_0           = dword ptr  8
.text$mn:0000AA68
.text$mn:0000AA68                 push    ebp
.text$mn:0000AA69                 mov     ebp, esp
.text$mn:0000AA6B                 push    ecx
.text$mn:0000AA6C                 mov     [ebp+var_4], ecx
.text$mn:0000AA6F                 push    0
.text$mn:0000AA71                 mov     eax, [ebp+arg_0]
.text$mn:0000AA74                 push    eax
.text$mn:0000AA75                 call    ??$_Allocate@D@std@@YAPADIPAD@Z ; std::_Allocate<char>(uint,char *)
.text$mn:0000AA7A                 add     esp, 8
.text$mn:0000AA7D                 mov     esp, ebp
.text$mn:0000AA7F                 pop     ebp
.text$mn:0000AA80                 retn    4
.text$mn:0000AA80 ?allocate@?$allocator@D@std@@QAEPADI@Z endp
.text$mn:0000AA80
.text$mn:0000AA80 ; ---------------------------------------------------------------------------
.text$mn:0000AA83                 align 4
.text$mn:0000AA83 _text$mn        ends
.text$mn:0000AA83
.text$mn:0000AA84 ; ===========================================================================
.text$mn:0000AA84
.text$mn:0000AA84 ; Segment type: Pure code
.text$mn:0000AA84 ; Segment permissions: Read/Execute
.text$mn:0000AA84 _text$mn        segment para public 'CODE' use32
.text$mn:0000AA84                 assume cs:_text$mn
.text$mn:0000AA84                 ;org 0AA84h
.text$mn:0000AA84 ; COMDAT (pick any)
.text$mn:0000AA84                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text$mn:0000AA84
.text$mn:0000AA84 ; =============== S U B R O U T I N E =======================================
.text$mn:0000AA84
.text$mn:0000AA84 ; Attributes: bp-based frame
.text$mn:0000AA84
.text$mn:0000AA84 ; public: struct std::_Container_proxy * __thiscall std::allocator<struct std::_Container_proxy>::allocate(unsigned int)
.text$mn:0000AA84                 public ?allocate@?$allocator@U_Container_proxy@std@@@std@@QAEPAU_Container_proxy@2@I@Z
.text$mn:0000AA84 ?allocate@?$allocator@U_Container_proxy@std@@@std@@QAEPAU_Container_proxy@2@I@Z proc near
.text$mn:0000AA84                                         ; CODE XREF: std::_String_alloc<0,std::_String_base_types<char,std::allocator<char>>>::_Alloc_proxy(void)+16p
.text$mn:0000AA84                                         ; std::_String_alloc<0,std::_String_base_types<wchar_t,std::allocator<wchar_t>>>::_Alloc_proxy(void)+16p ...
.text$mn:0000AA84
.text$mn:0000AA84 var_4           = dword ptr -4
.text$mn:0000AA84 arg_0           = dword ptr  8
.text$mn:0000AA84
.text$mn:0000AA84                 push    ebp
.text$mn:0000AA85                 mov     ebp, esp
.text$mn:0000AA87                 push    ecx
.text$mn:0000AA88                 mov     [ebp+var_4], ecx
.text$mn:0000AA8B                 push    0
.text$mn:0000AA8D                 mov     eax, [ebp+arg_0]
.text$mn:0000AA90                 push    eax
.text$mn:0000AA91                 call    ??$_Allocate@U_Container_proxy@std@@@std@@YAPAU_Container_proxy@0@IPAU10@@Z ; std::_Allocate<std::_Container_proxy>(uint,std::_Container_proxy *)
.text$mn:0000AA96                 add     esp, 8
.text$mn:0000AA99                 mov     esp, ebp
.text$mn:0000AA9B                 pop     ebp
.text$mn:0000AA9C                 retn    4
.text$mn:0000AA9C ?allocate@?$allocator@U_Container_proxy@std@@@std@@QAEPAU_Container_proxy@2@I@Z endp
.text$mn:0000AA9C
.text$mn:0000AA9C ; ---------------------------------------------------------------------------
.text$mn:0000AA9F                 align 10h
.text$mn:0000AA9F _text$mn        ends
.text$mn:0000AA9F
.text$mn:0000AAA0 ; ===========================================================================
.text$mn:0000AAA0
.text$mn:0000AAA0 ; Segment type: Pure code
.text$mn:0000AAA0 ; Segment permissions: Read/Execute
.text$mn:0000AAA0 _text$mn        segment para public 'CODE' use32
.text$mn:0000AAA0                 assume cs:_text$mn
.text$mn:0000AAA0                 ;org 0AAA0h
.text$mn:0000AAA0 ; COMDAT (pick any)
.text$mn:0000AAA0                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text$mn:0000AAA0
.text$mn:0000AAA0 ; =============== S U B R O U T I N E =======================================
.text$mn:0000AAA0
.text$mn:0000AAA0 ; Attributes: bp-based frame
.text$mn:0000AAA0
.text$mn:0000AAA0 ; public: class std::basic_string<wchar_t, struct std::char_traits<wchar_t>, class std::allocator<wchar_t>> * __thiscall std::allocator<class std::basic_string<wchar_t, struct std::char_traits<wchar_t>, class std::allocator<wchar_t>>>::allocate(unsigned int)
.text$mn:0000AAA0                 public ?allocate@?$allocator@V?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@@std@@QAEPAV?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@2@I@Z
.text$mn:0000AAA0 ?allocate@?$allocator@V?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@@std@@QAEPAV?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@2@I@Z proc near
.text$mn:0000AAA0                                         ; CODE XREF: std::_Wrap_alloc<std::allocator<std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>>>>::allocate(uint)+Ep
.text$mn:0000AAA0
.text$mn:0000AAA0 var_4           = dword ptr -4
.text$mn:0000AAA0 arg_0           = dword ptr  8
.text$mn:0000AAA0
.text$mn:0000AAA0                 push    ebp
.text$mn:0000AAA1                 mov     ebp, esp
.text$mn:0000AAA3                 push    ecx
.text$mn:0000AAA4                 mov     [ebp+var_4], ecx
.text$mn:0000AAA7                 push    0
.text$mn:0000AAA9                 mov     eax, [ebp+arg_0]
.text$mn:0000AAAC                 push    eax
.text$mn:0000AAAD                 call    ??$_Allocate@V?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@@std@@YAPAV?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@0@IPAV10@@Z ; std::_Allocate<std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>>>(uint,std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>> *)
.text$mn:0000AAB2                 add     esp, 8
.text$mn:0000AAB5                 mov     esp, ebp
.text$mn:0000AAB7                 pop     ebp
.text$mn:0000AAB8                 retn    4
.text$mn:0000AAB8 ?allocate@?$allocator@V?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@@std@@QAEPAV?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@2@I@Z endp
.text$mn:0000AAB8
.text$mn:0000AAB8 ; ---------------------------------------------------------------------------
.text$mn:0000AABB                 align 4
.text$mn:0000AABB _text$mn        ends
.text$mn:0000AABB
.text$mn:0000AABC ; ===========================================================================
.text$mn:0000AABC
.text$mn:0000AABC ; Segment type: Pure code
.text$mn:0000AABC ; Segment permissions: Read/Execute
.text$mn:0000AABC _text$mn        segment para public 'CODE' use32
.text$mn:0000AABC                 assume cs:_text$mn
.text$mn:0000AABC                 ;org 0AABCh
.text$mn:0000AABC ; COMDAT (pick any)
.text$mn:0000AABC                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text$mn:0000AABC
.text$mn:0000AABC ; =============== S U B R O U T I N E =======================================
.text$mn:0000AABC
.text$mn:0000AABC ; Attributes: bp-based frame
.text$mn:0000AABC
.text$mn:0000AABC ; public: wchar_t * __thiscall std::allocator<wchar_t>::allocate(unsigned int)
.text$mn:0000AABC                 public ?allocate@?$allocator@_W@std@@QAEPA_WI@Z
.text$mn:0000AABC ?allocate@?$allocator@_W@std@@QAEPA_WI@Z proc near
.text$mn:0000AABC                                         ; CODE XREF: std::_Wrap_alloc<std::allocator<wchar_t>>::allocate(uint)+Ep
.text$mn:0000AABC
.text$mn:0000AABC var_4           = dword ptr -4
.text$mn:0000AABC arg_0           = dword ptr  8
.text$mn:0000AABC
.text$mn:0000AABC                 push    ebp
.text$mn:0000AABD                 mov     ebp, esp
.text$mn:0000AABF                 push    ecx
.text$mn:0000AAC0                 mov     [ebp+var_4], ecx
.text$mn:0000AAC3                 push    0
.text$mn:0000AAC5                 mov     eax, [ebp+arg_0]
.text$mn:0000AAC8                 push    eax
.text$mn:0000AAC9                 call    ??$_Allocate@_W@std@@YAPA_WIPA_W@Z ; std::_Allocate<wchar_t>(uint,wchar_t *)
.text$mn:0000AACE                 add     esp, 8
.text$mn:0000AAD1                 mov     esp, ebp
.text$mn:0000AAD3                 pop     ebp
.text$mn:0000AAD4                 retn    4
.text$mn:0000AAD4 ?allocate@?$allocator@_W@std@@QAEPA_WI@Z endp
.text$mn:0000AAD4
.text$mn:0000AAD4 ; ---------------------------------------------------------------------------
.text$mn:0000AAD7                 align 4
.text$mn:0000AAD7 _text$mn        ends
.text$mn:0000AAD7
.text$mn:0000AAD8 ; ===========================================================================
.text$mn:0000AAD8
.text$mn:0000AAD8 ; Segment type: Pure code
.text$mn:0000AAD8 ; Segment permissions: Read/Execute
.text$mn:0000AAD8 _text$mn        segment para public 'CODE' use32
.text$mn:0000AAD8                 assume cs:_text$mn
.text$mn:0000AAD8                 ;org 0AAD8h
.text$mn:0000AAD8 ; COMDAT (pick any)
.text$mn:0000AAD8                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text$mn:0000AAD8
.text$mn:0000AAD8 ; =============== S U B R O U T I N E =======================================
.text$mn:0000AAD8
.text$mn:0000AAD8 ; Attributes: bp-based frame
.text$mn:0000AAD8
.text$mn:0000AAD8 ; int __stdcall std::basic_string<char,std::char_traits<char>,std::allocator<char>>::append(int, int, size_t Size)
.text$mn:0000AAD8                 public ?append@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV12@ABV12@II@Z
.text$mn:0000AAD8 ?append@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV12@ABV12@II@Z proc near
.text$mn:0000AAD8                                         ; CODE XREF: std::basic_string<char,std::char_traits<char>,std::allocator<char>>::append(char const *,uint)+51p
.text$mn:0000AAD8
.text$mn:0000AAD8 var_8           = dword ptr -8
.text$mn:0000AAD8 var_4           = dword ptr -4
.text$mn:0000AAD8 arg_0           = dword ptr  8
.text$mn:0000AAD8 arg_4           = dword ptr  0Ch
.text$mn:0000AAD8 Size            = dword ptr  10h
.text$mn:0000AAD8
.text$mn:0000AAD8                 push    ebp
.text$mn:0000AAD9                 mov     ebp, esp
.text$mn:0000AADB                 sub     esp, 8
.text$mn:0000AADE                 mov     [ebp+var_4], ecx
.text$mn:0000AAE1                 mov     ecx, [ebp+arg_0]
.text$mn:0000AAE4                 call    ?size@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QBEIXZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char>>::size(void)
.text$mn:0000AAE9                 cmp     eax, [ebp+arg_4]
.text$mn:0000AAEC                 jnb     short loc_AAF6
.text$mn:0000AAEE                 mov     ecx, [ebp+var_4]
.text$mn:0000AAF1                 call    ?_Xran@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QBEXXZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char>>::_Xran(void)
.text$mn:0000AAF6
.text$mn:0000AAF6 loc_AAF6:                               ; CODE XREF: std::basic_string<char,std::char_traits<char>,std::allocator<char>>::append(std::basic_string<char,std::char_traits<char>,std::allocator<char>> const &,uint,uint)+14j
.text$mn:0000AAF6                 mov     ecx, [ebp+arg_0]
.text$mn:0000AAF9                 call    ?size@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QBEIXZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char>>::size(void)
.text$mn:0000AAFE                 sub     eax, [ebp+arg_4]
.text$mn:0000AB01                 mov     [ebp+var_8], eax
.text$mn:0000AB04                 mov     eax, [ebp+var_8]
.text$mn:0000AB07                 cmp     eax, [ebp+Size]
.text$mn:0000AB0A                 jnb     short loc_AB12
.text$mn:0000AB0C                 mov     ecx, [ebp+var_8]
.text$mn:0000AB0F                 mov     [ebp+Size], ecx
.text$mn:0000AB12
.text$mn:0000AB12 loc_AB12:                               ; CODE XREF: std::basic_string<char,std::char_traits<char>,std::allocator<char>>::append(std::basic_string<char,std::char_traits<char>,std::allocator<char>> const &,uint,uint)+32j
.text$mn:0000AB12                 mov     edx, [ebp+var_4]
.text$mn:0000AB15                 mov     eax, ds:?npos@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@2IB ; uint const std::basic_string<char,std::char_traits<char>,std::allocator<char>>::npos
.text$mn:0000AB1A                 sub     eax, [edx+14h]
.text$mn:0000AB1D                 cmp     eax, [ebp+Size]
.text$mn:0000AB20                 ja      short loc_AB2A
.text$mn:0000AB22                 mov     ecx, [ebp+var_4]
.text$mn:0000AB25                 call    ?_Xlen@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QBEXXZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char>>::_Xlen(void)
.text$mn:0000AB2A
.text$mn:0000AB2A loc_AB2A:                               ; CODE XREF: std::basic_string<char,std::char_traits<char>,std::allocator<char>>::append(std::basic_string<char,std::char_traits<char>,std::allocator<char>> const &,uint,uint)+48j
.text$mn:0000AB2A                 cmp     [ebp+Size], 0
.text$mn:0000AB2E                 jbe     short loc_AB84
.text$mn:0000AB30                 mov     ecx, [ebp+var_4]
.text$mn:0000AB33                 mov     edx, [ecx+14h]
.text$mn:0000AB36                 add     edx, [ebp+Size]
.text$mn:0000AB39                 mov     [ebp+var_8], edx
.text$mn:0000AB3C                 push    0
.text$mn:0000AB3E                 mov     eax, [ebp+var_8]
.text$mn:0000AB41                 push    eax
.text$mn:0000AB42                 mov     ecx, [ebp+var_4]
.text$mn:0000AB45                 call    ?_Grow@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE_NI_N@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char>>::_Grow(uint,bool)
.text$mn:0000AB4A                 movzx   ecx, al
.text$mn:0000AB4D                 test    ecx, ecx
.text$mn:0000AB4F                 jz      short loc_AB84
.text$mn:0000AB51                 mov     edx, [ebp+Size]
.text$mn:0000AB54                 push    edx             ; Size
.text$mn:0000AB55                 mov     ecx, [ebp+arg_0]
.text$mn:0000AB58                 call    ?_Myptr@?$_String_val@U?$_Simple_types@D@std@@@std@@QBEPBDXZ ; std::_String_val<std::_Simple_types<char>>::_Myptr(void)
.text$mn:0000AB5D                 add     eax, [ebp+arg_4]
.text$mn:0000AB60                 push    eax             ; Src
.text$mn:0000AB61                 mov     ecx, [ebp+var_4]
.text$mn:0000AB64                 call    ?_Myptr@?$_String_val@U?$_Simple_types@D@std@@@std@@QAEPADXZ ; std::_String_val<std::_Simple_types<char>>::_Myptr(void)
.text$mn:0000AB69                 mov     ecx, [ebp+var_4]
.text$mn:0000AB6C                 add     eax, [ecx+14h]
.text$mn:0000AB6F                 push    eax             ; Dst
.text$mn:0000AB70                 call    ?copy@?$char_traits@D@std@@SAPADPADPBDI@Z ; std::char_traits<char>::copy(char *,char const *,uint)
.text$mn:0000AB75                 add     esp, 0Ch
.text$mn:0000AB78                 mov     edx, [ebp+var_8]
.text$mn:0000AB7B                 push    edx
.text$mn:0000AB7C                 mov     ecx, [ebp+var_4]
.text$mn:0000AB7F                 call    ?_Eos@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEXI@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char>>::_Eos(uint)
.text$mn:0000AB84
.text$mn:0000AB84 loc_AB84:                               ; CODE XREF: std::basic_string<char,std::char_traits<char>,std::allocator<char>>::append(std::basic_string<char,std::char_traits<char>,std::allocator<char>> const &,uint,uint)+56j
.text$mn:0000AB84                                         ; std::basic_string<char,std::char_traits<char>,std::allocator<char>>::append(std::basic_string<char,std::char_traits<char>,std::allocator<char>> const &,uint,uint)+77j
.text$mn:0000AB84                 mov     eax, [ebp+var_4]
.text$mn:0000AB87                 mov     esp, ebp
.text$mn:0000AB89                 pop     ebp
.text$mn:0000AB8A                 retn    0Ch
.text$mn:0000AB8A ?append@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV12@ABV12@II@Z endp
.text$mn:0000AB8A
.text$mn:0000AB8A ; ---------------------------------------------------------------------------
.text$mn:0000AB8D                 align 10h
.text$mn:0000AB8D _text$mn        ends
.text$mn:0000AB8D
.text$mn:0000AB90 ; ===========================================================================
.text$mn:0000AB90
.text$mn:0000AB90 ; Segment type: Pure code
.text$mn:0000AB90 ; Segment permissions: Read/Execute
.text$mn:0000AB90 _text$mn        segment para public 'CODE' use32
.text$mn:0000AB90                 assume cs:_text$mn
.text$mn:0000AB90                 ;org 0AB90h
.text$mn:0000AB90 ; COMDAT (pick any)
.text$mn:0000AB90                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text$mn:0000AB90
.text$mn:0000AB90 ; =============== S U B R O U T I N E =======================================
.text$mn:0000AB90
.text$mn:0000AB90 ; Attributes: bp-based frame
.text$mn:0000AB90
.text$mn:0000AB90 ; int __stdcall std::basic_string<char,std::char_traits<char>,std::allocator<char>>::append(char *Str)
.text$mn:0000AB90                 public ?append@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV12@PBD@Z
.text$mn:0000AB90 ?append@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV12@PBD@Z proc near
.text$mn:0000AB90                                         ; CODE XREF: std::basic_string<char,std::char_traits<char>,std::allocator<char>>::operator+=(char const *)+Ep
.text$mn:0000AB90
.text$mn:0000AB90 var_4           = dword ptr -4
.text$mn:0000AB90 Str             = dword ptr  8
.text$mn:0000AB90
.text$mn:0000AB90                 push    ebp
.text$mn:0000AB91                 mov     ebp, esp
.text$mn:0000AB93                 push    ecx
.text$mn:0000AB94                 mov     [ebp+var_4], ecx
.text$mn:0000AB97                 push    43Eh            ; unsigned int
.text$mn:0000AB9C                 push    offset ??_C@_1IO@FEAPGJBD@?$AAC?$AA?3?$AA?2?$AAP?$AAr?$AAo?$AAg?$AAr?$AAa?$AAm?$AA?5?$AAF?$AAi?$AAl?$AAe?$AAs?$AA?5?$AA?$CI?$AAx?$AA8?$AA6?$AA?$CJ?$AA?2?$AAM?$AAi?$AAc?$AAr?$AAo?$AAs?$AAo?$AAf?$AAt@ ; "C:\\Program Files (x86)\\Microsoft Visu"...
.text$mn:0000ABA1                 mov     eax, [ebp+Str]
.text$mn:0000ABA4                 push    eax             ; int
.text$mn:0000ABA5                 call    ??$_Debug_pointer@D@std@@YAXPBDPB_WI@Z ; std::_Debug_pointer<char>(char const *,wchar_t const *,uint)
.text$mn:0000ABAA                 add     esp, 0Ch
.text$mn:0000ABAD                 mov     ecx, [ebp+Str]
.text$mn:0000ABB0                 push    ecx             ; Str
.text$mn:0000ABB1                 call    ?length@?$char_traits@D@std@@SAIPBD@Z ; std::char_traits<char>::length(char const *)
.text$mn:0000ABB6                 add     esp, 4
.text$mn:0000ABB9                 push    eax             ; Size
.text$mn:0000ABBA                 mov     edx, [ebp+Str]
.text$mn:0000ABBD                 push    edx             ; Src
.text$mn:0000ABBE                 mov     ecx, [ebp+var_4]
.text$mn:0000ABC1                 call    ?append@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV12@PBDI@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char>>::append(char const *,uint)
.text$mn:0000ABC6                 mov     esp, ebp
.text$mn:0000ABC8                 pop     ebp
.text$mn:0000ABC9                 retn    4
.text$mn:0000ABC9 ?append@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV12@PBD@Z endp
.text$mn:0000ABC9
.text$mn:0000ABC9 _text$mn        ends
.text$mn:0000ABC9
.text$mn:0000ABCC ; ===========================================================================
.text$mn:0000ABCC
.text$mn:0000ABCC ; Segment type: Pure code
.text$mn:0000ABCC ; Segment permissions: Read/Execute
.text$mn:0000ABCC _text$mn        segment para public 'CODE' use32
.text$mn:0000ABCC                 assume cs:_text$mn
.text$mn:0000ABCC                 ;org 0ABCCh
.text$mn:0000ABCC ; COMDAT (pick any)
.text$mn:0000ABCC                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text$mn:0000ABCC
.text$mn:0000ABCC ; =============== S U B R O U T I N E =======================================
.text$mn:0000ABCC
.text$mn:0000ABCC ; Attributes: bp-based frame
.text$mn:0000ABCC
.text$mn:0000ABCC ; int __stdcall std::basic_string<char,std::char_traits<char>,std::allocator<char>>::append(void *Src, size_t Size)
.text$mn:0000ABCC                 public ?append@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV12@PBDI@Z
.text$mn:0000ABCC ?append@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV12@PBDI@Z proc near
.text$mn:0000ABCC                                         ; CODE XREF: std::basic_string<char,std::char_traits<char>,std::allocator<char>>::append(char const *)+31p
.text$mn:0000ABCC
.text$mn:0000ABCC var_8           = dword ptr -8
.text$mn:0000ABCC var_4           = dword ptr -4
.text$mn:0000ABCC Src             = dword ptr  8
.text$mn:0000ABCC Size            = dword ptr  0Ch
.text$mn:0000ABCC
.text$mn:0000ABCC                 push    ebp
.text$mn:0000ABCD                 mov     ebp, esp
.text$mn:0000ABCF                 sub     esp, 8
.text$mn:0000ABD2                 mov     [ebp+var_4], ecx
.text$mn:0000ABD5                 cmp     [ebp+Size], 0
.text$mn:0000ABD9                 jz      short loc_ABF1
.text$mn:0000ABDB                 push    42Ah            ; unsigned int
.text$mn:0000ABE0                 push    offset ??_C@_1IO@FEAPGJBD@?$AAC?$AA?3?$AA?2?$AAP?$AAr?$AAo?$AAg?$AAr?$AAa?$AAm?$AA?5?$AAF?$AAi?$AAl?$AAe?$AAs?$AA?5?$AA?$CI?$AAx?$AA8?$AA6?$AA?$CJ?$AA?2?$AAM?$AAi?$AAc?$AAr?$AAo?$AAs?$AAo?$AAf?$AAt@ ; "C:\\Program Files (x86)\\Microsoft Visu"...
.text$mn:0000ABE5                 mov     eax, [ebp+Src]
.text$mn:0000ABE8                 push    eax             ; int
.text$mn:0000ABE9                 call    ??$_Debug_pointer@D@std@@YAXPBDPB_WI@Z ; std::_Debug_pointer<char>(char const *,wchar_t const *,uint)
.text$mn:0000ABEE                 add     esp, 0Ch
.text$mn:0000ABF1
.text$mn:0000ABF1 loc_ABF1:                               ; CODE XREF: std::basic_string<char,std::char_traits<char>,std::allocator<char>>::append(char const *,uint)+Dj
.text$mn:0000ABF1                 mov     ecx, [ebp+Src]
.text$mn:0000ABF4                 push    ecx
.text$mn:0000ABF5                 mov     ecx, [ebp+var_4]
.text$mn:0000ABF8                 call    ?_Inside@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE_NPBD@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char>>::_Inside(char const *)
.text$mn:0000ABFD                 movzx   edx, al
.text$mn:0000AC00                 test    edx, edx
.text$mn:0000AC02                 jz      short loc_AC24
.text$mn:0000AC04                 mov     eax, [ebp+Size]
.text$mn:0000AC07                 push    eax             ; Size
.text$mn:0000AC08                 mov     ecx, [ebp+var_4]
.text$mn:0000AC0B                 call    ?_Myptr@?$_String_val@U?$_Simple_types@D@std@@@std@@QAEPADXZ ; std::_String_val<std::_Simple_types<char>>::_Myptr(void)
.text$mn:0000AC10                 mov     ecx, [ebp+Src]
.text$mn:0000AC13                 sub     ecx, eax
.text$mn:0000AC15                 push    ecx             ; int
.text$mn:0000AC16                 mov     edx, [ebp+var_4]
.text$mn:0000AC19                 push    edx             ; int
.text$mn:0000AC1A                 mov     ecx, [ebp+var_4]
.text$mn:0000AC1D                 call    ?append@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV12@ABV12@II@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char>>::append(std::basic_string<char,std::char_traits<char>,std::allocator<char>> const &,uint,uint)
.text$mn:0000AC22                 jmp     short loc_AC92
.text$mn:0000AC24 ; ---------------------------------------------------------------------------
.text$mn:0000AC24
.text$mn:0000AC24 loc_AC24:                               ; CODE XREF: std::basic_string<char,std::char_traits<char>,std::allocator<char>>::append(char const *,uint)+36j
.text$mn:0000AC24                 mov     eax, [ebp+var_4]
.text$mn:0000AC27                 mov     ecx, ds:?npos@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@2IB ; uint const std::basic_string<char,std::char_traits<char>,std::allocator<char>>::npos
.text$mn:0000AC2D                 sub     ecx, [eax+14h]
.text$mn:0000AC30                 cmp     ecx, [ebp+Size]
.text$mn:0000AC33                 ja      short loc_AC3D
.text$mn:0000AC35                 mov     ecx, [ebp+var_4]
.text$mn:0000AC38                 call    ?_Xlen@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QBEXXZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char>>::_Xlen(void)
.text$mn:0000AC3D
.text$mn:0000AC3D loc_AC3D:                               ; CODE XREF: std::basic_string<char,std::char_traits<char>,std::allocator<char>>::append(char const *,uint)+67j
.text$mn:0000AC3D                 cmp     [ebp+Size], 0
.text$mn:0000AC41                 jbe     short loc_AC8F
.text$mn:0000AC43                 mov     edx, [ebp+var_4]
.text$mn:0000AC46                 mov     eax, [edx+14h]
.text$mn:0000AC49                 add     eax, [ebp+Size]
.text$mn:0000AC4C                 mov     [ebp+var_8], eax
.text$mn:0000AC4F                 push    0
.text$mn:0000AC51                 mov     ecx, [ebp+var_8]
.text$mn:0000AC54                 push    ecx
.text$mn:0000AC55                 mov     ecx, [ebp+var_4]
.text$mn:0000AC58                 call    ?_Grow@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE_NI_N@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char>>::_Grow(uint,bool)
.text$mn:0000AC5D                 movzx   edx, al
.text$mn:0000AC60                 test    edx, edx
.text$mn:0000AC62                 jz      short loc_AC8F
.text$mn:0000AC64                 mov     eax, [ebp+Size]
.text$mn:0000AC67                 push    eax             ; Size
.text$mn:0000AC68                 mov     ecx, [ebp+Src]
.text$mn:0000AC6B                 push    ecx             ; Src
.text$mn:0000AC6C                 mov     ecx, [ebp+var_4]
.text$mn:0000AC6F                 call    ?_Myptr@?$_String_val@U?$_Simple_types@D@std@@@std@@QAEPADXZ ; std::_String_val<std::_Simple_types<char>>::_Myptr(void)
.text$mn:0000AC74                 mov     edx, [ebp+var_4]
.text$mn:0000AC77                 add     eax, [edx+14h]
.text$mn:0000AC7A                 push    eax             ; Dst
.text$mn:0000AC7B                 call    ?copy@?$char_traits@D@std@@SAPADPADPBDI@Z ; std::char_traits<char>::copy(char *,char const *,uint)
.text$mn:0000AC80                 add     esp, 0Ch
.text$mn:0000AC83                 mov     eax, [ebp+var_8]
.text$mn:0000AC86                 push    eax
.text$mn:0000AC87                 mov     ecx, [ebp+var_4]
.text$mn:0000AC8A                 call    ?_Eos@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEXI@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char>>::_Eos(uint)
.text$mn:0000AC8F
.text$mn:0000AC8F loc_AC8F:                               ; CODE XREF: std::basic_string<char,std::char_traits<char>,std::allocator<char>>::append(char const *,uint)+75j
.text$mn:0000AC8F                                         ; std::basic_string<char,std::char_traits<char>,std::allocator<char>>::append(char const *,uint)+96j
.text$mn:0000AC8F                 mov     eax, [ebp+var_4]
.text$mn:0000AC92
.text$mn:0000AC92 loc_AC92:                               ; CODE XREF: std::basic_string<char,std::char_traits<char>,std::allocator<char>>::append(char const *,uint)+56j
.text$mn:0000AC92                 mov     esp, ebp
.text$mn:0000AC94                 pop     ebp
.text$mn:0000AC95                 retn    8
.text$mn:0000AC95 ?append@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV12@PBDI@Z endp
.text$mn:0000AC95
.text$mn:0000AC95 _text$mn        ends
.text$mn:0000AC95
.text$mn:0000AC98 ; ===========================================================================
.text$mn:0000AC98
.text$mn:0000AC98 ; Segment type: Pure code
.text$mn:0000AC98 ; Segment permissions: Read/Execute
.text$mn:0000AC98 _text$mn        segment para public 'CODE' use32
.text$mn:0000AC98                 assume cs:_text$mn
.text$mn:0000AC98                 ;org 0AC98h
.text$mn:0000AC98 ; COMDAT (pick any)
.text$mn:0000AC98                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text$mn:0000AC98
.text$mn:0000AC98 ; =============== S U B R O U T I N E =======================================
.text$mn:0000AC98
.text$mn:0000AC98 ; Attributes: bp-based frame
.text$mn:0000AC98
.text$mn:0000AC98 ; public: class std::basic_string<wchar_t, struct std::char_traits<wchar_t>, class std::allocator<wchar_t>> & __thiscall std::basic_string<wchar_t, struct std::char_traits<wchar_t>, class std::allocator<wchar_t>>::append(class std::basic_string<wchar_t, struct std::char_traits<wchar_t>, class std::allocator<wchar_t>> const &)
.text$mn:0000AC98                 public ?append@?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QAEAAV12@ABV12@@Z
.text$mn:0000AC98 ?append@?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QAEAAV12@ABV12@@Z proc near
.text$mn:0000AC98                                         ; CODE XREF: BuildMenuFileName(int,uint,std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>> const &)+B2p
.text$mn:0000AC98                                         ; BuildMenuFileName(int,uint,std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>> const &)+1E3p ...
.text$mn:0000AC98
.text$mn:0000AC98 var_4           = dword ptr -4
.text$mn:0000AC98 arg_0           = dword ptr  8
.text$mn:0000AC98
.text$mn:0000AC98                 push    ebp
.text$mn:0000AC99                 mov     ebp, esp
.text$mn:0000AC9B                 push    ecx
.text$mn:0000AC9C                 mov     [ebp+var_4], ecx
.text$mn:0000AC9F                 mov     eax, ds:?npos@?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@2IB ; uint const std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>>::npos
.text$mn:0000ACA4                 push    eax
.text$mn:0000ACA5                 push    0
.text$mn:0000ACA7                 mov     ecx, [ebp+arg_0]
.text$mn:0000ACAA                 push    ecx
.text$mn:0000ACAB                 mov     ecx, [ebp+var_4]
.text$mn:0000ACAE                 call    ?append@?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QAEAAV12@ABV12@II@Z ; std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>>::append(std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>> const &,uint,uint)
.text$mn:0000ACB3                 mov     esp, ebp
.text$mn:0000ACB5                 pop     ebp
.text$mn:0000ACB6                 retn    4
.text$mn:0000ACB6 ?append@?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QAEAAV12@ABV12@@Z endp
.text$mn:0000ACB6
.text$mn:0000ACB6 ; ---------------------------------------------------------------------------
.text$mn:0000ACB9                 align 4
.text$mn:0000ACB9 _text$mn        ends
.text$mn:0000ACB9
.text$mn:0000ACBC ; ===========================================================================
.text$mn:0000ACBC
.text$mn:0000ACBC ; Segment type: Pure code
.text$mn:0000ACBC ; Segment permissions: Read/Execute
.text$mn:0000ACBC _text$mn        segment para public 'CODE' use32
.text$mn:0000ACBC                 assume cs:_text$mn
.text$mn:0000ACBC                 ;org 0ACBCh
.text$mn:0000ACBC ; COMDAT (pick any)
.text$mn:0000ACBC                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text$mn:0000ACBC
.text$mn:0000ACBC ; =============== S U B R O U T I N E =======================================
.text$mn:0000ACBC
.text$mn:0000ACBC ; Attributes: bp-based frame
.text$mn:0000ACBC
.text$mn:0000ACBC ; public: class std::basic_string<wchar_t, struct std::char_traits<wchar_t>, class std::allocator<wchar_t>> & __thiscall std::basic_string<wchar_t, struct std::char_traits<wchar_t>, class std::allocator<wchar_t>>::append(class std::basic_string<wchar_t, struct std::char_traits<wchar_t>, class std::allocator<wchar_t>> const &, unsigned int, unsigned int)
.text$mn:0000ACBC                 public ?append@?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QAEAAV12@ABV12@II@Z
.text$mn:0000ACBC ?append@?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QAEAAV12@ABV12@II@Z proc near
.text$mn:0000ACBC                                         ; CODE XREF: std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>>::append(std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>> const &)+16p
.text$mn:0000ACBC                                         ; std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>>::append(wchar_t const *,uint)+53p
.text$mn:0000ACBC
.text$mn:0000ACBC var_8           = dword ptr -8
.text$mn:0000ACBC var_4           = dword ptr -4
.text$mn:0000ACBC arg_0           = dword ptr  8
.text$mn:0000ACBC arg_4           = dword ptr  0Ch
.text$mn:0000ACBC arg_8           = dword ptr  10h
.text$mn:0000ACBC
.text$mn:0000ACBC                 push    ebp
.text$mn:0000ACBD                 mov     ebp, esp
.text$mn:0000ACBF                 sub     esp, 8
.text$mn:0000ACC2                 mov     [ebp+var_4], ecx
.text$mn:0000ACC5                 mov     ecx, [ebp+arg_0]
.text$mn:0000ACC8                 call    ?size@?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QBEIXZ ; std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>>::size(void)
.text$mn:0000ACCD                 cmp     eax, [ebp+arg_4]
.text$mn:0000ACD0                 jnb     short loc_ACDA
.text$mn:0000ACD2                 mov     ecx, [ebp+var_4]
.text$mn:0000ACD5                 call    ?_Xran@?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QBEXXZ ; std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>>::_Xran(void)
.text$mn:0000ACDA
.text$mn:0000ACDA loc_ACDA:                               ; CODE XREF: std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>>::append(std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>> const &,uint,uint)+14j
.text$mn:0000ACDA                 mov     ecx, [ebp+arg_0]
.text$mn:0000ACDD                 call    ?size@?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QBEIXZ ; std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>>::size(void)
.text$mn:0000ACE2                 sub     eax, [ebp+arg_4]
.text$mn:0000ACE5                 mov     [ebp+var_8], eax
.text$mn:0000ACE8                 mov     eax, [ebp+var_8]
.text$mn:0000ACEB                 cmp     eax, [ebp+arg_8]
.text$mn:0000ACEE                 jnb     short loc_ACF6
.text$mn:0000ACF0                 mov     ecx, [ebp+var_8]
.text$mn:0000ACF3                 mov     [ebp+arg_8], ecx
.text$mn:0000ACF6
.text$mn:0000ACF6 loc_ACF6:                               ; CODE XREF: std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>>::append(std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>> const &,uint,uint)+32j
.text$mn:0000ACF6                 mov     edx, [ebp+var_4]
.text$mn:0000ACF9                 mov     eax, ds:?npos@?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@2IB ; uint const std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>>::npos
.text$mn:0000ACFE                 sub     eax, [edx+14h]
.text$mn:0000AD01                 cmp     eax, [ebp+arg_8]
.text$mn:0000AD04                 ja      short loc_AD0E
.text$mn:0000AD06                 mov     ecx, [ebp+var_4]
.text$mn:0000AD09                 call    ?_Xlen@?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QBEXXZ ; std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>>::_Xlen(void)
.text$mn:0000AD0E
.text$mn:0000AD0E loc_AD0E:                               ; CODE XREF: std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>>::append(std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>> const &,uint,uint)+48j
.text$mn:0000AD0E                 cmp     [ebp+arg_8], 0
.text$mn:0000AD12                 jbe     short loc_AD6E
.text$mn:0000AD14                 mov     ecx, [ebp+var_4]
.text$mn:0000AD17                 mov     edx, [ecx+14h]
.text$mn:0000AD1A                 add     edx, [ebp+arg_8]
.text$mn:0000AD1D                 mov     [ebp+var_8], edx
.text$mn:0000AD20                 push    0
.text$mn:0000AD22                 mov     eax, [ebp+var_8]
.text$mn:0000AD25                 push    eax
.text$mn:0000AD26                 mov     ecx, [ebp+var_4]
.text$mn:0000AD29                 call    ?_Grow@?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QAE_NI_N@Z ; std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>>::_Grow(uint,bool)
.text$mn:0000AD2E                 movzx   ecx, al
.text$mn:0000AD31                 test    ecx, ecx
.text$mn:0000AD33                 jz      short loc_AD6E
.text$mn:0000AD35                 mov     edx, [ebp+arg_8]
.text$mn:0000AD38                 push    edx             ; int
.text$mn:0000AD39                 mov     ecx, [ebp+arg_0]
.text$mn:0000AD3C                 call    ?_Myptr@?$_String_val@U?$_Simple_types@_W@std@@@std@@QBEPB_WXZ ; std::_String_val<std::_Simple_types<wchar_t>>::_Myptr(void)
.text$mn:0000AD41                 mov     ecx, [ebp+arg_4]
.text$mn:0000AD44                 lea     edx, [eax+ecx*2]
.text$mn:0000AD47                 push    edx             ; Src
.text$mn:0000AD48                 mov     ecx, [ebp+var_4]
.text$mn:0000AD4B                 call    ?_Myptr@?$_String_val@U?$_Simple_types@_W@std@@@std@@QAEPA_WXZ ; std::_String_val<std::_Simple_types<wchar_t>>::_Myptr(void)
.text$mn:0000AD50                 mov     ecx, [ebp+var_4]
.text$mn:0000AD53                 mov     edx, [ecx+14h]
.text$mn:0000AD56                 lea     eax, [eax+edx*2]
.text$mn:0000AD59                 push    eax             ; Dst
.text$mn:0000AD5A                 call    ?copy@?$char_traits@_W@std@@SAPA_WPA_WPB_WI@Z ; std::char_traits<wchar_t>::copy(wchar_t *,wchar_t const *,uint)
.text$mn:0000AD5F                 add     esp, 0Ch
.text$mn:0000AD62                 mov     ecx, [ebp+var_8]
.text$mn:0000AD65                 push    ecx
.text$mn:0000AD66                 mov     ecx, [ebp+var_4]
.text$mn:0000AD69                 call    ?_Eos@?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QAEXI@Z ; std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>>::_Eos(uint)
.text$mn:0000AD6E
.text$mn:0000AD6E loc_AD6E:                               ; CODE XREF: std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>>::append(std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>> const &,uint,uint)+56j
.text$mn:0000AD6E                                         ; std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>>::append(std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>> const &,uint,uint)+77j
.text$mn:0000AD6E                 mov     eax, [ebp+var_4]
.text$mn:0000AD71                 mov     esp, ebp
.text$mn:0000AD73                 pop     ebp
.text$mn:0000AD74                 retn    0Ch
.text$mn:0000AD74 ?append@?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QAEAAV12@ABV12@II@Z endp
.text$mn:0000AD74
.text$mn:0000AD74 ; ---------------------------------------------------------------------------
.text$mn:0000AD77                 align 4
.text$mn:0000AD77 _text$mn        ends
.text$mn:0000AD77
.text$mn:0000AD78 ; ===========================================================================
.text$mn:0000AD78
.text$mn:0000AD78 ; Segment type: Pure code
.text$mn:0000AD78 ; Segment permissions: Read/Execute
.text$mn:0000AD78 _text$mn        segment para public 'CODE' use32
.text$mn:0000AD78                 assume cs:_text$mn
.text$mn:0000AD78                 ;org 0AD78h
.text$mn:0000AD78 ; COMDAT (pick any)
.text$mn:0000AD78                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text$mn:0000AD78
.text$mn:0000AD78 ; =============== S U B R O U T I N E =======================================
.text$mn:0000AD78
.text$mn:0000AD78 ; Attributes: bp-based frame
.text$mn:0000AD78
.text$mn:0000AD78 ; public: class std::basic_string<wchar_t, struct std::char_traits<wchar_t>, class std::allocator<wchar_t>> & __thiscall std::basic_string<wchar_t, struct std::char_traits<wchar_t>, class std::allocator<wchar_t>>::append(unsigned int, wchar_t)
.text$mn:0000AD78                 public ?append@?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QAEAAV12@I_W@Z
.text$mn:0000AD78 ?append@?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QAEAAV12@I_W@Z proc near
.text$mn:0000AD78                                         ; CODE XREF: std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>>::_Construct<std::reverse_iterator<std::_Vector_iterator<std::_Vector_val<std::_Simple_types<wchar_t>>>>>(std::reverse_iterator<std::_Vector_iterator<std::_Vector_val<std::_Simple_types<wchar_t>>>>,std::reverse_iterator<std::_Vector_iterator<std::_Vector_val<std::_Simple_types<wchar_t>>>>,std::forward_iterator_tag)+120p
.text$mn:0000AD78                                         ; std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>>::operator+=(wchar_t)+11p
.text$mn:0000AD78
.text$mn:0000AD78 var_8           = dword ptr -8
.text$mn:0000AD78 var_4           = dword ptr -4
.text$mn:0000AD78 arg_0           = dword ptr  8
.text$mn:0000AD78 arg_4           = word ptr  0Ch
.text$mn:0000AD78
.text$mn:0000AD78                 push    ebp
.text$mn:0000AD79                 mov     ebp, esp
.text$mn:0000AD7B                 sub     esp, 8
.text$mn:0000AD7E                 mov     [ebp+var_4], ecx
.text$mn:0000AD81                 mov     eax, [ebp+var_4]
.text$mn:0000AD84                 mov     ecx, ds:?npos@?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@2IB ; uint const std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>>::npos
.text$mn:0000AD8A                 sub     ecx, [eax+14h]
.text$mn:0000AD8D                 cmp     ecx, [ebp+arg_0]
.text$mn:0000AD90                 ja      short loc_AD9A
.text$mn:0000AD92                 mov     ecx, [ebp+var_4]
.text$mn:0000AD95                 call    ?_Xlen@?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QBEXXZ ; std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>>::_Xlen(void)
.text$mn:0000AD9A
.text$mn:0000AD9A loc_AD9A:                               ; CODE XREF: std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>>::append(uint,wchar_t)+18j
.text$mn:0000AD9A                 cmp     [ebp+arg_0], 0
.text$mn:0000AD9E                 jbe     short loc_ADE5
.text$mn:0000ADA0                 mov     edx, [ebp+var_4]
.text$mn:0000ADA3                 mov     eax, [edx+14h]
.text$mn:0000ADA6                 add     eax, [ebp+arg_0]
.text$mn:0000ADA9                 mov     [ebp+var_8], eax
.text$mn:0000ADAC                 push    0
.text$mn:0000ADAE                 mov     ecx, [ebp+var_8]
.text$mn:0000ADB1                 push    ecx
.text$mn:0000ADB2                 mov     ecx, [ebp+var_4]
.text$mn:0000ADB5                 call    ?_Grow@?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QAE_NI_N@Z ; std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>>::_Grow(uint,bool)
.text$mn:0000ADBA                 movzx   edx, al
.text$mn:0000ADBD                 test    edx, edx
.text$mn:0000ADBF                 jz      short loc_ADE5
.text$mn:0000ADC1                 movzx   eax, [ebp+arg_4]
.text$mn:0000ADC5                 push    eax
.text$mn:0000ADC6                 mov     ecx, [ebp+arg_0]
.text$mn:0000ADC9                 push    ecx
.text$mn:0000ADCA                 mov     edx, [ebp+var_4]
.text$mn:0000ADCD                 mov     eax, [edx+14h]
.text$mn:0000ADD0                 push    eax
.text$mn:0000ADD1                 mov     ecx, [ebp+var_4]
.text$mn:0000ADD4                 call    ?_Chassign@?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QAEXII_W@Z ; std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>>::_Chassign(uint,uint,wchar_t)
.text$mn:0000ADD9                 mov     ecx, [ebp+var_8]
.text$mn:0000ADDC                 push    ecx
.text$mn:0000ADDD                 mov     ecx, [ebp+var_4]
.text$mn:0000ADE0                 call    ?_Eos@?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QAEXI@Z ; std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>>::_Eos(uint)
.text$mn:0000ADE5
.text$mn:0000ADE5 loc_ADE5:                               ; CODE XREF: std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>>::append(uint,wchar_t)+26j
.text$mn:0000ADE5                                         ; std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>>::append(uint,wchar_t)+47j
.text$mn:0000ADE5                 mov     eax, [ebp+var_4]
.text$mn:0000ADE8                 mov     esp, ebp
.text$mn:0000ADEA                 pop     ebp
.text$mn:0000ADEB                 retn    8
.text$mn:0000ADEB ?append@?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QAEAAV12@I_W@Z endp
.text$mn:0000ADEB
.text$mn:0000ADEB ; ---------------------------------------------------------------------------
.text$mn:0000ADEE                 align 10h
.text$mn:0000ADEE _text$mn        ends
.text$mn:0000ADEE
.text$mn:0000ADF0 ; ===========================================================================
.text$mn:0000ADF0
.text$mn:0000ADF0 ; Segment type: Pure code
.text$mn:0000ADF0 ; Segment permissions: Read/Execute
.text$mn:0000ADF0 _text$mn        segment para public 'CODE' use32
.text$mn:0000ADF0                 assume cs:_text$mn
.text$mn:0000ADF0                 ;org 0ADF0h
.text$mn:0000ADF0 ; COMDAT (pick any)
.text$mn:0000ADF0                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text$mn:0000ADF0
.text$mn:0000ADF0 ; =============== S U B R O U T I N E =======================================
.text$mn:0000ADF0
.text$mn:0000ADF0 ; Attributes: bp-based frame
.text$mn:0000ADF0
.text$mn:0000ADF0 ; int __stdcall std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>>::append(wchar_t *Str)
.text$mn:0000ADF0                 public ?append@?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QAEAAV12@PB_W@Z
.text$mn:0000ADF0 ?append@?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QAEAAV12@PB_W@Z proc near
.text$mn:0000ADF0                                         ; CODE XREF: BuildMenuFileName(int,uint,std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>> const &)+75p
.text$mn:0000ADF0                                         ; BuildMenuFileName(int,uint,std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>> const &)+CEp ...
.text$mn:0000ADF0
.text$mn:0000ADF0 var_4           = dword ptr -4
.text$mn:0000ADF0 Str             = dword ptr  8
.text$mn:0000ADF0
.text$mn:0000ADF0                 push    ebp
.text$mn:0000ADF1                 mov     ebp, esp
.text$mn:0000ADF3                 push    ecx
.text$mn:0000ADF4                 mov     [ebp+var_4], ecx
.text$mn:0000ADF7                 push    43Eh            ; unsigned int
.text$mn:0000ADFC                 push    offset ??_C@_1IO@FEAPGJBD@?$AAC?$AA?3?$AA?2?$AAP?$AAr?$AAo?$AAg?$AAr?$AAa?$AAm?$AA?5?$AAF?$AAi?$AAl?$AAe?$AAs?$AA?5?$AA?$CI?$AAx?$AA8?$AA6?$AA?$CJ?$AA?2?$AAM?$AAi?$AAc?$AAr?$AAo?$AAs?$AAo?$AAf?$AAt@ ; "C:\\Program Files (x86)\\Microsoft Visu"...
.text$mn:0000AE01                 mov     eax, [ebp+Str]
.text$mn:0000AE04                 push    eax             ; int
.text$mn:0000AE05                 call    ??$_Debug_pointer@_W@std@@YAXPB_W0I@Z ; std::_Debug_pointer<wchar_t>(wchar_t const *,wchar_t const *,uint)
.text$mn:0000AE0A                 add     esp, 0Ch
.text$mn:0000AE0D                 mov     ecx, [ebp+Str]
.text$mn:0000AE10                 push    ecx             ; Str
.text$mn:0000AE11                 call    ?length@?$char_traits@_W@std@@SAIPB_W@Z ; std::char_traits<wchar_t>::length(wchar_t const *)
.text$mn:0000AE16                 add     esp, 4
.text$mn:0000AE19                 push    eax             ; int
.text$mn:0000AE1A                 mov     edx, [ebp+Str]
.text$mn:0000AE1D                 push    edx             ; Src
.text$mn:0000AE1E                 mov     ecx, [ebp+var_4]
.text$mn:0000AE21                 call    ?append@?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QAEAAV12@PB_WI@Z ; std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>>::append(wchar_t const *,uint)
.text$mn:0000AE26                 mov     esp, ebp
.text$mn:0000AE28                 pop     ebp
.text$mn:0000AE29                 retn    4
.text$mn:0000AE29 ?append@?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QAEAAV12@PB_W@Z endp
.text$mn:0000AE29
.text$mn:0000AE29 _text$mn        ends
.text$mn:0000AE29
.text$mn:0000AE2C ; ===========================================================================
.text$mn:0000AE2C
.text$mn:0000AE2C ; Segment type: Pure code
.text$mn:0000AE2C ; Segment permissions: Read/Execute
.text$mn:0000AE2C _text$mn        segment para public 'CODE' use32
.text$mn:0000AE2C                 assume cs:_text$mn
.text$mn:0000AE2C                 ;org 0AE2Ch
.text$mn:0000AE2C ; COMDAT (pick any)
.text$mn:0000AE2C                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text$mn:0000AE2C
.text$mn:0000AE2C ; =============== S U B R O U T I N E =======================================
.text$mn:0000AE2C
.text$mn:0000AE2C ; Attributes: bp-based frame
.text$mn:0000AE2C
.text$mn:0000AE2C ; int __stdcall std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>>::append(void *Src, int)
.text$mn:0000AE2C                 public ?append@?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QAEAAV12@PB_WI@Z
.text$mn:0000AE2C ?append@?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QAEAAV12@PB_WI@Z proc near
.text$mn:0000AE2C                                         ; CODE XREF: std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>>::append(wchar_t const *)+31p
.text$mn:0000AE2C
.text$mn:0000AE2C var_8           = dword ptr -8
.text$mn:0000AE2C var_4           = dword ptr -4
.text$mn:0000AE2C Src             = dword ptr  8
.text$mn:0000AE2C arg_4           = dword ptr  0Ch
.text$mn:0000AE2C
.text$mn:0000AE2C                 push    ebp
.text$mn:0000AE2D                 mov     ebp, esp
.text$mn:0000AE2F                 sub     esp, 8
.text$mn:0000AE32                 mov     [ebp+var_4], ecx
.text$mn:0000AE35                 cmp     [ebp+arg_4], 0
.text$mn:0000AE39                 jz      short loc_AE51
.text$mn:0000AE3B                 push    42Ah            ; unsigned int
.text$mn:0000AE40                 push    offset ??_C@_1IO@FEAPGJBD@?$AAC?$AA?3?$AA?2?$AAP?$AAr?$AAo?$AAg?$AAr?$AAa?$AAm?$AA?5?$AAF?$AAi?$AAl?$AAe?$AAs?$AA?5?$AA?$CI?$AAx?$AA8?$AA6?$AA?$CJ?$AA?2?$AAM?$AAi?$AAc?$AAr?$AAo?$AAs?$AAo?$AAf?$AAt@ ; "C:\\Program Files (x86)\\Microsoft Visu"...
.text$mn:0000AE45                 mov     eax, [ebp+Src]
.text$mn:0000AE48                 push    eax             ; int
.text$mn:0000AE49                 call    ??$_Debug_pointer@_W@std@@YAXPB_W0I@Z ; std::_Debug_pointer<wchar_t>(wchar_t const *,wchar_t const *,uint)
.text$mn:0000AE4E                 add     esp, 0Ch
.text$mn:0000AE51
.text$mn:0000AE51 loc_AE51:                               ; CODE XREF: std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>>::append(wchar_t const *,uint)+Dj
.text$mn:0000AE51                 mov     ecx, [ebp+Src]
.text$mn:0000AE54                 push    ecx
.text$mn:0000AE55                 mov     ecx, [ebp+var_4]
.text$mn:0000AE58                 call    ?_Inside@?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QAE_NPB_W@Z ; std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>>::_Inside(wchar_t const *)
.text$mn:0000AE5D                 movzx   edx, al
.text$mn:0000AE60                 test    edx, edx
.text$mn:0000AE62                 jz      short loc_AE86
.text$mn:0000AE64                 mov     eax, [ebp+arg_4]
.text$mn:0000AE67                 push    eax
.text$mn:0000AE68                 mov     ecx, [ebp+var_4]
.text$mn:0000AE6B                 call    ?_Myptr@?$_String_val@U?$_Simple_types@_W@std@@@std@@QAEPA_WXZ ; std::_String_val<std::_Simple_types<wchar_t>>::_Myptr(void)
.text$mn:0000AE70                 mov     ecx, [ebp+Src]
.text$mn:0000AE73                 sub     ecx, eax
.text$mn:0000AE75                 sar     ecx, 1
.text$mn:0000AE77                 push    ecx
.text$mn:0000AE78                 mov     edx, [ebp+var_4]
.text$mn:0000AE7B                 push    edx
.text$mn:0000AE7C                 mov     ecx, [ebp+var_4]
.text$mn:0000AE7F                 call    ?append@?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QAEAAV12@ABV12@II@Z ; std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>>::append(std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>> const &,uint,uint)
.text$mn:0000AE84                 jmp     short loc_AEF7
.text$mn:0000AE86 ; ---------------------------------------------------------------------------
.text$mn:0000AE86
.text$mn:0000AE86 loc_AE86:                               ; CODE XREF: std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>>::append(wchar_t const *,uint)+36j
.text$mn:0000AE86                 mov     eax, [ebp+var_4]
.text$mn:0000AE89                 mov     ecx, ds:?npos@?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@2IB ; uint const std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>>::npos
.text$mn:0000AE8F                 sub     ecx, [eax+14h]
.text$mn:0000AE92                 cmp     ecx, [ebp+arg_4]
.text$mn:0000AE95                 ja      short loc_AE9F
.text$mn:0000AE97                 mov     ecx, [ebp+var_4]
.text$mn:0000AE9A                 call    ?_Xlen@?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QBEXXZ ; std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>>::_Xlen(void)
.text$mn:0000AE9F
.text$mn:0000AE9F loc_AE9F:                               ; CODE XREF: std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>>::append(wchar_t const *,uint)+69j
.text$mn:0000AE9F                 cmp     [ebp+arg_4], 0
.text$mn:0000AEA3                 jbe     short loc_AEF4
.text$mn:0000AEA5                 mov     edx, [ebp+var_4]
.text$mn:0000AEA8                 mov     eax, [edx+14h]
.text$mn:0000AEAB                 add     eax, [ebp+arg_4]
.text$mn:0000AEAE                 mov     [ebp+var_8], eax
.text$mn:0000AEB1                 push    0
.text$mn:0000AEB3                 mov     ecx, [ebp+var_8]
.text$mn:0000AEB6                 push    ecx
.text$mn:0000AEB7                 mov     ecx, [ebp+var_4]
.text$mn:0000AEBA                 call    ?_Grow@?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QAE_NI_N@Z ; std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>>::_Grow(uint,bool)
.text$mn:0000AEBF                 movzx   edx, al
.text$mn:0000AEC2                 test    edx, edx
.text$mn:0000AEC4                 jz      short loc_AEF4
.text$mn:0000AEC6                 mov     eax, [ebp+arg_4]
.text$mn:0000AEC9                 push    eax             ; int
.text$mn:0000AECA                 mov     ecx, [ebp+Src]
.text$mn:0000AECD                 push    ecx             ; Src
.text$mn:0000AECE                 mov     ecx, [ebp+var_4]
.text$mn:0000AED1                 call    ?_Myptr@?$_String_val@U?$_Simple_types@_W@std@@@std@@QAEPA_WXZ ; std::_String_val<std::_Simple_types<wchar_t>>::_Myptr(void)
.text$mn:0000AED6                 mov     edx, [ebp+var_4]
.text$mn:0000AED9                 mov     ecx, [edx+14h]
.text$mn:0000AEDC                 lea     edx, [eax+ecx*2]
.text$mn:0000AEDF                 push    edx             ; Dst
.text$mn:0000AEE0                 call    ?copy@?$char_traits@_W@std@@SAPA_WPA_WPB_WI@Z ; std::char_traits<wchar_t>::copy(wchar_t *,wchar_t const *,uint)
.text$mn:0000AEE5                 add     esp, 0Ch
.text$mn:0000AEE8                 mov     eax, [ebp+var_8]
.text$mn:0000AEEB                 push    eax
.text$mn:0000AEEC                 mov     ecx, [ebp+var_4]
.text$mn:0000AEEF                 call    ?_Eos@?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QAEXI@Z ; std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>>::_Eos(uint)
.text$mn:0000AEF4
.text$mn:0000AEF4 loc_AEF4:                               ; CODE XREF: std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>>::append(wchar_t const *,uint)+77j
.text$mn:0000AEF4                                         ; std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>>::append(wchar_t const *,uint)+98j
.text$mn:0000AEF4                 mov     eax, [ebp+var_4]
.text$mn:0000AEF7
.text$mn:0000AEF7 loc_AEF7:                               ; CODE XREF: std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>>::append(wchar_t const *,uint)+58j
.text$mn:0000AEF7                 mov     esp, ebp
.text$mn:0000AEF9                 pop     ebp
.text$mn:0000AEFA                 retn    8
.text$mn:0000AEFA ?append@?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QAEAAV12@PB_WI@Z endp
.text$mn:0000AEFA
.text$mn:0000AEFA ; ---------------------------------------------------------------------------
.text$mn:0000AEFD                 align 10h
.text$mn:0000AEFD _text$mn        ends
.text$mn:0000AEFD
.text$mn:0000AF00 ; ===========================================================================
.text$mn:0000AF00
.text$mn:0000AF00 ; Segment type: Pure code
.text$mn:0000AF00 ; Segment permissions: Read/Execute
.text$mn:0000AF00 _text$mn        segment para public 'CODE' use32
.text$mn:0000AF00                 assume cs:_text$mn
.text$mn:0000AF00                 ;org 0AF00h
.text$mn:0000AF00 ; COMDAT (pick any)
.text$mn:0000AF00                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text$mn:0000AF00
.text$mn:0000AF00 ; =============== S U B R O U T I N E =======================================
.text$mn:0000AF00
.text$mn:0000AF00 ; Attributes: bp-based frame
.text$mn:0000AF00
.text$mn:0000AF00 ; public: class std::basic_string<char, struct std::char_traits<char>, class std::allocator<char>> & __thiscall std::basic_string<char, struct std::char_traits<char>, class std::allocator<char>>::assign(class std::basic_string<char, struct std::char_traits<char>, class std::allocator<char>> const &, unsigned int, unsigned int)
.text$mn:0000AF00                 public ?assign@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV12@ABV12@II@Z
.text$mn:0000AF00 ?assign@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV12@ABV12@II@Z proc near
.text$mn:0000AF00                                         ; CODE XREF: std::basic_string<char,std::char_traits<char>,std::allocator<char>>::assign(char const *,uint)+4Fp
.text$mn:0000AF00
.text$mn:0000AF00 Size            = dword ptr -8
.text$mn:0000AF00 var_4           = dword ptr -4
.text$mn:0000AF00 arg_0           = dword ptr  8
.text$mn:0000AF00 arg_4           = dword ptr  0Ch
.text$mn:0000AF00 arg_8           = dword ptr  10h
.text$mn:0000AF00
.text$mn:0000AF00                 push    ebp
.text$mn:0000AF01                 mov     ebp, esp
.text$mn:0000AF03                 sub     esp, 8
.text$mn:0000AF06                 mov     [ebp+var_4], ecx
.text$mn:0000AF09                 mov     ecx, [ebp+arg_0]
.text$mn:0000AF0C                 call    ?size@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QBEIXZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char>>::size(void)
.text$mn:0000AF11                 cmp     eax, [ebp+arg_4]
.text$mn:0000AF14                 jnb     short loc_AF1E
.text$mn:0000AF16                 mov     ecx, [ebp+var_4]
.text$mn:0000AF19                 call    ?_Xran@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QBEXXZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char>>::_Xran(void)
.text$mn:0000AF1E
.text$mn:0000AF1E loc_AF1E:                               ; CODE XREF: std::basic_string<char,std::char_traits<char>,std::allocator<char>>::assign(std::basic_string<char,std::char_traits<char>,std::allocator<char>> const &,uint,uint)+14j
.text$mn:0000AF1E                 mov     ecx, [ebp+arg_0]
.text$mn:0000AF21                 call    ?size@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QBEIXZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char>>::size(void)
.text$mn:0000AF26                 sub     eax, [ebp+arg_4]
.text$mn:0000AF29                 mov     [ebp+Size], eax
.text$mn:0000AF2C                 mov     eax, [ebp+arg_8]
.text$mn:0000AF2F                 cmp     eax, [ebp+Size]
.text$mn:0000AF32                 jnb     short loc_AF3A
.text$mn:0000AF34                 mov     ecx, [ebp+arg_8]
.text$mn:0000AF37                 mov     [ebp+Size], ecx
.text$mn:0000AF3A
.text$mn:0000AF3A loc_AF3A:                               ; CODE XREF: std::basic_string<char,std::char_traits<char>,std::allocator<char>>::assign(std::basic_string<char,std::char_traits<char>,std::allocator<char>> const &,uint,uint)+32j
.text$mn:0000AF3A                 mov     edx, [ebp+var_4]
.text$mn:0000AF3D                 cmp     edx, [ebp+arg_0]
.text$mn:0000AF40                 jnz     short loc_AF61
.text$mn:0000AF42                 mov     eax, [ebp+arg_4]
.text$mn:0000AF45                 add     eax, [ebp+Size]
.text$mn:0000AF48                 push    eax
.text$mn:0000AF49                 mov     ecx, [ebp+var_4]
.text$mn:0000AF4C                 call    ?erase@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV12@I@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char>>::erase(uint)
.text$mn:0000AF51                 mov     ecx, [ebp+arg_4]
.text$mn:0000AF54                 push    ecx
.text$mn:0000AF55                 push    0
.text$mn:0000AF57                 mov     ecx, [ebp+var_4]
.text$mn:0000AF5A                 call    ?erase@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV12@II@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char>>::erase(uint,uint)
.text$mn:0000AF5F                 jmp     short loc_AFA3
.text$mn:0000AF61 ; ---------------------------------------------------------------------------
.text$mn:0000AF61
.text$mn:0000AF61 loc_AF61:                               ; CODE XREF: std::basic_string<char,std::char_traits<char>,std::allocator<char>>::assign(std::basic_string<char,std::char_traits<char>,std::allocator<char>> const &,uint,uint)+40j
.text$mn:0000AF61                 push    0
.text$mn:0000AF63                 mov     edx, [ebp+Size]
.text$mn:0000AF66                 push    edx
.text$mn:0000AF67                 mov     ecx, [ebp+var_4]
.text$mn:0000AF6A                 call    ?_Grow@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE_NI_N@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char>>::_Grow(uint,bool)
.text$mn:0000AF6F                 movzx   eax, al
.text$mn:0000AF72                 test    eax, eax
.text$mn:0000AF74                 jz      short loc_AFA3
.text$mn:0000AF76                 mov     ecx, [ebp+Size]
.text$mn:0000AF79                 push    ecx             ; Size
.text$mn:0000AF7A                 mov     ecx, [ebp+arg_0]
.text$mn:0000AF7D                 call    ?_Myptr@?$_String_val@U?$_Simple_types@D@std@@@std@@QBEPBDXZ ; std::_String_val<std::_Simple_types<char>>::_Myptr(void)
.text$mn:0000AF82                 add     eax, [ebp+arg_4]
.text$mn:0000AF85                 push    eax             ; Src
.text$mn:0000AF86                 mov     ecx, [ebp+var_4]
.text$mn:0000AF89                 call    ?_Myptr@?$_String_val@U?$_Simple_types@D@std@@@std@@QAEPADXZ ; std::_String_val<std::_Simple_types<char>>::_Myptr(void)
.text$mn:0000AF8E                 push    eax             ; Dst
.text$mn:0000AF8F                 call    ?copy@?$char_traits@D@std@@SAPADPADPBDI@Z ; std::char_traits<char>::copy(char *,char const *,uint)
.text$mn:0000AF94                 add     esp, 0Ch
.text$mn:0000AF97                 mov     edx, [ebp+Size]
.text$mn:0000AF9A                 push    edx
.text$mn:0000AF9B                 mov     ecx, [ebp+var_4]
.text$mn:0000AF9E                 call    ?_Eos@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEXI@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char>>::_Eos(uint)
.text$mn:0000AFA3
.text$mn:0000AFA3 loc_AFA3:                               ; CODE XREF: std::basic_string<char,std::char_traits<char>,std::allocator<char>>::assign(std::basic_string<char,std::char_traits<char>,std::allocator<char>> const &,uint,uint)+5Fj
.text$mn:0000AFA3                                         ; std::basic_string<char,std::char_traits<char>,std::allocator<char>>::assign(std::basic_string<char,std::char_traits<char>,std::allocator<char>> const &,uint,uint)+74j
.text$mn:0000AFA3                 mov     eax, [ebp+var_4]
.text$mn:0000AFA6                 mov     esp, ebp
.text$mn:0000AFA8                 pop     ebp
.text$mn:0000AFA9                 retn    0Ch
.text$mn:0000AFA9 ?assign@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV12@ABV12@II@Z endp
.text$mn:0000AFA9
.text$mn:0000AFA9 _text$mn        ends
.text$mn:0000AFA9
.text$mn:0000AFAC ; ===========================================================================
.text$mn:0000AFAC
.text$mn:0000AFAC ; Segment type: Pure code
.text$mn:0000AFAC ; Segment permissions: Read/Execute
.text$mn:0000AFAC _text$mn        segment para public 'CODE' use32
.text$mn:0000AFAC                 assume cs:_text$mn
.text$mn:0000AFAC                 ;org 0AFACh
.text$mn:0000AFAC ; COMDAT (pick any)
.text$mn:0000AFAC                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text$mn:0000AFAC
.text$mn:0000AFAC ; =============== S U B R O U T I N E =======================================
.text$mn:0000AFAC
.text$mn:0000AFAC ; Attributes: bp-based frame
.text$mn:0000AFAC
.text$mn:0000AFAC ; int __stdcall std::basic_string<char,std::char_traits<char>,std::allocator<char>>::assign(char *Str)
.text$mn:0000AFAC                 public ?assign@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV12@PBD@Z
.text$mn:0000AFAC ?assign@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV12@PBD@Z proc near
.text$mn:0000AFAC                                         ; CODE XREF: std::basic_string<char,std::char_traits<char>,std::allocator<char>>::basic_string<char,std::char_traits<char>,std::allocator<char>>(char const *)+53p
.text$mn:0000AFAC
.text$mn:0000AFAC var_4           = dword ptr -4
.text$mn:0000AFAC Str             = dword ptr  8
.text$mn:0000AFAC
.text$mn:0000AFAC                 push    ebp
.text$mn:0000AFAD                 mov     ebp, esp
.text$mn:0000AFAF                 push    ecx
.text$mn:0000AFB0                 mov     [ebp+var_4], ecx
.text$mn:0000AFB3                 push    490h            ; unsigned int
.text$mn:0000AFB8                 push    offset ??_C@_1IO@FEAPGJBD@?$AAC?$AA?3?$AA?2?$AAP?$AAr?$AAo?$AAg?$AAr?$AAa?$AAm?$AA?5?$AAF?$AAi?$AAl?$AAe?$AAs?$AA?5?$AA?$CI?$AAx?$AA8?$AA6?$AA?$CJ?$AA?2?$AAM?$AAi?$AAc?$AAr?$AAo?$AAs?$AAo?$AAf?$AAt@ ; "C:\\Program Files (x86)\\Microsoft Visu"...
.text$mn:0000AFBD                 mov     eax, [ebp+Str]
.text$mn:0000AFC0                 push    eax             ; int
.text$mn:0000AFC1                 call    ??$_Debug_pointer@D@std@@YAXPBDPB_WI@Z ; std::_Debug_pointer<char>(char const *,wchar_t const *,uint)
.text$mn:0000AFC6                 add     esp, 0Ch
.text$mn:0000AFC9                 mov     ecx, [ebp+Str]
.text$mn:0000AFCC                 push    ecx             ; Str
.text$mn:0000AFCD                 call    ?length@?$char_traits@D@std@@SAIPBD@Z ; std::char_traits<char>::length(char const *)
.text$mn:0000AFD2                 add     esp, 4
.text$mn:0000AFD5                 push    eax             ; Size
.text$mn:0000AFD6                 mov     edx, [ebp+Str]
.text$mn:0000AFD9                 push    edx             ; Src
.text$mn:0000AFDA                 mov     ecx, [ebp+var_4]
.text$mn:0000AFDD                 call    ?assign@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV12@PBDI@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char>>::assign(char const *,uint)
.text$mn:0000AFE2                 mov     esp, ebp
.text$mn:0000AFE4                 pop     ebp
.text$mn:0000AFE5                 retn    4
.text$mn:0000AFE5 ?assign@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV12@PBD@Z endp
.text$mn:0000AFE5
.text$mn:0000AFE5 _text$mn        ends
.text$mn:0000AFE5
.text$mn:0000AFE8 ; ===========================================================================
.text$mn:0000AFE8
.text$mn:0000AFE8 ; Segment type: Pure code
.text$mn:0000AFE8 ; Segment permissions: Read/Execute
.text$mn:0000AFE8 _text$mn        segment para public 'CODE' use32
.text$mn:0000AFE8                 assume cs:_text$mn
.text$mn:0000AFE8                 ;org 0AFE8h
.text$mn:0000AFE8 ; COMDAT (pick any)
.text$mn:0000AFE8                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text$mn:0000AFE8
.text$mn:0000AFE8 ; =============== S U B R O U T I N E =======================================
.text$mn:0000AFE8
.text$mn:0000AFE8 ; Attributes: bp-based frame
.text$mn:0000AFE8
.text$mn:0000AFE8 ; int __stdcall std::basic_string<char,std::char_traits<char>,std::allocator<char>>::assign(void *Src, size_t Size)
.text$mn:0000AFE8                 public ?assign@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV12@PBDI@Z
.text$mn:0000AFE8 ?assign@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV12@PBDI@Z proc near
.text$mn:0000AFE8                                         ; CODE XREF: std::basic_string<char,std::char_traits<char>,std::allocator<char>>::assign(char const *)+31p
.text$mn:0000AFE8
.text$mn:0000AFE8 var_4           = dword ptr -4
.text$mn:0000AFE8 Src             = dword ptr  8
.text$mn:0000AFE8 Size            = dword ptr  0Ch
.text$mn:0000AFE8
.text$mn:0000AFE8                 push    ebp
.text$mn:0000AFE9                 mov     ebp, esp
.text$mn:0000AFEB                 push    ecx
.text$mn:0000AFEC                 mov     [ebp+var_4], ecx
.text$mn:0000AFEF                 cmp     [ebp+Size], 0
.text$mn:0000AFF3                 jz      short loc_B00B
.text$mn:0000AFF5                 push    47Fh            ; unsigned int
.text$mn:0000AFFA                 push    offset ??_C@_1IO@FEAPGJBD@?$AAC?$AA?3?$AA?2?$AAP?$AAr?$AAo?$AAg?$AAr?$AAa?$AAm?$AA?5?$AAF?$AAi?$AAl?$AAe?$AAs?$AA?5?$AA?$CI?$AAx?$AA8?$AA6?$AA?$CJ?$AA?2?$AAM?$AAi?$AAc?$AAr?$AAo?$AAs?$AAo?$AAf?$AAt@ ; "C:\\Program Files (x86)\\Microsoft Visu"...
.text$mn:0000AFFF                 mov     eax, [ebp+Src]
.text$mn:0000B002                 push    eax             ; int
.text$mn:0000B003                 call    ??$_Debug_pointer@D@std@@YAXPBDPB_WI@Z ; std::_Debug_pointer<char>(char const *,wchar_t const *,uint)
.text$mn:0000B008                 add     esp, 0Ch
.text$mn:0000B00B
.text$mn:0000B00B loc_B00B:                               ; CODE XREF: std::basic_string<char,std::char_traits<char>,std::allocator<char>>::assign(char const *,uint)+Bj
.text$mn:0000B00B                 mov     ecx, [ebp+Src]
.text$mn:0000B00E                 push    ecx
.text$mn:0000B00F                 mov     ecx, [ebp+var_4]
.text$mn:0000B012                 call    ?_Inside@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE_NPBD@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char>>::_Inside(char const *)
.text$mn:0000B017                 movzx   edx, al
.text$mn:0000B01A                 test    edx, edx
.text$mn:0000B01C                 jz      short loc_B03E
.text$mn:0000B01E                 mov     eax, [ebp+Size]
.text$mn:0000B021                 push    eax
.text$mn:0000B022                 mov     ecx, [ebp+var_4]
.text$mn:0000B025                 call    ?_Myptr@?$_String_val@U?$_Simple_types@D@std@@@std@@QAEPADXZ ; std::_String_val<std::_Simple_types<char>>::_Myptr(void)
.text$mn:0000B02A                 mov     ecx, [ebp+Src]
.text$mn:0000B02D                 sub     ecx, eax
.text$mn:0000B02F                 push    ecx
.text$mn:0000B030                 mov     edx, [ebp+var_4]
.text$mn:0000B033                 push    edx
.text$mn:0000B034                 mov     ecx, [ebp+var_4]
.text$mn:0000B037                 call    ?assign@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV12@ABV12@II@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char>>::assign(std::basic_string<char,std::char_traits<char>,std::allocator<char>> const &,uint,uint)
.text$mn:0000B03C                 jmp     short loc_B07B
.text$mn:0000B03E ; ---------------------------------------------------------------------------
.text$mn:0000B03E
.text$mn:0000B03E loc_B03E:                               ; CODE XREF: std::basic_string<char,std::char_traits<char>,std::allocator<char>>::assign(char const *,uint)+34j
.text$mn:0000B03E                 push    0
.text$mn:0000B040                 mov     eax, [ebp+Size]
.text$mn:0000B043                 push    eax
.text$mn:0000B044                 mov     ecx, [ebp+var_4]
.text$mn:0000B047                 call    ?_Grow@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE_NI_N@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char>>::_Grow(uint,bool)
.text$mn:0000B04C                 movzx   ecx, al
.text$mn:0000B04F                 test    ecx, ecx
.text$mn:0000B051                 jz      short loc_B078
.text$mn:0000B053                 mov     edx, [ebp+Size]
.text$mn:0000B056                 push    edx             ; Size
.text$mn:0000B057                 mov     eax, [ebp+Src]
.text$mn:0000B05A                 push    eax             ; Src
.text$mn:0000B05B                 mov     ecx, [ebp+var_4]
.text$mn:0000B05E                 call    ?_Myptr@?$_String_val@U?$_Simple_types@D@std@@@std@@QAEPADXZ ; std::_String_val<std::_Simple_types<char>>::_Myptr(void)
.text$mn:0000B063                 push    eax             ; Dst
.text$mn:0000B064                 call    ?copy@?$char_traits@D@std@@SAPADPADPBDI@Z ; std::char_traits<char>::copy(char *,char const *,uint)
.text$mn:0000B069                 add     esp, 0Ch
.text$mn:0000B06C                 mov     ecx, [ebp+Size]
.text$mn:0000B06F                 push    ecx
.text$mn:0000B070                 mov     ecx, [ebp+var_4]
.text$mn:0000B073                 call    ?_Eos@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEXI@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char>>::_Eos(uint)
.text$mn:0000B078
.text$mn:0000B078 loc_B078:                               ; CODE XREF: std::basic_string<char,std::char_traits<char>,std::allocator<char>>::assign(char const *,uint)+69j
.text$mn:0000B078                 mov     eax, [ebp+var_4]
.text$mn:0000B07B
.text$mn:0000B07B loc_B07B:                               ; CODE XREF: std::basic_string<char,std::char_traits<char>,std::allocator<char>>::assign(char const *,uint)+54j
.text$mn:0000B07B                 mov     esp, ebp
.text$mn:0000B07D                 pop     ebp
.text$mn:0000B07E                 retn    8
.text$mn:0000B07E ?assign@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV12@PBDI@Z endp
.text$mn:0000B07E
.text$mn:0000B07E ; ---------------------------------------------------------------------------
.text$mn:0000B081                 align 4
.text$mn:0000B081 _text$mn        ends
.text$mn:0000B081
.text$mn:0000B084 ; ===========================================================================
.text$mn:0000B084
.text$mn:0000B084 ; Segment type: Pure code
.text$mn:0000B084 ; Segment permissions: Read/Execute
.text$mn:0000B084 _text$mn        segment para public 'CODE' use32
.text$mn:0000B084                 assume cs:_text$mn
.text$mn:0000B084                 ;org 0B084h
.text$mn:0000B084 ; COMDAT (pick any)
.text$mn:0000B084                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text$mn:0000B084
.text$mn:0000B084 ; =============== S U B R O U T I N E =======================================
.text$mn:0000B084
.text$mn:0000B084 ; Attributes: bp-based frame
.text$mn:0000B084
.text$mn:0000B084 ; public: class std::basic_string<wchar_t, struct std::char_traits<wchar_t>, class std::allocator<wchar_t>> & __thiscall std::basic_string<wchar_t, struct std::char_traits<wchar_t>, class std::allocator<wchar_t>>::assign(class std::basic_string<wchar_t, struct std::char_traits<wchar_t>, class std::allocator<wchar_t>> const &)
.text$mn:0000B084                 public ?assign@?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QAEAAV12@ABV12@@Z
.text$mn:0000B084 ?assign@?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QAEAAV12@ABV12@@Z proc near
.text$mn:0000B084                                         ; CODE XREF: std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>>::operator=(std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>> const &)+66p
.text$mn:0000B084
.text$mn:0000B084 var_4           = dword ptr -4
.text$mn:0000B084 arg_0           = dword ptr  8
.text$mn:0000B084
.text$mn:0000B084                 push    ebp
.text$mn:0000B085                 mov     ebp, esp
.text$mn:0000B087                 push    ecx
.text$mn:0000B088                 mov     [ebp+var_4], ecx
.text$mn:0000B08B                 mov     eax, ds:?npos@?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@2IB ; uint const std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>>::npos
.text$mn:0000B090                 push    eax
.text$mn:0000B091                 push    0
.text$mn:0000B093                 mov     ecx, [ebp+arg_0]
.text$mn:0000B096                 push    ecx
.text$mn:0000B097                 mov     ecx, [ebp+var_4]
.text$mn:0000B09A                 call    ?assign@?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QAEAAV12@ABV12@II@Z ; std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>>::assign(std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>> const &,uint,uint)
.text$mn:0000B09F                 mov     esp, ebp
.text$mn:0000B0A1                 pop     ebp
.text$mn:0000B0A2                 retn    4
.text$mn:0000B0A2 ?assign@?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QAEAAV12@ABV12@@Z endp
.text$mn:0000B0A2
.text$mn:0000B0A2 ; ---------------------------------------------------------------------------
.text$mn:0000B0A5                 align 4
.text$mn:0000B0A5 _text$mn        ends
.text$mn:0000B0A5
.text$mn:0000B0A8 ; ===========================================================================
.text$mn:0000B0A8
.text$mn:0000B0A8 ; Segment type: Pure code
.text$mn:0000B0A8 ; Segment permissions: Read/Execute
.text$mn:0000B0A8 _text$mn        segment para public 'CODE' use32
.text$mn:0000B0A8                 assume cs:_text$mn
.text$mn:0000B0A8                 ;org 0B0A8h
.text$mn:0000B0A8 ; COMDAT (pick any)
.text$mn:0000B0A8                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text$mn:0000B0A8
.text$mn:0000B0A8 ; =============== S U B R O U T I N E =======================================
.text$mn:0000B0A8
.text$mn:0000B0A8 ; Attributes: bp-based frame
.text$mn:0000B0A8
.text$mn:0000B0A8 ; public: class std::basic_string<wchar_t, struct std::char_traits<wchar_t>, class std::allocator<wchar_t>> & __thiscall std::basic_string<wchar_t, struct std::char_traits<wchar_t>, class std::allocator<wchar_t>>::assign(class std::basic_string<wchar_t, struct std::char_traits<wchar_t>, class std::allocator<wchar_t>> const &, unsigned int, unsigned int)
.text$mn:0000B0A8                 public ?assign@?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QAEAAV12@ABV12@II@Z
.text$mn:0000B0A8 ?assign@?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QAEAAV12@ABV12@II@Z proc near
.text$mn:0000B0A8                                         ; CODE XREF: std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>>::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>>(std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>> const &)+6Bp
.text$mn:0000B0A8                                         ; std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>>::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>>(std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>> const &,uint,uint,std::allocator<wchar_t> const &)+54p ...
.text$mn:0000B0A8
.text$mn:0000B0A8 var_8           = dword ptr -8
.text$mn:0000B0A8 var_4           = dword ptr -4
.text$mn:0000B0A8 arg_0           = dword ptr  8
.text$mn:0000B0A8 arg_4           = dword ptr  0Ch
.text$mn:0000B0A8 arg_8           = dword ptr  10h
.text$mn:0000B0A8
.text$mn:0000B0A8                 push    ebp
.text$mn:0000B0A9                 mov     ebp, esp
.text$mn:0000B0AB                 sub     esp, 8
.text$mn:0000B0AE                 mov     [ebp+var_4], ecx
.text$mn:0000B0B1                 mov     ecx, [ebp+arg_0]
.text$mn:0000B0B4                 call    ?size@?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QBEIXZ ; std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>>::size(void)
.text$mn:0000B0B9                 cmp     eax, [ebp+arg_4]
.text$mn:0000B0BC                 jnb     short loc_B0C6
.text$mn:0000B0BE                 mov     ecx, [ebp+var_4]
.text$mn:0000B0C1                 call    ?_Xran@?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QBEXXZ ; std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>>::_Xran(void)
.text$mn:0000B0C6
.text$mn:0000B0C6 loc_B0C6:                               ; CODE XREF: std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>>::assign(std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>> const &,uint,uint)+14j
.text$mn:0000B0C6                 mov     ecx, [ebp+arg_0]
.text$mn:0000B0C9                 call    ?size@?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QBEIXZ ; std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>>::size(void)
.text$mn:0000B0CE                 sub     eax, [ebp+arg_4]
.text$mn:0000B0D1                 mov     [ebp+var_8], eax
.text$mn:0000B0D4                 mov     eax, [ebp+arg_8]
.text$mn:0000B0D7                 cmp     eax, [ebp+var_8]
.text$mn:0000B0DA                 jnb     short loc_B0E2
.text$mn:0000B0DC                 mov     ecx, [ebp+arg_8]
.text$mn:0000B0DF                 mov     [ebp+var_8], ecx
.text$mn:0000B0E2
.text$mn:0000B0E2 loc_B0E2:                               ; CODE XREF: std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>>::assign(std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>> const &,uint,uint)+32j
.text$mn:0000B0E2                 mov     edx, [ebp+var_4]
.text$mn:0000B0E5                 cmp     edx, [ebp+arg_0]
.text$mn:0000B0E8                 jnz     short loc_B109
.text$mn:0000B0EA                 mov     eax, [ebp+arg_4]
.text$mn:0000B0ED                 add     eax, [ebp+var_8]
.text$mn:0000B0F0                 push    eax
.text$mn:0000B0F1                 mov     ecx, [ebp+var_4]
.text$mn:0000B0F4                 call    ?erase@?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QAEAAV12@I@Z ; std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>>::erase(uint)
.text$mn:0000B0F9                 mov     ecx, [ebp+arg_4]
.text$mn:0000B0FC                 push    ecx
.text$mn:0000B0FD                 push    0
.text$mn:0000B0FF                 mov     ecx, [ebp+var_4]
.text$mn:0000B102                 call    ?erase@?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QAEAAV12@II@Z ; std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>>::erase(uint,uint)
.text$mn:0000B107                 jmp     short loc_B14E
.text$mn:0000B109 ; ---------------------------------------------------------------------------
.text$mn:0000B109
.text$mn:0000B109 loc_B109:                               ; CODE XREF: std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>>::assign(std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>> const &,uint,uint)+40j
.text$mn:0000B109                 push    0
.text$mn:0000B10B                 mov     edx, [ebp+var_8]
.text$mn:0000B10E                 push    edx
.text$mn:0000B10F                 mov     ecx, [ebp+var_4]
.text$mn:0000B112                 call    ?_Grow@?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QAE_NI_N@Z ; std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>>::_Grow(uint,bool)
.text$mn:0000B117                 movzx   eax, al
.text$mn:0000B11A                 test    eax, eax
.text$mn:0000B11C                 jz      short loc_B14E
.text$mn:0000B11E                 mov     ecx, [ebp+var_8]
.text$mn:0000B121                 push    ecx             ; int
.text$mn:0000B122                 mov     ecx, [ebp+arg_0]
.text$mn:0000B125                 call    ?_Myptr@?$_String_val@U?$_Simple_types@_W@std@@@std@@QBEPB_WXZ ; std::_String_val<std::_Simple_types<wchar_t>>::_Myptr(void)
.text$mn:0000B12A                 mov     edx, [ebp+arg_4]
.text$mn:0000B12D                 lea     eax, [eax+edx*2]
.text$mn:0000B130                 push    eax             ; Src
.text$mn:0000B131                 mov     ecx, [ebp+var_4]
.text$mn:0000B134                 call    ?_Myptr@?$_String_val@U?$_Simple_types@_W@std@@@std@@QAEPA_WXZ ; std::_String_val<std::_Simple_types<wchar_t>>::_Myptr(void)
.text$mn:0000B139                 push    eax             ; Dst
.text$mn:0000B13A                 call    ?copy@?$char_traits@_W@std@@SAPA_WPA_WPB_WI@Z ; std::char_traits<wchar_t>::copy(wchar_t *,wchar_t const *,uint)
.text$mn:0000B13F                 add     esp, 0Ch
.text$mn:0000B142                 mov     ecx, [ebp+var_8]
.text$mn:0000B145                 push    ecx
.text$mn:0000B146                 mov     ecx, [ebp+var_4]
.text$mn:0000B149                 call    ?_Eos@?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QAEXI@Z ; std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>>::_Eos(uint)
.text$mn:0000B14E
.text$mn:0000B14E loc_B14E:                               ; CODE XREF: std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>>::assign(std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>> const &,uint,uint)+5Fj
.text$mn:0000B14E                                         ; std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>>::assign(std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>> const &,uint,uint)+74j
.text$mn:0000B14E                 mov     eax, [ebp+var_4]
.text$mn:0000B151                 mov     esp, ebp
.text$mn:0000B153                 pop     ebp
.text$mn:0000B154                 retn    0Ch
.text$mn:0000B154 ?assign@?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QAEAAV12@ABV12@II@Z endp
.text$mn:0000B154
.text$mn:0000B154 ; ---------------------------------------------------------------------------
.text$mn:0000B157                 align 4
.text$mn:0000B157 _text$mn        ends
.text$mn:0000B157
.text$mn:0000B158 ; ===========================================================================
.text$mn:0000B158
.text$mn:0000B158 ; Segment type: Pure code
.text$mn:0000B158 ; Segment permissions: Read/Execute
.text$mn:0000B158 _text$mn        segment para public 'CODE' use32
.text$mn:0000B158                 assume cs:_text$mn
.text$mn:0000B158                 ;org 0B158h
.text$mn:0000B158 ; COMDAT (pick any)
.text$mn:0000B158                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text$mn:0000B158
.text$mn:0000B158 ; =============== S U B R O U T I N E =======================================
.text$mn:0000B158
.text$mn:0000B158 ; Attributes: bp-based frame
.text$mn:0000B158
.text$mn:0000B158 ; int __stdcall std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>>::assign(wchar_t *Str)
.text$mn:0000B158                 public ?assign@?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QAEAAV12@PB_W@Z
.text$mn:0000B158 ?assign@?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QAEAAV12@PB_W@Z proc near
.text$mn:0000B158                                         ; CODE XREF: std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>>::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>>(wchar_t const *)+53p
.text$mn:0000B158                                         ; std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>>::operator=(wchar_t const *)+Ep
.text$mn:0000B158
.text$mn:0000B158 var_4           = dword ptr -4
.text$mn:0000B158 Str             = dword ptr  8
.text$mn:0000B158
.text$mn:0000B158                 push    ebp
.text$mn:0000B159                 mov     ebp, esp
.text$mn:0000B15B                 push    ecx
.text$mn:0000B15C                 mov     [ebp+var_4], ecx
.text$mn:0000B15F                 push    490h            ; unsigned int
.text$mn:0000B164                 push    offset ??_C@_1IO@FEAPGJBD@?$AAC?$AA?3?$AA?2?$AAP?$AAr?$AAo?$AAg?$AAr?$AAa?$AAm?$AA?5?$AAF?$AAi?$AAl?$AAe?$AAs?$AA?5?$AA?$CI?$AAx?$AA8?$AA6?$AA?$CJ?$AA?2?$AAM?$AAi?$AAc?$AAr?$AAo?$AAs?$AAo?$AAf?$AAt@ ; "C:\\Program Files (x86)\\Microsoft Visu"...
.text$mn:0000B169                 mov     eax, [ebp+Str]
.text$mn:0000B16C                 push    eax             ; int
.text$mn:0000B16D                 call    ??$_Debug_pointer@_W@std@@YAXPB_W0I@Z ; std::_Debug_pointer<wchar_t>(wchar_t const *,wchar_t const *,uint)
.text$mn:0000B172                 add     esp, 0Ch
.text$mn:0000B175                 mov     ecx, [ebp+Str]
.text$mn:0000B178                 push    ecx             ; Str
.text$mn:0000B179                 call    ?length@?$char_traits@_W@std@@SAIPB_W@Z ; std::char_traits<wchar_t>::length(wchar_t const *)
.text$mn:0000B17E                 add     esp, 4
.text$mn:0000B181                 push    eax             ; int
.text$mn:0000B182                 mov     edx, [ebp+Str]
.text$mn:0000B185                 push    edx             ; Src
.text$mn:0000B186                 mov     ecx, [ebp+var_4]
.text$mn:0000B189                 call    ?assign@?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QAEAAV12@PB_WI@Z ; std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>>::assign(wchar_t const *,uint)
.text$mn:0000B18E                 mov     esp, ebp
.text$mn:0000B190                 pop     ebp
.text$mn:0000B191                 retn    4
.text$mn:0000B191 ?assign@?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QAEAAV12@PB_W@Z endp
.text$mn:0000B191
.text$mn:0000B191 _text$mn        ends
.text$mn:0000B191
.text$mn:0000B194 ; ===========================================================================
.text$mn:0000B194
.text$mn:0000B194 ; Segment type: Pure code
.text$mn:0000B194 ; Segment permissions: Read/Execute
.text$mn:0000B194 _text$mn        segment para public 'CODE' use32
.text$mn:0000B194                 assume cs:_text$mn
.text$mn:0000B194                 ;org 0B194h
.text$mn:0000B194 ; COMDAT (pick any)
.text$mn:0000B194                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text$mn:0000B194
.text$mn:0000B194 ; =============== S U B R O U T I N E =======================================
.text$mn:0000B194
.text$mn:0000B194 ; Attributes: bp-based frame
.text$mn:0000B194
.text$mn:0000B194 ; int __stdcall std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>>::assign(void *Src, int)
.text$mn:0000B194                 public ?assign@?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QAEAAV12@PB_WI@Z
.text$mn:0000B194 ?assign@?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QAEAAV12@PB_WI@Z proc near
.text$mn:0000B194                                         ; CODE XREF: std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>>::assign(wchar_t const *)+31p
.text$mn:0000B194
.text$mn:0000B194 var_4           = dword ptr -4
.text$mn:0000B194 Src             = dword ptr  8
.text$mn:0000B194 arg_4           = dword ptr  0Ch
.text$mn:0000B194
.text$mn:0000B194                 push    ebp
.text$mn:0000B195                 mov     ebp, esp
.text$mn:0000B197                 push    ecx
.text$mn:0000B198                 mov     [ebp+var_4], ecx
.text$mn:0000B19B                 cmp     [ebp+arg_4], 0
.text$mn:0000B19F                 jz      short loc_B1B7
.text$mn:0000B1A1                 push    47Fh            ; unsigned int
.text$mn:0000B1A6                 push    offset ??_C@_1IO@FEAPGJBD@?$AAC?$AA?3?$AA?2?$AAP?$AAr?$AAo?$AAg?$AAr?$AAa?$AAm?$AA?5?$AAF?$AAi?$AAl?$AAe?$AAs?$AA?5?$AA?$CI?$AAx?$AA8?$AA6?$AA?$CJ?$AA?2?$AAM?$AAi?$AAc?$AAr?$AAo?$AAs?$AAo?$AAf?$AAt@ ; "C:\\Program Files (x86)\\Microsoft Visu"...
.text$mn:0000B1AB                 mov     eax, [ebp+Src]
.text$mn:0000B1AE                 push    eax             ; int
.text$mn:0000B1AF                 call    ??$_Debug_pointer@_W@std@@YAXPB_W0I@Z ; std::_Debug_pointer<wchar_t>(wchar_t const *,wchar_t const *,uint)
.text$mn:0000B1B4                 add     esp, 0Ch
.text$mn:0000B1B7
.text$mn:0000B1B7 loc_B1B7:                               ; CODE XREF: std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>>::assign(wchar_t const *,uint)+Bj
.text$mn:0000B1B7                 mov     ecx, [ebp+Src]
.text$mn:0000B1BA                 push    ecx
.text$mn:0000B1BB                 mov     ecx, [ebp+var_4]
.text$mn:0000B1BE                 call    ?_Inside@?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QAE_NPB_W@Z ; std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>>::_Inside(wchar_t const *)
.text$mn:0000B1C3                 movzx   edx, al
.text$mn:0000B1C6                 test    edx, edx
.text$mn:0000B1C8                 jz      short loc_B1EC
.text$mn:0000B1CA                 mov     eax, [ebp+arg_4]
.text$mn:0000B1CD                 push    eax
.text$mn:0000B1CE                 mov     ecx, [ebp+var_4]
.text$mn:0000B1D1                 call    ?_Myptr@?$_String_val@U?$_Simple_types@_W@std@@@std@@QAEPA_WXZ ; std::_String_val<std::_Simple_types<wchar_t>>::_Myptr(void)
.text$mn:0000B1D6                 mov     ecx, [ebp+Src]
.text$mn:0000B1D9                 sub     ecx, eax
.text$mn:0000B1DB                 sar     ecx, 1
.text$mn:0000B1DD                 push    ecx
.text$mn:0000B1DE                 mov     edx, [ebp+var_4]
.text$mn:0000B1E1                 push    edx
.text$mn:0000B1E2                 mov     ecx, [ebp+var_4]
.text$mn:0000B1E5                 call    ?assign@?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QAEAAV12@ABV12@II@Z ; std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>>::assign(std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>> const &,uint,uint)
.text$mn:0000B1EA                 jmp     short loc_B229
.text$mn:0000B1EC ; ---------------------------------------------------------------------------
.text$mn:0000B1EC
.text$mn:0000B1EC loc_B1EC:                               ; CODE XREF: std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>>::assign(wchar_t const *,uint)+34j
.text$mn:0000B1EC                 push    0
.text$mn:0000B1EE                 mov     eax, [ebp+arg_4]
.text$mn:0000B1F1                 push    eax
.text$mn:0000B1F2                 mov     ecx, [ebp+var_4]
.text$mn:0000B1F5                 call    ?_Grow@?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QAE_NI_N@Z ; std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>>::_Grow(uint,bool)
.text$mn:0000B1FA                 movzx   ecx, al
.text$mn:0000B1FD                 test    ecx, ecx
.text$mn:0000B1FF                 jz      short loc_B226
.text$mn:0000B201                 mov     edx, [ebp+arg_4]
.text$mn:0000B204                 push    edx             ; int
.text$mn:0000B205                 mov     eax, [ebp+Src]
.text$mn:0000B208                 push    eax             ; Src
.text$mn:0000B209                 mov     ecx, [ebp+var_4]
.text$mn:0000B20C                 call    ?_Myptr@?$_String_val@U?$_Simple_types@_W@std@@@std@@QAEPA_WXZ ; std::_String_val<std::_Simple_types<wchar_t>>::_Myptr(void)
.text$mn:0000B211                 push    eax             ; Dst
.text$mn:0000B212                 call    ?copy@?$char_traits@_W@std@@SAPA_WPA_WPB_WI@Z ; std::char_traits<wchar_t>::copy(wchar_t *,wchar_t const *,uint)
.text$mn:0000B217                 add     esp, 0Ch
.text$mn:0000B21A                 mov     ecx, [ebp+arg_4]
.text$mn:0000B21D                 push    ecx
.text$mn:0000B21E                 mov     ecx, [ebp+var_4]
.text$mn:0000B221                 call    ?_Eos@?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QAEXI@Z ; std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>>::_Eos(uint)
.text$mn:0000B226
.text$mn:0000B226 loc_B226:                               ; CODE XREF: std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>>::assign(wchar_t const *,uint)+6Bj
.text$mn:0000B226                 mov     eax, [ebp+var_4]
.text$mn:0000B229
.text$mn:0000B229 loc_B229:                               ; CODE XREF: std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>>::assign(wchar_t const *,uint)+56j
.text$mn:0000B229                 mov     esp, ebp
.text$mn:0000B22B                 pop     ebp
.text$mn:0000B22C                 retn    8
.text$mn:0000B22C ?assign@?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QAEAAV12@PB_WI@Z endp
.text$mn:0000B22C
.text$mn:0000B22C ; ---------------------------------------------------------------------------
.text$mn:0000B22F                 align 10h
.text$mn:0000B22F _text$mn        ends
.text$mn:0000B22F
.text$mn:0000B230 ; ===========================================================================
.text$mn:0000B230
.text$mn:0000B230 ; Segment type: Pure code
.text$mn:0000B230 ; Segment permissions: Read/Execute
.text$mn:0000B230 _text$mn        segment para public 'CODE' use32
.text$mn:0000B230                 assume cs:_text$mn
.text$mn:0000B230                 ;org 0B230h
.text$mn:0000B230 ; COMDAT (pick any)
.text$mn:0000B230                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text$mn:0000B230
.text$mn:0000B230 ; =============== S U B R O U T I N E =======================================
.text$mn:0000B230
.text$mn:0000B230 ; Attributes: bp-based frame
.text$mn:0000B230
.text$mn:0000B230 ; public: static void __cdecl std::char_traits<char>::assign(char &, char const &)
.text$mn:0000B230                 public ?assign@?$char_traits@D@std@@SAXAADABD@Z
.text$mn:0000B230 ?assign@?$char_traits@D@std@@SAXAADABD@Z proc near
.text$mn:0000B230                                         ; CODE XREF: std::basic_string<char,std::char_traits<char>,std::allocator<char>>::_Eos(uint)+26p
.text$mn:0000B230
.text$mn:0000B230 arg_0           = dword ptr  8
.text$mn:0000B230 arg_4           = dword ptr  0Ch
.text$mn:0000B230
.text$mn:0000B230                 push    ebp
.text$mn:0000B231                 mov     ebp, esp
.text$mn:0000B233                 mov     eax, [ebp+arg_0]
.text$mn:0000B236                 mov     ecx, [ebp+arg_4]
.text$mn:0000B239                 mov     dl, [ecx]
.text$mn:0000B23B                 mov     [eax], dl
.text$mn:0000B23D                 pop     ebp
.text$mn:0000B23E                 retn
.text$mn:0000B23E ?assign@?$char_traits@D@std@@SAXAADABD@Z endp
.text$mn:0000B23E
.text$mn:0000B23E ; ---------------------------------------------------------------------------
.text$mn:0000B23F                 align 10h
.text$mn:0000B23F _text$mn        ends
.text$mn:0000B23F
.text$mn:0000B240 ; ===========================================================================
.text$mn:0000B240
.text$mn:0000B240 ; Segment type: Pure code
.text$mn:0000B240 ; Segment permissions: Read/Execute
.text$mn:0000B240 _text$mn        segment para public 'CODE' use32
.text$mn:0000B240                 assume cs:_text$mn
.text$mn:0000B240                 ;org 0B240h
.text$mn:0000B240 ; COMDAT (pick any)
.text$mn:0000B240                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text$mn:0000B240
.text$mn:0000B240 ; =============== S U B R O U T I N E =======================================
.text$mn:0000B240
.text$mn:0000B240 ; Attributes: bp-based frame
.text$mn:0000B240
.text$mn:0000B240 ; public: static wchar_t * __cdecl std::char_traits<wchar_t>::assign(wchar_t *, unsigned int, wchar_t)
.text$mn:0000B240                 public ?assign@?$char_traits@_W@std@@SAPA_WPA_WI_W@Z
.text$mn:0000B240 ?assign@?$char_traits@_W@std@@SAPA_WPA_WI_W@Z proc near
.text$mn:0000B240                                         ; CODE XREF: std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>>::_Chassign(uint,uint,wchar_t)+42p
.text$mn:0000B240
.text$mn:0000B240 arg_0           = dword ptr  8
.text$mn:0000B240 arg_4           = dword ptr  0Ch
.text$mn:0000B240 arg_8           = word ptr  10h
.text$mn:0000B240
.text$mn:0000B240                 push    ebp
.text$mn:0000B241                 mov     ebp, esp
.text$mn:0000B243                 mov     eax, [ebp+arg_4]
.text$mn:0000B246                 push    eax
.text$mn:0000B247                 movzx   ecx, [ebp+arg_8]
.text$mn:0000B24B                 push    ecx
.text$mn:0000B24C                 mov     edx, [ebp+arg_0]
.text$mn:0000B24F                 push    edx
.text$mn:0000B250                 call    _wmemset
.text$mn:0000B255                 add     esp, 0Ch
.text$mn:0000B258                 pop     ebp
.text$mn:0000B259                 retn
.text$mn:0000B259 ?assign@?$char_traits@_W@std@@SAPA_WPA_WI_W@Z endp
.text$mn:0000B259
.text$mn:0000B259 ; ---------------------------------------------------------------------------
.text$mn:0000B25A                 align 4
.text$mn:0000B25A _text$mn        ends
.text$mn:0000B25A
.text$mn:0000B25C ; ===========================================================================
.text$mn:0000B25C
.text$mn:0000B25C ; Segment type: Pure code
.text$mn:0000B25C ; Segment permissions: Read/Execute
.text$mn:0000B25C _text$mn        segment para public 'CODE' use32
.text$mn:0000B25C                 assume cs:_text$mn
.text$mn:0000B25C                 ;org 0B25Ch
.text$mn:0000B25C ; COMDAT (pick any)
.text$mn:0000B25C                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text$mn:0000B25C
.text$mn:0000B25C ; =============== S U B R O U T I N E =======================================
.text$mn:0000B25C
.text$mn:0000B25C ; Attributes: bp-based frame
.text$mn:0000B25C
.text$mn:0000B25C ; public: static void __cdecl std::char_traits<wchar_t>::assign(wchar_t &, wchar_t const &)
.text$mn:0000B25C                 public ?assign@?$char_traits@_W@std@@SAXAA_WAB_W@Z
.text$mn:0000B25C ?assign@?$char_traits@_W@std@@SAXAA_WAB_W@Z proc near
.text$mn:0000B25C                                         ; CODE XREF: std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>>::_Chassign(uint,uint,wchar_t)+20p
.text$mn:0000B25C                                         ; std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>>::_Eos(uint)+2Bp
.text$mn:0000B25C
.text$mn:0000B25C arg_0           = dword ptr  8
.text$mn:0000B25C arg_4           = dword ptr  0Ch
.text$mn:0000B25C
.text$mn:0000B25C                 push    ebp
.text$mn:0000B25D                 mov     ebp, esp
.text$mn:0000B25F                 mov     eax, [ebp+arg_0]
.text$mn:0000B262                 mov     ecx, [ebp+arg_4]
.text$mn:0000B265                 mov     dx, [ecx]
.text$mn:0000B268                 mov     [eax], dx
.text$mn:0000B26B                 pop     ebp
.text$mn:0000B26C                 retn
.text$mn:0000B26C ?assign@?$char_traits@_W@std@@SAXAA_WAB_W@Z endp
.text$mn:0000B26C
.text$mn:0000B26C ; ---------------------------------------------------------------------------
.text$mn:0000B26D                 align 10h
.text$mn:0000B26D _text$mn        ends
.text$mn:0000B26D
.text$mn:0000B270 ; ===========================================================================
.text$mn:0000B270
.text$mn:0000B270 ; Segment type: Pure code
.text$mn:0000B270 ; Segment permissions: Read/Execute
.text$mn:0000B270 _text$mn        segment para public 'CODE' use32
.text$mn:0000B270                 assume cs:_text$mn
.text$mn:0000B270                 ;org 0B270h
.text$mn:0000B270 ; COMDAT (pick any)
.text$mn:0000B270                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text$mn:0000B270
.text$mn:0000B270 ; =============== S U B R O U T I N E =======================================
.text$mn:0000B270
.text$mn:0000B270 ; Attributes: bp-based frame
.text$mn:0000B270
.text$mn:0000B270 ; public: class std::basic_string<wchar_t, struct std::char_traits<wchar_t>, class std::allocator<wchar_t>> const & __thiscall std::vector<class std::basic_string<wchar_t, struct std::char_traits<wchar_t>, class std::allocator<wchar_t>>, class std::allocator<class std::basic_string<wchar_t, struct std::char_traits<wchar_t>, class std::allocator<wchar_t>>>>::at(unsigned int)const
.text$mn:0000B270                 public ?at@?$vector@V?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@V?$allocator@V?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@@2@@std@@QBEABV?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@2@I@Z
.text$mn:0000B270 ?at@?$vector@V?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@V?$allocator@V?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@@2@@std@@QBEABV?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@2@I@Z proc near
.text$mn:0000B270                                         ; CODE XREF: stringJoin(std::vector<std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>>,std::allocator<std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>>>> const &,std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>> const &)+6Ap
.text$mn:0000B270
.text$mn:0000B270 var_4           = dword ptr -4
.text$mn:0000B270 arg_0           = dword ptr  8
.text$mn:0000B270
.text$mn:0000B270                 push    ebp
.text$mn:0000B271                 mov     ebp, esp
.text$mn:0000B273                 push    ecx
.text$mn:0000B274                 mov     [ebp+var_4], ecx
.text$mn:0000B277                 mov     ecx, [ebp+var_4]
.text$mn:0000B27A                 call    ?size@?$vector@V?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@V?$allocator@V?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@@2@@std@@QBEIXZ ; std::vector<std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>>,std::allocator<std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>>>>::size(void)
.text$mn:0000B27F                 cmp     eax, [ebp+arg_0]
.text$mn:0000B282                 ja      short loc_B28C
.text$mn:0000B284                 mov     ecx, [ebp+var_4]
.text$mn:0000B287                 call    ?_Xran@?$vector@V?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@V?$allocator@V?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@@2@@std@@IBEXXZ ; std::vector<std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>>,std::allocator<std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>>>>::_Xran(void)
.text$mn:0000B28C
.text$mn:0000B28C loc_B28C:                               ; CODE XREF: std::vector<std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>>,std::allocator<std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>>>>::at(uint)+12j
.text$mn:0000B28C                 imul    eax, [ebp+arg_0], 1Ch
.text$mn:0000B290                 mov     ecx, [ebp+var_4]
.text$mn:0000B293                 add     eax, [ecx+4]
.text$mn:0000B296                 mov     esp, ebp
.text$mn:0000B298                 pop     ebp
.text$mn:0000B299                 retn    4
.text$mn:0000B299 ?at@?$vector@V?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@V?$allocator@V?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@@2@@std@@QBEABV?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@2@I@Z endp
.text$mn:0000B299
.text$mn:0000B299 _text$mn        ends
.text$mn:0000B299
.text$mn:0000B29C ; ===========================================================================
.text$mn:0000B29C
.text$mn:0000B29C ; Segment type: Pure code
.text$mn:0000B29C ; Segment permissions: Read/Execute
.text$mn:0000B29C _text$mn        segment para public 'CODE' use32
.text$mn:0000B29C                 assume cs:_text$mn
.text$mn:0000B29C                 ;org 0B29Ch
.text$mn:0000B29C ; COMDAT (pick any)
.text$mn:0000B29C                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text$mn:0000B29C
.text$mn:0000B29C ; =============== S U B R O U T I N E =======================================
.text$mn:0000B29C
.text$mn:0000B29C ; Attributes: bp-based frame
.text$mn:0000B29C
.text$mn:0000B29C ; public: class std::_Vector_iterator<class std::_Vector_val<struct std::_Simple_types<wchar_t>>> __thiscall std::_Revranit<class std::_Vector_iterator<class std::_Vector_val<struct std::_Simple_types<wchar_t>>>, struct std::iterator<struct std::random_access_iterator_tag, wchar_t, int, wchar_t *, wchar_t &>>::base(void)const
.text$mn:0000B29C                 public ?base@?$_Revranit@V?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@_W@std@@@std@@@std@@U?$iterator@Urandom_access_iterator_tag@std@@_WHPA_WAA_W@2@@std@@QBE?AV?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@_W@std@@@std@@@2@XZ
.text$mn:0000B29C ?base@?$_Revranit@V?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@_W@std@@@std@@@std@@U?$iterator@Urandom_access_iterator_tag@std@@_WHPA_WAA_W@2@@std@@QBE?AV?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@_W@std@@@std@@@2@XZ proc near
.text$mn:0000B29C                                         ; CODE XREF: std::operator-<std::_Vector_iterator<std::_Vector_val<std::_Simple_types<wchar_t>>>,std::_Vector_iterator<std::_Vector_val<std::_Simple_types<wchar_t>>>>(std::reverse_iterator<std::_Vector_iterator<std::_Vector_val<std::_Simple_types<wchar_t>>>> const &,std::reverse_iterator<std::_Vector_iterator<std::_Vector_val<std::_Simple_types<wchar_t>>>> const &)+2Cp
.text$mn:0000B29C                                         ; std::operator-<std::_Vector_iterator<std::_Vector_val<std::_Simple_types<wchar_t>>>,std::_Vector_iterator<std::_Vector_val<std::_Simple_types<wchar_t>>>>(std::reverse_iterator<std::_Vector_iterator<std::_Vector_val<std::_Simple_types<wchar_t>>>> const &,std::reverse_iterator<std::_Vector_iterator<std::_Vector_val<std::_Simple_types<wchar_t>>>> const &)+4Cp ...
.text$mn:0000B29C
.text$mn:0000B29C var_14          = dword ptr -14h
.text$mn:0000B29C var_10          = dword ptr -10h
.text$mn:0000B29C var_C           = dword ptr -0Ch
.text$mn:0000B29C var_4           = dword ptr -4
.text$mn:0000B29C arg_0           = dword ptr  8
.text$mn:0000B29C
.text$mn:0000B29C                 push    ebp
.text$mn:0000B29D                 mov     ebp, esp
.text$mn:0000B29F                 push    0FFFFFFFFh
.text$mn:0000B2A1                 push    offset __ehhandler$?base@?$_Revranit@V?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@_W@std@@@std@@@std@@U?$iterator@Urandom_access_iterator_tag@std@@_WHPA_WAA_W@2@@std@@QBE?AV?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@_W@std@@@std@@@2@XZ
.text$mn:0000B2A6                 mov     eax, large fs:0
.text$mn:0000B2AC                 push    eax
.text$mn:0000B2AD                 sub     esp, 8
.text$mn:0000B2B0                 mov     eax, dword ptr ds:___security_cookie
.text$mn:0000B2B5                 xor     eax, ebp
.text$mn:0000B2B7                 push    eax
.text$mn:0000B2B8                 lea     eax, [ebp+var_C]
.text$mn:0000B2BB                 mov     large fs:0, eax
.text$mn:0000B2C1                 mov     [ebp+var_14], ecx
.text$mn:0000B2C4                 mov     [ebp+var_10], 0
.text$mn:0000B2CB                 mov     eax, [ebp+var_14]
.text$mn:0000B2CE                 push    eax             ; struct std::_Iterator_base12 *
.text$mn:0000B2CF                 mov     ecx, [ebp+arg_0]
.text$mn:0000B2D2                 call    ??0?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@_W@std@@@std@@@std@@QAE@ABV01@@Z ; std::_Vector_iterator<std::_Vector_val<std::_Simple_types<wchar_t>>>::_Vector_iterator<std::_Vector_val<std::_Simple_types<wchar_t>>>(std::_Vector_iterator<std::_Vector_val<std::_Simple_types<wchar_t>>> const &)
.text$mn:0000B2D7                 mov     [ebp+var_4], 0
.text$mn:0000B2DE                 mov     ecx, [ebp+var_10]
.text$mn:0000B2E1                 or      ecx, 1
.text$mn:0000B2E4                 mov     [ebp+var_10], ecx
.text$mn:0000B2E7                 mov     eax, [ebp+arg_0]
.text$mn:0000B2EA                 mov     ecx, [ebp+var_C]
.text$mn:0000B2ED                 mov     large fs:0, ecx
.text$mn:0000B2F4                 pop     ecx
.text$mn:0000B2F5                 mov     esp, ebp
.text$mn:0000B2F7                 pop     ebp
.text$mn:0000B2F8                 retn    4
.text$mn:0000B2F8 ?base@?$_Revranit@V?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@_W@std@@@std@@@std@@U?$iterator@Urandom_access_iterator_tag@std@@_WHPA_WAA_W@2@@std@@QBE?AV?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@_W@std@@@std@@@2@XZ endp
.text$mn:0000B2F8
.text$mn:0000B2F8 ; ---------------------------------------------------------------------------
.text$mn:0000B2FB                 align 4
.text$mn:0000B2FB _text$mn        ends
.text$mn:0000B2FB
.text$x:0000B2FC ; ===========================================================================
.text$x:0000B2FC
.text$x:0000B2FC ; Segment type: Pure code
.text$x:0000B2FC ; Segment permissions: Read/Execute
.text$x:0000B2FC _text$x         segment para public 'CODE' use32
.text$x:0000B2FC                 assume cs:_text$x
.text$x:0000B2FC                 ;org 0B2FCh
.text$x:0000B2FC ; COMDAT (pick associative to section at B29C)
.text$x:0000B2FC                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text$x:0000B2FC
.text$x:0000B2FC ; =============== S U B R O U T I N E =======================================
.text$x:0000B2FC
.text$x:0000B2FC
.text$x:0000B2FC __unwindfunclet$?base@?$_Revranit@V?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@_W@std@@@std@@@std@@U?$iterator@Urandom_access_iterator_tag@std@@_WHPA_WAA_W@2@@std@@QBE?AV?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@_W@std@@@std@@@2@XZ$0 proc near
.text$x:0000B2FC                                         ; DATA XREF: .xdata$x:0000E9A8o
.text$x:0000B2FC                 mov     eax, [ebp-10h]
.text$x:0000B2FF                 and     eax, 1
.text$x:0000B302                 jz      $LN4_6
.text$x:0000B308                 and     dword ptr [ebp-10h], 0FFFFFFFEh
.text$x:0000B30C                 mov     ecx, [ebp+8]
.text$x:0000B30F                 jmp     ??1?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@_W@std@@@std@@@std@@QAE@XZ ; std::_Vector_iterator<std::_Vector_val<std::_Simple_types<wchar_t>>>::~_Vector_iterator<std::_Vector_val<std::_Simple_types<wchar_t>>>(void)
.text$x:0000B314 ; ---------------------------------------------------------------------------
.text$x:0000B314
.text$x:0000B314 $LN4_6:                                 ; CODE XREF: __unwindfunclet$?base@?$_Revranit@V?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@_W@std@@@std@@@std@@U?$iterator@Urandom_access_iterator_tag@std@@_WHPA_WAA_W@2@@std@@QBE?AV?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@_W@std@@@std@@@2@XZ$0+6j
.text$x:0000B314                 retn
.text$x:0000B314 __unwindfunclet$?base@?$_Revranit@V?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@_W@std@@@std@@@std@@U?$iterator@Urandom_access_iterator_tag@std@@_WHPA_WAA_W@2@@std@@QBE?AV?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@_W@std@@@std@@@2@XZ$0 endp
.text$x:0000B314
.text$x:0000B315
.text$x:0000B315 ; =============== S U B R O U T I N E =======================================
.text$x:0000B315
.text$x:0000B315
.text$x:0000B315 __ehhandler$?base@?$_Revranit@V?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@_W@std@@@std@@@std@@U?$iterator@Urandom_access_iterator_tag@std@@_WHPA_WAA_W@2@@std@@QBE?AV?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@_W@std@@@std@@@2@XZ proc near
.text$x:0000B315                                         ; DATA XREF: std::_Revranit<std::_Vector_iterator<std::_Vector_val<std::_Simple_types<wchar_t>>>,std::iterator<std::random_access_iterator_tag,wchar_t,int,wchar_t *,wchar_t &>>::base(void)+5o
.text$x:0000B315
.text$x:0000B315 arg_4           = dword ptr  8
.text$x:0000B315
.text$x:0000B315                 mov     edx, [esp+arg_4]
.text$x:0000B319                 lea     eax, [edx+0Ch]
.text$x:0000B31C                 mov     ecx, [edx-0Ch]
.text$x:0000B31F                 xor     ecx, eax
.text$x:0000B321                 call    @__security_check_cookie@4 ; __security_check_cookie(x)
.text$x:0000B326                 mov     eax, offset __ehfuncinfo$?base@?$_Revranit@V?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@_W@std@@@std@@@std@@U?$iterator@Urandom_access_iterator_tag@std@@_WHPA_WAA_W@2@@std@@QBE?AV?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@_W@std@@@std@@@2@XZ
.text$x:0000B32B                 jmp     ___CxxFrameHandler3
.text$x:0000B32B __ehhandler$?base@?$_Revranit@V?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@_W@std@@@std@@@std@@U?$iterator@Urandom_access_iterator_tag@std@@_WHPA_WAA_W@2@@std@@QBE?AV?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@_W@std@@@std@@@2@XZ endp
.text$x:0000B32B
.text$x:0000B32B _text$x         ends
.text$x:0000B32B
.text$mn:0000B330 ; ===========================================================================
.text$mn:0000B330
.text$mn:0000B330 ; Segment type: Pure code
.text$mn:0000B330 ; Segment permissions: Read/Execute
.text$mn:0000B330 _text$mn        segment para public 'CODE' use32
.text$mn:0000B330                 assume cs:_text$mn
.text$mn:0000B330                 ;org 0B330h
.text$mn:0000B330 ; COMDAT (pick any)
.text$mn:0000B330                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text$mn:0000B330
.text$mn:0000B330 ; =============== S U B R O U T I N E =======================================
.text$mn:0000B330
.text$mn:0000B330 ; Attributes: bp-based frame
.text$mn:0000B330
.text$mn:0000B330 ; public: class std::_String_iterator<class std::_String_val<struct std::_Simple_types<wchar_t>>> __thiscall std::basic_string<wchar_t, struct std::char_traits<wchar_t>, class std::allocator<wchar_t>>::begin(void)
.text$mn:0000B330                 public ?begin@?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QAE?AV?$_String_iterator@V?$_String_val@U?$_Simple_types@_W@std@@@std@@@2@XZ
.text$mn:0000B330 ?begin@?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QAE?AV?$_String_iterator@V?$_String_val@U?$_Simple_types@_W@std@@@std@@@2@XZ proc near
.text$mn:0000B330                                         ; CODE XREF: stringToUpper(std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>>)+44p
.text$mn:0000B330                                         ; stringToUpper(std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>>)+80p ...
.text$mn:0000B330
.text$mn:0000B330 var_14          = dword ptr -14h
.text$mn:0000B330 var_10          = dword ptr -10h
.text$mn:0000B330 var_C           = dword ptr -0Ch
.text$mn:0000B330 var_4           = dword ptr -4
.text$mn:0000B330 arg_0           = dword ptr  8
.text$mn:0000B330
.text$mn:0000B330                 push    ebp
.text$mn:0000B331                 mov     ebp, esp
.text$mn:0000B333                 push    0FFFFFFFFh
.text$mn:0000B335                 push    offset __ehhandler$?begin@?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QAE?AV?$_String_iterator@V?$_String_val@U?$_Simple_types@_W@std@@@std@@@2@XZ
.text$mn:0000B33A                 mov     eax, large fs:0
.text$mn:0000B340                 push    eax
.text$mn:0000B341                 sub     esp, 8
.text$mn:0000B344                 mov     eax, dword ptr ds:___security_cookie
.text$mn:0000B349                 xor     eax, ebp
.text$mn:0000B34B                 push    eax
.text$mn:0000B34C                 lea     eax, [ebp+var_C]
.text$mn:0000B34F                 mov     large fs:0, eax
.text$mn:0000B355                 mov     [ebp+var_10], ecx
.text$mn:0000B358                 mov     [ebp+var_14], 0
.text$mn:0000B35F                 mov     eax, [ebp+var_10]
.text$mn:0000B362                 push    eax             ; struct std::_Container_base12 *
.text$mn:0000B363                 mov     ecx, [ebp+var_10]
.text$mn:0000B366                 call    ?_Myptr@?$_String_val@U?$_Simple_types@_W@std@@@std@@QAEPA_WXZ ; std::_String_val<std::_Simple_types<wchar_t>>::_Myptr(void)
.text$mn:0000B36B                 push    eax             ; int
.text$mn:0000B36C                 mov     ecx, [ebp+arg_0]
.text$mn:0000B36F                 call    ??0?$_String_iterator@V?$_String_val@U?$_Simple_types@_W@std@@@std@@@std@@QAE@PA_WPBU_Container_base12@1@@Z ; std::_String_iterator<std::_String_val<std::_Simple_types<wchar_t>>>::_String_iterator<std::_String_val<std::_Simple_types<wchar_t>>>(wchar_t *,std::_Container_base12 const *)
.text$mn:0000B374                 mov     [ebp+var_4], 0
.text$mn:0000B37B                 mov     ecx, [ebp+var_14]
.text$mn:0000B37E                 or      ecx, 1
.text$mn:0000B381                 mov     [ebp+var_14], ecx
.text$mn:0000B384                 mov     eax, [ebp+arg_0]
.text$mn:0000B387                 mov     ecx, [ebp+var_C]
.text$mn:0000B38A                 mov     large fs:0, ecx
.text$mn:0000B391                 pop     ecx
.text$mn:0000B392                 mov     esp, ebp
.text$mn:0000B394                 pop     ebp
.text$mn:0000B395                 retn    4
.text$mn:0000B395 ?begin@?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QAE?AV?$_String_iterator@V?$_String_val@U?$_Simple_types@_W@std@@@std@@@2@XZ endp
.text$mn:0000B395
.text$mn:0000B395 _text$mn        ends
.text$mn:0000B395
.text$x:0000B398 ; ===========================================================================
.text$x:0000B398
.text$x:0000B398 ; Segment type: Pure code
.text$x:0000B398 ; Segment permissions: Read/Execute
.text$x:0000B398 _text$x         segment para public 'CODE' use32
.text$x:0000B398                 assume cs:_text$x
.text$x:0000B398                 ;org 0B398h
.text$x:0000B398 ; COMDAT (pick associative to section at B330)
.text$x:0000B398                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text$x:0000B398
.text$x:0000B398 ; =============== S U B R O U T I N E =======================================
.text$x:0000B398
.text$x:0000B398
.text$x:0000B398 __unwindfunclet$?begin@?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QAE?AV?$_String_iterator@V?$_String_val@U?$_Simple_types@_W@std@@@std@@@2@XZ$0 proc near
.text$x:0000B398                                         ; DATA XREF: .xdata$x:0000DB4Co
.text$x:0000B398                 mov     eax, [ebp-14h]
.text$x:0000B39B                 and     eax, 1
.text$x:0000B39E                 jz      $LN4
.text$x:0000B3A4                 and     dword ptr [ebp-14h], 0FFFFFFFEh
.text$x:0000B3A8                 mov     ecx, [ebp+8]
.text$x:0000B3AB                 jmp     ??1?$_String_iterator@V?$_String_val@U?$_Simple_types@_W@std@@@std@@@std@@QAE@XZ ; std::_String_iterator<std::_String_val<std::_Simple_types<wchar_t>>>::~_String_iterator<std::_String_val<std::_Simple_types<wchar_t>>>(void)
.text$x:0000B3B0 ; ---------------------------------------------------------------------------
.text$x:0000B3B0
.text$x:0000B3B0 $LN4:                                   ; CODE XREF: __unwindfunclet$?begin@?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QAE?AV?$_String_iterator@V?$_String_val@U?$_Simple_types@_W@std@@@std@@@2@XZ$0+6j
.text$x:0000B3B0                 retn
.text$x:0000B3B0 __unwindfunclet$?begin@?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QAE?AV?$_String_iterator@V?$_String_val@U?$_Simple_types@_W@std@@@std@@@2@XZ$0 endp
.text$x:0000B3B0
.text$x:0000B3B1
.text$x:0000B3B1 ; =============== S U B R O U T I N E =======================================
.text$x:0000B3B1
.text$x:0000B3B1
.text$x:0000B3B1 __ehhandler$?begin@?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QAE?AV?$_String_iterator@V?$_String_val@U?$_Simple_types@_W@std@@@std@@@2@XZ proc near
.text$x:0000B3B1                                         ; DATA XREF: std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>>::begin(void)+5o
.text$x:0000B3B1
.text$x:0000B3B1 arg_4           = dword ptr  8
.text$x:0000B3B1
.text$x:0000B3B1                 mov     edx, [esp+arg_4]
.text$x:0000B3B5                 lea     eax, [edx+0Ch]
.text$x:0000B3B8                 mov     ecx, [edx-0Ch]
.text$x:0000B3BB                 xor     ecx, eax
.text$x:0000B3BD                 call    @__security_check_cookie@4 ; __security_check_cookie(x)
.text$x:0000B3C2                 mov     eax, offset __ehfuncinfo$?begin@?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QAE?AV?$_String_iterator@V?$_String_val@U?$_Simple_types@_W@std@@@std@@@2@XZ
.text$x:0000B3C7                 jmp     ___CxxFrameHandler3
.text$x:0000B3C7 __ehhandler$?begin@?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QAE?AV?$_String_iterator@V?$_String_val@U?$_Simple_types@_W@std@@@std@@@2@XZ endp
.text$x:0000B3C7
.text$x:0000B3C7 _text$x         ends
.text$x:0000B3C7
.text$mn:0000B3CC ; ===========================================================================
.text$mn:0000B3CC
.text$mn:0000B3CC ; Segment type: Pure code
.text$mn:0000B3CC ; Segment permissions: Read/Execute
.text$mn:0000B3CC _text$mn        segment para public 'CODE' use32
.text$mn:0000B3CC                 assume cs:_text$mn
.text$mn:0000B3CC                 ;org 0B3CCh
.text$mn:0000B3CC ; COMDAT (pick any)
.text$mn:0000B3CC                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text$mn:0000B3CC
.text$mn:0000B3CC ; =============== S U B R O U T I N E =======================================
.text$mn:0000B3CC
.text$mn:0000B3CC ; Attributes: bp-based frame
.text$mn:0000B3CC
.text$mn:0000B3CC ; public: class std::_String_const_iterator<class std::_String_val<struct std::_Simple_types<wchar_t>>> __thiscall std::basic_string<wchar_t, struct std::char_traits<wchar_t>, class std::allocator<wchar_t>>::begin(void)const
.text$mn:0000B3CC                 public ?begin@?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QBE?AV?$_String_const_iterator@V?$_String_val@U?$_Simple_types@_W@std@@@std@@@2@XZ
.text$mn:0000B3CC ?begin@?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QBE?AV?$_String_const_iterator@V?$_String_val@U?$_Simple_types@_W@std@@@std@@@2@XZ proc near
.text$mn:0000B3CC                                         ; CODE XREF: BuildMenuFileName(int,uint,std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>> const &)+224p
.text$mn:0000B3CC
.text$mn:0000B3CC var_14          = dword ptr -14h
.text$mn:0000B3CC var_10          = dword ptr -10h
.text$mn:0000B3CC var_C           = dword ptr -0Ch
.text$mn:0000B3CC var_4           = dword ptr -4
.text$mn:0000B3CC arg_0           = dword ptr  8
.text$mn:0000B3CC
.text$mn:0000B3CC                 push    ebp
.text$mn:0000B3CD                 mov     ebp, esp
.text$mn:0000B3CF                 push    0FFFFFFFFh
.text$mn:0000B3D1                 push    offset __ehhandler$?begin@?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QBE?AV?$_String_const_iterator@V?$_String_val@U?$_Simple_types@_W@std@@@std@@@2@XZ
.text$mn:0000B3D6                 mov     eax, large fs:0
.text$mn:0000B3DC                 push    eax
.text$mn:0000B3DD                 sub     esp, 8
.text$mn:0000B3E0                 mov     eax, dword ptr ds:___security_cookie
.text$mn:0000B3E5                 xor     eax, ebp
.text$mn:0000B3E7                 push    eax
.text$mn:0000B3E8                 lea     eax, [ebp+var_C]
.text$mn:0000B3EB                 mov     large fs:0, eax
.text$mn:0000B3F1                 mov     [ebp+var_10], ecx
.text$mn:0000B3F4                 mov     [ebp+var_14], 0
.text$mn:0000B3FB                 mov     eax, [ebp+var_10]
.text$mn:0000B3FE                 push    eax             ; struct std::_Container_base12 *
.text$mn:0000B3FF                 mov     ecx, [ebp+var_10]
.text$mn:0000B402                 call    ?_Myptr@?$_String_val@U?$_Simple_types@_W@std@@@std@@QBEPB_WXZ ; std::_String_val<std::_Simple_types<wchar_t>>::_Myptr(void)
.text$mn:0000B407                 push    eax             ; int
.text$mn:0000B408                 mov     ecx, [ebp+arg_0]
.text$mn:0000B40B                 call    ??0?$_String_const_iterator@V?$_String_val@U?$_Simple_types@_W@std@@@std@@@std@@QAE@PB_WPBU_Container_base12@1@@Z ; std::_String_const_iterator<std::_String_val<std::_Simple_types<wchar_t>>>::_String_const_iterator<std::_String_val<std::_Simple_types<wchar_t>>>(wchar_t const *,std::_Container_base12 const *)
.text$mn:0000B410                 mov     [ebp+var_4], 0
.text$mn:0000B417                 mov     ecx, [ebp+var_14]
.text$mn:0000B41A                 or      ecx, 1
.text$mn:0000B41D                 mov     [ebp+var_14], ecx
.text$mn:0000B420                 mov     eax, [ebp+arg_0]
.text$mn:0000B423                 mov     ecx, [ebp+var_C]
.text$mn:0000B426                 mov     large fs:0, ecx
.text$mn:0000B42D                 pop     ecx
.text$mn:0000B42E                 mov     esp, ebp
.text$mn:0000B430                 pop     ebp
.text$mn:0000B431                 retn    4
.text$mn:0000B431 ?begin@?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QBE?AV?$_String_const_iterator@V?$_String_val@U?$_Simple_types@_W@std@@@std@@@2@XZ endp
.text$mn:0000B431
.text$mn:0000B431 _text$mn        ends
.text$mn:0000B431
.text$x:0000B434 ; ===========================================================================
.text$x:0000B434
.text$x:0000B434 ; Segment type: Pure code
.text$x:0000B434 ; Segment permissions: Read/Execute
.text$x:0000B434 _text$x         segment para public 'CODE' use32
.text$x:0000B434                 assume cs:_text$x
.text$x:0000B434                 ;org 0B434h
.text$x:0000B434 ; COMDAT (pick associative to section at B3CC)
.text$x:0000B434                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text$x:0000B434
.text$x:0000B434 ; =============== S U B R O U T I N E =======================================
.text$x:0000B434
.text$x:0000B434
.text$x:0000B434 __unwindfunclet$?begin@?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QBE?AV?$_String_const_iterator@V?$_String_val@U?$_Simple_types@_W@std@@@std@@@2@XZ$0 proc near
.text$x:0000B434                                         ; DATA XREF: .xdata$x:0000DB78o
.text$x:0000B434                 mov     eax, [ebp-14h]
.text$x:0000B437                 and     eax, 1
.text$x:0000B43A                 jz      $LN4_0
.text$x:0000B440                 and     dword ptr [ebp-14h], 0FFFFFFFEh
.text$x:0000B444                 mov     ecx, [ebp+8]
.text$x:0000B447                 jmp     ??1?$_String_const_iterator@V?$_String_val@U?$_Simple_types@_W@std@@@std@@@std@@QAE@XZ ; std::_String_const_iterator<std::_String_val<std::_Simple_types<wchar_t>>>::~_String_const_iterator<std::_String_val<std::_Simple_types<wchar_t>>>(void)
.text$x:0000B44C ; ---------------------------------------------------------------------------
.text$x:0000B44C
.text$x:0000B44C $LN4_0:                                 ; CODE XREF: __unwindfunclet$?begin@?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QBE?AV?$_String_const_iterator@V?$_String_val@U?$_Simple_types@_W@std@@@std@@@2@XZ$0+6j
.text$x:0000B44C                 retn
.text$x:0000B44C __unwindfunclet$?begin@?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QBE?AV?$_String_const_iterator@V?$_String_val@U?$_Simple_types@_W@std@@@std@@@2@XZ$0 endp
.text$x:0000B44C
.text$x:0000B44D
.text$x:0000B44D ; =============== S U B R O U T I N E =======================================
.text$x:0000B44D
.text$x:0000B44D
.text$x:0000B44D __ehhandler$?begin@?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QBE?AV?$_String_const_iterator@V?$_String_val@U?$_Simple_types@_W@std@@@std@@@2@XZ proc near
.text$x:0000B44D                                         ; DATA XREF: std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>>::begin(void)+5o
.text$x:0000B44D
.text$x:0000B44D arg_4           = dword ptr  8
.text$x:0000B44D
.text$x:0000B44D                 mov     edx, [esp+arg_4]
.text$x:0000B451                 lea     eax, [edx+0Ch]
.text$x:0000B454                 mov     ecx, [edx-0Ch]
.text$x:0000B457                 xor     ecx, eax
.text$x:0000B459                 call    @__security_check_cookie@4 ; __security_check_cookie(x)
.text$x:0000B45E                 mov     eax, offset __ehfuncinfo$?begin@?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QBE?AV?$_String_const_iterator@V?$_String_val@U?$_Simple_types@_W@std@@@std@@@2@XZ
.text$x:0000B463                 jmp     ___CxxFrameHandler3
.text$x:0000B463 __ehhandler$?begin@?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QBE?AV?$_String_const_iterator@V?$_String_val@U?$_Simple_types@_W@std@@@std@@@2@XZ endp
.text$x:0000B463
.text$x:0000B463 _text$x         ends
.text$x:0000B463
.text$mn:0000B468 ; ===========================================================================
.text$mn:0000B468
.text$mn:0000B468 ; Segment type: Pure code
.text$mn:0000B468 ; Segment permissions: Read/Execute
.text$mn:0000B468 _text$mn        segment para public 'CODE' use32
.text$mn:0000B468                 assume cs:_text$mn
.text$mn:0000B468                 ;org 0B468h
.text$mn:0000B468 ; COMDAT (pick any)
.text$mn:0000B468                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text$mn:0000B468
.text$mn:0000B468 ; =============== S U B R O U T I N E =======================================
.text$mn:0000B468
.text$mn:0000B468 ; Attributes: bp-based frame
.text$mn:0000B468
.text$mn:0000B468 ; public: class std::_Vector_iterator<class std::_Vector_val<struct std::_Simple_types<wchar_t>>> __thiscall std::vector<wchar_t, class std::allocator<wchar_t>>::begin(void)
.text$mn:0000B468                 public ?begin@?$vector@_WV?$allocator@_W@std@@@std@@QAE?AV?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@_W@std@@@std@@@2@XZ
.text$mn:0000B468 ?begin@?$vector@_WV?$allocator@_W@std@@@std@@QAE?AV?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@_W@std@@@std@@@2@XZ proc near
.text$mn:0000B468                                         ; CODE XREF: BuildMenuFileName(int,uint,std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>> const &)+147p
.text$mn:0000B468                                         ; BuildMenuFileName(int,uint,std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>> const &)+195p ...
.text$mn:0000B468
.text$mn:0000B468 var_14          = dword ptr -14h
.text$mn:0000B468 var_10          = dword ptr -10h
.text$mn:0000B468 var_C           = dword ptr -0Ch
.text$mn:0000B468 var_4           = dword ptr -4
.text$mn:0000B468 arg_0           = dword ptr  8
.text$mn:0000B468
.text$mn:0000B468                 push    ebp
.text$mn:0000B469                 mov     ebp, esp
.text$mn:0000B46B                 push    0FFFFFFFFh
.text$mn:0000B46D                 push    offset __ehhandler$?begin@?$vector@_WV?$allocator@_W@std@@@std@@QAE?AV?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@_W@std@@@std@@@2@XZ
.text$mn:0000B472                 mov     eax, large fs:0
.text$mn:0000B478                 push    eax
.text$mn:0000B479                 sub     esp, 8
.text$mn:0000B47C                 mov     eax, dword ptr ds:___security_cookie
.text$mn:0000B481                 xor     eax, ebp
.text$mn:0000B483                 push    eax
.text$mn:0000B484                 lea     eax, [ebp+var_C]
.text$mn:0000B487                 mov     large fs:0, eax
.text$mn:0000B48D                 mov     [ebp+var_10], ecx
.text$mn:0000B490                 mov     [ebp+var_14], 0
.text$mn:0000B497                 mov     eax, [ebp+var_10]
.text$mn:0000B49A                 push    eax             ; struct std::_Container_base12 *
.text$mn:0000B49B                 mov     ecx, [ebp+var_10]
.text$mn:0000B49E                 mov     edx, [ecx+4]
.text$mn:0000B4A1                 push    edx             ; int
.text$mn:0000B4A2                 mov     ecx, [ebp+arg_0]
.text$mn:0000B4A5                 call    ??0?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@_W@std@@@std@@@std@@QAE@PA_WPBU_Container_base12@1@@Z ; std::_Vector_iterator<std::_Vector_val<std::_Simple_types<wchar_t>>>::_Vector_iterator<std::_Vector_val<std::_Simple_types<wchar_t>>>(wchar_t *,std::_Container_base12 const *)
.text$mn:0000B4AA                 mov     [ebp+var_4], 0
.text$mn:0000B4B1                 mov     eax, [ebp+var_14]
.text$mn:0000B4B4                 or      eax, 1
.text$mn:0000B4B7                 mov     [ebp+var_14], eax
.text$mn:0000B4BA                 mov     eax, [ebp+arg_0]
.text$mn:0000B4BD                 mov     ecx, [ebp+var_C]
.text$mn:0000B4C0                 mov     large fs:0, ecx
.text$mn:0000B4C7                 pop     ecx
.text$mn:0000B4C8                 mov     esp, ebp
.text$mn:0000B4CA                 pop     ebp
.text$mn:0000B4CB                 retn    4
.text$mn:0000B4CB ?begin@?$vector@_WV?$allocator@_W@std@@@std@@QAE?AV?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@_W@std@@@std@@@2@XZ endp
.text$mn:0000B4CB
.text$mn:0000B4CB ; ---------------------------------------------------------------------------
.text$mn:0000B4CE                 align 10h
.text$mn:0000B4CE _text$mn        ends
.text$mn:0000B4CE
.text$x:0000B4D0 ; ===========================================================================
.text$x:0000B4D0
.text$x:0000B4D0 ; Segment type: Pure code
.text$x:0000B4D0 ; Segment permissions: Read/Execute
.text$x:0000B4D0 _text$x         segment para public 'CODE' use32
.text$x:0000B4D0                 assume cs:_text$x
.text$x:0000B4D0                 ;org 0B4D0h
.text$x:0000B4D0 ; COMDAT (pick associative to section at B468)
.text$x:0000B4D0                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text$x:0000B4D0
.text$x:0000B4D0 ; =============== S U B R O U T I N E =======================================
.text$x:0000B4D0
.text$x:0000B4D0
.text$x:0000B4D0 __unwindfunclet$?begin@?$vector@_WV?$allocator@_W@std@@@std@@QAE?AV?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@_W@std@@@std@@@2@XZ$0 proc near
.text$x:0000B4D0                                         ; DATA XREF: .xdata$x:0000E524o
.text$x:0000B4D0                 mov     eax, [ebp-14h]
.text$x:0000B4D3                 and     eax, 1
.text$x:0000B4D6                 jz      $LN4_4
.text$x:0000B4DC                 and     dword ptr [ebp-14h], 0FFFFFFFEh
.text$x:0000B4E0                 mov     ecx, [ebp+8]
.text$x:0000B4E3                 jmp     ??1?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@_W@std@@@std@@@std@@QAE@XZ ; std::_Vector_iterator<std::_Vector_val<std::_Simple_types<wchar_t>>>::~_Vector_iterator<std::_Vector_val<std::_Simple_types<wchar_t>>>(void)
.text$x:0000B4E8 ; ---------------------------------------------------------------------------
.text$x:0000B4E8
.text$x:0000B4E8 $LN4_4:                                 ; CODE XREF: __unwindfunclet$?begin@?$vector@_WV?$allocator@_W@std@@@std@@QAE?AV?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@_W@std@@@std@@@2@XZ$0+6j
.text$x:0000B4E8                 retn
.text$x:0000B4E8 __unwindfunclet$?begin@?$vector@_WV?$allocator@_W@std@@@std@@QAE?AV?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@_W@std@@@std@@@2@XZ$0 endp
.text$x:0000B4E8
.text$x:0000B4E9
.text$x:0000B4E9 ; =============== S U B R O U T I N E =======================================
.text$x:0000B4E9
.text$x:0000B4E9
.text$x:0000B4E9 __ehhandler$?begin@?$vector@_WV?$allocator@_W@std@@@std@@QAE?AV?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@_W@std@@@std@@@2@XZ proc near
.text$x:0000B4E9                                         ; DATA XREF: std::vector<wchar_t,std::allocator<wchar_t>>::begin(void)+5o
.text$x:0000B4E9
.text$x:0000B4E9 arg_4           = dword ptr  8
.text$x:0000B4E9
.text$x:0000B4E9                 mov     edx, [esp+arg_4]
.text$x:0000B4ED                 lea     eax, [edx+0Ch]
.text$x:0000B4F0                 mov     ecx, [edx-0Ch]
.text$x:0000B4F3                 xor     ecx, eax
.text$x:0000B4F5                 call    @__security_check_cookie@4 ; __security_check_cookie(x)
.text$x:0000B4FA                 mov     eax, offset __ehfuncinfo$?begin@?$vector@_WV?$allocator@_W@std@@@std@@QAE?AV?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@_W@std@@@std@@@2@XZ
.text$x:0000B4FF                 jmp     ___CxxFrameHandler3
.text$x:0000B4FF __ehhandler$?begin@?$vector@_WV?$allocator@_W@std@@@std@@QAE?AV?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@_W@std@@@std@@@2@XZ endp
.text$x:0000B4FF
.text$x:0000B4FF _text$x         ends
.text$x:0000B4FF
.text$mn:0000B504 ; ===========================================================================
.text$mn:0000B504
.text$mn:0000B504 ; Segment type: Pure code
.text$mn:0000B504 ; Segment permissions: Read/Execute
.text$mn:0000B504 _text$mn        segment para public 'CODE' use32
.text$mn:0000B504                 assume cs:_text$mn
.text$mn:0000B504                 ;org 0B504h
.text$mn:0000B504 ; COMDAT (pick any)
.text$mn:0000B504                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text$mn:0000B504
.text$mn:0000B504 ; =============== S U B R O U T I N E =======================================
.text$mn:0000B504
.text$mn:0000B504 ; Attributes: bp-based frame
.text$mn:0000B504
.text$mn:0000B504 ; public: char const * __thiscall std::basic_string<char, struct std::char_traits<char>, class std::allocator<char>>::c_str(void)const
.text$mn:0000B504                 public ?c_str@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QBEPBDXZ
.text$mn:0000B504 ?c_str@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QBEPBDXZ proc near
.text$mn:0000B504                                         ; CODE XREF: string2wstring(std::basic_string<char,std::char_traits<char>,std::allocator<char>> const &,uint)+35p
.text$mn:0000B504                                         ; string2wstring(std::basic_string<char,std::char_traits<char>,std::allocator<char>> const &,uint)+77p
.text$mn:0000B504
.text$mn:0000B504 var_4           = dword ptr -4
.text$mn:0000B504
.text$mn:0000B504                 push    ebp
.text$mn:0000B505                 mov     ebp, esp
.text$mn:0000B507                 push    ecx
.text$mn:0000B508                 mov     [ebp+var_4], ecx
.text$mn:0000B50B                 mov     ecx, [ebp+var_4]
.text$mn:0000B50E                 call    ?_Myptr@?$_String_val@U?$_Simple_types@D@std@@@std@@QBEPBDXZ ; std::_String_val<std::_Simple_types<char>>::_Myptr(void)
.text$mn:0000B513                 mov     esp, ebp
.text$mn:0000B515                 pop     ebp
.text$mn:0000B516                 retn
.text$mn:0000B516 ?c_str@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QBEPBDXZ endp
.text$mn:0000B516
.text$mn:0000B516 ; ---------------------------------------------------------------------------
.text$mn:0000B517                 align 4
.text$mn:0000B517 _text$mn        ends
.text$mn:0000B517
.text$mn:0000B518 ; ===========================================================================
.text$mn:0000B518
.text$mn:0000B518 ; Segment type: Pure code
.text$mn:0000B518 ; Segment permissions: Read/Execute
.text$mn:0000B518 _text$mn        segment para public 'CODE' use32
.text$mn:0000B518                 assume cs:_text$mn
.text$mn:0000B518                 ;org 0B518h
.text$mn:0000B518 ; COMDAT (pick any)
.text$mn:0000B518                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text$mn:0000B518
.text$mn:0000B518 ; =============== S U B R O U T I N E =======================================
.text$mn:0000B518
.text$mn:0000B518 ; Attributes: bp-based frame
.text$mn:0000B518
.text$mn:0000B518 ; public: wchar_t const * __thiscall std::basic_string<wchar_t, struct std::char_traits<wchar_t>, class std::allocator<wchar_t>>::c_str(void)const
.text$mn:0000B518                 public ?c_str@?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QBEPB_WXZ
.text$mn:0000B518 ?c_str@?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QBEPB_WXZ proc near
.text$mn:0000B518                                         ; CODE XREF: wstring2string(std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>> const &,uint)+39p
.text$mn:0000B518                                         ; wstring2string(std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>> const &,uint)+7Fp ...
.text$mn:0000B518
.text$mn:0000B518 var_4           = dword ptr -4
.text$mn:0000B518
.text$mn:0000B518                 push    ebp
.text$mn:0000B519                 mov     ebp, esp
.text$mn:0000B51B                 push    ecx
.text$mn:0000B51C                 mov     [ebp+var_4], ecx
.text$mn:0000B51F                 mov     ecx, [ebp+var_4]
.text$mn:0000B522                 call    ?_Myptr@?$_String_val@U?$_Simple_types@_W@std@@@std@@QBEPB_WXZ ; std::_String_val<std::_Simple_types<wchar_t>>::_Myptr(void)
.text$mn:0000B527                 mov     esp, ebp
.text$mn:0000B529                 pop     ebp
.text$mn:0000B52A                 retn
.text$mn:0000B52A ?c_str@?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QBEPB_WXZ endp
.text$mn:0000B52A
.text$mn:0000B52A ; ---------------------------------------------------------------------------
.text$mn:0000B52B                 align 4
.text$mn:0000B52B _text$mn        ends
.text$mn:0000B52B
.text$mn:0000B52C ; ===========================================================================
.text$mn:0000B52C
.text$mn:0000B52C ; Segment type: Pure code
.text$mn:0000B52C ; Segment permissions: Read/Execute
.text$mn:0000B52C _text$mn        segment para public 'CODE' use32
.text$mn:0000B52C                 assume cs:_text$mn
.text$mn:0000B52C                 ;org 0B52Ch
.text$mn:0000B52C ; COMDAT (pick any)
.text$mn:0000B52C                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text$mn:0000B52C
.text$mn:0000B52C ; =============== S U B R O U T I N E =======================================
.text$mn:0000B52C
.text$mn:0000B52C ; Attributes: bp-based frame
.text$mn:0000B52C
.text$mn:0000B52C ; public: unsigned int __thiscall std::vector<class std::basic_string<wchar_t, struct std::char_traits<wchar_t>, class std::allocator<wchar_t>>, class std::allocator<class std::basic_string<wchar_t, struct std::char_traits<wchar_t>, class std::allocator<wchar_t>>>>::capacity(void)const
.text$mn:0000B52C                 public ?capacity@?$vector@V?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@V?$allocator@V?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@@2@@std@@QBEIXZ
.text$mn:0000B52C ?capacity@?$vector@V?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@V?$allocator@V?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@@2@@std@@QBEIXZ proc near
.text$mn:0000B52C                                         ; CODE XREF: std::vector<std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>>,std::allocator<std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>>>>::_Grow_to(uint)+Cp
.text$mn:0000B52C
.text$mn:0000B52C var_4           = dword ptr -4
.text$mn:0000B52C
.text$mn:0000B52C                 push    ebp
.text$mn:0000B52D                 mov     ebp, esp
.text$mn:0000B52F                 push    ecx
.text$mn:0000B530                 mov     [ebp+var_4], ecx
.text$mn:0000B533                 mov     eax, [ebp+var_4]
.text$mn:0000B536                 mov     ecx, [ebp+var_4]
.text$mn:0000B539                 mov     eax, [eax+0Ch]
.text$mn:0000B53C                 sub     eax, [ecx+4]
.text$mn:0000B53F                 cdq
.text$mn:0000B540                 mov     ecx, 1Ch
.text$mn:0000B545                 idiv    ecx
.text$mn:0000B547                 mov     esp, ebp
.text$mn:0000B549                 pop     ebp
.text$mn:0000B54A                 retn
.text$mn:0000B54A ?capacity@?$vector@V?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@V?$allocator@V?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@@2@@std@@QBEIXZ endp
.text$mn:0000B54A
.text$mn:0000B54A ; ---------------------------------------------------------------------------
.text$mn:0000B54B                 align 4
.text$mn:0000B54B _text$mn        ends
.text$mn:0000B54B
.text$mn:0000B54C ; ===========================================================================
.text$mn:0000B54C
.text$mn:0000B54C ; Segment type: Pure code
.text$mn:0000B54C ; Segment permissions: Read/Execute
.text$mn:0000B54C _text$mn        segment para public 'CODE' use32
.text$mn:0000B54C                 assume cs:_text$mn
.text$mn:0000B54C                 ;org 0B54Ch
.text$mn:0000B54C ; COMDAT (pick any)
.text$mn:0000B54C                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text$mn:0000B54C
.text$mn:0000B54C ; =============== S U B R O U T I N E =======================================
.text$mn:0000B54C
.text$mn:0000B54C ; Attributes: bp-based frame
.text$mn:0000B54C
.text$mn:0000B54C ; public: unsigned int __thiscall std::vector<wchar_t, class std::allocator<wchar_t>>::capacity(void)const
.text$mn:0000B54C                 public ?capacity@?$vector@_WV?$allocator@_W@std@@@std@@QBEIXZ
.text$mn:0000B54C ?capacity@?$vector@_WV?$allocator@_W@std@@@std@@QBEIXZ proc near
.text$mn:0000B54C                                         ; CODE XREF: std::vector<wchar_t,std::allocator<wchar_t>>::_Grow_to(uint)+Cp
.text$mn:0000B54C
.text$mn:0000B54C var_4           = dword ptr -4
.text$mn:0000B54C
.text$mn:0000B54C                 push    ebp
.text$mn:0000B54D                 mov     ebp, esp
.text$mn:0000B54F                 push    ecx
.text$mn:0000B550                 mov     [ebp+var_4], ecx
.text$mn:0000B553                 mov     eax, [ebp+var_4]
.text$mn:0000B556                 mov     ecx, [ebp+var_4]
.text$mn:0000B559                 mov     eax, [eax+0Ch]
.text$mn:0000B55C                 sub     eax, [ecx+4]
.text$mn:0000B55F                 sar     eax, 1
.text$mn:0000B561                 mov     esp, ebp
.text$mn:0000B563                 pop     ebp
.text$mn:0000B564                 retn
.text$mn:0000B564 ?capacity@?$vector@_WV?$allocator@_W@std@@@std@@QBEIXZ endp
.text$mn:0000B564
.text$mn:0000B564 ; ---------------------------------------------------------------------------
.text$mn:0000B565                 align 4
.text$mn:0000B565 _text$mn        ends
.text$mn:0000B565
.text$mn:0000B568 ; ===========================================================================
.text$mn:0000B568
.text$mn:0000B568 ; Segment type: Pure code
.text$mn:0000B568 ; Segment permissions: Read/Execute
.text$mn:0000B568 _text$mn        segment para public 'CODE' use32
.text$mn:0000B568                 assume cs:_text$mn
.text$mn:0000B568                 ;org 0B568h
.text$mn:0000B568 ; COMDAT (pick any)
.text$mn:0000B568                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text$mn:0000B568
.text$mn:0000B568 ; =============== S U B R O U T I N E =======================================
.text$mn:0000B568
.text$mn:0000B568 ; Attributes: bp-based frame
.text$mn:0000B568
.text$mn:0000B568 ; const struct std::error_category *__thiscall std::error_code::category(std::error_code *__hidden this)
.text$mn:0000B568                 public ?category@error_code@std@@QBEABVerror_category@2@XZ
.text$mn:0000B568 ?category@error_code@std@@QBEABVerror_category@2@XZ proc near
.text$mn:0000B568                                         ; CODE XREF: std::error_category::equivalent(std::error_code const &,int)+Cp
.text$mn:0000B568
.text$mn:0000B568 var_4           = dword ptr -4
.text$mn:0000B568
.text$mn:0000B568                 push    ebp
.text$mn:0000B569                 mov     ebp, esp
.text$mn:0000B56B                 push    ecx
.text$mn:0000B56C                 mov     [ebp+var_4], ecx
.text$mn:0000B56F                 mov     eax, [ebp+var_4]
.text$mn:0000B572                 mov     eax, [eax+4]
.text$mn:0000B575                 mov     esp, ebp
.text$mn:0000B577                 pop     ebp
.text$mn:0000B578                 retn
.text$mn:0000B578 ?category@error_code@std@@QBEABVerror_category@2@XZ endp
.text$mn:0000B578
.text$mn:0000B578 ; ---------------------------------------------------------------------------
.text$mn:0000B579                 align 4
.text$mn:0000B579 _text$mn        ends
.text$mn:0000B579
.text$mn:0000B57C ; ===========================================================================
.text$mn:0000B57C
.text$mn:0000B57C ; Segment type: Pure code
.text$mn:0000B57C ; Segment permissions: Read/Execute
.text$mn:0000B57C _text$mn        segment para public 'CODE' use32
.text$mn:0000B57C                 assume cs:_text$mn
.text$mn:0000B57C                 ;org 0B57Ch
.text$mn:0000B57C ; COMDAT (pick any)
.text$mn:0000B57C                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text$mn:0000B57C
.text$mn:0000B57C ; =============== S U B R O U T I N E =======================================
.text$mn:0000B57C
.text$mn:0000B57C ; Attributes: bp-based frame
.text$mn:0000B57C
.text$mn:0000B57C ; const struct std::error_category *__thiscall std::error_condition::category(std::error_condition *__hidden this)
.text$mn:0000B57C                 public ?category@error_condition@std@@QBEABVerror_category@2@XZ
.text$mn:0000B57C ?category@error_condition@std@@QBEABVerror_category@2@XZ proc near
.text$mn:0000B57C                                         ; CODE XREF: std::error_condition::operator==(std::error_condition const &)+Dp
.text$mn:0000B57C                                         ; std::error_condition::operator==(std::error_condition const &)+16p
.text$mn:0000B57C
.text$mn:0000B57C var_4           = dword ptr -4
.text$mn:0000B57C
.text$mn:0000B57C                 push    ebp
.text$mn:0000B57D                 mov     ebp, esp
.text$mn:0000B57F                 push    ecx
.text$mn:0000B580                 mov     [ebp+var_4], ecx
.text$mn:0000B583                 mov     eax, [ebp+var_4]
.text$mn:0000B586                 mov     eax, [eax+4]
.text$mn:0000B589                 mov     esp, ebp
.text$mn:0000B58B                 pop     ebp
.text$mn:0000B58C                 retn
.text$mn:0000B58C ?category@error_condition@std@@QBEABVerror_category@2@XZ endp
.text$mn:0000B58C
.text$mn:0000B58C ; ---------------------------------------------------------------------------
.text$mn:0000B58D                 align 10h
.text$mn:0000B58D _text$mn        ends
.text$mn:0000B58D
.text$mn:0000B590 ; ===========================================================================
.text$mn:0000B590
.text$mn:0000B590 ; Segment type: Pure code
.text$mn:0000B590 ; Segment permissions: Read/Execute
.text$mn:0000B590 _text$mn        segment para public 'CODE' use32
.text$mn:0000B590                 assume cs:_text$mn
.text$mn:0000B590                 ;org 0B590h
.text$mn:0000B590 ; COMDAT (pick any)
.text$mn:0000B590                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text$mn:0000B590
.text$mn:0000B590 ; =============== S U B R O U T I N E =======================================
.text$mn:0000B590
.text$mn:0000B590 ; Attributes: bp-based frame
.text$mn:0000B590
.text$mn:0000B590 ; public: int __thiscall std::basic_string<wchar_t, struct std::char_traits<wchar_t>, class std::allocator<wchar_t>>::compare(unsigned int, unsigned int, wchar_t const *, unsigned int)const
.text$mn:0000B590                 public ?compare@?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QBEHIIPB_WI@Z
.text$mn:0000B590 ?compare@?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QBEHIIPB_WI@Z proc near
.text$mn:0000B590                                         ; CODE XREF: std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>>::compare(wchar_t const *)+3Ap
.text$mn:0000B590
.text$mn:0000B590 var_18          = dword ptr -18h
.text$mn:0000B590 var_14          = dword ptr -14h
.text$mn:0000B590 var_10          = dword ptr -10h
.text$mn:0000B590 var_C           = dword ptr -0Ch
.text$mn:0000B590 var_8           = dword ptr -8
.text$mn:0000B590 var_4           = dword ptr -4
.text$mn:0000B590 arg_0           = dword ptr  8
.text$mn:0000B590 arg_4           = dword ptr  0Ch
.text$mn:0000B590 arg_8           = dword ptr  10h
.text$mn:0000B590 arg_C           = dword ptr  14h
.text$mn:0000B590
.text$mn:0000B590                 push    ebp
.text$mn:0000B591                 mov     ebp, esp
.text$mn:0000B593                 sub     esp, 18h
.text$mn:0000B596                 mov     [ebp+var_4], ecx
.text$mn:0000B599                 cmp     [ebp+arg_C], 0
.text$mn:0000B59D                 jz      short loc_B5B5
.text$mn:0000B59F                 push    87Dh            ; unsigned int
.text$mn:0000B5A4                 push    offset ??_C@_1IO@FEAPGJBD@?$AAC?$AA?3?$AA?2?$AAP?$AAr?$AAo?$AAg?$AAr?$AAa?$AAm?$AA?5?$AAF?$AAi?$AAl?$AAe?$AAs?$AA?5?$AA?$CI?$AAx?$AA8?$AA6?$AA?$CJ?$AA?2?$AAM?$AAi?$AAc?$AAr?$AAo?$AAs?$AAo?$AAf?$AAt@ ; "C:\\Program Files (x86)\\Microsoft Visu"...
.text$mn:0000B5A9                 mov     eax, [ebp+arg_8]
.text$mn:0000B5AC                 push    eax             ; int
.text$mn:0000B5AD                 call    ??$_Debug_pointer@_W@std@@YAXPB_W0I@Z ; std::_Debug_pointer<wchar_t>(wchar_t const *,wchar_t const *,uint)
.text$mn:0000B5B2                 add     esp, 0Ch
.text$mn:0000B5B5
.text$mn:0000B5B5 loc_B5B5:                               ; CODE XREF: std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>>::compare(uint,uint,wchar_t const *,uint)+Dj
.text$mn:0000B5B5                 mov     ecx, [ebp+var_4]
.text$mn:0000B5B8                 mov     edx, [ecx+14h]
.text$mn:0000B5BB                 cmp     edx, [ebp+arg_0]
.text$mn:0000B5BE                 jnb     short loc_B5C8
.text$mn:0000B5C0                 mov     ecx, [ebp+var_4]
.text$mn:0000B5C3                 call    ?_Xran@?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QBEXXZ ; std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>>::_Xran(void)
.text$mn:0000B5C8
.text$mn:0000B5C8 loc_B5C8:                               ; CODE XREF: std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>>::compare(uint,uint,wchar_t const *,uint)+2Ej
.text$mn:0000B5C8                 mov     eax, [ebp+var_4]
.text$mn:0000B5CB                 mov     ecx, [eax+14h]
.text$mn:0000B5CE                 sub     ecx, [ebp+arg_0]
.text$mn:0000B5D1                 cmp     ecx, [ebp+arg_4]
.text$mn:0000B5D4                 jnb     short loc_B5E2
.text$mn:0000B5D6                 mov     edx, [ebp+var_4]
.text$mn:0000B5D9                 mov     eax, [edx+14h]
.text$mn:0000B5DC                 sub     eax, [ebp+arg_0]
.text$mn:0000B5DF                 mov     [ebp+arg_4], eax
.text$mn:0000B5E2
.text$mn:0000B5E2 loc_B5E2:                               ; CODE XREF: std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>>::compare(uint,uint,wchar_t const *,uint)+44j
.text$mn:0000B5E2                 mov     ecx, [ebp+arg_4]
.text$mn:0000B5E5                 cmp     ecx, [ebp+arg_C]
.text$mn:0000B5E8                 jnb     short loc_B5F2
.text$mn:0000B5EA                 mov     edx, [ebp+arg_4]
.text$mn:0000B5ED                 mov     [ebp+var_8], edx
.text$mn:0000B5F0                 jmp     short loc_B5F8
.text$mn:0000B5F2 ; ---------------------------------------------------------------------------
.text$mn:0000B5F2
.text$mn:0000B5F2 loc_B5F2:                               ; CODE XREF: std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>>::compare(uint,uint,wchar_t const *,uint)+58j
.text$mn:0000B5F2                 mov     eax, [ebp+arg_C]
.text$mn:0000B5F5                 mov     [ebp+var_8], eax
.text$mn:0000B5F8
.text$mn:0000B5F8 loc_B5F8:                               ; CODE XREF: std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>>::compare(uint,uint,wchar_t const *,uint)+60j
.text$mn:0000B5F8                 mov     ecx, [ebp+var_8]
.text$mn:0000B5FB                 push    ecx
.text$mn:0000B5FC                 mov     edx, [ebp+arg_8]
.text$mn:0000B5FF                 push    edx
.text$mn:0000B600                 mov     ecx, [ebp+var_4]
.text$mn:0000B603                 call    ?_Myptr@?$_String_val@U?$_Simple_types@_W@std@@@std@@QBEPB_WXZ ; std::_String_val<std::_Simple_types<wchar_t>>::_Myptr(void)
.text$mn:0000B608                 mov     ecx, [ebp+arg_0]
.text$mn:0000B60B                 lea     edx, [eax+ecx*2]
.text$mn:0000B60E                 push    edx
.text$mn:0000B60F                 call    ?compare@?$char_traits@_W@std@@SAHPB_W0I@Z ; std::char_traits<wchar_t>::compare(wchar_t const *,wchar_t const *,uint)
.text$mn:0000B614                 add     esp, 0Ch
.text$mn:0000B617                 mov     [ebp+var_C], eax
.text$mn:0000B61A                 cmp     [ebp+var_C], 0
.text$mn:0000B61E                 jz      short loc_B628
.text$mn:0000B620                 mov     eax, [ebp+var_C]
.text$mn:0000B623                 mov     [ebp+var_18], eax
.text$mn:0000B626                 jmp     short loc_B65D
.text$mn:0000B628 ; ---------------------------------------------------------------------------
.text$mn:0000B628
.text$mn:0000B628 loc_B628:                               ; CODE XREF: std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>>::compare(uint,uint,wchar_t const *,uint)+8Ej
.text$mn:0000B628                 mov     ecx, [ebp+arg_4]
.text$mn:0000B62B                 cmp     ecx, [ebp+arg_C]
.text$mn:0000B62E                 jnb     short loc_B639
.text$mn:0000B630                 mov     [ebp+var_14], 0FFFFFFFFh
.text$mn:0000B637                 jmp     short loc_B657
.text$mn:0000B639 ; ---------------------------------------------------------------------------
.text$mn:0000B639
.text$mn:0000B639 loc_B639:                               ; CODE XREF: std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>>::compare(uint,uint,wchar_t const *,uint)+9Ej
.text$mn:0000B639                 mov     edx, [ebp+arg_4]
.text$mn:0000B63C                 cmp     edx, [ebp+arg_C]
.text$mn:0000B63F                 jnz     short loc_B64A
.text$mn:0000B641                 mov     [ebp+var_10], 0
.text$mn:0000B648                 jmp     short loc_B651
.text$mn:0000B64A ; ---------------------------------------------------------------------------
.text$mn:0000B64A
.text$mn:0000B64A loc_B64A:                               ; CODE XREF: std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>>::compare(uint,uint,wchar_t const *,uint)+AFj
.text$mn:0000B64A                 mov     [ebp+var_10], 1
.text$mn:0000B651
.text$mn:0000B651 loc_B651:                               ; CODE XREF: std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>>::compare(uint,uint,wchar_t const *,uint)+B8j
.text$mn:0000B651                 mov     eax, [ebp+var_10]
.text$mn:0000B654                 mov     [ebp+var_14], eax
.text$mn:0000B657
.text$mn:0000B657 loc_B657:                               ; CODE XREF: std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>>::compare(uint,uint,wchar_t const *,uint)+A7j
.text$mn:0000B657                 mov     ecx, [ebp+var_14]
.text$mn:0000B65A                 mov     [ebp+var_18], ecx
.text$mn:0000B65D
.text$mn:0000B65D loc_B65D:                               ; CODE XREF: std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>>::compare(uint,uint,wchar_t const *,uint)+96j
.text$mn:0000B65D                 mov     eax, [ebp+var_18]
.text$mn:0000B660                 mov     esp, ebp
.text$mn:0000B662                 pop     ebp
.text$mn:0000B663                 retn    10h
.text$mn:0000B663 ?compare@?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QBEHIIPB_WI@Z endp
.text$mn:0000B663
.text$mn:0000B663 ; ---------------------------------------------------------------------------
.text$mn:0000B666                 align 4
.text$mn:0000B666 _text$mn        ends
.text$mn:0000B666
.text$mn:0000B668 ; ===========================================================================
.text$mn:0000B668
.text$mn:0000B668 ; Segment type: Pure code
.text$mn:0000B668 ; Segment permissions: Read/Execute
.text$mn:0000B668 _text$mn        segment para public 'CODE' use32
.text$mn:0000B668                 assume cs:_text$mn
.text$mn:0000B668                 ;org 0B668h
.text$mn:0000B668 ; COMDAT (pick any)
.text$mn:0000B668                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text$mn:0000B668
.text$mn:0000B668 ; =============== S U B R O U T I N E =======================================
.text$mn:0000B668
.text$mn:0000B668 ; Attributes: bp-based frame
.text$mn:0000B668
.text$mn:0000B668 ; int __stdcall std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>>::compare(wchar_t *Str)
.text$mn:0000B668                 public ?compare@?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QBEHPB_W@Z
.text$mn:0000B668 ?compare@?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QBEHPB_W@Z proc near
.text$mn:0000B668                                         ; CODE XREF: std::operator==<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>>(std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>> const &,wchar_t const *)+Bp
.text$mn:0000B668
.text$mn:0000B668 var_4           = dword ptr -4
.text$mn:0000B668 Str             = dword ptr  8
.text$mn:0000B668
.text$mn:0000B668                 push    ebp
.text$mn:0000B669                 mov     ebp, esp
.text$mn:0000B66B                 push    ecx
.text$mn:0000B66C                 mov     [ebp+var_4], ecx
.text$mn:0000B66F                 push    86Eh            ; unsigned int
.text$mn:0000B674                 push    offset ??_C@_1IO@FEAPGJBD@?$AAC?$AA?3?$AA?2?$AAP?$AAr?$AAo?$AAg?$AAr?$AAa?$AAm?$AA?5?$AAF?$AAi?$AAl?$AAe?$AAs?$AA?5?$AA?$CI?$AAx?$AA8?$AA6?$AA?$CJ?$AA?2?$AAM?$AAi?$AAc?$AAr?$AAo?$AAs?$AAo?$AAf?$AAt@ ; "C:\\Program Files (x86)\\Microsoft Visu"...
.text$mn:0000B679                 mov     eax, [ebp+Str]
.text$mn:0000B67C                 push    eax             ; int
.text$mn:0000B67D                 call    ??$_Debug_pointer@_W@std@@YAXPB_W0I@Z ; std::_Debug_pointer<wchar_t>(wchar_t const *,wchar_t const *,uint)
.text$mn:0000B682                 add     esp, 0Ch
.text$mn:0000B685                 mov     ecx, [ebp+Str]
.text$mn:0000B688                 push    ecx             ; Str
.text$mn:0000B689                 call    ?length@?$char_traits@_W@std@@SAIPB_W@Z ; std::char_traits<wchar_t>::length(wchar_t const *)
.text$mn:0000B68E                 add     esp, 4
.text$mn:0000B691                 push    eax
.text$mn:0000B692                 mov     edx, [ebp+Str]
.text$mn:0000B695                 push    edx
.text$mn:0000B696                 mov     eax, [ebp+var_4]
.text$mn:0000B699                 mov     ecx, [eax+14h]
.text$mn:0000B69C                 push    ecx
.text$mn:0000B69D                 push    0
.text$mn:0000B69F                 mov     ecx, [ebp+var_4]
.text$mn:0000B6A2                 call    ?compare@?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QBEHIIPB_WI@Z ; std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>>::compare(uint,uint,wchar_t const *,uint)
.text$mn:0000B6A7                 mov     esp, ebp
.text$mn:0000B6A9                 pop     ebp
.text$mn:0000B6AA                 retn    4
.text$mn:0000B6AA ?compare@?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QBEHPB_W@Z endp
.text$mn:0000B6AA
.text$mn:0000B6AA ; ---------------------------------------------------------------------------
.text$mn:0000B6AD                 align 10h
.text$mn:0000B6AD _text$mn        ends
.text$mn:0000B6AD
.text$mn:0000B6B0 ; ===========================================================================
.text$mn:0000B6B0
.text$mn:0000B6B0 ; Segment type: Pure code
.text$mn:0000B6B0 ; Segment permissions: Read/Execute
.text$mn:0000B6B0 _text$mn        segment para public 'CODE' use32
.text$mn:0000B6B0                 assume cs:_text$mn
.text$mn:0000B6B0                 ;org 0B6B0h
.text$mn:0000B6B0 ; COMDAT (pick any)
.text$mn:0000B6B0                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text$mn:0000B6B0
.text$mn:0000B6B0 ; =============== S U B R O U T I N E =======================================
.text$mn:0000B6B0
.text$mn:0000B6B0 ; Attributes: bp-based frame
.text$mn:0000B6B0
.text$mn:0000B6B0 ; public: static int __cdecl std::char_traits<wchar_t>::compare(wchar_t const *, wchar_t const *, unsigned int)
.text$mn:0000B6B0                 public ?compare@?$char_traits@_W@std@@SAHPB_W0I@Z
.text$mn:0000B6B0 ?compare@?$char_traits@_W@std@@SAHPB_W0I@Z proc near
.text$mn:0000B6B0                                         ; CODE XREF: std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>>::compare(uint,uint,wchar_t const *,uint)+7Fp
.text$mn:0000B6B0                                         ; std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>>::find(wchar_t const *,uint,uint)+CBp ...
.text$mn:0000B6B0
.text$mn:0000B6B0 var_4           = dword ptr -4
.text$mn:0000B6B0 arg_0           = dword ptr  8
.text$mn:0000B6B0 arg_4           = dword ptr  0Ch
.text$mn:0000B6B0 arg_8           = dword ptr  10h
.text$mn:0000B6B0
.text$mn:0000B6B0                 push    ebp
.text$mn:0000B6B1                 mov     ebp, esp
.text$mn:0000B6B3                 push    ecx
.text$mn:0000B6B4                 cmp     [ebp+arg_8], 0
.text$mn:0000B6B8                 jnz     short loc_B6C3
.text$mn:0000B6BA                 mov     [ebp+var_4], 0
.text$mn:0000B6C1                 jmp     short loc_B6DA
.text$mn:0000B6C3 ; ---------------------------------------------------------------------------
.text$mn:0000B6C3
.text$mn:0000B6C3 loc_B6C3:                               ; CODE XREF: std::char_traits<wchar_t>::compare(wchar_t const *,wchar_t const *,uint)+8j
.text$mn:0000B6C3                 mov     eax, [ebp+arg_8]
.text$mn:0000B6C6                 push    eax
.text$mn:0000B6C7                 mov     ecx, [ebp+arg_4]
.text$mn:0000B6CA                 push    ecx
.text$mn:0000B6CB                 mov     edx, [ebp+arg_0]
.text$mn:0000B6CE                 push    edx
.text$mn:0000B6CF                 call    _wmemcmp
.text$mn:0000B6D4                 add     esp, 0Ch
.text$mn:0000B6D7                 mov     [ebp+var_4], eax
.text$mn:0000B6DA
.text$mn:0000B6DA loc_B6DA:                               ; CODE XREF: std::char_traits<wchar_t>::compare(wchar_t const *,wchar_t const *,uint)+11j
.text$mn:0000B6DA                 mov     eax, [ebp+var_4]
.text$mn:0000B6DD                 mov     esp, ebp
.text$mn:0000B6DF                 pop     ebp
.text$mn:0000B6E0                 retn
.text$mn:0000B6E0 ?compare@?$char_traits@_W@std@@SAHPB_W0I@Z endp
.text$mn:0000B6E0
.text$mn:0000B6E0 ; ---------------------------------------------------------------------------
.text$mn:0000B6E1                 align 4
.text$mn:0000B6E1 _text$mn        ends
.text$mn:0000B6E1
.text$mn:0000B6E4 ; ===========================================================================
.text$mn:0000B6E4
.text$mn:0000B6E4 ; Segment type: Pure code
.text$mn:0000B6E4 ; Segment permissions: Read/Execute
.text$mn:0000B6E4 _text$mn        segment para public 'CODE' use32
.text$mn:0000B6E4                 assume cs:_text$mn
.text$mn:0000B6E4                 ;org 0B6E4h
.text$mn:0000B6E4 ; COMDAT (pick any)
.text$mn:0000B6E4                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text$mn:0000B6E4
.text$mn:0000B6E4 ; =============== S U B R O U T I N E =======================================
.text$mn:0000B6E4
.text$mn:0000B6E4 ; Attributes: bp-based frame
.text$mn:0000B6E4
.text$mn:0000B6E4 ; int __cdecl std::char_traits<char>::copy(void *Dst, void *Src, size_t Size)
.text$mn:0000B6E4                 public ?copy@?$char_traits@D@std@@SAPADPADPBDI@Z
.text$mn:0000B6E4 ?copy@?$char_traits@D@std@@SAPADPADPBDI@Z proc near ; CODE XREF: $LN19+1Ep
.text$mn:0000B6E4                                         ; std::basic_string<char,std::char_traits<char>,std::allocator<char>>::_Tidy(bool,uint)+5Dp ...
.text$mn:0000B6E4
.text$mn:0000B6E4 var_4           = dword ptr -4
.text$mn:0000B6E4 Dst             = dword ptr  8
.text$mn:0000B6E4 Src             = dword ptr  0Ch
.text$mn:0000B6E4 Size            = dword ptr  10h
.text$mn:0000B6E4
.text$mn:0000B6E4                 push    ebp
.text$mn:0000B6E5                 mov     ebp, esp
.text$mn:0000B6E7                 push    ecx
.text$mn:0000B6E8                 cmp     [ebp+Size], 0
.text$mn:0000B6EC                 jnz     short loc_B6F6
.text$mn:0000B6EE                 mov     eax, [ebp+Dst]
.text$mn:0000B6F1                 mov     [ebp+var_4], eax
.text$mn:0000B6F4                 jmp     short loc_B70D
.text$mn:0000B6F6 ; ---------------------------------------------------------------------------
.text$mn:0000B6F6
.text$mn:0000B6F6 loc_B6F6:                               ; CODE XREF: std::char_traits<char>::copy(char *,char const *,uint)+8j
.text$mn:0000B6F6                 mov     ecx, [ebp+Size]
.text$mn:0000B6F9                 push    ecx             ; Size
.text$mn:0000B6FA                 mov     edx, [ebp+Src]
.text$mn:0000B6FD                 push    edx             ; Src
.text$mn:0000B6FE                 mov     eax, [ebp+Dst]
.text$mn:0000B701                 push    eax             ; Dst
.text$mn:0000B702                 call    _memcpy
.text$mn:0000B707                 add     esp, 0Ch
.text$mn:0000B70A                 mov     [ebp+var_4], eax
.text$mn:0000B70D
.text$mn:0000B70D loc_B70D:                               ; CODE XREF: std::char_traits<char>::copy(char *,char const *,uint)+10j
.text$mn:0000B70D                 mov     eax, [ebp+var_4]
.text$mn:0000B710                 mov     esp, ebp
.text$mn:0000B712                 pop     ebp
.text$mn:0000B713                 retn
.text$mn:0000B713 ?copy@?$char_traits@D@std@@SAPADPADPBDI@Z endp
.text$mn:0000B713
.text$mn:0000B713 _text$mn        ends
.text$mn:0000B713
.text$mn:0000B714 ; ===========================================================================
.text$mn:0000B714
.text$mn:0000B714 ; Segment type: Pure code
.text$mn:0000B714 ; Segment permissions: Read/Execute
.text$mn:0000B714 _text$mn        segment para public 'CODE' use32
.text$mn:0000B714                 assume cs:_text$mn
.text$mn:0000B714                 ;org 0B714h
.text$mn:0000B714 ; COMDAT (pick any)
.text$mn:0000B714                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text$mn:0000B714
.text$mn:0000B714 ; =============== S U B R O U T I N E =======================================
.text$mn:0000B714
.text$mn:0000B714 ; Attributes: bp-based frame
.text$mn:0000B714
.text$mn:0000B714 ; int __cdecl std::char_traits<wchar_t>::copy(void *Dst, void *Src, int)
.text$mn:0000B714                 public ?copy@?$char_traits@_W@std@@SAPA_WPA_WPB_WI@Z
.text$mn:0000B714 ?copy@?$char_traits@_W@std@@SAPA_WPA_WPB_WI@Z proc near
.text$mn:0000B714                                         ; CODE XREF: $LN19_0+1Ep
.text$mn:0000B714                                         ; std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>>::_Tidy(bool,uint)+5Dp ...
.text$mn:0000B714
.text$mn:0000B714 var_4           = dword ptr -4
.text$mn:0000B714 Dst             = dword ptr  8
.text$mn:0000B714 Src             = dword ptr  0Ch
.text$mn:0000B714 arg_8           = dword ptr  10h
.text$mn:0000B714
.text$mn:0000B714                 push    ebp
.text$mn:0000B715                 mov     ebp, esp
.text$mn:0000B717                 push    ecx
.text$mn:0000B718                 cmp     [ebp+arg_8], 0
.text$mn:0000B71C                 jnz     short loc_B726
.text$mn:0000B71E                 mov     eax, [ebp+Dst]
.text$mn:0000B721                 mov     [ebp+var_4], eax
.text$mn:0000B724                 jmp     short loc_B73D
.text$mn:0000B726 ; ---------------------------------------------------------------------------
.text$mn:0000B726
.text$mn:0000B726 loc_B726:                               ; CODE XREF: std::char_traits<wchar_t>::copy(wchar_t *,wchar_t const *,uint)+8j
.text$mn:0000B726                 mov     ecx, [ebp+arg_8]
.text$mn:0000B729                 push    ecx             ; int
.text$mn:0000B72A                 mov     edx, [ebp+Src]
.text$mn:0000B72D                 push    edx             ; Src
.text$mn:0000B72E                 mov     eax, [ebp+Dst]
.text$mn:0000B731                 push    eax             ; Dst
.text$mn:0000B732                 call    _wmemcpy
.text$mn:0000B737                 add     esp, 0Ch
.text$mn:0000B73A                 mov     [ebp+var_4], eax
.text$mn:0000B73D
.text$mn:0000B73D loc_B73D:                               ; CODE XREF: std::char_traits<wchar_t>::copy(wchar_t *,wchar_t const *,uint)+10j
.text$mn:0000B73D                 mov     eax, [ebp+var_4]
.text$mn:0000B740                 mov     esp, ebp
.text$mn:0000B742                 pop     ebp
.text$mn:0000B743                 retn
.text$mn:0000B743 ?copy@?$char_traits@_W@std@@SAPA_WPA_WPB_WI@Z endp
.text$mn:0000B743
.text$mn:0000B743 _text$mn        ends
.text$mn:0000B743
.text$mn:0000B744 ; ===========================================================================
.text$mn:0000B744
.text$mn:0000B744 ; Segment type: Pure code
.text$mn:0000B744 ; Segment permissions: Read/Execute
.text$mn:0000B744 _text$mn        segment para public 'CODE' use32
.text$mn:0000B744                 assume cs:_text$mn
.text$mn:0000B744                 ;org 0B744h
.text$mn:0000B744 ; COMDAT (pick any)
.text$mn:0000B744                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text$mn:0000B744
.text$mn:0000B744 ; =============== S U B R O U T I N E =======================================
.text$mn:0000B744
.text$mn:0000B744 ; Attributes: bp-based frame
.text$mn:0000B744
.text$mn:0000B744 ; int __stdcall std::_Wrap_alloc<std::allocator<char>>::deallocate(void *, int)
.text$mn:0000B744                 public ?deallocate@?$_Wrap_alloc@V?$allocator@D@std@@@std@@QAEXPADI@Z
.text$mn:0000B744 ?deallocate@?$_Wrap_alloc@V?$allocator@D@std@@@std@@QAEXPADI@Z proc near
.text$mn:0000B744                                         ; CODE XREF: std::basic_string<char,std::char_traits<char>,std::allocator<char>>::_Tidy(bool,uint)+81p
.text$mn:0000B744                                         ; std::vector<char,std::allocator<char>>::_Tidy(void)+52p
.text$mn:0000B744
.text$mn:0000B744 var_4           = dword ptr -4
.text$mn:0000B744 arg_0           = dword ptr  8
.text$mn:0000B744 arg_4           = dword ptr  0Ch
.text$mn:0000B744
.text$mn:0000B744                 push    ebp
.text$mn:0000B745                 mov     ebp, esp
.text$mn:0000B747                 push    ecx
.text$mn:0000B748                 mov     [ebp+var_4], ecx
.text$mn:0000B74B                 mov     eax, [ebp+arg_4]
.text$mn:0000B74E                 push    eax             ; int
.text$mn:0000B74F                 mov     ecx, [ebp+arg_0]
.text$mn:0000B752                 push    ecx             ; void *
.text$mn:0000B753                 mov     ecx, [ebp+var_4]
.text$mn:0000B756                 call    ?deallocate@?$allocator@D@std@@QAEXPADI@Z ; std::allocator<char>::deallocate(char *,uint)
.text$mn:0000B75B                 mov     esp, ebp
.text$mn:0000B75D                 pop     ebp
.text$mn:0000B75E                 retn    8
.text$mn:0000B75E ?deallocate@?$_Wrap_alloc@V?$allocator@D@std@@@std@@QAEXPADI@Z endp
.text$mn:0000B75E
.text$mn:0000B75E ; ---------------------------------------------------------------------------
.text$mn:0000B761                 align 4
.text$mn:0000B761 _text$mn        ends
.text$mn:0000B761
.text$mn:0000B764 ; ===========================================================================
.text$mn:0000B764
.text$mn:0000B764 ; Segment type: Pure code
.text$mn:0000B764 ; Segment permissions: Read/Execute
.text$mn:0000B764 _text$mn        segment para public 'CODE' use32
.text$mn:0000B764                 assume cs:_text$mn
.text$mn:0000B764                 ;org 0B764h
.text$mn:0000B764 ; COMDAT (pick any)
.text$mn:0000B764                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text$mn:0000B764
.text$mn:0000B764 ; =============== S U B R O U T I N E =======================================
.text$mn:0000B764
.text$mn:0000B764 ; Attributes: bp-based frame
.text$mn:0000B764
.text$mn:0000B764 ; int __stdcall std::_Wrap_alloc<std::allocator<std::_Container_proxy>>::deallocate(void *, int)
.text$mn:0000B764                 public ?deallocate@?$_Wrap_alloc@V?$allocator@U_Container_proxy@std@@@std@@@std@@QAEXPAU_Container_proxy@2@I@Z
.text$mn:0000B764 ?deallocate@?$_Wrap_alloc@V?$allocator@U_Container_proxy@std@@@std@@@std@@QAEXPAU_Container_proxy@2@I@Z proc near
.text$mn:0000B764                                         ; CODE XREF: std::_Vector_alloc<0,std::_Vec_base_types<char,std::allocator<char>>>::_Free_proxy(void)+32p
.text$mn:0000B764                                         ; std::_Vector_alloc<0,std::_Vec_base_types<std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>>,std::allocator<std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>>>>>::_Free_proxy(void)+32p ...
.text$mn:0000B764
.text$mn:0000B764 var_4           = dword ptr -4
.text$mn:0000B764 arg_0           = dword ptr  8
.text$mn:0000B764 arg_4           = dword ptr  0Ch
.text$mn:0000B764
.text$mn:0000B764                 push    ebp
.text$mn:0000B765                 mov     ebp, esp
.text$mn:0000B767                 push    ecx
.text$mn:0000B768                 mov     [ebp+var_4], ecx
.text$mn:0000B76B                 mov     eax, [ebp+arg_4]
.text$mn:0000B76E                 push    eax             ; int
.text$mn:0000B76F                 mov     ecx, [ebp+arg_0]
.text$mn:0000B772                 push    ecx             ; void *
.text$mn:0000B773                 mov     ecx, [ebp+var_4]
.text$mn:0000B776                 call    ?deallocate@?$allocator@U_Container_proxy@std@@@std@@QAEXPAU_Container_proxy@2@I@Z ; std::allocator<std::_Container_proxy>::deallocate(std::_Container_proxy *,uint)
.text$mn:0000B77B                 mov     esp, ebp
.text$mn:0000B77D                 pop     ebp
.text$mn:0000B77E                 retn    8
.text$mn:0000B77E ?deallocate@?$_Wrap_alloc@V?$allocator@U_Container_proxy@std@@@std@@@std@@QAEXPAU_Container_proxy@2@I@Z endp
.text$mn:0000B77E
.text$mn:0000B77E ; ---------------------------------------------------------------------------
.text$mn:0000B781                 align 4
.text$mn:0000B781 _text$mn        ends
.text$mn:0000B781
.text$mn:0000B784 ; ===========================================================================
.text$mn:0000B784
.text$mn:0000B784 ; Segment type: Pure code
.text$mn:0000B784 ; Segment permissions: Read/Execute
.text$mn:0000B784 _text$mn        segment para public 'CODE' use32
.text$mn:0000B784                 assume cs:_text$mn
.text$mn:0000B784                 ;org 0B784h
.text$mn:0000B784 ; COMDAT (pick any)
.text$mn:0000B784                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text$mn:0000B784
.text$mn:0000B784 ; =============== S U B R O U T I N E =======================================
.text$mn:0000B784
.text$mn:0000B784 ; Attributes: bp-based frame
.text$mn:0000B784
.text$mn:0000B784 ; int __stdcall std::_Wrap_alloc<std::allocator<std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>>>>::deallocate(void *, int)
.text$mn:0000B784                 public ?deallocate@?$_Wrap_alloc@V?$allocator@V?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@@std@@@std@@QAEXPAV?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@2@I@Z
.text$mn:0000B784 ?deallocate@?$_Wrap_alloc@V?$allocator@V?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@@std@@@std@@QAEXPAV?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@2@I@Z proc near
.text$mn:0000B784                                         ; CODE XREF: __catch$?_Reallocate@?$vector@V?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@V?$allocator@V?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@@2@@std@@IAEXI@Z$0+16p
.text$mn:0000B784                                         ; std::vector<std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>>,std::allocator<std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>>>>::_Reallocate(uint)+FAp ...
.text$mn:0000B784
.text$mn:0000B784 var_4           = dword ptr -4
.text$mn:0000B784 arg_0           = dword ptr  8
.text$mn:0000B784 arg_4           = dword ptr  0Ch
.text$mn:0000B784
.text$mn:0000B784                 push    ebp
.text$mn:0000B785                 mov     ebp, esp
.text$mn:0000B787                 push    ecx
.text$mn:0000B788                 mov     [ebp+var_4], ecx
.text$mn:0000B78B                 mov     eax, [ebp+arg_4]
.text$mn:0000B78E                 push    eax             ; int
.text$mn:0000B78F                 mov     ecx, [ebp+arg_0]
.text$mn:0000B792                 push    ecx             ; void *
.text$mn:0000B793                 mov     ecx, [ebp+var_4]
.text$mn:0000B796                 call    ?deallocate@?$allocator@V?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@@std@@QAEXPAV?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@2@I@Z ; std::allocator<std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>>>::deallocate(std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>> *,uint)
.text$mn:0000B79B                 mov     esp, ebp
.text$mn:0000B79D                 pop     ebp
.text$mn:0000B79E                 retn    8
.text$mn:0000B79E ?deallocate@?$_Wrap_alloc@V?$allocator@V?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@@std@@@std@@QAEXPAV?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@2@I@Z endp
.text$mn:0000B79E
.text$mn:0000B79E ; ---------------------------------------------------------------------------
.text$mn:0000B7A1                 align 4
.text$mn:0000B7A1 _text$mn        ends
.text$mn:0000B7A1
.text$mn:0000B7A4 ; ===========================================================================
.text$mn:0000B7A4
.text$mn:0000B7A4 ; Segment type: Pure code
.text$mn:0000B7A4 ; Segment permissions: Read/Execute
.text$mn:0000B7A4 _text$mn        segment para public 'CODE' use32
.text$mn:0000B7A4                 assume cs:_text$mn
.text$mn:0000B7A4                 ;org 0B7A4h
.text$mn:0000B7A4 ; COMDAT (pick any)
.text$mn:0000B7A4                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text$mn:0000B7A4
.text$mn:0000B7A4 ; =============== S U B R O U T I N E =======================================
.text$mn:0000B7A4
.text$mn:0000B7A4 ; Attributes: bp-based frame
.text$mn:0000B7A4
.text$mn:0000B7A4 ; int __stdcall std::_Wrap_alloc<std::allocator<wchar_t>>::deallocate(void *, int)
.text$mn:0000B7A4                 public ?deallocate@?$_Wrap_alloc@V?$allocator@_W@std@@@std@@QAEXPA_WI@Z
.text$mn:0000B7A4 ?deallocate@?$_Wrap_alloc@V?$allocator@_W@std@@@std@@QAEXPA_WI@Z proc near
.text$mn:0000B7A4                                         ; CODE XREF: __catch$?_Reallocate@?$vector@_WV?$allocator@_W@std@@@std@@IAEXI@Z$0+16p
.text$mn:0000B7A4                                         ; std::vector<wchar_t,std::allocator<wchar_t>>::_Reallocate(uint)+F4p ...
.text$mn:0000B7A4
.text$mn:0000B7A4 var_4           = dword ptr -4
.text$mn:0000B7A4 arg_0           = dword ptr  8
.text$mn:0000B7A4 arg_4           = dword ptr  0Ch
.text$mn:0000B7A4
.text$mn:0000B7A4                 push    ebp
.text$mn:0000B7A5                 mov     ebp, esp
.text$mn:0000B7A7                 push    ecx
.text$mn:0000B7A8                 mov     [ebp+var_4], ecx
.text$mn:0000B7AB                 mov     eax, [ebp+arg_4]
.text$mn:0000B7AE                 push    eax             ; int
.text$mn:0000B7AF                 mov     ecx, [ebp+arg_0]
.text$mn:0000B7B2                 push    ecx             ; void *
.text$mn:0000B7B3                 mov     ecx, [ebp+var_4]
.text$mn:0000B7B6                 call    ?deallocate@?$allocator@_W@std@@QAEXPA_WI@Z ; std::allocator<wchar_t>::deallocate(wchar_t *,uint)
.text$mn:0000B7BB                 mov     esp, ebp
.text$mn:0000B7BD                 pop     ebp
.text$mn:0000B7BE                 retn    8
.text$mn:0000B7BE ?deallocate@?$_Wrap_alloc@V?$allocator@_W@std@@@std@@QAEXPA_WI@Z endp
.text$mn:0000B7BE
.text$mn:0000B7BE ; ---------------------------------------------------------------------------
.text$mn:0000B7C1                 align 4
.text$mn:0000B7C1 _text$mn        ends
.text$mn:0000B7C1
.text$mn:0000B7C4 ; ===========================================================================
.text$mn:0000B7C4
.text$mn:0000B7C4 ; Segment type: Pure code
.text$mn:0000B7C4 ; Segment permissions: Read/Execute
.text$mn:0000B7C4 _text$mn        segment para public 'CODE' use32
.text$mn:0000B7C4                 assume cs:_text$mn
.text$mn:0000B7C4                 ;org 0B7C4h
.text$mn:0000B7C4 ; COMDAT (pick any)
.text$mn:0000B7C4                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text$mn:0000B7C4
.text$mn:0000B7C4 ; =============== S U B R O U T I N E =======================================
.text$mn:0000B7C4
.text$mn:0000B7C4 ; Attributes: bp-based frame
.text$mn:0000B7C4
.text$mn:0000B7C4 ; int __stdcall std::allocator<char>::deallocate(void *, int)
.text$mn:0000B7C4                 public ?deallocate@?$allocator@D@std@@QAEXPADI@Z
.text$mn:0000B7C4 ?deallocate@?$allocator@D@std@@QAEXPADI@Z proc near
.text$mn:0000B7C4                                         ; CODE XREF: std::_Wrap_alloc<std::allocator<char>>::deallocate(char *,uint)+12p
.text$mn:0000B7C4
.text$mn:0000B7C4 var_4           = dword ptr -4
.text$mn:0000B7C4 arg_0           = dword ptr  8
.text$mn:0000B7C4
.text$mn:0000B7C4                 push    ebp
.text$mn:0000B7C5                 mov     ebp, esp
.text$mn:0000B7C7                 push    ecx
.text$mn:0000B7C8                 mov     [ebp+var_4], ecx
.text$mn:0000B7CB                 mov     eax, [ebp+arg_0]
.text$mn:0000B7CE                 push    eax             ; void *
.text$mn:0000B7CF                 call    ??3@YAXPAX@Z    ; operator delete(void *)
.text$mn:0000B7D4                 add     esp, 4
.text$mn:0000B7D7                 mov     esp, ebp
.text$mn:0000B7D9                 pop     ebp
.text$mn:0000B7DA                 retn    8
.text$mn:0000B7DA ?deallocate@?$allocator@D@std@@QAEXPADI@Z endp
.text$mn:0000B7DA
.text$mn:0000B7DA ; ---------------------------------------------------------------------------
.text$mn:0000B7DD                 align 10h
.text$mn:0000B7DD _text$mn        ends
.text$mn:0000B7DD
.text$mn:0000B7E0 ; ===========================================================================
.text$mn:0000B7E0
.text$mn:0000B7E0 ; Segment type: Pure code
.text$mn:0000B7E0 ; Segment permissions: Read/Execute
.text$mn:0000B7E0 _text$mn        segment para public 'CODE' use32
.text$mn:0000B7E0                 assume cs:_text$mn
.text$mn:0000B7E0                 ;org 0B7E0h
.text$mn:0000B7E0 ; COMDAT (pick any)
.text$mn:0000B7E0                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text$mn:0000B7E0
.text$mn:0000B7E0 ; =============== S U B R O U T I N E =======================================
.text$mn:0000B7E0
.text$mn:0000B7E0 ; Attributes: bp-based frame
.text$mn:0000B7E0
.text$mn:0000B7E0 ; int __stdcall std::allocator<std::_Container_proxy>::deallocate(void *, int)
.text$mn:0000B7E0                 public ?deallocate@?$allocator@U_Container_proxy@std@@@std@@QAEXPAU_Container_proxy@2@I@Z
.text$mn:0000B7E0 ?deallocate@?$allocator@U_Container_proxy@std@@@std@@QAEXPAU_Container_proxy@2@I@Z proc near
.text$mn:0000B7E0                                         ; CODE XREF: std::_String_alloc<0,std::_String_base_types<char,std::allocator<char>>>::_Free_proxy(void)+32p
.text$mn:0000B7E0                                         ; std::_String_alloc<0,std::_String_base_types<wchar_t,std::allocator<wchar_t>>>::_Free_proxy(void)+32p ...
.text$mn:0000B7E0
.text$mn:0000B7E0 var_4           = dword ptr -4
.text$mn:0000B7E0 arg_0           = dword ptr  8
.text$mn:0000B7E0
.text$mn:0000B7E0                 push    ebp
.text$mn:0000B7E1                 mov     ebp, esp
.text$mn:0000B7E3                 push    ecx
.text$mn:0000B7E4                 mov     [ebp+var_4], ecx
.text$mn:0000B7E7                 mov     eax, [ebp+arg_0]
.text$mn:0000B7EA                 push    eax             ; void *
.text$mn:0000B7EB                 call    ??3@YAXPAX@Z    ; operator delete(void *)
.text$mn:0000B7F0                 add     esp, 4
.text$mn:0000B7F3                 mov     esp, ebp
.text$mn:0000B7F5                 pop     ebp
.text$mn:0000B7F6                 retn    8
.text$mn:0000B7F6 ?deallocate@?$allocator@U_Container_proxy@std@@@std@@QAEXPAU_Container_proxy@2@I@Z endp
.text$mn:0000B7F6
.text$mn:0000B7F6 ; ---------------------------------------------------------------------------
.text$mn:0000B7F9                 align 4
.text$mn:0000B7F9 _text$mn        ends
.text$mn:0000B7F9
.text$mn:0000B7FC ; ===========================================================================
.text$mn:0000B7FC
.text$mn:0000B7FC ; Segment type: Pure code
.text$mn:0000B7FC ; Segment permissions: Read/Execute
.text$mn:0000B7FC _text$mn        segment para public 'CODE' use32
.text$mn:0000B7FC                 assume cs:_text$mn
.text$mn:0000B7FC                 ;org 0B7FCh
.text$mn:0000B7FC ; COMDAT (pick any)
.text$mn:0000B7FC                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text$mn:0000B7FC
.text$mn:0000B7FC ; =============== S U B R O U T I N E =======================================
.text$mn:0000B7FC
.text$mn:0000B7FC ; Attributes: bp-based frame
.text$mn:0000B7FC
.text$mn:0000B7FC ; int __stdcall std::allocator<std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>>>::deallocate(void *, int)
.text$mn:0000B7FC                 public ?deallocate@?$allocator@V?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@@std@@QAEXPAV?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@2@I@Z
.text$mn:0000B7FC ?deallocate@?$allocator@V?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@@std@@QAEXPAV?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@2@I@Z proc near
.text$mn:0000B7FC                                         ; CODE XREF: std::_Wrap_alloc<std::allocator<std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>>>>::deallocate(std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>> *,uint)+12p
.text$mn:0000B7FC
.text$mn:0000B7FC var_4           = dword ptr -4
.text$mn:0000B7FC arg_0           = dword ptr  8
.text$mn:0000B7FC
.text$mn:0000B7FC                 push    ebp
.text$mn:0000B7FD                 mov     ebp, esp
.text$mn:0000B7FF                 push    ecx
.text$mn:0000B800                 mov     [ebp+var_4], ecx
.text$mn:0000B803                 mov     eax, [ebp+arg_0]
.text$mn:0000B806                 push    eax             ; void *
.text$mn:0000B807                 call    ??3@YAXPAX@Z    ; operator delete(void *)
.text$mn:0000B80C                 add     esp, 4
.text$mn:0000B80F                 mov     esp, ebp
.text$mn:0000B811                 pop     ebp
.text$mn:0000B812                 retn    8
.text$mn:0000B812 ?deallocate@?$allocator@V?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@@std@@QAEXPAV?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@2@I@Z endp
.text$mn:0000B812
.text$mn:0000B812 ; ---------------------------------------------------------------------------
.text$mn:0000B815                 align 4
.text$mn:0000B815 _text$mn        ends
.text$mn:0000B815
.text$mn:0000B818 ; ===========================================================================
.text$mn:0000B818
.text$mn:0000B818 ; Segment type: Pure code
.text$mn:0000B818 ; Segment permissions: Read/Execute
.text$mn:0000B818 _text$mn        segment para public 'CODE' use32
.text$mn:0000B818                 assume cs:_text$mn
.text$mn:0000B818                 ;org 0B818h
.text$mn:0000B818 ; COMDAT (pick any)
.text$mn:0000B818                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text$mn:0000B818
.text$mn:0000B818 ; =============== S U B R O U T I N E =======================================
.text$mn:0000B818
.text$mn:0000B818 ; Attributes: bp-based frame
.text$mn:0000B818
.text$mn:0000B818 ; int __stdcall std::allocator<wchar_t>::deallocate(void *, int)
.text$mn:0000B818                 public ?deallocate@?$allocator@_W@std@@QAEXPA_WI@Z
.text$mn:0000B818 ?deallocate@?$allocator@_W@std@@QAEXPA_WI@Z proc near
.text$mn:0000B818                                         ; CODE XREF: std::_Wrap_alloc<std::allocator<wchar_t>>::deallocate(wchar_t *,uint)+12p
.text$mn:0000B818
.text$mn:0000B818 var_4           = dword ptr -4
.text$mn:0000B818 arg_0           = dword ptr  8
.text$mn:0000B818
.text$mn:0000B818                 push    ebp
.text$mn:0000B819                 mov     ebp, esp
.text$mn:0000B81B                 push    ecx
.text$mn:0000B81C                 mov     [ebp+var_4], ecx
.text$mn:0000B81F                 mov     eax, [ebp+arg_0]
.text$mn:0000B822                 push    eax             ; void *
.text$mn:0000B823                 call    ??3@YAXPAX@Z    ; operator delete(void *)
.text$mn:0000B828                 add     esp, 4
.text$mn:0000B82B                 mov     esp, ebp
.text$mn:0000B82D                 pop     ebp
.text$mn:0000B82E                 retn    8
.text$mn:0000B82E ?deallocate@?$allocator@_W@std@@QAEXPA_WI@Z endp
.text$mn:0000B82E
.text$mn:0000B82E ; ---------------------------------------------------------------------------
.text$mn:0000B831                 align 4
.text$mn:0000B831 _text$mn        ends
.text$mn:0000B831
.text$mn:0000B834 ; ===========================================================================
.text$mn:0000B834
.text$mn:0000B834 ; Segment type: Pure code
.text$mn:0000B834 ; Segment permissions: Read/Execute
.text$mn:0000B834 _text$mn        segment para public 'CODE' use32
.text$mn:0000B834                 assume cs:_text$mn
.text$mn:0000B834                 ;org 0B834h
.text$mn:0000B834 ; COMDAT (pick any)
.text$mn:0000B834                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text$mn:0000B834
.text$mn:0000B834 ; =============== S U B R O U T I N E =======================================
.text$mn:0000B834
.text$mn:0000B834 ; Attributes: bp-based frame
.text$mn:0000B834
.text$mn:0000B834 ; public: virtual class std::error_condition __thiscall std::_System_error_category::default_error_condition(int)const
.text$mn:0000B834                 public ?default_error_condition@_System_error_category@std@@UBE?AVerror_condition@2@H@Z
.text$mn:0000B834 ?default_error_condition@_System_error_category@std@@UBE?AVerror_condition@2@H@Z proc near
.text$mn:0000B834                                         ; DATA XREF: .rdata:0000F41Co
.text$mn:0000B834
.text$mn:0000B834 var_4           = dword ptr -4
.text$mn:0000B834 arg_0           = dword ptr  8
.text$mn:0000B834 arg_4           = dword ptr  0Ch
.text$mn:0000B834
.text$mn:0000B834                 push    ebp
.text$mn:0000B835                 mov     ebp, esp
.text$mn:0000B837                 push    ecx
.text$mn:0000B838                 mov     [ebp+var_4], ecx
.text$mn:0000B83B                 mov     eax, [ebp+arg_4]
.text$mn:0000B83E                 push    eax             ; int
.text$mn:0000B83F                 call    ?_Syserror_map@std@@YAPBDH@Z ; std::_Syserror_map(int)
.text$mn:0000B844                 add     esp, 4
.text$mn:0000B847                 test    eax, eax
.text$mn:0000B849                 jz      short loc_B864
.text$mn:0000B84B                 call    ?generic_category@std@@YAABVerror_category@1@XZ ; std::generic_category(void)
.text$mn:0000B850                 push    eax             ; struct std::error_category *
.text$mn:0000B851                 mov     ecx, [ebp+arg_4]
.text$mn:0000B854                 push    ecx             ; int
.text$mn:0000B855                 mov     ecx, [ebp+arg_0] ; this
.text$mn:0000B858                 call    ??0error_condition@std@@QAE@HABVerror_category@1@@Z ; std::error_condition::error_condition(int,std::error_category const &)
.text$mn:0000B85D                 mov     eax, [ebp+arg_0]
.text$mn:0000B860                 jmp     short loc_B879
.text$mn:0000B862 ; ---------------------------------------------------------------------------
.text$mn:0000B862                 jmp     short loc_B879
.text$mn:0000B864 ; ---------------------------------------------------------------------------
.text$mn:0000B864
.text$mn:0000B864 loc_B864:                               ; CODE XREF: std::_System_error_category::default_error_condition(int)+15j
.text$mn:0000B864                 call    ?system_category@std@@YAABVerror_category@1@XZ ; std::system_category(void)
.text$mn:0000B869                 push    eax             ; struct std::error_category *
.text$mn:0000B86A                 mov     edx, [ebp+arg_4]
.text$mn:0000B86D                 push    edx             ; int
.text$mn:0000B86E                 mov     ecx, [ebp+arg_0] ; this
.text$mn:0000B871                 call    ??0error_condition@std@@QAE@HABVerror_category@1@@Z ; std::error_condition::error_condition(int,std::error_category const &)
.text$mn:0000B876                 mov     eax, [ebp+arg_0]
.text$mn:0000B879
.text$mn:0000B879 loc_B879:                               ; CODE XREF: std::_System_error_category::default_error_condition(int)+2Cj
.text$mn:0000B879                                         ; std::_System_error_category::default_error_condition(int)+2Ej
.text$mn:0000B879                 mov     esp, ebp
.text$mn:0000B87B                 pop     ebp
.text$mn:0000B87C                 retn    8
.text$mn:0000B87C ?default_error_condition@_System_error_category@std@@UBE?AVerror_condition@2@H@Z endp
.text$mn:0000B87C
.text$mn:0000B87C ; ---------------------------------------------------------------------------
.text$mn:0000B87F                 align 10h
.text$mn:0000B87F _text$mn        ends
.text$mn:0000B87F
.text$mn:0000B880 ; ===========================================================================
.text$mn:0000B880
.text$mn:0000B880 ; Segment type: Pure code
.text$mn:0000B880 ; Segment permissions: Read/Execute
.text$mn:0000B880 _text$mn        segment para public 'CODE' use32
.text$mn:0000B880                 assume cs:_text$mn
.text$mn:0000B880                 ;org 0B880h
.text$mn:0000B880 ; COMDAT (pick any)
.text$mn:0000B880                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text$mn:0000B880
.text$mn:0000B880 ; =============== S U B R O U T I N E =======================================
.text$mn:0000B880
.text$mn:0000B880 ; Attributes: bp-based frame
.text$mn:0000B880
.text$mn:0000B880 ; public: virtual class std::error_condition __thiscall std::error_category::default_error_condition(int)const
.text$mn:0000B880                 public ?default_error_condition@error_category@std@@UBE?AVerror_condition@2@H@Z
.text$mn:0000B880 ?default_error_condition@error_category@std@@UBE?AVerror_condition@2@H@Z proc near
.text$mn:0000B880                                         ; DATA XREF: .rdata:0000F38Co
.text$mn:0000B880                                         ; .rdata:0000F3A8o ...
.text$mn:0000B880
.text$mn:0000B880 var_4           = dword ptr -4
.text$mn:0000B880 arg_0           = dword ptr  8
.text$mn:0000B880 arg_4           = dword ptr  0Ch
.text$mn:0000B880
.text$mn:0000B880                 push    ebp
.text$mn:0000B881                 mov     ebp, esp
.text$mn:0000B883                 push    ecx
.text$mn:0000B884                 mov     [ebp+var_4], ecx
.text$mn:0000B887                 mov     eax, [ebp+var_4]
.text$mn:0000B88A                 push    eax             ; struct std::error_category *
.text$mn:0000B88B                 mov     ecx, [ebp+arg_4]
.text$mn:0000B88E                 push    ecx             ; int
.text$mn:0000B88F                 mov     ecx, [ebp+arg_0] ; this
.text$mn:0000B892                 call    ??0error_condition@std@@QAE@HABVerror_category@1@@Z ; std::error_condition::error_condition(int,std::error_category const &)
.text$mn:0000B897                 mov     eax, [ebp+arg_0]
.text$mn:0000B89A                 mov     esp, ebp
.text$mn:0000B89C                 pop     ebp
.text$mn:0000B89D                 retn    8
.text$mn:0000B89D ?default_error_condition@error_category@std@@UBE?AVerror_condition@2@H@Z endp
.text$mn:0000B89D
.text$mn:0000B89D _text$mn        ends
.text$mn:0000B89D
.text$mn:0000B8A0 ; ===========================================================================
.text$mn:0000B8A0
.text$mn:0000B8A0 ; Segment type: Pure code
.text$mn:0000B8A0 ; Segment permissions: Read/Execute
.text$mn:0000B8A0 _text$mn        segment para public 'CODE' use32
.text$mn:0000B8A0                 assume cs:_text$mn
.text$mn:0000B8A0                 ;org 0B8A0h
.text$mn:0000B8A0 ; COMDAT (pick any)
.text$mn:0000B8A0                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text$mn:0000B8A0
.text$mn:0000B8A0 ; =============== S U B R O U T I N E =======================================
.text$mn:0000B8A0
.text$mn:0000B8A0 ; Attributes: bp-based frame
.text$mn:0000B8A0
.text$mn:0000B8A0 ; public: void __thiscall WcharMbcsConvertor::StringBuffer<char>::empty(void)
.text$mn:0000B8A0                 public ?empty@?$StringBuffer@D@WcharMbcsConvertor@@QAEXXZ
.text$mn:0000B8A0 ?empty@?$StringBuffer@D@WcharMbcsConvertor@@QAEXXZ proc near
.text$mn:0000B8A0                                         ; CODE XREF: WcharMbcsConvertor::wchar2char(wchar_t const *,uint,int,int *)+6Ep
.text$mn:0000B8A0                                         ; WcharMbcsConvertor::wchar2char(wchar_t const *,uint,long *,long *)+102p
.text$mn:0000B8A0
.text$mn:0000B8A0 var_4           = dword ptr -4
.text$mn:0000B8A0
.text$mn:0000B8A0                 push    ebp
.text$mn:0000B8A1                 mov     ebp, esp
.text$mn:0000B8A3                 push    ecx
.text$mn:0000B8A4                 mov     [ebp+var_4], ecx
.text$mn:0000B8A7                 mov     eax, [ebp+var_4]
.text$mn:0000B8AA                 cmp     dword ptr [eax], 0
.text$mn:0000B8AD                 jnz     short loc_B8BB
.text$mn:0000B8AF                 mov     ecx, [ebp+var_4]
.text$mn:0000B8B2                 mov     dword ptr [ecx+4], offset ?nullStr@?1??empty@?$StringBuffer@D@WcharMbcsConvertor@@QAEXXZ@4DA ; char `WcharMbcsConvertor::StringBuffer<char>::empty(void)'::`2'::nullStr
.text$mn:0000B8B9                 jmp     short loc_B8CD
.text$mn:0000B8BB ; ---------------------------------------------------------------------------
.text$mn:0000B8BB
.text$mn:0000B8BB loc_B8BB:                               ; CODE XREF: WcharMbcsConvertor::StringBuffer<char>::empty(void)+Dj
.text$mn:0000B8BB                 mov     edx, 1
.text$mn:0000B8C0                 imul    eax, edx, 0
.text$mn:0000B8C3                 mov     ecx, [ebp+var_4]
.text$mn:0000B8C6                 mov     edx, [ecx+4]
.text$mn:0000B8C9                 mov     byte ptr [eax+edx], 0
.text$mn:0000B8CD
.text$mn:0000B8CD loc_B8CD:                               ; CODE XREF: WcharMbcsConvertor::StringBuffer<char>::empty(void)+19j
.text$mn:0000B8CD                 mov     esp, ebp
.text$mn:0000B8CF                 pop     ebp
.text$mn:0000B8D0                 retn
.text$mn:0000B8D0 ?empty@?$StringBuffer@D@WcharMbcsConvertor@@QAEXXZ endp
.text$mn:0000B8D0
.text$mn:0000B8D0 ; ---------------------------------------------------------------------------
.text$mn:0000B8D1                 align 4
.text$mn:0000B8D1 _text$mn        ends
.text$mn:0000B8D1
.text$mn:0000B8D4 ; ===========================================================================
.text$mn:0000B8D4
.text$mn:0000B8D4 ; Segment type: Pure code
.text$mn:0000B8D4 ; Segment permissions: Read/Execute
.text$mn:0000B8D4 _text$mn        segment para public 'CODE' use32
.text$mn:0000B8D4                 assume cs:_text$mn
.text$mn:0000B8D4                 ;org 0B8D4h
.text$mn:0000B8D4 ; COMDAT (pick any)
.text$mn:0000B8D4                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text$mn:0000B8D4
.text$mn:0000B8D4 ; =============== S U B R O U T I N E =======================================
.text$mn:0000B8D4
.text$mn:0000B8D4 ; Attributes: bp-based frame
.text$mn:0000B8D4
.text$mn:0000B8D4 ; public: void __thiscall WcharMbcsConvertor::StringBuffer<wchar_t>::empty(void)
.text$mn:0000B8D4                 public ?empty@?$StringBuffer@_W@WcharMbcsConvertor@@QAEXXZ
.text$mn:0000B8D4 ?empty@?$StringBuffer@_W@WcharMbcsConvertor@@QAEXXZ proc near
.text$mn:0000B8D4                                         ; CODE XREF: WcharMbcsConvertor::char2wchar(char const *,uint,int,int *,int *)+3Bp
.text$mn:0000B8D4                                         ; WcharMbcsConvertor::char2wchar(char const *,uint,int,int *,int *)+1D0p ...
.text$mn:0000B8D4
.text$mn:0000B8D4 var_4           = dword ptr -4
.text$mn:0000B8D4
.text$mn:0000B8D4                 push    ebp
.text$mn:0000B8D5                 mov     ebp, esp
.text$mn:0000B8D7                 push    ecx
.text$mn:0000B8D8                 mov     [ebp+var_4], ecx
.text$mn:0000B8DB                 mov     eax, [ebp+var_4]
.text$mn:0000B8DE                 cmp     dword ptr [eax], 0
.text$mn:0000B8E1                 jnz     short loc_B8EF
.text$mn:0000B8E3                 mov     ecx, [ebp+var_4]
.text$mn:0000B8E6                 mov     dword ptr [ecx+4], offset ?nullStr@?1??empty@?$StringBuffer@_W@WcharMbcsConvertor@@QAEXXZ@4_WA ; wchar_t `WcharMbcsConvertor::StringBuffer<wchar_t>::empty(void)'::`2'::nullStr
.text$mn:0000B8ED                 jmp     short loc_B903
.text$mn:0000B8EF ; ---------------------------------------------------------------------------
.text$mn:0000B8EF
.text$mn:0000B8EF loc_B8EF:                               ; CODE XREF: WcharMbcsConvertor::StringBuffer<wchar_t>::empty(void)+Dj
.text$mn:0000B8EF                 mov     edx, 2
.text$mn:0000B8F4                 imul    eax, edx, 0
.text$mn:0000B8F7                 mov     ecx, [ebp+var_4]
.text$mn:0000B8FA                 mov     edx, [ecx+4]
.text$mn:0000B8FD                 xor     ecx, ecx
.text$mn:0000B8FF                 mov     [eax+edx], cx
.text$mn:0000B903
.text$mn:0000B903 loc_B903:                               ; CODE XREF: WcharMbcsConvertor::StringBuffer<wchar_t>::empty(void)+19j
.text$mn:0000B903                 mov     esp, ebp
.text$mn:0000B905                 pop     ebp
.text$mn:0000B906                 retn
.text$mn:0000B906 ?empty@?$StringBuffer@_W@WcharMbcsConvertor@@QAEXXZ endp
.text$mn:0000B906
.text$mn:0000B906 ; ---------------------------------------------------------------------------
.text$mn:0000B907                 align 4
.text$mn:0000B907 _text$mn        ends
.text$mn:0000B907
.text$mn:0000B908 ; ===========================================================================
.text$mn:0000B908
.text$mn:0000B908 ; Segment type: Pure code
.text$mn:0000B908 ; Segment permissions: Read/Execute
.text$mn:0000B908 _text$mn        segment para public 'CODE' use32
.text$mn:0000B908                 assume cs:_text$mn
.text$mn:0000B908                 ;org 0B908h
.text$mn:0000B908 ; COMDAT (pick any)
.text$mn:0000B908                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text$mn:0000B908
.text$mn:0000B908 ; =============== S U B R O U T I N E =======================================
.text$mn:0000B908
.text$mn:0000B908 ; Attributes: bp-based frame
.text$mn:0000B908
.text$mn:0000B908 ; public: class std::_String_iterator<class std::_String_val<struct std::_Simple_types<wchar_t>>> __thiscall std::basic_string<wchar_t, struct std::char_traits<wchar_t>, class std::allocator<wchar_t>>::end(void)
.text$mn:0000B908                 public ?end@?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QAE?AV?$_String_iterator@V?$_String_val@U?$_Simple_types@_W@std@@@std@@@2@XZ
.text$mn:0000B908 ?end@?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QAE?AV?$_String_iterator@V?$_String_val@U?$_Simple_types@_W@std@@@std@@@2@XZ proc near
.text$mn:0000B908                                         ; CODE XREF: stringToUpper(std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>>)+62p
.text$mn:0000B908                                         ; std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>>::push_back(wchar_t)+34p
.text$mn:0000B908
.text$mn:0000B908 var_14          = dword ptr -14h
.text$mn:0000B908 var_10          = dword ptr -10h
.text$mn:0000B908 var_C           = dword ptr -0Ch
.text$mn:0000B908 var_4           = dword ptr -4
.text$mn:0000B908 arg_0           = dword ptr  8
.text$mn:0000B908
.text$mn:0000B908                 push    ebp
.text$mn:0000B909                 mov     ebp, esp
.text$mn:0000B90B                 push    0FFFFFFFFh
.text$mn:0000B90D                 push    offset __ehhandler$?end@?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QAE?AV?$_String_iterator@V?$_String_val@U?$_Simple_types@_W@std@@@std@@@2@XZ
.text$mn:0000B912                 mov     eax, large fs:0
.text$mn:0000B918                 push    eax
.text$mn:0000B919                 sub     esp, 8
.text$mn:0000B91C                 mov     eax, dword ptr ds:___security_cookie
.text$mn:0000B921                 xor     eax, ebp
.text$mn:0000B923                 push    eax
.text$mn:0000B924                 lea     eax, [ebp+var_C]
.text$mn:0000B927                 mov     large fs:0, eax
.text$mn:0000B92D                 mov     [ebp+var_10], ecx
.text$mn:0000B930                 mov     [ebp+var_14], 0
.text$mn:0000B937                 mov     eax, [ebp+var_10]
.text$mn:0000B93A                 push    eax             ; struct std::_Container_base12 *
.text$mn:0000B93B                 mov     ecx, [ebp+var_10]
.text$mn:0000B93E                 call    ?_Myptr@?$_String_val@U?$_Simple_types@_W@std@@@std@@QAEPA_WXZ ; std::_String_val<std::_Simple_types<wchar_t>>::_Myptr(void)
.text$mn:0000B943                 mov     ecx, [ebp+var_10]
.text$mn:0000B946                 mov     edx, [ecx+14h]
.text$mn:0000B949                 lea     eax, [eax+edx*2]
.text$mn:0000B94C                 push    eax             ; int
.text$mn:0000B94D                 mov     ecx, [ebp+arg_0]
.text$mn:0000B950                 call    ??0?$_String_iterator@V?$_String_val@U?$_Simple_types@_W@std@@@std@@@std@@QAE@PA_WPBU_Container_base12@1@@Z ; std::_String_iterator<std::_String_val<std::_Simple_types<wchar_t>>>::_String_iterator<std::_String_val<std::_Simple_types<wchar_t>>>(wchar_t *,std::_Container_base12 const *)
.text$mn:0000B955                 mov     [ebp+var_4], 0
.text$mn:0000B95C                 mov     ecx, [ebp+var_14]
.text$mn:0000B95F                 or      ecx, 1
.text$mn:0000B962                 mov     [ebp+var_14], ecx
.text$mn:0000B965                 mov     eax, [ebp+arg_0]
.text$mn:0000B968                 mov     ecx, [ebp+var_C]
.text$mn:0000B96B                 mov     large fs:0, ecx
.text$mn:0000B972                 pop     ecx
.text$mn:0000B973                 mov     esp, ebp
.text$mn:0000B975                 pop     ebp
.text$mn:0000B976                 retn    4
.text$mn:0000B976 ?end@?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QAE?AV?$_String_iterator@V?$_String_val@U?$_Simple_types@_W@std@@@std@@@2@XZ endp
.text$mn:0000B976
.text$mn:0000B976 ; ---------------------------------------------------------------------------
.text$mn:0000B979                 align 4
.text$mn:0000B979 _text$mn        ends
.text$mn:0000B979
.text$x:0000B97C ; ===========================================================================
.text$x:0000B97C
.text$x:0000B97C ; Segment type: Pure code
.text$x:0000B97C ; Segment permissions: Read/Execute
.text$x:0000B97C _text$x         segment para public 'CODE' use32
.text$x:0000B97C                 assume cs:_text$x
.text$x:0000B97C                 ;org 0B97Ch
.text$x:0000B97C ; COMDAT (pick associative to section at B908)
.text$x:0000B97C                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text$x:0000B97C
.text$x:0000B97C ; =============== S U B R O U T I N E =======================================
.text$x:0000B97C
.text$x:0000B97C
.text$x:0000B97C __unwindfunclet$?end@?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QAE?AV?$_String_iterator@V?$_String_val@U?$_Simple_types@_W@std@@@std@@@2@XZ$0 proc near
.text$x:0000B97C                                         ; DATA XREF: .xdata$x:0000DBA4o
.text$x:0000B97C                 mov     eax, [ebp-14h]
.text$x:0000B97F                 and     eax, 1
.text$x:0000B982                 jz      $LN4_1
.text$x:0000B988                 and     dword ptr [ebp-14h], 0FFFFFFFEh
.text$x:0000B98C                 mov     ecx, [ebp+8]
.text$x:0000B98F                 jmp     ??1?$_String_iterator@V?$_String_val@U?$_Simple_types@_W@std@@@std@@@std@@QAE@XZ ; std::_String_iterator<std::_String_val<std::_Simple_types<wchar_t>>>::~_String_iterator<std::_String_val<std::_Simple_types<wchar_t>>>(void)
.text$x:0000B994 ; ---------------------------------------------------------------------------
.text$x:0000B994
.text$x:0000B994 $LN4_1:                                 ; CODE XREF: __unwindfunclet$?end@?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QAE?AV?$_String_iterator@V?$_String_val@U?$_Simple_types@_W@std@@@std@@@2@XZ$0+6j
.text$x:0000B994                 retn
.text$x:0000B994 __unwindfunclet$?end@?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QAE?AV?$_String_iterator@V?$_String_val@U?$_Simple_types@_W@std@@@std@@@2@XZ$0 endp
.text$x:0000B994
.text$x:0000B995
.text$x:0000B995 ; =============== S U B R O U T I N E =======================================
.text$x:0000B995
.text$x:0000B995
.text$x:0000B995 __ehhandler$?end@?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QAE?AV?$_String_iterator@V?$_String_val@U?$_Simple_types@_W@std@@@std@@@2@XZ proc near
.text$x:0000B995                                         ; DATA XREF: std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>>::end(void)+5o
.text$x:0000B995
.text$x:0000B995 arg_4           = dword ptr  8
.text$x:0000B995
.text$x:0000B995                 mov     edx, [esp+arg_4]
.text$x:0000B999                 lea     eax, [edx+0Ch]
.text$x:0000B99C                 mov     ecx, [edx-0Ch]
.text$x:0000B99F                 xor     ecx, eax
.text$x:0000B9A1                 call    @__security_check_cookie@4 ; __security_check_cookie(x)
.text$x:0000B9A6                 mov     eax, offset __ehfuncinfo$?end@?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QAE?AV?$_String_iterator@V?$_String_val@U?$_Simple_types@_W@std@@@std@@@2@XZ
.text$x:0000B9AB                 jmp     ___CxxFrameHandler3
.text$x:0000B9AB __ehhandler$?end@?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QAE?AV?$_String_iterator@V?$_String_val@U?$_Simple_types@_W@std@@@std@@@2@XZ endp
.text$x:0000B9AB
.text$x:0000B9AB _text$x         ends
.text$x:0000B9AB
.text$mn:0000B9B0 ; ===========================================================================
.text$mn:0000B9B0
.text$mn:0000B9B0 ; Segment type: Pure code
.text$mn:0000B9B0 ; Segment permissions: Read/Execute
.text$mn:0000B9B0 _text$mn        segment para public 'CODE' use32
.text$mn:0000B9B0                 assume cs:_text$mn
.text$mn:0000B9B0                 ;org 0B9B0h
.text$mn:0000B9B0 ; COMDAT (pick any)
.text$mn:0000B9B0                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text$mn:0000B9B0
.text$mn:0000B9B0 ; =============== S U B R O U T I N E =======================================
.text$mn:0000B9B0
.text$mn:0000B9B0 ; Attributes: bp-based frame
.text$mn:0000B9B0
.text$mn:0000B9B0 ; public: class std::_String_const_iterator<class std::_String_val<struct std::_Simple_types<wchar_t>>> __thiscall std::basic_string<wchar_t, struct std::char_traits<wchar_t>, class std::allocator<wchar_t>>::end(void)const
.text$mn:0000B9B0                 public ?end@?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QBE?AV?$_String_const_iterator@V?$_String_val@U?$_Simple_types@_W@std@@@std@@@2@XZ
.text$mn:0000B9B0 ?end@?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QBE?AV?$_String_const_iterator@V?$_String_val@U?$_Simple_types@_W@std@@@std@@@2@XZ proc near
.text$mn:0000B9B0                                         ; CODE XREF: BuildMenuFileName(int,uint,std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>> const &)+26Dp
.text$mn:0000B9B0                                         ; BuildMenuFileName(int,uint,std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>> const &)+2E9p ...
.text$mn:0000B9B0
.text$mn:0000B9B0 var_14          = dword ptr -14h
.text$mn:0000B9B0 var_10          = dword ptr -10h
.text$mn:0000B9B0 var_C           = dword ptr -0Ch
.text$mn:0000B9B0 var_4           = dword ptr -4
.text$mn:0000B9B0 arg_0           = dword ptr  8
.text$mn:0000B9B0
.text$mn:0000B9B0                 push    ebp
.text$mn:0000B9B1                 mov     ebp, esp
.text$mn:0000B9B3                 push    0FFFFFFFFh
.text$mn:0000B9B5                 push    offset __ehhandler$?end@?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QBE?AV?$_String_const_iterator@V?$_String_val@U?$_Simple_types@_W@std@@@std@@@2@XZ
.text$mn:0000B9BA                 mov     eax, large fs:0
.text$mn:0000B9C0                 push    eax
.text$mn:0000B9C1                 sub     esp, 8
.text$mn:0000B9C4                 mov     eax, dword ptr ds:___security_cookie
.text$mn:0000B9C9                 xor     eax, ebp
.text$mn:0000B9CB                 push    eax
.text$mn:0000B9CC                 lea     eax, [ebp+var_C]
.text$mn:0000B9CF                 mov     large fs:0, eax
.text$mn:0000B9D5                 mov     [ebp+var_10], ecx
.text$mn:0000B9D8                 mov     [ebp+var_14], 0
.text$mn:0000B9DF                 mov     eax, [ebp+var_10]
.text$mn:0000B9E2                 push    eax             ; struct std::_Container_base12 *
.text$mn:0000B9E3                 mov     ecx, [ebp+var_10]
.text$mn:0000B9E6                 call    ?_Myptr@?$_String_val@U?$_Simple_types@_W@std@@@std@@QBEPB_WXZ ; std::_String_val<std::_Simple_types<wchar_t>>::_Myptr(void)
.text$mn:0000B9EB                 mov     ecx, [ebp+var_10]
.text$mn:0000B9EE                 mov     edx, [ecx+14h]
.text$mn:0000B9F1                 lea     eax, [eax+edx*2]
.text$mn:0000B9F4                 push    eax             ; int
.text$mn:0000B9F5                 mov     ecx, [ebp+arg_0]
.text$mn:0000B9F8                 call    ??0?$_String_const_iterator@V?$_String_val@U?$_Simple_types@_W@std@@@std@@@std@@QAE@PB_WPBU_Container_base12@1@@Z ; std::_String_const_iterator<std::_String_val<std::_Simple_types<wchar_t>>>::_String_const_iterator<std::_String_val<std::_Simple_types<wchar_t>>>(wchar_t const *,std::_Container_base12 const *)
.text$mn:0000B9FD                 mov     [ebp+var_4], 0
.text$mn:0000BA04                 mov     ecx, [ebp+var_14]
.text$mn:0000BA07                 or      ecx, 1
.text$mn:0000BA0A                 mov     [ebp+var_14], ecx
.text$mn:0000BA0D                 mov     eax, [ebp+arg_0]
.text$mn:0000BA10                 mov     ecx, [ebp+var_C]
.text$mn:0000BA13                 mov     large fs:0, ecx
.text$mn:0000BA1A                 pop     ecx
.text$mn:0000BA1B                 mov     esp, ebp
.text$mn:0000BA1D                 pop     ebp
.text$mn:0000BA1E                 retn    4
.text$mn:0000BA1E ?end@?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QBE?AV?$_String_const_iterator@V?$_String_val@U?$_Simple_types@_W@std@@@std@@@2@XZ endp
.text$mn:0000BA1E
.text$mn:0000BA1E ; ---------------------------------------------------------------------------
.text$mn:0000BA21                 align 4
.text$mn:0000BA21 _text$mn        ends
.text$mn:0000BA21
.text$x:0000BA24 ; ===========================================================================
.text$x:0000BA24
.text$x:0000BA24 ; Segment type: Pure code
.text$x:0000BA24 ; Segment permissions: Read/Execute
.text$x:0000BA24 _text$x         segment para public 'CODE' use32
.text$x:0000BA24                 assume cs:_text$x
.text$x:0000BA24                 ;org 0BA24h
.text$x:0000BA24 ; COMDAT (pick associative to section at B9B0)
.text$x:0000BA24                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text$x:0000BA24
.text$x:0000BA24 ; =============== S U B R O U T I N E =======================================
.text$x:0000BA24
.text$x:0000BA24
.text$x:0000BA24 __unwindfunclet$?end@?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QBE?AV?$_String_const_iterator@V?$_String_val@U?$_Simple_types@_W@std@@@std@@@2@XZ$0 proc near
.text$x:0000BA24                                         ; DATA XREF: .xdata$x:0000DBD0o
.text$x:0000BA24                 mov     eax, [ebp-14h]
.text$x:0000BA27                 and     eax, 1
.text$x:0000BA2A                 jz      $LN4_2
.text$x:0000BA30                 and     dword ptr [ebp-14h], 0FFFFFFFEh
.text$x:0000BA34                 mov     ecx, [ebp+8]
.text$x:0000BA37                 jmp     ??1?$_String_const_iterator@V?$_String_val@U?$_Simple_types@_W@std@@@std@@@std@@QAE@XZ ; std::_String_const_iterator<std::_String_val<std::_Simple_types<wchar_t>>>::~_String_const_iterator<std::_String_val<std::_Simple_types<wchar_t>>>(void)
.text$x:0000BA3C ; ---------------------------------------------------------------------------
.text$x:0000BA3C
.text$x:0000BA3C $LN4_2:                                 ; CODE XREF: __unwindfunclet$?end@?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QBE?AV?$_String_const_iterator@V?$_String_val@U?$_Simple_types@_W@std@@@std@@@2@XZ$0+6j
.text$x:0000BA3C                 retn
.text$x:0000BA3C __unwindfunclet$?end@?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QBE?AV?$_String_const_iterator@V?$_String_val@U?$_Simple_types@_W@std@@@std@@@2@XZ$0 endp
.text$x:0000BA3C
.text$x:0000BA3D
.text$x:0000BA3D ; =============== S U B R O U T I N E =======================================
.text$x:0000BA3D
.text$x:0000BA3D
.text$x:0000BA3D __ehhandler$?end@?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QBE?AV?$_String_const_iterator@V?$_String_val@U?$_Simple_types@_W@std@@@std@@@2@XZ proc near
.text$x:0000BA3D                                         ; DATA XREF: std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>>::end(void)+5o
.text$x:0000BA3D
.text$x:0000BA3D arg_4           = dword ptr  8
.text$x:0000BA3D
.text$x:0000BA3D                 mov     edx, [esp+arg_4]
.text$x:0000BA41                 lea     eax, [edx+0Ch]
.text$x:0000BA44                 mov     ecx, [edx-0Ch]
.text$x:0000BA47                 xor     ecx, eax
.text$x:0000BA49                 call    @__security_check_cookie@4 ; __security_check_cookie(x)
.text$x:0000BA4E                 mov     eax, offset __ehfuncinfo$?end@?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QBE?AV?$_String_const_iterator@V?$_String_val@U?$_Simple_types@_W@std@@@std@@@2@XZ
.text$x:0000BA53                 jmp     ___CxxFrameHandler3
.text$x:0000BA53 __ehhandler$?end@?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QBE?AV?$_String_const_iterator@V?$_String_val@U?$_Simple_types@_W@std@@@std@@@2@XZ endp
.text$x:0000BA53
.text$x:0000BA53 _text$x         ends
.text$x:0000BA53
.text$mn:0000BA58 ; ===========================================================================
.text$mn:0000BA58
.text$mn:0000BA58 ; Segment type: Pure code
.text$mn:0000BA58 ; Segment permissions: Read/Execute
.text$mn:0000BA58 _text$mn        segment para public 'CODE' use32
.text$mn:0000BA58                 assume cs:_text$mn
.text$mn:0000BA58                 ;org 0BA58h
.text$mn:0000BA58 ; COMDAT (pick any)
.text$mn:0000BA58                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text$mn:0000BA58
.text$mn:0000BA58 ; =============== S U B R O U T I N E =======================================
.text$mn:0000BA58
.text$mn:0000BA58 ; Attributes: bp-based frame
.text$mn:0000BA58
.text$mn:0000BA58 ; public: class std::_Vector_iterator<class std::_Vector_val<struct std::_Simple_types<wchar_t>>> __thiscall std::vector<wchar_t, class std::allocator<wchar_t>>::end(void)
.text$mn:0000BA58                 public ?end@?$vector@_WV?$allocator@_W@std@@@std@@QAE?AV?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@_W@std@@@std@@@2@XZ
.text$mn:0000BA58 ?end@?$vector@_WV?$allocator@_W@std@@@std@@QAE?AV?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@_W@std@@@std@@@2@XZ proc near
.text$mn:0000BA58                                         ; CODE XREF: std::vector<wchar_t,std::allocator<wchar_t>>::rbegin(void)+3Bp
.text$mn:0000BA58
.text$mn:0000BA58 var_14          = dword ptr -14h
.text$mn:0000BA58 var_10          = dword ptr -10h
.text$mn:0000BA58 var_C           = dword ptr -0Ch
.text$mn:0000BA58 var_4           = dword ptr -4
.text$mn:0000BA58 arg_0           = dword ptr  8
.text$mn:0000BA58
.text$mn:0000BA58                 push    ebp
.text$mn:0000BA59                 mov     ebp, esp
.text$mn:0000BA5B                 push    0FFFFFFFFh
.text$mn:0000BA5D                 push    offset __ehhandler$?end@?$vector@_WV?$allocator@_W@std@@@std@@QAE?AV?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@_W@std@@@std@@@2@XZ
.text$mn:0000BA62                 mov     eax, large fs:0
.text$mn:0000BA68                 push    eax
.text$mn:0000BA69                 sub     esp, 8
.text$mn:0000BA6C                 mov     eax, dword ptr ds:___security_cookie
.text$mn:0000BA71                 xor     eax, ebp
.text$mn:0000BA73                 push    eax
.text$mn:0000BA74                 lea     eax, [ebp+var_C]
.text$mn:0000BA77                 mov     large fs:0, eax
.text$mn:0000BA7D                 mov     [ebp+var_10], ecx
.text$mn:0000BA80                 mov     [ebp+var_14], 0
.text$mn:0000BA87                 mov     eax, [ebp+var_10]
.text$mn:0000BA8A                 push    eax             ; struct std::_Container_base12 *
.text$mn:0000BA8B                 mov     ecx, [ebp+var_10]
.text$mn:0000BA8E                 mov     edx, [ecx+8]
.text$mn:0000BA91                 push    edx             ; int
.text$mn:0000BA92                 mov     ecx, [ebp+arg_0]
.text$mn:0000BA95                 call    ??0?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@_W@std@@@std@@@std@@QAE@PA_WPBU_Container_base12@1@@Z ; std::_Vector_iterator<std::_Vector_val<std::_Simple_types<wchar_t>>>::_Vector_iterator<std::_Vector_val<std::_Simple_types<wchar_t>>>(wchar_t *,std::_Container_base12 const *)
.text$mn:0000BA9A                 mov     [ebp+var_4], 0
.text$mn:0000BAA1                 mov     eax, [ebp+var_14]
.text$mn:0000BAA4                 or      eax, 1
.text$mn:0000BAA7                 mov     [ebp+var_14], eax
.text$mn:0000BAAA                 mov     eax, [ebp+arg_0]
.text$mn:0000BAAD                 mov     ecx, [ebp+var_C]
.text$mn:0000BAB0                 mov     large fs:0, ecx
.text$mn:0000BAB7                 pop     ecx
.text$mn:0000BAB8                 mov     esp, ebp
.text$mn:0000BABA                 pop     ebp
.text$mn:0000BABB                 retn    4
.text$mn:0000BABB ?end@?$vector@_WV?$allocator@_W@std@@@std@@QAE?AV?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@_W@std@@@std@@@2@XZ endp
.text$mn:0000BABB
.text$mn:0000BABB ; ---------------------------------------------------------------------------
.text$mn:0000BABE                 align 10h
.text$mn:0000BABE _text$mn        ends
.text$mn:0000BABE
.text$x:0000BAC0 ; ===========================================================================
.text$x:0000BAC0
.text$x:0000BAC0 ; Segment type: Pure code
.text$x:0000BAC0 ; Segment permissions: Read/Execute
.text$x:0000BAC0 _text$x         segment para public 'CODE' use32
.text$x:0000BAC0                 assume cs:_text$x
.text$x:0000BAC0                 ;org 0BAC0h
.text$x:0000BAC0 ; COMDAT (pick associative to section at BA58)
.text$x:0000BAC0                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text$x:0000BAC0
.text$x:0000BAC0 ; =============== S U B R O U T I N E =======================================
.text$x:0000BAC0
.text$x:0000BAC0
.text$x:0000BAC0 __unwindfunclet$?end@?$vector@_WV?$allocator@_W@std@@@std@@QAE?AV?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@_W@std@@@std@@@2@XZ$0 proc near
.text$x:0000BAC0                                         ; DATA XREF: .xdata$x:0000E550o
.text$x:0000BAC0                 mov     eax, [ebp-14h]
.text$x:0000BAC3                 and     eax, 1
.text$x:0000BAC6                 jz      $LN4_5
.text$x:0000BACC                 and     dword ptr [ebp-14h], 0FFFFFFFEh
.text$x:0000BAD0                 mov     ecx, [ebp+8]
.text$x:0000BAD3                 jmp     ??1?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@_W@std@@@std@@@std@@QAE@XZ ; std::_Vector_iterator<std::_Vector_val<std::_Simple_types<wchar_t>>>::~_Vector_iterator<std::_Vector_val<std::_Simple_types<wchar_t>>>(void)
.text$x:0000BAD8 ; ---------------------------------------------------------------------------
.text$x:0000BAD8
.text$x:0000BAD8 $LN4_5:                                 ; CODE XREF: __unwindfunclet$?end@?$vector@_WV?$allocator@_W@std@@@std@@QAE?AV?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@_W@std@@@std@@@2@XZ$0+6j
.text$x:0000BAD8                 retn
.text$x:0000BAD8 __unwindfunclet$?end@?$vector@_WV?$allocator@_W@std@@@std@@QAE?AV?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@_W@std@@@std@@@2@XZ$0 endp
.text$x:0000BAD8
.text$x:0000BAD9
.text$x:0000BAD9 ; =============== S U B R O U T I N E =======================================
.text$x:0000BAD9
.text$x:0000BAD9
.text$x:0000BAD9 __ehhandler$?end@?$vector@_WV?$allocator@_W@std@@@std@@QAE?AV?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@_W@std@@@std@@@2@XZ proc near
.text$x:0000BAD9                                         ; DATA XREF: std::vector<wchar_t,std::allocator<wchar_t>>::end(void)+5o
.text$x:0000BAD9
.text$x:0000BAD9 arg_4           = dword ptr  8
.text$x:0000BAD9
.text$x:0000BAD9                 mov     edx, [esp+arg_4]
.text$x:0000BADD                 lea     eax, [edx+0Ch]
.text$x:0000BAE0                 mov     ecx, [edx-0Ch]
.text$x:0000BAE3                 xor     ecx, eax
.text$x:0000BAE5                 call    @__security_check_cookie@4 ; __security_check_cookie(x)
.text$x:0000BAEA                 mov     eax, offset __ehfuncinfo$?end@?$vector@_WV?$allocator@_W@std@@@std@@QAE?AV?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@_W@std@@@std@@@2@XZ
.text$x:0000BAEF                 jmp     ___CxxFrameHandler3
.text$x:0000BAEF __ehhandler$?end@?$vector@_WV?$allocator@_W@std@@@std@@QAE?AV?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@_W@std@@@std@@@2@XZ endp
.text$x:0000BAEF
.text$x:0000BAEF _text$x         ends
.text$x:0000BAEF
.text$mn:0000BAF4 ; ===========================================================================
.text$mn:0000BAF4
.text$mn:0000BAF4 ; Segment type: Pure code
.text$mn:0000BAF4 ; Segment permissions: Read/Execute
.text$mn:0000BAF4 _text$mn        segment para public 'CODE' use32
.text$mn:0000BAF4                 assume cs:_text$mn
.text$mn:0000BAF4                 ;org 0BAF4h
.text$mn:0000BAF4 ; COMDAT (pick any)
.text$mn:0000BAF4                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text$mn:0000BAF4
.text$mn:0000BAF4 ; =============== S U B R O U T I N E =======================================
.text$mn:0000BAF4
.text$mn:0000BAF4 ; Attributes: bp-based frame
.text$mn:0000BAF4
.text$mn:0000BAF4 ; public: static bool __cdecl std::char_traits<wchar_t>::eq(wchar_t const &, wchar_t const &)
.text$mn:0000BAF4                 public ?eq@?$char_traits@_W@std@@SA_NAB_W0@Z
.text$mn:0000BAF4 ?eq@?$char_traits@_W@std@@SA_NAB_W0@Z proc near
.text$mn:0000BAF4                                         ; CODE XREF: std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>>::rfind(wchar_t const *,uint,uint)+A4p
.text$mn:0000BAF4
.text$mn:0000BAF4 var_4           = dword ptr -4
.text$mn:0000BAF4 arg_0           = dword ptr  8
.text$mn:0000BAF4 arg_4           = dword ptr  0Ch
.text$mn:0000BAF4
.text$mn:0000BAF4                 push    ebp
.text$mn:0000BAF5                 mov     ebp, esp
.text$mn:0000BAF7                 push    ecx
.text$mn:0000BAF8                 mov     eax, [ebp+arg_0]
.text$mn:0000BAFB                 movzx   ecx, word ptr [eax]
.text$mn:0000BAFE                 mov     edx, [ebp+arg_4]
.text$mn:0000BB01                 movzx   eax, word ptr [edx]
.text$mn:0000BB04                 cmp     ecx, eax
.text$mn:0000BB06                 jnz     short loc_BB11
.text$mn:0000BB08                 mov     [ebp+var_4], 1
.text$mn:0000BB0F                 jmp     short loc_BB18
.text$mn:0000BB11 ; ---------------------------------------------------------------------------
.text$mn:0000BB11
.text$mn:0000BB11 loc_BB11:                               ; CODE XREF: std::char_traits<wchar_t>::eq(wchar_t const &,wchar_t const &)+12j
.text$mn:0000BB11                 mov     [ebp+var_4], 0
.text$mn:0000BB18
.text$mn:0000BB18 loc_BB18:                               ; CODE XREF: std::char_traits<wchar_t>::eq(wchar_t const &,wchar_t const &)+1Bj
.text$mn:0000BB18                 mov     al, byte ptr [ebp+var_4]
.text$mn:0000BB1B                 mov     esp, ebp
.text$mn:0000BB1D                 pop     ebp
.text$mn:0000BB1E                 retn
.text$mn:0000BB1E ?eq@?$char_traits@_W@std@@SA_NAB_W0@Z endp
.text$mn:0000BB1E
.text$mn:0000BB1E ; ---------------------------------------------------------------------------
.text$mn:0000BB1F                 align 10h
.text$mn:0000BB1F _text$mn        ends
.text$mn:0000BB1F
.text$mn:0000BB20 ; ===========================================================================
.text$mn:0000BB20
.text$mn:0000BB20 ; Segment type: Pure code
.text$mn:0000BB20 ; Segment permissions: Read/Execute
.text$mn:0000BB20 _text$mn        segment para public 'CODE' use32
.text$mn:0000BB20                 assume cs:_text$mn
.text$mn:0000BB20                 ;org 0BB20h
.text$mn:0000BB20 ; COMDAT (pick any)
.text$mn:0000BB20                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text$mn:0000BB20
.text$mn:0000BB20 ; =============== S U B R O U T I N E =======================================
.text$mn:0000BB20
.text$mn:0000BB20 ; Attributes: bp-based frame
.text$mn:0000BB20
.text$mn:0000BB20 ; bool __thiscall std::error_category::equivalent(std::error_category *this, const struct std::error_code *, int)
.text$mn:0000BB20                 public ?equivalent@error_category@std@@UBE_NABVerror_code@2@H@Z
.text$mn:0000BB20 ?equivalent@error_category@std@@UBE_NABVerror_code@2@H@Z proc near
.text$mn:0000BB20                                         ; DATA XREF: .rdata:0000F390o
.text$mn:0000BB20                                         ; .rdata:0000F3ACo ...
.text$mn:0000BB20
.text$mn:0000BB20 var_8           = dword ptr -8
.text$mn:0000BB20 var_4           = dword ptr -4
.text$mn:0000BB20 arg_0           = dword ptr  8
.text$mn:0000BB20 arg_4           = dword ptr  0Ch
.text$mn:0000BB20
.text$mn:0000BB20                 push    ebp
.text$mn:0000BB21                 mov     ebp, esp
.text$mn:0000BB23                 sub     esp, 8
.text$mn:0000BB26                 mov     [ebp+var_8], ecx
.text$mn:0000BB29                 mov     ecx, [ebp+arg_0] ; this
.text$mn:0000BB2C                 call    ?category@error_code@std@@QBEABVerror_category@2@XZ ; std::error_code::category(void)
.text$mn:0000BB31                 push    eax
.text$mn:0000BB32                 mov     ecx, [ebp+var_8]
.text$mn:0000BB35                 call    ??8error_category@std@@QBE_NABV01@@Z ; std::error_category::operator==(std::error_category const &)
.text$mn:0000BB3A                 movzx   eax, al
.text$mn:0000BB3D                 test    eax, eax
.text$mn:0000BB3F                 jz      short loc_BB57
.text$mn:0000BB41                 mov     ecx, [ebp+arg_0] ; this
.text$mn:0000BB44                 call    ?value@error_code@std@@QBEHXZ ; std::error_code::value(void)
.text$mn:0000BB49                 cmp     eax, [ebp+arg_4]
.text$mn:0000BB4C                 jnz     short loc_BB57
.text$mn:0000BB4E                 mov     [ebp+var_4], 1
.text$mn:0000BB55                 jmp     short loc_BB5E
.text$mn:0000BB57 ; ---------------------------------------------------------------------------
.text$mn:0000BB57
.text$mn:0000BB57 loc_BB57:                               ; CODE XREF: std::error_category::equivalent(std::error_code const &,int)+1Fj
.text$mn:0000BB57                                         ; std::error_category::equivalent(std::error_code const &,int)+2Cj
.text$mn:0000BB57                 mov     [ebp+var_4], 0
.text$mn:0000BB5E
.text$mn:0000BB5E loc_BB5E:                               ; CODE XREF: std::error_category::equivalent(std::error_code const &,int)+35j
.text$mn:0000BB5E                 mov     al, byte ptr [ebp+var_4]
.text$mn:0000BB61                 mov     esp, ebp
.text$mn:0000BB63                 pop     ebp
.text$mn:0000BB64                 retn    8
.text$mn:0000BB64 ?equivalent@error_category@std@@UBE_NABVerror_code@2@H@Z endp
.text$mn:0000BB64
.text$mn:0000BB64 ; ---------------------------------------------------------------------------
.text$mn:0000BB67                 align 4
.text$mn:0000BB67 _text$mn        ends
.text$mn:0000BB67
.text$mn:0000BB68 ; ===========================================================================
.text$mn:0000BB68
.text$mn:0000BB68 ; Segment type: Pure code
.text$mn:0000BB68 ; Segment permissions: Read/Execute
.text$mn:0000BB68 _text$mn        segment para public 'CODE' use32
.text$mn:0000BB68                 assume cs:_text$mn
.text$mn:0000BB68                 ;org 0BB68h
.text$mn:0000BB68 ; COMDAT (pick any)
.text$mn:0000BB68                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text$mn:0000BB68
.text$mn:0000BB68 ; =============== S U B R O U T I N E =======================================
.text$mn:0000BB68
.text$mn:0000BB68 ; Attributes: bp-based frame
.text$mn:0000BB68
.text$mn:0000BB68 ; bool __thiscall std::error_category::equivalent(std::error_category *this, int, const struct std::error_condition *)
.text$mn:0000BB68                 public ?equivalent@error_category@std@@UBE_NHABVerror_condition@2@@Z
.text$mn:0000BB68 ?equivalent@error_category@std@@UBE_NHABVerror_condition@2@@Z proc near
.text$mn:0000BB68                                         ; DATA XREF: .rdata:0000F394o
.text$mn:0000BB68                                         ; .rdata:0000F3B0o ...
.text$mn:0000BB68
.text$mn:0000BB68 var_C           = byte ptr -0Ch
.text$mn:0000BB68 var_4           = dword ptr -4
.text$mn:0000BB68 arg_0           = dword ptr  8
.text$mn:0000BB68 arg_4           = dword ptr  0Ch
.text$mn:0000BB68
.text$mn:0000BB68                 push    ebp
.text$mn:0000BB69                 mov     ebp, esp
.text$mn:0000BB6B                 sub     esp, 0Ch
.text$mn:0000BB6E                 mov     [ebp+var_4], ecx
.text$mn:0000BB71                 mov     eax, [ebp+arg_4]
.text$mn:0000BB74                 push    eax             ; std::error_condition *
.text$mn:0000BB75                 mov     ecx, [ebp+arg_0]
.text$mn:0000BB78                 push    ecx
.text$mn:0000BB79                 lea     edx, [ebp+var_C]
.text$mn:0000BB7C                 push    edx
.text$mn:0000BB7D                 mov     eax, [ebp+var_4]
.text$mn:0000BB80                 mov     edx, [eax]
.text$mn:0000BB82                 mov     ecx, [ebp+var_4]
.text$mn:0000BB85                 mov     eax, [edx+0Ch]
.text$mn:0000BB88                 call    eax
.text$mn:0000BB8A                 mov     ecx, eax
.text$mn:0000BB8C                 call    ??8error_condition@std@@QBE_NABV01@@Z ; std::error_condition::operator==(std::error_condition const &)
.text$mn:0000BB91                 mov     esp, ebp
.text$mn:0000BB93                 pop     ebp
.text$mn:0000BB94                 retn    8
.text$mn:0000BB94 ?equivalent@error_category@std@@UBE_NHABVerror_condition@2@@Z endp
.text$mn:0000BB94
.text$mn:0000BB94 ; ---------------------------------------------------------------------------
.text$mn:0000BB97                 align 4
.text$mn:0000BB97 _text$mn        ends
.text$mn:0000BB97
.text$mn:0000BB98 ; ===========================================================================
.text$mn:0000BB98
.text$mn:0000BB98 ; Segment type: Pure code
.text$mn:0000BB98 ; Segment permissions: Read/Execute
.text$mn:0000BB98 _text$mn        segment para public 'CODE' use32
.text$mn:0000BB98                 assume cs:_text$mn
.text$mn:0000BB98                 ;org 0BB98h
.text$mn:0000BB98 ; COMDAT (pick any)
.text$mn:0000BB98                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text$mn:0000BB98
.text$mn:0000BB98 ; =============== S U B R O U T I N E =======================================
.text$mn:0000BB98
.text$mn:0000BB98 ; Attributes: bp-based frame
.text$mn:0000BB98
.text$mn:0000BB98 ; public: class std::basic_string<char, struct std::char_traits<char>, class std::allocator<char>> & __thiscall std::basic_string<char, struct std::char_traits<char>, class std::allocator<char>>::erase(unsigned int)
.text$mn:0000BB98                 public ?erase@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV12@I@Z
.text$mn:0000BB98 ?erase@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV12@I@Z proc near
.text$mn:0000BB98                                         ; CODE XREF: std::basic_string<char,std::char_traits<char>,std::allocator<char>>::assign(std::basic_string<char,std::char_traits<char>,std::allocator<char>> const &,uint,uint)+4Cp
.text$mn:0000BB98
.text$mn:0000BB98 var_4           = dword ptr -4
.text$mn:0000BB98 arg_0           = dword ptr  8
.text$mn:0000BB98
.text$mn:0000BB98                 push    ebp
.text$mn:0000BB99                 mov     ebp, esp
.text$mn:0000BB9B                 push    ecx
.text$mn:0000BB9C                 mov     [ebp+var_4], ecx
.text$mn:0000BB9F                 mov     eax, [ebp+var_4]
.text$mn:0000BBA2                 mov     ecx, [eax+14h]
.text$mn:0000BBA5                 cmp     ecx, [ebp+arg_0]
.text$mn:0000BBA8                 jnb     short loc_BBB2
.text$mn:0000BBAA                 mov     ecx, [ebp+var_4]
.text$mn:0000BBAD                 call    ?_Xran@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QBEXXZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char>>::_Xran(void)
.text$mn:0000BBB2
.text$mn:0000BBB2 loc_BBB2:                               ; CODE XREF: std::basic_string<char,std::char_traits<char>,std::allocator<char>>::erase(uint)+10j
.text$mn:0000BBB2                 mov     edx, [ebp+arg_0]
.text$mn:0000BBB5                 push    edx
.text$mn:0000BBB6                 mov     ecx, [ebp+var_4]
.text$mn:0000BBB9                 call    ?_Eos@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEXI@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char>>::_Eos(uint)
.text$mn:0000BBBE                 mov     eax, [ebp+var_4]
.text$mn:0000BBC1                 mov     esp, ebp
.text$mn:0000BBC3                 pop     ebp
.text$mn:0000BBC4                 retn    4
.text$mn:0000BBC4 ?erase@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV12@I@Z endp
.text$mn:0000BBC4
.text$mn:0000BBC4 ; ---------------------------------------------------------------------------
.text$mn:0000BBC7                 align 4
.text$mn:0000BBC7 _text$mn        ends
.text$mn:0000BBC7
.text$mn:0000BBC8 ; ===========================================================================
.text$mn:0000BBC8
.text$mn:0000BBC8 ; Segment type: Pure code
.text$mn:0000BBC8 ; Segment permissions: Read/Execute
.text$mn:0000BBC8 _text$mn        segment para public 'CODE' use32
.text$mn:0000BBC8                 assume cs:_text$mn
.text$mn:0000BBC8                 ;org 0BBC8h
.text$mn:0000BBC8 ; COMDAT (pick any)
.text$mn:0000BBC8                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text$mn:0000BBC8
.text$mn:0000BBC8 ; =============== S U B R O U T I N E =======================================
.text$mn:0000BBC8
.text$mn:0000BBC8 ; Attributes: bp-based frame
.text$mn:0000BBC8
.text$mn:0000BBC8 ; public: class std::basic_string<char, struct std::char_traits<char>, class std::allocator<char>> & __thiscall std::basic_string<char, struct std::char_traits<char>, class std::allocator<char>>::erase(unsigned int, unsigned int)
.text$mn:0000BBC8                 public ?erase@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV12@II@Z
.text$mn:0000BBC8 ?erase@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV12@II@Z proc near
.text$mn:0000BBC8                                         ; CODE XREF: std::basic_string<char,std::char_traits<char>,std::allocator<char>>::assign(std::basic_string<char,std::char_traits<char>,std::allocator<char>> const &,uint,uint)+5Ap
.text$mn:0000BBC8
.text$mn:0000BBC8 var_C           = dword ptr -0Ch
.text$mn:0000BBC8 Dst             = dword ptr -8
.text$mn:0000BBC8 var_4           = dword ptr -4
.text$mn:0000BBC8 arg_0           = dword ptr  8
.text$mn:0000BBC8 arg_4           = dword ptr  0Ch
.text$mn:0000BBC8
.text$mn:0000BBC8                 push    ebp
.text$mn:0000BBC9                 mov     ebp, esp
.text$mn:0000BBCB                 sub     esp, 0Ch
.text$mn:0000BBCE                 mov     [ebp+var_4], ecx
.text$mn:0000BBD1                 mov     eax, [ebp+var_4]
.text$mn:0000BBD4                 mov     ecx, [eax+14h]
.text$mn:0000BBD7                 cmp     ecx, [ebp+arg_0]
.text$mn:0000BBDA                 jnb     short loc_BBE4
.text$mn:0000BBDC                 mov     ecx, [ebp+var_4]
.text$mn:0000BBDF                 call    ?_Xran@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QBEXXZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char>>::_Xran(void)
.text$mn:0000BBE4
.text$mn:0000BBE4 loc_BBE4:                               ; CODE XREF: std::basic_string<char,std::char_traits<char>,std::allocator<char>>::erase(uint,uint)+12j
.text$mn:0000BBE4                 mov     edx, [ebp+var_4]
.text$mn:0000BBE7                 mov     eax, [edx+14h]
.text$mn:0000BBEA                 sub     eax, [ebp+arg_0]
.text$mn:0000BBED                 cmp     eax, [ebp+arg_4]
.text$mn:0000BBF0                 ja      short loc_BC00
.text$mn:0000BBF2                 mov     ecx, [ebp+arg_0]
.text$mn:0000BBF5                 push    ecx
.text$mn:0000BBF6                 mov     ecx, [ebp+var_4]
.text$mn:0000BBF9                 call    ?_Eos@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEXI@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char>>::_Eos(uint)
.text$mn:0000BBFE                 jmp     short loc_BC46
.text$mn:0000BC00 ; ---------------------------------------------------------------------------
.text$mn:0000BC00
.text$mn:0000BC00 loc_BC00:                               ; CODE XREF: std::basic_string<char,std::char_traits<char>,std::allocator<char>>::erase(uint,uint)+28j
.text$mn:0000BC00                 cmp     [ebp+arg_4], 0
.text$mn:0000BC04                 jbe     short loc_BC46
.text$mn:0000BC06                 mov     ecx, [ebp+var_4]
.text$mn:0000BC09                 call    ?_Myptr@?$_String_val@U?$_Simple_types@D@std@@@std@@QAEPADXZ ; std::_String_val<std::_Simple_types<char>>::_Myptr(void)
.text$mn:0000BC0E                 add     eax, [ebp+arg_0]
.text$mn:0000BC11                 mov     [ebp+Dst], eax
.text$mn:0000BC14                 mov     edx, [ebp+var_4]
.text$mn:0000BC17                 mov     eax, [edx+14h]
.text$mn:0000BC1A                 sub     eax, [ebp+arg_4]
.text$mn:0000BC1D                 mov     [ebp+var_C], eax
.text$mn:0000BC20                 mov     ecx, [ebp+var_C]
.text$mn:0000BC23                 sub     ecx, [ebp+arg_0]
.text$mn:0000BC26                 push    ecx             ; Size
.text$mn:0000BC27                 mov     edx, [ebp+Dst]
.text$mn:0000BC2A                 add     edx, [ebp+arg_4]
.text$mn:0000BC2D                 push    edx             ; Src
.text$mn:0000BC2E                 mov     eax, [ebp+Dst]
.text$mn:0000BC31                 push    eax             ; Dst
.text$mn:0000BC32                 call    ?move@?$char_traits@D@std@@SAPADPADPBDI@Z ; std::char_traits<char>::move(char *,char const *,uint)
.text$mn:0000BC37                 add     esp, 0Ch
.text$mn:0000BC3A                 mov     ecx, [ebp+var_C]
.text$mn:0000BC3D                 push    ecx
.text$mn:0000BC3E                 mov     ecx, [ebp+var_4]
.text$mn:0000BC41                 call    ?_Eos@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEXI@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char>>::_Eos(uint)
.text$mn:0000BC46
.text$mn:0000BC46 loc_BC46:                               ; CODE XREF: std::basic_string<char,std::char_traits<char>,std::allocator<char>>::erase(uint,uint)+36j
.text$mn:0000BC46                                         ; std::basic_string<char,std::char_traits<char>,std::allocator<char>>::erase(uint,uint)+3Cj
.text$mn:0000BC46                 mov     eax, [ebp+var_4]
.text$mn:0000BC49                 mov     esp, ebp
.text$mn:0000BC4B                 pop     ebp
.text$mn:0000BC4C                 retn    8
.text$mn:0000BC4C ?erase@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV12@II@Z endp
.text$mn:0000BC4C
.text$mn:0000BC4C ; ---------------------------------------------------------------------------
.text$mn:0000BC4F                 align 10h
.text$mn:0000BC4F _text$mn        ends
.text$mn:0000BC4F
.text$mn:0000BC50 ; ===========================================================================
.text$mn:0000BC50
.text$mn:0000BC50 ; Segment type: Pure code
.text$mn:0000BC50 ; Segment permissions: Read/Execute
.text$mn:0000BC50 _text$mn        segment para public 'CODE' use32
.text$mn:0000BC50                 assume cs:_text$mn
.text$mn:0000BC50                 ;org 0BC50h
.text$mn:0000BC50 ; COMDAT (pick any)
.text$mn:0000BC50                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text$mn:0000BC50
.text$mn:0000BC50 ; =============== S U B R O U T I N E =======================================
.text$mn:0000BC50
.text$mn:0000BC50 ; Attributes: bp-based frame
.text$mn:0000BC50
.text$mn:0000BC50 ; public: class std::basic_string<wchar_t, struct std::char_traits<wchar_t>, class std::allocator<wchar_t>> & __thiscall std::basic_string<wchar_t, struct std::char_traits<wchar_t>, class std::allocator<wchar_t>>::erase(unsigned int)
.text$mn:0000BC50                 public ?erase@?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QAEAAV12@I@Z
.text$mn:0000BC50 ?erase@?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QAEAAV12@I@Z proc near
.text$mn:0000BC50                                         ; CODE XREF: PathRemoveFileSpecW(std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>> &)+6Ep
.text$mn:0000BC50                                         ; PathRemoveFileSpecW(std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>> &)+7Ap ...
.text$mn:0000BC50
.text$mn:0000BC50 var_4           = dword ptr -4
.text$mn:0000BC50 arg_0           = dword ptr  8
.text$mn:0000BC50
.text$mn:0000BC50                 push    ebp
.text$mn:0000BC51                 mov     ebp, esp
.text$mn:0000BC53                 push    ecx
.text$mn:0000BC54                 mov     [ebp+var_4], ecx
.text$mn:0000BC57                 mov     eax, [ebp+var_4]
.text$mn:0000BC5A                 mov     ecx, [eax+14h]
.text$mn:0000BC5D                 cmp     ecx, [ebp+arg_0]
.text$mn:0000BC60                 jnb     short loc_BC6A
.text$mn:0000BC62                 mov     ecx, [ebp+var_4]
.text$mn:0000BC65                 call    ?_Xran@?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QBEXXZ ; std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>>::_Xran(void)
.text$mn:0000BC6A
.text$mn:0000BC6A loc_BC6A:                               ; CODE XREF: std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>>::erase(uint)+10j
.text$mn:0000BC6A                 mov     edx, [ebp+arg_0]
.text$mn:0000BC6D                 push    edx
.text$mn:0000BC6E                 mov     ecx, [ebp+var_4]
.text$mn:0000BC71                 call    ?_Eos@?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QAEXI@Z ; std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>>::_Eos(uint)
.text$mn:0000BC76                 mov     eax, [ebp+var_4]
.text$mn:0000BC79                 mov     esp, ebp
.text$mn:0000BC7B                 pop     ebp
.text$mn:0000BC7C                 retn    4
.text$mn:0000BC7C ?erase@?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QAEAAV12@I@Z endp
.text$mn:0000BC7C
.text$mn:0000BC7C ; ---------------------------------------------------------------------------
.text$mn:0000BC7F                 align 10h
.text$mn:0000BC7F _text$mn        ends
.text$mn:0000BC7F
.text$mn:0000BC80 ; ===========================================================================
.text$mn:0000BC80
.text$mn:0000BC80 ; Segment type: Pure code
.text$mn:0000BC80 ; Segment permissions: Read/Execute
.text$mn:0000BC80 _text$mn        segment para public 'CODE' use32
.text$mn:0000BC80                 assume cs:_text$mn
.text$mn:0000BC80                 ;org 0BC80h
.text$mn:0000BC80 ; COMDAT (pick any)
.text$mn:0000BC80                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text$mn:0000BC80
.text$mn:0000BC80 ; =============== S U B R O U T I N E =======================================
.text$mn:0000BC80
.text$mn:0000BC80 ; Attributes: bp-based frame
.text$mn:0000BC80
.text$mn:0000BC80 ; public: class std::basic_string<wchar_t, struct std::char_traits<wchar_t>, class std::allocator<wchar_t>> & __thiscall std::basic_string<wchar_t, struct std::char_traits<wchar_t>, class std::allocator<wchar_t>>::erase(unsigned int, unsigned int)
.text$mn:0000BC80                 public ?erase@?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QAEAAV12@II@Z
.text$mn:0000BC80 ?erase@?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QAEAAV12@II@Z proc near
.text$mn:0000BC80                                         ; CODE XREF: PathAppendW(std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>> &,std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>> const &)+142p
.text$mn:0000BC80                                         ; std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>>::assign(std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>> const &,uint,uint)+5Ap
.text$mn:0000BC80
.text$mn:0000BC80 var_C           = dword ptr -0Ch
.text$mn:0000BC80 Dst             = dword ptr -8
.text$mn:0000BC80 var_4           = dword ptr -4
.text$mn:0000BC80 arg_0           = dword ptr  8
.text$mn:0000BC80 arg_4           = dword ptr  0Ch
.text$mn:0000BC80
.text$mn:0000BC80                 push    ebp
.text$mn:0000BC81                 mov     ebp, esp
.text$mn:0000BC83                 sub     esp, 0Ch
.text$mn:0000BC86                 mov     [ebp+var_4], ecx
.text$mn:0000BC89                 mov     eax, [ebp+var_4]
.text$mn:0000BC8C                 mov     ecx, [eax+14h]
.text$mn:0000BC8F                 cmp     ecx, [ebp+arg_0]
.text$mn:0000BC92                 jnb     short loc_BC9C
.text$mn:0000BC94                 mov     ecx, [ebp+var_4]
.text$mn:0000BC97                 call    ?_Xran@?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QBEXXZ ; std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>>::_Xran(void)
.text$mn:0000BC9C
.text$mn:0000BC9C loc_BC9C:                               ; CODE XREF: std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>>::erase(uint,uint)+12j
.text$mn:0000BC9C                 mov     edx, [ebp+var_4]
.text$mn:0000BC9F                 mov     eax, [edx+14h]
.text$mn:0000BCA2                 sub     eax, [ebp+arg_0]
.text$mn:0000BCA5                 cmp     eax, [ebp+arg_4]
.text$mn:0000BCA8                 ja      short loc_BCB8
.text$mn:0000BCAA                 mov     ecx, [ebp+arg_0]
.text$mn:0000BCAD                 push    ecx
.text$mn:0000BCAE                 mov     ecx, [ebp+var_4]
.text$mn:0000BCB1                 call    ?_Eos@?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QAEXI@Z ; std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>>::_Eos(uint)
.text$mn:0000BCB6                 jmp     short loc_BD04
.text$mn:0000BCB8 ; ---------------------------------------------------------------------------
.text$mn:0000BCB8
.text$mn:0000BCB8 loc_BCB8:                               ; CODE XREF: std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>>::erase(uint,uint)+28j
.text$mn:0000BCB8                 cmp     [ebp+arg_4], 0
.text$mn:0000BCBC                 jbe     short loc_BD04
.text$mn:0000BCBE                 mov     ecx, [ebp+var_4]
.text$mn:0000BCC1                 call    ?_Myptr@?$_String_val@U?$_Simple_types@_W@std@@@std@@QAEPA_WXZ ; std::_String_val<std::_Simple_types<wchar_t>>::_Myptr(void)
.text$mn:0000BCC6                 mov     edx, [ebp+arg_0]
.text$mn:0000BCC9                 lea     eax, [eax+edx*2]
.text$mn:0000BCCC                 mov     [ebp+Dst], eax
.text$mn:0000BCCF                 mov     ecx, [ebp+var_4]
.text$mn:0000BCD2                 mov     edx, [ecx+14h]
.text$mn:0000BCD5                 sub     edx, [ebp+arg_4]
.text$mn:0000BCD8                 mov     [ebp+var_C], edx
.text$mn:0000BCDB                 mov     eax, [ebp+var_C]
.text$mn:0000BCDE                 sub     eax, [ebp+arg_0]
.text$mn:0000BCE1                 push    eax             ; int
.text$mn:0000BCE2                 mov     ecx, [ebp+arg_4]
.text$mn:0000BCE5                 mov     edx, [ebp+Dst]
.text$mn:0000BCE8                 lea     eax, [edx+ecx*2]
.text$mn:0000BCEB                 push    eax             ; Src
.text$mn:0000BCEC                 mov     ecx, [ebp+Dst]
.text$mn:0000BCEF                 push    ecx             ; Dst
.text$mn:0000BCF0                 call    ?move@?$char_traits@_W@std@@SAPA_WPA_WPB_WI@Z ; std::char_traits<wchar_t>::move(wchar_t *,wchar_t const *,uint)
.text$mn:0000BCF5                 add     esp, 0Ch
.text$mn:0000BCF8                 mov     edx, [ebp+var_C]
.text$mn:0000BCFB                 push    edx
.text$mn:0000BCFC                 mov     ecx, [ebp+var_4]
.text$mn:0000BCFF                 call    ?_Eos@?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QAEXI@Z ; std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>>::_Eos(uint)
.text$mn:0000BD04
.text$mn:0000BD04 loc_BD04:                               ; CODE XREF: std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>>::erase(uint,uint)+36j
.text$mn:0000BD04                                         ; std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>>::erase(uint,uint)+3Cj
.text$mn:0000BD04                 mov     eax, [ebp+var_4]
.text$mn:0000BD07                 mov     esp, ebp
.text$mn:0000BD09                 pop     ebp
.text$mn:0000BD0A                 retn    8
.text$mn:0000BD0A ?erase@?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QAEAAV12@II@Z endp
.text$mn:0000BD0A
.text$mn:0000BD0A ; ---------------------------------------------------------------------------
.text$mn:0000BD0D                 align 10h
.text$mn:0000BD0D _text$mn        ends
.text$mn:0000BD0D
.text$mn:0000BD10 ; ===========================================================================
.text$mn:0000BD10
.text$mn:0000BD10 ; Segment type: Pure code
.text$mn:0000BD10 ; Segment permissions: Read/Execute
.text$mn:0000BD10 _text$mn        segment para public 'CODE' use32
.text$mn:0000BD10                 assume cs:_text$mn
.text$mn:0000BD10                 ;org 0BD10h
.text$mn:0000BD10 ; COMDAT (pick any)
.text$mn:0000BD10                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text$mn:0000BD10
.text$mn:0000BD10 ; =============== S U B R O U T I N E =======================================
.text$mn:0000BD10
.text$mn:0000BD10 ; Attributes: bp-based frame
.text$mn:0000BD10
.text$mn:0000BD10 ; public: unsigned int __thiscall std::basic_string<wchar_t, struct std::char_traits<wchar_t>, class std::allocator<wchar_t>>::find(class std::basic_string<wchar_t, struct std::char_traits<wchar_t>, class std::allocator<wchar_t>> const &, unsigned int)const
.text$mn:0000BD10                 public ?find@?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QBEIABV12@I@Z
.text$mn:0000BD10 ?find@?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QBEIABV12@I@Z proc near
.text$mn:0000BD10                                         ; CODE XREF: stringReplace(std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>>,std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>> const &,std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>> const &)+45p
.text$mn:0000BD10                                         ; stringSplit(std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>> const &,std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>> const &)+3Fp ...
.text$mn:0000BD10
.text$mn:0000BD10 var_4           = dword ptr -4
.text$mn:0000BD10 arg_0           = dword ptr  8
.text$mn:0000BD10 arg_4           = dword ptr  0Ch
.text$mn:0000BD10
.text$mn:0000BD10                 push    ebp
.text$mn:0000BD11                 mov     ebp, esp
.text$mn:0000BD13                 push    ecx
.text$mn:0000BD14                 mov     [ebp+var_4], ecx
.text$mn:0000BD17                 mov     ecx, [ebp+arg_0]
.text$mn:0000BD1A                 call    ?size@?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QBEIXZ ; std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>>::size(void)
.text$mn:0000BD1F                 push    eax
.text$mn:0000BD20                 mov     eax, [ebp+arg_4]
.text$mn:0000BD23                 push    eax
.text$mn:0000BD24                 mov     ecx, [ebp+arg_0]
.text$mn:0000BD27                 call    ?_Myptr@?$_String_val@U?$_Simple_types@_W@std@@@std@@QBEPB_WXZ ; std::_String_val<std::_Simple_types<wchar_t>>::_Myptr(void)
.text$mn:0000BD2C                 push    eax
.text$mn:0000BD2D                 mov     ecx, [ebp+var_4]
.text$mn:0000BD30                 call    ?find@?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QBEIPB_WII@Z ; std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>>::find(wchar_t const *,uint,uint)
.text$mn:0000BD35                 mov     esp, ebp
.text$mn:0000BD37                 pop     ebp
.text$mn:0000BD38                 retn    8
.text$mn:0000BD38 ?find@?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QBEIABV12@I@Z endp
.text$mn:0000BD38
.text$mn:0000BD38 ; ---------------------------------------------------------------------------
.text$mn:0000BD3B                 align 4
.text$mn:0000BD3B _text$mn        ends
.text$mn:0000BD3B
.text$mn:0000BD3C ; ===========================================================================
.text$mn:0000BD3C
.text$mn:0000BD3C ; Segment type: Pure code
.text$mn:0000BD3C ; Segment permissions: Read/Execute
.text$mn:0000BD3C _text$mn        segment para public 'CODE' use32
.text$mn:0000BD3C                 assume cs:_text$mn
.text$mn:0000BD3C                 ;org 0BD3Ch
.text$mn:0000BD3C ; COMDAT (pick any)
.text$mn:0000BD3C                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text$mn:0000BD3C
.text$mn:0000BD3C ; =============== S U B R O U T I N E =======================================
.text$mn:0000BD3C
.text$mn:0000BD3C ; Attributes: bp-based frame
.text$mn:0000BD3C
.text$mn:0000BD3C ; public: unsigned int __thiscall std::basic_string<wchar_t, struct std::char_traits<wchar_t>, class std::allocator<wchar_t>>::find(wchar_t const *, unsigned int, unsigned int)const
.text$mn:0000BD3C                 public ?find@?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QBEIPB_WII@Z
.text$mn:0000BD3C ?find@?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QBEIPB_WII@Z proc near
.text$mn:0000BD3C                                         ; CODE XREF: std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>>::find(std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>> const &,uint)+20p
.text$mn:0000BD3C                                         ; std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>>::find_first_of(wchar_t,uint)+14p
.text$mn:0000BD3C
.text$mn:0000BD3C var_10          = dword ptr -10h
.text$mn:0000BD3C var_C           = dword ptr -0Ch
.text$mn:0000BD3C var_8           = dword ptr -8
.text$mn:0000BD3C var_4           = dword ptr -4
.text$mn:0000BD3C arg_0           = dword ptr  8
.text$mn:0000BD3C arg_4           = dword ptr  0Ch
.text$mn:0000BD3C arg_8           = dword ptr  10h
.text$mn:0000BD3C
.text$mn:0000BD3C                 push    ebp
.text$mn:0000BD3D                 mov     ebp, esp
.text$mn:0000BD3F                 sub     esp, 10h
.text$mn:0000BD42                 mov     [ebp+var_8], ecx
.text$mn:0000BD45                 cmp     [ebp+arg_8], 0
.text$mn:0000BD49                 jz      short loc_BD61
.text$mn:0000BD4B                 push    768h            ; unsigned int
.text$mn:0000BD50                 push    offset ??_C@_1IO@FEAPGJBD@?$AAC?$AA?3?$AA?2?$AAP?$AAr?$AAo?$AAg?$AAr?$AAa?$AAm?$AA?5?$AAF?$AAi?$AAl?$AAe?$AAs?$AA?5?$AA?$CI?$AAx?$AA8?$AA6?$AA?$CJ?$AA?2?$AAM?$AAi?$AAc?$AAr?$AAo?$AAs?$AAo?$AAf?$AAt@ ; "C:\\Program Files (x86)\\Microsoft Visu"...
.text$mn:0000BD55                 mov     eax, [ebp+arg_0]
.text$mn:0000BD58                 push    eax             ; int
.text$mn:0000BD59                 call    ??$_Debug_pointer@_W@std@@YAXPB_W0I@Z ; std::_Debug_pointer<wchar_t>(wchar_t const *,wchar_t const *,uint)
.text$mn:0000BD5E                 add     esp, 0Ch
.text$mn:0000BD61
.text$mn:0000BD61 loc_BD61:                               ; CODE XREF: std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>>::find(wchar_t const *,uint,uint)+Dj
.text$mn:0000BD61                 cmp     [ebp+arg_8], 0
.text$mn:0000BD65                 jnz     short loc_BD7A
.text$mn:0000BD67                 mov     ecx, [ebp+var_8]
.text$mn:0000BD6A                 mov     edx, [ebp+arg_4]
.text$mn:0000BD6D                 cmp     edx, [ecx+14h]
.text$mn:0000BD70                 ja      short loc_BD7A
.text$mn:0000BD72                 mov     eax, [ebp+arg_4]
.text$mn:0000BD75                 jmp     loc_BE2D
.text$mn:0000BD7A ; ---------------------------------------------------------------------------
.text$mn:0000BD7A
.text$mn:0000BD7A loc_BD7A:                               ; CODE XREF: std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>>::find(wchar_t const *,uint,uint)+29j
.text$mn:0000BD7A                                         ; std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>>::find(wchar_t const *,uint,uint)+34j
.text$mn:0000BD7A                 mov     eax, [ebp+var_8]
.text$mn:0000BD7D                 mov     ecx, [ebp+arg_4]
.text$mn:0000BD80                 cmp     ecx, [eax+14h]
.text$mn:0000BD83                 jnb     loc_BE28
.text$mn:0000BD89                 mov     edx, [ebp+var_8]
.text$mn:0000BD8C                 mov     eax, [edx+14h]
.text$mn:0000BD8F                 sub     eax, [ebp+arg_4]
.text$mn:0000BD92                 mov     [ebp+var_4], eax
.text$mn:0000BD95                 mov     ecx, [ebp+arg_8]
.text$mn:0000BD98                 cmp     ecx, [ebp+var_4]
.text$mn:0000BD9B                 ja      loc_BE28
.text$mn:0000BDA1                 mov     edx, [ebp+arg_8]
.text$mn:0000BDA4                 sub     edx, 1
.text$mn:0000BDA7                 mov     eax, [ebp+var_4]
.text$mn:0000BDAA                 sub     eax, edx
.text$mn:0000BDAC                 mov     [ebp+var_4], eax
.text$mn:0000BDAF                 mov     ecx, [ebp+var_8]
.text$mn:0000BDB2                 call    ?_Myptr@?$_String_val@U?$_Simple_types@_W@std@@@std@@QBEPB_WXZ ; std::_String_val<std::_Simple_types<wchar_t>>::_Myptr(void)
.text$mn:0000BDB7                 mov     ecx, [ebp+arg_4]
.text$mn:0000BDBA                 lea     edx, [eax+ecx*2]
.text$mn:0000BDBD                 mov     [ebp+var_10], edx
.text$mn:0000BDC0                 jmp     short loc_BDDE
.text$mn:0000BDC2 ; ---------------------------------------------------------------------------
.text$mn:0000BDC2
.text$mn:0000BDC2 loc_BDC2:                               ; CODE XREF: std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>>::find(wchar_t const *,uint,uint):loc_BE26j
.text$mn:0000BDC2                 mov     eax, [ebp+var_C]
.text$mn:0000BDC5                 sub     eax, [ebp+var_10]
.text$mn:0000BDC8                 sar     eax, 1
.text$mn:0000BDCA                 add     eax, 1
.text$mn:0000BDCD                 mov     ecx, [ebp+var_4]
.text$mn:0000BDD0                 sub     ecx, eax
.text$mn:0000BDD2                 mov     [ebp+var_4], ecx
.text$mn:0000BDD5                 mov     edx, [ebp+var_C]
.text$mn:0000BDD8                 add     edx, 2
.text$mn:0000BDDB                 mov     [ebp+var_10], edx
.text$mn:0000BDDE
.text$mn:0000BDDE loc_BDDE:                               ; CODE XREF: std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>>::find(wchar_t const *,uint,uint)+84j
.text$mn:0000BDDE                 mov     eax, [ebp+arg_0]
.text$mn:0000BDE1                 push    eax
.text$mn:0000BDE2                 mov     ecx, [ebp+var_4]
.text$mn:0000BDE5                 push    ecx
.text$mn:0000BDE6                 mov     edx, [ebp+var_10]
.text$mn:0000BDE9                 push    edx
.text$mn:0000BDEA                 call    ?find@?$char_traits@_W@std@@SAPB_WPB_WIAB_W@Z ; std::char_traits<wchar_t>::find(wchar_t const *,uint,wchar_t const &)
.text$mn:0000BDEF                 add     esp, 0Ch
.text$mn:0000BDF2                 mov     [ebp+var_C], eax
.text$mn:0000BDF5                 cmp     [ebp+var_C], 0
.text$mn:0000BDF9                 jz      short loc_BE28
.text$mn:0000BDFB                 mov     eax, [ebp+arg_8]
.text$mn:0000BDFE                 push    eax
.text$mn:0000BDFF                 mov     ecx, [ebp+arg_0]
.text$mn:0000BE02                 push    ecx
.text$mn:0000BE03                 mov     edx, [ebp+var_C]
.text$mn:0000BE06                 push    edx
.text$mn:0000BE07                 call    ?compare@?$char_traits@_W@std@@SAHPB_W0I@Z ; std::char_traits<wchar_t>::compare(wchar_t const *,wchar_t const *,uint)
.text$mn:0000BE0C                 add     esp, 0Ch
.text$mn:0000BE0F                 test    eax, eax
.text$mn:0000BE11                 jnz     short loc_BE26
.text$mn:0000BE13                 mov     ecx, [ebp+var_8]
.text$mn:0000BE16                 call    ?_Myptr@?$_String_val@U?$_Simple_types@_W@std@@@std@@QBEPB_WXZ ; std::_String_val<std::_Simple_types<wchar_t>>::_Myptr(void)
.text$mn:0000BE1B                 mov     ecx, [ebp+var_C]
.text$mn:0000BE1E                 sub     ecx, eax
.text$mn:0000BE20                 sar     ecx, 1
.text$mn:0000BE22                 mov     eax, ecx
.text$mn:0000BE24                 jmp     short loc_BE2D
.text$mn:0000BE26 ; ---------------------------------------------------------------------------
.text$mn:0000BE26
.text$mn:0000BE26 loc_BE26:                               ; CODE XREF: std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>>::find(wchar_t const *,uint,uint)+D5j
.text$mn:0000BE26                 jmp     short loc_BDC2
.text$mn:0000BE28 ; ---------------------------------------------------------------------------
.text$mn:0000BE28
.text$mn:0000BE28 loc_BE28:                               ; CODE XREF: std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>>::find(wchar_t const *,uint,uint)+47j
.text$mn:0000BE28                                         ; std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>>::find(wchar_t const *,uint,uint)+5Fj ...
.text$mn:0000BE28                 mov     eax, ds:?npos@?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@2IB ; uint const std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>>::npos
.text$mn:0000BE2D
.text$mn:0000BE2D loc_BE2D:                               ; CODE XREF: std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>>::find(wchar_t const *,uint,uint)+39j
.text$mn:0000BE2D                                         ; std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>>::find(wchar_t const *,uint,uint)+E8j
.text$mn:0000BE2D                 mov     esp, ebp
.text$mn:0000BE2F                 pop     ebp
.text$mn:0000BE30                 retn    0Ch
.text$mn:0000BE30 ?find@?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QBEIPB_WII@Z endp
.text$mn:0000BE30
.text$mn:0000BE30 ; ---------------------------------------------------------------------------
.text$mn:0000BE33                 align 4
.text$mn:0000BE33 _text$mn        ends
.text$mn:0000BE33
.text$mn:0000BE34 ; ===========================================================================
.text$mn:0000BE34
.text$mn:0000BE34 ; Segment type: Pure code
.text$mn:0000BE34 ; Segment permissions: Read/Execute
.text$mn:0000BE34 _text$mn        segment para public 'CODE' use32
.text$mn:0000BE34                 assume cs:_text$mn
.text$mn:0000BE34                 ;org 0BE34h
.text$mn:0000BE34 ; COMDAT (pick any)
.text$mn:0000BE34                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text$mn:0000BE34
.text$mn:0000BE34 ; =============== S U B R O U T I N E =======================================
.text$mn:0000BE34
.text$mn:0000BE34 ; Attributes: bp-based frame
.text$mn:0000BE34
.text$mn:0000BE34 ; public: static wchar_t const * __cdecl std::char_traits<wchar_t>::find(wchar_t const *, unsigned int, wchar_t const &)
.text$mn:0000BE34                 public ?find@?$char_traits@_W@std@@SAPB_WPB_WIAB_W@Z
.text$mn:0000BE34 ?find@?$char_traits@_W@std@@SAPB_WPB_WIAB_W@Z proc near
.text$mn:0000BE34                                         ; CODE XREF: std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>>::find(wchar_t const *,uint,uint)+AEp
.text$mn:0000BE34                                         ; std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>>::find_first_not_of(wchar_t const *,uint,uint)+74p
.text$mn:0000BE34
.text$mn:0000BE34 var_4           = dword ptr -4
.text$mn:0000BE34 arg_0           = dword ptr  8
.text$mn:0000BE34 arg_4           = dword ptr  0Ch
.text$mn:0000BE34 arg_8           = dword ptr  10h
.text$mn:0000BE34
.text$mn:0000BE34                 push    ebp
.text$mn:0000BE35                 mov     ebp, esp
.text$mn:0000BE37                 push    ecx
.text$mn:0000BE38                 cmp     [ebp+arg_4], 0
.text$mn:0000BE3C                 jnz     short loc_BE47
.text$mn:0000BE3E                 mov     [ebp+var_4], 0
.text$mn:0000BE45                 jmp     short loc_BE61
.text$mn:0000BE47 ; ---------------------------------------------------------------------------
.text$mn:0000BE47
.text$mn:0000BE47 loc_BE47:                               ; CODE XREF: std::char_traits<wchar_t>::find(wchar_t const *,uint,wchar_t const &)+8j
.text$mn:0000BE47                 mov     eax, [ebp+arg_4]
.text$mn:0000BE4A                 push    eax
.text$mn:0000BE4B                 mov     ecx, [ebp+arg_8]
.text$mn:0000BE4E                 movzx   edx, word ptr [ecx]
.text$mn:0000BE51                 push    edx
.text$mn:0000BE52                 mov     eax, [ebp+arg_0]
.text$mn:0000BE55                 push    eax
.text$mn:0000BE56                 call    _wmemchr
.text$mn:0000BE5B                 add     esp, 0Ch
.text$mn:0000BE5E                 mov     [ebp+var_4], eax
.text$mn:0000BE61
.text$mn:0000BE61 loc_BE61:                               ; CODE XREF: std::char_traits<wchar_t>::find(wchar_t const *,uint,wchar_t const &)+11j
.text$mn:0000BE61                 mov     eax, [ebp+var_4]
.text$mn:0000BE64                 mov     esp, ebp
.text$mn:0000BE66                 pop     ebp
.text$mn:0000BE67                 retn
.text$mn:0000BE67 ?find@?$char_traits@_W@std@@SAPB_WPB_WIAB_W@Z endp
.text$mn:0000BE67
.text$mn:0000BE67 _text$mn        ends
.text$mn:0000BE67
.text$mn:0000BE68 ; ===========================================================================
.text$mn:0000BE68
.text$mn:0000BE68 ; Segment type: Pure code
.text$mn:0000BE68 ; Segment permissions: Read/Execute
.text$mn:0000BE68 _text$mn        segment para public 'CODE' use32
.text$mn:0000BE68                 assume cs:_text$mn
.text$mn:0000BE68                 ;org 0BE68h
.text$mn:0000BE68 ; COMDAT (pick any)
.text$mn:0000BE68                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text$mn:0000BE68
.text$mn:0000BE68 ; =============== S U B R O U T I N E =======================================
.text$mn:0000BE68
.text$mn:0000BE68 ; Attributes: bp-based frame
.text$mn:0000BE68
.text$mn:0000BE68 ; public: unsigned int __thiscall std::basic_string<wchar_t, struct std::char_traits<wchar_t>, class std::allocator<wchar_t>>::find_first_not_of(class std::basic_string<wchar_t, struct std::char_traits<wchar_t>, class std::allocator<wchar_t>> const &, unsigned int)const
.text$mn:0000BE68                 public ?find_first_not_of@?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QBEIABV12@I@Z
.text$mn:0000BE68 ?find_first_not_of@?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QBEIABV12@I@Z proc near
.text$mn:0000BE68                                         ; CODE XREF: stringTakeWhileAdmissable(std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>> const &,std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>> const &)+35p
.text$mn:0000BE68
.text$mn:0000BE68 var_4           = dword ptr -4
.text$mn:0000BE68 arg_0           = dword ptr  8
.text$mn:0000BE68 arg_4           = dword ptr  0Ch
.text$mn:0000BE68
.text$mn:0000BE68                 push    ebp
.text$mn:0000BE69                 mov     ebp, esp
.text$mn:0000BE6B                 push    ecx
.text$mn:0000BE6C                 mov     [ebp+var_4], ecx
.text$mn:0000BE6F                 mov     ecx, [ebp+arg_0]
.text$mn:0000BE72                 call    ?size@?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QBEIXZ ; std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>>::size(void)
.text$mn:0000BE77                 push    eax
.text$mn:0000BE78                 mov     eax, [ebp+arg_4]
.text$mn:0000BE7B                 push    eax
.text$mn:0000BE7C                 mov     ecx, [ebp+arg_0]
.text$mn:0000BE7F                 call    ?_Myptr@?$_String_val@U?$_Simple_types@_W@std@@@std@@QBEPB_WXZ ; std::_String_val<std::_Simple_types<wchar_t>>::_Myptr(void)
.text$mn:0000BE84                 push    eax
.text$mn:0000BE85                 mov     ecx, [ebp+var_4]
.text$mn:0000BE88                 call    ?find_first_not_of@?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QBEIPB_WII@Z ; std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>>::find_first_not_of(wchar_t const *,uint,uint)
.text$mn:0000BE8D                 mov     esp, ebp
.text$mn:0000BE8F                 pop     ebp
.text$mn:0000BE90                 retn    8
.text$mn:0000BE90 ?find_first_not_of@?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QBEIABV12@I@Z endp
.text$mn:0000BE90
.text$mn:0000BE90 ; ---------------------------------------------------------------------------
.text$mn:0000BE93                 align 4
.text$mn:0000BE93 _text$mn        ends
.text$mn:0000BE93
.text$mn:0000BE94 ; ===========================================================================
.text$mn:0000BE94
.text$mn:0000BE94 ; Segment type: Pure code
.text$mn:0000BE94 ; Segment permissions: Read/Execute
.text$mn:0000BE94 _text$mn        segment para public 'CODE' use32
.text$mn:0000BE94                 assume cs:_text$mn
.text$mn:0000BE94                 ;org 0BE94h
.text$mn:0000BE94 ; COMDAT (pick any)
.text$mn:0000BE94                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text$mn:0000BE94
.text$mn:0000BE94 ; =============== S U B R O U T I N E =======================================
.text$mn:0000BE94
.text$mn:0000BE94 ; Attributes: bp-based frame
.text$mn:0000BE94
.text$mn:0000BE94 ; public: unsigned int __thiscall std::basic_string<wchar_t, struct std::char_traits<wchar_t>, class std::allocator<wchar_t>>::find_first_not_of(wchar_t const *, unsigned int, unsigned int)const
.text$mn:0000BE94                 public ?find_first_not_of@?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QBEIPB_WII@Z
.text$mn:0000BE94 ?find_first_not_of@?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QBEIPB_WII@Z proc near
.text$mn:0000BE94                                         ; CODE XREF: std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>>::find_first_not_of(std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>> const &,uint)+20p
.text$mn:0000BE94                                         ; std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>>::find_first_not_of(wchar_t,uint)+14p
.text$mn:0000BE94
.text$mn:0000BE94 var_C           = dword ptr -0Ch
.text$mn:0000BE94 var_8           = dword ptr -8
.text$mn:0000BE94 var_4           = dword ptr -4
.text$mn:0000BE94 arg_0           = dword ptr  8
.text$mn:0000BE94 arg_4           = dword ptr  0Ch
.text$mn:0000BE94 arg_8           = dword ptr  10h
.text$mn:0000BE94
.text$mn:0000BE94                 push    ebp
.text$mn:0000BE95                 mov     ebp, esp
.text$mn:0000BE97                 sub     esp, 0Ch
.text$mn:0000BE9A                 mov     [ebp+var_4], ecx
.text$mn:0000BE9D                 cmp     [ebp+arg_8], 0
.text$mn:0000BEA1                 jz      short loc_BEB9
.text$mn:0000BEA3                 push    80Eh            ; unsigned int
.text$mn:0000BEA8                 push    offset ??_C@_1IO@FEAPGJBD@?$AAC?$AA?3?$AA?2?$AAP?$AAr?$AAo?$AAg?$AAr?$AAa?$AAm?$AA?5?$AAF?$AAi?$AAl?$AAe?$AAs?$AA?5?$AA?$CI?$AAx?$AA8?$AA6?$AA?$CJ?$AA?2?$AAM?$AAi?$AAc?$AAr?$AAo?$AAs?$AAo?$AAf?$AAt@ ; "C:\\Program Files (x86)\\Microsoft Visu"...
.text$mn:0000BEAD                 mov     eax, [ebp+arg_0]
.text$mn:0000BEB0                 push    eax             ; int
.text$mn:0000BEB1                 call    ??$_Debug_pointer@_W@std@@YAXPB_W0I@Z ; std::_Debug_pointer<wchar_t>(wchar_t const *,wchar_t const *,uint)
.text$mn:0000BEB6                 add     esp, 0Ch
.text$mn:0000BEB9
.text$mn:0000BEB9 loc_BEB9:                               ; CODE XREF: std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>>::find_first_not_of(wchar_t const *,uint,uint)+Dj
.text$mn:0000BEB9                 mov     ecx, [ebp+var_4]
.text$mn:0000BEBC                 mov     edx, [ebp+arg_4]
.text$mn:0000BEBF                 cmp     edx, [ecx+14h]
.text$mn:0000BEC2                 jnb     short loc_BF29
.text$mn:0000BEC4                 mov     ecx, [ebp+var_4]
.text$mn:0000BEC7                 call    ?_Myptr@?$_String_val@U?$_Simple_types@_W@std@@@std@@QBEPB_WXZ ; std::_String_val<std::_Simple_types<wchar_t>>::_Myptr(void)
.text$mn:0000BECC                 mov     ecx, [ebp+var_4]
.text$mn:0000BECF                 mov     edx, [ecx+14h]
.text$mn:0000BED2                 lea     eax, [eax+edx*2]
.text$mn:0000BED5                 mov     [ebp+var_C], eax
.text$mn:0000BED8                 mov     ecx, [ebp+var_4]
.text$mn:0000BEDB                 call    ?_Myptr@?$_String_val@U?$_Simple_types@_W@std@@@std@@QBEPB_WXZ ; std::_String_val<std::_Simple_types<wchar_t>>::_Myptr(void)
.text$mn:0000BEE0                 mov     ecx, [ebp+arg_4]
.text$mn:0000BEE3                 lea     edx, [eax+ecx*2]
.text$mn:0000BEE6                 mov     [ebp+var_8], edx
.text$mn:0000BEE9                 jmp     short loc_BEF4
.text$mn:0000BEEB ; ---------------------------------------------------------------------------
.text$mn:0000BEEB
.text$mn:0000BEEB loc_BEEB:                               ; CODE XREF: std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>>::find_first_not_of(wchar_t const *,uint,uint):loc_BF27j
.text$mn:0000BEEB                 mov     eax, [ebp+var_8]
.text$mn:0000BEEE                 add     eax, 2
.text$mn:0000BEF1                 mov     [ebp+var_8], eax
.text$mn:0000BEF4
.text$mn:0000BEF4 loc_BEF4:                               ; CODE XREF: std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>>::find_first_not_of(wchar_t const *,uint,uint)+55j
.text$mn:0000BEF4                 mov     ecx, [ebp+var_8]
.text$mn:0000BEF7                 cmp     ecx, [ebp+var_C]
.text$mn:0000BEFA                 jnb     short loc_BF29
.text$mn:0000BEFC                 mov     edx, [ebp+var_8]
.text$mn:0000BEFF                 push    edx
.text$mn:0000BF00                 mov     eax, [ebp+arg_8]
.text$mn:0000BF03                 push    eax
.text$mn:0000BF04                 mov     ecx, [ebp+arg_0]
.text$mn:0000BF07                 push    ecx
.text$mn:0000BF08                 call    ?find@?$char_traits@_W@std@@SAPB_WPB_WIAB_W@Z ; std::char_traits<wchar_t>::find(wchar_t const *,uint,wchar_t const &)
.text$mn:0000BF0D                 add     esp, 0Ch
.text$mn:0000BF10                 test    eax, eax
.text$mn:0000BF12                 jnz     short loc_BF27
.text$mn:0000BF14                 mov     ecx, [ebp+var_4]
.text$mn:0000BF17                 call    ?_Myptr@?$_String_val@U?$_Simple_types@_W@std@@@std@@QBEPB_WXZ ; std::_String_val<std::_Simple_types<wchar_t>>::_Myptr(void)
.text$mn:0000BF1C                 mov     edx, [ebp+var_8]
.text$mn:0000BF1F                 sub     edx, eax
.text$mn:0000BF21                 sar     edx, 1
.text$mn:0000BF23                 mov     eax, edx
.text$mn:0000BF25                 jmp     short loc_BF2E
.text$mn:0000BF27 ; ---------------------------------------------------------------------------
.text$mn:0000BF27
.text$mn:0000BF27 loc_BF27:                               ; CODE XREF: std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>>::find_first_not_of(wchar_t const *,uint,uint)+7Ej
.text$mn:0000BF27                 jmp     short loc_BEEB
.text$mn:0000BF29 ; ---------------------------------------------------------------------------
.text$mn:0000BF29
.text$mn:0000BF29 loc_BF29:                               ; CODE XREF: std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>>::find_first_not_of(wchar_t const *,uint,uint)+2Ej
.text$mn:0000BF29                                         ; std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>>::find_first_not_of(wchar_t const *,uint,uint)+66j
.text$mn:0000BF29                 mov     eax, ds:?npos@?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@2IB ; uint const std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>>::npos
.text$mn:0000BF2E
.text$mn:0000BF2E loc_BF2E:                               ; CODE XREF: std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>>::find_first_not_of(wchar_t const *,uint,uint)+91j
.text$mn:0000BF2E                 mov     esp, ebp
.text$mn:0000BF30                 pop     ebp
.text$mn:0000BF31                 retn    0Ch
.text$mn:0000BF31 ?find_first_not_of@?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QBEIPB_WII@Z endp
.text$mn:0000BF31
.text$mn:0000BF31 _text$mn        ends
.text$mn:0000BF31
.text$mn:0000BF34 ; ===========================================================================
.text$mn:0000BF34
.text$mn:0000BF34 ; Segment type: Pure code
.text$mn:0000BF34 ; Segment permissions: Read/Execute
.text$mn:0000BF34 _text$mn        segment para public 'CODE' use32
.text$mn:0000BF34                 assume cs:_text$mn
.text$mn:0000BF34                 ;org 0BF34h
.text$mn:0000BF34 ; COMDAT (pick any)
.text$mn:0000BF34                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text$mn:0000BF34
.text$mn:0000BF34 ; =============== S U B R O U T I N E =======================================
.text$mn:0000BF34
.text$mn:0000BF34 ; Attributes: bp-based frame
.text$mn:0000BF34
.text$mn:0000BF34 ; public: unsigned int __thiscall std::basic_string<wchar_t, struct std::char_traits<wchar_t>, class std::allocator<wchar_t>>::find_first_not_of(wchar_t, unsigned int)const
.text$mn:0000BF34                 public ?find_first_not_of@?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QBEI_WI@Z
.text$mn:0000BF34 ?find_first_not_of@?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QBEI_WI@Z proc near
.text$mn:0000BF34                                         ; CODE XREF: tokenizeString(std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>> const &,char)+4Cp
.text$mn:0000BF34                                         ; tokenizeString(std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>> const &,char)+CEp
.text$mn:0000BF34
.text$mn:0000BF34 var_4           = dword ptr -4
.text$mn:0000BF34 arg_0           = byte ptr  8
.text$mn:0000BF34 arg_4           = dword ptr  0Ch
.text$mn:0000BF34
.text$mn:0000BF34                 push    ebp
.text$mn:0000BF35                 mov     ebp, esp
.text$mn:0000BF37                 push    ecx
.text$mn:0000BF38                 mov     [ebp+var_4], ecx
.text$mn:0000BF3B                 push    1
.text$mn:0000BF3D                 mov     eax, [ebp+arg_4]
.text$mn:0000BF40                 push    eax
.text$mn:0000BF41                 lea     ecx, [ebp+arg_0]
.text$mn:0000BF44                 push    ecx
.text$mn:0000BF45                 mov     ecx, [ebp+var_4]
.text$mn:0000BF48                 call    ?find_first_not_of@?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QBEIPB_WII@Z ; std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>>::find_first_not_of(wchar_t const *,uint,uint)
.text$mn:0000BF4D                 mov     esp, ebp
.text$mn:0000BF4F                 pop     ebp
.text$mn:0000BF50                 retn    8
.text$mn:0000BF50 ?find_first_not_of@?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QBEI_WI@Z endp
.text$mn:0000BF50
.text$mn:0000BF50 ; ---------------------------------------------------------------------------
.text$mn:0000BF53                 align 4
.text$mn:0000BF53 _text$mn        ends
.text$mn:0000BF53
.text$mn:0000BF54 ; ===========================================================================
.text$mn:0000BF54
.text$mn:0000BF54 ; Segment type: Pure code
.text$mn:0000BF54 ; Segment permissions: Read/Execute
.text$mn:0000BF54 _text$mn        segment para public 'CODE' use32
.text$mn:0000BF54                 assume cs:_text$mn
.text$mn:0000BF54                 ;org 0BF54h
.text$mn:0000BF54 ; COMDAT (pick any)
.text$mn:0000BF54                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text$mn:0000BF54
.text$mn:0000BF54 ; =============== S U B R O U T I N E =======================================
.text$mn:0000BF54
.text$mn:0000BF54 ; Attributes: bp-based frame
.text$mn:0000BF54
.text$mn:0000BF54 ; public: unsigned int __thiscall std::basic_string<wchar_t, struct std::char_traits<wchar_t>, class std::allocator<wchar_t>>::find_first_of(wchar_t, unsigned int)const
.text$mn:0000BF54                 public ?find_first_of@?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QBEI_WI@Z
.text$mn:0000BF54 ?find_first_of@?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QBEI_WI@Z proc near
.text$mn:0000BF54                                         ; CODE XREF: tokenizeString(std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>> const &,char)+64p
.text$mn:0000BF54                                         ; tokenizeString(std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>> const &,char)+E6p
.text$mn:0000BF54
.text$mn:0000BF54 var_4           = dword ptr -4
.text$mn:0000BF54 arg_0           = byte ptr  8
.text$mn:0000BF54 arg_4           = dword ptr  0Ch
.text$mn:0000BF54
.text$mn:0000BF54                 push    ebp
.text$mn:0000BF55                 mov     ebp, esp
.text$mn:0000BF57                 push    ecx
.text$mn:0000BF58                 mov     [ebp+var_4], ecx
.text$mn:0000BF5B                 push    1
.text$mn:0000BF5D                 mov     eax, [ebp+arg_4]
.text$mn:0000BF60                 push    eax
.text$mn:0000BF61                 lea     ecx, [ebp+arg_0]
.text$mn:0000BF64                 push    ecx
.text$mn:0000BF65                 mov     ecx, [ebp+var_4]
.text$mn:0000BF68                 call    ?find@?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QBEIPB_WII@Z ; std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>>::find(wchar_t const *,uint,uint)
.text$mn:0000BF6D                 mov     esp, ebp
.text$mn:0000BF6F                 pop     ebp
.text$mn:0000BF70                 retn    8
.text$mn:0000BF70 ?find_first_of@?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QBEI_WI@Z endp
.text$mn:0000BF70
.text$mn:0000BF70 ; ---------------------------------------------------------------------------
.text$mn:0000BF73                 align 4
.text$mn:0000BF73 _text$mn        ends
.text$mn:0000BF73
.text$mn:0000BF74 ; ===========================================================================
.text$mn:0000BF74
.text$mn:0000BF74 ; Segment type: Pure code
.text$mn:0000BF74 ; Segment permissions: Read/Execute
.text$mn:0000BF74 _text$mn        segment para public 'CODE' use32
.text$mn:0000BF74                 assume cs:_text$mn
.text$mn:0000BF74                 ;org 0BF74h
.text$mn:0000BF74 ; COMDAT (pick any)
.text$mn:0000BF74                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text$mn:0000BF74
.text$mn:0000BF74 ; =============== S U B R O U T I N E =======================================
.text$mn:0000BF74
.text$mn:0000BF74 ; Attributes: bp-based frame
.text$mn:0000BF74
.text$mn:0000BF74 ; public: unsigned int __thiscall std::basic_string<wchar_t, struct std::char_traits<wchar_t>, class std::allocator<wchar_t>>::find_last_of(wchar_t, unsigned int)const
.text$mn:0000BF74                 public ?find_last_of@?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QBEI_WI@Z
.text$mn:0000BF74 ?find_last_of@?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QBEI_WI@Z proc near
.text$mn:0000BF74                                         ; CODE XREF: PathRemoveFileSpecW(std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>> &)+37p
.text$mn:0000BF74
.text$mn:0000BF74 var_4           = dword ptr -4
.text$mn:0000BF74 arg_0           = byte ptr  8
.text$mn:0000BF74 arg_4           = dword ptr  0Ch
.text$mn:0000BF74
.text$mn:0000BF74                 push    ebp
.text$mn:0000BF75                 mov     ebp, esp
.text$mn:0000BF77                 push    ecx
.text$mn:0000BF78                 mov     [ebp+var_4], ecx
.text$mn:0000BF7B                 push    1
.text$mn:0000BF7D                 mov     eax, [ebp+arg_4]
.text$mn:0000BF80                 push    eax
.text$mn:0000BF81                 lea     ecx, [ebp+arg_0]
.text$mn:0000BF84                 push    ecx
.text$mn:0000BF85                 mov     ecx, [ebp+var_4]
.text$mn:0000BF88                 call    ?rfind@?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QBEIPB_WII@Z ; std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>>::rfind(wchar_t const *,uint,uint)
.text$mn:0000BF8D                 mov     esp, ebp
.text$mn:0000BF8F                 pop     ebp
.text$mn:0000BF90                 retn    8
.text$mn:0000BF90 ?find_last_of@?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QBEI_WI@Z endp
.text$mn:0000BF90
.text$mn:0000BF90 ; ---------------------------------------------------------------------------
.text$mn:0000BF93                 align 4
.text$mn:0000BF93 _text$mn        ends
.text$mn:0000BF93
.text$mn:0000BF94 ; ===========================================================================
.text$mn:0000BF94
.text$mn:0000BF94 ; Segment type: Pure code
.text$mn:0000BF94 ; Segment permissions: Read/Execute
.text$mn:0000BF94 _text$mn        segment para public 'CODE' use32
.text$mn:0000BF94                 assume cs:_text$mn
.text$mn:0000BF94                 ;org 0BF94h
.text$mn:0000BF94 ; COMDAT (pick any)
.text$mn:0000BF94                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text$mn:0000BF94
.text$mn:0000BF94 ; =============== S U B R O U T I N E =======================================
.text$mn:0000BF94
.text$mn:0000BF94 ; Attributes: bp-based frame
.text$mn:0000BF94
.text$mn:0000BF94 ; const struct std::error_category *__cdecl std::generic_category()
.text$mn:0000BF94                 public ?generic_category@std@@YAABVerror_category@1@XZ
.text$mn:0000BF94 ?generic_category@std@@YAABVerror_category@1@XZ proc near
.text$mn:0000BF94                                         ; CODE XREF: std::_System_error_category::default_error_condition(int)+17p
.text$mn:0000BF94                 push    ebp
.text$mn:0000BF95                 mov     ebp, esp
.text$mn:0000BF97                 mov     eax, offset ?_Generic_object@?$_Error_objects@H@std@@2V_Generic_error_category@2@A ; std::_Generic_error_category std::_Error_objects<int>::_Generic_object
.text$mn:0000BF9C                 pop     ebp
.text$mn:0000BF9D                 retn
.text$mn:0000BF9D ?generic_category@std@@YAABVerror_category@1@XZ endp
.text$mn:0000BF9D
.text$mn:0000BF9D ; ---------------------------------------------------------------------------
.text$mn:0000BF9E                 align 10h
.text$mn:0000BF9E _text$mn        ends
.text$mn:0000BF9E
.text$mn:0000BFA0 ; ===========================================================================
.text$mn:0000BFA0
.text$mn:0000BFA0 ; Segment type: Pure code
.text$mn:0000BFA0 ; Segment permissions: Read/Execute
.text$mn:0000BFA0 _text$mn        segment para public 'CODE' use32
.text$mn:0000BFA0                 assume cs:_text$mn
.text$mn:0000BFA0                 ;org 0BFA0h
.text$mn:0000BFA0 ; COMDAT (pick any)
.text$mn:0000BFA0                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text$mn:0000BFA0
.text$mn:0000BFA0 ; =============== S U B R O U T I N E =======================================
.text$mn:0000BFA0
.text$mn:0000BFA0 ; Attributes: bp-based frame
.text$mn:0000BFA0
.text$mn:0000BFA0 ; public: class std::allocator<wchar_t> __thiscall std::basic_string<wchar_t, struct std::char_traits<wchar_t>, class std::allocator<wchar_t>>::get_allocator(void)const
.text$mn:0000BFA0                 public ?get_allocator@?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QBE?AV?$allocator@_W@2@XZ
.text$mn:0000BFA0 ?get_allocator@?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QBE?AV?$allocator@_W@2@XZ proc near
.text$mn:0000BFA0                                         ; CODE XREF: std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>>::substr(uint,uint)+36p
.text$mn:0000BFA0
.text$mn:0000BFA0 var_8           = dword ptr -8
.text$mn:0000BFA0 var_1           = byte ptr -1
.text$mn:0000BFA0 arg_0           = dword ptr  8
.text$mn:0000BFA0
.text$mn:0000BFA0                 push    ebp
.text$mn:0000BFA1                 mov     ebp, esp
.text$mn:0000BFA3                 sub     esp, 8
.text$mn:0000BFA6                 mov     [ebp+var_8], ecx
.text$mn:0000BFA9                 lea     eax, [ebp+var_1]
.text$mn:0000BFAC                 push    eax
.text$mn:0000BFAD                 mov     ecx, [ebp+var_8]
.text$mn:0000BFB0                 call    ?_Getal@?$_String_alloc@$0A@U?$_String_base_types@_WV?$allocator@_W@std@@@std@@@std@@QBE?AU?$_Wrap_alloc@V?$allocator@_W@std@@@2@XZ ; std::_String_alloc<0,std::_String_base_types<wchar_t,std::allocator<wchar_t>>>::_Getal(void)
.text$mn:0000BFB5                 push    eax
.text$mn:0000BFB6                 mov     ecx, [ebp+arg_0]
.text$mn:0000BFB9                 call    ??0?$allocator@_W@std@@QAE@ABV01@@Z ; std::allocator<wchar_t>::allocator<wchar_t>(std::allocator<wchar_t> const &)
.text$mn:0000BFBE                 mov     eax, [ebp+arg_0]
.text$mn:0000BFC1                 mov     esp, ebp
.text$mn:0000BFC3                 pop     ebp
.text$mn:0000BFC4                 retn    4
.text$mn:0000BFC4 ?get_allocator@?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QBE?AV?$allocator@_W@2@XZ endp
.text$mn:0000BFC4
.text$mn:0000BFC4 ; ---------------------------------------------------------------------------
.text$mn:0000BFC7                 align 4
.text$mn:0000BFC7 _text$mn        ends
.text$mn:0000BFC7
.text$mn:0000BFC8 ; ===========================================================================
.text$mn:0000BFC8
.text$mn:0000BFC8 ; Segment type: Pure code
.text$mn:0000BFC8 ; Segment permissions: Read/Execute
.text$mn:0000BFC8 _text$mn        segment para public 'CODE' use32
.text$mn:0000BFC8                 assume cs:_text$mn
.text$mn:0000BFC8                 ;org 0BFC8h
.text$mn:0000BFC8 ; COMDAT (pick any)
.text$mn:0000BFC8                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text$mn:0000BFC8
.text$mn:0000BFC8 ; =============== S U B R O U T I N E =======================================
.text$mn:0000BFC8
.text$mn:0000BFC8 ; Attributes: bp-based frame
.text$mn:0000BFC8
.text$mn:0000BFC8 ; public: class std::_String_iterator<class std::_String_val<struct std::_Simple_types<wchar_t>>> __thiscall std::basic_string<wchar_t, struct std::char_traits<wchar_t>, class std::allocator<wchar_t>>::insert(class std::_String_const_iterator<class std::_String_val<struct std::_Simple_types<wchar_t>>>, wchar_t)
.text$mn:0000BFC8                 public ?insert@?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QAE?AV?$_String_iterator@V?$_String_val@U?$_Simple_types@_W@std@@@std@@@2@V?$_String_const_iterator@V?$_String_val@U?$_Simple_types@_W@std@@@std@@@2@_W@Z
.text$mn:0000BFC8 ?insert@?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QAE?AV?$_String_iterator@V?$_String_val@U?$_Simple_types@_W@std@@@std@@@2@V?$_String_const_iterator@V?$_String_val@U?$_Simple_types@_W@std@@@std@@@2@_W@Z proc near
.text$mn:0000BFC8                                         ; CODE XREF: std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>>::push_back(wchar_t)+72p
.text$mn:0000BFC8
.text$mn:0000BFC8 var_5C          = byte ptr -5Ch
.text$mn:0000BFC8 var_50          = byte ptr -50h
.text$mn:0000BFC8 var_44          = dword ptr -44h
.text$mn:0000BFC8 var_40          = dword ptr -40h
.text$mn:0000BFC8 var_3C          = dword ptr -3Ch
.text$mn:0000BFC8 var_38          = dword ptr -38h
.text$mn:0000BFC8 var_34          = dword ptr -34h
.text$mn:0000BFC8 var_30          = dword ptr -30h
.text$mn:0000BFC8 var_2C          = dword ptr -2Ch
.text$mn:0000BFC8 var_28          = dword ptr -28h
.text$mn:0000BFC8 var_24          = dword ptr -24h
.text$mn:0000BFC8 var_20          = dword ptr -20h
.text$mn:0000BFC8 var_1C          = dword ptr -1Ch
.text$mn:0000BFC8 var_18          = dword ptr -18h
.text$mn:0000BFC8 var_14          = dword ptr -14h
.text$mn:0000BFC8 var_10          = dword ptr -10h
.text$mn:0000BFC8 var_C           = dword ptr -0Ch
.text$mn:0000BFC8 var_4           = dword ptr -4
.text$mn:0000BFC8 arg_0           = dword ptr  8
.text$mn:0000BFC8 arg_4           = byte ptr  0Ch
.text$mn:0000BFC8 arg_10          = word ptr  18h
.text$mn:0000BFC8
.text$mn:0000BFC8                 push    ebp
.text$mn:0000BFC9                 mov     ebp, esp
.text$mn:0000BFCB                 push    0FFFFFFFFh
.text$mn:0000BFCD                 push    offset __ehhandler$?insert@?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QAE?AV?$_String_iterator@V?$_String_val@U?$_Simple_types@_W@std@@@std@@@2@V?$_String_const_iterator@V?$_String_val@U?$_Simple_types@_W@std@@@std@@@2@_W@Z
.text$mn:0000BFD2                 mov     eax, large fs:0
.text$mn:0000BFD8                 push    eax
.text$mn:0000BFD9                 sub     esp, 50h
.text$mn:0000BFDC                 mov     eax, dword ptr ds:___security_cookie
.text$mn:0000BFE1                 xor     eax, ebp
.text$mn:0000BFE3                 push    eax
.text$mn:0000BFE4                 lea     eax, [ebp+var_C]
.text$mn:0000BFE7                 mov     large fs:0, eax
.text$mn:0000BFED                 mov     [ebp+var_10], ecx
.text$mn:0000BFF0                 mov     [ebp+var_18], 0
.text$mn:0000BFF7                 mov     [ebp+var_4], 1
.text$mn:0000BFFE                 lea     eax, [ebp+var_50]
.text$mn:0000C001                 push    eax
.text$mn:0000C002                 mov     ecx, [ebp+var_10]
.text$mn:0000C005                 call    ?begin@?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QAE?AV?$_String_iterator@V?$_String_val@U?$_Simple_types@_W@std@@@std@@@2@XZ ; std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>>::begin(void)
.text$mn:0000C00A                 mov     [ebp+var_1C], eax
.text$mn:0000C00D                 mov     ecx, [ebp+var_1C]
.text$mn:0000C010                 mov     [ebp+var_20], ecx
.text$mn:0000C013                 mov     byte ptr [ebp+var_4], 2
.text$mn:0000C017                 sub     esp, 0Ch
.text$mn:0000C01A                 mov     ecx, esp
.text$mn:0000C01C                 mov     [ebp+var_38], esp
.text$mn:0000C01F                 mov     edx, [ebp+var_20]
.text$mn:0000C022                 push    edx             ; struct std::_Iterator_base12 *
.text$mn:0000C023                 call    ??0?$_String_const_iterator@V?$_String_val@U?$_Simple_types@_W@std@@@std@@@std@@QAE@ABV01@@Z ; std::_String_const_iterator<std::_String_val<std::_Simple_types<wchar_t>>>::_String_const_iterator<std::_String_val<std::_Simple_types<wchar_t>>>(std::_String_const_iterator<std::_String_val<std::_Simple_types<wchar_t>>> const &)
.text$mn:0000C028                 mov     [ebp+var_24], eax
.text$mn:0000C02B                 mov     eax, [ebp+var_24]
.text$mn:0000C02E                 mov     [ebp+var_3C], eax
.text$mn:0000C031                 mov     byte ptr [ebp+var_4], 3
.text$mn:0000C035                 sub     esp, 0Ch
.text$mn:0000C038                 mov     ecx, esp
.text$mn:0000C03A                 mov     [ebp+var_40], esp
.text$mn:0000C03D                 lea     edx, [ebp+arg_4]
.text$mn:0000C040                 push    edx             ; struct std::_Iterator_base12 *
.text$mn:0000C041                 call    ??0?$_String_const_iterator@V?$_String_val@U?$_Simple_types@_W@std@@@std@@@std@@QAE@ABV01@@Z ; std::_String_const_iterator<std::_String_val<std::_Simple_types<wchar_t>>>::_String_const_iterator<std::_String_val<std::_Simple_types<wchar_t>>>(std::_String_const_iterator<std::_String_val<std::_Simple_types<wchar_t>>> const &)
.text$mn:0000C046                 mov     [ebp+var_28], eax
.text$mn:0000C049                 mov     eax, [ebp+var_28]
.text$mn:0000C04C                 mov     [ebp+var_44], eax
.text$mn:0000C04F                 mov     byte ptr [ebp+var_4], 4
.text$mn:0000C053                 mov     byte ptr [ebp+var_4], 2
.text$mn:0000C057                 call    ?_Pdif@?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@SAIV?$_String_const_iterator@V?$_String_val@U?$_Simple_types@_W@std@@@std@@@2@0@Z ; std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>>::_Pdif(std::_String_const_iterator<std::_String_val<std::_Simple_types<wchar_t>>>,std::_String_const_iterator<std::_String_val<std::_Simple_types<wchar_t>>>)
.text$mn:0000C05C                 add     esp, 18h
.text$mn:0000C05F                 mov     [ebp+var_2C], eax
.text$mn:0000C062                 mov     ecx, [ebp+var_2C]
.text$mn:0000C065                 mov     [ebp+var_14], ecx
.text$mn:0000C068                 mov     byte ptr [ebp+var_4], 1
.text$mn:0000C06C                 lea     ecx, [ebp+var_50]
.text$mn:0000C06F                 call    ??1?$_String_iterator@V?$_String_val@U?$_Simple_types@_W@std@@@std@@@std@@QAE@XZ ; std::_String_iterator<std::_String_val<std::_Simple_types<wchar_t>>>::~_String_iterator<std::_String_val<std::_Simple_types<wchar_t>>>(void)
.text$mn:0000C074                 movzx   edx, [ebp+arg_10]
.text$mn:0000C078                 push    edx
.text$mn:0000C079                 push    1
.text$mn:0000C07B                 mov     eax, [ebp+var_14]
.text$mn:0000C07E                 push    eax
.text$mn:0000C07F                 mov     ecx, [ebp+var_10]
.text$mn:0000C082                 call    ?insert@?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QAEAAV12@II_W@Z ; std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>>::insert(uint,uint,wchar_t)
.text$mn:0000C087                 mov     ecx, [ebp+var_14]
.text$mn:0000C08A                 push    ecx
.text$mn:0000C08B                 mov     edx, [ebp+arg_0]
.text$mn:0000C08E                 push    edx
.text$mn:0000C08F                 lea     eax, [ebp+var_5C]
.text$mn:0000C092                 push    eax
.text$mn:0000C093                 mov     ecx, [ebp+var_10]
.text$mn:0000C096                 call    ?begin@?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QAE?AV?$_String_iterator@V?$_String_val@U?$_Simple_types@_W@std@@@std@@@2@XZ ; std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>>::begin(void)
.text$mn:0000C09B                 mov     [ebp+var_30], eax
.text$mn:0000C09E                 mov     ecx, [ebp+var_30]
.text$mn:0000C0A1                 mov     [ebp+var_34], ecx
.text$mn:0000C0A4                 mov     byte ptr [ebp+var_4], 5
.text$mn:0000C0A8                 mov     ecx, [ebp+var_34]
.text$mn:0000C0AB                 call    ??H?$_String_iterator@V?$_String_val@U?$_Simple_types@_W@std@@@std@@@std@@QBE?AV01@H@Z ; std::_String_iterator<std::_String_val<std::_Simple_types<wchar_t>>>::operator+(int)
.text$mn:0000C0B0                 mov     edx, [ebp+var_18]
.text$mn:0000C0B3                 or      edx, 1
.text$mn:0000C0B6                 mov     [ebp+var_18], edx
.text$mn:0000C0B9                 mov     byte ptr [ebp+var_4], 1
.text$mn:0000C0BD                 lea     ecx, [ebp+var_5C]
.text$mn:0000C0C0                 call    ??1?$_String_iterator@V?$_String_val@U?$_Simple_types@_W@std@@@std@@@std@@QAE@XZ ; std::_String_iterator<std::_String_val<std::_Simple_types<wchar_t>>>::~_String_iterator<std::_String_val<std::_Simple_types<wchar_t>>>(void)
.text$mn:0000C0C5                 mov     byte ptr [ebp+var_4], 0
.text$mn:0000C0C9                 lea     ecx, [ebp+arg_4]
.text$mn:0000C0CC                 call    ??1?$_String_const_iterator@V?$_String_val@U?$_Simple_types@_W@std@@@std@@@std@@QAE@XZ ; std::_String_const_iterator<std::_String_val<std::_Simple_types<wchar_t>>>::~_String_const_iterator<std::_String_val<std::_Simple_types<wchar_t>>>(void)
.text$mn:0000C0D1                 mov     eax, [ebp+arg_0]
.text$mn:0000C0D4                 mov     ecx, [ebp+var_C]
.text$mn:0000C0D7                 mov     large fs:0, ecx
.text$mn:0000C0DE                 pop     ecx
.text$mn:0000C0DF                 mov     esp, ebp
.text$mn:0000C0E1                 pop     ebp
.text$mn:0000C0E2                 retn    14h
.text$mn:0000C0E2 ?insert@?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QAE?AV?$_String_iterator@V?$_String_val@U?$_Simple_types@_W@std@@@std@@@2@V?$_String_const_iterator@V?$_String_val@U?$_Simple_types@_W@std@@@std@@@2@_W@Z endp
.text$mn:0000C0E2
.text$mn:0000C0E2 ; ---------------------------------------------------------------------------
.text$mn:0000C0E5                 align 4
.text$mn:0000C0E5 _text$mn        ends
.text$mn:0000C0E5
.text$x:0000C0E8 ; ===========================================================================
.text$x:0000C0E8
.text$x:0000C0E8 ; Segment type: Pure code
.text$x:0000C0E8 ; Segment permissions: Read/Execute
.text$x:0000C0E8 _text$x         segment para public 'CODE' use32
.text$x:0000C0E8                 assume cs:_text$x
.text$x:0000C0E8                 ;org 0C0E8h
.text$x:0000C0E8 ; COMDAT (pick associative to section at BFC8)
.text$x:0000C0E8                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text$x:0000C0E8
.text$x:0000C0E8 ; =============== S U B R O U T I N E =======================================
.text$x:0000C0E8
.text$x:0000C0E8
.text$x:0000C0E8 __unwindfunclet$?insert@?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QAE?AV?$_String_iterator@V?$_String_val@U?$_Simple_types@_W@std@@@std@@@2@V?$_String_const_iterator@V?$_String_val@U?$_Simple_types@_W@std@@@std@@@2@_W@Z$0 proc near
.text$x:0000C0E8                                         ; DATA XREF: .xdata$x:0000DB24o
.text$x:0000C0E8                 lea     ecx, [ebp+0Ch]
.text$x:0000C0EB                 jmp     ??1?$_String_const_iterator@V?$_String_val@U?$_Simple_types@_W@std@@@std@@@std@@QAE@XZ ; std::_String_const_iterator<std::_String_val<std::_Simple_types<wchar_t>>>::~_String_const_iterator<std::_String_val<std::_Simple_types<wchar_t>>>(void)
.text$x:0000C0EB __unwindfunclet$?insert@?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QAE?AV?$_String_iterator@V?$_String_val@U?$_Simple_types@_W@std@@@std@@@2@V?$_String_const_iterator@V?$_String_val@U?$_Simple_types@_W@std@@@std@@@2@_W@Z$0 endp
.text$x:0000C0EB
.text$x:0000C0F0
.text$x:0000C0F0 ; =============== S U B R O U T I N E =======================================
.text$x:0000C0F0
.text$x:0000C0F0
.text$x:0000C0F0 __unwindfunclet$?insert@?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QAE?AV?$_String_iterator@V?$_String_val@U?$_Simple_types@_W@std@@@std@@@2@V?$_String_const_iterator@V?$_String_val@U?$_Simple_types@_W@std@@@std@@@2@_W@Z$1 proc near
.text$x:0000C0F0                                         ; DATA XREF: .xdata$x:0000DB2Co
.text$x:0000C0F0                 lea     ecx, [ebp-50h]
.text$x:0000C0F3                 jmp     ??1?$_String_iterator@V?$_String_val@U?$_Simple_types@_W@std@@@std@@@std@@QAE@XZ ; std::_String_iterator<std::_String_val<std::_Simple_types<wchar_t>>>::~_String_iterator<std::_String_val<std::_Simple_types<wchar_t>>>(void)
.text$x:0000C0F3 __unwindfunclet$?insert@?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QAE?AV?$_String_iterator@V?$_String_val@U?$_Simple_types@_W@std@@@std@@@2@V?$_String_const_iterator@V?$_String_val@U?$_Simple_types@_W@std@@@std@@@2@_W@Z$1 endp
.text$x:0000C0F3
.text$x:0000C0F8
.text$x:0000C0F8 ; =============== S U B R O U T I N E =======================================
.text$x:0000C0F8
.text$x:0000C0F8
.text$x:0000C0F8 __unwindfunclet$?insert@?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QAE?AV?$_String_iterator@V?$_String_val@U?$_Simple_types@_W@std@@@std@@@2@V?$_String_const_iterator@V?$_String_val@U?$_Simple_types@_W@std@@@std@@@2@_W@Z$2 proc near
.text$x:0000C0F8                                         ; DATA XREF: .xdata$x:0000DB34o
.text$x:0000C0F8                 mov     ecx, [ebp-38h]
.text$x:0000C0FB                 jmp     ??1?$_String_const_iterator@V?$_String_val@U?$_Simple_types@_W@std@@@std@@@std@@QAE@XZ ; std::_String_const_iterator<std::_String_val<std::_Simple_types<wchar_t>>>::~_String_const_iterator<std::_String_val<std::_Simple_types<wchar_t>>>(void)
.text$x:0000C0FB __unwindfunclet$?insert@?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QAE?AV?$_String_iterator@V?$_String_val@U?$_Simple_types@_W@std@@@std@@@2@V?$_String_const_iterator@V?$_String_val@U?$_Simple_types@_W@std@@@std@@@2@_W@Z$2 endp
.text$x:0000C0FB
.text$x:0000C100
.text$x:0000C100 ; =============== S U B R O U T I N E =======================================
.text$x:0000C100
.text$x:0000C100
.text$x:0000C100 __unwindfunclet$?insert@?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QAE?AV?$_String_iterator@V?$_String_val@U?$_Simple_types@_W@std@@@std@@@2@V?$_String_const_iterator@V?$_String_val@U?$_Simple_types@_W@std@@@std@@@2@_W@Z$3 proc near
.text$x:0000C100                                         ; DATA XREF: .xdata$x:0000DB3Co
.text$x:0000C100                 mov     ecx, [ebp-40h]
.text$x:0000C103                 jmp     ??1?$_String_const_iterator@V?$_String_val@U?$_Simple_types@_W@std@@@std@@@std@@QAE@XZ ; std::_String_const_iterator<std::_String_val<std::_Simple_types<wchar_t>>>::~_String_const_iterator<std::_String_val<std::_Simple_types<wchar_t>>>(void)
.text$x:0000C103 __unwindfunclet$?insert@?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QAE?AV?$_String_iterator@V?$_String_val@U?$_Simple_types@_W@std@@@std@@@2@V?$_String_const_iterator@V?$_String_val@U?$_Simple_types@_W@std@@@std@@@2@_W@Z$3 endp
.text$x:0000C103
.text$x:0000C108
.text$x:0000C108 ; =============== S U B R O U T I N E =======================================
.text$x:0000C108
.text$x:0000C108
.text$x:0000C108 __unwindfunclet$?insert@?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QAE?AV?$_String_iterator@V?$_String_val@U?$_Simple_types@_W@std@@@std@@@2@V?$_String_const_iterator@V?$_String_val@U?$_Simple_types@_W@std@@@std@@@2@_W@Z$4 proc near
.text$x:0000C108                                         ; DATA XREF: .xdata$x:0000DB44o
.text$x:0000C108                 lea     ecx, [ebp-5Ch]
.text$x:0000C10B                 jmp     ??1?$_String_iterator@V?$_String_val@U?$_Simple_types@_W@std@@@std@@@std@@QAE@XZ ; std::_String_iterator<std::_String_val<std::_Simple_types<wchar_t>>>::~_String_iterator<std::_String_val<std::_Simple_types<wchar_t>>>(void)
.text$x:0000C10B __unwindfunclet$?insert@?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QAE?AV?$_String_iterator@V?$_String_val@U?$_Simple_types@_W@std@@@std@@@2@V?$_String_const_iterator@V?$_String_val@U?$_Simple_types@_W@std@@@std@@@2@_W@Z$4 endp
.text$x:0000C10B
.text$x:0000C110
.text$x:0000C110 ; =============== S U B R O U T I N E =======================================
.text$x:0000C110
.text$x:0000C110
.text$x:0000C110 __unwindfunclet$?insert@?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QAE?AV?$_String_iterator@V?$_String_val@U?$_Simple_types@_W@std@@@std@@@2@V?$_String_const_iterator@V?$_String_val@U?$_Simple_types@_W@std@@@std@@@2@_W@Z$5 proc near
.text$x:0000C110                                         ; DATA XREF: .xdata$x:0000DB1Co
.text$x:0000C110                 mov     eax, [ebp-18h]
.text$x:0000C113                 and     eax, 1
.text$x:0000C116                 jz      $LN9
.text$x:0000C11C                 and     dword ptr [ebp-18h], 0FFFFFFFEh
.text$x:0000C120                 mov     ecx, [ebp+8]
.text$x:0000C123                 jmp     ??1?$_String_iterator@V?$_String_val@U?$_Simple_types@_W@std@@@std@@@std@@QAE@XZ ; std::_String_iterator<std::_String_val<std::_Simple_types<wchar_t>>>::~_String_iterator<std::_String_val<std::_Simple_types<wchar_t>>>(void)
.text$x:0000C128 ; ---------------------------------------------------------------------------
.text$x:0000C128
.text$x:0000C128 $LN9:                                   ; CODE XREF: __unwindfunclet$?insert@?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QAE?AV?$_String_iterator@V?$_String_val@U?$_Simple_types@_W@std@@@std@@@2@V?$_String_const_iterator@V?$_String_val@U?$_Simple_types@_W@std@@@std@@@2@_W@Z$5+6j
.text$x:0000C128                 retn
.text$x:0000C128 __unwindfunclet$?insert@?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QAE?AV?$_String_iterator@V?$_String_val@U?$_Simple_types@_W@std@@@std@@@2@V?$_String_const_iterator@V?$_String_val@U?$_Simple_types@_W@std@@@std@@@2@_W@Z$5 endp
.text$x:0000C128
.text$x:0000C129
.text$x:0000C129 ; =============== S U B R O U T I N E =======================================
.text$x:0000C129
.text$x:0000C129
.text$x:0000C129 __ehhandler$?insert@?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QAE?AV?$_String_iterator@V?$_String_val@U?$_Simple_types@_W@std@@@std@@@2@V?$_String_const_iterator@V?$_String_val@U?$_Simple_types@_W@std@@@std@@@2@_W@Z proc near
.text$x:0000C129                                         ; DATA XREF: std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>>::insert(std::_String_const_iterator<std::_String_val<std::_Simple_types<wchar_t>>>,wchar_t)+5o
.text$x:0000C129
.text$x:0000C129 arg_4           = dword ptr  8
.text$x:0000C129
.text$x:0000C129                 mov     edx, [esp+arg_4]
.text$x:0000C12D                 lea     eax, [edx+0Ch]
.text$x:0000C130                 mov     ecx, [edx-54h]
.text$x:0000C133                 xor     ecx, eax
.text$x:0000C135                 call    @__security_check_cookie@4 ; __security_check_cookie(x)
.text$x:0000C13A                 mov     eax, offset __ehfuncinfo$?insert@?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QAE?AV?$_String_iterator@V?$_String_val@U?$_Simple_types@_W@std@@@std@@@2@V?$_String_const_iterator@V?$_String_val@U?$_Simple_types@_W@std@@@std@@@2@_W@Z
.text$x:0000C13F                 jmp     ___CxxFrameHandler3
.text$x:0000C13F __ehhandler$?insert@?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QAE?AV?$_String_iterator@V?$_String_val@U?$_Simple_types@_W@std@@@std@@@2@V?$_String_const_iterator@V?$_String_val@U?$_Simple_types@_W@std@@@std@@@2@_W@Z endp
.text$x:0000C13F
.text$x:0000C13F _text$x         ends
.text$x:0000C13F
.text$mn:0000C144 ; ===========================================================================
.text$mn:0000C144
.text$mn:0000C144 ; Segment type: Pure code
.text$mn:0000C144 ; Segment permissions: Read/Execute
.text$mn:0000C144 _text$mn        segment para public 'CODE' use32
.text$mn:0000C144                 assume cs:_text$mn
.text$mn:0000C144                 ;org 0C144h
.text$mn:0000C144 ; COMDAT (pick any)
.text$mn:0000C144                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text$mn:0000C144
.text$mn:0000C144 ; =============== S U B R O U T I N E =======================================
.text$mn:0000C144
.text$mn:0000C144 ; Attributes: bp-based frame
.text$mn:0000C144
.text$mn:0000C144 ; public: class std::basic_string<wchar_t, struct std::char_traits<wchar_t>, class std::allocator<wchar_t>> & __thiscall std::basic_string<wchar_t, struct std::char_traits<wchar_t>, class std::allocator<wchar_t>>::insert(unsigned int, unsigned int, wchar_t)
.text$mn:0000C144                 public ?insert@?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QAEAAV12@II_W@Z
.text$mn:0000C144 ?insert@?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QAEAAV12@II_W@Z proc near
.text$mn:0000C144                                         ; CODE XREF: std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>>::insert(std::_String_const_iterator<std::_String_val<std::_Simple_types<wchar_t>>>,wchar_t)+BAp
.text$mn:0000C144
.text$mn:0000C144 var_8           = dword ptr -8
.text$mn:0000C144 var_4           = dword ptr -4
.text$mn:0000C144 arg_0           = dword ptr  8
.text$mn:0000C144 arg_4           = dword ptr  0Ch
.text$mn:0000C144 arg_8           = word ptr  10h
.text$mn:0000C144
.text$mn:0000C144                 push    ebp
.text$mn:0000C145                 mov     ebp, esp
.text$mn:0000C147                 sub     esp, 8
.text$mn:0000C14A                 mov     [ebp+var_4], ecx
.text$mn:0000C14D                 mov     eax, [ebp+var_4]
.text$mn:0000C150                 mov     ecx, [eax+14h]
.text$mn:0000C153                 cmp     ecx, [ebp+arg_0]
.text$mn:0000C156                 jnb     short loc_C160
.text$mn:0000C158                 mov     ecx, [ebp+var_4]
.text$mn:0000C15B                 call    ?_Xran@?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QBEXXZ ; std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>>::_Xran(void)
.text$mn:0000C160
.text$mn:0000C160 loc_C160:                               ; CODE XREF: std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>>::insert(uint,uint,wchar_t)+12j
.text$mn:0000C160                 mov     edx, [ebp+var_4]
.text$mn:0000C163                 mov     eax, ds:?npos@?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@2IB ; uint const std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>>::npos
.text$mn:0000C168                 sub     eax, [edx+14h]
.text$mn:0000C16B                 cmp     eax, [ebp+arg_4]
.text$mn:0000C16E                 ja      short loc_C178
.text$mn:0000C170                 mov     ecx, [ebp+var_4]
.text$mn:0000C173                 call    ?_Xlen@?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QBEXXZ ; std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>>::_Xlen(void)
.text$mn:0000C178
.text$mn:0000C178 loc_C178:                               ; CODE XREF: std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>>::insert(uint,uint,wchar_t)+2Aj
.text$mn:0000C178                 cmp     [ebp+arg_4], 0
.text$mn:0000C17C                 jbe     short loc_C1F6
.text$mn:0000C17E                 mov     ecx, [ebp+var_4]
.text$mn:0000C181                 mov     edx, [ecx+14h]
.text$mn:0000C184                 add     edx, [ebp+arg_4]
.text$mn:0000C187                 mov     [ebp+var_8], edx
.text$mn:0000C18A                 push    0
.text$mn:0000C18C                 mov     eax, [ebp+var_8]
.text$mn:0000C18F                 push    eax
.text$mn:0000C190                 mov     ecx, [ebp+var_4]
.text$mn:0000C193                 call    ?_Grow@?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QAE_NI_N@Z ; std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>>::_Grow(uint,bool)
.text$mn:0000C198                 movzx   ecx, al
.text$mn:0000C19B                 test    ecx, ecx
.text$mn:0000C19D                 jz      short loc_C1F6
.text$mn:0000C19F                 mov     edx, [ebp+var_4]
.text$mn:0000C1A2                 mov     eax, [edx+14h]
.text$mn:0000C1A5                 sub     eax, [ebp+arg_0]
.text$mn:0000C1A8                 push    eax             ; int
.text$mn:0000C1A9                 mov     ecx, [ebp+var_4]
.text$mn:0000C1AC                 call    ?_Myptr@?$_String_val@U?$_Simple_types@_W@std@@@std@@QAEPA_WXZ ; std::_String_val<std::_Simple_types<wchar_t>>::_Myptr(void)
.text$mn:0000C1B1                 mov     ecx, [ebp+arg_0]
.text$mn:0000C1B4                 lea     edx, [eax+ecx*2]
.text$mn:0000C1B7                 push    edx             ; Src
.text$mn:0000C1B8                 mov     ecx, [ebp+var_4]
.text$mn:0000C1BB                 call    ?_Myptr@?$_String_val@U?$_Simple_types@_W@std@@@std@@QAEPA_WXZ ; std::_String_val<std::_Simple_types<wchar_t>>::_Myptr(void)
.text$mn:0000C1C0                 mov     ecx, [ebp+arg_0]
.text$mn:0000C1C3                 lea     edx, [eax+ecx*2]
.text$mn:0000C1C6                 mov     eax, [ebp+arg_4]
.text$mn:0000C1C9                 lea     ecx, [edx+eax*2]
.text$mn:0000C1CC                 push    ecx             ; Dst
.text$mn:0000C1CD                 call    ?move@?$char_traits@_W@std@@SAPA_WPA_WPB_WI@Z ; std::char_traits<wchar_t>::move(wchar_t *,wchar_t const *,uint)
.text$mn:0000C1D2                 add     esp, 0Ch
.text$mn:0000C1D5                 movzx   edx, [ebp+arg_8]
.text$mn:0000C1D9                 push    edx
.text$mn:0000C1DA                 mov     eax, [ebp+arg_4]
.text$mn:0000C1DD                 push    eax
.text$mn:0000C1DE                 mov     ecx, [ebp+arg_0]
.text$mn:0000C1E1                 push    ecx
.text$mn:0000C1E2                 mov     ecx, [ebp+var_4]
.text$mn:0000C1E5                 call    ?_Chassign@?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QAEXII_W@Z ; std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>>::_Chassign(uint,uint,wchar_t)
.text$mn:0000C1EA                 mov     edx, [ebp+var_8]
.text$mn:0000C1ED                 push    edx
.text$mn:0000C1EE                 mov     ecx, [ebp+var_4]
.text$mn:0000C1F1                 call    ?_Eos@?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QAEXI@Z ; std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>>::_Eos(uint)
.text$mn:0000C1F6
.text$mn:0000C1F6 loc_C1F6:                               ; CODE XREF: std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>>::insert(uint,uint,wchar_t)+38j
.text$mn:0000C1F6                                         ; std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>>::insert(uint,uint,wchar_t)+59j
.text$mn:0000C1F6                 mov     eax, [ebp+var_4]
.text$mn:0000C1F9                 mov     esp, ebp
.text$mn:0000C1FB                 pop     ebp
.text$mn:0000C1FC                 retn    0Ch
.text$mn:0000C1FC ?insert@?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QAEAAV12@II_W@Z endp
.text$mn:0000C1FC
.text$mn:0000C1FC ; ---------------------------------------------------------------------------
.text$mn:0000C1FF                 align 10h
.text$mn:0000C1FF _text$mn        ends
.text$mn:0000C1FF
.text$mn:0000C200 ; ===========================================================================
.text$mn:0000C200
.text$mn:0000C200 ; Segment type: Pure code
.text$mn:0000C200 ; Segment permissions: Read/Execute
.text$mn:0000C200 _text$mn        segment para public 'CODE' use32
.text$mn:0000C200                 assume cs:_text$mn
.text$mn:0000C200                 ;org 0C200h
.text$mn:0000C200 ; COMDAT (pick any)
.text$mn:0000C200                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text$mn:0000C200
.text$mn:0000C200 ; =============== S U B R O U T I N E =======================================
.text$mn:0000C200
.text$mn:0000C200 ; Attributes: bp-based frame
.text$mn:0000C200
.text$mn:0000C200 ; public: unsigned int __thiscall std::basic_string<wchar_t, struct std::char_traits<wchar_t>, class std::allocator<wchar_t>>::length(void)const
.text$mn:0000C200                 public ?length@?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QBEIXZ
.text$mn:0000C200 ?length@?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QBEIXZ proc near
.text$mn:0000C200                                         ; CODE XREF: PathAppendW(std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>> &,std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>> const &)+EEp
.text$mn:0000C200                                         ; PathAppendW(std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>> &,std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>> const &)+136p ...
.text$mn:0000C200
.text$mn:0000C200 var_4           = dword ptr -4
.text$mn:0000C200
.text$mn:0000C200                 push    ebp
.text$mn:0000C201                 mov     ebp, esp
.text$mn:0000C203                 push    ecx
.text$mn:0000C204                 mov     [ebp+var_4], ecx
.text$mn:0000C207                 mov     eax, [ebp+var_4]
.text$mn:0000C20A                 mov     eax, [eax+14h]
.text$mn:0000C20D                 mov     esp, ebp
.text$mn:0000C20F                 pop     ebp
.text$mn:0000C210                 retn
.text$mn:0000C210 ?length@?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QBEIXZ endp
.text$mn:0000C210
.text$mn:0000C210 ; ---------------------------------------------------------------------------
.text$mn:0000C211                 align 4
.text$mn:0000C211 _text$mn        ends
.text$mn:0000C211
.text$mn:0000C214 ; ===========================================================================
.text$mn:0000C214
.text$mn:0000C214 ; Segment type: Pure code
.text$mn:0000C214 ; Segment permissions: Read/Execute
.text$mn:0000C214 _text$mn        segment para public 'CODE' use32
.text$mn:0000C214                 assume cs:_text$mn
.text$mn:0000C214                 ;org 0C214h
.text$mn:0000C214 ; COMDAT (pick any)
.text$mn:0000C214                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text$mn:0000C214
.text$mn:0000C214 ; =============== S U B R O U T I N E =======================================
.text$mn:0000C214
.text$mn:0000C214 ; Attributes: bp-based frame
.text$mn:0000C214
.text$mn:0000C214 ; int __cdecl std::char_traits<char>::length(char *Str)
.text$mn:0000C214                 public ?length@?$char_traits@D@std@@SAIPBD@Z
.text$mn:0000C214 ?length@?$char_traits@D@std@@SAIPBD@Z proc near
.text$mn:0000C214                                         ; CODE XREF: std::basic_string<char,std::char_traits<char>,std::allocator<char>>::append(char const *)+21p
.text$mn:0000C214                                         ; std::basic_string<char,std::char_traits<char>,std::allocator<char>>::assign(char const *)+21p
.text$mn:0000C214
.text$mn:0000C214 var_4           = dword ptr -4
.text$mn:0000C214 Str             = dword ptr  8
.text$mn:0000C214
.text$mn:0000C214                 push    ebp
.text$mn:0000C215                 mov     ebp, esp
.text$mn:0000C217                 push    ecx
.text$mn:0000C218                 mov     eax, [ebp+Str]
.text$mn:0000C21B                 movsx   ecx, byte ptr [eax]
.text$mn:0000C21E                 test    ecx, ecx
.text$mn:0000C220                 jnz     short loc_C22B
.text$mn:0000C222                 mov     [ebp+var_4], 0
.text$mn:0000C229                 jmp     short loc_C23A
.text$mn:0000C22B ; ---------------------------------------------------------------------------
.text$mn:0000C22B
.text$mn:0000C22B loc_C22B:                               ; CODE XREF: std::char_traits<char>::length(char const *)+Cj
.text$mn:0000C22B                 mov     edx, [ebp+Str]
.text$mn:0000C22E                 push    edx             ; Str
.text$mn:0000C22F                 call    _strlen
.text$mn:0000C234                 add     esp, 4
.text$mn:0000C237                 mov     [ebp+var_4], eax
.text$mn:0000C23A
.text$mn:0000C23A loc_C23A:                               ; CODE XREF: std::char_traits<char>::length(char const *)+15j
.text$mn:0000C23A                 mov     eax, [ebp+var_4]
.text$mn:0000C23D                 mov     esp, ebp
.text$mn:0000C23F                 pop     ebp
.text$mn:0000C240                 retn
.text$mn:0000C240 ?length@?$char_traits@D@std@@SAIPBD@Z endp
.text$mn:0000C240
.text$mn:0000C240 ; ---------------------------------------------------------------------------
.text$mn:0000C241                 align 4
.text$mn:0000C241 _text$mn        ends
.text$mn:0000C241
.text$mn:0000C244 ; ===========================================================================
.text$mn:0000C244
.text$mn:0000C244 ; Segment type: Pure code
.text$mn:0000C244 ; Segment permissions: Read/Execute
.text$mn:0000C244 _text$mn        segment para public 'CODE' use32
.text$mn:0000C244                 assume cs:_text$mn
.text$mn:0000C244                 ;org 0C244h
.text$mn:0000C244 ; COMDAT (pick any)
.text$mn:0000C244                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text$mn:0000C244
.text$mn:0000C244 ; =============== S U B R O U T I N E =======================================
.text$mn:0000C244
.text$mn:0000C244 ; Attributes: bp-based frame
.text$mn:0000C244
.text$mn:0000C244 ; int __cdecl std::char_traits<wchar_t>::length(wchar_t *Str)
.text$mn:0000C244                 public ?length@?$char_traits@_W@std@@SAIPB_W@Z
.text$mn:0000C244 ?length@?$char_traits@_W@std@@SAIPB_W@Z proc near
.text$mn:0000C244                                         ; CODE XREF: std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>>::append(wchar_t const *)+21p
.text$mn:0000C244                                         ; std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>>::assign(wchar_t const *)+21p ...
.text$mn:0000C244
.text$mn:0000C244 var_4           = dword ptr -4
.text$mn:0000C244 Str             = dword ptr  8
.text$mn:0000C244
.text$mn:0000C244                 push    ebp
.text$mn:0000C245                 mov     ebp, esp
.text$mn:0000C247                 push    ecx
.text$mn:0000C248                 mov     eax, [ebp+Str]
.text$mn:0000C24B                 movzx   ecx, word ptr [eax]
.text$mn:0000C24E                 test    ecx, ecx
.text$mn:0000C250                 jnz     short loc_C25B
.text$mn:0000C252                 mov     [ebp+var_4], 0
.text$mn:0000C259                 jmp     short loc_C26A
.text$mn:0000C25B ; ---------------------------------------------------------------------------
.text$mn:0000C25B
.text$mn:0000C25B loc_C25B:                               ; CODE XREF: std::char_traits<wchar_t>::length(wchar_t const *)+Cj
.text$mn:0000C25B                 mov     edx, [ebp+Str]
.text$mn:0000C25E                 push    edx             ; Str
.text$mn:0000C25F                 call    _wcslen
.text$mn:0000C264                 add     esp, 4
.text$mn:0000C267                 mov     [ebp+var_4], eax
.text$mn:0000C26A
.text$mn:0000C26A loc_C26A:                               ; CODE XREF: std::char_traits<wchar_t>::length(wchar_t const *)+15j
.text$mn:0000C26A                 mov     eax, [ebp+var_4]
.text$mn:0000C26D                 mov     esp, ebp
.text$mn:0000C26F                 pop     ebp
.text$mn:0000C270                 retn
.text$mn:0000C270 ?length@?$char_traits@_W@std@@SAIPB_W@Z endp
.text$mn:0000C270
.text$mn:0000C270 ; ---------------------------------------------------------------------------
.text$mn:0000C271                 align 4
.text$mn:0000C271 _text$mn        ends
.text$mn:0000C271
.text$mn:0000C274 ; ===========================================================================
.text$mn:0000C274
.text$mn:0000C274 ; Segment type: Pure code
.text$mn:0000C274 ; Segment permissions: Read/Execute
.text$mn:0000C274 _text$mn        segment para public 'CODE' use32
.text$mn:0000C274                 assume cs:_text$mn
.text$mn:0000C274                 ;org 0C274h
.text$mn:0000C274 ; COMDAT (pick any)
.text$mn:0000C274                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text$mn:0000C274
.text$mn:0000C274 ; =============== S U B R O U T I N E =======================================
.text$mn:0000C274
.text$mn:0000C274 ; Attributes: bp-based frame
.text$mn:0000C274
.text$mn:0000C274 ; public: unsigned int __thiscall std::_Wrap_alloc<class std::allocator<char>>::max_size(void)const
.text$mn:0000C274                 public ?max_size@?$_Wrap_alloc@V?$allocator@D@std@@@std@@QBEIXZ
.text$mn:0000C274 ?max_size@?$_Wrap_alloc@V?$allocator@D@std@@@std@@QBEIXZ proc near
.text$mn:0000C274                                         ; CODE XREF: std::basic_string<char,std::char_traits<char>,std::allocator<char>>::max_size(void)+17p
.text$mn:0000C274                                         ; std::vector<char,std::allocator<char>>::max_size(void)+17p
.text$mn:0000C274
.text$mn:0000C274 var_4           = dword ptr -4
.text$mn:0000C274
.text$mn:0000C274                 push    ebp
.text$mn:0000C275                 mov     ebp, esp
.text$mn:0000C277                 push    ecx
.text$mn:0000C278                 mov     [ebp+var_4], ecx
.text$mn:0000C27B                 mov     eax, [ebp+var_4]
.text$mn:0000C27E                 push    eax
.text$mn:0000C27F                 call    ?max_size@?$allocator_traits@V?$allocator@D@std@@@std@@SAIABV?$allocator@D@2@@Z ; std::allocator_traits<std::allocator<char>>::max_size(std::allocator<char> const &)
.text$mn:0000C284                 add     esp, 4
.text$mn:0000C287                 mov     esp, ebp
.text$mn:0000C289                 pop     ebp
.text$mn:0000C28A                 retn
.text$mn:0000C28A ?max_size@?$_Wrap_alloc@V?$allocator@D@std@@@std@@QBEIXZ endp
.text$mn:0000C28A
.text$mn:0000C28A ; ---------------------------------------------------------------------------
.text$mn:0000C28B                 align 4
.text$mn:0000C28B _text$mn        ends
.text$mn:0000C28B
.text$mn:0000C28C ; ===========================================================================
.text$mn:0000C28C
.text$mn:0000C28C ; Segment type: Pure code
.text$mn:0000C28C ; Segment permissions: Read/Execute
.text$mn:0000C28C _text$mn        segment para public 'CODE' use32
.text$mn:0000C28C                 assume cs:_text$mn
.text$mn:0000C28C                 ;org 0C28Ch
.text$mn:0000C28C ; COMDAT (pick any)
.text$mn:0000C28C                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text$mn:0000C28C
.text$mn:0000C28C ; =============== S U B R O U T I N E =======================================
.text$mn:0000C28C
.text$mn:0000C28C ; Attributes: bp-based frame
.text$mn:0000C28C
.text$mn:0000C28C ; public: unsigned int __thiscall std::_Wrap_alloc<class std::allocator<class std::basic_string<wchar_t, struct std::char_traits<wchar_t>, class std::allocator<wchar_t>>>>::max_size(void)const
.text$mn:0000C28C                 public ?max_size@?$_Wrap_alloc@V?$allocator@V?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@@std@@@std@@QBEIXZ
.text$mn:0000C28C ?max_size@?$_Wrap_alloc@V?$allocator@V?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@@std@@@std@@QBEIXZ proc near
.text$mn:0000C28C                                         ; CODE XREF: std::vector<std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>>,std::allocator<std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>>>>::max_size(void)+17p
.text$mn:0000C28C
.text$mn:0000C28C var_4           = dword ptr -4
.text$mn:0000C28C
.text$mn:0000C28C                 push    ebp
.text$mn:0000C28D                 mov     ebp, esp
.text$mn:0000C28F                 push    ecx
.text$mn:0000C290                 mov     [ebp+var_4], ecx
.text$mn:0000C293                 mov     eax, [ebp+var_4]
.text$mn:0000C296                 push    eax
.text$mn:0000C297                 call    ?max_size@?$allocator_traits@V?$allocator@V?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@@std@@@std@@SAIABV?$allocator@V?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@@2@@Z ; std::allocator_traits<std::allocator<std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>>>>::max_size(std::allocator<std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>>> const &)
.text$mn:0000C29C                 add     esp, 4
.text$mn:0000C29F                 mov     esp, ebp
.text$mn:0000C2A1                 pop     ebp
.text$mn:0000C2A2                 retn
.text$mn:0000C2A2 ?max_size@?$_Wrap_alloc@V?$allocator@V?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@@std@@@std@@QBEIXZ endp
.text$mn:0000C2A2
.text$mn:0000C2A2 ; ---------------------------------------------------------------------------
.text$mn:0000C2A3                 align 4
.text$mn:0000C2A3 _text$mn        ends
.text$mn:0000C2A3
.text$mn:0000C2A4 ; ===========================================================================
.text$mn:0000C2A4
.text$mn:0000C2A4 ; Segment type: Pure code
.text$mn:0000C2A4 ; Segment permissions: Read/Execute
.text$mn:0000C2A4 _text$mn        segment para public 'CODE' use32
.text$mn:0000C2A4                 assume cs:_text$mn
.text$mn:0000C2A4                 ;org 0C2A4h
.text$mn:0000C2A4 ; COMDAT (pick any)
.text$mn:0000C2A4                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text$mn:0000C2A4
.text$mn:0000C2A4 ; =============== S U B R O U T I N E =======================================
.text$mn:0000C2A4
.text$mn:0000C2A4 ; Attributes: bp-based frame
.text$mn:0000C2A4
.text$mn:0000C2A4 ; public: unsigned int __thiscall std::_Wrap_alloc<class std::allocator<wchar_t>>::max_size(void)const
.text$mn:0000C2A4                 public ?max_size@?$_Wrap_alloc@V?$allocator@_W@std@@@std@@QBEIXZ
.text$mn:0000C2A4 ?max_size@?$_Wrap_alloc@V?$allocator@_W@std@@@std@@QBEIXZ proc near
.text$mn:0000C2A4                                         ; CODE XREF: std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>>::max_size(void)+17p
.text$mn:0000C2A4                                         ; std::vector<wchar_t,std::allocator<wchar_t>>::max_size(void)+17p
.text$mn:0000C2A4
.text$mn:0000C2A4 var_4           = dword ptr -4
.text$mn:0000C2A4
.text$mn:0000C2A4                 push    ebp
.text$mn:0000C2A5                 mov     ebp, esp
.text$mn:0000C2A7                 push    ecx
.text$mn:0000C2A8                 mov     [ebp+var_4], ecx
.text$mn:0000C2AB                 mov     eax, [ebp+var_4]
.text$mn:0000C2AE                 push    eax
.text$mn:0000C2AF                 call    ?max_size@?$allocator_traits@V?$allocator@_W@std@@@std@@SAIABV?$allocator@_W@2@@Z ; std::allocator_traits<std::allocator<wchar_t>>::max_size(std::allocator<wchar_t> const &)
.text$mn:0000C2B4                 add     esp, 4
.text$mn:0000C2B7                 mov     esp, ebp
.text$mn:0000C2B9                 pop     ebp
.text$mn:0000C2BA                 retn
.text$mn:0000C2BA ?max_size@?$_Wrap_alloc@V?$allocator@_W@std@@@std@@QBEIXZ endp
.text$mn:0000C2BA
.text$mn:0000C2BA ; ---------------------------------------------------------------------------
.text$mn:0000C2BB                 align 4
.text$mn:0000C2BB _text$mn        ends
.text$mn:0000C2BB
.text$mn:0000C2BC ; ===========================================================================
.text$mn:0000C2BC
.text$mn:0000C2BC ; Segment type: Pure code
.text$mn:0000C2BC ; Segment permissions: Read/Execute
.text$mn:0000C2BC _text$mn        segment para public 'CODE' use32
.text$mn:0000C2BC                 assume cs:_text$mn
.text$mn:0000C2BC                 ;org 0C2BCh
.text$mn:0000C2BC ; COMDAT (pick any)
.text$mn:0000C2BC                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text$mn:0000C2BC
.text$mn:0000C2BC ; =============== S U B R O U T I N E =======================================
.text$mn:0000C2BC
.text$mn:0000C2BC ; Attributes: bp-based frame
.text$mn:0000C2BC
.text$mn:0000C2BC ; public: unsigned int __thiscall std::allocator<char>::max_size(void)const
.text$mn:0000C2BC                 public ?max_size@?$allocator@D@std@@QBEIXZ
.text$mn:0000C2BC ?max_size@?$allocator@D@std@@QBEIXZ proc near
.text$mn:0000C2BC                                         ; CODE XREF: std::allocator_traits<std::allocator<char>>::max_size(std::allocator<char> const &)+6p
.text$mn:0000C2BC
.text$mn:0000C2BC var_4           = dword ptr -4
.text$mn:0000C2BC
.text$mn:0000C2BC                 push    ebp
.text$mn:0000C2BD                 mov     ebp, esp
.text$mn:0000C2BF                 push    ecx
.text$mn:0000C2C0                 mov     [ebp+var_4], ecx
.text$mn:0000C2C3                 or      eax, 0FFFFFFFFh
.text$mn:0000C2C6                 mov     esp, ebp
.text$mn:0000C2C8                 pop     ebp
.text$mn:0000C2C9                 retn
.text$mn:0000C2C9 ?max_size@?$allocator@D@std@@QBEIXZ endp
.text$mn:0000C2C9
.text$mn:0000C2C9 ; ---------------------------------------------------------------------------
.text$mn:0000C2CA                 align 4
.text$mn:0000C2CA _text$mn        ends
.text$mn:0000C2CA
.text$mn:0000C2CC ; ===========================================================================
.text$mn:0000C2CC
.text$mn:0000C2CC ; Segment type: Pure code
.text$mn:0000C2CC ; Segment permissions: Read/Execute
.text$mn:0000C2CC _text$mn        segment para public 'CODE' use32
.text$mn:0000C2CC                 assume cs:_text$mn
.text$mn:0000C2CC                 ;org 0C2CCh
.text$mn:0000C2CC ; COMDAT (pick any)
.text$mn:0000C2CC                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text$mn:0000C2CC
.text$mn:0000C2CC ; =============== S U B R O U T I N E =======================================
.text$mn:0000C2CC
.text$mn:0000C2CC ; Attributes: bp-based frame
.text$mn:0000C2CC
.text$mn:0000C2CC ; public: unsigned int __thiscall std::allocator<class std::basic_string<wchar_t, struct std::char_traits<wchar_t>, class std::allocator<wchar_t>>>::max_size(void)const
.text$mn:0000C2CC                 public ?max_size@?$allocator@V?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@@std@@QBEIXZ
.text$mn:0000C2CC ?max_size@?$allocator@V?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@@std@@QBEIXZ proc near
.text$mn:0000C2CC                                         ; CODE XREF: std::allocator_traits<std::allocator<std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>>>>::max_size(std::allocator<std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>>> const &)+6p
.text$mn:0000C2CC
.text$mn:0000C2CC var_4           = dword ptr -4
.text$mn:0000C2CC
.text$mn:0000C2CC                 push    ebp
.text$mn:0000C2CD                 mov     ebp, esp
.text$mn:0000C2CF                 push    ecx
.text$mn:0000C2D0                 mov     [ebp+var_4], ecx
.text$mn:0000C2D3                 mov     eax, 9249249h
.text$mn:0000C2D8                 mov     esp, ebp
.text$mn:0000C2DA                 pop     ebp
.text$mn:0000C2DB                 retn
.text$mn:0000C2DB ?max_size@?$allocator@V?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@@std@@QBEIXZ endp
.text$mn:0000C2DB
.text$mn:0000C2DB _text$mn        ends
.text$mn:0000C2DB
.text$mn:0000C2DC ; ===========================================================================
.text$mn:0000C2DC
.text$mn:0000C2DC ; Segment type: Pure code
.text$mn:0000C2DC ; Segment permissions: Read/Execute
.text$mn:0000C2DC _text$mn        segment para public 'CODE' use32
.text$mn:0000C2DC                 assume cs:_text$mn
.text$mn:0000C2DC                 ;org 0C2DCh
.text$mn:0000C2DC ; COMDAT (pick any)
.text$mn:0000C2DC                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text$mn:0000C2DC
.text$mn:0000C2DC ; =============== S U B R O U T I N E =======================================
.text$mn:0000C2DC
.text$mn:0000C2DC ; Attributes: bp-based frame
.text$mn:0000C2DC
.text$mn:0000C2DC ; public: unsigned int __thiscall std::allocator<wchar_t>::max_size(void)const
.text$mn:0000C2DC                 public ?max_size@?$allocator@_W@std@@QBEIXZ
.text$mn:0000C2DC ?max_size@?$allocator@_W@std@@QBEIXZ proc near
.text$mn:0000C2DC                                         ; CODE XREF: std::allocator_traits<std::allocator<wchar_t>>::max_size(std::allocator<wchar_t> const &)+6p
.text$mn:0000C2DC
.text$mn:0000C2DC var_4           = dword ptr -4
.text$mn:0000C2DC
.text$mn:0000C2DC                 push    ebp
.text$mn:0000C2DD                 mov     ebp, esp
.text$mn:0000C2DF                 push    ecx
.text$mn:0000C2E0                 mov     [ebp+var_4], ecx
.text$mn:0000C2E3                 mov     eax, 7FFFFFFFh
.text$mn:0000C2E8                 mov     esp, ebp
.text$mn:0000C2EA                 pop     ebp
.text$mn:0000C2EB                 retn
.text$mn:0000C2EB ?max_size@?$allocator@_W@std@@QBEIXZ endp
.text$mn:0000C2EB
.text$mn:0000C2EB _text$mn        ends
.text$mn:0000C2EB
.text$mn:0000C2EC ; ===========================================================================
.text$mn:0000C2EC
.text$mn:0000C2EC ; Segment type: Pure code
.text$mn:0000C2EC ; Segment permissions: Read/Execute
.text$mn:0000C2EC _text$mn        segment para public 'CODE' use32
.text$mn:0000C2EC                 assume cs:_text$mn
.text$mn:0000C2EC                 ;org 0C2ECh
.text$mn:0000C2EC ; COMDAT (pick any)
.text$mn:0000C2EC                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text$mn:0000C2EC
.text$mn:0000C2EC ; =============== S U B R O U T I N E =======================================
.text$mn:0000C2EC
.text$mn:0000C2EC ; Attributes: bp-based frame
.text$mn:0000C2EC
.text$mn:0000C2EC ; public: static unsigned int __cdecl std::allocator_traits<class std::allocator<char>>::max_size(class std::allocator<char> const &)
.text$mn:0000C2EC                 public ?max_size@?$allocator_traits@V?$allocator@D@std@@@std@@SAIABV?$allocator@D@2@@Z
.text$mn:0000C2EC ?max_size@?$allocator_traits@V?$allocator@D@std@@@std@@SAIABV?$allocator@D@2@@Z proc near
.text$mn:0000C2EC                                         ; CODE XREF: std::_Wrap_alloc<std::allocator<char>>::max_size(void)+Bp
.text$mn:0000C2EC
.text$mn:0000C2EC arg_0           = dword ptr  8
.text$mn:0000C2EC
.text$mn:0000C2EC                 push    ebp
.text$mn:0000C2ED                 mov     ebp, esp
.text$mn:0000C2EF                 mov     ecx, [ebp+arg_0]
.text$mn:0000C2F2                 call    ?max_size@?$allocator@D@std@@QBEIXZ ; std::allocator<char>::max_size(void)
.text$mn:0000C2F7                 pop     ebp
.text$mn:0000C2F8                 retn
.text$mn:0000C2F8 ?max_size@?$allocator_traits@V?$allocator@D@std@@@std@@SAIABV?$allocator@D@2@@Z endp
.text$mn:0000C2F8
.text$mn:0000C2F8 ; ---------------------------------------------------------------------------
.text$mn:0000C2F9                 align 4
.text$mn:0000C2F9 _text$mn        ends
.text$mn:0000C2F9
.text$mn:0000C2FC ; ===========================================================================
.text$mn:0000C2FC
.text$mn:0000C2FC ; Segment type: Pure code
.text$mn:0000C2FC ; Segment permissions: Read/Execute
.text$mn:0000C2FC _text$mn        segment para public 'CODE' use32
.text$mn:0000C2FC                 assume cs:_text$mn
.text$mn:0000C2FC                 ;org 0C2FCh
.text$mn:0000C2FC ; COMDAT (pick any)
.text$mn:0000C2FC                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text$mn:0000C2FC
.text$mn:0000C2FC ; =============== S U B R O U T I N E =======================================
.text$mn:0000C2FC
.text$mn:0000C2FC ; Attributes: bp-based frame
.text$mn:0000C2FC
.text$mn:0000C2FC ; public: static unsigned int __cdecl std::allocator_traits<class std::allocator<class std::basic_string<wchar_t, struct std::char_traits<wchar_t>, class std::allocator<wchar_t>>>>::max_size(class std::allocator<class std::basic_string<wchar_t, struct std::char_traits<wchar_t>, class std::allocator<wchar_t>>> const &)
.text$mn:0000C2FC                 public ?max_size@?$allocator_traits@V?$allocator@V?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@@std@@@std@@SAIABV?$allocator@V?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@@2@@Z
.text$mn:0000C2FC ?max_size@?$allocator_traits@V?$allocator@V?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@@std@@@std@@SAIABV?$allocator@V?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@@2@@Z proc near
.text$mn:0000C2FC                                         ; CODE XREF: std::_Wrap_alloc<std::allocator<std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>>>>::max_size(void)+Bp
.text$mn:0000C2FC
.text$mn:0000C2FC arg_0           = dword ptr  8
.text$mn:0000C2FC
.text$mn:0000C2FC                 push    ebp
.text$mn:0000C2FD                 mov     ebp, esp
.text$mn:0000C2FF                 mov     ecx, [ebp+arg_0]
.text$mn:0000C302                 call    ?max_size@?$allocator@V?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@@std@@QBEIXZ ; std::allocator<std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>>>::max_size(void)
.text$mn:0000C307                 pop     ebp
.text$mn:0000C308                 retn
.text$mn:0000C308 ?max_size@?$allocator_traits@V?$allocator@V?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@@std@@@std@@SAIABV?$allocator@V?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@@2@@Z endp
.text$mn:0000C308
.text$mn:0000C308 ; ---------------------------------------------------------------------------
.text$mn:0000C309                 align 4
.text$mn:0000C309 _text$mn        ends
.text$mn:0000C309
.text$mn:0000C30C ; ===========================================================================
.text$mn:0000C30C
.text$mn:0000C30C ; Segment type: Pure code
.text$mn:0000C30C ; Segment permissions: Read/Execute
.text$mn:0000C30C _text$mn        segment para public 'CODE' use32
.text$mn:0000C30C                 assume cs:_text$mn
.text$mn:0000C30C                 ;org 0C30Ch
.text$mn:0000C30C ; COMDAT (pick any)
.text$mn:0000C30C                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text$mn:0000C30C
.text$mn:0000C30C ; =============== S U B R O U T I N E =======================================
.text$mn:0000C30C
.text$mn:0000C30C ; Attributes: bp-based frame
.text$mn:0000C30C
.text$mn:0000C30C ; public: static unsigned int __cdecl std::allocator_traits<class std::allocator<wchar_t>>::max_size(class std::allocator<wchar_t> const &)
.text$mn:0000C30C                 public ?max_size@?$allocator_traits@V?$allocator@_W@std@@@std@@SAIABV?$allocator@_W@2@@Z
.text$mn:0000C30C ?max_size@?$allocator_traits@V?$allocator@_W@std@@@std@@SAIABV?$allocator@_W@2@@Z proc near
.text$mn:0000C30C                                         ; CODE XREF: std::_Wrap_alloc<std::allocator<wchar_t>>::max_size(void)+Bp
.text$mn:0000C30C
.text$mn:0000C30C arg_0           = dword ptr  8
.text$mn:0000C30C
.text$mn:0000C30C                 push    ebp
.text$mn:0000C30D                 mov     ebp, esp
.text$mn:0000C30F                 mov     ecx, [ebp+arg_0]
.text$mn:0000C312                 call    ?max_size@?$allocator@_W@std@@QBEIXZ ; std::allocator<wchar_t>::max_size(void)
.text$mn:0000C317                 pop     ebp
.text$mn:0000C318                 retn
.text$mn:0000C318 ?max_size@?$allocator_traits@V?$allocator@_W@std@@@std@@SAIABV?$allocator@_W@2@@Z endp
.text$mn:0000C318
.text$mn:0000C318 ; ---------------------------------------------------------------------------
.text$mn:0000C319                 align 4
.text$mn:0000C319 _text$mn        ends
.text$mn:0000C319
.text$mn:0000C31C ; ===========================================================================
.text$mn:0000C31C
.text$mn:0000C31C ; Segment type: Pure code
.text$mn:0000C31C ; Segment permissions: Read/Execute
.text$mn:0000C31C _text$mn        segment para public 'CODE' use32
.text$mn:0000C31C                 assume cs:_text$mn
.text$mn:0000C31C                 ;org 0C31Ch
.text$mn:0000C31C ; COMDAT (pick any)
.text$mn:0000C31C                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text$mn:0000C31C
.text$mn:0000C31C ; =============== S U B R O U T I N E =======================================
.text$mn:0000C31C
.text$mn:0000C31C ; Attributes: bp-based frame
.text$mn:0000C31C
.text$mn:0000C31C ; public: unsigned int __thiscall std::basic_string<char, struct std::char_traits<char>, class std::allocator<char>>::max_size(void)const
.text$mn:0000C31C                 public ?max_size@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QBEIXZ
.text$mn:0000C31C ?max_size@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QBEIXZ proc near
.text$mn:0000C31C                                         ; CODE XREF: std::basic_string<char,std::char_traits<char>,std::allocator<char>>::_Copy(uint,uint)+3Bp
.text$mn:0000C31C                                         ; std::basic_string<char,std::char_traits<char>,std::allocator<char>>::_Copy(uint,uint)+6Ap ...
.text$mn:0000C31C
.text$mn:0000C31C var_10          = dword ptr -10h
.text$mn:0000C31C var_C           = dword ptr -0Ch
.text$mn:0000C31C var_8           = dword ptr -8
.text$mn:0000C31C var_1           = byte ptr -1
.text$mn:0000C31C
.text$mn:0000C31C                 push    ebp
.text$mn:0000C31D                 mov     ebp, esp
.text$mn:0000C31F                 sub     esp, 10h
.text$mn:0000C322                 mov     [ebp+var_10], ecx
.text$mn:0000C325                 lea     eax, [ebp+var_1]
.text$mn:0000C328                 push    eax
.text$mn:0000C329                 mov     ecx, [ebp+var_10]
.text$mn:0000C32C                 call    ?_Getal@?$_String_alloc@$0A@U?$_String_base_types@DV?$allocator@D@std@@@std@@@std@@QBE?AU?$_Wrap_alloc@V?$allocator@D@std@@@2@XZ ; std::_String_alloc<0,std::_String_base_types<char,std::allocator<char>>>::_Getal(void)
.text$mn:0000C331                 mov     ecx, eax
.text$mn:0000C333                 call    ?max_size@?$_Wrap_alloc@V?$allocator@D@std@@@std@@QBEIXZ ; std::_Wrap_alloc<std::allocator<char>>::max_size(void)
.text$mn:0000C338                 mov     [ebp+var_8], eax
.text$mn:0000C33B                 cmp     [ebp+var_8], 1
.text$mn:0000C33F                 ja      short loc_C34A
.text$mn:0000C341                 mov     [ebp+var_C], 1
.text$mn:0000C348                 jmp     short loc_C353
.text$mn:0000C34A ; ---------------------------------------------------------------------------
.text$mn:0000C34A
.text$mn:0000C34A loc_C34A:                               ; CODE XREF: std::basic_string<char,std::char_traits<char>,std::allocator<char>>::max_size(void)+23j
.text$mn:0000C34A                 mov     ecx, [ebp+var_8]
.text$mn:0000C34D                 sub     ecx, 1
.text$mn:0000C350                 mov     [ebp+var_C], ecx
.text$mn:0000C353
.text$mn:0000C353 loc_C353:                               ; CODE XREF: std::basic_string<char,std::char_traits<char>,std::allocator<char>>::max_size(void)+2Cj
.text$mn:0000C353                 mov     eax, [ebp+var_C]
.text$mn:0000C356                 mov     esp, ebp
.text$mn:0000C358                 pop     ebp
.text$mn:0000C359                 retn
.text$mn:0000C359 ?max_size@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QBEIXZ endp
.text$mn:0000C359
.text$mn:0000C359 ; ---------------------------------------------------------------------------
.text$mn:0000C35A                 align 4
.text$mn:0000C35A _text$mn        ends
.text$mn:0000C35A
.text$mn:0000C35C ; ===========================================================================
.text$mn:0000C35C
.text$mn:0000C35C ; Segment type: Pure code
.text$mn:0000C35C ; Segment permissions: Read/Execute
.text$mn:0000C35C _text$mn        segment para public 'CODE' use32
.text$mn:0000C35C                 assume cs:_text$mn
.text$mn:0000C35C                 ;org 0C35Ch
.text$mn:0000C35C ; COMDAT (pick any)
.text$mn:0000C35C                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text$mn:0000C35C
.text$mn:0000C35C ; =============== S U B R O U T I N E =======================================
.text$mn:0000C35C
.text$mn:0000C35C ; Attributes: bp-based frame
.text$mn:0000C35C
.text$mn:0000C35C ; public: unsigned int __thiscall std::basic_string<wchar_t, struct std::char_traits<wchar_t>, class std::allocator<wchar_t>>::max_size(void)const
.text$mn:0000C35C                 public ?max_size@?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QBEIXZ
.text$mn:0000C35C ?max_size@?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QBEIXZ proc near
.text$mn:0000C35C                                         ; CODE XREF: std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>>::_Copy(uint,uint)+3Bp
.text$mn:0000C35C                                         ; std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>>::_Copy(uint,uint)+6Ap ...
.text$mn:0000C35C
.text$mn:0000C35C var_10          = dword ptr -10h
.text$mn:0000C35C var_C           = dword ptr -0Ch
.text$mn:0000C35C var_8           = dword ptr -8
.text$mn:0000C35C var_1           = byte ptr -1
.text$mn:0000C35C
.text$mn:0000C35C                 push    ebp
.text$mn:0000C35D                 mov     ebp, esp
.text$mn:0000C35F                 sub     esp, 10h
.text$mn:0000C362                 mov     [ebp+var_10], ecx
.text$mn:0000C365                 lea     eax, [ebp+var_1]
.text$mn:0000C368                 push    eax
.text$mn:0000C369                 mov     ecx, [ebp+var_10]
.text$mn:0000C36C                 call    ?_Getal@?$_String_alloc@$0A@U?$_String_base_types@_WV?$allocator@_W@std@@@std@@@std@@QBE?AU?$_Wrap_alloc@V?$allocator@_W@std@@@2@XZ ; std::_String_alloc<0,std::_String_base_types<wchar_t,std::allocator<wchar_t>>>::_Getal(void)
.text$mn:0000C371                 mov     ecx, eax
.text$mn:0000C373                 call    ?max_size@?$_Wrap_alloc@V?$allocator@_W@std@@@std@@QBEIXZ ; std::_Wrap_alloc<std::allocator<wchar_t>>::max_size(void)
.text$mn:0000C378                 mov     [ebp+var_8], eax
.text$mn:0000C37B                 cmp     [ebp+var_8], 1
.text$mn:0000C37F                 ja      short loc_C38A
.text$mn:0000C381                 mov     [ebp+var_C], 1
.text$mn:0000C388                 jmp     short loc_C393
.text$mn:0000C38A ; ---------------------------------------------------------------------------
.text$mn:0000C38A
.text$mn:0000C38A loc_C38A:                               ; CODE XREF: std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>>::max_size(void)+23j
.text$mn:0000C38A                 mov     ecx, [ebp+var_8]
.text$mn:0000C38D                 sub     ecx, 1
.text$mn:0000C390                 mov     [ebp+var_C], ecx
.text$mn:0000C393
.text$mn:0000C393 loc_C393:                               ; CODE XREF: std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>>::max_size(void)+2Cj
.text$mn:0000C393                 mov     eax, [ebp+var_C]
.text$mn:0000C396                 mov     esp, ebp
.text$mn:0000C398                 pop     ebp
.text$mn:0000C399                 retn
.text$mn:0000C399 ?max_size@?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QBEIXZ endp
.text$mn:0000C399
.text$mn:0000C399 ; ---------------------------------------------------------------------------
.text$mn:0000C39A                 align 4
.text$mn:0000C39A _text$mn        ends
.text$mn:0000C39A
.text$mn:0000C39C ; ===========================================================================
.text$mn:0000C39C
.text$mn:0000C39C ; Segment type: Pure code
.text$mn:0000C39C ; Segment permissions: Read/Execute
.text$mn:0000C39C _text$mn        segment para public 'CODE' use32
.text$mn:0000C39C                 assume cs:_text$mn
.text$mn:0000C39C                 ;org 0C39Ch
.text$mn:0000C39C ; COMDAT (pick any)
.text$mn:0000C39C                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text$mn:0000C39C
.text$mn:0000C39C ; =============== S U B R O U T I N E =======================================
.text$mn:0000C39C
.text$mn:0000C39C ; Attributes: bp-based frame
.text$mn:0000C39C
.text$mn:0000C39C ; public: unsigned int __thiscall std::vector<char, class std::allocator<char>>::max_size(void)const
.text$mn:0000C39C                 public ?max_size@?$vector@DV?$allocator@D@std@@@std@@QBEIXZ
.text$mn:0000C39C ?max_size@?$vector@DV?$allocator@D@std@@@std@@QBEIXZ proc near
.text$mn:0000C39C                                         ; CODE XREF: std::vector<char,std::allocator<char>>::_Buy(uint)+36p
.text$mn:0000C39C
.text$mn:0000C39C var_8           = dword ptr -8
.text$mn:0000C39C var_1           = byte ptr -1
.text$mn:0000C39C
.text$mn:0000C39C                 push    ebp
.text$mn:0000C39D                 mov     ebp, esp
.text$mn:0000C39F                 sub     esp, 8
.text$mn:0000C3A2                 mov     [ebp+var_8], ecx
.text$mn:0000C3A5                 lea     eax, [ebp+var_1]
.text$mn:0000C3A8                 push    eax
.text$mn:0000C3A9                 mov     ecx, [ebp+var_8]
.text$mn:0000C3AC                 call    ?_Getal@?$_Vector_alloc@$0A@U?$_Vec_base_types@DV?$allocator@D@std@@@std@@@std@@QBE?AU?$_Wrap_alloc@V?$allocator@D@std@@@2@XZ ; std::_Vector_alloc<0,std::_Vec_base_types<char,std::allocator<char>>>::_Getal(void)
.text$mn:0000C3B1                 mov     ecx, eax
.text$mn:0000C3B3                 call    ?max_size@?$_Wrap_alloc@V?$allocator@D@std@@@std@@QBEIXZ ; std::_Wrap_alloc<std::allocator<char>>::max_size(void)
.text$mn:0000C3B8                 mov     esp, ebp
.text$mn:0000C3BA                 pop     ebp
.text$mn:0000C3BB                 retn
.text$mn:0000C3BB ?max_size@?$vector@DV?$allocator@D@std@@@std@@QBEIXZ endp
.text$mn:0000C3BB
.text$mn:0000C3BB _text$mn        ends
.text$mn:0000C3BB
.text$mn:0000C3BC ; ===========================================================================
.text$mn:0000C3BC
.text$mn:0000C3BC ; Segment type: Pure code
.text$mn:0000C3BC ; Segment permissions: Read/Execute
.text$mn:0000C3BC _text$mn        segment para public 'CODE' use32
.text$mn:0000C3BC                 assume cs:_text$mn
.text$mn:0000C3BC                 ;org 0C3BCh
.text$mn:0000C3BC ; COMDAT (pick any)
.text$mn:0000C3BC                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text$mn:0000C3BC
.text$mn:0000C3BC ; =============== S U B R O U T I N E =======================================
.text$mn:0000C3BC
.text$mn:0000C3BC ; Attributes: bp-based frame
.text$mn:0000C3BC
.text$mn:0000C3BC ; public: unsigned int __thiscall std::vector<class std::basic_string<wchar_t, struct std::char_traits<wchar_t>, class std::allocator<wchar_t>>, class std::allocator<class std::basic_string<wchar_t, struct std::char_traits<wchar_t>, class std::allocator<wchar_t>>>>::max_size(void)const
.text$mn:0000C3BC                 public ?max_size@?$vector@V?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@V?$allocator@V?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@@2@@std@@QBEIXZ
.text$mn:0000C3BC ?max_size@?$vector@V?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@V?$allocator@V?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@@2@@std@@QBEIXZ proc near
.text$mn:0000C3BC                                         ; CODE XREF: std::vector<std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>>,std::allocator<std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>>>>::_Grow_to(uint)+17p
.text$mn:0000C3BC                                         ; std::vector<std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>>,std::allocator<std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>>>>::_Reserve(uint)+18p
.text$mn:0000C3BC
.text$mn:0000C3BC var_8           = dword ptr -8
.text$mn:0000C3BC var_1           = byte ptr -1
.text$mn:0000C3BC
.text$mn:0000C3BC                 push    ebp
.text$mn:0000C3BD                 mov     ebp, esp
.text$mn:0000C3BF                 sub     esp, 8
.text$mn:0000C3C2                 mov     [ebp+var_8], ecx
.text$mn:0000C3C5                 lea     eax, [ebp+var_1]
.text$mn:0000C3C8                 push    eax
.text$mn:0000C3C9                 mov     ecx, [ebp+var_8]
.text$mn:0000C3CC                 call    ?_Getal@?$_Vector_alloc@$0A@U?$_Vec_base_types@V?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@V?$allocator@V?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@@2@@std@@@std@@QBE?AU?$_Wrap_alloc@V?$allocator@V?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@@std@@@2@XZ ; std::_Vector_alloc<0,std::_Vec_base_types<std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>>,std::allocator<std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>>>>>::_Getal(void)
.text$mn:0000C3D1                 mov     ecx, eax
.text$mn:0000C3D3                 call    ?max_size@?$_Wrap_alloc@V?$allocator@V?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@@std@@@std@@QBEIXZ ; std::_Wrap_alloc<std::allocator<std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>>>>::max_size(void)
.text$mn:0000C3D8                 mov     esp, ebp
.text$mn:0000C3DA                 pop     ebp
.text$mn:0000C3DB                 retn
.text$mn:0000C3DB ?max_size@?$vector@V?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@V?$allocator@V?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@@2@@std@@QBEIXZ endp
.text$mn:0000C3DB
.text$mn:0000C3DB _text$mn        ends
.text$mn:0000C3DB
.text$mn:0000C3DC ; ===========================================================================
.text$mn:0000C3DC
.text$mn:0000C3DC ; Segment type: Pure code
.text$mn:0000C3DC ; Segment permissions: Read/Execute
.text$mn:0000C3DC _text$mn        segment para public 'CODE' use32
.text$mn:0000C3DC                 assume cs:_text$mn
.text$mn:0000C3DC                 ;org 0C3DCh
.text$mn:0000C3DC ; COMDAT (pick any)
.text$mn:0000C3DC                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text$mn:0000C3DC
.text$mn:0000C3DC ; =============== S U B R O U T I N E =======================================
.text$mn:0000C3DC
.text$mn:0000C3DC ; Attributes: bp-based frame
.text$mn:0000C3DC
.text$mn:0000C3DC ; public: unsigned int __thiscall std::vector<wchar_t, class std::allocator<wchar_t>>::max_size(void)const
.text$mn:0000C3DC                 public ?max_size@?$vector@_WV?$allocator@_W@std@@@std@@QBEIXZ
.text$mn:0000C3DC ?max_size@?$vector@_WV?$allocator@_W@std@@@std@@QBEIXZ proc near
.text$mn:0000C3DC                                         ; CODE XREF: std::vector<wchar_t,std::allocator<wchar_t>>::_Buy(uint)+36p
.text$mn:0000C3DC                                         ; std::vector<wchar_t,std::allocator<wchar_t>>::_Grow_to(uint)+17p ...
.text$mn:0000C3DC
.text$mn:0000C3DC var_8           = dword ptr -8
.text$mn:0000C3DC var_1           = byte ptr -1
.text$mn:0000C3DC
.text$mn:0000C3DC                 push    ebp
.text$mn:0000C3DD                 mov     ebp, esp
.text$mn:0000C3DF                 sub     esp, 8
.text$mn:0000C3E2                 mov     [ebp+var_8], ecx
.text$mn:0000C3E5                 lea     eax, [ebp+var_1]
.text$mn:0000C3E8                 push    eax
.text$mn:0000C3E9                 mov     ecx, [ebp+var_8]
.text$mn:0000C3EC                 call    ?_Getal@?$_Vector_alloc@$0A@U?$_Vec_base_types@_WV?$allocator@_W@std@@@std@@@std@@QBE?AU?$_Wrap_alloc@V?$allocator@_W@std@@@2@XZ ; std::_Vector_alloc<0,std::_Vec_base_types<wchar_t,std::allocator<wchar_t>>>::_Getal(void)
.text$mn:0000C3F1                 mov     ecx, eax
.text$mn:0000C3F3                 call    ?max_size@?$_Wrap_alloc@V?$allocator@_W@std@@@std@@QBEIXZ ; std::_Wrap_alloc<std::allocator<wchar_t>>::max_size(void)
.text$mn:0000C3F8                 mov     esp, ebp
.text$mn:0000C3FA                 pop     ebp
.text$mn:0000C3FB                 retn
.text$mn:0000C3FB ?max_size@?$vector@_WV?$allocator@_W@std@@@std@@QBEIXZ endp
.text$mn:0000C3FB
.text$mn:0000C3FB _text$mn        ends
.text$mn:0000C3FB
.text$mn:0000C3FC ; ===========================================================================
.text$mn:0000C3FC
.text$mn:0000C3FC ; Segment type: Pure code
.text$mn:0000C3FC ; Segment permissions: Read/Execute
.text$mn:0000C3FC _text$mn        segment para public 'CODE' use32
.text$mn:0000C3FC                 assume cs:_text$mn
.text$mn:0000C3FC                 ;org 0C3FCh
.text$mn:0000C3FC ; COMDAT (pick any)
.text$mn:0000C3FC                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text$mn:0000C3FC
.text$mn:0000C3FC ; =============== S U B R O U T I N E =======================================
.text$mn:0000C3FC
.text$mn:0000C3FC ; Attributes: bp-based frame
.text$mn:0000C3FC
.text$mn:0000C3FC ; public: virtual class std::basic_string<char, struct std::char_traits<char>, class std::allocator<char>> __thiscall std::_Generic_error_category::message(int)const
.text$mn:0000C3FC                 public ?message@_Generic_error_category@std@@UBE?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@2@H@Z
.text$mn:0000C3FC ?message@_Generic_error_category@std@@UBE?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@2@H@Z proc near
.text$mn:0000C3FC                                         ; CODE XREF: std::_Iostream_error_category::message(int)+64p
.text$mn:0000C3FC                                         ; DATA XREF: .rdata:0000F3A4o
.text$mn:0000C3FC
.text$mn:0000C3FC var_1C          = dword ptr -1Ch
.text$mn:0000C3FC var_18          = dword ptr -18h
.text$mn:0000C3FC Str             = dword ptr -14h
.text$mn:0000C3FC var_10          = dword ptr -10h
.text$mn:0000C3FC var_C           = dword ptr -0Ch
.text$mn:0000C3FC var_4           = dword ptr -4
.text$mn:0000C3FC arg_0           = dword ptr  8
.text$mn:0000C3FC arg_4           = dword ptr  0Ch
.text$mn:0000C3FC
.text$mn:0000C3FC                 push    ebp
.text$mn:0000C3FD                 mov     ebp, esp
.text$mn:0000C3FF                 push    0FFFFFFFFh
.text$mn:0000C401                 push    offset __ehhandler$?message@_Generic_error_category@std@@UBE?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@2@H@Z
.text$mn:0000C406                 mov     eax, large fs:0
.text$mn:0000C40C                 push    eax
.text$mn:0000C40D                 sub     esp, 10h
.text$mn:0000C410                 mov     eax, dword ptr ds:___security_cookie
.text$mn:0000C415                 xor     eax, ebp
.text$mn:0000C417                 push    eax
.text$mn:0000C418                 lea     eax, [ebp+var_C]
.text$mn:0000C41B                 mov     large fs:0, eax
.text$mn:0000C421                 mov     [ebp+var_1C], ecx
.text$mn:0000C424                 mov     [ebp+var_18], 0
.text$mn:0000C42B                 mov     eax, [ebp+arg_4]
.text$mn:0000C42E                 push    eax             ; int
.text$mn:0000C42F                 call    ?_Syserror_map@std@@YAPBDH@Z ; std::_Syserror_map(int)
.text$mn:0000C434                 add     esp, 4
.text$mn:0000C437                 mov     [ebp+var_10], eax
.text$mn:0000C43A                 cmp     [ebp+var_10], 0
.text$mn:0000C43E                 jz      short loc_C448
.text$mn:0000C440                 mov     ecx, [ebp+var_10]
.text$mn:0000C443                 mov     [ebp+Str], ecx
.text$mn:0000C446                 jmp     short loc_C44F
.text$mn:0000C448 ; ---------------------------------------------------------------------------
.text$mn:0000C448
.text$mn:0000C448 loc_C448:                               ; CODE XREF: std::_Generic_error_category::message(int)+42j
.text$mn:0000C448                 mov     [ebp+Str], offset ??_C@_0O@BFJCFAAK@unknown?5error?$AA@ ; "unknown error"
.text$mn:0000C44F
.text$mn:0000C44F loc_C44F:                               ; CODE XREF: std::_Generic_error_category::message(int)+4Aj
.text$mn:0000C44F                 mov     edx, [ebp+Str]
.text$mn:0000C452                 push    edx             ; Str
.text$mn:0000C453                 mov     ecx, [ebp+arg_0]
.text$mn:0000C456                 call    ??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@PBD@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char>>::basic_string<char,std::char_traits<char>,std::allocator<char>>(char const *)
.text$mn:0000C45B                 mov     [ebp+var_4], 0
.text$mn:0000C462                 mov     eax, [ebp+var_18]
.text$mn:0000C465                 or      eax, 1
.text$mn:0000C468                 mov     [ebp+var_18], eax
.text$mn:0000C46B                 mov     eax, [ebp+arg_0]
.text$mn:0000C46E                 mov     ecx, [ebp+var_C]
.text$mn:0000C471                 mov     large fs:0, ecx
.text$mn:0000C478                 pop     ecx
.text$mn:0000C479                 mov     esp, ebp
.text$mn:0000C47B                 pop     ebp
.text$mn:0000C47C                 retn    8
.text$mn:0000C47C ?message@_Generic_error_category@std@@UBE?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@2@H@Z endp
.text$mn:0000C47C
.text$mn:0000C47C ; ---------------------------------------------------------------------------
.text$mn:0000C47F                 align 10h
.text$mn:0000C47F _text$mn        ends
.text$mn:0000C47F
.text$x:0000C480 ; ===========================================================================
.text$x:0000C480
.text$x:0000C480 ; Segment type: Pure code
.text$x:0000C480 ; Segment permissions: Read/Execute
.text$x:0000C480 _text$x         segment para public 'CODE' use32
.text$x:0000C480                 assume cs:_text$x
.text$x:0000C480                 ;org 0C480h
.text$x:0000C480 ; COMDAT (pick associative to section at C3FC)
.text$x:0000C480                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text$x:0000C480
.text$x:0000C480 ; =============== S U B R O U T I N E =======================================
.text$x:0000C480
.text$x:0000C480
.text$x:0000C480 __unwindfunclet$?message@_Generic_error_category@std@@UBE?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@2@H@Z$0 proc near
.text$x:0000C480                                         ; DATA XREF: .xdata$x:0000D7E0o
.text$x:0000C480                 mov     eax, [ebp-18h]
.text$x:0000C483                 and     eax, 1
.text$x:0000C486                 jz      $LN6
.text$x:0000C48C                 and     dword ptr [ebp-18h], 0FFFFFFFEh
.text$x:0000C490                 mov     ecx, [ebp+8]
.text$x:0000C493                 jmp     ??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char>>::~basic_string<char,std::char_traits<char>,std::allocator<char>>(void)
.text$x:0000C498 ; ---------------------------------------------------------------------------
.text$x:0000C498
.text$x:0000C498 $LN6:                                   ; CODE XREF: __unwindfunclet$?message@_Generic_error_category@std@@UBE?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@2@H@Z$0+6j
.text$x:0000C498                 retn
.text$x:0000C498 __unwindfunclet$?message@_Generic_error_category@std@@UBE?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@2@H@Z$0 endp
.text$x:0000C498
.text$x:0000C499
.text$x:0000C499 ; =============== S U B R O U T I N E =======================================
.text$x:0000C499
.text$x:0000C499
.text$x:0000C499 __ehhandler$?message@_Generic_error_category@std@@UBE?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@2@H@Z proc near
.text$x:0000C499                                         ; DATA XREF: std::_Generic_error_category::message(int)+5o
.text$x:0000C499
.text$x:0000C499 arg_4           = dword ptr  8
.text$x:0000C499
.text$x:0000C499                 mov     edx, [esp+arg_4]
.text$x:0000C49D                 lea     eax, [edx+0Ch]
.text$x:0000C4A0                 mov     ecx, [edx-14h]
.text$x:0000C4A3                 xor     ecx, eax
.text$x:0000C4A5                 call    @__security_check_cookie@4 ; __security_check_cookie(x)
.text$x:0000C4AA                 mov     eax, offset __ehfuncinfo$?message@_Generic_error_category@std@@UBE?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@2@H@Z
.text$x:0000C4AF                 jmp     ___CxxFrameHandler3
.text$x:0000C4AF __ehhandler$?message@_Generic_error_category@std@@UBE?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@2@H@Z endp
.text$x:0000C4AF
.text$x:0000C4AF _text$x         ends
.text$x:0000C4AF
.text$mn:0000C4B4 ; ===========================================================================
.text$mn:0000C4B4
.text$mn:0000C4B4 ; Segment type: Pure code
.text$mn:0000C4B4 ; Segment permissions: Read/Execute
.text$mn:0000C4B4 _text$mn        segment para public 'CODE' use32
.text$mn:0000C4B4                 assume cs:_text$mn
.text$mn:0000C4B4                 ;org 0C4B4h
.text$mn:0000C4B4 ; COMDAT (pick any)
.text$mn:0000C4B4                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text$mn:0000C4B4
.text$mn:0000C4B4 ; =============== S U B R O U T I N E =======================================
.text$mn:0000C4B4
.text$mn:0000C4B4 ; Attributes: bp-based frame
.text$mn:0000C4B4
.text$mn:0000C4B4 ; public: virtual class std::basic_string<char, struct std::char_traits<char>, class std::allocator<char>> __thiscall std::_Iostream_error_category::message(int)const
.text$mn:0000C4B4                 public ?message@_Iostream_error_category@std@@UBE?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@2@H@Z
.text$mn:0000C4B4 ?message@_Iostream_error_category@std@@UBE?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@2@H@Z proc near
.text$mn:0000C4B4                                         ; DATA XREF: .rdata:0000F3D8o
.text$mn:0000C4B4
.text$mn:0000C4B4 var_14          = dword ptr -14h
.text$mn:0000C4B4 var_10          = dword ptr -10h
.text$mn:0000C4B4 var_C           = dword ptr -0Ch
.text$mn:0000C4B4 var_4           = dword ptr -4
.text$mn:0000C4B4 arg_0           = dword ptr  8
.text$mn:0000C4B4 arg_4           = dword ptr  0Ch
.text$mn:0000C4B4
.text$mn:0000C4B4                 push    ebp
.text$mn:0000C4B5                 mov     ebp, esp
.text$mn:0000C4B7                 push    0FFFFFFFFh
.text$mn:0000C4B9                 push    offset __ehhandler$?message@_Iostream_error_category@std@@UBE?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@2@H@Z
.text$mn:0000C4BE                 mov     eax, large fs:0
.text$mn:0000C4C4                 push    eax
.text$mn:0000C4C5                 sub     esp, 8
.text$mn:0000C4C8                 mov     eax, dword ptr ds:___security_cookie
.text$mn:0000C4CD                 xor     eax, ebp
.text$mn:0000C4CF                 push    eax
.text$mn:0000C4D0                 lea     eax, [ebp+var_C]
.text$mn:0000C4D3                 mov     large fs:0, eax
.text$mn:0000C4D9                 mov     [ebp+var_14], ecx
.text$mn:0000C4DC                 mov     [ebp+var_10], 0
.text$mn:0000C4E3                 cmp     [ebp+arg_4], 1
.text$mn:0000C4E7                 jnz     short loc_C50D
.text$mn:0000C4E9                 push    offset ??_C@_0BG@PADBLCHM@iostream?5stream?5error?$AA@ ; "iostream stream error"
.text$mn:0000C4EE                 mov     ecx, [ebp+arg_0]
.text$mn:0000C4F1                 call    ??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@PBD@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char>>::basic_string<char,std::char_traits<char>,std::allocator<char>>(char const *)
.text$mn:0000C4F6                 mov     [ebp+var_4], 0
.text$mn:0000C4FD                 mov     eax, [ebp+var_10]
.text$mn:0000C500                 or      eax, 1
.text$mn:0000C503                 mov     [ebp+var_10], eax
.text$mn:0000C506                 mov     eax, [ebp+arg_0]
.text$mn:0000C509                 jmp     short loc_C530
.text$mn:0000C50B ; ---------------------------------------------------------------------------
.text$mn:0000C50B                 jmp     short loc_C530
.text$mn:0000C50D ; ---------------------------------------------------------------------------
.text$mn:0000C50D
.text$mn:0000C50D loc_C50D:                               ; CODE XREF: std::_Iostream_error_category::message(int)+33j
.text$mn:0000C50D                 mov     ecx, [ebp+arg_4]
.text$mn:0000C510                 push    ecx
.text$mn:0000C511                 mov     edx, [ebp+arg_0]
.text$mn:0000C514                 push    edx
.text$mn:0000C515                 mov     ecx, [ebp+var_14]
.text$mn:0000C518                 call    ?message@_Generic_error_category@std@@UBE?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@2@H@Z ; std::_Generic_error_category::message(int)
.text$mn:0000C51D                 mov     [ebp+var_4], 0
.text$mn:0000C524                 mov     eax, [ebp+var_10]
.text$mn:0000C527                 or      eax, 1
.text$mn:0000C52A                 mov     [ebp+var_10], eax
.text$mn:0000C52D                 mov     eax, [ebp+arg_0]
.text$mn:0000C530
.text$mn:0000C530 loc_C530:                               ; CODE XREF: std::_Iostream_error_category::message(int)+55j
.text$mn:0000C530                                         ; std::_Iostream_error_category::message(int)+57j
.text$mn:0000C530                 mov     ecx, [ebp+var_C]
.text$mn:0000C533                 mov     large fs:0, ecx
.text$mn:0000C53A                 pop     ecx
.text$mn:0000C53B                 mov     esp, ebp
.text$mn:0000C53D                 pop     ebp
.text$mn:0000C53E                 retn    8
.text$mn:0000C53E ?message@_Iostream_error_category@std@@UBE?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@2@H@Z endp
.text$mn:0000C53E
.text$mn:0000C53E ; ---------------------------------------------------------------------------
.text$mn:0000C541                 align 4
.text$mn:0000C541 _text$mn        ends
.text$mn:0000C541
.text$x:0000C544 ; ===========================================================================
.text$x:0000C544
.text$x:0000C544 ; Segment type: Pure code
.text$x:0000C544 ; Segment permissions: Read/Execute
.text$x:0000C544 _text$x         segment para public 'CODE' use32
.text$x:0000C544                 assume cs:_text$x
.text$x:0000C544                 ;org 0C544h
.text$x:0000C544 ; COMDAT (pick associative to section at C4B4)
.text$x:0000C544                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text$x:0000C544
.text$x:0000C544 ; =============== S U B R O U T I N E =======================================
.text$x:0000C544
.text$x:0000C544
.text$x:0000C544 __unwindfunclet$?message@_Iostream_error_category@std@@UBE?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@2@H@Z$0 proc near
.text$x:0000C544                                         ; DATA XREF: .xdata$x:0000D864o
.text$x:0000C544                 mov     eax, [ebp-10h]
.text$x:0000C547                 and     eax, 1
.text$x:0000C54A                 jz      $LN6_0
.text$x:0000C550                 and     dword ptr [ebp-10h], 0FFFFFFFEh
.text$x:0000C554                 mov     ecx, [ebp+8]
.text$x:0000C557                 jmp     ??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char>>::~basic_string<char,std::char_traits<char>,std::allocator<char>>(void)
.text$x:0000C55C ; ---------------------------------------------------------------------------
.text$x:0000C55C
.text$x:0000C55C $LN6_0:                                 ; CODE XREF: __unwindfunclet$?message@_Iostream_error_category@std@@UBE?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@2@H@Z$0+6j
.text$x:0000C55C                 retn
.text$x:0000C55C __unwindfunclet$?message@_Iostream_error_category@std@@UBE?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@2@H@Z$0 endp
.text$x:0000C55C
.text$x:0000C55D
.text$x:0000C55D ; =============== S U B R O U T I N E =======================================
.text$x:0000C55D
.text$x:0000C55D
.text$x:0000C55D __ehhandler$?message@_Iostream_error_category@std@@UBE?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@2@H@Z proc near
.text$x:0000C55D                                         ; DATA XREF: std::_Iostream_error_category::message(int)+5o
.text$x:0000C55D
.text$x:0000C55D arg_4           = dword ptr  8
.text$x:0000C55D
.text$x:0000C55D                 mov     edx, [esp+arg_4]
.text$x:0000C561                 lea     eax, [edx+0Ch]
.text$x:0000C564                 mov     ecx, [edx-0Ch]
.text$x:0000C567                 xor     ecx, eax
.text$x:0000C569                 call    @__security_check_cookie@4 ; __security_check_cookie(x)
.text$x:0000C56E                 mov     eax, offset __ehfuncinfo$?message@_Iostream_error_category@std@@UBE?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@2@H@Z
.text$x:0000C573                 jmp     ___CxxFrameHandler3
.text$x:0000C573 __ehhandler$?message@_Iostream_error_category@std@@UBE?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@2@H@Z endp
.text$x:0000C573
.text$x:0000C573 _text$x         ends
.text$x:0000C573
.text$mn:0000C578 ; ===========================================================================
.text$mn:0000C578
.text$mn:0000C578 ; Segment type: Pure code
.text$mn:0000C578 ; Segment permissions: Read/Execute
.text$mn:0000C578 _text$mn        segment para public 'CODE' use32
.text$mn:0000C578                 assume cs:_text$mn
.text$mn:0000C578                 ;org 0C578h
.text$mn:0000C578 ; COMDAT (pick any)
.text$mn:0000C578                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text$mn:0000C578
.text$mn:0000C578 ; =============== S U B R O U T I N E =======================================
.text$mn:0000C578
.text$mn:0000C578 ; Attributes: bp-based frame
.text$mn:0000C578
.text$mn:0000C578 ; public: virtual class std::basic_string<char, struct std::char_traits<char>, class std::allocator<char>> __thiscall std::_System_error_category::message(int)const
.text$mn:0000C578                 public ?message@_System_error_category@std@@UBE?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@2@H@Z
.text$mn:0000C578 ?message@_System_error_category@std@@UBE?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@2@H@Z proc near
.text$mn:0000C578                                         ; DATA XREF: .rdata:0000F418o
.text$mn:0000C578
.text$mn:0000C578 var_1C          = dword ptr -1Ch
.text$mn:0000C578 var_18          = dword ptr -18h
.text$mn:0000C578 Str             = dword ptr -14h
.text$mn:0000C578 var_10          = dword ptr -10h
.text$mn:0000C578 var_C           = dword ptr -0Ch
.text$mn:0000C578 var_4           = dword ptr -4
.text$mn:0000C578 arg_0           = dword ptr  8
.text$mn:0000C578 arg_4           = dword ptr  0Ch
.text$mn:0000C578
.text$mn:0000C578                 push    ebp
.text$mn:0000C579                 mov     ebp, esp
.text$mn:0000C57B                 push    0FFFFFFFFh
.text$mn:0000C57D                 push    offset __ehhandler$?message@_System_error_category@std@@UBE?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@2@H@Z
.text$mn:0000C582                 mov     eax, large fs:0
.text$mn:0000C588                 push    eax
.text$mn:0000C589                 sub     esp, 10h
.text$mn:0000C58C                 mov     eax, dword ptr ds:___security_cookie
.text$mn:0000C591                 xor     eax, ebp
.text$mn:0000C593                 push    eax
.text$mn:0000C594                 lea     eax, [ebp+var_C]
.text$mn:0000C597                 mov     large fs:0, eax
.text$mn:0000C59D                 mov     [ebp+var_1C], ecx
.text$mn:0000C5A0                 mov     [ebp+var_18], 0
.text$mn:0000C5A7                 mov     eax, [ebp+arg_4]
.text$mn:0000C5AA                 push    eax             ; int
.text$mn:0000C5AB                 call    ?_Winerror_map@std@@YAPBDH@Z ; std::_Winerror_map(int)
.text$mn:0000C5B0                 add     esp, 4
.text$mn:0000C5B3                 mov     [ebp+var_10], eax
.text$mn:0000C5B6                 cmp     [ebp+var_10], 0
.text$mn:0000C5BA                 jz      short loc_C5C4
.text$mn:0000C5BC                 mov     ecx, [ebp+var_10]
.text$mn:0000C5BF                 mov     [ebp+Str], ecx
.text$mn:0000C5C2                 jmp     short loc_C5CB
.text$mn:0000C5C4 ; ---------------------------------------------------------------------------
.text$mn:0000C5C4
.text$mn:0000C5C4 loc_C5C4:                               ; CODE XREF: std::_System_error_category::message(int)+42j
.text$mn:0000C5C4                 mov     [ebp+Str], offset ??_C@_0O@BFJCFAAK@unknown?5error?$AA@ ; "unknown error"
.text$mn:0000C5CB
.text$mn:0000C5CB loc_C5CB:                               ; CODE XREF: std::_System_error_category::message(int)+4Aj
.text$mn:0000C5CB                 mov     edx, [ebp+Str]
.text$mn:0000C5CE                 push    edx             ; Str
.text$mn:0000C5CF                 mov     ecx, [ebp+arg_0]
.text$mn:0000C5D2                 call    ??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@PBD@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char>>::basic_string<char,std::char_traits<char>,std::allocator<char>>(char const *)
.text$mn:0000C5D7                 mov     [ebp+var_4], 0
.text$mn:0000C5DE                 mov     eax, [ebp+var_18]
.text$mn:0000C5E1                 or      eax, 1
.text$mn:0000C5E4                 mov     [ebp+var_18], eax
.text$mn:0000C5E7                 mov     eax, [ebp+arg_0]
.text$mn:0000C5EA                 mov     ecx, [ebp+var_C]
.text$mn:0000C5ED                 mov     large fs:0, ecx
.text$mn:0000C5F4                 pop     ecx
.text$mn:0000C5F5                 mov     esp, ebp
.text$mn:0000C5F7                 pop     ebp
.text$mn:0000C5F8                 retn    8
.text$mn:0000C5F8 ?message@_System_error_category@std@@UBE?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@2@H@Z endp
.text$mn:0000C5F8
.text$mn:0000C5F8 ; ---------------------------------------------------------------------------
.text$mn:0000C5FB                 align 4
.text$mn:0000C5FB _text$mn        ends
.text$mn:0000C5FB
.text$x:0000C5FC ; ===========================================================================
.text$x:0000C5FC
.text$x:0000C5FC ; Segment type: Pure code
.text$x:0000C5FC ; Segment permissions: Read/Execute
.text$x:0000C5FC _text$x         segment para public 'CODE' use32
.text$x:0000C5FC                 assume cs:_text$x
.text$x:0000C5FC                 ;org 0C5FCh
.text$x:0000C5FC ; COMDAT (pick associative to section at C578)
.text$x:0000C5FC                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text$x:0000C5FC
.text$x:0000C5FC ; =============== S U B R O U T I N E =======================================
.text$x:0000C5FC
.text$x:0000C5FC
.text$x:0000C5FC __unwindfunclet$?message@_System_error_category@std@@UBE?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@2@H@Z$0 proc near
.text$x:0000C5FC                                         ; DATA XREF: .xdata$x:0000D8E8o
.text$x:0000C5FC                 mov     eax, [ebp-18h]
.text$x:0000C5FF                 and     eax, 1
.text$x:0000C602                 jz      $LN6_1
.text$x:0000C608                 and     dword ptr [ebp-18h], 0FFFFFFFEh
.text$x:0000C60C                 mov     ecx, [ebp+8]
.text$x:0000C60F                 jmp     ??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char>>::~basic_string<char,std::char_traits<char>,std::allocator<char>>(void)
.text$x:0000C614 ; ---------------------------------------------------------------------------
.text$x:0000C614
.text$x:0000C614 $LN6_1:                                 ; CODE XREF: __unwindfunclet$?message@_System_error_category@std@@UBE?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@2@H@Z$0+6j
.text$x:0000C614                 retn
.text$x:0000C614 __unwindfunclet$?message@_System_error_category@std@@UBE?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@2@H@Z$0 endp
.text$x:0000C614
.text$x:0000C615
.text$x:0000C615 ; =============== S U B R O U T I N E =======================================
.text$x:0000C615
.text$x:0000C615
.text$x:0000C615 __ehhandler$?message@_System_error_category@std@@UBE?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@2@H@Z proc near
.text$x:0000C615                                         ; DATA XREF: std::_System_error_category::message(int)+5o
.text$x:0000C615
.text$x:0000C615 arg_4           = dword ptr  8
.text$x:0000C615
.text$x:0000C615                 mov     edx, [esp+arg_4]
.text$x:0000C619                 lea     eax, [edx+0Ch]
.text$x:0000C61C                 mov     ecx, [edx-14h]
.text$x:0000C61F                 xor     ecx, eax
.text$x:0000C621                 call    @__security_check_cookie@4 ; __security_check_cookie(x)
.text$x:0000C626                 mov     eax, offset __ehfuncinfo$?message@_System_error_category@std@@UBE?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@2@H@Z
.text$x:0000C62B                 jmp     ___CxxFrameHandler3
.text$x:0000C62B __ehhandler$?message@_System_error_category@std@@UBE?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@2@H@Z endp
.text$x:0000C62B
.text$x:0000C62B _text$x         ends
.text$x:0000C62B
.text$mn:0000C630 ; ===========================================================================
.text$mn:0000C630
.text$mn:0000C630 ; Segment type: Pure code
.text$mn:0000C630 ; Segment permissions: Read/Execute
.text$mn:0000C630 _text$mn        segment para public 'CODE' use32
.text$mn:0000C630                 assume cs:_text$mn
.text$mn:0000C630                 ;org 0C630h
.text$mn:0000C630 ; COMDAT (pick any)
.text$mn:0000C630                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text$mn:0000C630
.text$mn:0000C630 ; =============== S U B R O U T I N E =======================================
.text$mn:0000C630
.text$mn:0000C630 ; Attributes: bp-based frame
.text$mn:0000C630
.text$mn:0000C630 ; int __cdecl std::char_traits<char>::move(void *Dst, void *Src, size_t Size)
.text$mn:0000C630                 public ?move@?$char_traits@D@std@@SAPADPADPBDI@Z
.text$mn:0000C630 ?move@?$char_traits@D@std@@SAPADPADPBDI@Z proc near
.text$mn:0000C630                                         ; CODE XREF: std::basic_string<char,std::char_traits<char>,std::allocator<char>>::_Assign_rv(std::basic_string<char,std::char_traits<char>,std::allocator<char>> &&)+2Ap
.text$mn:0000C630                                         ; std::basic_string<char,std::char_traits<char>,std::allocator<char>>::erase(uint,uint)+6Ap
.text$mn:0000C630
.text$mn:0000C630 var_4           = dword ptr -4
.text$mn:0000C630 Dst             = dword ptr  8
.text$mn:0000C630 Src             = dword ptr  0Ch
.text$mn:0000C630 Size            = dword ptr  10h
.text$mn:0000C630
.text$mn:0000C630                 push    ebp
.text$mn:0000C631                 mov     ebp, esp
.text$mn:0000C633                 push    ecx
.text$mn:0000C634                 cmp     [ebp+Size], 0
.text$mn:0000C638                 jnz     short loc_C642
.text$mn:0000C63A                 mov     eax, [ebp+Dst]
.text$mn:0000C63D                 mov     [ebp+var_4], eax
.text$mn:0000C640                 jmp     short loc_C659
.text$mn:0000C642 ; ---------------------------------------------------------------------------
.text$mn:0000C642
.text$mn:0000C642 loc_C642:                               ; CODE XREF: std::char_traits<char>::move(char *,char const *,uint)+8j
.text$mn:0000C642                 mov     ecx, [ebp+Size]
.text$mn:0000C645                 push    ecx             ; Size
.text$mn:0000C646                 mov     edx, [ebp+Src]
.text$mn:0000C649                 push    edx             ; Src
.text$mn:0000C64A                 mov     eax, [ebp+Dst]
.text$mn:0000C64D                 push    eax             ; Dst
.text$mn:0000C64E                 call    _memmove
.text$mn:0000C653                 add     esp, 0Ch
.text$mn:0000C656                 mov     [ebp+var_4], eax
.text$mn:0000C659
.text$mn:0000C659 loc_C659:                               ; CODE XREF: std::char_traits<char>::move(char *,char const *,uint)+10j
.text$mn:0000C659                 mov     eax, [ebp+var_4]
.text$mn:0000C65C                 mov     esp, ebp
.text$mn:0000C65E                 pop     ebp
.text$mn:0000C65F                 retn
.text$mn:0000C65F ?move@?$char_traits@D@std@@SAPADPADPBDI@Z endp
.text$mn:0000C65F
.text$mn:0000C65F _text$mn        ends
.text$mn:0000C65F
.text$mn:0000C660 ; ===========================================================================
.text$mn:0000C660
.text$mn:0000C660 ; Segment type: Pure code
.text$mn:0000C660 ; Segment permissions: Read/Execute
.text$mn:0000C660 _text$mn        segment para public 'CODE' use32
.text$mn:0000C660                 assume cs:_text$mn
.text$mn:0000C660                 ;org 0C660h
.text$mn:0000C660 ; COMDAT (pick any)
.text$mn:0000C660                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text$mn:0000C660
.text$mn:0000C660 ; =============== S U B R O U T I N E =======================================
.text$mn:0000C660
.text$mn:0000C660 ; Attributes: bp-based frame
.text$mn:0000C660
.text$mn:0000C660 ; int __cdecl std::char_traits<wchar_t>::move(void *Dst, void *Src, int)
.text$mn:0000C660                 public ?move@?$char_traits@_W@std@@SAPA_WPA_WPB_WI@Z
.text$mn:0000C660 ?move@?$char_traits@_W@std@@SAPA_WPA_WPB_WI@Z proc near
.text$mn:0000C660                                         ; CODE XREF: std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>>::_Assign_rv(std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>> &&)+2Ap
.text$mn:0000C660                                         ; std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>>::erase(uint,uint)+70p ...
.text$mn:0000C660
.text$mn:0000C660 var_4           = dword ptr -4
.text$mn:0000C660 Dst             = dword ptr  8
.text$mn:0000C660 Src             = dword ptr  0Ch
.text$mn:0000C660 arg_8           = dword ptr  10h
.text$mn:0000C660
.text$mn:0000C660                 push    ebp
.text$mn:0000C661                 mov     ebp, esp
.text$mn:0000C663                 push    ecx
.text$mn:0000C664                 cmp     [ebp+arg_8], 0
.text$mn:0000C668                 jnz     short loc_C672
.text$mn:0000C66A                 mov     eax, [ebp+Dst]
.text$mn:0000C66D                 mov     [ebp+var_4], eax
.text$mn:0000C670                 jmp     short loc_C689
.text$mn:0000C672 ; ---------------------------------------------------------------------------
.text$mn:0000C672
.text$mn:0000C672 loc_C672:                               ; CODE XREF: std::char_traits<wchar_t>::move(wchar_t *,wchar_t const *,uint)+8j
.text$mn:0000C672                 mov     ecx, [ebp+arg_8]
.text$mn:0000C675                 push    ecx             ; int
.text$mn:0000C676                 mov     edx, [ebp+Src]
.text$mn:0000C679                 push    edx             ; Src
.text$mn:0000C67A                 mov     eax, [ebp+Dst]
.text$mn:0000C67D                 push    eax             ; Dst
.text$mn:0000C67E                 call    _wmemmove
.text$mn:0000C683                 add     esp, 0Ch
.text$mn:0000C686                 mov     [ebp+var_4], eax
.text$mn:0000C689
.text$mn:0000C689 loc_C689:                               ; CODE XREF: std::char_traits<wchar_t>::move(wchar_t *,wchar_t const *,uint)+10j
.text$mn:0000C689                 mov     eax, [ebp+var_4]
.text$mn:0000C68C                 mov     esp, ebp
.text$mn:0000C68E                 pop     ebp
.text$mn:0000C68F                 retn
.text$mn:0000C68F ?move@?$char_traits@_W@std@@SAPA_WPA_WPB_WI@Z endp
.text$mn:0000C68F
.text$mn:0000C68F _text$mn        ends
.text$mn:0000C68F
.text$mn:0000C690 ; ===========================================================================
.text$mn:0000C690
.text$mn:0000C690 ; Segment type: Pure code
.text$mn:0000C690 ; Segment permissions: Read/Execute
.text$mn:0000C690 _text$mn        segment para public 'CODE' use32
.text$mn:0000C690                 assume cs:_text$mn
.text$mn:0000C690                 ;org 0C690h
.text$mn:0000C690 ; COMDAT (pick any)
.text$mn:0000C690                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text$mn:0000C690
.text$mn:0000C690 ; =============== S U B R O U T I N E =======================================
.text$mn:0000C690
.text$mn:0000C690 ; Attributes: bp-based frame
.text$mn:0000C690
.text$mn:0000C690 ; const char *__thiscall std::_Generic_error_category::name(std::_Generic_error_category *__hidden this)
.text$mn:0000C690                 public ?name@_Generic_error_category@std@@UBEPBDXZ
.text$mn:0000C690 ?name@_Generic_error_category@std@@UBEPBDXZ proc near
.text$mn:0000C690                                         ; DATA XREF: .rdata:0000F3A0o
.text$mn:0000C690
.text$mn:0000C690 var_4           = dword ptr -4
.text$mn:0000C690
.text$mn:0000C690                 push    ebp
.text$mn:0000C691                 mov     ebp, esp
.text$mn:0000C693                 push    ecx
.text$mn:0000C694                 mov     [ebp+var_4], ecx
.text$mn:0000C697                 mov     eax, offset ??_C@_07DCLBNMLN@generic?$AA@ ; "generic"
.text$mn:0000C69C                 mov     esp, ebp
.text$mn:0000C69E                 pop     ebp
.text$mn:0000C69F                 retn
.text$mn:0000C69F ?name@_Generic_error_category@std@@UBEPBDXZ endp
.text$mn:0000C69F
.text$mn:0000C69F _text$mn        ends
.text$mn:0000C69F
.text$mn:0000C6A0 ; ===========================================================================
.text$mn:0000C6A0
.text$mn:0000C6A0 ; Segment type: Pure code
.text$mn:0000C6A0 ; Segment permissions: Read/Execute
.text$mn:0000C6A0 _text$mn        segment para public 'CODE' use32
.text$mn:0000C6A0                 assume cs:_text$mn
.text$mn:0000C6A0                 ;org 0C6A0h
.text$mn:0000C6A0 ; COMDAT (pick any)
.text$mn:0000C6A0                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text$mn:0000C6A0
.text$mn:0000C6A0 ; =============== S U B R O U T I N E =======================================
.text$mn:0000C6A0
.text$mn:0000C6A0 ; Attributes: bp-based frame
.text$mn:0000C6A0
.text$mn:0000C6A0 ; const char *__thiscall std::_Iostream_error_category::name(std::_Iostream_error_category *__hidden this)
.text$mn:0000C6A0                 public ?name@_Iostream_error_category@std@@UBEPBDXZ
.text$mn:0000C6A0 ?name@_Iostream_error_category@std@@UBEPBDXZ proc near
.text$mn:0000C6A0                                         ; DATA XREF: .rdata:0000F3D4o
.text$mn:0000C6A0
.text$mn:0000C6A0 var_4           = dword ptr -4
.text$mn:0000C6A0
.text$mn:0000C6A0                 push    ebp
.text$mn:0000C6A1                 mov     ebp, esp
.text$mn:0000C6A3                 push    ecx
.text$mn:0000C6A4                 mov     [ebp+var_4], ecx
.text$mn:0000C6A7                 mov     eax, offset ??_C@_08LLGCOLLL@iostream?$AA@ ; "iostream"
.text$mn:0000C6AC                 mov     esp, ebp
.text$mn:0000C6AE                 pop     ebp
.text$mn:0000C6AF                 retn
.text$mn:0000C6AF ?name@_Iostream_error_category@std@@UBEPBDXZ endp
.text$mn:0000C6AF
.text$mn:0000C6AF _text$mn        ends
.text$mn:0000C6AF
.text$mn:0000C6B0 ; ===========================================================================
.text$mn:0000C6B0
.text$mn:0000C6B0 ; Segment type: Pure code
.text$mn:0000C6B0 ; Segment permissions: Read/Execute
.text$mn:0000C6B0 _text$mn        segment para public 'CODE' use32
.text$mn:0000C6B0                 assume cs:_text$mn
.text$mn:0000C6B0                 ;org 0C6B0h
.text$mn:0000C6B0 ; COMDAT (pick any)
.text$mn:0000C6B0                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text$mn:0000C6B0
.text$mn:0000C6B0 ; =============== S U B R O U T I N E =======================================
.text$mn:0000C6B0
.text$mn:0000C6B0 ; Attributes: bp-based frame
.text$mn:0000C6B0
.text$mn:0000C6B0 ; const char *__thiscall std::_System_error_category::name(std::_System_error_category *__hidden this)
.text$mn:0000C6B0                 public ?name@_System_error_category@std@@UBEPBDXZ
.text$mn:0000C6B0 ?name@_System_error_category@std@@UBEPBDXZ proc near
.text$mn:0000C6B0                                         ; DATA XREF: .rdata:0000F414o
.text$mn:0000C6B0
.text$mn:0000C6B0 var_4           = dword ptr -4
.text$mn:0000C6B0
.text$mn:0000C6B0                 push    ebp
.text$mn:0000C6B1                 mov     ebp, esp
.text$mn:0000C6B3                 push    ecx
.text$mn:0000C6B4                 mov     [ebp+var_4], ecx
.text$mn:0000C6B7                 mov     eax, offset ??_C@_06FHFOAHML@system?$AA@ ; "system"
.text$mn:0000C6BC                 mov     esp, ebp
.text$mn:0000C6BE                 pop     ebp
.text$mn:0000C6BF                 retn
.text$mn:0000C6BF ?name@_System_error_category@std@@UBEPBDXZ endp
.text$mn:0000C6BF
.text$mn:0000C6BF _text$mn        ends
.text$mn:0000C6BF
.text$mn:0000C6C0 ; ===========================================================================
.text$mn:0000C6C0
.text$mn:0000C6C0 ; Segment type: Pure code
.text$mn:0000C6C0 ; Segment permissions: Read/Execute
.text$mn:0000C6C0 _text$mn        segment para public 'CODE' use32
.text$mn:0000C6C0                 assume cs:_text$mn
.text$mn:0000C6C0                 ;org 0C6C0h
.text$mn:0000C6C0 ; COMDAT (pick any)
.text$mn:0000C6C0                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text$mn:0000C6C0
.text$mn:0000C6C0 ; =============== S U B R O U T I N E =======================================
.text$mn:0000C6C0
.text$mn:0000C6C0 ; Attributes: bp-based frame
.text$mn:0000C6C0
.text$mn:0000C6C0 ; public: void __thiscall std::basic_string<wchar_t, struct std::char_traits<wchar_t>, class std::allocator<wchar_t>>::push_back(wchar_t)
.text$mn:0000C6C0                 public ?push_back@?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QAEX_W@Z
.text$mn:0000C6C0 ?push_back@?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QAEX_W@Z proc near
.text$mn:0000C6C0                                         ; CODE XREF: BuildMenuFileName(int,uint,std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>> const &)+50p
.text$mn:0000C6C0                                         ; BuildMenuFileName(int,uint,std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>> const &)+60p ...
.text$mn:0000C6C0
.text$mn:0000C6C0 var_40          = byte ptr -40h
.text$mn:0000C6C0 var_34          = byte ptr -34h
.text$mn:0000C6C0 var_28          = dword ptr -28h
.text$mn:0000C6C0 var_24          = dword ptr -24h
.text$mn:0000C6C0 var_20          = dword ptr -20h
.text$mn:0000C6C0 var_1C          = dword ptr -1Ch
.text$mn:0000C6C0 var_18          = dword ptr -18h
.text$mn:0000C6C0 var_14          = dword ptr -14h
.text$mn:0000C6C0 var_10          = dword ptr -10h
.text$mn:0000C6C0 var_C           = dword ptr -0Ch
.text$mn:0000C6C0 var_4           = dword ptr -4
.text$mn:0000C6C0 arg_0           = word ptr  8
.text$mn:0000C6C0
.text$mn:0000C6C0                 push    ebp
.text$mn:0000C6C1                 mov     ebp, esp
.text$mn:0000C6C3                 push    0FFFFFFFFh
.text$mn:0000C6C5                 push    offset __ehhandler$?push_back@?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QAEX_W@Z
.text$mn:0000C6CA                 mov     eax, large fs:0
.text$mn:0000C6D0                 push    eax
.text$mn:0000C6D1                 sub     esp, 34h
.text$mn:0000C6D4                 mov     eax, dword ptr ds:___security_cookie
.text$mn:0000C6D9                 xor     eax, ebp
.text$mn:0000C6DB                 push    eax
.text$mn:0000C6DC                 lea     eax, [ebp+var_C]
.text$mn:0000C6DF                 mov     large fs:0, eax
.text$mn:0000C6E5                 mov     [ebp+var_10], ecx
.text$mn:0000C6E8                 movzx   eax, [ebp+arg_0]
.text$mn:0000C6EC                 push    eax
.text$mn:0000C6ED                 lea     ecx, [ebp+var_40]
.text$mn:0000C6F0                 push    ecx
.text$mn:0000C6F1                 mov     ecx, [ebp+var_10]
.text$mn:0000C6F4                 call    ?end@?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QAE?AV?$_String_iterator@V?$_String_val@U?$_Simple_types@_W@std@@@std@@@2@XZ ; std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>>::end(void)
.text$mn:0000C6F9                 mov     [ebp+var_14], eax
.text$mn:0000C6FC                 mov     edx, [ebp+var_14]
.text$mn:0000C6FF                 mov     [ebp+var_18], edx
.text$mn:0000C702                 mov     [ebp+var_4], 0
.text$mn:0000C709                 sub     esp, 0Ch
.text$mn:0000C70C                 mov     ecx, esp
.text$mn:0000C70E                 mov     [ebp+var_20], esp
.text$mn:0000C711                 mov     eax, [ebp+var_18]
.text$mn:0000C714                 push    eax             ; struct std::_Iterator_base12 *
.text$mn:0000C715                 call    ??0?$_String_const_iterator@V?$_String_val@U?$_Simple_types@_W@std@@@std@@@std@@QAE@ABV01@@Z ; std::_String_const_iterator<std::_String_val<std::_Simple_types<wchar_t>>>::_String_const_iterator<std::_String_val<std::_Simple_types<wchar_t>>>(std::_String_const_iterator<std::_String_val<std::_Simple_types<wchar_t>>> const &)
.text$mn:0000C71A                 mov     [ebp+var_1C], eax
.text$mn:0000C71D                 mov     ecx, [ebp+var_1C]
.text$mn:0000C720                 mov     [ebp+var_24], ecx
.text$mn:0000C723                 mov     byte ptr [ebp+var_4], 1
.text$mn:0000C727                 lea     edx, [ebp+var_34]
.text$mn:0000C72A                 push    edx
.text$mn:0000C72B                 mov     byte ptr [ebp+var_4], 0
.text$mn:0000C72F                 mov     ecx, [ebp+var_10]
.text$mn:0000C732                 call    ?insert@?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QAE?AV?$_String_iterator@V?$_String_val@U?$_Simple_types@_W@std@@@std@@@2@V?$_String_const_iterator@V?$_String_val@U?$_Simple_types@_W@std@@@std@@@2@_W@Z ; std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>>::insert(std::_String_const_iterator<std::_String_val<std::_Simple_types<wchar_t>>>,wchar_t)
.text$mn:0000C737                 mov     [ebp+var_28], eax
.text$mn:0000C73A                 lea     ecx, [ebp+var_34]
.text$mn:0000C73D                 call    ??1?$_String_iterator@V?$_String_val@U?$_Simple_types@_W@std@@@std@@@std@@QAE@XZ ; std::_String_iterator<std::_String_val<std::_Simple_types<wchar_t>>>::~_String_iterator<std::_String_val<std::_Simple_types<wchar_t>>>(void)
.text$mn:0000C742                 mov     [ebp+var_4], 0FFFFFFFFh
.text$mn:0000C749                 lea     ecx, [ebp+var_40]
.text$mn:0000C74C                 call    ??1?$_String_iterator@V?$_String_val@U?$_Simple_types@_W@std@@@std@@@std@@QAE@XZ ; std::_String_iterator<std::_String_val<std::_Simple_types<wchar_t>>>::~_String_iterator<std::_String_val<std::_Simple_types<wchar_t>>>(void)
.text$mn:0000C751                 mov     ecx, [ebp+var_C]
.text$mn:0000C754                 mov     large fs:0, ecx
.text$mn:0000C75B                 pop     ecx
.text$mn:0000C75C                 mov     esp, ebp
.text$mn:0000C75E                 pop     ebp
.text$mn:0000C75F                 retn    4
.text$mn:0000C75F ?push_back@?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QAEX_W@Z endp
.text$mn:0000C75F
.text$mn:0000C75F ; ---------------------------------------------------------------------------
.text$mn:0000C762                 align 4
.text$mn:0000C762 _text$mn        ends
.text$mn:0000C762
.text$x:0000C764 ; ===========================================================================
.text$x:0000C764
.text$x:0000C764 ; Segment type: Pure code
.text$x:0000C764 ; Segment permissions: Read/Execute
.text$x:0000C764 _text$x         segment para public 'CODE' use32
.text$x:0000C764                 assume cs:_text$x
.text$x:0000C764                 ;org 0C764h
.text$x:0000C764 ; COMDAT (pick associative to section at C6C0)
.text$x:0000C764                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text$x:0000C764
.text$x:0000C764 ; =============== S U B R O U T I N E =======================================
.text$x:0000C764
.text$x:0000C764
.text$x:0000C764 __unwindfunclet$?push_back@?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QAEX_W@Z$0 proc near
.text$x:0000C764                                         ; DATA XREF: .xdata$x:0000DBFCo
.text$x:0000C764                 lea     ecx, [ebp-40h]
.text$x:0000C767                 jmp     ??1?$_String_iterator@V?$_String_val@U?$_Simple_types@_W@std@@@std@@@std@@QAE@XZ ; std::_String_iterator<std::_String_val<std::_Simple_types<wchar_t>>>::~_String_iterator<std::_String_val<std::_Simple_types<wchar_t>>>(void)
.text$x:0000C767 __unwindfunclet$?push_back@?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QAEX_W@Z$0 endp
.text$x:0000C767
.text$x:0000C76C
.text$x:0000C76C ; =============== S U B R O U T I N E =======================================
.text$x:0000C76C
.text$x:0000C76C
.text$x:0000C76C __unwindfunclet$?push_back@?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QAEX_W@Z$1 proc near
.text$x:0000C76C                                         ; DATA XREF: .xdata$x:0000DC04o
.text$x:0000C76C                 mov     ecx, [ebp-20h]
.text$x:0000C76F                 jmp     ??1?$_String_const_iterator@V?$_String_val@U?$_Simple_types@_W@std@@@std@@@std@@QAE@XZ ; std::_String_const_iterator<std::_String_val<std::_Simple_types<wchar_t>>>::~_String_const_iterator<std::_String_val<std::_Simple_types<wchar_t>>>(void)
.text$x:0000C76F __unwindfunclet$?push_back@?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QAEX_W@Z$1 endp
.text$x:0000C76F
.text$x:0000C774
.text$x:0000C774 ; =============== S U B R O U T I N E =======================================
.text$x:0000C774
.text$x:0000C774
.text$x:0000C774 __ehhandler$?push_back@?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QAEX_W@Z proc near
.text$x:0000C774                                         ; DATA XREF: std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>>::push_back(wchar_t)+5o
.text$x:0000C774
.text$x:0000C774 arg_4           = dword ptr  8
.text$x:0000C774
.text$x:0000C774                 mov     edx, [esp+arg_4]
.text$x:0000C778                 lea     eax, [edx+0Ch]
.text$x:0000C77B                 mov     ecx, [edx-38h]
.text$x:0000C77E                 xor     ecx, eax
.text$x:0000C780                 call    @__security_check_cookie@4 ; __security_check_cookie(x)
.text$x:0000C785                 mov     eax, offset __ehfuncinfo$?push_back@?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QAEX_W@Z
.text$x:0000C78A                 jmp     ___CxxFrameHandler3
.text$x:0000C78A __ehhandler$?push_back@?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QAEX_W@Z endp
.text$x:0000C78A
.text$x:0000C78A ; ---------------------------------------------------------------------------
.text$x:0000C78F                 align 10h
.text$x:0000C78F _text$x         ends
.text$x:0000C78F
.text$mn:0000C790 ; ===========================================================================
.text$mn:0000C790
.text$mn:0000C790 ; Segment type: Pure code
.text$mn:0000C790 ; Segment permissions: Read/Execute
.text$mn:0000C790 _text$mn        segment para public 'CODE' use32
.text$mn:0000C790                 assume cs:_text$mn
.text$mn:0000C790                 ;org 0C790h
.text$mn:0000C790 ; COMDAT (pick any)
.text$mn:0000C790                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text$mn:0000C790
.text$mn:0000C790 ; =============== S U B R O U T I N E =======================================
.text$mn:0000C790
.text$mn:0000C790 ; Attributes: bp-based frame
.text$mn:0000C790
.text$mn:0000C790 ; public: void __thiscall std::vector<class std::basic_string<wchar_t, struct std::char_traits<wchar_t>, class std::allocator<wchar_t>>, class std::allocator<class std::basic_string<wchar_t, struct std::char_traits<wchar_t>, class std::allocator<wchar_t>>>>::push_back(class std::basic_string<wchar_t, struct std::char_traits<wchar_t>, class std::allocator<wchar_t>> &&)
.text$mn:0000C790                 public ?push_back@?$vector@V?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@V?$allocator@V?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@@2@@std@@QAEX$$QAV?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@2@@Z
.text$mn:0000C790 ?push_back@?$vector@V?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@V?$allocator@V?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@@2@@std@@QAEX$$QAV?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@2@@Z proc near
.text$mn:0000C790                                         ; CODE XREF: tokenizeString(std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>> const &,char)+ADp
.text$mn:0000C790                                         ; stringSplit(std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>> const &,std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>> const &)+97p ...
.text$mn:0000C790
.text$mn:0000C790 var_C           = dword ptr -0Ch
.text$mn:0000C790 var_8           = dword ptr -8
.text$mn:0000C790 var_2           = byte ptr -2
.text$mn:0000C790 var_1           = byte ptr -1
.text$mn:0000C790 arg_0           = dword ptr  8
.text$mn:0000C790
.text$mn:0000C790                 push    ebp
.text$mn:0000C791                 mov     ebp, esp
.text$mn:0000C793                 sub     esp, 0Ch
.text$mn:0000C796                 mov     [ebp+var_8], ecx
.text$mn:0000C799                 mov     eax, [ebp+arg_0]
.text$mn:0000C79C                 push    eax
.text$mn:0000C79D                 call    ??$addressof@V?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@@std@@YAPAV?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@0@AAV10@@Z ; std::addressof<std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>>>(std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>> &)
.text$mn:0000C7A2                 add     esp, 4
.text$mn:0000C7A5                 push    eax
.text$mn:0000C7A6                 mov     ecx, [ebp+var_8]
.text$mn:0000C7A9                 call    ?_Inside@?$vector@V?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@V?$allocator@V?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@@2@@std@@IBE_NPBV?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@2@@Z ; std::vector<std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>>,std::allocator<std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>>>>::_Inside(std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>> const *)
.text$mn:0000C7AE                 movzx   ecx, al
.text$mn:0000C7B1                 test    ecx, ecx
.text$mn:0000C7B3                 jz      loc_C843
.text$mn:0000C7B9                 mov     edx, [ebp+arg_0]
.text$mn:0000C7BC                 push    edx
.text$mn:0000C7BD                 call    ??$addressof@V?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@@std@@YAPAV?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@0@AAV10@@Z ; std::addressof<std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>>>(std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>> &)
.text$mn:0000C7C2                 add     esp, 4
.text$mn:0000C7C5                 mov     ecx, [ebp+var_8]
.text$mn:0000C7C8                 sub     eax, [ecx+4]
.text$mn:0000C7CB                 cdq
.text$mn:0000C7CC                 mov     ecx, 1Ch
.text$mn:0000C7D1                 idiv    ecx
.text$mn:0000C7D3                 mov     [ebp+var_C], eax
.text$mn:0000C7D6                 mov     edx, [ebp+var_8]
.text$mn:0000C7D9                 mov     eax, [ebp+var_8]
.text$mn:0000C7DC                 mov     ecx, [edx+8]
.text$mn:0000C7DF                 cmp     ecx, [eax+0Ch]
.text$mn:0000C7E2                 jnz     short loc_C7EE
.text$mn:0000C7E4                 push    1
.text$mn:0000C7E6                 mov     ecx, [ebp+var_8]
.text$mn:0000C7E9                 call    ?_Reserve@?$vector@V?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@V?$allocator@V?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@@2@@std@@IAEXI@Z ; std::vector<std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>>,std::allocator<std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>>>>::_Reserve(uint)
.text$mn:0000C7EE
.text$mn:0000C7EE loc_C7EE:                               ; CODE XREF: std::vector<std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>>,std::allocator<std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>>>>::push_back(std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>> &&)+52j
.text$mn:0000C7EE                 mov     edx, [ebp+var_8]
.text$mn:0000C7F1                 mov     eax, [edx+8]
.text$mn:0000C7F4                 push    eax
.text$mn:0000C7F5                 mov     ecx, [ebp+var_8]
.text$mn:0000C7F8                 mov     edx, [ecx+8]
.text$mn:0000C7FB                 push    edx
.text$mn:0000C7FC                 mov     ecx, [ebp+var_8]
.text$mn:0000C7FF                 call    ?_Orphan_range@?$vector@V?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@V?$allocator@V?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@@2@@std@@IBEXPAV?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@2@0@Z ; std::vector<std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>>,std::allocator<std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>>>>::_Orphan_range(std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>> *,std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>> *)
.text$mn:0000C804                 imul    eax, [ebp+var_C], 1Ch
.text$mn:0000C808                 mov     ecx, [ebp+var_8]
.text$mn:0000C80B                 add     eax, [ecx+4]
.text$mn:0000C80E                 push    eax
.text$mn:0000C80F                 call    ??$forward@V?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@@std@@YA$$QAV?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@0@AAV10@@Z ; std::forward<std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>>>(std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>> &)
.text$mn:0000C814                 add     esp, 4
.text$mn:0000C817                 push    eax             ; int
.text$mn:0000C818                 mov     edx, [ebp+var_8]
.text$mn:0000C81B                 mov     eax, [edx+8]
.text$mn:0000C81E                 push    eax             ; void *
.text$mn:0000C81F                 lea     ecx, [ebp+var_1]
.text$mn:0000C822                 push    ecx
.text$mn:0000C823                 mov     ecx, [ebp+var_8]
.text$mn:0000C826                 call    ?_Getal@?$_Vector_alloc@$0A@U?$_Vec_base_types@V?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@V?$allocator@V?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@@2@@std@@@std@@QBE?AU?$_Wrap_alloc@V?$allocator@V?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@@std@@@2@XZ ; std::_Vector_alloc<0,std::_Vec_base_types<std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>>,std::allocator<std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>>>>>::_Getal(void)
.text$mn:0000C82B                 mov     ecx, eax
.text$mn:0000C82D                 call    ??$construct@V?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@V12@@?$_Wrap_alloc@V?$allocator@V?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@@std@@@std@@QAEXPAV?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@1@$$QAV21@@Z ; std::_Wrap_alloc<std::allocator<std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>>>>::construct<std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>>,std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>>>(std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>> *,std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>> &&)
.text$mn:0000C832                 mov     edx, [ebp+var_8]
.text$mn:0000C835                 mov     eax, [edx+8]
.text$mn:0000C838                 add     eax, 1Ch
.text$mn:0000C83B                 mov     ecx, [ebp+var_8]
.text$mn:0000C83E                 mov     [ecx+8], eax
.text$mn:0000C841                 jmp     short loc_C8A7
.text$mn:0000C843 ; ---------------------------------------------------------------------------
.text$mn:0000C843
.text$mn:0000C843 loc_C843:                               ; CODE XREF: std::vector<std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>>,std::allocator<std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>>>>::push_back(std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>> &&)+23j
.text$mn:0000C843                 mov     edx, [ebp+var_8]
.text$mn:0000C846                 mov     eax, [ebp+var_8]
.text$mn:0000C849                 mov     ecx, [edx+8]
.text$mn:0000C84C                 cmp     ecx, [eax+0Ch]
.text$mn:0000C84F                 jnz     short loc_C85B
.text$mn:0000C851                 push    1
.text$mn:0000C853                 mov     ecx, [ebp+var_8]
.text$mn:0000C856                 call    ?_Reserve@?$vector@V?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@V?$allocator@V?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@@2@@std@@IAEXI@Z ; std::vector<std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>>,std::allocator<std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>>>>::_Reserve(uint)
.text$mn:0000C85B
.text$mn:0000C85B loc_C85B:                               ; CODE XREF: std::vector<std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>>,std::allocator<std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>>>>::push_back(std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>> &&)+BFj
.text$mn:0000C85B                 mov     edx, [ebp+var_8]
.text$mn:0000C85E                 mov     eax, [edx+8]
.text$mn:0000C861                 push    eax
.text$mn:0000C862                 mov     ecx, [ebp+var_8]
.text$mn:0000C865                 mov     edx, [ecx+8]
.text$mn:0000C868                 push    edx
.text$mn:0000C869                 mov     ecx, [ebp+var_8]
.text$mn:0000C86C                 call    ?_Orphan_range@?$vector@V?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@V?$allocator@V?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@@2@@std@@IBEXPAV?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@2@0@Z ; std::vector<std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>>,std::allocator<std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>>>>::_Orphan_range(std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>> *,std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>> *)
.text$mn:0000C871                 mov     eax, [ebp+arg_0]
.text$mn:0000C874                 push    eax
.text$mn:0000C875                 call    ??$forward@V?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@@std@@YA$$QAV?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@0@AAV10@@Z ; std::forward<std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>>>(std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>> &)
.text$mn:0000C87A                 add     esp, 4
.text$mn:0000C87D                 push    eax             ; int
.text$mn:0000C87E                 mov     ecx, [ebp+var_8]
.text$mn:0000C881                 mov     edx, [ecx+8]
.text$mn:0000C884                 push    edx             ; void *
.text$mn:0000C885                 lea     eax, [ebp+var_2]
.text$mn:0000C888                 push    eax
.text$mn:0000C889                 mov     ecx, [ebp+var_8]
.text$mn:0000C88C                 call    ?_Getal@?$_Vector_alloc@$0A@U?$_Vec_base_types@V?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@V?$allocator@V?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@@2@@std@@@std@@QBE?AU?$_Wrap_alloc@V?$allocator@V?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@@std@@@2@XZ ; std::_Vector_alloc<0,std::_Vec_base_types<std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>>,std::allocator<std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>>>>>::_Getal(void)
.text$mn:0000C891                 mov     ecx, eax
.text$mn:0000C893                 call    ??$construct@V?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@V12@@?$_Wrap_alloc@V?$allocator@V?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@@std@@@std@@QAEXPAV?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@1@$$QAV21@@Z ; std::_Wrap_alloc<std::allocator<std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>>>>::construct<std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>>,std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>>>(std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>> *,std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>> &&)
.text$mn:0000C898                 mov     ecx, [ebp+var_8]
.text$mn:0000C89B                 mov     edx, [ecx+8]
.text$mn:0000C89E                 add     edx, 1Ch
.text$mn:0000C8A1                 mov     eax, [ebp+var_8]
.text$mn:0000C8A4                 mov     [eax+8], edx
.text$mn:0000C8A7
.text$mn:0000C8A7 loc_C8A7:                               ; CODE XREF: std::vector<std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>>,std::allocator<std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>>>>::push_back(std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>> &&)+B1j
.text$mn:0000C8A7                 mov     esp, ebp
.text$mn:0000C8A9                 pop     ebp
.text$mn:0000C8AA                 retn    4
.text$mn:0000C8AA ?push_back@?$vector@V?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@V?$allocator@V?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@@2@@std@@QAEX$$QAV?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@2@@Z endp
.text$mn:0000C8AA
.text$mn:0000C8AA ; ---------------------------------------------------------------------------
.text$mn:0000C8AD                 align 10h
.text$mn:0000C8AD _text$mn        ends
.text$mn:0000C8AD
.text$mn:0000C8B0 ; ===========================================================================
.text$mn:0000C8B0
.text$mn:0000C8B0 ; Segment type: Pure code
.text$mn:0000C8B0 ; Segment permissions: Read/Execute
.text$mn:0000C8B0 _text$mn        segment para public 'CODE' use32
.text$mn:0000C8B0                 assume cs:_text$mn
.text$mn:0000C8B0                 ;org 0C8B0h
.text$mn:0000C8B0 ; COMDAT (pick any)
.text$mn:0000C8B0                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text$mn:0000C8B0
.text$mn:0000C8B0 ; =============== S U B R O U T I N E =======================================
.text$mn:0000C8B0
.text$mn:0000C8B0 ; Attributes: bp-based frame
.text$mn:0000C8B0
.text$mn:0000C8B0 ; public: void __thiscall std::vector<wchar_t, class std::allocator<wchar_t>>::push_back(wchar_t &&)
.text$mn:0000C8B0                 public ?push_back@?$vector@_WV?$allocator@_W@std@@@std@@QAEX$$QA_W@Z
.text$mn:0000C8B0 ?push_back@?$vector@_WV?$allocator@_W@std@@@std@@QAEX$$QA_W@Z proc near
.text$mn:0000C8B0                                         ; CODE XREF: intToString(int)+7Fp
.text$mn:0000C8B0                                         ; intToString(int)+BDp ...
.text$mn:0000C8B0
.text$mn:0000C8B0 var_C           = dword ptr -0Ch
.text$mn:0000C8B0 var_8           = dword ptr -8
.text$mn:0000C8B0 var_2           = byte ptr -2
.text$mn:0000C8B0 var_1           = byte ptr -1
.text$mn:0000C8B0 arg_0           = dword ptr  8
.text$mn:0000C8B0
.text$mn:0000C8B0                 push    ebp
.text$mn:0000C8B1                 mov     ebp, esp
.text$mn:0000C8B3                 sub     esp, 0Ch
.text$mn:0000C8B6                 mov     [ebp+var_8], ecx
.text$mn:0000C8B9                 mov     eax, [ebp+arg_0]
.text$mn:0000C8BC                 push    eax
.text$mn:0000C8BD                 call    ??$addressof@_W@std@@YAPA_WAA_W@Z ; std::addressof<wchar_t>(wchar_t &)
.text$mn:0000C8C2                 add     esp, 4
.text$mn:0000C8C5                 push    eax
.text$mn:0000C8C6                 mov     ecx, [ebp+var_8]
.text$mn:0000C8C9                 call    ?_Inside@?$vector@_WV?$allocator@_W@std@@@std@@IBE_NPB_W@Z ; std::vector<wchar_t,std::allocator<wchar_t>>::_Inside(wchar_t const *)
.text$mn:0000C8CE                 movzx   ecx, al
.text$mn:0000C8D1                 test    ecx, ecx
.text$mn:0000C8D3                 jz      loc_C95F
.text$mn:0000C8D9                 mov     edx, [ebp+arg_0]
.text$mn:0000C8DC                 push    edx
.text$mn:0000C8DD                 call    ??$addressof@_W@std@@YAPA_WAA_W@Z ; std::addressof<wchar_t>(wchar_t &)
.text$mn:0000C8E2                 add     esp, 4
.text$mn:0000C8E5                 mov     ecx, [ebp+var_8]
.text$mn:0000C8E8                 sub     eax, [ecx+4]
.text$mn:0000C8EB                 sar     eax, 1
.text$mn:0000C8ED                 mov     [ebp+var_C], eax
.text$mn:0000C8F0                 mov     edx, [ebp+var_8]
.text$mn:0000C8F3                 mov     eax, [ebp+var_8]
.text$mn:0000C8F6                 mov     ecx, [edx+8]
.text$mn:0000C8F9                 cmp     ecx, [eax+0Ch]
.text$mn:0000C8FC                 jnz     short loc_C908
.text$mn:0000C8FE                 push    1
.text$mn:0000C900                 mov     ecx, [ebp+var_8]
.text$mn:0000C903                 call    ?_Reserve@?$vector@_WV?$allocator@_W@std@@@std@@IAEXI@Z ; std::vector<wchar_t,std::allocator<wchar_t>>::_Reserve(uint)
.text$mn:0000C908
.text$mn:0000C908 loc_C908:                               ; CODE XREF: std::vector<wchar_t,std::allocator<wchar_t>>::push_back(wchar_t &&)+4Cj
.text$mn:0000C908                 mov     edx, [ebp+var_8]
.text$mn:0000C90B                 mov     eax, [edx+8]
.text$mn:0000C90E                 push    eax
.text$mn:0000C90F                 mov     ecx, [ebp+var_8]
.text$mn:0000C912                 mov     edx, [ecx+8]
.text$mn:0000C915                 push    edx
.text$mn:0000C916                 mov     ecx, [ebp+var_8]
.text$mn:0000C919                 call    ?_Orphan_range@?$vector@_WV?$allocator@_W@std@@@std@@IBEXPA_W0@Z ; std::vector<wchar_t,std::allocator<wchar_t>>::_Orphan_range(wchar_t *,wchar_t *)
.text$mn:0000C91E                 mov     eax, [ebp+var_8]
.text$mn:0000C921                 mov     ecx, [eax+4]
.text$mn:0000C924                 mov     edx, [ebp+var_C]
.text$mn:0000C927                 lea     eax, [ecx+edx*2]
.text$mn:0000C92A                 push    eax
.text$mn:0000C92B                 call    ??$forward@_W@std@@YA$$QA_WAA_W@Z ; std::forward<wchar_t>(wchar_t &)
.text$mn:0000C930                 add     esp, 4
.text$mn:0000C933                 push    eax             ; int
.text$mn:0000C934                 mov     ecx, [ebp+var_8]
.text$mn:0000C937                 mov     edx, [ecx+8]
.text$mn:0000C93A                 push    edx             ; void *
.text$mn:0000C93B                 lea     eax, [ebp+var_1]
.text$mn:0000C93E                 push    eax
.text$mn:0000C93F                 mov     ecx, [ebp+var_8]
.text$mn:0000C942                 call    ?_Getal@?$_Vector_alloc@$0A@U?$_Vec_base_types@_WV?$allocator@_W@std@@@std@@@std@@QBE?AU?$_Wrap_alloc@V?$allocator@_W@std@@@2@XZ ; std::_Vector_alloc<0,std::_Vec_base_types<wchar_t,std::allocator<wchar_t>>>::_Getal(void)
.text$mn:0000C947                 mov     ecx, eax
.text$mn:0000C949                 call    ??$construct@_W_W@?$_Wrap_alloc@V?$allocator@_W@std@@@std@@QAEXPA_W$$QA_W@Z ; std::_Wrap_alloc<std::allocator<wchar_t>>::construct<wchar_t,wchar_t>(wchar_t *,wchar_t &&)
.text$mn:0000C94E                 mov     ecx, [ebp+var_8]
.text$mn:0000C951                 mov     edx, [ecx+8]
.text$mn:0000C954                 add     edx, 2
.text$mn:0000C957                 mov     eax, [ebp+var_8]
.text$mn:0000C95A                 mov     [eax+8], edx
.text$mn:0000C95D                 jmp     short loc_C9C3
.text$mn:0000C95F ; ---------------------------------------------------------------------------
.text$mn:0000C95F
.text$mn:0000C95F loc_C95F:                               ; CODE XREF: std::vector<wchar_t,std::allocator<wchar_t>>::push_back(wchar_t &&)+23j
.text$mn:0000C95F                 mov     ecx, [ebp+var_8]
.text$mn:0000C962                 mov     edx, [ebp+var_8]
.text$mn:0000C965                 mov     eax, [ecx+8]
.text$mn:0000C968                 cmp     eax, [edx+0Ch]
.text$mn:0000C96B                 jnz     short loc_C977
.text$mn:0000C96D                 push    1
.text$mn:0000C96F                 mov     ecx, [ebp+var_8]
.text$mn:0000C972                 call    ?_Reserve@?$vector@_WV?$allocator@_W@std@@@std@@IAEXI@Z ; std::vector<wchar_t,std::allocator<wchar_t>>::_Reserve(uint)
.text$mn:0000C977
.text$mn:0000C977 loc_C977:                               ; CODE XREF: std::vector<wchar_t,std::allocator<wchar_t>>::push_back(wchar_t &&)+BBj
.text$mn:0000C977                 mov     ecx, [ebp+var_8]
.text$mn:0000C97A                 mov     edx, [ecx+8]
.text$mn:0000C97D                 push    edx
.text$mn:0000C97E                 mov     eax, [ebp+var_8]
.text$mn:0000C981                 mov     ecx, [eax+8]
.text$mn:0000C984                 push    ecx
.text$mn:0000C985                 mov     ecx, [ebp+var_8]
.text$mn:0000C988                 call    ?_Orphan_range@?$vector@_WV?$allocator@_W@std@@@std@@IBEXPA_W0@Z ; std::vector<wchar_t,std::allocator<wchar_t>>::_Orphan_range(wchar_t *,wchar_t *)
.text$mn:0000C98D                 mov     edx, [ebp+arg_0]
.text$mn:0000C990                 push    edx
.text$mn:0000C991                 call    ??$forward@_W@std@@YA$$QA_WAA_W@Z ; std::forward<wchar_t>(wchar_t &)
.text$mn:0000C996                 add     esp, 4
.text$mn:0000C999                 push    eax             ; int
.text$mn:0000C99A                 mov     eax, [ebp+var_8]
.text$mn:0000C99D                 mov     ecx, [eax+8]
.text$mn:0000C9A0                 push    ecx             ; void *
.text$mn:0000C9A1                 lea     edx, [ebp+var_2]
.text$mn:0000C9A4                 push    edx
.text$mn:0000C9A5                 mov     ecx, [ebp+var_8]
.text$mn:0000C9A8                 call    ?_Getal@?$_Vector_alloc@$0A@U?$_Vec_base_types@_WV?$allocator@_W@std@@@std@@@std@@QBE?AU?$_Wrap_alloc@V?$allocator@_W@std@@@2@XZ ; std::_Vector_alloc<0,std::_Vec_base_types<wchar_t,std::allocator<wchar_t>>>::_Getal(void)
.text$mn:0000C9AD                 mov     ecx, eax
.text$mn:0000C9AF                 call    ??$construct@_W_W@?$_Wrap_alloc@V?$allocator@_W@std@@@std@@QAEXPA_W$$QA_W@Z ; std::_Wrap_alloc<std::allocator<wchar_t>>::construct<wchar_t,wchar_t>(wchar_t *,wchar_t &&)
.text$mn:0000C9B4                 mov     eax, [ebp+var_8]
.text$mn:0000C9B7                 mov     ecx, [eax+8]
.text$mn:0000C9BA                 add     ecx, 2
.text$mn:0000C9BD                 mov     edx, [ebp+var_8]
.text$mn:0000C9C0                 mov     [edx+8], ecx
.text$mn:0000C9C3
.text$mn:0000C9C3 loc_C9C3:                               ; CODE XREF: std::vector<wchar_t,std::allocator<wchar_t>>::push_back(wchar_t &&)+ADj
.text$mn:0000C9C3                 mov     esp, ebp
.text$mn:0000C9C5                 pop     ebp
.text$mn:0000C9C6                 retn    4
.text$mn:0000C9C6 ?push_back@?$vector@_WV?$allocator@_W@std@@@std@@QAEX$$QA_W@Z endp
.text$mn:0000C9C6
.text$mn:0000C9C6 ; ---------------------------------------------------------------------------
.text$mn:0000C9C9                 align 4
.text$mn:0000C9C9 _text$mn        ends
.text$mn:0000C9C9
.text$mn:0000C9CC ; ===========================================================================
.text$mn:0000C9CC
.text$mn:0000C9CC ; Segment type: Pure code
.text$mn:0000C9CC ; Segment permissions: Read/Execute
.text$mn:0000C9CC _text$mn        segment para public 'CODE' use32
.text$mn:0000C9CC                 assume cs:_text$mn
.text$mn:0000C9CC                 ;org 0C9CCh
.text$mn:0000C9CC ; COMDAT (pick any)
.text$mn:0000C9CC                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text$mn:0000C9CC
.text$mn:0000C9CC ; =============== S U B R O U T I N E =======================================
.text$mn:0000C9CC
.text$mn:0000C9CC ; Attributes: bp-based frame
.text$mn:0000C9CC
.text$mn:0000C9CC ; public: class std::reverse_iterator<class std::_Vector_iterator<class std::_Vector_val<struct std::_Simple_types<wchar_t>>>> __thiscall std::vector<wchar_t, class std::allocator<wchar_t>>::rbegin(void)
.text$mn:0000C9CC                 public ?rbegin@?$vector@_WV?$allocator@_W@std@@@std@@QAE?AV?$reverse_iterator@V?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@_W@std@@@std@@@std@@@2@XZ
.text$mn:0000C9CC ?rbegin@?$vector@_WV?$allocator@_W@std@@@std@@QAE?AV?$reverse_iterator@V?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@_W@std@@@std@@@std@@@2@XZ proc near
.text$mn:0000C9CC                                         ; CODE XREF: intToString(int)+119p
.text$mn:0000C9CC                                         ; uintToString(uint)+D2p
.text$mn:0000C9CC
.text$mn:0000C9CC var_34          = byte ptr -34h
.text$mn:0000C9CC var_28          = dword ptr -28h
.text$mn:0000C9CC var_24          = dword ptr -24h
.text$mn:0000C9CC var_20          = dword ptr -20h
.text$mn:0000C9CC var_1C          = dword ptr -1Ch
.text$mn:0000C9CC var_18          = dword ptr -18h
.text$mn:0000C9CC var_14          = dword ptr -14h
.text$mn:0000C9CC var_10          = dword ptr -10h
.text$mn:0000C9CC var_C           = dword ptr -0Ch
.text$mn:0000C9CC var_4           = dword ptr -4
.text$mn:0000C9CC arg_0           = dword ptr  8
.text$mn:0000C9CC
.text$mn:0000C9CC                 push    ebp
.text$mn:0000C9CD                 mov     ebp, esp
.text$mn:0000C9CF                 push    0FFFFFFFFh
.text$mn:0000C9D1                 push    offset __ehhandler$?rbegin@?$vector@_WV?$allocator@_W@std@@@std@@QAE?AV?$reverse_iterator@V?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@_W@std@@@std@@@std@@@2@XZ
.text$mn:0000C9D6                 mov     eax, large fs:0
.text$mn:0000C9DC                 push    eax
.text$mn:0000C9DD                 sub     esp, 28h
.text$mn:0000C9E0                 mov     eax, dword ptr ds:___security_cookie
.text$mn:0000C9E5                 xor     eax, ebp
.text$mn:0000C9E7                 push    eax
.text$mn:0000C9E8                 lea     eax, [ebp+var_C]
.text$mn:0000C9EB                 mov     large fs:0, eax
.text$mn:0000C9F1                 mov     [ebp+var_14], ecx
.text$mn:0000C9F4                 mov     [ebp+var_10], 0
.text$mn:0000C9FB                 sub     esp, 0Ch
.text$mn:0000C9FE                 mov     eax, esp
.text$mn:0000CA00                 mov     [ebp+var_24], esp
.text$mn:0000CA03                 push    eax
.text$mn:0000CA04                 mov     ecx, [ebp+var_14]
.text$mn:0000CA07                 call    ?end@?$vector@_WV?$allocator@_W@std@@@std@@QAE?AV?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@_W@std@@@std@@@2@XZ ; std::vector<wchar_t,std::allocator<wchar_t>>::end(void)
.text$mn:0000CA0C                 mov     [ebp+var_18], eax
.text$mn:0000CA0F                 mov     ecx, [ebp+var_18]
.text$mn:0000CA12                 mov     [ebp+var_28], ecx
.text$mn:0000CA15                 mov     [ebp+var_4], 1
.text$mn:0000CA1C                 mov     byte ptr [ebp+var_4], 0
.text$mn:0000CA20                 lea     ecx, [ebp+var_34]
.text$mn:0000CA23                 call    ??0?$reverse_iterator@V?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@_W@std@@@std@@@std@@@std@@QAE@V?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@_W@std@@@std@@@1@@Z ; std::reverse_iterator<std::_Vector_iterator<std::_Vector_val<std::_Simple_types<wchar_t>>>>::reverse_iterator<std::_Vector_iterator<std::_Vector_val<std::_Simple_types<wchar_t>>>>(std::_Vector_iterator<std::_Vector_val<std::_Simple_types<wchar_t>>>)
.text$mn:0000CA28                 mov     [ebp+var_1C], eax
.text$mn:0000CA2B                 mov     edx, [ebp+var_1C]
.text$mn:0000CA2E                 mov     [ebp+var_20], edx
.text$mn:0000CA31                 mov     [ebp+var_4], 2
.text$mn:0000CA38                 mov     eax, [ebp+var_20]
.text$mn:0000CA3B                 push    eax             ; struct std::_Iterator_base12 *
.text$mn:0000CA3C                 mov     ecx, [ebp+arg_0]
.text$mn:0000CA3F                 call    ??0?$reverse_iterator@V?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@_W@std@@@std@@@std@@@std@@QAE@ABV01@@Z ; std::reverse_iterator<std::_Vector_iterator<std::_Vector_val<std::_Simple_types<wchar_t>>>>::reverse_iterator<std::_Vector_iterator<std::_Vector_val<std::_Simple_types<wchar_t>>>>(std::reverse_iterator<std::_Vector_iterator<std::_Vector_val<std::_Simple_types<wchar_t>>>> const &)
.text$mn:0000CA44                 mov     ecx, [ebp+var_10]
.text$mn:0000CA47                 or      ecx, 1
.text$mn:0000CA4A                 mov     [ebp+var_10], ecx
.text$mn:0000CA4D                 mov     byte ptr [ebp+var_4], 0
.text$mn:0000CA51                 lea     ecx, [ebp+var_34]
.text$mn:0000CA54                 call    ??1?$reverse_iterator@V?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@_W@std@@@std@@@std@@@std@@QAE@XZ ; std::reverse_iterator<std::_Vector_iterator<std::_Vector_val<std::_Simple_types<wchar_t>>>>::~reverse_iterator<std::_Vector_iterator<std::_Vector_val<std::_Simple_types<wchar_t>>>>(void)
.text$mn:0000CA59                 mov     eax, [ebp+arg_0]
.text$mn:0000CA5C                 mov     ecx, [ebp+var_C]
.text$mn:0000CA5F                 mov     large fs:0, ecx
.text$mn:0000CA66                 pop     ecx
.text$mn:0000CA67                 mov     esp, ebp
.text$mn:0000CA69                 pop     ebp
.text$mn:0000CA6A                 retn    4
.text$mn:0000CA6A ?rbegin@?$vector@_WV?$allocator@_W@std@@@std@@QAE?AV?$reverse_iterator@V?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@_W@std@@@std@@@std@@@2@XZ endp
.text$mn:0000CA6A
.text$mn:0000CA6A ; ---------------------------------------------------------------------------
.text$mn:0000CA6D                 align 10h
.text$mn:0000CA6D _text$mn        ends
.text$mn:0000CA6D
.text$x:0000CA70 ; ===========================================================================
.text$x:0000CA70
.text$x:0000CA70 ; Segment type: Pure code
.text$x:0000CA70 ; Segment permissions: Read/Execute
.text$x:0000CA70 _text$x         segment para public 'CODE' use32
.text$x:0000CA70                 assume cs:_text$x
.text$x:0000CA70                 ;org 0CA70h
.text$x:0000CA70 ; COMDAT (pick associative to section at C9CC)
.text$x:0000CA70                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text$x:0000CA70
.text$x:0000CA70 ; =============== S U B R O U T I N E =======================================
.text$x:0000CA70
.text$x:0000CA70
.text$x:0000CA70 __unwindfunclet$?rbegin@?$vector@_WV?$allocator@_W@std@@@std@@QAE?AV?$reverse_iterator@V?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@_W@std@@@std@@@std@@@2@XZ$0 proc near
.text$x:0000CA70                                         ; DATA XREF: .xdata$x:0000E584o
.text$x:0000CA70                 mov     ecx, [ebp-24h]
.text$x:0000CA73                 jmp     ??1?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@_W@std@@@std@@@std@@QAE@XZ ; std::_Vector_iterator<std::_Vector_val<std::_Simple_types<wchar_t>>>::~_Vector_iterator<std::_Vector_val<std::_Simple_types<wchar_t>>>(void)
.text$x:0000CA73 __unwindfunclet$?rbegin@?$vector@_WV?$allocator@_W@std@@@std@@QAE?AV?$reverse_iterator@V?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@_W@std@@@std@@@std@@@2@XZ$0 endp
.text$x:0000CA73
.text$x:0000CA78
.text$x:0000CA78 ; =============== S U B R O U T I N E =======================================
.text$x:0000CA78
.text$x:0000CA78
.text$x:0000CA78 __unwindfunclet$?rbegin@?$vector@_WV?$allocator@_W@std@@@std@@QAE?AV?$reverse_iterator@V?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@_W@std@@@std@@@std@@@2@XZ$1 proc near
.text$x:0000CA78                                         ; DATA XREF: .xdata$x:0000E58Co
.text$x:0000CA78                 lea     ecx, [ebp-34h]
.text$x:0000CA7B                 jmp     ??1?$reverse_iterator@V?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@_W@std@@@std@@@std@@@std@@QAE@XZ ; std::reverse_iterator<std::_Vector_iterator<std::_Vector_val<std::_Simple_types<wchar_t>>>>::~reverse_iterator<std::_Vector_iterator<std::_Vector_val<std::_Simple_types<wchar_t>>>>(void)
.text$x:0000CA7B __unwindfunclet$?rbegin@?$vector@_WV?$allocator@_W@std@@@std@@QAE?AV?$reverse_iterator@V?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@_W@std@@@std@@@std@@@2@XZ$1 endp
.text$x:0000CA7B
.text$x:0000CA80
.text$x:0000CA80 ; =============== S U B R O U T I N E =======================================
.text$x:0000CA80
.text$x:0000CA80
.text$x:0000CA80 __unwindfunclet$?rbegin@?$vector@_WV?$allocator@_W@std@@@std@@QAE?AV?$reverse_iterator@V?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@_W@std@@@std@@@std@@@2@XZ$2 proc near
.text$x:0000CA80                                         ; DATA XREF: .xdata$x:0000E57Co
.text$x:0000CA80                 mov     eax, [ebp-10h]
.text$x:0000CA83                 and     eax, 1
.text$x:0000CA86                 jz      $LN6_2
.text$x:0000CA8C                 and     dword ptr [ebp-10h], 0FFFFFFFEh
.text$x:0000CA90                 mov     ecx, [ebp+8]
.text$x:0000CA93                 jmp     ??1?$reverse_iterator@V?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@_W@std@@@std@@@std@@@std@@QAE@XZ ; std::reverse_iterator<std::_Vector_iterator<std::_Vector_val<std::_Simple_types<wchar_t>>>>::~reverse_iterator<std::_Vector_iterator<std::_Vector_val<std::_Simple_types<wchar_t>>>>(void)
.text$x:0000CA98 ; ---------------------------------------------------------------------------
.text$x:0000CA98
.text$x:0000CA98 $LN6_2:                                 ; CODE XREF: __unwindfunclet$?rbegin@?$vector@_WV?$allocator@_W@std@@@std@@QAE?AV?$reverse_iterator@V?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@_W@std@@@std@@@std@@@2@XZ$2+6j
.text$x:0000CA98                 retn
.text$x:0000CA98 __unwindfunclet$?rbegin@?$vector@_WV?$allocator@_W@std@@@std@@QAE?AV?$reverse_iterator@V?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@_W@std@@@std@@@std@@@2@XZ$2 endp
.text$x:0000CA98
.text$x:0000CA99
.text$x:0000CA99 ; =============== S U B R O U T I N E =======================================
.text$x:0000CA99
.text$x:0000CA99
.text$x:0000CA99 __ehhandler$?rbegin@?$vector@_WV?$allocator@_W@std@@@std@@QAE?AV?$reverse_iterator@V?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@_W@std@@@std@@@std@@@2@XZ proc near
.text$x:0000CA99                                         ; DATA XREF: std::vector<wchar_t,std::allocator<wchar_t>>::rbegin(void)+5o
.text$x:0000CA99
.text$x:0000CA99 arg_4           = dword ptr  8
.text$x:0000CA99
.text$x:0000CA99                 mov     edx, [esp+arg_4]
.text$x:0000CA9D                 lea     eax, [edx+0Ch]
.text$x:0000CAA0                 mov     ecx, [edx-2Ch]
.text$x:0000CAA3                 xor     ecx, eax
.text$x:0000CAA5                 call    @__security_check_cookie@4 ; __security_check_cookie(x)
.text$x:0000CAAA                 mov     eax, offset __ehfuncinfo$?rbegin@?$vector@_WV?$allocator@_W@std@@@std@@QAE?AV?$reverse_iterator@V?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@_W@std@@@std@@@std@@@2@XZ
.text$x:0000CAAF                 jmp     ___CxxFrameHandler3
.text$x:0000CAAF __ehhandler$?rbegin@?$vector@_WV?$allocator@_W@std@@@std@@QAE?AV?$reverse_iterator@V?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@_W@std@@@std@@@std@@@2@XZ endp
.text$x:0000CAAF
.text$x:0000CAAF _text$x         ends
.text$x:0000CAAF
.text$mn:0000CAB4 ; ===========================================================================
.text$mn:0000CAB4
.text$mn:0000CAB4 ; Segment type: Pure code
.text$mn:0000CAB4 ; Segment permissions: Read/Execute
.text$mn:0000CAB4 _text$mn        segment para public 'CODE' use32
.text$mn:0000CAB4                 assume cs:_text$mn
.text$mn:0000CAB4                 ;org 0CAB4h
.text$mn:0000CAB4 ; COMDAT (pick any)
.text$mn:0000CAB4                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text$mn:0000CAB4
.text$mn:0000CAB4 ; =============== S U B R O U T I N E =======================================
.text$mn:0000CAB4
.text$mn:0000CAB4 ; Attributes: bp-based frame
.text$mn:0000CAB4
.text$mn:0000CAB4 ; public: class std::reverse_iterator<class std::_Vector_iterator<class std::_Vector_val<struct std::_Simple_types<wchar_t>>>> __thiscall std::vector<wchar_t, class std::allocator<wchar_t>>::rend(void)
.text$mn:0000CAB4                 public ?rend@?$vector@_WV?$allocator@_W@std@@@std@@QAE?AV?$reverse_iterator@V?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@_W@std@@@std@@@std@@@2@XZ
.text$mn:0000CAB4 ?rend@?$vector@_WV?$allocator@_W@std@@@std@@QAE?AV?$reverse_iterator@V?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@_W@std@@@std@@@std@@@2@XZ proc near
.text$mn:0000CAB4                                         ; CODE XREF: intToString(int)+FBp
.text$mn:0000CAB4                                         ; uintToString(uint)+B4p
.text$mn:0000CAB4
.text$mn:0000CAB4 var_34          = byte ptr -34h
.text$mn:0000CAB4 var_28          = dword ptr -28h
.text$mn:0000CAB4 var_24          = dword ptr -24h
.text$mn:0000CAB4 var_20          = dword ptr -20h
.text$mn:0000CAB4 var_1C          = dword ptr -1Ch
.text$mn:0000CAB4 var_18          = dword ptr -18h
.text$mn:0000CAB4 var_14          = dword ptr -14h
.text$mn:0000CAB4 var_10          = dword ptr -10h
.text$mn:0000CAB4 var_C           = dword ptr -0Ch
.text$mn:0000CAB4 var_4           = dword ptr -4
.text$mn:0000CAB4 arg_0           = dword ptr  8
.text$mn:0000CAB4
.text$mn:0000CAB4                 push    ebp
.text$mn:0000CAB5                 mov     ebp, esp
.text$mn:0000CAB7                 push    0FFFFFFFFh
.text$mn:0000CAB9                 push    offset __ehhandler$?rend@?$vector@_WV?$allocator@_W@std@@@std@@QAE?AV?$reverse_iterator@V?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@_W@std@@@std@@@std@@@2@XZ
.text$mn:0000CABE                 mov     eax, large fs:0
.text$mn:0000CAC4                 push    eax
.text$mn:0000CAC5                 sub     esp, 28h
.text$mn:0000CAC8                 mov     eax, dword ptr ds:___security_cookie
.text$mn:0000CACD                 xor     eax, ebp
.text$mn:0000CACF                 push    eax
.text$mn:0000CAD0                 lea     eax, [ebp+var_C]
.text$mn:0000CAD3                 mov     large fs:0, eax
.text$mn:0000CAD9                 mov     [ebp+var_14], ecx
.text$mn:0000CADC                 mov     [ebp+var_10], 0
.text$mn:0000CAE3                 sub     esp, 0Ch
.text$mn:0000CAE6                 mov     eax, esp
.text$mn:0000CAE8                 mov     [ebp+var_24], esp
.text$mn:0000CAEB                 push    eax
.text$mn:0000CAEC                 mov     ecx, [ebp+var_14]
.text$mn:0000CAEF                 call    ?begin@?$vector@_WV?$allocator@_W@std@@@std@@QAE?AV?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@_W@std@@@std@@@2@XZ ; std::vector<wchar_t,std::allocator<wchar_t>>::begin(void)
.text$mn:0000CAF4                 mov     [ebp+var_18], eax
.text$mn:0000CAF7                 mov     ecx, [ebp+var_18]
.text$mn:0000CAFA                 mov     [ebp+var_28], ecx
.text$mn:0000CAFD                 mov     [ebp+var_4], 1
.text$mn:0000CB04                 mov     byte ptr [ebp+var_4], 0
.text$mn:0000CB08                 lea     ecx, [ebp+var_34]
.text$mn:0000CB0B                 call    ??0?$reverse_iterator@V?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@_W@std@@@std@@@std@@@std@@QAE@V?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@_W@std@@@std@@@1@@Z ; std::reverse_iterator<std::_Vector_iterator<std::_Vector_val<std::_Simple_types<wchar_t>>>>::reverse_iterator<std::_Vector_iterator<std::_Vector_val<std::_Simple_types<wchar_t>>>>(std::_Vector_iterator<std::_Vector_val<std::_Simple_types<wchar_t>>>)
.text$mn:0000CB10                 mov     [ebp+var_1C], eax
.text$mn:0000CB13                 mov     edx, [ebp+var_1C]
.text$mn:0000CB16                 mov     [ebp+var_20], edx
.text$mn:0000CB19                 mov     [ebp+var_4], 2
.text$mn:0000CB20                 mov     eax, [ebp+var_20]
.text$mn:0000CB23                 push    eax             ; struct std::_Iterator_base12 *
.text$mn:0000CB24                 mov     ecx, [ebp+arg_0]
.text$mn:0000CB27                 call    ??0?$reverse_iterator@V?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@_W@std@@@std@@@std@@@std@@QAE@ABV01@@Z ; std::reverse_iterator<std::_Vector_iterator<std::_Vector_val<std::_Simple_types<wchar_t>>>>::reverse_iterator<std::_Vector_iterator<std::_Vector_val<std::_Simple_types<wchar_t>>>>(std::reverse_iterator<std::_Vector_iterator<std::_Vector_val<std::_Simple_types<wchar_t>>>> const &)
.text$mn:0000CB2C                 mov     ecx, [ebp+var_10]
.text$mn:0000CB2F                 or      ecx, 1
.text$mn:0000CB32                 mov     [ebp+var_10], ecx
.text$mn:0000CB35                 mov     byte ptr [ebp+var_4], 0
.text$mn:0000CB39                 lea     ecx, [ebp+var_34]
.text$mn:0000CB3C                 call    ??1?$reverse_iterator@V?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@_W@std@@@std@@@std@@@std@@QAE@XZ ; std::reverse_iterator<std::_Vector_iterator<std::_Vector_val<std::_Simple_types<wchar_t>>>>::~reverse_iterator<std::_Vector_iterator<std::_Vector_val<std::_Simple_types<wchar_t>>>>(void)
.text$mn:0000CB41                 mov     eax, [ebp+arg_0]
.text$mn:0000CB44                 mov     ecx, [ebp+var_C]
.text$mn:0000CB47                 mov     large fs:0, ecx
.text$mn:0000CB4E                 pop     ecx
.text$mn:0000CB4F                 mov     esp, ebp
.text$mn:0000CB51                 pop     ebp
.text$mn:0000CB52                 retn    4
.text$mn:0000CB52 ?rend@?$vector@_WV?$allocator@_W@std@@@std@@QAE?AV?$reverse_iterator@V?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@_W@std@@@std@@@std@@@2@XZ endp
.text$mn:0000CB52
.text$mn:0000CB52 ; ---------------------------------------------------------------------------
.text$mn:0000CB55                 align 4
.text$mn:0000CB55 _text$mn        ends
.text$mn:0000CB55
.text$x:0000CB58 ; ===========================================================================
.text$x:0000CB58
.text$x:0000CB58 ; Segment type: Pure code
.text$x:0000CB58 ; Segment permissions: Read/Execute
.text$x:0000CB58 _text$x         segment para public 'CODE' use32
.text$x:0000CB58                 assume cs:_text$x
.text$x:0000CB58                 ;org 0CB58h
.text$x:0000CB58 ; COMDAT (pick associative to section at CAB4)
.text$x:0000CB58                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text$x:0000CB58
.text$x:0000CB58 ; =============== S U B R O U T I N E =======================================
.text$x:0000CB58
.text$x:0000CB58
.text$x:0000CB58 __unwindfunclet$?rend@?$vector@_WV?$allocator@_W@std@@@std@@QAE?AV?$reverse_iterator@V?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@_W@std@@@std@@@std@@@2@XZ$0 proc near
.text$x:0000CB58                                         ; DATA XREF: .xdata$x:0000E5C0o
.text$x:0000CB58                 mov     ecx, [ebp-24h]
.text$x:0000CB5B                 jmp     ??1?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@_W@std@@@std@@@std@@QAE@XZ ; std::_Vector_iterator<std::_Vector_val<std::_Simple_types<wchar_t>>>::~_Vector_iterator<std::_Vector_val<std::_Simple_types<wchar_t>>>(void)
.text$x:0000CB5B __unwindfunclet$?rend@?$vector@_WV?$allocator@_W@std@@@std@@QAE?AV?$reverse_iterator@V?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@_W@std@@@std@@@std@@@2@XZ$0 endp
.text$x:0000CB5B
.text$x:0000CB60
.text$x:0000CB60 ; =============== S U B R O U T I N E =======================================
.text$x:0000CB60
.text$x:0000CB60
.text$x:0000CB60 __unwindfunclet$?rend@?$vector@_WV?$allocator@_W@std@@@std@@QAE?AV?$reverse_iterator@V?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@_W@std@@@std@@@std@@@2@XZ$1 proc near
.text$x:0000CB60                                         ; DATA XREF: .xdata$x:0000E5C8o
.text$x:0000CB60                 lea     ecx, [ebp-34h]
.text$x:0000CB63                 jmp     ??1?$reverse_iterator@V?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@_W@std@@@std@@@std@@@std@@QAE@XZ ; std::reverse_iterator<std::_Vector_iterator<std::_Vector_val<std::_Simple_types<wchar_t>>>>::~reverse_iterator<std::_Vector_iterator<std::_Vector_val<std::_Simple_types<wchar_t>>>>(void)
.text$x:0000CB63 __unwindfunclet$?rend@?$vector@_WV?$allocator@_W@std@@@std@@QAE?AV?$reverse_iterator@V?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@_W@std@@@std@@@std@@@2@XZ$1 endp
.text$x:0000CB63
.text$x:0000CB68
.text$x:0000CB68 ; =============== S U B R O U T I N E =======================================
.text$x:0000CB68
.text$x:0000CB68
.text$x:0000CB68 __unwindfunclet$?rend@?$vector@_WV?$allocator@_W@std@@@std@@QAE?AV?$reverse_iterator@V?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@_W@std@@@std@@@std@@@2@XZ$2 proc near
.text$x:0000CB68                                         ; DATA XREF: .xdata$x:0000E5B8o
.text$x:0000CB68                 mov     eax, [ebp-10h]
.text$x:0000CB6B                 and     eax, 1
.text$x:0000CB6E                 jz      $LN6_3
.text$x:0000CB74                 and     dword ptr [ebp-10h], 0FFFFFFFEh
.text$x:0000CB78                 mov     ecx, [ebp+8]
.text$x:0000CB7B                 jmp     ??1?$reverse_iterator@V?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@_W@std@@@std@@@std@@@std@@QAE@XZ ; std::reverse_iterator<std::_Vector_iterator<std::_Vector_val<std::_Simple_types<wchar_t>>>>::~reverse_iterator<std::_Vector_iterator<std::_Vector_val<std::_Simple_types<wchar_t>>>>(void)
.text$x:0000CB80 ; ---------------------------------------------------------------------------
.text$x:0000CB80
.text$x:0000CB80 $LN6_3:                                 ; CODE XREF: __unwindfunclet$?rend@?$vector@_WV?$allocator@_W@std@@@std@@QAE?AV?$reverse_iterator@V?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@_W@std@@@std@@@std@@@2@XZ$2+6j
.text$x:0000CB80                 retn
.text$x:0000CB80 __unwindfunclet$?rend@?$vector@_WV?$allocator@_W@std@@@std@@QAE?AV?$reverse_iterator@V?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@_W@std@@@std@@@std@@@2@XZ$2 endp
.text$x:0000CB80
.text$x:0000CB81
.text$x:0000CB81 ; =============== S U B R O U T I N E =======================================
.text$x:0000CB81
.text$x:0000CB81
.text$x:0000CB81 __ehhandler$?rend@?$vector@_WV?$allocator@_W@std@@@std@@QAE?AV?$reverse_iterator@V?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@_W@std@@@std@@@std@@@2@XZ proc near
.text$x:0000CB81                                         ; DATA XREF: std::vector<wchar_t,std::allocator<wchar_t>>::rend(void)+5o
.text$x:0000CB81
.text$x:0000CB81 arg_4           = dword ptr  8
.text$x:0000CB81
.text$x:0000CB81                 mov     edx, [esp+arg_4]
.text$x:0000CB85                 lea     eax, [edx+0Ch]
.text$x:0000CB88                 mov     ecx, [edx-2Ch]
.text$x:0000CB8B                 xor     ecx, eax
.text$x:0000CB8D                 call    @__security_check_cookie@4 ; __security_check_cookie(x)
.text$x:0000CB92                 mov     eax, offset __ehfuncinfo$?rend@?$vector@_WV?$allocator@_W@std@@@std@@QAE?AV?$reverse_iterator@V?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@_W@std@@@std@@@std@@@2@XZ
.text$x:0000CB97                 jmp     ___CxxFrameHandler3
.text$x:0000CB97 __ehhandler$?rend@?$vector@_WV?$allocator@_W@std@@@std@@QAE?AV?$reverse_iterator@V?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@_W@std@@@std@@@std@@@2@XZ endp
.text$x:0000CB97
.text$x:0000CB97 _text$x         ends
.text$x:0000CB97
.text$mn:0000CB9C ; ===========================================================================
.text$mn:0000CB9C
.text$mn:0000CB9C ; Segment type: Pure code
.text$mn:0000CB9C ; Segment permissions: Read/Execute
.text$mn:0000CB9C _text$mn        segment para public 'CODE' use32
.text$mn:0000CB9C                 assume cs:_text$mn
.text$mn:0000CB9C                 ;org 0CB9Ch
.text$mn:0000CB9C ; COMDAT (pick any)
.text$mn:0000CB9C                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text$mn:0000CB9C
.text$mn:0000CB9C ; =============== S U B R O U T I N E =======================================
.text$mn:0000CB9C
.text$mn:0000CB9C ; Attributes: bp-based frame
.text$mn:0000CB9C
.text$mn:0000CB9C ; public: class std::basic_string<wchar_t, struct std::char_traits<wchar_t>, class std::allocator<wchar_t>> & __thiscall std::basic_string<wchar_t, struct std::char_traits<wchar_t>, class std::allocator<wchar_t>>::replace(unsigned int, unsigned int, class std::basic_string<wchar_t, struct std::char_traits<wchar_t>, class std::allocator<wchar_t>> const &)
.text$mn:0000CB9C                 public ?replace@?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QAEAAV12@IIABV12@@Z
.text$mn:0000CB9C ?replace@?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QAEAAV12@IIABV12@@Z proc near
.text$mn:0000CB9C                                         ; CODE XREF: stringReplace(std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>>,std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>> const &,std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>> const &)+6Cp
.text$mn:0000CB9C
.text$mn:0000CB9C var_4           = dword ptr -4
.text$mn:0000CB9C arg_0           = dword ptr  8
.text$mn:0000CB9C arg_4           = dword ptr  0Ch
.text$mn:0000CB9C arg_8           = dword ptr  10h
.text$mn:0000CB9C
.text$mn:0000CB9C                 push    ebp
.text$mn:0000CB9D                 mov     ebp, esp
.text$mn:0000CB9F                 push    ecx
.text$mn:0000CBA0                 mov     [ebp+var_4], ecx
.text$mn:0000CBA3                 mov     eax, ds:?npos@?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@2IB ; uint const std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>>::npos
.text$mn:0000CBA8                 push    eax
.text$mn:0000CBA9                 push    0
.text$mn:0000CBAB                 mov     ecx, [ebp+arg_8]
.text$mn:0000CBAE                 push    ecx
.text$mn:0000CBAF                 mov     edx, [ebp+arg_4]
.text$mn:0000CBB2                 push    edx
.text$mn:0000CBB3                 mov     eax, [ebp+arg_0]
.text$mn:0000CBB6                 push    eax
.text$mn:0000CBB7                 mov     ecx, [ebp+var_4]
.text$mn:0000CBBA                 call    ?replace@?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QAEAAV12@IIABV12@II@Z ; std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>>::replace(uint,uint,std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>> const &,uint,uint)
.text$mn:0000CBBF                 mov     esp, ebp
.text$mn:0000CBC1                 pop     ebp
.text$mn:0000CBC2                 retn    0Ch
.text$mn:0000CBC2 ?replace@?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QAEAAV12@IIABV12@@Z endp
.text$mn:0000CBC2
.text$mn:0000CBC2 ; ---------------------------------------------------------------------------
.text$mn:0000CBC5                 align 4
.text$mn:0000CBC5 _text$mn        ends
.text$mn:0000CBC5
.text$mn:0000CBC8 ; ===========================================================================
.text$mn:0000CBC8
.text$mn:0000CBC8 ; Segment type: Pure code
.text$mn:0000CBC8 ; Segment permissions: Read/Execute
.text$mn:0000CBC8 _text$mn        segment para public 'CODE' use32
.text$mn:0000CBC8                 assume cs:_text$mn
.text$mn:0000CBC8                 ;org 0CBC8h
.text$mn:0000CBC8 ; COMDAT (pick any)
.text$mn:0000CBC8                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text$mn:0000CBC8
.text$mn:0000CBC8 ; =============== S U B R O U T I N E =======================================
.text$mn:0000CBC8
.text$mn:0000CBC8 ; Attributes: bp-based frame
.text$mn:0000CBC8
.text$mn:0000CBC8 ; public: class std::basic_string<wchar_t, struct std::char_traits<wchar_t>, class std::allocator<wchar_t>> & __thiscall std::basic_string<wchar_t, struct std::char_traits<wchar_t>, class std::allocator<wchar_t>>::replace(unsigned int, unsigned int, class std::basic_string<wchar_t, struct std::char_traits<wchar_t>, class std::allocator<wchar_t>> const &, unsigned int, unsigned int)
.text$mn:0000CBC8                 public ?replace@?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QAEAAV12@IIABV12@II@Z
.text$mn:0000CBC8 ?replace@?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QAEAAV12@IIABV12@II@Z proc near
.text$mn:0000CBC8                                         ; CODE XREF: std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>>::replace(uint,uint,std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>> const &)+1Ep
.text$mn:0000CBC8
.text$mn:0000CBC8 var_10          = dword ptr -10h
.text$mn:0000CBC8 var_C           = dword ptr -0Ch
.text$mn:0000CBC8 var_8           = dword ptr -8
.text$mn:0000CBC8 var_4           = dword ptr -4
.text$mn:0000CBC8 arg_0           = dword ptr  8
.text$mn:0000CBC8 arg_4           = dword ptr  0Ch
.text$mn:0000CBC8 arg_8           = dword ptr  10h
.text$mn:0000CBC8 arg_C           = dword ptr  14h
.text$mn:0000CBC8 arg_10          = dword ptr  18h
.text$mn:0000CBC8
.text$mn:0000CBC8                 push    ebp
.text$mn:0000CBC9                 mov     ebp, esp
.text$mn:0000CBCB                 sub     esp, 10h
.text$mn:0000CBCE                 mov     [ebp+var_4], ecx
.text$mn:0000CBD1                 mov     eax, [ebp+var_4]
.text$mn:0000CBD4                 mov     ecx, [eax+14h]
.text$mn:0000CBD7                 cmp     ecx, [ebp+arg_0]
.text$mn:0000CBDA                 jb      short loc_CBE9
.text$mn:0000CBDC                 mov     ecx, [ebp+arg_8]
.text$mn:0000CBDF                 call    ?size@?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QBEIXZ ; std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>>::size(void)
.text$mn:0000CBE4                 cmp     eax, [ebp+arg_C]
.text$mn:0000CBE7                 jnb     short loc_CBF1
.text$mn:0000CBE9
.text$mn:0000CBE9 loc_CBE9:                               ; CODE XREF: std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>>::replace(uint,uint,std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>> const &,uint,uint)+12j
.text$mn:0000CBE9                 mov     ecx, [ebp+var_4]
.text$mn:0000CBEC                 call    ?_Xran@?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QBEXXZ ; std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>>::_Xran(void)
.text$mn:0000CBF1
.text$mn:0000CBF1 loc_CBF1:                               ; CODE XREF: std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>>::replace(uint,uint,std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>> const &,uint,uint)+1Fj
.text$mn:0000CBF1                 mov     edx, [ebp+var_4]
.text$mn:0000CBF4                 mov     eax, [edx+14h]
.text$mn:0000CBF7                 sub     eax, [ebp+arg_0]
.text$mn:0000CBFA                 cmp     eax, [ebp+arg_4]
.text$mn:0000CBFD                 jnb     short loc_CC0B
.text$mn:0000CBFF                 mov     ecx, [ebp+var_4]
.text$mn:0000CC02                 mov     edx, [ecx+14h]
.text$mn:0000CC05                 sub     edx, [ebp+arg_0]
.text$mn:0000CC08                 mov     [ebp+arg_4], edx
.text$mn:0000CC0B
.text$mn:0000CC0B loc_CC0B:                               ; CODE XREF: std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>>::replace(uint,uint,std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>> const &,uint,uint)+35j
.text$mn:0000CC0B                 mov     ecx, [ebp+arg_8]
.text$mn:0000CC0E                 call    ?size@?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QBEIXZ ; std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>>::size(void)
.text$mn:0000CC13                 sub     eax, [ebp+arg_C]
.text$mn:0000CC16                 mov     [ebp+var_10], eax
.text$mn:0000CC19                 mov     eax, [ebp+var_10]
.text$mn:0000CC1C                 cmp     eax, [ebp+arg_10]
.text$mn:0000CC1F                 jnb     short loc_CC27
.text$mn:0000CC21                 mov     ecx, [ebp+var_10]
.text$mn:0000CC24                 mov     [ebp+arg_10], ecx
.text$mn:0000CC27
.text$mn:0000CC27 loc_CC27:                               ; CODE XREF: std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>>::replace(uint,uint,std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>> const &,uint,uint)+57j
.text$mn:0000CC27                 mov     edx, ds:?npos@?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@2IB ; uint const std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>>::npos
.text$mn:0000CC2D                 sub     edx, [ebp+arg_10]
.text$mn:0000CC30                 mov     eax, [ebp+var_4]
.text$mn:0000CC33                 mov     ecx, [eax+14h]
.text$mn:0000CC36                 sub     ecx, [ebp+arg_4]
.text$mn:0000CC39                 cmp     edx, ecx
.text$mn:0000CC3B                 ja      short loc_CC45
.text$mn:0000CC3D                 mov     ecx, [ebp+var_4]
.text$mn:0000CC40                 call    ?_Xlen@?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QBEXXZ ; std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>>::_Xlen(void)
.text$mn:0000CC45
.text$mn:0000CC45 loc_CC45:                               ; CODE XREF: std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>>::replace(uint,uint,std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>> const &,uint,uint)+73j
.text$mn:0000CC45                 mov     edx, [ebp+var_4]
.text$mn:0000CC48                 mov     eax, [edx+14h]
.text$mn:0000CC4B                 sub     eax, [ebp+arg_4]
.text$mn:0000CC4E                 sub     eax, [ebp+arg_0]
.text$mn:0000CC51                 mov     [ebp+var_8], eax
.text$mn:0000CC54                 mov     ecx, [ebp+var_4]
.text$mn:0000CC57                 mov     edx, [ecx+14h]
.text$mn:0000CC5A                 add     edx, [ebp+arg_10]
.text$mn:0000CC5D                 sub     edx, [ebp+arg_4]
.text$mn:0000CC60                 mov     [ebp+var_C], edx
.text$mn:0000CC63                 mov     eax, [ebp+var_4]
.text$mn:0000CC66                 mov     ecx, [eax+14h]
.text$mn:0000CC69                 cmp     ecx, [ebp+var_C]
.text$mn:0000CC6C                 jnb     short loc_CC7C
.text$mn:0000CC6E                 push    0
.text$mn:0000CC70                 mov     edx, [ebp+var_C]
.text$mn:0000CC73                 push    edx
.text$mn:0000CC74                 mov     ecx, [ebp+var_4]
.text$mn:0000CC77                 call    ?_Grow@?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QAE_NI_N@Z ; std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>>::_Grow(uint,bool)
.text$mn:0000CC7C
.text$mn:0000CC7C loc_CC7C:                               ; CODE XREF: std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>>::replace(uint,uint,std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>> const &,uint,uint)+A4j
.text$mn:0000CC7C                 mov     eax, [ebp+var_4]
.text$mn:0000CC7F                 cmp     eax, [ebp+arg_8]
.text$mn:0000CC82                 jz      short loc_CCE9
.text$mn:0000CC84                 mov     ecx, [ebp+var_8]
.text$mn:0000CC87                 push    ecx             ; int
.text$mn:0000CC88                 mov     ecx, [ebp+var_4]
.text$mn:0000CC8B                 call    ?_Myptr@?$_String_val@U?$_Simple_types@_W@std@@@std@@QAEPA_WXZ ; std::_String_val<std::_Simple_types<wchar_t>>::_Myptr(void)
.text$mn:0000CC90                 mov     edx, [ebp+arg_0]
.text$mn:0000CC93                 lea     eax, [eax+edx*2]
.text$mn:0000CC96                 mov     ecx, [ebp+arg_4]
.text$mn:0000CC99                 lea     edx, [eax+ecx*2]
.text$mn:0000CC9C                 push    edx             ; Src
.text$mn:0000CC9D                 mov     ecx, [ebp+var_4]
.text$mn:0000CCA0                 call    ?_Myptr@?$_String_val@U?$_Simple_types@_W@std@@@std@@QAEPA_WXZ ; std::_String_val<std::_Simple_types<wchar_t>>::_Myptr(void)
.text$mn:0000CCA5                 mov     ecx, [ebp+arg_0]
.text$mn:0000CCA8                 lea     edx, [eax+ecx*2]
.text$mn:0000CCAB                 mov     eax, [ebp+arg_10]
.text$mn:0000CCAE                 lea     ecx, [edx+eax*2]
.text$mn:0000CCB1                 push    ecx             ; Dst
.text$mn:0000CCB2                 call    ?move@?$char_traits@_W@std@@SAPA_WPA_WPB_WI@Z ; std::char_traits<wchar_t>::move(wchar_t *,wchar_t const *,uint)
.text$mn:0000CCB7                 add     esp, 0Ch
.text$mn:0000CCBA                 mov     edx, [ebp+arg_10]
.text$mn:0000CCBD                 push    edx             ; int
.text$mn:0000CCBE                 mov     ecx, [ebp+arg_8]
.text$mn:0000CCC1                 call    ?_Myptr@?$_String_val@U?$_Simple_types@_W@std@@@std@@QBEPB_WXZ ; std::_String_val<std::_Simple_types<wchar_t>>::_Myptr(void)
.text$mn:0000CCC6                 mov     ecx, [ebp+arg_C]
.text$mn:0000CCC9                 lea     edx, [eax+ecx*2]
.text$mn:0000CCCC                 push    edx             ; Src
.text$mn:0000CCCD                 mov     ecx, [ebp+var_4]
.text$mn:0000CCD0                 call    ?_Myptr@?$_String_val@U?$_Simple_types@_W@std@@@std@@QAEPA_WXZ ; std::_String_val<std::_Simple_types<wchar_t>>::_Myptr(void)
.text$mn:0000CCD5                 mov     ecx, [ebp+arg_0]
.text$mn:0000CCD8                 lea     edx, [eax+ecx*2]
.text$mn:0000CCDB                 push    edx             ; Dst
.text$mn:0000CCDC                 call    ?copy@?$char_traits@_W@std@@SAPA_WPA_WPB_WI@Z ; std::char_traits<wchar_t>::copy(wchar_t *,wchar_t const *,uint)
.text$mn:0000CCE1                 add     esp, 0Ch
.text$mn:0000CCE4                 jmp     loc_CED2
.text$mn:0000CCE9 ; ---------------------------------------------------------------------------
.text$mn:0000CCE9
.text$mn:0000CCE9 loc_CCE9:                               ; CODE XREF: std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>>::replace(uint,uint,std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>> const &,uint,uint)+BAj
.text$mn:0000CCE9                 mov     eax, [ebp+arg_10]
.text$mn:0000CCEC                 cmp     eax, [ebp+arg_4]
.text$mn:0000CCEF                 ja      short loc_CD56
.text$mn:0000CCF1                 mov     ecx, [ebp+arg_10]
.text$mn:0000CCF4                 push    ecx             ; int
.text$mn:0000CCF5                 mov     ecx, [ebp+var_4]
.text$mn:0000CCF8                 call    ?_Myptr@?$_String_val@U?$_Simple_types@_W@std@@@std@@QAEPA_WXZ ; std::_String_val<std::_Simple_types<wchar_t>>::_Myptr(void)
.text$mn:0000CCFD                 mov     edx, [ebp+arg_C]
.text$mn:0000CD00                 lea     eax, [eax+edx*2]
.text$mn:0000CD03                 push    eax             ; Src
.text$mn:0000CD04                 mov     ecx, [ebp+var_4]
.text$mn:0000CD07                 call    ?_Myptr@?$_String_val@U?$_Simple_types@_W@std@@@std@@QAEPA_WXZ ; std::_String_val<std::_Simple_types<wchar_t>>::_Myptr(void)
.text$mn:0000CD0C                 mov     ecx, [ebp+arg_0]
.text$mn:0000CD0F                 lea     edx, [eax+ecx*2]
.text$mn:0000CD12                 push    edx             ; Dst
.text$mn:0000CD13                 call    ?move@?$char_traits@_W@std@@SAPA_WPA_WPB_WI@Z ; std::char_traits<wchar_t>::move(wchar_t *,wchar_t const *,uint)
.text$mn:0000CD18                 add     esp, 0Ch
.text$mn:0000CD1B                 mov     eax, [ebp+var_8]
.text$mn:0000CD1E                 push    eax             ; int
.text$mn:0000CD1F                 mov     ecx, [ebp+var_4]
.text$mn:0000CD22                 call    ?_Myptr@?$_String_val@U?$_Simple_types@_W@std@@@std@@QAEPA_WXZ ; std::_String_val<std::_Simple_types<wchar_t>>::_Myptr(void)
.text$mn:0000CD27                 mov     ecx, [ebp+arg_0]
.text$mn:0000CD2A                 lea     edx, [eax+ecx*2]
.text$mn:0000CD2D                 mov     eax, [ebp+arg_4]
.text$mn:0000CD30                 lea     ecx, [edx+eax*2]
.text$mn:0000CD33                 push    ecx             ; Src
.text$mn:0000CD34                 mov     ecx, [ebp+var_4]
.text$mn:0000CD37                 call    ?_Myptr@?$_String_val@U?$_Simple_types@_W@std@@@std@@QAEPA_WXZ ; std::_String_val<std::_Simple_types<wchar_t>>::_Myptr(void)
.text$mn:0000CD3C                 mov     edx, [ebp+arg_0]
.text$mn:0000CD3F                 lea     eax, [eax+edx*2]
.text$mn:0000CD42                 mov     ecx, [ebp+arg_10]
.text$mn:0000CD45                 lea     edx, [eax+ecx*2]
.text$mn:0000CD48                 push    edx             ; Dst
.text$mn:0000CD49                 call    ?move@?$char_traits@_W@std@@SAPA_WPA_WPB_WI@Z ; std::char_traits<wchar_t>::move(wchar_t *,wchar_t const *,uint)
.text$mn:0000CD4E                 add     esp, 0Ch
.text$mn:0000CD51                 jmp     loc_CED2
.text$mn:0000CD56 ; ---------------------------------------------------------------------------
.text$mn:0000CD56
.text$mn:0000CD56 loc_CD56:                               ; CODE XREF: std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>>::replace(uint,uint,std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>> const &,uint,uint)+127j
.text$mn:0000CD56                 mov     eax, [ebp+arg_C]
.text$mn:0000CD59                 cmp     eax, [ebp+arg_0]
.text$mn:0000CD5C                 ja      short loc_CDC3
.text$mn:0000CD5E                 mov     ecx, [ebp+var_8]
.text$mn:0000CD61                 push    ecx             ; int
.text$mn:0000CD62                 mov     ecx, [ebp+var_4]
.text$mn:0000CD65                 call    ?_Myptr@?$_String_val@U?$_Simple_types@_W@std@@@std@@QAEPA_WXZ ; std::_String_val<std::_Simple_types<wchar_t>>::_Myptr(void)
.text$mn:0000CD6A                 mov     edx, [ebp+arg_0]
.text$mn:0000CD6D                 lea     eax, [eax+edx*2]
.text$mn:0000CD70                 mov     ecx, [ebp+arg_4]
.text$mn:0000CD73                 lea     edx, [eax+ecx*2]
.text$mn:0000CD76                 push    edx             ; Src
.text$mn:0000CD77                 mov     ecx, [ebp+var_4]
.text$mn:0000CD7A                 call    ?_Myptr@?$_String_val@U?$_Simple_types@_W@std@@@std@@QAEPA_WXZ ; std::_String_val<std::_Simple_types<wchar_t>>::_Myptr(void)
.text$mn:0000CD7F                 mov     ecx, [ebp+arg_0]
.text$mn:0000CD82                 lea     edx, [eax+ecx*2]
.text$mn:0000CD85                 mov     eax, [ebp+arg_10]
.text$mn:0000CD88                 lea     ecx, [edx+eax*2]
.text$mn:0000CD8B                 push    ecx             ; Dst
.text$mn:0000CD8C                 call    ?move@?$char_traits@_W@std@@SAPA_WPA_WPB_WI@Z ; std::char_traits<wchar_t>::move(wchar_t *,wchar_t const *,uint)
.text$mn:0000CD91                 add     esp, 0Ch
.text$mn:0000CD94                 mov     edx, [ebp+arg_10]
.text$mn:0000CD97                 push    edx             ; int
.text$mn:0000CD98                 mov     ecx, [ebp+var_4]
.text$mn:0000CD9B                 call    ?_Myptr@?$_String_val@U?$_Simple_types@_W@std@@@std@@QAEPA_WXZ ; std::_String_val<std::_Simple_types<wchar_t>>::_Myptr(void)
.text$mn:0000CDA0                 mov     ecx, [ebp+arg_C]
.text$mn:0000CDA3                 lea     edx, [eax+ecx*2]
.text$mn:0000CDA6                 push    edx             ; Src
.text$mn:0000CDA7                 mov     ecx, [ebp+var_4]
.text$mn:0000CDAA                 call    ?_Myptr@?$_String_val@U?$_Simple_types@_W@std@@@std@@QAEPA_WXZ ; std::_String_val<std::_Simple_types<wchar_t>>::_Myptr(void)
.text$mn:0000CDAF                 mov     ecx, [ebp+arg_0]
.text$mn:0000CDB2                 lea     edx, [eax+ecx*2]
.text$mn:0000CDB5                 push    edx             ; Dst
.text$mn:0000CDB6                 call    ?move@?$char_traits@_W@std@@SAPA_WPA_WPB_WI@Z ; std::char_traits<wchar_t>::move(wchar_t *,wchar_t const *,uint)
.text$mn:0000CDBB                 add     esp, 0Ch
.text$mn:0000CDBE                 jmp     loc_CED2
.text$mn:0000CDC3 ; ---------------------------------------------------------------------------
.text$mn:0000CDC3
.text$mn:0000CDC3 loc_CDC3:                               ; CODE XREF: std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>>::replace(uint,uint,std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>> const &,uint,uint)+194j
.text$mn:0000CDC3                 mov     eax, [ebp+arg_0]
.text$mn:0000CDC6                 add     eax, [ebp+arg_4]
.text$mn:0000CDC9                 cmp     eax, [ebp+arg_C]
.text$mn:0000CDCC                 ja      short loc_CE39
.text$mn:0000CDCE                 mov     ecx, [ebp+var_8]
.text$mn:0000CDD1                 push    ecx             ; int
.text$mn:0000CDD2                 mov     ecx, [ebp+var_4]
.text$mn:0000CDD5                 call    ?_Myptr@?$_String_val@U?$_Simple_types@_W@std@@@std@@QAEPA_WXZ ; std::_String_val<std::_Simple_types<wchar_t>>::_Myptr(void)
.text$mn:0000CDDA                 mov     edx, [ebp+arg_0]
.text$mn:0000CDDD                 lea     eax, [eax+edx*2]
.text$mn:0000CDE0                 mov     ecx, [ebp+arg_4]
.text$mn:0000CDE3                 lea     edx, [eax+ecx*2]
.text$mn:0000CDE6                 push    edx             ; Src
.text$mn:0000CDE7                 mov     ecx, [ebp+var_4]
.text$mn:0000CDEA                 call    ?_Myptr@?$_String_val@U?$_Simple_types@_W@std@@@std@@QAEPA_WXZ ; std::_String_val<std::_Simple_types<wchar_t>>::_Myptr(void)
.text$mn:0000CDEF                 mov     ecx, [ebp+arg_0]
.text$mn:0000CDF2                 lea     edx, [eax+ecx*2]
.text$mn:0000CDF5                 mov     eax, [ebp+arg_10]
.text$mn:0000CDF8                 lea     ecx, [edx+eax*2]
.text$mn:0000CDFB                 push    ecx             ; Dst
.text$mn:0000CDFC                 call    ?move@?$char_traits@_W@std@@SAPA_WPA_WPB_WI@Z ; std::char_traits<wchar_t>::move(wchar_t *,wchar_t const *,uint)
.text$mn:0000CE01                 add     esp, 0Ch
.text$mn:0000CE04                 mov     edx, [ebp+arg_10]
.text$mn:0000CE07                 push    edx             ; int
.text$mn:0000CE08                 mov     ecx, [ebp+var_4]
.text$mn:0000CE0B                 call    ?_Myptr@?$_String_val@U?$_Simple_types@_W@std@@@std@@QAEPA_WXZ ; std::_String_val<std::_Simple_types<wchar_t>>::_Myptr(void)
.text$mn:0000CE10                 mov     ecx, [ebp+arg_C]
.text$mn:0000CE13                 add     ecx, [ebp+arg_10]
.text$mn:0000CE16                 sub     ecx, [ebp+arg_4]
.text$mn:0000CE19                 lea     edx, [eax+ecx*2]
.text$mn:0000CE1C                 push    edx             ; Src
.text$mn:0000CE1D                 mov     ecx, [ebp+var_4]
.text$mn:0000CE20                 call    ?_Myptr@?$_String_val@U?$_Simple_types@_W@std@@@std@@QAEPA_WXZ ; std::_String_val<std::_Simple_types<wchar_t>>::_Myptr(void)
.text$mn:0000CE25                 mov     ecx, [ebp+arg_0]
.text$mn:0000CE28                 lea     edx, [eax+ecx*2]
.text$mn:0000CE2B                 push    edx             ; Dst
.text$mn:0000CE2C                 call    ?move@?$char_traits@_W@std@@SAPA_WPA_WPB_WI@Z ; std::char_traits<wchar_t>::move(wchar_t *,wchar_t const *,uint)
.text$mn:0000CE31                 add     esp, 0Ch
.text$mn:0000CE34                 jmp     loc_CED2
.text$mn:0000CE39 ; ---------------------------------------------------------------------------
.text$mn:0000CE39
.text$mn:0000CE39 loc_CE39:                               ; CODE XREF: std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>>::replace(uint,uint,std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>> const &,uint,uint)+204j
.text$mn:0000CE39                 mov     eax, [ebp+arg_4]
.text$mn:0000CE3C                 push    eax             ; int
.text$mn:0000CE3D                 mov     ecx, [ebp+var_4]
.text$mn:0000CE40                 call    ?_Myptr@?$_String_val@U?$_Simple_types@_W@std@@@std@@QAEPA_WXZ ; std::_String_val<std::_Simple_types<wchar_t>>::_Myptr(void)
.text$mn:0000CE45                 mov     ecx, [ebp+arg_C]
.text$mn:0000CE48                 lea     edx, [eax+ecx*2]
.text$mn:0000CE4B                 push    edx             ; Src
.text$mn:0000CE4C                 mov     ecx, [ebp+var_4]
.text$mn:0000CE4F                 call    ?_Myptr@?$_String_val@U?$_Simple_types@_W@std@@@std@@QAEPA_WXZ ; std::_String_val<std::_Simple_types<wchar_t>>::_Myptr(void)
.text$mn:0000CE54                 mov     ecx, [ebp+arg_0]
.text$mn:0000CE57                 lea     edx, [eax+ecx*2]
.text$mn:0000CE5A                 push    edx             ; Dst
.text$mn:0000CE5B                 call    ?move@?$char_traits@_W@std@@SAPA_WPA_WPB_WI@Z ; std::char_traits<wchar_t>::move(wchar_t *,wchar_t const *,uint)
.text$mn:0000CE60                 add     esp, 0Ch
.text$mn:0000CE63                 mov     eax, [ebp+var_8]
.text$mn:0000CE66                 push    eax             ; int
.text$mn:0000CE67                 mov     ecx, [ebp+var_4]
.text$mn:0000CE6A                 call    ?_Myptr@?$_String_val@U?$_Simple_types@_W@std@@@std@@QAEPA_WXZ ; std::_String_val<std::_Simple_types<wchar_t>>::_Myptr(void)
.text$mn:0000CE6F                 mov     ecx, [ebp+arg_0]
.text$mn:0000CE72                 lea     edx, [eax+ecx*2]
.text$mn:0000CE75                 mov     eax, [ebp+arg_4]
.text$mn:0000CE78                 lea     ecx, [edx+eax*2]
.text$mn:0000CE7B                 push    ecx             ; Src
.text$mn:0000CE7C                 mov     ecx, [ebp+var_4]
.text$mn:0000CE7F                 call    ?_Myptr@?$_String_val@U?$_Simple_types@_W@std@@@std@@QAEPA_WXZ ; std::_String_val<std::_Simple_types<wchar_t>>::_Myptr(void)
.text$mn:0000CE84                 mov     edx, [ebp+arg_0]
.text$mn:0000CE87                 lea     eax, [eax+edx*2]
.text$mn:0000CE8A                 mov     ecx, [ebp+arg_10]
.text$mn:0000CE8D                 lea     edx, [eax+ecx*2]
.text$mn:0000CE90                 push    edx             ; Dst
.text$mn:0000CE91                 call    ?move@?$char_traits@_W@std@@SAPA_WPA_WPB_WI@Z ; std::char_traits<wchar_t>::move(wchar_t *,wchar_t const *,uint)
.text$mn:0000CE96                 add     esp, 0Ch
.text$mn:0000CE99                 mov     eax, [ebp+arg_10]
.text$mn:0000CE9C                 sub     eax, [ebp+arg_4]
.text$mn:0000CE9F                 push    eax             ; int
.text$mn:0000CEA0                 mov     ecx, [ebp+var_4]
.text$mn:0000CEA3                 call    ?_Myptr@?$_String_val@U?$_Simple_types@_W@std@@@std@@QAEPA_WXZ ; std::_String_val<std::_Simple_types<wchar_t>>::_Myptr(void)
.text$mn:0000CEA8                 mov     ecx, [ebp+arg_C]
.text$mn:0000CEAB                 lea     edx, [eax+ecx*2]
.text$mn:0000CEAE                 mov     eax, [ebp+arg_10]
.text$mn:0000CEB1                 lea     ecx, [edx+eax*2]
.text$mn:0000CEB4                 push    ecx             ; Src
.text$mn:0000CEB5                 mov     ecx, [ebp+var_4]
.text$mn:0000CEB8                 call    ?_Myptr@?$_String_val@U?$_Simple_types@_W@std@@@std@@QAEPA_WXZ ; std::_String_val<std::_Simple_types<wchar_t>>::_Myptr(void)
.text$mn:0000CEBD                 mov     edx, [ebp+arg_0]
.text$mn:0000CEC0                 lea     eax, [eax+edx*2]
.text$mn:0000CEC3                 mov     ecx, [ebp+arg_4]
.text$mn:0000CEC6                 lea     edx, [eax+ecx*2]
.text$mn:0000CEC9                 push    edx             ; Dst
.text$mn:0000CECA                 call    ?move@?$char_traits@_W@std@@SAPA_WPA_WPB_WI@Z ; std::char_traits<wchar_t>::move(wchar_t *,wchar_t const *,uint)
.text$mn:0000CECF                 add     esp, 0Ch
.text$mn:0000CED2
.text$mn:0000CED2 loc_CED2:                               ; CODE XREF: std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>>::replace(uint,uint,std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>> const &,uint,uint)+11Cj
.text$mn:0000CED2                                         ; std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>>::replace(uint,uint,std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>> const &,uint,uint)+189j ...
.text$mn:0000CED2                 mov     eax, [ebp+var_C]
.text$mn:0000CED5                 push    eax
.text$mn:0000CED6                 mov     ecx, [ebp+var_4]
.text$mn:0000CED9                 call    ?_Eos@?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QAEXI@Z ; std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>>::_Eos(uint)
.text$mn:0000CEDE                 mov     eax, [ebp+var_4]
.text$mn:0000CEE1                 mov     esp, ebp
.text$mn:0000CEE3                 pop     ebp
.text$mn:0000CEE4                 retn    14h
.text$mn:0000CEE4 ?replace@?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QAEAAV12@IIABV12@II@Z endp
.text$mn:0000CEE4
.text$mn:0000CEE4 ; ---------------------------------------------------------------------------
.text$mn:0000CEE7                 align 4
.text$mn:0000CEE7 _text$mn        ends
.text$mn:0000CEE7
.text$mn:0000CEE8 ; ===========================================================================
.text$mn:0000CEE8
.text$mn:0000CEE8 ; Segment type: Pure code
.text$mn:0000CEE8 ; Segment permissions: Read/Execute
.text$mn:0000CEE8 _text$mn        segment para public 'CODE' use32
.text$mn:0000CEE8                 assume cs:_text$mn
.text$mn:0000CEE8                 ;org 0CEE8h
.text$mn:0000CEE8 ; COMDAT (pick any)
.text$mn:0000CEE8                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text$mn:0000CEE8
.text$mn:0000CEE8 ; =============== S U B R O U T I N E =======================================
.text$mn:0000CEE8
.text$mn:0000CEE8 ; Attributes: bp-based frame
.text$mn:0000CEE8
.text$mn:0000CEE8 ; public: void __thiscall std::basic_string<wchar_t, struct std::char_traits<wchar_t>, class std::allocator<wchar_t>>::reserve(unsigned int)
.text$mn:0000CEE8                 public ?reserve@?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QAEXI@Z
.text$mn:0000CEE8 ?reserve@?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QAEXI@Z proc near
.text$mn:0000CEE8                                         ; CODE XREF: std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>>::_Construct<std::reverse_iterator<std::_Vector_iterator<std::_Vector_val<std::_Simple_types<wchar_t>>>>>(std::reverse_iterator<std::_Vector_iterator<std::_Vector_val<std::_Simple_types<wchar_t>>>>,std::reverse_iterator<std::_Vector_iterator<std::_Vector_val<std::_Simple_types<wchar_t>>>>,std::forward_iterator_tag)+E2p
.text$mn:0000CEE8
.text$mn:0000CEE8 var_8           = dword ptr -8
.text$mn:0000CEE8 var_4           = dword ptr -4
.text$mn:0000CEE8 arg_0           = dword ptr  8
.text$mn:0000CEE8
.text$mn:0000CEE8                 push    ebp
.text$mn:0000CEE9                 mov     ebp, esp
.text$mn:0000CEEB                 sub     esp, 8
.text$mn:0000CEEE                 mov     [ebp+var_4], ecx
.text$mn:0000CEF1                 mov     eax, [ebp+var_4]
.text$mn:0000CEF4                 mov     ecx, [eax+14h]
.text$mn:0000CEF7                 cmp     ecx, [ebp+arg_0]
.text$mn:0000CEFA                 ja      short loc_CF31
.text$mn:0000CEFC                 mov     edx, [ebp+var_4]
.text$mn:0000CEFF                 mov     eax, [edx+18h]
.text$mn:0000CF02                 cmp     eax, [ebp+arg_0]
.text$mn:0000CF05                 jz      short loc_CF31
.text$mn:0000CF07                 mov     ecx, [ebp+var_4]
.text$mn:0000CF0A                 mov     edx, [ecx+14h]
.text$mn:0000CF0D                 mov     [ebp+var_8], edx
.text$mn:0000CF10                 push    1
.text$mn:0000CF12                 mov     eax, [ebp+arg_0]
.text$mn:0000CF15                 push    eax
.text$mn:0000CF16                 mov     ecx, [ebp+var_4]
.text$mn:0000CF19                 call    ?_Grow@?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QAE_NI_N@Z ; std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>>::_Grow(uint,bool)
.text$mn:0000CF1E                 movzx   ecx, al
.text$mn:0000CF21                 test    ecx, ecx
.text$mn:0000CF23                 jz      short loc_CF31
.text$mn:0000CF25                 mov     edx, [ebp+var_8]
.text$mn:0000CF28                 push    edx
.text$mn:0000CF29                 mov     ecx, [ebp+var_4]
.text$mn:0000CF2C                 call    ?_Eos@?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QAEXI@Z ; std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>>::_Eos(uint)
.text$mn:0000CF31
.text$mn:0000CF31 loc_CF31:                               ; CODE XREF: std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>>::reserve(uint)+12j
.text$mn:0000CF31                                         ; std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>>::reserve(uint)+1Dj ...
.text$mn:0000CF31                 mov     esp, ebp
.text$mn:0000CF33                 pop     ebp
.text$mn:0000CF34                 retn    4
.text$mn:0000CF34 ?reserve@?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QAEXI@Z endp
.text$mn:0000CF34
.text$mn:0000CF34 ; ---------------------------------------------------------------------------
.text$mn:0000CF37                 align 4
.text$mn:0000CF37 _text$mn        ends
.text$mn:0000CF37
.text$mn:0000CF38 ; ===========================================================================
.text$mn:0000CF38
.text$mn:0000CF38 ; Segment type: Pure code
.text$mn:0000CF38 ; Segment permissions: Read/Execute
.text$mn:0000CF38 _text$mn        segment para public 'CODE' use32
.text$mn:0000CF38                 assume cs:_text$mn
.text$mn:0000CF38                 ;org 0CF38h
.text$mn:0000CF38 ; COMDAT (pick any)
.text$mn:0000CF38                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text$mn:0000CF38
.text$mn:0000CF38 ; =============== S U B R O U T I N E =======================================
.text$mn:0000CF38
.text$mn:0000CF38 ; Attributes: bp-based frame
.text$mn:0000CF38
.text$mn:0000CF38 ; public: unsigned int __thiscall std::basic_string<wchar_t, struct std::char_traits<wchar_t>, class std::allocator<wchar_t>>::rfind(wchar_t const *, unsigned int, unsigned int)const
.text$mn:0000CF38                 public ?rfind@?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QBEIPB_WII@Z
.text$mn:0000CF38 ?rfind@?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QBEIPB_WII@Z proc near
.text$mn:0000CF38                                         ; CODE XREF: std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>>::find_last_of(wchar_t,uint)+14p
.text$mn:0000CF38
.text$mn:0000CF38 var_10          = dword ptr -10h
.text$mn:0000CF38 var_C           = dword ptr -0Ch
.text$mn:0000CF38 var_8           = dword ptr -8
.text$mn:0000CF38 var_4           = dword ptr -4
.text$mn:0000CF38 arg_0           = dword ptr  8
.text$mn:0000CF38 arg_4           = dword ptr  0Ch
.text$mn:0000CF38 arg_8           = dword ptr  10h
.text$mn:0000CF38
.text$mn:0000CF38                 push    ebp
.text$mn:0000CF39                 mov     ebp, esp
.text$mn:0000CF3B                 sub     esp, 10h
.text$mn:0000CF3E                 mov     [ebp+var_4], ecx
.text$mn:0000CF41                 cmp     [ebp+arg_8], 0
.text$mn:0000CF45                 jz      short loc_CF5D
.text$mn:0000CF47                 push    791h            ; unsigned int
.text$mn:0000CF4C                 push    offset ??_C@_1IO@FEAPGJBD@?$AAC?$AA?3?$AA?2?$AAP?$AAr?$AAo?$AAg?$AAr?$AAa?$AAm?$AA?5?$AAF?$AAi?$AAl?$AAe?$AAs?$AA?5?$AA?$CI?$AAx?$AA8?$AA6?$AA?$CJ?$AA?2?$AAM?$AAi?$AAc?$AAr?$AAo?$AAs?$AAo?$AAf?$AAt@ ; "C:\\Program Files (x86)\\Microsoft Visu"...
.text$mn:0000CF51                 mov     eax, [ebp+arg_0]
.text$mn:0000CF54                 push    eax             ; int
.text$mn:0000CF55                 call    ??$_Debug_pointer@_W@std@@YAXPB_W0I@Z ; std::_Debug_pointer<wchar_t>(wchar_t const *,wchar_t const *,uint)
.text$mn:0000CF5A                 add     esp, 0Ch
.text$mn:0000CF5D
.text$mn:0000CF5D loc_CF5D:                               ; CODE XREF: std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>>::rfind(wchar_t const *,uint,uint)+Dj
.text$mn:0000CF5D                 cmp     [ebp+arg_8], 0
.text$mn:0000CF61                 jnz     short loc_CF87
.text$mn:0000CF63                 mov     ecx, [ebp+var_4]
.text$mn:0000CF66                 mov     edx, [ebp+arg_4]
.text$mn:0000CF69                 cmp     edx, [ecx+14h]
.text$mn:0000CF6C                 jnb     short loc_CF76
.text$mn:0000CF6E                 mov     eax, [ebp+arg_4]
.text$mn:0000CF71                 mov     [ebp+var_C], eax
.text$mn:0000CF74                 jmp     short loc_CF7F
.text$mn:0000CF76 ; ---------------------------------------------------------------------------
.text$mn:0000CF76
.text$mn:0000CF76 loc_CF76:                               ; CODE XREF: std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>>::rfind(wchar_t const *,uint,uint)+34j
.text$mn:0000CF76                 mov     ecx, [ebp+var_4]
.text$mn:0000CF79                 mov     edx, [ecx+14h]
.text$mn:0000CF7C                 mov     [ebp+var_C], edx
.text$mn:0000CF7F
.text$mn:0000CF7F loc_CF7F:                               ; CODE XREF: std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>>::rfind(wchar_t const *,uint,uint)+3Cj
.text$mn:0000CF7F                 mov     eax, [ebp+var_C]
.text$mn:0000CF82                 jmp     loc_D02E
.text$mn:0000CF87 ; ---------------------------------------------------------------------------
.text$mn:0000CF87
.text$mn:0000CF87 loc_CF87:                               ; CODE XREF: std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>>::rfind(wchar_t const *,uint,uint)+29j
.text$mn:0000CF87                 mov     eax, [ebp+var_4]
.text$mn:0000CF8A                 mov     ecx, [ebp+arg_8]
.text$mn:0000CF8D                 cmp     ecx, [eax+14h]
.text$mn:0000CF90                 ja      loc_D029
.text$mn:0000CF96                 mov     edx, [ebp+var_4]
.text$mn:0000CF99                 mov     eax, [edx+14h]
.text$mn:0000CF9C                 sub     eax, [ebp+arg_8]
.text$mn:0000CF9F                 cmp     [ebp+arg_4], eax
.text$mn:0000CFA2                 jnb     short loc_CFAC
.text$mn:0000CFA4                 mov     ecx, [ebp+arg_4]
.text$mn:0000CFA7                 mov     [ebp+var_10], ecx
.text$mn:0000CFAA                 jmp     short loc_CFB8
.text$mn:0000CFAC ; ---------------------------------------------------------------------------
.text$mn:0000CFAC
.text$mn:0000CFAC loc_CFAC:                               ; CODE XREF: std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>>::rfind(wchar_t const *,uint,uint)+6Aj
.text$mn:0000CFAC                 mov     edx, [ebp+var_4]
.text$mn:0000CFAF                 mov     eax, [edx+14h]
.text$mn:0000CFB2                 sub     eax, [ebp+arg_8]
.text$mn:0000CFB5                 mov     [ebp+var_10], eax
.text$mn:0000CFB8
.text$mn:0000CFB8 loc_CFB8:                               ; CODE XREF: std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>>::rfind(wchar_t const *,uint,uint)+72j
.text$mn:0000CFB8                 mov     ecx, [ebp+var_4]
.text$mn:0000CFBB                 call    ?_Myptr@?$_String_val@U?$_Simple_types@_W@std@@@std@@QBEPB_WXZ ; std::_String_val<std::_Simple_types<wchar_t>>::_Myptr(void)
.text$mn:0000CFC0                 mov     ecx, [ebp+var_10]
.text$mn:0000CFC3                 lea     edx, [eax+ecx*2]
.text$mn:0000CFC6                 mov     [ebp+var_8], edx
.text$mn:0000CFC9                 jmp     short loc_CFD4
.text$mn:0000CFCB ; ---------------------------------------------------------------------------
.text$mn:0000CFCB
.text$mn:0000CFCB loc_CFCB:                               ; CODE XREF: std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>>::rfind(wchar_t const *,uint,uint):loc_D027j
.text$mn:0000CFCB                 mov     eax, [ebp+var_8]
.text$mn:0000CFCE                 sub     eax, 2
.text$mn:0000CFD1                 mov     [ebp+var_8], eax
.text$mn:0000CFD4
.text$mn:0000CFD4 loc_CFD4:                               ; CODE XREF: std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>>::rfind(wchar_t const *,uint,uint)+91j
.text$mn:0000CFD4                 mov     ecx, [ebp+arg_0]
.text$mn:0000CFD7                 push    ecx
.text$mn:0000CFD8                 mov     edx, [ebp+var_8]
.text$mn:0000CFDB                 push    edx
.text$mn:0000CFDC                 call    ?eq@?$char_traits@_W@std@@SA_NAB_W0@Z ; std::char_traits<wchar_t>::eq(wchar_t const &,wchar_t const &)
.text$mn:0000CFE1                 add     esp, 8
.text$mn:0000CFE4                 movzx   eax, al
.text$mn:0000CFE7                 test    eax, eax
.text$mn:0000CFE9                 jz      short loc_D018
.text$mn:0000CFEB                 mov     ecx, [ebp+arg_8]
.text$mn:0000CFEE                 push    ecx
.text$mn:0000CFEF                 mov     edx, [ebp+arg_0]
.text$mn:0000CFF2                 push    edx
.text$mn:0000CFF3                 mov     eax, [ebp+var_8]
.text$mn:0000CFF6                 push    eax
.text$mn:0000CFF7                 call    ?compare@?$char_traits@_W@std@@SAHPB_W0I@Z ; std::char_traits<wchar_t>::compare(wchar_t const *,wchar_t const *,uint)
.text$mn:0000CFFC                 add     esp, 0Ch
.text$mn:0000CFFF                 test    eax, eax
.text$mn:0000D001                 jnz     short loc_D018
.text$mn:0000D003                 mov     ecx, [ebp+var_4]
.text$mn:0000D006                 call    ?_Myptr@?$_String_val@U?$_Simple_types@_W@std@@@std@@QBEPB_WXZ ; std::_String_val<std::_Simple_types<wchar_t>>::_Myptr(void)
.text$mn:0000D00B                 mov     ecx, [ebp+var_8]
.text$mn:0000D00E                 sub     ecx, eax
.text$mn:0000D010                 sar     ecx, 1
.text$mn:0000D012                 mov     eax, ecx
.text$mn:0000D014                 jmp     short loc_D02E
.text$mn:0000D016 ; ---------------------------------------------------------------------------
.text$mn:0000D016                 jmp     short loc_D027
.text$mn:0000D018 ; ---------------------------------------------------------------------------
.text$mn:0000D018
.text$mn:0000D018 loc_D018:                               ; CODE XREF: std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>>::rfind(wchar_t const *,uint,uint)+B1j
.text$mn:0000D018                                         ; std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>>::rfind(wchar_t const *,uint,uint)+C9j
.text$mn:0000D018                 mov     ecx, [ebp+var_4]
.text$mn:0000D01B                 call    ?_Myptr@?$_String_val@U?$_Simple_types@_W@std@@@std@@QBEPB_WXZ ; std::_String_val<std::_Simple_types<wchar_t>>::_Myptr(void)
.text$mn:0000D020                 cmp     [ebp+var_8], eax
.text$mn:0000D023                 jnz     short loc_D027
.text$mn:0000D025                 jmp     short loc_D029
.text$mn:0000D027 ; ---------------------------------------------------------------------------
.text$mn:0000D027
.text$mn:0000D027 loc_D027:                               ; CODE XREF: std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>>::rfind(wchar_t const *,uint,uint)+DEj
.text$mn:0000D027                                         ; std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>>::rfind(wchar_t const *,uint,uint)+EBj
.text$mn:0000D027                 jmp     short loc_CFCB
.text$mn:0000D029 ; ---------------------------------------------------------------------------
.text$mn:0000D029
.text$mn:0000D029 loc_D029:                               ; CODE XREF: std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>>::rfind(wchar_t const *,uint,uint)+58j
.text$mn:0000D029                                         ; std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>>::rfind(wchar_t const *,uint,uint)+EDj
.text$mn:0000D029                 mov     eax, ds:?npos@?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@2IB ; uint const std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>>::npos
.text$mn:0000D02E
.text$mn:0000D02E loc_D02E:                               ; CODE XREF: std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>>::rfind(wchar_t const *,uint,uint)+4Aj
.text$mn:0000D02E                                         ; std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>>::rfind(wchar_t const *,uint,uint)+DCj
.text$mn:0000D02E                 mov     esp, ebp
.text$mn:0000D030                 pop     ebp
.text$mn:0000D031                 retn    0Ch
.text$mn:0000D031 ?rfind@?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QBEIPB_WII@Z endp
.text$mn:0000D031
.text$mn:0000D031 _text$mn        ends
.text$mn:0000D031
.text$mn:0000D034 ; ===========================================================================
.text$mn:0000D034
.text$mn:0000D034 ; Segment type: Pure code
.text$mn:0000D034 ; Segment permissions: Read/Execute
.text$mn:0000D034 _text$mn        segment para public 'CODE' use32
.text$mn:0000D034                 assume cs:_text$mn
.text$mn:0000D034                 ;org 0D034h
.text$mn:0000D034 ; COMDAT (pick any)
.text$mn:0000D034                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text$mn:0000D034
.text$mn:0000D034 ; =============== S U B R O U T I N E =======================================
.text$mn:0000D034
.text$mn:0000D034 ; Attributes: bp-based frame
.text$mn:0000D034
.text$mn:0000D034 ; public: struct std::_Wrap_alloc<class std::allocator<wchar_t>> __thiscall std::_Wrap_alloc<class std::allocator<wchar_t>>::select_on_container_copy_construction(void)const
.text$mn:0000D034                 public ?select_on_container_copy_construction@?$_Wrap_alloc@V?$allocator@_W@std@@@std@@QBE?AU12@XZ
.text$mn:0000D034 ?select_on_container_copy_construction@?$_Wrap_alloc@V?$allocator@_W@std@@@std@@QBE?AU12@XZ proc near
.text$mn:0000D034                                         ; CODE XREF: std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>>::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>>(std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>> const &)+3Ap
.text$mn:0000D034
.text$mn:0000D034 var_8           = dword ptr -8
.text$mn:0000D034 var_1           = byte ptr -1
.text$mn:0000D034 arg_0           = dword ptr  8
.text$mn:0000D034
.text$mn:0000D034                 push    ebp
.text$mn:0000D035                 mov     ebp, esp
.text$mn:0000D037                 sub     esp, 8
.text$mn:0000D03A                 mov     [ebp+var_8], ecx
.text$mn:0000D03D                 mov     eax, [ebp+var_8]
.text$mn:0000D040                 push    eax
.text$mn:0000D041                 lea     ecx, [ebp+var_1]
.text$mn:0000D044                 push    ecx
.text$mn:0000D045                 call    ?select_on_container_copy_construction@?$allocator_traits@V?$allocator@_W@std@@@std@@SA?AV?$allocator@_W@2@ABV32@@Z ; std::allocator_traits<std::allocator<wchar_t>>::select_on_container_copy_construction(std::allocator<wchar_t> const &)
.text$mn:0000D04A                 add     esp, 8
.text$mn:0000D04D                 push    eax
.text$mn:0000D04E                 mov     ecx, [ebp+arg_0]
.text$mn:0000D051                 call    ??0?$_Wrap_alloc@V?$allocator@_W@std@@@std@@QAE@ABV?$allocator@_W@1@@Z ; std::_Wrap_alloc<std::allocator<wchar_t>>::_Wrap_alloc<std::allocator<wchar_t>>(std::allocator<wchar_t> const &)
.text$mn:0000D056                 mov     eax, [ebp+arg_0]
.text$mn:0000D059                 mov     esp, ebp
.text$mn:0000D05B                 pop     ebp
.text$mn:0000D05C                 retn    4
.text$mn:0000D05C ?select_on_container_copy_construction@?$_Wrap_alloc@V?$allocator@_W@std@@@std@@QBE?AU12@XZ endp
.text$mn:0000D05C
.text$mn:0000D05C ; ---------------------------------------------------------------------------
.text$mn:0000D05F                 align 10h
.text$mn:0000D05F _text$mn        ends
.text$mn:0000D05F
.text$mn:0000D060 ; ===========================================================================
.text$mn:0000D060
.text$mn:0000D060 ; Segment type: Pure code
.text$mn:0000D060 ; Segment permissions: Read/Execute
.text$mn:0000D060 _text$mn        segment para public 'CODE' use32
.text$mn:0000D060                 assume cs:_text$mn
.text$mn:0000D060                 ;org 0D060h
.text$mn:0000D060 ; COMDAT (pick any)
.text$mn:0000D060                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text$mn:0000D060
.text$mn:0000D060 ; =============== S U B R O U T I N E =======================================
.text$mn:0000D060
.text$mn:0000D060 ; Attributes: bp-based frame
.text$mn:0000D060
.text$mn:0000D060 ; public: class std::allocator<wchar_t> __thiscall std::allocator<wchar_t>::select_on_container_copy_construction(void)const
.text$mn:0000D060                 public ?select_on_container_copy_construction@?$allocator@_W@std@@QBE?AV12@XZ
.text$mn:0000D060 ?select_on_container_copy_construction@?$allocator@_W@std@@QBE?AV12@XZ proc near
.text$mn:0000D060                                         ; CODE XREF: std::allocator_traits<std::allocator<wchar_t>>::select_on_container_copy_construction(std::allocator<wchar_t> const &)+Ap
.text$mn:0000D060
.text$mn:0000D060 var_4           = dword ptr -4
.text$mn:0000D060 arg_0           = dword ptr  8
.text$mn:0000D060
.text$mn:0000D060                 push    ebp
.text$mn:0000D061                 mov     ebp, esp
.text$mn:0000D063                 push    ecx
.text$mn:0000D064                 mov     [ebp+var_4], ecx
.text$mn:0000D067                 mov     eax, [ebp+var_4]
.text$mn:0000D06A                 push    eax
.text$mn:0000D06B                 mov     ecx, [ebp+arg_0]
.text$mn:0000D06E                 call    ??0?$allocator@_W@std@@QAE@ABV01@@Z ; std::allocator<wchar_t>::allocator<wchar_t>(std::allocator<wchar_t> const &)
.text$mn:0000D073                 mov     eax, [ebp+arg_0]
.text$mn:0000D076                 mov     esp, ebp
.text$mn:0000D078                 pop     ebp
.text$mn:0000D079                 retn    4
.text$mn:0000D079 ?select_on_container_copy_construction@?$allocator@_W@std@@QBE?AV12@XZ endp
.text$mn:0000D079
.text$mn:0000D079 _text$mn        ends
.text$mn:0000D079
.text$mn:0000D07C ; ===========================================================================
.text$mn:0000D07C
.text$mn:0000D07C ; Segment type: Pure code
.text$mn:0000D07C ; Segment permissions: Read/Execute
.text$mn:0000D07C _text$mn        segment para public 'CODE' use32
.text$mn:0000D07C                 assume cs:_text$mn
.text$mn:0000D07C                 ;org 0D07Ch
.text$mn:0000D07C ; COMDAT (pick any)
.text$mn:0000D07C                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text$mn:0000D07C
.text$mn:0000D07C ; =============== S U B R O U T I N E =======================================
.text$mn:0000D07C
.text$mn:0000D07C ; Attributes: bp-based frame
.text$mn:0000D07C
.text$mn:0000D07C ; public: static class std::allocator<wchar_t> __cdecl std::allocator_traits<class std::allocator<wchar_t>>::select_on_container_copy_construction(class std::allocator<wchar_t> const &)
.text$mn:0000D07C                 public ?select_on_container_copy_construction@?$allocator_traits@V?$allocator@_W@std@@@std@@SA?AV?$allocator@_W@2@ABV32@@Z
.text$mn:0000D07C ?select_on_container_copy_construction@?$allocator_traits@V?$allocator@_W@std@@@std@@SA?AV?$allocator@_W@2@ABV32@@Z proc near
.text$mn:0000D07C                                         ; CODE XREF: std::_Wrap_alloc<std::allocator<wchar_t>>::select_on_container_copy_construction(void)+11p
.text$mn:0000D07C
.text$mn:0000D07C arg_0           = dword ptr  8
.text$mn:0000D07C arg_4           = dword ptr  0Ch
.text$mn:0000D07C
.text$mn:0000D07C                 push    ebp
.text$mn:0000D07D                 mov     ebp, esp
.text$mn:0000D07F                 mov     eax, [ebp+arg_0]
.text$mn:0000D082                 push    eax
.text$mn:0000D083                 mov     ecx, [ebp+arg_4]
.text$mn:0000D086                 call    ?select_on_container_copy_construction@?$allocator@_W@std@@QBE?AV12@XZ ; std::allocator<wchar_t>::select_on_container_copy_construction(void)
.text$mn:0000D08B                 mov     eax, [ebp+arg_0]
.text$mn:0000D08E                 pop     ebp
.text$mn:0000D08F                 retn
.text$mn:0000D08F ?select_on_container_copy_construction@?$allocator_traits@V?$allocator@_W@std@@@std@@SA?AV?$allocator@_W@2@ABV32@@Z endp
.text$mn:0000D08F
.text$mn:0000D08F _text$mn        ends
.text$mn:0000D08F
.text$mn:0000D090 ; ===========================================================================
.text$mn:0000D090
.text$mn:0000D090 ; Segment type: Pure code
.text$mn:0000D090 ; Segment permissions: Read/Execute
.text$mn:0000D090 _text$mn        segment para public 'CODE' use32
.text$mn:0000D090                 assume cs:_text$mn
.text$mn:0000D090                 ;org 0D090h
.text$mn:0000D090 ; COMDAT (pick any)
.text$mn:0000D090                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text$mn:0000D090
.text$mn:0000D090 ; =============== S U B R O U T I N E =======================================
.text$mn:0000D090
.text$mn:0000D090 ; Attributes: bp-based frame
.text$mn:0000D090
.text$mn:0000D090 ; public: unsigned int __thiscall std::basic_string<char, struct std::char_traits<char>, class std::allocator<char>>::size(void)const
.text$mn:0000D090                 public ?size@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QBEIXZ
.text$mn:0000D090 ?size@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QBEIXZ proc near
.text$mn:0000D090                                         ; CODE XREF: std::basic_string<char,std::char_traits<char>,std::allocator<char>>::append(std::basic_string<char,std::char_traits<char>,std::allocator<char>> const &,uint,uint)+Cp
.text$mn:0000D090                                         ; std::basic_string<char,std::char_traits<char>,std::allocator<char>>::append(std::basic_string<char,std::char_traits<char>,std::allocator<char>> const &,uint,uint)+21p ...
.text$mn:0000D090
.text$mn:0000D090 var_4           = dword ptr -4
.text$mn:0000D090
.text$mn:0000D090                 push    ebp
.text$mn:0000D091                 mov     ebp, esp
.text$mn:0000D093                 push    ecx
.text$mn:0000D094                 mov     [ebp+var_4], ecx
.text$mn:0000D097                 mov     eax, [ebp+var_4]
.text$mn:0000D09A                 mov     eax, [eax+14h]
.text$mn:0000D09D                 mov     esp, ebp
.text$mn:0000D09F                 pop     ebp
.text$mn:0000D0A0                 retn
.text$mn:0000D0A0 ?size@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QBEIXZ endp
.text$mn:0000D0A0
.text$mn:0000D0A0 ; ---------------------------------------------------------------------------
.text$mn:0000D0A1                 align 4
.text$mn:0000D0A1 _text$mn        ends
.text$mn:0000D0A1
.text$mn:0000D0A4 ; ===========================================================================
.text$mn:0000D0A4
.text$mn:0000D0A4 ; Segment type: Pure code
.text$mn:0000D0A4 ; Segment permissions: Read/Execute
.text$mn:0000D0A4 _text$mn        segment para public 'CODE' use32
.text$mn:0000D0A4                 assume cs:_text$mn
.text$mn:0000D0A4                 ;org 0D0A4h
.text$mn:0000D0A4 ; COMDAT (pick any)
.text$mn:0000D0A4                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text$mn:0000D0A4
.text$mn:0000D0A4 ; =============== S U B R O U T I N E =======================================
.text$mn:0000D0A4
.text$mn:0000D0A4 ; Attributes: bp-based frame
.text$mn:0000D0A4
.text$mn:0000D0A4 ; public: unsigned int __thiscall std::basic_string<wchar_t, struct std::char_traits<wchar_t>, class std::allocator<wchar_t>>::size(void)const
.text$mn:0000D0A4                 public ?size@?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QBEIXZ
.text$mn:0000D0A4 ?size@?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QBEIXZ proc near
.text$mn:0000D0A4                                         ; CODE XREF: PathRemoveFileSpecW(std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>> &)+4Dp
.text$mn:0000D0A4                                         ; PathRemoveFileSpecW(std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>> &)+9Cp ...
.text$mn:0000D0A4
.text$mn:0000D0A4 var_4           = dword ptr -4
.text$mn:0000D0A4
.text$mn:0000D0A4                 push    ebp
.text$mn:0000D0A5                 mov     ebp, esp
.text$mn:0000D0A7                 push    ecx
.text$mn:0000D0A8                 mov     [ebp+var_4], ecx
.text$mn:0000D0AB                 mov     eax, [ebp+var_4]
.text$mn:0000D0AE                 mov     eax, [eax+14h]
.text$mn:0000D0B1                 mov     esp, ebp
.text$mn:0000D0B3                 pop     ebp
.text$mn:0000D0B4                 retn
.text$mn:0000D0B4 ?size@?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QBEIXZ endp
.text$mn:0000D0B4
.text$mn:0000D0B4 ; ---------------------------------------------------------------------------
.text$mn:0000D0B5                 align 4
.text$mn:0000D0B5 _text$mn        ends
.text$mn:0000D0B5
.text$mn:0000D0B8 ; ===========================================================================
.text$mn:0000D0B8
.text$mn:0000D0B8 ; Segment type: Pure code
.text$mn:0000D0B8 ; Segment permissions: Read/Execute
.text$mn:0000D0B8 _text$mn        segment para public 'CODE' use32
.text$mn:0000D0B8                 assume cs:_text$mn
.text$mn:0000D0B8                 ;org 0D0B8h
.text$mn:0000D0B8 ; COMDAT (pick any)
.text$mn:0000D0B8                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text$mn:0000D0B8
.text$mn:0000D0B8 ; =============== S U B R O U T I N E =======================================
.text$mn:0000D0B8
.text$mn:0000D0B8 ; Attributes: bp-based frame
.text$mn:0000D0B8
.text$mn:0000D0B8 ; public: unsigned int __thiscall std::vector<char, class std::allocator<char>>::size(void)const
.text$mn:0000D0B8                 public ?size@?$vector@DV?$allocator@D@std@@@std@@QBEIXZ
.text$mn:0000D0B8 ?size@?$vector@DV?$allocator@D@std@@@std@@QBEIXZ proc near
.text$mn:0000D0B8                                         ; CODE XREF: std::vector<char,std::allocator<char>>::operator[](uint)+Ap
.text$mn:0000D0B8
.text$mn:0000D0B8 var_4           = dword ptr -4
.text$mn:0000D0B8
.text$mn:0000D0B8                 push    ebp
.text$mn:0000D0B9                 mov     ebp, esp
.text$mn:0000D0BB                 push    ecx
.text$mn:0000D0BC                 mov     [ebp+var_4], ecx
.text$mn:0000D0BF                 mov     eax, [ebp+var_4]
.text$mn:0000D0C2                 mov     ecx, [ebp+var_4]
.text$mn:0000D0C5                 mov     eax, [eax+8]
.text$mn:0000D0C8                 sub     eax, [ecx+4]
.text$mn:0000D0CB                 mov     esp, ebp
.text$mn:0000D0CD                 pop     ebp
.text$mn:0000D0CE                 retn
.text$mn:0000D0CE ?size@?$vector@DV?$allocator@D@std@@@std@@QBEIXZ endp
.text$mn:0000D0CE
.text$mn:0000D0CE ; ---------------------------------------------------------------------------
.text$mn:0000D0CF                 align 10h
.text$mn:0000D0CF _text$mn        ends
.text$mn:0000D0CF
.text$mn:0000D0D0 ; ===========================================================================
.text$mn:0000D0D0
.text$mn:0000D0D0 ; Segment type: Pure code
.text$mn:0000D0D0 ; Segment permissions: Read/Execute
.text$mn:0000D0D0 _text$mn        segment para public 'CODE' use32
.text$mn:0000D0D0                 assume cs:_text$mn
.text$mn:0000D0D0                 ;org 0D0D0h
.text$mn:0000D0D0 ; COMDAT (pick any)
.text$mn:0000D0D0                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text$mn:0000D0D0
.text$mn:0000D0D0 ; =============== S U B R O U T I N E =======================================
.text$mn:0000D0D0
.text$mn:0000D0D0 ; Attributes: bp-based frame
.text$mn:0000D0D0
.text$mn:0000D0D0 ; public: unsigned int __thiscall std::vector<class std::basic_string<wchar_t, struct std::char_traits<wchar_t>, class std::allocator<wchar_t>>, class std::allocator<class std::basic_string<wchar_t, struct std::char_traits<wchar_t>, class std::allocator<wchar_t>>>>::size(void)const
.text$mn:0000D0D0                 public ?size@?$vector@V?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@V?$allocator@V?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@@2@@std@@QBEIXZ
.text$mn:0000D0D0 ?size@?$vector@V?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@V?$allocator@V?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@@2@@std@@QBEIXZ proc near
.text$mn:0000D0D0                                         ; CODE XREF: stringJoin(std::vector<std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>>,std::allocator<std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>>>> const &,std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>> const &)+41p
.text$mn:0000D0D0                                         ; std::vector<std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>>,std::allocator<std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>>>>::_Reallocate(uint)+A9p ...
.text$mn:0000D0D0
.text$mn:0000D0D0 var_4           = dword ptr -4
.text$mn:0000D0D0
.text$mn:0000D0D0                 push    ebp
.text$mn:0000D0D1                 mov     ebp, esp
.text$mn:0000D0D3                 push    ecx
.text$mn:0000D0D4                 mov     [ebp+var_4], ecx
.text$mn:0000D0D7                 mov     eax, [ebp+var_4]
.text$mn:0000D0DA                 mov     ecx, [ebp+var_4]
.text$mn:0000D0DD                 mov     eax, [eax+8]
.text$mn:0000D0E0                 sub     eax, [ecx+4]
.text$mn:0000D0E3                 cdq
.text$mn:0000D0E4                 mov     ecx, 1Ch
.text$mn:0000D0E9                 idiv    ecx
.text$mn:0000D0EB                 mov     esp, ebp
.text$mn:0000D0ED                 pop     ebp
.text$mn:0000D0EE                 retn
.text$mn:0000D0EE ?size@?$vector@V?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@V?$allocator@V?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@@2@@std@@QBEIXZ endp
.text$mn:0000D0EE
.text$mn:0000D0EE ; ---------------------------------------------------------------------------
.text$mn:0000D0EF                 align 10h
.text$mn:0000D0EF _text$mn        ends
.text$mn:0000D0EF
.text$mn:0000D0F0 ; ===========================================================================
.text$mn:0000D0F0
.text$mn:0000D0F0 ; Segment type: Pure code
.text$mn:0000D0F0 ; Segment permissions: Read/Execute
.text$mn:0000D0F0 _text$mn        segment para public 'CODE' use32
.text$mn:0000D0F0                 assume cs:_text$mn
.text$mn:0000D0F0                 ;org 0D0F0h
.text$mn:0000D0F0 ; COMDAT (pick any)
.text$mn:0000D0F0                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text$mn:0000D0F0
.text$mn:0000D0F0 ; =============== S U B R O U T I N E =======================================
.text$mn:0000D0F0
.text$mn:0000D0F0 ; Attributes: bp-based frame
.text$mn:0000D0F0
.text$mn:0000D0F0 ; public: unsigned int __thiscall std::vector<wchar_t, class std::allocator<wchar_t>>::size(void)const
.text$mn:0000D0F0                 public ?size@?$vector@_WV?$allocator@_W@std@@@std@@QBEIXZ
.text$mn:0000D0F0 ?size@?$vector@_WV?$allocator@_W@std@@@std@@QBEIXZ proc near
.text$mn:0000D0F0                                         ; CODE XREF: std::vector<wchar_t,std::allocator<wchar_t>>::operator[](uint)+Ap
.text$mn:0000D0F0                                         ; std::vector<wchar_t,std::allocator<wchar_t>>::_Reallocate(uint)+A9p ...
.text$mn:0000D0F0
.text$mn:0000D0F0 var_4           = dword ptr -4
.text$mn:0000D0F0
.text$mn:0000D0F0                 push    ebp
.text$mn:0000D0F1                 mov     ebp, esp
.text$mn:0000D0F3                 push    ecx
.text$mn:0000D0F4                 mov     [ebp+var_4], ecx
.text$mn:0000D0F7                 mov     eax, [ebp+var_4]
.text$mn:0000D0FA                 mov     ecx, [ebp+var_4]
.text$mn:0000D0FD                 mov     eax, [eax+8]
.text$mn:0000D100                 sub     eax, [ecx+4]
.text$mn:0000D103                 sar     eax, 1
.text$mn:0000D105                 mov     esp, ebp
.text$mn:0000D107                 pop     ebp
.text$mn:0000D108                 retn
.text$mn:0000D108 ?size@?$vector@_WV?$allocator@_W@std@@@std@@QBEIXZ endp
.text$mn:0000D108
.text$mn:0000D108 ; ---------------------------------------------------------------------------
.text$mn:0000D109                 align 4
.text$mn:0000D109 _text$mn        ends
.text$mn:0000D109
.text$mn:0000D10C ; ===========================================================================
.text$mn:0000D10C
.text$mn:0000D10C ; Segment type: Pure code
.text$mn:0000D10C ; Segment permissions: Read/Execute
.text$mn:0000D10C _text$mn        segment para public 'CODE' use32
.text$mn:0000D10C                 assume cs:_text$mn
.text$mn:0000D10C                 ;org 0D10Ch
.text$mn:0000D10C ; COMDAT (pick any)
.text$mn:0000D10C                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text$mn:0000D10C
.text$mn:0000D10C ; =============== S U B R O U T I N E =======================================
.text$mn:0000D10C
.text$mn:0000D10C ; Attributes: bp-based frame
.text$mn:0000D10C
.text$mn:0000D10C ; public: void __thiscall WcharMbcsConvertor::StringBuffer<char>::sizeTo(unsigned int)
.text$mn:0000D10C                 public ?sizeTo@?$StringBuffer@D@WcharMbcsConvertor@@QAEXI@Z
.text$mn:0000D10C ?sizeTo@?$StringBuffer@D@WcharMbcsConvertor@@QAEXI@Z proc near
.text$mn:0000D10C                                         ; CODE XREF: WcharMbcsConvertor::wchar2char(wchar_t const *,uint,int,int *)+3Fp
.text$mn:0000D10C                                         ; WcharMbcsConvertor::wchar2char(wchar_t const *,uint,long *,long *)+44p
.text$mn:0000D10C
.text$mn:0000D10C var_10          = dword ptr -10h
.text$mn:0000D10C var_C           = dword ptr -0Ch
.text$mn:0000D10C var_8           = dword ptr -8
.text$mn:0000D10C var_4           = dword ptr -4
.text$mn:0000D10C arg_0           = dword ptr  8
.text$mn:0000D10C
.text$mn:0000D10C                 push    ebp
.text$mn:0000D10D                 mov     ebp, esp
.text$mn:0000D10F                 sub     esp, 10h
.text$mn:0000D112                 mov     [ebp+var_4], ecx
.text$mn:0000D115                 mov     eax, [ebp+var_4]
.text$mn:0000D118                 mov     ecx, [eax]
.text$mn:0000D11A                 cmp     ecx, [ebp+arg_0]
.text$mn:0000D11D                 jnb     short loc_D176
.text$mn:0000D11F                 mov     edx, [ebp+var_4]
.text$mn:0000D122                 cmp     dword ptr [edx], 0
.text$mn:0000D125                 jz      short loc_D13C
.text$mn:0000D127                 mov     eax, [ebp+var_4]
.text$mn:0000D12A                 mov     ecx, [eax+4]
.text$mn:0000D12D                 mov     [ebp+var_C], ecx
.text$mn:0000D130                 mov     edx, [ebp+var_C]
.text$mn:0000D133                 push    edx             ; void *
.text$mn:0000D134                 call    ??_V@YAXPAX@Z   ; operator delete[](void *)
.text$mn:0000D139                 add     esp, 4
.text$mn:0000D13C
.text$mn:0000D13C loc_D13C:                               ; CODE XREF: WcharMbcsConvertor::StringBuffer<char>::sizeTo(uint)+19j
.text$mn:0000D13C                 cmp     [ebp+arg_0], 400h
.text$mn:0000D143                 jbe     short loc_D14D
.text$mn:0000D145                 mov     eax, [ebp+arg_0]
.text$mn:0000D148                 mov     [ebp+var_8], eax
.text$mn:0000D14B                 jmp     short loc_D154
.text$mn:0000D14D ; ---------------------------------------------------------------------------
.text$mn:0000D14D
.text$mn:0000D14D loc_D14D:                               ; CODE XREF: WcharMbcsConvertor::StringBuffer<char>::sizeTo(uint)+37j
.text$mn:0000D14D                 mov     [ebp+var_8], 400h
.text$mn:0000D154
.text$mn:0000D154 loc_D154:                               ; CODE XREF: WcharMbcsConvertor::StringBuffer<char>::sizeTo(uint)+3Fj
.text$mn:0000D154                 mov     ecx, [ebp+var_4]
.text$mn:0000D157                 mov     edx, [ebp+var_8]
.text$mn:0000D15A                 mov     [ecx], edx
.text$mn:0000D15C                 mov     eax, [ebp+var_4]
.text$mn:0000D15F                 mov     ecx, [eax]
.text$mn:0000D161                 push    ecx             ; unsigned int
.text$mn:0000D162                 call    ??_U@YAPAXI@Z   ; operator new[](uint)
.text$mn:0000D167                 add     esp, 4
.text$mn:0000D16A                 mov     [ebp+var_10], eax
.text$mn:0000D16D                 mov     edx, [ebp+var_4]
.text$mn:0000D170                 mov     eax, [ebp+var_10]
.text$mn:0000D173                 mov     [edx+4], eax
.text$mn:0000D176
.text$mn:0000D176 loc_D176:                               ; CODE XREF: WcharMbcsConvertor::StringBuffer<char>::sizeTo(uint)+11j
.text$mn:0000D176                 mov     esp, ebp
.text$mn:0000D178                 pop     ebp
.text$mn:0000D179                 retn    4
.text$mn:0000D179 ?sizeTo@?$StringBuffer@D@WcharMbcsConvertor@@QAEXI@Z endp
.text$mn:0000D179
.text$mn:0000D179 _text$mn        ends
.text$mn:0000D179
.text$mn:0000D17C ; ===========================================================================
.text$mn:0000D17C
.text$mn:0000D17C ; Segment type: Pure code
.text$mn:0000D17C ; Segment permissions: Read/Execute
.text$mn:0000D17C _text$mn        segment para public 'CODE' use32
.text$mn:0000D17C                 assume cs:_text$mn
.text$mn:0000D17C                 ;org 0D17Ch
.text$mn:0000D17C ; COMDAT (pick any)
.text$mn:0000D17C                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text$mn:0000D17C
.text$mn:0000D17C ; =============== S U B R O U T I N E =======================================
.text$mn:0000D17C
.text$mn:0000D17C ; Attributes: bp-based frame
.text$mn:0000D17C
.text$mn:0000D17C ; public: void __thiscall WcharMbcsConvertor::StringBuffer<wchar_t>::sizeTo(unsigned int)
.text$mn:0000D17C                 public ?sizeTo@?$StringBuffer@_W@WcharMbcsConvertor@@QAEXI@Z
.text$mn:0000D17C ?sizeTo@?$StringBuffer@_W@WcharMbcsConvertor@@QAEXI@Z proc near
.text$mn:0000D17C                                         ; CODE XREF: WcharMbcsConvertor::char2wchar(char const *,uint,int,int *,int *)+19Cp
.text$mn:0000D17C                                         ; WcharMbcsConvertor::char2wchar(char const *,uint,int *,int *)+43p
.text$mn:0000D17C
.text$mn:0000D17C var_10          = dword ptr -10h
.text$mn:0000D17C var_C           = dword ptr -0Ch
.text$mn:0000D17C var_8           = dword ptr -8
.text$mn:0000D17C var_4           = dword ptr -4
.text$mn:0000D17C arg_0           = dword ptr  8
.text$mn:0000D17C
.text$mn:0000D17C                 push    ebp
.text$mn:0000D17D                 mov     ebp, esp
.text$mn:0000D17F                 sub     esp, 10h
.text$mn:0000D182                 mov     [ebp+var_4], ecx
.text$mn:0000D185                 mov     eax, [ebp+var_4]
.text$mn:0000D188                 mov     ecx, [eax]
.text$mn:0000D18A                 cmp     ecx, [ebp+arg_0]
.text$mn:0000D18D                 jnb     short loc_D1F6
.text$mn:0000D18F                 mov     edx, [ebp+var_4]
.text$mn:0000D192                 cmp     dword ptr [edx], 0
.text$mn:0000D195                 jz      short loc_D1AC
.text$mn:0000D197                 mov     eax, [ebp+var_4]
.text$mn:0000D19A                 mov     ecx, [eax+4]
.text$mn:0000D19D                 mov     [ebp+var_C], ecx
.text$mn:0000D1A0                 mov     edx, [ebp+var_C]
.text$mn:0000D1A3                 push    edx             ; void *
.text$mn:0000D1A4                 call    ??_V@YAXPAX@Z   ; operator delete[](void *)
.text$mn:0000D1A9                 add     esp, 4
.text$mn:0000D1AC
.text$mn:0000D1AC loc_D1AC:                               ; CODE XREF: WcharMbcsConvertor::StringBuffer<wchar_t>::sizeTo(uint)+19j
.text$mn:0000D1AC                 cmp     [ebp+arg_0], 400h
.text$mn:0000D1B3                 jbe     short loc_D1BD
.text$mn:0000D1B5                 mov     eax, [ebp+arg_0]
.text$mn:0000D1B8                 mov     [ebp+var_8], eax
.text$mn:0000D1BB                 jmp     short loc_D1C4
.text$mn:0000D1BD ; ---------------------------------------------------------------------------
.text$mn:0000D1BD
.text$mn:0000D1BD loc_D1BD:                               ; CODE XREF: WcharMbcsConvertor::StringBuffer<wchar_t>::sizeTo(uint)+37j
.text$mn:0000D1BD                 mov     [ebp+var_8], 400h
.text$mn:0000D1C4
.text$mn:0000D1C4 loc_D1C4:                               ; CODE XREF: WcharMbcsConvertor::StringBuffer<wchar_t>::sizeTo(uint)+3Fj
.text$mn:0000D1C4                 mov     ecx, [ebp+var_4]
.text$mn:0000D1C7                 mov     edx, [ebp+var_8]
.text$mn:0000D1CA                 mov     [ecx], edx
.text$mn:0000D1CC                 xor     ecx, ecx
.text$mn:0000D1CE                 mov     edx, [ebp+var_4]
.text$mn:0000D1D1                 mov     eax, [edx]
.text$mn:0000D1D3                 mov     edx, 2
.text$mn:0000D1D8                 mul     edx
.text$mn:0000D1DA                 seto    cl
.text$mn:0000D1DD                 neg     ecx
.text$mn:0000D1DF                 or      ecx, eax
.text$mn:0000D1E1                 push    ecx             ; unsigned int
.text$mn:0000D1E2                 call    ??_U@YAPAXI@Z   ; operator new[](uint)
.text$mn:0000D1E7                 add     esp, 4
.text$mn:0000D1EA                 mov     [ebp+var_10], eax
.text$mn:0000D1ED                 mov     eax, [ebp+var_4]
.text$mn:0000D1F0                 mov     ecx, [ebp+var_10]
.text$mn:0000D1F3                 mov     [eax+4], ecx
.text$mn:0000D1F6
.text$mn:0000D1F6 loc_D1F6:                               ; CODE XREF: WcharMbcsConvertor::StringBuffer<wchar_t>::sizeTo(uint)+11j
.text$mn:0000D1F6                 mov     esp, ebp
.text$mn:0000D1F8                 pop     ebp
.text$mn:0000D1F9                 retn    4
.text$mn:0000D1F9 ?sizeTo@?$StringBuffer@_W@WcharMbcsConvertor@@QAEXI@Z endp
.text$mn:0000D1F9
.text$mn:0000D1F9 _text$mn        ends
.text$mn:0000D1F9
.text$mn:0000D1FC ; ===========================================================================
.text$mn:0000D1FC
.text$mn:0000D1FC ; Segment type: Pure code
.text$mn:0000D1FC ; Segment permissions: Read/Execute
.text$mn:0000D1FC _text$mn        segment para public 'CODE' use32
.text$mn:0000D1FC                 assume cs:_text$mn
.text$mn:0000D1FC                 ;org 0D1FCh
.text$mn:0000D1FC ; COMDAT (pick any)
.text$mn:0000D1FC                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text$mn:0000D1FC
.text$mn:0000D1FC ; =============== S U B R O U T I N E =======================================
.text$mn:0000D1FC
.text$mn:0000D1FC ; Attributes: bp-based frame
.text$mn:0000D1FC
.text$mn:0000D1FC ; public: class std::basic_string<wchar_t, struct std::char_traits<wchar_t>, class std::allocator<wchar_t>> __thiscall std::basic_string<wchar_t, struct std::char_traits<wchar_t>, class std::allocator<wchar_t>>::substr(unsigned int, unsigned int)const
.text$mn:0000D1FC                 public ?substr@?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QBE?AV12@II@Z
.text$mn:0000D1FC ?substr@?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QBE?AV12@II@Z proc near
.text$mn:0000D1FC                                         ; CODE XREF: tokenizeString(std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>> const &,char)+94p
.text$mn:0000D1FC                                         ; stringSplit(std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>> const &,std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>> const &)+7Ep ...
.text$mn:0000D1FC
.text$mn:0000D1FC var_18          = dword ptr -18h
.text$mn:0000D1FC var_14          = dword ptr -14h
.text$mn:0000D1FC var_D           = byte ptr -0Dh
.text$mn:0000D1FC var_C           = dword ptr -0Ch
.text$mn:0000D1FC var_4           = dword ptr -4
.text$mn:0000D1FC arg_0           = dword ptr  8
.text$mn:0000D1FC arg_4           = dword ptr  0Ch
.text$mn:0000D1FC arg_8           = dword ptr  10h
.text$mn:0000D1FC
.text$mn:0000D1FC                 push    ebp
.text$mn:0000D1FD                 mov     ebp, esp
.text$mn:0000D1FF                 push    0FFFFFFFFh
.text$mn:0000D201                 push    offset __ehhandler$?substr@?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QBE?AV12@II@Z
.text$mn:0000D206                 mov     eax, large fs:0
.text$mn:0000D20C                 push    eax
.text$mn:0000D20D                 sub     esp, 0Ch
.text$mn:0000D210                 mov     eax, dword ptr ds:___security_cookie
.text$mn:0000D215                 xor     eax, ebp
.text$mn:0000D217                 push    eax
.text$mn:0000D218                 lea     eax, [ebp+var_C]
.text$mn:0000D21B                 mov     large fs:0, eax
.text$mn:0000D221                 mov     [ebp+var_14], ecx
.text$mn:0000D224                 mov     [ebp+var_18], 0
.text$mn:0000D22B                 lea     eax, [ebp+var_D]
.text$mn:0000D22E                 push    eax
.text$mn:0000D22F                 mov     ecx, [ebp+var_14]
.text$mn:0000D232                 call    ?get_allocator@?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QBE?AV?$allocator@_W@2@XZ ; std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>>::get_allocator(void)
.text$mn:0000D237                 push    eax
.text$mn:0000D238                 mov     ecx, [ebp+arg_8]
.text$mn:0000D23B                 push    ecx
.text$mn:0000D23C                 mov     edx, [ebp+arg_4]
.text$mn:0000D23F                 push    edx
.text$mn:0000D240                 mov     eax, [ebp+var_14]
.text$mn:0000D243                 push    eax
.text$mn:0000D244                 mov     ecx, [ebp+arg_0]
.text$mn:0000D247                 call    ??0?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QAE@ABV01@IIABV?$allocator@_W@1@@Z ; std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>>::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>>(std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>> const &,uint,uint,std::allocator<wchar_t> const &)
.text$mn:0000D24C                 mov     [ebp+var_4], 0
.text$mn:0000D253                 mov     ecx, [ebp+var_18]
.text$mn:0000D256                 or      ecx, 1
.text$mn:0000D259                 mov     [ebp+var_18], ecx
.text$mn:0000D25C                 mov     eax, [ebp+arg_0]
.text$mn:0000D25F                 mov     ecx, [ebp+var_C]
.text$mn:0000D262                 mov     large fs:0, ecx
.text$mn:0000D269                 pop     ecx
.text$mn:0000D26A                 mov     esp, ebp
.text$mn:0000D26C                 pop     ebp
.text$mn:0000D26D                 retn    0Ch
.text$mn:0000D26D ?substr@?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QBE?AV12@II@Z endp
.text$mn:0000D26D
.text$mn:0000D26D _text$mn        ends
.text$mn:0000D26D
.text$x:0000D270 ; ===========================================================================
.text$x:0000D270
.text$x:0000D270 ; Segment type: Pure code
.text$x:0000D270 ; Segment permissions: Read/Execute
.text$x:0000D270 _text$x         segment para public 'CODE' use32
.text$x:0000D270                 assume cs:_text$x
.text$x:0000D270                 ;org 0D270h
.text$x:0000D270 ; COMDAT (pick associative to section at D1FC)
.text$x:0000D270                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text$x:0000D270
.text$x:0000D270 ; =============== S U B R O U T I N E =======================================
.text$x:0000D270
.text$x:0000D270
.text$x:0000D270 __unwindfunclet$?substr@?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QBE?AV12@II@Z$0 proc near
.text$x:0000D270                                         ; DATA XREF: .xdata$x:0000DC30o
.text$x:0000D270                 mov     eax, [ebp-18h]
.text$x:0000D273                 and     eax, 1
.text$x:0000D276                 jz      $LN4_3
.text$x:0000D27C                 and     dword ptr [ebp-18h], 0FFFFFFFEh
.text$x:0000D280                 mov     ecx, [ebp+8]
.text$x:0000D283                 jmp     ??1?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QAE@XZ ; std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>>::~basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>>(void)
.text$x:0000D288 ; ---------------------------------------------------------------------------
.text$x:0000D288
.text$x:0000D288 $LN4_3:                                 ; CODE XREF: __unwindfunclet$?substr@?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QBE?AV12@II@Z$0+6j
.text$x:0000D288                 retn
.text$x:0000D288 __unwindfunclet$?substr@?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QBE?AV12@II@Z$0 endp
.text$x:0000D288
.text$x:0000D289
.text$x:0000D289 ; =============== S U B R O U T I N E =======================================
.text$x:0000D289
.text$x:0000D289
.text$x:0000D289 __ehhandler$?substr@?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QBE?AV12@II@Z proc near
.text$x:0000D289                                         ; DATA XREF: std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>>::substr(uint,uint)+5o
.text$x:0000D289
.text$x:0000D289 arg_4           = dword ptr  8
.text$x:0000D289
.text$x:0000D289                 mov     edx, [esp+arg_4]
.text$x:0000D28D                 lea     eax, [edx+0Ch]
.text$x:0000D290                 mov     ecx, [edx-10h]
.text$x:0000D293                 xor     ecx, eax
.text$x:0000D295                 call    @__security_check_cookie@4 ; __security_check_cookie(x)
.text$x:0000D29A                 mov     eax, offset __ehfuncinfo$?substr@?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QBE?AV12@II@Z
.text$x:0000D29F                 jmp     ___CxxFrameHandler3
.text$x:0000D29F __ehhandler$?substr@?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QBE?AV12@II@Z endp
.text$x:0000D29F
.text$x:0000D29F _text$x         ends
.text$x:0000D29F
.text$mn:0000D2A4 ; ===========================================================================
.text$mn:0000D2A4
.text$mn:0000D2A4 ; Segment type: Pure code
.text$mn:0000D2A4 ; Segment permissions: Read/Execute
.text$mn:0000D2A4 _text$mn        segment para public 'CODE' use32
.text$mn:0000D2A4                 assume cs:_text$mn
.text$mn:0000D2A4                 ;org 0D2A4h
.text$mn:0000D2A4 ; COMDAT (pick any)
.text$mn:0000D2A4                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text$mn:0000D2A4
.text$mn:0000D2A4 ; =============== S U B R O U T I N E =======================================
.text$mn:0000D2A4
.text$mn:0000D2A4 ; Attributes: bp-based frame
.text$mn:0000D2A4
.text$mn:0000D2A4 ; const struct std::error_category *__cdecl std::system_category()
.text$mn:0000D2A4                 public ?system_category@std@@YAABVerror_category@1@XZ
.text$mn:0000D2A4 ?system_category@std@@YAABVerror_category@1@XZ proc near
.text$mn:0000D2A4                                         ; CODE XREF: std::_System_error_category::default_error_condition(int):loc_B864p
.text$mn:0000D2A4                 push    ebp
.text$mn:0000D2A5                 mov     ebp, esp
.text$mn:0000D2A7                 mov     eax, offset ?_System_object@?$_Error_objects@H@std@@2V_System_error_category@2@A ; std::_System_error_category std::_Error_objects<int>::_System_object
.text$mn:0000D2AC                 pop     ebp
.text$mn:0000D2AD                 retn
.text$mn:0000D2AD ?system_category@std@@YAABVerror_category@1@XZ endp
.text$mn:0000D2AD
.text$mn:0000D2AD ; ---------------------------------------------------------------------------
.text$mn:0000D2AE                 align 10h
.text$mn:0000D2AE _text$mn        ends
.text$mn:0000D2AE
.text$mn:0000D2B0 ; ===========================================================================
.text$mn:0000D2B0
.text$mn:0000D2B0 ; Segment type: Pure code
.text$mn:0000D2B0 ; Segment permissions: Read/Execute
.text$mn:0000D2B0 _text$mn        segment para public 'CODE' use32
.text$mn:0000D2B0                 assume cs:_text$mn
.text$mn:0000D2B0                 ;org 0D2B0h
.text$mn:0000D2B0 ; COMDAT (pick any)
.text$mn:0000D2B0                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text$mn:0000D2B0
.text$mn:0000D2B0 ; =============== S U B R O U T I N E =======================================
.text$mn:0000D2B0
.text$mn:0000D2B0 ; Attributes: bp-based frame
.text$mn:0000D2B0
.text$mn:0000D2B0 ; int __thiscall std::error_code::value(std::error_code *__hidden this)
.text$mn:0000D2B0                 public ?value@error_code@std@@QBEHXZ
.text$mn:0000D2B0 ?value@error_code@std@@QBEHXZ proc near ; CODE XREF: std::error_category::equivalent(std::error_code const &,int)+24p
.text$mn:0000D2B0
.text$mn:0000D2B0 var_4           = dword ptr -4
.text$mn:0000D2B0
.text$mn:0000D2B0                 push    ebp
.text$mn:0000D2B1                 mov     ebp, esp
.text$mn:0000D2B3                 push    ecx
.text$mn:0000D2B4                 mov     [ebp+var_4], ecx
.text$mn:0000D2B7                 mov     eax, [ebp+var_4]
.text$mn:0000D2BA                 mov     eax, [eax]
.text$mn:0000D2BC                 mov     esp, ebp
.text$mn:0000D2BE                 pop     ebp
.text$mn:0000D2BF                 retn
.text$mn:0000D2BF ?value@error_code@std@@QBEHXZ endp
.text$mn:0000D2BF
.text$mn:0000D2BF _text$mn        ends
.text$mn:0000D2BF
.text$mn:0000D2C0 ; ===========================================================================
.text$mn:0000D2C0
.text$mn:0000D2C0 ; Segment type: Pure code
.text$mn:0000D2C0 ; Segment permissions: Read/Execute
.text$mn:0000D2C0 _text$mn        segment para public 'CODE' use32
.text$mn:0000D2C0                 assume cs:_text$mn
.text$mn:0000D2C0                 ;org 0D2C0h
.text$mn:0000D2C0 ; COMDAT (pick any)
.text$mn:0000D2C0                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text$mn:0000D2C0
.text$mn:0000D2C0 ; =============== S U B R O U T I N E =======================================
.text$mn:0000D2C0
.text$mn:0000D2C0 ; Attributes: bp-based frame
.text$mn:0000D2C0
.text$mn:0000D2C0 ; int __thiscall std::error_condition::value(std::error_condition *__hidden this)
.text$mn:0000D2C0                 public ?value@error_condition@std@@QBEHXZ
.text$mn:0000D2C0 ?value@error_condition@std@@QBEHXZ proc near
.text$mn:0000D2C0                                         ; CODE XREF: std::error_condition::operator==(std::error_condition const &)+2Cp
.text$mn:0000D2C0                                         ; std::error_condition::operator==(std::error_condition const &)+36p
.text$mn:0000D2C0
.text$mn:0000D2C0 var_4           = dword ptr -4
.text$mn:0000D2C0
.text$mn:0000D2C0                 push    ebp
.text$mn:0000D2C1                 mov     ebp, esp
.text$mn:0000D2C3                 push    ecx
.text$mn:0000D2C4                 mov     [ebp+var_4], ecx
.text$mn:0000D2C7                 mov     eax, [ebp+var_4]
.text$mn:0000D2CA                 mov     eax, [eax]
.text$mn:0000D2CC                 mov     esp, ebp
.text$mn:0000D2CE                 pop     ebp
.text$mn:0000D2CF                 retn
.text$mn:0000D2CF ?value@error_condition@std@@QBEHXZ endp
.text$mn:0000D2CF
.text$mn:0000D2CF _text$mn        ends
.text$mn:0000D2CF
.text$mn:0000D2D0 ; ===========================================================================
.text$mn:0000D2D0
.text$mn:0000D2D0 ; Segment type: Pure code
.text$mn:0000D2D0 ; Segment permissions: Read/Execute
.text$mn:0000D2D0 _text$mn        segment para public 'CODE' use32
.text$mn:0000D2D0                 assume cs:_text$mn
.text$mn:0000D2D0                 ;org 0D2D0h
.text$mn:0000D2D0 ; COMDAT (pick any)
.text$mn:0000D2D0                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text$mn:0000D2D0
.text$mn:0000D2D0 ; =============== S U B R O U T I N E =======================================
.text$mn:0000D2D0
.text$mn:0000D2D0 ; Attributes: bp-based frame
.text$mn:0000D2D0
.text$mn:0000D2D0                 public _hypot
.text$mn:0000D2D0 _hypot          proc near
.text$mn:0000D2D0
.text$mn:0000D2D0 var_10          = qword ptr -10h
.text$mn:0000D2D0 var_8           = qword ptr -8
.text$mn:0000D2D0 arg_0           = qword ptr  8
.text$mn:0000D2D0 arg_8           = qword ptr  10h
.text$mn:0000D2D0
.text$mn:0000D2D0                 push    ebp
.text$mn:0000D2D1                 mov     ebp, esp
.text$mn:0000D2D3                 sub     esp, 8
.text$mn:0000D2D6                 movsd   xmm0, [ebp+arg_8]
.text$mn:0000D2DB                 movsd   [esp+8+var_8], xmm0
.text$mn:0000D2E0                 sub     esp, 8
.text$mn:0000D2E3                 movsd   xmm0, [ebp+arg_0]
.text$mn:0000D2E8                 movsd   [esp+10h+var_10], xmm0
.text$mn:0000D2ED                 call    __hypot
.text$mn:0000D2F2                 add     esp, 10h
.text$mn:0000D2F5                 pop     ebp
.text$mn:0000D2F6                 retn
.text$mn:0000D2F6 _hypot          endp
.text$mn:0000D2F6
.text$mn:0000D2F6 ; ---------------------------------------------------------------------------
.text$mn:0000D2F7                 align 4
.text$mn:0000D2F7 _text$mn        ends
.text$mn:0000D2F7
.text$mn:0000D2F8 ; ===========================================================================
.text$mn:0000D2F8
.text$mn:0000D2F8 ; Segment type: Pure code
.text$mn:0000D2F8 ; Segment permissions: Read/Execute
.text$mn:0000D2F8 _text$mn        segment para public 'CODE' use32
.text$mn:0000D2F8                 assume cs:_text$mn
.text$mn:0000D2F8                 ;org 0D2F8h
.text$mn:0000D2F8 ; COMDAT (pick any)
.text$mn:0000D2F8                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text$mn:0000D2F8
.text$mn:0000D2F8 ; =============== S U B R O U T I N E =======================================
.text$mn:0000D2F8
.text$mn:0000D2F8 ; Attributes: bp-based frame
.text$mn:0000D2F8
.text$mn:0000D2F8                 public _wmemchr
.text$mn:0000D2F8 _wmemchr        proc near               ; CODE XREF: std::char_traits<wchar_t>::find(wchar_t const *,uint,wchar_t const &)+22p
.text$mn:0000D2F8
.text$mn:0000D2F8 arg_0           = dword ptr  8
.text$mn:0000D2F8 arg_4           = word ptr  0Ch
.text$mn:0000D2F8 arg_8           = dword ptr  10h
.text$mn:0000D2F8
.text$mn:0000D2F8                 push    ebp
.text$mn:0000D2F9                 mov     ebp, esp
.text$mn:0000D2FB                 jmp     short loc_D30F
.text$mn:0000D2FD ; ---------------------------------------------------------------------------
.text$mn:0000D2FD
.text$mn:0000D2FD loc_D2FD:                               ; CODE XREF: _wmemchr:loc_D328j
.text$mn:0000D2FD                 mov     eax, [ebp+arg_0]
.text$mn:0000D300                 add     eax, 2
.text$mn:0000D303                 mov     [ebp+arg_0], eax
.text$mn:0000D306                 mov     ecx, [ebp+arg_8]
.text$mn:0000D309                 sub     ecx, 1
.text$mn:0000D30C                 mov     [ebp+arg_8], ecx
.text$mn:0000D30F
.text$mn:0000D30F loc_D30F:                               ; CODE XREF: _wmemchr+3j
.text$mn:0000D30F                 cmp     [ebp+arg_8], 0
.text$mn:0000D313                 jbe     short loc_D32A
.text$mn:0000D315                 mov     edx, [ebp+arg_0]
.text$mn:0000D318                 movzx   eax, word ptr [edx]
.text$mn:0000D31B                 movzx   ecx, [ebp+arg_4]
.text$mn:0000D31F                 cmp     eax, ecx
.text$mn:0000D321                 jnz     short loc_D328
.text$mn:0000D323                 mov     eax, [ebp+arg_0]
.text$mn:0000D326                 jmp     short loc_D32C
.text$mn:0000D328 ; ---------------------------------------------------------------------------
.text$mn:0000D328
.text$mn:0000D328 loc_D328:                               ; CODE XREF: _wmemchr+29j
.text$mn:0000D328                 jmp     short loc_D2FD
.text$mn:0000D32A ; ---------------------------------------------------------------------------
.text$mn:0000D32A
.text$mn:0000D32A loc_D32A:                               ; CODE XREF: _wmemchr+1Bj
.text$mn:0000D32A                 xor     eax, eax
.text$mn:0000D32C
.text$mn:0000D32C loc_D32C:                               ; CODE XREF: _wmemchr+2Ej
.text$mn:0000D32C                 pop     ebp
.text$mn:0000D32D                 retn
.text$mn:0000D32D _wmemchr        endp
.text$mn:0000D32D
.text$mn:0000D32D ; ---------------------------------------------------------------------------
.text$mn:0000D32E                 align 10h
.text$mn:0000D32E _text$mn        ends
.text$mn:0000D32E
.text$mn:0000D330 ; ===========================================================================
.text$mn:0000D330
.text$mn:0000D330 ; Segment type: Pure code
.text$mn:0000D330 ; Segment permissions: Read/Execute
.text$mn:0000D330 _text$mn        segment para public 'CODE' use32
.text$mn:0000D330                 assume cs:_text$mn
.text$mn:0000D330                 ;org 0D330h
.text$mn:0000D330 ; COMDAT (pick any)
.text$mn:0000D330                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text$mn:0000D330
.text$mn:0000D330 ; =============== S U B R O U T I N E =======================================
.text$mn:0000D330
.text$mn:0000D330 ; Attributes: bp-based frame
.text$mn:0000D330
.text$mn:0000D330                 public _wmemcmp
.text$mn:0000D330 _wmemcmp        proc near               ; CODE XREF: std::char_traits<wchar_t>::compare(wchar_t const *,wchar_t const *,uint)+1Fp
.text$mn:0000D330
.text$mn:0000D330 var_4           = dword ptr -4
.text$mn:0000D330 arg_0           = dword ptr  8
.text$mn:0000D330 arg_4           = dword ptr  0Ch
.text$mn:0000D330 arg_8           = dword ptr  10h
.text$mn:0000D330
.text$mn:0000D330                 push    ebp
.text$mn:0000D331                 mov     ebp, esp
.text$mn:0000D333                 push    ecx
.text$mn:0000D334                 jmp     short loc_D351
.text$mn:0000D336 ; ---------------------------------------------------------------------------
.text$mn:0000D336
.text$mn:0000D336 loc_D336:                               ; CODE XREF: _wmemcmp:loc_D38Cj
.text$mn:0000D336                 mov     eax, [ebp+arg_0]
.text$mn:0000D339                 add     eax, 2
.text$mn:0000D33C                 mov     [ebp+arg_0], eax
.text$mn:0000D33F                 mov     ecx, [ebp+arg_4]
.text$mn:0000D342                 add     ecx, 2
.text$mn:0000D345                 mov     [ebp+arg_4], ecx
.text$mn:0000D348                 mov     edx, [ebp+arg_8]
.text$mn:0000D34B                 sub     edx, 1
.text$mn:0000D34E                 mov     [ebp+arg_8], edx
.text$mn:0000D351
.text$mn:0000D351 loc_D351:                               ; CODE XREF: _wmemcmp+4j
.text$mn:0000D351                 cmp     [ebp+arg_8], 0
.text$mn:0000D355                 jbe     short loc_D38E
.text$mn:0000D357                 mov     eax, [ebp+arg_0]
.text$mn:0000D35A                 movzx   ecx, word ptr [eax]
.text$mn:0000D35D                 mov     edx, [ebp+arg_4]
.text$mn:0000D360                 movzx   eax, word ptr [edx]
.text$mn:0000D363                 cmp     ecx, eax
.text$mn:0000D365                 jz      short loc_D38C
.text$mn:0000D367                 mov     ecx, [ebp+arg_0]
.text$mn:0000D36A                 movzx   edx, word ptr [ecx]
.text$mn:0000D36D                 mov     eax, [ebp+arg_4]
.text$mn:0000D370                 movzx   ecx, word ptr [eax]
.text$mn:0000D373                 cmp     edx, ecx
.text$mn:0000D375                 jge     short loc_D380
.text$mn:0000D377                 mov     [ebp+var_4], 0FFFFFFFFh
.text$mn:0000D37E                 jmp     short loc_D387
.text$mn:0000D380 ; ---------------------------------------------------------------------------
.text$mn:0000D380
.text$mn:0000D380 loc_D380:                               ; CODE XREF: _wmemcmp+45j
.text$mn:0000D380                 mov     [ebp+var_4], 1
.text$mn:0000D387
.text$mn:0000D387 loc_D387:                               ; CODE XREF: _wmemcmp+4Ej
.text$mn:0000D387                 mov     eax, [ebp+var_4]
.text$mn:0000D38A                 jmp     short loc_D390
.text$mn:0000D38C ; ---------------------------------------------------------------------------
.text$mn:0000D38C
.text$mn:0000D38C loc_D38C:                               ; CODE XREF: _wmemcmp+35j
.text$mn:0000D38C                 jmp     short loc_D336
.text$mn:0000D38E ; ---------------------------------------------------------------------------
.text$mn:0000D38E
.text$mn:0000D38E loc_D38E:                               ; CODE XREF: _wmemcmp+25j
.text$mn:0000D38E                 xor     eax, eax
.text$mn:0000D390
.text$mn:0000D390 loc_D390:                               ; CODE XREF: _wmemcmp+5Aj
.text$mn:0000D390                 mov     esp, ebp
.text$mn:0000D392                 pop     ebp
.text$mn:0000D393                 retn
.text$mn:0000D393 _wmemcmp        endp
.text$mn:0000D393
.text$mn:0000D393 _text$mn        ends
.text$mn:0000D393
.text$mn:0000D394 ; ===========================================================================
.text$mn:0000D394
.text$mn:0000D394 ; Segment type: Pure code
.text$mn:0000D394 ; Segment permissions: Read/Execute
.text$mn:0000D394 _text$mn        segment para public 'CODE' use32
.text$mn:0000D394                 assume cs:_text$mn
.text$mn:0000D394                 ;org 0D394h
.text$mn:0000D394 ; COMDAT (pick any)
.text$mn:0000D394                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text$mn:0000D394
.text$mn:0000D394 ; =============== S U B R O U T I N E =======================================
.text$mn:0000D394
.text$mn:0000D394 ; Attributes: bp-based frame
.text$mn:0000D394
.text$mn:0000D394 ; int __cdecl wmemcpy(void *Dst, void *Src, int)
.text$mn:0000D394                 public _wmemcpy
.text$mn:0000D394 _wmemcpy        proc near               ; CODE XREF: std::char_traits<wchar_t>::copy(wchar_t *,wchar_t const *,uint)+1Ep
.text$mn:0000D394
.text$mn:0000D394 Dst             = dword ptr  8
.text$mn:0000D394 Src             = dword ptr  0Ch
.text$mn:0000D394 arg_8           = dword ptr  10h
.text$mn:0000D394
.text$mn:0000D394                 push    ebp
.text$mn:0000D395                 mov     ebp, esp
.text$mn:0000D397                 mov     eax, [ebp+arg_8]
.text$mn:0000D39A                 shl     eax, 1
.text$mn:0000D39C                 push    eax             ; Size
.text$mn:0000D39D                 mov     ecx, [ebp+Src]
.text$mn:0000D3A0                 push    ecx             ; Src
.text$mn:0000D3A1                 mov     edx, [ebp+Dst]
.text$mn:0000D3A4                 push    edx             ; Dst
.text$mn:0000D3A5                 call    _memcpy
.text$mn:0000D3AA                 add     esp, 0Ch
.text$mn:0000D3AD                 pop     ebp
.text$mn:0000D3AE                 retn
.text$mn:0000D3AE _wmemcpy        endp
.text$mn:0000D3AE
.text$mn:0000D3AE ; ---------------------------------------------------------------------------
.text$mn:0000D3AF                 align 10h
.text$mn:0000D3AF _text$mn        ends
.text$mn:0000D3AF
.text$mn:0000D3B0 ; ===========================================================================
.text$mn:0000D3B0
.text$mn:0000D3B0 ; Segment type: Pure code
.text$mn:0000D3B0 ; Segment permissions: Read/Execute
.text$mn:0000D3B0 _text$mn        segment para public 'CODE' use32
.text$mn:0000D3B0                 assume cs:_text$mn
.text$mn:0000D3B0                 ;org 0D3B0h
.text$mn:0000D3B0 ; COMDAT (pick any)
.text$mn:0000D3B0                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text$mn:0000D3B0
.text$mn:0000D3B0 ; =============== S U B R O U T I N E =======================================
.text$mn:0000D3B0
.text$mn:0000D3B0 ; Attributes: bp-based frame
.text$mn:0000D3B0
.text$mn:0000D3B0 ; int __cdecl wmemmove(void *Dst, void *Src, int)
.text$mn:0000D3B0                 public _wmemmove
.text$mn:0000D3B0 _wmemmove       proc near               ; CODE XREF: std::char_traits<wchar_t>::move(wchar_t *,wchar_t const *,uint)+1Ep
.text$mn:0000D3B0
.text$mn:0000D3B0 Dst             = dword ptr  8
.text$mn:0000D3B0 Src             = dword ptr  0Ch
.text$mn:0000D3B0 arg_8           = dword ptr  10h
.text$mn:0000D3B0
.text$mn:0000D3B0                 push    ebp
.text$mn:0000D3B1                 mov     ebp, esp
.text$mn:0000D3B3                 mov     eax, [ebp+arg_8]
.text$mn:0000D3B6                 shl     eax, 1
.text$mn:0000D3B8                 push    eax             ; Size
.text$mn:0000D3B9                 mov     ecx, [ebp+Src]
.text$mn:0000D3BC                 push    ecx             ; Src
.text$mn:0000D3BD                 mov     edx, [ebp+Dst]
.text$mn:0000D3C0                 push    edx             ; Dst
.text$mn:0000D3C1                 call    _memmove
.text$mn:0000D3C6                 add     esp, 0Ch
.text$mn:0000D3C9                 pop     ebp
.text$mn:0000D3CA                 retn
.text$mn:0000D3CA _wmemmove       endp
.text$mn:0000D3CA
.text$mn:0000D3CA ; ---------------------------------------------------------------------------
.text$mn:0000D3CB                 align 4
.text$mn:0000D3CB _text$mn        ends
.text$mn:0000D3CB
.text$mn:0000D3CC ; ===========================================================================
.text$mn:0000D3CC
.text$mn:0000D3CC ; Segment type: Pure code
.text$mn:0000D3CC ; Segment permissions: Read/Execute
.text$mn:0000D3CC _text$mn        segment para public 'CODE' use32
.text$mn:0000D3CC                 assume cs:_text$mn
.text$mn:0000D3CC                 ;org 0D3CCh
.text$mn:0000D3CC ; COMDAT (pick any)
.text$mn:0000D3CC                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text$mn:0000D3CC
.text$mn:0000D3CC ; =============== S U B R O U T I N E =======================================
.text$mn:0000D3CC
.text$mn:0000D3CC ; Attributes: bp-based frame
.text$mn:0000D3CC
.text$mn:0000D3CC                 public _wmemset
.text$mn:0000D3CC _wmemset        proc near               ; CODE XREF: std::char_traits<wchar_t>::assign(wchar_t *,uint,wchar_t)+10p
.text$mn:0000D3CC
.text$mn:0000D3CC var_4           = dword ptr -4
.text$mn:0000D3CC arg_0           = dword ptr  8
.text$mn:0000D3CC arg_4           = word ptr  0Ch
.text$mn:0000D3CC arg_8           = dword ptr  10h
.text$mn:0000D3CC
.text$mn:0000D3CC                 push    ebp
.text$mn:0000D3CD                 mov     ebp, esp
.text$mn:0000D3CF                 push    ecx
.text$mn:0000D3D0                 mov     eax, [ebp+arg_0]
.text$mn:0000D3D3                 mov     [ebp+var_4], eax
.text$mn:0000D3D6                 jmp     short loc_D3EA
.text$mn:0000D3D8 ; ---------------------------------------------------------------------------
.text$mn:0000D3D8
.text$mn:0000D3D8 loc_D3D8:                               ; CODE XREF: _wmemset+2Ej
.text$mn:0000D3D8                 mov     ecx, [ebp+var_4]
.text$mn:0000D3DB                 add     ecx, 2
.text$mn:0000D3DE                 mov     [ebp+var_4], ecx
.text$mn:0000D3E1                 mov     edx, [ebp+arg_8]
.text$mn:0000D3E4                 sub     edx, 1
.text$mn:0000D3E7                 mov     [ebp+arg_8], edx
.text$mn:0000D3EA
.text$mn:0000D3EA loc_D3EA:                               ; CODE XREF: _wmemset+Aj
.text$mn:0000D3EA                 cmp     [ebp+arg_8], 0
.text$mn:0000D3EE                 jbe     short loc_D3FC
.text$mn:0000D3F0                 mov     eax, [ebp+var_4]
.text$mn:0000D3F3                 mov     cx, [ebp+arg_4]
.text$mn:0000D3F7                 mov     [eax], cx
.text$mn:0000D3FA                 jmp     short loc_D3D8
.text$mn:0000D3FC ; ---------------------------------------------------------------------------
.text$mn:0000D3FC
.text$mn:0000D3FC loc_D3FC:                               ; CODE XREF: _wmemset+22j
.text$mn:0000D3FC                 mov     eax, [ebp+arg_0]
.text$mn:0000D3FF                 mov     esp, ebp
.text$mn:0000D401                 pop     ebp
.text$mn:0000D402                 retn
.text$mn:0000D402 _wmemset        endp
.text$mn:0000D402
.text$mn:0000D402 ; ---------------------------------------------------------------------------
.text$mn:0000D403                 align 4
.text$mn:0000D403 _text$mn        ends
.text$mn:0000D403
.xdata$x:0000D404 ; ===========================================================================
.xdata$x:0000D404
.xdata$x:0000D404 ; Segment type: Pure data
.xdata$x:0000D404 ; Segment permissions: Read
.xdata$x:0000D404 _xdata$x        segment dword public 'DATA' use32
.xdata$x:0000D404                 assume cs:_xdata$x
.xdata$x:0000D404                 ;org 0D404h
.xdata$x:0000D404 ; COMDAT (pick associative to section at 9E64)
.xdata$x:0000D404 __unwindtable$?_Orphan_all@_Container_base12@std@@QAEXXZ db 0FFh
.xdata$x:0000D404                                         ; DATA XREF: .xdata$x:0000D414o
.xdata$x:0000D405                 db 0FFh
.xdata$x:0000D406                 db 0FFh
.xdata$x:0000D407                 db 0FFh
.xdata$x:0000D408                 dd offset __unwindfunclet$?_Orphan_all@_Container_base12@std@@QAEXXZ$0
.xdata$x:0000D40C __ehfuncinfo$?_Orphan_all@_Container_base12@std@@QAEXXZ db  22h ; "
.xdata$x:0000D40C                                         ; DATA XREF: __ehhandler$?_Orphan_all@_Container_base12@std@@QAEXXZ+11o
.xdata$x:0000D40D                 db    5
.xdata$x:0000D40E                 db  93h ; ô
.xdata$x:0000D40F                 db  19h
.xdata$x:0000D410                 db    1
.xdata$x:0000D411                 db    0
.xdata$x:0000D412                 db    0
.xdata$x:0000D413                 db    0
.xdata$x:0000D414                 dd offset __unwindtable$?_Orphan_all@_Container_base12@std@@QAEXXZ
.xdata$x:0000D418                 db    0
.xdata$x:0000D419                 db    0
.xdata$x:0000D41A                 db    0
.xdata$x:0000D41B                 db    0
.xdata$x:0000D41C                 db    0
.xdata$x:0000D41D                 db    0
.xdata$x:0000D41E                 db    0
.xdata$x:0000D41F                 db    0
.xdata$x:0000D420                 db    0
.xdata$x:0000D421                 db    0
.xdata$x:0000D422                 db    0
.xdata$x:0000D423                 db    0
.xdata$x:0000D424                 db    0
.xdata$x:0000D425                 db    0
.xdata$x:0000D426                 db    0
.xdata$x:0000D427                 db    0
.xdata$x:0000D428                 db    0
.xdata$x:0000D429                 db    0
.xdata$x:0000D42A                 db    0
.xdata$x:0000D42B                 db    0
.xdata$x:0000D42C                 db    0
.xdata$x:0000D42D                 db    0
.xdata$x:0000D42E                 db    0
.xdata$x:0000D42F                 db    0
.xdata$x:0000D42F _xdata$x        ends
.xdata$x:0000D42F
.xdata$x:0000D430 ; ===========================================================================
.xdata$x:0000D430
.xdata$x:0000D430 ; Segment type: Pure data
.xdata$x:0000D430 ; Segment permissions: Read
.xdata$x:0000D430 _xdata$x        segment dword public 'DATA' use32
.xdata$x:0000D430                 assume cs:_xdata$x
.xdata$x:0000D430                 ;org 0D430h
.xdata$x:0000D430 ; COMDAT (pick associative to section at A568)
.xdata$x:0000D430 __unwindtable$?_Swap_all@_Container_base12@std@@QAEXAAU12@@Z db 0FFh
.xdata$x:0000D430                                         ; DATA XREF: .xdata$x:0000D440o
.xdata$x:0000D431                 db 0FFh
.xdata$x:0000D432                 db 0FFh
.xdata$x:0000D433                 db 0FFh
.xdata$x:0000D434                 dd offset __unwindfunclet$?_Swap_all@_Container_base12@std@@QAEXAAU12@@Z$0
.xdata$x:0000D438 __ehfuncinfo$?_Swap_all@_Container_base12@std@@QAEXAAU12@@Z db  22h ; "
.xdata$x:0000D438                                         ; DATA XREF: __ehhandler$?_Swap_all@_Container_base12@std@@QAEXAAU12@@Z+11o
.xdata$x:0000D439                 db    5
.xdata$x:0000D43A                 db  93h ; ô
.xdata$x:0000D43B                 db  19h
.xdata$x:0000D43C                 db    1
.xdata$x:0000D43D                 db    0
.xdata$x:0000D43E                 db    0
.xdata$x:0000D43F                 db    0
.xdata$x:0000D440                 dd offset __unwindtable$?_Swap_all@_Container_base12@std@@QAEXAAU12@@Z
.xdata$x:0000D444                 db    0
.xdata$x:0000D445                 db    0
.xdata$x:0000D446                 db    0
.xdata$x:0000D447                 db    0
.xdata$x:0000D448                 db    0
.xdata$x:0000D449                 db    0
.xdata$x:0000D44A                 db    0
.xdata$x:0000D44B                 db    0
.xdata$x:0000D44C                 db    0
.xdata$x:0000D44D                 db    0
.xdata$x:0000D44E                 db    0
.xdata$x:0000D44F                 db    0
.xdata$x:0000D450                 db    0
.xdata$x:0000D451                 db    0
.xdata$x:0000D452                 db    0
.xdata$x:0000D453                 db    0
.xdata$x:0000D454                 db    0
.xdata$x:0000D455                 db    0
.xdata$x:0000D456                 db    0
.xdata$x:0000D457                 db    0
.xdata$x:0000D458                 db    0
.xdata$x:0000D459                 db    0
.xdata$x:0000D45A                 db    0
.xdata$x:0000D45B                 db    0
.xdata$x:0000D45B _xdata$x        ends
.xdata$x:0000D45B
.xdata$x:0000D45C ; ===========================================================================
.xdata$x:0000D45C
.xdata$x:0000D45C ; Segment type: Pure data
.xdata$x:0000D45C ; Segment permissions: Read
.xdata$x:0000D45C _xdata$x        segment dword public 'DATA' use32
.xdata$x:0000D45C                 assume cs:_xdata$x
.xdata$x:0000D45C                 ;org 0D45Ch
.xdata$x:0000D45C ; COMDAT (pick associative to section at 7B70)
.xdata$x:0000D45C __unwindtable$??4_Iterator_base12@std@@QAEAAU01@ABU01@@Z db 0FFh
.xdata$x:0000D45C                                         ; DATA XREF: .xdata$x:0000D46Co
.xdata$x:0000D45D                 db 0FFh
.xdata$x:0000D45E                 db 0FFh
.xdata$x:0000D45F                 db 0FFh
.xdata$x:0000D460                 dd offset __unwindfunclet$??4_Iterator_base12@std@@QAEAAU01@ABU01@@Z$0
.xdata$x:0000D464 __ehfuncinfo$??4_Iterator_base12@std@@QAEAAU01@ABU01@@Z db  22h ; "
.xdata$x:0000D464                                         ; DATA XREF: __ehhandler$??4_Iterator_base12@std@@QAEAAU01@ABU01@@Z+11o
.xdata$x:0000D465                 db    5
.xdata$x:0000D466                 db  93h ; ô
.xdata$x:0000D467                 db  19h
.xdata$x:0000D468                 db    1
.xdata$x:0000D469                 db    0
.xdata$x:0000D46A                 db    0
.xdata$x:0000D46B                 db    0
.xdata$x:0000D46C                 dd offset __unwindtable$??4_Iterator_base12@std@@QAEAAU01@ABU01@@Z
.xdata$x:0000D470                 db    0
.xdata$x:0000D471                 db    0
.xdata$x:0000D472                 db    0
.xdata$x:0000D473                 db    0
.xdata$x:0000D474                 db    0
.xdata$x:0000D475                 db    0
.xdata$x:0000D476                 db    0
.xdata$x:0000D477                 db    0
.xdata$x:0000D478                 db    0
.xdata$x:0000D479                 db    0
.xdata$x:0000D47A                 db    0
.xdata$x:0000D47B                 db    0
.xdata$x:0000D47C                 db    0
.xdata$x:0000D47D                 db    0
.xdata$x:0000D47E                 db    0
.xdata$x:0000D47F                 db    0
.xdata$x:0000D480                 db    0
.xdata$x:0000D481                 db    0
.xdata$x:0000D482                 db    0
.xdata$x:0000D483                 db    0
.xdata$x:0000D484                 db    0
.xdata$x:0000D485                 db    0
.xdata$x:0000D486                 db    0
.xdata$x:0000D487                 db    0
.xdata$x:0000D487 _xdata$x        ends
.xdata$x:0000D487
.xdata$x:0000D488 ; ===========================================================================
.xdata$x:0000D488
.xdata$x:0000D488 ; Segment type: Pure data
.xdata$x:0000D488 ; Segment permissions: Read
.xdata$x:0000D488 _xdata$x        segment dword public 'DATA' use32
.xdata$x:0000D488                 assume cs:_xdata$x
.xdata$x:0000D488                 ;org 0D488h
.xdata$x:0000D488 ; COMDAT (pick associative to section at 7878)
.xdata$x:0000D488 __unwindtable$??1_Iterator_base12@std@@QAE@XZ db 0FFh
.xdata$x:0000D488                                         ; DATA XREF: .xdata$x:0000D498o
.xdata$x:0000D489                 db 0FFh
.xdata$x:0000D48A                 db 0FFh
.xdata$x:0000D48B                 db 0FFh
.xdata$x:0000D48C                 dd offset __unwindfunclet$??1_Iterator_base12@std@@QAE@XZ$0
.xdata$x:0000D490 __ehfuncinfo$??1_Iterator_base12@std@@QAE@XZ db  22h ; "
.xdata$x:0000D490                                         ; DATA XREF: __ehhandler$??1_Iterator_base12@std@@QAE@XZ+11o
.xdata$x:0000D491                 db    5
.xdata$x:0000D492                 db  93h ; ô
.xdata$x:0000D493                 db  19h
.xdata$x:0000D494                 db    1
.xdata$x:0000D495                 db    0
.xdata$x:0000D496                 db    0
.xdata$x:0000D497                 db    0
.xdata$x:0000D498                 dd offset __unwindtable$??1_Iterator_base12@std@@QAE@XZ
.xdata$x:0000D49C                 db    0
.xdata$x:0000D49D                 db    0
.xdata$x:0000D49E                 db    0
.xdata$x:0000D49F                 db    0
.xdata$x:0000D4A0                 db    0
.xdata$x:0000D4A1                 db    0
.xdata$x:0000D4A2                 db    0
.xdata$x:0000D4A3                 db    0
.xdata$x:0000D4A4                 db    0
.xdata$x:0000D4A5                 db    0
.xdata$x:0000D4A6                 db    0
.xdata$x:0000D4A7                 db    0
.xdata$x:0000D4A8                 db    0
.xdata$x:0000D4A9                 db    0
.xdata$x:0000D4AA                 db    0
.xdata$x:0000D4AB                 db    0
.xdata$x:0000D4AC                 db    0
.xdata$x:0000D4AD                 db    0
.xdata$x:0000D4AE                 db    0
.xdata$x:0000D4AF                 db    0
.xdata$x:0000D4B0                 db    0
.xdata$x:0000D4B1                 db    0
.xdata$x:0000D4B2                 db    0
.xdata$x:0000D4B3                 db    0
.xdata$x:0000D4B3 _xdata$x        ends
.xdata$x:0000D4B3
.xdata$x:0000D4B4 ; ===========================================================================
.xdata$x:0000D4B4
.xdata$x:0000D4B4 ; Segment type: Pure data
.xdata$x:0000D4B4 ; Segment permissions: Read
.xdata$x:0000D4B4 _xdata$x        segment dword public 'DATA' use32
.xdata$x:0000D4B4                 assume cs:_xdata$x
.xdata$x:0000D4B4                 ;org 0D4B4h
.xdata$x:0000D4B4 ; COMDAT (pick associative to section at 8D28)
.xdata$x:0000D4B4 __unwindtable$?_Adopt@_Iterator_base12@std@@QAEXPBU_Container_base12@2@@Z db 0FFh
.xdata$x:0000D4B4                                         ; DATA XREF: .xdata$x:0000D4CCo
.xdata$x:0000D4B5                 db 0FFh
.xdata$x:0000D4B6                 db 0FFh
.xdata$x:0000D4B7                 db 0FFh
.xdata$x:0000D4B8                 dd offset __unwindfunclet$?_Adopt@_Iterator_base12@std@@QAEXPBU_Container_base12@2@@Z$0
.xdata$x:0000D4BC                 db 0FFh
.xdata$x:0000D4BD                 db 0FFh
.xdata$x:0000D4BE                 db 0FFh
.xdata$x:0000D4BF                 db 0FFh
.xdata$x:0000D4C0                 dd offset __unwindfunclet$?_Adopt@_Iterator_base12@std@@QAEXPBU_Container_base12@2@@Z$1
.xdata$x:0000D4C4 __ehfuncinfo$?_Adopt@_Iterator_base12@std@@QAEXPBU_Container_base12@2@@Z db  22h ; "
.xdata$x:0000D4C4                                         ; DATA XREF: __ehhandler$?_Adopt@_Iterator_base12@std@@QAEXPBU_Container_base12@2@@Z+11o
.xdata$x:0000D4C5                 db    5
.xdata$x:0000D4C6                 db  93h ; ô
.xdata$x:0000D4C7                 db  19h
.xdata$x:0000D4C8                 db    2
.xdata$x:0000D4C9                 db    0
.xdata$x:0000D4CA                 db    0
.xdata$x:0000D4CB                 db    0
.xdata$x:0000D4CC                 dd offset __unwindtable$?_Adopt@_Iterator_base12@std@@QAEXPBU_Container_base12@2@@Z
.xdata$x:0000D4D0                 db    0
.xdata$x:0000D4D1                 db    0
.xdata$x:0000D4D2                 db    0
.xdata$x:0000D4D3                 db    0
.xdata$x:0000D4D4                 db    0
.xdata$x:0000D4D5                 db    0
.xdata$x:0000D4D6                 db    0
.xdata$x:0000D4D7                 db    0
.xdata$x:0000D4D8                 db    0
.xdata$x:0000D4D9                 db    0
.xdata$x:0000D4DA                 db    0
.xdata$x:0000D4DB                 db    0
.xdata$x:0000D4DC                 db    0
.xdata$x:0000D4DD                 db    0
.xdata$x:0000D4DE                 db    0
.xdata$x:0000D4DF                 db    0
.xdata$x:0000D4E0                 db    0
.xdata$x:0000D4E1                 db    0
.xdata$x:0000D4E2                 db    0
.xdata$x:0000D4E3                 db    0
.xdata$x:0000D4E4                 db    0
.xdata$x:0000D4E5                 db    0
.xdata$x:0000D4E6                 db    0
.xdata$x:0000D4E7                 db    0
.xdata$x:0000D4E7 _xdata$x        ends
.xdata$x:0000D4E7
.xdata$x:0000D4E8 ; ===========================================================================
.xdata$x:0000D4E8
.xdata$x:0000D4E8 ; Segment type: Pure data
.xdata$x:0000D4E8 ; Segment permissions: Read
.xdata$x:0000D4E8 _xdata$x        segment dword public 'DATA' use32
.xdata$x:0000D4E8                 assume cs:_xdata$x
.xdata$x:0000D4E8                 ;org 0D4E8h
.xdata$x:0000D4E8 ; COMDAT (pick associative to section at 6C2C)
.xdata$x:0000D4E8 __unwindtable$??0logic_error@std@@QAE@PBD@Z db 0FFh
.xdata$x:0000D4E8                                         ; DATA XREF: .xdata$x:0000D4F8o
.xdata$x:0000D4E9                 db 0FFh
.xdata$x:0000D4EA                 db 0FFh
.xdata$x:0000D4EB                 db 0FFh
.xdata$x:0000D4EC                 dd offset __unwindfunclet$??0logic_error@std@@QAE@PBD@Z$0
.xdata$x:0000D4F0 __ehfuncinfo$??0logic_error@std@@QAE@PBD@Z db  22h ; "
.xdata$x:0000D4F0                                         ; DATA XREF: __ehhandler$??0logic_error@std@@QAE@PBD@Z+11o
.xdata$x:0000D4F1                 db    5
.xdata$x:0000D4F2                 db  93h ; ô
.xdata$x:0000D4F3                 db  19h
.xdata$x:0000D4F4                 db    1
.xdata$x:0000D4F5                 db    0
.xdata$x:0000D4F6                 db    0
.xdata$x:0000D4F7                 db    0
.xdata$x:0000D4F8                 dd offset __unwindtable$??0logic_error@std@@QAE@PBD@Z
.xdata$x:0000D4FC                 db    0
.xdata$x:0000D4FD                 db    0
.xdata$x:0000D4FE                 db    0
.xdata$x:0000D4FF                 db    0
.xdata$x:0000D500                 db    0
.xdata$x:0000D501                 db    0
.xdata$x:0000D502                 db    0
.xdata$x:0000D503                 db    0
.xdata$x:0000D504                 db    0
.xdata$x:0000D505                 db    0
.xdata$x:0000D506                 db    0
.xdata$x:0000D507                 db    0
.xdata$x:0000D508                 db    0
.xdata$x:0000D509                 db    0
.xdata$x:0000D50A                 db    0
.xdata$x:0000D50B                 db    0
.xdata$x:0000D50C                 db    0
.xdata$x:0000D50D                 db    0
.xdata$x:0000D50E                 db    0
.xdata$x:0000D50F                 db    0
.xdata$x:0000D510                 db    0
.xdata$x:0000D511                 db    0
.xdata$x:0000D512                 db    0
.xdata$x:0000D513                 db    0
.xdata$x:0000D513 _xdata$x        ends
.xdata$x:0000D513
.xdata$x:0000D514 ; ===========================================================================
.xdata$x:0000D514
.xdata$x:0000D514 ; Segment type: Pure data
.xdata$x:0000D514 ; Segment permissions: Read
.xdata$x:0000D514 _xdata$x        segment dword public 'DATA' use32
.xdata$x:0000D514                 assume cs:_xdata$x
.xdata$x:0000D514                 ;org 0D514h
.xdata$x:0000D514 ; COMDAT (pick associative to section at 79F0)
.xdata$x:0000D514 __unwindtable$??1logic_error@std@@UAE@XZ db 0FFh
.xdata$x:0000D514                                         ; DATA XREF: .xdata$x:0000D524o
.xdata$x:0000D515                 db 0FFh
.xdata$x:0000D516                 db 0FFh
.xdata$x:0000D517                 db 0FFh
.xdata$x:0000D518                 dd offset __unwindfunclet$??1logic_error@std@@UAE@XZ$0
.xdata$x:0000D51C __ehfuncinfo$??1logic_error@std@@UAE@XZ db  22h ; "
.xdata$x:0000D51C                                         ; DATA XREF: __ehhandler$??1logic_error@std@@UAE@XZ+11o
.xdata$x:0000D51D                 db    5
.xdata$x:0000D51E                 db  93h ; ô
.xdata$x:0000D51F                 db  19h
.xdata$x:0000D520                 db    1
.xdata$x:0000D521                 db    0
.xdata$x:0000D522                 db    0
.xdata$x:0000D523                 db    0
.xdata$x:0000D524                 dd offset __unwindtable$??1logic_error@std@@UAE@XZ
.xdata$x:0000D528                 align 20h
.xdata$x:0000D528 _xdata$x        ends
.xdata$x:0000D528
.xdata$x:0000D540 ; ===========================================================================
.xdata$x:0000D540
.xdata$x:0000D540 ; Segment type: Pure data
.xdata$x:0000D540 ; Segment permissions: Read
.xdata$x:0000D540 _xdata$x        segment dword public 'DATA' use32
.xdata$x:0000D540                 assume cs:_xdata$x
.xdata$x:0000D540                 ;org 0D540h
.xdata$x:0000D540 ; COMDAT (pick associative to section at 58A0)
.xdata$x:0000D540 __unwindtable$??0?$_String_val@U?$_Simple_types@D@std@@@std@@QAE@XZ db 0FFh
.xdata$x:0000D540                                         ; DATA XREF: .xdata$x:0000D550o
.xdata$x:0000D541                 db 0FFh
.xdata$x:0000D542                 db 0FFh
.xdata$x:0000D543                 db 0FFh
.xdata$x:0000D544                 dd offset __unwindfunclet$??0?$_String_val@U?$_Simple_types@D@std@@@std@@QAE@XZ$0
.xdata$x:0000D548 __ehfuncinfo$??0?$_String_val@U?$_Simple_types@D@std@@@std@@QAE@XZ db  22h ; "
.xdata$x:0000D548                                         ; DATA XREF: __ehhandler$??0?$_String_val@U?$_Simple_types@D@std@@@std@@QAE@XZ+11o
.xdata$x:0000D549                 db    5
.xdata$x:0000D54A                 db  93h ; ô
.xdata$x:0000D54B                 db  19h
.xdata$x:0000D54C                 db    1
.xdata$x:0000D54D                 db    0
.xdata$x:0000D54E                 db    0
.xdata$x:0000D54F                 db    0
.xdata$x:0000D550                 dd offset __unwindtable$??0?$_String_val@U?$_Simple_types@D@std@@@std@@QAE@XZ
.xdata$x:0000D554                 db    0
.xdata$x:0000D555                 db    0
.xdata$x:0000D556                 db    0
.xdata$x:0000D557                 db    0
.xdata$x:0000D558                 db    0
.xdata$x:0000D559                 db    0
.xdata$x:0000D55A                 db    0
.xdata$x:0000D55B                 db    0
.xdata$x:0000D55C                 db    0
.xdata$x:0000D55D                 db    0
.xdata$x:0000D55E                 db    0
.xdata$x:0000D55F                 db    0
.xdata$x:0000D560                 db    0
.xdata$x:0000D561                 db    0
.xdata$x:0000D562                 db    0
.xdata$x:0000D563                 db    0
.xdata$x:0000D564                 db    0
.xdata$x:0000D565                 db    0
.xdata$x:0000D566                 db    0
.xdata$x:0000D567                 db    0
.xdata$x:0000D568                 db    0
.xdata$x:0000D569                 db    0
.xdata$x:0000D56A                 db    0
.xdata$x:0000D56B                 db    0
.xdata$x:0000D56B _xdata$x        ends
.xdata$x:0000D56B
.xdata$x:0000D56C ; ===========================================================================
.xdata$x:0000D56C
.xdata$x:0000D56C ; Segment type: Pure data
.xdata$x:0000D56C ; Segment permissions: Read
.xdata$x:0000D56C _xdata$x        segment dword public 'DATA' use32
.xdata$x:0000D56C                 assume cs:_xdata$x
.xdata$x:0000D56C                 ;org 0D56Ch
.xdata$x:0000D56C ; COMDAT (pick associative to section at 703C)
.xdata$x:0000D56C __unwindtable$??1?$_String_val@U?$_Simple_types@D@std@@@std@@QAE@XZ db 0FFh
.xdata$x:0000D56C                                         ; DATA XREF: .xdata$x:0000D57Co
.xdata$x:0000D56D                 db 0FFh
.xdata$x:0000D56E                 db 0FFh
.xdata$x:0000D56F                 db 0FFh
.xdata$x:0000D570                 dd offset __unwindfunclet$??1?$_String_val@U?$_Simple_types@D@std@@@std@@QAE@XZ$0
.xdata$x:0000D574 __ehfuncinfo$??1?$_String_val@U?$_Simple_types@D@std@@@std@@QAE@XZ db  22h ; "
.xdata$x:0000D574                                         ; DATA XREF: __ehhandler$??1?$_String_val@U?$_Simple_types@D@std@@@std@@QAE@XZ+11o
.xdata$x:0000D575                 db    5
.xdata$x:0000D576                 db  93h ; ô
.xdata$x:0000D577                 db  19h
.xdata$x:0000D578                 db    1
.xdata$x:0000D579                 db    0
.xdata$x:0000D57A                 db    0
.xdata$x:0000D57B                 db    0
.xdata$x:0000D57C                 dd offset __unwindtable$??1?$_String_val@U?$_Simple_types@D@std@@@std@@QAE@XZ
.xdata$x:0000D580                 db    0
.xdata$x:0000D581                 db    0
.xdata$x:0000D582                 db    0
.xdata$x:0000D583                 db    0
.xdata$x:0000D584                 db    0
.xdata$x:0000D585                 db    0
.xdata$x:0000D586                 db    0
.xdata$x:0000D587                 db    0
.xdata$x:0000D588                 db    0
.xdata$x:0000D589                 db    0
.xdata$x:0000D58A                 db    0
.xdata$x:0000D58B                 db    0
.xdata$x:0000D58C                 db    0
.xdata$x:0000D58D                 db    0
.xdata$x:0000D58E                 db    0
.xdata$x:0000D58F                 db    0
.xdata$x:0000D590                 db    0
.xdata$x:0000D591                 db    0
.xdata$x:0000D592                 db    0
.xdata$x:0000D593                 db    0
.xdata$x:0000D594                 db    0
.xdata$x:0000D595                 db    0
.xdata$x:0000D596                 db    0
.xdata$x:0000D597                 db    0
.xdata$x:0000D597 _xdata$x        ends
.xdata$x:0000D597
.xdata$x:0000D598 ; ===========================================================================
.xdata$x:0000D598
.xdata$x:0000D598 ; Segment type: Pure data
.xdata$x:0000D598 ; Segment permissions: Read
.xdata$x:0000D598 _xdata$x        segment dword public 'DATA' use32
.xdata$x:0000D598                 assume cs:_xdata$x
.xdata$x:0000D598                 ;org 0D598h
.xdata$x:0000D598 ; COMDAT (pick associative to section at 55A4)
.xdata$x:0000D598 __unwindtable$??0?$_String_alloc@$0A@U?$_String_base_types@DV?$allocator@D@std@@@std@@@std@@QAE@ABV?$allocator@D@1@@Z db 0FFh
.xdata$x:0000D598                                         ; DATA XREF: .xdata$x:0000D5A8o
.xdata$x:0000D599                 db 0FFh
.xdata$x:0000D59A                 db 0FFh
.xdata$x:0000D59B                 db 0FFh
.xdata$x:0000D59C                 dd offset __unwindfunclet$??0?$_String_alloc@$0A@U?$_String_base_types@DV?$allocator@D@std@@@std@@@std@@QAE@ABV?$allocator@D@1@@Z$0
.xdata$x:0000D5A0 __ehfuncinfo$??0?$_String_alloc@$0A@U?$_String_base_types@DV?$allocator@D@std@@@std@@@std@@QAE@ABV?$allocator@D@1@@Z db  22h ; "
.xdata$x:0000D5A0                                         ; DATA XREF: __ehhandler$??0?$_String_alloc@$0A@U?$_String_base_types@DV?$allocator@D@std@@@std@@@std@@QAE@ABV?$allocator@D@1@@Z+11o
.xdata$x:0000D5A1                 db    5
.xdata$x:0000D5A2                 db  93h ; ô
.xdata$x:0000D5A3                 db  19h
.xdata$x:0000D5A4                 db    1
.xdata$x:0000D5A5                 db    0
.xdata$x:0000D5A6                 db    0
.xdata$x:0000D5A7                 db    0
.xdata$x:0000D5A8                 dd offset __unwindtable$??0?$_String_alloc@$0A@U?$_String_base_types@DV?$allocator@D@std@@@std@@@std@@QAE@ABV?$allocator@D@1@@Z
.xdata$x:0000D5AC                 db    0
.xdata$x:0000D5AD                 db    0
.xdata$x:0000D5AE                 db    0
.xdata$x:0000D5AF                 db    0
.xdata$x:0000D5B0                 db    0
.xdata$x:0000D5B1                 db    0
.xdata$x:0000D5B2                 db    0
.xdata$x:0000D5B3                 db    0
.xdata$x:0000D5B4                 db    0
.xdata$x:0000D5B5                 db    0
.xdata$x:0000D5B6                 db    0
.xdata$x:0000D5B7                 db    0
.xdata$x:0000D5B8                 db    0
.xdata$x:0000D5B9                 db    0
.xdata$x:0000D5BA                 db    0
.xdata$x:0000D5BB                 db    0
.xdata$x:0000D5BC                 db    0
.xdata$x:0000D5BD                 db    0
.xdata$x:0000D5BE                 db    0
.xdata$x:0000D5BF                 db    0
.xdata$x:0000D5C0                 db    0
.xdata$x:0000D5C1                 db    0
.xdata$x:0000D5C2                 db    0
.xdata$x:0000D5C3                 db    0
.xdata$x:0000D5C3 _xdata$x        ends
.xdata$x:0000D5C3
.xdata$x:0000D5C4 ; ===========================================================================
.xdata$x:0000D5C4
.xdata$x:0000D5C4 ; Segment type: Pure data
.xdata$x:0000D5C4 ; Segment permissions: Read
.xdata$x:0000D5C4 _xdata$x        segment dword public 'DATA' use32
.xdata$x:0000D5C4                 assume cs:_xdata$x
.xdata$x:0000D5C4                 ;org 0D5C4h
.xdata$x:0000D5C4 ; COMDAT (pick associative to section at 6E6C)
.xdata$x:0000D5C4 __unwindtable$??1?$_String_alloc@$0A@U?$_String_base_types@DV?$allocator@D@std@@@std@@@std@@QAE@XZ db 0FFh
.xdata$x:0000D5C4                                         ; DATA XREF: .xdata$x:0000D5D4o
.xdata$x:0000D5C5                 db 0FFh
.xdata$x:0000D5C6                 db 0FFh
.xdata$x:0000D5C7                 db 0FFh
.xdata$x:0000D5C8                 dd offset __unwindfunclet$??1?$_String_alloc@$0A@U?$_String_base_types@DV?$allocator@D@std@@@std@@@std@@QAE@XZ$0
.xdata$x:0000D5CC __ehfuncinfo$??1?$_String_alloc@$0A@U?$_String_base_types@DV?$allocator@D@std@@@std@@@std@@QAE@XZ db  22h ; "
.xdata$x:0000D5CC                                         ; DATA XREF: __ehhandler$??1?$_String_alloc@$0A@U?$_String_base_types@DV?$allocator@D@std@@@std@@@std@@QAE@XZ+11o
.xdata$x:0000D5CD                 db    5
.xdata$x:0000D5CE                 db  93h ; ô
.xdata$x:0000D5CF                 db  19h
.xdata$x:0000D5D0                 db    1
.xdata$x:0000D5D1                 db    0
.xdata$x:0000D5D2                 db    0
.xdata$x:0000D5D3                 db    0
.xdata$x:0000D5D4                 dd offset __unwindtable$??1?$_String_alloc@$0A@U?$_String_base_types@DV?$allocator@D@std@@@std@@@std@@QAE@XZ
.xdata$x:0000D5D8                 db    0
.xdata$x:0000D5D9                 db    0
.xdata$x:0000D5DA                 db    0
.xdata$x:0000D5DB                 db    0
.xdata$x:0000D5DC                 db    0
.xdata$x:0000D5DD                 db    0
.xdata$x:0000D5DE                 db    0
.xdata$x:0000D5DF                 db    0
.xdata$x:0000D5E0                 db    0
.xdata$x:0000D5E1                 db    0
.xdata$x:0000D5E2                 db    0
.xdata$x:0000D5E3                 db    0
.xdata$x:0000D5E4                 db    0
.xdata$x:0000D5E5                 db    0
.xdata$x:0000D5E6                 db    0
.xdata$x:0000D5E7                 db    0
.xdata$x:0000D5E8                 db    0
.xdata$x:0000D5E9                 db    0
.xdata$x:0000D5EA                 db    0
.xdata$x:0000D5EB                 db    0
.xdata$x:0000D5EC                 db    0
.xdata$x:0000D5ED                 db    0
.xdata$x:0000D5EE                 db    0
.xdata$x:0000D5EF                 db    0
.xdata$x:0000D5EF _xdata$x        ends
.xdata$x:0000D5EF
.xdata$x:0000D5F0 ; ===========================================================================
.xdata$x:0000D5F0
.xdata$x:0000D5F0 ; Segment type: Pure data
.xdata$x:0000D5F0 ; Segment permissions: Read
.xdata$x:0000D5F0 _xdata$x        segment dword public 'DATA' use32
.xdata$x:0000D5F0                 assume cs:_xdata$x
.xdata$x:0000D5F0                 ;org 0D5F0h
.xdata$x:0000D5F0 ; COMDAT (pick associative to section at 6048)
.xdata$x:0000D5F0 __unwindtable$??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@PBD@Z db 0FFh
.xdata$x:0000D5F0                                         ; DATA XREF: .xdata$x:0000D600o
.xdata$x:0000D5F1                 db 0FFh
.xdata$x:0000D5F2                 db 0FFh
.xdata$x:0000D5F3                 db 0FFh
.xdata$x:0000D5F4                 dd offset __unwindfunclet$??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@PBD@Z$0
.xdata$x:0000D5F8 __ehfuncinfo$??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@PBD@Z db  22h ; "
.xdata$x:0000D5F8                                         ; DATA XREF: __ehhandler$??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@PBD@Z+11o
.xdata$x:0000D5F9                 db    5
.xdata$x:0000D5FA                 db  93h ; ô
.xdata$x:0000D5FB                 db  19h
.xdata$x:0000D5FC                 db    1
.xdata$x:0000D5FD                 db    0
.xdata$x:0000D5FE                 db    0
.xdata$x:0000D5FF                 db    0
.xdata$x:0000D600                 dd offset __unwindtable$??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@PBD@Z
.xdata$x:0000D604                 db    0
.xdata$x:0000D605                 db    0
.xdata$x:0000D606                 db    0
.xdata$x:0000D607                 db    0
.xdata$x:0000D608                 db    0
.xdata$x:0000D609                 db    0
.xdata$x:0000D60A                 db    0
.xdata$x:0000D60B                 db    0
.xdata$x:0000D60C                 db    0
.xdata$x:0000D60D                 db    0
.xdata$x:0000D60E                 db    0
.xdata$x:0000D60F                 db    0
.xdata$x:0000D610                 db    0
.xdata$x:0000D611                 db    0
.xdata$x:0000D612                 db    0
.xdata$x:0000D613                 db    0
.xdata$x:0000D614                 db    0
.xdata$x:0000D615                 db    0
.xdata$x:0000D616                 db    0
.xdata$x:0000D617                 db    0
.xdata$x:0000D618                 db    0
.xdata$x:0000D619                 db    0
.xdata$x:0000D61A                 db    0
.xdata$x:0000D61B                 db    0
.xdata$x:0000D61B _xdata$x        ends
.xdata$x:0000D61B
.xdata$x:0000D61C ; ===========================================================================
.xdata$x:0000D61C
.xdata$x:0000D61C ; Segment type: Pure data
.xdata$x:0000D61C ; Segment permissions: Read
.xdata$x:0000D61C _xdata$x        segment dword public 'DATA' use32
.xdata$x:0000D61C                 assume cs:_xdata$x
.xdata$x:0000D61C                 ;org 0D61Ch
.xdata$x:0000D61C ; COMDAT (pick associative to section at 5FA4)
.xdata$x:0000D61C __unwindtable$??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@$$QAV01@@Z db 0FFh
.xdata$x:0000D61C                                         ; DATA XREF: .xdata$x:0000D62Co
.xdata$x:0000D61D                 db 0FFh
.xdata$x:0000D61E                 db 0FFh
.xdata$x:0000D61F                 db 0FFh
.xdata$x:0000D620                 dd offset __unwindfunclet$??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@$$QAV01@@Z$0
.xdata$x:0000D624 __ehfuncinfo$??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@$$QAV01@@Z db  22h ; "
.xdata$x:0000D624                                         ; DATA XREF: __ehhandler$??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@$$QAV01@@Z+11o
.xdata$x:0000D625                 db    5
.xdata$x:0000D626                 db  93h ; ô
.xdata$x:0000D627                 db  19h
.xdata$x:0000D628                 db    1
.xdata$x:0000D629                 db    0
.xdata$x:0000D62A                 db    0
.xdata$x:0000D62B                 db    0
.xdata$x:0000D62C                 dd offset __unwindtable$??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@$$QAV01@@Z
.xdata$x:0000D630                 db    0
.xdata$x:0000D631                 db    0
.xdata$x:0000D632                 db    0
.xdata$x:0000D633                 db    0
.xdata$x:0000D634                 db    0
.xdata$x:0000D635                 db    0
.xdata$x:0000D636                 db    0
.xdata$x:0000D637                 db    0
.xdata$x:0000D638                 db    0
.xdata$x:0000D639                 db    0
.xdata$x:0000D63A                 db    0
.xdata$x:0000D63B                 db    0
.xdata$x:0000D63C                 db    0
.xdata$x:0000D63D                 db    0
.xdata$x:0000D63E                 db    0
.xdata$x:0000D63F                 db    0
.xdata$x:0000D640                 db    0
.xdata$x:0000D641                 db    0
.xdata$x:0000D642                 db    0
.xdata$x:0000D643                 db    0
.xdata$x:0000D644                 db    0
.xdata$x:0000D645                 db    0
.xdata$x:0000D646                 db    0
.xdata$x:0000D647                 db    0
.xdata$x:0000D647 _xdata$x        ends
.xdata$x:0000D647
.xdata$x:0000D648 ; ===========================================================================
.xdata$x:0000D648
.xdata$x:0000D648 ; Segment type: Pure data
.xdata$x:0000D648 ; Segment permissions: Read
.xdata$x:0000D648 _xdata$x        segment dword public 'DATA' use32
.xdata$x:0000D648                 assume cs:_xdata$x
.xdata$x:0000D648                 ;org 0D648h
.xdata$x:0000D648 ; COMDAT (pick associative to section at 74B4)
.xdata$x:0000D648 __unwindtable$??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ db 0FFh
.xdata$x:0000D648                                         ; DATA XREF: .xdata$x:0000D658o
.xdata$x:0000D649                 db 0FFh
.xdata$x:0000D64A                 db 0FFh
.xdata$x:0000D64B                 db 0FFh
.xdata$x:0000D64C                 dd offset __unwindfunclet$??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ$0
.xdata$x:0000D650 __ehfuncinfo$??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ db  22h ; "
.xdata$x:0000D650                                         ; DATA XREF: __ehhandler$??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ+11o
.xdata$x:0000D651                 db    5
.xdata$x:0000D652                 db  93h ; ô
.xdata$x:0000D653                 db  19h
.xdata$x:0000D654                 db    1
.xdata$x:0000D655                 db    0
.xdata$x:0000D656                 db    0
.xdata$x:0000D657                 db    0
.xdata$x:0000D658                 dd offset __unwindtable$??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ
.xdata$x:0000D65C                 db    0
.xdata$x:0000D65D                 db    0
.xdata$x:0000D65E                 db    0
.xdata$x:0000D65F                 db    0
.xdata$x:0000D660                 db    0
.xdata$x:0000D661                 db    0
.xdata$x:0000D662                 db    0
.xdata$x:0000D663                 db    0
.xdata$x:0000D664                 db    0
.xdata$x:0000D665                 db    0
.xdata$x:0000D666                 db    0
.xdata$x:0000D667                 db    0
.xdata$x:0000D668                 db    0
.xdata$x:0000D669                 db    0
.xdata$x:0000D66A                 db    0
.xdata$x:0000D66B                 db    0
.xdata$x:0000D66C                 db    0
.xdata$x:0000D66D                 db    0
.xdata$x:0000D66E                 db    0
.xdata$x:0000D66F                 db    0
.xdata$x:0000D670                 db    0
.xdata$x:0000D671                 db    0
.xdata$x:0000D672                 db    0
.xdata$x:0000D673                 db    0
.xdata$x:0000D673 _xdata$x        ends
.xdata$x:0000D673
.xdata$x:0000D674 ; ===========================================================================
.xdata$x:0000D674
.xdata$x:0000D674 ; Segment type: Pure data
.xdata$x:0000D674 ; Segment permissions: Read
.xdata$x:0000D674 _xdata$x        segment dword public 'DATA' use32
.xdata$x:0000D674                 assume cs:_xdata$x
.xdata$x:0000D674                 ;org 0D674h
.xdata$x:0000D674 ; COMDAT (pick associative to section at 93B8)
.xdata$x:0000D674 __catchsym$?_Copy@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEXII@Z$5 db    0
.xdata$x:0000D674                                         ; DATA XREF: .xdata$x:0000D6FCo
.xdata$x:0000D675                 db    0
.xdata$x:0000D676                 db    0
.xdata$x:0000D677                 db    0
.xdata$x:0000D678                 db    0
.xdata$x:0000D679                 db    0
.xdata$x:0000D67A                 db    0
.xdata$x:0000D67B                 db    0
.xdata$x:0000D67C                 db    0
.xdata$x:0000D67D                 db    0
.xdata$x:0000D67E                 db    0
.xdata$x:0000D67F                 db    0
.xdata$x:0000D680                 dd offset __catch$?_Copy@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEXII@Z$0
.xdata$x:0000D684 __catchsym$?_Copy@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEXII@Z$4 db    0
.xdata$x:0000D684                                         ; DATA XREF: .xdata$x:0000D6E8o
.xdata$x:0000D685                 db    0
.xdata$x:0000D686                 db    0
.xdata$x:0000D687                 db    0
.xdata$x:0000D688                 db    0
.xdata$x:0000D689                 db    0
.xdata$x:0000D68A                 db    0
.xdata$x:0000D68B                 db    0
.xdata$x:0000D68C                 db    0
.xdata$x:0000D68D                 db    0
.xdata$x:0000D68E                 db    0
.xdata$x:0000D68F                 db    0
.xdata$x:0000D690                 dd offset __catch$?_Copy@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEXII@Z$1
.xdata$x:0000D694 __unwindtable$?_Copy@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEXII@Z db 0FFh
.xdata$x:0000D694                                         ; DATA XREF: .xdata$x:0000D6BCo
.xdata$x:0000D695                 db 0FFh
.xdata$x:0000D696                 db 0FFh
.xdata$x:0000D697                 db 0FFh
.xdata$x:0000D698                 db    0
.xdata$x:0000D699                 db    0
.xdata$x:0000D69A                 db    0
.xdata$x:0000D69B                 db    0
.xdata$x:0000D69C                 db 0FFh
.xdata$x:0000D69D                 db 0FFh
.xdata$x:0000D69E                 db 0FFh
.xdata$x:0000D69F                 db 0FFh
.xdata$x:0000D6A0                 db    0
.xdata$x:0000D6A1                 db    0
.xdata$x:0000D6A2                 db    0
.xdata$x:0000D6A3                 db    0
.xdata$x:0000D6A4                 db    1
.xdata$x:0000D6A5                 db    0
.xdata$x:0000D6A6                 db    0
.xdata$x:0000D6A7                 db    0
.xdata$x:0000D6A8                 db    0
.xdata$x:0000D6A9                 db    0
.xdata$x:0000D6AA                 db    0
.xdata$x:0000D6AB                 db    0
.xdata$x:0000D6AC                 db    1
.xdata$x:0000D6AD                 db    0
.xdata$x:0000D6AE                 db    0
.xdata$x:0000D6AF                 db    0
.xdata$x:0000D6B0                 db    0
.xdata$x:0000D6B1                 db    0
.xdata$x:0000D6B2                 db    0
.xdata$x:0000D6B3                 db    0
.xdata$x:0000D6B4 __ehfuncinfo$?_Copy@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEXII@Z db  22h ; "
.xdata$x:0000D6B4                                         ; DATA XREF: __ehhandler$?_Copy@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEXII@Z+11o
.xdata$x:0000D6B5                 db    5
.xdata$x:0000D6B6                 db  93h ; ô
.xdata$x:0000D6B7                 db  19h
.xdata$x:0000D6B8                 db    4
.xdata$x:0000D6B9                 db    0
.xdata$x:0000D6BA                 db    0
.xdata$x:0000D6BB                 db    0
.xdata$x:0000D6BC                 dd offset __unwindtable$?_Copy@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEXII@Z
.xdata$x:0000D6C0                 db    2
.xdata$x:0000D6C1                 db    0
.xdata$x:0000D6C2                 db    0
.xdata$x:0000D6C3                 db    0
.xdata$x:0000D6C4                 dd offset __tryblocktable$?_Copy@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEXII@Z
.xdata$x:0000D6C8                 db    0
.xdata$x:0000D6C9                 db    0
.xdata$x:0000D6CA                 db    0
.xdata$x:0000D6CB                 db    0
.xdata$x:0000D6CC                 db    0
.xdata$x:0000D6CD                 db    0
.xdata$x:0000D6CE                 db    0
.xdata$x:0000D6CF                 db    0
.xdata$x:0000D6D0                 db    0
.xdata$x:0000D6D1                 db    0
.xdata$x:0000D6D2                 db    0
.xdata$x:0000D6D3                 db    0
.xdata$x:0000D6D4                 db    0
.xdata$x:0000D6D5                 db    0
.xdata$x:0000D6D6                 db    0
.xdata$x:0000D6D7                 db    0
.xdata$x:0000D6D8 __tryblocktable$?_Copy@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEXII@Z db    2
.xdata$x:0000D6D8                                         ; DATA XREF: .xdata$x:0000D6C4o
.xdata$x:0000D6D9                 db    0
.xdata$x:0000D6DA                 db    0
.xdata$x:0000D6DB                 db    0
.xdata$x:0000D6DC                 db    2
.xdata$x:0000D6DD                 db    0
.xdata$x:0000D6DE                 db    0
.xdata$x:0000D6DF                 db    0
.xdata$x:0000D6E0                 db    3
.xdata$x:0000D6E1                 db    0
.xdata$x:0000D6E2                 db    0
.xdata$x:0000D6E3                 db    0
.xdata$x:0000D6E4                 db    1
.xdata$x:0000D6E5                 db    0
.xdata$x:0000D6E6                 db    0
.xdata$x:0000D6E7                 db    0
.xdata$x:0000D6E8                 dd offset __catchsym$?_Copy@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEXII@Z$4
.xdata$x:0000D6EC                 db    0
.xdata$x:0000D6ED                 db    0
.xdata$x:0000D6EE                 db    0
.xdata$x:0000D6EF                 db    0
.xdata$x:0000D6F0                 db    0
.xdata$x:0000D6F1                 db    0
.xdata$x:0000D6F2                 db    0
.xdata$x:0000D6F3                 db    0
.xdata$x:0000D6F4                 db    3
.xdata$x:0000D6F5                 db    0
.xdata$x:0000D6F6                 db    0
.xdata$x:0000D6F7                 db    0
.xdata$x:0000D6F8                 db    1
.xdata$x:0000D6F9                 db    0
.xdata$x:0000D6FA                 db    0
.xdata$x:0000D6FB                 db    0
.xdata$x:0000D6FC                 dd offset __catchsym$?_Copy@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEXII@Z$5
.xdata$x:0000D6FC _xdata$x        ends
.xdata$x:0000D6FC
.xdata$x:0000D700 ; ===========================================================================
.xdata$x:0000D700
.xdata$x:0000D700 ; Segment type: Pure data
.xdata$x:0000D700 ; Segment permissions: Read
.xdata$x:0000D700 _xdata$x        segment dword public 'DATA' use32
.xdata$x:0000D700                 assume cs:_xdata$x
.xdata$x:0000D700                 ;org 0D700h
.xdata$x:0000D700 ; COMDAT (pick associative to section at 6BA8)
.xdata$x:0000D700 __unwindtable$??0invalid_argument@std@@QAE@PBD@Z db 0FFh
.xdata$x:0000D700                                         ; DATA XREF: .xdata$x:0000D710o
.xdata$x:0000D701                 db 0FFh
.xdata$x:0000D702                 db 0FFh
.xdata$x:0000D703                 db 0FFh
.xdata$x:0000D704                 dd offset __unwindfunclet$??0invalid_argument@std@@QAE@PBD@Z$0
.xdata$x:0000D708 __ehfuncinfo$??0invalid_argument@std@@QAE@PBD@Z db  22h ; "
.xdata$x:0000D708                                         ; DATA XREF: __ehhandler$??0invalid_argument@std@@QAE@PBD@Z+11o
.xdata$x:0000D709                 db    5
.xdata$x:0000D70A                 db  93h ; ô
.xdata$x:0000D70B                 db  19h
.xdata$x:0000D70C                 db    1
.xdata$x:0000D70D                 db    0
.xdata$x:0000D70E                 db    0
.xdata$x:0000D70F                 db    0
.xdata$x:0000D710                 dd offset __unwindtable$??0invalid_argument@std@@QAE@PBD@Z
.xdata$x:0000D714                 db    0
.xdata$x:0000D715                 db    0
.xdata$x:0000D716                 db    0
.xdata$x:0000D717                 db    0
.xdata$x:0000D718                 db    0
.xdata$x:0000D719                 db    0
.xdata$x:0000D71A                 db    0
.xdata$x:0000D71B                 db    0
.xdata$x:0000D71C                 db    0
.xdata$x:0000D71D                 db    0
.xdata$x:0000D71E                 db    0
.xdata$x:0000D71F                 db    0
.xdata$x:0000D720                 db    0
.xdata$x:0000D721                 db    0
.xdata$x:0000D722                 db    0
.xdata$x:0000D723                 db    0
.xdata$x:0000D724                 db    0
.xdata$x:0000D725                 db    0
.xdata$x:0000D726                 db    0
.xdata$x:0000D727                 db    0
.xdata$x:0000D728                 db    0
.xdata$x:0000D729                 db    0
.xdata$x:0000D72A                 db    0
.xdata$x:0000D72B                 db    0
.xdata$x:0000D72B _xdata$x        ends
.xdata$x:0000D72B
.xdata$x:0000D72C ; ===========================================================================
.xdata$x:0000D72C
.xdata$x:0000D72C ; Segment type: Pure data
.xdata$x:0000D72C ; Segment permissions: Read
.xdata$x:0000D72C _xdata$x        segment dword public 'DATA' use32
.xdata$x:0000D72C                 assume cs:_xdata$x
.xdata$x:0000D72C                 ;org 0D72Ch
.xdata$x:0000D72C ; COMDAT (pick associative to section at 7980)
.xdata$x:0000D72C __unwindtable$??1invalid_argument@std@@UAE@XZ db 0FFh
.xdata$x:0000D72C                                         ; DATA XREF: .xdata$x:0000D73Co
.xdata$x:0000D72D                 db 0FFh
.xdata$x:0000D72E                 db 0FFh
.xdata$x:0000D72F                 db 0FFh
.xdata$x:0000D730                 dd offset __unwindfunclet$??1invalid_argument@std@@UAE@XZ$0
.xdata$x:0000D734 __ehfuncinfo$??1invalid_argument@std@@UAE@XZ db  22h ; "
.xdata$x:0000D734                                         ; DATA XREF: __ehhandler$??1invalid_argument@std@@UAE@XZ+11o
.xdata$x:0000D735                 db    5
.xdata$x:0000D736                 db  93h ; ô
.xdata$x:0000D737                 db  19h
.xdata$x:0000D738                 db    1
.xdata$x:0000D739                 db    0
.xdata$x:0000D73A                 db    0
.xdata$x:0000D73B                 db    0
.xdata$x:0000D73C                 dd offset __unwindtable$??1invalid_argument@std@@UAE@XZ
.xdata$x:0000D740                 db    0
.xdata$x:0000D741                 db    0
.xdata$x:0000D742                 db    0
.xdata$x:0000D743                 db    0
.xdata$x:0000D744                 db    0
.xdata$x:0000D745                 db    0
.xdata$x:0000D746                 db    0
.xdata$x:0000D747                 db    0
.xdata$x:0000D748                 db    0
.xdata$x:0000D749                 db    0
.xdata$x:0000D74A                 db    0
.xdata$x:0000D74B                 db    0
.xdata$x:0000D74C                 db    0
.xdata$x:0000D74D                 db    0
.xdata$x:0000D74E                 db    0
.xdata$x:0000D74F                 db    0
.xdata$x:0000D750                 db    0
.xdata$x:0000D751                 db    0
.xdata$x:0000D752                 db    0
.xdata$x:0000D753                 db    0
.xdata$x:0000D754                 db    0
.xdata$x:0000D755                 db    0
.xdata$x:0000D756                 db    0
.xdata$x:0000D757                 db    0
.xdata$x:0000D757 _xdata$x        ends
.xdata$x:0000D757
.xdata$x:0000D758 ; ===========================================================================
.xdata$x:0000D758
.xdata$x:0000D758 ; Segment type: Pure data
.xdata$x:0000D758 ; Segment permissions: Read
.xdata$x:0000D758 _xdata$x        segment dword public 'DATA' use32
.xdata$x:0000D758                 assume cs:_xdata$x
.xdata$x:0000D758                 ;org 0D758h
.xdata$x:0000D758 ; COMDAT (pick associative to section at 6CB0)
.xdata$x:0000D758 __unwindtable$??0out_of_range@std@@QAE@PBD@Z db 0FFh
.xdata$x:0000D758                                         ; DATA XREF: .xdata$x:0000D768o
.xdata$x:0000D759                 db 0FFh
.xdata$x:0000D75A                 db 0FFh
.xdata$x:0000D75B                 db 0FFh
.xdata$x:0000D75C                 dd offset __unwindfunclet$??0out_of_range@std@@QAE@PBD@Z$0
.xdata$x:0000D760 __ehfuncinfo$??0out_of_range@std@@QAE@PBD@Z db  22h ; "
.xdata$x:0000D760                                         ; DATA XREF: __ehhandler$??0out_of_range@std@@QAE@PBD@Z+11o
.xdata$x:0000D761                 db    5
.xdata$x:0000D762                 db  93h ; ô
.xdata$x:0000D763                 db  19h
.xdata$x:0000D764                 db    1
.xdata$x:0000D765                 db    0
.xdata$x:0000D766                 db    0
.xdata$x:0000D767                 db    0
.xdata$x:0000D768                 dd offset __unwindtable$??0out_of_range@std@@QAE@PBD@Z
.xdata$x:0000D76C                 db    0
.xdata$x:0000D76D                 db    0
.xdata$x:0000D76E                 db    0
.xdata$x:0000D76F                 db    0
.xdata$x:0000D770                 db    0
.xdata$x:0000D771                 db    0
.xdata$x:0000D772                 db    0
.xdata$x:0000D773                 db    0
.xdata$x:0000D774                 db    0
.xdata$x:0000D775                 db    0
.xdata$x:0000D776                 db    0
.xdata$x:0000D777                 db    0
.xdata$x:0000D778                 db    0
.xdata$x:0000D779                 db    0
.xdata$x:0000D77A                 db    0
.xdata$x:0000D77B                 db    0
.xdata$x:0000D77C                 db    0
.xdata$x:0000D77D                 db    0
.xdata$x:0000D77E                 db    0
.xdata$x:0000D77F                 db    0
.xdata$x:0000D780                 db    0
.xdata$x:0000D781                 db    0
.xdata$x:0000D782                 db    0
.xdata$x:0000D783                 db    0
.xdata$x:0000D783 _xdata$x        ends
.xdata$x:0000D783
.xdata$x:0000D784 ; ===========================================================================
.xdata$x:0000D784
.xdata$x:0000D784 ; Segment type: Pure data
.xdata$x:0000D784 ; Segment permissions: Read
.xdata$x:0000D784 _xdata$x        segment dword public 'DATA' use32
.xdata$x:0000D784                 assume cs:_xdata$x
.xdata$x:0000D784                 ;org 0D784h
.xdata$x:0000D784 ; COMDAT (pick associative to section at 7A60)
.xdata$x:0000D784 __unwindtable$??1out_of_range@std@@UAE@XZ db 0FFh
.xdata$x:0000D784                                         ; DATA XREF: .xdata$x:0000D794o
.xdata$x:0000D785                 db 0FFh
.xdata$x:0000D786                 db 0FFh
.xdata$x:0000D787                 db 0FFh
.xdata$x:0000D788                 dd offset __unwindfunclet$??1out_of_range@std@@UAE@XZ$0
.xdata$x:0000D78C __ehfuncinfo$??1out_of_range@std@@UAE@XZ db  22h ; "
.xdata$x:0000D78C                                         ; DATA XREF: __ehhandler$??1out_of_range@std@@UAE@XZ+11o
.xdata$x:0000D78D                 db    5
.xdata$x:0000D78E                 db  93h ; ô
.xdata$x:0000D78F                 db  19h
.xdata$x:0000D790                 db    1
.xdata$x:0000D791                 db    0
.xdata$x:0000D792                 db    0
.xdata$x:0000D793                 db    0
.xdata$x:0000D794                 dd offset __unwindtable$??1out_of_range@std@@UAE@XZ
.xdata$x:0000D798                 db    0
.xdata$x:0000D799                 db    0
.xdata$x:0000D79A                 db    0
.xdata$x:0000D79B                 db    0
.xdata$x:0000D79C                 db    0
.xdata$x:0000D79D                 db    0
.xdata$x:0000D79E                 db    0
.xdata$x:0000D79F                 db    0
.xdata$x:0000D7A0                 db    0
.xdata$x:0000D7A1                 db    0
.xdata$x:0000D7A2                 db    0
.xdata$x:0000D7A3                 db    0
.xdata$x:0000D7A4                 db    0
.xdata$x:0000D7A5                 db    0
.xdata$x:0000D7A6                 db    0
.xdata$x:0000D7A7                 db    0
.xdata$x:0000D7A8                 db    0
.xdata$x:0000D7A9                 db    0
.xdata$x:0000D7AA                 db    0
.xdata$x:0000D7AB                 db    0
.xdata$x:0000D7AC                 db    0
.xdata$x:0000D7AD                 db    0
.xdata$x:0000D7AE                 db    0
.xdata$x:0000D7AF                 db    0
.xdata$x:0000D7AF _xdata$x        ends
.xdata$x:0000D7AF
.xdata$x:0000D7B0 ; ===========================================================================
.xdata$x:0000D7B0
.xdata$x:0000D7B0 ; Segment type: Pure data
.xdata$x:0000D7B0 ; Segment permissions: Read
.xdata$x:0000D7B0 _xdata$x        segment dword public 'DATA' use32
.xdata$x:0000D7B0                 assume cs:_xdata$x
.xdata$x:0000D7B0                 ;org 0D7B0h
.xdata$x:0000D7B0 ; COMDAT (pick associative to section at 698C)
.xdata$x:0000D7B0 __unwindtable$??0_Generic_error_category@std@@QAE@XZ db 0FFh
.xdata$x:0000D7B0                                         ; DATA XREF: .xdata$x:0000D7C0o
.xdata$x:0000D7B1                 db 0FFh
.xdata$x:0000D7B2                 db 0FFh
.xdata$x:0000D7B3                 db 0FFh
.xdata$x:0000D7B4                 dd offset __unwindfunclet$??0_Generic_error_category@std@@QAE@XZ$0
.xdata$x:0000D7B8 __ehfuncinfo$??0_Generic_error_category@std@@QAE@XZ db  22h ; "
.xdata$x:0000D7B8                                         ; DATA XREF: __ehhandler$??0_Generic_error_category@std@@QAE@XZ+11o
.xdata$x:0000D7B9                 db    5
.xdata$x:0000D7BA                 db  93h ; ô
.xdata$x:0000D7BB                 db  19h
.xdata$x:0000D7BC                 db    1
.xdata$x:0000D7BD                 db    0
.xdata$x:0000D7BE                 db    0
.xdata$x:0000D7BF                 db    0
.xdata$x:0000D7C0                 dd offset __unwindtable$??0_Generic_error_category@std@@QAE@XZ
.xdata$x:0000D7C4                 db    0
.xdata$x:0000D7C5                 db    0
.xdata$x:0000D7C6                 db    0
.xdata$x:0000D7C7                 db    0
.xdata$x:0000D7C8                 db    0
.xdata$x:0000D7C9                 db    0
.xdata$x:0000D7CA                 db    0
.xdata$x:0000D7CB                 db    0
.xdata$x:0000D7CC                 db    0
.xdata$x:0000D7CD                 db    0
.xdata$x:0000D7CE                 db    0
.xdata$x:0000D7CF                 db    0
.xdata$x:0000D7D0                 db    0
.xdata$x:0000D7D1                 db    0
.xdata$x:0000D7D2                 db    0
.xdata$x:0000D7D3                 db    0
.xdata$x:0000D7D4                 db    0
.xdata$x:0000D7D5                 db    0
.xdata$x:0000D7D6                 db    0
.xdata$x:0000D7D7                 db    0
.xdata$x:0000D7D8                 db    0
.xdata$x:0000D7D9                 db    0
.xdata$x:0000D7DA                 db    0
.xdata$x:0000D7DB                 db    0
.xdata$x:0000D7DB _xdata$x        ends
.xdata$x:0000D7DB
.xdata$x:0000D7DC ; ===========================================================================
.xdata$x:0000D7DC
.xdata$x:0000D7DC ; Segment type: Pure data
.xdata$x:0000D7DC ; Segment permissions: Read
.xdata$x:0000D7DC _xdata$x        segment dword public 'DATA' use32
.xdata$x:0000D7DC                 assume cs:_xdata$x
.xdata$x:0000D7DC                 ;org 0D7DCh
.xdata$x:0000D7DC ; COMDAT (pick associative to section at C3FC)
.xdata$x:0000D7DC __unwindtable$?message@_Generic_error_category@std@@UBE?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@2@H@Z db 0FFh
.xdata$x:0000D7DC                                         ; DATA XREF: .xdata$x:0000D7ECo
.xdata$x:0000D7DD                 db 0FFh
.xdata$x:0000D7DE                 db 0FFh
.xdata$x:0000D7DF                 db 0FFh
.xdata$x:0000D7E0                 dd offset __unwindfunclet$?message@_Generic_error_category@std@@UBE?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@2@H@Z$0
.xdata$x:0000D7E4 __ehfuncinfo$?message@_Generic_error_category@std@@UBE?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@2@H@Z db  22h ; "
.xdata$x:0000D7E4                                         ; DATA XREF: __ehhandler$?message@_Generic_error_category@std@@UBE?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@2@H@Z+11o
.xdata$x:0000D7E5                 db    5
.xdata$x:0000D7E6                 db  93h ; ô
.xdata$x:0000D7E7                 db  19h
.xdata$x:0000D7E8                 db    1
.xdata$x:0000D7E9                 db    0
.xdata$x:0000D7EA                 db    0
.xdata$x:0000D7EB                 db    0
.xdata$x:0000D7EC                 dd offset __unwindtable$?message@_Generic_error_category@std@@UBE?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@2@H@Z
.xdata$x:0000D7F0                 db    0
.xdata$x:0000D7F1                 db    0
.xdata$x:0000D7F2                 db    0
.xdata$x:0000D7F3                 db    0
.xdata$x:0000D7F4                 db    0
.xdata$x:0000D7F5                 db    0
.xdata$x:0000D7F6                 db    0
.xdata$x:0000D7F7                 db    0
.xdata$x:0000D7F8                 db    0
.xdata$x:0000D7F9                 db    0
.xdata$x:0000D7FA                 db    0
.xdata$x:0000D7FB                 db    0
.xdata$x:0000D7FC                 db    0
.xdata$x:0000D7FD                 db    0
.xdata$x:0000D7FE                 db    0
.xdata$x:0000D7FF                 db    0
.xdata$x:0000D800                 db    0
.xdata$x:0000D801                 db    0
.xdata$x:0000D802                 db    0
.xdata$x:0000D803                 db    0
.xdata$x:0000D804                 db    0
.xdata$x:0000D805                 db    0
.xdata$x:0000D806                 db    0
.xdata$x:0000D807                 db    0
.xdata$x:0000D807 _xdata$x        ends
.xdata$x:0000D807
.xdata$x:0000D808 ; ===========================================================================
.xdata$x:0000D808
.xdata$x:0000D808 ; Segment type: Pure data
.xdata$x:0000D808 ; Segment permissions: Read
.xdata$x:0000D808 _xdata$x        segment dword public 'DATA' use32
.xdata$x:0000D808                 assume cs:_xdata$x
.xdata$x:0000D808                 ;org 0D808h
.xdata$x:0000D808 ; COMDAT (pick associative to section at 7798)
.xdata$x:0000D808 __unwindtable$??1_Generic_error_category@std@@UAE@XZ db 0FFh
.xdata$x:0000D808                                         ; DATA XREF: .xdata$x:0000D818o
.xdata$x:0000D809                 db 0FFh
.xdata$x:0000D80A                 db 0FFh
.xdata$x:0000D80B                 db 0FFh
.xdata$x:0000D80C                 dd offset __unwindfunclet$??1_Generic_error_category@std@@UAE@XZ$0
.xdata$x:0000D810 __ehfuncinfo$??1_Generic_error_category@std@@UAE@XZ db  22h ; "
.xdata$x:0000D810                                         ; DATA XREF: __ehhandler$??1_Generic_error_category@std@@UAE@XZ+11o
.xdata$x:0000D811                 db    5
.xdata$x:0000D812                 db  93h ; ô
.xdata$x:0000D813                 db  19h
.xdata$x:0000D814                 db    1
.xdata$x:0000D815                 db    0
.xdata$x:0000D816                 db    0
.xdata$x:0000D817                 db    0
.xdata$x:0000D818                 dd offset __unwindtable$??1_Generic_error_category@std@@UAE@XZ
.xdata$x:0000D81C                 db    0
.xdata$x:0000D81D                 db    0
.xdata$x:0000D81E                 db    0
.xdata$x:0000D81F                 db    0
.xdata$x:0000D820                 db    0
.xdata$x:0000D821                 db    0
.xdata$x:0000D822                 db    0
.xdata$x:0000D823                 db    0
.xdata$x:0000D824                 db    0
.xdata$x:0000D825                 db    0
.xdata$x:0000D826                 db    0
.xdata$x:0000D827                 db    0
.xdata$x:0000D828                 db    0
.xdata$x:0000D829                 db    0
.xdata$x:0000D82A                 db    0
.xdata$x:0000D82B                 db    0
.xdata$x:0000D82C                 db    0
.xdata$x:0000D82D                 db    0
.xdata$x:0000D82E                 db    0
.xdata$x:0000D82F                 db    0
.xdata$x:0000D830                 db    0
.xdata$x:0000D831                 db    0
.xdata$x:0000D832                 db    0
.xdata$x:0000D833                 db    0
.xdata$x:0000D833 _xdata$x        ends
.xdata$x:0000D833
.xdata$x:0000D834 ; ===========================================================================
.xdata$x:0000D834
.xdata$x:0000D834 ; Segment type: Pure data
.xdata$x:0000D834 ; Segment permissions: Read
.xdata$x:0000D834 _xdata$x        segment dword public 'DATA' use32
.xdata$x:0000D834                 assume cs:_xdata$x
.xdata$x:0000D834                 ;org 0D834h
.xdata$x:0000D834 ; COMDAT (pick associative to section at 6A08)
.xdata$x:0000D834 __unwindtable$??0_Iostream_error_category@std@@QAE@XZ db 0FFh
.xdata$x:0000D834                                         ; DATA XREF: .xdata$x:0000D844o
.xdata$x:0000D835                 db 0FFh
.xdata$x:0000D836                 db 0FFh
.xdata$x:0000D837                 db 0FFh
.xdata$x:0000D838                 dd offset __unwindfunclet$??0_Iostream_error_category@std@@QAE@XZ$0
.xdata$x:0000D83C __ehfuncinfo$??0_Iostream_error_category@std@@QAE@XZ db  22h ; "
.xdata$x:0000D83C                                         ; DATA XREF: __ehhandler$??0_Iostream_error_category@std@@QAE@XZ+11o
.xdata$x:0000D83D                 db    5
.xdata$x:0000D83E                 db  93h ; ô
.xdata$x:0000D83F                 db  19h
.xdata$x:0000D840                 db    1
.xdata$x:0000D841                 db    0
.xdata$x:0000D842                 db    0
.xdata$x:0000D843                 db    0
.xdata$x:0000D844                 dd offset __unwindtable$??0_Iostream_error_category@std@@QAE@XZ
.xdata$x:0000D848                 align 20h
.xdata$x:0000D848 _xdata$x        ends
.xdata$x:0000D848
.xdata$x:0000D860 ; ===========================================================================
.xdata$x:0000D860
.xdata$x:0000D860 ; Segment type: Pure data
.xdata$x:0000D860 ; Segment permissions: Read
.xdata$x:0000D860 _xdata$x        segment dword public 'DATA' use32
.xdata$x:0000D860                 assume cs:_xdata$x
.xdata$x:0000D860                 ;org 0D860h
.xdata$x:0000D860 ; COMDAT (pick associative to section at C4B4)
.xdata$x:0000D860 __unwindtable$?message@_Iostream_error_category@std@@UBE?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@2@H@Z db 0FFh
.xdata$x:0000D860                                         ; DATA XREF: .xdata$x:0000D870o
.xdata$x:0000D861                 db 0FFh
.xdata$x:0000D862                 db 0FFh
.xdata$x:0000D863                 db 0FFh
.xdata$x:0000D864                 dd offset __unwindfunclet$?message@_Iostream_error_category@std@@UBE?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@2@H@Z$0
.xdata$x:0000D868 __ehfuncinfo$?message@_Iostream_error_category@std@@UBE?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@2@H@Z db  22h ; "
.xdata$x:0000D868                                         ; DATA XREF: __ehhandler$?message@_Iostream_error_category@std@@UBE?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@2@H@Z+11o
.xdata$x:0000D869                 db    5
.xdata$x:0000D86A                 db  93h ; ô
.xdata$x:0000D86B                 db  19h
.xdata$x:0000D86C                 db    1
.xdata$x:0000D86D                 db    0
.xdata$x:0000D86E                 db    0
.xdata$x:0000D86F                 db    0
.xdata$x:0000D870                 dd offset __unwindtable$?message@_Iostream_error_category@std@@UBE?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@2@H@Z
.xdata$x:0000D874                 db    0
.xdata$x:0000D875                 db    0
.xdata$x:0000D876                 db    0
.xdata$x:0000D877                 db    0
.xdata$x:0000D878                 db    0
.xdata$x:0000D879                 db    0
.xdata$x:0000D87A                 db    0
.xdata$x:0000D87B                 db    0
.xdata$x:0000D87C                 db    0
.xdata$x:0000D87D                 db    0
.xdata$x:0000D87E                 db    0
.xdata$x:0000D87F                 db    0
.xdata$x:0000D880                 db    0
.xdata$x:0000D881                 db    0
.xdata$x:0000D882                 db    0
.xdata$x:0000D883                 db    0
.xdata$x:0000D884                 db    0
.xdata$x:0000D885                 db    0
.xdata$x:0000D886                 db    0
.xdata$x:0000D887                 db    0
.xdata$x:0000D888                 db    0
.xdata$x:0000D889                 db    0
.xdata$x:0000D88A                 db    0
.xdata$x:0000D88B                 db    0
.xdata$x:0000D88B _xdata$x        ends
.xdata$x:0000D88B
.xdata$x:0000D88C ; ===========================================================================
.xdata$x:0000D88C
.xdata$x:0000D88C ; Segment type: Pure data
.xdata$x:0000D88C ; Segment permissions: Read
.xdata$x:0000D88C _xdata$x        segment dword public 'DATA' use32
.xdata$x:0000D88C                 assume cs:_xdata$x
.xdata$x:0000D88C                 ;org 0D88Ch
.xdata$x:0000D88C ; COMDAT (pick associative to section at 7808)
.xdata$x:0000D88C __unwindtable$??1_Iostream_error_category@std@@UAE@XZ db 0FFh
.xdata$x:0000D88C                                         ; DATA XREF: .xdata$x:0000D89Co
.xdata$x:0000D88D                 db 0FFh
.xdata$x:0000D88E                 db 0FFh
.xdata$x:0000D88F                 db 0FFh
.xdata$x:0000D890                 dd offset __unwindfunclet$??1_Iostream_error_category@std@@UAE@XZ$0
.xdata$x:0000D894 __ehfuncinfo$??1_Iostream_error_category@std@@UAE@XZ db  22h ; "
.xdata$x:0000D894                                         ; DATA XREF: __ehhandler$??1_Iostream_error_category@std@@UAE@XZ+11o
.xdata$x:0000D895                 db    5
.xdata$x:0000D896                 db  93h ; ô
.xdata$x:0000D897                 db  19h
.xdata$x:0000D898                 db    1
.xdata$x:0000D899                 db    0
.xdata$x:0000D89A                 db    0
.xdata$x:0000D89B                 db    0
.xdata$x:0000D89C                 dd offset __unwindtable$??1_Iostream_error_category@std@@UAE@XZ
.xdata$x:0000D8A0                 db    0
.xdata$x:0000D8A1                 db    0
.xdata$x:0000D8A2                 db    0
.xdata$x:0000D8A3                 db    0
.xdata$x:0000D8A4                 db    0
.xdata$x:0000D8A5                 db    0
.xdata$x:0000D8A6                 db    0
.xdata$x:0000D8A7                 db    0
.xdata$x:0000D8A8                 db    0
.xdata$x:0000D8A9                 db    0
.xdata$x:0000D8AA                 db    0
.xdata$x:0000D8AB                 db    0
.xdata$x:0000D8AC                 db    0
.xdata$x:0000D8AD                 db    0
.xdata$x:0000D8AE                 db    0
.xdata$x:0000D8AF                 db    0
.xdata$x:0000D8B0                 db    0
.xdata$x:0000D8B1                 db    0
.xdata$x:0000D8B2                 db    0
.xdata$x:0000D8B3                 db    0
.xdata$x:0000D8B4                 db    0
.xdata$x:0000D8B5                 db    0
.xdata$x:0000D8B6                 db    0
.xdata$x:0000D8B7                 db    0
.xdata$x:0000D8B7 _xdata$x        ends
.xdata$x:0000D8B7
.xdata$x:0000D8B8 ; ===========================================================================
.xdata$x:0000D8B8
.xdata$x:0000D8B8 ; Segment type: Pure data
.xdata$x:0000D8B8 ; Segment permissions: Read
.xdata$x:0000D8B8 _xdata$x        segment dword public 'DATA' use32
.xdata$x:0000D8B8                 assume cs:_xdata$x
.xdata$x:0000D8B8                 ;org 0D8B8h
.xdata$x:0000D8B8 ; COMDAT (pick associative to section at 6AD8)
.xdata$x:0000D8B8 __unwindtable$??0_System_error_category@std@@QAE@XZ db 0FFh
.xdata$x:0000D8B8                                         ; DATA XREF: .xdata$x:0000D8C8o
.xdata$x:0000D8B9                 db 0FFh
.xdata$x:0000D8BA                 db 0FFh
.xdata$x:0000D8BB                 db 0FFh
.xdata$x:0000D8BC                 dd offset __unwindfunclet$??0_System_error_category@std@@QAE@XZ$0
.xdata$x:0000D8C0 __ehfuncinfo$??0_System_error_category@std@@QAE@XZ db  22h ; "
.xdata$x:0000D8C0                                         ; DATA XREF: __ehhandler$??0_System_error_category@std@@QAE@XZ+11o
.xdata$x:0000D8C1                 db    5
.xdata$x:0000D8C2                 db  93h ; ô
.xdata$x:0000D8C3                 db  19h
.xdata$x:0000D8C4                 db    1
.xdata$x:0000D8C5                 db    0
.xdata$x:0000D8C6                 db    0
.xdata$x:0000D8C7                 db    0
.xdata$x:0000D8C8                 dd offset __unwindtable$??0_System_error_category@std@@QAE@XZ
.xdata$x:0000D8CC                 db    0
.xdata$x:0000D8CD                 db    0
.xdata$x:0000D8CE                 db    0
.xdata$x:0000D8CF                 db    0
.xdata$x:0000D8D0                 db    0
.xdata$x:0000D8D1                 db    0
.xdata$x:0000D8D2                 db    0
.xdata$x:0000D8D3                 db    0
.xdata$x:0000D8D4                 db    0
.xdata$x:0000D8D5                 db    0
.xdata$x:0000D8D6                 db    0
.xdata$x:0000D8D7                 db    0
.xdata$x:0000D8D8                 db    0
.xdata$x:0000D8D9                 db    0
.xdata$x:0000D8DA                 db    0
.xdata$x:0000D8DB                 db    0
.xdata$x:0000D8DC                 db    0
.xdata$x:0000D8DD                 db    0
.xdata$x:0000D8DE                 db    0
.xdata$x:0000D8DF                 db    0
.xdata$x:0000D8E0                 db    0
.xdata$x:0000D8E1                 db    0
.xdata$x:0000D8E2                 db    0
.xdata$x:0000D8E3                 db    0
.xdata$x:0000D8E3 _xdata$x        ends
.xdata$x:0000D8E3
.xdata$x:0000D8E4 ; ===========================================================================
.xdata$x:0000D8E4
.xdata$x:0000D8E4 ; Segment type: Pure data
.xdata$x:0000D8E4 ; Segment permissions: Read
.xdata$x:0000D8E4 _xdata$x        segment dword public 'DATA' use32
.xdata$x:0000D8E4                 assume cs:_xdata$x
.xdata$x:0000D8E4                 ;org 0D8E4h
.xdata$x:0000D8E4 ; COMDAT (pick associative to section at C578)
.xdata$x:0000D8E4 __unwindtable$?message@_System_error_category@std@@UBE?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@2@H@Z db 0FFh
.xdata$x:0000D8E4                                         ; DATA XREF: .xdata$x:0000D8F4o
.xdata$x:0000D8E5                 db 0FFh
.xdata$x:0000D8E6                 db 0FFh
.xdata$x:0000D8E7                 db 0FFh
.xdata$x:0000D8E8                 dd offset __unwindfunclet$?message@_System_error_category@std@@UBE?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@2@H@Z$0
.xdata$x:0000D8EC __ehfuncinfo$?message@_System_error_category@std@@UBE?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@2@H@Z db  22h ; "
.xdata$x:0000D8EC                                         ; DATA XREF: __ehhandler$?message@_System_error_category@std@@UBE?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@2@H@Z+11o
.xdata$x:0000D8ED                 db    5
.xdata$x:0000D8EE                 db  93h ; ô
.xdata$x:0000D8EF                 db  19h
.xdata$x:0000D8F0                 db    1
.xdata$x:0000D8F1                 db    0
.xdata$x:0000D8F2                 db    0
.xdata$x:0000D8F3                 db    0
.xdata$x:0000D8F4                 dd offset __unwindtable$?message@_System_error_category@std@@UBE?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@2@H@Z
.xdata$x:0000D8F8                 db    0
.xdata$x:0000D8F9                 db    0
.xdata$x:0000D8FA                 db    0
.xdata$x:0000D8FB                 db    0
.xdata$x:0000D8FC                 db    0
.xdata$x:0000D8FD                 db    0
.xdata$x:0000D8FE                 db    0
.xdata$x:0000D8FF                 db    0
.xdata$x:0000D900                 db    0
.xdata$x:0000D901                 db    0
.xdata$x:0000D902                 db    0
.xdata$x:0000D903                 db    0
.xdata$x:0000D904                 db    0
.xdata$x:0000D905                 db    0
.xdata$x:0000D906                 db    0
.xdata$x:0000D907                 db    0
.xdata$x:0000D908                 db    0
.xdata$x:0000D909                 db    0
.xdata$x:0000D90A                 db    0
.xdata$x:0000D90B                 db    0
.xdata$x:0000D90C                 db    0
.xdata$x:0000D90D                 db    0
.xdata$x:0000D90E                 db    0
.xdata$x:0000D90F                 db    0
.xdata$x:0000D90F _xdata$x        ends
.xdata$x:0000D90F
.xdata$x:0000D910 ; ===========================================================================
.xdata$x:0000D910
.xdata$x:0000D910 ; Segment type: Pure data
.xdata$x:0000D910 ; Segment permissions: Read
.xdata$x:0000D910 _xdata$x        segment dword public 'DATA' use32
.xdata$x:0000D910                 assume cs:_xdata$x
.xdata$x:0000D910                 ;org 0D910h
.xdata$x:0000D910 ; COMDAT (pick associative to section at 78FC)
.xdata$x:0000D910 __unwindtable$??1_System_error_category@std@@UAE@XZ db 0FFh
.xdata$x:0000D910                                         ; DATA XREF: .xdata$x:0000D920o
.xdata$x:0000D911                 db 0FFh
.xdata$x:0000D912                 db 0FFh
.xdata$x:0000D913                 db 0FFh
.xdata$x:0000D914                 dd offset __unwindfunclet$??1_System_error_category@std@@UAE@XZ$0
.xdata$x:0000D918 __ehfuncinfo$??1_System_error_category@std@@UAE@XZ db  22h ; "
.xdata$x:0000D918                                         ; DATA XREF: __ehhandler$??1_System_error_category@std@@UAE@XZ+11o
.xdata$x:0000D919                 db    5
.xdata$x:0000D91A                 db  93h ; ô
.xdata$x:0000D91B                 db  19h
.xdata$x:0000D91C                 db    1
.xdata$x:0000D91D                 db    0
.xdata$x:0000D91E                 db    0
.xdata$x:0000D91F                 db    0
.xdata$x:0000D920                 dd offset __unwindtable$??1_System_error_category@std@@UAE@XZ
.xdata$x:0000D924                 db    0
.xdata$x:0000D925                 db    0
.xdata$x:0000D926                 db    0
.xdata$x:0000D927                 db    0
.xdata$x:0000D928                 db    0
.xdata$x:0000D929                 db    0
.xdata$x:0000D92A                 db    0
.xdata$x:0000D92B                 db    0
.xdata$x:0000D92C                 db    0
.xdata$x:0000D92D                 db    0
.xdata$x:0000D92E                 db    0
.xdata$x:0000D92F                 db    0
.xdata$x:0000D930                 db    0
.xdata$x:0000D931                 db    0
.xdata$x:0000D932                 db    0
.xdata$x:0000D933                 db    0
.xdata$x:0000D934                 db    0
.xdata$x:0000D935                 db    0
.xdata$x:0000D936                 db    0
.xdata$x:0000D937                 db    0
.xdata$x:0000D938                 db    0
.xdata$x:0000D939                 db    0
.xdata$x:0000D93A                 db    0
.xdata$x:0000D93B                 db    0
.xdata$x:0000D93B _xdata$x        ends
.xdata$x:0000D93B
.xdata$x:0000D93C ; ===========================================================================
.xdata$x:0000D93C
.xdata$x:0000D93C ; Segment type: Pure data
.xdata$x:0000D93C ; Segment permissions: Read
.xdata$x:0000D93C _xdata$x        segment dword public 'DATA' use32
.xdata$x:0000D93C                 assume cs:_xdata$x
.xdata$x:0000D93C                 ;org 0D93Ch
.xdata$x:0000D93C ; COMDAT (pick associative to section at 5928)
.xdata$x:0000D93C __unwindtable$??0?$_String_val@U?$_Simple_types@_W@std@@@std@@QAE@XZ db 0FFh
.xdata$x:0000D93C                                         ; DATA XREF: .xdata$x:0000D94Co
.xdata$x:0000D93D                 db 0FFh
.xdata$x:0000D93E                 db 0FFh
.xdata$x:0000D93F                 db 0FFh
.xdata$x:0000D940                 dd offset __unwindfunclet$??0?$_String_val@U?$_Simple_types@_W@std@@@std@@QAE@XZ$0
.xdata$x:0000D944 __ehfuncinfo$??0?$_String_val@U?$_Simple_types@_W@std@@@std@@QAE@XZ db  22h ; "
.xdata$x:0000D944                                         ; DATA XREF: __ehhandler$??0?$_String_val@U?$_Simple_types@_W@std@@@std@@QAE@XZ+11o
.xdata$x:0000D945                 db    5
.xdata$x:0000D946                 db  93h ; ô
.xdata$x:0000D947                 db  19h
.xdata$x:0000D948                 db    1
.xdata$x:0000D949                 db    0
.xdata$x:0000D94A                 db    0
.xdata$x:0000D94B                 db    0
.xdata$x:0000D94C                 dd offset __unwindtable$??0?$_String_val@U?$_Simple_types@_W@std@@@std@@QAE@XZ
.xdata$x:0000D950                 db    0
.xdata$x:0000D951                 db    0
.xdata$x:0000D952                 db    0
.xdata$x:0000D953                 db    0
.xdata$x:0000D954                 db    0
.xdata$x:0000D955                 db    0
.xdata$x:0000D956                 db    0
.xdata$x:0000D957                 db    0
.xdata$x:0000D958                 db    0
.xdata$x:0000D959                 db    0
.xdata$x:0000D95A                 db    0
.xdata$x:0000D95B                 db    0
.xdata$x:0000D95C                 db    0
.xdata$x:0000D95D                 db    0
.xdata$x:0000D95E                 db    0
.xdata$x:0000D95F                 db    0
.xdata$x:0000D960                 db    0
.xdata$x:0000D961                 db    0
.xdata$x:0000D962                 db    0
.xdata$x:0000D963                 db    0
.xdata$x:0000D964                 db    0
.xdata$x:0000D965                 db    0
.xdata$x:0000D966                 db    0
.xdata$x:0000D967                 db    0
.xdata$x:0000D967 _xdata$x        ends
.xdata$x:0000D967
.xdata$x:0000D968 ; ===========================================================================
.xdata$x:0000D968
.xdata$x:0000D968 ; Segment type: Pure data
.xdata$x:0000D968 ; Segment permissions: Read
.xdata$x:0000D968 _xdata$x        segment dword public 'DATA' use32
.xdata$x:0000D968                 assume cs:_xdata$x
.xdata$x:0000D968                 ;org 0D968h
.xdata$x:0000D968 ; COMDAT (pick associative to section at 70AC)
.xdata$x:0000D968 __unwindtable$??1?$_String_val@U?$_Simple_types@_W@std@@@std@@QAE@XZ db 0FFh
.xdata$x:0000D968                                         ; DATA XREF: .xdata$x:0000D978o
.xdata$x:0000D969                 db 0FFh
.xdata$x:0000D96A                 db 0FFh
.xdata$x:0000D96B                 db 0FFh
.xdata$x:0000D96C                 dd offset __unwindfunclet$??1?$_String_val@U?$_Simple_types@_W@std@@@std@@QAE@XZ$0
.xdata$x:0000D970 __ehfuncinfo$??1?$_String_val@U?$_Simple_types@_W@std@@@std@@QAE@XZ db  22h ; "
.xdata$x:0000D970                                         ; DATA XREF: __ehhandler$??1?$_String_val@U?$_Simple_types@_W@std@@@std@@QAE@XZ+11o
.xdata$x:0000D971                 db    5
.xdata$x:0000D972                 db  93h ; ô
.xdata$x:0000D973                 db  19h
.xdata$x:0000D974                 db    1
.xdata$x:0000D975                 db    0
.xdata$x:0000D976                 db    0
.xdata$x:0000D977                 db    0
.xdata$x:0000D978                 dd offset __unwindtable$??1?$_String_val@U?$_Simple_types@_W@std@@@std@@QAE@XZ
.xdata$x:0000D97C                 db    0
.xdata$x:0000D97D                 db    0
.xdata$x:0000D97E                 db    0
.xdata$x:0000D97F                 db    0
.xdata$x:0000D980                 db    0
.xdata$x:0000D981                 db    0
.xdata$x:0000D982                 db    0
.xdata$x:0000D983                 db    0
.xdata$x:0000D984                 db    0
.xdata$x:0000D985                 db    0
.xdata$x:0000D986                 db    0
.xdata$x:0000D987                 db    0
.xdata$x:0000D988                 db    0
.xdata$x:0000D989                 db    0
.xdata$x:0000D98A                 db    0
.xdata$x:0000D98B                 db    0
.xdata$x:0000D98C                 db    0
.xdata$x:0000D98D                 db    0
.xdata$x:0000D98E                 db    0
.xdata$x:0000D98F                 db    0
.xdata$x:0000D990                 db    0
.xdata$x:0000D991                 db    0
.xdata$x:0000D992                 db    0
.xdata$x:0000D993                 db    0
.xdata$x:0000D993 _xdata$x        ends
.xdata$x:0000D993
.xdata$x:0000D994 ; ===========================================================================
.xdata$x:0000D994
.xdata$x:0000D994 ; Segment type: Pure data
.xdata$x:0000D994 ; Segment permissions: Read
.xdata$x:0000D994 _xdata$x        segment dword public 'DATA' use32
.xdata$x:0000D994                 assume cs:_xdata$x
.xdata$x:0000D994                 ;org 0D994h
.xdata$x:0000D994 ; COMDAT (pick associative to section at 5620)
.xdata$x:0000D994 __unwindtable$??0?$_String_alloc@$0A@U?$_String_base_types@_WV?$allocator@_W@std@@@std@@@std@@QAE@ABV?$allocator@_W@1@@Z db 0FFh
.xdata$x:0000D994                                         ; DATA XREF: .xdata$x:0000D9A4o
.xdata$x:0000D995                 db 0FFh
.xdata$x:0000D996                 db 0FFh
.xdata$x:0000D997                 db 0FFh
.xdata$x:0000D998                 dd offset __unwindfunclet$??0?$_String_alloc@$0A@U?$_String_base_types@_WV?$allocator@_W@std@@@std@@@std@@QAE@ABV?$allocator@_W@1@@Z$0
.xdata$x:0000D99C __ehfuncinfo$??0?$_String_alloc@$0A@U?$_String_base_types@_WV?$allocator@_W@std@@@std@@@std@@QAE@ABV?$allocator@_W@1@@Z db  22h ; "
.xdata$x:0000D99C                                         ; DATA XREF: __ehhandler$??0?$_String_alloc@$0A@U?$_String_base_types@_WV?$allocator@_W@std@@@std@@@std@@QAE@ABV?$allocator@_W@1@@Z+11o
.xdata$x:0000D99D                 db    5
.xdata$x:0000D99E                 db  93h ; ô
.xdata$x:0000D99F                 db  19h
.xdata$x:0000D9A0                 db    1
.xdata$x:0000D9A1                 db    0
.xdata$x:0000D9A2                 db    0
.xdata$x:0000D9A3                 db    0
.xdata$x:0000D9A4                 dd offset __unwindtable$??0?$_String_alloc@$0A@U?$_String_base_types@_WV?$allocator@_W@std@@@std@@@std@@QAE@ABV?$allocator@_W@1@@Z
.xdata$x:0000D9A8                 align 20h
.xdata$x:0000D9A8 _xdata$x        ends
.xdata$x:0000D9A8
.xdata$x:0000D9C0 ; ===========================================================================
.xdata$x:0000D9C0
.xdata$x:0000D9C0 ; Segment type: Pure data
.xdata$x:0000D9C0 ; Segment permissions: Read
.xdata$x:0000D9C0 _xdata$x        segment dword public 'DATA' use32
.xdata$x:0000D9C0                 assume cs:_xdata$x
.xdata$x:0000D9C0                 ;org 0D9C0h
.xdata$x:0000D9C0 ; COMDAT (pick associative to section at 6EE4)
.xdata$x:0000D9C0 __unwindtable$??1?$_String_alloc@$0A@U?$_String_base_types@_WV?$allocator@_W@std@@@std@@@std@@QAE@XZ db 0FFh
.xdata$x:0000D9C0                                         ; DATA XREF: .xdata$x:0000D9D0o
.xdata$x:0000D9C1                 db 0FFh
.xdata$x:0000D9C2                 db 0FFh
.xdata$x:0000D9C3                 db 0FFh
.xdata$x:0000D9C4                 dd offset __unwindfunclet$??1?$_String_alloc@$0A@U?$_String_base_types@_WV?$allocator@_W@std@@@std@@@std@@QAE@XZ$0
.xdata$x:0000D9C8 __ehfuncinfo$??1?$_String_alloc@$0A@U?$_String_base_types@_WV?$allocator@_W@std@@@std@@@std@@QAE@XZ db  22h ; "
.xdata$x:0000D9C8                                         ; DATA XREF: __ehhandler$??1?$_String_alloc@$0A@U?$_String_base_types@_WV?$allocator@_W@std@@@std@@@std@@QAE@XZ+11o
.xdata$x:0000D9C9                 db    5
.xdata$x:0000D9CA                 db  93h ; ô
.xdata$x:0000D9CB                 db  19h
.xdata$x:0000D9CC                 db    1
.xdata$x:0000D9CD                 db    0
.xdata$x:0000D9CE                 db    0
.xdata$x:0000D9CF                 db    0
.xdata$x:0000D9D0                 dd offset __unwindtable$??1?$_String_alloc@$0A@U?$_String_base_types@_WV?$allocator@_W@std@@@std@@@std@@QAE@XZ
.xdata$x:0000D9D4                 db    0
.xdata$x:0000D9D5                 db    0
.xdata$x:0000D9D6                 db    0
.xdata$x:0000D9D7                 db    0
.xdata$x:0000D9D8                 db    0
.xdata$x:0000D9D9                 db    0
.xdata$x:0000D9DA                 db    0
.xdata$x:0000D9DB                 db    0
.xdata$x:0000D9DC                 db    0
.xdata$x:0000D9DD                 db    0
.xdata$x:0000D9DE                 db    0
.xdata$x:0000D9DF                 db    0
.xdata$x:0000D9E0                 db    0
.xdata$x:0000D9E1                 db    0
.xdata$x:0000D9E2                 db    0
.xdata$x:0000D9E3                 db    0
.xdata$x:0000D9E4                 db    0
.xdata$x:0000D9E5                 db    0
.xdata$x:0000D9E6                 db    0
.xdata$x:0000D9E7                 db    0
.xdata$x:0000D9E8                 db    0
.xdata$x:0000D9E9                 db    0
.xdata$x:0000D9EA                 db    0
.xdata$x:0000D9EB                 db    0
.xdata$x:0000D9EB _xdata$x        ends
.xdata$x:0000D9EB
.xdata$x:0000D9EC ; ===========================================================================
.xdata$x:0000D9EC
.xdata$x:0000D9EC ; Segment type: Pure data
.xdata$x:0000D9EC ; Segment permissions: Read
.xdata$x:0000D9EC _xdata$x        segment dword public 'DATA' use32
.xdata$x:0000D9EC                 assume cs:_xdata$x
.xdata$x:0000D9EC                 ;org 0D9ECh
.xdata$x:0000D9EC ; COMDAT (pick associative to section at 6184)
.xdata$x:0000D9EC __unwindtable$??0?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QAE@ABV01@@Z db 0FFh
.xdata$x:0000D9EC                                         ; DATA XREF: .xdata$x:0000D9FCo
.xdata$x:0000D9ED                 db 0FFh
.xdata$x:0000D9EE                 db 0FFh
.xdata$x:0000D9EF                 db 0FFh
.xdata$x:0000D9F0                 dd offset __unwindfunclet$??0?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QAE@ABV01@@Z$0
.xdata$x:0000D9F4 __ehfuncinfo$??0?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QAE@ABV01@@Z db  22h ; "
.xdata$x:0000D9F4                                         ; DATA XREF: __ehhandler$??0?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QAE@ABV01@@Z+11o
.xdata$x:0000D9F5                 db    5
.xdata$x:0000D9F6                 db  93h ; ô
.xdata$x:0000D9F7                 db  19h
.xdata$x:0000D9F8                 db    1
.xdata$x:0000D9F9                 db    0
.xdata$x:0000D9FA                 db    0
.xdata$x:0000D9FB                 db    0
.xdata$x:0000D9FC                 dd offset __unwindtable$??0?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QAE@ABV01@@Z
.xdata$x:0000DA00                 db    0
.xdata$x:0000DA01                 db    0
.xdata$x:0000DA02                 db    0
.xdata$x:0000DA03                 db    0
.xdata$x:0000DA04                 db    0
.xdata$x:0000DA05                 db    0
.xdata$x:0000DA06                 db    0
.xdata$x:0000DA07                 db    0
.xdata$x:0000DA08                 db    0
.xdata$x:0000DA09                 db    0
.xdata$x:0000DA0A                 db    0
.xdata$x:0000DA0B                 db    0
.xdata$x:0000DA0C                 db    0
.xdata$x:0000DA0D                 db    0
.xdata$x:0000DA0E                 db    0
.xdata$x:0000DA0F                 db    0
.xdata$x:0000DA10                 db    0
.xdata$x:0000DA11                 db    0
.xdata$x:0000DA12                 db    0
.xdata$x:0000DA13                 db    0
.xdata$x:0000DA14                 db    0
.xdata$x:0000DA15                 db    0
.xdata$x:0000DA16                 db    0
.xdata$x:0000DA17                 db    0
.xdata$x:0000DA17 _xdata$x        ends
.xdata$x:0000DA17
.xdata$x:0000DA18 ; ===========================================================================
.xdata$x:0000DA18
.xdata$x:0000DA18 ; Segment type: Pure data
.xdata$x:0000DA18 ; Segment permissions: Read
.xdata$x:0000DA18 _xdata$x        segment dword public 'DATA' use32
.xdata$x:0000DA18                 assume cs:_xdata$x
.xdata$x:0000DA18                 ;org 0DA18h
.xdata$x:0000DA18 ; COMDAT (pick associative to section at 6364)
.xdata$x:0000DA18 __unwindtable$??0?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QAE@XZ db 0FFh
.xdata$x:0000DA18                                         ; DATA XREF: .xdata$x:0000DA28o
.xdata$x:0000DA19                 db 0FFh
.xdata$x:0000DA1A                 db 0FFh
.xdata$x:0000DA1B                 db 0FFh
.xdata$x:0000DA1C                 dd offset __unwindfunclet$??0?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QAE@XZ$0
.xdata$x:0000DA20 __ehfuncinfo$??0?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QAE@XZ db  22h ; "
.xdata$x:0000DA20                                         ; DATA XREF: __ehhandler$??0?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QAE@XZ+11o
.xdata$x:0000DA21                 db    5
.xdata$x:0000DA22                 db  93h ; ô
.xdata$x:0000DA23                 db  19h
.xdata$x:0000DA24                 db    1
.xdata$x:0000DA25                 db    0
.xdata$x:0000DA26                 db    0
.xdata$x:0000DA27                 db    0
.xdata$x:0000DA28                 dd offset __unwindtable$??0?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QAE@XZ
.xdata$x:0000DA2C                 db    0
.xdata$x:0000DA2D                 db    0
.xdata$x:0000DA2E                 db    0
.xdata$x:0000DA2F                 db    0
.xdata$x:0000DA30                 db    0
.xdata$x:0000DA31                 db    0
.xdata$x:0000DA32                 db    0
.xdata$x:0000DA33                 db    0
.xdata$x:0000DA34                 db    0
.xdata$x:0000DA35                 db    0
.xdata$x:0000DA36                 db    0
.xdata$x:0000DA37                 db    0
.xdata$x:0000DA38                 db    0
.xdata$x:0000DA39                 db    0
.xdata$x:0000DA3A                 db    0
.xdata$x:0000DA3B                 db    0
.xdata$x:0000DA3C                 db    0
.xdata$x:0000DA3D                 db    0
.xdata$x:0000DA3E                 db    0
.xdata$x:0000DA3F                 db    0
.xdata$x:0000DA40                 db    0
.xdata$x:0000DA41                 db    0
.xdata$x:0000DA42                 db    0
.xdata$x:0000DA43                 db    0
.xdata$x:0000DA43 _xdata$x        ends
.xdata$x:0000DA43
.xdata$x:0000DA44 ; ===========================================================================
.xdata$x:0000DA44
.xdata$x:0000DA44 ; Segment type: Pure data
.xdata$x:0000DA44 ; Segment permissions: Read
.xdata$x:0000DA44 _xdata$x        segment dword public 'DATA' use32
.xdata$x:0000DA44                 assume cs:_xdata$x
.xdata$x:0000DA44                 ;org 0DA44h
.xdata$x:0000DA44 ; COMDAT (pick associative to section at 6234)
.xdata$x:0000DA44 __unwindtable$??0?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QAE@ABV01@IIABV?$allocator@_W@1@@Z db 0FFh
.xdata$x:0000DA44                                         ; DATA XREF: .xdata$x:0000DA54o
.xdata$x:0000DA45                 db 0FFh
.xdata$x:0000DA46                 db 0FFh
.xdata$x:0000DA47                 db 0FFh
.xdata$x:0000DA48                 dd offset __unwindfunclet$??0?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QAE@ABV01@IIABV?$allocator@_W@1@@Z$0
.xdata$x:0000DA4C __ehfuncinfo$??0?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QAE@ABV01@IIABV?$allocator@_W@1@@Z db  22h ; "
.xdata$x:0000DA4C                                         ; DATA XREF: __ehhandler$??0?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QAE@ABV01@IIABV?$allocator@_W@1@@Z+11o
.xdata$x:0000DA4D                 db    5
.xdata$x:0000DA4E                 db  93h ; ô
.xdata$x:0000DA4F                 db  19h
.xdata$x:0000DA50                 db    1
.xdata$x:0000DA51                 db    0
.xdata$x:0000DA52                 db    0
.xdata$x:0000DA53                 db    0
.xdata$x:0000DA54                 dd offset __unwindtable$??0?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QAE@ABV01@IIABV?$allocator@_W@1@@Z
.xdata$x:0000DA58                 db    0
.xdata$x:0000DA59                 db    0
.xdata$x:0000DA5A                 db    0
.xdata$x:0000DA5B                 db    0
.xdata$x:0000DA5C                 db    0
.xdata$x:0000DA5D                 db    0
.xdata$x:0000DA5E                 db    0
.xdata$x:0000DA5F                 db    0
.xdata$x:0000DA60                 db    0
.xdata$x:0000DA61                 db    0
.xdata$x:0000DA62                 db    0
.xdata$x:0000DA63                 db    0
.xdata$x:0000DA64                 db    0
.xdata$x:0000DA65                 db    0
.xdata$x:0000DA66                 db    0
.xdata$x:0000DA67                 db    0
.xdata$x:0000DA68                 db    0
.xdata$x:0000DA69                 db    0
.xdata$x:0000DA6A                 db    0
.xdata$x:0000DA6B                 db    0
.xdata$x:0000DA6C                 db    0
.xdata$x:0000DA6D                 db    0
.xdata$x:0000DA6E                 db    0
.xdata$x:0000DA6F                 db    0
.xdata$x:0000DA6F _xdata$x        ends
.xdata$x:0000DA6F
.xdata$x:0000DA70 ; ===========================================================================
.xdata$x:0000DA70
.xdata$x:0000DA70 ; Segment type: Pure data
.xdata$x:0000DA70 ; Segment permissions: Read
.xdata$x:0000DA70 _xdata$x        segment dword public 'DATA' use32
.xdata$x:0000DA70                 assume cs:_xdata$x
.xdata$x:0000DA70                 ;org 0DA70h
.xdata$x:0000DA70 ; COMDAT (pick associative to section at 62CC)
.xdata$x:0000DA70 __unwindtable$??0?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QAE@PB_W@Z db 0FFh
.xdata$x:0000DA70                                         ; DATA XREF: .xdata$x:0000DA80o
.xdata$x:0000DA71                 db 0FFh
.xdata$x:0000DA72                 db 0FFh
.xdata$x:0000DA73                 db 0FFh
.xdata$x:0000DA74                 dd offset __unwindfunclet$??0?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QAE@PB_W@Z$0
.xdata$x:0000DA78 __ehfuncinfo$??0?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QAE@PB_W@Z db  22h ; "
.xdata$x:0000DA78                                         ; DATA XREF: __ehhandler$??0?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QAE@PB_W@Z+11o
.xdata$x:0000DA79                 db    5
.xdata$x:0000DA7A                 db  93h ; ô
.xdata$x:0000DA7B                 db  19h
.xdata$x:0000DA7C                 db    1
.xdata$x:0000DA7D                 db    0
.xdata$x:0000DA7E                 db    0
.xdata$x:0000DA7F                 db    0
.xdata$x:0000DA80                 dd offset __unwindtable$??0?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QAE@PB_W@Z
.xdata$x:0000DA84                 db    0
.xdata$x:0000DA85                 db    0
.xdata$x:0000DA86                 db    0
.xdata$x:0000DA87                 db    0
.xdata$x:0000DA88                 db    0
.xdata$x:0000DA89                 db    0
.xdata$x:0000DA8A                 db    0
.xdata$x:0000DA8B                 db    0
.xdata$x:0000DA8C                 db    0
.xdata$x:0000DA8D                 db    0
.xdata$x:0000DA8E                 db    0
.xdata$x:0000DA8F                 db    0
.xdata$x:0000DA90                 db    0
.xdata$x:0000DA91                 db    0
.xdata$x:0000DA92                 db    0
.xdata$x:0000DA93                 db    0
.xdata$x:0000DA94                 db    0
.xdata$x:0000DA95                 db    0
.xdata$x:0000DA96                 db    0
.xdata$x:0000DA97                 db    0
.xdata$x:0000DA98                 db    0
.xdata$x:0000DA99                 db    0
.xdata$x:0000DA9A                 db    0
.xdata$x:0000DA9B                 db    0
.xdata$x:0000DA9B _xdata$x        ends
.xdata$x:0000DA9B
.xdata$x:0000DA9C ; ===========================================================================
.xdata$x:0000DA9C
.xdata$x:0000DA9C ; Segment type: Pure data
.xdata$x:0000DA9C ; Segment permissions: Read
.xdata$x:0000DA9C _xdata$x        segment dword public 'DATA' use32
.xdata$x:0000DA9C                 assume cs:_xdata$x
.xdata$x:0000DA9C                 ;org 0DA9Ch
.xdata$x:0000DA9C ; COMDAT (pick associative to section at 60E0)
.xdata$x:0000DA9C __unwindtable$??0?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QAE@$$QAV01@@Z db 0FFh
.xdata$x:0000DA9C                                         ; DATA XREF: .xdata$x:0000DAACo
.xdata$x:0000DA9D                 db 0FFh
.xdata$x:0000DA9E                 db 0FFh
.xdata$x:0000DA9F                 db 0FFh
.xdata$x:0000DAA0                 dd offset __unwindfunclet$??0?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QAE@$$QAV01@@Z$0
.xdata$x:0000DAA4 __ehfuncinfo$??0?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QAE@$$QAV01@@Z db  22h ; "
.xdata$x:0000DAA4                                         ; DATA XREF: __ehhandler$??0?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QAE@$$QAV01@@Z+11o
.xdata$x:0000DAA5                 db    5
.xdata$x:0000DAA6                 db  93h ; ô
.xdata$x:0000DAA7                 db  19h
.xdata$x:0000DAA8                 db    1
.xdata$x:0000DAA9                 db    0
.xdata$x:0000DAAA                 db    0
.xdata$x:0000DAAB                 db    0
.xdata$x:0000DAAC                 dd offset __unwindtable$??0?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QAE@$$QAV01@@Z
.xdata$x:0000DAB0                 db    0
.xdata$x:0000DAB1                 db    0
.xdata$x:0000DAB2                 db    0
.xdata$x:0000DAB3                 db    0
.xdata$x:0000DAB4                 db    0
.xdata$x:0000DAB5                 db    0
.xdata$x:0000DAB6                 db    0
.xdata$x:0000DAB7                 db    0
.xdata$x:0000DAB8                 db    0
.xdata$x:0000DAB9                 db    0
.xdata$x:0000DABA                 db    0
.xdata$x:0000DABB                 db    0
.xdata$x:0000DABC                 db    0
.xdata$x:0000DABD                 db    0
.xdata$x:0000DABE                 db    0
.xdata$x:0000DABF                 db    0
.xdata$x:0000DAC0                 db    0
.xdata$x:0000DAC1                 db    0
.xdata$x:0000DAC2                 db    0
.xdata$x:0000DAC3                 db    0
.xdata$x:0000DAC4                 db    0
.xdata$x:0000DAC5                 db    0
.xdata$x:0000DAC6                 db    0
.xdata$x:0000DAC7                 db    0
.xdata$x:0000DAC7 _xdata$x        ends
.xdata$x:0000DAC7
.xdata$x:0000DAC8 ; ===========================================================================
.xdata$x:0000DAC8
.xdata$x:0000DAC8 ; Segment type: Pure data
.xdata$x:0000DAC8 ; Segment permissions: Read
.xdata$x:0000DAC8 _xdata$x        segment dword public 'DATA' use32
.xdata$x:0000DAC8                 assume cs:_xdata$x
.xdata$x:0000DAC8                 ;org 0DAC8h
.xdata$x:0000DAC8 ; COMDAT (pick associative to section at 7530)
.xdata$x:0000DAC8 __unwindtable$??1?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QAE@XZ db 0FFh
.xdata$x:0000DAC8                                         ; DATA XREF: .xdata$x:0000DAD8o
.xdata$x:0000DAC9                 db 0FFh
.xdata$x:0000DACA                 db 0FFh
.xdata$x:0000DACB                 db 0FFh
.xdata$x:0000DACC                 dd offset __unwindfunclet$??1?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QAE@XZ$0
.xdata$x:0000DAD0 __ehfuncinfo$??1?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QAE@XZ db  22h ; "
.xdata$x:0000DAD0                                         ; DATA XREF: __ehhandler$??1?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QAE@XZ+11o
.xdata$x:0000DAD1                 db    5
.xdata$x:0000DAD2                 db  93h ; ô
.xdata$x:0000DAD3                 db  19h
.xdata$x:0000DAD4                 db    1
.xdata$x:0000DAD5                 db    0
.xdata$x:0000DAD6                 db    0
.xdata$x:0000DAD7                 db    0
.xdata$x:0000DAD8                 dd offset __unwindtable$??1?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QAE@XZ
.xdata$x:0000DADC                 db    0
.xdata$x:0000DADD                 db    0
.xdata$x:0000DADE                 db    0
.xdata$x:0000DADF                 db    0
.xdata$x:0000DAE0                 db    0
.xdata$x:0000DAE1                 db    0
.xdata$x:0000DAE2                 db    0
.xdata$x:0000DAE3                 db    0
.xdata$x:0000DAE4                 db    0
.xdata$x:0000DAE5                 db    0
.xdata$x:0000DAE6                 db    0
.xdata$x:0000DAE7                 db    0
.xdata$x:0000DAE8                 db    0
.xdata$x:0000DAE9                 db    0
.xdata$x:0000DAEA                 db    0
.xdata$x:0000DAEB                 db    0
.xdata$x:0000DAEC                 db    0
.xdata$x:0000DAED                 db    0
.xdata$x:0000DAEE                 db    0
.xdata$x:0000DAEF                 db    0
.xdata$x:0000DAF0                 db    0
.xdata$x:0000DAF1                 db    0
.xdata$x:0000DAF2                 db    0
.xdata$x:0000DAF3                 db    0
.xdata$x:0000DAF3 _xdata$x        ends
.xdata$x:0000DAF3
.xdata$x:0000DAF4 ; ===========================================================================
.xdata$x:0000DAF4
.xdata$x:0000DAF4 ; Segment type: Pure data
.xdata$x:0000DAF4 ; Segment permissions: Read
.xdata$x:0000DAF4 _xdata$x        segment dword public 'DATA' use32
.xdata$x:0000DAF4                 assume cs:_xdata$x
.xdata$x:0000DAF4                 ;org 0DAF4h
.xdata$x:0000DAF4 ; COMDAT (pick associative to section at BFC8)
.xdata$x:0000DAF4 __ehfuncinfo$?insert@?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QAE?AV?$_String_iterator@V?$_String_val@U?$_Simple_types@_W@std@@@std@@@2@V?$_String_const_iterator@V?$_String_val@U?$_Simple_types@_W@std@@@std@@@2@_W@Z db  22h ; "
.xdata$x:0000DAF4                                         ; DATA XREF: __ehhandler$?insert@?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QAE?AV?$_String_iterator@V?$_String_val@U?$_Simple_types@_W@std@@@std@@@2@V?$_String_const_iterator@V?$_String_val@U?$_Simple_types@_W@std@@@std@@@2@_W@Z+11o
.xdata$x:0000DAF5                 db    5
.xdata$x:0000DAF6                 db  93h ; ô
.xdata$x:0000DAF7                 db  19h
.xdata$x:0000DAF8                 db    6
.xdata$x:0000DAF9                 db    0
.xdata$x:0000DAFA                 db    0
.xdata$x:0000DAFB                 db    0
.xdata$x:0000DAFC                 dd offset __unwindtable$?insert@?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QAE?AV?$_String_iterator@V?$_String_val@U?$_Simple_types@_W@std@@@std@@@2@V?$_String_const_iterator@V?$_String_val@U?$_Simple_types@_W@std@@@std@@@2@_W@Z
.xdata$x:0000DB00                 db    0
.xdata$x:0000DB01                 db    0
.xdata$x:0000DB02                 db    0
.xdata$x:0000DB03                 db    0
.xdata$x:0000DB04                 db    0
.xdata$x:0000DB05                 db    0
.xdata$x:0000DB06                 db    0
.xdata$x:0000DB07                 db    0
.xdata$x:0000DB08                 db    0
.xdata$x:0000DB09                 db    0
.xdata$x:0000DB0A                 db    0
.xdata$x:0000DB0B                 db    0
.xdata$x:0000DB0C                 db    0
.xdata$x:0000DB0D                 db    0
.xdata$x:0000DB0E                 db    0
.xdata$x:0000DB0F                 db    0
.xdata$x:0000DB10                 db    0
.xdata$x:0000DB11                 db    0
.xdata$x:0000DB12                 db    0
.xdata$x:0000DB13                 db    0
.xdata$x:0000DB14                 db    0
.xdata$x:0000DB15                 db    0
.xdata$x:0000DB16                 db    0
.xdata$x:0000DB17                 db    0
.xdata$x:0000DB18 __unwindtable$?insert@?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QAE?AV?$_String_iterator@V?$_String_val@U?$_Simple_types@_W@std@@@std@@@2@V?$_String_const_iterator@V?$_String_val@U?$_Simple_types@_W@std@@@std@@@2@_W@Z db 0FFh
.xdata$x:0000DB18                                         ; DATA XREF: .xdata$x:0000DAFCo
.xdata$x:0000DB19                 db 0FFh
.xdata$x:0000DB1A                 db 0FFh
.xdata$x:0000DB1B                 db 0FFh
.xdata$x:0000DB1C                 dd offset __unwindfunclet$?insert@?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QAE?AV?$_String_iterator@V?$_String_val@U?$_Simple_types@_W@std@@@std@@@2@V?$_String_const_iterator@V?$_String_val@U?$_Simple_types@_W@std@@@std@@@2@_W@Z$5
.xdata$x:0000DB20                 db    0
.xdata$x:0000DB21                 db    0
.xdata$x:0000DB22                 db    0
.xdata$x:0000DB23                 db    0
.xdata$x:0000DB24                 dd offset __unwindfunclet$?insert@?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QAE?AV?$_String_iterator@V?$_String_val@U?$_Simple_types@_W@std@@@std@@@2@V?$_String_const_iterator@V?$_String_val@U?$_Simple_types@_W@std@@@std@@@2@_W@Z$0
.xdata$x:0000DB28                 db    1
.xdata$x:0000DB29                 db    0
.xdata$x:0000DB2A                 db    0
.xdata$x:0000DB2B                 db    0
.xdata$x:0000DB2C                 dd offset __unwindfunclet$?insert@?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QAE?AV?$_String_iterator@V?$_String_val@U?$_Simple_types@_W@std@@@std@@@2@V?$_String_const_iterator@V?$_String_val@U?$_Simple_types@_W@std@@@std@@@2@_W@Z$1
.xdata$x:0000DB30                 db    2
.xdata$x:0000DB31                 db    0
.xdata$x:0000DB32                 db    0
.xdata$x:0000DB33                 db    0
.xdata$x:0000DB34                 dd offset __unwindfunclet$?insert@?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QAE?AV?$_String_iterator@V?$_String_val@U?$_Simple_types@_W@std@@@std@@@2@V?$_String_const_iterator@V?$_String_val@U?$_Simple_types@_W@std@@@std@@@2@_W@Z$2
.xdata$x:0000DB38                 db    3
.xdata$x:0000DB39                 db    0
.xdata$x:0000DB3A                 db    0
.xdata$x:0000DB3B                 db    0
.xdata$x:0000DB3C                 dd offset __unwindfunclet$?insert@?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QAE?AV?$_String_iterator@V?$_String_val@U?$_Simple_types@_W@std@@@std@@@2@V?$_String_const_iterator@V?$_String_val@U?$_Simple_types@_W@std@@@std@@@2@_W@Z$3
.xdata$x:0000DB40                 db    1
.xdata$x:0000DB41                 db    0
.xdata$x:0000DB42                 db    0
.xdata$x:0000DB43                 db    0
.xdata$x:0000DB44                 dd offset __unwindfunclet$?insert@?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QAE?AV?$_String_iterator@V?$_String_val@U?$_Simple_types@_W@std@@@std@@@2@V?$_String_const_iterator@V?$_String_val@U?$_Simple_types@_W@std@@@std@@@2@_W@Z$4
.xdata$x:0000DB44 _xdata$x        ends
.xdata$x:0000DB44
.xdata$x:0000DB48 ; ===========================================================================
.xdata$x:0000DB48
.xdata$x:0000DB48 ; Segment type: Pure data
.xdata$x:0000DB48 ; Segment permissions: Read
.xdata$x:0000DB48 _xdata$x        segment dword public 'DATA' use32
.xdata$x:0000DB48                 assume cs:_xdata$x
.xdata$x:0000DB48                 ;org 0DB48h
.xdata$x:0000DB48 ; COMDAT (pick associative to section at B330)
.xdata$x:0000DB48 __unwindtable$?begin@?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QAE?AV?$_String_iterator@V?$_String_val@U?$_Simple_types@_W@std@@@std@@@2@XZ db 0FFh
.xdata$x:0000DB48                                         ; DATA XREF: .xdata$x:0000DB58o
.xdata$x:0000DB49                 db 0FFh
.xdata$x:0000DB4A                 db 0FFh
.xdata$x:0000DB4B                 db 0FFh
.xdata$x:0000DB4C                 dd offset __unwindfunclet$?begin@?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QAE?AV?$_String_iterator@V?$_String_val@U?$_Simple_types@_W@std@@@std@@@2@XZ$0
.xdata$x:0000DB50 __ehfuncinfo$?begin@?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QAE?AV?$_String_iterator@V?$_String_val@U?$_Simple_types@_W@std@@@std@@@2@XZ db  22h ; "
.xdata$x:0000DB50                                         ; DATA XREF: __ehhandler$?begin@?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QAE?AV?$_String_iterator@V?$_String_val@U?$_Simple_types@_W@std@@@std@@@2@XZ+11o
.xdata$x:0000DB51                 db    5
.xdata$x:0000DB52                 db  93h ; ô
.xdata$x:0000DB53                 db  19h
.xdata$x:0000DB54                 db    1
.xdata$x:0000DB55                 db    0
.xdata$x:0000DB56                 db    0
.xdata$x:0000DB57                 db    0
.xdata$x:0000DB58                 dd offset __unwindtable$?begin@?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QAE?AV?$_String_iterator@V?$_String_val@U?$_Simple_types@_W@std@@@std@@@2@XZ
.xdata$x:0000DB5C                 db    0
.xdata$x:0000DB5D                 db    0
.xdata$x:0000DB5E                 db    0
.xdata$x:0000DB5F                 db    0
.xdata$x:0000DB60                 db    0
.xdata$x:0000DB61                 db    0
.xdata$x:0000DB62                 db    0
.xdata$x:0000DB63                 db    0
.xdata$x:0000DB64                 db    0
.xdata$x:0000DB65                 db    0
.xdata$x:0000DB66                 db    0
.xdata$x:0000DB67                 db    0
.xdata$x:0000DB68                 db    0
.xdata$x:0000DB69                 db    0
.xdata$x:0000DB6A                 db    0
.xdata$x:0000DB6B                 db    0
.xdata$x:0000DB6C                 db    0
.xdata$x:0000DB6D                 db    0
.xdata$x:0000DB6E                 db    0
.xdata$x:0000DB6F                 db    0
.xdata$x:0000DB70                 db    0
.xdata$x:0000DB71                 db    0
.xdata$x:0000DB72                 db    0
.xdata$x:0000DB73                 db    0
.xdata$x:0000DB73 _xdata$x        ends
.xdata$x:0000DB73
.xdata$x:0000DB74 ; ===========================================================================
.xdata$x:0000DB74
.xdata$x:0000DB74 ; Segment type: Pure data
.xdata$x:0000DB74 ; Segment permissions: Read
.xdata$x:0000DB74 _xdata$x        segment dword public 'DATA' use32
.xdata$x:0000DB74                 assume cs:_xdata$x
.xdata$x:0000DB74                 ;org 0DB74h
.xdata$x:0000DB74 ; COMDAT (pick associative to section at B3CC)
.xdata$x:0000DB74 __unwindtable$?begin@?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QBE?AV?$_String_const_iterator@V?$_String_val@U?$_Simple_types@_W@std@@@std@@@2@XZ db 0FFh
.xdata$x:0000DB74                                         ; DATA XREF: .xdata$x:0000DB84o
.xdata$x:0000DB75                 db 0FFh
.xdata$x:0000DB76                 db 0FFh
.xdata$x:0000DB77                 db 0FFh
.xdata$x:0000DB78                 dd offset __unwindfunclet$?begin@?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QBE?AV?$_String_const_iterator@V?$_String_val@U?$_Simple_types@_W@std@@@std@@@2@XZ$0
.xdata$x:0000DB7C __ehfuncinfo$?begin@?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QBE?AV?$_String_const_iterator@V?$_String_val@U?$_Simple_types@_W@std@@@std@@@2@XZ db  22h ; "
.xdata$x:0000DB7C                                         ; DATA XREF: __ehhandler$?begin@?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QBE?AV?$_String_const_iterator@V?$_String_val@U?$_Simple_types@_W@std@@@std@@@2@XZ+11o
.xdata$x:0000DB7D                 db    5
.xdata$x:0000DB7E                 db  93h ; ô
.xdata$x:0000DB7F                 db  19h
.xdata$x:0000DB80                 db    1
.xdata$x:0000DB81                 db    0
.xdata$x:0000DB82                 db    0
.xdata$x:0000DB83                 db    0
.xdata$x:0000DB84                 dd offset __unwindtable$?begin@?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QBE?AV?$_String_const_iterator@V?$_String_val@U?$_Simple_types@_W@std@@@std@@@2@XZ
.xdata$x:0000DB88                 align 20h
.xdata$x:0000DB88 _xdata$x        ends
.xdata$x:0000DB88
.xdata$x:0000DBA0 ; ===========================================================================
.xdata$x:0000DBA0
.xdata$x:0000DBA0 ; Segment type: Pure data
.xdata$x:0000DBA0 ; Segment permissions: Read
.xdata$x:0000DBA0 _xdata$x        segment dword public 'DATA' use32
.xdata$x:0000DBA0                 assume cs:_xdata$x
.xdata$x:0000DBA0                 ;org 0DBA0h
.xdata$x:0000DBA0 ; COMDAT (pick associative to section at B908)
.xdata$x:0000DBA0 __unwindtable$?end@?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QAE?AV?$_String_iterator@V?$_String_val@U?$_Simple_types@_W@std@@@std@@@2@XZ db 0FFh
.xdata$x:0000DBA0                                         ; DATA XREF: .xdata$x:0000DBB0o
.xdata$x:0000DBA1                 db 0FFh
.xdata$x:0000DBA2                 db 0FFh
.xdata$x:0000DBA3                 db 0FFh
.xdata$x:0000DBA4                 dd offset __unwindfunclet$?end@?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QAE?AV?$_String_iterator@V?$_String_val@U?$_Simple_types@_W@std@@@std@@@2@XZ$0
.xdata$x:0000DBA8 __ehfuncinfo$?end@?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QAE?AV?$_String_iterator@V?$_String_val@U?$_Simple_types@_W@std@@@std@@@2@XZ db  22h ; "
.xdata$x:0000DBA8                                         ; DATA XREF: __ehhandler$?end@?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QAE?AV?$_String_iterator@V?$_String_val@U?$_Simple_types@_W@std@@@std@@@2@XZ+11o
.xdata$x:0000DBA9                 db    5
.xdata$x:0000DBAA                 db  93h ; ô
.xdata$x:0000DBAB                 db  19h
.xdata$x:0000DBAC                 db    1
.xdata$x:0000DBAD                 db    0
.xdata$x:0000DBAE                 db    0
.xdata$x:0000DBAF                 db    0
.xdata$x:0000DBB0                 dd offset __unwindtable$?end@?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QAE?AV?$_String_iterator@V?$_String_val@U?$_Simple_types@_W@std@@@std@@@2@XZ
.xdata$x:0000DBB4                 db    0
.xdata$x:0000DBB5                 db    0
.xdata$x:0000DBB6                 db    0
.xdata$x:0000DBB7                 db    0
.xdata$x:0000DBB8                 db    0
.xdata$x:0000DBB9                 db    0
.xdata$x:0000DBBA                 db    0
.xdata$x:0000DBBB                 db    0
.xdata$x:0000DBBC                 db    0
.xdata$x:0000DBBD                 db    0
.xdata$x:0000DBBE                 db    0
.xdata$x:0000DBBF                 db    0
.xdata$x:0000DBC0                 db    0
.xdata$x:0000DBC1                 db    0
.xdata$x:0000DBC2                 db    0
.xdata$x:0000DBC3                 db    0
.xdata$x:0000DBC4                 db    0
.xdata$x:0000DBC5                 db    0
.xdata$x:0000DBC6                 db    0
.xdata$x:0000DBC7                 db    0
.xdata$x:0000DBC8                 db    0
.xdata$x:0000DBC9                 db    0
.xdata$x:0000DBCA                 db    0
.xdata$x:0000DBCB                 db    0
.xdata$x:0000DBCB _xdata$x        ends
.xdata$x:0000DBCB
.xdata$x:0000DBCC ; ===========================================================================
.xdata$x:0000DBCC
.xdata$x:0000DBCC ; Segment type: Pure data
.xdata$x:0000DBCC ; Segment permissions: Read
.xdata$x:0000DBCC _xdata$x        segment dword public 'DATA' use32
.xdata$x:0000DBCC                 assume cs:_xdata$x
.xdata$x:0000DBCC                 ;org 0DBCCh
.xdata$x:0000DBCC ; COMDAT (pick associative to section at B9B0)
.xdata$x:0000DBCC __unwindtable$?end@?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QBE?AV?$_String_const_iterator@V?$_String_val@U?$_Simple_types@_W@std@@@std@@@2@XZ db 0FFh
.xdata$x:0000DBCC                                         ; DATA XREF: .xdata$x:0000DBDCo
.xdata$x:0000DBCD                 db 0FFh
.xdata$x:0000DBCE                 db 0FFh
.xdata$x:0000DBCF                 db 0FFh
.xdata$x:0000DBD0                 dd offset __unwindfunclet$?end@?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QBE?AV?$_String_const_iterator@V?$_String_val@U?$_Simple_types@_W@std@@@std@@@2@XZ$0
.xdata$x:0000DBD4 __ehfuncinfo$?end@?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QBE?AV?$_String_const_iterator@V?$_String_val@U?$_Simple_types@_W@std@@@std@@@2@XZ db  22h ; "
.xdata$x:0000DBD4                                         ; DATA XREF: __ehhandler$?end@?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QBE?AV?$_String_const_iterator@V?$_String_val@U?$_Simple_types@_W@std@@@std@@@2@XZ+11o
.xdata$x:0000DBD5                 db    5
.xdata$x:0000DBD6                 db  93h ; ô
.xdata$x:0000DBD7                 db  19h
.xdata$x:0000DBD8                 db    1
.xdata$x:0000DBD9                 db    0
.xdata$x:0000DBDA                 db    0
.xdata$x:0000DBDB                 db    0
.xdata$x:0000DBDC                 dd offset __unwindtable$?end@?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QBE?AV?$_String_const_iterator@V?$_String_val@U?$_Simple_types@_W@std@@@std@@@2@XZ
.xdata$x:0000DBE0                 db    0
.xdata$x:0000DBE1                 db    0
.xdata$x:0000DBE2                 db    0
.xdata$x:0000DBE3                 db    0
.xdata$x:0000DBE4                 db    0
.xdata$x:0000DBE5                 db    0
.xdata$x:0000DBE6                 db    0
.xdata$x:0000DBE7                 db    0
.xdata$x:0000DBE8                 db    0
.xdata$x:0000DBE9                 db    0
.xdata$x:0000DBEA                 db    0
.xdata$x:0000DBEB                 db    0
.xdata$x:0000DBEC                 db    0
.xdata$x:0000DBED                 db    0
.xdata$x:0000DBEE                 db    0
.xdata$x:0000DBEF                 db    0
.xdata$x:0000DBF0                 db    0
.xdata$x:0000DBF1                 db    0
.xdata$x:0000DBF2                 db    0
.xdata$x:0000DBF3                 db    0
.xdata$x:0000DBF4                 db    0
.xdata$x:0000DBF5                 db    0
.xdata$x:0000DBF6                 db    0
.xdata$x:0000DBF7                 db    0
.xdata$x:0000DBF7 _xdata$x        ends
.xdata$x:0000DBF7
.xdata$x:0000DBF8 ; ===========================================================================
.xdata$x:0000DBF8
.xdata$x:0000DBF8 ; Segment type: Pure data
.xdata$x:0000DBF8 ; Segment permissions: Read
.xdata$x:0000DBF8 _xdata$x        segment dword public 'DATA' use32
.xdata$x:0000DBF8                 assume cs:_xdata$x
.xdata$x:0000DBF8                 ;org 0DBF8h
.xdata$x:0000DBF8 ; COMDAT (pick associative to section at C6C0)
.xdata$x:0000DBF8 __unwindtable$?push_back@?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QAEX_W@Z db 0FFh
.xdata$x:0000DBF8                                         ; DATA XREF: .xdata$x:0000DC10o
.xdata$x:0000DBF9                 db 0FFh
.xdata$x:0000DBFA                 db 0FFh
.xdata$x:0000DBFB                 db 0FFh
.xdata$x:0000DBFC                 dd offset __unwindfunclet$?push_back@?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QAEX_W@Z$0
.xdata$x:0000DC00                 db    0
.xdata$x:0000DC01                 db    0
.xdata$x:0000DC02                 db    0
.xdata$x:0000DC03                 db    0
.xdata$x:0000DC04                 dd offset __unwindfunclet$?push_back@?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QAEX_W@Z$1
.xdata$x:0000DC08 __ehfuncinfo$?push_back@?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QAEX_W@Z db  22h ; "
.xdata$x:0000DC08                                         ; DATA XREF: __ehhandler$?push_back@?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QAEX_W@Z+11o
.xdata$x:0000DC09                 db    5
.xdata$x:0000DC0A                 db  93h ; ô
.xdata$x:0000DC0B                 db  19h
.xdata$x:0000DC0C                 db    2
.xdata$x:0000DC0D                 db    0
.xdata$x:0000DC0E                 db    0
.xdata$x:0000DC0F                 db    0
.xdata$x:0000DC10                 dd offset __unwindtable$?push_back@?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QAEX_W@Z
.xdata$x:0000DC14                 db    0
.xdata$x:0000DC15                 db    0
.xdata$x:0000DC16                 db    0
.xdata$x:0000DC17                 db    0
.xdata$x:0000DC18                 db    0
.xdata$x:0000DC19                 db    0
.xdata$x:0000DC1A                 db    0
.xdata$x:0000DC1B                 db    0
.xdata$x:0000DC1C                 db    0
.xdata$x:0000DC1D                 db    0
.xdata$x:0000DC1E                 db    0
.xdata$x:0000DC1F                 db    0
.xdata$x:0000DC20                 db    0
.xdata$x:0000DC21                 db    0
.xdata$x:0000DC22                 db    0
.xdata$x:0000DC23                 db    0
.xdata$x:0000DC24                 db    0
.xdata$x:0000DC25                 db    0
.xdata$x:0000DC26                 db    0
.xdata$x:0000DC27                 db    0
.xdata$x:0000DC28                 db    0
.xdata$x:0000DC29                 db    0
.xdata$x:0000DC2A                 db    0
.xdata$x:0000DC2B                 db    0
.xdata$x:0000DC2B _xdata$x        ends
.xdata$x:0000DC2B
.xdata$x:0000DC2C ; ===========================================================================
.xdata$x:0000DC2C
.xdata$x:0000DC2C ; Segment type: Pure data
.xdata$x:0000DC2C ; Segment permissions: Read
.xdata$x:0000DC2C _xdata$x        segment dword public 'DATA' use32
.xdata$x:0000DC2C                 assume cs:_xdata$x
.xdata$x:0000DC2C                 ;org 0DC2Ch
.xdata$x:0000DC2C ; COMDAT (pick associative to section at D1FC)
.xdata$x:0000DC2C __unwindtable$?substr@?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QBE?AV12@II@Z db 0FFh
.xdata$x:0000DC2C                                         ; DATA XREF: .xdata$x:0000DC3Co
.xdata$x:0000DC2D                 db 0FFh
.xdata$x:0000DC2E                 db 0FFh
.xdata$x:0000DC2F                 db 0FFh
.xdata$x:0000DC30                 dd offset __unwindfunclet$?substr@?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QBE?AV12@II@Z$0
.xdata$x:0000DC34 __ehfuncinfo$?substr@?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QBE?AV12@II@Z db  22h ; "
.xdata$x:0000DC34                                         ; DATA XREF: __ehhandler$?substr@?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QBE?AV12@II@Z+11o
.xdata$x:0000DC35                 db    5
.xdata$x:0000DC36                 db  93h ; ô
.xdata$x:0000DC37                 db  19h
.xdata$x:0000DC38                 db    1
.xdata$x:0000DC39                 db    0
.xdata$x:0000DC3A                 db    0
.xdata$x:0000DC3B                 db    0
.xdata$x:0000DC3C                 dd offset __unwindtable$?substr@?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QBE?AV12@II@Z
.xdata$x:0000DC40                 db    0
.xdata$x:0000DC41                 db    0
.xdata$x:0000DC42                 db    0
.xdata$x:0000DC43                 db    0
.xdata$x:0000DC44                 db    0
.xdata$x:0000DC45                 db    0
.xdata$x:0000DC46                 db    0
.xdata$x:0000DC47                 db    0
.xdata$x:0000DC48                 db    0
.xdata$x:0000DC49                 db    0
.xdata$x:0000DC4A                 db    0
.xdata$x:0000DC4B                 db    0
.xdata$x:0000DC4C                 db    0
.xdata$x:0000DC4D                 db    0
.xdata$x:0000DC4E                 db    0
.xdata$x:0000DC4F                 db    0
.xdata$x:0000DC50                 db    0
.xdata$x:0000DC51                 db    0
.xdata$x:0000DC52                 db    0
.xdata$x:0000DC53                 db    0
.xdata$x:0000DC54                 db    0
.xdata$x:0000DC55                 db    0
.xdata$x:0000DC56                 db    0
.xdata$x:0000DC57                 db    0
.xdata$x:0000DC57 _xdata$x        ends
.xdata$x:0000DC57
.xdata$x:0000DC58 ; ===========================================================================
.xdata$x:0000DC58
.xdata$x:0000DC58 ; Segment type: Pure data
.xdata$x:0000DC58 ; Segment permissions: Read
.xdata$x:0000DC58 _xdata$x        segment dword public 'DATA' use32
.xdata$x:0000DC58                 assume cs:_xdata$x
.xdata$x:0000DC58                 ;org 0DC58h
.xdata$x:0000DC58 ; COMDAT (pick associative to section at 9578)
.xdata$x:0000DC58 __catchsym$?_Copy@?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QAEXII@Z$5 db    0
.xdata$x:0000DC58                                         ; DATA XREF: .xdata$x:0000DCE0o
.xdata$x:0000DC59                 db    0
.xdata$x:0000DC5A                 db    0
.xdata$x:0000DC5B                 db    0
.xdata$x:0000DC5C                 db    0
.xdata$x:0000DC5D                 db    0
.xdata$x:0000DC5E                 db    0
.xdata$x:0000DC5F                 db    0
.xdata$x:0000DC60                 db    0
.xdata$x:0000DC61                 db    0
.xdata$x:0000DC62                 db    0
.xdata$x:0000DC63                 db    0
.xdata$x:0000DC64                 dd offset __catch$?_Copy@?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QAEXII@Z$0
.xdata$x:0000DC68 __catchsym$?_Copy@?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QAEXII@Z$4 db    0
.xdata$x:0000DC68                                         ; DATA XREF: .xdata$x:0000DCCCo
.xdata$x:0000DC69                 db    0
.xdata$x:0000DC6A                 db    0
.xdata$x:0000DC6B                 db    0
.xdata$x:0000DC6C                 db    0
.xdata$x:0000DC6D                 db    0
.xdata$x:0000DC6E                 db    0
.xdata$x:0000DC6F                 db    0
.xdata$x:0000DC70                 db    0
.xdata$x:0000DC71                 db    0
.xdata$x:0000DC72                 db    0
.xdata$x:0000DC73                 db    0
.xdata$x:0000DC74                 dd offset __catch$?_Copy@?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QAEXII@Z$1
.xdata$x:0000DC78 __unwindtable$?_Copy@?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QAEXII@Z db 0FFh
.xdata$x:0000DC78                                         ; DATA XREF: .xdata$x:0000DCA0o
.xdata$x:0000DC79                 db 0FFh
.xdata$x:0000DC7A                 db 0FFh
.xdata$x:0000DC7B                 db 0FFh
.xdata$x:0000DC7C                 db    0
.xdata$x:0000DC7D                 db    0
.xdata$x:0000DC7E                 db    0
.xdata$x:0000DC7F                 db    0
.xdata$x:0000DC80                 db 0FFh
.xdata$x:0000DC81                 db 0FFh
.xdata$x:0000DC82                 db 0FFh
.xdata$x:0000DC83                 db 0FFh
.xdata$x:0000DC84                 db    0
.xdata$x:0000DC85                 db    0
.xdata$x:0000DC86                 db    0
.xdata$x:0000DC87                 db    0
.xdata$x:0000DC88                 db    1
.xdata$x:0000DC89                 db    0
.xdata$x:0000DC8A                 db    0
.xdata$x:0000DC8B                 db    0
.xdata$x:0000DC8C                 db    0
.xdata$x:0000DC8D                 db    0
.xdata$x:0000DC8E                 db    0
.xdata$x:0000DC8F                 db    0
.xdata$x:0000DC90                 db    1
.xdata$x:0000DC91                 db    0
.xdata$x:0000DC92                 db    0
.xdata$x:0000DC93                 db    0
.xdata$x:0000DC94                 db    0
.xdata$x:0000DC95                 db    0
.xdata$x:0000DC96                 db    0
.xdata$x:0000DC97                 db    0
.xdata$x:0000DC98 __ehfuncinfo$?_Copy@?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QAEXII@Z db  22h ; "
.xdata$x:0000DC98                                         ; DATA XREF: __ehhandler$?_Copy@?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QAEXII@Z+11o
.xdata$x:0000DC99                 db    5
.xdata$x:0000DC9A                 db  93h ; ô
.xdata$x:0000DC9B                 db  19h
.xdata$x:0000DC9C                 db    4
.xdata$x:0000DC9D                 db    0
.xdata$x:0000DC9E                 db    0
.xdata$x:0000DC9F                 db    0
.xdata$x:0000DCA0                 dd offset __unwindtable$?_Copy@?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QAEXII@Z
.xdata$x:0000DCA4                 db    2
.xdata$x:0000DCA5                 db    0
.xdata$x:0000DCA6                 db    0
.xdata$x:0000DCA7                 db    0
.xdata$x:0000DCA8                 dd offset __tryblocktable$?_Copy@?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QAEXII@Z
.xdata$x:0000DCAC                 db    0
.xdata$x:0000DCAD                 db    0
.xdata$x:0000DCAE                 db    0
.xdata$x:0000DCAF                 db    0
.xdata$x:0000DCB0                 db    0
.xdata$x:0000DCB1                 db    0
.xdata$x:0000DCB2                 db    0
.xdata$x:0000DCB3                 db    0
.xdata$x:0000DCB4                 db    0
.xdata$x:0000DCB5                 db    0
.xdata$x:0000DCB6                 db    0
.xdata$x:0000DCB7                 db    0
.xdata$x:0000DCB8                 db    0
.xdata$x:0000DCB9                 db    0
.xdata$x:0000DCBA                 db    0
.xdata$x:0000DCBB                 db    0
.xdata$x:0000DCBC __tryblocktable$?_Copy@?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QAEXII@Z db    2
.xdata$x:0000DCBC                                         ; DATA XREF: .xdata$x:0000DCA8o
.xdata$x:0000DCBD                 db    0
.xdata$x:0000DCBE                 db    0
.xdata$x:0000DCBF                 db    0
.xdata$x:0000DCC0                 db    2
.xdata$x:0000DCC1                 db    0
.xdata$x:0000DCC2                 db    0
.xdata$x:0000DCC3                 db    0
.xdata$x:0000DCC4                 db    3
.xdata$x:0000DCC5                 db    0
.xdata$x:0000DCC6                 db    0
.xdata$x:0000DCC7                 db    0
.xdata$x:0000DCC8                 db    1
.xdata$x:0000DCC9                 db    0
.xdata$x:0000DCCA                 db    0
.xdata$x:0000DCCB                 db    0
.xdata$x:0000DCCC                 dd offset __catchsym$?_Copy@?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QAEXII@Z$4
.xdata$x:0000DCD0                 db    0
.xdata$x:0000DCD1                 db    0
.xdata$x:0000DCD2                 db    0
.xdata$x:0000DCD3                 db    0
.xdata$x:0000DCD4                 db    0
.xdata$x:0000DCD5                 db    0
.xdata$x:0000DCD6                 db    0
.xdata$x:0000DCD7                 db    0
.xdata$x:0000DCD8                 db    3
.xdata$x:0000DCD9                 db    0
.xdata$x:0000DCDA                 db    0
.xdata$x:0000DCDB                 db    0
.xdata$x:0000DCDC                 db    1
.xdata$x:0000DCDD                 db    0
.xdata$x:0000DCDE                 db    0
.xdata$x:0000DCDF                 db    0
.xdata$x:0000DCE0                 dd offset __catchsym$?_Copy@?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QAEXII@Z$5
.xdata$x:0000DCE0 _xdata$x        ends
.xdata$x:0000DCE0
.xdata$x:0000DCE4 ; ===========================================================================
.xdata$x:0000DCE4
.xdata$x:0000DCE4 ; Segment type: Pure data
.xdata$x:0000DCE4 ; Segment permissions: Read
.xdata$x:0000DCE4 _xdata$x        segment dword public 'DATA' use32
.xdata$x:0000DCE4                 assume cs:_xdata$x
.xdata$x:0000DCE4                 ;org 0DCE4h
.xdata$x:0000DCE4 ; COMDAT (pick associative to section at A150)
.xdata$x:0000DCE4 __unwindtable$?_Pdif@?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@SAIV?$_String_const_iterator@V?$_String_val@U?$_Simple_types@_W@std@@@std@@@2@0@Z db 0FFh
.xdata$x:0000DCE4                                         ; DATA XREF: .xdata$x:0000DCFCo
.xdata$x:0000DCE5                 db 0FFh
.xdata$x:0000DCE6                 db 0FFh
.xdata$x:0000DCE7                 db 0FFh
.xdata$x:0000DCE8                 dd offset __unwindfunclet$?_Pdif@?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@SAIV?$_String_const_iterator@V?$_String_val@U?$_Simple_types@_W@std@@@std@@@2@0@Z$0
.xdata$x:0000DCEC                 align 10h
.xdata$x:0000DCF0                 dd offset __unwindfunclet$?_Pdif@?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@SAIV?$_String_const_iterator@V?$_String_val@U?$_Simple_types@_W@std@@@std@@@2@0@Z$1
.xdata$x:0000DCF4 __ehfuncinfo$?_Pdif@?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@SAIV?$_String_const_iterator@V?$_String_val@U?$_Simple_types@_W@std@@@std@@@2@0@Z db  22h ; "
.xdata$x:0000DCF4                                         ; DATA XREF: __ehhandler$?_Pdif@?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@SAIV?$_String_const_iterator@V?$_String_val@U?$_Simple_types@_W@std@@@std@@@2@0@Z+11o
.xdata$x:0000DCF5                 db    5
.xdata$x:0000DCF6                 db  93h ; ô
.xdata$x:0000DCF7                 db  19h
.xdata$x:0000DCF8                 db    2
.xdata$x:0000DCF9                 db    0
.xdata$x:0000DCFA                 db    0
.xdata$x:0000DCFB                 db    0
.xdata$x:0000DCFC                 dd offset __unwindtable$?_Pdif@?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@SAIV?$_String_const_iterator@V?$_String_val@U?$_Simple_types@_W@std@@@std@@@2@0@Z
.xdata$x:0000DD00                 db    0
.xdata$x:0000DD01                 db    0
.xdata$x:0000DD02                 db    0
.xdata$x:0000DD03                 db    0
.xdata$x:0000DD04                 db    0
.xdata$x:0000DD05                 db    0
.xdata$x:0000DD06                 db    0
.xdata$x:0000DD07                 db    0
.xdata$x:0000DD08                 db    0
.xdata$x:0000DD09                 db    0
.xdata$x:0000DD0A                 db    0
.xdata$x:0000DD0B                 db    0
.xdata$x:0000DD0C                 db    0
.xdata$x:0000DD0D                 db    0
.xdata$x:0000DD0E                 db    0
.xdata$x:0000DD0F                 db    0
.xdata$x:0000DD10                 db    0
.xdata$x:0000DD11                 db    0
.xdata$x:0000DD12                 db    0
.xdata$x:0000DD13                 db    0
.xdata$x:0000DD14                 db    0
.xdata$x:0000DD15                 db    0
.xdata$x:0000DD16                 db    0
.xdata$x:0000DD17                 db    0
.xdata$x:0000DD17 _xdata$x        ends
.xdata$x:0000DD17
.xdata$x:0000DD18 ; ===========================================================================
.xdata$x:0000DD18
.xdata$x:0000DD18 ; Segment type: Pure data
.xdata$x:0000DD18 ; Segment permissions: Read
.xdata$x:0000DD18 _xdata$x        segment dword public 'DATA' use32
.xdata$x:0000DD18                 assume cs:_xdata$x
.xdata$x:0000DD18                 ;org 0DD18h
.xdata$x:0000DD18 __unwindtable$?stringTakeWhileAdmissable@@YA?AV?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@ABV12@0@Z db 0FFh
.xdata$x:0000DD18                                         ; DATA XREF: .xdata$x:0000DE64o
.xdata$x:0000DD19                 db 0FFh
.xdata$x:0000DD1A                 db 0FFh
.xdata$x:0000DD1B                 db 0FFh
.xdata$x:0000DD1C                 dd offset __unwindfunclet$?stringTakeWhileAdmissable@@YA?AV?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@ABV12@0@Z$0
.xdata$x:0000DD20 __unwindtable$?PathAppendW@@YA?AV?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@AAV12@ABV12@@Z db 0FFh
.xdata$x:0000DD20                                         ; DATA XREF: .xdata$x:0000DF18o
.xdata$x:0000DD21                 db 0FFh
.xdata$x:0000DD22                 db 0FFh
.xdata$x:0000DD23                 db 0FFh
.xdata$x:0000DD24                 dd offset __unwindfunclet$?PathAppendW@@YA?AV?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@AAV12@ABV12@@Z$0
.xdata$x:0000DD28 __unwindtable$?PathRemoveFileSpecW@@YA?AV?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@AAV12@@Z db 0FFh
.xdata$x:0000DD28                                         ; DATA XREF: .xdata$x:0000DF3Co
.xdata$x:0000DD29                 db 0FFh
.xdata$x:0000DD2A                 db 0FFh
.xdata$x:0000DD2B                 db 0FFh
.xdata$x:0000DD2C                 dd offset __unwindfunclet$?PathRemoveFileSpecW@@YA?AV?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@AAV12@@Z$0
.xdata$x:0000DD30 __unwindtable$?purgeMenuItemString@@YA?AV?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@PB_W_N@Z db 0FFh
.xdata$x:0000DD30                                         ; DATA XREF: .xdata$x:0000E038o
.xdata$x:0000DD31                 db 0FFh
.xdata$x:0000DD32                 db 0FFh
.xdata$x:0000DD33                 db 0FFh
.xdata$x:0000DD34                 dd offset __unwindfunclet$?purgeMenuItemString@@YA?AV?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@PB_W_N@Z$0
.xdata$x:0000DD38 __unwindtable$?stodLocale@@YANABV?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@PAUlocaleinfo_struct@@PAI@Z db 0FFh
.xdata$x:0000DD38                                         ; DATA XREF: .xdata$x:0000DE40o
.xdata$x:0000DD39                 db 0FFh
.xdata$x:0000DD3A                 db 0FFh
.xdata$x:0000DD3B                 db 0FFh
.xdata$x:0000DD3C                 dd offset __unwindfunclet$?stodLocale@@YANABV?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@PAUlocaleinfo_struct@@PAI@Z$0
.xdata$x:0000DD40                 db 0FFh
.xdata$x:0000DD41                 db 0FFh
.xdata$x:0000DD42                 db 0FFh
.xdata$x:0000DD43                 db 0FFh
.xdata$x:0000DD44                 dd offset __unwindfunclet$?stodLocale@@YANABV?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@PAUlocaleinfo_struct@@PAI@Z$1
.xdata$x:0000DD48 __unwindtable$?stringJoin@@YA?AV?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@ABV?$vector@V?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@V?$allocator@V?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@@2@@2@ABV12@@Z db 0FFh
.xdata$x:0000DD48                                         ; DATA XREF: .xdata$x:0000DE88o
.xdata$x:0000DD49                 db 0FFh
.xdata$x:0000DD4A                 db 0FFh
.xdata$x:0000DD4B                 db 0FFh
.xdata$x:0000DD4C                 dd offset __unwindfunclet$?stringJoin@@YA?AV?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@ABV?$vector@V?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@V?$allocator@V?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@@2@@2@ABV12@@Z$1
.xdata$x:0000DD50                 db    0
.xdata$x:0000DD51                 db    0
.xdata$x:0000DD52                 db    0
.xdata$x:0000DD53                 db    0
.xdata$x:0000DD54                 dd offset __unwindfunclet$?stringJoin@@YA?AV?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@ABV?$vector@V?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@V?$allocator@V?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@@2@@2@ABV12@@Z$0
.xdata$x:0000DD58 __unwindtable$?stringReplace@@YA?AV?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@V12@ABV12@1@Z db 0FFh
.xdata$x:0000DD58                                         ; DATA XREF: .xdata$x:0000DED0o
.xdata$x:0000DD59                 db 0FFh
.xdata$x:0000DD5A                 db 0FFh
.xdata$x:0000DD5B                 db 0FFh
.xdata$x:0000DD5C                 dd offset __unwindfunclet$?stringReplace@@YA?AV?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@V12@ABV12@1@Z$1
.xdata$x:0000DD60                 db    0
.xdata$x:0000DD61                 db    0
.xdata$x:0000DD62                 db    0
.xdata$x:0000DD63                 db    0
.xdata$x:0000DD64                 dd offset __unwindfunclet$?stringReplace@@YA?AV?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@V12@ABV12@1@Z$0
.xdata$x:0000DD68 __unwindtable$?relativeFilePathToFullFilePath@@YA?AV?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@PB_W@Z db 0FFh
.xdata$x:0000DD68                                         ; DATA XREF: .xdata$x:0000DF60o
.xdata$x:0000DD69                 db 0FFh
.xdata$x:0000DD6A                 db 0FFh
.xdata$x:0000DD6B                 db 0FFh
.xdata$x:0000DD6C                 dd offset __unwindfunclet$?relativeFilePathToFullFilePath@@YA?AV?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@PB_W@Z$1
.xdata$x:0000DD70                 db    0
.xdata$x:0000DD71                 db    0
.xdata$x:0000DD72                 db    0
.xdata$x:0000DD73                 db    0
.xdata$x:0000DD74                 dd offset __unwindfunclet$?relativeFilePathToFullFilePath@@YA?AV?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@PB_W@Z$0
.xdata$x:0000DD78 __unwindtable$?getFileContent@@YA?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@PB_W@Z db 0FFh
.xdata$x:0000DD78                                         ; DATA XREF: .xdata$x:0000DF84o
.xdata$x:0000DD79                 db 0FFh
.xdata$x:0000DD7A                 db 0FFh
.xdata$x:0000DD7B                 db 0FFh
.xdata$x:0000DD7C                 dd offset __unwindfunclet$?getFileContent@@YA?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@PB_W@Z$1
.xdata$x:0000DD80                 db    0
.xdata$x:0000DD81                 db    0
.xdata$x:0000DD82                 db    0
.xdata$x:0000DD83                 db    0
.xdata$x:0000DD84                 dd offset __unwindfunclet$?getFileContent@@YA?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@PB_W@Z$0
.xdata$x:0000DD88 __unwindtable$?wstring2string@@YA?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@ABV?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@2@I@Z db 0FFh
.xdata$x:0000DD88                                         ; DATA XREF: .xdata$x:0000DFCCo
.xdata$x:0000DD89                 db 0FFh
.xdata$x:0000DD8A                 db 0FFh
.xdata$x:0000DD8B                 db 0FFh
.xdata$x:0000DD8C                 dd offset __unwindfunclet$?wstring2string@@YA?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@ABV?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@2@I@Z$1
.xdata$x:0000DD90                 db    0
.xdata$x:0000DD91                 db    0
.xdata$x:0000DD92                 db    0
.xdata$x:0000DD93                 db    0
.xdata$x:0000DD94                 dd offset __unwindfunclet$?wstring2string@@YA?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@ABV?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@2@I@Z$0
.xdata$x:0000DD98 __unwindtable$?string2wstring@@YA?AV?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@ABV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@2@I@Z db 0FFh
.xdata$x:0000DD98                                         ; DATA XREF: .xdata$x:0000DFF0o
.xdata$x:0000DD99                 db 0FFh
.xdata$x:0000DD9A                 db 0FFh
.xdata$x:0000DD9B                 db 0FFh
.xdata$x:0000DD9C                 dd offset __unwindfunclet$?string2wstring@@YA?AV?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@ABV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@2@I@Z$1
.xdata$x:0000DDA0                 db    0
.xdata$x:0000DDA1                 db    0
.xdata$x:0000DDA2                 db    0
.xdata$x:0000DDA3                 db    0
.xdata$x:0000DDA4                 dd offset __unwindfunclet$?string2wstring@@YA?AV?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@ABV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@2@I@Z$0
.xdata$x:0000DDA8 __unwindtable$?getFolderName@@YA?AV?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@PAUHWND__@@PB_W@Z db 0FFh
.xdata$x:0000DDA8                                         ; DATA XREF: .xdata$x:0000E05Co
.xdata$x:0000DDA9                 db 0FFh
.xdata$x:0000DDAA                 db 0FFh
.xdata$x:0000DDAB                 db 0FFh
.xdata$x:0000DDAC                 dd offset __unwindfunclet$?getFolderName@@YA?AV?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@PAUHWND__@@PB_W@Z$1
.xdata$x:0000DDB0                 db    0
.xdata$x:0000DDB1                 db    0
.xdata$x:0000DDB2                 db    0
.xdata$x:0000DDB3                 db    0
.xdata$x:0000DDB4                 dd offset __unwindfunclet$?getFolderName@@YA?AV?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@PAUHWND__@@PB_W@Z$0
.xdata$x:0000DDB8 __unwindtable$?tokenizeString@@YA?AV?$vector@V?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@V?$allocator@V?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@@2@@std@@ABV?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@2@D@Z db 0FFh
.xdata$x:0000DDB8                                         ; DATA XREF: .xdata$x:0000E014o
.xdata$x:0000DDB9                 db 0FFh
.xdata$x:0000DDBA                 db 0FFh
.xdata$x:0000DDBB                 db 0FFh
.xdata$x:0000DDBC                 dd offset __unwindfunclet$?tokenizeString@@YA?AV?$vector@V?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@V?$allocator@V?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@@2@@std@@ABV?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@2@D@Z$2
.xdata$x:0000DDC0                 db    0
.xdata$x:0000DDC1                 db    0
.xdata$x:0000DDC2                 db    0
.xdata$x:0000DDC3                 db    0
.xdata$x:0000DDC4                 dd offset __unwindfunclet$?tokenizeString@@YA?AV?$vector@V?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@V?$allocator@V?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@@2@@std@@ABV?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@2@D@Z$0
.xdata$x:0000DDC8                 db    1
.xdata$x:0000DDC9                 db    0
.xdata$x:0000DDCA                 db    0
.xdata$x:0000DDCB                 db    0
.xdata$x:0000DDCC                 dd offset __unwindfunclet$?tokenizeString@@YA?AV?$vector@V?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@V?$allocator@V?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@@2@@std@@ABV?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@2@D@Z$1
.xdata$x:0000DDD0 __unwindtable$?stringSplit@@YA?AV?$vector@V?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@V?$allocator@V?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@@2@@std@@ABV?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@2@0@Z db 0FFh
.xdata$x:0000DDD0                                         ; DATA XREF: .xdata$x:0000DEACo
.xdata$x:0000DDD1                 db 0FFh
.xdata$x:0000DDD2                 db 0FFh
.xdata$x:0000DDD3                 db 0FFh
.xdata$x:0000DDD4                 dd offset __unwindfunclet$?stringSplit@@YA?AV?$vector@V?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@V?$allocator@V?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@@2@@std@@ABV?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@2@0@Z$3
.xdata$x:0000DDD8                 db    0
.xdata$x:0000DDD9                 db    0
.xdata$x:0000DDDA                 db    0
.xdata$x:0000DDDB                 db    0
.xdata$x:0000DDDC                 dd offset __unwindfunclet$?stringSplit@@YA?AV?$vector@V?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@V?$allocator@V?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@@2@@std@@ABV?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@2@0@Z$0
.xdata$x:0000DDE0                 db    1
.xdata$x:0000DDE1                 db    0
.xdata$x:0000DDE2                 db    0
.xdata$x:0000DDE3                 db    0
.xdata$x:0000DDE4                 dd offset __unwindfunclet$?stringSplit@@YA?AV?$vector@V?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@V?$allocator@V?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@@2@@std@@ABV?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@2@0@Z$1
.xdata$x:0000DDE8                 db    1
.xdata$x:0000DDE9                 db    0
.xdata$x:0000DDEA                 db    0
.xdata$x:0000DDEB                 db    0
.xdata$x:0000DDEC                 dd offset __unwindfunclet$?stringSplit@@YA?AV?$vector@V?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@V?$allocator@V?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@@2@@std@@ABV?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@2@0@Z$2
.xdata$x:0000DDF0 __ehfuncinfo$?uintToString@@YA?AV?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@I@Z db  22h ; "
.xdata$x:0000DDF0                                         ; DATA XREF: __ehhandler$?uintToString@@YA?AV?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@I@Z+1Bo
.xdata$x:0000DDF1                 db    5
.xdata$x:0000DDF2                 db  93h ; ô
.xdata$x:0000DDF3                 db  19h
.xdata$x:0000DDF4                 db    5
.xdata$x:0000DDF5                 db    0
.xdata$x:0000DDF6                 db    0
.xdata$x:0000DDF7                 db    0
.xdata$x:0000DDF8                 dd offset __unwindtable$?uintToString@@YA?AV?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@I@Z
.xdata$x:0000DDFC                 db    0
.xdata$x:0000DDFD                 db    0
.xdata$x:0000DDFE                 db    0
.xdata$x:0000DDFF                 db    0
.xdata$x:0000DE00                 db    0
.xdata$x:0000DE01                 db    0
.xdata$x:0000DE02                 db    0
.xdata$x:0000DE03                 db    0
.xdata$x:0000DE04                 db    0
.xdata$x:0000DE05                 db    0
.xdata$x:0000DE06                 db    0
.xdata$x:0000DE07                 db    0
.xdata$x:0000DE08                 db    0
.xdata$x:0000DE09                 db    0
.xdata$x:0000DE0A                 db    0
.xdata$x:0000DE0B                 db    0
.xdata$x:0000DE0C                 db    0
.xdata$x:0000DE0D                 db    0
.xdata$x:0000DE0E                 db    0
.xdata$x:0000DE0F                 db    0
.xdata$x:0000DE10                 db    0
.xdata$x:0000DE11                 db    0
.xdata$x:0000DE12                 db    0
.xdata$x:0000DE13                 db    0
.xdata$x:0000DE14 __ehfuncinfo$?intToString@@YA?AV?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@H@Z db  22h ; "
.xdata$x:0000DE14                                         ; DATA XREF: __ehhandler$?intToString@@YA?AV?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@H@Z+1Bo
.xdata$x:0000DE15                 db    5
.xdata$x:0000DE16                 db  93h ; ô
.xdata$x:0000DE17                 db  19h
.xdata$x:0000DE18                 db    5
.xdata$x:0000DE19                 db    0
.xdata$x:0000DE1A                 db    0
.xdata$x:0000DE1B                 db    0
.xdata$x:0000DE1C                 dd offset __unwindtable$?intToString@@YA?AV?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@H@Z
.xdata$x:0000DE20                 db    0
.xdata$x:0000DE21                 db    0
.xdata$x:0000DE22                 db    0
.xdata$x:0000DE23                 db    0
.xdata$x:0000DE24                 db    0
.xdata$x:0000DE25                 db    0
.xdata$x:0000DE26                 db    0
.xdata$x:0000DE27                 db    0
.xdata$x:0000DE28                 db    0
.xdata$x:0000DE29                 db    0
.xdata$x:0000DE2A                 db    0
.xdata$x:0000DE2B                 db    0
.xdata$x:0000DE2C                 db    0
.xdata$x:0000DE2D                 db    0
.xdata$x:0000DE2E                 db    0
.xdata$x:0000DE2F                 db    0
.xdata$x:0000DE30                 db    0
.xdata$x:0000DE31                 db    0
.xdata$x:0000DE32                 db    0
.xdata$x:0000DE33                 db    0
.xdata$x:0000DE34                 db    0
.xdata$x:0000DE35                 db    0
.xdata$x:0000DE36                 db    0
.xdata$x:0000DE37                 db    0
.xdata$x:0000DE38 __ehfuncinfo$?stodLocale@@YANABV?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@PAUlocaleinfo_struct@@PAI@Z db  22h ; "
.xdata$x:0000DE38                                         ; DATA XREF: __ehhandler$?stodLocale@@YANABV?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@PAUlocaleinfo_struct@@PAI@Z+11o
.xdata$x:0000DE39                 db    5
.xdata$x:0000DE3A                 db  93h ; ô
.xdata$x:0000DE3B                 db  19h
.xdata$x:0000DE3C                 db    2
.xdata$x:0000DE3D                 db    0
.xdata$x:0000DE3E                 db    0
.xdata$x:0000DE3F                 db    0
.xdata$x:0000DE40                 dd offset __unwindtable$?stodLocale@@YANABV?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@PAUlocaleinfo_struct@@PAI@Z
.xdata$x:0000DE44                 db    0
.xdata$x:0000DE45                 db    0
.xdata$x:0000DE46                 db    0
.xdata$x:0000DE47                 db    0
.xdata$x:0000DE48                 db    0
.xdata$x:0000DE49                 db    0
.xdata$x:0000DE4A                 db    0
.xdata$x:0000DE4B                 db    0
.xdata$x:0000DE4C                 db    0
.xdata$x:0000DE4D                 db    0
.xdata$x:0000DE4E                 db    0
.xdata$x:0000DE4F                 db    0
.xdata$x:0000DE50                 db    0
.xdata$x:0000DE51                 db    0
.xdata$x:0000DE52                 db    0
.xdata$x:0000DE53                 db    0
.xdata$x:0000DE54                 db    0
.xdata$x:0000DE55                 db    0
.xdata$x:0000DE56                 db    0
.xdata$x:0000DE57                 db    0
.xdata$x:0000DE58                 db    0
.xdata$x:0000DE59                 db    0
.xdata$x:0000DE5A                 db    0
.xdata$x:0000DE5B                 db    0
.xdata$x:0000DE5C __ehfuncinfo$?stringTakeWhileAdmissable@@YA?AV?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@ABV12@0@Z db  22h ; "
.xdata$x:0000DE5C                                         ; DATA XREF: __ehhandler$?stringTakeWhileAdmissable@@YA?AV?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@ABV12@0@Z+11o
.xdata$x:0000DE5D                 db    5
.xdata$x:0000DE5E                 db  93h ; ô
.xdata$x:0000DE5F                 db  19h
.xdata$x:0000DE60                 db    1
.xdata$x:0000DE61                 db    0
.xdata$x:0000DE62                 db    0
.xdata$x:0000DE63                 db    0
.xdata$x:0000DE64                 dd offset __unwindtable$?stringTakeWhileAdmissable@@YA?AV?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@ABV12@0@Z
.xdata$x:0000DE68                 align 20h
.xdata$x:0000DE80 __ehfuncinfo$?stringJoin@@YA?AV?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@ABV?$vector@V?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@V?$allocator@V?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@@2@@2@ABV12@@Z db  22h ; "
.xdata$x:0000DE80                                         ; DATA XREF: __ehhandler$?stringJoin@@YA?AV?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@ABV?$vector@V?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@V?$allocator@V?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@@2@@2@ABV12@@Z+1Bo
.xdata$x:0000DE81                 db    5
.xdata$x:0000DE82                 db  93h ; ô
.xdata$x:0000DE83                 db  19h
.xdata$x:0000DE84                 db    2
.xdata$x:0000DE85                 db    0
.xdata$x:0000DE86                 db    0
.xdata$x:0000DE87                 db    0
.xdata$x:0000DE88                 dd offset __unwindtable$?stringJoin@@YA?AV?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@ABV?$vector@V?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@V?$allocator@V?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@@2@@2@ABV12@@Z
.xdata$x:0000DE8C                 db    0
.xdata$x:0000DE8D                 db    0
.xdata$x:0000DE8E                 db    0
.xdata$x:0000DE8F                 db    0
.xdata$x:0000DE90                 db    0
.xdata$x:0000DE91                 db    0
.xdata$x:0000DE92                 db    0
.xdata$x:0000DE93                 db    0
.xdata$x:0000DE94                 db    0
.xdata$x:0000DE95                 db    0
.xdata$x:0000DE96                 db    0
.xdata$x:0000DE97                 db    0
.xdata$x:0000DE98                 db    0
.xdata$x:0000DE99                 db    0
.xdata$x:0000DE9A                 db    0
.xdata$x:0000DE9B                 db    0
.xdata$x:0000DE9C                 db    0
.xdata$x:0000DE9D                 db    0
.xdata$x:0000DE9E                 db    0
.xdata$x:0000DE9F                 db    0
.xdata$x:0000DEA0                 db    0
.xdata$x:0000DEA1                 db    0
.xdata$x:0000DEA2                 db    0
.xdata$x:0000DEA3                 db    0
.xdata$x:0000DEA4 __ehfuncinfo$?stringSplit@@YA?AV?$vector@V?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@V?$allocator@V?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@@2@@std@@ABV?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@2@0@Z db  22h ; "
.xdata$x:0000DEA4                                         ; DATA XREF: __ehhandler$?stringSplit@@YA?AV?$vector@V?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@V?$allocator@V?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@@2@@std@@ABV?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@2@0@Z+1Bo
.xdata$x:0000DEA5                 db    5
.xdata$x:0000DEA6                 db  93h ; ô
.xdata$x:0000DEA7                 db  19h
.xdata$x:0000DEA8                 db    4
.xdata$x:0000DEA9                 db    0
.xdata$x:0000DEAA                 db    0
.xdata$x:0000DEAB                 db    0
.xdata$x:0000DEAC                 dd offset __unwindtable$?stringSplit@@YA?AV?$vector@V?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@V?$allocator@V?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@@2@@std@@ABV?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@2@0@Z
.xdata$x:0000DEB0                 db    0
.xdata$x:0000DEB1                 db    0
.xdata$x:0000DEB2                 db    0
.xdata$x:0000DEB3                 db    0
.xdata$x:0000DEB4                 db    0
.xdata$x:0000DEB5                 db    0
.xdata$x:0000DEB6                 db    0
.xdata$x:0000DEB7                 db    0
.xdata$x:0000DEB8                 db    0
.xdata$x:0000DEB9                 db    0
.xdata$x:0000DEBA                 db    0
.xdata$x:0000DEBB                 db    0
.xdata$x:0000DEBC                 db    0
.xdata$x:0000DEBD                 db    0
.xdata$x:0000DEBE                 db    0
.xdata$x:0000DEBF                 db    0
.xdata$x:0000DEC0                 db    0
.xdata$x:0000DEC1                 db    0
.xdata$x:0000DEC2                 db    0
.xdata$x:0000DEC3                 db    0
.xdata$x:0000DEC4                 db    0
.xdata$x:0000DEC5                 db    0
.xdata$x:0000DEC6                 db    0
.xdata$x:0000DEC7                 db    0
.xdata$x:0000DEC8 __ehfuncinfo$?stringReplace@@YA?AV?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@V12@ABV12@1@Z db  22h ; "
.xdata$x:0000DEC8                                         ; DATA XREF: __ehhandler$?stringReplace@@YA?AV?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@V12@ABV12@1@Z+11o
.xdata$x:0000DEC9                 db    5
.xdata$x:0000DECA                 db  93h ; ô
.xdata$x:0000DECB                 db  19h
.xdata$x:0000DECC                 db    2
.xdata$x:0000DECD                 db    0
.xdata$x:0000DECE                 db    0
.xdata$x:0000DECF                 db    0
.xdata$x:0000DED0                 dd offset __unwindtable$?stringReplace@@YA?AV?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@V12@ABV12@1@Z
.xdata$x:0000DED4                 db    0
.xdata$x:0000DED5                 db    0
.xdata$x:0000DED6                 db    0
.xdata$x:0000DED7                 db    0
.xdata$x:0000DED8                 db    0
.xdata$x:0000DED9                 db    0
.xdata$x:0000DEDA                 db    0
.xdata$x:0000DEDB                 db    0
.xdata$x:0000DEDC                 db    0
.xdata$x:0000DEDD                 db    0
.xdata$x:0000DEDE                 db    0
.xdata$x:0000DEDF                 db    0
.xdata$x:0000DEE0                 db    0
.xdata$x:0000DEE1                 db    0
.xdata$x:0000DEE2                 db    0
.xdata$x:0000DEE3                 db    0
.xdata$x:0000DEE4                 db    0
.xdata$x:0000DEE5                 db    0
.xdata$x:0000DEE6                 db    0
.xdata$x:0000DEE7                 db    0
.xdata$x:0000DEE8                 db    0
.xdata$x:0000DEE9                 db    0
.xdata$x:0000DEEA                 db    0
.xdata$x:0000DEEB                 db    0
.xdata$x:0000DEEC __ehfuncinfo$?stringToUpper@@YA?AV?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@V12@@Z db  22h ; "
.xdata$x:0000DEEC                                         ; DATA XREF: __ehhandler$?stringToUpper@@YA?AV?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@V12@@Z+11o
.xdata$x:0000DEED                 db    5
.xdata$x:0000DEEE                 db  93h ; ô
.xdata$x:0000DEEF                 db  19h
.xdata$x:0000DEF0                 db    5
.xdata$x:0000DEF1                 db    0
.xdata$x:0000DEF2                 db    0
.xdata$x:0000DEF3                 db    0
.xdata$x:0000DEF4                 dd offset __unwindtable$?stringToUpper@@YA?AV?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@V12@@Z
.xdata$x:0000DEF8                 db    0
.xdata$x:0000DEF9                 db    0
.xdata$x:0000DEFA                 db    0
.xdata$x:0000DEFB                 db    0
.xdata$x:0000DEFC                 db    0
.xdata$x:0000DEFD                 db    0
.xdata$x:0000DEFE                 db    0
.xdata$x:0000DEFF                 db    0
.xdata$x:0000DF00                 db    0
.xdata$x:0000DF01                 db    0
.xdata$x:0000DF02                 db    0
.xdata$x:0000DF03                 db    0
.xdata$x:0000DF04                 db    0
.xdata$x:0000DF05                 db    0
.xdata$x:0000DF06                 db    0
.xdata$x:0000DF07                 db    0
.xdata$x:0000DF08                 db    0
.xdata$x:0000DF09                 db    0
.xdata$x:0000DF0A                 db    0
.xdata$x:0000DF0B                 db    0
.xdata$x:0000DF0C                 db    0
.xdata$x:0000DF0D                 db    0
.xdata$x:0000DF0E                 db    0
.xdata$x:0000DF0F                 db    0
.xdata$x:0000DF10 __ehfuncinfo$?PathAppendW@@YA?AV?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@AAV12@ABV12@@Z db  22h ; "
.xdata$x:0000DF10                                         ; DATA XREF: __ehhandler$?PathAppendW@@YA?AV?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@AAV12@ABV12@@Z+11o
.xdata$x:0000DF11                 db    5
.xdata$x:0000DF12                 db  93h ; ô
.xdata$x:0000DF13                 db  19h
.xdata$x:0000DF14                 db    1
.xdata$x:0000DF15                 db    0
.xdata$x:0000DF16                 db    0
.xdata$x:0000DF17                 db    0
.xdata$x:0000DF18                 dd offset __unwindtable$?PathAppendW@@YA?AV?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@AAV12@ABV12@@Z
.xdata$x:0000DF1C                 db    0
.xdata$x:0000DF1D                 db    0
.xdata$x:0000DF1E                 db    0
.xdata$x:0000DF1F                 db    0
.xdata$x:0000DF20                 db    0
.xdata$x:0000DF21                 db    0
.xdata$x:0000DF22                 db    0
.xdata$x:0000DF23                 db    0
.xdata$x:0000DF24                 db    0
.xdata$x:0000DF25                 db    0
.xdata$x:0000DF26                 db    0
.xdata$x:0000DF27                 db    0
.xdata$x:0000DF28                 db    0
.xdata$x:0000DF29                 db    0
.xdata$x:0000DF2A                 db    0
.xdata$x:0000DF2B                 db    0
.xdata$x:0000DF2C                 db    0
.xdata$x:0000DF2D                 db    0
.xdata$x:0000DF2E                 db    0
.xdata$x:0000DF2F                 db    0
.xdata$x:0000DF30                 db    0
.xdata$x:0000DF31                 db    0
.xdata$x:0000DF32                 db    0
.xdata$x:0000DF33                 db    0
.xdata$x:0000DF34 __ehfuncinfo$?PathRemoveFileSpecW@@YA?AV?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@AAV12@@Z db  22h ; "
.xdata$x:0000DF34                                         ; DATA XREF: __ehhandler$?PathRemoveFileSpecW@@YA?AV?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@AAV12@@Z+11o
.xdata$x:0000DF35                 db    5
.xdata$x:0000DF36                 db  93h ; ô
.xdata$x:0000DF37                 db  19h
.xdata$x:0000DF38                 db    1
.xdata$x:0000DF39                 db    0
.xdata$x:0000DF3A                 db    0
.xdata$x:0000DF3B                 db    0
.xdata$x:0000DF3C                 dd offset __unwindtable$?PathRemoveFileSpecW@@YA?AV?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@AAV12@@Z
.xdata$x:0000DF40                 db    0
.xdata$x:0000DF41                 db    0
.xdata$x:0000DF42                 db    0
.xdata$x:0000DF43                 db    0
.xdata$x:0000DF44                 db    0
.xdata$x:0000DF45                 db    0
.xdata$x:0000DF46                 db    0
.xdata$x:0000DF47                 db    0
.xdata$x:0000DF48                 db    0
.xdata$x:0000DF49                 db    0
.xdata$x:0000DF4A                 db    0
.xdata$x:0000DF4B                 db    0
.xdata$x:0000DF4C                 db    0
.xdata$x:0000DF4D                 db    0
.xdata$x:0000DF4E                 db    0
.xdata$x:0000DF4F                 db    0
.xdata$x:0000DF50                 db    0
.xdata$x:0000DF51                 db    0
.xdata$x:0000DF52                 db    0
.xdata$x:0000DF53                 db    0
.xdata$x:0000DF54                 db    0
.xdata$x:0000DF55                 db    0
.xdata$x:0000DF56                 db    0
.xdata$x:0000DF57                 db    0
.xdata$x:0000DF58 __ehfuncinfo$?relativeFilePathToFullFilePath@@YA?AV?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@PB_W@Z db  22h ; "
.xdata$x:0000DF58                                         ; DATA XREF: __ehhandler$?relativeFilePathToFullFilePath@@YA?AV?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@PB_W@Z+1Eo
.xdata$x:0000DF59                 db    5
.xdata$x:0000DF5A                 db  93h ; ô
.xdata$x:0000DF5B                 db  19h
.xdata$x:0000DF5C                 db    2
.xdata$x:0000DF5D                 db    0
.xdata$x:0000DF5E                 db    0
.xdata$x:0000DF5F                 db    0
.xdata$x:0000DF60                 dd offset __unwindtable$?relativeFilePathToFullFilePath@@YA?AV?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@PB_W@Z
.xdata$x:0000DF64                 db    0
.xdata$x:0000DF65                 db    0
.xdata$x:0000DF66                 db    0
.xdata$x:0000DF67                 db    0
.xdata$x:0000DF68                 db    0
.xdata$x:0000DF69                 db    0
.xdata$x:0000DF6A                 db    0
.xdata$x:0000DF6B                 db    0
.xdata$x:0000DF6C                 db    0
.xdata$x:0000DF6D                 db    0
.xdata$x:0000DF6E                 db    0
.xdata$x:0000DF6F                 db    0
.xdata$x:0000DF70                 db    0
.xdata$x:0000DF71                 db    0
.xdata$x:0000DF72                 db    0
.xdata$x:0000DF73                 db    0
.xdata$x:0000DF74                 db    0
.xdata$x:0000DF75                 db    0
.xdata$x:0000DF76                 db    0
.xdata$x:0000DF77                 db    0
.xdata$x:0000DF78                 db    0
.xdata$x:0000DF79                 db    0
.xdata$x:0000DF7A                 db    0
.xdata$x:0000DF7B                 db    0
.xdata$x:0000DF7C __ehfuncinfo$?getFileContent@@YA?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@PB_W@Z db  22h ; "
.xdata$x:0000DF7C                                         ; DATA XREF: __ehhandler$?getFileContent@@YA?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@PB_W@Z+1Eo
.xdata$x:0000DF7D                 db    5
.xdata$x:0000DF7E                 db  93h ; ô
.xdata$x:0000DF7F                 db  19h
.xdata$x:0000DF80                 db    2
.xdata$x:0000DF81                 db    0
.xdata$x:0000DF82                 db    0
.xdata$x:0000DF83                 db    0
.xdata$x:0000DF84                 dd offset __unwindtable$?getFileContent@@YA?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@PB_W@Z
.xdata$x:0000DF88                 align 20h
.xdata$x:0000DFA0 __ehfuncinfo$?BuildMenuFileName@@YA?AV?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@HIABV12@@Z db  22h ; "
.xdata$x:0000DFA0                                         ; DATA XREF: __ehhandler$?BuildMenuFileName@@YA?AV?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@HIABV12@@Z+1Eo
.xdata$x:0000DFA1                 db    5
.xdata$x:0000DFA2                 db  93h ; ô
.xdata$x:0000DFA3                 db  19h
.xdata$x:0000DFA4                 db  16h
.xdata$x:0000DFA5                 db    0
.xdata$x:0000DFA6                 db    0
.xdata$x:0000DFA7                 db    0
.xdata$x:0000DFA8                 dd offset __unwindtable$?BuildMenuFileName@@YA?AV?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@HIABV12@@Z
.xdata$x:0000DFAC                 db    0
.xdata$x:0000DFAD                 db    0
.xdata$x:0000DFAE                 db    0
.xdata$x:0000DFAF                 db    0
.xdata$x:0000DFB0                 db    0
.xdata$x:0000DFB1                 db    0
.xdata$x:0000DFB2                 db    0
.xdata$x:0000DFB3                 db    0
.xdata$x:0000DFB4                 db    0
.xdata$x:0000DFB5                 db    0
.xdata$x:0000DFB6                 db    0
.xdata$x:0000DFB7                 db    0
.xdata$x:0000DFB8                 db    0
.xdata$x:0000DFB9                 db    0
.xdata$x:0000DFBA                 db    0
.xdata$x:0000DFBB                 db    0
.xdata$x:0000DFBC                 db    0
.xdata$x:0000DFBD                 db    0
.xdata$x:0000DFBE                 db    0
.xdata$x:0000DFBF                 db    0
.xdata$x:0000DFC0                 db    0
.xdata$x:0000DFC1                 db    0
.xdata$x:0000DFC2                 db    0
.xdata$x:0000DFC3                 db    0
.xdata$x:0000DFC4 __ehfuncinfo$?wstring2string@@YA?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@ABV?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@2@I@Z db  22h ; "
.xdata$x:0000DFC4                                         ; DATA XREF: __ehhandler$?wstring2string@@YA?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@ABV?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@2@I@Z+11o
.xdata$x:0000DFC5                 db    5
.xdata$x:0000DFC6                 db  93h ; ô
.xdata$x:0000DFC7                 db  19h
.xdata$x:0000DFC8                 db    2
.xdata$x:0000DFC9                 db    0
.xdata$x:0000DFCA                 db    0
.xdata$x:0000DFCB                 db    0
.xdata$x:0000DFCC                 dd offset __unwindtable$?wstring2string@@YA?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@ABV?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@2@I@Z
.xdata$x:0000DFD0                 db    0
.xdata$x:0000DFD1                 db    0
.xdata$x:0000DFD2                 db    0
.xdata$x:0000DFD3                 db    0
.xdata$x:0000DFD4                 db    0
.xdata$x:0000DFD5                 db    0
.xdata$x:0000DFD6                 db    0
.xdata$x:0000DFD7                 db    0
.xdata$x:0000DFD8                 db    0
.xdata$x:0000DFD9                 db    0
.xdata$x:0000DFDA                 db    0
.xdata$x:0000DFDB                 db    0
.xdata$x:0000DFDC                 db    0
.xdata$x:0000DFDD                 db    0
.xdata$x:0000DFDE                 db    0
.xdata$x:0000DFDF                 db    0
.xdata$x:0000DFE0                 db    0
.xdata$x:0000DFE1                 db    0
.xdata$x:0000DFE2                 db    0
.xdata$x:0000DFE3                 db    0
.xdata$x:0000DFE4                 db    0
.xdata$x:0000DFE5                 db    0
.xdata$x:0000DFE6                 db    0
.xdata$x:0000DFE7                 db    0
.xdata$x:0000DFE8 __ehfuncinfo$?string2wstring@@YA?AV?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@ABV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@2@I@Z db  22h ; "
.xdata$x:0000DFE8                                         ; DATA XREF: __ehhandler$?string2wstring@@YA?AV?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@ABV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@2@I@Z+11o
.xdata$x:0000DFE9                 db    5
.xdata$x:0000DFEA                 db  93h ; ô
.xdata$x:0000DFEB                 db  19h
.xdata$x:0000DFEC                 db    2
.xdata$x:0000DFED                 db    0
.xdata$x:0000DFEE                 db    0
.xdata$x:0000DFEF                 db    0
.xdata$x:0000DFF0                 dd offset __unwindtable$?string2wstring@@YA?AV?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@ABV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@2@I@Z
.xdata$x:0000DFF4                 db    0
.xdata$x:0000DFF5                 db    0
.xdata$x:0000DFF6                 db    0
.xdata$x:0000DFF7                 db    0
.xdata$x:0000DFF8                 db    0
.xdata$x:0000DFF9                 db    0
.xdata$x:0000DFFA                 db    0
.xdata$x:0000DFFB                 db    0
.xdata$x:0000DFFC                 db    0
.xdata$x:0000DFFD                 db    0
.xdata$x:0000DFFE                 db    0
.xdata$x:0000DFFF                 db    0
.xdata$x:0000E000                 db    0
.xdata$x:0000E001                 db    0
.xdata$x:0000E002                 db    0
.xdata$x:0000E003                 db    0
.xdata$x:0000E004                 db    0
.xdata$x:0000E005                 db    0
.xdata$x:0000E006                 db    0
.xdata$x:0000E007                 db    0
.xdata$x:0000E008                 db    0
.xdata$x:0000E009                 db    0
.xdata$x:0000E00A                 db    0
.xdata$x:0000E00B                 db    0
.xdata$x:0000E00C __ehfuncinfo$?tokenizeString@@YA?AV?$vector@V?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@V?$allocator@V?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@@2@@std@@ABV?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@2@D@Z db  22h ; "
.xdata$x:0000E00C                                         ; DATA XREF: __ehhandler$?tokenizeString@@YA?AV?$vector@V?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@V?$allocator@V?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@@2@@std@@ABV?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@2@D@Z+1Bo
.xdata$x:0000E00D                 db    5
.xdata$x:0000E00E                 db  93h ; ô
.xdata$x:0000E00F                 db  19h
.xdata$x:0000E010                 db    3
.xdata$x:0000E011                 db    0
.xdata$x:0000E012                 db    0
.xdata$x:0000E013                 db    0
.xdata$x:0000E014                 dd offset __unwindtable$?tokenizeString@@YA?AV?$vector@V?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@V?$allocator@V?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@@2@@std@@ABV?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@2@D@Z
.xdata$x:0000E018                 db    0
.xdata$x:0000E019                 db    0
.xdata$x:0000E01A                 db    0
.xdata$x:0000E01B                 db    0
.xdata$x:0000E01C                 db    0
.xdata$x:0000E01D                 db    0
.xdata$x:0000E01E                 db    0
.xdata$x:0000E01F                 db    0
.xdata$x:0000E020                 db    0
.xdata$x:0000E021                 db    0
.xdata$x:0000E022                 db    0
.xdata$x:0000E023                 db    0
.xdata$x:0000E024                 db    0
.xdata$x:0000E025                 db    0
.xdata$x:0000E026                 db    0
.xdata$x:0000E027                 db    0
.xdata$x:0000E028                 db    0
.xdata$x:0000E029                 db    0
.xdata$x:0000E02A                 db    0
.xdata$x:0000E02B                 db    0
.xdata$x:0000E02C                 db    0
.xdata$x:0000E02D                 db    0
.xdata$x:0000E02E                 db    0
.xdata$x:0000E02F                 db    0
.xdata$x:0000E030 __ehfuncinfo$?purgeMenuItemString@@YA?AV?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@PB_W_N@Z db  22h ; "
.xdata$x:0000E030                                         ; DATA XREF: __ehhandler$?purgeMenuItemString@@YA?AV?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@PB_W_N@Z+1Eo
.xdata$x:0000E031                 db    5
.xdata$x:0000E032                 db  93h ; ô
.xdata$x:0000E033                 db  19h
.xdata$x:0000E034                 db    1
.xdata$x:0000E035                 db    0
.xdata$x:0000E036                 db    0
.xdata$x:0000E037                 db    0
.xdata$x:0000E038                 dd offset __unwindtable$?purgeMenuItemString@@YA?AV?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@PB_W_N@Z
.xdata$x:0000E03C                 db    0
.xdata$x:0000E03D                 db    0
.xdata$x:0000E03E                 db    0
.xdata$x:0000E03F                 db    0
.xdata$x:0000E040                 db    0
.xdata$x:0000E041                 db    0
.xdata$x:0000E042                 db    0
.xdata$x:0000E043                 db    0
.xdata$x:0000E044                 db    0
.xdata$x:0000E045                 db    0
.xdata$x:0000E046                 db    0
.xdata$x:0000E047                 db    0
.xdata$x:0000E048                 db    0
.xdata$x:0000E049                 db    0
.xdata$x:0000E04A                 db    0
.xdata$x:0000E04B                 db    0
.xdata$x:0000E04C                 db    0
.xdata$x:0000E04D                 db    0
.xdata$x:0000E04E                 db    0
.xdata$x:0000E04F                 db    0
.xdata$x:0000E050                 db    0
.xdata$x:0000E051                 db    0
.xdata$x:0000E052                 db    0
.xdata$x:0000E053                 db    0
.xdata$x:0000E054 __ehfuncinfo$?getFolderName@@YA?AV?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@PAUHWND__@@PB_W@Z db  22h ; "
.xdata$x:0000E054                                         ; DATA XREF: __ehhandler$?getFolderName@@YA?AV?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@PAUHWND__@@PB_W@Z+1Eo
.xdata$x:0000E055                 db    5
.xdata$x:0000E056                 db  93h ; ô
.xdata$x:0000E057                 db  19h
.xdata$x:0000E058                 db    2
.xdata$x:0000E059                 db    0
.xdata$x:0000E05A                 db    0
.xdata$x:0000E05B                 db    0
.xdata$x:0000E05C                 dd offset __unwindtable$?getFolderName@@YA?AV?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@PAUHWND__@@PB_W@Z
.xdata$x:0000E060                 db    0
.xdata$x:0000E061                 db    0
.xdata$x:0000E062                 db    0
.xdata$x:0000E063                 db    0
.xdata$x:0000E064                 db    0
.xdata$x:0000E065                 db    0
.xdata$x:0000E066                 db    0
.xdata$x:0000E067                 db    0
.xdata$x:0000E068                 db    0
.xdata$x:0000E069                 db    0
.xdata$x:0000E06A                 db    0
.xdata$x:0000E06B                 db    0
.xdata$x:0000E06C                 db    0
.xdata$x:0000E06D                 db    0
.xdata$x:0000E06E                 db    0
.xdata$x:0000E06F                 db    0
.xdata$x:0000E070                 db    0
.xdata$x:0000E071                 db    0
.xdata$x:0000E072                 db    0
.xdata$x:0000E073                 db    0
.xdata$x:0000E074                 db    0
.xdata$x:0000E075                 db    0
.xdata$x:0000E076                 db    0
.xdata$x:0000E077                 db    0
.xdata$x:0000E078 __unwindtable$?uintToString@@YA?AV?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@I@Z db 0FFh
.xdata$x:0000E078                                         ; DATA XREF: .xdata$x:0000DDF8o
.xdata$x:0000E079                 db 0FFh
.xdata$x:0000E07A                 db 0FFh
.xdata$x:0000E07B                 db 0FFh
.xdata$x:0000E07C                 dd offset __unwindfunclet$?uintToString@@YA?AV?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@I@Z$4
.xdata$x:0000E080                 db    0
.xdata$x:0000E081                 db    0
.xdata$x:0000E082                 db    0
.xdata$x:0000E083                 db    0
.xdata$x:0000E084                 dd offset __unwindfunclet$?uintToString@@YA?AV?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@I@Z$0
.xdata$x:0000E088                 db    1
.xdata$x:0000E089                 db    0
.xdata$x:0000E08A                 db    0
.xdata$x:0000E08B                 db    0
.xdata$x:0000E08C                 dd offset __unwindfunclet$?uintToString@@YA?AV?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@I@Z$1
.xdata$x:0000E090                 db    2
.xdata$x:0000E091                 db    0
.xdata$x:0000E092                 db    0
.xdata$x:0000E093                 db    0
.xdata$x:0000E094                 dd offset __unwindfunclet$?uintToString@@YA?AV?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@I@Z$2
.xdata$x:0000E098                 db    1
.xdata$x:0000E099                 db    0
.xdata$x:0000E09A                 db    0
.xdata$x:0000E09B                 db    0
.xdata$x:0000E09C                 dd offset __unwindfunclet$?uintToString@@YA?AV?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@I@Z$3
.xdata$x:0000E0A0 __unwindtable$?intToString@@YA?AV?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@H@Z db 0FFh
.xdata$x:0000E0A0                                         ; DATA XREF: .xdata$x:0000DE1Co
.xdata$x:0000E0A1                 db 0FFh
.xdata$x:0000E0A2                 db 0FFh
.xdata$x:0000E0A3                 db 0FFh
.xdata$x:0000E0A4                 dd offset __unwindfunclet$?intToString@@YA?AV?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@H@Z$4
.xdata$x:0000E0A8                 db    0
.xdata$x:0000E0A9                 db    0
.xdata$x:0000E0AA                 db    0
.xdata$x:0000E0AB                 db    0
.xdata$x:0000E0AC                 dd offset __unwindfunclet$?intToString@@YA?AV?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@H@Z$0
.xdata$x:0000E0B0                 db    1
.xdata$x:0000E0B1                 db    0
.xdata$x:0000E0B2                 db    0
.xdata$x:0000E0B3                 db    0
.xdata$x:0000E0B4                 dd offset __unwindfunclet$?intToString@@YA?AV?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@H@Z$1
.xdata$x:0000E0B8                 db    2
.xdata$x:0000E0B9                 db    0
.xdata$x:0000E0BA                 db    0
.xdata$x:0000E0BB                 db    0
.xdata$x:0000E0BC                 dd offset __unwindfunclet$?intToString@@YA?AV?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@H@Z$2
.xdata$x:0000E0C0                 db    1
.xdata$x:0000E0C1                 db    0
.xdata$x:0000E0C2                 db    0
.xdata$x:0000E0C3                 db    0
.xdata$x:0000E0C4                 dd offset __unwindfunclet$?intToString@@YA?AV?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@H@Z$3
.xdata$x:0000E0C8 __unwindtable$?stringToUpper@@YA?AV?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@V12@@Z db 0FFh
.xdata$x:0000E0C8                                         ; DATA XREF: .xdata$x:0000DEF4o
.xdata$x:0000E0C9                 db 0FFh
.xdata$x:0000E0CA                 db 0FFh
.xdata$x:0000E0CB                 db 0FFh
.xdata$x:0000E0CC                 dd offset __unwindfunclet$?stringToUpper@@YA?AV?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@V12@@Z$5
.xdata$x:0000E0D0                 db    0
.xdata$x:0000E0D1                 db    0
.xdata$x:0000E0D2                 db    0
.xdata$x:0000E0D3                 db    0
.xdata$x:0000E0D4                 dd offset __unwindfunclet$?stringToUpper@@YA?AV?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@V12@@Z$0
.xdata$x:0000E0D8                 db    1
.xdata$x:0000E0D9                 db    0
.xdata$x:0000E0DA                 db    0
.xdata$x:0000E0DB                 db    0
.xdata$x:0000E0DC                 dd offset __unwindfunclet$?stringToUpper@@YA?AV?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@V12@@Z$1
.xdata$x:0000E0E0                 db    2
.xdata$x:0000E0E1                 db    0
.xdata$x:0000E0E2                 db    0
.xdata$x:0000E0E3                 db    0
.xdata$x:0000E0E4                 dd offset __unwindfunclet$?stringToUpper@@YA?AV?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@V12@@Z$2
.xdata$x:0000E0E8                 db    3
.xdata$x:0000E0E9                 db    0
.xdata$x:0000E0EA                 db    0
.xdata$x:0000E0EB                 db    0
.xdata$x:0000E0EC                 dd offset __unwindfunclet$?stringToUpper@@YA?AV?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@V12@@Z$3
.xdata$x:0000E0F0 __unwindtable$?BuildMenuFileName@@YA?AV?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@HIABV12@@Z db 0FFh
.xdata$x:0000E0F0                                         ; DATA XREF: .xdata$x:0000DFA8o
.xdata$x:0000E0F1                 db 0FFh
.xdata$x:0000E0F2                 db 0FFh
.xdata$x:0000E0F3                 db 0FFh
.xdata$x:0000E0F4                 dd offset __unwindfunclet$?BuildMenuFileName@@YA?AV?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@HIABV12@@Z$20
.xdata$x:0000E0F8                 db    0
.xdata$x:0000E0F9                 db    0
.xdata$x:0000E0FA                 db    0
.xdata$x:0000E0FB                 db    0
.xdata$x:0000E0FC                 dd offset __unwindfunclet$?BuildMenuFileName@@YA?AV?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@HIABV12@@Z$0
.xdata$x:0000E100                 db    1
.xdata$x:0000E101                 db    0
.xdata$x:0000E102                 db    0
.xdata$x:0000E103                 db    0
.xdata$x:0000E104                 dd offset __unwindfunclet$?BuildMenuFileName@@YA?AV?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@HIABV12@@Z$1
.xdata$x:0000E108                 db    1
.xdata$x:0000E109                 db    0
.xdata$x:0000E10A                 db    0
.xdata$x:0000E10B                 db    0
.xdata$x:0000E10C                 dd offset __unwindfunclet$?BuildMenuFileName@@YA?AV?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@HIABV12@@Z$2
.xdata$x:0000E110                 db    3
.xdata$x:0000E111                 db    0
.xdata$x:0000E112                 db    0
.xdata$x:0000E113                 db    0
.xdata$x:0000E114                 dd offset __unwindfunclet$?BuildMenuFileName@@YA?AV?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@HIABV12@@Z$3
.xdata$x:0000E118                 db    4
.xdata$x:0000E119                 db    0
.xdata$x:0000E11A                 db    0
.xdata$x:0000E11B                 db    0
.xdata$x:0000E11C                 dd offset __unwindfunclet$?BuildMenuFileName@@YA?AV?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@HIABV12@@Z$4
.xdata$x:0000E120                 db    5
.xdata$x:0000E121                 db    0
.xdata$x:0000E122                 db    0
.xdata$x:0000E123                 db    0
.xdata$x:0000E124                 dd offset __unwindfunclet$?BuildMenuFileName@@YA?AV?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@HIABV12@@Z$5
.xdata$x:0000E128                 db    4
.xdata$x:0000E129                 db    0
.xdata$x:0000E12A                 db    0
.xdata$x:0000E12B                 db    0
.xdata$x:0000E12C                 dd offset __unwindfunclet$?BuildMenuFileName@@YA?AV?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@HIABV12@@Z$6
.xdata$x:0000E130                 db    1
.xdata$x:0000E131                 db    0
.xdata$x:0000E132                 db    0
.xdata$x:0000E133                 db    0
.xdata$x:0000E134                 dd offset __unwindfunclet$?BuildMenuFileName@@YA?AV?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@HIABV12@@Z$7
.xdata$x:0000E138                 db    8
.xdata$x:0000E139                 db    0
.xdata$x:0000E13A                 db    0
.xdata$x:0000E13B                 db    0
.xdata$x:0000E13C                 dd offset __unwindfunclet$?BuildMenuFileName@@YA?AV?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@HIABV12@@Z$8
.xdata$x:0000E140                 db    8
.xdata$x:0000E141                 db    0
.xdata$x:0000E142                 db    0
.xdata$x:0000E143                 db    0
.xdata$x:0000E144                 dd offset __unwindfunclet$?BuildMenuFileName@@YA?AV?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@HIABV12@@Z$9
.xdata$x:0000E148                 db  0Ah
.xdata$x:0000E149                 db    0
.xdata$x:0000E14A                 db    0
.xdata$x:0000E14B                 db    0
.xdata$x:0000E14C                 dd offset __unwindfunclet$?BuildMenuFileName@@YA?AV?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@HIABV12@@Z$10
.xdata$x:0000E150                 db    8
.xdata$x:0000E151                 db    0
.xdata$x:0000E152                 db    0
.xdata$x:0000E153                 db    0
.xdata$x:0000E154                 dd offset __unwindfunclet$?BuildMenuFileName@@YA?AV?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@HIABV12@@Z$11
.xdata$x:0000E158                 db    8
.xdata$x:0000E159                 db    0
.xdata$x:0000E15A                 db    0
.xdata$x:0000E15B                 db    0
.xdata$x:0000E15C                 dd offset __unwindfunclet$?BuildMenuFileName@@YA?AV?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@HIABV12@@Z$12
.xdata$x:0000E160                 db  0Dh
.xdata$x:0000E161                 db    0
.xdata$x:0000E162                 db    0
.xdata$x:0000E163                 db    0
.xdata$x:0000E164                 dd offset __unwindfunclet$?BuildMenuFileName@@YA?AV?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@HIABV12@@Z$13
.xdata$x:0000E168                 db  0Eh
.xdata$x:0000E169                 db    0
.xdata$x:0000E16A                 db    0
.xdata$x:0000E16B                 db    0
.xdata$x:0000E16C                 dd offset __unwindfunclet$?BuildMenuFileName@@YA?AV?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@HIABV12@@Z$14
.xdata$x:0000E170                 db  0Dh
.xdata$x:0000E171                 db    0
.xdata$x:0000E172                 db    0
.xdata$x:0000E173                 db    0
.xdata$x:0000E174                 dd offset __unwindfunclet$?BuildMenuFileName@@YA?AV?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@HIABV12@@Z$15
.xdata$x:0000E178                 db    8
.xdata$x:0000E179                 db    0
.xdata$x:0000E17A                 db    0
.xdata$x:0000E17B                 db    0
.xdata$x:0000E17C                 dd offset __unwindfunclet$?BuildMenuFileName@@YA?AV?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@HIABV12@@Z$16
.xdata$x:0000E180                 db  11h
.xdata$x:0000E181                 db    0
.xdata$x:0000E182                 db    0
.xdata$x:0000E183                 db    0
.xdata$x:0000E184                 dd offset __unwindfunclet$?BuildMenuFileName@@YA?AV?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@HIABV12@@Z$17
.xdata$x:0000E188                 db  12h
.xdata$x:0000E189                 db    0
.xdata$x:0000E18A                 db    0
.xdata$x:0000E18B                 db    0
.xdata$x:0000E18C                 dd offset __unwindfunclet$?BuildMenuFileName@@YA?AV?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@HIABV12@@Z$18
.xdata$x:0000E190                 db    8
.xdata$x:0000E191                 db    0
.xdata$x:0000E192                 db    0
.xdata$x:0000E193                 db    0
.xdata$x:0000E194                 dd offset __unwindfunclet$?BuildMenuFileName@@YA?AV?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@HIABV12@@Z$17
.xdata$x:0000E198                 db  14h
.xdata$x:0000E199                 db    0
.xdata$x:0000E19A                 db    0
.xdata$x:0000E19B                 db    0
.xdata$x:0000E19C                 dd offset __unwindfunclet$?BuildMenuFileName@@YA?AV?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@HIABV12@@Z$19
.xdata$x:0000E19C _xdata$x        ends
.xdata$x:0000E19C
.xdata$x:0000E1A0 ; ===========================================================================
.xdata$x:0000E1A0
.xdata$x:0000E1A0 ; Segment type: Pure data
.xdata$x:0000E1A0 ; Segment permissions: Read
.xdata$x:0000E1A0 _xdata$x        segment dword public 'DATA' use32
.xdata$x:0000E1A0                 assume cs:_xdata$x
.xdata$x:0000E1A0                 ;org 0E1A0h
.xdata$x:0000E1A0 ; COMDAT (pick associative to section at 68C0)
.xdata$x:0000E1A0 __unwindtable$??0WcharMbcsConvertor@@IAE@XZ db 0FFh
.xdata$x:0000E1A0                                         ; DATA XREF: .xdata$x:0000E1B8o
.xdata$x:0000E1A1                 db 0FFh
.xdata$x:0000E1A2                 db 0FFh
.xdata$x:0000E1A3                 db 0FFh
.xdata$x:0000E1A4                 dd offset __unwindfunclet$??0WcharMbcsConvertor@@IAE@XZ$0
.xdata$x:0000E1A8                 db    0
.xdata$x:0000E1A9                 db    0
.xdata$x:0000E1AA                 db    0
.xdata$x:0000E1AB                 db    0
.xdata$x:0000E1AC                 dd offset __unwindfunclet$??0WcharMbcsConvertor@@IAE@XZ$1
.xdata$x:0000E1B0 __ehfuncinfo$??0WcharMbcsConvertor@@IAE@XZ db  22h ; "
.xdata$x:0000E1B0                                         ; DATA XREF: __ehhandler$??0WcharMbcsConvertor@@IAE@XZ+11o
.xdata$x:0000E1B1                 db    5
.xdata$x:0000E1B2                 db  93h ; ô
.xdata$x:0000E1B3                 db  19h
.xdata$x:0000E1B4                 db    2
.xdata$x:0000E1B5                 db    0
.xdata$x:0000E1B6                 db    0
.xdata$x:0000E1B7                 db    0
.xdata$x:0000E1B8                 dd offset __unwindtable$??0WcharMbcsConvertor@@IAE@XZ
.xdata$x:0000E1BC                 db    0
.xdata$x:0000E1BD                 db    0
.xdata$x:0000E1BE                 db    0
.xdata$x:0000E1BF                 db    0
.xdata$x:0000E1C0                 db    0
.xdata$x:0000E1C1                 db    0
.xdata$x:0000E1C2                 db    0
.xdata$x:0000E1C3                 db    0
.xdata$x:0000E1C4                 db    0
.xdata$x:0000E1C5                 db    0
.xdata$x:0000E1C6                 db    0
.xdata$x:0000E1C7                 db    0
.xdata$x:0000E1C8                 db    0
.xdata$x:0000E1C9                 db    0
.xdata$x:0000E1CA                 db    0
.xdata$x:0000E1CB                 db    0
.xdata$x:0000E1CC                 db    0
.xdata$x:0000E1CD                 db    0
.xdata$x:0000E1CE                 db    0
.xdata$x:0000E1CF                 db    0
.xdata$x:0000E1D0                 db    0
.xdata$x:0000E1D1                 db    0
.xdata$x:0000E1D2                 db    0
.xdata$x:0000E1D3                 db    0
.xdata$x:0000E1D3 _xdata$x        ends
.xdata$x:0000E1D3
.xdata$x:0000E1D4 ; ===========================================================================
.xdata$x:0000E1D4
.xdata$x:0000E1D4 ; Segment type: Pure data
.xdata$x:0000E1D4 ; Segment permissions: Read
.xdata$x:0000E1D4 _xdata$x        segment dword public 'DATA' use32
.xdata$x:0000E1D4                 assume cs:_xdata$x
.xdata$x:0000E1D4                 ;org 0E1D4h
.xdata$x:0000E1D4 ; COMDAT (pick associative to section at 8BE8)
.xdata$x:0000E1D4 __unwindtable$??__E?_pSelf@WcharMbcsConvertor@@1PAV1@A@@YAXXZ db 0FFh
.xdata$x:0000E1D4                                         ; DATA XREF: .xdata$x:0000E1E4o
.xdata$x:0000E1D5                 db 0FFh
.xdata$x:0000E1D6                 db 0FFh
.xdata$x:0000E1D7                 db 0FFh
.xdata$x:0000E1D8                 dd offset __unwindfunclet$??__E?_pSelf@WcharMbcsConvertor@@1PAV1@A@@YAXXZ$0
.xdata$x:0000E1DC __ehfuncinfo$??__E?_pSelf@WcharMbcsConvertor@@1PAV1@A@@YAXXZ db  22h ; "
.xdata$x:0000E1DC                                         ; DATA XREF: __ehhandler$??__E?_pSelf@WcharMbcsConvertor@@1PAV1@A@@YAXXZ+11o
.xdata$x:0000E1DD                 db    5
.xdata$x:0000E1DE                 db  93h ; ô
.xdata$x:0000E1DF                 db  19h
.xdata$x:0000E1E0                 db    1
.xdata$x:0000E1E1                 db    0
.xdata$x:0000E1E2                 db    0
.xdata$x:0000E1E3                 db    0
.xdata$x:0000E1E4                 dd offset __unwindtable$??__E?_pSelf@WcharMbcsConvertor@@1PAV1@A@@YAXXZ
.xdata$x:0000E1E8                 align 20h
.xdata$x:0000E1E8 _xdata$x        ends
.xdata$x:0000E1E8
.xdata$x:0000E200 ; ===========================================================================
.xdata$x:0000E200
.xdata$x:0000E200 ; Segment type: Pure data
.xdata$x:0000E200 ; Segment permissions: Read
.xdata$x:0000E200 _xdata$x        segment dword public 'DATA' use32
.xdata$x:0000E200                 assume cs:_xdata$x
.xdata$x:0000E200                 ;org 0E200h
.xdata$x:0000E200 ; COMDAT (pick associative to section at 5DB8)
.xdata$x:0000E200 __unwindtable$??0?$_Vector_val@U?$_Simple_types@V?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@@std@@@std@@QAE@XZ db 0FFh
.xdata$x:0000E200                                         ; DATA XREF: .xdata$x:0000E210o
.xdata$x:0000E201                 db 0FFh
.xdata$x:0000E202                 db 0FFh
.xdata$x:0000E203                 db 0FFh
.xdata$x:0000E204                 dd offset __unwindfunclet$??0?$_Vector_val@U?$_Simple_types@V?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@@std@@@std@@QAE@XZ$0
.xdata$x:0000E208 __ehfuncinfo$??0?$_Vector_val@U?$_Simple_types@V?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@@std@@@std@@QAE@XZ db  22h ; "
.xdata$x:0000E208                                         ; DATA XREF: __ehhandler$??0?$_Vector_val@U?$_Simple_types@V?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@@std@@@std@@QAE@XZ+11o
.xdata$x:0000E209                 db    5
.xdata$x:0000E20A                 db  93h ; ô
.xdata$x:0000E20B                 db  19h
.xdata$x:0000E20C                 db    1
.xdata$x:0000E20D                 db    0
.xdata$x:0000E20E                 db    0
.xdata$x:0000E20F                 db    0
.xdata$x:0000E210                 dd offset __unwindtable$??0?$_Vector_val@U?$_Simple_types@V?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@@std@@@std@@QAE@XZ
.xdata$x:0000E214                 db    0
.xdata$x:0000E215                 db    0
.xdata$x:0000E216                 db    0
.xdata$x:0000E217                 db    0
.xdata$x:0000E218                 db    0
.xdata$x:0000E219                 db    0
.xdata$x:0000E21A                 db    0
.xdata$x:0000E21B                 db    0
.xdata$x:0000E21C                 db    0
.xdata$x:0000E21D                 db    0
.xdata$x:0000E21E                 db    0
.xdata$x:0000E21F                 db    0
.xdata$x:0000E220                 db    0
.xdata$x:0000E221                 db    0
.xdata$x:0000E222                 db    0
.xdata$x:0000E223                 db    0
.xdata$x:0000E224                 db    0
.xdata$x:0000E225                 db    0
.xdata$x:0000E226                 db    0
.xdata$x:0000E227                 db    0
.xdata$x:0000E228                 db    0
.xdata$x:0000E229                 db    0
.xdata$x:0000E22A                 db    0
.xdata$x:0000E22B                 db    0
.xdata$x:0000E22B _xdata$x        ends
.xdata$x:0000E22B
.xdata$x:0000E22C ; ===========================================================================
.xdata$x:0000E22C
.xdata$x:0000E22C ; Segment type: Pure data
.xdata$x:0000E22C ; Segment permissions: Read
.xdata$x:0000E22C _xdata$x        segment dword public 'DATA' use32
.xdata$x:0000E22C                 assume cs:_xdata$x
.xdata$x:0000E22C                 ;org 0E22Ch
.xdata$x:0000E22C ; COMDAT (pick associative to section at 73D4)
.xdata$x:0000E22C __unwindtable$??1?$_Vector_val@U?$_Simple_types@V?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@@std@@@std@@QAE@XZ db 0FFh
.xdata$x:0000E22C                                         ; DATA XREF: .xdata$x:0000E23Co
.xdata$x:0000E22D                 db 0FFh
.xdata$x:0000E22E                 db 0FFh
.xdata$x:0000E22F                 db 0FFh
.xdata$x:0000E230                 dd offset __unwindfunclet$??1?$_Vector_val@U?$_Simple_types@V?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@@std@@@std@@QAE@XZ$0
.xdata$x:0000E234 __ehfuncinfo$??1?$_Vector_val@U?$_Simple_types@V?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@@std@@@std@@QAE@XZ db  22h ; "
.xdata$x:0000E234                                         ; DATA XREF: __ehhandler$??1?$_Vector_val@U?$_Simple_types@V?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@@std@@@std@@QAE@XZ+11o
.xdata$x:0000E235                 db    5
.xdata$x:0000E236                 db  93h ; ô
.xdata$x:0000E237                 db  19h
.xdata$x:0000E238                 db    1
.xdata$x:0000E239                 db    0
.xdata$x:0000E23A                 db    0
.xdata$x:0000E23B                 db    0
.xdata$x:0000E23C                 dd offset __unwindtable$??1?$_Vector_val@U?$_Simple_types@V?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@@std@@@std@@QAE@XZ
.xdata$x:0000E240                 db    0
.xdata$x:0000E241                 db    0
.xdata$x:0000E242                 db    0
.xdata$x:0000E243                 db    0
.xdata$x:0000E244                 db    0
.xdata$x:0000E245                 db    0
.xdata$x:0000E246                 db    0
.xdata$x:0000E247                 db    0
.xdata$x:0000E248                 db    0
.xdata$x:0000E249                 db    0
.xdata$x:0000E24A                 db    0
.xdata$x:0000E24B                 db    0
.xdata$x:0000E24C                 db    0
.xdata$x:0000E24D                 db    0
.xdata$x:0000E24E                 db    0
.xdata$x:0000E24F                 db    0
.xdata$x:0000E250                 db    0
.xdata$x:0000E251                 db    0
.xdata$x:0000E252                 db    0
.xdata$x:0000E253                 db    0
.xdata$x:0000E254                 db    0
.xdata$x:0000E255                 db    0
.xdata$x:0000E256                 db    0
.xdata$x:0000E257                 db    0
.xdata$x:0000E257 _xdata$x        ends
.xdata$x:0000E257
.xdata$x:0000E258 ; ===========================================================================
.xdata$x:0000E258
.xdata$x:0000E258 ; Segment type: Pure data
.xdata$x:0000E258 ; Segment permissions: Read
.xdata$x:0000E258 _xdata$x        segment dword public 'DATA' use32
.xdata$x:0000E258                 assume cs:_xdata$x
.xdata$x:0000E258                 ;org 0E258h
.xdata$x:0000E258 ; COMDAT (pick associative to section at 5A2C)
.xdata$x:0000E258 __unwindtable$??0?$_Vector_alloc@$0A@U?$_Vec_base_types@V?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@V?$allocator@V?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@@2@@std@@@std@@QAE@ABV?$allocator@V?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@@1@@Z db 0FFh
.xdata$x:0000E258                                         ; DATA XREF: .xdata$x:0000E268o
.xdata$x:0000E259                 db 0FFh
.xdata$x:0000E25A                 db 0FFh
.xdata$x:0000E25B                 db 0FFh
.xdata$x:0000E25C                 dd offset __unwindfunclet$??0?$_Vector_alloc@$0A@U?$_Vec_base_types@V?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@V?$allocator@V?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@@2@@std@@@std@@QAE@ABV?$allocator@V?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@@1@@Z$0
.xdata$x:0000E260 __ehfuncinfo$??0?$_Vector_alloc@$0A@U?$_Vec_base_types@V?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@V?$allocator@V?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@@2@@std@@@std@@QAE@ABV?$allocator@V?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@@1@@Z db  22h ; "
.xdata$x:0000E260                                         ; DATA XREF: __ehhandler$??0?$_Vector_alloc@$0A@U?$_Vec_base_types@V?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@V?$allocator@V?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@@2@@std@@@std@@QAE@ABV?$allocator@V?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@@1@@Z+11o
.xdata$x:0000E261                 db    5
.xdata$x:0000E262                 db  93h ; ô
.xdata$x:0000E263                 db  19h
.xdata$x:0000E264                 db    1
.xdata$x:0000E265                 db    0
.xdata$x:0000E266                 db    0
.xdata$x:0000E267                 db    0
.xdata$x:0000E268                 dd offset __unwindtable$??0?$_Vector_alloc@$0A@U?$_Vec_base_types@V?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@V?$allocator@V?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@@2@@std@@@std@@QAE@ABV?$allocator@V?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@@1@@Z
.xdata$x:0000E26C                 db    0
.xdata$x:0000E26D                 db    0
.xdata$x:0000E26E                 db    0
.xdata$x:0000E26F                 db    0
.xdata$x:0000E270                 db    0
.xdata$x:0000E271                 db    0
.xdata$x:0000E272                 db    0
.xdata$x:0000E273                 db    0
.xdata$x:0000E274                 db    0
.xdata$x:0000E275                 db    0
.xdata$x:0000E276                 db    0
.xdata$x:0000E277                 db    0
.xdata$x:0000E278                 db    0
.xdata$x:0000E279                 db    0
.xdata$x:0000E27A                 db    0
.xdata$x:0000E27B                 db    0
.xdata$x:0000E27C                 db    0
.xdata$x:0000E27D                 db    0
.xdata$x:0000E27E                 db    0
.xdata$x:0000E27F                 db    0
.xdata$x:0000E280                 db    0
.xdata$x:0000E281                 db    0
.xdata$x:0000E282                 db    0
.xdata$x:0000E283                 db    0
.xdata$x:0000E283 _xdata$x        ends
.xdata$x:0000E283
.xdata$x:0000E284 ; ===========================================================================
.xdata$x:0000E284
.xdata$x:0000E284 ; Segment type: Pure data
.xdata$x:0000E284 ; Segment permissions: Read
.xdata$x:0000E284 _xdata$x        segment dword public 'DATA' use32
.xdata$x:0000E284                 assume cs:_xdata$x
.xdata$x:0000E284                 ;org 0E284h
.xdata$x:0000E284 ; COMDAT (pick associative to section at 7194)
.xdata$x:0000E284 __unwindtable$??1?$_Vector_alloc@$0A@U?$_Vec_base_types@V?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@V?$allocator@V?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@@2@@std@@@std@@QAE@XZ db 0FFh
.xdata$x:0000E284                                         ; DATA XREF: .xdata$x:0000E294o
.xdata$x:0000E285                 db 0FFh
.xdata$x:0000E286                 db 0FFh
.xdata$x:0000E287                 db 0FFh
.xdata$x:0000E288                 dd offset __unwindfunclet$??1?$_Vector_alloc@$0A@U?$_Vec_base_types@V?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@V?$allocator@V?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@@2@@std@@@std@@QAE@XZ$0
.xdata$x:0000E28C __ehfuncinfo$??1?$_Vector_alloc@$0A@U?$_Vec_base_types@V?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@V?$allocator@V?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@@2@@std@@@std@@QAE@XZ db  22h ; "
.xdata$x:0000E28C                                         ; DATA XREF: __ehhandler$??1?$_Vector_alloc@$0A@U?$_Vec_base_types@V?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@V?$allocator@V?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@@2@@std@@@std@@QAE@XZ+11o
.xdata$x:0000E28D                 db    5
.xdata$x:0000E28E                 db  93h ; ô
.xdata$x:0000E28F                 db  19h
.xdata$x:0000E290                 db    1
.xdata$x:0000E291                 db    0
.xdata$x:0000E292                 db    0
.xdata$x:0000E293                 db    0
.xdata$x:0000E294                 dd offset __unwindtable$??1?$_Vector_alloc@$0A@U?$_Vec_base_types@V?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@V?$allocator@V?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@@2@@std@@@std@@QAE@XZ
.xdata$x:0000E298                 db    0
.xdata$x:0000E299                 db    0
.xdata$x:0000E29A                 db    0
.xdata$x:0000E29B                 db    0
.xdata$x:0000E29C                 db    0
.xdata$x:0000E29D                 db    0
.xdata$x:0000E29E                 db    0
.xdata$x:0000E29F                 db    0
.xdata$x:0000E2A0                 db    0
.xdata$x:0000E2A1                 db    0
.xdata$x:0000E2A2                 db    0
.xdata$x:0000E2A3                 db    0
.xdata$x:0000E2A4                 db    0
.xdata$x:0000E2A5                 db    0
.xdata$x:0000E2A6                 db    0
.xdata$x:0000E2A7                 db    0
.xdata$x:0000E2A8                 db    0
.xdata$x:0000E2A9                 db    0
.xdata$x:0000E2AA                 db    0
.xdata$x:0000E2AB                 db    0
.xdata$x:0000E2AC                 db    0
.xdata$x:0000E2AD                 db    0
.xdata$x:0000E2AE                 db    0
.xdata$x:0000E2AF                 db    0
.xdata$x:0000E2AF _xdata$x        ends
.xdata$x:0000E2AF
.xdata$x:0000E2B0 ; ===========================================================================
.xdata$x:0000E2B0
.xdata$x:0000E2B0 ; Segment type: Pure data
.xdata$x:0000E2B0 ; Segment permissions: Read
.xdata$x:0000E2B0 _xdata$x        segment dword public 'DATA' use32
.xdata$x:0000E2B0                 assume cs:_xdata$x
.xdata$x:0000E2B0                 ;org 0E2B0h
.xdata$x:0000E2B0 ; COMDAT (pick associative to section at 66C0)
.xdata$x:0000E2B0 __unwindtable$??0?$vector@V?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@V?$allocator@V?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@@2@@std@@QAE@XZ db 0FFh
.xdata$x:0000E2B0                                         ; DATA XREF: .xdata$x:0000E2C0o
.xdata$x:0000E2B1                 db 0FFh
.xdata$x:0000E2B2                 db 0FFh
.xdata$x:0000E2B3                 db 0FFh
.xdata$x:0000E2B4                 dd offset __unwindfunclet$??0?$vector@V?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@V?$allocator@V?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@@2@@std@@QAE@XZ$0
.xdata$x:0000E2B8 __ehfuncinfo$??0?$vector@V?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@V?$allocator@V?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@@2@@std@@QAE@XZ db  22h ; "
.xdata$x:0000E2B8                                         ; DATA XREF: __ehhandler$??0?$vector@V?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@V?$allocator@V?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@@2@@std@@QAE@XZ+11o
.xdata$x:0000E2B9                 db    5
.xdata$x:0000E2BA                 db  93h ; ô
.xdata$x:0000E2BB                 db  19h
.xdata$x:0000E2BC                 db    1
.xdata$x:0000E2BD                 db    0
.xdata$x:0000E2BE                 db    0
.xdata$x:0000E2BF                 db    0
.xdata$x:0000E2C0                 dd offset __unwindtable$??0?$vector@V?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@V?$allocator@V?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@@2@@std@@QAE@XZ
.xdata$x:0000E2C4                 db    0
.xdata$x:0000E2C5                 db    0
.xdata$x:0000E2C6                 db    0
.xdata$x:0000E2C7                 db    0
.xdata$x:0000E2C8                 db    0
.xdata$x:0000E2C9                 db    0
.xdata$x:0000E2CA                 db    0
.xdata$x:0000E2CB                 db    0
.xdata$x:0000E2CC                 db    0
.xdata$x:0000E2CD                 db    0
.xdata$x:0000E2CE                 db    0
.xdata$x:0000E2CF                 db    0
.xdata$x:0000E2D0                 db    0
.xdata$x:0000E2D1                 db    0
.xdata$x:0000E2D2                 db    0
.xdata$x:0000E2D3                 db    0
.xdata$x:0000E2D4                 db    0
.xdata$x:0000E2D5                 db    0
.xdata$x:0000E2D6                 db    0
.xdata$x:0000E2D7                 db    0
.xdata$x:0000E2D8                 db    0
.xdata$x:0000E2D9                 db    0
.xdata$x:0000E2DA                 db    0
.xdata$x:0000E2DB                 db    0
.xdata$x:0000E2DB _xdata$x        ends
.xdata$x:0000E2DB
.xdata$x:0000E2DC ; ===========================================================================
.xdata$x:0000E2DC
.xdata$x:0000E2DC ; Segment type: Pure data
.xdata$x:0000E2DC ; Segment permissions: Read
.xdata$x:0000E2DC _xdata$x        segment dword public 'DATA' use32
.xdata$x:0000E2DC                 assume cs:_xdata$x
.xdata$x:0000E2DC                 ;org 0E2DCh
.xdata$x:0000E2DC ; COMDAT (pick associative to section at 661C)
.xdata$x:0000E2DC __unwindtable$??0?$vector@V?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@V?$allocator@V?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@@2@@std@@QAE@$$QAV01@@Z db 0FFh
.xdata$x:0000E2DC                                         ; DATA XREF: .xdata$x:0000E2ECo
.xdata$x:0000E2DD                 db 0FFh
.xdata$x:0000E2DE                 db 0FFh
.xdata$x:0000E2DF                 db 0FFh
.xdata$x:0000E2E0                 dd offset __unwindfunclet$??0?$vector@V?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@V?$allocator@V?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@@2@@std@@QAE@$$QAV01@@Z$0
.xdata$x:0000E2E4 __ehfuncinfo$??0?$vector@V?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@V?$allocator@V?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@@2@@std@@QAE@$$QAV01@@Z db  22h ; "
.xdata$x:0000E2E4                                         ; DATA XREF: __ehhandler$??0?$vector@V?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@V?$allocator@V?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@@2@@std@@QAE@$$QAV01@@Z+11o
.xdata$x:0000E2E5                 db    5
.xdata$x:0000E2E6                 db  93h ; ô
.xdata$x:0000E2E7                 db  19h
.xdata$x:0000E2E8                 db    1
.xdata$x:0000E2E9                 db    0
.xdata$x:0000E2EA                 db    0
.xdata$x:0000E2EB                 db    0
.xdata$x:0000E2EC                 dd offset __unwindtable$??0?$vector@V?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@V?$allocator@V?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@@2@@std@@QAE@$$QAV01@@Z
.xdata$x:0000E2F0                 db    0
.xdata$x:0000E2F1                 db    0
.xdata$x:0000E2F2                 db    0
.xdata$x:0000E2F3                 db    0
.xdata$x:0000E2F4                 db    0
.xdata$x:0000E2F5                 db    0
.xdata$x:0000E2F6                 db    0
.xdata$x:0000E2F7                 db    0
.xdata$x:0000E2F8                 db    0
.xdata$x:0000E2F9                 db    0
.xdata$x:0000E2FA                 db    0
.xdata$x:0000E2FB                 db    0
.xdata$x:0000E2FC                 db    0
.xdata$x:0000E2FD                 db    0
.xdata$x:0000E2FE                 db    0
.xdata$x:0000E2FF                 db    0
.xdata$x:0000E300                 db    0
.xdata$x:0000E301                 db    0
.xdata$x:0000E302                 db    0
.xdata$x:0000E303                 db    0
.xdata$x:0000E304                 db    0
.xdata$x:0000E305                 db    0
.xdata$x:0000E306                 db    0
.xdata$x:0000E307                 db    0
.xdata$x:0000E307 _xdata$x        ends
.xdata$x:0000E307
.xdata$x:0000E308 ; ===========================================================================
.xdata$x:0000E308
.xdata$x:0000E308 ; Segment type: Pure data
.xdata$x:0000E308 ; Segment permissions: Read
.xdata$x:0000E308 _xdata$x        segment dword public 'DATA' use32
.xdata$x:0000E308                 assume cs:_xdata$x
.xdata$x:0000E308                 ;org 0E308h
.xdata$x:0000E308 ; COMDAT (pick associative to section at 7694)
.xdata$x:0000E308 __unwindtable$??1?$vector@V?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@V?$allocator@V?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@@2@@std@@QAE@XZ db 0FFh
.xdata$x:0000E308                                         ; DATA XREF: .xdata$x:0000E318o
.xdata$x:0000E309                 db 0FFh
.xdata$x:0000E30A                 db 0FFh
.xdata$x:0000E30B                 db 0FFh
.xdata$x:0000E30C                 dd offset __unwindfunclet$??1?$vector@V?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@V?$allocator@V?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@@2@@std@@QAE@XZ$0
.xdata$x:0000E310 __ehfuncinfo$??1?$vector@V?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@V?$allocator@V?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@@2@@std@@QAE@XZ db  22h ; "
.xdata$x:0000E310                                         ; DATA XREF: __ehhandler$??1?$vector@V?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@V?$allocator@V?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@@2@@std@@QAE@XZ+11o
.xdata$x:0000E311                 db    5
.xdata$x:0000E312                 db  93h ; ô
.xdata$x:0000E313                 db  19h
.xdata$x:0000E314                 db    1
.xdata$x:0000E315                 db    0
.xdata$x:0000E316                 db    0
.xdata$x:0000E317                 db    0
.xdata$x:0000E318                 dd offset __unwindtable$??1?$vector@V?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@V?$allocator@V?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@@2@@std@@QAE@XZ
.xdata$x:0000E31C                 db    0
.xdata$x:0000E31D                 db    0
.xdata$x:0000E31E                 db    0
.xdata$x:0000E31F                 db    0
.xdata$x:0000E320                 db    0
.xdata$x:0000E321                 db    0
.xdata$x:0000E322                 db    0
.xdata$x:0000E323                 db    0
.xdata$x:0000E324                 db    0
.xdata$x:0000E325                 db    0
.xdata$x:0000E326                 db    0
.xdata$x:0000E327                 db    0
.xdata$x:0000E328                 db    0
.xdata$x:0000E329                 db    0
.xdata$x:0000E32A                 db    0
.xdata$x:0000E32B                 db    0
.xdata$x:0000E32C                 db    0
.xdata$x:0000E32D                 db    0
.xdata$x:0000E32E                 db    0
.xdata$x:0000E32F                 db    0
.xdata$x:0000E330                 db    0
.xdata$x:0000E331                 db    0
.xdata$x:0000E332                 db    0
.xdata$x:0000E333                 db    0
.xdata$x:0000E333 _xdata$x        ends
.xdata$x:0000E333
.xdata$x:0000E334 ; ===========================================================================
.xdata$x:0000E334
.xdata$x:0000E334 ; Segment type: Pure data
.xdata$x:0000E334 ; Segment permissions: Read
.xdata$x:0000E334 _xdata$x        segment dword public 'DATA' use32
.xdata$x:0000E334                 assume cs:_xdata$x
.xdata$x:0000E334                 ;org 0E334h
.xdata$x:0000E334 ; COMDAT (pick associative to section at A1FC)
.xdata$x:0000E334 __catchsym$?_Reallocate@?$vector@V?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@V?$allocator@V?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@@2@@std@@IAEXI@Z$2 db    0
.xdata$x:0000E334                                         ; DATA XREF: .xdata$x:0000E364o
.xdata$x:0000E335                 db    0
.xdata$x:0000E336                 db    0
.xdata$x:0000E337                 db    0
.xdata$x:0000E338                 db    0
.xdata$x:0000E339                 db    0
.xdata$x:0000E33A                 db    0
.xdata$x:0000E33B                 db    0
.xdata$x:0000E33C                 db    0
.xdata$x:0000E33D                 db    0
.xdata$x:0000E33E                 db    0
.xdata$x:0000E33F                 db    0
.xdata$x:0000E340                 dd offset __catch$?_Reallocate@?$vector@V?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@V?$allocator@V?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@@2@@std@@IAEXI@Z$0
.xdata$x:0000E344 __unwindtable$?_Reallocate@?$vector@V?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@V?$allocator@V?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@@2@@std@@IAEXI@Z db 0FFh
.xdata$x:0000E344                                         ; DATA XREF: .xdata$x:0000E370o
.xdata$x:0000E345                 db 0FFh
.xdata$x:0000E346                 db 0FFh
.xdata$x:0000E347                 db 0FFh
.xdata$x:0000E348                 db    0
.xdata$x:0000E349                 db    0
.xdata$x:0000E34A                 db    0
.xdata$x:0000E34B                 db    0
.xdata$x:0000E34C                 db 0FFh
.xdata$x:0000E34D                 db 0FFh
.xdata$x:0000E34E                 db 0FFh
.xdata$x:0000E34F                 db 0FFh
.xdata$x:0000E350                 db    0
.xdata$x:0000E351                 db    0
.xdata$x:0000E352                 db    0
.xdata$x:0000E353                 db    0
.xdata$x:0000E354 __tryblocktable$?_Reallocate@?$vector@V?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@V?$allocator@V?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@@2@@std@@IAEXI@Z db    0
.xdata$x:0000E354                                         ; DATA XREF: .xdata$x:0000E378o
.xdata$x:0000E355                 db    0
.xdata$x:0000E356                 db    0
.xdata$x:0000E357                 db    0
.xdata$x:0000E358                 db    0
.xdata$x:0000E359                 db    0
.xdata$x:0000E35A                 db    0
.xdata$x:0000E35B                 db    0
.xdata$x:0000E35C                 db    1
.xdata$x:0000E35D                 db    0
.xdata$x:0000E35E                 db    0
.xdata$x:0000E35F                 db    0
.xdata$x:0000E360                 db    1
.xdata$x:0000E361                 db    0
.xdata$x:0000E362                 db    0
.xdata$x:0000E363                 db    0
.xdata$x:0000E364                 dd offset __catchsym$?_Reallocate@?$vector@V?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@V?$allocator@V?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@@2@@std@@IAEXI@Z$2
.xdata$x:0000E368 __ehfuncinfo$?_Reallocate@?$vector@V?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@V?$allocator@V?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@@2@@std@@IAEXI@Z db  22h ; "
.xdata$x:0000E368                                         ; DATA XREF: __ehhandler$?_Reallocate@?$vector@V?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@V?$allocator@V?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@@2@@std@@IAEXI@Z+11o
.xdata$x:0000E369                 db    5
.xdata$x:0000E36A                 db  93h ; ô
.xdata$x:0000E36B                 db  19h
.xdata$x:0000E36C                 db    2
.xdata$x:0000E36D                 db    0
.xdata$x:0000E36E                 db    0
.xdata$x:0000E36F                 db    0
.xdata$x:0000E370                 dd offset __unwindtable$?_Reallocate@?$vector@V?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@V?$allocator@V?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@@2@@std@@IAEXI@Z
.xdata$x:0000E374                 db    1
.xdata$x:0000E375                 db    0
.xdata$x:0000E376                 db    0
.xdata$x:0000E377                 db    0
.xdata$x:0000E378                 dd offset __tryblocktable$?_Reallocate@?$vector@V?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@V?$allocator@V?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@@2@@std@@IAEXI@Z
.xdata$x:0000E37C                 db    0
.xdata$x:0000E37D                 db    0
.xdata$x:0000E37E                 db    0
.xdata$x:0000E37F                 db    0
.xdata$x:0000E380                 db    0
.xdata$x:0000E381                 db    0
.xdata$x:0000E382                 db    0
.xdata$x:0000E383                 db    0
.xdata$x:0000E384                 db    0
.xdata$x:0000E385                 db    0
.xdata$x:0000E386                 db    0
.xdata$x:0000E387                 db    0
.xdata$x:0000E388                 db    0
.xdata$x:0000E389                 db    0
.xdata$x:0000E38A                 db    0
.xdata$x:0000E38B                 db    0
.xdata$x:0000E38B _xdata$x        ends
.xdata$x:0000E38B
.xdata$x:0000E38C ; ===========================================================================
.xdata$x:0000E38C
.xdata$x:0000E38C ; Segment type: Pure data
.xdata$x:0000E38C ; Segment permissions: Read
.xdata$x:0000E38C _xdata$x        segment dword public 'DATA' use32
.xdata$x:0000E38C                 assume cs:_xdata$x
.xdata$x:0000E38C                 ;org 0E38Ch
.xdata$x:0000E38C ; COMDAT (pick associative to section at 9F98)
.xdata$x:0000E38C __unwindtable$?_Orphan_range@?$vector@V?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@V?$allocator@V?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@@2@@std@@IBEXPAV?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@2@0@Z db 0FFh
.xdata$x:0000E38C                                         ; DATA XREF: .xdata$x:0000E39Co
.xdata$x:0000E38D                 db 0FFh
.xdata$x:0000E38E                 db 0FFh
.xdata$x:0000E38F                 db 0FFh
.xdata$x:0000E390                 dd offset __unwindfunclet$?_Orphan_range@?$vector@V?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@V?$allocator@V?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@@2@@std@@IBEXPAV?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@2@0@Z$0
.xdata$x:0000E394 __ehfuncinfo$?_Orphan_range@?$vector@V?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@V?$allocator@V?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@@2@@std@@IBEXPAV?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@2@0@Z db  22h ; "
.xdata$x:0000E394                                         ; DATA XREF: __ehhandler$?_Orphan_range@?$vector@V?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@V?$allocator@V?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@@2@@std@@IBEXPAV?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@2@0@Z+11o
.xdata$x:0000E395                 db    5
.xdata$x:0000E396                 db  93h ; ô
.xdata$x:0000E397                 db  19h
.xdata$x:0000E398                 db    1
.xdata$x:0000E399                 db    0
.xdata$x:0000E39A                 db    0
.xdata$x:0000E39B                 db    0
.xdata$x:0000E39C                 dd offset __unwindtable$?_Orphan_range@?$vector@V?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@V?$allocator@V?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@@2@@std@@IBEXPAV?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@2@0@Z
.xdata$x:0000E3A0                 db    0
.xdata$x:0000E3A1                 db    0
.xdata$x:0000E3A2                 db    0
.xdata$x:0000E3A3                 db    0
.xdata$x:0000E3A4                 db    0
.xdata$x:0000E3A5                 db    0
.xdata$x:0000E3A6                 db    0
.xdata$x:0000E3A7                 db    0
.xdata$x:0000E3A8                 db    0
.xdata$x:0000E3A9                 db    0
.xdata$x:0000E3AA                 db    0
.xdata$x:0000E3AB                 db    0
.xdata$x:0000E3AC                 db    0
.xdata$x:0000E3AD                 db    0
.xdata$x:0000E3AE                 db    0
.xdata$x:0000E3AF                 db    0
.xdata$x:0000E3B0                 db    0
.xdata$x:0000E3B1                 db    0
.xdata$x:0000E3B2                 db    0
.xdata$x:0000E3B3                 db    0
.xdata$x:0000E3B4                 db    0
.xdata$x:0000E3B5                 db    0
.xdata$x:0000E3B6                 db    0
.xdata$x:0000E3B7                 db    0
.xdata$x:0000E3B7 _xdata$x        ends
.xdata$x:0000E3B7
.xdata$x:0000E3B8 ; ===========================================================================
.xdata$x:0000E3B8
.xdata$x:0000E3B8 ; Segment type: Pure data
.xdata$x:0000E3B8 ; Segment permissions: Read
.xdata$x:0000E3B8 _xdata$x        segment dword public 'DATA' use32
.xdata$x:0000E3B8                 assume cs:_xdata$x
.xdata$x:0000E3B8                 ;org 0E3B8h
.xdata$x:0000E3B8 ; COMDAT (pick associative to section at 5E48)
.xdata$x:0000E3B8 __unwindtable$??0?$_Vector_val@U?$_Simple_types@_W@std@@@std@@QAE@XZ db 0FFh
.xdata$x:0000E3B8                                         ; DATA XREF: .xdata$x:0000E3C8o
.xdata$x:0000E3B9                 db 0FFh
.xdata$x:0000E3BA                 db 0FFh
.xdata$x:0000E3BB                 db 0FFh
.xdata$x:0000E3BC                 dd offset __unwindfunclet$??0?$_Vector_val@U?$_Simple_types@_W@std@@@std@@QAE@XZ$0
.xdata$x:0000E3C0 __ehfuncinfo$??0?$_Vector_val@U?$_Simple_types@_W@std@@@std@@QAE@XZ db  22h ; "
.xdata$x:0000E3C0                                         ; DATA XREF: __ehhandler$??0?$_Vector_val@U?$_Simple_types@_W@std@@@std@@QAE@XZ+11o
.xdata$x:0000E3C1                 db    5
.xdata$x:0000E3C2                 db  93h ; ô
.xdata$x:0000E3C3                 db  19h
.xdata$x:0000E3C4                 db    1
.xdata$x:0000E3C5                 db    0
.xdata$x:0000E3C6                 db    0
.xdata$x:0000E3C7                 db    0
.xdata$x:0000E3C8                 dd offset __unwindtable$??0?$_Vector_val@U?$_Simple_types@_W@std@@@std@@QAE@XZ
.xdata$x:0000E3CC                 db    0
.xdata$x:0000E3CD                 db    0
.xdata$x:0000E3CE                 db    0
.xdata$x:0000E3CF                 db    0
.xdata$x:0000E3D0                 db    0
.xdata$x:0000E3D1                 db    0
.xdata$x:0000E3D2                 db    0
.xdata$x:0000E3D3                 db    0
.xdata$x:0000E3D4                 db    0
.xdata$x:0000E3D5                 db    0
.xdata$x:0000E3D6                 db    0
.xdata$x:0000E3D7                 db    0
.xdata$x:0000E3D8                 db    0
.xdata$x:0000E3D9                 db    0
.xdata$x:0000E3DA                 db    0
.xdata$x:0000E3DB                 db    0
.xdata$x:0000E3DC                 db    0
.xdata$x:0000E3DD                 db    0
.xdata$x:0000E3DE                 db    0
.xdata$x:0000E3DF                 db    0
.xdata$x:0000E3E0                 db    0
.xdata$x:0000E3E1                 db    0
.xdata$x:0000E3E2                 db    0
.xdata$x:0000E3E3                 db    0
.xdata$x:0000E3E3 _xdata$x        ends
.xdata$x:0000E3E3
.xdata$x:0000E3E4 ; ===========================================================================
.xdata$x:0000E3E4
.xdata$x:0000E3E4 ; Segment type: Pure data
.xdata$x:0000E3E4 ; Segment permissions: Read
.xdata$x:0000E3E4 _xdata$x        segment dword public 'DATA' use32
.xdata$x:0000E3E4                 assume cs:_xdata$x
.xdata$x:0000E3E4                 ;org 0E3E4h
.xdata$x:0000E3E4 ; COMDAT (pick associative to section at 7444)
.xdata$x:0000E3E4 __unwindtable$??1?$_Vector_val@U?$_Simple_types@_W@std@@@std@@QAE@XZ db 0FFh
.xdata$x:0000E3E4                                         ; DATA XREF: .xdata$x:0000E3F4o
.xdata$x:0000E3E5                 db 0FFh
.xdata$x:0000E3E6                 db 0FFh
.xdata$x:0000E3E7                 db 0FFh
.xdata$x:0000E3E8                 dd offset __unwindfunclet$??1?$_Vector_val@U?$_Simple_types@_W@std@@@std@@QAE@XZ$0
.xdata$x:0000E3EC __ehfuncinfo$??1?$_Vector_val@U?$_Simple_types@_W@std@@@std@@QAE@XZ db  22h ; "
.xdata$x:0000E3EC                                         ; DATA XREF: __ehhandler$??1?$_Vector_val@U?$_Simple_types@_W@std@@@std@@QAE@XZ+11o
.xdata$x:0000E3ED                 db    5
.xdata$x:0000E3EE                 db  93h ; ô
.xdata$x:0000E3EF                 db  19h
.xdata$x:0000E3F0                 db    1
.xdata$x:0000E3F1                 db    0
.xdata$x:0000E3F2                 db    0
.xdata$x:0000E3F3                 db    0
.xdata$x:0000E3F4                 dd offset __unwindtable$??1?$_Vector_val@U?$_Simple_types@_W@std@@@std@@QAE@XZ
.xdata$x:0000E3F8                 db    0
.xdata$x:0000E3F9                 db    0
.xdata$x:0000E3FA                 db    0
.xdata$x:0000E3FB                 db    0
.xdata$x:0000E3FC                 db    0
.xdata$x:0000E3FD                 db    0
.xdata$x:0000E3FE                 db    0
.xdata$x:0000E3FF                 db    0
.xdata$x:0000E400                 db    0
.xdata$x:0000E401                 db    0
.xdata$x:0000E402                 db    0
.xdata$x:0000E403                 db    0
.xdata$x:0000E404                 db    0
.xdata$x:0000E405                 db    0
.xdata$x:0000E406                 db    0
.xdata$x:0000E407                 db    0
.xdata$x:0000E408                 db    0
.xdata$x:0000E409                 db    0
.xdata$x:0000E40A                 db    0
.xdata$x:0000E40B                 db    0
.xdata$x:0000E40C                 db    0
.xdata$x:0000E40D                 db    0
.xdata$x:0000E40E                 db    0
.xdata$x:0000E40F                 db    0
.xdata$x:0000E40F _xdata$x        ends
.xdata$x:0000E40F
.xdata$x:0000E410 ; ===========================================================================
.xdata$x:0000E410
.xdata$x:0000E410 ; Segment type: Pure data
.xdata$x:0000E410 ; Segment permissions: Read
.xdata$x:0000E410 _xdata$x        segment dword public 'DATA' use32
.xdata$x:0000E410                 assume cs:_xdata$x
.xdata$x:0000E410                 ;org 0E410h
.xdata$x:0000E410 ; COMDAT (pick associative to section at 5AA8)
.xdata$x:0000E410 __unwindtable$??0?$_Vector_alloc@$0A@U?$_Vec_base_types@_WV?$allocator@_W@std@@@std@@@std@@QAE@ABV?$allocator@_W@1@@Z db 0FFh
.xdata$x:0000E410                                         ; DATA XREF: .xdata$x:0000E420o
.xdata$x:0000E411                 db 0FFh
.xdata$x:0000E412                 db 0FFh
.xdata$x:0000E413                 db 0FFh
.xdata$x:0000E414                 dd offset __unwindfunclet$??0?$_Vector_alloc@$0A@U?$_Vec_base_types@_WV?$allocator@_W@std@@@std@@@std@@QAE@ABV?$allocator@_W@1@@Z$0
.xdata$x:0000E418 __ehfuncinfo$??0?$_Vector_alloc@$0A@U?$_Vec_base_types@_WV?$allocator@_W@std@@@std@@@std@@QAE@ABV?$allocator@_W@1@@Z db  22h ; "
.xdata$x:0000E418                                         ; DATA XREF: __ehhandler$??0?$_Vector_alloc@$0A@U?$_Vec_base_types@_WV?$allocator@_W@std@@@std@@@std@@QAE@ABV?$allocator@_W@1@@Z+11o
.xdata$x:0000E419                 db    5
.xdata$x:0000E41A                 db  93h ; ô
.xdata$x:0000E41B                 db  19h
.xdata$x:0000E41C                 db    1
.xdata$x:0000E41D                 db    0
.xdata$x:0000E41E                 db    0
.xdata$x:0000E41F                 db    0
.xdata$x:0000E420                 dd offset __unwindtable$??0?$_Vector_alloc@$0A@U?$_Vec_base_types@_WV?$allocator@_W@std@@@std@@@std@@QAE@ABV?$allocator@_W@1@@Z
.xdata$x:0000E424                 db    0
.xdata$x:0000E425                 db    0
.xdata$x:0000E426                 db    0
.xdata$x:0000E427                 db    0
.xdata$x:0000E428                 db    0
.xdata$x:0000E429                 db    0
.xdata$x:0000E42A                 db    0
.xdata$x:0000E42B                 db    0
.xdata$x:0000E42C                 db    0
.xdata$x:0000E42D                 db    0
.xdata$x:0000E42E                 db    0
.xdata$x:0000E42F                 db    0
.xdata$x:0000E430                 db    0
.xdata$x:0000E431                 db    0
.xdata$x:0000E432                 db    0
.xdata$x:0000E433                 db    0
.xdata$x:0000E434                 db    0
.xdata$x:0000E435                 db    0
.xdata$x:0000E436                 db    0
.xdata$x:0000E437                 db    0
.xdata$x:0000E438                 db    0
.xdata$x:0000E439                 db    0
.xdata$x:0000E43A                 db    0
.xdata$x:0000E43B                 db    0
.xdata$x:0000E43B _xdata$x        ends
.xdata$x:0000E43B
.xdata$x:0000E43C ; ===========================================================================
.xdata$x:0000E43C
.xdata$x:0000E43C ; Segment type: Pure data
.xdata$x:0000E43C ; Segment permissions: Read
.xdata$x:0000E43C _xdata$x        segment dword public 'DATA' use32
.xdata$x:0000E43C                 assume cs:_xdata$x
.xdata$x:0000E43C                 ;org 0E43Ch
.xdata$x:0000E43C ; COMDAT (pick associative to section at 720C)
.xdata$x:0000E43C __unwindtable$??1?$_Vector_alloc@$0A@U?$_Vec_base_types@_WV?$allocator@_W@std@@@std@@@std@@QAE@XZ db 0FFh
.xdata$x:0000E43C                                         ; DATA XREF: .xdata$x:0000E44Co
.xdata$x:0000E43D                 db 0FFh
.xdata$x:0000E43E                 db 0FFh
.xdata$x:0000E43F                 db 0FFh
.xdata$x:0000E440                 dd offset __unwindfunclet$??1?$_Vector_alloc@$0A@U?$_Vec_base_types@_WV?$allocator@_W@std@@@std@@@std@@QAE@XZ$0
.xdata$x:0000E444 __ehfuncinfo$??1?$_Vector_alloc@$0A@U?$_Vec_base_types@_WV?$allocator@_W@std@@@std@@@std@@QAE@XZ db  22h ; "
.xdata$x:0000E444                                         ; DATA XREF: __ehhandler$??1?$_Vector_alloc@$0A@U?$_Vec_base_types@_WV?$allocator@_W@std@@@std@@@std@@QAE@XZ+11o
.xdata$x:0000E445                 db    5
.xdata$x:0000E446                 db  93h ; ô
.xdata$x:0000E447                 db  19h
.xdata$x:0000E448                 db    1
.xdata$x:0000E449                 db    0
.xdata$x:0000E44A                 db    0
.xdata$x:0000E44B                 db    0
.xdata$x:0000E44C                 dd offset __unwindtable$??1?$_Vector_alloc@$0A@U?$_Vec_base_types@_WV?$allocator@_W@std@@@std@@@std@@QAE@XZ
.xdata$x:0000E450                 db    0
.xdata$x:0000E451                 db    0
.xdata$x:0000E452                 db    0
.xdata$x:0000E453                 db    0
.xdata$x:0000E454                 db    0
.xdata$x:0000E455                 db    0
.xdata$x:0000E456                 db    0
.xdata$x:0000E457                 db    0
.xdata$x:0000E458                 db    0
.xdata$x:0000E459                 db    0
.xdata$x:0000E45A                 db    0
.xdata$x:0000E45B                 db    0
.xdata$x:0000E45C                 db    0
.xdata$x:0000E45D                 db    0
.xdata$x:0000E45E                 db    0
.xdata$x:0000E45F                 db    0
.xdata$x:0000E460                 db    0
.xdata$x:0000E461                 db    0
.xdata$x:0000E462                 db    0
.xdata$x:0000E463                 db    0
.xdata$x:0000E464                 db    0
.xdata$x:0000E465                 db    0
.xdata$x:0000E466                 db    0
.xdata$x:0000E467                 db    0
.xdata$x:0000E467 _xdata$x        ends
.xdata$x:0000E467
.xdata$x:0000E468 ; ===========================================================================
.xdata$x:0000E468
.xdata$x:0000E468 ; Segment type: Pure data
.xdata$x:0000E468 ; Segment permissions: Read
.xdata$x:0000E468 _xdata$x        segment dword public 'DATA' use32
.xdata$x:0000E468                 assume cs:_xdata$x
.xdata$x:0000E468                 ;org 0E468h
.xdata$x:0000E468 ; COMDAT (pick associative to section at 6840)
.xdata$x:0000E468 __unwindtable$??0?$vector@_WV?$allocator@_W@std@@@std@@QAE@XZ db 0FFh
.xdata$x:0000E468                                         ; DATA XREF: .xdata$x:0000E478o
.xdata$x:0000E469                 db 0FFh
.xdata$x:0000E46A                 db 0FFh
.xdata$x:0000E46B                 db 0FFh
.xdata$x:0000E46C                 dd offset __unwindfunclet$??0?$vector@_WV?$allocator@_W@std@@@std@@QAE@XZ$0
.xdata$x:0000E470 __ehfuncinfo$??0?$vector@_WV?$allocator@_W@std@@@std@@QAE@XZ db  22h ; "
.xdata$x:0000E470                                         ; DATA XREF: __ehhandler$??0?$vector@_WV?$allocator@_W@std@@@std@@QAE@XZ+11o
.xdata$x:0000E471                 db    5
.xdata$x:0000E472                 db  93h ; ô
.xdata$x:0000E473                 db  19h
.xdata$x:0000E474                 db    1
.xdata$x:0000E475                 db    0
.xdata$x:0000E476                 db    0
.xdata$x:0000E477                 db    0
.xdata$x:0000E478                 dd offset __unwindtable$??0?$vector@_WV?$allocator@_W@std@@@std@@QAE@XZ
.xdata$x:0000E47C                 db    0
.xdata$x:0000E47D                 db    0
.xdata$x:0000E47E                 db    0
.xdata$x:0000E47F                 db    0
.xdata$x:0000E480                 db    0
.xdata$x:0000E481                 db    0
.xdata$x:0000E482                 db    0
.xdata$x:0000E483                 db    0
.xdata$x:0000E484                 db    0
.xdata$x:0000E485                 db    0
.xdata$x:0000E486                 db    0
.xdata$x:0000E487                 db    0
.xdata$x:0000E488                 db    0
.xdata$x:0000E489                 db    0
.xdata$x:0000E48A                 db    0
.xdata$x:0000E48B                 db    0
.xdata$x:0000E48C                 db    0
.xdata$x:0000E48D                 db    0
.xdata$x:0000E48E                 db    0
.xdata$x:0000E48F                 db    0
.xdata$x:0000E490                 db    0
.xdata$x:0000E491                 db    0
.xdata$x:0000E492                 db    0
.xdata$x:0000E493                 db    0
.xdata$x:0000E493 _xdata$x        ends
.xdata$x:0000E493
.xdata$x:0000E494 ; ===========================================================================
.xdata$x:0000E494
.xdata$x:0000E494 ; Segment type: Pure data
.xdata$x:0000E494 ; Segment permissions: Read
.xdata$x:0000E494 _xdata$x        segment dword public 'DATA' use32
.xdata$x:0000E494                 assume cs:_xdata$x
.xdata$x:0000E494                 ;org 0E494h
.xdata$x:0000E494 ; COMDAT (pick associative to section at 6740)
.xdata$x:0000E494 __catchsym$??0?$vector@_WV?$allocator@_W@std@@@std@@QAE@I@Z$3 db    0
.xdata$x:0000E494                                         ; DATA XREF: .xdata$x:0000E4B4o
.xdata$x:0000E495                 db    0
.xdata$x:0000E496                 db    0
.xdata$x:0000E497                 db    0
.xdata$x:0000E498                 db    0
.xdata$x:0000E499                 db    0
.xdata$x:0000E49A                 db    0
.xdata$x:0000E49B                 db    0
.xdata$x:0000E49C                 db    0
.xdata$x:0000E49D                 db    0
.xdata$x:0000E49E                 db    0
.xdata$x:0000E49F                 db    0
.xdata$x:0000E4A0                 dd offset __catch$??0?$vector@_WV?$allocator@_W@std@@@std@@QAE@I@Z$0
.xdata$x:0000E4A4 __tryblocktable$??0?$vector@_WV?$allocator@_W@std@@@std@@QAE@I@Z db    1
.xdata$x:0000E4A4                                         ; DATA XREF: .xdata$x:0000E4E0o
.xdata$x:0000E4A5                 db    0
.xdata$x:0000E4A6                 db    0
.xdata$x:0000E4A7                 db    0
.xdata$x:0000E4A8                 db    1
.xdata$x:0000E4A9                 db    0
.xdata$x:0000E4AA                 db    0
.xdata$x:0000E4AB                 db    0
.xdata$x:0000E4AC                 db    2
.xdata$x:0000E4AD                 db    0
.xdata$x:0000E4AE                 db    0
.xdata$x:0000E4AF                 db    0
.xdata$x:0000E4B0                 db    1
.xdata$x:0000E4B1                 db    0
.xdata$x:0000E4B2                 db    0
.xdata$x:0000E4B3                 db    0
.xdata$x:0000E4B4                 dd offset __catchsym$??0?$vector@_WV?$allocator@_W@std@@@std@@QAE@I@Z$3
.xdata$x:0000E4B8 __unwindtable$??0?$vector@_WV?$allocator@_W@std@@@std@@QAE@I@Z db 0FFh
.xdata$x:0000E4B8                                         ; DATA XREF: .xdata$x:0000E4D8o
.xdata$x:0000E4B9                 db 0FFh
.xdata$x:0000E4BA                 db 0FFh
.xdata$x:0000E4BB                 db 0FFh
.xdata$x:0000E4BC                 dd offset __unwindfunclet$??0?$vector@_WV?$allocator@_W@std@@@std@@QAE@I@Z$2
.xdata$x:0000E4C0                 db    0
.xdata$x:0000E4C1                 db    0
.xdata$x:0000E4C2                 db    0
.xdata$x:0000E4C3                 db    0
.xdata$x:0000E4C4                 db    0
.xdata$x:0000E4C5                 db    0
.xdata$x:0000E4C6                 db    0
.xdata$x:0000E4C7                 db    0
.xdata$x:0000E4C8                 db    0
.xdata$x:0000E4C9                 db    0
.xdata$x:0000E4CA                 db    0
.xdata$x:0000E4CB                 db    0
.xdata$x:0000E4CC                 db    0
.xdata$x:0000E4CD                 db    0
.xdata$x:0000E4CE                 db    0
.xdata$x:0000E4CF                 db    0
.xdata$x:0000E4D0 __ehfuncinfo$??0?$vector@_WV?$allocator@_W@std@@@std@@QAE@I@Z db  22h ; "
.xdata$x:0000E4D0                                         ; DATA XREF: __ehhandler$??0?$vector@_WV?$allocator@_W@std@@@std@@QAE@I@Z+11o
.xdata$x:0000E4D1                 db    5
.xdata$x:0000E4D2                 db  93h ; ô
.xdata$x:0000E4D3                 db  19h
.xdata$x:0000E4D4                 db    3
.xdata$x:0000E4D5                 db    0
.xdata$x:0000E4D6                 db    0
.xdata$x:0000E4D7                 db    0
.xdata$x:0000E4D8                 dd offset __unwindtable$??0?$vector@_WV?$allocator@_W@std@@@std@@QAE@I@Z
.xdata$x:0000E4DC                 db    1
.xdata$x:0000E4DD                 db    0
.xdata$x:0000E4DE                 db    0
.xdata$x:0000E4DF                 db    0
.xdata$x:0000E4E0                 dd offset __tryblocktable$??0?$vector@_WV?$allocator@_W@std@@@std@@QAE@I@Z
.xdata$x:0000E4E4                 db    0
.xdata$x:0000E4E5                 db    0
.xdata$x:0000E4E6                 db    0
.xdata$x:0000E4E7                 db    0
.xdata$x:0000E4E8                 db    0
.xdata$x:0000E4E9                 db    0
.xdata$x:0000E4EA                 db    0
.xdata$x:0000E4EB                 db    0
.xdata$x:0000E4EC                 db    0
.xdata$x:0000E4ED                 db    0
.xdata$x:0000E4EE                 db    0
.xdata$x:0000E4EF                 db    0
.xdata$x:0000E4F0                 db    0
.xdata$x:0000E4F1                 db    0
.xdata$x:0000E4F2                 db    0
.xdata$x:0000E4F3                 db    0
.xdata$x:0000E4F3 _xdata$x        ends
.xdata$x:0000E4F3
.xdata$x:0000E4F4 ; ===========================================================================
.xdata$x:0000E4F4
.xdata$x:0000E4F4 ; Segment type: Pure data
.xdata$x:0000E4F4 ; Segment permissions: Read
.xdata$x:0000E4F4 _xdata$x        segment dword public 'DATA' use32
.xdata$x:0000E4F4                 assume cs:_xdata$x
.xdata$x:0000E4F4                 ;org 0E4F4h
.xdata$x:0000E4F4 ; COMDAT (pick associative to section at 770C)
.xdata$x:0000E4F4 __unwindtable$??1?$vector@_WV?$allocator@_W@std@@@std@@QAE@XZ db 0FFh
.xdata$x:0000E4F4                                         ; DATA XREF: .xdata$x:0000E504o
.xdata$x:0000E4F5                 db 0FFh
.xdata$x:0000E4F6                 db 0FFh
.xdata$x:0000E4F7                 db 0FFh
.xdata$x:0000E4F8                 dd offset __unwindfunclet$??1?$vector@_WV?$allocator@_W@std@@@std@@QAE@XZ$0
.xdata$x:0000E4FC __ehfuncinfo$??1?$vector@_WV?$allocator@_W@std@@@std@@QAE@XZ db  22h ; "
.xdata$x:0000E4FC                                         ; DATA XREF: __ehhandler$??1?$vector@_WV?$allocator@_W@std@@@std@@QAE@XZ+11o
.xdata$x:0000E4FD                 db    5
.xdata$x:0000E4FE                 db  93h ; ô
.xdata$x:0000E4FF                 db  19h
.xdata$x:0000E500                 db    1
.xdata$x:0000E501                 db    0
.xdata$x:0000E502                 db    0
.xdata$x:0000E503                 db    0
.xdata$x:0000E504                 dd offset __unwindtable$??1?$vector@_WV?$allocator@_W@std@@@std@@QAE@XZ
.xdata$x:0000E508                 align 20h
.xdata$x:0000E508 _xdata$x        ends
.xdata$x:0000E508
.xdata$x:0000E520 ; ===========================================================================
.xdata$x:0000E520
.xdata$x:0000E520 ; Segment type: Pure data
.xdata$x:0000E520 ; Segment permissions: Read
.xdata$x:0000E520 _xdata$x        segment dword public 'DATA' use32
.xdata$x:0000E520                 assume cs:_xdata$x
.xdata$x:0000E520                 ;org 0E520h
.xdata$x:0000E520 ; COMDAT (pick associative to section at B468)
.xdata$x:0000E520 __unwindtable$?begin@?$vector@_WV?$allocator@_W@std@@@std@@QAE?AV?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@_W@std@@@std@@@2@XZ db 0FFh
.xdata$x:0000E520                                         ; DATA XREF: .xdata$x:0000E530o
.xdata$x:0000E521                 db 0FFh
.xdata$x:0000E522                 db 0FFh
.xdata$x:0000E523                 db 0FFh
.xdata$x:0000E524                 dd offset __unwindfunclet$?begin@?$vector@_WV?$allocator@_W@std@@@std@@QAE?AV?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@_W@std@@@std@@@2@XZ$0
.xdata$x:0000E528 __ehfuncinfo$?begin@?$vector@_WV?$allocator@_W@std@@@std@@QAE?AV?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@_W@std@@@std@@@2@XZ db  22h ; "
.xdata$x:0000E528                                         ; DATA XREF: __ehhandler$?begin@?$vector@_WV?$allocator@_W@std@@@std@@QAE?AV?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@_W@std@@@std@@@2@XZ+11o
.xdata$x:0000E529                 db    5
.xdata$x:0000E52A                 db  93h ; ô
.xdata$x:0000E52B                 db  19h
.xdata$x:0000E52C                 db    1
.xdata$x:0000E52D                 db    0
.xdata$x:0000E52E                 db    0
.xdata$x:0000E52F                 db    0
.xdata$x:0000E530                 dd offset __unwindtable$?begin@?$vector@_WV?$allocator@_W@std@@@std@@QAE?AV?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@_W@std@@@std@@@2@XZ
.xdata$x:0000E534                 db    0
.xdata$x:0000E535                 db    0
.xdata$x:0000E536                 db    0
.xdata$x:0000E537                 db    0
.xdata$x:0000E538                 db    0
.xdata$x:0000E539                 db    0
.xdata$x:0000E53A                 db    0
.xdata$x:0000E53B                 db    0
.xdata$x:0000E53C                 db    0
.xdata$x:0000E53D                 db    0
.xdata$x:0000E53E                 db    0
.xdata$x:0000E53F                 db    0
.xdata$x:0000E540                 db    0
.xdata$x:0000E541                 db    0
.xdata$x:0000E542                 db    0
.xdata$x:0000E543                 db    0
.xdata$x:0000E544                 db    0
.xdata$x:0000E545                 db    0
.xdata$x:0000E546                 db    0
.xdata$x:0000E547                 db    0
.xdata$x:0000E548                 db    0
.xdata$x:0000E549                 db    0
.xdata$x:0000E54A                 db    0
.xdata$x:0000E54B                 db    0
.xdata$x:0000E54B _xdata$x        ends
.xdata$x:0000E54B
.xdata$x:0000E54C ; ===========================================================================
.xdata$x:0000E54C
.xdata$x:0000E54C ; Segment type: Pure data
.xdata$x:0000E54C ; Segment permissions: Read
.xdata$x:0000E54C _xdata$x        segment dword public 'DATA' use32
.xdata$x:0000E54C                 assume cs:_xdata$x
.xdata$x:0000E54C                 ;org 0E54Ch
.xdata$x:0000E54C ; COMDAT (pick associative to section at BA58)
.xdata$x:0000E54C __unwindtable$?end@?$vector@_WV?$allocator@_W@std@@@std@@QAE?AV?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@_W@std@@@std@@@2@XZ db 0FFh
.xdata$x:0000E54C                                         ; DATA XREF: .xdata$x:0000E55Co
.xdata$x:0000E54D                 db 0FFh
.xdata$x:0000E54E                 db 0FFh
.xdata$x:0000E54F                 db 0FFh
.xdata$x:0000E550                 dd offset __unwindfunclet$?end@?$vector@_WV?$allocator@_W@std@@@std@@QAE?AV?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@_W@std@@@std@@@2@XZ$0
.xdata$x:0000E554 __ehfuncinfo$?end@?$vector@_WV?$allocator@_W@std@@@std@@QAE?AV?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@_W@std@@@std@@@2@XZ db  22h ; "
.xdata$x:0000E554                                         ; DATA XREF: __ehhandler$?end@?$vector@_WV?$allocator@_W@std@@@std@@QAE?AV?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@_W@std@@@std@@@2@XZ+11o
.xdata$x:0000E555                 db    5
.xdata$x:0000E556                 db  93h ; ô
.xdata$x:0000E557                 db  19h
.xdata$x:0000E558                 db    1
.xdata$x:0000E559                 db    0
.xdata$x:0000E55A                 db    0
.xdata$x:0000E55B                 db    0
.xdata$x:0000E55C                 dd offset __unwindtable$?end@?$vector@_WV?$allocator@_W@std@@@std@@QAE?AV?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@_W@std@@@std@@@2@XZ
.xdata$x:0000E560                 db    0
.xdata$x:0000E561                 db    0
.xdata$x:0000E562                 db    0
.xdata$x:0000E563                 db    0
.xdata$x:0000E564                 db    0
.xdata$x:0000E565                 db    0
.xdata$x:0000E566                 db    0
.xdata$x:0000E567                 db    0
.xdata$x:0000E568                 db    0
.xdata$x:0000E569                 db    0
.xdata$x:0000E56A                 db    0
.xdata$x:0000E56B                 db    0
.xdata$x:0000E56C                 db    0
.xdata$x:0000E56D                 db    0
.xdata$x:0000E56E                 db    0
.xdata$x:0000E56F                 db    0
.xdata$x:0000E570                 db    0
.xdata$x:0000E571                 db    0
.xdata$x:0000E572                 db    0
.xdata$x:0000E573                 db    0
.xdata$x:0000E574                 db    0
.xdata$x:0000E575                 db    0
.xdata$x:0000E576                 db    0
.xdata$x:0000E577                 db    0
.xdata$x:0000E577 _xdata$x        ends
.xdata$x:0000E577
.xdata$x:0000E578 ; ===========================================================================
.xdata$x:0000E578
.xdata$x:0000E578 ; Segment type: Pure data
.xdata$x:0000E578 ; Segment permissions: Read
.xdata$x:0000E578 _xdata$x        segment dword public 'DATA' use32
.xdata$x:0000E578                 assume cs:_xdata$x
.xdata$x:0000E578                 ;org 0E578h
.xdata$x:0000E578 ; COMDAT (pick associative to section at C9CC)
.xdata$x:0000E578 __unwindtable$?rbegin@?$vector@_WV?$allocator@_W@std@@@std@@QAE?AV?$reverse_iterator@V?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@_W@std@@@std@@@std@@@2@XZ db 0FFh
.xdata$x:0000E578                                         ; DATA XREF: .xdata$x:0000E598o
.xdata$x:0000E579                 db 0FFh
.xdata$x:0000E57A                 db 0FFh
.xdata$x:0000E57B                 db 0FFh
.xdata$x:0000E57C                 dd offset __unwindfunclet$?rbegin@?$vector@_WV?$allocator@_W@std@@@std@@QAE?AV?$reverse_iterator@V?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@_W@std@@@std@@@std@@@2@XZ$2
.xdata$x:0000E580                 db    0
.xdata$x:0000E581                 db    0
.xdata$x:0000E582                 db    0
.xdata$x:0000E583                 db    0
.xdata$x:0000E584                 dd offset __unwindfunclet$?rbegin@?$vector@_WV?$allocator@_W@std@@@std@@QAE?AV?$reverse_iterator@V?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@_W@std@@@std@@@std@@@2@XZ$0
.xdata$x:0000E588                 db    0
.xdata$x:0000E589                 db    0
.xdata$x:0000E58A                 db    0
.xdata$x:0000E58B                 db    0
.xdata$x:0000E58C                 dd offset __unwindfunclet$?rbegin@?$vector@_WV?$allocator@_W@std@@@std@@QAE?AV?$reverse_iterator@V?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@_W@std@@@std@@@std@@@2@XZ$1
.xdata$x:0000E590 __ehfuncinfo$?rbegin@?$vector@_WV?$allocator@_W@std@@@std@@QAE?AV?$reverse_iterator@V?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@_W@std@@@std@@@std@@@2@XZ db  22h ; "
.xdata$x:0000E590                                         ; DATA XREF: __ehhandler$?rbegin@?$vector@_WV?$allocator@_W@std@@@std@@QAE?AV?$reverse_iterator@V?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@_W@std@@@std@@@std@@@2@XZ+11o
.xdata$x:0000E591                 db    5
.xdata$x:0000E592                 db  93h ; ô
.xdata$x:0000E593                 db  19h
.xdata$x:0000E594                 db    3
.xdata$x:0000E595                 db    0
.xdata$x:0000E596                 db    0
.xdata$x:0000E597                 db    0
.xdata$x:0000E598                 dd offset __unwindtable$?rbegin@?$vector@_WV?$allocator@_W@std@@@std@@QAE?AV?$reverse_iterator@V?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@_W@std@@@std@@@std@@@2@XZ
.xdata$x:0000E59C                 db    0
.xdata$x:0000E59D                 db    0
.xdata$x:0000E59E                 db    0
.xdata$x:0000E59F                 db    0
.xdata$x:0000E5A0                 db    0
.xdata$x:0000E5A1                 db    0
.xdata$x:0000E5A2                 db    0
.xdata$x:0000E5A3                 db    0
.xdata$x:0000E5A4                 db    0
.xdata$x:0000E5A5                 db    0
.xdata$x:0000E5A6                 db    0
.xdata$x:0000E5A7                 db    0
.xdata$x:0000E5A8                 db    0
.xdata$x:0000E5A9                 db    0
.xdata$x:0000E5AA                 db    0
.xdata$x:0000E5AB                 db    0
.xdata$x:0000E5AC                 db    0
.xdata$x:0000E5AD                 db    0
.xdata$x:0000E5AE                 db    0
.xdata$x:0000E5AF                 db    0
.xdata$x:0000E5B0                 db    0
.xdata$x:0000E5B1                 db    0
.xdata$x:0000E5B2                 db    0
.xdata$x:0000E5B3                 db    0
.xdata$x:0000E5B3 _xdata$x        ends
.xdata$x:0000E5B3
.xdata$x:0000E5B4 ; ===========================================================================
.xdata$x:0000E5B4
.xdata$x:0000E5B4 ; Segment type: Pure data
.xdata$x:0000E5B4 ; Segment permissions: Read
.xdata$x:0000E5B4 _xdata$x        segment dword public 'DATA' use32
.xdata$x:0000E5B4                 assume cs:_xdata$x
.xdata$x:0000E5B4                 ;org 0E5B4h
.xdata$x:0000E5B4 ; COMDAT (pick associative to section at CAB4)
.xdata$x:0000E5B4 __unwindtable$?rend@?$vector@_WV?$allocator@_W@std@@@std@@QAE?AV?$reverse_iterator@V?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@_W@std@@@std@@@std@@@2@XZ db 0FFh
.xdata$x:0000E5B4                                         ; DATA XREF: .xdata$x:0000E5D4o
.xdata$x:0000E5B5                 db 0FFh
.xdata$x:0000E5B6                 db 0FFh
.xdata$x:0000E5B7                 db 0FFh
.xdata$x:0000E5B8                 dd offset __unwindfunclet$?rend@?$vector@_WV?$allocator@_W@std@@@std@@QAE?AV?$reverse_iterator@V?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@_W@std@@@std@@@std@@@2@XZ$2
.xdata$x:0000E5BC                 align 10h
.xdata$x:0000E5C0                 dd offset __unwindfunclet$?rend@?$vector@_WV?$allocator@_W@std@@@std@@QAE?AV?$reverse_iterator@V?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@_W@std@@@std@@@std@@@2@XZ$0
.xdata$x:0000E5C4                 align 8
.xdata$x:0000E5C8                 dd offset __unwindfunclet$?rend@?$vector@_WV?$allocator@_W@std@@@std@@QAE?AV?$reverse_iterator@V?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@_W@std@@@std@@@std@@@2@XZ$1
.xdata$x:0000E5CC __ehfuncinfo$?rend@?$vector@_WV?$allocator@_W@std@@@std@@QAE?AV?$reverse_iterator@V?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@_W@std@@@std@@@std@@@2@XZ db  22h ; "
.xdata$x:0000E5CC                                         ; DATA XREF: __ehhandler$?rend@?$vector@_WV?$allocator@_W@std@@@std@@QAE?AV?$reverse_iterator@V?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@_W@std@@@std@@@std@@@2@XZ+11o
.xdata$x:0000E5CD                 db    5
.xdata$x:0000E5CE                 db  93h ; ô
.xdata$x:0000E5CF                 db  19h
.xdata$x:0000E5D0                 db    3
.xdata$x:0000E5D1                 db    0
.xdata$x:0000E5D2                 db    0
.xdata$x:0000E5D3                 db    0
.xdata$x:0000E5D4                 dd offset __unwindtable$?rend@?$vector@_WV?$allocator@_W@std@@@std@@QAE?AV?$reverse_iterator@V?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@_W@std@@@std@@@std@@@2@XZ
.xdata$x:0000E5D8                 db    0
.xdata$x:0000E5D9                 db    0
.xdata$x:0000E5DA                 db    0
.xdata$x:0000E5DB                 db    0
.xdata$x:0000E5DC                 db    0
.xdata$x:0000E5DD                 db    0
.xdata$x:0000E5DE                 db    0
.xdata$x:0000E5DF                 db    0
.xdata$x:0000E5E0                 db    0
.xdata$x:0000E5E1                 db    0
.xdata$x:0000E5E2                 db    0
.xdata$x:0000E5E3                 db    0
.xdata$x:0000E5E4                 db    0
.xdata$x:0000E5E5                 db    0
.xdata$x:0000E5E6                 db    0
.xdata$x:0000E5E7                 db    0
.xdata$x:0000E5E8                 db    0
.xdata$x:0000E5E9                 db    0
.xdata$x:0000E5EA                 db    0
.xdata$x:0000E5EB                 db    0
.xdata$x:0000E5EC                 db    0
.xdata$x:0000E5ED                 db    0
.xdata$x:0000E5EE                 db    0
.xdata$x:0000E5EF                 db    0
.xdata$x:0000E5EF _xdata$x        ends
.xdata$x:0000E5EF
.xdata$x:0000E5F0 ; ===========================================================================
.xdata$x:0000E5F0
.xdata$x:0000E5F0 ; Segment type: Pure data
.xdata$x:0000E5F0 ; Segment permissions: Read
.xdata$x:0000E5F0 _xdata$x        segment dword public 'DATA' use32
.xdata$x:0000E5F0                 assume cs:_xdata$x
.xdata$x:0000E5F0                 ;org 0E5F0h
.xdata$x:0000E5F0 ; COMDAT (pick associative to section at A358)
.xdata$x:0000E5F0 __catchsym$?_Reallocate@?$vector@_WV?$allocator@_W@std@@@std@@IAEXI@Z$2 db    0
.xdata$x:0000E5F0                                         ; DATA XREF: .xdata$x:0000E620o
.xdata$x:0000E5F1                 db    0
.xdata$x:0000E5F2                 db    0
.xdata$x:0000E5F3                 db    0
.xdata$x:0000E5F4                 db    0
.xdata$x:0000E5F5                 db    0
.xdata$x:0000E5F6                 db    0
.xdata$x:0000E5F7                 db    0
.xdata$x:0000E5F8                 db    0
.xdata$x:0000E5F9                 db    0
.xdata$x:0000E5FA                 db    0
.xdata$x:0000E5FB                 db    0
.xdata$x:0000E5FC                 dd offset __catch$?_Reallocate@?$vector@_WV?$allocator@_W@std@@@std@@IAEXI@Z$0
.xdata$x:0000E600 __unwindtable$?_Reallocate@?$vector@_WV?$allocator@_W@std@@@std@@IAEXI@Z db 0FFh
.xdata$x:0000E600                                         ; DATA XREF: .xdata$x:0000E62Co
.xdata$x:0000E601                 db 0FFh
.xdata$x:0000E602                 db 0FFh
.xdata$x:0000E603                 db 0FFh
.xdata$x:0000E604                 db    0
.xdata$x:0000E605                 db    0
.xdata$x:0000E606                 db    0
.xdata$x:0000E607                 db    0
.xdata$x:0000E608                 db 0FFh
.xdata$x:0000E609                 db 0FFh
.xdata$x:0000E60A                 db 0FFh
.xdata$x:0000E60B                 db 0FFh
.xdata$x:0000E60C                 db    0
.xdata$x:0000E60D                 db    0
.xdata$x:0000E60E                 db    0
.xdata$x:0000E60F                 db    0
.xdata$x:0000E610 __tryblocktable$?_Reallocate@?$vector@_WV?$allocator@_W@std@@@std@@IAEXI@Z db    0
.xdata$x:0000E610                                         ; DATA XREF: .xdata$x:0000E634o
.xdata$x:0000E611                 db    0
.xdata$x:0000E612                 db    0
.xdata$x:0000E613                 db    0
.xdata$x:0000E614                 db    0
.xdata$x:0000E615                 db    0
.xdata$x:0000E616                 db    0
.xdata$x:0000E617                 db    0
.xdata$x:0000E618                 db    1
.xdata$x:0000E619                 db    0
.xdata$x:0000E61A                 db    0
.xdata$x:0000E61B                 db    0
.xdata$x:0000E61C                 db    1
.xdata$x:0000E61D                 db    0
.xdata$x:0000E61E                 db    0
.xdata$x:0000E61F                 db    0
.xdata$x:0000E620                 dd offset __catchsym$?_Reallocate@?$vector@_WV?$allocator@_W@std@@@std@@IAEXI@Z$2
.xdata$x:0000E624 __ehfuncinfo$?_Reallocate@?$vector@_WV?$allocator@_W@std@@@std@@IAEXI@Z db  22h ; "
.xdata$x:0000E624                                         ; DATA XREF: __ehhandler$?_Reallocate@?$vector@_WV?$allocator@_W@std@@@std@@IAEXI@Z+11o
.xdata$x:0000E625                 db    5
.xdata$x:0000E626                 db  93h ; ô
.xdata$x:0000E627                 db  19h
.xdata$x:0000E628                 db    2
.xdata$x:0000E629                 db    0
.xdata$x:0000E62A                 db    0
.xdata$x:0000E62B                 db    0
.xdata$x:0000E62C                 dd offset __unwindtable$?_Reallocate@?$vector@_WV?$allocator@_W@std@@@std@@IAEXI@Z
.xdata$x:0000E630                 db    1
.xdata$x:0000E631                 db    0
.xdata$x:0000E632                 db    0
.xdata$x:0000E633                 db    0
.xdata$x:0000E634                 dd offset __tryblocktable$?_Reallocate@?$vector@_WV?$allocator@_W@std@@@std@@IAEXI@Z
.xdata$x:0000E638                 db    0
.xdata$x:0000E639                 db    0
.xdata$x:0000E63A                 db    0
.xdata$x:0000E63B                 db    0
.xdata$x:0000E63C                 db    0
.xdata$x:0000E63D                 db    0
.xdata$x:0000E63E                 db    0
.xdata$x:0000E63F                 db    0
.xdata$x:0000E640                 db    0
.xdata$x:0000E641                 db    0
.xdata$x:0000E642                 db    0
.xdata$x:0000E643                 db    0
.xdata$x:0000E644                 db    0
.xdata$x:0000E645                 db    0
.xdata$x:0000E646                 db    0
.xdata$x:0000E647                 db    0
.xdata$x:0000E647 _xdata$x        ends
.xdata$x:0000E647
.xdata$x:0000E648 ; ===========================================================================
.xdata$x:0000E648
.xdata$x:0000E648 ; Segment type: Pure data
.xdata$x:0000E648 ; Segment permissions: Read
.xdata$x:0000E648 _xdata$x        segment dword public 'DATA' use32
.xdata$x:0000E648                 assume cs:_xdata$x
.xdata$x:0000E648                 ;org 0E648h
.xdata$x:0000E648 ; COMDAT (pick associative to section at A074)
.xdata$x:0000E648 __unwindtable$?_Orphan_range@?$vector@_WV?$allocator@_W@std@@@std@@IBEXPA_W0@Z db 0FFh
.xdata$x:0000E648                                         ; DATA XREF: .xdata$x:0000E658o
.xdata$x:0000E649                 db 0FFh
.xdata$x:0000E64A                 db 0FFh
.xdata$x:0000E64B                 db 0FFh
.xdata$x:0000E64C                 dd offset __unwindfunclet$?_Orphan_range@?$vector@_WV?$allocator@_W@std@@@std@@IBEXPA_W0@Z$0
.xdata$x:0000E650 __ehfuncinfo$?_Orphan_range@?$vector@_WV?$allocator@_W@std@@@std@@IBEXPA_W0@Z db  22h ; "
.xdata$x:0000E650                                         ; DATA XREF: __ehhandler$?_Orphan_range@?$vector@_WV?$allocator@_W@std@@@std@@IBEXPA_W0@Z+11o
.xdata$x:0000E651                 db    5
.xdata$x:0000E652                 db  93h ; ô
.xdata$x:0000E653                 db  19h
.xdata$x:0000E654                 db    1
.xdata$x:0000E655                 db    0
.xdata$x:0000E656                 db    0
.xdata$x:0000E657                 db    0
.xdata$x:0000E658                 dd offset __unwindtable$?_Orphan_range@?$vector@_WV?$allocator@_W@std@@@std@@IBEXPA_W0@Z
.xdata$x:0000E65C                 db    0
.xdata$x:0000E65D                 db    0
.xdata$x:0000E65E                 db    0
.xdata$x:0000E65F                 db    0
.xdata$x:0000E660                 db    0
.xdata$x:0000E661                 db    0
.xdata$x:0000E662                 db    0
.xdata$x:0000E663                 db    0
.xdata$x:0000E664                 db    0
.xdata$x:0000E665                 db    0
.xdata$x:0000E666                 db    0
.xdata$x:0000E667                 db    0
.xdata$x:0000E668                 db    0
.xdata$x:0000E669                 db    0
.xdata$x:0000E66A                 db    0
.xdata$x:0000E66B                 db    0
.xdata$x:0000E66C                 db    0
.xdata$x:0000E66D                 db    0
.xdata$x:0000E66E                 db    0
.xdata$x:0000E66F                 db    0
.xdata$x:0000E670                 db    0
.xdata$x:0000E671                 db    0
.xdata$x:0000E672                 db    0
.xdata$x:0000E673                 db    0
.xdata$x:0000E673 _xdata$x        ends
.xdata$x:0000E673
.xdata$x:0000E674 ; ===========================================================================
.xdata$x:0000E674
.xdata$x:0000E674 ; Segment type: Pure data
.xdata$x:0000E674 ; Segment permissions: Read
.xdata$x:0000E674 _xdata$x        segment dword public 'DATA' use32
.xdata$x:0000E674                 assume cs:_xdata$x
.xdata$x:0000E674                 ;org 0E674h
.xdata$x:0000E674 ; COMDAT (pick associative to section at 5D28)
.xdata$x:0000E674 __unwindtable$??0?$_Vector_val@U?$_Simple_types@D@std@@@std@@QAE@XZ db 0FFh
.xdata$x:0000E674                                         ; DATA XREF: .xdata$x:0000E684o
.xdata$x:0000E675                 db 0FFh
.xdata$x:0000E676                 db 0FFh
.xdata$x:0000E677                 db 0FFh
.xdata$x:0000E678                 dd offset __unwindfunclet$??0?$_Vector_val@U?$_Simple_types@D@std@@@std@@QAE@XZ$0
.xdata$x:0000E67C __ehfuncinfo$??0?$_Vector_val@U?$_Simple_types@D@std@@@std@@QAE@XZ db  22h ; "
.xdata$x:0000E67C                                         ; DATA XREF: __ehhandler$??0?$_Vector_val@U?$_Simple_types@D@std@@@std@@QAE@XZ+11o
.xdata$x:0000E67D                 db    5
.xdata$x:0000E67E                 db  93h ; ô
.xdata$x:0000E67F                 db  19h
.xdata$x:0000E680                 db    1
.xdata$x:0000E681                 db    0
.xdata$x:0000E682                 db    0
.xdata$x:0000E683                 db    0
.xdata$x:0000E684                 dd offset __unwindtable$??0?$_Vector_val@U?$_Simple_types@D@std@@@std@@QAE@XZ
.xdata$x:0000E688                 align 20h
.xdata$x:0000E688 _xdata$x        ends
.xdata$x:0000E688
.xdata$x:0000E6A0 ; ===========================================================================
.xdata$x:0000E6A0
.xdata$x:0000E6A0 ; Segment type: Pure data
.xdata$x:0000E6A0 ; Segment permissions: Read
.xdata$x:0000E6A0 _xdata$x        segment dword public 'DATA' use32
.xdata$x:0000E6A0                 assume cs:_xdata$x
.xdata$x:0000E6A0                 ;org 0E6A0h
.xdata$x:0000E6A0 ; COMDAT (pick associative to section at 7364)
.xdata$x:0000E6A0 __unwindtable$??1?$_Vector_val@U?$_Simple_types@D@std@@@std@@QAE@XZ db 0FFh
.xdata$x:0000E6A0                                         ; DATA XREF: .xdata$x:0000E6B0o
.xdata$x:0000E6A1                 db 0FFh
.xdata$x:0000E6A2                 db 0FFh
.xdata$x:0000E6A3                 db 0FFh
.xdata$x:0000E6A4                 dd offset __unwindfunclet$??1?$_Vector_val@U?$_Simple_types@D@std@@@std@@QAE@XZ$0
.xdata$x:0000E6A8 __ehfuncinfo$??1?$_Vector_val@U?$_Simple_types@D@std@@@std@@QAE@XZ db  22h ; "
.xdata$x:0000E6A8                                         ; DATA XREF: __ehhandler$??1?$_Vector_val@U?$_Simple_types@D@std@@@std@@QAE@XZ+11o
.xdata$x:0000E6A9                 db    5
.xdata$x:0000E6AA                 db  93h ; ô
.xdata$x:0000E6AB                 db  19h
.xdata$x:0000E6AC                 db    1
.xdata$x:0000E6AD                 db    0
.xdata$x:0000E6AE                 db    0
.xdata$x:0000E6AF                 db    0
.xdata$x:0000E6B0                 dd offset __unwindtable$??1?$_Vector_val@U?$_Simple_types@D@std@@@std@@QAE@XZ
.xdata$x:0000E6B4                 db    0
.xdata$x:0000E6B5                 db    0
.xdata$x:0000E6B6                 db    0
.xdata$x:0000E6B7                 db    0
.xdata$x:0000E6B8                 db    0
.xdata$x:0000E6B9                 db    0
.xdata$x:0000E6BA                 db    0
.xdata$x:0000E6BB                 db    0
.xdata$x:0000E6BC                 db    0
.xdata$x:0000E6BD                 db    0
.xdata$x:0000E6BE                 db    0
.xdata$x:0000E6BF                 db    0
.xdata$x:0000E6C0                 db    0
.xdata$x:0000E6C1                 db    0
.xdata$x:0000E6C2                 db    0
.xdata$x:0000E6C3                 db    0
.xdata$x:0000E6C4                 db    0
.xdata$x:0000E6C5                 db    0
.xdata$x:0000E6C6                 db    0
.xdata$x:0000E6C7                 db    0
.xdata$x:0000E6C8                 db    0
.xdata$x:0000E6C9                 db    0
.xdata$x:0000E6CA                 db    0
.xdata$x:0000E6CB                 db    0
.xdata$x:0000E6CB _xdata$x        ends
.xdata$x:0000E6CB
.xdata$x:0000E6CC ; ===========================================================================
.xdata$x:0000E6CC
.xdata$x:0000E6CC ; Segment type: Pure data
.xdata$x:0000E6CC ; Segment permissions: Read
.xdata$x:0000E6CC _xdata$x        segment dword public 'DATA' use32
.xdata$x:0000E6CC                 assume cs:_xdata$x
.xdata$x:0000E6CC                 ;org 0E6CCh
.xdata$x:0000E6CC ; COMDAT (pick associative to section at 59B0)
.xdata$x:0000E6CC __unwindtable$??0?$_Vector_alloc@$0A@U?$_Vec_base_types@DV?$allocator@D@std@@@std@@@std@@QAE@ABV?$allocator@D@1@@Z db 0FFh
.xdata$x:0000E6CC                                         ; DATA XREF: .xdata$x:0000E6DCo
.xdata$x:0000E6CD                 db 0FFh
.xdata$x:0000E6CE                 db 0FFh
.xdata$x:0000E6CF                 db 0FFh
.xdata$x:0000E6D0                 dd offset __unwindfunclet$??0?$_Vector_alloc@$0A@U?$_Vec_base_types@DV?$allocator@D@std@@@std@@@std@@QAE@ABV?$allocator@D@1@@Z$0
.xdata$x:0000E6D4 __ehfuncinfo$??0?$_Vector_alloc@$0A@U?$_Vec_base_types@DV?$allocator@D@std@@@std@@@std@@QAE@ABV?$allocator@D@1@@Z db  22h ; "
.xdata$x:0000E6D4                                         ; DATA XREF: __ehhandler$??0?$_Vector_alloc@$0A@U?$_Vec_base_types@DV?$allocator@D@std@@@std@@@std@@QAE@ABV?$allocator@D@1@@Z+11o
.xdata$x:0000E6D5                 db    5
.xdata$x:0000E6D6                 db  93h ; ô
.xdata$x:0000E6D7                 db  19h
.xdata$x:0000E6D8                 db    1
.xdata$x:0000E6D9                 db    0
.xdata$x:0000E6DA                 db    0
.xdata$x:0000E6DB                 db    0
.xdata$x:0000E6DC                 dd offset __unwindtable$??0?$_Vector_alloc@$0A@U?$_Vec_base_types@DV?$allocator@D@std@@@std@@@std@@QAE@ABV?$allocator@D@1@@Z
.xdata$x:0000E6E0                 db    0
.xdata$x:0000E6E1                 db    0
.xdata$x:0000E6E2                 db    0
.xdata$x:0000E6E3                 db    0
.xdata$x:0000E6E4                 db    0
.xdata$x:0000E6E5                 db    0
.xdata$x:0000E6E6                 db    0
.xdata$x:0000E6E7                 db    0
.xdata$x:0000E6E8                 db    0
.xdata$x:0000E6E9                 db    0
.xdata$x:0000E6EA                 db    0
.xdata$x:0000E6EB                 db    0
.xdata$x:0000E6EC                 db    0
.xdata$x:0000E6ED                 db    0
.xdata$x:0000E6EE                 db    0
.xdata$x:0000E6EF                 db    0
.xdata$x:0000E6F0                 db    0
.xdata$x:0000E6F1                 db    0
.xdata$x:0000E6F2                 db    0
.xdata$x:0000E6F3                 db    0
.xdata$x:0000E6F4                 db    0
.xdata$x:0000E6F5                 db    0
.xdata$x:0000E6F6                 db    0
.xdata$x:0000E6F7                 db    0
.xdata$x:0000E6F7 _xdata$x        ends
.xdata$x:0000E6F7
.xdata$x:0000E6F8 ; ===========================================================================
.xdata$x:0000E6F8
.xdata$x:0000E6F8 ; Segment type: Pure data
.xdata$x:0000E6F8 ; Segment permissions: Read
.xdata$x:0000E6F8 _xdata$x        segment dword public 'DATA' use32
.xdata$x:0000E6F8                 assume cs:_xdata$x
.xdata$x:0000E6F8                 ;org 0E6F8h
.xdata$x:0000E6F8 ; COMDAT (pick associative to section at 711C)
.xdata$x:0000E6F8 __unwindtable$??1?$_Vector_alloc@$0A@U?$_Vec_base_types@DV?$allocator@D@std@@@std@@@std@@QAE@XZ db 0FFh
.xdata$x:0000E6F8                                         ; DATA XREF: .xdata$x:0000E708o
.xdata$x:0000E6F9                 db 0FFh
.xdata$x:0000E6FA                 db 0FFh
.xdata$x:0000E6FB                 db 0FFh
.xdata$x:0000E6FC                 dd offset __unwindfunclet$??1?$_Vector_alloc@$0A@U?$_Vec_base_types@DV?$allocator@D@std@@@std@@@std@@QAE@XZ$0
.xdata$x:0000E700 __ehfuncinfo$??1?$_Vector_alloc@$0A@U?$_Vec_base_types@DV?$allocator@D@std@@@std@@@std@@QAE@XZ db  22h ; "
.xdata$x:0000E700                                         ; DATA XREF: __ehhandler$??1?$_Vector_alloc@$0A@U?$_Vec_base_types@DV?$allocator@D@std@@@std@@@std@@QAE@XZ+11o
.xdata$x:0000E701                 db    5
.xdata$x:0000E702                 db  93h ; ô
.xdata$x:0000E703                 db  19h
.xdata$x:0000E704                 db    1
.xdata$x:0000E705                 db    0
.xdata$x:0000E706                 db    0
.xdata$x:0000E707                 db    0
.xdata$x:0000E708                 dd offset __unwindtable$??1?$_Vector_alloc@$0A@U?$_Vec_base_types@DV?$allocator@D@std@@@std@@@std@@QAE@XZ
.xdata$x:0000E70C                 db    0
.xdata$x:0000E70D                 db    0
.xdata$x:0000E70E                 db    0
.xdata$x:0000E70F                 db    0
.xdata$x:0000E710                 db    0
.xdata$x:0000E711                 db    0
.xdata$x:0000E712                 db    0
.xdata$x:0000E713                 db    0
.xdata$x:0000E714                 db    0
.xdata$x:0000E715                 db    0
.xdata$x:0000E716                 db    0
.xdata$x:0000E717                 db    0
.xdata$x:0000E718                 db    0
.xdata$x:0000E719                 db    0
.xdata$x:0000E71A                 db    0
.xdata$x:0000E71B                 db    0
.xdata$x:0000E71C                 db    0
.xdata$x:0000E71D                 db    0
.xdata$x:0000E71E                 db    0
.xdata$x:0000E71F                 db    0
.xdata$x:0000E720                 db    0
.xdata$x:0000E721                 db    0
.xdata$x:0000E722                 db    0
.xdata$x:0000E723                 db    0
.xdata$x:0000E723 _xdata$x        ends
.xdata$x:0000E723
.xdata$x:0000E724 ; ===========================================================================
.xdata$x:0000E724
.xdata$x:0000E724 ; Segment type: Pure data
.xdata$x:0000E724 ; Segment permissions: Read
.xdata$x:0000E724 _xdata$x        segment dword public 'DATA' use32
.xdata$x:0000E724                 assume cs:_xdata$x
.xdata$x:0000E724                 ;org 0E724h
.xdata$x:0000E724 ; COMDAT (pick associative to section at 6520)
.xdata$x:0000E724 __catchsym$??0?$vector@DV?$allocator@D@std@@@std@@QAE@I@Z$3 db    0
.xdata$x:0000E724                                         ; DATA XREF: .xdata$x:0000E744o
.xdata$x:0000E725                 db    0
.xdata$x:0000E726                 db    0
.xdata$x:0000E727                 db    0
.xdata$x:0000E728                 db    0
.xdata$x:0000E729                 db    0
.xdata$x:0000E72A                 db    0
.xdata$x:0000E72B                 db    0
.xdata$x:0000E72C                 db    0
.xdata$x:0000E72D                 db    0
.xdata$x:0000E72E                 db    0
.xdata$x:0000E72F                 db    0
.xdata$x:0000E730                 dd offset __catch$??0?$vector@DV?$allocator@D@std@@@std@@QAE@I@Z$0
.xdata$x:0000E734 __tryblocktable$??0?$vector@DV?$allocator@D@std@@@std@@QAE@I@Z db    1
.xdata$x:0000E734                                         ; DATA XREF: .xdata$x:0000E770o
.xdata$x:0000E735                 db    0
.xdata$x:0000E736                 db    0
.xdata$x:0000E737                 db    0
.xdata$x:0000E738                 db    1
.xdata$x:0000E739                 db    0
.xdata$x:0000E73A                 db    0
.xdata$x:0000E73B                 db    0
.xdata$x:0000E73C                 db    2
.xdata$x:0000E73D                 db    0
.xdata$x:0000E73E                 db    0
.xdata$x:0000E73F                 db    0
.xdata$x:0000E740                 db    1
.xdata$x:0000E741                 db    0
.xdata$x:0000E742                 db    0
.xdata$x:0000E743                 db    0
.xdata$x:0000E744                 dd offset __catchsym$??0?$vector@DV?$allocator@D@std@@@std@@QAE@I@Z$3
.xdata$x:0000E748 __unwindtable$??0?$vector@DV?$allocator@D@std@@@std@@QAE@I@Z db 0FFh
.xdata$x:0000E748                                         ; DATA XREF: .xdata$x:0000E768o
.xdata$x:0000E749                 db 0FFh
.xdata$x:0000E74A                 db 0FFh
.xdata$x:0000E74B                 db 0FFh
.xdata$x:0000E74C                 dd offset __unwindfunclet$??0?$vector@DV?$allocator@D@std@@@std@@QAE@I@Z$2
.xdata$x:0000E750                 align 20h
.xdata$x:0000E760 __ehfuncinfo$??0?$vector@DV?$allocator@D@std@@@std@@QAE@I@Z db  22h ; "
.xdata$x:0000E760                                         ; DATA XREF: __ehhandler$??0?$vector@DV?$allocator@D@std@@@std@@QAE@I@Z+11o
.xdata$x:0000E761                 db    5
.xdata$x:0000E762                 db  93h ; ô
.xdata$x:0000E763                 db  19h
.xdata$x:0000E764                 db    3
.xdata$x:0000E765                 db    0
.xdata$x:0000E766                 db    0
.xdata$x:0000E767                 db    0
.xdata$x:0000E768                 dd offset __unwindtable$??0?$vector@DV?$allocator@D@std@@@std@@QAE@I@Z
.xdata$x:0000E76C                 db    1
.xdata$x:0000E76D                 db    0
.xdata$x:0000E76E                 db    0
.xdata$x:0000E76F                 db    0
.xdata$x:0000E770                 dd offset __tryblocktable$??0?$vector@DV?$allocator@D@std@@@std@@QAE@I@Z
.xdata$x:0000E774                 db    0
.xdata$x:0000E775                 db    0
.xdata$x:0000E776                 db    0
.xdata$x:0000E777                 db    0
.xdata$x:0000E778                 db    0
.xdata$x:0000E779                 db    0
.xdata$x:0000E77A                 db    0
.xdata$x:0000E77B                 db    0
.xdata$x:0000E77C                 db    0
.xdata$x:0000E77D                 db    0
.xdata$x:0000E77E                 db    0
.xdata$x:0000E77F                 db    0
.xdata$x:0000E780                 db    0
.xdata$x:0000E781                 db    0
.xdata$x:0000E782                 db    0
.xdata$x:0000E783                 db    0
.xdata$x:0000E783 _xdata$x        ends
.xdata$x:0000E783
.xdata$x:0000E784 ; ===========================================================================
.xdata$x:0000E784
.xdata$x:0000E784 ; Segment type: Pure data
.xdata$x:0000E784 ; Segment permissions: Read
.xdata$x:0000E784 _xdata$x        segment dword public 'DATA' use32
.xdata$x:0000E784                 assume cs:_xdata$x
.xdata$x:0000E784                 ;org 0E784h
.xdata$x:0000E784 ; COMDAT (pick associative to section at 761C)
.xdata$x:0000E784 __unwindtable$??1?$vector@DV?$allocator@D@std@@@std@@QAE@XZ db 0FFh
.xdata$x:0000E784                                         ; DATA XREF: .xdata$x:0000E794o
.xdata$x:0000E785                 db 0FFh
.xdata$x:0000E786                 db 0FFh
.xdata$x:0000E787                 db 0FFh
.xdata$x:0000E788                 dd offset __unwindfunclet$??1?$vector@DV?$allocator@D@std@@@std@@QAE@XZ$0
.xdata$x:0000E78C __ehfuncinfo$??1?$vector@DV?$allocator@D@std@@@std@@QAE@XZ db  22h ; "
.xdata$x:0000E78C                                         ; DATA XREF: __ehhandler$??1?$vector@DV?$allocator@D@std@@@std@@QAE@XZ+11o
.xdata$x:0000E78D                 db    5
.xdata$x:0000E78E                 db  93h ; ô
.xdata$x:0000E78F                 db  19h
.xdata$x:0000E790                 db    1
.xdata$x:0000E791                 db    0
.xdata$x:0000E792                 db    0
.xdata$x:0000E793                 db    0
.xdata$x:0000E794                 dd offset __unwindtable$??1?$vector@DV?$allocator@D@std@@@std@@QAE@XZ
.xdata$x:0000E798                 db    0
.xdata$x:0000E799                 db    0
.xdata$x:0000E79A                 db    0
.xdata$x:0000E79B                 db    0
.xdata$x:0000E79C                 db    0
.xdata$x:0000E79D                 db    0
.xdata$x:0000E79E                 db    0
.xdata$x:0000E79F                 db    0
.xdata$x:0000E7A0                 db    0
.xdata$x:0000E7A1                 db    0
.xdata$x:0000E7A2                 db    0
.xdata$x:0000E7A3                 db    0
.xdata$x:0000E7A4                 db    0
.xdata$x:0000E7A5                 db    0
.xdata$x:0000E7A6                 db    0
.xdata$x:0000E7A7                 db    0
.xdata$x:0000E7A8                 db    0
.xdata$x:0000E7A9                 db    0
.xdata$x:0000E7AA                 db    0
.xdata$x:0000E7AB                 db    0
.xdata$x:0000E7AC                 db    0
.xdata$x:0000E7AD                 db    0
.xdata$x:0000E7AE                 db    0
.xdata$x:0000E7AF                 db    0
.xdata$x:0000E7AF _xdata$x        ends
.xdata$x:0000E7AF
.xdata$x:0000E7B0 ; ===========================================================================
.xdata$x:0000E7B0
.xdata$x:0000E7B0 ; Segment type: Pure data
.xdata$x:0000E7B0 ; Segment permissions: Read
.xdata$x:0000E7B0 _xdata$x        segment dword public 'DATA' use32
.xdata$x:0000E7B0                 assume cs:_xdata$x
.xdata$x:0000E7B0                 ;org 0E7B0h
.xdata$x:0000E7B0 ; COMDAT (pick associative to section at 542C)
.xdata$x:0000E7B0 __unwindtable$??0?$_Iterator012@Urandom_access_iterator_tag@std@@_WHPB_WAB_WU_Iterator_base12@2@@std@@QAE@XZ db 0FFh
.xdata$x:0000E7B0                                         ; DATA XREF: .xdata$x:0000E7C0o
.xdata$x:0000E7B1                 db 0FFh
.xdata$x:0000E7B2                 db 0FFh
.xdata$x:0000E7B3                 db 0FFh
.xdata$x:0000E7B4                 dd offset __unwindfunclet$??0?$_Iterator012@Urandom_access_iterator_tag@std@@_WHPB_WAB_WU_Iterator_base12@2@@std@@QAE@XZ$0
.xdata$x:0000E7B8 __ehfuncinfo$??0?$_Iterator012@Urandom_access_iterator_tag@std@@_WHPB_WAB_WU_Iterator_base12@2@@std@@QAE@XZ db  22h ; "
.xdata$x:0000E7B8                                         ; DATA XREF: __ehhandler$??0?$_Iterator012@Urandom_access_iterator_tag@std@@_WHPB_WAB_WU_Iterator_base12@2@@std@@QAE@XZ+11o
.xdata$x:0000E7B9                 db    5
.xdata$x:0000E7BA                 db  93h ; ô
.xdata$x:0000E7BB                 db  19h
.xdata$x:0000E7BC                 db    1
.xdata$x:0000E7BD                 db    0
.xdata$x:0000E7BE                 db    0
.xdata$x:0000E7BF                 db    0
.xdata$x:0000E7C0                 dd offset __unwindtable$??0?$_Iterator012@Urandom_access_iterator_tag@std@@_WHPB_WAB_WU_Iterator_base12@2@@std@@QAE@XZ
.xdata$x:0000E7C4                 db    0
.xdata$x:0000E7C5                 db    0
.xdata$x:0000E7C6                 db    0
.xdata$x:0000E7C7                 db    0
.xdata$x:0000E7C8                 db    0
.xdata$x:0000E7C9                 db    0
.xdata$x:0000E7CA                 db    0
.xdata$x:0000E7CB                 db    0
.xdata$x:0000E7CC                 db    0
.xdata$x:0000E7CD                 db    0
.xdata$x:0000E7CE                 db    0
.xdata$x:0000E7CF                 db    0
.xdata$x:0000E7D0                 db    0
.xdata$x:0000E7D1                 db    0
.xdata$x:0000E7D2                 db    0
.xdata$x:0000E7D3                 db    0
.xdata$x:0000E7D4                 db    0
.xdata$x:0000E7D5                 db    0
.xdata$x:0000E7D6                 db    0
.xdata$x:0000E7D7                 db    0
.xdata$x:0000E7D8                 db    0
.xdata$x:0000E7D9                 db    0
.xdata$x:0000E7DA                 db    0
.xdata$x:0000E7DB                 db    0
.xdata$x:0000E7DB _xdata$x        ends
.xdata$x:0000E7DB
.xdata$x:0000E7DC ; ===========================================================================
.xdata$x:0000E7DC
.xdata$x:0000E7DC ; Segment type: Pure data
.xdata$x:0000E7DC ; Segment permissions: Read
.xdata$x:0000E7DC _xdata$x        segment dword public 'DATA' use32
.xdata$x:0000E7DC                 assume cs:_xdata$x
.xdata$x:0000E7DC                 ;org 0E7DCh
.xdata$x:0000E7DC ; COMDAT (pick associative to section at 6D8C)
.xdata$x:0000E7DC __unwindtable$??1?$_Iterator012@Urandom_access_iterator_tag@std@@_WHPB_WAB_WU_Iterator_base12@2@@std@@QAE@XZ db 0FFh
.xdata$x:0000E7DC                                         ; DATA XREF: .xdata$x:0000E7ECo
.xdata$x:0000E7DD                 db 0FFh
.xdata$x:0000E7DE                 db 0FFh
.xdata$x:0000E7DF                 db 0FFh
.xdata$x:0000E7E0                 dd offset __unwindfunclet$??1?$_Iterator012@Urandom_access_iterator_tag@std@@_WHPB_WAB_WU_Iterator_base12@2@@std@@QAE@XZ$0
.xdata$x:0000E7E4 __ehfuncinfo$??1?$_Iterator012@Urandom_access_iterator_tag@std@@_WHPB_WAB_WU_Iterator_base12@2@@std@@QAE@XZ db  22h ; "
.xdata$x:0000E7E4                                         ; DATA XREF: __ehhandler$??1?$_Iterator012@Urandom_access_iterator_tag@std@@_WHPB_WAB_WU_Iterator_base12@2@@std@@QAE@XZ+11o
.xdata$x:0000E7E5                 db    5
.xdata$x:0000E7E6                 db  93h ; ô
.xdata$x:0000E7E7                 db  19h
.xdata$x:0000E7E8                 db    1
.xdata$x:0000E7E9                 db    0
.xdata$x:0000E7EA                 db    0
.xdata$x:0000E7EB                 db    0
.xdata$x:0000E7EC                 dd offset __unwindtable$??1?$_Iterator012@Urandom_access_iterator_tag@std@@_WHPB_WAB_WU_Iterator_base12@2@@std@@QAE@XZ
.xdata$x:0000E7F0                 db    0
.xdata$x:0000E7F1                 db    0
.xdata$x:0000E7F2                 db    0
.xdata$x:0000E7F3                 db    0
.xdata$x:0000E7F4                 db    0
.xdata$x:0000E7F5                 db    0
.xdata$x:0000E7F6                 db    0
.xdata$x:0000E7F7                 db    0
.xdata$x:0000E7F8                 db    0
.xdata$x:0000E7F9                 db    0
.xdata$x:0000E7FA                 db    0
.xdata$x:0000E7FB                 db    0
.xdata$x:0000E7FC                 db    0
.xdata$x:0000E7FD                 db    0
.xdata$x:0000E7FE                 db    0
.xdata$x:0000E7FF                 db    0
.xdata$x:0000E800                 db    0
.xdata$x:0000E801                 db    0
.xdata$x:0000E802                 db    0
.xdata$x:0000E803                 db    0
.xdata$x:0000E804                 db    0
.xdata$x:0000E805                 db    0
.xdata$x:0000E806                 db    0
.xdata$x:0000E807                 db    0
.xdata$x:0000E807 _xdata$x        ends
.xdata$x:0000E807
.xdata$x:0000E808 ; ===========================================================================
.xdata$x:0000E808
.xdata$x:0000E808 ; Segment type: Pure data
.xdata$x:0000E808 ; Segment permissions: Read
.xdata$x:0000E808 _xdata$x        segment dword public 'DATA' use32
.xdata$x:0000E808                 assume cs:_xdata$x
.xdata$x:0000E808                 ;org 0E808h
.xdata$x:0000E808 ; COMDAT (pick associative to section at 53B4)
.xdata$x:0000E808 __unwindtable$??0?$_Iterator012@Urandom_access_iterator_tag@std@@_WHPB_WAB_WU_Iterator_base12@2@@std@@QAE@ABU01@@Z db 0FFh
.xdata$x:0000E808                                         ; DATA XREF: .xdata$x:0000E818o
.xdata$x:0000E809                 db 0FFh
.xdata$x:0000E80A                 db 0FFh
.xdata$x:0000E80B                 db 0FFh
.xdata$x:0000E80C                 dd offset __unwindfunclet$??0?$_Iterator012@Urandom_access_iterator_tag@std@@_WHPB_WAB_WU_Iterator_base12@2@@std@@QAE@ABU01@@Z$0
.xdata$x:0000E810 __ehfuncinfo$??0?$_Iterator012@Urandom_access_iterator_tag@std@@_WHPB_WAB_WU_Iterator_base12@2@@std@@QAE@ABU01@@Z db  22h ; "
.xdata$x:0000E810                                         ; DATA XREF: __ehhandler$??0?$_Iterator012@Urandom_access_iterator_tag@std@@_WHPB_WAB_WU_Iterator_base12@2@@std@@QAE@ABU01@@Z+11o
.xdata$x:0000E811                 db    5
.xdata$x:0000E812                 db  93h ; ô
.xdata$x:0000E813                 db  19h
.xdata$x:0000E814                 db    1
.xdata$x:0000E815                 db    0
.xdata$x:0000E816                 db    0
.xdata$x:0000E817                 db    0
.xdata$x:0000E818                 dd offset __unwindtable$??0?$_Iterator012@Urandom_access_iterator_tag@std@@_WHPB_WAB_WU_Iterator_base12@2@@std@@QAE@ABU01@@Z
.xdata$x:0000E81C                 db    0
.xdata$x:0000E81D                 db    0
.xdata$x:0000E81E                 db    0
.xdata$x:0000E81F                 db    0
.xdata$x:0000E820                 db    0
.xdata$x:0000E821                 db    0
.xdata$x:0000E822                 db    0
.xdata$x:0000E823                 db    0
.xdata$x:0000E824                 db    0
.xdata$x:0000E825                 db    0
.xdata$x:0000E826                 db    0
.xdata$x:0000E827                 db    0
.xdata$x:0000E828                 db    0
.xdata$x:0000E829                 db    0
.xdata$x:0000E82A                 db    0
.xdata$x:0000E82B                 db    0
.xdata$x:0000E82C                 db    0
.xdata$x:0000E82D                 db    0
.xdata$x:0000E82E                 db    0
.xdata$x:0000E82F                 db    0
.xdata$x:0000E830                 db    0
.xdata$x:0000E831                 db    0
.xdata$x:0000E832                 db    0
.xdata$x:0000E833                 db    0
.xdata$x:0000E833 _xdata$x        ends
.xdata$x:0000E833
.xdata$x:0000E834 ; ===========================================================================
.xdata$x:0000E834
.xdata$x:0000E834 ; Segment type: Pure data
.xdata$x:0000E834 ; Segment permissions: Read
.xdata$x:0000E834 _xdata$x        segment dword public 'DATA' use32
.xdata$x:0000E834                 assume cs:_xdata$x
.xdata$x:0000E834                 ;org 0E834h
.xdata$x:0000E834 ; COMDAT (pick associative to section at 5BA8)
.xdata$x:0000E834 __unwindtable$??0?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@_W@std@@@std@@@std@@QAE@PA_WPBU_Container_base12@1@@Z db 0FFh
.xdata$x:0000E834                                         ; DATA XREF: .xdata$x:0000E844o
.xdata$x:0000E835                 db 0FFh
.xdata$x:0000E836                 db 0FFh
.xdata$x:0000E837                 db 0FFh
.xdata$x:0000E838                 dd offset __unwindfunclet$??0?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@_W@std@@@std@@@std@@QAE@PA_WPBU_Container_base12@1@@Z$0
.xdata$x:0000E83C __ehfuncinfo$??0?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@_W@std@@@std@@@std@@QAE@PA_WPBU_Container_base12@1@@Z db  22h ; "
.xdata$x:0000E83C                                         ; DATA XREF: __ehhandler$??0?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@_W@std@@@std@@@std@@QAE@PA_WPBU_Container_base12@1@@Z+11o
.xdata$x:0000E83D                 db    5
.xdata$x:0000E83E                 db  93h ; ô
.xdata$x:0000E83F                 db  19h
.xdata$x:0000E840                 db    1
.xdata$x:0000E841                 db    0
.xdata$x:0000E842                 db    0
.xdata$x:0000E843                 db    0
.xdata$x:0000E844                 dd offset __unwindtable$??0?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@_W@std@@@std@@@std@@QAE@PA_WPBU_Container_base12@1@@Z
.xdata$x:0000E848                 align 20h
.xdata$x:0000E848 _xdata$x        ends
.xdata$x:0000E848
.xdata$x:0000E860 ; ===========================================================================
.xdata$x:0000E860
.xdata$x:0000E860 ; Segment type: Pure data
.xdata$x:0000E860 ; Segment permissions: Read
.xdata$x:0000E860 _xdata$x        segment dword public 'DATA' use32
.xdata$x:0000E860                 assume cs:_xdata$x
.xdata$x:0000E860                 ;org 0E860h
.xdata$x:0000E860 ; COMDAT (pick associative to section at 7284)
.xdata$x:0000E860 __unwindtable$??1?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@_W@std@@@std@@@std@@QAE@XZ db 0FFh
.xdata$x:0000E860                                         ; DATA XREF: .xdata$x:0000E870o
.xdata$x:0000E861                 db 0FFh
.xdata$x:0000E862                 db 0FFh
.xdata$x:0000E863                 db 0FFh
.xdata$x:0000E864                 dd offset __unwindfunclet$??1?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@_W@std@@@std@@@std@@QAE@XZ$0
.xdata$x:0000E868 __ehfuncinfo$??1?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@_W@std@@@std@@@std@@QAE@XZ db  22h ; "
.xdata$x:0000E868                                         ; DATA XREF: __ehhandler$??1?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@_W@std@@@std@@@std@@QAE@XZ+11o
.xdata$x:0000E869                 db    5
.xdata$x:0000E86A                 db  93h ; ô
.xdata$x:0000E86B                 db  19h
.xdata$x:0000E86C                 db    1
.xdata$x:0000E86D                 db    0
.xdata$x:0000E86E                 db    0
.xdata$x:0000E86F                 db    0
.xdata$x:0000E870                 dd offset __unwindtable$??1?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@_W@std@@@std@@@std@@QAE@XZ
.xdata$x:0000E874                 db    0
.xdata$x:0000E875                 db    0
.xdata$x:0000E876                 db    0
.xdata$x:0000E877                 db    0
.xdata$x:0000E878                 db    0
.xdata$x:0000E879                 db    0
.xdata$x:0000E87A                 db    0
.xdata$x:0000E87B                 db    0
.xdata$x:0000E87C                 db    0
.xdata$x:0000E87D                 db    0
.xdata$x:0000E87E                 db    0
.xdata$x:0000E87F                 db    0
.xdata$x:0000E880                 db    0
.xdata$x:0000E881                 db    0
.xdata$x:0000E882                 db    0
.xdata$x:0000E883                 db    0
.xdata$x:0000E884                 db    0
.xdata$x:0000E885                 db    0
.xdata$x:0000E886                 db    0
.xdata$x:0000E887                 db    0
.xdata$x:0000E888                 db    0
.xdata$x:0000E889                 db    0
.xdata$x:0000E88A                 db    0
.xdata$x:0000E88B                 db    0
.xdata$x:0000E88B _xdata$x        ends
.xdata$x:0000E88B
.xdata$x:0000E88C ; ===========================================================================
.xdata$x:0000E88C
.xdata$x:0000E88C ; Segment type: Pure data
.xdata$x:0000E88C ; Segment permissions: Read
.xdata$x:0000E88C _xdata$x        segment dword public 'DATA' use32
.xdata$x:0000E88C                 assume cs:_xdata$x
.xdata$x:0000E88C                 ;org 0E88Ch
.xdata$x:0000E88C ; COMDAT (pick associative to section at 5B24)
.xdata$x:0000E88C __unwindtable$??0?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@_W@std@@@std@@@std@@QAE@ABV01@@Z db 0FFh
.xdata$x:0000E88C                                         ; DATA XREF: .xdata$x:0000E89Co
.xdata$x:0000E88D                 db 0FFh
.xdata$x:0000E88E                 db 0FFh
.xdata$x:0000E88F                 db 0FFh
.xdata$x:0000E890                 dd offset __unwindfunclet$??0?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@_W@std@@@std@@@std@@QAE@ABV01@@Z$0
.xdata$x:0000E894 __ehfuncinfo$??0?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@_W@std@@@std@@@std@@QAE@ABV01@@Z db  22h ; "
.xdata$x:0000E894                                         ; DATA XREF: __ehhandler$??0?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@_W@std@@@std@@@std@@QAE@ABV01@@Z+11o
.xdata$x:0000E895                 db    5
.xdata$x:0000E896                 db  93h ; ô
.xdata$x:0000E897                 db  19h
.xdata$x:0000E898                 db    1
.xdata$x:0000E899                 db    0
.xdata$x:0000E89A                 db    0
.xdata$x:0000E89B                 db    0
.xdata$x:0000E89C                 dd offset __unwindtable$??0?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@_W@std@@@std@@@std@@QAE@ABV01@@Z
.xdata$x:0000E8A0                 db    0
.xdata$x:0000E8A1                 db    0
.xdata$x:0000E8A2                 db    0
.xdata$x:0000E8A3                 db    0
.xdata$x:0000E8A4                 db    0
.xdata$x:0000E8A5                 db    0
.xdata$x:0000E8A6                 db    0
.xdata$x:0000E8A7                 db    0
.xdata$x:0000E8A8                 db    0
.xdata$x:0000E8A9                 db    0
.xdata$x:0000E8AA                 db    0
.xdata$x:0000E8AB                 db    0
.xdata$x:0000E8AC                 db    0
.xdata$x:0000E8AD                 db    0
.xdata$x:0000E8AE                 db    0
.xdata$x:0000E8AF                 db    0
.xdata$x:0000E8B0                 db    0
.xdata$x:0000E8B1                 db    0
.xdata$x:0000E8B2                 db    0
.xdata$x:0000E8B3                 db    0
.xdata$x:0000E8B4                 db    0
.xdata$x:0000E8B5                 db    0
.xdata$x:0000E8B6                 db    0
.xdata$x:0000E8B7                 db    0
.xdata$x:0000E8B7 _xdata$x        ends
.xdata$x:0000E8B7
.xdata$x:0000E8B8 ; ===========================================================================
.xdata$x:0000E8B8
.xdata$x:0000E8B8 ; Segment type: Pure data
.xdata$x:0000E8B8 ; Segment permissions: Read
.xdata$x:0000E8B8 _xdata$x        segment dword public 'DATA' use32
.xdata$x:0000E8B8                 assume cs:_xdata$x
.xdata$x:0000E8B8                 ;org 0E8B8h
.xdata$x:0000E8B8 ; COMDAT (pick associative to section at 5CAC)
.xdata$x:0000E8B8 __unwindtable$??0?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@_W@std@@@std@@@std@@QAE@PA_WPBU_Container_base12@1@@Z db 0FFh
.xdata$x:0000E8B8                                         ; DATA XREF: .xdata$x:0000E8C8o
.xdata$x:0000E8B9                 db 0FFh
.xdata$x:0000E8BA                 db 0FFh
.xdata$x:0000E8BB                 db 0FFh
.xdata$x:0000E8BC                 dd offset __unwindfunclet$??0?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@_W@std@@@std@@@std@@QAE@PA_WPBU_Container_base12@1@@Z$0
.xdata$x:0000E8C0 __ehfuncinfo$??0?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@_W@std@@@std@@@std@@QAE@PA_WPBU_Container_base12@1@@Z db  22h ; "
.xdata$x:0000E8C0                                         ; DATA XREF: __ehhandler$??0?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@_W@std@@@std@@@std@@QAE@PA_WPBU_Container_base12@1@@Z+11o
.xdata$x:0000E8C1                 db    5
.xdata$x:0000E8C2                 db  93h ; ô
.xdata$x:0000E8C3                 db  19h
.xdata$x:0000E8C4                 db    1
.xdata$x:0000E8C5                 db    0
.xdata$x:0000E8C6                 db    0
.xdata$x:0000E8C7                 db    0
.xdata$x:0000E8C8                 dd offset __unwindtable$??0?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@_W@std@@@std@@@std@@QAE@PA_WPBU_Container_base12@1@@Z
.xdata$x:0000E8CC                 db    0
.xdata$x:0000E8CD                 db    0
.xdata$x:0000E8CE                 db    0
.xdata$x:0000E8CF                 db    0
.xdata$x:0000E8D0                 db    0
.xdata$x:0000E8D1                 db    0
.xdata$x:0000E8D2                 db    0
.xdata$x:0000E8D3                 db    0
.xdata$x:0000E8D4                 db    0
.xdata$x:0000E8D5                 db    0
.xdata$x:0000E8D6                 db    0
.xdata$x:0000E8D7                 db    0
.xdata$x:0000E8D8                 db    0
.xdata$x:0000E8D9                 db    0
.xdata$x:0000E8DA                 db    0
.xdata$x:0000E8DB                 db    0
.xdata$x:0000E8DC                 db    0
.xdata$x:0000E8DD                 db    0
.xdata$x:0000E8DE                 db    0
.xdata$x:0000E8DF                 db    0
.xdata$x:0000E8E0                 db    0
.xdata$x:0000E8E1                 db    0
.xdata$x:0000E8E2                 db    0
.xdata$x:0000E8E3                 db    0
.xdata$x:0000E8E3 _xdata$x        ends
.xdata$x:0000E8E3
.xdata$x:0000E8E4 ; ===========================================================================
.xdata$x:0000E8E4
.xdata$x:0000E8E4 ; Segment type: Pure data
.xdata$x:0000E8E4 ; Segment permissions: Read
.xdata$x:0000E8E4 _xdata$x        segment dword public 'DATA' use32
.xdata$x:0000E8E4                 assume cs:_xdata$x
.xdata$x:0000E8E4                 ;org 0E8E4h
.xdata$x:0000E8E4 ; COMDAT (pick associative to section at 8680)
.xdata$x:0000E8E4 __unwindtable$??H?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@_W@std@@@std@@@std@@QBE?AV01@H@Z db 0FFh
.xdata$x:0000E8E4                                         ; DATA XREF: .xdata$x:0000E8FCo
.xdata$x:0000E8E5                 db 0FFh
.xdata$x:0000E8E6                 db 0FFh
.xdata$x:0000E8E7                 db 0FFh
.xdata$x:0000E8E8                 dd offset __unwindfunclet$??H?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@_W@std@@@std@@@std@@QBE?AV01@H@Z$1
.xdata$x:0000E8EC                 db    0
.xdata$x:0000E8ED                 db    0
.xdata$x:0000E8EE                 db    0
.xdata$x:0000E8EF                 db    0
.xdata$x:0000E8F0                 dd offset __unwindfunclet$??H?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@_W@std@@@std@@@std@@QBE?AV01@H@Z$0
.xdata$x:0000E8F4 __ehfuncinfo$??H?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@_W@std@@@std@@@std@@QBE?AV01@H@Z db  22h ; "
.xdata$x:0000E8F4                                         ; DATA XREF: __ehhandler$??H?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@_W@std@@@std@@@std@@QBE?AV01@H@Z+11o
.xdata$x:0000E8F5                 db    5
.xdata$x:0000E8F6                 db  93h ; ô
.xdata$x:0000E8F7                 db  19h
.xdata$x:0000E8F8                 db    2
.xdata$x:0000E8F9                 db    0
.xdata$x:0000E8FA                 db    0
.xdata$x:0000E8FB                 db    0
.xdata$x:0000E8FC                 dd offset __unwindtable$??H?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@_W@std@@@std@@@std@@QBE?AV01@H@Z
.xdata$x:0000E900                 db    0
.xdata$x:0000E901                 db    0
.xdata$x:0000E902                 db    0
.xdata$x:0000E903                 db    0
.xdata$x:0000E904                 db    0
.xdata$x:0000E905                 db    0
.xdata$x:0000E906                 db    0
.xdata$x:0000E907                 db    0
.xdata$x:0000E908                 db    0
.xdata$x:0000E909                 db    0
.xdata$x:0000E90A                 db    0
.xdata$x:0000E90B                 db    0
.xdata$x:0000E90C                 db    0
.xdata$x:0000E90D                 db    0
.xdata$x:0000E90E                 db    0
.xdata$x:0000E90F                 db    0
.xdata$x:0000E910                 db    0
.xdata$x:0000E911                 db    0
.xdata$x:0000E912                 db    0
.xdata$x:0000E913                 db    0
.xdata$x:0000E914                 db    0
.xdata$x:0000E915                 db    0
.xdata$x:0000E916                 db    0
.xdata$x:0000E917                 db    0
.xdata$x:0000E917 _xdata$x        ends
.xdata$x:0000E917
.xdata$x:0000E918 ; ===========================================================================
.xdata$x:0000E918
.xdata$x:0000E918 ; Segment type: Pure data
.xdata$x:0000E918 ; Segment permissions: Read
.xdata$x:0000E918 _xdata$x        segment dword public 'DATA' use32
.xdata$x:0000E918                 assume cs:_xdata$x
.xdata$x:0000E918                 ;org 0E918h
.xdata$x:0000E918 ; COMDAT (pick associative to section at 72F4)
.xdata$x:0000E918 __unwindtable$??1?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@_W@std@@@std@@@std@@QAE@XZ db 0FFh
.xdata$x:0000E918                                         ; DATA XREF: .xdata$x:0000E928o
.xdata$x:0000E919                 db 0FFh
.xdata$x:0000E91A                 db 0FFh
.xdata$x:0000E91B                 db 0FFh
.xdata$x:0000E91C                 dd offset __unwindfunclet$??1?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@_W@std@@@std@@@std@@QAE@XZ$0
.xdata$x:0000E920 __ehfuncinfo$??1?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@_W@std@@@std@@@std@@QAE@XZ db  22h ; "
.xdata$x:0000E920                                         ; DATA XREF: __ehhandler$??1?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@_W@std@@@std@@@std@@QAE@XZ+11o
.xdata$x:0000E921                 db    5
.xdata$x:0000E922                 db  93h ; ô
.xdata$x:0000E923                 db  19h
.xdata$x:0000E924                 db    1
.xdata$x:0000E925                 db    0
.xdata$x:0000E926                 db    0
.xdata$x:0000E927                 db    0
.xdata$x:0000E928                 dd offset __unwindtable$??1?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@_W@std@@@std@@@std@@QAE@XZ
.xdata$x:0000E92C                 db    0
.xdata$x:0000E92D                 db    0
.xdata$x:0000E92E                 db    0
.xdata$x:0000E92F                 db    0
.xdata$x:0000E930                 db    0
.xdata$x:0000E931                 db    0
.xdata$x:0000E932                 db    0
.xdata$x:0000E933                 db    0
.xdata$x:0000E934                 db    0
.xdata$x:0000E935                 db    0
.xdata$x:0000E936                 db    0
.xdata$x:0000E937                 db    0
.xdata$x:0000E938                 db    0
.xdata$x:0000E939                 db    0
.xdata$x:0000E93A                 db    0
.xdata$x:0000E93B                 db    0
.xdata$x:0000E93C                 db    0
.xdata$x:0000E93D                 db    0
.xdata$x:0000E93E                 db    0
.xdata$x:0000E93F                 db    0
.xdata$x:0000E940                 db    0
.xdata$x:0000E941                 db    0
.xdata$x:0000E942                 db    0
.xdata$x:0000E943                 db    0
.xdata$x:0000E943 _xdata$x        ends
.xdata$x:0000E943
.xdata$x:0000E944 ; ===========================================================================
.xdata$x:0000E944
.xdata$x:0000E944 ; Segment type: Pure data
.xdata$x:0000E944 ; Segment permissions: Read
.xdata$x:0000E944 _xdata$x        segment dword public 'DATA' use32
.xdata$x:0000E944                 assume cs:_xdata$x
.xdata$x:0000E944                 ;org 0E944h
.xdata$x:0000E944 ; COMDAT (pick associative to section at 5C34)
.xdata$x:0000E944 __unwindtable$??0?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@_W@std@@@std@@@std@@QAE@ABV01@@Z db 0FFh
.xdata$x:0000E944                                         ; DATA XREF: .xdata$x:0000E954o
.xdata$x:0000E945                 db 0FFh
.xdata$x:0000E946                 db 0FFh
.xdata$x:0000E947                 db 0FFh
.xdata$x:0000E948                 dd offset __unwindfunclet$??0?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@_W@std@@@std@@@std@@QAE@ABV01@@Z$0
.xdata$x:0000E94C __ehfuncinfo$??0?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@_W@std@@@std@@@std@@QAE@ABV01@@Z db  22h ; "
.xdata$x:0000E94C                                         ; DATA XREF: __ehhandler$??0?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@_W@std@@@std@@@std@@QAE@ABV01@@Z+11o
.xdata$x:0000E94D                 db    5
.xdata$x:0000E94E                 db  93h ; ô
.xdata$x:0000E94F                 db  19h
.xdata$x:0000E950                 db    1
.xdata$x:0000E951                 db    0
.xdata$x:0000E952                 db    0
.xdata$x:0000E953                 db    0
.xdata$x:0000E954                 dd offset __unwindtable$??0?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@_W@std@@@std@@@std@@QAE@ABV01@@Z
.xdata$x:0000E958                 db    0
.xdata$x:0000E959                 db    0
.xdata$x:0000E95A                 db    0
.xdata$x:0000E95B                 db    0
.xdata$x:0000E95C                 db    0
.xdata$x:0000E95D                 db    0
.xdata$x:0000E95E                 db    0
.xdata$x:0000E95F                 db    0
.xdata$x:0000E960                 db    0
.xdata$x:0000E961                 db    0
.xdata$x:0000E962                 db    0
.xdata$x:0000E963                 db    0
.xdata$x:0000E964                 db    0
.xdata$x:0000E965                 db    0
.xdata$x:0000E966                 db    0
.xdata$x:0000E967                 db    0
.xdata$x:0000E968                 db    0
.xdata$x:0000E969                 db    0
.xdata$x:0000E96A                 db    0
.xdata$x:0000E96B                 db    0
.xdata$x:0000E96C                 db    0
.xdata$x:0000E96D                 db    0
.xdata$x:0000E96E                 db    0
.xdata$x:0000E96F                 db    0
.xdata$x:0000E96F _xdata$x        ends
.xdata$x:0000E96F
.xdata$x:0000E970 ; ===========================================================================
.xdata$x:0000E970
.xdata$x:0000E970 ; Segment type: Pure data
.xdata$x:0000E970 ; Segment permissions: Read
.xdata$x:0000E970 _xdata$x        segment dword public 'DATA' use32
.xdata$x:0000E970                 assume cs:_xdata$x
.xdata$x:0000E970                 ;org 0E970h
.xdata$x:0000E970 ; COMDAT (pick associative to section at 5518)
.xdata$x:0000E970 __unwindtable$??0?$_Revranit@V?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@_W@std@@@std@@@std@@U?$iterator@Urandom_access_iterator_tag@std@@_WHPA_WAA_W@2@@std@@QAE@V?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@_W@std@@@std@@@1@@Z db 0FFh
.xdata$x:0000E970                                         ; DATA XREF: .xdata$x:0000E988o
.xdata$x:0000E971                 db 0FFh
.xdata$x:0000E972                 db 0FFh
.xdata$x:0000E973                 db 0FFh
.xdata$x:0000E974                 dd offset __unwindfunclet$??0?$_Revranit@V?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@_W@std@@@std@@@std@@U?$iterator@Urandom_access_iterator_tag@std@@_WHPA_WAA_W@2@@std@@QAE@V?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@_W@std@@@std@@@1@@Z$0
.xdata$x:0000E978                 db    0
.xdata$x:0000E979                 db    0
.xdata$x:0000E97A                 db    0
.xdata$x:0000E97B                 db    0
.xdata$x:0000E97C                 dd offset __unwindfunclet$??0?$_Revranit@V?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@_W@std@@@std@@@std@@U?$iterator@Urandom_access_iterator_tag@std@@_WHPA_WAA_W@2@@std@@QAE@V?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@_W@std@@@std@@@1@@Z$1
.xdata$x:0000E980 __ehfuncinfo$??0?$_Revranit@V?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@_W@std@@@std@@@std@@U?$iterator@Urandom_access_iterator_tag@std@@_WHPA_WAA_W@2@@std@@QAE@V?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@_W@std@@@std@@@1@@Z db  22h ; "
.xdata$x:0000E980                                         ; DATA XREF: __ehhandler$??0?$_Revranit@V?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@_W@std@@@std@@@std@@U?$iterator@Urandom_access_iterator_tag@std@@_WHPA_WAA_W@2@@std@@QAE@V?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@_W@std@@@std@@@1@@Z+11o
.xdata$x:0000E981                 db    5
.xdata$x:0000E982                 db  93h ; ô
.xdata$x:0000E983                 db  19h
.xdata$x:0000E984                 db    2
.xdata$x:0000E985                 db    0
.xdata$x:0000E986                 db    0
.xdata$x:0000E987                 db    0
.xdata$x:0000E988                 dd offset __unwindtable$??0?$_Revranit@V?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@_W@std@@@std@@@std@@U?$iterator@Urandom_access_iterator_tag@std@@_WHPA_WAA_W@2@@std@@QAE@V?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@_W@std@@@std@@@1@@Z
.xdata$x:0000E98C                 db    0
.xdata$x:0000E98D                 db    0
.xdata$x:0000E98E                 db    0
.xdata$x:0000E98F                 db    0
.xdata$x:0000E990                 db    0
.xdata$x:0000E991                 db    0
.xdata$x:0000E992                 db    0
.xdata$x:0000E993                 db    0
.xdata$x:0000E994                 db    0
.xdata$x:0000E995                 db    0
.xdata$x:0000E996                 db    0
.xdata$x:0000E997                 db    0
.xdata$x:0000E998                 db    0
.xdata$x:0000E999                 db    0
.xdata$x:0000E99A                 db    0
.xdata$x:0000E99B                 db    0
.xdata$x:0000E99C                 db    0
.xdata$x:0000E99D                 db    0
.xdata$x:0000E99E                 db    0
.xdata$x:0000E99F                 db    0
.xdata$x:0000E9A0                 db    0
.xdata$x:0000E9A1                 db    0
.xdata$x:0000E9A2                 db    0
.xdata$x:0000E9A3                 db    0
.xdata$x:0000E9A3 _xdata$x        ends
.xdata$x:0000E9A3
.xdata$x:0000E9A4 ; ===========================================================================
.xdata$x:0000E9A4
.xdata$x:0000E9A4 ; Segment type: Pure data
.xdata$x:0000E9A4 ; Segment permissions: Read
.xdata$x:0000E9A4 _xdata$x        segment dword public 'DATA' use32
.xdata$x:0000E9A4                 assume cs:_xdata$x
.xdata$x:0000E9A4                 ;org 0E9A4h
.xdata$x:0000E9A4 ; COMDAT (pick associative to section at B29C)
.xdata$x:0000E9A4 __unwindtable$?base@?$_Revranit@V?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@_W@std@@@std@@@std@@U?$iterator@Urandom_access_iterator_tag@std@@_WHPA_WAA_W@2@@std@@QBE?AV?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@_W@std@@@std@@@2@XZ db 0FFh
.xdata$x:0000E9A4                                         ; DATA XREF: .xdata$x:0000E9B4o
.xdata$x:0000E9A5                 db 0FFh
.xdata$x:0000E9A6                 db 0FFh
.xdata$x:0000E9A7                 db 0FFh
.xdata$x:0000E9A8                 dd offset __unwindfunclet$?base@?$_Revranit@V?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@_W@std@@@std@@@std@@U?$iterator@Urandom_access_iterator_tag@std@@_WHPA_WAA_W@2@@std@@QBE?AV?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@_W@std@@@std@@@2@XZ$0
.xdata$x:0000E9AC __ehfuncinfo$?base@?$_Revranit@V?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@_W@std@@@std@@@std@@U?$iterator@Urandom_access_iterator_tag@std@@_WHPA_WAA_W@2@@std@@QBE?AV?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@_W@std@@@std@@@2@XZ db  22h ; "
.xdata$x:0000E9AC                                         ; DATA XREF: __ehhandler$?base@?$_Revranit@V?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@_W@std@@@std@@@std@@U?$iterator@Urandom_access_iterator_tag@std@@_WHPA_WAA_W@2@@std@@QBE?AV?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@_W@std@@@std@@@2@XZ+11o
.xdata$x:0000E9AD                 db    5
.xdata$x:0000E9AE                 db  93h ; ô
.xdata$x:0000E9AF                 db  19h
.xdata$x:0000E9B0                 db    1
.xdata$x:0000E9B1                 db    0
.xdata$x:0000E9B2                 db    0
.xdata$x:0000E9B3                 db    0
.xdata$x:0000E9B4                 dd offset __unwindtable$?base@?$_Revranit@V?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@_W@std@@@std@@@std@@U?$iterator@Urandom_access_iterator_tag@std@@_WHPA_WAA_W@2@@std@@QBE?AV?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@_W@std@@@std@@@2@XZ
.xdata$x:0000E9B8                 db    0
.xdata$x:0000E9B9                 db    0
.xdata$x:0000E9BA                 db    0
.xdata$x:0000E9BB                 db    0
.xdata$x:0000E9BC                 db    0
.xdata$x:0000E9BD                 db    0
.xdata$x:0000E9BE                 db    0
.xdata$x:0000E9BF                 db    0
.xdata$x:0000E9C0                 db    0
.xdata$x:0000E9C1                 db    0
.xdata$x:0000E9C2                 db    0
.xdata$x:0000E9C3                 db    0
.xdata$x:0000E9C4                 db    0
.xdata$x:0000E9C5                 db    0
.xdata$x:0000E9C6                 db    0
.xdata$x:0000E9C7                 db    0
.xdata$x:0000E9C8                 db    0
.xdata$x:0000E9C9                 db    0
.xdata$x:0000E9CA                 db    0
.xdata$x:0000E9CB                 db    0
.xdata$x:0000E9CC                 db    0
.xdata$x:0000E9CD                 db    0
.xdata$x:0000E9CE                 db    0
.xdata$x:0000E9CF                 db    0
.xdata$x:0000E9CF _xdata$x        ends
.xdata$x:0000E9CF
.xdata$x:0000E9D0 ; ===========================================================================
.xdata$x:0000E9D0
.xdata$x:0000E9D0 ; Segment type: Pure data
.xdata$x:0000E9D0 ; Segment permissions: Read
.xdata$x:0000E9D0 _xdata$x        segment dword public 'DATA' use32
.xdata$x:0000E9D0                 assume cs:_xdata$x
.xdata$x:0000E9D0                 ;org 0E9D0h
.xdata$x:0000E9D0 ; COMDAT (pick associative to section at 7F54)
.xdata$x:0000E9D0 __unwindtable$??D?$_Revranit@V?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@_W@std@@@std@@@std@@U?$iterator@Urandom_access_iterator_tag@std@@_WHPA_WAA_W@2@@std@@QBEAA_WXZ db 0FFh
.xdata$x:0000E9D0                                         ; DATA XREF: .xdata$x:0000E9E0o
.xdata$x:0000E9D1                 db 0FFh
.xdata$x:0000E9D2                 db 0FFh
.xdata$x:0000E9D3                 db 0FFh
.xdata$x:0000E9D4                 dd offset __unwindfunclet$??D?$_Revranit@V?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@_W@std@@@std@@@std@@U?$iterator@Urandom_access_iterator_tag@std@@_WHPA_WAA_W@2@@std@@QBEAA_WXZ$0
.xdata$x:0000E9D8 __ehfuncinfo$??D?$_Revranit@V?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@_W@std@@@std@@@std@@U?$iterator@Urandom_access_iterator_tag@std@@_WHPA_WAA_W@2@@std@@QBEAA_WXZ db  22h ; "
.xdata$x:0000E9D8                                         ; DATA XREF: __ehhandler$??D?$_Revranit@V?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@_W@std@@@std@@@std@@U?$iterator@Urandom_access_iterator_tag@std@@_WHPA_WAA_W@2@@std@@QBEAA_WXZ+11o
.xdata$x:0000E9D9                 db    5
.xdata$x:0000E9DA                 db  93h ; ô
.xdata$x:0000E9DB                 db  19h
.xdata$x:0000E9DC                 db    1
.xdata$x:0000E9DD                 db    0
.xdata$x:0000E9DE                 db    0
.xdata$x:0000E9DF                 db    0
.xdata$x:0000E9E0                 dd offset __unwindtable$??D?$_Revranit@V?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@_W@std@@@std@@@std@@U?$iterator@Urandom_access_iterator_tag@std@@_WHPA_WAA_W@2@@std@@QBEAA_WXZ
.xdata$x:0000E9E4                 db    0
.xdata$x:0000E9E5                 db    0
.xdata$x:0000E9E6                 db    0
.xdata$x:0000E9E7                 db    0
.xdata$x:0000E9E8                 db    0
.xdata$x:0000E9E9                 db    0
.xdata$x:0000E9EA                 db    0
.xdata$x:0000E9EB                 db    0
.xdata$x:0000E9EC                 db    0
.xdata$x:0000E9ED                 db    0
.xdata$x:0000E9EE                 db    0
.xdata$x:0000E9EF                 db    0
.xdata$x:0000E9F0                 db    0
.xdata$x:0000E9F1                 db    0
.xdata$x:0000E9F2                 db    0
.xdata$x:0000E9F3                 db    0
.xdata$x:0000E9F4                 db    0
.xdata$x:0000E9F5                 db    0
.xdata$x:0000E9F6                 db    0
.xdata$x:0000E9F7                 db    0
.xdata$x:0000E9F8                 db    0
.xdata$x:0000E9F9                 db    0
.xdata$x:0000E9FA                 db    0
.xdata$x:0000E9FB                 db    0
.xdata$x:0000E9FB _xdata$x        ends
.xdata$x:0000E9FB
.xdata$x:0000E9FC ; ===========================================================================
.xdata$x:0000E9FC
.xdata$x:0000E9FC ; Segment type: Pure data
.xdata$x:0000E9FC ; Segment permissions: Read
.xdata$x:0000E9FC _xdata$x        segment dword public 'DATA' use32
.xdata$x:0000E9FC                 assume cs:_xdata$x
.xdata$x:0000E9FC                 ;org 0E9FCh
.xdata$x:0000E9FC ; COMDAT (pick associative to section at 6DFC)
.xdata$x:0000E9FC __unwindtable$??1?$_Revranit@V?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@_W@std@@@std@@@std@@U?$iterator@Urandom_access_iterator_tag@std@@_WHPA_WAA_W@2@@std@@QAE@XZ db 0FFh
.xdata$x:0000E9FC                                         ; DATA XREF: .xdata$x:0000EA0Co
.xdata$x:0000E9FD                 db 0FFh
.xdata$x:0000E9FE                 db 0FFh
.xdata$x:0000E9FF                 db 0FFh
.xdata$x:0000EA00                 dd offset __unwindfunclet$??1?$_Revranit@V?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@_W@std@@@std@@@std@@U?$iterator@Urandom_access_iterator_tag@std@@_WHPA_WAA_W@2@@std@@QAE@XZ$0
.xdata$x:0000EA04 __ehfuncinfo$??1?$_Revranit@V?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@_W@std@@@std@@@std@@U?$iterator@Urandom_access_iterator_tag@std@@_WHPA_WAA_W@2@@std@@QAE@XZ db  22h ; "
.xdata$x:0000EA04                                         ; DATA XREF: __ehhandler$??1?$_Revranit@V?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@_W@std@@@std@@@std@@U?$iterator@Urandom_access_iterator_tag@std@@_WHPA_WAA_W@2@@std@@QAE@XZ+11o
.xdata$x:0000EA05                 db    5
.xdata$x:0000EA06                 db  93h ; ô
.xdata$x:0000EA07                 db  19h
.xdata$x:0000EA08                 db    1
.xdata$x:0000EA09                 db    0
.xdata$x:0000EA0A                 db    0
.xdata$x:0000EA0B                 db    0
.xdata$x:0000EA0C                 dd offset __unwindtable$??1?$_Revranit@V?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@_W@std@@@std@@@std@@U?$iterator@Urandom_access_iterator_tag@std@@_WHPA_WAA_W@2@@std@@QAE@XZ
.xdata$x:0000EA10                 db    0
.xdata$x:0000EA11                 db    0
.xdata$x:0000EA12                 db    0
.xdata$x:0000EA13                 db    0
.xdata$x:0000EA14                 db    0
.xdata$x:0000EA15                 db    0
.xdata$x:0000EA16                 db    0
.xdata$x:0000EA17                 db    0
.xdata$x:0000EA18                 db    0
.xdata$x:0000EA19                 db    0
.xdata$x:0000EA1A                 db    0
.xdata$x:0000EA1B                 db    0
.xdata$x:0000EA1C                 db    0
.xdata$x:0000EA1D                 db    0
.xdata$x:0000EA1E                 db    0
.xdata$x:0000EA1F                 db    0
.xdata$x:0000EA20                 db    0
.xdata$x:0000EA21                 db    0
.xdata$x:0000EA22                 db    0
.xdata$x:0000EA23                 db    0
.xdata$x:0000EA24                 db    0
.xdata$x:0000EA25                 db    0
.xdata$x:0000EA26                 db    0
.xdata$x:0000EA27                 db    0
.xdata$x:0000EA27 _xdata$x        ends
.xdata$x:0000EA27
.xdata$x:0000EA28 ; ===========================================================================
.xdata$x:0000EA28
.xdata$x:0000EA28 ; Segment type: Pure data
.xdata$x:0000EA28 ; Segment permissions: Read
.xdata$x:0000EA28 _xdata$x        segment dword public 'DATA' use32
.xdata$x:0000EA28                 assume cs:_xdata$x
.xdata$x:0000EA28                 ;org 0EA28h
.xdata$x:0000EA28 ; COMDAT (pick associative to section at 54A0)
.xdata$x:0000EA28 __unwindtable$??0?$_Revranit@V?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@_W@std@@@std@@@std@@U?$iterator@Urandom_access_iterator_tag@std@@_WHPA_WAA_W@2@@std@@QAE@ABV01@@Z db 0FFh
.xdata$x:0000EA28                                         ; DATA XREF: .xdata$x:0000EA38o
.xdata$x:0000EA29                 db 0FFh
.xdata$x:0000EA2A                 db 0FFh
.xdata$x:0000EA2B                 db 0FFh
.xdata$x:0000EA2C                 dd offset __unwindfunclet$??0?$_Revranit@V?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@_W@std@@@std@@@std@@U?$iterator@Urandom_access_iterator_tag@std@@_WHPA_WAA_W@2@@std@@QAE@ABV01@@Z$0
.xdata$x:0000EA30 __ehfuncinfo$??0?$_Revranit@V?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@_W@std@@@std@@@std@@U?$iterator@Urandom_access_iterator_tag@std@@_WHPA_WAA_W@2@@std@@QAE@ABV01@@Z db  22h ; "
.xdata$x:0000EA30                                         ; DATA XREF: __ehhandler$??0?$_Revranit@V?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@_W@std@@@std@@@std@@U?$iterator@Urandom_access_iterator_tag@std@@_WHPA_WAA_W@2@@std@@QAE@ABV01@@Z+11o
.xdata$x:0000EA31                 db    5
.xdata$x:0000EA32                 db  93h ; ô
.xdata$x:0000EA33                 db  19h
.xdata$x:0000EA34                 db    1
.xdata$x:0000EA35                 db    0
.xdata$x:0000EA36                 db    0
.xdata$x:0000EA37                 db    0
.xdata$x:0000EA38                 dd offset __unwindtable$??0?$_Revranit@V?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@_W@std@@@std@@@std@@U?$iterator@Urandom_access_iterator_tag@std@@_WHPA_WAA_W@2@@std@@QAE@ABV01@@Z
.xdata$x:0000EA3C                 db    0
.xdata$x:0000EA3D                 db    0
.xdata$x:0000EA3E                 db    0
.xdata$x:0000EA3F                 db    0
.xdata$x:0000EA40                 db    0
.xdata$x:0000EA41                 db    0
.xdata$x:0000EA42                 db    0
.xdata$x:0000EA43                 db    0
.xdata$x:0000EA44                 db    0
.xdata$x:0000EA45                 db    0
.xdata$x:0000EA46                 db    0
.xdata$x:0000EA47                 db    0
.xdata$x:0000EA48                 db    0
.xdata$x:0000EA49                 db    0
.xdata$x:0000EA4A                 db    0
.xdata$x:0000EA4B                 db    0
.xdata$x:0000EA4C                 db    0
.xdata$x:0000EA4D                 db    0
.xdata$x:0000EA4E                 db    0
.xdata$x:0000EA4F                 db    0
.xdata$x:0000EA50                 db    0
.xdata$x:0000EA51                 db    0
.xdata$x:0000EA52                 db    0
.xdata$x:0000EA53                 db    0
.xdata$x:0000EA53 _xdata$x        ends
.xdata$x:0000EA53
.xdata$x:0000EA54 ; ===========================================================================
.xdata$x:0000EA54
.xdata$x:0000EA54 ; Segment type: Pure data
.xdata$x:0000EA54 ; Segment permissions: Read
.xdata$x:0000EA54 _xdata$x        segment dword public 'DATA' use32
.xdata$x:0000EA54                 assume cs:_xdata$x
.xdata$x:0000EA54                 ;org 0EA54h
.xdata$x:0000EA54 ; COMDAT (pick associative to section at 6468)
.xdata$x:0000EA54 __unwindtable$??0?$reverse_iterator@V?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@_W@std@@@std@@@std@@@std@@QAE@V?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@_W@std@@@std@@@1@@Z db 0FFh
.xdata$x:0000EA54                                         ; DATA XREF: .xdata$x:0000EA74o
.xdata$x:0000EA55                 db 0FFh
.xdata$x:0000EA56                 db 0FFh
.xdata$x:0000EA57                 db 0FFh
.xdata$x:0000EA58                 dd offset __unwindfunclet$??0?$reverse_iterator@V?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@_W@std@@@std@@@std@@@std@@QAE@V?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@_W@std@@@std@@@1@@Z$0
.xdata$x:0000EA5C                 align 10h
.xdata$x:0000EA60                 dd offset __unwindfunclet$??0?$reverse_iterator@V?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@_W@std@@@std@@@std@@@std@@QAE@V?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@_W@std@@@std@@@1@@Z$1
.xdata$x:0000EA64                 align 8
.xdata$x:0000EA68                 dd offset __unwindfunclet$??0?$reverse_iterator@V?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@_W@std@@@std@@@std@@@std@@QAE@V?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@_W@std@@@std@@@1@@Z$2
.xdata$x:0000EA6C __ehfuncinfo$??0?$reverse_iterator@V?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@_W@std@@@std@@@std@@@std@@QAE@V?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@_W@std@@@std@@@1@@Z db  22h ; "
.xdata$x:0000EA6C                                         ; DATA XREF: __ehhandler$??0?$reverse_iterator@V?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@_W@std@@@std@@@std@@@std@@QAE@V?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@_W@std@@@std@@@1@@Z+11o
.xdata$x:0000EA6D                 db    5
.xdata$x:0000EA6E                 db  93h ; ô
.xdata$x:0000EA6F                 db  19h
.xdata$x:0000EA70                 db    3
.xdata$x:0000EA71                 db    0
.xdata$x:0000EA72                 db    0
.xdata$x:0000EA73                 db    0
.xdata$x:0000EA74                 dd offset __unwindtable$??0?$reverse_iterator@V?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@_W@std@@@std@@@std@@@std@@QAE@V?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@_W@std@@@std@@@1@@Z
.xdata$x:0000EA78                 db    0
.xdata$x:0000EA79                 db    0
.xdata$x:0000EA7A                 db    0
.xdata$x:0000EA7B                 db    0
.xdata$x:0000EA7C                 db    0
.xdata$x:0000EA7D                 db    0
.xdata$x:0000EA7E                 db    0
.xdata$x:0000EA7F                 db    0
.xdata$x:0000EA80                 db    0
.xdata$x:0000EA81                 db    0
.xdata$x:0000EA82                 db    0
.xdata$x:0000EA83                 db    0
.xdata$x:0000EA84                 db    0
.xdata$x:0000EA85                 db    0
.xdata$x:0000EA86                 db    0
.xdata$x:0000EA87                 db    0
.xdata$x:0000EA88                 db    0
.xdata$x:0000EA89                 db    0
.xdata$x:0000EA8A                 db    0
.xdata$x:0000EA8B                 db    0
.xdata$x:0000EA8C                 db    0
.xdata$x:0000EA8D                 db    0
.xdata$x:0000EA8E                 db    0
.xdata$x:0000EA8F                 db    0
.xdata$x:0000EA8F _xdata$x        ends
.xdata$x:0000EA8F
.xdata$x:0000EA90 ; ===========================================================================
.xdata$x:0000EA90
.xdata$x:0000EA90 ; Segment type: Pure data
.xdata$x:0000EA90 ; Segment permissions: Read
.xdata$x:0000EA90 _xdata$x        segment dword public 'DATA' use32
.xdata$x:0000EA90                 assume cs:_xdata$x
.xdata$x:0000EA90                 ;org 0EA90h
.xdata$x:0000EA90 ; COMDAT (pick associative to section at 75AC)
.xdata$x:0000EA90 __unwindtable$??1?$reverse_iterator@V?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@_W@std@@@std@@@std@@@std@@QAE@XZ db 0FFh
.xdata$x:0000EA90                                         ; DATA XREF: .xdata$x:0000EAA0o
.xdata$x:0000EA91                 db 0FFh
.xdata$x:0000EA92                 db 0FFh
.xdata$x:0000EA93                 db 0FFh
.xdata$x:0000EA94                 dd offset __unwindfunclet$??1?$reverse_iterator@V?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@_W@std@@@std@@@std@@@std@@QAE@XZ$0
.xdata$x:0000EA98 __ehfuncinfo$??1?$reverse_iterator@V?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@_W@std@@@std@@@std@@@std@@QAE@XZ db  22h ; "
.xdata$x:0000EA98                                         ; DATA XREF: __ehhandler$??1?$reverse_iterator@V?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@_W@std@@@std@@@std@@@std@@QAE@XZ+11o
.xdata$x:0000EA99                 db    5
.xdata$x:0000EA9A                 db  93h ; ô
.xdata$x:0000EA9B                 db  19h
.xdata$x:0000EA9C                 db    1
.xdata$x:0000EA9D                 db    0
.xdata$x:0000EA9E                 db    0
.xdata$x:0000EA9F                 db    0
.xdata$x:0000EAA0                 dd offset __unwindtable$??1?$reverse_iterator@V?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@_W@std@@@std@@@std@@@std@@QAE@XZ
.xdata$x:0000EAA4                 db    0
.xdata$x:0000EAA5                 db    0
.xdata$x:0000EAA6                 db    0
.xdata$x:0000EAA7                 db    0
.xdata$x:0000EAA8                 db    0
.xdata$x:0000EAA9                 db    0
.xdata$x:0000EAAA                 db    0
.xdata$x:0000EAAB                 db    0
.xdata$x:0000EAAC                 db    0
.xdata$x:0000EAAD                 db    0
.xdata$x:0000EAAE                 db    0
.xdata$x:0000EAAF                 db    0
.xdata$x:0000EAB0                 db    0
.xdata$x:0000EAB1                 db    0
.xdata$x:0000EAB2                 db    0
.xdata$x:0000EAB3                 db    0
.xdata$x:0000EAB4                 db    0
.xdata$x:0000EAB5                 db    0
.xdata$x:0000EAB6                 db    0
.xdata$x:0000EAB7                 db    0
.xdata$x:0000EAB8                 db    0
.xdata$x:0000EAB9                 db    0
.xdata$x:0000EABA                 db    0
.xdata$x:0000EABB                 db    0
.xdata$x:0000EABB _xdata$x        ends
.xdata$x:0000EABB
.xdata$x:0000EABC ; ===========================================================================
.xdata$x:0000EABC
.xdata$x:0000EABC ; Segment type: Pure data
.xdata$x:0000EABC ; Segment permissions: Read
.xdata$x:0000EABC _xdata$x        segment dword public 'DATA' use32
.xdata$x:0000EABC                 assume cs:_xdata$x
.xdata$x:0000EABC                 ;org 0EABCh
.xdata$x:0000EABC ; COMDAT (pick associative to section at 63F0)
.xdata$x:0000EABC __unwindtable$??0?$reverse_iterator@V?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@_W@std@@@std@@@std@@@std@@QAE@ABV01@@Z db 0FFh
.xdata$x:0000EABC                                         ; DATA XREF: .xdata$x:0000EACCo
.xdata$x:0000EABD                 db 0FFh
.xdata$x:0000EABE                 db 0FFh
.xdata$x:0000EABF                 db 0FFh
.xdata$x:0000EAC0                 dd offset __unwindfunclet$??0?$reverse_iterator@V?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@_W@std@@@std@@@std@@@std@@QAE@ABV01@@Z$0
.xdata$x:0000EAC4 __ehfuncinfo$??0?$reverse_iterator@V?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@_W@std@@@std@@@std@@@std@@QAE@ABV01@@Z db  22h ; "
.xdata$x:0000EAC4                                         ; DATA XREF: __ehhandler$??0?$reverse_iterator@V?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@_W@std@@@std@@@std@@@std@@QAE@ABV01@@Z+11o
.xdata$x:0000EAC5                 db    5
.xdata$x:0000EAC6                 db  93h ; ô
.xdata$x:0000EAC7                 db  19h
.xdata$x:0000EAC8                 db    1
.xdata$x:0000EAC9                 db    0
.xdata$x:0000EACA                 db    0
.xdata$x:0000EACB                 db    0
.xdata$x:0000EACC                 dd offset __unwindtable$??0?$reverse_iterator@V?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@_W@std@@@std@@@std@@@std@@QAE@ABV01@@Z
.xdata$x:0000EAD0                 db    0
.xdata$x:0000EAD1                 db    0
.xdata$x:0000EAD2                 db    0
.xdata$x:0000EAD3                 db    0
.xdata$x:0000EAD4                 db    0
.xdata$x:0000EAD5                 db    0
.xdata$x:0000EAD6                 db    0
.xdata$x:0000EAD7                 db    0
.xdata$x:0000EAD8                 db    0
.xdata$x:0000EAD9                 db    0
.xdata$x:0000EADA                 db    0
.xdata$x:0000EADB                 db    0
.xdata$x:0000EADC                 db    0
.xdata$x:0000EADD                 db    0
.xdata$x:0000EADE                 db    0
.xdata$x:0000EADF                 db    0
.xdata$x:0000EAE0                 db    0
.xdata$x:0000EAE1                 db    0
.xdata$x:0000EAE2                 db    0
.xdata$x:0000EAE3                 db    0
.xdata$x:0000EAE4                 db    0
.xdata$x:0000EAE5                 db    0
.xdata$x:0000EAE6                 db    0
.xdata$x:0000EAE7                 db    0
.xdata$x:0000EAE7 _xdata$x        ends
.xdata$x:0000EAE7
.xdata$x:0000EAE8 ; ===========================================================================
.xdata$x:0000EAE8
.xdata$x:0000EAE8 ; Segment type: Pure data
.xdata$x:0000EAE8 ; Segment permissions: Read
.xdata$x:0000EAE8 _xdata$x        segment dword public 'DATA' use32
.xdata$x:0000EAE8                 assume cs:_xdata$x
.xdata$x:0000EAE8                 ;org 0EAE8h
.xdata$x:0000EAE8 ; COMDAT (pick associative to section at 3070)
.xdata$x:0000EAE8 __ehfuncinfo$??$?0V?$reverse_iterator@V?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@_W@std@@@std@@@std@@@std@@X@?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QAE@V?$reverse_iterator@V?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@_W@std@@@std@@@std@@@1@0@Z db  22h ; "
.xdata$x:0000EAE8                                         ; DATA XREF: __ehhandler$??$?0V?$reverse_iterator@V?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@_W@std@@@std@@@std@@@std@@X@?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QAE@V?$reverse_iterator@V?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@_W@std@@@std@@@std@@@1@0@Z+11o
.xdata$x:0000EAE9                 db    5
.xdata$x:0000EAEA                 db  93h ; ô
.xdata$x:0000EAEB                 db  19h
.xdata$x:0000EAEC                 db    5
.xdata$x:0000EAED                 db    0
.xdata$x:0000EAEE                 db    0
.xdata$x:0000EAEF                 db    0
.xdata$x:0000EAF0                 dd offset __unwindtable$??$?0V?$reverse_iterator@V?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@_W@std@@@std@@@std@@@std@@X@?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QAE@V?$reverse_iterator@V?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@_W@std@@@std@@@std@@@1@0@Z
.xdata$x:0000EAF4                 db    0
.xdata$x:0000EAF5                 db    0
.xdata$x:0000EAF6                 db    0
.xdata$x:0000EAF7                 db    0
.xdata$x:0000EAF8                 db    0
.xdata$x:0000EAF9                 db    0
.xdata$x:0000EAFA                 db    0
.xdata$x:0000EAFB                 db    0
.xdata$x:0000EAFC                 db    0
.xdata$x:0000EAFD                 db    0
.xdata$x:0000EAFE                 db    0
.xdata$x:0000EAFF                 db    0
.xdata$x:0000EB00                 db    0
.xdata$x:0000EB01                 db    0
.xdata$x:0000EB02                 db    0
.xdata$x:0000EB03                 db    0
.xdata$x:0000EB04                 db    0
.xdata$x:0000EB05                 db    0
.xdata$x:0000EB06                 db    0
.xdata$x:0000EB07                 db    0
.xdata$x:0000EB08                 db    0
.xdata$x:0000EB09                 db    0
.xdata$x:0000EB0A                 db    0
.xdata$x:0000EB0B                 db    0
.xdata$x:0000EB0C __unwindtable$??$?0V?$reverse_iterator@V?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@_W@std@@@std@@@std@@@std@@X@?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QAE@V?$reverse_iterator@V?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@_W@std@@@std@@@std@@@1@0@Z db 0FFh
.xdata$x:0000EB0C                                         ; DATA XREF: .xdata$x:0000EAF0o
.xdata$x:0000EB0D                 db 0FFh
.xdata$x:0000EB0E                 db 0FFh
.xdata$x:0000EB0F                 db 0FFh
.xdata$x:0000EB10                 dd offset __unwindfunclet$??$?0V?$reverse_iterator@V?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@_W@std@@@std@@@std@@@std@@X@?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QAE@V?$reverse_iterator@V?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@_W@std@@@std@@@std@@@1@0@Z$0
.xdata$x:0000EB14                 align 8
.xdata$x:0000EB18                 dd offset __unwindfunclet$??$?0V?$reverse_iterator@V?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@_W@std@@@std@@@std@@@std@@X@?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QAE@V?$reverse_iterator@V?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@_W@std@@@std@@@std@@@1@0@Z$1
.xdata$x:0000EB1C                 db    1
.xdata$x:0000EB1D                 db    0
.xdata$x:0000EB1E                 db    0
.xdata$x:0000EB1F                 db    0
.xdata$x:0000EB20                 dd offset __unwindfunclet$??$?0V?$reverse_iterator@V?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@_W@std@@@std@@@std@@@std@@X@?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QAE@V?$reverse_iterator@V?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@_W@std@@@std@@@std@@@1@0@Z$2
.xdata$x:0000EB24                 db    2
.xdata$x:0000EB25                 db    0
.xdata$x:0000EB26                 db    0
.xdata$x:0000EB27                 db    0
.xdata$x:0000EB28                 dd offset __unwindfunclet$??$?0V?$reverse_iterator@V?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@_W@std@@@std@@@std@@@std@@X@?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QAE@V?$reverse_iterator@V?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@_W@std@@@std@@@std@@@1@0@Z$3
.xdata$x:0000EB2C                 db    3
.xdata$x:0000EB2D                 db    0
.xdata$x:0000EB2E                 db    0
.xdata$x:0000EB2F                 db    0
.xdata$x:0000EB30                 dd offset __unwindfunclet$??$?0V?$reverse_iterator@V?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@_W@std@@@std@@@std@@@std@@X@?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QAE@V?$reverse_iterator@V?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@_W@std@@@std@@@std@@@1@0@Z$4
.xdata$x:0000EB30 _xdata$x        ends
.xdata$x:0000EB30
.xdata$x:0000EB34 ; ===========================================================================
.xdata$x:0000EB34
.xdata$x:0000EB34 ; Segment type: Pure data
.xdata$x:0000EB34 ; Segment permissions: Read
.xdata$x:0000EB34 _xdata$x        segment dword public 'DATA' use32
.xdata$x:0000EB34                 assume cs:_xdata$x
.xdata$x:0000EB34                 ;org 0EB34h
.xdata$x:0000EB34 ; COMDAT (pick associative to section at 5720)
.xdata$x:0000EB34 __unwindtable$??0?$_String_const_iterator@V?$_String_val@U?$_Simple_types@_W@std@@@std@@@std@@QAE@PB_WPBU_Container_base12@1@@Z db 0FFh
.xdata$x:0000EB34                                         ; DATA XREF: .xdata$x:0000EB44o
.xdata$x:0000EB35                 db 0FFh
.xdata$x:0000EB36                 db 0FFh
.xdata$x:0000EB37                 db 0FFh
.xdata$x:0000EB38                 dd offset __unwindfunclet$??0?$_String_const_iterator@V?$_String_val@U?$_Simple_types@_W@std@@@std@@@std@@QAE@PB_WPBU_Container_base12@1@@Z$0
.xdata$x:0000EB3C __ehfuncinfo$??0?$_String_const_iterator@V?$_String_val@U?$_Simple_types@_W@std@@@std@@@std@@QAE@PB_WPBU_Container_base12@1@@Z db  22h ; "
.xdata$x:0000EB3C                                         ; DATA XREF: __ehhandler$??0?$_String_const_iterator@V?$_String_val@U?$_Simple_types@_W@std@@@std@@@std@@QAE@PB_WPBU_Container_base12@1@@Z+11o
.xdata$x:0000EB3D                 db    5
.xdata$x:0000EB3E                 db  93h ; ô
.xdata$x:0000EB3F                 db  19h
.xdata$x:0000EB40                 db    1
.xdata$x:0000EB41                 db    0
.xdata$x:0000EB42                 db    0
.xdata$x:0000EB43                 db    0
.xdata$x:0000EB44                 dd offset __unwindtable$??0?$_String_const_iterator@V?$_String_val@U?$_Simple_types@_W@std@@@std@@@std@@QAE@PB_WPBU_Container_base12@1@@Z
.xdata$x:0000EB48                 align 20h
.xdata$x:0000EB48 _xdata$x        ends
.xdata$x:0000EB48
.xdata$x:0000EB60 ; ===========================================================================
.xdata$x:0000EB60
.xdata$x:0000EB60 ; Segment type: Pure data
.xdata$x:0000EB60 ; Segment permissions: Read
.xdata$x:0000EB60 _xdata$x        segment dword public 'DATA' use32
.xdata$x:0000EB60                 assume cs:_xdata$x
.xdata$x:0000EB60                 ;org 0EB60h
.xdata$x:0000EB60 ; COMDAT (pick associative to section at 8508)
.xdata$x:0000EB60 __unwindtable$??H?$_String_const_iterator@V?$_String_val@U?$_Simple_types@_W@std@@@std@@@std@@QBE?AV01@H@Z db 0FFh
.xdata$x:0000EB60                                         ; DATA XREF: .xdata$x:0000EB78o
.xdata$x:0000EB61                 db 0FFh
.xdata$x:0000EB62                 db 0FFh
.xdata$x:0000EB63                 db 0FFh
.xdata$x:0000EB64                 dd offset __unwindfunclet$??H?$_String_const_iterator@V?$_String_val@U?$_Simple_types@_W@std@@@std@@@std@@QBE?AV01@H@Z$1
.xdata$x:0000EB68                 db    0
.xdata$x:0000EB69                 db    0
.xdata$x:0000EB6A                 db    0
.xdata$x:0000EB6B                 db    0
.xdata$x:0000EB6C                 dd offset __unwindfunclet$??H?$_String_const_iterator@V?$_String_val@U?$_Simple_types@_W@std@@@std@@@std@@QBE?AV01@H@Z$0
.xdata$x:0000EB70 __ehfuncinfo$??H?$_String_const_iterator@V?$_String_val@U?$_Simple_types@_W@std@@@std@@@std@@QBE?AV01@H@Z db  22h ; "
.xdata$x:0000EB70                                         ; DATA XREF: __ehhandler$??H?$_String_const_iterator@V?$_String_val@U?$_Simple_types@_W@std@@@std@@@std@@QBE?AV01@H@Z+11o
.xdata$x:0000EB71                 db    5
.xdata$x:0000EB72                 db  93h ; ô
.xdata$x:0000EB73                 db  19h
.xdata$x:0000EB74                 db    2
.xdata$x:0000EB75                 db    0
.xdata$x:0000EB76                 db    0
.xdata$x:0000EB77                 db    0
.xdata$x:0000EB78                 dd offset __unwindtable$??H?$_String_const_iterator@V?$_String_val@U?$_Simple_types@_W@std@@@std@@@std@@QBE?AV01@H@Z
.xdata$x:0000EB7C                 db    0
.xdata$x:0000EB7D                 db    0
.xdata$x:0000EB7E                 db    0
.xdata$x:0000EB7F                 db    0
.xdata$x:0000EB80                 db    0
.xdata$x:0000EB81                 db    0
.xdata$x:0000EB82                 db    0
.xdata$x:0000EB83                 db    0
.xdata$x:0000EB84                 db    0
.xdata$x:0000EB85                 db    0
.xdata$x:0000EB86                 db    0
.xdata$x:0000EB87                 db    0
.xdata$x:0000EB88                 db    0
.xdata$x:0000EB89                 db    0
.xdata$x:0000EB8A                 db    0
.xdata$x:0000EB8B                 db    0
.xdata$x:0000EB8C                 db    0
.xdata$x:0000EB8D                 db    0
.xdata$x:0000EB8E                 db    0
.xdata$x:0000EB8F                 db    0
.xdata$x:0000EB90                 db    0
.xdata$x:0000EB91                 db    0
.xdata$x:0000EB92                 db    0
.xdata$x:0000EB93                 db    0
.xdata$x:0000EB93 _xdata$x        ends
.xdata$x:0000EB93
.xdata$x:0000EB94 ; ===========================================================================
.xdata$x:0000EB94
.xdata$x:0000EB94 ; Segment type: Pure data
.xdata$x:0000EB94 ; Segment permissions: Read
.xdata$x:0000EB94 _xdata$x        segment dword public 'DATA' use32
.xdata$x:0000EB94                 assume cs:_xdata$x
.xdata$x:0000EB94                 ;org 0EB94h
.xdata$x:0000EB94 ; COMDAT (pick associative to section at 83E0)
.xdata$x:0000EB94 __unwindtable$??G?$_String_const_iterator@V?$_String_val@U?$_Simple_types@_W@std@@@std@@@std@@QBE?AV01@H@Z db 0FFh
.xdata$x:0000EB94                                         ; DATA XREF: .xdata$x:0000EBACo
.xdata$x:0000EB95                 db 0FFh
.xdata$x:0000EB96                 db 0FFh
.xdata$x:0000EB97                 db 0FFh
.xdata$x:0000EB98                 dd offset __unwindfunclet$??G?$_String_const_iterator@V?$_String_val@U?$_Simple_types@_W@std@@@std@@@std@@QBE?AV01@H@Z$1
.xdata$x:0000EB9C                 align 10h
.xdata$x:0000EBA0                 dd offset __unwindfunclet$??G?$_String_const_iterator@V?$_String_val@U?$_Simple_types@_W@std@@@std@@@std@@QBE?AV01@H@Z$0
.xdata$x:0000EBA4 __ehfuncinfo$??G?$_String_const_iterator@V?$_String_val@U?$_Simple_types@_W@std@@@std@@@std@@QBE?AV01@H@Z db  22h ; "
.xdata$x:0000EBA4                                         ; DATA XREF: __ehhandler$??G?$_String_const_iterator@V?$_String_val@U?$_Simple_types@_W@std@@@std@@@std@@QBE?AV01@H@Z+11o
.xdata$x:0000EBA5                 db    5
.xdata$x:0000EBA6                 db  93h ; ô
.xdata$x:0000EBA7                 db  19h
.xdata$x:0000EBA8                 db    2
.xdata$x:0000EBA9                 db    0
.xdata$x:0000EBAA                 db    0
.xdata$x:0000EBAB                 db    0
.xdata$x:0000EBAC                 dd offset __unwindtable$??G?$_String_const_iterator@V?$_String_val@U?$_Simple_types@_W@std@@@std@@@std@@QBE?AV01@H@Z
.xdata$x:0000EBB0                 db    0
.xdata$x:0000EBB1                 db    0
.xdata$x:0000EBB2                 db    0
.xdata$x:0000EBB3                 db    0
.xdata$x:0000EBB4                 db    0
.xdata$x:0000EBB5                 db    0
.xdata$x:0000EBB6                 db    0
.xdata$x:0000EBB7                 db    0
.xdata$x:0000EBB8                 db    0
.xdata$x:0000EBB9                 db    0
.xdata$x:0000EBBA                 db    0
.xdata$x:0000EBBB                 db    0
.xdata$x:0000EBBC                 db    0
.xdata$x:0000EBBD                 db    0
.xdata$x:0000EBBE                 db    0
.xdata$x:0000EBBF                 db    0
.xdata$x:0000EBC0                 db    0
.xdata$x:0000EBC1                 db    0
.xdata$x:0000EBC2                 db    0
.xdata$x:0000EBC3                 db    0
.xdata$x:0000EBC4                 db    0
.xdata$x:0000EBC5                 db    0
.xdata$x:0000EBC6                 db    0
.xdata$x:0000EBC7                 db    0
.xdata$x:0000EBC7 _xdata$x        ends
.xdata$x:0000EBC7
.xdata$x:0000EBC8 ; ===========================================================================
.xdata$x:0000EBC8
.xdata$x:0000EBC8 ; Segment type: Pure data
.xdata$x:0000EBC8 ; Segment permissions: Read
.xdata$x:0000EBC8 _xdata$x        segment dword public 'DATA' use32
.xdata$x:0000EBC8                 assume cs:_xdata$x
.xdata$x:0000EBC8                 ;org 0EBC8h
.xdata$x:0000EBC8 ; COMDAT (pick associative to section at 6F5C)
.xdata$x:0000EBC8 __unwindtable$??1?$_String_const_iterator@V?$_String_val@U?$_Simple_types@_W@std@@@std@@@std@@QAE@XZ db 0FFh
.xdata$x:0000EBC8                                         ; DATA XREF: .xdata$x:0000EBD8o
.xdata$x:0000EBC9                 db 0FFh
.xdata$x:0000EBCA                 db 0FFh
.xdata$x:0000EBCB                 db 0FFh
.xdata$x:0000EBCC                 dd offset __unwindfunclet$??1?$_String_const_iterator@V?$_String_val@U?$_Simple_types@_W@std@@@std@@@std@@QAE@XZ$0
.xdata$x:0000EBD0 __ehfuncinfo$??1?$_String_const_iterator@V?$_String_val@U?$_Simple_types@_W@std@@@std@@@std@@QAE@XZ db  22h ; "
.xdata$x:0000EBD0                                         ; DATA XREF: __ehhandler$??1?$_String_const_iterator@V?$_String_val@U?$_Simple_types@_W@std@@@std@@@std@@QAE@XZ+11o
.xdata$x:0000EBD1                 db    5
.xdata$x:0000EBD2                 db  93h ; ô
.xdata$x:0000EBD3                 db  19h
.xdata$x:0000EBD4                 db    1
.xdata$x:0000EBD5                 db    0
.xdata$x:0000EBD6                 db    0
.xdata$x:0000EBD7                 db    0
.xdata$x:0000EBD8                 dd offset __unwindtable$??1?$_String_const_iterator@V?$_String_val@U?$_Simple_types@_W@std@@@std@@@std@@QAE@XZ
.xdata$x:0000EBDC                 db    0
.xdata$x:0000EBDD                 db    0
.xdata$x:0000EBDE                 db    0
.xdata$x:0000EBDF                 db    0
.xdata$x:0000EBE0                 db    0
.xdata$x:0000EBE1                 db    0
.xdata$x:0000EBE2                 db    0
.xdata$x:0000EBE3                 db    0
.xdata$x:0000EBE4                 db    0
.xdata$x:0000EBE5                 db    0
.xdata$x:0000EBE6                 db    0
.xdata$x:0000EBE7                 db    0
.xdata$x:0000EBE8                 db    0
.xdata$x:0000EBE9                 db    0
.xdata$x:0000EBEA                 db    0
.xdata$x:0000EBEB                 db    0
.xdata$x:0000EBEC                 db    0
.xdata$x:0000EBED                 db    0
.xdata$x:0000EBEE                 db    0
.xdata$x:0000EBEF                 db    0
.xdata$x:0000EBF0                 db    0
.xdata$x:0000EBF1                 db    0
.xdata$x:0000EBF2                 db    0
.xdata$x:0000EBF3                 db    0
.xdata$x:0000EBF3 _xdata$x        ends
.xdata$x:0000EBF3
.xdata$x:0000EBF4 ; ===========================================================================
.xdata$x:0000EBF4
.xdata$x:0000EBF4 ; Segment type: Pure data
.xdata$x:0000EBF4 ; Segment permissions: Read
.xdata$x:0000EBF4 _xdata$x        segment dword public 'DATA' use32
.xdata$x:0000EBF4                 assume cs:_xdata$x
.xdata$x:0000EBF4                 ;org 0EBF4h
.xdata$x:0000EBF4 ; COMDAT (pick associative to section at 569C)
.xdata$x:0000EBF4 __unwindtable$??0?$_String_const_iterator@V?$_String_val@U?$_Simple_types@_W@std@@@std@@@std@@QAE@ABV01@@Z db 0FFh
.xdata$x:0000EBF4                                         ; DATA XREF: .xdata$x:0000EC04o
.xdata$x:0000EBF5                 db 0FFh
.xdata$x:0000EBF6                 db 0FFh
.xdata$x:0000EBF7                 db 0FFh
.xdata$x:0000EBF8                 dd offset __unwindfunclet$??0?$_String_const_iterator@V?$_String_val@U?$_Simple_types@_W@std@@@std@@@std@@QAE@ABV01@@Z$0
.xdata$x:0000EBFC __ehfuncinfo$??0?$_String_const_iterator@V?$_String_val@U?$_Simple_types@_W@std@@@std@@@std@@QAE@ABV01@@Z db  22h ; "
.xdata$x:0000EBFC                                         ; DATA XREF: __ehhandler$??0?$_String_const_iterator@V?$_String_val@U?$_Simple_types@_W@std@@@std@@@std@@QAE@ABV01@@Z+11o
.xdata$x:0000EBFD                 db    5
.xdata$x:0000EBFE                 db  93h ; ô
.xdata$x:0000EBFF                 db  19h
.xdata$x:0000EC00                 db    1
.xdata$x:0000EC01                 db    0
.xdata$x:0000EC02                 db    0
.xdata$x:0000EC03                 db    0
.xdata$x:0000EC04                 dd offset __unwindtable$??0?$_String_const_iterator@V?$_String_val@U?$_Simple_types@_W@std@@@std@@@std@@QAE@ABV01@@Z
.xdata$x:0000EC08                 align 20h
.xdata$x:0000EC08 _xdata$x        ends
.xdata$x:0000EC08
.xdata$x:0000EC20 ; ===========================================================================
.xdata$x:0000EC20
.xdata$x:0000EC20 ; Segment type: Pure data
.xdata$x:0000EC20 ; Segment permissions: Read
.xdata$x:0000EC20 _xdata$x        segment dword public 'DATA' use32
.xdata$x:0000EC20                 assume cs:_xdata$x
.xdata$x:0000EC20                 ;org 0EC20h
.xdata$x:0000EC20 ; COMDAT (pick associative to section at 4E28)
.xdata$x:0000EC20 __ehfuncinfo$??$convertFileName@V?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@_W@std@@@std@@@std@@@@YA?AV?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@V?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@_W@std@@@std@@@1@0@Z db  22h ; "
.xdata$x:0000EC20                                         ; DATA XREF: __ehhandler$??$convertFileName@V?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@_W@std@@@std@@@std@@@@YA?AV?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@V?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@_W@std@@@std@@@1@0@Z+1Bo
.xdata$x:0000EC21                 db    5
.xdata$x:0000EC22                 db  93h ; ô
.xdata$x:0000EC23                 db  19h
.xdata$x:0000EC24                 db    5
.xdata$x:0000EC25                 db    0
.xdata$x:0000EC26                 db    0
.xdata$x:0000EC27                 db    0
.xdata$x:0000EC28                 dd offset __unwindtable$??$convertFileName@V?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@_W@std@@@std@@@std@@@@YA?AV?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@V?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@_W@std@@@std@@@1@0@Z
.xdata$x:0000EC2C                 db    0
.xdata$x:0000EC2D                 db    0
.xdata$x:0000EC2E                 db    0
.xdata$x:0000EC2F                 db    0
.xdata$x:0000EC30                 db    0
.xdata$x:0000EC31                 db    0
.xdata$x:0000EC32                 db    0
.xdata$x:0000EC33                 db    0
.xdata$x:0000EC34                 db    0
.xdata$x:0000EC35                 db    0
.xdata$x:0000EC36                 db    0
.xdata$x:0000EC37                 db    0
.xdata$x:0000EC38                 db    0
.xdata$x:0000EC39                 db    0
.xdata$x:0000EC3A                 db    0
.xdata$x:0000EC3B                 db    0
.xdata$x:0000EC3C                 db    0
.xdata$x:0000EC3D                 db    0
.xdata$x:0000EC3E                 db    0
.xdata$x:0000EC3F                 db    0
.xdata$x:0000EC40                 db    0
.xdata$x:0000EC41                 db    0
.xdata$x:0000EC42                 db    0
.xdata$x:0000EC43                 db    0
.xdata$x:0000EC44 __unwindtable$??$convertFileName@V?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@_W@std@@@std@@@std@@@@YA?AV?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@V?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@_W@std@@@std@@@1@0@Z db 0FFh
.xdata$x:0000EC44                                         ; DATA XREF: .xdata$x:0000EC28o
.xdata$x:0000EC45                 db 0FFh
.xdata$x:0000EC46                 db 0FFh
.xdata$x:0000EC47                 db 0FFh
.xdata$x:0000EC48                 dd offset __unwindfunclet$??$convertFileName@V?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@_W@std@@@std@@@std@@@@YA?AV?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@V?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@_W@std@@@std@@@1@0@Z$4
.xdata$x:0000EC4C                 align 10h
.xdata$x:0000EC50                 dd offset __unwindfunclet$??$convertFileName@V?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@_W@std@@@std@@@std@@@@YA?AV?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@V?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@_W@std@@@std@@@1@0@Z$0
.xdata$x:0000EC54                 db    1
.xdata$x:0000EC55                 db    0
.xdata$x:0000EC56                 db    0
.xdata$x:0000EC57                 db    0
.xdata$x:0000EC58                 dd offset __unwindfunclet$??$convertFileName@V?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@_W@std@@@std@@@std@@@@YA?AV?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@V?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@_W@std@@@std@@@1@0@Z$1
.xdata$x:0000EC5C                 db    2
.xdata$x:0000EC5D                 db    0
.xdata$x:0000EC5E                 db    0
.xdata$x:0000EC5F                 db    0
.xdata$x:0000EC60                 dd offset __unwindfunclet$??$convertFileName@V?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@_W@std@@@std@@@std@@@@YA?AV?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@V?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@_W@std@@@std@@@1@0@Z$2
.xdata$x:0000EC64                 db    3
.xdata$x:0000EC65                 db    0
.xdata$x:0000EC66                 db    0
.xdata$x:0000EC67                 db    0
.xdata$x:0000EC68                 dd offset __unwindfunclet$??$convertFileName@V?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@_W@std@@@std@@@std@@@@YA?AV?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@V?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@_W@std@@@std@@@1@0@Z$3
.xdata$x:0000EC68 _xdata$x        ends
.xdata$x:0000EC68
.xdata$x:0000EC6C ; ===========================================================================
.xdata$x:0000EC6C
.xdata$x:0000EC6C ; Segment type: Pure data
.xdata$x:0000EC6C ; Segment permissions: Read
.xdata$x:0000EC6C _xdata$x        segment dword public 'DATA' use32
.xdata$x:0000EC6C                 assume cs:_xdata$x
.xdata$x:0000EC6C                 ;org 0EC6Ch
.xdata$x:0000EC6C ; COMDAT (pick associative to section at 4CC4)
.xdata$x:0000EC6C __ehfuncinfo$??$convertFileName@V?$_String_const_iterator@V?$_String_val@U?$_Simple_types@_W@std@@@std@@@std@@@@YA?AV?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@V?$_String_const_iterator@V?$_String_val@U?$_Simple_types@_W@std@@@std@@@1@0@Z db  22h ; "
.xdata$x:0000EC6C                                         ; DATA XREF: __ehhandler$??$convertFileName@V?$_String_const_iterator@V?$_String_val@U?$_Simple_types@_W@std@@@std@@@std@@@@YA?AV?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@V?$_String_const_iterator@V?$_String_val@U?$_Simple_types@_W@std@@@std@@@1@0@Z+1Bo
.xdata$x:0000EC6D                 db    5
.xdata$x:0000EC6E                 db  93h ; ô
.xdata$x:0000EC6F                 db  19h
.xdata$x:0000EC70                 db    5
.xdata$x:0000EC71                 db    0
.xdata$x:0000EC72                 db    0
.xdata$x:0000EC73                 db    0
.xdata$x:0000EC74                 dd offset __unwindtable$??$convertFileName@V?$_String_const_iterator@V?$_String_val@U?$_Simple_types@_W@std@@@std@@@std@@@@YA?AV?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@V?$_String_const_iterator@V?$_String_val@U?$_Simple_types@_W@std@@@std@@@1@0@Z
.xdata$x:0000EC78                 db    0
.xdata$x:0000EC79                 db    0
.xdata$x:0000EC7A                 db    0
.xdata$x:0000EC7B                 db    0
.xdata$x:0000EC7C                 db    0
.xdata$x:0000EC7D                 db    0
.xdata$x:0000EC7E                 db    0
.xdata$x:0000EC7F                 db    0
.xdata$x:0000EC80                 db    0
.xdata$x:0000EC81                 db    0
.xdata$x:0000EC82                 db    0
.xdata$x:0000EC83                 db    0
.xdata$x:0000EC84                 db    0
.xdata$x:0000EC85                 db    0
.xdata$x:0000EC86                 db    0
.xdata$x:0000EC87                 db    0
.xdata$x:0000EC88                 db    0
.xdata$x:0000EC89                 db    0
.xdata$x:0000EC8A                 db    0
.xdata$x:0000EC8B                 db    0
.xdata$x:0000EC8C                 db    0
.xdata$x:0000EC8D                 db    0
.xdata$x:0000EC8E                 db    0
.xdata$x:0000EC8F                 db    0
.xdata$x:0000EC90 __unwindtable$??$convertFileName@V?$_String_const_iterator@V?$_String_val@U?$_Simple_types@_W@std@@@std@@@std@@@@YA?AV?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@V?$_String_const_iterator@V?$_String_val@U?$_Simple_types@_W@std@@@std@@@1@0@Z db 0FFh
.xdata$x:0000EC90                                         ; DATA XREF: .xdata$x:0000EC74o
.xdata$x:0000EC91                 db 0FFh
.xdata$x:0000EC92                 db 0FFh
.xdata$x:0000EC93                 db 0FFh
.xdata$x:0000EC94                 dd offset __unwindfunclet$??$convertFileName@V?$_String_const_iterator@V?$_String_val@U?$_Simple_types@_W@std@@@std@@@std@@@@YA?AV?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@V?$_String_const_iterator@V?$_String_val@U?$_Simple_types@_W@std@@@std@@@1@0@Z$4
.xdata$x:0000EC98                 db    0
.xdata$x:0000EC99                 db    0
.xdata$x:0000EC9A                 db    0
.xdata$x:0000EC9B                 db    0
.xdata$x:0000EC9C                 dd offset __unwindfunclet$??$convertFileName@V?$_String_const_iterator@V?$_String_val@U?$_Simple_types@_W@std@@@std@@@std@@@@YA?AV?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@V?$_String_const_iterator@V?$_String_val@U?$_Simple_types@_W@std@@@std@@@1@0@Z$0
.xdata$x:0000ECA0                 db    1
.xdata$x:0000ECA1                 db    0
.xdata$x:0000ECA2                 db    0
.xdata$x:0000ECA3                 db    0
.xdata$x:0000ECA4                 dd offset __unwindfunclet$??$convertFileName@V?$_String_const_iterator@V?$_String_val@U?$_Simple_types@_W@std@@@std@@@std@@@@YA?AV?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@V?$_String_const_iterator@V?$_String_val@U?$_Simple_types@_W@std@@@std@@@1@0@Z$1
.xdata$x:0000ECA8                 db    2
.xdata$x:0000ECA9                 db    0
.xdata$x:0000ECAA                 db    0
.xdata$x:0000ECAB                 db    0
.xdata$x:0000ECAC                 dd offset __unwindfunclet$??$convertFileName@V?$_String_const_iterator@V?$_String_val@U?$_Simple_types@_W@std@@@std@@@std@@@@YA?AV?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@V?$_String_const_iterator@V?$_String_val@U?$_Simple_types@_W@std@@@std@@@1@0@Z$2
.xdata$x:0000ECB0                 db    3
.xdata$x:0000ECB1                 db    0
.xdata$x:0000ECB2                 db    0
.xdata$x:0000ECB3                 db    0
.xdata$x:0000ECB4                 dd offset __unwindfunclet$??$convertFileName@V?$_String_const_iterator@V?$_String_val@U?$_Simple_types@_W@std@@@std@@@std@@@@YA?AV?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@V?$_String_const_iterator@V?$_String_val@U?$_Simple_types@_W@std@@@std@@@1@0@Z$3
.xdata$x:0000ECB4 _xdata$x        ends
.xdata$x:0000ECB4
.xdata$x:0000ECB8 ; ===========================================================================
.xdata$x:0000ECB8
.xdata$x:0000ECB8 ; Segment type: Pure data
.xdata$x:0000ECB8 ; Segment permissions: Read
.xdata$x:0000ECB8 _xdata$x        segment dword public 'DATA' use32
.xdata$x:0000ECB8                 assume cs:_xdata$x
.xdata$x:0000ECB8                 ;org 0ECB8h
.xdata$x:0000ECB8 ; COMDAT (pick associative to section at 5824)
.xdata$x:0000ECB8 __unwindtable$??0?$_String_iterator@V?$_String_val@U?$_Simple_types@_W@std@@@std@@@std@@QAE@PA_WPBU_Container_base12@1@@Z db 0FFh
.xdata$x:0000ECB8                                         ; DATA XREF: .xdata$x:0000ECC8o
.xdata$x:0000ECB9                 db 0FFh
.xdata$x:0000ECBA                 db 0FFh
.xdata$x:0000ECBB                 db 0FFh
.xdata$x:0000ECBC                 dd offset __unwindfunclet$??0?$_String_iterator@V?$_String_val@U?$_Simple_types@_W@std@@@std@@@std@@QAE@PA_WPBU_Container_base12@1@@Z$0
.xdata$x:0000ECC0 __ehfuncinfo$??0?$_String_iterator@V?$_String_val@U?$_Simple_types@_W@std@@@std@@@std@@QAE@PA_WPBU_Container_base12@1@@Z db  22h ; "
.xdata$x:0000ECC0                                         ; DATA XREF: __ehhandler$??0?$_String_iterator@V?$_String_val@U?$_Simple_types@_W@std@@@std@@@std@@QAE@PA_WPBU_Container_base12@1@@Z+11o
.xdata$x:0000ECC1                 db    5
.xdata$x:0000ECC2                 db  93h ; ô
.xdata$x:0000ECC3                 db  19h
.xdata$x:0000ECC4                 db    1
.xdata$x:0000ECC5                 db    0
.xdata$x:0000ECC6                 db    0
.xdata$x:0000ECC7                 db    0
.xdata$x:0000ECC8                 dd offset __unwindtable$??0?$_String_iterator@V?$_String_val@U?$_Simple_types@_W@std@@@std@@@std@@QAE@PA_WPBU_Container_base12@1@@Z
.xdata$x:0000ECCC                 db    0
.xdata$x:0000ECCD                 db    0
.xdata$x:0000ECCE                 db    0
.xdata$x:0000ECCF                 db    0
.xdata$x:0000ECD0                 db    0
.xdata$x:0000ECD1                 db    0
.xdata$x:0000ECD2                 db    0
.xdata$x:0000ECD3                 db    0
.xdata$x:0000ECD4                 db    0
.xdata$x:0000ECD5                 db    0
.xdata$x:0000ECD6                 db    0
.xdata$x:0000ECD7                 db    0
.xdata$x:0000ECD8                 db    0
.xdata$x:0000ECD9                 db    0
.xdata$x:0000ECDA                 db    0
.xdata$x:0000ECDB                 db    0
.xdata$x:0000ECDC                 db    0
.xdata$x:0000ECDD                 db    0
.xdata$x:0000ECDE                 db    0
.xdata$x:0000ECDF                 db    0
.xdata$x:0000ECE0                 db    0
.xdata$x:0000ECE1                 db    0
.xdata$x:0000ECE2                 db    0
.xdata$x:0000ECE3                 db    0
.xdata$x:0000ECE3 _xdata$x        ends
.xdata$x:0000ECE3
.xdata$x:0000ECE4 ; ===========================================================================
.xdata$x:0000ECE4
.xdata$x:0000ECE4 ; Segment type: Pure data
.xdata$x:0000ECE4 ; Segment permissions: Read
.xdata$x:0000ECE4 _xdata$x        segment dword public 'DATA' use32
.xdata$x:0000ECE4                 assume cs:_xdata$x
.xdata$x:0000ECE4                 ;org 0ECE4h
.xdata$x:0000ECE4 ; COMDAT (pick associative to section at 85C4)
.xdata$x:0000ECE4 __unwindtable$??H?$_String_iterator@V?$_String_val@U?$_Simple_types@_W@std@@@std@@@std@@QBE?AV01@H@Z db 0FFh
.xdata$x:0000ECE4                                         ; DATA XREF: .xdata$x:0000ECFCo
.xdata$x:0000ECE5                 db 0FFh
.xdata$x:0000ECE6                 db 0FFh
.xdata$x:0000ECE7                 db 0FFh
.xdata$x:0000ECE8                 dd offset __unwindfunclet$??H?$_String_iterator@V?$_String_val@U?$_Simple_types@_W@std@@@std@@@std@@QBE?AV01@H@Z$1
.xdata$x:0000ECEC                 align 10h
.xdata$x:0000ECF0                 dd offset __unwindfunclet$??H?$_String_iterator@V?$_String_val@U?$_Simple_types@_W@std@@@std@@@std@@QBE?AV01@H@Z$0
.xdata$x:0000ECF4 __ehfuncinfo$??H?$_String_iterator@V?$_String_val@U?$_Simple_types@_W@std@@@std@@@std@@QBE?AV01@H@Z db  22h ; "
.xdata$x:0000ECF4                                         ; DATA XREF: __ehhandler$??H?$_String_iterator@V?$_String_val@U?$_Simple_types@_W@std@@@std@@@std@@QBE?AV01@H@Z+11o
.xdata$x:0000ECF5                 db    5
.xdata$x:0000ECF6                 db  93h ; ô
.xdata$x:0000ECF7                 db  19h
.xdata$x:0000ECF8                 db    2
.xdata$x:0000ECF9                 db    0
.xdata$x:0000ECFA                 db    0
.xdata$x:0000ECFB                 db    0
.xdata$x:0000ECFC                 dd offset __unwindtable$??H?$_String_iterator@V?$_String_val@U?$_Simple_types@_W@std@@@std@@@std@@QBE?AV01@H@Z
.xdata$x:0000ED00                 db    0
.xdata$x:0000ED01                 db    0
.xdata$x:0000ED02                 db    0
.xdata$x:0000ED03                 db    0
.xdata$x:0000ED04                 db    0
.xdata$x:0000ED05                 db    0
.xdata$x:0000ED06                 db    0
.xdata$x:0000ED07                 db    0
.xdata$x:0000ED08                 db    0
.xdata$x:0000ED09                 db    0
.xdata$x:0000ED0A                 db    0
.xdata$x:0000ED0B                 db    0
.xdata$x:0000ED0C                 db    0
.xdata$x:0000ED0D                 db    0
.xdata$x:0000ED0E                 db    0
.xdata$x:0000ED0F                 db    0
.xdata$x:0000ED10                 db    0
.xdata$x:0000ED11                 db    0
.xdata$x:0000ED12                 db    0
.xdata$x:0000ED13                 db    0
.xdata$x:0000ED14                 db    0
.xdata$x:0000ED15                 db    0
.xdata$x:0000ED16                 db    0
.xdata$x:0000ED17                 db    0
.xdata$x:0000ED17 _xdata$x        ends
.xdata$x:0000ED17
.xdata$x:0000ED18 ; ===========================================================================
.xdata$x:0000ED18
.xdata$x:0000ED18 ; Segment type: Pure data
.xdata$x:0000ED18 ; Segment permissions: Read
.xdata$x:0000ED18 _xdata$x        segment dword public 'DATA' use32
.xdata$x:0000ED18                 assume cs:_xdata$x
.xdata$x:0000ED18                 ;org 0ED18h
.xdata$x:0000ED18 ; COMDAT (pick associative to section at 6FCC)
.xdata$x:0000ED18 __unwindtable$??1?$_String_iterator@V?$_String_val@U?$_Simple_types@_W@std@@@std@@@std@@QAE@XZ db 0FFh
.xdata$x:0000ED18                                         ; DATA XREF: .xdata$x:0000ED28o
.xdata$x:0000ED19                 db 0FFh
.xdata$x:0000ED1A                 db 0FFh
.xdata$x:0000ED1B                 db 0FFh
.xdata$x:0000ED1C                 dd offset __unwindfunclet$??1?$_String_iterator@V?$_String_val@U?$_Simple_types@_W@std@@@std@@@std@@QAE@XZ$0
.xdata$x:0000ED20 __ehfuncinfo$??1?$_String_iterator@V?$_String_val@U?$_Simple_types@_W@std@@@std@@@std@@QAE@XZ db  22h ; "
.xdata$x:0000ED20                                         ; DATA XREF: __ehhandler$??1?$_String_iterator@V?$_String_val@U?$_Simple_types@_W@std@@@std@@@std@@QAE@XZ+11o
.xdata$x:0000ED21                 db    5
.xdata$x:0000ED22                 db  93h ; ô
.xdata$x:0000ED23                 db  19h
.xdata$x:0000ED24                 db    1
.xdata$x:0000ED25                 db    0
.xdata$x:0000ED26                 db    0
.xdata$x:0000ED27                 db    0
.xdata$x:0000ED28                 dd offset __unwindtable$??1?$_String_iterator@V?$_String_val@U?$_Simple_types@_W@std@@@std@@@std@@QAE@XZ
.xdata$x:0000ED2C                 db    0
.xdata$x:0000ED2D                 db    0
.xdata$x:0000ED2E                 db    0
.xdata$x:0000ED2F                 db    0
.xdata$x:0000ED30                 db    0
.xdata$x:0000ED31                 db    0
.xdata$x:0000ED32                 db    0
.xdata$x:0000ED33                 db    0
.xdata$x:0000ED34                 db    0
.xdata$x:0000ED35                 db    0
.xdata$x:0000ED36                 db    0
.xdata$x:0000ED37                 db    0
.xdata$x:0000ED38                 db    0
.xdata$x:0000ED39                 db    0
.xdata$x:0000ED3A                 db    0
.xdata$x:0000ED3B                 db    0
.xdata$x:0000ED3C                 db    0
.xdata$x:0000ED3D                 db    0
.xdata$x:0000ED3E                 db    0
.xdata$x:0000ED3F                 db    0
.xdata$x:0000ED40                 db    0
.xdata$x:0000ED41                 db    0
.xdata$x:0000ED42                 db    0
.xdata$x:0000ED43                 db    0
.xdata$x:0000ED43 _xdata$x        ends
.xdata$x:0000ED43
.xdata$x:0000ED44 ; ===========================================================================
.xdata$x:0000ED44
.xdata$x:0000ED44 ; Segment type: Pure data
.xdata$x:0000ED44 ; Segment permissions: Read
.xdata$x:0000ED44 _xdata$x        segment dword public 'DATA' use32
.xdata$x:0000ED44                 assume cs:_xdata$x
.xdata$x:0000ED44                 ;org 0ED44h
.xdata$x:0000ED44 ; COMDAT (pick associative to section at 57AC)
.xdata$x:0000ED44 __unwindtable$??0?$_String_iterator@V?$_String_val@U?$_Simple_types@_W@std@@@std@@@std@@QAE@ABV01@@Z db 0FFh
.xdata$x:0000ED44                                         ; DATA XREF: .xdata$x:0000ED54o
.xdata$x:0000ED45                 db 0FFh
.xdata$x:0000ED46                 db 0FFh
.xdata$x:0000ED47                 db 0FFh
.xdata$x:0000ED48                 dd offset __unwindfunclet$??0?$_String_iterator@V?$_String_val@U?$_Simple_types@_W@std@@@std@@@std@@QAE@ABV01@@Z$0
.xdata$x:0000ED4C __ehfuncinfo$??0?$_String_iterator@V?$_String_val@U?$_Simple_types@_W@std@@@std@@@std@@QAE@ABV01@@Z db  22h ; "
.xdata$x:0000ED4C                                         ; DATA XREF: __ehhandler$??0?$_String_iterator@V?$_String_val@U?$_Simple_types@_W@std@@@std@@@std@@QAE@ABV01@@Z+11o
.xdata$x:0000ED4D                 db    5
.xdata$x:0000ED4E                 db  93h ; ô
.xdata$x:0000ED4F                 db  19h
.xdata$x:0000ED50                 db    1
.xdata$x:0000ED51                 db    0
.xdata$x:0000ED52                 db    0
.xdata$x:0000ED53                 db    0
.xdata$x:0000ED54                 dd offset __unwindtable$??0?$_String_iterator@V?$_String_val@U?$_Simple_types@_W@std@@@std@@@std@@QAE@ABV01@@Z
.xdata$x:0000ED58                 db    0
.xdata$x:0000ED59                 db    0
.xdata$x:0000ED5A                 db    0
.xdata$x:0000ED5B                 db    0
.xdata$x:0000ED5C                 db    0
.xdata$x:0000ED5D                 db    0
.xdata$x:0000ED5E                 db    0
.xdata$x:0000ED5F                 db    0
.xdata$x:0000ED60                 db    0
.xdata$x:0000ED61                 db    0
.xdata$x:0000ED62                 db    0
.xdata$x:0000ED63                 db    0
.xdata$x:0000ED64                 db    0
.xdata$x:0000ED65                 db    0
.xdata$x:0000ED66                 db    0
.xdata$x:0000ED67                 db    0
.xdata$x:0000ED68                 db    0
.xdata$x:0000ED69                 db    0
.xdata$x:0000ED6A                 db    0
.xdata$x:0000ED6B                 db    0
.xdata$x:0000ED6C                 db    0
.xdata$x:0000ED6D                 db    0
.xdata$x:0000ED6E                 db    0
.xdata$x:0000ED6F                 db    0
.xdata$x:0000ED6F _xdata$x        ends
.xdata$x:0000ED6F
.xdata$x:0000ED70 ; ===========================================================================
.xdata$x:0000ED70
.xdata$x:0000ED70 ; Segment type: Pure data
.xdata$x:0000ED70 ; Segment permissions: Read
.xdata$x:0000ED70 _xdata$x        segment dword public 'DATA' use32
.xdata$x:0000ED70                 assume cs:_xdata$x
.xdata$x:0000ED70                 ;org 0ED70h
.xdata$x:0000ED70 ; COMDAT (pick associative to section at 50DC)
.xdata$x:0000ED70 __ehfuncinfo$??$transform@V?$_String_iterator@V?$_String_val@U?$_Simple_types@_W@std@@@std@@@std@@V12@P6AHH@Z@std@@YA?AV?$_String_iterator@V?$_String_val@U?$_Simple_types@_W@std@@@std@@@0@V10@00P6AHH@Z@Z db  22h ; "
.xdata$x:0000ED70                                         ; DATA XREF: __ehhandler$??$transform@V?$_String_iterator@V?$_String_val@U?$_Simple_types@_W@std@@@std@@@std@@V12@P6AHH@Z@std@@YA?AV?$_String_iterator@V?$_String_val@U?$_Simple_types@_W@std@@@std@@@0@V10@00P6AHH@Z@Z+11o
.xdata$x:0000ED71                 db    5
.xdata$x:0000ED72                 db  93h ; ô
.xdata$x:0000ED73                 db  19h
.xdata$x:0000ED74                 db  0Ah
.xdata$x:0000ED75                 db    0
.xdata$x:0000ED76                 db    0
.xdata$x:0000ED77                 db    0
.xdata$x:0000ED78                 dd offset __unwindtable$??$transform@V?$_String_iterator@V?$_String_val@U?$_Simple_types@_W@std@@@std@@@std@@V12@P6AHH@Z@std@@YA?AV?$_String_iterator@V?$_String_val@U?$_Simple_types@_W@std@@@std@@@0@V10@00P6AHH@Z@Z
.xdata$x:0000ED7C                 db    0
.xdata$x:0000ED7D                 db    0
.xdata$x:0000ED7E                 db    0
.xdata$x:0000ED7F                 db    0
.xdata$x:0000ED80                 db    0
.xdata$x:0000ED81                 db    0
.xdata$x:0000ED82                 db    0
.xdata$x:0000ED83                 db    0
.xdata$x:0000ED84                 db    0
.xdata$x:0000ED85                 db    0
.xdata$x:0000ED86                 db    0
.xdata$x:0000ED87                 db    0
.xdata$x:0000ED88                 db    0
.xdata$x:0000ED89                 db    0
.xdata$x:0000ED8A                 db    0
.xdata$x:0000ED8B                 db    0
.xdata$x:0000ED8C                 db    0
.xdata$x:0000ED8D                 db    0
.xdata$x:0000ED8E                 db    0
.xdata$x:0000ED8F                 db    0
.xdata$x:0000ED90                 db    0
.xdata$x:0000ED91                 db    0
.xdata$x:0000ED92                 db    0
.xdata$x:0000ED93                 db    0
.xdata$x:0000ED94 __unwindtable$??$transform@V?$_String_iterator@V?$_String_val@U?$_Simple_types@_W@std@@@std@@@std@@V12@P6AHH@Z@std@@YA?AV?$_String_iterator@V?$_String_val@U?$_Simple_types@_W@std@@@std@@@0@V10@00P6AHH@Z@Z db 0FFh
.xdata$x:0000ED94                                         ; DATA XREF: .xdata$x:0000ED78o
.xdata$x:0000ED95                 db 0FFh
.xdata$x:0000ED96                 db 0FFh
.xdata$x:0000ED97                 db 0FFh
.xdata$x:0000ED98                 dd offset __unwindfunclet$??$transform@V?$_String_iterator@V?$_String_val@U?$_Simple_types@_W@std@@@std@@@std@@V12@P6AHH@Z@std@@YA?AV?$_String_iterator@V?$_String_val@U?$_Simple_types@_W@std@@@std@@@0@V10@00P6AHH@Z@Z$9
.xdata$x:0000ED9C                 align 10h
.xdata$x:0000EDA0                 dd offset __unwindfunclet$??$transform@V?$_String_iterator@V?$_String_val@U?$_Simple_types@_W@std@@@std@@@std@@V12@P6AHH@Z@std@@YA?AV?$_String_iterator@V?$_String_val@U?$_Simple_types@_W@std@@@std@@@0@V10@00P6AHH@Z@Z$0
.xdata$x:0000EDA4                 db    1
.xdata$x:0000EDA5                 db    0
.xdata$x:0000EDA6                 db    0
.xdata$x:0000EDA7                 db    0
.xdata$x:0000EDA8                 dd offset __unwindfunclet$??$transform@V?$_String_iterator@V?$_String_val@U?$_Simple_types@_W@std@@@std@@@std@@V12@P6AHH@Z@std@@YA?AV?$_String_iterator@V?$_String_val@U?$_Simple_types@_W@std@@@std@@@0@V10@00P6AHH@Z@Z$1
.xdata$x:0000EDAC                 db    2
.xdata$x:0000EDAD                 db    0
.xdata$x:0000EDAE                 db    0
.xdata$x:0000EDAF                 db    0
.xdata$x:0000EDB0                 dd offset __unwindfunclet$??$transform@V?$_String_iterator@V?$_String_val@U?$_Simple_types@_W@std@@@std@@@std@@V12@P6AHH@Z@std@@YA?AV?$_String_iterator@V?$_String_val@U?$_Simple_types@_W@std@@@std@@@0@V10@00P6AHH@Z@Z$2
.xdata$x:0000EDB4                 db    3
.xdata$x:0000EDB5                 db    0
.xdata$x:0000EDB6                 db    0
.xdata$x:0000EDB7                 db    0
.xdata$x:0000EDB8                 dd offset __unwindfunclet$??$transform@V?$_String_iterator@V?$_String_val@U?$_Simple_types@_W@std@@@std@@@std@@V12@P6AHH@Z@std@@YA?AV?$_String_iterator@V?$_String_val@U?$_Simple_types@_W@std@@@std@@@0@V10@00P6AHH@Z@Z$3
.xdata$x:0000EDBC                 db    4
.xdata$x:0000EDBD                 db    0
.xdata$x:0000EDBE                 db    0
.xdata$x:0000EDBF                 db    0
.xdata$x:0000EDC0                 dd offset __unwindfunclet$??$transform@V?$_String_iterator@V?$_String_val@U?$_Simple_types@_W@std@@@std@@@std@@V12@P6AHH@Z@std@@YA?AV?$_String_iterator@V?$_String_val@U?$_Simple_types@_W@std@@@std@@@0@V10@00P6AHH@Z@Z$4
.xdata$x:0000EDC4                 db    3
.xdata$x:0000EDC5                 db    0
.xdata$x:0000EDC6                 db    0
.xdata$x:0000EDC7                 db    0
.xdata$x:0000EDC8                 dd offset __unwindfunclet$??$transform@V?$_String_iterator@V?$_String_val@U?$_Simple_types@_W@std@@@std@@@std@@V12@P6AHH@Z@std@@YA?AV?$_String_iterator@V?$_String_val@U?$_Simple_types@_W@std@@@std@@@0@V10@00P6AHH@Z@Z$5
.xdata$x:0000EDCC                 db    3
.xdata$x:0000EDCD                 db    0
.xdata$x:0000EDCE                 db    0
.xdata$x:0000EDCF                 db    0
.xdata$x:0000EDD0                 dd offset __unwindfunclet$??$transform@V?$_String_iterator@V?$_String_val@U?$_Simple_types@_W@std@@@std@@@std@@V12@P6AHH@Z@std@@YA?AV?$_String_iterator@V?$_String_val@U?$_Simple_types@_W@std@@@std@@@0@V10@00P6AHH@Z@Z$6
.xdata$x:0000EDD4                 db    7
.xdata$x:0000EDD5                 db    0
.xdata$x:0000EDD6                 db    0
.xdata$x:0000EDD7                 db    0
.xdata$x:0000EDD8                 dd offset __unwindfunclet$??$transform@V?$_String_iterator@V?$_String_val@U?$_Simple_types@_W@std@@@std@@@std@@V12@P6AHH@Z@std@@YA?AV?$_String_iterator@V?$_String_val@U?$_Simple_types@_W@std@@@std@@@0@V10@00P6AHH@Z@Z$7
.xdata$x:0000EDDC                 db    7
.xdata$x:0000EDDD                 db    0
.xdata$x:0000EDDE                 db    0
.xdata$x:0000EDDF                 db    0
.xdata$x:0000EDE0                 dd offset __unwindfunclet$??$transform@V?$_String_iterator@V?$_String_val@U?$_Simple_types@_W@std@@@std@@@std@@V12@P6AHH@Z@std@@YA?AV?$_String_iterator@V?$_String_val@U?$_Simple_types@_W@std@@@std@@@0@V10@00P6AHH@Z@Z$8
.xdata$x:0000EDE0 _xdata$x        ends
.xdata$x:0000EDE0
.xdata$x:0000EDE4 ; ===========================================================================
.xdata$x:0000EDE4
.xdata$x:0000EDE4 ; Segment type: Pure data
.xdata$x:0000EDE4 ; Segment permissions: Read
.xdata$x:0000EDE4 _xdata$x        segment dword public 'DATA' use32
.xdata$x:0000EDE4                 assume cs:_xdata$x
.xdata$x:0000EDE4                 ;org 0EDE4h
.xdata$x:0000EDE4 ; COMDAT (pick associative to section at 49EC)
.xdata$x:0000EDE4 __unwindtable$??$construct@U_Container_proxy@std@@U12@@?$allocator@U_Container_proxy@std@@@std@@QAEXPAU_Container_proxy@1@$$QAU21@@Z db 0FFh
.xdata$x:0000EDE4                                         ; DATA XREF: .xdata$x:0000EDF4o
.xdata$x:0000EDE5                 db 0FFh
.xdata$x:0000EDE6                 db 0FFh
.xdata$x:0000EDE7                 db 0FFh
.xdata$x:0000EDE8                 dd offset __unwindfunclet$??$construct@U_Container_proxy@std@@U12@@?$allocator@U_Container_proxy@std@@@std@@QAEXPAU_Container_proxy@1@$$QAU21@@Z$0
.xdata$x:0000EDEC __ehfuncinfo$??$construct@U_Container_proxy@std@@U12@@?$allocator@U_Container_proxy@std@@@std@@QAEXPAU_Container_proxy@1@$$QAU21@@Z db  22h ; "
.xdata$x:0000EDEC                                         ; DATA XREF: __ehhandler$??$construct@U_Container_proxy@std@@U12@@?$allocator@U_Container_proxy@std@@@std@@QAEXPAU_Container_proxy@1@$$QAU21@@Z+11o
.xdata$x:0000EDED                 db    5
.xdata$x:0000EDEE                 db  93h ; ô
.xdata$x:0000EDEF                 db  19h
.xdata$x:0000EDF0                 db    1
.xdata$x:0000EDF1                 db    0
.xdata$x:0000EDF2                 db    0
.xdata$x:0000EDF3                 db    0
.xdata$x:0000EDF4                 dd offset __unwindtable$??$construct@U_Container_proxy@std@@U12@@?$allocator@U_Container_proxy@std@@@std@@QAEXPAU_Container_proxy@1@$$QAU21@@Z
.xdata$x:0000EDF8                 db    0
.xdata$x:0000EDF9                 db    0
.xdata$x:0000EDFA                 db    0
.xdata$x:0000EDFB                 db    0
.xdata$x:0000EDFC                 db    0
.xdata$x:0000EDFD                 db    0
.xdata$x:0000EDFE                 db    0
.xdata$x:0000EDFF                 db    0
.xdata$x:0000EE00                 db    0
.xdata$x:0000EE01                 db    0
.xdata$x:0000EE02                 db    0
.xdata$x:0000EE03                 db    0
.xdata$x:0000EE04                 db    0
.xdata$x:0000EE05                 db    0
.xdata$x:0000EE06                 db    0
.xdata$x:0000EE07                 db    0
.xdata$x:0000EE08                 db    0
.xdata$x:0000EE09                 db    0
.xdata$x:0000EE0A                 db    0
.xdata$x:0000EE0B                 db    0
.xdata$x:0000EE0C                 db    0
.xdata$x:0000EE0D                 db    0
.xdata$x:0000EE0E                 db    0
.xdata$x:0000EE0F                 db    0
.xdata$x:0000EE0F _xdata$x        ends
.xdata$x:0000EE0F
.xdata$x:0000EE10 ; ===========================================================================
.xdata$x:0000EE10
.xdata$x:0000EE10 ; Segment type: Pure data
.xdata$x:0000EE10 ; Segment permissions: Read
.xdata$x:0000EE10 _xdata$x        segment dword public 'DATA' use32
.xdata$x:0000EE10                 assume cs:_xdata$x
.xdata$x:0000EE10                 ;org 0EE10h
.xdata$x:0000EE10 ; COMDAT (pick associative to section at 347C)
.xdata$x:0000EE10 __catchsym$??$_Construct@V?$reverse_iterator@V?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@_W@std@@@std@@@std@@@std@@@?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QAEXV?$reverse_iterator@V?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@_W@std@@@std@@@std@@@1@0Uforward_iterator_tag@1@@Z$8 db    0
.xdata$x:0000EE10                                         ; DATA XREF: .xdata$x:0000EE30o
.xdata$x:0000EE11                 db    0
.xdata$x:0000EE12                 db    0
.xdata$x:0000EE13                 db    0
.xdata$x:0000EE14                 db    0
.xdata$x:0000EE15                 db    0
.xdata$x:0000EE16                 db    0
.xdata$x:0000EE17                 db    0
.xdata$x:0000EE18                 db    0
.xdata$x:0000EE19                 db    0
.xdata$x:0000EE1A                 db    0
.xdata$x:0000EE1B                 db    0
.xdata$x:0000EE1C                 dd offset __catch$??$_Construct@V?$reverse_iterator@V?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@_W@std@@@std@@@std@@@std@@@?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QAEXV?$reverse_iterator@V?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@_W@std@@@std@@@std@@@1@0Uforward_iterator_tag@1@@Z$0
.xdata$x:0000EE20 __tryblocktable$??$_Construct@V?$reverse_iterator@V?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@_W@std@@@std@@@std@@@std@@@?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QAEXV?$reverse_iterator@V?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@_W@std@@@std@@@std@@@1@0Uforward_iterator_tag@1@@Z db    6
.xdata$x:0000EE20                                         ; DATA XREF: .xdata$x:0000EE44o
.xdata$x:0000EE21                 db    0
.xdata$x:0000EE22                 db    0
.xdata$x:0000EE23                 db    0
.xdata$x:0000EE24                 db    6
.xdata$x:0000EE25                 db    0
.xdata$x:0000EE26                 db    0
.xdata$x:0000EE27                 db    0
.xdata$x:0000EE28                 db    7
.xdata$x:0000EE29                 db    0
.xdata$x:0000EE2A                 db    0
.xdata$x:0000EE2B                 db    0
.xdata$x:0000EE2C                 db    1
.xdata$x:0000EE2D                 db    0
.xdata$x:0000EE2E                 db    0
.xdata$x:0000EE2F                 db    0
.xdata$x:0000EE30                 dd offset __catchsym$??$_Construct@V?$reverse_iterator@V?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@_W@std@@@std@@@std@@@std@@@?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QAEXV?$reverse_iterator@V?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@_W@std@@@std@@@std@@@1@0Uforward_iterator_tag@1@@Z$8
.xdata$x:0000EE34 __ehfuncinfo$??$_Construct@V?$reverse_iterator@V?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@_W@std@@@std@@@std@@@std@@@?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QAEXV?$reverse_iterator@V?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@_W@std@@@std@@@std@@@1@0Uforward_iterator_tag@1@@Z db  22h ; "
.xdata$x:0000EE34                                         ; DATA XREF: __ehhandler$??$_Construct@V?$reverse_iterator@V?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@_W@std@@@std@@@std@@@std@@@?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QAEXV?$reverse_iterator@V?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@_W@std@@@std@@@std@@@1@0Uforward_iterator_tag@1@@Z+11o
.xdata$x:0000EE35                 db    5
.xdata$x:0000EE36                 db  93h ; ô
.xdata$x:0000EE37                 db  19h
.xdata$x:0000EE38                 db    8
.xdata$x:0000EE39                 db    0
.xdata$x:0000EE3A                 db    0
.xdata$x:0000EE3B                 db    0
.xdata$x:0000EE3C                 dd offset __unwindtable$??$_Construct@V?$reverse_iterator@V?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@_W@std@@@std@@@std@@@std@@@?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QAEXV?$reverse_iterator@V?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@_W@std@@@std@@@std@@@1@0Uforward_iterator_tag@1@@Z
.xdata$x:0000EE40                 db    1
.xdata$x:0000EE41                 db    0
.xdata$x:0000EE42                 db    0
.xdata$x:0000EE43                 db    0
.xdata$x:0000EE44                 dd offset __tryblocktable$??$_Construct@V?$reverse_iterator@V?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@_W@std@@@std@@@std@@@std@@@?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QAEXV?$reverse_iterator@V?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@_W@std@@@std@@@std@@@1@0Uforward_iterator_tag@1@@Z
.xdata$x:0000EE48                 db    0
.xdata$x:0000EE49                 db    0
.xdata$x:0000EE4A                 db    0
.xdata$x:0000EE4B                 db    0
.xdata$x:0000EE4C                 db    0
.xdata$x:0000EE4D                 db    0
.xdata$x:0000EE4E                 db    0
.xdata$x:0000EE4F                 db    0
.xdata$x:0000EE50                 db    0
.xdata$x:0000EE51                 db    0
.xdata$x:0000EE52                 db    0
.xdata$x:0000EE53                 db    0
.xdata$x:0000EE54                 db    0
.xdata$x:0000EE55                 db    0
.xdata$x:0000EE56                 db    0
.xdata$x:0000EE57                 db    0
.xdata$x:0000EE58 __unwindtable$??$_Construct@V?$reverse_iterator@V?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@_W@std@@@std@@@std@@@std@@@?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QAEXV?$reverse_iterator@V?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@_W@std@@@std@@@std@@@1@0Uforward_iterator_tag@1@@Z db 0FFh
.xdata$x:0000EE58                                         ; DATA XREF: .xdata$x:0000EE3Co
.xdata$x:0000EE59                 db 0FFh
.xdata$x:0000EE5A                 db 0FFh
.xdata$x:0000EE5B                 db 0FFh
.xdata$x:0000EE5C                 dd offset __unwindfunclet$??$_Construct@V?$reverse_iterator@V?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@_W@std@@@std@@@std@@@std@@@?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QAEXV?$reverse_iterator@V?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@_W@std@@@std@@@std@@@1@0Uforward_iterator_tag@1@@Z$2
.xdata$x:0000EE60                 db    0
.xdata$x:0000EE61                 db    0
.xdata$x:0000EE62                 db    0
.xdata$x:0000EE63                 db    0
.xdata$x:0000EE64                 dd offset __unwindfunclet$??$_Construct@V?$reverse_iterator@V?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@_W@std@@@std@@@std@@@std@@@?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QAEXV?$reverse_iterator@V?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@_W@std@@@std@@@std@@@1@0Uforward_iterator_tag@1@@Z$3
.xdata$x:0000EE68                 db    1
.xdata$x:0000EE69                 db    0
.xdata$x:0000EE6A                 db    0
.xdata$x:0000EE6B                 db    0
.xdata$x:0000EE6C                 dd offset __unwindfunclet$??$_Construct@V?$reverse_iterator@V?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@_W@std@@@std@@@std@@@std@@@?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QAEXV?$reverse_iterator@V?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@_W@std@@@std@@@std@@@1@0Uforward_iterator_tag@1@@Z$4
.xdata$x:0000EE70                 db    2
.xdata$x:0000EE71                 db    0
.xdata$x:0000EE72                 db    0
.xdata$x:0000EE73                 db    0
.xdata$x:0000EE74                 dd offset __unwindfunclet$??$_Construct@V?$reverse_iterator@V?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@_W@std@@@std@@@std@@@std@@@?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QAEXV?$reverse_iterator@V?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@_W@std@@@std@@@std@@@1@0Uforward_iterator_tag@1@@Z$5
.xdata$x:0000EE78                 db    1
.xdata$x:0000EE79                 db    0
.xdata$x:0000EE7A                 db    0
.xdata$x:0000EE7B                 db    0
.xdata$x:0000EE7C                 dd offset __unwindfunclet$??$_Construct@V?$reverse_iterator@V?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@_W@std@@@std@@@std@@@std@@@?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QAEXV?$reverse_iterator@V?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@_W@std@@@std@@@std@@@1@0Uforward_iterator_tag@1@@Z$6
.xdata$x:0000EE80                 db    4
.xdata$x:0000EE81                 db    0
.xdata$x:0000EE82                 db    0
.xdata$x:0000EE83                 db    0
.xdata$x:0000EE84                 dd offset __unwindfunclet$??$_Construct@V?$reverse_iterator@V?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@_W@std@@@std@@@std@@@std@@@?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QAEXV?$reverse_iterator@V?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@_W@std@@@std@@@std@@@1@0Uforward_iterator_tag@1@@Z$7
.xdata$x:0000EE88                 db    1
.xdata$x:0000EE89                 db    0
.xdata$x:0000EE8A                 db    0
.xdata$x:0000EE8B                 db    0
.xdata$x:0000EE8C                 db    0
.xdata$x:0000EE8D                 db    0
.xdata$x:0000EE8E                 db    0
.xdata$x:0000EE8F                 db    0
.xdata$x:0000EE90                 db    1
.xdata$x:0000EE91                 db    0
.xdata$x:0000EE92                 db    0
.xdata$x:0000EE93                 db    0
.xdata$x:0000EE94                 db    0
.xdata$x:0000EE95                 db    0
.xdata$x:0000EE96                 db    0
.xdata$x:0000EE97                 db    0
.xdata$x:0000EE97 _xdata$x        ends
.xdata$x:0000EE97
.xdata$x:0000EE98 ; ===========================================================================
.xdata$x:0000EE98
.xdata$x:0000EE98 ; Segment type: Pure data
.xdata$x:0000EE98 ; Segment permissions: Read
.xdata$x:0000EE98 _xdata$x        segment dword public 'DATA' use32
.xdata$x:0000EE98                 assume cs:_xdata$x
.xdata$x:0000EE98                 ;org 0EE98h
.xdata$x:0000EE98 ; COMDAT (pick associative to section at 39E4)
.xdata$x:0000EE98 __unwindtable$??$_Debug_range@V?$_String_iterator@V?$_String_val@U?$_Simple_types@_W@std@@@std@@@std@@@std@@YAXV?$_String_iterator@V?$_String_val@U?$_Simple_types@_W@std@@@std@@@0@0PB_WI@Z db 0FFh
.xdata$x:0000EE98                                         ; DATA XREF: .xdata$x:0000EEC0o
.xdata$x:0000EE99                 db 0FFh
.xdata$x:0000EE9A                 db 0FFh
.xdata$x:0000EE9B                 db 0FFh
.xdata$x:0000EE9C                 dd offset __unwindfunclet$??$_Debug_range@V?$_String_iterator@V?$_String_val@U?$_Simple_types@_W@std@@@std@@@std@@@std@@YAXV?$_String_iterator@V?$_String_val@U?$_Simple_types@_W@std@@@std@@@0@0PB_WI@Z$0
.xdata$x:0000EEA0                 db    0
.xdata$x:0000EEA1                 db    0
.xdata$x:0000EEA2                 db    0
.xdata$x:0000EEA3                 db    0
.xdata$x:0000EEA4                 dd offset __unwindfunclet$??$_Debug_range@V?$_String_iterator@V?$_String_val@U?$_Simple_types@_W@std@@@std@@@std@@@std@@YAXV?$_String_iterator@V?$_String_val@U?$_Simple_types@_W@std@@@std@@@0@0PB_WI@Z$1
.xdata$x:0000EEA8                 db    1
.xdata$x:0000EEA9                 db    0
.xdata$x:0000EEAA                 db    0
.xdata$x:0000EEAB                 db    0
.xdata$x:0000EEAC                 dd offset __unwindfunclet$??$_Debug_range@V?$_String_iterator@V?$_String_val@U?$_Simple_types@_W@std@@@std@@@std@@@std@@YAXV?$_String_iterator@V?$_String_val@U?$_Simple_types@_W@std@@@std@@@0@0PB_WI@Z$2
.xdata$x:0000EEB0                 db    2
.xdata$x:0000EEB1                 db    0
.xdata$x:0000EEB2                 db    0
.xdata$x:0000EEB3                 db    0
.xdata$x:0000EEB4                 dd offset __unwindfunclet$??$_Debug_range@V?$_String_iterator@V?$_String_val@U?$_Simple_types@_W@std@@@std@@@std@@@std@@YAXV?$_String_iterator@V?$_String_val@U?$_Simple_types@_W@std@@@std@@@0@0PB_WI@Z$3
.xdata$x:0000EEB8 __ehfuncinfo$??$_Debug_range@V?$_String_iterator@V?$_String_val@U?$_Simple_types@_W@std@@@std@@@std@@@std@@YAXV?$_String_iterator@V?$_String_val@U?$_Simple_types@_W@std@@@std@@@0@0PB_WI@Z db  22h ; "
.xdata$x:0000EEB8                                         ; DATA XREF: __ehhandler$??$_Debug_range@V?$_String_iterator@V?$_String_val@U?$_Simple_types@_W@std@@@std@@@std@@@std@@YAXV?$_String_iterator@V?$_String_val@U?$_Simple_types@_W@std@@@std@@@0@0PB_WI@Z+11o
.xdata$x:0000EEB9                 db    5
.xdata$x:0000EEBA                 db  93h ; ô
.xdata$x:0000EEBB                 db  19h
.xdata$x:0000EEBC                 db    4
.xdata$x:0000EEBD                 db    0
.xdata$x:0000EEBE                 db    0
.xdata$x:0000EEBF                 db    0
.xdata$x:0000EEC0                 dd offset __unwindtable$??$_Debug_range@V?$_String_iterator@V?$_String_val@U?$_Simple_types@_W@std@@@std@@@std@@@std@@YAXV?$_String_iterator@V?$_String_val@U?$_Simple_types@_W@std@@@std@@@0@0PB_WI@Z
.xdata$x:0000EEC4                 db    0
.xdata$x:0000EEC5                 db    0
.xdata$x:0000EEC6                 db    0
.xdata$x:0000EEC7                 db    0
.xdata$x:0000EEC8                 db    0
.xdata$x:0000EEC9                 db    0
.xdata$x:0000EECA                 db    0
.xdata$x:0000EECB                 db    0
.xdata$x:0000EECC                 db    0
.xdata$x:0000EECD                 db    0
.xdata$x:0000EECE                 db    0
.xdata$x:0000EECF                 db    0
.xdata$x:0000EED0                 db    0
.xdata$x:0000EED1                 db    0
.xdata$x:0000EED2                 db    0
.xdata$x:0000EED3                 db    0
.xdata$x:0000EED4                 db    0
.xdata$x:0000EED5                 db    0
.xdata$x:0000EED6                 db    0
.xdata$x:0000EED7                 db    0
.xdata$x:0000EED8                 db    0
.xdata$x:0000EED9                 db    0
.xdata$x:0000EEDA                 db    0
.xdata$x:0000EEDB                 db    0
.xdata$x:0000EEDB _xdata$x        ends
.xdata$x:0000EEDB
.xdata$x:0000EEDC ; ===========================================================================
.xdata$x:0000EEDC
.xdata$x:0000EEDC ; Segment type: Pure data
.xdata$x:0000EEDC ; Segment permissions: Read
.xdata$x:0000EEDC _xdata$x        segment dword public 'DATA' use32
.xdata$x:0000EEDC                 assume cs:_xdata$x
.xdata$x:0000EEDC                 ;org 0EEDCh
.xdata$x:0000EEDC ; COMDAT (pick associative to section at 43C8)
.xdata$x:0000EEDC __unwindtable$??$_Unchecked@V?$_String_val@U?$_Simple_types@_W@std@@@std@@@std@@YAPA_WV?$_String_iterator@V?$_String_val@U?$_Simple_types@_W@std@@@std@@@0@@Z db 0FFh
.xdata$x:0000EEDC                                         ; DATA XREF: .xdata$x:0000EEECo
.xdata$x:0000EEDD                 db 0FFh
.xdata$x:0000EEDE                 db 0FFh
.xdata$x:0000EEDF                 db 0FFh
.xdata$x:0000EEE0                 dd offset __unwindfunclet$??$_Unchecked@V?$_String_val@U?$_Simple_types@_W@std@@@std@@@std@@YAPA_WV?$_String_iterator@V?$_String_val@U?$_Simple_types@_W@std@@@std@@@0@@Z$0
.xdata$x:0000EEE4 __ehfuncinfo$??$_Unchecked@V?$_String_val@U?$_Simple_types@_W@std@@@std@@@std@@YAPA_WV?$_String_iterator@V?$_String_val@U?$_Simple_types@_W@std@@@std@@@0@@Z db  22h ; "
.xdata$x:0000EEE4                                         ; DATA XREF: __ehhandler$??$_Unchecked@V?$_String_val@U?$_Simple_types@_W@std@@@std@@@std@@YAPA_WV?$_String_iterator@V?$_String_val@U?$_Simple_types@_W@std@@@std@@@0@@Z+11o
.xdata$x:0000EEE5                 db    5
.xdata$x:0000EEE6                 db  93h ; ô
.xdata$x:0000EEE7                 db  19h
.xdata$x:0000EEE8                 db    1
.xdata$x:0000EEE9                 db    0
.xdata$x:0000EEEA                 db    0
.xdata$x:0000EEEB                 db    0
.xdata$x:0000EEEC                 dd offset __unwindtable$??$_Unchecked@V?$_String_val@U?$_Simple_types@_W@std@@@std@@@std@@YAPA_WV?$_String_iterator@V?$_String_val@U?$_Simple_types@_W@std@@@std@@@0@@Z
.xdata$x:0000EEF0                 db    0
.xdata$x:0000EEF1                 db    0
.xdata$x:0000EEF2                 db    0
.xdata$x:0000EEF3                 db    0
.xdata$x:0000EEF4                 db    0
.xdata$x:0000EEF5                 db    0
.xdata$x:0000EEF6                 db    0
.xdata$x:0000EEF7                 db    0
.xdata$x:0000EEF8                 db    0
.xdata$x:0000EEF9                 db    0
.xdata$x:0000EEFA                 db    0
.xdata$x:0000EEFB                 db    0
.xdata$x:0000EEFC                 db    0
.xdata$x:0000EEFD                 db    0
.xdata$x:0000EEFE                 db    0
.xdata$x:0000EEFF                 db    0
.xdata$x:0000EF00                 db    0
.xdata$x:0000EF01                 db    0
.xdata$x:0000EF02                 db    0
.xdata$x:0000EF03                 db    0
.xdata$x:0000EF04                 db    0
.xdata$x:0000EF05                 db    0
.xdata$x:0000EF06                 db    0
.xdata$x:0000EF07                 db    0
.xdata$x:0000EF07 _xdata$x        ends
.xdata$x:0000EF07
.xdata$x:0000EF08 ; ===========================================================================
.xdata$x:0000EF08
.xdata$x:0000EF08 ; Segment type: Pure data
.xdata$x:0000EF08 ; Segment permissions: Read
.xdata$x:0000EF08 _xdata$x        segment dword public 'DATA' use32
.xdata$x:0000EF08                 assume cs:_xdata$x
.xdata$x:0000EF08                 ;org 0EF08h
.xdata$x:0000EF08 ; COMDAT (pick associative to section at 3F44)
.xdata$x:0000EF08 __unwindtable$??$_Is_checked@V?$_String_iterator@V?$_String_val@U?$_Simple_types@_W@std@@@std@@@std@@@std@@YA?AU?$integral_constant@_N$00@0@V?$_String_iterator@V?$_String_val@U?$_Simple_types@_W@std@@@std@@@0@@Z db 0FFh
.xdata$x:0000EF08                                         ; DATA XREF: .xdata$x:0000EF18o
.xdata$x:0000EF09                 db 0FFh
.xdata$x:0000EF0A                 db 0FFh
.xdata$x:0000EF0B                 db 0FFh
.xdata$x:0000EF0C                 dd offset __unwindfunclet$??$_Is_checked@V?$_String_iterator@V?$_String_val@U?$_Simple_types@_W@std@@@std@@@std@@@std@@YA?AU?$integral_constant@_N$00@0@V?$_String_iterator@V?$_String_val@U?$_Simple_types@_W@std@@@std@@@0@@Z$0
.xdata$x:0000EF10 __ehfuncinfo$??$_Is_checked@V?$_String_iterator@V?$_String_val@U?$_Simple_types@_W@std@@@std@@@std@@@std@@YA?AU?$integral_constant@_N$00@0@V?$_String_iterator@V?$_String_val@U?$_Simple_types@_W@std@@@std@@@0@@Z db  22h ; "
.xdata$x:0000EF10                                         ; DATA XREF: __ehhandler$??$_Is_checked@V?$_String_iterator@V?$_String_val@U?$_Simple_types@_W@std@@@std@@@std@@@std@@YA?AU?$integral_constant@_N$00@0@V?$_String_iterator@V?$_String_val@U?$_Simple_types@_W@std@@@std@@@0@@Z+11o
.xdata$x:0000EF11                 db    5
.xdata$x:0000EF12                 db  93h ; ô
.xdata$x:0000EF13                 db  19h
.xdata$x:0000EF14                 db    1
.xdata$x:0000EF15                 db    0
.xdata$x:0000EF16                 db    0
.xdata$x:0000EF17                 db    0
.xdata$x:0000EF18                 dd offset __unwindtable$??$_Is_checked@V?$_String_iterator@V?$_String_val@U?$_Simple_types@_W@std@@@std@@@std@@@std@@YA?AU?$integral_constant@_N$00@0@V?$_String_iterator@V?$_String_val@U?$_Simple_types@_W@std@@@std@@@0@@Z
.xdata$x:0000EF1C                 db    0
.xdata$x:0000EF1D                 db    0
.xdata$x:0000EF1E                 db    0
.xdata$x:0000EF1F                 db    0
.xdata$x:0000EF20                 db    0
.xdata$x:0000EF21                 db    0
.xdata$x:0000EF22                 db    0
.xdata$x:0000EF23                 db    0
.xdata$x:0000EF24                 db    0
.xdata$x:0000EF25                 db    0
.xdata$x:0000EF26                 db    0
.xdata$x:0000EF27                 db    0
.xdata$x:0000EF28                 db    0
.xdata$x:0000EF29                 db    0
.xdata$x:0000EF2A                 db    0
.xdata$x:0000EF2B                 db    0
.xdata$x:0000EF2C                 db    0
.xdata$x:0000EF2D                 db    0
.xdata$x:0000EF2E                 db    0
.xdata$x:0000EF2F                 db    0
.xdata$x:0000EF30                 db    0
.xdata$x:0000EF31                 db    0
.xdata$x:0000EF32                 db    0
.xdata$x:0000EF33                 db    0
.xdata$x:0000EF33 _xdata$x        ends
.xdata$x:0000EF33
.xdata$x:0000EF34 ; ===========================================================================
.xdata$x:0000EF34
.xdata$x:0000EF34 ; Segment type: Pure data
.xdata$x:0000EF34 ; Segment permissions: Read
.xdata$x:0000EF34 _xdata$x        segment dword public 'DATA' use32
.xdata$x:0000EF34                 assume cs:_xdata$x
.xdata$x:0000EF34                 ;org 0EF34h
.xdata$x:0000EF34 ; COMDAT (pick associative to section at 40F0)
.xdata$x:0000EF34 __unwindtable$??$_Transform1@PA_WV?$_String_iterator@V?$_String_val@U?$_Simple_types@_W@std@@@std@@@std@@P6AHH@Z@std@@YA?AV?$_String_iterator@V?$_String_val@U?$_Simple_types@_W@std@@@std@@@0@PA_W0V10@P6AHH@ZU?$integral_constant@_N$00@0@@Z db 0FFh
.xdata$x:0000EF34                                         ; DATA XREF: .xdata$x:0000EF54o
.xdata$x:0000EF35                 db 0FFh
.xdata$x:0000EF36                 db 0FFh
.xdata$x:0000EF37                 db 0FFh
.xdata$x:0000EF38                 dd offset __unwindfunclet$??$_Transform1@PA_WV?$_String_iterator@V?$_String_val@U?$_Simple_types@_W@std@@@std@@@std@@P6AHH@Z@std@@YA?AV?$_String_iterator@V?$_String_val@U?$_Simple_types@_W@std@@@std@@@0@PA_W0V10@P6AHH@ZU?$integral_constant@_N$00@0@@Z$2
.xdata$x:0000EF3C                 align 10h
.xdata$x:0000EF40                 dd offset __unwindfunclet$??$_Transform1@PA_WV?$_String_iterator@V?$_String_val@U?$_Simple_types@_W@std@@@std@@@std@@P6AHH@Z@std@@YA?AV?$_String_iterator@V?$_String_val@U?$_Simple_types@_W@std@@@std@@@0@PA_W0V10@P6AHH@ZU?$integral_constant@_N$00@0@@Z$0
.xdata$x:0000EF44                 db    1
.xdata$x:0000EF45                 db    0
.xdata$x:0000EF46                 db    0
.xdata$x:0000EF47                 db    0
.xdata$x:0000EF48                 dd offset __unwindfunclet$??$_Transform1@PA_WV?$_String_iterator@V?$_String_val@U?$_Simple_types@_W@std@@@std@@@std@@P6AHH@Z@std@@YA?AV?$_String_iterator@V?$_String_val@U?$_Simple_types@_W@std@@@std@@@0@PA_W0V10@P6AHH@ZU?$integral_constant@_N$00@0@@Z$1
.xdata$x:0000EF4C __ehfuncinfo$??$_Transform1@PA_WV?$_String_iterator@V?$_String_val@U?$_Simple_types@_W@std@@@std@@@std@@P6AHH@Z@std@@YA?AV?$_String_iterator@V?$_String_val@U?$_Simple_types@_W@std@@@std@@@0@PA_W0V10@P6AHH@ZU?$integral_constant@_N$00@0@@Z db  22h ; "
.xdata$x:0000EF4C                                         ; DATA XREF: __ehhandler$??$_Transform1@PA_WV?$_String_iterator@V?$_String_val@U?$_Simple_types@_W@std@@@std@@@std@@P6AHH@Z@std@@YA?AV?$_String_iterator@V?$_String_val@U?$_Simple_types@_W@std@@@std@@@0@PA_W0V10@P6AHH@ZU?$integral_constant@_N$00@0@@Z+11o
.xdata$x:0000EF4D                 db    5
.xdata$x:0000EF4E                 db  93h ; ô
.xdata$x:0000EF4F                 db  19h
.xdata$x:0000EF50                 db    3
.xdata$x:0000EF51                 db    0
.xdata$x:0000EF52                 db    0
.xdata$x:0000EF53                 db    0
.xdata$x:0000EF54                 dd offset __unwindtable$??$_Transform1@PA_WV?$_String_iterator@V?$_String_val@U?$_Simple_types@_W@std@@@std@@@std@@P6AHH@Z@std@@YA?AV?$_String_iterator@V?$_String_val@U?$_Simple_types@_W@std@@@std@@@0@PA_W0V10@P6AHH@ZU?$integral_constant@_N$00@0@@Z
.xdata$x:0000EF58                 db    0
.xdata$x:0000EF59                 db    0
.xdata$x:0000EF5A                 db    0
.xdata$x:0000EF5B                 db    0
.xdata$x:0000EF5C                 db    0
.xdata$x:0000EF5D                 db    0
.xdata$x:0000EF5E                 db    0
.xdata$x:0000EF5F                 db    0
.xdata$x:0000EF60                 db    0
.xdata$x:0000EF61                 db    0
.xdata$x:0000EF62                 db    0
.xdata$x:0000EF63                 db    0
.xdata$x:0000EF64                 db    0
.xdata$x:0000EF65                 db    0
.xdata$x:0000EF66                 db    0
.xdata$x:0000EF67                 db    0
.xdata$x:0000EF68                 db    0
.xdata$x:0000EF69                 db    0
.xdata$x:0000EF6A                 db    0
.xdata$x:0000EF6B                 db    0
.xdata$x:0000EF6C                 db    0
.xdata$x:0000EF6D                 db    0
.xdata$x:0000EF6E                 db    0
.xdata$x:0000EF6F                 db    0
.xdata$x:0000EF6F _xdata$x        ends
.xdata$x:0000EF6F
.xdata$x:0000EF70 ; ===========================================================================
.xdata$x:0000EF70
.xdata$x:0000EF70 ; Segment type: Pure data
.xdata$x:0000EF70 ; Segment permissions: Read
.xdata$x:0000EF70 _xdata$x        segment dword public 'DATA' use32
.xdata$x:0000EF70                 assume cs:_xdata$x
.xdata$x:0000EF70                 ;org 0EF70h
.xdata$x:0000EF70 ; COMDAT (pick associative to section at 3ADC)
.xdata$x:0000EF70 __unwindtable$??$_Debug_range@V?$reverse_iterator@V?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@_W@std@@@std@@@std@@@std@@@std@@YAXV?$reverse_iterator@V?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@_W@std@@@std@@@std@@@0@0PB_WI@Z db 0FFh
.xdata$x:0000EF70                                         ; DATA XREF: .xdata$x:0000EF98o
.xdata$x:0000EF71                 db 0FFh
.xdata$x:0000EF72                 db 0FFh
.xdata$x:0000EF73                 db 0FFh
.xdata$x:0000EF74                 dd offset __unwindfunclet$??$_Debug_range@V?$reverse_iterator@V?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@_W@std@@@std@@@std@@@std@@@std@@YAXV?$reverse_iterator@V?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@_W@std@@@std@@@std@@@0@0PB_WI@Z$0
.xdata$x:0000EF78                 db    0
.xdata$x:0000EF79                 db    0
.xdata$x:0000EF7A                 db    0
.xdata$x:0000EF7B                 db    0
.xdata$x:0000EF7C                 dd offset __unwindfunclet$??$_Debug_range@V?$reverse_iterator@V?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@_W@std@@@std@@@std@@@std@@@std@@YAXV?$reverse_iterator@V?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@_W@std@@@std@@@std@@@0@0PB_WI@Z$1
.xdata$x:0000EF80                 db    1
.xdata$x:0000EF81                 db    0
.xdata$x:0000EF82                 db    0
.xdata$x:0000EF83                 db    0
.xdata$x:0000EF84                 dd offset __unwindfunclet$??$_Debug_range@V?$reverse_iterator@V?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@_W@std@@@std@@@std@@@std@@@std@@YAXV?$reverse_iterator@V?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@_W@std@@@std@@@std@@@0@0PB_WI@Z$2
.xdata$x:0000EF88                 db    2
.xdata$x:0000EF89                 db    0
.xdata$x:0000EF8A                 db    0
.xdata$x:0000EF8B                 db    0
.xdata$x:0000EF8C                 dd offset __unwindfunclet$??$_Debug_range@V?$reverse_iterator@V?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@_W@std@@@std@@@std@@@std@@@std@@YAXV?$reverse_iterator@V?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@_W@std@@@std@@@std@@@0@0PB_WI@Z$3
.xdata$x:0000EF90 __ehfuncinfo$??$_Debug_range@V?$reverse_iterator@V?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@_W@std@@@std@@@std@@@std@@@std@@YAXV?$reverse_iterator@V?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@_W@std@@@std@@@std@@@0@0PB_WI@Z db  22h ; "
.xdata$x:0000EF90                                         ; DATA XREF: __ehhandler$??$_Debug_range@V?$reverse_iterator@V?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@_W@std@@@std@@@std@@@std@@@std@@YAXV?$reverse_iterator@V?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@_W@std@@@std@@@std@@@0@0PB_WI@Z+11o
.xdata$x:0000EF91                 db    5
.xdata$x:0000EF92                 db  93h ; ô
.xdata$x:0000EF93                 db  19h
.xdata$x:0000EF94                 db    4
.xdata$x:0000EF95                 db    0
.xdata$x:0000EF96                 db    0
.xdata$x:0000EF97                 db    0
.xdata$x:0000EF98                 dd offset __unwindtable$??$_Debug_range@V?$reverse_iterator@V?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@_W@std@@@std@@@std@@@std@@@std@@YAXV?$reverse_iterator@V?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@_W@std@@@std@@@std@@@0@0PB_WI@Z
.xdata$x:0000EF9C                 db    0
.xdata$x:0000EF9D                 db    0
.xdata$x:0000EF9E                 db    0
.xdata$x:0000EF9F                 db    0
.xdata$x:0000EFA0                 db    0
.xdata$x:0000EFA1                 db    0
.xdata$x:0000EFA2                 db    0
.xdata$x:0000EFA3                 db    0
.xdata$x:0000EFA4                 db    0
.xdata$x:0000EFA5                 db    0
.xdata$x:0000EFA6                 db    0
.xdata$x:0000EFA7                 db    0
.xdata$x:0000EFA8                 db    0
.xdata$x:0000EFA9                 db    0
.xdata$x:0000EFAA                 db    0
.xdata$x:0000EFAB                 db    0
.xdata$x:0000EFAC                 db    0
.xdata$x:0000EFAD                 db    0
.xdata$x:0000EFAE                 db    0
.xdata$x:0000EFAF                 db    0
.xdata$x:0000EFB0                 db    0
.xdata$x:0000EFB1                 db    0
.xdata$x:0000EFB2                 db    0
.xdata$x:0000EFB3                 db    0
.xdata$x:0000EFB3 _xdata$x        ends
.xdata$x:0000EFB3
.xdata$x:0000EFB4 ; ===========================================================================
.xdata$x:0000EFB4
.xdata$x:0000EFB4 ; Segment type: Pure data
.xdata$x:0000EFB4 ; Segment permissions: Read
.xdata$x:0000EFB4 _xdata$x        segment dword public 'DATA' use32
.xdata$x:0000EFB4                 assume cs:_xdata$x
.xdata$x:0000EFB4                 ;org 0EFB4h
.xdata$x:0000EFB4 ; COMDAT (pick associative to section at 3D84)
.xdata$x:0000EFB4 __unwindtable$??$_Distance@V?$reverse_iterator@V?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@_W@std@@@std@@@std@@@std@@I@std@@YAXV?$reverse_iterator@V?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@_W@std@@@std@@@std@@@0@0AAI@Z db 0FFh
.xdata$x:0000EFB4                                         ; DATA XREF: .xdata$x:0000EFDCo
.xdata$x:0000EFB5                 db 0FFh
.xdata$x:0000EFB6                 db 0FFh
.xdata$x:0000EFB7                 db 0FFh
.xdata$x:0000EFB8                 dd offset __unwindfunclet$??$_Distance@V?$reverse_iterator@V?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@_W@std@@@std@@@std@@@std@@I@std@@YAXV?$reverse_iterator@V?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@_W@std@@@std@@@std@@@0@0AAI@Z$0
.xdata$x:0000EFBC                 align 10h
.xdata$x:0000EFC0                 dd offset __unwindfunclet$??$_Distance@V?$reverse_iterator@V?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@_W@std@@@std@@@std@@@std@@I@std@@YAXV?$reverse_iterator@V?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@_W@std@@@std@@@std@@@0@0AAI@Z$1
.xdata$x:0000EFC4                 db    1
.xdata$x:0000EFC5                 db    0
.xdata$x:0000EFC6                 db    0
.xdata$x:0000EFC7                 db    0
.xdata$x:0000EFC8                 dd offset __unwindfunclet$??$_Distance@V?$reverse_iterator@V?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@_W@std@@@std@@@std@@@std@@I@std@@YAXV?$reverse_iterator@V?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@_W@std@@@std@@@std@@@0@0AAI@Z$2
.xdata$x:0000EFCC                 db    2
.xdata$x:0000EFCD                 db    0
.xdata$x:0000EFCE                 db    0
.xdata$x:0000EFCF                 db    0
.xdata$x:0000EFD0                 dd offset __unwindfunclet$??$_Distance@V?$reverse_iterator@V?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@_W@std@@@std@@@std@@@std@@I@std@@YAXV?$reverse_iterator@V?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@_W@std@@@std@@@std@@@0@0AAI@Z$3
.xdata$x:0000EFD4 __ehfuncinfo$??$_Distance@V?$reverse_iterator@V?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@_W@std@@@std@@@std@@@std@@I@std@@YAXV?$reverse_iterator@V?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@_W@std@@@std@@@std@@@0@0AAI@Z db  22h ; "
.xdata$x:0000EFD4                                         ; DATA XREF: __ehhandler$??$_Distance@V?$reverse_iterator@V?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@_W@std@@@std@@@std@@@std@@I@std@@YAXV?$reverse_iterator@V?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@_W@std@@@std@@@std@@@0@0AAI@Z+11o
.xdata$x:0000EFD5                 db    5
.xdata$x:0000EFD6                 db  93h ; ô
.xdata$x:0000EFD7                 db  19h
.xdata$x:0000EFD8                 db    4
.xdata$x:0000EFD9                 db    0
.xdata$x:0000EFDA                 db    0
.xdata$x:0000EFDB                 db    0
.xdata$x:0000EFDC                 dd offset __unwindtable$??$_Distance@V?$reverse_iterator@V?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@_W@std@@@std@@@std@@@std@@I@std@@YAXV?$reverse_iterator@V?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@_W@std@@@std@@@std@@@0@0AAI@Z
.xdata$x:0000EFE0                 db    0
.xdata$x:0000EFE1                 db    0
.xdata$x:0000EFE2                 db    0
.xdata$x:0000EFE3                 db    0
.xdata$x:0000EFE4                 db    0
.xdata$x:0000EFE5                 db    0
.xdata$x:0000EFE6                 db    0
.xdata$x:0000EFE7                 db    0
.xdata$x:0000EFE8                 db    0
.xdata$x:0000EFE9                 db    0
.xdata$x:0000EFEA                 db    0
.xdata$x:0000EFEB                 db    0
.xdata$x:0000EFEC                 db    0
.xdata$x:0000EFED                 db    0
.xdata$x:0000EFEE                 db    0
.xdata$x:0000EFEF                 db    0
.xdata$x:0000EFF0                 db    0
.xdata$x:0000EFF1                 db    0
.xdata$x:0000EFF2                 db    0
.xdata$x:0000EFF3                 db    0
.xdata$x:0000EFF4                 db    0
.xdata$x:0000EFF5                 db    0
.xdata$x:0000EFF6                 db    0
.xdata$x:0000EFF7                 db    0
.xdata$x:0000EFF7 _xdata$x        ends
.xdata$x:0000EFF7
.xdata$x:0000EFF8 ; ===========================================================================
.xdata$x:0000EFF8
.xdata$x:0000EFF8 ; Segment type: Pure data
.xdata$x:0000EFF8 ; Segment permissions: Read
.xdata$x:0000EFF8 _xdata$x        segment dword public 'DATA' use32
.xdata$x:0000EFF8                 assume cs:_xdata$x
.xdata$x:0000EFF8                 ;org 0EFF8h
.xdata$x:0000EFF8 ; COMDAT (pick associative to section at 37A4)
.xdata$x:0000EFF8 __unwindtable$??$_Debug_range2@V?$_String_iterator@V?$_String_val@U?$_Simple_types@_W@std@@@std@@@std@@@std@@YAXV?$_String_iterator@V?$_String_val@U?$_Simple_types@_W@std@@@std@@@0@0PB_WIUrandom_access_iterator_tag@0@@Z db 0FFh
.xdata$x:0000EFF8                                         ; DATA XREF: .xdata$x:0000F010o
.xdata$x:0000EFF9                 db 0FFh
.xdata$x:0000EFFA                 db 0FFh
.xdata$x:0000EFFB                 db 0FFh
.xdata$x:0000EFFC                 dd offset __unwindfunclet$??$_Debug_range2@V?$_String_iterator@V?$_String_val@U?$_Simple_types@_W@std@@@std@@@std@@@std@@YAXV?$_String_iterator@V?$_String_val@U?$_Simple_types@_W@std@@@std@@@0@0PB_WIUrandom_access_iterator_tag@0@@Z$0
.xdata$x:0000F000                 db    0
.xdata$x:0000F001                 db    0
.xdata$x:0000F002                 db    0
.xdata$x:0000F003                 db    0
.xdata$x:0000F004                 dd offset __unwindfunclet$??$_Debug_range2@V?$_String_iterator@V?$_String_val@U?$_Simple_types@_W@std@@@std@@@std@@@std@@YAXV?$_String_iterator@V?$_String_val@U?$_Simple_types@_W@std@@@std@@@0@0PB_WIUrandom_access_iterator_tag@0@@Z$1
.xdata$x:0000F008 __ehfuncinfo$??$_Debug_range2@V?$_String_iterator@V?$_String_val@U?$_Simple_types@_W@std@@@std@@@std@@@std@@YAXV?$_String_iterator@V?$_String_val@U?$_Simple_types@_W@std@@@std@@@0@0PB_WIUrandom_access_iterator_tag@0@@Z db  22h ; "
.xdata$x:0000F008                                         ; DATA XREF: __ehhandler$??$_Debug_range2@V?$_String_iterator@V?$_String_val@U?$_Simple_types@_W@std@@@std@@@std@@@std@@YAXV?$_String_iterator@V?$_String_val@U?$_Simple_types@_W@std@@@std@@@0@0PB_WIUrandom_access_iterator_tag@0@@Z+11o
.xdata$x:0000F009                 db    5
.xdata$x:0000F00A                 db  93h ; ô
.xdata$x:0000F00B                 db  19h
.xdata$x:0000F00C                 db    2
.xdata$x:0000F00D                 db    0
.xdata$x:0000F00E                 db    0
.xdata$x:0000F00F                 db    0
.xdata$x:0000F010                 dd offset __unwindtable$??$_Debug_range2@V?$_String_iterator@V?$_String_val@U?$_Simple_types@_W@std@@@std@@@std@@@std@@YAXV?$_String_iterator@V?$_String_val@U?$_Simple_types@_W@std@@@std@@@0@0PB_WIUrandom_access_iterator_tag@0@@Z
.xdata$x:0000F014                 db    0
.xdata$x:0000F015                 db    0
.xdata$x:0000F016                 db    0
.xdata$x:0000F017                 db    0
.xdata$x:0000F018                 db    0
.xdata$x:0000F019                 db    0
.xdata$x:0000F01A                 db    0
.xdata$x:0000F01B                 db    0
.xdata$x:0000F01C                 db    0
.xdata$x:0000F01D                 db    0
.xdata$x:0000F01E                 db    0
.xdata$x:0000F01F                 db    0
.xdata$x:0000F020                 db    0
.xdata$x:0000F021                 db    0
.xdata$x:0000F022                 db    0
.xdata$x:0000F023                 db    0
.xdata$x:0000F024                 db    0
.xdata$x:0000F025                 db    0
.xdata$x:0000F026                 db    0
.xdata$x:0000F027                 db    0
.xdata$x:0000F028                 db    0
.xdata$x:0000F029                 db    0
.xdata$x:0000F02A                 db    0
.xdata$x:0000F02B                 db    0
.xdata$x:0000F02B _xdata$x        ends
.xdata$x:0000F02B
.xdata$x:0000F02C ; ===========================================================================
.xdata$x:0000F02C
.xdata$x:0000F02C ; Segment type: Pure data
.xdata$x:0000F02C ; Segment permissions: Read
.xdata$x:0000F02C _xdata$x        segment dword public 'DATA' use32
.xdata$x:0000F02C                 assume cs:_xdata$x
.xdata$x:0000F02C                 ;org 0F02Ch
.xdata$x:0000F02C ; COMDAT (pick associative to section at 41F8)
.xdata$x:0000F02C __unwindtable$??$_Transform1@PA_WV?$_String_iterator@V?$_String_val@U?$_Simple_types@_W@std@@@std@@@std@@P6AHH@Z@std@@YA?AV?$_String_iterator@V?$_String_val@U?$_Simple_types@_W@std@@@std@@@0@PA_W0V10@P6AHH@ZUrandom_access_iterator_tag@0@3@Z db 0FFh
.xdata$x:0000F02C                                         ; DATA XREF: .xdata$x:0000F054o
.xdata$x:0000F02D                 db 0FFh
.xdata$x:0000F02E                 db 0FFh
.xdata$x:0000F02F                 db 0FFh
.xdata$x:0000F030                 dd offset __unwindfunclet$??$_Transform1@PA_WV?$_String_iterator@V?$_String_val@U?$_Simple_types@_W@std@@@std@@@std@@P6AHH@Z@std@@YA?AV?$_String_iterator@V?$_String_val@U?$_Simple_types@_W@std@@@std@@@0@PA_W0V10@P6AHH@ZUrandom_access_iterator_tag@0@3@Z$3
.xdata$x:0000F034                 align 8
.xdata$x:0000F038                 dd offset __unwindfunclet$??$_Transform1@PA_WV?$_String_iterator@V?$_String_val@U?$_Simple_types@_W@std@@@std@@@std@@P6AHH@Z@std@@YA?AV?$_String_iterator@V?$_String_val@U?$_Simple_types@_W@std@@@std@@@0@PA_W0V10@P6AHH@ZUrandom_access_iterator_tag@0@3@Z$0
.xdata$x:0000F03C                 db    1
.xdata$x:0000F03D                 db    0
.xdata$x:0000F03E                 db    0
.xdata$x:0000F03F                 db    0
.xdata$x:0000F040                 dd offset __unwindfunclet$??$_Transform1@PA_WV?$_String_iterator@V?$_String_val@U?$_Simple_types@_W@std@@@std@@@std@@P6AHH@Z@std@@YA?AV?$_String_iterator@V?$_String_val@U?$_Simple_types@_W@std@@@std@@@0@PA_W0V10@P6AHH@ZUrandom_access_iterator_tag@0@3@Z$1
.xdata$x:0000F044                 db    2
.xdata$x:0000F045                 db    0
.xdata$x:0000F046                 db    0
.xdata$x:0000F047                 db    0
.xdata$x:0000F048                 dd offset __unwindfunclet$??$_Transform1@PA_WV?$_String_iterator@V?$_String_val@U?$_Simple_types@_W@std@@@std@@@std@@P6AHH@Z@std@@YA?AV?$_String_iterator@V?$_String_val@U?$_Simple_types@_W@std@@@std@@@0@PA_W0V10@P6AHH@ZUrandom_access_iterator_tag@0@3@Z$2
.xdata$x:0000F04C __ehfuncinfo$??$_Transform1@PA_WV?$_String_iterator@V?$_String_val@U?$_Simple_types@_W@std@@@std@@@std@@P6AHH@Z@std@@YA?AV?$_String_iterator@V?$_String_val@U?$_Simple_types@_W@std@@@std@@@0@PA_W0V10@P6AHH@ZUrandom_access_iterator_tag@0@3@Z db  22h ; "
.xdata$x:0000F04C                                         ; DATA XREF: __ehhandler$??$_Transform1@PA_WV?$_String_iterator@V?$_String_val@U?$_Simple_types@_W@std@@@std@@@std@@P6AHH@Z@std@@YA?AV?$_String_iterator@V?$_String_val@U?$_Simple_types@_W@std@@@std@@@0@PA_W0V10@P6AHH@ZUrandom_access_iterator_tag@0@3@Z+11o
.xdata$x:0000F04D                 db    5
.xdata$x:0000F04E                 db  93h ; ô
.xdata$x:0000F04F                 db  19h
.xdata$x:0000F050                 db    4
.xdata$x:0000F051                 db    0
.xdata$x:0000F052                 db    0
.xdata$x:0000F053                 db    0
.xdata$x:0000F054                 dd offset __unwindtable$??$_Transform1@PA_WV?$_String_iterator@V?$_String_val@U?$_Simple_types@_W@std@@@std@@@std@@P6AHH@Z@std@@YA?AV?$_String_iterator@V?$_String_val@U?$_Simple_types@_W@std@@@std@@@0@PA_W0V10@P6AHH@ZUrandom_access_iterator_tag@0@3@Z
.xdata$x:0000F058                 db    0
.xdata$x:0000F059                 db    0
.xdata$x:0000F05A                 db    0
.xdata$x:0000F05B                 db    0
.xdata$x:0000F05C                 db    0
.xdata$x:0000F05D                 db    0
.xdata$x:0000F05E                 db    0
.xdata$x:0000F05F                 db    0
.xdata$x:0000F060                 db    0
.xdata$x:0000F061                 db    0
.xdata$x:0000F062                 db    0
.xdata$x:0000F063                 db    0
.xdata$x:0000F064                 db    0
.xdata$x:0000F065                 db    0
.xdata$x:0000F066                 db    0
.xdata$x:0000F067                 db    0
.xdata$x:0000F068                 db    0
.xdata$x:0000F069                 db    0
.xdata$x:0000F06A                 db    0
.xdata$x:0000F06B                 db    0
.xdata$x:0000F06C                 db    0
.xdata$x:0000F06D                 db    0
.xdata$x:0000F06E                 db    0
.xdata$x:0000F06F                 db    0
.xdata$x:0000F06F _xdata$x        ends
.xdata$x:0000F06F
.xdata$x:0000F070 ; ===========================================================================
.xdata$x:0000F070
.xdata$x:0000F070 ; Segment type: Pure data
.xdata$x:0000F070 ; Segment permissions: Read
.xdata$x:0000F070 _xdata$x        segment dword public 'DATA' use32
.xdata$x:0000F070                 assume cs:_xdata$x
.xdata$x:0000F070                 ;org 0F070h
.xdata$x:0000F070 ; COMDAT (pick associative to section at 4AF0)
.xdata$x:0000F070 __unwindtable$??$construct@V?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@V12@@?$allocator@V?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@@std@@QAEXPAV?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@1@$$QAV21@@Z db 0FFh
.xdata$x:0000F070                                         ; DATA XREF: .xdata$x:0000F080o
.xdata$x:0000F071                 db 0FFh
.xdata$x:0000F072                 db 0FFh
.xdata$x:0000F073                 db 0FFh
.xdata$x:0000F074                 dd offset __unwindfunclet$??$construct@V?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@V12@@?$allocator@V?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@@std@@QAEXPAV?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@1@$$QAV21@@Z$0
.xdata$x:0000F078 __ehfuncinfo$??$construct@V?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@V12@@?$allocator@V?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@@std@@QAEXPAV?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@1@$$QAV21@@Z db  22h ; "
.xdata$x:0000F078                                         ; DATA XREF: __ehhandler$??$construct@V?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@V12@@?$allocator@V?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@@std@@QAEXPAV?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@1@$$QAV21@@Z+11o
.xdata$x:0000F079                 db    5
.xdata$x:0000F07A                 db  93h ; ô
.xdata$x:0000F07B                 db  19h
.xdata$x:0000F07C                 db    1
.xdata$x:0000F07D                 db    0
.xdata$x:0000F07E                 db    0
.xdata$x:0000F07F                 db    0
.xdata$x:0000F080                 dd offset __unwindtable$??$construct@V?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@V12@@?$allocator@V?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@@std@@QAEXPAV?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@1@$$QAV21@@Z
.xdata$x:0000F084                 db    0
.xdata$x:0000F085                 db    0
.xdata$x:0000F086                 db    0
.xdata$x:0000F087                 db    0
.xdata$x:0000F088                 db    0
.xdata$x:0000F089                 db    0
.xdata$x:0000F08A                 db    0
.xdata$x:0000F08B                 db    0
.xdata$x:0000F08C                 db    0
.xdata$x:0000F08D                 db    0
.xdata$x:0000F08E                 db    0
.xdata$x:0000F08F                 db    0
.xdata$x:0000F090                 db    0
.xdata$x:0000F091                 db    0
.xdata$x:0000F092                 db    0
.xdata$x:0000F093                 db    0
.xdata$x:0000F094                 db    0
.xdata$x:0000F095                 db    0
.xdata$x:0000F096                 db    0
.xdata$x:0000F097                 db    0
.xdata$x:0000F098                 db    0
.xdata$x:0000F099                 db    0
.xdata$x:0000F09A                 db    0
.xdata$x:0000F09B                 db    0
.xdata$x:0000F09B _xdata$x        ends
.xdata$x:0000F09B
.xdata$x:0000F09C ; ===========================================================================
.xdata$x:0000F09C
.xdata$x:0000F09C ; Segment type: Pure data
.xdata$x:0000F09C ; Segment permissions: Read
.xdata$x:0000F09C _xdata$x        segment dword public 'DATA' use32
.xdata$x:0000F09C                 assume cs:_xdata$x
.xdata$x:0000F09C                 ;org 0F09Ch
.xdata$x:0000F09C ; COMDAT (pick associative to section at 4BF0)
.xdata$x:0000F09C __unwindtable$??$construct@_W_W@?$allocator@_W@std@@QAEXPA_W$$QA_W@Z db 0FFh
.xdata$x:0000F09C                                         ; DATA XREF: .xdata$x:0000F0ACo
.xdata$x:0000F09D                 db 0FFh
.xdata$x:0000F09E                 db 0FFh
.xdata$x:0000F09F                 db 0FFh
.xdata$x:0000F0A0                 dd offset __unwindfunclet$??$construct@_W_W@?$allocator@_W@std@@QAEXPA_W$$QA_W@Z$0
.xdata$x:0000F0A4 __ehfuncinfo$??$construct@_W_W@?$allocator@_W@std@@QAEXPA_W$$QA_W@Z db  22h ; "
.xdata$x:0000F0A4                                         ; DATA XREF: __ehhandler$??$construct@_W_W@?$allocator@_W@std@@QAEXPA_W$$QA_W@Z+11o
.xdata$x:0000F0A5                 db    5
.xdata$x:0000F0A6                 db  93h ; ô
.xdata$x:0000F0A7                 db  19h
.xdata$x:0000F0A8                 db    1
.xdata$x:0000F0A9                 db    0
.xdata$x:0000F0AA                 db    0
.xdata$x:0000F0AB                 db    0
.xdata$x:0000F0AC                 dd offset __unwindtable$??$construct@_W_W@?$allocator@_W@std@@QAEXPA_W$$QA_W@Z
.xdata$x:0000F0B0                 db    0
.xdata$x:0000F0B1                 db    0
.xdata$x:0000F0B2                 db    0
.xdata$x:0000F0B3                 db    0
.xdata$x:0000F0B4                 db    0
.xdata$x:0000F0B5                 db    0
.xdata$x:0000F0B6                 db    0
.xdata$x:0000F0B7                 db    0
.xdata$x:0000F0B8                 db    0
.xdata$x:0000F0B9                 db    0
.xdata$x:0000F0BA                 db    0
.xdata$x:0000F0BB                 db    0
.xdata$x:0000F0BC                 db    0
.xdata$x:0000F0BD                 db    0
.xdata$x:0000F0BE                 db    0
.xdata$x:0000F0BF                 db    0
.xdata$x:0000F0C0                 db    0
.xdata$x:0000F0C1                 db    0
.xdata$x:0000F0C2                 db    0
.xdata$x:0000F0C3                 db    0
.xdata$x:0000F0C4                 db    0
.xdata$x:0000F0C5                 db    0
.xdata$x:0000F0C6                 db    0
.xdata$x:0000F0C7                 db    0
.xdata$x:0000F0C7 _xdata$x        ends
.xdata$x:0000F0C7
.xdata$x:0000F0C8 ; ===========================================================================
.xdata$x:0000F0C8
.xdata$x:0000F0C8 ; Segment type: Pure data
.xdata$x:0000F0C8 ; Segment permissions: Read
.xdata$x:0000F0C8 _xdata$x        segment dword public 'DATA' use32
.xdata$x:0000F0C8                 assume cs:_xdata$x
.xdata$x:0000F0C8                 ;org 0F0C8h
.xdata$x:0000F0C8 ; COMDAT (pick associative to section at 47EC)
.xdata$x:0000F0C8 __unwindtable$??$construct@PADAAPAD@?$allocator@D@std@@QAEXPAPADAAPAD@Z db 0FFh
.xdata$x:0000F0C8                                         ; DATA XREF: .xdata$x:0000F0D8o
.xdata$x:0000F0C9                 db 0FFh
.xdata$x:0000F0CA                 db 0FFh
.xdata$x:0000F0CB                 db 0FFh
.xdata$x:0000F0CC                 dd offset __unwindfunclet$??$construct@PADAAPAD@?$allocator@D@std@@QAEXPAPADAAPAD@Z$0
.xdata$x:0000F0D0 __ehfuncinfo$??$construct@PADAAPAD@?$allocator@D@std@@QAEXPAPADAAPAD@Z db  22h ; "
.xdata$x:0000F0D0                                         ; DATA XREF: __ehhandler$??$construct@PADAAPAD@?$allocator@D@std@@QAEXPAPADAAPAD@Z+11o
.xdata$x:0000F0D1                 db    5
.xdata$x:0000F0D2                 db  93h ; ô
.xdata$x:0000F0D3                 db  19h
.xdata$x:0000F0D4                 db    1
.xdata$x:0000F0D5                 db    0
.xdata$x:0000F0D6                 db    0
.xdata$x:0000F0D7                 db    0
.xdata$x:0000F0D8                 dd offset __unwindtable$??$construct@PADAAPAD@?$allocator@D@std@@QAEXPAPADAAPAD@Z
.xdata$x:0000F0DC                 db    0
.xdata$x:0000F0DD                 db    0
.xdata$x:0000F0DE                 db    0
.xdata$x:0000F0DF                 db    0
.xdata$x:0000F0E0                 db    0
.xdata$x:0000F0E1                 db    0
.xdata$x:0000F0E2                 db    0
.xdata$x:0000F0E3                 db    0
.xdata$x:0000F0E4                 db    0
.xdata$x:0000F0E5                 db    0
.xdata$x:0000F0E6                 db    0
.xdata$x:0000F0E7                 db    0
.xdata$x:0000F0E8                 db    0
.xdata$x:0000F0E9                 db    0
.xdata$x:0000F0EA                 db    0
.xdata$x:0000F0EB                 db    0
.xdata$x:0000F0EC                 db    0
.xdata$x:0000F0ED                 db    0
.xdata$x:0000F0EE                 db    0
.xdata$x:0000F0EF                 db    0
.xdata$x:0000F0F0                 db    0
.xdata$x:0000F0F1                 db    0
.xdata$x:0000F0F2                 db    0
.xdata$x:0000F0F3                 db    0
.xdata$x:0000F0F3 _xdata$x        ends
.xdata$x:0000F0F3
.xdata$x:0000F0F4 ; ===========================================================================
.xdata$x:0000F0F4
.xdata$x:0000F0F4 ; Segment type: Pure data
.xdata$x:0000F0F4 ; Segment permissions: Read
.xdata$x:0000F0F4 _xdata$x        segment dword public 'DATA' use32
.xdata$x:0000F0F4                 assume cs:_xdata$x
.xdata$x:0000F0F4                 ;org 0F0F4h
.xdata$x:0000F0F4 ; COMDAT (pick associative to section at 48EC)
.xdata$x:0000F0F4 __unwindtable$??$construct@PA_WAAPA_W@?$allocator@_W@std@@QAEXPAPA_WAAPA_W@Z db 0FFh
.xdata$x:0000F0F4                                         ; DATA XREF: .xdata$x:0000F104o
.xdata$x:0000F0F5                 db 0FFh
.xdata$x:0000F0F6                 db 0FFh
.xdata$x:0000F0F7                 db 0FFh
.xdata$x:0000F0F8                 dd offset __unwindfunclet$??$construct@PA_WAAPA_W@?$allocator@_W@std@@QAEXPAPA_WAAPA_W@Z$0
.xdata$x:0000F0FC __ehfuncinfo$??$construct@PA_WAAPA_W@?$allocator@_W@std@@QAEXPAPA_WAAPA_W@Z db  22h ; "
.xdata$x:0000F0FC                                         ; DATA XREF: __ehhandler$??$construct@PA_WAAPA_W@?$allocator@_W@std@@QAEXPAPA_WAAPA_W@Z+11o
.xdata$x:0000F0FD                 db    5
.xdata$x:0000F0FE                 db  93h ; ô
.xdata$x:0000F0FF                 db  19h
.xdata$x:0000F100                 db    1
.xdata$x:0000F101                 db    0
.xdata$x:0000F102                 db    0
.xdata$x:0000F103                 db    0
.xdata$x:0000F104                 dd offset __unwindtable$??$construct@PA_WAAPA_W@?$allocator@_W@std@@QAEXPAPA_WAAPA_W@Z
.xdata$x:0000F108                 align 20h
.xdata$x:0000F108 _xdata$x        ends
.xdata$x:0000F108
.xdata$x:0000F120 ; ===========================================================================
.xdata$x:0000F120
.xdata$x:0000F120 ; Segment type: Pure data
.xdata$x:0000F120 ; Segment permissions: Read
.xdata$x:0000F120 _xdata$x        segment dword public 'DATA' use32
.xdata$x:0000F120                 assume cs:_xdata$x
.xdata$x:0000F120                 ;org 0F120h
.xdata$x:0000F120 ; COMDAT (pick associative to section at 3888)
.xdata$x:0000F120 __unwindtable$??$_Debug_range2@V?$reverse_iterator@V?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@_W@std@@@std@@@std@@@std@@@std@@YAXV?$reverse_iterator@V?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@_W@std@@@std@@@std@@@0@0PB_WIUrandom_access_iterator_tag@0@@Z db 0FFh
.xdata$x:0000F120                                         ; DATA XREF: .xdata$x:0000F138o
.xdata$x:0000F121                 db 0FFh
.xdata$x:0000F122                 db 0FFh
.xdata$x:0000F123                 db 0FFh
.xdata$x:0000F124                 dd offset __unwindfunclet$??$_Debug_range2@V?$reverse_iterator@V?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@_W@std@@@std@@@std@@@std@@@std@@YAXV?$reverse_iterator@V?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@_W@std@@@std@@@std@@@0@0PB_WIUrandom_access_iterator_tag@0@@Z$0
.xdata$x:0000F128                 db    0
.xdata$x:0000F129                 db    0
.xdata$x:0000F12A                 db    0
.xdata$x:0000F12B                 db    0
.xdata$x:0000F12C                 dd offset __unwindfunclet$??$_Debug_range2@V?$reverse_iterator@V?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@_W@std@@@std@@@std@@@std@@@std@@YAXV?$reverse_iterator@V?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@_W@std@@@std@@@std@@@0@0PB_WIUrandom_access_iterator_tag@0@@Z$1
.xdata$x:0000F130 __ehfuncinfo$??$_Debug_range2@V?$reverse_iterator@V?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@_W@std@@@std@@@std@@@std@@@std@@YAXV?$reverse_iterator@V?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@_W@std@@@std@@@std@@@0@0PB_WIUrandom_access_iterator_tag@0@@Z db  22h ; "
.xdata$x:0000F130                                         ; DATA XREF: __ehhandler$??$_Debug_range2@V?$reverse_iterator@V?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@_W@std@@@std@@@std@@@std@@@std@@YAXV?$reverse_iterator@V?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@_W@std@@@std@@@std@@@0@0PB_WIUrandom_access_iterator_tag@0@@Z+11o
.xdata$x:0000F131                 db    5
.xdata$x:0000F132                 db  93h ; ô
.xdata$x:0000F133                 db  19h
.xdata$x:0000F134                 db    2
.xdata$x:0000F135                 db    0
.xdata$x:0000F136                 db    0
.xdata$x:0000F137                 db    0
.xdata$x:0000F138                 dd offset __unwindtable$??$_Debug_range2@V?$reverse_iterator@V?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@_W@std@@@std@@@std@@@std@@@std@@YAXV?$reverse_iterator@V?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@_W@std@@@std@@@std@@@0@0PB_WIUrandom_access_iterator_tag@0@@Z
.xdata$x:0000F13C                 db    0
.xdata$x:0000F13D                 db    0
.xdata$x:0000F13E                 db    0
.xdata$x:0000F13F                 db    0
.xdata$x:0000F140                 db    0
.xdata$x:0000F141                 db    0
.xdata$x:0000F142                 db    0
.xdata$x:0000F143                 db    0
.xdata$x:0000F144                 db    0
.xdata$x:0000F145                 db    0
.xdata$x:0000F146                 db    0
.xdata$x:0000F147                 db    0
.xdata$x:0000F148                 db    0
.xdata$x:0000F149                 db    0
.xdata$x:0000F14A                 db    0
.xdata$x:0000F14B                 db    0
.xdata$x:0000F14C                 db    0
.xdata$x:0000F14D                 db    0
.xdata$x:0000F14E                 db    0
.xdata$x:0000F14F                 db    0
.xdata$x:0000F150                 db    0
.xdata$x:0000F151                 db    0
.xdata$x:0000F152                 db    0
.xdata$x:0000F153                 db    0
.xdata$x:0000F153 _xdata$x        ends
.xdata$x:0000F153
.xdata$x:0000F154 ; ===========================================================================
.xdata$x:0000F154
.xdata$x:0000F154 ; Segment type: Pure data
.xdata$x:0000F154 ; Segment permissions: Read
.xdata$x:0000F154 _xdata$x        segment dword public 'DATA' use32
.xdata$x:0000F154                 assume cs:_xdata$x
.xdata$x:0000F154                 ;org 0F154h
.xdata$x:0000F154 ; COMDAT (pick associative to section at 3CA8)
.xdata$x:0000F154 __unwindtable$??$_Distance2@V?$reverse_iterator@V?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@_W@std@@@std@@@std@@@std@@I@std@@YAXV?$reverse_iterator@V?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@_W@std@@@std@@@std@@@0@0AAIUrandom_access_iterator_tag@0@@Z db 0FFh
.xdata$x:0000F154                                         ; DATA XREF: .xdata$x:0000F16Co
.xdata$x:0000F155                 db 0FFh
.xdata$x:0000F156                 db 0FFh
.xdata$x:0000F157                 db 0FFh
.xdata$x:0000F158                 dd offset __unwindfunclet$??$_Distance2@V?$reverse_iterator@V?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@_W@std@@@std@@@std@@@std@@I@std@@YAXV?$reverse_iterator@V?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@_W@std@@@std@@@std@@@0@0AAIUrandom_access_iterator_tag@0@@Z$0
.xdata$x:0000F15C                 align 10h
.xdata$x:0000F160                 dd offset __unwindfunclet$??$_Distance2@V?$reverse_iterator@V?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@_W@std@@@std@@@std@@@std@@I@std@@YAXV?$reverse_iterator@V?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@_W@std@@@std@@@std@@@0@0AAIUrandom_access_iterator_tag@0@@Z$1
.xdata$x:0000F164 __ehfuncinfo$??$_Distance2@V?$reverse_iterator@V?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@_W@std@@@std@@@std@@@std@@I@std@@YAXV?$reverse_iterator@V?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@_W@std@@@std@@@std@@@0@0AAIUrandom_access_iterator_tag@0@@Z db  22h ; "
.xdata$x:0000F164                                         ; DATA XREF: __ehhandler$??$_Distance2@V?$reverse_iterator@V?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@_W@std@@@std@@@std@@@std@@I@std@@YAXV?$reverse_iterator@V?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@_W@std@@@std@@@std@@@0@0AAIUrandom_access_iterator_tag@0@@Z+11o
.xdata$x:0000F165                 db    5
.xdata$x:0000F166                 db  93h ; ô
.xdata$x:0000F167                 db  19h
.xdata$x:0000F168                 db    2
.xdata$x:0000F169                 db    0
.xdata$x:0000F16A                 db    0
.xdata$x:0000F16B                 db    0
.xdata$x:0000F16C                 dd offset __unwindtable$??$_Distance2@V?$reverse_iterator@V?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@_W@std@@@std@@@std@@@std@@I@std@@YAXV?$reverse_iterator@V?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@_W@std@@@std@@@std@@@0@0AAIUrandom_access_iterator_tag@0@@Z
.xdata$x:0000F170                 db    0
.xdata$x:0000F171                 db    0
.xdata$x:0000F172                 db    0
.xdata$x:0000F173                 db    0
.xdata$x:0000F174                 db    0
.xdata$x:0000F175                 db    0
.xdata$x:0000F176                 db    0
.xdata$x:0000F177                 db    0
.xdata$x:0000F178                 db    0
.xdata$x:0000F179                 db    0
.xdata$x:0000F17A                 db    0
.xdata$x:0000F17B                 db    0
.xdata$x:0000F17C                 db    0
.xdata$x:0000F17D                 db    0
.xdata$x:0000F17E                 db    0
.xdata$x:0000F17F                 db    0
.xdata$x:0000F180                 db    0
.xdata$x:0000F181                 db    0
.xdata$x:0000F182                 db    0
.xdata$x:0000F183                 db    0
.xdata$x:0000F184                 db    0
.xdata$x:0000F185                 db    0
.xdata$x:0000F186                 db    0
.xdata$x:0000F187                 db    0
.xdata$x:0000F187 _xdata$x        ends
.xdata$x:0000F187
.xdata$x:0000F188 ; ===========================================================================
.xdata$x:0000F188
.xdata$x:0000F188 ; Segment type: Pure data
.xdata$x:0000F188 ; Segment permissions: Read
.xdata$x:0000F188 _xdata$x        segment dword public 'DATA' use32
.xdata$x:0000F188                 assume cs:_xdata$x
.xdata$x:0000F188                 ;org 0F188h
.xdata$x:0000F188 ; COMDAT (pick associative to section at 44C8)
.xdata$x:0000F188 __catchsym$??$_Uninit_move@PAV?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@PAV12@V?$allocator@V?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@@2@V12@@std@@YAPAV?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@0@PAV10@00AAU?$_Wrap_alloc@V?$allocator@V?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@@std@@@0@0U_Nonscalar_ptr_iterator_tag@0@@Z$2 db    0
.xdata$x:0000F188                                         ; DATA XREF: .xdata$x:0000F1B8o
.xdata$x:0000F189                 db    0
.xdata$x:0000F18A                 db    0
.xdata$x:0000F18B                 db    0
.xdata$x:0000F18C                 db    0
.xdata$x:0000F18D                 db    0
.xdata$x:0000F18E                 db    0
.xdata$x:0000F18F                 db    0
.xdata$x:0000F190                 db    0
.xdata$x:0000F191                 db    0
.xdata$x:0000F192                 db    0
.xdata$x:0000F193                 db    0
.xdata$x:0000F194                 dd offset __catch$??$_Uninit_move@PAV?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@PAV12@V?$allocator@V?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@@2@V12@@std@@YAPAV?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@0@PAV10@00AAU?$_Wrap_alloc@V?$allocator@V?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@@std@@@0@0U_Nonscalar_ptr_iterator_tag@0@@Z$0
.xdata$x:0000F198 __unwindtable$??$_Uninit_move@PAV?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@PAV12@V?$allocator@V?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@@2@V12@@std@@YAPAV?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@0@PAV10@00AAU?$_Wrap_alloc@V?$allocator@V?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@@std@@@0@0U_Nonscalar_ptr_iterator_tag@0@@Z db 0FFh
.xdata$x:0000F198                                         ; DATA XREF: .xdata$x:0000F1C4o
.xdata$x:0000F199                 db 0FFh
.xdata$x:0000F19A                 db 0FFh
.xdata$x:0000F19B                 db 0FFh
.xdata$x:0000F19C                 db    0
.xdata$x:0000F19D                 db    0
.xdata$x:0000F19E                 db    0
.xdata$x:0000F19F                 db    0
.xdata$x:0000F1A0                 db 0FFh
.xdata$x:0000F1A1                 db 0FFh
.xdata$x:0000F1A2                 db 0FFh
.xdata$x:0000F1A3                 db 0FFh
.xdata$x:0000F1A4                 db    0
.xdata$x:0000F1A5                 db    0
.xdata$x:0000F1A6                 db    0
.xdata$x:0000F1A7                 db    0
.xdata$x:0000F1A8 __tryblocktable$??$_Uninit_move@PAV?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@PAV12@V?$allocator@V?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@@2@V12@@std@@YAPAV?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@0@PAV10@00AAU?$_Wrap_alloc@V?$allocator@V?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@@std@@@0@0U_Nonscalar_ptr_iterator_tag@0@@Z db    0
.xdata$x:0000F1A8                                         ; DATA XREF: .xdata$x:0000F1CCo
.xdata$x:0000F1A9                 db    0
.xdata$x:0000F1AA                 db    0
.xdata$x:0000F1AB                 db    0
.xdata$x:0000F1AC                 db    0
.xdata$x:0000F1AD                 db    0
.xdata$x:0000F1AE                 db    0
.xdata$x:0000F1AF                 db    0
.xdata$x:0000F1B0                 db    1
.xdata$x:0000F1B1                 db    0
.xdata$x:0000F1B2                 db    0
.xdata$x:0000F1B3                 db    0
.xdata$x:0000F1B4                 db    1
.xdata$x:0000F1B5                 db    0
.xdata$x:0000F1B6                 db    0
.xdata$x:0000F1B7                 db    0
.xdata$x:0000F1B8                 dd offset __catchsym$??$_Uninit_move@PAV?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@PAV12@V?$allocator@V?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@@2@V12@@std@@YAPAV?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@0@PAV10@00AAU?$_Wrap_alloc@V?$allocator@V?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@@std@@@0@0U_Nonscalar_ptr_iterator_tag@0@@Z$2
.xdata$x:0000F1BC __ehfuncinfo$??$_Uninit_move@PAV?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@PAV12@V?$allocator@V?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@@2@V12@@std@@YAPAV?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@0@PAV10@00AAU?$_Wrap_alloc@V?$allocator@V?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@@std@@@0@0U_Nonscalar_ptr_iterator_tag@0@@Z db  22h ; "
.xdata$x:0000F1BC                                         ; DATA XREF: __ehhandler$??$_Uninit_move@PAV?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@PAV12@V?$allocator@V?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@@2@V12@@std@@YAPAV?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@0@PAV10@00AAU?$_Wrap_alloc@V?$allocator@V?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@@std@@@0@0U_Nonscalar_ptr_iterator_tag@0@@Z+11o
.xdata$x:0000F1BD                 db    5
.xdata$x:0000F1BE                 db  93h ; ô
.xdata$x:0000F1BF                 db  19h
.xdata$x:0000F1C0                 db    2
.xdata$x:0000F1C1                 db    0
.xdata$x:0000F1C2                 db    0
.xdata$x:0000F1C3                 db    0
.xdata$x:0000F1C4                 dd offset __unwindtable$??$_Uninit_move@PAV?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@PAV12@V?$allocator@V?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@@2@V12@@std@@YAPAV?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@0@PAV10@00AAU?$_Wrap_alloc@V?$allocator@V?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@@std@@@0@0U_Nonscalar_ptr_iterator_tag@0@@Z
.xdata$x:0000F1C8                 db    1
.xdata$x:0000F1C9                 db    0
.xdata$x:0000F1CA                 db    0
.xdata$x:0000F1CB                 db    0
.xdata$x:0000F1CC                 dd offset __tryblocktable$??$_Uninit_move@PAV?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@PAV12@V?$allocator@V?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@@2@V12@@std@@YAPAV?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@0@PAV10@00AAU?$_Wrap_alloc@V?$allocator@V?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@@std@@@0@0U_Nonscalar_ptr_iterator_tag@0@@Z
.xdata$x:0000F1D0                 align 20h
.xdata$x:0000F1D0 _xdata$x        ends
.xdata$x:0000F1D0
.xdata$x:0000F1E0 ; ===========================================================================
.xdata$x:0000F1E0
.xdata$x:0000F1E0 ; Segment type: Pure data
.xdata$x:0000F1E0 ; Segment permissions: Read
.xdata$x:0000F1E0 _xdata$x        segment dword public 'DATA' use32
.xdata$x:0000F1E0                 assume cs:_xdata$x
.xdata$x:0000F1E0                 ;org 0F1E0h
.xdata$x:0000F1E0 ; COMDAT (pick associative to section at 32A8)
.xdata$x:0000F1E0 __unwindtable$??$?GV?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@_W@std@@@std@@@std@@V01@@std@@YAHABV?$reverse_iterator@V?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@_W@std@@@std@@@std@@@0@0@Z db 0FFh
.xdata$x:0000F1E0                                         ; DATA XREF: .xdata$x:0000F1F8o
.xdata$x:0000F1E1                 db 0FFh
.xdata$x:0000F1E2                 db 0FFh
.xdata$x:0000F1E3                 db 0FFh
.xdata$x:0000F1E4                 dd offset __unwindfunclet$??$?GV?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@_W@std@@@std@@@std@@V01@@std@@YAHABV?$reverse_iterator@V?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@_W@std@@@std@@@std@@@0@0@Z$0
.xdata$x:0000F1E8                 db    0
.xdata$x:0000F1E9                 db    0
.xdata$x:0000F1EA                 db    0
.xdata$x:0000F1EB                 db    0
.xdata$x:0000F1EC                 dd offset __unwindfunclet$??$?GV?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@_W@std@@@std@@@std@@V01@@std@@YAHABV?$reverse_iterator@V?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@_W@std@@@std@@@std@@@0@0@Z$1
.xdata$x:0000F1F0 __ehfuncinfo$??$?GV?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@_W@std@@@std@@@std@@V01@@std@@YAHABV?$reverse_iterator@V?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@_W@std@@@std@@@std@@@0@0@Z db  22h ; "
.xdata$x:0000F1F0                                         ; DATA XREF: __ehhandler$??$?GV?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@_W@std@@@std@@@std@@V01@@std@@YAHABV?$reverse_iterator@V?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@_W@std@@@std@@@std@@@0@0@Z+11o
.xdata$x:0000F1F1                 db    5
.xdata$x:0000F1F2                 db  93h ; ô
.xdata$x:0000F1F3                 db  19h
.xdata$x:0000F1F4                 db    2
.xdata$x:0000F1F5                 db    0
.xdata$x:0000F1F6                 db    0
.xdata$x:0000F1F7                 db    0
.xdata$x:0000F1F8                 dd offset __unwindtable$??$?GV?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@_W@std@@@std@@@std@@V01@@std@@YAHABV?$reverse_iterator@V?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@_W@std@@@std@@@std@@@0@0@Z
.xdata$x:0000F1FC                 db    0
.xdata$x:0000F1FD                 db    0
.xdata$x:0000F1FE                 db    0
.xdata$x:0000F1FF                 db    0
.xdata$x:0000F200                 db    0
.xdata$x:0000F201                 db    0
.xdata$x:0000F202                 db    0
.xdata$x:0000F203                 db    0
.xdata$x:0000F204                 db    0
.xdata$x:0000F205                 db    0
.xdata$x:0000F206                 db    0
.xdata$x:0000F207                 db    0
.xdata$x:0000F208                 db    0
.xdata$x:0000F209                 db    0
.xdata$x:0000F20A                 db    0
.xdata$x:0000F20B                 db    0
.xdata$x:0000F20C                 db    0
.xdata$x:0000F20D                 db    0
.xdata$x:0000F20E                 db    0
.xdata$x:0000F20F                 db    0
.xdata$x:0000F210                 db    0
.xdata$x:0000F211                 db    0
.xdata$x:0000F212                 db    0
.xdata$x:0000F213                 db    0
.xdata$x:0000F213 _xdata$x        ends
.xdata$x:0000F213
.xdata$x:0000F214 ; ===========================================================================
.xdata$x:0000F214
.xdata$x:0000F214 ; Segment type: Pure data
.xdata$x:0000F214 ; Segment permissions: Read
.xdata$x:0000F214 _xdata$x        segment dword public 'DATA' use32
.xdata$x:0000F214                 assume cs:_xdata$x
.xdata$x:0000F214                 ;org 0F214h
.xdata$x:0000F214 ; COMDAT (pick associative to section at 3E78)
.xdata$x:0000F214 __unwindtable$??$_Equal@V?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@_W@std@@@std@@@std@@U?$iterator@Urandom_access_iterator_tag@std@@_WHPA_WAA_W@2@@?$_Revranit@V?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@_W@std@@@std@@@std@@U?$iterator@Urandom_access_iterator_tag@std@@_WHPA_WAA_W@2@@std@@QBE_NABV01@@Z db 0FFh
.xdata$x:0000F214                                         ; DATA XREF: .xdata$x:0000F224o
.xdata$x:0000F215                 db 0FFh
.xdata$x:0000F216                 db 0FFh
.xdata$x:0000F217                 db 0FFh
.xdata$x:0000F218                 dd offset __unwindfunclet$??$_Equal@V?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@_W@std@@@std@@@std@@U?$iterator@Urandom_access_iterator_tag@std@@_WHPA_WAA_W@2@@?$_Revranit@V?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@_W@std@@@std@@@std@@U?$iterator@Urandom_access_iterator_tag@std@@_WHPA_WAA_W@2@@std@@QBE_NABV01@@Z$0
.xdata$x:0000F21C __ehfuncinfo$??$_Equal@V?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@_W@std@@@std@@@std@@U?$iterator@Urandom_access_iterator_tag@std@@_WHPA_WAA_W@2@@?$_Revranit@V?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@_W@std@@@std@@@std@@U?$iterator@Urandom_access_iterator_tag@std@@_WHPA_WAA_W@2@@std@@QBE_NABV01@@Z db  22h ; "
.xdata$x:0000F21C                                         ; DATA XREF: __ehhandler$??$_Equal@V?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@_W@std@@@std@@@std@@U?$iterator@Urandom_access_iterator_tag@std@@_WHPA_WAA_W@2@@?$_Revranit@V?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@_W@std@@@std@@@std@@U?$iterator@Urandom_access_iterator_tag@std@@_WHPA_WAA_W@2@@std@@QBE_NABV01@@Z+11o
.xdata$x:0000F21D                 db    5
.xdata$x:0000F21E                 db  93h ; ô
.xdata$x:0000F21F                 db  19h
.xdata$x:0000F220                 db    1
.xdata$x:0000F221                 db    0
.xdata$x:0000F222                 db    0
.xdata$x:0000F223                 db    0
.xdata$x:0000F224                 dd offset __unwindtable$??$_Equal@V?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@_W@std@@@std@@@std@@U?$iterator@Urandom_access_iterator_tag@std@@_WHPA_WAA_W@2@@?$_Revranit@V?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@_W@std@@@std@@@std@@U?$iterator@Urandom_access_iterator_tag@std@@_WHPA_WAA_W@2@@std@@QBE_NABV01@@Z
.xdata$x:0000F228                 align 20h
.xdata$x:0000F228 _xdata$x        ends
.xdata$x:0000F228
.xdata$x:0000F240 ; ===========================================================================
.xdata$x:0000F240
.xdata$x:0000F240 ; Segment type: Pure data
.xdata$x:0000F240 ; Segment permissions: Read
.xdata$x:0000F240 _xdata$x        segment dword public 'DATA' use32
.xdata$x:0000F240                 assume cs:_xdata$x
.xdata$x:0000F240                 ;org 0F240h
.xdata$x:0000F240 ; COMDAT (pick associative to section at 4010)
.xdata$x:0000F240 __unwindtable$??$_Less@V?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@_W@std@@@std@@@std@@U?$iterator@Urandom_access_iterator_tag@std@@_WHPA_WAA_W@2@@?$_Revranit@V?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@_W@std@@@std@@@std@@U?$iterator@Urandom_access_iterator_tag@std@@_WHPA_WAA_W@2@@std@@QBE_NABV01@@Z db 0FFh
.xdata$x:0000F240                                         ; DATA XREF: .xdata$x:0000F250o
.xdata$x:0000F241                 db 0FFh
.xdata$x:0000F242                 db 0FFh
.xdata$x:0000F243                 db 0FFh
.xdata$x:0000F244                 dd offset __unwindfunclet$??$_Less@V?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@_W@std@@@std@@@std@@U?$iterator@Urandom_access_iterator_tag@std@@_WHPA_WAA_W@2@@?$_Revranit@V?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@_W@std@@@std@@@std@@U?$iterator@Urandom_access_iterator_tag@std@@_WHPA_WAA_W@2@@std@@QBE_NABV01@@Z$0
.xdata$x:0000F248 __ehfuncinfo$??$_Less@V?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@_W@std@@@std@@@std@@U?$iterator@Urandom_access_iterator_tag@std@@_WHPA_WAA_W@2@@?$_Revranit@V?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@_W@std@@@std@@@std@@U?$iterator@Urandom_access_iterator_tag@std@@_WHPA_WAA_W@2@@std@@QBE_NABV01@@Z db  22h ; "
.xdata$x:0000F248                                         ; DATA XREF: __ehhandler$??$_Less@V?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@_W@std@@@std@@@std@@U?$iterator@Urandom_access_iterator_tag@std@@_WHPA_WAA_W@2@@?$_Revranit@V?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@_W@std@@@std@@@std@@U?$iterator@Urandom_access_iterator_tag@std@@_WHPA_WAA_W@2@@std@@QBE_NABV01@@Z+11o
.xdata$x:0000F249                 db    5
.xdata$x:0000F24A                 db  93h ; ô
.xdata$x:0000F24B                 db  19h
.xdata$x:0000F24C                 db    1
.xdata$x:0000F24D                 db    0
.xdata$x:0000F24E                 db    0
.xdata$x:0000F24F                 db    0
.xdata$x:0000F250                 dd offset __unwindtable$??$_Less@V?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@_W@std@@@std@@@std@@U?$iterator@Urandom_access_iterator_tag@std@@_WHPA_WAA_W@2@@?$_Revranit@V?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@_W@std@@@std@@@std@@U?$iterator@Urandom_access_iterator_tag@std@@_WHPA_WAA_W@2@@std@@QBE_NABV01@@Z
.xdata$x:0000F254                 db    0
.xdata$x:0000F255                 db    0
.xdata$x:0000F256                 db    0
.xdata$x:0000F257                 db    0
.xdata$x:0000F258                 db    0
.xdata$x:0000F259                 db    0
.xdata$x:0000F25A                 db    0
.xdata$x:0000F25B                 db    0
.xdata$x:0000F25C                 db    0
.xdata$x:0000F25D                 db    0
.xdata$x:0000F25E                 db    0
.xdata$x:0000F25F                 db    0
.xdata$x:0000F260                 db    0
.xdata$x:0000F261                 db    0
.xdata$x:0000F262                 db    0
.xdata$x:0000F263                 db    0
.xdata$x:0000F264                 db    0
.xdata$x:0000F265                 db    0
.xdata$x:0000F266                 db    0
.xdata$x:0000F267                 db    0
.xdata$x:0000F268                 db    0
.xdata$x:0000F269                 db    0
.xdata$x:0000F26A                 db    0
.xdata$x:0000F26B                 db    0
.xdata$x:0000F26B _xdata$x        ends
.xdata$x:0000F26B
.bss:0000F26C ; ===========================================================================
.bss:0000F26C
.bss:0000F26C ; Segment type: Uninitialized
.bss:0000F26C ; Segment permissions: Read/Write
.bss:0000F26C _bss            segment dword public 'BSS' use32
.bss:0000F26C                 assume cs:_bss
.bss:0000F26C                 ;org 0F26Ch
.bss:0000F26C                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.bss:0000F26C _allocator_arg  db    ? ;
.bss:0000F26D _piecewise_construct db    ? ;
.bss:0000F26E                 db    ? ;
.bss:0000F26F                 db    ? ;
.bss:0000F270                 public ?_pSelf@WcharMbcsConvertor@@1PAV1@A
.bss:0000F270 ; protected: static class WcharMbcsConvertor * WcharMbcsConvertor::_pSelf
.bss:0000F270 ?_pSelf@WcharMbcsConvertor@@1PAV1@A dd ?
.bss:0000F270                                         ; DATA XREF: `dynamic initializer for 'WcharMbcsConvertor * WcharMbcsConvertor::_pSelf''(void)+63w
.bss:0000F270 _bss            ends
.bss:0000F270
.rdata:0000F274 ; ===========================================================================
.rdata:0000F274
.rdata:0000F274 ; Segment type: Pure data
.rdata:0000F274 ; Segment permissions: Read
.rdata:0000F274 ; Segment alignment 'qword' can not be represented in assembly
.rdata:0000F274 _rdata          segment para public 'DATA' use32
.rdata:0000F274                 assume cs:_rdata
.rdata:0000F274                 ;org 0F274h
.rdata:0000F274 ; COMDAT (pick any)
.rdata:0000F274                 public ??_C@_1JA@EADLBAJ@?$AAC?$AA?3?$AA?2?$AAP?$AAr?$AAo?$AAg?$AAr?$AAa?$AAm?$AA?5?$AAF?$AAi?$AAl?$AAe?$AAs?$AA?5?$AA?$CI?$AAx?$AA8?$AA6?$AA?$CJ?$AA?2?$AAM?$AAi?$AAc?$AAr?$AAo?$AAs?$AAo?$AAf?$AAt@
.rdata:0000F274 ; wchar_t `string'
.rdata:0000F274 ??_C@_1JA@EADLBAJ@?$AAC?$AA?3?$AA?2?$AAP?$AAr?$AAo?$AAg?$AAr?$AAa?$AAm?$AA?5?$AAF?$AAi?$AAl?$AAe?$AAs?$AA?5?$AA?$CI?$AAx?$AA8?$AA6?$AA?$CJ?$AA?2?$AAM?$AAi?$AAc?$AAr?$AAo?$AAs?$AAo?$AAf?$AAt@:
.rdata:0000F274                                         ; DATA XREF: std::_Distance2<std::reverse_iterator<std::_Vector_iterator<std::_Vector_val<std::_Simple_types<wchar_t>>>>,uint>(std::reverse_iterator<std::_Vector_iterator<std::_Vector_val<std::_Simple_types<wchar_t>>>>,std::reverse_iterator<std::_Vector_iterator<std::_Vector_val<std::_Simple_types<wchar_t>>>>,uint &,std::random_access_iterator_tag)+45o
.rdata:0000F274                                         ; std::_Distance2<std::reverse_iterator<std::_Vector_iterator<std::_Vector_val<std::_Simple_types<wchar_t>>>>,uint>(std::reverse_iterator<std::_Vector_iterator<std::_Vector_val<std::_Simple_types<wchar_t>>>>,std::reverse_iterator<std::_Vector_iterator<std::_Vector_val<std::_Simple_types<wchar_t>>>>,uint &,std::random_access_iterator_tag)+5Bo ...
.rdata:0000F274                 unicode 0, <C:\Program Files (x86)\Microsoft Visual Studio 12.0\VC\in>
.rdata:0000F274                 unicode 0, <clude\xutility>,0
.rdata:0000F274 _rdata          ends
.rdata:0000F274
.rdata:0000F304 ; ===========================================================================
.rdata:0000F304
.rdata:0000F304 ; Segment type: Pure data
.rdata:0000F304 ; Segment permissions: Read
.rdata:0000F304 _rdata          segment dword public 'DATA' use32
.rdata:0000F304                 assume cs:_rdata
.rdata:0000F304                 ;org 0F304h
.rdata:0000F304 ; COMDAT (pick any)
.rdata:0000F304                 public ??_C@_1DC@POOIKBAO@?$AAI?$AAT?$AAE?$AAR?$AAA?$AAT?$AAO?$AAR?$AA?5?$AAL?$AAI?$AAS?$AAT?$AA?5?$AAC?$AAO?$AAR?$AAR?$AAU?$AAP?$AAT?$AAE?$AAD?$AA?$CB?$AA?$AA@
.rdata:0000F304 ; wchar_t `string'
.rdata:0000F304 ??_C@_1DC@POOIKBAO@?$AAI?$AAT?$AAE?$AAR?$AAA?$AAT?$AAO?$AAR?$AA?5?$AAL?$AAI?$AAS?$AAT?$AA?5?$AAC?$AAO?$AAR?$AAR?$AAU?$AAP?$AAT?$AAE?$AAD?$AA?$CB?$AA?$AA@:
.rdata:0000F304                                         ; DATA XREF: std::_Iterator_base12::_Orphan_me(void)+4Do
.rdata:0000F304                 unicode 0, <ITERATOR LIST CORRUPTED!>,0
.rdata:0000F336                 align 4
.rdata:0000F336 _rdata          ends
.rdata:0000F336
.rdata:0000F338 ; ===========================================================================
.rdata:0000F338
.rdata:0000F338 ; Segment type: Pure data
.rdata:0000F338 ; Segment permissions: Read
.rdata:0000F338 _rdata          segment dword public 'DATA' use32
.rdata:0000F338                 assume cs:_rdata
.rdata:0000F338                 ;org 0F338h
.rdata:0000F338 ; COMDAT (pick largest)
.rdata:0000F338                 dd offset ??_R4logic_error@std@@6B@ ; const std::logic_error::`RTTI Complete Object Locator'
.rdata:0000F33C                 public ??_7logic_error@std@@6B@
.rdata:0000F33C ; const std::logic_error::`vftable'
.rdata:0000F33C ??_7logic_error@std@@6B@ dd offset ??_Elogic_error@std@@UAEPAXI@Z
.rdata:0000F33C                                         ; DATA XREF: std::logic_error::logic_error(char const *)+3Co
.rdata:0000F33C                                         ; std::logic_error::`vector deleting destructor'(uint)
.rdata:0000F340                 dd offset ?what@exception@std@@UBEPBDXZ ; std::exception::what(void)
.rdata:0000F340 _rdata          ends
.rdata:0000F340
.rdata:0000F344 ; ===========================================================================
.rdata:0000F344
.rdata:0000F344 ; Segment type: Pure data
.rdata:0000F344 ; Segment permissions: Read
.rdata:0000F344 _rdata          segment dword public 'DATA' use32
.rdata:0000F344                 assume cs:_rdata
.rdata:0000F344                 ;org 0F344h
.rdata:0000F344 ; COMDAT (pick any)
.rdata:0000F344                 public ?npos@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@2IB
.rdata:0000F344 ; public: static unsigned int const std::basic_string<char, struct std::char_traits<char>, class std::allocator<char>>::npos
.rdata:0000F344 ?npos@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@2IB dd 0FFFFFFFFh
.rdata:0000F344                                         ; DATA XREF: tokenizeString(std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>> const &,char)+6Fr
.rdata:0000F344                                         ; tokenizeString(std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>> const &,char)+7Ar ...
.rdata:0000F344 _rdata          ends
.rdata:0000F344
.rdata:0000F348 ; ===========================================================================
.rdata:0000F348
.rdata:0000F348 ; Segment type: Pure data
.rdata:0000F348 ; Segment permissions: Read
.rdata:0000F348 _rdata          segment dword public 'DATA' use32
.rdata:0000F348                 assume cs:_rdata
.rdata:0000F348                 ;org 0F348h
.rdata:0000F348 ; COMDAT (pick largest)
.rdata:0000F348                 dd offset ??_R4invalid_argument@std@@6B@ ; const std::invalid_argument::`RTTI Complete Object Locator'
.rdata:0000F34C                 public ??_7invalid_argument@std@@6B@
.rdata:0000F34C ; const std::invalid_argument::`vftable'
.rdata:0000F34C ??_7invalid_argument@std@@6B@ dd offset ??_Einvalid_argument@std@@UAEPAXI@Z
.rdata:0000F34C                                         ; DATA XREF: std::invalid_argument::invalid_argument(char const *)+3Co
.rdata:0000F34C                                         ; std::invalid_argument::`vector deleting destructor'(uint)
.rdata:0000F350                 dd offset ?what@exception@std@@UBEPBDXZ ; std::exception::what(void)
.rdata:0000F350 _rdata          ends
.rdata:0000F350
.rdata:0000F354 ; ===========================================================================
.rdata:0000F354
.rdata:0000F354 ; Segment type: Pure data
.rdata:0000F354 ; Segment permissions: Read
.rdata:0000F354 _rdata          segment dword public 'DATA' use32
.rdata:0000F354                 assume cs:_rdata
.rdata:0000F354                 ;org 0F354h
.rdata:0000F354 ; COMDAT (pick largest)
.rdata:0000F354                 dd offset ??_R4out_of_range@std@@6B@ ; const std::out_of_range::`RTTI Complete Object Locator'
.rdata:0000F358                 public ??_7out_of_range@std@@6B@
.rdata:0000F358 ; const std::out_of_range::`vftable'
.rdata:0000F358 ??_7out_of_range@std@@6B@ dd offset ??_Eout_of_range@std@@UAEPAXI@Z
.rdata:0000F358                                         ; DATA XREF: std::out_of_range::out_of_range(char const *)+3Co
.rdata:0000F358                                         ; std::out_of_range::`vector deleting destructor'(uint)
.rdata:0000F35C                 dd offset ?what@exception@std@@UBEPBDXZ ; std::exception::what(void)
.rdata:0000F35C _rdata          ends
.rdata:0000F35C
.data$r:0000F360 ; ===========================================================================
.data$r:0000F360
.data$r:0000F360 ; Segment type: Pure data
.data$r:0000F360 ; Segment permissions: Read/Write
.data$r:0000F360 _data$r         segment dword public 'DATA' use32
.data$r:0000F360                 assume cs:_data$r
.data$r:0000F360                 ;org 0F360h
.data$r:0000F360 ; COMDAT (pick any)
.data$r:0000F360                 public ??_R0?AVexception@std@@@8
.data$r:0000F360 ; class std::exception `RTTI Type Descriptor'
.data$r:0000F360 ??_R0?AVexception@std@@@8 dd offset ??_7type_info@@6B@
.data$r:0000F360                                         ; DATA XREF: .rdata$r:std::exception::`RTTI Base Class Descriptor at (0,-1,0,64)'o
.data$r:0000F360                                         ; const type_info::`vftable'
.data$r:0000F364                 align 8
.data$r:0000F368 a_?avexception@ db '.?AVexception@std@@',0
.data$r:0000F368 _data$r         ends
.data$r:0000F368
.rdata:0000F37C ; ===========================================================================
.rdata:0000F37C
.rdata:0000F37C ; Segment type: Pure data
.rdata:0000F37C ; Segment permissions: Read
.rdata:0000F37C _rdata          segment dword public 'DATA' use32
.rdata:0000F37C                 assume cs:_rdata
.rdata:0000F37C                 ;org 0F37Ch
.rdata:0000F37C ; COMDAT (pick largest)
.rdata:0000F37C                 dd offset ??_R4error_category@std@@6B@ ; const std::error_category::`RTTI Complete Object Locator'
.rdata:0000F380                 public ??_7error_category@std@@6B@
.rdata:0000F380 ; const std::error_category::`vftable'
.rdata:0000F380 ??_7error_category@std@@6B@ dd offset ??_Eerror_category@std@@UAEPAXI@Z
.rdata:0000F380                                         ; DATA XREF: std::error_category::error_category(void)+Ao
.rdata:0000F380                                         ; std::error_category::~error_category(void)+Ao
.rdata:0000F380                                         ; std::error_category::`vector deleting destructor'(uint)
.rdata:0000F384                 dd offset __purecall
.rdata:0000F388                 dd offset __purecall
.rdata:0000F38C                 dd offset ?default_error_condition@error_category@std@@UBE?AVerror_condition@2@H@Z ; std::error_category::default_error_condition(int)
.rdata:0000F390                 dd offset ?equivalent@error_category@std@@UBE_NABVerror_code@2@H@Z ; std::error_category::equivalent(std::error_code const &,int)
.rdata:0000F394                 dd offset ?equivalent@error_category@std@@UBE_NHABVerror_condition@2@@Z ; std::error_category::equivalent(int,std::error_condition const &)
.rdata:0000F394 _rdata          ends
.rdata:0000F394
.rdata:0000F398 ; ===========================================================================
.rdata:0000F398
.rdata:0000F398 ; Segment type: Pure data
.rdata:0000F398 ; Segment permissions: Read
.rdata:0000F398 _rdata          segment dword public 'DATA' use32
.rdata:0000F398                 assume cs:_rdata
.rdata:0000F398                 ;org 0F398h
.rdata:0000F398 ; COMDAT (pick largest)
.rdata:0000F398                 dd offset ??_R4_Generic_error_category@std@@6B@ ; const std::_Generic_error_category::`RTTI Complete Object Locator'
.rdata:0000F39C                 public ??_7_Generic_error_category@std@@6B@
.rdata:0000F39C ; const std::_Generic_error_category::`vftable'
.rdata:0000F39C ??_7_Generic_error_category@std@@6B@ dd offset ??_E_Generic_error_category@std@@UAEPAXI@Z
.rdata:0000F39C                                         ; DATA XREF: std::_Generic_error_category::_Generic_error_category(void)+38o
.rdata:0000F39C                                         ; std::_Generic_error_category::`vector deleting destructor'(uint)
.rdata:0000F3A0                 dd offset ?name@_Generic_error_category@std@@UBEPBDXZ ; std::_Generic_error_category::name(void)
.rdata:0000F3A4                 dd offset ?message@_Generic_error_category@std@@UBE?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@2@H@Z ; std::_Generic_error_category::message(int)
.rdata:0000F3A8                 dd offset ?default_error_condition@error_category@std@@UBE?AVerror_condition@2@H@Z ; std::error_category::default_error_condition(int)
.rdata:0000F3AC                 dd offset ?equivalent@error_category@std@@UBE_NABVerror_code@2@H@Z ; std::error_category::equivalent(std::error_code const &,int)
.rdata:0000F3B0                 dd offset ?equivalent@error_category@std@@UBE_NHABVerror_condition@2@@Z ; std::error_category::equivalent(int,std::error_condition const &)
.rdata:0000F3B0 _rdata          ends
.rdata:0000F3B0
.rdata:0000F3B4 ; ===========================================================================
.rdata:0000F3B4
.rdata:0000F3B4 ; Segment type: Pure data
.rdata:0000F3B4 ; Segment permissions: Read
.rdata:0000F3B4 _rdata          segment dword public 'DATA' use32
.rdata:0000F3B4                 assume cs:_rdata
.rdata:0000F3B4                 ;org 0F3B4h
.rdata:0000F3B4 ; COMDAT (pick any)
.rdata:0000F3B4                 public ??_C@_07DCLBNMLN@generic?$AA@
.rdata:0000F3B4 ; `string'
.rdata:0000F3B4 ??_C@_07DCLBNMLN@generic?$AA@ db 'generic',0
.rdata:0000F3B4                                         ; DATA XREF: std::_Generic_error_category::name(void)+7o
.rdata:0000F3B4 _rdata          ends
.rdata:0000F3B4
.rdata:0000F3BC ; ===========================================================================
.rdata:0000F3BC
.rdata:0000F3BC ; Segment type: Pure data
.rdata:0000F3BC ; Segment permissions: Read
.rdata:0000F3BC _rdata          segment dword public 'DATA' use32
.rdata:0000F3BC                 assume cs:_rdata
.rdata:0000F3BC                 ;org 0F3BCh
.rdata:0000F3BC ; COMDAT (pick any)
.rdata:0000F3BC                 public ??_C@_0O@BFJCFAAK@unknown?5error?$AA@
.rdata:0000F3BC ; `string'
.rdata:0000F3BC ??_C@_0O@BFJCFAAK@unknown?5error?$AA@ db 'unknown error',0
.rdata:0000F3BC                                         ; DATA XREF: std::_Generic_error_category::message(int):loc_C448o
.rdata:0000F3BC                                         ; std::_System_error_category::message(int):loc_C5C4o
.rdata:0000F3CA                 align 4
.rdata:0000F3CA _rdata          ends
.rdata:0000F3CA
.rdata:0000F3CC ; ===========================================================================
.rdata:0000F3CC
.rdata:0000F3CC ; Segment type: Pure data
.rdata:0000F3CC ; Segment permissions: Read
.rdata:0000F3CC _rdata          segment dword public 'DATA' use32
.rdata:0000F3CC                 assume cs:_rdata
.rdata:0000F3CC                 ;org 0F3CCh
.rdata:0000F3CC ; COMDAT (pick largest)
.rdata:0000F3CC                 dd offset ??_R4_Iostream_error_category@std@@6B@ ; const std::_Iostream_error_category::`RTTI Complete Object Locator'
.rdata:0000F3D0                 public ??_7_Iostream_error_category@std@@6B@
.rdata:0000F3D0 ; const std::_Iostream_error_category::`vftable'
.rdata:0000F3D0 ??_7_Iostream_error_category@std@@6B@ dd offset ??_E_Iostream_error_category@std@@UAEPAXI@Z
.rdata:0000F3D0                                         ; DATA XREF: std::_Iostream_error_category::_Iostream_error_category(void)+38o
.rdata:0000F3D0                                         ; std::_Iostream_error_category::`vector deleting destructor'(uint)
.rdata:0000F3D4                 dd offset ?name@_Iostream_error_category@std@@UBEPBDXZ ; std::_Iostream_error_category::name(void)
.rdata:0000F3D8                 dd offset ?message@_Iostream_error_category@std@@UBE?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@2@H@Z ; std::_Iostream_error_category::message(int)
.rdata:0000F3DC                 dd offset ?default_error_condition@error_category@std@@UBE?AVerror_condition@2@H@Z ; std::error_category::default_error_condition(int)
.rdata:0000F3E0                 dd offset ?equivalent@error_category@std@@UBE_NABVerror_code@2@H@Z ; std::error_category::equivalent(std::error_code const &,int)
.rdata:0000F3E4                 dd offset ?equivalent@error_category@std@@UBE_NHABVerror_condition@2@@Z ; std::error_category::equivalent(int,std::error_condition const &)
.rdata:0000F3E4 _rdata          ends
.rdata:0000F3E4
.rdata:0000F3E8 ; ===========================================================================
.rdata:0000F3E8
.rdata:0000F3E8 ; Segment type: Pure data
.rdata:0000F3E8 ; Segment permissions: Read
.rdata:0000F3E8 _rdata          segment dword public 'DATA' use32
.rdata:0000F3E8                 assume cs:_rdata
.rdata:0000F3E8                 ;org 0F3E8h
.rdata:0000F3E8 ; COMDAT (pick any)
.rdata:0000F3E8                 public ??_C@_08LLGCOLLL@iostream?$AA@
.rdata:0000F3E8 ; `string'
.rdata:0000F3E8 ??_C@_08LLGCOLLL@iostream?$AA@ db 'iostream',0
.rdata:0000F3E8                                         ; DATA XREF: std::_Iostream_error_category::name(void)+7o
.rdata:0000F3F1                 align 4
.rdata:0000F3F1 _rdata          ends
.rdata:0000F3F1
.rdata:0000F3F4 ; ===========================================================================
.rdata:0000F3F4
.rdata:0000F3F4 ; Segment type: Pure data
.rdata:0000F3F4 ; Segment permissions: Read
.rdata:0000F3F4 _rdata          segment dword public 'DATA' use32
.rdata:0000F3F4                 assume cs:_rdata
.rdata:0000F3F4                 ;org 0F3F4h
.rdata:0000F3F4 ; COMDAT (pick any)
.rdata:0000F3F4                 public ??_C@_0BG@PADBLCHM@iostream?5stream?5error?$AA@
.rdata:0000F3F4 ; char `string'[]
.rdata:0000F3F4 ??_C@_0BG@PADBLCHM@iostream?5stream?5error?$AA@ db 'iostream stream error',0
.rdata:0000F3F4                                         ; DATA XREF: std::_Iostream_error_category::message(int)+35o
.rdata:0000F40A                 align 4
.rdata:0000F40A _rdata          ends
.rdata:0000F40A
.rdata:0000F40C ; ===========================================================================
.rdata:0000F40C
.rdata:0000F40C ; Segment type: Pure data
.rdata:0000F40C ; Segment permissions: Read
.rdata:0000F40C _rdata          segment dword public 'DATA' use32
.rdata:0000F40C                 assume cs:_rdata
.rdata:0000F40C                 ;org 0F40Ch
.rdata:0000F40C ; COMDAT (pick largest)
.rdata:0000F40C                 dd offset ??_R4_System_error_category@std@@6B@ ; const std::_System_error_category::`RTTI Complete Object Locator'
.rdata:0000F410                 public ??_7_System_error_category@std@@6B@
.rdata:0000F410 ; const std::_System_error_category::`vftable'
.rdata:0000F410 ??_7_System_error_category@std@@6B@ dd offset ??_E_System_error_category@std@@UAEPAXI@Z
.rdata:0000F410                                         ; DATA XREF: std::_System_error_category::_System_error_category(void)+38o
.rdata:0000F410                                         ; std::_System_error_category::`vector deleting destructor'(uint)
.rdata:0000F414                 dd offset ?name@_System_error_category@std@@UBEPBDXZ ; std::_System_error_category::name(void)
.rdata:0000F418                 dd offset ?message@_System_error_category@std@@UBE?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@2@H@Z ; std::_System_error_category::message(int)
.rdata:0000F41C                 dd offset ?default_error_condition@_System_error_category@std@@UBE?AVerror_condition@2@H@Z ; std::_System_error_category::default_error_condition(int)
.rdata:0000F420                 dd offset ?equivalent@error_category@std@@UBE_NABVerror_code@2@H@Z ; std::error_category::equivalent(std::error_code const &,int)
.rdata:0000F424                 dd offset ?equivalent@error_category@std@@UBE_NHABVerror_condition@2@@Z ; std::error_category::equivalent(int,std::error_condition const &)
.rdata:0000F424 _rdata          ends
.rdata:0000F424
.rdata:0000F428 ; ===========================================================================
.rdata:0000F428
.rdata:0000F428 ; Segment type: Pure data
.rdata:0000F428 ; Segment permissions: Read
.rdata:0000F428 _rdata          segment dword public 'DATA' use32
.rdata:0000F428                 assume cs:_rdata
.rdata:0000F428                 ;org 0F428h
.rdata:0000F428 ; COMDAT (pick any)
.rdata:0000F428                 public ??_C@_06FHFOAHML@system?$AA@
.rdata:0000F428 ; `string'
.rdata:0000F428 ??_C@_06FHFOAHML@system?$AA@ db 'system',0
.rdata:0000F428                                         ; DATA XREF: std::_System_error_category::name(void)+7o
.rdata:0000F42F                 align 10h
.rdata:0000F42F _rdata          ends
.rdata:0000F42F
.bss:0000F430 ; ===========================================================================
.bss:0000F430
.bss:0000F430 ; Segment type: Uninitialized
.bss:0000F430 ; Segment permissions: Read/Write
.bss:0000F430 _bss            segment dword public 'BSS' use32
.bss:0000F430                 assume cs:_bss
.bss:0000F430                 ;org 0F430h
.bss:0000F430 ; COMDAT (pick any)
.bss:0000F430                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.bss:0000F430                 public ?_Generic_object@?$_Error_objects@H@std@@2V_Generic_error_category@2@A
.bss:0000F430 ; std::_Generic_error_category std::_Error_objects<int>::_Generic_object
.bss:0000F430 ?_Generic_object@?$_Error_objects@H@std@@2V_Generic_error_category@2@A db    ? ;
.bss:0000F430                                         ; DATA XREF: `dynamic initializer for 'std::_Generic_error_category std::_Error_objects<int>::_Generic_object''(void)+3o
.bss:0000F430                                         ; `dynamic atexit destructor for 'std::_Generic_error_category std::_Error_objects<int>::_Generic_object''(void)+3o ...
.bss:0000F431                 db    ? ;
.bss:0000F432                 db    ? ;
.bss:0000F433                 db    ? ;
.bss:0000F433 _bss            ends
.bss:0000F433
.bss:0000F434 ; ===========================================================================
.bss:0000F434
.bss:0000F434 ; Segment type: Uninitialized
.bss:0000F434 ; Segment permissions: Read/Write
.bss:0000F434 _bss            segment dword public 'BSS' use32
.bss:0000F434                 assume cs:_bss
.bss:0000F434                 ;org 0F434h
.bss:0000F434 ; COMDAT (pick any)
.bss:0000F434                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.bss:0000F434                 public ?_Iostream_object@?$_Error_objects@H@std@@2V_Iostream_error_category@2@A
.bss:0000F434 ; std::_Iostream_error_category std::_Error_objects<int>::_Iostream_object
.bss:0000F434 ?_Iostream_object@?$_Error_objects@H@std@@2V_Iostream_error_category@2@A db    ? ;
.bss:0000F434                                         ; DATA XREF: `dynamic initializer for 'std::_Iostream_error_category std::_Error_objects<int>::_Iostream_object''(void)+3o
.bss:0000F434                                         ; `dynamic atexit destructor for 'std::_Iostream_error_category std::_Error_objects<int>::_Iostream_object''(void)+3o
.bss:0000F435                 db    ? ;
.bss:0000F436                 db    ? ;
.bss:0000F437                 db    ? ;
.bss:0000F437 _bss            ends
.bss:0000F437
.bss:0000F438 ; ===========================================================================
.bss:0000F438
.bss:0000F438 ; Segment type: Uninitialized
.bss:0000F438 ; Segment permissions: Read/Write
.bss:0000F438 _bss            segment dword public 'BSS' use32
.bss:0000F438                 assume cs:_bss
.bss:0000F438                 ;org 0F438h
.bss:0000F438 ; COMDAT (pick any)
.bss:0000F438                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.bss:0000F438                 public ?_System_object@?$_Error_objects@H@std@@2V_System_error_category@2@A
.bss:0000F438 ; std::_System_error_category std::_Error_objects<int>::_System_object
.bss:0000F438 ?_System_object@?$_Error_objects@H@std@@2V_System_error_category@2@A db    ? ;
.bss:0000F438                                         ; DATA XREF: `dynamic initializer for 'std::_System_error_category std::_Error_objects<int>::_System_object''(void)+3o
.bss:0000F438                                         ; `dynamic atexit destructor for 'std::_System_error_category std::_Error_objects<int>::_System_object''(void)+3o ...
.bss:0000F439                 db    ? ;
.bss:0000F43A                 db    ? ;
.bss:0000F43B                 db    ? ;
.bss:0000F43B _bss            ends
.bss:0000F43B
.rdata:0000F43C ; ===========================================================================
.rdata:0000F43C
.rdata:0000F43C ; Segment type: Pure data
.rdata:0000F43C ; Segment permissions: Read
.rdata:0000F43C _rdata          segment dword public 'DATA' use32
.rdata:0000F43C                 assume cs:_rdata
.rdata:0000F43C                 ;org 0F43Ch
.rdata:0000F43C ; COMDAT (pick any)
.rdata:0000F43C                 public ?npos@?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@2IB
.rdata:0000F43C ; public: static unsigned int const std::basic_string<wchar_t, struct std::char_traits<wchar_t>, class std::allocator<wchar_t>>::npos
.rdata:0000F43C ?npos@?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@2IB dd 0FFFFFFFFh
.rdata:0000F43C                                         ; DATA XREF: PathRemoveFileSpecW(std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>> &)+2Cr
.rdata:0000F43C                                         ; PathRemoveFileSpecW(std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>> &)+42r ...
.rdata:0000F43C _rdata          ends
.rdata:0000F43C
.bss:0000F440 ; ===========================================================================
.bss:0000F440
.bss:0000F440 ; Segment type: Uninitialized
.bss:0000F440 ; Segment permissions: Read/Write
.bss:0000F440 _bss            segment dword public 'BSS' use32
.bss:0000F440                 assume cs:_bss
.bss:0000F440                 ;org 0F440h
.bss:0000F440 ; COMDAT (pick any)
.bss:0000F440                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.bss:0000F440                 public ?id@?$num_put@DV?$back_insert_iterator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@std@@2V0locale@2@A
.bss:0000F440 ; std::locale::id std::num_put<char,std::back_insert_iterator<std::basic_string<char,std::char_traits<char>,std::allocator<char>>>>::id
.bss:0000F440 ?id@?$num_put@DV?$back_insert_iterator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@std@@2V0locale@2@A db    ? ;
.bss:0000F440                                         ; DATA XREF: `dynamic initializer for 'std::locale::id std::num_put<char,std::back_insert_iterator<std::basic_string<char,std::char_traits<char>,std::allocator<char>>>>::id''(void)+5o
.bss:0000F441                 db    ? ;
.bss:0000F442                 db    ? ;
.bss:0000F443                 db    ? ;
.bss:0000F443 _bss            ends
.bss:0000F443
.bss:0000F444 ; ===========================================================================
.bss:0000F444
.bss:0000F444 ; Segment type: Uninitialized
.bss:0000F444 ; Segment permissions: Read/Write
.bss:0000F444 _bss            segment dword public 'BSS' use32
.bss:0000F444                 assume cs:_bss
.bss:0000F444                 ;org 0F444h
.bss:0000F444 ; COMDAT (pick any)
.bss:0000F444                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.bss:0000F444                 public ?id@?$num_put@_WV?$back_insert_iterator@V?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@@std@@@std@@2V0locale@2@A
.bss:0000F444 ; std::locale::id std::num_put<wchar_t,std::back_insert_iterator<std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>>>>::id
.bss:0000F444 ?id@?$num_put@_WV?$back_insert_iterator@V?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@@std@@@std@@2V0locale@2@A db    ? ;
.bss:0000F444                                         ; DATA XREF: `dynamic initializer for 'std::locale::id std::num_put<wchar_t,std::back_insert_iterator<std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>>>>::id''(void)+5o
.bss:0000F445                 db    ? ;
.bss:0000F446                 db    ? ;
.bss:0000F447                 db    ? ;
.bss:0000F447 _bss            ends
.bss:0000F447
.rdata:0000F448 ; ===========================================================================
.rdata:0000F448
.rdata:0000F448 ; Segment type: Pure data
.rdata:0000F448 ; Segment permissions: Read
.rdata:0000F448 _rdata          segment dword public 'DATA' use32
.rdata:0000F448                 assume cs:_rdata
.rdata:0000F448                 ;org 0F448h
.rdata:0000F448 ; COMDAT (pick any)
.rdata:0000F448 ; char const * const `int __cdecl Utf8::continuationBytes(unsigned char)'::`2'::_len
.rdata:0000F448 ?_len@?1??continuationBytes@Utf8@@YAHE@Z@4QBDB db 1
.rdata:0000F448                                         ; DATA XREF: Utf8::continuationBytes(uchar)+22r
.rdata:0000F449                 db    1
.rdata:0000F44A                 db    2
.rdata:0000F44B                 db    3
.rdata:0000F44B _rdata          ends
.rdata:0000F44B
.xdata$x:0000F44C ; ===========================================================================
.xdata$x:0000F44C
.xdata$x:0000F44C ; Segment type: Pure data
.xdata$x:0000F44C ; Segment permissions: Read
.xdata$x:0000F44C _xdata$x        segment dword public 'DATA' use32
.xdata$x:0000F44C                 assume cs:_xdata$x
.xdata$x:0000F44C                 ;org 0F44Ch
.xdata$x:0000F44C ; COMDAT (pick any)
.xdata$x:0000F44C                 public __TI4PAVinvalid_argument@std@@
.xdata$x:0000F44C __TI4PAVinvalid_argument@std@@ db    0  ; DATA XREF: stodLocale(std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>> const &,localeinfo_struct *,uint *)+A0o
.xdata$x:0000F44D                 db    0
.xdata$x:0000F44E                 db    0
.xdata$x:0000F44F                 db    0
.xdata$x:0000F450                 db    0
.xdata$x:0000F451                 db    0
.xdata$x:0000F452                 db    0
.xdata$x:0000F453                 db    0
.xdata$x:0000F454                 db    0
.xdata$x:0000F455                 db    0
.xdata$x:0000F456                 db    0
.xdata$x:0000F457                 db    0
.xdata$x:0000F458                 dd offset __CTA4PAVinvalid_argument@std@@
.xdata$x:0000F458 _xdata$x        ends
.xdata$x:0000F458
.xdata$x:0000F45C ; ===========================================================================
.xdata$x:0000F45C
.xdata$x:0000F45C ; Segment type: Pure data
.xdata$x:0000F45C ; Segment permissions: Read
.xdata$x:0000F45C _xdata$x        segment dword public 'DATA' use32
.xdata$x:0000F45C                 assume cs:_xdata$x
.xdata$x:0000F45C                 ;org 0F45Ch
.xdata$x:0000F45C ; COMDAT (pick any)
.xdata$x:0000F45C                 public __CTA4PAVinvalid_argument@std@@
.xdata$x:0000F45C __CTA4PAVinvalid_argument@std@@ db    4 ; DATA XREF: .xdata$x:0000F458o
.xdata$x:0000F45D                 db    0
.xdata$x:0000F45E                 db    0
.xdata$x:0000F45F                 db    0
.xdata$x:0000F460                 dd offset __CT??_R0PAVinvalid_argument@std@@@84
.xdata$x:0000F464                 dd offset __CT??_R0PAVlogic_error@std@@@84
.xdata$x:0000F468                 dd offset __CT??_R0PAVexception@std@@@84
.xdata$x:0000F46C                 dd offset __CT??_R0PAX@84
.xdata$x:0000F46C _xdata$x        ends
.xdata$x:0000F46C
.data$r:0000F470 ; ===========================================================================
.data$r:0000F470
.data$r:0000F470 ; Segment type: Pure data
.data$r:0000F470 ; Segment permissions: Read/Write
.data$r:0000F470 _data$r         segment dword public 'DATA' use32
.data$r:0000F470                 assume cs:_data$r
.data$r:0000F470                 ;org 0F470h
.data$r:0000F470 ; COMDAT (pick any)
.data$r:0000F470                 public ??_R0PAVinvalid_argument@std@@@8
.data$r:0000F470 ; class std::invalid_argument * `RTTI Type Descriptor'
.data$r:0000F470 ??_R0PAVinvalid_argument@std@@@8 dd offset ??_7type_info@@6B@
.data$r:0000F470                                         ; DATA XREF: .xdata$x:0000F498o
.data$r:0000F470                                         ; const type_info::`vftable'
.data$r:0000F474                 align 8
.data$r:0000F478 a_pavinvalid_ar db '.PAVinvalid_argument@std@@',0
.data$r:0000F493                 align 4
.data$r:0000F493 _data$r         ends
.data$r:0000F493
.xdata$x:0000F494 ; ===========================================================================
.xdata$x:0000F494
.xdata$x:0000F494 ; Segment type: Pure data
.xdata$x:0000F494 ; Segment permissions: Read
.xdata$x:0000F494 _xdata$x        segment dword public 'DATA' use32
.xdata$x:0000F494                 assume cs:_xdata$x
.xdata$x:0000F494                 ;org 0F494h
.xdata$x:0000F494 ; COMDAT (pick any)
.xdata$x:0000F494                 public __CT??_R0PAVinvalid_argument@std@@@84
.xdata$x:0000F494 __CT??_R0PAVinvalid_argument@std@@@84 db    1
.xdata$x:0000F494                                         ; DATA XREF: .xdata$x:0000F460o
.xdata$x:0000F495                 db    0
.xdata$x:0000F496                 db    0
.xdata$x:0000F497                 db    0
.xdata$x:0000F498                 dd offset ??_R0PAVinvalid_argument@std@@@8 ; std::invalid_argument * `RTTI Type Descriptor'
.xdata$x:0000F49C                 align 10h
.xdata$x:0000F4A0                 db 0FFh
.xdata$x:0000F4A1                 db 0FFh
.xdata$x:0000F4A2                 db 0FFh
.xdata$x:0000F4A3                 db 0FFh
.xdata$x:0000F4A4                 db    0
.xdata$x:0000F4A5                 db    0
.xdata$x:0000F4A6                 db    0
.xdata$x:0000F4A7                 db    0
.xdata$x:0000F4A8                 db    4
.xdata$x:0000F4A9                 db    0
.xdata$x:0000F4AA                 db    0
.xdata$x:0000F4AB                 db    0
.xdata$x:0000F4AC                 db    0
.xdata$x:0000F4AD                 db    0
.xdata$x:0000F4AE                 db    0
.xdata$x:0000F4AF                 db    0
.xdata$x:0000F4AF _xdata$x        ends
.xdata$x:0000F4AF
.data$r:0000F4B0 ; ===========================================================================
.data$r:0000F4B0
.data$r:0000F4B0 ; Segment type: Pure data
.data$r:0000F4B0 ; Segment permissions: Read/Write
.data$r:0000F4B0 _data$r         segment dword public 'DATA' use32
.data$r:0000F4B0                 assume cs:_data$r
.data$r:0000F4B0                 ;org 0F4B0h
.data$r:0000F4B0 ; COMDAT (pick any)
.data$r:0000F4B0                 public ??_R0PAVlogic_error@std@@@8
.data$r:0000F4B0 ; class std::logic_error * `RTTI Type Descriptor'
.data$r:0000F4B0 ??_R0PAVlogic_error@std@@@8 dd offset ??_7type_info@@6B@
.data$r:0000F4B0                                         ; DATA XREF: .xdata$x:0000F4D4o
.data$r:0000F4B0                                         ; const type_info::`vftable'
.data$r:0000F4B4                 align 8
.data$r:0000F4B8 a_pavlogic_erro db '.PAVlogic_error@std@@',0
.data$r:0000F4CE                 align 10h
.data$r:0000F4CE _data$r         ends
.data$r:0000F4CE
.xdata$x:0000F4D0 ; ===========================================================================
.xdata$x:0000F4D0
.xdata$x:0000F4D0 ; Segment type: Pure data
.xdata$x:0000F4D0 ; Segment permissions: Read
.xdata$x:0000F4D0 _xdata$x        segment dword public 'DATA' use32
.xdata$x:0000F4D0                 assume cs:_xdata$x
.xdata$x:0000F4D0                 ;org 0F4D0h
.xdata$x:0000F4D0 ; COMDAT (pick any)
.xdata$x:0000F4D0                 public __CT??_R0PAVlogic_error@std@@@84
.xdata$x:0000F4D0 __CT??_R0PAVlogic_error@std@@@84 db    1 ; DATA XREF: .xdata$x:0000F464o
.xdata$x:0000F4D0                                         ; .xdata$x:0000F568o
.xdata$x:0000F4D1                 db    0
.xdata$x:0000F4D2                 db    0
.xdata$x:0000F4D3                 db    0
.xdata$x:0000F4D4                 dd offset ??_R0PAVlogic_error@std@@@8 ; std::logic_error * `RTTI Type Descriptor'
.xdata$x:0000F4D8                 db    0
.xdata$x:0000F4D9                 db    0
.xdata$x:0000F4DA                 db    0
.xdata$x:0000F4DB                 db    0
.xdata$x:0000F4DC                 db 0FFh
.xdata$x:0000F4DD                 db 0FFh
.xdata$x:0000F4DE                 db 0FFh
.xdata$x:0000F4DF                 db 0FFh
.xdata$x:0000F4E0                 db    0
.xdata$x:0000F4E1                 db    0
.xdata$x:0000F4E2                 db    0
.xdata$x:0000F4E3                 db    0
.xdata$x:0000F4E4                 db    4
.xdata$x:0000F4E5                 db    0
.xdata$x:0000F4E6                 db    0
.xdata$x:0000F4E7                 db    0
.xdata$x:0000F4E8                 db    0
.xdata$x:0000F4E9                 db    0
.xdata$x:0000F4EA                 db    0
.xdata$x:0000F4EB                 db    0
.xdata$x:0000F4EB _xdata$x        ends
.xdata$x:0000F4EB
.data$r:0000F4EC ; ===========================================================================
.data$r:0000F4EC
.data$r:0000F4EC ; Segment type: Pure data
.data$r:0000F4EC ; Segment permissions: Read/Write
.data$r:0000F4EC _data$r         segment dword public 'DATA' use32
.data$r:0000F4EC                 assume cs:_data$r
.data$r:0000F4EC                 ;org 0F4ECh
.data$r:0000F4EC ; COMDAT (pick any)
.data$r:0000F4EC                 public ??_R0PAVexception@std@@@8
.data$r:0000F4EC ; class std::exception * `RTTI Type Descriptor'
.data$r:0000F4EC ??_R0PAVexception@std@@@8 dd offset ??_7type_info@@6B@
.data$r:0000F4EC                                         ; DATA XREF: .xdata$x:0000F50Co
.data$r:0000F4EC                                         ; const type_info::`vftable'
.data$r:0000F4F0                 db    0
.data$r:0000F4F1                 db    0
.data$r:0000F4F2                 db    0
.data$r:0000F4F3                 db    0
.data$r:0000F4F4                 db  2Eh ; .
.data$r:0000F4F5                 db  50h ; P
.data$r:0000F4F6                 db  41h ; A
.data$r:0000F4F7                 db  56h ; V
.data$r:0000F4F8                 db  65h ; e
.data$r:0000F4F9                 db  78h ; x
.data$r:0000F4FA                 db  63h ; c
.data$r:0000F4FB                 db  65h ; e
.data$r:0000F4FC                 db  70h ; p
.data$r:0000F4FD                 db  74h ; t
.data$r:0000F4FE                 db  69h ; i
.data$r:0000F4FF                 db  6Fh ; o
.data$r:0000F500                 db  6Eh ; n
.data$r:0000F501                 db  40h ; @
.data$r:0000F502                 db  73h ; s
.data$r:0000F503                 db  74h ; t
.data$r:0000F504                 db  64h ; d
.data$r:0000F505                 db  40h ; @
.data$r:0000F506                 db  40h ; @
.data$r:0000F507                 db    0
.data$r:0000F507 _data$r         ends
.data$r:0000F507
.xdata$x:0000F508 ; ===========================================================================
.xdata$x:0000F508
.xdata$x:0000F508 ; Segment type: Pure data
.xdata$x:0000F508 ; Segment permissions: Read
.xdata$x:0000F508 _xdata$x        segment dword public 'DATA' use32
.xdata$x:0000F508                 assume cs:_xdata$x
.xdata$x:0000F508                 ;org 0F508h
.xdata$x:0000F508 ; COMDAT (pick any)
.xdata$x:0000F508                 public __CT??_R0PAVexception@std@@@84
.xdata$x:0000F508 __CT??_R0PAVexception@std@@@84 db    1  ; DATA XREF: .xdata$x:0000F468o
.xdata$x:0000F508                                         ; .xdata$x:0000F56Co
.xdata$x:0000F509                 db    0
.xdata$x:0000F50A                 db    0
.xdata$x:0000F50B                 db    0
.xdata$x:0000F50C                 dd offset ??_R0PAVexception@std@@@8 ; std::exception * `RTTI Type Descriptor'
.xdata$x:0000F510                 db    0
.xdata$x:0000F511                 db    0
.xdata$x:0000F512                 db    0
.xdata$x:0000F513                 db    0
.xdata$x:0000F514                 db 0FFh
.xdata$x:0000F515                 db 0FFh
.xdata$x:0000F516                 db 0FFh
.xdata$x:0000F517                 db 0FFh
.xdata$x:0000F518                 db    0
.xdata$x:0000F519                 db    0
.xdata$x:0000F51A                 db    0
.xdata$x:0000F51B                 db    0
.xdata$x:0000F51C                 db    4
.xdata$x:0000F51D                 db    0
.xdata$x:0000F51E                 db    0
.xdata$x:0000F51F                 db    0
.xdata$x:0000F520                 db    0
.xdata$x:0000F521                 db    0
.xdata$x:0000F522                 db    0
.xdata$x:0000F523                 db    0
.xdata$x:0000F523 _xdata$x        ends
.xdata$x:0000F523
.data$r:0000F524 ; ===========================================================================
.data$r:0000F524
.data$r:0000F524 ; Segment type: Pure data
.data$r:0000F524 ; Segment permissions: Read/Write
.data$r:0000F524 _data$r         segment dword public 'DATA' use32
.data$r:0000F524                 assume cs:_data$r
.data$r:0000F524                 ;org 0F524h
.data$r:0000F524 ; COMDAT (pick any)
.data$r:0000F524                 public ??_R0PAX@8
.data$r:0000F524 ; void * `RTTI Type Descriptor'
.data$r:0000F524 ??_R0PAX@8      dd offset ??_7type_info@@6B@
.data$r:0000F524                                         ; DATA XREF: .xdata$x:0000F538o
.data$r:0000F524                                         ; const type_info::`vftable'
.data$r:0000F528                 db    0
.data$r:0000F529                 db    0
.data$r:0000F52A                 db    0
.data$r:0000F52B                 db    0
.data$r:0000F52C                 db  2Eh ; .
.data$r:0000F52D                 db  50h ; P
.data$r:0000F52E                 db  41h ; A
.data$r:0000F52F                 db  58h ; X
.data$r:0000F530                 db    0
.data$r:0000F531                 align 4
.data$r:0000F531 _data$r         ends
.data$r:0000F531
.xdata$x:0000F534 ; ===========================================================================
.xdata$x:0000F534
.xdata$x:0000F534 ; Segment type: Pure data
.xdata$x:0000F534 ; Segment permissions: Read
.xdata$x:0000F534 _xdata$x        segment dword public 'DATA' use32
.xdata$x:0000F534                 assume cs:_xdata$x
.xdata$x:0000F534                 ;org 0F534h
.xdata$x:0000F534 ; COMDAT (pick any)
.xdata$x:0000F534                 public __CT??_R0PAX@84
.xdata$x:0000F534 __CT??_R0PAX@84 db    1                 ; DATA XREF: .xdata$x:0000F46Co
.xdata$x:0000F534                                         ; .xdata$x:0000F570o
.xdata$x:0000F535                 db    0
.xdata$x:0000F536                 db    0
.xdata$x:0000F537                 db    0
.xdata$x:0000F538                 dd offset ??_R0PAX@8    ; void * `RTTI Type Descriptor'
.xdata$x:0000F53C                 align 10h
.xdata$x:0000F540                 db 0FFh
.xdata$x:0000F541                 db 0FFh
.xdata$x:0000F542                 db 0FFh
.xdata$x:0000F543                 db 0FFh
.xdata$x:0000F544                 db    0
.xdata$x:0000F545                 db    0
.xdata$x:0000F546                 db    0
.xdata$x:0000F547                 db    0
.xdata$x:0000F548                 db    4
.xdata$x:0000F549                 db    0
.xdata$x:0000F54A                 db    0
.xdata$x:0000F54B                 db    0
.xdata$x:0000F54C                 db    0
.xdata$x:0000F54D                 db    0
.xdata$x:0000F54E                 db    0
.xdata$x:0000F54F                 db    0
.xdata$x:0000F54F _xdata$x        ends
.xdata$x:0000F54F
.xdata$x:0000F550 ; ===========================================================================
.xdata$x:0000F550
.xdata$x:0000F550 ; Segment type: Pure data
.xdata$x:0000F550 ; Segment permissions: Read
.xdata$x:0000F550 _xdata$x        segment dword public 'DATA' use32
.xdata$x:0000F550                 assume cs:_xdata$x
.xdata$x:0000F550                 ;org 0F550h
.xdata$x:0000F550 ; COMDAT (pick any)
.xdata$x:0000F550                 public __TI4PAVout_of_range@std@@
.xdata$x:0000F550 __TI4PAVout_of_range@std@@ db    0      ; DATA XREF: stodLocale(std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>> const &,localeinfo_struct *,uint *)+FEo
.xdata$x:0000F551                 db    0
.xdata$x:0000F552                 db    0
.xdata$x:0000F553                 db    0
.xdata$x:0000F554                 db    0
.xdata$x:0000F555                 db    0
.xdata$x:0000F556                 db    0
.xdata$x:0000F557                 db    0
.xdata$x:0000F558                 db    0
.xdata$x:0000F559                 db    0
.xdata$x:0000F55A                 db    0
.xdata$x:0000F55B                 db    0
.xdata$x:0000F55C                 dd offset __CTA4PAVout_of_range@std@@
.xdata$x:0000F55C _xdata$x        ends
.xdata$x:0000F55C
.xdata$x:0000F560 ; ===========================================================================
.xdata$x:0000F560
.xdata$x:0000F560 ; Segment type: Pure data
.xdata$x:0000F560 ; Segment permissions: Read
.xdata$x:0000F560 _xdata$x        segment dword public 'DATA' use32
.xdata$x:0000F560                 assume cs:_xdata$x
.xdata$x:0000F560                 ;org 0F560h
.xdata$x:0000F560 ; COMDAT (pick any)
.xdata$x:0000F560                 public __CTA4PAVout_of_range@std@@
.xdata$x:0000F560 __CTA4PAVout_of_range@std@@ db    4     ; DATA XREF: .xdata$x:0000F55Co
.xdata$x:0000F561                 db    0
.xdata$x:0000F562                 db    0
.xdata$x:0000F563                 db    0
.xdata$x:0000F564                 dd offset __CT??_R0PAVout_of_range@std@@@84
.xdata$x:0000F568                 dd offset __CT??_R0PAVlogic_error@std@@@84
.xdata$x:0000F56C                 dd offset __CT??_R0PAVexception@std@@@84
.xdata$x:0000F570                 dd offset __CT??_R0PAX@84
.xdata$x:0000F570 _xdata$x        ends
.xdata$x:0000F570
.data$r:0000F574 ; ===========================================================================
.data$r:0000F574
.data$r:0000F574 ; Segment type: Pure data
.data$r:0000F574 ; Segment permissions: Read/Write
.data$r:0000F574 _data$r         segment dword public 'DATA' use32
.data$r:0000F574                 assume cs:_data$r
.data$r:0000F574                 ;org 0F574h
.data$r:0000F574 ; COMDAT (pick any)
.data$r:0000F574                 public ??_R0PAVout_of_range@std@@@8
.data$r:0000F574 ; class std::out_of_range * `RTTI Type Descriptor'
.data$r:0000F574 ??_R0PAVout_of_range@std@@@8 dd offset ??_7type_info@@6B@
.data$r:0000F574                                         ; DATA XREF: .xdata$x:0000F598o
.data$r:0000F574                                         ; const type_info::`vftable'
.data$r:0000F578                 db    0
.data$r:0000F579                 db    0
.data$r:0000F57A                 db    0
.data$r:0000F57B                 db    0
.data$r:0000F57C                 db  2Eh ; .
.data$r:0000F57D                 db  50h ; P
.data$r:0000F57E                 db  41h ; A
.data$r:0000F57F                 db  56h ; V
.data$r:0000F580                 db  6Fh ; o
.data$r:0000F581                 db  75h ; u
.data$r:0000F582                 db  74h ; t
.data$r:0000F583                 db  5Fh ; _
.data$r:0000F584                 db  6Fh ; o
.data$r:0000F585                 db  66h ; f
.data$r:0000F586                 db  5Fh ; _
.data$r:0000F587                 db  72h ; r
.data$r:0000F588                 db  61h ; a
.data$r:0000F589                 db  6Eh ; n
.data$r:0000F58A                 db  67h ; g
.data$r:0000F58B                 db  65h ; e
.data$r:0000F58C                 db  40h ; @
.data$r:0000F58D                 db  73h ; s
.data$r:0000F58E                 db  74h ; t
.data$r:0000F58F                 db  64h ; d
.data$r:0000F590                 db  40h ; @
.data$r:0000F591                 db  40h ; @
.data$r:0000F592                 db    0
.data$r:0000F593                 align 4
.data$r:0000F593 _data$r         ends
.data$r:0000F593
.xdata$x:0000F594 ; ===========================================================================
.xdata$x:0000F594
.xdata$x:0000F594 ; Segment type: Pure data
.xdata$x:0000F594 ; Segment permissions: Read
.xdata$x:0000F594 _xdata$x        segment dword public 'DATA' use32
.xdata$x:0000F594                 assume cs:_xdata$x
.xdata$x:0000F594                 ;org 0F594h
.xdata$x:0000F594 ; COMDAT (pick any)
.xdata$x:0000F594                 public __CT??_R0PAVout_of_range@std@@@84
.xdata$x:0000F594 __CT??_R0PAVout_of_range@std@@@84 db    1 ; DATA XREF: .xdata$x:0000F564o
.xdata$x:0000F595                 db    0
.xdata$x:0000F596                 db    0
.xdata$x:0000F597                 db    0
.xdata$x:0000F598                 dd offset ??_R0PAVout_of_range@std@@@8 ; std::out_of_range * `RTTI Type Descriptor'
.xdata$x:0000F59C                 align 10h
.xdata$x:0000F5A0                 db 0FFh
.xdata$x:0000F5A1                 db 0FFh
.xdata$x:0000F5A2                 db 0FFh
.xdata$x:0000F5A3                 db 0FFh
.xdata$x:0000F5A4                 db    0
.xdata$x:0000F5A5                 db    0
.xdata$x:0000F5A6                 db    0
.xdata$x:0000F5A7                 db    0
.xdata$x:0000F5A8                 db    4
.xdata$x:0000F5A9                 db    0
.xdata$x:0000F5AA                 db    0
.xdata$x:0000F5AB                 db    0
.xdata$x:0000F5AC                 db    0
.xdata$x:0000F5AD                 db    0
.xdata$x:0000F5AE                 db    0
.xdata$x:0000F5AF                 db    0
.xdata$x:0000F5AF _xdata$x        ends
.xdata$x:0000F5AF
.rdata:0000F5B0 ; ===========================================================================
.rdata:0000F5B0
.rdata:0000F5B0 ; Segment type: Pure data
.rdata:0000F5B0 ; Segment permissions: Read
.rdata:0000F5B0 ; Segment alignment 'qword' can not be represented in assembly
.rdata:0000F5B0 _rdata          segment para public 'DATA' use32
.rdata:0000F5B0                 assume cs:_rdata
.rdata:0000F5B0                 ;org 0F5B0h
.rdata:0000F5B0 ; COMDAT (pick any)
.rdata:0000F5B0                 public ??_C@_1IO@FEAPGJBD@?$AAC?$AA?3?$AA?2?$AAP?$AAr?$AAo?$AAg?$AAr?$AAa?$AAm?$AA?5?$AAF?$AAi?$AAl?$AAe?$AAs?$AA?5?$AA?$CI?$AAx?$AA8?$AA6?$AA?$CJ?$AA?2?$AAM?$AAi?$AAc?$AAr?$AAo?$AAs?$AAo?$AAf?$AAt@
.rdata:0000F5B0 ; wchar_t `string'
.rdata:0000F5B0 ??_C@_1IO@FEAPGJBD@?$AAC?$AA?3?$AA?2?$AAP?$AAr?$AAo?$AAg?$AAr?$AAa?$AAm?$AA?5?$AAF?$AAi?$AAl?$AAe?$AAs?$AA?5?$AA?$CI?$AAx?$AA8?$AA6?$AA?$CJ?$AA?2?$AAM?$AAi?$AAc?$AAr?$AAo?$AAs?$AAo?$AAf?$AAt@:
.rdata:0000F5B0                                         ; DATA XREF: std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>>::_Construct<std::reverse_iterator<std::_Vector_iterator<std::_Vector_val<std::_Simple_types<wchar_t>>>>>(std::reverse_iterator<std::_Vector_iterator<std::_Vector_val<std::_Simple_types<wchar_t>>>>,std::reverse_iterator<std::_Vector_iterator<std::_Vector_val<std::_Simple_types<wchar_t>>>>,std::forward_iterator_tag)+3Bo
.rdata:0000F5B0                                         ; std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>>::operator[](uint)+17o ...
.rdata:0000F5B0                 unicode 0, <C:\Program Files (x86)\Microsoft Visual Studio 12.0\VC\in>
.rdata:0000F5B0                 unicode 0, <clude\xstring>,0
.rdata:0000F63E                 align 10h
.rdata:0000F63E _rdata          ends
.rdata:0000F63E
.rdata:0000F640 ; ===========================================================================
.rdata:0000F640
.rdata:0000F640 ; Segment type: Pure data
.rdata:0000F640 ; Segment permissions: Read
.rdata:0000F640 _rdata          segment dword public 'DATA' use32
.rdata:0000F640                 assume cs:_rdata
.rdata:0000F640                 ;org 0F640h
.rdata:0000F640 ; COMDAT (pick any)
.rdata:0000F640                 public ??_C@_1DM@GMPLOCPK@?$AAs?$AAt?$AAr?$AAi?$AAn?$AAg?$AA?5?$AAs?$AAu?$AAb?$AAs?$AAc?$AAr?$AAi?$AAp?$AAt?$AA?5?$AAo?$AAu?$AAt?$AA?5?$AAo?$AAf?$AA?5?$AAr?$AAa?$AAn?$AAg?$AAe?$AA?$AA@
.rdata:0000F640 ; wchar_t `string'
.rdata:0000F640 ??_C@_1DM@GMPLOCPK@?$AAs?$AAt?$AAr?$AAi?$AAn?$AAg?$AA?5?$AAs?$AAu?$AAb?$AAs?$AAc?$AAr?$AAi?$AAp?$AAt?$AA?5?$AAo?$AAu?$AAt?$AA?5?$AAo?$AAf?$AA?5?$AAr?$AAa?$AAn?$AAg?$AAe?$AA?$AA@:
.rdata:0000F640                                         ; DATA XREF: std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>>::operator[](uint)+1Co
.rdata:0000F640                                         ; std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>>::operator[](uint)+1Co
.rdata:0000F640                 unicode 0, <string subscript out of range>,0
.rdata:0000F640 _rdata          ends
.rdata:0000F640
.bss:0000F67C ; ===========================================================================
.bss:0000F67C
.bss:0000F67C ; Segment type: Uninitialized
.bss:0000F67C ; Segment permissions: Read/Write
.bss:0000F67C _bss            segment dword public 'BSS' use32
.bss:0000F67C                 assume cs:_bss
.bss:0000F67C                 ;org 0F67Ch
.bss:0000F67C ; COMDAT (pick any)
.bss:0000F67C                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.bss:0000F67C                 public ?id@?$numpunct@D@std@@2V0locale@2@A
.bss:0000F67C ; std::locale::id std::numpunct<char>::id
.bss:0000F67C ?id@?$numpunct@D@std@@2V0locale@2@A db    ? ;
.bss:0000F67C                                         ; DATA XREF: `dynamic initializer for 'std::locale::id std::numpunct<char>::id''(void)+5o
.bss:0000F67D                 db    ? ;
.bss:0000F67E                 db    ? ;
.bss:0000F67F                 db    ? ;
.bss:0000F67F _bss            ends
.bss:0000F67F
.bss:0000F680 ; ===========================================================================
.bss:0000F680
.bss:0000F680 ; Segment type: Uninitialized
.bss:0000F680 ; Segment permissions: Read/Write
.bss:0000F680 _bss            segment dword public 'BSS' use32
.bss:0000F680                 assume cs:_bss
.bss:0000F680                 ;org 0F680h
.bss:0000F680 ; COMDAT (pick any)
.bss:0000F680                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.bss:0000F680                 public ?id@?$numpunct@_W@std@@2V0locale@2@A
.bss:0000F680 ; std::locale::id std::numpunct<wchar_t>::id
.bss:0000F680 ?id@?$numpunct@_W@std@@2V0locale@2@A db    ? ;
.bss:0000F680                                         ; DATA XREF: `dynamic initializer for 'std::locale::id std::numpunct<wchar_t>::id''(void)+5o
.bss:0000F681                 db    ? ;
.bss:0000F682                 db    ? ;
.bss:0000F683                 db    ? ;
.bss:0000F683 _bss            ends
.bss:0000F683
.bss:0000F684 ; ===========================================================================
.bss:0000F684
.bss:0000F684 ; Segment type: Uninitialized
.bss:0000F684 ; Segment permissions: Read/Write
.bss:0000F684 _bss            segment byte public 'BSS' use32
.bss:0000F684                 assume cs:_bss
.bss:0000F684                 ;org 0F684h
.bss:0000F684 ; COMDAT (pick any)
.bss:0000F684                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.bss:0000F684                 public ?nullStr@?1??empty@?$StringBuffer@D@WcharMbcsConvertor@@QAEXXZ@4DA
.bss:0000F684 ; char `public: void __thiscall WcharMbcsConvertor::StringBuffer<char>::empty(void)'::`2'::nullStr
.bss:0000F684 ?nullStr@?1??empty@?$StringBuffer@D@WcharMbcsConvertor@@QAEXXZ@4DA db    ? ;
.bss:0000F684                                         ; DATA XREF: WcharMbcsConvertor::StringBuffer<char>::empty(void)+12o
.bss:0000F685                 align 4
.bss:0000F685 _bss            ends
.bss:0000F685
.bss:0000F688 ; ===========================================================================
.bss:0000F688
.bss:0000F688 ; Segment type: Uninitialized
.bss:0000F688 ; Segment permissions: Read/Write
.bss:0000F688 _bss            segment dword public 'BSS' use32
.bss:0000F688                 assume cs:_bss
.bss:0000F688                 ;org 0F688h
.bss:0000F688 ; COMDAT (pick any)
.bss:0000F688                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.bss:0000F688                 public ?nullStr@?1??empty@?$StringBuffer@_W@WcharMbcsConvertor@@QAEXXZ@4_WA
.bss:0000F688 ; wchar_t `public: void __thiscall WcharMbcsConvertor::StringBuffer<wchar_t>::empty(void)'::`2'::nullStr
.bss:0000F688 ?nullStr@?1??empty@?$StringBuffer@_W@WcharMbcsConvertor@@QAEXXZ@4_WA db    ? ;
.bss:0000F688                                         ; DATA XREF: WcharMbcsConvertor::StringBuffer<wchar_t>::empty(void)+12o
.bss:0000F689                 db    ? ;
.bss:0000F68A                 align 4
.bss:0000F68A _bss            ends
.bss:0000F68A
.rdata:0000F68C ; ===========================================================================
.rdata:0000F68C
.rdata:0000F68C ; Segment type: Pure data
.rdata:0000F68C ; Segment permissions: Read
.rdata:0000F68C ; Segment alignment 'qword' can not be represented in assembly
.rdata:0000F68C _rdata          segment para public 'DATA' use32
.rdata:0000F68C                 assume cs:_rdata
.rdata:0000F68C                 ;org 0F68Ch
.rdata:0000F68C ; COMDAT (pick any)
.rdata:0000F68C                 public ??_C@_1IM@EINEHPHE@?$AAC?$AA?3?$AA?2?$AAP?$AAr?$AAo?$AAg?$AAr?$AAa?$AAm?$AA?5?$AAF?$AAi?$AAl?$AAe?$AAs?$AA?5?$AA?$CI?$AAx?$AA8?$AA6?$AA?$CJ?$AA?2?$AAM?$AAi?$AAc?$AAr?$AAo?$AAs?$AAo?$AAf?$AAt@
.rdata:0000F68C ; wchar_t `string'
.rdata:0000F68C ??_C@_1IM@EINEHPHE@?$AAC?$AA?3?$AA?2?$AAP?$AAr?$AAo?$AAg?$AAr?$AAa?$AAm?$AA?5?$AAF?$AAi?$AAl?$AAe?$AAs?$AA?5?$AA?$CI?$AAx?$AA8?$AA6?$AA?$CJ?$AA?2?$AAM?$AAi?$AAc?$AAr?$AAo?$AAs?$AAo?$AAf?$AAt@:
.rdata:0000F68C                                         ; DATA XREF: std::vector<char,std::allocator<char>>::operator[](uint)+19o
.rdata:0000F68C                                         ; std::vector<char,std::allocator<char>>::operator[](uint)+49o ...
.rdata:0000F68C                 unicode 0, <C:\Program Files (x86)\Microsoft Visual Studio 12.0\VC\in>
.rdata:0000F68C                 unicode 0, <clude\vector>,0
.rdata:0000F68C _rdata          ends
.rdata:0000F68C
.rdata:0000F718 ; ===========================================================================
.rdata:0000F718
.rdata:0000F718 ; Segment type: Pure data
.rdata:0000F718 ; Segment permissions: Read
.rdata:0000F718 _rdata          segment dword public 'DATA' use32
.rdata:0000F718                 assume cs:_rdata
.rdata:0000F718                 ;org 0F718h
.rdata:0000F718 ; COMDAT (pick any)
.rdata:0000F718                 public ??_C@_1DM@LHGCHCBA@?$AAv?$AAe?$AAc?$AAt?$AAo?$AAr?$AA?5?$AAs?$AAu?$AAb?$AAs?$AAc?$AAr?$AAi?$AAp?$AAt?$AA?5?$AAo?$AAu?$AAt?$AA?5?$AAo?$AAf?$AA?5?$AAr?$AAa?$AAn?$AAg?$AAe?$AA?$AA@
.rdata:0000F718 ; wchar_t `string'
.rdata:0000F718 ??_C@_1DM@LHGCHCBA@?$AAv?$AAe?$AAc?$AAt?$AAo?$AAr?$AA?5?$AAs?$AAu?$AAb?$AAs?$AAc?$AAr?$AAi?$AAp?$AAt?$AA?5?$AAo?$AAu?$AAt?$AA?5?$AAo?$AAf?$AA?5?$AAr?$AAa?$AAn?$AAg?$AAe?$AA?$AA@:
.rdata:0000F718                                         ; DATA XREF: std::vector<char,std::allocator<char>>::operator[](uint)+1Eo
.rdata:0000F718                                         ; std::vector<wchar_t,std::allocator<wchar_t>>::operator[](uint)+1Eo
.rdata:0000F718                 unicode 0, <vector subscript out of range>,0
.rdata:0000F718 _rdata          ends
.rdata:0000F718
.rdata:0000F754 ; ===========================================================================
.rdata:0000F754
.rdata:0000F754 ; Segment type: Pure data
.rdata:0000F754 ; Segment permissions: Read
.rdata:0000F754 _rdata          segment dword public 'DATA' use32
.rdata:0000F754                 assume cs:_rdata
.rdata:0000F754                 ;org 0F754h
.rdata:0000F754 ; COMDAT (pick any)
.rdata:0000F754                 public ??_C@_0CE@OFMIGAMM@Standard?5C?$CL?$CL?5Libraries?5Out?5of?5Ra@
.rdata:0000F754 ; `string'
.rdata:0000F754 ??_C@_0CE@OFMIGAMM@Standard?5C?$CL?$CL?5Libraries?5Out?5of?5Ra@ db 'Standard C++ Libraries Out of Range',0
.rdata:0000F754                                         ; DATA XREF: std::vector<char,std::allocator<char>>::operator[](uint)+2Bo
.rdata:0000F754                                         ; std::vector<wchar_t,std::allocator<wchar_t>>::operator[](uint)+2Bo ...
.rdata:0000F754 _rdata          ends
.rdata:0000F754
.rdata:0000F778 ; ===========================================================================
.rdata:0000F778
.rdata:0000F778 ; Segment type: Pure data
.rdata:0000F778 ; Segment permissions: Read
.rdata:0000F778 ; Segment alignment 'qword' can not be represented in assembly
.rdata:0000F778 _rdata          segment para public 'DATA' use32
.rdata:0000F778                 assume cs:_rdata
.rdata:0000F778                 ;org 0F778h
.rdata:0000F778 ; COMDAT (pick any)
.rdata:0000F778                 public ??_C@_1FG@IBPIFFN@?$AA?$CC?$AAS?$AAt?$AAa?$AAn?$AAd?$AAa?$AAr?$AAd?$AA?5?$AAC?$AA?$CL?$AA?$CL?$AA?5?$AAL?$AAi?$AAb?$AAr?$AAa?$AAr?$AAi?$AAe?$AAs?$AA?5?$AAO?$AAu?$AAt?$AA?5?$AAo?$AAf?$AA?5?$AAR@
.rdata:0000F778 ; `string'
.rdata:0000F778 ??_C@_1FG@IBPIFFN@?$AA?$CC?$AAS?$AAt?$AAa?$AAn?$AAd?$AAa?$AAr?$AAd?$AA?5?$AAC?$AA?$CL?$AA?$CL?$AA?5?$AAL?$AAi?$AAb?$AAr?$AAa?$AAr?$AAi?$AAe?$AAs?$AA?5?$AAO?$AAu?$AAt?$AA?5?$AAo?$AAf?$AA?5?$AAR@:
.rdata:0000F778                                         ; DATA XREF: std::vector<char,std::allocator<char>>::operator[](uint):loc_7E48o
.rdata:0000F778                                         ; std::vector<wchar_t,std::allocator<wchar_t>>::operator[](uint):loc_7ED4o ...
.rdata:0000F778                 unicode 0, <"Standard C++ Libraries Out of Range" && 0>,0
.rdata:0000F7CE                 align 10h
.rdata:0000F7CE _rdata          ends
.rdata:0000F7CE
.rdata:0000F7D0 ; ===========================================================================
.rdata:0000F7D0
.rdata:0000F7D0 ; Segment type: Pure data
.rdata:0000F7D0 ; Segment permissions: Read
.rdata:0000F7D0 _rdata          segment dword public 'DATA' use32
.rdata:0000F7D0                 assume cs:_rdata
.rdata:0000F7D0                 ;org 0F7D0h
.rdata:0000F7D0 ; COMDAT (pick any)
.rdata:0000F7D0                 public ??_C@_15GANGMFKL@?$AA?$CF?$AAs?$AA?$AA@
.rdata:0000F7D0 ; `string'
.rdata:0000F7D0 ??_C@_15GANGMFKL@?$AA?$CF?$AAs?$AA?$AA@:
.rdata:0000F7D0                                         ; DATA XREF: std::vector<char,std::allocator<char>>::operator[](uint)+3Do
.rdata:0000F7D0                                         ; std::vector<wchar_t,std::allocator<wchar_t>>::operator[](uint)+3Do ...
.rdata:0000F7D0                 unicode 0, <%s>,0
.rdata:0000F7D6                 align 4
.rdata:0000F7D6 _rdata          ends
.rdata:0000F7D6
.rdata:0000F7D8 ; ===========================================================================
.rdata:0000F7D8
.rdata:0000F7D8 ; Segment type: Pure data
.rdata:0000F7D8 ; Segment permissions: Read
.rdata:0000F7D8 ; Segment alignment 'qword' can not be represented in assembly
.rdata:0000F7D8 _rdata          segment para public 'DATA' use32
.rdata:0000F7D8                 assume cs:_rdata
.rdata:0000F7D8                 ;org 0F7D8h
.rdata:0000F7D8 ; COMDAT (pick any)
.rdata:0000F7D8                 public ??_C@_1IC@MBIJKJB@?$AAs?$AAt?$AAd?$AA?3?$AA?3?$AAv?$AAe?$AAc?$AAt?$AAo?$AAr?$AA?$DM?$AAw?$AAc?$AAh?$AAa?$AAr?$AA_?$AAt?$AA?0?$AAc?$AAl?$AAa?$AAs?$AAs?$AA?5?$AAs?$AAt?$AAd?$AA?3?$AA?3?$AAa@
.rdata:0000F7D8 ; `string'
.rdata:0000F7D8 ??_C@_1IC@MBIJKJB@?$AAs?$AAt?$AAd?$AA?3?$AA?3?$AAv?$AAe?$AAc?$AAt?$AAo?$AAr?$AA?$DM?$AAw?$AAc?$AAh?$AAa?$AAr?$AA_?$AAt?$AA?0?$AAc?$AAl?$AAa?$AAs?$AAs?$AA?5?$AAs?$AAt?$AAd?$AA?3?$AA?3?$AAa@:
.rdata:0000F7D8                                         ; DATA XREF: std::vector<wchar_t,std::allocator<wchar_t>>::operator[](uint)+6Ao
.rdata:0000F7D8                 unicode 0, <std::vector>
.rdata:0000F7D8                 dw 3Ch
.rdata:0000F7D8                 unicode 0, <wchar_t,class std::allocator>
.rdata:0000F7D8                 dw 3Ch
.rdata:0000F7D8                 unicode 0, <wchar_t>
.rdata:0000F7D8                 dw 3Eh
.rdata:0000F7D8                 unicode 0, < >
.rdata:0000F7D8                 dw 3Eh
.rdata:0000F7D8                 unicode 0, <::operator []>,0
.rdata:0000F85A                 align 4
.rdata:0000F85A _rdata          ends
.rdata:0000F85A
.rdata:0000F85C ; ===========================================================================
.rdata:0000F85C
.rdata:0000F85C ; Segment type: Pure data
.rdata:0000F85C ; Segment permissions: Read
.rdata:0000F85C _rdata          segment dword public 'DATA' use32
.rdata:0000F85C                 assume cs:_rdata
.rdata:0000F85C                 ;org 0F85Ch
.rdata:0000F85C ; COMDAT (pick any)
.rdata:0000F85C                 public ??_C@_1BO@MEPPHOO@?$AA?$CC?$AAo?$AAu?$AAt?$AA?5?$AAo?$AAf?$AA?5?$AAr?$AAa?$AAn?$AAg?$AAe?$AA?$CC?$AA?$AA@
.rdata:0000F85C ; `string'
.rdata:0000F85C ??_C@_1BO@MEPPHOO@?$AA?$CC?$AAo?$AAu?$AAt?$AA?5?$AAo?$AAf?$AA?5?$AAr?$AAa?$AAn?$AAg?$AAe?$AA?$CC?$AA?$AA@:
.rdata:0000F85C                                         ; DATA XREF: std::vector<char,std::allocator<char>>::operator[](uint)+6Fo
.rdata:0000F85C                                         ; std::vector<wchar_t,std::allocator<wchar_t>>::operator[](uint)+6Fo ...
.rdata:0000F85C                 unicode 0, <"out of range">,0
.rdata:0000F87A                 align 4
.rdata:0000F87A _rdata          ends
.rdata:0000F87A
.rdata:0000F87C ; ===========================================================================
.rdata:0000F87C
.rdata:0000F87C ; Segment type: Pure data
.rdata:0000F87C ; Segment permissions: Read
.rdata:0000F87C ; Segment alignment 'qword' can not be represented in assembly
.rdata:0000F87C _rdata          segment para public 'DATA' use32
.rdata:0000F87C                 assume cs:_rdata
.rdata:0000F87C                 ;org 0F87Ch
.rdata:0000F87C ; COMDAT (pick any)
.rdata:0000F87C                 public ??_C@_1HG@EBINAPHK@?$AAs?$AAt?$AAd?$AA?3?$AA?3?$AAv?$AAe?$AAc?$AAt?$AAo?$AAr?$AA?$DM?$AAc?$AAh?$AAa?$AAr?$AA?0?$AAc?$AAl?$AAa?$AAs?$AAs?$AA?5?$AAs?$AAt?$AAd?$AA?3?$AA?3?$AAa?$AAl?$AAl?$AAo@
.rdata:0000F87C ; `string'
.rdata:0000F87C ??_C@_1HG@EBINAPHK@?$AAs?$AAt?$AAd?$AA?3?$AA?3?$AAv?$AAe?$AAc?$AAt?$AAo?$AAr?$AA?$DM?$AAc?$AAh?$AAa?$AAr?$AA?0?$AAc?$AAl?$AAa?$AAs?$AAs?$AA?5?$AAs?$AAt?$AAd?$AA?3?$AA?3?$AAa?$AAl?$AAl?$AAo@:
.rdata:0000F87C                                         ; DATA XREF: std::vector<char,std::allocator<char>>::operator[](uint)+6Ao
.rdata:0000F87C                 unicode 0, <std::vector>
.rdata:0000F87C                 dw 3Ch
.rdata:0000F87C                 unicode 0, <char,class std::allocator>
.rdata:0000F87C                 dw 3Ch
.rdata:0000F87C                 unicode 0, <char>
.rdata:0000F87C                 dw 3Eh
.rdata:0000F87C                 unicode 0, < >
.rdata:0000F87C                 dw 3Eh
.rdata:0000F87C                 unicode 0, <::operator []>,0
.rdata:0000F8F2                 align 4
.rdata:0000F8F2 _rdata          ends
.rdata:0000F8F2
.rdata:0000F8F4 ; ===========================================================================
.rdata:0000F8F4
.rdata:0000F8F4 ; Segment type: Pure data
.rdata:0000F8F4 ; Segment permissions: Read
.rdata:0000F8F4 ; Segment alignment 'qword' can not be represented in assembly
.rdata:0000F8F4 _rdata          segment para public 'DATA' use32
.rdata:0000F8F4                 assume cs:_rdata
.rdata:0000F8F4                 ;org 0F8F4h
.rdata:0000F8F4 ; COMDAT (pick any)
.rdata:0000F8F4                 public ??_C@_1EM@MEFKBKGF@?$AAs?$AAt?$AAr?$AAi?$AAn?$AAg?$AA?5?$AAi?$AAt?$AAe?$AAr?$AAa?$AAt?$AAo?$AAr?$AA?5?$AA?$CL?$AA?5?$AAo?$AAf?$AAf?$AAs?$AAe?$AAt?$AA?5?$AAo?$AAu?$AAt?$AA?5?$AAo?$AAf?$AA?5@
.rdata:0000F8F4 ; wchar_t `string'
.rdata:0000F8F4 ??_C@_1EM@MEFKBKGF@?$AAs?$AAt?$AAr?$AAi?$AAn?$AAg?$AA?5?$AAi?$AAt?$AAe?$AAr?$AAa?$AAt?$AAo?$AAr?$AA?5?$AA?$CL?$AA?5?$AAo?$AAf?$AAf?$AAs?$AAe?$AAt?$AA?5?$AAo?$AAu?$AAt?$AA?5?$AAo?$AAf?$AA?5@:
.rdata:0000F8F4                                         ; DATA XREF: std::_String_const_iterator<std::_String_val<std::_Simple_types<wchar_t>>>::operator+=(int)+75o
.rdata:0000F8F4                 unicode 0, <string iterator + offset out of range>,0
.rdata:0000F8F4 _rdata          ends
.rdata:0000F8F4
.rdata:0000F940 ; ===========================================================================
.rdata:0000F940
.rdata:0000F940 ; Segment type: Pure data
.rdata:0000F940 ; Segment permissions: Read
.rdata:0000F940 ; Segment alignment 'qword' can not be represented in assembly
.rdata:0000F940 _rdata          segment para public 'DATA' use32
.rdata:0000F940                 assume cs:_rdata
.rdata:0000F940                 ;org 0F940h
.rdata:0000F940 ; COMDAT (pick any)
.rdata:0000F940                 public ??_C@_1MO@BFIEDEJC@?$AAs?$AAt?$AAd?$AA?3?$AA?3?$AA_?$AAS?$AAt?$AAr?$AAi?$AAn?$AAg?$AA_?$AAc?$AAo?$AAn?$AAs?$AAt?$AA_?$AAi?$AAt?$AAe?$AAr?$AAa?$AAt?$AAo?$AAr?$AA?$DM?$AAc?$AAl?$AAa?$AAs@
.rdata:0000F940 ; `string'
.rdata:0000F940 ??_C@_1MO@BFIEDEJC@?$AAs?$AAt?$AAd?$AA?3?$AA?3?$AA_?$AAS?$AAt?$AAr?$AAi?$AAn?$AAg?$AA_?$AAc?$AAo?$AAn?$AAs?$AAt?$AA_?$AAi?$AAt?$AAe?$AAr?$AAa?$AAt?$AAo?$AAr?$AA?$DM?$AAc?$AAl?$AAa?$AAs@:
.rdata:0000F940                                         ; DATA XREF: std::_String_const_iterator<std::_String_val<std::_Simple_types<wchar_t>>>::operator+=(int)+C1o
.rdata:0000F940                 unicode 0, <std::_String_const_iterator>
.rdata:0000F940                 dw 3Ch
.rdata:0000F940                 unicode 0, <class std::_String_val>
.rdata:0000F940                 dw 3Ch
.rdata:0000F940                 unicode 0, <struct std::_Simple_types>
.rdata:0000F940                 dw 3Ch
.rdata:0000F940                 unicode 0, <wchar_t>
.rdata:0000F940                 dw 3Eh
.rdata:0000F940                 unicode 0, < >
.rdata:0000F940                 dw 3Eh
.rdata:0000F940                 unicode 0, < >
.rdata:0000F940                 dw 3Eh
.rdata:0000F940                 unicode 0, <::operator +=>,0
.rdata:0000FA0E                 align 10h
.rdata:0000FA0E _rdata          ends
.rdata:0000FA0E
.rdata:0000FA10 ; ===========================================================================
.rdata:0000FA10
.rdata:0000FA10 ; Segment type: Pure data
.rdata:0000FA10 ; Segment permissions: Read
.rdata:0000FA10 _rdata          segment dword public 'DATA' use32
.rdata:0000FA10                 assume cs:_rdata
.rdata:0000FA10                 ;org 0FA10h
.rdata:0000FA10 ; COMDAT (pick any)
.rdata:0000FA10                 public ??_C@_0BI@CFPLBAOH@invalid?5string?5position?$AA@
.rdata:0000FA10 ; char `string'[]
.rdata:0000FA10 ??_C@_0BI@CFPLBAOH@invalid?5string?5position?$AA@ db 'invalid string position',0
.rdata:0000FA10                                         ; DATA XREF: std::basic_string<char,std::char_traits<char>,std::allocator<char>>::_Xran(void)+7o
.rdata:0000FA10                                         ; std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>>::_Xran(void)+7o
.rdata:0000FA10 _rdata          ends
.rdata:0000FA10
.rdata:0000FA28 ; ===========================================================================
.rdata:0000FA28
.rdata:0000FA28 ; Segment type: Pure data
.rdata:0000FA28 ; Segment permissions: Read
.rdata:0000FA28 _rdata          segment dword public 'DATA' use32
.rdata:0000FA28                 assume cs:_rdata
.rdata:0000FA28                 ;org 0FA28h
.rdata:0000FA28 ; COMDAT (pick any)
.rdata:0000FA28                 public ??_C@_0BM@NMJKDPPO@invalid?5vector?$DMT?$DO?5subscript?$AA@
.rdata:0000FA28 ; char `string'[]
.rdata:0000FA28 ??_C@_0BM@NMJKDPPO@invalid?5vector?$DMT?$DO?5subscript?$AA@ db 'invalid vector<T> subscript',0
.rdata:0000FA28                                         ; DATA XREF: std::vector<std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>>,std::allocator<std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>>>>::_Xran(void)+7o
.rdata:0000FA28 _rdata          ends
.rdata:0000FA28
.rdata:0000FA44 ; ===========================================================================
.rdata:0000FA44
.rdata:0000FA44 ; Segment type: Pure data
.rdata:0000FA44 ; Segment permissions: Read
.rdata:0000FA44 _rdata          segment dword public 'DATA' use32
.rdata:0000FA44                 assume cs:_rdata
.rdata:0000FA44                 ;org 0FA44h
.rdata:0000FA44 ; COMDAT (pick any)
.rdata:0000FA44                 public ??_C@_1DM@KDEKGMPF@?$AAs?$AAt?$AAr?$AAi?$AAn?$AAg?$AA?5?$AAi?$AAt?$AAe?$AAr?$AAa?$AAt?$AAo?$AAr?$AAs?$AA?5?$AAi?$AAn?$AAc?$AAo?$AAm?$AAp?$AAa?$AAt?$AAi?$AAb?$AAl?$AAe?$AA?$AA@
.rdata:0000FA44 ; wchar_t `string'
.rdata:0000FA44 ??_C@_1DM@KDEKGMPF@?$AAs?$AAt?$AAr?$AAi?$AAn?$AAg?$AA?5?$AAi?$AAt?$AAe?$AAr?$AAa?$AAt?$AAo?$AAr?$AAs?$AA?5?$AAi?$AAn?$AAc?$AAo?$AAm?$AAp?$AAa?$AAt?$AAi?$AAb?$AAl?$AAe?$AA?$AA@:
.rdata:0000FA44                                         ; DATA XREF: std::_String_const_iterator<std::_String_val<std::_Simple_types<wchar_t>>>::_Compat(std::_String_const_iterator<std::_String_val<std::_Simple_types<wchar_t>>> const &)+34o
.rdata:0000FA44                 unicode 0, <string iterators incompatible>,0
.rdata:0000FA44 _rdata          ends
.rdata:0000FA44
.rdata:0000FA80 ; ===========================================================================
.rdata:0000FA80
.rdata:0000FA80 ; Segment type: Pure data
.rdata:0000FA80 ; Segment permissions: Read
.rdata:0000FA80 _rdata          segment dword public 'DATA' use32
.rdata:0000FA80                 assume cs:_rdata
.rdata:0000FA80                 ;org 0FA80h
.rdata:0000FA80 ; COMDAT (pick any)
.rdata:0000FA80                 public ??_C@_0CI@FNPHFCCM@Standard?5C?$CL?$CL?5Libraries?5Invalid?5A@
.rdata:0000FA80 ; `string'
.rdata:0000FA80 ??_C@_0CI@FNPHFCCM@Standard?5C?$CL?$CL?5Libraries?5Invalid?5A@ db 'Standard C++ Libraries Invalid Argument',0
.rdata:0000FA80                                         ; DATA XREF: std::_String_const_iterator<std::_String_val<std::_Simple_types<wchar_t>>>::_Compat(std::_String_const_iterator<std::_String_val<std::_Simple_types<wchar_t>>> const &)+41o
.rdata:0000FA80                                         ; std::_Vector_const_iterator<std::_Vector_val<std::_Simple_types<wchar_t>>>::_Compat(std::_Vector_const_iterator<std::_Vector_val<std::_Simple_types<wchar_t>>> const &)+41o
.rdata:0000FA80 _rdata          ends
.rdata:0000FA80
.rdata:0000FAA8 ; ===========================================================================
.rdata:0000FAA8
.rdata:0000FAA8 ; Segment type: Pure data
.rdata:0000FAA8 ; Segment permissions: Read
.rdata:0000FAA8 ; Segment alignment 'qword' can not be represented in assembly
.rdata:0000FAA8 _rdata          segment para public 'DATA' use32
.rdata:0000FAA8                 assume cs:_rdata
.rdata:0000FAA8                 ;org 0FAA8h
.rdata:0000FAA8 ; COMDAT (pick any)
.rdata:0000FAA8                 public ??_C@_1FO@GJIHNDLM@?$AA?$CC?$AAS?$AAt?$AAa?$AAn?$AAd?$AAa?$AAr?$AAd?$AA?5?$AAC?$AA?$CL?$AA?$CL?$AA?5?$AAL?$AAi?$AAb?$AAr?$AAa?$AAr?$AAi?$AAe?$AAs?$AA?5?$AAI?$AAn?$AAv?$AAa?$AAl?$AAi?$AAd?$AA?5@
.rdata:0000FAA8 ; `string'
.rdata:0000FAA8 ??_C@_1FO@GJIHNDLM@?$AA?$CC?$AAS?$AAt?$AAa?$AAn?$AAd?$AAa?$AAr?$AAd?$AA?5?$AAC?$AA?$CL?$AA?$CL?$AA?5?$AAL?$AAi?$AAb?$AAr?$AAa?$AAr?$AAi?$AAe?$AAs?$AA?5?$AAI?$AAn?$AAv?$AAa?$AAl?$AAi?$AAd?$AA?5@:
.rdata:0000FAA8                                         ; DATA XREF: std::_String_const_iterator<std::_String_val<std::_Simple_types<wchar_t>>>::_Compat(std::_String_const_iterator<std::_String_val<std::_Simple_types<wchar_t>>> const &):loc_92CEo
.rdata:0000FAA8                                         ; std::_Vector_const_iterator<std::_Vector_val<std::_Simple_types<wchar_t>>>::_Compat(std::_Vector_const_iterator<std::_Vector_val<std::_Simple_types<wchar_t>>> const &):loc_936Ao
.rdata:0000FAA8                 unicode 0, <"Standard C++ Libraries Invalid Argument" && 0>,0
.rdata:0000FB06                 align 4
.rdata:0000FB06 _rdata          ends
.rdata:0000FB06
.rdata:0000FB08 ; ===========================================================================
.rdata:0000FB08
.rdata:0000FB08 ; Segment type: Pure data
.rdata:0000FB08 ; Segment permissions: Read
.rdata:0000FB08 ; Segment alignment 'qword' can not be represented in assembly
.rdata:0000FB08 _rdata          segment para public 'DATA' use32
.rdata:0000FB08                 assume cs:_rdata
.rdata:0000FB08                 ;org 0FB08h
.rdata:0000FB08 ; COMDAT (pick any)
.rdata:0000FB08                 public ??_C@_1MG@CLNEOJNJ@?$AAs?$AAt?$AAd?$AA?3?$AA?3?$AA_?$AAS?$AAt?$AAr?$AAi?$AAn?$AAg?$AA_?$AAc?$AAo?$AAn?$AAs?$AAt?$AA_?$AAi?$AAt?$AAe?$AAr?$AAa?$AAt?$AAo?$AAr?$AA?$DM?$AAc?$AAl?$AAa?$AAs@
.rdata:0000FB08 ; `string'
.rdata:0000FB08 ??_C@_1MG@CLNEOJNJ@?$AAs?$AAt?$AAd?$AA?3?$AA?3?$AA_?$AAS?$AAt?$AAr?$AAi?$AAn?$AAg?$AA_?$AAc?$AAo?$AAn?$AAs?$AAt?$AA_?$AAi?$AAt?$AAe?$AAr?$AAa?$AAt?$AAo?$AAr?$AA?$DM?$AAc?$AAl?$AAa?$AAs@:
.rdata:0000FB08                                         ; DATA XREF: std::_String_const_iterator<std::_String_val<std::_Simple_types<wchar_t>>>::_Compat(std::_String_const_iterator<std::_String_val<std::_Simple_types<wchar_t>>> const &)+80o
.rdata:0000FB08                 unicode 0, <std::_String_const_iterator>
.rdata:0000FB08                 dw 3Ch
.rdata:0000FB08                 unicode 0, <class std::_String_val>
.rdata:0000FB08                 dw 3Ch
.rdata:0000FB08                 unicode 0, <struct std::_Simple_types>
.rdata:0000FB08                 dw 3Ch
.rdata:0000FB08                 unicode 0, <wchar_t>
.rdata:0000FB08                 dw 3Eh
.rdata:0000FB08                 unicode 0, < >
.rdata:0000FB08                 dw 3Eh
.rdata:0000FB08                 unicode 0, < >
.rdata:0000FB08                 dw 3Eh
.rdata:0000FB08                 unicode 0, <::_Compat>,0
.rdata:0000FBCE                 align 10h
.rdata:0000FBCE _rdata          ends
.rdata:0000FBCE
.rdata:0000FBD0 ; ===========================================================================
.rdata:0000FBD0
.rdata:0000FBD0 ; Segment type: Pure data
.rdata:0000FBD0 ; Segment permissions: Read
.rdata:0000FBD0 _rdata          segment dword public 'DATA' use32
.rdata:0000FBD0                 assume cs:_rdata
.rdata:0000FBD0                 ;org 0FBD0h
.rdata:0000FBD0 ; COMDAT (pick any)
.rdata:0000FBD0                 public ??_C@_1CG@JNLFBNGN@?$AA?$CC?$AAi?$AAn?$AAv?$AAa?$AAl?$AAi?$AAd?$AA?5?$AAa?$AAr?$AAg?$AAu?$AAm?$AAe?$AAn?$AAt?$AA?$CC?$AA?$AA@
.rdata:0000FBD0 ; `string'
.rdata:0000FBD0 ??_C@_1CG@JNLFBNGN@?$AA?$CC?$AAi?$AAn?$AAv?$AAa?$AAl?$AAi?$AAd?$AA?5?$AAa?$AAr?$AAg?$AAu?$AAm?$AAe?$AAn?$AAt?$AA?$CC?$AA?$AA@:
.rdata:0000FBD0                                         ; DATA XREF: std::_String_const_iterator<std::_String_val<std::_Simple_types<wchar_t>>>::_Compat(std::_String_const_iterator<std::_String_val<std::_Simple_types<wchar_t>>> const &)+85o
.rdata:0000FBD0                                         ; std::_Vector_const_iterator<std::_Vector_val<std::_Simple_types<wchar_t>>>::_Compat(std::_Vector_const_iterator<std::_Vector_val<std::_Simple_types<wchar_t>>> const &)+85o
.rdata:0000FBD0                 unicode 0, <"invalid argument">,0
.rdata:0000FBF6                 align 4
.rdata:0000FBF6 _rdata          ends
.rdata:0000FBF6
.rdata:0000FBF8 ; ===========================================================================
.rdata:0000FBF8
.rdata:0000FBF8 ; Segment type: Pure data
.rdata:0000FBF8 ; Segment permissions: Read
.rdata:0000FBF8 _rdata          segment dword public 'DATA' use32
.rdata:0000FBF8                 assume cs:_rdata
.rdata:0000FBF8                 ;org 0FBF8h
.rdata:0000FBF8 ; COMDAT (pick any)
.rdata:0000FBF8                 public ??_C@_0BA@JFNIOLAK@string?5too?5long?$AA@
.rdata:0000FBF8 ; char `string'[]
.rdata:0000FBF8 ??_C@_0BA@JFNIOLAK@string?5too?5long?$AA@ db 'string too long',0
.rdata:0000FBF8                                         ; DATA XREF: std::basic_string<char,std::char_traits<char>,std::allocator<char>>::_Xlen(void)+7o
.rdata:0000FBF8                                         ; std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>>::_Xlen(void)+7o
.rdata:0000FBF8 _rdata          ends
.rdata:0000FBF8
.rdata:0000FC08 ; ===========================================================================
.rdata:0000FC08
.rdata:0000FC08 ; Segment type: Pure data
.rdata:0000FC08 ; Segment permissions: Read
.rdata:0000FC08 _rdata          segment dword public 'DATA' use32
.rdata:0000FC08                 assume cs:_rdata
.rdata:0000FC08                 ;org 0FC08h
.rdata:0000FC08 ; COMDAT (pick any)
.rdata:0000FC08                 public ??_C@_0BD@OLBABOEK@vector?$DMT?$DO?5too?5long?$AA@
.rdata:0000FC08 ; char `string'[]
.rdata:0000FC08 ??_C@_0BD@OLBABOEK@vector?$DMT?$DO?5too?5long?$AA@ db 'vector<T> too long',0
.rdata:0000FC08                                         ; DATA XREF: std::vector<char,std::allocator<char>>::_Xlen(void)+7o
.rdata:0000FC08                                         ; std::vector<std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>>,std::allocator<std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>>>>::_Xlen(void)+7o ...
.rdata:0000FC1B                 align 4
.rdata:0000FC1B _rdata          ends
.rdata:0000FC1B
.rdata:0000FC1C ; ===========================================================================
.rdata:0000FC1C
.rdata:0000FC1C ; Segment type: Pure data
.rdata:0000FC1C ; Segment permissions: Read
.rdata:0000FC1C ; Segment alignment 'qword' can not be represented in assembly
.rdata:0000FC1C _rdata          segment para public 'DATA' use32
.rdata:0000FC1C                 assume cs:_rdata
.rdata:0000FC1C                 ;org 0FC1Ch
.rdata:0000FC1C ; COMDAT (pick any)
.rdata:0000FC1C                 public ??_C@_1EM@FKAOCOMF@?$AAv?$AAe?$AAc?$AAt?$AAo?$AAr?$AA?5?$AAi?$AAt?$AAe?$AAr?$AAa?$AAt?$AAo?$AAr?$AA?5?$AA?$CL?$AA?5?$AAo?$AAf?$AAf?$AAs?$AAe?$AAt?$AA?5?$AAo?$AAu?$AAt?$AA?5?$AAo?$AAf?$AA?5@
.rdata:0000FC1C ; wchar_t `string'
.rdata:0000FC1C ??_C@_1EM@FKAOCOMF@?$AAv?$AAe?$AAc?$AAt?$AAo?$AAr?$AA?5?$AAi?$AAt?$AAe?$AAr?$AAa?$AAt?$AAo?$AAr?$AA?5?$AA?$CL?$AA?5?$AAo?$AAf?$AAf?$AAs?$AAe?$AAt?$AA?5?$AAo?$AAu?$AAt?$AA?5?$AAo?$AAf?$AA?5@:
.rdata:0000FC1C                                         ; DATA XREF: std::_Vector_const_iterator<std::_Vector_val<std::_Simple_types<wchar_t>>>::operator+=(int)+50o
.rdata:0000FC1C                 unicode 0, <vector iterator + offset out of range>,0
.rdata:0000FC1C _rdata          ends
.rdata:0000FC1C
.rdata:0000FC68 ; ===========================================================================
.rdata:0000FC68
.rdata:0000FC68 ; Segment type: Pure data
.rdata:0000FC68 ; Segment permissions: Read
.rdata:0000FC68 ; Segment alignment 'qword' can not be represented in assembly
.rdata:0000FC68 _rdata          segment para public 'DATA' use32
.rdata:0000FC68                 assume cs:_rdata
.rdata:0000FC68                 ;org 0FC68h
.rdata:0000FC68 ; COMDAT (pick any)
.rdata:0000FC68                 public ??_C@_1MO@IIMGPDGH@?$AAs?$AAt?$AAd?$AA?3?$AA?3?$AA_?$AAV?$AAe?$AAc?$AAt?$AAo?$AAr?$AA_?$AAc?$AAo?$AAn?$AAs?$AAt?$AA_?$AAi?$AAt?$AAe?$AAr?$AAa?$AAt?$AAo?$AAr?$AA?$DM?$AAc?$AAl?$AAa?$AAs@
.rdata:0000FC68 ; `string'
.rdata:0000FC68 ??_C@_1MO@IIMGPDGH@?$AAs?$AAt?$AAd?$AA?3?$AA?3?$AA_?$AAV?$AAe?$AAc?$AAt?$AAo?$AAr?$AA_?$AAc?$AAo?$AAn?$AAs?$AAt?$AA_?$AAi?$AAt?$AAe?$AAr?$AAa?$AAt?$AAo?$AAr?$AA?$DM?$AAc?$AAl?$AAa?$AAs@:
.rdata:0000FC68                                         ; DATA XREF: std::_Vector_const_iterator<std::_Vector_val<std::_Simple_types<wchar_t>>>::operator+=(int)+9Co
.rdata:0000FC68                 unicode 0, <std::_Vector_const_iterator>
.rdata:0000FC68                 dw 3Ch
.rdata:0000FC68                 unicode 0, <class std::_Vector_val>
.rdata:0000FC68                 dw 3Ch
.rdata:0000FC68                 unicode 0, <struct std::_Simple_types>
.rdata:0000FC68                 dw 3Ch
.rdata:0000FC68                 unicode 0, <wchar_t>
.rdata:0000FC68                 dw 3Eh
.rdata:0000FC68                 unicode 0, < >
.rdata:0000FC68                 dw 3Eh
.rdata:0000FC68                 unicode 0, < >
.rdata:0000FC68                 dw 3Eh
.rdata:0000FC68                 unicode 0, <::operator +=>,0
.rdata:0000FD36                 align 4
.rdata:0000FD36 _rdata          ends
.rdata:0000FD36
.rdata:0000FD38 ; ===========================================================================
.rdata:0000FD38
.rdata:0000FD38 ; Segment type: Pure data
.rdata:0000FD38 ; Segment permissions: Read
.rdata:0000FD38 _rdata          segment dword public 'DATA' use32
.rdata:0000FD38                 assume cs:_rdata
.rdata:0000FD38                 ;org 0FD38h
.rdata:0000FD38 ; COMDAT (pick any)
.rdata:0000FD38                 public ??_C@_1CK@EOPGIILJ@?$AAi?$AAn?$AAv?$AAa?$AAl?$AAi?$AAd?$AA?5?$AAn?$AAu?$AAl?$AAl?$AA?5?$AAp?$AAo?$AAi?$AAn?$AAt?$AAe?$AAr?$AA?$AA@
.rdata:0000FD38 ; wchar_t `string'
.rdata:0000FD38 ??_C@_1CK@EOPGIILJ@?$AAi?$AAn?$AAv?$AAa?$AAl?$AAi?$AAd?$AA?5?$AAn?$AAu?$AAl?$AAl?$AA?5?$AAp?$AAo?$AAi?$AAn?$AAt?$AAe?$AAr?$AA?$AA@:
.rdata:0000FD38                                         ; DATA XREF: std::_Debug_pointer<int (int)>(int (*)(int),wchar_t const *,uint)+11o
.rdata:0000FD38                                         ; std::_Debug_pointer<char>(char const *,wchar_t const *,uint)+11o ...
.rdata:0000FD38                 unicode 0, <invalid null pointer>,0
.rdata:0000FD62                 align 4
.rdata:0000FD62 _rdata          ends
.rdata:0000FD62
.rdata:0000FD64 ; ===========================================================================
.rdata:0000FD64
.rdata:0000FD64 ; Segment type: Pure data
.rdata:0000FD64 ; Segment permissions: Read
.rdata:0000FD64 ; Segment alignment 'qword' can not be represented in assembly
.rdata:0000FD64 _rdata          segment para public 'DATA' use32
.rdata:0000FD64                 assume cs:_rdata
.rdata:0000FD64                 ;org 0FD64h
.rdata:0000FD64 ; COMDAT (pick any)
.rdata:0000FD64                 public ??_C@_1JC@HALMDPKM@?$AAC?$AA?3?$AA?2?$AAP?$AAr?$AAo?$AAg?$AAr?$AAa?$AAm?$AA?5?$AAF?$AAi?$AAl?$AAe?$AAs?$AA?5?$AA?$CI?$AAx?$AA8?$AA6?$AA?$CJ?$AA?2?$AAM?$AAi?$AAc?$AAr?$AAo?$AAs?$AAo?$AAf?$AAt@
.rdata:0000FD64 ; wchar_t `string'
.rdata:0000FD64 ??_C@_1JC@HALMDPKM@?$AAC?$AA?3?$AA?2?$AAP?$AAr?$AAo?$AAg?$AAr?$AAa?$AAm?$AA?5?$AAF?$AAi?$AAl?$AAe?$AAs?$AA?5?$AA?$CI?$AAx?$AA8?$AA6?$AA?$CJ?$AA?2?$AAM?$AAi?$AAc?$AAr?$AAo?$AAs?$AAo?$AAf?$AAt@:
.rdata:0000FD64                                         ; DATA XREF: std::transform<std::_String_iterator<std::_String_val<std::_Simple_types<wchar_t>>>,std::_String_iterator<std::_String_val<std::_Simple_types<wchar_t>>>,int (*)(int)>(std::_String_iterator<std::_String_val<std::_Simple_types<wchar_t>>>,std::_String_iterator<std::_String_val<std::_Simple_types<wchar_t>>>,std::_String_iterator<std::_String_val<std::_Simple_types<wchar_t>>>,int (*)(int))+38o
.rdata:0000FD64                                         ; std::transform<std::_String_iterator<std::_String_val<std::_Simple_types<wchar_t>>>,std::_String_iterator<std::_String_val<std::_Simple_types<wchar_t>>>,int (*)(int)>(std::_String_iterator<std::_String_val<std::_Simple_types<wchar_t>>>,std::_String_iterator<std::_String_val<std::_Simple_types<wchar_t>>>,std::_String_iterator<std::_String_val<std::_Simple_types<wchar_t>>>,int (*)(int))+8Ao ...
.rdata:0000FD64                 unicode 0, <C:\Program Files (x86)\Microsoft Visual Studio 12.0\VC\in>
.rdata:0000FD64                 unicode 0, <clude\algorithm>,0
.rdata:0000FDF6                 align 4
.rdata:0000FDF6 _rdata          ends
.rdata:0000FDF6
.rdata:0000FDF8 ; ===========================================================================
.rdata:0000FDF8
.rdata:0000FDF8 ; Segment type: Pure data
.rdata:0000FDF8 ; Segment permissions: Read
.rdata:0000FDF8 ; Segment alignment 'qword' can not be represented in assembly
.rdata:0000FDF8 _rdata          segment para public 'DATA' use32
.rdata:0000FDF8                 assume cs:_rdata
.rdata:0000FDF8                 ;org 0FDF8h
.rdata:0000FDF8 ; COMDAT (pick any)
.rdata:0000FDF8                 public ??_C@_1EG@CNCHLAOB@?$AAs?$AAt?$AAr?$AAi?$AAn?$AAg?$AA?5?$AAi?$AAt?$AAe?$AAr?$AAa?$AAt?$AAo?$AAr?$AA?5?$AAn?$AAo?$AAt?$AA?5?$AAd?$AAe?$AAr?$AAe?$AAf?$AAe?$AAr?$AAe?$AAn?$AAc?$AAa?$AAb@
.rdata:0000FDF8 ; wchar_t `string'
.rdata:0000FDF8 ??_C@_1EG@CNCHLAOB@?$AAs?$AAt?$AAr?$AAi?$AAn?$AAg?$AA?5?$AAi?$AAt?$AAe?$AAr?$AAa?$AAt?$AAo?$AAr?$AA?5?$AAn?$AAo?$AAt?$AA?5?$AAd?$AAe?$AAr?$AAe?$AAf?$AAe?$AAr?$AAe?$AAn?$AAc?$AAa?$AAb@:
.rdata:0000FDF8                                         ; DATA XREF: std::_String_const_iterator<std::_String_val<std::_Simple_types<wchar_t>>>::operator*(void)+62o
.rdata:0000FDF8                 unicode 0, <string iterator not dereferencable>,0
.rdata:0000FE3E                 align 10h
.rdata:0000FE3E _rdata          ends
.rdata:0000FE3E
.rdata:0000FE40 ; ===========================================================================
.rdata:0000FE40
.rdata:0000FE40 ; Segment type: Pure data
.rdata:0000FE40 ; Segment permissions: Read
.rdata:0000FE40 ; Segment alignment 'qword' can not be represented in assembly
.rdata:0000FE40 _rdata          segment para public 'DATA' use32
.rdata:0000FE40                 assume cs:_rdata
.rdata:0000FE40                 ;org 0FE40h
.rdata:0000FE40 ; COMDAT (pick any)
.rdata:0000FE40                 public ??_C@_1MM@BFHGHMKD@?$AAs?$AAt?$AAd?$AA?3?$AA?3?$AA_?$AAS?$AAt?$AAr?$AAi?$AAn?$AAg?$AA_?$AAc?$AAo?$AAn?$AAs?$AAt?$AA_?$AAi?$AAt?$AAe?$AAr?$AAa?$AAt?$AAo?$AAr?$AA?$DM?$AAc?$AAl?$AAa?$AAs@
.rdata:0000FE40 ; `string'
.rdata:0000FE40 ??_C@_1MM@BFHGHMKD@?$AAs?$AAt?$AAd?$AA?3?$AA?3?$AA_?$AAS?$AAt?$AAr?$AAi?$AAn?$AAg?$AA_?$AAc?$AAo?$AAn?$AAs?$AAt?$AA_?$AAi?$AAt?$AAe?$AAr?$AAa?$AAt?$AAo?$AAr?$AA?$DM?$AAc?$AAl?$AAa?$AAs@:
.rdata:0000FE40                                         ; DATA XREF: std::_String_const_iterator<std::_String_val<std::_Simple_types<wchar_t>>>::operator*(void)+A8o
.rdata:0000FE40                 unicode 0, <std::_String_const_iterator>
.rdata:0000FE40                 dw 3Ch
.rdata:0000FE40                 unicode 0, <class std::_String_val>
.rdata:0000FE40                 dw 3Ch
.rdata:0000FE40                 unicode 0, <struct std::_Simple_types>
.rdata:0000FE40                 dw 3Ch
.rdata:0000FE40                 unicode 0, <wchar_t>
.rdata:0000FE40                 dw 3Eh
.rdata:0000FE40                 unicode 0, < >
.rdata:0000FE40                 dw 3Eh
.rdata:0000FE40                 unicode 0, < >
.rdata:0000FE40                 dw 3Eh
.rdata:0000FE40                 unicode 0, <::operator *>,0
.rdata:0000FE40 _rdata          ends
.rdata:0000FE40
.rdata:0000FF0C ; ===========================================================================
.rdata:0000FF0C
.rdata:0000FF0C ; Segment type: Pure data
.rdata:0000FF0C ; Segment permissions: Read
.rdata:0000FF0C ; Segment alignment 'qword' can not be represented in assembly
.rdata:0000FF0C _rdata          segment para public 'DATA' use32
.rdata:0000FF0C                 assume cs:_rdata
.rdata:0000FF0C                 ;org 0FF0Ch
.rdata:0000FF0C ; COMDAT (pick any)
.rdata:0000FF0C                 public ??_C@_1EE@HAKOGNPH@?$AAs?$AAt?$AAr?$AAi?$AAn?$AAg?$AA?5?$AAi?$AAt?$AAe?$AAr?$AAa?$AAt?$AAo?$AAr?$AA?5?$AAn?$AAo?$AAt?$AA?5?$AAi?$AAn?$AAc?$AAr?$AAe?$AAm?$AAe?$AAn?$AAt?$AAa?$AAb?$AAl@
.rdata:0000FF0C ; wchar_t `string'
.rdata:0000FF0C ??_C@_1EE@HAKOGNPH@?$AAs?$AAt?$AAr?$AAi?$AAn?$AAg?$AA?5?$AAi?$AAt?$AAe?$AAr?$AAa?$AAt?$AAo?$AAr?$AA?5?$AAn?$AAo?$AAt?$AA?5?$AAi?$AAn?$AAc?$AAr?$AAe?$AAm?$AAe?$AAn?$AAt?$AAa?$AAb?$AAl@:
.rdata:0000FF0C                                         ; DATA XREF: std::_String_const_iterator<std::_String_val<std::_Simple_types<wchar_t>>>::operator++(void)+4Bo
.rdata:0000FF0C                 unicode 0, <string iterator not incrementable>,0
.rdata:0000FF0C _rdata          ends
.rdata:0000FF0C
.rdata:0000FF50 ; ===========================================================================
.rdata:0000FF50
.rdata:0000FF50 ; Segment type: Pure data
.rdata:0000FF50 ; Segment permissions: Read
.rdata:0000FF50 ; Segment alignment 'qword' can not be represented in assembly
.rdata:0000FF50 _rdata          segment para public 'DATA' use32
.rdata:0000FF50                 assume cs:_rdata
.rdata:0000FF50                 ;org 0FF50h
.rdata:0000FF50 ; COMDAT (pick any)
.rdata:0000FF50                 public ??_C@_1MO@GAPGDMNB@?$AAs?$AAt?$AAd?$AA?3?$AA?3?$AA_?$AAS?$AAt?$AAr?$AAi?$AAn?$AAg?$AA_?$AAc?$AAo?$AAn?$AAs?$AAt?$AA_?$AAi?$AAt?$AAe?$AAr?$AAa?$AAt?$AAo?$AAr?$AA?$DM?$AAc?$AAl?$AAa?$AAs@
.rdata:0000FF50 ; `string'
.rdata:0000FF50 ??_C@_1MO@GAPGDMNB@?$AAs?$AAt?$AAd?$AA?3?$AA?3?$AA_?$AAS?$AAt?$AAr?$AAi?$AAn?$AAg?$AA_?$AAc?$AAo?$AAn?$AAs?$AAt?$AA_?$AAi?$AAt?$AAe?$AAr?$AAa?$AAt?$AAo?$AAr?$AA?$DM?$AAc?$AAl?$AAa?$AAs@:
.rdata:0000FF50                                         ; DATA XREF: std::_String_const_iterator<std::_String_val<std::_Simple_types<wchar_t>>>::operator++(void)+91o
.rdata:0000FF50                 unicode 0, <std::_String_const_iterator>
.rdata:0000FF50                 dw 3Ch
.rdata:0000FF50                 unicode 0, <class std::_String_val>
.rdata:0000FF50                 dw 3Ch
.rdata:0000FF50                 unicode 0, <struct std::_Simple_types>
.rdata:0000FF50                 dw 3Ch
.rdata:0000FF50                 unicode 0, <wchar_t>
.rdata:0000FF50                 dw 3Eh
.rdata:0000FF50                 unicode 0, < >
.rdata:0000FF50                 dw 3Eh
.rdata:0000FF50                 unicode 0, < >
.rdata:0000FF50                 dw 3Eh
.rdata:0000FF50                 unicode 0, <::operator ++>,0
.rdata:0001001E                 align 10h
.rdata:0001001E _rdata          ends
.rdata:0001001E
.rdata:00010020 ; ===========================================================================
.rdata:00010020
.rdata:00010020 ; Segment type: Pure data
.rdata:00010020 ; Segment permissions: Read
.rdata:00010020 ; Segment alignment 'qword' can not be represented in assembly
.rdata:00010020 _rdata          segment para public 'DATA' use32
.rdata:00010020                 assume cs:_rdata
.rdata:00010020                 ;org 10020h
.rdata:00010020 ; COMDAT (pick any)
.rdata:00010020                 public ??_C@_1EG@FOHJJHAC@?$AAv?$AAe?$AAc?$AAt?$AAo?$AAr?$AA?5?$AAi?$AAt?$AAe?$AAr?$AAa?$AAt?$AAo?$AAr?$AA?5?$AAn?$AAo?$AAt?$AA?5?$AAd?$AAe?$AAr?$AAe?$AAf?$AAe?$AAr?$AAe?$AAn?$AAc?$AAa?$AAb@
.rdata:00010020 ; wchar_t `string'
.rdata:00010020 ??_C@_1EG@FOHJJHAC@?$AAv?$AAe?$AAc?$AAt?$AAo?$AAr?$AA?5?$AAi?$AAt?$AAe?$AAr?$AAa?$AAt?$AAo?$AAr?$AA?5?$AAn?$AAo?$AAt?$AA?5?$AAd?$AAe?$AAr?$AAe?$AAf?$AAe?$AAr?$AAe?$AAn?$AAc?$AAa?$AAb@:
.rdata:00010020                                         ; DATA XREF: std::_Vector_const_iterator<std::_Vector_val<std::_Simple_types<wchar_t>>>::operator*(void)+49o
.rdata:00010020                 unicode 0, <vector iterator not dereferencable>,0
.rdata:00010066                 align 4
.rdata:00010066 _rdata          ends
.rdata:00010066
.rdata:00010068 ; ===========================================================================
.rdata:00010068
.rdata:00010068 ; Segment type: Pure data
.rdata:00010068 ; Segment permissions: Read
.rdata:00010068 ; Segment alignment 'qword' can not be represented in assembly
.rdata:00010068 _rdata          segment para public 'DATA' use32
.rdata:00010068                 assume cs:_rdata
.rdata:00010068                 ;org 10068h
.rdata:00010068 ; COMDAT (pick any)
.rdata:00010068                 public ??_C@_1MM@BKDBGIKM@?$AAs?$AAt?$AAd?$AA?3?$AA?3?$AA_?$AAV?$AAe?$AAc?$AAt?$AAo?$AAr?$AA_?$AAc?$AAo?$AAn?$AAs?$AAt?$AA_?$AAi?$AAt?$AAe?$AAr?$AAa?$AAt?$AAo?$AAr?$AA?$DM?$AAc?$AAl?$AAa?$AAs@
.rdata:00010068 ; `string'
.rdata:00010068 ??_C@_1MM@BKDBGIKM@?$AAs?$AAt?$AAd?$AA?3?$AA?3?$AA_?$AAV?$AAe?$AAc?$AAt?$AAo?$AAr?$AA_?$AAc?$AAo?$AAn?$AAs?$AAt?$AA_?$AAi?$AAt?$AAe?$AAr?$AAa?$AAt?$AAo?$AAr?$AA?$DM?$AAc?$AAl?$AAa?$AAs@:
.rdata:00010068                                         ; DATA XREF: std::_Vector_const_iterator<std::_Vector_val<std::_Simple_types<wchar_t>>>::operator*(void)+8Fo
.rdata:00010068                 unicode 0, <std::_Vector_const_iterator>
.rdata:00010068                 dw 3Ch
.rdata:00010068                 unicode 0, <class std::_Vector_val>
.rdata:00010068                 dw 3Ch
.rdata:00010068                 unicode 0, <struct std::_Simple_types>
.rdata:00010068                 dw 3Ch
.rdata:00010068                 unicode 0, <wchar_t>
.rdata:00010068                 dw 3Eh
.rdata:00010068                 unicode 0, < >
.rdata:00010068                 dw 3Eh
.rdata:00010068                 unicode 0, < >
.rdata:00010068                 dw 3Eh
.rdata:00010068                 unicode 0, <::operator *>,0
.rdata:00010068 _rdata          ends
.rdata:00010068
.rdata:00010134 ; ===========================================================================
.rdata:00010134
.rdata:00010134 ; Segment type: Pure data
.rdata:00010134 ; Segment permissions: Read
.rdata:00010134 ; Segment alignment 'qword' can not be represented in assembly
.rdata:00010134 _rdata          segment para public 'DATA' use32
.rdata:00010134                 assume cs:_rdata
.rdata:00010134                 ;org 10134h
.rdata:00010134 ; COMDAT (pick any)
.rdata:00010134                 public ??_C@_1EE@EJDKCLKB@?$AAv?$AAe?$AAc?$AAt?$AAo?$AAr?$AA?5?$AAi?$AAt?$AAe?$AAr?$AAa?$AAt?$AAo?$AAr?$AA?5?$AAn?$AAo?$AAt?$AA?5?$AAi?$AAn?$AAc?$AAr?$AAe?$AAm?$AAe?$AAn?$AAt?$AAa?$AAb?$AAl@
.rdata:00010134 ; wchar_t `string'
.rdata:00010134 ??_C@_1EE@EJDKCLKB@?$AAv?$AAe?$AAc?$AAt?$AAo?$AAr?$AA?5?$AAi?$AAt?$AAe?$AAr?$AAa?$AAt?$AAo?$AAr?$AA?5?$AAn?$AAo?$AAt?$AA?5?$AAi?$AAn?$AAc?$AAr?$AAe?$AAm?$AAe?$AAn?$AAt?$AAa?$AAb?$AAl@:
.rdata:00010134                                         ; DATA XREF: std::_Vector_const_iterator<std::_Vector_val<std::_Simple_types<wchar_t>>>::operator++(void)+36o
.rdata:00010134                 unicode 0, <vector iterator not incrementable>,0
.rdata:00010134 _rdata          ends
.rdata:00010134
.rdata:00010178 ; ===========================================================================
.rdata:00010178
.rdata:00010178 ; Segment type: Pure data
.rdata:00010178 ; Segment permissions: Read
.rdata:00010178 ; Segment alignment 'qword' can not be represented in assembly
.rdata:00010178 _rdata          segment para public 'DATA' use32
.rdata:00010178                 assume cs:_rdata
.rdata:00010178                 ;org 10178h
.rdata:00010178 ; COMDAT (pick any)
.rdata:00010178                 public ??_C@_1MO@PNLEPLCE@?$AAs?$AAt?$AAd?$AA?3?$AA?3?$AA_?$AAV?$AAe?$AAc?$AAt?$AAo?$AAr?$AA_?$AAc?$AAo?$AAn?$AAs?$AAt?$AA_?$AAi?$AAt?$AAe?$AAr?$AAa?$AAt?$AAo?$AAr?$AA?$DM?$AAc?$AAl?$AAa?$AAs@
.rdata:00010178 ; `string'
.rdata:00010178 ??_C@_1MO@PNLEPLCE@?$AAs?$AAt?$AAd?$AA?3?$AA?3?$AA_?$AAV?$AAe?$AAc?$AAt?$AAo?$AAr?$AA_?$AAc?$AAo?$AAn?$AAs?$AAt?$AA_?$AAi?$AAt?$AAe?$AAr?$AAa?$AAt?$AAo?$AAr?$AA?$DM?$AAc?$AAl?$AAa?$AAs@:
.rdata:00010178                                         ; DATA XREF: std::_Vector_const_iterator<std::_Vector_val<std::_Simple_types<wchar_t>>>::operator++(void)+7Co
.rdata:00010178                 unicode 0, <std::_Vector_const_iterator>
.rdata:00010178                 dw 3Ch
.rdata:00010178                 unicode 0, <class std::_Vector_val>
.rdata:00010178                 dw 3Ch
.rdata:00010178                 unicode 0, <struct std::_Simple_types>
.rdata:00010178                 dw 3Ch
.rdata:00010178                 unicode 0, <wchar_t>
.rdata:00010178                 dw 3Eh
.rdata:00010178                 unicode 0, < >
.rdata:00010178                 dw 3Eh
.rdata:00010178                 unicode 0, < >
.rdata:00010178                 dw 3Eh
.rdata:00010178                 unicode 0, <::operator ++>,0
.rdata:00010246                 align 4
.rdata:00010246 _rdata          ends
.rdata:00010246
.rdata:00010248 ; ===========================================================================
.rdata:00010248
.rdata:00010248 ; Segment type: Pure data
.rdata:00010248 ; Segment permissions: Read
.rdata:00010248 _rdata          segment dword public 'DATA' use32
.rdata:00010248                 assume cs:_rdata
.rdata:00010248                 ;org 10248h
.rdata:00010248 ; COMDAT (pick any)
.rdata:00010248                 public ??_C@_1DM@HINDPMBP@?$AAv?$AAe?$AAc?$AAt?$AAo?$AAr?$AA?5?$AAi?$AAt?$AAe?$AAr?$AAa?$AAt?$AAo?$AAr?$AAs?$AA?5?$AAi?$AAn?$AAc?$AAo?$AAm?$AAp?$AAa?$AAt?$AAi?$AAb?$AAl?$AAe?$AA?$AA@
.rdata:00010248 ; wchar_t `string'
.rdata:00010248 ??_C@_1DM@HINDPMBP@?$AAv?$AAe?$AAc?$AAt?$AAo?$AAr?$AA?5?$AAi?$AAt?$AAe?$AAr?$AAa?$AAt?$AAo?$AAr?$AAs?$AA?5?$AAi?$AAn?$AAc?$AAo?$AAm?$AAp?$AAa?$AAt?$AAi?$AAb?$AAl?$AAe?$AA?$AA@:
.rdata:00010248                                         ; DATA XREF: std::_Vector_const_iterator<std::_Vector_val<std::_Simple_types<wchar_t>>>::_Compat(std::_Vector_const_iterator<std::_Vector_val<std::_Simple_types<wchar_t>>> const &)+34o
.rdata:00010248                 unicode 0, <vector iterators incompatible>,0
.rdata:00010248 _rdata          ends
.rdata:00010248
.rdata:00010284 ; ===========================================================================
.rdata:00010284
.rdata:00010284 ; Segment type: Pure data
.rdata:00010284 ; Segment permissions: Read
.rdata:00010284 ; Segment alignment 'qword' can not be represented in assembly
.rdata:00010284 _rdata          segment para public 'DATA' use32
.rdata:00010284                 assume cs:_rdata
.rdata:00010284                 ;org 10284h
.rdata:00010284 ; COMDAT (pick any)
.rdata:00010284                 public ??_C@_1MG@HLEJMPCF@?$AAs?$AAt?$AAd?$AA?3?$AA?3?$AA_?$AAV?$AAe?$AAc?$AAt?$AAo?$AAr?$AA_?$AAc?$AAo?$AAn?$AAs?$AAt?$AA_?$AAi?$AAt?$AAe?$AAr?$AAa?$AAt?$AAo?$AAr?$AA?$DM?$AAc?$AAl?$AAa?$AAs@
.rdata:00010284 ; `string'
.rdata:00010284 ??_C@_1MG@HLEJMPCF@?$AAs?$AAt?$AAd?$AA?3?$AA?3?$AA_?$AAV?$AAe?$AAc?$AAt?$AAo?$AAr?$AA_?$AAc?$AAo?$AAn?$AAs?$AAt?$AA_?$AAi?$AAt?$AAe?$AAr?$AAa?$AAt?$AAo?$AAr?$AA?$DM?$AAc?$AAl?$AAa?$AAs@:
.rdata:00010284                                         ; DATA XREF: std::_Vector_const_iterator<std::_Vector_val<std::_Simple_types<wchar_t>>>::_Compat(std::_Vector_const_iterator<std::_Vector_val<std::_Simple_types<wchar_t>>> const &)+80o
.rdata:00010284                 unicode 0, <std::_Vector_const_iterator>
.rdata:00010284                 dw 3Ch
.rdata:00010284                 unicode 0, <class std::_Vector_val>
.rdata:00010284                 dw 3Ch
.rdata:00010284                 unicode 0, <struct std::_Simple_types>
.rdata:00010284                 dw 3Ch
.rdata:00010284                 unicode 0, <wchar_t>
.rdata:00010284                 dw 3Eh
.rdata:00010284                 unicode 0, < >
.rdata:00010284                 dw 3Eh
.rdata:00010284                 unicode 0, < >
.rdata:00010284                 dw 3Eh
.rdata:00010284                 unicode 0, <::_Compat>,0
.rdata:0001034A                 align 4
.rdata:0001034A _rdata          ends
.rdata:0001034A
.rdata:0001034C ; ===========================================================================
.rdata:0001034C
.rdata:0001034C ; Segment type: Pure data
.rdata:0001034C ; Segment permissions: Read
.rdata:0001034C _rdata          segment dword public 'DATA' use32
.rdata:0001034C                 assume cs:_rdata
.rdata:0001034C                 ;org 1034Ch
.rdata:0001034C ; COMDAT (pick any)
.rdata:0001034C                 public ??_C@_1CO@DGLIKNHI@?$AAi?$AAn?$AAv?$AAa?$AAl?$AAi?$AAd?$AA?5?$AAi?$AAt?$AAe?$AAr?$AAa?$AAt?$AAo?$AAr?$AA?5?$AAr?$AAa?$AAn?$AAg?$AAe?$AA?$AA@
.rdata:0001034C ; wchar_t `string'
.rdata:0001034C ??_C@_1CO@DGLIKNHI@?$AAi?$AAn?$AAv?$AAa?$AAl?$AAi?$AAd?$AA?5?$AAi?$AAt?$AAe?$AAr?$AAa?$AAt?$AAo?$AAr?$AA?5?$AAr?$AAa?$AAn?$AAg?$AAe?$AA?$AA@:
.rdata:0001034C                                         ; DATA XREF: std::_Debug_range2<std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>> *>(std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>> *,std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>> *,wchar_t const *,uint,std::random_access_iterator_tag)+43o
.rdata:0001034C                                         ; std::_Debug_range2<wchar_t *>(wchar_t *,wchar_t *,wchar_t const *,uint,std::random_access_iterator_tag)+43o ...
.rdata:0001034C                 unicode 0, <invalid iterator range>,0
.rdata:0001037A                 align 4
.rdata:0001037A _rdata          ends
.rdata:0001037A
.rdata:0001037C ; ===========================================================================
.rdata:0001037C
.rdata:0001037C ; Segment type: Pure data
.rdata:0001037C ; Segment permissions: Read
.rdata:0001037C ; Segment alignment 'qword' can not be represented in assembly
.rdata:0001037C _rdata          segment para public 'DATA' use32
.rdata:0001037C                 assume cs:_rdata
.rdata:0001037C                 ;org 1037Ch
.rdata:0001037C ; COMDAT (pick any)
.rdata:0001037C                 public ??_C@_1EE@OEIJAKGE@?$AAv?$AAe?$AAc?$AAt?$AAo?$AAr?$AA?5?$AAi?$AAt?$AAe?$AAr?$AAa?$AAt?$AAo?$AAr?$AA?5?$AAn?$AAo?$AAt?$AA?5?$AAd?$AAe?$AAc?$AAr?$AAe?$AAm?$AAe?$AAn?$AAt?$AAa?$AAb?$AAl@
.rdata:0001037C ; wchar_t `string'
.rdata:0001037C ??_C@_1EE@OEIJAKGE@?$AAv?$AAe?$AAc?$AAt?$AAo?$AAr?$AA?5?$AAi?$AAt?$AAe?$AAr?$AAa?$AAt?$AAo?$AAr?$AA?5?$AAn?$AAo?$AAt?$AA?5?$AAd?$AAe?$AAc?$AAr?$AAe?$AAm?$AAe?$AAn?$AAt?$AAa?$AAb?$AAl@:
.rdata:0001037C                                         ; DATA XREF: std::_Vector_const_iterator<std::_Vector_val<std::_Simple_types<wchar_t>>>::operator--(void)+39o
.rdata:0001037C                 unicode 0, <vector iterator not decrementable>,0
.rdata:0001037C _rdata          ends
.rdata:0001037C
.rdata:000103C0 ; ===========================================================================
.rdata:000103C0
.rdata:000103C0 ; Segment type: Pure data
.rdata:000103C0 ; Segment permissions: Read
.rdata:000103C0 ; Segment alignment 'qword' can not be represented in assembly
.rdata:000103C0 _rdata          segment para public 'DATA' use32
.rdata:000103C0                 assume cs:_rdata
.rdata:000103C0                 ;org 103C0h
.rdata:000103C0 ; COMDAT (pick any)
.rdata:000103C0                 public ??_C@_1MO@OIGEHOF@?$AAs?$AAt?$AAd?$AA?3?$AA?3?$AA_?$AAV?$AAe?$AAc?$AAt?$AAo?$AAr?$AA_?$AAc?$AAo?$AAn?$AAs?$AAt?$AA_?$AAi?$AAt?$AAe?$AAr?$AAa?$AAt?$AAo?$AAr?$AA?$DM?$AAc?$AAl?$AAa?$AAs@
.rdata:000103C0 ; `string'
.rdata:000103C0 ??_C@_1MO@OIGEHOF@?$AAs?$AAt?$AAd?$AA?3?$AA?3?$AA_?$AAV?$AAe?$AAc?$AAt?$AAo?$AAr?$AA_?$AAc?$AAo?$AAn?$AAs?$AAt?$AA_?$AAi?$AAt?$AAe?$AAr?$AAa?$AAt?$AAo?$AAr?$AA?$DM?$AAc?$AAl?$AAa?$AAs@:
.rdata:000103C0                                         ; DATA XREF: std::_Vector_const_iterator<std::_Vector_val<std::_Simple_types<wchar_t>>>::operator--(void)+85o
.rdata:000103C0                 unicode 0, <std::_Vector_const_iterator>
.rdata:000103C0                 dw 3Ch
.rdata:000103C0                 unicode 0, <class std::_Vector_val>
.rdata:000103C0                 dw 3Ch
.rdata:000103C0                 unicode 0, <struct std::_Simple_types>
.rdata:000103C0                 dw 3Ch
.rdata:000103C0                 unicode 0, <wchar_t>
.rdata:000103C0                 dw 3Eh
.rdata:000103C0                 unicode 0, < >
.rdata:000103C0                 dw 3Eh
.rdata:000103C0                 unicode 0, < >
.rdata:000103C0                 dw 3Eh
.rdata:000103C0                 unicode 0, <::operator -->,0
.rdata:0001048E                 align 10h
.rdata:0001048E _rdata          ends
.rdata:0001048E
.rdata:00010490 ; ===========================================================================
.rdata:00010490
.rdata:00010490 ; Segment type: Pure data
.rdata:00010490 ; Segment permissions: Read
.rdata:00010490 ; Segment alignment 'qword' can not be represented in assembly
.rdata:00010490 _rdata          segment para public 'DATA' use32
.rdata:00010490                 assume cs:_rdata
.rdata:00010490                 ;org 10490h
.rdata:00010490 ; COMDAT (pick any)
.rdata:00010490                 public ??_C@_1IO@LKIDJAMC@?$AAC?$AA?3?$AA?2?$AAP?$AAr?$AAo?$AAg?$AAr?$AAa?$AAm?$AA?5?$AAF?$AAi?$AAl?$AAe?$AAs?$AA?5?$AA?$CI?$AAx?$AA8?$AA6?$AA?$CJ?$AA?2?$AAM?$AAi?$AAc?$AAr?$AAo?$AAs?$AAo?$AAf?$AAt@
.rdata:00010490 ; wchar_t `string'
.rdata:00010490 ??_C@_1IO@LKIDJAMC@?$AAC?$AA?3?$AA?2?$AAP?$AAr?$AAo?$AAg?$AAr?$AAa?$AAm?$AA?5?$AAF?$AAi?$AAl?$AAe?$AAs?$AA?5?$AA?$CI?$AAx?$AA8?$AA6?$AA?$CJ?$AA?2?$AAM?$AAi?$AAc?$AAr?$AAo?$AAs?$AAo?$AAf?$AAt@:
.rdata:00010490                                         ; DATA XREF: std::_Uninit_move<std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>> *,std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>> *,std::allocator<std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>>>,std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>>>(std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>> *,std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>> *,std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>> *,std::_Wrap_alloc<std::allocator<std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>>>> &,std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>> *,std::_Nonscalar_ptr_iterator_tag)+2Fo
.rdata:00010490                                         ; std::_Uninit_move<std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>> *,std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>> *,std::allocator<std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>>>,std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>>>(std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>> *,std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>> *,std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>> *,std::_Wrap_alloc<std::allocator<std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>>>> &,std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>> *,std::_Nonscalar_ptr_iterator_tag)+49o ...
.rdata:00010490                 unicode 0, <C:\Program Files (x86)\Microsoft Visual Studio 12.0\VC\in>
.rdata:00010490                 unicode 0, <clude\xmemory>,0
.rdata:0001051E                 align 10h
.rdata:0001051E _rdata          ends
.rdata:0001051E
.rdata$r:00010520 ; ===========================================================================
.rdata$r:00010520
.rdata$r:00010520 ; Segment type: Pure data
.rdata$r:00010520 ; Segment permissions: Read
.rdata$r:00010520 _rdata$r        segment dword public 'DATA' use32
.rdata$r:00010520                 assume cs:_rdata$r
.rdata$r:00010520                 ;org 10520h
.rdata$r:00010520 ; COMDAT (pick any)
.rdata$r:00010520                 public ??_R1A@?0A@EA@exception@std@@8
.rdata$r:00010520 ; std::exception::`RTTI Base Class Descriptor at (0, -1, 0, 64)'
.rdata$r:00010520 ??_R1A@?0A@EA@exception@std@@8 dd offset ??_R0?AVexception@std@@@8
.rdata$r:00010520                                         ; DATA XREF: .rdata$r:std::exception::`RTTI Base Class Array'o
.rdata$r:00010520                                         ; .rdata$r:0001059Co ...
.rdata$r:00010520                                         ; std::exception `RTTI Type Descriptor'
.rdata$r:00010524                 db    0
.rdata$r:00010525                 db    0
.rdata$r:00010526                 db    0
.rdata$r:00010527                 db    0
.rdata$r:00010528                 db    0
.rdata$r:00010529                 db    0
.rdata$r:0001052A                 db    0
.rdata$r:0001052B                 db    0
.rdata$r:0001052C                 db 0FFh
.rdata$r:0001052D                 db 0FFh
.rdata$r:0001052E                 db 0FFh
.rdata$r:0001052F                 db 0FFh
.rdata$r:00010530                 db    0
.rdata$r:00010531                 db    0
.rdata$r:00010532                 db    0
.rdata$r:00010533                 db    0
.rdata$r:00010534                 db  40h ; @
.rdata$r:00010535                 db    0
.rdata$r:00010536                 db    0
.rdata$r:00010537                 db    0
.rdata$r:00010538                 dd offset ??_R3exception@std@@8 ; std::exception::`RTTI Class Hierarchy Descriptor'
.rdata$r:00010538 _rdata$r        ends
.rdata$r:00010538
.rdata$r:0001053C ; ===========================================================================
.rdata$r:0001053C
.rdata$r:0001053C ; Segment type: Pure data
.rdata$r:0001053C ; Segment permissions: Read
.rdata$r:0001053C _rdata$r        segment dword public 'DATA' use32
.rdata$r:0001053C                 assume cs:_rdata$r
.rdata$r:0001053C                 ;org 1053Ch
.rdata$r:0001053C ; COMDAT (pick any)
.rdata$r:0001053C                 public ??_R3exception@std@@8
.rdata$r:0001053C ; std::exception::`RTTI Class Hierarchy Descriptor'
.rdata$r:0001053C ??_R3exception@std@@8 db    0           ; DATA XREF: .rdata$r:00010538o
.rdata$r:0001053D                 db    0
.rdata$r:0001053E                 db    0
.rdata$r:0001053F                 db    0
.rdata$r:00010540                 db    0
.rdata$r:00010541                 db    0
.rdata$r:00010542                 db    0
.rdata$r:00010543                 db    0
.rdata$r:00010544                 db    1
.rdata$r:00010545                 db    0
.rdata$r:00010546                 db    0
.rdata$r:00010547                 db    0
.rdata$r:00010548                 dd offset ??_R2exception@std@@8 ; std::exception::`RTTI Base Class Array'
.rdata$r:00010548 _rdata$r        ends
.rdata$r:00010548
.rdata$r:0001054C ; ===========================================================================
.rdata$r:0001054C
.rdata$r:0001054C ; Segment type: Pure data
.rdata$r:0001054C ; Segment permissions: Read
.rdata$r:0001054C _rdata$r        segment dword public 'DATA' use32
.rdata$r:0001054C                 assume cs:_rdata$r
.rdata$r:0001054C                 ;org 1054Ch
.rdata$r:0001054C ; COMDAT (pick any)
.rdata$r:0001054C                 public ??_R2exception@std@@8
.rdata$r:0001054C ; std::exception::`RTTI Base Class Array'
.rdata$r:0001054C ??_R2exception@std@@8 dd offset ??_R1A@?0A@EA@exception@std@@8
.rdata$r:0001054C                                         ; DATA XREF: .rdata$r:00010548o
.rdata$r:0001054C                                         ; std::exception::`RTTI Base Class Descriptor at (0,-1,0,64)'
.rdata$r:00010550                 db    0
.rdata$r:00010551                 align 4
.rdata$r:00010551 _rdata$r        ends
.rdata$r:00010551
.rdata$r:00010554 ; ===========================================================================
.rdata$r:00010554
.rdata$r:00010554 ; Segment type: Pure data
.rdata$r:00010554 ; Segment permissions: Read
.rdata$r:00010554 _rdata$r        segment dword public 'DATA' use32
.rdata$r:00010554                 assume cs:_rdata$r
.rdata$r:00010554                 ;org 10554h
.rdata$r:00010554 ; COMDAT (pick any)
.rdata$r:00010554                 public ??_R4logic_error@std@@6B@
.rdata$r:00010554 ; const std::logic_error::`RTTI Complete Object Locator'
.rdata$r:00010554 ??_R4logic_error@std@@6B@ db    0       ; DATA XREF: .rdata:0000F338o
.rdata$r:00010555                 db    0
.rdata$r:00010556                 db    0
.rdata$r:00010557                 db    0
.rdata$r:00010558                 db    0
.rdata$r:00010559                 db    0
.rdata$r:0001055A                 db    0
.rdata$r:0001055B                 db    0
.rdata$r:0001055C                 db    0
.rdata$r:0001055D                 db    0
.rdata$r:0001055E                 db    0
.rdata$r:0001055F                 db    0
.rdata$r:00010560                 dd offset ??_R0?AVlogic_error@std@@@8 ; std::logic_error `RTTI Type Descriptor'
.rdata$r:00010564                 dd offset ??_R3logic_error@std@@8 ; std::logic_error::`RTTI Class Hierarchy Descriptor'
.rdata$r:00010564 _rdata$r        ends
.rdata$r:00010564
.data$r:00010568 ; ===========================================================================
.data$r:00010568
.data$r:00010568 ; Segment type: Pure data
.data$r:00010568 ; Segment permissions: Read/Write
.data$r:00010568 _data$r         segment dword public 'DATA' use32
.data$r:00010568                 assume cs:_data$r
.data$r:00010568                 ;org 10568h
.data$r:00010568 ; COMDAT (pick any)
.data$r:00010568                 public ??_R0?AVlogic_error@std@@@8
.data$r:00010568 ; class std::logic_error `RTTI Type Descriptor'
.data$r:00010568 ??_R0?AVlogic_error@std@@@8 dd offset ??_7type_info@@6B@
.data$r:00010568                                         ; DATA XREF: .rdata$r:00010560o
.data$r:00010568                                         ; .rdata$r:std::logic_error::`RTTI Base Class Descriptor at (0,-1,0,64)'o
.data$r:00010568                                         ; const type_info::`vftable'
.data$r:0001056C                 align 10h
.data$r:00010570 a_?avlogic_erro db '.?AVlogic_error@std@@',0
.data$r:00010586                 align 4
.data$r:00010586 _data$r         ends
.data$r:00010586
.rdata$r:00010588 ; ===========================================================================
.rdata$r:00010588
.rdata$r:00010588 ; Segment type: Pure data
.rdata$r:00010588 ; Segment permissions: Read
.rdata$r:00010588 _rdata$r        segment dword public 'DATA' use32
.rdata$r:00010588                 assume cs:_rdata$r
.rdata$r:00010588                 ;org 10588h
.rdata$r:00010588 ; COMDAT (pick any)
.rdata$r:00010588                 public ??_R3logic_error@std@@8
.rdata$r:00010588 ; std::logic_error::`RTTI Class Hierarchy Descriptor'
.rdata$r:00010588 ??_R3logic_error@std@@8 db    0         ; DATA XREF: .rdata$r:00010564o
.rdata$r:00010588                                         ; .rdata$r:000105BCo
.rdata$r:00010589                 db    0
.rdata$r:0001058A                 db    0
.rdata$r:0001058B                 db    0
.rdata$r:0001058C                 db    0
.rdata$r:0001058D                 db    0
.rdata$r:0001058E                 db    0
.rdata$r:0001058F                 db    0
.rdata$r:00010590                 db    2
.rdata$r:00010591                 db    0
.rdata$r:00010592                 db    0
.rdata$r:00010593                 db    0
.rdata$r:00010594                 dd offset ??_R2logic_error@std@@8 ; std::logic_error::`RTTI Base Class Array'
.rdata$r:00010594 _rdata$r        ends
.rdata$r:00010594
.rdata$r:00010598 ; ===========================================================================
.rdata$r:00010598
.rdata$r:00010598 ; Segment type: Pure data
.rdata$r:00010598 ; Segment permissions: Read
.rdata$r:00010598 _rdata$r        segment dword public 'DATA' use32
.rdata$r:00010598                 assume cs:_rdata$r
.rdata$r:00010598                 ;org 10598h
.rdata$r:00010598 ; COMDAT (pick any)
.rdata$r:00010598                 public ??_R2logic_error@std@@8
.rdata$r:00010598 ; std::logic_error::`RTTI Base Class Array'
.rdata$r:00010598 ??_R2logic_error@std@@8 dd offset ??_R1A@?0A@EA@logic_error@std@@8
.rdata$r:00010598                                         ; DATA XREF: .rdata$r:00010594o
.rdata$r:00010598                                         ; std::logic_error::`RTTI Base Class Descriptor at (0,-1,0,64)'
.rdata$r:0001059C                 dd offset ??_R1A@?0A@EA@exception@std@@8 ; std::exception::`RTTI Base Class Descriptor at (0,-1,0,64)'
.rdata$r:000105A0                 db    0
.rdata$r:000105A1                 align 4
.rdata$r:000105A1 _rdata$r        ends
.rdata$r:000105A1
.rdata$r:000105A4 ; ===========================================================================
.rdata$r:000105A4
.rdata$r:000105A4 ; Segment type: Pure data
.rdata$r:000105A4 ; Segment permissions: Read
.rdata$r:000105A4 _rdata$r        segment dword public 'DATA' use32
.rdata$r:000105A4                 assume cs:_rdata$r
.rdata$r:000105A4                 ;org 105A4h
.rdata$r:000105A4 ; COMDAT (pick any)
.rdata$r:000105A4                 public ??_R1A@?0A@EA@logic_error@std@@8
.rdata$r:000105A4 ; std::logic_error::`RTTI Base Class Descriptor at (0, -1, 0, 64)'
.rdata$r:000105A4 ??_R1A@?0A@EA@logic_error@std@@8 dd offset ??_R0?AVlogic_error@std@@@8
.rdata$r:000105A4                                         ; DATA XREF: .rdata$r:std::logic_error::`RTTI Base Class Array'o
.rdata$r:000105A4                                         ; .rdata$r:0001060Co ...
.rdata$r:000105A4                                         ; std::logic_error `RTTI Type Descriptor'
.rdata$r:000105A8                 db    1
.rdata$r:000105A9                 db    0
.rdata$r:000105AA                 db    0
.rdata$r:000105AB                 db    0
.rdata$r:000105AC                 db    0
.rdata$r:000105AD                 db    0
.rdata$r:000105AE                 db    0
.rdata$r:000105AF                 db    0
.rdata$r:000105B0                 db 0FFh
.rdata$r:000105B1                 db 0FFh
.rdata$r:000105B2                 db 0FFh
.rdata$r:000105B3                 db 0FFh
.rdata$r:000105B4                 db    0
.rdata$r:000105B5                 db    0
.rdata$r:000105B6                 db    0
.rdata$r:000105B7                 db    0
.rdata$r:000105B8                 db  40h ; @
.rdata$r:000105B9                 db    0
.rdata$r:000105BA                 db    0
.rdata$r:000105BB                 db    0
.rdata$r:000105BC                 dd offset ??_R3logic_error@std@@8 ; std::logic_error::`RTTI Class Hierarchy Descriptor'
.rdata$r:000105BC _rdata$r        ends
.rdata$r:000105BC
.rdata$r:000105C0 ; ===========================================================================
.rdata$r:000105C0
.rdata$r:000105C0 ; Segment type: Pure data
.rdata$r:000105C0 ; Segment permissions: Read
.rdata$r:000105C0 _rdata$r        segment dword public 'DATA' use32
.rdata$r:000105C0                 assume cs:_rdata$r
.rdata$r:000105C0                 ;org 105C0h
.rdata$r:000105C0 ; COMDAT (pick any)
.rdata$r:000105C0                 public ??_R4invalid_argument@std@@6B@
.rdata$r:000105C0 ; const std::invalid_argument::`RTTI Complete Object Locator'
.rdata$r:000105C0 ??_R4invalid_argument@std@@6B@ db    0  ; DATA XREF: .rdata:0000F348o
.rdata$r:000105C1                 db    0
.rdata$r:000105C2                 db    0
.rdata$r:000105C3                 db    0
.rdata$r:000105C4                 db    0
.rdata$r:000105C5                 db    0
.rdata$r:000105C6                 db    0
.rdata$r:000105C7                 db    0
.rdata$r:000105C8                 db    0
.rdata$r:000105C9                 db    0
.rdata$r:000105CA                 db    0
.rdata$r:000105CB                 db    0
.rdata$r:000105CC                 dd offset ??_R0?AVinvalid_argument@std@@@8 ; std::invalid_argument `RTTI Type Descriptor'
.rdata$r:000105D0                 dd offset ??_R3invalid_argument@std@@8 ; std::invalid_argument::`RTTI Class Hierarchy Descriptor'
.rdata$r:000105D0 _rdata$r        ends
.rdata$r:000105D0
.data$r:000105D4 ; ===========================================================================
.data$r:000105D4
.data$r:000105D4 ; Segment type: Pure data
.data$r:000105D4 ; Segment permissions: Read/Write
.data$r:000105D4 _data$r         segment dword public 'DATA' use32
.data$r:000105D4                 assume cs:_data$r
.data$r:000105D4                 ;org 105D4h
.data$r:000105D4 ; COMDAT (pick any)
.data$r:000105D4                 public ??_R0?AVinvalid_argument@std@@@8
.data$r:000105D4 ; class std::invalid_argument `RTTI Type Descriptor'
.data$r:000105D4 ??_R0?AVinvalid_argument@std@@@8 dd offset ??_7type_info@@6B@
.data$r:000105D4                                         ; DATA XREF: .rdata$r:000105CCo
.data$r:000105D4                                         ; .rdata$r:std::invalid_argument::`RTTI Base Class Descriptor at (0,-1,0,64)'o
.data$r:000105D4                                         ; const type_info::`vftable'
.data$r:000105D8                 db    0
.data$r:000105D9                 db    0
.data$r:000105DA                 db    0
.data$r:000105DB                 db    0
.data$r:000105DC                 db  2Eh ; .
.data$r:000105DD                 db  3Fh ; ?
.data$r:000105DE                 db  41h ; A
.data$r:000105DF                 db  56h ; V
.data$r:000105E0                 db  69h ; i
.data$r:000105E1                 db  6Eh ; n
.data$r:000105E2                 db  76h ; v
.data$r:000105E3                 db  61h ; a
.data$r:000105E4                 db  6Ch ; l
.data$r:000105E5                 db  69h ; i
.data$r:000105E6                 db  64h ; d
.data$r:000105E7                 db  5Fh ; _
.data$r:000105E8                 db  61h ; a
.data$r:000105E9                 db  72h ; r
.data$r:000105EA                 db  67h ; g
.data$r:000105EB                 db  75h ; u
.data$r:000105EC                 db  6Dh ; m
.data$r:000105ED                 db  65h ; e
.data$r:000105EE                 db  6Eh ; n
.data$r:000105EF                 db  74h ; t
.data$r:000105F0                 db  40h ; @
.data$r:000105F1                 db  73h ; s
.data$r:000105F2                 db  74h ; t
.data$r:000105F3                 db  64h ; d
.data$r:000105F4                 db  40h ; @
.data$r:000105F5                 db  40h ; @
.data$r:000105F6                 db    0
.data$r:000105F7                 align 4
.data$r:000105F7 _data$r         ends
.data$r:000105F7
.rdata$r:000105F8 ; ===========================================================================
.rdata$r:000105F8
.rdata$r:000105F8 ; Segment type: Pure data
.rdata$r:000105F8 ; Segment permissions: Read
.rdata$r:000105F8 _rdata$r        segment dword public 'DATA' use32
.rdata$r:000105F8                 assume cs:_rdata$r
.rdata$r:000105F8                 ;org 105F8h
.rdata$r:000105F8 ; COMDAT (pick any)
.rdata$r:000105F8                 public ??_R3invalid_argument@std@@8
.rdata$r:000105F8 ; std::invalid_argument::`RTTI Class Hierarchy Descriptor'
.rdata$r:000105F8 ??_R3invalid_argument@std@@8 db    0    ; DATA XREF: .rdata$r:000105D0o
.rdata$r:000105F8                                         ; .rdata$r:00010630o
.rdata$r:000105F9                 db    0
.rdata$r:000105FA                 db    0
.rdata$r:000105FB                 db    0
.rdata$r:000105FC                 db    0
.rdata$r:000105FD                 db    0
.rdata$r:000105FE                 db    0
.rdata$r:000105FF                 db    0
.rdata$r:00010600                 db    3
.rdata$r:00010601                 db    0
.rdata$r:00010602                 db    0
.rdata$r:00010603                 db    0
.rdata$r:00010604                 dd offset ??_R2invalid_argument@std@@8 ; std::invalid_argument::`RTTI Base Class Array'
.rdata$r:00010604 _rdata$r        ends
.rdata$r:00010604
.rdata$r:00010608 ; ===========================================================================
.rdata$r:00010608
.rdata$r:00010608 ; Segment type: Pure data
.rdata$r:00010608 ; Segment permissions: Read
.rdata$r:00010608 _rdata$r        segment dword public 'DATA' use32
.rdata$r:00010608                 assume cs:_rdata$r
.rdata$r:00010608                 ;org 10608h
.rdata$r:00010608 ; COMDAT (pick any)
.rdata$r:00010608                 public ??_R2invalid_argument@std@@8
.rdata$r:00010608 ; std::invalid_argument::`RTTI Base Class Array'
.rdata$r:00010608 ??_R2invalid_argument@std@@8 dd offset ??_R1A@?0A@EA@invalid_argument@std@@8
.rdata$r:00010608                                         ; DATA XREF: .rdata$r:00010604o
.rdata$r:00010608                                         ; std::invalid_argument::`RTTI Base Class Descriptor at (0,-1,0,64)'
.rdata$r:0001060C                 dd offset ??_R1A@?0A@EA@logic_error@std@@8 ; std::logic_error::`RTTI Base Class Descriptor at (0,-1,0,64)'
.rdata$r:00010610                 dd offset ??_R1A@?0A@EA@exception@std@@8 ; std::exception::`RTTI Base Class Descriptor at (0,-1,0,64)'
.rdata$r:00010614                 db    0
.rdata$r:00010615                 align 4
.rdata$r:00010615 _rdata$r        ends
.rdata$r:00010615
.rdata$r:00010618 ; ===========================================================================
.rdata$r:00010618
.rdata$r:00010618 ; Segment type: Pure data
.rdata$r:00010618 ; Segment permissions: Read
.rdata$r:00010618 _rdata$r        segment dword public 'DATA' use32
.rdata$r:00010618                 assume cs:_rdata$r
.rdata$r:00010618                 ;org 10618h
.rdata$r:00010618 ; COMDAT (pick any)
.rdata$r:00010618                 public ??_R1A@?0A@EA@invalid_argument@std@@8
.rdata$r:00010618 ; std::invalid_argument::`RTTI Base Class Descriptor at (0, -1, 0, 64)'
.rdata$r:00010618 ??_R1A@?0A@EA@invalid_argument@std@@8 dd offset ??_R0?AVinvalid_argument@std@@@8
.rdata$r:00010618                                         ; DATA XREF: .rdata$r:std::invalid_argument::`RTTI Base Class Array'o
.rdata$r:00010618                                         ; std::invalid_argument `RTTI Type Descriptor'
.rdata$r:0001061C                 db    2
.rdata$r:0001061D                 db    0
.rdata$r:0001061E                 db    0
.rdata$r:0001061F                 db    0
.rdata$r:00010620                 db    0
.rdata$r:00010621                 db    0
.rdata$r:00010622                 db    0
.rdata$r:00010623                 db    0
.rdata$r:00010624                 db 0FFh
.rdata$r:00010625                 db 0FFh
.rdata$r:00010626                 db 0FFh
.rdata$r:00010627                 db 0FFh
.rdata$r:00010628                 db    0
.rdata$r:00010629                 db    0
.rdata$r:0001062A                 db    0
.rdata$r:0001062B                 db    0
.rdata$r:0001062C                 db  40h ; @
.rdata$r:0001062D                 db    0
.rdata$r:0001062E                 db    0
.rdata$r:0001062F                 db    0
.rdata$r:00010630                 dd offset ??_R3invalid_argument@std@@8 ; std::invalid_argument::`RTTI Class Hierarchy Descriptor'
.rdata$r:00010630 _rdata$r        ends
.rdata$r:00010630
.rdata$r:00010634 ; ===========================================================================
.rdata$r:00010634
.rdata$r:00010634 ; Segment type: Pure data
.rdata$r:00010634 ; Segment permissions: Read
.rdata$r:00010634 _rdata$r        segment dword public 'DATA' use32
.rdata$r:00010634                 assume cs:_rdata$r
.rdata$r:00010634                 ;org 10634h
.rdata$r:00010634 ; COMDAT (pick any)
.rdata$r:00010634                 public ??_R4out_of_range@std@@6B@
.rdata$r:00010634 ; const std::out_of_range::`RTTI Complete Object Locator'
.rdata$r:00010634 ??_R4out_of_range@std@@6B@ db    0      ; DATA XREF: .rdata:0000F354o
.rdata$r:00010635                 db    0
.rdata$r:00010636                 db    0
.rdata$r:00010637                 db    0
.rdata$r:00010638                 db    0
.rdata$r:00010639                 db    0
.rdata$r:0001063A                 db    0
.rdata$r:0001063B                 db    0
.rdata$r:0001063C                 db    0
.rdata$r:0001063D                 db    0
.rdata$r:0001063E                 db    0
.rdata$r:0001063F                 db    0
.rdata$r:00010640                 dd offset ??_R0?AVout_of_range@std@@@8 ; std::out_of_range `RTTI Type Descriptor'
.rdata$r:00010644                 dd offset ??_R3out_of_range@std@@8 ; std::out_of_range::`RTTI Class Hierarchy Descriptor'
.rdata$r:00010644 _rdata$r        ends
.rdata$r:00010644
.data$r:00010648 ; ===========================================================================
.data$r:00010648
.data$r:00010648 ; Segment type: Pure data
.data$r:00010648 ; Segment permissions: Read/Write
.data$r:00010648 _data$r         segment dword public 'DATA' use32
.data$r:00010648                 assume cs:_data$r
.data$r:00010648                 ;org 10648h
.data$r:00010648 ; COMDAT (pick any)
.data$r:00010648                 public ??_R0?AVout_of_range@std@@@8
.data$r:00010648 ; class std::out_of_range `RTTI Type Descriptor'
.data$r:00010648 ??_R0?AVout_of_range@std@@@8 dd offset ??_7type_info@@6B@
.data$r:00010648                                         ; DATA XREF: .rdata$r:00010640o
.data$r:00010648                                         ; .rdata$r:std::out_of_range::`RTTI Base Class Descriptor at (0,-1,0,64)'o
.data$r:00010648                                         ; const type_info::`vftable'
.data$r:0001064C                 align 10h
.data$r:00010650 a_?avout_of_ran db '.?AVout_of_range@std@@',0
.data$r:00010667                 align 4
.data$r:00010667 _data$r         ends
.data$r:00010667
.rdata$r:00010668 ; ===========================================================================
.rdata$r:00010668
.rdata$r:00010668 ; Segment type: Pure data
.rdata$r:00010668 ; Segment permissions: Read
.rdata$r:00010668 _rdata$r        segment dword public 'DATA' use32
.rdata$r:00010668                 assume cs:_rdata$r
.rdata$r:00010668                 ;org 10668h
.rdata$r:00010668 ; COMDAT (pick any)
.rdata$r:00010668                 public ??_R3out_of_range@std@@8
.rdata$r:00010668 ; std::out_of_range::`RTTI Class Hierarchy Descriptor'
.rdata$r:00010668 ??_R3out_of_range@std@@8 db    0        ; DATA XREF: .rdata$r:00010644o
.rdata$r:00010668                                         ; .rdata$r:000106A0o
.rdata$r:00010669                 db    0
.rdata$r:0001066A                 db    0
.rdata$r:0001066B                 db    0
.rdata$r:0001066C                 db    0
.rdata$r:0001066D                 db    0
.rdata$r:0001066E                 db    0
.rdata$r:0001066F                 db    0
.rdata$r:00010670                 db    3
.rdata$r:00010671                 db    0
.rdata$r:00010672                 db    0
.rdata$r:00010673                 db    0
.rdata$r:00010674                 dd offset ??_R2out_of_range@std@@8 ; std::out_of_range::`RTTI Base Class Array'
.rdata$r:00010674 _rdata$r        ends
.rdata$r:00010674
.rdata$r:00010678 ; ===========================================================================
.rdata$r:00010678
.rdata$r:00010678 ; Segment type: Pure data
.rdata$r:00010678 ; Segment permissions: Read
.rdata$r:00010678 _rdata$r        segment dword public 'DATA' use32
.rdata$r:00010678                 assume cs:_rdata$r
.rdata$r:00010678                 ;org 10678h
.rdata$r:00010678 ; COMDAT (pick any)
.rdata$r:00010678                 public ??_R2out_of_range@std@@8
.rdata$r:00010678 ; std::out_of_range::`RTTI Base Class Array'
.rdata$r:00010678 ??_R2out_of_range@std@@8 dd offset ??_R1A@?0A@EA@out_of_range@std@@8
.rdata$r:00010678                                         ; DATA XREF: .rdata$r:00010674o
.rdata$r:00010678                                         ; std::out_of_range::`RTTI Base Class Descriptor at (0,-1,0,64)'
.rdata$r:0001067C                 dd offset ??_R1A@?0A@EA@logic_error@std@@8 ; std::logic_error::`RTTI Base Class Descriptor at (0,-1,0,64)'
.rdata$r:00010680                 dd offset ??_R1A@?0A@EA@exception@std@@8 ; std::exception::`RTTI Base Class Descriptor at (0,-1,0,64)'
.rdata$r:00010684                 db    0
.rdata$r:00010685                 align 4
.rdata$r:00010685 _rdata$r        ends
.rdata$r:00010685
.rdata$r:00010688 ; ===========================================================================
.rdata$r:00010688
.rdata$r:00010688 ; Segment type: Pure data
.rdata$r:00010688 ; Segment permissions: Read
.rdata$r:00010688 _rdata$r        segment dword public 'DATA' use32
.rdata$r:00010688                 assume cs:_rdata$r
.rdata$r:00010688                 ;org 10688h
.rdata$r:00010688 ; COMDAT (pick any)
.rdata$r:00010688                 public ??_R1A@?0A@EA@out_of_range@std@@8
.rdata$r:00010688 ; std::out_of_range::`RTTI Base Class Descriptor at (0, -1, 0, 64)'
.rdata$r:00010688 ??_R1A@?0A@EA@out_of_range@std@@8 dd offset ??_R0?AVout_of_range@std@@@8
.rdata$r:00010688                                         ; DATA XREF: .rdata$r:std::out_of_range::`RTTI Base Class Array'o
.rdata$r:00010688                                         ; std::out_of_range `RTTI Type Descriptor'
.rdata$r:0001068C                 db    2
.rdata$r:0001068D                 db    0
.rdata$r:0001068E                 db    0
.rdata$r:0001068F                 db    0
.rdata$r:00010690                 db    0
.rdata$r:00010691                 db    0
.rdata$r:00010692                 db    0
.rdata$r:00010693                 db    0
.rdata$r:00010694                 db 0FFh
.rdata$r:00010695                 db 0FFh
.rdata$r:00010696                 db 0FFh
.rdata$r:00010697                 db 0FFh
.rdata$r:00010698                 db    0
.rdata$r:00010699                 db    0
.rdata$r:0001069A                 db    0
.rdata$r:0001069B                 db    0
.rdata$r:0001069C                 db  40h ; @
.rdata$r:0001069D                 db    0
.rdata$r:0001069E                 db    0
.rdata$r:0001069F                 db    0
.rdata$r:000106A0                 dd offset ??_R3out_of_range@std@@8 ; std::out_of_range::`RTTI Class Hierarchy Descriptor'
.rdata$r:000106A0 _rdata$r        ends
.rdata$r:000106A0
.rdata$r:000106A4 ; ===========================================================================
.rdata$r:000106A4
.rdata$r:000106A4 ; Segment type: Pure data
.rdata$r:000106A4 ; Segment permissions: Read
.rdata$r:000106A4 _rdata$r        segment dword public 'DATA' use32
.rdata$r:000106A4                 assume cs:_rdata$r
.rdata$r:000106A4                 ;org 106A4h
.rdata$r:000106A4 ; COMDAT (pick any)
.rdata$r:000106A4                 public ??_R4error_category@std@@6B@
.rdata$r:000106A4 ; const std::error_category::`RTTI Complete Object Locator'
.rdata$r:000106A4 ??_R4error_category@std@@6B@ db    0    ; DATA XREF: .rdata:0000F37Co
.rdata$r:000106A5                 db    0
.rdata$r:000106A6                 db    0
.rdata$r:000106A7                 db    0
.rdata$r:000106A8                 db    0
.rdata$r:000106A9                 db    0
.rdata$r:000106AA                 db    0
.rdata$r:000106AB                 db    0
.rdata$r:000106AC                 db    0
.rdata$r:000106AD                 db    0
.rdata$r:000106AE                 db    0
.rdata$r:000106AF                 db    0
.rdata$r:000106B0                 dd offset ??_R0?AVerror_category@std@@@8 ; std::error_category `RTTI Type Descriptor'
.rdata$r:000106B4                 dd offset ??_R3error_category@std@@8 ; std::error_category::`RTTI Class Hierarchy Descriptor'
.rdata$r:000106B4 _rdata$r        ends
.rdata$r:000106B4
.data$r:000106B8 ; ===========================================================================
.data$r:000106B8
.data$r:000106B8 ; Segment type: Pure data
.data$r:000106B8 ; Segment permissions: Read/Write
.data$r:000106B8 _data$r         segment dword public 'DATA' use32
.data$r:000106B8                 assume cs:_data$r
.data$r:000106B8                 ;org 106B8h
.data$r:000106B8 ; COMDAT (pick any)
.data$r:000106B8                 public ??_R0?AVerror_category@std@@@8
.data$r:000106B8 ; class std::error_category `RTTI Type Descriptor'
.data$r:000106B8 ??_R0?AVerror_category@std@@@8 dd offset ??_7type_info@@6B@
.data$r:000106B8                                         ; DATA XREF: .rdata$r:000106B0o
.data$r:000106B8                                         ; .rdata$r:std::error_category::`RTTI Base Class Descriptor at (0,-1,0,64)'o
.data$r:000106B8                                         ; const type_info::`vftable'
.data$r:000106BC                 align 10h
.data$r:000106C0 a_?averror_cate db '.?AVerror_category@std@@',0
.data$r:000106D9                 align 4
.data$r:000106D9 _data$r         ends
.data$r:000106D9
.rdata$r:000106DC ; ===========================================================================
.rdata$r:000106DC
.rdata$r:000106DC ; Segment type: Pure data
.rdata$r:000106DC ; Segment permissions: Read
.rdata$r:000106DC _rdata$r        segment dword public 'DATA' use32
.rdata$r:000106DC                 assume cs:_rdata$r
.rdata$r:000106DC                 ;org 106DCh
.rdata$r:000106DC ; COMDAT (pick any)
.rdata$r:000106DC                 public ??_R3error_category@std@@8
.rdata$r:000106DC ; std::error_category::`RTTI Class Hierarchy Descriptor'
.rdata$r:000106DC ??_R3error_category@std@@8 db    0      ; DATA XREF: .rdata$r:000106B4o
.rdata$r:000106DC                                         ; .rdata$r:0001070Co
.rdata$r:000106DD                 db    0
.rdata$r:000106DE                 db    0
.rdata$r:000106DF                 db    0
.rdata$r:000106E0                 db    0
.rdata$r:000106E1                 db    0
.rdata$r:000106E2                 db    0
.rdata$r:000106E3                 db    0
.rdata$r:000106E4                 db    1
.rdata$r:000106E5                 db    0
.rdata$r:000106E6                 db    0
.rdata$r:000106E7                 db    0
.rdata$r:000106E8                 dd offset ??_R2error_category@std@@8 ; std::error_category::`RTTI Base Class Array'
.rdata$r:000106E8 _rdata$r        ends
.rdata$r:000106E8
.rdata$r:000106EC ; ===========================================================================
.rdata$r:000106EC
.rdata$r:000106EC ; Segment type: Pure data
.rdata$r:000106EC ; Segment permissions: Read
.rdata$r:000106EC _rdata$r        segment dword public 'DATA' use32
.rdata$r:000106EC                 assume cs:_rdata$r
.rdata$r:000106EC                 ;org 106ECh
.rdata$r:000106EC ; COMDAT (pick any)
.rdata$r:000106EC                 public ??_R2error_category@std@@8
.rdata$r:000106EC ; std::error_category::`RTTI Base Class Array'
.rdata$r:000106EC ??_R2error_category@std@@8 dd offset ??_R1A@?0A@EA@error_category@std@@8
.rdata$r:000106EC                                         ; DATA XREF: .rdata$r:000106E8o
.rdata$r:000106EC                                         ; std::error_category::`RTTI Base Class Descriptor at (0,-1,0,64)'
.rdata$r:000106F0                 db    0
.rdata$r:000106F1                 align 4
.rdata$r:000106F1 _rdata$r        ends
.rdata$r:000106F1
.rdata$r:000106F4 ; ===========================================================================
.rdata$r:000106F4
.rdata$r:000106F4 ; Segment type: Pure data
.rdata$r:000106F4 ; Segment permissions: Read
.rdata$r:000106F4 _rdata$r        segment dword public 'DATA' use32
.rdata$r:000106F4                 assume cs:_rdata$r
.rdata$r:000106F4                 ;org 106F4h
.rdata$r:000106F4 ; COMDAT (pick any)
.rdata$r:000106F4                 public ??_R1A@?0A@EA@error_category@std@@8
.rdata$r:000106F4 ; std::error_category::`RTTI Base Class Descriptor at (0, -1, 0, 64)'
.rdata$r:000106F4 ??_R1A@?0A@EA@error_category@std@@8 dd offset ??_R0?AVerror_category@std@@@8
.rdata$r:000106F4                                         ; DATA XREF: .rdata$r:std::error_category::`RTTI Base Class Array'o
.rdata$r:000106F4                                         ; .rdata$r:00010764o ...
.rdata$r:000106F4                                         ; std::error_category `RTTI Type Descriptor'
.rdata$r:000106F8                 align 10h
.rdata$r:00010700                 db 0FFh
.rdata$r:00010701                 db 0FFh
.rdata$r:00010702                 db 0FFh
.rdata$r:00010703                 db 0FFh
.rdata$r:00010704                 db    0
.rdata$r:00010705                 db    0
.rdata$r:00010706                 db    0
.rdata$r:00010707                 db    0
.rdata$r:00010708                 db  40h ; @
.rdata$r:00010709                 db    0
.rdata$r:0001070A                 db    0
.rdata$r:0001070B                 db    0
.rdata$r:0001070C                 dd offset ??_R3error_category@std@@8 ; std::error_category::`RTTI Class Hierarchy Descriptor'
.rdata$r:0001070C _rdata$r        ends
.rdata$r:0001070C
.rdata$r:00010710 ; ===========================================================================
.rdata$r:00010710
.rdata$r:00010710 ; Segment type: Pure data
.rdata$r:00010710 ; Segment permissions: Read
.rdata$r:00010710 _rdata$r        segment dword public 'DATA' use32
.rdata$r:00010710                 assume cs:_rdata$r
.rdata$r:00010710                 ;org 10710h
.rdata$r:00010710 ; COMDAT (pick any)
.rdata$r:00010710                 public ??_R4_Generic_error_category@std@@6B@
.rdata$r:00010710 ; const std::_Generic_error_category::`RTTI Complete Object Locator'
.rdata$r:00010710 ??_R4_Generic_error_category@std@@6B@ db    0
.rdata$r:00010710                                         ; DATA XREF: .rdata:0000F398o
.rdata$r:00010711                 db    0
.rdata$r:00010712                 db    0
.rdata$r:00010713                 db    0
.rdata$r:00010714                 db    0
.rdata$r:00010715                 db    0
.rdata$r:00010716                 db    0
.rdata$r:00010717                 db    0
.rdata$r:00010718                 db    0
.rdata$r:00010719                 db    0
.rdata$r:0001071A                 db    0
.rdata$r:0001071B                 db    0
.rdata$r:0001071C                 dd offset ??_R0?AV_Generic_error_category@std@@@8 ; std::_Generic_error_category `RTTI Type Descriptor'
.rdata$r:00010720                 dd offset ??_R3_Generic_error_category@std@@8 ; std::_Generic_error_category::`RTTI Class Hierarchy Descriptor'
.rdata$r:00010720 _rdata$r        ends
.rdata$r:00010720
.data$r:00010724 ; ===========================================================================
.data$r:00010724
.data$r:00010724 ; Segment type: Pure data
.data$r:00010724 ; Segment permissions: Read/Write
.data$r:00010724 _data$r         segment dword public 'DATA' use32
.data$r:00010724                 assume cs:_data$r
.data$r:00010724                 ;org 10724h
.data$r:00010724 ; COMDAT (pick any)
.data$r:00010724                 public ??_R0?AV_Generic_error_category@std@@@8
.data$r:00010724 ; class std::_Generic_error_category `RTTI Type Descriptor'
.data$r:00010724 ??_R0?AV_Generic_error_category@std@@@8 dd offset ??_7type_info@@6B@
.data$r:00010724                                         ; DATA XREF: .rdata$r:0001071Co
.data$r:00010724                                         ; .rdata$r:std::_Generic_error_category::`RTTI Base Class Descriptor at (0,-1,0,64)'o
.data$r:00010724                                         ; const type_info::`vftable'
.data$r:00010728                 db    0
.data$r:00010729                 db    0
.data$r:0001072A                 db    0
.data$r:0001072B                 db    0
.data$r:0001072C                 db  2Eh ; .
.data$r:0001072D                 db  3Fh ; ?
.data$r:0001072E                 db  41h ; A
.data$r:0001072F                 db  56h ; V
.data$r:00010730                 db  5Fh ; _
.data$r:00010731                 db  47h ; G
.data$r:00010732                 db  65h ; e
.data$r:00010733                 db  6Eh ; n
.data$r:00010734                 db  65h ; e
.data$r:00010735                 db  72h ; r
.data$r:00010736                 db  69h ; i
.data$r:00010737                 db  63h ; c
.data$r:00010738                 db  5Fh ; _
.data$r:00010739                 db  65h ; e
.data$r:0001073A                 db  72h ; r
.data$r:0001073B                 db  72h ; r
.data$r:0001073C                 db  6Fh ; o
.data$r:0001073D                 db  72h ; r
.data$r:0001073E                 db  5Fh ; _
.data$r:0001073F                 db  63h ; c
.data$r:00010740                 db  61h ; a
.data$r:00010741                 db  74h ; t
.data$r:00010742                 db  65h ; e
.data$r:00010743                 db  67h ; g
.data$r:00010744                 db  6Fh ; o
.data$r:00010745                 db  72h ; r
.data$r:00010746                 db  79h ; y
.data$r:00010747                 db  40h ; @
.data$r:00010748                 db  73h ; s
.data$r:00010749                 db  74h ; t
.data$r:0001074A                 db  64h ; d
.data$r:0001074B                 db  40h ; @
.data$r:0001074C                 db  40h ; @
.data$r:0001074D                 db    0
.data$r:0001074E                 align 10h
.data$r:0001074E _data$r         ends
.data$r:0001074E
.rdata$r:00010750 ; ===========================================================================
.rdata$r:00010750
.rdata$r:00010750 ; Segment type: Pure data
.rdata$r:00010750 ; Segment permissions: Read
.rdata$r:00010750 _rdata$r        segment dword public 'DATA' use32
.rdata$r:00010750                 assume cs:_rdata$r
.rdata$r:00010750                 ;org 10750h
.rdata$r:00010750 ; COMDAT (pick any)
.rdata$r:00010750                 public ??_R3_Generic_error_category@std@@8
.rdata$r:00010750 ; std::_Generic_error_category::`RTTI Class Hierarchy Descriptor'
.rdata$r:00010750 ??_R3_Generic_error_category@std@@8 db    0
.rdata$r:00010750                                         ; DATA XREF: .rdata$r:00010720o
.rdata$r:00010750                                         ; .rdata$r:00010784o
.rdata$r:00010751                 db    0
.rdata$r:00010752                 db    0
.rdata$r:00010753                 db    0
.rdata$r:00010754                 db    0
.rdata$r:00010755                 db    0
.rdata$r:00010756                 db    0
.rdata$r:00010757                 db    0
.rdata$r:00010758                 db    2
.rdata$r:00010759                 db    0
.rdata$r:0001075A                 db    0
.rdata$r:0001075B                 db    0
.rdata$r:0001075C                 dd offset ??_R2_Generic_error_category@std@@8 ; std::_Generic_error_category::`RTTI Base Class Array'
.rdata$r:0001075C _rdata$r        ends
.rdata$r:0001075C
.rdata$r:00010760 ; ===========================================================================
.rdata$r:00010760
.rdata$r:00010760 ; Segment type: Pure data
.rdata$r:00010760 ; Segment permissions: Read
.rdata$r:00010760 _rdata$r        segment dword public 'DATA' use32
.rdata$r:00010760                 assume cs:_rdata$r
.rdata$r:00010760                 ;org 10760h
.rdata$r:00010760 ; COMDAT (pick any)
.rdata$r:00010760                 public ??_R2_Generic_error_category@std@@8
.rdata$r:00010760 ; std::_Generic_error_category::`RTTI Base Class Array'
.rdata$r:00010760 ??_R2_Generic_error_category@std@@8 dd offset ??_R1A@?0A@EA@_Generic_error_category@std@@8
.rdata$r:00010760                                         ; DATA XREF: .rdata$r:0001075Co
.rdata$r:00010760                                         ; std::_Generic_error_category::`RTTI Base Class Descriptor at (0,-1,0,64)'
.rdata$r:00010764                 dd offset ??_R1A@?0A@EA@error_category@std@@8 ; std::error_category::`RTTI Base Class Descriptor at (0,-1,0,64)'
.rdata$r:00010768                 db    0
.rdata$r:00010769                 align 4
.rdata$r:00010769 _rdata$r        ends
.rdata$r:00010769
.rdata$r:0001076C ; ===========================================================================
.rdata$r:0001076C
.rdata$r:0001076C ; Segment type: Pure data
.rdata$r:0001076C ; Segment permissions: Read
.rdata$r:0001076C _rdata$r        segment dword public 'DATA' use32
.rdata$r:0001076C                 assume cs:_rdata$r
.rdata$r:0001076C                 ;org 1076Ch
.rdata$r:0001076C ; COMDAT (pick any)
.rdata$r:0001076C                 public ??_R1A@?0A@EA@_Generic_error_category@std@@8
.rdata$r:0001076C ; std::_Generic_error_category::`RTTI Base Class Descriptor at (0, -1, 0, 64)'
.rdata$r:0001076C ??_R1A@?0A@EA@_Generic_error_category@std@@8 dd offset ??_R0?AV_Generic_error_category@std@@@8
.rdata$r:0001076C                                         ; DATA XREF: .rdata$r:std::_Generic_error_category::`RTTI Base Class Array'o
.rdata$r:0001076C                                         ; .rdata$r:000107DCo ...
.rdata$r:0001076C                                         ; std::_Generic_error_category `RTTI Type Descriptor'
.rdata$r:00010770                 db    1
.rdata$r:00010771                 db    0
.rdata$r:00010772                 db    0
.rdata$r:00010773                 db    0
.rdata$r:00010774                 db    0
.rdata$r:00010775                 db    0
.rdata$r:00010776                 db    0
.rdata$r:00010777                 db    0
.rdata$r:00010778                 db 0FFh
.rdata$r:00010779                 db 0FFh
.rdata$r:0001077A                 db 0FFh
.rdata$r:0001077B                 db 0FFh
.rdata$r:0001077C                 db    0
.rdata$r:0001077D                 db    0
.rdata$r:0001077E                 db    0
.rdata$r:0001077F                 db    0
.rdata$r:00010780                 db  40h ; @
.rdata$r:00010781                 db    0
.rdata$r:00010782                 db    0
.rdata$r:00010783                 db    0
.rdata$r:00010784                 dd offset ??_R3_Generic_error_category@std@@8 ; std::_Generic_error_category::`RTTI Class Hierarchy Descriptor'
.rdata$r:00010784 _rdata$r        ends
.rdata$r:00010784
.rdata$r:00010788 ; ===========================================================================
.rdata$r:00010788
.rdata$r:00010788 ; Segment type: Pure data
.rdata$r:00010788 ; Segment permissions: Read
.rdata$r:00010788 _rdata$r        segment dword public 'DATA' use32
.rdata$r:00010788                 assume cs:_rdata$r
.rdata$r:00010788                 ;org 10788h
.rdata$r:00010788 ; COMDAT (pick any)
.rdata$r:00010788                 public ??_R4_Iostream_error_category@std@@6B@
.rdata$r:00010788 ; const std::_Iostream_error_category::`RTTI Complete Object Locator'
.rdata$r:00010788 ??_R4_Iostream_error_category@std@@6B@ db    0
.rdata$r:00010788                                         ; DATA XREF: .rdata:0000F3CCo
.rdata$r:00010789                 db    0
.rdata$r:0001078A                 db    0
.rdata$r:0001078B                 db    0
.rdata$r:0001078C                 db    0
.rdata$r:0001078D                 db    0
.rdata$r:0001078E                 db    0
.rdata$r:0001078F                 db    0
.rdata$r:00010790                 db    0
.rdata$r:00010791                 db    0
.rdata$r:00010792                 db    0
.rdata$r:00010793                 db    0
.rdata$r:00010794                 dd offset ??_R0?AV_Iostream_error_category@std@@@8 ; std::_Iostream_error_category `RTTI Type Descriptor'
.rdata$r:00010798                 dd offset ??_R3_Iostream_error_category@std@@8 ; std::_Iostream_error_category::`RTTI Class Hierarchy Descriptor'
.rdata$r:00010798 _rdata$r        ends
.rdata$r:00010798
.data$r:0001079C ; ===========================================================================
.data$r:0001079C
.data$r:0001079C ; Segment type: Pure data
.data$r:0001079C ; Segment permissions: Read/Write
.data$r:0001079C _data$r         segment dword public 'DATA' use32
.data$r:0001079C                 assume cs:_data$r
.data$r:0001079C                 ;org 1079Ch
.data$r:0001079C ; COMDAT (pick any)
.data$r:0001079C                 public ??_R0?AV_Iostream_error_category@std@@@8
.data$r:0001079C ; class std::_Iostream_error_category `RTTI Type Descriptor'
.data$r:0001079C ??_R0?AV_Iostream_error_category@std@@@8 dd offset ??_7type_info@@6B@
.data$r:0001079C                                         ; DATA XREF: .rdata$r:00010794o
.data$r:0001079C                                         ; .rdata$r:std::_Iostream_error_category::`RTTI Base Class Descriptor at (0,-1,0,64)'o
.data$r:0001079C                                         ; const type_info::`vftable'
.data$r:000107A0                 db    0
.data$r:000107A1                 db    0
.data$r:000107A2                 db    0
.data$r:000107A3                 db    0
.data$r:000107A4                 db  2Eh ; .
.data$r:000107A5                 db  3Fh ; ?
.data$r:000107A6                 db  41h ; A
.data$r:000107A7                 db  56h ; V
.data$r:000107A8                 db  5Fh ; _
.data$r:000107A9                 db  49h ; I
.data$r:000107AA                 db  6Fh ; o
.data$r:000107AB                 db  73h ; s
.data$r:000107AC                 db  74h ; t
.data$r:000107AD                 db  72h ; r
.data$r:000107AE                 db  65h ; e
.data$r:000107AF                 db  61h ; a
.data$r:000107B0                 db  6Dh ; m
.data$r:000107B1                 db  5Fh ; _
.data$r:000107B2                 db  65h ; e
.data$r:000107B3                 db  72h ; r
.data$r:000107B4                 db  72h ; r
.data$r:000107B5                 db  6Fh ; o
.data$r:000107B6                 db  72h ; r
.data$r:000107B7                 db  5Fh ; _
.data$r:000107B8                 db  63h ; c
.data$r:000107B9                 db  61h ; a
.data$r:000107BA                 db  74h ; t
.data$r:000107BB                 db  65h ; e
.data$r:000107BC                 db  67h ; g
.data$r:000107BD                 db  6Fh ; o
.data$r:000107BE                 db  72h ; r
.data$r:000107BF                 db  79h ; y
.data$r:000107C0                 db  40h ; @
.data$r:000107C1                 db  73h ; s
.data$r:000107C2                 db  74h ; t
.data$r:000107C3                 db  64h ; d
.data$r:000107C4                 db  40h ; @
.data$r:000107C5                 db  40h ; @
.data$r:000107C6                 db    0
.data$r:000107C7                 align 4
.data$r:000107C7 _data$r         ends
.data$r:000107C7
.rdata$r:000107C8 ; ===========================================================================
.rdata$r:000107C8
.rdata$r:000107C8 ; Segment type: Pure data
.rdata$r:000107C8 ; Segment permissions: Read
.rdata$r:000107C8 _rdata$r        segment dword public 'DATA' use32
.rdata$r:000107C8                 assume cs:_rdata$r
.rdata$r:000107C8                 ;org 107C8h
.rdata$r:000107C8 ; COMDAT (pick any)
.rdata$r:000107C8                 public ??_R3_Iostream_error_category@std@@8
.rdata$r:000107C8 ; std::_Iostream_error_category::`RTTI Class Hierarchy Descriptor'
.rdata$r:000107C8 ??_R3_Iostream_error_category@std@@8 db    0
.rdata$r:000107C8                                         ; DATA XREF: .rdata$r:00010798o
.rdata$r:000107C8                                         ; .rdata$r:00010800o
.rdata$r:000107C9                 db    0
.rdata$r:000107CA                 db    0
.rdata$r:000107CB                 db    0
.rdata$r:000107CC                 db    0
.rdata$r:000107CD                 db    0
.rdata$r:000107CE                 db    0
.rdata$r:000107CF                 db    0
.rdata$r:000107D0                 db    3
.rdata$r:000107D1                 db    0
.rdata$r:000107D2                 db    0
.rdata$r:000107D3                 db    0
.rdata$r:000107D4                 dd offset ??_R2_Iostream_error_category@std@@8 ; std::_Iostream_error_category::`RTTI Base Class Array'
.rdata$r:000107D4 _rdata$r        ends
.rdata$r:000107D4
.rdata$r:000107D8 ; ===========================================================================
.rdata$r:000107D8
.rdata$r:000107D8 ; Segment type: Pure data
.rdata$r:000107D8 ; Segment permissions: Read
.rdata$r:000107D8 _rdata$r        segment dword public 'DATA' use32
.rdata$r:000107D8                 assume cs:_rdata$r
.rdata$r:000107D8                 ;org 107D8h
.rdata$r:000107D8 ; COMDAT (pick any)
.rdata$r:000107D8                 public ??_R2_Iostream_error_category@std@@8
.rdata$r:000107D8 ; std::_Iostream_error_category::`RTTI Base Class Array'
.rdata$r:000107D8 ??_R2_Iostream_error_category@std@@8 dd offset ??_R1A@?0A@EA@_Iostream_error_category@std@@8
.rdata$r:000107D8                                         ; DATA XREF: .rdata$r:000107D4o
.rdata$r:000107D8                                         ; std::_Iostream_error_category::`RTTI Base Class Descriptor at (0,-1,0,64)'
.rdata$r:000107DC                 dd offset ??_R1A@?0A@EA@_Generic_error_category@std@@8 ; std::_Generic_error_category::`RTTI Base Class Descriptor at (0,-1,0,64)'
.rdata$r:000107E0                 dd offset ??_R1A@?0A@EA@error_category@std@@8 ; std::error_category::`RTTI Base Class Descriptor at (0,-1,0,64)'
.rdata$r:000107E4                 db    0
.rdata$r:000107E5                 align 4
.rdata$r:000107E5 _rdata$r        ends
.rdata$r:000107E5
.rdata$r:000107E8 ; ===========================================================================
.rdata$r:000107E8
.rdata$r:000107E8 ; Segment type: Pure data
.rdata$r:000107E8 ; Segment permissions: Read
.rdata$r:000107E8 _rdata$r        segment dword public 'DATA' use32
.rdata$r:000107E8                 assume cs:_rdata$r
.rdata$r:000107E8                 ;org 107E8h
.rdata$r:000107E8 ; COMDAT (pick any)
.rdata$r:000107E8                 public ??_R1A@?0A@EA@_Iostream_error_category@std@@8
.rdata$r:000107E8 ; std::_Iostream_error_category::`RTTI Base Class Descriptor at (0, -1, 0, 64)'
.rdata$r:000107E8 ??_R1A@?0A@EA@_Iostream_error_category@std@@8 dd offset ??_R0?AV_Iostream_error_category@std@@@8
.rdata$r:000107E8                                         ; DATA XREF: .rdata$r:std::_Iostream_error_category::`RTTI Base Class Array'o
.rdata$r:000107E8                                         ; std::_Iostream_error_category `RTTI Type Descriptor'
.rdata$r:000107EC                 db    2
.rdata$r:000107ED                 db    0
.rdata$r:000107EE                 db    0
.rdata$r:000107EF                 db    0
.rdata$r:000107F0                 db    0
.rdata$r:000107F1                 db    0
.rdata$r:000107F2                 db    0
.rdata$r:000107F3                 db    0
.rdata$r:000107F4                 db 0FFh
.rdata$r:000107F5                 db 0FFh
.rdata$r:000107F6                 db 0FFh
.rdata$r:000107F7                 db 0FFh
.rdata$r:000107F8                 db    0
.rdata$r:000107F9                 db    0
.rdata$r:000107FA                 db    0
.rdata$r:000107FB                 db    0
.rdata$r:000107FC                 db  40h ; @
.rdata$r:000107FD                 db    0
.rdata$r:000107FE                 db    0
.rdata$r:000107FF                 db    0
.rdata$r:00010800                 dd offset ??_R3_Iostream_error_category@std@@8 ; std::_Iostream_error_category::`RTTI Class Hierarchy Descriptor'
.rdata$r:00010800 _rdata$r        ends
.rdata$r:00010800
.rdata$r:00010804 ; ===========================================================================
.rdata$r:00010804
.rdata$r:00010804 ; Segment type: Pure data
.rdata$r:00010804 ; Segment permissions: Read
.rdata$r:00010804 _rdata$r        segment dword public 'DATA' use32
.rdata$r:00010804                 assume cs:_rdata$r
.rdata$r:00010804                 ;org 10804h
.rdata$r:00010804 ; COMDAT (pick any)
.rdata$r:00010804                 public ??_R4_System_error_category@std@@6B@
.rdata$r:00010804 ; const std::_System_error_category::`RTTI Complete Object Locator'
.rdata$r:00010804 ??_R4_System_error_category@std@@6B@ db    0 ; DATA XREF: .rdata:0000F40Co
.rdata$r:00010805                 db    0
.rdata$r:00010806                 db    0
.rdata$r:00010807                 db    0
.rdata$r:00010808                 db    0
.rdata$r:00010809                 db    0
.rdata$r:0001080A                 db    0
.rdata$r:0001080B                 db    0
.rdata$r:0001080C                 db    0
.rdata$r:0001080D                 db    0
.rdata$r:0001080E                 db    0
.rdata$r:0001080F                 db    0
.rdata$r:00010810                 dd offset ??_R0?AV_System_error_category@std@@@8 ; std::_System_error_category `RTTI Type Descriptor'
.rdata$r:00010814                 dd offset ??_R3_System_error_category@std@@8 ; std::_System_error_category::`RTTI Class Hierarchy Descriptor'
.rdata$r:00010814 _rdata$r        ends
.rdata$r:00010814
.data$r:00010818 ; ===========================================================================
.data$r:00010818
.data$r:00010818 ; Segment type: Pure data
.data$r:00010818 ; Segment permissions: Read/Write
.data$r:00010818 _data$r         segment dword public 'DATA' use32
.data$r:00010818                 assume cs:_data$r
.data$r:00010818                 ;org 10818h
.data$r:00010818 ; COMDAT (pick any)
.data$r:00010818                 public ??_R0?AV_System_error_category@std@@@8
.data$r:00010818 ; class std::_System_error_category `RTTI Type Descriptor'
.data$r:00010818 ??_R0?AV_System_error_category@std@@@8 dd offset ??_7type_info@@6B@
.data$r:00010818                                         ; DATA XREF: .rdata$r:00010810o
.data$r:00010818                                         ; .rdata$r:std::_System_error_category::`RTTI Base Class Descriptor at (0,-1,0,64)'o
.data$r:00010818                                         ; const type_info::`vftable'
.data$r:0001081C                 align 10h
.data$r:00010820 a_?av_system_er db '.?AV_System_error_category@std@@',0
.data$r:00010841                 align 4
.data$r:00010841 _data$r         ends
.data$r:00010841
.rdata$r:00010844 ; ===========================================================================
.rdata$r:00010844
.rdata$r:00010844 ; Segment type: Pure data
.rdata$r:00010844 ; Segment permissions: Read
.rdata$r:00010844 _rdata$r        segment dword public 'DATA' use32
.rdata$r:00010844                 assume cs:_rdata$r
.rdata$r:00010844                 ;org 10844h
.rdata$r:00010844 ; COMDAT (pick any)
.rdata$r:00010844                 public ??_R3_System_error_category@std@@8
.rdata$r:00010844 ; std::_System_error_category::`RTTI Class Hierarchy Descriptor'
.rdata$r:00010844 ??_R3_System_error_category@std@@8 db    0 ; DATA XREF: .rdata$r:00010814o
.rdata$r:00010844                                         ; .rdata$r:0001087Co
.rdata$r:00010845                 db    0
.rdata$r:00010846                 db    0
.rdata$r:00010847                 db    0
.rdata$r:00010848                 db    0
.rdata$r:00010849                 db    0
.rdata$r:0001084A                 db    0
.rdata$r:0001084B                 db    0
.rdata$r:0001084C                 db    3
.rdata$r:0001084D                 db    0
.rdata$r:0001084E                 db    0
.rdata$r:0001084F                 db    0
.rdata$r:00010850                 dd offset ??_R2_System_error_category@std@@8 ; std::_System_error_category::`RTTI Base Class Array'
.rdata$r:00010850 _rdata$r        ends
.rdata$r:00010850
.rdata$r:00010854 ; ===========================================================================
.rdata$r:00010854
.rdata$r:00010854 ; Segment type: Pure data
.rdata$r:00010854 ; Segment permissions: Read
.rdata$r:00010854 _rdata$r        segment dword public 'DATA' use32
.rdata$r:00010854                 assume cs:_rdata$r
.rdata$r:00010854                 ;org 10854h
.rdata$r:00010854 ; COMDAT (pick any)
.rdata$r:00010854                 public ??_R2_System_error_category@std@@8
.rdata$r:00010854 ; std::_System_error_category::`RTTI Base Class Array'
.rdata$r:00010854 ??_R2_System_error_category@std@@8 dd offset ??_R1A@?0A@EA@_System_error_category@std@@8
.rdata$r:00010854                                         ; DATA XREF: .rdata$r:00010850o
.rdata$r:00010854                                         ; std::_System_error_category::`RTTI Base Class Descriptor at (0,-1,0,64)'
.rdata$r:00010858                 dd offset ??_R1A@?0A@EA@_Generic_error_category@std@@8 ; std::_Generic_error_category::`RTTI Base Class Descriptor at (0,-1,0,64)'
.rdata$r:0001085C                 dd offset ??_R1A@?0A@EA@error_category@std@@8 ; std::error_category::`RTTI Base Class Descriptor at (0,-1,0,64)'
.rdata$r:00010860                 db    0
.rdata$r:00010861                 align 4
.rdata$r:00010861 _rdata$r        ends
.rdata$r:00010861
.rdata$r:00010864 ; ===========================================================================
.rdata$r:00010864
.rdata$r:00010864 ; Segment type: Pure data
.rdata$r:00010864 ; Segment permissions: Read
.rdata$r:00010864 _rdata$r        segment dword public 'DATA' use32
.rdata$r:00010864                 assume cs:_rdata$r
.rdata$r:00010864                 ;org 10864h
.rdata$r:00010864 ; COMDAT (pick any)
.rdata$r:00010864                 public ??_R1A@?0A@EA@_System_error_category@std@@8
.rdata$r:00010864 ; std::_System_error_category::`RTTI Base Class Descriptor at (0, -1, 0, 64)'
.rdata$r:00010864 ??_R1A@?0A@EA@_System_error_category@std@@8 dd offset ??_R0?AV_System_error_category@std@@@8
.rdata$r:00010864                                         ; DATA XREF: .rdata$r:std::_System_error_category::`RTTI Base Class Array'o
.rdata$r:00010864                                         ; std::_System_error_category `RTTI Type Descriptor'
.rdata$r:00010868                 db    2
.rdata$r:00010869                 db    0
.rdata$r:0001086A                 db    0
.rdata$r:0001086B                 db    0
.rdata$r:0001086C                 db    0
.rdata$r:0001086D                 db    0
.rdata$r:0001086E                 db    0
.rdata$r:0001086F                 db    0
.rdata$r:00010870                 db 0FFh
.rdata$r:00010871                 db 0FFh
.rdata$r:00010872                 db 0FFh
.rdata$r:00010873                 db 0FFh
.rdata$r:00010874                 db    0
.rdata$r:00010875                 db    0
.rdata$r:00010876                 db    0
.rdata$r:00010877                 db    0
.rdata$r:00010878                 db  40h ; @
.rdata$r:00010879                 db    0
.rdata$r:0001087A                 db    0
.rdata$r:0001087B                 db    0
.rdata$r:0001087C                 dd offset ??_R3_System_error_category@std@@8 ; std::_System_error_category::`RTTI Class Hierarchy Descriptor'
.rdata$r:0001087C _rdata$r        ends
.rdata$r:0001087C
.CRT$XCU:00010880 ; ===========================================================================
.CRT$XCU:00010880
.CRT$XCU:00010880 ; Segment type: Pure data
.CRT$XCU:00010880 ; Segment permissions: Read
.CRT$XCU:00010880 _CRT$XCU        segment dword public 'DATA' use32
.CRT$XCU:00010880                 assume cs:_CRT$XCU
.CRT$XCU:00010880                 ;org 10880h
.CRT$XCU:00010880 _piecewise_construct$initializer$ dd offset ??__Epiecewise_construct@std@@YAXXZ ; std::`dynamic initializer for 'piecewise_construct''(void)
.CRT$XCU:00010884 _allocator_arg$initializer$ dd offset ??__Eallocator_arg@std@@YAXXZ ; std::`dynamic initializer for 'allocator_arg''(void)
.CRT$XCU:00010888 ; protected: static void (__cdecl *WcharMbcsConvertor::_pSelf$initializer$)(void)
.CRT$XCU:00010888 ?_pSelf$initializer$@WcharMbcsConvertor@@1P6AXXZA dd offset ??__E?_pSelf@WcharMbcsConvertor@@1PAV1@A@@YAXXZ ; `dynamic initializer for 'WcharMbcsConvertor * WcharMbcsConvertor::_pSelf''(void)
.CRT$XCU:00010888 _CRT$XCU        ends
.CRT$XCU:00010888
.CRT$XCU:0001088C ; ===========================================================================
.CRT$XCU:0001088C
.CRT$XCU:0001088C ; Segment type: Pure data
.CRT$XCU:0001088C ; Segment permissions: Read
.CRT$XCU:0001088C _CRT$XCU        segment dword public 'DATA' use32
.CRT$XCU:0001088C                 assume cs:_CRT$XCU
.CRT$XCU:0001088C                 ;org 1088Ch
.CRT$XCU:0001088C ; COMDAT (pick associative to section at F430)
.CRT$XCU:0001088C ; public: static void (__cdecl *std::_Error_objects<int>::_Generic_object$initializer$)(void)
.CRT$XCU:0001088C ?_Generic_object$initializer$@?$_Error_objects@H@std@@2P6AXXZA dd offset ??__E?_Generic_object@?$_Error_objects@H@std@@2V_Generic_error_category@2@A@@YAXXZ ; `dynamic initializer for 'std::_Generic_error_category std::_Error_objects<int>::_Generic_object''(void)
.CRT$XCU:0001088C _CRT$XCU        ends
.CRT$XCU:0001088C
.CRT$XCU:00010890 ; ===========================================================================
.CRT$XCU:00010890
.CRT$XCU:00010890 ; Segment type: Pure data
.CRT$XCU:00010890 ; Segment permissions: Read
.CRT$XCU:00010890 _CRT$XCU        segment dword public 'DATA' use32
.CRT$XCU:00010890                 assume cs:_CRT$XCU
.CRT$XCU:00010890                 ;org 10890h
.CRT$XCU:00010890 ; COMDAT (pick associative to section at F434)
.CRT$XCU:00010890 ; public: static void (__cdecl *std::_Error_objects<int>::_Iostream_object$initializer$)(void)
.CRT$XCU:00010890 ?_Iostream_object$initializer$@?$_Error_objects@H@std@@2P6AXXZA dd offset ??__E?_Iostream_object@?$_Error_objects@H@std@@2V_Iostream_error_category@2@A@@YAXXZ ; `dynamic initializer for 'std::_Iostream_error_category std::_Error_objects<int>::_Iostream_object''(void)
.CRT$XCU:00010890 _CRT$XCU        ends
.CRT$XCU:00010890
.CRT$XCU:00010894 ; ===========================================================================
.CRT$XCU:00010894
.CRT$XCU:00010894 ; Segment type: Pure data
.CRT$XCU:00010894 ; Segment permissions: Read
.CRT$XCU:00010894 _CRT$XCU        segment dword public 'DATA' use32
.CRT$XCU:00010894                 assume cs:_CRT$XCU
.CRT$XCU:00010894                 ;org 10894h
.CRT$XCU:00010894 ; COMDAT (pick associative to section at F438)
.CRT$XCU:00010894 ; public: static void (__cdecl *std::_Error_objects<int>::_System_object$initializer$)(void)
.CRT$XCU:00010894 ?_System_object$initializer$@?$_Error_objects@H@std@@2P6AXXZA dd offset ??__E?_System_object@?$_Error_objects@H@std@@2V_System_error_category@2@A@@YAXXZ ; `dynamic initializer for 'std::_System_error_category std::_Error_objects<int>::_System_object''(void)
.CRT$XCU:00010894 _CRT$XCU        ends
.CRT$XCU:00010894
.CRT$XCU:00010898 ; ===========================================================================
.CRT$XCU:00010898
.CRT$XCU:00010898 ; Segment type: Pure data
.CRT$XCU:00010898 ; Segment permissions: Read
.CRT$XCU:00010898 _CRT$XCU        segment dword public 'DATA' use32
.CRT$XCU:00010898                 assume cs:_CRT$XCU
.CRT$XCU:00010898                 ;org 10898h
.CRT$XCU:00010898 ; COMDAT (pick associative to section at F440)
.CRT$XCU:00010898 ; public: static void (__cdecl *std::num_put<char, class std::back_insert_iterator<class std::basic_string<char, struct std::char_traits<char>, class std::allocator<char>>>>::id$initializer$)(void)
.CRT$XCU:00010898 ?id$initializer$@?$num_put@DV?$back_insert_iterator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@std@@2P6AXXZA dd offset ??__E?id@?$num_put@DV?$back_insert_iterator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@std@@2V0locale@2@A@@YAXXZ ; `dynamic initializer for 'std::locale::id std::num_put<char,std::back_insert_iterator<std::basic_string<char,std::char_traits<char>,std::allocator<char>>>>::id''(void)
.CRT$XCU:00010898 _CRT$XCU        ends
.CRT$XCU:00010898
.CRT$XCU:0001089C ; ===========================================================================
.CRT$XCU:0001089C
.CRT$XCU:0001089C ; Segment type: Pure data
.CRT$XCU:0001089C ; Segment permissions: Read
.CRT$XCU:0001089C _CRT$XCU        segment dword public 'DATA' use32
.CRT$XCU:0001089C                 assume cs:_CRT$XCU
.CRT$XCU:0001089C                 ;org 1089Ch
.CRT$XCU:0001089C ; COMDAT (pick associative to section at F444)
.CRT$XCU:0001089C ; public: static void (__cdecl *std::num_put<wchar_t, class std::back_insert_iterator<class std::basic_string<wchar_t, struct std::char_traits<wchar_t>, class std::allocator<wchar_t>>>>::id$initializer$)(void)
.CRT$XCU:0001089C ?id$initializer$@?$num_put@_WV?$back_insert_iterator@V?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@@std@@@std@@2P6AXXZA dd offset ??__E?id@?$num_put@_WV?$back_insert_iterator@V?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@@std@@@std@@2V0locale@2@A@@YAXXZ ; `dynamic initializer for 'std::locale::id std::num_put<wchar_t,std::back_insert_iterator<std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>>>>::id''(void)
.CRT$XCU:0001089C _CRT$XCU        ends
.CRT$XCU:0001089C
.CRT$XCU:000108A0 ; ===========================================================================
.CRT$XCU:000108A0
.CRT$XCU:000108A0 ; Segment type: Pure data
.CRT$XCU:000108A0 ; Segment permissions: Read
.CRT$XCU:000108A0 _CRT$XCU        segment dword public 'DATA' use32
.CRT$XCU:000108A0                 assume cs:_CRT$XCU
.CRT$XCU:000108A0                 ;org 108A0h
.CRT$XCU:000108A0 ; COMDAT (pick associative to section at F67C)
.CRT$XCU:000108A0 ; public: static void (__cdecl *std::numpunct<char>::id$initializer$)(void)
.CRT$XCU:000108A0 ?id$initializer$@?$numpunct@D@std@@2P6AXXZA dd offset ??__E?id@?$numpunct@D@std@@2V0locale@2@A@@YAXXZ ; `dynamic initializer for 'std::locale::id std::numpunct<char>::id''(void)
.CRT$XCU:000108A0 _CRT$XCU        ends
.CRT$XCU:000108A0
.CRT$XCU:000108A4 ; ===========================================================================
.CRT$XCU:000108A4
.CRT$XCU:000108A4 ; Segment type: Pure data
.CRT$XCU:000108A4 ; Segment permissions: Read
.CRT$XCU:000108A4 _CRT$XCU        segment dword public 'DATA' use32
.CRT$XCU:000108A4                 assume cs:_CRT$XCU
.CRT$XCU:000108A4                 ;org 108A4h
.CRT$XCU:000108A4 ; COMDAT (pick associative to section at F680)
.CRT$XCU:000108A4 ; public: static void (__cdecl *std::numpunct<wchar_t>::id$initializer$)(void)
.CRT$XCU:000108A4 ?id$initializer$@?$numpunct@_W@std@@2P6AXXZA dd offset ??__E?id@?$numpunct@_W@std@@2V0locale@2@A@@YAXXZ ; `dynamic initializer for 'std::locale::id std::numpunct<wchar_t>::id''(void)
.CRT$XCU:000108A4 _CRT$XCU        ends
.CRT$XCU:000108A4
UNDEF:000108B0 ; ===========================================================================
UNDEF:000108B0
UNDEF:000108B0 ; Segment type: Externs
UNDEF:000108B0 ; UNDEF
UNDEF:000108B0                 extrn __purecall:near   ; DATA XREF: .rdata:0000F384o
UNDEF:000108B0                                         ; .rdata:0000F388o
UNDEF:000108B4 ; void *__cdecl operator new(unsigned int)
UNDEF:000108B4                 extrn ??2@YAPAXI@Z:near ; CODE XREF: stodLocale(std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>> const &,localeinfo_struct *,uint *)+5Cp
UNDEF:000108B4                                         ; stodLocale(std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>> const &,localeinfo_struct *,uint *)+BAp ...
UNDEF:000108B8 ; void __cdecl operator delete(void *)
UNDEF:000108B8                 extrn ??3@YAXPAX@Z:near ; CODE XREF: __unwindfunclet$?stodLocale@@YANABV?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@PAUlocaleinfo_struct@@PAI@Z$0+4p
UNDEF:000108B8                                         ; __unwindfunclet$?stodLocale@@YANABV?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@PAUlocaleinfo_struct@@PAI@Z$1+4p ...
UNDEF:000108BC ; int __cdecl atexit(void (__cdecl *)())
UNDEF:000108BC                 extrn _atexit:near      ; CODE XREF: `dynamic initializer for 'std::_Generic_error_category std::_Error_objects<int>::_Generic_object''(void)+12p
UNDEF:000108BC                                         ; `dynamic initializer for 'std::_Iostream_error_category std::_Error_objects<int>::_Iostream_object''(void)+12p ...
UNDEF:000108C0                 extrn ___report_rangecheckfailure:near
UNDEF:000108C0                                         ; CODE XREF: folderBrowser(HWND__ *,int,wchar_t const *):loc_1C3p
UNDEF:000108C0                                         ; purgeMenuItemString(wchar_t const *,bool):loc_5F2p ...
UNDEF:000108C4                 extrn __invalid_parameter:near
UNDEF:000108C4                                         ; CODE XREF: std::vector<char,std::allocator<char>>::operator[](uint)+74p
UNDEF:000108C4                                         ; std::vector<wchar_t,std::allocator<wchar_t>>::operator[](uint)+74p ...
UNDEF:000108C8 ; _DWORD __thiscall std::_Lockit::_Lockit(std::_Lockit *__hidden this, int)
UNDEF:000108C8                 extrn ??0_Lockit@std@@QAE@H@Z:near
UNDEF:000108C8                                         ; CODE XREF: std::_Iterator_base12::~_Iterator_base12(void)+2Dp
UNDEF:000108C8                                         ; std::_Iterator_base12::operator=(std::_Iterator_base12 const &)+55p ...
UNDEF:000108CC ; _DWORD __thiscall std::_Lockit::~_Lockit(std::_Lockit *__hidden this)
UNDEF:000108CC                 extrn ??1_Lockit@std@@QAE@XZ:near
UNDEF:000108CC                                         ; CODE XREF: std::_Iterator_base12::~_Iterator_base12(void)+4Bp
UNDEF:000108CC                                         ; __unwindfunclet$??1_Iterator_base12@std@@QAE@XZ$0+3j ...
UNDEF:000108D0 ; int *__cdecl _errno()
UNDEF:000108D0                 extrn __errno:near      ; CODE XREF: stodLocale(std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>> const &,localeinfo_struct *,uint *)+30p
UNDEF:000108D0                                         ; stodLocale(std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>> const &,localeinfo_struct *,uint *):loc_2386p
UNDEF:000108D4 ; int __cdecl abs(int X)
UNDEF:000108D4                 extrn _abs:near         ; CODE XREF: intToString(int)+66p
UNDEF:000108D4                                         ; intToString(int)+A4p
UNDEF:000108D8 ; double __cdecl _wcstod_l(const wchar_t *Str, wchar_t **EndPtr, _locale_t Locale)
UNDEF:000108D8                 extrn __wcstod_l:near   ; CODE XREF: stodLocale(std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>> const &,localeinfo_struct *,uint *)+47p
UNDEF:000108DC                 extrn __hypot:near      ; CODE XREF: _hypot+1Dp
UNDEF:000108E0 ; FILE *__cdecl _wfopen(const wchar_t *Filename, const wchar_t *Mode)
UNDEF:000108E0                 extrn __wfopen:near     ; CODE XREF: writeLog(wchar_t const *,char const *)+Dp
UNDEF:000108E0                                         ; getFileContent(wchar_t const *)+5Fp ...
UNDEF:000108E4 ; errno_t __cdecl wcscpy_s(wchar_t *Dst, rsize_t SizeInWords, const wchar_t *Src)
UNDEF:000108E4                 extrn _wcscpy_s:near    ; CODE XREF: str2Clipboard(std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>> const &,HWND__ *)+BBp
UNDEF:000108E8 ; size_t __cdecl wcslen(const wchar_t *Str)
UNDEF:000108E8                 extrn _wcslen:near      ; CODE XREF: std::char_traits<wchar_t>::length(wchar_t const *)+1Bp
UNDEF:000108EC ; int __cdecl wcsicmp(const wchar_t *Str1, const wchar_t *Str2)
UNDEF:000108EC                 extrn _wcsicmp:near     ; CODE XREF: isInList(wchar_t const *,wchar_t const *)+DFp
UNDEF:000108F0 ; void *__cdecl memmove(void *Dst, const void *Src, size_t Size)
UNDEF:000108F0                 extrn _memmove:near     ; CODE XREF: std::_Uninit_move<wchar_t,wchar_t,wchar_t>(wchar_t *,wchar_t *,wchar_t *,std::_Wrap_alloc<std::allocator<wchar_t>> &,wchar_t *,std::_Scalar_ptr_iterator_tag)+4Dp
UNDEF:000108F0                                         ; std::char_traits<char>::move(char *,char const *,uint)+1Ep ...
UNDEF:000108F4 ; void *__cdecl memcpy(void *Dst, const void *Src, size_t Size)
UNDEF:000108F4                 extrn _memcpy:near      ; CODE XREF: std::char_traits<char>::copy(char *,char const *,uint)+1Ep
UNDEF:000108F4                                         ; _wmemcpy+11p
UNDEF:000108F8 ; void *__cdecl memset(void *Dst, int Val, size_t Size)
UNDEF:000108F8                 extrn _memset:near      ; CODE XREF: folderBrowser(HWND__ *,int,wchar_t const *)+3Dp
UNDEF:000108F8                                         ; getFolderName(HWND__ *,wchar_t const *)+76p ...
UNDEF:000108FC ; size_t __cdecl strlen(const char *Str)
UNDEF:000108FC                 extrn _strlen:near      ; CODE XREF: writeLog(wchar_t const *,char const *)+20p
UNDEF:000108FC                                         ; writeFileContent(wchar_t const *,char const *)+20p ...
UNDEF:00010900 ; _DWORD __thiscall std::exception::exception(std::exception *__hidden this, const char *const *)
UNDEF:00010900                 extrn ??0exception@std@@QAE@ABQBD@Z:near
UNDEF:00010900                                         ; CODE XREF: std::logic_error::logic_error(char const *)+2Dp
UNDEF:00010904 ; _DWORD __thiscall std::exception::~exception(std::exception *__hidden this)
UNDEF:00010904                 extrn ??1exception@std@@UAE@XZ:near
UNDEF:00010904                                         ; CODE XREF: __unwindfunclet$??0logic_error@std@@QAE@PBD@Z$0+3j
UNDEF:00010904                                         ; std::logic_error::~logic_error(void)+37p ...
UNDEF:00010908 ; public: virtual char const * __thiscall std::exception::what(void)const
UNDEF:00010908                 extrn ?what@exception@std@@UBEPBDXZ:near
UNDEF:00010908                                         ; DATA XREF: .rdata:0000F340o
UNDEF:00010908                                         ; .rdata:0000F350o ...
UNDEF:0001090C ; void __cdecl operator delete[](void *)
UNDEF:0001090C                 extrn ??_V@YAXPAX@Z:near
UNDEF:0001090C                                         ; CODE XREF: WcharMbcsConvertor::StringBuffer<char>::~StringBuffer<char>(void)+1Ep
UNDEF:0001090C                                         ; WcharMbcsConvertor::StringBuffer<wchar_t>::~StringBuffer<wchar_t>(void)+1Ep ...
UNDEF:00010910 ; void *__cdecl operator new[](unsigned int)
UNDEF:00010910                 extrn ??_U@YAPAXI@Z:near
UNDEF:00010910                                         ; CODE XREF: WcharMbcsConvertor::StringBuffer<char>::sizeTo(uint)+56p
UNDEF:00010910                                         ; WcharMbcsConvertor::StringBuffer<wchar_t>::sizeTo(uint)+66p
UNDEF:00010914 ; int __cdecl fclose(FILE *File)
UNDEF:00010914                 extrn _fclose:near      ; CODE XREF: writeLog(wchar_t const *,char const *)+55p
UNDEF:00010914                                         ; getFileContent(wchar_t const *)+13Bp ...
UNDEF:00010918 ; int __cdecl fflush(FILE *File)
UNDEF:00010918                 extrn _fflush:near      ; CODE XREF: writeLog(wchar_t const *,char const *)+49p
UNDEF:00010918                                         ; writeFileContent(wchar_t const *,char const *)+3Bp
UNDEF:0001091C ; int __cdecl fputc(int Ch, FILE *File)
UNDEF:0001091C                 extrn _fputc:near       ; CODE XREF: writeLog(wchar_t const *,char const *)+3Dp
UNDEF:00010920 ; size_t __cdecl fread(void *DstBuf, size_t ElementSize, size_t Count, FILE *File)
UNDEF:00010920                 extrn _fread:near       ; CODE XREF: getFileContent(wchar_t const *)+8Cp
UNDEF:00010924 ; size_t __cdecl fwrite(const void *Str, size_t Size, size_t Count, FILE *File)
UNDEF:00010924                 extrn _fwrite:near      ; CODE XREF: writeLog(wchar_t const *,char const *)+2Fp
UNDEF:00010924                                         ; writeFileContent(wchar_t const *,char const *)+2Fp
UNDEF:00010928                 extrn __CrtDbgReportW:near
UNDEF:00010928                                         ; CODE XREF: std::vector<char,std::allocator<char>>::operator[](uint)+50p
UNDEF:00010928                                         ; std::vector<wchar_t,std::allocator<wchar_t>>::operator[](uint)+50p ...
UNDEF:0001092C ; void __cdecl std::_Debug_message(const wchar_t *, const wchar_t *, unsigned int)
UNDEF:0001092C                 extrn ?_Debug_message@std@@YAXPB_W0I@Z:near
UNDEF:0001092C                                         ; CODE XREF: std::_Debug_pointer<int (int)>(int (*)(int),wchar_t const *,uint)+16p
UNDEF:0001092C                                         ; std::_Debug_pointer<char>(char const *,wchar_t const *,uint)+16p ...
UNDEF:00010930 ; void __cdecl std::_Xbad_alloc()
UNDEF:00010930                 extrn ?_Xbad_alloc@std@@YAXXZ:near
UNDEF:00010930                                         ; CODE XREF: std::_Allocate<char>(uint,char *):loc_33AEp
UNDEF:00010930                                         ; std::_Allocate<std::_Container_proxy>(uint,std::_Container_proxy *):loc_33F0p ...
UNDEF:00010934 ; void __cdecl std::_Xlength_error(const char *)
UNDEF:00010934                 extrn ?_Xlength_error@std@@YAXPBD@Z:near
UNDEF:00010934                                         ; CODE XREF: std::basic_string<char,std::char_traits<char>,std::allocator<char>>::_Xlen(void)+Cp
UNDEF:00010934                                         ; std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>>::_Xlen(void)+Cp ...
UNDEF:00010938 ; void __cdecl std::_Xout_of_range(const char *)
UNDEF:00010938                 extrn ?_Xout_of_range@std@@YAXPBD@Z:near
UNDEF:00010938                                         ; CODE XREF: std::basic_string<char,std::char_traits<char>,std::allocator<char>>::_Xran(void)+Cp
UNDEF:00010938                                         ; std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>>::_Xran(void)+Cp ...
UNDEF:0001093C ; int __cdecl toupper(int C)
UNDEF:0001093C                 extrn _toupper:near     ; DATA XREF: stringToUpper(std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>>)+33o
UNDEF:00010940 ; DWORD __stdcall GetCurrentDirectoryW(DWORD nBufferLength, LPWSTR lpBuffer)
UNDEF:00010940                 extrn __imp__GetCurrentDirectoryW@8:near
UNDEF:00010940                                         ; CODE XREF: getDriveLetter(void)+26p
UNDEF:00010940                                         ; DATA XREF: getDriveLetter(void)+26r
UNDEF:00010944 ; DWORD __stdcall GetFullPathNameW(LPCWSTR lpFileName, DWORD nBufferLength, LPWSTR lpBuffer, LPWSTR *lpFilePart)
UNDEF:00010944                 extrn __imp__GetFullPathNameW@16:near
UNDEF:00010944                                         ; CODE XREF: relativeFilePathToFullFilePath(wchar_t const *)+77p
UNDEF:00010944                                         ; DATA XREF: relativeFilePathToFullFilePath(wchar_t const *)+77r
UNDEF:00010948 ; DWORD __stdcall GetLastError()
UNDEF:00010948                 extrn __imp__GetLastError@0:near
UNDEF:00010948                                         ; CODE XREF: WcharMbcsConvertor::char2wchar(char const *,uint,int,int *,int *)+131p
UNDEF:00010948                                         ; DATA XREF: WcharMbcsConvertor::char2wchar(char const *,uint,int,int *,int *)+131r
UNDEF:0001094C ; HGLOBAL __stdcall GlobalAlloc(UINT uFlags, SIZE_T dwBytes)
UNDEF:0001094C                 extrn __imp__GlobalAlloc@8:near
UNDEF:0001094C                                         ; CODE XREF: str2Clipboard(std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>> const &,HWND__ *)+1Bp
UNDEF:0001094C                                         ; DATA XREF: str2Clipboard(std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>> const &,HWND__ *)+1Br
UNDEF:00010950 ; LPVOID __stdcall GlobalLock(HGLOBAL hMem)
UNDEF:00010950                 extrn __imp__GlobalLock@4:near
UNDEF:00010950                                         ; CODE XREF: str2Clipboard(std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>> const &,HWND__ *)+7Bp
UNDEF:00010950                                         ; DATA XREF: str2Clipboard(std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>> const &,HWND__ *)+7Br
UNDEF:00010954 ; BOOL __stdcall GlobalUnlock(HGLOBAL hMem)
UNDEF:00010954                 extrn __imp__GlobalUnlock@4:near
UNDEF:00010954                                         ; CODE XREF: str2Clipboard(std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>> const &,HWND__ *)+8Ep
UNDEF:00010954                                         ; str2Clipboard(std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>> const &,HWND__ *)+C7p ...
UNDEF:00010958 ; HGLOBAL __stdcall GlobalFree(HGLOBAL hMem)
UNDEF:00010958                 extrn __imp__GlobalFree@4:near
UNDEF:00010958                                         ; CODE XREF: str2Clipboard(std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>> const &,HWND__ *)+43p
UNDEF:00010958                                         ; str2Clipboard(std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>> const &,HWND__ *)+64p ...
UNDEF:0001095C ; int __stdcall lstrlenW(LPCWSTR lpString)
UNDEF:0001095C                 extrn __imp__lstrlenW@4:near
UNDEF:0001095C                                         ; CODE XREF: purgeMenuItemString(wchar_t const *,bool)+63p
UNDEF:0001095C                                         ; isInList(wchar_t const *,wchar_t const *)+3Ep ...
UNDEF:00010960 ; HBITMAP __stdcall CreateCompatibleBitmap(HDC hdc, int cx, int cy)
UNDEF:00010960                 extrn __imp__CreateCompatibleBitmap@12:near
UNDEF:00010960                                         ; CODE XREF: getCtrlBgColor(HWND__ *)+7Fp
UNDEF:00010960                                         ; DATA XREF: getCtrlBgColor(HWND__ *)+7Fr
UNDEF:00010964 ; HDC __stdcall CreateCompatibleDC(HDC hdc)
UNDEF:00010964                 extrn __imp__CreateCompatibleDC@4:near
UNDEF:00010964                                         ; CODE XREF: getCtrlBgColor(HWND__ *)+64p
UNDEF:00010964                                         ; DATA XREF: getCtrlBgColor(HWND__ *)+64r
UNDEF:00010968 ; BOOL __stdcall DeleteDC(HDC hdc)
UNDEF:00010968                 extrn __imp__DeleteDC@4:near
UNDEF:00010968                                         ; CODE XREF: getCtrlBgColor(HWND__ *)+E8p
UNDEF:00010968                                         ; DATA XREF: getCtrlBgColor(HWND__ *)+E8r
UNDEF:0001096C ; BOOL __stdcall DeleteObject(HGDIOBJ ho)
UNDEF:0001096C                 extrn __imp__DeleteObject@4:near
UNDEF:0001096C                                         ; CODE XREF: getCtrlBgColor(HWND__ *)+DEp
UNDEF:0001096C                                         ; DATA XREF: getCtrlBgColor(HWND__ *)+DEr
UNDEF:00010970 ; COLORREF __stdcall GetPixel(HDC hdc, int x, int y)
UNDEF:00010970                 extrn __imp__GetPixel@12:near
UNDEF:00010970                                         ; CODE XREF: getCtrlBgColor(HWND__ *)+C3p
UNDEF:00010970                                         ; DATA XREF: getCtrlBgColor(HWND__ *)+C3r
UNDEF:00010974 ; HGDIOBJ __stdcall SelectObject(HDC hdc, HGDIOBJ h)
UNDEF:00010974                 extrn __imp__SelectObject@8:near
UNDEF:00010974                                         ; CODE XREF: getCtrlBgColor(HWND__ *)+96p
UNDEF:00010974                                         ; getCtrlBgColor(HWND__ *)+D4p
UNDEF:00010974                                         ; DATA XREF: ...
UNDEF:00010978 ; int _wsprintfW(LPWSTR, LPCWSTR, ...)
UNDEF:00010978                 extrn __imp__wsprintfW:near ; CODE XREF: printInt(int)+1Dp
UNDEF:00010978                                         ; DATA XREF: printInt(int)+1Dr
UNDEF:0001097C ; LRESULT __stdcall SendMessageW(HWND hWnd, UINT Msg, WPARAM wParam, LPARAM lParam)
UNDEF:0001097C                 extrn __imp__SendMessageW@16:near
UNDEF:0001097C                                         ; CODE XREF: getCtrlBgColor(HWND__ *)+B1p
UNDEF:0001097C                                         ; BrowseCallbackProc(HWND__ *,uint,long,long)+1Ep
UNDEF:0001097C                                         ; DATA XREF: ...
UNDEF:00010980 ; BOOL __stdcall IsWindow(HWND hWnd)
UNDEF:00010980                 extrn __imp__IsWindow@4:near
UNDEF:00010980                                         ; CODE XREF: getCtrlBgColor(HWND__ *)+25p
UNDEF:00010980                                         ; DATA XREF: getCtrlBgColor(HWND__ *)+25r
UNDEF:00010984 ; BOOL __stdcall SetDlgItemTextW(HWND hDlg, int nIDDlgItem, LPCWSTR lpString)
UNDEF:00010984                 extrn __imp__SetDlgItemTextW@12:near
UNDEF:00010984                                         ; CODE XREF: folderBrowser(HWND__ *,int,wchar_t const *)+144p
UNDEF:00010984                                         ; DATA XREF: folderBrowser(HWND__ *,int,wchar_t const *)+144r
UNDEF:00010988 ; UINT __stdcall GetDlgItemTextW(HWND hDlg, int nIDDlgItem, LPWSTR lpString, int cchMax)
UNDEF:00010988                 extrn __imp__GetDlgItemTextW@16:near
UNDEF:00010988                                         ; CODE XREF: folderBrowser(HWND__ *,int,wchar_t const *)+96p
UNDEF:00010988                                         ; DATA XREF: folderBrowser(HWND__ *,int,wchar_t const *)+96r
UNDEF:0001098C ; BOOL __stdcall OpenClipboard(HWND hWndNewOwner)
UNDEF:0001098C                 extrn __imp__OpenClipboard@4:near
UNDEF:0001098C                                         ; CODE XREF: str2Clipboard(std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>> const &,HWND__ *)+35p
UNDEF:0001098C                                         ; DATA XREF: str2Clipboard(std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>> const &,HWND__ *)+35r
UNDEF:00010990 ; BOOL __stdcall CloseClipboard()
UNDEF:00010990                 extrn __imp__CloseClipboard@0:near
UNDEF:00010990                                         ; CODE XREF: str2Clipboard(std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>> const &,HWND__ *)+49p
UNDEF:00010990                                         ; str2Clipboard(std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>> const &,HWND__ *)+6Ap ...
UNDEF:00010994 ; HANDLE __stdcall SetClipboardData(UINT uFormat, HANDLE hMem)
UNDEF:00010994                 extrn __imp__SetClipboardData@8:near
UNDEF:00010994                                         ; CODE XREF: str2Clipboard(std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>> const &,HWND__ *)+DCp
UNDEF:00010994                                         ; DATA XREF: str2Clipboard(std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>> const &,HWND__ *)+DCr
UNDEF:00010998 ; BOOL __stdcall EmptyClipboard()
UNDEF:00010998                 extrn __imp__EmptyClipboard@0:near
UNDEF:00010998                                         ; CODE XREF: str2Clipboard(std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>> const &,HWND__ *):loc_246Ep
UNDEF:00010998                                         ; DATA XREF: str2Clipboard(std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>> const &,HWND__ *):loc_246Er
UNDEF:0001099C ; HDC __stdcall GetDC(HWND hWnd)
UNDEF:0001099C                 extrn __imp__GetDC@4:near
UNDEF:0001099C                                         ; CODE XREF: getCtrlBgColor(HWND__ *)+4Dp
UNDEF:0001099C                                         ; DATA XREF: getCtrlBgColor(HWND__ *)+4Dr
UNDEF:000109A0 ; int __stdcall ReleaseDC(HWND hWnd, HDC hDC)
UNDEF:000109A0                 extrn __imp__ReleaseDC@8:near
UNDEF:000109A0                                         ; CODE XREF: getCtrlBgColor(HWND__ *)+F6p
UNDEF:000109A0                                         ; DATA XREF: getCtrlBgColor(HWND__ *)+F6r
UNDEF:000109A4 ; BOOL __stdcall GetClientRect(HWND hWnd, LPRECT lpRect)
UNDEF:000109A4                 extrn __imp__GetClientRect@8:near
UNDEF:000109A4                                         ; CODE XREF: getCtrlBgColor(HWND__ *)+3Bp
UNDEF:000109A4                                         ; DATA XREF: getCtrlBgColor(HWND__ *)+3Br
UNDEF:000109A8 ; int __stdcall MessageBoxW(HWND hWnd, LPCWSTR lpText, LPCWSTR lpCaption, UINT uType)
UNDEF:000109A8                 extrn __imp__MessageBoxW@16:near
UNDEF:000109A8                                         ; CODE XREF: printInt(int)+33p
UNDEF:000109A8                                         ; printStr(wchar_t const *)+10p
UNDEF:000109A8                                         ; DATA XREF: ...
UNDEF:000109AC ; BOOL __stdcall ClientToScreen(HWND hWnd, LPPOINT lpPoint)
UNDEF:000109AC                 extrn __imp__ClientToScreen@8:near
UNDEF:000109AC                                         ; CODE XREF: ClientRectToScreenRect(HWND__ *,tagRECT *)+1Fp
UNDEF:000109AC                                         ; ClientRectToScreenRect(HWND__ *,tagRECT *)+50p
UNDEF:000109AC                                         ; DATA XREF: ...
UNDEF:000109B0 ; BOOL __stdcall ScreenToClient(HWND hWnd, LPPOINT lpPoint)
UNDEF:000109B0                 extrn __imp__ScreenToClient@8:near
UNDEF:000109B0                                         ; CODE XREF: ScreenRectToClientRect(HWND__ *,tagRECT *)+1Fp
UNDEF:000109B0                                         ; ScreenRectToClientRect(HWND__ *,tagRECT *)+50p
UNDEF:000109B0                                         ; DATA XREF: ...
UNDEF:000109B4 ; int __stdcall MultiByteToWideChar(UINT CodePage, DWORD dwFlags, LPCSTR lpMultiByteStr, int cbMultiByte, LPWSTR lpWideCharStr, int cchWideChar)
UNDEF:000109B4                 extrn __imp__MultiByteToWideChar@24:near
UNDEF:000109B4                                         ; CODE XREF: string2wstring(std::basic_string<char,std::char_traits<char>,std::allocator<char>> const &,uint)+41p
UNDEF:000109B4                                         ; string2wstring(std::basic_string<char,std::char_traits<char>,std::allocator<char>> const &,uint)+83p ...
UNDEF:000109B8 ; int __stdcall WideCharToMultiByte(UINT CodePage, DWORD dwFlags, LPCWSTR lpWideCharStr, int cchWideChar, LPSTR lpMultiByteStr, int cbMultiByte, LPCSTR lpDefaultChar, LPBOOL lpUsedDefaultChar)
UNDEF:000109B8                 extrn __imp__WideCharToMultiByte@32:near
UNDEF:000109B8                                         ; CODE XREF: wstring2string(std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>> const &,uint)+45p
UNDEF:000109B8                                         ; wstring2string(std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>> const &,uint)+8Bp ...
UNDEF:000109BC ; BOOL __stdcall PathCompactPathExW(LPWSTR pszOut, LPCWSTR pszSrc, UINT cchMax, DWORD dwFlags)
UNDEF:000109BC                 extrn __imp__PathCompactPathExW@16:near
UNDEF:000109BC                                         ; CODE XREF: BuildMenuFileName(int,uint,std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>> const &)+113p
UNDEF:000109BC                                         ; DATA XREF: BuildMenuFileName(int,uint,std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>> const &)+113r
UNDEF:000109C0 ; LPWSTR __stdcall PathFindFileNameW(LPCWSTR pszPath)
UNDEF:000109C0                 extrn __imp__PathFindFileNameW@4:near
UNDEF:000109C0                                         ; CODE XREF: BuildMenuFileName(int,uint,std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>> const &)+23Cp
UNDEF:000109C0                                         ; DATA XREF: BuildMenuFileName(int,uint,std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>> const &)+23Cr
UNDEF:000109C4 ; int __stdcall PathGetDriveNumberW(LPCWSTR pszPath)
UNDEF:000109C4                 extrn __imp__PathGetDriveNumberW@4:near
UNDEF:000109C4                                         ; CODE XREF: getDriveLetter(void)+33p
UNDEF:000109C4                                         ; DATA XREF: getDriveLetter(void)+33r
UNDEF:000109C8 ; BOOL __stdcall PathIsRelativeW(LPCWSTR pszPath)
UNDEF:000109C8                 extrn __imp__PathIsRelativeW@4:near
UNDEF:000109C8                                         ; CODE XREF: relativeFilePathToFullFilePath(wchar_t const *)+50p
UNDEF:000109C8                                         ; DATA XREF: relativeFilePathToFullFilePath(wchar_t const *)+50r
UNDEF:000109CC ; HRESULT __stdcall SHGetMalloc(IMalloc **ppMalloc)
UNDEF:000109CC                 extrn __imp__SHGetMalloc@4:near
UNDEF:000109CC                                         ; CODE XREF: folderBrowser(HWND__ *,int,wchar_t const *)+24p
UNDEF:000109CC                                         ; getFolderName(HWND__ *,wchar_t const *)+5Dp
UNDEF:000109CC                                         ; DATA XREF: ...
UNDEF:000109D0 ; BOOL __stdcall SHGetPathFromIDListW(LPCITEMIDLIST pidl, LPWSTR pszPath)
UNDEF:000109D0                 extrn __imp__SHGetPathFromIDListW@8:near
UNDEF:000109D0                                         ; CODE XREF: folderBrowser(HWND__ *,int,wchar_t const *)+12Bp
UNDEF:000109D0                                         ; getFolderName(HWND__ *,wchar_t const *)+EEp
UNDEF:000109D0                                         ; DATA XREF: ...
UNDEF:000109D4 ; LPITEMIDLIST __stdcall SHBrowseForFolderW(LPBROWSEINFOW lpbi)
UNDEF:000109D4                 extrn __imp__SHBrowseForFolderW@4:near
UNDEF:000109D4                                         ; CODE XREF: folderBrowser(HWND__ *,int,wchar_t const *)+108p
UNDEF:000109D4                                         ; getFolderName(HWND__ *,wchar_t const *)+CBp
UNDEF:000109D4                                         ; DATA XREF: ...
UNDEF:000109D8 ; public: virtual void * __thiscall std::logic_error::`vector deleting destructor'(unsigned int)
UNDEF:000109D8                 extrn ??_Elogic_error@std@@UAEPAXI@Z:near ; weak
UNDEF:000109D8                                         ; DATA XREF: .rdata:const std::logic_error::`vftable'o
UNDEF:000109DC ; public: virtual void * __thiscall std::invalid_argument::`vector deleting destructor'(unsigned int)
UNDEF:000109DC                 extrn ??_Einvalid_argument@std@@UAEPAXI@Z:near ; weak
UNDEF:000109DC                                         ; DATA XREF: .rdata:const std::invalid_argument::`vftable'o
UNDEF:000109E0 ; public: virtual void * __thiscall std::out_of_range::`vector deleting destructor'(unsigned int)
UNDEF:000109E0                 extrn ??_Eout_of_range@std@@UAEPAXI@Z:near ; weak
UNDEF:000109E0                                         ; DATA XREF: .rdata:const std::out_of_range::`vftable'o
UNDEF:000109E4 ; public: virtual void * __thiscall std::error_category::`vector deleting destructor'(unsigned int)
UNDEF:000109E4                 extrn ??_Eerror_category@std@@UAEPAXI@Z:near ; weak
UNDEF:000109E4                                         ; DATA XREF: .rdata:const std::error_category::`vftable'o
UNDEF:000109E8 ; const char *__cdecl std::_Syserror_map(int)
UNDEF:000109E8                 extrn ?_Syserror_map@std@@YAPBDH@Z:near
UNDEF:000109E8                                         ; CODE XREF: std::_System_error_category::default_error_condition(int)+Bp
UNDEF:000109E8                                         ; std::_Generic_error_category::message(int)+33p
UNDEF:000109EC ; const char *__cdecl std::_Winerror_map(int)
UNDEF:000109EC                 extrn ?_Winerror_map@std@@YAPBDH@Z:near
UNDEF:000109EC                                         ; CODE XREF: std::_System_error_category::message(int)+33p
UNDEF:000109F0 ; public: virtual void * __thiscall std::_Generic_error_category::`vector deleting destructor'(unsigned int)
UNDEF:000109F0                 extrn ??_E_Generic_error_category@std@@UAEPAXI@Z:near ; weak
UNDEF:000109F0                                         ; DATA XREF: .rdata:const std::_Generic_error_category::`vftable'o
UNDEF:000109F4 ; public: virtual void * __thiscall std::_Iostream_error_category::`vector deleting destructor'(unsigned int)
UNDEF:000109F4                 extrn ??_E_Iostream_error_category@std@@UAEPAXI@Z:near ; weak
UNDEF:000109F4                                         ; DATA XREF: .rdata:const std::_Iostream_error_category::`vftable'o
UNDEF:000109F8 ; public: virtual void * __thiscall std::_System_error_category::`vector deleting destructor'(unsigned int)
UNDEF:000109F8                 extrn ??_E_System_error_category@std@@UAEPAXI@Z:near ; weak
UNDEF:000109F8                                         ; DATA XREF: .rdata:const std::_System_error_category::`vftable'o
UNDEF:000109FC ; __fastcall __security_check_cookie(x)
UNDEF:000109FC                 extrn @__security_check_cookie@4:near
UNDEF:000109FC                                         ; CODE XREF: folderBrowser(HWND__ *,int,wchar_t const *)+17Ep
UNDEF:000109FC                                         ; getFolderName(HWND__ *,wchar_t const *)+179p ...
UNDEF:00010A00 ; __stdcall _CxxThrowException(x, x)
UNDEF:00010A00                 extrn __CxxThrowException@8:near
UNDEF:00010A00                                         ; CODE XREF: stodLocale(std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>> const &,localeinfo_struct *,uint *)+A9p
UNDEF:00010A00                                         ; stodLocale(std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>> const &,localeinfo_struct *,uint *)+107p ...
UNDEF:00010A04                 extrn ___CxxFrameHandler3:near
UNDEF:00010A04                                         ; CODE XREF: __ehhandler$?getFolderName@@YA?AV?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@PAUHWND__@@PB_W@Z+23j
UNDEF:00010A04                                         ; __ehhandler$?purgeMenuItemString@@YA?AV?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@PB_W_N@Z+23j ...
UNDEF:00010A08 ; void *__cdecl memset_0(void *Dst, int Val, size_t Size)
UNDEF:00010A08                 extrn _memset_0:near    ; CODE XREF: purgeMenuItemString(wchar_t const *,bool)+4Dp
UNDEF:00010A0C ; const type_info::`vftable'
UNDEF:00010A0C                 extrn ??_7type_info@@6B@:near
UNDEF:00010A0C                                         ; DATA XREF: .data$r:std::exception `RTTI Type Descriptor'o
UNDEF:00010A0C                                         ; .data$r:std::invalid_argument * `RTTI Type Descriptor'o ...
UNDEF:00010A10                 extrn ___security_cookie:near
UNDEF:00010A10                                         ; DATA XREF: folderBrowser(HWND__ *,int,wchar_t const *)+9r
UNDEF:00010A10                                         ; getFolderName(HWND__ *,wchar_t const *)+17r ...
UNDEF:00010A14                 extrn __fltused:near
UNDEF:00010A14
UNDEF:00010A14
UNDEF:00010A14                 end