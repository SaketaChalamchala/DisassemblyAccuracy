.data:00000000 ;
.data:00000000 ; +-------------------------------------------------------------------------+
.data:00000000 ; |   This file has been generated by The Interactive Disassembler (IDA)    |
.data:00000000 ; |           Copyright (c) 2015 Hex-Rays, <support@hex-rays.com>           |
.data:00000000 ; |                      License info: 48-3677-7074-51                      |
.data:00000000 ; |             Michalis Polychronakis, Stony Brook University              |
.data:00000000 ; +-------------------------------------------------------------------------+
.data:00000000 ;
.data:00000000 ; Input MD5   : CC91056DAAE708CE92B5B441C7771CAB
.data:00000000 ; Input CRC32 : 22E8B113
.data:00000000
.data:00000000 ; File Name   : C:\workspace\notepad-plus-plus-6.7.9.2\PowerEditor\visual.net\Unicode Debug\documentMap.obj
.data:00000000 ; Format      : COFF (X386MAGIC)
.data:00000000 ; includelib "uuid.lib"
.data:00000000 ; includelib "libcpmtd"
.data:00000000 ; must resolve: ?_Generic_object@?$_Error_objects@H@std@@2V_Generic_error_category@2@A
.data:00000000 ; must resolve: ?_Iostream_object@?$_Error_objects@H@std@@2V_Iostream_error_category@2@A
.data:00000000 ; must resolve: ?_System_object@?$_Error_objects@H@std@@2V_System_error_category@2@A
.data:00000000 ; must resolve: ?id@?$num_put@DV?$back_insert_iterator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@std@@2V0locale@2@A
.data:00000000 ; must resolve: ?id@?$num_put@_WV?$back_insert_iterator@V?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@@std@@@std@@2V0locale@2@A
.data:00000000 ; must resolve: ?id@?$numpunct@D@std@@2V0locale@2@A
.data:00000000 ; must resolve: ?id@?$numpunct@_W@std@@2V0locale@2@A
.data:00000000 ; includelib "LIBCMTD"
.data:00000000 ; includelib "OLDNAMES"
.data:00000000
.data:00000000                 include uni.inc ; see unicode subdir of ida for info on unicode
.data:00000000
.data:00000000                 .686p
.data:00000000                 .mmx
.data:00000000                 .model flat
.data:00000000
.data:00000000 ; ===========================================================================
.data:00000000
.data:00000000 ; Segment type: Pure data
.data:00000000 ; Segment permissions: Read/Write
.data:00000000 ; Segment alignment 'qword' can not be represented in assembly
.data:00000000 _data           segment para public 'DATA' use32
.data:00000000                 assume cs:_data
.data:00000000 _acTop_xpm      dd offset $SG145444     ; "12 12 56 1"
.data:00000004                 dd offset $SG145445     ; " \tc #FFFFFF"
.data:00000008                 dd offset $SG145446     ; ".\tc #8AB2E9"
.data:0000000C                 dd offset $SG145447     ; "+\tc #CCDCF6"
.data:00000010                 dd offset $SG145448     ; "@\tc #80ABEA"
.data:00000014                 dd offset $SG145449     ; "#\tc #7DA9E8"
.data:00000018                 dd offset $SG145450     ; "$\tc #C7DAF3"
.data:0000001C                 dd offset $SG145451     ; "%\tc #79A7E6"
.data:00000020                 dd offset $SG145452     ; "&\tc #ADC8EF"
.data:00000024                 dd offset $SG145453     ; "*\tc #87B0E8"
.data:00000028                 dd offset $SG145454     ; "=\tc #BBD2F0"
.data:0000002C                 dd offset $SG145455     ; "-\tc #6EA0E2"
.data:00000030                 dd offset $SG145456     ; ";\tc #A8C7EE"
.data:00000034                 dd offset $SG145457     ; ">\tc #A3C2ED"
.data:00000038                 dd offset $SG145458     ; ",\tc #75A4E3"
.data:0000003C                 dd offset $SG145459     ; "'\tc #A7C4EB"
.data:00000040                 dd offset $SG145460     ; ")\tc #6297E1"
.data:00000044                 dd offset $SG145461     ; "!\tc #A1C1EC"
.data:00000048                 dd offset $SG145462     ; "~\tc #92B7E8"
.data:0000004C                 dd offset $SG145463     ; "{\tc #99BBE9"
.data:00000050                 dd offset $SG145464     ; "]\tc #6197DD"
.data:00000054                 dd offset $SG145465     ; "^\tc #96B9E6"
.data:00000058                 dd offset $SG145466     ; "/\tc #538EDB"
.data:0000005C                 dd offset $SG145467     ; "(\tc #99BBEA"
.data:00000060                 dd offset $SG145468     ; "_\tc #80AAE3"
.data:00000064                 dd offset $SG145469     ; ":\tc #81ABE3"
.data:00000068                 dd offset $SG145470     ; "<\tc #8AB1E4"
.data:0000006C                 dd offset $SG145471     ; "[\tc #4B88D6"
.data:00000070                 dd offset $SG145472     ; "}\tc #4882D1"
.data:00000074                 dd offset $SG145473     ; "|\tc #4384D6"
.data:00000078                 dd offset $SG145474     ; "1\tc #90B5E7"
.data:0000007C                 dd offset $SG145475     ; "2\tc #74A3E0"
.data:00000080                 dd offset $SG145476     ; "3\tc #77A4E0"
.data:00000084                 dd offset $SG145477     ; "4\tc #81ABE2"
.data:00000088                 dd offset $SG145478     ; "5\tc #437FD3"
.data:0000008C                 dd offset $SG145479     ; "6\tc #7FA2DF"
.data:00000090                 dd offset $SG145480     ; "7\tc #3577D2"
.data:00000094                 dd offset $SG145481     ; "8\tc #87AFE4"
.data:00000098                 dd offset $SG145482     ; "9\tc #72A1DF"
.data:0000009C                 dd offset $SG145483     ; "0\tc #7CA9E1"
.data:000000A0                 dd offset $SG145484     ; "a\tc #3F7AD0"
.data:000000A4                 dd offset $SG145485     ; "b\tc #85A4DE"
.data:000000A8                 dd offset $SG145486     ; "c\tc #FBFCFE"
.data:000000AC                 dd offset $SG145487     ; "d\tc #236ECD"
.data:000000B0                 dd offset $SG145488     ; "e\tc #7EA8E1"
.data:000000B4                 dd offset $SG145489     ; "f\tc #79A6E0"
.data:000000B8                 dd offset $SG145490     ; "g\tc #3D77D0"
.data:000000BC                 dd offset $SG145491     ; "h\tc #87A4DC"
.data:000000C0                 dd offset $SG145492     ; "i\tc #1A62C9"
.data:000000C4                 dd offset $SG145493     ; "j\tc #75A3DF"
.data:000000C8                 dd offset $SG145494     ; "k\tc #3C74CF"
.data:000000CC                 dd offset $SG145495     ; "l\tc #8DA6DE"
.data:000000D0                 dd offset $SG145496     ; "m\tc #1859C4"
.data:000000D4                 dd offset $SG145497     ; "n\tc #3B71CC"
.data:000000D8                 dd offset $SG145498     ; "o\tc #8EA5DD"
.data:000000DC                 dd offset $SG145499     ; "p\tc #164EC0"
.data:000000E0                 dd offset $SG145500     ; "q\tc #92A7DD"
.data:000000E4                 dd offset $SG145501     ; "    .+      "
.data:000000E8                 dd offset $SG145502     ; "    @#$     "
.data:000000EC                 dd offset $SG145503     ; "    %&*=    "
.data:000000F0                 dd offset $SG145504     ; "    -;>,'   "
.data:000000F4                 dd offset $SG145505     ; "    )!~{]^  "
.data:000000F8                 dd offset $SG145506     ; "    /(_:<[} "
.data:000000FC                 dd offset $SG145507     ; "    |123456 "
.data:00000100                 dd offset $SG145508     ; "    7890abc "
.data:00000104                 dd offset $SG145509     ; "    defgh   "
.data:00000108                 dd offset $SG145510     ; "    ijkl    "
.data:0000010C                 dd offset $SG145511     ; "    mno     "
.data:00000110                 dd offset $SG145512     ; "    pq      "
.data:00000114                 align 8
.data:00000118 _acBottom_xpm   dd offset $SG145514     ; "12 12 54 1"
.data:0000011C                 dd offset $SG145515     ; " \tc #FFFFFF"
.data:00000120                 dd offset $SG145516     ; ".\tc #C4D7F3"
.data:00000124                 dd offset $SG145517     ; "+\tc #72A1E3"
.data:00000128                 dd offset $SG145518     ; "@\tc #C1D6F2"
.data:0000012C                 dd offset $SG145519     ; "#\tc #6397E1"
.data:00000130                 dd offset $SG145520     ; "$\tc #5990DD"
.data:00000134                 dd offset $SG145521     ; "%\tc #BBD2F0"
.data:00000138                 dd offset $SG145522     ; "&\tc #7AA6E5"
.data:0000013C                 dd offset $SG145523     ; "*\tc #9ABDEA"
.data:00000140                 dd offset $SG145524     ; "=\tc #4A87D9"
.data:00000144                 dd offset $SG145525     ; "-\tc #B1CAEE"
.data:00000148                 dd offset $SG145526     ; ";\tc #75A4E3"
.data:0000014C                 dd offset $SG145527     ; ">\tc #99BBE9"
.data:00000150                 dd offset $SG145528     ; ",\tc #95B9E8"
.data:00000154                 dd offset $SG145529     ; "'\tc #3A7CD4"
.data:00000158                 dd offset $SG145530     ; ")\tc #A9C6EC"
.data:0000015C                 dd offset $SG145531     ; "!\tc #71A0E0"
.data:00000160                 dd offset $SG145532     ; "~\tc #86AFE5"
.data:00000164                 dd offset $SG145533     ; "{\tc #8DB2E6"
.data:00000168                 dd offset $SG145534     ; "]\tc #2A72CF"
.data:0000016C                 dd offset $SG145535     ; "^\tc #73A0E0"
.data:00000170                 dd offset $SG145536     ; "/\tc #6B9DE0"
.data:00000174                 dd offset $SG145537     ; "(\tc #95B8E8"
.data:00000178                 dd offset $SG145538     ; "_\tc #81ABE3"
.data:0000017C                 dd offset $SG145539     ; ":\tc #72A1DF"
.data:00000180                 dd offset $SG145540     ; "<\tc #83ADE3"
.data:00000184                 dd offset $SG145541     ; "[\tc #1B65C9"
.data:00000188                 dd offset $SG145542     ; "}\tc #5F95DC"
.data:0000018C                 dd offset $SG145543     ; "|\tc #8BB3E5"
.data:00000190                 dd offset $SG145544     ; "1\tc #77A4E0"
.data:00000194                 dd offset $SG145545     ; "2\tc #679ADC"
.data:00000198                 dd offset $SG145546     ; "3\tc #7AA6E1"
.data:0000019C                 dd offset $SG145547     ; "4\tc #195CC6"
.data:000001A0                 dd offset $SG145548     ; "5\tc #FCFDFE"
.data:000001A4                 dd offset $SG145549     ; "6\tc #8DB2E4"
.data:000001A8                 dd offset $SG145550     ; "7\tc #4885D6"
.data:000001AC                 dd offset $SG145551     ; "8\tc #7CA9E1"
.data:000001B0                 dd offset $SG145552     ; "9\tc #6698DB"
.data:000001B4                 dd offset $SG145553     ; "0\tc #71A1DE"
.data:000001B8                 dd offset $SG145554     ; "a\tc #1752C0"
.data:000001BC                 dd offset $SG145555     ; "b\tc #88ABE0"
.data:000001C0                 dd offset $SG145556     ; "c\tc #3D77D0"
.data:000001C4                 dd offset $SG145557     ; "d\tc #6E9FDD"
.data:000001C8                 dd offset $SG145558     ; "e\tc #699BDC"
.data:000001CC                 dd offset $SG145559     ; "f\tc #1547BD"
.data:000001D0                 dd offset $SG145560     ; "g\tc #8DA6DE"
.data:000001D4                 dd offset $SG145561     ; "h\tc #376BC9"
.data:000001D8                 dd offset $SG145562     ; "i\tc #6295DA"
.data:000001DC                 dd offset $SG145563     ; "j\tc #1440B9"
.data:000001E0                 dd offset $SG145564     ; "k\tc #8DA0DB"
.data:000001E4                 dd offset $SG145565     ; "l\tc #315FC4"
.data:000001E8                 dd offset $SG145566     ; "m\tc #1339B7"
.data:000001EC                 dd offset $SG145567     ; "n\tc #909FDA"
.data:000001F0                 dd offset $SG145568     ; "o\tc #1233B4"
.data:000001F4                 dd offset $SG145569     ; "         .+ "
.data:000001F8                 dd offset $SG145570     ; "        @#$ "
.data:000001FC                 dd offset $SG145571     ; "       %&*= L"
.data:00000200                 dd offset $SG145572     ; "      -;>,' "
.data:00000204                 dd offset $SG145573     ; "     )!>~{] "
.data:00000208                 dd offset $SG145574     ; "    ^/(_:<[ "
.data:0000020C                 dd offset $SG145575     ; "    (}|1234 "
.data:00000210                 dd offset $SG145576     ; "    567890a "
.data:00000214                 dd offset $SG145577     ; "      bcdef "
.data:00000218                 dd offset $SG145578     ; "       ghij "
.data:0000021C                 dd offset $SG145579     ; "        klm "
.data:00000220                 dd offset $SG145580     ; "         no "
.data:00000224                 align 8
.data:00000228 _bookmark_xpm   dd offset $SG145582     ; "13 14 54 1"
.data:0000022C                 dd offset $SG145583     ; " \tc None"
.data:00000230                 dd offset $SG145584     ; ".\tc #545254"
.data:00000234                 dd offset $SG145585     ; "+\tc #3C3E3C"
.data:00000238                 dd offset $SG145586     ; "@\tc #646464"
.data:0000023C                 dd offset $SG145587     ; "#\tc #A4A4A4"
.data:00000240                 dd offset $SG145588     ; "$\tc #B7B8B7"
.data:00000244                 dd offset $SG145589     ; "%\tc #747284"
.data:00000248                 dd offset $SG145590     ; "&\tc #B4B2C4"
.data:0000024C                 dd offset $SG145591     ; "*\tc #DCD7E4"
.data:00000250                 dd offset $SG145592     ; "=\tc #1C1A1C"
.data:00000254                 dd offset $SG145593     ; "-\tc #403E58"
.data:00000258                 dd offset $SG145594     ; ";\tc #5C5A8C"
.data:0000025C                 dd offset $SG145595     ; ">\tc #7C7EAC"
.data:00000260                 dd offset $SG145596     ; ",\tc #7C8EBC"
.data:00000264                 dd offset $SG145597     ; "'\tc #242644"
.data:00000268                 dd offset $SG145598     ; ")\tc #282668"
.data:0000026C                 dd offset $SG145599     ; "!\tc #24367C"
.data:00000270                 dd offset $SG145600     ; "~\tc #244A84"
.data:00000274                 dd offset $SG145601     ; "{\tc #2C5098"
.data:00000278                 dd offset $SG145602     ; "]\tc #14162C"
.data:0000027C                 dd offset $SG145603     ; "^\tc #142E7C"
.data:00000280                 dd offset $SG145604     ; "/\tc #143789"
.data:00000284                 dd offset $SG145605     ; "(\tc #204990"
.data:00000288                 dd offset $SG145606     ; "_\tc #174091"
.data:0000028C                 dd offset $SG145607     ; ":\tc #0C0630"
.data:00000290                 dd offset $SG145608     ; "<\tc #24327C"
.data:00000294                 dd offset $SG145609     ; "[\tc #2450A0"
.data:00000298                 dd offset $SG145610     ; "}\tc #345DB4"
.data:0000029C                 dd offset $SG145611     ; "|\tc #3C68B8"
.data:000002A0                 dd offset $SG145612     ; "1\tc #141244"
.data:000002A4                 dd offset $SG145613     ; "2\tc #24428C"
.data:000002A8                 dd offset $SG145614     ; "3\tc #3462B9"
.data:000002AC                 dd offset $SG145615     ; "4\tc #4470C4"
.data:000002B0                 dd offset $SG145616     ; "5\tc #4C7FD6"
.data:000002B4                 dd offset $SG145617     ; "6\tc #4472CC"
.data:000002B8                 dd offset $SG145618     ; "7\tc #24224C"
.data:000002BC                 dd offset $SG145619     ; "8\tc #5C8DEC"
.data:000002C0                 dd offset $SG145620     ; "9\tc #5C94F6"
.data:000002C4                 dd offset $SG145621     ; "0\tc #5482DF"
.data:000002C8                 dd offset $SG145622     ; "a\tc #619DF7"
.data:000002CC                 dd offset $SG145623     ; "b\tc #6CA6FC"
.data:000002D0                 dd offset $SG145624     ; "c\tc #64A2FC"
.data:000002D4                 dd offset $SG145625     ; "d\tc #1C2E5C"
.data:000002D8                 dd offset $SG145626     ; "e\tc #6CA2FC"
.data:000002DC                 dd offset $SG145627     ; "f\tc #74B2FC"
.data:000002E0                 dd offset $SG145628     ; "g\tc #7CB8FC"
.data:000002E4                 dd offset $SG145629     ; "h\tc #1C3264"
.data:000002E8                 dd offset $SG145630     ; "i\tc #346AD4"
.data:000002EC                 dd offset $SG145631     ; "j\tc #7CBEFC"
.data:000002F0                 dd offset $SG145632     ; "k\tc #3C72DC"
.data:000002F4                 dd offset $SG145633     ; "l\tc #243250"
.data:000002F8                 dd offset $SG145634     ; "m\tc #346AB4"
.data:000002FC                 dd offset $SG145635     ; "n\tc #3C82DC"
.data:00000300                 dd offset $SG145636     ; "o\tc #6C6A6C"
.data:00000304                 dd offset $SG145637     ; "     .+.     "
.data:00000308                 dd offset $SG145638     ; "   @##$##@   "
.data:0000030C                 dd offset $SG145639     ; "  @%&***&%@  "
.data:00000310                 dd offset $SG145640     ; " =-;>,,,>;-= "
.data:00000314                 dd offset $SG145641     ; " ')!~{{{~!)' "
.data:00000318                 dd offset $SG145642     ; "])^/({{{(_^)]"
.data:0000031C                 dd offset $SG145643     ; ":<_[}|||}[_<:"
.data:00000320                 dd offset $SG145644     ; "12[3455563[21"
.data:00000324                 dd offset $SG145645     ; "7_365899063_7"
.data:00000328                 dd offset $SG145646     ; " /|09abc904/ "
.data:0000032C                 dd offset $SG145647     ; " d}8efgfb83d "
.data:00000330                 dd offset $SG145648     ; "  hiafjgakh  "
.data:00000334                 dd offset $SG145649     ; "   l~mnm~l   "
.data:00000338                 dd offset $SG145650     ; "     o@o     "
.data:0000033C                 align 10h
.data:00000340                 public ?zoomRatio@@3PANA
.data:00000340 ; double * zoomRatio
.data:00000340 ?zoomRatio@@3PANA db    0
.data:00000341                 db    0
.data:00000342                 db    0
.data:00000343                 db    0
.data:00000344                 db    0
.data:00000345                 db    0
.data:00000346                 db 0F0h ; =
.data:00000347                 db  3Fh ; ?
.data:00000348                 db    0
.data:00000349                 db    0
.data:0000034A                 db    0
.data:0000034B                 db    0
.data:0000034C                 db    0
.data:0000034D                 db    0
.data:0000034E                 db 0F0h ; =
.data:0000034F                 db  3Fh ; ?
.data:00000350                 db    0
.data:00000351                 db    0
.data:00000352                 db    0
.data:00000353                 db    0
.data:00000354                 db    0
.data:00000355                 db    0
.data:00000356                 db 0F0h ; =
.data:00000357                 db  3Fh ; ?
.data:00000358                 db    0
.data:00000359                 db    0
.data:0000035A                 db    0
.data:0000035B                 db    0
.data:0000035C                 db    0
.data:0000035D                 db    0
.data:0000035E                 db 0F0h ; =
.data:0000035F                 db  3Fh ; ?
.data:00000360                 db    0
.data:00000361                 db    0
.data:00000362                 db    0
.data:00000363                 db    0
.data:00000364                 db    0
.data:00000365                 db    0
.data:00000366                 db 0F8h ; Â°
.data:00000367                 db  3Fh ; ?
.data:00000368                 db    0
.data:00000369                 db    0
.data:0000036A                 db    0
.data:0000036B                 db    0
.data:0000036C                 db    0
.data:0000036D                 db    0
.data:0000036E                 db    0
.data:0000036F                 db  40h ; @
.data:00000370                 db    0
.data:00000371                 db    0
.data:00000372                 db    0
.data:00000373                 db    0
.data:00000374                 db    0
.data:00000375                 db    0
.data:00000376                 db    4
.data:00000377                 db  40h ; @
.data:00000378                 db    0
.data:00000379                 db    0
.data:0000037A                 db    0
.data:0000037B                 db    0
.data:0000037C                 db    0
.data:0000037D                 db    0
.data:0000037E                 db    4
.data:0000037F                 db  40h ; @
.data:00000380                 db    0
.data:00000381                 db    0
.data:00000382                 db    0
.data:00000383                 db    0
.data:00000384                 db    0
.data:00000385                 db    0
.data:00000386                 db  0Ch
.data:00000387                 db  40h ; @
.data:00000388                 db    0
.data:00000389                 db    0
.data:0000038A                 db    0
.data:0000038B                 db    0
.data:0000038C                 db    0
.data:0000038D                 db    0
.data:0000038E                 db  0Ch
.data:0000038F                 db  40h ; @
.data:00000390 qword_390       dq 4010000000000000h    ; DATA XREF: DocumentMap::wrapMap(void)+7Br
.data:00000398                 db    0
.data:00000399                 db    0
.data:0000039A                 db    0
.data:0000039B                 db    0
.data:0000039C                 db    0
.data:0000039D                 db    0
.data:0000039E                 db  12h
.data:0000039F                 db  40h ; @
.data:000003A0                 db    0
.data:000003A1                 db    0
.data:000003A2                 db    0
.data:000003A3                 db    0
.data:000003A4                 db    0
.data:000003A5                 db    0
.data:000003A6                 db  14h
.data:000003A7                 db  40h ; @
.data:000003A8                 db    0
.data:000003A9                 db    0
.data:000003AA                 db    0
.data:000003AB                 db    0
.data:000003AC                 db    0
.data:000003AD                 db    0
.data:000003AE                 db  14h
.data:000003AF                 db  40h ; @
.data:000003B0                 db    0
.data:000003B1                 db    0
.data:000003B2                 db    0
.data:000003B3                 db    0
.data:000003B4                 db    0
.data:000003B5                 db    0
.data:000003B6                 db  16h
.data:000003B7                 db  40h ; @
.data:000003B8                 db    0
.data:000003B9                 db    0
.data:000003BA                 db    0
.data:000003BB                 db    0
.data:000003BC                 db    0
.data:000003BD                 db    0
.data:000003BE                 db  18h
.data:000003BF                 db  40h ; @
.data:000003C0                 db    0
.data:000003C1                 db    0
.data:000003C2                 db    0
.data:000003C3                 db    0
.data:000003C4                 db    0
.data:000003C5                 db    0
.data:000003C6                 db  1Ah
.data:000003C7                 db  40h ; @
.data:000003C8                 db    0
.data:000003C9                 db    0
.data:000003CA                 db    0
.data:000003CB                 db    0
.data:000003CC                 db    0
.data:000003CD                 db    0
.data:000003CE                 db  1Ch
.data:000003CF                 db  40h ; @
.data:000003D0                 db    0
.data:000003D1                 db    0
.data:000003D2                 db    0
.data:000003D3                 db    0
.data:000003D4                 db    0
.data:000003D5                 db    0
.data:000003D6                 db  1Ch
.data:000003D7                 db  40h ; @
.data:000003D8                 db    0
.data:000003D9                 db    0
.data:000003DA                 db    0
.data:000003DB                 db    0
.data:000003DC                 db    0
.data:000003DD                 db    0
.data:000003DE                 db  1Eh
.data:000003DF                 db  40h ; @
.data:000003E0                 db    0
.data:000003E1                 db    0
.data:000003E2                 db    0
.data:000003E3                 db    0
.data:000003E4                 db    0
.data:000003E5                 db    0
.data:000003E6                 db  20h
.data:000003E7                 db  40h ; @
.data:000003E8                 db    0
.data:000003E9                 db    0
.data:000003EA                 db    0
.data:000003EB                 db    0
.data:000003EC                 db    0
.data:000003ED                 db    0
.data:000003EE                 db  21h ; !
.data:000003EF                 db  40h ; @
.data:000003F0                 db    0
.data:000003F1                 db    0
.data:000003F2                 db    0
.data:000003F3                 db    0
.data:000003F4                 db    0
.data:000003F5                 db    0
.data:000003F6                 db  21h ; !
.data:000003F7                 db  40h ; @
.data:000003F8                 db    0
.data:000003F9                 db    0
.data:000003FA                 db    0
.data:000003FB                 db    0
.data:000003FC                 db    0
.data:000003FD                 db    0
.data:000003FE                 db  23h ; #
.data:000003FF                 db  40h ; @
.data:00000400                 db    0
.data:00000401                 db    0
.data:00000402                 db    0
.data:00000403                 db    0
.data:00000404                 db    0
.data:00000405                 db    0
.data:00000406                 db  23h ; #
.data:00000407                 db  40h ; @
.data:00000408                 db    0
.data:00000409                 db    0
.data:0000040A                 db    0
.data:0000040B                 db    0
.data:0000040C                 db    0
.data:0000040D                 db    0
.data:0000040E                 db  24h ; $
.data:0000040F                 db  40h ; @
.data:00000410                 db    0
.data:00000411                 db    0
.data:00000412                 db    0
.data:00000413                 db    0
.data:00000414                 db    0
.data:00000415                 db    0
.data:00000416                 db  25h ; %
.data:00000417                 db  40h ; @
.data:00000418                 db    0
.data:00000419                 db    0
.data:0000041A                 db    0
.data:0000041B                 db    0
.data:0000041C                 db    0
.data:0000041D                 db    0
.data:0000041E                 db  26h ; &
.data:0000041F                 db  40h ; @
.data:00000420                 db    0
.data:00000421                 db    0
.data:00000422                 db    0
.data:00000423                 db    0
.data:00000424                 db    0
.data:00000425                 db    0
.data:00000426                 db  26h ; &
.data:00000427                 db  40h ; @
.data:00000428                 db    0
.data:00000429                 db    0
.data:0000042A                 db    0
.data:0000042B                 db    0
.data:0000042C                 db    0
.data:0000042D                 db    0
.data:0000042E                 db  27h ; '
.data:0000042F                 db  40h ; @
.data:00000430                 db    0
.data:00000431                 db    0
.data:00000432                 db    0
.data:00000433                 db    0
.data:00000434                 db    0
.data:00000435                 db    0
.data:00000436                 db  28h ; (
.data:00000437                 db  40h ; @
.data:00000437 _data           ends
.data:00000437
.rdata:00000438 ; ===========================================================================
.rdata:00000438
.rdata:00000438 ; Segment type: Pure data
.rdata:00000438 ; Segment permissions: Read
.rdata:00000438 _rdata          segment dword public 'DATA' use32
.rdata:00000438                 assume cs:_rdata
.rdata:00000438                 ;org 438h
.rdata:00000438 $SG145444       db '12 12 56 1',0       ; DATA XREF: .data:_acTop_xpmo
.rdata:00000443                 align 4
.rdata:00000444 $SG145445       db ' ',9,'c #FFFFFF',0  ; DATA XREF: .data:00000004o
.rdata:00000450 $SG145446       db '.',9,'c #8AB2E9',0  ; DATA XREF: .data:00000008o
.rdata:0000045C $SG145447       db '+',9,'c #CCDCF6',0  ; DATA XREF: .data:0000000Co
.rdata:00000468 $SG145448       db '@',9,'c #80ABEA',0  ; DATA XREF: .data:00000010o
.rdata:00000474 $SG145449       db '#',9,'c #7DA9E8',0  ; DATA XREF: .data:00000014o
.rdata:00000480 $SG145450       db '$',9,'c #C7DAF3',0  ; DATA XREF: .data:00000018o
.rdata:0000048C $SG145451       db '%',9,'c #79A7E6',0  ; DATA XREF: .data:0000001Co
.rdata:00000498 $SG145452       db '&',9,'c #ADC8EF',0  ; DATA XREF: .data:00000020o
.rdata:000004A4 $SG145453       db '*',9,'c #87B0E8',0  ; DATA XREF: .data:00000024o
.rdata:000004B0 $SG145454       db '=',9,'c #BBD2F0',0  ; DATA XREF: .data:00000028o
.rdata:000004BC $SG145455       db '-',9,'c #6EA0E2',0  ; DATA XREF: .data:0000002Co
.rdata:000004C8 $SG145456       db ';',9,'c #A8C7EE',0  ; DATA XREF: .data:00000030o
.rdata:000004D4 $SG145457       db '>',9,'c #A3C2ED',0  ; DATA XREF: .data:00000034o
.rdata:000004E0 $SG145458       db ',',9,'c #75A4E3',0  ; DATA XREF: .data:00000038o
.rdata:000004EC $SG145459       db 27h,9,'c #A7C4EB',0  ; DATA XREF: .data:0000003Co
.rdata:000004F8 $SG145460       db ')',9,'c #6297E1',0  ; DATA XREF: .data:00000040o
.rdata:00000504 $SG145461       db '!',9,'c #A1C1EC',0  ; DATA XREF: .data:00000044o
.rdata:00000510 $SG145462       db '~',9,'c #92B7E8',0  ; DATA XREF: .data:00000048o
.rdata:0000051C $SG145463       db '{',9,'c #99BBE9',0  ; DATA XREF: .data:0000004Co
.rdata:00000528 $SG145464       db ']',9,'c #6197DD',0  ; DATA XREF: .data:00000050o
.rdata:00000534 $SG145465       db '^',9,'c #96B9E6',0  ; DATA XREF: .data:00000054o
.rdata:00000540 $SG145466       db '/',9,'c #538EDB',0  ; DATA XREF: .data:00000058o
.rdata:0000054C $SG145467       db '(',9,'c #99BBEA',0  ; DATA XREF: .data:0000005Co
.rdata:00000558 $SG145468       db '_',9,'c #80AAE3',0  ; DATA XREF: .data:00000060o
.rdata:00000564 $SG145469       db ':',9,'c #81ABE3',0  ; DATA XREF: .data:00000064o
.rdata:00000570 $SG145470       db '<',9,'c #8AB1E4',0  ; DATA XREF: .data:00000068o
.rdata:0000057C $SG145471       db '[',9,'c #4B88D6',0  ; DATA XREF: .data:0000006Co
.rdata:00000588 $SG145472       db '}',9,'c #4882D1',0  ; DATA XREF: .data:00000070o
.rdata:00000594 $SG145473       db '|',9,'c #4384D6',0  ; DATA XREF: .data:00000074o
.rdata:000005A0 $SG145474       db '1',9,'c #90B5E7',0  ; DATA XREF: .data:00000078o
.rdata:000005AC $SG145475       db '2',9,'c #74A3E0',0  ; DATA XREF: .data:0000007Co
.rdata:000005B8 $SG145476       db '3',9,'c #77A4E0',0  ; DATA XREF: .data:00000080o
.rdata:000005C4 $SG145477       db '4',9,'c #81ABE2',0  ; DATA XREF: .data:00000084o
.rdata:000005D0 $SG145478       db '5',9,'c #437FD3',0  ; DATA XREF: .data:00000088o
.rdata:000005DC $SG145479       db '6',9,'c #7FA2DF',0  ; DATA XREF: .data:0000008Co
.rdata:000005E8 $SG145480       db '7',9,'c #3577D2',0  ; DATA XREF: .data:00000090o
.rdata:000005F4 $SG145481       db '8',9,'c #87AFE4',0  ; DATA XREF: .data:00000094o
.rdata:00000600 $SG145482       db '9',9,'c #72A1DF',0  ; DATA XREF: .data:00000098o
.rdata:0000060C $SG145483       db '0',9,'c #7CA9E1',0  ; DATA XREF: .data:0000009Co
.rdata:00000618 $SG145484       db 'a',9,'c #3F7AD0',0  ; DATA XREF: .data:000000A0o
.rdata:00000624 $SG145485       db 'b',9,'c #85A4DE',0  ; DATA XREF: .data:000000A4o
.rdata:00000630 $SG145486       db 'c',9,'c #FBFCFE',0  ; DATA XREF: .data:000000A8o
.rdata:0000063C $SG145487       db 'd',9,'c #236ECD',0  ; DATA XREF: .data:000000ACo
.rdata:00000648 $SG145488       db 'e',9,'c #7EA8E1',0  ; DATA XREF: .data:000000B0o
.rdata:00000654 $SG145489       db 'f',9,'c #79A6E0',0  ; DATA XREF: .data:000000B4o
.rdata:00000660 $SG145490       db 'g',9,'c #3D77D0',0  ; DATA XREF: .data:000000B8o
.rdata:0000066C $SG145491       db 'h',9,'c #87A4DC',0  ; DATA XREF: .data:000000BCo
.rdata:00000678 $SG145492       db 'i',9,'c #1A62C9',0  ; DATA XREF: .data:000000C0o
.rdata:00000684 $SG145493       db 'j',9,'c #75A3DF',0  ; DATA XREF: .data:000000C4o
.rdata:00000690 $SG145494       db 'k',9,'c #3C74CF',0  ; DATA XREF: .data:000000C8o
.rdata:0000069C $SG145495       db 'l',9,'c #8DA6DE',0  ; DATA XREF: .data:000000CCo
.rdata:000006A8 $SG145496       db 'm',9,'c #1859C4',0  ; DATA XREF: .data:000000D0o
.rdata:000006B4 $SG145497       db 'n',9,'c #3B71CC',0  ; DATA XREF: .data:000000D4o
.rdata:000006C0 $SG145498       db 'o',9,'c #8EA5DD',0  ; DATA XREF: .data:000000D8o
.rdata:000006CC $SG145499       db 'p',9,'c #164EC0',0  ; DATA XREF: .data:000000DCo
.rdata:000006D8 $SG145500       db 'q',9,'c #92A7DD',0  ; DATA XREF: .data:000000E0o
.rdata:000006E4 $SG145501       db '    .+      ',0     ; DATA XREF: .data:000000E4o
.rdata:000006F1                 align 4
.rdata:000006F4 $SG145502       db '    @#$     ',0     ; DATA XREF: .data:000000E8o
.rdata:00000701                 align 4
.rdata:00000704 $SG145503       db '    %&*=    ',0     ; DATA XREF: .data:000000ECo
.rdata:00000711                 align 4
.rdata:00000714 $SG145504       db '    -;>,',27h,'   ',0 ; DATA XREF: .data:000000F0o
.rdata:00000721                 align 4
.rdata:00000724 $SG145505       db '    )!~{]^  ',0     ; DATA XREF: .data:000000F4o
.rdata:00000731                 align 4
.rdata:00000734 $SG145506       db '    /(_:<[} ',0     ; DATA XREF: .data:000000F8o
.rdata:00000741                 align 4
.rdata:00000744 $SG145507       db '    |123456 ',0     ; DATA XREF: .data:000000FCo
.rdata:00000751                 align 4
.rdata:00000754 $SG145508       db '    7890abc ',0     ; DATA XREF: .data:00000100o
.rdata:00000761                 align 4
.rdata:00000764 $SG145509       db '    defgh   ',0     ; DATA XREF: .data:00000104o
.rdata:00000771                 align 4
.rdata:00000774 $SG145510       db '    ijkl    ',0     ; DATA XREF: .data:00000108o
.rdata:00000781                 align 4
.rdata:00000784 $SG145511       db '    mno     ',0     ; DATA XREF: .data:0000010Co
.rdata:00000791                 align 4
.rdata:00000794 $SG145512       db '    pq      ',0     ; DATA XREF: .data:00000110o
.rdata:000007A1                 align 4
.rdata:000007A4 $SG145514       db '12 12 54 1',0       ; DATA XREF: .data:_acBottom_xpmo
.rdata:000007AF                 align 10h
.rdata:000007B0 $SG145515       db ' ',9,'c #FFFFFF',0  ; DATA XREF: .data:0000011Co
.rdata:000007BC $SG145516       db '.',9,'c #C4D7F3',0  ; DATA XREF: .data:00000120o
.rdata:000007C8 $SG145517       db '+',9,'c #72A1E3',0  ; DATA XREF: .data:00000124o
.rdata:000007D4 $SG145518       db '@',9,'c #C1D6F2',0  ; DATA XREF: .data:00000128o
.rdata:000007E0 $SG145519       db '#',9,'c #6397E1',0  ; DATA XREF: .data:0000012Co
.rdata:000007EC $SG145520       db '$',9,'c #5990DD',0  ; DATA XREF: .data:00000130o
.rdata:000007F8 $SG145521       db '%',9,'c #BBD2F0',0  ; DATA XREF: .data:00000134o
.rdata:00000804 $SG145522       db '&',9,'c #7AA6E5',0  ; DATA XREF: .data:00000138o
.rdata:00000810 $SG145523       db '*',9,'c #9ABDEA',0  ; DATA XREF: .data:0000013Co
.rdata:0000081C $SG145524       db '=',9,'c #4A87D9',0  ; DATA XREF: .data:00000140o
.rdata:00000828 $SG145525       db '-',9,'c #B1CAEE',0  ; DATA XREF: .data:00000144o
.rdata:00000834 $SG145526       db ';',9,'c #75A4E3',0  ; DATA XREF: .data:00000148o
.rdata:00000840 $SG145527       db '>',9,'c #99BBE9',0  ; DATA XREF: .data:0000014Co
.rdata:0000084C $SG145528       db ',',9,'c #95B9E8',0  ; DATA XREF: .data:00000150o
.rdata:00000858 $SG145529       db 27h,9,'c #3A7CD4',0  ; DATA XREF: .data:00000154o
.rdata:00000864 $SG145530       db ')',9,'c #A9C6EC',0  ; DATA XREF: .data:00000158o
.rdata:00000870 $SG145531       db '!',9,'c #71A0E0',0  ; DATA XREF: .data:0000015Co
.rdata:0000087C $SG145532       db '~',9,'c #86AFE5',0  ; DATA XREF: .data:00000160o
.rdata:00000888 $SG145533       db '{',9,'c #8DB2E6',0  ; DATA XREF: .data:00000164o
.rdata:00000894 $SG145534       db ']',9,'c #2A72CF',0  ; DATA XREF: .data:00000168o
.rdata:000008A0 $SG145535       db '^',9,'c #73A0E0',0  ; DATA XREF: .data:0000016Co
.rdata:000008AC $SG145536       db '/',9,'c #6B9DE0',0  ; DATA XREF: .data:00000170o
.rdata:000008B8 $SG145537       db '(',9,'c #95B8E8',0  ; DATA XREF: .data:00000174o
.rdata:000008C4 $SG145538       db '_',9,'c #81ABE3',0  ; DATA XREF: .data:00000178o
.rdata:000008D0 $SG145539       db ':',9,'c #72A1DF',0  ; DATA XREF: .data:0000017Co
.rdata:000008DC $SG145540       db '<',9,'c #83ADE3',0  ; DATA XREF: .data:00000180o
.rdata:000008E8 $SG145541       db '[',9,'c #1B65C9',0  ; DATA XREF: .data:00000184o
.rdata:000008F4 $SG145542       db '}',9,'c #5F95DC',0  ; DATA XREF: .data:00000188o
.rdata:00000900 $SG145543       db '|',9,'c #8BB3E5',0  ; DATA XREF: .data:0000018Co
.rdata:0000090C $SG145544       db '1',9,'c #77A4E0',0  ; DATA XREF: .data:00000190o
.rdata:00000918 $SG145545       db '2',9,'c #679ADC',0  ; DATA XREF: .data:00000194o
.rdata:00000924 $SG145546       db '3',9,'c #7AA6E1',0  ; DATA XREF: .data:00000198o
.rdata:00000930 $SG145547       db '4',9,'c #195CC6',0  ; DATA XREF: .data:0000019Co
.rdata:0000093C $SG145548       db '5',9,'c #FCFDFE',0  ; DATA XREF: .data:000001A0o
.rdata:00000948 $SG145549       db '6',9,'c #8DB2E4',0  ; DATA XREF: .data:000001A4o
.rdata:00000954 $SG145550       db '7',9,'c #4885D6',0  ; DATA XREF: .data:000001A8o
.rdata:00000960 $SG145551       db '8',9,'c #7CA9E1',0  ; DATA XREF: .data:000001ACo
.rdata:0000096C $SG145552       db '9',9,'c #6698DB',0  ; DATA XREF: .data:000001B0o
.rdata:00000978 $SG145553       db '0',9,'c #71A1DE',0  ; DATA XREF: .data:000001B4o
.rdata:00000984 $SG145554       db 'a',9,'c #1752C0',0  ; DATA XREF: .data:000001B8o
.rdata:00000990 $SG145555       db 'b',9,'c #88ABE0',0  ; DATA XREF: .data:000001BCo
.rdata:0000099C $SG145556       db 'c',9,'c #3D77D0',0  ; DATA XREF: .data:000001C0o
.rdata:000009A8 $SG145557       db 'd',9,'c #6E9FDD',0  ; DATA XREF: .data:000001C4o
.rdata:000009B4 $SG145558       db 'e',9,'c #699BDC',0  ; DATA XREF: .data:000001C8o
.rdata:000009C0 $SG145559       db 'f',9,'c #1547BD',0  ; DATA XREF: .data:000001CCo
.rdata:000009CC $SG145560       db 'g',9,'c #8DA6DE',0  ; DATA XREF: .data:000001D0o
.rdata:000009D8 $SG145561       db 'h',9,'c #376BC9',0  ; DATA XREF: .data:000001D4o
.rdata:000009E4 $SG145562       db 'i',9,'c #6295DA',0  ; DATA XREF: .data:000001D8o
.rdata:000009F0 $SG145563       db 'j',9,'c #1440B9',0  ; DATA XREF: .data:000001DCo
.rdata:000009FC $SG145564       db 'k',9,'c #8DA0DB',0  ; DATA XREF: .data:000001E0o
.rdata:00000A08 $SG145565       db 'l',9,'c #315FC4',0  ; DATA XREF: .data:000001E4o
.rdata:00000A14 $SG145566       db 'm',9,'c #1339B7',0  ; DATA XREF: .data:000001E8o
.rdata:00000A20 $SG145567       db 'n',9,'c #909FDA',0  ; DATA XREF: .data:000001ECo
.rdata:00000A2C $SG145568       db 'o',9,'c #1233B4',0  ; DATA XREF: .data:000001F0o
.rdata:00000A38 $SG145569       db '         .+ ',0     ; DATA XREF: .data:000001F4o
.rdata:00000A45                 align 4
.rdata:00000A48 $SG145570       db '        @#$ ',0     ; DATA XREF: .data:000001F8o
.rdata:00000A55                 align 4
.rdata:00000A58 $SG145571       db '       %&*= L',0    ; DATA XREF: .data:000001FCo
.rdata:00000A66                 align 4
.rdata:00000A68 $SG145572       db '      -;>,',27h,' ',0 ; DATA XREF: .data:00000200o
.rdata:00000A75                 align 4
.rdata:00000A78 $SG145573       db '     )!>~{] ',0     ; DATA XREF: .data:00000204o
.rdata:00000A85                 align 4
.rdata:00000A88 $SG145574       db '    ^/(_:<[ ',0     ; DATA XREF: .data:00000208o
.rdata:00000A95                 align 4
.rdata:00000A98 $SG145575       db '    (}|1234 ',0     ; DATA XREF: .data:0000020Co
.rdata:00000AA5                 align 4
.rdata:00000AA8 $SG145576       db '    567890a ',0     ; DATA XREF: .data:00000210o
.rdata:00000AB5                 align 4
.rdata:00000AB8 $SG145577       db '      bcdef ',0     ; DATA XREF: .data:00000214o
.rdata:00000AC5                 align 4
.rdata:00000AC8 $SG145578       db '       ghij ',0     ; DATA XREF: .data:00000218o
.rdata:00000AD5                 align 4
.rdata:00000AD8 $SG145579       db '        klm ',0     ; DATA XREF: .data:0000021Co
.rdata:00000AE5                 align 4
.rdata:00000AE8 $SG145580       db '         no ',0     ; DATA XREF: .data:00000220o
.rdata:00000AF5                 align 4
.rdata:00000AF8 $SG145582       db '13 14 54 1',0       ; DATA XREF: .data:_bookmark_xpmo
.rdata:00000B03                 align 4
.rdata:00000B04 $SG145583       db ' ',9,'c None',0     ; DATA XREF: .data:0000022Co
.rdata:00000B0D                 align 10h
.rdata:00000B10 $SG145584       db '.',9,'c #545254',0  ; DATA XREF: .data:00000230o
.rdata:00000B1C $SG145585       db '+',9,'c #3C3E3C',0  ; DATA XREF: .data:00000234o
.rdata:00000B28 $SG145586       db '@',9,'c #646464',0  ; DATA XREF: .data:00000238o
.rdata:00000B34 $SG145587       db '#',9,'c #A4A4A4',0  ; DATA XREF: .data:0000023Co
.rdata:00000B40 $SG145588       db '$',9,'c #B7B8B7',0  ; DATA XREF: .data:00000240o
.rdata:00000B4C $SG145589       db '%',9,'c #747284',0  ; DATA XREF: .data:00000244o
.rdata:00000B58 $SG145590       db '&',9,'c #B4B2C4',0  ; DATA XREF: .data:00000248o
.rdata:00000B64 $SG145591       db '*',9,'c #DCD7E4',0  ; DATA XREF: .data:0000024Co
.rdata:00000B70 $SG145592       db '=',9,'c #1C1A1C',0  ; DATA XREF: .data:00000250o
.rdata:00000B7C $SG145593       db '-',9,'c #403E58',0  ; DATA XREF: .data:00000254o
.rdata:00000B88 $SG145594       db ';',9,'c #5C5A8C',0  ; DATA XREF: .data:00000258o
.rdata:00000B94 $SG145595       db '>',9,'c #7C7EAC',0  ; DATA XREF: .data:0000025Co
.rdata:00000BA0 $SG145596       db ',',9,'c #7C8EBC',0  ; DATA XREF: .data:00000260o
.rdata:00000BAC $SG145597       db 27h,9,'c #242644',0  ; DATA XREF: .data:00000264o
.rdata:00000BB8 $SG145598       db ')',9,'c #282668',0  ; DATA XREF: .data:00000268o
.rdata:00000BC4 $SG145599       db '!',9,'c #24367C',0  ; DATA XREF: .data:0000026Co
.rdata:00000BD0 $SG145600       db '~',9,'c #244A84',0  ; DATA XREF: .data:00000270o
.rdata:00000BDC $SG145601       db '{',9,'c #2C5098',0  ; DATA XREF: .data:00000274o
.rdata:00000BE8 $SG145602       db ']',9,'c #14162C',0  ; DATA XREF: .data:00000278o
.rdata:00000BF4 $SG145603       db '^',9,'c #142E7C',0  ; DATA XREF: .data:0000027Co
.rdata:00000C00 $SG145604       db '/',9,'c #143789',0  ; DATA XREF: .data:00000280o
.rdata:00000C0C $SG145605       db '(',9,'c #204990',0  ; DATA XREF: .data:00000284o
.rdata:00000C18 $SG145606       db '_',9,'c #174091',0  ; DATA XREF: .data:00000288o
.rdata:00000C24 $SG145607       db ':',9,'c #0C0630',0  ; DATA XREF: .data:0000028Co
.rdata:00000C30 $SG145608       db '<',9,'c #24327C',0  ; DATA XREF: .data:00000290o
.rdata:00000C3C $SG145609       db '[',9,'c #2450A0',0  ; DATA XREF: .data:00000294o
.rdata:00000C48 $SG145610       db '}',9,'c #345DB4',0  ; DATA XREF: .data:00000298o
.rdata:00000C54 $SG145611       db '|',9,'c #3C68B8',0  ; DATA XREF: .data:0000029Co
.rdata:00000C60 $SG145612       db '1',9,'c #141244',0  ; DATA XREF: .data:000002A0o
.rdata:00000C6C $SG145613       db '2',9,'c #24428C',0  ; DATA XREF: .data:000002A4o
.rdata:00000C78 $SG145614       db '3',9,'c #3462B9',0  ; DATA XREF: .data:000002A8o
.rdata:00000C84 $SG145615       db '4',9,'c #4470C4',0  ; DATA XREF: .data:000002ACo
.rdata:00000C90 $SG145616       db '5',9,'c #4C7FD6',0  ; DATA XREF: .data:000002B0o
.rdata:00000C9C $SG145617       db '6',9,'c #4472CC',0  ; DATA XREF: .data:000002B4o
.rdata:00000CA8 $SG145618       db '7',9,'c #24224C',0  ; DATA XREF: .data:000002B8o
.rdata:00000CB4 $SG145619       db '8',9,'c #5C8DEC',0  ; DATA XREF: .data:000002BCo
.rdata:00000CC0 $SG145620       db '9',9,'c #5C94F6',0  ; DATA XREF: .data:000002C0o
.rdata:00000CCC $SG145621       db '0',9,'c #5482DF',0  ; DATA XREF: .data:000002C4o
.rdata:00000CD8 $SG145622       db 'a',9,'c #619DF7',0  ; DATA XREF: .data:000002C8o
.rdata:00000CE4 $SG145623       db 'b',9,'c #6CA6FC',0  ; DATA XREF: .data:000002CCo
.rdata:00000CF0 $SG145624       db 'c',9,'c #64A2FC',0  ; DATA XREF: .data:000002D0o
.rdata:00000CFC $SG145625       db 'd',9,'c #1C2E5C',0  ; DATA XREF: .data:000002D4o
.rdata:00000D08 $SG145626       db 'e',9,'c #6CA2FC',0  ; DATA XREF: .data:000002D8o
.rdata:00000D14 $SG145627       db 'f',9,'c #74B2FC',0  ; DATA XREF: .data:000002DCo
.rdata:00000D20 $SG145628       db 'g',9,'c #7CB8FC',0  ; DATA XREF: .data:000002E0o
.rdata:00000D2C $SG145629       db 'h',9,'c #1C3264',0  ; DATA XREF: .data:000002E4o
.rdata:00000D38 $SG145630       db 'i',9,'c #346AD4',0  ; DATA XREF: .data:000002E8o
.rdata:00000D44 $SG145631       db 'j',9,'c #7CBEFC',0  ; DATA XREF: .data:000002ECo
.rdata:00000D50 $SG145632       db 'k',9,'c #3C72DC',0  ; DATA XREF: .data:000002F0o
.rdata:00000D5C $SG145633       db 'l',9,'c #243250',0  ; DATA XREF: .data:000002F4o
.rdata:00000D68 $SG145634       db 'm',9,'c #346AB4',0  ; DATA XREF: .data:000002F8o
.rdata:00000D74 $SG145635       db 'n',9,'c #3C82DC',0  ; DATA XREF: .data:000002FCo
.rdata:00000D80 $SG145636       db 'o',9,'c #6C6A6C',0  ; DATA XREF: .data:00000300o
.rdata:00000D8C $SG145637       db '     .+.     ',0    ; DATA XREF: .data:00000304o
.rdata:00000D9A                 align 4
.rdata:00000D9C $SG145638       db '   @##$##@   ',0    ; DATA XREF: .data:00000308o
.rdata:00000DAA                 align 4
.rdata:00000DAC $SG145639       db '  @%&***&%@  ',0    ; DATA XREF: .data:0000030Co
.rdata:00000DBA                 align 4
.rdata:00000DBC $SG145640       db ' =-;>,,,>;-= ',0    ; DATA XREF: .data:00000310o
.rdata:00000DCA                 align 4
.rdata:00000DCC $SG145641       db ' ',27h,')!~{{{~!)',27h,' ',0
.rdata:00000DCC                                         ; DATA XREF: .data:00000314o
.rdata:00000DDA                 align 4
.rdata:00000DDC $SG145642       db '])^/({{{(_^)]',0    ; DATA XREF: .data:00000318o
.rdata:00000DEA                 align 4
.rdata:00000DEC $SG145643       db ':<_[}|||}[_<:',0    ; DATA XREF: .data:0000031Co
.rdata:00000DFA                 align 4
.rdata:00000DFC $SG145644       db '12[3455563[21',0    ; DATA XREF: .data:00000320o
.rdata:00000E0A                 align 4
.rdata:00000E0C $SG145645       db '7_365899063_7',0    ; DATA XREF: .data:00000324o
.rdata:00000E1A                 align 4
.rdata:00000E1C $SG145646       db ' /|09abc904/ ',0    ; DATA XREF: .data:00000328o
.rdata:00000E2A                 align 4
.rdata:00000E2C $SG145647       db ' d}8efgfb83d ',0    ; DATA XREF: .data:0000032Co
.rdata:00000E3A                 align 4
.rdata:00000E3C $SG145648       db '  hiafjgakh  ',0    ; DATA XREF: .data:00000330o
.rdata:00000E4A                 align 4
.rdata:00000E4C $SG145649       db '   l~mnm~l   ',0    ; DATA XREF: .data:00000334o
.rdata:00000E5A                 align 4
.rdata:00000E5C $SG145650       db '     o@o     ',0    ; DATA XREF: .data:00000338o
.rdata:00000E6A                 align 4
.rdata:00000E6A _rdata          ends
.rdata:00000E6A
.text$mn:00000E6C ; ===========================================================================
.text$mn:00000E6C
.text$mn:00000E6C ; Segment type: Pure code
.text$mn:00000E6C ; Segment permissions: Read/Execute
.text$mn:00000E6C _text$mn        segment para public 'CODE' use32
.text$mn:00000E6C                 assume cs:_text$mn
.text$mn:00000E6C                 ;org 0E6Ch
.text$mn:00000E6C                 assume es:nothing, ss:nothing, ds:_data, fs:nothing, gs:nothing
.text$mn:00000E6C
.text$mn:00000E6C ; =============== S U B R O U T I N E =======================================
.text$mn:00000E6C
.text$mn:00000E6C ; Attributes: bp-based frame
.text$mn:00000E6C
.text$mn:00000E6C ; void __thiscall ViewZoneDlg::doDialog(ViewZoneDlg *__hidden this)
.text$mn:00000E6C                 public ?doDialog@ViewZoneDlg@@QAEXXZ
.text$mn:00000E6C ?doDialog@ViewZoneDlg@@QAEXXZ proc near ; CODE XREF: DocumentMap::run_dlgProc(uint,uint,long)+136p
.text$mn:00000E6C
.text$mn:00000E6C var_4           = dword ptr -4
.text$mn:00000E6C
.text$mn:00000E6C                 push    ebp
.text$mn:00000E6D                 mov     ebp, esp
.text$mn:00000E6F                 push    ecx
.text$mn:00000E70                 mov     [ebp+var_4], ecx
.text$mn:00000E73                 mov     eax, [ebp+var_4]
.text$mn:00000E76                 mov     edx, [eax]
.text$mn:00000E78                 mov     ecx, [ebp+var_4]
.text$mn:00000E7B                 mov     eax, [edx+34h]
.text$mn:00000E7E                 call    eax
.text$mn:00000E80                 movzx   ecx, al
.text$mn:00000E83                 test    ecx, ecx
.text$mn:00000E85                 jnz     short loc_E9D
.text$mn:00000E87                 push    1
.text$mn:00000E89                 push    0
.text$mn:00000E8B                 push    0CF8h
.text$mn:00000E90                 mov     edx, [ebp+var_4]
.text$mn:00000E93                 mov     eax, [edx]
.text$mn:00000E95                 mov     ecx, [ebp+var_4]
.text$mn:00000E98                 mov     edx, [eax+30h]
.text$mn:00000E9B                 call    edx
.text$mn:00000E9D
.text$mn:00000E9D loc_E9D:                                ; CODE XREF: ViewZoneDlg::doDialog(void)+19j
.text$mn:00000E9D                 push    1
.text$mn:00000E9F                 mov     eax, [ebp+var_4]
.text$mn:00000EA2                 mov     edx, [eax]
.text$mn:00000EA4                 mov     ecx, [ebp+var_4]
.text$mn:00000EA7                 mov     eax, [edx+0Ch]
.text$mn:00000EAA                 call    eax
.text$mn:00000EAC                 mov     esp, ebp
.text$mn:00000EAE                 pop     ebp
.text$mn:00000EAF                 retn
.text$mn:00000EAF ?doDialog@ViewZoneDlg@@QAEXXZ endp
.text$mn:00000EAF
.text$mn:00000EAF ; ---------------------------------------------------------------------------
.text$mn:00000EB0                 db 0Ch dup(0CCh)
.text$mn:00000EBC
.text$mn:00000EBC ; =============== S U B R O U T I N E =======================================
.text$mn:00000EBC
.text$mn:00000EBC ; Attributes: bp-based frame
.text$mn:00000EBC
.text$mn:00000EBC ; int __stdcall ViewZoneDlg::run_dlgProc(LONG dwNewLong, unsigned int, WPARAM wParam, LPARAM lParam)
.text$mn:00000EBC                 public ?run_dlgProc@ViewZoneDlg@@MAGHIIJ@Z
.text$mn:00000EBC ?run_dlgProc@ViewZoneDlg@@MAGHIIJ@Z proc near
.text$mn:00000EBC
.text$mn:00000EBC nWidth          = dword ptr -0Ch
.text$mn:00000EBC nHeight         = dword ptr -8
.text$mn:00000EBC var_4           = dword ptr -4
.text$mn:00000EBC dwNewLong       = dword ptr  8
.text$mn:00000EBC arg_4           = dword ptr  0Ch
.text$mn:00000EBC wParam          = dword ptr  10h
.text$mn:00000EBC lParam          = dword ptr  14h
.text$mn:00000EBC
.text$mn:00000EBC                 push    ebp
.text$mn:00000EBD                 mov     ebp, esp
.text$mn:00000EBF                 sub     esp, 0Ch
.text$mn:00000EC2                 mov     eax, [ebp+arg_4]
.text$mn:00000EC5                 mov     [ebp+var_4], eax
.text$mn:00000EC8                 cmp     [ebp+var_4], 110h
.text$mn:00000ECF                 ja      short loc_EFD
.text$mn:00000ED1                 cmp     [ebp+var_4], 110h
.text$mn:00000ED8                 jz      short loc_F25
.text$mn:00000EDA                 cmp     [ebp+var_4], 2
.text$mn:00000EDE                 jz      loc_1043
.text$mn:00000EE4                 cmp     [ebp+var_4], 5
.text$mn:00000EE8                 jz      loc_FDB
.text$mn:00000EEE                 cmp     [ebp+var_4], 2Bh ; '+'
.text$mn:00000EF2                 jz      loc_FC8
.text$mn:00000EF8                 jmp     loc_104A
.text$mn:00000EFD ; ---------------------------------------------------------------------------
.text$mn:00000EFD
.text$mn:00000EFD loc_EFD:                                ; CODE XREF: ViewZoneDlg::run_dlgProc(uint,uint,long)+13j
.text$mn:00000EFD                 cmp     [ebp+var_4], 200h
.text$mn:00000F04                 jz      loc_FA1
.text$mn:00000F0A                 cmp     [ebp+var_4], 201h
.text$mn:00000F11                 jz      short loc_F82
.text$mn:00000F13                 cmp     [ebp+var_4], 20Ah
.text$mn:00000F1A                 jz      loc_1022
.text$mn:00000F20                 jmp     loc_104A
.text$mn:00000F25 ; ---------------------------------------------------------------------------
.text$mn:00000F25
.text$mn:00000F25 loc_F25:                                ; CODE XREF: ViewZoneDlg::run_dlgProc(uint,uint,long)+1Cj
.text$mn:00000F25                 push    0CF9h           ; nIDDlgItem
.text$mn:00000F2A                 mov     ecx, [ebp+dwNewLong]
.text$mn:00000F2D                 mov     edx, [ecx+0Ch]
.text$mn:00000F30                 push    edx             ; hDlg
.text$mn:00000F31                 call    dword ptr ds:__imp__GetDlgItem@8 ; GetDlgItem(x,x)
.text$mn:00000F37                 mov     ecx, [ebp+dwNewLong]
.text$mn:00000F3A                 mov     [ecx+20h], eax
.text$mn:00000F3D                 mov     edx, [ebp+dwNewLong]
.text$mn:00000F40                 cmp     dword ptr [edx+20h], 0
.text$mn:00000F44                 jz      short loc_F7D
.text$mn:00000F46                 mov     eax, [ebp+dwNewLong]
.text$mn:00000F49                 push    eax             ; dwNewLong
.text$mn:00000F4A                 push    0FFFFFFEBh      ; nIndex
.text$mn:00000F4C                 mov     ecx, [ebp+dwNewLong]
.text$mn:00000F4F                 mov     edx, [ecx+20h]
.text$mn:00000F52                 push    edx             ; hWnd
.text$mn:00000F53                 call    dword ptr ds:__imp__SetWindowLongW@12 ; SetWindowLongW(x,x,x)
.text$mn:00000F59                 push    offset ?canvasStaticProc@ViewZoneDlg@@KGJPAUHWND__@@IIJ@Z ; dwNewLong
.text$mn:00000F5E                 push    0FFFFFFFCh      ; nIndex
.text$mn:00000F60                 mov     eax, [ebp+dwNewLong]
.text$mn:00000F63                 mov     ecx, [eax+20h]
.text$mn:00000F66                 push    ecx             ; hWnd
.text$mn:00000F67                 call    dword ptr ds:__imp__SetWindowLongW@12 ; SetWindowLongW(x,x,x)
.text$mn:00000F6D                 mov     edx, [ebp+dwNewLong]
.text$mn:00000F70                 mov     [edx+24h], eax
.text$mn:00000F73                 mov     eax, 1
.text$mn:00000F78                 jmp     loc_104C
.text$mn:00000F7D ; ---------------------------------------------------------------------------
.text$mn:00000F7D
.text$mn:00000F7D loc_F7D:                                ; CODE XREF: ViewZoneDlg::run_dlgProc(uint,uint,long)+88j
.text$mn:00000F7D                 jmp     loc_104A
.text$mn:00000F82 ; ---------------------------------------------------------------------------
.text$mn:00000F82
.text$mn:00000F82 loc_F82:                                ; CODE XREF: ViewZoneDlg::run_dlgProc(uint,uint,long)+55j
.text$mn:00000F82                 mov     eax, [ebp+lParam]
.text$mn:00000F85                 push    eax             ; lParam
.text$mn:00000F86                 mov     ecx, [ebp+wParam]
.text$mn:00000F89                 push    ecx             ; wParam
.text$mn:00000F8A                 push    402h            ; Msg
.text$mn:00000F8F                 mov     edx, [ebp+dwNewLong]
.text$mn:00000F92                 mov     eax, [edx+8]
.text$mn:00000F95                 push    eax             ; hWnd
.text$mn:00000F96                 call    dword ptr ds:__imp__SendMessageW@16 ; SendMessageW(x,x,x,x)
.text$mn:00000F9C                 jmp     loc_104A
.text$mn:00000FA1 ; ---------------------------------------------------------------------------
.text$mn:00000FA1
.text$mn:00000FA1 loc_FA1:                                ; CODE XREF: ViewZoneDlg::run_dlgProc(uint,uint,long)+48j
.text$mn:00000FA1                 mov     ecx, [ebp+wParam]
.text$mn:00000FA4                 and     ecx, 1
.text$mn:00000FA7                 jz      short loc_FC3
.text$mn:00000FA9                 mov     edx, [ebp+lParam]
.text$mn:00000FAC                 push    edx             ; lParam
.text$mn:00000FAD                 mov     eax, [ebp+wParam]
.text$mn:00000FB0                 push    eax             ; wParam
.text$mn:00000FB1                 push    402h            ; Msg
.text$mn:00000FB6                 mov     ecx, [ebp+dwNewLong]
.text$mn:00000FB9                 mov     edx, [ecx+8]
.text$mn:00000FBC                 push    edx             ; hWnd
.text$mn:00000FBD                 call    dword ptr ds:__imp__SendMessageW@16 ; SendMessageW(x,x,x,x)
.text$mn:00000FC3
.text$mn:00000FC3 loc_FC3:                                ; CODE XREF: ViewZoneDlg::run_dlgProc(uint,uint,long)+EBj
.text$mn:00000FC3                 jmp     loc_104A
.text$mn:00000FC8 ; ---------------------------------------------------------------------------
.text$mn:00000FC8
.text$mn:00000FC8 loc_FC8:                                ; CODE XREF: ViewZoneDlg::run_dlgProc(uint,uint,long)+36j
.text$mn:00000FC8                 mov     eax, [ebp+lParam]
.text$mn:00000FCB                 push    eax             ; struct tagDRAWITEMSTRUCT *
.text$mn:00000FCC                 mov     ecx, [ebp+dwNewLong] ; this
.text$mn:00000FCF                 call    ?drawPreviewZone@ViewZoneDlg@@IAEXPAUtagDRAWITEMSTRUCT@@@Z ; ViewZoneDlg::drawPreviewZone(tagDRAWITEMSTRUCT *)
.text$mn:00000FD4                 mov     eax, 1
.text$mn:00000FD9                 jmp     short loc_104C
.text$mn:00000FDB ; ---------------------------------------------------------------------------
.text$mn:00000FDB
.text$mn:00000FDB loc_FDB:                                ; CODE XREF: ViewZoneDlg::run_dlgProc(uint,uint,long)+2Cj
.text$mn:00000FDB                 mov     ecx, [ebp+dwNewLong]
.text$mn:00000FDE                 cmp     dword ptr [ecx+20h], 0
.text$mn:00000FE2                 jz      short loc_1020
.text$mn:00000FE4                 mov     edx, [ebp+lParam]
.text$mn:00000FE7                 and     edx, 0FFFFh
.text$mn:00000FED                 movzx   eax, dx
.text$mn:00000FF0                 mov     [ebp+nWidth], eax
.text$mn:00000FF3                 mov     ecx, [ebp+lParam]
.text$mn:00000FF6                 shr     ecx, 10h
.text$mn:00000FF9                 and     ecx, 0FFFFh
.text$mn:00000FFF                 movzx   edx, cx
.text$mn:00001002                 mov     [ebp+nHeight], edx
.text$mn:00001005                 push    1               ; bRepaint
.text$mn:00001007                 mov     eax, [ebp+nHeight]
.text$mn:0000100A                 push    eax             ; nHeight
.text$mn:0000100B                 mov     ecx, [ebp+nWidth]
.text$mn:0000100E                 push    ecx             ; nWidth
.text$mn:0000100F                 push    0               ; Y
.text$mn:00001011                 push    0               ; X
.text$mn:00001013                 mov     edx, [ebp+dwNewLong]
.text$mn:00001016                 mov     eax, [edx+20h]
.text$mn:00001019                 push    eax             ; hWnd
.text$mn:0000101A                 call    dword ptr ds:__imp__MoveWindow@24 ; MoveWindow(x,x,x,x,x,x)
.text$mn:00001020
.text$mn:00001020 loc_1020:                               ; CODE XREF: ViewZoneDlg::run_dlgProc(uint,uint,long)+126j
.text$mn:00001020                 jmp     short loc_104A
.text$mn:00001022 ; ---------------------------------------------------------------------------
.text$mn:00001022
.text$mn:00001022 loc_1022:                               ; CODE XREF: ViewZoneDlg::run_dlgProc(uint,uint,long)+5Ej
.text$mn:00001022                 mov     ecx, [ebp+lParam]
.text$mn:00001025                 push    ecx             ; lParam
.text$mn:00001026                 mov     edx, [ebp+wParam]
.text$mn:00001029                 push    edx             ; wParam
.text$mn:0000102A                 push    403h            ; Msg
.text$mn:0000102F                 mov     eax, [ebp+dwNewLong]
.text$mn:00001032                 mov     ecx, [eax+8]
.text$mn:00001035                 push    ecx             ; hWnd
.text$mn:00001036                 call    dword ptr ds:__imp__SendMessageW@16 ; SendMessageW(x,x,x,x)
.text$mn:0000103C                 mov     eax, 1
.text$mn:00001041                 jmp     short loc_104C
.text$mn:00001043 ; ---------------------------------------------------------------------------
.text$mn:00001043
.text$mn:00001043 loc_1043:                               ; CODE XREF: ViewZoneDlg::run_dlgProc(uint,uint,long)+22j
.text$mn:00001043                 mov     eax, 1
.text$mn:00001048                 jmp     short loc_104C
.text$mn:0000104A ; ---------------------------------------------------------------------------
.text$mn:0000104A
.text$mn:0000104A loc_104A:                               ; CODE XREF: ViewZoneDlg::run_dlgProc(uint,uint,long)+3Cj
.text$mn:0000104A                                         ; ViewZoneDlg::run_dlgProc(uint,uint,long)+64j ...
.text$mn:0000104A                 xor     eax, eax
.text$mn:0000104C
.text$mn:0000104C loc_104C:                               ; CODE XREF: ViewZoneDlg::run_dlgProc(uint,uint,long)+BCj
.text$mn:0000104C                                         ; ViewZoneDlg::run_dlgProc(uint,uint,long)+11Dj ...
.text$mn:0000104C                 mov     esp, ebp
.text$mn:0000104E                 pop     ebp
.text$mn:0000104F                 retn    10h
.text$mn:0000104F ?run_dlgProc@ViewZoneDlg@@MAGHIIJ@Z endp
.text$mn:0000104F
.text$mn:0000104F ; ---------------------------------------------------------------------------
.text$mn:00001052                 db 0Ah dup(0CCh)
.text$mn:0000105C
.text$mn:0000105C ; =============== S U B R O U T I N E =======================================
.text$mn:0000105C
.text$mn:0000105C ; Attributes: bp-based frame
.text$mn:0000105C
.text$mn:0000105C ; __int32 __stdcall ViewZoneDlg::canvasStaticProc(HWND hWnd, unsigned int, unsigned int, __int32)
.text$mn:0000105C                 public ?canvasStaticProc@ViewZoneDlg@@KGJPAUHWND__@@IIJ@Z
.text$mn:0000105C ?canvasStaticProc@ViewZoneDlg@@KGJPAUHWND__@@IIJ@Z proc near
.text$mn:0000105C                                         ; DATA XREF: ViewZoneDlg::run_dlgProc(uint,uint,long)+9Do
.text$mn:0000105C
.text$mn:0000105C var_4           = dword ptr -4
.text$mn:0000105C hWnd            = dword ptr  8
.text$mn:0000105C arg_4           = dword ptr  0Ch
.text$mn:0000105C arg_8           = dword ptr  10h
.text$mn:0000105C arg_C           = dword ptr  14h
.text$mn:0000105C
.text$mn:0000105C                 push    ebp
.text$mn:0000105D                 mov     ebp, esp
.text$mn:0000105F                 push    ecx
.text$mn:00001060                 push    0FFFFFFEBh      ; nIndex
.text$mn:00001062                 mov     eax, [ebp+hWnd]
.text$mn:00001065                 push    eax             ; hWnd
.text$mn:00001066                 call    dword ptr ds:__imp__GetWindowLongW@8 ; GetWindowLongW(x,x)
.text$mn:0000106C                 mov     [ebp+var_4], eax
.text$mn:0000106F                 cmp     [ebp+var_4], 0
.text$mn:00001073                 jnz     short loc_1079
.text$mn:00001075                 xor     eax, eax
.text$mn:00001077                 jmp     short loc_1092
.text$mn:00001079 ; ---------------------------------------------------------------------------
.text$mn:00001079
.text$mn:00001079 loc_1079:                               ; CODE XREF: ViewZoneDlg::canvasStaticProc(HWND__ *,uint,uint,long)+17j
.text$mn:00001079                 mov     ecx, [ebp+arg_C]
.text$mn:0000107C                 push    ecx             ; __int32
.text$mn:0000107D                 mov     edx, [ebp+arg_8]
.text$mn:00001080                 push    edx             ; unsigned int
.text$mn:00001081                 mov     eax, [ebp+arg_4]
.text$mn:00001084                 push    eax             ; unsigned int
.text$mn:00001085                 mov     ecx, [ebp+hWnd]
.text$mn:00001088                 push    ecx             ; HWND
.text$mn:00001089                 mov     edx, [ebp+var_4]
.text$mn:0000108C                 push    edx             ; this
.text$mn:0000108D                 call    ?canvas_runProc@ViewZoneDlg@@IAGJPAUHWND__@@IIJ@Z ; ViewZoneDlg::canvas_runProc(HWND__ *,uint,uint,long)
.text$mn:00001092
.text$mn:00001092 loc_1092:                               ; CODE XREF: ViewZoneDlg::canvasStaticProc(HWND__ *,uint,uint,long)+1Bj
.text$mn:00001092                 mov     esp, ebp
.text$mn:00001094                 pop     ebp
.text$mn:00001095                 retn    10h
.text$mn:00001095 ?canvasStaticProc@ViewZoneDlg@@KGJPAUHWND__@@IIJ@Z endp
.text$mn:00001095
.text$mn:00001095 ; ---------------------------------------------------------------------------
.text$mn:00001098                 db 4 dup(0CCh)
.text$mn:0000109C
.text$mn:0000109C ; =============== S U B R O U T I N E =======================================
.text$mn:0000109C
.text$mn:0000109C ; Attributes: bp-based frame
.text$mn:0000109C
.text$mn:0000109C ; __int32 __stdcall ViewZoneDlg::canvas_runProc(ViewZoneDlg *this, HWND, unsigned int, unsigned int, __int32)
.text$mn:0000109C                 public ?canvas_runProc@ViewZoneDlg@@IAGJPAUHWND__@@IIJ@Z
.text$mn:0000109C ?canvas_runProc@ViewZoneDlg@@IAGJPAUHWND__@@IIJ@Z proc near
.text$mn:0000109C                                         ; CODE XREF: ViewZoneDlg::canvasStaticProc(HWND__ *,uint,uint,long)+31p
.text$mn:0000109C
.text$mn:0000109C var_4           = dword ptr -4
.text$mn:0000109C this            = dword ptr  8
.text$mn:0000109C arg_4           = dword ptr  0Ch
.text$mn:0000109C arg_8           = dword ptr  10h
.text$mn:0000109C arg_C           = dword ptr  14h
.text$mn:0000109C arg_10          = dword ptr  18h
.text$mn:0000109C
.text$mn:0000109C                 push    ebp
.text$mn:0000109D                 mov     ebp, esp
.text$mn:0000109F                 push    ecx
.text$mn:000010A0                 mov     eax, [ebp+arg_8]
.text$mn:000010A3                 mov     [ebp+var_4], eax
.text$mn:000010A6                 mov     ecx, [ebp+var_4]
.text$mn:000010A9                 sub     ecx, 2
.text$mn:000010AC                 mov     [ebp+var_4], ecx
.text$mn:000010AF                 cmp     [ebp+var_4], 0FEh ; 'Â¦' ; switch 255 cases
.text$mn:000010B6                 ja      $LN1            ; jumptable 000010C6 default case
.text$mn:000010BC                 mov     edx, [ebp+var_4]
.text$mn:000010BF                 movzx   eax, ds:$LN14[edx]
.text$mn:000010C6                 jmp     ds:$LN15[eax*4] ; switch jump
.text$mn:000010CD ; ---------------------------------------------------------------------------
.text$mn:000010CD
.text$mn:000010CD $LN9:                                   ; CODE XREF: ViewZoneDlg::canvas_runProc(HWND__ *,uint,uint,long)+2Aj
.text$mn:000010CD                                         ; DATA XREF: .text$mn:$LN15o
.text$mn:000010CD                 mov     eax, 1          ; jumptable 000010C6 case 0
.text$mn:000010D2                 jmp     loc_1184
.text$mn:000010D7 ; ---------------------------------------------------------------------------
.text$mn:000010D7
.text$mn:000010D7 $LN8:                                   ; CODE XREF: ViewZoneDlg::canvas_runProc(HWND__ *,uint,uint,long)+2Aj
.text$mn:000010D7                                         ; DATA XREF: .text$mn:$LN15o
.text$mn:000010D7                 cmp     [ebp+arg_C], 26h ; '&' ; jumptable 000010C6 case 254
.text$mn:000010DB                 jnz     short loc_10F3
.text$mn:000010DD                 push    0               ; lParam
.text$mn:000010DF                 push    0               ; wParam
.text$mn:000010E1                 push    401h            ; Msg
.text$mn:000010E6                 mov     ecx, [ebp+this]
.text$mn:000010E9                 mov     edx, [ecx+8]
.text$mn:000010EC                 push    edx             ; hWnd
.text$mn:000010ED                 call    dword ptr ds:__imp__SendMessageW@16 ; SendMessageW(x,x,x,x)
.text$mn:000010F3
.text$mn:000010F3 loc_10F3:                               ; CODE XREF: ViewZoneDlg::canvas_runProc(HWND__ *,uint,uint,long)+3Fj
.text$mn:000010F3                 cmp     [ebp+arg_C], 28h ; '('
.text$mn:000010F7                 jnz     short loc_110F
.text$mn:000010F9                 push    0               ; lParam
.text$mn:000010FB                 push    1               ; wParam
.text$mn:000010FD                 push    401h            ; Msg
.text$mn:00001102                 mov     eax, [ebp+this]
.text$mn:00001105                 mov     ecx, [eax+8]
.text$mn:00001108                 push    ecx             ; hWnd
.text$mn:00001109                 call    dword ptr ds:__imp__SendMessageW@16 ; SendMessageW(x,x,x,x)
.text$mn:0000110F
.text$mn:0000110F loc_110F:                               ; CODE XREF: ViewZoneDlg::canvas_runProc(HWND__ *,uint,uint,long)+5Bj
.text$mn:0000110F                 cmp     [ebp+arg_C], 21h ; '!'
.text$mn:00001113                 jnz     short loc_112B
.text$mn:00001115                 push    1               ; lParam
.text$mn:00001117                 push    0               ; wParam
.text$mn:00001119                 push    401h            ; Msg
.text$mn:0000111E                 mov     edx, [ebp+this]
.text$mn:00001121                 mov     eax, [edx+8]
.text$mn:00001124                 push    eax             ; hWnd
.text$mn:00001125                 call    dword ptr ds:__imp__SendMessageW@16 ; SendMessageW(x,x,x,x)
.text$mn:0000112B
.text$mn:0000112B loc_112B:                               ; CODE XREF: ViewZoneDlg::canvas_runProc(HWND__ *,uint,uint,long)+77j
.text$mn:0000112B                 cmp     [ebp+arg_C], 22h ; '"'
.text$mn:0000112F                 jnz     short loc_1147
.text$mn:00001131                 push    1               ; lParam
.text$mn:00001133                 push    1               ; wParam
.text$mn:00001135                 push    401h            ; Msg
.text$mn:0000113A                 mov     ecx, [ebp+this]
.text$mn:0000113D                 mov     edx, [ecx+8]
.text$mn:00001140                 push    edx             ; hWnd
.text$mn:00001141                 call    dword ptr ds:__imp__SendMessageW@16 ; SendMessageW(x,x,x,x)
.text$mn:00001147
.text$mn:00001147 loc_1147:                               ; CODE XREF: ViewZoneDlg::canvas_runProc(HWND__ *,uint,uint,long)+93j
.text$mn:00001147                 jmp     short loc_116C
.text$mn:00001149 ; ---------------------------------------------------------------------------
.text$mn:00001149
.text$mn:00001149 $LN3:                                   ; CODE XREF: ViewZoneDlg::canvas_runProc(HWND__ *,uint,uint,long)+2Aj
.text$mn:00001149                                         ; DATA XREF: .text$mn:$LN15o
.text$mn:00001149                 jmp     short loc_116C  ; jumptable 000010C6 case 3
.text$mn:0000114B ; ---------------------------------------------------------------------------
.text$mn:0000114B
.text$mn:0000114B $LN2:                                   ; CODE XREF: ViewZoneDlg::canvas_runProc(HWND__ *,uint,uint,long)+2Aj
.text$mn:0000114B                                         ; DATA XREF: .text$mn:$LN15o
.text$mn:0000114B                 mov     eax, 1          ; jumptable 000010C6 case 76
.text$mn:00001150                 jmp     short loc_1184
.text$mn:00001152 ; ---------------------------------------------------------------------------
.text$mn:00001152
.text$mn:00001152 $LN1:                                   ; CODE XREF: ViewZoneDlg::canvas_runProc(HWND__ *,uint,uint,long)+1Aj
.text$mn:00001152                                         ; ViewZoneDlg::canvas_runProc(HWND__ *,uint,uint,long)+2Aj
.text$mn:00001152                                         ; DATA XREF: ...
.text$mn:00001152                 mov     eax, [ebp+arg_10] ; jumptable 000010C6 default case
.text$mn:00001155                 push    eax
.text$mn:00001156                 mov     ecx, [ebp+arg_C]
.text$mn:00001159                 push    ecx
.text$mn:0000115A                 mov     edx, [ebp+arg_8]
.text$mn:0000115D                 push    edx
.text$mn:0000115E                 mov     eax, [ebp+arg_4]
.text$mn:00001161                 push    eax
.text$mn:00001162                 mov     ecx, [ebp+this]
.text$mn:00001165                 mov     edx, [ecx+24h]
.text$mn:00001168                 call    edx
.text$mn:0000116A                 jmp     short loc_1184
.text$mn:0000116C ; ---------------------------------------------------------------------------
.text$mn:0000116C
.text$mn:0000116C loc_116C:                               ; CODE XREF: ViewZoneDlg::canvas_runProc(HWND__ *,uint,uint,long):loc_1147j
.text$mn:0000116C                                         ; ViewZoneDlg::canvas_runProc(HWND__ *,uint,uint,long):$LN3j
.text$mn:0000116C                 mov     eax, [ebp+arg_10]
.text$mn:0000116F                 push    eax
.text$mn:00001170                 mov     ecx, [ebp+arg_C]
.text$mn:00001173                 push    ecx
.text$mn:00001174                 mov     edx, [ebp+arg_8]
.text$mn:00001177                 push    edx
.text$mn:00001178                 mov     eax, [ebp+arg_4]
.text$mn:0000117B                 push    eax
.text$mn:0000117C                 mov     ecx, [ebp+this]
.text$mn:0000117F                 mov     edx, [ecx+24h]
.text$mn:00001182                 call    edx
.text$mn:00001184
.text$mn:00001184 loc_1184:                               ; CODE XREF: ViewZoneDlg::canvas_runProc(HWND__ *,uint,uint,long)+36j
.text$mn:00001184                                         ; ViewZoneDlg::canvas_runProc(HWND__ *,uint,uint,long)+B4j ...
.text$mn:00001184                 mov     esp, ebp
.text$mn:00001186                 pop     ebp
.text$mn:00001187                 retn    14h
.text$mn:00001187 ?canvas_runProc@ViewZoneDlg@@IAGJPAUHWND__@@IIJ@Z endp
.text$mn:00001187
.text$mn:00001187 ; ---------------------------------------------------------------------------
.text$mn:0000118A                 align 4
.text$mn:0000118C $LN15           dd offset $LN9, offset $LN3, offset $LN2, offset $LN8
.text$mn:0000118C                                         ; DATA XREF: ViewZoneDlg::canvas_runProc(HWND__ *,uint,uint,long)+2Ar
.text$mn:0000118C                 dd offset $LN1          ; jump table for switch statement
.text$mn:000011A0 $LN14           db 0, 4, 4, 1, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4
.text$mn:000011A0                                         ; DATA XREF: ViewZoneDlg::canvas_runProc(HWND__ *,uint,uint,long)+23r
.text$mn:000011A0                 db 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4 ; indirect table for switch statement
.text$mn:000011A0                 db 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4
.text$mn:000011A0                 db 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4
.text$mn:000011A0                 db 4, 4, 4, 4, 2, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4
.text$mn:000011A0                 db 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4
.text$mn:000011A0                 db 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4
.text$mn:000011A0                 db 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4
.text$mn:000011A0                 db 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4
.text$mn:000011A0                 db 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4
.text$mn:000011A0                 db 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4
.text$mn:000011A0                 db 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4
.text$mn:000011A0                 db 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4
.text$mn:000011A0                 db 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4
.text$mn:000011A0                 db 4, 4, 3
.text$mn:0000129F                 db 0Dh dup(0CCh)
.text$mn:000012AC
.text$mn:000012AC ; =============== S U B R O U T I N E =======================================
.text$mn:000012AC
.text$mn:000012AC ; Attributes: bp-based frame
.text$mn:000012AC
.text$mn:000012AC ; void __thiscall ViewZoneDlg::drawPreviewZone(ViewZoneDlg *this, struct tagDRAWITEMSTRUCT *)
.text$mn:000012AC                 public ?drawPreviewZone@ViewZoneDlg@@IAEXPAUtagDRAWITEMSTRUCT@@@Z
.text$mn:000012AC ?drawPreviewZone@ViewZoneDlg@@IAEXPAUtagDRAWITEMSTRUCT@@@Z proc near
.text$mn:000012AC                                         ; CODE XREF: ViewZoneDlg::run_dlgProc(uint,uint,long)+113p
.text$mn:000012AC
.text$mn:000012AC var_28          = dword ptr -28h
.text$mn:000012AC var_24          = dword ptr -24h
.text$mn:000012AC var_20          = dword ptr -20h
.text$mn:000012AC var_1C          = dword ptr -1Ch
.text$mn:000012AC hbr             = dword ptr -18h
.text$mn:000012AC rc              = RECT ptr -14h
.text$mn:000012AC var_4           = dword ptr -4
.text$mn:000012AC arg_0           = dword ptr  8
.text$mn:000012AC
.text$mn:000012AC                 push    ebp
.text$mn:000012AD                 mov     ebp, esp
.text$mn:000012AF                 sub     esp, 28h
.text$mn:000012B2                 mov     eax, dword ptr ds:___security_cookie
.text$mn:000012B7                 xor     eax, ebp
.text$mn:000012B9                 mov     [ebp+var_4], eax
.text$mn:000012BC                 mov     [ebp+var_20], ecx
.text$mn:000012BF                 mov     eax, [ebp+arg_0]
.text$mn:000012C2                 add     eax, 1Ch
.text$mn:000012C5                 mov     ecx, [eax]
.text$mn:000012C7                 mov     [ebp+rc.left], ecx
.text$mn:000012CA                 mov     edx, [eax+4]
.text$mn:000012CD                 mov     [ebp+rc.top], edx
.text$mn:000012D0                 mov     ecx, [eax+8]
.text$mn:000012D3                 mov     [ebp+rc.right], ecx
.text$mn:000012D6                 mov     edx, [eax+0Ch]
.text$mn:000012D9                 mov     [ebp+rc.bottom], edx
.text$mn:000012DC                 mov     [ebp+var_24], 80FFh
.text$mn:000012E3                 mov     [ebp+var_28], 0FFFFFFh
.text$mn:000012EA                 push    80FFh           ; color
.text$mn:000012EF                 call    dword ptr ds:__imp__CreateSolidBrush@4 ; CreateSolidBrush(x)
.text$mn:000012F5                 mov     [ebp+var_1C], eax
.text$mn:000012F8                 push    0FFFFFFh        ; color
.text$mn:000012FD                 call    dword ptr ds:__imp__CreateSolidBrush@4 ; CreateSolidBrush(x)
.text$mn:00001303                 mov     [ebp+hbr], eax
.text$mn:00001306                 mov     eax, [ebp+hbr]
.text$mn:00001309                 push    eax             ; hbr
.text$mn:0000130A                 lea     ecx, [ebp+rc]
.text$mn:0000130D                 push    ecx             ; lprc
.text$mn:0000130E                 mov     edx, [ebp+arg_0]
.text$mn:00001311                 mov     eax, [edx+18h]
.text$mn:00001314                 push    eax             ; hDC
.text$mn:00001315                 call    dword ptr ds:__imp__FillRect@12 ; FillRect(x,x,x)
.text$mn:0000131B                 mov     ecx, [ebp+var_20]
.text$mn:0000131E                 mov     edx, [ecx+28h]
.text$mn:00001321                 mov     [ebp+rc.top], edx
.text$mn:00001324                 mov     eax, [ebp+var_20]
.text$mn:00001327                 mov     ecx, [eax+2Ch]
.text$mn:0000132A                 mov     [ebp+rc.bottom], ecx
.text$mn:0000132D                 mov     edx, [ebp+var_1C]
.text$mn:00001330                 push    edx             ; hbr
.text$mn:00001331                 lea     eax, [ebp+rc]
.text$mn:00001334                 push    eax             ; lprc
.text$mn:00001335                 mov     ecx, [ebp+arg_0]
.text$mn:00001338                 mov     edx, [ecx+18h]
.text$mn:0000133B                 push    edx             ; hDC
.text$mn:0000133C                 call    dword ptr ds:__imp__FillRect@12 ; FillRect(x,x,x)
.text$mn:00001342                 mov     eax, [ebp+var_1C]
.text$mn:00001345                 push    eax             ; ho
.text$mn:00001346                 call    dword ptr ds:__imp__DeleteObject@4 ; DeleteObject(x)
.text$mn:0000134C                 mov     ecx, [ebp+hbr]
.text$mn:0000134F                 push    ecx             ; ho
.text$mn:00001350                 call    dword ptr ds:__imp__DeleteObject@4 ; DeleteObject(x)
.text$mn:00001356                 mov     ecx, [ebp+var_4]
.text$mn:00001359                 xor     ecx, ebp
.text$mn:0000135B                 call    @__security_check_cookie@4 ; __security_check_cookie(x)
.text$mn:00001360                 mov     esp, ebp
.text$mn:00001362                 pop     ebp
.text$mn:00001363                 retn    4
.text$mn:00001363 ?drawPreviewZone@ViewZoneDlg@@IAEXPAUtagDRAWITEMSTRUCT@@@Z endp
.text$mn:00001363
.text$mn:00001363 ; ---------------------------------------------------------------------------
.text$mn:00001366                 db 6 dup(0CCh)
.text$mn:0000136C
.text$mn:0000136C ; =============== S U B R O U T I N E =======================================
.text$mn:0000136C
.text$mn:0000136C ; Attributes: bp-based frame
.text$mn:0000136C
.text$mn:0000136C ; void __thiscall DocumentMap::redraw(DocumentMap *this, bool)
.text$mn:0000136C                 public ?redraw@DocumentMap@@UBEX_N@Z
.text$mn:0000136C ?redraw@DocumentMap@@UBEX_N@Z proc near
.text$mn:0000136C
.text$mn:0000136C var_4           = dword ptr -4
.text$mn:0000136C
.text$mn:0000136C                 push    ebp
.text$mn:0000136D                 mov     ebp, esp
.text$mn:0000136F                 push    ecx
.text$mn:00001370                 mov     [ebp+var_4], ecx
.text$mn:00001373                 push    0FFFFFFFFh      ; __int32
.text$mn:00001375                 push    0               ; unsigned int
.text$mn:00001377                 push    0FA3h           ; unsigned int
.text$mn:0000137C                 mov     eax, [ebp+var_4]
.text$mn:0000137F                 mov     ecx, [eax+70h]  ; this
.text$mn:00001382                 call    ?execute@ScintillaEditView@@QBEJIIJ@Z ; ScintillaEditView::execute(uint,uint,long)
.text$mn:00001387                 mov     esp, ebp
.text$mn:00001389                 pop     ebp
.text$mn:0000138A                 retn    4
.text$mn:0000138A ?redraw@DocumentMap@@UBEX_N@Z endp
.text$mn:0000138A
.text$mn:0000138A ; ---------------------------------------------------------------------------
.text$mn:0000138D                 db 0Fh dup(0CCh)
.text$mn:0000139C
.text$mn:0000139C ; =============== S U B R O U T I N E =======================================
.text$mn:0000139C
.text$mn:0000139C ; Attributes: bp-based frame
.text$mn:0000139C
.text$mn:0000139C ; void __thiscall DocumentMap::reloadMap(DocumentMap *__hidden this)
.text$mn:0000139C                 public ?reloadMap@DocumentMap@@QAEXXZ
.text$mn:0000139C ?reloadMap@DocumentMap@@QAEXXZ proc near
.text$mn:0000139C                                         ; CODE XREF: DocumentMap::run_dlgProc(uint,uint,long)+10Ap
.text$mn:0000139C                                         ; DocumentMap::run_dlgProc(uint,uint,long)+2E5p
.text$mn:0000139C
.text$mn:0000139C var_28          = byte ptr -28h
.text$mn:0000139C var_18          = dword ptr -18h
.text$mn:0000139C var_14          = dword ptr -14h
.text$mn:0000139C var_10          = dword ptr -10h
.text$mn:0000139C var_C           = dword ptr -0Ch
.text$mn:0000139C var_4           = dword ptr -4
.text$mn:0000139C
.text$mn:0000139C                 push    ebp
.text$mn:0000139D                 mov     ebp, esp
.text$mn:0000139F                 push    0FFFFFFFFh
.text$mn:000013A1                 push    offset __ehhandler$?reloadMap@DocumentMap@@QAEXXZ
.text$mn:000013A6                 mov     eax, large fs:0
.text$mn:000013AC                 push    eax
.text$mn:000013AD                 sub     esp, 1Ch
.text$mn:000013B0                 mov     eax, dword ptr ds:___security_cookie
.text$mn:000013B5                 xor     eax, ebp
.text$mn:000013B7                 push    eax
.text$mn:000013B8                 lea     eax, [ebp+var_C]
.text$mn:000013BB                 mov     large fs:0, eax
.text$mn:000013C1                 mov     [ebp+var_10], ecx
.text$mn:000013C4                 mov     eax, [ebp+var_10]
.text$mn:000013C7                 cmp     dword ptr [eax+70h], 0
.text$mn:000013CB                 jz      loc_149D
.text$mn:000013D1                 mov     ecx, [ebp+var_10]
.text$mn:000013D4                 cmp     dword ptr [ecx+6Ch], 0
.text$mn:000013D8                 jz      loc_149D
.text$mn:000013DE                 push    0               ; __int32
.text$mn:000013E0                 push    0               ; unsigned int
.text$mn:000013E2                 push    935h            ; unsigned int
.text$mn:000013E7                 mov     edx, [ebp+var_10]
.text$mn:000013EA                 mov     eax, [edx+6Ch]
.text$mn:000013ED                 mov     ecx, [eax]      ; this
.text$mn:000013EF                 call    ?execute@ScintillaEditView@@QBEJIIJ@Z ; ScintillaEditView::execute(uint,uint,long)
.text$mn:000013F4                 mov     [ebp+var_14], eax
.text$mn:000013F7                 mov     ecx, [ebp+var_14]
.text$mn:000013FA                 push    ecx             ; __int32
.text$mn:000013FB                 push    0               ; unsigned int
.text$mn:000013FD                 push    936h            ; unsigned int
.text$mn:00001402                 mov     edx, [ebp+var_10]
.text$mn:00001405                 mov     ecx, [edx+70h]  ; this
.text$mn:00001408                 call    ?execute@ScintillaEditView@@QBEJIIJ@Z ; ScintillaEditView::execute(uint,uint,long)
.text$mn:0000140D                 mov     eax, [ebp+var_10]
.text$mn:00001410                 mov     ecx, [eax+6Ch]
.text$mn:00001413                 mov     ecx, [ecx]      ; this
.text$mn:00001415                 call    ?getCurrentBuffer@ScintillaEditView@@QAEPAVBuffer@@XZ ; ScintillaEditView::getCurrentBuffer(void)
.text$mn:0000141A                 mov     [ebp+var_18], eax
.text$mn:0000141D                 mov     edx, [ebp+var_18]
.text$mn:00001420                 push    edx             ; struct Buffer *
.text$mn:00001421                 mov     eax, [ebp+var_10]
.text$mn:00001424                 mov     ecx, [eax+70h]  ; this
.text$mn:00001427                 call    ?setCurrentBuffer@ScintillaEditView@@QAEXPAVBuffer@@@Z ; ScintillaEditView::setCurrentBuffer(Buffer *)
.text$mn:0000142C                 lea     ecx, [ebp+var_28]
.text$mn:0000142F                 call    ??0?$vector@IV?$allocator@I@std@@@std@@QAE@XZ ; std::vector<uint,std::allocator<uint>>::vector<uint,std::allocator<uint>>(void)
.text$mn:00001434                 mov     [ebp+var_4], 0
.text$mn:0000143B                 lea     ecx, [ebp+var_28]
.text$mn:0000143E                 push    ecx
.text$mn:0000143F                 mov     edx, [ebp+var_10]
.text$mn:00001442                 mov     eax, [edx+6Ch]
.text$mn:00001445                 mov     ecx, [eax]
.text$mn:00001447                 call    ?getCurrentFoldStates@ScintillaEditView@@QAEXAAV?$vector@IV?$allocator@I@std@@@std@@@Z ; ScintillaEditView::getCurrentFoldStates(std::vector<uint,std::allocator<uint>> &)
.text$mn:0000144C                 lea     ecx, [ebp+var_28]
.text$mn:0000144F                 push    ecx
.text$mn:00001450                 mov     edx, [ebp+var_10]
.text$mn:00001453                 mov     ecx, [edx+70h]
.text$mn:00001456                 call    ?syncFoldStateWith@ScintillaEditView@@QAEXABV?$vector@IV?$allocator@I@std@@@std@@@Z ; ScintillaEditView::syncFoldStateWith(std::vector<uint,std::allocator<uint>> const &)
.text$mn:0000145B                 mov     eax, [ebp+var_10]
.text$mn:0000145E                 mov     ecx, [eax+6Ch]
.text$mn:00001461                 mov     ecx, [ecx]      ; this
.text$mn:00001463                 call    ?isWrap@ScintillaEditView@@QBE_NXZ ; ScintillaEditView::isWrap(void)
.text$mn:00001468                 movzx   edx, al
.text$mn:0000146B                 test    edx, edx
.text$mn:0000146D                 jz      short loc_1486
.text$mn:0000146F                 mov     ecx, [ebp+var_10] ; this
.text$mn:00001472                 call    ?needToRecomputeWith@DocumentMap@@IAE_NXZ ; DocumentMap::needToRecomputeWith(void)
.text$mn:00001477                 movzx   eax, al
.text$mn:0000147A                 test    eax, eax
.text$mn:0000147C                 jz      short loc_1486
.text$mn:0000147E                 mov     ecx, [ebp+var_10] ; this
.text$mn:00001481                 call    ?wrapMap@DocumentMap@@QAEXXZ ; DocumentMap::wrapMap(void)
.text$mn:00001486
.text$mn:00001486 loc_1486:                               ; CODE XREF: DocumentMap::reloadMap(void)+D1j
.text$mn:00001486                                         ; DocumentMap::reloadMap(void)+E0j
.text$mn:00001486                 mov     ecx, [ebp+var_10] ; this
.text$mn:00001489                 call    ?scrollMap@DocumentMap@@QAEXXZ ; DocumentMap::scrollMap(void)
.text$mn:0000148E                 mov     [ebp+var_4], 0FFFFFFFFh
.text$mn:00001495                 lea     ecx, [ebp+var_28]
.text$mn:00001498                 call    ??1?$vector@IV?$allocator@I@std@@@std@@QAE@XZ ; std::vector<uint,std::allocator<uint>>::~vector<uint,std::allocator<uint>>(void)
.text$mn:0000149D
.text$mn:0000149D loc_149D:                               ; CODE XREF: DocumentMap::reloadMap(void)+2Fj
.text$mn:0000149D                                         ; DocumentMap::reloadMap(void)+3Cj
.text$mn:0000149D                 mov     ecx, [ebp+var_C]
.text$mn:000014A0                 mov     large fs:0, ecx
.text$mn:000014A7                 pop     ecx
.text$mn:000014A8                 mov     esp, ebp
.text$mn:000014AA                 pop     ebp
.text$mn:000014AB                 retn
.text$mn:000014AB ?reloadMap@DocumentMap@@QAEXXZ endp
.text$mn:000014AB
.text$mn:000014AC
.text$mn:000014AC ; =============== S U B R O U T I N E =======================================
.text$mn:000014AC
.text$mn:000014AC ; Attributes: bp-based frame
.text$mn:000014AC
.text$mn:000014AC ; void __thiscall DocumentMap::wrapMap(DocumentMap *__hidden this)
.text$mn:000014AC                 public ?wrapMap@DocumentMap@@QAEXXZ
.text$mn:000014AC ?wrapMap@DocumentMap@@QAEXXZ proc near  ; CODE XREF: DocumentMap::reloadMap(void)+E5p
.text$mn:000014AC
.text$mn:000014AC var_2C          = qword ptr -2Ch
.text$mn:000014AC var_24          = qword ptr -24h
.text$mn:000014AC var_1C          = dword ptr -1Ch
.text$mn:000014AC var_18          = dword ptr -18h
.text$mn:000014AC var_14          = byte ptr -14h
.text$mn:000014AC var_10          = dword ptr -10h
.text$mn:000014AC var_8           = dword ptr -8
.text$mn:000014AC var_4           = dword ptr -4
.text$mn:000014AC
.text$mn:000014AC                 push    ebp
.text$mn:000014AD                 mov     ebp, esp
.text$mn:000014AF                 sub     esp, 2Ch
.text$mn:000014B2                 mov     eax, dword ptr ds:___security_cookie
.text$mn:000014B7                 xor     eax, ebp
.text$mn:000014B9                 mov     [ebp+var_4], eax
.text$mn:000014BC                 mov     [ebp+var_18], ecx
.text$mn:000014BF                 lea     eax, [ebp+var_14]
.text$mn:000014C2                 push    eax
.text$mn:000014C3                 mov     ecx, [ebp+var_18]
.text$mn:000014C6                 mov     edx, [ecx]
.text$mn:000014C8                 mov     ecx, [ebp+var_18]
.text$mn:000014CB                 mov     eax, [edx+1Ch]
.text$mn:000014CE                 call    eax
.text$mn:000014D0                 mov     ecx, [ebp+var_18]
.text$mn:000014D3                 mov     edx, [ecx+6Ch]
.text$mn:000014D6                 mov     ecx, [edx]      ; this
.text$mn:000014D8                 call    ?isWrap@ScintillaEditView@@QBE_NXZ ; ScintillaEditView::isWrap(void)
.text$mn:000014DD                 movzx   eax, al
.text$mn:000014E0                 test    eax, eax
.text$mn:000014E2                 jz      loc_159F
.text$mn:000014E8                 mov     ecx, [ebp+var_18] ; this
.text$mn:000014EB                 call    ?getEditorTextZoneWidth@DocumentMap@@IAEHXZ ; DocumentMap::getEditorTextZoneWidth(void)
.text$mn:000014F0                 mov     [ebp+var_1C], eax
.text$mn:000014F3                 mov     ecx, [ebp+var_18]
.text$mn:000014F6                 mov     edx, [ebp+var_1C]
.text$mn:000014F9                 mov     [ecx+0A8h], edx
.text$mn:000014FF                 push    0               ; __int32
.text$mn:00001501                 push    0               ; unsigned int
.text$mn:00001503                 push    946h            ; unsigned int
.text$mn:00001508                 mov     eax, [ebp+var_18]
.text$mn:0000150B                 mov     ecx, [eax+6Ch]
.text$mn:0000150E                 mov     ecx, [ecx]      ; this
.text$mn:00001510                 call    ?execute@ScintillaEditView@@QBEJIIJ@Z ; ScintillaEditView::execute(uint,uint,long)
.text$mn:00001515                 mov     edx, [ebp+var_18]
.text$mn:00001518                 mov     [edx+0A4h], eax
.text$mn:0000151E                 mov     eax, [ebp+var_18]
.text$mn:00001521                 mov     ecx, [eax+0A4h]
.text$mn:00001527                 movsd   xmm0, qword_390[ecx*8]
.text$mn:00001530                 movsd   [ebp+var_24], xmm0
.text$mn:00001535                 cvtsi2sd xmm0, [ebp+var_1C]
.text$mn:0000153A                 divsd   xmm0, [ebp+var_24]
.text$mn:0000153F                 movsd   [ebp+var_2C], xmm0
.text$mn:00001544                 push    1               ; bRepaint
.text$mn:00001546                 mov     edx, [ebp+var_8]
.text$mn:00001549                 sub     edx, [ebp+var_10]
.text$mn:0000154C                 push    edx             ; nHeight
.text$mn:0000154D                 cvttsd2si eax, [ebp+var_2C]
.text$mn:00001552                 push    eax             ; nWidth
.text$mn:00001553                 push    0               ; Y
.text$mn:00001555                 push    0               ; X
.text$mn:00001557                 mov     ecx, [ebp+var_18]
.text$mn:0000155A                 mov     ecx, [ecx+70h]  ; this
.text$mn:0000155D                 call    ?getHSelf@Window@@QBEPAUHWND__@@XZ ; Window::getHSelf(void)
.text$mn:00001562                 push    eax             ; hWnd
.text$mn:00001563                 call    dword ptr ds:__imp__MoveWindow@24 ; MoveWindow(x,x,x,x,x,x)
.text$mn:00001569                 push    1               ; bool
.text$mn:0000156B                 mov     edx, [ebp+var_18]
.text$mn:0000156E                 mov     ecx, [edx+70h]  ; this
.text$mn:00001571                 call    ?wrap@ScintillaEditView@@QAEX_N@Z ; ScintillaEditView::wrap(bool)
.text$mn:00001576                 push    0               ; __int32
.text$mn:00001578                 push    0               ; __int32
.text$mn:0000157A                 push    0               ; unsigned int
.text$mn:0000157C                 push    9A9h            ; unsigned int
.text$mn:00001581                 mov     eax, [ebp+var_18]
.text$mn:00001584                 mov     ecx, [eax+6Ch]
.text$mn:00001587                 mov     ecx, [ecx]      ; this
.text$mn:00001589                 call    ?execute@ScintillaEditView@@QBEJIIJ@Z ; ScintillaEditView::execute(uint,uint,long)
.text$mn:0000158E                 push    eax             ; unsigned int
.text$mn:0000158F                 push    9A8h            ; unsigned int
.text$mn:00001594                 mov     edx, [ebp+var_18]
.text$mn:00001597                 mov     ecx, [edx+70h]  ; this
.text$mn:0000159A                 call    ?execute@ScintillaEditView@@QBEJIIJ@Z ; ScintillaEditView::execute(uint,uint,long)
.text$mn:0000159F
.text$mn:0000159F loc_159F:                               ; CODE XREF: DocumentMap::wrapMap(void)+36j
.text$mn:0000159F                 mov     ecx, [ebp+var_4]
.text$mn:000015A2                 xor     ecx, ebp
.text$mn:000015A4                 call    @__security_check_cookie@4 ; __security_check_cookie(x)
.text$mn:000015A9                 mov     esp, ebp
.text$mn:000015AB                 pop     ebp
.text$mn:000015AC                 retn
.text$mn:000015AC ?wrapMap@DocumentMap@@QAEXXZ endp
.text$mn:000015AC
.text$mn:000015AC ; ---------------------------------------------------------------------------
.text$mn:000015AD                 db 0Fh dup(0CCh)
.text$mn:000015BC
.text$mn:000015BC ; =============== S U B R O U T I N E =======================================
.text$mn:000015BC
.text$mn:000015BC ; Attributes: bp-based frame
.text$mn:000015BC
.text$mn:000015BC ; void __thiscall DocumentMap::initWrapMap(DocumentMap *__hidden this)
.text$mn:000015BC                 public ?initWrapMap@DocumentMap@@QAEXXZ
.text$mn:000015BC ?initWrapMap@DocumentMap@@QAEXXZ proc near
.text$mn:000015BC
.text$mn:000015BC var_19          = byte ptr -19h
.text$mn:000015BC var_18          = dword ptr -18h
.text$mn:000015BC var_14          = dword ptr -14h
.text$mn:000015BC var_10          = dword ptr -10h
.text$mn:000015BC var_C           = dword ptr -0Ch
.text$mn:000015BC var_8           = dword ptr -8
.text$mn:000015BC var_4           = dword ptr -4
.text$mn:000015BC
.text$mn:000015BC                 push    ebp
.text$mn:000015BD                 mov     ebp, esp
.text$mn:000015BF                 sub     esp, 1Ch
.text$mn:000015C2                 mov     eax, dword ptr ds:___security_cookie
.text$mn:000015C7                 xor     eax, ebp
.text$mn:000015C9                 mov     [ebp+var_4], eax
.text$mn:000015CC                 mov     [ebp+var_18], ecx
.text$mn:000015CF                 mov     eax, [ebp+var_18]
.text$mn:000015D2                 cmp     dword ptr [eax+70h], 0
.text$mn:000015D6                 jz      loc_1678
.text$mn:000015DC                 mov     ecx, [ebp+var_18]
.text$mn:000015DF                 cmp     dword ptr [ecx+6Ch], 0
.text$mn:000015E3                 jz      loc_1678
.text$mn:000015E9                 lea     edx, [ebp+var_14]
.text$mn:000015EC                 push    edx
.text$mn:000015ED                 mov     eax, [ebp+var_18]
.text$mn:000015F0                 mov     edx, [eax]
.text$mn:000015F2                 mov     ecx, [ebp+var_18]
.text$mn:000015F5                 mov     eax, [edx+1Ch]
.text$mn:000015F8                 call    eax
.text$mn:000015FA                 push    1               ; bRepaint
.text$mn:000015FC                 mov     ecx, [ebp+var_8]
.text$mn:000015FF                 sub     ecx, [ebp+var_10]
.text$mn:00001602                 push    ecx             ; nHeight
.text$mn:00001603                 mov     edx, [ebp+var_C]
.text$mn:00001606                 sub     edx, [ebp+var_14]
.text$mn:00001609                 push    edx             ; nWidth
.text$mn:0000160A                 push    0               ; Y
.text$mn:0000160C                 push    0               ; X
.text$mn:0000160E                 mov     eax, [ebp+var_18]
.text$mn:00001611                 mov     ecx, [eax+70h]  ; this
.text$mn:00001614                 call    ?getHSelf@Window@@QBEPAUHWND__@@XZ ; Window::getHSelf(void)
.text$mn:00001619                 push    eax             ; hWnd
.text$mn:0000161A                 call    dword ptr ds:__imp__MoveWindow@24 ; MoveWindow(x,x,x,x,x,x)
.text$mn:00001620                 push    0               ; bool
.text$mn:00001622                 mov     ecx, [ebp+var_18]
.text$mn:00001625                 mov     ecx, [ecx+70h]  ; this
.text$mn:00001628                 call    ?wrap@ScintillaEditView@@QAEX_N@Z ; ScintillaEditView::wrap(bool)
.text$mn:0000162D                 push    1
.text$mn:0000162F                 mov     edx, [ebp+var_18]
.text$mn:00001632                 mov     eax, [edx+70h]
.text$mn:00001635                 mov     ecx, [ebp+var_18]
.text$mn:00001638                 mov     edx, [eax]
.text$mn:0000163A                 mov     ecx, [ecx+70h]
.text$mn:0000163D                 mov     eax, [edx+18h]
.text$mn:00001640                 call    eax
.text$mn:00001642                 mov     ecx, [ebp+var_18]
.text$mn:00001645                 mov     edx, [ecx+6Ch]
.text$mn:00001648                 mov     ecx, [edx]      ; this
.text$mn:0000164A                 call    ?isTextDirectionRTL@ScintillaEditView@@QBE_NXZ ; ScintillaEditView::isTextDirectionRTL(void)
.text$mn:0000164F                 mov     [ebp+var_19], al
.text$mn:00001652                 mov     eax, [ebp+var_18]
.text$mn:00001655                 mov     ecx, [eax+70h]  ; this
.text$mn:00001658                 call    ?isTextDirectionRTL@ScintillaEditView@@QBE_NXZ ; ScintillaEditView::isTextDirectionRTL(void)
.text$mn:0000165D                 movzx   ecx, al
.text$mn:00001660                 movzx   edx, [ebp+var_19]
.text$mn:00001664                 cmp     ecx, edx
.text$mn:00001666                 jz      short loc_1678
.text$mn:00001668                 movzx   eax, [ebp+var_19]
.text$mn:0000166C                 push    eax             ; bool
.text$mn:0000166D                 mov     ecx, [ebp+var_18]
.text$mn:00001670                 mov     ecx, [ecx+70h]  ; this
.text$mn:00001673                 call    ?changeTextDirection@ScintillaEditView@@QAEX_N@Z ; ScintillaEditView::changeTextDirection(bool)
.text$mn:00001678
.text$mn:00001678 loc_1678:                               ; CODE XREF: DocumentMap::initWrapMap(void)+1Aj
.text$mn:00001678                                         ; DocumentMap::initWrapMap(void)+27j ...
.text$mn:00001678                 mov     ecx, [ebp+var_4]
.text$mn:0000167B                 xor     ecx, ebp
.text$mn:0000167D                 call    @__security_check_cookie@4 ; __security_check_cookie(x)
.text$mn:00001682                 mov     esp, ebp
.text$mn:00001684                 pop     ebp
.text$mn:00001685                 retn
.text$mn:00001685 ?initWrapMap@DocumentMap@@QAEXXZ endp
.text$mn:00001685
.text$mn:00001685 ; ---------------------------------------------------------------------------
.text$mn:00001686                 db 6 dup(0CCh)
.text$mn:0000168C
.text$mn:0000168C ; =============== S U B R O U T I N E =======================================
.text$mn:0000168C
.text$mn:0000168C ; Attributes: bp-based frame
.text$mn:0000168C
.text$mn:0000168C ; void __thiscall DocumentMap::scrollMap(DocumentMap *__hidden this)
.text$mn:0000168C                 public ?scrollMap@DocumentMap@@QAEXXZ
.text$mn:0000168C ?scrollMap@DocumentMap@@QAEXXZ proc near
.text$mn:0000168C                                         ; CODE XREF: DocumentMap::reloadMap(void)+EDp
.text$mn:0000168C                                         ; DocumentMap::scrollMap(bool,moveMode)+8Cp ...
.text$mn:0000168C
.text$mn:0000168C var_40          = dword ptr -40h
.text$mn:0000168C var_3C          = dword ptr -3Ch
.text$mn:0000168C var_38          = dword ptr -38h
.text$mn:0000168C var_34          = dword ptr -34h
.text$mn:0000168C var_30          = dword ptr -30h
.text$mn:0000168C var_2C          = dword ptr -2Ch
.text$mn:0000168C var_28          = dword ptr -28h
.text$mn:0000168C var_24          = dword ptr -24h
.text$mn:0000168C var_20          = dword ptr -20h
.text$mn:0000168C var_1C          = dword ptr -1Ch
.text$mn:0000168C var_18          = dword ptr -18h
.text$mn:0000168C var_14          = dword ptr -14h
.text$mn:0000168C var_10          = dword ptr -10h
.text$mn:0000168C var_C           = dword ptr -0Ch
.text$mn:0000168C var_8           = dword ptr -8
.text$mn:0000168C var_4           = dword ptr -4
.text$mn:0000168C
.text$mn:0000168C                 push    ebp
.text$mn:0000168D                 mov     ebp, esp
.text$mn:0000168F                 sub     esp, 40h
.text$mn:00001692                 mov     [ebp+var_4], ecx
.text$mn:00001695                 mov     eax, [ebp+var_4]
.text$mn:00001698                 cmp     dword ptr [eax+70h], 0
.text$mn:0000169C                 jz      loc_18DC
.text$mn:000016A2                 mov     ecx, [ebp+var_4]
.text$mn:000016A5                 cmp     dword ptr [ecx+6Ch], 0
.text$mn:000016A9                 jz      loc_18DC
.text$mn:000016AF                 push    0               ; __int32
.text$mn:000016B1                 push    0               ; unsigned int
.text$mn:000016B3                 push    868h            ; unsigned int
.text$mn:000016B8                 mov     edx, [ebp+var_4]
.text$mn:000016BB                 mov     eax, [edx+6Ch]
.text$mn:000016BE                 mov     ecx, [eax]      ; this
.text$mn:000016C0                 call    ?execute@ScintillaEditView@@QBEJIIJ@Z ; ScintillaEditView::execute(uint,uint,long)
.text$mn:000016C5                 mov     [ebp+var_14], eax
.text$mn:000016C8                 push    0               ; __int32
.text$mn:000016CA                 mov     ecx, [ebp+var_14]
.text$mn:000016CD                 push    ecx             ; unsigned int
.text$mn:000016CE                 push    8ADh            ; unsigned int
.text$mn:000016D3                 mov     edx, [ebp+var_4]
.text$mn:000016D6                 mov     eax, [edx+6Ch]
.text$mn:000016D9                 mov     ecx, [eax]      ; this
.text$mn:000016DB                 call    ?execute@ScintillaEditView@@QBEJIIJ@Z ; ScintillaEditView::execute(uint,uint,long)
.text$mn:000016E0                 mov     [ebp+var_8], eax
.text$mn:000016E3                 push    0               ; __int32
.text$mn:000016E5                 mov     ecx, [ebp+var_14]
.text$mn:000016E8                 push    ecx             ; unsigned int
.text$mn:000016E9                 push    942h            ; unsigned int
.text$mn:000016EE                 mov     edx, [ebp+var_4]
.text$mn:000016F1                 mov     eax, [edx+6Ch]
.text$mn:000016F4                 mov     ecx, [eax]      ; this
.text$mn:000016F6                 call    ?execute@ScintillaEditView@@QBEJIIJ@Z ; ScintillaEditView::execute(uint,uint,long)
.text$mn:000016FB                 mov     [ebp+var_1C], eax
.text$mn:000016FE                 push    0               ; __int32
.text$mn:00001700                 mov     ecx, [ebp+var_14]
.text$mn:00001703                 add     ecx, [ebp+var_1C]
.text$mn:00001706                 push    ecx             ; unsigned int
.text$mn:00001707                 push    8ADh            ; unsigned int
.text$mn:0000170C                 mov     edx, [ebp+var_4]
.text$mn:0000170F                 mov     eax, [edx+6Ch]
.text$mn:00001712                 mov     ecx, [eax]      ; this
.text$mn:00001714                 call    ?execute@ScintillaEditView@@QBEJIIJ@Z ; ScintillaEditView::execute(uint,uint,long)
.text$mn:00001719                 mov     [ebp+var_18], eax
.text$mn:0000171C                 push    0               ; __int32
.text$mn:0000171E                 push    0               ; unsigned int
.text$mn:00001720                 push    868h            ; unsigned int
.text$mn:00001725                 mov     ecx, [ebp+var_4]
.text$mn:00001728                 mov     ecx, [ecx+70h]  ; this
.text$mn:0000172B                 call    ?execute@ScintillaEditView@@QBEJIIJ@Z ; ScintillaEditView::execute(uint,uint,long)
.text$mn:00001730                 mov     [ebp+var_20], eax
.text$mn:00001733                 push    0               ; __int32
.text$mn:00001735                 mov     edx, [ebp+var_20]
.text$mn:00001738                 push    edx             ; unsigned int
.text$mn:00001739                 push    8ADh            ; unsigned int
.text$mn:0000173E                 mov     eax, [ebp+var_4]
.text$mn:00001741                 mov     ecx, [eax+70h]  ; this
.text$mn:00001744                 call    ?execute@ScintillaEditView@@QBEJIIJ@Z ; ScintillaEditView::execute(uint,uint,long)
.text$mn:00001749                 mov     [ebp+var_24], eax
.text$mn:0000174C                 push    0               ; __int32
.text$mn:0000174E                 mov     ecx, [ebp+var_24]
.text$mn:00001751                 push    ecx             ; unsigned int
.text$mn:00001752                 push    942h            ; unsigned int
.text$mn:00001757                 mov     edx, [ebp+var_4]
.text$mn:0000175A                 mov     ecx, [edx+70h]  ; this
.text$mn:0000175D                 call    ?execute@ScintillaEditView@@QBEJIIJ@Z ; ScintillaEditView::execute(uint,uint,long)
.text$mn:00001762                 mov     [ebp+var_28], eax
.text$mn:00001765                 push    0               ; __int32
.text$mn:00001767                 mov     eax, [ebp+var_20]
.text$mn:0000176A                 add     eax, [ebp+var_28]
.text$mn:0000176D                 push    eax             ; unsigned int
.text$mn:0000176E                 push    8ADh            ; unsigned int
.text$mn:00001773                 mov     ecx, [ebp+var_4]
.text$mn:00001776                 mov     edx, [ecx+6Ch]
.text$mn:00001779                 mov     ecx, [edx]      ; this
.text$mn:0000177B                 call    ?execute@ScintillaEditView@@QBEJIIJ@Z ; ScintillaEditView::execute(uint,uint,long)
.text$mn:00001780                 mov     [ebp+var_2C], eax
.text$mn:00001783                 mov     eax, [ebp+var_2C]
.text$mn:00001786                 cmp     eax, [ebp+var_18]
.text$mn:00001789                 jge     short loc_17A3
.text$mn:0000178B                 push    0               ; __int32
.text$mn:0000178D                 mov     ecx, [ebp+var_18]
.text$mn:00001790                 push    ecx             ; unsigned int
.text$mn:00001791                 push    7E8h            ; unsigned int
.text$mn:00001796                 mov     edx, [ebp+var_4]
.text$mn:00001799                 mov     ecx, [edx+70h]  ; this
.text$mn:0000179C                 call    ?execute@ScintillaEditView@@QBEJIIJ@Z ; ScintillaEditView::execute(uint,uint,long)
.text$mn:000017A1                 jmp     short loc_17B9
.text$mn:000017A3 ; ---------------------------------------------------------------------------
.text$mn:000017A3
.text$mn:000017A3 loc_17A3:                               ; CODE XREF: DocumentMap::scrollMap(void)+FDj
.text$mn:000017A3                 push    0               ; __int32
.text$mn:000017A5                 mov     eax, [ebp+var_8]
.text$mn:000017A8                 push    eax             ; unsigned int
.text$mn:000017A9                 push    7E8h            ; unsigned int
.text$mn:000017AE                 mov     ecx, [ebp+var_4]
.text$mn:000017B1                 mov     ecx, [ecx+70h]  ; this
.text$mn:000017B4                 call    ?execute@ScintillaEditView@@QBEJIIJ@Z ; ScintillaEditView::execute(uint,uint,long)
.text$mn:000017B9
.text$mn:000017B9 loc_17B9:                               ; CODE XREF: DocumentMap::scrollMap(void)+115j
.text$mn:000017B9                 mov     [ebp+var_10], 0
.text$mn:000017C0                 mov     [ebp+var_C], 0
.text$mn:000017C7                 mov     edx, [ebp+var_4]
.text$mn:000017CA                 mov     eax, [edx+6Ch]
.text$mn:000017CD                 mov     ecx, [eax]      ; this
.text$mn:000017CF                 call    ?isWrap@ScintillaEditView@@QBE_NXZ ; ScintillaEditView::isWrap(void)
.text$mn:000017D4                 movzx   ecx, al
.text$mn:000017D7                 test    ecx, ecx
.text$mn:000017D9                 jnz     loc_1871
.text$mn:000017DF                 push    0               ; __int32
.text$mn:000017E1                 mov     edx, [ebp+var_8]
.text$mn:000017E4                 push    edx             ; unsigned int
.text$mn:000017E5                 push    877h            ; unsigned int
.text$mn:000017EA                 mov     eax, [ebp+var_4]
.text$mn:000017ED                 mov     ecx, [eax+70h]  ; this
.text$mn:000017F0                 call    ?execute@ScintillaEditView@@QBEJIIJ@Z ; ScintillaEditView::execute(uint,uint,long)
.text$mn:000017F5                 mov     [ebp+var_30], eax
.text$mn:000017F8                 push    0               ; __int32
.text$mn:000017FA                 mov     ecx, [ebp+var_18]
.text$mn:000017FD                 push    ecx             ; unsigned int
.text$mn:000017FE                 push    877h            ; unsigned int
.text$mn:00001803                 mov     edx, [ebp+var_4]
.text$mn:00001806                 mov     ecx, [edx+70h]  ; this
.text$mn:00001809                 call    ?execute@ScintillaEditView@@QBEJIIJ@Z ; ScintillaEditView::execute(uint,uint,long)
.text$mn:0000180E                 mov     [ebp+var_34], eax
.text$mn:00001811                 mov     eax, [ebp+var_30]
.text$mn:00001814                 push    eax             ; __int32
.text$mn:00001815                 push    0               ; unsigned int
.text$mn:00001817                 push    875h            ; unsigned int
.text$mn:0000181C                 mov     ecx, [ebp+var_4]
.text$mn:0000181F                 mov     ecx, [ecx+70h]  ; this
.text$mn:00001822                 call    ?execute@ScintillaEditView@@QBEJIIJ@Z ; ScintillaEditView::execute(uint,uint,long)
.text$mn:00001827                 mov     [ebp+var_10], eax
.text$mn:0000182A                 mov     edx, [ebp+var_34]
.text$mn:0000182D                 push    edx             ; __int32
.text$mn:0000182E                 push    0               ; unsigned int
.text$mn:00001830                 push    875h            ; unsigned int
.text$mn:00001835                 mov     eax, [ebp+var_4]
.text$mn:00001838                 mov     ecx, [eax+70h]  ; this
.text$mn:0000183B                 call    ?execute@ScintillaEditView@@QBEJIIJ@Z ; ScintillaEditView::execute(uint,uint,long)
.text$mn:00001840                 mov     [ebp+var_C], eax
.text$mn:00001843                 cmp     [ebp+var_C], 0
.text$mn:00001847                 jnz     short loc_186F
.text$mn:00001849                 push    0               ; __int32
.text$mn:0000184B                 mov     ecx, [ebp+var_8]
.text$mn:0000184E                 push    ecx             ; unsigned int
.text$mn:0000184F                 push    8E7h            ; unsigned int
.text$mn:00001854                 mov     edx, [ebp+var_4]
.text$mn:00001857                 mov     ecx, [edx+70h]  ; this
.text$mn:0000185A                 call    ?execute@ScintillaEditView@@QBEJIIJ@Z ; ScintillaEditView::execute(uint,uint,long)
.text$mn:0000185F                 mov     [ebp+var_38], eax
.text$mn:00001862                 mov     eax, [ebp+var_1C]
.text$mn:00001865                 imul    eax, [ebp+var_38]
.text$mn:00001869                 add     eax, [ebp+var_8]
.text$mn:0000186C                 mov     [ebp+var_C], eax
.text$mn:0000186F
.text$mn:0000186F loc_186F:                               ; CODE XREF: DocumentMap::scrollMap(void)+1BBj
.text$mn:0000186F                 jmp     short loc_18C9
.text$mn:00001871 ; ---------------------------------------------------------------------------
.text$mn:00001871
.text$mn:00001871 loc_1871:                               ; CODE XREF: DocumentMap::scrollMap(void)+14Dj
.text$mn:00001871                 push    0               ; __int32
.text$mn:00001873                 push    0               ; unsigned int
.text$mn:00001875                 push    7E6h            ; unsigned int
.text$mn:0000187A                 mov     ecx, [ebp+var_4]
.text$mn:0000187D                 mov     edx, [ecx+6Ch]
.text$mn:00001880                 mov     ecx, [edx]      ; this
.text$mn:00001882                 call    ?execute@ScintillaEditView@@QBEJIIJ@Z ; ScintillaEditView::execute(uint,uint,long)
.text$mn:00001887                 mov     [ebp+var_3C], eax
.text$mn:0000188A                 mov     eax, [ebp+var_3C]
.text$mn:0000188D                 push    eax             ; __int32
.text$mn:0000188E                 push    0               ; unsigned int
.text$mn:00001890                 push    875h            ; unsigned int
.text$mn:00001895                 mov     ecx, [ebp+var_4]
.text$mn:00001898                 mov     ecx, [ecx+70h]  ; this
.text$mn:0000189B                 call    ?execute@ScintillaEditView@@QBEJIIJ@Z ; ScintillaEditView::execute(uint,uint,long)
.text$mn:000018A0                 mov     [ebp+var_10], eax
.text$mn:000018A3                 push    0               ; __int32
.text$mn:000018A5                 mov     edx, [ebp+var_8]
.text$mn:000018A8                 push    edx             ; unsigned int
.text$mn:000018A9                 push    8E7h            ; unsigned int
.text$mn:000018AE                 mov     eax, [ebp+var_4]
.text$mn:000018B1                 mov     ecx, [eax+70h]  ; this
.text$mn:000018B4                 call    ?execute@ScintillaEditView@@QBEJIIJ@Z ; ScintillaEditView::execute(uint,uint,long)
.text$mn:000018B9                 mov     [ebp+var_40], eax
.text$mn:000018BC                 mov     ecx, [ebp+var_1C]
.text$mn:000018BF                 imul    ecx, [ebp+var_40]
.text$mn:000018C3                 add     ecx, [ebp+var_10]
.text$mn:000018C6                 mov     [ebp+var_C], ecx
.text$mn:000018C9
.text$mn:000018C9 loc_18C9:                               ; CODE XREF: DocumentMap::scrollMap(void):loc_186Fj
.text$mn:000018C9                 mov     edx, [ebp+var_C]
.text$mn:000018CC                 push    edx             ; __int32
.text$mn:000018CD                 mov     eax, [ebp+var_10]
.text$mn:000018D0                 push    eax             ; __int32
.text$mn:000018D1                 mov     ecx, [ebp+var_4]
.text$mn:000018D4                 add     ecx, 74h ; 't'  ; this
.text$mn:000018D7                 call    ?drawZone@ViewZoneDlg@@QAEXJJ@Z ; ViewZoneDlg::drawZone(long,long)
.text$mn:000018DC
.text$mn:000018DC loc_18DC:                               ; CODE XREF: DocumentMap::scrollMap(void)+10j
.text$mn:000018DC                                         ; DocumentMap::scrollMap(void)+1Dj
.text$mn:000018DC                 mov     esp, ebp
.text$mn:000018DE                 pop     ebp
.text$mn:000018DF                 retn
.text$mn:000018DF ?scrollMap@DocumentMap@@QAEXXZ endp
.text$mn:000018DF
.text$mn:000018DF ; ---------------------------------------------------------------------------
.text$mn:000018E0                 db 0Ch dup(0CCh)
.text$mn:000018EC
.text$mn:000018EC ; =============== S U B R O U T I N E =======================================
.text$mn:000018EC
.text$mn:000018EC ; Attributes: bp-based frame
.text$mn:000018EC
.text$mn:000018EC ; public: void __thiscall DocumentMap::scrollMap(bool, enum  moveMode)
.text$mn:000018EC                 public ?scrollMap@DocumentMap@@QAEX_NW4moveMode@@@Z
.text$mn:000018EC ?scrollMap@DocumentMap@@QAEX_NW4moveMode@@@Z proc near
.text$mn:000018EC                                         ; CODE XREF: DocumentMap::run_dlgProc(uint,uint,long)+3E9p
.text$mn:000018EC
.text$mn:000018EC var_18          = dword ptr -18h
.text$mn:000018EC var_14          = dword ptr -14h
.text$mn:000018EC var_10          = dword ptr -10h
.text$mn:000018EC var_C           = dword ptr -0Ch
.text$mn:000018EC var_8           = dword ptr -8
.text$mn:000018EC var_4           = dword ptr -4
.text$mn:000018EC arg_0           = byte ptr  8
.text$mn:000018EC arg_4           = dword ptr  0Ch
.text$mn:000018EC
.text$mn:000018EC                 push    ebp
.text$mn:000018ED                 mov     ebp, esp
.text$mn:000018EF                 sub     esp, 18h
.text$mn:000018F2                 mov     [ebp+var_4], ecx
.text$mn:000018F5                 push    0               ; __int32
.text$mn:000018F7                 push    0               ; unsigned int
.text$mn:000018F9                 push    868h            ; unsigned int
.text$mn:000018FE                 mov     eax, [ebp+var_4]
.text$mn:00001901                 mov     ecx, [eax+6Ch]
.text$mn:00001904                 mov     ecx, [ecx]      ; this
.text$mn:00001906                 call    ?execute@ScintillaEditView@@QBEJIIJ@Z ; ScintillaEditView::execute(uint,uint,long)
.text$mn:0000190B                 mov     [ebp+var_14], eax
.text$mn:0000190E                 push    0               ; __int32
.text$mn:00001910                 mov     edx, [ebp+var_14]
.text$mn:00001913                 push    edx             ; unsigned int
.text$mn:00001914                 push    942h            ; unsigned int
.text$mn:00001919                 mov     eax, [ebp+var_4]
.text$mn:0000191C                 mov     ecx, [eax+6Ch]
.text$mn:0000191F                 mov     ecx, [ecx]      ; this
.text$mn:00001921                 call    ?execute@ScintillaEditView@@QBEJIIJ@Z ; ScintillaEditView::execute(uint,uint,long)
.text$mn:00001926                 mov     [ebp+var_18], eax
.text$mn:00001929                 cmp     [ebp+arg_4], 0
.text$mn:0000192D                 jnz     short loc_1938
.text$mn:0000192F                 mov     [ebp+var_8], 1
.text$mn:00001936                 jmp     short loc_193E
.text$mn:00001938 ; ---------------------------------------------------------------------------
.text$mn:00001938
.text$mn:00001938 loc_1938:                               ; CODE XREF: DocumentMap::scrollMap(bool,moveMode)+41j
.text$mn:00001938                 mov     edx, [ebp+var_18]
.text$mn:0000193B                 mov     [ebp+var_8], edx
.text$mn:0000193E
.text$mn:0000193E loc_193E:                               ; CODE XREF: DocumentMap::scrollMap(bool,moveMode)+4Aj
.text$mn:0000193E                 mov     eax, [ebp+var_8]
.text$mn:00001941                 mov     [ebp+var_C], eax
.text$mn:00001944                 movzx   ecx, [ebp+arg_0]
.text$mn:00001948                 cmp     ecx, 1
.text$mn:0000194B                 jnz     short loc_1955
.text$mn:0000194D                 mov     edx, [ebp+var_C]
.text$mn:00001950                 mov     [ebp+var_10], edx
.text$mn:00001953                 jmp     short loc_195D
.text$mn:00001955 ; ---------------------------------------------------------------------------
.text$mn:00001955
.text$mn:00001955 loc_1955:                               ; CODE XREF: DocumentMap::scrollMap(bool,moveMode)+5Fj
.text$mn:00001955                 mov     eax, [ebp+var_C]
.text$mn:00001958                 neg     eax
.text$mn:0000195A                 mov     [ebp+var_10], eax
.text$mn:0000195D
.text$mn:0000195D loc_195D:                               ; CODE XREF: DocumentMap::scrollMap(bool,moveMode)+67j
.text$mn:0000195D                 mov     ecx, [ebp+var_10]
.text$mn:00001960                 push    ecx             ; __int32
.text$mn:00001961                 push    0               ; unsigned int
.text$mn:00001963                 push    878h            ; unsigned int
.text$mn:00001968                 mov     edx, [ebp+var_4]
.text$mn:0000196B                 mov     eax, [edx+6Ch]
.text$mn:0000196E                 mov     ecx, [eax]      ; this
.text$mn:00001970                 call    ?execute@ScintillaEditView@@QBEJIIJ@Z ; ScintillaEditView::execute(uint,uint,long)
.text$mn:00001975                 mov     ecx, [ebp+var_4] ; this
.text$mn:00001978                 call    ?scrollMap@DocumentMap@@QAEXXZ ; DocumentMap::scrollMap(void)
.text$mn:0000197D                 mov     esp, ebp
.text$mn:0000197F                 pop     ebp
.text$mn:00001980                 retn    8
.text$mn:00001980 ?scrollMap@DocumentMap@@QAEX_NW4moveMode@@@Z endp
.text$mn:00001980
.text$mn:00001980 ; ---------------------------------------------------------------------------
.text$mn:00001983                 db 9 dup(0CCh)
.text$mn:0000198C
.text$mn:0000198C ; =============== S U B R O U T I N E =======================================
.text$mn:0000198C
.text$mn:0000198C ; Attributes: bp-based frame
.text$mn:0000198C
.text$mn:0000198C ; void __thiscall DocumentMap::doMove(DocumentMap *__hidden this)
.text$mn:0000198C                 public ?doMove@DocumentMap@@QAEXXZ
.text$mn:0000198C ?doMove@DocumentMap@@QAEXXZ proc near
.text$mn:0000198C
.text$mn:0000198C Point           = tagPOINT ptr -20h
.text$mn:0000198C var_18          = dword ptr -18h
.text$mn:0000198C var_14          = dword ptr -14h
.text$mn:0000198C var_10          = dword ptr -10h
.text$mn:0000198C var_C           = dword ptr -0Ch
.text$mn:0000198C var_8           = dword ptr -8
.text$mn:0000198C var_4           = dword ptr -4
.text$mn:0000198C
.text$mn:0000198C                 push    ebp
.text$mn:0000198D                 mov     ebp, esp
.text$mn:0000198F                 sub     esp, 20h
.text$mn:00001992                 mov     eax, dword ptr ds:___security_cookie
.text$mn:00001997                 xor     eax, ebp
.text$mn:00001999                 mov     [ebp+var_4], eax
.text$mn:0000199C                 mov     [ebp+var_18], ecx
.text$mn:0000199F                 mov     [ebp+Point.x], 0
.text$mn:000019A6                 mov     [ebp+Point.y], 0
.text$mn:000019AD                 lea     eax, [ebp+Point]
.text$mn:000019B0                 push    eax             ; lpPoint
.text$mn:000019B1                 mov     ecx, [ebp+var_18]
.text$mn:000019B4                 mov     edx, [ecx+0Ch]
.text$mn:000019B7                 push    edx             ; hWnd
.text$mn:000019B8                 call    dword ptr ds:__imp__ClientToScreen@8 ; ClientToScreen(x,x)
.text$mn:000019BE                 lea     eax, [ebp+var_14]
.text$mn:000019C1                 push    eax
.text$mn:000019C2                 mov     ecx, [ebp+var_18]
.text$mn:000019C5                 mov     edx, [ecx]
.text$mn:000019C7                 mov     ecx, [ebp+var_18]
.text$mn:000019CA                 mov     eax, [edx+1Ch]
.text$mn:000019CD                 call    eax
.text$mn:000019CF                 push    1               ; bRepaint
.text$mn:000019D1                 mov     ecx, [ebp+var_8]
.text$mn:000019D4                 sub     ecx, [ebp+var_10]
.text$mn:000019D7                 push    ecx             ; nHeight
.text$mn:000019D8                 mov     edx, [ebp+var_C]
.text$mn:000019DB                 sub     edx, [ebp+var_14]
.text$mn:000019DE                 push    edx             ; nWidth
.text$mn:000019DF                 mov     eax, [ebp+Point.y]
.text$mn:000019E2                 push    eax             ; Y
.text$mn:000019E3                 mov     ecx, [ebp+Point.x]
.text$mn:000019E6                 push    ecx             ; X
.text$mn:000019E7                 mov     ecx, [ebp+var_18]
.text$mn:000019EA                 add     ecx, 74h ; 't'  ; this
.text$mn:000019ED                 call    ?getHSelf@Window@@QBEPAUHWND__@@XZ ; Window::getHSelf(void)
.text$mn:000019F2                 push    eax             ; hWnd
.text$mn:000019F3                 call    dword ptr ds:__imp__MoveWindow@24 ; MoveWindow(x,x,x,x,x,x)
.text$mn:000019F9                 mov     ecx, [ebp+var_4]
.text$mn:000019FC                 xor     ecx, ebp
.text$mn:000019FE                 call    @__security_check_cookie@4 ; __security_check_cookie(x)
.text$mn:00001A03                 mov     esp, ebp
.text$mn:00001A05                 pop     ebp
.text$mn:00001A06                 retn
.text$mn:00001A06 ?doMove@DocumentMap@@QAEXXZ endp
.text$mn:00001A06
.text$mn:00001A06 ; ---------------------------------------------------------------------------
.text$mn:00001A07                 db 5 dup(0CCh)
.text$mn:00001A0C
.text$mn:00001A0C ; =============== S U B R O U T I N E =======================================
.text$mn:00001A0C
.text$mn:00001A0C ; Attributes: bp-based frame
.text$mn:00001A0C
.text$mn:00001A0C ; void __thiscall DocumentMap::fold(DocumentMap *this, int, bool)
.text$mn:00001A0C                 public ?fold@DocumentMap@@QAEXH_N@Z
.text$mn:00001A0C ?fold@DocumentMap@@QAEXH_N@Z proc near
.text$mn:00001A0C
.text$mn:00001A0C var_4           = dword ptr -4
.text$mn:00001A0C arg_0           = dword ptr  8
.text$mn:00001A0C arg_4           = byte ptr  0Ch
.text$mn:00001A0C
.text$mn:00001A0C                 push    ebp
.text$mn:00001A0D                 mov     ebp, esp
.text$mn:00001A0F                 push    ecx
.text$mn:00001A10                 mov     [ebp+var_4], ecx
.text$mn:00001A13                 movzx   eax, [ebp+arg_4]
.text$mn:00001A17                 push    eax             ; bool
.text$mn:00001A18                 mov     ecx, [ebp+arg_0]
.text$mn:00001A1B                 push    ecx             ; int
.text$mn:00001A1C                 mov     edx, [ebp+var_4]
.text$mn:00001A1F                 mov     ecx, [edx+70h]  ; this
.text$mn:00001A22                 call    ?fold@ScintillaEditView@@QAEXH_N@Z ; ScintillaEditView::fold(int,bool)
.text$mn:00001A27                 mov     esp, ebp
.text$mn:00001A29                 pop     ebp
.text$mn:00001A2A                 retn    8
.text$mn:00001A2A ?fold@DocumentMap@@QAEXH_N@Z endp
.text$mn:00001A2A
.text$mn:00001A2A ; ---------------------------------------------------------------------------
.text$mn:00001A2D                 db 0Fh dup(0CCh)
.text$mn:00001A3C
.text$mn:00001A3C ; =============== S U B R O U T I N E =======================================
.text$mn:00001A3C
.text$mn:00001A3C ; Attributes: bp-based frame
.text$mn:00001A3C
.text$mn:00001A3C ; void __thiscall DocumentMap::foldAll(DocumentMap *this, bool)
.text$mn:00001A3C                 public ?foldAll@DocumentMap@@QAEX_N@Z
.text$mn:00001A3C ?foldAll@DocumentMap@@QAEX_N@Z proc near
.text$mn:00001A3C
.text$mn:00001A3C var_4           = dword ptr -4
.text$mn:00001A3C arg_0           = byte ptr  8
.text$mn:00001A3C
.text$mn:00001A3C                 push    ebp
.text$mn:00001A3D                 mov     ebp, esp
.text$mn:00001A3F                 push    ecx
.text$mn:00001A40                 mov     [ebp+var_4], ecx
.text$mn:00001A43                 movzx   eax, [ebp+arg_0]
.text$mn:00001A47                 push    eax             ; bool
.text$mn:00001A48                 mov     ecx, [ebp+var_4]
.text$mn:00001A4B                 mov     ecx, [ecx+70h]  ; this
.text$mn:00001A4E                 call    ?foldAll@ScintillaEditView@@QAEX_N@Z ; ScintillaEditView::foldAll(bool)
.text$mn:00001A53                 mov     esp, ebp
.text$mn:00001A55                 pop     ebp
.text$mn:00001A56                 retn    4
.text$mn:00001A56 ?foldAll@DocumentMap@@QAEX_N@Z endp
.text$mn:00001A56
.text$mn:00001A56 ; ---------------------------------------------------------------------------
.text$mn:00001A59                 align 4
.text$mn:00001A5C
.text$mn:00001A5C ; =============== S U B R O U T I N E =======================================
.text$mn:00001A5C
.text$mn:00001A5C ; Attributes: bp-based frame
.text$mn:00001A5C
.text$mn:00001A5C ; void __thiscall DocumentMap::setSyntaxHiliting(DocumentMap *__hidden this)
.text$mn:00001A5C                 public ?setSyntaxHiliting@DocumentMap@@QAEXXZ
.text$mn:00001A5C ?setSyntaxHiliting@DocumentMap@@QAEXXZ proc near
.text$mn:00001A5C                                         ; CODE XREF: DocumentMap::run_dlgProc(uint,uint,long)+158p
.text$mn:00001A5C                                         ; DocumentMap::run_dlgProc(uint,uint,long)+2EDp
.text$mn:00001A5C
.text$mn:00001A5C var_8           = dword ptr -8
.text$mn:00001A5C var_4           = dword ptr -4
.text$mn:00001A5C
.text$mn:00001A5C                 push    ebp
.text$mn:00001A5D                 mov     ebp, esp
.text$mn:00001A5F                 sub     esp, 8
.text$mn:00001A62                 mov     [ebp+var_4], ecx
.text$mn:00001A65                 mov     eax, [ebp+var_4]
.text$mn:00001A68                 mov     ecx, [eax+70h]  ; this
.text$mn:00001A6B                 call    ?getCurrentBuffer@ScintillaEditView@@QAEPAVBuffer@@XZ ; ScintillaEditView::getCurrentBuffer(void)
.text$mn:00001A70                 mov     [ebp+var_8], eax
.text$mn:00001A73                 mov     ecx, [ebp+var_8]
.text$mn:00001A76                 call    ?getLangType@Buffer@@QBE?AW4LangType@@XZ ; Buffer::getLangType(void)
.text$mn:00001A7B                 push    eax
.text$mn:00001A7C                 mov     ecx, [ebp+var_4]
.text$mn:00001A7F                 mov     ecx, [ecx+70h]
.text$mn:00001A82                 call    ?defineDocType@ScintillaEditView@@QAEXW4LangType@@@Z ; ScintillaEditView::defineDocType(LangType)
.text$mn:00001A87                 push    0               ; bool
.text$mn:00001A89                 mov     edx, dword ptr ds:?_SC_MARGE_FOLDER@ScintillaEditView@@2HB ; int const ScintillaEditView::_SC_MARGE_FOLDER
.text$mn:00001A8F                 push    edx             ; unsigned int
.text$mn:00001A90                 mov     eax, [ebp+var_4]
.text$mn:00001A93                 mov     ecx, [eax+70h]  ; this
.text$mn:00001A96                 call    ?showMargin@ScintillaEditView@@QAEXH_N@Z ; ScintillaEditView::showMargin(int,bool)
.text$mn:00001A9B                 mov     esp, ebp
.text$mn:00001A9D                 pop     ebp
.text$mn:00001A9E                 retn
.text$mn:00001A9E ?setSyntaxHiliting@DocumentMap@@QAEXXZ endp
.text$mn:00001A9E
.text$mn:00001A9E ; ---------------------------------------------------------------------------
.text$mn:00001A9F                 db 0Dh dup(0CCh)
.text$mn:00001AAC
.text$mn:00001AAC ; =============== S U B R O U T I N E =======================================
.text$mn:00001AAC
.text$mn:00001AAC ; Attributes: bp-based frame
.text$mn:00001AAC
.text$mn:00001AAC ; void __thiscall DocumentMap::changeTextDirection(DocumentMap *this, bool)
.text$mn:00001AAC                 public ?changeTextDirection@DocumentMap@@QAEX_N@Z
.text$mn:00001AAC ?changeTextDirection@DocumentMap@@QAEX_N@Z proc near
.text$mn:00001AAC
.text$mn:00001AAC var_4           = dword ptr -4
.text$mn:00001AAC arg_0           = byte ptr  8
.text$mn:00001AAC
.text$mn:00001AAC                 push    ebp
.text$mn:00001AAD                 mov     ebp, esp
.text$mn:00001AAF                 push    ecx
.text$mn:00001AB0                 mov     [ebp+var_4], ecx
.text$mn:00001AB3                 movzx   eax, [ebp+arg_0]
.text$mn:00001AB7                 push    eax             ; bool
.text$mn:00001AB8                 mov     ecx, [ebp+var_4]
.text$mn:00001ABB                 mov     ecx, [ecx+70h]  ; this
.text$mn:00001ABE                 call    ?changeTextDirection@ScintillaEditView@@QAEX_N@Z ; ScintillaEditView::changeTextDirection(bool)
.text$mn:00001AC3                 mov     esp, ebp
.text$mn:00001AC5                 pop     ebp
.text$mn:00001AC6                 retn    4
.text$mn:00001AC6 ?changeTextDirection@DocumentMap@@QAEX_N@Z endp
.text$mn:00001AC6
.text$mn:00001AC6 ; ---------------------------------------------------------------------------
.text$mn:00001AC9                 align 4
.text$mn:00001ACC
.text$mn:00001ACC ; =============== S U B R O U T I N E =======================================
.text$mn:00001ACC
.text$mn:00001ACC ; Attributes: bp-based frame
.text$mn:00001ACC
.text$mn:00001ACC ; int __stdcall DocumentMap::run_dlgProc(DocumentMap *this, unsigned int, unsigned int, __int32)
.text$mn:00001ACC                 public ?run_dlgProc@DocumentMap@@MAGHIIJ@Z
.text$mn:00001ACC ?run_dlgProc@DocumentMap@@MAGHIIJ@Z proc near
.text$mn:00001ACC
.text$mn:00001ACC var_64          = dword ptr -64h
.text$mn:00001ACC var_60          = dword ptr -60h
.text$mn:00001ACC lParam          = dword ptr -5Ch
.text$mn:00001ACC var_58          = dword ptr -58h
.text$mn:00001ACC var_54          = dword ptr -54h
.text$mn:00001ACC var_50          = dword ptr -50h
.text$mn:00001ACC var_4C          = dword ptr -4Ch
.text$mn:00001ACC var_48          = dword ptr -48h
.text$mn:00001ACC var_44          = dword ptr -44h
.text$mn:00001ACC var_40          = tagPOINT ptr -40h
.text$mn:00001ACC Point           = tagPOINT ptr -38h
.text$mn:00001ACC var_30          = dword ptr -30h
.text$mn:00001ACC var_2C          = dword ptr -2Ch
.text$mn:00001ACC nHeight         = dword ptr -28h
.text$mn:00001ACC nWidth          = dword ptr -24h
.text$mn:00001ACC var_20          = dword ptr -20h
.text$mn:00001ACC var_19          = byte ptr -19h
.text$mn:00001ACC var_18          = dword ptr -18h
.text$mn:00001ACC var_14          = dword ptr -14h
.text$mn:00001ACC var_10          = dword ptr -10h
.text$mn:00001ACC var_C           = dword ptr -0Ch
.text$mn:00001ACC var_8           = dword ptr -8
.text$mn:00001ACC var_4           = dword ptr -4
.text$mn:00001ACC this            = dword ptr  8
.text$mn:00001ACC arg_4           = dword ptr  0Ch
.text$mn:00001ACC arg_8           = dword ptr  10h
.text$mn:00001ACC arg_C           = dword ptr  14h
.text$mn:00001ACC
.text$mn:00001ACC                 push    ebp
.text$mn:00001ACD                 mov     ebp, esp
.text$mn:00001ACF                 sub     esp, 64h
.text$mn:00001AD2                 mov     eax, dword ptr ds:___security_cookie
.text$mn:00001AD7                 xor     eax, ebp
.text$mn:00001AD9                 mov     [ebp+var_4], eax
.text$mn:00001ADC                 mov     eax, [ebp+arg_4]
.text$mn:00001ADF                 mov     [ebp+var_18], eax
.text$mn:00001AE2                 cmp     [ebp+var_18], 401h
.text$mn:00001AE9                 ja      short loc_1B1A
.text$mn:00001AEB                 cmp     [ebp+var_18], 401h
.text$mn:00001AF2                 jz      loc_1E71
.text$mn:00001AF8                 cmp     [ebp+var_18], 5
.text$mn:00001AFC                 jz      loc_1C6F
.text$mn:00001B02                 cmp     [ebp+var_18], 4Eh ; 'N'
.text$mn:00001B06                 jz      loc_1D2E
.text$mn:00001B0C                 cmp     [ebp+var_18], 110h
.text$mn:00001B13                 jz      short loc_1B39
.text$mn:00001B15                 jmp     loc_1F51
.text$mn:00001B1A ; ---------------------------------------------------------------------------
.text$mn:00001B1A
.text$mn:00001B1A loc_1B1A:                               ; CODE XREF: DocumentMap::run_dlgProc(uint,uint,long)+1Dj
.text$mn:00001B1A                 cmp     [ebp+var_18], 402h
.text$mn:00001B21                 jz      loc_1EC4
.text$mn:00001B27                 cmp     [ebp+var_18], 403h
.text$mn:00001B2E                 jz      loc_1F35
.text$mn:00001B34                 jmp     loc_1F51
.text$mn:00001B39 ; ---------------------------------------------------------------------------
.text$mn:00001B39
.text$mn:00001B39 loc_1B39:                               ; CODE XREF: DocumentMap::run_dlgProc(uint,uint,long)+47j
.text$mn:00001B39                 mov     ecx, [ebp+this]
.text$mn:00001B3C                 mov     edx, [ecx+0Ch]
.text$mn:00001B3F                 push    edx             ; lParam
.text$mn:00001B40                 push    0               ; wParam
.text$mn:00001B42                 push    7FCh            ; Msg
.text$mn:00001B47                 mov     eax, [ebp+this]
.text$mn:00001B4A                 mov     ecx, [eax+8]
.text$mn:00001B4D                 push    ecx             ; hWnd
.text$mn:00001B4E                 call    dword ptr ds:__imp__SendMessageW@16 ; SendMessageW(x,x,x,x)
.text$mn:00001B54                 mov     [ebp+lParam], eax
.text$mn:00001B57                 mov     edx, [ebp+lParam]
.text$mn:00001B5A                 push    edx             ; lParam
.text$mn:00001B5B                 push    0               ; wParam
.text$mn:00001B5D                 push    425h            ; Msg
.text$mn:00001B62                 mov     eax, [ebp+this]
.text$mn:00001B65                 mov     ecx, [eax+8]
.text$mn:00001B68                 push    ecx             ; hWnd
.text$mn:00001B69                 call    dword ptr ds:__imp__SendMessageW@16 ; SendMessageW(x,x,x,x)
.text$mn:00001B6F                 mov     edx, [ebp+this]
.text$mn:00001B72                 mov     [edx+70h], eax
.text$mn:00001B75                 push    0               ; __int32
.text$mn:00001B77                 push    0FFFFFFF6h      ; unsigned int
.text$mn:00001B79                 push    945h            ; unsigned int
.text$mn:00001B7E                 mov     eax, [ebp+this]
.text$mn:00001B81                 mov     ecx, [eax+70h]  ; this
.text$mn:00001B84                 call    ?execute@ScintillaEditView@@QBEJIIJ@Z ; ScintillaEditView::execute(uint,uint,long)
.text$mn:00001B89                 push    0               ; __int32
.text$mn:00001B8B                 push    0               ; unsigned int
.text$mn:00001B8D                 push    8E8h            ; unsigned int
.text$mn:00001B92                 mov     ecx, [ebp+this]
.text$mn:00001B95                 mov     ecx, [ecx+70h]  ; this
.text$mn:00001B98                 call    ?execute@ScintillaEditView@@QBEJIIJ@Z ; ScintillaEditView::execute(uint,uint,long)
.text$mn:00001B9D                 push    0               ; __int32
.text$mn:00001B9F                 push    0               ; unsigned int
.text$mn:00001BA1                 push    852h            ; unsigned int
.text$mn:00001BA6                 mov     edx, [ebp+this]
.text$mn:00001BA9                 mov     ecx, [edx+70h]  ; this
.text$mn:00001BAC                 call    ?execute@ScintillaEditView@@QBEJIIJ@Z ; ScintillaEditView::execute(uint,uint,long)
.text$mn:00001BB1                 push    0               ; bool
.text$mn:00001BB3                 mov     eax, [ebp+this]
.text$mn:00001BB6                 mov     ecx, [eax+70h]  ; this
.text$mn:00001BB9                 call    ?showIndentGuideLine@ScintillaEditView@@QAEX_N@Z ; ScintillaEditView::showIndentGuideLine(bool)
.text$mn:00001BBE                 push    1
.text$mn:00001BC0                 mov     ecx, [ebp+this]
.text$mn:00001BC3                 mov     edx, [ecx+70h]
.text$mn:00001BC6                 mov     eax, [ebp+this]
.text$mn:00001BC9                 mov     edx, [edx]
.text$mn:00001BCB                 mov     ecx, [eax+70h]
.text$mn:00001BCE                 mov     eax, [edx+0Ch]
.text$mn:00001BD1                 call    eax
.text$mn:00001BD3                 mov     ecx, [ebp+this] ; this
.text$mn:00001BD6                 call    ?reloadMap@DocumentMap@@QAEXXZ ; DocumentMap::reloadMap(void)
.text$mn:00001BDB                 mov     ecx, [ebp+this]
.text$mn:00001BDE                 mov     edx, [ecx+0Ch]
.text$mn:00001BE1                 push    edx
.text$mn:00001BE2                 push    0               ; lpModuleName
.text$mn:00001BE4                 call    dword ptr ds:__imp__GetModuleHandleW@4 ; GetModuleHandleW(x)
.text$mn:00001BEA                 push    eax
.text$mn:00001BEB                 mov     ecx, [ebp+this]
.text$mn:00001BEE                 add     ecx, 74h ; 't'
.text$mn:00001BF1                 mov     eax, [ebp+this]
.text$mn:00001BF4                 mov     edx, [eax+74h]
.text$mn:00001BF7                 mov     eax, [edx+4]
.text$mn:00001BFA                 call    eax
.text$mn:00001BFC                 mov     ecx, [ebp+this]
.text$mn:00001BFF                 add     ecx, 74h ; 't'  ; this
.text$mn:00001C02                 call    ?doDialog@ViewZoneDlg@@QAEXXZ ; ViewZoneDlg::doDialog(void)
.text$mn:00001C07                 push    32h ; '2'       ; int
.text$mn:00001C09                 mov     ecx, [ebp+this]
.text$mn:00001C0C                 add     ecx, 74h ; 't'  ; this
.text$mn:00001C0F                 call    ?getHSelf@Window@@QBEPAUHWND__@@XZ ; Window::getHSelf(void)
.text$mn:00001C14                 push    eax             ; hWnd
.text$mn:00001C15                 call    ?getInstance@NppParameters@@SAPAV1@XZ ; NppParameters::getInstance(void)
.text$mn:00001C1A                 mov     ecx, eax        ; this
.text$mn:00001C1C                 call    ?SetTransparent@NppParameters@@QAEXPAUHWND__@@H@Z ; NppParameters::SetTransparent(HWND__ *,int)
.text$mn:00001C21                 mov     ecx, [ebp+this] ; this
.text$mn:00001C24                 call    ?setSyntaxHiliting@DocumentMap@@QAEXXZ ; DocumentMap::setSyntaxHiliting(void)
.text$mn:00001C29                 push    0               ; bool
.text$mn:00001C2B                 push    0               ; unsigned int
.text$mn:00001C2D                 mov     ecx, [ebp+this]
.text$mn:00001C30                 mov     ecx, [ecx+70h]  ; this
.text$mn:00001C33                 call    ?showMargin@ScintillaEditView@@QAEXH_N@Z ; ScintillaEditView::showMargin(int,bool)
.text$mn:00001C38                 push    0               ; bool
.text$mn:00001C3A                 push    1               ; unsigned int
.text$mn:00001C3C                 mov     edx, [ebp+this]
.text$mn:00001C3F                 mov     ecx, [edx+70h]  ; this
.text$mn:00001C42                 call    ?showMargin@ScintillaEditView@@QAEXH_N@Z ; ScintillaEditView::showMargin(int,bool)
.text$mn:00001C47                 push    0               ; bool
.text$mn:00001C49                 push    2               ; unsigned int
.text$mn:00001C4B                 mov     eax, [ebp+this]
.text$mn:00001C4E                 mov     ecx, [eax+70h]  ; this
.text$mn:00001C51                 call    ?showMargin@ScintillaEditView@@QAEXH_N@Z ; ScintillaEditView::showMargin(int,bool)
.text$mn:00001C56                 push    0               ; bool
.text$mn:00001C58                 push    3               ; unsigned int
.text$mn:00001C5A                 mov     ecx, [ebp+this]
.text$mn:00001C5D                 mov     ecx, [ecx+70h]  ; this
.text$mn:00001C60                 call    ?showMargin@ScintillaEditView@@QAEXH_N@Z ; ScintillaEditView::showMargin(int,bool)
.text$mn:00001C65                 mov     eax, 1
.text$mn:00001C6A                 jmp     loc_1F7D
.text$mn:00001C6F ; ---------------------------------------------------------------------------
.text$mn:00001C6F
.text$mn:00001C6F loc_1C6F:                               ; CODE XREF: DocumentMap::run_dlgProc(uint,uint,long)+30j
.text$mn:00001C6F                 mov     edx, [ebp+this]
.text$mn:00001C72                 cmp     dword ptr [edx+70h], 0
.text$mn:00001C76                 jz      loc_1D29
.text$mn:00001C7C                 mov     eax, [ebp+arg_C]
.text$mn:00001C7F                 and     eax, 0FFFFh
.text$mn:00001C84                 movzx   ecx, ax
.text$mn:00001C87                 mov     [ebp+nWidth], ecx
.text$mn:00001C8A                 mov     edx, [ebp+arg_C]
.text$mn:00001C8D                 shr     edx, 10h
.text$mn:00001C90                 and     edx, 0FFFFh
.text$mn:00001C96                 movzx   eax, dx
.text$mn:00001C99                 mov     [ebp+nHeight], eax
.text$mn:00001C9C                 mov     ecx, [ebp+this]
.text$mn:00001C9F                 add     ecx, 74h ; 't'
.text$mn:00001CA2                 mov     edx, [ebp+this]
.text$mn:00001CA5                 mov     eax, [edx+74h]
.text$mn:00001CA8                 mov     edx, [eax+34h]
.text$mn:00001CAB                 call    edx
.text$mn:00001CAD                 movzx   eax, al
.text$mn:00001CB0                 test    eax, eax
.text$mn:00001CB2                 jz      short loc_1D29
.text$mn:00001CB4                 mov     [ebp+Point.x], 0
.text$mn:00001CBB                 mov     [ebp+Point.y], 0
.text$mn:00001CC2                 lea     ecx, [ebp+Point]
.text$mn:00001CC5                 push    ecx             ; lpPoint
.text$mn:00001CC6                 mov     edx, [ebp+this]
.text$mn:00001CC9                 mov     eax, [edx+0Ch]
.text$mn:00001CCC                 push    eax             ; hWnd
.text$mn:00001CCD                 call    dword ptr ds:__imp__ClientToScreen@8 ; ClientToScreen(x,x)
.text$mn:00001CD3                 mov     ecx, [ebp+this]
.text$mn:00001CD6                 mov     ecx, [ecx+70h]  ; this
.text$mn:00001CD9                 call    ?isWrap@ScintillaEditView@@QBE_NXZ ; ScintillaEditView::isWrap(void)
.text$mn:00001CDE                 movzx   edx, al
.text$mn:00001CE1                 test    edx, edx
.text$mn:00001CE3                 jnz     short loc_1D05
.text$mn:00001CE5                 push    1               ; bRepaint
.text$mn:00001CE7                 mov     eax, [ebp+nHeight]
.text$mn:00001CEA                 push    eax             ; nHeight
.text$mn:00001CEB                 mov     ecx, [ebp+nWidth]
.text$mn:00001CEE                 push    ecx             ; nWidth
.text$mn:00001CEF                 push    0               ; Y
.text$mn:00001CF1                 push    0               ; X
.text$mn:00001CF3                 mov     edx, [ebp+this]
.text$mn:00001CF6                 mov     ecx, [edx+70h]  ; this
.text$mn:00001CF9                 call    ?getHSelf@Window@@QBEPAUHWND__@@XZ ; Window::getHSelf(void)
.text$mn:00001CFE                 push    eax             ; hWnd
.text$mn:00001CFF                 call    dword ptr ds:__imp__MoveWindow@24 ; MoveWindow(x,x,x,x,x,x)
.text$mn:00001D05
.text$mn:00001D05 loc_1D05:                               ; CODE XREF: DocumentMap::run_dlgProc(uint,uint,long)+217j
.text$mn:00001D05                 push    1               ; bRepaint
.text$mn:00001D07                 mov     eax, [ebp+nHeight]
.text$mn:00001D0A                 push    eax             ; nHeight
.text$mn:00001D0B                 mov     ecx, [ebp+nWidth]
.text$mn:00001D0E                 push    ecx             ; nWidth
.text$mn:00001D0F                 mov     edx, [ebp+Point.y]
.text$mn:00001D12                 push    edx             ; Y
.text$mn:00001D13                 mov     eax, [ebp+Point.x]
.text$mn:00001D16                 push    eax             ; X
.text$mn:00001D17                 mov     ecx, [ebp+this]
.text$mn:00001D1A                 add     ecx, 74h ; 't'  ; this
.text$mn:00001D1D                 call    ?getHSelf@Window@@QBEPAUHWND__@@XZ ; Window::getHSelf(void)
.text$mn:00001D22                 push    eax             ; hWnd
.text$mn:00001D23                 call    dword ptr ds:__imp__MoveWindow@24 ; MoveWindow(x,x,x,x,x,x)
.text$mn:00001D29
.text$mn:00001D29 loc_1D29:                               ; CODE XREF: DocumentMap::run_dlgProc(uint,uint,long)+1AAj
.text$mn:00001D29                                         ; DocumentMap::run_dlgProc(uint,uint,long)+1E6j
.text$mn:00001D29                 jmp     loc_1F68
.text$mn:00001D2E ; ---------------------------------------------------------------------------
.text$mn:00001D2E
.text$mn:00001D2E loc_1D2E:                               ; CODE XREF: DocumentMap::run_dlgProc(uint,uint,long)+3Aj
.text$mn:00001D2E                 mov     ecx, [ebp+arg_C]
.text$mn:00001D31                 mov     edx, [ecx+8]
.text$mn:00001D34                 mov     [ebp+var_20], edx
.text$mn:00001D37                 cmp     [ebp+var_20], 41Eh
.text$mn:00001D3E                 ja      short loc_1D57
.text$mn:00001D40                 cmp     [ebp+var_20], 41Eh
.text$mn:00001D47                 jz      short loc_1D9B
.text$mn:00001D49                 cmp     [ebp+var_20], 41Bh
.text$mn:00001D50                 jz      short loc_1D78
.text$mn:00001D52                 jmp     loc_1E67
.text$mn:00001D57 ; ---------------------------------------------------------------------------
.text$mn:00001D57
.text$mn:00001D57 loc_1D57:                               ; CODE XREF: DocumentMap::run_dlgProc(uint,uint,long)+272j
.text$mn:00001D57                 cmp     [ebp+var_20], 41Fh
.text$mn:00001D5E                 jz      short loc_1DC8
.text$mn:00001D60                 cmp     [ebp+var_20], 420h
.text$mn:00001D67                 jz      short loc_1DE5
.text$mn:00001D69                 cmp     [ebp+var_20], 0FFFFFFFDh
.text$mn:00001D6D                 jz      loc_1E5D
.text$mn:00001D73                 jmp     loc_1E67
.text$mn:00001D78 ; ---------------------------------------------------------------------------
.text$mn:00001D78
.text$mn:00001D78 loc_1D78:                               ; CODE XREF: DocumentMap::run_dlgProc(uint,uint,long)+284j
.text$mn:00001D78                 push    0               ; lParam
.text$mn:00001D7A                 push    0AC30h          ; wParam
.text$mn:00001D7F                 push    111h            ; Msg
.text$mn:00001D84                 mov     eax, [ebp+this]
.text$mn:00001D87                 mov     ecx, [eax+8]
.text$mn:00001D8A                 push    ecx             ; hWnd
.text$mn:00001D8B                 call    dword ptr ds:__imp__SendMessageW@16 ; SendMessageW(x,x,x,x)
.text$mn:00001D91                 mov     eax, 1
.text$mn:00001D96                 jmp     loc_1F7D
.text$mn:00001D9B ; ---------------------------------------------------------------------------
.text$mn:00001D9B
.text$mn:00001D9B loc_1D9B:                               ; CODE XREF: DocumentMap::run_dlgProc(uint,uint,long)+27Bj
.text$mn:00001D9B                 push    1
.text$mn:00001D9D                 mov     ecx, [ebp+this]
.text$mn:00001DA0                 add     ecx, 74h ; 't'
.text$mn:00001DA3                 mov     edx, [ebp+this]
.text$mn:00001DA6                 mov     eax, [edx+74h]
.text$mn:00001DA9                 mov     edx, [eax+0Ch]
.text$mn:00001DAC                 call    edx
.text$mn:00001DAE                 mov     ecx, [ebp+this] ; this
.text$mn:00001DB1                 call    ?reloadMap@DocumentMap@@QAEXXZ ; DocumentMap::reloadMap(void)
.text$mn:00001DB6                 mov     ecx, [ebp+this] ; this
.text$mn:00001DB9                 call    ?setSyntaxHiliting@DocumentMap@@QAEXXZ ; DocumentMap::setSyntaxHiliting(void)
.text$mn:00001DBE                 mov     eax, 1
.text$mn:00001DC3                 jmp     loc_1F7D
.text$mn:00001DC8 ; ---------------------------------------------------------------------------
.text$mn:00001DC8
.text$mn:00001DC8 loc_1DC8:                               ; CODE XREF: DocumentMap::run_dlgProc(uint,uint,long)+292j
.text$mn:00001DC8                 push    0
.text$mn:00001DCA                 mov     ecx, [ebp+this]
.text$mn:00001DCD                 add     ecx, 74h ; 't'
.text$mn:00001DD0                 mov     eax, [ebp+this]
.text$mn:00001DD3                 mov     edx, [eax+74h]
.text$mn:00001DD6                 mov     eax, [edx+0Ch]
.text$mn:00001DD9                 call    eax
.text$mn:00001DDB                 mov     eax, 1
.text$mn:00001DE0                 jmp     loc_1F7D
.text$mn:00001DE5 ; ---------------------------------------------------------------------------
.text$mn:00001DE5
.text$mn:00001DE5 loc_1DE5:                               ; CODE XREF: DocumentMap::run_dlgProc(uint,uint,long)+29Bj
.text$mn:00001DE5                 lea     ecx, [ebp+var_14]
.text$mn:00001DE8                 push    ecx
.text$mn:00001DE9                 mov     edx, [ebp+this]
.text$mn:00001DEC                 mov     eax, [edx]
.text$mn:00001DEE                 mov     ecx, [ebp+this]
.text$mn:00001DF1                 mov     edx, [eax+1Ch]
.text$mn:00001DF4                 call    edx
.text$mn:00001DF6                 mov     eax, [ebp+var_C]
.text$mn:00001DF9                 sub     eax, [ebp+var_14]
.text$mn:00001DFC                 mov     [ebp+var_44], eax
.text$mn:00001DFF                 mov     ecx, [ebp+var_8]
.text$mn:00001E02                 sub     ecx, [ebp+var_10]
.text$mn:00001E05                 mov     [ebp+var_54], ecx
.text$mn:00001E08                 mov     [ebp+var_40.x], 0
.text$mn:00001E0F                 mov     [ebp+var_40.y], 0
.text$mn:00001E16                 lea     edx, [ebp+var_40]
.text$mn:00001E19                 push    edx             ; lpPoint
.text$mn:00001E1A                 mov     eax, [ebp+this]
.text$mn:00001E1D                 mov     ecx, [eax+0Ch]
.text$mn:00001E20                 push    ecx             ; hWnd
.text$mn:00001E21                 call    dword ptr ds:__imp__ClientToScreen@8 ; ClientToScreen(x,x)
.text$mn:00001E27                 push    1               ; bRepaint
.text$mn:00001E29                 mov     edx, [ebp+var_54]
.text$mn:00001E2C                 push    edx             ; nHeight
.text$mn:00001E2D                 mov     eax, [ebp+var_44]
.text$mn:00001E30                 push    eax             ; nWidth
.text$mn:00001E31                 mov     ecx, [ebp+var_40.y]
.text$mn:00001E34                 push    ecx             ; Y
.text$mn:00001E35                 mov     edx, [ebp+var_40.x]
.text$mn:00001E38                 push    edx             ; X
.text$mn:00001E39                 mov     ecx, [ebp+this]
.text$mn:00001E3C                 add     ecx, 74h ; 't'  ; this
.text$mn:00001E3F                 call    ?getHSelf@Window@@QBEPAUHWND__@@XZ ; Window::getHSelf(void)
.text$mn:00001E44                 push    eax             ; hWnd
.text$mn:00001E45                 call    dword ptr ds:__imp__MoveWindow@24 ; MoveWindow(x,x,x,x,x,x)
.text$mn:00001E4B                 mov     ecx, [ebp+this] ; this
.text$mn:00001E4E                 call    ?scrollMap@DocumentMap@@QAEXXZ ; DocumentMap::scrollMap(void)
.text$mn:00001E53                 mov     eax, 1
.text$mn:00001E58                 jmp     loc_1F7D
.text$mn:00001E5D ; ---------------------------------------------------------------------------
.text$mn:00001E5D
.text$mn:00001E5D loc_1E5D:                               ; CODE XREF: DocumentMap::run_dlgProc(uint,uint,long)+2A1j
.text$mn:00001E5D                 mov     eax, 1
.text$mn:00001E62                 jmp     loc_1F7D
.text$mn:00001E67 ; ---------------------------------------------------------------------------
.text$mn:00001E67
.text$mn:00001E67 loc_1E67:                               ; CODE XREF: DocumentMap::run_dlgProc(uint,uint,long)+286j
.text$mn:00001E67                                         ; DocumentMap::run_dlgProc(uint,uint,long)+2A7j
.text$mn:00001E67                 mov     eax, 1
.text$mn:00001E6C                 jmp     loc_1F7D
.text$mn:00001E71 ; ---------------------------------------------------------------------------
.text$mn:00001E71
.text$mn:00001E71 loc_1E71:                               ; CODE XREF: DocumentMap::run_dlgProc(uint,uint,long)+26j
.text$mn:00001E71                 cmp     [ebp+arg_8], 0
.text$mn:00001E75                 jz      short loc_1E80
.text$mn:00001E77                 mov     [ebp+var_2C], 1
.text$mn:00001E7E                 jmp     short loc_1E87
.text$mn:00001E80 ; ---------------------------------------------------------------------------
.text$mn:00001E80
.text$mn:00001E80 loc_1E80:                               ; CODE XREF: DocumentMap::run_dlgProc(uint,uint,long)+3A9j
.text$mn:00001E80                 mov     [ebp+var_2C], 0
.text$mn:00001E87
.text$mn:00001E87 loc_1E87:                               ; CODE XREF: DocumentMap::run_dlgProc(uint,uint,long)+3B2j
.text$mn:00001E87                 mov     al, byte ptr [ebp+var_2C]
.text$mn:00001E8A                 mov     [ebp+var_19], al
.text$mn:00001E8D                 cmp     [ebp+arg_C], 0
.text$mn:00001E91                 jnz     short loc_1E9C
.text$mn:00001E93                 mov     [ebp+var_30], 0
.text$mn:00001E9A                 jmp     short loc_1EA3
.text$mn:00001E9C ; ---------------------------------------------------------------------------
.text$mn:00001E9C
.text$mn:00001E9C loc_1E9C:                               ; CODE XREF: DocumentMap::run_dlgProc(uint,uint,long)+3C5j
.text$mn:00001E9C                 mov     [ebp+var_30], 1
.text$mn:00001EA3
.text$mn:00001EA3 loc_1EA3:                               ; CODE XREF: DocumentMap::run_dlgProc(uint,uint,long)+3CEj
.text$mn:00001EA3                 mov     ecx, [ebp+var_30]
.text$mn:00001EA6                 mov     [ebp+var_64], ecx
.text$mn:00001EA9                 mov     edx, [ebp+var_64]
.text$mn:00001EAC                 push    edx
.text$mn:00001EAD                 movzx   eax, [ebp+var_19]
.text$mn:00001EB1                 push    eax
.text$mn:00001EB2                 mov     ecx, [ebp+this]
.text$mn:00001EB5                 call    ?scrollMap@DocumentMap@@QAEX_NW4moveMode@@@Z ; DocumentMap::scrollMap(bool,moveMode)
.text$mn:00001EBA                 mov     eax, 1
.text$mn:00001EBF                 jmp     loc_1F7D
.text$mn:00001EC4 ; ---------------------------------------------------------------------------
.text$mn:00001EC4
.text$mn:00001EC4 loc_1EC4:                               ; CODE XREF: DocumentMap::run_dlgProc(uint,uint,long)+55j
.text$mn:00001EC4                 mov     ecx, [ebp+arg_C]
.text$mn:00001EC7                 shr     ecx, 10h
.text$mn:00001ECA                 and     ecx, 0FFFFh
.text$mn:00001ED0                 movzx   edx, cx
.text$mn:00001ED3                 mov     [ebp+var_58], edx
.text$mn:00001ED6                 mov     ecx, [ebp+this]
.text$mn:00001ED9                 add     ecx, 74h ; 't'  ; this
.text$mn:00001EDC                 call    ?getCurrentCenterPosY@ViewZoneDlg@@QBEHXZ ; ViewZoneDlg::getCurrentCenterPosY(void)
.text$mn:00001EE1                 mov     [ebp+var_50], eax
.text$mn:00001EE4                 push    0               ; __int32
.text$mn:00001EE6                 push    0               ; unsigned int
.text$mn:00001EE8                 push    8E7h            ; unsigned int
.text$mn:00001EED                 mov     eax, [ebp+this]
.text$mn:00001EF0                 mov     ecx, [eax+70h]  ; this
.text$mn:00001EF3                 call    ?execute@ScintillaEditView@@QBEJIIJ@Z ; ScintillaEditView::execute(uint,uint,long)
.text$mn:00001EF8                 mov     [ebp+var_48], eax
.text$mn:00001EFB                 mov     ecx, [ebp+var_58]
.text$mn:00001EFE                 sub     ecx, [ebp+var_50]
.text$mn:00001F01                 mov     [ebp+var_60], ecx
.text$mn:00001F04                 mov     eax, [ebp+var_60]
.text$mn:00001F07                 cdq
.text$mn:00001F08                 idiv    [ebp+var_48]
.text$mn:00001F0B                 mov     [ebp+var_4C], eax
.text$mn:00001F0E                 mov     edx, [ebp+var_4C]
.text$mn:00001F11                 push    edx             ; __int32
.text$mn:00001F12                 push    0               ; unsigned int
.text$mn:00001F14                 push    878h            ; unsigned int
.text$mn:00001F19                 mov     eax, [ebp+this]
.text$mn:00001F1C                 mov     ecx, [eax+6Ch]
.text$mn:00001F1F                 mov     ecx, [ecx]      ; this
.text$mn:00001F21                 call    ?execute@ScintillaEditView@@QBEJIIJ@Z ; ScintillaEditView::execute(uint,uint,long)
.text$mn:00001F26                 mov     ecx, [ebp+this] ; this
.text$mn:00001F29                 call    ?scrollMap@DocumentMap@@QAEXXZ ; DocumentMap::scrollMap(void)
.text$mn:00001F2E                 mov     eax, 1
.text$mn:00001F33                 jmp     short loc_1F7D
.text$mn:00001F35 ; ---------------------------------------------------------------------------
.text$mn:00001F35
.text$mn:00001F35 loc_1F35:                               ; CODE XREF: DocumentMap::run_dlgProc(uint,uint,long)+62j
.text$mn:00001F35                 mov     edx, [ebp+arg_C]
.text$mn:00001F38                 push    edx             ; __int32
.text$mn:00001F39                 mov     eax, [ebp+arg_8]
.text$mn:00001F3C                 push    eax             ; unsigned int
.text$mn:00001F3D                 mov     ecx, [ebp+this]
.text$mn:00001F40                 mov     edx, [ecx+6Ch]
.text$mn:00001F43                 mov     ecx, [edx]      ; this
.text$mn:00001F45                 call    ?mouseWheel@ScintillaEditView@@QAEXIJ@Z ; ScintillaEditView::mouseWheel(uint,long)
.text$mn:00001F4A                 mov     eax, 1
.text$mn:00001F4F                 jmp     short loc_1F7D
.text$mn:00001F51 ; ---------------------------------------------------------------------------
.text$mn:00001F51
.text$mn:00001F51 loc_1F51:                               ; CODE XREF: DocumentMap::run_dlgProc(uint,uint,long)+49j
.text$mn:00001F51                                         ; DocumentMap::run_dlgProc(uint,uint,long)+68j
.text$mn:00001F51                 mov     eax, [ebp+arg_C]
.text$mn:00001F54                 push    eax             ; __int32
.text$mn:00001F55                 mov     ecx, [ebp+arg_8]
.text$mn:00001F58                 push    ecx             ; unsigned int
.text$mn:00001F59                 mov     edx, [ebp+arg_4]
.text$mn:00001F5C                 push    edx             ; unsigned int
.text$mn:00001F5D                 mov     eax, [ebp+this]
.text$mn:00001F60                 push    eax             ; this
.text$mn:00001F61                 call    ?run_dlgProc@DockingDlgInterface@@MAGHIIJ@Z ; DockingDlgInterface::run_dlgProc(uint,uint,long)
.text$mn:00001F66                 jmp     short loc_1F7D
.text$mn:00001F68 ; ---------------------------------------------------------------------------
.text$mn:00001F68
.text$mn:00001F68 loc_1F68:                               ; CODE XREF: DocumentMap::run_dlgProc(uint,uint,long):loc_1D29j
.text$mn:00001F68                 mov     ecx, [ebp+arg_C]
.text$mn:00001F6B                 push    ecx             ; __int32
.text$mn:00001F6C                 mov     edx, [ebp+arg_8]
.text$mn:00001F6F                 push    edx             ; unsigned int
.text$mn:00001F70                 mov     eax, [ebp+arg_4]
.text$mn:00001F73                 push    eax             ; unsigned int
.text$mn:00001F74                 mov     ecx, [ebp+this]
.text$mn:00001F77                 push    ecx             ; this
.text$mn:00001F78                 call    ?run_dlgProc@DockingDlgInterface@@MAGHIIJ@Z ; DockingDlgInterface::run_dlgProc(uint,uint,long)
.text$mn:00001F7D
.text$mn:00001F7D loc_1F7D:                               ; CODE XREF: DocumentMap::run_dlgProc(uint,uint,long)+19Ej
.text$mn:00001F7D                                         ; DocumentMap::run_dlgProc(uint,uint,long)+2CAj ...
.text$mn:00001F7D                 mov     ecx, [ebp+var_4]
.text$mn:00001F80                 xor     ecx, ebp
.text$mn:00001F82                 call    @__security_check_cookie@4 ; __security_check_cookie(x)
.text$mn:00001F87                 mov     esp, ebp
.text$mn:00001F89                 pop     ebp
.text$mn:00001F8A                 retn    10h
.text$mn:00001F8A ?run_dlgProc@DocumentMap@@MAGHIIJ@Z endp
.text$mn:00001F8A
.text$mn:00001F8A ; ---------------------------------------------------------------------------
.text$mn:00001F8D                 db 0Fh dup(0CCh)
.text$mn:00001F9C
.text$mn:00001F9C ; =============== S U B R O U T I N E =======================================
.text$mn:00001F9C
.text$mn:00001F9C ; Attributes: bp-based frame
.text$mn:00001F9C
.text$mn:00001F9C ; bool __thiscall DocumentMap::needToRecomputeWith(DocumentMap *__hidden this)
.text$mn:00001F9C                 public ?needToRecomputeWith@DocumentMap@@IAE_NXZ
.text$mn:00001F9C ?needToRecomputeWith@DocumentMap@@IAE_NXZ proc near
.text$mn:00001F9C                                         ; CODE XREF: DocumentMap::reloadMap(void)+D6p
.text$mn:00001F9C
.text$mn:00001F9C var_C           = dword ptr -0Ch
.text$mn:00001F9C var_8           = dword ptr -8
.text$mn:00001F9C var_4           = dword ptr -4
.text$mn:00001F9C
.text$mn:00001F9C                 push    ebp
.text$mn:00001F9D                 mov     ebp, esp
.text$mn:00001F9F                 sub     esp, 0Ch
.text$mn:00001FA2                 mov     [ebp+var_4], ecx
.text$mn:00001FA5                 push    0               ; __int32
.text$mn:00001FA7                 push    0               ; unsigned int
.text$mn:00001FA9                 push    946h            ; unsigned int
.text$mn:00001FAE                 mov     eax, [ebp+var_4]
.text$mn:00001FB1                 mov     ecx, [eax+6Ch]
.text$mn:00001FB4                 mov     ecx, [ecx]      ; this
.text$mn:00001FB6                 call    ?execute@ScintillaEditView@@QBEJIIJ@Z ; ScintillaEditView::execute(uint,uint,long)
.text$mn:00001FBB                 mov     [ebp+var_8], eax
.text$mn:00001FBE                 mov     edx, [ebp+var_4]
.text$mn:00001FC1                 mov     eax, [edx+0A4h]
.text$mn:00001FC7                 cmp     eax, [ebp+var_8]
.text$mn:00001FCA                 jz      short loc_1FD0
.text$mn:00001FCC                 mov     al, 1
.text$mn:00001FCE                 jmp     short loc_1FEF
.text$mn:00001FD0 ; ---------------------------------------------------------------------------
.text$mn:00001FD0
.text$mn:00001FD0 loc_1FD0:                               ; CODE XREF: DocumentMap::needToRecomputeWith(void)+2Ej
.text$mn:00001FD0                 mov     ecx, [ebp+var_4] ; this
.text$mn:00001FD3                 call    ?getEditorTextZoneWidth@DocumentMap@@IAEHXZ ; DocumentMap::getEditorTextZoneWidth(void)
.text$mn:00001FD8                 mov     [ebp+var_C], eax
.text$mn:00001FDB                 mov     ecx, [ebp+var_4]
.text$mn:00001FDE                 mov     edx, [ecx+0A8h]
.text$mn:00001FE4                 cmp     edx, [ebp+var_C]
.text$mn:00001FE7                 jz      short loc_1FED
.text$mn:00001FE9                 mov     al, 1
.text$mn:00001FEB                 jmp     short loc_1FEF
.text$mn:00001FED ; ---------------------------------------------------------------------------
.text$mn:00001FED
.text$mn:00001FED loc_1FED:                               ; CODE XREF: DocumentMap::needToRecomputeWith(void)+4Bj
.text$mn:00001FED                 xor     al, al
.text$mn:00001FEF
.text$mn:00001FEF loc_1FEF:                               ; CODE XREF: DocumentMap::needToRecomputeWith(void)+32j
.text$mn:00001FEF                                         ; DocumentMap::needToRecomputeWith(void)+4Fj
.text$mn:00001FEF                 mov     esp, ebp
.text$mn:00001FF1                 pop     ebp
.text$mn:00001FF2                 retn
.text$mn:00001FF2 ?needToRecomputeWith@DocumentMap@@IAE_NXZ endp
.text$mn:00001FF2
.text$mn:00001FF2 ; ---------------------------------------------------------------------------
.text$mn:00001FF3                 db 9 dup(0CCh)
.text$mn:00001FFC
.text$mn:00001FFC ; =============== S U B R O U T I N E =======================================
.text$mn:00001FFC
.text$mn:00001FFC ; Attributes: bp-based frame
.text$mn:00001FFC
.text$mn:00001FFC ; int __thiscall DocumentMap::getEditorTextZoneWidth(DocumentMap *__hidden this)
.text$mn:00001FFC                 public ?getEditorTextZoneWidth@DocumentMap@@IAEHXZ
.text$mn:00001FFC ?getEditorTextZoneWidth@DocumentMap@@IAEHXZ proc near
.text$mn:00001FFC                                         ; CODE XREF: DocumentMap::wrapMap(void)+3Fp
.text$mn:00001FFC                                         ; DocumentMap::needToRecomputeWith(void)+37p
.text$mn:00001FFC
.text$mn:00001FFC var_20          = dword ptr -20h
.text$mn:00001FFC var_1C          = dword ptr -1Ch
.text$mn:00001FFC var_18          = dword ptr -18h
.text$mn:00001FFC var_14          = dword ptr -14h
.text$mn:00001FFC var_C           = dword ptr -0Ch
.text$mn:00001FFC var_4           = dword ptr -4
.text$mn:00001FFC
.text$mn:00001FFC                 push    ebp
.text$mn:00001FFD                 mov     ebp, esp
.text$mn:00001FFF                 sub     esp, 20h
.text$mn:00002002                 mov     eax, dword ptr ds:___security_cookie
.text$mn:00002007                 xor     eax, ebp
.text$mn:00002009                 mov     [ebp+var_4], eax
.text$mn:0000200C                 mov     [ebp+var_1C], ecx
.text$mn:0000200F                 lea     eax, [ebp+var_14]
.text$mn:00002012                 push    eax
.text$mn:00002013                 mov     ecx, [ebp+var_1C]
.text$mn:00002016                 mov     edx, [ecx+6Ch]
.text$mn:00002019                 mov     eax, [edx]
.text$mn:0000201B                 mov     ecx, [ebp+var_1C]
.text$mn:0000201E                 mov     edx, [ecx+6Ch]
.text$mn:00002021                 mov     eax, [eax]
.text$mn:00002023                 mov     ecx, [edx]
.text$mn:00002025                 mov     edx, [eax+1Ch]
.text$mn:00002028                 call    edx
.text$mn:0000202A                 mov     [ebp+var_20], 0
.text$mn:00002031                 mov     [ebp+var_18], 0
.text$mn:00002038                 jmp     short loc_2043
.text$mn:0000203A ; ---------------------------------------------------------------------------
.text$mn:0000203A
.text$mn:0000203A loc_203A:                               ; CODE XREF: DocumentMap::getEditorTextZoneWidth(void)+6Bj
.text$mn:0000203A                 mov     eax, [ebp+var_18]
.text$mn:0000203D                 add     eax, 1
.text$mn:00002040                 mov     [ebp+var_18], eax
.text$mn:00002043
.text$mn:00002043 loc_2043:                               ; CODE XREF: DocumentMap::getEditorTextZoneWidth(void)+3Cj
.text$mn:00002043                 cmp     [ebp+var_18], 4
.text$mn:00002047                 jge     short loc_2069
.text$mn:00002049                 push    0               ; __int32
.text$mn:0000204B                 mov     ecx, [ebp+var_18]
.text$mn:0000204E                 push    ecx             ; unsigned int
.text$mn:0000204F                 push    8C3h            ; unsigned int
.text$mn:00002054                 mov     edx, [ebp+var_1C]
.text$mn:00002057                 mov     eax, [edx+6Ch]
.text$mn:0000205A                 mov     ecx, [eax]      ; this
.text$mn:0000205C                 call    ?execute@ScintillaEditView@@QBEJIIJ@Z ; ScintillaEditView::execute(uint,uint,long)
.text$mn:00002061                 add     eax, [ebp+var_20]
.text$mn:00002064                 mov     [ebp+var_20], eax
.text$mn:00002067                 jmp     short loc_203A
.text$mn:00002069 ; ---------------------------------------------------------------------------
.text$mn:00002069
.text$mn:00002069 loc_2069:                               ; CODE XREF: DocumentMap::getEditorTextZoneWidth(void)+4Bj
.text$mn:00002069                 mov     eax, [ebp+var_C]
.text$mn:0000206C                 sub     eax, [ebp+var_14]
.text$mn:0000206F                 sub     eax, [ebp+var_20]
.text$mn:00002072                 mov     ecx, [ebp+var_4]
.text$mn:00002075                 xor     ecx, ebp
.text$mn:00002077                 call    @__security_check_cookie@4 ; __security_check_cookie(x)
.text$mn:0000207C                 mov     esp, ebp
.text$mn:0000207E                 pop     ebp
.text$mn:0000207F                 retn
.text$mn:0000207F ?getEditorTextZoneWidth@DocumentMap@@IAEHXZ endp
.text$mn:0000207F
.text$mn:0000207F _text$mn        ends
.text$mn:0000207F
.text$x:00002080 ; ===========================================================================
.text$x:00002080
.text$x:00002080 ; Segment type: Pure code
.text$x:00002080 ; Segment permissions: Read/Execute
.text$x:00002080 _text$x         segment para public 'CODE' use32
.text$x:00002080                 assume cs:_text$x
.text$x:00002080                 ;org 2080h
.text$x:00002080                 assume es:nothing, ss:nothing, ds:_data, fs:nothing, gs:nothing
.text$x:00002080
.text$x:00002080 ; =============== S U B R O U T I N E =======================================
.text$x:00002080
.text$x:00002080
.text$x:00002080 __unwindfunclet$?reloadMap@DocumentMap@@QAEXXZ$0 proc near
.text$x:00002080                                         ; DATA XREF: .xdata$x:00004660o
.text$x:00002080                 lea     ecx, [ebp-28h]
.text$x:00002083                 jmp     ??1?$vector@IV?$allocator@I@std@@@std@@QAE@XZ ; std::vector<uint,std::allocator<uint>>::~vector<uint,std::allocator<uint>>(void)
.text$x:00002083 __unwindfunclet$?reloadMap@DocumentMap@@QAEXXZ$0 endp
.text$x:00002083
.text$x:00002088
.text$x:00002088 ; =============== S U B R O U T I N E =======================================
.text$x:00002088
.text$x:00002088
.text$x:00002088 __ehhandler$?reloadMap@DocumentMap@@QAEXXZ proc near
.text$x:00002088                                         ; DATA XREF: DocumentMap::reloadMap(void)+5o
.text$x:00002088
.text$x:00002088 arg_4           = dword ptr  8
.text$x:00002088
.text$x:00002088                 mov     edx, [esp+arg_4]
.text$x:0000208C                 lea     eax, [edx+0Ch]
.text$x:0000208F                 mov     ecx, [edx-20h]
.text$x:00002092                 xor     ecx, eax
.text$x:00002094                 call    @__security_check_cookie@4 ; __security_check_cookie(x)
.text$x:00002099                 mov     eax, offset __ehfuncinfo$?reloadMap@DocumentMap@@QAEXXZ
.text$x:0000209E                 jmp     ___CxxFrameHandler3
.text$x:0000209E __ehhandler$?reloadMap@DocumentMap@@QAEXXZ endp
.text$x:0000209E
.text$x:0000209E ; ---------------------------------------------------------------------------
.text$x:000020A3                 align 4
.text$x:000020A3 _text$x         ends
.text$x:000020A3
.text$mn:000020A4 ; ===========================================================================
.text$mn:000020A4
.text$mn:000020A4 ; Segment type: Pure code
.text$mn:000020A4 ; Segment permissions: Read/Execute
.text$mn:000020A4 _text$mn        segment para public 'CODE' use32
.text$mn:000020A4                 assume cs:_text$mn
.text$mn:000020A4                 ;org 20A4h
.text$mn:000020A4 ; COMDAT (pick any)
.text$mn:000020A4                 assume es:nothing, ss:nothing, ds:_data, fs:nothing, gs:nothing
.text$mn:000020A4
.text$mn:000020A4 ; =============== S U B R O U T I N E =======================================
.text$mn:000020A4
.text$mn:000020A4 ; Attributes: bp-based frame
.text$mn:000020A4
.text$mn:000020A4 ; char * __cdecl std::_Allocate<char>(unsigned int, char *)
.text$mn:000020A4                 public ??$_Allocate@D@std@@YAPADIPAD@Z
.text$mn:000020A4 ??$_Allocate@D@std@@YAPADIPAD@Z proc near
.text$mn:000020A4                                         ; CODE XREF: std::allocator<char>::allocate(uint)+Dp
.text$mn:000020A4
.text$mn:000020A4 var_4           = dword ptr -4
.text$mn:000020A4 arg_0           = dword ptr  8
.text$mn:000020A4
.text$mn:000020A4                 push    ebp
.text$mn:000020A5                 mov     ebp, esp
.text$mn:000020A7                 push    ecx
.text$mn:000020A8                 mov     [ebp+var_4], 0
.text$mn:000020AF                 cmp     [ebp+arg_0], 0
.text$mn:000020B3                 jnz     short loc_20B7
.text$mn:000020B5                 jmp     short loc_20D7
.text$mn:000020B7 ; ---------------------------------------------------------------------------
.text$mn:000020B7
.text$mn:000020B7 loc_20B7:                               ; CODE XREF: std::_Allocate<char>(uint,char *)+Fj
.text$mn:000020B7                 cmp     [ebp+arg_0], 0FFFFFFFFh
.text$mn:000020BB                 ja      short loc_20D2
.text$mn:000020BD                 mov     eax, [ebp+arg_0]
.text$mn:000020C0                 push    eax             ; unsigned int
.text$mn:000020C1                 call    ??2@YAPAXI@Z    ; operator new(uint)
.text$mn:000020C6                 add     esp, 4
.text$mn:000020C9                 mov     [ebp+var_4], eax
.text$mn:000020CC                 cmp     [ebp+var_4], 0
.text$mn:000020D0                 jnz     short loc_20D7
.text$mn:000020D2
.text$mn:000020D2 loc_20D2:                               ; CODE XREF: std::_Allocate<char>(uint,char *)+17j
.text$mn:000020D2                 call    ?_Xbad_alloc@std@@YAXXZ ; std::_Xbad_alloc(void)
.text$mn:000020D7
.text$mn:000020D7 loc_20D7:                               ; CODE XREF: std::_Allocate<char>(uint,char *)+11j
.text$mn:000020D7                                         ; std::_Allocate<char>(uint,char *)+2Cj
.text$mn:000020D7                 mov     eax, [ebp+var_4]
.text$mn:000020DA                 mov     esp, ebp
.text$mn:000020DC                 pop     ebp
.text$mn:000020DD                 retn
.text$mn:000020DD ??$_Allocate@D@std@@YAPADIPAD@Z endp
.text$mn:000020DD
.text$mn:000020DD ; ---------------------------------------------------------------------------
.text$mn:000020DE                 align 10h
.text$mn:000020DE _text$mn        ends
.text$mn:000020DE
.text$mn:000020E0 ; ===========================================================================
.text$mn:000020E0
.text$mn:000020E0 ; Segment type: Pure code
.text$mn:000020E0 ; Segment permissions: Read/Execute
.text$mn:000020E0 _text$mn        segment para public 'CODE' use32
.text$mn:000020E0                 assume cs:_text$mn
.text$mn:000020E0                 ;org 20E0h
.text$mn:000020E0 ; COMDAT (pick any)
.text$mn:000020E0                 assume es:nothing, ss:nothing, ds:_data, fs:nothing, gs:nothing
.text$mn:000020E0
.text$mn:000020E0 ; =============== S U B R O U T I N E =======================================
.text$mn:000020E0
.text$mn:000020E0 ; Attributes: bp-based frame
.text$mn:000020E0
.text$mn:000020E0 ; struct std::_Container_proxy * __cdecl std::_Allocate<struct std::_Container_proxy>(unsigned int, struct std::_Container_proxy *)
.text$mn:000020E0                 public ??$_Allocate@U_Container_proxy@std@@@std@@YAPAU_Container_proxy@0@IPAU10@@Z
.text$mn:000020E0 ??$_Allocate@U_Container_proxy@std@@@std@@YAPAU_Container_proxy@0@IPAU10@@Z proc near
.text$mn:000020E0                                         ; CODE XREF: std::allocator<std::_Container_proxy>::allocate(uint)+Dp
.text$mn:000020E0
.text$mn:000020E0 var_4           = dword ptr -4
.text$mn:000020E0 arg_0           = dword ptr  8
.text$mn:000020E0
.text$mn:000020E0                 push    ebp
.text$mn:000020E1                 mov     ebp, esp
.text$mn:000020E3                 push    ecx
.text$mn:000020E4                 mov     [ebp+var_4], 0
.text$mn:000020EB                 cmp     [ebp+arg_0], 0
.text$mn:000020EF                 jnz     short loc_20F3
.text$mn:000020F1                 jmp     short loc_2119
.text$mn:000020F3 ; ---------------------------------------------------------------------------
.text$mn:000020F3
.text$mn:000020F3 loc_20F3:                               ; CODE XREF: std::_Allocate<std::_Container_proxy>(uint,std::_Container_proxy *)+Fj
.text$mn:000020F3                 cmp     [ebp+arg_0], 1FFFFFFFh
.text$mn:000020FA                 ja      short loc_2114
.text$mn:000020FC                 mov     eax, [ebp+arg_0]
.text$mn:000020FF                 shl     eax, 3
.text$mn:00002102                 push    eax             ; unsigned int
.text$mn:00002103                 call    ??2@YAPAXI@Z    ; operator new(uint)
.text$mn:00002108                 add     esp, 4
.text$mn:0000210B                 mov     [ebp+var_4], eax
.text$mn:0000210E                 cmp     [ebp+var_4], 0
.text$mn:00002112                 jnz     short loc_2119
.text$mn:00002114
.text$mn:00002114 loc_2114:                               ; CODE XREF: std::_Allocate<std::_Container_proxy>(uint,std::_Container_proxy *)+1Aj
.text$mn:00002114                 call    ?_Xbad_alloc@std@@YAXXZ ; std::_Xbad_alloc(void)
.text$mn:00002119
.text$mn:00002119 loc_2119:                               ; CODE XREF: std::_Allocate<std::_Container_proxy>(uint,std::_Container_proxy *)+11j
.text$mn:00002119                                         ; std::_Allocate<std::_Container_proxy>(uint,std::_Container_proxy *)+32j
.text$mn:00002119                 mov     eax, [ebp+var_4]
.text$mn:0000211C                 mov     esp, ebp
.text$mn:0000211E                 pop     ebp
.text$mn:0000211F                 retn
.text$mn:0000211F ??$_Allocate@U_Container_proxy@std@@@std@@YAPAU_Container_proxy@0@IPAU10@@Z endp
.text$mn:0000211F
.text$mn:0000211F _text$mn        ends
.text$mn:0000211F
.text$mn:00002120 ; ===========================================================================
.text$mn:00002120
.text$mn:00002120 ; Segment type: Pure code
.text$mn:00002120 ; Segment permissions: Read/Execute
.text$mn:00002120 _text$mn        segment para public 'CODE' use32
.text$mn:00002120                 assume cs:_text$mn
.text$mn:00002120                 ;org 2120h
.text$mn:00002120 ; COMDAT (pick any)
.text$mn:00002120                 assume es:nothing, ss:nothing, ds:_data, fs:nothing, gs:nothing
.text$mn:00002120
.text$mn:00002120 ; =============== S U B R O U T I N E =======================================
.text$mn:00002120
.text$mn:00002120 ; Attributes: bp-based frame
.text$mn:00002120
.text$mn:00002120 ; int __cdecl std::_Debug_pointer<char>(int, wchar_t *, unsigned int)
.text$mn:00002120                 public ??$_Debug_pointer@D@std@@YAXPBDPB_WI@Z
.text$mn:00002120 ??$_Debug_pointer@D@std@@YAXPBDPB_WI@Z proc near
.text$mn:00002120                                         ; CODE XREF: std::basic_string<char,std::char_traits<char>,std::allocator<char>>::assign(char const *)+15p
.text$mn:00002120                                         ; std::basic_string<char,std::char_traits<char>,std::allocator<char>>::assign(char const *,uint)+1Bp
.text$mn:00002120
.text$mn:00002120 arg_0           = dword ptr  8
.text$mn:00002120 arg_4           = dword ptr  0Ch
.text$mn:00002120 arg_8           = dword ptr  10h
.text$mn:00002120
.text$mn:00002120                 push    ebp
.text$mn:00002121                 mov     ebp, esp
.text$mn:00002123                 cmp     [ebp+arg_0], 0
.text$mn:00002127                 jnz     short loc_213E
.text$mn:00002129                 mov     eax, [ebp+arg_8]
.text$mn:0000212C                 push    eax             ; unsigned int
.text$mn:0000212D                 mov     ecx, [ebp+arg_4]
.text$mn:00002130                 push    ecx             ; wchar_t *
.text$mn:00002131                 push    offset ??_C@_1CK@EOPGIILJ@?$AAi?$AAn?$AAv?$AAa?$AAl?$AAi?$AAd?$AA?5?$AAn?$AAu?$AAl?$AAl?$AA?5?$AAp?$AAo?$AAi?$AAn?$AAt?$AAe?$AAr?$AA?$AA@ ; "invalid null pointer"
.text$mn:00002136                 call    ?_Debug_message@std@@YAXPB_W0I@Z ; std::_Debug_message(wchar_t const *,wchar_t const *,uint)
.text$mn:0000213B                 add     esp, 0Ch
.text$mn:0000213E
.text$mn:0000213E loc_213E:                               ; CODE XREF: std::_Debug_pointer<char>(char const *,wchar_t const *,uint)+7j
.text$mn:0000213E                 pop     ebp
.text$mn:0000213F                 retn
.text$mn:0000213F ??$_Debug_pointer@D@std@@YAXPBDPB_WI@Z endp
.text$mn:0000213F
.text$mn:0000213F _text$mn        ends
.text$mn:0000213F
.text$mn:00002140 ; ===========================================================================
.text$mn:00002140
.text$mn:00002140 ; Segment type: Pure code
.text$mn:00002140 ; Segment permissions: Read/Execute
.text$mn:00002140 _text$mn        segment para public 'CODE' use32
.text$mn:00002140                 assume cs:_text$mn
.text$mn:00002140                 ;org 2140h
.text$mn:00002140 ; COMDAT (pick any)
.text$mn:00002140                 assume es:nothing, ss:nothing, ds:_data, fs:nothing, gs:nothing
.text$mn:00002140
.text$mn:00002140 ; =============== S U B R O U T I N E =======================================
.text$mn:00002140
.text$mn:00002140 ; Attributes: bp-based frame
.text$mn:00002140
.text$mn:00002140 ; void __cdecl std::_Destroy_range<struct std::_Wrap_alloc<class std::allocator<unsigned int>>>(unsigned int *, unsigned int *, struct std::_Wrap_alloc<class std::allocator<unsigned int>> &)
.text$mn:00002140                 public ??$_Destroy_range@U?$_Wrap_alloc@V?$allocator@I@std@@@std@@@std@@YAXPAI0AAU?$_Wrap_alloc@V?$allocator@I@std@@@0@@Z
.text$mn:00002140 ??$_Destroy_range@U?$_Wrap_alloc@V?$allocator@I@std@@@std@@@std@@YAXPAI0AAU?$_Wrap_alloc@V?$allocator@I@std@@@0@@Z proc near
.text$mn:00002140                                         ; CODE XREF: std::vector<uint,std::allocator<uint>>::_Destroy(uint *,uint *)+21p
.text$mn:00002140
.text$mn:00002140 var_1           = byte ptr -1
.text$mn:00002140 arg_0           = dword ptr  8
.text$mn:00002140 arg_4           = dword ptr  0Ch
.text$mn:00002140 arg_8           = dword ptr  10h
.text$mn:00002140
.text$mn:00002140                 push    ebp
.text$mn:00002141                 mov     ebp, esp
.text$mn:00002143                 push    ecx
.text$mn:00002144                 mov     eax, [ebp+arg_4]
.text$mn:00002147                 push    eax
.text$mn:00002148                 mov     ecx, [ebp+arg_0]
.text$mn:0000214B                 push    ecx
.text$mn:0000214C                 call    ??$_Ptr_cat@II@std@@YA?AU_Scalar_ptr_iterator_tag@0@PAI0@Z ; std::_Ptr_cat<uint,uint>(uint *,uint *)
.text$mn:00002151                 add     esp, 8
.text$mn:00002154                 mov     [ebp+var_1], al
.text$mn:00002157                 movzx   edx, [ebp+var_1]
.text$mn:0000215B                 push    edx
.text$mn:0000215C                 mov     eax, [ebp+arg_8]
.text$mn:0000215F                 push    eax
.text$mn:00002160                 mov     ecx, [ebp+arg_4]
.text$mn:00002163                 push    ecx
.text$mn:00002164                 mov     edx, [ebp+arg_0]
.text$mn:00002167                 push    edx
.text$mn:00002168                 call    ??$_Destroy_range@U?$_Wrap_alloc@V?$allocator@I@std@@@std@@@std@@YAXPAI0AAU?$_Wrap_alloc@V?$allocator@I@std@@@0@U_Scalar_ptr_iterator_tag@0@@Z ; std::_Destroy_range<std::_Wrap_alloc<std::allocator<uint>>>(uint *,uint *,std::_Wrap_alloc<std::allocator<uint>> &,std::_Scalar_ptr_iterator_tag)
.text$mn:0000216D                 add     esp, 10h
.text$mn:00002170                 mov     esp, ebp
.text$mn:00002172                 pop     ebp
.text$mn:00002173                 retn
.text$mn:00002173 ??$_Destroy_range@U?$_Wrap_alloc@V?$allocator@I@std@@@std@@@std@@YAXPAI0AAU?$_Wrap_alloc@V?$allocator@I@std@@@0@@Z endp
.text$mn:00002173
.text$mn:00002173 _text$mn        ends
.text$mn:00002173
.text$mn:00002174 ; ===========================================================================
.text$mn:00002174
.text$mn:00002174 ; Segment type: Pure code
.text$mn:00002174 ; Segment permissions: Read/Execute
.text$mn:00002174 _text$mn        segment para public 'CODE' use32
.text$mn:00002174                 assume cs:_text$mn
.text$mn:00002174                 ;org 2174h
.text$mn:00002174 ; COMDAT (pick any)
.text$mn:00002174                 assume es:nothing, ss:nothing, ds:_data, fs:nothing, gs:nothing
.text$mn:00002174
.text$mn:00002174 ; =============== S U B R O U T I N E =======================================
.text$mn:00002174
.text$mn:00002174 ; Attributes: bp-based frame
.text$mn:00002174
.text$mn:00002174 ; void __cdecl std::_Destroy_range<struct std::_Wrap_alloc<class std::allocator<unsigned int>>>(unsigned int *, unsigned int *, struct std::_Wrap_alloc<class std::allocator<unsigned int>> &, struct std::_Scalar_ptr_iterator_tag)
.text$mn:00002174                 public ??$_Destroy_range@U?$_Wrap_alloc@V?$allocator@I@std@@@std@@@std@@YAXPAI0AAU?$_Wrap_alloc@V?$allocator@I@std@@@0@U_Scalar_ptr_iterator_tag@0@@Z
.text$mn:00002174 ??$_Destroy_range@U?$_Wrap_alloc@V?$allocator@I@std@@@std@@@std@@YAXPAI0AAU?$_Wrap_alloc@V?$allocator@I@std@@@0@U_Scalar_ptr_iterator_tag@0@@Z proc near
.text$mn:00002174                                         ; CODE XREF: std::_Destroy_range<std::_Wrap_alloc<std::allocator<uint>>>(uint *,uint *,std::_Wrap_alloc<std::allocator<uint>> &)+28p
.text$mn:00002174                 push    ebp
.text$mn:00002175                 mov     ebp, esp
.text$mn:00002177                 pop     ebp
.text$mn:00002178                 retn
.text$mn:00002178 ??$_Destroy_range@U?$_Wrap_alloc@V?$allocator@I@std@@@std@@@std@@YAXPAI0AAU?$_Wrap_alloc@V?$allocator@I@std@@@0@U_Scalar_ptr_iterator_tag@0@@Z endp
.text$mn:00002178
.text$mn:00002178 ; ---------------------------------------------------------------------------
.text$mn:00002179                 align 4
.text$mn:00002179 _text$mn        ends
.text$mn:00002179
.text$mn:0000217C ; ===========================================================================
.text$mn:0000217C
.text$mn:0000217C ; Segment type: Pure code
.text$mn:0000217C ; Segment permissions: Read/Execute
.text$mn:0000217C _text$mn        segment para public 'CODE' use32
.text$mn:0000217C                 assume cs:_text$mn
.text$mn:0000217C                 ;org 217Ch
.text$mn:0000217C ; COMDAT (pick any)
.text$mn:0000217C                 assume es:nothing, ss:nothing, ds:_data, fs:nothing, gs:nothing
.text$mn:0000217C
.text$mn:0000217C ; =============== S U B R O U T I N E =======================================
.text$mn:0000217C
.text$mn:0000217C ; Attributes: bp-based frame
.text$mn:0000217C
.text$mn:0000217C ; struct std::_Scalar_ptr_iterator_tag __cdecl std::_Ptr_cat<unsigned int, unsigned int>(unsigned int *, unsigned int *)
.text$mn:0000217C                 public ??$_Ptr_cat@II@std@@YA?AU_Scalar_ptr_iterator_tag@0@PAI0@Z
.text$mn:0000217C ??$_Ptr_cat@II@std@@YA?AU_Scalar_ptr_iterator_tag@0@PAI0@Z proc near
.text$mn:0000217C                                         ; CODE XREF: std::_Destroy_range<std::_Wrap_alloc<std::allocator<uint>>>(uint *,uint *,std::_Wrap_alloc<std::allocator<uint>> &)+Cp
.text$mn:0000217C
.text$mn:0000217C var_1           = byte ptr -1
.text$mn:0000217C
.text$mn:0000217C                 push    ebp
.text$mn:0000217D                 mov     ebp, esp
.text$mn:0000217F                 push    ecx
.text$mn:00002180                 mov     al, [ebp+var_1]
.text$mn:00002183                 mov     esp, ebp
.text$mn:00002185                 pop     ebp
.text$mn:00002186                 retn
.text$mn:00002186 ??$_Ptr_cat@II@std@@YA?AU_Scalar_ptr_iterator_tag@0@PAI0@Z endp
.text$mn:00002186
.text$mn:00002186 ; ---------------------------------------------------------------------------
.text$mn:00002187                 align 4
.text$mn:00002187 _text$mn        ends
.text$mn:00002187
.text$mn:00002188 ; ===========================================================================
.text$mn:00002188
.text$mn:00002188 ; Segment type: Pure code
.text$mn:00002188 ; Segment permissions: Read/Execute
.text$mn:00002188 _text$mn        segment para public 'CODE' use32
.text$mn:00002188                 assume cs:_text$mn
.text$mn:00002188                 ;org 2188h
.text$mn:00002188 ; COMDAT (pick any)
.text$mn:00002188                 assume es:nothing, ss:nothing, ds:_data, fs:nothing, gs:nothing
.text$mn:00002188
.text$mn:00002188 ; =============== S U B R O U T I N E =======================================
.text$mn:00002188
.text$mn:00002188 ; Attributes: bp-based frame
.text$mn:00002188
.text$mn:00002188 ; char * __cdecl std::addressof<char>(char &)
.text$mn:00002188                 public ??$addressof@D@std@@YAPADAAD@Z
.text$mn:00002188 ??$addressof@D@std@@YAPADAAD@Z proc near
.text$mn:00002188                                         ; CODE XREF: std::_String_val<std::_Simple_types<char>>::_Myptr(void)+19p
.text$mn:00002188                                         ; std::_String_val<std::_Simple_types<char>>::_Myptr(void)+19p ...
.text$mn:00002188
.text$mn:00002188 arg_0           = dword ptr  8
.text$mn:00002188
.text$mn:00002188                 push    ebp
.text$mn:00002189                 mov     ebp, esp
.text$mn:0000218B                 mov     eax, [ebp+arg_0]
.text$mn:0000218E                 pop     ebp
.text$mn:0000218F                 retn
.text$mn:0000218F ??$addressof@D@std@@YAPADAAD@Z endp
.text$mn:0000218F
.text$mn:0000218F _text$mn        ends
.text$mn:0000218F
.text$mn:00002190 ; ===========================================================================
.text$mn:00002190
.text$mn:00002190 ; Segment type: Pure code
.text$mn:00002190 ; Segment permissions: Read/Execute
.text$mn:00002190 _text$mn        segment para public 'CODE' use32
.text$mn:00002190                 assume cs:_text$mn
.text$mn:00002190                 ;org 2190h
.text$mn:00002190 ; COMDAT (pick any)
.text$mn:00002190                 assume es:nothing, ss:nothing, ds:_data, fs:nothing, gs:nothing
.text$mn:00002190
.text$mn:00002190 ; =============== S U B R O U T I N E =======================================
.text$mn:00002190
.text$mn:00002190 ; Attributes: bp-based frame
.text$mn:00002190
.text$mn:00002190 ; int __stdcall std::_Wrap_alloc<std::allocator<char>>::construct<char *,char * &>(void *, int)
.text$mn:00002190                 public ??$construct@PADAAPAD@?$_Wrap_alloc@V?$allocator@D@std@@@std@@QAEXPAPADAAPAD@Z
.text$mn:00002190 ??$construct@PADAAPAD@?$_Wrap_alloc@V?$allocator@D@std@@@std@@QAEXPAPADAAPAD@Z proc near
.text$mn:00002190                                         ; CODE XREF: $LN19+4Bp
.text$mn:00002190
.text$mn:00002190 var_4           = dword ptr -4
.text$mn:00002190 arg_0           = dword ptr  8
.text$mn:00002190 arg_4           = dword ptr  0Ch
.text$mn:00002190
.text$mn:00002190                 push    ebp
.text$mn:00002191                 mov     ebp, esp
.text$mn:00002193                 push    ecx
.text$mn:00002194                 mov     [ebp+var_4], ecx
.text$mn:00002197                 mov     eax, [ebp+arg_4]
.text$mn:0000219A                 push    eax
.text$mn:0000219B                 call    ??$forward@AAPAD@std@@YAAAPADAAPAD@Z ; std::forward<char * &>(char * &)
.text$mn:000021A0                 add     esp, 4
.text$mn:000021A3                 push    eax             ; int
.text$mn:000021A4                 mov     ecx, [ebp+arg_0]
.text$mn:000021A7                 push    ecx             ; void *
.text$mn:000021A8                 mov     edx, [ebp+var_4]
.text$mn:000021AB                 push    edx             ; int
.text$mn:000021AC                 call    ??$construct@PADAAPAD@?$allocator_traits@V?$allocator@D@std@@@std@@SAXAAV?$allocator@D@1@PAPADAAPAD@Z ; std::allocator_traits<std::allocator<char>>::construct<char *,char * &>(std::allocator<char> &,char * *,char * &)
.text$mn:000021B1                 add     esp, 0Ch
.text$mn:000021B4                 mov     esp, ebp
.text$mn:000021B6                 pop     ebp
.text$mn:000021B7                 retn    8
.text$mn:000021B7 ??$construct@PADAAPAD@?$_Wrap_alloc@V?$allocator@D@std@@@std@@QAEXPAPADAAPAD@Z endp
.text$mn:000021B7
.text$mn:000021B7 ; ---------------------------------------------------------------------------
.text$mn:000021BA                 align 4
.text$mn:000021BA _text$mn        ends
.text$mn:000021BA
.text$mn:000021BC ; ===========================================================================
.text$mn:000021BC
.text$mn:000021BC ; Segment type: Pure code
.text$mn:000021BC ; Segment permissions: Read/Execute
.text$mn:000021BC _text$mn        segment para public 'CODE' use32
.text$mn:000021BC                 assume cs:_text$mn
.text$mn:000021BC                 ;org 21BCh
.text$mn:000021BC ; COMDAT (pick any)
.text$mn:000021BC                 assume es:nothing, ss:nothing, ds:_data, fs:nothing, gs:nothing
.text$mn:000021BC
.text$mn:000021BC ; =============== S U B R O U T I N E =======================================
.text$mn:000021BC
.text$mn:000021BC ; Attributes: bp-based frame
.text$mn:000021BC
.text$mn:000021BC ; int __stdcall std::allocator<char>::construct<char *,char * &>(void *, int)
.text$mn:000021BC                 public ??$construct@PADAAPAD@?$allocator@D@std@@QAEXPAPADAAPAD@Z
.text$mn:000021BC ??$construct@PADAAPAD@?$allocator@D@std@@QAEXPAPADAAPAD@Z proc near
.text$mn:000021BC                                         ; CODE XREF: std::allocator_traits<std::allocator<char>>::construct<char *,char * &>(std::allocator<char> &,char * *,char * &)+17p
.text$mn:000021BC
.text$mn:000021BC var_1C          = dword ptr -1Ch
.text$mn:000021BC var_18          = dword ptr -18h
.text$mn:000021BC var_14          = dword ptr -14h
.text$mn:000021BC var_10          = dword ptr -10h
.text$mn:000021BC var_C           = dword ptr -0Ch
.text$mn:000021BC var_4           = dword ptr -4
.text$mn:000021BC arg_0           = dword ptr  8
.text$mn:000021BC arg_4           = dword ptr  0Ch
.text$mn:000021BC
.text$mn:000021BC                 push    ebp
.text$mn:000021BD                 mov     ebp, esp
.text$mn:000021BF                 push    0FFFFFFFFh
.text$mn:000021C1                 push    offset __ehhandler$??$construct@PADAAPAD@?$allocator@D@std@@QAEXPAPADAAPAD@Z
.text$mn:000021C6                 mov     eax, large fs:0
.text$mn:000021CC                 push    eax
.text$mn:000021CD                 sub     esp, 10h
.text$mn:000021D0                 mov     eax, dword ptr ds:___security_cookie
.text$mn:000021D5                 xor     eax, ebp
.text$mn:000021D7                 push    eax
.text$mn:000021D8                 lea     eax, [ebp+var_C]
.text$mn:000021DB                 mov     large fs:0, eax
.text$mn:000021E1                 mov     [ebp+var_18], ecx
.text$mn:000021E4                 mov     eax, [ebp+arg_0]
.text$mn:000021E7                 push    eax             ; void *
.text$mn:000021E8                 push    4               ; unsigned int
.text$mn:000021EA                 call    ??2@YAPAXIPAX@Z ; operator new(uint,void *)
.text$mn:000021EF                 add     esp, 8
.text$mn:000021F2                 mov     [ebp+var_10], eax
.text$mn:000021F5                 mov     [ebp+var_4], 0
.text$mn:000021FC                 cmp     [ebp+var_10], 0
.text$mn:00002200                 jz      short loc_221D
.text$mn:00002202                 mov     ecx, [ebp+arg_4]
.text$mn:00002205                 push    ecx
.text$mn:00002206                 call    ??$forward@AAPAD@std@@YAAAPADAAPAD@Z ; std::forward<char * &>(char * &)
.text$mn:0000220B                 add     esp, 4
.text$mn:0000220E                 mov     edx, [ebp+var_10]
.text$mn:00002211                 mov     eax, [eax]
.text$mn:00002213                 mov     [edx], eax
.text$mn:00002215                 mov     ecx, [ebp+var_10]
.text$mn:00002218                 mov     [ebp+var_14], ecx
.text$mn:0000221B                 jmp     short loc_2224
.text$mn:0000221D ; ---------------------------------------------------------------------------
.text$mn:0000221D
.text$mn:0000221D loc_221D:                               ; CODE XREF: std::allocator<char>::construct<char *,char * &>(char * *,char * &)+44j
.text$mn:0000221D                 mov     [ebp+var_14], 0
.text$mn:00002224
.text$mn:00002224 loc_2224:                               ; CODE XREF: std::allocator<char>::construct<char *,char * &>(char * *,char * &)+5Fj
.text$mn:00002224                 mov     edx, [ebp+var_14]
.text$mn:00002227                 mov     [ebp+var_1C], edx
.text$mn:0000222A                 mov     [ebp+var_4], 0FFFFFFFFh
.text$mn:00002231                 mov     ecx, [ebp+var_C]
.text$mn:00002234                 mov     large fs:0, ecx
.text$mn:0000223B                 pop     ecx
.text$mn:0000223C                 mov     esp, ebp
.text$mn:0000223E                 pop     ebp
.text$mn:0000223F                 retn    8
.text$mn:0000223F ??$construct@PADAAPAD@?$allocator@D@std@@QAEXPAPADAAPAD@Z endp
.text$mn:0000223F
.text$mn:0000223F ; ---------------------------------------------------------------------------
.text$mn:00002242                 align 4
.text$mn:00002242 _text$mn        ends
.text$mn:00002242
.text$x:00002244 ; ===========================================================================
.text$x:00002244
.text$x:00002244 ; Segment type: Pure code
.text$x:00002244 ; Segment permissions: Read/Execute
.text$x:00002244 _text$x         segment para public 'CODE' use32
.text$x:00002244                 assume cs:_text$x
.text$x:00002244                 ;org 2244h
.text$x:00002244 ; COMDAT (pick associative to section at 21BC)
.text$x:00002244                 assume es:nothing, ss:nothing, ds:_data, fs:nothing, gs:nothing
.text$x:00002244
.text$x:00002244 ; =============== S U B R O U T I N E =======================================
.text$x:00002244
.text$x:00002244
.text$x:00002244 __unwindfunclet$??$construct@PADAAPAD@?$allocator@D@std@@QAEXPAPADAAPAD@Z$0 proc near
.text$x:00002244                                         ; DATA XREF: .xdata$x:000047C0o
.text$x:00002244                 mov     eax, [ebp+8]
.text$x:00002247                 push    eax
.text$x:00002248                 mov     eax, [ebp-10h]
.text$x:0000224B                 push    eax             ; void *
.text$x:0000224C                 call    ??3@YAXPAX0@Z   ; operator delete(void *,void *)
.text$x:00002251                 add     esp, 8
.text$x:00002254                 retn
.text$x:00002254 __unwindfunclet$??$construct@PADAAPAD@?$allocator@D@std@@QAEXPAPADAAPAD@Z$0 endp
.text$x:00002254
.text$x:00002255
.text$x:00002255 ; =============== S U B R O U T I N E =======================================
.text$x:00002255
.text$x:00002255
.text$x:00002255 __ehhandler$??$construct@PADAAPAD@?$allocator@D@std@@QAEXPAPADAAPAD@Z proc near
.text$x:00002255                                         ; DATA XREF: std::allocator<char>::construct<char *,char * &>(char * *,char * &)+5o
.text$x:00002255
.text$x:00002255 arg_4           = dword ptr  8
.text$x:00002255
.text$x:00002255                 mov     edx, [esp+arg_4]
.text$x:00002259                 lea     eax, [edx+0Ch]
.text$x:0000225C                 mov     ecx, [edx-14h]
.text$x:0000225F                 xor     ecx, eax
.text$x:00002261                 call    @__security_check_cookie@4 ; __security_check_cookie(x)
.text$x:00002266                 mov     eax, offset __ehfuncinfo$??$construct@PADAAPAD@?$allocator@D@std@@QAEXPAPADAAPAD@Z
.text$x:0000226B                 jmp     ___CxxFrameHandler3
.text$x:0000226B __ehhandler$??$construct@PADAAPAD@?$allocator@D@std@@QAEXPAPADAAPAD@Z endp
.text$x:0000226B
.text$x:0000226B _text$x         ends
.text$x:0000226B
.text$mn:00002270 ; ===========================================================================
.text$mn:00002270
.text$mn:00002270 ; Segment type: Pure code
.text$mn:00002270 ; Segment permissions: Read/Execute
.text$mn:00002270 _text$mn        segment para public 'CODE' use32
.text$mn:00002270                 assume cs:_text$mn
.text$mn:00002270                 ;org 2270h
.text$mn:00002270 ; COMDAT (pick any)
.text$mn:00002270                 assume es:nothing, ss:nothing, ds:_data, fs:nothing, gs:nothing
.text$mn:00002270
.text$mn:00002270 ; =============== S U B R O U T I N E =======================================
.text$mn:00002270
.text$mn:00002270 ; Attributes: bp-based frame
.text$mn:00002270
.text$mn:00002270 ; int __cdecl std::allocator_traits<std::allocator<char>>::construct<char *,char * &>(int, void *, int)
.text$mn:00002270                 public ??$construct@PADAAPAD@?$allocator_traits@V?$allocator@D@std@@@std@@SAXAAV?$allocator@D@1@PAPADAAPAD@Z
.text$mn:00002270 ??$construct@PADAAPAD@?$allocator_traits@V?$allocator@D@std@@@std@@SAXAAV?$allocator@D@1@PAPADAAPAD@Z proc near
.text$mn:00002270                                         ; CODE XREF: std::_Wrap_alloc<std::allocator<char>>::construct<char *,char * &>(char * *,char * &)+1Cp
.text$mn:00002270
.text$mn:00002270 arg_0           = dword ptr  8
.text$mn:00002270 arg_4           = dword ptr  0Ch
.text$mn:00002270 arg_8           = dword ptr  10h
.text$mn:00002270
.text$mn:00002270                 push    ebp
.text$mn:00002271                 mov     ebp, esp
.text$mn:00002273                 mov     eax, [ebp+arg_8]
.text$mn:00002276                 push    eax
.text$mn:00002277                 call    ??$forward@AAPAD@std@@YAAAPADAAPAD@Z ; std::forward<char * &>(char * &)
.text$mn:0000227C                 add     esp, 4
.text$mn:0000227F                 push    eax             ; int
.text$mn:00002280                 mov     ecx, [ebp+arg_4]
.text$mn:00002283                 push    ecx             ; void *
.text$mn:00002284                 mov     ecx, [ebp+arg_0]
.text$mn:00002287                 call    ??$construct@PADAAPAD@?$allocator@D@std@@QAEXPAPADAAPAD@Z ; std::allocator<char>::construct<char *,char * &>(char * *,char * &)
.text$mn:0000228C                 pop     ebp
.text$mn:0000228D                 retn
.text$mn:0000228D ??$construct@PADAAPAD@?$allocator_traits@V?$allocator@D@std@@@std@@SAXAAV?$allocator@D@1@PAPADAAPAD@Z endp
.text$mn:0000228D
.text$mn:0000228D ; ---------------------------------------------------------------------------
.text$mn:0000228E                 align 10h
.text$mn:0000228E _text$mn        ends
.text$mn:0000228E
.text$mn:00002290 ; ===========================================================================
.text$mn:00002290
.text$mn:00002290 ; Segment type: Pure code
.text$mn:00002290 ; Segment permissions: Read/Execute
.text$mn:00002290 _text$mn        segment para public 'CODE' use32
.text$mn:00002290                 assume cs:_text$mn
.text$mn:00002290                 ;org 2290h
.text$mn:00002290 ; COMDAT (pick any)
.text$mn:00002290                 assume es:nothing, ss:nothing, ds:_data, fs:nothing, gs:nothing
.text$mn:00002290
.text$mn:00002290 ; =============== S U B R O U T I N E =======================================
.text$mn:00002290
.text$mn:00002290 ; Attributes: bp-based frame
.text$mn:00002290
.text$mn:00002290 ; int __stdcall std::_Wrap_alloc<std::allocator<std::_Container_proxy>>::construct<std::_Container_proxy,std::_Container_proxy>(void *, int)
.text$mn:00002290                 public ??$construct@U_Container_proxy@std@@U12@@?$_Wrap_alloc@V?$allocator@U_Container_proxy@std@@@std@@@std@@QAEXPAU_Container_proxy@1@$$QAU21@@Z
.text$mn:00002290 ??$construct@U_Container_proxy@std@@U12@@?$_Wrap_alloc@V?$allocator@U_Container_proxy@std@@@std@@@std@@QAEXPAU_Container_proxy@1@$$QAU21@@Z proc near
.text$mn:00002290                                         ; CODE XREF: std::_Vector_alloc<0,std::_Vec_base_types<uint,std::allocator<uint>>>::_Alloc_proxy(void)+32p
.text$mn:00002290
.text$mn:00002290 var_4           = dword ptr -4
.text$mn:00002290 arg_0           = dword ptr  8
.text$mn:00002290 arg_4           = dword ptr  0Ch
.text$mn:00002290
.text$mn:00002290                 push    ebp
.text$mn:00002291                 mov     ebp, esp
.text$mn:00002293                 push    ecx
.text$mn:00002294                 mov     [ebp+var_4], ecx
.text$mn:00002297                 mov     eax, [ebp+arg_4]
.text$mn:0000229A                 push    eax
.text$mn:0000229B                 call    ??$forward@U_Container_proxy@std@@@std@@YA$$QAU_Container_proxy@0@AAU10@@Z ; std::forward<std::_Container_proxy>(std::_Container_proxy &)
.text$mn:000022A0                 add     esp, 4
.text$mn:000022A3                 push    eax             ; int
.text$mn:000022A4                 mov     ecx, [ebp+arg_0]
.text$mn:000022A7                 push    ecx             ; void *
.text$mn:000022A8                 mov     edx, [ebp+var_4]
.text$mn:000022AB                 push    edx             ; int
.text$mn:000022AC                 call    ??$construct@U_Container_proxy@std@@U12@@?$allocator_traits@V?$allocator@U_Container_proxy@std@@@std@@@std@@SAXAAV?$allocator@U_Container_proxy@std@@@1@PAU_Container_proxy@1@$$QAU31@@Z ; std::allocator_traits<std::allocator<std::_Container_proxy>>::construct<std::_Container_proxy,std::_Container_proxy>(std::allocator<std::_Container_proxy> &,std::_Container_proxy *,std::_Container_proxy &&)
.text$mn:000022B1                 add     esp, 0Ch
.text$mn:000022B4                 mov     esp, ebp
.text$mn:000022B6                 pop     ebp
.text$mn:000022B7                 retn    8
.text$mn:000022B7 ??$construct@U_Container_proxy@std@@U12@@?$_Wrap_alloc@V?$allocator@U_Container_proxy@std@@@std@@@std@@QAEXPAU_Container_proxy@1@$$QAU21@@Z endp
.text$mn:000022B7
.text$mn:000022B7 ; ---------------------------------------------------------------------------
.text$mn:000022BA                 align 4
.text$mn:000022BA _text$mn        ends
.text$mn:000022BA
.text$mn:000022BC ; ===========================================================================
.text$mn:000022BC
.text$mn:000022BC ; Segment type: Pure code
.text$mn:000022BC ; Segment permissions: Read/Execute
.text$mn:000022BC _text$mn        segment para public 'CODE' use32
.text$mn:000022BC                 assume cs:_text$mn
.text$mn:000022BC                 ;org 22BCh
.text$mn:000022BC ; COMDAT (pick any)
.text$mn:000022BC                 assume es:nothing, ss:nothing, ds:_data, fs:nothing, gs:nothing
.text$mn:000022BC
.text$mn:000022BC ; =============== S U B R O U T I N E =======================================
.text$mn:000022BC
.text$mn:000022BC ; Attributes: bp-based frame
.text$mn:000022BC
.text$mn:000022BC ; int __stdcall std::allocator<std::_Container_proxy>::construct<std::_Container_proxy,std::_Container_proxy>(void *, int)
.text$mn:000022BC                 public ??$construct@U_Container_proxy@std@@U12@@?$allocator@U_Container_proxy@std@@@std@@QAEXPAU_Container_proxy@1@$$QAU21@@Z
.text$mn:000022BC ??$construct@U_Container_proxy@std@@U12@@?$allocator@U_Container_proxy@std@@@std@@QAEXPAU_Container_proxy@1@$$QAU21@@Z proc near
.text$mn:000022BC                                         ; CODE XREF: std::allocator_traits<std::allocator<std::_Container_proxy>>::construct<std::_Container_proxy,std::_Container_proxy>(std::allocator<std::_Container_proxy> &,std::_Container_proxy *,std::_Container_proxy &&)+17p
.text$mn:000022BC                                         ; std::_String_alloc<0,std::_String_base_types<char,std::allocator<char>>>::_Alloc_proxy(void)+32p
.text$mn:000022BC
.text$mn:000022BC var_1C          = dword ptr -1Ch
.text$mn:000022BC var_18          = dword ptr -18h
.text$mn:000022BC var_14          = dword ptr -14h
.text$mn:000022BC var_10          = dword ptr -10h
.text$mn:000022BC var_C           = dword ptr -0Ch
.text$mn:000022BC var_4           = dword ptr -4
.text$mn:000022BC arg_0           = dword ptr  8
.text$mn:000022BC arg_4           = dword ptr  0Ch
.text$mn:000022BC
.text$mn:000022BC                 push    ebp
.text$mn:000022BD                 mov     ebp, esp
.text$mn:000022BF                 push    0FFFFFFFFh
.text$mn:000022C1                 push    offset __ehhandler$??$construct@U_Container_proxy@std@@U12@@?$allocator@U_Container_proxy@std@@@std@@QAEXPAU_Container_proxy@1@$$QAU21@@Z
.text$mn:000022C6                 mov     eax, large fs:0
.text$mn:000022CC                 push    eax
.text$mn:000022CD                 sub     esp, 10h
.text$mn:000022D0                 mov     eax, dword ptr ds:___security_cookie
.text$mn:000022D5                 xor     eax, ebp
.text$mn:000022D7                 push    eax
.text$mn:000022D8                 lea     eax, [ebp+var_C]
.text$mn:000022DB                 mov     large fs:0, eax
.text$mn:000022E1                 mov     [ebp+var_18], ecx
.text$mn:000022E4                 mov     eax, [ebp+arg_0]
.text$mn:000022E7                 push    eax             ; void *
.text$mn:000022E8                 push    8               ; unsigned int
.text$mn:000022EA                 call    ??2@YAPAXIPAX@Z ; operator new(uint,void *)
.text$mn:000022EF                 add     esp, 8
.text$mn:000022F2                 mov     [ebp+var_10], eax
.text$mn:000022F5                 mov     [ebp+var_4], 0
.text$mn:000022FC                 cmp     [ebp+var_10], 0
.text$mn:00002300                 jz      short loc_2323
.text$mn:00002302                 mov     ecx, [ebp+arg_4]
.text$mn:00002305                 push    ecx
.text$mn:00002306                 call    ??$forward@U_Container_proxy@std@@@std@@YA$$QAU_Container_proxy@0@AAU10@@Z ; std::forward<std::_Container_proxy>(std::_Container_proxy &)
.text$mn:0000230B                 add     esp, 4
.text$mn:0000230E                 mov     edx, [eax]
.text$mn:00002310                 mov     eax, [eax+4]
.text$mn:00002313                 mov     ecx, [ebp+var_10]
.text$mn:00002316                 mov     [ecx], edx
.text$mn:00002318                 mov     [ecx+4], eax
.text$mn:0000231B                 mov     edx, [ebp+var_10]
.text$mn:0000231E                 mov     [ebp+var_14], edx
.text$mn:00002321                 jmp     short loc_232A
.text$mn:00002323 ; ---------------------------------------------------------------------------
.text$mn:00002323
.text$mn:00002323 loc_2323:                               ; CODE XREF: std::allocator<std::_Container_proxy>::construct<std::_Container_proxy,std::_Container_proxy>(std::_Container_proxy *,std::_Container_proxy &&)+44j
.text$mn:00002323                 mov     [ebp+var_14], 0
.text$mn:0000232A
.text$mn:0000232A loc_232A:                               ; CODE XREF: std::allocator<std::_Container_proxy>::construct<std::_Container_proxy,std::_Container_proxy>(std::_Container_proxy *,std::_Container_proxy &&)+65j
.text$mn:0000232A                 mov     eax, [ebp+var_14]
.text$mn:0000232D                 mov     [ebp+var_1C], eax
.text$mn:00002330                 mov     [ebp+var_4], 0FFFFFFFFh
.text$mn:00002337                 mov     ecx, [ebp+var_C]
.text$mn:0000233A                 mov     large fs:0, ecx
.text$mn:00002341                 pop     ecx
.text$mn:00002342                 mov     esp, ebp
.text$mn:00002344                 pop     ebp
.text$mn:00002345                 retn    8
.text$mn:00002345 ??$construct@U_Container_proxy@std@@U12@@?$allocator@U_Container_proxy@std@@@std@@QAEXPAU_Container_proxy@1@$$QAU21@@Z endp
.text$mn:00002345
.text$mn:00002345 _text$mn        ends
.text$mn:00002345
.text$x:00002348 ; ===========================================================================
.text$x:00002348
.text$x:00002348 ; Segment type: Pure code
.text$x:00002348 ; Segment permissions: Read/Execute
.text$x:00002348 _text$x         segment para public 'CODE' use32
.text$x:00002348                 assume cs:_text$x
.text$x:00002348                 ;org 2348h
.text$x:00002348 ; COMDAT (pick associative to section at 22BC)
.text$x:00002348                 assume es:nothing, ss:nothing, ds:_data, fs:nothing, gs:nothing
.text$x:00002348
.text$x:00002348 ; =============== S U B R O U T I N E =======================================
.text$x:00002348
.text$x:00002348
.text$x:00002348 __unwindfunclet$??$construct@U_Container_proxy@std@@U12@@?$allocator@U_Container_proxy@std@@@std@@QAEXPAU_Container_proxy@1@$$QAU21@@Z$0 proc near
.text$x:00002348                                         ; DATA XREF: .xdata$x:00004794o
.text$x:00002348                 mov     eax, [ebp+8]
.text$x:0000234B                 push    eax
.text$x:0000234C                 mov     eax, [ebp-10h]
.text$x:0000234F                 push    eax             ; void *
.text$x:00002350                 call    ??3@YAXPAX0@Z   ; operator delete(void *,void *)
.text$x:00002355                 add     esp, 8
.text$x:00002358                 retn
.text$x:00002358 __unwindfunclet$??$construct@U_Container_proxy@std@@U12@@?$allocator@U_Container_proxy@std@@@std@@QAEXPAU_Container_proxy@1@$$QAU21@@Z$0 endp
.text$x:00002358
.text$x:00002359
.text$x:00002359 ; =============== S U B R O U T I N E =======================================
.text$x:00002359
.text$x:00002359
.text$x:00002359 __ehhandler$??$construct@U_Container_proxy@std@@U12@@?$allocator@U_Container_proxy@std@@@std@@QAEXPAU_Container_proxy@1@$$QAU21@@Z proc near
.text$x:00002359                                         ; DATA XREF: std::allocator<std::_Container_proxy>::construct<std::_Container_proxy,std::_Container_proxy>(std::_Container_proxy *,std::_Container_proxy &&)+5o
.text$x:00002359
.text$x:00002359 arg_4           = dword ptr  8
.text$x:00002359
.text$x:00002359                 mov     edx, [esp+arg_4]
.text$x:0000235D                 lea     eax, [edx+0Ch]
.text$x:00002360                 mov     ecx, [edx-14h]
.text$x:00002363                 xor     ecx, eax
.text$x:00002365                 call    @__security_check_cookie@4 ; __security_check_cookie(x)
.text$x:0000236A                 mov     eax, offset __ehfuncinfo$??$construct@U_Container_proxy@std@@U12@@?$allocator@U_Container_proxy@std@@@std@@QAEXPAU_Container_proxy@1@$$QAU21@@Z
.text$x:0000236F                 jmp     ___CxxFrameHandler3
.text$x:0000236F __ehhandler$??$construct@U_Container_proxy@std@@U12@@?$allocator@U_Container_proxy@std@@@std@@QAEXPAU_Container_proxy@1@$$QAU21@@Z endp
.text$x:0000236F
.text$x:0000236F _text$x         ends
.text$x:0000236F
.text$mn:00002374 ; ===========================================================================
.text$mn:00002374
.text$mn:00002374 ; Segment type: Pure code
.text$mn:00002374 ; Segment permissions: Read/Execute
.text$mn:00002374 _text$mn        segment para public 'CODE' use32
.text$mn:00002374                 assume cs:_text$mn
.text$mn:00002374                 ;org 2374h
.text$mn:00002374 ; COMDAT (pick any)
.text$mn:00002374                 assume es:nothing, ss:nothing, ds:_data, fs:nothing, gs:nothing
.text$mn:00002374
.text$mn:00002374 ; =============== S U B R O U T I N E =======================================
.text$mn:00002374
.text$mn:00002374 ; Attributes: bp-based frame
.text$mn:00002374
.text$mn:00002374 ; int __cdecl std::allocator_traits<std::allocator<std::_Container_proxy>>::construct<std::_Container_proxy,std::_Container_proxy>(int, void *, int)
.text$mn:00002374                 public ??$construct@U_Container_proxy@std@@U12@@?$allocator_traits@V?$allocator@U_Container_proxy@std@@@std@@@std@@SAXAAV?$allocator@U_Container_proxy@std@@@1@PAU_Container_proxy@1@$$QAU31@@Z
.text$mn:00002374 ??$construct@U_Container_proxy@std@@U12@@?$allocator_traits@V?$allocator@U_Container_proxy@std@@@std@@@std@@SAXAAV?$allocator@U_Container_proxy@std@@@1@PAU_Container_proxy@1@$$QAU31@@Z proc near
.text$mn:00002374                                         ; CODE XREF: std::_Wrap_alloc<std::allocator<std::_Container_proxy>>::construct<std::_Container_proxy,std::_Container_proxy>(std::_Container_proxy *,std::_Container_proxy &&)+1Cp
.text$mn:00002374
.text$mn:00002374 arg_0           = dword ptr  8
.text$mn:00002374 arg_4           = dword ptr  0Ch
.text$mn:00002374 arg_8           = dword ptr  10h
.text$mn:00002374
.text$mn:00002374                 push    ebp
.text$mn:00002375                 mov     ebp, esp
.text$mn:00002377                 mov     eax, [ebp+arg_8]
.text$mn:0000237A                 push    eax
.text$mn:0000237B                 call    ??$forward@U_Container_proxy@std@@@std@@YA$$QAU_Container_proxy@0@AAU10@@Z ; std::forward<std::_Container_proxy>(std::_Container_proxy &)
.text$mn:00002380                 add     esp, 4
.text$mn:00002383                 push    eax             ; int
.text$mn:00002384                 mov     ecx, [ebp+arg_4]
.text$mn:00002387                 push    ecx             ; void *
.text$mn:00002388                 mov     ecx, [ebp+arg_0]
.text$mn:0000238B                 call    ??$construct@U_Container_proxy@std@@U12@@?$allocator@U_Container_proxy@std@@@std@@QAEXPAU_Container_proxy@1@$$QAU21@@Z ; std::allocator<std::_Container_proxy>::construct<std::_Container_proxy,std::_Container_proxy>(std::_Container_proxy *,std::_Container_proxy &&)
.text$mn:00002390                 pop     ebp
.text$mn:00002391                 retn
.text$mn:00002391 ??$construct@U_Container_proxy@std@@U12@@?$allocator_traits@V?$allocator@U_Container_proxy@std@@@std@@@std@@SAXAAV?$allocator@U_Container_proxy@std@@@1@PAU_Container_proxy@1@$$QAU31@@Z endp
.text$mn:00002391
.text$mn:00002391 ; ---------------------------------------------------------------------------
.text$mn:00002392                 align 4
.text$mn:00002392 _text$mn        ends
.text$mn:00002392
.text$mn:00002394 ; ===========================================================================
.text$mn:00002394
.text$mn:00002394 ; Segment type: Pure code
.text$mn:00002394 ; Segment permissions: Read/Execute
.text$mn:00002394 _text$mn        segment para public 'CODE' use32
.text$mn:00002394                 assume cs:_text$mn
.text$mn:00002394                 ;org 2394h
.text$mn:00002394 ; COMDAT (pick any)
.text$mn:00002394                 assume es:nothing, ss:nothing, ds:_data, fs:nothing, gs:nothing
.text$mn:00002394
.text$mn:00002394 ; =============== S U B R O U T I N E =======================================
.text$mn:00002394
.text$mn:00002394 ; Attributes: bp-based frame
.text$mn:00002394
.text$mn:00002394 ; public: void __thiscall std::_Wrap_alloc<class std::allocator<char>>::destroy<char *>(char * *)
.text$mn:00002394                 public ??$destroy@PAD@?$_Wrap_alloc@V?$allocator@D@std@@@std@@QAEXPAPAD@Z
.text$mn:00002394 ??$destroy@PAD@?$_Wrap_alloc@V?$allocator@D@std@@@std@@QAEXPAPAD@Z proc near
.text$mn:00002394                                         ; CODE XREF: std::basic_string<char,std::char_traits<char>,std::allocator<char>>::_Tidy(bool,uint)+3Ap
.text$mn:00002394
.text$mn:00002394 var_4           = dword ptr -4
.text$mn:00002394 arg_0           = dword ptr  8
.text$mn:00002394
.text$mn:00002394                 push    ebp
.text$mn:00002395                 mov     ebp, esp
.text$mn:00002397                 push    ecx
.text$mn:00002398                 mov     [ebp+var_4], ecx
.text$mn:0000239B                 mov     eax, [ebp+arg_0]
.text$mn:0000239E                 push    eax
.text$mn:0000239F                 mov     ecx, [ebp+var_4]
.text$mn:000023A2                 push    ecx
.text$mn:000023A3                 call    ??$destroy@PAD@?$allocator_traits@V?$allocator@D@std@@@std@@SAXAAV?$allocator@D@1@PAPAD@Z ; std::allocator_traits<std::allocator<char>>::destroy<char *>(std::allocator<char> &,char * *)
.text$mn:000023A8                 add     esp, 8
.text$mn:000023AB                 mov     esp, ebp
.text$mn:000023AD                 pop     ebp
.text$mn:000023AE                 retn    4
.text$mn:000023AE ??$destroy@PAD@?$_Wrap_alloc@V?$allocator@D@std@@@std@@QAEXPAPAD@Z endp
.text$mn:000023AE
.text$mn:000023AE ; ---------------------------------------------------------------------------
.text$mn:000023B1                 align 4
.text$mn:000023B1 _text$mn        ends
.text$mn:000023B1
.text$mn:000023B4 ; ===========================================================================
.text$mn:000023B4
.text$mn:000023B4 ; Segment type: Pure code
.text$mn:000023B4 ; Segment permissions: Read/Execute
.text$mn:000023B4 _text$mn        segment para public 'CODE' use32
.text$mn:000023B4                 assume cs:_text$mn
.text$mn:000023B4                 ;org 23B4h
.text$mn:000023B4 ; COMDAT (pick any)
.text$mn:000023B4                 assume es:nothing, ss:nothing, ds:_data, fs:nothing, gs:nothing
.text$mn:000023B4
.text$mn:000023B4 ; =============== S U B R O U T I N E =======================================
.text$mn:000023B4
.text$mn:000023B4 ; Attributes: bp-based frame
.text$mn:000023B4
.text$mn:000023B4 ; public: void __thiscall std::allocator<char>::destroy<char *>(char * *)
.text$mn:000023B4                 public ??$destroy@PAD@?$allocator@D@std@@QAEXPAPAD@Z
.text$mn:000023B4 ??$destroy@PAD@?$allocator@D@std@@QAEXPAPAD@Z proc near
.text$mn:000023B4                                         ; CODE XREF: std::allocator_traits<std::allocator<char>>::destroy<char *>(std::allocator<char> &,char * *)+Ap
.text$mn:000023B4
.text$mn:000023B4 var_4           = dword ptr -4
.text$mn:000023B4
.text$mn:000023B4                 push    ebp
.text$mn:000023B5                 mov     ebp, esp
.text$mn:000023B7                 push    ecx
.text$mn:000023B8                 mov     [ebp+var_4], ecx
.text$mn:000023BB                 mov     esp, ebp
.text$mn:000023BD                 pop     ebp
.text$mn:000023BE                 retn    4
.text$mn:000023BE ??$destroy@PAD@?$allocator@D@std@@QAEXPAPAD@Z endp
.text$mn:000023BE
.text$mn:000023BE ; ---------------------------------------------------------------------------
.text$mn:000023C1                 align 4
.text$mn:000023C1 _text$mn        ends
.text$mn:000023C1
.text$mn:000023C4 ; ===========================================================================
.text$mn:000023C4
.text$mn:000023C4 ; Segment type: Pure code
.text$mn:000023C4 ; Segment permissions: Read/Execute
.text$mn:000023C4 _text$mn        segment para public 'CODE' use32
.text$mn:000023C4                 assume cs:_text$mn
.text$mn:000023C4                 ;org 23C4h
.text$mn:000023C4 ; COMDAT (pick any)
.text$mn:000023C4                 assume es:nothing, ss:nothing, ds:_data, fs:nothing, gs:nothing
.text$mn:000023C4
.text$mn:000023C4 ; =============== S U B R O U T I N E =======================================
.text$mn:000023C4
.text$mn:000023C4 ; Attributes: bp-based frame
.text$mn:000023C4
.text$mn:000023C4 ; public: static void __cdecl std::allocator_traits<class std::allocator<char>>::destroy<char *>(class std::allocator<char> &, char * *)
.text$mn:000023C4                 public ??$destroy@PAD@?$allocator_traits@V?$allocator@D@std@@@std@@SAXAAV?$allocator@D@1@PAPAD@Z
.text$mn:000023C4 ??$destroy@PAD@?$allocator_traits@V?$allocator@D@std@@@std@@SAXAAV?$allocator@D@1@PAPAD@Z proc near
.text$mn:000023C4                                         ; CODE XREF: std::_Wrap_alloc<std::allocator<char>>::destroy<char *>(char * *)+Fp
.text$mn:000023C4
.text$mn:000023C4 arg_0           = dword ptr  8
.text$mn:000023C4 arg_4           = dword ptr  0Ch
.text$mn:000023C4
.text$mn:000023C4                 push    ebp
.text$mn:000023C5                 mov     ebp, esp
.text$mn:000023C7                 mov     eax, [ebp+arg_4]
.text$mn:000023CA                 push    eax
.text$mn:000023CB                 mov     ecx, [ebp+arg_0]
.text$mn:000023CE                 call    ??$destroy@PAD@?$allocator@D@std@@QAEXPAPAD@Z ; std::allocator<char>::destroy<char *>(char * *)
.text$mn:000023D3                 pop     ebp
.text$mn:000023D4                 retn
.text$mn:000023D4 ??$destroy@PAD@?$allocator_traits@V?$allocator@D@std@@@std@@SAXAAV?$allocator@D@1@PAPAD@Z endp
.text$mn:000023D4
.text$mn:000023D4 ; ---------------------------------------------------------------------------
.text$mn:000023D5                 align 4
.text$mn:000023D5 _text$mn        ends
.text$mn:000023D5
.text$mn:000023D8 ; ===========================================================================
.text$mn:000023D8
.text$mn:000023D8 ; Segment type: Pure code
.text$mn:000023D8 ; Segment permissions: Read/Execute
.text$mn:000023D8 _text$mn        segment para public 'CODE' use32
.text$mn:000023D8                 assume cs:_text$mn
.text$mn:000023D8                 ;org 23D8h
.text$mn:000023D8 ; COMDAT (pick any)
.text$mn:000023D8                 assume es:nothing, ss:nothing, ds:_data, fs:nothing, gs:nothing
.text$mn:000023D8
.text$mn:000023D8 ; =============== S U B R O U T I N E =======================================
.text$mn:000023D8
.text$mn:000023D8 ; Attributes: bp-based frame
.text$mn:000023D8
.text$mn:000023D8 ; public: void __thiscall std::_Wrap_alloc<class std::allocator<struct std::_Container_proxy>>::destroy<struct std::_Container_proxy>(struct std::_Container_proxy *)
.text$mn:000023D8                 public ??$destroy@U_Container_proxy@std@@@?$_Wrap_alloc@V?$allocator@U_Container_proxy@std@@@std@@@std@@QAEXPAU_Container_proxy@1@@Z
.text$mn:000023D8 ??$destroy@U_Container_proxy@std@@@?$_Wrap_alloc@V?$allocator@U_Container_proxy@std@@@std@@@std@@QAEXPAU_Container_proxy@1@@Z proc near
.text$mn:000023D8                                         ; CODE XREF: std::_Vector_alloc<0,std::_Vec_base_types<uint,std::allocator<uint>>>::_Free_proxy(void)+22p
.text$mn:000023D8
.text$mn:000023D8 var_4           = dword ptr -4
.text$mn:000023D8 arg_0           = dword ptr  8
.text$mn:000023D8
.text$mn:000023D8                 push    ebp
.text$mn:000023D9                 mov     ebp, esp
.text$mn:000023DB                 push    ecx
.text$mn:000023DC                 mov     [ebp+var_4], ecx
.text$mn:000023DF                 mov     eax, [ebp+arg_0]
.text$mn:000023E2                 push    eax
.text$mn:000023E3                 mov     ecx, [ebp+var_4]
.text$mn:000023E6                 push    ecx
.text$mn:000023E7                 call    ??$destroy@U_Container_proxy@std@@@?$allocator_traits@V?$allocator@U_Container_proxy@std@@@std@@@std@@SAXAAV?$allocator@U_Container_proxy@std@@@1@PAU_Container_proxy@1@@Z ; std::allocator_traits<std::allocator<std::_Container_proxy>>::destroy<std::_Container_proxy>(std::allocator<std::_Container_proxy> &,std::_Container_proxy *)
.text$mn:000023EC                 add     esp, 8
.text$mn:000023EF                 mov     esp, ebp
.text$mn:000023F1                 pop     ebp
.text$mn:000023F2                 retn    4
.text$mn:000023F2 ??$destroy@U_Container_proxy@std@@@?$_Wrap_alloc@V?$allocator@U_Container_proxy@std@@@std@@@std@@QAEXPAU_Container_proxy@1@@Z endp
.text$mn:000023F2
.text$mn:000023F2 ; ---------------------------------------------------------------------------
.text$mn:000023F5                 align 4
.text$mn:000023F5 _text$mn        ends
.text$mn:000023F5
.text$mn:000023F8 ; ===========================================================================
.text$mn:000023F8
.text$mn:000023F8 ; Segment type: Pure code
.text$mn:000023F8 ; Segment permissions: Read/Execute
.text$mn:000023F8 _text$mn        segment para public 'CODE' use32
.text$mn:000023F8                 assume cs:_text$mn
.text$mn:000023F8                 ;org 23F8h
.text$mn:000023F8 ; COMDAT (pick any)
.text$mn:000023F8                 assume es:nothing, ss:nothing, ds:_data, fs:nothing, gs:nothing
.text$mn:000023F8
.text$mn:000023F8 ; =============== S U B R O U T I N E =======================================
.text$mn:000023F8
.text$mn:000023F8 ; Attributes: bp-based frame
.text$mn:000023F8
.text$mn:000023F8 ; public: void __thiscall std::allocator<struct std::_Container_proxy>::destroy<struct std::_Container_proxy>(struct std::_Container_proxy *)
.text$mn:000023F8                 public ??$destroy@U_Container_proxy@std@@@?$allocator@U_Container_proxy@std@@@std@@QAEXPAU_Container_proxy@1@@Z
.text$mn:000023F8 ??$destroy@U_Container_proxy@std@@@?$allocator@U_Container_proxy@std@@@std@@QAEXPAU_Container_proxy@1@@Z proc near
.text$mn:000023F8                                         ; CODE XREF: std::allocator_traits<std::allocator<std::_Container_proxy>>::destroy<std::_Container_proxy>(std::allocator<std::_Container_proxy> &,std::_Container_proxy *)+Ap
.text$mn:000023F8                                         ; std::_String_alloc<0,std::_String_base_types<char,std::allocator<char>>>::_Free_proxy(void)+22p
.text$mn:000023F8
.text$mn:000023F8 var_4           = dword ptr -4
.text$mn:000023F8
.text$mn:000023F8                 push    ebp
.text$mn:000023F9                 mov     ebp, esp
.text$mn:000023FB                 push    ecx
.text$mn:000023FC                 mov     [ebp+var_4], ecx
.text$mn:000023FF                 mov     esp, ebp
.text$mn:00002401                 pop     ebp
.text$mn:00002402                 retn    4
.text$mn:00002402 ??$destroy@U_Container_proxy@std@@@?$allocator@U_Container_proxy@std@@@std@@QAEXPAU_Container_proxy@1@@Z endp
.text$mn:00002402
.text$mn:00002402 ; ---------------------------------------------------------------------------
.text$mn:00002405                 align 4
.text$mn:00002405 _text$mn        ends
.text$mn:00002405
.text$mn:00002408 ; ===========================================================================
.text$mn:00002408
.text$mn:00002408 ; Segment type: Pure code
.text$mn:00002408 ; Segment permissions: Read/Execute
.text$mn:00002408 _text$mn        segment para public 'CODE' use32
.text$mn:00002408                 assume cs:_text$mn
.text$mn:00002408                 ;org 2408h
.text$mn:00002408 ; COMDAT (pick any)
.text$mn:00002408                 assume es:nothing, ss:nothing, ds:_data, fs:nothing, gs:nothing
.text$mn:00002408
.text$mn:00002408 ; =============== S U B R O U T I N E =======================================
.text$mn:00002408
.text$mn:00002408 ; Attributes: bp-based frame
.text$mn:00002408
.text$mn:00002408 ; public: static void __cdecl std::allocator_traits<class std::allocator<struct std::_Container_proxy>>::destroy<struct std::_Container_proxy>(class std::allocator<struct std::_Container_proxy> &, struct std::_Container_proxy *)
.text$mn:00002408                 public ??$destroy@U_Container_proxy@std@@@?$allocator_traits@V?$allocator@U_Container_proxy@std@@@std@@@std@@SAXAAV?$allocator@U_Container_proxy@std@@@1@PAU_Container_proxy@1@@Z
.text$mn:00002408 ??$destroy@U_Container_proxy@std@@@?$allocator_traits@V?$allocator@U_Container_proxy@std@@@std@@@std@@SAXAAV?$allocator@U_Container_proxy@std@@@1@PAU_Container_proxy@1@@Z proc near
.text$mn:00002408                                         ; CODE XREF: std::_Wrap_alloc<std::allocator<std::_Container_proxy>>::destroy<std::_Container_proxy>(std::_Container_proxy *)+Fp
.text$mn:00002408
.text$mn:00002408 arg_0           = dword ptr  8
.text$mn:00002408 arg_4           = dword ptr  0Ch
.text$mn:00002408
.text$mn:00002408                 push    ebp
.text$mn:00002409                 mov     ebp, esp
.text$mn:0000240B                 mov     eax, [ebp+arg_4]
.text$mn:0000240E                 push    eax
.text$mn:0000240F                 mov     ecx, [ebp+arg_0]
.text$mn:00002412                 call    ??$destroy@U_Container_proxy@std@@@?$allocator@U_Container_proxy@std@@@std@@QAEXPAU_Container_proxy@1@@Z ; std::allocator<std::_Container_proxy>::destroy<std::_Container_proxy>(std::_Container_proxy *)
.text$mn:00002417                 pop     ebp
.text$mn:00002418                 retn
.text$mn:00002418 ??$destroy@U_Container_proxy@std@@@?$allocator_traits@V?$allocator@U_Container_proxy@std@@@std@@@std@@SAXAAV?$allocator@U_Container_proxy@std@@@1@PAU_Container_proxy@1@@Z endp
.text$mn:00002418
.text$mn:00002418 ; ---------------------------------------------------------------------------
.text$mn:00002419                 align 4
.text$mn:00002419 _text$mn        ends
.text$mn:00002419
.text$mn:0000241C ; ===========================================================================
.text$mn:0000241C
.text$mn:0000241C ; Segment type: Pure code
.text$mn:0000241C ; Segment permissions: Read/Execute
.text$mn:0000241C _text$mn        segment para public 'CODE' use32
.text$mn:0000241C                 assume cs:_text$mn
.text$mn:0000241C                 ;org 241Ch
.text$mn:0000241C ; COMDAT (pick any)
.text$mn:0000241C                 assume es:nothing, ss:nothing, ds:_data, fs:nothing, gs:nothing
.text$mn:0000241C
.text$mn:0000241C ; =============== S U B R O U T I N E =======================================
.text$mn:0000241C
.text$mn:0000241C ; Attributes: bp-based frame
.text$mn:0000241C
.text$mn:0000241C ; char * & __cdecl std::forward<char * &>(char * &)
.text$mn:0000241C                 public ??$forward@AAPAD@std@@YAAAPADAAPAD@Z
.text$mn:0000241C ??$forward@AAPAD@std@@YAAAPADAAPAD@Z proc near
.text$mn:0000241C                                         ; CODE XREF: std::_Wrap_alloc<std::allocator<char>>::construct<char *,char * &>(char * *,char * &)+Bp
.text$mn:0000241C                                         ; std::allocator<char>::construct<char *,char * &>(char * *,char * &)+4Ap ...
.text$mn:0000241C
.text$mn:0000241C arg_0           = dword ptr  8
.text$mn:0000241C
.text$mn:0000241C                 push    ebp
.text$mn:0000241D                 mov     ebp, esp
.text$mn:0000241F                 mov     eax, [ebp+arg_0]
.text$mn:00002422                 pop     ebp
.text$mn:00002423                 retn
.text$mn:00002423 ??$forward@AAPAD@std@@YAAAPADAAPAD@Z endp
.text$mn:00002423
.text$mn:00002423 _text$mn        ends
.text$mn:00002423
.text$mn:00002424 ; ===========================================================================
.text$mn:00002424
.text$mn:00002424 ; Segment type: Pure code
.text$mn:00002424 ; Segment permissions: Read/Execute
.text$mn:00002424 _text$mn        segment para public 'CODE' use32
.text$mn:00002424                 assume cs:_text$mn
.text$mn:00002424                 ;org 2424h
.text$mn:00002424 ; COMDAT (pick any)
.text$mn:00002424                 assume es:nothing, ss:nothing, ds:_data, fs:nothing, gs:nothing
.text$mn:00002424
.text$mn:00002424 ; =============== S U B R O U T I N E =======================================
.text$mn:00002424
.text$mn:00002424 ; Attributes: bp-based frame
.text$mn:00002424
.text$mn:00002424 ; struct std::_Container_proxy && __cdecl std::forward<struct std::_Container_proxy>(struct std::_Container_proxy &)
.text$mn:00002424                 public ??$forward@U_Container_proxy@std@@@std@@YA$$QAU_Container_proxy@0@AAU10@@Z
.text$mn:00002424 ??$forward@U_Container_proxy@std@@@std@@YA$$QAU_Container_proxy@0@AAU10@@Z proc near
.text$mn:00002424                                         ; CODE XREF: std::_Wrap_alloc<std::allocator<std::_Container_proxy>>::construct<std::_Container_proxy,std::_Container_proxy>(std::_Container_proxy *,std::_Container_proxy &&)+Bp
.text$mn:00002424                                         ; std::allocator<std::_Container_proxy>::construct<std::_Container_proxy,std::_Container_proxy>(std::_Container_proxy *,std::_Container_proxy &&)+4Ap ...
.text$mn:00002424
.text$mn:00002424 arg_0           = dword ptr  8
.text$mn:00002424
.text$mn:00002424                 push    ebp
.text$mn:00002425                 mov     ebp, esp
.text$mn:00002427                 mov     eax, [ebp+arg_0]
.text$mn:0000242A                 pop     ebp
.text$mn:0000242B                 retn
.text$mn:0000242B ??$forward@U_Container_proxy@std@@@std@@YA$$QAU_Container_proxy@0@AAU10@@Z endp
.text$mn:0000242B
.text$mn:0000242B _text$mn        ends
.text$mn:0000242B
.text$mn:0000242C ; ===========================================================================
.text$mn:0000242C
.text$mn:0000242C ; Segment type: Pure code
.text$mn:0000242C ; Segment permissions: Read/Execute
.text$mn:0000242C _text$mn        segment para public 'CODE' use32
.text$mn:0000242C                 assume cs:_text$mn
.text$mn:0000242C                 ;org 242Ch
.text$mn:0000242C ; COMDAT (pick any)
.text$mn:0000242C                 assume es:nothing, ss:nothing, ds:_data, fs:nothing, gs:nothing
.text$mn:0000242C
.text$mn:0000242C ; =============== S U B R O U T I N E =======================================
.text$mn:0000242C
.text$mn:0000242C ; Attributes: bp-based frame
.text$mn:0000242C
.text$mn:0000242C ; public: __thiscall std::_String_alloc<0, struct std::_String_base_types<char, class std::allocator<char>>>::_String_alloc<0, struct std::_String_base_types<char, class std::allocator<char>>>(class std::allocator<char> const &)
.text$mn:0000242C                 public ??0?$_String_alloc@$0A@U?$_String_base_types@DV?$allocator@D@std@@@std@@@std@@QAE@ABV?$allocator@D@1@@Z
.text$mn:0000242C ??0?$_String_alloc@$0A@U?$_String_base_types@DV?$allocator@D@std@@@std@@@std@@QAE@ABV?$allocator@D@1@@Z proc near
.text$mn:0000242C                                         ; CODE XREF: std::basic_string<char,std::char_traits<char>,std::allocator<char>>::basic_string<char,std::char_traits<char>,std::allocator<char>>(char const *)+34p
.text$mn:0000242C
.text$mn:0000242C var_10          = dword ptr -10h
.text$mn:0000242C var_C           = dword ptr -0Ch
.text$mn:0000242C var_4           = dword ptr -4
.text$mn:0000242C
.text$mn:0000242C                 push    ebp
.text$mn:0000242D                 mov     ebp, esp
.text$mn:0000242F                 push    0FFFFFFFFh
.text$mn:00002431                 push    offset __ehhandler$??0?$_String_alloc@$0A@U?$_String_base_types@DV?$allocator@D@std@@@std@@@std@@QAE@ABV?$allocator@D@1@@Z
.text$mn:00002436                 mov     eax, large fs:0
.text$mn:0000243C                 push    eax
.text$mn:0000243D                 push    ecx
.text$mn:0000243E                 mov     eax, dword ptr ds:___security_cookie
.text$mn:00002443                 xor     eax, ebp
.text$mn:00002445                 push    eax
.text$mn:00002446                 lea     eax, [ebp+var_C]
.text$mn:00002449                 mov     large fs:0, eax
.text$mn:0000244F                 mov     [ebp+var_10], ecx
.text$mn:00002452                 mov     ecx, [ebp+var_10]
.text$mn:00002455                 call    ??0?$_String_val@U?$_Simple_types@D@std@@@std@@QAE@XZ ; std::_String_val<std::_Simple_types<char>>::_String_val<std::_Simple_types<char>>(void)
.text$mn:0000245A                 mov     [ebp+var_4], 0
.text$mn:00002461                 mov     ecx, [ebp+var_10]
.text$mn:00002464                 call    ?_Alloc_proxy@?$_String_alloc@$0A@U?$_String_base_types@DV?$allocator@D@std@@@std@@@std@@QAEXXZ ; std::_String_alloc<0,std::_String_base_types<char,std::allocator<char>>>::_Alloc_proxy(void)
.text$mn:00002469                 mov     [ebp+var_4], 0FFFFFFFFh
.text$mn:00002470                 mov     eax, [ebp+var_10]
.text$mn:00002473                 mov     ecx, [ebp+var_C]
.text$mn:00002476                 mov     large fs:0, ecx
.text$mn:0000247D                 pop     ecx
.text$mn:0000247E                 mov     esp, ebp
.text$mn:00002480                 pop     ebp
.text$mn:00002481                 retn    4
.text$mn:00002481 ??0?$_String_alloc@$0A@U?$_String_base_types@DV?$allocator@D@std@@@std@@@std@@QAE@ABV?$allocator@D@1@@Z endp
.text$mn:00002481
.text$mn:00002481 _text$mn        ends
.text$mn:00002481
.text$x:00002484 ; ===========================================================================
.text$x:00002484
.text$x:00002484 ; Segment type: Pure code
.text$x:00002484 ; Segment permissions: Read/Execute
.text$x:00002484 _text$x         segment para public 'CODE' use32
.text$x:00002484                 assume cs:_text$x
.text$x:00002484                 ;org 2484h
.text$x:00002484 ; COMDAT (pick associative to section at 242C)
.text$x:00002484                 assume es:nothing, ss:nothing, ds:_data, fs:nothing, gs:nothing
.text$x:00002484
.text$x:00002484 ; =============== S U B R O U T I N E =======================================
.text$x:00002484
.text$x:00002484
.text$x:00002484 __unwindfunclet$??0?$_String_alloc@$0A@U?$_String_base_types@DV?$allocator@D@std@@@std@@@std@@QAE@ABV?$allocator@D@1@@Z$0 proc near
.text$x:00002484                                         ; DATA XREF: .xdata$x:00004398o
.text$x:00002484                 mov     ecx, [ebp-10h]
.text$x:00002487                 jmp     ??1?$_String_val@U?$_Simple_types@D@std@@@std@@QAE@XZ ; std::_String_val<std::_Simple_types<char>>::~_String_val<std::_Simple_types<char>>(void)
.text$x:00002487 __unwindfunclet$??0?$_String_alloc@$0A@U?$_String_base_types@DV?$allocator@D@std@@@std@@@std@@QAE@ABV?$allocator@D@1@@Z$0 endp
.text$x:00002487
.text$x:0000248C
.text$x:0000248C ; =============== S U B R O U T I N E =======================================
.text$x:0000248C
.text$x:0000248C
.text$x:0000248C __ehhandler$??0?$_String_alloc@$0A@U?$_String_base_types@DV?$allocator@D@std@@@std@@@std@@QAE@ABV?$allocator@D@1@@Z proc near
.text$x:0000248C                                         ; DATA XREF: std::_String_alloc<0,std::_String_base_types<char,std::allocator<char>>>::_String_alloc<0,std::_String_base_types<char,std::allocator<char>>>(std::allocator<char> const &)+5o
.text$x:0000248C
.text$x:0000248C arg_4           = dword ptr  8
.text$x:0000248C
.text$x:0000248C                 mov     edx, [esp+arg_4]
.text$x:00002490                 lea     eax, [edx+0Ch]
.text$x:00002493                 mov     ecx, [edx-8]
.text$x:00002496                 xor     ecx, eax
.text$x:00002498                 call    @__security_check_cookie@4 ; __security_check_cookie(x)
.text$x:0000249D                 mov     eax, offset __ehfuncinfo$??0?$_String_alloc@$0A@U?$_String_base_types@DV?$allocator@D@std@@@std@@@std@@QAE@ABV?$allocator@D@1@@Z
.text$x:000024A2                 jmp     ___CxxFrameHandler3
.text$x:000024A2 __ehhandler$??0?$_String_alloc@$0A@U?$_String_base_types@DV?$allocator@D@std@@@std@@@std@@QAE@ABV?$allocator@D@1@@Z endp
.text$x:000024A2
.text$x:000024A2 ; ---------------------------------------------------------------------------
.text$x:000024A7                 align 4
.text$x:000024A7 _text$x         ends
.text$x:000024A7
.text$mn:000024A8 ; ===========================================================================
.text$mn:000024A8
.text$mn:000024A8 ; Segment type: Pure code
.text$mn:000024A8 ; Segment permissions: Read/Execute
.text$mn:000024A8 _text$mn        segment para public 'CODE' use32
.text$mn:000024A8                 assume cs:_text$mn
.text$mn:000024A8                 ;org 24A8h
.text$mn:000024A8 ; COMDAT (pick any)
.text$mn:000024A8                 assume es:nothing, ss:nothing, ds:_data, fs:nothing, gs:nothing
.text$mn:000024A8
.text$mn:000024A8 ; =============== S U B R O U T I N E =======================================
.text$mn:000024A8
.text$mn:000024A8 ; Attributes: bp-based frame
.text$mn:000024A8
.text$mn:000024A8 ; public: __thiscall std::_String_val<struct std::_Simple_types<char>>::_String_val<struct std::_Simple_types<char>>(void)
.text$mn:000024A8                 public ??0?$_String_val@U?$_Simple_types@D@std@@@std@@QAE@XZ
.text$mn:000024A8 ??0?$_String_val@U?$_Simple_types@D@std@@@std@@QAE@XZ proc near
.text$mn:000024A8                                         ; CODE XREF: std::_String_alloc<0,std::_String_base_types<char,std::allocator<char>>>::_String_alloc<0,std::_String_base_types<char,std::allocator<char>>>(std::allocator<char> const &)+29p
.text$mn:000024A8
.text$mn:000024A8 var_10          = dword ptr -10h
.text$mn:000024A8 var_C           = dword ptr -0Ch
.text$mn:000024A8 var_4           = dword ptr -4
.text$mn:000024A8
.text$mn:000024A8                 push    ebp
.text$mn:000024A9                 mov     ebp, esp
.text$mn:000024AB                 push    0FFFFFFFFh
.text$mn:000024AD                 push    offset __ehhandler$??0?$_String_val@U?$_Simple_types@D@std@@@std@@QAE@XZ
.text$mn:000024B2                 mov     eax, large fs:0
.text$mn:000024B8                 push    eax
.text$mn:000024B9                 push    ecx
.text$mn:000024BA                 mov     eax, dword ptr ds:___security_cookie
.text$mn:000024BF                 xor     eax, ebp
.text$mn:000024C1                 push    eax
.text$mn:000024C2                 lea     eax, [ebp+var_C]
.text$mn:000024C5                 mov     large fs:0, eax
.text$mn:000024CB                 mov     [ebp+var_10], ecx
.text$mn:000024CE                 mov     ecx, [ebp+var_10] ; this
.text$mn:000024D1                 call    ??0_Container_base12@std@@QAE@XZ ; std::_Container_base12::_Container_base12(void)
.text$mn:000024D6                 mov     [ebp+var_4], 0
.text$mn:000024DD                 mov     eax, [ebp+var_10]
.text$mn:000024E0                 mov     dword ptr [eax+14h], 0
.text$mn:000024E7                 mov     ecx, [ebp+var_10]
.text$mn:000024EA                 mov     dword ptr [ecx+18h], 0
.text$mn:000024F1                 mov     [ebp+var_4], 0FFFFFFFFh
.text$mn:000024F8                 mov     eax, [ebp+var_10]
.text$mn:000024FB                 mov     ecx, [ebp+var_C]
.text$mn:000024FE                 mov     large fs:0, ecx
.text$mn:00002505                 pop     ecx
.text$mn:00002506                 mov     esp, ebp
.text$mn:00002508                 pop     ebp
.text$mn:00002509                 retn
.text$mn:00002509 ??0?$_String_val@U?$_Simple_types@D@std@@@std@@QAE@XZ endp
.text$mn:00002509
.text$mn:00002509 ; ---------------------------------------------------------------------------
.text$mn:0000250A                 align 4
.text$mn:0000250A _text$mn        ends
.text$mn:0000250A
.text$x:0000250C ; ===========================================================================
.text$x:0000250C
.text$x:0000250C ; Segment type: Pure code
.text$x:0000250C ; Segment permissions: Read/Execute
.text$x:0000250C _text$x         segment para public 'CODE' use32
.text$x:0000250C                 assume cs:_text$x
.text$x:0000250C                 ;org 250Ch
.text$x:0000250C ; COMDAT (pick associative to section at 24A8)
.text$x:0000250C                 assume es:nothing, ss:nothing, ds:_data, fs:nothing, gs:nothing
.text$x:0000250C
.text$x:0000250C ; =============== S U B R O U T I N E =======================================
.text$x:0000250C
.text$x:0000250C
.text$x:0000250C __unwindfunclet$??0?$_String_val@U?$_Simple_types@D@std@@@std@@QAE@XZ$0 proc near
.text$x:0000250C                                         ; DATA XREF: .xdata$x:00004340o
.text$x:0000250C                 mov     ecx, [ebp-10h]  ; this
.text$x:0000250F                 jmp     ??1_Container_base12@std@@QAE@XZ ; std::_Container_base12::~_Container_base12(void)
.text$x:0000250F __unwindfunclet$??0?$_String_val@U?$_Simple_types@D@std@@@std@@QAE@XZ$0 endp
.text$x:0000250F
.text$x:00002514
.text$x:00002514 ; =============== S U B R O U T I N E =======================================
.text$x:00002514
.text$x:00002514
.text$x:00002514 __ehhandler$??0?$_String_val@U?$_Simple_types@D@std@@@std@@QAE@XZ proc near
.text$x:00002514                                         ; DATA XREF: std::_String_val<std::_Simple_types<char>>::_String_val<std::_Simple_types<char>>(void)+5o
.text$x:00002514
.text$x:00002514 arg_4           = dword ptr  8
.text$x:00002514
.text$x:00002514                 mov     edx, [esp+arg_4]
.text$x:00002518                 lea     eax, [edx+0Ch]
.text$x:0000251B                 mov     ecx, [edx-8]
.text$x:0000251E                 xor     ecx, eax
.text$x:00002520                 call    @__security_check_cookie@4 ; __security_check_cookie(x)
.text$x:00002525                 mov     eax, offset __ehfuncinfo$??0?$_String_val@U?$_Simple_types@D@std@@@std@@QAE@XZ
.text$x:0000252A                 jmp     ___CxxFrameHandler3
.text$x:0000252A __ehhandler$??0?$_String_val@U?$_Simple_types@D@std@@@std@@QAE@XZ endp
.text$x:0000252A
.text$x:0000252A ; ---------------------------------------------------------------------------
.text$x:0000252F                 align 10h
.text$x:0000252F _text$x         ends
.text$x:0000252F
.text$mn:00002530 ; ===========================================================================
.text$mn:00002530
.text$mn:00002530 ; Segment type: Pure code
.text$mn:00002530 ; Segment permissions: Read/Execute
.text$mn:00002530 _text$mn        segment para public 'CODE' use32
.text$mn:00002530                 assume cs:_text$mn
.text$mn:00002530                 ;org 2530h
.text$mn:00002530 ; COMDAT (pick any)
.text$mn:00002530                 assume es:nothing, ss:nothing, ds:_data, fs:nothing, gs:nothing
.text$mn:00002530
.text$mn:00002530 ; =============== S U B R O U T I N E =======================================
.text$mn:00002530
.text$mn:00002530 ; Attributes: bp-based frame
.text$mn:00002530
.text$mn:00002530 ; public: __thiscall std::_Vector_alloc<0, struct std::_Vec_base_types<unsigned int, class std::allocator<unsigned int>>>::_Vector_alloc<0, struct std::_Vec_base_types<unsigned int, class std::allocator<unsigned int>>>(class std::allocator<unsigned int> const &)
.text$mn:00002530                 public ??0?$_Vector_alloc@$0A@U?$_Vec_base_types@IV?$allocator@I@std@@@std@@@std@@QAE@ABV?$allocator@I@1@@Z
.text$mn:00002530 ??0?$_Vector_alloc@$0A@U?$_Vec_base_types@IV?$allocator@I@std@@@std@@@std@@QAE@ABV?$allocator@I@1@@Z proc near
.text$mn:00002530                                         ; CODE XREF: std::vector<uint,std::allocator<uint>>::vector<uint,std::allocator<uint>>(void)+34p
.text$mn:00002530
.text$mn:00002530 var_10          = dword ptr -10h
.text$mn:00002530 var_C           = dword ptr -0Ch
.text$mn:00002530 var_4           = dword ptr -4
.text$mn:00002530
.text$mn:00002530                 push    ebp
.text$mn:00002531                 mov     ebp, esp
.text$mn:00002533                 push    0FFFFFFFFh
.text$mn:00002535                 push    offset __ehhandler$??0?$_Vector_alloc@$0A@U?$_Vec_base_types@IV?$allocator@I@std@@@std@@@std@@QAE@ABV?$allocator@I@1@@Z
.text$mn:0000253A                 mov     eax, large fs:0
.text$mn:00002540                 push    eax
.text$mn:00002541                 push    ecx
.text$mn:00002542                 mov     eax, dword ptr ds:___security_cookie
.text$mn:00002547                 xor     eax, ebp
.text$mn:00002549                 push    eax
.text$mn:0000254A                 lea     eax, [ebp+var_C]
.text$mn:0000254D                 mov     large fs:0, eax
.text$mn:00002553                 mov     [ebp+var_10], ecx
.text$mn:00002556                 mov     ecx, [ebp+var_10]
.text$mn:00002559                 call    ??0?$_Vector_val@U?$_Simple_types@I@std@@@std@@QAE@XZ ; std::_Vector_val<std::_Simple_types<uint>>::_Vector_val<std::_Simple_types<uint>>(void)
.text$mn:0000255E                 mov     [ebp+var_4], 0
.text$mn:00002565                 mov     ecx, [ebp+var_10]
.text$mn:00002568                 call    ?_Alloc_proxy@?$_Vector_alloc@$0A@U?$_Vec_base_types@IV?$allocator@I@std@@@std@@@std@@QAEXXZ ; std::_Vector_alloc<0,std::_Vec_base_types<uint,std::allocator<uint>>>::_Alloc_proxy(void)
.text$mn:0000256D                 mov     [ebp+var_4], 0FFFFFFFFh
.text$mn:00002574                 mov     eax, [ebp+var_10]
.text$mn:00002577                 mov     ecx, [ebp+var_C]
.text$mn:0000257A                 mov     large fs:0, ecx
.text$mn:00002581                 pop     ecx
.text$mn:00002582                 mov     esp, ebp
.text$mn:00002584                 pop     ebp
.text$mn:00002585                 retn    4
.text$mn:00002585 ??0?$_Vector_alloc@$0A@U?$_Vec_base_types@IV?$allocator@I@std@@@std@@@std@@QAE@ABV?$allocator@I@1@@Z endp
.text$mn:00002585
.text$mn:00002585 _text$mn        ends
.text$mn:00002585
.text$x:00002588 ; ===========================================================================
.text$x:00002588
.text$x:00002588 ; Segment type: Pure code
.text$x:00002588 ; Segment permissions: Read/Execute
.text$x:00002588 _text$x         segment para public 'CODE' use32
.text$x:00002588                 assume cs:_text$x
.text$x:00002588                 ;org 2588h
.text$x:00002588 ; COMDAT (pick associative to section at 2530)
.text$x:00002588                 assume es:nothing, ss:nothing, ds:_data, fs:nothing, gs:nothing
.text$x:00002588
.text$x:00002588 ; =============== S U B R O U T I N E =======================================
.text$x:00002588
.text$x:00002588
.text$x:00002588 __unwindfunclet$??0?$_Vector_alloc@$0A@U?$_Vec_base_types@IV?$allocator@I@std@@@std@@@std@@QAE@ABV?$allocator@I@1@@Z$0 proc near
.text$x:00002588                                         ; DATA XREF: .xdata$x:000046E4o
.text$x:00002588                 mov     ecx, [ebp-10h]
.text$x:0000258B                 jmp     ??1?$_Vector_val@U?$_Simple_types@I@std@@@std@@QAE@XZ ; std::_Vector_val<std::_Simple_types<uint>>::~_Vector_val<std::_Simple_types<uint>>(void)
.text$x:0000258B __unwindfunclet$??0?$_Vector_alloc@$0A@U?$_Vec_base_types@IV?$allocator@I@std@@@std@@@std@@QAE@ABV?$allocator@I@1@@Z$0 endp
.text$x:0000258B
.text$x:00002590
.text$x:00002590 ; =============== S U B R O U T I N E =======================================
.text$x:00002590
.text$x:00002590
.text$x:00002590 __ehhandler$??0?$_Vector_alloc@$0A@U?$_Vec_base_types@IV?$allocator@I@std@@@std@@@std@@QAE@ABV?$allocator@I@1@@Z proc near
.text$x:00002590                                         ; DATA XREF: std::_Vector_alloc<0,std::_Vec_base_types<uint,std::allocator<uint>>>::_Vector_alloc<0,std::_Vec_base_types<uint,std::allocator<uint>>>(std::allocator<uint> const &)+5o
.text$x:00002590
.text$x:00002590 arg_4           = dword ptr  8
.text$x:00002590
.text$x:00002590                 mov     edx, [esp+arg_4]
.text$x:00002594                 lea     eax, [edx+0Ch]
.text$x:00002597                 mov     ecx, [edx-8]
.text$x:0000259A                 xor     ecx, eax
.text$x:0000259C                 call    @__security_check_cookie@4 ; __security_check_cookie(x)
.text$x:000025A1                 mov     eax, offset __ehfuncinfo$??0?$_Vector_alloc@$0A@U?$_Vec_base_types@IV?$allocator@I@std@@@std@@@std@@QAE@ABV?$allocator@I@1@@Z
.text$x:000025A6                 jmp     ___CxxFrameHandler3
.text$x:000025A6 __ehhandler$??0?$_Vector_alloc@$0A@U?$_Vec_base_types@IV?$allocator@I@std@@@std@@@std@@QAE@ABV?$allocator@I@1@@Z endp
.text$x:000025A6
.text$x:000025A6 ; ---------------------------------------------------------------------------
.text$x:000025AB                 align 4
.text$x:000025AB _text$x         ends
.text$x:000025AB
.text$mn:000025AC ; ===========================================================================
.text$mn:000025AC
.text$mn:000025AC ; Segment type: Pure code
.text$mn:000025AC ; Segment permissions: Read/Execute
.text$mn:000025AC _text$mn        segment para public 'CODE' use32
.text$mn:000025AC                 assume cs:_text$mn
.text$mn:000025AC                 ;org 25ACh
.text$mn:000025AC ; COMDAT (pick any)
.text$mn:000025AC                 assume es:nothing, ss:nothing, ds:_data, fs:nothing, gs:nothing
.text$mn:000025AC
.text$mn:000025AC ; =============== S U B R O U T I N E =======================================
.text$mn:000025AC
.text$mn:000025AC ; Attributes: bp-based frame
.text$mn:000025AC
.text$mn:000025AC ; public: __thiscall std::_Vector_val<struct std::_Simple_types<unsigned int>>::_Vector_val<struct std::_Simple_types<unsigned int>>(void)
.text$mn:000025AC                 public ??0?$_Vector_val@U?$_Simple_types@I@std@@@std@@QAE@XZ
.text$mn:000025AC ??0?$_Vector_val@U?$_Simple_types@I@std@@@std@@QAE@XZ proc near
.text$mn:000025AC                                         ; CODE XREF: std::_Vector_alloc<0,std::_Vec_base_types<uint,std::allocator<uint>>>::_Vector_alloc<0,std::_Vec_base_types<uint,std::allocator<uint>>>(std::allocator<uint> const &)+29p
.text$mn:000025AC
.text$mn:000025AC var_10          = dword ptr -10h
.text$mn:000025AC var_C           = dword ptr -0Ch
.text$mn:000025AC var_4           = dword ptr -4
.text$mn:000025AC
.text$mn:000025AC                 push    ebp
.text$mn:000025AD                 mov     ebp, esp
.text$mn:000025AF                 push    0FFFFFFFFh
.text$mn:000025B1                 push    offset __ehhandler$??0?$_Vector_val@U?$_Simple_types@I@std@@@std@@QAE@XZ
.text$mn:000025B6                 mov     eax, large fs:0
.text$mn:000025BC                 push    eax
.text$mn:000025BD                 push    ecx
.text$mn:000025BE                 mov     eax, dword ptr ds:___security_cookie
.text$mn:000025C3                 xor     eax, ebp
.text$mn:000025C5                 push    eax
.text$mn:000025C6                 lea     eax, [ebp+var_C]
.text$mn:000025C9                 mov     large fs:0, eax
.text$mn:000025CF                 mov     [ebp+var_10], ecx
.text$mn:000025D2                 mov     ecx, [ebp+var_10] ; this
.text$mn:000025D5                 call    ??0_Container_base12@std@@QAE@XZ ; std::_Container_base12::_Container_base12(void)
.text$mn:000025DA                 mov     [ebp+var_4], 0
.text$mn:000025E1                 mov     eax, [ebp+var_10]
.text$mn:000025E4                 mov     dword ptr [eax+4], 0
.text$mn:000025EB                 mov     ecx, [ebp+var_10]
.text$mn:000025EE                 mov     dword ptr [ecx+8], 0
.text$mn:000025F5                 mov     edx, [ebp+var_10]
.text$mn:000025F8                 mov     dword ptr [edx+0Ch], 0
.text$mn:000025FF                 mov     [ebp+var_4], 0FFFFFFFFh
.text$mn:00002606                 mov     eax, [ebp+var_10]
.text$mn:00002609                 mov     ecx, [ebp+var_C]
.text$mn:0000260C                 mov     large fs:0, ecx
.text$mn:00002613                 pop     ecx
.text$mn:00002614                 mov     esp, ebp
.text$mn:00002616                 pop     ebp
.text$mn:00002617                 retn
.text$mn:00002617 ??0?$_Vector_val@U?$_Simple_types@I@std@@@std@@QAE@XZ endp
.text$mn:00002617
.text$mn:00002617 _text$mn        ends
.text$mn:00002617
.text$x:00002618 ; ===========================================================================
.text$x:00002618
.text$x:00002618 ; Segment type: Pure code
.text$x:00002618 ; Segment permissions: Read/Execute
.text$x:00002618 _text$x         segment para public 'CODE' use32
.text$x:00002618                 assume cs:_text$x
.text$x:00002618                 ;org 2618h
.text$x:00002618 ; COMDAT (pick associative to section at 25AC)
.text$x:00002618                 assume es:nothing, ss:nothing, ds:_data, fs:nothing, gs:nothing
.text$x:00002618
.text$x:00002618 ; =============== S U B R O U T I N E =======================================
.text$x:00002618
.text$x:00002618
.text$x:00002618 __unwindfunclet$??0?$_Vector_val@U?$_Simple_types@I@std@@@std@@QAE@XZ$0 proc near
.text$x:00002618                                         ; DATA XREF: .xdata$x:0000468Co
.text$x:00002618                 mov     ecx, [ebp-10h]  ; this
.text$x:0000261B                 jmp     ??1_Container_base12@std@@QAE@XZ ; std::_Container_base12::~_Container_base12(void)
.text$x:0000261B __unwindfunclet$??0?$_Vector_val@U?$_Simple_types@I@std@@@std@@QAE@XZ$0 endp
.text$x:0000261B
.text$x:00002620
.text$x:00002620 ; =============== S U B R O U T I N E =======================================
.text$x:00002620
.text$x:00002620
.text$x:00002620 __ehhandler$??0?$_Vector_val@U?$_Simple_types@I@std@@@std@@QAE@XZ proc near
.text$x:00002620                                         ; DATA XREF: std::_Vector_val<std::_Simple_types<uint>>::_Vector_val<std::_Simple_types<uint>>(void)+5o
.text$x:00002620
.text$x:00002620 arg_4           = dword ptr  8
.text$x:00002620
.text$x:00002620                 mov     edx, [esp+arg_4]
.text$x:00002624                 lea     eax, [edx+0Ch]
.text$x:00002627                 mov     ecx, [edx-8]
.text$x:0000262A                 xor     ecx, eax
.text$x:0000262C                 call    @__security_check_cookie@4 ; __security_check_cookie(x)
.text$x:00002631                 mov     eax, offset __ehfuncinfo$??0?$_Vector_val@U?$_Simple_types@I@std@@@std@@QAE@XZ
.text$x:00002636                 jmp     ___CxxFrameHandler3
.text$x:00002636 __ehhandler$??0?$_Vector_val@U?$_Simple_types@I@std@@@std@@QAE@XZ endp
.text$x:00002636
.text$x:00002636 ; ---------------------------------------------------------------------------
.text$x:0000263B                 align 4
.text$x:0000263B _text$x         ends
.text$x:0000263B
.text$mn:0000263C ; ===========================================================================
.text$mn:0000263C
.text$mn:0000263C ; Segment type: Pure code
.text$mn:0000263C ; Segment permissions: Read/Execute
.text$mn:0000263C _text$mn        segment para public 'CODE' use32
.text$mn:0000263C                 assume cs:_text$mn
.text$mn:0000263C                 ;org 263Ch
.text$mn:0000263C ; COMDAT (pick any)
.text$mn:0000263C                 assume es:nothing, ss:nothing, ds:_data, fs:nothing, gs:nothing
.text$mn:0000263C
.text$mn:0000263C ; =============== S U B R O U T I N E =======================================
.text$mn:0000263C
.text$mn:0000263C ; Attributes: bp-based frame
.text$mn:0000263C
.text$mn:0000263C ; public: __thiscall std::_Wrap_alloc<class std::allocator<char>>::_Wrap_alloc<class std::allocator<char>>(void)
.text$mn:0000263C                 public ??0?$_Wrap_alloc@V?$allocator@D@std@@@std@@QAE@XZ
.text$mn:0000263C ??0?$_Wrap_alloc@V?$allocator@D@std@@@std@@QAE@XZ proc near
.text$mn:0000263C                                         ; CODE XREF: std::_String_alloc<0,std::_String_base_types<char,std::allocator<char>>>::_Getal(void)+Ap
.text$mn:0000263C
.text$mn:0000263C var_4           = dword ptr -4
.text$mn:0000263C
.text$mn:0000263C                 push    ebp
.text$mn:0000263D                 mov     ebp, esp
.text$mn:0000263F                 push    ecx
.text$mn:00002640                 mov     [ebp+var_4], ecx
.text$mn:00002643                 mov     ecx, [ebp+var_4]
.text$mn:00002646                 call    ??0?$allocator@D@std@@QAE@XZ ; std::allocator<char>::allocator<char>(void)
.text$mn:0000264B                 mov     eax, [ebp+var_4]
.text$mn:0000264E                 mov     esp, ebp
.text$mn:00002650                 pop     ebp
.text$mn:00002651                 retn
.text$mn:00002651 ??0?$_Wrap_alloc@V?$allocator@D@std@@@std@@QAE@XZ endp
.text$mn:00002651
.text$mn:00002651 ; ---------------------------------------------------------------------------
.text$mn:00002652                 align 4
.text$mn:00002652 _text$mn        ends
.text$mn:00002652
.text$mn:00002654 ; ===========================================================================
.text$mn:00002654
.text$mn:00002654 ; Segment type: Pure code
.text$mn:00002654 ; Segment permissions: Read/Execute
.text$mn:00002654 _text$mn        segment para public 'CODE' use32
.text$mn:00002654                 assume cs:_text$mn
.text$mn:00002654                 ;org 2654h
.text$mn:00002654 ; COMDAT (pick any)
.text$mn:00002654                 assume es:nothing, ss:nothing, ds:_data, fs:nothing, gs:nothing
.text$mn:00002654
.text$mn:00002654 ; =============== S U B R O U T I N E =======================================
.text$mn:00002654
.text$mn:00002654 ; Attributes: bp-based frame
.text$mn:00002654
.text$mn:00002654 ; public: __thiscall std::_Wrap_alloc<class std::allocator<unsigned int>>::_Wrap_alloc<class std::allocator<unsigned int>>(void)
.text$mn:00002654                 public ??0?$_Wrap_alloc@V?$allocator@I@std@@@std@@QAE@XZ
.text$mn:00002654 ??0?$_Wrap_alloc@V?$allocator@I@std@@@std@@QAE@XZ proc near
.text$mn:00002654                                         ; CODE XREF: std::_Vector_alloc<0,std::_Vec_base_types<uint,std::allocator<uint>>>::_Getal(void)+Ap
.text$mn:00002654
.text$mn:00002654 var_4           = dword ptr -4
.text$mn:00002654
.text$mn:00002654                 push    ebp
.text$mn:00002655                 mov     ebp, esp
.text$mn:00002657                 push    ecx
.text$mn:00002658                 mov     [ebp+var_4], ecx
.text$mn:0000265B                 mov     ecx, [ebp+var_4]
.text$mn:0000265E                 call    ??0?$allocator@I@std@@QAE@XZ ; std::allocator<uint>::allocator<uint>(void)
.text$mn:00002663                 mov     eax, [ebp+var_4]
.text$mn:00002666                 mov     esp, ebp
.text$mn:00002668                 pop     ebp
.text$mn:00002669                 retn
.text$mn:00002669 ??0?$_Wrap_alloc@V?$allocator@I@std@@@std@@QAE@XZ endp
.text$mn:00002669
.text$mn:00002669 ; ---------------------------------------------------------------------------
.text$mn:0000266A                 align 4
.text$mn:0000266A _text$mn        ends
.text$mn:0000266A
.text$mn:0000266C ; ===========================================================================
.text$mn:0000266C
.text$mn:0000266C ; Segment type: Pure code
.text$mn:0000266C ; Segment permissions: Read/Execute
.text$mn:0000266C _text$mn        segment para public 'CODE' use32
.text$mn:0000266C                 assume cs:_text$mn
.text$mn:0000266C                 ;org 266Ch
.text$mn:0000266C ; COMDAT (pick any)
.text$mn:0000266C                 assume es:nothing, ss:nothing, ds:_data, fs:nothing, gs:nothing
.text$mn:0000266C
.text$mn:0000266C ; =============== S U B R O U T I N E =======================================
.text$mn:0000266C
.text$mn:0000266C ; Attributes: bp-based frame
.text$mn:0000266C
.text$mn:0000266C ; public: __thiscall std::_Wrap_alloc<class std::allocator<struct std::_Container_proxy>>::_Wrap_alloc<class std::allocator<struct std::_Container_proxy>>(void)
.text$mn:0000266C                 public ??0?$_Wrap_alloc@V?$allocator@U_Container_proxy@std@@@std@@@std@@QAE@XZ
.text$mn:0000266C ??0?$_Wrap_alloc@V?$allocator@U_Container_proxy@std@@@std@@@std@@QAE@XZ proc near
.text$mn:0000266C                                         ; CODE XREF: std::_Vector_alloc<0,std::_Vec_base_types<uint,std::allocator<uint>>>::_Alloc_proxy(void)+Cp
.text$mn:0000266C                                         ; std::_Vector_alloc<0,std::_Vec_base_types<uint,std::allocator<uint>>>::_Free_proxy(void)+Cp
.text$mn:0000266C
.text$mn:0000266C var_4           = dword ptr -4
.text$mn:0000266C
.text$mn:0000266C                 push    ebp
.text$mn:0000266D                 mov     ebp, esp
.text$mn:0000266F                 push    ecx
.text$mn:00002670                 mov     [ebp+var_4], ecx
.text$mn:00002673                 mov     ecx, [ebp+var_4]
.text$mn:00002676                 call    ??0?$allocator@U_Container_proxy@std@@@std@@QAE@XZ ; std::allocator<std::_Container_proxy>::allocator<std::_Container_proxy>(void)
.text$mn:0000267B                 mov     eax, [ebp+var_4]
.text$mn:0000267E                 mov     esp, ebp
.text$mn:00002680                 pop     ebp
.text$mn:00002681                 retn
.text$mn:00002681 ??0?$_Wrap_alloc@V?$allocator@U_Container_proxy@std@@@std@@@std@@QAE@XZ endp
.text$mn:00002681
.text$mn:00002681 ; ---------------------------------------------------------------------------
.text$mn:00002682                 align 4
.text$mn:00002682 _text$mn        ends
.text$mn:00002682
.text$mn:00002684 ; ===========================================================================
.text$mn:00002684
.text$mn:00002684 ; Segment type: Pure code
.text$mn:00002684 ; Segment permissions: Read/Execute
.text$mn:00002684 _text$mn        segment para public 'CODE' use32
.text$mn:00002684                 assume cs:_text$mn
.text$mn:00002684                 ;org 2684h
.text$mn:00002684 ; COMDAT (pick any)
.text$mn:00002684                 assume es:nothing, ss:nothing, ds:_data, fs:nothing, gs:nothing
.text$mn:00002684
.text$mn:00002684 ; =============== S U B R O U T I N E =======================================
.text$mn:00002684
.text$mn:00002684 ; Attributes: bp-based frame
.text$mn:00002684
.text$mn:00002684 ; public: __thiscall std::allocator<char>::allocator<char>(void)
.text$mn:00002684                 public ??0?$allocator@D@std@@QAE@XZ
.text$mn:00002684 ??0?$allocator@D@std@@QAE@XZ proc near  ; CODE XREF: std::_Wrap_alloc<std::allocator<char>>::_Wrap_alloc<std::allocator<char>>(void)+Ap
.text$mn:00002684                                         ; std::basic_string<char,std::char_traits<char>,std::allocator<char>>::basic_string<char,std::char_traits<char>,std::allocator<char>>(char const *)+2Bp
.text$mn:00002684
.text$mn:00002684 var_4           = dword ptr -4
.text$mn:00002684
.text$mn:00002684                 push    ebp
.text$mn:00002685                 mov     ebp, esp
.text$mn:00002687                 push    ecx
.text$mn:00002688                 mov     [ebp+var_4], ecx
.text$mn:0000268B                 mov     eax, [ebp+var_4]
.text$mn:0000268E                 mov     esp, ebp
.text$mn:00002690                 pop     ebp
.text$mn:00002691                 retn
.text$mn:00002691 ??0?$allocator@D@std@@QAE@XZ endp
.text$mn:00002691
.text$mn:00002691 ; ---------------------------------------------------------------------------
.text$mn:00002692                 align 4
.text$mn:00002692 _text$mn        ends
.text$mn:00002692
.text$mn:00002694 ; ===========================================================================
.text$mn:00002694
.text$mn:00002694 ; Segment type: Pure code
.text$mn:00002694 ; Segment permissions: Read/Execute
.text$mn:00002694 _text$mn        segment para public 'CODE' use32
.text$mn:00002694                 assume cs:_text$mn
.text$mn:00002694                 ;org 2694h
.text$mn:00002694 ; COMDAT (pick any)
.text$mn:00002694                 assume es:nothing, ss:nothing, ds:_data, fs:nothing, gs:nothing
.text$mn:00002694
.text$mn:00002694 ; =============== S U B R O U T I N E =======================================
.text$mn:00002694
.text$mn:00002694 ; Attributes: bp-based frame
.text$mn:00002694
.text$mn:00002694 ; public: __thiscall std::allocator<unsigned int>::allocator<unsigned int>(void)
.text$mn:00002694                 public ??0?$allocator@I@std@@QAE@XZ
.text$mn:00002694 ??0?$allocator@I@std@@QAE@XZ proc near  ; CODE XREF: std::_Wrap_alloc<std::allocator<uint>>::_Wrap_alloc<std::allocator<uint>>(void)+Ap
.text$mn:00002694                                         ; std::vector<uint,std::allocator<uint>>::vector<uint,std::allocator<uint>>(void)+2Bp
.text$mn:00002694
.text$mn:00002694 var_4           = dword ptr -4
.text$mn:00002694
.text$mn:00002694                 push    ebp
.text$mn:00002695                 mov     ebp, esp
.text$mn:00002697                 push    ecx
.text$mn:00002698                 mov     [ebp+var_4], ecx
.text$mn:0000269B                 mov     eax, [ebp+var_4]
.text$mn:0000269E                 mov     esp, ebp
.text$mn:000026A0                 pop     ebp
.text$mn:000026A1                 retn
.text$mn:000026A1 ??0?$allocator@I@std@@QAE@XZ endp
.text$mn:000026A1
.text$mn:000026A1 ; ---------------------------------------------------------------------------
.text$mn:000026A2                 align 4
.text$mn:000026A2 _text$mn        ends
.text$mn:000026A2
.text$mn:000026A4 ; ===========================================================================
.text$mn:000026A4
.text$mn:000026A4 ; Segment type: Pure code
.text$mn:000026A4 ; Segment permissions: Read/Execute
.text$mn:000026A4 _text$mn        segment para public 'CODE' use32
.text$mn:000026A4                 assume cs:_text$mn
.text$mn:000026A4                 ;org 26A4h
.text$mn:000026A4 ; COMDAT (pick any)
.text$mn:000026A4                 assume es:nothing, ss:nothing, ds:_data, fs:nothing, gs:nothing
.text$mn:000026A4
.text$mn:000026A4 ; =============== S U B R O U T I N E =======================================
.text$mn:000026A4
.text$mn:000026A4 ; Attributes: bp-based frame
.text$mn:000026A4
.text$mn:000026A4 ; public: __thiscall std::allocator<struct std::_Container_proxy>::allocator<struct std::_Container_proxy>(void)
.text$mn:000026A4                 public ??0?$allocator@U_Container_proxy@std@@@std@@QAE@XZ
.text$mn:000026A4 ??0?$allocator@U_Container_proxy@std@@@std@@QAE@XZ proc near
.text$mn:000026A4                                         ; CODE XREF: std::_Wrap_alloc<std::allocator<std::_Container_proxy>>::_Wrap_alloc<std::allocator<std::_Container_proxy>>(void)+Ap
.text$mn:000026A4                                         ; std::_String_alloc<0,std::_String_base_types<char,std::allocator<char>>>::_Alloc_proxy(void)+Cp ...
.text$mn:000026A4
.text$mn:000026A4 var_4           = dword ptr -4
.text$mn:000026A4
.text$mn:000026A4                 push    ebp
.text$mn:000026A5                 mov     ebp, esp
.text$mn:000026A7                 push    ecx
.text$mn:000026A8                 mov     [ebp+var_4], ecx
.text$mn:000026AB                 mov     eax, [ebp+var_4]
.text$mn:000026AE                 mov     esp, ebp
.text$mn:000026B0                 pop     ebp
.text$mn:000026B1                 retn
.text$mn:000026B1 ??0?$allocator@U_Container_proxy@std@@@std@@QAE@XZ endp
.text$mn:000026B1
.text$mn:000026B1 ; ---------------------------------------------------------------------------
.text$mn:000026B2                 align 4
.text$mn:000026B2 _text$mn        ends
.text$mn:000026B2
.text$mn:000026B4 ; ===========================================================================
.text$mn:000026B4
.text$mn:000026B4 ; Segment type: Pure code
.text$mn:000026B4 ; Segment permissions: Read/Execute
.text$mn:000026B4 _text$mn        segment para public 'CODE' use32
.text$mn:000026B4                 assume cs:_text$mn
.text$mn:000026B4                 ;org 26B4h
.text$mn:000026B4 ; COMDAT (pick any)
.text$mn:000026B4                 assume es:nothing, ss:nothing, ds:_data, fs:nothing, gs:nothing
.text$mn:000026B4
.text$mn:000026B4 ; =============== S U B R O U T I N E =======================================
.text$mn:000026B4
.text$mn:000026B4 ; Attributes: bp-based frame
.text$mn:000026B4
.text$mn:000026B4 ; int __stdcall std::basic_string<char,std::char_traits<char>,std::allocator<char>>::basic_string<char,std::char_traits<char>,std::allocator<char>>(char *Str)
.text$mn:000026B4                 public ??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@PBD@Z
.text$mn:000026B4 ??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@PBD@Z proc near
.text$mn:000026B4                                         ; CODE XREF: std::_Generic_error_category::message(int)+5Ap
.text$mn:000026B4                                         ; std::_Iostream_error_category::message(int)+3Dp ...
.text$mn:000026B4
.text$mn:000026B4 var_14          = dword ptr -14h
.text$mn:000026B4 var_D           = byte ptr -0Dh
.text$mn:000026B4 var_C           = dword ptr -0Ch
.text$mn:000026B4 var_4           = dword ptr -4
.text$mn:000026B4 Str             = dword ptr  8
.text$mn:000026B4
.text$mn:000026B4                 push    ebp
.text$mn:000026B5                 mov     ebp, esp
.text$mn:000026B7                 push    0FFFFFFFFh
.text$mn:000026B9                 push    offset __ehhandler$??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@PBD@Z
.text$mn:000026BE                 mov     eax, large fs:0
.text$mn:000026C4                 push    eax
.text$mn:000026C5                 sub     esp, 8
.text$mn:000026C8                 mov     eax, dword ptr ds:___security_cookie
.text$mn:000026CD                 xor     eax, ebp
.text$mn:000026CF                 push    eax
.text$mn:000026D0                 lea     eax, [ebp+var_C]
.text$mn:000026D3                 mov     large fs:0, eax
.text$mn:000026D9                 mov     [ebp+var_14], ecx
.text$mn:000026DC                 lea     ecx, [ebp+var_D]
.text$mn:000026DF                 call    ??0?$allocator@D@std@@QAE@XZ ; std::allocator<char>::allocator<char>(void)
.text$mn:000026E4                 push    eax
.text$mn:000026E5                 mov     ecx, [ebp+var_14]
.text$mn:000026E8                 call    ??0?$_String_alloc@$0A@U?$_String_base_types@DV?$allocator@D@std@@@std@@@std@@QAE@ABV?$allocator@D@1@@Z ; std::_String_alloc<0,std::_String_base_types<char,std::allocator<char>>>::_String_alloc<0,std::_String_base_types<char,std::allocator<char>>>(std::allocator<char> const &)
.text$mn:000026ED                 mov     [ebp+var_4], 0
.text$mn:000026F4                 push    0               ; Size
.text$mn:000026F6                 push    0               ; char
.text$mn:000026F8                 mov     ecx, [ebp+var_14]
.text$mn:000026FB                 call    ?_Tidy@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEX_NI@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char>>::_Tidy(bool,uint)
.text$mn:00002700                 mov     eax, [ebp+Str]
.text$mn:00002703                 push    eax             ; Str
.text$mn:00002704                 mov     ecx, [ebp+var_14]
.text$mn:00002707                 call    ?assign@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV12@PBD@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char>>::assign(char const *)
.text$mn:0000270C                 mov     [ebp+var_4], 0FFFFFFFFh
.text$mn:00002713                 mov     eax, [ebp+var_14]
.text$mn:00002716                 mov     ecx, [ebp+var_C]
.text$mn:00002719                 mov     large fs:0, ecx
.text$mn:00002720                 pop     ecx
.text$mn:00002721                 mov     esp, ebp
.text$mn:00002723                 pop     ebp
.text$mn:00002724                 retn    4
.text$mn:00002724 ??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@PBD@Z endp
.text$mn:00002724
.text$mn:00002724 ; ---------------------------------------------------------------------------
.text$mn:00002727                 align 4
.text$mn:00002727 _text$mn        ends
.text$mn:00002727
.text$x:00002728 ; ===========================================================================
.text$x:00002728
.text$x:00002728 ; Segment type: Pure code
.text$x:00002728 ; Segment permissions: Read/Execute
.text$x:00002728 _text$x         segment para public 'CODE' use32
.text$x:00002728                 assume cs:_text$x
.text$x:00002728                 ;org 2728h
.text$x:00002728 ; COMDAT (pick associative to section at 26B4)
.text$x:00002728                 assume es:nothing, ss:nothing, ds:_data, fs:nothing, gs:nothing
.text$x:00002728
.text$x:00002728 ; =============== S U B R O U T I N E =======================================
.text$x:00002728
.text$x:00002728
.text$x:00002728 __unwindfunclet$??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@PBD@Z$0 proc near
.text$x:00002728                                         ; DATA XREF: .xdata$x:000043F0o
.text$x:00002728                 mov     ecx, [ebp-14h]
.text$x:0000272B                 jmp     ??1?$_String_alloc@$0A@U?$_String_base_types@DV?$allocator@D@std@@@std@@@std@@QAE@XZ ; std::_String_alloc<0,std::_String_base_types<char,std::allocator<char>>>::~_String_alloc<0,std::_String_base_types<char,std::allocator<char>>>(void)
.text$x:0000272B __unwindfunclet$??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@PBD@Z$0 endp
.text$x:0000272B
.text$x:00002730
.text$x:00002730 ; =============== S U B R O U T I N E =======================================
.text$x:00002730
.text$x:00002730
.text$x:00002730 __ehhandler$??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@PBD@Z proc near
.text$x:00002730                                         ; DATA XREF: std::basic_string<char,std::char_traits<char>,std::allocator<char>>::basic_string<char,std::char_traits<char>,std::allocator<char>>(char const *)+5o
.text$x:00002730
.text$x:00002730 arg_4           = dword ptr  8
.text$x:00002730
.text$x:00002730                 mov     edx, [esp+arg_4]
.text$x:00002734                 lea     eax, [edx+0Ch]
.text$x:00002737                 mov     ecx, [edx-0Ch]
.text$x:0000273A                 xor     ecx, eax
.text$x:0000273C                 call    @__security_check_cookie@4 ; __security_check_cookie(x)
.text$x:00002741                 mov     eax, offset __ehfuncinfo$??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@PBD@Z
.text$x:00002746                 jmp     ___CxxFrameHandler3
.text$x:00002746 __ehhandler$??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@PBD@Z endp
.text$x:00002746
.text$x:00002746 ; ---------------------------------------------------------------------------
.text$x:0000274B                 align 4
.text$x:0000274B _text$x         ends
.text$x:0000274B
.text$mn:0000274C ; ===========================================================================
.text$mn:0000274C
.text$mn:0000274C ; Segment type: Pure code
.text$mn:0000274C ; Segment permissions: Read/Execute
.text$mn:0000274C _text$mn        segment para public 'CODE' use32
.text$mn:0000274C                 assume cs:_text$mn
.text$mn:0000274C                 ;org 274Ch
.text$mn:0000274C ; COMDAT (pick any)
.text$mn:0000274C                 assume es:nothing, ss:nothing, ds:_data, fs:nothing, gs:nothing
.text$mn:0000274C
.text$mn:0000274C ; =============== S U B R O U T I N E =======================================
.text$mn:0000274C
.text$mn:0000274C ; Attributes: bp-based frame
.text$mn:0000274C
.text$mn:0000274C ; public: __thiscall std::vector<unsigned int, class std::allocator<unsigned int>>::vector<unsigned int, class std::allocator<unsigned int>>(void)
.text$mn:0000274C                 public ??0?$vector@IV?$allocator@I@std@@@std@@QAE@XZ
.text$mn:0000274C ??0?$vector@IV?$allocator@I@std@@@std@@QAE@XZ proc near
.text$mn:0000274C                                         ; CODE XREF: DocumentMap::reloadMap(void)+93p
.text$mn:0000274C
.text$mn:0000274C var_14          = dword ptr -14h
.text$mn:0000274C var_D           = byte ptr -0Dh
.text$mn:0000274C var_C           = dword ptr -0Ch
.text$mn:0000274C var_4           = dword ptr -4
.text$mn:0000274C
.text$mn:0000274C                 push    ebp
.text$mn:0000274D                 mov     ebp, esp
.text$mn:0000274F                 push    0FFFFFFFFh
.text$mn:00002751                 push    offset __ehhandler$??0?$vector@IV?$allocator@I@std@@@std@@QAE@XZ
.text$mn:00002756                 mov     eax, large fs:0
.text$mn:0000275C                 push    eax
.text$mn:0000275D                 sub     esp, 8
.text$mn:00002760                 mov     eax, dword ptr ds:___security_cookie
.text$mn:00002765                 xor     eax, ebp
.text$mn:00002767                 push    eax
.text$mn:00002768                 lea     eax, [ebp+var_C]
.text$mn:0000276B                 mov     large fs:0, eax
.text$mn:00002771                 mov     [ebp+var_14], ecx
.text$mn:00002774                 lea     ecx, [ebp+var_D]
.text$mn:00002777                 call    ??0?$allocator@I@std@@QAE@XZ ; std::allocator<uint>::allocator<uint>(void)
.text$mn:0000277C                 push    eax
.text$mn:0000277D                 mov     ecx, [ebp+var_14]
.text$mn:00002780                 call    ??0?$_Vector_alloc@$0A@U?$_Vec_base_types@IV?$allocator@I@std@@@std@@@std@@QAE@ABV?$allocator@I@1@@Z ; std::_Vector_alloc<0,std::_Vec_base_types<uint,std::allocator<uint>>>::_Vector_alloc<0,std::_Vec_base_types<uint,std::allocator<uint>>>(std::allocator<uint> const &)
.text$mn:00002785                 mov     [ebp+var_4], 0
.text$mn:0000278C                 mov     [ebp+var_4], 0FFFFFFFFh
.text$mn:00002793                 mov     eax, [ebp+var_14]
.text$mn:00002796                 mov     ecx, [ebp+var_C]
.text$mn:00002799                 mov     large fs:0, ecx
.text$mn:000027A0                 pop     ecx
.text$mn:000027A1                 mov     esp, ebp
.text$mn:000027A3                 pop     ebp
.text$mn:000027A4                 retn
.text$mn:000027A4 ??0?$vector@IV?$allocator@I@std@@@std@@QAE@XZ endp
.text$mn:000027A4
.text$mn:000027A4 ; ---------------------------------------------------------------------------
.text$mn:000027A5                 align 4
.text$mn:000027A5 _text$mn        ends
.text$mn:000027A5
.text$x:000027A8 ; ===========================================================================
.text$x:000027A8
.text$x:000027A8 ; Segment type: Pure code
.text$x:000027A8 ; Segment permissions: Read/Execute
.text$x:000027A8 _text$x         segment para public 'CODE' use32
.text$x:000027A8                 assume cs:_text$x
.text$x:000027A8                 ;org 27A8h
.text$x:000027A8 ; COMDAT (pick associative to section at 274C)
.text$x:000027A8                 assume es:nothing, ss:nothing, ds:_data, fs:nothing, gs:nothing
.text$x:000027A8
.text$x:000027A8 ; =============== S U B R O U T I N E =======================================
.text$x:000027A8
.text$x:000027A8
.text$x:000027A8 __unwindfunclet$??0?$vector@IV?$allocator@I@std@@@std@@QAE@XZ$0 proc near
.text$x:000027A8                                         ; DATA XREF: .xdata$x:0000473Co
.text$x:000027A8                 mov     ecx, [ebp-14h]
.text$x:000027AB                 jmp     ??1?$_Vector_alloc@$0A@U?$_Vec_base_types@IV?$allocator@I@std@@@std@@@std@@QAE@XZ ; std::_Vector_alloc<0,std::_Vec_base_types<uint,std::allocator<uint>>>::~_Vector_alloc<0,std::_Vec_base_types<uint,std::allocator<uint>>>(void)
.text$x:000027AB __unwindfunclet$??0?$vector@IV?$allocator@I@std@@@std@@QAE@XZ$0 endp
.text$x:000027AB
.text$x:000027B0
.text$x:000027B0 ; =============== S U B R O U T I N E =======================================
.text$x:000027B0
.text$x:000027B0
.text$x:000027B0 __ehhandler$??0?$vector@IV?$allocator@I@std@@@std@@QAE@XZ proc near
.text$x:000027B0                                         ; DATA XREF: std::vector<uint,std::allocator<uint>>::vector<uint,std::allocator<uint>>(void)+5o
.text$x:000027B0
.text$x:000027B0 arg_4           = dword ptr  8
.text$x:000027B0
.text$x:000027B0                 mov     edx, [esp+arg_4]
.text$x:000027B4                 lea     eax, [edx+0Ch]
.text$x:000027B7                 mov     ecx, [edx-0Ch]
.text$x:000027BA                 xor     ecx, eax
.text$x:000027BC                 call    @__security_check_cookie@4 ; __security_check_cookie(x)
.text$x:000027C1                 mov     eax, offset __ehfuncinfo$??0?$vector@IV?$allocator@I@std@@@std@@QAE@XZ
.text$x:000027C6                 jmp     ___CxxFrameHandler3
.text$x:000027C6 __ehhandler$??0?$vector@IV?$allocator@I@std@@@std@@QAE@XZ endp
.text$x:000027C6
.text$x:000027C6 ; ---------------------------------------------------------------------------
.text$x:000027CB                 align 4
.text$x:000027CB _text$x         ends
.text$x:000027CB
.text$mn:000027CC ; ===========================================================================
.text$mn:000027CC
.text$mn:000027CC ; Segment type: Pure code
.text$mn:000027CC ; Segment permissions: Read/Execute
.text$mn:000027CC _text$mn        segment para public 'CODE' use32
.text$mn:000027CC                 assume cs:_text$mn
.text$mn:000027CC                 ;org 27CCh
.text$mn:000027CC ; COMDAT (pick any)
.text$mn:000027CC                 assume es:nothing, ss:nothing, ds:_data, fs:nothing, gs:nothing
.text$mn:000027CC
.text$mn:000027CC ; =============== S U B R O U T I N E =======================================
.text$mn:000027CC
.text$mn:000027CC ; Attributes: bp-based frame
.text$mn:000027CC
.text$mn:000027CC ; _DWORD __thiscall std::_Container_base12::_Container_base12(std::_Container_base12 *__hidden this)
.text$mn:000027CC                 public ??0_Container_base12@std@@QAE@XZ
.text$mn:000027CC ??0_Container_base12@std@@QAE@XZ proc near
.text$mn:000027CC                                         ; CODE XREF: std::_String_val<std::_Simple_types<char>>::_String_val<std::_Simple_types<char>>(void)+29p
.text$mn:000027CC                                         ; std::_Vector_val<std::_Simple_types<uint>>::_Vector_val<std::_Simple_types<uint>>(void)+29p
.text$mn:000027CC
.text$mn:000027CC var_4           = dword ptr -4
.text$mn:000027CC
.text$mn:000027CC                 push    ebp
.text$mn:000027CD                 mov     ebp, esp
.text$mn:000027CF                 push    ecx
.text$mn:000027D0                 mov     [ebp+var_4], ecx
.text$mn:000027D3                 mov     eax, [ebp+var_4]
.text$mn:000027D6                 mov     dword ptr [eax], 0
.text$mn:000027DC                 mov     eax, [ebp+var_4]
.text$mn:000027DF                 mov     esp, ebp
.text$mn:000027E1                 pop     ebp
.text$mn:000027E2                 retn
.text$mn:000027E2 ??0_Container_base12@std@@QAE@XZ endp
.text$mn:000027E2
.text$mn:000027E2 ; ---------------------------------------------------------------------------
.text$mn:000027E3                 align 4
.text$mn:000027E3 _text$mn        ends
.text$mn:000027E3
.text$mn:000027E4 ; ===========================================================================
.text$mn:000027E4
.text$mn:000027E4 ; Segment type: Pure code
.text$mn:000027E4 ; Segment permissions: Read/Execute
.text$mn:000027E4 _text$mn        segment para public 'CODE' use32
.text$mn:000027E4                 assume cs:_text$mn
.text$mn:000027E4                 ;org 27E4h
.text$mn:000027E4 ; COMDAT (pick any)
.text$mn:000027E4                 assume es:nothing, ss:nothing, ds:_data, fs:nothing, gs:nothing
.text$mn:000027E4
.text$mn:000027E4 ; =============== S U B R O U T I N E =======================================
.text$mn:000027E4
.text$mn:000027E4 ; Attributes: bp-based frame
.text$mn:000027E4
.text$mn:000027E4 ; _DWORD __thiscall std::_Container_proxy::_Container_proxy(std::_Container_proxy *__hidden this)
.text$mn:000027E4                 public ??0_Container_proxy@std@@QAE@XZ
.text$mn:000027E4 ??0_Container_proxy@std@@QAE@XZ proc near
.text$mn:000027E4                                         ; CODE XREF: std::_String_alloc<0,std::_String_base_types<char,std::allocator<char>>>::_Alloc_proxy(void)+23p
.text$mn:000027E4                                         ; std::_Vector_alloc<0,std::_Vec_base_types<uint,std::allocator<uint>>>::_Alloc_proxy(void)+23p
.text$mn:000027E4
.text$mn:000027E4 var_4           = dword ptr -4
.text$mn:000027E4
.text$mn:000027E4                 push    ebp
.text$mn:000027E5                 mov     ebp, esp
.text$mn:000027E7                 push    ecx
.text$mn:000027E8                 mov     [ebp+var_4], ecx
.text$mn:000027EB                 mov     eax, [ebp+var_4]
.text$mn:000027EE                 mov     dword ptr [eax], 0
.text$mn:000027F4                 mov     ecx, [ebp+var_4]
.text$mn:000027F7                 mov     dword ptr [ecx+4], 0
.text$mn:000027FE                 mov     eax, [ebp+var_4]
.text$mn:00002801                 mov     esp, ebp
.text$mn:00002803                 pop     ebp
.text$mn:00002804                 retn
.text$mn:00002804 ??0_Container_proxy@std@@QAE@XZ endp
.text$mn:00002804
.text$mn:00002804 ; ---------------------------------------------------------------------------
.text$mn:00002805                 align 4
.text$mn:00002805 _text$mn        ends
.text$mn:00002805
.text$mn:00002808 ; ===========================================================================
.text$mn:00002808
.text$mn:00002808 ; Segment type: Pure code
.text$mn:00002808 ; Segment permissions: Read/Execute
.text$mn:00002808 _text$mn        segment para public 'CODE' use32
.text$mn:00002808                 assume cs:_text$mn
.text$mn:00002808                 ;org 2808h
.text$mn:00002808 ; COMDAT (pick any)
.text$mn:00002808                 assume es:nothing, ss:nothing, ds:_data, fs:nothing, gs:nothing
.text$mn:00002808
.text$mn:00002808 ; =============== S U B R O U T I N E =======================================
.text$mn:00002808
.text$mn:00002808 ; Attributes: bp-based frame
.text$mn:00002808
.text$mn:00002808 ; _DWORD __thiscall std::_Generic_error_category::_Generic_error_category(std::_Generic_error_category *__hidden this)
.text$mn:00002808                 public ??0_Generic_error_category@std@@QAE@XZ
.text$mn:00002808 ??0_Generic_error_category@std@@QAE@XZ proc near
.text$mn:00002808                                         ; CODE XREF: std::_Iostream_error_category::_Iostream_error_category(void)+29p
.text$mn:00002808                                         ; std::_System_error_category::_System_error_category(void)+29p ...
.text$mn:00002808
.text$mn:00002808 var_10          = dword ptr -10h
.text$mn:00002808 var_C           = dword ptr -0Ch
.text$mn:00002808 var_4           = dword ptr -4
.text$mn:00002808
.text$mn:00002808                 push    ebp
.text$mn:00002809                 mov     ebp, esp
.text$mn:0000280B                 push    0FFFFFFFFh
.text$mn:0000280D                 push    offset __ehhandler$??0_Generic_error_category@std@@QAE@XZ
.text$mn:00002812                 mov     eax, large fs:0
.text$mn:00002818                 push    eax
.text$mn:00002819                 push    ecx
.text$mn:0000281A                 mov     eax, dword ptr ds:___security_cookie
.text$mn:0000281F                 xor     eax, ebp
.text$mn:00002821                 push    eax
.text$mn:00002822                 lea     eax, [ebp+var_C]
.text$mn:00002825                 mov     large fs:0, eax
.text$mn:0000282B                 mov     [ebp+var_10], ecx
.text$mn:0000282E                 mov     ecx, [ebp+var_10] ; this
.text$mn:00002831                 call    ??0error_category@std@@QAE@XZ ; std::error_category::error_category(void)
.text$mn:00002836                 mov     [ebp+var_4], 0
.text$mn:0000283D                 mov     eax, [ebp+var_10]
.text$mn:00002840                 mov     dword ptr [eax], offset ??_7_Generic_error_category@std@@6B@ ; const std::_Generic_error_category::`vftable'
.text$mn:00002846                 mov     [ebp+var_4], 0FFFFFFFFh
.text$mn:0000284D                 mov     eax, [ebp+var_10]
.text$mn:00002850                 mov     ecx, [ebp+var_C]
.text$mn:00002853                 mov     large fs:0, ecx
.text$mn:0000285A                 pop     ecx
.text$mn:0000285B                 mov     esp, ebp
.text$mn:0000285D                 pop     ebp
.text$mn:0000285E                 retn
.text$mn:0000285E ??0_Generic_error_category@std@@QAE@XZ endp
.text$mn:0000285E
.text$mn:0000285E ; ---------------------------------------------------------------------------
.text$mn:0000285F                 align 10h
.text$mn:0000285F _text$mn        ends
.text$mn:0000285F
.text$x:00002860 ; ===========================================================================
.text$x:00002860
.text$x:00002860 ; Segment type: Pure code
.text$x:00002860 ; Segment permissions: Read/Execute
.text$x:00002860 _text$x         segment para public 'CODE' use32
.text$x:00002860                 assume cs:_text$x
.text$x:00002860                 ;org 2860h
.text$x:00002860 ; COMDAT (pick associative to section at 2808)
.text$x:00002860                 assume es:nothing, ss:nothing, ds:_data, fs:nothing, gs:nothing
.text$x:00002860
.text$x:00002860 ; =============== S U B R O U T I N E =======================================
.text$x:00002860
.text$x:00002860
.text$x:00002860 __unwindfunclet$??0_Generic_error_category@std@@QAE@XZ$0 proc near
.text$x:00002860                                         ; DATA XREF: .xdata$x:000044D4o
.text$x:00002860                 mov     ecx, [ebp-10h]  ; this
.text$x:00002863                 jmp     ??1error_category@std@@UAE@XZ ; std::error_category::~error_category(void)
.text$x:00002863 __unwindfunclet$??0_Generic_error_category@std@@QAE@XZ$0 endp
.text$x:00002863
.text$x:00002868
.text$x:00002868 ; =============== S U B R O U T I N E =======================================
.text$x:00002868
.text$x:00002868
.text$x:00002868 __ehhandler$??0_Generic_error_category@std@@QAE@XZ proc near
.text$x:00002868                                         ; DATA XREF: std::_Generic_error_category::_Generic_error_category(void)+5o
.text$x:00002868
.text$x:00002868 arg_4           = dword ptr  8
.text$x:00002868
.text$x:00002868                 mov     edx, [esp+arg_4]
.text$x:0000286C                 lea     eax, [edx+0Ch]
.text$x:0000286F                 mov     ecx, [edx-8]
.text$x:00002872                 xor     ecx, eax
.text$x:00002874                 call    @__security_check_cookie@4 ; __security_check_cookie(x)
.text$x:00002879                 mov     eax, offset __ehfuncinfo$??0_Generic_error_category@std@@QAE@XZ
.text$x:0000287E                 jmp     ___CxxFrameHandler3
.text$x:0000287E __ehhandler$??0_Generic_error_category@std@@QAE@XZ endp
.text$x:0000287E
.text$x:0000287E ; ---------------------------------------------------------------------------
.text$x:00002883                 align 4
.text$x:00002883 _text$x         ends
.text$x:00002883
.text$mn:00002884 ; ===========================================================================
.text$mn:00002884
.text$mn:00002884 ; Segment type: Pure code
.text$mn:00002884 ; Segment permissions: Read/Execute
.text$mn:00002884 _text$mn        segment para public 'CODE' use32
.text$mn:00002884                 assume cs:_text$mn
.text$mn:00002884                 ;org 2884h
.text$mn:00002884 ; COMDAT (pick any)
.text$mn:00002884                 assume es:nothing, ss:nothing, ds:_data, fs:nothing, gs:nothing
.text$mn:00002884
.text$mn:00002884 ; =============== S U B R O U T I N E =======================================
.text$mn:00002884
.text$mn:00002884 ; Attributes: bp-based frame
.text$mn:00002884
.text$mn:00002884 ; _DWORD __thiscall std::_Ignore::_Ignore(std::_Ignore *__hidden this)
.text$mn:00002884                 public ??0_Ignore@std@@QAE@XZ
.text$mn:00002884 ??0_Ignore@std@@QAE@XZ proc near        ; CODE XREF: std::`dynamic initializer for 'ignore''(void)+8p
.text$mn:00002884
.text$mn:00002884 var_4           = dword ptr -4
.text$mn:00002884
.text$mn:00002884                 push    ebp
.text$mn:00002885                 mov     ebp, esp
.text$mn:00002887                 push    ecx
.text$mn:00002888                 mov     [ebp+var_4], ecx
.text$mn:0000288B                 mov     eax, [ebp+var_4]
.text$mn:0000288E                 mov     esp, ebp
.text$mn:00002890                 pop     ebp
.text$mn:00002891                 retn
.text$mn:00002891 ??0_Ignore@std@@QAE@XZ endp
.text$mn:00002891
.text$mn:00002891 ; ---------------------------------------------------------------------------
.text$mn:00002892                 align 4
.text$mn:00002892 _text$mn        ends
.text$mn:00002892
.text$mn:00002894 ; ===========================================================================
.text$mn:00002894
.text$mn:00002894 ; Segment type: Pure code
.text$mn:00002894 ; Segment permissions: Read/Execute
.text$mn:00002894 _text$mn        segment para public 'CODE' use32
.text$mn:00002894                 assume cs:_text$mn
.text$mn:00002894                 ;org 2894h
.text$mn:00002894 ; COMDAT (pick any)
.text$mn:00002894                 assume es:nothing, ss:nothing, ds:_data, fs:nothing, gs:nothing
.text$mn:00002894
.text$mn:00002894 ; =============== S U B R O U T I N E =======================================
.text$mn:00002894
.text$mn:00002894 ; Attributes: bp-based frame
.text$mn:00002894
.text$mn:00002894 ; _DWORD __thiscall std::_Iostream_error_category::_Iostream_error_category(std::_Iostream_error_category *__hidden this)
.text$mn:00002894                 public ??0_Iostream_error_category@std@@QAE@XZ
.text$mn:00002894 ??0_Iostream_error_category@std@@QAE@XZ proc near
.text$mn:00002894                                         ; CODE XREF: `dynamic initializer for 'std::_Iostream_error_category std::_Error_objects<int>::_Iostream_object''(void)+8p
.text$mn:00002894
.text$mn:00002894 var_10          = dword ptr -10h
.text$mn:00002894 var_C           = dword ptr -0Ch
.text$mn:00002894 var_4           = dword ptr -4
.text$mn:00002894
.text$mn:00002894                 push    ebp
.text$mn:00002895                 mov     ebp, esp
.text$mn:00002897                 push    0FFFFFFFFh
.text$mn:00002899                 push    offset __ehhandler$??0_Iostream_error_category@std@@QAE@XZ
.text$mn:0000289E                 mov     eax, large fs:0
.text$mn:000028A4                 push    eax
.text$mn:000028A5                 push    ecx
.text$mn:000028A6                 mov     eax, dword ptr ds:___security_cookie
.text$mn:000028AB                 xor     eax, ebp
.text$mn:000028AD                 push    eax
.text$mn:000028AE                 lea     eax, [ebp+var_C]
.text$mn:000028B1                 mov     large fs:0, eax
.text$mn:000028B7                 mov     [ebp+var_10], ecx
.text$mn:000028BA                 mov     ecx, [ebp+var_10] ; this
.text$mn:000028BD                 call    ??0_Generic_error_category@std@@QAE@XZ ; std::_Generic_error_category::_Generic_error_category(void)
.text$mn:000028C2                 mov     [ebp+var_4], 0
.text$mn:000028C9                 mov     eax, [ebp+var_10]
.text$mn:000028CC                 mov     dword ptr [eax], offset ??_7_Iostream_error_category@std@@6B@ ; const std::_Iostream_error_category::`vftable'
.text$mn:000028D2                 mov     [ebp+var_4], 0FFFFFFFFh
.text$mn:000028D9                 mov     eax, [ebp+var_10]
.text$mn:000028DC                 mov     ecx, [ebp+var_C]
.text$mn:000028DF                 mov     large fs:0, ecx
.text$mn:000028E6                 pop     ecx
.text$mn:000028E7                 mov     esp, ebp
.text$mn:000028E9                 pop     ebp
.text$mn:000028EA                 retn
.text$mn:000028EA ??0_Iostream_error_category@std@@QAE@XZ endp
.text$mn:000028EA
.text$mn:000028EA ; ---------------------------------------------------------------------------
.text$mn:000028EB                 align 4
.text$mn:000028EB _text$mn        ends
.text$mn:000028EB
.text$x:000028EC ; ===========================================================================
.text$x:000028EC
.text$x:000028EC ; Segment type: Pure code
.text$x:000028EC ; Segment permissions: Read/Execute
.text$x:000028EC _text$x         segment para public 'CODE' use32
.text$x:000028EC                 assume cs:_text$x
.text$x:000028EC                 ;org 28ECh
.text$x:000028EC ; COMDAT (pick associative to section at 2894)
.text$x:000028EC                 assume es:nothing, ss:nothing, ds:_data, fs:nothing, gs:nothing
.text$x:000028EC
.text$x:000028EC ; =============== S U B R O U T I N E =======================================
.text$x:000028EC
.text$x:000028EC
.text$x:000028EC __unwindfunclet$??0_Iostream_error_category@std@@QAE@XZ$0 proc near
.text$x:000028EC                                         ; DATA XREF: .xdata$x:00004558o
.text$x:000028EC                 mov     ecx, [ebp-10h]  ; this
.text$x:000028EF                 jmp     ??1_Generic_error_category@std@@UAE@XZ ; std::_Generic_error_category::~_Generic_error_category(void)
.text$x:000028EF __unwindfunclet$??0_Iostream_error_category@std@@QAE@XZ$0 endp
.text$x:000028EF
.text$x:000028F4
.text$x:000028F4 ; =============== S U B R O U T I N E =======================================
.text$x:000028F4
.text$x:000028F4
.text$x:000028F4 __ehhandler$??0_Iostream_error_category@std@@QAE@XZ proc near
.text$x:000028F4                                         ; DATA XREF: std::_Iostream_error_category::_Iostream_error_category(void)+5o
.text$x:000028F4
.text$x:000028F4 arg_4           = dword ptr  8
.text$x:000028F4
.text$x:000028F4                 mov     edx, [esp+arg_4]
.text$x:000028F8                 lea     eax, [edx+0Ch]
.text$x:000028FB                 mov     ecx, [edx-8]
.text$x:000028FE                 xor     ecx, eax
.text$x:00002900                 call    @__security_check_cookie@4 ; __security_check_cookie(x)
.text$x:00002905                 mov     eax, offset __ehfuncinfo$??0_Iostream_error_category@std@@QAE@XZ
.text$x:0000290A                 jmp     ___CxxFrameHandler3
.text$x:0000290A __ehhandler$??0_Iostream_error_category@std@@QAE@XZ endp
.text$x:0000290A
.text$x:0000290A ; ---------------------------------------------------------------------------
.text$x:0000290F                 align 10h
.text$x:0000290F _text$x         ends
.text$x:0000290F
.text$mn:00002910 ; ===========================================================================
.text$mn:00002910
.text$mn:00002910 ; Segment type: Pure code
.text$mn:00002910 ; Segment permissions: Read/Execute
.text$mn:00002910 _text$mn        segment para public 'CODE' use32
.text$mn:00002910                 assume cs:_text$mn
.text$mn:00002910                 ;org 2910h
.text$mn:00002910 ; COMDAT (pick any)
.text$mn:00002910                 assume es:nothing, ss:nothing, ds:_data, fs:nothing, gs:nothing
.text$mn:00002910
.text$mn:00002910 ; =============== S U B R O U T I N E =======================================
.text$mn:00002910
.text$mn:00002910 ; Attributes: bp-based frame
.text$mn:00002910
.text$mn:00002910 ; _DWORD __thiscall std::_System_error_category::_System_error_category(std::_System_error_category *__hidden this)
.text$mn:00002910                 public ??0_System_error_category@std@@QAE@XZ
.text$mn:00002910 ??0_System_error_category@std@@QAE@XZ proc near
.text$mn:00002910                                         ; CODE XREF: `dynamic initializer for 'std::_System_error_category std::_Error_objects<int>::_System_object''(void)+8p
.text$mn:00002910
.text$mn:00002910 var_10          = dword ptr -10h
.text$mn:00002910 var_C           = dword ptr -0Ch
.text$mn:00002910 var_4           = dword ptr -4
.text$mn:00002910
.text$mn:00002910                 push    ebp
.text$mn:00002911                 mov     ebp, esp
.text$mn:00002913                 push    0FFFFFFFFh
.text$mn:00002915                 push    offset __ehhandler$??0_System_error_category@std@@QAE@XZ
.text$mn:0000291A                 mov     eax, large fs:0
.text$mn:00002920                 push    eax
.text$mn:00002921                 push    ecx
.text$mn:00002922                 mov     eax, dword ptr ds:___security_cookie
.text$mn:00002927                 xor     eax, ebp
.text$mn:00002929                 push    eax
.text$mn:0000292A                 lea     eax, [ebp+var_C]
.text$mn:0000292D                 mov     large fs:0, eax
.text$mn:00002933                 mov     [ebp+var_10], ecx
.text$mn:00002936                 mov     ecx, [ebp+var_10] ; this
.text$mn:00002939                 call    ??0_Generic_error_category@std@@QAE@XZ ; std::_Generic_error_category::_Generic_error_category(void)
.text$mn:0000293E                 mov     [ebp+var_4], 0
.text$mn:00002945                 mov     eax, [ebp+var_10]
.text$mn:00002948                 mov     dword ptr [eax], offset ??_7_System_error_category@std@@6B@ ; const std::_System_error_category::`vftable'
.text$mn:0000294E                 mov     [ebp+var_4], 0FFFFFFFFh
.text$mn:00002955                 mov     eax, [ebp+var_10]
.text$mn:00002958                 mov     ecx, [ebp+var_C]
.text$mn:0000295B                 mov     large fs:0, ecx
.text$mn:00002962                 pop     ecx
.text$mn:00002963                 mov     esp, ebp
.text$mn:00002965                 pop     ebp
.text$mn:00002966                 retn
.text$mn:00002966 ??0_System_error_category@std@@QAE@XZ endp
.text$mn:00002966
.text$mn:00002966 ; ---------------------------------------------------------------------------
.text$mn:00002967                 align 4
.text$mn:00002967 _text$mn        ends
.text$mn:00002967
.text$x:00002968 ; ===========================================================================
.text$x:00002968
.text$x:00002968 ; Segment type: Pure code
.text$x:00002968 ; Segment permissions: Read/Execute
.text$x:00002968 _text$x         segment para public 'CODE' use32
.text$x:00002968                 assume cs:_text$x
.text$x:00002968                 ;org 2968h
.text$x:00002968 ; COMDAT (pick associative to section at 2910)
.text$x:00002968                 assume es:nothing, ss:nothing, ds:_data, fs:nothing, gs:nothing
.text$x:00002968
.text$x:00002968 ; =============== S U B R O U T I N E =======================================
.text$x:00002968
.text$x:00002968
.text$x:00002968 __unwindfunclet$??0_System_error_category@std@@QAE@XZ$0 proc near
.text$x:00002968                                         ; DATA XREF: .xdata$x:000045DCo
.text$x:00002968                 mov     ecx, [ebp-10h]  ; this
.text$x:0000296B                 jmp     ??1_Generic_error_category@std@@UAE@XZ ; std::_Generic_error_category::~_Generic_error_category(void)
.text$x:0000296B __unwindfunclet$??0_System_error_category@std@@QAE@XZ$0 endp
.text$x:0000296B
.text$x:00002970
.text$x:00002970 ; =============== S U B R O U T I N E =======================================
.text$x:00002970
.text$x:00002970
.text$x:00002970 __ehhandler$??0_System_error_category@std@@QAE@XZ proc near
.text$x:00002970                                         ; DATA XREF: std::_System_error_category::_System_error_category(void)+5o
.text$x:00002970
.text$x:00002970 arg_4           = dword ptr  8
.text$x:00002970
.text$x:00002970                 mov     edx, [esp+arg_4]
.text$x:00002974                 lea     eax, [edx+0Ch]
.text$x:00002977                 mov     ecx, [edx-8]
.text$x:0000297A                 xor     ecx, eax
.text$x:0000297C                 call    @__security_check_cookie@4 ; __security_check_cookie(x)
.text$x:00002981                 mov     eax, offset __ehfuncinfo$??0_System_error_category@std@@QAE@XZ
.text$x:00002986                 jmp     ___CxxFrameHandler3
.text$x:00002986 __ehhandler$??0_System_error_category@std@@QAE@XZ endp
.text$x:00002986
.text$x:00002986 ; ---------------------------------------------------------------------------
.text$x:0000298B                 align 4
.text$x:0000298B _text$x         ends
.text$x:0000298B
.text$mn:0000298C ; ===========================================================================
.text$mn:0000298C
.text$mn:0000298C ; Segment type: Pure code
.text$mn:0000298C ; Segment permissions: Read/Execute
.text$mn:0000298C _text$mn        segment para public 'CODE' use32
.text$mn:0000298C                 assume cs:_text$mn
.text$mn:0000298C                 ;org 298Ch
.text$mn:0000298C ; COMDAT (pick any)
.text$mn:0000298C                 assume es:nothing, ss:nothing, ds:_data, fs:nothing, gs:nothing
.text$mn:0000298C
.text$mn:0000298C ; =============== S U B R O U T I N E =======================================
.text$mn:0000298C
.text$mn:0000298C ; Attributes: bp-based frame
.text$mn:0000298C
.text$mn:0000298C ; _DWORD __thiscall std::error_category::error_category(std::error_category *__hidden this)
.text$mn:0000298C                 public ??0error_category@std@@QAE@XZ
.text$mn:0000298C ??0error_category@std@@QAE@XZ proc near ; CODE XREF: std::_Generic_error_category::_Generic_error_category(void)+29p
.text$mn:0000298C
.text$mn:0000298C var_4           = dword ptr -4
.text$mn:0000298C
.text$mn:0000298C                 push    ebp
.text$mn:0000298D                 mov     ebp, esp
.text$mn:0000298F                 push    ecx
.text$mn:00002990                 mov     [ebp+var_4], ecx
.text$mn:00002993                 mov     eax, [ebp+var_4]
.text$mn:00002996                 mov     dword ptr [eax], offset ??_7error_category@std@@6B@ ; const std::error_category::`vftable'
.text$mn:0000299C                 mov     eax, [ebp+var_4]
.text$mn:0000299F                 mov     esp, ebp
.text$mn:000029A1                 pop     ebp
.text$mn:000029A2                 retn
.text$mn:000029A2 ??0error_category@std@@QAE@XZ endp
.text$mn:000029A2
.text$mn:000029A2 ; ---------------------------------------------------------------------------
.text$mn:000029A3                 align 4
.text$mn:000029A3 _text$mn        ends
.text$mn:000029A3
.text$mn:000029A4 ; ===========================================================================
.text$mn:000029A4
.text$mn:000029A4 ; Segment type: Pure code
.text$mn:000029A4 ; Segment permissions: Read/Execute
.text$mn:000029A4 _text$mn        segment para public 'CODE' use32
.text$mn:000029A4                 assume cs:_text$mn
.text$mn:000029A4                 ;org 29A4h
.text$mn:000029A4 ; COMDAT (pick any)
.text$mn:000029A4                 assume es:nothing, ss:nothing, ds:_data, fs:nothing, gs:nothing
.text$mn:000029A4
.text$mn:000029A4 ; =============== S U B R O U T I N E =======================================
.text$mn:000029A4
.text$mn:000029A4 ; Attributes: bp-based frame
.text$mn:000029A4
.text$mn:000029A4 ; _DWORD __thiscall std::error_condition::error_condition(std::error_condition *this, int, const struct std::error_category *)
.text$mn:000029A4                 public ??0error_condition@std@@QAE@HABVerror_category@1@@Z
.text$mn:000029A4 ??0error_condition@std@@QAE@HABVerror_category@1@@Z proc near
.text$mn:000029A4                                         ; CODE XREF: std::_System_error_category::default_error_condition(int)+24p
.text$mn:000029A4                                         ; std::_System_error_category::default_error_condition(int)+3Dp ...
.text$mn:000029A4
.text$mn:000029A4 var_4           = dword ptr -4
.text$mn:000029A4 arg_0           = dword ptr  8
.text$mn:000029A4 arg_4           = dword ptr  0Ch
.text$mn:000029A4
.text$mn:000029A4                 push    ebp
.text$mn:000029A5                 mov     ebp, esp
.text$mn:000029A7                 push    ecx
.text$mn:000029A8                 mov     [ebp+var_4], ecx
.text$mn:000029AB                 mov     eax, [ebp+var_4]
.text$mn:000029AE                 mov     ecx, [ebp+arg_0]
.text$mn:000029B1                 mov     [eax], ecx
.text$mn:000029B3                 mov     edx, [ebp+var_4]
.text$mn:000029B6                 mov     eax, [ebp+arg_4]
.text$mn:000029B9                 mov     [edx+4], eax
.text$mn:000029BC                 mov     eax, [ebp+var_4]
.text$mn:000029BF                 mov     esp, ebp
.text$mn:000029C1                 pop     ebp
.text$mn:000029C2                 retn    8
.text$mn:000029C2 ??0error_condition@std@@QAE@HABVerror_category@1@@Z endp
.text$mn:000029C2
.text$mn:000029C2 ; ---------------------------------------------------------------------------
.text$mn:000029C5                 align 4
.text$mn:000029C5 _text$mn        ends
.text$mn:000029C5
.text$mn:000029C8 ; ===========================================================================
.text$mn:000029C8
.text$mn:000029C8 ; Segment type: Pure code
.text$mn:000029C8 ; Segment permissions: Read/Execute
.text$mn:000029C8 _text$mn        segment para public 'CODE' use32
.text$mn:000029C8                 assume cs:_text$mn
.text$mn:000029C8                 ;org 29C8h
.text$mn:000029C8 ; COMDAT (pick any)
.text$mn:000029C8                 assume es:nothing, ss:nothing, ds:_data, fs:nothing, gs:nothing
.text$mn:000029C8
.text$mn:000029C8 ; =============== S U B R O U T I N E =======================================
.text$mn:000029C8
.text$mn:000029C8 ; Attributes: bp-based frame
.text$mn:000029C8
.text$mn:000029C8 ; _DWORD __thiscall std::locale::id::id(std::locale::id *this, unsigned int)
.text$mn:000029C8                 public ??0id@locale@std@@QAE@I@Z
.text$mn:000029C8 ??0id@locale@std@@QAE@I@Z proc near     ; CODE XREF: `dynamic initializer for 'std::locale::id std::num_put<char,std::back_insert_iterator<std::basic_string<char,std::char_traits<char>,std::allocator<char>>>>::id''(void)+Ap
.text$mn:000029C8                                         ; `dynamic initializer for 'std::locale::id std::num_put<wchar_t,std::back_insert_iterator<std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>>>>::id''(void)+Ap ...
.text$mn:000029C8
.text$mn:000029C8 var_4           = dword ptr -4
.text$mn:000029C8 arg_0           = dword ptr  8
.text$mn:000029C8
.text$mn:000029C8                 push    ebp
.text$mn:000029C9                 mov     ebp, esp
.text$mn:000029CB                 push    ecx
.text$mn:000029CC                 mov     [ebp+var_4], ecx
.text$mn:000029CF                 mov     eax, [ebp+var_4]
.text$mn:000029D2                 mov     ecx, [ebp+arg_0]
.text$mn:000029D5                 mov     [eax], ecx
.text$mn:000029D7                 mov     eax, [ebp+var_4]
.text$mn:000029DA                 mov     esp, ebp
.text$mn:000029DC                 pop     ebp
.text$mn:000029DD                 retn    4
.text$mn:000029DD ??0id@locale@std@@QAE@I@Z endp
.text$mn:000029DD
.text$mn:000029DD _text$mn        ends
.text$mn:000029DD
.text$mn:000029E0 ; ===========================================================================
.text$mn:000029E0
.text$mn:000029E0 ; Segment type: Pure code
.text$mn:000029E0 ; Segment permissions: Read/Execute
.text$mn:000029E0 _text$mn        segment para public 'CODE' use32
.text$mn:000029E0                 assume cs:_text$mn
.text$mn:000029E0                 ;org 29E0h
.text$mn:000029E0 ; COMDAT (pick any)
.text$mn:000029E0                 assume es:nothing, ss:nothing, ds:_data, fs:nothing, gs:nothing
.text$mn:000029E0
.text$mn:000029E0 ; =============== S U B R O U T I N E =======================================
.text$mn:000029E0
.text$mn:000029E0 ; Attributes: bp-based frame
.text$mn:000029E0
.text$mn:000029E0 ; public: __thiscall std::_String_alloc<0, struct std::_String_base_types<char, class std::allocator<char>>>::~_String_alloc<0, struct std::_String_base_types<char, class std::allocator<char>>>(void)
.text$mn:000029E0                 public ??1?$_String_alloc@$0A@U?$_String_base_types@DV?$allocator@D@std@@@std@@@std@@QAE@XZ
.text$mn:000029E0 ??1?$_String_alloc@$0A@U?$_String_base_types@DV?$allocator@D@std@@@std@@@std@@QAE@XZ proc near
.text$mn:000029E0                                         ; CODE XREF: __unwindfunclet$??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@PBD@Z$0+3j
.text$mn:000029E0                                         ; std::basic_string<char,std::char_traits<char>,std::allocator<char>>::~basic_string<char,std::char_traits<char>,std::allocator<char>>(void)+43p ...
.text$mn:000029E0
.text$mn:000029E0 var_10          = dword ptr -10h
.text$mn:000029E0 var_C           = dword ptr -0Ch
.text$mn:000029E0 var_4           = dword ptr -4
.text$mn:000029E0
.text$mn:000029E0                 push    ebp
.text$mn:000029E1                 mov     ebp, esp
.text$mn:000029E3                 push    0FFFFFFFFh
.text$mn:000029E5                 push    offset __ehhandler$??1?$_String_alloc@$0A@U?$_String_base_types@DV?$allocator@D@std@@@std@@@std@@QAE@XZ
.text$mn:000029EA                 mov     eax, large fs:0
.text$mn:000029F0                 push    eax
.text$mn:000029F1                 push    ecx
.text$mn:000029F2                 mov     eax, dword ptr ds:___security_cookie
.text$mn:000029F7                 xor     eax, ebp
.text$mn:000029F9                 push    eax
.text$mn:000029FA                 lea     eax, [ebp+var_C]
.text$mn:000029FD                 mov     large fs:0, eax
.text$mn:00002A03                 mov     [ebp+var_10], ecx
.text$mn:00002A06                 mov     [ebp+var_4], 0
.text$mn:00002A0D                 mov     ecx, [ebp+var_10]
.text$mn:00002A10                 call    ?_Free_proxy@?$_String_alloc@$0A@U?$_String_base_types@DV?$allocator@D@std@@@std@@@std@@QAEXXZ ; std::_String_alloc<0,std::_String_base_types<char,std::allocator<char>>>::_Free_proxy(void)
.text$mn:00002A15                 mov     [ebp+var_4], 0FFFFFFFFh
.text$mn:00002A1C                 mov     ecx, [ebp+var_10]
.text$mn:00002A1F                 call    ??1?$_String_val@U?$_Simple_types@D@std@@@std@@QAE@XZ ; std::_String_val<std::_Simple_types<char>>::~_String_val<std::_Simple_types<char>>(void)
.text$mn:00002A24                 mov     ecx, [ebp+var_C]
.text$mn:00002A27                 mov     large fs:0, ecx
.text$mn:00002A2E                 pop     ecx
.text$mn:00002A2F                 mov     esp, ebp
.text$mn:00002A31                 pop     ebp
.text$mn:00002A32                 retn
.text$mn:00002A32 ??1?$_String_alloc@$0A@U?$_String_base_types@DV?$allocator@D@std@@@std@@@std@@QAE@XZ endp
.text$mn:00002A32
.text$mn:00002A32 ; ---------------------------------------------------------------------------
.text$mn:00002A33                 align 4
.text$mn:00002A33 _text$mn        ends
.text$mn:00002A33
.text$x:00002A34 ; ===========================================================================
.text$x:00002A34
.text$x:00002A34 ; Segment type: Pure code
.text$x:00002A34 ; Segment permissions: Read/Execute
.text$x:00002A34 _text$x         segment para public 'CODE' use32
.text$x:00002A34                 assume cs:_text$x
.text$x:00002A34                 ;org 2A34h
.text$x:00002A34 ; COMDAT (pick associative to section at 29E0)
.text$x:00002A34                 assume es:nothing, ss:nothing, ds:_data, fs:nothing, gs:nothing
.text$x:00002A34
.text$x:00002A34 ; =============== S U B R O U T I N E =======================================
.text$x:00002A34
.text$x:00002A34
.text$x:00002A34 __unwindfunclet$??1?$_String_alloc@$0A@U?$_String_base_types@DV?$allocator@D@std@@@std@@@std@@QAE@XZ$0 proc near
.text$x:00002A34                                         ; DATA XREF: .xdata$x:000043C4o
.text$x:00002A34                 mov     ecx, [ebp-10h]
.text$x:00002A37                 jmp     ??1?$_String_val@U?$_Simple_types@D@std@@@std@@QAE@XZ ; std::_String_val<std::_Simple_types<char>>::~_String_val<std::_Simple_types<char>>(void)
.text$x:00002A37 __unwindfunclet$??1?$_String_alloc@$0A@U?$_String_base_types@DV?$allocator@D@std@@@std@@@std@@QAE@XZ$0 endp
.text$x:00002A37
.text$x:00002A3C
.text$x:00002A3C ; =============== S U B R O U T I N E =======================================
.text$x:00002A3C
.text$x:00002A3C
.text$x:00002A3C __ehhandler$??1?$_String_alloc@$0A@U?$_String_base_types@DV?$allocator@D@std@@@std@@@std@@QAE@XZ proc near
.text$x:00002A3C                                         ; DATA XREF: std::_String_alloc<0,std::_String_base_types<char,std::allocator<char>>>::~_String_alloc<0,std::_String_base_types<char,std::allocator<char>>>(void)+5o
.text$x:00002A3C
.text$x:00002A3C arg_4           = dword ptr  8
.text$x:00002A3C
.text$x:00002A3C                 mov     edx, [esp+arg_4]
.text$x:00002A40                 lea     eax, [edx+0Ch]
.text$x:00002A43                 mov     ecx, [edx-8]
.text$x:00002A46                 xor     ecx, eax
.text$x:00002A48                 call    @__security_check_cookie@4 ; __security_check_cookie(x)
.text$x:00002A4D                 mov     eax, offset __ehfuncinfo$??1?$_String_alloc@$0A@U?$_String_base_types@DV?$allocator@D@std@@@std@@@std@@QAE@XZ
.text$x:00002A52                 jmp     ___CxxFrameHandler3
.text$x:00002A52 __ehhandler$??1?$_String_alloc@$0A@U?$_String_base_types@DV?$allocator@D@std@@@std@@@std@@QAE@XZ endp
.text$x:00002A52
.text$x:00002A52 ; ---------------------------------------------------------------------------
.text$x:00002A57                 align 4
.text$x:00002A57 _text$x         ends
.text$x:00002A57
.text$mn:00002A58 ; ===========================================================================
.text$mn:00002A58
.text$mn:00002A58 ; Segment type: Pure code
.text$mn:00002A58 ; Segment permissions: Read/Execute
.text$mn:00002A58 _text$mn        segment para public 'CODE' use32
.text$mn:00002A58                 assume cs:_text$mn
.text$mn:00002A58                 ;org 2A58h
.text$mn:00002A58 ; COMDAT (pick any)
.text$mn:00002A58                 assume es:nothing, ss:nothing, ds:_data, fs:nothing, gs:nothing
.text$mn:00002A58
.text$mn:00002A58 ; =============== S U B R O U T I N E =======================================
.text$mn:00002A58
.text$mn:00002A58 ; Attributes: bp-based frame
.text$mn:00002A58
.text$mn:00002A58 ; public: __thiscall std::_String_val<struct std::_Simple_types<char>>::~_String_val<struct std::_Simple_types<char>>(void)
.text$mn:00002A58                 public ??1?$_String_val@U?$_Simple_types@D@std@@@std@@QAE@XZ
.text$mn:00002A58 ??1?$_String_val@U?$_Simple_types@D@std@@@std@@QAE@XZ proc near
.text$mn:00002A58                                         ; CODE XREF: __unwindfunclet$??0?$_String_alloc@$0A@U?$_String_base_types@DV?$allocator@D@std@@@std@@@std@@QAE@ABV?$allocator@D@1@@Z$0+3j
.text$mn:00002A58                                         ; std::_String_alloc<0,std::_String_base_types<char,std::allocator<char>>>::~_String_alloc<0,std::_String_base_types<char,std::allocator<char>>>(void)+3Fp ...
.text$mn:00002A58
.text$mn:00002A58 var_10          = dword ptr -10h
.text$mn:00002A58 var_C           = dword ptr -0Ch
.text$mn:00002A58 var_4           = dword ptr -4
.text$mn:00002A58
.text$mn:00002A58                 push    ebp
.text$mn:00002A59                 mov     ebp, esp
.text$mn:00002A5B                 push    0FFFFFFFFh
.text$mn:00002A5D                 push    offset __ehhandler$??1?$_String_val@U?$_Simple_types@D@std@@@std@@QAE@XZ
.text$mn:00002A62                 mov     eax, large fs:0
.text$mn:00002A68                 push    eax
.text$mn:00002A69                 push    ecx
.text$mn:00002A6A                 mov     eax, dword ptr ds:___security_cookie
.text$mn:00002A6F                 xor     eax, ebp
.text$mn:00002A71                 push    eax
.text$mn:00002A72                 lea     eax, [ebp+var_C]
.text$mn:00002A75                 mov     large fs:0, eax
.text$mn:00002A7B                 mov     [ebp+var_10], ecx
.text$mn:00002A7E                 mov     [ebp+var_4], 0
.text$mn:00002A85                 mov     [ebp+var_4], 0FFFFFFFFh
.text$mn:00002A8C                 mov     ecx, [ebp+var_10] ; this
.text$mn:00002A8F                 call    ??1_Container_base12@std@@QAE@XZ ; std::_Container_base12::~_Container_base12(void)
.text$mn:00002A94                 mov     ecx, [ebp+var_C]
.text$mn:00002A97                 mov     large fs:0, ecx
.text$mn:00002A9E                 pop     ecx
.text$mn:00002A9F                 mov     esp, ebp
.text$mn:00002AA1                 pop     ebp
.text$mn:00002AA2                 retn
.text$mn:00002AA2 ??1?$_String_val@U?$_Simple_types@D@std@@@std@@QAE@XZ endp
.text$mn:00002AA2
.text$mn:00002AA2 ; ---------------------------------------------------------------------------
.text$mn:00002AA3                 align 4
.text$mn:00002AA3 _text$mn        ends
.text$mn:00002AA3
.text$x:00002AA4 ; ===========================================================================
.text$x:00002AA4
.text$x:00002AA4 ; Segment type: Pure code
.text$x:00002AA4 ; Segment permissions: Read/Execute
.text$x:00002AA4 _text$x         segment para public 'CODE' use32
.text$x:00002AA4                 assume cs:_text$x
.text$x:00002AA4                 ;org 2AA4h
.text$x:00002AA4 ; COMDAT (pick associative to section at 2A58)
.text$x:00002AA4                 assume es:nothing, ss:nothing, ds:_data, fs:nothing, gs:nothing
.text$x:00002AA4
.text$x:00002AA4 ; =============== S U B R O U T I N E =======================================
.text$x:00002AA4
.text$x:00002AA4
.text$x:00002AA4 __unwindfunclet$??1?$_String_val@U?$_Simple_types@D@std@@@std@@QAE@XZ$0 proc near
.text$x:00002AA4                                         ; DATA XREF: .xdata$x:0000436Co
.text$x:00002AA4                 mov     ecx, [ebp-10h]  ; this
.text$x:00002AA7                 jmp     ??1_Container_base12@std@@QAE@XZ ; std::_Container_base12::~_Container_base12(void)
.text$x:00002AA7 __unwindfunclet$??1?$_String_val@U?$_Simple_types@D@std@@@std@@QAE@XZ$0 endp
.text$x:00002AA7
.text$x:00002AAC
.text$x:00002AAC ; =============== S U B R O U T I N E =======================================
.text$x:00002AAC
.text$x:00002AAC
.text$x:00002AAC __ehhandler$??1?$_String_val@U?$_Simple_types@D@std@@@std@@QAE@XZ proc near
.text$x:00002AAC                                         ; DATA XREF: std::_String_val<std::_Simple_types<char>>::~_String_val<std::_Simple_types<char>>(void)+5o
.text$x:00002AAC
.text$x:00002AAC arg_4           = dword ptr  8
.text$x:00002AAC
.text$x:00002AAC                 mov     edx, [esp+arg_4]
.text$x:00002AB0                 lea     eax, [edx+0Ch]
.text$x:00002AB3                 mov     ecx, [edx-8]
.text$x:00002AB6                 xor     ecx, eax
.text$x:00002AB8                 call    @__security_check_cookie@4 ; __security_check_cookie(x)
.text$x:00002ABD                 mov     eax, offset __ehfuncinfo$??1?$_String_val@U?$_Simple_types@D@std@@@std@@QAE@XZ
.text$x:00002AC2                 jmp     ___CxxFrameHandler3
.text$x:00002AC2 __ehhandler$??1?$_String_val@U?$_Simple_types@D@std@@@std@@QAE@XZ endp
.text$x:00002AC2
.text$x:00002AC2 ; ---------------------------------------------------------------------------
.text$x:00002AC7                 align 4
.text$x:00002AC7 _text$x         ends
.text$x:00002AC7
.text$mn:00002AC8 ; ===========================================================================
.text$mn:00002AC8
.text$mn:00002AC8 ; Segment type: Pure code
.text$mn:00002AC8 ; Segment permissions: Read/Execute
.text$mn:00002AC8 _text$mn        segment para public 'CODE' use32
.text$mn:00002AC8                 assume cs:_text$mn
.text$mn:00002AC8                 ;org 2AC8h
.text$mn:00002AC8 ; COMDAT (pick any)
.text$mn:00002AC8                 assume es:nothing, ss:nothing, ds:_data, fs:nothing, gs:nothing
.text$mn:00002AC8
.text$mn:00002AC8 ; =============== S U B R O U T I N E =======================================
.text$mn:00002AC8
.text$mn:00002AC8 ; Attributes: bp-based frame
.text$mn:00002AC8
.text$mn:00002AC8 ; public: __thiscall std::_Vector_alloc<0, struct std::_Vec_base_types<unsigned int, class std::allocator<unsigned int>>>::~_Vector_alloc<0, struct std::_Vec_base_types<unsigned int, class std::allocator<unsigned int>>>(void)
.text$mn:00002AC8                 public ??1?$_Vector_alloc@$0A@U?$_Vec_base_types@IV?$allocator@I@std@@@std@@@std@@QAE@XZ
.text$mn:00002AC8 ??1?$_Vector_alloc@$0A@U?$_Vec_base_types@IV?$allocator@I@std@@@std@@@std@@QAE@XZ proc near
.text$mn:00002AC8                                         ; CODE XREF: __unwindfunclet$??0?$vector@IV?$allocator@I@std@@@std@@QAE@XZ$0+3j
.text$mn:00002AC8                                         ; std::vector<uint,std::allocator<uint>>::~vector<uint,std::allocator<uint>>(void)+3Fp ...
.text$mn:00002AC8
.text$mn:00002AC8 var_10          = dword ptr -10h
.text$mn:00002AC8 var_C           = dword ptr -0Ch
.text$mn:00002AC8 var_4           = dword ptr -4
.text$mn:00002AC8
.text$mn:00002AC8                 push    ebp
.text$mn:00002AC9                 mov     ebp, esp
.text$mn:00002ACB                 push    0FFFFFFFFh
.text$mn:00002ACD                 push    offset __ehhandler$??1?$_Vector_alloc@$0A@U?$_Vec_base_types@IV?$allocator@I@std@@@std@@@std@@QAE@XZ
.text$mn:00002AD2                 mov     eax, large fs:0
.text$mn:00002AD8                 push    eax
.text$mn:00002AD9                 push    ecx
.text$mn:00002ADA                 mov     eax, dword ptr ds:___security_cookie
.text$mn:00002ADF                 xor     eax, ebp
.text$mn:00002AE1                 push    eax
.text$mn:00002AE2                 lea     eax, [ebp+var_C]
.text$mn:00002AE5                 mov     large fs:0, eax
.text$mn:00002AEB                 mov     [ebp+var_10], ecx
.text$mn:00002AEE                 mov     [ebp+var_4], 0
.text$mn:00002AF5                 mov     ecx, [ebp+var_10]
.text$mn:00002AF8                 call    ?_Free_proxy@?$_Vector_alloc@$0A@U?$_Vec_base_types@IV?$allocator@I@std@@@std@@@std@@QAEXXZ ; std::_Vector_alloc<0,std::_Vec_base_types<uint,std::allocator<uint>>>::_Free_proxy(void)
.text$mn:00002AFD                 mov     [ebp+var_4], 0FFFFFFFFh
.text$mn:00002B04                 mov     ecx, [ebp+var_10]
.text$mn:00002B07                 call    ??1?$_Vector_val@U?$_Simple_types@I@std@@@std@@QAE@XZ ; std::_Vector_val<std::_Simple_types<uint>>::~_Vector_val<std::_Simple_types<uint>>(void)
.text$mn:00002B0C                 mov     ecx, [ebp+var_C]
.text$mn:00002B0F                 mov     large fs:0, ecx
.text$mn:00002B16                 pop     ecx
.text$mn:00002B17                 mov     esp, ebp
.text$mn:00002B19                 pop     ebp
.text$mn:00002B1A                 retn
.text$mn:00002B1A ??1?$_Vector_alloc@$0A@U?$_Vec_base_types@IV?$allocator@I@std@@@std@@@std@@QAE@XZ endp
.text$mn:00002B1A
.text$mn:00002B1A ; ---------------------------------------------------------------------------
.text$mn:00002B1B                 align 4
.text$mn:00002B1B _text$mn        ends
.text$mn:00002B1B
.text$x:00002B1C ; ===========================================================================
.text$x:00002B1C
.text$x:00002B1C ; Segment type: Pure code
.text$x:00002B1C ; Segment permissions: Read/Execute
.text$x:00002B1C _text$x         segment para public 'CODE' use32
.text$x:00002B1C                 assume cs:_text$x
.text$x:00002B1C                 ;org 2B1Ch
.text$x:00002B1C ; COMDAT (pick associative to section at 2AC8)
.text$x:00002B1C                 assume es:nothing, ss:nothing, ds:_data, fs:nothing, gs:nothing
.text$x:00002B1C
.text$x:00002B1C ; =============== S U B R O U T I N E =======================================
.text$x:00002B1C
.text$x:00002B1C
.text$x:00002B1C __unwindfunclet$??1?$_Vector_alloc@$0A@U?$_Vec_base_types@IV?$allocator@I@std@@@std@@@std@@QAE@XZ$0 proc near
.text$x:00002B1C                                         ; DATA XREF: .xdata$x:00004710o
.text$x:00002B1C                 mov     ecx, [ebp-10h]
.text$x:00002B1F                 jmp     ??1?$_Vector_val@U?$_Simple_types@I@std@@@std@@QAE@XZ ; std::_Vector_val<std::_Simple_types<uint>>::~_Vector_val<std::_Simple_types<uint>>(void)
.text$x:00002B1F __unwindfunclet$??1?$_Vector_alloc@$0A@U?$_Vec_base_types@IV?$allocator@I@std@@@std@@@std@@QAE@XZ$0 endp
.text$x:00002B1F
.text$x:00002B24
.text$x:00002B24 ; =============== S U B R O U T I N E =======================================
.text$x:00002B24
.text$x:00002B24
.text$x:00002B24 __ehhandler$??1?$_Vector_alloc@$0A@U?$_Vec_base_types@IV?$allocator@I@std@@@std@@@std@@QAE@XZ proc near
.text$x:00002B24                                         ; DATA XREF: std::_Vector_alloc<0,std::_Vec_base_types<uint,std::allocator<uint>>>::~_Vector_alloc<0,std::_Vec_base_types<uint,std::allocator<uint>>>(void)+5o
.text$x:00002B24
.text$x:00002B24 arg_4           = dword ptr  8
.text$x:00002B24
.text$x:00002B24                 mov     edx, [esp+arg_4]
.text$x:00002B28                 lea     eax, [edx+0Ch]
.text$x:00002B2B                 mov     ecx, [edx-8]
.text$x:00002B2E                 xor     ecx, eax
.text$x:00002B30                 call    @__security_check_cookie@4 ; __security_check_cookie(x)
.text$x:00002B35                 mov     eax, offset __ehfuncinfo$??1?$_Vector_alloc@$0A@U?$_Vec_base_types@IV?$allocator@I@std@@@std@@@std@@QAE@XZ
.text$x:00002B3A                 jmp     ___CxxFrameHandler3
.text$x:00002B3A __ehhandler$??1?$_Vector_alloc@$0A@U?$_Vec_base_types@IV?$allocator@I@std@@@std@@@std@@QAE@XZ endp
.text$x:00002B3A
.text$x:00002B3A ; ---------------------------------------------------------------------------
.text$x:00002B3F                 align 10h
.text$x:00002B3F _text$x         ends
.text$x:00002B3F
.text$mn:00002B40 ; ===========================================================================
.text$mn:00002B40
.text$mn:00002B40 ; Segment type: Pure code
.text$mn:00002B40 ; Segment permissions: Read/Execute
.text$mn:00002B40 _text$mn        segment para public 'CODE' use32
.text$mn:00002B40                 assume cs:_text$mn
.text$mn:00002B40                 ;org 2B40h
.text$mn:00002B40 ; COMDAT (pick any)
.text$mn:00002B40                 assume es:nothing, ss:nothing, ds:_data, fs:nothing, gs:nothing
.text$mn:00002B40
.text$mn:00002B40 ; =============== S U B R O U T I N E =======================================
.text$mn:00002B40
.text$mn:00002B40 ; Attributes: bp-based frame
.text$mn:00002B40
.text$mn:00002B40 ; public: __thiscall std::_Vector_val<struct std::_Simple_types<unsigned int>>::~_Vector_val<struct std::_Simple_types<unsigned int>>(void)
.text$mn:00002B40                 public ??1?$_Vector_val@U?$_Simple_types@I@std@@@std@@QAE@XZ
.text$mn:00002B40 ??1?$_Vector_val@U?$_Simple_types@I@std@@@std@@QAE@XZ proc near
.text$mn:00002B40                                         ; CODE XREF: __unwindfunclet$??0?$_Vector_alloc@$0A@U?$_Vec_base_types@IV?$allocator@I@std@@@std@@@std@@QAE@ABV?$allocator@I@1@@Z$0+3j
.text$mn:00002B40                                         ; std::_Vector_alloc<0,std::_Vec_base_types<uint,std::allocator<uint>>>::~_Vector_alloc<0,std::_Vec_base_types<uint,std::allocator<uint>>>(void)+3Fp ...
.text$mn:00002B40
.text$mn:00002B40 var_10          = dword ptr -10h
.text$mn:00002B40 var_C           = dword ptr -0Ch
.text$mn:00002B40 var_4           = dword ptr -4
.text$mn:00002B40
.text$mn:00002B40                 push    ebp
.text$mn:00002B41                 mov     ebp, esp
.text$mn:00002B43                 push    0FFFFFFFFh
.text$mn:00002B45                 push    offset __ehhandler$??1?$_Vector_val@U?$_Simple_types@I@std@@@std@@QAE@XZ
.text$mn:00002B4A                 mov     eax, large fs:0
.text$mn:00002B50                 push    eax
.text$mn:00002B51                 push    ecx
.text$mn:00002B52                 mov     eax, dword ptr ds:___security_cookie
.text$mn:00002B57                 xor     eax, ebp
.text$mn:00002B59                 push    eax
.text$mn:00002B5A                 lea     eax, [ebp+var_C]
.text$mn:00002B5D                 mov     large fs:0, eax
.text$mn:00002B63                 mov     [ebp+var_10], ecx
.text$mn:00002B66                 mov     [ebp+var_4], 0
.text$mn:00002B6D                 mov     [ebp+var_4], 0FFFFFFFFh
.text$mn:00002B74                 mov     ecx, [ebp+var_10] ; this
.text$mn:00002B77                 call    ??1_Container_base12@std@@QAE@XZ ; std::_Container_base12::~_Container_base12(void)
.text$mn:00002B7C                 mov     ecx, [ebp+var_C]
.text$mn:00002B7F                 mov     large fs:0, ecx
.text$mn:00002B86                 pop     ecx
.text$mn:00002B87                 mov     esp, ebp
.text$mn:00002B89                 pop     ebp
.text$mn:00002B8A                 retn
.text$mn:00002B8A ??1?$_Vector_val@U?$_Simple_types@I@std@@@std@@QAE@XZ endp
.text$mn:00002B8A
.text$mn:00002B8A ; ---------------------------------------------------------------------------
.text$mn:00002B8B                 align 4
.text$mn:00002B8B _text$mn        ends
.text$mn:00002B8B
.text$x:00002B8C ; ===========================================================================
.text$x:00002B8C
.text$x:00002B8C ; Segment type: Pure code
.text$x:00002B8C ; Segment permissions: Read/Execute
.text$x:00002B8C _text$x         segment para public 'CODE' use32
.text$x:00002B8C                 assume cs:_text$x
.text$x:00002B8C                 ;org 2B8Ch
.text$x:00002B8C ; COMDAT (pick associative to section at 2B40)
.text$x:00002B8C                 assume es:nothing, ss:nothing, ds:_data, fs:nothing, gs:nothing
.text$x:00002B8C
.text$x:00002B8C ; =============== S U B R O U T I N E =======================================
.text$x:00002B8C
.text$x:00002B8C
.text$x:00002B8C __unwindfunclet$??1?$_Vector_val@U?$_Simple_types@I@std@@@std@@QAE@XZ$0 proc near
.text$x:00002B8C                                         ; DATA XREF: .xdata$x:000046B8o
.text$x:00002B8C                 mov     ecx, [ebp-10h]  ; this
.text$x:00002B8F                 jmp     ??1_Container_base12@std@@QAE@XZ ; std::_Container_base12::~_Container_base12(void)
.text$x:00002B8F __unwindfunclet$??1?$_Vector_val@U?$_Simple_types@I@std@@@std@@QAE@XZ$0 endp
.text$x:00002B8F
.text$x:00002B94
.text$x:00002B94 ; =============== S U B R O U T I N E =======================================
.text$x:00002B94
.text$x:00002B94
.text$x:00002B94 __ehhandler$??1?$_Vector_val@U?$_Simple_types@I@std@@@std@@QAE@XZ proc near
.text$x:00002B94                                         ; DATA XREF: std::_Vector_val<std::_Simple_types<uint>>::~_Vector_val<std::_Simple_types<uint>>(void)+5o
.text$x:00002B94
.text$x:00002B94 arg_4           = dword ptr  8
.text$x:00002B94
.text$x:00002B94                 mov     edx, [esp+arg_4]
.text$x:00002B98                 lea     eax, [edx+0Ch]
.text$x:00002B9B                 mov     ecx, [edx-8]
.text$x:00002B9E                 xor     ecx, eax
.text$x:00002BA0                 call    @__security_check_cookie@4 ; __security_check_cookie(x)
.text$x:00002BA5                 mov     eax, offset __ehfuncinfo$??1?$_Vector_val@U?$_Simple_types@I@std@@@std@@QAE@XZ
.text$x:00002BAA                 jmp     ___CxxFrameHandler3
.text$x:00002BAA __ehhandler$??1?$_Vector_val@U?$_Simple_types@I@std@@@std@@QAE@XZ endp
.text$x:00002BAA
.text$x:00002BAA ; ---------------------------------------------------------------------------
.text$x:00002BAF                 align 10h
.text$x:00002BAF _text$x         ends
.text$x:00002BAF
.text$mn:00002BB0 ; ===========================================================================
.text$mn:00002BB0
.text$mn:00002BB0 ; Segment type: Pure code
.text$mn:00002BB0 ; Segment permissions: Read/Execute
.text$mn:00002BB0 _text$mn        segment para public 'CODE' use32
.text$mn:00002BB0                 assume cs:_text$mn
.text$mn:00002BB0                 ;org 2BB0h
.text$mn:00002BB0 ; COMDAT (pick any)
.text$mn:00002BB0                 assume es:nothing, ss:nothing, ds:_data, fs:nothing, gs:nothing
.text$mn:00002BB0
.text$mn:00002BB0 ; =============== S U B R O U T I N E =======================================
.text$mn:00002BB0
.text$mn:00002BB0 ; Attributes: bp-based frame
.text$mn:00002BB0
.text$mn:00002BB0 ; public: __thiscall std::basic_string<char, struct std::char_traits<char>, class std::allocator<char>>::~basic_string<char, struct std::char_traits<char>, class std::allocator<char>>(void)
.text$mn:00002BB0                 public ??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ
.text$mn:00002BB0 ??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ proc near
.text$mn:00002BB0                                         ; CODE XREF: __unwindfunclet$?message@_Generic_error_category@std@@UBE?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@2@H@Z$0+13j
.text$mn:00002BB0                                         ; __unwindfunclet$?message@_Iostream_error_category@std@@UBE?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@2@H@Z$0+13j ...
.text$mn:00002BB0
.text$mn:00002BB0 var_10          = dword ptr -10h
.text$mn:00002BB0 var_C           = dword ptr -0Ch
.text$mn:00002BB0 var_4           = dword ptr -4
.text$mn:00002BB0
.text$mn:00002BB0                 push    ebp
.text$mn:00002BB1                 mov     ebp, esp
.text$mn:00002BB3                 push    0FFFFFFFFh
.text$mn:00002BB5                 push    offset __ehhandler$??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ
.text$mn:00002BBA                 mov     eax, large fs:0
.text$mn:00002BC0                 push    eax
.text$mn:00002BC1                 push    ecx
.text$mn:00002BC2                 mov     eax, dword ptr ds:___security_cookie
.text$mn:00002BC7                 xor     eax, ebp
.text$mn:00002BC9                 push    eax
.text$mn:00002BCA                 lea     eax, [ebp+var_C]
.text$mn:00002BCD                 mov     large fs:0, eax
.text$mn:00002BD3                 mov     [ebp+var_10], ecx
.text$mn:00002BD6                 mov     [ebp+var_4], 0
.text$mn:00002BDD                 push    0               ; Size
.text$mn:00002BDF                 push    1               ; char
.text$mn:00002BE1                 mov     ecx, [ebp+var_10]
.text$mn:00002BE4                 call    ?_Tidy@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEX_NI@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char>>::_Tidy(bool,uint)
.text$mn:00002BE9                 mov     [ebp+var_4], 0FFFFFFFFh
.text$mn:00002BF0                 mov     ecx, [ebp+var_10]
.text$mn:00002BF3                 call    ??1?$_String_alloc@$0A@U?$_String_base_types@DV?$allocator@D@std@@@std@@@std@@QAE@XZ ; std::_String_alloc<0,std::_String_base_types<char,std::allocator<char>>>::~_String_alloc<0,std::_String_base_types<char,std::allocator<char>>>(void)
.text$mn:00002BF8                 mov     ecx, [ebp+var_C]
.text$mn:00002BFB                 mov     large fs:0, ecx
.text$mn:00002C02                 pop     ecx
.text$mn:00002C03                 mov     esp, ebp
.text$mn:00002C05                 pop     ebp
.text$mn:00002C06                 retn
.text$mn:00002C06 ??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ endp
.text$mn:00002C06
.text$mn:00002C06 ; ---------------------------------------------------------------------------
.text$mn:00002C07                 align 4
.text$mn:00002C07 _text$mn        ends
.text$mn:00002C07
.text$x:00002C08 ; ===========================================================================
.text$x:00002C08
.text$x:00002C08 ; Segment type: Pure code
.text$x:00002C08 ; Segment permissions: Read/Execute
.text$x:00002C08 _text$x         segment para public 'CODE' use32
.text$x:00002C08                 assume cs:_text$x
.text$x:00002C08                 ;org 2C08h
.text$x:00002C08 ; COMDAT (pick associative to section at 2BB0)
.text$x:00002C08                 assume es:nothing, ss:nothing, ds:_data, fs:nothing, gs:nothing
.text$x:00002C08
.text$x:00002C08 ; =============== S U B R O U T I N E =======================================
.text$x:00002C08
.text$x:00002C08
.text$x:00002C08 __unwindfunclet$??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ$0 proc near
.text$x:00002C08                                         ; DATA XREF: .xdata$x:0000441Co
.text$x:00002C08                 mov     ecx, [ebp-10h]
.text$x:00002C0B                 jmp     ??1?$_String_alloc@$0A@U?$_String_base_types@DV?$allocator@D@std@@@std@@@std@@QAE@XZ ; std::_String_alloc<0,std::_String_base_types<char,std::allocator<char>>>::~_String_alloc<0,std::_String_base_types<char,std::allocator<char>>>(void)
.text$x:00002C0B __unwindfunclet$??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ$0 endp
.text$x:00002C0B
.text$x:00002C10
.text$x:00002C10 ; =============== S U B R O U T I N E =======================================
.text$x:00002C10
.text$x:00002C10
.text$x:00002C10 __ehhandler$??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ proc near
.text$x:00002C10                                         ; DATA XREF: std::basic_string<char,std::char_traits<char>,std::allocator<char>>::~basic_string<char,std::char_traits<char>,std::allocator<char>>(void)+5o
.text$x:00002C10
.text$x:00002C10 arg_4           = dword ptr  8
.text$x:00002C10
.text$x:00002C10                 mov     edx, [esp+arg_4]
.text$x:00002C14                 lea     eax, [edx+0Ch]
.text$x:00002C17                 mov     ecx, [edx-8]
.text$x:00002C1A                 xor     ecx, eax
.text$x:00002C1C                 call    @__security_check_cookie@4 ; __security_check_cookie(x)
.text$x:00002C21                 mov     eax, offset __ehfuncinfo$??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ
.text$x:00002C26                 jmp     ___CxxFrameHandler3
.text$x:00002C26 __ehhandler$??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ endp
.text$x:00002C26
.text$x:00002C26 ; ---------------------------------------------------------------------------
.text$x:00002C2B                 align 4
.text$x:00002C2B _text$x         ends
.text$x:00002C2B
.text$mn:00002C2C ; ===========================================================================
.text$mn:00002C2C
.text$mn:00002C2C ; Segment type: Pure code
.text$mn:00002C2C ; Segment permissions: Read/Execute
.text$mn:00002C2C _text$mn        segment para public 'CODE' use32
.text$mn:00002C2C                 assume cs:_text$mn
.text$mn:00002C2C                 ;org 2C2Ch
.text$mn:00002C2C ; COMDAT (pick any)
.text$mn:00002C2C                 assume es:nothing, ss:nothing, ds:_data, fs:nothing, gs:nothing
.text$mn:00002C2C
.text$mn:00002C2C ; =============== S U B R O U T I N E =======================================
.text$mn:00002C2C
.text$mn:00002C2C ; Attributes: bp-based frame
.text$mn:00002C2C
.text$mn:00002C2C ; public: __thiscall std::vector<unsigned int, class std::allocator<unsigned int>>::~vector<unsigned int, class std::allocator<unsigned int>>(void)
.text$mn:00002C2C                 public ??1?$vector@IV?$allocator@I@std@@@std@@QAE@XZ
.text$mn:00002C2C ??1?$vector@IV?$allocator@I@std@@@std@@QAE@XZ proc near
.text$mn:00002C2C                                         ; CODE XREF: DocumentMap::reloadMap(void)+FCp
.text$mn:00002C2C                                         ; __unwindfunclet$?reloadMap@DocumentMap@@QAEXXZ$0+3j
.text$mn:00002C2C
.text$mn:00002C2C var_10          = dword ptr -10h
.text$mn:00002C2C var_C           = dword ptr -0Ch
.text$mn:00002C2C var_4           = dword ptr -4
.text$mn:00002C2C
.text$mn:00002C2C                 push    ebp
.text$mn:00002C2D                 mov     ebp, esp
.text$mn:00002C2F                 push    0FFFFFFFFh
.text$mn:00002C31                 push    offset __ehhandler$??1?$vector@IV?$allocator@I@std@@@std@@QAE@XZ
.text$mn:00002C36                 mov     eax, large fs:0
.text$mn:00002C3C                 push    eax
.text$mn:00002C3D                 push    ecx
.text$mn:00002C3E                 mov     eax, dword ptr ds:___security_cookie
.text$mn:00002C43                 xor     eax, ebp
.text$mn:00002C45                 push    eax
.text$mn:00002C46                 lea     eax, [ebp+var_C]
.text$mn:00002C49                 mov     large fs:0, eax
.text$mn:00002C4F                 mov     [ebp+var_10], ecx
.text$mn:00002C52                 mov     [ebp+var_4], 0
.text$mn:00002C59                 mov     ecx, [ebp+var_10]
.text$mn:00002C5C                 call    ?_Tidy@?$vector@IV?$allocator@I@std@@@std@@IAEXXZ ; std::vector<uint,std::allocator<uint>>::_Tidy(void)
.text$mn:00002C61                 mov     [ebp+var_4], 0FFFFFFFFh
.text$mn:00002C68                 mov     ecx, [ebp+var_10]
.text$mn:00002C6B                 call    ??1?$_Vector_alloc@$0A@U?$_Vec_base_types@IV?$allocator@I@std@@@std@@@std@@QAE@XZ ; std::_Vector_alloc<0,std::_Vec_base_types<uint,std::allocator<uint>>>::~_Vector_alloc<0,std::_Vec_base_types<uint,std::allocator<uint>>>(void)
.text$mn:00002C70                 mov     ecx, [ebp+var_C]
.text$mn:00002C73                 mov     large fs:0, ecx
.text$mn:00002C7A                 pop     ecx
.text$mn:00002C7B                 mov     esp, ebp
.text$mn:00002C7D                 pop     ebp
.text$mn:00002C7E                 retn
.text$mn:00002C7E ??1?$vector@IV?$allocator@I@std@@@std@@QAE@XZ endp
.text$mn:00002C7E
.text$mn:00002C7E ; ---------------------------------------------------------------------------
.text$mn:00002C7F                 align 10h
.text$mn:00002C7F _text$mn        ends
.text$mn:00002C7F
.text$x:00002C80 ; ===========================================================================
.text$x:00002C80
.text$x:00002C80 ; Segment type: Pure code
.text$x:00002C80 ; Segment permissions: Read/Execute
.text$x:00002C80 _text$x         segment para public 'CODE' use32
.text$x:00002C80                 assume cs:_text$x
.text$x:00002C80                 ;org 2C80h
.text$x:00002C80 ; COMDAT (pick associative to section at 2C2C)
.text$x:00002C80                 assume es:nothing, ss:nothing, ds:_data, fs:nothing, gs:nothing
.text$x:00002C80
.text$x:00002C80 ; =============== S U B R O U T I N E =======================================
.text$x:00002C80
.text$x:00002C80
.text$x:00002C80 __unwindfunclet$??1?$vector@IV?$allocator@I@std@@@std@@QAE@XZ$0 proc near
.text$x:00002C80                                         ; DATA XREF: .xdata$x:00004768o
.text$x:00002C80                 mov     ecx, [ebp-10h]
.text$x:00002C83                 jmp     ??1?$_Vector_alloc@$0A@U?$_Vec_base_types@IV?$allocator@I@std@@@std@@@std@@QAE@XZ ; std::_Vector_alloc<0,std::_Vec_base_types<uint,std::allocator<uint>>>::~_Vector_alloc<0,std::_Vec_base_types<uint,std::allocator<uint>>>(void)
.text$x:00002C83 __unwindfunclet$??1?$vector@IV?$allocator@I@std@@@std@@QAE@XZ$0 endp
.text$x:00002C83
.text$x:00002C88
.text$x:00002C88 ; =============== S U B R O U T I N E =======================================
.text$x:00002C88
.text$x:00002C88
.text$x:00002C88 __ehhandler$??1?$vector@IV?$allocator@I@std@@@std@@QAE@XZ proc near
.text$x:00002C88                                         ; DATA XREF: std::vector<uint,std::allocator<uint>>::~vector<uint,std::allocator<uint>>(void)+5o
.text$x:00002C88
.text$x:00002C88 arg_4           = dword ptr  8
.text$x:00002C88
.text$x:00002C88                 mov     edx, [esp+arg_4]
.text$x:00002C8C                 lea     eax, [edx+0Ch]
.text$x:00002C8F                 mov     ecx, [edx-8]
.text$x:00002C92                 xor     ecx, eax
.text$x:00002C94                 call    @__security_check_cookie@4 ; __security_check_cookie(x)
.text$x:00002C99                 mov     eax, offset __ehfuncinfo$??1?$vector@IV?$allocator@I@std@@@std@@QAE@XZ
.text$x:00002C9E                 jmp     ___CxxFrameHandler3
.text$x:00002C9E __ehhandler$??1?$vector@IV?$allocator@I@std@@@std@@QAE@XZ endp
.text$x:00002C9E
.text$x:00002C9E ; ---------------------------------------------------------------------------
.text$x:00002CA3                 align 4
.text$x:00002CA3 _text$x         ends
.text$x:00002CA3
.text$mn:00002CA4 ; ===========================================================================
.text$mn:00002CA4
.text$mn:00002CA4 ; Segment type: Pure code
.text$mn:00002CA4 ; Segment permissions: Read/Execute
.text$mn:00002CA4 _text$mn        segment para public 'CODE' use32
.text$mn:00002CA4                 assume cs:_text$mn
.text$mn:00002CA4                 ;org 2CA4h
.text$mn:00002CA4 ; COMDAT (pick any)
.text$mn:00002CA4                 assume es:nothing, ss:nothing, ds:_data, fs:nothing, gs:nothing
.text$mn:00002CA4
.text$mn:00002CA4 ; =============== S U B R O U T I N E =======================================
.text$mn:00002CA4
.text$mn:00002CA4 ; Attributes: bp-based frame
.text$mn:00002CA4
.text$mn:00002CA4 ; _DWORD __thiscall std::_Container_base12::~_Container_base12(std::_Container_base12 *__hidden this)
.text$mn:00002CA4                 public ??1_Container_base12@std@@QAE@XZ
.text$mn:00002CA4 ??1_Container_base12@std@@QAE@XZ proc near
.text$mn:00002CA4                                         ; CODE XREF: __unwindfunclet$??0?$_String_val@U?$_Simple_types@D@std@@@std@@QAE@XZ$0+3j
.text$mn:00002CA4                                         ; __unwindfunclet$??0?$_Vector_val@U?$_Simple_types@I@std@@@std@@QAE@XZ$0+3j ...
.text$mn:00002CA4
.text$mn:00002CA4 var_4           = dword ptr -4
.text$mn:00002CA4
.text$mn:00002CA4                 push    ebp
.text$mn:00002CA5                 mov     ebp, esp
.text$mn:00002CA7                 push    ecx
.text$mn:00002CA8                 mov     [ebp+var_4], ecx
.text$mn:00002CAB                 mov     ecx, [ebp+var_4] ; this
.text$mn:00002CAE                 call    ?_Orphan_all@_Container_base12@std@@QAEXXZ ; std::_Container_base12::_Orphan_all(void)
.text$mn:00002CB3                 mov     esp, ebp
.text$mn:00002CB5                 pop     ebp
.text$mn:00002CB6                 retn
.text$mn:00002CB6 ??1_Container_base12@std@@QAE@XZ endp
.text$mn:00002CB6
.text$mn:00002CB6 ; ---------------------------------------------------------------------------
.text$mn:00002CB7                 align 4
.text$mn:00002CB7 _text$mn        ends
.text$mn:00002CB7
.text$mn:00002CB8 ; ===========================================================================
.text$mn:00002CB8
.text$mn:00002CB8 ; Segment type: Pure code
.text$mn:00002CB8 ; Segment permissions: Read/Execute
.text$mn:00002CB8 _text$mn        segment para public 'CODE' use32
.text$mn:00002CB8                 assume cs:_text$mn
.text$mn:00002CB8                 ;org 2CB8h
.text$mn:00002CB8 ; COMDAT (pick any)
.text$mn:00002CB8                 assume es:nothing, ss:nothing, ds:_data, fs:nothing, gs:nothing
.text$mn:00002CB8
.text$mn:00002CB8 ; =============== S U B R O U T I N E =======================================
.text$mn:00002CB8
.text$mn:00002CB8 ; Attributes: bp-based frame
.text$mn:00002CB8
.text$mn:00002CB8 ; _DWORD __thiscall std::_Generic_error_category::~_Generic_error_category(std::_Generic_error_category *__hidden this)
.text$mn:00002CB8                 public ??1_Generic_error_category@std@@UAE@XZ
.text$mn:00002CB8 ??1_Generic_error_category@std@@UAE@XZ proc near
.text$mn:00002CB8                                         ; CODE XREF: __unwindfunclet$??0_Iostream_error_category@std@@QAE@XZ$0+3j
.text$mn:00002CB8                                         ; __unwindfunclet$??0_System_error_category@std@@QAE@XZ$0+3j ...
.text$mn:00002CB8
.text$mn:00002CB8 var_10          = dword ptr -10h
.text$mn:00002CB8 var_C           = dword ptr -0Ch
.text$mn:00002CB8 var_4           = dword ptr -4
.text$mn:00002CB8
.text$mn:00002CB8                 push    ebp
.text$mn:00002CB9                 mov     ebp, esp
.text$mn:00002CBB                 push    0FFFFFFFFh
.text$mn:00002CBD                 push    offset __ehhandler$??1_Generic_error_category@std@@UAE@XZ
.text$mn:00002CC2                 mov     eax, large fs:0
.text$mn:00002CC8                 push    eax
.text$mn:00002CC9                 push    ecx
.text$mn:00002CCA                 mov     eax, dword ptr ds:___security_cookie
.text$mn:00002CCF                 xor     eax, ebp
.text$mn:00002CD1                 push    eax
.text$mn:00002CD2                 lea     eax, [ebp+var_C]
.text$mn:00002CD5                 mov     large fs:0, eax
.text$mn:00002CDB                 mov     [ebp+var_10], ecx
.text$mn:00002CDE                 mov     [ebp+var_4], 0
.text$mn:00002CE5                 mov     [ebp+var_4], 0FFFFFFFFh
.text$mn:00002CEC                 mov     ecx, [ebp+var_10] ; this
.text$mn:00002CEF                 call    ??1error_category@std@@UAE@XZ ; std::error_category::~error_category(void)
.text$mn:00002CF4                 mov     ecx, [ebp+var_C]
.text$mn:00002CF7                 mov     large fs:0, ecx
.text$mn:00002CFE                 pop     ecx
.text$mn:00002CFF                 mov     esp, ebp
.text$mn:00002D01                 pop     ebp
.text$mn:00002D02                 retn
.text$mn:00002D02 ??1_Generic_error_category@std@@UAE@XZ endp
.text$mn:00002D02
.text$mn:00002D02 ; ---------------------------------------------------------------------------
.text$mn:00002D03                 align 4
.text$mn:00002D03 _text$mn        ends
.text$mn:00002D03
.text$x:00002D04 ; ===========================================================================
.text$x:00002D04
.text$x:00002D04 ; Segment type: Pure code
.text$x:00002D04 ; Segment permissions: Read/Execute
.text$x:00002D04 _text$x         segment para public 'CODE' use32
.text$x:00002D04                 assume cs:_text$x
.text$x:00002D04                 ;org 2D04h
.text$x:00002D04 ; COMDAT (pick associative to section at 2CB8)
.text$x:00002D04                 assume es:nothing, ss:nothing, ds:_data, fs:nothing, gs:nothing
.text$x:00002D04
.text$x:00002D04 ; =============== S U B R O U T I N E =======================================
.text$x:00002D04
.text$x:00002D04
.text$x:00002D04 __unwindfunclet$??1_Generic_error_category@std@@UAE@XZ$0 proc near
.text$x:00002D04                                         ; DATA XREF: .xdata$x:0000452Co
.text$x:00002D04                 mov     ecx, [ebp-10h]  ; this
.text$x:00002D07                 jmp     ??1error_category@std@@UAE@XZ ; std::error_category::~error_category(void)
.text$x:00002D07 __unwindfunclet$??1_Generic_error_category@std@@UAE@XZ$0 endp
.text$x:00002D07
.text$x:00002D0C
.text$x:00002D0C ; =============== S U B R O U T I N E =======================================
.text$x:00002D0C
.text$x:00002D0C
.text$x:00002D0C __ehhandler$??1_Generic_error_category@std@@UAE@XZ proc near
.text$x:00002D0C                                         ; DATA XREF: std::_Generic_error_category::~_Generic_error_category(void)+5o
.text$x:00002D0C
.text$x:00002D0C arg_4           = dword ptr  8
.text$x:00002D0C
.text$x:00002D0C                 mov     edx, [esp+arg_4]
.text$x:00002D10                 lea     eax, [edx+0Ch]
.text$x:00002D13                 mov     ecx, [edx-8]
.text$x:00002D16                 xor     ecx, eax
.text$x:00002D18                 call    @__security_check_cookie@4 ; __security_check_cookie(x)
.text$x:00002D1D                 mov     eax, offset __ehfuncinfo$??1_Generic_error_category@std@@UAE@XZ
.text$x:00002D22                 jmp     ___CxxFrameHandler3
.text$x:00002D22 __ehhandler$??1_Generic_error_category@std@@UAE@XZ endp
.text$x:00002D22
.text$x:00002D22 ; ---------------------------------------------------------------------------
.text$x:00002D27                 align 4
.text$x:00002D27 _text$x         ends
.text$x:00002D27
.text$mn:00002D28 ; ===========================================================================
.text$mn:00002D28
.text$mn:00002D28 ; Segment type: Pure code
.text$mn:00002D28 ; Segment permissions: Read/Execute
.text$mn:00002D28 _text$mn        segment para public 'CODE' use32
.text$mn:00002D28                 assume cs:_text$mn
.text$mn:00002D28                 ;org 2D28h
.text$mn:00002D28 ; COMDAT (pick any)
.text$mn:00002D28                 assume es:nothing, ss:nothing, ds:_data, fs:nothing, gs:nothing
.text$mn:00002D28
.text$mn:00002D28 ; =============== S U B R O U T I N E =======================================
.text$mn:00002D28
.text$mn:00002D28 ; Attributes: bp-based frame
.text$mn:00002D28
.text$mn:00002D28 ; _DWORD __thiscall std::_Iostream_error_category::~_Iostream_error_category(std::_Iostream_error_category *__hidden this)
.text$mn:00002D28                 public ??1_Iostream_error_category@std@@UAE@XZ
.text$mn:00002D28 ??1_Iostream_error_category@std@@UAE@XZ proc near
.text$mn:00002D28                                         ; CODE XREF: std::_Iostream_error_category::`scalar deleting destructor'(uint)+Ap
.text$mn:00002D28                                         ; `dynamic atexit destructor for 'std::_Iostream_error_category std::_Error_objects<int>::_Iostream_object''(void)+8p
.text$mn:00002D28
.text$mn:00002D28 var_10          = dword ptr -10h
.text$mn:00002D28 var_C           = dword ptr -0Ch
.text$mn:00002D28 var_4           = dword ptr -4
.text$mn:00002D28
.text$mn:00002D28                 push    ebp
.text$mn:00002D29                 mov     ebp, esp
.text$mn:00002D2B                 push    0FFFFFFFFh
.text$mn:00002D2D                 push    offset __ehhandler$??1_Iostream_error_category@std@@UAE@XZ
.text$mn:00002D32                 mov     eax, large fs:0
.text$mn:00002D38                 push    eax
.text$mn:00002D39                 push    ecx
.text$mn:00002D3A                 mov     eax, dword ptr ds:___security_cookie
.text$mn:00002D3F                 xor     eax, ebp
.text$mn:00002D41                 push    eax
.text$mn:00002D42                 lea     eax, [ebp+var_C]
.text$mn:00002D45                 mov     large fs:0, eax
.text$mn:00002D4B                 mov     [ebp+var_10], ecx
.text$mn:00002D4E                 mov     [ebp+var_4], 0
.text$mn:00002D55                 mov     [ebp+var_4], 0FFFFFFFFh
.text$mn:00002D5C                 mov     ecx, [ebp+var_10] ; this
.text$mn:00002D5F                 call    ??1_Generic_error_category@std@@UAE@XZ ; std::_Generic_error_category::~_Generic_error_category(void)
.text$mn:00002D64                 mov     ecx, [ebp+var_C]
.text$mn:00002D67                 mov     large fs:0, ecx
.text$mn:00002D6E                 pop     ecx
.text$mn:00002D6F                 mov     esp, ebp
.text$mn:00002D71                 pop     ebp
.text$mn:00002D72                 retn
.text$mn:00002D72 ??1_Iostream_error_category@std@@UAE@XZ endp
.text$mn:00002D72
.text$mn:00002D72 ; ---------------------------------------------------------------------------
.text$mn:00002D73                 align 4
.text$mn:00002D73 _text$mn        ends
.text$mn:00002D73
.text$x:00002D74 ; ===========================================================================
.text$x:00002D74
.text$x:00002D74 ; Segment type: Pure code
.text$x:00002D74 ; Segment permissions: Read/Execute
.text$x:00002D74 _text$x         segment para public 'CODE' use32
.text$x:00002D74                 assume cs:_text$x
.text$x:00002D74                 ;org 2D74h
.text$x:00002D74 ; COMDAT (pick associative to section at 2D28)
.text$x:00002D74                 assume es:nothing, ss:nothing, ds:_data, fs:nothing, gs:nothing
.text$x:00002D74
.text$x:00002D74 ; =============== S U B R O U T I N E =======================================
.text$x:00002D74
.text$x:00002D74
.text$x:00002D74 __unwindfunclet$??1_Iostream_error_category@std@@UAE@XZ$0 proc near
.text$x:00002D74                                         ; DATA XREF: .xdata$x:000045B0o
.text$x:00002D74                 mov     ecx, [ebp-10h]  ; this
.text$x:00002D77                 jmp     ??1_Generic_error_category@std@@UAE@XZ ; std::_Generic_error_category::~_Generic_error_category(void)
.text$x:00002D77 __unwindfunclet$??1_Iostream_error_category@std@@UAE@XZ$0 endp
.text$x:00002D77
.text$x:00002D7C
.text$x:00002D7C ; =============== S U B R O U T I N E =======================================
.text$x:00002D7C
.text$x:00002D7C
.text$x:00002D7C __ehhandler$??1_Iostream_error_category@std@@UAE@XZ proc near
.text$x:00002D7C                                         ; DATA XREF: std::_Iostream_error_category::~_Iostream_error_category(void)+5o
.text$x:00002D7C
.text$x:00002D7C arg_4           = dword ptr  8
.text$x:00002D7C
.text$x:00002D7C                 mov     edx, [esp+arg_4]
.text$x:00002D80                 lea     eax, [edx+0Ch]
.text$x:00002D83                 mov     ecx, [edx-8]
.text$x:00002D86                 xor     ecx, eax
.text$x:00002D88                 call    @__security_check_cookie@4 ; __security_check_cookie(x)
.text$x:00002D8D                 mov     eax, offset __ehfuncinfo$??1_Iostream_error_category@std@@UAE@XZ
.text$x:00002D92                 jmp     ___CxxFrameHandler3
.text$x:00002D92 __ehhandler$??1_Iostream_error_category@std@@UAE@XZ endp
.text$x:00002D92
.text$x:00002D92 ; ---------------------------------------------------------------------------
.text$x:00002D97                 align 4
.text$x:00002D97 _text$x         ends
.text$x:00002D97
.text$mn:00002D98 ; ===========================================================================
.text$mn:00002D98
.text$mn:00002D98 ; Segment type: Pure code
.text$mn:00002D98 ; Segment permissions: Read/Execute
.text$mn:00002D98 _text$mn        segment para public 'CODE' use32
.text$mn:00002D98                 assume cs:_text$mn
.text$mn:00002D98                 ;org 2D98h
.text$mn:00002D98 ; COMDAT (pick any)
.text$mn:00002D98                 assume es:nothing, ss:nothing, ds:_data, fs:nothing, gs:nothing
.text$mn:00002D98
.text$mn:00002D98 ; =============== S U B R O U T I N E =======================================
.text$mn:00002D98
.text$mn:00002D98 ; Attributes: bp-based frame
.text$mn:00002D98
.text$mn:00002D98 ; _DWORD __thiscall std::_System_error_category::~_System_error_category(std::_System_error_category *__hidden this)
.text$mn:00002D98                 public ??1_System_error_category@std@@UAE@XZ
.text$mn:00002D98 ??1_System_error_category@std@@UAE@XZ proc near
.text$mn:00002D98                                         ; CODE XREF: std::_System_error_category::`scalar deleting destructor'(uint)+Ap
.text$mn:00002D98                                         ; `dynamic atexit destructor for 'std::_System_error_category std::_Error_objects<int>::_System_object''(void)+8p
.text$mn:00002D98
.text$mn:00002D98 var_10          = dword ptr -10h
.text$mn:00002D98 var_C           = dword ptr -0Ch
.text$mn:00002D98 var_4           = dword ptr -4
.text$mn:00002D98
.text$mn:00002D98                 push    ebp
.text$mn:00002D99                 mov     ebp, esp
.text$mn:00002D9B                 push    0FFFFFFFFh
.text$mn:00002D9D                 push    offset __ehhandler$??1_System_error_category@std@@UAE@XZ
.text$mn:00002DA2                 mov     eax, large fs:0
.text$mn:00002DA8                 push    eax
.text$mn:00002DA9                 push    ecx
.text$mn:00002DAA                 mov     eax, dword ptr ds:___security_cookie
.text$mn:00002DAF                 xor     eax, ebp
.text$mn:00002DB1                 push    eax
.text$mn:00002DB2                 lea     eax, [ebp+var_C]
.text$mn:00002DB5                 mov     large fs:0, eax
.text$mn:00002DBB                 mov     [ebp+var_10], ecx
.text$mn:00002DBE                 mov     [ebp+var_4], 0
.text$mn:00002DC5                 mov     [ebp+var_4], 0FFFFFFFFh
.text$mn:00002DCC                 mov     ecx, [ebp+var_10] ; this
.text$mn:00002DCF                 call    ??1_Generic_error_category@std@@UAE@XZ ; std::_Generic_error_category::~_Generic_error_category(void)
.text$mn:00002DD4                 mov     ecx, [ebp+var_C]
.text$mn:00002DD7                 mov     large fs:0, ecx
.text$mn:00002DDE                 pop     ecx
.text$mn:00002DDF                 mov     esp, ebp
.text$mn:00002DE1                 pop     ebp
.text$mn:00002DE2                 retn
.text$mn:00002DE2 ??1_System_error_category@std@@UAE@XZ endp
.text$mn:00002DE2
.text$mn:00002DE2 ; ---------------------------------------------------------------------------
.text$mn:00002DE3                 align 4
.text$mn:00002DE3 _text$mn        ends
.text$mn:00002DE3
.text$x:00002DE4 ; ===========================================================================
.text$x:00002DE4
.text$x:00002DE4 ; Segment type: Pure code
.text$x:00002DE4 ; Segment permissions: Read/Execute
.text$x:00002DE4 _text$x         segment para public 'CODE' use32
.text$x:00002DE4                 assume cs:_text$x
.text$x:00002DE4                 ;org 2DE4h
.text$x:00002DE4 ; COMDAT (pick associative to section at 2D98)
.text$x:00002DE4                 assume es:nothing, ss:nothing, ds:_data, fs:nothing, gs:nothing
.text$x:00002DE4
.text$x:00002DE4 ; =============== S U B R O U T I N E =======================================
.text$x:00002DE4
.text$x:00002DE4
.text$x:00002DE4 __unwindfunclet$??1_System_error_category@std@@UAE@XZ$0 proc near
.text$x:00002DE4                                         ; DATA XREF: .xdata$x:00004634o
.text$x:00002DE4                 mov     ecx, [ebp-10h]  ; this
.text$x:00002DE7                 jmp     ??1_Generic_error_category@std@@UAE@XZ ; std::_Generic_error_category::~_Generic_error_category(void)
.text$x:00002DE7 __unwindfunclet$??1_System_error_category@std@@UAE@XZ$0 endp
.text$x:00002DE7
.text$x:00002DEC
.text$x:00002DEC ; =============== S U B R O U T I N E =======================================
.text$x:00002DEC
.text$x:00002DEC
.text$x:00002DEC __ehhandler$??1_System_error_category@std@@UAE@XZ proc near
.text$x:00002DEC                                         ; DATA XREF: std::_System_error_category::~_System_error_category(void)+5o
.text$x:00002DEC
.text$x:00002DEC arg_4           = dword ptr  8
.text$x:00002DEC
.text$x:00002DEC                 mov     edx, [esp+arg_4]
.text$x:00002DF0                 lea     eax, [edx+0Ch]
.text$x:00002DF3                 mov     ecx, [edx-8]
.text$x:00002DF6                 xor     ecx, eax
.text$x:00002DF8                 call    @__security_check_cookie@4 ; __security_check_cookie(x)
.text$x:00002DFD                 mov     eax, offset __ehfuncinfo$??1_System_error_category@std@@UAE@XZ
.text$x:00002E02                 jmp     ___CxxFrameHandler3
.text$x:00002E02 __ehhandler$??1_System_error_category@std@@UAE@XZ endp
.text$x:00002E02
.text$x:00002E02 ; ---------------------------------------------------------------------------
.text$x:00002E07                 align 4
.text$x:00002E07 _text$x         ends
.text$x:00002E07
.text$mn:00002E08 ; ===========================================================================
.text$mn:00002E08
.text$mn:00002E08 ; Segment type: Pure code
.text$mn:00002E08 ; Segment permissions: Read/Execute
.text$mn:00002E08 _text$mn        segment para public 'CODE' use32
.text$mn:00002E08                 assume cs:_text$mn
.text$mn:00002E08                 ;org 2E08h
.text$mn:00002E08 ; COMDAT (pick any)
.text$mn:00002E08                 assume es:nothing, ss:nothing, ds:_data, fs:nothing, gs:nothing
.text$mn:00002E08
.text$mn:00002E08 ; =============== S U B R O U T I N E =======================================
.text$mn:00002E08
.text$mn:00002E08 ; Attributes: bp-based frame
.text$mn:00002E08
.text$mn:00002E08 ; _DWORD __thiscall std::error_category::~error_category(std::error_category *__hidden this)
.text$mn:00002E08                 public ??1error_category@std@@UAE@XZ
.text$mn:00002E08 ??1error_category@std@@UAE@XZ proc near ; CODE XREF: __unwindfunclet$??0_Generic_error_category@std@@QAE@XZ$0+3j
.text$mn:00002E08                                         ; std::_Generic_error_category::~_Generic_error_category(void)+37p ...
.text$mn:00002E08
.text$mn:00002E08 var_4           = dword ptr -4
.text$mn:00002E08
.text$mn:00002E08                 push    ebp
.text$mn:00002E09                 mov     ebp, esp
.text$mn:00002E0B                 push    ecx
.text$mn:00002E0C                 mov     [ebp+var_4], ecx
.text$mn:00002E0F                 mov     eax, [ebp+var_4]
.text$mn:00002E12                 mov     dword ptr [eax], offset ??_7error_category@std@@6B@ ; const std::error_category::`vftable'
.text$mn:00002E18                 mov     esp, ebp
.text$mn:00002E1A                 pop     ebp
.text$mn:00002E1B                 retn
.text$mn:00002E1B ??1error_category@std@@UAE@XZ endp
.text$mn:00002E1B
.text$mn:00002E1B _text$mn        ends
.text$mn:00002E1B
.text$mn:00002E1C ; ===========================================================================
.text$mn:00002E1C
.text$mn:00002E1C ; Segment type: Pure code
.text$mn:00002E1C ; Segment permissions: Read/Execute
.text$mn:00002E1C _text$mn        segment para public 'CODE' use32
.text$mn:00002E1C                 assume cs:_text$mn
.text$mn:00002E1C                 ;org 2E1Ch
.text$mn:00002E1C ; COMDAT (pick any)
.text$mn:00002E1C                 assume es:nothing, ss:nothing, ds:_data, fs:nothing, gs:nothing
.text$mn:00002E1C
.text$mn:00002E1C ; =============== S U B R O U T I N E =======================================
.text$mn:00002E1C
.text$mn:00002E1C ; Attributes: bp-based frame
.text$mn:00002E1C
.text$mn:00002E1C ; void *__cdecl operator new(unsigned int, void *)
.text$mn:00002E1C                 public ??2@YAPAXIPAX@Z
.text$mn:00002E1C ??2@YAPAXIPAX@Z proc near               ; CODE XREF: std::allocator<char>::construct<char *,char * &>(char * *,char * &)+2Ep
.text$mn:00002E1C                                         ; std::allocator<std::_Container_proxy>::construct<std::_Container_proxy,std::_Container_proxy>(std::_Container_proxy *,std::_Container_proxy &&)+2Ep
.text$mn:00002E1C
.text$mn:00002E1C arg_4           = dword ptr  0Ch
.text$mn:00002E1C
.text$mn:00002E1C                 push    ebp
.text$mn:00002E1D                 mov     ebp, esp
.text$mn:00002E1F                 mov     eax, [ebp+arg_4]
.text$mn:00002E22                 pop     ebp
.text$mn:00002E23                 retn
.text$mn:00002E23 ??2@YAPAXIPAX@Z endp
.text$mn:00002E23
.text$mn:00002E23 _text$mn        ends
.text$mn:00002E23
.text$mn:00002E24 ; ===========================================================================
.text$mn:00002E24
.text$mn:00002E24 ; Segment type: Pure code
.text$mn:00002E24 ; Segment permissions: Read/Execute
.text$mn:00002E24 _text$mn        segment para public 'CODE' use32
.text$mn:00002E24                 assume cs:_text$mn
.text$mn:00002E24                 ;org 2E24h
.text$mn:00002E24 ; COMDAT (pick any)
.text$mn:00002E24                 assume es:nothing, ss:nothing, ds:_data, fs:nothing, gs:nothing
.text$mn:00002E24
.text$mn:00002E24 ; =============== S U B R O U T I N E =======================================
.text$mn:00002E24
.text$mn:00002E24 ; Attributes: bp-based frame
.text$mn:00002E24
.text$mn:00002E24 ; void __cdecl operator delete(void *)
.text$mn:00002E24                 public ??3@YAXPAX0@Z
.text$mn:00002E24 ??3@YAXPAX0@Z   proc near               ; CODE XREF: __unwindfunclet$??$construct@PADAAPAD@?$allocator@D@std@@QAEXPAPADAAPAD@Z$0+8p
.text$mn:00002E24                                         ; __unwindfunclet$??$construct@U_Container_proxy@std@@U12@@?$allocator@U_Container_proxy@std@@@std@@QAEXPAU_Container_proxy@1@$$QAU21@@Z$0+8p
.text$mn:00002E24                 push    ebp
.text$mn:00002E25                 mov     ebp, esp
.text$mn:00002E27                 pop     ebp
.text$mn:00002E28                 retn
.text$mn:00002E28 ??3@YAXPAX0@Z   endp
.text$mn:00002E28
.text$mn:00002E28 ; ---------------------------------------------------------------------------
.text$mn:00002E29                 align 4
.text$mn:00002E29 _text$mn        ends
.text$mn:00002E29
.text$mn:00002E2C ; ===========================================================================
.text$mn:00002E2C
.text$mn:00002E2C ; Segment type: Pure code
.text$mn:00002E2C ; Segment permissions: Read/Execute
.text$mn:00002E2C _text$mn        segment para public 'CODE' use32
.text$mn:00002E2C                 assume cs:_text$mn
.text$mn:00002E2C                 ;org 2E2Ch
.text$mn:00002E2C ; COMDAT (pick any)
.text$mn:00002E2C                 assume es:nothing, ss:nothing, ds:_data, fs:nothing, gs:nothing
.text$mn:00002E2C
.text$mn:00002E2C ; =============== S U B R O U T I N E =======================================
.text$mn:00002E2C
.text$mn:00002E2C ; Attributes: bp-based frame
.text$mn:00002E2C
.text$mn:00002E2C ; public: bool __thiscall std::error_category::operator==(class std::error_category const &)const
.text$mn:00002E2C                 public ??8error_category@std@@QBE_NABV01@@Z
.text$mn:00002E2C ??8error_category@std@@QBE_NABV01@@Z proc near
.text$mn:00002E2C                                         ; CODE XREF: std::error_condition::operator==(std::error_condition const &)+1Dp
.text$mn:00002E2C                                         ; std::error_category::equivalent(std::error_code const &,int)+15p
.text$mn:00002E2C
.text$mn:00002E2C var_8           = dword ptr -8
.text$mn:00002E2C var_4           = dword ptr -4
.text$mn:00002E2C arg_0           = dword ptr  8
.text$mn:00002E2C
.text$mn:00002E2C                 push    ebp
.text$mn:00002E2D                 mov     ebp, esp
.text$mn:00002E2F                 sub     esp, 8
.text$mn:00002E32                 mov     [ebp+var_8], ecx
.text$mn:00002E35                 mov     eax, [ebp+var_8]
.text$mn:00002E38                 cmp     eax, [ebp+arg_0]
.text$mn:00002E3B                 jnz     short loc_2E46
.text$mn:00002E3D                 mov     [ebp+var_4], 1
.text$mn:00002E44                 jmp     short loc_2E4D
.text$mn:00002E46 ; ---------------------------------------------------------------------------
.text$mn:00002E46
.text$mn:00002E46 loc_2E46:                               ; CODE XREF: std::error_category::operator==(std::error_category const &)+Fj
.text$mn:00002E46                 mov     [ebp+var_4], 0
.text$mn:00002E4D
.text$mn:00002E4D loc_2E4D:                               ; CODE XREF: std::error_category::operator==(std::error_category const &)+18j
.text$mn:00002E4D                 mov     al, byte ptr [ebp+var_4]
.text$mn:00002E50                 mov     esp, ebp
.text$mn:00002E52                 pop     ebp
.text$mn:00002E53                 retn    4
.text$mn:00002E53 ??8error_category@std@@QBE_NABV01@@Z endp
.text$mn:00002E53
.text$mn:00002E53 ; ---------------------------------------------------------------------------
.text$mn:00002E56                 align 4
.text$mn:00002E56 _text$mn        ends
.text$mn:00002E56
.text$mn:00002E58 ; ===========================================================================
.text$mn:00002E58
.text$mn:00002E58 ; Segment type: Pure code
.text$mn:00002E58 ; Segment permissions: Read/Execute
.text$mn:00002E58 _text$mn        segment para public 'CODE' use32
.text$mn:00002E58                 assume cs:_text$mn
.text$mn:00002E58                 ;org 2E58h
.text$mn:00002E58 ; COMDAT (pick any)
.text$mn:00002E58                 assume es:nothing, ss:nothing, ds:_data, fs:nothing, gs:nothing
.text$mn:00002E58
.text$mn:00002E58 ; =============== S U B R O U T I N E =======================================
.text$mn:00002E58
.text$mn:00002E58 ; Attributes: bp-based frame
.text$mn:00002E58
.text$mn:00002E58 ; int __stdcall std::error_condition::operator==(std::error_condition *)
.text$mn:00002E58                 public ??8error_condition@std@@QBE_NABV01@@Z
.text$mn:00002E58 ??8error_condition@std@@QBE_NABV01@@Z proc near
.text$mn:00002E58                                         ; CODE XREF: std::error_category::equivalent(int,std::error_condition const &)+24p
.text$mn:00002E58
.text$mn:00002E58 var_8           = dword ptr -8
.text$mn:00002E58 var_4           = dword ptr -4
.text$mn:00002E58 arg_0           = dword ptr  8
.text$mn:00002E58
.text$mn:00002E58                 push    ebp
.text$mn:00002E59                 mov     ebp, esp
.text$mn:00002E5B                 sub     esp, 8
.text$mn:00002E5E                 push    esi
.text$mn:00002E5F                 mov     [ebp+var_4], ecx
.text$mn:00002E62                 mov     ecx, [ebp+arg_0] ; this
.text$mn:00002E65                 call    ?category@error_condition@std@@QBEABVerror_category@2@XZ ; std::error_condition::category(void)
.text$mn:00002E6A                 push    eax
.text$mn:00002E6B                 mov     ecx, [ebp+var_4] ; this
.text$mn:00002E6E                 call    ?category@error_condition@std@@QBEABVerror_category@2@XZ ; std::error_condition::category(void)
.text$mn:00002E73                 mov     ecx, eax
.text$mn:00002E75                 call    ??8error_category@std@@QBE_NABV01@@Z ; std::error_category::operator==(std::error_category const &)
.text$mn:00002E7A                 movzx   eax, al
.text$mn:00002E7D                 test    eax, eax
.text$mn:00002E7F                 jz      short loc_2EA0
.text$mn:00002E81                 mov     ecx, [ebp+var_4] ; this
.text$mn:00002E84                 call    ?value@error_condition@std@@QBEHXZ ; std::error_condition::value(void)
.text$mn:00002E89                 mov     esi, eax
.text$mn:00002E8B                 mov     ecx, [ebp+arg_0] ; this
.text$mn:00002E8E                 call    ?value@error_condition@std@@QBEHXZ ; std::error_condition::value(void)
.text$mn:00002E93                 cmp     esi, eax
.text$mn:00002E95                 jnz     short loc_2EA0
.text$mn:00002E97                 mov     [ebp+var_8], 1
.text$mn:00002E9E                 jmp     short loc_2EA7
.text$mn:00002EA0 ; ---------------------------------------------------------------------------
.text$mn:00002EA0
.text$mn:00002EA0 loc_2EA0:                               ; CODE XREF: std::error_condition::operator==(std::error_condition const &)+27j
.text$mn:00002EA0                                         ; std::error_condition::operator==(std::error_condition const &)+3Dj
.text$mn:00002EA0                 mov     [ebp+var_8], 0
.text$mn:00002EA7
.text$mn:00002EA7 loc_2EA7:                               ; CODE XREF: std::error_condition::operator==(std::error_condition const &)+46j
.text$mn:00002EA7                 mov     al, byte ptr [ebp+var_8]
.text$mn:00002EAA                 pop     esi
.text$mn:00002EAB                 mov     esp, ebp
.text$mn:00002EAD                 pop     ebp
.text$mn:00002EAE                 retn    4
.text$mn:00002EAE ??8error_condition@std@@QBE_NABV01@@Z endp
.text$mn:00002EAE
.text$mn:00002EAE ; ---------------------------------------------------------------------------
.text$mn:00002EB1                 align 4
.text$mn:00002EB1 _text$mn        ends
.text$mn:00002EB1
.text$mn:00002EB4 ; ===========================================================================
.text$mn:00002EB4
.text$mn:00002EB4 ; Segment type: Pure code
.text$mn:00002EB4 ; Segment permissions: Read/Execute
.text$mn:00002EB4 _text$mn        segment para public 'CODE' use32
.text$mn:00002EB4                 assume cs:_text$mn
.text$mn:00002EB4                 ;org 2EB4h
.text$mn:00002EB4 ; COMDAT (pick any)
.text$mn:00002EB4                 assume es:nothing, ss:nothing, ds:_data, fs:nothing, gs:nothing
.text$mn:00002EB4
.text$mn:00002EB4 ; =============== S U B R O U T I N E =======================================
.text$mn:00002EB4
.text$mn:00002EB4 ; Attributes: bp-based frame
.text$mn:00002EB4
.text$mn:00002EB4 ; public: virtual void * __thiscall std::_Generic_error_category::`scalar deleting destructor'(unsigned int)
.text$mn:00002EB4                 public ??_G_Generic_error_category@std@@UAEPAXI@Z
.text$mn:00002EB4 ??_G_Generic_error_category@std@@UAEPAXI@Z proc near
.text$mn:00002EB4
.text$mn:00002EB4 var_4           = dword ptr -4
.text$mn:00002EB4 arg_0           = dword ptr  8
.text$mn:00002EB4
.text$mn:00002EB4                 push    ebp
.text$mn:00002EB5                 mov     ebp, esp
.text$mn:00002EB7                 push    ecx
.text$mn:00002EB8                 mov     [ebp+var_4], ecx
.text$mn:00002EBB                 mov     ecx, [ebp+var_4] ; this
.text$mn:00002EBE                 call    ??1_Generic_error_category@std@@UAE@XZ ; std::_Generic_error_category::~_Generic_error_category(void)
.text$mn:00002EC3                 mov     eax, [ebp+arg_0]
.text$mn:00002EC6                 and     eax, 1
.text$mn:00002EC9                 jz      short loc_2ED7
.text$mn:00002ECB                 mov     ecx, [ebp+var_4]
.text$mn:00002ECE                 push    ecx             ; void *
.text$mn:00002ECF                 call    ??3@YAXPAX@Z    ; operator delete(void *)
.text$mn:00002ED4                 add     esp, 4
.text$mn:00002ED7
.text$mn:00002ED7 loc_2ED7:                               ; CODE XREF: std::_Generic_error_category::`scalar deleting destructor'(uint)+15j
.text$mn:00002ED7                 mov     eax, [ebp+var_4]
.text$mn:00002EDA                 mov     esp, ebp
.text$mn:00002EDC                 pop     ebp
.text$mn:00002EDD                 retn    4
.text$mn:00002EDD ??_G_Generic_error_category@std@@UAEPAXI@Z endp
.text$mn:00002EDD
.text$mn:00002EDD _text$mn        ends
.text$mn:00002EDD
.text$mn:00002EE0 ; ===========================================================================
.text$mn:00002EE0
.text$mn:00002EE0 ; Segment type: Pure code
.text$mn:00002EE0 ; Segment permissions: Read/Execute
.text$mn:00002EE0 _text$mn        segment para public 'CODE' use32
.text$mn:00002EE0                 assume cs:_text$mn
.text$mn:00002EE0                 ;org 2EE0h
.text$mn:00002EE0 ; COMDAT (pick any)
.text$mn:00002EE0                 assume es:nothing, ss:nothing, ds:_data, fs:nothing, gs:nothing
.text$mn:00002EE0
.text$mn:00002EE0 ; =============== S U B R O U T I N E =======================================
.text$mn:00002EE0
.text$mn:00002EE0 ; Attributes: bp-based frame
.text$mn:00002EE0
.text$mn:00002EE0 ; public: virtual void * __thiscall std::_Iostream_error_category::`scalar deleting destructor'(unsigned int)
.text$mn:00002EE0                 public ??_G_Iostream_error_category@std@@UAEPAXI@Z
.text$mn:00002EE0 ??_G_Iostream_error_category@std@@UAEPAXI@Z proc near
.text$mn:00002EE0
.text$mn:00002EE0 var_4           = dword ptr -4
.text$mn:00002EE0 arg_0           = dword ptr  8
.text$mn:00002EE0
.text$mn:00002EE0                 push    ebp
.text$mn:00002EE1                 mov     ebp, esp
.text$mn:00002EE3                 push    ecx
.text$mn:00002EE4                 mov     [ebp+var_4], ecx
.text$mn:00002EE7                 mov     ecx, [ebp+var_4] ; this
.text$mn:00002EEA                 call    ??1_Iostream_error_category@std@@UAE@XZ ; std::_Iostream_error_category::~_Iostream_error_category(void)
.text$mn:00002EEF                 mov     eax, [ebp+arg_0]
.text$mn:00002EF2                 and     eax, 1
.text$mn:00002EF5                 jz      short loc_2F03
.text$mn:00002EF7                 mov     ecx, [ebp+var_4]
.text$mn:00002EFA                 push    ecx             ; void *
.text$mn:00002EFB                 call    ??3@YAXPAX@Z    ; operator delete(void *)
.text$mn:00002F00                 add     esp, 4
.text$mn:00002F03
.text$mn:00002F03 loc_2F03:                               ; CODE XREF: std::_Iostream_error_category::`scalar deleting destructor'(uint)+15j
.text$mn:00002F03                 mov     eax, [ebp+var_4]
.text$mn:00002F06                 mov     esp, ebp
.text$mn:00002F08                 pop     ebp
.text$mn:00002F09                 retn    4
.text$mn:00002F09 ??_G_Iostream_error_category@std@@UAEPAXI@Z endp
.text$mn:00002F09
.text$mn:00002F09 _text$mn        ends
.text$mn:00002F09
.text$mn:00002F0C ; ===========================================================================
.text$mn:00002F0C
.text$mn:00002F0C ; Segment type: Pure code
.text$mn:00002F0C ; Segment permissions: Read/Execute
.text$mn:00002F0C _text$mn        segment para public 'CODE' use32
.text$mn:00002F0C                 assume cs:_text$mn
.text$mn:00002F0C                 ;org 2F0Ch
.text$mn:00002F0C ; COMDAT (pick any)
.text$mn:00002F0C                 assume es:nothing, ss:nothing, ds:_data, fs:nothing, gs:nothing
.text$mn:00002F0C
.text$mn:00002F0C ; =============== S U B R O U T I N E =======================================
.text$mn:00002F0C
.text$mn:00002F0C ; Attributes: bp-based frame
.text$mn:00002F0C
.text$mn:00002F0C ; public: virtual void * __thiscall std::_System_error_category::`scalar deleting destructor'(unsigned int)
.text$mn:00002F0C                 public ??_G_System_error_category@std@@UAEPAXI@Z
.text$mn:00002F0C ??_G_System_error_category@std@@UAEPAXI@Z proc near
.text$mn:00002F0C
.text$mn:00002F0C var_4           = dword ptr -4
.text$mn:00002F0C arg_0           = dword ptr  8
.text$mn:00002F0C
.text$mn:00002F0C                 push    ebp
.text$mn:00002F0D                 mov     ebp, esp
.text$mn:00002F0F                 push    ecx
.text$mn:00002F10                 mov     [ebp+var_4], ecx
.text$mn:00002F13                 mov     ecx, [ebp+var_4] ; this
.text$mn:00002F16                 call    ??1_System_error_category@std@@UAE@XZ ; std::_System_error_category::~_System_error_category(void)
.text$mn:00002F1B                 mov     eax, [ebp+arg_0]
.text$mn:00002F1E                 and     eax, 1
.text$mn:00002F21                 jz      short loc_2F2F
.text$mn:00002F23                 mov     ecx, [ebp+var_4]
.text$mn:00002F26                 push    ecx             ; void *
.text$mn:00002F27                 call    ??3@YAXPAX@Z    ; operator delete(void *)
.text$mn:00002F2C                 add     esp, 4
.text$mn:00002F2F
.text$mn:00002F2F loc_2F2F:                               ; CODE XREF: std::_System_error_category::`scalar deleting destructor'(uint)+15j
.text$mn:00002F2F                 mov     eax, [ebp+var_4]
.text$mn:00002F32                 mov     esp, ebp
.text$mn:00002F34                 pop     ebp
.text$mn:00002F35                 retn    4
.text$mn:00002F35 ??_G_System_error_category@std@@UAEPAXI@Z endp
.text$mn:00002F35
.text$mn:00002F35 _text$mn        ends
.text$mn:00002F35
.text$mn:00002F38 ; ===========================================================================
.text$mn:00002F38
.text$mn:00002F38 ; Segment type: Pure code
.text$mn:00002F38 ; Segment permissions: Read/Execute
.text$mn:00002F38 _text$mn        segment para public 'CODE' use32
.text$mn:00002F38                 assume cs:_text$mn
.text$mn:00002F38                 ;org 2F38h
.text$mn:00002F38 ; COMDAT (pick any)
.text$mn:00002F38                 assume es:nothing, ss:nothing, ds:_data, fs:nothing, gs:nothing
.text$mn:00002F38
.text$mn:00002F38 ; =============== S U B R O U T I N E =======================================
.text$mn:00002F38
.text$mn:00002F38 ; Attributes: bp-based frame
.text$mn:00002F38
.text$mn:00002F38 ; public: virtual void * __thiscall std::error_category::`scalar deleting destructor'(unsigned int)
.text$mn:00002F38                 public ??_Gerror_category@std@@UAEPAXI@Z
.text$mn:00002F38 ??_Gerror_category@std@@UAEPAXI@Z proc near
.text$mn:00002F38
.text$mn:00002F38 var_4           = dword ptr -4
.text$mn:00002F38 arg_0           = dword ptr  8
.text$mn:00002F38
.text$mn:00002F38                 push    ebp
.text$mn:00002F39                 mov     ebp, esp
.text$mn:00002F3B                 push    ecx
.text$mn:00002F3C                 mov     [ebp+var_4], ecx
.text$mn:00002F3F                 mov     ecx, [ebp+var_4] ; this
.text$mn:00002F42                 call    ??1error_category@std@@UAE@XZ ; std::error_category::~error_category(void)
.text$mn:00002F47                 mov     eax, [ebp+arg_0]
.text$mn:00002F4A                 and     eax, 1
.text$mn:00002F4D                 jz      short loc_2F5B
.text$mn:00002F4F                 mov     ecx, [ebp+var_4]
.text$mn:00002F52                 push    ecx             ; void *
.text$mn:00002F53                 call    ??3@YAXPAX@Z    ; operator delete(void *)
.text$mn:00002F58                 add     esp, 4
.text$mn:00002F5B
.text$mn:00002F5B loc_2F5B:                               ; CODE XREF: std::error_category::`scalar deleting destructor'(uint)+15j
.text$mn:00002F5B                 mov     eax, [ebp+var_4]
.text$mn:00002F5E                 mov     esp, ebp
.text$mn:00002F60                 pop     ebp
.text$mn:00002F61                 retn    4
.text$mn:00002F61 ??_Gerror_category@std@@UAEPAXI@Z endp
.text$mn:00002F61
.text$mn:00002F61 _text$mn        ends
.text$mn:00002F61
.text$di:00002F64 ; ===========================================================================
.text$di:00002F64
.text$di:00002F64 ; Segment type: Pure code
.text$di:00002F64 ; Segment permissions: Read/Execute
.text$di:00002F64 _text$di        segment para public 'CODE' use32
.text$di:00002F64                 assume cs:_text$di
.text$di:00002F64                 ;org 2F64h
.text$di:00002F64 ; COMDAT (pick any)
.text$di:00002F64                 assume es:nothing, ss:nothing, ds:_data, fs:nothing, gs:nothing
.text$di:00002F64
.text$di:00002F64 ; =============== S U B R O U T I N E =======================================
.text$di:00002F64
.text$di:00002F64 ; Attributes: bp-based frame
.text$di:00002F64
.text$di:00002F64 ; void __cdecl `dynamic initializer for 'public: static class std::_Generic_error_category std::_Error_objects<int>::_Generic_object''(void)
.text$di:00002F64 ??__E?_Generic_object@?$_Error_objects@H@std@@2V_Generic_error_category@2@A@@YAXXZ proc near
.text$di:00002F64                                         ; DATA XREF: .CRT$XCU:void (*std::_Error_objects<int>::_Generic_object$initializer$)(void)o
.text$di:00002F64                 push    ebp
.text$di:00002F65                 mov     ebp, esp
.text$di:00002F67                 mov     ecx, offset ?_Generic_object@?$_Error_objects@H@std@@2V_Generic_error_category@2@A ; this
.text$di:00002F6C                 call    ??0_Generic_error_category@std@@QAE@XZ ; std::_Generic_error_category::_Generic_error_category(void)
.text$di:00002F71                 push    offset ??__F?_Generic_object@?$_Error_objects@H@std@@2V_Generic_error_category@2@A@@YAXXZ ; void (__cdecl *)()
.text$di:00002F76                 call    _atexit
.text$di:00002F7B                 add     esp, 4
.text$di:00002F7E                 pop     ebp
.text$di:00002F7F                 retn
.text$di:00002F7F ??__E?_Generic_object@?$_Error_objects@H@std@@2V_Generic_error_category@2@A@@YAXXZ endp
.text$di:00002F7F
.text$di:00002F7F _text$di        ends
.text$di:00002F7F
.text$di:00002F80 ; ===========================================================================
.text$di:00002F80
.text$di:00002F80 ; Segment type: Pure code
.text$di:00002F80 ; Segment permissions: Read/Execute
.text$di:00002F80 _text$di        segment para public 'CODE' use32
.text$di:00002F80                 assume cs:_text$di
.text$di:00002F80                 ;org 2F80h
.text$di:00002F80 ; COMDAT (pick any)
.text$di:00002F80                 assume es:nothing, ss:nothing, ds:_data, fs:nothing, gs:nothing
.text$di:00002F80
.text$di:00002F80 ; =============== S U B R O U T I N E =======================================
.text$di:00002F80
.text$di:00002F80 ; Attributes: bp-based frame
.text$di:00002F80
.text$di:00002F80 ; void __cdecl `dynamic initializer for 'public: static class std::_Iostream_error_category std::_Error_objects<int>::_Iostream_object''(void)
.text$di:00002F80 ??__E?_Iostream_object@?$_Error_objects@H@std@@2V_Iostream_error_category@2@A@@YAXXZ proc near
.text$di:00002F80                                         ; DATA XREF: .CRT$XCU:void (*std::_Error_objects<int>::_Iostream_object$initializer$)(void)o
.text$di:00002F80                 push    ebp
.text$di:00002F81                 mov     ebp, esp
.text$di:00002F83                 mov     ecx, offset ?_Iostream_object@?$_Error_objects@H@std@@2V_Iostream_error_category@2@A ; this
.text$di:00002F88                 call    ??0_Iostream_error_category@std@@QAE@XZ ; std::_Iostream_error_category::_Iostream_error_category(void)
.text$di:00002F8D                 push    offset ??__F?_Iostream_object@?$_Error_objects@H@std@@2V_Iostream_error_category@2@A@@YAXXZ ; void (__cdecl *)()
.text$di:00002F92                 call    _atexit
.text$di:00002F97                 add     esp, 4
.text$di:00002F9A                 pop     ebp
.text$di:00002F9B                 retn
.text$di:00002F9B ??__E?_Iostream_object@?$_Error_objects@H@std@@2V_Iostream_error_category@2@A@@YAXXZ endp
.text$di:00002F9B
.text$di:00002F9B _text$di        ends
.text$di:00002F9B
.text$di:00002F9C ; ===========================================================================
.text$di:00002F9C
.text$di:00002F9C ; Segment type: Pure code
.text$di:00002F9C ; Segment permissions: Read/Execute
.text$di:00002F9C _text$di        segment para public 'CODE' use32
.text$di:00002F9C                 assume cs:_text$di
.text$di:00002F9C                 ;org 2F9Ch
.text$di:00002F9C ; COMDAT (pick any)
.text$di:00002F9C                 assume es:nothing, ss:nothing, ds:_data, fs:nothing, gs:nothing
.text$di:00002F9C
.text$di:00002F9C ; =============== S U B R O U T I N E =======================================
.text$di:00002F9C
.text$di:00002F9C ; Attributes: bp-based frame
.text$di:00002F9C
.text$di:00002F9C ; void __cdecl `dynamic initializer for 'public: static class std::_System_error_category std::_Error_objects<int>::_System_object''(void)
.text$di:00002F9C ??__E?_System_object@?$_Error_objects@H@std@@2V_System_error_category@2@A@@YAXXZ proc near
.text$di:00002F9C                                         ; DATA XREF: .CRT$XCU:void (*std::_Error_objects<int>::_System_object$initializer$)(void)o
.text$di:00002F9C                 push    ebp
.text$di:00002F9D                 mov     ebp, esp
.text$di:00002F9F                 mov     ecx, offset ?_System_object@?$_Error_objects@H@std@@2V_System_error_category@2@A ; this
.text$di:00002FA4                 call    ??0_System_error_category@std@@QAE@XZ ; std::_System_error_category::_System_error_category(void)
.text$di:00002FA9                 push    offset ??__F?_System_object@?$_Error_objects@H@std@@2V_System_error_category@2@A@@YAXXZ ; void (__cdecl *)()
.text$di:00002FAE                 call    _atexit
.text$di:00002FB3                 add     esp, 4
.text$di:00002FB6                 pop     ebp
.text$di:00002FB7                 retn
.text$di:00002FB7 ??__E?_System_object@?$_Error_objects@H@std@@2V_System_error_category@2@A@@YAXXZ endp
.text$di:00002FB7
.text$di:00002FB7 _text$di        ends
.text$di:00002FB7
.text$di:00002FB8 ; ===========================================================================
.text$di:00002FB8
.text$di:00002FB8 ; Segment type: Pure code
.text$di:00002FB8 ; Segment permissions: Read/Execute
.text$di:00002FB8 _text$di        segment para public 'CODE' use32
.text$di:00002FB8                 assume cs:_text$di
.text$di:00002FB8                 ;org 2FB8h
.text$di:00002FB8 ; COMDAT (pick any)
.text$di:00002FB8                 assume es:nothing, ss:nothing, ds:_data, fs:nothing, gs:nothing
.text$di:00002FB8
.text$di:00002FB8 ; =============== S U B R O U T I N E =======================================
.text$di:00002FB8
.text$di:00002FB8 ; Attributes: bp-based frame
.text$di:00002FB8
.text$di:00002FB8 ; void __cdecl `dynamic initializer for 'public: static class std::locale::id std::num_put<char, class std::back_insert_iterator<class std::basic_string<char, struct std::char_traits<char>, class std::allocator<char>>>>::id''(void)
.text$di:00002FB8 ??__E?id@?$num_put@DV?$back_insert_iterator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@std@@2V0locale@2@A@@YAXXZ proc near
.text$di:00002FB8                                         ; DATA XREF: .CRT$XCU:void (*std::num_put<char,std::back_insert_iterator<std::basic_string<char,std::char_traits<char>,std::allocator<char>>>>::id$initializer$)(void)o
.text$di:00002FB8                 push    ebp
.text$di:00002FB9                 mov     ebp, esp
.text$di:00002FBB                 push    0               ; unsigned int
.text$di:00002FBD                 mov     ecx, offset ?id@?$num_put@DV?$back_insert_iterator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@std@@2V0locale@2@A ; this
.text$di:00002FC2                 call    ??0id@locale@std@@QAE@I@Z ; std::locale::id::id(uint)
.text$di:00002FC7                 pop     ebp
.text$di:00002FC8                 retn
.text$di:00002FC8 ??__E?id@?$num_put@DV?$back_insert_iterator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@std@@2V0locale@2@A@@YAXXZ endp
.text$di:00002FC8
.text$di:00002FC8 ; ---------------------------------------------------------------------------
.text$di:00002FC9                 align 4
.text$di:00002FC9 _text$di        ends
.text$di:00002FC9
.text$di:00002FCC ; ===========================================================================
.text$di:00002FCC
.text$di:00002FCC ; Segment type: Pure code
.text$di:00002FCC ; Segment permissions: Read/Execute
.text$di:00002FCC _text$di        segment para public 'CODE' use32
.text$di:00002FCC                 assume cs:_text$di
.text$di:00002FCC                 ;org 2FCCh
.text$di:00002FCC ; COMDAT (pick any)
.text$di:00002FCC                 assume es:nothing, ss:nothing, ds:_data, fs:nothing, gs:nothing
.text$di:00002FCC
.text$di:00002FCC ; =============== S U B R O U T I N E =======================================
.text$di:00002FCC
.text$di:00002FCC ; Attributes: bp-based frame
.text$di:00002FCC
.text$di:00002FCC ; void __cdecl `dynamic initializer for 'public: static class std::locale::id std::num_put<wchar_t, class std::back_insert_iterator<class std::basic_string<wchar_t, struct std::char_traits<wchar_t>, class std::allocator<wchar_t>>>>::id''(void)
.text$di:00002FCC ??__E?id@?$num_put@_WV?$back_insert_iterator@V?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@@std@@@std@@2V0locale@2@A@@YAXXZ proc near
.text$di:00002FCC                                         ; DATA XREF: .CRT$XCU:void (*std::num_put<wchar_t,std::back_insert_iterator<std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>>>>::id$initializer$)(void)o
.text$di:00002FCC                 push    ebp
.text$di:00002FCD                 mov     ebp, esp
.text$di:00002FCF                 push    0               ; unsigned int
.text$di:00002FD1                 mov     ecx, offset ?id@?$num_put@_WV?$back_insert_iterator@V?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@@std@@@std@@2V0locale@2@A ; this
.text$di:00002FD6                 call    ??0id@locale@std@@QAE@I@Z ; std::locale::id::id(uint)
.text$di:00002FDB                 pop     ebp
.text$di:00002FDC                 retn
.text$di:00002FDC ??__E?id@?$num_put@_WV?$back_insert_iterator@V?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@@std@@@std@@2V0locale@2@A@@YAXXZ endp
.text$di:00002FDC
.text$di:00002FDC ; ---------------------------------------------------------------------------
.text$di:00002FDD                 align 10h
.text$di:00002FDD _text$di        ends
.text$di:00002FDD
.text$di:00002FE0 ; ===========================================================================
.text$di:00002FE0
.text$di:00002FE0 ; Segment type: Pure code
.text$di:00002FE0 ; Segment permissions: Read/Execute
.text$di:00002FE0 _text$di        segment para public 'CODE' use32
.text$di:00002FE0                 assume cs:_text$di
.text$di:00002FE0                 ;org 2FE0h
.text$di:00002FE0 ; COMDAT (pick any)
.text$di:00002FE0                 assume es:nothing, ss:nothing, ds:_data, fs:nothing, gs:nothing
.text$di:00002FE0
.text$di:00002FE0 ; =============== S U B R O U T I N E =======================================
.text$di:00002FE0
.text$di:00002FE0 ; Attributes: bp-based frame
.text$di:00002FE0
.text$di:00002FE0 ; void __cdecl `dynamic initializer for 'public: static class std::locale::id std::numpunct<char>::id''(void)
.text$di:00002FE0 ??__E?id@?$numpunct@D@std@@2V0locale@2@A@@YAXXZ proc near
.text$di:00002FE0                                         ; DATA XREF: .CRT$XCU:void (*std::numpunct<char>::id$initializer$)(void)o
.text$di:00002FE0                 push    ebp
.text$di:00002FE1                 mov     ebp, esp
.text$di:00002FE3                 push    0               ; unsigned int
.text$di:00002FE5                 mov     ecx, offset ?id@?$numpunct@D@std@@2V0locale@2@A ; this
.text$di:00002FEA                 call    ??0id@locale@std@@QAE@I@Z ; std::locale::id::id(uint)
.text$di:00002FEF                 pop     ebp
.text$di:00002FF0                 retn
.text$di:00002FF0 ??__E?id@?$numpunct@D@std@@2V0locale@2@A@@YAXXZ endp
.text$di:00002FF0
.text$di:00002FF0 ; ---------------------------------------------------------------------------
.text$di:00002FF1                 align 4
.text$di:00002FF1 _text$di        ends
.text$di:00002FF1
.text$di:00002FF4 ; ===========================================================================
.text$di:00002FF4
.text$di:00002FF4 ; Segment type: Pure code
.text$di:00002FF4 ; Segment permissions: Read/Execute
.text$di:00002FF4 _text$di        segment para public 'CODE' use32
.text$di:00002FF4                 assume cs:_text$di
.text$di:00002FF4                 ;org 2FF4h
.text$di:00002FF4 ; COMDAT (pick any)
.text$di:00002FF4                 assume es:nothing, ss:nothing, ds:_data, fs:nothing, gs:nothing
.text$di:00002FF4
.text$di:00002FF4 ; =============== S U B R O U T I N E =======================================
.text$di:00002FF4
.text$di:00002FF4 ; Attributes: bp-based frame
.text$di:00002FF4
.text$di:00002FF4 ; void __cdecl `dynamic initializer for 'public: static class std::locale::id std::numpunct<wchar_t>::id''(void)
.text$di:00002FF4 ??__E?id@?$numpunct@_W@std@@2V0locale@2@A@@YAXXZ proc near
.text$di:00002FF4                                         ; DATA XREF: .CRT$XCU:void (*std::numpunct<wchar_t>::id$initializer$)(void)o
.text$di:00002FF4                 push    ebp
.text$di:00002FF5                 mov     ebp, esp
.text$di:00002FF7                 push    0               ; unsigned int
.text$di:00002FF9                 mov     ecx, offset ?id@?$numpunct@_W@std@@2V0locale@2@A ; this
.text$di:00002FFE                 call    ??0id@locale@std@@QAE@I@Z ; std::locale::id::id(uint)
.text$di:00003003                 pop     ebp
.text$di:00003004                 retn
.text$di:00003004 ??__E?id@?$numpunct@_W@std@@2V0locale@2@A@@YAXXZ endp
.text$di:00003004
.text$di:00003004 ; ---------------------------------------------------------------------------
.text$di:00003005                 align 4
.text$di:00003005 _text$di        ends
.text$di:00003005
.text$di:00003008 ; ===========================================================================
.text$di:00003008
.text$di:00003008 ; Segment type: Pure code
.text$di:00003008 ; Segment permissions: Read/Execute
.text$di:00003008 _text$di        segment para public 'CODE' use32
.text$di:00003008                 assume cs:_text$di
.text$di:00003008                 ;org 3008h
.text$di:00003008 ; COMDAT (pick any)
.text$di:00003008                 assume es:nothing, ss:nothing, ds:_data, fs:nothing, gs:nothing
.text$di:00003008
.text$di:00003008 ; =============== S U B R O U T I N E =======================================
.text$di:00003008
.text$di:00003008 ; Attributes: bp-based frame
.text$di:00003008
.text$di:00003008 ; void __cdecl std::`dynamic initializer for '_Tuple_alloc''(void)
.text$di:00003008 ??__E_Tuple_alloc@std@@YAXXZ proc near  ; DATA XREF: .CRT$XCU:__Tuple_alloc$initializer$o
.text$di:00003008
.text$di:00003008 var_1           = byte ptr -1
.text$di:00003008
.text$di:00003008                 push    ebp
.text$di:00003009                 mov     ebp, esp
.text$di:0000300B                 push    ecx
.text$di:0000300C                 xor     eax, eax
.text$di:0000300E                 mov     [ebp+var_1], al
.text$di:00003011                 mov     esp, ebp
.text$di:00003013                 pop     ebp
.text$di:00003014                 retn
.text$di:00003014 ??__E_Tuple_alloc@std@@YAXXZ endp
.text$di:00003014
.text$di:00003014 ; ---------------------------------------------------------------------------
.text$di:00003015                 align 4
.text$di:00003015 _text$di        ends
.text$di:00003015
.text$di:00003018 ; ===========================================================================
.text$di:00003018
.text$di:00003018 ; Segment type: Pure code
.text$di:00003018 ; Segment permissions: Read/Execute
.text$di:00003018 _text$di        segment para public 'CODE' use32
.text$di:00003018                 assume cs:_text$di
.text$di:00003018                 ;org 3018h
.text$di:00003018 ; COMDAT (pick any)
.text$di:00003018                 assume es:nothing, ss:nothing, ds:_data, fs:nothing, gs:nothing
.text$di:00003018
.text$di:00003018 ; =============== S U B R O U T I N E =======================================
.text$di:00003018
.text$di:00003018 ; Attributes: bp-based frame
.text$di:00003018
.text$di:00003018 ; void __cdecl std::`dynamic initializer for 'allocator_arg''(void)
.text$di:00003018 ??__Eallocator_arg@std@@YAXXZ proc near ; DATA XREF: .CRT$XCU:_allocator_arg$initializer$o
.text$di:00003018
.text$di:00003018 var_1           = byte ptr -1
.text$di:00003018
.text$di:00003018                 push    ebp
.text$di:00003019                 mov     ebp, esp
.text$di:0000301B                 push    ecx
.text$di:0000301C                 xor     eax, eax
.text$di:0000301E                 mov     [ebp+var_1], al
.text$di:00003021                 mov     esp, ebp
.text$di:00003023                 pop     ebp
.text$di:00003024                 retn
.text$di:00003024 ??__Eallocator_arg@std@@YAXXZ endp
.text$di:00003024
.text$di:00003024 ; ---------------------------------------------------------------------------
.text$di:00003025                 align 4
.text$di:00003025 _text$di        ends
.text$di:00003025
.text$di:00003028 ; ===========================================================================
.text$di:00003028
.text$di:00003028 ; Segment type: Pure code
.text$di:00003028 ; Segment permissions: Read/Execute
.text$di:00003028 _text$di        segment para public 'CODE' use32
.text$di:00003028                 assume cs:_text$di
.text$di:00003028                 ;org 3028h
.text$di:00003028 ; COMDAT (pick any)
.text$di:00003028                 assume es:nothing, ss:nothing, ds:_data, fs:nothing, gs:nothing
.text$di:00003028
.text$di:00003028 ; =============== S U B R O U T I N E =======================================
.text$di:00003028
.text$di:00003028 ; Attributes: bp-based frame
.text$di:00003028
.text$di:00003028 ; void __cdecl std::`dynamic initializer for 'ignore''(void)
.text$di:00003028 ??__Eignore@std@@YAXXZ proc near        ; DATA XREF: .CRT$XCU:_ignore$initializer$o
.text$di:00003028                 push    ebp
.text$di:00003029                 mov     ebp, esp
.text$di:0000302B                 mov     ecx, offset _ignore ; this
.text$di:00003030                 call    ??0_Ignore@std@@QAE@XZ ; std::_Ignore::_Ignore(void)
.text$di:00003035                 pop     ebp
.text$di:00003036                 retn
.text$di:00003036 ??__Eignore@std@@YAXXZ endp
.text$di:00003036
.text$di:00003036 ; ---------------------------------------------------------------------------
.text$di:00003037                 align 4
.text$di:00003037 _text$di        ends
.text$di:00003037
.text$di:00003038 ; ===========================================================================
.text$di:00003038
.text$di:00003038 ; Segment type: Pure code
.text$di:00003038 ; Segment permissions: Read/Execute
.text$di:00003038 _text$di        segment para public 'CODE' use32
.text$di:00003038                 assume cs:_text$di
.text$di:00003038                 ;org 3038h
.text$di:00003038 ; COMDAT (pick any)
.text$di:00003038                 assume es:nothing, ss:nothing, ds:_data, fs:nothing, gs:nothing
.text$di:00003038
.text$di:00003038 ; =============== S U B R O U T I N E =======================================
.text$di:00003038
.text$di:00003038 ; Attributes: bp-based frame
.text$di:00003038
.text$di:00003038 ; void __cdecl std::`dynamic initializer for 'piecewise_construct''(void)
.text$di:00003038 ??__Epiecewise_construct@std@@YAXXZ proc near
.text$di:00003038                                         ; DATA XREF: .CRT$XCU:_piecewise_construct$initializer$o
.text$di:00003038
.text$di:00003038 var_1           = byte ptr -1
.text$di:00003038
.text$di:00003038                 push    ebp
.text$di:00003039                 mov     ebp, esp
.text$di:0000303B                 push    ecx
.text$di:0000303C                 xor     eax, eax
.text$di:0000303E                 mov     [ebp+var_1], al
.text$di:00003041                 mov     esp, ebp
.text$di:00003043                 pop     ebp
.text$di:00003044                 retn
.text$di:00003044 ??__Epiecewise_construct@std@@YAXXZ endp
.text$di:00003044
.text$di:00003044 ; ---------------------------------------------------------------------------
.text$di:00003045                 align 4
.text$di:00003045 _text$di        ends
.text$di:00003045
.text$yd:00003048 ; ===========================================================================
.text$yd:00003048
.text$yd:00003048 ; Segment type: Pure code
.text$yd:00003048 ; Segment permissions: Read/Execute
.text$yd:00003048 _text$yd        segment para public 'CODE' use32
.text$yd:00003048                 assume cs:_text$yd
.text$yd:00003048                 ;org 3048h
.text$yd:00003048 ; COMDAT (pick any)
.text$yd:00003048                 assume es:nothing, ss:nothing, ds:_data, fs:nothing, gs:nothing
.text$yd:00003048
.text$yd:00003048 ; =============== S U B R O U T I N E =======================================
.text$yd:00003048
.text$yd:00003048 ; Attributes: bp-based frame
.text$yd:00003048
.text$yd:00003048 ; void __cdecl `dynamic atexit destructor for 'public: static std::_Generic_error_category std::_Error_objects<int>::_Generic_object''()
.text$yd:00003048 ??__F?_Generic_object@?$_Error_objects@H@std@@2V_Generic_error_category@2@A@@YAXXZ proc near
.text$yd:00003048                                         ; DATA XREF: `dynamic initializer for 'std::_Generic_error_category std::_Error_objects<int>::_Generic_object''(void)+Do
.text$yd:00003048                 push    ebp
.text$yd:00003049                 mov     ebp, esp
.text$yd:0000304B                 mov     ecx, offset ?_Generic_object@?$_Error_objects@H@std@@2V_Generic_error_category@2@A ; this
.text$yd:00003050                 call    ??1_Generic_error_category@std@@UAE@XZ ; std::_Generic_error_category::~_Generic_error_category(void)
.text$yd:00003055                 pop     ebp
.text$yd:00003056                 retn
.text$yd:00003056 ??__F?_Generic_object@?$_Error_objects@H@std@@2V_Generic_error_category@2@A@@YAXXZ endp
.text$yd:00003056
.text$yd:00003056 ; ---------------------------------------------------------------------------
.text$yd:00003057                 align 4
.text$yd:00003057 _text$yd        ends
.text$yd:00003057
.text$yd:00003058 ; ===========================================================================
.text$yd:00003058
.text$yd:00003058 ; Segment type: Pure code
.text$yd:00003058 ; Segment permissions: Read/Execute
.text$yd:00003058 _text$yd        segment para public 'CODE' use32
.text$yd:00003058                 assume cs:_text$yd
.text$yd:00003058                 ;org 3058h
.text$yd:00003058 ; COMDAT (pick any)
.text$yd:00003058                 assume es:nothing, ss:nothing, ds:_data, fs:nothing, gs:nothing
.text$yd:00003058
.text$yd:00003058 ; =============== S U B R O U T I N E =======================================
.text$yd:00003058
.text$yd:00003058 ; Attributes: bp-based frame
.text$yd:00003058
.text$yd:00003058 ; void __cdecl `dynamic atexit destructor for 'public: static std::_Iostream_error_category std::_Error_objects<int>::_Iostream_object''()
.text$yd:00003058 ??__F?_Iostream_object@?$_Error_objects@H@std@@2V_Iostream_error_category@2@A@@YAXXZ proc near
.text$yd:00003058                                         ; DATA XREF: `dynamic initializer for 'std::_Iostream_error_category std::_Error_objects<int>::_Iostream_object''(void)+Do
.text$yd:00003058                 push    ebp
.text$yd:00003059                 mov     ebp, esp
.text$yd:0000305B                 mov     ecx, offset ?_Iostream_object@?$_Error_objects@H@std@@2V_Iostream_error_category@2@A ; this
.text$yd:00003060                 call    ??1_Iostream_error_category@std@@UAE@XZ ; std::_Iostream_error_category::~_Iostream_error_category(void)
.text$yd:00003065                 pop     ebp
.text$yd:00003066                 retn
.text$yd:00003066 ??__F?_Iostream_object@?$_Error_objects@H@std@@2V_Iostream_error_category@2@A@@YAXXZ endp
.text$yd:00003066
.text$yd:00003066 ; ---------------------------------------------------------------------------
.text$yd:00003067                 align 4
.text$yd:00003067 _text$yd        ends
.text$yd:00003067
.text$yd:00003068 ; ===========================================================================
.text$yd:00003068
.text$yd:00003068 ; Segment type: Pure code
.text$yd:00003068 ; Segment permissions: Read/Execute
.text$yd:00003068 _text$yd        segment para public 'CODE' use32
.text$yd:00003068                 assume cs:_text$yd
.text$yd:00003068                 ;org 3068h
.text$yd:00003068 ; COMDAT (pick any)
.text$yd:00003068                 assume es:nothing, ss:nothing, ds:_data, fs:nothing, gs:nothing
.text$yd:00003068
.text$yd:00003068 ; =============== S U B R O U T I N E =======================================
.text$yd:00003068
.text$yd:00003068 ; Attributes: bp-based frame
.text$yd:00003068
.text$yd:00003068 ; void __cdecl `dynamic atexit destructor for 'public: static std::_System_error_category std::_Error_objects<int>::_System_object''()
.text$yd:00003068 ??__F?_System_object@?$_Error_objects@H@std@@2V_System_error_category@2@A@@YAXXZ proc near
.text$yd:00003068                                         ; DATA XREF: `dynamic initializer for 'std::_System_error_category std::_Error_objects<int>::_System_object''(void)+Do
.text$yd:00003068                 push    ebp
.text$yd:00003069                 mov     ebp, esp
.text$yd:0000306B                 mov     ecx, offset ?_System_object@?$_Error_objects@H@std@@2V_System_error_category@2@A ; this
.text$yd:00003070                 call    ??1_System_error_category@std@@UAE@XZ ; std::_System_error_category::~_System_error_category(void)
.text$yd:00003075                 pop     ebp
.text$yd:00003076                 retn
.text$yd:00003076 ??__F?_System_object@?$_Error_objects@H@std@@2V_System_error_category@2@A@@YAXXZ endp
.text$yd:00003076
.text$yd:00003076 ; ---------------------------------------------------------------------------
.text$yd:00003077                 align 4
.text$yd:00003077 _text$yd        ends
.text$yd:00003077
.text$mn:00003078 ; ===========================================================================
.text$mn:00003078
.text$mn:00003078 ; Segment type: Pure code
.text$mn:00003078 ; Segment permissions: Read/Execute
.text$mn:00003078 _text$mn        segment para public 'CODE' use32
.text$mn:00003078                 assume cs:_text$mn
.text$mn:00003078                 ;org 3078h
.text$mn:00003078 ; COMDAT (pick any)
.text$mn:00003078                 assume es:nothing, ss:nothing, ds:_data, fs:nothing, gs:nothing
.text$mn:00003078
.text$mn:00003078 ; =============== S U B R O U T I N E =======================================
.text$mn:00003078
.text$mn:00003078 ; Attributes: bp-based frame
.text$mn:00003078
.text$mn:00003078 ; void __thiscall NppParameters::SetTransparent(NppParameters *this, HWND hWnd, int)
.text$mn:00003078                 public ?SetTransparent@NppParameters@@QAEXPAUHWND__@@H@Z
.text$mn:00003078 ?SetTransparent@NppParameters@@QAEXPAUHWND__@@H@Z proc near
.text$mn:00003078                                         ; CODE XREF: DocumentMap::run_dlgProc(uint,uint,long)+150p
.text$mn:00003078
.text$mn:00003078 var_4           = dword ptr -4
.text$mn:00003078 hWnd            = dword ptr  8
.text$mn:00003078 arg_4           = dword ptr  0Ch
.text$mn:00003078
.text$mn:00003078                 push    ebp
.text$mn:00003079                 mov     ebp, esp
.text$mn:0000307B                 push    ecx
.text$mn:0000307C                 mov     [ebp+var_4], ecx
.text$mn:0000307F                 mov     eax, [ebp+var_4]
.text$mn:00003082                 cmp     dword ptr [eax+1C8F8h], 0
.text$mn:00003089                 jnz     short loc_308D
.text$mn:0000308B                 jmp     short loc_30DF
.text$mn:0000308D ; ---------------------------------------------------------------------------
.text$mn:0000308D
.text$mn:0000308D loc_308D:                               ; CODE XREF: NppParameters::SetTransparent(HWND__ *,int)+11j
.text$mn:0000308D                 push    0FFFFFFECh      ; nIndex
.text$mn:0000308F                 mov     ecx, [ebp+hWnd]
.text$mn:00003092                 push    ecx             ; hWnd
.text$mn:00003093                 call    dword ptr ds:__imp__GetWindowLongW@8 ; GetWindowLongW(x,x)
.text$mn:00003099                 or      eax, 80000h
.text$mn:0000309E                 push    eax             ; dwNewLong
.text$mn:0000309F                 push    0FFFFFFECh      ; nIndex
.text$mn:000030A1                 mov     edx, [ebp+hWnd]
.text$mn:000030A4                 push    edx             ; hWnd
.text$mn:000030A5                 call    dword ptr ds:__imp__SetWindowLongW@12 ; SetWindowLongW(x,x,x)
.text$mn:000030AB                 cmp     [ebp+arg_4], 0FFh
.text$mn:000030B2                 jle     short loc_30BB
.text$mn:000030B4                 mov     [ebp+arg_4], 0FFh
.text$mn:000030BB
.text$mn:000030BB loc_30BB:                               ; CODE XREF: NppParameters::SetTransparent(HWND__ *,int)+3Aj
.text$mn:000030BB                 cmp     [ebp+arg_4], 0
.text$mn:000030BF                 jge     short loc_30C8
.text$mn:000030C1                 mov     [ebp+arg_4], 0
.text$mn:000030C8
.text$mn:000030C8 loc_30C8:                               ; CODE XREF: NppParameters::SetTransparent(HWND__ *,int)+47j
.text$mn:000030C8                 push    2
.text$mn:000030CA                 mov     eax, [ebp+arg_4]
.text$mn:000030CD                 push    eax
.text$mn:000030CE                 push    0
.text$mn:000030D0                 mov     ecx, [ebp+hWnd]
.text$mn:000030D3                 push    ecx
.text$mn:000030D4                 mov     edx, [ebp+var_4]
.text$mn:000030D7                 mov     eax, [edx+1C8F8h]
.text$mn:000030DD                 call    eax
.text$mn:000030DF
.text$mn:000030DF loc_30DF:                               ; CODE XREF: NppParameters::SetTransparent(HWND__ *,int)+13j
.text$mn:000030DF                 mov     esp, ebp
.text$mn:000030E1                 pop     ebp
.text$mn:000030E2                 retn    8
.text$mn:000030E2 ?SetTransparent@NppParameters@@QAEXPAUHWND__@@H@Z endp
.text$mn:000030E2
.text$mn:000030E2 ; ---------------------------------------------------------------------------
.text$mn:000030E5                 align 4
.text$mn:000030E5 _text$mn        ends
.text$mn:000030E5
.text$mn:000030E8 ; ===========================================================================
.text$mn:000030E8
.text$mn:000030E8 ; Segment type: Pure code
.text$mn:000030E8 ; Segment permissions: Read/Execute
.text$mn:000030E8 _text$mn        segment para public 'CODE' use32
.text$mn:000030E8                 assume cs:_text$mn
.text$mn:000030E8                 ;org 30E8h
.text$mn:000030E8 ; COMDAT (pick any)
.text$mn:000030E8                 assume es:nothing, ss:nothing, ds:_data, fs:nothing, gs:nothing
.text$mn:000030E8
.text$mn:000030E8 ; =============== S U B R O U T I N E =======================================
.text$mn:000030E8
.text$mn:000030E8 ; Attributes: bp-based frame
.text$mn:000030E8
.text$mn:000030E8 ; public: void __thiscall std::_String_alloc<0, struct std::_String_base_types<char, class std::allocator<char>>>::_Alloc_proxy(void)
.text$mn:000030E8                 public ?_Alloc_proxy@?$_String_alloc@$0A@U?$_String_base_types@DV?$allocator@D@std@@@std@@@std@@QAEXXZ
.text$mn:000030E8 ?_Alloc_proxy@?$_String_alloc@$0A@U?$_String_base_types@DV?$allocator@D@std@@@std@@@std@@QAEXXZ proc near
.text$mn:000030E8                                         ; CODE XREF: std::_String_alloc<0,std::_String_base_types<char,std::allocator<char>>>::_String_alloc<0,std::_String_base_types<char,std::allocator<char>>>(std::allocator<char> const &)+38p
.text$mn:000030E8
.text$mn:000030E8 var_10          = byte ptr -10h
.text$mn:000030E8 var_8           = dword ptr -8
.text$mn:000030E8 var_1           = byte ptr -1
.text$mn:000030E8
.text$mn:000030E8                 push    ebp
.text$mn:000030E9                 mov     ebp, esp
.text$mn:000030EB                 sub     esp, 10h
.text$mn:000030EE                 mov     [ebp+var_8], ecx
.text$mn:000030F1                 lea     ecx, [ebp+var_1]
.text$mn:000030F4                 call    ??0?$allocator@U_Container_proxy@std@@@std@@QAE@XZ ; std::allocator<std::_Container_proxy>::allocator<std::_Container_proxy>(void)
.text$mn:000030F9                 push    1
.text$mn:000030FB                 lea     ecx, [ebp+var_1]
.text$mn:000030FE                 call    ?allocate@?$allocator@U_Container_proxy@std@@@std@@QAEPAU_Container_proxy@2@I@Z ; std::allocator<std::_Container_proxy>::allocate(uint)
.text$mn:00003103                 mov     ecx, [ebp+var_8]
.text$mn:00003106                 mov     [ecx], eax
.text$mn:00003108                 lea     ecx, [ebp+var_10] ; this
.text$mn:0000310B                 call    ??0_Container_proxy@std@@QAE@XZ ; std::_Container_proxy::_Container_proxy(void)
.text$mn:00003110                 push    eax             ; int
.text$mn:00003111                 mov     edx, [ebp+var_8]
.text$mn:00003114                 mov     eax, [edx]
.text$mn:00003116                 push    eax             ; void *
.text$mn:00003117                 lea     ecx, [ebp+var_1]
.text$mn:0000311A                 call    ??$construct@U_Container_proxy@std@@U12@@?$allocator@U_Container_proxy@std@@@std@@QAEXPAU_Container_proxy@1@$$QAU21@@Z ; std::allocator<std::_Container_proxy>::construct<std::_Container_proxy,std::_Container_proxy>(std::_Container_proxy *,std::_Container_proxy &&)
.text$mn:0000311F                 mov     ecx, [ebp+var_8]
.text$mn:00003122                 mov     edx, [ecx]
.text$mn:00003124                 mov     eax, [ebp+var_8]
.text$mn:00003127                 mov     [edx], eax
.text$mn:00003129                 mov     esp, ebp
.text$mn:0000312B                 pop     ebp
.text$mn:0000312C                 retn
.text$mn:0000312C ?_Alloc_proxy@?$_String_alloc@$0A@U?$_String_base_types@DV?$allocator@D@std@@@std@@@std@@QAEXXZ endp
.text$mn:0000312C
.text$mn:0000312C ; ---------------------------------------------------------------------------
.text$mn:0000312D                 align 10h
.text$mn:0000312D _text$mn        ends
.text$mn:0000312D
.text$mn:00003130 ; ===========================================================================
.text$mn:00003130
.text$mn:00003130 ; Segment type: Pure code
.text$mn:00003130 ; Segment permissions: Read/Execute
.text$mn:00003130 _text$mn        segment para public 'CODE' use32
.text$mn:00003130                 assume cs:_text$mn
.text$mn:00003130                 ;org 3130h
.text$mn:00003130 ; COMDAT (pick any)
.text$mn:00003130                 assume es:nothing, ss:nothing, ds:_data, fs:nothing, gs:nothing
.text$mn:00003130
.text$mn:00003130 ; =============== S U B R O U T I N E =======================================
.text$mn:00003130
.text$mn:00003130 ; Attributes: bp-based frame
.text$mn:00003130
.text$mn:00003130 ; public: void __thiscall std::_Vector_alloc<0, struct std::_Vec_base_types<unsigned int, class std::allocator<unsigned int>>>::_Alloc_proxy(void)
.text$mn:00003130                 public ?_Alloc_proxy@?$_Vector_alloc@$0A@U?$_Vec_base_types@IV?$allocator@I@std@@@std@@@std@@QAEXXZ
.text$mn:00003130 ?_Alloc_proxy@?$_Vector_alloc@$0A@U?$_Vec_base_types@IV?$allocator@I@std@@@std@@@std@@QAEXXZ proc near
.text$mn:00003130                                         ; CODE XREF: std::_Vector_alloc<0,std::_Vec_base_types<uint,std::allocator<uint>>>::_Vector_alloc<0,std::_Vec_base_types<uint,std::allocator<uint>>>(std::allocator<uint> const &)+38p
.text$mn:00003130
.text$mn:00003130 var_10          = byte ptr -10h
.text$mn:00003130 var_8           = dword ptr -8
.text$mn:00003130 var_1           = byte ptr -1
.text$mn:00003130
.text$mn:00003130                 push    ebp
.text$mn:00003131                 mov     ebp, esp
.text$mn:00003133                 sub     esp, 10h
.text$mn:00003136                 mov     [ebp+var_8], ecx
.text$mn:00003139                 lea     ecx, [ebp+var_1]
.text$mn:0000313C                 call    ??0?$_Wrap_alloc@V?$allocator@U_Container_proxy@std@@@std@@@std@@QAE@XZ ; std::_Wrap_alloc<std::allocator<std::_Container_proxy>>::_Wrap_alloc<std::allocator<std::_Container_proxy>>(void)
.text$mn:00003141                 push    1
.text$mn:00003143                 lea     ecx, [ebp+var_1]
.text$mn:00003146                 call    ?allocate@?$_Wrap_alloc@V?$allocator@U_Container_proxy@std@@@std@@@std@@QAEPAU_Container_proxy@2@I@Z ; std::_Wrap_alloc<std::allocator<std::_Container_proxy>>::allocate(uint)
.text$mn:0000314B                 mov     ecx, [ebp+var_8]
.text$mn:0000314E                 mov     [ecx], eax
.text$mn:00003150                 lea     ecx, [ebp+var_10] ; this
.text$mn:00003153                 call    ??0_Container_proxy@std@@QAE@XZ ; std::_Container_proxy::_Container_proxy(void)
.text$mn:00003158                 push    eax             ; int
.text$mn:00003159                 mov     edx, [ebp+var_8]
.text$mn:0000315C                 mov     eax, [edx]
.text$mn:0000315E                 push    eax             ; void *
.text$mn:0000315F                 lea     ecx, [ebp+var_1]
.text$mn:00003162                 call    ??$construct@U_Container_proxy@std@@U12@@?$_Wrap_alloc@V?$allocator@U_Container_proxy@std@@@std@@@std@@QAEXPAU_Container_proxy@1@$$QAU21@@Z ; std::_Wrap_alloc<std::allocator<std::_Container_proxy>>::construct<std::_Container_proxy,std::_Container_proxy>(std::_Container_proxy *,std::_Container_proxy &&)
.text$mn:00003167                 mov     ecx, [ebp+var_8]
.text$mn:0000316A                 mov     edx, [ecx]
.text$mn:0000316C                 mov     eax, [ebp+var_8]
.text$mn:0000316F                 mov     [edx], eax
.text$mn:00003171                 mov     esp, ebp
.text$mn:00003173                 pop     ebp
.text$mn:00003174                 retn
.text$mn:00003174 ?_Alloc_proxy@?$_Vector_alloc@$0A@U?$_Vec_base_types@IV?$allocator@I@std@@@std@@@std@@QAEXXZ endp
.text$mn:00003174
.text$mn:00003174 ; ---------------------------------------------------------------------------
.text$mn:00003175                 align 4
.text$mn:00003175 _text$mn        ends
.text$mn:00003175
.text$mn:00003178 ; ===========================================================================
.text$mn:00003178
.text$mn:00003178 ; Segment type: Pure code
.text$mn:00003178 ; Segment permissions: Read/Execute
.text$mn:00003178 _text$mn        segment para public 'CODE' use32
.text$mn:00003178                 assume cs:_text$mn
.text$mn:00003178                 ;org 3178h
.text$mn:00003178 ; COMDAT (pick any)
.text$mn:00003178                 assume es:nothing, ss:nothing, ds:_data, fs:nothing, gs:nothing
.text$mn:00003178
.text$mn:00003178 ; =============== S U B R O U T I N E =======================================
.text$mn:00003178
.text$mn:00003178 ; Attributes: bp-based frame
.text$mn:00003178
.text$mn:00003178 ; public: void __thiscall std::basic_string<char, struct std::char_traits<char>, class std::allocator<char>>::_Copy(unsigned int, unsigned int)
.text$mn:00003178                 public ?_Copy@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEXII@Z
.text$mn:00003178 ?_Copy@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEXII@Z proc near
.text$mn:00003178                                         ; CODE XREF: std::basic_string<char,std::char_traits<char>,std::allocator<char>>::_Grow(uint,bool)+37p
.text$mn:00003178
.text$mn:00003178 var_20          = dword ptr -20h
.text$mn:00003178 var_1C          = dword ptr -1Ch
.text$mn:00003178 var_18          = dword ptr -18h
.text$mn:00003178 var_11          = byte ptr -11h
.text$mn:00003178 var_10          = dword ptr -10h
.text$mn:00003178 var_C           = byte ptr -0Ch
.text$mn:00003178 var_4           = dword ptr -4
.text$mn:00003178 arg_0           = dword ptr  8
.text$mn:00003178
.text$mn:00003178 ; FUNCTION CHUNK AT .text$mn:0000329A SIZE 00000009 BYTES
.text$mn:00003178
.text$mn:00003178                 push    ebp
.text$mn:00003179                 mov     ebp, esp
.text$mn:0000317B                 push    0FFFFFFFFh
.text$mn:0000317D                 push    offset __ehhandler$?_Copy@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEXII@Z
.text$mn:00003182                 mov     eax, large fs:0
.text$mn:00003188                 push    eax
.text$mn:00003189                 push    ecx
.text$mn:0000318A                 sub     esp, 10h
.text$mn:0000318D                 push    ebx
.text$mn:0000318E                 push    esi
.text$mn:0000318F                 push    edi
.text$mn:00003190                 mov     eax, dword ptr ds:___security_cookie
.text$mn:00003195                 xor     eax, ebp
.text$mn:00003197                 push    eax
.text$mn:00003198                 lea     eax, [ebp+var_C]
.text$mn:0000319B                 mov     large fs:0, eax
.text$mn:000031A1                 mov     [ebp+var_10], esp
.text$mn:000031A4                 mov     [ebp+var_18], ecx
.text$mn:000031A7                 mov     eax, [ebp+arg_0]
.text$mn:000031AA                 or      eax, 0Fh
.text$mn:000031AD                 mov     [ebp+var_1C], eax
.text$mn:000031B0                 mov     ecx, [ebp+var_18]
.text$mn:000031B3                 call    ?max_size@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QBEIXZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char>>::max_size(void)
.text$mn:000031B8                 cmp     eax, [ebp+var_1C]
.text$mn:000031BB                 jnb     short loc_31C5
.text$mn:000031BD                 mov     ecx, [ebp+arg_0]
.text$mn:000031C0                 mov     [ebp+var_1C], ecx
.text$mn:000031C3                 jmp     short loc_3217
.text$mn:000031C5 ; ---------------------------------------------------------------------------
.text$mn:000031C5
.text$mn:000031C5 loc_31C5:                               ; CODE XREF: std::basic_string<char,std::char_traits<char>,std::allocator<char>>::_Copy(uint,uint)+43j
.text$mn:000031C5                 mov     edx, [ebp+var_18]
.text$mn:000031C8                 mov     ecx, [edx+18h]
.text$mn:000031CB                 shr     ecx, 1
.text$mn:000031CD                 mov     eax, [ebp+var_1C]
.text$mn:000031D0                 xor     edx, edx
.text$mn:000031D2                 mov     esi, 3
.text$mn:000031D7                 div     esi
.text$mn:000031D9                 cmp     ecx, eax
.text$mn:000031DB                 ja      short loc_31DF
.text$mn:000031DD                 jmp     short loc_3217
.text$mn:000031DF ; ---------------------------------------------------------------------------
.text$mn:000031DF
.text$mn:000031DF loc_31DF:                               ; CODE XREF: std::basic_string<char,std::char_traits<char>,std::allocator<char>>::_Copy(uint,uint)+63j
.text$mn:000031DF                 mov     ecx, [ebp+var_18]
.text$mn:000031E2                 call    ?max_size@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QBEIXZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char>>::max_size(void)
.text$mn:000031E7                 mov     edx, [ebp+var_18]
.text$mn:000031EA                 mov     ecx, [edx+18h]
.text$mn:000031ED                 shr     ecx, 1
.text$mn:000031EF                 sub     eax, ecx
.text$mn:000031F1                 mov     edx, [ebp+var_18]
.text$mn:000031F4                 cmp     [edx+18h], eax
.text$mn:000031F7                 ja      short loc_320C
.text$mn:000031F9                 mov     eax, [ebp+var_18]
.text$mn:000031FC                 mov     ecx, [eax+18h]
.text$mn:000031FF                 shr     ecx, 1
.text$mn:00003201                 mov     edx, [ebp+var_18]
.text$mn:00003204                 add     ecx, [edx+18h]
.text$mn:00003207                 mov     [ebp+var_1C], ecx
.text$mn:0000320A                 jmp     short loc_3217
.text$mn:0000320C ; ---------------------------------------------------------------------------
.text$mn:0000320C
.text$mn:0000320C loc_320C:                               ; CODE XREF: std::basic_string<char,std::char_traits<char>,std::allocator<char>>::_Copy(uint,uint)+7Fj
.text$mn:0000320C                 mov     ecx, [ebp+var_18]
.text$mn:0000320F                 call    ?max_size@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QBEIXZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char>>::max_size(void)
.text$mn:00003214                 mov     [ebp+var_1C], eax
.text$mn:00003217
.text$mn:00003217 loc_3217:                               ; CODE XREF: std::basic_string<char,std::char_traits<char>,std::allocator<char>>::_Copy(uint,uint)+4Bj
.text$mn:00003217                                         ; std::basic_string<char,std::char_traits<char>,std::allocator<char>>::_Copy(uint,uint)+65j ...
.text$mn:00003217                 mov     [ebp+var_4], 0
.text$mn:0000321E                 mov     eax, [ebp+var_1C]
.text$mn:00003221                 add     eax, 1
.text$mn:00003224                 push    eax
.text$mn:00003225                 lea     ecx, [ebp+var_11]
.text$mn:00003228                 push    ecx
.text$mn:00003229                 mov     ecx, [ebp+var_18]
.text$mn:0000322C                 call    ?_Getal@?$_String_alloc@$0A@U?$_String_base_types@DV?$allocator@D@std@@@std@@@std@@QBE?AU?$_Wrap_alloc@V?$allocator@D@std@@@2@XZ ; std::_String_alloc<0,std::_String_base_types<char,std::allocator<char>>>::_Getal(void)
.text$mn:00003231                 mov     ecx, eax
.text$mn:00003233                 call    ?allocate@?$_Wrap_alloc@V?$allocator@D@std@@@std@@QAEPADI@Z ; std::_Wrap_alloc<std::allocator<char>>::allocate(uint)
.text$mn:00003238                 mov     [ebp+var_20], eax
.text$mn:0000323B                 jmp     short loc_329A
.text$mn:0000323B ?_Copy@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEXII@Z endp
.text$mn:0000323B
.text$mn:0000323D
.text$mn:0000323D ; =============== S U B R O U T I N E =======================================
.text$mn:0000323D
.text$mn:0000323D
.text$mn:0000323D __catch$?_Copy@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEXII@Z$0 proc near
.text$mn:0000323D                                         ; DATA XREF: .xdata$x:00004450o
.text$mn:0000323D
.text$mn:0000323D ; FUNCTION CHUNK AT .text$mn:00003284 SIZE 00000009 BYTES
.text$mn:0000323D ; FUNCTION CHUNK AT .text$mn:00003294 SIZE 00000006 BYTES
.text$mn:0000323D
.text$mn:0000323D                 mov     [ebp-10h], esp
.text$mn:00003240                 mov     edx, [ebp+8]
.text$mn:00003243                 mov     [ebp-1Ch], edx
.text$mn:00003246                 mov     byte ptr [ebp-4], 2
.text$mn:0000324A                 mov     eax, [ebp-1Ch]
.text$mn:0000324D                 add     eax, 1
.text$mn:00003250                 push    eax
.text$mn:00003251                 lea     ecx, [ebp-12h]
.text$mn:00003254                 push    ecx
.text$mn:00003255                 mov     ecx, [ebp-18h]
.text$mn:00003258                 call    ?_Getal@?$_String_alloc@$0A@U?$_String_base_types@DV?$allocator@D@std@@@std@@@std@@QBE?AU?$_Wrap_alloc@V?$allocator@D@std@@@2@XZ ; std::_String_alloc<0,std::_String_base_types<char,std::allocator<char>>>::_Getal(void)
.text$mn:0000325D                 mov     ecx, eax
.text$mn:0000325F                 call    ?allocate@?$_Wrap_alloc@V?$allocator@D@std@@@std@@QAEPADI@Z ; std::_Wrap_alloc<std::allocator<char>>::allocate(uint)
.text$mn:00003264                 mov     [ebp-20h], eax
.text$mn:00003267                 jmp     short loc_3284
.text$mn:00003267 __catch$?_Copy@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEXII@Z$0 endp
.text$mn:00003267
.text$mn:00003269
.text$mn:00003269 ; =============== S U B R O U T I N E =======================================
.text$mn:00003269
.text$mn:00003269 ; Attributes: noreturn
.text$mn:00003269
.text$mn:00003269 __catch$?_Copy@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEXII@Z$1 proc near
.text$mn:00003269                                         ; DATA XREF: .xdata$x:00004460o
.text$mn:00003269                 push    0               ; Size
.text$mn:0000326B                 push    1               ; char
.text$mn:0000326D                 mov     ecx, [ebp-18h]
.text$mn:00003270                 call    ?_Tidy@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEX_NI@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char>>::_Tidy(bool,uint)
.text$mn:00003275                 push    0
.text$mn:00003277                 push    0
.text$mn:00003279                 call    __CxxThrowException@8 ; _CxxThrowException(x,x)
.text$mn:00003279 __catch$?_Copy@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEXII@Z$1 endp
.text$mn:00003279
.text$mn:0000327E ; ---------------------------------------------------------------------------
.text$mn:0000327E                 mov     eax, offset $LN17
.text$mn:00003283                 retn
.text$mn:00003284 ; ---------------------------------------------------------------------------
.text$mn:00003284 ; START OF FUNCTION CHUNK FOR __catch$?_Copy@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEXII@Z$0
.text$mn:00003284
.text$mn:00003284 loc_3284:                               ; CODE XREF: __catch$?_Copy@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEXII@Z$0+2Aj
.text$mn:00003284                 mov     dword ptr [ebp-4], 1
.text$mn:0000328B                 jmp     short loc_3294
.text$mn:0000328B ; END OF FUNCTION CHUNK FOR __catch$?_Copy@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEXII@Z$0
.text$mn:0000328D
.text$mn:0000328D ; =============== S U B R O U T I N E =======================================
.text$mn:0000328D
.text$mn:0000328D
.text$mn:0000328D $LN17           proc near               ; DATA XREF: .text$mn:0000327Eo
.text$mn:0000328D                 mov     dword ptr [ebp-4], 1
.text$mn:0000328D $LN17           endp ; sp-analysis failed
.text$mn:0000328D
.text$mn:00003294 ; START OF FUNCTION CHUNK FOR __catch$?_Copy@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEXII@Z$0
.text$mn:00003294
.text$mn:00003294 loc_3294:                               ; CODE XREF: __catch$?_Copy@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEXII@Z$0+4Ej
.text$mn:00003294                 mov     eax, offset $LN19
.text$mn:00003299                 retn
.text$mn:00003299 ; END OF FUNCTION CHUNK FOR __catch$?_Copy@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEXII@Z$0
.text$mn:0000329A ; ---------------------------------------------------------------------------
.text$mn:0000329A ; START OF FUNCTION CHUNK FOR ?_Copy@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEXII@Z
.text$mn:0000329A
.text$mn:0000329A loc_329A:                               ; CODE XREF: std::basic_string<char,std::char_traits<char>,std::allocator<char>>::_Copy(uint,uint)+C3j
.text$mn:0000329A                 mov     [ebp+var_4], 0FFFFFFFFh
.text$mn:000032A1                 jmp     short loc_32AA
.text$mn:000032A1 ; END OF FUNCTION CHUNK FOR ?_Copy@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEXII@Z
.text$mn:000032A3
.text$mn:000032A3 ; =============== S U B R O U T I N E =======================================
.text$mn:000032A3
.text$mn:000032A3
.text$mn:000032A3 $LN19           proc near               ; DATA XREF: __catch$?_Copy@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEXII@Z$0:loc_3294o
.text$mn:000032A3                 mov     dword ptr [ebp-4], 0FFFFFFFFh
.text$mn:000032AA
.text$mn:000032AA loc_32AA:                               ; CODE XREF: std::basic_string<char,std::char_traits<char>,std::allocator<char>>::_Copy(uint,uint)+129j
.text$mn:000032AA                 cmp     dword ptr [ebp+0Ch], 0
.text$mn:000032AE                 jbe     short loc_32C9
.text$mn:000032B0                 mov     edx, [ebp+0Ch]
.text$mn:000032B3                 push    edx             ; Size
.text$mn:000032B4                 mov     ecx, [ebp-18h]
.text$mn:000032B7                 call    ?_Myptr@?$_String_val@U?$_Simple_types@D@std@@@std@@QAEPADXZ ; std::_String_val<std::_Simple_types<char>>::_Myptr(void)
.text$mn:000032BC                 push    eax             ; Src
.text$mn:000032BD                 mov     eax, [ebp-20h]
.text$mn:000032C0                 push    eax             ; Dst
.text$mn:000032C1                 call    ?copy@?$char_traits@D@std@@SAPADPADPBDI@Z ; std::char_traits<char>::copy(char *,char const *,uint)
.text$mn:000032C6                 add     esp, 0Ch
.text$mn:000032C9
.text$mn:000032C9 loc_32C9:                               ; CODE XREF: $LN19+Bj
.text$mn:000032C9                 push    0               ; Size
.text$mn:000032CB                 push    1               ; char
.text$mn:000032CD                 mov     ecx, [ebp-18h]
.text$mn:000032D0                 call    ?_Tidy@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEX_NI@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char>>::_Tidy(bool,uint)
.text$mn:000032D5                 lea     ecx, [ebp-20h]
.text$mn:000032D8                 push    ecx             ; int
.text$mn:000032D9                 mov     edx, [ebp-18h]
.text$mn:000032DC                 add     edx, 4
.text$mn:000032DF                 push    edx             ; void *
.text$mn:000032E0                 lea     eax, [ebp-13h]
.text$mn:000032E3                 push    eax
.text$mn:000032E4                 mov     ecx, [ebp-18h]
.text$mn:000032E7                 call    ?_Getal@?$_String_alloc@$0A@U?$_String_base_types@DV?$allocator@D@std@@@std@@@std@@QBE?AU?$_Wrap_alloc@V?$allocator@D@std@@@2@XZ ; std::_String_alloc<0,std::_String_base_types<char,std::allocator<char>>>::_Getal(void)
.text$mn:000032EC                 mov     ecx, eax
.text$mn:000032EE                 call    ??$construct@PADAAPAD@?$_Wrap_alloc@V?$allocator@D@std@@@std@@QAEXPAPADAAPAD@Z ; std::_Wrap_alloc<std::allocator<char>>::construct<char *,char * &>(char * *,char * &)
.text$mn:000032F3                 mov     ecx, [ebp-18h]
.text$mn:000032F6                 mov     edx, [ebp-1Ch]
.text$mn:000032F9                 mov     [ecx+18h], edx
.text$mn:000032FC                 mov     eax, [ebp+0Ch]
.text$mn:000032FF                 push    eax
.text$mn:00003300                 mov     ecx, [ebp-18h]
.text$mn:00003303                 call    ?_Eos@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEXI@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char>>::_Eos(uint)
.text$mn:00003308                 mov     ecx, [ebp-0Ch]
.text$mn:0000330B                 mov     large fs:0, ecx
.text$mn:00003312                 pop     ecx
.text$mn:00003313                 pop     edi
.text$mn:00003314                 pop     esi
.text$mn:00003315                 pop     ebx
.text$mn:00003316                 mov     esp, ebp
.text$mn:00003318                 pop     ebp
.text$mn:00003319                 retn    8
.text$mn:00003319 $LN19           endp ; sp-analysis failed
.text$mn:00003319
.text$mn:00003319 _text$mn        ends
.text$mn:00003319
.text$x:0000331C ; ===========================================================================
.text$x:0000331C
.text$x:0000331C ; Segment type: Pure code
.text$x:0000331C ; Segment permissions: Read/Execute
.text$x:0000331C _text$x         segment para public 'CODE' use32
.text$x:0000331C                 assume cs:_text$x
.text$x:0000331C                 ;org 331Ch
.text$x:0000331C ; COMDAT (pick associative to section at 3178)
.text$x:0000331C                 assume es:nothing, ss:nothing, ds:_data, fs:nothing, gs:nothing
.text$x:0000331C
.text$x:0000331C ; =============== S U B R O U T I N E =======================================
.text$x:0000331C
.text$x:0000331C
.text$x:0000331C __ehhandler$?_Copy@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEXII@Z proc near
.text$x:0000331C                                         ; DATA XREF: std::basic_string<char,std::char_traits<char>,std::allocator<char>>::_Copy(uint,uint)+5o
.text$x:0000331C
.text$x:0000331C arg_4           = dword ptr  8
.text$x:0000331C
.text$x:0000331C                 mov     edx, [esp+arg_4]
.text$x:00003320                 lea     eax, [edx+0Ch]
.text$x:00003323                 mov     ecx, [edx-24h]
.text$x:00003326                 xor     ecx, eax
.text$x:00003328                 call    @__security_check_cookie@4 ; __security_check_cookie(x)
.text$x:0000332D                 mov     eax, offset __ehfuncinfo$?_Copy@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEXII@Z
.text$x:00003332                 jmp     ___CxxFrameHandler3
.text$x:00003332 __ehhandler$?_Copy@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEXII@Z endp
.text$x:00003332
.text$x:00003332 ; ---------------------------------------------------------------------------
.text$x:00003337                 align 4
.text$x:00003337 _text$x         ends
.text$x:00003337
.text$mn:00003338 ; ===========================================================================
.text$mn:00003338
.text$mn:00003338 ; Segment type: Pure code
.text$mn:00003338 ; Segment permissions: Read/Execute
.text$mn:00003338 _text$mn        segment para public 'CODE' use32
.text$mn:00003338                 assume cs:_text$mn
.text$mn:00003338                 ;org 3338h
.text$mn:00003338 ; COMDAT (pick any)
.text$mn:00003338                 assume es:nothing, ss:nothing, ds:_data, fs:nothing, gs:nothing
.text$mn:00003338
.text$mn:00003338 ; =============== S U B R O U T I N E =======================================
.text$mn:00003338
.text$mn:00003338 ; Attributes: bp-based frame
.text$mn:00003338
.text$mn:00003338 ; protected: void __thiscall std::vector<unsigned int, class std::allocator<unsigned int>>::_Destroy(unsigned int *, unsigned int *)
.text$mn:00003338                 public ?_Destroy@?$vector@IV?$allocator@I@std@@@std@@IAEXPAI0@Z
.text$mn:00003338 ?_Destroy@?$vector@IV?$allocator@I@std@@@std@@IAEXPAI0@Z proc near
.text$mn:00003338                                         ; CODE XREF: std::vector<uint,std::allocator<uint>>::_Tidy(void)+2Bp
.text$mn:00003338
.text$mn:00003338 var_8           = dword ptr -8
.text$mn:00003338 var_1           = byte ptr -1
.text$mn:00003338 arg_0           = dword ptr  8
.text$mn:00003338 arg_4           = dword ptr  0Ch
.text$mn:00003338
.text$mn:00003338                 push    ebp
.text$mn:00003339                 mov     ebp, esp
.text$mn:0000333B                 sub     esp, 8
.text$mn:0000333E                 mov     [ebp+var_8], ecx
.text$mn:00003341                 lea     eax, [ebp+var_1]
.text$mn:00003344                 push    eax
.text$mn:00003345                 mov     ecx, [ebp+var_8]
.text$mn:00003348                 call    ?_Getal@?$_Vector_alloc@$0A@U?$_Vec_base_types@IV?$allocator@I@std@@@std@@@std@@QBE?AU?$_Wrap_alloc@V?$allocator@I@std@@@2@XZ ; std::_Vector_alloc<0,std::_Vec_base_types<uint,std::allocator<uint>>>::_Getal(void)
.text$mn:0000334D                 lea     ecx, [ebp+var_1]
.text$mn:00003350                 push    ecx
.text$mn:00003351                 mov     edx, [ebp+arg_4]
.text$mn:00003354                 push    edx
.text$mn:00003355                 mov     eax, [ebp+arg_0]
.text$mn:00003358                 push    eax
.text$mn:00003359                 call    ??$_Destroy_range@U?$_Wrap_alloc@V?$allocator@I@std@@@std@@@std@@YAXPAI0AAU?$_Wrap_alloc@V?$allocator@I@std@@@0@@Z ; std::_Destroy_range<std::_Wrap_alloc<std::allocator<uint>>>(uint *,uint *,std::_Wrap_alloc<std::allocator<uint>> &)
.text$mn:0000335E                 add     esp, 0Ch
.text$mn:00003361                 mov     esp, ebp
.text$mn:00003363                 pop     ebp
.text$mn:00003364                 retn    8
.text$mn:00003364 ?_Destroy@?$vector@IV?$allocator@I@std@@@std@@IAEXPAI0@Z endp
.text$mn:00003364
.text$mn:00003364 ; ---------------------------------------------------------------------------
.text$mn:00003367                 align 4
.text$mn:00003367 _text$mn        ends
.text$mn:00003367
.text$mn:00003368 ; ===========================================================================
.text$mn:00003368
.text$mn:00003368 ; Segment type: Pure code
.text$mn:00003368 ; Segment permissions: Read/Execute
.text$mn:00003368 _text$mn        segment para public 'CODE' use32
.text$mn:00003368                 assume cs:_text$mn
.text$mn:00003368                 ;org 3368h
.text$mn:00003368 ; COMDAT (pick any)
.text$mn:00003368                 assume es:nothing, ss:nothing, ds:_data, fs:nothing, gs:nothing
.text$mn:00003368
.text$mn:00003368 ; =============== S U B R O U T I N E =======================================
.text$mn:00003368
.text$mn:00003368 ; Attributes: bp-based frame
.text$mn:00003368
.text$mn:00003368 ; public: void __thiscall std::basic_string<char, struct std::char_traits<char>, class std::allocator<char>>::_Eos(unsigned int)
.text$mn:00003368                 public ?_Eos@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEXI@Z
.text$mn:00003368 ?_Eos@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEXI@Z proc near
.text$mn:00003368                                         ; CODE XREF: $LN19+60p
.text$mn:00003368                                         ; std::basic_string<char,std::char_traits<char>,std::allocator<char>>::_Grow(uint,bool)+83p ...
.text$mn:00003368
.text$mn:00003368 var_8           = dword ptr -8
.text$mn:00003368 var_1           = byte ptr -1
.text$mn:00003368 arg_0           = dword ptr  8
.text$mn:00003368
.text$mn:00003368                 push    ebp
.text$mn:00003369                 mov     ebp, esp
.text$mn:0000336B                 sub     esp, 8
.text$mn:0000336E                 mov     [ebp+var_8], ecx
.text$mn:00003371                 mov     [ebp+var_1], 0
.text$mn:00003375                 mov     eax, [ebp+var_8]
.text$mn:00003378                 mov     ecx, [ebp+arg_0]
.text$mn:0000337B                 mov     [eax+14h], ecx
.text$mn:0000337E                 lea     edx, [ebp+var_1]
.text$mn:00003381                 push    edx
.text$mn:00003382                 mov     ecx, [ebp+var_8]
.text$mn:00003385                 call    ?_Myptr@?$_String_val@U?$_Simple_types@D@std@@@std@@QAEPADXZ ; std::_String_val<std::_Simple_types<char>>::_Myptr(void)
.text$mn:0000338A                 add     eax, [ebp+arg_0]
.text$mn:0000338D                 push    eax
.text$mn:0000338E                 call    ?assign@?$char_traits@D@std@@SAXAADABD@Z ; std::char_traits<char>::assign(char &,char const &)
.text$mn:00003393                 add     esp, 8
.text$mn:00003396                 mov     esp, ebp
.text$mn:00003398                 pop     ebp
.text$mn:00003399                 retn    4
.text$mn:00003399 ?_Eos@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEXI@Z endp
.text$mn:00003399
.text$mn:00003399 _text$mn        ends
.text$mn:00003399
.text$mn:0000339C ; ===========================================================================
.text$mn:0000339C
.text$mn:0000339C ; Segment type: Pure code
.text$mn:0000339C ; Segment permissions: Read/Execute
.text$mn:0000339C _text$mn        segment para public 'CODE' use32
.text$mn:0000339C                 assume cs:_text$mn
.text$mn:0000339C                 ;org 339Ch
.text$mn:0000339C ; COMDAT (pick any)
.text$mn:0000339C                 assume es:nothing, ss:nothing, ds:_data, fs:nothing, gs:nothing
.text$mn:0000339C
.text$mn:0000339C ; =============== S U B R O U T I N E =======================================
.text$mn:0000339C
.text$mn:0000339C ; Attributes: bp-based frame
.text$mn:0000339C
.text$mn:0000339C ; public: void __thiscall std::_String_alloc<0, struct std::_String_base_types<char, class std::allocator<char>>>::_Free_proxy(void)
.text$mn:0000339C                 public ?_Free_proxy@?$_String_alloc@$0A@U?$_String_base_types@DV?$allocator@D@std@@@std@@@std@@QAEXXZ
.text$mn:0000339C ?_Free_proxy@?$_String_alloc@$0A@U?$_String_base_types@DV?$allocator@D@std@@@std@@@std@@QAEXXZ proc near
.text$mn:0000339C                                         ; CODE XREF: std::_String_alloc<0,std::_String_base_types<char,std::allocator<char>>>::~_String_alloc<0,std::_String_base_types<char,std::allocator<char>>>(void)+30p
.text$mn:0000339C
.text$mn:0000339C var_8           = dword ptr -8
.text$mn:0000339C var_1           = byte ptr -1
.text$mn:0000339C
.text$mn:0000339C                 push    ebp
.text$mn:0000339D                 mov     ebp, esp
.text$mn:0000339F                 sub     esp, 8
.text$mn:000033A2                 mov     [ebp+var_8], ecx
.text$mn:000033A5                 lea     ecx, [ebp+var_1]
.text$mn:000033A8                 call    ??0?$allocator@U_Container_proxy@std@@@std@@QAE@XZ ; std::allocator<std::_Container_proxy>::allocator<std::_Container_proxy>(void)
.text$mn:000033AD                 mov     ecx, [ebp+var_8] ; this
.text$mn:000033B0                 call    ?_Orphan_all@_Container_base12@std@@QAEXXZ ; std::_Container_base12::_Orphan_all(void)
.text$mn:000033B5                 mov     eax, [ebp+var_8]
.text$mn:000033B8                 mov     ecx, [eax]
.text$mn:000033BA                 push    ecx
.text$mn:000033BB                 lea     ecx, [ebp+var_1]
.text$mn:000033BE                 call    ??$destroy@U_Container_proxy@std@@@?$allocator@U_Container_proxy@std@@@std@@QAEXPAU_Container_proxy@1@@Z ; std::allocator<std::_Container_proxy>::destroy<std::_Container_proxy>(std::_Container_proxy *)
.text$mn:000033C3                 push    1               ; int
.text$mn:000033C5                 mov     edx, [ebp+var_8]
.text$mn:000033C8                 mov     eax, [edx]
.text$mn:000033CA                 push    eax             ; void *
.text$mn:000033CB                 lea     ecx, [ebp+var_1]
.text$mn:000033CE                 call    ?deallocate@?$allocator@U_Container_proxy@std@@@std@@QAEXPAU_Container_proxy@2@I@Z ; std::allocator<std::_Container_proxy>::deallocate(std::_Container_proxy *,uint)
.text$mn:000033D3                 mov     ecx, [ebp+var_8]
.text$mn:000033D6                 mov     dword ptr [ecx], 0
.text$mn:000033DC                 mov     esp, ebp
.text$mn:000033DE                 pop     ebp
.text$mn:000033DF                 retn
.text$mn:000033DF ?_Free_proxy@?$_String_alloc@$0A@U?$_String_base_types@DV?$allocator@D@std@@@std@@@std@@QAEXXZ endp
.text$mn:000033DF
.text$mn:000033DF _text$mn        ends
.text$mn:000033DF
.text$mn:000033E0 ; ===========================================================================
.text$mn:000033E0
.text$mn:000033E0 ; Segment type: Pure code
.text$mn:000033E0 ; Segment permissions: Read/Execute
.text$mn:000033E0 _text$mn        segment para public 'CODE' use32
.text$mn:000033E0                 assume cs:_text$mn
.text$mn:000033E0                 ;org 33E0h
.text$mn:000033E0 ; COMDAT (pick any)
.text$mn:000033E0                 assume es:nothing, ss:nothing, ds:_data, fs:nothing, gs:nothing
.text$mn:000033E0
.text$mn:000033E0 ; =============== S U B R O U T I N E =======================================
.text$mn:000033E0
.text$mn:000033E0 ; Attributes: bp-based frame
.text$mn:000033E0
.text$mn:000033E0 ; public: void __thiscall std::_Vector_alloc<0, struct std::_Vec_base_types<unsigned int, class std::allocator<unsigned int>>>::_Free_proxy(void)
.text$mn:000033E0                 public ?_Free_proxy@?$_Vector_alloc@$0A@U?$_Vec_base_types@IV?$allocator@I@std@@@std@@@std@@QAEXXZ
.text$mn:000033E0 ?_Free_proxy@?$_Vector_alloc@$0A@U?$_Vec_base_types@IV?$allocator@I@std@@@std@@@std@@QAEXXZ proc near
.text$mn:000033E0                                         ; CODE XREF: std::_Vector_alloc<0,std::_Vec_base_types<uint,std::allocator<uint>>>::~_Vector_alloc<0,std::_Vec_base_types<uint,std::allocator<uint>>>(void)+30p
.text$mn:000033E0
.text$mn:000033E0 var_8           = dword ptr -8
.text$mn:000033E0 var_1           = byte ptr -1
.text$mn:000033E0
.text$mn:000033E0                 push    ebp
.text$mn:000033E1                 mov     ebp, esp
.text$mn:000033E3                 sub     esp, 8
.text$mn:000033E6                 mov     [ebp+var_8], ecx
.text$mn:000033E9                 lea     ecx, [ebp+var_1]
.text$mn:000033EC                 call    ??0?$_Wrap_alloc@V?$allocator@U_Container_proxy@std@@@std@@@std@@QAE@XZ ; std::_Wrap_alloc<std::allocator<std::_Container_proxy>>::_Wrap_alloc<std::allocator<std::_Container_proxy>>(void)
.text$mn:000033F1                 mov     ecx, [ebp+var_8] ; this
.text$mn:000033F4                 call    ?_Orphan_all@_Container_base12@std@@QAEXXZ ; std::_Container_base12::_Orphan_all(void)
.text$mn:000033F9                 mov     eax, [ebp+var_8]
.text$mn:000033FC                 mov     ecx, [eax]
.text$mn:000033FE                 push    ecx
.text$mn:000033FF                 lea     ecx, [ebp+var_1]
.text$mn:00003402                 call    ??$destroy@U_Container_proxy@std@@@?$_Wrap_alloc@V?$allocator@U_Container_proxy@std@@@std@@@std@@QAEXPAU_Container_proxy@1@@Z ; std::_Wrap_alloc<std::allocator<std::_Container_proxy>>::destroy<std::_Container_proxy>(std::_Container_proxy *)
.text$mn:00003407                 push    1               ; int
.text$mn:00003409                 mov     edx, [ebp+var_8]
.text$mn:0000340C                 mov     eax, [edx]
.text$mn:0000340E                 push    eax             ; void *
.text$mn:0000340F                 lea     ecx, [ebp+var_1]
.text$mn:00003412                 call    ?deallocate@?$_Wrap_alloc@V?$allocator@U_Container_proxy@std@@@std@@@std@@QAEXPAU_Container_proxy@2@I@Z ; std::_Wrap_alloc<std::allocator<std::_Container_proxy>>::deallocate(std::_Container_proxy *,uint)
.text$mn:00003417                 mov     ecx, [ebp+var_8]
.text$mn:0000341A                 mov     dword ptr [ecx], 0
.text$mn:00003420                 mov     esp, ebp
.text$mn:00003422                 pop     ebp
.text$mn:00003423                 retn
.text$mn:00003423 ?_Free_proxy@?$_Vector_alloc@$0A@U?$_Vec_base_types@IV?$allocator@I@std@@@std@@@std@@QAEXXZ endp
.text$mn:00003423
.text$mn:00003423 _text$mn        ends
.text$mn:00003423
.text$mn:00003424 ; ===========================================================================
.text$mn:00003424
.text$mn:00003424 ; Segment type: Pure code
.text$mn:00003424 ; Segment permissions: Read/Execute
.text$mn:00003424 _text$mn        segment para public 'CODE' use32
.text$mn:00003424                 assume cs:_text$mn
.text$mn:00003424                 ;org 3424h
.text$mn:00003424 ; COMDAT (pick any)
.text$mn:00003424                 assume es:nothing, ss:nothing, ds:_data, fs:nothing, gs:nothing
.text$mn:00003424
.text$mn:00003424 ; =============== S U B R O U T I N E =======================================
.text$mn:00003424
.text$mn:00003424 ; Attributes: bp-based frame
.text$mn:00003424
.text$mn:00003424 ; public: struct std::_Wrap_alloc<class std::allocator<char>> __thiscall std::_String_alloc<0, struct std::_String_base_types<char, class std::allocator<char>>>::_Getal(void)const
.text$mn:00003424                 public ?_Getal@?$_String_alloc@$0A@U?$_String_base_types@DV?$allocator@D@std@@@std@@@std@@QBE?AU?$_Wrap_alloc@V?$allocator@D@std@@@2@XZ
.text$mn:00003424 ?_Getal@?$_String_alloc@$0A@U?$_String_base_types@DV?$allocator@D@std@@@std@@@std@@QBE?AU?$_Wrap_alloc@V?$allocator@D@std@@@2@XZ proc near
.text$mn:00003424                                         ; CODE XREF: std::basic_string<char,std::char_traits<char>,std::allocator<char>>::_Copy(uint,uint)+B4p
.text$mn:00003424                                         ; __catch$?_Copy@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEXII@Z$0+1Bp ...
.text$mn:00003424
.text$mn:00003424 var_4           = dword ptr -4
.text$mn:00003424 arg_0           = dword ptr  8
.text$mn:00003424
.text$mn:00003424                 push    ebp
.text$mn:00003425                 mov     ebp, esp
.text$mn:00003427                 push    ecx
.text$mn:00003428                 mov     [ebp+var_4], ecx
.text$mn:0000342B                 mov     ecx, [ebp+arg_0]
.text$mn:0000342E                 call    ??0?$_Wrap_alloc@V?$allocator@D@std@@@std@@QAE@XZ ; std::_Wrap_alloc<std::allocator<char>>::_Wrap_alloc<std::allocator<char>>(void)
.text$mn:00003433                 mov     eax, [ebp+arg_0]
.text$mn:00003436                 mov     esp, ebp
.text$mn:00003438                 pop     ebp
.text$mn:00003439                 retn    4
.text$mn:00003439 ?_Getal@?$_String_alloc@$0A@U?$_String_base_types@DV?$allocator@D@std@@@std@@@std@@QBE?AU?$_Wrap_alloc@V?$allocator@D@std@@@2@XZ endp
.text$mn:00003439
.text$mn:00003439 _text$mn        ends
.text$mn:00003439
.text$mn:0000343C ; ===========================================================================
.text$mn:0000343C
.text$mn:0000343C ; Segment type: Pure code
.text$mn:0000343C ; Segment permissions: Read/Execute
.text$mn:0000343C _text$mn        segment para public 'CODE' use32
.text$mn:0000343C                 assume cs:_text$mn
.text$mn:0000343C                 ;org 343Ch
.text$mn:0000343C ; COMDAT (pick any)
.text$mn:0000343C                 assume es:nothing, ss:nothing, ds:_data, fs:nothing, gs:nothing
.text$mn:0000343C
.text$mn:0000343C ; =============== S U B R O U T I N E =======================================
.text$mn:0000343C
.text$mn:0000343C ; Attributes: bp-based frame
.text$mn:0000343C
.text$mn:0000343C ; public: struct std::_Wrap_alloc<class std::allocator<unsigned int>> __thiscall std::_Vector_alloc<0, struct std::_Vec_base_types<unsigned int, class std::allocator<unsigned int>>>::_Getal(void)const
.text$mn:0000343C                 public ?_Getal@?$_Vector_alloc@$0A@U?$_Vec_base_types@IV?$allocator@I@std@@@std@@@std@@QBE?AU?$_Wrap_alloc@V?$allocator@I@std@@@2@XZ
.text$mn:0000343C ?_Getal@?$_Vector_alloc@$0A@U?$_Vec_base_types@IV?$allocator@I@std@@@std@@@std@@QBE?AU?$_Wrap_alloc@V?$allocator@I@std@@@2@XZ proc near
.text$mn:0000343C                                         ; CODE XREF: std::vector<uint,std::allocator<uint>>::_Destroy(uint *,uint *)+10p
.text$mn:0000343C                                         ; std::vector<uint,std::allocator<uint>>::_Tidy(void)+4Ep
.text$mn:0000343C
.text$mn:0000343C var_4           = dword ptr -4
.text$mn:0000343C arg_0           = dword ptr  8
.text$mn:0000343C
.text$mn:0000343C                 push    ebp
.text$mn:0000343D                 mov     ebp, esp
.text$mn:0000343F                 push    ecx
.text$mn:00003440                 mov     [ebp+var_4], ecx
.text$mn:00003443                 mov     ecx, [ebp+arg_0]
.text$mn:00003446                 call    ??0?$_Wrap_alloc@V?$allocator@I@std@@@std@@QAE@XZ ; std::_Wrap_alloc<std::allocator<uint>>::_Wrap_alloc<std::allocator<uint>>(void)
.text$mn:0000344B                 mov     eax, [ebp+arg_0]
.text$mn:0000344E                 mov     esp, ebp
.text$mn:00003450                 pop     ebp
.text$mn:00003451                 retn    4
.text$mn:00003451 ?_Getal@?$_Vector_alloc@$0A@U?$_Vec_base_types@IV?$allocator@I@std@@@std@@@std@@QBE?AU?$_Wrap_alloc@V?$allocator@I@std@@@2@XZ endp
.text$mn:00003451
.text$mn:00003451 _text$mn        ends
.text$mn:00003451
.text$mn:00003454 ; ===========================================================================
.text$mn:00003454
.text$mn:00003454 ; Segment type: Pure code
.text$mn:00003454 ; Segment permissions: Read/Execute
.text$mn:00003454 _text$mn        segment para public 'CODE' use32
.text$mn:00003454                 assume cs:_text$mn
.text$mn:00003454                 ;org 3454h
.text$mn:00003454 ; COMDAT (pick any)
.text$mn:00003454                 assume es:nothing, ss:nothing, ds:_data, fs:nothing, gs:nothing
.text$mn:00003454
.text$mn:00003454 ; =============== S U B R O U T I N E =======================================
.text$mn:00003454
.text$mn:00003454 ; Attributes: bp-based frame
.text$mn:00003454
.text$mn:00003454 ; public: bool __thiscall std::basic_string<char, struct std::char_traits<char>, class std::allocator<char>>::_Grow(unsigned int, bool)
.text$mn:00003454                 public ?_Grow@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE_NI_N@Z
.text$mn:00003454 ?_Grow@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE_NI_N@Z proc near
.text$mn:00003454                                         ; CODE XREF: std::basic_string<char,std::char_traits<char>,std::allocator<char>>::assign(std::basic_string<char,std::char_traits<char>,std::allocator<char>> const &,uint,uint)+6Ap
.text$mn:00003454                                         ; std::basic_string<char,std::char_traits<char>,std::allocator<char>>::assign(char const *,uint)+5Fp
.text$mn:00003454
.text$mn:00003454 var_C           = dword ptr -0Ch
.text$mn:00003454 Size            = dword ptr -8
.text$mn:00003454 var_4           = dword ptr -4
.text$mn:00003454 arg_0           = dword ptr  8
.text$mn:00003454 arg_4           = byte ptr  0Ch
.text$mn:00003454
.text$mn:00003454                 push    ebp
.text$mn:00003455                 mov     ebp, esp
.text$mn:00003457                 sub     esp, 0Ch
.text$mn:0000345A                 mov     [ebp+var_4], ecx
.text$mn:0000345D                 mov     ecx, [ebp+var_4]
.text$mn:00003460                 call    ?max_size@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QBEIXZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char>>::max_size(void)
.text$mn:00003465                 cmp     eax, [ebp+arg_0]
.text$mn:00003468                 jnb     short loc_3472
.text$mn:0000346A                 mov     ecx, [ebp+var_4]
.text$mn:0000346D                 call    ?_Xlen@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QBEXXZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char>>::_Xlen(void)
.text$mn:00003472
.text$mn:00003472 loc_3472:                               ; CODE XREF: std::basic_string<char,std::char_traits<char>,std::allocator<char>>::_Grow(uint,bool)+14j
.text$mn:00003472                 mov     eax, [ebp+var_4]
.text$mn:00003475                 mov     ecx, [eax+18h]
.text$mn:00003478                 cmp     ecx, [ebp+arg_0]
.text$mn:0000347B                 jnb     short loc_3492
.text$mn:0000347D                 mov     edx, [ebp+var_4]
.text$mn:00003480                 mov     eax, [edx+14h]
.text$mn:00003483                 push    eax
.text$mn:00003484                 mov     ecx, [ebp+arg_0]
.text$mn:00003487                 push    ecx
.text$mn:00003488                 mov     ecx, [ebp+var_4]
.text$mn:0000348B                 call    ?_Copy@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEXII@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char>>::_Copy(uint,uint)
.text$mn:00003490                 jmp     short loc_34DC
.text$mn:00003492 ; ---------------------------------------------------------------------------
.text$mn:00003492
.text$mn:00003492 loc_3492:                               ; CODE XREF: std::basic_string<char,std::char_traits<char>,std::allocator<char>>::_Grow(uint,bool)+27j
.text$mn:00003492                 movzx   edx, [ebp+arg_4]
.text$mn:00003496                 test    edx, edx
.text$mn:00003498                 jz      short loc_34CC
.text$mn:0000349A                 cmp     [ebp+arg_0], 10h
.text$mn:0000349E                 jnb     short loc_34CC
.text$mn:000034A0                 mov     eax, [ebp+var_4]
.text$mn:000034A3                 mov     ecx, [ebp+arg_0]
.text$mn:000034A6                 cmp     ecx, [eax+14h]
.text$mn:000034A9                 jnb     short loc_34B3
.text$mn:000034AB                 mov     edx, [ebp+arg_0]
.text$mn:000034AE                 mov     [ebp+Size], edx
.text$mn:000034B1                 jmp     short loc_34BC
.text$mn:000034B3 ; ---------------------------------------------------------------------------
.text$mn:000034B3
.text$mn:000034B3 loc_34B3:                               ; CODE XREF: std::basic_string<char,std::char_traits<char>,std::allocator<char>>::_Grow(uint,bool)+55j
.text$mn:000034B3                 mov     eax, [ebp+var_4]
.text$mn:000034B6                 mov     ecx, [eax+14h]
.text$mn:000034B9                 mov     [ebp+Size], ecx
.text$mn:000034BC
.text$mn:000034BC loc_34BC:                               ; CODE XREF: std::basic_string<char,std::char_traits<char>,std::allocator<char>>::_Grow(uint,bool)+5Dj
.text$mn:000034BC                 mov     edx, [ebp+Size]
.text$mn:000034BF                 push    edx             ; Size
.text$mn:000034C0                 push    1               ; char
.text$mn:000034C2                 mov     ecx, [ebp+var_4]
.text$mn:000034C5                 call    ?_Tidy@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEX_NI@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char>>::_Tidy(bool,uint)
.text$mn:000034CA                 jmp     short loc_34DC
.text$mn:000034CC ; ---------------------------------------------------------------------------
.text$mn:000034CC
.text$mn:000034CC loc_34CC:                               ; CODE XREF: std::basic_string<char,std::char_traits<char>,std::allocator<char>>::_Grow(uint,bool)+44j
.text$mn:000034CC                                         ; std::basic_string<char,std::char_traits<char>,std::allocator<char>>::_Grow(uint,bool)+4Aj
.text$mn:000034CC                 cmp     [ebp+arg_0], 0
.text$mn:000034D0                 jnz     short loc_34DC
.text$mn:000034D2                 push    0
.text$mn:000034D4                 mov     ecx, [ebp+var_4]
.text$mn:000034D7                 call    ?_Eos@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEXI@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char>>::_Eos(uint)
.text$mn:000034DC
.text$mn:000034DC loc_34DC:                               ; CODE XREF: std::basic_string<char,std::char_traits<char>,std::allocator<char>>::_Grow(uint,bool)+3Cj
.text$mn:000034DC                                         ; std::basic_string<char,std::char_traits<char>,std::allocator<char>>::_Grow(uint,bool)+76j ...
.text$mn:000034DC                 cmp     [ebp+arg_0], 0
.text$mn:000034E0                 jbe     short loc_34EB
.text$mn:000034E2                 mov     [ebp+var_C], 1
.text$mn:000034E9                 jmp     short loc_34F2
.text$mn:000034EB ; ---------------------------------------------------------------------------
.text$mn:000034EB
.text$mn:000034EB loc_34EB:                               ; CODE XREF: std::basic_string<char,std::char_traits<char>,std::allocator<char>>::_Grow(uint,bool)+8Cj
.text$mn:000034EB                 mov     [ebp+var_C], 0
.text$mn:000034F2
.text$mn:000034F2 loc_34F2:                               ; CODE XREF: std::basic_string<char,std::char_traits<char>,std::allocator<char>>::_Grow(uint,bool)+95j
.text$mn:000034F2                 mov     al, byte ptr [ebp+var_C]
.text$mn:000034F5                 mov     esp, ebp
.text$mn:000034F7                 pop     ebp
.text$mn:000034F8                 retn    8
.text$mn:000034F8 ?_Grow@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE_NI_N@Z endp
.text$mn:000034F8
.text$mn:000034F8 ; ---------------------------------------------------------------------------
.text$mn:000034FB                 align 4
.text$mn:000034FB _text$mn        ends
.text$mn:000034FB
.text$mn:000034FC ; ===========================================================================
.text$mn:000034FC
.text$mn:000034FC ; Segment type: Pure code
.text$mn:000034FC ; Segment permissions: Read/Execute
.text$mn:000034FC _text$mn        segment para public 'CODE' use32
.text$mn:000034FC                 assume cs:_text$mn
.text$mn:000034FC                 ;org 34FCh
.text$mn:000034FC ; COMDAT (pick any)
.text$mn:000034FC                 assume es:nothing, ss:nothing, ds:_data, fs:nothing, gs:nothing
.text$mn:000034FC
.text$mn:000034FC ; =============== S U B R O U T I N E =======================================
.text$mn:000034FC
.text$mn:000034FC ; Attributes: bp-based frame
.text$mn:000034FC
.text$mn:000034FC ; public: bool __thiscall std::basic_string<char, struct std::char_traits<char>, class std::allocator<char>>::_Inside(char const *)
.text$mn:000034FC                 public ?_Inside@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE_NPBD@Z
.text$mn:000034FC ?_Inside@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE_NPBD@Z proc near
.text$mn:000034FC                                         ; CODE XREF: std::basic_string<char,std::char_traits<char>,std::allocator<char>>::assign(char const *,uint)+2Ap
.text$mn:000034FC
.text$mn:000034FC var_4           = dword ptr -4
.text$mn:000034FC arg_0           = dword ptr  8
.text$mn:000034FC
.text$mn:000034FC                 push    ebp
.text$mn:000034FD                 mov     ebp, esp
.text$mn:000034FF                 push    ecx
.text$mn:00003500                 mov     [ebp+var_4], ecx
.text$mn:00003503                 cmp     [ebp+arg_0], 0
.text$mn:00003507                 jz      short loc_3529
.text$mn:00003509                 mov     ecx, [ebp+var_4]
.text$mn:0000350C                 call    ?_Myptr@?$_String_val@U?$_Simple_types@D@std@@@std@@QAEPADXZ ; std::_String_val<std::_Simple_types<char>>::_Myptr(void)
.text$mn:00003511                 cmp     [ebp+arg_0], eax
.text$mn:00003514                 jb      short loc_3529
.text$mn:00003516                 mov     ecx, [ebp+var_4]
.text$mn:00003519                 call    ?_Myptr@?$_String_val@U?$_Simple_types@D@std@@@std@@QAEPADXZ ; std::_String_val<std::_Simple_types<char>>::_Myptr(void)
.text$mn:0000351E                 mov     ecx, [ebp+var_4]
.text$mn:00003521                 add     eax, [ecx+14h]
.text$mn:00003524                 cmp     eax, [ebp+arg_0]
.text$mn:00003527                 ja      short loc_352F
.text$mn:00003529
.text$mn:00003529 loc_3529:                               ; CODE XREF: std::basic_string<char,std::char_traits<char>,std::allocator<char>>::_Inside(char const *)+Bj
.text$mn:00003529                                         ; std::basic_string<char,std::char_traits<char>,std::allocator<char>>::_Inside(char const *)+18j
.text$mn:00003529                 xor     al, al
.text$mn:0000352B                 jmp     short loc_3531
.text$mn:0000352D ; ---------------------------------------------------------------------------
.text$mn:0000352D                 jmp     short loc_3531
.text$mn:0000352F ; ---------------------------------------------------------------------------
.text$mn:0000352F
.text$mn:0000352F loc_352F:                               ; CODE XREF: std::basic_string<char,std::char_traits<char>,std::allocator<char>>::_Inside(char const *)+2Bj
.text$mn:0000352F                 mov     al, 1
.text$mn:00003531
.text$mn:00003531 loc_3531:                               ; CODE XREF: std::basic_string<char,std::char_traits<char>,std::allocator<char>>::_Inside(char const *)+2Fj
.text$mn:00003531                                         ; std::basic_string<char,std::char_traits<char>,std::allocator<char>>::_Inside(char const *)+31j
.text$mn:00003531                 mov     esp, ebp
.text$mn:00003533                 pop     ebp
.text$mn:00003534                 retn    4
.text$mn:00003534 ?_Inside@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE_NPBD@Z endp
.text$mn:00003534
.text$mn:00003534 ; ---------------------------------------------------------------------------
.text$mn:00003537                 align 4
.text$mn:00003537 _text$mn        ends
.text$mn:00003537
.text$mn:00003538 ; ===========================================================================
.text$mn:00003538
.text$mn:00003538 ; Segment type: Pure code
.text$mn:00003538 ; Segment permissions: Read/Execute
.text$mn:00003538 _text$mn        segment para public 'CODE' use32
.text$mn:00003538                 assume cs:_text$mn
.text$mn:00003538                 ;org 3538h
.text$mn:00003538 ; COMDAT (pick any)
.text$mn:00003538                 assume es:nothing, ss:nothing, ds:_data, fs:nothing, gs:nothing
.text$mn:00003538
.text$mn:00003538 ; =============== S U B R O U T I N E =======================================
.text$mn:00003538
.text$mn:00003538 ; Attributes: bp-based frame
.text$mn:00003538
.text$mn:00003538 ; public: char * __thiscall std::_String_val<struct std::_Simple_types<char>>::_Myptr(void)
.text$mn:00003538                 public ?_Myptr@?$_String_val@U?$_Simple_types@D@std@@@std@@QAEPADXZ
.text$mn:00003538 ?_Myptr@?$_String_val@U?$_Simple_types@D@std@@@std@@QAEPADXZ proc near
.text$mn:00003538                                         ; CODE XREF: $LN19+14p
.text$mn:00003538                                         ; std::basic_string<char,std::char_traits<char>,std::allocator<char>>::_Eos(uint)+1Dp ...
.text$mn:00003538
.text$mn:00003538 var_8           = dword ptr -8
.text$mn:00003538 var_4           = dword ptr -4
.text$mn:00003538
.text$mn:00003538                 push    ebp
.text$mn:00003539                 mov     ebp, esp
.text$mn:0000353B                 sub     esp, 8
.text$mn:0000353E                 mov     [ebp+var_4], ecx
.text$mn:00003541                 mov     eax, [ebp+var_4]
.text$mn:00003544                 cmp     dword ptr [eax+18h], 10h
.text$mn:00003548                 jb      short loc_355E
.text$mn:0000354A                 mov     ecx, [ebp+var_4]
.text$mn:0000354D                 mov     edx, [ecx+4]
.text$mn:00003550                 push    edx
.text$mn:00003551                 call    ??$addressof@D@std@@YAPADAAD@Z ; std::addressof<char>(char &)
.text$mn:00003556                 add     esp, 4
.text$mn:00003559                 mov     [ebp+var_8], eax
.text$mn:0000355C                 jmp     short loc_3567
.text$mn:0000355E ; ---------------------------------------------------------------------------
.text$mn:0000355E
.text$mn:0000355E loc_355E:                               ; CODE XREF: std::_String_val<std::_Simple_types<char>>::_Myptr(void)+10j
.text$mn:0000355E                 mov     eax, [ebp+var_4]
.text$mn:00003561                 add     eax, 4
.text$mn:00003564                 mov     [ebp+var_8], eax
.text$mn:00003567
.text$mn:00003567 loc_3567:                               ; CODE XREF: std::_String_val<std::_Simple_types<char>>::_Myptr(void)+24j
.text$mn:00003567                 mov     eax, [ebp+var_8]
.text$mn:0000356A                 mov     esp, ebp
.text$mn:0000356C                 pop     ebp
.text$mn:0000356D                 retn
.text$mn:0000356D ?_Myptr@?$_String_val@U?$_Simple_types@D@std@@@std@@QAEPADXZ endp
.text$mn:0000356D
.text$mn:0000356D ; ---------------------------------------------------------------------------
.text$mn:0000356E                 align 10h
.text$mn:0000356E _text$mn        ends
.text$mn:0000356E
.text$mn:00003570 ; ===========================================================================
.text$mn:00003570
.text$mn:00003570 ; Segment type: Pure code
.text$mn:00003570 ; Segment permissions: Read/Execute
.text$mn:00003570 _text$mn        segment para public 'CODE' use32
.text$mn:00003570                 assume cs:_text$mn
.text$mn:00003570                 ;org 3570h
.text$mn:00003570 ; COMDAT (pick any)
.text$mn:00003570                 assume es:nothing, ss:nothing, ds:_data, fs:nothing, gs:nothing
.text$mn:00003570
.text$mn:00003570 ; =============== S U B R O U T I N E =======================================
.text$mn:00003570
.text$mn:00003570 ; Attributes: bp-based frame
.text$mn:00003570
.text$mn:00003570 ; public: char const * __thiscall std::_String_val<struct std::_Simple_types<char>>::_Myptr(void)const
.text$mn:00003570                 public ?_Myptr@?$_String_val@U?$_Simple_types@D@std@@@std@@QBEPBDXZ
.text$mn:00003570 ?_Myptr@?$_String_val@U?$_Simple_types@D@std@@@std@@QBEPBDXZ proc near
.text$mn:00003570                                         ; CODE XREF: std::basic_string<char,std::char_traits<char>,std::allocator<char>>::assign(std::basic_string<char,std::char_traits<char>,std::allocator<char>> const &,uint,uint)+7Dp
.text$mn:00003570
.text$mn:00003570 var_8           = dword ptr -8
.text$mn:00003570 var_4           = dword ptr -4
.text$mn:00003570
.text$mn:00003570                 push    ebp
.text$mn:00003571                 mov     ebp, esp
.text$mn:00003573                 sub     esp, 8
.text$mn:00003576                 mov     [ebp+var_4], ecx
.text$mn:00003579                 mov     eax, [ebp+var_4]
.text$mn:0000357C                 cmp     dword ptr [eax+18h], 10h
.text$mn:00003580                 jb      short loc_3596
.text$mn:00003582                 mov     ecx, [ebp+var_4]
.text$mn:00003585                 mov     edx, [ecx+4]
.text$mn:00003588                 push    edx
.text$mn:00003589                 call    ??$addressof@D@std@@YAPADAAD@Z ; std::addressof<char>(char &)
.text$mn:0000358E                 add     esp, 4
.text$mn:00003591                 mov     [ebp+var_8], eax
.text$mn:00003594                 jmp     short loc_359F
.text$mn:00003596 ; ---------------------------------------------------------------------------
.text$mn:00003596
.text$mn:00003596 loc_3596:                               ; CODE XREF: std::_String_val<std::_Simple_types<char>>::_Myptr(void)+10j
.text$mn:00003596                 mov     eax, [ebp+var_4]
.text$mn:00003599                 add     eax, 4
.text$mn:0000359C                 mov     [ebp+var_8], eax
.text$mn:0000359F
.text$mn:0000359F loc_359F:                               ; CODE XREF: std::_String_val<std::_Simple_types<char>>::_Myptr(void)+24j
.text$mn:0000359F                 mov     eax, [ebp+var_8]
.text$mn:000035A2                 mov     esp, ebp
.text$mn:000035A4                 pop     ebp
.text$mn:000035A5                 retn
.text$mn:000035A5 ?_Myptr@?$_String_val@U?$_Simple_types@D@std@@@std@@QBEPBDXZ endp
.text$mn:000035A5
.text$mn:000035A5 ; ---------------------------------------------------------------------------
.text$mn:000035A6                 align 4
.text$mn:000035A6 _text$mn        ends
.text$mn:000035A6
.text$mn:000035A8 ; ===========================================================================
.text$mn:000035A8
.text$mn:000035A8 ; Segment type: Pure code
.text$mn:000035A8 ; Segment permissions: Read/Execute
.text$mn:000035A8 _text$mn        segment para public 'CODE' use32
.text$mn:000035A8                 assume cs:_text$mn
.text$mn:000035A8                 ;org 35A8h
.text$mn:000035A8 ; COMDAT (pick any)
.text$mn:000035A8                 assume es:nothing, ss:nothing, ds:_data, fs:nothing, gs:nothing
.text$mn:000035A8
.text$mn:000035A8 ; =============== S U B R O U T I N E =======================================
.text$mn:000035A8
.text$mn:000035A8 ; Attributes: bp-based frame
.text$mn:000035A8
.text$mn:000035A8 ; void __thiscall std::_Container_base12::_Orphan_all(std::_Container_base12 *__hidden this)
.text$mn:000035A8                 public ?_Orphan_all@_Container_base12@std@@QAEXXZ
.text$mn:000035A8 ?_Orphan_all@_Container_base12@std@@QAEXXZ proc near
.text$mn:000035A8                                         ; CODE XREF: std::_Container_base12::~_Container_base12(void)+Ap
.text$mn:000035A8                                         ; std::_String_alloc<0,std::_String_base_types<char,std::allocator<char>>>::_Free_proxy(void)+14p ...
.text$mn:000035A8
.text$mn:000035A8 var_18          = byte ptr -18h
.text$mn:000035A8 var_14          = dword ptr -14h
.text$mn:000035A8 var_10          = dword ptr -10h
.text$mn:000035A8 var_C           = dword ptr -0Ch
.text$mn:000035A8 var_4           = dword ptr -4
.text$mn:000035A8
.text$mn:000035A8                 push    ebp
.text$mn:000035A9                 mov     ebp, esp
.text$mn:000035AB                 push    0FFFFFFFFh
.text$mn:000035AD                 push    offset __ehhandler$?_Orphan_all@_Container_base12@std@@QAEXXZ
.text$mn:000035B2                 mov     eax, large fs:0
.text$mn:000035B8                 push    eax
.text$mn:000035B9                 sub     esp, 0Ch
.text$mn:000035BC                 mov     eax, dword ptr ds:___security_cookie
.text$mn:000035C1                 xor     eax, ebp
.text$mn:000035C3                 push    eax
.text$mn:000035C4                 lea     eax, [ebp+var_C]
.text$mn:000035C7                 mov     large fs:0, eax
.text$mn:000035CD                 mov     [ebp+var_14], ecx
.text$mn:000035D0                 mov     eax, [ebp+var_14]
.text$mn:000035D3                 cmp     dword ptr [eax], 0
.text$mn:000035D6                 jz      short loc_3633
.text$mn:000035D8                 push    3               ; int
.text$mn:000035DA                 lea     ecx, [ebp+var_18] ; this
.text$mn:000035DD                 call    ??0_Lockit@std@@QAE@H@Z ; std::_Lockit::_Lockit(int)
.text$mn:000035E2                 mov     [ebp+var_4], 0
.text$mn:000035E9                 mov     ecx, [ebp+var_14]
.text$mn:000035EC                 mov     edx, [ecx]
.text$mn:000035EE                 add     edx, 4
.text$mn:000035F1                 mov     [ebp+var_10], edx
.text$mn:000035F4                 jmp     short loc_3603
.text$mn:000035F6 ; ---------------------------------------------------------------------------
.text$mn:000035F6
.text$mn:000035F6 loc_35F6:                               ; CODE XREF: std::_Container_base12::_Orphan_all(void)+6Ej
.text$mn:000035F6                 mov     eax, [ebp+var_10]
.text$mn:000035F9                 mov     ecx, [eax]
.text$mn:000035FB                 mov     edx, [ebp+var_10]
.text$mn:000035FE                 mov     eax, [ecx+4]
.text$mn:00003601                 mov     [edx], eax
.text$mn:00003603
.text$mn:00003603 loc_3603:                               ; CODE XREF: std::_Container_base12::_Orphan_all(void)+4Cj
.text$mn:00003603                 mov     ecx, [ebp+var_10]
.text$mn:00003606                 cmp     dword ptr [ecx], 0
.text$mn:00003609                 jz      short loc_3618
.text$mn:0000360B                 mov     edx, [ebp+var_10]
.text$mn:0000360E                 mov     eax, [edx]
.text$mn:00003610                 mov     dword ptr [eax], 0
.text$mn:00003616                 jmp     short loc_35F6
.text$mn:00003618 ; ---------------------------------------------------------------------------
.text$mn:00003618
.text$mn:00003618 loc_3618:                               ; CODE XREF: std::_Container_base12::_Orphan_all(void)+61j
.text$mn:00003618                 mov     ecx, [ebp+var_14]
.text$mn:0000361B                 mov     edx, [ecx]
.text$mn:0000361D                 mov     dword ptr [edx+4], 0
.text$mn:00003624                 mov     [ebp+var_4], 0FFFFFFFFh
.text$mn:0000362B                 lea     ecx, [ebp+var_18] ; this
.text$mn:0000362E                 call    ??1_Lockit@std@@QAE@XZ ; std::_Lockit::~_Lockit(void)
.text$mn:00003633
.text$mn:00003633 loc_3633:                               ; CODE XREF: std::_Container_base12::_Orphan_all(void)+2Ej
.text$mn:00003633                 mov     ecx, [ebp+var_C]
.text$mn:00003636                 mov     large fs:0, ecx
.text$mn:0000363D                 pop     ecx
.text$mn:0000363E                 mov     esp, ebp
.text$mn:00003640                 pop     ebp
.text$mn:00003641                 retn
.text$mn:00003641 ?_Orphan_all@_Container_base12@std@@QAEXXZ endp
.text$mn:00003641
.text$mn:00003641 ; ---------------------------------------------------------------------------
.text$mn:00003642                 align 4
.text$mn:00003642 _text$mn        ends
.text$mn:00003642
.text$x:00003644 ; ===========================================================================
.text$x:00003644
.text$x:00003644 ; Segment type: Pure code
.text$x:00003644 ; Segment permissions: Read/Execute
.text$x:00003644 _text$x         segment para public 'CODE' use32
.text$x:00003644                 assume cs:_text$x
.text$x:00003644                 ;org 3644h
.text$x:00003644 ; COMDAT (pick associative to section at 35A8)
.text$x:00003644                 assume es:nothing, ss:nothing, ds:_data, fs:nothing, gs:nothing
.text$x:00003644
.text$x:00003644 ; =============== S U B R O U T I N E =======================================
.text$x:00003644
.text$x:00003644
.text$x:00003644 __unwindfunclet$?_Orphan_all@_Container_base12@std@@QAEXXZ$0 proc near
.text$x:00003644                                         ; DATA XREF: .xdata$x:00004314o
.text$x:00003644                 lea     ecx, [ebp-18h]  ; this
.text$x:00003647                 jmp     ??1_Lockit@std@@QAE@XZ ; std::_Lockit::~_Lockit(void)
.text$x:00003647 __unwindfunclet$?_Orphan_all@_Container_base12@std@@QAEXXZ$0 endp
.text$x:00003647
.text$x:0000364C
.text$x:0000364C ; =============== S U B R O U T I N E =======================================
.text$x:0000364C
.text$x:0000364C
.text$x:0000364C __ehhandler$?_Orphan_all@_Container_base12@std@@QAEXXZ proc near
.text$x:0000364C                                         ; DATA XREF: std::_Container_base12::_Orphan_all(void)+5o
.text$x:0000364C
.text$x:0000364C arg_4           = dword ptr  8
.text$x:0000364C
.text$x:0000364C                 mov     edx, [esp+arg_4]
.text$x:00003650                 lea     eax, [edx+0Ch]
.text$x:00003653                 mov     ecx, [edx-10h]
.text$x:00003656                 xor     ecx, eax
.text$x:00003658                 call    @__security_check_cookie@4 ; __security_check_cookie(x)
.text$x:0000365D                 mov     eax, offset __ehfuncinfo$?_Orphan_all@_Container_base12@std@@QAEXXZ
.text$x:00003662                 jmp     ___CxxFrameHandler3
.text$x:00003662 __ehhandler$?_Orphan_all@_Container_base12@std@@QAEXXZ endp
.text$x:00003662
.text$x:00003662 ; ---------------------------------------------------------------------------
.text$x:00003667                 align 4
.text$x:00003667 _text$x         ends
.text$x:00003667
.text$mn:00003668 ; ===========================================================================
.text$mn:00003668
.text$mn:00003668 ; Segment type: Pure code
.text$mn:00003668 ; Segment permissions: Read/Execute
.text$mn:00003668 _text$mn        segment para public 'CODE' use32
.text$mn:00003668                 assume cs:_text$mn
.text$mn:00003668                 ;org 3668h
.text$mn:00003668 ; COMDAT (pick any)
.text$mn:00003668                 assume es:nothing, ss:nothing, ds:_data, fs:nothing, gs:nothing
.text$mn:00003668
.text$mn:00003668 ; =============== S U B R O U T I N E =======================================
.text$mn:00003668
.text$mn:00003668 ; Attributes: bp-based frame
.text$mn:00003668
.text$mn:00003668 ; int __stdcall std::basic_string<char,std::char_traits<char>,std::allocator<char>>::_Tidy(char, size_t Size)
.text$mn:00003668                 public ?_Tidy@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEX_NI@Z
.text$mn:00003668 ?_Tidy@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEX_NI@Z proc near
.text$mn:00003668                                         ; CODE XREF: std::basic_string<char,std::char_traits<char>,std::allocator<char>>::basic_string<char,std::char_traits<char>,std::allocator<char>>(char const *)+47p
.text$mn:00003668                                         ; std::basic_string<char,std::char_traits<char>,std::allocator<char>>::~basic_string<char,std::char_traits<char>,std::allocator<char>>(void)+34p ...
.text$mn:00003668
.text$mn:00003668 var_C           = dword ptr -0Ch
.text$mn:00003668 var_8           = dword ptr -8
.text$mn:00003668 var_2           = byte ptr -2
.text$mn:00003668 var_1           = byte ptr -1
.text$mn:00003668 arg_0           = byte ptr  8
.text$mn:00003668 Size            = dword ptr  0Ch
.text$mn:00003668
.text$mn:00003668                 push    ebp
.text$mn:00003669                 mov     ebp, esp
.text$mn:0000366B                 sub     esp, 0Ch
.text$mn:0000366E                 mov     [ebp+var_8], ecx
.text$mn:00003671                 movzx   eax, [ebp+arg_0]
.text$mn:00003675                 test    eax, eax
.text$mn:00003677                 jnz     short loc_367B
.text$mn:00003679                 jmp     short loc_36EE
.text$mn:0000367B ; ---------------------------------------------------------------------------
.text$mn:0000367B
.text$mn:0000367B loc_367B:                               ; CODE XREF: std::basic_string<char,std::char_traits<char>,std::allocator<char>>::_Tidy(bool,uint)+Fj
.text$mn:0000367B                 mov     ecx, [ebp+var_8]
.text$mn:0000367E                 cmp     dword ptr [ecx+18h], 10h
.text$mn:00003682                 jb      short loc_36EE
.text$mn:00003684                 mov     edx, [ebp+var_8]
.text$mn:00003687                 mov     eax, [edx+4]
.text$mn:0000368A                 mov     [ebp+var_C], eax
.text$mn:0000368D                 mov     ecx, [ebp+var_8]
.text$mn:00003690                 add     ecx, 4
.text$mn:00003693                 push    ecx
.text$mn:00003694                 lea     edx, [ebp+var_1]
.text$mn:00003697                 push    edx
.text$mn:00003698                 mov     ecx, [ebp+var_8]
.text$mn:0000369B                 call    ?_Getal@?$_String_alloc@$0A@U?$_String_base_types@DV?$allocator@D@std@@@std@@@std@@QBE?AU?$_Wrap_alloc@V?$allocator@D@std@@@2@XZ ; std::_String_alloc<0,std::_String_base_types<char,std::allocator<char>>>::_Getal(void)
.text$mn:000036A0                 mov     ecx, eax
.text$mn:000036A2                 call    ??$destroy@PAD@?$_Wrap_alloc@V?$allocator@D@std@@@std@@QAEXPAPAD@Z ; std::_Wrap_alloc<std::allocator<char>>::destroy<char *>(char * *)
.text$mn:000036A7                 cmp     [ebp+Size], 0
.text$mn:000036AB                 jbe     short loc_36CD
.text$mn:000036AD                 mov     eax, [ebp+Size]
.text$mn:000036B0                 push    eax             ; Size
.text$mn:000036B1                 mov     ecx, [ebp+var_C]
.text$mn:000036B4                 push    ecx
.text$mn:000036B5                 call    ??$addressof@D@std@@YAPADAAD@Z ; std::addressof<char>(char &)
.text$mn:000036BA                 add     esp, 4
.text$mn:000036BD                 push    eax             ; Src
.text$mn:000036BE                 mov     edx, [ebp+var_8]
.text$mn:000036C1                 add     edx, 4
.text$mn:000036C4                 push    edx             ; Dst
.text$mn:000036C5                 call    ?copy@?$char_traits@D@std@@SAPADPADPBDI@Z ; std::char_traits<char>::copy(char *,char const *,uint)
.text$mn:000036CA                 add     esp, 0Ch
.text$mn:000036CD
.text$mn:000036CD loc_36CD:                               ; CODE XREF: std::basic_string<char,std::char_traits<char>,std::allocator<char>>::_Tidy(bool,uint)+43j
.text$mn:000036CD                 mov     eax, [ebp+var_8]
.text$mn:000036D0                 mov     ecx, [eax+18h]
.text$mn:000036D3                 add     ecx, 1
.text$mn:000036D6                 push    ecx             ; int
.text$mn:000036D7                 mov     edx, [ebp+var_C]
.text$mn:000036DA                 push    edx             ; void *
.text$mn:000036DB                 lea     eax, [ebp+var_2]
.text$mn:000036DE                 push    eax
.text$mn:000036DF                 mov     ecx, [ebp+var_8]
.text$mn:000036E2                 call    ?_Getal@?$_String_alloc@$0A@U?$_String_base_types@DV?$allocator@D@std@@@std@@@std@@QBE?AU?$_Wrap_alloc@V?$allocator@D@std@@@2@XZ ; std::_String_alloc<0,std::_String_base_types<char,std::allocator<char>>>::_Getal(void)
.text$mn:000036E7                 mov     ecx, eax
.text$mn:000036E9                 call    ?deallocate@?$_Wrap_alloc@V?$allocator@D@std@@@std@@QAEXPADI@Z ; std::_Wrap_alloc<std::allocator<char>>::deallocate(char *,uint)
.text$mn:000036EE
.text$mn:000036EE loc_36EE:                               ; CODE XREF: std::basic_string<char,std::char_traits<char>,std::allocator<char>>::_Tidy(bool,uint)+11j
.text$mn:000036EE                                         ; std::basic_string<char,std::char_traits<char>,std::allocator<char>>::_Tidy(bool,uint)+1Aj
.text$mn:000036EE                 mov     ecx, [ebp+var_8]
.text$mn:000036F1                 mov     dword ptr [ecx+18h], 0Fh
.text$mn:000036F8                 mov     edx, [ebp+Size]
.text$mn:000036FB                 push    edx
.text$mn:000036FC                 mov     ecx, [ebp+var_8]
.text$mn:000036FF                 call    ?_Eos@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEXI@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char>>::_Eos(uint)
.text$mn:00003704                 mov     esp, ebp
.text$mn:00003706                 pop     ebp
.text$mn:00003707                 retn    8
.text$mn:00003707 ?_Tidy@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEX_NI@Z endp
.text$mn:00003707
.text$mn:00003707 ; ---------------------------------------------------------------------------
.text$mn:0000370A                 align 4
.text$mn:0000370A _text$mn        ends
.text$mn:0000370A
.text$mn:0000370C ; ===========================================================================
.text$mn:0000370C
.text$mn:0000370C ; Segment type: Pure code
.text$mn:0000370C ; Segment permissions: Read/Execute
.text$mn:0000370C _text$mn        segment para public 'CODE' use32
.text$mn:0000370C                 assume cs:_text$mn
.text$mn:0000370C                 ;org 370Ch
.text$mn:0000370C ; COMDAT (pick any)
.text$mn:0000370C                 assume es:nothing, ss:nothing, ds:_data, fs:nothing, gs:nothing
.text$mn:0000370C
.text$mn:0000370C ; =============== S U B R O U T I N E =======================================
.text$mn:0000370C
.text$mn:0000370C ; Attributes: bp-based frame
.text$mn:0000370C
.text$mn:0000370C ; protected: void __thiscall std::vector<unsigned int, class std::allocator<unsigned int>>::_Tidy(void)
.text$mn:0000370C                 public ?_Tidy@?$vector@IV?$allocator@I@std@@@std@@IAEXXZ
.text$mn:0000370C ?_Tidy@?$vector@IV?$allocator@I@std@@@std@@IAEXXZ proc near
.text$mn:0000370C                                         ; CODE XREF: std::vector<uint,std::allocator<uint>>::~vector<uint,std::allocator<uint>>(void)+30p
.text$mn:0000370C
.text$mn:0000370C var_8           = dword ptr -8
.text$mn:0000370C var_1           = byte ptr -1
.text$mn:0000370C
.text$mn:0000370C                 push    ebp
.text$mn:0000370D                 mov     ebp, esp
.text$mn:0000370F                 sub     esp, 8
.text$mn:00003712                 mov     [ebp+var_8], ecx
.text$mn:00003715                 mov     eax, [ebp+var_8]
.text$mn:00003718                 cmp     dword ptr [eax+4], 0
.text$mn:0000371C                 jz      short loc_3784
.text$mn:0000371E                 mov     ecx, [ebp+var_8] ; this
.text$mn:00003721                 call    ?_Orphan_all@_Container_base12@std@@QAEXXZ ; std::_Container_base12::_Orphan_all(void)
.text$mn:00003726                 mov     ecx, [ebp+var_8]
.text$mn:00003729                 mov     edx, [ecx+8]
.text$mn:0000372C                 push    edx
.text$mn:0000372D                 mov     eax, [ebp+var_8]
.text$mn:00003730                 mov     ecx, [eax+4]
.text$mn:00003733                 push    ecx
.text$mn:00003734                 mov     ecx, [ebp+var_8]
.text$mn:00003737                 call    ?_Destroy@?$vector@IV?$allocator@I@std@@@std@@IAEXPAI0@Z ; std::vector<uint,std::allocator<uint>>::_Destroy(uint *,uint *)
.text$mn:0000373C                 mov     edx, [ebp+var_8]
.text$mn:0000373F                 mov     eax, [ebp+var_8]
.text$mn:00003742                 mov     ecx, [edx+0Ch]
.text$mn:00003745                 sub     ecx, [eax+4]
.text$mn:00003748                 sar     ecx, 2
.text$mn:0000374B                 push    ecx             ; int
.text$mn:0000374C                 mov     edx, [ebp+var_8]
.text$mn:0000374F                 mov     eax, [edx+4]
.text$mn:00003752                 push    eax             ; void *
.text$mn:00003753                 lea     ecx, [ebp+var_1]
.text$mn:00003756                 push    ecx
.text$mn:00003757                 mov     ecx, [ebp+var_8]
.text$mn:0000375A                 call    ?_Getal@?$_Vector_alloc@$0A@U?$_Vec_base_types@IV?$allocator@I@std@@@std@@@std@@QBE?AU?$_Wrap_alloc@V?$allocator@I@std@@@2@XZ ; std::_Vector_alloc<0,std::_Vec_base_types<uint,std::allocator<uint>>>::_Getal(void)
.text$mn:0000375F                 mov     ecx, eax
.text$mn:00003761                 call    ?deallocate@?$_Wrap_alloc@V?$allocator@I@std@@@std@@QAEXPAII@Z ; std::_Wrap_alloc<std::allocator<uint>>::deallocate(uint *,uint)
.text$mn:00003766                 mov     edx, [ebp+var_8]
.text$mn:00003769                 mov     dword ptr [edx+4], 0
.text$mn:00003770                 mov     eax, [ebp+var_8]
.text$mn:00003773                 mov     dword ptr [eax+8], 0
.text$mn:0000377A                 mov     ecx, [ebp+var_8]
.text$mn:0000377D                 mov     dword ptr [ecx+0Ch], 0
.text$mn:00003784
.text$mn:00003784 loc_3784:                               ; CODE XREF: std::vector<uint,std::allocator<uint>>::_Tidy(void)+10j
.text$mn:00003784                 mov     esp, ebp
.text$mn:00003786                 pop     ebp
.text$mn:00003787                 retn
.text$mn:00003787 ?_Tidy@?$vector@IV?$allocator@I@std@@@std@@IAEXXZ endp
.text$mn:00003787
.text$mn:00003787 _text$mn        ends
.text$mn:00003787
.text$mn:00003788 ; ===========================================================================
.text$mn:00003788
.text$mn:00003788 ; Segment type: Pure code
.text$mn:00003788 ; Segment permissions: Read/Execute
.text$mn:00003788 _text$mn        segment para public 'CODE' use32
.text$mn:00003788                 assume cs:_text$mn
.text$mn:00003788                 ;org 3788h
.text$mn:00003788 ; COMDAT (pick any)
.text$mn:00003788                 assume es:nothing, ss:nothing, ds:_data, fs:nothing, gs:nothing
.text$mn:00003788
.text$mn:00003788 ; =============== S U B R O U T I N E =======================================
.text$mn:00003788
.text$mn:00003788 ; Attributes: bp-based frame
.text$mn:00003788
.text$mn:00003788 ; public: void __thiscall std::basic_string<char, struct std::char_traits<char>, class std::allocator<char>>::_Xlen(void)const
.text$mn:00003788                 public ?_Xlen@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QBEXXZ
.text$mn:00003788 ?_Xlen@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QBEXXZ proc near
.text$mn:00003788                                         ; CODE XREF: std::basic_string<char,std::char_traits<char>,std::allocator<char>>::_Grow(uint,bool)+19p
.text$mn:00003788
.text$mn:00003788 var_4           = dword ptr -4
.text$mn:00003788
.text$mn:00003788                 push    ebp
.text$mn:00003789                 mov     ebp, esp
.text$mn:0000378B                 push    ecx
.text$mn:0000378C                 mov     [ebp+var_4], ecx
.text$mn:0000378F                 push    offset ??_C@_0BA@JFNIOLAK@string?5too?5long?$AA@ ; "string too long"
.text$mn:00003794                 call    ?_Xlength_error@std@@YAXPBD@Z ; std::_Xlength_error(char const *)
.text$mn:00003799                 mov     esp, ebp
.text$mn:0000379B                 pop     ebp
.text$mn:0000379C                 retn
.text$mn:0000379C ?_Xlen@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QBEXXZ endp
.text$mn:0000379C
.text$mn:0000379C ; ---------------------------------------------------------------------------
.text$mn:0000379D                 align 10h
.text$mn:0000379D _text$mn        ends
.text$mn:0000379D
.text$mn:000037A0 ; ===========================================================================
.text$mn:000037A0
.text$mn:000037A0 ; Segment type: Pure code
.text$mn:000037A0 ; Segment permissions: Read/Execute
.text$mn:000037A0 _text$mn        segment para public 'CODE' use32
.text$mn:000037A0                 assume cs:_text$mn
.text$mn:000037A0                 ;org 37A0h
.text$mn:000037A0 ; COMDAT (pick any)
.text$mn:000037A0                 assume es:nothing, ss:nothing, ds:_data, fs:nothing, gs:nothing
.text$mn:000037A0
.text$mn:000037A0 ; =============== S U B R O U T I N E =======================================
.text$mn:000037A0
.text$mn:000037A0 ; Attributes: bp-based frame
.text$mn:000037A0
.text$mn:000037A0 ; public: void __thiscall std::basic_string<char, struct std::char_traits<char>, class std::allocator<char>>::_Xran(void)const
.text$mn:000037A0                 public ?_Xran@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QBEXXZ
.text$mn:000037A0 ?_Xran@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QBEXXZ proc near
.text$mn:000037A0                                         ; CODE XREF: std::basic_string<char,std::char_traits<char>,std::allocator<char>>::assign(std::basic_string<char,std::char_traits<char>,std::allocator<char>> const &,uint,uint)+19p
.text$mn:000037A0                                         ; std::basic_string<char,std::char_traits<char>,std::allocator<char>>::erase(uint)+15p ...
.text$mn:000037A0
.text$mn:000037A0 var_4           = dword ptr -4
.text$mn:000037A0
.text$mn:000037A0                 push    ebp
.text$mn:000037A1                 mov     ebp, esp
.text$mn:000037A3                 push    ecx
.text$mn:000037A4                 mov     [ebp+var_4], ecx
.text$mn:000037A7                 push    offset ??_C@_0BI@CFPLBAOH@invalid?5string?5position?$AA@ ; "invalid string position"
.text$mn:000037AC                 call    ?_Xout_of_range@std@@YAXPBD@Z ; std::_Xout_of_range(char const *)
.text$mn:000037B1                 mov     esp, ebp
.text$mn:000037B3                 pop     ebp
.text$mn:000037B4                 retn
.text$mn:000037B4 ?_Xran@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QBEXXZ endp
.text$mn:000037B4
.text$mn:000037B4 ; ---------------------------------------------------------------------------
.text$mn:000037B5                 align 4
.text$mn:000037B5 _text$mn        ends
.text$mn:000037B5
.text$mn:000037B8 ; ===========================================================================
.text$mn:000037B8
.text$mn:000037B8 ; Segment type: Pure code
.text$mn:000037B8 ; Segment permissions: Read/Execute
.text$mn:000037B8 _text$mn        segment para public 'CODE' use32
.text$mn:000037B8                 assume cs:_text$mn
.text$mn:000037B8                 ;org 37B8h
.text$mn:000037B8 ; COMDAT (pick any)
.text$mn:000037B8                 assume es:nothing, ss:nothing, ds:_data, fs:nothing, gs:nothing
.text$mn:000037B8
.text$mn:000037B8 ; =============== S U B R O U T I N E =======================================
.text$mn:000037B8
.text$mn:000037B8 ; Attributes: bp-based frame
.text$mn:000037B8
.text$mn:000037B8 ; public: char * __thiscall std::_Wrap_alloc<class std::allocator<char>>::allocate(unsigned int)
.text$mn:000037B8                 public ?allocate@?$_Wrap_alloc@V?$allocator@D@std@@@std@@QAEPADI@Z
.text$mn:000037B8 ?allocate@?$_Wrap_alloc@V?$allocator@D@std@@@std@@QAEPADI@Z proc near
.text$mn:000037B8                                         ; CODE XREF: std::basic_string<char,std::char_traits<char>,std::allocator<char>>::_Copy(uint,uint)+BBp
.text$mn:000037B8                                         ; __catch$?_Copy@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEXII@Z$0+22p
.text$mn:000037B8
.text$mn:000037B8 var_4           = dword ptr -4
.text$mn:000037B8 arg_0           = dword ptr  8
.text$mn:000037B8
.text$mn:000037B8                 push    ebp
.text$mn:000037B9                 mov     ebp, esp
.text$mn:000037BB                 push    ecx
.text$mn:000037BC                 mov     [ebp+var_4], ecx
.text$mn:000037BF                 mov     eax, [ebp+arg_0]
.text$mn:000037C2                 push    eax
.text$mn:000037C3                 mov     ecx, [ebp+var_4]
.text$mn:000037C6                 call    ?allocate@?$allocator@D@std@@QAEPADI@Z ; std::allocator<char>::allocate(uint)
.text$mn:000037CB                 mov     esp, ebp
.text$mn:000037CD                 pop     ebp
.text$mn:000037CE                 retn    4
.text$mn:000037CE ?allocate@?$_Wrap_alloc@V?$allocator@D@std@@@std@@QAEPADI@Z endp
.text$mn:000037CE
.text$mn:000037CE ; ---------------------------------------------------------------------------
.text$mn:000037D1                 align 4
.text$mn:000037D1 _text$mn        ends
.text$mn:000037D1
.text$mn:000037D4 ; ===========================================================================
.text$mn:000037D4
.text$mn:000037D4 ; Segment type: Pure code
.text$mn:000037D4 ; Segment permissions: Read/Execute
.text$mn:000037D4 _text$mn        segment para public 'CODE' use32
.text$mn:000037D4                 assume cs:_text$mn
.text$mn:000037D4                 ;org 37D4h
.text$mn:000037D4 ; COMDAT (pick any)
.text$mn:000037D4                 assume es:nothing, ss:nothing, ds:_data, fs:nothing, gs:nothing
.text$mn:000037D4
.text$mn:000037D4 ; =============== S U B R O U T I N E =======================================
.text$mn:000037D4
.text$mn:000037D4 ; Attributes: bp-based frame
.text$mn:000037D4
.text$mn:000037D4 ; public: struct std::_Container_proxy * __thiscall std::_Wrap_alloc<class std::allocator<struct std::_Container_proxy>>::allocate(unsigned int)
.text$mn:000037D4                 public ?allocate@?$_Wrap_alloc@V?$allocator@U_Container_proxy@std@@@std@@@std@@QAEPAU_Container_proxy@2@I@Z
.text$mn:000037D4 ?allocate@?$_Wrap_alloc@V?$allocator@U_Container_proxy@std@@@std@@@std@@QAEPAU_Container_proxy@2@I@Z proc near
.text$mn:000037D4                                         ; CODE XREF: std::_Vector_alloc<0,std::_Vec_base_types<uint,std::allocator<uint>>>::_Alloc_proxy(void)+16p
.text$mn:000037D4
.text$mn:000037D4 var_4           = dword ptr -4
.text$mn:000037D4 arg_0           = dword ptr  8
.text$mn:000037D4
.text$mn:000037D4                 push    ebp
.text$mn:000037D5                 mov     ebp, esp
.text$mn:000037D7                 push    ecx
.text$mn:000037D8                 mov     [ebp+var_4], ecx
.text$mn:000037DB                 mov     eax, [ebp+arg_0]
.text$mn:000037DE                 push    eax
.text$mn:000037DF                 mov     ecx, [ebp+var_4]
.text$mn:000037E2                 call    ?allocate@?$allocator@U_Container_proxy@std@@@std@@QAEPAU_Container_proxy@2@I@Z ; std::allocator<std::_Container_proxy>::allocate(uint)
.text$mn:000037E7                 mov     esp, ebp
.text$mn:000037E9                 pop     ebp
.text$mn:000037EA                 retn    4
.text$mn:000037EA ?allocate@?$_Wrap_alloc@V?$allocator@U_Container_proxy@std@@@std@@@std@@QAEPAU_Container_proxy@2@I@Z endp
.text$mn:000037EA
.text$mn:000037EA ; ---------------------------------------------------------------------------
.text$mn:000037ED                 align 10h
.text$mn:000037ED _text$mn        ends
.text$mn:000037ED
.text$mn:000037F0 ; ===========================================================================
.text$mn:000037F0
.text$mn:000037F0 ; Segment type: Pure code
.text$mn:000037F0 ; Segment permissions: Read/Execute
.text$mn:000037F0 _text$mn        segment para public 'CODE' use32
.text$mn:000037F0                 assume cs:_text$mn
.text$mn:000037F0                 ;org 37F0h
.text$mn:000037F0 ; COMDAT (pick any)
.text$mn:000037F0                 assume es:nothing, ss:nothing, ds:_data, fs:nothing, gs:nothing
.text$mn:000037F0
.text$mn:000037F0 ; =============== S U B R O U T I N E =======================================
.text$mn:000037F0
.text$mn:000037F0 ; Attributes: bp-based frame
.text$mn:000037F0
.text$mn:000037F0 ; public: char * __thiscall std::allocator<char>::allocate(unsigned int)
.text$mn:000037F0                 public ?allocate@?$allocator@D@std@@QAEPADI@Z
.text$mn:000037F0 ?allocate@?$allocator@D@std@@QAEPADI@Z proc near
.text$mn:000037F0                                         ; CODE XREF: std::_Wrap_alloc<std::allocator<char>>::allocate(uint)+Ep
.text$mn:000037F0
.text$mn:000037F0 var_4           = dword ptr -4
.text$mn:000037F0 arg_0           = dword ptr  8
.text$mn:000037F0
.text$mn:000037F0                 push    ebp
.text$mn:000037F1                 mov     ebp, esp
.text$mn:000037F3                 push    ecx
.text$mn:000037F4                 mov     [ebp+var_4], ecx
.text$mn:000037F7                 push    0
.text$mn:000037F9                 mov     eax, [ebp+arg_0]
.text$mn:000037FC                 push    eax
.text$mn:000037FD                 call    ??$_Allocate@D@std@@YAPADIPAD@Z ; std::_Allocate<char>(uint,char *)
.text$mn:00003802                 add     esp, 8
.text$mn:00003805                 mov     esp, ebp
.text$mn:00003807                 pop     ebp
.text$mn:00003808                 retn    4
.text$mn:00003808 ?allocate@?$allocator@D@std@@QAEPADI@Z endp
.text$mn:00003808
.text$mn:00003808 ; ---------------------------------------------------------------------------
.text$mn:0000380B                 align 4
.text$mn:0000380B _text$mn        ends
.text$mn:0000380B
.text$mn:0000380C ; ===========================================================================
.text$mn:0000380C
.text$mn:0000380C ; Segment type: Pure code
.text$mn:0000380C ; Segment permissions: Read/Execute
.text$mn:0000380C _text$mn        segment para public 'CODE' use32
.text$mn:0000380C                 assume cs:_text$mn
.text$mn:0000380C                 ;org 380Ch
.text$mn:0000380C ; COMDAT (pick any)
.text$mn:0000380C                 assume es:nothing, ss:nothing, ds:_data, fs:nothing, gs:nothing
.text$mn:0000380C
.text$mn:0000380C ; =============== S U B R O U T I N E =======================================
.text$mn:0000380C
.text$mn:0000380C ; Attributes: bp-based frame
.text$mn:0000380C
.text$mn:0000380C ; public: struct std::_Container_proxy * __thiscall std::allocator<struct std::_Container_proxy>::allocate(unsigned int)
.text$mn:0000380C                 public ?allocate@?$allocator@U_Container_proxy@std@@@std@@QAEPAU_Container_proxy@2@I@Z
.text$mn:0000380C ?allocate@?$allocator@U_Container_proxy@std@@@std@@QAEPAU_Container_proxy@2@I@Z proc near
.text$mn:0000380C                                         ; CODE XREF: std::_String_alloc<0,std::_String_base_types<char,std::allocator<char>>>::_Alloc_proxy(void)+16p
.text$mn:0000380C                                         ; std::_Wrap_alloc<std::allocator<std::_Container_proxy>>::allocate(uint)+Ep
.text$mn:0000380C
.text$mn:0000380C var_4           = dword ptr -4
.text$mn:0000380C arg_0           = dword ptr  8
.text$mn:0000380C
.text$mn:0000380C                 push    ebp
.text$mn:0000380D                 mov     ebp, esp
.text$mn:0000380F                 push    ecx
.text$mn:00003810                 mov     [ebp+var_4], ecx
.text$mn:00003813                 push    0
.text$mn:00003815                 mov     eax, [ebp+arg_0]
.text$mn:00003818                 push    eax
.text$mn:00003819                 call    ??$_Allocate@U_Container_proxy@std@@@std@@YAPAU_Container_proxy@0@IPAU10@@Z ; std::_Allocate<std::_Container_proxy>(uint,std::_Container_proxy *)
.text$mn:0000381E                 add     esp, 8
.text$mn:00003821                 mov     esp, ebp
.text$mn:00003823                 pop     ebp
.text$mn:00003824                 retn    4
.text$mn:00003824 ?allocate@?$allocator@U_Container_proxy@std@@@std@@QAEPAU_Container_proxy@2@I@Z endp
.text$mn:00003824
.text$mn:00003824 ; ---------------------------------------------------------------------------
.text$mn:00003827                 align 4
.text$mn:00003827 _text$mn        ends
.text$mn:00003827
.text$mn:00003828 ; ===========================================================================
.text$mn:00003828
.text$mn:00003828 ; Segment type: Pure code
.text$mn:00003828 ; Segment permissions: Read/Execute
.text$mn:00003828 _text$mn        segment para public 'CODE' use32
.text$mn:00003828                 assume cs:_text$mn
.text$mn:00003828                 ;org 3828h
.text$mn:00003828 ; COMDAT (pick any)
.text$mn:00003828                 assume es:nothing, ss:nothing, ds:_data, fs:nothing, gs:nothing
.text$mn:00003828
.text$mn:00003828 ; =============== S U B R O U T I N E =======================================
.text$mn:00003828
.text$mn:00003828 ; Attributes: bp-based frame
.text$mn:00003828
.text$mn:00003828 ; public: class std::basic_string<char, struct std::char_traits<char>, class std::allocator<char>> & __thiscall std::basic_string<char, struct std::char_traits<char>, class std::allocator<char>>::assign(class std::basic_string<char, struct std::char_traits<char>, class std::allocator<char>> const &, unsigned int, unsigned int)
.text$mn:00003828                 public ?assign@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV12@ABV12@II@Z
.text$mn:00003828 ?assign@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV12@ABV12@II@Z proc near
.text$mn:00003828                                         ; CODE XREF: std::basic_string<char,std::char_traits<char>,std::allocator<char>>::assign(char const *,uint)+4Fp
.text$mn:00003828
.text$mn:00003828 Size            = dword ptr -8
.text$mn:00003828 var_4           = dword ptr -4
.text$mn:00003828 arg_0           = dword ptr  8
.text$mn:00003828 arg_4           = dword ptr  0Ch
.text$mn:00003828 arg_8           = dword ptr  10h
.text$mn:00003828
.text$mn:00003828                 push    ebp
.text$mn:00003829                 mov     ebp, esp
.text$mn:0000382B                 sub     esp, 8
.text$mn:0000382E                 mov     [ebp+var_4], ecx
.text$mn:00003831                 mov     ecx, [ebp+arg_0]
.text$mn:00003834                 call    ?size@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QBEIXZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char>>::size(void)
.text$mn:00003839                 cmp     eax, [ebp+arg_4]
.text$mn:0000383C                 jnb     short loc_3846
.text$mn:0000383E                 mov     ecx, [ebp+var_4]
.text$mn:00003841                 call    ?_Xran@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QBEXXZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char>>::_Xran(void)
.text$mn:00003846
.text$mn:00003846 loc_3846:                               ; CODE XREF: std::basic_string<char,std::char_traits<char>,std::allocator<char>>::assign(std::basic_string<char,std::char_traits<char>,std::allocator<char>> const &,uint,uint)+14j
.text$mn:00003846                 mov     ecx, [ebp+arg_0]
.text$mn:00003849                 call    ?size@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QBEIXZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char>>::size(void)
.text$mn:0000384E                 sub     eax, [ebp+arg_4]
.text$mn:00003851                 mov     [ebp+Size], eax
.text$mn:00003854                 mov     eax, [ebp+arg_8]
.text$mn:00003857                 cmp     eax, [ebp+Size]
.text$mn:0000385A                 jnb     short loc_3862
.text$mn:0000385C                 mov     ecx, [ebp+arg_8]
.text$mn:0000385F                 mov     [ebp+Size], ecx
.text$mn:00003862
.text$mn:00003862 loc_3862:                               ; CODE XREF: std::basic_string<char,std::char_traits<char>,std::allocator<char>>::assign(std::basic_string<char,std::char_traits<char>,std::allocator<char>> const &,uint,uint)+32j
.text$mn:00003862                 mov     edx, [ebp+var_4]
.text$mn:00003865                 cmp     edx, [ebp+arg_0]
.text$mn:00003868                 jnz     short loc_3889
.text$mn:0000386A                 mov     eax, [ebp+arg_4]
.text$mn:0000386D                 add     eax, [ebp+Size]
.text$mn:00003870                 push    eax
.text$mn:00003871                 mov     ecx, [ebp+var_4]
.text$mn:00003874                 call    ?erase@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV12@I@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char>>::erase(uint)
.text$mn:00003879                 mov     ecx, [ebp+arg_4]
.text$mn:0000387C                 push    ecx
.text$mn:0000387D                 push    0
.text$mn:0000387F                 mov     ecx, [ebp+var_4]
.text$mn:00003882                 call    ?erase@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV12@II@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char>>::erase(uint,uint)
.text$mn:00003887                 jmp     short loc_38CB
.text$mn:00003889 ; ---------------------------------------------------------------------------
.text$mn:00003889
.text$mn:00003889 loc_3889:                               ; CODE XREF: std::basic_string<char,std::char_traits<char>,std::allocator<char>>::assign(std::basic_string<char,std::char_traits<char>,std::allocator<char>> const &,uint,uint)+40j
.text$mn:00003889                 push    0
.text$mn:0000388B                 mov     edx, [ebp+Size]
.text$mn:0000388E                 push    edx
.text$mn:0000388F                 mov     ecx, [ebp+var_4]
.text$mn:00003892                 call    ?_Grow@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE_NI_N@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char>>::_Grow(uint,bool)
.text$mn:00003897                 movzx   eax, al
.text$mn:0000389A                 test    eax, eax
.text$mn:0000389C                 jz      short loc_38CB
.text$mn:0000389E                 mov     ecx, [ebp+Size]
.text$mn:000038A1                 push    ecx             ; Size
.text$mn:000038A2                 mov     ecx, [ebp+arg_0]
.text$mn:000038A5                 call    ?_Myptr@?$_String_val@U?$_Simple_types@D@std@@@std@@QBEPBDXZ ; std::_String_val<std::_Simple_types<char>>::_Myptr(void)
.text$mn:000038AA                 add     eax, [ebp+arg_4]
.text$mn:000038AD                 push    eax             ; Src
.text$mn:000038AE                 mov     ecx, [ebp+var_4]
.text$mn:000038B1                 call    ?_Myptr@?$_String_val@U?$_Simple_types@D@std@@@std@@QAEPADXZ ; std::_String_val<std::_Simple_types<char>>::_Myptr(void)
.text$mn:000038B6                 push    eax             ; Dst
.text$mn:000038B7                 call    ?copy@?$char_traits@D@std@@SAPADPADPBDI@Z ; std::char_traits<char>::copy(char *,char const *,uint)
.text$mn:000038BC                 add     esp, 0Ch
.text$mn:000038BF                 mov     edx, [ebp+Size]
.text$mn:000038C2                 push    edx
.text$mn:000038C3                 mov     ecx, [ebp+var_4]
.text$mn:000038C6                 call    ?_Eos@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEXI@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char>>::_Eos(uint)
.text$mn:000038CB
.text$mn:000038CB loc_38CB:                               ; CODE XREF: std::basic_string<char,std::char_traits<char>,std::allocator<char>>::assign(std::basic_string<char,std::char_traits<char>,std::allocator<char>> const &,uint,uint)+5Fj
.text$mn:000038CB                                         ; std::basic_string<char,std::char_traits<char>,std::allocator<char>>::assign(std::basic_string<char,std::char_traits<char>,std::allocator<char>> const &,uint,uint)+74j
.text$mn:000038CB                 mov     eax, [ebp+var_4]
.text$mn:000038CE                 mov     esp, ebp
.text$mn:000038D0                 pop     ebp
.text$mn:000038D1                 retn    0Ch
.text$mn:000038D1 ?assign@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV12@ABV12@II@Z endp
.text$mn:000038D1
.text$mn:000038D1 _text$mn        ends
.text$mn:000038D1
.text$mn:000038D4 ; ===========================================================================
.text$mn:000038D4
.text$mn:000038D4 ; Segment type: Pure code
.text$mn:000038D4 ; Segment permissions: Read/Execute
.text$mn:000038D4 _text$mn        segment para public 'CODE' use32
.text$mn:000038D4                 assume cs:_text$mn
.text$mn:000038D4                 ;org 38D4h
.text$mn:000038D4 ; COMDAT (pick any)
.text$mn:000038D4                 assume es:nothing, ss:nothing, ds:_data, fs:nothing, gs:nothing
.text$mn:000038D4
.text$mn:000038D4 ; =============== S U B R O U T I N E =======================================
.text$mn:000038D4
.text$mn:000038D4 ; Attributes: bp-based frame
.text$mn:000038D4
.text$mn:000038D4 ; int __stdcall std::basic_string<char,std::char_traits<char>,std::allocator<char>>::assign(char *Str)
.text$mn:000038D4                 public ?assign@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV12@PBD@Z
.text$mn:000038D4 ?assign@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV12@PBD@Z proc near
.text$mn:000038D4                                         ; CODE XREF: std::basic_string<char,std::char_traits<char>,std::allocator<char>>::basic_string<char,std::char_traits<char>,std::allocator<char>>(char const *)+53p
.text$mn:000038D4
.text$mn:000038D4 var_4           = dword ptr -4
.text$mn:000038D4 Str             = dword ptr  8
.text$mn:000038D4
.text$mn:000038D4                 push    ebp
.text$mn:000038D5                 mov     ebp, esp
.text$mn:000038D7                 push    ecx
.text$mn:000038D8                 mov     [ebp+var_4], ecx
.text$mn:000038DB                 push    490h            ; unsigned int
.text$mn:000038E0                 push    offset ??_C@_1IO@FEAPGJBD@?$AAC?$AA?3?$AA?2?$AAP?$AAr?$AAo?$AAg?$AAr?$AAa?$AAm?$AA?5?$AAF?$AAi?$AAl?$AAe?$AAs?$AA?5?$AA?$CI?$AAx?$AA8?$AA6?$AA?$CJ?$AA?2?$AAM?$AAi?$AAc?$AAr?$AAo?$AAs?$AAo?$AAf?$AAt@ ; "C:\\Program Files (x86)\\Microsoft Visu"...
.text$mn:000038E5                 mov     eax, [ebp+Str]
.text$mn:000038E8                 push    eax             ; int
.text$mn:000038E9                 call    ??$_Debug_pointer@D@std@@YAXPBDPB_WI@Z ; std::_Debug_pointer<char>(char const *,wchar_t const *,uint)
.text$mn:000038EE                 add     esp, 0Ch
.text$mn:000038F1                 mov     ecx, [ebp+Str]
.text$mn:000038F4                 push    ecx             ; Str
.text$mn:000038F5                 call    ?length@?$char_traits@D@std@@SAIPBD@Z ; std::char_traits<char>::length(char const *)
.text$mn:000038FA                 add     esp, 4
.text$mn:000038FD                 push    eax             ; Size
.text$mn:000038FE                 mov     edx, [ebp+Str]
.text$mn:00003901                 push    edx             ; Src
.text$mn:00003902                 mov     ecx, [ebp+var_4]
.text$mn:00003905                 call    ?assign@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV12@PBDI@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char>>::assign(char const *,uint)
.text$mn:0000390A                 mov     esp, ebp
.text$mn:0000390C                 pop     ebp
.text$mn:0000390D                 retn    4
.text$mn:0000390D ?assign@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV12@PBD@Z endp
.text$mn:0000390D
.text$mn:0000390D _text$mn        ends
.text$mn:0000390D
.text$mn:00003910 ; ===========================================================================
.text$mn:00003910
.text$mn:00003910 ; Segment type: Pure code
.text$mn:00003910 ; Segment permissions: Read/Execute
.text$mn:00003910 _text$mn        segment para public 'CODE' use32
.text$mn:00003910                 assume cs:_text$mn
.text$mn:00003910                 ;org 3910h
.text$mn:00003910 ; COMDAT (pick any)
.text$mn:00003910                 assume es:nothing, ss:nothing, ds:_data, fs:nothing, gs:nothing
.text$mn:00003910
.text$mn:00003910 ; =============== S U B R O U T I N E =======================================
.text$mn:00003910
.text$mn:00003910 ; Attributes: bp-based frame
.text$mn:00003910
.text$mn:00003910 ; int __stdcall std::basic_string<char,std::char_traits<char>,std::allocator<char>>::assign(void *Src, size_t Size)
.text$mn:00003910                 public ?assign@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV12@PBDI@Z
.text$mn:00003910 ?assign@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV12@PBDI@Z proc near
.text$mn:00003910                                         ; CODE XREF: std::basic_string<char,std::char_traits<char>,std::allocator<char>>::assign(char const *)+31p
.text$mn:00003910
.text$mn:00003910 var_4           = dword ptr -4
.text$mn:00003910 Src             = dword ptr  8
.text$mn:00003910 Size            = dword ptr  0Ch
.text$mn:00003910
.text$mn:00003910                 push    ebp
.text$mn:00003911                 mov     ebp, esp
.text$mn:00003913                 push    ecx
.text$mn:00003914                 mov     [ebp+var_4], ecx
.text$mn:00003917                 cmp     [ebp+Size], 0
.text$mn:0000391B                 jz      short loc_3933
.text$mn:0000391D                 push    47Fh            ; unsigned int
.text$mn:00003922                 push    offset ??_C@_1IO@FEAPGJBD@?$AAC?$AA?3?$AA?2?$AAP?$AAr?$AAo?$AAg?$AAr?$AAa?$AAm?$AA?5?$AAF?$AAi?$AAl?$AAe?$AAs?$AA?5?$AA?$CI?$AAx?$AA8?$AA6?$AA?$CJ?$AA?2?$AAM?$AAi?$AAc?$AAr?$AAo?$AAs?$AAo?$AAf?$AAt@ ; "C:\\Program Files (x86)\\Microsoft Visu"...
.text$mn:00003927                 mov     eax, [ebp+Src]
.text$mn:0000392A                 push    eax             ; int
.text$mn:0000392B                 call    ??$_Debug_pointer@D@std@@YAXPBDPB_WI@Z ; std::_Debug_pointer<char>(char const *,wchar_t const *,uint)
.text$mn:00003930                 add     esp, 0Ch
.text$mn:00003933
.text$mn:00003933 loc_3933:                               ; CODE XREF: std::basic_string<char,std::char_traits<char>,std::allocator<char>>::assign(char const *,uint)+Bj
.text$mn:00003933                 mov     ecx, [ebp+Src]
.text$mn:00003936                 push    ecx
.text$mn:00003937                 mov     ecx, [ebp+var_4]
.text$mn:0000393A                 call    ?_Inside@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE_NPBD@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char>>::_Inside(char const *)
.text$mn:0000393F                 movzx   edx, al
.text$mn:00003942                 test    edx, edx
.text$mn:00003944                 jz      short loc_3966
.text$mn:00003946                 mov     eax, [ebp+Size]
.text$mn:00003949                 push    eax
.text$mn:0000394A                 mov     ecx, [ebp+var_4]
.text$mn:0000394D                 call    ?_Myptr@?$_String_val@U?$_Simple_types@D@std@@@std@@QAEPADXZ ; std::_String_val<std::_Simple_types<char>>::_Myptr(void)
.text$mn:00003952                 mov     ecx, [ebp+Src]
.text$mn:00003955                 sub     ecx, eax
.text$mn:00003957                 push    ecx
.text$mn:00003958                 mov     edx, [ebp+var_4]
.text$mn:0000395B                 push    edx
.text$mn:0000395C                 mov     ecx, [ebp+var_4]
.text$mn:0000395F                 call    ?assign@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV12@ABV12@II@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char>>::assign(std::basic_string<char,std::char_traits<char>,std::allocator<char>> const &,uint,uint)
.text$mn:00003964                 jmp     short loc_39A3
.text$mn:00003966 ; ---------------------------------------------------------------------------
.text$mn:00003966
.text$mn:00003966 loc_3966:                               ; CODE XREF: std::basic_string<char,std::char_traits<char>,std::allocator<char>>::assign(char const *,uint)+34j
.text$mn:00003966                 push    0
.text$mn:00003968                 mov     eax, [ebp+Size]
.text$mn:0000396B                 push    eax
.text$mn:0000396C                 mov     ecx, [ebp+var_4]
.text$mn:0000396F                 call    ?_Grow@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE_NI_N@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char>>::_Grow(uint,bool)
.text$mn:00003974                 movzx   ecx, al
.text$mn:00003977                 test    ecx, ecx
.text$mn:00003979                 jz      short loc_39A0
.text$mn:0000397B                 mov     edx, [ebp+Size]
.text$mn:0000397E                 push    edx             ; Size
.text$mn:0000397F                 mov     eax, [ebp+Src]
.text$mn:00003982                 push    eax             ; Src
.text$mn:00003983                 mov     ecx, [ebp+var_4]
.text$mn:00003986                 call    ?_Myptr@?$_String_val@U?$_Simple_types@D@std@@@std@@QAEPADXZ ; std::_String_val<std::_Simple_types<char>>::_Myptr(void)
.text$mn:0000398B                 push    eax             ; Dst
.text$mn:0000398C                 call    ?copy@?$char_traits@D@std@@SAPADPADPBDI@Z ; std::char_traits<char>::copy(char *,char const *,uint)
.text$mn:00003991                 add     esp, 0Ch
.text$mn:00003994                 mov     ecx, [ebp+Size]
.text$mn:00003997                 push    ecx
.text$mn:00003998                 mov     ecx, [ebp+var_4]
.text$mn:0000399B                 call    ?_Eos@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEXI@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char>>::_Eos(uint)
.text$mn:000039A0
.text$mn:000039A0 loc_39A0:                               ; CODE XREF: std::basic_string<char,std::char_traits<char>,std::allocator<char>>::assign(char const *,uint)+69j
.text$mn:000039A0                 mov     eax, [ebp+var_4]
.text$mn:000039A3
.text$mn:000039A3 loc_39A3:                               ; CODE XREF: std::basic_string<char,std::char_traits<char>,std::allocator<char>>::assign(char const *,uint)+54j
.text$mn:000039A3                 mov     esp, ebp
.text$mn:000039A5                 pop     ebp
.text$mn:000039A6                 retn    8
.text$mn:000039A6 ?assign@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV12@PBDI@Z endp
.text$mn:000039A6
.text$mn:000039A6 ; ---------------------------------------------------------------------------
.text$mn:000039A9                 align 4
.text$mn:000039A9 _text$mn        ends
.text$mn:000039A9
.text$mn:000039AC ; ===========================================================================
.text$mn:000039AC
.text$mn:000039AC ; Segment type: Pure code
.text$mn:000039AC ; Segment permissions: Read/Execute
.text$mn:000039AC _text$mn        segment para public 'CODE' use32
.text$mn:000039AC                 assume cs:_text$mn
.text$mn:000039AC                 ;org 39ACh
.text$mn:000039AC ; COMDAT (pick any)
.text$mn:000039AC                 assume es:nothing, ss:nothing, ds:_data, fs:nothing, gs:nothing
.text$mn:000039AC
.text$mn:000039AC ; =============== S U B R O U T I N E =======================================
.text$mn:000039AC
.text$mn:000039AC ; Attributes: bp-based frame
.text$mn:000039AC
.text$mn:000039AC ; public: static void __cdecl std::char_traits<char>::assign(char &, char const &)
.text$mn:000039AC                 public ?assign@?$char_traits@D@std@@SAXAADABD@Z
.text$mn:000039AC ?assign@?$char_traits@D@std@@SAXAADABD@Z proc near
.text$mn:000039AC                                         ; CODE XREF: std::basic_string<char,std::char_traits<char>,std::allocator<char>>::_Eos(uint)+26p
.text$mn:000039AC
.text$mn:000039AC arg_0           = dword ptr  8
.text$mn:000039AC arg_4           = dword ptr  0Ch
.text$mn:000039AC
.text$mn:000039AC                 push    ebp
.text$mn:000039AD                 mov     ebp, esp
.text$mn:000039AF                 mov     eax, [ebp+arg_0]
.text$mn:000039B2                 mov     ecx, [ebp+arg_4]
.text$mn:000039B5                 mov     dl, [ecx]
.text$mn:000039B7                 mov     [eax], dl
.text$mn:000039B9                 pop     ebp
.text$mn:000039BA                 retn
.text$mn:000039BA ?assign@?$char_traits@D@std@@SAXAADABD@Z endp
.text$mn:000039BA
.text$mn:000039BA ; ---------------------------------------------------------------------------
.text$mn:000039BB                 align 4
.text$mn:000039BB _text$mn        ends
.text$mn:000039BB
.text$mn:000039BC ; ===========================================================================
.text$mn:000039BC
.text$mn:000039BC ; Segment type: Pure code
.text$mn:000039BC ; Segment permissions: Read/Execute
.text$mn:000039BC _text$mn        segment para public 'CODE' use32
.text$mn:000039BC                 assume cs:_text$mn
.text$mn:000039BC                 ;org 39BCh
.text$mn:000039BC ; COMDAT (pick any)
.text$mn:000039BC                 assume es:nothing, ss:nothing, ds:_data, fs:nothing, gs:nothing
.text$mn:000039BC
.text$mn:000039BC ; =============== S U B R O U T I N E =======================================
.text$mn:000039BC
.text$mn:000039BC ; Attributes: bp-based frame
.text$mn:000039BC
.text$mn:000039BC ; const struct std::error_category *__thiscall std::error_code::category(std::error_code *__hidden this)
.text$mn:000039BC                 public ?category@error_code@std@@QBEABVerror_category@2@XZ
.text$mn:000039BC ?category@error_code@std@@QBEABVerror_category@2@XZ proc near
.text$mn:000039BC                                         ; CODE XREF: std::error_category::equivalent(std::error_code const &,int)+Cp
.text$mn:000039BC
.text$mn:000039BC var_4           = dword ptr -4
.text$mn:000039BC
.text$mn:000039BC                 push    ebp
.text$mn:000039BD                 mov     ebp, esp
.text$mn:000039BF                 push    ecx
.text$mn:000039C0                 mov     [ebp+var_4], ecx
.text$mn:000039C3                 mov     eax, [ebp+var_4]
.text$mn:000039C6                 mov     eax, [eax+4]
.text$mn:000039C9                 mov     esp, ebp
.text$mn:000039CB                 pop     ebp
.text$mn:000039CC                 retn
.text$mn:000039CC ?category@error_code@std@@QBEABVerror_category@2@XZ endp
.text$mn:000039CC
.text$mn:000039CC ; ---------------------------------------------------------------------------
.text$mn:000039CD                 align 10h
.text$mn:000039CD _text$mn        ends
.text$mn:000039CD
.text$mn:000039D0 ; ===========================================================================
.text$mn:000039D0
.text$mn:000039D0 ; Segment type: Pure code
.text$mn:000039D0 ; Segment permissions: Read/Execute
.text$mn:000039D0 _text$mn        segment para public 'CODE' use32
.text$mn:000039D0                 assume cs:_text$mn
.text$mn:000039D0                 ;org 39D0h
.text$mn:000039D0 ; COMDAT (pick any)
.text$mn:000039D0                 assume es:nothing, ss:nothing, ds:_data, fs:nothing, gs:nothing
.text$mn:000039D0
.text$mn:000039D0 ; =============== S U B R O U T I N E =======================================
.text$mn:000039D0
.text$mn:000039D0 ; Attributes: bp-based frame
.text$mn:000039D0
.text$mn:000039D0 ; const struct std::error_category *__thiscall std::error_condition::category(std::error_condition *__hidden this)
.text$mn:000039D0                 public ?category@error_condition@std@@QBEABVerror_category@2@XZ
.text$mn:000039D0 ?category@error_condition@std@@QBEABVerror_category@2@XZ proc near
.text$mn:000039D0                                         ; CODE XREF: std::error_condition::operator==(std::error_condition const &)+Dp
.text$mn:000039D0                                         ; std::error_condition::operator==(std::error_condition const &)+16p
.text$mn:000039D0
.text$mn:000039D0 var_4           = dword ptr -4
.text$mn:000039D0
.text$mn:000039D0                 push    ebp
.text$mn:000039D1                 mov     ebp, esp
.text$mn:000039D3                 push    ecx
.text$mn:000039D4                 mov     [ebp+var_4], ecx
.text$mn:000039D7                 mov     eax, [ebp+var_4]
.text$mn:000039DA                 mov     eax, [eax+4]
.text$mn:000039DD                 mov     esp, ebp
.text$mn:000039DF                 pop     ebp
.text$mn:000039E0                 retn
.text$mn:000039E0 ?category@error_condition@std@@QBEABVerror_category@2@XZ endp
.text$mn:000039E0
.text$mn:000039E0 ; ---------------------------------------------------------------------------
.text$mn:000039E1                 align 4
.text$mn:000039E1 _text$mn        ends
.text$mn:000039E1
.text$mn:000039E4 ; ===========================================================================
.text$mn:000039E4
.text$mn:000039E4 ; Segment type: Pure code
.text$mn:000039E4 ; Segment permissions: Read/Execute
.text$mn:000039E4 _text$mn        segment para public 'CODE' use32
.text$mn:000039E4                 assume cs:_text$mn
.text$mn:000039E4                 ;org 39E4h
.text$mn:000039E4 ; COMDAT (pick any)
.text$mn:000039E4                 assume es:nothing, ss:nothing, ds:_data, fs:nothing, gs:nothing
.text$mn:000039E4
.text$mn:000039E4 ; =============== S U B R O U T I N E =======================================
.text$mn:000039E4
.text$mn:000039E4 ; Attributes: bp-based frame
.text$mn:000039E4
.text$mn:000039E4 ; int __cdecl std::char_traits<char>::copy(void *Dst, void *Src, size_t Size)
.text$mn:000039E4                 public ?copy@?$char_traits@D@std@@SAPADPADPBDI@Z
.text$mn:000039E4 ?copy@?$char_traits@D@std@@SAPADPADPBDI@Z proc near ; CODE XREF: $LN19+1Ep
.text$mn:000039E4                                         ; std::basic_string<char,std::char_traits<char>,std::allocator<char>>::_Tidy(bool,uint)+5Dp ...
.text$mn:000039E4
.text$mn:000039E4 var_4           = dword ptr -4
.text$mn:000039E4 Dst             = dword ptr  8
.text$mn:000039E4 Src             = dword ptr  0Ch
.text$mn:000039E4 Size            = dword ptr  10h
.text$mn:000039E4
.text$mn:000039E4                 push    ebp
.text$mn:000039E5                 mov     ebp, esp
.text$mn:000039E7                 push    ecx
.text$mn:000039E8                 cmp     [ebp+Size], 0
.text$mn:000039EC                 jnz     short loc_39F6
.text$mn:000039EE                 mov     eax, [ebp+Dst]
.text$mn:000039F1                 mov     [ebp+var_4], eax
.text$mn:000039F4                 jmp     short loc_3A0D
.text$mn:000039F6 ; ---------------------------------------------------------------------------
.text$mn:000039F6
.text$mn:000039F6 loc_39F6:                               ; CODE XREF: std::char_traits<char>::copy(char *,char const *,uint)+8j
.text$mn:000039F6                 mov     ecx, [ebp+Size]
.text$mn:000039F9                 push    ecx             ; Size
.text$mn:000039FA                 mov     edx, [ebp+Src]
.text$mn:000039FD                 push    edx             ; Src
.text$mn:000039FE                 mov     eax, [ebp+Dst]
.text$mn:00003A01                 push    eax             ; Dst
.text$mn:00003A02                 call    _memcpy
.text$mn:00003A07                 add     esp, 0Ch
.text$mn:00003A0A                 mov     [ebp+var_4], eax
.text$mn:00003A0D
.text$mn:00003A0D loc_3A0D:                               ; CODE XREF: std::char_traits<char>::copy(char *,char const *,uint)+10j
.text$mn:00003A0D                 mov     eax, [ebp+var_4]
.text$mn:00003A10                 mov     esp, ebp
.text$mn:00003A12                 pop     ebp
.text$mn:00003A13                 retn
.text$mn:00003A13 ?copy@?$char_traits@D@std@@SAPADPADPBDI@Z endp
.text$mn:00003A13
.text$mn:00003A13 _text$mn        ends
.text$mn:00003A13
.text$mn:00003A14 ; ===========================================================================
.text$mn:00003A14
.text$mn:00003A14 ; Segment type: Pure code
.text$mn:00003A14 ; Segment permissions: Read/Execute
.text$mn:00003A14 _text$mn        segment para public 'CODE' use32
.text$mn:00003A14                 assume cs:_text$mn
.text$mn:00003A14                 ;org 3A14h
.text$mn:00003A14 ; COMDAT (pick any)
.text$mn:00003A14                 assume es:nothing, ss:nothing, ds:_data, fs:nothing, gs:nothing
.text$mn:00003A14
.text$mn:00003A14 ; =============== S U B R O U T I N E =======================================
.text$mn:00003A14
.text$mn:00003A14 ; Attributes: bp-based frame
.text$mn:00003A14
.text$mn:00003A14 ; int __stdcall std::_Wrap_alloc<std::allocator<char>>::deallocate(void *, int)
.text$mn:00003A14                 public ?deallocate@?$_Wrap_alloc@V?$allocator@D@std@@@std@@QAEXPADI@Z
.text$mn:00003A14 ?deallocate@?$_Wrap_alloc@V?$allocator@D@std@@@std@@QAEXPADI@Z proc near
.text$mn:00003A14                                         ; CODE XREF: std::basic_string<char,std::char_traits<char>,std::allocator<char>>::_Tidy(bool,uint)+81p
.text$mn:00003A14
.text$mn:00003A14 var_4           = dword ptr -4
.text$mn:00003A14 arg_0           = dword ptr  8
.text$mn:00003A14 arg_4           = dword ptr  0Ch
.text$mn:00003A14
.text$mn:00003A14                 push    ebp
.text$mn:00003A15                 mov     ebp, esp
.text$mn:00003A17                 push    ecx
.text$mn:00003A18                 mov     [ebp+var_4], ecx
.text$mn:00003A1B                 mov     eax, [ebp+arg_4]
.text$mn:00003A1E                 push    eax             ; int
.text$mn:00003A1F                 mov     ecx, [ebp+arg_0]
.text$mn:00003A22                 push    ecx             ; void *
.text$mn:00003A23                 mov     ecx, [ebp+var_4]
.text$mn:00003A26                 call    ?deallocate@?$allocator@D@std@@QAEXPADI@Z ; std::allocator<char>::deallocate(char *,uint)
.text$mn:00003A2B                 mov     esp, ebp
.text$mn:00003A2D                 pop     ebp
.text$mn:00003A2E                 retn    8
.text$mn:00003A2E ?deallocate@?$_Wrap_alloc@V?$allocator@D@std@@@std@@QAEXPADI@Z endp
.text$mn:00003A2E
.text$mn:00003A2E ; ---------------------------------------------------------------------------
.text$mn:00003A31                 align 4
.text$mn:00003A31 _text$mn        ends
.text$mn:00003A31
.text$mn:00003A34 ; ===========================================================================
.text$mn:00003A34
.text$mn:00003A34 ; Segment type: Pure code
.text$mn:00003A34 ; Segment permissions: Read/Execute
.text$mn:00003A34 _text$mn        segment para public 'CODE' use32
.text$mn:00003A34                 assume cs:_text$mn
.text$mn:00003A34                 ;org 3A34h
.text$mn:00003A34 ; COMDAT (pick any)
.text$mn:00003A34                 assume es:nothing, ss:nothing, ds:_data, fs:nothing, gs:nothing
.text$mn:00003A34
.text$mn:00003A34 ; =============== S U B R O U T I N E =======================================
.text$mn:00003A34
.text$mn:00003A34 ; Attributes: bp-based frame
.text$mn:00003A34
.text$mn:00003A34 ; int __stdcall std::_Wrap_alloc<std::allocator<unsigned int>>::deallocate(void *, int)
.text$mn:00003A34                 public ?deallocate@?$_Wrap_alloc@V?$allocator@I@std@@@std@@QAEXPAII@Z
.text$mn:00003A34 ?deallocate@?$_Wrap_alloc@V?$allocator@I@std@@@std@@QAEXPAII@Z proc near
.text$mn:00003A34                                         ; CODE XREF: std::vector<uint,std::allocator<uint>>::_Tidy(void)+55p
.text$mn:00003A34
.text$mn:00003A34 var_4           = dword ptr -4
.text$mn:00003A34 arg_0           = dword ptr  8
.text$mn:00003A34 arg_4           = dword ptr  0Ch
.text$mn:00003A34
.text$mn:00003A34                 push    ebp
.text$mn:00003A35                 mov     ebp, esp
.text$mn:00003A37                 push    ecx
.text$mn:00003A38                 mov     [ebp+var_4], ecx
.text$mn:00003A3B                 mov     eax, [ebp+arg_4]
.text$mn:00003A3E                 push    eax             ; int
.text$mn:00003A3F                 mov     ecx, [ebp+arg_0]
.text$mn:00003A42                 push    ecx             ; void *
.text$mn:00003A43                 mov     ecx, [ebp+var_4]
.text$mn:00003A46                 call    ?deallocate@?$allocator@I@std@@QAEXPAII@Z ; std::allocator<uint>::deallocate(uint *,uint)
.text$mn:00003A4B                 mov     esp, ebp
.text$mn:00003A4D                 pop     ebp
.text$mn:00003A4E                 retn    8
.text$mn:00003A4E ?deallocate@?$_Wrap_alloc@V?$allocator@I@std@@@std@@QAEXPAII@Z endp
.text$mn:00003A4E
.text$mn:00003A4E ; ---------------------------------------------------------------------------
.text$mn:00003A51                 align 4
.text$mn:00003A51 _text$mn        ends
.text$mn:00003A51
.text$mn:00003A54 ; ===========================================================================
.text$mn:00003A54
.text$mn:00003A54 ; Segment type: Pure code
.text$mn:00003A54 ; Segment permissions: Read/Execute
.text$mn:00003A54 _text$mn        segment para public 'CODE' use32
.text$mn:00003A54                 assume cs:_text$mn
.text$mn:00003A54                 ;org 3A54h
.text$mn:00003A54 ; COMDAT (pick any)
.text$mn:00003A54                 assume es:nothing, ss:nothing, ds:_data, fs:nothing, gs:nothing
.text$mn:00003A54
.text$mn:00003A54 ; =============== S U B R O U T I N E =======================================
.text$mn:00003A54
.text$mn:00003A54 ; Attributes: bp-based frame
.text$mn:00003A54
.text$mn:00003A54 ; int __stdcall std::_Wrap_alloc<std::allocator<std::_Container_proxy>>::deallocate(void *, int)
.text$mn:00003A54                 public ?deallocate@?$_Wrap_alloc@V?$allocator@U_Container_proxy@std@@@std@@@std@@QAEXPAU_Container_proxy@2@I@Z
.text$mn:00003A54 ?deallocate@?$_Wrap_alloc@V?$allocator@U_Container_proxy@std@@@std@@@std@@QAEXPAU_Container_proxy@2@I@Z proc near
.text$mn:00003A54                                         ; CODE XREF: std::_Vector_alloc<0,std::_Vec_base_types<uint,std::allocator<uint>>>::_Free_proxy(void)+32p
.text$mn:00003A54
.text$mn:00003A54 var_4           = dword ptr -4
.text$mn:00003A54 arg_0           = dword ptr  8
.text$mn:00003A54 arg_4           = dword ptr  0Ch
.text$mn:00003A54
.text$mn:00003A54                 push    ebp
.text$mn:00003A55                 mov     ebp, esp
.text$mn:00003A57                 push    ecx
.text$mn:00003A58                 mov     [ebp+var_4], ecx
.text$mn:00003A5B                 mov     eax, [ebp+arg_4]
.text$mn:00003A5E                 push    eax             ; int
.text$mn:00003A5F                 mov     ecx, [ebp+arg_0]
.text$mn:00003A62                 push    ecx             ; void *
.text$mn:00003A63                 mov     ecx, [ebp+var_4]
.text$mn:00003A66                 call    ?deallocate@?$allocator@U_Container_proxy@std@@@std@@QAEXPAU_Container_proxy@2@I@Z ; std::allocator<std::_Container_proxy>::deallocate(std::_Container_proxy *,uint)
.text$mn:00003A6B                 mov     esp, ebp
.text$mn:00003A6D                 pop     ebp
.text$mn:00003A6E                 retn    8
.text$mn:00003A6E ?deallocate@?$_Wrap_alloc@V?$allocator@U_Container_proxy@std@@@std@@@std@@QAEXPAU_Container_proxy@2@I@Z endp
.text$mn:00003A6E
.text$mn:00003A6E ; ---------------------------------------------------------------------------
.text$mn:00003A71                 align 4
.text$mn:00003A71 _text$mn        ends
.text$mn:00003A71
.text$mn:00003A74 ; ===========================================================================
.text$mn:00003A74
.text$mn:00003A74 ; Segment type: Pure code
.text$mn:00003A74 ; Segment permissions: Read/Execute
.text$mn:00003A74 _text$mn        segment para public 'CODE' use32
.text$mn:00003A74                 assume cs:_text$mn
.text$mn:00003A74                 ;org 3A74h
.text$mn:00003A74 ; COMDAT (pick any)
.text$mn:00003A74                 assume es:nothing, ss:nothing, ds:_data, fs:nothing, gs:nothing
.text$mn:00003A74
.text$mn:00003A74 ; =============== S U B R O U T I N E =======================================
.text$mn:00003A74
.text$mn:00003A74 ; Attributes: bp-based frame
.text$mn:00003A74
.text$mn:00003A74 ; int __stdcall std::allocator<char>::deallocate(void *, int)
.text$mn:00003A74                 public ?deallocate@?$allocator@D@std@@QAEXPADI@Z
.text$mn:00003A74 ?deallocate@?$allocator@D@std@@QAEXPADI@Z proc near
.text$mn:00003A74                                         ; CODE XREF: std::_Wrap_alloc<std::allocator<char>>::deallocate(char *,uint)+12p
.text$mn:00003A74
.text$mn:00003A74 var_4           = dword ptr -4
.text$mn:00003A74 arg_0           = dword ptr  8
.text$mn:00003A74
.text$mn:00003A74                 push    ebp
.text$mn:00003A75                 mov     ebp, esp
.text$mn:00003A77                 push    ecx
.text$mn:00003A78                 mov     [ebp+var_4], ecx
.text$mn:00003A7B                 mov     eax, [ebp+arg_0]
.text$mn:00003A7E                 push    eax             ; void *
.text$mn:00003A7F                 call    ??3@YAXPAX@Z    ; operator delete(void *)
.text$mn:00003A84                 add     esp, 4
.text$mn:00003A87                 mov     esp, ebp
.text$mn:00003A89                 pop     ebp
.text$mn:00003A8A                 retn    8
.text$mn:00003A8A ?deallocate@?$allocator@D@std@@QAEXPADI@Z endp
.text$mn:00003A8A
.text$mn:00003A8A ; ---------------------------------------------------------------------------
.text$mn:00003A8D                 align 10h
.text$mn:00003A8D _text$mn        ends
.text$mn:00003A8D
.text$mn:00003A90 ; ===========================================================================
.text$mn:00003A90
.text$mn:00003A90 ; Segment type: Pure code
.text$mn:00003A90 ; Segment permissions: Read/Execute
.text$mn:00003A90 _text$mn        segment para public 'CODE' use32
.text$mn:00003A90                 assume cs:_text$mn
.text$mn:00003A90                 ;org 3A90h
.text$mn:00003A90 ; COMDAT (pick any)
.text$mn:00003A90                 assume es:nothing, ss:nothing, ds:_data, fs:nothing, gs:nothing
.text$mn:00003A90
.text$mn:00003A90 ; =============== S U B R O U T I N E =======================================
.text$mn:00003A90
.text$mn:00003A90 ; Attributes: bp-based frame
.text$mn:00003A90
.text$mn:00003A90 ; int __stdcall std::allocator<unsigned int>::deallocate(void *, int)
.text$mn:00003A90                 public ?deallocate@?$allocator@I@std@@QAEXPAII@Z
.text$mn:00003A90 ?deallocate@?$allocator@I@std@@QAEXPAII@Z proc near
.text$mn:00003A90                                         ; CODE XREF: std::_Wrap_alloc<std::allocator<uint>>::deallocate(uint *,uint)+12p
.text$mn:00003A90
.text$mn:00003A90 var_4           = dword ptr -4
.text$mn:00003A90 arg_0           = dword ptr  8
.text$mn:00003A90
.text$mn:00003A90                 push    ebp
.text$mn:00003A91                 mov     ebp, esp
.text$mn:00003A93                 push    ecx
.text$mn:00003A94                 mov     [ebp+var_4], ecx
.text$mn:00003A97                 mov     eax, [ebp+arg_0]
.text$mn:00003A9A                 push    eax             ; void *
.text$mn:00003A9B                 call    ??3@YAXPAX@Z    ; operator delete(void *)
.text$mn:00003AA0                 add     esp, 4
.text$mn:00003AA3                 mov     esp, ebp
.text$mn:00003AA5                 pop     ebp
.text$mn:00003AA6                 retn    8
.text$mn:00003AA6 ?deallocate@?$allocator@I@std@@QAEXPAII@Z endp
.text$mn:00003AA6
.text$mn:00003AA6 ; ---------------------------------------------------------------------------
.text$mn:00003AA9                 align 4
.text$mn:00003AA9 _text$mn        ends
.text$mn:00003AA9
.text$mn:00003AAC ; ===========================================================================
.text$mn:00003AAC
.text$mn:00003AAC ; Segment type: Pure code
.text$mn:00003AAC ; Segment permissions: Read/Execute
.text$mn:00003AAC _text$mn        segment para public 'CODE' use32
.text$mn:00003AAC                 assume cs:_text$mn
.text$mn:00003AAC                 ;org 3AACh
.text$mn:00003AAC ; COMDAT (pick any)
.text$mn:00003AAC                 assume es:nothing, ss:nothing, ds:_data, fs:nothing, gs:nothing
.text$mn:00003AAC
.text$mn:00003AAC ; =============== S U B R O U T I N E =======================================
.text$mn:00003AAC
.text$mn:00003AAC ; Attributes: bp-based frame
.text$mn:00003AAC
.text$mn:00003AAC ; int __stdcall std::allocator<std::_Container_proxy>::deallocate(void *, int)
.text$mn:00003AAC                 public ?deallocate@?$allocator@U_Container_proxy@std@@@std@@QAEXPAU_Container_proxy@2@I@Z
.text$mn:00003AAC ?deallocate@?$allocator@U_Container_proxy@std@@@std@@QAEXPAU_Container_proxy@2@I@Z proc near
.text$mn:00003AAC                                         ; CODE XREF: std::_String_alloc<0,std::_String_base_types<char,std::allocator<char>>>::_Free_proxy(void)+32p
.text$mn:00003AAC                                         ; std::_Wrap_alloc<std::allocator<std::_Container_proxy>>::deallocate(std::_Container_proxy *,uint)+12p
.text$mn:00003AAC
.text$mn:00003AAC var_4           = dword ptr -4
.text$mn:00003AAC arg_0           = dword ptr  8
.text$mn:00003AAC
.text$mn:00003AAC                 push    ebp
.text$mn:00003AAD                 mov     ebp, esp
.text$mn:00003AAF                 push    ecx
.text$mn:00003AB0                 mov     [ebp+var_4], ecx
.text$mn:00003AB3                 mov     eax, [ebp+arg_0]
.text$mn:00003AB6                 push    eax             ; void *
.text$mn:00003AB7                 call    ??3@YAXPAX@Z    ; operator delete(void *)
.text$mn:00003ABC                 add     esp, 4
.text$mn:00003ABF                 mov     esp, ebp
.text$mn:00003AC1                 pop     ebp
.text$mn:00003AC2                 retn    8
.text$mn:00003AC2 ?deallocate@?$allocator@U_Container_proxy@std@@@std@@QAEXPAU_Container_proxy@2@I@Z endp
.text$mn:00003AC2
.text$mn:00003AC2 ; ---------------------------------------------------------------------------
.text$mn:00003AC5                 align 4
.text$mn:00003AC5 _text$mn        ends
.text$mn:00003AC5
.text$mn:00003AC8 ; ===========================================================================
.text$mn:00003AC8
.text$mn:00003AC8 ; Segment type: Pure code
.text$mn:00003AC8 ; Segment permissions: Read/Execute
.text$mn:00003AC8 _text$mn        segment para public 'CODE' use32
.text$mn:00003AC8                 assume cs:_text$mn
.text$mn:00003AC8                 ;org 3AC8h
.text$mn:00003AC8 ; COMDAT (pick any)
.text$mn:00003AC8                 assume es:nothing, ss:nothing, ds:_data, fs:nothing, gs:nothing
.text$mn:00003AC8
.text$mn:00003AC8 ; =============== S U B R O U T I N E =======================================
.text$mn:00003AC8
.text$mn:00003AC8 ; Attributes: bp-based frame
.text$mn:00003AC8
.text$mn:00003AC8 ; public: virtual class std::error_condition __thiscall std::_System_error_category::default_error_condition(int)const
.text$mn:00003AC8                 public ?default_error_condition@_System_error_category@std@@UBE?AVerror_condition@2@H@Z
.text$mn:00003AC8 ?default_error_condition@_System_error_category@std@@UBE?AVerror_condition@2@H@Z proc near
.text$mn:00003AC8                                         ; DATA XREF: .rdata:0000488Co
.text$mn:00003AC8
.text$mn:00003AC8 var_4           = dword ptr -4
.text$mn:00003AC8 arg_0           = dword ptr  8
.text$mn:00003AC8 arg_4           = dword ptr  0Ch
.text$mn:00003AC8
.text$mn:00003AC8                 push    ebp
.text$mn:00003AC9                 mov     ebp, esp
.text$mn:00003ACB                 push    ecx
.text$mn:00003ACC                 mov     [ebp+var_4], ecx
.text$mn:00003ACF                 mov     eax, [ebp+arg_4]
.text$mn:00003AD2                 push    eax             ; int
.text$mn:00003AD3                 call    ?_Syserror_map@std@@YAPBDH@Z ; std::_Syserror_map(int)
.text$mn:00003AD8                 add     esp, 4
.text$mn:00003ADB                 test    eax, eax
.text$mn:00003ADD                 jz      short loc_3AF8
.text$mn:00003ADF                 call    ?generic_category@std@@YAABVerror_category@1@XZ ; std::generic_category(void)
.text$mn:00003AE4                 push    eax             ; struct std::error_category *
.text$mn:00003AE5                 mov     ecx, [ebp+arg_4]
.text$mn:00003AE8                 push    ecx             ; int
.text$mn:00003AE9                 mov     ecx, [ebp+arg_0] ; this
.text$mn:00003AEC                 call    ??0error_condition@std@@QAE@HABVerror_category@1@@Z ; std::error_condition::error_condition(int,std::error_category const &)
.text$mn:00003AF1                 mov     eax, [ebp+arg_0]
.text$mn:00003AF4                 jmp     short loc_3B0D
.text$mn:00003AF6 ; ---------------------------------------------------------------------------
.text$mn:00003AF6                 jmp     short loc_3B0D
.text$mn:00003AF8 ; ---------------------------------------------------------------------------
.text$mn:00003AF8
.text$mn:00003AF8 loc_3AF8:                               ; CODE XREF: std::_System_error_category::default_error_condition(int)+15j
.text$mn:00003AF8                 call    ?system_category@std@@YAABVerror_category@1@XZ ; std::system_category(void)
.text$mn:00003AFD                 push    eax             ; struct std::error_category *
.text$mn:00003AFE                 mov     edx, [ebp+arg_4]
.text$mn:00003B01                 push    edx             ; int
.text$mn:00003B02                 mov     ecx, [ebp+arg_0] ; this
.text$mn:00003B05                 call    ??0error_condition@std@@QAE@HABVerror_category@1@@Z ; std::error_condition::error_condition(int,std::error_category const &)
.text$mn:00003B0A                 mov     eax, [ebp+arg_0]
.text$mn:00003B0D
.text$mn:00003B0D loc_3B0D:                               ; CODE XREF: std::_System_error_category::default_error_condition(int)+2Cj
.text$mn:00003B0D                                         ; std::_System_error_category::default_error_condition(int)+2Ej
.text$mn:00003B0D                 mov     esp, ebp
.text$mn:00003B0F                 pop     ebp
.text$mn:00003B10                 retn    8
.text$mn:00003B10 ?default_error_condition@_System_error_category@std@@UBE?AVerror_condition@2@H@Z endp
.text$mn:00003B10
.text$mn:00003B10 ; ---------------------------------------------------------------------------
.text$mn:00003B13                 align 4
.text$mn:00003B13 _text$mn        ends
.text$mn:00003B13
.text$mn:00003B14 ; ===========================================================================
.text$mn:00003B14
.text$mn:00003B14 ; Segment type: Pure code
.text$mn:00003B14 ; Segment permissions: Read/Execute
.text$mn:00003B14 _text$mn        segment para public 'CODE' use32
.text$mn:00003B14                 assume cs:_text$mn
.text$mn:00003B14                 ;org 3B14h
.text$mn:00003B14 ; COMDAT (pick any)
.text$mn:00003B14                 assume es:nothing, ss:nothing, ds:_data, fs:nothing, gs:nothing
.text$mn:00003B14
.text$mn:00003B14 ; =============== S U B R O U T I N E =======================================
.text$mn:00003B14
.text$mn:00003B14 ; Attributes: bp-based frame
.text$mn:00003B14
.text$mn:00003B14 ; public: virtual class std::error_condition __thiscall std::error_category::default_error_condition(int)const
.text$mn:00003B14                 public ?default_error_condition@error_category@std@@UBE?AVerror_condition@2@H@Z
.text$mn:00003B14 ?default_error_condition@error_category@std@@UBE?AVerror_condition@2@H@Z proc near
.text$mn:00003B14                                         ; DATA XREF: .rdata:000047FCo
.text$mn:00003B14                                         ; .rdata:00004818o ...
.text$mn:00003B14
.text$mn:00003B14 var_4           = dword ptr -4
.text$mn:00003B14 arg_0           = dword ptr  8
.text$mn:00003B14 arg_4           = dword ptr  0Ch
.text$mn:00003B14
.text$mn:00003B14                 push    ebp
.text$mn:00003B15                 mov     ebp, esp
.text$mn:00003B17                 push    ecx
.text$mn:00003B18                 mov     [ebp+var_4], ecx
.text$mn:00003B1B                 mov     eax, [ebp+var_4]
.text$mn:00003B1E                 push    eax             ; struct std::error_category *
.text$mn:00003B1F                 mov     ecx, [ebp+arg_4]
.text$mn:00003B22                 push    ecx             ; int
.text$mn:00003B23                 mov     ecx, [ebp+arg_0] ; this
.text$mn:00003B26                 call    ??0error_condition@std@@QAE@HABVerror_category@1@@Z ; std::error_condition::error_condition(int,std::error_category const &)
.text$mn:00003B2B                 mov     eax, [ebp+arg_0]
.text$mn:00003B2E                 mov     esp, ebp
.text$mn:00003B30                 pop     ebp
.text$mn:00003B31                 retn    8
.text$mn:00003B31 ?default_error_condition@error_category@std@@UBE?AVerror_condition@2@H@Z endp
.text$mn:00003B31
.text$mn:00003B31 _text$mn        ends
.text$mn:00003B31
.text$mn:00003B34 ; ===========================================================================
.text$mn:00003B34
.text$mn:00003B34 ; Segment type: Pure code
.text$mn:00003B34 ; Segment permissions: Read/Execute
.text$mn:00003B34 _text$mn        segment para public 'CODE' use32
.text$mn:00003B34                 assume cs:_text$mn
.text$mn:00003B34                 ;org 3B34h
.text$mn:00003B34 ; COMDAT (pick any)
.text$mn:00003B34                 assume es:nothing, ss:nothing, ds:_data, fs:nothing, gs:nothing
.text$mn:00003B34
.text$mn:00003B34 ; =============== S U B R O U T I N E =======================================
.text$mn:00003B34
.text$mn:00003B34 ; Attributes: bp-based frame
.text$mn:00003B34
.text$mn:00003B34 ; void __thiscall ViewZoneDlg::drawZone(ViewZoneDlg *this, __int32, __int32)
.text$mn:00003B34                 public ?drawZone@ViewZoneDlg@@QAEXJJ@Z
.text$mn:00003B34 ?drawZone@ViewZoneDlg@@QAEXJJ@Z proc near
.text$mn:00003B34                                         ; CODE XREF: DocumentMap::scrollMap(void)+24Bp
.text$mn:00003B34
.text$mn:00003B34 var_4           = dword ptr -4
.text$mn:00003B34 arg_0           = dword ptr  8
.text$mn:00003B34 arg_4           = dword ptr  0Ch
.text$mn:00003B34
.text$mn:00003B34                 push    ebp
.text$mn:00003B35                 mov     ebp, esp
.text$mn:00003B37                 push    ecx
.text$mn:00003B38                 mov     [ebp+var_4], ecx
.text$mn:00003B3B                 mov     eax, [ebp+var_4]
.text$mn:00003B3E                 mov     ecx, [ebp+arg_0]
.text$mn:00003B41                 mov     [eax+28h], ecx
.text$mn:00003B44                 mov     edx, [ebp+var_4]
.text$mn:00003B47                 mov     eax, [ebp+arg_4]
.text$mn:00003B4A                 mov     [edx+2Ch], eax
.text$mn:00003B4D                 mov     ecx, [ebp+var_4]
.text$mn:00003B50                 cmp     dword ptr [ecx+20h], 0
.text$mn:00003B54                 jz      short loc_3B67
.text$mn:00003B56                 push    1               ; bErase
.text$mn:00003B58                 push    0               ; lpRect
.text$mn:00003B5A                 mov     edx, [ebp+var_4]
.text$mn:00003B5D                 mov     eax, [edx+20h]
.text$mn:00003B60                 push    eax             ; hWnd
.text$mn:00003B61                 call    dword ptr ds:__imp__InvalidateRect@12 ; InvalidateRect(x,x,x)
.text$mn:00003B67
.text$mn:00003B67 loc_3B67:                               ; CODE XREF: ViewZoneDlg::drawZone(long,long)+20j
.text$mn:00003B67                 mov     esp, ebp
.text$mn:00003B69                 pop     ebp
.text$mn:00003B6A                 retn    8
.text$mn:00003B6A ?drawZone@ViewZoneDlg@@QAEXJJ@Z endp
.text$mn:00003B6A
.text$mn:00003B6A ; ---------------------------------------------------------------------------
.text$mn:00003B6D                 align 10h
.text$mn:00003B6D _text$mn        ends
.text$mn:00003B6D
.text$mn:00003B70 ; ===========================================================================
.text$mn:00003B70
.text$mn:00003B70 ; Segment type: Pure code
.text$mn:00003B70 ; Segment permissions: Read/Execute
.text$mn:00003B70 _text$mn        segment para public 'CODE' use32
.text$mn:00003B70                 assume cs:_text$mn
.text$mn:00003B70                 ;org 3B70h
.text$mn:00003B70 ; COMDAT (pick any)
.text$mn:00003B70                 assume es:nothing, ss:nothing, ds:_data, fs:nothing, gs:nothing
.text$mn:00003B70
.text$mn:00003B70 ; =============== S U B R O U T I N E =======================================
.text$mn:00003B70
.text$mn:00003B70 ; Attributes: bp-based frame
.text$mn:00003B70
.text$mn:00003B70 ; bool __thiscall std::error_category::equivalent(std::error_category *this, const struct std::error_code *, int)
.text$mn:00003B70                 public ?equivalent@error_category@std@@UBE_NABVerror_code@2@H@Z
.text$mn:00003B70 ?equivalent@error_category@std@@UBE_NABVerror_code@2@H@Z proc near
.text$mn:00003B70                                         ; DATA XREF: .rdata:00004800o
.text$mn:00003B70                                         ; .rdata:0000481Co ...
.text$mn:00003B70
.text$mn:00003B70 var_8           = dword ptr -8
.text$mn:00003B70 var_4           = dword ptr -4
.text$mn:00003B70 arg_0           = dword ptr  8
.text$mn:00003B70 arg_4           = dword ptr  0Ch
.text$mn:00003B70
.text$mn:00003B70                 push    ebp
.text$mn:00003B71                 mov     ebp, esp
.text$mn:00003B73                 sub     esp, 8
.text$mn:00003B76                 mov     [ebp+var_8], ecx
.text$mn:00003B79                 mov     ecx, [ebp+arg_0] ; this
.text$mn:00003B7C                 call    ?category@error_code@std@@QBEABVerror_category@2@XZ ; std::error_code::category(void)
.text$mn:00003B81                 push    eax
.text$mn:00003B82                 mov     ecx, [ebp+var_8]
.text$mn:00003B85                 call    ??8error_category@std@@QBE_NABV01@@Z ; std::error_category::operator==(std::error_category const &)
.text$mn:00003B8A                 movzx   eax, al
.text$mn:00003B8D                 test    eax, eax
.text$mn:00003B8F                 jz      short loc_3BA7
.text$mn:00003B91                 mov     ecx, [ebp+arg_0] ; this
.text$mn:00003B94                 call    ?value@error_code@std@@QBEHXZ ; std::error_code::value(void)
.text$mn:00003B99                 cmp     eax, [ebp+arg_4]
.text$mn:00003B9C                 jnz     short loc_3BA7
.text$mn:00003B9E                 mov     [ebp+var_4], 1
.text$mn:00003BA5                 jmp     short loc_3BAE
.text$mn:00003BA7 ; ---------------------------------------------------------------------------
.text$mn:00003BA7
.text$mn:00003BA7 loc_3BA7:                               ; CODE XREF: std::error_category::equivalent(std::error_code const &,int)+1Fj
.text$mn:00003BA7                                         ; std::error_category::equivalent(std::error_code const &,int)+2Cj
.text$mn:00003BA7                 mov     [ebp+var_4], 0
.text$mn:00003BAE
.text$mn:00003BAE loc_3BAE:                               ; CODE XREF: std::error_category::equivalent(std::error_code const &,int)+35j
.text$mn:00003BAE                 mov     al, byte ptr [ebp+var_4]
.text$mn:00003BB1                 mov     esp, ebp
.text$mn:00003BB3                 pop     ebp
.text$mn:00003BB4                 retn    8
.text$mn:00003BB4 ?equivalent@error_category@std@@UBE_NABVerror_code@2@H@Z endp
.text$mn:00003BB4
.text$mn:00003BB4 ; ---------------------------------------------------------------------------
.text$mn:00003BB7                 align 4
.text$mn:00003BB7 _text$mn        ends
.text$mn:00003BB7
.text$mn:00003BB8 ; ===========================================================================
.text$mn:00003BB8
.text$mn:00003BB8 ; Segment type: Pure code
.text$mn:00003BB8 ; Segment permissions: Read/Execute
.text$mn:00003BB8 _text$mn        segment para public 'CODE' use32
.text$mn:00003BB8                 assume cs:_text$mn
.text$mn:00003BB8                 ;org 3BB8h
.text$mn:00003BB8 ; COMDAT (pick any)
.text$mn:00003BB8                 assume es:nothing, ss:nothing, ds:_data, fs:nothing, gs:nothing
.text$mn:00003BB8
.text$mn:00003BB8 ; =============== S U B R O U T I N E =======================================
.text$mn:00003BB8
.text$mn:00003BB8 ; Attributes: bp-based frame
.text$mn:00003BB8
.text$mn:00003BB8 ; bool __thiscall std::error_category::equivalent(std::error_category *this, int, const struct std::error_condition *)
.text$mn:00003BB8                 public ?equivalent@error_category@std@@UBE_NHABVerror_condition@2@@Z
.text$mn:00003BB8 ?equivalent@error_category@std@@UBE_NHABVerror_condition@2@@Z proc near
.text$mn:00003BB8                                         ; DATA XREF: .rdata:00004804o
.text$mn:00003BB8                                         ; .rdata:00004820o ...
.text$mn:00003BB8
.text$mn:00003BB8 var_C           = byte ptr -0Ch
.text$mn:00003BB8 var_4           = dword ptr -4
.text$mn:00003BB8 arg_0           = dword ptr  8
.text$mn:00003BB8 arg_4           = dword ptr  0Ch
.text$mn:00003BB8
.text$mn:00003BB8                 push    ebp
.text$mn:00003BB9                 mov     ebp, esp
.text$mn:00003BBB                 sub     esp, 0Ch
.text$mn:00003BBE                 mov     [ebp+var_4], ecx
.text$mn:00003BC1                 mov     eax, [ebp+arg_4]
.text$mn:00003BC4                 push    eax             ; std::error_condition *
.text$mn:00003BC5                 mov     ecx, [ebp+arg_0]
.text$mn:00003BC8                 push    ecx
.text$mn:00003BC9                 lea     edx, [ebp+var_C]
.text$mn:00003BCC                 push    edx
.text$mn:00003BCD                 mov     eax, [ebp+var_4]
.text$mn:00003BD0                 mov     edx, [eax]
.text$mn:00003BD2                 mov     ecx, [ebp+var_4]
.text$mn:00003BD5                 mov     eax, [edx+0Ch]
.text$mn:00003BD8                 call    eax
.text$mn:00003BDA                 mov     ecx, eax
.text$mn:00003BDC                 call    ??8error_condition@std@@QBE_NABV01@@Z ; std::error_condition::operator==(std::error_condition const &)
.text$mn:00003BE1                 mov     esp, ebp
.text$mn:00003BE3                 pop     ebp
.text$mn:00003BE4                 retn    8
.text$mn:00003BE4 ?equivalent@error_category@std@@UBE_NHABVerror_condition@2@@Z endp
.text$mn:00003BE4
.text$mn:00003BE4 ; ---------------------------------------------------------------------------
.text$mn:00003BE7                 align 4
.text$mn:00003BE7 _text$mn        ends
.text$mn:00003BE7
.text$mn:00003BE8 ; ===========================================================================
.text$mn:00003BE8
.text$mn:00003BE8 ; Segment type: Pure code
.text$mn:00003BE8 ; Segment permissions: Read/Execute
.text$mn:00003BE8 _text$mn        segment para public 'CODE' use32
.text$mn:00003BE8                 assume cs:_text$mn
.text$mn:00003BE8                 ;org 3BE8h
.text$mn:00003BE8 ; COMDAT (pick any)
.text$mn:00003BE8                 assume es:nothing, ss:nothing, ds:_data, fs:nothing, gs:nothing
.text$mn:00003BE8
.text$mn:00003BE8 ; =============== S U B R O U T I N E =======================================
.text$mn:00003BE8
.text$mn:00003BE8 ; Attributes: bp-based frame
.text$mn:00003BE8
.text$mn:00003BE8 ; public: class std::basic_string<char, struct std::char_traits<char>, class std::allocator<char>> & __thiscall std::basic_string<char, struct std::char_traits<char>, class std::allocator<char>>::erase(unsigned int)
.text$mn:00003BE8                 public ?erase@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV12@I@Z
.text$mn:00003BE8 ?erase@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV12@I@Z proc near
.text$mn:00003BE8                                         ; CODE XREF: std::basic_string<char,std::char_traits<char>,std::allocator<char>>::assign(std::basic_string<char,std::char_traits<char>,std::allocator<char>> const &,uint,uint)+4Cp
.text$mn:00003BE8
.text$mn:00003BE8 var_4           = dword ptr -4
.text$mn:00003BE8 arg_0           = dword ptr  8
.text$mn:00003BE8
.text$mn:00003BE8                 push    ebp
.text$mn:00003BE9                 mov     ebp, esp
.text$mn:00003BEB                 push    ecx
.text$mn:00003BEC                 mov     [ebp+var_4], ecx
.text$mn:00003BEF                 mov     eax, [ebp+var_4]
.text$mn:00003BF2                 mov     ecx, [eax+14h]
.text$mn:00003BF5                 cmp     ecx, [ebp+arg_0]
.text$mn:00003BF8                 jnb     short loc_3C02
.text$mn:00003BFA                 mov     ecx, [ebp+var_4]
.text$mn:00003BFD                 call    ?_Xran@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QBEXXZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char>>::_Xran(void)
.text$mn:00003C02
.text$mn:00003C02 loc_3C02:                               ; CODE XREF: std::basic_string<char,std::char_traits<char>,std::allocator<char>>::erase(uint)+10j
.text$mn:00003C02                 mov     edx, [ebp+arg_0]
.text$mn:00003C05                 push    edx
.text$mn:00003C06                 mov     ecx, [ebp+var_4]
.text$mn:00003C09                 call    ?_Eos@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEXI@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char>>::_Eos(uint)
.text$mn:00003C0E                 mov     eax, [ebp+var_4]
.text$mn:00003C11                 mov     esp, ebp
.text$mn:00003C13                 pop     ebp
.text$mn:00003C14                 retn    4
.text$mn:00003C14 ?erase@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV12@I@Z endp
.text$mn:00003C14
.text$mn:00003C14 ; ---------------------------------------------------------------------------
.text$mn:00003C17                 align 4
.text$mn:00003C17 _text$mn        ends
.text$mn:00003C17
.text$mn:00003C18 ; ===========================================================================
.text$mn:00003C18
.text$mn:00003C18 ; Segment type: Pure code
.text$mn:00003C18 ; Segment permissions: Read/Execute
.text$mn:00003C18 _text$mn        segment para public 'CODE' use32
.text$mn:00003C18                 assume cs:_text$mn
.text$mn:00003C18                 ;org 3C18h
.text$mn:00003C18 ; COMDAT (pick any)
.text$mn:00003C18                 assume es:nothing, ss:nothing, ds:_data, fs:nothing, gs:nothing
.text$mn:00003C18
.text$mn:00003C18 ; =============== S U B R O U T I N E =======================================
.text$mn:00003C18
.text$mn:00003C18 ; Attributes: bp-based frame
.text$mn:00003C18
.text$mn:00003C18 ; public: class std::basic_string<char, struct std::char_traits<char>, class std::allocator<char>> & __thiscall std::basic_string<char, struct std::char_traits<char>, class std::allocator<char>>::erase(unsigned int, unsigned int)
.text$mn:00003C18                 public ?erase@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV12@II@Z
.text$mn:00003C18 ?erase@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV12@II@Z proc near
.text$mn:00003C18                                         ; CODE XREF: std::basic_string<char,std::char_traits<char>,std::allocator<char>>::assign(std::basic_string<char,std::char_traits<char>,std::allocator<char>> const &,uint,uint)+5Ap
.text$mn:00003C18
.text$mn:00003C18 var_C           = dword ptr -0Ch
.text$mn:00003C18 Dst             = dword ptr -8
.text$mn:00003C18 var_4           = dword ptr -4
.text$mn:00003C18 arg_0           = dword ptr  8
.text$mn:00003C18 arg_4           = dword ptr  0Ch
.text$mn:00003C18
.text$mn:00003C18                 push    ebp
.text$mn:00003C19                 mov     ebp, esp
.text$mn:00003C1B                 sub     esp, 0Ch
.text$mn:00003C1E                 mov     [ebp+var_4], ecx
.text$mn:00003C21                 mov     eax, [ebp+var_4]
.text$mn:00003C24                 mov     ecx, [eax+14h]
.text$mn:00003C27                 cmp     ecx, [ebp+arg_0]
.text$mn:00003C2A                 jnb     short loc_3C34
.text$mn:00003C2C                 mov     ecx, [ebp+var_4]
.text$mn:00003C2F                 call    ?_Xran@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QBEXXZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char>>::_Xran(void)
.text$mn:00003C34
.text$mn:00003C34 loc_3C34:                               ; CODE XREF: std::basic_string<char,std::char_traits<char>,std::allocator<char>>::erase(uint,uint)+12j
.text$mn:00003C34                 mov     edx, [ebp+var_4]
.text$mn:00003C37                 mov     eax, [edx+14h]
.text$mn:00003C3A                 sub     eax, [ebp+arg_0]
.text$mn:00003C3D                 cmp     eax, [ebp+arg_4]
.text$mn:00003C40                 ja      short loc_3C50
.text$mn:00003C42                 mov     ecx, [ebp+arg_0]
.text$mn:00003C45                 push    ecx
.text$mn:00003C46                 mov     ecx, [ebp+var_4]
.text$mn:00003C49                 call    ?_Eos@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEXI@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char>>::_Eos(uint)
.text$mn:00003C4E                 jmp     short loc_3C96
.text$mn:00003C50 ; ---------------------------------------------------------------------------
.text$mn:00003C50
.text$mn:00003C50 loc_3C50:                               ; CODE XREF: std::basic_string<char,std::char_traits<char>,std::allocator<char>>::erase(uint,uint)+28j
.text$mn:00003C50                 cmp     [ebp+arg_4], 0
.text$mn:00003C54                 jbe     short loc_3C96
.text$mn:00003C56                 mov     ecx, [ebp+var_4]
.text$mn:00003C59                 call    ?_Myptr@?$_String_val@U?$_Simple_types@D@std@@@std@@QAEPADXZ ; std::_String_val<std::_Simple_types<char>>::_Myptr(void)
.text$mn:00003C5E                 add     eax, [ebp+arg_0]
.text$mn:00003C61                 mov     [ebp+Dst], eax
.text$mn:00003C64                 mov     edx, [ebp+var_4]
.text$mn:00003C67                 mov     eax, [edx+14h]
.text$mn:00003C6A                 sub     eax, [ebp+arg_4]
.text$mn:00003C6D                 mov     [ebp+var_C], eax
.text$mn:00003C70                 mov     ecx, [ebp+var_C]
.text$mn:00003C73                 sub     ecx, [ebp+arg_0]
.text$mn:00003C76                 push    ecx             ; Size
.text$mn:00003C77                 mov     edx, [ebp+Dst]
.text$mn:00003C7A                 add     edx, [ebp+arg_4]
.text$mn:00003C7D                 push    edx             ; Src
.text$mn:00003C7E                 mov     eax, [ebp+Dst]
.text$mn:00003C81                 push    eax             ; Dst
.text$mn:00003C82                 call    ?move@?$char_traits@D@std@@SAPADPADPBDI@Z ; std::char_traits<char>::move(char *,char const *,uint)
.text$mn:00003C87                 add     esp, 0Ch
.text$mn:00003C8A                 mov     ecx, [ebp+var_C]
.text$mn:00003C8D                 push    ecx
.text$mn:00003C8E                 mov     ecx, [ebp+var_4]
.text$mn:00003C91                 call    ?_Eos@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEXI@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char>>::_Eos(uint)
.text$mn:00003C96
.text$mn:00003C96 loc_3C96:                               ; CODE XREF: std::basic_string<char,std::char_traits<char>,std::allocator<char>>::erase(uint,uint)+36j
.text$mn:00003C96                                         ; std::basic_string<char,std::char_traits<char>,std::allocator<char>>::erase(uint,uint)+3Cj
.text$mn:00003C96                 mov     eax, [ebp+var_4]
.text$mn:00003C99                 mov     esp, ebp
.text$mn:00003C9B                 pop     ebp
.text$mn:00003C9C                 retn    8
.text$mn:00003C9C ?erase@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV12@II@Z endp
.text$mn:00003C9C
.text$mn:00003C9C ; ---------------------------------------------------------------------------
.text$mn:00003C9F                 align 10h
.text$mn:00003C9F _text$mn        ends
.text$mn:00003C9F
.text$mn:00003CA0 ; ===========================================================================
.text$mn:00003CA0
.text$mn:00003CA0 ; Segment type: Pure code
.text$mn:00003CA0 ; Segment permissions: Read/Execute
.text$mn:00003CA0 _text$mn        segment para public 'CODE' use32
.text$mn:00003CA0                 assume cs:_text$mn
.text$mn:00003CA0                 ;org 3CA0h
.text$mn:00003CA0 ; COMDAT (pick any)
.text$mn:00003CA0                 assume es:nothing, ss:nothing, ds:_data, fs:nothing, gs:nothing
.text$mn:00003CA0
.text$mn:00003CA0 ; =============== S U B R O U T I N E =======================================
.text$mn:00003CA0
.text$mn:00003CA0 ; Attributes: bp-based frame
.text$mn:00003CA0
.text$mn:00003CA0 ; __int32 __thiscall ScintillaEditView::execute(ScintillaEditView *this, unsigned int, unsigned int, __int32)
.text$mn:00003CA0                 public ?execute@ScintillaEditView@@QBEJIIJ@Z
.text$mn:00003CA0 ?execute@ScintillaEditView@@QBEJIIJ@Z proc near
.text$mn:00003CA0                                         ; CODE XREF: DocumentMap::redraw(bool)+16p
.text$mn:00003CA0                                         ; DocumentMap::reloadMap(void)+53p ...
.text$mn:00003CA0
.text$mn:00003CA0 var_4           = dword ptr -4
.text$mn:00003CA0 arg_0           = dword ptr  8
.text$mn:00003CA0 arg_4           = dword ptr  0Ch
.text$mn:00003CA0 arg_8           = dword ptr  10h
.text$mn:00003CA0
.text$mn:00003CA0                 push    ebp
.text$mn:00003CA1                 mov     ebp, esp
.text$mn:00003CA3                 push    ecx
.text$mn:00003CA4                 mov     [ebp+var_4], ecx
.text$mn:00003CA7                 mov     eax, [ebp+arg_8]
.text$mn:00003CAA                 push    eax
.text$mn:00003CAB                 mov     ecx, [ebp+arg_4]
.text$mn:00003CAE                 push    ecx
.text$mn:00003CAF                 mov     edx, [ebp+arg_0]
.text$mn:00003CB2                 push    edx
.text$mn:00003CB3                 mov     eax, [ebp+var_4]
.text$mn:00003CB6                 mov     ecx, [eax+14h]
.text$mn:00003CB9                 push    ecx
.text$mn:00003CBA                 mov     edx, [ebp+var_4]
.text$mn:00003CBD                 mov     eax, [edx+10h]
.text$mn:00003CC0                 call    eax
.text$mn:00003CC2                 add     esp, 10h
.text$mn:00003CC5                 mov     esp, ebp
.text$mn:00003CC7                 pop     ebp
.text$mn:00003CC8                 retn    0Ch
.text$mn:00003CC8 ?execute@ScintillaEditView@@QBEJIIJ@Z endp
.text$mn:00003CC8
.text$mn:00003CC8 ; ---------------------------------------------------------------------------
.text$mn:00003CCB                 align 4
.text$mn:00003CCB _text$mn        ends
.text$mn:00003CCB
.text$mn:00003CCC ; ===========================================================================
.text$mn:00003CCC
.text$mn:00003CCC ; Segment type: Pure code
.text$mn:00003CCC ; Segment permissions: Read/Execute
.text$mn:00003CCC _text$mn        segment para public 'CODE' use32
.text$mn:00003CCC                 assume cs:_text$mn
.text$mn:00003CCC                 ;org 3CCCh
.text$mn:00003CCC ; COMDAT (pick any)
.text$mn:00003CCC                 assume es:nothing, ss:nothing, ds:_data, fs:nothing, gs:nothing
.text$mn:00003CCC
.text$mn:00003CCC ; =============== S U B R O U T I N E =======================================
.text$mn:00003CCC
.text$mn:00003CCC ; Attributes: bp-based frame
.text$mn:00003CCC
.text$mn:00003CCC ; const struct std::error_category *__cdecl std::generic_category()
.text$mn:00003CCC                 public ?generic_category@std@@YAABVerror_category@1@XZ
.text$mn:00003CCC ?generic_category@std@@YAABVerror_category@1@XZ proc near
.text$mn:00003CCC                                         ; CODE XREF: std::_System_error_category::default_error_condition(int)+17p
.text$mn:00003CCC                 push    ebp
.text$mn:00003CCD                 mov     ebp, esp
.text$mn:00003CCF                 mov     eax, offset ?_Generic_object@?$_Error_objects@H@std@@2V_Generic_error_category@2@A ; std::_Generic_error_category std::_Error_objects<int>::_Generic_object
.text$mn:00003CD4                 pop     ebp
.text$mn:00003CD5                 retn
.text$mn:00003CD5 ?generic_category@std@@YAABVerror_category@1@XZ endp
.text$mn:00003CD5
.text$mn:00003CD5 ; ---------------------------------------------------------------------------
.text$mn:00003CD6                 align 4
.text$mn:00003CD6 _text$mn        ends
.text$mn:00003CD6
.text$mn:00003CD8 ; ===========================================================================
.text$mn:00003CD8
.text$mn:00003CD8 ; Segment type: Pure code
.text$mn:00003CD8 ; Segment permissions: Read/Execute
.text$mn:00003CD8 _text$mn        segment para public 'CODE' use32
.text$mn:00003CD8                 assume cs:_text$mn
.text$mn:00003CD8                 ;org 3CD8h
.text$mn:00003CD8 ; COMDAT (pick any)
.text$mn:00003CD8                 assume es:nothing, ss:nothing, ds:_data, fs:nothing, gs:nothing
.text$mn:00003CD8
.text$mn:00003CD8 ; =============== S U B R O U T I N E =======================================
.text$mn:00003CD8
.text$mn:00003CD8 ; Attributes: bp-based frame
.text$mn:00003CD8
.text$mn:00003CD8 ; struct Buffer *__thiscall ScintillaEditView::getCurrentBuffer(ScintillaEditView *__hidden this)
.text$mn:00003CD8                 public ?getCurrentBuffer@ScintillaEditView@@QAEPAVBuffer@@XZ
.text$mn:00003CD8 ?getCurrentBuffer@ScintillaEditView@@QAEPAVBuffer@@XZ proc near
.text$mn:00003CD8                                         ; CODE XREF: DocumentMap::reloadMap(void)+79p
.text$mn:00003CD8                                         ; DocumentMap::setSyntaxHiliting(void)+Fp
.text$mn:00003CD8
.text$mn:00003CD8 var_4           = dword ptr -4
.text$mn:00003CD8
.text$mn:00003CD8                 push    ebp
.text$mn:00003CD9                 mov     ebp, esp
.text$mn:00003CDB                 push    ecx
.text$mn:00003CDC                 mov     [ebp+var_4], ecx
.text$mn:00003CDF                 mov     eax, [ebp+var_4]
.text$mn:00003CE2                 mov     eax, [eax+20h]
.text$mn:00003CE5                 mov     esp, ebp
.text$mn:00003CE7                 pop     ebp
.text$mn:00003CE8                 retn
.text$mn:00003CE8 ?getCurrentBuffer@ScintillaEditView@@QAEPAVBuffer@@XZ endp
.text$mn:00003CE8
.text$mn:00003CE8 ; ---------------------------------------------------------------------------
.text$mn:00003CE9                 align 4
.text$mn:00003CE9 _text$mn        ends
.text$mn:00003CE9
.text$mn:00003CEC ; ===========================================================================
.text$mn:00003CEC
.text$mn:00003CEC ; Segment type: Pure code
.text$mn:00003CEC ; Segment permissions: Read/Execute
.text$mn:00003CEC _text$mn        segment para public 'CODE' use32
.text$mn:00003CEC                 assume cs:_text$mn
.text$mn:00003CEC                 ;org 3CECh
.text$mn:00003CEC ; COMDAT (pick any)
.text$mn:00003CEC                 assume es:nothing, ss:nothing, ds:_data, fs:nothing, gs:nothing
.text$mn:00003CEC
.text$mn:00003CEC ; =============== S U B R O U T I N E =======================================
.text$mn:00003CEC
.text$mn:00003CEC ; Attributes: bp-based frame
.text$mn:00003CEC
.text$mn:00003CEC ; int __thiscall ViewZoneDlg::getCurrentCenterPosY(ViewZoneDlg *__hidden this)
.text$mn:00003CEC                 public ?getCurrentCenterPosY@ViewZoneDlg@@QBEHXZ
.text$mn:00003CEC ?getCurrentCenterPosY@ViewZoneDlg@@QBEHXZ proc near
.text$mn:00003CEC                                         ; CODE XREF: DocumentMap::run_dlgProc(uint,uint,long)+410p
.text$mn:00003CEC
.text$mn:00003CEC var_4           = dword ptr -4
.text$mn:00003CEC
.text$mn:00003CEC                 push    ebp
.text$mn:00003CED                 mov     ebp, esp
.text$mn:00003CEF                 push    ecx
.text$mn:00003CF0                 mov     [ebp+var_4], ecx
.text$mn:00003CF3                 mov     eax, [ebp+var_4]
.text$mn:00003CF6                 mov     ecx, [ebp+var_4]
.text$mn:00003CF9                 mov     eax, [eax+2Ch]
.text$mn:00003CFC                 sub     eax, [ecx+28h]
.text$mn:00003CFF                 cdq
.text$mn:00003D00                 sub     eax, edx
.text$mn:00003D02                 sar     eax, 1
.text$mn:00003D04                 mov     edx, [ebp+var_4]
.text$mn:00003D07                 add     eax, [edx+28h]
.text$mn:00003D0A                 mov     esp, ebp
.text$mn:00003D0C                 pop     ebp
.text$mn:00003D0D                 retn
.text$mn:00003D0D ?getCurrentCenterPosY@ViewZoneDlg@@QBEHXZ endp
.text$mn:00003D0D
.text$mn:00003D0D ; ---------------------------------------------------------------------------
.text$mn:00003D0E                 align 10h
.text$mn:00003D0E _text$mn        ends
.text$mn:00003D0E
.text$mn:00003D10 ; ===========================================================================
.text$mn:00003D10
.text$mn:00003D10 ; Segment type: Pure code
.text$mn:00003D10 ; Segment permissions: Read/Execute
.text$mn:00003D10 _text$mn        segment para public 'CODE' use32
.text$mn:00003D10                 assume cs:_text$mn
.text$mn:00003D10                 ;org 3D10h
.text$mn:00003D10 ; COMDAT (pick any)
.text$mn:00003D10                 assume es:nothing, ss:nothing, ds:_data, fs:nothing, gs:nothing
.text$mn:00003D10
.text$mn:00003D10 ; =============== S U B R O U T I N E =======================================
.text$mn:00003D10
.text$mn:00003D10 ; Attributes: bp-based frame
.text$mn:00003D10
.text$mn:00003D10 ; HWND __thiscall Window::getHSelf(Window *__hidden this)
.text$mn:00003D10                 public ?getHSelf@Window@@QBEPAUHWND__@@XZ
.text$mn:00003D10 ?getHSelf@Window@@QBEPAUHWND__@@XZ proc near
.text$mn:00003D10                                         ; CODE XREF: DocumentMap::wrapMap(void)+B1p
.text$mn:00003D10                                         ; DocumentMap::initWrapMap(void)+58p ...
.text$mn:00003D10
.text$mn:00003D10 var_4           = dword ptr -4
.text$mn:00003D10
.text$mn:00003D10                 push    ebp
.text$mn:00003D11                 mov     ebp, esp
.text$mn:00003D13                 push    ecx
.text$mn:00003D14                 mov     [ebp+var_4], ecx
.text$mn:00003D17                 mov     eax, [ebp+var_4]
.text$mn:00003D1A                 mov     eax, [eax+0Ch]
.text$mn:00003D1D                 mov     esp, ebp
.text$mn:00003D1F                 pop     ebp
.text$mn:00003D20                 retn
.text$mn:00003D20 ?getHSelf@Window@@QBEPAUHWND__@@XZ endp
.text$mn:00003D20
.text$mn:00003D20 ; ---------------------------------------------------------------------------
.text$mn:00003D21                 align 4
.text$mn:00003D21 _text$mn        ends
.text$mn:00003D21
.text$mn:00003D24 ; ===========================================================================
.text$mn:00003D24
.text$mn:00003D24 ; Segment type: Pure code
.text$mn:00003D24 ; Segment permissions: Read/Execute
.text$mn:00003D24 _text$mn        segment para public 'CODE' use32
.text$mn:00003D24                 assume cs:_text$mn
.text$mn:00003D24                 ;org 3D24h
.text$mn:00003D24 ; COMDAT (pick any)
.text$mn:00003D24                 assume es:nothing, ss:nothing, ds:_data, fs:nothing, gs:nothing
.text$mn:00003D24
.text$mn:00003D24 ; =============== S U B R O U T I N E =======================================
.text$mn:00003D24
.text$mn:00003D24 ; Attributes: bp-based frame
.text$mn:00003D24
.text$mn:00003D24 ; struct NppParameters *__cdecl NppParameters::getInstance()
.text$mn:00003D24                 public ?getInstance@NppParameters@@SAPAV1@XZ
.text$mn:00003D24 ?getInstance@NppParameters@@SAPAV1@XZ proc near
.text$mn:00003D24                                         ; CODE XREF: DocumentMap::run_dlgProc(uint,uint,long)+149p
.text$mn:00003D24                 push    ebp
.text$mn:00003D25                 mov     ebp, esp
.text$mn:00003D27                 mov     eax, dword ptr ds:?_pSelf@NppParameters@@0PAV1@A ; NppParameters * NppParameters::_pSelf
.text$mn:00003D2C                 pop     ebp
.text$mn:00003D2D                 retn
.text$mn:00003D2D ?getInstance@NppParameters@@SAPAV1@XZ endp
.text$mn:00003D2D
.text$mn:00003D2D ; ---------------------------------------------------------------------------
.text$mn:00003D2E                 align 10h
.text$mn:00003D2E _text$mn        ends
.text$mn:00003D2E
.text$mn:00003D30 ; ===========================================================================
.text$mn:00003D30
.text$mn:00003D30 ; Segment type: Pure code
.text$mn:00003D30 ; Segment permissions: Read/Execute
.text$mn:00003D30 _text$mn        segment para public 'CODE' use32
.text$mn:00003D30                 assume cs:_text$mn
.text$mn:00003D30                 ;org 3D30h
.text$mn:00003D30 ; COMDAT (pick any)
.text$mn:00003D30                 assume es:nothing, ss:nothing, ds:_data, fs:nothing, gs:nothing
.text$mn:00003D30
.text$mn:00003D30 ; =============== S U B R O U T I N E =======================================
.text$mn:00003D30
.text$mn:00003D30 ; Attributes: bp-based frame
.text$mn:00003D30
.text$mn:00003D30 ; public: enum  LangType __thiscall Buffer::getLangType(void)const
.text$mn:00003D30                 public ?getLangType@Buffer@@QBE?AW4LangType@@XZ
.text$mn:00003D30 ?getLangType@Buffer@@QBE?AW4LangType@@XZ proc near
.text$mn:00003D30                                         ; CODE XREF: DocumentMap::setSyntaxHiliting(void)+1Ap
.text$mn:00003D30
.text$mn:00003D30 var_4           = dword ptr -4
.text$mn:00003D30
.text$mn:00003D30                 push    ebp
.text$mn:00003D31                 mov     ebp, esp
.text$mn:00003D33                 push    ecx
.text$mn:00003D34                 mov     [ebp+var_4], ecx
.text$mn:00003D37                 mov     eax, [ebp+var_4]
.text$mn:00003D3A                 mov     eax, [eax+14h]
.text$mn:00003D3D                 mov     esp, ebp
.text$mn:00003D3F                 pop     ebp
.text$mn:00003D40                 retn
.text$mn:00003D40 ?getLangType@Buffer@@QBE?AW4LangType@@XZ endp
.text$mn:00003D40
.text$mn:00003D40 ; ---------------------------------------------------------------------------
.text$mn:00003D41                 align 4
.text$mn:00003D41 _text$mn        ends
.text$mn:00003D41
.text$mn:00003D44 ; ===========================================================================
.text$mn:00003D44
.text$mn:00003D44 ; Segment type: Pure code
.text$mn:00003D44 ; Segment permissions: Read/Execute
.text$mn:00003D44 _text$mn        segment para public 'CODE' use32
.text$mn:00003D44                 assume cs:_text$mn
.text$mn:00003D44                 ;org 3D44h
.text$mn:00003D44 ; COMDAT (pick any)
.text$mn:00003D44                 assume es:nothing, ss:nothing, ds:_data, fs:nothing, gs:nothing
.text$mn:00003D44
.text$mn:00003D44 ; =============== S U B R O U T I N E =======================================
.text$mn:00003D44
.text$mn:00003D44 ; Attributes: bp-based frame
.text$mn:00003D44
.text$mn:00003D44 ; bool __thiscall ScintillaEditView::isWrap(ScintillaEditView *__hidden this)
.text$mn:00003D44                 public ?isWrap@ScintillaEditView@@QBE_NXZ
.text$mn:00003D44 ?isWrap@ScintillaEditView@@QBE_NXZ proc near
.text$mn:00003D44                                         ; CODE XREF: DocumentMap::reloadMap(void)+C7p
.text$mn:00003D44                                         ; DocumentMap::wrapMap(void)+2Cp ...
.text$mn:00003D44
.text$mn:00003D44 var_8           = dword ptr -8
.text$mn:00003D44 var_4           = dword ptr -4
.text$mn:00003D44
.text$mn:00003D44                 push    ebp
.text$mn:00003D45                 mov     ebp, esp
.text$mn:00003D47                 sub     esp, 8
.text$mn:00003D4A                 mov     [ebp+var_8], ecx
.text$mn:00003D4D                 push    0               ; __int32
.text$mn:00003D4F                 push    0               ; unsigned int
.text$mn:00003D51                 push    8DDh            ; unsigned int
.text$mn:00003D56                 mov     ecx, [ebp+var_8] ; this
.text$mn:00003D59                 call    ?execute@ScintillaEditView@@QBEJIIJ@Z ; ScintillaEditView::execute(uint,uint,long)
.text$mn:00003D5E                 cmp     eax, 1
.text$mn:00003D61                 jnz     short loc_3D6C
.text$mn:00003D63                 mov     [ebp+var_4], 1
.text$mn:00003D6A                 jmp     short loc_3D73
.text$mn:00003D6C ; ---------------------------------------------------------------------------
.text$mn:00003D6C
.text$mn:00003D6C loc_3D6C:                               ; CODE XREF: ScintillaEditView::isWrap(void)+1Dj
.text$mn:00003D6C                 mov     [ebp+var_4], 0
.text$mn:00003D73
.text$mn:00003D73 loc_3D73:                               ; CODE XREF: ScintillaEditView::isWrap(void)+26j
.text$mn:00003D73                 mov     al, byte ptr [ebp+var_4]
.text$mn:00003D76                 mov     esp, ebp
.text$mn:00003D78                 pop     ebp
.text$mn:00003D79                 retn
.text$mn:00003D79 ?isWrap@ScintillaEditView@@QBE_NXZ endp
.text$mn:00003D79
.text$mn:00003D79 ; ---------------------------------------------------------------------------
.text$mn:00003D7A                 align 4
.text$mn:00003D7A _text$mn        ends
.text$mn:00003D7A
.text$mn:00003D7C ; ===========================================================================
.text$mn:00003D7C
.text$mn:00003D7C ; Segment type: Pure code
.text$mn:00003D7C ; Segment permissions: Read/Execute
.text$mn:00003D7C _text$mn        segment para public 'CODE' use32
.text$mn:00003D7C                 assume cs:_text$mn
.text$mn:00003D7C                 ;org 3D7Ch
.text$mn:00003D7C ; COMDAT (pick any)
.text$mn:00003D7C                 assume es:nothing, ss:nothing, ds:_data, fs:nothing, gs:nothing
.text$mn:00003D7C
.text$mn:00003D7C ; =============== S U B R O U T I N E =======================================
.text$mn:00003D7C
.text$mn:00003D7C ; Attributes: bp-based frame
.text$mn:00003D7C
.text$mn:00003D7C ; int __cdecl std::char_traits<char>::length(char *Str)
.text$mn:00003D7C                 public ?length@?$char_traits@D@std@@SAIPBD@Z
.text$mn:00003D7C ?length@?$char_traits@D@std@@SAIPBD@Z proc near
.text$mn:00003D7C                                         ; CODE XREF: std::basic_string<char,std::char_traits<char>,std::allocator<char>>::assign(char const *)+21p
.text$mn:00003D7C
.text$mn:00003D7C var_4           = dword ptr -4
.text$mn:00003D7C Str             = dword ptr  8
.text$mn:00003D7C
.text$mn:00003D7C                 push    ebp
.text$mn:00003D7D                 mov     ebp, esp
.text$mn:00003D7F                 push    ecx
.text$mn:00003D80                 mov     eax, [ebp+Str]
.text$mn:00003D83                 movsx   ecx, byte ptr [eax]
.text$mn:00003D86                 test    ecx, ecx
.text$mn:00003D88                 jnz     short loc_3D93
.text$mn:00003D8A                 mov     [ebp+var_4], 0
.text$mn:00003D91                 jmp     short loc_3DA2
.text$mn:00003D93 ; ---------------------------------------------------------------------------
.text$mn:00003D93
.text$mn:00003D93 loc_3D93:                               ; CODE XREF: std::char_traits<char>::length(char const *)+Cj
.text$mn:00003D93                 mov     edx, [ebp+Str]
.text$mn:00003D96                 push    edx             ; Str
.text$mn:00003D97                 call    _strlen
.text$mn:00003D9C                 add     esp, 4
.text$mn:00003D9F                 mov     [ebp+var_4], eax
.text$mn:00003DA2
.text$mn:00003DA2 loc_3DA2:                               ; CODE XREF: std::char_traits<char>::length(char const *)+15j
.text$mn:00003DA2                 mov     eax, [ebp+var_4]
.text$mn:00003DA5                 mov     esp, ebp
.text$mn:00003DA7                 pop     ebp
.text$mn:00003DA8                 retn
.text$mn:00003DA8 ?length@?$char_traits@D@std@@SAIPBD@Z endp
.text$mn:00003DA8
.text$mn:00003DA8 ; ---------------------------------------------------------------------------
.text$mn:00003DA9                 align 4
.text$mn:00003DA9 _text$mn        ends
.text$mn:00003DA9
.text$mn:00003DAC ; ===========================================================================
.text$mn:00003DAC
.text$mn:00003DAC ; Segment type: Pure code
.text$mn:00003DAC ; Segment permissions: Read/Execute
.text$mn:00003DAC _text$mn        segment para public 'CODE' use32
.text$mn:00003DAC                 assume cs:_text$mn
.text$mn:00003DAC                 ;org 3DACh
.text$mn:00003DAC ; COMDAT (pick any)
.text$mn:00003DAC                 assume es:nothing, ss:nothing, ds:_data, fs:nothing, gs:nothing
.text$mn:00003DAC
.text$mn:00003DAC ; =============== S U B R O U T I N E =======================================
.text$mn:00003DAC
.text$mn:00003DAC ; Attributes: bp-based frame
.text$mn:00003DAC
.text$mn:00003DAC ; public: unsigned int __thiscall std::_Wrap_alloc<class std::allocator<char>>::max_size(void)const
.text$mn:00003DAC                 public ?max_size@?$_Wrap_alloc@V?$allocator@D@std@@@std@@QBEIXZ
.text$mn:00003DAC ?max_size@?$_Wrap_alloc@V?$allocator@D@std@@@std@@QBEIXZ proc near
.text$mn:00003DAC                                         ; CODE XREF: std::basic_string<char,std::char_traits<char>,std::allocator<char>>::max_size(void)+17p
.text$mn:00003DAC
.text$mn:00003DAC var_4           = dword ptr -4
.text$mn:00003DAC
.text$mn:00003DAC                 push    ebp
.text$mn:00003DAD                 mov     ebp, esp
.text$mn:00003DAF                 push    ecx
.text$mn:00003DB0                 mov     [ebp+var_4], ecx
.text$mn:00003DB3                 mov     eax, [ebp+var_4]
.text$mn:00003DB6                 push    eax
.text$mn:00003DB7                 call    ?max_size@?$allocator_traits@V?$allocator@D@std@@@std@@SAIABV?$allocator@D@2@@Z ; std::allocator_traits<std::allocator<char>>::max_size(std::allocator<char> const &)
.text$mn:00003DBC                 add     esp, 4
.text$mn:00003DBF                 mov     esp, ebp
.text$mn:00003DC1                 pop     ebp
.text$mn:00003DC2                 retn
.text$mn:00003DC2 ?max_size@?$_Wrap_alloc@V?$allocator@D@std@@@std@@QBEIXZ endp
.text$mn:00003DC2
.text$mn:00003DC2 ; ---------------------------------------------------------------------------
.text$mn:00003DC3                 align 4
.text$mn:00003DC3 _text$mn        ends
.text$mn:00003DC3
.text$mn:00003DC4 ; ===========================================================================
.text$mn:00003DC4
.text$mn:00003DC4 ; Segment type: Pure code
.text$mn:00003DC4 ; Segment permissions: Read/Execute
.text$mn:00003DC4 _text$mn        segment para public 'CODE' use32
.text$mn:00003DC4                 assume cs:_text$mn
.text$mn:00003DC4                 ;org 3DC4h
.text$mn:00003DC4 ; COMDAT (pick any)
.text$mn:00003DC4                 assume es:nothing, ss:nothing, ds:_data, fs:nothing, gs:nothing
.text$mn:00003DC4
.text$mn:00003DC4 ; =============== S U B R O U T I N E =======================================
.text$mn:00003DC4
.text$mn:00003DC4 ; Attributes: bp-based frame
.text$mn:00003DC4
.text$mn:00003DC4 ; public: unsigned int __thiscall std::allocator<char>::max_size(void)const
.text$mn:00003DC4                 public ?max_size@?$allocator@D@std@@QBEIXZ
.text$mn:00003DC4 ?max_size@?$allocator@D@std@@QBEIXZ proc near
.text$mn:00003DC4                                         ; CODE XREF: std::allocator_traits<std::allocator<char>>::max_size(std::allocator<char> const &)+6p
.text$mn:00003DC4
.text$mn:00003DC4 var_4           = dword ptr -4
.text$mn:00003DC4
.text$mn:00003DC4                 push    ebp
.text$mn:00003DC5                 mov     ebp, esp
.text$mn:00003DC7                 push    ecx
.text$mn:00003DC8                 mov     [ebp+var_4], ecx
.text$mn:00003DCB                 or      eax, 0FFFFFFFFh
.text$mn:00003DCE                 mov     esp, ebp
.text$mn:00003DD0                 pop     ebp
.text$mn:00003DD1                 retn
.text$mn:00003DD1 ?max_size@?$allocator@D@std@@QBEIXZ endp
.text$mn:00003DD1
.text$mn:00003DD1 ; ---------------------------------------------------------------------------
.text$mn:00003DD2                 align 4
.text$mn:00003DD2 _text$mn        ends
.text$mn:00003DD2
.text$mn:00003DD4 ; ===========================================================================
.text$mn:00003DD4
.text$mn:00003DD4 ; Segment type: Pure code
.text$mn:00003DD4 ; Segment permissions: Read/Execute
.text$mn:00003DD4 _text$mn        segment para public 'CODE' use32
.text$mn:00003DD4                 assume cs:_text$mn
.text$mn:00003DD4                 ;org 3DD4h
.text$mn:00003DD4 ; COMDAT (pick any)
.text$mn:00003DD4                 assume es:nothing, ss:nothing, ds:_data, fs:nothing, gs:nothing
.text$mn:00003DD4
.text$mn:00003DD4 ; =============== S U B R O U T I N E =======================================
.text$mn:00003DD4
.text$mn:00003DD4 ; Attributes: bp-based frame
.text$mn:00003DD4
.text$mn:00003DD4 ; public: static unsigned int __cdecl std::allocator_traits<class std::allocator<char>>::max_size(class std::allocator<char> const &)
.text$mn:00003DD4                 public ?max_size@?$allocator_traits@V?$allocator@D@std@@@std@@SAIABV?$allocator@D@2@@Z
.text$mn:00003DD4 ?max_size@?$allocator_traits@V?$allocator@D@std@@@std@@SAIABV?$allocator@D@2@@Z proc near
.text$mn:00003DD4                                         ; CODE XREF: std::_Wrap_alloc<std::allocator<char>>::max_size(void)+Bp
.text$mn:00003DD4
.text$mn:00003DD4 arg_0           = dword ptr  8
.text$mn:00003DD4
.text$mn:00003DD4                 push    ebp
.text$mn:00003DD5                 mov     ebp, esp
.text$mn:00003DD7                 mov     ecx, [ebp+arg_0]
.text$mn:00003DDA                 call    ?max_size@?$allocator@D@std@@QBEIXZ ; std::allocator<char>::max_size(void)
.text$mn:00003DDF                 pop     ebp
.text$mn:00003DE0                 retn
.text$mn:00003DE0 ?max_size@?$allocator_traits@V?$allocator@D@std@@@std@@SAIABV?$allocator@D@2@@Z endp
.text$mn:00003DE0
.text$mn:00003DE0 ; ---------------------------------------------------------------------------
.text$mn:00003DE1                 align 4
.text$mn:00003DE1 _text$mn        ends
.text$mn:00003DE1
.text$mn:00003DE4 ; ===========================================================================
.text$mn:00003DE4
.text$mn:00003DE4 ; Segment type: Pure code
.text$mn:00003DE4 ; Segment permissions: Read/Execute
.text$mn:00003DE4 _text$mn        segment para public 'CODE' use32
.text$mn:00003DE4                 assume cs:_text$mn
.text$mn:00003DE4                 ;org 3DE4h
.text$mn:00003DE4 ; COMDAT (pick any)
.text$mn:00003DE4                 assume es:nothing, ss:nothing, ds:_data, fs:nothing, gs:nothing
.text$mn:00003DE4
.text$mn:00003DE4 ; =============== S U B R O U T I N E =======================================
.text$mn:00003DE4
.text$mn:00003DE4 ; Attributes: bp-based frame
.text$mn:00003DE4
.text$mn:00003DE4 ; public: unsigned int __thiscall std::basic_string<char, struct std::char_traits<char>, class std::allocator<char>>::max_size(void)const
.text$mn:00003DE4                 public ?max_size@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QBEIXZ
.text$mn:00003DE4 ?max_size@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QBEIXZ proc near
.text$mn:00003DE4                                         ; CODE XREF: std::basic_string<char,std::char_traits<char>,std::allocator<char>>::_Copy(uint,uint)+3Bp
.text$mn:00003DE4                                         ; std::basic_string<char,std::char_traits<char>,std::allocator<char>>::_Copy(uint,uint)+6Ap ...
.text$mn:00003DE4
.text$mn:00003DE4 var_10          = dword ptr -10h
.text$mn:00003DE4 var_C           = dword ptr -0Ch
.text$mn:00003DE4 var_8           = dword ptr -8
.text$mn:00003DE4 var_1           = byte ptr -1
.text$mn:00003DE4
.text$mn:00003DE4                 push    ebp
.text$mn:00003DE5                 mov     ebp, esp
.text$mn:00003DE7                 sub     esp, 10h
.text$mn:00003DEA                 mov     [ebp+var_10], ecx
.text$mn:00003DED                 lea     eax, [ebp+var_1]
.text$mn:00003DF0                 push    eax
.text$mn:00003DF1                 mov     ecx, [ebp+var_10]
.text$mn:00003DF4                 call    ?_Getal@?$_String_alloc@$0A@U?$_String_base_types@DV?$allocator@D@std@@@std@@@std@@QBE?AU?$_Wrap_alloc@V?$allocator@D@std@@@2@XZ ; std::_String_alloc<0,std::_String_base_types<char,std::allocator<char>>>::_Getal(void)
.text$mn:00003DF9                 mov     ecx, eax
.text$mn:00003DFB                 call    ?max_size@?$_Wrap_alloc@V?$allocator@D@std@@@std@@QBEIXZ ; std::_Wrap_alloc<std::allocator<char>>::max_size(void)
.text$mn:00003E00                 mov     [ebp+var_8], eax
.text$mn:00003E03                 cmp     [ebp+var_8], 1
.text$mn:00003E07                 ja      short loc_3E12
.text$mn:00003E09                 mov     [ebp+var_C], 1
.text$mn:00003E10                 jmp     short loc_3E1B
.text$mn:00003E12 ; ---------------------------------------------------------------------------
.text$mn:00003E12
.text$mn:00003E12 loc_3E12:                               ; CODE XREF: std::basic_string<char,std::char_traits<char>,std::allocator<char>>::max_size(void)+23j
.text$mn:00003E12                 mov     ecx, [ebp+var_8]
.text$mn:00003E15                 sub     ecx, 1
.text$mn:00003E18                 mov     [ebp+var_C], ecx
.text$mn:00003E1B
.text$mn:00003E1B loc_3E1B:                               ; CODE XREF: std::basic_string<char,std::char_traits<char>,std::allocator<char>>::max_size(void)+2Cj
.text$mn:00003E1B                 mov     eax, [ebp+var_C]
.text$mn:00003E1E                 mov     esp, ebp
.text$mn:00003E20                 pop     ebp
.text$mn:00003E21                 retn
.text$mn:00003E21 ?max_size@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QBEIXZ endp
.text$mn:00003E21
.text$mn:00003E21 ; ---------------------------------------------------------------------------
.text$mn:00003E22                 align 4
.text$mn:00003E22 _text$mn        ends
.text$mn:00003E22
.text$mn:00003E24 ; ===========================================================================
.text$mn:00003E24
.text$mn:00003E24 ; Segment type: Pure code
.text$mn:00003E24 ; Segment permissions: Read/Execute
.text$mn:00003E24 _text$mn        segment para public 'CODE' use32
.text$mn:00003E24                 assume cs:_text$mn
.text$mn:00003E24                 ;org 3E24h
.text$mn:00003E24 ; COMDAT (pick any)
.text$mn:00003E24                 assume es:nothing, ss:nothing, ds:_data, fs:nothing, gs:nothing
.text$mn:00003E24
.text$mn:00003E24 ; =============== S U B R O U T I N E =======================================
.text$mn:00003E24
.text$mn:00003E24 ; Attributes: bp-based frame
.text$mn:00003E24
.text$mn:00003E24 ; public: virtual class std::basic_string<char, struct std::char_traits<char>, class std::allocator<char>> __thiscall std::_Generic_error_category::message(int)const
.text$mn:00003E24                 public ?message@_Generic_error_category@std@@UBE?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@2@H@Z
.text$mn:00003E24 ?message@_Generic_error_category@std@@UBE?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@2@H@Z proc near
.text$mn:00003E24                                         ; CODE XREF: std::_Iostream_error_category::message(int)+64p
.text$mn:00003E24                                         ; DATA XREF: .rdata:00004814o
.text$mn:00003E24
.text$mn:00003E24 var_1C          = dword ptr -1Ch
.text$mn:00003E24 var_18          = dword ptr -18h
.text$mn:00003E24 Str             = dword ptr -14h
.text$mn:00003E24 var_10          = dword ptr -10h
.text$mn:00003E24 var_C           = dword ptr -0Ch
.text$mn:00003E24 var_4           = dword ptr -4
.text$mn:00003E24 arg_0           = dword ptr  8
.text$mn:00003E24 arg_4           = dword ptr  0Ch
.text$mn:00003E24
.text$mn:00003E24                 push    ebp
.text$mn:00003E25                 mov     ebp, esp
.text$mn:00003E27                 push    0FFFFFFFFh
.text$mn:00003E29                 push    offset __ehhandler$?message@_Generic_error_category@std@@UBE?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@2@H@Z
.text$mn:00003E2E                 mov     eax, large fs:0
.text$mn:00003E34                 push    eax
.text$mn:00003E35                 sub     esp, 10h
.text$mn:00003E38                 mov     eax, dword ptr ds:___security_cookie
.text$mn:00003E3D                 xor     eax, ebp
.text$mn:00003E3F                 push    eax
.text$mn:00003E40                 lea     eax, [ebp+var_C]
.text$mn:00003E43                 mov     large fs:0, eax
.text$mn:00003E49                 mov     [ebp+var_1C], ecx
.text$mn:00003E4C                 mov     [ebp+var_18], 0
.text$mn:00003E53                 mov     eax, [ebp+arg_4]
.text$mn:00003E56                 push    eax             ; int
.text$mn:00003E57                 call    ?_Syserror_map@std@@YAPBDH@Z ; std::_Syserror_map(int)
.text$mn:00003E5C                 add     esp, 4
.text$mn:00003E5F                 mov     [ebp+var_10], eax
.text$mn:00003E62                 cmp     [ebp+var_10], 0
.text$mn:00003E66                 jz      short loc_3E70
.text$mn:00003E68                 mov     ecx, [ebp+var_10]
.text$mn:00003E6B                 mov     [ebp+Str], ecx
.text$mn:00003E6E                 jmp     short loc_3E77
.text$mn:00003E70 ; ---------------------------------------------------------------------------
.text$mn:00003E70
.text$mn:00003E70 loc_3E70:                               ; CODE XREF: std::_Generic_error_category::message(int)+42j
.text$mn:00003E70                 mov     [ebp+Str], offset ??_C@_0O@BFJCFAAK@unknown?5error?$AA@ ; "unknown error"
.text$mn:00003E77
.text$mn:00003E77 loc_3E77:                               ; CODE XREF: std::_Generic_error_category::message(int)+4Aj
.text$mn:00003E77                 mov     edx, [ebp+Str]
.text$mn:00003E7A                 push    edx             ; Str
.text$mn:00003E7B                 mov     ecx, [ebp+arg_0]
.text$mn:00003E7E                 call    ??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@PBD@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char>>::basic_string<char,std::char_traits<char>,std::allocator<char>>(char const *)
.text$mn:00003E83                 mov     [ebp+var_4], 0
.text$mn:00003E8A                 mov     eax, [ebp+var_18]
.text$mn:00003E8D                 or      eax, 1
.text$mn:00003E90                 mov     [ebp+var_18], eax
.text$mn:00003E93                 mov     eax, [ebp+arg_0]
.text$mn:00003E96                 mov     ecx, [ebp+var_C]
.text$mn:00003E99                 mov     large fs:0, ecx
.text$mn:00003EA0                 pop     ecx
.text$mn:00003EA1                 mov     esp, ebp
.text$mn:00003EA3                 pop     ebp
.text$mn:00003EA4                 retn    8
.text$mn:00003EA4 ?message@_Generic_error_category@std@@UBE?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@2@H@Z endp
.text$mn:00003EA4
.text$mn:00003EA4 ; ---------------------------------------------------------------------------
.text$mn:00003EA7                 align 4
.text$mn:00003EA7 _text$mn        ends
.text$mn:00003EA7
.text$x:00003EA8 ; ===========================================================================
.text$x:00003EA8
.text$x:00003EA8 ; Segment type: Pure code
.text$x:00003EA8 ; Segment permissions: Read/Execute
.text$x:00003EA8 _text$x         segment para public 'CODE' use32
.text$x:00003EA8                 assume cs:_text$x
.text$x:00003EA8                 ;org 3EA8h
.text$x:00003EA8 ; COMDAT (pick associative to section at 3E24)
.text$x:00003EA8                 assume es:nothing, ss:nothing, ds:_data, fs:nothing, gs:nothing
.text$x:00003EA8
.text$x:00003EA8 ; =============== S U B R O U T I N E =======================================
.text$x:00003EA8
.text$x:00003EA8
.text$x:00003EA8 __unwindfunclet$?message@_Generic_error_category@std@@UBE?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@2@H@Z$0 proc near
.text$x:00003EA8                                         ; DATA XREF: .xdata$x:00004500o
.text$x:00003EA8                 mov     eax, [ebp-18h]
.text$x:00003EAB                 and     eax, 1
.text$x:00003EAE                 jz      $LN6
.text$x:00003EB4                 and     dword ptr [ebp-18h], 0FFFFFFFEh
.text$x:00003EB8                 mov     ecx, [ebp+8]
.text$x:00003EBB                 jmp     ??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char>>::~basic_string<char,std::char_traits<char>,std::allocator<char>>(void)
.text$x:00003EC0 ; ---------------------------------------------------------------------------
.text$x:00003EC0
.text$x:00003EC0 $LN6:                                   ; CODE XREF: __unwindfunclet$?message@_Generic_error_category@std@@UBE?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@2@H@Z$0+6j
.text$x:00003EC0                 retn
.text$x:00003EC0 __unwindfunclet$?message@_Generic_error_category@std@@UBE?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@2@H@Z$0 endp
.text$x:00003EC0
.text$x:00003EC1
.text$x:00003EC1 ; =============== S U B R O U T I N E =======================================
.text$x:00003EC1
.text$x:00003EC1
.text$x:00003EC1 __ehhandler$?message@_Generic_error_category@std@@UBE?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@2@H@Z proc near
.text$x:00003EC1                                         ; DATA XREF: std::_Generic_error_category::message(int)+5o
.text$x:00003EC1
.text$x:00003EC1 arg_4           = dword ptr  8
.text$x:00003EC1
.text$x:00003EC1                 mov     edx, [esp+arg_4]
.text$x:00003EC5                 lea     eax, [edx+0Ch]
.text$x:00003EC8                 mov     ecx, [edx-14h]
.text$x:00003ECB                 xor     ecx, eax
.text$x:00003ECD                 call    @__security_check_cookie@4 ; __security_check_cookie(x)
.text$x:00003ED2                 mov     eax, offset __ehfuncinfo$?message@_Generic_error_category@std@@UBE?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@2@H@Z
.text$x:00003ED7                 jmp     ___CxxFrameHandler3
.text$x:00003ED7 __ehhandler$?message@_Generic_error_category@std@@UBE?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@2@H@Z endp
.text$x:00003ED7
.text$x:00003ED7 _text$x         ends
.text$x:00003ED7
.text$mn:00003EDC ; ===========================================================================
.text$mn:00003EDC
.text$mn:00003EDC ; Segment type: Pure code
.text$mn:00003EDC ; Segment permissions: Read/Execute
.text$mn:00003EDC _text$mn        segment para public 'CODE' use32
.text$mn:00003EDC                 assume cs:_text$mn
.text$mn:00003EDC                 ;org 3EDCh
.text$mn:00003EDC ; COMDAT (pick any)
.text$mn:00003EDC                 assume es:nothing, ss:nothing, ds:_data, fs:nothing, gs:nothing
.text$mn:00003EDC
.text$mn:00003EDC ; =============== S U B R O U T I N E =======================================
.text$mn:00003EDC
.text$mn:00003EDC ; Attributes: bp-based frame
.text$mn:00003EDC
.text$mn:00003EDC ; public: virtual class std::basic_string<char, struct std::char_traits<char>, class std::allocator<char>> __thiscall std::_Iostream_error_category::message(int)const
.text$mn:00003EDC                 public ?message@_Iostream_error_category@std@@UBE?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@2@H@Z
.text$mn:00003EDC ?message@_Iostream_error_category@std@@UBE?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@2@H@Z proc near
.text$mn:00003EDC                                         ; DATA XREF: .rdata:00004848o
.text$mn:00003EDC
.text$mn:00003EDC var_14          = dword ptr -14h
.text$mn:00003EDC var_10          = dword ptr -10h
.text$mn:00003EDC var_C           = dword ptr -0Ch
.text$mn:00003EDC var_4           = dword ptr -4
.text$mn:00003EDC arg_0           = dword ptr  8
.text$mn:00003EDC arg_4           = dword ptr  0Ch
.text$mn:00003EDC
.text$mn:00003EDC                 push    ebp
.text$mn:00003EDD                 mov     ebp, esp
.text$mn:00003EDF                 push    0FFFFFFFFh
.text$mn:00003EE1                 push    offset __ehhandler$?message@_Iostream_error_category@std@@UBE?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@2@H@Z
.text$mn:00003EE6                 mov     eax, large fs:0
.text$mn:00003EEC                 push    eax
.text$mn:00003EED                 sub     esp, 8
.text$mn:00003EF0                 mov     eax, dword ptr ds:___security_cookie
.text$mn:00003EF5                 xor     eax, ebp
.text$mn:00003EF7                 push    eax
.text$mn:00003EF8                 lea     eax, [ebp+var_C]
.text$mn:00003EFB                 mov     large fs:0, eax
.text$mn:00003F01                 mov     [ebp+var_14], ecx
.text$mn:00003F04                 mov     [ebp+var_10], 0
.text$mn:00003F0B                 cmp     [ebp+arg_4], 1
.text$mn:00003F0F                 jnz     short loc_3F35
.text$mn:00003F11                 push    offset ??_C@_0BG@PADBLCHM@iostream?5stream?5error?$AA@ ; "iostream stream error"
.text$mn:00003F16                 mov     ecx, [ebp+arg_0]
.text$mn:00003F19                 call    ??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@PBD@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char>>::basic_string<char,std::char_traits<char>,std::allocator<char>>(char const *)
.text$mn:00003F1E                 mov     [ebp+var_4], 0
.text$mn:00003F25                 mov     eax, [ebp+var_10]
.text$mn:00003F28                 or      eax, 1
.text$mn:00003F2B                 mov     [ebp+var_10], eax
.text$mn:00003F2E                 mov     eax, [ebp+arg_0]
.text$mn:00003F31                 jmp     short loc_3F58
.text$mn:00003F33 ; ---------------------------------------------------------------------------
.text$mn:00003F33                 jmp     short loc_3F58
.text$mn:00003F35 ; ---------------------------------------------------------------------------
.text$mn:00003F35
.text$mn:00003F35 loc_3F35:                               ; CODE XREF: std::_Iostream_error_category::message(int)+33j
.text$mn:00003F35                 mov     ecx, [ebp+arg_4]
.text$mn:00003F38                 push    ecx
.text$mn:00003F39                 mov     edx, [ebp+arg_0]
.text$mn:00003F3C                 push    edx
.text$mn:00003F3D                 mov     ecx, [ebp+var_14]
.text$mn:00003F40                 call    ?message@_Generic_error_category@std@@UBE?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@2@H@Z ; std::_Generic_error_category::message(int)
.text$mn:00003F45                 mov     [ebp+var_4], 0
.text$mn:00003F4C                 mov     eax, [ebp+var_10]
.text$mn:00003F4F                 or      eax, 1
.text$mn:00003F52                 mov     [ebp+var_10], eax
.text$mn:00003F55                 mov     eax, [ebp+arg_0]
.text$mn:00003F58
.text$mn:00003F58 loc_3F58:                               ; CODE XREF: std::_Iostream_error_category::message(int)+55j
.text$mn:00003F58                                         ; std::_Iostream_error_category::message(int)+57j
.text$mn:00003F58                 mov     ecx, [ebp+var_C]
.text$mn:00003F5B                 mov     large fs:0, ecx
.text$mn:00003F62                 pop     ecx
.text$mn:00003F63                 mov     esp, ebp
.text$mn:00003F65                 pop     ebp
.text$mn:00003F66                 retn    8
.text$mn:00003F66 ?message@_Iostream_error_category@std@@UBE?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@2@H@Z endp
.text$mn:00003F66
.text$mn:00003F66 ; ---------------------------------------------------------------------------
.text$mn:00003F69                 align 4
.text$mn:00003F69 _text$mn        ends
.text$mn:00003F69
.text$x:00003F6C ; ===========================================================================
.text$x:00003F6C
.text$x:00003F6C ; Segment type: Pure code
.text$x:00003F6C ; Segment permissions: Read/Execute
.text$x:00003F6C _text$x         segment para public 'CODE' use32
.text$x:00003F6C                 assume cs:_text$x
.text$x:00003F6C                 ;org 3F6Ch
.text$x:00003F6C ; COMDAT (pick associative to section at 3EDC)
.text$x:00003F6C                 assume es:nothing, ss:nothing, ds:_data, fs:nothing, gs:nothing
.text$x:00003F6C
.text$x:00003F6C ; =============== S U B R O U T I N E =======================================
.text$x:00003F6C
.text$x:00003F6C
.text$x:00003F6C __unwindfunclet$?message@_Iostream_error_category@std@@UBE?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@2@H@Z$0 proc near
.text$x:00003F6C                                         ; DATA XREF: .xdata$x:00004584o
.text$x:00003F6C                 mov     eax, [ebp-10h]
.text$x:00003F6F                 and     eax, 1
.text$x:00003F72                 jz      $LN6_0
.text$x:00003F78                 and     dword ptr [ebp-10h], 0FFFFFFFEh
.text$x:00003F7C                 mov     ecx, [ebp+8]
.text$x:00003F7F                 jmp     ??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char>>::~basic_string<char,std::char_traits<char>,std::allocator<char>>(void)
.text$x:00003F84 ; ---------------------------------------------------------------------------
.text$x:00003F84
.text$x:00003F84 $LN6_0:                                 ; CODE XREF: __unwindfunclet$?message@_Iostream_error_category@std@@UBE?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@2@H@Z$0+6j
.text$x:00003F84                 retn
.text$x:00003F84 __unwindfunclet$?message@_Iostream_error_category@std@@UBE?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@2@H@Z$0 endp
.text$x:00003F84
.text$x:00003F85
.text$x:00003F85 ; =============== S U B R O U T I N E =======================================
.text$x:00003F85
.text$x:00003F85
.text$x:00003F85 __ehhandler$?message@_Iostream_error_category@std@@UBE?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@2@H@Z proc near
.text$x:00003F85                                         ; DATA XREF: std::_Iostream_error_category::message(int)+5o
.text$x:00003F85
.text$x:00003F85 arg_4           = dword ptr  8
.text$x:00003F85
.text$x:00003F85                 mov     edx, [esp+arg_4]
.text$x:00003F89                 lea     eax, [edx+0Ch]
.text$x:00003F8C                 mov     ecx, [edx-0Ch]
.text$x:00003F8F                 xor     ecx, eax
.text$x:00003F91                 call    @__security_check_cookie@4 ; __security_check_cookie(x)
.text$x:00003F96                 mov     eax, offset __ehfuncinfo$?message@_Iostream_error_category@std@@UBE?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@2@H@Z
.text$x:00003F9B                 jmp     ___CxxFrameHandler3
.text$x:00003F9B __ehhandler$?message@_Iostream_error_category@std@@UBE?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@2@H@Z endp
.text$x:00003F9B
.text$x:00003F9B _text$x         ends
.text$x:00003F9B
.text$mn:00003FA0 ; ===========================================================================
.text$mn:00003FA0
.text$mn:00003FA0 ; Segment type: Pure code
.text$mn:00003FA0 ; Segment permissions: Read/Execute
.text$mn:00003FA0 _text$mn        segment para public 'CODE' use32
.text$mn:00003FA0                 assume cs:_text$mn
.text$mn:00003FA0                 ;org 3FA0h
.text$mn:00003FA0 ; COMDAT (pick any)
.text$mn:00003FA0                 assume es:nothing, ss:nothing, ds:_data, fs:nothing, gs:nothing
.text$mn:00003FA0
.text$mn:00003FA0 ; =============== S U B R O U T I N E =======================================
.text$mn:00003FA0
.text$mn:00003FA0 ; Attributes: bp-based frame
.text$mn:00003FA0
.text$mn:00003FA0 ; public: virtual class std::basic_string<char, struct std::char_traits<char>, class std::allocator<char>> __thiscall std::_System_error_category::message(int)const
.text$mn:00003FA0                 public ?message@_System_error_category@std@@UBE?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@2@H@Z
.text$mn:00003FA0 ?message@_System_error_category@std@@UBE?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@2@H@Z proc near
.text$mn:00003FA0                                         ; DATA XREF: .rdata:00004888o
.text$mn:00003FA0
.text$mn:00003FA0 var_1C          = dword ptr -1Ch
.text$mn:00003FA0 var_18          = dword ptr -18h
.text$mn:00003FA0 Str             = dword ptr -14h
.text$mn:00003FA0 var_10          = dword ptr -10h
.text$mn:00003FA0 var_C           = dword ptr -0Ch
.text$mn:00003FA0 var_4           = dword ptr -4
.text$mn:00003FA0 arg_0           = dword ptr  8
.text$mn:00003FA0 arg_4           = dword ptr  0Ch
.text$mn:00003FA0
.text$mn:00003FA0                 push    ebp
.text$mn:00003FA1                 mov     ebp, esp
.text$mn:00003FA3                 push    0FFFFFFFFh
.text$mn:00003FA5                 push    offset __ehhandler$?message@_System_error_category@std@@UBE?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@2@H@Z
.text$mn:00003FAA                 mov     eax, large fs:0
.text$mn:00003FB0                 push    eax
.text$mn:00003FB1                 sub     esp, 10h
.text$mn:00003FB4                 mov     eax, dword ptr ds:___security_cookie
.text$mn:00003FB9                 xor     eax, ebp
.text$mn:00003FBB                 push    eax
.text$mn:00003FBC                 lea     eax, [ebp+var_C]
.text$mn:00003FBF                 mov     large fs:0, eax
.text$mn:00003FC5                 mov     [ebp+var_1C], ecx
.text$mn:00003FC8                 mov     [ebp+var_18], 0
.text$mn:00003FCF                 mov     eax, [ebp+arg_4]
.text$mn:00003FD2                 push    eax             ; int
.text$mn:00003FD3                 call    ?_Winerror_map@std@@YAPBDH@Z ; std::_Winerror_map(int)
.text$mn:00003FD8                 add     esp, 4
.text$mn:00003FDB                 mov     [ebp+var_10], eax
.text$mn:00003FDE                 cmp     [ebp+var_10], 0
.text$mn:00003FE2                 jz      short loc_3FEC
.text$mn:00003FE4                 mov     ecx, [ebp+var_10]
.text$mn:00003FE7                 mov     [ebp+Str], ecx
.text$mn:00003FEA                 jmp     short loc_3FF3
.text$mn:00003FEC ; ---------------------------------------------------------------------------
.text$mn:00003FEC
.text$mn:00003FEC loc_3FEC:                               ; CODE XREF: std::_System_error_category::message(int)+42j
.text$mn:00003FEC                 mov     [ebp+Str], offset ??_C@_0O@BFJCFAAK@unknown?5error?$AA@ ; "unknown error"
.text$mn:00003FF3
.text$mn:00003FF3 loc_3FF3:                               ; CODE XREF: std::_System_error_category::message(int)+4Aj
.text$mn:00003FF3                 mov     edx, [ebp+Str]
.text$mn:00003FF6                 push    edx             ; Str
.text$mn:00003FF7                 mov     ecx, [ebp+arg_0]
.text$mn:00003FFA                 call    ??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@PBD@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char>>::basic_string<char,std::char_traits<char>,std::allocator<char>>(char const *)
.text$mn:00003FFF                 mov     [ebp+var_4], 0
.text$mn:00004006                 mov     eax, [ebp+var_18]
.text$mn:00004009                 or      eax, 1
.text$mn:0000400C                 mov     [ebp+var_18], eax
.text$mn:0000400F                 mov     eax, [ebp+arg_0]
.text$mn:00004012                 mov     ecx, [ebp+var_C]
.text$mn:00004015                 mov     large fs:0, ecx
.text$mn:0000401C                 pop     ecx
.text$mn:0000401D                 mov     esp, ebp
.text$mn:0000401F                 pop     ebp
.text$mn:00004020                 retn    8
.text$mn:00004020 ?message@_System_error_category@std@@UBE?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@2@H@Z endp
.text$mn:00004020
.text$mn:00004020 ; ---------------------------------------------------------------------------
.text$mn:00004023                 align 4
.text$mn:00004023 _text$mn        ends
.text$mn:00004023
.text$x:00004024 ; ===========================================================================
.text$x:00004024
.text$x:00004024 ; Segment type: Pure code
.text$x:00004024 ; Segment permissions: Read/Execute
.text$x:00004024 _text$x         segment para public 'CODE' use32
.text$x:00004024                 assume cs:_text$x
.text$x:00004024                 ;org 4024h
.text$x:00004024 ; COMDAT (pick associative to section at 3FA0)
.text$x:00004024                 assume es:nothing, ss:nothing, ds:_data, fs:nothing, gs:nothing
.text$x:00004024
.text$x:00004024 ; =============== S U B R O U T I N E =======================================
.text$x:00004024
.text$x:00004024
.text$x:00004024 __unwindfunclet$?message@_System_error_category@std@@UBE?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@2@H@Z$0 proc near
.text$x:00004024                                         ; DATA XREF: .xdata$x:00004608o
.text$x:00004024                 mov     eax, [ebp-18h]
.text$x:00004027                 and     eax, 1
.text$x:0000402A                 jz      $LN6_1
.text$x:00004030                 and     dword ptr [ebp-18h], 0FFFFFFFEh
.text$x:00004034                 mov     ecx, [ebp+8]
.text$x:00004037                 jmp     ??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char>>::~basic_string<char,std::char_traits<char>,std::allocator<char>>(void)
.text$x:0000403C ; ---------------------------------------------------------------------------
.text$x:0000403C
.text$x:0000403C $LN6_1:                                 ; CODE XREF: __unwindfunclet$?message@_System_error_category@std@@UBE?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@2@H@Z$0+6j
.text$x:0000403C                 retn
.text$x:0000403C __unwindfunclet$?message@_System_error_category@std@@UBE?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@2@H@Z$0 endp
.text$x:0000403C
.text$x:0000403D
.text$x:0000403D ; =============== S U B R O U T I N E =======================================
.text$x:0000403D
.text$x:0000403D
.text$x:0000403D __ehhandler$?message@_System_error_category@std@@UBE?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@2@H@Z proc near
.text$x:0000403D                                         ; DATA XREF: std::_System_error_category::message(int)+5o
.text$x:0000403D
.text$x:0000403D arg_4           = dword ptr  8
.text$x:0000403D
.text$x:0000403D                 mov     edx, [esp+arg_4]
.text$x:00004041                 lea     eax, [edx+0Ch]
.text$x:00004044                 mov     ecx, [edx-14h]
.text$x:00004047                 xor     ecx, eax
.text$x:00004049                 call    @__security_check_cookie@4 ; __security_check_cookie(x)
.text$x:0000404E                 mov     eax, offset __ehfuncinfo$?message@_System_error_category@std@@UBE?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@2@H@Z
.text$x:00004053                 jmp     ___CxxFrameHandler3
.text$x:00004053 __ehhandler$?message@_System_error_category@std@@UBE?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@2@H@Z endp
.text$x:00004053
.text$x:00004053 _text$x         ends
.text$x:00004053
.text$mn:00004058 ; ===========================================================================
.text$mn:00004058
.text$mn:00004058 ; Segment type: Pure code
.text$mn:00004058 ; Segment permissions: Read/Execute
.text$mn:00004058 _text$mn        segment para public 'CODE' use32
.text$mn:00004058                 assume cs:_text$mn
.text$mn:00004058                 ;org 4058h
.text$mn:00004058 ; COMDAT (pick any)
.text$mn:00004058                 assume es:nothing, ss:nothing, ds:_data, fs:nothing, gs:nothing
.text$mn:00004058
.text$mn:00004058 ; =============== S U B R O U T I N E =======================================
.text$mn:00004058
.text$mn:00004058 ; Attributes: bp-based frame
.text$mn:00004058
.text$mn:00004058 ; void __thiscall ScintillaEditView::mouseWheel(ScintillaEditView *this, unsigned int, __int32)
.text$mn:00004058                 public ?mouseWheel@ScintillaEditView@@QAEXIJ@Z
.text$mn:00004058 ?mouseWheel@ScintillaEditView@@QAEXIJ@Z proc near
.text$mn:00004058                                         ; CODE XREF: DocumentMap::run_dlgProc(uint,uint,long)+479p
.text$mn:00004058
.text$mn:00004058 var_4           = dword ptr -4
.text$mn:00004058 arg_0           = dword ptr  8
.text$mn:00004058 arg_4           = dword ptr  0Ch
.text$mn:00004058
.text$mn:00004058                 push    ebp
.text$mn:00004059                 mov     ebp, esp
.text$mn:0000405B                 push    ecx
.text$mn:0000405C                 mov     [ebp+var_4], ecx
.text$mn:0000405F                 mov     eax, [ebp+arg_4]
.text$mn:00004062                 push    eax             ; __int32
.text$mn:00004063                 mov     ecx, [ebp+arg_0]
.text$mn:00004066                 push    ecx             ; unsigned int
.text$mn:00004067                 push    20Ah            ; unsigned int
.text$mn:0000406C                 mov     edx, [ebp+var_4]
.text$mn:0000406F                 mov     eax, [edx+0Ch]
.text$mn:00004072                 push    eax             ; HWND
.text$mn:00004073                 mov     ecx, [ebp+var_4] ; this
.text$mn:00004076                 call    ?scintillaNew_Proc@ScintillaEditView@@IAEJPAUHWND__@@IIJ@Z ; ScintillaEditView::scintillaNew_Proc(HWND__ *,uint,uint,long)
.text$mn:0000407B                 mov     esp, ebp
.text$mn:0000407D                 pop     ebp
.text$mn:0000407E                 retn    8
.text$mn:0000407E ?mouseWheel@ScintillaEditView@@QAEXIJ@Z endp
.text$mn:0000407E
.text$mn:0000407E ; ---------------------------------------------------------------------------
.text$mn:00004081                 align 4
.text$mn:00004081 _text$mn        ends
.text$mn:00004081
.text$mn:00004084 ; ===========================================================================
.text$mn:00004084
.text$mn:00004084 ; Segment type: Pure code
.text$mn:00004084 ; Segment permissions: Read/Execute
.text$mn:00004084 _text$mn        segment para public 'CODE' use32
.text$mn:00004084                 assume cs:_text$mn
.text$mn:00004084                 ;org 4084h
.text$mn:00004084 ; COMDAT (pick any)
.text$mn:00004084                 assume es:nothing, ss:nothing, ds:_data, fs:nothing, gs:nothing
.text$mn:00004084
.text$mn:00004084 ; =============== S U B R O U T I N E =======================================
.text$mn:00004084
.text$mn:00004084 ; Attributes: bp-based frame
.text$mn:00004084
.text$mn:00004084 ; int __cdecl std::char_traits<char>::move(void *Dst, void *Src, size_t Size)
.text$mn:00004084                 public ?move@?$char_traits@D@std@@SAPADPADPBDI@Z
.text$mn:00004084 ?move@?$char_traits@D@std@@SAPADPADPBDI@Z proc near
.text$mn:00004084                                         ; CODE XREF: std::basic_string<char,std::char_traits<char>,std::allocator<char>>::erase(uint,uint)+6Ap
.text$mn:00004084
.text$mn:00004084 var_4           = dword ptr -4
.text$mn:00004084 Dst             = dword ptr  8
.text$mn:00004084 Src             = dword ptr  0Ch
.text$mn:00004084 Size            = dword ptr  10h
.text$mn:00004084
.text$mn:00004084                 push    ebp
.text$mn:00004085                 mov     ebp, esp
.text$mn:00004087                 push    ecx
.text$mn:00004088                 cmp     [ebp+Size], 0
.text$mn:0000408C                 jnz     short loc_4096
.text$mn:0000408E                 mov     eax, [ebp+Dst]
.text$mn:00004091                 mov     [ebp+var_4], eax
.text$mn:00004094                 jmp     short loc_40AD
.text$mn:00004096 ; ---------------------------------------------------------------------------
.text$mn:00004096
.text$mn:00004096 loc_4096:                               ; CODE XREF: std::char_traits<char>::move(char *,char const *,uint)+8j
.text$mn:00004096                 mov     ecx, [ebp+Size]
.text$mn:00004099                 push    ecx             ; Size
.text$mn:0000409A                 mov     edx, [ebp+Src]
.text$mn:0000409D                 push    edx             ; Src
.text$mn:0000409E                 mov     eax, [ebp+Dst]
.text$mn:000040A1                 push    eax             ; Dst
.text$mn:000040A2                 call    _memmove
.text$mn:000040A7                 add     esp, 0Ch
.text$mn:000040AA                 mov     [ebp+var_4], eax
.text$mn:000040AD
.text$mn:000040AD loc_40AD:                               ; CODE XREF: std::char_traits<char>::move(char *,char const *,uint)+10j
.text$mn:000040AD                 mov     eax, [ebp+var_4]
.text$mn:000040B0                 mov     esp, ebp
.text$mn:000040B2                 pop     ebp
.text$mn:000040B3                 retn
.text$mn:000040B3 ?move@?$char_traits@D@std@@SAPADPADPBDI@Z endp
.text$mn:000040B3
.text$mn:000040B3 _text$mn        ends
.text$mn:000040B3
.text$mn:000040B4 ; ===========================================================================
.text$mn:000040B4
.text$mn:000040B4 ; Segment type: Pure code
.text$mn:000040B4 ; Segment permissions: Read/Execute
.text$mn:000040B4 _text$mn        segment para public 'CODE' use32
.text$mn:000040B4                 assume cs:_text$mn
.text$mn:000040B4                 ;org 40B4h
.text$mn:000040B4 ; COMDAT (pick any)
.text$mn:000040B4                 assume es:nothing, ss:nothing, ds:_data, fs:nothing, gs:nothing
.text$mn:000040B4
.text$mn:000040B4 ; =============== S U B R O U T I N E =======================================
.text$mn:000040B4
.text$mn:000040B4 ; Attributes: bp-based frame
.text$mn:000040B4
.text$mn:000040B4 ; const char *__thiscall std::_Generic_error_category::name(std::_Generic_error_category *__hidden this)
.text$mn:000040B4                 public ?name@_Generic_error_category@std@@UBEPBDXZ
.text$mn:000040B4 ?name@_Generic_error_category@std@@UBEPBDXZ proc near
.text$mn:000040B4                                         ; DATA XREF: .rdata:00004810o
.text$mn:000040B4
.text$mn:000040B4 var_4           = dword ptr -4
.text$mn:000040B4
.text$mn:000040B4                 push    ebp
.text$mn:000040B5                 mov     ebp, esp
.text$mn:000040B7                 push    ecx
.text$mn:000040B8                 mov     [ebp+var_4], ecx
.text$mn:000040BB                 mov     eax, offset ??_C@_07DCLBNMLN@generic?$AA@ ; "generic"
.text$mn:000040C0                 mov     esp, ebp
.text$mn:000040C2                 pop     ebp
.text$mn:000040C3                 retn
.text$mn:000040C3 ?name@_Generic_error_category@std@@UBEPBDXZ endp
.text$mn:000040C3
.text$mn:000040C3 _text$mn        ends
.text$mn:000040C3
.text$mn:000040C4 ; ===========================================================================
.text$mn:000040C4
.text$mn:000040C4 ; Segment type: Pure code
.text$mn:000040C4 ; Segment permissions: Read/Execute
.text$mn:000040C4 _text$mn        segment para public 'CODE' use32
.text$mn:000040C4                 assume cs:_text$mn
.text$mn:000040C4                 ;org 40C4h
.text$mn:000040C4 ; COMDAT (pick any)
.text$mn:000040C4                 assume es:nothing, ss:nothing, ds:_data, fs:nothing, gs:nothing
.text$mn:000040C4
.text$mn:000040C4 ; =============== S U B R O U T I N E =======================================
.text$mn:000040C4
.text$mn:000040C4 ; Attributes: bp-based frame
.text$mn:000040C4
.text$mn:000040C4 ; const char *__thiscall std::_Iostream_error_category::name(std::_Iostream_error_category *__hidden this)
.text$mn:000040C4                 public ?name@_Iostream_error_category@std@@UBEPBDXZ
.text$mn:000040C4 ?name@_Iostream_error_category@std@@UBEPBDXZ proc near
.text$mn:000040C4                                         ; DATA XREF: .rdata:00004844o
.text$mn:000040C4
.text$mn:000040C4 var_4           = dword ptr -4
.text$mn:000040C4
.text$mn:000040C4                 push    ebp
.text$mn:000040C5                 mov     ebp, esp
.text$mn:000040C7                 push    ecx
.text$mn:000040C8                 mov     [ebp+var_4], ecx
.text$mn:000040CB                 mov     eax, offset ??_C@_08LLGCOLLL@iostream?$AA@ ; "iostream"
.text$mn:000040D0                 mov     esp, ebp
.text$mn:000040D2                 pop     ebp
.text$mn:000040D3                 retn
.text$mn:000040D3 ?name@_Iostream_error_category@std@@UBEPBDXZ endp
.text$mn:000040D3
.text$mn:000040D3 _text$mn        ends
.text$mn:000040D3
.text$mn:000040D4 ; ===========================================================================
.text$mn:000040D4
.text$mn:000040D4 ; Segment type: Pure code
.text$mn:000040D4 ; Segment permissions: Read/Execute
.text$mn:000040D4 _text$mn        segment para public 'CODE' use32
.text$mn:000040D4                 assume cs:_text$mn
.text$mn:000040D4                 ;org 40D4h
.text$mn:000040D4 ; COMDAT (pick any)
.text$mn:000040D4                 assume es:nothing, ss:nothing, ds:_data, fs:nothing, gs:nothing
.text$mn:000040D4
.text$mn:000040D4 ; =============== S U B R O U T I N E =======================================
.text$mn:000040D4
.text$mn:000040D4 ; Attributes: bp-based frame
.text$mn:000040D4
.text$mn:000040D4 ; const char *__thiscall std::_System_error_category::name(std::_System_error_category *__hidden this)
.text$mn:000040D4                 public ?name@_System_error_category@std@@UBEPBDXZ
.text$mn:000040D4 ?name@_System_error_category@std@@UBEPBDXZ proc near
.text$mn:000040D4                                         ; DATA XREF: .rdata:00004884o
.text$mn:000040D4
.text$mn:000040D4 var_4           = dword ptr -4
.text$mn:000040D4
.text$mn:000040D4                 push    ebp
.text$mn:000040D5                 mov     ebp, esp
.text$mn:000040D7                 push    ecx
.text$mn:000040D8                 mov     [ebp+var_4], ecx
.text$mn:000040DB                 mov     eax, offset ??_C@_06FHFOAHML@system?$AA@ ; "system"
.text$mn:000040E0                 mov     esp, ebp
.text$mn:000040E2                 pop     ebp
.text$mn:000040E3                 retn
.text$mn:000040E3 ?name@_System_error_category@std@@UBEPBDXZ endp
.text$mn:000040E3
.text$mn:000040E3 _text$mn        ends
.text$mn:000040E3
.text$mn:000040E4 ; ===========================================================================
.text$mn:000040E4
.text$mn:000040E4 ; Segment type: Pure code
.text$mn:000040E4 ; Segment permissions: Read/Execute
.text$mn:000040E4 _text$mn        segment para public 'CODE' use32
.text$mn:000040E4                 assume cs:_text$mn
.text$mn:000040E4                 ;org 40E4h
.text$mn:000040E4 ; COMDAT (pick any)
.text$mn:000040E4                 assume es:nothing, ss:nothing, ds:_data, fs:nothing, gs:nothing
.text$mn:000040E4
.text$mn:000040E4 ; =============== S U B R O U T I N E =======================================
.text$mn:000040E4
.text$mn:000040E4 ; Attributes: bp-based frame
.text$mn:000040E4
.text$mn:000040E4 ; int __stdcall DockingDlgInterface::run_dlgProc(DockingDlgInterface *this, unsigned int, unsigned int, __int32)
.text$mn:000040E4                 public ?run_dlgProc@DockingDlgInterface@@MAGHIIJ@Z
.text$mn:000040E4 ?run_dlgProc@DockingDlgInterface@@MAGHIIJ@Z proc near
.text$mn:000040E4                                         ; CODE XREF: DocumentMap::run_dlgProc(uint,uint,long)+495p
.text$mn:000040E4                                         ; DocumentMap::run_dlgProc(uint,uint,long)+4ACp
.text$mn:000040E4
.text$mn:000040E4 var_C           = dword ptr -0Ch
.text$mn:000040E4 var_8           = dword ptr -8
.text$mn:000040E4 var_4           = dword ptr -4
.text$mn:000040E4 this            = dword ptr  8
.text$mn:000040E4 arg_4           = dword ptr  0Ch
.text$mn:000040E4 arg_C           = dword ptr  14h
.text$mn:000040E4
.text$mn:000040E4                 push    ebp
.text$mn:000040E5                 mov     ebp, esp
.text$mn:000040E7                 sub     esp, 0Ch
.text$mn:000040EA                 mov     eax, [ebp+arg_4]
.text$mn:000040ED                 mov     [ebp+var_C], eax
.text$mn:000040F0                 cmp     [ebp+var_C], 4Eh ; 'N'
.text$mn:000040F4                 jz      short loc_40F8
.text$mn:000040F6                 jmp     short loc_415A
.text$mn:000040F8 ; ---------------------------------------------------------------------------
.text$mn:000040F8
.text$mn:000040F8 loc_40F8:                               ; CODE XREF: DockingDlgInterface::run_dlgProc(uint,uint,long)+10j
.text$mn:000040F8                 mov     ecx, [ebp+arg_C]
.text$mn:000040FB                 mov     [ebp+var_4], ecx
.text$mn:000040FE                 mov     edx, [ebp+var_4]
.text$mn:00004101                 mov     eax, [ebp+this]
.text$mn:00004104                 mov     ecx, [edx]
.text$mn:00004106                 cmp     ecx, [eax+8]
.text$mn:00004109                 jnz     short loc_415A
.text$mn:0000410B                 mov     edx, [ebp+var_4]
.text$mn:0000410E                 mov     eax, [edx+8]
.text$mn:00004111                 and     eax, 0FFFFh
.text$mn:00004116                 movzx   ecx, ax
.text$mn:00004119                 mov     [ebp+var_8], ecx
.text$mn:0000411C                 cmp     [ebp+var_8], 41Ch
.text$mn:00004123                 jz      short loc_413B
.text$mn:00004125                 cmp     [ebp+var_8], 41Dh
.text$mn:0000412C                 jz      short loc_4132
.text$mn:0000412E                 jmp     short loc_415A
.text$mn:00004130 ; ---------------------------------------------------------------------------
.text$mn:00004130                 jmp     short loc_415A
.text$mn:00004132 ; ---------------------------------------------------------------------------
.text$mn:00004132
.text$mn:00004132 loc_4132:                               ; CODE XREF: DockingDlgInterface::run_dlgProc(uint,uint,long)+48j
.text$mn:00004132                 mov     edx, [ebp+this]
.text$mn:00004135                 mov     byte ptr [edx+28h], 1
.text$mn:00004139                 jmp     short loc_415A
.text$mn:0000413B ; ---------------------------------------------------------------------------
.text$mn:0000413B
.text$mn:0000413B loc_413B:                               ; CODE XREF: DockingDlgInterface::run_dlgProc(uint,uint,long)+3Fj
.text$mn:0000413B                 mov     eax, [ebp+var_4]
.text$mn:0000413E                 mov     ecx, [eax+8]
.text$mn:00004141                 shr     ecx, 10h
.text$mn:00004144                 and     ecx, 0FFFFh
.text$mn:0000414A                 movzx   edx, cx
.text$mn:0000414D                 mov     eax, [ebp+this]
.text$mn:00004150                 mov     [eax+2Ch], edx
.text$mn:00004153                 mov     ecx, [ebp+this]
.text$mn:00004156                 mov     byte ptr [ecx+28h], 0
.text$mn:0000415A
.text$mn:0000415A loc_415A:                               ; CODE XREF: DockingDlgInterface::run_dlgProc(uint,uint,long)+12j
.text$mn:0000415A                                         ; DockingDlgInterface::run_dlgProc(uint,uint,long)+25j ...
.text$mn:0000415A                 xor     eax, eax
.text$mn:0000415C                 mov     esp, ebp
.text$mn:0000415E                 pop     ebp
.text$mn:0000415F                 retn    10h
.text$mn:0000415F ?run_dlgProc@DockingDlgInterface@@MAGHIIJ@Z endp
.text$mn:0000415F
.text$mn:0000415F ; ---------------------------------------------------------------------------
.text$mn:00004162                 align 4
.text$mn:00004162 _text$mn        ends
.text$mn:00004162
.text$mn:00004164 ; ===========================================================================
.text$mn:00004164
.text$mn:00004164 ; Segment type: Pure code
.text$mn:00004164 ; Segment permissions: Read/Execute
.text$mn:00004164 _text$mn        segment para public 'CODE' use32
.text$mn:00004164                 assume cs:_text$mn
.text$mn:00004164                 ;org 4164h
.text$mn:00004164 ; COMDAT (pick any)
.text$mn:00004164                 assume es:nothing, ss:nothing, ds:_data, fs:nothing, gs:nothing
.text$mn:00004164
.text$mn:00004164 ; =============== S U B R O U T I N E =======================================
.text$mn:00004164
.text$mn:00004164 ; Attributes: bp-based frame
.text$mn:00004164
.text$mn:00004164 ; void __thiscall ScintillaEditView::setCurrentBuffer(ScintillaEditView *this, struct Buffer *)
.text$mn:00004164                 public ?setCurrentBuffer@ScintillaEditView@@QAEXPAVBuffer@@@Z
.text$mn:00004164 ?setCurrentBuffer@ScintillaEditView@@QAEXPAVBuffer@@@Z proc near
.text$mn:00004164                                         ; CODE XREF: DocumentMap::reloadMap(void)+8Bp
.text$mn:00004164
.text$mn:00004164 var_4           = dword ptr -4
.text$mn:00004164 arg_0           = dword ptr  8
.text$mn:00004164
.text$mn:00004164                 push    ebp
.text$mn:00004165                 mov     ebp, esp
.text$mn:00004167                 push    ecx
.text$mn:00004168                 mov     [ebp+var_4], ecx
.text$mn:0000416B                 mov     eax, [ebp+var_4]
.text$mn:0000416E                 mov     ecx, [ebp+arg_0]
.text$mn:00004171                 mov     [eax+20h], ecx
.text$mn:00004174                 mov     esp, ebp
.text$mn:00004176                 pop     ebp
.text$mn:00004177                 retn    4
.text$mn:00004177 ?setCurrentBuffer@ScintillaEditView@@QAEXPAVBuffer@@@Z endp
.text$mn:00004177
.text$mn:00004177 ; ---------------------------------------------------------------------------
.text$mn:0000417A                 align 4
.text$mn:0000417A _text$mn        ends
.text$mn:0000417A
.text$mn:0000417C ; ===========================================================================
.text$mn:0000417C
.text$mn:0000417C ; Segment type: Pure code
.text$mn:0000417C ; Segment permissions: Read/Execute
.text$mn:0000417C _text$mn        segment para public 'CODE' use32
.text$mn:0000417C                 assume cs:_text$mn
.text$mn:0000417C                 ;org 417Ch
.text$mn:0000417C ; COMDAT (pick any)
.text$mn:0000417C                 assume es:nothing, ss:nothing, ds:_data, fs:nothing, gs:nothing
.text$mn:0000417C
.text$mn:0000417C ; =============== S U B R O U T I N E =======================================
.text$mn:0000417C
.text$mn:0000417C ; Attributes: bp-based frame
.text$mn:0000417C
.text$mn:0000417C ; void __thiscall ScintillaEditView::showIndentGuideLine(ScintillaEditView *this, bool)
.text$mn:0000417C                 public ?showIndentGuideLine@ScintillaEditView@@QAEX_N@Z
.text$mn:0000417C ?showIndentGuideLine@ScintillaEditView@@QAEX_N@Z proc near
.text$mn:0000417C                                         ; CODE XREF: DocumentMap::run_dlgProc(uint,uint,long)+EDp
.text$mn:0000417C
.text$mn:0000417C var_8           = dword ptr -8
.text$mn:0000417C var_4           = dword ptr -4
.text$mn:0000417C arg_0           = byte ptr  8
.text$mn:0000417C
.text$mn:0000417C                 push    ebp
.text$mn:0000417D                 mov     ebp, esp
.text$mn:0000417F                 sub     esp, 8
.text$mn:00004182                 mov     [ebp+var_8], ecx
.text$mn:00004185                 movzx   eax, [ebp+arg_0]
.text$mn:00004189                 test    eax, eax
.text$mn:0000418B                 jz      short loc_4196
.text$mn:0000418D                 mov     [ebp+var_4], 3
.text$mn:00004194                 jmp     short loc_419D
.text$mn:00004196 ; ---------------------------------------------------------------------------
.text$mn:00004196
.text$mn:00004196 loc_4196:                               ; CODE XREF: ScintillaEditView::showIndentGuideLine(bool)+Fj
.text$mn:00004196                 mov     [ebp+var_4], 0
.text$mn:0000419D
.text$mn:0000419D loc_419D:                               ; CODE XREF: ScintillaEditView::showIndentGuideLine(bool)+18j
.text$mn:0000419D                 push    0               ; __int32
.text$mn:0000419F                 mov     ecx, [ebp+var_4]
.text$mn:000041A2                 push    ecx             ; unsigned int
.text$mn:000041A3                 push    854h            ; unsigned int
.text$mn:000041A8                 mov     ecx, [ebp+var_8] ; this
.text$mn:000041AB                 call    ?execute@ScintillaEditView@@QBEJIIJ@Z ; ScintillaEditView::execute(uint,uint,long)
.text$mn:000041B0                 mov     esp, ebp
.text$mn:000041B2                 pop     ebp
.text$mn:000041B3                 retn    4
.text$mn:000041B3 ?showIndentGuideLine@ScintillaEditView@@QAEX_N@Z endp
.text$mn:000041B3
.text$mn:000041B3 ; ---------------------------------------------------------------------------
.text$mn:000041B6                 align 4
.text$mn:000041B6 _text$mn        ends
.text$mn:000041B6
.text$mn:000041B8 ; ===========================================================================
.text$mn:000041B8
.text$mn:000041B8 ; Segment type: Pure code
.text$mn:000041B8 ; Segment permissions: Read/Execute
.text$mn:000041B8 _text$mn        segment para public 'CODE' use32
.text$mn:000041B8                 assume cs:_text$mn
.text$mn:000041B8                 ;org 41B8h
.text$mn:000041B8 ; COMDAT (pick any)
.text$mn:000041B8                 assume es:nothing, ss:nothing, ds:_data, fs:nothing, gs:nothing
.text$mn:000041B8
.text$mn:000041B8 ; =============== S U B R O U T I N E =======================================
.text$mn:000041B8
.text$mn:000041B8 ; Attributes: bp-based frame
.text$mn:000041B8
.text$mn:000041B8 ; void __thiscall ScintillaEditView::showLineNumbersMargin(ScintillaEditView *this, bool)
.text$mn:000041B8                 public ?showLineNumbersMargin@ScintillaEditView@@QAEX_N@Z
.text$mn:000041B8 ?showLineNumbersMargin@ScintillaEditView@@QAEX_N@Z proc near
.text$mn:000041B8                                         ; CODE XREF: ScintillaEditView::showMargin(int,bool)+1Cp
.text$mn:000041B8
.text$mn:000041B8 var_4           = dword ptr -4
.text$mn:000041B8 arg_0           = byte ptr  8
.text$mn:000041B8
.text$mn:000041B8                 push    ebp
.text$mn:000041B9                 mov     ebp, esp
.text$mn:000041BB                 push    ecx
.text$mn:000041BC                 mov     [ebp+var_4], ecx
.text$mn:000041BF                 movzx   eax, [ebp+arg_0]
.text$mn:000041C3                 mov     ecx, [ebp+var_4]
.text$mn:000041C6                 movzx   edx, byte ptr [ecx+2Ch]
.text$mn:000041CA                 cmp     eax, edx
.text$mn:000041CC                 jnz     short loc_41D0
.text$mn:000041CE                 jmp     short loc_4200
.text$mn:000041D0 ; ---------------------------------------------------------------------------
.text$mn:000041D0
.text$mn:000041D0 loc_41D0:                               ; CODE XREF: ScintillaEditView::showLineNumbersMargin(bool)+14j
.text$mn:000041D0                 mov     eax, [ebp+var_4]
.text$mn:000041D3                 mov     cl, [ebp+arg_0]
.text$mn:000041D6                 mov     [eax+2Ch], cl
.text$mn:000041D9                 movzx   edx, [ebp+arg_0]
.text$mn:000041DD                 test    edx, edx
.text$mn:000041DF                 jz      short loc_41EB
.text$mn:000041E1                 mov     ecx, [ebp+var_4] ; this
.text$mn:000041E4                 call    ?updateLineNumberWidth@ScintillaEditView@@QAEXXZ ; ScintillaEditView::updateLineNumberWidth(void)
.text$mn:000041E9                 jmp     short loc_4200
.text$mn:000041EB ; ---------------------------------------------------------------------------
.text$mn:000041EB
.text$mn:000041EB loc_41EB:                               ; CODE XREF: ScintillaEditView::showLineNumbersMargin(bool)+27j
.text$mn:000041EB                 push    0               ; __int32
.text$mn:000041ED                 mov     eax, dword ptr ds:?_SC_MARGE_LINENUMBER@ScintillaEditView@@2HB ; int const ScintillaEditView::_SC_MARGE_LINENUMBER
.text$mn:000041F2                 push    eax             ; unsigned int
.text$mn:000041F3                 push    8C2h            ; unsigned int
.text$mn:000041F8                 mov     ecx, [ebp+var_4] ; this
.text$mn:000041FB                 call    ?execute@ScintillaEditView@@QBEJIIJ@Z ; ScintillaEditView::execute(uint,uint,long)
.text$mn:00004200
.text$mn:00004200 loc_4200:                               ; CODE XREF: ScintillaEditView::showLineNumbersMargin(bool)+16j
.text$mn:00004200                                         ; ScintillaEditView::showLineNumbersMargin(bool)+31j
.text$mn:00004200                 mov     esp, ebp
.text$mn:00004202                 pop     ebp
.text$mn:00004203                 retn    4
.text$mn:00004203 ?showLineNumbersMargin@ScintillaEditView@@QAEX_N@Z endp
.text$mn:00004203
.text$mn:00004203 ; ---------------------------------------------------------------------------
.text$mn:00004206                 align 4
.text$mn:00004206 _text$mn        ends
.text$mn:00004206
.text$mn:00004208 ; ===========================================================================
.text$mn:00004208
.text$mn:00004208 ; Segment type: Pure code
.text$mn:00004208 ; Segment permissions: Read/Execute
.text$mn:00004208 _text$mn        segment para public 'CODE' use32
.text$mn:00004208                 assume cs:_text$mn
.text$mn:00004208                 ;org 4208h
.text$mn:00004208 ; COMDAT (pick any)
.text$mn:00004208                 assume es:nothing, ss:nothing, ds:_data, fs:nothing, gs:nothing
.text$mn:00004208
.text$mn:00004208 ; =============== S U B R O U T I N E =======================================
.text$mn:00004208
.text$mn:00004208 ; Attributes: bp-based frame
.text$mn:00004208
.text$mn:00004208 ; void __thiscall ScintillaEditView::showMargin(ScintillaEditView *this, unsigned int, bool)
.text$mn:00004208                 public ?showMargin@ScintillaEditView@@QAEXH_N@Z
.text$mn:00004208 ?showMargin@ScintillaEditView@@QAEXH_N@Z proc near
.text$mn:00004208                                         ; CODE XREF: DocumentMap::setSyntaxHiliting(void)+3Ap
.text$mn:00004208                                         ; DocumentMap::run_dlgProc(uint,uint,long)+167p ...
.text$mn:00004208
.text$mn:00004208 var_C           = dword ptr -0Ch
.text$mn:00004208 var_8           = dword ptr -8
.text$mn:00004208 var_4           = dword ptr -4
.text$mn:00004208 arg_0           = dword ptr  8
.text$mn:00004208 arg_4           = byte ptr  0Ch
.text$mn:00004208
.text$mn:00004208                 push    ebp
.text$mn:00004209                 mov     ebp, esp
.text$mn:0000420B                 sub     esp, 0Ch
.text$mn:0000420E                 mov     [ebp+var_C], ecx
.text$mn:00004211                 mov     eax, [ebp+arg_0]
.text$mn:00004214                 cmp     eax, dword ptr ds:?_SC_MARGE_LINENUMBER@ScintillaEditView@@2HB ; int const ScintillaEditView::_SC_MARGE_LINENUMBER
.text$mn:0000421A                 jnz     short loc_422B
.text$mn:0000421C                 movzx   ecx, [ebp+arg_4]
.text$mn:00004220                 push    ecx             ; bool
.text$mn:00004221                 mov     ecx, [ebp+var_C] ; this
.text$mn:00004224                 call    ?showLineNumbersMargin@ScintillaEditView@@QAEX_N@Z ; ScintillaEditView::showLineNumbersMargin(bool)
.text$mn:00004229                 jmp     short loc_427B
.text$mn:0000422B ; ---------------------------------------------------------------------------
.text$mn:0000422B
.text$mn:0000422B loc_422B:                               ; CODE XREF: ScintillaEditView::showMargin(int,bool)+12j
.text$mn:0000422B                 mov     [ebp+var_4], 3
.text$mn:00004232                 mov     edx, [ebp+arg_0]
.text$mn:00004235                 cmp     edx, dword ptr ds:?_SC_MARGE_SYBOLE@ScintillaEditView@@2HB ; int const ScintillaEditView::_SC_MARGE_SYBOLE
.text$mn:0000423B                 jz      short loc_4248
.text$mn:0000423D                 mov     eax, [ebp+arg_0]
.text$mn:00004240                 cmp     eax, dword ptr ds:?_SC_MARGE_FOLDER@ScintillaEditView@@2HB ; int const ScintillaEditView::_SC_MARGE_FOLDER
.text$mn:00004246                 jnz     short loc_424F
.text$mn:00004248
.text$mn:00004248 loc_4248:                               ; CODE XREF: ScintillaEditView::showMargin(int,bool)+33j
.text$mn:00004248                 mov     [ebp+var_4], 0Eh
.text$mn:0000424F
.text$mn:0000424F loc_424F:                               ; CODE XREF: ScintillaEditView::showMargin(int,bool)+3Ej
.text$mn:0000424F                 movzx   ecx, [ebp+arg_4]
.text$mn:00004253                 test    ecx, ecx
.text$mn:00004255                 jz      short loc_425F
.text$mn:00004257                 mov     edx, [ebp+var_4]
.text$mn:0000425A                 mov     [ebp+var_8], edx
.text$mn:0000425D                 jmp     short loc_4266
.text$mn:0000425F ; ---------------------------------------------------------------------------
.text$mn:0000425F
.text$mn:0000425F loc_425F:                               ; CODE XREF: ScintillaEditView::showMargin(int,bool)+4Dj
.text$mn:0000425F                 mov     [ebp+var_8], 0
.text$mn:00004266
.text$mn:00004266 loc_4266:                               ; CODE XREF: ScintillaEditView::showMargin(int,bool)+55j
.text$mn:00004266                 mov     eax, [ebp+var_8]
.text$mn:00004269                 push    eax             ; __int32
.text$mn:0000426A                 mov     ecx, [ebp+arg_0]
.text$mn:0000426D                 push    ecx             ; unsigned int
.text$mn:0000426E                 push    8C2h            ; unsigned int
.text$mn:00004273                 mov     ecx, [ebp+var_C] ; this
.text$mn:00004276                 call    ?execute@ScintillaEditView@@QBEJIIJ@Z ; ScintillaEditView::execute(uint,uint,long)
.text$mn:0000427B
.text$mn:0000427B loc_427B:                               ; CODE XREF: ScintillaEditView::showMargin(int,bool)+21j
.text$mn:0000427B                 mov     esp, ebp
.text$mn:0000427D                 pop     ebp
.text$mn:0000427E                 retn    8
.text$mn:0000427E ?showMargin@ScintillaEditView@@QAEXH_N@Z endp
.text$mn:0000427E
.text$mn:0000427E ; ---------------------------------------------------------------------------
.text$mn:00004281                 align 4
.text$mn:00004281 _text$mn        ends
.text$mn:00004281
.text$mn:00004284 ; ===========================================================================
.text$mn:00004284
.text$mn:00004284 ; Segment type: Pure code
.text$mn:00004284 ; Segment permissions: Read/Execute
.text$mn:00004284 _text$mn        segment para public 'CODE' use32
.text$mn:00004284                 assume cs:_text$mn
.text$mn:00004284                 ;org 4284h
.text$mn:00004284 ; COMDAT (pick any)
.text$mn:00004284                 assume es:nothing, ss:nothing, ds:_data, fs:nothing, gs:nothing
.text$mn:00004284
.text$mn:00004284 ; =============== S U B R O U T I N E =======================================
.text$mn:00004284
.text$mn:00004284 ; Attributes: bp-based frame
.text$mn:00004284
.text$mn:00004284 ; public: unsigned int __thiscall std::basic_string<char, struct std::char_traits<char>, class std::allocator<char>>::size(void)const
.text$mn:00004284                 public ?size@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QBEIXZ
.text$mn:00004284 ?size@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QBEIXZ proc near
.text$mn:00004284                                         ; CODE XREF: std::basic_string<char,std::char_traits<char>,std::allocator<char>>::assign(std::basic_string<char,std::char_traits<char>,std::allocator<char>> const &,uint,uint)+Cp
.text$mn:00004284                                         ; std::basic_string<char,std::char_traits<char>,std::allocator<char>>::assign(std::basic_string<char,std::char_traits<char>,std::allocator<char>> const &,uint,uint)+21p
.text$mn:00004284
.text$mn:00004284 var_4           = dword ptr -4
.text$mn:00004284
.text$mn:00004284                 push    ebp
.text$mn:00004285                 mov     ebp, esp
.text$mn:00004287                 push    ecx
.text$mn:00004288                 mov     [ebp+var_4], ecx
.text$mn:0000428B                 mov     eax, [ebp+var_4]
.text$mn:0000428E                 mov     eax, [eax+14h]
.text$mn:00004291                 mov     esp, ebp
.text$mn:00004293                 pop     ebp
.text$mn:00004294                 retn
.text$mn:00004294 ?size@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QBEIXZ endp
.text$mn:00004294
.text$mn:00004294 ; ---------------------------------------------------------------------------
.text$mn:00004295                 align 4
.text$mn:00004295 _text$mn        ends
.text$mn:00004295
.text$mn:00004298 ; ===========================================================================
.text$mn:00004298
.text$mn:00004298 ; Segment type: Pure code
.text$mn:00004298 ; Segment permissions: Read/Execute
.text$mn:00004298 _text$mn        segment para public 'CODE' use32
.text$mn:00004298                 assume cs:_text$mn
.text$mn:00004298                 ;org 4298h
.text$mn:00004298 ; COMDAT (pick any)
.text$mn:00004298                 assume es:nothing, ss:nothing, ds:_data, fs:nothing, gs:nothing
.text$mn:00004298
.text$mn:00004298 ; =============== S U B R O U T I N E =======================================
.text$mn:00004298
.text$mn:00004298 ; Attributes: bp-based frame
.text$mn:00004298
.text$mn:00004298 ; const struct std::error_category *__cdecl std::system_category()
.text$mn:00004298                 public ?system_category@std@@YAABVerror_category@1@XZ
.text$mn:00004298 ?system_category@std@@YAABVerror_category@1@XZ proc near
.text$mn:00004298                                         ; CODE XREF: std::_System_error_category::default_error_condition(int):loc_3AF8p
.text$mn:00004298                 push    ebp
.text$mn:00004299                 mov     ebp, esp
.text$mn:0000429B                 mov     eax, offset ?_System_object@?$_Error_objects@H@std@@2V_System_error_category@2@A ; std::_System_error_category std::_Error_objects<int>::_System_object
.text$mn:000042A0                 pop     ebp
.text$mn:000042A1                 retn
.text$mn:000042A1 ?system_category@std@@YAABVerror_category@1@XZ endp
.text$mn:000042A1
.text$mn:000042A1 ; ---------------------------------------------------------------------------
.text$mn:000042A2                 align 4
.text$mn:000042A2 _text$mn        ends
.text$mn:000042A2
.text$mn:000042A4 ; ===========================================================================
.text$mn:000042A4
.text$mn:000042A4 ; Segment type: Pure code
.text$mn:000042A4 ; Segment permissions: Read/Execute
.text$mn:000042A4 _text$mn        segment para public 'CODE' use32
.text$mn:000042A4                 assume cs:_text$mn
.text$mn:000042A4                 ;org 42A4h
.text$mn:000042A4 ; COMDAT (pick any)
.text$mn:000042A4                 assume es:nothing, ss:nothing, ds:_data, fs:nothing, gs:nothing
.text$mn:000042A4
.text$mn:000042A4 ; =============== S U B R O U T I N E =======================================
.text$mn:000042A4
.text$mn:000042A4 ; Attributes: bp-based frame
.text$mn:000042A4
.text$mn:000042A4 ; int __thiscall std::error_code::value(std::error_code *__hidden this)
.text$mn:000042A4                 public ?value@error_code@std@@QBEHXZ
.text$mn:000042A4 ?value@error_code@std@@QBEHXZ proc near ; CODE XREF: std::error_category::equivalent(std::error_code const &,int)+24p
.text$mn:000042A4
.text$mn:000042A4 var_4           = dword ptr -4
.text$mn:000042A4
.text$mn:000042A4                 push    ebp
.text$mn:000042A5                 mov     ebp, esp
.text$mn:000042A7                 push    ecx
.text$mn:000042A8                 mov     [ebp+var_4], ecx
.text$mn:000042AB                 mov     eax, [ebp+var_4]
.text$mn:000042AE                 mov     eax, [eax]
.text$mn:000042B0                 mov     esp, ebp
.text$mn:000042B2                 pop     ebp
.text$mn:000042B3                 retn
.text$mn:000042B3 ?value@error_code@std@@QBEHXZ endp
.text$mn:000042B3
.text$mn:000042B3 _text$mn        ends
.text$mn:000042B3
.text$mn:000042B4 ; ===========================================================================
.text$mn:000042B4
.text$mn:000042B4 ; Segment type: Pure code
.text$mn:000042B4 ; Segment permissions: Read/Execute
.text$mn:000042B4 _text$mn        segment para public 'CODE' use32
.text$mn:000042B4                 assume cs:_text$mn
.text$mn:000042B4                 ;org 42B4h
.text$mn:000042B4 ; COMDAT (pick any)
.text$mn:000042B4                 assume es:nothing, ss:nothing, ds:_data, fs:nothing, gs:nothing
.text$mn:000042B4
.text$mn:000042B4 ; =============== S U B R O U T I N E =======================================
.text$mn:000042B4
.text$mn:000042B4 ; Attributes: bp-based frame
.text$mn:000042B4
.text$mn:000042B4 ; int __thiscall std::error_condition::value(std::error_condition *__hidden this)
.text$mn:000042B4                 public ?value@error_condition@std@@QBEHXZ
.text$mn:000042B4 ?value@error_condition@std@@QBEHXZ proc near
.text$mn:000042B4                                         ; CODE XREF: std::error_condition::operator==(std::error_condition const &)+2Cp
.text$mn:000042B4                                         ; std::error_condition::operator==(std::error_condition const &)+36p
.text$mn:000042B4
.text$mn:000042B4 var_4           = dword ptr -4
.text$mn:000042B4
.text$mn:000042B4                 push    ebp
.text$mn:000042B5                 mov     ebp, esp
.text$mn:000042B7                 push    ecx
.text$mn:000042B8                 mov     [ebp+var_4], ecx
.text$mn:000042BB                 mov     eax, [ebp+var_4]
.text$mn:000042BE                 mov     eax, [eax]
.text$mn:000042C0                 mov     esp, ebp
.text$mn:000042C2                 pop     ebp
.text$mn:000042C3                 retn
.text$mn:000042C3 ?value@error_condition@std@@QBEHXZ endp
.text$mn:000042C3
.text$mn:000042C3 _text$mn        ends
.text$mn:000042C3
.text$mn:000042C4 ; ===========================================================================
.text$mn:000042C4
.text$mn:000042C4 ; Segment type: Pure code
.text$mn:000042C4 ; Segment permissions: Read/Execute
.text$mn:000042C4 _text$mn        segment para public 'CODE' use32
.text$mn:000042C4                 assume cs:_text$mn
.text$mn:000042C4                 ;org 42C4h
.text$mn:000042C4 ; COMDAT (pick any)
.text$mn:000042C4                 assume es:nothing, ss:nothing, ds:_data, fs:nothing, gs:nothing
.text$mn:000042C4
.text$mn:000042C4 ; =============== S U B R O U T I N E =======================================
.text$mn:000042C4
.text$mn:000042C4 ; Attributes: bp-based frame
.text$mn:000042C4
.text$mn:000042C4 ; void __thiscall ScintillaEditView::wrap(ScintillaEditView *this, bool)
.text$mn:000042C4                 public ?wrap@ScintillaEditView@@QAEX_N@Z
.text$mn:000042C4 ?wrap@ScintillaEditView@@QAEX_N@Z proc near
.text$mn:000042C4                                         ; CODE XREF: DocumentMap::wrapMap(void)+C5p
.text$mn:000042C4                                         ; DocumentMap::initWrapMap(void)+6Cp
.text$mn:000042C4
.text$mn:000042C4 var_4           = dword ptr -4
.text$mn:000042C4 arg_0           = byte ptr  8
.text$mn:000042C4
.text$mn:000042C4                 push    ebp
.text$mn:000042C5                 mov     ebp, esp
.text$mn:000042C7                 push    ecx
.text$mn:000042C8                 mov     [ebp+var_4], ecx
.text$mn:000042CB                 push    0               ; __int32
.text$mn:000042CD                 movzx   eax, [ebp+arg_0]
.text$mn:000042D1                 push    eax             ; unsigned int
.text$mn:000042D2                 push    8DCh            ; unsigned int
.text$mn:000042D7                 mov     ecx, [ebp+var_4] ; this
.text$mn:000042DA                 call    ?execute@ScintillaEditView@@QBEJIIJ@Z ; ScintillaEditView::execute(uint,uint,long)
.text$mn:000042DF                 mov     esp, ebp
.text$mn:000042E1                 pop     ebp
.text$mn:000042E2                 retn    4
.text$mn:000042E2 ?wrap@ScintillaEditView@@QAEX_N@Z endp
.text$mn:000042E2
.text$mn:000042E2 ; ---------------------------------------------------------------------------
.text$mn:000042E5                 align 4
.text$mn:000042E5 _text$mn        ends
.text$mn:000042E5
.text$mn:000042E8 ; ===========================================================================
.text$mn:000042E8
.text$mn:000042E8 ; Segment type: Pure code
.text$mn:000042E8 ; Segment permissions: Read/Execute
.text$mn:000042E8 _text$mn        segment para public 'CODE' use32
.text$mn:000042E8                 assume cs:_text$mn
.text$mn:000042E8                 ;org 42E8h
.text$mn:000042E8 ; COMDAT (pick any)
.text$mn:000042E8                 assume es:nothing, ss:nothing, ds:_data, fs:nothing, gs:nothing
.text$mn:000042E8
.text$mn:000042E8 ; =============== S U B R O U T I N E =======================================
.text$mn:000042E8
.text$mn:000042E8 ; Attributes: bp-based frame
.text$mn:000042E8
.text$mn:000042E8                 public _hypot
.text$mn:000042E8 _hypot          proc near
.text$mn:000042E8
.text$mn:000042E8 var_10          = qword ptr -10h
.text$mn:000042E8 var_8           = qword ptr -8
.text$mn:000042E8 arg_0           = qword ptr  8
.text$mn:000042E8 arg_8           = qword ptr  10h
.text$mn:000042E8
.text$mn:000042E8                 push    ebp
.text$mn:000042E9                 mov     ebp, esp
.text$mn:000042EB                 sub     esp, 8
.text$mn:000042EE                 movsd   xmm0, [ebp+arg_8]
.text$mn:000042F3                 movsd   [esp+8+var_8], xmm0
.text$mn:000042F8                 sub     esp, 8
.text$mn:000042FB                 movsd   xmm0, [ebp+arg_0]
.text$mn:00004300                 movsd   [esp+10h+var_10], xmm0
.text$mn:00004305                 call    __hypot
.text$mn:0000430A                 add     esp, 10h
.text$mn:0000430D                 pop     ebp
.text$mn:0000430E                 retn
.text$mn:0000430E _hypot          endp
.text$mn:0000430E
.text$mn:0000430E ; ---------------------------------------------------------------------------
.text$mn:0000430F                 align 10h
.text$mn:0000430F _text$mn        ends
.text$mn:0000430F
.xdata$x:00004310 ; ===========================================================================
.xdata$x:00004310
.xdata$x:00004310 ; Segment type: Pure data
.xdata$x:00004310 ; Segment permissions: Read
.xdata$x:00004310 _xdata$x        segment dword public 'DATA' use32
.xdata$x:00004310                 assume cs:_xdata$x
.xdata$x:00004310                 ;org 4310h
.xdata$x:00004310 ; COMDAT (pick associative to section at 35A8)
.xdata$x:00004310 __unwindtable$?_Orphan_all@_Container_base12@std@@QAEXXZ db 0FFh
.xdata$x:00004310                                         ; DATA XREF: .xdata$x:00004320o
.xdata$x:00004311                 db 0FFh
.xdata$x:00004312                 db 0FFh
.xdata$x:00004313                 db 0FFh
.xdata$x:00004314                 dd offset __unwindfunclet$?_Orphan_all@_Container_base12@std@@QAEXXZ$0
.xdata$x:00004318 __ehfuncinfo$?_Orphan_all@_Container_base12@std@@QAEXXZ db  22h ; "
.xdata$x:00004318                                         ; DATA XREF: __ehhandler$?_Orphan_all@_Container_base12@std@@QAEXXZ+11o
.xdata$x:00004319                 db    5
.xdata$x:0000431A                 db  93h ; Ã´
.xdata$x:0000431B                 db  19h
.xdata$x:0000431C                 db    1
.xdata$x:0000431D                 db    0
.xdata$x:0000431E                 db    0
.xdata$x:0000431F                 db    0
.xdata$x:00004320                 dd offset __unwindtable$?_Orphan_all@_Container_base12@std@@QAEXXZ
.xdata$x:00004324                 db    0
.xdata$x:00004325                 db    0
.xdata$x:00004326                 db    0
.xdata$x:00004327                 db    0
.xdata$x:00004328                 db    0
.xdata$x:00004329                 db    0
.xdata$x:0000432A                 db    0
.xdata$x:0000432B                 db    0
.xdata$x:0000432C                 db    0
.xdata$x:0000432D                 db    0
.xdata$x:0000432E                 db    0
.xdata$x:0000432F                 db    0
.xdata$x:00004330                 db    0
.xdata$x:00004331                 db    0
.xdata$x:00004332                 db    0
.xdata$x:00004333                 db    0
.xdata$x:00004334                 db    0
.xdata$x:00004335                 db    0
.xdata$x:00004336                 db    0
.xdata$x:00004337                 db    0
.xdata$x:00004338                 db    0
.xdata$x:00004339                 db    0
.xdata$x:0000433A                 db    0
.xdata$x:0000433B                 db    0
.xdata$x:0000433B _xdata$x        ends
.xdata$x:0000433B
.xdata$x:0000433C ; ===========================================================================
.xdata$x:0000433C
.xdata$x:0000433C ; Segment type: Pure data
.xdata$x:0000433C ; Segment permissions: Read
.xdata$x:0000433C _xdata$x        segment dword public 'DATA' use32
.xdata$x:0000433C                 assume cs:_xdata$x
.xdata$x:0000433C                 ;org 433Ch
.xdata$x:0000433C ; COMDAT (pick associative to section at 24A8)
.xdata$x:0000433C __unwindtable$??0?$_String_val@U?$_Simple_types@D@std@@@std@@QAE@XZ db 0FFh
.xdata$x:0000433C                                         ; DATA XREF: .xdata$x:0000434Co
.xdata$x:0000433D                 db 0FFh
.xdata$x:0000433E                 db 0FFh
.xdata$x:0000433F                 db 0FFh
.xdata$x:00004340                 dd offset __unwindfunclet$??0?$_String_val@U?$_Simple_types@D@std@@@std@@QAE@XZ$0
.xdata$x:00004344 __ehfuncinfo$??0?$_String_val@U?$_Simple_types@D@std@@@std@@QAE@XZ db  22h ; "
.xdata$x:00004344                                         ; DATA XREF: __ehhandler$??0?$_String_val@U?$_Simple_types@D@std@@@std@@QAE@XZ+11o
.xdata$x:00004345                 db    5
.xdata$x:00004346                 db  93h ; Ã´
.xdata$x:00004347                 db  19h
.xdata$x:00004348                 db    1
.xdata$x:00004349                 db    0
.xdata$x:0000434A                 db    0
.xdata$x:0000434B                 db    0
.xdata$x:0000434C                 dd offset __unwindtable$??0?$_String_val@U?$_Simple_types@D@std@@@std@@QAE@XZ
.xdata$x:00004350                 db    0
.xdata$x:00004351                 db    0
.xdata$x:00004352                 db    0
.xdata$x:00004353                 db    0
.xdata$x:00004354                 db    0
.xdata$x:00004355                 db    0
.xdata$x:00004356                 db    0
.xdata$x:00004357                 db    0
.xdata$x:00004358                 db    0
.xdata$x:00004359                 db    0
.xdata$x:0000435A                 db    0
.xdata$x:0000435B                 db    0
.xdata$x:0000435C                 db    0
.xdata$x:0000435D                 db    0
.xdata$x:0000435E                 db    0
.xdata$x:0000435F                 db    0
.xdata$x:00004360                 db    0
.xdata$x:00004361                 db    0
.xdata$x:00004362                 db    0
.xdata$x:00004363                 db    0
.xdata$x:00004364                 db    0
.xdata$x:00004365                 db    0
.xdata$x:00004366                 db    0
.xdata$x:00004367                 db    0
.xdata$x:00004367 _xdata$x        ends
.xdata$x:00004367
.xdata$x:00004368 ; ===========================================================================
.xdata$x:00004368
.xdata$x:00004368 ; Segment type: Pure data
.xdata$x:00004368 ; Segment permissions: Read
.xdata$x:00004368 _xdata$x        segment dword public 'DATA' use32
.xdata$x:00004368                 assume cs:_xdata$x
.xdata$x:00004368                 ;org 4368h
.xdata$x:00004368 ; COMDAT (pick associative to section at 2A58)
.xdata$x:00004368 __unwindtable$??1?$_String_val@U?$_Simple_types@D@std@@@std@@QAE@XZ db 0FFh
.xdata$x:00004368                                         ; DATA XREF: .xdata$x:00004378o
.xdata$x:00004369                 db 0FFh
.xdata$x:0000436A                 db 0FFh
.xdata$x:0000436B                 db 0FFh
.xdata$x:0000436C                 dd offset __unwindfunclet$??1?$_String_val@U?$_Simple_types@D@std@@@std@@QAE@XZ$0
.xdata$x:00004370 __ehfuncinfo$??1?$_String_val@U?$_Simple_types@D@std@@@std@@QAE@XZ db  22h ; "
.xdata$x:00004370                                         ; DATA XREF: __ehhandler$??1?$_String_val@U?$_Simple_types@D@std@@@std@@QAE@XZ+11o
.xdata$x:00004371                 db    5
.xdata$x:00004372                 db  93h ; Ã´
.xdata$x:00004373                 db  19h
.xdata$x:00004374                 db    1
.xdata$x:00004375                 db    0
.xdata$x:00004376                 db    0
.xdata$x:00004377                 db    0
.xdata$x:00004378                 dd offset __unwindtable$??1?$_String_val@U?$_Simple_types@D@std@@@std@@QAE@XZ
.xdata$x:0000437C                 db    0
.xdata$x:0000437D                 db    0
.xdata$x:0000437E                 db    0
.xdata$x:0000437F                 db    0
.xdata$x:00004380                 db    0
.xdata$x:00004381                 db    0
.xdata$x:00004382                 db    0
.xdata$x:00004383                 db    0
.xdata$x:00004384                 db    0
.xdata$x:00004385                 db    0
.xdata$x:00004386                 db    0
.xdata$x:00004387                 db    0
.xdata$x:00004388                 db    0
.xdata$x:00004389                 db    0
.xdata$x:0000438A                 db    0
.xdata$x:0000438B                 db    0
.xdata$x:0000438C                 db    0
.xdata$x:0000438D                 db    0
.xdata$x:0000438E                 db    0
.xdata$x:0000438F                 db    0
.xdata$x:00004390                 db    0
.xdata$x:00004391                 db    0
.xdata$x:00004392                 db    0
.xdata$x:00004393                 db    0
.xdata$x:00004393 _xdata$x        ends
.xdata$x:00004393
.xdata$x:00004394 ; ===========================================================================
.xdata$x:00004394
.xdata$x:00004394 ; Segment type: Pure data
.xdata$x:00004394 ; Segment permissions: Read
.xdata$x:00004394 _xdata$x        segment dword public 'DATA' use32
.xdata$x:00004394                 assume cs:_xdata$x
.xdata$x:00004394                 ;org 4394h
.xdata$x:00004394 ; COMDAT (pick associative to section at 242C)
.xdata$x:00004394 __unwindtable$??0?$_String_alloc@$0A@U?$_String_base_types@DV?$allocator@D@std@@@std@@@std@@QAE@ABV?$allocator@D@1@@Z db 0FFh
.xdata$x:00004394                                         ; DATA XREF: .xdata$x:000043A4o
.xdata$x:00004395                 db 0FFh
.xdata$x:00004396                 db 0FFh
.xdata$x:00004397                 db 0FFh
.xdata$x:00004398                 dd offset __unwindfunclet$??0?$_String_alloc@$0A@U?$_String_base_types@DV?$allocator@D@std@@@std@@@std@@QAE@ABV?$allocator@D@1@@Z$0
.xdata$x:0000439C __ehfuncinfo$??0?$_String_alloc@$0A@U?$_String_base_types@DV?$allocator@D@std@@@std@@@std@@QAE@ABV?$allocator@D@1@@Z db  22h ; "
.xdata$x:0000439C                                         ; DATA XREF: __ehhandler$??0?$_String_alloc@$0A@U?$_String_base_types@DV?$allocator@D@std@@@std@@@std@@QAE@ABV?$allocator@D@1@@Z+11o
.xdata$x:0000439D                 db    5
.xdata$x:0000439E                 db  93h ; Ã´
.xdata$x:0000439F                 db  19h
.xdata$x:000043A0                 db    1
.xdata$x:000043A1                 db    0
.xdata$x:000043A2                 db    0
.xdata$x:000043A3                 db    0
.xdata$x:000043A4                 dd offset __unwindtable$??0?$_String_alloc@$0A@U?$_String_base_types@DV?$allocator@D@std@@@std@@@std@@QAE@ABV?$allocator@D@1@@Z
.xdata$x:000043A8                 align 20h
.xdata$x:000043A8 _xdata$x        ends
.xdata$x:000043A8
.xdata$x:000043C0 ; ===========================================================================
.xdata$x:000043C0
.xdata$x:000043C0 ; Segment type: Pure data
.xdata$x:000043C0 ; Segment permissions: Read
.xdata$x:000043C0 _xdata$x        segment dword public 'DATA' use32
.xdata$x:000043C0                 assume cs:_xdata$x
.xdata$x:000043C0                 ;org 43C0h
.xdata$x:000043C0 ; COMDAT (pick associative to section at 29E0)
.xdata$x:000043C0 __unwindtable$??1?$_String_alloc@$0A@U?$_String_base_types@DV?$allocator@D@std@@@std@@@std@@QAE@XZ db 0FFh
.xdata$x:000043C0                                         ; DATA XREF: .xdata$x:000043D0o
.xdata$x:000043C1                 db 0FFh
.xdata$x:000043C2                 db 0FFh
.xdata$x:000043C3                 db 0FFh
.xdata$x:000043C4                 dd offset __unwindfunclet$??1?$_String_alloc@$0A@U?$_String_base_types@DV?$allocator@D@std@@@std@@@std@@QAE@XZ$0
.xdata$x:000043C8 __ehfuncinfo$??1?$_String_alloc@$0A@U?$_String_base_types@DV?$allocator@D@std@@@std@@@std@@QAE@XZ db  22h ; "
.xdata$x:000043C8                                         ; DATA XREF: __ehhandler$??1?$_String_alloc@$0A@U?$_String_base_types@DV?$allocator@D@std@@@std@@@std@@QAE@XZ+11o
.xdata$x:000043C9                 db    5
.xdata$x:000043CA                 db  93h ; Ã´
.xdata$x:000043CB                 db  19h
.xdata$x:000043CC                 db    1
.xdata$x:000043CD                 db    0
.xdata$x:000043CE                 db    0
.xdata$x:000043CF                 db    0
.xdata$x:000043D0                 dd offset __unwindtable$??1?$_String_alloc@$0A@U?$_String_base_types@DV?$allocator@D@std@@@std@@@std@@QAE@XZ
.xdata$x:000043D4                 db    0
.xdata$x:000043D5                 db    0
.xdata$x:000043D6                 db    0
.xdata$x:000043D7                 db    0
.xdata$x:000043D8                 db    0
.xdata$x:000043D9                 db    0
.xdata$x:000043DA                 db    0
.xdata$x:000043DB                 db    0
.xdata$x:000043DC                 db    0
.xdata$x:000043DD                 db    0
.xdata$x:000043DE                 db    0
.xdata$x:000043DF                 db    0
.xdata$x:000043E0                 db    0
.xdata$x:000043E1                 db    0
.xdata$x:000043E2                 db    0
.xdata$x:000043E3                 db    0
.xdata$x:000043E4                 db    0
.xdata$x:000043E5                 db    0
.xdata$x:000043E6                 db    0
.xdata$x:000043E7                 db    0
.xdata$x:000043E8                 db    0
.xdata$x:000043E9                 db    0
.xdata$x:000043EA                 db    0
.xdata$x:000043EB                 db    0
.xdata$x:000043EB _xdata$x        ends
.xdata$x:000043EB
.xdata$x:000043EC ; ===========================================================================
.xdata$x:000043EC
.xdata$x:000043EC ; Segment type: Pure data
.xdata$x:000043EC ; Segment permissions: Read
.xdata$x:000043EC _xdata$x        segment dword public 'DATA' use32
.xdata$x:000043EC                 assume cs:_xdata$x
.xdata$x:000043EC                 ;org 43ECh
.xdata$x:000043EC ; COMDAT (pick associative to section at 26B4)
.xdata$x:000043EC __unwindtable$??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@PBD@Z db 0FFh
.xdata$x:000043EC                                         ; DATA XREF: .xdata$x:000043FCo
.xdata$x:000043ED                 db 0FFh
.xdata$x:000043EE                 db 0FFh
.xdata$x:000043EF                 db 0FFh
.xdata$x:000043F0                 dd offset __unwindfunclet$??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@PBD@Z$0
.xdata$x:000043F4 __ehfuncinfo$??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@PBD@Z db  22h ; "
.xdata$x:000043F4                                         ; DATA XREF: __ehhandler$??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@PBD@Z+11o
.xdata$x:000043F5                 db    5
.xdata$x:000043F6                 db  93h ; Ã´
.xdata$x:000043F7                 db  19h
.xdata$x:000043F8                 db    1
.xdata$x:000043F9                 db    0
.xdata$x:000043FA                 db    0
.xdata$x:000043FB                 db    0
.xdata$x:000043FC                 dd offset __unwindtable$??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@PBD@Z
.xdata$x:00004400                 db    0
.xdata$x:00004401                 db    0
.xdata$x:00004402                 db    0
.xdata$x:00004403                 db    0
.xdata$x:00004404                 db    0
.xdata$x:00004405                 db    0
.xdata$x:00004406                 db    0
.xdata$x:00004407                 db    0
.xdata$x:00004408                 db    0
.xdata$x:00004409                 db    0
.xdata$x:0000440A                 db    0
.xdata$x:0000440B                 db    0
.xdata$x:0000440C                 db    0
.xdata$x:0000440D                 db    0
.xdata$x:0000440E                 db    0
.xdata$x:0000440F                 db    0
.xdata$x:00004410                 db    0
.xdata$x:00004411                 db    0
.xdata$x:00004412                 db    0
.xdata$x:00004413                 db    0
.xdata$x:00004414                 db    0
.xdata$x:00004415                 db    0
.xdata$x:00004416                 db    0
.xdata$x:00004417                 db    0
.xdata$x:00004417 _xdata$x        ends
.xdata$x:00004417
.xdata$x:00004418 ; ===========================================================================
.xdata$x:00004418
.xdata$x:00004418 ; Segment type: Pure data
.xdata$x:00004418 ; Segment permissions: Read
.xdata$x:00004418 _xdata$x        segment dword public 'DATA' use32
.xdata$x:00004418                 assume cs:_xdata$x
.xdata$x:00004418                 ;org 4418h
.xdata$x:00004418 ; COMDAT (pick associative to section at 2BB0)
.xdata$x:00004418 __unwindtable$??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ db 0FFh
.xdata$x:00004418                                         ; DATA XREF: .xdata$x:00004428o
.xdata$x:00004419                 db 0FFh
.xdata$x:0000441A                 db 0FFh
.xdata$x:0000441B                 db 0FFh
.xdata$x:0000441C                 dd offset __unwindfunclet$??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ$0
.xdata$x:00004420 __ehfuncinfo$??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ db  22h ; "
.xdata$x:00004420                                         ; DATA XREF: __ehhandler$??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ+11o
.xdata$x:00004421                 db    5
.xdata$x:00004422                 db  93h ; Ã´
.xdata$x:00004423                 db  19h
.xdata$x:00004424                 db    1
.xdata$x:00004425                 db    0
.xdata$x:00004426                 db    0
.xdata$x:00004427                 db    0
.xdata$x:00004428                 dd offset __unwindtable$??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ
.xdata$x:0000442C                 db    0
.xdata$x:0000442D                 db    0
.xdata$x:0000442E                 db    0
.xdata$x:0000442F                 db    0
.xdata$x:00004430                 db    0
.xdata$x:00004431                 db    0
.xdata$x:00004432                 db    0
.xdata$x:00004433                 db    0
.xdata$x:00004434                 db    0
.xdata$x:00004435                 db    0
.xdata$x:00004436                 db    0
.xdata$x:00004437                 db    0
.xdata$x:00004438                 db    0
.xdata$x:00004439                 db    0
.xdata$x:0000443A                 db    0
.xdata$x:0000443B                 db    0
.xdata$x:0000443C                 db    0
.xdata$x:0000443D                 db    0
.xdata$x:0000443E                 db    0
.xdata$x:0000443F                 db    0
.xdata$x:00004440                 db    0
.xdata$x:00004441                 db    0
.xdata$x:00004442                 db    0
.xdata$x:00004443                 db    0
.xdata$x:00004443 _xdata$x        ends
.xdata$x:00004443
.xdata$x:00004444 ; ===========================================================================
.xdata$x:00004444
.xdata$x:00004444 ; Segment type: Pure data
.xdata$x:00004444 ; Segment permissions: Read
.xdata$x:00004444 _xdata$x        segment dword public 'DATA' use32
.xdata$x:00004444                 assume cs:_xdata$x
.xdata$x:00004444                 ;org 4444h
.xdata$x:00004444 ; COMDAT (pick associative to section at 3178)
.xdata$x:00004444 __catchsym$?_Copy@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEXII@Z$5 db    0
.xdata$x:00004444                                         ; DATA XREF: .xdata$x:000044CCo
.xdata$x:00004445                 db    0
.xdata$x:00004446                 db    0
.xdata$x:00004447                 db    0
.xdata$x:00004448                 db    0
.xdata$x:00004449                 db    0
.xdata$x:0000444A                 db    0
.xdata$x:0000444B                 db    0
.xdata$x:0000444C                 db    0
.xdata$x:0000444D                 db    0
.xdata$x:0000444E                 db    0
.xdata$x:0000444F                 db    0
.xdata$x:00004450                 dd offset __catch$?_Copy@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEXII@Z$0
.xdata$x:00004454 __catchsym$?_Copy@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEXII@Z$4 db    0
.xdata$x:00004454                                         ; DATA XREF: .xdata$x:000044B8o
.xdata$x:00004455                 db    0
.xdata$x:00004456                 db    0
.xdata$x:00004457                 db    0
.xdata$x:00004458                 db    0
.xdata$x:00004459                 db    0
.xdata$x:0000445A                 db    0
.xdata$x:0000445B                 db    0
.xdata$x:0000445C                 db    0
.xdata$x:0000445D                 db    0
.xdata$x:0000445E                 db    0
.xdata$x:0000445F                 db    0
.xdata$x:00004460                 dd offset __catch$?_Copy@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEXII@Z$1
.xdata$x:00004464 __unwindtable$?_Copy@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEXII@Z db 0FFh
.xdata$x:00004464                                         ; DATA XREF: .xdata$x:0000448Co
.xdata$x:00004465                 db 0FFh
.xdata$x:00004466                 db 0FFh
.xdata$x:00004467                 db 0FFh
.xdata$x:00004468                 db    0
.xdata$x:00004469                 db    0
.xdata$x:0000446A                 db    0
.xdata$x:0000446B                 db    0
.xdata$x:0000446C                 db 0FFh
.xdata$x:0000446D                 db 0FFh
.xdata$x:0000446E                 db 0FFh
.xdata$x:0000446F                 db 0FFh
.xdata$x:00004470                 db    0
.xdata$x:00004471                 db    0
.xdata$x:00004472                 db    0
.xdata$x:00004473                 db    0
.xdata$x:00004474                 db    1
.xdata$x:00004475                 db    0
.xdata$x:00004476                 db    0
.xdata$x:00004477                 db    0
.xdata$x:00004478                 db    0
.xdata$x:00004479                 db    0
.xdata$x:0000447A                 db    0
.xdata$x:0000447B                 db    0
.xdata$x:0000447C                 db    1
.xdata$x:0000447D                 db    0
.xdata$x:0000447E                 db    0
.xdata$x:0000447F                 db    0
.xdata$x:00004480                 db    0
.xdata$x:00004481                 db    0
.xdata$x:00004482                 db    0
.xdata$x:00004483                 db    0
.xdata$x:00004484 __ehfuncinfo$?_Copy@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEXII@Z db  22h ; "
.xdata$x:00004484                                         ; DATA XREF: __ehhandler$?_Copy@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEXII@Z+11o
.xdata$x:00004485                 db    5
.xdata$x:00004486                 db  93h ; Ã´
.xdata$x:00004487                 db  19h
.xdata$x:00004488                 db    4
.xdata$x:00004489                 db    0
.xdata$x:0000448A                 db    0
.xdata$x:0000448B                 db    0
.xdata$x:0000448C                 dd offset __unwindtable$?_Copy@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEXII@Z
.xdata$x:00004490                 db    2
.xdata$x:00004491                 db    0
.xdata$x:00004492                 db    0
.xdata$x:00004493                 db    0
.xdata$x:00004494                 dd offset __tryblocktable$?_Copy@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEXII@Z
.xdata$x:00004498                 db    0
.xdata$x:00004499                 db    0
.xdata$x:0000449A                 db    0
.xdata$x:0000449B                 db    0
.xdata$x:0000449C                 db    0
.xdata$x:0000449D                 db    0
.xdata$x:0000449E                 db    0
.xdata$x:0000449F                 db    0
.xdata$x:000044A0                 db    0
.xdata$x:000044A1                 db    0
.xdata$x:000044A2                 db    0
.xdata$x:000044A3                 db    0
.xdata$x:000044A4                 db    0
.xdata$x:000044A5                 db    0
.xdata$x:000044A6                 db    0
.xdata$x:000044A7                 db    0
.xdata$x:000044A8 __tryblocktable$?_Copy@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEXII@Z db    2
.xdata$x:000044A8                                         ; DATA XREF: .xdata$x:00004494o
.xdata$x:000044A9                 db    0
.xdata$x:000044AA                 db    0
.xdata$x:000044AB                 db    0
.xdata$x:000044AC                 db    2
.xdata$x:000044AD                 db    0
.xdata$x:000044AE                 db    0
.xdata$x:000044AF                 db    0
.xdata$x:000044B0                 db    3
.xdata$x:000044B1                 db    0
.xdata$x:000044B2                 db    0
.xdata$x:000044B3                 db    0
.xdata$x:000044B4                 db    1
.xdata$x:000044B5                 db    0
.xdata$x:000044B6                 db    0
.xdata$x:000044B7                 db    0
.xdata$x:000044B8                 dd offset __catchsym$?_Copy@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEXII@Z$4
.xdata$x:000044BC                 db    0
.xdata$x:000044BD                 db    0
.xdata$x:000044BE                 db    0
.xdata$x:000044BF                 db    0
.xdata$x:000044C0                 db    0
.xdata$x:000044C1                 db    0
.xdata$x:000044C2                 db    0
.xdata$x:000044C3                 db    0
.xdata$x:000044C4                 db    3
.xdata$x:000044C5                 db    0
.xdata$x:000044C6                 db    0
.xdata$x:000044C7                 db    0
.xdata$x:000044C8                 db    1
.xdata$x:000044C9                 db    0
.xdata$x:000044CA                 db    0
.xdata$x:000044CB                 db    0
.xdata$x:000044CC                 dd offset __catchsym$?_Copy@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEXII@Z$5
.xdata$x:000044CC _xdata$x        ends
.xdata$x:000044CC
.xdata$x:000044D0 ; ===========================================================================
.xdata$x:000044D0
.xdata$x:000044D0 ; Segment type: Pure data
.xdata$x:000044D0 ; Segment permissions: Read
.xdata$x:000044D0 _xdata$x        segment dword public 'DATA' use32
.xdata$x:000044D0                 assume cs:_xdata$x
.xdata$x:000044D0                 ;org 44D0h
.xdata$x:000044D0 ; COMDAT (pick associative to section at 2808)
.xdata$x:000044D0 __unwindtable$??0_Generic_error_category@std@@QAE@XZ db 0FFh
.xdata$x:000044D0                                         ; DATA XREF: .xdata$x:000044E0o
.xdata$x:000044D1                 db 0FFh
.xdata$x:000044D2                 db 0FFh
.xdata$x:000044D3                 db 0FFh
.xdata$x:000044D4                 dd offset __unwindfunclet$??0_Generic_error_category@std@@QAE@XZ$0
.xdata$x:000044D8 __ehfuncinfo$??0_Generic_error_category@std@@QAE@XZ db  22h ; "
.xdata$x:000044D8                                         ; DATA XREF: __ehhandler$??0_Generic_error_category@std@@QAE@XZ+11o
.xdata$x:000044D9                 db    5
.xdata$x:000044DA                 db  93h ; Ã´
.xdata$x:000044DB                 db  19h
.xdata$x:000044DC                 db    1
.xdata$x:000044DD                 db    0
.xdata$x:000044DE                 db    0
.xdata$x:000044DF                 db    0
.xdata$x:000044E0                 dd offset __unwindtable$??0_Generic_error_category@std@@QAE@XZ
.xdata$x:000044E4                 db    0
.xdata$x:000044E5                 db    0
.xdata$x:000044E6                 db    0
.xdata$x:000044E7                 db    0
.xdata$x:000044E8                 db    0
.xdata$x:000044E9                 db    0
.xdata$x:000044EA                 db    0
.xdata$x:000044EB                 db    0
.xdata$x:000044EC                 db    0
.xdata$x:000044ED                 db    0
.xdata$x:000044EE                 db    0
.xdata$x:000044EF                 db    0
.xdata$x:000044F0                 db    0
.xdata$x:000044F1                 db    0
.xdata$x:000044F2                 db    0
.xdata$x:000044F3                 db    0
.xdata$x:000044F4                 db    0
.xdata$x:000044F5                 db    0
.xdata$x:000044F6                 db    0
.xdata$x:000044F7                 db    0
.xdata$x:000044F8                 db    0
.xdata$x:000044F9                 db    0
.xdata$x:000044FA                 db    0
.xdata$x:000044FB                 db    0
.xdata$x:000044FB _xdata$x        ends
.xdata$x:000044FB
.xdata$x:000044FC ; ===========================================================================
.xdata$x:000044FC
.xdata$x:000044FC ; Segment type: Pure data
.xdata$x:000044FC ; Segment permissions: Read
.xdata$x:000044FC _xdata$x        segment dword public 'DATA' use32
.xdata$x:000044FC                 assume cs:_xdata$x
.xdata$x:000044FC                 ;org 44FCh
.xdata$x:000044FC ; COMDAT (pick associative to section at 3E24)
.xdata$x:000044FC __unwindtable$?message@_Generic_error_category@std@@UBE?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@2@H@Z db 0FFh
.xdata$x:000044FC                                         ; DATA XREF: .xdata$x:0000450Co
.xdata$x:000044FD                 db 0FFh
.xdata$x:000044FE                 db 0FFh
.xdata$x:000044FF                 db 0FFh
.xdata$x:00004500                 dd offset __unwindfunclet$?message@_Generic_error_category@std@@UBE?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@2@H@Z$0
.xdata$x:00004504 __ehfuncinfo$?message@_Generic_error_category@std@@UBE?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@2@H@Z db  22h ; "
.xdata$x:00004504                                         ; DATA XREF: __ehhandler$?message@_Generic_error_category@std@@UBE?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@2@H@Z+11o
.xdata$x:00004505                 db    5
.xdata$x:00004506                 db  93h ; Ã´
.xdata$x:00004507                 db  19h
.xdata$x:00004508                 db    1
.xdata$x:00004509                 db    0
.xdata$x:0000450A                 db    0
.xdata$x:0000450B                 db    0
.xdata$x:0000450C                 dd offset __unwindtable$?message@_Generic_error_category@std@@UBE?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@2@H@Z
.xdata$x:00004510                 db    0
.xdata$x:00004511                 db    0
.xdata$x:00004512                 db    0
.xdata$x:00004513                 db    0
.xdata$x:00004514                 db    0
.xdata$x:00004515                 db    0
.xdata$x:00004516                 db    0
.xdata$x:00004517                 db    0
.xdata$x:00004518                 db    0
.xdata$x:00004519                 db    0
.xdata$x:0000451A                 db    0
.xdata$x:0000451B                 db    0
.xdata$x:0000451C                 db    0
.xdata$x:0000451D                 db    0
.xdata$x:0000451E                 db    0
.xdata$x:0000451F                 db    0
.xdata$x:00004520                 db    0
.xdata$x:00004521                 db    0
.xdata$x:00004522                 db    0
.xdata$x:00004523                 db    0
.xdata$x:00004524                 db    0
.xdata$x:00004525                 db    0
.xdata$x:00004526                 db    0
.xdata$x:00004527                 db    0
.xdata$x:00004527 _xdata$x        ends
.xdata$x:00004527
.xdata$x:00004528 ; ===========================================================================
.xdata$x:00004528
.xdata$x:00004528 ; Segment type: Pure data
.xdata$x:00004528 ; Segment permissions: Read
.xdata$x:00004528 _xdata$x        segment dword public 'DATA' use32
.xdata$x:00004528                 assume cs:_xdata$x
.xdata$x:00004528                 ;org 4528h
.xdata$x:00004528 ; COMDAT (pick associative to section at 2CB8)
.xdata$x:00004528 __unwindtable$??1_Generic_error_category@std@@UAE@XZ db 0FFh
.xdata$x:00004528                                         ; DATA XREF: .xdata$x:00004538o
.xdata$x:00004529                 db 0FFh
.xdata$x:0000452A                 db 0FFh
.xdata$x:0000452B                 db 0FFh
.xdata$x:0000452C                 dd offset __unwindfunclet$??1_Generic_error_category@std@@UAE@XZ$0
.xdata$x:00004530 __ehfuncinfo$??1_Generic_error_category@std@@UAE@XZ db  22h ; "
.xdata$x:00004530                                         ; DATA XREF: __ehhandler$??1_Generic_error_category@std@@UAE@XZ+11o
.xdata$x:00004531                 db    5
.xdata$x:00004532                 db  93h ; Ã´
.xdata$x:00004533                 db  19h
.xdata$x:00004534                 db    1
.xdata$x:00004535                 db    0
.xdata$x:00004536                 db    0
.xdata$x:00004537                 db    0
.xdata$x:00004538                 dd offset __unwindtable$??1_Generic_error_category@std@@UAE@XZ
.xdata$x:0000453C                 db    0
.xdata$x:0000453D                 db    0
.xdata$x:0000453E                 db    0
.xdata$x:0000453F                 db    0
.xdata$x:00004540                 db    0
.xdata$x:00004541                 db    0
.xdata$x:00004542                 db    0
.xdata$x:00004543                 db    0
.xdata$x:00004544                 db    0
.xdata$x:00004545                 db    0
.xdata$x:00004546                 db    0
.xdata$x:00004547                 db    0
.xdata$x:00004548                 db    0
.xdata$x:00004549                 db    0
.xdata$x:0000454A                 db    0
.xdata$x:0000454B                 db    0
.xdata$x:0000454C                 db    0
.xdata$x:0000454D                 db    0
.xdata$x:0000454E                 db    0
.xdata$x:0000454F                 db    0
.xdata$x:00004550                 db    0
.xdata$x:00004551                 db    0
.xdata$x:00004552                 db    0
.xdata$x:00004553                 db    0
.xdata$x:00004553 _xdata$x        ends
.xdata$x:00004553
.xdata$x:00004554 ; ===========================================================================
.xdata$x:00004554
.xdata$x:00004554 ; Segment type: Pure data
.xdata$x:00004554 ; Segment permissions: Read
.xdata$x:00004554 _xdata$x        segment dword public 'DATA' use32
.xdata$x:00004554                 assume cs:_xdata$x
.xdata$x:00004554                 ;org 4554h
.xdata$x:00004554 ; COMDAT (pick associative to section at 2894)
.xdata$x:00004554 __unwindtable$??0_Iostream_error_category@std@@QAE@XZ db 0FFh
.xdata$x:00004554                                         ; DATA XREF: .xdata$x:00004564o
.xdata$x:00004555                 db 0FFh
.xdata$x:00004556                 db 0FFh
.xdata$x:00004557                 db 0FFh
.xdata$x:00004558                 dd offset __unwindfunclet$??0_Iostream_error_category@std@@QAE@XZ$0
.xdata$x:0000455C __ehfuncinfo$??0_Iostream_error_category@std@@QAE@XZ db  22h ; "
.xdata$x:0000455C                                         ; DATA XREF: __ehhandler$??0_Iostream_error_category@std@@QAE@XZ+11o
.xdata$x:0000455D                 db    5
.xdata$x:0000455E                 db  93h ; Ã´
.xdata$x:0000455F                 db  19h
.xdata$x:00004560                 db    1
.xdata$x:00004561                 db    0
.xdata$x:00004562                 db    0
.xdata$x:00004563                 db    0
.xdata$x:00004564                 dd offset __unwindtable$??0_Iostream_error_category@std@@QAE@XZ
.xdata$x:00004568                 align 20h
.xdata$x:00004568 _xdata$x        ends
.xdata$x:00004568
.xdata$x:00004580 ; ===========================================================================
.xdata$x:00004580
.xdata$x:00004580 ; Segment type: Pure data
.xdata$x:00004580 ; Segment permissions: Read
.xdata$x:00004580 _xdata$x        segment dword public 'DATA' use32
.xdata$x:00004580                 assume cs:_xdata$x
.xdata$x:00004580                 ;org 4580h
.xdata$x:00004580 ; COMDAT (pick associative to section at 3EDC)
.xdata$x:00004580 __unwindtable$?message@_Iostream_error_category@std@@UBE?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@2@H@Z db 0FFh
.xdata$x:00004580                                         ; DATA XREF: .xdata$x:00004590o
.xdata$x:00004581                 db 0FFh
.xdata$x:00004582                 db 0FFh
.xdata$x:00004583                 db 0FFh
.xdata$x:00004584                 dd offset __unwindfunclet$?message@_Iostream_error_category@std@@UBE?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@2@H@Z$0
.xdata$x:00004588 __ehfuncinfo$?message@_Iostream_error_category@std@@UBE?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@2@H@Z db  22h ; "
.xdata$x:00004588                                         ; DATA XREF: __ehhandler$?message@_Iostream_error_category@std@@UBE?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@2@H@Z+11o
.xdata$x:00004589                 db    5
.xdata$x:0000458A                 db  93h ; Ã´
.xdata$x:0000458B                 db  19h
.xdata$x:0000458C                 db    1
.xdata$x:0000458D                 db    0
.xdata$x:0000458E                 db    0
.xdata$x:0000458F                 db    0
.xdata$x:00004590                 dd offset __unwindtable$?message@_Iostream_error_category@std@@UBE?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@2@H@Z
.xdata$x:00004594                 db    0
.xdata$x:00004595                 db    0
.xdata$x:00004596                 db    0
.xdata$x:00004597                 db    0
.xdata$x:00004598                 db    0
.xdata$x:00004599                 db    0
.xdata$x:0000459A                 db    0
.xdata$x:0000459B                 db    0
.xdata$x:0000459C                 db    0
.xdata$x:0000459D                 db    0
.xdata$x:0000459E                 db    0
.xdata$x:0000459F                 db    0
.xdata$x:000045A0                 db    0
.xdata$x:000045A1                 db    0
.xdata$x:000045A2                 db    0
.xdata$x:000045A3                 db    0
.xdata$x:000045A4                 db    0
.xdata$x:000045A5                 db    0
.xdata$x:000045A6                 db    0
.xdata$x:000045A7                 db    0
.xdata$x:000045A8                 db    0
.xdata$x:000045A9                 db    0
.xdata$x:000045AA                 db    0
.xdata$x:000045AB                 db    0
.xdata$x:000045AB _xdata$x        ends
.xdata$x:000045AB
.xdata$x:000045AC ; ===========================================================================
.xdata$x:000045AC
.xdata$x:000045AC ; Segment type: Pure data
.xdata$x:000045AC ; Segment permissions: Read
.xdata$x:000045AC _xdata$x        segment dword public 'DATA' use32
.xdata$x:000045AC                 assume cs:_xdata$x
.xdata$x:000045AC                 ;org 45ACh
.xdata$x:000045AC ; COMDAT (pick associative to section at 2D28)
.xdata$x:000045AC __unwindtable$??1_Iostream_error_category@std@@UAE@XZ db 0FFh
.xdata$x:000045AC                                         ; DATA XREF: .xdata$x:000045BCo
.xdata$x:000045AD                 db 0FFh
.xdata$x:000045AE                 db 0FFh
.xdata$x:000045AF                 db 0FFh
.xdata$x:000045B0                 dd offset __unwindfunclet$??1_Iostream_error_category@std@@UAE@XZ$0
.xdata$x:000045B4 __ehfuncinfo$??1_Iostream_error_category@std@@UAE@XZ db  22h ; "
.xdata$x:000045B4                                         ; DATA XREF: __ehhandler$??1_Iostream_error_category@std@@UAE@XZ+11o
.xdata$x:000045B5                 db    5
.xdata$x:000045B6                 db  93h ; Ã´
.xdata$x:000045B7                 db  19h
.xdata$x:000045B8                 db    1
.xdata$x:000045B9                 db    0
.xdata$x:000045BA                 db    0
.xdata$x:000045BB                 db    0
.xdata$x:000045BC                 dd offset __unwindtable$??1_Iostream_error_category@std@@UAE@XZ
.xdata$x:000045C0                 db    0
.xdata$x:000045C1                 db    0
.xdata$x:000045C2                 db    0
.xdata$x:000045C3                 db    0
.xdata$x:000045C4                 db    0
.xdata$x:000045C5                 db    0
.xdata$x:000045C6                 db    0
.xdata$x:000045C7                 db    0
.xdata$x:000045C8                 db    0
.xdata$x:000045C9                 db    0
.xdata$x:000045CA                 db    0
.xdata$x:000045CB                 db    0
.xdata$x:000045CC                 db    0
.xdata$x:000045CD                 db    0
.xdata$x:000045CE                 db    0
.xdata$x:000045CF                 db    0
.xdata$x:000045D0                 db    0
.xdata$x:000045D1                 db    0
.xdata$x:000045D2                 db    0
.xdata$x:000045D3                 db    0
.xdata$x:000045D4                 db    0
.xdata$x:000045D5                 db    0
.xdata$x:000045D6                 db    0
.xdata$x:000045D7                 db    0
.xdata$x:000045D7 _xdata$x        ends
.xdata$x:000045D7
.xdata$x:000045D8 ; ===========================================================================
.xdata$x:000045D8
.xdata$x:000045D8 ; Segment type: Pure data
.xdata$x:000045D8 ; Segment permissions: Read
.xdata$x:000045D8 _xdata$x        segment dword public 'DATA' use32
.xdata$x:000045D8                 assume cs:_xdata$x
.xdata$x:000045D8                 ;org 45D8h
.xdata$x:000045D8 ; COMDAT (pick associative to section at 2910)
.xdata$x:000045D8 __unwindtable$??0_System_error_category@std@@QAE@XZ db 0FFh
.xdata$x:000045D8                                         ; DATA XREF: .xdata$x:000045E8o
.xdata$x:000045D9                 db 0FFh
.xdata$x:000045DA                 db 0FFh
.xdata$x:000045DB                 db 0FFh
.xdata$x:000045DC                 dd offset __unwindfunclet$??0_System_error_category@std@@QAE@XZ$0
.xdata$x:000045E0 __ehfuncinfo$??0_System_error_category@std@@QAE@XZ db  22h ; "
.xdata$x:000045E0                                         ; DATA XREF: __ehhandler$??0_System_error_category@std@@QAE@XZ+11o
.xdata$x:000045E1                 db    5
.xdata$x:000045E2                 db  93h ; Ã´
.xdata$x:000045E3                 db  19h
.xdata$x:000045E4                 db    1
.xdata$x:000045E5                 db    0
.xdata$x:000045E6                 db    0
.xdata$x:000045E7                 db    0
.xdata$x:000045E8                 dd offset __unwindtable$??0_System_error_category@std@@QAE@XZ
.xdata$x:000045EC                 db    0
.xdata$x:000045ED                 db    0
.xdata$x:000045EE                 db    0
.xdata$x:000045EF                 db    0
.xdata$x:000045F0                 db    0
.xdata$x:000045F1                 db    0
.xdata$x:000045F2                 db    0
.xdata$x:000045F3                 db    0
.xdata$x:000045F4                 db    0
.xdata$x:000045F5                 db    0
.xdata$x:000045F6                 db    0
.xdata$x:000045F7                 db    0
.xdata$x:000045F8                 db    0
.xdata$x:000045F9                 db    0
.xdata$x:000045FA                 db    0
.xdata$x:000045FB                 db    0
.xdata$x:000045FC                 db    0
.xdata$x:000045FD                 db    0
.xdata$x:000045FE                 db    0
.xdata$x:000045FF                 db    0
.xdata$x:00004600                 db    0
.xdata$x:00004601                 db    0
.xdata$x:00004602                 db    0
.xdata$x:00004603                 db    0
.xdata$x:00004603 _xdata$x        ends
.xdata$x:00004603
.xdata$x:00004604 ; ===========================================================================
.xdata$x:00004604
.xdata$x:00004604 ; Segment type: Pure data
.xdata$x:00004604 ; Segment permissions: Read
.xdata$x:00004604 _xdata$x        segment dword public 'DATA' use32
.xdata$x:00004604                 assume cs:_xdata$x
.xdata$x:00004604                 ;org 4604h
.xdata$x:00004604 ; COMDAT (pick associative to section at 3FA0)
.xdata$x:00004604 __unwindtable$?message@_System_error_category@std@@UBE?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@2@H@Z db 0FFh
.xdata$x:00004604                                         ; DATA XREF: .xdata$x:00004614o
.xdata$x:00004605                 db 0FFh
.xdata$x:00004606                 db 0FFh
.xdata$x:00004607                 db 0FFh
.xdata$x:00004608                 dd offset __unwindfunclet$?message@_System_error_category@std@@UBE?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@2@H@Z$0
.xdata$x:0000460C __ehfuncinfo$?message@_System_error_category@std@@UBE?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@2@H@Z db  22h ; "
.xdata$x:0000460C                                         ; DATA XREF: __ehhandler$?message@_System_error_category@std@@UBE?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@2@H@Z+11o
.xdata$x:0000460D                 db    5
.xdata$x:0000460E                 db  93h ; Ã´
.xdata$x:0000460F                 db  19h
.xdata$x:00004610                 db    1
.xdata$x:00004611                 db    0
.xdata$x:00004612                 db    0
.xdata$x:00004613                 db    0
.xdata$x:00004614                 dd offset __unwindtable$?message@_System_error_category@std@@UBE?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@2@H@Z
.xdata$x:00004618                 db    0
.xdata$x:00004619                 db    0
.xdata$x:0000461A                 db    0
.xdata$x:0000461B                 db    0
.xdata$x:0000461C                 db    0
.xdata$x:0000461D                 db    0
.xdata$x:0000461E                 db    0
.xdata$x:0000461F                 db    0
.xdata$x:00004620                 db    0
.xdata$x:00004621                 db    0
.xdata$x:00004622                 db    0
.xdata$x:00004623                 db    0
.xdata$x:00004624                 db    0
.xdata$x:00004625                 db    0
.xdata$x:00004626                 db    0
.xdata$x:00004627                 db    0
.xdata$x:00004628                 db    0
.xdata$x:00004629                 db    0
.xdata$x:0000462A                 db    0
.xdata$x:0000462B                 db    0
.xdata$x:0000462C                 db    0
.xdata$x:0000462D                 db    0
.xdata$x:0000462E                 db    0
.xdata$x:0000462F                 db    0
.xdata$x:0000462F _xdata$x        ends
.xdata$x:0000462F
.xdata$x:00004630 ; ===========================================================================
.xdata$x:00004630
.xdata$x:00004630 ; Segment type: Pure data
.xdata$x:00004630 ; Segment permissions: Read
.xdata$x:00004630 _xdata$x        segment dword public 'DATA' use32
.xdata$x:00004630                 assume cs:_xdata$x
.xdata$x:00004630                 ;org 4630h
.xdata$x:00004630 ; COMDAT (pick associative to section at 2D98)
.xdata$x:00004630 __unwindtable$??1_System_error_category@std@@UAE@XZ db 0FFh
.xdata$x:00004630                                         ; DATA XREF: .xdata$x:00004640o
.xdata$x:00004631                 db 0FFh
.xdata$x:00004632                 db 0FFh
.xdata$x:00004633                 db 0FFh
.xdata$x:00004634                 dd offset __unwindfunclet$??1_System_error_category@std@@UAE@XZ$0
.xdata$x:00004638 __ehfuncinfo$??1_System_error_category@std@@UAE@XZ db  22h ; "
.xdata$x:00004638                                         ; DATA XREF: __ehhandler$??1_System_error_category@std@@UAE@XZ+11o
.xdata$x:00004639                 db    5
.xdata$x:0000463A                 db  93h ; Ã´
.xdata$x:0000463B                 db  19h
.xdata$x:0000463C                 db    1
.xdata$x:0000463D                 db    0
.xdata$x:0000463E                 db    0
.xdata$x:0000463F                 db    0
.xdata$x:00004640                 dd offset __unwindtable$??1_System_error_category@std@@UAE@XZ
.xdata$x:00004644                 db    0
.xdata$x:00004645                 db    0
.xdata$x:00004646                 db    0
.xdata$x:00004647                 db    0
.xdata$x:00004648                 db    0
.xdata$x:00004649                 db    0
.xdata$x:0000464A                 db    0
.xdata$x:0000464B                 db    0
.xdata$x:0000464C                 db    0
.xdata$x:0000464D                 db    0
.xdata$x:0000464E                 db    0
.xdata$x:0000464F                 db    0
.xdata$x:00004650                 db    0
.xdata$x:00004651                 db    0
.xdata$x:00004652                 db    0
.xdata$x:00004653                 db    0
.xdata$x:00004654                 db    0
.xdata$x:00004655                 db    0
.xdata$x:00004656                 db    0
.xdata$x:00004657                 db    0
.xdata$x:00004658                 db    0
.xdata$x:00004659                 db    0
.xdata$x:0000465A                 db    0
.xdata$x:0000465B                 db    0
.xdata$x:0000465B _xdata$x        ends
.xdata$x:0000465B
.xdata$x:0000465C ; ===========================================================================
.xdata$x:0000465C
.xdata$x:0000465C ; Segment type: Pure data
.xdata$x:0000465C ; Segment permissions: Read
.xdata$x:0000465C _xdata$x        segment dword public 'DATA' use32
.xdata$x:0000465C                 assume cs:_xdata$x
.xdata$x:0000465C                 ;org 465Ch
.xdata$x:0000465C __unwindtable$?reloadMap@DocumentMap@@QAEXXZ db 0FFh
.xdata$x:0000465C                                         ; DATA XREF: .xdata$x:0000466Co
.xdata$x:0000465D                 db 0FFh
.xdata$x:0000465E                 db 0FFh
.xdata$x:0000465F                 db 0FFh
.xdata$x:00004660                 dd offset __unwindfunclet$?reloadMap@DocumentMap@@QAEXXZ$0
.xdata$x:00004664 __ehfuncinfo$?reloadMap@DocumentMap@@QAEXXZ db  22h ; "
.xdata$x:00004664                                         ; DATA XREF: __ehhandler$?reloadMap@DocumentMap@@QAEXXZ+11o
.xdata$x:00004665                 db    5
.xdata$x:00004666                 db  93h ; Ã´
.xdata$x:00004667                 db  19h
.xdata$x:00004668                 db    1
.xdata$x:00004669                 db    0
.xdata$x:0000466A                 db    0
.xdata$x:0000466B                 db    0
.xdata$x:0000466C                 dd offset __unwindtable$?reloadMap@DocumentMap@@QAEXXZ
.xdata$x:00004670                 db    0
.xdata$x:00004671                 db    0
.xdata$x:00004672                 db    0
.xdata$x:00004673                 db    0
.xdata$x:00004674                 db    0
.xdata$x:00004675                 db    0
.xdata$x:00004676                 db    0
.xdata$x:00004677                 db    0
.xdata$x:00004678                 db    0
.xdata$x:00004679                 db    0
.xdata$x:0000467A                 db    0
.xdata$x:0000467B                 db    0
.xdata$x:0000467C                 db    0
.xdata$x:0000467D                 db    0
.xdata$x:0000467E                 db    0
.xdata$x:0000467F                 db    0
.xdata$x:00004680                 db    0
.xdata$x:00004681                 db    0
.xdata$x:00004682                 db    0
.xdata$x:00004683                 db    0
.xdata$x:00004684                 db    0
.xdata$x:00004685                 db    0
.xdata$x:00004686                 db    0
.xdata$x:00004687                 db    0
.xdata$x:00004687 _xdata$x        ends
.xdata$x:00004687
.xdata$x:00004688 ; ===========================================================================
.xdata$x:00004688
.xdata$x:00004688 ; Segment type: Pure data
.xdata$x:00004688 ; Segment permissions: Read
.xdata$x:00004688 _xdata$x        segment dword public 'DATA' use32
.xdata$x:00004688                 assume cs:_xdata$x
.xdata$x:00004688                 ;org 4688h
.xdata$x:00004688 ; COMDAT (pick associative to section at 25AC)
.xdata$x:00004688 __unwindtable$??0?$_Vector_val@U?$_Simple_types@I@std@@@std@@QAE@XZ db 0FFh
.xdata$x:00004688                                         ; DATA XREF: .xdata$x:00004698o
.xdata$x:00004689                 db 0FFh
.xdata$x:0000468A                 db 0FFh
.xdata$x:0000468B                 db 0FFh
.xdata$x:0000468C                 dd offset __unwindfunclet$??0?$_Vector_val@U?$_Simple_types@I@std@@@std@@QAE@XZ$0
.xdata$x:00004690 __ehfuncinfo$??0?$_Vector_val@U?$_Simple_types@I@std@@@std@@QAE@XZ db  22h ; "
.xdata$x:00004690                                         ; DATA XREF: __ehhandler$??0?$_Vector_val@U?$_Simple_types@I@std@@@std@@QAE@XZ+11o
.xdata$x:00004691                 db    5
.xdata$x:00004692                 db  93h ; Ã´
.xdata$x:00004693                 db  19h
.xdata$x:00004694                 db    1
.xdata$x:00004695                 db    0
.xdata$x:00004696                 db    0
.xdata$x:00004697                 db    0
.xdata$x:00004698                 dd offset __unwindtable$??0?$_Vector_val@U?$_Simple_types@I@std@@@std@@QAE@XZ
.xdata$x:0000469C                 db    0
.xdata$x:0000469D                 db    0
.xdata$x:0000469E                 db    0
.xdata$x:0000469F                 db    0
.xdata$x:000046A0                 db    0
.xdata$x:000046A1                 db    0
.xdata$x:000046A2                 db    0
.xdata$x:000046A3                 db    0
.xdata$x:000046A4                 db    0
.xdata$x:000046A5                 db    0
.xdata$x:000046A6                 db    0
.xdata$x:000046A7                 db    0
.xdata$x:000046A8                 db    0
.xdata$x:000046A9                 db    0
.xdata$x:000046AA                 db    0
.xdata$x:000046AB                 db    0
.xdata$x:000046AC                 db    0
.xdata$x:000046AD                 db    0
.xdata$x:000046AE                 db    0
.xdata$x:000046AF                 db    0
.xdata$x:000046B0                 db    0
.xdata$x:000046B1                 db    0
.xdata$x:000046B2                 db    0
.xdata$x:000046B3                 db    0
.xdata$x:000046B3 _xdata$x        ends
.xdata$x:000046B3
.xdata$x:000046B4 ; ===========================================================================
.xdata$x:000046B4
.xdata$x:000046B4 ; Segment type: Pure data
.xdata$x:000046B4 ; Segment permissions: Read
.xdata$x:000046B4 _xdata$x        segment dword public 'DATA' use32
.xdata$x:000046B4                 assume cs:_xdata$x
.xdata$x:000046B4                 ;org 46B4h
.xdata$x:000046B4 ; COMDAT (pick associative to section at 2B40)
.xdata$x:000046B4 __unwindtable$??1?$_Vector_val@U?$_Simple_types@I@std@@@std@@QAE@XZ db 0FFh
.xdata$x:000046B4                                         ; DATA XREF: .xdata$x:000046C4o
.xdata$x:000046B5                 db 0FFh
.xdata$x:000046B6                 db 0FFh
.xdata$x:000046B7                 db 0FFh
.xdata$x:000046B8                 dd offset __unwindfunclet$??1?$_Vector_val@U?$_Simple_types@I@std@@@std@@QAE@XZ$0
.xdata$x:000046BC __ehfuncinfo$??1?$_Vector_val@U?$_Simple_types@I@std@@@std@@QAE@XZ db  22h ; "
.xdata$x:000046BC                                         ; DATA XREF: __ehhandler$??1?$_Vector_val@U?$_Simple_types@I@std@@@std@@QAE@XZ+11o
.xdata$x:000046BD                 db    5
.xdata$x:000046BE                 db  93h ; Ã´
.xdata$x:000046BF                 db  19h
.xdata$x:000046C0                 db    1
.xdata$x:000046C1                 db    0
.xdata$x:000046C2                 db    0
.xdata$x:000046C3                 db    0
.xdata$x:000046C4                 dd offset __unwindtable$??1?$_Vector_val@U?$_Simple_types@I@std@@@std@@QAE@XZ
.xdata$x:000046C8                 align 20h
.xdata$x:000046C8 _xdata$x        ends
.xdata$x:000046C8
.xdata$x:000046E0 ; ===========================================================================
.xdata$x:000046E0
.xdata$x:000046E0 ; Segment type: Pure data
.xdata$x:000046E0 ; Segment permissions: Read
.xdata$x:000046E0 _xdata$x        segment dword public 'DATA' use32
.xdata$x:000046E0                 assume cs:_xdata$x
.xdata$x:000046E0                 ;org 46E0h
.xdata$x:000046E0 ; COMDAT (pick associative to section at 2530)
.xdata$x:000046E0 __unwindtable$??0?$_Vector_alloc@$0A@U?$_Vec_base_types@IV?$allocator@I@std@@@std@@@std@@QAE@ABV?$allocator@I@1@@Z db 0FFh
.xdata$x:000046E0                                         ; DATA XREF: .xdata$x:000046F0o
.xdata$x:000046E1                 db 0FFh
.xdata$x:000046E2                 db 0FFh
.xdata$x:000046E3                 db 0FFh
.xdata$x:000046E4                 dd offset __unwindfunclet$??0?$_Vector_alloc@$0A@U?$_Vec_base_types@IV?$allocator@I@std@@@std@@@std@@QAE@ABV?$allocator@I@1@@Z$0
.xdata$x:000046E8 __ehfuncinfo$??0?$_Vector_alloc@$0A@U?$_Vec_base_types@IV?$allocator@I@std@@@std@@@std@@QAE@ABV?$allocator@I@1@@Z db  22h ; "
.xdata$x:000046E8                                         ; DATA XREF: __ehhandler$??0?$_Vector_alloc@$0A@U?$_Vec_base_types@IV?$allocator@I@std@@@std@@@std@@QAE@ABV?$allocator@I@1@@Z+11o
.xdata$x:000046E9                 db    5
.xdata$x:000046EA                 db  93h ; Ã´
.xdata$x:000046EB                 db  19h
.xdata$x:000046EC                 db    1
.xdata$x:000046ED                 db    0
.xdata$x:000046EE                 db    0
.xdata$x:000046EF                 db    0
.xdata$x:000046F0                 dd offset __unwindtable$??0?$_Vector_alloc@$0A@U?$_Vec_base_types@IV?$allocator@I@std@@@std@@@std@@QAE@ABV?$allocator@I@1@@Z
.xdata$x:000046F4                 db    0
.xdata$x:000046F5                 db    0
.xdata$x:000046F6                 db    0
.xdata$x:000046F7                 db    0
.xdata$x:000046F8                 db    0
.xdata$x:000046F9                 db    0
.xdata$x:000046FA                 db    0
.xdata$x:000046FB                 db    0
.xdata$x:000046FC                 db    0
.xdata$x:000046FD                 db    0
.xdata$x:000046FE                 db    0
.xdata$x:000046FF                 db    0
.xdata$x:00004700                 db    0
.xdata$x:00004701                 db    0
.xdata$x:00004702                 db    0
.xdata$x:00004703                 db    0
.xdata$x:00004704                 db    0
.xdata$x:00004705                 db    0
.xdata$x:00004706                 db    0
.xdata$x:00004707                 db    0
.xdata$x:00004708                 db    0
.xdata$x:00004709                 db    0
.xdata$x:0000470A                 db    0
.xdata$x:0000470B                 db    0
.xdata$x:0000470B _xdata$x        ends
.xdata$x:0000470B
.xdata$x:0000470C ; ===========================================================================
.xdata$x:0000470C
.xdata$x:0000470C ; Segment type: Pure data
.xdata$x:0000470C ; Segment permissions: Read
.xdata$x:0000470C _xdata$x        segment dword public 'DATA' use32
.xdata$x:0000470C                 assume cs:_xdata$x
.xdata$x:0000470C                 ;org 470Ch
.xdata$x:0000470C ; COMDAT (pick associative to section at 2AC8)
.xdata$x:0000470C __unwindtable$??1?$_Vector_alloc@$0A@U?$_Vec_base_types@IV?$allocator@I@std@@@std@@@std@@QAE@XZ db 0FFh
.xdata$x:0000470C                                         ; DATA XREF: .xdata$x:0000471Co
.xdata$x:0000470D                 db 0FFh
.xdata$x:0000470E                 db 0FFh
.xdata$x:0000470F                 db 0FFh
.xdata$x:00004710                 dd offset __unwindfunclet$??1?$_Vector_alloc@$0A@U?$_Vec_base_types@IV?$allocator@I@std@@@std@@@std@@QAE@XZ$0
.xdata$x:00004714 __ehfuncinfo$??1?$_Vector_alloc@$0A@U?$_Vec_base_types@IV?$allocator@I@std@@@std@@@std@@QAE@XZ db  22h ; "
.xdata$x:00004714                                         ; DATA XREF: __ehhandler$??1?$_Vector_alloc@$0A@U?$_Vec_base_types@IV?$allocator@I@std@@@std@@@std@@QAE@XZ+11o
.xdata$x:00004715                 db    5
.xdata$x:00004716                 db  93h ; Ã´
.xdata$x:00004717                 db  19h
.xdata$x:00004718                 db    1
.xdata$x:00004719                 db    0
.xdata$x:0000471A                 db    0
.xdata$x:0000471B                 db    0
.xdata$x:0000471C                 dd offset __unwindtable$??1?$_Vector_alloc@$0A@U?$_Vec_base_types@IV?$allocator@I@std@@@std@@@std@@QAE@XZ
.xdata$x:00004720                 db    0
.xdata$x:00004721                 db    0
.xdata$x:00004722                 db    0
.xdata$x:00004723                 db    0
.xdata$x:00004724                 db    0
.xdata$x:00004725                 db    0
.xdata$x:00004726                 db    0
.xdata$x:00004727                 db    0
.xdata$x:00004728                 db    0
.xdata$x:00004729                 db    0
.xdata$x:0000472A                 db    0
.xdata$x:0000472B                 db    0
.xdata$x:0000472C                 db    0
.xdata$x:0000472D                 db    0
.xdata$x:0000472E                 db    0
.xdata$x:0000472F                 db    0
.xdata$x:00004730                 db    0
.xdata$x:00004731                 db    0
.xdata$x:00004732                 db    0
.xdata$x:00004733                 db    0
.xdata$x:00004734                 db    0
.xdata$x:00004735                 db    0
.xdata$x:00004736                 db    0
.xdata$x:00004737                 db    0
.xdata$x:00004737 _xdata$x        ends
.xdata$x:00004737
.xdata$x:00004738 ; ===========================================================================
.xdata$x:00004738
.xdata$x:00004738 ; Segment type: Pure data
.xdata$x:00004738 ; Segment permissions: Read
.xdata$x:00004738 _xdata$x        segment dword public 'DATA' use32
.xdata$x:00004738                 assume cs:_xdata$x
.xdata$x:00004738                 ;org 4738h
.xdata$x:00004738 ; COMDAT (pick associative to section at 274C)
.xdata$x:00004738 __unwindtable$??0?$vector@IV?$allocator@I@std@@@std@@QAE@XZ db 0FFh
.xdata$x:00004738                                         ; DATA XREF: .xdata$x:00004748o
.xdata$x:00004739                 db 0FFh
.xdata$x:0000473A                 db 0FFh
.xdata$x:0000473B                 db 0FFh
.xdata$x:0000473C                 dd offset __unwindfunclet$??0?$vector@IV?$allocator@I@std@@@std@@QAE@XZ$0
.xdata$x:00004740 __ehfuncinfo$??0?$vector@IV?$allocator@I@std@@@std@@QAE@XZ db  22h ; "
.xdata$x:00004740                                         ; DATA XREF: __ehhandler$??0?$vector@IV?$allocator@I@std@@@std@@QAE@XZ+11o
.xdata$x:00004741                 db    5
.xdata$x:00004742                 db  93h ; Ã´
.xdata$x:00004743                 db  19h
.xdata$x:00004744                 db    1
.xdata$x:00004745                 db    0
.xdata$x:00004746                 db    0
.xdata$x:00004747                 db    0
.xdata$x:00004748                 dd offset __unwindtable$??0?$vector@IV?$allocator@I@std@@@std@@QAE@XZ
.xdata$x:0000474C                 db    0
.xdata$x:0000474D                 db    0
.xdata$x:0000474E                 db    0
.xdata$x:0000474F                 db    0
.xdata$x:00004750                 db    0
.xdata$x:00004751                 db    0
.xdata$x:00004752                 db    0
.xdata$x:00004753                 db    0
.xdata$x:00004754                 db    0
.xdata$x:00004755                 db    0
.xdata$x:00004756                 db    0
.xdata$x:00004757                 db    0
.xdata$x:00004758                 db    0
.xdata$x:00004759                 db    0
.xdata$x:0000475A                 db    0
.xdata$x:0000475B                 db    0
.xdata$x:0000475C                 db    0
.xdata$x:0000475D                 db    0
.xdata$x:0000475E                 db    0
.xdata$x:0000475F                 db    0
.xdata$x:00004760                 db    0
.xdata$x:00004761                 db    0
.xdata$x:00004762                 db    0
.xdata$x:00004763                 db    0
.xdata$x:00004763 _xdata$x        ends
.xdata$x:00004763
.xdata$x:00004764 ; ===========================================================================
.xdata$x:00004764
.xdata$x:00004764 ; Segment type: Pure data
.xdata$x:00004764 ; Segment permissions: Read
.xdata$x:00004764 _xdata$x        segment dword public 'DATA' use32
.xdata$x:00004764                 assume cs:_xdata$x
.xdata$x:00004764                 ;org 4764h
.xdata$x:00004764 ; COMDAT (pick associative to section at 2C2C)
.xdata$x:00004764 __unwindtable$??1?$vector@IV?$allocator@I@std@@@std@@QAE@XZ db 0FFh
.xdata$x:00004764                                         ; DATA XREF: .xdata$x:00004774o
.xdata$x:00004765                 db 0FFh
.xdata$x:00004766                 db 0FFh
.xdata$x:00004767                 db 0FFh
.xdata$x:00004768                 dd offset __unwindfunclet$??1?$vector@IV?$allocator@I@std@@@std@@QAE@XZ$0
.xdata$x:0000476C __ehfuncinfo$??1?$vector@IV?$allocator@I@std@@@std@@QAE@XZ db  22h ; "
.xdata$x:0000476C                                         ; DATA XREF: __ehhandler$??1?$vector@IV?$allocator@I@std@@@std@@QAE@XZ+11o
.xdata$x:0000476D                 db    5
.xdata$x:0000476E                 db  93h ; Ã´
.xdata$x:0000476F                 db  19h
.xdata$x:00004770                 db    1
.xdata$x:00004771                 db    0
.xdata$x:00004772                 db    0
.xdata$x:00004773                 db    0
.xdata$x:00004774                 dd offset __unwindtable$??1?$vector@IV?$allocator@I@std@@@std@@QAE@XZ
.xdata$x:00004778                 db    0
.xdata$x:00004779                 db    0
.xdata$x:0000477A                 db    0
.xdata$x:0000477B                 db    0
.xdata$x:0000477C                 db    0
.xdata$x:0000477D                 db    0
.xdata$x:0000477E                 db    0
.xdata$x:0000477F                 db    0
.xdata$x:00004780                 db    0
.xdata$x:00004781                 db    0
.xdata$x:00004782                 db    0
.xdata$x:00004783                 db    0
.xdata$x:00004784                 db    0
.xdata$x:00004785                 db    0
.xdata$x:00004786                 db    0
.xdata$x:00004787                 db    0
.xdata$x:00004788                 db    0
.xdata$x:00004789                 db    0
.xdata$x:0000478A                 db    0
.xdata$x:0000478B                 db    0
.xdata$x:0000478C                 db    0
.xdata$x:0000478D                 db    0
.xdata$x:0000478E                 db    0
.xdata$x:0000478F                 db    0
.xdata$x:0000478F _xdata$x        ends
.xdata$x:0000478F
.xdata$x:00004790 ; ===========================================================================
.xdata$x:00004790
.xdata$x:00004790 ; Segment type: Pure data
.xdata$x:00004790 ; Segment permissions: Read
.xdata$x:00004790 _xdata$x        segment dword public 'DATA' use32
.xdata$x:00004790                 assume cs:_xdata$x
.xdata$x:00004790                 ;org 4790h
.xdata$x:00004790 ; COMDAT (pick associative to section at 22BC)
.xdata$x:00004790 __unwindtable$??$construct@U_Container_proxy@std@@U12@@?$allocator@U_Container_proxy@std@@@std@@QAEXPAU_Container_proxy@1@$$QAU21@@Z db 0FFh
.xdata$x:00004790                                         ; DATA XREF: .xdata$x:000047A0o
.xdata$x:00004791                 db 0FFh
.xdata$x:00004792                 db 0FFh
.xdata$x:00004793                 db 0FFh
.xdata$x:00004794                 dd offset __unwindfunclet$??$construct@U_Container_proxy@std@@U12@@?$allocator@U_Container_proxy@std@@@std@@QAEXPAU_Container_proxy@1@$$QAU21@@Z$0
.xdata$x:00004798 __ehfuncinfo$??$construct@U_Container_proxy@std@@U12@@?$allocator@U_Container_proxy@std@@@std@@QAEXPAU_Container_proxy@1@$$QAU21@@Z db  22h ; "
.xdata$x:00004798                                         ; DATA XREF: __ehhandler$??$construct@U_Container_proxy@std@@U12@@?$allocator@U_Container_proxy@std@@@std@@QAEXPAU_Container_proxy@1@$$QAU21@@Z+11o
.xdata$x:00004799                 db    5
.xdata$x:0000479A                 db  93h ; Ã´
.xdata$x:0000479B                 db  19h
.xdata$x:0000479C                 db    1
.xdata$x:0000479D                 db    0
.xdata$x:0000479E                 db    0
.xdata$x:0000479F                 db    0
.xdata$x:000047A0                 dd offset __unwindtable$??$construct@U_Container_proxy@std@@U12@@?$allocator@U_Container_proxy@std@@@std@@QAEXPAU_Container_proxy@1@$$QAU21@@Z
.xdata$x:000047A4                 db    0
.xdata$x:000047A5                 db    0
.xdata$x:000047A6                 db    0
.xdata$x:000047A7                 db    0
.xdata$x:000047A8                 db    0
.xdata$x:000047A9                 db    0
.xdata$x:000047AA                 db    0
.xdata$x:000047AB                 db    0
.xdata$x:000047AC                 db    0
.xdata$x:000047AD                 db    0
.xdata$x:000047AE                 db    0
.xdata$x:000047AF                 db    0
.xdata$x:000047B0                 db    0
.xdata$x:000047B1                 db    0
.xdata$x:000047B2                 db    0
.xdata$x:000047B3                 db    0
.xdata$x:000047B4                 db    0
.xdata$x:000047B5                 db    0
.xdata$x:000047B6                 db    0
.xdata$x:000047B7                 db    0
.xdata$x:000047B8                 db    0
.xdata$x:000047B9                 db    0
.xdata$x:000047BA                 db    0
.xdata$x:000047BB                 db    0
.xdata$x:000047BB _xdata$x        ends
.xdata$x:000047BB
.xdata$x:000047BC ; ===========================================================================
.xdata$x:000047BC
.xdata$x:000047BC ; Segment type: Pure data
.xdata$x:000047BC ; Segment permissions: Read
.xdata$x:000047BC _xdata$x        segment dword public 'DATA' use32
.xdata$x:000047BC                 assume cs:_xdata$x
.xdata$x:000047BC                 ;org 47BCh
.xdata$x:000047BC ; COMDAT (pick associative to section at 21BC)
.xdata$x:000047BC __unwindtable$??$construct@PADAAPAD@?$allocator@D@std@@QAEXPAPADAAPAD@Z db 0FFh
.xdata$x:000047BC                                         ; DATA XREF: .xdata$x:000047CCo
.xdata$x:000047BD                 db 0FFh
.xdata$x:000047BE                 db 0FFh
.xdata$x:000047BF                 db 0FFh
.xdata$x:000047C0                 dd offset __unwindfunclet$??$construct@PADAAPAD@?$allocator@D@std@@QAEXPAPADAAPAD@Z$0
.xdata$x:000047C4 __ehfuncinfo$??$construct@PADAAPAD@?$allocator@D@std@@QAEXPAPADAAPAD@Z db  22h ; "
.xdata$x:000047C4                                         ; DATA XREF: __ehhandler$??$construct@PADAAPAD@?$allocator@D@std@@QAEXPAPADAAPAD@Z+11o
.xdata$x:000047C5                 db    5
.xdata$x:000047C6                 db  93h ; Ã´
.xdata$x:000047C7                 db  19h
.xdata$x:000047C8                 db    1
.xdata$x:000047C9                 db    0
.xdata$x:000047CA                 db    0
.xdata$x:000047CB                 db    0
.xdata$x:000047CC                 dd offset __unwindtable$??$construct@PADAAPAD@?$allocator@D@std@@QAEXPAPADAAPAD@Z
.xdata$x:000047D0                 db    0
.xdata$x:000047D1                 db    0
.xdata$x:000047D2                 db    0
.xdata$x:000047D3                 db    0
.xdata$x:000047D4                 db    0
.xdata$x:000047D5                 db    0
.xdata$x:000047D6                 db    0
.xdata$x:000047D7                 db    0
.xdata$x:000047D8                 db    0
.xdata$x:000047D9                 db    0
.xdata$x:000047DA                 db    0
.xdata$x:000047DB                 db    0
.xdata$x:000047DC                 db    0
.xdata$x:000047DD                 db    0
.xdata$x:000047DE                 db    0
.xdata$x:000047DF                 db    0
.xdata$x:000047E0                 db    0
.xdata$x:000047E1                 db    0
.xdata$x:000047E2                 db    0
.xdata$x:000047E3                 db    0
.xdata$x:000047E4                 db    0
.xdata$x:000047E5                 db    0
.xdata$x:000047E6                 db    0
.xdata$x:000047E7                 db    0
.xdata$x:000047E7 _xdata$x        ends
.xdata$x:000047E7
.bss:000047E8 ; ===========================================================================
.bss:000047E8
.bss:000047E8 ; Segment type: Uninitialized
.bss:000047E8 ; Segment permissions: Read/Write
.bss:000047E8 _bss            segment byte public 'BSS' use32
.bss:000047E8                 assume cs:_bss
.bss:000047E8                 ;org 47E8h
.bss:000047E8                 assume es:nothing, ss:nothing, ds:_data, fs:nothing, gs:nothing
.bss:000047E8 __Tuple_alloc   db    ? ;
.bss:000047E9 ; std::_Ignore ignore
.bss:000047E9 _ignore         db    ? ;               ; DATA XREF: std::`dynamic initializer for 'ignore''(void)+3o
.bss:000047EA _allocator_arg  db    ? ;
.bss:000047EB _piecewise_construct db    ? ;
.bss:000047EB _bss            ends
.bss:000047EB
.rdata:000047EC ; ===========================================================================
.rdata:000047EC
.rdata:000047EC ; Segment type: Pure data
.rdata:000047EC ; Segment permissions: Read
.rdata:000047EC _rdata          segment dword public 'DATA' use32
.rdata:000047EC                 assume cs:_rdata
.rdata:000047EC                 ;org 47ECh
.rdata:000047EC ; COMDAT (pick largest)
.rdata:000047EC                 dd offset ??_R4error_category@std@@6B@ ; const std::error_category::`RTTI Complete Object Locator'
.rdata:000047F0                 public ??_7error_category@std@@6B@
.rdata:000047F0 ; const std::error_category::`vftable'
.rdata:000047F0 ??_7error_category@std@@6B@ dd offset ??_Eerror_category@std@@UAEPAXI@Z
.rdata:000047F0                                         ; DATA XREF: std::error_category::error_category(void)+Ao
.rdata:000047F0                                         ; std::error_category::~error_category(void)+Ao
.rdata:000047F0                                         ; std::error_category::`vector deleting destructor'(uint)
.rdata:000047F4                 dd offset __purecall
.rdata:000047F8                 dd offset __purecall
.rdata:000047FC                 dd offset ?default_error_condition@error_category@std@@UBE?AVerror_condition@2@H@Z ; std::error_category::default_error_condition(int)
.rdata:00004800                 dd offset ?equivalent@error_category@std@@UBE_NABVerror_code@2@H@Z ; std::error_category::equivalent(std::error_code const &,int)
.rdata:00004804                 dd offset ?equivalent@error_category@std@@UBE_NHABVerror_condition@2@@Z ; std::error_category::equivalent(int,std::error_condition const &)
.rdata:00004804 _rdata          ends
.rdata:00004804
.rdata:00004808 ; ===========================================================================
.rdata:00004808
.rdata:00004808 ; Segment type: Pure data
.rdata:00004808 ; Segment permissions: Read
.rdata:00004808 _rdata          segment dword public 'DATA' use32
.rdata:00004808                 assume cs:_rdata
.rdata:00004808                 ;org 4808h
.rdata:00004808 ; COMDAT (pick largest)
.rdata:00004808                 dd offset ??_R4_Generic_error_category@std@@6B@ ; const std::_Generic_error_category::`RTTI Complete Object Locator'
.rdata:0000480C                 public ??_7_Generic_error_category@std@@6B@
.rdata:0000480C ; const std::_Generic_error_category::`vftable'
.rdata:0000480C ??_7_Generic_error_category@std@@6B@ dd offset ??_E_Generic_error_category@std@@UAEPAXI@Z
.rdata:0000480C                                         ; DATA XREF: std::_Generic_error_category::_Generic_error_category(void)+38o
.rdata:0000480C                                         ; std::_Generic_error_category::`vector deleting destructor'(uint)
.rdata:00004810                 dd offset ?name@_Generic_error_category@std@@UBEPBDXZ ; std::_Generic_error_category::name(void)
.rdata:00004814                 dd offset ?message@_Generic_error_category@std@@UBE?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@2@H@Z ; std::_Generic_error_category::message(int)
.rdata:00004818                 dd offset ?default_error_condition@error_category@std@@UBE?AVerror_condition@2@H@Z ; std::error_category::default_error_condition(int)
.rdata:0000481C                 dd offset ?equivalent@error_category@std@@UBE_NABVerror_code@2@H@Z ; std::error_category::equivalent(std::error_code const &,int)
.rdata:00004820                 dd offset ?equivalent@error_category@std@@UBE_NHABVerror_condition@2@@Z ; std::error_category::equivalent(int,std::error_condition const &)
.rdata:00004820 _rdata          ends
.rdata:00004820
.rdata:00004824 ; ===========================================================================
.rdata:00004824
.rdata:00004824 ; Segment type: Pure data
.rdata:00004824 ; Segment permissions: Read
.rdata:00004824 _rdata          segment dword public 'DATA' use32
.rdata:00004824                 assume cs:_rdata
.rdata:00004824                 ;org 4824h
.rdata:00004824 ; COMDAT (pick any)
.rdata:00004824                 public ??_C@_07DCLBNMLN@generic?$AA@
.rdata:00004824 ; `string'
.rdata:00004824 ??_C@_07DCLBNMLN@generic?$AA@ db 'generic',0
.rdata:00004824                                         ; DATA XREF: std::_Generic_error_category::name(void)+7o
.rdata:00004824 _rdata          ends
.rdata:00004824
.rdata:0000482C ; ===========================================================================
.rdata:0000482C
.rdata:0000482C ; Segment type: Pure data
.rdata:0000482C ; Segment permissions: Read
.rdata:0000482C _rdata          segment dword public 'DATA' use32
.rdata:0000482C                 assume cs:_rdata
.rdata:0000482C                 ;org 482Ch
.rdata:0000482C ; COMDAT (pick any)
.rdata:0000482C                 public ??_C@_0O@BFJCFAAK@unknown?5error?$AA@
.rdata:0000482C ; `string'
.rdata:0000482C ??_C@_0O@BFJCFAAK@unknown?5error?$AA@ db 'unknown error',0
.rdata:0000482C                                         ; DATA XREF: std::_Generic_error_category::message(int):loc_3E70o
.rdata:0000482C                                         ; std::_System_error_category::message(int):loc_3FECo
.rdata:0000483A                 align 4
.rdata:0000483A _rdata          ends
.rdata:0000483A
.rdata:0000483C ; ===========================================================================
.rdata:0000483C
.rdata:0000483C ; Segment type: Pure data
.rdata:0000483C ; Segment permissions: Read
.rdata:0000483C _rdata          segment dword public 'DATA' use32
.rdata:0000483C                 assume cs:_rdata
.rdata:0000483C                 ;org 483Ch
.rdata:0000483C ; COMDAT (pick largest)
.rdata:0000483C                 dd offset ??_R4_Iostream_error_category@std@@6B@ ; const std::_Iostream_error_category::`RTTI Complete Object Locator'
.rdata:00004840                 public ??_7_Iostream_error_category@std@@6B@
.rdata:00004840 ; const std::_Iostream_error_category::`vftable'
.rdata:00004840 ??_7_Iostream_error_category@std@@6B@ dd offset ??_E_Iostream_error_category@std@@UAEPAXI@Z
.rdata:00004840                                         ; DATA XREF: std::_Iostream_error_category::_Iostream_error_category(void)+38o
.rdata:00004840                                         ; std::_Iostream_error_category::`vector deleting destructor'(uint)
.rdata:00004844                 dd offset ?name@_Iostream_error_category@std@@UBEPBDXZ ; std::_Iostream_error_category::name(void)
.rdata:00004848                 dd offset ?message@_Iostream_error_category@std@@UBE?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@2@H@Z ; std::_Iostream_error_category::message(int)
.rdata:0000484C                 dd offset ?default_error_condition@error_category@std@@UBE?AVerror_condition@2@H@Z ; std::error_category::default_error_condition(int)
.rdata:00004850                 dd offset ?equivalent@error_category@std@@UBE_NABVerror_code@2@H@Z ; std::error_category::equivalent(std::error_code const &,int)
.rdata:00004854                 dd offset ?equivalent@error_category@std@@UBE_NHABVerror_condition@2@@Z ; std::error_category::equivalent(int,std::error_condition const &)
.rdata:00004854 _rdata          ends
.rdata:00004854
.rdata:00004858 ; ===========================================================================
.rdata:00004858
.rdata:00004858 ; Segment type: Pure data
.rdata:00004858 ; Segment permissions: Read
.rdata:00004858 _rdata          segment dword public 'DATA' use32
.rdata:00004858                 assume cs:_rdata
.rdata:00004858                 ;org 4858h
.rdata:00004858 ; COMDAT (pick any)
.rdata:00004858                 public ??_C@_08LLGCOLLL@iostream?$AA@
.rdata:00004858 ; `string'
.rdata:00004858 ??_C@_08LLGCOLLL@iostream?$AA@ db 'iostream',0
.rdata:00004858                                         ; DATA XREF: std::_Iostream_error_category::name(void)+7o
.rdata:00004861                 align 4
.rdata:00004861 _rdata          ends
.rdata:00004861
.rdata:00004864 ; ===========================================================================
.rdata:00004864
.rdata:00004864 ; Segment type: Pure data
.rdata:00004864 ; Segment permissions: Read
.rdata:00004864 _rdata          segment dword public 'DATA' use32
.rdata:00004864                 assume cs:_rdata
.rdata:00004864                 ;org 4864h
.rdata:00004864 ; COMDAT (pick any)
.rdata:00004864                 public ??_C@_0BG@PADBLCHM@iostream?5stream?5error?$AA@
.rdata:00004864 ; char `string'[]
.rdata:00004864 ??_C@_0BG@PADBLCHM@iostream?5stream?5error?$AA@ db 'iostream stream error',0
.rdata:00004864                                         ; DATA XREF: std::_Iostream_error_category::message(int)+35o
.rdata:0000487A                 align 4
.rdata:0000487A _rdata          ends
.rdata:0000487A
.rdata:0000487C ; ===========================================================================
.rdata:0000487C
.rdata:0000487C ; Segment type: Pure data
.rdata:0000487C ; Segment permissions: Read
.rdata:0000487C _rdata          segment dword public 'DATA' use32
.rdata:0000487C                 assume cs:_rdata
.rdata:0000487C                 ;org 487Ch
.rdata:0000487C ; COMDAT (pick largest)
.rdata:0000487C                 dd offset ??_R4_System_error_category@std@@6B@ ; const std::_System_error_category::`RTTI Complete Object Locator'
.rdata:00004880                 public ??_7_System_error_category@std@@6B@
.rdata:00004880 ; const std::_System_error_category::`vftable'
.rdata:00004880 ??_7_System_error_category@std@@6B@ dd offset ??_E_System_error_category@std@@UAEPAXI@Z
.rdata:00004880                                         ; DATA XREF: std::_System_error_category::_System_error_category(void)+38o
.rdata:00004880                                         ; std::_System_error_category::`vector deleting destructor'(uint)
.rdata:00004884                 dd offset ?name@_System_error_category@std@@UBEPBDXZ ; std::_System_error_category::name(void)
.rdata:00004888                 dd offset ?message@_System_error_category@std@@UBE?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@2@H@Z ; std::_System_error_category::message(int)
.rdata:0000488C                 dd offset ?default_error_condition@_System_error_category@std@@UBE?AVerror_condition@2@H@Z ; std::_System_error_category::default_error_condition(int)
.rdata:00004890                 dd offset ?equivalent@error_category@std@@UBE_NABVerror_code@2@H@Z ; std::error_category::equivalent(std::error_code const &,int)
.rdata:00004894                 dd offset ?equivalent@error_category@std@@UBE_NHABVerror_condition@2@@Z ; std::error_category::equivalent(int,std::error_condition const &)
.rdata:00004894 _rdata          ends
.rdata:00004894
.rdata:00004898 ; ===========================================================================
.rdata:00004898
.rdata:00004898 ; Segment type: Pure data
.rdata:00004898 ; Segment permissions: Read
.rdata:00004898 _rdata          segment dword public 'DATA' use32
.rdata:00004898                 assume cs:_rdata
.rdata:00004898                 ;org 4898h
.rdata:00004898 ; COMDAT (pick any)
.rdata:00004898                 public ??_C@_06FHFOAHML@system?$AA@
.rdata:00004898 ; `string'
.rdata:00004898 ??_C@_06FHFOAHML@system?$AA@ db 'system',0
.rdata:00004898                                         ; DATA XREF: std::_System_error_category::name(void)+7o
.rdata:0000489F                 align 10h
.rdata:0000489F _rdata          ends
.rdata:0000489F
.bss:000048A0 ; ===========================================================================
.bss:000048A0
.bss:000048A0 ; Segment type: Uninitialized
.bss:000048A0 ; Segment permissions: Read/Write
.bss:000048A0 _bss            segment dword public 'BSS' use32
.bss:000048A0                 assume cs:_bss
.bss:000048A0                 ;org 48A0h
.bss:000048A0 ; COMDAT (pick any)
.bss:000048A0                 assume es:nothing, ss:nothing, ds:_data, fs:nothing, gs:nothing
.bss:000048A0                 public ?_Generic_object@?$_Error_objects@H@std@@2V_Generic_error_category@2@A
.bss:000048A0 ; std::_Generic_error_category std::_Error_objects<int>::_Generic_object
.bss:000048A0 ?_Generic_object@?$_Error_objects@H@std@@2V_Generic_error_category@2@A db    ? ;
.bss:000048A0                                         ; DATA XREF: `dynamic initializer for 'std::_Generic_error_category std::_Error_objects<int>::_Generic_object''(void)+3o
.bss:000048A0                                         ; `dynamic atexit destructor for 'std::_Generic_error_category std::_Error_objects<int>::_Generic_object''(void)+3o ...
.bss:000048A1                 db    ? ;
.bss:000048A2                 db    ? ;
.bss:000048A3                 db    ? ;
.bss:000048A3 _bss            ends
.bss:000048A3
.bss:000048A4 ; ===========================================================================
.bss:000048A4
.bss:000048A4 ; Segment type: Uninitialized
.bss:000048A4 ; Segment permissions: Read/Write
.bss:000048A4 _bss            segment dword public 'BSS' use32
.bss:000048A4                 assume cs:_bss
.bss:000048A4                 ;org 48A4h
.bss:000048A4 ; COMDAT (pick any)
.bss:000048A4                 assume es:nothing, ss:nothing, ds:_data, fs:nothing, gs:nothing
.bss:000048A4                 public ?_Iostream_object@?$_Error_objects@H@std@@2V_Iostream_error_category@2@A
.bss:000048A4 ; std::_Iostream_error_category std::_Error_objects<int>::_Iostream_object
.bss:000048A4 ?_Iostream_object@?$_Error_objects@H@std@@2V_Iostream_error_category@2@A db    ? ;
.bss:000048A4                                         ; DATA XREF: `dynamic initializer for 'std::_Iostream_error_category std::_Error_objects<int>::_Iostream_object''(void)+3o
.bss:000048A4                                         ; `dynamic atexit destructor for 'std::_Iostream_error_category std::_Error_objects<int>::_Iostream_object''(void)+3o
.bss:000048A5                 db    ? ;
.bss:000048A6                 db    ? ;
.bss:000048A7                 db    ? ;
.bss:000048A7 _bss            ends
.bss:000048A7
.bss:000048A8 ; ===========================================================================
.bss:000048A8
.bss:000048A8 ; Segment type: Uninitialized
.bss:000048A8 ; Segment permissions: Read/Write
.bss:000048A8 _bss            segment dword public 'BSS' use32
.bss:000048A8                 assume cs:_bss
.bss:000048A8                 ;org 48A8h
.bss:000048A8 ; COMDAT (pick any)
.bss:000048A8                 assume es:nothing, ss:nothing, ds:_data, fs:nothing, gs:nothing
.bss:000048A8                 public ?_System_object@?$_Error_objects@H@std@@2V_System_error_category@2@A
.bss:000048A8 ; std::_System_error_category std::_Error_objects<int>::_System_object
.bss:000048A8 ?_System_object@?$_Error_objects@H@std@@2V_System_error_category@2@A db    ? ;
.bss:000048A8                                         ; DATA XREF: `dynamic initializer for 'std::_System_error_category std::_Error_objects<int>::_System_object''(void)+3o
.bss:000048A8                                         ; `dynamic atexit destructor for 'std::_System_error_category std::_Error_objects<int>::_System_object''(void)+3o ...
.bss:000048A9                 db    ? ;
.bss:000048AA                 db    ? ;
.bss:000048AB                 db    ? ;
.bss:000048AB _bss            ends
.bss:000048AB
.bss:000048AC ; ===========================================================================
.bss:000048AC
.bss:000048AC ; Segment type: Uninitialized
.bss:000048AC ; Segment permissions: Read/Write
.bss:000048AC _bss            segment dword public 'BSS' use32
.bss:000048AC                 assume cs:_bss
.bss:000048AC                 ;org 48ACh
.bss:000048AC ; COMDAT (pick any)
.bss:000048AC                 assume es:nothing, ss:nothing, ds:_data, fs:nothing, gs:nothing
.bss:000048AC                 public ?id@?$num_put@DV?$back_insert_iterator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@std@@2V0locale@2@A
.bss:000048AC ; std::locale::id std::num_put<char,std::back_insert_iterator<std::basic_string<char,std::char_traits<char>,std::allocator<char>>>>::id
.bss:000048AC ?id@?$num_put@DV?$back_insert_iterator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@std@@2V0locale@2@A db    ? ;
.bss:000048AC                                         ; DATA XREF: `dynamic initializer for 'std::locale::id std::num_put<char,std::back_insert_iterator<std::basic_string<char,std::char_traits<char>,std::allocator<char>>>>::id''(void)+5o
.bss:000048AD                 db    ? ;
.bss:000048AE                 db    ? ;
.bss:000048AF                 db    ? ;
.bss:000048AF _bss            ends
.bss:000048AF
.bss:000048B0 ; ===========================================================================
.bss:000048B0
.bss:000048B0 ; Segment type: Uninitialized
.bss:000048B0 ; Segment permissions: Read/Write
.bss:000048B0 _bss            segment dword public 'BSS' use32
.bss:000048B0                 assume cs:_bss
.bss:000048B0                 ;org 48B0h
.bss:000048B0 ; COMDAT (pick any)
.bss:000048B0                 assume es:nothing, ss:nothing, ds:_data, fs:nothing, gs:nothing
.bss:000048B0                 public ?id@?$num_put@_WV?$back_insert_iterator@V?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@@std@@@std@@2V0locale@2@A
.bss:000048B0 ; std::locale::id std::num_put<wchar_t,std::back_insert_iterator<std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>>>>::id
.bss:000048B0 ?id@?$num_put@_WV?$back_insert_iterator@V?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@@std@@@std@@2V0locale@2@A db    ? ;
.bss:000048B0                                         ; DATA XREF: `dynamic initializer for 'std::locale::id std::num_put<wchar_t,std::back_insert_iterator<std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>>>>::id''(void)+5o
.bss:000048B1                 db    ? ;
.bss:000048B2                 db    ? ;
.bss:000048B3                 db    ? ;
.bss:000048B3 _bss            ends
.bss:000048B3
.rdata:000048B4 ; ===========================================================================
.rdata:000048B4
.rdata:000048B4 ; Segment type: Pure data
.rdata:000048B4 ; Segment permissions: Read
.rdata:000048B4 ; Segment alignment 'qword' can not be represented in assembly
.rdata:000048B4 _rdata          segment para public 'DATA' use32
.rdata:000048B4                 assume cs:_rdata
.rdata:000048B4                 ;org 48B4h
.rdata:000048B4 ; COMDAT (pick any)
.rdata:000048B4                 public ??_C@_1IO@FEAPGJBD@?$AAC?$AA?3?$AA?2?$AAP?$AAr?$AAo?$AAg?$AAr?$AAa?$AAm?$AA?5?$AAF?$AAi?$AAl?$AAe?$AAs?$AA?5?$AA?$CI?$AAx?$AA8?$AA6?$AA?$CJ?$AA?2?$AAM?$AAi?$AAc?$AAr?$AAo?$AAs?$AAo?$AAf?$AAt@
.rdata:000048B4 ; wchar_t `string'
.rdata:000048B4 ??_C@_1IO@FEAPGJBD@?$AAC?$AA?3?$AA?2?$AAP?$AAr?$AAo?$AAg?$AAr?$AAa?$AAm?$AA?5?$AAF?$AAi?$AAl?$AAe?$AAs?$AA?5?$AA?$CI?$AAx?$AA8?$AA6?$AA?$CJ?$AA?2?$AAM?$AAi?$AAc?$AAr?$AAo?$AAs?$AAo?$AAf?$AAt@:
.rdata:000048B4                                         ; DATA XREF: std::basic_string<char,std::char_traits<char>,std::allocator<char>>::assign(char const *)+Co
.rdata:000048B4                                         ; std::basic_string<char,std::char_traits<char>,std::allocator<char>>::assign(char const *,uint)+12o
.rdata:000048B4                 unicode 0, <C:\Program Files (x86)\Microsoft Visual Studio 12.0\VC\in>
.rdata:000048B4                 unicode 0, <clude\xstring>,0
.rdata:00004942                 align 4
.rdata:00004942 _rdata          ends
.rdata:00004942
.bss:00004944 ; ===========================================================================
.bss:00004944
.bss:00004944 ; Segment type: Uninitialized
.bss:00004944 ; Segment permissions: Read/Write
.bss:00004944 _bss            segment dword public 'BSS' use32
.bss:00004944                 assume cs:_bss
.bss:00004944                 ;org 4944h
.bss:00004944 ; COMDAT (pick any)
.bss:00004944                 assume es:nothing, ss:nothing, ds:_data, fs:nothing, gs:nothing
.bss:00004944                 public ?id@?$numpunct@D@std@@2V0locale@2@A
.bss:00004944 ; std::locale::id std::numpunct<char>::id
.bss:00004944 ?id@?$numpunct@D@std@@2V0locale@2@A db    ? ;
.bss:00004944                                         ; DATA XREF: `dynamic initializer for 'std::locale::id std::numpunct<char>::id''(void)+5o
.bss:00004945                 db    ? ;
.bss:00004946                 db    ? ;
.bss:00004947                 db    ? ;
.bss:00004947 _bss            ends
.bss:00004947
.bss:00004948 ; ===========================================================================
.bss:00004948
.bss:00004948 ; Segment type: Uninitialized
.bss:00004948 ; Segment permissions: Read/Write
.bss:00004948 _bss            segment dword public 'BSS' use32
.bss:00004948                 assume cs:_bss
.bss:00004948                 ;org 4948h
.bss:00004948 ; COMDAT (pick any)
.bss:00004948                 assume es:nothing, ss:nothing, ds:_data, fs:nothing, gs:nothing
.bss:00004948                 public ?id@?$numpunct@_W@std@@2V0locale@2@A
.bss:00004948 ; std::locale::id std::numpunct<wchar_t>::id
.bss:00004948 ?id@?$numpunct@_W@std@@2V0locale@2@A db    ? ;
.bss:00004948                                         ; DATA XREF: `dynamic initializer for 'std::locale::id std::numpunct<wchar_t>::id''(void)+5o
.bss:00004949                 db    ? ;
.bss:0000494A                 db    ? ;
.bss:0000494B                 db    ? ;
.bss:0000494B _bss            ends
.bss:0000494B
.rdata:0000494C ; ===========================================================================
.rdata:0000494C
.rdata:0000494C ; Segment type: Pure data
.rdata:0000494C ; Segment permissions: Read
.rdata:0000494C _rdata          segment dword public 'DATA' use32
.rdata:0000494C                 assume cs:_rdata
.rdata:0000494C                 ;org 494Ch
.rdata:0000494C ; COMDAT (pick any)
.rdata:0000494C                 public ??_C@_0BA@JFNIOLAK@string?5too?5long?$AA@
.rdata:0000494C ; char `string'[]
.rdata:0000494C ??_C@_0BA@JFNIOLAK@string?5too?5long?$AA@ db 'string too long',0
.rdata:0000494C                                         ; DATA XREF: std::basic_string<char,std::char_traits<char>,std::allocator<char>>::_Xlen(void)+7o
.rdata:0000494C _rdata          ends
.rdata:0000494C
.rdata:0000495C ; ===========================================================================
.rdata:0000495C
.rdata:0000495C ; Segment type: Pure data
.rdata:0000495C ; Segment permissions: Read
.rdata:0000495C _rdata          segment dword public 'DATA' use32
.rdata:0000495C                 assume cs:_rdata
.rdata:0000495C                 ;org 495Ch
.rdata:0000495C ; COMDAT (pick any)
.rdata:0000495C                 public ??_C@_0BI@CFPLBAOH@invalid?5string?5position?$AA@
.rdata:0000495C ; char `string'[]
.rdata:0000495C ??_C@_0BI@CFPLBAOH@invalid?5string?5position?$AA@ db 'invalid string position',0
.rdata:0000495C                                         ; DATA XREF: std::basic_string<char,std::char_traits<char>,std::allocator<char>>::_Xran(void)+7o
.rdata:0000495C _rdata          ends
.rdata:0000495C
.rdata:00004974 ; ===========================================================================
.rdata:00004974
.rdata:00004974 ; Segment type: Pure data
.rdata:00004974 ; Segment permissions: Read
.rdata:00004974 _rdata          segment dword public 'DATA' use32
.rdata:00004974                 assume cs:_rdata
.rdata:00004974                 ;org 4974h
.rdata:00004974 ; COMDAT (pick any)
.rdata:00004974                 public ??_C@_1CK@EOPGIILJ@?$AAi?$AAn?$AAv?$AAa?$AAl?$AAi?$AAd?$AA?5?$AAn?$AAu?$AAl?$AAl?$AA?5?$AAp?$AAo?$AAi?$AAn?$AAt?$AAe?$AAr?$AA?$AA@
.rdata:00004974 ; wchar_t `string'
.rdata:00004974 ??_C@_1CK@EOPGIILJ@?$AAi?$AAn?$AAv?$AAa?$AAl?$AAi?$AAd?$AA?5?$AAn?$AAu?$AAl?$AAl?$AA?5?$AAp?$AAo?$AAi?$AAn?$AAt?$AAe?$AAr?$AA?$AA@:
.rdata:00004974                                         ; DATA XREF: std::_Debug_pointer<char>(char const *,wchar_t const *,uint)+11o
.rdata:00004974                 unicode 0, <invalid null pointer>,0
.rdata:0000499E                 align 10h
.rdata:0000499E _rdata          ends
.rdata:0000499E
.rdata$r:000049A0 ; ===========================================================================
.rdata$r:000049A0
.rdata$r:000049A0 ; Segment type: Pure data
.rdata$r:000049A0 ; Segment permissions: Read
.rdata$r:000049A0 _rdata$r        segment dword public 'DATA' use32
.rdata$r:000049A0                 assume cs:_rdata$r
.rdata$r:000049A0                 ;org 49A0h
.rdata$r:000049A0 ; COMDAT (pick any)
.rdata$r:000049A0                 public ??_R4error_category@std@@6B@
.rdata$r:000049A0 ; const std::error_category::`RTTI Complete Object Locator'
.rdata$r:000049A0 ??_R4error_category@std@@6B@ db    0    ; DATA XREF: .rdata:000047ECo
.rdata$r:000049A1                 db    0
.rdata$r:000049A2                 db    0
.rdata$r:000049A3                 db    0
.rdata$r:000049A4                 db    0
.rdata$r:000049A5                 db    0
.rdata$r:000049A6                 db    0
.rdata$r:000049A7                 db    0
.rdata$r:000049A8                 db    0
.rdata$r:000049A9                 db    0
.rdata$r:000049AA                 db    0
.rdata$r:000049AB                 db    0
.rdata$r:000049AC                 dd offset ??_R0?AVerror_category@std@@@8 ; std::error_category `RTTI Type Descriptor'
.rdata$r:000049B0                 dd offset ??_R3error_category@std@@8 ; std::error_category::`RTTI Class Hierarchy Descriptor'
.rdata$r:000049B0 _rdata$r        ends
.rdata$r:000049B0
.data$r:000049B4 ; ===========================================================================
.data$r:000049B4
.data$r:000049B4 ; Segment type: Pure data
.data$r:000049B4 ; Segment permissions: Read/Write
.data$r:000049B4 _data$r         segment dword public 'DATA' use32
.data$r:000049B4                 assume cs:_data$r
.data$r:000049B4                 ;org 49B4h
.data$r:000049B4 ; COMDAT (pick any)
.data$r:000049B4                 public ??_R0?AVerror_category@std@@@8
.data$r:000049B4 ; class std::error_category `RTTI Type Descriptor'
.data$r:000049B4 ??_R0?AVerror_category@std@@@8 dd offset ??_7type_info@@6B@
.data$r:000049B4                                         ; DATA XREF: .rdata$r:000049ACo
.data$r:000049B4                                         ; .rdata$r:std::error_category::`RTTI Base Class Descriptor at (0,-1,0,64)'o
.data$r:000049B4                                         ; const type_info::`vftable'
.data$r:000049B8                 db    0
.data$r:000049B9                 db    0
.data$r:000049BA                 db    0
.data$r:000049BB                 db    0
.data$r:000049BC                 db  2Eh ; .
.data$r:000049BD                 db  3Fh ; ?
.data$r:000049BE                 db  41h ; A
.data$r:000049BF                 db  56h ; V
.data$r:000049C0                 db  65h ; e
.data$r:000049C1                 db  72h ; r
.data$r:000049C2                 db  72h ; r
.data$r:000049C3                 db  6Fh ; o
.data$r:000049C4                 db  72h ; r
.data$r:000049C5                 db  5Fh ; _
.data$r:000049C6                 db  63h ; c
.data$r:000049C7                 db  61h ; a
.data$r:000049C8                 db  74h ; t
.data$r:000049C9                 db  65h ; e
.data$r:000049CA                 db  67h ; g
.data$r:000049CB                 db  6Fh ; o
.data$r:000049CC                 db  72h ; r
.data$r:000049CD                 db  79h ; y
.data$r:000049CE                 db  40h ; @
.data$r:000049CF                 db  73h ; s
.data$r:000049D0                 db  74h ; t
.data$r:000049D1                 db  64h ; d
.data$r:000049D2                 db  40h ; @
.data$r:000049D3                 db  40h ; @
.data$r:000049D4                 db    0
.data$r:000049D5                 align 4
.data$r:000049D5 _data$r         ends
.data$r:000049D5
.rdata$r:000049D8 ; ===========================================================================
.rdata$r:000049D8
.rdata$r:000049D8 ; Segment type: Pure data
.rdata$r:000049D8 ; Segment permissions: Read
.rdata$r:000049D8 _rdata$r        segment dword public 'DATA' use32
.rdata$r:000049D8                 assume cs:_rdata$r
.rdata$r:000049D8                 ;org 49D8h
.rdata$r:000049D8 ; COMDAT (pick any)
.rdata$r:000049D8                 public ??_R3error_category@std@@8
.rdata$r:000049D8 ; std::error_category::`RTTI Class Hierarchy Descriptor'
.rdata$r:000049D8 ??_R3error_category@std@@8 db    0      ; DATA XREF: .rdata$r:000049B0o
.rdata$r:000049D8                                         ; .rdata$r:00004A08o
.rdata$r:000049D9                 db    0
.rdata$r:000049DA                 db    0
.rdata$r:000049DB                 db    0
.rdata$r:000049DC                 db    0
.rdata$r:000049DD                 db    0
.rdata$r:000049DE                 db    0
.rdata$r:000049DF                 db    0
.rdata$r:000049E0                 db    1
.rdata$r:000049E1                 db    0
.rdata$r:000049E2                 db    0
.rdata$r:000049E3                 db    0
.rdata$r:000049E4                 dd offset ??_R2error_category@std@@8 ; std::error_category::`RTTI Base Class Array'
.rdata$r:000049E4 _rdata$r        ends
.rdata$r:000049E4
.rdata$r:000049E8 ; ===========================================================================
.rdata$r:000049E8
.rdata$r:000049E8 ; Segment type: Pure data
.rdata$r:000049E8 ; Segment permissions: Read
.rdata$r:000049E8 _rdata$r        segment dword public 'DATA' use32
.rdata$r:000049E8                 assume cs:_rdata$r
.rdata$r:000049E8                 ;org 49E8h
.rdata$r:000049E8 ; COMDAT (pick any)
.rdata$r:000049E8                 public ??_R2error_category@std@@8
.rdata$r:000049E8 ; std::error_category::`RTTI Base Class Array'
.rdata$r:000049E8 ??_R2error_category@std@@8 dd offset ??_R1A@?0A@EA@error_category@std@@8
.rdata$r:000049E8                                         ; DATA XREF: .rdata$r:000049E4o
.rdata$r:000049E8                                         ; std::error_category::`RTTI Base Class Descriptor at (0,-1,0,64)'
.rdata$r:000049EC                 db    0
.rdata$r:000049ED                 align 10h
.rdata$r:000049ED _rdata$r        ends
.rdata$r:000049ED
.rdata$r:000049F0 ; ===========================================================================
.rdata$r:000049F0
.rdata$r:000049F0 ; Segment type: Pure data
.rdata$r:000049F0 ; Segment permissions: Read
.rdata$r:000049F0 _rdata$r        segment dword public 'DATA' use32
.rdata$r:000049F0                 assume cs:_rdata$r
.rdata$r:000049F0                 ;org 49F0h
.rdata$r:000049F0 ; COMDAT (pick any)
.rdata$r:000049F0                 public ??_R1A@?0A@EA@error_category@std@@8
.rdata$r:000049F0 ; std::error_category::`RTTI Base Class Descriptor at (0, -1, 0, 64)'
.rdata$r:000049F0 ??_R1A@?0A@EA@error_category@std@@8 dd offset ??_R0?AVerror_category@std@@@8
.rdata$r:000049F0                                         ; DATA XREF: .rdata$r:std::error_category::`RTTI Base Class Array'o
.rdata$r:000049F0                                         ; .rdata$r:00004A60o ...
.rdata$r:000049F0                                         ; std::error_category `RTTI Type Descriptor'
.rdata$r:000049F4                 db    0
.rdata$r:000049F5                 db    0
.rdata$r:000049F6                 db    0
.rdata$r:000049F7                 db    0
.rdata$r:000049F8                 db    0
.rdata$r:000049F9                 db    0
.rdata$r:000049FA                 db    0
.rdata$r:000049FB                 db    0
.rdata$r:000049FC                 db 0FFh
.rdata$r:000049FD                 db 0FFh
.rdata$r:000049FE                 db 0FFh
.rdata$r:000049FF                 db 0FFh
.rdata$r:00004A00                 db    0
.rdata$r:00004A01                 db    0
.rdata$r:00004A02                 db    0
.rdata$r:00004A03                 db    0
.rdata$r:00004A04                 db  40h ; @
.rdata$r:00004A05                 db    0
.rdata$r:00004A06                 db    0
.rdata$r:00004A07                 db    0
.rdata$r:00004A08                 dd offset ??_R3error_category@std@@8 ; std::error_category::`RTTI Class Hierarchy Descriptor'
.rdata$r:00004A08 _rdata$r        ends
.rdata$r:00004A08
.rdata$r:00004A0C ; ===========================================================================
.rdata$r:00004A0C
.rdata$r:00004A0C ; Segment type: Pure data
.rdata$r:00004A0C ; Segment permissions: Read
.rdata$r:00004A0C _rdata$r        segment dword public 'DATA' use32
.rdata$r:00004A0C                 assume cs:_rdata$r
.rdata$r:00004A0C                 ;org 4A0Ch
.rdata$r:00004A0C ; COMDAT (pick any)
.rdata$r:00004A0C                 public ??_R4_Generic_error_category@std@@6B@
.rdata$r:00004A0C ; const std::_Generic_error_category::`RTTI Complete Object Locator'
.rdata$r:00004A0C ??_R4_Generic_error_category@std@@6B@ db    0
.rdata$r:00004A0C                                         ; DATA XREF: .rdata:00004808o
.rdata$r:00004A0D                 db    0
.rdata$r:00004A0E                 db    0
.rdata$r:00004A0F                 db    0
.rdata$r:00004A10                 db    0
.rdata$r:00004A11                 db    0
.rdata$r:00004A12                 db    0
.rdata$r:00004A13                 db    0
.rdata$r:00004A14                 db    0
.rdata$r:00004A15                 db    0
.rdata$r:00004A16                 db    0
.rdata$r:00004A17                 db    0
.rdata$r:00004A18                 dd offset ??_R0?AV_Generic_error_category@std@@@8 ; std::_Generic_error_category `RTTI Type Descriptor'
.rdata$r:00004A1C                 dd offset ??_R3_Generic_error_category@std@@8 ; std::_Generic_error_category::`RTTI Class Hierarchy Descriptor'
.rdata$r:00004A1C _rdata$r        ends
.rdata$r:00004A1C
.data$r:00004A20 ; ===========================================================================
.data$r:00004A20
.data$r:00004A20 ; Segment type: Pure data
.data$r:00004A20 ; Segment permissions: Read/Write
.data$r:00004A20 _data$r         segment dword public 'DATA' use32
.data$r:00004A20                 assume cs:_data$r
.data$r:00004A20                 ;org 4A20h
.data$r:00004A20 ; COMDAT (pick any)
.data$r:00004A20                 public ??_R0?AV_Generic_error_category@std@@@8
.data$r:00004A20 ; class std::_Generic_error_category `RTTI Type Descriptor'
.data$r:00004A20 ??_R0?AV_Generic_error_category@std@@@8 dd offset ??_7type_info@@6B@
.data$r:00004A20                                         ; DATA XREF: .rdata$r:00004A18o
.data$r:00004A20                                         ; .rdata$r:std::_Generic_error_category::`RTTI Base Class Descriptor at (0,-1,0,64)'o
.data$r:00004A20                                         ; const type_info::`vftable'
.data$r:00004A24                 align 8
.data$r:00004A28 a_?av_generic_e db '.?AV_Generic_error_category@std@@',0
.data$r:00004A4A                 align 4
.data$r:00004A4A _data$r         ends
.data$r:00004A4A
.rdata$r:00004A4C ; ===========================================================================
.rdata$r:00004A4C
.rdata$r:00004A4C ; Segment type: Pure data
.rdata$r:00004A4C ; Segment permissions: Read
.rdata$r:00004A4C _rdata$r        segment dword public 'DATA' use32
.rdata$r:00004A4C                 assume cs:_rdata$r
.rdata$r:00004A4C                 ;org 4A4Ch
.rdata$r:00004A4C ; COMDAT (pick any)
.rdata$r:00004A4C                 public ??_R3_Generic_error_category@std@@8
.rdata$r:00004A4C ; std::_Generic_error_category::`RTTI Class Hierarchy Descriptor'
.rdata$r:00004A4C ??_R3_Generic_error_category@std@@8 db    0
.rdata$r:00004A4C                                         ; DATA XREF: .rdata$r:00004A1Co
.rdata$r:00004A4C                                         ; .rdata$r:00004A80o
.rdata$r:00004A4D                 db    0
.rdata$r:00004A4E                 db    0
.rdata$r:00004A4F                 db    0
.rdata$r:00004A50                 db    0
.rdata$r:00004A51                 db    0
.rdata$r:00004A52                 db    0
.rdata$r:00004A53                 db    0
.rdata$r:00004A54                 db    2
.rdata$r:00004A55                 db    0
.rdata$r:00004A56                 db    0
.rdata$r:00004A57                 db    0
.rdata$r:00004A58                 dd offset ??_R2_Generic_error_category@std@@8 ; std::_Generic_error_category::`RTTI Base Class Array'
.rdata$r:00004A58 _rdata$r        ends
.rdata$r:00004A58
.rdata$r:00004A5C ; ===========================================================================
.rdata$r:00004A5C
.rdata$r:00004A5C ; Segment type: Pure data
.rdata$r:00004A5C ; Segment permissions: Read
.rdata$r:00004A5C _rdata$r        segment dword public 'DATA' use32
.rdata$r:00004A5C                 assume cs:_rdata$r
.rdata$r:00004A5C                 ;org 4A5Ch
.rdata$r:00004A5C ; COMDAT (pick any)
.rdata$r:00004A5C                 public ??_R2_Generic_error_category@std@@8
.rdata$r:00004A5C ; std::_Generic_error_category::`RTTI Base Class Array'
.rdata$r:00004A5C ??_R2_Generic_error_category@std@@8 dd offset ??_R1A@?0A@EA@_Generic_error_category@std@@8
.rdata$r:00004A5C                                         ; DATA XREF: .rdata$r:00004A58o
.rdata$r:00004A5C                                         ; std::_Generic_error_category::`RTTI Base Class Descriptor at (0,-1,0,64)'
.rdata$r:00004A60                 dd offset ??_R1A@?0A@EA@error_category@std@@8 ; std::error_category::`RTTI Base Class Descriptor at (0,-1,0,64)'
.rdata$r:00004A64                 db    0
.rdata$r:00004A65                 align 4
.rdata$r:00004A65 _rdata$r        ends
.rdata$r:00004A65
.rdata$r:00004A68 ; ===========================================================================
.rdata$r:00004A68
.rdata$r:00004A68 ; Segment type: Pure data
.rdata$r:00004A68 ; Segment permissions: Read
.rdata$r:00004A68 _rdata$r        segment dword public 'DATA' use32
.rdata$r:00004A68                 assume cs:_rdata$r
.rdata$r:00004A68                 ;org 4A68h
.rdata$r:00004A68 ; COMDAT (pick any)
.rdata$r:00004A68                 public ??_R1A@?0A@EA@_Generic_error_category@std@@8
.rdata$r:00004A68 ; std::_Generic_error_category::`RTTI Base Class Descriptor at (0, -1, 0, 64)'
.rdata$r:00004A68 ??_R1A@?0A@EA@_Generic_error_category@std@@8 dd offset ??_R0?AV_Generic_error_category@std@@@8
.rdata$r:00004A68                                         ; DATA XREF: .rdata$r:std::_Generic_error_category::`RTTI Base Class Array'o
.rdata$r:00004A68                                         ; .rdata$r:00004AD8o ...
.rdata$r:00004A68                                         ; std::_Generic_error_category `RTTI Type Descriptor'
.rdata$r:00004A6C                 db    1
.rdata$r:00004A6D                 db    0
.rdata$r:00004A6E                 db    0
.rdata$r:00004A6F                 db    0
.rdata$r:00004A70                 db    0
.rdata$r:00004A71                 db    0
.rdata$r:00004A72                 db    0
.rdata$r:00004A73                 db    0
.rdata$r:00004A74                 db 0FFh
.rdata$r:00004A75                 db 0FFh
.rdata$r:00004A76                 db 0FFh
.rdata$r:00004A77                 db 0FFh
.rdata$r:00004A78                 db    0
.rdata$r:00004A79                 db    0
.rdata$r:00004A7A                 db    0
.rdata$r:00004A7B                 db    0
.rdata$r:00004A7C                 db  40h ; @
.rdata$r:00004A7D                 db    0
.rdata$r:00004A7E                 db    0
.rdata$r:00004A7F                 db    0
.rdata$r:00004A80                 dd offset ??_R3_Generic_error_category@std@@8 ; std::_Generic_error_category::`RTTI Class Hierarchy Descriptor'
.rdata$r:00004A80 _rdata$r        ends
.rdata$r:00004A80
.rdata$r:00004A84 ; ===========================================================================
.rdata$r:00004A84
.rdata$r:00004A84 ; Segment type: Pure data
.rdata$r:00004A84 ; Segment permissions: Read
.rdata$r:00004A84 _rdata$r        segment dword public 'DATA' use32
.rdata$r:00004A84                 assume cs:_rdata$r
.rdata$r:00004A84                 ;org 4A84h
.rdata$r:00004A84 ; COMDAT (pick any)
.rdata$r:00004A84                 public ??_R4_Iostream_error_category@std@@6B@
.rdata$r:00004A84 ; const std::_Iostream_error_category::`RTTI Complete Object Locator'
.rdata$r:00004A84 ??_R4_Iostream_error_category@std@@6B@ db    0
.rdata$r:00004A84                                         ; DATA XREF: .rdata:0000483Co
.rdata$r:00004A85                 db    0
.rdata$r:00004A86                 db    0
.rdata$r:00004A87                 db    0
.rdata$r:00004A88                 db    0
.rdata$r:00004A89                 db    0
.rdata$r:00004A8A                 db    0
.rdata$r:00004A8B                 db    0
.rdata$r:00004A8C                 db    0
.rdata$r:00004A8D                 db    0
.rdata$r:00004A8E                 db    0
.rdata$r:00004A8F                 db    0
.rdata$r:00004A90                 dd offset ??_R0?AV_Iostream_error_category@std@@@8 ; std::_Iostream_error_category `RTTI Type Descriptor'
.rdata$r:00004A94                 dd offset ??_R3_Iostream_error_category@std@@8 ; std::_Iostream_error_category::`RTTI Class Hierarchy Descriptor'
.rdata$r:00004A94 _rdata$r        ends
.rdata$r:00004A94
.data$r:00004A98 ; ===========================================================================
.data$r:00004A98
.data$r:00004A98 ; Segment type: Pure data
.data$r:00004A98 ; Segment permissions: Read/Write
.data$r:00004A98 _data$r         segment dword public 'DATA' use32
.data$r:00004A98                 assume cs:_data$r
.data$r:00004A98                 ;org 4A98h
.data$r:00004A98 ; COMDAT (pick any)
.data$r:00004A98                 public ??_R0?AV_Iostream_error_category@std@@@8
.data$r:00004A98 ; class std::_Iostream_error_category `RTTI Type Descriptor'
.data$r:00004A98 ??_R0?AV_Iostream_error_category@std@@@8 dd offset ??_7type_info@@6B@
.data$r:00004A98                                         ; DATA XREF: .rdata$r:00004A90o
.data$r:00004A98                                         ; .rdata$r:std::_Iostream_error_category::`RTTI Base Class Descriptor at (0,-1,0,64)'o
.data$r:00004A98                                         ; const type_info::`vftable'
.data$r:00004A9C                 align 10h
.data$r:00004AA0 a_?av_iostream_ db '.?AV_Iostream_error_category@std@@',0
.data$r:00004AC3                 align 4
.data$r:00004AC3 _data$r         ends
.data$r:00004AC3
.rdata$r:00004AC4 ; ===========================================================================
.rdata$r:00004AC4
.rdata$r:00004AC4 ; Segment type: Pure data
.rdata$r:00004AC4 ; Segment permissions: Read
.rdata$r:00004AC4 _rdata$r        segment dword public 'DATA' use32
.rdata$r:00004AC4                 assume cs:_rdata$r
.rdata$r:00004AC4                 ;org 4AC4h
.rdata$r:00004AC4 ; COMDAT (pick any)
.rdata$r:00004AC4                 public ??_R3_Iostream_error_category@std@@8
.rdata$r:00004AC4 ; std::_Iostream_error_category::`RTTI Class Hierarchy Descriptor'
.rdata$r:00004AC4 ??_R3_Iostream_error_category@std@@8 db    0
.rdata$r:00004AC4                                         ; DATA XREF: .rdata$r:00004A94o
.rdata$r:00004AC4                                         ; .rdata$r:00004AFCo
.rdata$r:00004AC5                 db    0
.rdata$r:00004AC6                 db    0
.rdata$r:00004AC7                 db    0
.rdata$r:00004AC8                 db    0
.rdata$r:00004AC9                 db    0
.rdata$r:00004ACA                 db    0
.rdata$r:00004ACB                 db    0
.rdata$r:00004ACC                 db    3
.rdata$r:00004ACD                 db    0
.rdata$r:00004ACE                 db    0
.rdata$r:00004ACF                 db    0
.rdata$r:00004AD0                 dd offset ??_R2_Iostream_error_category@std@@8 ; std::_Iostream_error_category::`RTTI Base Class Array'
.rdata$r:00004AD0 _rdata$r        ends
.rdata$r:00004AD0
.rdata$r:00004AD4 ; ===========================================================================
.rdata$r:00004AD4
.rdata$r:00004AD4 ; Segment type: Pure data
.rdata$r:00004AD4 ; Segment permissions: Read
.rdata$r:00004AD4 _rdata$r        segment dword public 'DATA' use32
.rdata$r:00004AD4                 assume cs:_rdata$r
.rdata$r:00004AD4                 ;org 4AD4h
.rdata$r:00004AD4 ; COMDAT (pick any)
.rdata$r:00004AD4                 public ??_R2_Iostream_error_category@std@@8
.rdata$r:00004AD4 ; std::_Iostream_error_category::`RTTI Base Class Array'
.rdata$r:00004AD4 ??_R2_Iostream_error_category@std@@8 dd offset ??_R1A@?0A@EA@_Iostream_error_category@std@@8
.rdata$r:00004AD4                                         ; DATA XREF: .rdata$r:00004AD0o
.rdata$r:00004AD4                                         ; std::_Iostream_error_category::`RTTI Base Class Descriptor at (0,-1,0,64)'
.rdata$r:00004AD8                 dd offset ??_R1A@?0A@EA@_Generic_error_category@std@@8 ; std::_Generic_error_category::`RTTI Base Class Descriptor at (0,-1,0,64)'
.rdata$r:00004ADC                 dd offset ??_R1A@?0A@EA@error_category@std@@8 ; std::error_category::`RTTI Base Class Descriptor at (0,-1,0,64)'
.rdata$r:00004AE0                 db    0
.rdata$r:00004AE1                 align 4
.rdata$r:00004AE1 _rdata$r        ends
.rdata$r:00004AE1
.rdata$r:00004AE4 ; ===========================================================================
.rdata$r:00004AE4
.rdata$r:00004AE4 ; Segment type: Pure data
.rdata$r:00004AE4 ; Segment permissions: Read
.rdata$r:00004AE4 _rdata$r        segment dword public 'DATA' use32
.rdata$r:00004AE4                 assume cs:_rdata$r
.rdata$r:00004AE4                 ;org 4AE4h
.rdata$r:00004AE4 ; COMDAT (pick any)
.rdata$r:00004AE4                 public ??_R1A@?0A@EA@_Iostream_error_category@std@@8
.rdata$r:00004AE4 ; std::_Iostream_error_category::`RTTI Base Class Descriptor at (0, -1, 0, 64)'
.rdata$r:00004AE4 ??_R1A@?0A@EA@_Iostream_error_category@std@@8 dd offset ??_R0?AV_Iostream_error_category@std@@@8
.rdata$r:00004AE4                                         ; DATA XREF: .rdata$r:std::_Iostream_error_category::`RTTI Base Class Array'o
.rdata$r:00004AE4                                         ; std::_Iostream_error_category `RTTI Type Descriptor'
.rdata$r:00004AE8                 db    2
.rdata$r:00004AE9                 db    0
.rdata$r:00004AEA                 db    0
.rdata$r:00004AEB                 db    0
.rdata$r:00004AEC                 db    0
.rdata$r:00004AED                 db    0
.rdata$r:00004AEE                 db    0
.rdata$r:00004AEF                 db    0
.rdata$r:00004AF0                 db 0FFh
.rdata$r:00004AF1                 db 0FFh
.rdata$r:00004AF2                 db 0FFh
.rdata$r:00004AF3                 db 0FFh
.rdata$r:00004AF4                 db    0
.rdata$r:00004AF5                 db    0
.rdata$r:00004AF6                 db    0
.rdata$r:00004AF7                 db    0
.rdata$r:00004AF8                 db  40h ; @
.rdata$r:00004AF9                 db    0
.rdata$r:00004AFA                 db    0
.rdata$r:00004AFB                 db    0
.rdata$r:00004AFC                 dd offset ??_R3_Iostream_error_category@std@@8 ; std::_Iostream_error_category::`RTTI Class Hierarchy Descriptor'
.rdata$r:00004AFC _rdata$r        ends
.rdata$r:00004AFC
.rdata$r:00004B00 ; ===========================================================================
.rdata$r:00004B00
.rdata$r:00004B00 ; Segment type: Pure data
.rdata$r:00004B00 ; Segment permissions: Read
.rdata$r:00004B00 _rdata$r        segment dword public 'DATA' use32
.rdata$r:00004B00                 assume cs:_rdata$r
.rdata$r:00004B00                 ;org 4B00h
.rdata$r:00004B00 ; COMDAT (pick any)
.rdata$r:00004B00                 public ??_R4_System_error_category@std@@6B@
.rdata$r:00004B00 ; const std::_System_error_category::`RTTI Complete Object Locator'
.rdata$r:00004B00 ??_R4_System_error_category@std@@6B@ db    0 ; DATA XREF: .rdata:0000487Co
.rdata$r:00004B01                 db    0
.rdata$r:00004B02                 db    0
.rdata$r:00004B03                 db    0
.rdata$r:00004B04                 db    0
.rdata$r:00004B05                 db    0
.rdata$r:00004B06                 db    0
.rdata$r:00004B07                 db    0
.rdata$r:00004B08                 db    0
.rdata$r:00004B09                 db    0
.rdata$r:00004B0A                 db    0
.rdata$r:00004B0B                 db    0
.rdata$r:00004B0C                 dd offset ??_R0?AV_System_error_category@std@@@8 ; std::_System_error_category `RTTI Type Descriptor'
.rdata$r:00004B10                 dd offset ??_R3_System_error_category@std@@8 ; std::_System_error_category::`RTTI Class Hierarchy Descriptor'
.rdata$r:00004B10 _rdata$r        ends
.rdata$r:00004B10
.data$r:00004B14 ; ===========================================================================
.data$r:00004B14
.data$r:00004B14 ; Segment type: Pure data
.data$r:00004B14 ; Segment permissions: Read/Write
.data$r:00004B14 _data$r         segment dword public 'DATA' use32
.data$r:00004B14                 assume cs:_data$r
.data$r:00004B14                 ;org 4B14h
.data$r:00004B14 ; COMDAT (pick any)
.data$r:00004B14                 public ??_R0?AV_System_error_category@std@@@8
.data$r:00004B14 ; class std::_System_error_category `RTTI Type Descriptor'
.data$r:00004B14 ??_R0?AV_System_error_category@std@@@8 dd offset ??_7type_info@@6B@
.data$r:00004B14                                         ; DATA XREF: .rdata$r:00004B0Co
.data$r:00004B14                                         ; .rdata$r:std::_System_error_category::`RTTI Base Class Descriptor at (0,-1,0,64)'o
.data$r:00004B14                                         ; const type_info::`vftable'
.data$r:00004B18                 db    0
.data$r:00004B19                 db    0
.data$r:00004B1A                 db    0
.data$r:00004B1B                 db    0
.data$r:00004B1C                 db  2Eh ; .
.data$r:00004B1D                 db  3Fh ; ?
.data$r:00004B1E                 db  41h ; A
.data$r:00004B1F                 db  56h ; V
.data$r:00004B20                 db  5Fh ; _
.data$r:00004B21                 db  53h ; S
.data$r:00004B22                 db  79h ; y
.data$r:00004B23                 db  73h ; s
.data$r:00004B24                 db  74h ; t
.data$r:00004B25                 db  65h ; e
.data$r:00004B26                 db  6Dh ; m
.data$r:00004B27                 db  5Fh ; _
.data$r:00004B28                 db  65h ; e
.data$r:00004B29                 db  72h ; r
.data$r:00004B2A                 db  72h ; r
.data$r:00004B2B                 db  6Fh ; o
.data$r:00004B2C                 db  72h ; r
.data$r:00004B2D                 db  5Fh ; _
.data$r:00004B2E                 db  63h ; c
.data$r:00004B2F                 db  61h ; a
.data$r:00004B30                 db  74h ; t
.data$r:00004B31                 db  65h ; e
.data$r:00004B32                 db  67h ; g
.data$r:00004B33                 db  6Fh ; o
.data$r:00004B34                 db  72h ; r
.data$r:00004B35                 db  79h ; y
.data$r:00004B36                 db  40h ; @
.data$r:00004B37                 db  73h ; s
.data$r:00004B38                 db  74h ; t
.data$r:00004B39                 db  64h ; d
.data$r:00004B3A                 db  40h ; @
.data$r:00004B3B                 db  40h ; @
.data$r:00004B3C                 db    0
.data$r:00004B3D                 align 10h
.data$r:00004B3D _data$r         ends
.data$r:00004B3D
.rdata$r:00004B40 ; ===========================================================================
.rdata$r:00004B40
.rdata$r:00004B40 ; Segment type: Pure data
.rdata$r:00004B40 ; Segment permissions: Read
.rdata$r:00004B40 _rdata$r        segment dword public 'DATA' use32
.rdata$r:00004B40                 assume cs:_rdata$r
.rdata$r:00004B40                 ;org 4B40h
.rdata$r:00004B40 ; COMDAT (pick any)
.rdata$r:00004B40                 public ??_R3_System_error_category@std@@8
.rdata$r:00004B40 ; std::_System_error_category::`RTTI Class Hierarchy Descriptor'
.rdata$r:00004B40 ??_R3_System_error_category@std@@8 db    0 ; DATA XREF: .rdata$r:00004B10o
.rdata$r:00004B40                                         ; .rdata$r:00004B78o
.rdata$r:00004B41                 db    0
.rdata$r:00004B42                 db    0
.rdata$r:00004B43                 db    0
.rdata$r:00004B44                 db    0
.rdata$r:00004B45                 db    0
.rdata$r:00004B46                 db    0
.rdata$r:00004B47                 db    0
.rdata$r:00004B48                 db    3
.rdata$r:00004B49                 db    0
.rdata$r:00004B4A                 db    0
.rdata$r:00004B4B                 db    0
.rdata$r:00004B4C                 dd offset ??_R2_System_error_category@std@@8 ; std::_System_error_category::`RTTI Base Class Array'
.rdata$r:00004B4C _rdata$r        ends
.rdata$r:00004B4C
.rdata$r:00004B50 ; ===========================================================================
.rdata$r:00004B50
.rdata$r:00004B50 ; Segment type: Pure data
.rdata$r:00004B50 ; Segment permissions: Read
.rdata$r:00004B50 _rdata$r        segment dword public 'DATA' use32
.rdata$r:00004B50                 assume cs:_rdata$r
.rdata$r:00004B50                 ;org 4B50h
.rdata$r:00004B50 ; COMDAT (pick any)
.rdata$r:00004B50                 public ??_R2_System_error_category@std@@8
.rdata$r:00004B50 ; std::_System_error_category::`RTTI Base Class Array'
.rdata$r:00004B50 ??_R2_System_error_category@std@@8 dd offset ??_R1A@?0A@EA@_System_error_category@std@@8
.rdata$r:00004B50                                         ; DATA XREF: .rdata$r:00004B4Co
.rdata$r:00004B50                                         ; std::_System_error_category::`RTTI Base Class Descriptor at (0,-1,0,64)'
.rdata$r:00004B54                 dd offset ??_R1A@?0A@EA@_Generic_error_category@std@@8 ; std::_Generic_error_category::`RTTI Base Class Descriptor at (0,-1,0,64)'
.rdata$r:00004B58                 dd offset ??_R1A@?0A@EA@error_category@std@@8 ; std::error_category::`RTTI Base Class Descriptor at (0,-1,0,64)'
.rdata$r:00004B5C                 db    0
.rdata$r:00004B5D                 align 10h
.rdata$r:00004B5D _rdata$r        ends
.rdata$r:00004B5D
.rdata$r:00004B60 ; ===========================================================================
.rdata$r:00004B60
.rdata$r:00004B60 ; Segment type: Pure data
.rdata$r:00004B60 ; Segment permissions: Read
.rdata$r:00004B60 _rdata$r        segment dword public 'DATA' use32
.rdata$r:00004B60                 assume cs:_rdata$r
.rdata$r:00004B60                 ;org 4B60h
.rdata$r:00004B60 ; COMDAT (pick any)
.rdata$r:00004B60                 public ??_R1A@?0A@EA@_System_error_category@std@@8
.rdata$r:00004B60 ; std::_System_error_category::`RTTI Base Class Descriptor at (0, -1, 0, 64)'
.rdata$r:00004B60 ??_R1A@?0A@EA@_System_error_category@std@@8 dd offset ??_R0?AV_System_error_category@std@@@8
.rdata$r:00004B60                                         ; DATA XREF: .rdata$r:std::_System_error_category::`RTTI Base Class Array'o
.rdata$r:00004B60                                         ; std::_System_error_category `RTTI Type Descriptor'
.rdata$r:00004B64                 db    2
.rdata$r:00004B65                 db    0
.rdata$r:00004B66                 db    0
.rdata$r:00004B67                 db    0
.rdata$r:00004B68                 db    0
.rdata$r:00004B69                 db    0
.rdata$r:00004B6A                 db    0
.rdata$r:00004B6B                 db    0
.rdata$r:00004B6C                 db 0FFh
.rdata$r:00004B6D                 db 0FFh
.rdata$r:00004B6E                 db 0FFh
.rdata$r:00004B6F                 db 0FFh
.rdata$r:00004B70                 db    0
.rdata$r:00004B71                 db    0
.rdata$r:00004B72                 db    0
.rdata$r:00004B73                 db    0
.rdata$r:00004B74                 db  40h ; @
.rdata$r:00004B75                 db    0
.rdata$r:00004B76                 db    0
.rdata$r:00004B77                 db    0
.rdata$r:00004B78                 dd offset ??_R3_System_error_category@std@@8 ; std::_System_error_category::`RTTI Class Hierarchy Descriptor'
.rdata$r:00004B78 _rdata$r        ends
.rdata$r:00004B78
.CRT$XCU:00004B7C ; ===========================================================================
.CRT$XCU:00004B7C
.CRT$XCU:00004B7C ; Segment type: Pure data
.CRT$XCU:00004B7C ; Segment permissions: Read
.CRT$XCU:00004B7C _CRT$XCU        segment dword public 'DATA' use32
.CRT$XCU:00004B7C                 assume cs:_CRT$XCU
.CRT$XCU:00004B7C                 ;org 4B7Ch
.CRT$XCU:00004B7C _piecewise_construct$initializer$ dd offset ??__Epiecewise_construct@std@@YAXXZ ; std::`dynamic initializer for 'piecewise_construct''(void)
.CRT$XCU:00004B80 _allocator_arg$initializer$ dd offset ??__Eallocator_arg@std@@YAXXZ ; std::`dynamic initializer for 'allocator_arg''(void)
.CRT$XCU:00004B84 _ignore$initializer$ dd offset ??__Eignore@std@@YAXXZ ; std::`dynamic initializer for 'ignore''(void)
.CRT$XCU:00004B88 __Tuple_alloc$initializer$ dd offset ??__E_Tuple_alloc@std@@YAXXZ ; std::`dynamic initializer for '_Tuple_alloc''(void)
.CRT$XCU:00004B88 _CRT$XCU        ends
.CRT$XCU:00004B88
.CRT$XCU:00004B8C ; ===========================================================================
.CRT$XCU:00004B8C
.CRT$XCU:00004B8C ; Segment type: Pure data
.CRT$XCU:00004B8C ; Segment permissions: Read
.CRT$XCU:00004B8C _CRT$XCU        segment dword public 'DATA' use32
.CRT$XCU:00004B8C                 assume cs:_CRT$XCU
.CRT$XCU:00004B8C                 ;org 4B8Ch
.CRT$XCU:00004B8C ; COMDAT (pick associative to section at 48A0)
.CRT$XCU:00004B8C ; public: static void (__cdecl *std::_Error_objects<int>::_Generic_object$initializer$)(void)
.CRT$XCU:00004B8C ?_Generic_object$initializer$@?$_Error_objects@H@std@@2P6AXXZA dd offset ??__E?_Generic_object@?$_Error_objects@H@std@@2V_Generic_error_category@2@A@@YAXXZ ; `dynamic initializer for 'std::_Generic_error_category std::_Error_objects<int>::_Generic_object''(void)
.CRT$XCU:00004B8C _CRT$XCU        ends
.CRT$XCU:00004B8C
.CRT$XCU:00004B90 ; ===========================================================================
.CRT$XCU:00004B90
.CRT$XCU:00004B90 ; Segment type: Pure data
.CRT$XCU:00004B90 ; Segment permissions: Read
.CRT$XCU:00004B90 _CRT$XCU        segment dword public 'DATA' use32
.CRT$XCU:00004B90                 assume cs:_CRT$XCU
.CRT$XCU:00004B90                 ;org 4B90h
.CRT$XCU:00004B90 ; COMDAT (pick associative to section at 48A4)
.CRT$XCU:00004B90 ; public: static void (__cdecl *std::_Error_objects<int>::_Iostream_object$initializer$)(void)
.CRT$XCU:00004B90 ?_Iostream_object$initializer$@?$_Error_objects@H@std@@2P6AXXZA dd offset ??__E?_Iostream_object@?$_Error_objects@H@std@@2V_Iostream_error_category@2@A@@YAXXZ ; `dynamic initializer for 'std::_Iostream_error_category std::_Error_objects<int>::_Iostream_object''(void)
.CRT$XCU:00004B90 _CRT$XCU        ends
.CRT$XCU:00004B90
.CRT$XCU:00004B94 ; ===========================================================================
.CRT$XCU:00004B94
.CRT$XCU:00004B94 ; Segment type: Pure data
.CRT$XCU:00004B94 ; Segment permissions: Read
.CRT$XCU:00004B94 _CRT$XCU        segment dword public 'DATA' use32
.CRT$XCU:00004B94                 assume cs:_CRT$XCU
.CRT$XCU:00004B94                 ;org 4B94h
.CRT$XCU:00004B94 ; COMDAT (pick associative to section at 48A8)
.CRT$XCU:00004B94 ; public: static void (__cdecl *std::_Error_objects<int>::_System_object$initializer$)(void)
.CRT$XCU:00004B94 ?_System_object$initializer$@?$_Error_objects@H@std@@2P6AXXZA dd offset ??__E?_System_object@?$_Error_objects@H@std@@2V_System_error_category@2@A@@YAXXZ ; `dynamic initializer for 'std::_System_error_category std::_Error_objects<int>::_System_object''(void)
.CRT$XCU:00004B94 _CRT$XCU        ends
.CRT$XCU:00004B94
.CRT$XCU:00004B98 ; ===========================================================================
.CRT$XCU:00004B98
.CRT$XCU:00004B98 ; Segment type: Pure data
.CRT$XCU:00004B98 ; Segment permissions: Read
.CRT$XCU:00004B98 _CRT$XCU        segment dword public 'DATA' use32
.CRT$XCU:00004B98                 assume cs:_CRT$XCU
.CRT$XCU:00004B98                 ;org 4B98h
.CRT$XCU:00004B98 ; COMDAT (pick associative to section at 48AC)
.CRT$XCU:00004B98 ; public: static void (__cdecl *std::num_put<char, class std::back_insert_iterator<class std::basic_string<char, struct std::char_traits<char>, class std::allocator<char>>>>::id$initializer$)(void)
.CRT$XCU:00004B98 ?id$initializer$@?$num_put@DV?$back_insert_iterator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@std@@2P6AXXZA dd offset ??__E?id@?$num_put@DV?$back_insert_iterator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@std@@2V0locale@2@A@@YAXXZ ; `dynamic initializer for 'std::locale::id std::num_put<char,std::back_insert_iterator<std::basic_string<char,std::char_traits<char>,std::allocator<char>>>>::id''(void)
.CRT$XCU:00004B98 _CRT$XCU        ends
.CRT$XCU:00004B98
.CRT$XCU:00004B9C ; ===========================================================================
.CRT$XCU:00004B9C
.CRT$XCU:00004B9C ; Segment type: Pure data
.CRT$XCU:00004B9C ; Segment permissions: Read
.CRT$XCU:00004B9C _CRT$XCU        segment dword public 'DATA' use32
.CRT$XCU:00004B9C                 assume cs:_CRT$XCU
.CRT$XCU:00004B9C                 ;org 4B9Ch
.CRT$XCU:00004B9C ; COMDAT (pick associative to section at 48B0)
.CRT$XCU:00004B9C ; public: static void (__cdecl *std::num_put<wchar_t, class std::back_insert_iterator<class std::basic_string<wchar_t, struct std::char_traits<wchar_t>, class std::allocator<wchar_t>>>>::id$initializer$)(void)
.CRT$XCU:00004B9C ?id$initializer$@?$num_put@_WV?$back_insert_iterator@V?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@@std@@@std@@2P6AXXZA dd offset ??__E?id@?$num_put@_WV?$back_insert_iterator@V?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@@std@@@std@@2V0locale@2@A@@YAXXZ ; `dynamic initializer for 'std::locale::id std::num_put<wchar_t,std::back_insert_iterator<std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>>>>::id''(void)
.CRT$XCU:00004B9C _CRT$XCU        ends
.CRT$XCU:00004B9C
.CRT$XCU:00004BA0 ; ===========================================================================
.CRT$XCU:00004BA0
.CRT$XCU:00004BA0 ; Segment type: Pure data
.CRT$XCU:00004BA0 ; Segment permissions: Read
.CRT$XCU:00004BA0 _CRT$XCU        segment dword public 'DATA' use32
.CRT$XCU:00004BA0                 assume cs:_CRT$XCU
.CRT$XCU:00004BA0                 ;org 4BA0h
.CRT$XCU:00004BA0 ; COMDAT (pick associative to section at 4944)
.CRT$XCU:00004BA0 ; public: static void (__cdecl *std::numpunct<char>::id$initializer$)(void)
.CRT$XCU:00004BA0 ?id$initializer$@?$numpunct@D@std@@2P6AXXZA dd offset ??__E?id@?$numpunct@D@std@@2V0locale@2@A@@YAXXZ ; `dynamic initializer for 'std::locale::id std::numpunct<char>::id''(void)
.CRT$XCU:00004BA0 _CRT$XCU        ends
.CRT$XCU:00004BA0
.CRT$XCU:00004BA4 ; ===========================================================================
.CRT$XCU:00004BA4
.CRT$XCU:00004BA4 ; Segment type: Pure data
.CRT$XCU:00004BA4 ; Segment permissions: Read
.CRT$XCU:00004BA4 _CRT$XCU        segment dword public 'DATA' use32
.CRT$XCU:00004BA4                 assume cs:_CRT$XCU
.CRT$XCU:00004BA4                 ;org 4BA4h
.CRT$XCU:00004BA4 ; COMDAT (pick associative to section at 4948)
.CRT$XCU:00004BA4 ; public: static void (__cdecl *std::numpunct<wchar_t>::id$initializer$)(void)
.CRT$XCU:00004BA4 ?id$initializer$@?$numpunct@_W@std@@2P6AXXZA dd offset ??__E?id@?$numpunct@_W@std@@2V0locale@2@A@@YAXXZ ; `dynamic initializer for 'std::locale::id std::numpunct<wchar_t>::id''(void)
.CRT$XCU:00004BA4 _CRT$XCU        ends
.CRT$XCU:00004BA4
UNDEF:00004BB0 ; ===========================================================================
UNDEF:00004BB0
UNDEF:00004BB0 ; Segment type: Externs
UNDEF:00004BB0 ; UNDEF
UNDEF:00004BB0                 extrn __purecall:near   ; DATA XREF: .rdata:000047F4o
UNDEF:00004BB0                                         ; .rdata:000047F8o
UNDEF:00004BB4 ; void *__cdecl operator new(unsigned int)
UNDEF:00004BB4                 extrn ??2@YAPAXI@Z:near ; CODE XREF: std::_Allocate<char>(uint,char *)+1Dp
UNDEF:00004BB4                                         ; std::_Allocate<std::_Container_proxy>(uint,std::_Container_proxy *)+23p
UNDEF:00004BB8 ; void __cdecl operator delete(void *)
UNDEF:00004BB8                 extrn ??3@YAXPAX@Z:near ; CODE XREF: std::_Generic_error_category::`scalar deleting destructor'(uint)+1Bp
UNDEF:00004BB8                                         ; std::_Iostream_error_category::`scalar deleting destructor'(uint)+1Bp ...
UNDEF:00004BBC ; int __cdecl atexit(void (__cdecl *)())
UNDEF:00004BBC                 extrn _atexit:near      ; CODE XREF: `dynamic initializer for 'std::_Generic_error_category std::_Error_objects<int>::_Generic_object''(void)+12p
UNDEF:00004BBC                                         ; `dynamic initializer for 'std::_Iostream_error_category std::_Error_objects<int>::_Iostream_object''(void)+12p ...
UNDEF:00004BC0 ; void *__cdecl memcpy(void *Dst, const void *Src, size_t Size)
UNDEF:00004BC0                 extrn _memcpy:near      ; CODE XREF: std::char_traits<char>::copy(char *,char const *,uint)+1Ep
UNDEF:00004BC4 ; size_t __cdecl strlen(const char *Str)
UNDEF:00004BC4                 extrn _strlen:near      ; CODE XREF: std::char_traits<char>::length(char const *)+1Bp
UNDEF:00004BC8 ; void *__cdecl memmove(void *Dst, const void *Src, size_t Size)
UNDEF:00004BC8                 extrn _memmove:near     ; CODE XREF: std::char_traits<char>::move(char *,char const *,uint)+1Ep
UNDEF:00004BCC ; HMODULE __stdcall GetModuleHandleW(LPCWSTR lpModuleName)
UNDEF:00004BCC                 extrn __imp__GetModuleHandleW@4:near
UNDEF:00004BCC                                         ; CODE XREF: DocumentMap::run_dlgProc(uint,uint,long)+118p
UNDEF:00004BCC                                         ; DATA XREF: DocumentMap::run_dlgProc(uint,uint,long)+118r
UNDEF:00004BD0 ; HBRUSH __stdcall CreateSolidBrush(COLORREF color)
UNDEF:00004BD0                 extrn __imp__CreateSolidBrush@4:near
UNDEF:00004BD0                                         ; CODE XREF: ViewZoneDlg::drawPreviewZone(tagDRAWITEMSTRUCT *)+43p
UNDEF:00004BD0                                         ; ViewZoneDlg::drawPreviewZone(tagDRAWITEMSTRUCT *)+51p
UNDEF:00004BD0                                         ; DATA XREF: ...
UNDEF:00004BD4 ; BOOL __stdcall DeleteObject(HGDIOBJ ho)
UNDEF:00004BD4                 extrn __imp__DeleteObject@4:near
UNDEF:00004BD4                                         ; CODE XREF: ViewZoneDlg::drawPreviewZone(tagDRAWITEMSTRUCT *)+9Ap
UNDEF:00004BD4                                         ; ViewZoneDlg::drawPreviewZone(tagDRAWITEMSTRUCT *)+A4p
UNDEF:00004BD4                                         ; DATA XREF: ...
UNDEF:00004BD8 ; LRESULT __stdcall SendMessageW(HWND hWnd, UINT Msg, WPARAM wParam, LPARAM lParam)
UNDEF:00004BD8                 extrn __imp__SendMessageW@16:near
UNDEF:00004BD8                                         ; CODE XREF: ViewZoneDlg::run_dlgProc(uint,uint,long)+DAp
UNDEF:00004BD8                                         ; ViewZoneDlg::run_dlgProc(uint,uint,long)+101p ...
UNDEF:00004BDC ; BOOL __stdcall MoveWindow(HWND hWnd, int X, int Y, int nWidth, int nHeight, BOOL bRepaint)
UNDEF:00004BDC                 extrn __imp__MoveWindow@24:near
UNDEF:00004BDC                                         ; CODE XREF: ViewZoneDlg::run_dlgProc(uint,uint,long)+15Ep
UNDEF:00004BDC                                         ; DocumentMap::wrapMap(void)+B7p ...
UNDEF:00004BE0 ; HWND __stdcall GetDlgItem(HWND hDlg, int nIDDlgItem)
UNDEF:00004BE0                 extrn __imp__GetDlgItem@8:near
UNDEF:00004BE0                                         ; CODE XREF: ViewZoneDlg::run_dlgProc(uint,uint,long)+75p
UNDEF:00004BE0                                         ; DATA XREF: ViewZoneDlg::run_dlgProc(uint,uint,long)+75r
UNDEF:00004BE4 ; BOOL __stdcall InvalidateRect(HWND hWnd, const RECT *lpRect, BOOL bErase)
UNDEF:00004BE4                 extrn __imp__InvalidateRect@12:near
UNDEF:00004BE4                                         ; CODE XREF: ViewZoneDlg::drawZone(long,long)+2Dp
UNDEF:00004BE4                                         ; DATA XREF: ViewZoneDlg::drawZone(long,long)+2Dr
UNDEF:00004BE8 ; BOOL __stdcall ClientToScreen(HWND hWnd, LPPOINT lpPoint)
UNDEF:00004BE8                 extrn __imp__ClientToScreen@8:near
UNDEF:00004BE8                                         ; CODE XREF: DocumentMap::doMove(void)+2Cp
UNDEF:00004BE8                                         ; DocumentMap::run_dlgProc(uint,uint,long)+201p ...
UNDEF:00004BEC ; int __stdcall FillRect(HDC hDC, const RECT *lprc, HBRUSH hbr)
UNDEF:00004BEC                 extrn __imp__FillRect@12:near
UNDEF:00004BEC                                         ; CODE XREF: ViewZoneDlg::drawPreviewZone(tagDRAWITEMSTRUCT *)+69p
UNDEF:00004BEC                                         ; ViewZoneDlg::drawPreviewZone(tagDRAWITEMSTRUCT *)+90p
UNDEF:00004BEC                                         ; DATA XREF: ...
UNDEF:00004BF0 ; LONG __stdcall GetWindowLongW(HWND hWnd, int nIndex)
UNDEF:00004BF0                 extrn __imp__GetWindowLongW@8:near
UNDEF:00004BF0                                         ; CODE XREF: ViewZoneDlg::canvasStaticProc(HWND__ *,uint,uint,long)+Ap
UNDEF:00004BF0                                         ; NppParameters::SetTransparent(HWND__ *,int)+1Bp
UNDEF:00004BF0                                         ; DATA XREF: ...
UNDEF:00004BF4 ; LONG __stdcall SetWindowLongW(HWND hWnd, int nIndex, LONG dwNewLong)
UNDEF:00004BF4                 extrn __imp__SetWindowLongW@12:near
UNDEF:00004BF4                                         ; CODE XREF: ViewZoneDlg::run_dlgProc(uint,uint,long)+97p
UNDEF:00004BF4                                         ; ViewZoneDlg::run_dlgProc(uint,uint,long)+ABp ...
UNDEF:00004BF8 ; _DWORD __thiscall std::_Lockit::_Lockit(std::_Lockit *__hidden this, int)
UNDEF:00004BF8                 extrn ??0_Lockit@std@@QAE@H@Z:near
UNDEF:00004BF8                                         ; CODE XREF: std::_Container_base12::_Orphan_all(void)+35p
UNDEF:00004BFC ; _DWORD __thiscall std::_Lockit::~_Lockit(std::_Lockit *__hidden this)
UNDEF:00004BFC                 extrn ??1_Lockit@std@@QAE@XZ:near
UNDEF:00004BFC                                         ; CODE XREF: std::_Container_base12::_Orphan_all(void)+86p
UNDEF:00004BFC                                         ; __unwindfunclet$?_Orphan_all@_Container_base12@std@@QAEXXZ$0+3j
UNDEF:00004C00                 extrn __hypot:near      ; CODE XREF: _hypot+1Dp
UNDEF:00004C04 ; void __cdecl std::_Debug_message(const wchar_t *, const wchar_t *, unsigned int)
UNDEF:00004C04                 extrn ?_Debug_message@std@@YAXPB_W0I@Z:near
UNDEF:00004C04                                         ; CODE XREF: std::_Debug_pointer<char>(char const *,wchar_t const *,uint)+16p
UNDEF:00004C08 ; void __cdecl std::_Xbad_alloc()
UNDEF:00004C08                 extrn ?_Xbad_alloc@std@@YAXXZ:near
UNDEF:00004C08                                         ; CODE XREF: std::_Allocate<char>(uint,char *):loc_20D2p
UNDEF:00004C08                                         ; std::_Allocate<std::_Container_proxy>(uint,std::_Container_proxy *):loc_2114p
UNDEF:00004C0C ; void __cdecl std::_Xlength_error(const char *)
UNDEF:00004C0C                 extrn ?_Xlength_error@std@@YAXPBD@Z:near
UNDEF:00004C0C                                         ; CODE XREF: std::basic_string<char,std::char_traits<char>,std::allocator<char>>::_Xlen(void)+Cp
UNDEF:00004C10 ; void __cdecl std::_Xout_of_range(const char *)
UNDEF:00004C10                 extrn ?_Xout_of_range@std@@YAXPBD@Z:near
UNDEF:00004C10                                         ; CODE XREF: std::basic_string<char,std::char_traits<char>,std::allocator<char>>::_Xran(void)+Cp
UNDEF:00004C14 ; public: virtual void * __thiscall std::error_category::`vector deleting destructor'(unsigned int)
UNDEF:00004C14                 extrn ??_Eerror_category@std@@UAEPAXI@Z:near ; weak
UNDEF:00004C14                                         ; DATA XREF: .rdata:const std::error_category::`vftable'o
UNDEF:00004C18 ; const char *__cdecl std::_Syserror_map(int)
UNDEF:00004C18                 extrn ?_Syserror_map@std@@YAPBDH@Z:near
UNDEF:00004C18                                         ; CODE XREF: std::_System_error_category::default_error_condition(int)+Bp
UNDEF:00004C18                                         ; std::_Generic_error_category::message(int)+33p
UNDEF:00004C1C ; const char *__cdecl std::_Winerror_map(int)
UNDEF:00004C1C                 extrn ?_Winerror_map@std@@YAPBDH@Z:near
UNDEF:00004C1C                                         ; CODE XREF: std::_System_error_category::message(int)+33p
UNDEF:00004C20 ; public: virtual void * __thiscall std::_Generic_error_category::`vector deleting destructor'(unsigned int)
UNDEF:00004C20                 extrn ??_E_Generic_error_category@std@@UAEPAXI@Z:near ; weak
UNDEF:00004C20                                         ; DATA XREF: .rdata:const std::_Generic_error_category::`vftable'o
UNDEF:00004C24 ; public: virtual void * __thiscall std::_Iostream_error_category::`vector deleting destructor'(unsigned int)
UNDEF:00004C24                 extrn ??_E_Iostream_error_category@std@@UAEPAXI@Z:near ; weak
UNDEF:00004C24                                         ; DATA XREF: .rdata:const std::_Iostream_error_category::`vftable'o
UNDEF:00004C28 ; public: virtual void * __thiscall std::_System_error_category::`vector deleting destructor'(unsigned int)
UNDEF:00004C28                 extrn ??_E_System_error_category@std@@UAEPAXI@Z:near ; weak
UNDEF:00004C28                                         ; DATA XREF: .rdata:const std::_System_error_category::`vftable'o
UNDEF:00004C2C ; public: void __thiscall ScintillaEditView::getCurrentFoldStates(class std::vector<unsigned int, class std::allocator<unsigned int>> &)
UNDEF:00004C2C                 extrn ?getCurrentFoldStates@ScintillaEditView@@QAEXAAV?$vector@IV?$allocator@I@std@@@std@@@Z:near
UNDEF:00004C2C                                         ; CODE XREF: DocumentMap::reloadMap(void)+ABp
UNDEF:00004C30 ; public: void __thiscall ScintillaEditView::syncFoldStateWith(class std::vector<unsigned int, class std::allocator<unsigned int>> const &)
UNDEF:00004C30                 extrn ?syncFoldStateWith@ScintillaEditView@@QAEXABV?$vector@IV?$allocator@I@std@@@std@@@Z:near
UNDEF:00004C30                                         ; CODE XREF: DocumentMap::reloadMap(void)+BAp
UNDEF:00004C34 ; void __thiscall ScintillaEditView::updateLineNumberWidth(ScintillaEditView *__hidden this)
UNDEF:00004C34                 extrn ?updateLineNumberWidth@ScintillaEditView@@QAEXXZ:near
UNDEF:00004C34                                         ; CODE XREF: ScintillaEditView::showLineNumbersMargin(bool)+2Cp
UNDEF:00004C38 ; void __thiscall ScintillaEditView::foldAll(ScintillaEditView *__hidden this, bool)
UNDEF:00004C38                 extrn ?foldAll@ScintillaEditView@@QAEX_N@Z:near
UNDEF:00004C38                                         ; CODE XREF: DocumentMap::foldAll(bool)+12p
UNDEF:00004C3C ; void __thiscall ScintillaEditView::fold(ScintillaEditView *__hidden this, int, bool)
UNDEF:00004C3C                 extrn ?fold@ScintillaEditView@@QAEXH_N@Z:near
UNDEF:00004C3C                                         ; CODE XREF: DocumentMap::fold(int,bool)+16p
UNDEF:00004C40 ; void __thiscall __high ScintillaEditView::defineDocType(enum LangType)
UNDEF:00004C40                 extrn ?defineDocType@ScintillaEditView@@QAEXW4LangType@@@Z:near
UNDEF:00004C40                                         ; CODE XREF: DocumentMap::setSyntaxHiliting(void)+26p
UNDEF:00004C44 ; void __thiscall ScintillaEditView::changeTextDirection(ScintillaEditView *__hidden this, bool)
UNDEF:00004C44                 extrn ?changeTextDirection@ScintillaEditView@@QAEX_N@Z:near
UNDEF:00004C44                                         ; CODE XREF: DocumentMap::initWrapMap(void)+B7p
UNDEF:00004C44                                         ; DocumentMap::changeTextDirection(bool)+12p
UNDEF:00004C48 ; bool __thiscall ScintillaEditView::isTextDirectionRTL(ScintillaEditView *__hidden this)
UNDEF:00004C48                 extrn ?isTextDirectionRTL@ScintillaEditView@@QBE_NXZ:near
UNDEF:00004C48                                         ; CODE XREF: DocumentMap::initWrapMap(void)+8Ep
UNDEF:00004C48                                         ; DocumentMap::initWrapMap(void)+9Cp
UNDEF:00004C4C ; __int32 __thiscall ScintillaEditView::scintillaNew_Proc(ScintillaEditView *__hidden this, HWND, unsigned int, unsigned int, __int32)
UNDEF:00004C4C                 extrn ?scintillaNew_Proc@ScintillaEditView@@IAEJPAUHWND__@@IIJ@Z:near
UNDEF:00004C4C                                         ; CODE XREF: ScintillaEditView::mouseWheel(uint,long)+1Ep
UNDEF:00004C50 ; __fastcall __security_check_cookie(x)
UNDEF:00004C50                 extrn @__security_check_cookie@4:near
UNDEF:00004C50                                         ; CODE XREF: ViewZoneDlg::drawPreviewZone(tagDRAWITEMSTRUCT *)+AFp
UNDEF:00004C50                                         ; DocumentMap::wrapMap(void)+F8p ...
UNDEF:00004C54 ; __stdcall _CxxThrowException(x, x)
UNDEF:00004C54                 extrn __CxxThrowException@8:near
UNDEF:00004C54                                         ; CODE XREF: __catch$?_Copy@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEXII@Z$1+10p
UNDEF:00004C58                 extrn ___CxxFrameHandler3:near
UNDEF:00004C58                                         ; CODE XREF: __ehhandler$?reloadMap@DocumentMap@@QAEXXZ+16j
UNDEF:00004C58                                         ; __ehhandler$??$construct@PADAAPAD@?$allocator@D@std@@QAEXPAPADAAPAD@Z+16j ...
UNDEF:00004C5C ; const type_info::`vftable'
UNDEF:00004C5C                 extrn ??_7type_info@@6B@:near
UNDEF:00004C5C                                         ; DATA XREF: .data$r:std::error_category `RTTI Type Descriptor'o
UNDEF:00004C5C                                         ; .data$r:std::_Generic_error_category `RTTI Type Descriptor'o ...
UNDEF:00004C60 ; private: static class NppParameters * NppParameters::_pSelf
UNDEF:00004C60                 extrn ?_pSelf@NppParameters@@0PAV1@A:near
UNDEF:00004C60                                         ; DATA XREF: NppParameters::getInstance(void)+3r
UNDEF:00004C64 ; unsigned int ScintillaEditView::_SC_MARGE_LINENUMBER
UNDEF:00004C64                 extrn ?_SC_MARGE_LINENUMBER@ScintillaEditView@@2HB:near
UNDEF:00004C64                                         ; DATA XREF: ScintillaEditView::showLineNumbersMargin(bool)+35r
UNDEF:00004C64                                         ; ScintillaEditView::showMargin(int,bool)+Cr
UNDEF:00004C68 ; public: static int const ScintillaEditView::_SC_MARGE_SYBOLE
UNDEF:00004C68                 extrn ?_SC_MARGE_SYBOLE@ScintillaEditView@@2HB:near
UNDEF:00004C68                                         ; DATA XREF: ScintillaEditView::showMargin(int,bool)+2Dr
UNDEF:00004C6C ; unsigned int ScintillaEditView::_SC_MARGE_FOLDER
UNDEF:00004C6C                 extrn ?_SC_MARGE_FOLDER@ScintillaEditView@@2HB:near
UNDEF:00004C6C                                         ; DATA XREF: DocumentMap::setSyntaxHiliting(void)+2Dr
UNDEF:00004C6C                                         ; ScintillaEditView::showMargin(int,bool)+38r
UNDEF:00004C70                 extrn ___security_cookie:near
UNDEF:00004C70                                         ; DATA XREF: ViewZoneDlg::drawPreviewZone(tagDRAWITEMSTRUCT *)+6r
UNDEF:00004C70                                         ; DocumentMap::reloadMap(void)+14r ...
UNDEF:00004C74                 extrn __fltused:near
UNDEF:00004C74
UNDEF:00004C74
UNDEF:00004C74                 end