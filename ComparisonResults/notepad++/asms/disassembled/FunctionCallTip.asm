.data:00000000 ;
.data:00000000 ; +-------------------------------------------------------------------------+
.data:00000000 ; |   This file has been generated by The Interactive Disassembler (IDA)    |
.data:00000000 ; |           Copyright (c) 2015 Hex-Rays, <support@hex-rays.com>           |
.data:00000000 ; |                      License info: 48-3677-7074-51                      |
.data:00000000 ; |             Michalis Polychronakis, Stony Brook University              |
.data:00000000 ; +-------------------------------------------------------------------------+
.data:00000000 ;
.data:00000000 ; Input MD5   : 7146008CD5FC5E2EEBCCA72A00A4FD63
.data:00000000 ; Input CRC32 : 1DB31558
.data:00000000
.data:00000000 ; File Name   : C:\workspace\notepad-plus-plus-6.7.9.2\PowerEditor\visual.net\Unicode Debug\FunctionCallTip.obj
.data:00000000 ; Format      : COFF (X386MAGIC)
.data:00000000 ; includelib "uuid.lib"
.data:00000000 ; includelib "libcpmtd"
.data:00000000 ; must resolve: ?_Generic_object@?$_Error_objects@H@std@@2V_Generic_error_category@2@A
.data:00000000 ; must resolve: ?_Iostream_object@?$_Error_objects@H@std@@2V_Iostream_error_category@2@A
.data:00000000 ; must resolve: ?_System_object@?$_Error_objects@H@std@@2V_System_error_category@2@A
.data:00000000 ; must resolve: ?id@?$num_put@DV?$back_insert_iterator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@std@@2V0locale@2@A
.data:00000000 ; must resolve: ?id@?$num_put@_WV?$back_insert_iterator@V?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@@std@@@std@@2V0locale@2@A
.data:00000000 ; must resolve: ?id@?$numpunct@D@std@@2V0locale@2@A
.data:00000000 ; must resolve: ?id@?$numpunct@_W@std@@2V0locale@2@A
.data:00000000 ; includelib "LIBCMTD"
.data:00000000 ; includelib "OLDNAMES"
.data:00000000
.data:00000000                 include uni.inc ; see unicode subdir of ida for info on unicode
.data:00000000
.data:00000000                 .686p
.data:00000000                 .mmx
.data:00000000                 .model flat
.data:00000000
.data:00000000 ; ===========================================================================
.data:00000000
.data:00000000 ; Segment type: Pure data
.data:00000000 ; Segment permissions: Read/Write
.data:00000000 ; Segment alignment 'qword' can not be represented in assembly
.data:00000000 _data           segment para public 'DATA' use32
.data:00000000                 assume cs:_data
.data:00000000 _acTop_xpm      dd offset $SG143412     ; "12 12 56 1"
.data:00000004                 dd offset $SG143413     ; " \tc #FFFFFF"
.data:00000008                 dd offset $SG143414     ; ".\tc #8AB2E9"
.data:0000000C                 dd offset $SG143415     ; "+\tc #CCDCF6"
.data:00000010                 dd offset $SG143416     ; "@\tc #80ABEA"
.data:00000014                 dd offset $SG143417     ; "#\tc #7DA9E8"
.data:00000018                 dd offset $SG143418     ; "$\tc #C7DAF3"
.data:0000001C                 dd offset $SG143419     ; "%\tc #79A7E6"
.data:00000020 off_20          dd offset $SG143420     ; DATA XREF: .rdata:$SG154404o
.data:00000020                                         ; "&\tc #ADC8EF"
.data:00000024                 dd offset $SG143421     ; "*\tc #87B0E8"
.data:00000028                 dd offset $SG143422     ; DATA XREF: .rdata:$SG154415o
.data:00000028                                         ; "=\tc #BBD2F0"
.data:0000002C                 dd offset $SG143423     ; "-\tc #6EA0E2"
.data:00000030                 dd offset $SG143424     ; ";\tc #A8C7EE"
.data:00000034                 dd offset $SG143425     ; ">\tc #A3C2ED"
.data:00000038                 dd offset $SG143426     ; ",\tc #75A4E3"
.data:0000003C                 dd offset $SG143427     ; "'\tc #A7C4EB"
.data:00000040                 dd offset $SG143428     ; ")\tc #6297E1"
.data:00000044                 dd offset $SG143429     ; "!\tc #A1C1EC"
.data:00000048                 dd offset $SG143430     ; "~\tc #92B7E8"
.data:0000004C                 dd offset $SG143431     ; "{\tc #99BBE9"
.data:00000050                 dd offset $SG143432     ; "]\tc #6197DD"
.data:00000054                 dd offset $SG143433     ; "^\tc #96B9E6"
.data:00000058                 dd offset $SG143434     ; "/\tc #538EDB"
.data:0000005C                 dd offset $SG143435     ; "(\tc #99BBEA"
.data:00000060                 dd offset $SG143436     ; "_\tc #80AAE3"
.data:00000064                 dd offset $SG143437     ; ":\tc #81ABE3"
.data:00000068                 dd offset $SG143438     ; "<\tc #8AB1E4"
.data:0000006C                 dd offset $SG143439     ; "[\tc #4B88D6"
.data:00000070                 dd offset $SG143440     ; "}\tc #4882D1"
.data:00000074                 dd offset $SG143441     ; "|\tc #4384D6"
.data:00000078                 dd offset $SG143442     ; "1\tc #90B5E7"
.data:0000007C                 dd offset $SG143443     ; "2\tc #74A3E0"
.data:00000080                 dd offset $SG143444     ; "3\tc #77A4E0"
.data:00000084                 dd offset $SG143445     ; "4\tc #81ABE2"
.data:00000088                 dd offset $SG143446     ; "5\tc #437FD3"
.data:0000008C                 dd offset $SG143447     ; "6\tc #7FA2DF"
.data:00000090                 dd offset $SG143448     ; "7\tc #3577D2"
.data:00000094                 dd offset $SG143449     ; "8\tc #87AFE4"
.data:00000098                 dd offset $SG143450     ; "9\tc #72A1DF"
.data:0000009C                 dd offset $SG143451     ; "0\tc #7CA9E1"
.data:000000A0                 dd offset $SG143452     ; "a\tc #3F7AD0"
.data:000000A4                 dd offset $SG143453     ; "b\tc #85A4DE"
.data:000000A8                 dd offset $SG143454     ; "c\tc #FBFCFE"
.data:000000AC                 dd offset $SG143455     ; "d\tc #236ECD"
.data:000000B0                 dd offset $SG143456     ; "e\tc #7EA8E1"
.data:000000B4                 dd offset $SG143457     ; "f\tc #79A6E0"
.data:000000B8                 dd offset $SG143458     ; "g\tc #3D77D0"
.data:000000BC                 dd offset $SG143459     ; "h\tc #87A4DC"
.data:000000C0                 dd offset $SG143460     ; "i\tc #1A62C9"
.data:000000C4                 dd offset $SG143461     ; "j\tc #75A3DF"
.data:000000C8                 dd offset $SG143462     ; "k\tc #3C74CF"
.data:000000CC                 dd offset $SG143463     ; "l\tc #8DA6DE"
.data:000000D0                 dd offset $SG143464     ; "m\tc #1859C4"
.data:000000D4                 dd offset $SG143465     ; "n\tc #3B71CC"
.data:000000D8                 dd offset $SG143466     ; "o\tc #8EA5DD"
.data:000000DC                 dd offset $SG143467     ; "p\tc #164EC0"
.data:000000E0                 dd offset $SG143468     ; "q\tc #92A7DD"
.data:000000E4                 dd offset $SG143469     ; "    .+      "
.data:000000E8                 dd offset $SG143470     ; "    @#$     "
.data:000000EC                 dd offset $SG143471     ; "    %&*=    "
.data:000000F0                 dd offset $SG143472     ; "    -;>,'   "
.data:000000F4                 dd offset $SG143473     ; "    )!~{]^  "
.data:000000F8                 dd offset $SG143474     ; "    /(_:<[} "
.data:000000FC                 dd offset $SG143475     ; "    |123456 "
.data:00000100                 dd offset $SG143476     ; "    7890abc "
.data:00000104                 dd offset $SG143477     ; "    defgh   "
.data:00000108                 dd offset $SG143478     ; "    ijkl    "
.data:0000010C                 dd offset $SG143479     ; "    mno     "
.data:00000110                 dd offset $SG143480     ; "    pq      "
.data:00000114                 align 8
.data:00000118 _acBottom_xpm   dd offset $SG143482     ; "12 12 54 1"
.data:0000011C                 dd offset $SG143483     ; " \tc #FFFFFF"
.data:00000120                 dd offset $SG143484     ; ".\tc #C4D7F3"
.data:00000124                 dd offset $SG143485     ; "+\tc #72A1E3"
.data:00000128                 dd offset $SG143486     ; "@\tc #C1D6F2"
.data:0000012C                 dd offset $SG143487     ; "#\tc #6397E1"
.data:00000130                 dd offset $SG143488     ; "$\tc #5990DD"
.data:00000134                 dd offset $SG143489     ; "%\tc #BBD2F0"
.data:00000138                 dd offset $SG143490     ; "&\tc #7AA6E5"
.data:0000013C                 dd offset $SG143491     ; "*\tc #9ABDEA"
.data:00000140                 dd offset $SG143492     ; "=\tc #4A87D9"
.data:00000144                 dd offset $SG143493     ; "-\tc #B1CAEE"
.data:00000148                 dd offset $SG143494     ; ";\tc #75A4E3"
.data:0000014C                 dd offset $SG143495     ; ">\tc #99BBE9"
.data:00000150                 dd offset $SG143496     ; ",\tc #95B9E8"
.data:00000154                 dd offset $SG143497     ; "'\tc #3A7CD4"
.data:00000158                 dd offset $SG143498     ; ")\tc #A9C6EC"
.data:0000015C                 dd offset $SG143499     ; "!\tc #71A0E0"
.data:00000160                 dd offset $SG143500     ; "~\tc #86AFE5"
.data:00000164                 dd offset $SG143501     ; "{\tc #8DB2E6"
.data:00000168                 dd offset $SG143502     ; "]\tc #2A72CF"
.data:0000016C                 dd offset $SG143503     ; "^\tc #73A0E0"
.data:00000170                 dd offset $SG143504     ; "/\tc #6B9DE0"
.data:00000174                 dd offset $SG143505     ; "(\tc #95B8E8"
.data:00000178                 dd offset $SG143506     ; "_\tc #81ABE3"
.data:0000017C                 dd offset $SG143507     ; ":\tc #72A1DF"
.data:00000180                 dd offset $SG143508     ; "<\tc #83ADE3"
.data:00000184                 dd offset $SG143509     ; "[\tc #1B65C9"
.data:00000188                 dd offset $SG143510     ; "}\tc #5F95DC"
.data:0000018C                 dd offset $SG143511     ; "|\tc #8BB3E5"
.data:00000190                 dd offset $SG143512     ; "1\tc #77A4E0"
.data:00000194                 dd offset $SG143513     ; "2\tc #679ADC"
.data:00000198                 dd offset $SG143514     ; "3\tc #7AA6E1"
.data:0000019C                 dd offset $SG143515     ; "4\tc #195CC6"
.data:000001A0                 dd offset $SG143516     ; "5\tc #FCFDFE"
.data:000001A4                 dd offset $SG143517     ; "6\tc #8DB2E4"
.data:000001A8                 dd offset $SG143518     ; "7\tc #4885D6"
.data:000001AC                 dd offset $SG143519     ; "8\tc #7CA9E1"
.data:000001B0                 dd offset $SG143520     ; "9\tc #6698DB"
.data:000001B4                 dd offset $SG143521     ; "0\tc #71A1DE"
.data:000001B8                 dd offset $SG143522     ; "a\tc #1752C0"
.data:000001BC                 dd offset $SG143523     ; "b\tc #88ABE0"
.data:000001C0                 dd offset $SG143524     ; "c\tc #3D77D0"
.data:000001C4                 dd offset $SG143525     ; "d\tc #6E9FDD"
.data:000001C8                 dd offset $SG143526     ; "e\tc #699BDC"
.data:000001CC                 dd offset $SG143527     ; "f\tc #1547BD"
.data:000001D0                 dd offset $SG143528     ; "g\tc #8DA6DE"
.data:000001D4                 dd offset $SG143529     ; "h\tc #376BC9"
.data:000001D8                 dd offset $SG143530     ; "i\tc #6295DA"
.data:000001DC                 dd offset $SG143531     ; "j\tc #1440B9"
.data:000001E0                 dd offset $SG143532     ; "k\tc #8DA0DB"
.data:000001E4                 dd offset $SG143533     ; "l\tc #315FC4"
.data:000001E8                 dd offset $SG143534     ; "m\tc #1339B7"
.data:000001EC                 dd offset $SG143535     ; "n\tc #909FDA"
.data:000001F0                 dd offset $SG143536     ; "o\tc #1233B4"
.data:000001F4                 dd offset $SG143537     ; "         .+ "
.data:000001F8                 dd offset $SG143538     ; "        @#$ "
.data:000001FC                 dd offset $SG143539     ; "       %&*= L"
.data:00000200                 dd offset $SG143540     ; "      -;>,' "
.data:00000204                 dd offset $SG143541     ; "     )!>~{] "
.data:00000208                 dd offset $SG143542     ; "    ^/(_:<[ "
.data:0000020C                 dd offset $SG143543     ; "    (}|1234 "
.data:00000210                 dd offset $SG143544     ; "    567890a "
.data:00000214                 dd offset $SG143545     ; "      bcdef "
.data:00000218                 dd offset $SG143546     ; "       ghij "
.data:0000021C                 dd offset $SG143547     ; "        klm "
.data:00000220                 dd offset $SG143548     ; "         no "
.data:00000224                 align 8
.data:00000228 _bookmark_xpm   dd offset $SG143550     ; "13 14 54 1"
.data:0000022C                 dd offset $SG143551     ; " \tc None"
.data:00000230                 dd offset $SG143552     ; ".\tc #545254"
.data:00000234                 dd offset $SG143553     ; "+\tc #3C3E3C"
.data:00000238                 dd offset $SG143554     ; "@\tc #646464"
.data:0000023C                 dd offset $SG143555     ; "#\tc #A4A4A4"
.data:00000240                 dd offset $SG143556     ; "$\tc #B7B8B7"
.data:00000244                 dd offset $SG143557     ; "%\tc #747284"
.data:00000248                 dd offset $SG143558     ; "&\tc #B4B2C4"
.data:0000024C                 dd offset $SG143559     ; "*\tc #DCD7E4"
.data:00000250                 dd offset $SG143560     ; "=\tc #1C1A1C"
.data:00000254                 dd offset $SG143561     ; "-\tc #403E58"
.data:00000258                 dd offset $SG143562     ; ";\tc #5C5A8C"
.data:0000025C                 dd offset $SG143563     ; ">\tc #7C7EAC"
.data:00000260                 dd offset $SG143564     ; ",\tc #7C8EBC"
.data:00000264                 dd offset $SG143565     ; "'\tc #242644"
.data:00000268                 dd offset $SG143566     ; ")\tc #282668"
.data:0000026C                 dd offset $SG143567     ; "!\tc #24367C"
.data:00000270                 dd offset $SG143568     ; "~\tc #244A84"
.data:00000274                 dd offset $SG143569     ; "{\tc #2C5098"
.data:00000278                 dd offset $SG143570     ; "]\tc #14162C"
.data:0000027C                 dd offset $SG143571     ; "^\tc #142E7C"
.data:00000280                 dd offset $SG143572     ; "/\tc #143789"
.data:00000284                 dd offset $SG143573     ; "(\tc #204990"
.data:00000288                 dd offset $SG143574     ; "_\tc #174091"
.data:0000028C                 dd offset $SG143575     ; ":\tc #0C0630"
.data:00000290                 dd offset $SG143576     ; "<\tc #24327C"
.data:00000294                 dd offset $SG143577     ; "[\tc #2450A0"
.data:00000298                 dd offset $SG143578     ; "}\tc #345DB4"
.data:0000029C                 dd offset $SG143579     ; "|\tc #3C68B8"
.data:000002A0                 dd offset $SG143580     ; "1\tc #141244"
.data:000002A4                 dd offset $SG143581     ; "2\tc #24428C"
.data:000002A8                 dd offset $SG143582     ; "3\tc #3462B9"
.data:000002AC                 dd offset $SG143583     ; "4\tc #4470C4"
.data:000002B0                 dd offset $SG143584     ; "5\tc #4C7FD6"
.data:000002B4                 dd offset $SG143585     ; "6\tc #4472CC"
.data:000002B8                 dd offset $SG143586     ; "7\tc #24224C"
.data:000002BC                 dd offset $SG143587     ; "8\tc #5C8DEC"
.data:000002C0                 dd offset $SG143588     ; "9\tc #5C94F6"
.data:000002C4                 dd offset $SG143589     ; "0\tc #5482DF"
.data:000002C8                 dd offset $SG143590     ; "a\tc #619DF7"
.data:000002CC                 dd offset $SG143591     ; "b\tc #6CA6FC"
.data:000002D0                 dd offset $SG143592     ; "c\tc #64A2FC"
.data:000002D4                 dd offset $SG143593     ; "d\tc #1C2E5C"
.data:000002D8                 dd offset $SG143594     ; "e\tc #6CA2FC"
.data:000002DC                 dd offset $SG143595     ; "f\tc #74B2FC"
.data:000002E0                 dd offset $SG143596     ; "g\tc #7CB8FC"
.data:000002E4                 dd offset $SG143597     ; "h\tc #1C3264"
.data:000002E8                 dd offset $SG143598     ; "i\tc #346AD4"
.data:000002EC                 dd offset $SG143599     ; "j\tc #7CBEFC"
.data:000002F0                 dd offset $SG143600     ; "k\tc #3C72DC"
.data:000002F4                 dd offset $SG143601     ; "l\tc #243250"
.data:000002F8                 dd offset $SG143602     ; "m\tc #346AB4"
.data:000002FC                 dd offset $SG143603     ; "n\tc #3C82DC"
.data:00000300                 dd offset $SG143604     ; "o\tc #6C6A6C"
.data:00000304                 dd offset $SG143605     ; "     .+.     "
.data:00000308                 dd offset $SG143606     ; "   @##$##@   "
.data:0000030C                 dd offset $SG143607     ; "  @%&***&%@  "
.data:00000310                 dd offset $SG143608     ; " =-;>,,,>;-= "
.data:00000314                 dd offset $SG143609     ; " ')!~{{{~!)' "
.data:00000318                 dd offset $SG143610     ; "])^/({{{(_^)]"
.data:0000031C                 dd offset $SG143611     ; ":<_[}|||}[_<:"
.data:00000320                 dd offset $SG143612     ; "12[3455563[21"
.data:00000324                 dd offset $SG143613     ; "7_365899063_7"
.data:00000328                 dd offset $SG143614     ; " /|09abc904/ "
.data:0000032C                 dd offset $SG143615     ; " d}8efgfb83d "
.data:00000330                 dd offset $SG143616     ; "  hiafjgakh  "
.data:00000334                 dd offset $SG143617     ; "   l~mnm~l   "
.data:00000338                 dd offset $SG143618     ; "     o@o     "
.data:00000338 _data           ends
.data:00000338
.rdata:0000033C ; ===========================================================================
.rdata:0000033C
.rdata:0000033C ; Segment type: Pure data
.rdata:0000033C ; Segment permissions: Read
.rdata:0000033C _rdata          segment dword public 'DATA' use32
.rdata:0000033C                 assume cs:_rdata
.rdata:0000033C                 ;org 33Ch
.rdata:0000033C $SG143412       db '12 12 56 1',0       ; DATA XREF: .data:_acTop_xpmo
.rdata:00000347                 align 4
.rdata:00000348 $SG143413       db ' ',9,'c #FFFFFF',0  ; DATA XREF: .data:00000004o
.rdata:00000354 $SG143414       db '.',9,'c #8AB2E9',0  ; DATA XREF: .data:00000008o
.rdata:00000360 $SG143415       db '+',9,'c #CCDCF6',0  ; DATA XREF: .data:0000000Co
.rdata:0000036C $SG143416       db '@',9,'c #80ABEA',0  ; DATA XREF: .data:00000010o
.rdata:00000378 $SG143417       db '#',9,'c #7DA9E8',0  ; DATA XREF: .data:00000014o
.rdata:00000384 $SG143418       db '$',9,'c #C7DAF3',0  ; DATA XREF: .data:00000018o
.rdata:00000390 $SG143419       db '%',9,'c #79A7E6',0  ; DATA XREF: .data:0000001Co
.rdata:0000039C $SG143420       db '&',9,'c #ADC8EF',0  ; DATA XREF: .data:off_20o
.rdata:000003A8 $SG143421       db '*',9,'c #87B0E8',0  ; DATA XREF: .data:00000024o
.rdata:000003B4 $SG143422       db '=',9,'c #BBD2F0',0  ; DATA XREF: .data:00000028o
.rdata:000003C0 $SG143423       db '-',9,'c #6EA0E2',0  ; DATA XREF: .data:0000002Co
.rdata:000003CC $SG143424       db ';',9,'c #A8C7EE',0  ; DATA XREF: .data:00000030o
.rdata:000003D8 $SG143425       db '>',9,'c #A3C2ED',0  ; DATA XREF: .data:00000034o
.rdata:000003E4 $SG143426       db ',',9,'c #75A4E3',0  ; DATA XREF: .data:00000038o
.rdata:000003F0 $SG143427       db 27h,9,'c #A7C4EB',0  ; DATA XREF: .data:0000003Co
.rdata:000003FC $SG143428       db ')',9,'c #6297E1',0  ; DATA XREF: .data:00000040o
.rdata:00000408 $SG143429       db '!',9,'c #A1C1EC',0  ; DATA XREF: .data:00000044o
.rdata:00000414 $SG143430       db '~',9,'c #92B7E8',0  ; DATA XREF: .data:00000048o
.rdata:00000420 $SG143431       db '{',9,'c #99BBE9',0  ; DATA XREF: .data:0000004Co
.rdata:0000042C $SG143432       db ']',9,'c #6197DD',0  ; DATA XREF: .data:00000050o
.rdata:00000438 $SG143433       db '^',9,'c #96B9E6',0  ; DATA XREF: .data:00000054o
.rdata:00000444 $SG143434       db '/',9,'c #538EDB',0  ; DATA XREF: .data:00000058o
.rdata:00000450 $SG143435       db '(',9,'c #99BBEA',0  ; DATA XREF: .data:0000005Co
.rdata:0000045C $SG143436       db '_',9,'c #80AAE3',0  ; DATA XREF: .data:00000060o
.rdata:00000468 $SG143437       db ':',9,'c #81ABE3',0  ; DATA XREF: .data:00000064o
.rdata:00000474 $SG143438       db '<',9,'c #8AB1E4',0  ; DATA XREF: .data:00000068o
.rdata:00000480 $SG143439       db '[',9,'c #4B88D6',0  ; DATA XREF: .data:0000006Co
.rdata:0000048C $SG143440       db '}',9,'c #4882D1',0  ; DATA XREF: .data:00000070o
.rdata:00000498 $SG143441       db '|',9,'c #4384D6',0  ; DATA XREF: .data:00000074o
.rdata:000004A4 $SG143442       db '1',9,'c #90B5E7',0  ; DATA XREF: .data:00000078o
.rdata:000004B0 $SG143443       db '2',9,'c #74A3E0',0  ; DATA XREF: .data:0000007Co
.rdata:000004BC $SG143444       db '3',9,'c #77A4E0',0  ; DATA XREF: .data:00000080o
.rdata:000004C8 $SG143445       db '4',9,'c #81ABE2',0  ; DATA XREF: .data:00000084o
.rdata:000004D4 $SG143446       db '5',9,'c #437FD3',0  ; DATA XREF: .data:00000088o
.rdata:000004E0 $SG143447       db '6',9,'c #7FA2DF',0  ; DATA XREF: .data:0000008Co
.rdata:000004EC $SG143448       db '7',9,'c #3577D2',0  ; DATA XREF: .data:00000090o
.rdata:000004F8 $SG143449       db '8',9,'c #87AFE4',0  ; DATA XREF: .data:00000094o
.rdata:00000504 $SG143450       db '9',9,'c #72A1DF',0  ; DATA XREF: .data:00000098o
.rdata:00000510 $SG143451       db '0',9,'c #7CA9E1',0  ; DATA XREF: .data:0000009Co
.rdata:0000051C $SG143452       db 'a',9,'c #3F7AD0',0  ; DATA XREF: .data:000000A0o
.rdata:00000528 $SG143453       db 'b',9,'c #85A4DE',0  ; DATA XREF: .data:000000A4o
.rdata:00000534 $SG143454       db 'c',9,'c #FBFCFE',0  ; DATA XREF: .data:000000A8o
.rdata:00000540 $SG143455       db 'd',9,'c #236ECD',0  ; DATA XREF: .data:000000ACo
.rdata:0000054C $SG143456       db 'e',9,'c #7EA8E1',0  ; DATA XREF: .data:000000B0o
.rdata:00000558 $SG143457       db 'f',9,'c #79A6E0',0  ; DATA XREF: .data:000000B4o
.rdata:00000564 $SG143458       db 'g',9,'c #3D77D0',0  ; DATA XREF: .data:000000B8o
.rdata:00000570 $SG143459       db 'h',9,'c #87A4DC',0  ; DATA XREF: .data:000000BCo
.rdata:0000057C $SG143460       db 'i',9,'c #1A62C9',0  ; DATA XREF: .data:000000C0o
.rdata:00000588 $SG143461       db 'j',9,'c #75A3DF',0  ; DATA XREF: .data:000000C4o
.rdata:00000594 $SG143462       db 'k',9,'c #3C74CF',0  ; DATA XREF: .data:000000C8o
.rdata:000005A0 $SG143463       db 'l',9,'c #8DA6DE',0  ; DATA XREF: .data:000000CCo
.rdata:000005AC $SG143464       db 'm',9,'c #1859C4',0  ; DATA XREF: .data:000000D0o
.rdata:000005B8 $SG143465       db 'n',9,'c #3B71CC',0  ; DATA XREF: .data:000000D4o
.rdata:000005C4 $SG143466       db 'o',9,'c #8EA5DD',0  ; DATA XREF: .data:000000D8o
.rdata:000005D0 $SG143467       db 'p',9,'c #164EC0',0  ; DATA XREF: .data:000000DCo
.rdata:000005DC $SG143468       db 'q',9,'c #92A7DD',0  ; DATA XREF: .data:000000E0o
.rdata:000005E8 $SG143469       db '    .+      ',0     ; DATA XREF: .data:000000E4o
.rdata:000005F5                 align 4
.rdata:000005F8 $SG143470       db '    @#$     ',0     ; DATA XREF: .data:000000E8o
.rdata:00000605                 align 4
.rdata:00000608 $SG143471       db '    %&*=    ',0     ; DATA XREF: .data:000000ECo
.rdata:00000615                 align 4
.rdata:00000618 $SG143472       db '    -;>,',27h,'   ',0 ; DATA XREF: .data:000000F0o
.rdata:00000625                 align 4
.rdata:00000628 $SG143473       db '    )!~{]^  ',0     ; DATA XREF: .data:000000F4o
.rdata:00000635                 align 4
.rdata:00000638 $SG143474       db '    /(_:<[} ',0     ; DATA XREF: .data:000000F8o
.rdata:00000645                 align 4
.rdata:00000648 $SG143475       db '    |123456 ',0     ; DATA XREF: .data:000000FCo
.rdata:00000655                 align 4
.rdata:00000658 $SG143476       db '    7890abc ',0     ; DATA XREF: .data:00000100o
.rdata:00000665                 align 4
.rdata:00000668 $SG143477       db '    defgh   ',0     ; DATA XREF: .data:00000104o
.rdata:00000675                 align 4
.rdata:00000678 $SG143478       db '    ijkl    ',0     ; DATA XREF: .data:00000108o
.rdata:00000685                 align 4
.rdata:00000688 $SG143479       db '    mno     ',0     ; DATA XREF: .data:0000010Co
.rdata:00000695                 align 4
.rdata:00000698 $SG143480       db '    pq      ',0     ; DATA XREF: .data:00000110o
.rdata:000006A5                 align 4
.rdata:000006A8 $SG143482       db '12 12 54 1',0       ; DATA XREF: .data:_acBottom_xpmo
.rdata:000006B3                 align 4
.rdata:000006B4 $SG143483       db ' ',9,'c #FFFFFF',0  ; DATA XREF: .data:0000011Co
.rdata:000006C0 $SG143484       db '.',9,'c #C4D7F3',0  ; DATA XREF: .data:00000120o
.rdata:000006CC $SG143485       db '+',9,'c #72A1E3',0  ; DATA XREF: .data:00000124o
.rdata:000006D8 $SG143486       db '@',9,'c #C1D6F2',0  ; DATA XREF: .data:00000128o
.rdata:000006E4 $SG143487       db '#',9,'c #6397E1',0  ; DATA XREF: .data:0000012Co
.rdata:000006F0 $SG143488       db '$',9,'c #5990DD',0  ; DATA XREF: .data:00000130o
.rdata:000006FC $SG143489       db '%',9,'c #BBD2F0',0  ; DATA XREF: .data:00000134o
.rdata:00000708 $SG143490       db '&',9,'c #7AA6E5',0  ; DATA XREF: .data:00000138o
.rdata:00000714 $SG143491       db '*',9,'c #9ABDEA',0  ; DATA XREF: .data:0000013Co
.rdata:00000720 $SG143492       db '=',9,'c #4A87D9',0  ; DATA XREF: .data:00000140o
.rdata:0000072C $SG143493       db '-',9,'c #B1CAEE',0  ; DATA XREF: .data:00000144o
.rdata:00000738 $SG143494       db ';',9,'c #75A4E3',0  ; DATA XREF: .data:00000148o
.rdata:00000744 $SG143495       db '>',9,'c #99BBE9',0  ; DATA XREF: .data:0000014Co
.rdata:00000750 $SG143496       db ',',9,'c #95B9E8',0  ; DATA XREF: .data:00000150o
.rdata:0000075C $SG143497       db 27h,9,'c #3A7CD4',0  ; DATA XREF: .data:00000154o
.rdata:00000768 $SG143498       db ')',9,'c #A9C6EC',0  ; DATA XREF: .data:00000158o
.rdata:00000774 $SG143499       db '!',9,'c #71A0E0',0  ; DATA XREF: .data:0000015Co
.rdata:00000780 $SG143500       db '~',9,'c #86AFE5',0  ; DATA XREF: .data:00000160o
.rdata:0000078C $SG143501       db '{',9,'c #8DB2E6',0  ; DATA XREF: .data:00000164o
.rdata:00000798 $SG143502       db ']',9,'c #2A72CF',0  ; DATA XREF: .data:00000168o
.rdata:000007A4 $SG143503       db '^',9,'c #73A0E0',0  ; DATA XREF: .data:0000016Co
.rdata:000007B0 $SG143504       db '/',9,'c #6B9DE0',0  ; DATA XREF: .data:00000170o
.rdata:000007BC $SG143505       db '(',9,'c #95B8E8',0  ; DATA XREF: .data:00000174o
.rdata:000007C8 $SG143506       db '_',9,'c #81ABE3',0  ; DATA XREF: .data:00000178o
.rdata:000007D4 $SG143507       db ':',9,'c #72A1DF',0  ; DATA XREF: .data:0000017Co
.rdata:000007E0 $SG143508       db '<',9,'c #83ADE3',0  ; DATA XREF: .data:00000180o
.rdata:000007EC $SG143509       db '[',9,'c #1B65C9',0  ; DATA XREF: .data:00000184o
.rdata:000007F8 $SG143510       db '}',9,'c #5F95DC',0  ; DATA XREF: .data:00000188o
.rdata:00000804 $SG143511       db '|',9,'c #8BB3E5',0  ; DATA XREF: .data:0000018Co
.rdata:00000810 $SG143512       db '1',9,'c #77A4E0',0  ; DATA XREF: .data:00000190o
.rdata:0000081C $SG143513       db '2',9,'c #679ADC',0  ; DATA XREF: .data:00000194o
.rdata:00000828 $SG143514       db '3',9,'c #7AA6E1',0  ; DATA XREF: .data:00000198o
.rdata:00000834 $SG143515       db '4',9,'c #195CC6',0  ; DATA XREF: .data:0000019Co
.rdata:00000840 $SG143516       db '5',9,'c #FCFDFE',0  ; DATA XREF: .data:000001A0o
.rdata:0000084C $SG143517       db '6',9,'c #8DB2E4',0  ; DATA XREF: .data:000001A4o
.rdata:00000858 $SG143518       db '7',9,'c #4885D6',0  ; DATA XREF: .data:000001A8o
.rdata:00000864 $SG143519       db '8',9,'c #7CA9E1',0  ; DATA XREF: .data:000001ACo
.rdata:00000870 $SG143520       db '9',9,'c #6698DB',0  ; DATA XREF: .data:000001B0o
.rdata:0000087C $SG143521       db '0',9,'c #71A1DE',0  ; DATA XREF: .data:000001B4o
.rdata:00000888 $SG143522       db 'a',9,'c #1752C0',0  ; DATA XREF: .data:000001B8o
.rdata:00000894 $SG143523       db 'b',9,'c #88ABE0',0  ; DATA XREF: .data:000001BCo
.rdata:000008A0 $SG143524       db 'c',9,'c #3D77D0',0  ; DATA XREF: .data:000001C0o
.rdata:000008AC $SG143525       db 'd',9,'c #6E9FDD',0  ; DATA XREF: .data:000001C4o
.rdata:000008B8 $SG143526       db 'e',9,'c #699BDC',0  ; DATA XREF: .data:000001C8o
.rdata:000008C4 $SG143527       db 'f',9,'c #1547BD',0  ; DATA XREF: .data:000001CCo
.rdata:000008D0 $SG143528       db 'g',9,'c #8DA6DE',0  ; DATA XREF: .data:000001D0o
.rdata:000008DC $SG143529       db 'h',9,'c #376BC9',0  ; DATA XREF: .data:000001D4o
.rdata:000008E8 $SG143530       db 'i',9,'c #6295DA',0  ; DATA XREF: .data:000001D8o
.rdata:000008F4 $SG143531       db 'j',9,'c #1440B9',0  ; DATA XREF: .data:000001DCo
.rdata:00000900 $SG143532       db 'k',9,'c #8DA0DB',0  ; DATA XREF: .data:000001E0o
.rdata:0000090C $SG143533       db 'l',9,'c #315FC4',0  ; DATA XREF: .data:000001E4o
.rdata:00000918 $SG143534       db 'm',9,'c #1339B7',0  ; DATA XREF: .data:000001E8o
.rdata:00000924 $SG143535       db 'n',9,'c #909FDA',0  ; DATA XREF: .data:000001ECo
.rdata:00000930 $SG143536       db 'o',9,'c #1233B4',0  ; DATA XREF: .data:000001F0o
.rdata:0000093C $SG143537       db '         .+ ',0     ; DATA XREF: .data:000001F4o
.rdata:00000949                 align 4
.rdata:0000094C $SG143538       db '        @#$ ',0     ; DATA XREF: .data:000001F8o
.rdata:00000959                 align 4
.rdata:0000095C $SG143539       db '       %&*= L',0    ; DATA XREF: .data:000001FCo
.rdata:0000096A                 align 4
.rdata:0000096C $SG143540       db '      -;>,',27h,' ',0 ; DATA XREF: .data:00000200o
.rdata:00000979                 align 4
.rdata:0000097C $SG143541       db '     )!>~{] ',0     ; DATA XREF: .data:00000204o
.rdata:00000989                 align 4
.rdata:0000098C $SG143542       db '    ^/(_:<[ ',0     ; DATA XREF: .data:00000208o
.rdata:00000999                 align 4
.rdata:0000099C $SG143543       db '    (}|1234 ',0     ; DATA XREF: .data:0000020Co
.rdata:000009A9                 align 4
.rdata:000009AC $SG143544       db '    567890a ',0     ; DATA XREF: .data:00000210o
.rdata:000009B9                 align 4
.rdata:000009BC $SG143545       db '      bcdef ',0     ; DATA XREF: .data:00000214o
.rdata:000009C9                 align 4
.rdata:000009CC $SG143546       db '       ghij ',0     ; DATA XREF: .data:00000218o
.rdata:000009D9                 align 4
.rdata:000009DC $SG143547       db '        klm ',0     ; DATA XREF: .data:0000021Co
.rdata:000009E9                 align 4
.rdata:000009EC $SG143548       db '         no ',0     ; DATA XREF: .data:00000220o
.rdata:000009F9                 align 4
.rdata:000009FC $SG143550       db '13 14 54 1',0       ; DATA XREF: .data:_bookmark_xpmo
.rdata:00000A07                 align 4
.rdata:00000A08 $SG152767       dw 0                    ; DATA XREF: FunctionCallTip::getCursorFunction(void):loc_1106r
.rdata:00000A0A                 align 4
.rdata:00000A0C $SG143551       db ' ',9,'c None',0     ; DATA XREF: .data:0000022Co
.rdata:00000A15                 align 4
.rdata:00000A18 $SG143552       db '.',9,'c #545254',0  ; DATA XREF: .data:00000230o
.rdata:00000A24 $SG143553       db '+',9,'c #3C3E3C',0  ; DATA XREF: .data:00000234o
.rdata:00000A30 $SG143554       db '@',9,'c #646464',0  ; DATA XREF: .data:00000238o
.rdata:00000A3C $SG143555       db '#',9,'c #A4A4A4',0  ; DATA XREF: .data:0000023Co
.rdata:00000A48 $SG143556       db '$',9,'c #B7B8B7',0  ; DATA XREF: .data:00000240o
.rdata:00000A54 $SG143557       db '%',9,'c #747284',0  ; DATA XREF: .data:00000244o
.rdata:00000A60 $SG143558       db '&',9,'c #B4B2C4',0  ; DATA XREF: .data:00000248o
.rdata:00000A6C $SG143559       db '*',9,'c #DCD7E4',0  ; DATA XREF: .data:0000024Co
.rdata:00000A78 $SG143560       db '=',9,'c #1C1A1C',0  ; DATA XREF: .data:00000250o
.rdata:00000A84 $SG143561       db '-',9,'c #403E58',0  ; DATA XREF: .data:00000254o
.rdata:00000A90 $SG143562       db ';',9,'c #5C5A8C',0  ; DATA XREF: .data:00000258o
.rdata:00000A9C $SG143563       db '>',9,'c #7C7EAC',0  ; DATA XREF: .data:0000025Co
.rdata:00000AA8 $SG143564       db ',',9,'c #7C8EBC',0  ; DATA XREF: .data:00000260o
.rdata:00000AB4 $SG143565       db 27h,9,'c #242644',0  ; DATA XREF: .data:00000264o
.rdata:00000AC0 $SG143566       db ')',9,'c #282668',0  ; DATA XREF: .data:00000268o
.rdata:00000ACC $SG143567       db '!',9,'c #24367C',0  ; DATA XREF: .data:0000026Co
.rdata:00000AD8 $SG143568       db '~',9,'c #244A84',0  ; DATA XREF: .data:00000270o
.rdata:00000AE4 $SG143569       db '{',9,'c #2C5098',0  ; DATA XREF: .data:00000274o
.rdata:00000AF0 $SG143570       db ']',9,'c #14162C',0  ; DATA XREF: .data:00000278o
.rdata:00000AFC $SG143571       db '^',9,'c #142E7C',0  ; DATA XREF: .data:0000027Co
.rdata:00000B08 $SG143572       db '/',9,'c #143789',0  ; DATA XREF: .data:00000280o
.rdata:00000B14 $SG143573       db '(',9,'c #204990',0  ; DATA XREF: .data:00000284o
.rdata:00000B20 $SG143574       db '_',9,'c #174091',0  ; DATA XREF: .data:00000288o
.rdata:00000B2C $SG143575       db ':',9,'c #0C0630',0  ; DATA XREF: .data:0000028Co
.rdata:00000B38 $SG143576       db '<',9,'c #24327C',0  ; DATA XREF: .data:00000290o
.rdata:00000B44 $SG143577       db '[',9,'c #2450A0',0  ; DATA XREF: .data:00000294o
.rdata:00000B50 $SG143578       db '}',9,'c #345DB4',0  ; DATA XREF: .data:00000298o
.rdata:00000B5C $SG143579       db '|',9,'c #3C68B8',0  ; DATA XREF: .data:0000029Co
.rdata:00000B68 $SG143580       db '1',9,'c #141244',0  ; DATA XREF: .data:000002A0o
.rdata:00000B74 $SG143581       db '2',9,'c #24428C',0  ; DATA XREF: .data:000002A4o
.rdata:00000B80 $SG143582       db '3',9,'c #3462B9',0  ; DATA XREF: .data:000002A8o
.rdata:00000B8C $SG143583       db '4',9,'c #4470C4',0  ; DATA XREF: .data:000002ACo
.rdata:00000B98 $SG143584       db '5',9,'c #4C7FD6',0  ; DATA XREF: .data:000002B0o
.rdata:00000BA4 $SG143585       db '6',9,'c #4472CC',0  ; DATA XREF: .data:000002B4o
.rdata:00000BB0 $SG143586       db '7',9,'c #24224C',0  ; DATA XREF: .data:000002B8o
.rdata:00000BBC $SG143587       db '8',9,'c #5C8DEC',0  ; DATA XREF: .data:000002BCo
.rdata:00000BC8 $SG143588       db '9',9,'c #5C94F6',0  ; DATA XREF: .data:000002C0o
.rdata:00000BD4 $SG143589       db '0',9,'c #5482DF',0  ; DATA XREF: .data:000002C4o
.rdata:00000BE0 $SG143590       db 'a',9,'c #619DF7',0  ; DATA XREF: .data:000002C8o
.rdata:00000BEC $SG143591       db 'b',9,'c #6CA6FC',0  ; DATA XREF: .data:000002CCo
.rdata:00000BF8 $SG143592       db 'c',9,'c #64A2FC',0  ; DATA XREF: .data:000002D0o
.rdata:00000C04 $SG143593       db 'd',9,'c #1C2E5C',0  ; DATA XREF: .data:000002D4o
.rdata:00000C10 $SG143594       db 'e',9,'c #6CA2FC',0  ; DATA XREF: .data:000002D8o
.rdata:00000C1C $SG143595       db 'f',9,'c #74B2FC',0  ; DATA XREF: .data:000002DCo
.rdata:00000C28 $SG143596       db 'g',9,'c #7CB8FC',0  ; DATA XREF: .data:000002E0o
.rdata:00000C34 $SG143597       db 'h',9,'c #1C3264',0  ; DATA XREF: .data:000002E4o
.rdata:00000C40 $SG143598       db 'i',9,'c #346AD4',0  ; DATA XREF: .data:000002E8o
.rdata:00000C4C $SG143599       db 'j',9,'c #7CBEFC',0  ; DATA XREF: .data:000002ECo
.rdata:00000C58 $SG143600       db 'k',9,'c #3C72DC',0  ; DATA XREF: .data:000002F0o
.rdata:00000C64 $SG143601       db 'l',9,'c #243250',0  ; DATA XREF: .data:000002F4o
.rdata:00000C70 $SG143602       db 'm',9,'c #346AB4',0  ; DATA XREF: .data:000002F8o
.rdata:00000C7C $SG143603       db 'n',9,'c #3C82DC',0  ; DATA XREF: .data:000002FCo
.rdata:00000C88 $SG143604       db 'o',9,'c #6C6A6C',0  ; DATA XREF: .data:00000300o
.rdata:00000C94 $SG143605       db '     .+.     ',0    ; DATA XREF: .data:00000304o
.rdata:00000CA2                 align 4
.rdata:00000CA4 $SG143606       db '   @##$##@   ',0    ; DATA XREF: .data:00000308o
.rdata:00000CB2                 align 4
.rdata:00000CB4 $SG143607       db '  @%&***&%@  ',0    ; DATA XREF: .data:0000030Co
.rdata:00000CC2                 align 4
.rdata:00000CC4 $SG143608       db ' =-;>,,,>;-= ',0    ; DATA XREF: .data:00000310o
.rdata:00000CD2                 align 4
.rdata:00000CD4 $SG143609       db ' ',27h,')!~{{{~!)',27h,' ',0
.rdata:00000CD4                                         ; DATA XREF: .data:00000314o
.rdata:00000CE2                 align 4
.rdata:00000CE4 $SG143610       db '])^/({{{(_^)]',0    ; DATA XREF: .data:00000318o
.rdata:00000CF2                 align 4
.rdata:00000CF4 $SG143611       db ':<_[}|||}[_<:',0    ; DATA XREF: .data:0000031Co
.rdata:00000D02                 align 4
.rdata:00000D04 $SG143612       db '12[3455563[21',0    ; DATA XREF: .data:00000320o
.rdata:00000D12                 align 4
.rdata:00000D14 $SG143613       db '7_365899063_7',0    ; DATA XREF: .data:00000324o
.rdata:00000D22                 align 4
.rdata:00000D24 $SG143614       db ' /|09abc904/ ',0    ; DATA XREF: .data:00000328o
.rdata:00000D32                 align 4
.rdata:00000D34 $SG143615       db ' d}8efgfb83d ',0    ; DATA XREF: .data:0000032Co
.rdata:00000D42                 align 4
.rdata:00000D44 $SG143616       db '  hiafjgakh  ',0    ; DATA XREF: .data:00000330o
.rdata:00000D52                 align 4
.rdata:00000D54 $SG143617       db '   l~mnm~l   ',0    ; DATA XREF: .data:00000334o
.rdata:00000D62                 align 4
.rdata:00000D64 $SG143618       db '     o@o     ',0    ; DATA XREF: .data:00000338o
.rdata:00000D72                 align 4
.rdata:00000D74 ; wchar_t _SG154327
.rdata:00000D74 $SG154327:                              ; DATA XREF: FunctionCallTip::loadFunction(void):loc_1899o
.rdata:00000D74                 unicode 0, <KeyWord>,0
.rdata:00000D84 ; wchar_t _SG154329
.rdata:00000D84 $SG154329:                              ; DATA XREF: FunctionCallTip::loadFunction(void)+66o
.rdata:00000D84                 unicode 0, <name>,0
.rdata:00000D8E                 align 10h
.rdata:00000D90 ; wchar_t _SG154336
.rdata:00000D90 $SG154336:                              ; DATA XREF: FunctionCallTip::loadFunction(void)+C4o
.rdata:00000D90                 unicode 0, <func>,0
.rdata:00000D9A                 align 4
.rdata:00000D9C ; const WCHAR _SG154339
.rdata:00000D9C $SG154339:                              ; DATA XREF: FunctionCallTip::loadFunction(void)+DAo
.rdata:00000D9C                 unicode 0, <yes>,0
.rdata:00000DA4 ; wchar_t _SG154344
.rdata:00000DA4 $SG154344:                              ; DATA XREF: FunctionCallTip::loadFunction(void)+125o
.rdata:00000DA4                 unicode 0, <Overload>,0
.rdata:00000DB6                 align 4
.rdata:00000DB8 ; wchar_t _SG154349
.rdata:00000DB8 $SG154349:                              ; DATA XREF: FunctionCallTip::loadFunction(void):loc_1995o
.rdata:00000DB8                 unicode 0, <Overload>,0
.rdata:00000DCA                 align 4
.rdata:00000DCC ; wchar_t _SG154351
.rdata:00000DCC $SG154351:                              ; DATA XREF: FunctionCallTip::loadFunction(void)+15Bo
.rdata:00000DCC                 unicode 0, <retVal>,0
.rdata:00000DDA                 align 4
.rdata:00000DDC ; wchar_t _SG154354
.rdata:00000DDC $SG154354:                              ; DATA XREF: FunctionCallTip::loadFunction(void)+182o
.rdata:00000DDC                 unicode 0, <descr>,0
.rdata:00000DE8 $SG154358       db    0                 ; DATA XREF: FunctionCallTip::loadFunction(void):loc_19FDo
.rdata:00000DE9                 db    0
.rdata:00000DEA                 db    0
.rdata:00000DEB                 db    0
.rdata:00000DEC ; wchar_t _SG154359
.rdata:00000DEC $SG154359:                              ; DATA XREF: FunctionCallTip::loadFunction(void):loc_1A13o
.rdata:00000DEC                 unicode 0, <Param>,0
.rdata:00000DF8 ; wchar_t _SG154363
.rdata:00000DF8 $SG154363:                              ; DATA XREF: FunctionCallTip::loadFunction(void):loc_1A25o
.rdata:00000DF8                 unicode 0, <Param>,0
.rdata:00000E04 ; wchar_t _SG154365
.rdata:00000E04 $SG154365:                              ; DATA XREF: FunctionCallTip::loadFunction(void)+1E7o
.rdata:00000E04                 unicode 0, <name>,0
.rdata:00000E0E                 align 10h
.rdata:00000E10 ; const WCHAR _SG154403
.rdata:00000E10 $SG154403       dw 1                    ; DATA XREF: FunctionCallTip::showCalltip(void)+29Eo
.rdata:00000E12                 db  25h ; %
.rdata:00000E13                 db    0
.rdata:00000E14                 db  75h ; u
.rdata:00000E15                 db    0
.rdata:00000E16                 db  20h
.rdata:00000E17                 db    0
.rdata:00000E18                 db  6Fh ; o
.rdata:00000E19                 db    0
.rdata:00000E1A                 db  66h ; f
.rdata:00000E1B                 db    0
.rdata:00000E1C                 db  20h
.rdata:00000E1D                 db    0
.rdata:00000E1E                 db  25h ; %
.rdata:00000E1F                 db    0
.rdata:00000E20                 db  75h ; u
.rdata:00000E21                 db    0
.rdata:00000E22                 db    2
.rdata:00000E23                 db    0
.rdata:00000E24                 db    0
.rdata:00000E25                 db    0
.rdata:00000E26                 db    0
.rdata:00000E27                 db    0
.rdata:00000E28 ; const WCHAR _SG154404
.rdata:00000E28 $SG154404       dd offset off_20        ; DATA XREF: FunctionCallTip::showCalltip(void)+2C7o
.rdata:00000E2C ; const WCHAR _SG154405
.rdata:00000E2C $SG154405:                              ; DATA XREF: FunctionCallTip::showCalltip(void)+2F0o
.rdata:00000E2C                 unicode 0, < (>,0
.rdata:00000E32                 align 4
.rdata:00000E34 ; const WCHAR _SG154414
.rdata:00000E34 $SG154414:                              ; DATA XREF: FunctionCallTip::showCalltip(void)+3C1o
.rdata:00000E34                 unicode 0, <, >,0
.rdata:00000E3A                 align 4
.rdata:00000E3C ; const WCHAR _SG154415
.rdata:00000E3C $SG154415       dd offset off_28+1      ; DATA XREF: FunctionCallTip::showCalltip(void):loc_1EBCo
.rdata:00000E40 ; const WCHAR _SG154417
.rdata:00000E40 $SG154417       dw 0Ah                  ; DATA XREF: FunctionCallTip::showCalltip(void)+3F5o
.rdata:00000E42                 align 4
.rdata:00000E42 _rdata          ends
.rdata:00000E42
.text$mn:00000E44 ; ===========================================================================
.text$mn:00000E44
.text$mn:00000E44 ; Segment type: Pure code
.text$mn:00000E44 ; Segment permissions: Read/Execute
.text$mn:00000E44 _text$mn        segment para public 'CODE' use32
.text$mn:00000E44                 assume cs:_text$mn
.text$mn:00000E44                 ;org 0E44h
.text$mn:00000E44                 assume es:nothing, ss:nothing, ds:_data, fs:nothing, gs:nothing
.text$mn:00000E44
.text$mn:00000E44 ; =============== S U B R O U T I N E =======================================
.text$mn:00000E44
.text$mn:00000E44 ; Attributes: bp-based frame
.text$mn:00000E44
.text$mn:00000E44 ; void __thiscall FunctionCallTip::setLanguageXML(FunctionCallTip *this, struct TiXmlElement *)
.text$mn:00000E44                 public ?setLanguageXML@FunctionCallTip@@QAEXPAVTiXmlElement@@@Z
.text$mn:00000E44 ?setLanguageXML@FunctionCallTip@@QAEXPAVTiXmlElement@@@Z proc near
.text$mn:00000E44
.text$mn:00000E44 var_8           = dword ptr -8
.text$mn:00000E44 var_4           = dword ptr -4
.text$mn:00000E44 arg_0           = dword ptr  8
.text$mn:00000E44
.text$mn:00000E44                 push    ebp
.text$mn:00000E45                 mov     ebp, esp
.text$mn:00000E47                 sub     esp, 8
.text$mn:00000E4A                 mov     [ebp+var_4], ecx
.text$mn:00000E4D                 mov     ecx, [ebp+var_4] ; this
.text$mn:00000E50                 call    ?isVisible@FunctionCallTip@@QAE_NXZ ; FunctionCallTip::isVisible(void)
.text$mn:00000E55                 movzx   eax, al
.text$mn:00000E58                 test    eax, eax
.text$mn:00000E5A                 jz      short loc_E64
.text$mn:00000E5C                 mov     ecx, [ebp+var_4] ; this
.text$mn:00000E5F                 call    ?close@FunctionCallTip@@QAEXXZ ; FunctionCallTip::close(void)
.text$mn:00000E64
.text$mn:00000E64 loc_E64:                                ; CODE XREF: FunctionCallTip::setLanguageXML(TiXmlElement *)+16j
.text$mn:00000E64                 mov     ecx, [ebp+var_4]
.text$mn:00000E67                 mov     edx, [ebp+arg_0]
.text$mn:00000E6A                 mov     [ecx+4], edx
.text$mn:00000E6D                 mov     ecx, [ebp+var_4] ; this
.text$mn:00000E70                 call    ?reset@FunctionCallTip@@AAEXXZ ; FunctionCallTip::reset(void)
.text$mn:00000E75                 mov     eax, [ebp+var_4]
.text$mn:00000E78                 cmp     dword ptr [eax+14h], 0
.text$mn:00000E7C                 jz      short loc_E93
.text$mn:00000E7E                 mov     ecx, [ebp+var_4]
.text$mn:00000E81                 mov     edx, [ecx+14h]
.text$mn:00000E84                 mov     [ebp+var_8], edx
.text$mn:00000E87                 mov     eax, [ebp+var_8]
.text$mn:00000E8A                 push    eax             ; void *
.text$mn:00000E8B                 call    ??_V@YAXPAX@Z   ; operator delete[](void *)
.text$mn:00000E90                 add     esp, 4
.text$mn:00000E93
.text$mn:00000E93 loc_E93:                                ; CODE XREF: FunctionCallTip::setLanguageXML(TiXmlElement *)+38j
.text$mn:00000E93                 mov     ecx, [ebp+var_4]
.text$mn:00000E96                 mov     dword ptr [ecx+14h], 0
.text$mn:00000E9D                 mov     esp, ebp
.text$mn:00000E9F                 pop     ebp
.text$mn:00000EA0                 retn    4
.text$mn:00000EA0 ?setLanguageXML@FunctionCallTip@@QAEXPAVTiXmlElement@@@Z endp
.text$mn:00000EA0
.text$mn:00000EA0 ; ---------------------------------------------------------------------------
.text$mn:00000EA3                 align 4
.text$mn:00000EA4
.text$mn:00000EA4 ; =============== S U B R O U T I N E =======================================
.text$mn:00000EA4
.text$mn:00000EA4 ; Attributes: bp-based frame
.text$mn:00000EA4
.text$mn:00000EA4 ; bool __thiscall FunctionCallTip::updateCalltip(FunctionCallTip *this, int, bool)
.text$mn:00000EA4                 public ?updateCalltip@FunctionCallTip@@QAE_NH_N@Z
.text$mn:00000EA4 ?updateCalltip@FunctionCallTip@@QAE_NH_N@Z proc near
.text$mn:00000EA4
.text$mn:00000EA4 var_4           = dword ptr -4
.text$mn:00000EA4 arg_0           = dword ptr  8
.text$mn:00000EA4 arg_4           = byte ptr  0Ch
.text$mn:00000EA4
.text$mn:00000EA4                 push    ebp
.text$mn:00000EA5                 mov     ebp, esp
.text$mn:00000EA7                 push    ecx
.text$mn:00000EA8                 mov     [ebp+var_4], ecx
.text$mn:00000EAB                 movzx   eax, [ebp+arg_4]
.text$mn:00000EAF                 test    eax, eax
.text$mn:00000EB1                 jnz     short loc_ED2
.text$mn:00000EB3                 mov     ecx, [ebp+var_4]
.text$mn:00000EB6                 movzx   edx, word ptr [ecx+54h]
.text$mn:00000EBA                 cmp     [ebp+arg_0], edx
.text$mn:00000EBD                 jz      short loc_ED2
.text$mn:00000EBF                 mov     ecx, [ebp+var_4] ; this
.text$mn:00000EC2                 call    ?isVisible@FunctionCallTip@@QAE_NXZ ; FunctionCallTip::isVisible(void)
.text$mn:00000EC7                 movzx   eax, al
.text$mn:00000ECA                 test    eax, eax
.text$mn:00000ECC                 jnz     short loc_ED2
.text$mn:00000ECE                 xor     al, al
.text$mn:00000ED0                 jmp     short loc_F10
.text$mn:00000ED2 ; ---------------------------------------------------------------------------
.text$mn:00000ED2
.text$mn:00000ED2 loc_ED2:                                ; CODE XREF: FunctionCallTip::updateCalltip(int,bool)+Dj
.text$mn:00000ED2                                         ; FunctionCallTip::updateCalltip(int,bool)+19j ...
.text$mn:00000ED2                 push    0               ; __int32
.text$mn:00000ED4                 push    0               ; unsigned int
.text$mn:00000ED6                 push    7D8h            ; unsigned int
.text$mn:00000EDB                 mov     ecx, [ebp+var_4]
.text$mn:00000EDE                 mov     ecx, [ecx]      ; this
.text$mn:00000EE0                 call    ?execute@ScintillaEditView@@QBEJIIJ@Z ; ScintillaEditView::execute(uint,uint,long)
.text$mn:00000EE5                 mov     edx, [ebp+var_4]
.text$mn:00000EE8                 mov     [edx+8], eax
.text$mn:00000EEB                 mov     ecx, [ebp+var_4] ; this
.text$mn:00000EEE                 call    ?getCursorFunction@FunctionCallTip@@AAE_NXZ ; FunctionCallTip::getCursorFunction(void)
.text$mn:00000EF3                 movzx   eax, al
.text$mn:00000EF6                 test    eax, eax
.text$mn:00000EF8                 jnz     short loc_F06
.text$mn:00000EFA                 mov     ecx, [ebp+var_4] ; this
.text$mn:00000EFD                 call    ?close@FunctionCallTip@@QAEXXZ ; FunctionCallTip::close(void)
.text$mn:00000F02                 xor     al, al
.text$mn:00000F04                 jmp     short loc_F10
.text$mn:00000F06 ; ---------------------------------------------------------------------------
.text$mn:00000F06
.text$mn:00000F06 loc_F06:                                ; CODE XREF: FunctionCallTip::updateCalltip(int,bool)+54j
.text$mn:00000F06                 mov     ecx, [ebp+var_4] ; this
.text$mn:00000F09                 call    ?showCalltip@FunctionCallTip@@AAEXXZ ; FunctionCallTip::showCalltip(void)
.text$mn:00000F0E                 mov     al, 1
.text$mn:00000F10
.text$mn:00000F10 loc_F10:                                ; CODE XREF: FunctionCallTip::updateCalltip(int,bool)+2Cj
.text$mn:00000F10                                         ; FunctionCallTip::updateCalltip(int,bool)+60j
.text$mn:00000F10                 mov     esp, ebp
.text$mn:00000F12                 pop     ebp
.text$mn:00000F13                 retn    8
.text$mn:00000F13 ?updateCalltip@FunctionCallTip@@QAE_NH_N@Z endp
.text$mn:00000F13
.text$mn:00000F13 ; ---------------------------------------------------------------------------
.text$mn:00000F16                 db 0Eh dup(0CCh)
.text$mn:00000F24
.text$mn:00000F24 ; =============== S U B R O U T I N E =======================================
.text$mn:00000F24
.text$mn:00000F24 ; Attributes: bp-based frame
.text$mn:00000F24
.text$mn:00000F24 ; void __thiscall FunctionCallTip::showNextOverload(FunctionCallTip *__hidden this)
.text$mn:00000F24                 public ?showNextOverload@FunctionCallTip@@QAEXXZ
.text$mn:00000F24 ?showNextOverload@FunctionCallTip@@QAEXXZ proc near
.text$mn:00000F24
.text$mn:00000F24 var_4           = dword ptr -4
.text$mn:00000F24
.text$mn:00000F24                 push    ebp
.text$mn:00000F25                 mov     ebp, esp
.text$mn:00000F27                 push    ecx
.text$mn:00000F28                 mov     [ebp+var_4], ecx
.text$mn:00000F2B                 mov     ecx, [ebp+var_4] ; this
.text$mn:00000F2E                 call    ?isVisible@FunctionCallTip@@QAE_NXZ ; FunctionCallTip::isVisible(void)
.text$mn:00000F33                 movzx   eax, al
.text$mn:00000F36                 test    eax, eax
.text$mn:00000F38                 jnz     short loc_F3C
.text$mn:00000F3A                 jmp     short loc_F5A
.text$mn:00000F3C ; ---------------------------------------------------------------------------
.text$mn:00000F3C
.text$mn:00000F3C loc_F3C:                                ; CODE XREF: FunctionCallTip::showNextOverload(void)+14j
.text$mn:00000F3C                 mov     ecx, [ebp+var_4]
.text$mn:00000F3F                 mov     eax, [ecx+4Ch]
.text$mn:00000F42                 add     eax, 1
.text$mn:00000F45                 mov     ecx, [ebp+var_4]
.text$mn:00000F48                 cdq
.text$mn:00000F49                 idiv    dword ptr [ecx+48h]
.text$mn:00000F4C                 mov     eax, [ebp+var_4]
.text$mn:00000F4F                 mov     [eax+4Ch], edx
.text$mn:00000F52                 mov     ecx, [ebp+var_4] ; this
.text$mn:00000F55                 call    ?showCalltip@FunctionCallTip@@AAEXXZ ; FunctionCallTip::showCalltip(void)
.text$mn:00000F5A
.text$mn:00000F5A loc_F5A:                                ; CODE XREF: FunctionCallTip::showNextOverload(void)+16j
.text$mn:00000F5A                 mov     esp, ebp
.text$mn:00000F5C                 pop     ebp
.text$mn:00000F5D                 retn
.text$mn:00000F5D ?showNextOverload@FunctionCallTip@@QAEXXZ endp
.text$mn:00000F5D
.text$mn:00000F5D ; ---------------------------------------------------------------------------
.text$mn:00000F5E                 db 6 dup(0CCh)
.text$mn:00000F64
.text$mn:00000F64 ; =============== S U B R O U T I N E =======================================
.text$mn:00000F64
.text$mn:00000F64 ; Attributes: bp-based frame
.text$mn:00000F64
.text$mn:00000F64 ; void __thiscall FunctionCallTip::showPrevOverload(FunctionCallTip *__hidden this)
.text$mn:00000F64                 public ?showPrevOverload@FunctionCallTip@@QAEXXZ
.text$mn:00000F64 ?showPrevOverload@FunctionCallTip@@QAEXXZ proc near
.text$mn:00000F64
.text$mn:00000F64 var_8           = dword ptr -8
.text$mn:00000F64 var_4           = dword ptr -4
.text$mn:00000F64
.text$mn:00000F64                 push    ebp
.text$mn:00000F65                 mov     ebp, esp
.text$mn:00000F67                 sub     esp, 8
.text$mn:00000F6A                 mov     [ebp+var_4], ecx
.text$mn:00000F6D                 mov     ecx, [ebp+var_4] ; this
.text$mn:00000F70                 call    ?isVisible@FunctionCallTip@@QAE_NXZ ; FunctionCallTip::isVisible(void)
.text$mn:00000F75                 movzx   eax, al
.text$mn:00000F78                 test    eax, eax
.text$mn:00000F7A                 jnz     short loc_F7E
.text$mn:00000F7C                 jmp     short loc_FB2
.text$mn:00000F7E ; ---------------------------------------------------------------------------
.text$mn:00000F7E
.text$mn:00000F7E loc_F7E:                                ; CODE XREF: FunctionCallTip::showPrevOverload(void)+16j
.text$mn:00000F7E                 mov     ecx, [ebp+var_4]
.text$mn:00000F81                 cmp     dword ptr [ecx+4Ch], 0
.text$mn:00000F85                 jle     short loc_F95
.text$mn:00000F87                 mov     edx, [ebp+var_4]
.text$mn:00000F8A                 mov     eax, [edx+4Ch]
.text$mn:00000F8D                 sub     eax, 1
.text$mn:00000F90                 mov     [ebp+var_8], eax
.text$mn:00000F93                 jmp     short loc_FA1
.text$mn:00000F95 ; ---------------------------------------------------------------------------
.text$mn:00000F95
.text$mn:00000F95 loc_F95:                                ; CODE XREF: FunctionCallTip::showPrevOverload(void)+21j
.text$mn:00000F95                 mov     ecx, [ebp+var_4]
.text$mn:00000F98                 mov     edx, [ecx+48h]
.text$mn:00000F9B                 sub     edx, 1
.text$mn:00000F9E                 mov     [ebp+var_8], edx
.text$mn:00000FA1
.text$mn:00000FA1 loc_FA1:                                ; CODE XREF: FunctionCallTip::showPrevOverload(void)+2Fj
.text$mn:00000FA1                 mov     eax, [ebp+var_4]
.text$mn:00000FA4                 mov     ecx, [ebp+var_8]
.text$mn:00000FA7                 mov     [eax+4Ch], ecx
.text$mn:00000FAA                 mov     ecx, [ebp+var_4] ; this
.text$mn:00000FAD                 call    ?showCalltip@FunctionCallTip@@AAEXXZ ; FunctionCallTip::showCalltip(void)
.text$mn:00000FB2
.text$mn:00000FB2 loc_FB2:                                ; CODE XREF: FunctionCallTip::showPrevOverload(void)+18j
.text$mn:00000FB2                 mov     esp, ebp
.text$mn:00000FB4                 pop     ebp
.text$mn:00000FB5                 retn
.text$mn:00000FB5 ?showPrevOverload@FunctionCallTip@@QAEXXZ endp
.text$mn:00000FB5
.text$mn:00000FB5 ; ---------------------------------------------------------------------------
.text$mn:00000FB6                 db 0Eh dup(0CCh)
.text$mn:00000FC4
.text$mn:00000FC4 ; =============== S U B R O U T I N E =======================================
.text$mn:00000FC4
.text$mn:00000FC4 ; Attributes: bp-based frame
.text$mn:00000FC4
.text$mn:00000FC4 ; void __thiscall FunctionCallTip::close(FunctionCallTip *__hidden this)
.text$mn:00000FC4                 public ?close@FunctionCallTip@@QAEXXZ
.text$mn:00000FC4 ?close@FunctionCallTip@@QAEXXZ proc near
.text$mn:00000FC4                                         ; CODE XREF: FunctionCallTip::setLanguageXML(TiXmlElement *)+1Bp
.text$mn:00000FC4                                         ; FunctionCallTip::updateCalltip(int,bool)+59p
.text$mn:00000FC4
.text$mn:00000FC4 var_4           = dword ptr -4
.text$mn:00000FC4
.text$mn:00000FC4                 push    ebp
.text$mn:00000FC5                 mov     ebp, esp
.text$mn:00000FC7                 push    ecx
.text$mn:00000FC8                 mov     [ebp+var_4], ecx
.text$mn:00000FCB                 mov     ecx, [ebp+var_4] ; this
.text$mn:00000FCE                 call    ?isVisible@FunctionCallTip@@QAE_NXZ ; FunctionCallTip::isVisible(void)
.text$mn:00000FD3                 movzx   eax, al
.text$mn:00000FD6                 test    eax, eax
.text$mn:00000FD8                 jz      short loc_FE5
.text$mn:00000FDA                 mov     ecx, [ebp+var_4]
.text$mn:00000FDD                 movzx   edx, byte ptr [ecx+79h]
.text$mn:00000FE1                 test    edx, edx
.text$mn:00000FE3                 jnz     short loc_FE7
.text$mn:00000FE5
.text$mn:00000FE5 loc_FE5:                                ; CODE XREF: FunctionCallTip::close(void)+14j
.text$mn:00000FE5                 jmp     short loc_100B
.text$mn:00000FE7 ; ---------------------------------------------------------------------------
.text$mn:00000FE7
.text$mn:00000FE7 loc_FE7:                                ; CODE XREF: FunctionCallTip::close(void)+1Fj
.text$mn:00000FE7                 push    0               ; __int32
.text$mn:00000FE9                 push    0               ; unsigned int
.text$mn:00000FEB                 push    899h            ; unsigned int
.text$mn:00000FF0                 mov     eax, [ebp+var_4]
.text$mn:00000FF3                 mov     ecx, [eax]      ; this
.text$mn:00000FF5                 call    ?execute@ScintillaEditView@@QBEJIIJ@Z ; ScintillaEditView::execute(uint,uint,long)
.text$mn:00000FFA                 mov     ecx, [ebp+var_4]
.text$mn:00000FFD                 mov     byte ptr [ecx+79h], 0
.text$mn:00001001                 mov     edx, [ebp+var_4]
.text$mn:00001004                 mov     dword ptr [edx+4Ch], 0
.text$mn:0000100B
.text$mn:0000100B loc_100B:                               ; CODE XREF: FunctionCallTip::close(void):loc_FE5j
.text$mn:0000100B                 mov     esp, ebp
.text$mn:0000100D                 pop     ebp
.text$mn:0000100E                 retn
.text$mn:0000100E ?close@FunctionCallTip@@QAEXXZ endp
.text$mn:0000100E
.text$mn:0000100E ; ---------------------------------------------------------------------------
.text$mn:0000100F                 db 5 dup(0CCh)
.text$mn:00001014
.text$mn:00001014 ; =============== S U B R O U T I N E =======================================
.text$mn:00001014
.text$mn:00001014 ; Attributes: bp-based frame
.text$mn:00001014
.text$mn:00001014 ; bool __thiscall FunctionCallTip::getCursorFunction(FunctionCallTip *__hidden this)
.text$mn:00001014                 public ?getCursorFunction@FunctionCallTip@@AAE_NXZ
.text$mn:00001014 ?getCursorFunction@FunctionCallTip@@AAE_NXZ proc near
.text$mn:00001014                                         ; CODE XREF: FunctionCallTip::updateCalltip(int,bool)+4Ap
.text$mn:00001014
.text$mn:00001014 var_2E8         = byte ptr -2E8h
.text$mn:00001014 var_2D8         = byte ptr -2D8h
.text$mn:00001014 var_2C8         = byte ptr -2C8h
.text$mn:00001014 var_2BC         = byte ptr -2BCh
.text$mn:00001014 var_2B0         = dword ptr -2B0h
.text$mn:00001014 var_2AC         = dword ptr -2ACh
.text$mn:00001014 var_2A8         = dword ptr -2A8h
.text$mn:00001014 var_2A4         = dword ptr -2A4h
.text$mn:00001014 var_2A0         = dword ptr -2A0h
.text$mn:00001014 var_29C         = byte ptr -29Ch
.text$mn:00001014 var_28C         = dword ptr -28Ch
.text$mn:00001014 var_288         = dword ptr -288h
.text$mn:00001014 var_284         = dword ptr -284h
.text$mn:00001014 var_280         = dword ptr -280h
.text$mn:00001014 var_27C         = dword ptr -27Ch
.text$mn:00001014 var_278         = byte ptr -278h
.text$mn:00001014 var_268         = dword ptr -268h
.text$mn:00001014 var_264         = dword ptr -264h
.text$mn:00001014 var_260         = dword ptr -260h
.text$mn:00001014 Str2            = dword ptr -25Ch
.text$mn:00001014 var_258         = dword ptr -258h
.text$mn:00001014 var_254         = dword ptr -254h
.text$mn:00001014 var_250         = dword ptr -250h
.text$mn:00001014 var_24C         = dword ptr -24Ch
.text$mn:00001014 var_248         = dword ptr -248h
.text$mn:00001014 var_244         = dword ptr -244h
.text$mn:00001014 var_240         = dword ptr -240h
.text$mn:00001014 var_23C         = dword ptr -23Ch
.text$mn:00001014 var_235         = byte ptr -235h
.text$mn:00001014 var_234         = dword ptr -234h
.text$mn:00001014 var_230         = dword ptr -230h
.text$mn:00001014 var_22C         = dword ptr -22Ch
.text$mn:00001014 var_228         = dword ptr -228h
.text$mn:00001014 var_224         = dword ptr -224h
.text$mn:00001014 var_220         = dword ptr -220h
.text$mn:00001014 var_21A         = byte ptr -21Ah
.text$mn:00001014 var_219         = byte ptr -219h
.text$mn:00001014 var_218         = word ptr -218h
.text$mn:00001014 var_214         = dword ptr -214h
.text$mn:00001014 var_210         = word ptr -210h
.text$mn:00001014 Dst             = byte ptr -20Eh
.text$mn:00001014 var_10          = dword ptr -10h
.text$mn:00001014 var_C           = dword ptr -0Ch
.text$mn:00001014 var_4           = dword ptr -4
.text$mn:00001014
.text$mn:00001014                 push    ebp
.text$mn:00001015                 mov     ebp, esp
.text$mn:00001017                 push    0FFFFFFFFh
.text$mn:00001019                 push    offset __ehhandler$?getCursorFunction@FunctionCallTip@@AAE_NXZ
.text$mn:0000101E                 mov     eax, large fs:0
.text$mn:00001024                 push    eax
.text$mn:00001025                 sub     esp, 2DCh
.text$mn:0000102B                 mov     eax, dword ptr ds:___security_cookie
.text$mn:00001030                 xor     eax, ebp
.text$mn:00001032                 mov     [ebp+var_10], eax
.text$mn:00001035                 push    eax
.text$mn:00001036                 lea     eax, [ebp+var_C]
.text$mn:00001039                 mov     large fs:0, eax
.text$mn:0000103F                 mov     [ebp+var_214], ecx
.text$mn:00001045                 push    0               ; __int32
.text$mn:00001047                 mov     eax, [ebp+var_214]
.text$mn:0000104D                 mov     ecx, [eax+8]
.text$mn:00001050                 push    ecx             ; unsigned int
.text$mn:00001051                 push    876h            ; unsigned int
.text$mn:00001056                 mov     edx, [ebp+var_214]
.text$mn:0000105C                 mov     ecx, [edx]      ; this
.text$mn:0000105E                 call    ?execute@ScintillaEditView@@QBEJIIJ@Z ; ScintillaEditView::execute(uint,uint,long)
.text$mn:00001063                 mov     [ebp+var_248], eax
.text$mn:00001069                 push    0               ; __int32
.text$mn:0000106B                 mov     eax, [ebp+var_248]
.text$mn:00001071                 push    eax             ; unsigned int
.text$mn:00001072                 push    877h            ; unsigned int
.text$mn:00001077                 mov     ecx, [ebp+var_214]
.text$mn:0000107D                 mov     ecx, [ecx]      ; this
.text$mn:0000107F                 call    ?execute@ScintillaEditView@@QBEJIIJ@Z ; ScintillaEditView::execute(uint,uint,long)
.text$mn:00001084                 mov     [ebp+var_268], eax
.text$mn:0000108A                 push    0               ; __int32
.text$mn:0000108C                 mov     edx, [ebp+var_248]
.text$mn:00001092                 push    edx             ; unsigned int
.text$mn:00001093                 push    858h            ; unsigned int
.text$mn:00001098                 mov     eax, [ebp+var_214]
.text$mn:0000109E                 mov     ecx, [eax]      ; this
.text$mn:000010A0                 call    ?execute@ScintillaEditView@@QBEJIIJ@Z ; ScintillaEditView::execute(uint,uint,long)
.text$mn:000010A5                 mov     [ebp+var_28C], eax
.text$mn:000010AB                 mov     ecx, [ebp+var_28C]
.text$mn:000010B1                 sub     ecx, [ebp+var_268]
.text$mn:000010B7                 add     ecx, 3
.text$mn:000010BA                 mov     [ebp+var_264], ecx
.text$mn:000010C0                 mov     edx, [ebp+var_214]
.text$mn:000010C6                 mov     eax, [edx+8]
.text$mn:000010C9                 sub     eax, [ebp+var_268]
.text$mn:000010CF                 mov     [ebp+var_24C], eax
.text$mn:000010D5                 mov     [ebp+var_2B0], 100h
.text$mn:000010DF                 cmp     [ebp+var_24C], 2
.text$mn:000010E6                 jl      short loc_10F4
.text$mn:000010E8                 cmp     [ebp+var_264], 100h
.text$mn:000010F2                 jl      short loc_1106
.text$mn:000010F4
.text$mn:000010F4 loc_10F4:                               ; CODE XREF: FunctionCallTip::getCursorFunction(void)+D2j
.text$mn:000010F4                 mov     ecx, [ebp+var_214] ; this
.text$mn:000010FA                 call    ?reset@FunctionCallTip@@AAEXXZ ; FunctionCallTip::reset(void)
.text$mn:000010FF                 xor     al, al
.text$mn:00001101                 jmp     loc_1834
.text$mn:00001106 ; ---------------------------------------------------------------------------
.text$mn:00001106
.text$mn:00001106 loc_1106:                               ; CODE XREF: FunctionCallTip::getCursorFunction(void)+DEj
.text$mn:00001106                 mov     cx, ds:$SG152767
.text$mn:0000110D                 mov     [ebp+var_210], cx
.text$mn:00001114                 push    1FEh            ; Size
.text$mn:00001119                 push    0               ; Val
.text$mn:0000111B                 lea     edx, [ebp+Dst]
.text$mn:00001121                 push    edx             ; Dst
.text$mn:00001122                 call    _memset
.text$mn:00001127                 add     esp, 0Ch
.text$mn:0000112A                 mov     eax, [ebp+var_264]
.text$mn:00001130                 push    eax             ; int
.text$mn:00001131                 lea     ecx, [ebp+var_210]
.text$mn:00001137                 push    ecx             ; wchar_t *
.text$mn:00001138                 mov     edx, [ebp+var_248]
.text$mn:0000113E                 push    edx             ; int
.text$mn:0000113F                 mov     eax, [ebp+var_214]
.text$mn:00001145                 mov     ecx, [eax]      ; this
.text$mn:00001147                 call    ?getLine@ScintillaEditView@@QAEXHPA_WH@Z ; ScintillaEditView::getLine(int,wchar_t *,int)
.text$mn:0000114C                 lea     ecx, [ebp+var_29C]
.text$mn:00001152                 call    ??0?$vector@UToken@@V?$allocator@UToken@@@std@@@std@@QAE@XZ ; std::vector<Token,std::allocator<Token>>::vector<Token,std::allocator<Token>>(void)
.text$mn:00001157                 mov     [ebp+var_4], 0
.text$mn:0000115E                 mov     [ebp+var_23C], 0
.text$mn:00001168                 mov     [ebp+var_220], 0
.text$mn:00001172                 jmp     short loc_1183
.text$mn:00001174 ; ---------------------------------------------------------------------------
.text$mn:00001174
.text$mn:00001174 loc_1174:                               ; CODE XREF: FunctionCallTip::getCursorFunction(void):loc_1318j
.text$mn:00001174                 mov     ecx, [ebp+var_220]
.text$mn:0000117A                 add     ecx, 1
.text$mn:0000117D                 mov     [ebp+var_220], ecx
.text$mn:00001183
.text$mn:00001183 loc_1183:                               ; CODE XREF: FunctionCallTip::getCursorFunction(void)+15Ej
.text$mn:00001183                 mov     edx, [ebp+var_220]
.text$mn:00001189                 cmp     edx, [ebp+var_24C]
.text$mn:0000118F                 jge     loc_131D
.text$mn:00001195                 mov     eax, [ebp+var_220]
.text$mn:0000119B                 mov     cx, [ebp+eax*2+var_210]
.text$mn:000011A3                 mov     [ebp+var_218], cx
.text$mn:000011AA                 movzx   edx, [ebp+var_218]
.text$mn:000011B1                 push    edx             ; wchar_t
.text$mn:000011B2                 mov     ecx, [ebp+var_214] ; this
.text$mn:000011B8                 call    ?isBasicWordChar@FunctionCallTip@@ABE_N_W@Z ; FunctionCallTip::isBasicWordChar(wchar_t)
.text$mn:000011BD                 movzx   eax, al
.text$mn:000011C0                 test    eax, eax
.text$mn:000011C2                 jnz     short loc_11E2
.text$mn:000011C4                 movzx   ecx, [ebp+var_218]
.text$mn:000011CB                 push    ecx             ; wchar_t
.text$mn:000011CC                 mov     ecx, [ebp+var_214] ; this
.text$mn:000011D2                 call    ?isAdditionalWordChar@FunctionCallTip@@ABE_N_W@Z ; FunctionCallTip::isAdditionalWordChar(wchar_t)
.text$mn:000011D7                 movzx   edx, al
.text$mn:000011DA                 test    edx, edx
.text$mn:000011DC                 jz      loc_12AE
.text$mn:000011E2
.text$mn:000011E2 loc_11E2:                               ; CODE XREF: FunctionCallTip::getCursorFunction(void)+1AEj
.text$mn:000011E2                 mov     [ebp+var_23C], 0
.text$mn:000011EC                 mov     eax, [ebp+var_220]
.text$mn:000011F2                 lea     ecx, [ebp+eax*2+var_210]
.text$mn:000011F9                 mov     [ebp+var_288], ecx
.text$mn:000011FF
.text$mn:000011FF loc_11FF:                               ; CODE XREF: FunctionCallTip::getCursorFunction(void)+260j
.text$mn:000011FF                 movzx   edx, [ebp+var_218]
.text$mn:00001206                 push    edx             ; wchar_t
.text$mn:00001207                 mov     ecx, [ebp+var_214] ; this
.text$mn:0000120D                 call    ?isBasicWordChar@FunctionCallTip@@ABE_N_W@Z ; FunctionCallTip::isBasicWordChar(wchar_t)
.text$mn:00001212                 movzx   eax, al
.text$mn:00001215                 test    eax, eax
.text$mn:00001217                 jnz     short loc_1233
.text$mn:00001219                 movzx   ecx, [ebp+var_218]
.text$mn:00001220                 push    ecx             ; wchar_t
.text$mn:00001221                 mov     ecx, [ebp+var_214] ; this
.text$mn:00001227                 call    ?isAdditionalWordChar@FunctionCallTip@@ABE_N_W@Z ; FunctionCallTip::isAdditionalWordChar(wchar_t)
.text$mn:0000122C                 movzx   edx, al
.text$mn:0000122F                 test    edx, edx
.text$mn:00001231                 jz      short loc_1276
.text$mn:00001233
.text$mn:00001233 loc_1233:                               ; CODE XREF: FunctionCallTip::getCursorFunction(void)+203j
.text$mn:00001233                 mov     eax, [ebp+var_220]
.text$mn:00001239                 cmp     eax, [ebp+var_24C]
.text$mn:0000123F                 jge     short loc_1276
.text$mn:00001241                 mov     ecx, [ebp+var_23C]
.text$mn:00001247                 add     ecx, 1
.text$mn:0000124A                 mov     [ebp+var_23C], ecx
.text$mn:00001250                 mov     edx, [ebp+var_220]
.text$mn:00001256                 add     edx, 1
.text$mn:00001259                 mov     [ebp+var_220], edx
.text$mn:0000125F                 mov     eax, [ebp+var_220]
.text$mn:00001265                 mov     cx, [ebp+eax*2+var_210]
.text$mn:0000126D                 mov     [ebp+var_218], cx
.text$mn:00001274                 jmp     short loc_11FF
.text$mn:00001276 ; ---------------------------------------------------------------------------
.text$mn:00001276
.text$mn:00001276 loc_1276:                               ; CODE XREF: FunctionCallTip::getCursorFunction(void)+21Dj
.text$mn:00001276                                         ; FunctionCallTip::getCursorFunction(void)+22Bj
.text$mn:00001276                 push    1               ; bool
.text$mn:00001278                 mov     edx, [ebp+var_23C]
.text$mn:0000127E                 push    edx             ; int
.text$mn:0000127F                 mov     eax, [ebp+var_288]
.text$mn:00001285                 push    eax             ; wchar_t *
.text$mn:00001286                 lea     ecx, [ebp+var_2BC] ; this
.text$mn:0000128C                 call    ??0Token@@QAE@PA_WH_N@Z ; Token::Token(wchar_t *,int,bool)
.text$mn:00001291                 push    eax
.text$mn:00001292                 lea     ecx, [ebp+var_29C]
.text$mn:00001298                 call    ?push_back@?$vector@UToken@@V?$allocator@UToken@@@std@@@std@@QAEX$$QAUToken@@@Z ; std::vector<Token,std::allocator<Token>>::push_back(Token &&)
.text$mn:0000129D                 mov     ecx, [ebp+var_220]
.text$mn:000012A3                 sub     ecx, 1
.text$mn:000012A6                 mov     [ebp+var_220], ecx
.text$mn:000012AC                 jmp     short loc_1318
.text$mn:000012AE ; ---------------------------------------------------------------------------
.text$mn:000012AE
.text$mn:000012AE loc_12AE:                               ; CODE XREF: FunctionCallTip::getCursorFunction(void)+1C8j
.text$mn:000012AE                 movzx   edx, [ebp+var_218]
.text$mn:000012B5                 cmp     edx, 20h ; ' '
.text$mn:000012B8                 jz      short loc_12DE
.text$mn:000012BA                 movzx   eax, [ebp+var_218]
.text$mn:000012C1                 cmp     eax, 9
.text$mn:000012C4                 jz      short loc_12DE
.text$mn:000012C6                 movzx   ecx, [ebp+var_218]
.text$mn:000012CD                 cmp     ecx, 0Ah
.text$mn:000012D0                 jz      short loc_12DE
.text$mn:000012D2                 movzx   edx, [ebp+var_218]
.text$mn:000012D9                 cmp     edx, 0Dh
.text$mn:000012DC                 jnz     short loc_12E0
.text$mn:000012DE
.text$mn:000012DE loc_12DE:                               ; CODE XREF: FunctionCallTip::getCursorFunction(void)+2A4j
.text$mn:000012DE                                         ; FunctionCallTip::getCursorFunction(void)+2B0j ...
.text$mn:000012DE                 jmp     short loc_1318
.text$mn:000012E0 ; ---------------------------------------------------------------------------
.text$mn:000012E0
.text$mn:000012E0 loc_12E0:                               ; CODE XREF: FunctionCallTip::getCursorFunction(void)+2C8j
.text$mn:000012E0                 mov     [ebp+var_23C], 1
.text$mn:000012EA                 push    0               ; bool
.text$mn:000012EC                 mov     eax, [ebp+var_23C]
.text$mn:000012F2                 push    eax             ; int
.text$mn:000012F3                 mov     ecx, [ebp+var_220]
.text$mn:000012F9                 lea     edx, [ebp+ecx*2+var_210]
.text$mn:00001300                 push    edx             ; wchar_t *
.text$mn:00001301                 lea     ecx, [ebp+var_2C8] ; this
.text$mn:00001307                 call    ??0Token@@QAE@PA_WH_N@Z ; Token::Token(wchar_t *,int,bool)
.text$mn:0000130C                 push    eax
.text$mn:0000130D                 lea     ecx, [ebp+var_29C]
.text$mn:00001313                 call    ?push_back@?$vector@UToken@@V?$allocator@UToken@@@std@@@std@@QAEX$$QAUToken@@@Z ; std::vector<Token,std::allocator<Token>>::push_back(Token &&)
.text$mn:00001318
.text$mn:00001318 loc_1318:                               ; CODE XREF: FunctionCallTip::getCursorFunction(void)+298j
.text$mn:00001318                                         ; FunctionCallTip::getCursorFunction(void):loc_12DEj
.text$mn:00001318                 jmp     loc_1174
.text$mn:0000131D ; ---------------------------------------------------------------------------
.text$mn:0000131D
.text$mn:0000131D loc_131D:                               ; CODE XREF: FunctionCallTip::getCursorFunction(void)+17Bj
.text$mn:0000131D                 lea     ecx, [ebp+var_29C]
.text$mn:00001323                 call    ?size@?$vector@UToken@@V?$allocator@UToken@@@std@@@std@@QBEIXZ ; std::vector<Token,std::allocator<Token>>::size(void)
.text$mn:00001328                 mov     [ebp+var_280], eax
.text$mn:0000132E                 lea     ecx, [ebp+var_278]
.text$mn:00001334                 call    ??0?$vector@UFunctionValues@@V?$allocator@UFunctionValues@@@std@@@std@@QAE@XZ ; std::vector<FunctionValues,std::allocator<FunctionValues>>::vector<FunctionValues,std::allocator<FunctionValues>>(void)
.text$mn:00001339                 mov     byte ptr [ebp+var_4], 1
.text$mn:0000133D                 lea     ecx, [ebp+var_230] ; this
.text$mn:00001343                 call    ??0FunctionValues@@QAE@XZ ; FunctionValues::FunctionValues(void)
.text$mn:00001348                 lea     ecx, [ebp+var_2AC] ; this
.text$mn:0000134E                 call    ??0FunctionValues@@QAE@XZ ; FunctionValues::FunctionValues(void)
.text$mn:00001353                 mov     [ebp+var_240], 0
.text$mn:0000135D                 mov     [ebp+var_234], 0
.text$mn:00001367                 jmp     short loc_1378
.text$mn:00001369 ; ---------------------------------------------------------------------------
.text$mn:00001369
.text$mn:00001369 loc_1369:                               ; CODE XREF: FunctionCallTip::getCursorFunction(void):loc_15D7j
.text$mn:00001369                 mov     eax, [ebp+var_234]
.text$mn:0000136F                 add     eax, 1
.text$mn:00001372                 mov     [ebp+var_234], eax
.text$mn:00001378
.text$mn:00001378 loc_1378:                               ; CODE XREF: FunctionCallTip::getCursorFunction(void)+353j
.text$mn:00001378                 mov     ecx, [ebp+var_234]
.text$mn:0000137E                 cmp     ecx, [ebp+var_280]
.text$mn:00001384                 jnb     loc_15DC
.text$mn:0000138A                 mov     edx, [ebp+var_234]
.text$mn:00001390                 push    edx
.text$mn:00001391                 lea     ecx, [ebp+var_29C]
.text$mn:00001397                 call    ?at@?$vector@UToken@@V?$allocator@UToken@@@std@@@std@@QAEAAUToken@@I@Z ; std::vector<Token,std::allocator<Token>>::at(uint)
.text$mn:0000139C                 mov     [ebp+var_244], eax
.text$mn:000013A2                 mov     eax, [ebp+var_244]
.text$mn:000013A8                 movzx   ecx, byte ptr [eax+8]
.text$mn:000013AC                 test    ecx, ecx
.text$mn:000013AE                 jz      short loc_13C1
.text$mn:000013B0                 mov     edx, [ebp+var_234]
.text$mn:000013B6                 mov     [ebp+var_230], edx
.text$mn:000013BC                 jmp     loc_15D7
.text$mn:000013C1 ; ---------------------------------------------------------------------------
.text$mn:000013C1
.text$mn:000013C1 loc_13C1:                               ; CODE XREF: FunctionCallTip::getCursorFunction(void)+39Aj
.text$mn:000013C1                 mov     eax, 2
.text$mn:000013C6                 imul    ecx, eax, 0
.text$mn:000013C9                 mov     edx, [ebp+var_244]
.text$mn:000013CF                 mov     eax, [edx]
.text$mn:000013D1                 movzx   ecx, word ptr [eax+ecx]
.text$mn:000013D5                 mov     edx, [ebp+var_214]
.text$mn:000013DB                 movzx   eax, word ptr [edx+54h]
.text$mn:000013DF                 cmp     ecx, eax
.text$mn:000013E1                 jnz     loc_1485
.text$mn:000013E7                 mov     ecx, [ebp+var_240]
.text$mn:000013ED                 add     ecx, 1
.text$mn:000013F0                 mov     [ebp+var_240], ecx
.text$mn:000013F6                 mov     edx, [ebp+var_230]
.text$mn:000013FC                 mov     [ebp+var_2AC], edx
.text$mn:00001402                 mov     eax, [ebp+var_22C]
.text$mn:00001408                 mov     [ebp+var_2A8], eax
.text$mn:0000140E                 mov     ecx, [ebp+var_228]
.text$mn:00001414                 mov     [ebp+var_2A4], ecx
.text$mn:0000141A                 mov     edx, [ebp+var_224]
.text$mn:00001420                 mov     [ebp+var_2A0], edx
.text$mn:00001426                 lea     eax, [ebp+var_2AC]
.text$mn:0000142C                 push    eax
.text$mn:0000142D                 lea     ecx, [ebp+var_278]
.text$mn:00001433                 call    ?push_back@?$vector@UFunctionValues@@V?$allocator@UFunctionValues@@@std@@@std@@QAEXABUFunctionValues@@@Z ; std::vector<FunctionValues,std::allocator<FunctionValues>>::push_back(FunctionValues const &)
.text$mn:00001438                 mov     ecx, [ebp+var_240]
.text$mn:0000143E                 mov     [ebp+var_224], ecx
.text$mn:00001444                 cmp     [ebp+var_234], 0
.text$mn:0000144B                 jbe     short loc_1476
.text$mn:0000144D                 mov     edx, [ebp+var_234]
.text$mn:00001453                 sub     edx, 1
.text$mn:00001456                 cmp     [ebp+var_230], edx
.text$mn:0000145C                 jnz     short loc_1476
.text$mn:0000145E                 mov     eax, [ebp+var_230]
.text$mn:00001464                 mov     [ebp+var_22C], eax
.text$mn:0000146A                 mov     [ebp+var_228], 0
.text$mn:00001474                 jmp     short loc_1480
.text$mn:00001476 ; ---------------------------------------------------------------------------
.text$mn:00001476
.text$mn:00001476 loc_1476:                               ; CODE XREF: FunctionCallTip::getCursorFunction(void)+437j
.text$mn:00001476                                         ; FunctionCallTip::getCursorFunction(void)+448j
.text$mn:00001476                 mov     [ebp+var_22C], 0FFFFFFFFh
.text$mn:00001480
.text$mn:00001480 loc_1480:                               ; CODE XREF: FunctionCallTip::getCursorFunction(void)+460j
.text$mn:00001480                 jmp     loc_15D7
.text$mn:00001485 ; ---------------------------------------------------------------------------
.text$mn:00001485
.text$mn:00001485 loc_1485:                               ; CODE XREF: FunctionCallTip::getCursorFunction(void)+3CDj
.text$mn:00001485                 mov     ecx, 2
.text$mn:0000148A                 imul    edx, ecx, 0
.text$mn:0000148D                 mov     eax, [ebp+var_244]
.text$mn:00001493                 mov     ecx, [eax]
.text$mn:00001495                 movzx   edx, word ptr [ecx+edx]
.text$mn:00001499                 mov     eax, [ebp+var_214]
.text$mn:0000149F                 movzx   ecx, word ptr [eax+58h]
.text$mn:000014A3                 cmp     edx, ecx
.text$mn:000014A5                 jnz     short loc_14C4
.text$mn:000014A7                 cmp     [ebp+var_22C], 0FFFFFFFFh
.text$mn:000014AE                 jle     short loc_14C4
.text$mn:000014B0                 mov     edx, [ebp+var_228]
.text$mn:000014B6                 add     edx, 1
.text$mn:000014B9                 mov     [ebp+var_228], edx
.text$mn:000014BF                 jmp     loc_15D7
.text$mn:000014C4 ; ---------------------------------------------------------------------------
.text$mn:000014C4
.text$mn:000014C4 loc_14C4:                               ; CODE XREF: FunctionCallTip::getCursorFunction(void)+491j
.text$mn:000014C4                                         ; FunctionCallTip::getCursorFunction(void)+49Aj
.text$mn:000014C4                 mov     eax, 2
.text$mn:000014C9                 imul    ecx, eax, 0
.text$mn:000014CC                 mov     edx, [ebp+var_244]
.text$mn:000014D2                 mov     eax, [edx]
.text$mn:000014D4                 movzx   ecx, word ptr [eax+ecx]
.text$mn:000014D8                 mov     edx, [ebp+var_214]
.text$mn:000014DE                 movzx   eax, word ptr [edx+56h]
.text$mn:000014E2                 cmp     ecx, eax
.text$mn:000014E4                 jnz     loc_157C
.text$mn:000014EA                 cmp     [ebp+var_240], 0
.text$mn:000014F1                 jz      short loc_1502
.text$mn:000014F3                 mov     ecx, [ebp+var_240]
.text$mn:000014F9                 sub     ecx, 1
.text$mn:000014FC                 mov     [ebp+var_240], ecx
.text$mn:00001502
.text$mn:00001502 loc_1502:                               ; CODE XREF: FunctionCallTip::getCursorFunction(void)+4DDj
.text$mn:00001502                 lea     ecx, [ebp+var_278]
.text$mn:00001508                 call    ?size@?$vector@UFunctionValues@@V?$allocator@UFunctionValues@@@std@@@std@@QBEIXZ ; std::vector<FunctionValues,std::allocator<FunctionValues>>::size(void)
.text$mn:0000150D                 test    eax, eax
.text$mn:0000150F                 jbe     short loc_154C
.text$mn:00001511                 lea     ecx, [ebp+var_278]
.text$mn:00001517                 call    ?back@?$vector@UFunctionValues@@V?$allocator@UFunctionValues@@@std@@@std@@QAEAAUFunctionValues@@XZ ; std::vector<FunctionValues,std::allocator<FunctionValues>>::back(void)
.text$mn:0000151C                 mov     edx, [eax]
.text$mn:0000151E                 mov     [ebp+var_230], edx
.text$mn:00001524                 mov     ecx, [eax+4]
.text$mn:00001527                 mov     [ebp+var_22C], ecx
.text$mn:0000152D                 mov     edx, [eax+8]
.text$mn:00001530                 mov     [ebp+var_228], edx
.text$mn:00001536                 mov     eax, [eax+0Ch]
.text$mn:00001539                 mov     [ebp+var_224], eax
.text$mn:0000153F                 lea     ecx, [ebp+var_278]
.text$mn:00001545                 call    ?pop_back@?$vector@UFunctionValues@@V?$allocator@UFunctionValues@@@std@@@std@@QAEXXZ ; std::vector<FunctionValues,std::allocator<FunctionValues>>::pop_back(void)
.text$mn:0000154A                 jmp     short loc_157A
.text$mn:0000154C ; ---------------------------------------------------------------------------
.text$mn:0000154C
.text$mn:0000154C loc_154C:                               ; CODE XREF: FunctionCallTip::getCursorFunction(void)+4FBj
.text$mn:0000154C                 lea     ecx, [ebp+var_2E8] ; this
.text$mn:00001552                 call    ??0FunctionValues@@QAE@XZ ; FunctionValues::FunctionValues(void)
.text$mn:00001557                 mov     ecx, [eax]
.text$mn:00001559                 mov     [ebp+var_230], ecx
.text$mn:0000155F                 mov     edx, [eax+4]
.text$mn:00001562                 mov     [ebp+var_22C], edx
.text$mn:00001568                 mov     ecx, [eax+8]
.text$mn:0000156B                 mov     [ebp+var_228], ecx
.text$mn:00001571                 mov     edx, [eax+0Ch]
.text$mn:00001574                 mov     [ebp+var_224], edx
.text$mn:0000157A
.text$mn:0000157A loc_157A:                               ; CODE XREF: FunctionCallTip::getCursorFunction(void)+536j
.text$mn:0000157A                 jmp     short loc_15D7
.text$mn:0000157C ; ---------------------------------------------------------------------------
.text$mn:0000157C
.text$mn:0000157C loc_157C:                               ; CODE XREF: FunctionCallTip::getCursorFunction(void)+4D0j
.text$mn:0000157C                 mov     eax, 2
.text$mn:00001581                 imul    ecx, eax, 0
.text$mn:00001584                 mov     edx, [ebp+var_244]
.text$mn:0000158A                 mov     eax, [edx]
.text$mn:0000158C                 movzx   ecx, word ptr [eax+ecx]
.text$mn:00001590                 mov     edx, [ebp+var_214]
.text$mn:00001596                 movzx   eax, word ptr [edx+5Ah]
.text$mn:0000159A                 cmp     ecx, eax
.text$mn:0000159C                 jnz     short loc_15D7
.text$mn:0000159E                 lea     ecx, [ebp+var_278]
.text$mn:000015A4                 call    ?clear@?$vector@UFunctionValues@@V?$allocator@UFunctionValues@@@std@@@std@@QAEXXZ ; std::vector<FunctionValues,std::allocator<FunctionValues>>::clear(void)
.text$mn:000015A9                 lea     ecx, [ebp+var_2D8] ; this
.text$mn:000015AF                 call    ??0FunctionValues@@QAE@XZ ; FunctionValues::FunctionValues(void)
.text$mn:000015B4                 mov     ecx, [eax]
.text$mn:000015B6                 mov     [ebp+var_230], ecx
.text$mn:000015BC                 mov     edx, [eax+4]
.text$mn:000015BF                 mov     [ebp+var_22C], edx
.text$mn:000015C5                 mov     ecx, [eax+8]
.text$mn:000015C8                 mov     [ebp+var_228], ecx
.text$mn:000015CE                 mov     edx, [eax+0Ch]
.text$mn:000015D1                 mov     [ebp+var_224], edx
.text$mn:000015D7
.text$mn:000015D7 loc_15D7:                               ; CODE XREF: FunctionCallTip::getCursorFunction(void)+3A8j
.text$mn:000015D7                                         ; FunctionCallTip::getCursorFunction(void):loc_1480j ...
.text$mn:000015D7                 jmp     loc_1369
.text$mn:000015DC ; ---------------------------------------------------------------------------
.text$mn:000015DC
.text$mn:000015DC loc_15DC:                               ; CODE XREF: FunctionCallTip::getCursorFunction(void)+370j
.text$mn:000015DC                 mov     [ebp+var_21A], 0
.text$mn:000015E3                 cmp     [ebp+var_22C], 0FFFFFFFFh
.text$mn:000015EA                 jnz     short loc_163F
.text$mn:000015EC
.text$mn:000015EC loc_15EC:                               ; CODE XREF: FunctionCallTip::getCursorFunction(void)+629j
.text$mn:000015EC                 cmp     [ebp+var_22C], 0FFFFFFFFh
.text$mn:000015F3                 jnz     short loc_163F
.text$mn:000015F5                 lea     ecx, [ebp+var_278]
.text$mn:000015FB                 call    ?size@?$vector@UFunctionValues@@V?$allocator@UFunctionValues@@@std@@@std@@QBEIXZ ; std::vector<FunctionValues,std::allocator<FunctionValues>>::size(void)
.text$mn:00001600                 test    eax, eax
.text$mn:00001602                 jbe     short loc_163F
.text$mn:00001604                 lea     ecx, [ebp+var_278]
.text$mn:0000160A                 call    ?back@?$vector@UFunctionValues@@V?$allocator@UFunctionValues@@@std@@@std@@QAEAAUFunctionValues@@XZ ; std::vector<FunctionValues,std::allocator<FunctionValues>>::back(void)
.text$mn:0000160F                 mov     ecx, [eax]
.text$mn:00001611                 mov     [ebp+var_230], ecx
.text$mn:00001617                 mov     edx, [eax+4]
.text$mn:0000161A                 mov     [ebp+var_22C], edx
.text$mn:00001620                 mov     ecx, [eax+8]
.text$mn:00001623                 mov     [ebp+var_228], ecx
.text$mn:00001629                 mov     edx, [eax+0Ch]
.text$mn:0000162C                 mov     [ebp+var_224], edx
.text$mn:00001632                 lea     ecx, [ebp+var_278]
.text$mn:00001638                 call    ?pop_back@?$vector@UFunctionValues@@V?$allocator@UFunctionValues@@@std@@@std@@QAEXXZ ; std::vector<FunctionValues,std::allocator<FunctionValues>>::pop_back(void)
.text$mn:0000163D                 jmp     short loc_15EC
.text$mn:0000163F ; ---------------------------------------------------------------------------
.text$mn:0000163F
.text$mn:0000163F loc_163F:                               ; CODE XREF: FunctionCallTip::getCursorFunction(void)+5D6j
.text$mn:0000163F                                         ; FunctionCallTip::getCursorFunction(void)+5DFj ...
.text$mn:0000163F                 cmp     [ebp+var_22C], 0FFFFFFFFh
.text$mn:00001646                 jle     loc_1801
.text$mn:0000164C                 mov     eax, [ebp+var_22C]
.text$mn:00001652                 push    eax
.text$mn:00001653                 lea     ecx, [ebp+var_29C]
.text$mn:00001659                 call    ?at@?$vector@UToken@@V?$allocator@UToken@@@std@@@std@@QAEAAUToken@@I@Z ; std::vector<Token,std::allocator<Token>>::at(uint)
.text$mn:0000165E                 mov     ecx, [eax]
.text$mn:00001660                 mov     [ebp+Str2], ecx
.text$mn:00001666                 mov     edx, [eax+4]
.text$mn:00001669                 mov     [ebp+var_258], edx
.text$mn:0000166F                 mov     eax, [eax+8]
.text$mn:00001672                 mov     [ebp+var_254], eax
.text$mn:00001678                 xor     ecx, ecx
.text$mn:0000167A                 mov     edx, [ebp+var_258]
.text$mn:00001680                 mov     eax, [ebp+Str2]
.text$mn:00001686                 mov     [eax+edx*2], cx
.text$mn:0000168A                 mov     ecx, [ebp+var_214]
.text$mn:00001690                 mov     edx, [ebp+var_228]
.text$mn:00001696                 mov     [ecx+50h], edx
.text$mn:00001699                 mov     [ebp+var_219], 0
.text$mn:000016A0                 mov     eax, [ebp+var_214]
.text$mn:000016A6                 cmp     dword ptr [eax+14h], 0
.text$mn:000016AA                 jz      loc_1760
.text$mn:000016B0                 mov     ecx, [ebp+var_214]
.text$mn:000016B6                 movzx   edx, byte ptr [ecx+78h]
.text$mn:000016BA                 test    edx, edx
.text$mn:000016BC                 jz      short loc_1710
.text$mn:000016BE                 mov     eax, [ebp+var_214]
.text$mn:000016C4                 mov     ecx, [eax+14h]
.text$mn:000016C7                 push    ecx             ; lpString
.text$mn:000016C8                 call    dword ptr ds:__imp__lstrlenW@4 ; lstrlenW(x)
.text$mn:000016CE                 push    eax             ; int
.text$mn:000016CF                 mov     edx, [ebp+Str2]
.text$mn:000016D5                 push    edx             ; wchar_t *
.text$mn:000016D6                 mov     eax, [ebp+var_214]
.text$mn:000016DC                 mov     ecx, [eax+14h]
.text$mn:000016DF                 push    ecx             ; wchar_t *
.text$mn:000016E0                 call    ?testNameNoCase@@YAHPB_W0H@Z ; testNameNoCase(wchar_t const *,wchar_t const *,int)
.text$mn:000016E5                 add     esp, 0Ch
.text$mn:000016E8                 test    eax, eax
.text$mn:000016EA                 jnz     short loc_16F8
.text$mn:000016EC                 mov     [ebp+var_260], 1
.text$mn:000016F6                 jmp     short loc_1702
.text$mn:000016F8 ; ---------------------------------------------------------------------------
.text$mn:000016F8
.text$mn:000016F8 loc_16F8:                               ; CODE XREF: FunctionCallTip::getCursorFunction(void)+6D6j
.text$mn:000016F8                 mov     [ebp+var_260], 0
.text$mn:00001702
.text$mn:00001702 loc_1702:                               ; CODE XREF: FunctionCallTip::getCursorFunction(void)+6E2j
.text$mn:00001702                 mov     dl, byte ptr [ebp+var_260]
.text$mn:00001708                 mov     [ebp+var_219], dl
.text$mn:0000170E                 jmp     short loc_1760
.text$mn:00001710 ; ---------------------------------------------------------------------------
.text$mn:00001710
.text$mn:00001710 loc_1710:                               ; CODE XREF: FunctionCallTip::getCursorFunction(void)+6A8j
.text$mn:00001710                 mov     eax, [ebp+var_214]
.text$mn:00001716                 mov     ecx, [eax+14h]
.text$mn:00001719                 push    ecx             ; lpString
.text$mn:0000171A                 call    dword ptr ds:__imp__lstrlenW@4 ; lstrlenW(x)
.text$mn:00001720                 push    eax             ; MaxCount
.text$mn:00001721                 mov     edx, [ebp+Str2]
.text$mn:00001727                 push    edx             ; Str2
.text$mn:00001728                 mov     eax, [ebp+var_214]
.text$mn:0000172E                 mov     ecx, [eax+14h]
.text$mn:00001731                 push    ecx             ; Str1
.text$mn:00001732                 call    _wcsncmp
.text$mn:00001737                 add     esp, 0Ch
.text$mn:0000173A                 test    eax, eax
.text$mn:0000173C                 jnz     short loc_174A
.text$mn:0000173E                 mov     [ebp+var_250], 1
.text$mn:00001748                 jmp     short loc_1754
.text$mn:0000174A ; ---------------------------------------------------------------------------
.text$mn:0000174A
.text$mn:0000174A loc_174A:                               ; CODE XREF: FunctionCallTip::getCursorFunction(void)+728j
.text$mn:0000174A                 mov     [ebp+var_250], 0
.text$mn:00001754
.text$mn:00001754 loc_1754:                               ; CODE XREF: FunctionCallTip::getCursorFunction(void)+734j
.text$mn:00001754                 mov     dl, byte ptr [ebp+var_250]
.text$mn:0000175A                 mov     [ebp+var_219], dl
.text$mn:00001760
.text$mn:00001760 loc_1760:                               ; CODE XREF: FunctionCallTip::getCursorFunction(void)+696j
.text$mn:00001760                                         ; FunctionCallTip::getCursorFunction(void)+6FAj
.text$mn:00001760                 movzx   eax, [ebp+var_219]
.text$mn:00001767                 test    eax, eax
.text$mn:00001769                 jnz     loc_17FA
.text$mn:0000176F                 mov     ecx, [ebp+var_214]
.text$mn:00001775                 cmp     dword ptr [ecx+14h], 0
.text$mn:00001779                 jz      short loc_1799
.text$mn:0000177B                 mov     edx, [ebp+var_214]
.text$mn:00001781                 mov     eax, [edx+14h]
.text$mn:00001784                 mov     [ebp+var_284], eax
.text$mn:0000178A                 mov     ecx, [ebp+var_284]
.text$mn:00001790                 push    ecx             ; void *
.text$mn:00001791                 call    ??_V@YAXPAX@Z   ; operator delete[](void *)
.text$mn:00001796                 add     esp, 4
.text$mn:00001799
.text$mn:00001799 loc_1799:                               ; CODE XREF: FunctionCallTip::getCursorFunction(void)+765j
.text$mn:00001799                 mov     eax, [ebp+var_258]
.text$mn:0000179F                 add     eax, 1
.text$mn:000017A2                 xor     ecx, ecx
.text$mn:000017A4                 mov     edx, 2
.text$mn:000017A9                 mul     edx
.text$mn:000017AB                 seto    cl
.text$mn:000017AE                 neg     ecx
.text$mn:000017B0                 or      ecx, eax
.text$mn:000017B2                 push    ecx             ; unsigned int
.text$mn:000017B3                 call    ??_U@YAPAXI@Z   ; operator new[](uint)
.text$mn:000017B8                 add     esp, 4
.text$mn:000017BB                 mov     [ebp+var_27C], eax
.text$mn:000017C1                 mov     eax, [ebp+var_214]
.text$mn:000017C7                 mov     ecx, [ebp+var_27C]
.text$mn:000017CD                 mov     [eax+14h], ecx
.text$mn:000017D0                 mov     edx, [ebp+Str2]
.text$mn:000017D6                 push    edx             ; lpString2
.text$mn:000017D7                 mov     eax, [ebp+var_214]
.text$mn:000017DD                 mov     ecx, [eax+14h]
.text$mn:000017E0                 push    ecx             ; lpString1
.text$mn:000017E1                 call    dword ptr ds:__imp__lstrcpyW@8 ; lstrcpyW(x,x)
.text$mn:000017E7                 mov     ecx, [ebp+var_214] ; this
.text$mn:000017ED                 call    ?loadFunction@FunctionCallTip@@AAE_NXZ ; FunctionCallTip::loadFunction(void)
.text$mn:000017F2                 mov     [ebp+var_21A], al
.text$mn:000017F8                 jmp     short loc_1801
.text$mn:000017FA ; ---------------------------------------------------------------------------
.text$mn:000017FA
.text$mn:000017FA loc_17FA:                               ; CODE XREF: FunctionCallTip::getCursorFunction(void)+755j
.text$mn:000017FA                 mov     [ebp+var_21A], 1
.text$mn:00001801
.text$mn:00001801 loc_1801:                               ; CODE XREF: FunctionCallTip::getCursorFunction(void)+632j
.text$mn:00001801                                         ; FunctionCallTip::getCursorFunction(void)+7E4j
.text$mn:00001801                 mov     dl, [ebp+var_21A]
.text$mn:00001807                 mov     [ebp+var_235], dl
.text$mn:0000180D                 mov     byte ptr [ebp+var_4], 0
.text$mn:00001811                 lea     ecx, [ebp+var_278]
.text$mn:00001817                 call    ??1?$vector@UFunctionValues@@V?$allocator@UFunctionValues@@@std@@@std@@QAE@XZ ; std::vector<FunctionValues,std::allocator<FunctionValues>>::~vector<FunctionValues,std::allocator<FunctionValues>>(void)
.text$mn:0000181C                 mov     [ebp+var_4], 0FFFFFFFFh
.text$mn:00001823                 lea     ecx, [ebp+var_29C]
.text$mn:00001829                 call    ??1?$vector@UToken@@V?$allocator@UToken@@@std@@@std@@QAE@XZ ; std::vector<Token,std::allocator<Token>>::~vector<Token,std::allocator<Token>>(void)
.text$mn:0000182E                 mov     al, [ebp+var_235]
.text$mn:00001834
.text$mn:00001834 loc_1834:                               ; CODE XREF: FunctionCallTip::getCursorFunction(void)+EDj
.text$mn:00001834                 mov     ecx, [ebp+var_C]
.text$mn:00001837                 mov     large fs:0, ecx
.text$mn:0000183E                 pop     ecx
.text$mn:0000183F                 mov     ecx, [ebp+var_10]
.text$mn:00001842                 xor     ecx, ebp
.text$mn:00001844                 call    @__security_check_cookie@4 ; __security_check_cookie(x)
.text$mn:00001849                 mov     esp, ebp
.text$mn:0000184B                 pop     ebp
.text$mn:0000184C                 retn
.text$mn:0000184C ?getCursorFunction@FunctionCallTip@@AAE_NXZ endp
.text$mn:0000184C
.text$mn:0000184C ; ---------------------------------------------------------------------------
.text$mn:0000184D                 db 7 dup(0CCh)
.text$mn:00001854
.text$mn:00001854 ; =============== S U B R O U T I N E =======================================
.text$mn:00001854
.text$mn:00001854 ; Attributes: bp-based frame
.text$mn:00001854
.text$mn:00001854 ; bool __thiscall FunctionCallTip::loadFunction(FunctionCallTip *__hidden this)
.text$mn:00001854                 public ?loadFunction@FunctionCallTip@@AAE_NXZ
.text$mn:00001854 ?loadFunction@FunctionCallTip@@AAE_NXZ proc near
.text$mn:00001854                                         ; CODE XREF: FunctionCallTip::getCursorFunction(void)+7D9p
.text$mn:00001854
.text$mn:00001854 var_4C          = byte ptr -4Ch
.text$mn:00001854 var_3C          = dword ptr -3Ch
.text$mn:00001854 var_38          = dword ptr -38h
.text$mn:00001854 var_34          = dword ptr -34h
.text$mn:00001854 var_30          = dword ptr -30h
.text$mn:00001854 var_2C          = dword ptr -2Ch
.text$mn:00001854 var_28          = dword ptr -28h
.text$mn:00001854 lpString1       = dword ptr -24h
.text$mn:00001854 var_20          = dword ptr -20h
.text$mn:00001854 var_1C          = dword ptr -1Ch
.text$mn:00001854 var_18          = dword ptr -18h
.text$mn:00001854 var_14          = dword ptr -14h
.text$mn:00001854 var_E           = byte ptr -0Eh
.text$mn:00001854 var_D           = byte ptr -0Dh
.text$mn:00001854 var_C           = dword ptr -0Ch
.text$mn:00001854 var_4           = dword ptr -4
.text$mn:00001854
.text$mn:00001854                 push    ebp
.text$mn:00001855                 mov     ebp, esp
.text$mn:00001857                 push    0FFFFFFFFh
.text$mn:00001859                 push    offset __ehhandler$?loadFunction@FunctionCallTip@@AAE_NXZ
.text$mn:0000185E                 mov     eax, large fs:0
.text$mn:00001864                 push    eax
.text$mn:00001865                 sub     esp, 40h
.text$mn:00001868                 mov     eax, dword ptr ds:___security_cookie
.text$mn:0000186D                 xor     eax, ebp
.text$mn:0000186F                 push    eax
.text$mn:00001870                 lea     eax, [ebp+var_C]
.text$mn:00001873                 mov     large fs:0, eax
.text$mn:00001879                 mov     [ebp+var_14], ecx
.text$mn:0000187C                 mov     ecx, [ebp+var_14] ; this
.text$mn:0000187F                 call    ?reset@FunctionCallTip@@AAEXXZ ; FunctionCallTip::reset(void)
.text$mn:00001884                 mov     eax, [ebp+var_14]
.text$mn:00001887                 mov     dword ptr [eax+10h], 0
.text$mn:0000188E                 mov     ecx, [ebp+var_14]
.text$mn:00001891                 mov     edx, [ecx+4]
.text$mn:00001894                 mov     [ebp+var_18], edx
.text$mn:00001897                 jmp     short loc_18A9
.text$mn:00001899 ; ---------------------------------------------------------------------------
.text$mn:00001899
.text$mn:00001899 loc_1899:                               ; CODE XREF: FunctionCallTip::loadFunction(void)+7Cj
.text$mn:00001899                                         ; FunctionCallTip::loadFunction(void):loc_1955j
.text$mn:00001899                 push    offset $SG154327 ; "KeyWord"
.text$mn:0000189E                 mov     ecx, [ebp+var_18] ; this
.text$mn:000018A1                 call    ?NextSiblingElement@TiXmlNode@@QBEPAVTiXmlElement@@PB_W@Z ; TiXmlNode::NextSiblingElement(wchar_t const *)
.text$mn:000018A6                 mov     [ebp+var_18], eax
.text$mn:000018A9
.text$mn:000018A9 loc_18A9:                               ; CODE XREF: FunctionCallTip::loadFunction(void)+43j
.text$mn:000018A9                 cmp     [ebp+var_18], 0
.text$mn:000018AD                 jz      loc_195A
.text$mn:000018B3                 mov     [ebp+lpString1], 0
.text$mn:000018BA                 push    offset $SG154329 ; "name"
.text$mn:000018BF                 mov     ecx, [ebp+var_18] ; this
.text$mn:000018C2                 call    ?Attribute@TiXmlElement@@QBEPB_WPB_W@Z ; TiXmlElement::Attribute(wchar_t const *)
.text$mn:000018C7                 mov     [ebp+lpString1], eax
.text$mn:000018CA                 cmp     [ebp+lpString1], 0
.text$mn:000018CE                 jnz     short loc_18D2
.text$mn:000018D0                 jmp     short loc_1899
.text$mn:000018D2 ; ---------------------------------------------------------------------------
.text$mn:000018D2
.text$mn:000018D2 loc_18D2:                               ; CODE XREF: FunctionCallTip::loadFunction(void)+7Aj
.text$mn:000018D2                 mov     [ebp+var_28], 0
.text$mn:000018D9                 mov     eax, [ebp+var_14]
.text$mn:000018DC                 movzx   ecx, byte ptr [eax+78h]
.text$mn:000018E0                 test    ecx, ecx
.text$mn:000018E2                 jz      short loc_18FE
.text$mn:000018E4                 push    0FFFFFFFFh      ; int
.text$mn:000018E6                 mov     edx, [ebp+var_14]
.text$mn:000018E9                 mov     eax, [edx+14h]
.text$mn:000018EC                 push    eax             ; wchar_t *
.text$mn:000018ED                 mov     ecx, [ebp+lpString1]
.text$mn:000018F0                 push    ecx             ; wchar_t *
.text$mn:000018F1                 call    ?testNameNoCase@@YAHPB_W0H@Z ; testNameNoCase(wchar_t const *,wchar_t const *,int)
.text$mn:000018F6                 add     esp, 0Ch
.text$mn:000018F9                 mov     [ebp+var_28], eax
.text$mn:000018FC                 jmp     short loc_1912
.text$mn:000018FE ; ---------------------------------------------------------------------------
.text$mn:000018FE
.text$mn:000018FE loc_18FE:                               ; CODE XREF: FunctionCallTip::loadFunction(void)+8Ej
.text$mn:000018FE                 mov     edx, [ebp+var_14]
.text$mn:00001901                 mov     eax, [edx+14h]
.text$mn:00001904                 push    eax             ; lpString2
.text$mn:00001905                 mov     ecx, [ebp+lpString1]
.text$mn:00001908                 push    ecx             ; lpString1
.text$mn:00001909                 call    dword ptr ds:__imp__lstrcmpW@8 ; lstrcmpW(x,x)
.text$mn:0000190F                 mov     [ebp+var_28], eax
.text$mn:00001912
.text$mn:00001912 loc_1912:                               ; CODE XREF: FunctionCallTip::loadFunction(void)+A8j
.text$mn:00001912                 cmp     [ebp+var_28], 0
.text$mn:00001916                 jnz     short loc_1955
.text$mn:00001918                 push    offset $SG154336 ; "func"
.text$mn:0000191D                 mov     ecx, [ebp+var_18] ; this
.text$mn:00001920                 call    ?Attribute@TiXmlElement@@QBEPB_WPB_W@Z ; TiXmlElement::Attribute(wchar_t const *)
.text$mn:00001925                 mov     [ebp+var_2C], eax
.text$mn:00001928                 cmp     [ebp+var_2C], 0
.text$mn:0000192C                 jz      short loc_1955
.text$mn:0000192E                 push    offset $SG154339 ; "yes"
.text$mn:00001933                 mov     edx, [ebp+var_2C]
.text$mn:00001936                 push    edx             ; lpString1
.text$mn:00001937                 call    dword ptr ds:__imp__lstrcmpW@8 ; lstrcmpW(x,x)
.text$mn:0000193D                 test    eax, eax
.text$mn:0000193F                 jnz     short loc_194E
.text$mn:00001941                 mov     eax, [ebp+var_14]
.text$mn:00001944                 mov     ecx, [ebp+var_18]
.text$mn:00001947                 mov     [eax+10h], ecx
.text$mn:0000194A                 jmp     short loc_195A
.text$mn:0000194C ; ---------------------------------------------------------------------------
.text$mn:0000194C                 jmp     short loc_1955
.text$mn:0000194E ; ---------------------------------------------------------------------------
.text$mn:0000194E
.text$mn:0000194E loc_194E:                               ; CODE XREF: FunctionCallTip::loadFunction(void)+EBj
.text$mn:0000194E                 xor     al, al
.text$mn:00001950                 jmp     loc_1AD4
.text$mn:00001955 ; ---------------------------------------------------------------------------
.text$mn:00001955
.text$mn:00001955 loc_1955:                               ; CODE XREF: FunctionCallTip::loadFunction(void)+C2j
.text$mn:00001955                                         ; FunctionCallTip::loadFunction(void)+D8j ...
.text$mn:00001955                 jmp     loc_1899
.text$mn:0000195A ; ---------------------------------------------------------------------------
.text$mn:0000195A
.text$mn:0000195A loc_195A:                               ; CODE XREF: FunctionCallTip::loadFunction(void)+59j
.text$mn:0000195A                                         ; FunctionCallTip::loadFunction(void)+F6j
.text$mn:0000195A                 mov     edx, [ebp+var_14]
.text$mn:0000195D                 cmp     dword ptr [edx+10h], 0
.text$mn:00001961                 jnz     short loc_196A
.text$mn:00001963                 xor     al, al
.text$mn:00001965                 jmp     loc_1AD4
.text$mn:0000196A ; ---------------------------------------------------------------------------
.text$mn:0000196A
.text$mn:0000196A loc_196A:                               ; CODE XREF: FunctionCallTip::loadFunction(void)+10Dj
.text$mn:0000196A                 lea     ecx, [ebp+var_4C]
.text$mn:0000196D                 call    ??0?$vector@PB_WV?$allocator@PB_W@std@@@std@@QAE@XZ ; std::vector<wchar_t const *,std::allocator<wchar_t const *>>::vector<wchar_t const *,std::allocator<wchar_t const *>>(void)
.text$mn:00001972                 mov     [ebp+var_4], 0
.text$mn:00001979                 push    offset $SG154344 ; "Overload"
.text$mn:0000197E                 mov     eax, [ebp+var_14]
.text$mn:00001981                 mov     ecx, [eax+10h]  ; this
.text$mn:00001984                 call    ?FirstChildElement@TiXmlNode@@QBEPAVTiXmlElement@@PB_W@Z ; TiXmlNode::FirstChildElement(wchar_t const *)
.text$mn:00001989                 mov     [ebp+var_1C], eax
.text$mn:0000198C                 mov     [ebp+var_20], 0
.text$mn:00001993                 jmp     short loc_19A5
.text$mn:00001995 ; ---------------------------------------------------------------------------
.text$mn:00001995
.text$mn:00001995 loc_1995:                               ; CODE XREF: FunctionCallTip::loadFunction(void)+171j
.text$mn:00001995                                         ; FunctionCallTip::loadFunction(void)+233j
.text$mn:00001995                 push    offset $SG154349 ; "Overload"
.text$mn:0000199A                 mov     ecx, [ebp+var_1C] ; this
.text$mn:0000199D                 call    ?NextSiblingElement@TiXmlNode@@QBEPAVTiXmlElement@@PB_W@Z ; TiXmlNode::NextSiblingElement(wchar_t const *)
.text$mn:000019A2                 mov     [ebp+var_1C], eax
.text$mn:000019A5
.text$mn:000019A5 loc_19A5:                               ; CODE XREF: FunctionCallTip::loadFunction(void)+13Fj
.text$mn:000019A5                 cmp     [ebp+var_1C], 0
.text$mn:000019A9                 jz      loc_1A8C
.text$mn:000019AF                 push    offset $SG154351 ; "retVal"
.text$mn:000019B4                 mov     ecx, [ebp+var_1C] ; this
.text$mn:000019B7                 call    ?Attribute@TiXmlElement@@QBEPB_WPB_W@Z ; TiXmlElement::Attribute(wchar_t const *)
.text$mn:000019BC                 mov     [ebp+var_30], eax
.text$mn:000019BF                 cmp     [ebp+var_30], 0
.text$mn:000019C3                 jnz     short loc_19C7
.text$mn:000019C5                 jmp     short loc_1995
.text$mn:000019C7 ; ---------------------------------------------------------------------------
.text$mn:000019C7
.text$mn:000019C7 loc_19C7:                               ; CODE XREF: FunctionCallTip::loadFunction(void)+16Fj
.text$mn:000019C7                 lea     ecx, [ebp+var_30]
.text$mn:000019CA                 push    ecx
.text$mn:000019CB                 mov     ecx, [ebp+var_14]
.text$mn:000019CE                 add     ecx, 18h
.text$mn:000019D1                 call    ?push_back@?$vector@PB_WV?$allocator@PB_W@std@@@std@@QAEXABQB_W@Z ; std::vector<wchar_t const *,std::allocator<wchar_t const *>>::push_back(wchar_t const * const &)
.text$mn:000019D6                 push    offset $SG154354 ; "descr"
.text$mn:000019DB                 mov     ecx, [ebp+var_1C] ; this
.text$mn:000019DE                 call    ?Attribute@TiXmlElement@@QBEPB_WPB_W@Z ; TiXmlElement::Attribute(wchar_t const *)
.text$mn:000019E3                 mov     [ebp+var_34], eax
.text$mn:000019E6                 cmp     [ebp+var_34], 0
.text$mn:000019EA                 jz      short loc_19FD
.text$mn:000019EC                 lea     edx, [ebp+var_34]
.text$mn:000019EF                 push    edx
.text$mn:000019F0                 mov     ecx, [ebp+var_14]
.text$mn:000019F3                 add     ecx, 38h ; '8'
.text$mn:000019F6                 call    ?push_back@?$vector@PB_WV?$allocator@PB_W@std@@@std@@QAEXABQB_W@Z ; std::vector<wchar_t const *,std::allocator<wchar_t const *>>::push_back(wchar_t const * const &)
.text$mn:000019FB                 jmp     short loc_1A13
.text$mn:000019FD ; ---------------------------------------------------------------------------
.text$mn:000019FD
.text$mn:000019FD loc_19FD:                               ; CODE XREF: FunctionCallTip::loadFunction(void)+196j
.text$mn:000019FD                 mov     [ebp+var_3C], offset $SG154358
.text$mn:00001A04                 lea     eax, [ebp+var_3C]
.text$mn:00001A07                 push    eax
.text$mn:00001A08                 mov     ecx, [ebp+var_14]
.text$mn:00001A0B                 add     ecx, 38h ; '8'
.text$mn:00001A0E                 call    ?push_back@?$vector@PB_WV?$allocator@PB_W@std@@@std@@QAEXABQB_W@Z ; std::vector<wchar_t const *,std::allocator<wchar_t const *>>::push_back(wchar_t const * const &)
.text$mn:00001A13
.text$mn:00001A13 loc_1A13:                               ; CODE XREF: FunctionCallTip::loadFunction(void)+1A7j
.text$mn:00001A13                 push    offset $SG154359 ; "Param"
.text$mn:00001A18                 mov     ecx, [ebp+var_1C] ; this
.text$mn:00001A1B                 call    ?FirstChildElement@TiXmlNode@@QBEPAVTiXmlElement@@PB_W@Z ; TiXmlNode::FirstChildElement(wchar_t const *)
.text$mn:00001A20                 mov     [ebp+var_20], eax
.text$mn:00001A23                 jmp     short loc_1A35
.text$mn:00001A25 ; ---------------------------------------------------------------------------
.text$mn:00001A25
.text$mn:00001A25 loc_1A25:                               ; CODE XREF: FunctionCallTip::loadFunction(void)+1FDj
.text$mn:00001A25                                         ; FunctionCallTip::loadFunction(void)+20Bj
.text$mn:00001A25                 push    offset $SG154363 ; "Param"
.text$mn:00001A2A                 mov     ecx, [ebp+var_20] ; this
.text$mn:00001A2D                 call    ?NextSiblingElement@TiXmlNode@@QBEPAVTiXmlElement@@PB_W@Z ; TiXmlNode::NextSiblingElement(wchar_t const *)
.text$mn:00001A32                 mov     [ebp+var_20], eax
.text$mn:00001A35
.text$mn:00001A35 loc_1A35:                               ; CODE XREF: FunctionCallTip::loadFunction(void)+1CFj
.text$mn:00001A35                 cmp     [ebp+var_20], 0
.text$mn:00001A39                 jz      short loc_1A61
.text$mn:00001A3B                 push    offset $SG154365 ; "name"
.text$mn:00001A40                 mov     ecx, [ebp+var_20] ; this
.text$mn:00001A43                 call    ?Attribute@TiXmlElement@@QBEPB_WPB_W@Z ; TiXmlElement::Attribute(wchar_t const *)
.text$mn:00001A48                 mov     [ebp+var_38], eax
.text$mn:00001A4B                 cmp     [ebp+var_38], 0
.text$mn:00001A4F                 jnz     short loc_1A53
.text$mn:00001A51                 jmp     short loc_1A25
.text$mn:00001A53 ; ---------------------------------------------------------------------------
.text$mn:00001A53
.text$mn:00001A53 loc_1A53:                               ; CODE XREF: FunctionCallTip::loadFunction(void)+1FBj
.text$mn:00001A53                 lea     ecx, [ebp+var_38]
.text$mn:00001A56                 push    ecx
.text$mn:00001A57                 lea     ecx, [ebp+var_4C]
.text$mn:00001A5A                 call    ?push_back@?$vector@PB_WV?$allocator@PB_W@std@@@std@@QAEXABQB_W@Z ; std::vector<wchar_t const *,std::allocator<wchar_t const *>>::push_back(wchar_t const * const &)
.text$mn:00001A5F                 jmp     short loc_1A25
.text$mn:00001A61 ; ---------------------------------------------------------------------------
.text$mn:00001A61
.text$mn:00001A61 loc_1A61:                               ; CODE XREF: FunctionCallTip::loadFunction(void)+1E5j
.text$mn:00001A61                 lea     edx, [ebp+var_4C]
.text$mn:00001A64                 push    edx
.text$mn:00001A65                 mov     ecx, [ebp+var_14]
.text$mn:00001A68                 add     ecx, 28h ; '('
.text$mn:00001A6B                 call    ?push_back@?$vector@V?$vector@PB_WV?$allocator@PB_W@std@@@std@@V?$allocator@V?$vector@PB_WV?$allocator@PB_W@std@@@std@@@2@@std@@QAEXABV?$vector@PB_WV?$allocator@PB_W@std@@@2@@Z ; std::vector<std::vector<wchar_t const *,std::allocator<wchar_t const *>>,std::allocator<std::vector<wchar_t const *,std::allocator<wchar_t const *>>>>::push_back(std::vector<wchar_t const *,std::allocator<wchar_t const *>> const &)
.text$mn:00001A70                 lea     ecx, [ebp+var_4C]
.text$mn:00001A73                 call    ?clear@?$vector@PB_WV?$allocator@PB_W@std@@@std@@QAEXXZ ; std::vector<wchar_t const *,std::allocator<wchar_t const *>>::clear(void)
.text$mn:00001A78                 mov     eax, [ebp+var_14]
.text$mn:00001A7B                 mov     ecx, [eax+48h]
.text$mn:00001A7E                 add     ecx, 1
.text$mn:00001A81                 mov     edx, [ebp+var_14]
.text$mn:00001A84                 mov     [edx+48h], ecx
.text$mn:00001A87                 jmp     loc_1995
.text$mn:00001A8C ; ---------------------------------------------------------------------------
.text$mn:00001A8C
.text$mn:00001A8C loc_1A8C:                               ; CODE XREF: FunctionCallTip::loadFunction(void)+155j
.text$mn:00001A8C                 mov     ecx, [ebp+var_14]
.text$mn:00001A8F                 add     ecx, 28h ; '('
.text$mn:00001A92                 call    ?size@?$vector@V?$vector@PB_WV?$allocator@PB_W@std@@@std@@V?$allocator@V?$vector@PB_WV?$allocator@PB_W@std@@@std@@@2@@std@@QBEIXZ ; std::vector<std::vector<wchar_t const *,std::allocator<wchar_t const *>>,std::allocator<std::vector<wchar_t const *,std::allocator<wchar_t const *>>>>::size(void)
.text$mn:00001A97                 mov     ecx, [ebp+var_14]
.text$mn:00001A9A                 mov     [ecx+48h], eax
.text$mn:00001A9D                 mov     edx, [ebp+var_14]
.text$mn:00001AA0                 cmp     dword ptr [edx+48h], 0
.text$mn:00001AA4                 jnz     short loc_1ABE
.text$mn:00001AA6                 mov     [ebp+var_D], 0
.text$mn:00001AAA                 mov     [ebp+var_4], 0FFFFFFFFh
.text$mn:00001AB1                 lea     ecx, [ebp+var_4C]
.text$mn:00001AB4                 call    ??1?$vector@PB_WV?$allocator@PB_W@std@@@std@@QAE@XZ ; std::vector<wchar_t const *,std::allocator<wchar_t const *>>::~vector<wchar_t const *,std::allocator<wchar_t const *>>(void)
.text$mn:00001AB9                 mov     al, [ebp+var_D]
.text$mn:00001ABC                 jmp     short loc_1AD4
.text$mn:00001ABE ; ---------------------------------------------------------------------------
.text$mn:00001ABE
.text$mn:00001ABE loc_1ABE:                               ; CODE XREF: FunctionCallTip::loadFunction(void)+250j
.text$mn:00001ABE                 mov     [ebp+var_E], 1
.text$mn:00001AC2                 mov     [ebp+var_4], 0FFFFFFFFh
.text$mn:00001AC9                 lea     ecx, [ebp+var_4C]
.text$mn:00001ACC                 call    ??1?$vector@PB_WV?$allocator@PB_W@std@@@std@@QAE@XZ ; std::vector<wchar_t const *,std::allocator<wchar_t const *>>::~vector<wchar_t const *,std::allocator<wchar_t const *>>(void)
.text$mn:00001AD1                 mov     al, [ebp+var_E]
.text$mn:00001AD4
.text$mn:00001AD4 loc_1AD4:                               ; CODE XREF: FunctionCallTip::loadFunction(void)+FCj
.text$mn:00001AD4                                         ; FunctionCallTip::loadFunction(void)+111j ...
.text$mn:00001AD4                 mov     ecx, [ebp+var_C]
.text$mn:00001AD7                 mov     large fs:0, ecx
.text$mn:00001ADE                 pop     ecx
.text$mn:00001ADF                 mov     esp, ebp
.text$mn:00001AE1                 pop     ebp
.text$mn:00001AE2                 retn
.text$mn:00001AE2 ?loadFunction@FunctionCallTip@@AAE_NXZ endp
.text$mn:00001AE2
.text$mn:00001AE2 ; ---------------------------------------------------------------------------
.text$mn:00001AE3                 align 4
.text$mn:00001AE4
.text$mn:00001AE4 ; =============== S U B R O U T I N E =======================================
.text$mn:00001AE4
.text$mn:00001AE4 ; Attributes: bp-based frame
.text$mn:00001AE4
.text$mn:00001AE4 ; void __thiscall FunctionCallTip::showCalltip(FunctionCallTip *__hidden this)
.text$mn:00001AE4                 public ?showCalltip@FunctionCallTip@@AAEXXZ
.text$mn:00001AE4 ?showCalltip@FunctionCallTip@@AAEXXZ proc near
.text$mn:00001AE4                                         ; CODE XREF: FunctionCallTip::updateCalltip(int,bool)+65p
.text$mn:00001AE4                                         ; FunctionCallTip::showNextOverload(void)+31p ...
.text$mn:00001AE4
.text$mn:00001AE4 var_1044        = dword ptr -1044h
.text$mn:00001AE4 var_1040        = dword ptr -1040h
.text$mn:00001AE4 var_103C        = dword ptr -103Ch
.text$mn:00001AE4 lpString        = dword ptr -1038h
.text$mn:00001AE4 lpString2       = dword ptr -1034h
.text$mn:00001AE4 var_1030        = dword ptr -1030h
.text$mn:00001AE4 var_102C        = dword ptr -102Ch
.text$mn:00001AE4 var_1028        = dword ptr -1028h
.text$mn:00001AE4 var_1024        = dword ptr -1024h
.text$mn:00001AE4 var_1020        = dword ptr -1020h
.text$mn:00001AE4 var_101C        = dword ptr -101Ch
.text$mn:00001AE4 var_1018        = dword ptr -1018h
.text$mn:00001AE4 var_1014        = dword ptr -1014h
.text$mn:00001AE4 var_1010        = dword ptr -1010h
.text$mn:00001AE4 var_1009        = byte ptr -1009h
.text$mn:00001AE4 var_1008        = dword ptr -1008h
.text$mn:00001AE4 String1         = word ptr -1004h
.text$mn:00001AE4 var_4           = dword ptr -4
.text$mn:00001AE4
.text$mn:00001AE4                 push    ebp
.text$mn:00001AE5                 mov     ebp, esp
.text$mn:00001AE7                 mov     eax, 1044h
.text$mn:00001AEC                 call    __chkstk
.text$mn:00001AF1                 mov     eax, dword ptr ds:___security_cookie
.text$mn:00001AF6                 xor     eax, ebp
.text$mn:00001AF8                 mov     [ebp+var_4], eax
.text$mn:00001AFB                 push    esi
.text$mn:00001AFC                 mov     [ebp+var_1008], ecx
.text$mn:00001B02                 mov     eax, [ebp+var_1008]
.text$mn:00001B08                 cmp     dword ptr [eax+48h], 0
.text$mn:00001B0C                 jnz     short loc_1B13
.text$mn:00001B0E                 jmp     loc_1F91
.text$mn:00001B13 ; ---------------------------------------------------------------------------
.text$mn:00001B13
.text$mn:00001B13 loc_1B13:                               ; CODE XREF: FunctionCallTip::showCalltip(void)+28j
.text$mn:00001B13                 mov     ecx, [ebp+var_1008]
.text$mn:00001B19                 mov     edx, [ecx+4Ch]
.text$mn:00001B1C                 push    edx
.text$mn:00001B1D                 mov     ecx, [ebp+var_1008]
.text$mn:00001B23                 add     ecx, 28h ; '('
.text$mn:00001B26                 call    ?at@?$vector@V?$vector@PB_WV?$allocator@PB_W@std@@@std@@V?$allocator@V?$vector@PB_WV?$allocator@PB_W@std@@@std@@@2@@std@@QAEAAV?$vector@PB_WV?$allocator@PB_W@std@@@2@I@Z ; std::vector<std::vector<wchar_t const *,std::allocator<wchar_t const *>>,std::allocator<std::vector<wchar_t const *,std::allocator<wchar_t const *>>>>::at(uint)
.text$mn:00001B2B                 mov     [ebp+var_101C], eax
.text$mn:00001B31                 mov     ecx, [ebp+var_101C]
.text$mn:00001B37                 call    ?size@?$vector@PB_WV?$allocator@PB_W@std@@@std@@QBEIXZ ; std::vector<wchar_t const *,std::allocator<wchar_t const *>>::size(void)
.text$mn:00001B3C                 add     eax, 1
.text$mn:00001B3F                 mov     [ebp+var_1028], eax
.text$mn:00001B45                 mov     eax, [ebp+var_1008]
.text$mn:00001B4B                 mov     ecx, [eax+50h]
.text$mn:00001B4E                 cmp     ecx, [ebp+var_1028]
.text$mn:00001B54                 jb      loc_1BE0
.text$mn:00001B5A                 mov     ecx, [ebp+var_1008]
.text$mn:00001B60                 add     ecx, 28h ; '('
.text$mn:00001B63                 call    ?size@?$vector@V?$vector@PB_WV?$allocator@PB_W@std@@@std@@V?$allocator@V?$vector@PB_WV?$allocator@PB_W@std@@@std@@@2@@std@@QBEIXZ ; std::vector<std::vector<wchar_t const *,std::allocator<wchar_t const *>>,std::allocator<std::vector<wchar_t const *,std::allocator<wchar_t const *>>>>::size(void)
.text$mn:00001B68                 mov     [ebp+var_1040], eax
.text$mn:00001B6E                 mov     [ebp+var_1018], 0
.text$mn:00001B78                 jmp     short loc_1B89
.text$mn:00001B7A ; ---------------------------------------------------------------------------
.text$mn:00001B7A
.text$mn:00001B7A loc_1B7A:                               ; CODE XREF: FunctionCallTip::showCalltip(void):loc_1BDEj
.text$mn:00001B7A                 mov     edx, [ebp+var_1018]
.text$mn:00001B80                 add     edx, 1
.text$mn:00001B83                 mov     [ebp+var_1018], edx
.text$mn:00001B89
.text$mn:00001B89 loc_1B89:                               ; CODE XREF: FunctionCallTip::showCalltip(void)+94j
.text$mn:00001B89                 mov     eax, [ebp+var_1018]
.text$mn:00001B8F                 cmp     eax, [ebp+var_1040]
.text$mn:00001B95                 jnb     short loc_1BE0
.text$mn:00001B97                 mov     ecx, [ebp+var_1018]
.text$mn:00001B9D                 push    ecx
.text$mn:00001B9E                 mov     ecx, [ebp+var_1008]
.text$mn:00001BA4                 add     ecx, 28h ; '('
.text$mn:00001BA7                 call    ?at@?$vector@V?$vector@PB_WV?$allocator@PB_W@std@@@std@@V?$allocator@V?$vector@PB_WV?$allocator@PB_W@std@@@std@@@2@@std@@QAEAAV?$vector@PB_WV?$allocator@PB_W@std@@@2@I@Z ; std::vector<std::vector<wchar_t const *,std::allocator<wchar_t const *>>,std::allocator<std::vector<wchar_t const *,std::allocator<wchar_t const *>>>>::at(uint)
.text$mn:00001BAC                 mov     ecx, eax
.text$mn:00001BAE                 call    ?size@?$vector@PB_WV?$allocator@PB_W@std@@@std@@QBEIXZ ; std::vector<wchar_t const *,std::allocator<wchar_t const *>>::size(void)
.text$mn:00001BB3                 add     eax, 1
.text$mn:00001BB6                 mov     [ebp+var_1028], eax
.text$mn:00001BBC                 mov     edx, [ebp+var_1008]
.text$mn:00001BC2                 mov     eax, [edx+50h]
.text$mn:00001BC5                 cmp     eax, [ebp+var_1028]
.text$mn:00001BCB                 jnb     short loc_1BDE
.text$mn:00001BCD                 mov     ecx, [ebp+var_1008]
.text$mn:00001BD3                 mov     edx, [ebp+var_1018]
.text$mn:00001BD9                 mov     [ecx+4Ch], edx
.text$mn:00001BDC                 jmp     short loc_1BE0
.text$mn:00001BDE ; ---------------------------------------------------------------------------
.text$mn:00001BDE
.text$mn:00001BDE loc_1BDE:                               ; CODE XREF: FunctionCallTip::showCalltip(void)+E7j
.text$mn:00001BDE                 jmp     short loc_1B7A
.text$mn:00001BE0 ; ---------------------------------------------------------------------------
.text$mn:00001BE0
.text$mn:00001BE0 loc_1BE0:                               ; CODE XREF: FunctionCallTip::showCalltip(void)+70j
.text$mn:00001BE0                                         ; FunctionCallTip::showCalltip(void)+B1j ...
.text$mn:00001BE0                 mov     eax, [ebp+var_1008]
.text$mn:00001BE6                 mov     ecx, [eax+4Ch]
.text$mn:00001BE9                 push    ecx
.text$mn:00001BEA                 mov     ecx, [ebp+var_1008]
.text$mn:00001BF0                 add     ecx, 18h
.text$mn:00001BF3                 call    ?at@?$vector@PB_WV?$allocator@PB_W@std@@@std@@QAEAAPB_WI@Z ; std::vector<wchar_t const *,std::allocator<wchar_t const *>>::at(uint)
.text$mn:00001BF8                 mov     edx, [eax]
.text$mn:00001BFA                 mov     [ebp+lpString], edx
.text$mn:00001C00                 mov     eax, [ebp+var_1008]
.text$mn:00001C06                 mov     ecx, [eax+4Ch]
.text$mn:00001C09                 push    ecx
.text$mn:00001C0A                 mov     ecx, [ebp+var_1008]
.text$mn:00001C10                 add     ecx, 38h ; '8'
.text$mn:00001C13                 call    ?at@?$vector@PB_WV?$allocator@PB_W@std@@@std@@QAEAAPB_WI@Z ; std::vector<wchar_t const *,std::allocator<wchar_t const *>>::at(uint)
.text$mn:00001C18                 mov     edx, [eax]
.text$mn:00001C1A                 mov     [ebp+lpString2], edx
.text$mn:00001C20                 mov     [ebp+var_1009], 1
.text$mn:00001C27                 mov     eax, 2
.text$mn:00001C2C                 imul    ecx, eax, 0
.text$mn:00001C2F                 mov     edx, [ebp+lpString2]
.text$mn:00001C35                 movzx   eax, word ptr [edx+ecx]
.text$mn:00001C39                 test    eax, eax
.text$mn:00001C3B                 jnz     short loc_1C44
.text$mn:00001C3D                 mov     [ebp+var_1009], 0
.text$mn:00001C44
.text$mn:00001C44 loc_1C44:                               ; CODE XREF: FunctionCallTip::showCalltip(void)+157j
.text$mn:00001C44                 mov     ecx, [ebp+lpString]
.text$mn:00001C4A                 push    ecx             ; lpString
.text$mn:00001C4B                 call    dword ptr ds:__imp__lstrlenW@4 ; lstrlenW(x)
.text$mn:00001C51                 mov     esi, eax
.text$mn:00001C53                 mov     edx, [ebp+var_1008]
.text$mn:00001C59                 mov     eax, [edx+14h]
.text$mn:00001C5C                 push    eax             ; lpString
.text$mn:00001C5D                 call    dword ptr ds:__imp__lstrlenW@4 ; lstrlenW(x)
.text$mn:00001C63                 lea     ecx, [esi+eax+5]
.text$mn:00001C67                 mov     [ebp+var_1010], ecx
.text$mn:00001C6D                 movzx   edx, [ebp+var_1009]
.text$mn:00001C74                 test    edx, edx
.text$mn:00001C76                 jz      short loc_1C91
.text$mn:00001C78                 mov     eax, [ebp+lpString2]
.text$mn:00001C7E                 push    eax             ; lpString
.text$mn:00001C7F                 call    dword ptr ds:__imp__lstrlenW@4 ; lstrlenW(x)
.text$mn:00001C85                 add     eax, [ebp+var_1010]
.text$mn:00001C8B                 mov     [ebp+var_1010], eax
.text$mn:00001C91
.text$mn:00001C91 loc_1C91:                               ; CODE XREF: FunctionCallTip::showCalltip(void)+192j
.text$mn:00001C91                 mov     ecx, [ebp+var_101C]
.text$mn:00001C97                 call    ?size@?$vector@PB_WV?$allocator@PB_W@std@@@std@@QBEIXZ ; std::vector<wchar_t const *,std::allocator<wchar_t const *>>::size(void)
.text$mn:00001C9C                 mov     [ebp+var_1030], eax
.text$mn:00001CA2                 mov     [ebp+var_1024], 0
.text$mn:00001CAC                 jmp     short loc_1CBD
.text$mn:00001CAE ; ---------------------------------------------------------------------------
.text$mn:00001CAE
.text$mn:00001CAE loc_1CAE:                               ; CODE XREF: FunctionCallTip::showCalltip(void)+212j
.text$mn:00001CAE                 mov     ecx, [ebp+var_1024]
.text$mn:00001CB4                 add     ecx, 1
.text$mn:00001CB7                 mov     [ebp+var_1024], ecx
.text$mn:00001CBD
.text$mn:00001CBD loc_1CBD:                               ; CODE XREF: FunctionCallTip::showCalltip(void)+1C8j
.text$mn:00001CBD                 mov     edx, [ebp+var_1024]
.text$mn:00001CC3                 cmp     edx, [ebp+var_1030]
.text$mn:00001CC9                 jnb     short loc_1CF8
.text$mn:00001CCB                 mov     eax, [ebp+var_1024]
.text$mn:00001CD1                 push    eax
.text$mn:00001CD2                 mov     ecx, [ebp+var_101C]
.text$mn:00001CD8                 call    ?at@?$vector@PB_WV?$allocator@PB_W@std@@@std@@QAEAAPB_WI@Z ; std::vector<wchar_t const *,std::allocator<wchar_t const *>>::at(uint)
.text$mn:00001CDD                 mov     ecx, [eax]
.text$mn:00001CDF                 push    ecx             ; lpString
.text$mn:00001CE0                 call    dword ptr ds:__imp__lstrlenW@4 ; lstrlenW(x)
.text$mn:00001CE6                 mov     edx, [ebp+var_1010]
.text$mn:00001CEC                 lea     eax, [edx+eax+2]
.text$mn:00001CF0                 mov     [ebp+var_1010], eax
.text$mn:00001CF6                 jmp     short loc_1CAE
.text$mn:00001CF8 ; ---------------------------------------------------------------------------
.text$mn:00001CF8
.text$mn:00001CF8 loc_1CF8:                               ; CODE XREF: FunctionCallTip::showCalltip(void)+1E5j
.text$mn:00001CF8                 mov     ecx, [ebp+var_1008]
.text$mn:00001CFE                 cmp     dword ptr [ecx+48h], 1
.text$mn:00001D02                 jle     short loc_1D13
.text$mn:00001D04                 mov     edx, [ebp+var_1010]
.text$mn:00001D0A                 add     edx, 18h
.text$mn:00001D0D                 mov     [ebp+var_1010], edx
.text$mn:00001D13
.text$mn:00001D13 loc_1D13:                               ; CODE XREF: FunctionCallTip::showCalltip(void)+21Ej
.text$mn:00001D13                 mov     [ebp+var_1044], 800h
.text$mn:00001D1D                 cmp     [ebp+var_1010], 800h
.text$mn:00001D27                 jl      short loc_1D2E
.text$mn:00001D29                 jmp     loc_1F91
.text$mn:00001D2E ; ---------------------------------------------------------------------------
.text$mn:00001D2E
.text$mn:00001D2E loc_1D2E:                               ; CODE XREF: FunctionCallTip::showCalltip(void)+243j
.text$mn:00001D2E                 mov     eax, 2
.text$mn:00001D33                 imul    ecx, eax, 0
.text$mn:00001D36                 mov     [ebp+var_103C], ecx
.text$mn:00001D3C                 cmp     [ebp+var_103C], 1000h
.text$mn:00001D46                 jnb     short loc_1D4A
.text$mn:00001D48                 jmp     short loc_1D4F
.text$mn:00001D4A ; ---------------------------------------------------------------------------
.text$mn:00001D4A
.text$mn:00001D4A loc_1D4A:                               ; CODE XREF: FunctionCallTip::showCalltip(void)+262j
.text$mn:00001D4A                 call    ___report_rangecheckfailure
.text$mn:00001D4F
.text$mn:00001D4F loc_1D4F:                               ; CODE XREF: FunctionCallTip::showCalltip(void)+264j
.text$mn:00001D4F                 xor     edx, edx
.text$mn:00001D51                 mov     eax, [ebp+var_103C]
.text$mn:00001D57                 mov     [ebp+eax+String1], dx
.text$mn:00001D5F                 mov     ecx, [ebp+var_1008]
.text$mn:00001D65                 cmp     dword ptr [ecx+48h], 1
.text$mn:00001D69                 jle     short loc_1D97
.text$mn:00001D6B                 mov     edx, [ebp+var_1008]
.text$mn:00001D71                 mov     eax, [edx+48h]
.text$mn:00001D74                 push    eax
.text$mn:00001D75                 mov     ecx, [ebp+var_1008]
.text$mn:00001D7B                 mov     edx, [ecx+4Ch]
.text$mn:00001D7E                 add     edx, 1
.text$mn:00001D81                 push    edx
.text$mn:00001D82                 push    offset $SG154403 ; LPCWSTR
.text$mn:00001D87                 lea     eax, [ebp+String1]
.text$mn:00001D8D                 push    eax             ; LPWSTR
.text$mn:00001D8E                 call    dword ptr ds:__imp__wsprintfW
.text$mn:00001D94                 add     esp, 10h
.text$mn:00001D97
.text$mn:00001D97 loc_1D97:                               ; CODE XREF: FunctionCallTip::showCalltip(void)+285j
.text$mn:00001D97                 mov     ecx, [ebp+lpString]
.text$mn:00001D9D                 push    ecx             ; lpString2
.text$mn:00001D9E                 lea     edx, [ebp+String1]
.text$mn:00001DA4                 push    edx             ; lpString1
.text$mn:00001DA5                 call    dword ptr ds:__imp__lstrcatW@8 ; lstrcatW(x,x)
.text$mn:00001DAB                 push    offset $SG154404 ; lpString2
.text$mn:00001DB0                 lea     eax, [ebp+String1]
.text$mn:00001DB6                 push    eax             ; lpString1
.text$mn:00001DB7                 call    dword ptr ds:__imp__lstrcatW@8 ; lstrcatW(x,x)
.text$mn:00001DBD                 mov     ecx, [ebp+var_1008]
.text$mn:00001DC3                 mov     edx, [ecx+14h]
.text$mn:00001DC6                 push    edx             ; lpString2
.text$mn:00001DC7                 lea     eax, [ebp+String1]
.text$mn:00001DCD                 push    eax             ; lpString1
.text$mn:00001DCE                 call    dword ptr ds:__imp__lstrcatW@8 ; lstrcatW(x,x)
.text$mn:00001DD4                 push    offset $SG154405 ; " ("
.text$mn:00001DD9                 lea     ecx, [ebp+String1]
.text$mn:00001DDF                 push    ecx             ; lpString1
.text$mn:00001DE0                 call    dword ptr ds:__imp__lstrcatW@8 ; lstrcatW(x,x)
.text$mn:00001DE6                 mov     [ebp+var_1020], 0
.text$mn:00001DF0                 mov     [ebp+var_102C], 0
.text$mn:00001DFA                 mov     [ebp+var_1014], 0
.text$mn:00001E04                 jmp     short loc_1E15
.text$mn:00001E06 ; ---------------------------------------------------------------------------
.text$mn:00001E06
.text$mn:00001E06 loc_1E06:                               ; CODE XREF: FunctionCallTip::showCalltip(void):loc_1EB7j
.text$mn:00001E06                 mov     edx, [ebp+var_1014]
.text$mn:00001E0C                 add     edx, 1
.text$mn:00001E0F                 mov     [ebp+var_1014], edx
.text$mn:00001E15
.text$mn:00001E15 loc_1E15:                               ; CODE XREF: FunctionCallTip::showCalltip(void)+320j
.text$mn:00001E15                 mov     eax, [ebp+var_1014]
.text$mn:00001E1B                 cmp     eax, [ebp+var_1030]
.text$mn:00001E21                 jnb     loc_1EBC
.text$mn:00001E27                 mov     ecx, [ebp+var_1008]
.text$mn:00001E2D                 mov     edx, [ebp+var_1014]
.text$mn:00001E33                 cmp     edx, [ecx+50h]
.text$mn:00001E36                 jnz     short loc_1E72
.text$mn:00001E38                 lea     eax, [ebp+String1]
.text$mn:00001E3E                 push    eax             ; lpString
.text$mn:00001E3F                 call    dword ptr ds:__imp__lstrlenW@4 ; lstrlenW(x)
.text$mn:00001E45                 mov     [ebp+var_1020], eax
.text$mn:00001E4B                 mov     ecx, [ebp+var_1014]
.text$mn:00001E51                 push    ecx
.text$mn:00001E52                 mov     ecx, [ebp+var_101C]
.text$mn:00001E58                 call    ?at@?$vector@PB_WV?$allocator@PB_W@std@@@std@@QAEAAPB_WI@Z ; std::vector<wchar_t const *,std::allocator<wchar_t const *>>::at(uint)
.text$mn:00001E5D                 mov     edx, [eax]
.text$mn:00001E5F                 push    edx             ; lpString
.text$mn:00001E60                 call    dword ptr ds:__imp__lstrlenW@4 ; lstrlenW(x)
.text$mn:00001E66                 add     eax, [ebp+var_1020]
.text$mn:00001E6C                 mov     [ebp+var_102C], eax
.text$mn:00001E72
.text$mn:00001E72 loc_1E72:                               ; CODE XREF: FunctionCallTip::showCalltip(void)+352j
.text$mn:00001E72                 mov     eax, [ebp+var_1014]
.text$mn:00001E78                 push    eax
.text$mn:00001E79                 mov     ecx, [ebp+var_101C]
.text$mn:00001E7F                 call    ?at@?$vector@PB_WV?$allocator@PB_W@std@@@std@@QAEAAPB_WI@Z ; std::vector<wchar_t const *,std::allocator<wchar_t const *>>::at(uint)
.text$mn:00001E84                 mov     ecx, [eax]
.text$mn:00001E86                 push    ecx             ; lpString2
.text$mn:00001E87                 lea     edx, [ebp+String1]
.text$mn:00001E8D                 push    edx             ; lpString1
.text$mn:00001E8E                 call    dword ptr ds:__imp__lstrcatW@8 ; lstrcatW(x,x)
.text$mn:00001E94                 mov     eax, [ebp+var_1030]
.text$mn:00001E9A                 sub     eax, 1
.text$mn:00001E9D                 cmp     [ebp+var_1014], eax
.text$mn:00001EA3                 jnb     short loc_1EB7
.text$mn:00001EA5                 push    offset $SG154414 ; ", "
.text$mn:00001EAA                 lea     ecx, [ebp+String1]
.text$mn:00001EB0                 push    ecx             ; lpString1
.text$mn:00001EB1                 call    dword ptr ds:__imp__lstrcatW@8 ; lstrcatW(x,x)
.text$mn:00001EB7
.text$mn:00001EB7 loc_1EB7:                               ; CODE XREF: FunctionCallTip::showCalltip(void)+3BFj
.text$mn:00001EB7                 jmp     loc_1E06
.text$mn:00001EBC ; ---------------------------------------------------------------------------
.text$mn:00001EBC
.text$mn:00001EBC loc_1EBC:                               ; CODE XREF: FunctionCallTip::showCalltip(void)+33Dj
.text$mn:00001EBC                 push    offset $SG154415 ; lpString2
.text$mn:00001EC1                 lea     edx, [ebp+String1]
.text$mn:00001EC7                 push    edx             ; lpString1
.text$mn:00001EC8                 call    dword ptr ds:__imp__lstrcatW@8 ; lstrcatW(x,x)
.text$mn:00001ECE                 movzx   eax, [ebp+var_1009]
.text$mn:00001ED5                 test    eax, eax
.text$mn:00001ED7                 jz      short loc_1EFF
.text$mn:00001ED9                 push    offset $SG154417 ; lpString2
.text$mn:00001EDE                 lea     ecx, [ebp+String1]
.text$mn:00001EE4                 push    ecx             ; lpString1
.text$mn:00001EE5                 call    dword ptr ds:__imp__lstrcatW@8 ; lstrcatW(x,x)
.text$mn:00001EEB                 mov     edx, [ebp+lpString2]
.text$mn:00001EF1                 push    edx             ; lpString2
.text$mn:00001EF2                 lea     eax, [ebp+String1]
.text$mn:00001EF8                 push    eax             ; lpString1
.text$mn:00001EF9                 call    dword ptr ds:__imp__lstrcatW@8 ; lstrcatW(x,x)
.text$mn:00001EFF
.text$mn:00001EFF loc_1EFF:                               ; CODE XREF: FunctionCallTip::showCalltip(void)+3F3j
.text$mn:00001EFF                 mov     ecx, [ebp+var_1008] ; this
.text$mn:00001F05                 call    ?isVisible@FunctionCallTip@@QAE_NXZ ; FunctionCallTip::isVisible(void)
.text$mn:00001F0A                 movzx   ecx, al
.text$mn:00001F0D                 test    ecx, ecx
.text$mn:00001F0F                 jz      short loc_1F29
.text$mn:00001F11                 push    0               ; __int32
.text$mn:00001F13                 push    0               ; unsigned int
.text$mn:00001F15                 push    899h            ; unsigned int
.text$mn:00001F1A                 mov     edx, [ebp+var_1008]
.text$mn:00001F20                 mov     ecx, [edx]      ; this
.text$mn:00001F22                 call    ?execute@ScintillaEditView@@QBEJIIJ@Z ; ScintillaEditView::execute(uint,uint,long)
.text$mn:00001F27                 jmp     short loc_1F3B
.text$mn:00001F29 ; ---------------------------------------------------------------------------
.text$mn:00001F29
.text$mn:00001F29 loc_1F29:                               ; CODE XREF: FunctionCallTip::showCalltip(void)+42Bj
.text$mn:00001F29                 mov     eax, [ebp+var_1008]
.text$mn:00001F2F                 mov     ecx, [ebp+var_1008]
.text$mn:00001F35                 mov     edx, [ecx+8]
.text$mn:00001F38                 mov     [eax+0Ch], edx
.text$mn:00001F3B
.text$mn:00001F3B loc_1F3B:                               ; CODE XREF: FunctionCallTip::showCalltip(void)+443j
.text$mn:00001F3B                 lea     eax, [ebp+String1]
.text$mn:00001F41                 push    eax             ; wchar_t *
.text$mn:00001F42                 mov     ecx, [ebp+var_1008]
.text$mn:00001F48                 mov     edx, [ecx+0Ch]
.text$mn:00001F4B                 push    edx             ; int
.text$mn:00001F4C                 mov     eax, [ebp+var_1008]
.text$mn:00001F52                 mov     ecx, [eax]      ; this
.text$mn:00001F54                 call    ?showCallTip@ScintillaEditView@@QAEXHPB_W@Z ; ScintillaEditView::showCallTip(int,wchar_t const *)
.text$mn:00001F59                 mov     ecx, [ebp+var_1008]
.text$mn:00001F5F                 mov     byte ptr [ecx+79h], 1
.text$mn:00001F63                 mov     edx, [ebp+var_1020]
.text$mn:00001F69                 cmp     edx, [ebp+var_102C]
.text$mn:00001F6F                 jz      short loc_1F91
.text$mn:00001F71                 mov     eax, [ebp+var_102C]
.text$mn:00001F77                 push    eax             ; __int32
.text$mn:00001F78                 mov     ecx, [ebp+var_1020]
.text$mn:00001F7E                 push    ecx             ; unsigned int
.text$mn:00001F7F                 push    89Ch            ; unsigned int
.text$mn:00001F84                 mov     edx, [ebp+var_1008]
.text$mn:00001F8A                 mov     ecx, [edx]      ; this
.text$mn:00001F8C                 call    ?execute@ScintillaEditView@@QBEJIIJ@Z ; ScintillaEditView::execute(uint,uint,long)
.text$mn:00001F91
.text$mn:00001F91 loc_1F91:                               ; CODE XREF: FunctionCallTip::showCalltip(void)+2Aj
.text$mn:00001F91                                         ; FunctionCallTip::showCalltip(void)+245j ...
.text$mn:00001F91                 pop     esi
.text$mn:00001F92                 mov     ecx, [ebp+var_4]
.text$mn:00001F95                 xor     ecx, ebp
.text$mn:00001F97                 call    @__security_check_cookie@4 ; __security_check_cookie(x)
.text$mn:00001F9C                 mov     esp, ebp
.text$mn:00001F9E                 pop     ebp
.text$mn:00001F9F                 retn
.text$mn:00001F9F ?showCalltip@FunctionCallTip@@AAEXXZ endp
.text$mn:00001F9F
.text$mn:00001F9F ; ---------------------------------------------------------------------------
.text$mn:00001FA0                 db 4 dup(0CCh)
.text$mn:00001FA4
.text$mn:00001FA4 ; =============== S U B R O U T I N E =======================================
.text$mn:00001FA4
.text$mn:00001FA4 ; Attributes: bp-based frame
.text$mn:00001FA4
.text$mn:00001FA4 ; void __thiscall FunctionCallTip::reset(FunctionCallTip *__hidden this)
.text$mn:00001FA4                 public ?reset@FunctionCallTip@@AAEXXZ
.text$mn:00001FA4 ?reset@FunctionCallTip@@AAEXXZ proc near
.text$mn:00001FA4                                         ; CODE XREF: FunctionCallTip::setLanguageXML(TiXmlElement *)+2Cp
.text$mn:00001FA4                                         ; FunctionCallTip::getCursorFunction(void)+E6p ...
.text$mn:00001FA4
.text$mn:00001FA4 var_4           = dword ptr -4
.text$mn:00001FA4
.text$mn:00001FA4                 push    ebp
.text$mn:00001FA5                 mov     ebp, esp
.text$mn:00001FA7                 push    ecx
.text$mn:00001FA8                 mov     [ebp+var_4], ecx
.text$mn:00001FAB                 mov     eax, [ebp+var_4]
.text$mn:00001FAE                 mov     dword ptr [eax+4Ch], 0
.text$mn:00001FB5                 mov     ecx, [ebp+var_4]
.text$mn:00001FB8                 mov     dword ptr [ecx+50h], 0
.text$mn:00001FBF                 mov     edx, [ebp+var_4]
.text$mn:00001FC2                 mov     dword ptr [edx+0Ch], 0
.text$mn:00001FC9                 mov     ecx, [ebp+var_4]
.text$mn:00001FCC                 add     ecx, 28h ; '('
.text$mn:00001FCF                 call    ?clear@?$vector@V?$vector@PB_WV?$allocator@PB_W@std@@@std@@V?$allocator@V?$vector@PB_WV?$allocator@PB_W@std@@@std@@@2@@std@@QAEXXZ ; std::vector<std::vector<wchar_t const *,std::allocator<wchar_t const *>>,std::allocator<std::vector<wchar_t const *,std::allocator<wchar_t const *>>>>::clear(void)
.text$mn:00001FD4                 mov     eax, [ebp+var_4]
.text$mn:00001FD7                 mov     dword ptr [eax+48h], 0
.text$mn:00001FDE                 mov     ecx, [ebp+var_4]
.text$mn:00001FE1                 add     ecx, 18h
.text$mn:00001FE4                 call    ?clear@?$vector@PB_WV?$allocator@PB_W@std@@@std@@QAEXXZ ; std::vector<wchar_t const *,std::allocator<wchar_t const *>>::clear(void)
.text$mn:00001FE9                 mov     ecx, [ebp+var_4]
.text$mn:00001FEC                 add     ecx, 38h ; '8'
.text$mn:00001FEF                 call    ?clear@?$vector@PB_WV?$allocator@PB_W@std@@@std@@QAEXXZ ; std::vector<wchar_t const *,std::allocator<wchar_t const *>>::clear(void)
.text$mn:00001FF4                 mov     esp, ebp
.text$mn:00001FF6                 pop     ebp
.text$mn:00001FF7                 retn
.text$mn:00001FF7 ?reset@FunctionCallTip@@AAEXXZ endp
.text$mn:00001FF7
.text$mn:00001FF7 ; ---------------------------------------------------------------------------
.text$mn:00001FF8                 db 0Ch dup(0CCh)
.text$mn:00002004
.text$mn:00002004 ; =============== S U B R O U T I N E =======================================
.text$mn:00002004
.text$mn:00002004 ; Attributes: bp-based frame
.text$mn:00002004
.text$mn:00002004 ; void __thiscall FunctionCallTip::cleanup(FunctionCallTip *__hidden this)
.text$mn:00002004                 public ?cleanup@FunctionCallTip@@AAEXXZ
.text$mn:00002004 ?cleanup@FunctionCallTip@@AAEXXZ proc near
.text$mn:00002004
.text$mn:00002004 var_8           = dword ptr -8
.text$mn:00002004 var_4           = dword ptr -4
.text$mn:00002004
.text$mn:00002004                 push    ebp
.text$mn:00002005                 mov     ebp, esp
.text$mn:00002007                 sub     esp, 8
.text$mn:0000200A                 mov     [ebp+var_4], ecx
.text$mn:0000200D                 mov     ecx, [ebp+var_4] ; this
.text$mn:00002010                 call    ?reset@FunctionCallTip@@AAEXXZ ; FunctionCallTip::reset(void)
.text$mn:00002015                 mov     eax, [ebp+var_4]
.text$mn:00002018                 cmp     dword ptr [eax+14h], 0
.text$mn:0000201C                 jz      short loc_2033
.text$mn:0000201E                 mov     ecx, [ebp+var_4]
.text$mn:00002021                 mov     edx, [ecx+14h]
.text$mn:00002024                 mov     [ebp+var_8], edx
.text$mn:00002027                 mov     eax, [ebp+var_8]
.text$mn:0000202A                 push    eax             ; void *
.text$mn:0000202B                 call    ??_V@YAXPAX@Z   ; operator delete[](void *)
.text$mn:00002030                 add     esp, 4
.text$mn:00002033
.text$mn:00002033 loc_2033:                               ; CODE XREF: FunctionCallTip::cleanup(void)+18j
.text$mn:00002033                 mov     ecx, [ebp+var_4]
.text$mn:00002036                 mov     dword ptr [ecx+14h], 0
.text$mn:0000203D                 mov     edx, [ebp+var_4]
.text$mn:00002040                 mov     dword ptr [edx], 0
.text$mn:00002046                 mov     esp, ebp
.text$mn:00002048                 pop     ebp
.text$mn:00002049                 retn
.text$mn:00002049 ?cleanup@FunctionCallTip@@AAEXXZ endp
.text$mn:00002049
.text$mn:00002049 ; ---------------------------------------------------------------------------
.text$mn:0000204A                 db 0Ah dup(0CCh)
.text$mn:00002054
.text$mn:00002054 ; =============== S U B R O U T I N E =======================================
.text$mn:00002054
.text$mn:00002054 ; Attributes: bp-based frame
.text$mn:00002054
.text$mn:00002054 ; int __cdecl testNameNoCase(const wchar_t *, const wchar_t *, int)
.text$mn:00002054                 public ?testNameNoCase@@YAHPB_W0H@Z
.text$mn:00002054 ?testNameNoCase@@YAHPB_W0H@Z proc near  ; CODE XREF: FunctionCallTip::getCursorFunction(void)+6CCp
.text$mn:00002054                                         ; FunctionCallTip::loadFunction(void)+9Dp
.text$mn:00002054
.text$mn:00002054 var_14          = dword ptr -14h
.text$mn:00002054 var_10          = dword ptr -10h
.text$mn:00002054 var_C           = dword ptr -0Ch
.text$mn:00002054 var_8           = dword ptr -8
.text$mn:00002054 var_4           = dword ptr -4
.text$mn:00002054 arg_0           = dword ptr  8
.text$mn:00002054 arg_4           = dword ptr  0Ch
.text$mn:00002054 arg_8           = dword ptr  10h
.text$mn:00002054
.text$mn:00002054                 push    ebp
.text$mn:00002055                 mov     ebp, esp
.text$mn:00002057                 sub     esp, 14h
.text$mn:0000205A                 cmp     [ebp+arg_8], 0FFFFFFFFh
.text$mn:0000205E                 jnz     short loc_2067
.text$mn:00002060                 mov     [ebp+arg_8], 400h
.text$mn:00002067
.text$mn:00002067 loc_2067:                               ; CODE XREF: testNameNoCase(wchar_t const *,wchar_t const *,int)+Aj
.text$mn:00002067                 mov     [ebp+var_4], 0
.text$mn:0000206E
.text$mn:0000206E loc_206E:                               ; CODE XREF: testNameNoCase(wchar_t const *,wchar_t const *,int)+65j
.text$mn:0000206E                 mov     eax, [ebp+var_4]
.text$mn:00002071                 mov     ecx, [ebp+arg_4]
.text$mn:00002074                 movzx   edx, word ptr [ecx+eax*2]
.text$mn:00002078                 push    edx             ; wchar_t
.text$mn:00002079                 mov     eax, [ebp+var_4]
.text$mn:0000207C                 mov     ecx, [ebp+arg_0]
.text$mn:0000207F                 movzx   edx, word ptr [ecx+eax*2]
.text$mn:00002083                 push    edx             ; wchar_t
.text$mn:00002084                 call    ?match@@YA_N_W0@Z ; match(wchar_t,wchar_t)
.text$mn:00002089                 add     esp, 8
.text$mn:0000208C                 movzx   eax, al
.text$mn:0000208F                 test    eax, eax
.text$mn:00002091                 jz      short loc_20BB
.text$mn:00002093                 mov     ecx, [ebp+var_4]
.text$mn:00002096                 mov     edx, [ebp+arg_0]
.text$mn:00002099                 movzx   eax, word ptr [edx+ecx*2]
.text$mn:0000209D                 test    eax, eax
.text$mn:0000209F                 jz      short loc_20A9
.text$mn:000020A1                 mov     ecx, [ebp+var_4]
.text$mn:000020A4                 cmp     ecx, [ebp+arg_8]
.text$mn:000020A7                 jnz     short loc_20B0
.text$mn:000020A9
.text$mn:000020A9 loc_20A9:                               ; CODE XREF: testNameNoCase(wchar_t const *,wchar_t const *,int)+4Bj
.text$mn:000020A9                 xor     eax, eax
.text$mn:000020AB                 jmp     loc_2137
.text$mn:000020B0 ; ---------------------------------------------------------------------------
.text$mn:000020B0
.text$mn:000020B0 loc_20B0:                               ; CODE XREF: testNameNoCase(wchar_t const *,wchar_t const *,int)+53j
.text$mn:000020B0                 mov     edx, [ebp+var_4]
.text$mn:000020B3                 add     edx, 1
.text$mn:000020B6                 mov     [ebp+var_4], edx
.text$mn:000020B9                 jmp     short loc_206E
.text$mn:000020BB ; ---------------------------------------------------------------------------
.text$mn:000020BB
.text$mn:000020BB loc_20BB:                               ; CODE XREF: testNameNoCase(wchar_t const *,wchar_t const *,int)+3Dj
.text$mn:000020BB                 mov     eax, [ebp+var_4]
.text$mn:000020BE                 mov     ecx, [ebp+arg_0]
.text$mn:000020C1                 movzx   edx, word ptr [ecx+eax*2]
.text$mn:000020C5                 push    edx             ; wchar_t
.text$mn:000020C6                 call    ?lower@@YA_N_W@Z ; lower(wchar_t)
.text$mn:000020CB                 add     esp, 4
.text$mn:000020CE                 movzx   eax, al
.text$mn:000020D1                 test    eax, eax
.text$mn:000020D3                 jz      short loc_20DE
.text$mn:000020D5                 mov     [ebp+var_8], 20h ; ' '
.text$mn:000020DC                 jmp     short loc_20E5
.text$mn:000020DE ; ---------------------------------------------------------------------------
.text$mn:000020DE
.text$mn:000020DE loc_20DE:                               ; CODE XREF: testNameNoCase(wchar_t const *,wchar_t const *,int)+7Fj
.text$mn:000020DE                 mov     [ebp+var_8], 0
.text$mn:000020E5
.text$mn:000020E5 loc_20E5:                               ; CODE XREF: testNameNoCase(wchar_t const *,wchar_t const *,int)+88j
.text$mn:000020E5                 mov     ecx, [ebp+var_8]
.text$mn:000020E8                 mov     [ebp+var_10], ecx
.text$mn:000020EB                 mov     edx, [ebp+var_4]
.text$mn:000020EE                 mov     eax, [ebp+arg_4]
.text$mn:000020F1                 movzx   ecx, word ptr [eax+edx*2]
.text$mn:000020F5                 push    ecx             ; wchar_t
.text$mn:000020F6                 call    ?lower@@YA_N_W@Z ; lower(wchar_t)
.text$mn:000020FB                 add     esp, 4
.text$mn:000020FE                 movzx   edx, al
.text$mn:00002101                 test    edx, edx
.text$mn:00002103                 jz      short loc_210E
.text$mn:00002105                 mov     [ebp+var_C], 20h ; ' '
.text$mn:0000210C                 jmp     short loc_2115
.text$mn:0000210E ; ---------------------------------------------------------------------------
.text$mn:0000210E
.text$mn:0000210E loc_210E:                               ; CODE XREF: testNameNoCase(wchar_t const *,wchar_t const *,int)+AFj
.text$mn:0000210E                 mov     [ebp+var_C], 0
.text$mn:00002115
.text$mn:00002115 loc_2115:                               ; CODE XREF: testNameNoCase(wchar_t const *,wchar_t const *,int)+B8j
.text$mn:00002115                 mov     eax, [ebp+var_C]
.text$mn:00002118                 mov     [ebp+var_14], eax
.text$mn:0000211B                 mov     ecx, [ebp+var_4]
.text$mn:0000211E                 mov     edx, [ebp+arg_0]
.text$mn:00002121                 movzx   eax, word ptr [edx+ecx*2]
.text$mn:00002125                 sub     eax, [ebp+var_10]
.text$mn:00002128                 mov     ecx, [ebp+var_4]
.text$mn:0000212B                 mov     edx, [ebp+arg_4]
.text$mn:0000212E                 movzx   ecx, word ptr [edx+ecx*2]
.text$mn:00002132                 sub     ecx, [ebp+var_14]
.text$mn:00002135                 sub     eax, ecx
.text$mn:00002137
.text$mn:00002137 loc_2137:                               ; CODE XREF: testNameNoCase(wchar_t const *,wchar_t const *,int)+57j
.text$mn:00002137                 mov     esp, ebp
.text$mn:00002139                 pop     ebp
.text$mn:0000213A                 retn
.text$mn:0000213A ?testNameNoCase@@YAHPB_W0H@Z endp
.text$mn:0000213A
.text$mn:0000213A ; ---------------------------------------------------------------------------
.text$mn:0000213B                 align 4
.text$mn:0000213B _text$mn        ends
.text$mn:0000213B
.text$x:0000213C ; ===========================================================================
.text$x:0000213C
.text$x:0000213C ; Segment type: Pure code
.text$x:0000213C ; Segment permissions: Read/Execute
.text$x:0000213C _text$x         segment para public 'CODE' use32
.text$x:0000213C                 assume cs:_text$x
.text$x:0000213C                 ;org 213Ch
.text$x:0000213C                 assume es:nothing, ss:nothing, ds:_data, fs:nothing, gs:nothing
.text$x:0000213C
.text$x:0000213C ; =============== S U B R O U T I N E =======================================
.text$x:0000213C
.text$x:0000213C
.text$x:0000213C __unwindfunclet$?getCursorFunction@FunctionCallTip@@AAE_NXZ$0 proc near
.text$x:0000213C                                         ; DATA XREF: .xdata$x:00009960o
.text$x:0000213C                 lea     ecx, [ebp-29Ch]
.text$x:00002142                 jmp     ??1?$vector@UToken@@V?$allocator@UToken@@@std@@@std@@QAE@XZ ; std::vector<Token,std::allocator<Token>>::~vector<Token,std::allocator<Token>>(void)
.text$x:00002142 __unwindfunclet$?getCursorFunction@FunctionCallTip@@AAE_NXZ$0 endp
.text$x:00002142
.text$x:00002147
.text$x:00002147 ; =============== S U B R O U T I N E =======================================
.text$x:00002147
.text$x:00002147
.text$x:00002147 __unwindfunclet$?getCursorFunction@FunctionCallTip@@AAE_NXZ$1 proc near
.text$x:00002147                                         ; DATA XREF: .xdata$x:00009968o
.text$x:00002147                 lea     ecx, [ebp-278h]
.text$x:0000214D                 jmp     ??1?$vector@UFunctionValues@@V?$allocator@UFunctionValues@@@std@@@std@@QAE@XZ ; std::vector<FunctionValues,std::allocator<FunctionValues>>::~vector<FunctionValues,std::allocator<FunctionValues>>(void)
.text$x:0000214D __unwindfunclet$?getCursorFunction@FunctionCallTip@@AAE_NXZ$1 endp
.text$x:0000214D
.text$x:00002152
.text$x:00002152 ; =============== S U B R O U T I N E =======================================
.text$x:00002152
.text$x:00002152
.text$x:00002152 __ehhandler$?getCursorFunction@FunctionCallTip@@AAE_NXZ proc near
.text$x:00002152                                         ; DATA XREF: FunctionCallTip::getCursorFunction(void)+5o
.text$x:00002152
.text$x:00002152 arg_4           = dword ptr  8
.text$x:00002152
.text$x:00002152                 mov     edx, [esp+arg_4]
.text$x:00002156                 lea     eax, [edx+0Ch]
.text$x:00002159                 mov     ecx, [edx-2E0h]
.text$x:0000215F                 xor     ecx, eax
.text$x:00002161                 call    @__security_check_cookie@4 ; __security_check_cookie(x)
.text$x:00002166                 mov     ecx, [edx-4]
.text$x:00002169                 xor     ecx, eax
.text$x:0000216B                 call    @__security_check_cookie@4 ; __security_check_cookie(x)
.text$x:00002170                 mov     eax, offset __ehfuncinfo$?getCursorFunction@FunctionCallTip@@AAE_NXZ
.text$x:00002175                 jmp     ___CxxFrameHandler3
.text$x:00002175 __ehhandler$?getCursorFunction@FunctionCallTip@@AAE_NXZ endp
.text$x:00002175
.text$x:0000217A
.text$x:0000217A ; =============== S U B R O U T I N E =======================================
.text$x:0000217A
.text$x:0000217A
.text$x:0000217A __unwindfunclet$?loadFunction@FunctionCallTip@@AAE_NXZ$0 proc near
.text$x:0000217A                                         ; DATA XREF: .xdata$x:00009958o
.text$x:0000217A                 lea     ecx, [ebp-4Ch]
.text$x:0000217D                 jmp     ??1?$vector@PB_WV?$allocator@PB_W@std@@@std@@QAE@XZ ; std::vector<wchar_t const *,std::allocator<wchar_t const *>>::~vector<wchar_t const *,std::allocator<wchar_t const *>>(void)
.text$x:0000217D __unwindfunclet$?loadFunction@FunctionCallTip@@AAE_NXZ$0 endp
.text$x:0000217D
.text$x:00002182
.text$x:00002182 ; =============== S U B R O U T I N E =======================================
.text$x:00002182
.text$x:00002182
.text$x:00002182 __ehhandler$?loadFunction@FunctionCallTip@@AAE_NXZ proc near
.text$x:00002182                                         ; DATA XREF: FunctionCallTip::loadFunction(void)+5o
.text$x:00002182
.text$x:00002182 arg_4           = dword ptr  8
.text$x:00002182
.text$x:00002182                 mov     edx, [esp+arg_4]
.text$x:00002186                 lea     eax, [edx+0Ch]
.text$x:00002189                 mov     ecx, [edx-44h]
.text$x:0000218C                 xor     ecx, eax
.text$x:0000218E                 call    @__security_check_cookie@4 ; __security_check_cookie(x)
.text$x:00002193                 mov     eax, offset __ehfuncinfo$?loadFunction@FunctionCallTip@@AAE_NXZ
.text$x:00002198                 jmp     ___CxxFrameHandler3
.text$x:00002198 __ehhandler$?loadFunction@FunctionCallTip@@AAE_NXZ endp
.text$x:00002198
.text$x:00002198 ; ---------------------------------------------------------------------------
.text$x:0000219D                 align 10h
.text$x:0000219D _text$x         ends
.text$x:0000219D
.text$mn:000021A0 ; ===========================================================================
.text$mn:000021A0
.text$mn:000021A0 ; Segment type: Pure code
.text$mn:000021A0 ; Segment permissions: Read/Execute
.text$mn:000021A0 _text$mn        segment para public 'CODE' use32
.text$mn:000021A0                 assume cs:_text$mn
.text$mn:000021A0                 ;org 21A0h
.text$mn:000021A0 ; COMDAT (pick any)
.text$mn:000021A0                 assume es:nothing, ss:nothing, ds:_data, fs:nothing, gs:nothing
.text$mn:000021A0
.text$mn:000021A0 ; =============== S U B R O U T I N E =======================================
.text$mn:000021A0
.text$mn:000021A0 ; Attributes: bp-based frame
.text$mn:000021A0
.text$mn:000021A0 ; char * __cdecl std::_Allocate<char>(unsigned int, char *)
.text$mn:000021A0                 public ??$_Allocate@D@std@@YAPADIPAD@Z
.text$mn:000021A0 ??$_Allocate@D@std@@YAPADIPAD@Z proc near
.text$mn:000021A0                                         ; CODE XREF: std::allocator<char>::allocate(uint)+Dp
.text$mn:000021A0
.text$mn:000021A0 var_4           = dword ptr -4
.text$mn:000021A0 arg_0           = dword ptr  8
.text$mn:000021A0
.text$mn:000021A0                 push    ebp
.text$mn:000021A1                 mov     ebp, esp
.text$mn:000021A3                 push    ecx
.text$mn:000021A4                 mov     [ebp+var_4], 0
.text$mn:000021AB                 cmp     [ebp+arg_0], 0
.text$mn:000021AF                 jnz     short loc_21B3
.text$mn:000021B1                 jmp     short loc_21D3
.text$mn:000021B3 ; ---------------------------------------------------------------------------
.text$mn:000021B3
.text$mn:000021B3 loc_21B3:                               ; CODE XREF: std::_Allocate<char>(uint,char *)+Fj
.text$mn:000021B3                 cmp     [ebp+arg_0], 0FFFFFFFFh
.text$mn:000021B7                 ja      short loc_21CE
.text$mn:000021B9                 mov     eax, [ebp+arg_0]
.text$mn:000021BC                 push    eax             ; unsigned int
.text$mn:000021BD                 call    ??2@YAPAXI@Z    ; operator new(uint)
.text$mn:000021C2                 add     esp, 4
.text$mn:000021C5                 mov     [ebp+var_4], eax
.text$mn:000021C8                 cmp     [ebp+var_4], 0
.text$mn:000021CC                 jnz     short loc_21D3
.text$mn:000021CE
.text$mn:000021CE loc_21CE:                               ; CODE XREF: std::_Allocate<char>(uint,char *)+17j
.text$mn:000021CE                 call    ?_Xbad_alloc@std@@YAXXZ ; std::_Xbad_alloc(void)
.text$mn:000021D3
.text$mn:000021D3 loc_21D3:                               ; CODE XREF: std::_Allocate<char>(uint,char *)+11j
.text$mn:000021D3                                         ; std::_Allocate<char>(uint,char *)+2Cj
.text$mn:000021D3                 mov     eax, [ebp+var_4]
.text$mn:000021D6                 mov     esp, ebp
.text$mn:000021D8                 pop     ebp
.text$mn:000021D9                 retn
.text$mn:000021D9 ??$_Allocate@D@std@@YAPADIPAD@Z endp
.text$mn:000021D9
.text$mn:000021D9 ; ---------------------------------------------------------------------------
.text$mn:000021DA                 align 4
.text$mn:000021DA _text$mn        ends
.text$mn:000021DA
.text$mn:000021DC ; ===========================================================================
.text$mn:000021DC
.text$mn:000021DC ; Segment type: Pure code
.text$mn:000021DC ; Segment permissions: Read/Execute
.text$mn:000021DC _text$mn        segment para public 'CODE' use32
.text$mn:000021DC                 assume cs:_text$mn
.text$mn:000021DC                 ;org 21DCh
.text$mn:000021DC ; COMDAT (pick any)
.text$mn:000021DC                 assume es:nothing, ss:nothing, ds:_data, fs:nothing, gs:nothing
.text$mn:000021DC
.text$mn:000021DC ; =============== S U B R O U T I N E =======================================
.text$mn:000021DC
.text$mn:000021DC ; Attributes: bp-based frame
.text$mn:000021DC
.text$mn:000021DC ; wchar_t const * * __cdecl std::_Allocate<wchar_t const *>(unsigned int, wchar_t const * *)
.text$mn:000021DC                 public ??$_Allocate@PB_W@std@@YAPAPB_WIPAPB_W@Z
.text$mn:000021DC ??$_Allocate@PB_W@std@@YAPAPB_WIPAPB_W@Z proc near
.text$mn:000021DC                                         ; CODE XREF: std::allocator<wchar_t const *>::allocate(uint)+Dp
.text$mn:000021DC
.text$mn:000021DC var_4           = dword ptr -4
.text$mn:000021DC arg_0           = dword ptr  8
.text$mn:000021DC
.text$mn:000021DC                 push    ebp
.text$mn:000021DD                 mov     ebp, esp
.text$mn:000021DF                 push    ecx
.text$mn:000021E0                 mov     [ebp+var_4], 0
.text$mn:000021E7                 cmp     [ebp+arg_0], 0
.text$mn:000021EB                 jnz     short loc_21EF
.text$mn:000021ED                 jmp     short loc_2215
.text$mn:000021EF ; ---------------------------------------------------------------------------
.text$mn:000021EF
.text$mn:000021EF loc_21EF:                               ; CODE XREF: std::_Allocate<wchar_t const *>(uint,wchar_t const * *)+Fj
.text$mn:000021EF                 cmp     [ebp+arg_0], 3FFFFFFFh
.text$mn:000021F6                 ja      short loc_2210
.text$mn:000021F8                 mov     eax, [ebp+arg_0]
.text$mn:000021FB                 shl     eax, 2
.text$mn:000021FE                 push    eax             ; unsigned int
.text$mn:000021FF                 call    ??2@YAPAXI@Z    ; operator new(uint)
.text$mn:00002204                 add     esp, 4
.text$mn:00002207                 mov     [ebp+var_4], eax
.text$mn:0000220A                 cmp     [ebp+var_4], 0
.text$mn:0000220E                 jnz     short loc_2215
.text$mn:00002210
.text$mn:00002210 loc_2210:                               ; CODE XREF: std::_Allocate<wchar_t const *>(uint,wchar_t const * *)+1Aj
.text$mn:00002210                 call    ?_Xbad_alloc@std@@YAXXZ ; std::_Xbad_alloc(void)
.text$mn:00002215
.text$mn:00002215 loc_2215:                               ; CODE XREF: std::_Allocate<wchar_t const *>(uint,wchar_t const * *)+11j
.text$mn:00002215                                         ; std::_Allocate<wchar_t const *>(uint,wchar_t const * *)+32j
.text$mn:00002215                 mov     eax, [ebp+var_4]
.text$mn:00002218                 mov     esp, ebp
.text$mn:0000221A                 pop     ebp
.text$mn:0000221B                 retn
.text$mn:0000221B ??$_Allocate@PB_W@std@@YAPAPB_WIPAPB_W@Z endp
.text$mn:0000221B
.text$mn:0000221B _text$mn        ends
.text$mn:0000221B
.text$mn:0000221C ; ===========================================================================
.text$mn:0000221C
.text$mn:0000221C ; Segment type: Pure code
.text$mn:0000221C ; Segment permissions: Read/Execute
.text$mn:0000221C _text$mn        segment para public 'CODE' use32
.text$mn:0000221C                 assume cs:_text$mn
.text$mn:0000221C                 ;org 221Ch
.text$mn:0000221C ; COMDAT (pick any)
.text$mn:0000221C                 assume es:nothing, ss:nothing, ds:_data, fs:nothing, gs:nothing
.text$mn:0000221C
.text$mn:0000221C ; =============== S U B R O U T I N E =======================================
.text$mn:0000221C
.text$mn:0000221C ; Attributes: bp-based frame
.text$mn:0000221C
.text$mn:0000221C ; struct FunctionValues * __cdecl std::_Allocate<struct FunctionValues>(unsigned int, struct FunctionValues *)
.text$mn:0000221C                 public ??$_Allocate@UFunctionValues@@@std@@YAPAUFunctionValues@@IPAU1@@Z
.text$mn:0000221C ??$_Allocate@UFunctionValues@@@std@@YAPAUFunctionValues@@IPAU1@@Z proc near
.text$mn:0000221C                                         ; CODE XREF: std::allocator<FunctionValues>::allocate(uint)+Dp
.text$mn:0000221C
.text$mn:0000221C var_4           = dword ptr -4
.text$mn:0000221C arg_0           = dword ptr  8
.text$mn:0000221C
.text$mn:0000221C                 push    ebp
.text$mn:0000221D                 mov     ebp, esp
.text$mn:0000221F                 push    ecx
.text$mn:00002220                 mov     [ebp+var_4], 0
.text$mn:00002227                 cmp     [ebp+arg_0], 0
.text$mn:0000222B                 jnz     short loc_222F
.text$mn:0000222D                 jmp     short loc_2255
.text$mn:0000222F ; ---------------------------------------------------------------------------
.text$mn:0000222F
.text$mn:0000222F loc_222F:                               ; CODE XREF: std::_Allocate<FunctionValues>(uint,FunctionValues *)+Fj
.text$mn:0000222F                 cmp     [ebp+arg_0], 0FFFFFFFh
.text$mn:00002236                 ja      short loc_2250
.text$mn:00002238                 mov     eax, [ebp+arg_0]
.text$mn:0000223B                 shl     eax, 4
.text$mn:0000223E                 push    eax             ; unsigned int
.text$mn:0000223F                 call    ??2@YAPAXI@Z    ; operator new(uint)
.text$mn:00002244                 add     esp, 4
.text$mn:00002247                 mov     [ebp+var_4], eax
.text$mn:0000224A                 cmp     [ebp+var_4], 0
.text$mn:0000224E                 jnz     short loc_2255
.text$mn:00002250
.text$mn:00002250 loc_2250:                               ; CODE XREF: std::_Allocate<FunctionValues>(uint,FunctionValues *)+1Aj
.text$mn:00002250                 call    ?_Xbad_alloc@std@@YAXXZ ; std::_Xbad_alloc(void)
.text$mn:00002255
.text$mn:00002255 loc_2255:                               ; CODE XREF: std::_Allocate<FunctionValues>(uint,FunctionValues *)+11j
.text$mn:00002255                                         ; std::_Allocate<FunctionValues>(uint,FunctionValues *)+32j
.text$mn:00002255                 mov     eax, [ebp+var_4]
.text$mn:00002258                 mov     esp, ebp
.text$mn:0000225A                 pop     ebp
.text$mn:0000225B                 retn
.text$mn:0000225B ??$_Allocate@UFunctionValues@@@std@@YAPAUFunctionValues@@IPAU1@@Z endp
.text$mn:0000225B
.text$mn:0000225B _text$mn        ends
.text$mn:0000225B
.text$mn:0000225C ; ===========================================================================
.text$mn:0000225C
.text$mn:0000225C ; Segment type: Pure code
.text$mn:0000225C ; Segment permissions: Read/Execute
.text$mn:0000225C _text$mn        segment para public 'CODE' use32
.text$mn:0000225C                 assume cs:_text$mn
.text$mn:0000225C                 ;org 225Ch
.text$mn:0000225C ; COMDAT (pick any)
.text$mn:0000225C                 assume es:nothing, ss:nothing, ds:_data, fs:nothing, gs:nothing
.text$mn:0000225C
.text$mn:0000225C ; =============== S U B R O U T I N E =======================================
.text$mn:0000225C
.text$mn:0000225C ; Attributes: bp-based frame
.text$mn:0000225C
.text$mn:0000225C ; struct Token * __cdecl std::_Allocate<struct Token>(unsigned int, struct Token *)
.text$mn:0000225C                 public ??$_Allocate@UToken@@@std@@YAPAUToken@@IPAU1@@Z
.text$mn:0000225C ??$_Allocate@UToken@@@std@@YAPAUToken@@IPAU1@@Z proc near
.text$mn:0000225C                                         ; CODE XREF: std::allocator<Token>::allocate(uint)+Dp
.text$mn:0000225C
.text$mn:0000225C var_4           = dword ptr -4
.text$mn:0000225C arg_0           = dword ptr  8
.text$mn:0000225C
.text$mn:0000225C                 push    ebp
.text$mn:0000225D                 mov     ebp, esp
.text$mn:0000225F                 push    ecx
.text$mn:00002260                 mov     [ebp+var_4], 0
.text$mn:00002267                 cmp     [ebp+arg_0], 0
.text$mn:0000226B                 jnz     short loc_226F
.text$mn:0000226D                 jmp     short loc_2293
.text$mn:0000226F ; ---------------------------------------------------------------------------
.text$mn:0000226F
.text$mn:0000226F loc_226F:                               ; CODE XREF: std::_Allocate<Token>(uint,Token *)+Fj
.text$mn:0000226F                 cmp     [ebp+arg_0], 15555555h
.text$mn:00002276                 ja      short loc_228E
.text$mn:00002278                 imul    eax, [ebp+arg_0], 0Ch
.text$mn:0000227C                 push    eax             ; unsigned int
.text$mn:0000227D                 call    ??2@YAPAXI@Z    ; operator new(uint)
.text$mn:00002282                 add     esp, 4
.text$mn:00002285                 mov     [ebp+var_4], eax
.text$mn:00002288                 cmp     [ebp+var_4], 0
.text$mn:0000228C                 jnz     short loc_2293
.text$mn:0000228E
.text$mn:0000228E loc_228E:                               ; CODE XREF: std::_Allocate<Token>(uint,Token *)+1Aj
.text$mn:0000228E                 call    ?_Xbad_alloc@std@@YAXXZ ; std::_Xbad_alloc(void)
.text$mn:00002293
.text$mn:00002293 loc_2293:                               ; CODE XREF: std::_Allocate<Token>(uint,Token *)+11j
.text$mn:00002293                                         ; std::_Allocate<Token>(uint,Token *)+30j
.text$mn:00002293                 mov     eax, [ebp+var_4]
.text$mn:00002296                 mov     esp, ebp
.text$mn:00002298                 pop     ebp
.text$mn:00002299                 retn
.text$mn:00002299 ??$_Allocate@UToken@@@std@@YAPAUToken@@IPAU1@@Z endp
.text$mn:00002299
.text$mn:00002299 ; ---------------------------------------------------------------------------
.text$mn:0000229A                 align 4
.text$mn:0000229A _text$mn        ends
.text$mn:0000229A
.text$mn:0000229C ; ===========================================================================
.text$mn:0000229C
.text$mn:0000229C ; Segment type: Pure code
.text$mn:0000229C ; Segment permissions: Read/Execute
.text$mn:0000229C _text$mn        segment para public 'CODE' use32
.text$mn:0000229C                 assume cs:_text$mn
.text$mn:0000229C                 ;org 229Ch
.text$mn:0000229C ; COMDAT (pick any)
.text$mn:0000229C                 assume es:nothing, ss:nothing, ds:_data, fs:nothing, gs:nothing
.text$mn:0000229C
.text$mn:0000229C ; =============== S U B R O U T I N E =======================================
.text$mn:0000229C
.text$mn:0000229C ; Attributes: bp-based frame
.text$mn:0000229C
.text$mn:0000229C ; struct std::_Container_proxy * __cdecl std::_Allocate<struct std::_Container_proxy>(unsigned int, struct std::_Container_proxy *)
.text$mn:0000229C                 public ??$_Allocate@U_Container_proxy@std@@@std@@YAPAU_Container_proxy@0@IPAU10@@Z
.text$mn:0000229C ??$_Allocate@U_Container_proxy@std@@@std@@YAPAU_Container_proxy@0@IPAU10@@Z proc near
.text$mn:0000229C                                         ; CODE XREF: std::allocator<std::_Container_proxy>::allocate(uint)+Dp
.text$mn:0000229C
.text$mn:0000229C var_4           = dword ptr -4
.text$mn:0000229C arg_0           = dword ptr  8
.text$mn:0000229C
.text$mn:0000229C                 push    ebp
.text$mn:0000229D                 mov     ebp, esp
.text$mn:0000229F                 push    ecx
.text$mn:000022A0                 mov     [ebp+var_4], 0
.text$mn:000022A7                 cmp     [ebp+arg_0], 0
.text$mn:000022AB                 jnz     short loc_22AF
.text$mn:000022AD                 jmp     short loc_22D5
.text$mn:000022AF ; ---------------------------------------------------------------------------
.text$mn:000022AF
.text$mn:000022AF loc_22AF:                               ; CODE XREF: std::_Allocate<std::_Container_proxy>(uint,std::_Container_proxy *)+Fj
.text$mn:000022AF                 cmp     [ebp+arg_0], 1FFFFFFFh
.text$mn:000022B6                 ja      short loc_22D0
.text$mn:000022B8                 mov     eax, [ebp+arg_0]
.text$mn:000022BB                 shl     eax, 3
.text$mn:000022BE                 push    eax             ; unsigned int
.text$mn:000022BF                 call    ??2@YAPAXI@Z    ; operator new(uint)
.text$mn:000022C4                 add     esp, 4
.text$mn:000022C7                 mov     [ebp+var_4], eax
.text$mn:000022CA                 cmp     [ebp+var_4], 0
.text$mn:000022CE                 jnz     short loc_22D5
.text$mn:000022D0
.text$mn:000022D0 loc_22D0:                               ; CODE XREF: std::_Allocate<std::_Container_proxy>(uint,std::_Container_proxy *)+1Aj
.text$mn:000022D0                 call    ?_Xbad_alloc@std@@YAXXZ ; std::_Xbad_alloc(void)
.text$mn:000022D5
.text$mn:000022D5 loc_22D5:                               ; CODE XREF: std::_Allocate<std::_Container_proxy>(uint,std::_Container_proxy *)+11j
.text$mn:000022D5                                         ; std::_Allocate<std::_Container_proxy>(uint,std::_Container_proxy *)+32j
.text$mn:000022D5                 mov     eax, [ebp+var_4]
.text$mn:000022D8                 mov     esp, ebp
.text$mn:000022DA                 pop     ebp
.text$mn:000022DB                 retn
.text$mn:000022DB ??$_Allocate@U_Container_proxy@std@@@std@@YAPAU_Container_proxy@0@IPAU10@@Z endp
.text$mn:000022DB
.text$mn:000022DB _text$mn        ends
.text$mn:000022DB
.text$mn:000022DC ; ===========================================================================
.text$mn:000022DC
.text$mn:000022DC ; Segment type: Pure code
.text$mn:000022DC ; Segment permissions: Read/Execute
.text$mn:000022DC _text$mn        segment para public 'CODE' use32
.text$mn:000022DC                 assume cs:_text$mn
.text$mn:000022DC                 ;org 22DCh
.text$mn:000022DC ; COMDAT (pick any)
.text$mn:000022DC                 assume es:nothing, ss:nothing, ds:_data, fs:nothing, gs:nothing
.text$mn:000022DC
.text$mn:000022DC ; =============== S U B R O U T I N E =======================================
.text$mn:000022DC
.text$mn:000022DC ; Attributes: bp-based frame
.text$mn:000022DC
.text$mn:000022DC ; class std::vector<wchar_t const *, class std::allocator<wchar_t const *>> * __cdecl std::_Allocate<class std::vector<wchar_t const *, class std::allocator<wchar_t const *>>>(unsigned int, class std::vector<wchar_t const *, class std::allocator<wchar_t const *>> *)
.text$mn:000022DC                 public ??$_Allocate@V?$vector@PB_WV?$allocator@PB_W@std@@@std@@@std@@YAPAV?$vector@PB_WV?$allocator@PB_W@std@@@0@IPAV10@@Z
.text$mn:000022DC ??$_Allocate@V?$vector@PB_WV?$allocator@PB_W@std@@@std@@@std@@YAPAV?$vector@PB_WV?$allocator@PB_W@std@@@0@IPAV10@@Z proc near
.text$mn:000022DC                                         ; CODE XREF: std::allocator<std::vector<wchar_t const *,std::allocator<wchar_t const *>>>::allocate(uint)+Dp
.text$mn:000022DC
.text$mn:000022DC var_4           = dword ptr -4
.text$mn:000022DC arg_0           = dword ptr  8
.text$mn:000022DC
.text$mn:000022DC                 push    ebp
.text$mn:000022DD                 mov     ebp, esp
.text$mn:000022DF                 push    ecx
.text$mn:000022E0                 mov     [ebp+var_4], 0
.text$mn:000022E7                 cmp     [ebp+arg_0], 0
.text$mn:000022EB                 jnz     short loc_22EF
.text$mn:000022ED                 jmp     short loc_2315
.text$mn:000022EF ; ---------------------------------------------------------------------------
.text$mn:000022EF
.text$mn:000022EF loc_22EF:                               ; CODE XREF: std::_Allocate<std::vector<wchar_t const *,std::allocator<wchar_t const *>>>(uint,std::vector<wchar_t const *,std::allocator<wchar_t const *>> *)+Fj
.text$mn:000022EF                 cmp     [ebp+arg_0], 0FFFFFFFh
.text$mn:000022F6                 ja      short loc_2310
.text$mn:000022F8                 mov     eax, [ebp+arg_0]
.text$mn:000022FB                 shl     eax, 4
.text$mn:000022FE                 push    eax             ; unsigned int
.text$mn:000022FF                 call    ??2@YAPAXI@Z    ; operator new(uint)
.text$mn:00002304                 add     esp, 4
.text$mn:00002307                 mov     [ebp+var_4], eax
.text$mn:0000230A                 cmp     [ebp+var_4], 0
.text$mn:0000230E                 jnz     short loc_2315
.text$mn:00002310
.text$mn:00002310 loc_2310:                               ; CODE XREF: std::_Allocate<std::vector<wchar_t const *,std::allocator<wchar_t const *>>>(uint,std::vector<wchar_t const *,std::allocator<wchar_t const *>> *)+1Aj
.text$mn:00002310                 call    ?_Xbad_alloc@std@@YAXXZ ; std::_Xbad_alloc(void)
.text$mn:00002315
.text$mn:00002315 loc_2315:                               ; CODE XREF: std::_Allocate<std::vector<wchar_t const *,std::allocator<wchar_t const *>>>(uint,std::vector<wchar_t const *,std::allocator<wchar_t const *>> *)+11j
.text$mn:00002315                                         ; std::_Allocate<std::vector<wchar_t const *,std::allocator<wchar_t const *>>>(uint,std::vector<wchar_t const *,std::allocator<wchar_t const *>> *)+32j
.text$mn:00002315                 mov     eax, [ebp+var_4]
.text$mn:00002318                 mov     esp, ebp
.text$mn:0000231A                 pop     ebp
.text$mn:0000231B                 retn
.text$mn:0000231B ??$_Allocate@V?$vector@PB_WV?$allocator@PB_W@std@@@std@@@std@@YAPAV?$vector@PB_WV?$allocator@PB_W@std@@@0@IPAV10@@Z endp
.text$mn:0000231B
.text$mn:0000231B _text$mn        ends
.text$mn:0000231B
.text$mn:0000231C ; ===========================================================================
.text$mn:0000231C
.text$mn:0000231C ; Segment type: Pure code
.text$mn:0000231C ; Segment permissions: Read/Execute
.text$mn:0000231C _text$mn        segment para public 'CODE' use32
.text$mn:0000231C                 assume cs:_text$mn
.text$mn:0000231C                 ;org 231Ch
.text$mn:0000231C ; COMDAT (pick any)
.text$mn:0000231C                 assume es:nothing, ss:nothing, ds:_data, fs:nothing, gs:nothing
.text$mn:0000231C
.text$mn:0000231C ; =============== S U B R O U T I N E =======================================
.text$mn:0000231C
.text$mn:0000231C ; Attributes: bp-based frame
.text$mn:0000231C
.text$mn:0000231C ; int __cdecl std::_Debug_pointer<char>(int, wchar_t *, unsigned int)
.text$mn:0000231C                 public ??$_Debug_pointer@D@std@@YAXPBDPB_WI@Z
.text$mn:0000231C ??$_Debug_pointer@D@std@@YAXPBDPB_WI@Z proc near
.text$mn:0000231C                                         ; CODE XREF: std::basic_string<char,std::char_traits<char>,std::allocator<char>>::assign(char const *)+15p
.text$mn:0000231C                                         ; std::basic_string<char,std::char_traits<char>,std::allocator<char>>::assign(char const *,uint)+1Bp
.text$mn:0000231C
.text$mn:0000231C arg_0           = dword ptr  8
.text$mn:0000231C arg_4           = dword ptr  0Ch
.text$mn:0000231C arg_8           = dword ptr  10h
.text$mn:0000231C
.text$mn:0000231C                 push    ebp
.text$mn:0000231D                 mov     ebp, esp
.text$mn:0000231F                 cmp     [ebp+arg_0], 0
.text$mn:00002323                 jnz     short loc_233A
.text$mn:00002325                 mov     eax, [ebp+arg_8]
.text$mn:00002328                 push    eax             ; unsigned int
.text$mn:00002329                 mov     ecx, [ebp+arg_4]
.text$mn:0000232C                 push    ecx             ; wchar_t *
.text$mn:0000232D                 push    offset ??_C@_1CK@EOPGIILJ@?$AAi?$AAn?$AAv?$AAa?$AAl?$AAi?$AAd?$AA?5?$AAn?$AAu?$AAl?$AAl?$AA?5?$AAp?$AAo?$AAi?$AAn?$AAt?$AAe?$AAr?$AA?$AA@ ; "invalid null pointer"
.text$mn:00002332                 call    ?_Debug_message@std@@YAXPB_W0I@Z ; std::_Debug_message(wchar_t const *,wchar_t const *,uint)
.text$mn:00002337                 add     esp, 0Ch
.text$mn:0000233A
.text$mn:0000233A loc_233A:                               ; CODE XREF: std::_Debug_pointer<char>(char const *,wchar_t const *,uint)+7j
.text$mn:0000233A                 pop     ebp
.text$mn:0000233B                 retn
.text$mn:0000233B ??$_Debug_pointer@D@std@@YAXPBDPB_WI@Z endp
.text$mn:0000233B
.text$mn:0000233B _text$mn        ends
.text$mn:0000233B
.text$mn:0000233C ; ===========================================================================
.text$mn:0000233C
.text$mn:0000233C ; Segment type: Pure code
.text$mn:0000233C ; Segment permissions: Read/Execute
.text$mn:0000233C _text$mn        segment para public 'CODE' use32
.text$mn:0000233C                 assume cs:_text$mn
.text$mn:0000233C                 ;org 233Ch
.text$mn:0000233C ; COMDAT (pick any)
.text$mn:0000233C                 assume es:nothing, ss:nothing, ds:_data, fs:nothing, gs:nothing
.text$mn:0000233C
.text$mn:0000233C ; =============== S U B R O U T I N E =======================================
.text$mn:0000233C
.text$mn:0000233C ; Attributes: bp-based frame
.text$mn:0000233C
.text$mn:0000233C ; int __cdecl std::_Debug_pointer<wchar_t const *>(int, wchar_t *, unsigned int)
.text$mn:0000233C                 public ??$_Debug_pointer@PB_W@std@@YAXPAPB_WPB_WI@Z
.text$mn:0000233C ??$_Debug_pointer@PB_W@std@@YAXPAPB_WPB_WI@Z proc near
.text$mn:0000233C                                         ; CODE XREF: std::_Debug_range2<wchar_t const * *>(wchar_t const * *,wchar_t const * *,wchar_t const *,uint,std::random_access_iterator_tag)+17p
.text$mn:0000233C                                         ; std::_Debug_range2<wchar_t const * *>(wchar_t const * *,wchar_t const * *,wchar_t const *,uint,std::random_access_iterator_tag)+2Bp ...
.text$mn:0000233C
.text$mn:0000233C arg_0           = dword ptr  8
.text$mn:0000233C arg_4           = dword ptr  0Ch
.text$mn:0000233C arg_8           = dword ptr  10h
.text$mn:0000233C
.text$mn:0000233C                 push    ebp
.text$mn:0000233D                 mov     ebp, esp
.text$mn:0000233F                 cmp     [ebp+arg_0], 0
.text$mn:00002343                 jnz     short loc_235A
.text$mn:00002345                 mov     eax, [ebp+arg_8]
.text$mn:00002348                 push    eax             ; unsigned int
.text$mn:00002349                 mov     ecx, [ebp+arg_4]
.text$mn:0000234C                 push    ecx             ; wchar_t *
.text$mn:0000234D                 push    offset ??_C@_1CK@EOPGIILJ@?$AAi?$AAn?$AAv?$AAa?$AAl?$AAi?$AAd?$AA?5?$AAn?$AAu?$AAl?$AAl?$AA?5?$AAp?$AAo?$AAi?$AAn?$AAt?$AAe?$AAr?$AA?$AA@ ; "invalid null pointer"
.text$mn:00002352                 call    ?_Debug_message@std@@YAXPB_W0I@Z ; std::_Debug_message(wchar_t const *,wchar_t const *,uint)
.text$mn:00002357                 add     esp, 0Ch
.text$mn:0000235A
.text$mn:0000235A loc_235A:                               ; CODE XREF: std::_Debug_pointer<wchar_t const *>(wchar_t const * *,wchar_t const *,uint)+7j
.text$mn:0000235A                 pop     ebp
.text$mn:0000235B                 retn
.text$mn:0000235B ??$_Debug_pointer@PB_W@std@@YAXPAPB_WPB_WI@Z endp
.text$mn:0000235B
.text$mn:0000235B _text$mn        ends
.text$mn:0000235B
.text$mn:0000235C ; ===========================================================================
.text$mn:0000235C
.text$mn:0000235C ; Segment type: Pure code
.text$mn:0000235C ; Segment permissions: Read/Execute
.text$mn:0000235C _text$mn        segment para public 'CODE' use32
.text$mn:0000235C                 assume cs:_text$mn
.text$mn:0000235C                 ;org 235Ch
.text$mn:0000235C ; COMDAT (pick any)
.text$mn:0000235C                 assume es:nothing, ss:nothing, ds:_data, fs:nothing, gs:nothing
.text$mn:0000235C
.text$mn:0000235C ; =============== S U B R O U T I N E =======================================
.text$mn:0000235C
.text$mn:0000235C ; Attributes: bp-based frame
.text$mn:0000235C
.text$mn:0000235C ; int __cdecl std::_Debug_pointer<wchar_t const *>(int, wchar_t *, unsigned int)
.text$mn:0000235C                 public ??$_Debug_pointer@PB_W@std@@YAXPBQB_WPB_WI@Z
.text$mn:0000235C ??$_Debug_pointer@PB_W@std@@YAXPBQB_WPB_WI@Z proc near
.text$mn:0000235C                                         ; CODE XREF: std::_Debug_range2<wchar_t const * const *>(wchar_t const * const *,wchar_t const * const *,wchar_t const *,uint,std::random_access_iterator_tag)+17p
.text$mn:0000235C                                         ; std::_Debug_range2<wchar_t const * const *>(wchar_t const * const *,wchar_t const * const *,wchar_t const *,uint,std::random_access_iterator_tag)+2Bp
.text$mn:0000235C
.text$mn:0000235C arg_0           = dword ptr  8
.text$mn:0000235C arg_4           = dword ptr  0Ch
.text$mn:0000235C arg_8           = dword ptr  10h
.text$mn:0000235C
.text$mn:0000235C                 push    ebp
.text$mn:0000235D                 mov     ebp, esp
.text$mn:0000235F                 cmp     [ebp+arg_0], 0
.text$mn:00002363                 jnz     short loc_237A
.text$mn:00002365                 mov     eax, [ebp+arg_8]
.text$mn:00002368                 push    eax             ; unsigned int
.text$mn:00002369                 mov     ecx, [ebp+arg_4]
.text$mn:0000236C                 push    ecx             ; wchar_t *
.text$mn:0000236D                 push    offset ??_C@_1CK@EOPGIILJ@?$AAi?$AAn?$AAv?$AAa?$AAl?$AAi?$AAd?$AA?5?$AAn?$AAu?$AAl?$AAl?$AA?5?$AAp?$AAo?$AAi?$AAn?$AAt?$AAe?$AAr?$AA?$AA@ ; "invalid null pointer"
.text$mn:00002372                 call    ?_Debug_message@std@@YAXPB_W0I@Z ; std::_Debug_message(wchar_t const *,wchar_t const *,uint)
.text$mn:00002377                 add     esp, 0Ch
.text$mn:0000237A
.text$mn:0000237A loc_237A:                               ; CODE XREF: std::_Debug_pointer<wchar_t const *>(wchar_t const * const *,wchar_t const *,uint)+7j
.text$mn:0000237A                 pop     ebp
.text$mn:0000237B                 retn
.text$mn:0000237B ??$_Debug_pointer@PB_W@std@@YAXPBQB_WPB_WI@Z endp
.text$mn:0000237B
.text$mn:0000237B _text$mn        ends
.text$mn:0000237B
.text$mn:0000237C ; ===========================================================================
.text$mn:0000237C
.text$mn:0000237C ; Segment type: Pure code
.text$mn:0000237C ; Segment permissions: Read/Execute
.text$mn:0000237C _text$mn        segment para public 'CODE' use32
.text$mn:0000237C                 assume cs:_text$mn
.text$mn:0000237C                 ;org 237Ch
.text$mn:0000237C ; COMDAT (pick any)
.text$mn:0000237C                 assume es:nothing, ss:nothing, ds:_data, fs:nothing, gs:nothing
.text$mn:0000237C
.text$mn:0000237C ; =============== S U B R O U T I N E =======================================
.text$mn:0000237C
.text$mn:0000237C ; Attributes: bp-based frame
.text$mn:0000237C
.text$mn:0000237C ; int __cdecl std::_Debug_pointer<FunctionValues>(int, wchar_t *, unsigned int)
.text$mn:0000237C                 public ??$_Debug_pointer@UFunctionValues@@@std@@YAXPAUFunctionValues@@PB_WI@Z
.text$mn:0000237C ??$_Debug_pointer@UFunctionValues@@@std@@YAXPAUFunctionValues@@PB_WI@Z proc near
.text$mn:0000237C                                         ; CODE XREF: std::_Debug_range2<FunctionValues *>(FunctionValues *,FunctionValues *,wchar_t const *,uint,std::random_access_iterator_tag)+17p
.text$mn:0000237C                                         ; std::_Debug_range2<FunctionValues *>(FunctionValues *,FunctionValues *,wchar_t const *,uint,std::random_access_iterator_tag)+2Bp ...
.text$mn:0000237C
.text$mn:0000237C arg_0           = dword ptr  8
.text$mn:0000237C arg_4           = dword ptr  0Ch
.text$mn:0000237C arg_8           = dword ptr  10h
.text$mn:0000237C
.text$mn:0000237C                 push    ebp
.text$mn:0000237D                 mov     ebp, esp
.text$mn:0000237F                 cmp     [ebp+arg_0], 0
.text$mn:00002383                 jnz     short loc_239A
.text$mn:00002385                 mov     eax, [ebp+arg_8]
.text$mn:00002388                 push    eax             ; unsigned int
.text$mn:00002389                 mov     ecx, [ebp+arg_4]
.text$mn:0000238C                 push    ecx             ; wchar_t *
.text$mn:0000238D                 push    offset ??_C@_1CK@EOPGIILJ@?$AAi?$AAn?$AAv?$AAa?$AAl?$AAi?$AAd?$AA?5?$AAn?$AAu?$AAl?$AAl?$AA?5?$AAp?$AAo?$AAi?$AAn?$AAt?$AAe?$AAr?$AA?$AA@ ; "invalid null pointer"
.text$mn:00002392                 call    ?_Debug_message@std@@YAXPB_W0I@Z ; std::_Debug_message(wchar_t const *,wchar_t const *,uint)
.text$mn:00002397                 add     esp, 0Ch
.text$mn:0000239A
.text$mn:0000239A loc_239A:                               ; CODE XREF: std::_Debug_pointer<FunctionValues>(FunctionValues *,wchar_t const *,uint)+7j
.text$mn:0000239A                 pop     ebp
.text$mn:0000239B                 retn
.text$mn:0000239B ??$_Debug_pointer@UFunctionValues@@@std@@YAXPAUFunctionValues@@PB_WI@Z endp
.text$mn:0000239B
.text$mn:0000239B _text$mn        ends
.text$mn:0000239B
.text$mn:0000239C ; ===========================================================================
.text$mn:0000239C
.text$mn:0000239C ; Segment type: Pure code
.text$mn:0000239C ; Segment permissions: Read/Execute
.text$mn:0000239C _text$mn        segment para public 'CODE' use32
.text$mn:0000239C                 assume cs:_text$mn
.text$mn:0000239C                 ;org 239Ch
.text$mn:0000239C ; COMDAT (pick any)
.text$mn:0000239C                 assume es:nothing, ss:nothing, ds:_data, fs:nothing, gs:nothing
.text$mn:0000239C
.text$mn:0000239C ; =============== S U B R O U T I N E =======================================
.text$mn:0000239C
.text$mn:0000239C ; Attributes: bp-based frame
.text$mn:0000239C
.text$mn:0000239C ; int __cdecl std::_Debug_pointer<Token>(int, wchar_t *, unsigned int)
.text$mn:0000239C                 public ??$_Debug_pointer@UToken@@@std@@YAXPAUToken@@PB_WI@Z
.text$mn:0000239C ??$_Debug_pointer@UToken@@@std@@YAXPAUToken@@PB_WI@Z proc near
.text$mn:0000239C                                         ; CODE XREF: std::_Debug_range2<Token *>(Token *,Token *,wchar_t const *,uint,std::random_access_iterator_tag)+17p
.text$mn:0000239C                                         ; std::_Debug_range2<Token *>(Token *,Token *,wchar_t const *,uint,std::random_access_iterator_tag)+2Bp ...
.text$mn:0000239C
.text$mn:0000239C arg_0           = dword ptr  8
.text$mn:0000239C arg_4           = dword ptr  0Ch
.text$mn:0000239C arg_8           = dword ptr  10h
.text$mn:0000239C
.text$mn:0000239C                 push    ebp
.text$mn:0000239D                 mov     ebp, esp
.text$mn:0000239F                 cmp     [ebp+arg_0], 0
.text$mn:000023A3                 jnz     short loc_23BA
.text$mn:000023A5                 mov     eax, [ebp+arg_8]
.text$mn:000023A8                 push    eax             ; unsigned int
.text$mn:000023A9                 mov     ecx, [ebp+arg_4]
.text$mn:000023AC                 push    ecx             ; wchar_t *
.text$mn:000023AD                 push    offset ??_C@_1CK@EOPGIILJ@?$AAi?$AAn?$AAv?$AAa?$AAl?$AAi?$AAd?$AA?5?$AAn?$AAu?$AAl?$AAl?$AA?5?$AAp?$AAo?$AAi?$AAn?$AAt?$AAe?$AAr?$AA?$AA@ ; "invalid null pointer"
.text$mn:000023B2                 call    ?_Debug_message@std@@YAXPB_W0I@Z ; std::_Debug_message(wchar_t const *,wchar_t const *,uint)
.text$mn:000023B7                 add     esp, 0Ch
.text$mn:000023BA
.text$mn:000023BA loc_23BA:                               ; CODE XREF: std::_Debug_pointer<Token>(Token *,wchar_t const *,uint)+7j
.text$mn:000023BA                 pop     ebp
.text$mn:000023BB                 retn
.text$mn:000023BB ??$_Debug_pointer@UToken@@@std@@YAXPAUToken@@PB_WI@Z endp
.text$mn:000023BB
.text$mn:000023BB _text$mn        ends
.text$mn:000023BB
.text$mn:000023BC ; ===========================================================================
.text$mn:000023BC
.text$mn:000023BC ; Segment type: Pure code
.text$mn:000023BC ; Segment permissions: Read/Execute
.text$mn:000023BC _text$mn        segment para public 'CODE' use32
.text$mn:000023BC                 assume cs:_text$mn
.text$mn:000023BC                 ;org 23BCh
.text$mn:000023BC ; COMDAT (pick any)
.text$mn:000023BC                 assume es:nothing, ss:nothing, ds:_data, fs:nothing, gs:nothing
.text$mn:000023BC
.text$mn:000023BC ; =============== S U B R O U T I N E =======================================
.text$mn:000023BC
.text$mn:000023BC ; Attributes: bp-based frame
.text$mn:000023BC
.text$mn:000023BC ; int __cdecl std::_Debug_pointer<std::vector<wchar_t const *,std::allocator<wchar_t const *>>>(int, wchar_t *, unsigned int)
.text$mn:000023BC                 public ??$_Debug_pointer@V?$vector@PB_WV?$allocator@PB_W@std@@@std@@@std@@YAXPAV?$vector@PB_WV?$allocator@PB_W@std@@@0@PB_WI@Z
.text$mn:000023BC ??$_Debug_pointer@V?$vector@PB_WV?$allocator@PB_W@std@@@std@@@std@@YAXPAV?$vector@PB_WV?$allocator@PB_W@std@@@0@PB_WI@Z proc near
.text$mn:000023BC                                         ; CODE XREF: std::_Debug_range2<std::vector<wchar_t const *,std::allocator<wchar_t const *>> *>(std::vector<wchar_t const *,std::allocator<wchar_t const *>> *,std::vector<wchar_t const *,std::allocator<wchar_t const *>> *,wchar_t const *,uint,std::random_access_iterator_tag)+17p
.text$mn:000023BC                                         ; std::_Debug_range2<std::vector<wchar_t const *,std::allocator<wchar_t const *>> *>(std::vector<wchar_t const *,std::allocator<wchar_t const *>> *,std::vector<wchar_t const *,std::allocator<wchar_t const *>> *,wchar_t const *,uint,std::random_access_iterator_tag)+2Bp ...
.text$mn:000023BC
.text$mn:000023BC arg_0           = dword ptr  8
.text$mn:000023BC arg_4           = dword ptr  0Ch
.text$mn:000023BC arg_8           = dword ptr  10h
.text$mn:000023BC
.text$mn:000023BC                 push    ebp
.text$mn:000023BD                 mov     ebp, esp
.text$mn:000023BF                 cmp     [ebp+arg_0], 0
.text$mn:000023C3                 jnz     short loc_23DA
.text$mn:000023C5                 mov     eax, [ebp+arg_8]
.text$mn:000023C8                 push    eax             ; unsigned int
.text$mn:000023C9                 mov     ecx, [ebp+arg_4]
.text$mn:000023CC                 push    ecx             ; wchar_t *
.text$mn:000023CD                 push    offset ??_C@_1CK@EOPGIILJ@?$AAi?$AAn?$AAv?$AAa?$AAl?$AAi?$AAd?$AA?5?$AAn?$AAu?$AAl?$AAl?$AA?5?$AAp?$AAo?$AAi?$AAn?$AAt?$AAe?$AAr?$AA?$AA@ ; "invalid null pointer"
.text$mn:000023D2                 call    ?_Debug_message@std@@YAXPB_W0I@Z ; std::_Debug_message(wchar_t const *,wchar_t const *,uint)
.text$mn:000023D7                 add     esp, 0Ch
.text$mn:000023DA
.text$mn:000023DA loc_23DA:                               ; CODE XREF: std::_Debug_pointer<std::vector<wchar_t const *,std::allocator<wchar_t const *>>>(std::vector<wchar_t const *,std::allocator<wchar_t const *>> *,wchar_t const *,uint)+7j
.text$mn:000023DA                 pop     ebp
.text$mn:000023DB                 retn
.text$mn:000023DB ??$_Debug_pointer@V?$vector@PB_WV?$allocator@PB_W@std@@@std@@@std@@YAXPAV?$vector@PB_WV?$allocator@PB_W@std@@@0@PB_WI@Z endp
.text$mn:000023DB
.text$mn:000023DB _text$mn        ends
.text$mn:000023DB
.text$mn:000023DC ; ===========================================================================
.text$mn:000023DC
.text$mn:000023DC ; Segment type: Pure code
.text$mn:000023DC ; Segment permissions: Read/Execute
.text$mn:000023DC _text$mn        segment para public 'CODE' use32
.text$mn:000023DC                 assume cs:_text$mn
.text$mn:000023DC                 ;org 23DCh
.text$mn:000023DC ; COMDAT (pick any)
.text$mn:000023DC                 assume es:nothing, ss:nothing, ds:_data, fs:nothing, gs:nothing
.text$mn:000023DC
.text$mn:000023DC ; =============== S U B R O U T I N E =======================================
.text$mn:000023DC
.text$mn:000023DC ; Attributes: bp-based frame
.text$mn:000023DC
.text$mn:000023DC ; int __cdecl std::_Debug_range2<wchar_t const * *>(int, int, wchar_t *, unsigned int)
.text$mn:000023DC                 public ??$_Debug_range2@PAPB_W@std@@YAXPAPB_W0PB_WIUrandom_access_iterator_tag@0@@Z
.text$mn:000023DC ??$_Debug_range2@PAPB_W@std@@YAXPAPB_W0PB_WIUrandom_access_iterator_tag@0@@Z proc near
.text$mn:000023DC                                         ; CODE XREF: std::_Debug_range<wchar_t const * *>(wchar_t const * *,wchar_t const * *,wchar_t const *,uint)+2Ap
.text$mn:000023DC
.text$mn:000023DC arg_0           = dword ptr  8
.text$mn:000023DC arg_4           = dword ptr  0Ch
.text$mn:000023DC arg_8           = dword ptr  10h
.text$mn:000023DC arg_C           = dword ptr  14h
.text$mn:000023DC
.text$mn:000023DC                 push    ebp
.text$mn:000023DD                 mov     ebp, esp
.text$mn:000023DF                 mov     eax, [ebp+arg_0]
.text$mn:000023E2                 cmp     eax, [ebp+arg_4]
.text$mn:000023E5                 jz      short loc_242C
.text$mn:000023E7                 mov     ecx, [ebp+arg_C]
.text$mn:000023EA                 push    ecx             ; unsigned int
.text$mn:000023EB                 mov     edx, [ebp+arg_8]
.text$mn:000023EE                 push    edx             ; wchar_t *
.text$mn:000023EF                 mov     eax, [ebp+arg_0]
.text$mn:000023F2                 push    eax             ; int
.text$mn:000023F3                 call    ??$_Debug_pointer@PB_W@std@@YAXPAPB_WPB_WI@Z ; std::_Debug_pointer<wchar_t const *>(wchar_t const * *,wchar_t const *,uint)
.text$mn:000023F8                 add     esp, 0Ch
.text$mn:000023FB                 mov     ecx, [ebp+arg_C]
.text$mn:000023FE                 push    ecx             ; unsigned int
.text$mn:000023FF                 mov     edx, [ebp+arg_8]
.text$mn:00002402                 push    edx             ; wchar_t *
.text$mn:00002403                 mov     eax, [ebp+arg_4]
.text$mn:00002406                 push    eax             ; int
.text$mn:00002407                 call    ??$_Debug_pointer@PB_W@std@@YAXPAPB_WPB_WI@Z ; std::_Debug_pointer<wchar_t const *>(wchar_t const * *,wchar_t const *,uint)
.text$mn:0000240C                 add     esp, 0Ch
.text$mn:0000240F                 mov     ecx, [ebp+arg_4]
.text$mn:00002412                 cmp     ecx, [ebp+arg_0]
.text$mn:00002415                 jnb     short loc_242C
.text$mn:00002417                 mov     edx, [ebp+arg_C]
.text$mn:0000241A                 push    edx             ; unsigned int
.text$mn:0000241B                 mov     eax, [ebp+arg_8]
.text$mn:0000241E                 push    eax             ; wchar_t *
.text$mn:0000241F                 push    offset ??_C@_1CO@DGLIKNHI@?$AAi?$AAn?$AAv?$AAa?$AAl?$AAi?$AAd?$AA?5?$AAi?$AAt?$AAe?$AAr?$AAa?$AAt?$AAo?$AAr?$AA?5?$AAr?$AAa?$AAn?$AAg?$AAe?$AA?$AA@ ; "invalid iterator range"
.text$mn:00002424                 call    ?_Debug_message@std@@YAXPB_W0I@Z ; std::_Debug_message(wchar_t const *,wchar_t const *,uint)
.text$mn:00002429                 add     esp, 0Ch
.text$mn:0000242C
.text$mn:0000242C loc_242C:                               ; CODE XREF: std::_Debug_range2<wchar_t const * *>(wchar_t const * *,wchar_t const * *,wchar_t const *,uint,std::random_access_iterator_tag)+9j
.text$mn:0000242C                                         ; std::_Debug_range2<wchar_t const * *>(wchar_t const * *,wchar_t const * *,wchar_t const *,uint,std::random_access_iterator_tag)+39j
.text$mn:0000242C                 pop     ebp
.text$mn:0000242D                 retn
.text$mn:0000242D ??$_Debug_range2@PAPB_W@std@@YAXPAPB_W0PB_WIUrandom_access_iterator_tag@0@@Z endp
.text$mn:0000242D
.text$mn:0000242D ; ---------------------------------------------------------------------------
.text$mn:0000242E                 align 10h
.text$mn:0000242E _text$mn        ends
.text$mn:0000242E
.text$mn:00002430 ; ===========================================================================
.text$mn:00002430
.text$mn:00002430 ; Segment type: Pure code
.text$mn:00002430 ; Segment permissions: Read/Execute
.text$mn:00002430 _text$mn        segment para public 'CODE' use32
.text$mn:00002430                 assume cs:_text$mn
.text$mn:00002430                 ;org 2430h
.text$mn:00002430 ; COMDAT (pick any)
.text$mn:00002430                 assume es:nothing, ss:nothing, ds:_data, fs:nothing, gs:nothing
.text$mn:00002430
.text$mn:00002430 ; =============== S U B R O U T I N E =======================================
.text$mn:00002430
.text$mn:00002430 ; Attributes: bp-based frame
.text$mn:00002430
.text$mn:00002430 ; int __cdecl std::_Debug_range2<FunctionValues *>(int, int, wchar_t *, unsigned int)
.text$mn:00002430                 public ??$_Debug_range2@PAUFunctionValues@@@std@@YAXPAUFunctionValues@@0PB_WIUrandom_access_iterator_tag@0@@Z
.text$mn:00002430 ??$_Debug_range2@PAUFunctionValues@@@std@@YAXPAUFunctionValues@@0PB_WIUrandom_access_iterator_tag@0@@Z proc near
.text$mn:00002430                                         ; CODE XREF: std::_Debug_range<FunctionValues *>(FunctionValues *,FunctionValues *,wchar_t const *,uint)+2Ap
.text$mn:00002430
.text$mn:00002430 arg_0           = dword ptr  8
.text$mn:00002430 arg_4           = dword ptr  0Ch
.text$mn:00002430 arg_8           = dword ptr  10h
.text$mn:00002430 arg_C           = dword ptr  14h
.text$mn:00002430
.text$mn:00002430                 push    ebp
.text$mn:00002431                 mov     ebp, esp
.text$mn:00002433                 mov     eax, [ebp+arg_0]
.text$mn:00002436                 cmp     eax, [ebp+arg_4]
.text$mn:00002439                 jz      short loc_2480
.text$mn:0000243B                 mov     ecx, [ebp+arg_C]
.text$mn:0000243E                 push    ecx             ; unsigned int
.text$mn:0000243F                 mov     edx, [ebp+arg_8]
.text$mn:00002442                 push    edx             ; wchar_t *
.text$mn:00002443                 mov     eax, [ebp+arg_0]
.text$mn:00002446                 push    eax             ; int
.text$mn:00002447                 call    ??$_Debug_pointer@UFunctionValues@@@std@@YAXPAUFunctionValues@@PB_WI@Z ; std::_Debug_pointer<FunctionValues>(FunctionValues *,wchar_t const *,uint)
.text$mn:0000244C                 add     esp, 0Ch
.text$mn:0000244F                 mov     ecx, [ebp+arg_C]
.text$mn:00002452                 push    ecx             ; unsigned int
.text$mn:00002453                 mov     edx, [ebp+arg_8]
.text$mn:00002456                 push    edx             ; wchar_t *
.text$mn:00002457                 mov     eax, [ebp+arg_4]
.text$mn:0000245A                 push    eax             ; int
.text$mn:0000245B                 call    ??$_Debug_pointer@UFunctionValues@@@std@@YAXPAUFunctionValues@@PB_WI@Z ; std::_Debug_pointer<FunctionValues>(FunctionValues *,wchar_t const *,uint)
.text$mn:00002460                 add     esp, 0Ch
.text$mn:00002463                 mov     ecx, [ebp+arg_4]
.text$mn:00002466                 cmp     ecx, [ebp+arg_0]
.text$mn:00002469                 jnb     short loc_2480
.text$mn:0000246B                 mov     edx, [ebp+arg_C]
.text$mn:0000246E                 push    edx             ; unsigned int
.text$mn:0000246F                 mov     eax, [ebp+arg_8]
.text$mn:00002472                 push    eax             ; wchar_t *
.text$mn:00002473                 push    offset ??_C@_1CO@DGLIKNHI@?$AAi?$AAn?$AAv?$AAa?$AAl?$AAi?$AAd?$AA?5?$AAi?$AAt?$AAe?$AAr?$AAa?$AAt?$AAo?$AAr?$AA?5?$AAr?$AAa?$AAn?$AAg?$AAe?$AA?$AA@ ; "invalid iterator range"
.text$mn:00002478                 call    ?_Debug_message@std@@YAXPB_W0I@Z ; std::_Debug_message(wchar_t const *,wchar_t const *,uint)
.text$mn:0000247D                 add     esp, 0Ch
.text$mn:00002480
.text$mn:00002480 loc_2480:                               ; CODE XREF: std::_Debug_range2<FunctionValues *>(FunctionValues *,FunctionValues *,wchar_t const *,uint,std::random_access_iterator_tag)+9j
.text$mn:00002480                                         ; std::_Debug_range2<FunctionValues *>(FunctionValues *,FunctionValues *,wchar_t const *,uint,std::random_access_iterator_tag)+39j
.text$mn:00002480                 pop     ebp
.text$mn:00002481                 retn
.text$mn:00002481 ??$_Debug_range2@PAUFunctionValues@@@std@@YAXPAUFunctionValues@@0PB_WIUrandom_access_iterator_tag@0@@Z endp
.text$mn:00002481
.text$mn:00002481 ; ---------------------------------------------------------------------------
.text$mn:00002482                 align 4
.text$mn:00002482 _text$mn        ends
.text$mn:00002482
.text$mn:00002484 ; ===========================================================================
.text$mn:00002484
.text$mn:00002484 ; Segment type: Pure code
.text$mn:00002484 ; Segment permissions: Read/Execute
.text$mn:00002484 _text$mn        segment para public 'CODE' use32
.text$mn:00002484                 assume cs:_text$mn
.text$mn:00002484                 ;org 2484h
.text$mn:00002484 ; COMDAT (pick any)
.text$mn:00002484                 assume es:nothing, ss:nothing, ds:_data, fs:nothing, gs:nothing
.text$mn:00002484
.text$mn:00002484 ; =============== S U B R O U T I N E =======================================
.text$mn:00002484
.text$mn:00002484 ; Attributes: bp-based frame
.text$mn:00002484
.text$mn:00002484 ; int __cdecl std::_Debug_range2<Token *>(int, int, wchar_t *, unsigned int)
.text$mn:00002484                 public ??$_Debug_range2@PAUToken@@@std@@YAXPAUToken@@0PB_WIUrandom_access_iterator_tag@0@@Z
.text$mn:00002484 ??$_Debug_range2@PAUToken@@@std@@YAXPAUToken@@0PB_WIUrandom_access_iterator_tag@0@@Z proc near
.text$mn:00002484                                         ; CODE XREF: std::_Debug_range<Token *>(Token *,Token *,wchar_t const *,uint)+2Ap
.text$mn:00002484
.text$mn:00002484 arg_0           = dword ptr  8
.text$mn:00002484 arg_4           = dword ptr  0Ch
.text$mn:00002484 arg_8           = dword ptr  10h
.text$mn:00002484 arg_C           = dword ptr  14h
.text$mn:00002484
.text$mn:00002484                 push    ebp
.text$mn:00002485                 mov     ebp, esp
.text$mn:00002487                 mov     eax, [ebp+arg_0]
.text$mn:0000248A                 cmp     eax, [ebp+arg_4]
.text$mn:0000248D                 jz      short loc_24D4
.text$mn:0000248F                 mov     ecx, [ebp+arg_C]
.text$mn:00002492                 push    ecx             ; unsigned int
.text$mn:00002493                 mov     edx, [ebp+arg_8]
.text$mn:00002496                 push    edx             ; wchar_t *
.text$mn:00002497                 mov     eax, [ebp+arg_0]
.text$mn:0000249A                 push    eax             ; int
.text$mn:0000249B                 call    ??$_Debug_pointer@UToken@@@std@@YAXPAUToken@@PB_WI@Z ; std::_Debug_pointer<Token>(Token *,wchar_t const *,uint)
.text$mn:000024A0                 add     esp, 0Ch
.text$mn:000024A3                 mov     ecx, [ebp+arg_C]
.text$mn:000024A6                 push    ecx             ; unsigned int
.text$mn:000024A7                 mov     edx, [ebp+arg_8]
.text$mn:000024AA                 push    edx             ; wchar_t *
.text$mn:000024AB                 mov     eax, [ebp+arg_4]
.text$mn:000024AE                 push    eax             ; int
.text$mn:000024AF                 call    ??$_Debug_pointer@UToken@@@std@@YAXPAUToken@@PB_WI@Z ; std::_Debug_pointer<Token>(Token *,wchar_t const *,uint)
.text$mn:000024B4                 add     esp, 0Ch
.text$mn:000024B7                 mov     ecx, [ebp+arg_4]
.text$mn:000024BA                 cmp     ecx, [ebp+arg_0]
.text$mn:000024BD                 jnb     short loc_24D4
.text$mn:000024BF                 mov     edx, [ebp+arg_C]
.text$mn:000024C2                 push    edx             ; unsigned int
.text$mn:000024C3                 mov     eax, [ebp+arg_8]
.text$mn:000024C6                 push    eax             ; wchar_t *
.text$mn:000024C7                 push    offset ??_C@_1CO@DGLIKNHI@?$AAi?$AAn?$AAv?$AAa?$AAl?$AAi?$AAd?$AA?5?$AAi?$AAt?$AAe?$AAr?$AAa?$AAt?$AAo?$AAr?$AA?5?$AAr?$AAa?$AAn?$AAg?$AAe?$AA?$AA@ ; "invalid iterator range"
.text$mn:000024CC                 call    ?_Debug_message@std@@YAXPB_W0I@Z ; std::_Debug_message(wchar_t const *,wchar_t const *,uint)
.text$mn:000024D1                 add     esp, 0Ch
.text$mn:000024D4
.text$mn:000024D4 loc_24D4:                               ; CODE XREF: std::_Debug_range2<Token *>(Token *,Token *,wchar_t const *,uint,std::random_access_iterator_tag)+9j
.text$mn:000024D4                                         ; std::_Debug_range2<Token *>(Token *,Token *,wchar_t const *,uint,std::random_access_iterator_tag)+39j
.text$mn:000024D4                 pop     ebp
.text$mn:000024D5                 retn
.text$mn:000024D5 ??$_Debug_range2@PAUToken@@@std@@YAXPAUToken@@0PB_WIUrandom_access_iterator_tag@0@@Z endp
.text$mn:000024D5
.text$mn:000024D5 ; ---------------------------------------------------------------------------
.text$mn:000024D6                 align 4
.text$mn:000024D6 _text$mn        ends
.text$mn:000024D6
.text$mn:000024D8 ; ===========================================================================
.text$mn:000024D8
.text$mn:000024D8 ; Segment type: Pure code
.text$mn:000024D8 ; Segment permissions: Read/Execute
.text$mn:000024D8 _text$mn        segment para public 'CODE' use32
.text$mn:000024D8                 assume cs:_text$mn
.text$mn:000024D8                 ;org 24D8h
.text$mn:000024D8 ; COMDAT (pick any)
.text$mn:000024D8                 assume es:nothing, ss:nothing, ds:_data, fs:nothing, gs:nothing
.text$mn:000024D8
.text$mn:000024D8 ; =============== S U B R O U T I N E =======================================
.text$mn:000024D8
.text$mn:000024D8 ; Attributes: bp-based frame
.text$mn:000024D8
.text$mn:000024D8 ; int __cdecl std::_Debug_range2<std::vector<wchar_t const *,std::allocator<wchar_t const *>> *>(int, int, wchar_t *, unsigned int)
.text$mn:000024D8                 public ??$_Debug_range2@PAV?$vector@PB_WV?$allocator@PB_W@std@@@std@@@std@@YAXPAV?$vector@PB_WV?$allocator@PB_W@std@@@0@0PB_WIUrandom_access_iterator_tag@0@@Z
.text$mn:000024D8 ??$_Debug_range2@PAV?$vector@PB_WV?$allocator@PB_W@std@@@std@@@std@@YAXPAV?$vector@PB_WV?$allocator@PB_W@std@@@0@0PB_WIUrandom_access_iterator_tag@0@@Z proc near
.text$mn:000024D8                                         ; CODE XREF: std::_Debug_range<std::vector<wchar_t const *,std::allocator<wchar_t const *>> *>(std::vector<wchar_t const *,std::allocator<wchar_t const *>> *,std::vector<wchar_t const *,std::allocator<wchar_t const *>> *,wchar_t const *,uint)+2Ap
.text$mn:000024D8
.text$mn:000024D8 arg_0           = dword ptr  8
.text$mn:000024D8 arg_4           = dword ptr  0Ch
.text$mn:000024D8 arg_8           = dword ptr  10h
.text$mn:000024D8 arg_C           = dword ptr  14h
.text$mn:000024D8
.text$mn:000024D8                 push    ebp
.text$mn:000024D9                 mov     ebp, esp
.text$mn:000024DB                 mov     eax, [ebp+arg_0]
.text$mn:000024DE                 cmp     eax, [ebp+arg_4]
.text$mn:000024E1                 jz      short loc_2528
.text$mn:000024E3                 mov     ecx, [ebp+arg_C]
.text$mn:000024E6                 push    ecx             ; unsigned int
.text$mn:000024E7                 mov     edx, [ebp+arg_8]
.text$mn:000024EA                 push    edx             ; wchar_t *
.text$mn:000024EB                 mov     eax, [ebp+arg_0]
.text$mn:000024EE                 push    eax             ; int
.text$mn:000024EF                 call    ??$_Debug_pointer@V?$vector@PB_WV?$allocator@PB_W@std@@@std@@@std@@YAXPAV?$vector@PB_WV?$allocator@PB_W@std@@@0@PB_WI@Z ; std::_Debug_pointer<std::vector<wchar_t const *,std::allocator<wchar_t const *>>>(std::vector<wchar_t const *,std::allocator<wchar_t const *>> *,wchar_t const *,uint)
.text$mn:000024F4                 add     esp, 0Ch
.text$mn:000024F7                 mov     ecx, [ebp+arg_C]
.text$mn:000024FA                 push    ecx             ; unsigned int
.text$mn:000024FB                 mov     edx, [ebp+arg_8]
.text$mn:000024FE                 push    edx             ; wchar_t *
.text$mn:000024FF                 mov     eax, [ebp+arg_4]
.text$mn:00002502                 push    eax             ; int
.text$mn:00002503                 call    ??$_Debug_pointer@V?$vector@PB_WV?$allocator@PB_W@std@@@std@@@std@@YAXPAV?$vector@PB_WV?$allocator@PB_W@std@@@0@PB_WI@Z ; std::_Debug_pointer<std::vector<wchar_t const *,std::allocator<wchar_t const *>>>(std::vector<wchar_t const *,std::allocator<wchar_t const *>> *,wchar_t const *,uint)
.text$mn:00002508                 add     esp, 0Ch
.text$mn:0000250B                 mov     ecx, [ebp+arg_4]
.text$mn:0000250E                 cmp     ecx, [ebp+arg_0]
.text$mn:00002511                 jnb     short loc_2528
.text$mn:00002513                 mov     edx, [ebp+arg_C]
.text$mn:00002516                 push    edx             ; unsigned int
.text$mn:00002517                 mov     eax, [ebp+arg_8]
.text$mn:0000251A                 push    eax             ; wchar_t *
.text$mn:0000251B                 push    offset ??_C@_1CO@DGLIKNHI@?$AAi?$AAn?$AAv?$AAa?$AAl?$AAi?$AAd?$AA?5?$AAi?$AAt?$AAe?$AAr?$AAa?$AAt?$AAo?$AAr?$AA?5?$AAr?$AAa?$AAn?$AAg?$AAe?$AA?$AA@ ; "invalid iterator range"
.text$mn:00002520                 call    ?_Debug_message@std@@YAXPB_W0I@Z ; std::_Debug_message(wchar_t const *,wchar_t const *,uint)
.text$mn:00002525                 add     esp, 0Ch
.text$mn:00002528
.text$mn:00002528 loc_2528:                               ; CODE XREF: std::_Debug_range2<std::vector<wchar_t const *,std::allocator<wchar_t const *>> *>(std::vector<wchar_t const *,std::allocator<wchar_t const *>> *,std::vector<wchar_t const *,std::allocator<wchar_t const *>> *,wchar_t const *,uint,std::random_access_iterator_tag)+9j
.text$mn:00002528                                         ; std::_Debug_range2<std::vector<wchar_t const *,std::allocator<wchar_t const *>> *>(std::vector<wchar_t const *,std::allocator<wchar_t const *>> *,std::vector<wchar_t const *,std::allocator<wchar_t const *>> *,wchar_t const *,uint,std::random_access_iterator_tag)+39j
.text$mn:00002528                 pop     ebp
.text$mn:00002529                 retn
.text$mn:00002529 ??$_Debug_range2@PAV?$vector@PB_WV?$allocator@PB_W@std@@@std@@@std@@YAXPAV?$vector@PB_WV?$allocator@PB_W@std@@@0@0PB_WIUrandom_access_iterator_tag@0@@Z endp
.text$mn:00002529
.text$mn:00002529 ; ---------------------------------------------------------------------------
.text$mn:0000252A                 align 4
.text$mn:0000252A _text$mn        ends
.text$mn:0000252A
.text$mn:0000252C ; ===========================================================================
.text$mn:0000252C
.text$mn:0000252C ; Segment type: Pure code
.text$mn:0000252C ; Segment permissions: Read/Execute
.text$mn:0000252C _text$mn        segment para public 'CODE' use32
.text$mn:0000252C                 assume cs:_text$mn
.text$mn:0000252C                 ;org 252Ch
.text$mn:0000252C ; COMDAT (pick any)
.text$mn:0000252C                 assume es:nothing, ss:nothing, ds:_data, fs:nothing, gs:nothing
.text$mn:0000252C
.text$mn:0000252C ; =============== S U B R O U T I N E =======================================
.text$mn:0000252C
.text$mn:0000252C ; Attributes: bp-based frame
.text$mn:0000252C
.text$mn:0000252C ; int __cdecl std::_Debug_range2<wchar_t const * const *>(int, int, wchar_t *, unsigned int)
.text$mn:0000252C                 public ??$_Debug_range2@PBQB_W@std@@YAXPBQB_W0PB_WIUrandom_access_iterator_tag@0@@Z
.text$mn:0000252C ??$_Debug_range2@PBQB_W@std@@YAXPBQB_W0PB_WIUrandom_access_iterator_tag@0@@Z proc near
.text$mn:0000252C                                         ; CODE XREF: std::_Debug_range<wchar_t const * const *>(wchar_t const * const *,wchar_t const * const *,wchar_t const *,uint)+2Ap
.text$mn:0000252C
.text$mn:0000252C arg_0           = dword ptr  8
.text$mn:0000252C arg_4           = dword ptr  0Ch
.text$mn:0000252C arg_8           = dword ptr  10h
.text$mn:0000252C arg_C           = dword ptr  14h
.text$mn:0000252C
.text$mn:0000252C                 push    ebp
.text$mn:0000252D                 mov     ebp, esp
.text$mn:0000252F                 mov     eax, [ebp+arg_0]
.text$mn:00002532                 cmp     eax, [ebp+arg_4]
.text$mn:00002535                 jz      short loc_257C
.text$mn:00002537                 mov     ecx, [ebp+arg_C]
.text$mn:0000253A                 push    ecx             ; unsigned int
.text$mn:0000253B                 mov     edx, [ebp+arg_8]
.text$mn:0000253E                 push    edx             ; wchar_t *
.text$mn:0000253F                 mov     eax, [ebp+arg_0]
.text$mn:00002542                 push    eax             ; int
.text$mn:00002543                 call    ??$_Debug_pointer@PB_W@std@@YAXPBQB_WPB_WI@Z ; std::_Debug_pointer<wchar_t const *>(wchar_t const * const *,wchar_t const *,uint)
.text$mn:00002548                 add     esp, 0Ch
.text$mn:0000254B                 mov     ecx, [ebp+arg_C]
.text$mn:0000254E                 push    ecx             ; unsigned int
.text$mn:0000254F                 mov     edx, [ebp+arg_8]
.text$mn:00002552                 push    edx             ; wchar_t *
.text$mn:00002553                 mov     eax, [ebp+arg_4]
.text$mn:00002556                 push    eax             ; int
.text$mn:00002557                 call    ??$_Debug_pointer@PB_W@std@@YAXPBQB_WPB_WI@Z ; std::_Debug_pointer<wchar_t const *>(wchar_t const * const *,wchar_t const *,uint)
.text$mn:0000255C                 add     esp, 0Ch
.text$mn:0000255F                 mov     ecx, [ebp+arg_4]
.text$mn:00002562                 cmp     ecx, [ebp+arg_0]
.text$mn:00002565                 jnb     short loc_257C
.text$mn:00002567                 mov     edx, [ebp+arg_C]
.text$mn:0000256A                 push    edx             ; unsigned int
.text$mn:0000256B                 mov     eax, [ebp+arg_8]
.text$mn:0000256E                 push    eax             ; wchar_t *
.text$mn:0000256F                 push    offset ??_C@_1CO@DGLIKNHI@?$AAi?$AAn?$AAv?$AAa?$AAl?$AAi?$AAd?$AA?5?$AAi?$AAt?$AAe?$AAr?$AAa?$AAt?$AAo?$AAr?$AA?5?$AAr?$AAa?$AAn?$AAg?$AAe?$AA?$AA@ ; "invalid iterator range"
.text$mn:00002574                 call    ?_Debug_message@std@@YAXPB_W0I@Z ; std::_Debug_message(wchar_t const *,wchar_t const *,uint)
.text$mn:00002579                 add     esp, 0Ch
.text$mn:0000257C
.text$mn:0000257C loc_257C:                               ; CODE XREF: std::_Debug_range2<wchar_t const * const *>(wchar_t const * const *,wchar_t const * const *,wchar_t const *,uint,std::random_access_iterator_tag)+9j
.text$mn:0000257C                                         ; std::_Debug_range2<wchar_t const * const *>(wchar_t const * const *,wchar_t const * const *,wchar_t const *,uint,std::random_access_iterator_tag)+39j
.text$mn:0000257C                 pop     ebp
.text$mn:0000257D                 retn
.text$mn:0000257D ??$_Debug_range2@PBQB_W@std@@YAXPBQB_W0PB_WIUrandom_access_iterator_tag@0@@Z endp
.text$mn:0000257D
.text$mn:0000257D ; ---------------------------------------------------------------------------
.text$mn:0000257E                 align 10h
.text$mn:0000257E _text$mn        ends
.text$mn:0000257E
.text$mn:00002580 ; ===========================================================================
.text$mn:00002580
.text$mn:00002580 ; Segment type: Pure code
.text$mn:00002580 ; Segment permissions: Read/Execute
.text$mn:00002580 _text$mn        segment para public 'CODE' use32
.text$mn:00002580                 assume cs:_text$mn
.text$mn:00002580                 ;org 2580h
.text$mn:00002580 ; COMDAT (pick any)
.text$mn:00002580                 assume es:nothing, ss:nothing, ds:_data, fs:nothing, gs:nothing
.text$mn:00002580
.text$mn:00002580 ; =============== S U B R O U T I N E =======================================
.text$mn:00002580
.text$mn:00002580 ; Attributes: bp-based frame
.text$mn:00002580
.text$mn:00002580 ; int __cdecl std::_Debug_range<wchar_t const * *>(int, int, wchar_t *, unsigned int)
.text$mn:00002580                 public ??$_Debug_range@PAPB_W@std@@YAXPAPB_W0PB_WI@Z
.text$mn:00002580 ??$_Debug_range@PAPB_W@std@@YAXPAPB_W0PB_WI@Z proc near
.text$mn:00002580                                         ; CODE XREF: std::_Uninit_move<wchar_t const *,wchar_t const *,wchar_t const *>(wchar_t const * *,wchar_t const * *,wchar_t const * *,std::_Wrap_alloc<std::allocator<wchar_t const *>> &,wchar_t const * *,std::_Scalar_ptr_iterator_tag)+16p
.text$mn:00002580
.text$mn:00002580 var_1           = byte ptr -1
.text$mn:00002580 arg_0           = dword ptr  8
.text$mn:00002580 arg_4           = dword ptr  0Ch
.text$mn:00002580 arg_8           = dword ptr  10h
.text$mn:00002580 arg_C           = dword ptr  14h
.text$mn:00002580
.text$mn:00002580                 push    ebp
.text$mn:00002581                 mov     ebp, esp
.text$mn:00002583                 push    ecx
.text$mn:00002584                 lea     eax, [ebp+arg_0]
.text$mn:00002587                 push    eax
.text$mn:00002588                 lea     ecx, [ebp+var_1]
.text$mn:0000258B                 push    ecx
.text$mn:0000258C                 call    ??$_Iter_cat@PAPB_W@std@@YA?AUrandom_access_iterator_tag@0@ABQAPB_W@Z ; std::_Iter_cat<wchar_t const * *>(wchar_t const * * const &)
.text$mn:00002591                 add     esp, 8
.text$mn:00002594                 mov     dl, [eax]
.text$mn:00002596                 movzx   eax, dl
.text$mn:00002599                 push    eax
.text$mn:0000259A                 mov     ecx, [ebp+arg_C]
.text$mn:0000259D                 push    ecx             ; unsigned int
.text$mn:0000259E                 mov     edx, [ebp+arg_8]
.text$mn:000025A1                 push    edx             ; wchar_t *
.text$mn:000025A2                 mov     eax, [ebp+arg_4]
.text$mn:000025A5                 push    eax             ; int
.text$mn:000025A6                 mov     ecx, [ebp+arg_0]
.text$mn:000025A9                 push    ecx             ; int
.text$mn:000025AA                 call    ??$_Debug_range2@PAPB_W@std@@YAXPAPB_W0PB_WIUrandom_access_iterator_tag@0@@Z ; std::_Debug_range2<wchar_t const * *>(wchar_t const * *,wchar_t const * *,wchar_t const *,uint,std::random_access_iterator_tag)
.text$mn:000025AF                 add     esp, 14h
.text$mn:000025B2                 mov     esp, ebp
.text$mn:000025B4                 pop     ebp
.text$mn:000025B5                 retn
.text$mn:000025B5 ??$_Debug_range@PAPB_W@std@@YAXPAPB_W0PB_WI@Z endp
.text$mn:000025B5
.text$mn:000025B5 ; ---------------------------------------------------------------------------
.text$mn:000025B6                 align 4
.text$mn:000025B6 _text$mn        ends
.text$mn:000025B6
.text$mn:000025B8 ; ===========================================================================
.text$mn:000025B8
.text$mn:000025B8 ; Segment type: Pure code
.text$mn:000025B8 ; Segment permissions: Read/Execute
.text$mn:000025B8 _text$mn        segment para public 'CODE' use32
.text$mn:000025B8                 assume cs:_text$mn
.text$mn:000025B8                 ;org 25B8h
.text$mn:000025B8 ; COMDAT (pick any)
.text$mn:000025B8                 assume es:nothing, ss:nothing, ds:_data, fs:nothing, gs:nothing
.text$mn:000025B8
.text$mn:000025B8 ; =============== S U B R O U T I N E =======================================
.text$mn:000025B8
.text$mn:000025B8 ; Attributes: bp-based frame
.text$mn:000025B8
.text$mn:000025B8 ; int __cdecl std::_Debug_range<FunctionValues *>(int, int, wchar_t *, unsigned int)
.text$mn:000025B8                 public ??$_Debug_range@PAUFunctionValues@@@std@@YAXPAUFunctionValues@@0PB_WI@Z
.text$mn:000025B8 ??$_Debug_range@PAUFunctionValues@@@std@@YAXPAUFunctionValues@@0PB_WI@Z proc near
.text$mn:000025B8                                         ; CODE XREF: std::_Uninit_move<FunctionValues *,FunctionValues *,std::allocator<FunctionValues>,FunctionValues>(FunctionValues *,FunctionValues *,FunctionValues *,std::_Wrap_alloc<std::allocator<FunctionValues>> &,FunctionValues *,std::_Nonscalar_ptr_iterator_tag)+3Cp
.text$mn:000025B8
.text$mn:000025B8 var_1           = byte ptr -1
.text$mn:000025B8 arg_0           = dword ptr  8
.text$mn:000025B8 arg_4           = dword ptr  0Ch
.text$mn:000025B8 arg_8           = dword ptr  10h
.text$mn:000025B8 arg_C           = dword ptr  14h
.text$mn:000025B8
.text$mn:000025B8                 push    ebp
.text$mn:000025B9                 mov     ebp, esp
.text$mn:000025BB                 push    ecx
.text$mn:000025BC                 lea     eax, [ebp+arg_0]
.text$mn:000025BF                 push    eax
.text$mn:000025C0                 lea     ecx, [ebp+var_1]
.text$mn:000025C3                 push    ecx
.text$mn:000025C4                 call    ??$_Iter_cat@PAUFunctionValues@@@std@@YA?AUrandom_access_iterator_tag@0@ABQAUFunctionValues@@@Z ; std::_Iter_cat<FunctionValues *>(FunctionValues * const &)
.text$mn:000025C9                 add     esp, 8
.text$mn:000025CC                 mov     dl, [eax]
.text$mn:000025CE                 movzx   eax, dl
.text$mn:000025D1                 push    eax
.text$mn:000025D2                 mov     ecx, [ebp+arg_C]
.text$mn:000025D5                 push    ecx             ; unsigned int
.text$mn:000025D6                 mov     edx, [ebp+arg_8]
.text$mn:000025D9                 push    edx             ; wchar_t *
.text$mn:000025DA                 mov     eax, [ebp+arg_4]
.text$mn:000025DD                 push    eax             ; int
.text$mn:000025DE                 mov     ecx, [ebp+arg_0]
.text$mn:000025E1                 push    ecx             ; int
.text$mn:000025E2                 call    ??$_Debug_range2@PAUFunctionValues@@@std@@YAXPAUFunctionValues@@0PB_WIUrandom_access_iterator_tag@0@@Z ; std::_Debug_range2<FunctionValues *>(FunctionValues *,FunctionValues *,wchar_t const *,uint,std::random_access_iterator_tag)
.text$mn:000025E7                 add     esp, 14h
.text$mn:000025EA                 mov     esp, ebp
.text$mn:000025EC                 pop     ebp
.text$mn:000025ED                 retn
.text$mn:000025ED ??$_Debug_range@PAUFunctionValues@@@std@@YAXPAUFunctionValues@@0PB_WI@Z endp
.text$mn:000025ED
.text$mn:000025ED ; ---------------------------------------------------------------------------
.text$mn:000025EE                 align 10h
.text$mn:000025EE _text$mn        ends
.text$mn:000025EE
.text$mn:000025F0 ; ===========================================================================
.text$mn:000025F0
.text$mn:000025F0 ; Segment type: Pure code
.text$mn:000025F0 ; Segment permissions: Read/Execute
.text$mn:000025F0 _text$mn        segment para public 'CODE' use32
.text$mn:000025F0                 assume cs:_text$mn
.text$mn:000025F0                 ;org 25F0h
.text$mn:000025F0 ; COMDAT (pick any)
.text$mn:000025F0                 assume es:nothing, ss:nothing, ds:_data, fs:nothing, gs:nothing
.text$mn:000025F0
.text$mn:000025F0 ; =============== S U B R O U T I N E =======================================
.text$mn:000025F0
.text$mn:000025F0 ; Attributes: bp-based frame
.text$mn:000025F0
.text$mn:000025F0 ; int __cdecl std::_Debug_range<Token *>(int, int, wchar_t *, unsigned int)
.text$mn:000025F0                 public ??$_Debug_range@PAUToken@@@std@@YAXPAUToken@@0PB_WI@Z
.text$mn:000025F0 ??$_Debug_range@PAUToken@@@std@@YAXPAUToken@@0PB_WI@Z proc near
.text$mn:000025F0                                         ; CODE XREF: std::_Uninit_move<Token *,Token *,std::allocator<Token>,Token>(Token *,Token *,Token *,std::_Wrap_alloc<std::allocator<Token>> &,Token *,std::_Nonscalar_ptr_iterator_tag)+3Cp
.text$mn:000025F0
.text$mn:000025F0 var_1           = byte ptr -1
.text$mn:000025F0 arg_0           = dword ptr  8
.text$mn:000025F0 arg_4           = dword ptr  0Ch
.text$mn:000025F0 arg_8           = dword ptr  10h
.text$mn:000025F0 arg_C           = dword ptr  14h
.text$mn:000025F0
.text$mn:000025F0                 push    ebp
.text$mn:000025F1                 mov     ebp, esp
.text$mn:000025F3                 push    ecx
.text$mn:000025F4                 lea     eax, [ebp+arg_0]
.text$mn:000025F7                 push    eax
.text$mn:000025F8                 lea     ecx, [ebp+var_1]
.text$mn:000025FB                 push    ecx
.text$mn:000025FC                 call    ??$_Iter_cat@PAUToken@@@std@@YA?AUrandom_access_iterator_tag@0@ABQAUToken@@@Z ; std::_Iter_cat<Token *>(Token * const &)
.text$mn:00002601                 add     esp, 8
.text$mn:00002604                 mov     dl, [eax]
.text$mn:00002606                 movzx   eax, dl
.text$mn:00002609                 push    eax
.text$mn:0000260A                 mov     ecx, [ebp+arg_C]
.text$mn:0000260D                 push    ecx             ; unsigned int
.text$mn:0000260E                 mov     edx, [ebp+arg_8]
.text$mn:00002611                 push    edx             ; wchar_t *
.text$mn:00002612                 mov     eax, [ebp+arg_4]
.text$mn:00002615                 push    eax             ; int
.text$mn:00002616                 mov     ecx, [ebp+arg_0]
.text$mn:00002619                 push    ecx             ; int
.text$mn:0000261A                 call    ??$_Debug_range2@PAUToken@@@std@@YAXPAUToken@@0PB_WIUrandom_access_iterator_tag@0@@Z ; std::_Debug_range2<Token *>(Token *,Token *,wchar_t const *,uint,std::random_access_iterator_tag)
.text$mn:0000261F                 add     esp, 14h
.text$mn:00002622                 mov     esp, ebp
.text$mn:00002624                 pop     ebp
.text$mn:00002625                 retn
.text$mn:00002625 ??$_Debug_range@PAUToken@@@std@@YAXPAUToken@@0PB_WI@Z endp
.text$mn:00002625
.text$mn:00002625 ; ---------------------------------------------------------------------------
.text$mn:00002626                 align 4
.text$mn:00002626 _text$mn        ends
.text$mn:00002626
.text$mn:00002628 ; ===========================================================================
.text$mn:00002628
.text$mn:00002628 ; Segment type: Pure code
.text$mn:00002628 ; Segment permissions: Read/Execute
.text$mn:00002628 _text$mn        segment para public 'CODE' use32
.text$mn:00002628                 assume cs:_text$mn
.text$mn:00002628                 ;org 2628h
.text$mn:00002628 ; COMDAT (pick any)
.text$mn:00002628                 assume es:nothing, ss:nothing, ds:_data, fs:nothing, gs:nothing
.text$mn:00002628
.text$mn:00002628 ; =============== S U B R O U T I N E =======================================
.text$mn:00002628
.text$mn:00002628 ; Attributes: bp-based frame
.text$mn:00002628
.text$mn:00002628 ; int __cdecl std::_Debug_range<std::vector<wchar_t const *,std::allocator<wchar_t const *>> *>(int, int, wchar_t *, unsigned int)
.text$mn:00002628                 public ??$_Debug_range@PAV?$vector@PB_WV?$allocator@PB_W@std@@@std@@@std@@YAXPAV?$vector@PB_WV?$allocator@PB_W@std@@@0@0PB_WI@Z
.text$mn:00002628 ??$_Debug_range@PAV?$vector@PB_WV?$allocator@PB_W@std@@@std@@@std@@YAXPAV?$vector@PB_WV?$allocator@PB_W@std@@@0@0PB_WI@Z proc near
.text$mn:00002628                                         ; CODE XREF: std::_Uninit_move<std::vector<wchar_t const *,std::allocator<wchar_t const *>> *,std::vector<wchar_t const *,std::allocator<wchar_t const *>> *,std::allocator<std::vector<wchar_t const *,std::allocator<wchar_t const *>>>,std::vector<wchar_t const *,std::allocator<wchar_t const *>>>(std::vector<wchar_t const *,std::allocator<wchar_t const *>> *,std::vector<wchar_t const *,std::allocator<wchar_t const *>> *,std::vector<wchar_t const *,std::allocator<wchar_t const *>> *,std::_Wrap_alloc<std::allocator<std::vector<wchar_t const *,std::allocator<wchar_t const *>>>> &,std::vector<wchar_t const *,std::allocator<wchar_t const *>> *,std::_Nonscalar_ptr_iterator_tag)+3Cp
.text$mn:00002628
.text$mn:00002628 var_1           = byte ptr -1
.text$mn:00002628 arg_0           = dword ptr  8
.text$mn:00002628 arg_4           = dword ptr  0Ch
.text$mn:00002628 arg_8           = dword ptr  10h
.text$mn:00002628 arg_C           = dword ptr  14h
.text$mn:00002628
.text$mn:00002628                 push    ebp
.text$mn:00002629                 mov     ebp, esp
.text$mn:0000262B                 push    ecx
.text$mn:0000262C                 lea     eax, [ebp+arg_0]
.text$mn:0000262F                 push    eax
.text$mn:00002630                 lea     ecx, [ebp+var_1]
.text$mn:00002633                 push    ecx
.text$mn:00002634                 call    ??$_Iter_cat@PAV?$vector@PB_WV?$allocator@PB_W@std@@@std@@@std@@YA?AUrandom_access_iterator_tag@0@ABQAV?$vector@PB_WV?$allocator@PB_W@std@@@0@@Z ; std::_Iter_cat<std::vector<wchar_t const *,std::allocator<wchar_t const *>> *>(std::vector<wchar_t const *,std::allocator<wchar_t const *>> * const &)
.text$mn:00002639                 add     esp, 8
.text$mn:0000263C                 mov     dl, [eax]
.text$mn:0000263E                 movzx   eax, dl
.text$mn:00002641                 push    eax
.text$mn:00002642                 mov     ecx, [ebp+arg_C]
.text$mn:00002645                 push    ecx             ; unsigned int
.text$mn:00002646                 mov     edx, [ebp+arg_8]
.text$mn:00002649                 push    edx             ; wchar_t *
.text$mn:0000264A                 mov     eax, [ebp+arg_4]
.text$mn:0000264D                 push    eax             ; int
.text$mn:0000264E                 mov     ecx, [ebp+arg_0]
.text$mn:00002651                 push    ecx             ; int
.text$mn:00002652                 call    ??$_Debug_range2@PAV?$vector@PB_WV?$allocator@PB_W@std@@@std@@@std@@YAXPAV?$vector@PB_WV?$allocator@PB_W@std@@@0@0PB_WIUrandom_access_iterator_tag@0@@Z ; std::_Debug_range2<std::vector<wchar_t const *,std::allocator<wchar_t const *>> *>(std::vector<wchar_t const *,std::allocator<wchar_t const *>> *,std::vector<wchar_t const *,std::allocator<wchar_t const *>> *,wchar_t const *,uint,std::random_access_iterator_tag)
.text$mn:00002657                 add     esp, 14h
.text$mn:0000265A                 mov     esp, ebp
.text$mn:0000265C                 pop     ebp
.text$mn:0000265D                 retn
.text$mn:0000265D ??$_Debug_range@PAV?$vector@PB_WV?$allocator@PB_W@std@@@std@@@std@@YAXPAV?$vector@PB_WV?$allocator@PB_W@std@@@0@0PB_WI@Z endp
.text$mn:0000265D
.text$mn:0000265D ; ---------------------------------------------------------------------------
.text$mn:0000265E                 align 10h
.text$mn:0000265E _text$mn        ends
.text$mn:0000265E
.text$mn:00002660 ; ===========================================================================
.text$mn:00002660
.text$mn:00002660 ; Segment type: Pure code
.text$mn:00002660 ; Segment permissions: Read/Execute
.text$mn:00002660 _text$mn        segment para public 'CODE' use32
.text$mn:00002660                 assume cs:_text$mn
.text$mn:00002660                 ;org 2660h
.text$mn:00002660 ; COMDAT (pick any)
.text$mn:00002660                 assume es:nothing, ss:nothing, ds:_data, fs:nothing, gs:nothing
.text$mn:00002660
.text$mn:00002660 ; =============== S U B R O U T I N E =======================================
.text$mn:00002660
.text$mn:00002660 ; Attributes: bp-based frame
.text$mn:00002660
.text$mn:00002660 ; int __cdecl std::_Debug_range<wchar_t const * const *>(int, int, wchar_t *, unsigned int)
.text$mn:00002660                 public ??$_Debug_range@PBQB_W@std@@YAXPBQB_W0PB_WI@Z
.text$mn:00002660 ??$_Debug_range@PBQB_W@std@@YAXPBQB_W0PB_WI@Z proc near
.text$mn:00002660                                         ; CODE XREF: std::_Uninit_copy<wchar_t const * const,wchar_t const *>(wchar_t const * const *,wchar_t const * const *,wchar_t const * *,std::_Wrap_alloc<std::allocator<wchar_t const *>> &,std::_Scalar_ptr_iterator_tag)+16p
.text$mn:00002660
.text$mn:00002660 var_1           = byte ptr -1
.text$mn:00002660 arg_0           = dword ptr  8
.text$mn:00002660 arg_4           = dword ptr  0Ch
.text$mn:00002660 arg_8           = dword ptr  10h
.text$mn:00002660 arg_C           = dword ptr  14h
.text$mn:00002660
.text$mn:00002660                 push    ebp
.text$mn:00002661                 mov     ebp, esp
.text$mn:00002663                 push    ecx
.text$mn:00002664                 lea     eax, [ebp+arg_0]
.text$mn:00002667                 push    eax
.text$mn:00002668                 lea     ecx, [ebp+var_1]
.text$mn:0000266B                 push    ecx
.text$mn:0000266C                 call    ??$_Iter_cat@PBQB_W@std@@YA?AUrandom_access_iterator_tag@0@ABQBQB_W@Z ; std::_Iter_cat<wchar_t const * const *>(wchar_t const * const * const &)
.text$mn:00002671                 add     esp, 8
.text$mn:00002674                 mov     dl, [eax]
.text$mn:00002676                 movzx   eax, dl
.text$mn:00002679                 push    eax
.text$mn:0000267A                 mov     ecx, [ebp+arg_C]
.text$mn:0000267D                 push    ecx             ; unsigned int
.text$mn:0000267E                 mov     edx, [ebp+arg_8]
.text$mn:00002681                 push    edx             ; wchar_t *
.text$mn:00002682                 mov     eax, [ebp+arg_4]
.text$mn:00002685                 push    eax             ; int
.text$mn:00002686                 mov     ecx, [ebp+arg_0]
.text$mn:00002689                 push    ecx             ; int
.text$mn:0000268A                 call    ??$_Debug_range2@PBQB_W@std@@YAXPBQB_W0PB_WIUrandom_access_iterator_tag@0@@Z ; std::_Debug_range2<wchar_t const * const *>(wchar_t const * const *,wchar_t const * const *,wchar_t const *,uint,std::random_access_iterator_tag)
.text$mn:0000268F                 add     esp, 14h
.text$mn:00002692                 mov     esp, ebp
.text$mn:00002694                 pop     ebp
.text$mn:00002695                 retn
.text$mn:00002695 ??$_Debug_range@PBQB_W@std@@YAXPBQB_W0PB_WI@Z endp
.text$mn:00002695
.text$mn:00002695 ; ---------------------------------------------------------------------------
.text$mn:00002696                 align 4
.text$mn:00002696 _text$mn        ends
.text$mn:00002696
.text$mn:00002698 ; ===========================================================================
.text$mn:00002698
.text$mn:00002698 ; Segment type: Pure code
.text$mn:00002698 ; Segment permissions: Read/Execute
.text$mn:00002698 _text$mn        segment para public 'CODE' use32
.text$mn:00002698                 assume cs:_text$mn
.text$mn:00002698                 ;org 2698h
.text$mn:00002698 ; COMDAT (pick any)
.text$mn:00002698                 assume es:nothing, ss:nothing, ds:_data, fs:nothing, gs:nothing
.text$mn:00002698
.text$mn:00002698 ; =============== S U B R O U T I N E =======================================
.text$mn:00002698
.text$mn:00002698 ; Attributes: bp-based frame
.text$mn:00002698
.text$mn:00002698 ; void __cdecl std::_Destroy_range<struct std::_Wrap_alloc<class std::allocator<wchar_t const *>>>(wchar_t const * *, wchar_t const * *, struct std::_Wrap_alloc<class std::allocator<wchar_t const *>> &)
.text$mn:00002698                 public ??$_Destroy_range@U?$_Wrap_alloc@V?$allocator@PB_W@std@@@std@@@std@@YAXPAPB_W0AAU?$_Wrap_alloc@V?$allocator@PB_W@std@@@0@@Z
.text$mn:00002698 ??$_Destroy_range@U?$_Wrap_alloc@V?$allocator@PB_W@std@@@std@@@std@@YAXPAPB_W0AAU?$_Wrap_alloc@V?$allocator@PB_W@std@@@0@@Z proc near
.text$mn:00002698                                         ; CODE XREF: std::vector<wchar_t const *,std::allocator<wchar_t const *>>::_Destroy(wchar_t const * *,wchar_t const * *)+21p
.text$mn:00002698
.text$mn:00002698 var_1           = byte ptr -1
.text$mn:00002698 arg_0           = dword ptr  8
.text$mn:00002698 arg_4           = dword ptr  0Ch
.text$mn:00002698 arg_8           = dword ptr  10h
.text$mn:00002698
.text$mn:00002698                 push    ebp
.text$mn:00002699                 mov     ebp, esp
.text$mn:0000269B                 push    ecx
.text$mn:0000269C                 mov     eax, [ebp+arg_4]
.text$mn:0000269F                 push    eax
.text$mn:000026A0                 mov     ecx, [ebp+arg_0]
.text$mn:000026A3                 push    ecx
.text$mn:000026A4                 call    ??$_Ptr_cat@PB_WPB_W@std@@YA?AU_Scalar_ptr_iterator_tag@0@PAPB_W0@Z ; std::_Ptr_cat<wchar_t const *,wchar_t const *>(wchar_t const * *,wchar_t const * *)
.text$mn:000026A9                 add     esp, 8
.text$mn:000026AC                 mov     [ebp+var_1], al
.text$mn:000026AF                 movzx   edx, [ebp+var_1]
.text$mn:000026B3                 push    edx
.text$mn:000026B4                 mov     eax, [ebp+arg_8]
.text$mn:000026B7                 push    eax
.text$mn:000026B8                 mov     ecx, [ebp+arg_4]
.text$mn:000026BB                 push    ecx
.text$mn:000026BC                 mov     edx, [ebp+arg_0]
.text$mn:000026BF                 push    edx
.text$mn:000026C0                 call    ??$_Destroy_range@U?$_Wrap_alloc@V?$allocator@PB_W@std@@@std@@@std@@YAXPAPB_W0AAU?$_Wrap_alloc@V?$allocator@PB_W@std@@@0@U_Scalar_ptr_iterator_tag@0@@Z ; std::_Destroy_range<std::_Wrap_alloc<std::allocator<wchar_t const *>>>(wchar_t const * *,wchar_t const * *,std::_Wrap_alloc<std::allocator<wchar_t const *>> &,std::_Scalar_ptr_iterator_tag)
.text$mn:000026C5                 add     esp, 10h
.text$mn:000026C8                 mov     esp, ebp
.text$mn:000026CA                 pop     ebp
.text$mn:000026CB                 retn
.text$mn:000026CB ??$_Destroy_range@U?$_Wrap_alloc@V?$allocator@PB_W@std@@@std@@@std@@YAXPAPB_W0AAU?$_Wrap_alloc@V?$allocator@PB_W@std@@@0@@Z endp
.text$mn:000026CB
.text$mn:000026CB _text$mn        ends
.text$mn:000026CB
.text$mn:000026CC ; ===========================================================================
.text$mn:000026CC
.text$mn:000026CC ; Segment type: Pure code
.text$mn:000026CC ; Segment permissions: Read/Execute
.text$mn:000026CC _text$mn        segment para public 'CODE' use32
.text$mn:000026CC                 assume cs:_text$mn
.text$mn:000026CC                 ;org 26CCh
.text$mn:000026CC ; COMDAT (pick any)
.text$mn:000026CC                 assume es:nothing, ss:nothing, ds:_data, fs:nothing, gs:nothing
.text$mn:000026CC
.text$mn:000026CC ; =============== S U B R O U T I N E =======================================
.text$mn:000026CC
.text$mn:000026CC ; Attributes: bp-based frame
.text$mn:000026CC
.text$mn:000026CC ; void __cdecl std::_Destroy_range<struct std::_Wrap_alloc<class std::allocator<wchar_t const *>>>(wchar_t const * *, wchar_t const * *, struct std::_Wrap_alloc<class std::allocator<wchar_t const *>> &, struct std::_Scalar_ptr_iterator_tag)
.text$mn:000026CC                 public ??$_Destroy_range@U?$_Wrap_alloc@V?$allocator@PB_W@std@@@std@@@std@@YAXPAPB_W0AAU?$_Wrap_alloc@V?$allocator@PB_W@std@@@0@U_Scalar_ptr_iterator_tag@0@@Z
.text$mn:000026CC ??$_Destroy_range@U?$_Wrap_alloc@V?$allocator@PB_W@std@@@std@@@std@@YAXPAPB_W0AAU?$_Wrap_alloc@V?$allocator@PB_W@std@@@0@U_Scalar_ptr_iterator_tag@0@@Z proc near
.text$mn:000026CC                                         ; CODE XREF: std::_Destroy_range<std::_Wrap_alloc<std::allocator<wchar_t const *>>>(wchar_t const * *,wchar_t const * *,std::_Wrap_alloc<std::allocator<wchar_t const *>> &)+28p
.text$mn:000026CC                 push    ebp
.text$mn:000026CD                 mov     ebp, esp
.text$mn:000026CF                 pop     ebp
.text$mn:000026D0                 retn
.text$mn:000026D0 ??$_Destroy_range@U?$_Wrap_alloc@V?$allocator@PB_W@std@@@std@@@std@@YAXPAPB_W0AAU?$_Wrap_alloc@V?$allocator@PB_W@std@@@0@U_Scalar_ptr_iterator_tag@0@@Z endp
.text$mn:000026D0
.text$mn:000026D0 ; ---------------------------------------------------------------------------
.text$mn:000026D1                 align 4
.text$mn:000026D1 _text$mn        ends
.text$mn:000026D1
.text$mn:000026D4 ; ===========================================================================
.text$mn:000026D4
.text$mn:000026D4 ; Segment type: Pure code
.text$mn:000026D4 ; Segment permissions: Read/Execute
.text$mn:000026D4 _text$mn        segment para public 'CODE' use32
.text$mn:000026D4                 assume cs:_text$mn
.text$mn:000026D4                 ;org 26D4h
.text$mn:000026D4 ; COMDAT (pick any)
.text$mn:000026D4                 assume es:nothing, ss:nothing, ds:_data, fs:nothing, gs:nothing
.text$mn:000026D4
.text$mn:000026D4 ; =============== S U B R O U T I N E =======================================
.text$mn:000026D4
.text$mn:000026D4 ; Attributes: bp-based frame
.text$mn:000026D4
.text$mn:000026D4 ; void __cdecl std::_Destroy_range<struct std::_Wrap_alloc<class std::allocator<struct FunctionValues>>>(struct FunctionValues *, struct FunctionValues *, struct std::_Wrap_alloc<class std::allocator<struct FunctionValues>> &)
.text$mn:000026D4                 public ??$_Destroy_range@U?$_Wrap_alloc@V?$allocator@UFunctionValues@@@std@@@std@@@std@@YAXPAUFunctionValues@@0AAU?$_Wrap_alloc@V?$allocator@UFunctionValues@@@std@@@0@@Z
.text$mn:000026D4 ??$_Destroy_range@U?$_Wrap_alloc@V?$allocator@UFunctionValues@@@std@@@std@@@std@@YAXPAUFunctionValues@@0AAU?$_Wrap_alloc@V?$allocator@UFunctionValues@@@std@@@0@@Z proc near
.text$mn:000026D4                                         ; CODE XREF: std::vector<FunctionValues,std::allocator<FunctionValues>>::_Destroy(FunctionValues *,FunctionValues *)+21p
.text$mn:000026D4
.text$mn:000026D4 var_1           = byte ptr -1
.text$mn:000026D4 arg_0           = dword ptr  8
.text$mn:000026D4 arg_4           = dword ptr  0Ch
.text$mn:000026D4 arg_8           = dword ptr  10h
.text$mn:000026D4
.text$mn:000026D4                 push    ebp
.text$mn:000026D5                 mov     ebp, esp
.text$mn:000026D7                 push    ecx
.text$mn:000026D8                 mov     eax, [ebp+arg_4]
.text$mn:000026DB                 push    eax
.text$mn:000026DC                 mov     ecx, [ebp+arg_0]
.text$mn:000026DF                 push    ecx
.text$mn:000026E0                 call    ??$_Ptr_cat@UFunctionValues@@U1@@std@@YA?AU_Nonscalar_ptr_iterator_tag@0@PAUFunctionValues@@0@Z ; std::_Ptr_cat<FunctionValues,FunctionValues>(FunctionValues *,FunctionValues *)
.text$mn:000026E5                 add     esp, 8
.text$mn:000026E8                 mov     [ebp+var_1], al
.text$mn:000026EB                 movzx   edx, [ebp+var_1]
.text$mn:000026EF                 push    edx
.text$mn:000026F0                 mov     eax, [ebp+arg_8]
.text$mn:000026F3                 push    eax
.text$mn:000026F4                 mov     ecx, [ebp+arg_4]
.text$mn:000026F7                 push    ecx
.text$mn:000026F8                 mov     edx, [ebp+arg_0]
.text$mn:000026FB                 push    edx
.text$mn:000026FC                 call    ??$_Destroy_range@U?$_Wrap_alloc@V?$allocator@UFunctionValues@@@std@@@std@@@std@@YAXPAUFunctionValues@@0AAU?$_Wrap_alloc@V?$allocator@UFunctionValues@@@std@@@0@U_Nonscalar_ptr_iterator_tag@0@@Z ; std::_Destroy_range<std::_Wrap_alloc<std::allocator<FunctionValues>>>(FunctionValues *,FunctionValues *,std::_Wrap_alloc<std::allocator<FunctionValues>> &,std::_Nonscalar_ptr_iterator_tag)
.text$mn:00002701                 add     esp, 10h
.text$mn:00002704                 mov     esp, ebp
.text$mn:00002706                 pop     ebp
.text$mn:00002707                 retn
.text$mn:00002707 ??$_Destroy_range@U?$_Wrap_alloc@V?$allocator@UFunctionValues@@@std@@@std@@@std@@YAXPAUFunctionValues@@0AAU?$_Wrap_alloc@V?$allocator@UFunctionValues@@@std@@@0@@Z endp
.text$mn:00002707
.text$mn:00002707 _text$mn        ends
.text$mn:00002707
.text$mn:00002708 ; ===========================================================================
.text$mn:00002708
.text$mn:00002708 ; Segment type: Pure code
.text$mn:00002708 ; Segment permissions: Read/Execute
.text$mn:00002708 _text$mn        segment para public 'CODE' use32
.text$mn:00002708                 assume cs:_text$mn
.text$mn:00002708                 ;org 2708h
.text$mn:00002708 ; COMDAT (pick any)
.text$mn:00002708                 assume es:nothing, ss:nothing, ds:_data, fs:nothing, gs:nothing
.text$mn:00002708
.text$mn:00002708 ; =============== S U B R O U T I N E =======================================
.text$mn:00002708
.text$mn:00002708 ; Attributes: bp-based frame
.text$mn:00002708
.text$mn:00002708 ; void __cdecl std::_Destroy_range<struct std::_Wrap_alloc<class std::allocator<struct FunctionValues>>>(struct FunctionValues *, struct FunctionValues *, struct std::_Wrap_alloc<class std::allocator<struct FunctionValues>> &, struct std::_Nonscalar_ptr_iterator_tag)
.text$mn:00002708                 public ??$_Destroy_range@U?$_Wrap_alloc@V?$allocator@UFunctionValues@@@std@@@std@@@std@@YAXPAUFunctionValues@@0AAU?$_Wrap_alloc@V?$allocator@UFunctionValues@@@std@@@0@U_Nonscalar_ptr_iterator_tag@0@@Z
.text$mn:00002708 ??$_Destroy_range@U?$_Wrap_alloc@V?$allocator@UFunctionValues@@@std@@@std@@@std@@YAXPAUFunctionValues@@0AAU?$_Wrap_alloc@V?$allocator@UFunctionValues@@@std@@@0@U_Nonscalar_ptr_iterator_tag@0@@Z proc near
.text$mn:00002708                                         ; CODE XREF: std::_Destroy_range<std::_Wrap_alloc<std::allocator<FunctionValues>>>(FunctionValues *,FunctionValues *,std::_Wrap_alloc<std::allocator<FunctionValues>> &)+28p
.text$mn:00002708
.text$mn:00002708 arg_0           = dword ptr  8
.text$mn:00002708 arg_4           = dword ptr  0Ch
.text$mn:00002708 arg_8           = dword ptr  10h
.text$mn:00002708
.text$mn:00002708                 push    ebp
.text$mn:00002709                 mov     ebp, esp
.text$mn:0000270B                 jmp     short loc_2716
.text$mn:0000270D ; ---------------------------------------------------------------------------
.text$mn:0000270D
.text$mn:0000270D loc_270D:                               ; CODE XREF: std::_Destroy_range<std::_Wrap_alloc<std::allocator<FunctionValues>>>(FunctionValues *,FunctionValues *,std::_Wrap_alloc<std::allocator<FunctionValues>> &,std::_Nonscalar_ptr_iterator_tag)+22j
.text$mn:0000270D                 mov     eax, [ebp+arg_0]
.text$mn:00002710                 add     eax, 10h
.text$mn:00002713                 mov     [ebp+arg_0], eax
.text$mn:00002716
.text$mn:00002716 loc_2716:                               ; CODE XREF: std::_Destroy_range<std::_Wrap_alloc<std::allocator<FunctionValues>>>(FunctionValues *,FunctionValues *,std::_Wrap_alloc<std::allocator<FunctionValues>> &,std::_Nonscalar_ptr_iterator_tag)+3j
.text$mn:00002716                 mov     ecx, [ebp+arg_0]
.text$mn:00002719                 cmp     ecx, [ebp+arg_4]
.text$mn:0000271C                 jz      short loc_272C
.text$mn:0000271E                 mov     edx, [ebp+arg_0]
.text$mn:00002721                 push    edx
.text$mn:00002722                 mov     ecx, [ebp+arg_8]
.text$mn:00002725                 call    ??$destroy@UFunctionValues@@@?$_Wrap_alloc@V?$allocator@UFunctionValues@@@std@@@std@@QAEXPAUFunctionValues@@@Z ; std::_Wrap_alloc<std::allocator<FunctionValues>>::destroy<FunctionValues>(FunctionValues *)
.text$mn:0000272A                 jmp     short loc_270D
.text$mn:0000272C ; ---------------------------------------------------------------------------
.text$mn:0000272C
.text$mn:0000272C loc_272C:                               ; CODE XREF: std::_Destroy_range<std::_Wrap_alloc<std::allocator<FunctionValues>>>(FunctionValues *,FunctionValues *,std::_Wrap_alloc<std::allocator<FunctionValues>> &,std::_Nonscalar_ptr_iterator_tag)+14j
.text$mn:0000272C                 pop     ebp
.text$mn:0000272D                 retn
.text$mn:0000272D ??$_Destroy_range@U?$_Wrap_alloc@V?$allocator@UFunctionValues@@@std@@@std@@@std@@YAXPAUFunctionValues@@0AAU?$_Wrap_alloc@V?$allocator@UFunctionValues@@@std@@@0@U_Nonscalar_ptr_iterator_tag@0@@Z endp
.text$mn:0000272D
.text$mn:0000272D ; ---------------------------------------------------------------------------
.text$mn:0000272E                 align 10h
.text$mn:0000272E _text$mn        ends
.text$mn:0000272E
.text$mn:00002730 ; ===========================================================================
.text$mn:00002730
.text$mn:00002730 ; Segment type: Pure code
.text$mn:00002730 ; Segment permissions: Read/Execute
.text$mn:00002730 _text$mn        segment para public 'CODE' use32
.text$mn:00002730                 assume cs:_text$mn
.text$mn:00002730                 ;org 2730h
.text$mn:00002730 ; COMDAT (pick any)
.text$mn:00002730                 assume es:nothing, ss:nothing, ds:_data, fs:nothing, gs:nothing
.text$mn:00002730
.text$mn:00002730 ; =============== S U B R O U T I N E =======================================
.text$mn:00002730
.text$mn:00002730 ; Attributes: bp-based frame
.text$mn:00002730
.text$mn:00002730 ; void __cdecl std::_Destroy_range<struct std::_Wrap_alloc<class std::allocator<struct Token>>>(struct Token *, struct Token *, struct std::_Wrap_alloc<class std::allocator<struct Token>> &)
.text$mn:00002730                 public ??$_Destroy_range@U?$_Wrap_alloc@V?$allocator@UToken@@@std@@@std@@@std@@YAXPAUToken@@0AAU?$_Wrap_alloc@V?$allocator@UToken@@@std@@@0@@Z
.text$mn:00002730 ??$_Destroy_range@U?$_Wrap_alloc@V?$allocator@UToken@@@std@@@std@@@std@@YAXPAUToken@@0AAU?$_Wrap_alloc@V?$allocator@UToken@@@std@@@0@@Z proc near
.text$mn:00002730                                         ; CODE XREF: std::vector<Token,std::allocator<Token>>::_Destroy(Token *,Token *)+21p
.text$mn:00002730
.text$mn:00002730 var_1           = byte ptr -1
.text$mn:00002730 arg_0           = dword ptr  8
.text$mn:00002730 arg_4           = dword ptr  0Ch
.text$mn:00002730 arg_8           = dword ptr  10h
.text$mn:00002730
.text$mn:00002730                 push    ebp
.text$mn:00002731                 mov     ebp, esp
.text$mn:00002733                 push    ecx
.text$mn:00002734                 mov     eax, [ebp+arg_4]
.text$mn:00002737                 push    eax
.text$mn:00002738                 mov     ecx, [ebp+arg_0]
.text$mn:0000273B                 push    ecx
.text$mn:0000273C                 call    ??$_Ptr_cat@UToken@@U1@@std@@YA?AU_Nonscalar_ptr_iterator_tag@0@PAUToken@@0@Z ; std::_Ptr_cat<Token,Token>(Token *,Token *)
.text$mn:00002741                 add     esp, 8
.text$mn:00002744                 mov     [ebp+var_1], al
.text$mn:00002747                 movzx   edx, [ebp+var_1]
.text$mn:0000274B                 push    edx
.text$mn:0000274C                 mov     eax, [ebp+arg_8]
.text$mn:0000274F                 push    eax
.text$mn:00002750                 mov     ecx, [ebp+arg_4]
.text$mn:00002753                 push    ecx
.text$mn:00002754                 mov     edx, [ebp+arg_0]
.text$mn:00002757                 push    edx
.text$mn:00002758                 call    ??$_Destroy_range@U?$_Wrap_alloc@V?$allocator@UToken@@@std@@@std@@@std@@YAXPAUToken@@0AAU?$_Wrap_alloc@V?$allocator@UToken@@@std@@@0@U_Nonscalar_ptr_iterator_tag@0@@Z ; std::_Destroy_range<std::_Wrap_alloc<std::allocator<Token>>>(Token *,Token *,std::_Wrap_alloc<std::allocator<Token>> &,std::_Nonscalar_ptr_iterator_tag)
.text$mn:0000275D                 add     esp, 10h
.text$mn:00002760                 mov     esp, ebp
.text$mn:00002762                 pop     ebp
.text$mn:00002763                 retn
.text$mn:00002763 ??$_Destroy_range@U?$_Wrap_alloc@V?$allocator@UToken@@@std@@@std@@@std@@YAXPAUToken@@0AAU?$_Wrap_alloc@V?$allocator@UToken@@@std@@@0@@Z endp
.text$mn:00002763
.text$mn:00002763 _text$mn        ends
.text$mn:00002763
.text$mn:00002764 ; ===========================================================================
.text$mn:00002764
.text$mn:00002764 ; Segment type: Pure code
.text$mn:00002764 ; Segment permissions: Read/Execute
.text$mn:00002764 _text$mn        segment para public 'CODE' use32
.text$mn:00002764                 assume cs:_text$mn
.text$mn:00002764                 ;org 2764h
.text$mn:00002764 ; COMDAT (pick any)
.text$mn:00002764                 assume es:nothing, ss:nothing, ds:_data, fs:nothing, gs:nothing
.text$mn:00002764
.text$mn:00002764 ; =============== S U B R O U T I N E =======================================
.text$mn:00002764
.text$mn:00002764 ; Attributes: bp-based frame
.text$mn:00002764
.text$mn:00002764 ; void __cdecl std::_Destroy_range<struct std::_Wrap_alloc<class std::allocator<struct Token>>>(struct Token *, struct Token *, struct std::_Wrap_alloc<class std::allocator<struct Token>> &, struct std::_Nonscalar_ptr_iterator_tag)
.text$mn:00002764                 public ??$_Destroy_range@U?$_Wrap_alloc@V?$allocator@UToken@@@std@@@std@@@std@@YAXPAUToken@@0AAU?$_Wrap_alloc@V?$allocator@UToken@@@std@@@0@U_Nonscalar_ptr_iterator_tag@0@@Z
.text$mn:00002764 ??$_Destroy_range@U?$_Wrap_alloc@V?$allocator@UToken@@@std@@@std@@@std@@YAXPAUToken@@0AAU?$_Wrap_alloc@V?$allocator@UToken@@@std@@@0@U_Nonscalar_ptr_iterator_tag@0@@Z proc near
.text$mn:00002764                                         ; CODE XREF: std::_Destroy_range<std::_Wrap_alloc<std::allocator<Token>>>(Token *,Token *,std::_Wrap_alloc<std::allocator<Token>> &)+28p
.text$mn:00002764
.text$mn:00002764 arg_0           = dword ptr  8
.text$mn:00002764 arg_4           = dword ptr  0Ch
.text$mn:00002764 arg_8           = dword ptr  10h
.text$mn:00002764
.text$mn:00002764                 push    ebp
.text$mn:00002765                 mov     ebp, esp
.text$mn:00002767                 jmp     short loc_2772
.text$mn:00002769 ; ---------------------------------------------------------------------------
.text$mn:00002769
.text$mn:00002769 loc_2769:                               ; CODE XREF: std::_Destroy_range<std::_Wrap_alloc<std::allocator<Token>>>(Token *,Token *,std::_Wrap_alloc<std::allocator<Token>> &,std::_Nonscalar_ptr_iterator_tag)+22j
.text$mn:00002769                 mov     eax, [ebp+arg_0]
.text$mn:0000276C                 add     eax, 0Ch
.text$mn:0000276F                 mov     [ebp+arg_0], eax
.text$mn:00002772
.text$mn:00002772 loc_2772:                               ; CODE XREF: std::_Destroy_range<std::_Wrap_alloc<std::allocator<Token>>>(Token *,Token *,std::_Wrap_alloc<std::allocator<Token>> &,std::_Nonscalar_ptr_iterator_tag)+3j
.text$mn:00002772                 mov     ecx, [ebp+arg_0]
.text$mn:00002775                 cmp     ecx, [ebp+arg_4]
.text$mn:00002778                 jz      short loc_2788
.text$mn:0000277A                 mov     edx, [ebp+arg_0]
.text$mn:0000277D                 push    edx
.text$mn:0000277E                 mov     ecx, [ebp+arg_8]
.text$mn:00002781                 call    ??$destroy@UToken@@@?$_Wrap_alloc@V?$allocator@UToken@@@std@@@std@@QAEXPAUToken@@@Z ; std::_Wrap_alloc<std::allocator<Token>>::destroy<Token>(Token *)
.text$mn:00002786                 jmp     short loc_2769
.text$mn:00002788 ; ---------------------------------------------------------------------------
.text$mn:00002788
.text$mn:00002788 loc_2788:                               ; CODE XREF: std::_Destroy_range<std::_Wrap_alloc<std::allocator<Token>>>(Token *,Token *,std::_Wrap_alloc<std::allocator<Token>> &,std::_Nonscalar_ptr_iterator_tag)+14j
.text$mn:00002788                 pop     ebp
.text$mn:00002789                 retn
.text$mn:00002789 ??$_Destroy_range@U?$_Wrap_alloc@V?$allocator@UToken@@@std@@@std@@@std@@YAXPAUToken@@0AAU?$_Wrap_alloc@V?$allocator@UToken@@@std@@@0@U_Nonscalar_ptr_iterator_tag@0@@Z endp
.text$mn:00002789
.text$mn:00002789 ; ---------------------------------------------------------------------------
.text$mn:0000278A                 align 4
.text$mn:0000278A _text$mn        ends
.text$mn:0000278A
.text$mn:0000278C ; ===========================================================================
.text$mn:0000278C
.text$mn:0000278C ; Segment type: Pure code
.text$mn:0000278C ; Segment permissions: Read/Execute
.text$mn:0000278C _text$mn        segment para public 'CODE' use32
.text$mn:0000278C                 assume cs:_text$mn
.text$mn:0000278C                 ;org 278Ch
.text$mn:0000278C ; COMDAT (pick any)
.text$mn:0000278C                 assume es:nothing, ss:nothing, ds:_data, fs:nothing, gs:nothing
.text$mn:0000278C
.text$mn:0000278C ; =============== S U B R O U T I N E =======================================
.text$mn:0000278C
.text$mn:0000278C ; Attributes: bp-based frame
.text$mn:0000278C
.text$mn:0000278C ; void __cdecl std::_Destroy_range<struct std::_Wrap_alloc<class std::allocator<class std::vector<wchar_t const *, class std::allocator<wchar_t const *>>>>>(class std::vector<wchar_t const *, class std::allocator<wchar_t const *>> *, class std::vector<wchar_t const *, class std::allocator<wchar_t const *>> *, struct std::_Wrap_alloc<class std::allocator<class std::vector<wchar_t const *, class std::allocator<wchar_t const *>>>> &)
.text$mn:0000278C                 public ??$_Destroy_range@U?$_Wrap_alloc@V?$allocator@V?$vector@PB_WV?$allocator@PB_W@std@@@std@@@std@@@std@@@std@@YAXPAV?$vector@PB_WV?$allocator@PB_W@std@@@0@0AAU?$_Wrap_alloc@V?$allocator@V?$vector@PB_WV?$allocator@PB_W@std@@@std@@@std@@@0@@Z
.text$mn:0000278C ??$_Destroy_range@U?$_Wrap_alloc@V?$allocator@V?$vector@PB_WV?$allocator@PB_W@std@@@std@@@std@@@std@@@std@@YAXPAV?$vector@PB_WV?$allocator@PB_W@std@@@0@0AAU?$_Wrap_alloc@V?$allocator@V?$vector@PB_WV?$allocator@PB_W@std@@@std@@@std@@@0@@Z proc near
.text$mn:0000278C                                         ; CODE XREF: std::vector<std::vector<wchar_t const *,std::allocator<wchar_t const *>>,std::allocator<std::vector<wchar_t const *,std::allocator<wchar_t const *>>>>::_Destroy(std::vector<wchar_t const *,std::allocator<wchar_t const *>> *,std::vector<wchar_t const *,std::allocator<wchar_t const *>> *)+21p
.text$mn:0000278C
.text$mn:0000278C var_1           = byte ptr -1
.text$mn:0000278C arg_0           = dword ptr  8
.text$mn:0000278C arg_4           = dword ptr  0Ch
.text$mn:0000278C arg_8           = dword ptr  10h
.text$mn:0000278C
.text$mn:0000278C                 push    ebp
.text$mn:0000278D                 mov     ebp, esp
.text$mn:0000278F                 push    ecx
.text$mn:00002790                 mov     eax, [ebp+arg_4]
.text$mn:00002793                 push    eax
.text$mn:00002794                 mov     ecx, [ebp+arg_0]
.text$mn:00002797                 push    ecx
.text$mn:00002798                 call    ??$_Ptr_cat@V?$vector@PB_WV?$allocator@PB_W@std@@@std@@V12@@std@@YA?AU_Nonscalar_ptr_iterator_tag@0@PAV?$vector@PB_WV?$allocator@PB_W@std@@@0@0@Z ; std::_Ptr_cat<std::vector<wchar_t const *,std::allocator<wchar_t const *>>,std::vector<wchar_t const *,std::allocator<wchar_t const *>>>(std::vector<wchar_t const *,std::allocator<wchar_t const *>> *,std::vector<wchar_t const *,std::allocator<wchar_t const *>> *)
.text$mn:0000279D                 add     esp, 8
.text$mn:000027A0                 mov     [ebp+var_1], al
.text$mn:000027A3                 movzx   edx, [ebp+var_1]
.text$mn:000027A7                 push    edx
.text$mn:000027A8                 mov     eax, [ebp+arg_8]
.text$mn:000027AB                 push    eax
.text$mn:000027AC                 mov     ecx, [ebp+arg_4]
.text$mn:000027AF                 push    ecx
.text$mn:000027B0                 mov     edx, [ebp+arg_0]
.text$mn:000027B3                 push    edx
.text$mn:000027B4                 call    ??$_Destroy_range@U?$_Wrap_alloc@V?$allocator@V?$vector@PB_WV?$allocator@PB_W@std@@@std@@@std@@@std@@@std@@YAXPAV?$vector@PB_WV?$allocator@PB_W@std@@@0@0AAU?$_Wrap_alloc@V?$allocator@V?$vector@PB_WV?$allocator@PB_W@std@@@std@@@std@@@0@U_Nonscalar_ptr_iterator_tag@0@@Z ; std::_Destroy_range<std::_Wrap_alloc<std::allocator<std::vector<wchar_t const *,std::allocator<wchar_t const *>>>>>(std::vector<wchar_t const *,std::allocator<wchar_t const *>> *,std::vector<wchar_t const *,std::allocator<wchar_t const *>> *,std::_Wrap_alloc<std::allocator<std::vector<wchar_t const *,std::allocator<wchar_t const *>>>> &,std::_Nonscalar_ptr_iterator_tag)
.text$mn:000027B9                 add     esp, 10h
.text$mn:000027BC                 mov     esp, ebp
.text$mn:000027BE                 pop     ebp
.text$mn:000027BF                 retn
.text$mn:000027BF ??$_Destroy_range@U?$_Wrap_alloc@V?$allocator@V?$vector@PB_WV?$allocator@PB_W@std@@@std@@@std@@@std@@@std@@YAXPAV?$vector@PB_WV?$allocator@PB_W@std@@@0@0AAU?$_Wrap_alloc@V?$allocator@V?$vector@PB_WV?$allocator@PB_W@std@@@std@@@std@@@0@@Z endp
.text$mn:000027BF
.text$mn:000027BF _text$mn        ends
.text$mn:000027BF
.text$mn:000027C0 ; ===========================================================================
.text$mn:000027C0
.text$mn:000027C0 ; Segment type: Pure code
.text$mn:000027C0 ; Segment permissions: Read/Execute
.text$mn:000027C0 _text$mn        segment para public 'CODE' use32
.text$mn:000027C0                 assume cs:_text$mn
.text$mn:000027C0                 ;org 27C0h
.text$mn:000027C0 ; COMDAT (pick any)
.text$mn:000027C0                 assume es:nothing, ss:nothing, ds:_data, fs:nothing, gs:nothing
.text$mn:000027C0
.text$mn:000027C0 ; =============== S U B R O U T I N E =======================================
.text$mn:000027C0
.text$mn:000027C0 ; Attributes: bp-based frame
.text$mn:000027C0
.text$mn:000027C0 ; void __cdecl std::_Destroy_range<struct std::_Wrap_alloc<class std::allocator<class std::vector<wchar_t const *, class std::allocator<wchar_t const *>>>>>(class std::vector<wchar_t const *, class std::allocator<wchar_t const *>> *, class std::vector<wchar_t const *, class std::allocator<wchar_t const *>> *, struct std::_Wrap_alloc<class std::allocator<class std::vector<wchar_t const *, class std::allocator<wchar_t const *>>>> &, struct std::_Nonscalar_ptr_iterator_tag)
.text$mn:000027C0                 public ??$_Destroy_range@U?$_Wrap_alloc@V?$allocator@V?$vector@PB_WV?$allocator@PB_W@std@@@std@@@std@@@std@@@std@@YAXPAV?$vector@PB_WV?$allocator@PB_W@std@@@0@0AAU?$_Wrap_alloc@V?$allocator@V?$vector@PB_WV?$allocator@PB_W@std@@@std@@@std@@@0@U_Nonscalar_ptr_iterator_tag@0@@Z
.text$mn:000027C0 ??$_Destroy_range@U?$_Wrap_alloc@V?$allocator@V?$vector@PB_WV?$allocator@PB_W@std@@@std@@@std@@@std@@@std@@YAXPAV?$vector@PB_WV?$allocator@PB_W@std@@@0@0AAU?$_Wrap_alloc@V?$allocator@V?$vector@PB_WV?$allocator@PB_W@std@@@std@@@std@@@0@U_Nonscalar_ptr_iterator_tag@0@@Z proc near
.text$mn:000027C0                                         ; CODE XREF: std::_Destroy_range<std::_Wrap_alloc<std::allocator<std::vector<wchar_t const *,std::allocator<wchar_t const *>>>>>(std::vector<wchar_t const *,std::allocator<wchar_t const *>> *,std::vector<wchar_t const *,std::allocator<wchar_t const *>> *,std::_Wrap_alloc<std::allocator<std::vector<wchar_t const *,std::allocator<wchar_t const *>>>> &)+28p
.text$mn:000027C0
.text$mn:000027C0 arg_0           = dword ptr  8
.text$mn:000027C0 arg_4           = dword ptr  0Ch
.text$mn:000027C0 arg_8           = dword ptr  10h
.text$mn:000027C0
.text$mn:000027C0                 push    ebp
.text$mn:000027C1                 mov     ebp, esp
.text$mn:000027C3                 jmp     short loc_27CE
.text$mn:000027C5 ; ---------------------------------------------------------------------------
.text$mn:000027C5
.text$mn:000027C5 loc_27C5:                               ; CODE XREF: std::_Destroy_range<std::_Wrap_alloc<std::allocator<std::vector<wchar_t const *,std::allocator<wchar_t const *>>>>>(std::vector<wchar_t const *,std::allocator<wchar_t const *>> *,std::vector<wchar_t const *,std::allocator<wchar_t const *>> *,std::_Wrap_alloc<std::allocator<std::vector<wchar_t const *,std::allocator<wchar_t const *>>>> &,std::_Nonscalar_ptr_iterator_tag)+22j
.text$mn:000027C5                 mov     eax, [ebp+arg_0]
.text$mn:000027C8                 add     eax, 10h
.text$mn:000027CB                 mov     [ebp+arg_0], eax
.text$mn:000027CE
.text$mn:000027CE loc_27CE:                               ; CODE XREF: std::_Destroy_range<std::_Wrap_alloc<std::allocator<std::vector<wchar_t const *,std::allocator<wchar_t const *>>>>>(std::vector<wchar_t const *,std::allocator<wchar_t const *>> *,std::vector<wchar_t const *,std::allocator<wchar_t const *>> *,std::_Wrap_alloc<std::allocator<std::vector<wchar_t const *,std::allocator<wchar_t const *>>>> &,std::_Nonscalar_ptr_iterator_tag)+3j
.text$mn:000027CE                 mov     ecx, [ebp+arg_0]
.text$mn:000027D1                 cmp     ecx, [ebp+arg_4]
.text$mn:000027D4                 jz      short loc_27E4
.text$mn:000027D6                 mov     edx, [ebp+arg_0]
.text$mn:000027D9                 push    edx
.text$mn:000027DA                 mov     ecx, [ebp+arg_8]
.text$mn:000027DD                 call    ??$destroy@V?$vector@PB_WV?$allocator@PB_W@std@@@std@@@?$_Wrap_alloc@V?$allocator@V?$vector@PB_WV?$allocator@PB_W@std@@@std@@@std@@@std@@QAEXPAV?$vector@PB_WV?$allocator@PB_W@std@@@1@@Z ; std::_Wrap_alloc<std::allocator<std::vector<wchar_t const *,std::allocator<wchar_t const *>>>>::destroy<std::vector<wchar_t const *,std::allocator<wchar_t const *>>>(std::vector<wchar_t const *,std::allocator<wchar_t const *>> *)
.text$mn:000027E2                 jmp     short loc_27C5
.text$mn:000027E4 ; ---------------------------------------------------------------------------
.text$mn:000027E4
.text$mn:000027E4 loc_27E4:                               ; CODE XREF: std::_Destroy_range<std::_Wrap_alloc<std::allocator<std::vector<wchar_t const *,std::allocator<wchar_t const *>>>>>(std::vector<wchar_t const *,std::allocator<wchar_t const *>> *,std::vector<wchar_t const *,std::allocator<wchar_t const *>> *,std::_Wrap_alloc<std::allocator<std::vector<wchar_t const *,std::allocator<wchar_t const *>>>> &,std::_Nonscalar_ptr_iterator_tag)+14j
.text$mn:000027E4                 pop     ebp
.text$mn:000027E5                 retn
.text$mn:000027E5 ??$_Destroy_range@U?$_Wrap_alloc@V?$allocator@V?$vector@PB_WV?$allocator@PB_W@std@@@std@@@std@@@std@@@std@@YAXPAV?$vector@PB_WV?$allocator@PB_W@std@@@0@0AAU?$_Wrap_alloc@V?$allocator@V?$vector@PB_WV?$allocator@PB_W@std@@@std@@@std@@@0@U_Nonscalar_ptr_iterator_tag@0@@Z endp
.text$mn:000027E5
.text$mn:000027E5 ; ---------------------------------------------------------------------------
.text$mn:000027E6                 align 4
.text$mn:000027E6 _text$mn        ends
.text$mn:000027E6
.text$mn:000027E8 ; ===========================================================================
.text$mn:000027E8
.text$mn:000027E8 ; Segment type: Pure code
.text$mn:000027E8 ; Segment permissions: Read/Execute
.text$mn:000027E8 _text$mn        segment para public 'CODE' use32
.text$mn:000027E8                 assume cs:_text$mn
.text$mn:000027E8                 ;org 27E8h
.text$mn:000027E8 ; COMDAT (pick any)
.text$mn:000027E8                 assume es:nothing, ss:nothing, ds:_data, fs:nothing, gs:nothing
.text$mn:000027E8
.text$mn:000027E8 ; =============== S U B R O U T I N E =======================================
.text$mn:000027E8
.text$mn:000027E8 ; Attributes: bp-based frame
.text$mn:000027E8
.text$mn:000027E8 ; struct std::random_access_iterator_tag __cdecl std::_Iter_cat<wchar_t const * *>(wchar_t const * * const &)
.text$mn:000027E8                 public ??$_Iter_cat@PAPB_W@std@@YA?AUrandom_access_iterator_tag@0@ABQAPB_W@Z
.text$mn:000027E8 ??$_Iter_cat@PAPB_W@std@@YA?AUrandom_access_iterator_tag@0@ABQAPB_W@Z proc near
.text$mn:000027E8                                         ; CODE XREF: std::_Debug_range<wchar_t const * *>(wchar_t const * *,wchar_t const * *,wchar_t const *,uint)+Cp
.text$mn:000027E8
.text$mn:000027E8 var_1           = byte ptr -1
.text$mn:000027E8 arg_0           = dword ptr  8
.text$mn:000027E8
.text$mn:000027E8                 push    ebp
.text$mn:000027E9                 mov     ebp, esp
.text$mn:000027EB                 push    ecx
.text$mn:000027EC                 mov     eax, [ebp+arg_0]
.text$mn:000027EF                 mov     cl, [ebp+var_1]
.text$mn:000027F2                 mov     [eax], cl
.text$mn:000027F4                 mov     eax, [ebp+arg_0]
.text$mn:000027F7                 mov     esp, ebp
.text$mn:000027F9                 pop     ebp
.text$mn:000027FA                 retn
.text$mn:000027FA ??$_Iter_cat@PAPB_W@std@@YA?AUrandom_access_iterator_tag@0@ABQAPB_W@Z endp
.text$mn:000027FA
.text$mn:000027FA ; ---------------------------------------------------------------------------
.text$mn:000027FB                 align 4
.text$mn:000027FB _text$mn        ends
.text$mn:000027FB
.text$mn:000027FC ; ===========================================================================
.text$mn:000027FC
.text$mn:000027FC ; Segment type: Pure code
.text$mn:000027FC ; Segment permissions: Read/Execute
.text$mn:000027FC _text$mn        segment para public 'CODE' use32
.text$mn:000027FC                 assume cs:_text$mn
.text$mn:000027FC                 ;org 27FCh
.text$mn:000027FC ; COMDAT (pick any)
.text$mn:000027FC                 assume es:nothing, ss:nothing, ds:_data, fs:nothing, gs:nothing
.text$mn:000027FC
.text$mn:000027FC ; =============== S U B R O U T I N E =======================================
.text$mn:000027FC
.text$mn:000027FC ; Attributes: bp-based frame
.text$mn:000027FC
.text$mn:000027FC ; struct std::random_access_iterator_tag __cdecl std::_Iter_cat<struct FunctionValues *>(struct FunctionValues * const &)
.text$mn:000027FC                 public ??$_Iter_cat@PAUFunctionValues@@@std@@YA?AUrandom_access_iterator_tag@0@ABQAUFunctionValues@@@Z
.text$mn:000027FC ??$_Iter_cat@PAUFunctionValues@@@std@@YA?AUrandom_access_iterator_tag@0@ABQAUFunctionValues@@@Z proc near
.text$mn:000027FC                                         ; CODE XREF: std::_Debug_range<FunctionValues *>(FunctionValues *,FunctionValues *,wchar_t const *,uint)+Cp
.text$mn:000027FC
.text$mn:000027FC var_1           = byte ptr -1
.text$mn:000027FC arg_0           = dword ptr  8
.text$mn:000027FC
.text$mn:000027FC                 push    ebp
.text$mn:000027FD                 mov     ebp, esp
.text$mn:000027FF                 push    ecx
.text$mn:00002800                 mov     eax, [ebp+arg_0]
.text$mn:00002803                 mov     cl, [ebp+var_1]
.text$mn:00002806                 mov     [eax], cl
.text$mn:00002808                 mov     eax, [ebp+arg_0]
.text$mn:0000280B                 mov     esp, ebp
.text$mn:0000280D                 pop     ebp
.text$mn:0000280E                 retn
.text$mn:0000280E ??$_Iter_cat@PAUFunctionValues@@@std@@YA?AUrandom_access_iterator_tag@0@ABQAUFunctionValues@@@Z endp
.text$mn:0000280E
.text$mn:0000280E ; ---------------------------------------------------------------------------
.text$mn:0000280F                 align 10h
.text$mn:0000280F _text$mn        ends
.text$mn:0000280F
.text$mn:00002810 ; ===========================================================================
.text$mn:00002810
.text$mn:00002810 ; Segment type: Pure code
.text$mn:00002810 ; Segment permissions: Read/Execute
.text$mn:00002810 _text$mn        segment para public 'CODE' use32
.text$mn:00002810                 assume cs:_text$mn
.text$mn:00002810                 ;org 2810h
.text$mn:00002810 ; COMDAT (pick any)
.text$mn:00002810                 assume es:nothing, ss:nothing, ds:_data, fs:nothing, gs:nothing
.text$mn:00002810
.text$mn:00002810 ; =============== S U B R O U T I N E =======================================
.text$mn:00002810
.text$mn:00002810 ; Attributes: bp-based frame
.text$mn:00002810
.text$mn:00002810 ; struct std::random_access_iterator_tag __cdecl std::_Iter_cat<struct Token *>(struct Token * const &)
.text$mn:00002810                 public ??$_Iter_cat@PAUToken@@@std@@YA?AUrandom_access_iterator_tag@0@ABQAUToken@@@Z
.text$mn:00002810 ??$_Iter_cat@PAUToken@@@std@@YA?AUrandom_access_iterator_tag@0@ABQAUToken@@@Z proc near
.text$mn:00002810                                         ; CODE XREF: std::_Debug_range<Token *>(Token *,Token *,wchar_t const *,uint)+Cp
.text$mn:00002810
.text$mn:00002810 var_1           = byte ptr -1
.text$mn:00002810 arg_0           = dword ptr  8
.text$mn:00002810
.text$mn:00002810                 push    ebp
.text$mn:00002811                 mov     ebp, esp
.text$mn:00002813                 push    ecx
.text$mn:00002814                 mov     eax, [ebp+arg_0]
.text$mn:00002817                 mov     cl, [ebp+var_1]
.text$mn:0000281A                 mov     [eax], cl
.text$mn:0000281C                 mov     eax, [ebp+arg_0]
.text$mn:0000281F                 mov     esp, ebp
.text$mn:00002821                 pop     ebp
.text$mn:00002822                 retn
.text$mn:00002822 ??$_Iter_cat@PAUToken@@@std@@YA?AUrandom_access_iterator_tag@0@ABQAUToken@@@Z endp
.text$mn:00002822
.text$mn:00002822 ; ---------------------------------------------------------------------------
.text$mn:00002823                 align 4
.text$mn:00002823 _text$mn        ends
.text$mn:00002823
.text$mn:00002824 ; ===========================================================================
.text$mn:00002824
.text$mn:00002824 ; Segment type: Pure code
.text$mn:00002824 ; Segment permissions: Read/Execute
.text$mn:00002824 _text$mn        segment para public 'CODE' use32
.text$mn:00002824                 assume cs:_text$mn
.text$mn:00002824                 ;org 2824h
.text$mn:00002824 ; COMDAT (pick any)
.text$mn:00002824                 assume es:nothing, ss:nothing, ds:_data, fs:nothing, gs:nothing
.text$mn:00002824
.text$mn:00002824 ; =============== S U B R O U T I N E =======================================
.text$mn:00002824
.text$mn:00002824 ; Attributes: bp-based frame
.text$mn:00002824
.text$mn:00002824 ; struct std::random_access_iterator_tag __cdecl std::_Iter_cat<class std::vector<wchar_t const *, class std::allocator<wchar_t const *>> *>(class std::vector<wchar_t const *, class std::allocator<wchar_t const *>> * const &)
.text$mn:00002824                 public ??$_Iter_cat@PAV?$vector@PB_WV?$allocator@PB_W@std@@@std@@@std@@YA?AUrandom_access_iterator_tag@0@ABQAV?$vector@PB_WV?$allocator@PB_W@std@@@0@@Z
.text$mn:00002824 ??$_Iter_cat@PAV?$vector@PB_WV?$allocator@PB_W@std@@@std@@@std@@YA?AUrandom_access_iterator_tag@0@ABQAV?$vector@PB_WV?$allocator@PB_W@std@@@0@@Z proc near
.text$mn:00002824                                         ; CODE XREF: std::_Debug_range<std::vector<wchar_t const *,std::allocator<wchar_t const *>> *>(std::vector<wchar_t const *,std::allocator<wchar_t const *>> *,std::vector<wchar_t const *,std::allocator<wchar_t const *>> *,wchar_t const *,uint)+Cp
.text$mn:00002824
.text$mn:00002824 var_1           = byte ptr -1
.text$mn:00002824 arg_0           = dword ptr  8
.text$mn:00002824
.text$mn:00002824                 push    ebp
.text$mn:00002825                 mov     ebp, esp
.text$mn:00002827                 push    ecx
.text$mn:00002828                 mov     eax, [ebp+arg_0]
.text$mn:0000282B                 mov     cl, [ebp+var_1]
.text$mn:0000282E                 mov     [eax], cl
.text$mn:00002830                 mov     eax, [ebp+arg_0]
.text$mn:00002833                 mov     esp, ebp
.text$mn:00002835                 pop     ebp
.text$mn:00002836                 retn
.text$mn:00002836 ??$_Iter_cat@PAV?$vector@PB_WV?$allocator@PB_W@std@@@std@@@std@@YA?AUrandom_access_iterator_tag@0@ABQAV?$vector@PB_WV?$allocator@PB_W@std@@@0@@Z endp
.text$mn:00002836
.text$mn:00002836 ; ---------------------------------------------------------------------------
.text$mn:00002837                 align 4
.text$mn:00002837 _text$mn        ends
.text$mn:00002837
.text$mn:00002838 ; ===========================================================================
.text$mn:00002838
.text$mn:00002838 ; Segment type: Pure code
.text$mn:00002838 ; Segment permissions: Read/Execute
.text$mn:00002838 _text$mn        segment para public 'CODE' use32
.text$mn:00002838                 assume cs:_text$mn
.text$mn:00002838                 ;org 2838h
.text$mn:00002838 ; COMDAT (pick any)
.text$mn:00002838                 assume es:nothing, ss:nothing, ds:_data, fs:nothing, gs:nothing
.text$mn:00002838
.text$mn:00002838 ; =============== S U B R O U T I N E =======================================
.text$mn:00002838
.text$mn:00002838 ; Attributes: bp-based frame
.text$mn:00002838
.text$mn:00002838 ; struct std::random_access_iterator_tag __cdecl std::_Iter_cat<wchar_t const * const *>(wchar_t const * const * const &)
.text$mn:00002838                 public ??$_Iter_cat@PBQB_W@std@@YA?AUrandom_access_iterator_tag@0@ABQBQB_W@Z
.text$mn:00002838 ??$_Iter_cat@PBQB_W@std@@YA?AUrandom_access_iterator_tag@0@ABQBQB_W@Z proc near
.text$mn:00002838                                         ; CODE XREF: std::_Debug_range<wchar_t const * const *>(wchar_t const * const *,wchar_t const * const *,wchar_t const *,uint)+Cp
.text$mn:00002838
.text$mn:00002838 var_1           = byte ptr -1
.text$mn:00002838 arg_0           = dword ptr  8
.text$mn:00002838
.text$mn:00002838                 push    ebp
.text$mn:00002839                 mov     ebp, esp
.text$mn:0000283B                 push    ecx
.text$mn:0000283C                 mov     eax, [ebp+arg_0]
.text$mn:0000283F                 mov     cl, [ebp+var_1]
.text$mn:00002842                 mov     [eax], cl
.text$mn:00002844                 mov     eax, [ebp+arg_0]
.text$mn:00002847                 mov     esp, ebp
.text$mn:00002849                 pop     ebp
.text$mn:0000284A                 retn
.text$mn:0000284A ??$_Iter_cat@PBQB_W@std@@YA?AUrandom_access_iterator_tag@0@ABQBQB_W@Z endp
.text$mn:0000284A
.text$mn:0000284A ; ---------------------------------------------------------------------------
.text$mn:0000284B                 align 4
.text$mn:0000284B _text$mn        ends
.text$mn:0000284B
.text$mn:0000284C ; ===========================================================================
.text$mn:0000284C
.text$mn:0000284C ; Segment type: Pure code
.text$mn:0000284C ; Segment permissions: Read/Execute
.text$mn:0000284C _text$mn        segment para public 'CODE' use32
.text$mn:0000284C                 assume cs:_text$mn
.text$mn:0000284C                 ;org 284Ch
.text$mn:0000284C ; COMDAT (pick any)
.text$mn:0000284C                 assume es:nothing, ss:nothing, ds:_data, fs:nothing, gs:nothing
.text$mn:0000284C
.text$mn:0000284C ; =============== S U B R O U T I N E =======================================
.text$mn:0000284C
.text$mn:0000284C ; Attributes: bp-based frame
.text$mn:0000284C
.text$mn:0000284C ; struct std::_Scalar_ptr_iterator_tag __cdecl std::_Ptr_cat<wchar_t const *, wchar_t const *>(wchar_t const * *, wchar_t const * *)
.text$mn:0000284C                 public ??$_Ptr_cat@PB_WPB_W@std@@YA?AU_Scalar_ptr_iterator_tag@0@PAPB_W0@Z
.text$mn:0000284C ??$_Ptr_cat@PB_WPB_W@std@@YA?AU_Scalar_ptr_iterator_tag@0@PAPB_W0@Z proc near
.text$mn:0000284C                                         ; CODE XREF: std::_Destroy_range<std::_Wrap_alloc<std::allocator<wchar_t const *>>>(wchar_t const * *,wchar_t const * *,std::_Wrap_alloc<std::allocator<wchar_t const *>> &)+Cp
.text$mn:0000284C                                         ; std::_Uninit_move<wchar_t const * *,wchar_t const * *,std::_Wrap_alloc<std::allocator<wchar_t const *>>>(wchar_t const * *,wchar_t const * *,wchar_t const * *,std::_Wrap_alloc<std::allocator<wchar_t const *>> &)+Cp
.text$mn:0000284C
.text$mn:0000284C var_1           = byte ptr -1
.text$mn:0000284C
.text$mn:0000284C                 push    ebp
.text$mn:0000284D                 mov     ebp, esp
.text$mn:0000284F                 push    ecx
.text$mn:00002850                 mov     al, [ebp+var_1]
.text$mn:00002853                 mov     esp, ebp
.text$mn:00002855                 pop     ebp
.text$mn:00002856                 retn
.text$mn:00002856 ??$_Ptr_cat@PB_WPB_W@std@@YA?AU_Scalar_ptr_iterator_tag@0@PAPB_W0@Z endp
.text$mn:00002856
.text$mn:00002856 ; ---------------------------------------------------------------------------
.text$mn:00002857                 align 4
.text$mn:00002857 _text$mn        ends
.text$mn:00002857
.text$mn:00002858 ; ===========================================================================
.text$mn:00002858
.text$mn:00002858 ; Segment type: Pure code
.text$mn:00002858 ; Segment permissions: Read/Execute
.text$mn:00002858 _text$mn        segment para public 'CODE' use32
.text$mn:00002858                 assume cs:_text$mn
.text$mn:00002858                 ;org 2858h
.text$mn:00002858 ; COMDAT (pick any)
.text$mn:00002858                 assume es:nothing, ss:nothing, ds:_data, fs:nothing, gs:nothing
.text$mn:00002858
.text$mn:00002858 ; =============== S U B R O U T I N E =======================================
.text$mn:00002858
.text$mn:00002858 ; Attributes: bp-based frame
.text$mn:00002858
.text$mn:00002858 ; struct std::_Scalar_ptr_iterator_tag __cdecl std::_Ptr_cat<wchar_t const *, wchar_t const *>(wchar_t const * const *, wchar_t const * *)
.text$mn:00002858                 public ??$_Ptr_cat@PB_WPB_W@std@@YA?AU_Scalar_ptr_iterator_tag@0@PBQB_WPAPB_W@Z
.text$mn:00002858 ??$_Ptr_cat@PB_WPB_W@std@@YA?AU_Scalar_ptr_iterator_tag@0@PBQB_WPAPB_W@Z proc near
.text$mn:00002858                                         ; CODE XREF: std::_Uninit_copy<wchar_t const * const *,wchar_t const * *,std::_Wrap_alloc<std::allocator<wchar_t const *>>>(wchar_t const * const *,wchar_t const * const *,wchar_t const * *,std::_Wrap_alloc<std::allocator<wchar_t const *>> &)+Cp
.text$mn:00002858
.text$mn:00002858 var_1           = byte ptr -1
.text$mn:00002858
.text$mn:00002858                 push    ebp
.text$mn:00002859                 mov     ebp, esp
.text$mn:0000285B                 push    ecx
.text$mn:0000285C                 mov     al, [ebp+var_1]
.text$mn:0000285F                 mov     esp, ebp
.text$mn:00002861                 pop     ebp
.text$mn:00002862                 retn
.text$mn:00002862 ??$_Ptr_cat@PB_WPB_W@std@@YA?AU_Scalar_ptr_iterator_tag@0@PBQB_WPAPB_W@Z endp
.text$mn:00002862
.text$mn:00002862 ; ---------------------------------------------------------------------------
.text$mn:00002863                 align 4
.text$mn:00002863 _text$mn        ends
.text$mn:00002863
.text$mn:00002864 ; ===========================================================================
.text$mn:00002864
.text$mn:00002864 ; Segment type: Pure code
.text$mn:00002864 ; Segment permissions: Read/Execute
.text$mn:00002864 _text$mn        segment para public 'CODE' use32
.text$mn:00002864                 assume cs:_text$mn
.text$mn:00002864                 ;org 2864h
.text$mn:00002864 ; COMDAT (pick any)
.text$mn:00002864                 assume es:nothing, ss:nothing, ds:_data, fs:nothing, gs:nothing
.text$mn:00002864
.text$mn:00002864 ; =============== S U B R O U T I N E =======================================
.text$mn:00002864
.text$mn:00002864 ; Attributes: bp-based frame
.text$mn:00002864
.text$mn:00002864 ; struct std::_Nonscalar_ptr_iterator_tag __cdecl std::_Ptr_cat<struct FunctionValues, struct FunctionValues>(struct FunctionValues *, struct FunctionValues *)
.text$mn:00002864                 public ??$_Ptr_cat@UFunctionValues@@U1@@std@@YA?AU_Nonscalar_ptr_iterator_tag@0@PAUFunctionValues@@0@Z
.text$mn:00002864 ??$_Ptr_cat@UFunctionValues@@U1@@std@@YA?AU_Nonscalar_ptr_iterator_tag@0@PAUFunctionValues@@0@Z proc near
.text$mn:00002864                                         ; CODE XREF: std::_Destroy_range<std::_Wrap_alloc<std::allocator<FunctionValues>>>(FunctionValues *,FunctionValues *,std::_Wrap_alloc<std::allocator<FunctionValues>> &)+Cp
.text$mn:00002864                                         ; std::_Uninit_move<FunctionValues *,FunctionValues *,std::_Wrap_alloc<std::allocator<FunctionValues>>>(FunctionValues *,FunctionValues *,FunctionValues *,std::_Wrap_alloc<std::allocator<FunctionValues>> &)+Cp
.text$mn:00002864
.text$mn:00002864 var_1           = byte ptr -1
.text$mn:00002864
.text$mn:00002864                 push    ebp
.text$mn:00002865                 mov     ebp, esp
.text$mn:00002867                 push    ecx
.text$mn:00002868                 mov     al, [ebp+var_1]
.text$mn:0000286B                 mov     esp, ebp
.text$mn:0000286D                 pop     ebp
.text$mn:0000286E                 retn
.text$mn:0000286E ??$_Ptr_cat@UFunctionValues@@U1@@std@@YA?AU_Nonscalar_ptr_iterator_tag@0@PAUFunctionValues@@0@Z endp
.text$mn:0000286E
.text$mn:0000286E ; ---------------------------------------------------------------------------
.text$mn:0000286F                 align 10h
.text$mn:0000286F _text$mn        ends
.text$mn:0000286F
.text$mn:00002870 ; ===========================================================================
.text$mn:00002870
.text$mn:00002870 ; Segment type: Pure code
.text$mn:00002870 ; Segment permissions: Read/Execute
.text$mn:00002870 _text$mn        segment para public 'CODE' use32
.text$mn:00002870                 assume cs:_text$mn
.text$mn:00002870                 ;org 2870h
.text$mn:00002870 ; COMDAT (pick any)
.text$mn:00002870                 assume es:nothing, ss:nothing, ds:_data, fs:nothing, gs:nothing
.text$mn:00002870
.text$mn:00002870 ; =============== S U B R O U T I N E =======================================
.text$mn:00002870
.text$mn:00002870 ; Attributes: bp-based frame
.text$mn:00002870
.text$mn:00002870 ; struct std::_Nonscalar_ptr_iterator_tag __cdecl std::_Ptr_cat<struct Token, struct Token>(struct Token *, struct Token *)
.text$mn:00002870                 public ??$_Ptr_cat@UToken@@U1@@std@@YA?AU_Nonscalar_ptr_iterator_tag@0@PAUToken@@0@Z
.text$mn:00002870 ??$_Ptr_cat@UToken@@U1@@std@@YA?AU_Nonscalar_ptr_iterator_tag@0@PAUToken@@0@Z proc near
.text$mn:00002870                                         ; CODE XREF: std::_Destroy_range<std::_Wrap_alloc<std::allocator<Token>>>(Token *,Token *,std::_Wrap_alloc<std::allocator<Token>> &)+Cp
.text$mn:00002870                                         ; std::_Uninit_move<Token *,Token *,std::_Wrap_alloc<std::allocator<Token>>>(Token *,Token *,Token *,std::_Wrap_alloc<std::allocator<Token>> &)+Cp
.text$mn:00002870
.text$mn:00002870 var_1           = byte ptr -1
.text$mn:00002870
.text$mn:00002870                 push    ebp
.text$mn:00002871                 mov     ebp, esp
.text$mn:00002873                 push    ecx
.text$mn:00002874                 mov     al, [ebp+var_1]
.text$mn:00002877                 mov     esp, ebp
.text$mn:00002879                 pop     ebp
.text$mn:0000287A                 retn
.text$mn:0000287A ??$_Ptr_cat@UToken@@U1@@std@@YA?AU_Nonscalar_ptr_iterator_tag@0@PAUToken@@0@Z endp
.text$mn:0000287A
.text$mn:0000287A ; ---------------------------------------------------------------------------
.text$mn:0000287B                 align 4
.text$mn:0000287B _text$mn        ends
.text$mn:0000287B
.text$mn:0000287C ; ===========================================================================
.text$mn:0000287C
.text$mn:0000287C ; Segment type: Pure code
.text$mn:0000287C ; Segment permissions: Read/Execute
.text$mn:0000287C _text$mn        segment para public 'CODE' use32
.text$mn:0000287C                 assume cs:_text$mn
.text$mn:0000287C                 ;org 287Ch
.text$mn:0000287C ; COMDAT (pick any)
.text$mn:0000287C                 assume es:nothing, ss:nothing, ds:_data, fs:nothing, gs:nothing
.text$mn:0000287C
.text$mn:0000287C ; =============== S U B R O U T I N E =======================================
.text$mn:0000287C
.text$mn:0000287C ; Attributes: bp-based frame
.text$mn:0000287C
.text$mn:0000287C ; struct std::_Nonscalar_ptr_iterator_tag __cdecl std::_Ptr_cat<class std::vector<wchar_t const *, class std::allocator<wchar_t const *>>, class std::vector<wchar_t const *, class std::allocator<wchar_t const *>>>(class std::vector<wchar_t const *, class std::allocator<wchar_t const *>> *, class std::vector<wchar_t const *, class std::allocator<wchar_t const *>> *)
.text$mn:0000287C                 public ??$_Ptr_cat@V?$vector@PB_WV?$allocator@PB_W@std@@@std@@V12@@std@@YA?AU_Nonscalar_ptr_iterator_tag@0@PAV?$vector@PB_WV?$allocator@PB_W@std@@@0@0@Z
.text$mn:0000287C ??$_Ptr_cat@V?$vector@PB_WV?$allocator@PB_W@std@@@std@@V12@@std@@YA?AU_Nonscalar_ptr_iterator_tag@0@PAV?$vector@PB_WV?$allocator@PB_W@std@@@0@0@Z proc near
.text$mn:0000287C                                         ; CODE XREF: std::_Destroy_range<std::_Wrap_alloc<std::allocator<std::vector<wchar_t const *,std::allocator<wchar_t const *>>>>>(std::vector<wchar_t const *,std::allocator<wchar_t const *>> *,std::vector<wchar_t const *,std::allocator<wchar_t const *>> *,std::_Wrap_alloc<std::allocator<std::vector<wchar_t const *,std::allocator<wchar_t const *>>>> &)+Cp
.text$mn:0000287C                                         ; std::_Uninit_move<std::vector<wchar_t const *,std::allocator<wchar_t const *>> *,std::vector<wchar_t const *,std::allocator<wchar_t const *>> *,std::_Wrap_alloc<std::allocator<std::vector<wchar_t const *,std::allocator<wchar_t const *>>>>>(std::vector<wchar_t const *,std::allocator<wchar_t const *>> *,std::vector<wchar_t const *,std::allocator<wchar_t const *>> *,std::vector<wchar_t const *,std::allocator<wchar_t const *>> *,std::_Wrap_alloc<std::allocator<std::vector<wchar_t const *,std::allocator<wchar_t const *>>>> &)+Cp
.text$mn:0000287C
.text$mn:0000287C var_1           = byte ptr -1
.text$mn:0000287C
.text$mn:0000287C                 push    ebp
.text$mn:0000287D                 mov     ebp, esp
.text$mn:0000287F                 push    ecx
.text$mn:00002880                 mov     al, [ebp+var_1]
.text$mn:00002883                 mov     esp, ebp
.text$mn:00002885                 pop     ebp
.text$mn:00002886                 retn
.text$mn:00002886 ??$_Ptr_cat@V?$vector@PB_WV?$allocator@PB_W@std@@@std@@V12@@std@@YA?AU_Nonscalar_ptr_iterator_tag@0@PAV?$vector@PB_WV?$allocator@PB_W@std@@@0@0@Z endp
.text$mn:00002886
.text$mn:00002886 ; ---------------------------------------------------------------------------
.text$mn:00002887                 align 4
.text$mn:00002887 _text$mn        ends
.text$mn:00002887
.text$mn:00002888 ; ===========================================================================
.text$mn:00002888
.text$mn:00002888 ; Segment type: Pure code
.text$mn:00002888 ; Segment permissions: Read/Execute
.text$mn:00002888 _text$mn        segment para public 'CODE' use32
.text$mn:00002888                 assume cs:_text$mn
.text$mn:00002888                 ;org 2888h
.text$mn:00002888 ; COMDAT (pick any)
.text$mn:00002888                 assume es:nothing, ss:nothing, ds:_data, fs:nothing, gs:nothing
.text$mn:00002888
.text$mn:00002888 ; =============== S U B R O U T I N E =======================================
.text$mn:00002888
.text$mn:00002888 ; Attributes: bp-based frame
.text$mn:00002888
.text$mn:00002888 ; wchar_t const * * & __cdecl std::_Rechecked<wchar_t const * *, wchar_t const * *>(wchar_t const * * &, wchar_t const * *)
.text$mn:00002888                 public ??$_Rechecked@PAPB_WPAPB_W@std@@YAAAPAPB_WAAPAPB_WPAPB_W@Z
.text$mn:00002888 ??$_Rechecked@PAPB_WPAPB_W@std@@YAAAPAPB_WAAPAPB_WPAPB_W@Z proc near
.text$mn:00002888                                         ; CODE XREF: std::_Uninitialized_copy<std::_Vector_const_iterator<std::_Vector_val<std::_Simple_types<wchar_t const *>>>,wchar_t const * *,std::_Wrap_alloc<std::allocator<wchar_t const *>>>(std::_Vector_const_iterator<std::_Vector_val<std::_Simple_types<wchar_t const *>>>,std::_Vector_const_iterator<std::_Vector_val<std::_Simple_types<wchar_t const *>>>,wchar_t const * *,std::_Wrap_alloc<std::allocator<wchar_t const *>> &)+B2p
.text$mn:00002888                                         ; std::_Uninitialized_move<wchar_t const * *,wchar_t const * *,std::_Wrap_alloc<std::allocator<wchar_t const *>>>(wchar_t const * *,wchar_t const * *,wchar_t const * *,std::_Wrap_alloc<std::allocator<wchar_t const *>> &)+3Bp
.text$mn:00002888
.text$mn:00002888 arg_0           = dword ptr  8
.text$mn:00002888 arg_4           = dword ptr  0Ch
.text$mn:00002888
.text$mn:00002888                 push    ebp
.text$mn:00002889                 mov     ebp, esp
.text$mn:0000288B                 mov     eax, [ebp+arg_0]
.text$mn:0000288E                 mov     ecx, [ebp+arg_4]
.text$mn:00002891                 mov     [eax], ecx
.text$mn:00002893                 mov     eax, [ebp+arg_0]
.text$mn:00002896                 pop     ebp
.text$mn:00002897                 retn
.text$mn:00002897 ??$_Rechecked@PAPB_WPAPB_W@std@@YAAAPAPB_WAAPAPB_WPAPB_W@Z endp
.text$mn:00002897
.text$mn:00002897 _text$mn        ends
.text$mn:00002897
.text$mn:00002898 ; ===========================================================================
.text$mn:00002898
.text$mn:00002898 ; Segment type: Pure code
.text$mn:00002898 ; Segment permissions: Read/Execute
.text$mn:00002898 _text$mn        segment para public 'CODE' use32
.text$mn:00002898                 assume cs:_text$mn
.text$mn:00002898                 ;org 2898h
.text$mn:00002898 ; COMDAT (pick any)
.text$mn:00002898                 assume es:nothing, ss:nothing, ds:_data, fs:nothing, gs:nothing
.text$mn:00002898
.text$mn:00002898 ; =============== S U B R O U T I N E =======================================
.text$mn:00002898
.text$mn:00002898 ; Attributes: bp-based frame
.text$mn:00002898
.text$mn:00002898 ; struct FunctionValues * & __cdecl std::_Rechecked<struct FunctionValues *, struct FunctionValues *>(struct FunctionValues * &, struct FunctionValues *)
.text$mn:00002898                 public ??$_Rechecked@PAUFunctionValues@@PAU1@@std@@YAAAPAUFunctionValues@@AAPAU1@PAU1@@Z
.text$mn:00002898 ??$_Rechecked@PAUFunctionValues@@PAU1@@std@@YAAAPAUFunctionValues@@AAPAU1@PAU1@@Z proc near
.text$mn:00002898                                         ; CODE XREF: std::_Uninitialized_move<FunctionValues *,FunctionValues *,std::_Wrap_alloc<std::allocator<FunctionValues>>>(FunctionValues *,FunctionValues *,FunctionValues *,std::_Wrap_alloc<std::allocator<FunctionValues>> &)+3Bp
.text$mn:00002898
.text$mn:00002898 arg_0           = dword ptr  8
.text$mn:00002898 arg_4           = dword ptr  0Ch
.text$mn:00002898
.text$mn:00002898                 push    ebp
.text$mn:00002899                 mov     ebp, esp
.text$mn:0000289B                 mov     eax, [ebp+arg_0]
.text$mn:0000289E                 mov     ecx, [ebp+arg_4]
.text$mn:000028A1                 mov     [eax], ecx
.text$mn:000028A3                 mov     eax, [ebp+arg_0]
.text$mn:000028A6                 pop     ebp
.text$mn:000028A7                 retn
.text$mn:000028A7 ??$_Rechecked@PAUFunctionValues@@PAU1@@std@@YAAAPAUFunctionValues@@AAPAU1@PAU1@@Z endp
.text$mn:000028A7
.text$mn:000028A7 _text$mn        ends
.text$mn:000028A7
.text$mn:000028A8 ; ===========================================================================
.text$mn:000028A8
.text$mn:000028A8 ; Segment type: Pure code
.text$mn:000028A8 ; Segment permissions: Read/Execute
.text$mn:000028A8 _text$mn        segment para public 'CODE' use32
.text$mn:000028A8                 assume cs:_text$mn
.text$mn:000028A8                 ;org 28A8h
.text$mn:000028A8 ; COMDAT (pick any)
.text$mn:000028A8                 assume es:nothing, ss:nothing, ds:_data, fs:nothing, gs:nothing
.text$mn:000028A8
.text$mn:000028A8 ; =============== S U B R O U T I N E =======================================
.text$mn:000028A8
.text$mn:000028A8 ; Attributes: bp-based frame
.text$mn:000028A8
.text$mn:000028A8 ; struct Token * & __cdecl std::_Rechecked<struct Token *, struct Token *>(struct Token * &, struct Token *)
.text$mn:000028A8                 public ??$_Rechecked@PAUToken@@PAU1@@std@@YAAAPAUToken@@AAPAU1@PAU1@@Z
.text$mn:000028A8 ??$_Rechecked@PAUToken@@PAU1@@std@@YAAAPAUToken@@AAPAU1@PAU1@@Z proc near
.text$mn:000028A8                                         ; CODE XREF: std::_Uninitialized_move<Token *,Token *,std::_Wrap_alloc<std::allocator<Token>>>(Token *,Token *,Token *,std::_Wrap_alloc<std::allocator<Token>> &)+3Bp
.text$mn:000028A8
.text$mn:000028A8 arg_0           = dword ptr  8
.text$mn:000028A8 arg_4           = dword ptr  0Ch
.text$mn:000028A8
.text$mn:000028A8                 push    ebp
.text$mn:000028A9                 mov     ebp, esp
.text$mn:000028AB                 mov     eax, [ebp+arg_0]
.text$mn:000028AE                 mov     ecx, [ebp+arg_4]
.text$mn:000028B1                 mov     [eax], ecx
.text$mn:000028B3                 mov     eax, [ebp+arg_0]
.text$mn:000028B6                 pop     ebp
.text$mn:000028B7                 retn
.text$mn:000028B7 ??$_Rechecked@PAUToken@@PAU1@@std@@YAAAPAUToken@@AAPAU1@PAU1@@Z endp
.text$mn:000028B7
.text$mn:000028B7 _text$mn        ends
.text$mn:000028B7
.text$mn:000028B8 ; ===========================================================================
.text$mn:000028B8
.text$mn:000028B8 ; Segment type: Pure code
.text$mn:000028B8 ; Segment permissions: Read/Execute
.text$mn:000028B8 _text$mn        segment para public 'CODE' use32
.text$mn:000028B8                 assume cs:_text$mn
.text$mn:000028B8                 ;org 28B8h
.text$mn:000028B8 ; COMDAT (pick any)
.text$mn:000028B8                 assume es:nothing, ss:nothing, ds:_data, fs:nothing, gs:nothing
.text$mn:000028B8
.text$mn:000028B8 ; =============== S U B R O U T I N E =======================================
.text$mn:000028B8
.text$mn:000028B8 ; Attributes: bp-based frame
.text$mn:000028B8
.text$mn:000028B8 ; class std::vector<wchar_t const *, class std::allocator<wchar_t const *>> * & __cdecl std::_Rechecked<class std::vector<wchar_t const *, class std::allocator<wchar_t const *>> *, class std::vector<wchar_t const *, class std::allocator<wchar_t const *>> *>(class std::vector<wchar_t const *, class std::allocator<wchar_t const *>> * &, class std::vector<wchar_t const *, class std::allocator<wchar_t const *>> *)
.text$mn:000028B8                 public ??$_Rechecked@PAV?$vector@PB_WV?$allocator@PB_W@std@@@std@@PAV12@@std@@YAAAPAV?$vector@PB_WV?$allocator@PB_W@std@@@0@AAPAV10@PAV10@@Z
.text$mn:000028B8 ??$_Rechecked@PAV?$vector@PB_WV?$allocator@PB_W@std@@@std@@PAV12@@std@@YAAAPAV?$vector@PB_WV?$allocator@PB_W@std@@@0@AAPAV10@PAV10@@Z proc near
.text$mn:000028B8                                         ; CODE XREF: std::_Uninitialized_move<std::vector<wchar_t const *,std::allocator<wchar_t const *>> *,std::vector<wchar_t const *,std::allocator<wchar_t const *>> *,std::_Wrap_alloc<std::allocator<std::vector<wchar_t const *,std::allocator<wchar_t const *>>>>>(std::vector<wchar_t const *,std::allocator<wchar_t const *>> *,std::vector<wchar_t const *,std::allocator<wchar_t const *>> *,std::vector<wchar_t const *,std::allocator<wchar_t const *>> *,std::_Wrap_alloc<std::allocator<std::vector<wchar_t const *,std::allocator<wchar_t const *>>>> &)+3Bp
.text$mn:000028B8
.text$mn:000028B8 arg_0           = dword ptr  8
.text$mn:000028B8 arg_4           = dword ptr  0Ch
.text$mn:000028B8
.text$mn:000028B8                 push    ebp
.text$mn:000028B9                 mov     ebp, esp
.text$mn:000028BB                 mov     eax, [ebp+arg_0]
.text$mn:000028BE                 mov     ecx, [ebp+arg_4]
.text$mn:000028C1                 mov     [eax], ecx
.text$mn:000028C3                 mov     eax, [ebp+arg_0]
.text$mn:000028C6                 pop     ebp
.text$mn:000028C7                 retn
.text$mn:000028C7 ??$_Rechecked@PAV?$vector@PB_WV?$allocator@PB_W@std@@@std@@PAV12@@std@@YAAAPAV?$vector@PB_WV?$allocator@PB_W@std@@@0@AAPAV10@PAV10@@Z endp
.text$mn:000028C7
.text$mn:000028C7 _text$mn        ends
.text$mn:000028C7
.text$mn:000028C8 ; ===========================================================================
.text$mn:000028C8
.text$mn:000028C8 ; Segment type: Pure code
.text$mn:000028C8 ; Segment permissions: Read/Execute
.text$mn:000028C8 _text$mn        segment para public 'CODE' use32
.text$mn:000028C8                 assume cs:_text$mn
.text$mn:000028C8                 ;org 28C8h
.text$mn:000028C8 ; COMDAT (pick any)
.text$mn:000028C8                 assume es:nothing, ss:nothing, ds:_data, fs:nothing, gs:nothing
.text$mn:000028C8
.text$mn:000028C8 ; =============== S U B R O U T I N E =======================================
.text$mn:000028C8
.text$mn:000028C8 ; Attributes: bp-based frame
.text$mn:000028C8
.text$mn:000028C8 ; protected: wchar_t const * * __thiscall std::vector<wchar_t const *, class std::allocator<wchar_t const *>>::_Ucopy<class std::_Vector_const_iterator<class std::_Vector_val<struct std::_Simple_types<wchar_t const *>>>>(class std::_Vector_const_iterator<class std::_Vector_val<struct std::_Simple_types<wchar_t const *>>>, class std::_Vector_const_iterator<class std::_Vector_val<struct std::_Simple_types<wchar_t const *>>>, wchar_t const * *)
.text$mn:000028C8                 public ??$_Ucopy@V?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@PB_W@std@@@std@@@std@@@?$vector@PB_WV?$allocator@PB_W@std@@@std@@IAEPAPB_WV?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@PB_W@std@@@std@@@1@0PAPB_W@Z
.text$mn:000028C8 ??$_Ucopy@V?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@PB_W@std@@@std@@@std@@@?$vector@PB_WV?$allocator@PB_W@std@@@std@@IAEPAPB_WV?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@PB_W@std@@@std@@@1@0PAPB_W@Z proc near
.text$mn:000028C8                                         ; CODE XREF: std::vector<wchar_t const *,std::allocator<wchar_t const *>>::vector<wchar_t const *,std::allocator<wchar_t const *>>(std::vector<wchar_t const *,std::allocator<wchar_t const *>> const &)+C0p
.text$mn:000028C8
.text$mn:000028C8 var_34          = dword ptr -34h
.text$mn:000028C8 var_30          = dword ptr -30h
.text$mn:000028C8 var_2C          = dword ptr -2Ch
.text$mn:000028C8 var_28          = dword ptr -28h
.text$mn:000028C8 var_24          = dword ptr -24h
.text$mn:000028C8 var_20          = dword ptr -20h
.text$mn:000028C8 var_1C          = dword ptr -1Ch
.text$mn:000028C8 var_18          = dword ptr -18h
.text$mn:000028C8 var_14          = dword ptr -14h
.text$mn:000028C8 var_D           = byte ptr -0Dh
.text$mn:000028C8 var_C           = dword ptr -0Ch
.text$mn:000028C8 var_4           = dword ptr -4
.text$mn:000028C8 arg_0           = byte ptr  8
.text$mn:000028C8 arg_C           = byte ptr  14h
.text$mn:000028C8 arg_18          = dword ptr  20h
.text$mn:000028C8
.text$mn:000028C8                 push    ebp
.text$mn:000028C9                 mov     ebp, esp
.text$mn:000028CB                 push    0FFFFFFFFh
.text$mn:000028CD                 push    offset __ehhandler$??$_Ucopy@V?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@PB_W@std@@@std@@@std@@@?$vector@PB_WV?$allocator@PB_W@std@@@std@@IAEPAPB_WV?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@PB_W@std@@@std@@@1@0PAPB_W@Z
.text$mn:000028D2                 mov     eax, large fs:0
.text$mn:000028D8                 push    eax
.text$mn:000028D9                 sub     esp, 28h
.text$mn:000028DC                 mov     eax, dword ptr ds:___security_cookie
.text$mn:000028E1                 xor     eax, ebp
.text$mn:000028E3                 push    eax
.text$mn:000028E4                 lea     eax, [ebp+var_C]
.text$mn:000028E7                 mov     large fs:0, eax
.text$mn:000028ED                 mov     [ebp+var_14], ecx
.text$mn:000028F0                 mov     [ebp+var_4], 1
.text$mn:000028F7                 lea     eax, [ebp+var_D]
.text$mn:000028FA                 push    eax
.text$mn:000028FB                 mov     ecx, [ebp+var_14]
.text$mn:000028FE                 call    ?_Getal@?$_Vector_alloc@$0A@U?$_Vec_base_types@PB_WV?$allocator@PB_W@std@@@std@@@std@@QBE?AU?$_Wrap_alloc@V?$allocator@PB_W@std@@@2@XZ ; std::_Vector_alloc<0,std::_Vec_base_types<wchar_t const *,std::allocator<wchar_t const *>>>::_Getal(void)
.text$mn:00002903                 lea     ecx, [ebp+var_D]
.text$mn:00002906                 push    ecx
.text$mn:00002907                 mov     edx, [ebp+arg_18]
.text$mn:0000290A                 push    edx
.text$mn:0000290B                 sub     esp, 0Ch
.text$mn:0000290E                 mov     ecx, esp
.text$mn:00002910                 mov     [ebp+var_28], esp
.text$mn:00002913                 lea     eax, [ebp+arg_C]
.text$mn:00002916                 push    eax             ; struct std::_Iterator_base12 *
.text$mn:00002917                 call    ??0?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@PB_W@std@@@std@@@std@@QAE@ABV01@@Z ; std::_Vector_const_iterator<std::_Vector_val<std::_Simple_types<wchar_t const *>>>::_Vector_const_iterator<std::_Vector_val<std::_Simple_types<wchar_t const *>>>(std::_Vector_const_iterator<std::_Vector_val<std::_Simple_types<wchar_t const *>>> const &)
.text$mn:0000291C                 mov     [ebp+var_18], eax
.text$mn:0000291F                 mov     ecx, [ebp+var_18]
.text$mn:00002922                 mov     [ebp+var_2C], ecx
.text$mn:00002925                 mov     byte ptr [ebp+var_4], 2
.text$mn:00002929                 sub     esp, 0Ch
.text$mn:0000292C                 mov     ecx, esp
.text$mn:0000292E                 mov     [ebp+var_30], esp
.text$mn:00002931                 lea     edx, [ebp+arg_0]
.text$mn:00002934                 push    edx             ; struct std::_Iterator_base12 *
.text$mn:00002935                 call    ??0?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@PB_W@std@@@std@@@std@@QAE@ABV01@@Z ; std::_Vector_const_iterator<std::_Vector_val<std::_Simple_types<wchar_t const *>>>::_Vector_const_iterator<std::_Vector_val<std::_Simple_types<wchar_t const *>>>(std::_Vector_const_iterator<std::_Vector_val<std::_Simple_types<wchar_t const *>>> const &)
.text$mn:0000293A                 mov     [ebp+var_1C], eax
.text$mn:0000293D                 mov     eax, [ebp+var_1C]
.text$mn:00002940                 mov     [ebp+var_34], eax
.text$mn:00002943                 mov     byte ptr [ebp+var_4], 3
.text$mn:00002947                 mov     byte ptr [ebp+var_4], 1
.text$mn:0000294B                 call    ??$_Uninitialized_copy@V?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@PB_W@std@@@std@@@std@@PAPB_WU?$_Wrap_alloc@V?$allocator@PB_W@std@@@2@@std@@YAPAPB_WV?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@PB_W@std@@@std@@@0@0PAPB_WAAU?$_Wrap_alloc@V?$allocator@PB_W@std@@@0@@Z ; std::_Uninitialized_copy<std::_Vector_const_iterator<std::_Vector_val<std::_Simple_types<wchar_t const *>>>,wchar_t const * *,std::_Wrap_alloc<std::allocator<wchar_t const *>>>(std::_Vector_const_iterator<std::_Vector_val<std::_Simple_types<wchar_t const *>>>,std::_Vector_const_iterator<std::_Vector_val<std::_Simple_types<wchar_t const *>>>,wchar_t const * *,std::_Wrap_alloc<std::allocator<wchar_t const *>> &)
.text$mn:00002950                 add     esp, 20h
.text$mn:00002953                 mov     [ebp+var_20], eax
.text$mn:00002956                 mov     ecx, [ebp+var_20]
.text$mn:00002959                 mov     [ebp+var_24], ecx
.text$mn:0000295C                 mov     byte ptr [ebp+var_4], 0
.text$mn:00002960                 lea     ecx, [ebp+arg_0]
.text$mn:00002963                 call    ??1?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@PB_W@std@@@std@@@std@@QAE@XZ ; std::_Vector_const_iterator<std::_Vector_val<std::_Simple_types<wchar_t const *>>>::~_Vector_const_iterator<std::_Vector_val<std::_Simple_types<wchar_t const *>>>(void)
.text$mn:00002968                 mov     [ebp+var_4], 0FFFFFFFFh
.text$mn:0000296F                 lea     ecx, [ebp+arg_C]
.text$mn:00002972                 call    ??1?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@PB_W@std@@@std@@@std@@QAE@XZ ; std::_Vector_const_iterator<std::_Vector_val<std::_Simple_types<wchar_t const *>>>::~_Vector_const_iterator<std::_Vector_val<std::_Simple_types<wchar_t const *>>>(void)
.text$mn:00002977                 mov     eax, [ebp+var_24]
.text$mn:0000297A                 mov     ecx, [ebp+var_C]
.text$mn:0000297D                 mov     large fs:0, ecx
.text$mn:00002984                 pop     ecx
.text$mn:00002985                 mov     esp, ebp
.text$mn:00002987                 pop     ebp
.text$mn:00002988                 retn    1Ch
.text$mn:00002988 ??$_Ucopy@V?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@PB_W@std@@@std@@@std@@@?$vector@PB_WV?$allocator@PB_W@std@@@std@@IAEPAPB_WV?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@PB_W@std@@@std@@@1@0PAPB_W@Z endp
.text$mn:00002988
.text$mn:00002988 ; ---------------------------------------------------------------------------
.text$mn:0000298B                 align 4
.text$mn:0000298B _text$mn        ends
.text$mn:0000298B
.text$x:0000298C ; ===========================================================================
.text$x:0000298C
.text$x:0000298C ; Segment type: Pure code
.text$x:0000298C ; Segment permissions: Read/Execute
.text$x:0000298C _text$x         segment para public 'CODE' use32
.text$x:0000298C                 assume cs:_text$x
.text$x:0000298C                 ;org 298Ch
.text$x:0000298C ; COMDAT (pick associative to section at 28C8)
.text$x:0000298C                 assume es:nothing, ss:nothing, ds:_data, fs:nothing, gs:nothing
.text$x:0000298C
.text$x:0000298C ; =============== S U B R O U T I N E =======================================
.text$x:0000298C
.text$x:0000298C
.text$x:0000298C __unwindfunclet$??$_Ucopy@V?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@PB_W@std@@@std@@@std@@@?$vector@PB_WV?$allocator@PB_W@std@@@std@@IAEPAPB_WV?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@PB_W@std@@@std@@@1@0PAPB_W@Z$0 proc near
.text$x:0000298C                                         ; DATA XREF: .xdata$x:0000A100o
.text$x:0000298C                 lea     ecx, [ebp+14h]
.text$x:0000298F                 jmp     ??1?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@PB_W@std@@@std@@@std@@QAE@XZ ; std::_Vector_const_iterator<std::_Vector_val<std::_Simple_types<wchar_t const *>>>::~_Vector_const_iterator<std::_Vector_val<std::_Simple_types<wchar_t const *>>>(void)
.text$x:0000298F __unwindfunclet$??$_Ucopy@V?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@PB_W@std@@@std@@@std@@@?$vector@PB_WV?$allocator@PB_W@std@@@std@@IAEPAPB_WV?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@PB_W@std@@@std@@@1@0PAPB_W@Z$0 endp
.text$x:0000298F
.text$x:00002994
.text$x:00002994 ; =============== S U B R O U T I N E =======================================
.text$x:00002994
.text$x:00002994
.text$x:00002994 __unwindfunclet$??$_Ucopy@V?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@PB_W@std@@@std@@@std@@@?$vector@PB_WV?$allocator@PB_W@std@@@std@@IAEPAPB_WV?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@PB_W@std@@@std@@@1@0PAPB_W@Z$1 proc near
.text$x:00002994                                         ; DATA XREF: .xdata$x:0000A108o
.text$x:00002994                 lea     ecx, [ebp+8]
.text$x:00002997                 jmp     ??1?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@PB_W@std@@@std@@@std@@QAE@XZ ; std::_Vector_const_iterator<std::_Vector_val<std::_Simple_types<wchar_t const *>>>::~_Vector_const_iterator<std::_Vector_val<std::_Simple_types<wchar_t const *>>>(void)
.text$x:00002997 __unwindfunclet$??$_Ucopy@V?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@PB_W@std@@@std@@@std@@@?$vector@PB_WV?$allocator@PB_W@std@@@std@@IAEPAPB_WV?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@PB_W@std@@@std@@@1@0PAPB_W@Z$1 endp
.text$x:00002997
.text$x:0000299C
.text$x:0000299C ; =============== S U B R O U T I N E =======================================
.text$x:0000299C
.text$x:0000299C
.text$x:0000299C __unwindfunclet$??$_Ucopy@V?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@PB_W@std@@@std@@@std@@@?$vector@PB_WV?$allocator@PB_W@std@@@std@@IAEPAPB_WV?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@PB_W@std@@@std@@@1@0PAPB_W@Z$2 proc near
.text$x:0000299C                                         ; DATA XREF: .xdata$x:0000A110o
.text$x:0000299C                 mov     ecx, [ebp-28h]
.text$x:0000299F                 jmp     ??1?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@PB_W@std@@@std@@@std@@QAE@XZ ; std::_Vector_const_iterator<std::_Vector_val<std::_Simple_types<wchar_t const *>>>::~_Vector_const_iterator<std::_Vector_val<std::_Simple_types<wchar_t const *>>>(void)
.text$x:0000299F __unwindfunclet$??$_Ucopy@V?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@PB_W@std@@@std@@@std@@@?$vector@PB_WV?$allocator@PB_W@std@@@std@@IAEPAPB_WV?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@PB_W@std@@@std@@@1@0PAPB_W@Z$2 endp
.text$x:0000299F
.text$x:000029A4
.text$x:000029A4 ; =============== S U B R O U T I N E =======================================
.text$x:000029A4
.text$x:000029A4
.text$x:000029A4 __unwindfunclet$??$_Ucopy@V?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@PB_W@std@@@std@@@std@@@?$vector@PB_WV?$allocator@PB_W@std@@@std@@IAEPAPB_WV?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@PB_W@std@@@std@@@1@0PAPB_W@Z$3 proc near
.text$x:000029A4                                         ; DATA XREF: .xdata$x:0000A118o
.text$x:000029A4                 mov     ecx, [ebp-30h]
.text$x:000029A7                 jmp     ??1?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@PB_W@std@@@std@@@std@@QAE@XZ ; std::_Vector_const_iterator<std::_Vector_val<std::_Simple_types<wchar_t const *>>>::~_Vector_const_iterator<std::_Vector_val<std::_Simple_types<wchar_t const *>>>(void)
.text$x:000029A7 __unwindfunclet$??$_Ucopy@V?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@PB_W@std@@@std@@@std@@@?$vector@PB_WV?$allocator@PB_W@std@@@std@@IAEPAPB_WV?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@PB_W@std@@@std@@@1@0PAPB_W@Z$3 endp
.text$x:000029A7
.text$x:000029AC
.text$x:000029AC ; =============== S U B R O U T I N E =======================================
.text$x:000029AC
.text$x:000029AC
.text$x:000029AC __ehhandler$??$_Ucopy@V?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@PB_W@std@@@std@@@std@@@?$vector@PB_WV?$allocator@PB_W@std@@@std@@IAEPAPB_WV?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@PB_W@std@@@std@@@1@0PAPB_W@Z proc near
.text$x:000029AC                                         ; DATA XREF: std::vector<wchar_t const *,std::allocator<wchar_t const *>>::_Ucopy<std::_Vector_const_iterator<std::_Vector_val<std::_Simple_types<wchar_t const *>>>>(std::_Vector_const_iterator<std::_Vector_val<std::_Simple_types<wchar_t const *>>>,std::_Vector_const_iterator<std::_Vector_val<std::_Simple_types<wchar_t const *>>>,wchar_t const * *)+5o
.text$x:000029AC
.text$x:000029AC arg_4           = dword ptr  8
.text$x:000029AC
.text$x:000029AC                 mov     edx, [esp+arg_4]
.text$x:000029B0                 lea     eax, [edx+0Ch]
.text$x:000029B3                 mov     ecx, [edx-2Ch]
.text$x:000029B6                 xor     ecx, eax
.text$x:000029B8                 call    @__security_check_cookie@4 ; __security_check_cookie(x)
.text$x:000029BD                 mov     eax, offset __ehfuncinfo$??$_Ucopy@V?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@PB_W@std@@@std@@@std@@@?$vector@PB_WV?$allocator@PB_W@std@@@std@@IAEPAPB_WV?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@PB_W@std@@@std@@@1@0PAPB_W@Z
.text$x:000029C2                 jmp     ___CxxFrameHandler3
.text$x:000029C2 __ehhandler$??$_Ucopy@V?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@PB_W@std@@@std@@@std@@@?$vector@PB_WV?$allocator@PB_W@std@@@std@@IAEPAPB_WV?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@PB_W@std@@@std@@@1@0PAPB_W@Z endp
.text$x:000029C2
.text$x:000029C2 ; ---------------------------------------------------------------------------
.text$x:000029C7                 align 4
.text$x:000029C7 _text$x         ends
.text$x:000029C7
.text$mn:000029C8 ; ===========================================================================
.text$mn:000029C8
.text$mn:000029C8 ; Segment type: Pure code
.text$mn:000029C8 ; Segment permissions: Read/Execute
.text$mn:000029C8 _text$mn        segment para public 'CODE' use32
.text$mn:000029C8                 assume cs:_text$mn
.text$mn:000029C8                 ;org 29C8h
.text$mn:000029C8 ; COMDAT (pick any)
.text$mn:000029C8                 assume es:nothing, ss:nothing, ds:_data, fs:nothing, gs:nothing
.text$mn:000029C8
.text$mn:000029C8 ; =============== S U B R O U T I N E =======================================
.text$mn:000029C8
.text$mn:000029C8 ; Attributes: bp-based frame
.text$mn:000029C8
.text$mn:000029C8 ; protected: wchar_t const * * __thiscall std::vector<wchar_t const *, class std::allocator<wchar_t const *>>::_Umove<wchar_t const * *>(wchar_t const * *, wchar_t const * *, wchar_t const * *)
.text$mn:000029C8                 public ??$_Umove@PAPB_W@?$vector@PB_WV?$allocator@PB_W@std@@@std@@IAEPAPB_WPAPB_W00@Z
.text$mn:000029C8 ??$_Umove@PAPB_W@?$vector@PB_WV?$allocator@PB_W@std@@@std@@IAEPAPB_WPAPB_W00@Z proc near
.text$mn:000029C8                                         ; CODE XREF: std::vector<wchar_t const *,std::allocator<wchar_t const *>>::_Reallocate(uint)+65p
.text$mn:000029C8
.text$mn:000029C8 var_8           = dword ptr -8
.text$mn:000029C8 var_1           = byte ptr -1
.text$mn:000029C8 arg_0           = dword ptr  8
.text$mn:000029C8 arg_4           = dword ptr  0Ch
.text$mn:000029C8 arg_8           = dword ptr  10h
.text$mn:000029C8
.text$mn:000029C8                 push    ebp
.text$mn:000029C9                 mov     ebp, esp
.text$mn:000029CB                 sub     esp, 8
.text$mn:000029CE                 mov     [ebp+var_8], ecx
.text$mn:000029D1                 lea     eax, [ebp+var_1]
.text$mn:000029D4                 push    eax
.text$mn:000029D5                 mov     ecx, [ebp+var_8]
.text$mn:000029D8                 call    ?_Getal@?$_Vector_alloc@$0A@U?$_Vec_base_types@PB_WV?$allocator@PB_W@std@@@std@@@std@@QBE?AU?$_Wrap_alloc@V?$allocator@PB_W@std@@@2@XZ ; std::_Vector_alloc<0,std::_Vec_base_types<wchar_t const *,std::allocator<wchar_t const *>>>::_Getal(void)
.text$mn:000029DD                 lea     ecx, [ebp+var_1]
.text$mn:000029E0                 push    ecx
.text$mn:000029E1                 mov     edx, [ebp+arg_8]
.text$mn:000029E4                 push    edx
.text$mn:000029E5                 mov     eax, [ebp+arg_4]
.text$mn:000029E8                 push    eax
.text$mn:000029E9                 mov     ecx, [ebp+arg_0]
.text$mn:000029EC                 push    ecx
.text$mn:000029ED                 call    ??$_Uninitialized_move@PAPB_WPAPB_WU?$_Wrap_alloc@V?$allocator@PB_W@std@@@std@@@std@@YAPAPB_WPAPB_W00AAU?$_Wrap_alloc@V?$allocator@PB_W@std@@@0@@Z ; std::_Uninitialized_move<wchar_t const * *,wchar_t const * *,std::_Wrap_alloc<std::allocator<wchar_t const *>>>(wchar_t const * *,wchar_t const * *,wchar_t const * *,std::_Wrap_alloc<std::allocator<wchar_t const *>> &)
.text$mn:000029F2                 add     esp, 10h
.text$mn:000029F5                 mov     esp, ebp
.text$mn:000029F7                 pop     ebp
.text$mn:000029F8                 retn    0Ch
.text$mn:000029F8 ??$_Umove@PAPB_W@?$vector@PB_WV?$allocator@PB_W@std@@@std@@IAEPAPB_WPAPB_W00@Z endp
.text$mn:000029F8
.text$mn:000029F8 ; ---------------------------------------------------------------------------
.text$mn:000029FB                 align 4
.text$mn:000029FB _text$mn        ends
.text$mn:000029FB
.text$mn:000029FC ; ===========================================================================
.text$mn:000029FC
.text$mn:000029FC ; Segment type: Pure code
.text$mn:000029FC ; Segment permissions: Read/Execute
.text$mn:000029FC _text$mn        segment para public 'CODE' use32
.text$mn:000029FC                 assume cs:_text$mn
.text$mn:000029FC                 ;org 29FCh
.text$mn:000029FC ; COMDAT (pick any)
.text$mn:000029FC                 assume es:nothing, ss:nothing, ds:_data, fs:nothing, gs:nothing
.text$mn:000029FC
.text$mn:000029FC ; =============== S U B R O U T I N E =======================================
.text$mn:000029FC
.text$mn:000029FC ; Attributes: bp-based frame
.text$mn:000029FC
.text$mn:000029FC ; protected: struct FunctionValues * __thiscall std::vector<struct FunctionValues, class std::allocator<struct FunctionValues>>::_Umove<struct FunctionValues *>(struct FunctionValues *, struct FunctionValues *, struct FunctionValues *)
.text$mn:000029FC                 public ??$_Umove@PAUFunctionValues@@@?$vector@UFunctionValues@@V?$allocator@UFunctionValues@@@std@@@std@@IAEPAUFunctionValues@@PAU2@00@Z
.text$mn:000029FC ??$_Umove@PAUFunctionValues@@@?$vector@UFunctionValues@@V?$allocator@UFunctionValues@@@std@@@std@@IAEPAUFunctionValues@@PAU2@00@Z proc near
.text$mn:000029FC                                         ; CODE XREF: std::vector<FunctionValues,std::allocator<FunctionValues>>::_Reallocate(uint)+65p
.text$mn:000029FC
.text$mn:000029FC var_8           = dword ptr -8
.text$mn:000029FC var_1           = byte ptr -1
.text$mn:000029FC arg_0           = dword ptr  8
.text$mn:000029FC arg_4           = dword ptr  0Ch
.text$mn:000029FC arg_8           = dword ptr  10h
.text$mn:000029FC
.text$mn:000029FC                 push    ebp
.text$mn:000029FD                 mov     ebp, esp
.text$mn:000029FF                 sub     esp, 8
.text$mn:00002A02                 mov     [ebp+var_8], ecx
.text$mn:00002A05                 lea     eax, [ebp+var_1]
.text$mn:00002A08                 push    eax
.text$mn:00002A09                 mov     ecx, [ebp+var_8]
.text$mn:00002A0C                 call    ?_Getal@?$_Vector_alloc@$0A@U?$_Vec_base_types@UFunctionValues@@V?$allocator@UFunctionValues@@@std@@@std@@@std@@QBE?AU?$_Wrap_alloc@V?$allocator@UFunctionValues@@@std@@@2@XZ ; std::_Vector_alloc<0,std::_Vec_base_types<FunctionValues,std::allocator<FunctionValues>>>::_Getal(void)
.text$mn:00002A11                 lea     ecx, [ebp+var_1]
.text$mn:00002A14                 push    ecx
.text$mn:00002A15                 mov     edx, [ebp+arg_8]
.text$mn:00002A18                 push    edx
.text$mn:00002A19                 mov     eax, [ebp+arg_4]
.text$mn:00002A1C                 push    eax
.text$mn:00002A1D                 mov     ecx, [ebp+arg_0]
.text$mn:00002A20                 push    ecx
.text$mn:00002A21                 call    ??$_Uninitialized_move@PAUFunctionValues@@PAU1@U?$_Wrap_alloc@V?$allocator@UFunctionValues@@@std@@@std@@@std@@YAPAUFunctionValues@@PAU1@00AAU?$_Wrap_alloc@V?$allocator@UFunctionValues@@@std@@@0@@Z ; std::_Uninitialized_move<FunctionValues *,FunctionValues *,std::_Wrap_alloc<std::allocator<FunctionValues>>>(FunctionValues *,FunctionValues *,FunctionValues *,std::_Wrap_alloc<std::allocator<FunctionValues>> &)
.text$mn:00002A26                 add     esp, 10h
.text$mn:00002A29                 mov     esp, ebp
.text$mn:00002A2B                 pop     ebp
.text$mn:00002A2C                 retn    0Ch
.text$mn:00002A2C ??$_Umove@PAUFunctionValues@@@?$vector@UFunctionValues@@V?$allocator@UFunctionValues@@@std@@@std@@IAEPAUFunctionValues@@PAU2@00@Z endp
.text$mn:00002A2C
.text$mn:00002A2C ; ---------------------------------------------------------------------------
.text$mn:00002A2F                 align 10h
.text$mn:00002A2F _text$mn        ends
.text$mn:00002A2F
.text$mn:00002A30 ; ===========================================================================
.text$mn:00002A30
.text$mn:00002A30 ; Segment type: Pure code
.text$mn:00002A30 ; Segment permissions: Read/Execute
.text$mn:00002A30 _text$mn        segment para public 'CODE' use32
.text$mn:00002A30                 assume cs:_text$mn
.text$mn:00002A30                 ;org 2A30h
.text$mn:00002A30 ; COMDAT (pick any)
.text$mn:00002A30                 assume es:nothing, ss:nothing, ds:_data, fs:nothing, gs:nothing
.text$mn:00002A30
.text$mn:00002A30 ; =============== S U B R O U T I N E =======================================
.text$mn:00002A30
.text$mn:00002A30 ; Attributes: bp-based frame
.text$mn:00002A30
.text$mn:00002A30 ; protected: struct Token * __thiscall std::vector<struct Token, class std::allocator<struct Token>>::_Umove<struct Token *>(struct Token *, struct Token *, struct Token *)
.text$mn:00002A30                 public ??$_Umove@PAUToken@@@?$vector@UToken@@V?$allocator@UToken@@@std@@@std@@IAEPAUToken@@PAU2@00@Z
.text$mn:00002A30 ??$_Umove@PAUToken@@@?$vector@UToken@@V?$allocator@UToken@@@std@@@std@@IAEPAUToken@@PAU2@00@Z proc near
.text$mn:00002A30                                         ; CODE XREF: std::vector<Token,std::allocator<Token>>::_Reallocate(uint)+65p
.text$mn:00002A30
.text$mn:00002A30 var_8           = dword ptr -8
.text$mn:00002A30 var_1           = byte ptr -1
.text$mn:00002A30 arg_0           = dword ptr  8
.text$mn:00002A30 arg_4           = dword ptr  0Ch
.text$mn:00002A30 arg_8           = dword ptr  10h
.text$mn:00002A30
.text$mn:00002A30                 push    ebp
.text$mn:00002A31                 mov     ebp, esp
.text$mn:00002A33                 sub     esp, 8
.text$mn:00002A36                 mov     [ebp+var_8], ecx
.text$mn:00002A39                 lea     eax, [ebp+var_1]
.text$mn:00002A3C                 push    eax
.text$mn:00002A3D                 mov     ecx, [ebp+var_8]
.text$mn:00002A40                 call    ?_Getal@?$_Vector_alloc@$0A@U?$_Vec_base_types@UToken@@V?$allocator@UToken@@@std@@@std@@@std@@QBE?AU?$_Wrap_alloc@V?$allocator@UToken@@@std@@@2@XZ ; std::_Vector_alloc<0,std::_Vec_base_types<Token,std::allocator<Token>>>::_Getal(void)
.text$mn:00002A45                 lea     ecx, [ebp+var_1]
.text$mn:00002A48                 push    ecx
.text$mn:00002A49                 mov     edx, [ebp+arg_8]
.text$mn:00002A4C                 push    edx
.text$mn:00002A4D                 mov     eax, [ebp+arg_4]
.text$mn:00002A50                 push    eax
.text$mn:00002A51                 mov     ecx, [ebp+arg_0]
.text$mn:00002A54                 push    ecx
.text$mn:00002A55                 call    ??$_Uninitialized_move@PAUToken@@PAU1@U?$_Wrap_alloc@V?$allocator@UToken@@@std@@@std@@@std@@YAPAUToken@@PAU1@00AAU?$_Wrap_alloc@V?$allocator@UToken@@@std@@@0@@Z ; std::_Uninitialized_move<Token *,Token *,std::_Wrap_alloc<std::allocator<Token>>>(Token *,Token *,Token *,std::_Wrap_alloc<std::allocator<Token>> &)
.text$mn:00002A5A                 add     esp, 10h
.text$mn:00002A5D                 mov     esp, ebp
.text$mn:00002A5F                 pop     ebp
.text$mn:00002A60                 retn    0Ch
.text$mn:00002A60 ??$_Umove@PAUToken@@@?$vector@UToken@@V?$allocator@UToken@@@std@@@std@@IAEPAUToken@@PAU2@00@Z endp
.text$mn:00002A60
.text$mn:00002A60 ; ---------------------------------------------------------------------------
.text$mn:00002A63                 align 4
.text$mn:00002A63 _text$mn        ends
.text$mn:00002A63
.text$mn:00002A64 ; ===========================================================================
.text$mn:00002A64
.text$mn:00002A64 ; Segment type: Pure code
.text$mn:00002A64 ; Segment permissions: Read/Execute
.text$mn:00002A64 _text$mn        segment para public 'CODE' use32
.text$mn:00002A64                 assume cs:_text$mn
.text$mn:00002A64                 ;org 2A64h
.text$mn:00002A64 ; COMDAT (pick any)
.text$mn:00002A64                 assume es:nothing, ss:nothing, ds:_data, fs:nothing, gs:nothing
.text$mn:00002A64
.text$mn:00002A64 ; =============== S U B R O U T I N E =======================================
.text$mn:00002A64
.text$mn:00002A64 ; Attributes: bp-based frame
.text$mn:00002A64
.text$mn:00002A64 ; protected: class std::vector<wchar_t const *, class std::allocator<wchar_t const *>> * __thiscall std::vector<class std::vector<wchar_t const *, class std::allocator<wchar_t const *>>, class std::allocator<class std::vector<wchar_t const *, class std::allocator<wchar_t const *>>>>::_Umove<class std::vector<wchar_t const *, class std::allocator<wchar_t const *>> *>(class std::vector<wchar_t const *, class std::allocator<wchar_t const *>> *, class std::vector<wchar_t const *, class std::allocator<wchar_t const *>> *, class std::vector<wchar_t const *, class std::allocator<wchar_t const *>> *)
.text$mn:00002A64                 public ??$_Umove@PAV?$vector@PB_WV?$allocator@PB_W@std@@@std@@@?$vector@V?$vector@PB_WV?$allocator@PB_W@std@@@std@@V?$allocator@V?$vector@PB_WV?$allocator@PB_W@std@@@std@@@2@@std@@IAEPAV?$vector@PB_WV?$allocator@PB_W@std@@@1@PAV21@00@Z
.text$mn:00002A64 ??$_Umove@PAV?$vector@PB_WV?$allocator@PB_W@std@@@std@@@?$vector@V?$vector@PB_WV?$allocator@PB_W@std@@@std@@V?$allocator@V?$vector@PB_WV?$allocator@PB_W@std@@@std@@@2@@std@@IAEPAV?$vector@PB_WV?$allocator@PB_W@std@@@1@PAV21@00@Z proc near
.text$mn:00002A64                                         ; CODE XREF: std::vector<std::vector<wchar_t const *,std::allocator<wchar_t const *>>,std::allocator<std::vector<wchar_t const *,std::allocator<wchar_t const *>>>>::_Reallocate(uint)+65p
.text$mn:00002A64
.text$mn:00002A64 var_8           = dword ptr -8
.text$mn:00002A64 var_1           = byte ptr -1
.text$mn:00002A64 arg_0           = dword ptr  8
.text$mn:00002A64 arg_4           = dword ptr  0Ch
.text$mn:00002A64 arg_8           = dword ptr  10h
.text$mn:00002A64
.text$mn:00002A64                 push    ebp
.text$mn:00002A65                 mov     ebp, esp
.text$mn:00002A67                 sub     esp, 8
.text$mn:00002A6A                 mov     [ebp+var_8], ecx
.text$mn:00002A6D                 lea     eax, [ebp+var_1]
.text$mn:00002A70                 push    eax
.text$mn:00002A71                 mov     ecx, [ebp+var_8]
.text$mn:00002A74                 call    ?_Getal@?$_Vector_alloc@$0A@U?$_Vec_base_types@V?$vector@PB_WV?$allocator@PB_W@std@@@std@@V?$allocator@V?$vector@PB_WV?$allocator@PB_W@std@@@std@@@2@@std@@@std@@QBE?AU?$_Wrap_alloc@V?$allocator@V?$vector@PB_WV?$allocator@PB_W@std@@@std@@@std@@@2@XZ ; std::_Vector_alloc<0,std::_Vec_base_types<std::vector<wchar_t const *,std::allocator<wchar_t const *>>,std::allocator<std::vector<wchar_t const *,std::allocator<wchar_t const *>>>>>::_Getal(void)
.text$mn:00002A79                 lea     ecx, [ebp+var_1]
.text$mn:00002A7C                 push    ecx
.text$mn:00002A7D                 mov     edx, [ebp+arg_8]
.text$mn:00002A80                 push    edx
.text$mn:00002A81                 mov     eax, [ebp+arg_4]
.text$mn:00002A84                 push    eax
.text$mn:00002A85                 mov     ecx, [ebp+arg_0]
.text$mn:00002A88                 push    ecx
.text$mn:00002A89                 call    ??$_Uninitialized_move@PAV?$vector@PB_WV?$allocator@PB_W@std@@@std@@PAV12@U?$_Wrap_alloc@V?$allocator@V?$vector@PB_WV?$allocator@PB_W@std@@@std@@@std@@@2@@std@@YAPAV?$vector@PB_WV?$allocator@PB_W@std@@@0@PAV10@00AAU?$_Wrap_alloc@V?$allocator@V?$vector@PB_WV?$allocator@PB_W@std@@@std@@@std@@@0@@Z ; std::_Uninitialized_move<std::vector<wchar_t const *,std::allocator<wchar_t const *>> *,std::vector<wchar_t const *,std::allocator<wchar_t const *>> *,std::_Wrap_alloc<std::allocator<std::vector<wchar_t const *,std::allocator<wchar_t const *>>>>>(std::vector<wchar_t const *,std::allocator<wchar_t const *>> *,std::vector<wchar_t const *,std::allocator<wchar_t const *>> *,std::vector<wchar_t const *,std::allocator<wchar_t const *>> *,std::_Wrap_alloc<std::allocator<std::vector<wchar_t const *,std::allocator<wchar_t const *>>>> &)
.text$mn:00002A8E                 add     esp, 10h
.text$mn:00002A91                 mov     esp, ebp
.text$mn:00002A93                 pop     ebp
.text$mn:00002A94                 retn    0Ch
.text$mn:00002A94 ??$_Umove@PAV?$vector@PB_WV?$allocator@PB_W@std@@@std@@@?$vector@V?$vector@PB_WV?$allocator@PB_W@std@@@std@@V?$allocator@V?$vector@PB_WV?$allocator@PB_W@std@@@std@@@2@@std@@IAEPAV?$vector@PB_WV?$allocator@PB_W@std@@@1@PAV21@00@Z endp
.text$mn:00002A94
.text$mn:00002A94 ; ---------------------------------------------------------------------------
.text$mn:00002A97                 align 4
.text$mn:00002A97 _text$mn        ends
.text$mn:00002A97
.text$mn:00002A98 ; ===========================================================================
.text$mn:00002A98
.text$mn:00002A98 ; Segment type: Pure code
.text$mn:00002A98 ; Segment permissions: Read/Execute
.text$mn:00002A98 _text$mn        segment para public 'CODE' use32
.text$mn:00002A98                 assume cs:_text$mn
.text$mn:00002A98                 ;org 2A98h
.text$mn:00002A98 ; COMDAT (pick any)
.text$mn:00002A98                 assume es:nothing, ss:nothing, ds:_data, fs:nothing, gs:nothing
.text$mn:00002A98
.text$mn:00002A98 ; =============== S U B R O U T I N E =======================================
.text$mn:00002A98
.text$mn:00002A98 ; Attributes: bp-based frame
.text$mn:00002A98
.text$mn:00002A98 ; wchar_t const * * __cdecl std::_Unchecked<wchar_t const * *>(wchar_t const * *)
.text$mn:00002A98                 public ??$_Unchecked@PAPB_W@std@@YAPAPB_WPAPB_W@Z
.text$mn:00002A98 ??$_Unchecked@PAPB_W@std@@YAPAPB_WPAPB_W@Z proc near
.text$mn:00002A98                                         ; CODE XREF: std::_Uninitialized_copy<std::_Vector_const_iterator<std::_Vector_val<std::_Simple_types<wchar_t const *>>>,wchar_t const * *,std::_Wrap_alloc<std::allocator<wchar_t const *>>>(std::_Vector_const_iterator<std::_Vector_val<std::_Simple_types<wchar_t const *>>>,std::_Vector_const_iterator<std::_Vector_val<std::_Simple_types<wchar_t const *>>>,wchar_t const * *,std::_Wrap_alloc<std::allocator<wchar_t const *>> &)+34p
.text$mn:00002A98                                         ; std::_Uninitialized_move<wchar_t const * *,wchar_t const * *,std::_Wrap_alloc<std::allocator<wchar_t const *>>>(wchar_t const * *,wchar_t const * *,wchar_t const * *,std::_Wrap_alloc<std::allocator<wchar_t const *>> &)+Bp ...
.text$mn:00002A98
.text$mn:00002A98 arg_0           = dword ptr  8
.text$mn:00002A98
.text$mn:00002A98                 push    ebp
.text$mn:00002A99                 mov     ebp, esp
.text$mn:00002A9B                 mov     eax, [ebp+arg_0]
.text$mn:00002A9E                 pop     ebp
.text$mn:00002A9F                 retn
.text$mn:00002A9F ??$_Unchecked@PAPB_W@std@@YAPAPB_WPAPB_W@Z endp
.text$mn:00002A9F
.text$mn:00002A9F _text$mn        ends
.text$mn:00002A9F
.text$mn:00002AA0 ; ===========================================================================
.text$mn:00002AA0
.text$mn:00002AA0 ; Segment type: Pure code
.text$mn:00002AA0 ; Segment permissions: Read/Execute
.text$mn:00002AA0 _text$mn        segment para public 'CODE' use32
.text$mn:00002AA0                 assume cs:_text$mn
.text$mn:00002AA0                 ;org 2AA0h
.text$mn:00002AA0 ; COMDAT (pick any)
.text$mn:00002AA0                 assume es:nothing, ss:nothing, ds:_data, fs:nothing, gs:nothing
.text$mn:00002AA0
.text$mn:00002AA0 ; =============== S U B R O U T I N E =======================================
.text$mn:00002AA0
.text$mn:00002AA0 ; Attributes: bp-based frame
.text$mn:00002AA0
.text$mn:00002AA0 ; struct FunctionValues * __cdecl std::_Unchecked<struct FunctionValues *>(struct FunctionValues *)
.text$mn:00002AA0                 public ??$_Unchecked@PAUFunctionValues@@@std@@YAPAUFunctionValues@@PAU1@@Z
.text$mn:00002AA0 ??$_Unchecked@PAUFunctionValues@@@std@@YAPAUFunctionValues@@PAU1@@Z proc near
.text$mn:00002AA0                                         ; CODE XREF: std::_Uninitialized_move<FunctionValues *,FunctionValues *,std::_Wrap_alloc<std::allocator<FunctionValues>>>(FunctionValues *,FunctionValues *,FunctionValues *,std::_Wrap_alloc<std::allocator<FunctionValues>> &)+Bp
.text$mn:00002AA0                                         ; std::_Uninitialized_move<FunctionValues *,FunctionValues *,std::_Wrap_alloc<std::allocator<FunctionValues>>>(FunctionValues *,FunctionValues *,FunctionValues *,std::_Wrap_alloc<std::allocator<FunctionValues>> &)+18p ...
.text$mn:00002AA0
.text$mn:00002AA0 arg_0           = dword ptr  8
.text$mn:00002AA0
.text$mn:00002AA0                 push    ebp
.text$mn:00002AA1                 mov     ebp, esp
.text$mn:00002AA3                 mov     eax, [ebp+arg_0]
.text$mn:00002AA6                 pop     ebp
.text$mn:00002AA7                 retn
.text$mn:00002AA7 ??$_Unchecked@PAUFunctionValues@@@std@@YAPAUFunctionValues@@PAU1@@Z endp
.text$mn:00002AA7
.text$mn:00002AA7 _text$mn        ends
.text$mn:00002AA7
.text$mn:00002AA8 ; ===========================================================================
.text$mn:00002AA8
.text$mn:00002AA8 ; Segment type: Pure code
.text$mn:00002AA8 ; Segment permissions: Read/Execute
.text$mn:00002AA8 _text$mn        segment para public 'CODE' use32
.text$mn:00002AA8                 assume cs:_text$mn
.text$mn:00002AA8                 ;org 2AA8h
.text$mn:00002AA8 ; COMDAT (pick any)
.text$mn:00002AA8                 assume es:nothing, ss:nothing, ds:_data, fs:nothing, gs:nothing
.text$mn:00002AA8
.text$mn:00002AA8 ; =============== S U B R O U T I N E =======================================
.text$mn:00002AA8
.text$mn:00002AA8 ; Attributes: bp-based frame
.text$mn:00002AA8
.text$mn:00002AA8 ; struct Token * __cdecl std::_Unchecked<struct Token *>(struct Token *)
.text$mn:00002AA8                 public ??$_Unchecked@PAUToken@@@std@@YAPAUToken@@PAU1@@Z
.text$mn:00002AA8 ??$_Unchecked@PAUToken@@@std@@YAPAUToken@@PAU1@@Z proc near
.text$mn:00002AA8                                         ; CODE XREF: std::_Uninitialized_move<Token *,Token *,std::_Wrap_alloc<std::allocator<Token>>>(Token *,Token *,Token *,std::_Wrap_alloc<std::allocator<Token>> &)+Bp
.text$mn:00002AA8                                         ; std::_Uninitialized_move<Token *,Token *,std::_Wrap_alloc<std::allocator<Token>>>(Token *,Token *,Token *,std::_Wrap_alloc<std::allocator<Token>> &)+18p ...
.text$mn:00002AA8
.text$mn:00002AA8 arg_0           = dword ptr  8
.text$mn:00002AA8
.text$mn:00002AA8                 push    ebp
.text$mn:00002AA9                 mov     ebp, esp
.text$mn:00002AAB                 mov     eax, [ebp+arg_0]
.text$mn:00002AAE                 pop     ebp
.text$mn:00002AAF                 retn
.text$mn:00002AAF ??$_Unchecked@PAUToken@@@std@@YAPAUToken@@PAU1@@Z endp
.text$mn:00002AAF
.text$mn:00002AAF _text$mn        ends
.text$mn:00002AAF
.text$mn:00002AB0 ; ===========================================================================
.text$mn:00002AB0
.text$mn:00002AB0 ; Segment type: Pure code
.text$mn:00002AB0 ; Segment permissions: Read/Execute
.text$mn:00002AB0 _text$mn        segment para public 'CODE' use32
.text$mn:00002AB0                 assume cs:_text$mn
.text$mn:00002AB0                 ;org 2AB0h
.text$mn:00002AB0 ; COMDAT (pick any)
.text$mn:00002AB0                 assume es:nothing, ss:nothing, ds:_data, fs:nothing, gs:nothing
.text$mn:00002AB0
.text$mn:00002AB0 ; =============== S U B R O U T I N E =======================================
.text$mn:00002AB0
.text$mn:00002AB0 ; Attributes: bp-based frame
.text$mn:00002AB0
.text$mn:00002AB0 ; class std::vector<wchar_t const *, class std::allocator<wchar_t const *>> * __cdecl std::_Unchecked<class std::vector<wchar_t const *, class std::allocator<wchar_t const *>> *>(class std::vector<wchar_t const *, class std::allocator<wchar_t const *>> *)
.text$mn:00002AB0                 public ??$_Unchecked@PAV?$vector@PB_WV?$allocator@PB_W@std@@@std@@@std@@YAPAV?$vector@PB_WV?$allocator@PB_W@std@@@0@PAV10@@Z
.text$mn:00002AB0 ??$_Unchecked@PAV?$vector@PB_WV?$allocator@PB_W@std@@@std@@@std@@YAPAV?$vector@PB_WV?$allocator@PB_W@std@@@0@PAV10@@Z proc near
.text$mn:00002AB0                                         ; CODE XREF: std::_Uninitialized_move<std::vector<wchar_t const *,std::allocator<wchar_t const *>> *,std::vector<wchar_t const *,std::allocator<wchar_t const *>> *,std::_Wrap_alloc<std::allocator<std::vector<wchar_t const *,std::allocator<wchar_t const *>>>>>(std::vector<wchar_t const *,std::allocator<wchar_t const *>> *,std::vector<wchar_t const *,std::allocator<wchar_t const *>> *,std::vector<wchar_t const *,std::allocator<wchar_t const *>> *,std::_Wrap_alloc<std::allocator<std::vector<wchar_t const *,std::allocator<wchar_t const *>>>> &)+Bp
.text$mn:00002AB0                                         ; std::_Uninitialized_move<std::vector<wchar_t const *,std::allocator<wchar_t const *>> *,std::vector<wchar_t const *,std::allocator<wchar_t const *>> *,std::_Wrap_alloc<std::allocator<std::vector<wchar_t const *,std::allocator<wchar_t const *>>>>>(std::vector<wchar_t const *,std::allocator<wchar_t const *>> *,std::vector<wchar_t const *,std::allocator<wchar_t const *>> *,std::vector<wchar_t const *,std::allocator<wchar_t const *>> *,std::_Wrap_alloc<std::allocator<std::vector<wchar_t const *,std::allocator<wchar_t const *>>>> &)+18p ...
.text$mn:00002AB0
.text$mn:00002AB0 arg_0           = dword ptr  8
.text$mn:00002AB0
.text$mn:00002AB0                 push    ebp
.text$mn:00002AB1                 mov     ebp, esp
.text$mn:00002AB3                 mov     eax, [ebp+arg_0]
.text$mn:00002AB6                 pop     ebp
.text$mn:00002AB7                 retn
.text$mn:00002AB7 ??$_Unchecked@PAV?$vector@PB_WV?$allocator@PB_W@std@@@std@@@std@@YAPAV?$vector@PB_WV?$allocator@PB_W@std@@@0@PAV10@@Z endp
.text$mn:00002AB7
.text$mn:00002AB7 _text$mn        ends
.text$mn:00002AB7
.text$mn:00002AB8 ; ===========================================================================
.text$mn:00002AB8
.text$mn:00002AB8 ; Segment type: Pure code
.text$mn:00002AB8 ; Segment permissions: Read/Execute
.text$mn:00002AB8 _text$mn        segment para public 'CODE' use32
.text$mn:00002AB8                 assume cs:_text$mn
.text$mn:00002AB8                 ;org 2AB8h
.text$mn:00002AB8 ; COMDAT (pick any)
.text$mn:00002AB8                 assume es:nothing, ss:nothing, ds:_data, fs:nothing, gs:nothing
.text$mn:00002AB8
.text$mn:00002AB8 ; =============== S U B R O U T I N E =======================================
.text$mn:00002AB8
.text$mn:00002AB8 ; Attributes: bp-based frame
.text$mn:00002AB8
.text$mn:00002AB8 ; wchar_t const * const * __cdecl std::_Unchecked<class std::_Vector_val<struct std::_Simple_types<wchar_t const *>>>(class std::_Vector_const_iterator<class std::_Vector_val<struct std::_Simple_types<wchar_t const *>>>)
.text$mn:00002AB8                 public ??$_Unchecked@V?$_Vector_val@U?$_Simple_types@PB_W@std@@@std@@@std@@YAPBQB_WV?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@PB_W@std@@@std@@@0@@Z
.text$mn:00002AB8 ??$_Unchecked@V?$_Vector_val@U?$_Simple_types@PB_W@std@@@std@@@std@@YAPBQB_WV?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@PB_W@std@@@std@@@0@@Z proc near
.text$mn:00002AB8                                         ; CODE XREF: std::_Uninitialized_copy<std::_Vector_const_iterator<std::_Vector_val<std::_Simple_types<wchar_t const *>>>,wchar_t const * *,std::_Wrap_alloc<std::allocator<wchar_t const *>>>(std::_Vector_const_iterator<std::_Vector_val<std::_Simple_types<wchar_t const *>>>,std::_Vector_const_iterator<std::_Vector_val<std::_Simple_types<wchar_t const *>>>,wchar_t const * *,std::_Wrap_alloc<std::allocator<wchar_t const *>> &)+5Fp
.text$mn:00002AB8                                         ; std::_Uninitialized_copy<std::_Vector_const_iterator<std::_Vector_val<std::_Simple_types<wchar_t const *>>>,wchar_t const * *,std::_Wrap_alloc<std::allocator<wchar_t const *>>>(std::_Vector_const_iterator<std::_Vector_val<std::_Simple_types<wchar_t const *>>>,std::_Vector_const_iterator<std::_Vector_val<std::_Simple_types<wchar_t const *>>>,wchar_t const * *,std::_Wrap_alloc<std::allocator<wchar_t const *>> &)+90p
.text$mn:00002AB8
.text$mn:00002AB8 var_10          = dword ptr -10h
.text$mn:00002AB8 var_C           = dword ptr -0Ch
.text$mn:00002AB8 var_4           = dword ptr -4
.text$mn:00002AB8 arg_0           = byte ptr  8
.text$mn:00002AB8
.text$mn:00002AB8                 push    ebp
.text$mn:00002AB9                 mov     ebp, esp
.text$mn:00002ABB                 push    0FFFFFFFFh
.text$mn:00002ABD                 push    offset __ehhandler$??$_Unchecked@V?$_Vector_val@U?$_Simple_types@PB_W@std@@@std@@@std@@YAPBQB_WV?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@PB_W@std@@@std@@@0@@Z
.text$mn:00002AC2                 mov     eax, large fs:0
.text$mn:00002AC8                 push    eax
.text$mn:00002AC9                 push    ecx
.text$mn:00002ACA                 mov     eax, dword ptr ds:___security_cookie
.text$mn:00002ACF                 xor     eax, ebp
.text$mn:00002AD1                 push    eax
.text$mn:00002AD2                 lea     eax, [ebp+var_C]
.text$mn:00002AD5                 mov     large fs:0, eax
.text$mn:00002ADB                 mov     [ebp+var_4], 0
.text$mn:00002AE2                 lea     ecx, [ebp+arg_0]
.text$mn:00002AE5                 call    ?_Unchecked@?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@PB_W@std@@@std@@@std@@QBEPBQB_WXZ ; std::_Vector_const_iterator<std::_Vector_val<std::_Simple_types<wchar_t const *>>>::_Unchecked(void)
.text$mn:00002AEA                 mov     [ebp+var_10], eax
.text$mn:00002AED                 mov     [ebp+var_4], 0FFFFFFFFh
.text$mn:00002AF4                 lea     ecx, [ebp+arg_0]
.text$mn:00002AF7                 call    ??1?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@PB_W@std@@@std@@@std@@QAE@XZ ; std::_Vector_const_iterator<std::_Vector_val<std::_Simple_types<wchar_t const *>>>::~_Vector_const_iterator<std::_Vector_val<std::_Simple_types<wchar_t const *>>>(void)
.text$mn:00002AFC                 mov     eax, [ebp+var_10]
.text$mn:00002AFF                 mov     ecx, [ebp+var_C]
.text$mn:00002B02                 mov     large fs:0, ecx
.text$mn:00002B09                 pop     ecx
.text$mn:00002B0A                 mov     esp, ebp
.text$mn:00002B0C                 pop     ebp
.text$mn:00002B0D                 retn
.text$mn:00002B0D ??$_Unchecked@V?$_Vector_val@U?$_Simple_types@PB_W@std@@@std@@@std@@YAPBQB_WV?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@PB_W@std@@@std@@@0@@Z endp
.text$mn:00002B0D
.text$mn:00002B0D ; ---------------------------------------------------------------------------
.text$mn:00002B0E                 align 10h
.text$mn:00002B0E _text$mn        ends
.text$mn:00002B0E
.text$x:00002B10 ; ===========================================================================
.text$x:00002B10
.text$x:00002B10 ; Segment type: Pure code
.text$x:00002B10 ; Segment permissions: Read/Execute
.text$x:00002B10 _text$x         segment para public 'CODE' use32
.text$x:00002B10                 assume cs:_text$x
.text$x:00002B10                 ;org 2B10h
.text$x:00002B10 ; COMDAT (pick associative to section at 2AB8)
.text$x:00002B10                 assume es:nothing, ss:nothing, ds:_data, fs:nothing, gs:nothing
.text$x:00002B10
.text$x:00002B10 ; =============== S U B R O U T I N E =======================================
.text$x:00002B10
.text$x:00002B10
.text$x:00002B10 __unwindfunclet$??$_Unchecked@V?$_Vector_val@U?$_Simple_types@PB_W@std@@@std@@@std@@YAPBQB_WV?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@PB_W@std@@@std@@@0@@Z$0 proc near
.text$x:00002B10                                         ; DATA XREF: .xdata$x:0000A290o
.text$x:00002B10                 lea     ecx, [ebp+8]
.text$x:00002B13                 jmp     ??1?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@PB_W@std@@@std@@@std@@QAE@XZ ; std::_Vector_const_iterator<std::_Vector_val<std::_Simple_types<wchar_t const *>>>::~_Vector_const_iterator<std::_Vector_val<std::_Simple_types<wchar_t const *>>>(void)
.text$x:00002B13 __unwindfunclet$??$_Unchecked@V?$_Vector_val@U?$_Simple_types@PB_W@std@@@std@@@std@@YAPBQB_WV?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@PB_W@std@@@std@@@0@@Z$0 endp
.text$x:00002B13
.text$x:00002B18
.text$x:00002B18 ; =============== S U B R O U T I N E =======================================
.text$x:00002B18
.text$x:00002B18
.text$x:00002B18 __ehhandler$??$_Unchecked@V?$_Vector_val@U?$_Simple_types@PB_W@std@@@std@@@std@@YAPBQB_WV?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@PB_W@std@@@std@@@0@@Z proc near
.text$x:00002B18                                         ; DATA XREF: std::_Unchecked<std::_Vector_val<std::_Simple_types<wchar_t const *>>>(std::_Vector_const_iterator<std::_Vector_val<std::_Simple_types<wchar_t const *>>>)+5o
.text$x:00002B18
.text$x:00002B18 arg_4           = dword ptr  8
.text$x:00002B18
.text$x:00002B18                 mov     edx, [esp+arg_4]
.text$x:00002B1C                 lea     eax, [edx+0Ch]
.text$x:00002B1F                 mov     ecx, [edx-8]
.text$x:00002B22                 xor     ecx, eax
.text$x:00002B24                 call    @__security_check_cookie@4 ; __security_check_cookie(x)
.text$x:00002B29                 mov     eax, offset __ehfuncinfo$??$_Unchecked@V?$_Vector_val@U?$_Simple_types@PB_W@std@@@std@@@std@@YAPBQB_WV?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@PB_W@std@@@std@@@0@@Z
.text$x:00002B2E                 jmp     ___CxxFrameHandler3
.text$x:00002B2E __ehhandler$??$_Unchecked@V?$_Vector_val@U?$_Simple_types@PB_W@std@@@std@@@std@@YAPBQB_WV?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@PB_W@std@@@std@@@0@@Z endp
.text$x:00002B2E
.text$x:00002B2E ; ---------------------------------------------------------------------------
.text$x:00002B33                 align 4
.text$x:00002B33 _text$x         ends
.text$x:00002B33
.text$mn:00002B34 ; ===========================================================================
.text$mn:00002B34
.text$mn:00002B34 ; Segment type: Pure code
.text$mn:00002B34 ; Segment permissions: Read/Execute
.text$mn:00002B34 _text$mn        segment para public 'CODE' use32
.text$mn:00002B34                 assume cs:_text$mn
.text$mn:00002B34                 ;org 2B34h
.text$mn:00002B34 ; COMDAT (pick any)
.text$mn:00002B34                 assume es:nothing, ss:nothing, ds:_data, fs:nothing, gs:nothing
.text$mn:00002B34
.text$mn:00002B34 ; =============== S U B R O U T I N E =======================================
.text$mn:00002B34
.text$mn:00002B34 ; Attributes: bp-based frame
.text$mn:00002B34
.text$mn:00002B34 ; int __cdecl std::_Uninit_copy<wchar_t const * const *,wchar_t const * *,std::_Wrap_alloc<std::allocator<wchar_t const *>>>(void *Src, int, void *Dst, int)
.text$mn:00002B34                 public ??$_Uninit_copy@PBQB_WPAPB_WU?$_Wrap_alloc@V?$allocator@PB_W@std@@@std@@@std@@YAPAPB_WPBQB_W0PAPB_WAAU?$_Wrap_alloc@V?$allocator@PB_W@std@@@0@@Z
.text$mn:00002B34 ??$_Uninit_copy@PBQB_WPAPB_WU?$_Wrap_alloc@V?$allocator@PB_W@std@@@std@@@std@@YAPAPB_WPBQB_W0PAPB_WAAU?$_Wrap_alloc@V?$allocator@PB_W@std@@@0@@Z proc near
.text$mn:00002B34                                         ; CODE XREF: std::_Uninitialized_copy<std::_Vector_const_iterator<std::_Vector_val<std::_Simple_types<wchar_t const *>>>,wchar_t const * *,std::_Wrap_alloc<std::allocator<wchar_t const *>>>(std::_Vector_const_iterator<std::_Vector_val<std::_Simple_types<wchar_t const *>>>,std::_Vector_const_iterator<std::_Vector_val<std::_Simple_types<wchar_t const *>>>,wchar_t const * *,std::_Wrap_alloc<std::allocator<wchar_t const *>> &)+9Fp
.text$mn:00002B34
.text$mn:00002B34 var_1           = byte ptr -1
.text$mn:00002B34 Src             = dword ptr  8
.text$mn:00002B34 arg_4           = dword ptr  0Ch
.text$mn:00002B34 Dst             = dword ptr  10h
.text$mn:00002B34 arg_C           = dword ptr  14h
.text$mn:00002B34
.text$mn:00002B34                 push    ebp
.text$mn:00002B35                 mov     ebp, esp
.text$mn:00002B37                 push    ecx
.text$mn:00002B38                 mov     eax, [ebp+Dst]
.text$mn:00002B3B                 push    eax
.text$mn:00002B3C                 mov     ecx, [ebp+Src]
.text$mn:00002B3F                 push    ecx
.text$mn:00002B40                 call    ??$_Ptr_cat@PB_WPB_W@std@@YA?AU_Scalar_ptr_iterator_tag@0@PBQB_WPAPB_W@Z ; std::_Ptr_cat<wchar_t const *,wchar_t const *>(wchar_t const * const *,wchar_t const * *)
.text$mn:00002B45                 add     esp, 8
.text$mn:00002B48                 mov     [ebp+var_1], al
.text$mn:00002B4B                 movzx   edx, [ebp+var_1]
.text$mn:00002B4F                 push    edx
.text$mn:00002B50                 mov     eax, [ebp+arg_C]
.text$mn:00002B53                 push    eax
.text$mn:00002B54                 mov     ecx, [ebp+Dst]
.text$mn:00002B57                 push    ecx             ; Dst
.text$mn:00002B58                 mov     edx, [ebp+arg_4]
.text$mn:00002B5B                 push    edx             ; int
.text$mn:00002B5C                 mov     eax, [ebp+Src]
.text$mn:00002B5F                 push    eax             ; Src
.text$mn:00002B60                 call    ??$_Uninit_copy@QB_WPB_W@std@@YAPAPB_WPBQB_W0PAPB_WAAU?$_Wrap_alloc@V?$allocator@PB_W@std@@@0@U_Scalar_ptr_iterator_tag@0@@Z ; std::_Uninit_copy<wchar_t const * const,wchar_t const *>(wchar_t const * const *,wchar_t const * const *,wchar_t const * *,std::_Wrap_alloc<std::allocator<wchar_t const *>> &,std::_Scalar_ptr_iterator_tag)
.text$mn:00002B65                 add     esp, 14h
.text$mn:00002B68                 mov     esp, ebp
.text$mn:00002B6A                 pop     ebp
.text$mn:00002B6B                 retn
.text$mn:00002B6B ??$_Uninit_copy@PBQB_WPAPB_WU?$_Wrap_alloc@V?$allocator@PB_W@std@@@std@@@std@@YAPAPB_WPBQB_W0PAPB_WAAU?$_Wrap_alloc@V?$allocator@PB_W@std@@@0@@Z endp
.text$mn:00002B6B
.text$mn:00002B6B _text$mn        ends
.text$mn:00002B6B
.text$mn:00002B6C ; ===========================================================================
.text$mn:00002B6C
.text$mn:00002B6C ; Segment type: Pure code
.text$mn:00002B6C ; Segment permissions: Read/Execute
.text$mn:00002B6C _text$mn        segment para public 'CODE' use32
.text$mn:00002B6C                 assume cs:_text$mn
.text$mn:00002B6C                 ;org 2B6Ch
.text$mn:00002B6C ; COMDAT (pick any)
.text$mn:00002B6C                 assume es:nothing, ss:nothing, ds:_data, fs:nothing, gs:nothing
.text$mn:00002B6C
.text$mn:00002B6C ; =============== S U B R O U T I N E =======================================
.text$mn:00002B6C
.text$mn:00002B6C ; Attributes: bp-based frame
.text$mn:00002B6C
.text$mn:00002B6C ; int __cdecl std::_Uninit_copy<wchar_t const * const,wchar_t const *>(void *Src, int, void *Dst)
.text$mn:00002B6C                 public ??$_Uninit_copy@QB_WPB_W@std@@YAPAPB_WPBQB_W0PAPB_WAAU?$_Wrap_alloc@V?$allocator@PB_W@std@@@0@U_Scalar_ptr_iterator_tag@0@@Z
.text$mn:00002B6C ??$_Uninit_copy@QB_WPB_W@std@@YAPAPB_WPBQB_W0PAPB_WAAU?$_Wrap_alloc@V?$allocator@PB_W@std@@@0@U_Scalar_ptr_iterator_tag@0@@Z proc near
.text$mn:00002B6C                                         ; CODE XREF: std::_Uninit_copy<wchar_t const * const *,wchar_t const * *,std::_Wrap_alloc<std::allocator<wchar_t const *>>>(wchar_t const * const *,wchar_t const * const *,wchar_t const * *,std::_Wrap_alloc<std::allocator<wchar_t const *>> &)+2Cp
.text$mn:00002B6C
.text$mn:00002B6C var_4           = dword ptr -4
.text$mn:00002B6C Src             = dword ptr  8
.text$mn:00002B6C arg_4           = dword ptr  0Ch
.text$mn:00002B6C Dst             = dword ptr  10h
.text$mn:00002B6C
.text$mn:00002B6C                 push    ebp
.text$mn:00002B6D                 mov     ebp, esp
.text$mn:00002B6F                 push    ecx
.text$mn:00002B70                 push    192h            ; unsigned int
.text$mn:00002B75                 push    offset ??_C@_1IO@LKIDJAMC@?$AAC?$AA?3?$AA?2?$AAP?$AAr?$AAo?$AAg?$AAr?$AAa?$AAm?$AA?5?$AAF?$AAi?$AAl?$AAe?$AAs?$AA?5?$AA?$CI?$AAx?$AA8?$AA6?$AA?$CJ?$AA?2?$AAM?$AAi?$AAc?$AAr?$AAo?$AAs?$AAo?$AAf?$AAt@ ; "C:\\Program Files (x86)\\Microsoft Visu"...
.text$mn:00002B7A                 mov     eax, [ebp+arg_4]
.text$mn:00002B7D                 push    eax             ; int
.text$mn:00002B7E                 mov     ecx, [ebp+Src]
.text$mn:00002B81                 push    ecx             ; int
.text$mn:00002B82                 call    ??$_Debug_range@PBQB_W@std@@YAXPBQB_W0PB_WI@Z ; std::_Debug_range<wchar_t const * const *>(wchar_t const * const *,wchar_t const * const *,wchar_t const *,uint)
.text$mn:00002B87                 add     esp, 10h
.text$mn:00002B8A                 push    193h            ; unsigned int
.text$mn:00002B8F                 push    offset ??_C@_1IO@LKIDJAMC@?$AAC?$AA?3?$AA?2?$AAP?$AAr?$AAo?$AAg?$AAr?$AAa?$AAm?$AA?5?$AAF?$AAi?$AAl?$AAe?$AAs?$AA?5?$AA?$CI?$AAx?$AA8?$AA6?$AA?$CJ?$AA?2?$AAM?$AAi?$AAc?$AAr?$AAo?$AAs?$AAo?$AAf?$AAt@ ; "C:\\Program Files (x86)\\Microsoft Visu"...
.text$mn:00002B94                 mov     edx, [ebp+Dst]
.text$mn:00002B97                 push    edx             ; int
.text$mn:00002B98                 call    ??$_Debug_pointer@PB_W@std@@YAXPAPB_WPB_WI@Z ; std::_Debug_pointer<wchar_t const *>(wchar_t const * *,wchar_t const *,uint)
.text$mn:00002B9D                 add     esp, 0Ch
.text$mn:00002BA0                 mov     eax, [ebp+arg_4]
.text$mn:00002BA3                 sub     eax, [ebp+Src]
.text$mn:00002BA6                 sar     eax, 2
.text$mn:00002BA9                 mov     [ebp+var_4], eax
.text$mn:00002BAC                 mov     ecx, [ebp+var_4]
.text$mn:00002BAF                 shl     ecx, 2
.text$mn:00002BB2                 push    ecx             ; Size
.text$mn:00002BB3                 mov     edx, [ebp+Src]
.text$mn:00002BB6                 push    edx             ; Src
.text$mn:00002BB7                 mov     eax, [ebp+Dst]
.text$mn:00002BBA                 push    eax             ; Dst
.text$mn:00002BBB                 call    _memmove
.text$mn:00002BC0                 add     esp, 0Ch
.text$mn:00002BC3                 mov     ecx, [ebp+var_4]
.text$mn:00002BC6                 lea     eax, [eax+ecx*4]
.text$mn:00002BC9                 mov     esp, ebp
.text$mn:00002BCB                 pop     ebp
.text$mn:00002BCC                 retn
.text$mn:00002BCC ??$_Uninit_copy@QB_WPB_W@std@@YAPAPB_WPBQB_W0PAPB_WAAU?$_Wrap_alloc@V?$allocator@PB_W@std@@@0@U_Scalar_ptr_iterator_tag@0@@Z endp
.text$mn:00002BCC
.text$mn:00002BCC ; ---------------------------------------------------------------------------
.text$mn:00002BCD                 align 10h
.text$mn:00002BCD _text$mn        ends
.text$mn:00002BCD
.text$mn:00002BD0 ; ===========================================================================
.text$mn:00002BD0
.text$mn:00002BD0 ; Segment type: Pure code
.text$mn:00002BD0 ; Segment permissions: Read/Execute
.text$mn:00002BD0 _text$mn        segment para public 'CODE' use32
.text$mn:00002BD0                 assume cs:_text$mn
.text$mn:00002BD0                 ;org 2BD0h
.text$mn:00002BD0 ; COMDAT (pick any)
.text$mn:00002BD0                 assume es:nothing, ss:nothing, ds:_data, fs:nothing, gs:nothing
.text$mn:00002BD0
.text$mn:00002BD0 ; =============== S U B R O U T I N E =======================================
.text$mn:00002BD0
.text$mn:00002BD0 ; Attributes: bp-based frame
.text$mn:00002BD0
.text$mn:00002BD0 ; int __cdecl std::_Uninit_move<wchar_t const * *,wchar_t const * *,std::_Wrap_alloc<std::allocator<wchar_t const *>>>(void *Src, int, void *Dst, int)
.text$mn:00002BD0                 public ??$_Uninit_move@PAPB_WPAPB_WU?$_Wrap_alloc@V?$allocator@PB_W@std@@@std@@@std@@YAPAPB_WPAPB_W00AAU?$_Wrap_alloc@V?$allocator@PB_W@std@@@0@@Z
.text$mn:00002BD0 ??$_Uninit_move@PAPB_WPAPB_WU?$_Wrap_alloc@V?$allocator@PB_W@std@@@std@@@std@@YAPAPB_WPAPB_W00AAU?$_Wrap_alloc@V?$allocator@PB_W@std@@@0@@Z proc near
.text$mn:00002BD0                                         ; CODE XREF: std::_Uninitialized_move<wchar_t const * *,wchar_t const * *,std::_Wrap_alloc<std::allocator<wchar_t const *>>>(wchar_t const * *,wchar_t const * *,wchar_t const * *,std::_Wrap_alloc<std::allocator<wchar_t const *>> &)+2Ep
.text$mn:00002BD0
.text$mn:00002BD0 var_1           = byte ptr -1
.text$mn:00002BD0 Src             = dword ptr  8
.text$mn:00002BD0 arg_4           = dword ptr  0Ch
.text$mn:00002BD0 Dst             = dword ptr  10h
.text$mn:00002BD0 arg_C           = dword ptr  14h
.text$mn:00002BD0
.text$mn:00002BD0                 push    ebp
.text$mn:00002BD1                 mov     ebp, esp
.text$mn:00002BD3                 push    ecx
.text$mn:00002BD4                 mov     eax, [ebp+Dst]
.text$mn:00002BD7                 push    eax
.text$mn:00002BD8                 mov     ecx, [ebp+Src]
.text$mn:00002BDB                 push    ecx
.text$mn:00002BDC                 call    ??$_Ptr_cat@PB_WPB_W@std@@YA?AU_Scalar_ptr_iterator_tag@0@PAPB_W0@Z ; std::_Ptr_cat<wchar_t const *,wchar_t const *>(wchar_t const * *,wchar_t const * *)
.text$mn:00002BE1                 add     esp, 8
.text$mn:00002BE4                 mov     [ebp+var_1], al
.text$mn:00002BE7                 movzx   edx, [ebp+var_1]
.text$mn:00002BEB                 push    edx
.text$mn:00002BEC                 mov     eax, [ebp+Src]
.text$mn:00002BEF                 push    eax
.text$mn:00002BF0                 call    ??$_Val_type@PAPB_W@std@@YAPAPB_WPAPB_W@Z ; std::_Val_type<wchar_t const * *>(wchar_t const * *)
.text$mn:00002BF5                 add     esp, 4
.text$mn:00002BF8                 push    eax
.text$mn:00002BF9                 mov     ecx, [ebp+arg_C]
.text$mn:00002BFC                 push    ecx
.text$mn:00002BFD                 mov     edx, [ebp+Dst]
.text$mn:00002C00                 push    edx             ; Dst
.text$mn:00002C01                 mov     eax, [ebp+arg_4]
.text$mn:00002C04                 push    eax             ; int
.text$mn:00002C05                 mov     ecx, [ebp+Src]
.text$mn:00002C08                 push    ecx             ; Src
.text$mn:00002C09                 call    ??$_Uninit_move@PB_WPB_WPB_W@std@@YAPAPB_WPAPB_W00AAU?$_Wrap_alloc@V?$allocator@PB_W@std@@@0@0U_Scalar_ptr_iterator_tag@0@@Z ; std::_Uninit_move<wchar_t const *,wchar_t const *,wchar_t const *>(wchar_t const * *,wchar_t const * *,wchar_t const * *,std::_Wrap_alloc<std::allocator<wchar_t const *>> &,wchar_t const * *,std::_Scalar_ptr_iterator_tag)
.text$mn:00002C0E                 add     esp, 18h
.text$mn:00002C11                 mov     esp, ebp
.text$mn:00002C13                 pop     ebp
.text$mn:00002C14                 retn
.text$mn:00002C14 ??$_Uninit_move@PAPB_WPAPB_WU?$_Wrap_alloc@V?$allocator@PB_W@std@@@std@@@std@@YAPAPB_WPAPB_W00AAU?$_Wrap_alloc@V?$allocator@PB_W@std@@@0@@Z endp
.text$mn:00002C14
.text$mn:00002C14 ; ---------------------------------------------------------------------------
.text$mn:00002C15                 align 4
.text$mn:00002C15 _text$mn        ends
.text$mn:00002C15
.text$mn:00002C18 ; ===========================================================================
.text$mn:00002C18
.text$mn:00002C18 ; Segment type: Pure code
.text$mn:00002C18 ; Segment permissions: Read/Execute
.text$mn:00002C18 _text$mn        segment para public 'CODE' use32
.text$mn:00002C18                 assume cs:_text$mn
.text$mn:00002C18                 ;org 2C18h
.text$mn:00002C18 ; COMDAT (pick any)
.text$mn:00002C18                 assume es:nothing, ss:nothing, ds:_data, fs:nothing, gs:nothing
.text$mn:00002C18
.text$mn:00002C18 ; =============== S U B R O U T I N E =======================================
.text$mn:00002C18
.text$mn:00002C18 ; Attributes: bp-based frame
.text$mn:00002C18
.text$mn:00002C18 ; int __cdecl std::_Uninit_move<FunctionValues *,FunctionValues *,std::_Wrap_alloc<std::allocator<FunctionValues>>>(int, int, void *, int)
.text$mn:00002C18                 public ??$_Uninit_move@PAUFunctionValues@@PAU1@U?$_Wrap_alloc@V?$allocator@UFunctionValues@@@std@@@std@@@std@@YAPAUFunctionValues@@PAU1@00AAU?$_Wrap_alloc@V?$allocator@UFunctionValues@@@std@@@0@@Z
.text$mn:00002C18 ??$_Uninit_move@PAUFunctionValues@@PAU1@U?$_Wrap_alloc@V?$allocator@UFunctionValues@@@std@@@std@@@std@@YAPAUFunctionValues@@PAU1@00AAU?$_Wrap_alloc@V?$allocator@UFunctionValues@@@std@@@0@@Z proc near
.text$mn:00002C18                                         ; CODE XREF: std::_Uninitialized_move<FunctionValues *,FunctionValues *,std::_Wrap_alloc<std::allocator<FunctionValues>>>(FunctionValues *,FunctionValues *,FunctionValues *,std::_Wrap_alloc<std::allocator<FunctionValues>> &)+2Ep
.text$mn:00002C18
.text$mn:00002C18 var_1           = byte ptr -1
.text$mn:00002C18 arg_0           = dword ptr  8
.text$mn:00002C18 arg_4           = dword ptr  0Ch
.text$mn:00002C18 arg_8           = dword ptr  10h
.text$mn:00002C18 arg_C           = dword ptr  14h
.text$mn:00002C18
.text$mn:00002C18                 push    ebp
.text$mn:00002C19                 mov     ebp, esp
.text$mn:00002C1B                 push    ecx
.text$mn:00002C1C                 mov     eax, [ebp+arg_8]
.text$mn:00002C1F                 push    eax
.text$mn:00002C20                 mov     ecx, [ebp+arg_0]
.text$mn:00002C23                 push    ecx
.text$mn:00002C24                 call    ??$_Ptr_cat@UFunctionValues@@U1@@std@@YA?AU_Nonscalar_ptr_iterator_tag@0@PAUFunctionValues@@0@Z ; std::_Ptr_cat<FunctionValues,FunctionValues>(FunctionValues *,FunctionValues *)
.text$mn:00002C29                 add     esp, 8
.text$mn:00002C2C                 mov     [ebp+var_1], al
.text$mn:00002C2F                 movzx   edx, [ebp+var_1]
.text$mn:00002C33                 push    edx
.text$mn:00002C34                 mov     eax, [ebp+arg_0]
.text$mn:00002C37                 push    eax
.text$mn:00002C38                 call    ??$_Val_type@PAUFunctionValues@@@std@@YAPAUFunctionValues@@PAU1@@Z ; std::_Val_type<FunctionValues *>(FunctionValues *)
.text$mn:00002C3D                 add     esp, 4
.text$mn:00002C40                 push    eax
.text$mn:00002C41                 mov     ecx, [ebp+arg_C]
.text$mn:00002C44                 push    ecx             ; int
.text$mn:00002C45                 mov     edx, [ebp+arg_8]
.text$mn:00002C48                 push    edx             ; void *
.text$mn:00002C49                 mov     eax, [ebp+arg_4]
.text$mn:00002C4C                 push    eax             ; int
.text$mn:00002C4D                 mov     ecx, [ebp+arg_0]
.text$mn:00002C50                 push    ecx             ; int
.text$mn:00002C51                 call    ??$_Uninit_move@PAUFunctionValues@@PAU1@V?$allocator@UFunctionValues@@@std@@U1@@std@@YAPAUFunctionValues@@PAU1@00AAU?$_Wrap_alloc@V?$allocator@UFunctionValues@@@std@@@0@0U_Nonscalar_ptr_iterator_tag@0@@Z ; std::_Uninit_move<FunctionValues *,FunctionValues *,std::allocator<FunctionValues>,FunctionValues>(FunctionValues *,FunctionValues *,FunctionValues *,std::_Wrap_alloc<std::allocator<FunctionValues>> &,FunctionValues *,std::_Nonscalar_ptr_iterator_tag)
.text$mn:00002C56                 add     esp, 18h
.text$mn:00002C59                 mov     esp, ebp
.text$mn:00002C5B                 pop     ebp
.text$mn:00002C5C                 retn
.text$mn:00002C5C ??$_Uninit_move@PAUFunctionValues@@PAU1@U?$_Wrap_alloc@V?$allocator@UFunctionValues@@@std@@@std@@@std@@YAPAUFunctionValues@@PAU1@00AAU?$_Wrap_alloc@V?$allocator@UFunctionValues@@@std@@@0@@Z endp
.text$mn:00002C5C
.text$mn:00002C5C ; ---------------------------------------------------------------------------
.text$mn:00002C5D                 align 10h
.text$mn:00002C5D _text$mn        ends
.text$mn:00002C5D
.text$mn:00002C60 ; ===========================================================================
.text$mn:00002C60
.text$mn:00002C60 ; Segment type: Pure code
.text$mn:00002C60 ; Segment permissions: Read/Execute
.text$mn:00002C60 _text$mn        segment para public 'CODE' use32
.text$mn:00002C60                 assume cs:_text$mn
.text$mn:00002C60                 ;org 2C60h
.text$mn:00002C60 ; COMDAT (pick any)
.text$mn:00002C60                 assume es:nothing, ss:nothing, ds:_data, fs:nothing, gs:nothing
.text$mn:00002C60
.text$mn:00002C60 ; =============== S U B R O U T I N E =======================================
.text$mn:00002C60
.text$mn:00002C60 ; Attributes: bp-based frame
.text$mn:00002C60
.text$mn:00002C60 ; int __cdecl std::_Uninit_move<FunctionValues *,FunctionValues *,std::allocator<FunctionValues>,FunctionValues>(int, int, void *, int)
.text$mn:00002C60                 public ??$_Uninit_move@PAUFunctionValues@@PAU1@V?$allocator@UFunctionValues@@@std@@U1@@std@@YAPAUFunctionValues@@PAU1@00AAU?$_Wrap_alloc@V?$allocator@UFunctionValues@@@std@@@0@0U_Nonscalar_ptr_iterator_tag@0@@Z
.text$mn:00002C60 ??$_Uninit_move@PAUFunctionValues@@PAU1@V?$allocator@UFunctionValues@@@std@@U1@@std@@YAPAUFunctionValues@@PAU1@00AAU?$_Wrap_alloc@V?$allocator@UFunctionValues@@@std@@@0@0U_Nonscalar_ptr_iterator_tag@0@@Z proc near
.text$mn:00002C60                                         ; CODE XREF: std::_Uninit_move<FunctionValues *,FunctionValues *,std::_Wrap_alloc<std::allocator<FunctionValues>>>(FunctionValues *,FunctionValues *,FunctionValues *,std::_Wrap_alloc<std::allocator<FunctionValues>> &)+39p
.text$mn:00002C60
.text$mn:00002C60 var_14          = dword ptr -14h
.text$mn:00002C60 var_10          = dword ptr -10h
.text$mn:00002C60 var_C           = dword ptr -0Ch
.text$mn:00002C60 var_4           = dword ptr -4
.text$mn:00002C60 arg_0           = dword ptr  8
.text$mn:00002C60 arg_4           = dword ptr  0Ch
.text$mn:00002C60 arg_8           = dword ptr  10h
.text$mn:00002C60 arg_C           = dword ptr  14h
.text$mn:00002C60
.text$mn:00002C60 ; FUNCTION CHUNK AT .text$mn:00002D27 SIZE 00000009 BYTES
.text$mn:00002C60 ; FUNCTION CHUNK AT .text$mn:00002D37 SIZE 00000015 BYTES
.text$mn:00002C60
.text$mn:00002C60                 push    ebp
.text$mn:00002C61                 mov     ebp, esp
.text$mn:00002C63                 push    0FFFFFFFFh
.text$mn:00002C65                 push    offset __ehhandler$??$_Uninit_move@PAUFunctionValues@@PAU1@V?$allocator@UFunctionValues@@@std@@U1@@std@@YAPAUFunctionValues@@PAU1@00AAU?$_Wrap_alloc@V?$allocator@UFunctionValues@@@std@@@0@0U_Nonscalar_ptr_iterator_tag@0@@Z
.text$mn:00002C6A                 mov     eax, large fs:0
.text$mn:00002C70                 push    eax
.text$mn:00002C71                 push    ecx
.text$mn:00002C72                 push    ecx
.text$mn:00002C73                 push    ebx
.text$mn:00002C74                 push    esi
.text$mn:00002C75                 push    edi
.text$mn:00002C76                 mov     eax, dword ptr ds:___security_cookie
.text$mn:00002C7B                 xor     eax, ebp
.text$mn:00002C7D                 push    eax
.text$mn:00002C7E                 lea     eax, [ebp+var_C]
.text$mn:00002C81                 mov     large fs:0, eax
.text$mn:00002C87                 mov     [ebp+var_10], esp
.text$mn:00002C8A                 push    1B6h            ; unsigned int
.text$mn:00002C8F                 push    offset ??_C@_1IO@LKIDJAMC@?$AAC?$AA?3?$AA?2?$AAP?$AAr?$AAo?$AAg?$AAr?$AAa?$AAm?$AA?5?$AAF?$AAi?$AAl?$AAe?$AAs?$AA?5?$AA?$CI?$AAx?$AA8?$AA6?$AA?$CJ?$AA?2?$AAM?$AAi?$AAc?$AAr?$AAo?$AAs?$AAo?$AAf?$AAt@ ; "C:\\Program Files (x86)\\Microsoft Visu"...
.text$mn:00002C94                 mov     eax, [ebp+arg_4]
.text$mn:00002C97                 push    eax             ; int
.text$mn:00002C98                 mov     ecx, [ebp+arg_0]
.text$mn:00002C9B                 push    ecx             ; int
.text$mn:00002C9C                 call    ??$_Debug_range@PAUFunctionValues@@@std@@YAXPAUFunctionValues@@0PB_WI@Z ; std::_Debug_range<FunctionValues *>(FunctionValues *,FunctionValues *,wchar_t const *,uint)
.text$mn:00002CA1                 add     esp, 10h
.text$mn:00002CA4                 push    1B7h            ; unsigned int
.text$mn:00002CA9                 push    offset ??_C@_1IO@LKIDJAMC@?$AAC?$AA?3?$AA?2?$AAP?$AAr?$AAo?$AAg?$AAr?$AAa?$AAm?$AA?5?$AAF?$AAi?$AAl?$AAe?$AAs?$AA?5?$AA?$CI?$AAx?$AA8?$AA6?$AA?$CJ?$AA?2?$AAM?$AAi?$AAc?$AAr?$AAo?$AAs?$AAo?$AAf?$AAt@ ; "C:\\Program Files (x86)\\Microsoft Visu"...
.text$mn:00002CAE                 mov     edx, [ebp+arg_8]
.text$mn:00002CB1                 push    edx             ; int
.text$mn:00002CB2                 call    ??$_Debug_pointer@UFunctionValues@@@std@@YAXPAUFunctionValues@@PB_WI@Z ; std::_Debug_pointer<FunctionValues>(FunctionValues *,wchar_t const *,uint)
.text$mn:00002CB7                 add     esp, 0Ch
.text$mn:00002CBA                 mov     eax, [ebp+arg_8]
.text$mn:00002CBD                 mov     [ebp+var_14], eax
.text$mn:00002CC0                 mov     [ebp+var_4], 0
.text$mn:00002CC7                 jmp     short loc_2CDB
.text$mn:00002CC9 ; ---------------------------------------------------------------------------
.text$mn:00002CC9
.text$mn:00002CC9 loc_2CC9:                               ; CODE XREF: std::_Uninit_move<FunctionValues *,FunctionValues *,std::allocator<FunctionValues>,FunctionValues>(FunctionValues *,FunctionValues *,FunctionValues *,std::_Wrap_alloc<std::allocator<FunctionValues>> &,FunctionValues *,std::_Nonscalar_ptr_iterator_tag)+93j
.text$mn:00002CC9                 mov     ecx, [ebp+arg_8]
.text$mn:00002CCC                 add     ecx, 10h
.text$mn:00002CCF                 mov     [ebp+arg_8], ecx
.text$mn:00002CD2                 mov     edx, [ebp+arg_0]
.text$mn:00002CD5                 add     edx, 10h
.text$mn:00002CD8                 mov     [ebp+arg_0], edx
.text$mn:00002CDB
.text$mn:00002CDB loc_2CDB:                               ; CODE XREF: std::_Uninit_move<FunctionValues *,FunctionValues *,std::allocator<FunctionValues>,FunctionValues>(FunctionValues *,FunctionValues *,FunctionValues *,std::_Wrap_alloc<std::allocator<FunctionValues>> &,FunctionValues *,std::_Nonscalar_ptr_iterator_tag)+67j
.text$mn:00002CDB                 mov     eax, [ebp+arg_0]
.text$mn:00002CDE                 cmp     eax, [ebp+arg_4]
.text$mn:00002CE1                 jz      short loc_2CF5
.text$mn:00002CE3                 mov     ecx, [ebp+arg_0]
.text$mn:00002CE6                 push    ecx             ; int
.text$mn:00002CE7                 mov     edx, [ebp+arg_8]
.text$mn:00002CEA                 push    edx             ; void *
.text$mn:00002CEB                 mov     ecx, [ebp+arg_C]
.text$mn:00002CEE                 call    ??$construct@UFunctionValues@@U1@@?$_Wrap_alloc@V?$allocator@UFunctionValues@@@std@@@std@@QAEXPAUFunctionValues@@$$QAU2@@Z ; std::_Wrap_alloc<std::allocator<FunctionValues>>::construct<FunctionValues,FunctionValues>(FunctionValues *,FunctionValues &&)
.text$mn:00002CF3                 jmp     short loc_2CC9
.text$mn:00002CF5 ; ---------------------------------------------------------------------------
.text$mn:00002CF5
.text$mn:00002CF5 loc_2CF5:                               ; CODE XREF: std::_Uninit_move<FunctionValues *,FunctionValues *,std::allocator<FunctionValues>,FunctionValues>(FunctionValues *,FunctionValues *,FunctionValues *,std::_Wrap_alloc<std::allocator<FunctionValues>> &,FunctionValues *,std::_Nonscalar_ptr_iterator_tag)+81j
.text$mn:00002CF5                 jmp     short loc_2D27
.text$mn:00002CF5 ??$_Uninit_move@PAUFunctionValues@@PAU1@V?$allocator@UFunctionValues@@@std@@U1@@std@@YAPAUFunctionValues@@PAU1@00AAU?$_Wrap_alloc@V?$allocator@UFunctionValues@@@std@@@0@0U_Nonscalar_ptr_iterator_tag@0@@Z endp
.text$mn:00002CF5
.text$mn:00002CF7
.text$mn:00002CF7 ; =============== S U B R O U T I N E =======================================
.text$mn:00002CF7
.text$mn:00002CF7 ; Attributes: noreturn
.text$mn:00002CF7
.text$mn:00002CF7 __catch$??$_Uninit_move@PAUFunctionValues@@PAU1@V?$allocator@UFunctionValues@@@std@@U1@@std@@YAPAUFunctionValues@@PAU1@00AAU?$_Wrap_alloc@V?$allocator@UFunctionValues@@@std@@@0@0U_Nonscalar_ptr_iterator_tag@0@@Z$0 proc near
.text$mn:00002CF7                                         ; DATA XREF: .xdata$x:0000A1FCo
.text$mn:00002CF7                 jmp     short loc_2D02
.text$mn:00002CF9 ; ---------------------------------------------------------------------------
.text$mn:00002CF9
.text$mn:00002CF9 loc_2CF9:                               ; CODE XREF: __catch$??$_Uninit_move@PAUFunctionValues@@PAU1@V?$allocator@UFunctionValues@@@std@@U1@@std@@YAPAUFunctionValues@@PAU1@00AAU?$_Wrap_alloc@V?$allocator@UFunctionValues@@@std@@@0@0U_Nonscalar_ptr_iterator_tag@0@@Z$0+1Fj
.text$mn:00002CF9                 mov     eax, [ebp-14h]
.text$mn:00002CFC                 add     eax, 10h
.text$mn:00002CFF                 mov     [ebp-14h], eax
.text$mn:00002D02
.text$mn:00002D02 loc_2D02:                               ; CODE XREF: __catch$??$_Uninit_move@PAUFunctionValues@@PAU1@V?$allocator@UFunctionValues@@@std@@U1@@std@@YAPAUFunctionValues@@PAU1@00AAU?$_Wrap_alloc@V?$allocator@UFunctionValues@@@std@@@0@0U_Nonscalar_ptr_iterator_tag@0@@Z$0j
.text$mn:00002D02                 mov     ecx, [ebp-14h]
.text$mn:00002D05                 cmp     ecx, [ebp+10h]
.text$mn:00002D08                 jz      short loc_2D18
.text$mn:00002D0A                 mov     edx, [ebp-14h]
.text$mn:00002D0D                 push    edx
.text$mn:00002D0E                 mov     ecx, [ebp+14h]
.text$mn:00002D11                 call    ??$destroy@UFunctionValues@@@?$_Wrap_alloc@V?$allocator@UFunctionValues@@@std@@@std@@QAEXPAUFunctionValues@@@Z ; std::_Wrap_alloc<std::allocator<FunctionValues>>::destroy<FunctionValues>(FunctionValues *)
.text$mn:00002D16                 jmp     short loc_2CF9
.text$mn:00002D18 ; ---------------------------------------------------------------------------
.text$mn:00002D18
.text$mn:00002D18 loc_2D18:                               ; CODE XREF: __catch$??$_Uninit_move@PAUFunctionValues@@PAU1@V?$allocator@UFunctionValues@@@std@@U1@@std@@YAPAUFunctionValues@@PAU1@00AAU?$_Wrap_alloc@V?$allocator@UFunctionValues@@@std@@@0@0U_Nonscalar_ptr_iterator_tag@0@@Z$0+11j
.text$mn:00002D18                 push    0
.text$mn:00002D1A                 push    0
.text$mn:00002D1C                 call    __CxxThrowException@8 ; _CxxThrowException(x,x)
.text$mn:00002D1C __catch$??$_Uninit_move@PAUFunctionValues@@PAU1@V?$allocator@UFunctionValues@@@std@@U1@@std@@YAPAUFunctionValues@@PAU1@00AAU?$_Wrap_alloc@V?$allocator@UFunctionValues@@@std@@@0@0U_Nonscalar_ptr_iterator_tag@0@@Z$0 endp
.text$mn:00002D1C
.text$mn:00002D21 ; ---------------------------------------------------------------------------
.text$mn:00002D21                 mov     eax, offset $LN13_1
.text$mn:00002D26                 retn
.text$mn:00002D27 ; ---------------------------------------------------------------------------
.text$mn:00002D27 ; START OF FUNCTION CHUNK FOR ??$_Uninit_move@PAUFunctionValues@@PAU1@V?$allocator@UFunctionValues@@@std@@U1@@std@@YAPAUFunctionValues@@PAU1@00AAU?$_Wrap_alloc@V?$allocator@UFunctionValues@@@std@@@0@0U_Nonscalar_ptr_iterator_tag@0@@Z
.text$mn:00002D27
.text$mn:00002D27 loc_2D27:                               ; CODE XREF: std::_Uninit_move<FunctionValues *,FunctionValues *,std::allocator<FunctionValues>,FunctionValues>(FunctionValues *,FunctionValues *,FunctionValues *,std::_Wrap_alloc<std::allocator<FunctionValues>> &,FunctionValues *,std::_Nonscalar_ptr_iterator_tag):loc_2CF5j
.text$mn:00002D27                 mov     [ebp+var_4], 0FFFFFFFFh
.text$mn:00002D2E                 jmp     short loc_2D37
.text$mn:00002D2E ; END OF FUNCTION CHUNK FOR ??$_Uninit_move@PAUFunctionValues@@PAU1@V?$allocator@UFunctionValues@@@std@@U1@@std@@YAPAUFunctionValues@@PAU1@00AAU?$_Wrap_alloc@V?$allocator@UFunctionValues@@@std@@@0@0U_Nonscalar_ptr_iterator_tag@0@@Z
.text$mn:00002D30
.text$mn:00002D30 ; =============== S U B R O U T I N E =======================================
.text$mn:00002D30
.text$mn:00002D30
.text$mn:00002D30 $LN13_1         proc near               ; DATA XREF: .text$mn:00002D21o
.text$mn:00002D30                 mov     dword ptr [ebp-4], 0FFFFFFFFh
.text$mn:00002D30 $LN13_1         endp ; sp-analysis failed
.text$mn:00002D30
.text$mn:00002D37 ; START OF FUNCTION CHUNK FOR ??$_Uninit_move@PAUFunctionValues@@PAU1@V?$allocator@UFunctionValues@@@std@@U1@@std@@YAPAUFunctionValues@@PAU1@00AAU?$_Wrap_alloc@V?$allocator@UFunctionValues@@@std@@@0@0U_Nonscalar_ptr_iterator_tag@0@@Z
.text$mn:00002D37
.text$mn:00002D37 loc_2D37:                               ; CODE XREF: std::_Uninit_move<FunctionValues *,FunctionValues *,std::allocator<FunctionValues>,FunctionValues>(FunctionValues *,FunctionValues *,FunctionValues *,std::_Wrap_alloc<std::allocator<FunctionValues>> &,FunctionValues *,std::_Nonscalar_ptr_iterator_tag)+CEj
.text$mn:00002D37                 mov     eax, [ebp+arg_8]
.text$mn:00002D3A                 mov     ecx, [ebp+var_C]
.text$mn:00002D3D                 mov     large fs:0, ecx
.text$mn:00002D44                 pop     ecx
.text$mn:00002D45                 pop     edi
.text$mn:00002D46                 pop     esi
.text$mn:00002D47                 pop     ebx
.text$mn:00002D48                 mov     esp, ebp
.text$mn:00002D4A                 pop     ebp
.text$mn:00002D4B                 retn
.text$mn:00002D4B ; END OF FUNCTION CHUNK FOR ??$_Uninit_move@PAUFunctionValues@@PAU1@V?$allocator@UFunctionValues@@@std@@U1@@std@@YAPAUFunctionValues@@PAU1@00AAU?$_Wrap_alloc@V?$allocator@UFunctionValues@@@std@@@0@0U_Nonscalar_ptr_iterator_tag@0@@Z
.text$mn:00002D4B _text$mn        ends
.text$mn:00002D4B
.text$x:00002D4C ; ===========================================================================
.text$x:00002D4C
.text$x:00002D4C ; Segment type: Pure code
.text$x:00002D4C ; Segment permissions: Read/Execute
.text$x:00002D4C _text$x         segment para public 'CODE' use32
.text$x:00002D4C                 assume cs:_text$x
.text$x:00002D4C                 ;org 2D4Ch
.text$x:00002D4C ; COMDAT (pick associative to section at 2C60)
.text$x:00002D4C                 assume es:nothing, ss:nothing, ds:_data, fs:nothing, gs:nothing
.text$x:00002D4C
.text$x:00002D4C ; =============== S U B R O U T I N E =======================================
.text$x:00002D4C
.text$x:00002D4C
.text$x:00002D4C __ehhandler$??$_Uninit_move@PAUFunctionValues@@PAU1@V?$allocator@UFunctionValues@@@std@@U1@@std@@YAPAUFunctionValues@@PAU1@00AAU?$_Wrap_alloc@V?$allocator@UFunctionValues@@@std@@@0@0U_Nonscalar_ptr_iterator_tag@0@@Z proc near
.text$x:00002D4C                                         ; DATA XREF: std::_Uninit_move<FunctionValues *,FunctionValues *,std::allocator<FunctionValues>,FunctionValues>(FunctionValues *,FunctionValues *,FunctionValues *,std::_Wrap_alloc<std::allocator<FunctionValues>> &,FunctionValues *,std::_Nonscalar_ptr_iterator_tag)+5o
.text$x:00002D4C
.text$x:00002D4C arg_4           = dword ptr  8
.text$x:00002D4C
.text$x:00002D4C                 mov     edx, [esp+arg_4]
.text$x:00002D50                 lea     eax, [edx+0Ch]
.text$x:00002D53                 mov     ecx, [edx-18h]
.text$x:00002D56                 xor     ecx, eax
.text$x:00002D58                 call    @__security_check_cookie@4 ; __security_check_cookie(x)
.text$x:00002D5D                 mov     eax, offset __ehfuncinfo$??$_Uninit_move@PAUFunctionValues@@PAU1@V?$allocator@UFunctionValues@@@std@@U1@@std@@YAPAUFunctionValues@@PAU1@00AAU?$_Wrap_alloc@V?$allocator@UFunctionValues@@@std@@@0@0U_Nonscalar_ptr_iterator_tag@0@@Z
.text$x:00002D62                 jmp     ___CxxFrameHandler3
.text$x:00002D62 __ehhandler$??$_Uninit_move@PAUFunctionValues@@PAU1@V?$allocator@UFunctionValues@@@std@@U1@@std@@YAPAUFunctionValues@@PAU1@00AAU?$_Wrap_alloc@V?$allocator@UFunctionValues@@@std@@@0@0U_Nonscalar_ptr_iterator_tag@0@@Z endp
.text$x:00002D62
.text$x:00002D62 ; ---------------------------------------------------------------------------
.text$x:00002D67                 align 4
.text$x:00002D67 _text$x         ends
.text$x:00002D67
.text$mn:00002D68 ; ===========================================================================
.text$mn:00002D68
.text$mn:00002D68 ; Segment type: Pure code
.text$mn:00002D68 ; Segment permissions: Read/Execute
.text$mn:00002D68 _text$mn        segment para public 'CODE' use32
.text$mn:00002D68                 assume cs:_text$mn
.text$mn:00002D68                 ;org 2D68h
.text$mn:00002D68 ; COMDAT (pick any)
.text$mn:00002D68                 assume es:nothing, ss:nothing, ds:_data, fs:nothing, gs:nothing
.text$mn:00002D68
.text$mn:00002D68 ; =============== S U B R O U T I N E =======================================
.text$mn:00002D68
.text$mn:00002D68 ; Attributes: bp-based frame
.text$mn:00002D68
.text$mn:00002D68 ; int __cdecl std::_Uninit_move<Token *,Token *,std::_Wrap_alloc<std::allocator<Token>>>(int, int, void *, int)
.text$mn:00002D68                 public ??$_Uninit_move@PAUToken@@PAU1@U?$_Wrap_alloc@V?$allocator@UToken@@@std@@@std@@@std@@YAPAUToken@@PAU1@00AAU?$_Wrap_alloc@V?$allocator@UToken@@@std@@@0@@Z
.text$mn:00002D68 ??$_Uninit_move@PAUToken@@PAU1@U?$_Wrap_alloc@V?$allocator@UToken@@@std@@@std@@@std@@YAPAUToken@@PAU1@00AAU?$_Wrap_alloc@V?$allocator@UToken@@@std@@@0@@Z proc near
.text$mn:00002D68                                         ; CODE XREF: std::_Uninitialized_move<Token *,Token *,std::_Wrap_alloc<std::allocator<Token>>>(Token *,Token *,Token *,std::_Wrap_alloc<std::allocator<Token>> &)+2Ep
.text$mn:00002D68
.text$mn:00002D68 var_1           = byte ptr -1
.text$mn:00002D68 arg_0           = dword ptr  8
.text$mn:00002D68 arg_4           = dword ptr  0Ch
.text$mn:00002D68 arg_8           = dword ptr  10h
.text$mn:00002D68 arg_C           = dword ptr  14h
.text$mn:00002D68
.text$mn:00002D68                 push    ebp
.text$mn:00002D69                 mov     ebp, esp
.text$mn:00002D6B                 push    ecx
.text$mn:00002D6C                 mov     eax, [ebp+arg_8]
.text$mn:00002D6F                 push    eax
.text$mn:00002D70                 mov     ecx, [ebp+arg_0]
.text$mn:00002D73                 push    ecx
.text$mn:00002D74                 call    ??$_Ptr_cat@UToken@@U1@@std@@YA?AU_Nonscalar_ptr_iterator_tag@0@PAUToken@@0@Z ; std::_Ptr_cat<Token,Token>(Token *,Token *)
.text$mn:00002D79                 add     esp, 8
.text$mn:00002D7C                 mov     [ebp+var_1], al
.text$mn:00002D7F                 movzx   edx, [ebp+var_1]
.text$mn:00002D83                 push    edx
.text$mn:00002D84                 mov     eax, [ebp+arg_0]
.text$mn:00002D87                 push    eax
.text$mn:00002D88                 call    ??$_Val_type@PAUToken@@@std@@YAPAUToken@@PAU1@@Z ; std::_Val_type<Token *>(Token *)
.text$mn:00002D8D                 add     esp, 4
.text$mn:00002D90                 push    eax
.text$mn:00002D91                 mov     ecx, [ebp+arg_C]
.text$mn:00002D94                 push    ecx             ; int
.text$mn:00002D95                 mov     edx, [ebp+arg_8]
.text$mn:00002D98                 push    edx             ; void *
.text$mn:00002D99                 mov     eax, [ebp+arg_4]
.text$mn:00002D9C                 push    eax             ; int
.text$mn:00002D9D                 mov     ecx, [ebp+arg_0]
.text$mn:00002DA0                 push    ecx             ; int
.text$mn:00002DA1                 call    ??$_Uninit_move@PAUToken@@PAU1@V?$allocator@UToken@@@std@@U1@@std@@YAPAUToken@@PAU1@00AAU?$_Wrap_alloc@V?$allocator@UToken@@@std@@@0@0U_Nonscalar_ptr_iterator_tag@0@@Z ; std::_Uninit_move<Token *,Token *,std::allocator<Token>,Token>(Token *,Token *,Token *,std::_Wrap_alloc<std::allocator<Token>> &,Token *,std::_Nonscalar_ptr_iterator_tag)
.text$mn:00002DA6                 add     esp, 18h
.text$mn:00002DA9                 mov     esp, ebp
.text$mn:00002DAB                 pop     ebp
.text$mn:00002DAC                 retn
.text$mn:00002DAC ??$_Uninit_move@PAUToken@@PAU1@U?$_Wrap_alloc@V?$allocator@UToken@@@std@@@std@@@std@@YAPAUToken@@PAU1@00AAU?$_Wrap_alloc@V?$allocator@UToken@@@std@@@0@@Z endp
.text$mn:00002DAC
.text$mn:00002DAC ; ---------------------------------------------------------------------------
.text$mn:00002DAD                 align 10h
.text$mn:00002DAD _text$mn        ends
.text$mn:00002DAD
.text$mn:00002DB0 ; ===========================================================================
.text$mn:00002DB0
.text$mn:00002DB0 ; Segment type: Pure code
.text$mn:00002DB0 ; Segment permissions: Read/Execute
.text$mn:00002DB0 _text$mn        segment para public 'CODE' use32
.text$mn:00002DB0                 assume cs:_text$mn
.text$mn:00002DB0                 ;org 2DB0h
.text$mn:00002DB0 ; COMDAT (pick any)
.text$mn:00002DB0                 assume es:nothing, ss:nothing, ds:_data, fs:nothing, gs:nothing
.text$mn:00002DB0
.text$mn:00002DB0 ; =============== S U B R O U T I N E =======================================
.text$mn:00002DB0
.text$mn:00002DB0 ; Attributes: bp-based frame
.text$mn:00002DB0
.text$mn:00002DB0 ; int __cdecl std::_Uninit_move<Token *,Token *,std::allocator<Token>,Token>(int, int, void *, int)
.text$mn:00002DB0                 public ??$_Uninit_move@PAUToken@@PAU1@V?$allocator@UToken@@@std@@U1@@std@@YAPAUToken@@PAU1@00AAU?$_Wrap_alloc@V?$allocator@UToken@@@std@@@0@0U_Nonscalar_ptr_iterator_tag@0@@Z
.text$mn:00002DB0 ??$_Uninit_move@PAUToken@@PAU1@V?$allocator@UToken@@@std@@U1@@std@@YAPAUToken@@PAU1@00AAU?$_Wrap_alloc@V?$allocator@UToken@@@std@@@0@0U_Nonscalar_ptr_iterator_tag@0@@Z proc near
.text$mn:00002DB0                                         ; CODE XREF: std::_Uninit_move<Token *,Token *,std::_Wrap_alloc<std::allocator<Token>>>(Token *,Token *,Token *,std::_Wrap_alloc<std::allocator<Token>> &)+39p
.text$mn:00002DB0
.text$mn:00002DB0 var_14          = dword ptr -14h
.text$mn:00002DB0 var_10          = dword ptr -10h
.text$mn:00002DB0 var_C           = dword ptr -0Ch
.text$mn:00002DB0 var_4           = dword ptr -4
.text$mn:00002DB0 arg_0           = dword ptr  8
.text$mn:00002DB0 arg_4           = dword ptr  0Ch
.text$mn:00002DB0 arg_8           = dword ptr  10h
.text$mn:00002DB0 arg_C           = dword ptr  14h
.text$mn:00002DB0
.text$mn:00002DB0 ; FUNCTION CHUNK AT .text$mn:00002E77 SIZE 00000009 BYTES
.text$mn:00002DB0 ; FUNCTION CHUNK AT .text$mn:00002E87 SIZE 00000015 BYTES
.text$mn:00002DB0
.text$mn:00002DB0                 push    ebp
.text$mn:00002DB1                 mov     ebp, esp
.text$mn:00002DB3                 push    0FFFFFFFFh
.text$mn:00002DB5                 push    offset __ehhandler$??$_Uninit_move@PAUToken@@PAU1@V?$allocator@UToken@@@std@@U1@@std@@YAPAUToken@@PAU1@00AAU?$_Wrap_alloc@V?$allocator@UToken@@@std@@@0@0U_Nonscalar_ptr_iterator_tag@0@@Z
.text$mn:00002DBA                 mov     eax, large fs:0
.text$mn:00002DC0                 push    eax
.text$mn:00002DC1                 push    ecx
.text$mn:00002DC2                 push    ecx
.text$mn:00002DC3                 push    ebx
.text$mn:00002DC4                 push    esi
.text$mn:00002DC5                 push    edi
.text$mn:00002DC6                 mov     eax, dword ptr ds:___security_cookie
.text$mn:00002DCB                 xor     eax, ebp
.text$mn:00002DCD                 push    eax
.text$mn:00002DCE                 lea     eax, [ebp+var_C]
.text$mn:00002DD1                 mov     large fs:0, eax
.text$mn:00002DD7                 mov     [ebp+var_10], esp
.text$mn:00002DDA                 push    1B6h            ; unsigned int
.text$mn:00002DDF                 push    offset ??_C@_1IO@LKIDJAMC@?$AAC?$AA?3?$AA?2?$AAP?$AAr?$AAo?$AAg?$AAr?$AAa?$AAm?$AA?5?$AAF?$AAi?$AAl?$AAe?$AAs?$AA?5?$AA?$CI?$AAx?$AA8?$AA6?$AA?$CJ?$AA?2?$AAM?$AAi?$AAc?$AAr?$AAo?$AAs?$AAo?$AAf?$AAt@ ; "C:\\Program Files (x86)\\Microsoft Visu"...
.text$mn:00002DE4                 mov     eax, [ebp+arg_4]
.text$mn:00002DE7                 push    eax             ; int
.text$mn:00002DE8                 mov     ecx, [ebp+arg_0]
.text$mn:00002DEB                 push    ecx             ; int
.text$mn:00002DEC                 call    ??$_Debug_range@PAUToken@@@std@@YAXPAUToken@@0PB_WI@Z ; std::_Debug_range<Token *>(Token *,Token *,wchar_t const *,uint)
.text$mn:00002DF1                 add     esp, 10h
.text$mn:00002DF4                 push    1B7h            ; unsigned int
.text$mn:00002DF9                 push    offset ??_C@_1IO@LKIDJAMC@?$AAC?$AA?3?$AA?2?$AAP?$AAr?$AAo?$AAg?$AAr?$AAa?$AAm?$AA?5?$AAF?$AAi?$AAl?$AAe?$AAs?$AA?5?$AA?$CI?$AAx?$AA8?$AA6?$AA?$CJ?$AA?2?$AAM?$AAi?$AAc?$AAr?$AAo?$AAs?$AAo?$AAf?$AAt@ ; "C:\\Program Files (x86)\\Microsoft Visu"...
.text$mn:00002DFE                 mov     edx, [ebp+arg_8]
.text$mn:00002E01                 push    edx             ; int
.text$mn:00002E02                 call    ??$_Debug_pointer@UToken@@@std@@YAXPAUToken@@PB_WI@Z ; std::_Debug_pointer<Token>(Token *,wchar_t const *,uint)
.text$mn:00002E07                 add     esp, 0Ch
.text$mn:00002E0A                 mov     eax, [ebp+arg_8]
.text$mn:00002E0D                 mov     [ebp+var_14], eax
.text$mn:00002E10                 mov     [ebp+var_4], 0
.text$mn:00002E17                 jmp     short loc_2E2B
.text$mn:00002E19 ; ---------------------------------------------------------------------------
.text$mn:00002E19
.text$mn:00002E19 loc_2E19:                               ; CODE XREF: std::_Uninit_move<Token *,Token *,std::allocator<Token>,Token>(Token *,Token *,Token *,std::_Wrap_alloc<std::allocator<Token>> &,Token *,std::_Nonscalar_ptr_iterator_tag)+93j
.text$mn:00002E19                 mov     ecx, [ebp+arg_8]
.text$mn:00002E1C                 add     ecx, 0Ch
.text$mn:00002E1F                 mov     [ebp+arg_8], ecx
.text$mn:00002E22                 mov     edx, [ebp+arg_0]
.text$mn:00002E25                 add     edx, 0Ch
.text$mn:00002E28                 mov     [ebp+arg_0], edx
.text$mn:00002E2B
.text$mn:00002E2B loc_2E2B:                               ; CODE XREF: std::_Uninit_move<Token *,Token *,std::allocator<Token>,Token>(Token *,Token *,Token *,std::_Wrap_alloc<std::allocator<Token>> &,Token *,std::_Nonscalar_ptr_iterator_tag)+67j
.text$mn:00002E2B                 mov     eax, [ebp+arg_0]
.text$mn:00002E2E                 cmp     eax, [ebp+arg_4]
.text$mn:00002E31                 jz      short loc_2E45
.text$mn:00002E33                 mov     ecx, [ebp+arg_0]
.text$mn:00002E36                 push    ecx             ; int
.text$mn:00002E37                 mov     edx, [ebp+arg_8]
.text$mn:00002E3A                 push    edx             ; void *
.text$mn:00002E3B                 mov     ecx, [ebp+arg_C]
.text$mn:00002E3E                 call    ??$construct@UToken@@U1@@?$_Wrap_alloc@V?$allocator@UToken@@@std@@@std@@QAEXPAUToken@@$$QAU2@@Z ; std::_Wrap_alloc<std::allocator<Token>>::construct<Token,Token>(Token *,Token &&)
.text$mn:00002E43                 jmp     short loc_2E19
.text$mn:00002E45 ; ---------------------------------------------------------------------------
.text$mn:00002E45
.text$mn:00002E45 loc_2E45:                               ; CODE XREF: std::_Uninit_move<Token *,Token *,std::allocator<Token>,Token>(Token *,Token *,Token *,std::_Wrap_alloc<std::allocator<Token>> &,Token *,std::_Nonscalar_ptr_iterator_tag)+81j
.text$mn:00002E45                 jmp     short loc_2E77
.text$mn:00002E45 ??$_Uninit_move@PAUToken@@PAU1@V?$allocator@UToken@@@std@@U1@@std@@YAPAUToken@@PAU1@00AAU?$_Wrap_alloc@V?$allocator@UToken@@@std@@@0@0U_Nonscalar_ptr_iterator_tag@0@@Z endp
.text$mn:00002E45
.text$mn:00002E47
.text$mn:00002E47 ; =============== S U B R O U T I N E =======================================
.text$mn:00002E47
.text$mn:00002E47 ; Attributes: noreturn
.text$mn:00002E47
.text$mn:00002E47 __catch$??$_Uninit_move@PAUToken@@PAU1@V?$allocator@UToken@@@std@@U1@@std@@YAPAUToken@@PAU1@00AAU?$_Wrap_alloc@V?$allocator@UToken@@@std@@@0@0U_Nonscalar_ptr_iterator_tag@0@@Z$0 proc near
.text$mn:00002E47                                         ; DATA XREF: .xdata$x:0000A1A4o
.text$mn:00002E47                 jmp     short loc_2E52
.text$mn:00002E49 ; ---------------------------------------------------------------------------
.text$mn:00002E49
.text$mn:00002E49 loc_2E49:                               ; CODE XREF: __catch$??$_Uninit_move@PAUToken@@PAU1@V?$allocator@UToken@@@std@@U1@@std@@YAPAUToken@@PAU1@00AAU?$_Wrap_alloc@V?$allocator@UToken@@@std@@@0@0U_Nonscalar_ptr_iterator_tag@0@@Z$0+1Fj
.text$mn:00002E49                 mov     eax, [ebp-14h]
.text$mn:00002E4C                 add     eax, 0Ch
.text$mn:00002E4F                 mov     [ebp-14h], eax
.text$mn:00002E52
.text$mn:00002E52 loc_2E52:                               ; CODE XREF: __catch$??$_Uninit_move@PAUToken@@PAU1@V?$allocator@UToken@@@std@@U1@@std@@YAPAUToken@@PAU1@00AAU?$_Wrap_alloc@V?$allocator@UToken@@@std@@@0@0U_Nonscalar_ptr_iterator_tag@0@@Z$0j
.text$mn:00002E52                 mov     ecx, [ebp-14h]
.text$mn:00002E55                 cmp     ecx, [ebp+10h]
.text$mn:00002E58                 jz      short loc_2E68
.text$mn:00002E5A                 mov     edx, [ebp-14h]
.text$mn:00002E5D                 push    edx
.text$mn:00002E5E                 mov     ecx, [ebp+14h]
.text$mn:00002E61                 call    ??$destroy@UToken@@@?$_Wrap_alloc@V?$allocator@UToken@@@std@@@std@@QAEXPAUToken@@@Z ; std::_Wrap_alloc<std::allocator<Token>>::destroy<Token>(Token *)
.text$mn:00002E66                 jmp     short loc_2E49
.text$mn:00002E68 ; ---------------------------------------------------------------------------
.text$mn:00002E68
.text$mn:00002E68 loc_2E68:                               ; CODE XREF: __catch$??$_Uninit_move@PAUToken@@PAU1@V?$allocator@UToken@@@std@@U1@@std@@YAPAUToken@@PAU1@00AAU?$_Wrap_alloc@V?$allocator@UToken@@@std@@@0@0U_Nonscalar_ptr_iterator_tag@0@@Z$0+11j
.text$mn:00002E68                 push    0
.text$mn:00002E6A                 push    0
.text$mn:00002E6C                 call    __CxxThrowException@8 ; _CxxThrowException(x,x)
.text$mn:00002E6C __catch$??$_Uninit_move@PAUToken@@PAU1@V?$allocator@UToken@@@std@@U1@@std@@YAPAUToken@@PAU1@00AAU?$_Wrap_alloc@V?$allocator@UToken@@@std@@@0@0U_Nonscalar_ptr_iterator_tag@0@@Z$0 endp
.text$mn:00002E6C
.text$mn:00002E71 ; ---------------------------------------------------------------------------
.text$mn:00002E71                 mov     eax, offset $LN13_0
.text$mn:00002E76                 retn
.text$mn:00002E77 ; ---------------------------------------------------------------------------
.text$mn:00002E77 ; START OF FUNCTION CHUNK FOR ??$_Uninit_move@PAUToken@@PAU1@V?$allocator@UToken@@@std@@U1@@std@@YAPAUToken@@PAU1@00AAU?$_Wrap_alloc@V?$allocator@UToken@@@std@@@0@0U_Nonscalar_ptr_iterator_tag@0@@Z
.text$mn:00002E77
.text$mn:00002E77 loc_2E77:                               ; CODE XREF: std::_Uninit_move<Token *,Token *,std::allocator<Token>,Token>(Token *,Token *,Token *,std::_Wrap_alloc<std::allocator<Token>> &,Token *,std::_Nonscalar_ptr_iterator_tag):loc_2E45j
.text$mn:00002E77                 mov     [ebp+var_4], 0FFFFFFFFh
.text$mn:00002E7E                 jmp     short loc_2E87
.text$mn:00002E7E ; END OF FUNCTION CHUNK FOR ??$_Uninit_move@PAUToken@@PAU1@V?$allocator@UToken@@@std@@U1@@std@@YAPAUToken@@PAU1@00AAU?$_Wrap_alloc@V?$allocator@UToken@@@std@@@0@0U_Nonscalar_ptr_iterator_tag@0@@Z
.text$mn:00002E80
.text$mn:00002E80 ; =============== S U B R O U T I N E =======================================
.text$mn:00002E80
.text$mn:00002E80
.text$mn:00002E80 $LN13_0         proc near               ; DATA XREF: .text$mn:00002E71o
.text$mn:00002E80                 mov     dword ptr [ebp-4], 0FFFFFFFFh
.text$mn:00002E80 $LN13_0         endp ; sp-analysis failed
.text$mn:00002E80
.text$mn:00002E87 ; START OF FUNCTION CHUNK FOR ??$_Uninit_move@PAUToken@@PAU1@V?$allocator@UToken@@@std@@U1@@std@@YAPAUToken@@PAU1@00AAU?$_Wrap_alloc@V?$allocator@UToken@@@std@@@0@0U_Nonscalar_ptr_iterator_tag@0@@Z
.text$mn:00002E87
.text$mn:00002E87 loc_2E87:                               ; CODE XREF: std::_Uninit_move<Token *,Token *,std::allocator<Token>,Token>(Token *,Token *,Token *,std::_Wrap_alloc<std::allocator<Token>> &,Token *,std::_Nonscalar_ptr_iterator_tag)+CEj
.text$mn:00002E87                 mov     eax, [ebp+arg_8]
.text$mn:00002E8A                 mov     ecx, [ebp+var_C]
.text$mn:00002E8D                 mov     large fs:0, ecx
.text$mn:00002E94                 pop     ecx
.text$mn:00002E95                 pop     edi
.text$mn:00002E96                 pop     esi
.text$mn:00002E97                 pop     ebx
.text$mn:00002E98                 mov     esp, ebp
.text$mn:00002E9A                 pop     ebp
.text$mn:00002E9B                 retn
.text$mn:00002E9B ; END OF FUNCTION CHUNK FOR ??$_Uninit_move@PAUToken@@PAU1@V?$allocator@UToken@@@std@@U1@@std@@YAPAUToken@@PAU1@00AAU?$_Wrap_alloc@V?$allocator@UToken@@@std@@@0@0U_Nonscalar_ptr_iterator_tag@0@@Z
.text$mn:00002E9B _text$mn        ends
.text$mn:00002E9B
.text$x:00002E9C ; ===========================================================================
.text$x:00002E9C
.text$x:00002E9C ; Segment type: Pure code
.text$x:00002E9C ; Segment permissions: Read/Execute
.text$x:00002E9C _text$x         segment para public 'CODE' use32
.text$x:00002E9C                 assume cs:_text$x
.text$x:00002E9C                 ;org 2E9Ch
.text$x:00002E9C ; COMDAT (pick associative to section at 2DB0)
.text$x:00002E9C                 assume es:nothing, ss:nothing, ds:_data, fs:nothing, gs:nothing
.text$x:00002E9C
.text$x:00002E9C ; =============== S U B R O U T I N E =======================================
.text$x:00002E9C
.text$x:00002E9C
.text$x:00002E9C __ehhandler$??$_Uninit_move@PAUToken@@PAU1@V?$allocator@UToken@@@std@@U1@@std@@YAPAUToken@@PAU1@00AAU?$_Wrap_alloc@V?$allocator@UToken@@@std@@@0@0U_Nonscalar_ptr_iterator_tag@0@@Z proc near
.text$x:00002E9C                                         ; DATA XREF: std::_Uninit_move<Token *,Token *,std::allocator<Token>,Token>(Token *,Token *,Token *,std::_Wrap_alloc<std::allocator<Token>> &,Token *,std::_Nonscalar_ptr_iterator_tag)+5o
.text$x:00002E9C
.text$x:00002E9C arg_4           = dword ptr  8
.text$x:00002E9C
.text$x:00002E9C                 mov     edx, [esp+arg_4]
.text$x:00002EA0                 lea     eax, [edx+0Ch]
.text$x:00002EA3                 mov     ecx, [edx-18h]
.text$x:00002EA6                 xor     ecx, eax
.text$x:00002EA8                 call    @__security_check_cookie@4 ; __security_check_cookie(x)
.text$x:00002EAD                 mov     eax, offset __ehfuncinfo$??$_Uninit_move@PAUToken@@PAU1@V?$allocator@UToken@@@std@@U1@@std@@YAPAUToken@@PAU1@00AAU?$_Wrap_alloc@V?$allocator@UToken@@@std@@@0@0U_Nonscalar_ptr_iterator_tag@0@@Z
.text$x:00002EB2                 jmp     ___CxxFrameHandler3
.text$x:00002EB2 __ehhandler$??$_Uninit_move@PAUToken@@PAU1@V?$allocator@UToken@@@std@@U1@@std@@YAPAUToken@@PAU1@00AAU?$_Wrap_alloc@V?$allocator@UToken@@@std@@@0@0U_Nonscalar_ptr_iterator_tag@0@@Z endp
.text$x:00002EB2
.text$x:00002EB2 ; ---------------------------------------------------------------------------
.text$x:00002EB7                 align 4
.text$x:00002EB7 _text$x         ends
.text$x:00002EB7
.text$mn:00002EB8 ; ===========================================================================
.text$mn:00002EB8
.text$mn:00002EB8 ; Segment type: Pure code
.text$mn:00002EB8 ; Segment permissions: Read/Execute
.text$mn:00002EB8 _text$mn        segment para public 'CODE' use32
.text$mn:00002EB8                 assume cs:_text$mn
.text$mn:00002EB8                 ;org 2EB8h
.text$mn:00002EB8 ; COMDAT (pick any)
.text$mn:00002EB8                 assume es:nothing, ss:nothing, ds:_data, fs:nothing, gs:nothing
.text$mn:00002EB8
.text$mn:00002EB8 ; =============== S U B R O U T I N E =======================================
.text$mn:00002EB8
.text$mn:00002EB8 ; Attributes: bp-based frame
.text$mn:00002EB8
.text$mn:00002EB8 ; int __cdecl std::_Uninit_move<std::vector<wchar_t const *,std::allocator<wchar_t const *>> *,std::vector<wchar_t const *,std::allocator<wchar_t const *>> *,std::_Wrap_alloc<std::allocator<std::vector<wchar_t const *,std::allocator<wchar_t const *>>>>>(int, int, void *, int)
.text$mn:00002EB8                 public ??$_Uninit_move@PAV?$vector@PB_WV?$allocator@PB_W@std@@@std@@PAV12@U?$_Wrap_alloc@V?$allocator@V?$vector@PB_WV?$allocator@PB_W@std@@@std@@@std@@@2@@std@@YAPAV?$vector@PB_WV?$allocator@PB_W@std@@@0@PAV10@00AAU?$_Wrap_alloc@V?$allocator@V?$vector@PB_WV?$allocator@PB_W@std@@@std@@@std@@@0@@Z
.text$mn:00002EB8 ??$_Uninit_move@PAV?$vector@PB_WV?$allocator@PB_W@std@@@std@@PAV12@U?$_Wrap_alloc@V?$allocator@V?$vector@PB_WV?$allocator@PB_W@std@@@std@@@std@@@2@@std@@YAPAV?$vector@PB_WV?$allocator@PB_W@std@@@0@PAV10@00AAU?$_Wrap_alloc@V?$allocator@V?$vector@PB_WV?$allocator@PB_W@std@@@std@@@std@@@0@@Z proc near
.text$mn:00002EB8                                         ; CODE XREF: std::_Uninitialized_move<std::vector<wchar_t const *,std::allocator<wchar_t const *>> *,std::vector<wchar_t const *,std::allocator<wchar_t const *>> *,std::_Wrap_alloc<std::allocator<std::vector<wchar_t const *,std::allocator<wchar_t const *>>>>>(std::vector<wchar_t const *,std::allocator<wchar_t const *>> *,std::vector<wchar_t const *,std::allocator<wchar_t const *>> *,std::vector<wchar_t const *,std::allocator<wchar_t const *>> *,std::_Wrap_alloc<std::allocator<std::vector<wchar_t const *,std::allocator<wchar_t const *>>>> &)+2Ep
.text$mn:00002EB8
.text$mn:00002EB8 var_1           = byte ptr -1
.text$mn:00002EB8 arg_0           = dword ptr  8
.text$mn:00002EB8 arg_4           = dword ptr  0Ch
.text$mn:00002EB8 arg_8           = dword ptr  10h
.text$mn:00002EB8 arg_C           = dword ptr  14h
.text$mn:00002EB8
.text$mn:00002EB8                 push    ebp
.text$mn:00002EB9                 mov     ebp, esp
.text$mn:00002EBB                 push    ecx
.text$mn:00002EBC                 mov     eax, [ebp+arg_8]
.text$mn:00002EBF                 push    eax
.text$mn:00002EC0                 mov     ecx, [ebp+arg_0]
.text$mn:00002EC3                 push    ecx
.text$mn:00002EC4                 call    ??$_Ptr_cat@V?$vector@PB_WV?$allocator@PB_W@std@@@std@@V12@@std@@YA?AU_Nonscalar_ptr_iterator_tag@0@PAV?$vector@PB_WV?$allocator@PB_W@std@@@0@0@Z ; std::_Ptr_cat<std::vector<wchar_t const *,std::allocator<wchar_t const *>>,std::vector<wchar_t const *,std::allocator<wchar_t const *>>>(std::vector<wchar_t const *,std::allocator<wchar_t const *>> *,std::vector<wchar_t const *,std::allocator<wchar_t const *>> *)
.text$mn:00002EC9                 add     esp, 8
.text$mn:00002ECC                 mov     [ebp+var_1], al
.text$mn:00002ECF                 movzx   edx, [ebp+var_1]
.text$mn:00002ED3                 push    edx
.text$mn:00002ED4                 mov     eax, [ebp+arg_0]
.text$mn:00002ED7                 push    eax
.text$mn:00002ED8                 call    ??$_Val_type@PAV?$vector@PB_WV?$allocator@PB_W@std@@@std@@@std@@YAPAV?$vector@PB_WV?$allocator@PB_W@std@@@0@PAV10@@Z ; std::_Val_type<std::vector<wchar_t const *,std::allocator<wchar_t const *>> *>(std::vector<wchar_t const *,std::allocator<wchar_t const *>> *)
.text$mn:00002EDD                 add     esp, 4
.text$mn:00002EE0                 push    eax
.text$mn:00002EE1                 mov     ecx, [ebp+arg_C]
.text$mn:00002EE4                 push    ecx             ; int
.text$mn:00002EE5                 mov     edx, [ebp+arg_8]
.text$mn:00002EE8                 push    edx             ; void *
.text$mn:00002EE9                 mov     eax, [ebp+arg_4]
.text$mn:00002EEC                 push    eax             ; int
.text$mn:00002EED                 mov     ecx, [ebp+arg_0]
.text$mn:00002EF0                 push    ecx             ; int
.text$mn:00002EF1                 call    ??$_Uninit_move@PAV?$vector@PB_WV?$allocator@PB_W@std@@@std@@PAV12@V?$allocator@V?$vector@PB_WV?$allocator@PB_W@std@@@std@@@2@V12@@std@@YAPAV?$vector@PB_WV?$allocator@PB_W@std@@@0@PAV10@00AAU?$_Wrap_alloc@V?$allocator@V?$vector@PB_WV?$allocator@PB_W@std@@@std@@@std@@@0@0U_Nonscalar_ptr_iterator_tag@0@@Z ; std::_Uninit_move<std::vector<wchar_t const *,std::allocator<wchar_t const *>> *,std::vector<wchar_t const *,std::allocator<wchar_t const *>> *,std::allocator<std::vector<wchar_t const *,std::allocator<wchar_t const *>>>,std::vector<wchar_t const *,std::allocator<wchar_t const *>>>(std::vector<wchar_t const *,std::allocator<wchar_t const *>> *,std::vector<wchar_t const *,std::allocator<wchar_t const *>> *,std::vector<wchar_t const *,std::allocator<wchar_t const *>> *,std::_Wrap_alloc<std::allocator<std::vector<wchar_t const *,std::allocator<wchar_t const *>>>> &,std::vector<wchar_t const *,std::allocator<wchar_t const *>> *,std::_Nonscalar_ptr_iterator_tag)
.text$mn:00002EF6                 add     esp, 18h
.text$mn:00002EF9                 mov     esp, ebp
.text$mn:00002EFB                 pop     ebp
.text$mn:00002EFC                 retn
.text$mn:00002EFC ??$_Uninit_move@PAV?$vector@PB_WV?$allocator@PB_W@std@@@std@@PAV12@U?$_Wrap_alloc@V?$allocator@V?$vector@PB_WV?$allocator@PB_W@std@@@std@@@std@@@2@@std@@YAPAV?$vector@PB_WV?$allocator@PB_W@std@@@0@PAV10@00AAU?$_Wrap_alloc@V?$allocator@V?$vector@PB_WV?$allocator@PB_W@std@@@std@@@std@@@0@@Z endp
.text$mn:00002EFC
.text$mn:00002EFC ; ---------------------------------------------------------------------------
.text$mn:00002EFD                 align 10h
.text$mn:00002EFD _text$mn        ends
.text$mn:00002EFD
.text$mn:00002F00 ; ===========================================================================
.text$mn:00002F00
.text$mn:00002F00 ; Segment type: Pure code
.text$mn:00002F00 ; Segment permissions: Read/Execute
.text$mn:00002F00 _text$mn        segment para public 'CODE' use32
.text$mn:00002F00                 assume cs:_text$mn
.text$mn:00002F00                 ;org 2F00h
.text$mn:00002F00 ; COMDAT (pick any)
.text$mn:00002F00                 assume es:nothing, ss:nothing, ds:_data, fs:nothing, gs:nothing
.text$mn:00002F00
.text$mn:00002F00 ; =============== S U B R O U T I N E =======================================
.text$mn:00002F00
.text$mn:00002F00 ; Attributes: bp-based frame
.text$mn:00002F00
.text$mn:00002F00 ; int __cdecl std::_Uninit_move<std::vector<wchar_t const *,std::allocator<wchar_t const *>> *,std::vector<wchar_t const *,std::allocator<wchar_t const *>> *,std::allocator<std::vector<wchar_t const *,std::allocator<wchar_t const *>>>,std::vector<wchar_t const *,std::allocator<wchar_t const *>>>(int, int, void *, int)
.text$mn:00002F00                 public ??$_Uninit_move@PAV?$vector@PB_WV?$allocator@PB_W@std@@@std@@PAV12@V?$allocator@V?$vector@PB_WV?$allocator@PB_W@std@@@std@@@2@V12@@std@@YAPAV?$vector@PB_WV?$allocator@PB_W@std@@@0@PAV10@00AAU?$_Wrap_alloc@V?$allocator@V?$vector@PB_WV?$allocator@PB_W@std@@@std@@@std@@@0@0U_Nonscalar_ptr_iterator_tag@0@@Z
.text$mn:00002F00 ??$_Uninit_move@PAV?$vector@PB_WV?$allocator@PB_W@std@@@std@@PAV12@V?$allocator@V?$vector@PB_WV?$allocator@PB_W@std@@@std@@@2@V12@@std@@YAPAV?$vector@PB_WV?$allocator@PB_W@std@@@0@PAV10@00AAU?$_Wrap_alloc@V?$allocator@V?$vector@PB_WV?$allocator@PB_W@std@@@std@@@std@@@0@0U_Nonscalar_ptr_iterator_tag@0@@Z proc near
.text$mn:00002F00                                         ; CODE XREF: std::_Uninit_move<std::vector<wchar_t const *,std::allocator<wchar_t const *>> *,std::vector<wchar_t const *,std::allocator<wchar_t const *>> *,std::_Wrap_alloc<std::allocator<std::vector<wchar_t const *,std::allocator<wchar_t const *>>>>>(std::vector<wchar_t const *,std::allocator<wchar_t const *>> *,std::vector<wchar_t const *,std::allocator<wchar_t const *>> *,std::vector<wchar_t const *,std::allocator<wchar_t const *>> *,std::_Wrap_alloc<std::allocator<std::vector<wchar_t const *,std::allocator<wchar_t const *>>>> &)+39p
.text$mn:00002F00
.text$mn:00002F00 var_14          = dword ptr -14h
.text$mn:00002F00 var_10          = dword ptr -10h
.text$mn:00002F00 var_C           = dword ptr -0Ch
.text$mn:00002F00 var_4           = dword ptr -4
.text$mn:00002F00 arg_0           = dword ptr  8
.text$mn:00002F00 arg_4           = dword ptr  0Ch
.text$mn:00002F00 arg_8           = dword ptr  10h
.text$mn:00002F00 arg_C           = dword ptr  14h
.text$mn:00002F00
.text$mn:00002F00 ; FUNCTION CHUNK AT .text$mn:00002FC7 SIZE 00000009 BYTES
.text$mn:00002F00 ; FUNCTION CHUNK AT .text$mn:00002FD7 SIZE 00000015 BYTES
.text$mn:00002F00
.text$mn:00002F00                 push    ebp
.text$mn:00002F01                 mov     ebp, esp
.text$mn:00002F03                 push    0FFFFFFFFh
.text$mn:00002F05                 push    offset __ehhandler$??$_Uninit_move@PAV?$vector@PB_WV?$allocator@PB_W@std@@@std@@PAV12@V?$allocator@V?$vector@PB_WV?$allocator@PB_W@std@@@std@@@2@V12@@std@@YAPAV?$vector@PB_WV?$allocator@PB_W@std@@@0@PAV10@00AAU?$_Wrap_alloc@V?$allocator@V?$vector@PB_WV?$allocator@PB_W@std@@@std@@@std@@@0@0U_Nonscalar_ptr_iterator_tag@0@@Z
.text$mn:00002F0A                 mov     eax, large fs:0
.text$mn:00002F10                 push    eax
.text$mn:00002F11                 push    ecx
.text$mn:00002F12                 push    ecx
.text$mn:00002F13                 push    ebx
.text$mn:00002F14                 push    esi
.text$mn:00002F15                 push    edi
.text$mn:00002F16                 mov     eax, dword ptr ds:___security_cookie
.text$mn:00002F1B                 xor     eax, ebp
.text$mn:00002F1D                 push    eax
.text$mn:00002F1E                 lea     eax, [ebp+var_C]
.text$mn:00002F21                 mov     large fs:0, eax
.text$mn:00002F27                 mov     [ebp+var_10], esp
.text$mn:00002F2A                 push    1B6h            ; unsigned int
.text$mn:00002F2F                 push    offset ??_C@_1IO@LKIDJAMC@?$AAC?$AA?3?$AA?2?$AAP?$AAr?$AAo?$AAg?$AAr?$AAa?$AAm?$AA?5?$AAF?$AAi?$AAl?$AAe?$AAs?$AA?5?$AA?$CI?$AAx?$AA8?$AA6?$AA?$CJ?$AA?2?$AAM?$AAi?$AAc?$AAr?$AAo?$AAs?$AAo?$AAf?$AAt@ ; "C:\\Program Files (x86)\\Microsoft Visu"...
.text$mn:00002F34                 mov     eax, [ebp+arg_4]
.text$mn:00002F37                 push    eax             ; int
.text$mn:00002F38                 mov     ecx, [ebp+arg_0]
.text$mn:00002F3B                 push    ecx             ; int
.text$mn:00002F3C                 call    ??$_Debug_range@PAV?$vector@PB_WV?$allocator@PB_W@std@@@std@@@std@@YAXPAV?$vector@PB_WV?$allocator@PB_W@std@@@0@0PB_WI@Z ; std::_Debug_range<std::vector<wchar_t const *,std::allocator<wchar_t const *>> *>(std::vector<wchar_t const *,std::allocator<wchar_t const *>> *,std::vector<wchar_t const *,std::allocator<wchar_t const *>> *,wchar_t const *,uint)
.text$mn:00002F41                 add     esp, 10h
.text$mn:00002F44                 push    1B7h            ; unsigned int
.text$mn:00002F49                 push    offset ??_C@_1IO@LKIDJAMC@?$AAC?$AA?3?$AA?2?$AAP?$AAr?$AAo?$AAg?$AAr?$AAa?$AAm?$AA?5?$AAF?$AAi?$AAl?$AAe?$AAs?$AA?5?$AA?$CI?$AAx?$AA8?$AA6?$AA?$CJ?$AA?2?$AAM?$AAi?$AAc?$AAr?$AAo?$AAs?$AAo?$AAf?$AAt@ ; "C:\\Program Files (x86)\\Microsoft Visu"...
.text$mn:00002F4E                 mov     edx, [ebp+arg_8]
.text$mn:00002F51                 push    edx             ; int
.text$mn:00002F52                 call    ??$_Debug_pointer@V?$vector@PB_WV?$allocator@PB_W@std@@@std@@@std@@YAXPAV?$vector@PB_WV?$allocator@PB_W@std@@@0@PB_WI@Z ; std::_Debug_pointer<std::vector<wchar_t const *,std::allocator<wchar_t const *>>>(std::vector<wchar_t const *,std::allocator<wchar_t const *>> *,wchar_t const *,uint)
.text$mn:00002F57                 add     esp, 0Ch
.text$mn:00002F5A                 mov     eax, [ebp+arg_8]
.text$mn:00002F5D                 mov     [ebp+var_14], eax
.text$mn:00002F60                 mov     [ebp+var_4], 0
.text$mn:00002F67                 jmp     short loc_2F7B
.text$mn:00002F69 ; ---------------------------------------------------------------------------
.text$mn:00002F69
.text$mn:00002F69 loc_2F69:                               ; CODE XREF: std::_Uninit_move<std::vector<wchar_t const *,std::allocator<wchar_t const *>> *,std::vector<wchar_t const *,std::allocator<wchar_t const *>> *,std::allocator<std::vector<wchar_t const *,std::allocator<wchar_t const *>>>,std::vector<wchar_t const *,std::allocator<wchar_t const *>>>(std::vector<wchar_t const *,std::allocator<wchar_t const *>> *,std::vector<wchar_t const *,std::allocator<wchar_t const *>> *,std::vector<wchar_t const *,std::allocator<wchar_t const *>> *,std::_Wrap_alloc<std::allocator<std::vector<wchar_t const *,std::allocator<wchar_t const *>>>> &,std::vector<wchar_t const *,std::allocator<wchar_t const *>> *,std::_Nonscalar_ptr_iterator_tag)+93j
.text$mn:00002F69                 mov     ecx, [ebp+arg_8]
.text$mn:00002F6C                 add     ecx, 10h
.text$mn:00002F6F                 mov     [ebp+arg_8], ecx
.text$mn:00002F72                 mov     edx, [ebp+arg_0]
.text$mn:00002F75                 add     edx, 10h
.text$mn:00002F78                 mov     [ebp+arg_0], edx
.text$mn:00002F7B
.text$mn:00002F7B loc_2F7B:                               ; CODE XREF: std::_Uninit_move<std::vector<wchar_t const *,std::allocator<wchar_t const *>> *,std::vector<wchar_t const *,std::allocator<wchar_t const *>> *,std::allocator<std::vector<wchar_t const *,std::allocator<wchar_t const *>>>,std::vector<wchar_t const *,std::allocator<wchar_t const *>>>(std::vector<wchar_t const *,std::allocator<wchar_t const *>> *,std::vector<wchar_t const *,std::allocator<wchar_t const *>> *,std::vector<wchar_t const *,std::allocator<wchar_t const *>> *,std::_Wrap_alloc<std::allocator<std::vector<wchar_t const *,std::allocator<wchar_t const *>>>> &,std::vector<wchar_t const *,std::allocator<wchar_t const *>> *,std::_Nonscalar_ptr_iterator_tag)+67j
.text$mn:00002F7B                 mov     eax, [ebp+arg_0]
.text$mn:00002F7E                 cmp     eax, [ebp+arg_4]
.text$mn:00002F81                 jz      short loc_2F95
.text$mn:00002F83                 mov     ecx, [ebp+arg_0]
.text$mn:00002F86                 push    ecx             ; int
.text$mn:00002F87                 mov     edx, [ebp+arg_8]
.text$mn:00002F8A                 push    edx             ; void *
.text$mn:00002F8B                 mov     ecx, [ebp+arg_C]
.text$mn:00002F8E                 call    ??$construct@V?$vector@PB_WV?$allocator@PB_W@std@@@std@@V12@@?$_Wrap_alloc@V?$allocator@V?$vector@PB_WV?$allocator@PB_W@std@@@std@@@std@@@std@@QAEXPAV?$vector@PB_WV?$allocator@PB_W@std@@@1@$$QAV21@@Z ; std::_Wrap_alloc<std::allocator<std::vector<wchar_t const *,std::allocator<wchar_t const *>>>>::construct<std::vector<wchar_t const *,std::allocator<wchar_t const *>>,std::vector<wchar_t const *,std::allocator<wchar_t const *>>>(std::vector<wchar_t const *,std::allocator<wchar_t const *>> *,std::vector<wchar_t const *,std::allocator<wchar_t const *>> &&)
.text$mn:00002F93                 jmp     short loc_2F69
.text$mn:00002F95 ; ---------------------------------------------------------------------------
.text$mn:00002F95
.text$mn:00002F95 loc_2F95:                               ; CODE XREF: std::_Uninit_move<std::vector<wchar_t const *,std::allocator<wchar_t const *>> *,std::vector<wchar_t const *,std::allocator<wchar_t const *>> *,std::allocator<std::vector<wchar_t const *,std::allocator<wchar_t const *>>>,std::vector<wchar_t const *,std::allocator<wchar_t const *>>>(std::vector<wchar_t const *,std::allocator<wchar_t const *>> *,std::vector<wchar_t const *,std::allocator<wchar_t const *>> *,std::vector<wchar_t const *,std::allocator<wchar_t const *>> *,std::_Wrap_alloc<std::allocator<std::vector<wchar_t const *,std::allocator<wchar_t const *>>>> &,std::vector<wchar_t const *,std::allocator<wchar_t const *>> *,std::_Nonscalar_ptr_iterator_tag)+81j
.text$mn:00002F95                 jmp     short loc_2FC7
.text$mn:00002F95 ??$_Uninit_move@PAV?$vector@PB_WV?$allocator@PB_W@std@@@std@@PAV12@V?$allocator@V?$vector@PB_WV?$allocator@PB_W@std@@@std@@@2@V12@@std@@YAPAV?$vector@PB_WV?$allocator@PB_W@std@@@0@PAV10@00AAU?$_Wrap_alloc@V?$allocator@V?$vector@PB_WV?$allocator@PB_W@std@@@std@@@std@@@0@0U_Nonscalar_ptr_iterator_tag@0@@Z endp
.text$mn:00002F95
.text$mn:00002F97
.text$mn:00002F97 ; =============== S U B R O U T I N E =======================================
.text$mn:00002F97
.text$mn:00002F97 ; Attributes: noreturn
.text$mn:00002F97
.text$mn:00002F97 __catch$??$_Uninit_move@PAV?$vector@PB_WV?$allocator@PB_W@std@@@std@@PAV12@V?$allocator@V?$vector@PB_WV?$allocator@PB_W@std@@@std@@@2@V12@@std@@YAPAV?$vector@PB_WV?$allocator@PB_W@std@@@0@PAV10@00AAU?$_Wrap_alloc@V?$allocator@V?$vector@PB_WV?$allocator@PB_W@std@@@std@@@std@@@0@0U_Nonscalar_ptr_iterator_tag@0@@Z$0 proc near
.text$mn:00002F97                                         ; DATA XREF: .xdata$x:0000A14Co
.text$mn:00002F97                 jmp     short loc_2FA2
.text$mn:00002F99 ; ---------------------------------------------------------------------------
.text$mn:00002F99
.text$mn:00002F99 loc_2F99:                               ; CODE XREF: __catch$??$_Uninit_move@PAV?$vector@PB_WV?$allocator@PB_W@std@@@std@@PAV12@V?$allocator@V?$vector@PB_WV?$allocator@PB_W@std@@@std@@@2@V12@@std@@YAPAV?$vector@PB_WV?$allocator@PB_W@std@@@0@PAV10@00AAU?$_Wrap_alloc@V?$allocator@V?$vector@PB_WV?$allocator@PB_W@std@@@std@@@std@@@0@0U_Nonscalar_ptr_iterator_tag@0@@Z$0+1Fj
.text$mn:00002F99                 mov     eax, [ebp-14h]
.text$mn:00002F9C                 add     eax, 10h
.text$mn:00002F9F                 mov     [ebp-14h], eax
.text$mn:00002FA2
.text$mn:00002FA2 loc_2FA2:                               ; CODE XREF: __catch$??$_Uninit_move@PAV?$vector@PB_WV?$allocator@PB_W@std@@@std@@PAV12@V?$allocator@V?$vector@PB_WV?$allocator@PB_W@std@@@std@@@2@V12@@std@@YAPAV?$vector@PB_WV?$allocator@PB_W@std@@@0@PAV10@00AAU?$_Wrap_alloc@V?$allocator@V?$vector@PB_WV?$allocator@PB_W@std@@@std@@@std@@@0@0U_Nonscalar_ptr_iterator_tag@0@@Z$0j
.text$mn:00002FA2                 mov     ecx, [ebp-14h]
.text$mn:00002FA5                 cmp     ecx, [ebp+10h]
.text$mn:00002FA8                 jz      short loc_2FB8
.text$mn:00002FAA                 mov     edx, [ebp-14h]
.text$mn:00002FAD                 push    edx
.text$mn:00002FAE                 mov     ecx, [ebp+14h]
.text$mn:00002FB1                 call    ??$destroy@V?$vector@PB_WV?$allocator@PB_W@std@@@std@@@?$_Wrap_alloc@V?$allocator@V?$vector@PB_WV?$allocator@PB_W@std@@@std@@@std@@@std@@QAEXPAV?$vector@PB_WV?$allocator@PB_W@std@@@1@@Z ; std::_Wrap_alloc<std::allocator<std::vector<wchar_t const *,std::allocator<wchar_t const *>>>>::destroy<std::vector<wchar_t const *,std::allocator<wchar_t const *>>>(std::vector<wchar_t const *,std::allocator<wchar_t const *>> *)
.text$mn:00002FB6                 jmp     short loc_2F99
.text$mn:00002FB8 ; ---------------------------------------------------------------------------
.text$mn:00002FB8
.text$mn:00002FB8 loc_2FB8:                               ; CODE XREF: __catch$??$_Uninit_move@PAV?$vector@PB_WV?$allocator@PB_W@std@@@std@@PAV12@V?$allocator@V?$vector@PB_WV?$allocator@PB_W@std@@@std@@@2@V12@@std@@YAPAV?$vector@PB_WV?$allocator@PB_W@std@@@0@PAV10@00AAU?$_Wrap_alloc@V?$allocator@V?$vector@PB_WV?$allocator@PB_W@std@@@std@@@std@@@0@0U_Nonscalar_ptr_iterator_tag@0@@Z$0+11j
.text$mn:00002FB8                 push    0
.text$mn:00002FBA                 push    0
.text$mn:00002FBC                 call    __CxxThrowException@8 ; _CxxThrowException(x,x)
.text$mn:00002FBC __catch$??$_Uninit_move@PAV?$vector@PB_WV?$allocator@PB_W@std@@@std@@PAV12@V?$allocator@V?$vector@PB_WV?$allocator@PB_W@std@@@std@@@2@V12@@std@@YAPAV?$vector@PB_WV?$allocator@PB_W@std@@@0@PAV10@00AAU?$_Wrap_alloc@V?$allocator@V?$vector@PB_WV?$allocator@PB_W@std@@@std@@@std@@@0@0U_Nonscalar_ptr_iterator_tag@0@@Z$0 endp
.text$mn:00002FBC
.text$mn:00002FC1 ; ---------------------------------------------------------------------------
.text$mn:00002FC1                 mov     eax, offset $LN13
.text$mn:00002FC6                 retn
.text$mn:00002FC7 ; ---------------------------------------------------------------------------
.text$mn:00002FC7 ; START OF FUNCTION CHUNK FOR ??$_Uninit_move@PAV?$vector@PB_WV?$allocator@PB_W@std@@@std@@PAV12@V?$allocator@V?$vector@PB_WV?$allocator@PB_W@std@@@std@@@2@V12@@std@@YAPAV?$vector@PB_WV?$allocator@PB_W@std@@@0@PAV10@00AAU?$_Wrap_alloc@V?$allocator@V?$vector@PB_WV?$allocator@PB_W@std@@@std@@@std@@@0@0U_Nonscalar_ptr_iterator_tag@0@@Z
.text$mn:00002FC7
.text$mn:00002FC7 loc_2FC7:                               ; CODE XREF: std::_Uninit_move<std::vector<wchar_t const *,std::allocator<wchar_t const *>> *,std::vector<wchar_t const *,std::allocator<wchar_t const *>> *,std::allocator<std::vector<wchar_t const *,std::allocator<wchar_t const *>>>,std::vector<wchar_t const *,std::allocator<wchar_t const *>>>(std::vector<wchar_t const *,std::allocator<wchar_t const *>> *,std::vector<wchar_t const *,std::allocator<wchar_t const *>> *,std::vector<wchar_t const *,std::allocator<wchar_t const *>> *,std::_Wrap_alloc<std::allocator<std::vector<wchar_t const *,std::allocator<wchar_t const *>>>> &,std::vector<wchar_t const *,std::allocator<wchar_t const *>> *,std::_Nonscalar_ptr_iterator_tag):loc_2F95j
.text$mn:00002FC7                 mov     [ebp+var_4], 0FFFFFFFFh
.text$mn:00002FCE                 jmp     short loc_2FD7
.text$mn:00002FCE ; END OF FUNCTION CHUNK FOR ??$_Uninit_move@PAV?$vector@PB_WV?$allocator@PB_W@std@@@std@@PAV12@V?$allocator@V?$vector@PB_WV?$allocator@PB_W@std@@@std@@@2@V12@@std@@YAPAV?$vector@PB_WV?$allocator@PB_W@std@@@0@PAV10@00AAU?$_Wrap_alloc@V?$allocator@V?$vector@PB_WV?$allocator@PB_W@std@@@std@@@std@@@0@0U_Nonscalar_ptr_iterator_tag@0@@Z
.text$mn:00002FD0
.text$mn:00002FD0 ; =============== S U B R O U T I N E =======================================
.text$mn:00002FD0
.text$mn:00002FD0
.text$mn:00002FD0 $LN13           proc near               ; DATA XREF: .text$mn:00002FC1o
.text$mn:00002FD0                 mov     dword ptr [ebp-4], 0FFFFFFFFh
.text$mn:00002FD0 $LN13           endp ; sp-analysis failed
.text$mn:00002FD0
.text$mn:00002FD7 ; START OF FUNCTION CHUNK FOR ??$_Uninit_move@PAV?$vector@PB_WV?$allocator@PB_W@std@@@std@@PAV12@V?$allocator@V?$vector@PB_WV?$allocator@PB_W@std@@@std@@@2@V12@@std@@YAPAV?$vector@PB_WV?$allocator@PB_W@std@@@0@PAV10@00AAU?$_Wrap_alloc@V?$allocator@V?$vector@PB_WV?$allocator@PB_W@std@@@std@@@std@@@0@0U_Nonscalar_ptr_iterator_tag@0@@Z
.text$mn:00002FD7
.text$mn:00002FD7 loc_2FD7:                               ; CODE XREF: std::_Uninit_move<std::vector<wchar_t const *,std::allocator<wchar_t const *>> *,std::vector<wchar_t const *,std::allocator<wchar_t const *>> *,std::allocator<std::vector<wchar_t const *,std::allocator<wchar_t const *>>>,std::vector<wchar_t const *,std::allocator<wchar_t const *>>>(std::vector<wchar_t const *,std::allocator<wchar_t const *>> *,std::vector<wchar_t const *,std::allocator<wchar_t const *>> *,std::vector<wchar_t const *,std::allocator<wchar_t const *>> *,std::_Wrap_alloc<std::allocator<std::vector<wchar_t const *,std::allocator<wchar_t const *>>>> &,std::vector<wchar_t const *,std::allocator<wchar_t const *>> *,std::_Nonscalar_ptr_iterator_tag)+CEj
.text$mn:00002FD7                 mov     eax, [ebp+arg_8]
.text$mn:00002FDA                 mov     ecx, [ebp+var_C]
.text$mn:00002FDD                 mov     large fs:0, ecx
.text$mn:00002FE4                 pop     ecx
.text$mn:00002FE5                 pop     edi
.text$mn:00002FE6                 pop     esi
.text$mn:00002FE7                 pop     ebx
.text$mn:00002FE8                 mov     esp, ebp
.text$mn:00002FEA                 pop     ebp
.text$mn:00002FEB                 retn
.text$mn:00002FEB ; END OF FUNCTION CHUNK FOR ??$_Uninit_move@PAV?$vector@PB_WV?$allocator@PB_W@std@@@std@@PAV12@V?$allocator@V?$vector@PB_WV?$allocator@PB_W@std@@@std@@@2@V12@@std@@YAPAV?$vector@PB_WV?$allocator@PB_W@std@@@0@PAV10@00AAU?$_Wrap_alloc@V?$allocator@V?$vector@PB_WV?$allocator@PB_W@std@@@std@@@std@@@0@0U_Nonscalar_ptr_iterator_tag@0@@Z
.text$mn:00002FEB _text$mn        ends
.text$mn:00002FEB
.text$x:00002FEC ; ===========================================================================
.text$x:00002FEC
.text$x:00002FEC ; Segment type: Pure code
.text$x:00002FEC ; Segment permissions: Read/Execute
.text$x:00002FEC _text$x         segment para public 'CODE' use32
.text$x:00002FEC                 assume cs:_text$x
.text$x:00002FEC                 ;org 2FECh
.text$x:00002FEC ; COMDAT (pick associative to section at 2F00)
.text$x:00002FEC                 assume es:nothing, ss:nothing, ds:_data, fs:nothing, gs:nothing
.text$x:00002FEC
.text$x:00002FEC ; =============== S U B R O U T I N E =======================================
.text$x:00002FEC
.text$x:00002FEC
.text$x:00002FEC __ehhandler$??$_Uninit_move@PAV?$vector@PB_WV?$allocator@PB_W@std@@@std@@PAV12@V?$allocator@V?$vector@PB_WV?$allocator@PB_W@std@@@std@@@2@V12@@std@@YAPAV?$vector@PB_WV?$allocator@PB_W@std@@@0@PAV10@00AAU?$_Wrap_alloc@V?$allocator@V?$vector@PB_WV?$allocator@PB_W@std@@@std@@@std@@@0@0U_Nonscalar_ptr_iterator_tag@0@@Z proc near
.text$x:00002FEC                                         ; DATA XREF: std::_Uninit_move<std::vector<wchar_t const *,std::allocator<wchar_t const *>> *,std::vector<wchar_t const *,std::allocator<wchar_t const *>> *,std::allocator<std::vector<wchar_t const *,std::allocator<wchar_t const *>>>,std::vector<wchar_t const *,std::allocator<wchar_t const *>>>(std::vector<wchar_t const *,std::allocator<wchar_t const *>> *,std::vector<wchar_t const *,std::allocator<wchar_t const *>> *,std::vector<wchar_t const *,std::allocator<wchar_t const *>> *,std::_Wrap_alloc<std::allocator<std::vector<wchar_t const *,std::allocator<wchar_t const *>>>> &,std::vector<wchar_t const *,std::allocator<wchar_t const *>> *,std::_Nonscalar_ptr_iterator_tag)+5o
.text$x:00002FEC
.text$x:00002FEC arg_4           = dword ptr  8
.text$x:00002FEC
.text$x:00002FEC                 mov     edx, [esp+arg_4]
.text$x:00002FF0                 lea     eax, [edx+0Ch]
.text$x:00002FF3                 mov     ecx, [edx-18h]
.text$x:00002FF6                 xor     ecx, eax
.text$x:00002FF8                 call    @__security_check_cookie@4 ; __security_check_cookie(x)
.text$x:00002FFD                 mov     eax, offset __ehfuncinfo$??$_Uninit_move@PAV?$vector@PB_WV?$allocator@PB_W@std@@@std@@PAV12@V?$allocator@V?$vector@PB_WV?$allocator@PB_W@std@@@std@@@2@V12@@std@@YAPAV?$vector@PB_WV?$allocator@PB_W@std@@@0@PAV10@00AAU?$_Wrap_alloc@V?$allocator@V?$vector@PB_WV?$allocator@PB_W@std@@@std@@@std@@@0@0U_Nonscalar_ptr_iterator_tag@0@@Z
.text$x:00003002                 jmp     ___CxxFrameHandler3
.text$x:00003002 __ehhandler$??$_Uninit_move@PAV?$vector@PB_WV?$allocator@PB_W@std@@@std@@PAV12@V?$allocator@V?$vector@PB_WV?$allocator@PB_W@std@@@std@@@2@V12@@std@@YAPAV?$vector@PB_WV?$allocator@PB_W@std@@@0@PAV10@00AAU?$_Wrap_alloc@V?$allocator@V?$vector@PB_WV?$allocator@PB_W@std@@@std@@@std@@@0@0U_Nonscalar_ptr_iterator_tag@0@@Z endp
.text$x:00003002
.text$x:00003002 ; ---------------------------------------------------------------------------
.text$x:00003007                 align 4
.text$x:00003007 _text$x         ends
.text$x:00003007
.text$mn:00003008 ; ===========================================================================
.text$mn:00003008
.text$mn:00003008 ; Segment type: Pure code
.text$mn:00003008 ; Segment permissions: Read/Execute
.text$mn:00003008 _text$mn        segment para public 'CODE' use32
.text$mn:00003008                 assume cs:_text$mn
.text$mn:00003008                 ;org 3008h
.text$mn:00003008 ; COMDAT (pick any)
.text$mn:00003008                 assume es:nothing, ss:nothing, ds:_data, fs:nothing, gs:nothing
.text$mn:00003008
.text$mn:00003008 ; =============== S U B R O U T I N E =======================================
.text$mn:00003008
.text$mn:00003008 ; Attributes: bp-based frame
.text$mn:00003008
.text$mn:00003008 ; int __cdecl std::_Uninit_move<wchar_t const *,wchar_t const *,wchar_t const *>(void *Src, int, void *Dst)
.text$mn:00003008                 public ??$_Uninit_move@PB_WPB_WPB_W@std@@YAPAPB_WPAPB_W00AAU?$_Wrap_alloc@V?$allocator@PB_W@std@@@0@0U_Scalar_ptr_iterator_tag@0@@Z
.text$mn:00003008 ??$_Uninit_move@PB_WPB_WPB_W@std@@YAPAPB_WPAPB_W00AAU?$_Wrap_alloc@V?$allocator@PB_W@std@@@0@0U_Scalar_ptr_iterator_tag@0@@Z proc near
.text$mn:00003008                                         ; CODE XREF: std::_Uninit_move<wchar_t const * *,wchar_t const * *,std::_Wrap_alloc<std::allocator<wchar_t const *>>>(wchar_t const * *,wchar_t const * *,wchar_t const * *,std::_Wrap_alloc<std::allocator<wchar_t const *>> &)+39p
.text$mn:00003008
.text$mn:00003008 var_4           = dword ptr -4
.text$mn:00003008 Src             = dword ptr  8
.text$mn:00003008 arg_4           = dword ptr  0Ch
.text$mn:00003008 Dst             = dword ptr  10h
.text$mn:00003008
.text$mn:00003008                 push    ebp
.text$mn:00003009                 mov     ebp, esp
.text$mn:0000300B                 push    ecx
.text$mn:0000300C                 push    1D6h            ; unsigned int
.text$mn:00003011                 push    offset ??_C@_1IO@LKIDJAMC@?$AAC?$AA?3?$AA?2?$AAP?$AAr?$AAo?$AAg?$AAr?$AAa?$AAm?$AA?5?$AAF?$AAi?$AAl?$AAe?$AAs?$AA?5?$AA?$CI?$AAx?$AA8?$AA6?$AA?$CJ?$AA?2?$AAM?$AAi?$AAc?$AAr?$AAo?$AAs?$AAo?$AAf?$AAt@ ; "C:\\Program Files (x86)\\Microsoft Visu"...
.text$mn:00003016                 mov     eax, [ebp+arg_4]
.text$mn:00003019                 push    eax             ; int
.text$mn:0000301A                 mov     ecx, [ebp+Src]
.text$mn:0000301D                 push    ecx             ; int
.text$mn:0000301E                 call    ??$_Debug_range@PAPB_W@std@@YAXPAPB_W0PB_WI@Z ; std::_Debug_range<wchar_t const * *>(wchar_t const * *,wchar_t const * *,wchar_t const *,uint)
.text$mn:00003023                 add     esp, 10h
.text$mn:00003026                 push    1D7h            ; unsigned int
.text$mn:0000302B                 push    offset ??_C@_1IO@LKIDJAMC@?$AAC?$AA?3?$AA?2?$AAP?$AAr?$AAo?$AAg?$AAr?$AAa?$AAm?$AA?5?$AAF?$AAi?$AAl?$AAe?$AAs?$AA?5?$AA?$CI?$AAx?$AA8?$AA6?$AA?$CJ?$AA?2?$AAM?$AAi?$AAc?$AAr?$AAo?$AAs?$AAo?$AAf?$AAt@ ; "C:\\Program Files (x86)\\Microsoft Visu"...
.text$mn:00003030                 mov     edx, [ebp+Dst]
.text$mn:00003033                 push    edx             ; int
.text$mn:00003034                 call    ??$_Debug_pointer@PB_W@std@@YAXPAPB_WPB_WI@Z ; std::_Debug_pointer<wchar_t const *>(wchar_t const * *,wchar_t const *,uint)
.text$mn:00003039                 add     esp, 0Ch
.text$mn:0000303C                 mov     eax, [ebp+arg_4]
.text$mn:0000303F                 sub     eax, [ebp+Src]
.text$mn:00003042                 sar     eax, 2
.text$mn:00003045                 mov     [ebp+var_4], eax
.text$mn:00003048                 mov     ecx, [ebp+var_4]
.text$mn:0000304B                 shl     ecx, 2
.text$mn:0000304E                 push    ecx             ; Size
.text$mn:0000304F                 mov     edx, [ebp+Src]
.text$mn:00003052                 push    edx             ; Src
.text$mn:00003053                 mov     eax, [ebp+Dst]
.text$mn:00003056                 push    eax             ; Dst
.text$mn:00003057                 call    _memmove
.text$mn:0000305C                 add     esp, 0Ch
.text$mn:0000305F                 mov     ecx, [ebp+var_4]
.text$mn:00003062                 lea     eax, [eax+ecx*4]
.text$mn:00003065                 mov     esp, ebp
.text$mn:00003067                 pop     ebp
.text$mn:00003068                 retn
.text$mn:00003068 ??$_Uninit_move@PB_WPB_WPB_W@std@@YAPAPB_WPAPB_W00AAU?$_Wrap_alloc@V?$allocator@PB_W@std@@@0@0U_Scalar_ptr_iterator_tag@0@@Z endp
.text$mn:00003068
.text$mn:00003068 ; ---------------------------------------------------------------------------
.text$mn:00003069                 align 4
.text$mn:00003069 _text$mn        ends
.text$mn:00003069
.text$mn:0000306C ; ===========================================================================
.text$mn:0000306C
.text$mn:0000306C ; Segment type: Pure code
.text$mn:0000306C ; Segment permissions: Read/Execute
.text$mn:0000306C _text$mn        segment para public 'CODE' use32
.text$mn:0000306C                 assume cs:_text$mn
.text$mn:0000306C                 ;org 306Ch
.text$mn:0000306C ; COMDAT (pick any)
.text$mn:0000306C                 assume es:nothing, ss:nothing, ds:_data, fs:nothing, gs:nothing
.text$mn:0000306C
.text$mn:0000306C ; =============== S U B R O U T I N E =======================================
.text$mn:0000306C
.text$mn:0000306C ; Attributes: bp-based frame
.text$mn:0000306C
.text$mn:0000306C ; wchar_t const * * __cdecl std::_Uninitialized_copy<class std::_Vector_const_iterator<class std::_Vector_val<struct std::_Simple_types<wchar_t const *>>>, wchar_t const * *, struct std::_Wrap_alloc<class std::allocator<wchar_t const *>>>(class std::_Vector_const_iterator<class std::_Vector_val<struct std::_Simple_types<wchar_t const *>>>, class std::_Vector_const_iterator<class std::_Vector_val<struct std::_Simple_types<wchar_t const *>>>, wchar_t const * *, struct std::_Wrap_alloc<class std::allocator<wchar_t const *>> &)
.text$mn:0000306C                 public ??$_Uninitialized_copy@V?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@PB_W@std@@@std@@@std@@PAPB_WU?$_Wrap_alloc@V?$allocator@PB_W@std@@@2@@std@@YAPAPB_WV?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@PB_W@std@@@std@@@0@0PAPB_WAAU?$_Wrap_alloc@V?$allocator@PB_W@std@@@0@@Z
.text$mn:0000306C ??$_Uninitialized_copy@V?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@PB_W@std@@@std@@@std@@PAPB_WU?$_Wrap_alloc@V?$allocator@PB_W@std@@@2@@std@@YAPAPB_WV?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@PB_W@std@@@std@@@0@0PAPB_WAAU?$_Wrap_alloc@V?$allocator@PB_W@std@@@0@@Z proc near
.text$mn:0000306C                                         ; CODE XREF: std::vector<wchar_t const *,std::allocator<wchar_t const *>>::_Ucopy<std::_Vector_const_iterator<std::_Vector_val<std::_Simple_types<wchar_t const *>>>>(std::_Vector_const_iterator<std::_Vector_val<std::_Simple_types<wchar_t const *>>>,std::_Vector_const_iterator<std::_Vector_val<std::_Simple_types<wchar_t const *>>>,wchar_t const * *)+83p
.text$mn:0000306C
.text$mn:0000306C var_34          = dword ptr -34h
.text$mn:0000306C var_30          = dword ptr -30h
.text$mn:0000306C var_2C          = dword ptr -2Ch
.text$mn:0000306C var_28          = dword ptr -28h
.text$mn:0000306C var_24          = dword ptr -24h
.text$mn:0000306C var_20          = dword ptr -20h
.text$mn:0000306C Src             = dword ptr -1Ch
.text$mn:0000306C var_18          = dword ptr -18h
.text$mn:0000306C var_14          = dword ptr -14h
.text$mn:0000306C var_10          = dword ptr -10h
.text$mn:0000306C var_C           = dword ptr -0Ch
.text$mn:0000306C var_4           = dword ptr -4
.text$mn:0000306C arg_0           = byte ptr  8
.text$mn:0000306C arg_C           = byte ptr  14h
.text$mn:0000306C arg_18          = dword ptr  20h
.text$mn:0000306C arg_1C          = dword ptr  24h
.text$mn:0000306C
.text$mn:0000306C                 push    ebp
.text$mn:0000306D                 mov     ebp, esp
.text$mn:0000306F                 push    0FFFFFFFFh
.text$mn:00003071                 push    offset __ehhandler$??$_Uninitialized_copy@V?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@PB_W@std@@@std@@@std@@PAPB_WU?$_Wrap_alloc@V?$allocator@PB_W@std@@@2@@std@@YAPAPB_WV?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@PB_W@std@@@std@@@0@0PAPB_WAAU?$_Wrap_alloc@V?$allocator@PB_W@std@@@0@@Z
.text$mn:00003076                 mov     eax, large fs:0
.text$mn:0000307C                 push    eax
.text$mn:0000307D                 sub     esp, 28h
.text$mn:00003080                 mov     eax, dword ptr ds:___security_cookie
.text$mn:00003085                 xor     eax, ebp
.text$mn:00003087                 push    eax
.text$mn:00003088                 lea     eax, [ebp+var_C]
.text$mn:0000308B                 mov     large fs:0, eax
.text$mn:00003091                 mov     [ebp+var_4], 1
.text$mn:00003098                 mov     eax, [ebp+arg_1C]
.text$mn:0000309B                 push    eax             ; int
.text$mn:0000309C                 mov     ecx, [ebp+arg_18]
.text$mn:0000309F                 push    ecx
.text$mn:000030A0                 call    ??$_Unchecked@PAPB_W@std@@YAPAPB_WPAPB_W@Z ; std::_Unchecked<wchar_t const * *>(wchar_t const * *)
.text$mn:000030A5                 add     esp, 4
.text$mn:000030A8                 push    eax             ; Dst
.text$mn:000030A9                 sub     esp, 0Ch
.text$mn:000030AC                 mov     ecx, esp
.text$mn:000030AE                 mov     [ebp+var_28], esp
.text$mn:000030B1                 lea     edx, [ebp+arg_C]
.text$mn:000030B4                 push    edx             ; struct std::_Iterator_base12 *
.text$mn:000030B5                 call    ??0?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@PB_W@std@@@std@@@std@@QAE@ABV01@@Z ; std::_Vector_const_iterator<std::_Vector_val<std::_Simple_types<wchar_t const *>>>::_Vector_const_iterator<std::_Vector_val<std::_Simple_types<wchar_t const *>>>(std::_Vector_const_iterator<std::_Vector_val<std::_Simple_types<wchar_t const *>>> const &)
.text$mn:000030BA                 mov     [ebp+var_10], eax
.text$mn:000030BD                 mov     eax, [ebp+var_10]
.text$mn:000030C0                 mov     [ebp+var_2C], eax
.text$mn:000030C3                 mov     byte ptr [ebp+var_4], 2
.text$mn:000030C7                 mov     byte ptr [ebp+var_4], 1
.text$mn:000030CB                 call    ??$_Unchecked@V?$_Vector_val@U?$_Simple_types@PB_W@std@@@std@@@std@@YAPBQB_WV?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@PB_W@std@@@std@@@0@@Z ; std::_Unchecked<std::_Vector_val<std::_Simple_types<wchar_t const *>>>(std::_Vector_const_iterator<std::_Vector_val<std::_Simple_types<wchar_t const *>>>)
.text$mn:000030D0                 add     esp, 0Ch
.text$mn:000030D3                 mov     [ebp+var_14], eax
.text$mn:000030D6                 mov     ecx, [ebp+var_14]
.text$mn:000030D9                 push    ecx             ; int
.text$mn:000030DA                 sub     esp, 0Ch
.text$mn:000030DD                 mov     ecx, esp
.text$mn:000030DF                 mov     [ebp+var_30], esp
.text$mn:000030E2                 lea     edx, [ebp+arg_0]
.text$mn:000030E5                 push    edx             ; struct std::_Iterator_base12 *
.text$mn:000030E6                 call    ??0?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@PB_W@std@@@std@@@std@@QAE@ABV01@@Z ; std::_Vector_const_iterator<std::_Vector_val<std::_Simple_types<wchar_t const *>>>::_Vector_const_iterator<std::_Vector_val<std::_Simple_types<wchar_t const *>>>(std::_Vector_const_iterator<std::_Vector_val<std::_Simple_types<wchar_t const *>>> const &)
.text$mn:000030EB                 mov     [ebp+var_18], eax
.text$mn:000030EE                 mov     eax, [ebp+var_18]
.text$mn:000030F1                 mov     [ebp+var_34], eax
.text$mn:000030F4                 mov     byte ptr [ebp+var_4], 3
.text$mn:000030F8                 mov     byte ptr [ebp+var_4], 1
.text$mn:000030FC                 call    ??$_Unchecked@V?$_Vector_val@U?$_Simple_types@PB_W@std@@@std@@@std@@YAPBQB_WV?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@PB_W@std@@@std@@@0@@Z ; std::_Unchecked<std::_Vector_val<std::_Simple_types<wchar_t const *>>>(std::_Vector_const_iterator<std::_Vector_val<std::_Simple_types<wchar_t const *>>>)
.text$mn:00003101                 add     esp, 0Ch
.text$mn:00003104                 mov     [ebp+Src], eax
.text$mn:00003107                 mov     ecx, [ebp+Src]
.text$mn:0000310A                 push    ecx             ; Src
.text$mn:0000310B                 call    ??$_Uninit_copy@PBQB_WPAPB_WU?$_Wrap_alloc@V?$allocator@PB_W@std@@@std@@@std@@YAPAPB_WPBQB_W0PAPB_WAAU?$_Wrap_alloc@V?$allocator@PB_W@std@@@0@@Z ; std::_Uninit_copy<wchar_t const * const *,wchar_t const * *,std::_Wrap_alloc<std::allocator<wchar_t const *>>>(wchar_t const * const *,wchar_t const * const *,wchar_t const * *,std::_Wrap_alloc<std::allocator<wchar_t const *>> &)
.text$mn:00003110                 add     esp, 10h
.text$mn:00003113                 mov     [ebp+var_20], eax
.text$mn:00003116                 mov     edx, [ebp+var_20]
.text$mn:00003119                 push    edx
.text$mn:0000311A                 lea     eax, [ebp+arg_18]
.text$mn:0000311D                 push    eax
.text$mn:0000311E                 call    ??$_Rechecked@PAPB_WPAPB_W@std@@YAAAPAPB_WAAPAPB_WPAPB_W@Z ; std::_Rechecked<wchar_t const * *,wchar_t const * *>(wchar_t const * * &,wchar_t const * *)
.text$mn:00003123                 add     esp, 8
.text$mn:00003126                 mov     ecx, [eax]
.text$mn:00003128                 mov     [ebp+var_24], ecx
.text$mn:0000312B                 mov     byte ptr [ebp+var_4], 0
.text$mn:0000312F                 lea     ecx, [ebp+arg_0]
.text$mn:00003132                 call    ??1?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@PB_W@std@@@std@@@std@@QAE@XZ ; std::_Vector_const_iterator<std::_Vector_val<std::_Simple_types<wchar_t const *>>>::~_Vector_const_iterator<std::_Vector_val<std::_Simple_types<wchar_t const *>>>(void)
.text$mn:00003137                 mov     [ebp+var_4], 0FFFFFFFFh
.text$mn:0000313E                 lea     ecx, [ebp+arg_C]
.text$mn:00003141                 call    ??1?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@PB_W@std@@@std@@@std@@QAE@XZ ; std::_Vector_const_iterator<std::_Vector_val<std::_Simple_types<wchar_t const *>>>::~_Vector_const_iterator<std::_Vector_val<std::_Simple_types<wchar_t const *>>>(void)
.text$mn:00003146                 mov     eax, [ebp+var_24]
.text$mn:00003149                 mov     ecx, [ebp+var_C]
.text$mn:0000314C                 mov     large fs:0, ecx
.text$mn:00003153                 pop     ecx
.text$mn:00003154                 mov     esp, ebp
.text$mn:00003156                 pop     ebp
.text$mn:00003157                 retn
.text$mn:00003157 ??$_Uninitialized_copy@V?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@PB_W@std@@@std@@@std@@PAPB_WU?$_Wrap_alloc@V?$allocator@PB_W@std@@@2@@std@@YAPAPB_WV?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@PB_W@std@@@std@@@0@0PAPB_WAAU?$_Wrap_alloc@V?$allocator@PB_W@std@@@0@@Z endp
.text$mn:00003157
.text$mn:00003157 _text$mn        ends
.text$mn:00003157
.text$x:00003158 ; ===========================================================================
.text$x:00003158
.text$x:00003158 ; Segment type: Pure code
.text$x:00003158 ; Segment permissions: Read/Execute
.text$x:00003158 _text$x         segment para public 'CODE' use32
.text$x:00003158                 assume cs:_text$x
.text$x:00003158                 ;org 3158h
.text$x:00003158 ; COMDAT (pick associative to section at 306C)
.text$x:00003158                 assume es:nothing, ss:nothing, ds:_data, fs:nothing, gs:nothing
.text$x:00003158
.text$x:00003158 ; =============== S U B R O U T I N E =======================================
.text$x:00003158
.text$x:00003158
.text$x:00003158 __unwindfunclet$??$_Uninitialized_copy@V?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@PB_W@std@@@std@@@std@@PAPB_WU?$_Wrap_alloc@V?$allocator@PB_W@std@@@2@@std@@YAPAPB_WV?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@PB_W@std@@@std@@@0@0PAPB_WAAU?$_Wrap_alloc@V?$allocator@PB_W@std@@@0@@Z$0 proc near
.text$x:00003158                                         ; DATA XREF: .xdata$x:0000A24Co
.text$x:00003158                 lea     ecx, [ebp+14h]
.text$x:0000315B                 jmp     ??1?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@PB_W@std@@@std@@@std@@QAE@XZ ; std::_Vector_const_iterator<std::_Vector_val<std::_Simple_types<wchar_t const *>>>::~_Vector_const_iterator<std::_Vector_val<std::_Simple_types<wchar_t const *>>>(void)
.text$x:0000315B __unwindfunclet$??$_Uninitialized_copy@V?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@PB_W@std@@@std@@@std@@PAPB_WU?$_Wrap_alloc@V?$allocator@PB_W@std@@@2@@std@@YAPAPB_WV?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@PB_W@std@@@std@@@0@0PAPB_WAAU?$_Wrap_alloc@V?$allocator@PB_W@std@@@0@@Z$0 endp
.text$x:0000315B
.text$x:00003160
.text$x:00003160 ; =============== S U B R O U T I N E =======================================
.text$x:00003160
.text$x:00003160
.text$x:00003160 __unwindfunclet$??$_Uninitialized_copy@V?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@PB_W@std@@@std@@@std@@PAPB_WU?$_Wrap_alloc@V?$allocator@PB_W@std@@@2@@std@@YAPAPB_WV?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@PB_W@std@@@std@@@0@0PAPB_WAAU?$_Wrap_alloc@V?$allocator@PB_W@std@@@0@@Z$1 proc near
.text$x:00003160                                         ; DATA XREF: .xdata$x:0000A254o
.text$x:00003160                 lea     ecx, [ebp+8]
.text$x:00003163                 jmp     ??1?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@PB_W@std@@@std@@@std@@QAE@XZ ; std::_Vector_const_iterator<std::_Vector_val<std::_Simple_types<wchar_t const *>>>::~_Vector_const_iterator<std::_Vector_val<std::_Simple_types<wchar_t const *>>>(void)
.text$x:00003163 __unwindfunclet$??$_Uninitialized_copy@V?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@PB_W@std@@@std@@@std@@PAPB_WU?$_Wrap_alloc@V?$allocator@PB_W@std@@@2@@std@@YAPAPB_WV?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@PB_W@std@@@std@@@0@0PAPB_WAAU?$_Wrap_alloc@V?$allocator@PB_W@std@@@0@@Z$1 endp
.text$x:00003163
.text$x:00003168
.text$x:00003168 ; =============== S U B R O U T I N E =======================================
.text$x:00003168
.text$x:00003168
.text$x:00003168 __unwindfunclet$??$_Uninitialized_copy@V?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@PB_W@std@@@std@@@std@@PAPB_WU?$_Wrap_alloc@V?$allocator@PB_W@std@@@2@@std@@YAPAPB_WV?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@PB_W@std@@@std@@@0@0PAPB_WAAU?$_Wrap_alloc@V?$allocator@PB_W@std@@@0@@Z$2 proc near
.text$x:00003168                                         ; DATA XREF: .xdata$x:0000A25Co
.text$x:00003168                 mov     ecx, [ebp-28h]
.text$x:0000316B                 jmp     ??1?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@PB_W@std@@@std@@@std@@QAE@XZ ; std::_Vector_const_iterator<std::_Vector_val<std::_Simple_types<wchar_t const *>>>::~_Vector_const_iterator<std::_Vector_val<std::_Simple_types<wchar_t const *>>>(void)
.text$x:0000316B __unwindfunclet$??$_Uninitialized_copy@V?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@PB_W@std@@@std@@@std@@PAPB_WU?$_Wrap_alloc@V?$allocator@PB_W@std@@@2@@std@@YAPAPB_WV?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@PB_W@std@@@std@@@0@0PAPB_WAAU?$_Wrap_alloc@V?$allocator@PB_W@std@@@0@@Z$2 endp
.text$x:0000316B
.text$x:00003170
.text$x:00003170 ; =============== S U B R O U T I N E =======================================
.text$x:00003170
.text$x:00003170
.text$x:00003170 __unwindfunclet$??$_Uninitialized_copy@V?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@PB_W@std@@@std@@@std@@PAPB_WU?$_Wrap_alloc@V?$allocator@PB_W@std@@@2@@std@@YAPAPB_WV?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@PB_W@std@@@std@@@0@0PAPB_WAAU?$_Wrap_alloc@V?$allocator@PB_W@std@@@0@@Z$3 proc near
.text$x:00003170                                         ; DATA XREF: .xdata$x:0000A264o
.text$x:00003170                 mov     ecx, [ebp-30h]
.text$x:00003173                 jmp     ??1?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@PB_W@std@@@std@@@std@@QAE@XZ ; std::_Vector_const_iterator<std::_Vector_val<std::_Simple_types<wchar_t const *>>>::~_Vector_const_iterator<std::_Vector_val<std::_Simple_types<wchar_t const *>>>(void)
.text$x:00003173 __unwindfunclet$??$_Uninitialized_copy@V?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@PB_W@std@@@std@@@std@@PAPB_WU?$_Wrap_alloc@V?$allocator@PB_W@std@@@2@@std@@YAPAPB_WV?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@PB_W@std@@@std@@@0@0PAPB_WAAU?$_Wrap_alloc@V?$allocator@PB_W@std@@@0@@Z$3 endp
.text$x:00003173
.text$x:00003178
.text$x:00003178 ; =============== S U B R O U T I N E =======================================
.text$x:00003178
.text$x:00003178
.text$x:00003178 __ehhandler$??$_Uninitialized_copy@V?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@PB_W@std@@@std@@@std@@PAPB_WU?$_Wrap_alloc@V?$allocator@PB_W@std@@@2@@std@@YAPAPB_WV?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@PB_W@std@@@std@@@0@0PAPB_WAAU?$_Wrap_alloc@V?$allocator@PB_W@std@@@0@@Z proc near
.text$x:00003178                                         ; DATA XREF: std::_Uninitialized_copy<std::_Vector_const_iterator<std::_Vector_val<std::_Simple_types<wchar_t const *>>>,wchar_t const * *,std::_Wrap_alloc<std::allocator<wchar_t const *>>>(std::_Vector_const_iterator<std::_Vector_val<std::_Simple_types<wchar_t const *>>>,std::_Vector_const_iterator<std::_Vector_val<std::_Simple_types<wchar_t const *>>>,wchar_t const * *,std::_Wrap_alloc<std::allocator<wchar_t const *>> &)+5o
.text$x:00003178
.text$x:00003178 arg_4           = dword ptr  8
.text$x:00003178
.text$x:00003178                 mov     edx, [esp+arg_4]
.text$x:0000317C                 lea     eax, [edx+0Ch]
.text$x:0000317F                 mov     ecx, [edx-2Ch]
.text$x:00003182                 xor     ecx, eax
.text$x:00003184                 call    @__security_check_cookie@4 ; __security_check_cookie(x)
.text$x:00003189                 mov     eax, offset __ehfuncinfo$??$_Uninitialized_copy@V?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@PB_W@std@@@std@@@std@@PAPB_WU?$_Wrap_alloc@V?$allocator@PB_W@std@@@2@@std@@YAPAPB_WV?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@PB_W@std@@@std@@@0@0PAPB_WAAU?$_Wrap_alloc@V?$allocator@PB_W@std@@@0@@Z
.text$x:0000318E                 jmp     ___CxxFrameHandler3
.text$x:0000318E __ehhandler$??$_Uninitialized_copy@V?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@PB_W@std@@@std@@@std@@PAPB_WU?$_Wrap_alloc@V?$allocator@PB_W@std@@@2@@std@@YAPAPB_WV?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@PB_W@std@@@std@@@0@0PAPB_WAAU?$_Wrap_alloc@V?$allocator@PB_W@std@@@0@@Z endp
.text$x:0000318E
.text$x:0000318E ; ---------------------------------------------------------------------------
.text$x:00003193                 align 4
.text$x:00003193 _text$x         ends
.text$x:00003193
.text$mn:00003194 ; ===========================================================================
.text$mn:00003194
.text$mn:00003194 ; Segment type: Pure code
.text$mn:00003194 ; Segment permissions: Read/Execute
.text$mn:00003194 _text$mn        segment para public 'CODE' use32
.text$mn:00003194                 assume cs:_text$mn
.text$mn:00003194                 ;org 3194h
.text$mn:00003194 ; COMDAT (pick any)
.text$mn:00003194                 assume es:nothing, ss:nothing, ds:_data, fs:nothing, gs:nothing
.text$mn:00003194
.text$mn:00003194 ; =============== S U B R O U T I N E =======================================
.text$mn:00003194
.text$mn:00003194 ; Attributes: bp-based frame
.text$mn:00003194
.text$mn:00003194 ; wchar_t const * * __cdecl std::_Uninitialized_move<wchar_t const * *, wchar_t const * *, struct std::_Wrap_alloc<class std::allocator<wchar_t const *>>>(wchar_t const * *, wchar_t const * *, wchar_t const * *, struct std::_Wrap_alloc<class std::allocator<wchar_t const *>> &)
.text$mn:00003194                 public ??$_Uninitialized_move@PAPB_WPAPB_WU?$_Wrap_alloc@V?$allocator@PB_W@std@@@std@@@std@@YAPAPB_WPAPB_W00AAU?$_Wrap_alloc@V?$allocator@PB_W@std@@@0@@Z
.text$mn:00003194 ??$_Uninitialized_move@PAPB_WPAPB_WU?$_Wrap_alloc@V?$allocator@PB_W@std@@@std@@@std@@YAPAPB_WPAPB_W00AAU?$_Wrap_alloc@V?$allocator@PB_W@std@@@0@@Z proc near
.text$mn:00003194                                         ; CODE XREF: std::vector<wchar_t const *,std::allocator<wchar_t const *>>::_Umove<wchar_t const * *>(wchar_t const * *,wchar_t const * *,wchar_t const * *)+25p
.text$mn:00003194
.text$mn:00003194 arg_0           = dword ptr  8
.text$mn:00003194 arg_4           = dword ptr  0Ch
.text$mn:00003194 arg_8           = dword ptr  10h
.text$mn:00003194 arg_C           = dword ptr  14h
.text$mn:00003194
.text$mn:00003194                 push    ebp
.text$mn:00003195                 mov     ebp, esp
.text$mn:00003197                 mov     eax, [ebp+arg_C]
.text$mn:0000319A                 push    eax             ; int
.text$mn:0000319B                 mov     ecx, [ebp+arg_8]
.text$mn:0000319E                 push    ecx
.text$mn:0000319F                 call    ??$_Unchecked@PAPB_W@std@@YAPAPB_WPAPB_W@Z ; std::_Unchecked<wchar_t const * *>(wchar_t const * *)
.text$mn:000031A4                 add     esp, 4
.text$mn:000031A7                 push    eax             ; Dst
.text$mn:000031A8                 mov     edx, [ebp+arg_4]
.text$mn:000031AB                 push    edx
.text$mn:000031AC                 call    ??$_Unchecked@PAPB_W@std@@YAPAPB_WPAPB_W@Z ; std::_Unchecked<wchar_t const * *>(wchar_t const * *)
.text$mn:000031B1                 add     esp, 4
.text$mn:000031B4                 push    eax             ; int
.text$mn:000031B5                 mov     eax, [ebp+arg_0]
.text$mn:000031B8                 push    eax
.text$mn:000031B9                 call    ??$_Unchecked@PAPB_W@std@@YAPAPB_WPAPB_W@Z ; std::_Unchecked<wchar_t const * *>(wchar_t const * *)
.text$mn:000031BE                 add     esp, 4
.text$mn:000031C1                 push    eax             ; Src
.text$mn:000031C2                 call    ??$_Uninit_move@PAPB_WPAPB_WU?$_Wrap_alloc@V?$allocator@PB_W@std@@@std@@@std@@YAPAPB_WPAPB_W00AAU?$_Wrap_alloc@V?$allocator@PB_W@std@@@0@@Z ; std::_Uninit_move<wchar_t const * *,wchar_t const * *,std::_Wrap_alloc<std::allocator<wchar_t const *>>>(wchar_t const * *,wchar_t const * *,wchar_t const * *,std::_Wrap_alloc<std::allocator<wchar_t const *>> &)
.text$mn:000031C7                 add     esp, 10h
.text$mn:000031CA                 push    eax
.text$mn:000031CB                 lea     ecx, [ebp+arg_8]
.text$mn:000031CE                 push    ecx
.text$mn:000031CF                 call    ??$_Rechecked@PAPB_WPAPB_W@std@@YAAAPAPB_WAAPAPB_WPAPB_W@Z ; std::_Rechecked<wchar_t const * *,wchar_t const * *>(wchar_t const * * &,wchar_t const * *)
.text$mn:000031D4                 add     esp, 8
.text$mn:000031D7                 mov     eax, [eax]
.text$mn:000031D9                 pop     ebp
.text$mn:000031DA                 retn
.text$mn:000031DA ??$_Uninitialized_move@PAPB_WPAPB_WU?$_Wrap_alloc@V?$allocator@PB_W@std@@@std@@@std@@YAPAPB_WPAPB_W00AAU?$_Wrap_alloc@V?$allocator@PB_W@std@@@0@@Z endp
.text$mn:000031DA
.text$mn:000031DA ; ---------------------------------------------------------------------------
.text$mn:000031DB                 align 4
.text$mn:000031DB _text$mn        ends
.text$mn:000031DB
.text$mn:000031DC ; ===========================================================================
.text$mn:000031DC
.text$mn:000031DC ; Segment type: Pure code
.text$mn:000031DC ; Segment permissions: Read/Execute
.text$mn:000031DC _text$mn        segment para public 'CODE' use32
.text$mn:000031DC                 assume cs:_text$mn
.text$mn:000031DC                 ;org 31DCh
.text$mn:000031DC ; COMDAT (pick any)
.text$mn:000031DC                 assume es:nothing, ss:nothing, ds:_data, fs:nothing, gs:nothing
.text$mn:000031DC
.text$mn:000031DC ; =============== S U B R O U T I N E =======================================
.text$mn:000031DC
.text$mn:000031DC ; Attributes: bp-based frame
.text$mn:000031DC
.text$mn:000031DC ; struct FunctionValues * __cdecl std::_Uninitialized_move<struct FunctionValues *, struct FunctionValues *, struct std::_Wrap_alloc<class std::allocator<struct FunctionValues>>>(struct FunctionValues *, struct FunctionValues *, struct FunctionValues *, struct std::_Wrap_alloc<class std::allocator<struct FunctionValues>> &)
.text$mn:000031DC                 public ??$_Uninitialized_move@PAUFunctionValues@@PAU1@U?$_Wrap_alloc@V?$allocator@UFunctionValues@@@std@@@std@@@std@@YAPAUFunctionValues@@PAU1@00AAU?$_Wrap_alloc@V?$allocator@UFunctionValues@@@std@@@0@@Z
.text$mn:000031DC ??$_Uninitialized_move@PAUFunctionValues@@PAU1@U?$_Wrap_alloc@V?$allocator@UFunctionValues@@@std@@@std@@@std@@YAPAUFunctionValues@@PAU1@00AAU?$_Wrap_alloc@V?$allocator@UFunctionValues@@@std@@@0@@Z proc near
.text$mn:000031DC                                         ; CODE XREF: std::vector<FunctionValues,std::allocator<FunctionValues>>::_Umove<FunctionValues *>(FunctionValues *,FunctionValues *,FunctionValues *)+25p
.text$mn:000031DC
.text$mn:000031DC arg_0           = dword ptr  8
.text$mn:000031DC arg_4           = dword ptr  0Ch
.text$mn:000031DC arg_8           = dword ptr  10h
.text$mn:000031DC arg_C           = dword ptr  14h
.text$mn:000031DC
.text$mn:000031DC                 push    ebp
.text$mn:000031DD                 mov     ebp, esp
.text$mn:000031DF                 mov     eax, [ebp+arg_C]
.text$mn:000031E2                 push    eax             ; int
.text$mn:000031E3                 mov     ecx, [ebp+arg_8]
.text$mn:000031E6                 push    ecx
.text$mn:000031E7                 call    ??$_Unchecked@PAUFunctionValues@@@std@@YAPAUFunctionValues@@PAU1@@Z ; std::_Unchecked<FunctionValues *>(FunctionValues *)
.text$mn:000031EC                 add     esp, 4
.text$mn:000031EF                 push    eax             ; void *
.text$mn:000031F0                 mov     edx, [ebp+arg_4]
.text$mn:000031F3                 push    edx
.text$mn:000031F4                 call    ??$_Unchecked@PAUFunctionValues@@@std@@YAPAUFunctionValues@@PAU1@@Z ; std::_Unchecked<FunctionValues *>(FunctionValues *)
.text$mn:000031F9                 add     esp, 4
.text$mn:000031FC                 push    eax             ; int
.text$mn:000031FD                 mov     eax, [ebp+arg_0]
.text$mn:00003200                 push    eax
.text$mn:00003201                 call    ??$_Unchecked@PAUFunctionValues@@@std@@YAPAUFunctionValues@@PAU1@@Z ; std::_Unchecked<FunctionValues *>(FunctionValues *)
.text$mn:00003206                 add     esp, 4
.text$mn:00003209                 push    eax             ; int
.text$mn:0000320A                 call    ??$_Uninit_move@PAUFunctionValues@@PAU1@U?$_Wrap_alloc@V?$allocator@UFunctionValues@@@std@@@std@@@std@@YAPAUFunctionValues@@PAU1@00AAU?$_Wrap_alloc@V?$allocator@UFunctionValues@@@std@@@0@@Z ; std::_Uninit_move<FunctionValues *,FunctionValues *,std::_Wrap_alloc<std::allocator<FunctionValues>>>(FunctionValues *,FunctionValues *,FunctionValues *,std::_Wrap_alloc<std::allocator<FunctionValues>> &)
.text$mn:0000320F                 add     esp, 10h
.text$mn:00003212                 push    eax
.text$mn:00003213                 lea     ecx, [ebp+arg_8]
.text$mn:00003216                 push    ecx
.text$mn:00003217                 call    ??$_Rechecked@PAUFunctionValues@@PAU1@@std@@YAAAPAUFunctionValues@@AAPAU1@PAU1@@Z ; std::_Rechecked<FunctionValues *,FunctionValues *>(FunctionValues * &,FunctionValues *)
.text$mn:0000321C                 add     esp, 8
.text$mn:0000321F                 mov     eax, [eax]
.text$mn:00003221                 pop     ebp
.text$mn:00003222                 retn
.text$mn:00003222 ??$_Uninitialized_move@PAUFunctionValues@@PAU1@U?$_Wrap_alloc@V?$allocator@UFunctionValues@@@std@@@std@@@std@@YAPAUFunctionValues@@PAU1@00AAU?$_Wrap_alloc@V?$allocator@UFunctionValues@@@std@@@0@@Z endp
.text$mn:00003222
.text$mn:00003222 ; ---------------------------------------------------------------------------
.text$mn:00003223                 align 4
.text$mn:00003223 _text$mn        ends
.text$mn:00003223
.text$mn:00003224 ; ===========================================================================
.text$mn:00003224
.text$mn:00003224 ; Segment type: Pure code
.text$mn:00003224 ; Segment permissions: Read/Execute
.text$mn:00003224 _text$mn        segment para public 'CODE' use32
.text$mn:00003224                 assume cs:_text$mn
.text$mn:00003224                 ;org 3224h
.text$mn:00003224 ; COMDAT (pick any)
.text$mn:00003224                 assume es:nothing, ss:nothing, ds:_data, fs:nothing, gs:nothing
.text$mn:00003224
.text$mn:00003224 ; =============== S U B R O U T I N E =======================================
.text$mn:00003224
.text$mn:00003224 ; Attributes: bp-based frame
.text$mn:00003224
.text$mn:00003224 ; struct Token * __cdecl std::_Uninitialized_move<struct Token *, struct Token *, struct std::_Wrap_alloc<class std::allocator<struct Token>>>(struct Token *, struct Token *, struct Token *, struct std::_Wrap_alloc<class std::allocator<struct Token>> &)
.text$mn:00003224                 public ??$_Uninitialized_move@PAUToken@@PAU1@U?$_Wrap_alloc@V?$allocator@UToken@@@std@@@std@@@std@@YAPAUToken@@PAU1@00AAU?$_Wrap_alloc@V?$allocator@UToken@@@std@@@0@@Z
.text$mn:00003224 ??$_Uninitialized_move@PAUToken@@PAU1@U?$_Wrap_alloc@V?$allocator@UToken@@@std@@@std@@@std@@YAPAUToken@@PAU1@00AAU?$_Wrap_alloc@V?$allocator@UToken@@@std@@@0@@Z proc near
.text$mn:00003224                                         ; CODE XREF: std::vector<Token,std::allocator<Token>>::_Umove<Token *>(Token *,Token *,Token *)+25p
.text$mn:00003224
.text$mn:00003224 arg_0           = dword ptr  8
.text$mn:00003224 arg_4           = dword ptr  0Ch
.text$mn:00003224 arg_8           = dword ptr  10h
.text$mn:00003224 arg_C           = dword ptr  14h
.text$mn:00003224
.text$mn:00003224                 push    ebp
.text$mn:00003225                 mov     ebp, esp
.text$mn:00003227                 mov     eax, [ebp+arg_C]
.text$mn:0000322A                 push    eax             ; int
.text$mn:0000322B                 mov     ecx, [ebp+arg_8]
.text$mn:0000322E                 push    ecx
.text$mn:0000322F                 call    ??$_Unchecked@PAUToken@@@std@@YAPAUToken@@PAU1@@Z ; std::_Unchecked<Token *>(Token *)
.text$mn:00003234                 add     esp, 4
.text$mn:00003237                 push    eax             ; void *
.text$mn:00003238                 mov     edx, [ebp+arg_4]
.text$mn:0000323B                 push    edx
.text$mn:0000323C                 call    ??$_Unchecked@PAUToken@@@std@@YAPAUToken@@PAU1@@Z ; std::_Unchecked<Token *>(Token *)
.text$mn:00003241                 add     esp, 4
.text$mn:00003244                 push    eax             ; int
.text$mn:00003245                 mov     eax, [ebp+arg_0]
.text$mn:00003248                 push    eax
.text$mn:00003249                 call    ??$_Unchecked@PAUToken@@@std@@YAPAUToken@@PAU1@@Z ; std::_Unchecked<Token *>(Token *)
.text$mn:0000324E                 add     esp, 4
.text$mn:00003251                 push    eax             ; int
.text$mn:00003252                 call    ??$_Uninit_move@PAUToken@@PAU1@U?$_Wrap_alloc@V?$allocator@UToken@@@std@@@std@@@std@@YAPAUToken@@PAU1@00AAU?$_Wrap_alloc@V?$allocator@UToken@@@std@@@0@@Z ; std::_Uninit_move<Token *,Token *,std::_Wrap_alloc<std::allocator<Token>>>(Token *,Token *,Token *,std::_Wrap_alloc<std::allocator<Token>> &)
.text$mn:00003257                 add     esp, 10h
.text$mn:0000325A                 push    eax
.text$mn:0000325B                 lea     ecx, [ebp+arg_8]
.text$mn:0000325E                 push    ecx
.text$mn:0000325F                 call    ??$_Rechecked@PAUToken@@PAU1@@std@@YAAAPAUToken@@AAPAU1@PAU1@@Z ; std::_Rechecked<Token *,Token *>(Token * &,Token *)
.text$mn:00003264                 add     esp, 8
.text$mn:00003267                 mov     eax, [eax]
.text$mn:00003269                 pop     ebp
.text$mn:0000326A                 retn
.text$mn:0000326A ??$_Uninitialized_move@PAUToken@@PAU1@U?$_Wrap_alloc@V?$allocator@UToken@@@std@@@std@@@std@@YAPAUToken@@PAU1@00AAU?$_Wrap_alloc@V?$allocator@UToken@@@std@@@0@@Z endp
.text$mn:0000326A
.text$mn:0000326A ; ---------------------------------------------------------------------------
.text$mn:0000326B                 align 4
.text$mn:0000326B _text$mn        ends
.text$mn:0000326B
.text$mn:0000326C ; ===========================================================================
.text$mn:0000326C
.text$mn:0000326C ; Segment type: Pure code
.text$mn:0000326C ; Segment permissions: Read/Execute
.text$mn:0000326C _text$mn        segment para public 'CODE' use32
.text$mn:0000326C                 assume cs:_text$mn
.text$mn:0000326C                 ;org 326Ch
.text$mn:0000326C ; COMDAT (pick any)
.text$mn:0000326C                 assume es:nothing, ss:nothing, ds:_data, fs:nothing, gs:nothing
.text$mn:0000326C
.text$mn:0000326C ; =============== S U B R O U T I N E =======================================
.text$mn:0000326C
.text$mn:0000326C ; Attributes: bp-based frame
.text$mn:0000326C
.text$mn:0000326C ; class std::vector<wchar_t const *, class std::allocator<wchar_t const *>> * __cdecl std::_Uninitialized_move<class std::vector<wchar_t const *, class std::allocator<wchar_t const *>> *, class std::vector<wchar_t const *, class std::allocator<wchar_t const *>> *, struct std::_Wrap_alloc<class std::allocator<class std::vector<wchar_t const *, class std::allocator<wchar_t const *>>>>>(class std::vector<wchar_t const *, class std::allocator<wchar_t const *>> *, class std::vector<wchar_t const *, class std::allocator<wchar_t const *>> *, class std::vector<wchar_t const *, class std::allocator<wchar_t const *>> *, struct std::_Wrap_alloc<class std::allocator<class std::vector<wchar_t const *, class std::allocator<wchar_t const *>>>> &)
.text$mn:0000326C                 public ??$_Uninitialized_move@PAV?$vector@PB_WV?$allocator@PB_W@std@@@std@@PAV12@U?$_Wrap_alloc@V?$allocator@V?$vector@PB_WV?$allocator@PB_W@std@@@std@@@std@@@2@@std@@YAPAV?$vector@PB_WV?$allocator@PB_W@std@@@0@PAV10@00AAU?$_Wrap_alloc@V?$allocator@V?$vector@PB_WV?$allocator@PB_W@std@@@std@@@std@@@0@@Z
.text$mn:0000326C ??$_Uninitialized_move@PAV?$vector@PB_WV?$allocator@PB_W@std@@@std@@PAV12@U?$_Wrap_alloc@V?$allocator@V?$vector@PB_WV?$allocator@PB_W@std@@@std@@@std@@@2@@std@@YAPAV?$vector@PB_WV?$allocator@PB_W@std@@@0@PAV10@00AAU?$_Wrap_alloc@V?$allocator@V?$vector@PB_WV?$allocator@PB_W@std@@@std@@@std@@@0@@Z proc near
.text$mn:0000326C                                         ; CODE XREF: std::vector<std::vector<wchar_t const *,std::allocator<wchar_t const *>>,std::allocator<std::vector<wchar_t const *,std::allocator<wchar_t const *>>>>::_Umove<std::vector<wchar_t const *,std::allocator<wchar_t const *>> *>(std::vector<wchar_t const *,std::allocator<wchar_t const *>> *,std::vector<wchar_t const *,std::allocator<wchar_t const *>> *,std::vector<wchar_t const *,std::allocator<wchar_t const *>> *)+25p
.text$mn:0000326C
.text$mn:0000326C arg_0           = dword ptr  8
.text$mn:0000326C arg_4           = dword ptr  0Ch
.text$mn:0000326C arg_8           = dword ptr  10h
.text$mn:0000326C arg_C           = dword ptr  14h
.text$mn:0000326C
.text$mn:0000326C                 push    ebp
.text$mn:0000326D                 mov     ebp, esp
.text$mn:0000326F                 mov     eax, [ebp+arg_C]
.text$mn:00003272                 push    eax             ; int
.text$mn:00003273                 mov     ecx, [ebp+arg_8]
.text$mn:00003276                 push    ecx
.text$mn:00003277                 call    ??$_Unchecked@PAV?$vector@PB_WV?$allocator@PB_W@std@@@std@@@std@@YAPAV?$vector@PB_WV?$allocator@PB_W@std@@@0@PAV10@@Z ; std::_Unchecked<std::vector<wchar_t const *,std::allocator<wchar_t const *>> *>(std::vector<wchar_t const *,std::allocator<wchar_t const *>> *)
.text$mn:0000327C                 add     esp, 4
.text$mn:0000327F                 push    eax             ; void *
.text$mn:00003280                 mov     edx, [ebp+arg_4]
.text$mn:00003283                 push    edx
.text$mn:00003284                 call    ??$_Unchecked@PAV?$vector@PB_WV?$allocator@PB_W@std@@@std@@@std@@YAPAV?$vector@PB_WV?$allocator@PB_W@std@@@0@PAV10@@Z ; std::_Unchecked<std::vector<wchar_t const *,std::allocator<wchar_t const *>> *>(std::vector<wchar_t const *,std::allocator<wchar_t const *>> *)
.text$mn:00003289                 add     esp, 4
.text$mn:0000328C                 push    eax             ; int
.text$mn:0000328D                 mov     eax, [ebp+arg_0]
.text$mn:00003290                 push    eax
.text$mn:00003291                 call    ??$_Unchecked@PAV?$vector@PB_WV?$allocator@PB_W@std@@@std@@@std@@YAPAV?$vector@PB_WV?$allocator@PB_W@std@@@0@PAV10@@Z ; std::_Unchecked<std::vector<wchar_t const *,std::allocator<wchar_t const *>> *>(std::vector<wchar_t const *,std::allocator<wchar_t const *>> *)
.text$mn:00003296                 add     esp, 4
.text$mn:00003299                 push    eax             ; int
.text$mn:0000329A                 call    ??$_Uninit_move@PAV?$vector@PB_WV?$allocator@PB_W@std@@@std@@PAV12@U?$_Wrap_alloc@V?$allocator@V?$vector@PB_WV?$allocator@PB_W@std@@@std@@@std@@@2@@std@@YAPAV?$vector@PB_WV?$allocator@PB_W@std@@@0@PAV10@00AAU?$_Wrap_alloc@V?$allocator@V?$vector@PB_WV?$allocator@PB_W@std@@@std@@@std@@@0@@Z ; std::_Uninit_move<std::vector<wchar_t const *,std::allocator<wchar_t const *>> *,std::vector<wchar_t const *,std::allocator<wchar_t const *>> *,std::_Wrap_alloc<std::allocator<std::vector<wchar_t const *,std::allocator<wchar_t const *>>>>>(std::vector<wchar_t const *,std::allocator<wchar_t const *>> *,std::vector<wchar_t const *,std::allocator<wchar_t const *>> *,std::vector<wchar_t const *,std::allocator<wchar_t const *>> *,std::_Wrap_alloc<std::allocator<std::vector<wchar_t const *,std::allocator<wchar_t const *>>>> &)
.text$mn:0000329F                 add     esp, 10h
.text$mn:000032A2                 push    eax
.text$mn:000032A3                 lea     ecx, [ebp+arg_8]
.text$mn:000032A6                 push    ecx
.text$mn:000032A7                 call    ??$_Rechecked@PAV?$vector@PB_WV?$allocator@PB_W@std@@@std@@PAV12@@std@@YAAAPAV?$vector@PB_WV?$allocator@PB_W@std@@@0@AAPAV10@PAV10@@Z ; std::_Rechecked<std::vector<wchar_t const *,std::allocator<wchar_t const *>> *,std::vector<wchar_t const *,std::allocator<wchar_t const *>> *>(std::vector<wchar_t const *,std::allocator<wchar_t const *>> * &,std::vector<wchar_t const *,std::allocator<wchar_t const *>> *)
.text$mn:000032AC                 add     esp, 8
.text$mn:000032AF                 mov     eax, [eax]
.text$mn:000032B1                 pop     ebp
.text$mn:000032B2                 retn
.text$mn:000032B2 ??$_Uninitialized_move@PAV?$vector@PB_WV?$allocator@PB_W@std@@@std@@PAV12@U?$_Wrap_alloc@V?$allocator@V?$vector@PB_WV?$allocator@PB_W@std@@@std@@@std@@@2@@std@@YAPAV?$vector@PB_WV?$allocator@PB_W@std@@@0@PAV10@00AAU?$_Wrap_alloc@V?$allocator@V?$vector@PB_WV?$allocator@PB_W@std@@@std@@@std@@@0@@Z endp
.text$mn:000032B2
.text$mn:000032B2 ; ---------------------------------------------------------------------------
.text$mn:000032B3                 align 4
.text$mn:000032B3 _text$mn        ends
.text$mn:000032B3
.text$mn:000032B4 ; ===========================================================================
.text$mn:000032B4
.text$mn:000032B4 ; Segment type: Pure code
.text$mn:000032B4 ; Segment permissions: Read/Execute
.text$mn:000032B4 _text$mn        segment para public 'CODE' use32
.text$mn:000032B4                 assume cs:_text$mn
.text$mn:000032B4                 ;org 32B4h
.text$mn:000032B4 ; COMDAT (pick any)
.text$mn:000032B4                 assume es:nothing, ss:nothing, ds:_data, fs:nothing, gs:nothing
.text$mn:000032B4
.text$mn:000032B4 ; =============== S U B R O U T I N E =======================================
.text$mn:000032B4
.text$mn:000032B4 ; Attributes: bp-based frame
.text$mn:000032B4
.text$mn:000032B4 ; wchar_t const * * __cdecl std::_Val_type<wchar_t const * *>(wchar_t const * *)
.text$mn:000032B4                 public ??$_Val_type@PAPB_W@std@@YAPAPB_WPAPB_W@Z
.text$mn:000032B4 ??$_Val_type@PAPB_W@std@@YAPAPB_WPAPB_W@Z proc near
.text$mn:000032B4                                         ; CODE XREF: std::_Uninit_move<wchar_t const * *,wchar_t const * *,std::_Wrap_alloc<std::allocator<wchar_t const *>>>(wchar_t const * *,wchar_t const * *,wchar_t const * *,std::_Wrap_alloc<std::allocator<wchar_t const *>> &)+20p
.text$mn:000032B4                 push    ebp
.text$mn:000032B5                 mov     ebp, esp
.text$mn:000032B7                 xor     eax, eax
.text$mn:000032B9                 pop     ebp
.text$mn:000032BA                 retn
.text$mn:000032BA ??$_Val_type@PAPB_W@std@@YAPAPB_WPAPB_W@Z endp
.text$mn:000032BA
.text$mn:000032BA ; ---------------------------------------------------------------------------
.text$mn:000032BB                 align 4
.text$mn:000032BB _text$mn        ends
.text$mn:000032BB
.text$mn:000032BC ; ===========================================================================
.text$mn:000032BC
.text$mn:000032BC ; Segment type: Pure code
.text$mn:000032BC ; Segment permissions: Read/Execute
.text$mn:000032BC _text$mn        segment para public 'CODE' use32
.text$mn:000032BC                 assume cs:_text$mn
.text$mn:000032BC                 ;org 32BCh
.text$mn:000032BC ; COMDAT (pick any)
.text$mn:000032BC                 assume es:nothing, ss:nothing, ds:_data, fs:nothing, gs:nothing
.text$mn:000032BC
.text$mn:000032BC ; =============== S U B R O U T I N E =======================================
.text$mn:000032BC
.text$mn:000032BC ; Attributes: bp-based frame
.text$mn:000032BC
.text$mn:000032BC ; struct FunctionValues * __cdecl std::_Val_type<struct FunctionValues *>(struct FunctionValues *)
.text$mn:000032BC                 public ??$_Val_type@PAUFunctionValues@@@std@@YAPAUFunctionValues@@PAU1@@Z
.text$mn:000032BC ??$_Val_type@PAUFunctionValues@@@std@@YAPAUFunctionValues@@PAU1@@Z proc near
.text$mn:000032BC                                         ; CODE XREF: std::_Uninit_move<FunctionValues *,FunctionValues *,std::_Wrap_alloc<std::allocator<FunctionValues>>>(FunctionValues *,FunctionValues *,FunctionValues *,std::_Wrap_alloc<std::allocator<FunctionValues>> &)+20p
.text$mn:000032BC                 push    ebp
.text$mn:000032BD                 mov     ebp, esp
.text$mn:000032BF                 xor     eax, eax
.text$mn:000032C1                 pop     ebp
.text$mn:000032C2                 retn
.text$mn:000032C2 ??$_Val_type@PAUFunctionValues@@@std@@YAPAUFunctionValues@@PAU1@@Z endp
.text$mn:000032C2
.text$mn:000032C2 ; ---------------------------------------------------------------------------
.text$mn:000032C3                 align 4
.text$mn:000032C3 _text$mn        ends
.text$mn:000032C3
.text$mn:000032C4 ; ===========================================================================
.text$mn:000032C4
.text$mn:000032C4 ; Segment type: Pure code
.text$mn:000032C4 ; Segment permissions: Read/Execute
.text$mn:000032C4 _text$mn        segment para public 'CODE' use32
.text$mn:000032C4                 assume cs:_text$mn
.text$mn:000032C4                 ;org 32C4h
.text$mn:000032C4 ; COMDAT (pick any)
.text$mn:000032C4                 assume es:nothing, ss:nothing, ds:_data, fs:nothing, gs:nothing
.text$mn:000032C4
.text$mn:000032C4 ; =============== S U B R O U T I N E =======================================
.text$mn:000032C4
.text$mn:000032C4 ; Attributes: bp-based frame
.text$mn:000032C4
.text$mn:000032C4 ; struct Token * __cdecl std::_Val_type<struct Token *>(struct Token *)
.text$mn:000032C4                 public ??$_Val_type@PAUToken@@@std@@YAPAUToken@@PAU1@@Z
.text$mn:000032C4 ??$_Val_type@PAUToken@@@std@@YAPAUToken@@PAU1@@Z proc near
.text$mn:000032C4                                         ; CODE XREF: std::_Uninit_move<Token *,Token *,std::_Wrap_alloc<std::allocator<Token>>>(Token *,Token *,Token *,std::_Wrap_alloc<std::allocator<Token>> &)+20p
.text$mn:000032C4                 push    ebp
.text$mn:000032C5                 mov     ebp, esp
.text$mn:000032C7                 xor     eax, eax
.text$mn:000032C9                 pop     ebp
.text$mn:000032CA                 retn
.text$mn:000032CA ??$_Val_type@PAUToken@@@std@@YAPAUToken@@PAU1@@Z endp
.text$mn:000032CA
.text$mn:000032CA ; ---------------------------------------------------------------------------
.text$mn:000032CB                 align 4
.text$mn:000032CB _text$mn        ends
.text$mn:000032CB
.text$mn:000032CC ; ===========================================================================
.text$mn:000032CC
.text$mn:000032CC ; Segment type: Pure code
.text$mn:000032CC ; Segment permissions: Read/Execute
.text$mn:000032CC _text$mn        segment para public 'CODE' use32
.text$mn:000032CC                 assume cs:_text$mn
.text$mn:000032CC                 ;org 32CCh
.text$mn:000032CC ; COMDAT (pick any)
.text$mn:000032CC                 assume es:nothing, ss:nothing, ds:_data, fs:nothing, gs:nothing
.text$mn:000032CC
.text$mn:000032CC ; =============== S U B R O U T I N E =======================================
.text$mn:000032CC
.text$mn:000032CC ; Attributes: bp-based frame
.text$mn:000032CC
.text$mn:000032CC ; class std::vector<wchar_t const *, class std::allocator<wchar_t const *>> * __cdecl std::_Val_type<class std::vector<wchar_t const *, class std::allocator<wchar_t const *>> *>(class std::vector<wchar_t const *, class std::allocator<wchar_t const *>> *)
.text$mn:000032CC                 public ??$_Val_type@PAV?$vector@PB_WV?$allocator@PB_W@std@@@std@@@std@@YAPAV?$vector@PB_WV?$allocator@PB_W@std@@@0@PAV10@@Z
.text$mn:000032CC ??$_Val_type@PAV?$vector@PB_WV?$allocator@PB_W@std@@@std@@@std@@YAPAV?$vector@PB_WV?$allocator@PB_W@std@@@0@PAV10@@Z proc near
.text$mn:000032CC                                         ; CODE XREF: std::_Uninit_move<std::vector<wchar_t const *,std::allocator<wchar_t const *>> *,std::vector<wchar_t const *,std::allocator<wchar_t const *>> *,std::_Wrap_alloc<std::allocator<std::vector<wchar_t const *,std::allocator<wchar_t const *>>>>>(std::vector<wchar_t const *,std::allocator<wchar_t const *>> *,std::vector<wchar_t const *,std::allocator<wchar_t const *>> *,std::vector<wchar_t const *,std::allocator<wchar_t const *>> *,std::_Wrap_alloc<std::allocator<std::vector<wchar_t const *,std::allocator<wchar_t const *>>>> &)+20p
.text$mn:000032CC                 push    ebp
.text$mn:000032CD                 mov     ebp, esp
.text$mn:000032CF                 xor     eax, eax
.text$mn:000032D1                 pop     ebp
.text$mn:000032D2                 retn
.text$mn:000032D2 ??$_Val_type@PAV?$vector@PB_WV?$allocator@PB_W@std@@@std@@@std@@YAPAV?$vector@PB_WV?$allocator@PB_W@std@@@0@PAV10@@Z endp
.text$mn:000032D2
.text$mn:000032D2 ; ---------------------------------------------------------------------------
.text$mn:000032D3                 align 4
.text$mn:000032D3 _text$mn        ends
.text$mn:000032D3
.text$mn:000032D4 ; ===========================================================================
.text$mn:000032D4
.text$mn:000032D4 ; Segment type: Pure code
.text$mn:000032D4 ; Segment permissions: Read/Execute
.text$mn:000032D4 _text$mn        segment para public 'CODE' use32
.text$mn:000032D4                 assume cs:_text$mn
.text$mn:000032D4                 ;org 32D4h
.text$mn:000032D4 ; COMDAT (pick any)
.text$mn:000032D4                 assume es:nothing, ss:nothing, ds:_data, fs:nothing, gs:nothing
.text$mn:000032D4
.text$mn:000032D4 ; =============== S U B R O U T I N E =======================================
.text$mn:000032D4
.text$mn:000032D4 ; Attributes: bp-based frame
.text$mn:000032D4
.text$mn:000032D4 ; struct FunctionValues const * __cdecl std::addressof<struct FunctionValues const>(struct FunctionValues const &)
.text$mn:000032D4                 public ??$addressof@$$CBUFunctionValues@@@std@@YAPBUFunctionValues@@ABU1@@Z
.text$mn:000032D4 ??$addressof@$$CBUFunctionValues@@@std@@YAPBUFunctionValues@@ABU1@@Z proc near
.text$mn:000032D4                                         ; CODE XREF: std::vector<FunctionValues,std::allocator<FunctionValues>>::push_back(FunctionValues const &)+Dp
.text$mn:000032D4                                         ; std::vector<FunctionValues,std::allocator<FunctionValues>>::push_back(FunctionValues const &)+29p
.text$mn:000032D4
.text$mn:000032D4 arg_0           = dword ptr  8
.text$mn:000032D4
.text$mn:000032D4                 push    ebp
.text$mn:000032D5                 mov     ebp, esp
.text$mn:000032D7                 mov     eax, [ebp+arg_0]
.text$mn:000032DA                 pop     ebp
.text$mn:000032DB                 retn
.text$mn:000032DB ??$addressof@$$CBUFunctionValues@@@std@@YAPBUFunctionValues@@ABU1@@Z endp
.text$mn:000032DB
.text$mn:000032DB _text$mn        ends
.text$mn:000032DB
.text$mn:000032DC ; ===========================================================================
.text$mn:000032DC
.text$mn:000032DC ; Segment type: Pure code
.text$mn:000032DC ; Segment permissions: Read/Execute
.text$mn:000032DC _text$mn        segment para public 'CODE' use32
.text$mn:000032DC                 assume cs:_text$mn
.text$mn:000032DC                 ;org 32DCh
.text$mn:000032DC ; COMDAT (pick any)
.text$mn:000032DC                 assume es:nothing, ss:nothing, ds:_data, fs:nothing, gs:nothing
.text$mn:000032DC
.text$mn:000032DC ; =============== S U B R O U T I N E =======================================
.text$mn:000032DC
.text$mn:000032DC ; Attributes: bp-based frame
.text$mn:000032DC
.text$mn:000032DC ; class std::vector<wchar_t const *, class std::allocator<wchar_t const *>> const * __cdecl std::addressof<class std::vector<wchar_t const *, class std::allocator<wchar_t const *>> const>(class std::vector<wchar_t const *, class std::allocator<wchar_t const *>> const &)
.text$mn:000032DC                 public ??$addressof@$$CBV?$vector@PB_WV?$allocator@PB_W@std@@@std@@@std@@YAPBV?$vector@PB_WV?$allocator@PB_W@std@@@0@ABV10@@Z
.text$mn:000032DC ??$addressof@$$CBV?$vector@PB_WV?$allocator@PB_W@std@@@std@@@std@@YAPBV?$vector@PB_WV?$allocator@PB_W@std@@@0@ABV10@@Z proc near
.text$mn:000032DC                                         ; CODE XREF: std::vector<std::vector<wchar_t const *,std::allocator<wchar_t const *>>,std::allocator<std::vector<wchar_t const *,std::allocator<wchar_t const *>>>>::push_back(std::vector<wchar_t const *,std::allocator<wchar_t const *>> const &)+Dp
.text$mn:000032DC                                         ; std::vector<std::vector<wchar_t const *,std::allocator<wchar_t const *>>,std::allocator<std::vector<wchar_t const *,std::allocator<wchar_t const *>>>>::push_back(std::vector<wchar_t const *,std::allocator<wchar_t const *>> const &)+29p
.text$mn:000032DC
.text$mn:000032DC arg_0           = dword ptr  8
.text$mn:000032DC
.text$mn:000032DC                 push    ebp
.text$mn:000032DD                 mov     ebp, esp
.text$mn:000032DF                 mov     eax, [ebp+arg_0]
.text$mn:000032E2                 pop     ebp
.text$mn:000032E3                 retn
.text$mn:000032E3 ??$addressof@$$CBV?$vector@PB_WV?$allocator@PB_W@std@@@std@@@std@@YAPBV?$vector@PB_WV?$allocator@PB_W@std@@@0@ABV10@@Z endp
.text$mn:000032E3
.text$mn:000032E3 _text$mn        ends
.text$mn:000032E3
.text$mn:000032E4 ; ===========================================================================
.text$mn:000032E4
.text$mn:000032E4 ; Segment type: Pure code
.text$mn:000032E4 ; Segment permissions: Read/Execute
.text$mn:000032E4 _text$mn        segment para public 'CODE' use32
.text$mn:000032E4                 assume cs:_text$mn
.text$mn:000032E4                 ;org 32E4h
.text$mn:000032E4 ; COMDAT (pick any)
.text$mn:000032E4                 assume es:nothing, ss:nothing, ds:_data, fs:nothing, gs:nothing
.text$mn:000032E4
.text$mn:000032E4 ; =============== S U B R O U T I N E =======================================
.text$mn:000032E4
.text$mn:000032E4 ; Attributes: bp-based frame
.text$mn:000032E4
.text$mn:000032E4 ; char * __cdecl std::addressof<char>(char &)
.text$mn:000032E4                 public ??$addressof@D@std@@YAPADAAD@Z
.text$mn:000032E4 ??$addressof@D@std@@YAPADAAD@Z proc near
.text$mn:000032E4                                         ; CODE XREF: std::_String_val<std::_Simple_types<char>>::_Myptr(void)+19p
.text$mn:000032E4                                         ; std::_String_val<std::_Simple_types<char>>::_Myptr(void)+19p ...
.text$mn:000032E4
.text$mn:000032E4 arg_0           = dword ptr  8
.text$mn:000032E4
.text$mn:000032E4                 push    ebp
.text$mn:000032E5                 mov     ebp, esp
.text$mn:000032E7                 mov     eax, [ebp+arg_0]
.text$mn:000032EA                 pop     ebp
.text$mn:000032EB                 retn
.text$mn:000032EB ??$addressof@D@std@@YAPADAAD@Z endp
.text$mn:000032EB
.text$mn:000032EB _text$mn        ends
.text$mn:000032EB
.text$mn:000032EC ; ===========================================================================
.text$mn:000032EC
.text$mn:000032EC ; Segment type: Pure code
.text$mn:000032EC ; Segment permissions: Read/Execute
.text$mn:000032EC _text$mn        segment para public 'CODE' use32
.text$mn:000032EC                 assume cs:_text$mn
.text$mn:000032EC                 ;org 32ECh
.text$mn:000032EC ; COMDAT (pick any)
.text$mn:000032EC                 assume es:nothing, ss:nothing, ds:_data, fs:nothing, gs:nothing
.text$mn:000032EC
.text$mn:000032EC ; =============== S U B R O U T I N E =======================================
.text$mn:000032EC
.text$mn:000032EC ; Attributes: bp-based frame
.text$mn:000032EC
.text$mn:000032EC ; wchar_t const * const * __cdecl std::addressof<wchar_t const * const>(wchar_t const * const &)
.text$mn:000032EC                 public ??$addressof@QB_W@std@@YAPBQB_WABQB_W@Z
.text$mn:000032EC ??$addressof@QB_W@std@@YAPBQB_WABQB_W@Z proc near
.text$mn:000032EC                                         ; CODE XREF: std::vector<wchar_t const *,std::allocator<wchar_t const *>>::push_back(wchar_t const * const &)+Dp
.text$mn:000032EC                                         ; std::vector<wchar_t const *,std::allocator<wchar_t const *>>::push_back(wchar_t const * const &)+29p
.text$mn:000032EC
.text$mn:000032EC arg_0           = dword ptr  8
.text$mn:000032EC
.text$mn:000032EC                 push    ebp
.text$mn:000032ED                 mov     ebp, esp
.text$mn:000032EF                 mov     eax, [ebp+arg_0]
.text$mn:000032F2                 pop     ebp
.text$mn:000032F3                 retn
.text$mn:000032F3 ??$addressof@QB_W@std@@YAPBQB_WABQB_W@Z endp
.text$mn:000032F3
.text$mn:000032F3 _text$mn        ends
.text$mn:000032F3
.text$mn:000032F4 ; ===========================================================================
.text$mn:000032F4
.text$mn:000032F4 ; Segment type: Pure code
.text$mn:000032F4 ; Segment permissions: Read/Execute
.text$mn:000032F4 _text$mn        segment para public 'CODE' use32
.text$mn:000032F4                 assume cs:_text$mn
.text$mn:000032F4                 ;org 32F4h
.text$mn:000032F4 ; COMDAT (pick any)
.text$mn:000032F4                 assume es:nothing, ss:nothing, ds:_data, fs:nothing, gs:nothing
.text$mn:000032F4
.text$mn:000032F4 ; =============== S U B R O U T I N E =======================================
.text$mn:000032F4
.text$mn:000032F4 ; Attributes: bp-based frame
.text$mn:000032F4
.text$mn:000032F4 ; struct Token * __cdecl std::addressof<struct Token>(struct Token &)
.text$mn:000032F4                 public ??$addressof@UToken@@@std@@YAPAUToken@@AAU1@@Z
.text$mn:000032F4 ??$addressof@UToken@@@std@@YAPAUToken@@AAU1@@Z proc near
.text$mn:000032F4                                         ; CODE XREF: std::vector<Token,std::allocator<Token>>::push_back(Token &&)+Dp
.text$mn:000032F4                                         ; std::vector<Token,std::allocator<Token>>::push_back(Token &&)+2Dp
.text$mn:000032F4
.text$mn:000032F4 arg_0           = dword ptr  8
.text$mn:000032F4
.text$mn:000032F4                 push    ebp
.text$mn:000032F5                 mov     ebp, esp
.text$mn:000032F7                 mov     eax, [ebp+arg_0]
.text$mn:000032FA                 pop     ebp
.text$mn:000032FB                 retn
.text$mn:000032FB ??$addressof@UToken@@@std@@YAPAUToken@@AAU1@@Z endp
.text$mn:000032FB
.text$mn:000032FB _text$mn        ends
.text$mn:000032FB
.text$mn:000032FC ; ===========================================================================
.text$mn:000032FC
.text$mn:000032FC ; Segment type: Pure code
.text$mn:000032FC ; Segment permissions: Read/Execute
.text$mn:000032FC _text$mn        segment para public 'CODE' use32
.text$mn:000032FC                 assume cs:_text$mn
.text$mn:000032FC                 ;org 32FCh
.text$mn:000032FC ; COMDAT (pick any)
.text$mn:000032FC                 assume es:nothing, ss:nothing, ds:_data, fs:nothing, gs:nothing
.text$mn:000032FC
.text$mn:000032FC ; =============== S U B R O U T I N E =======================================
.text$mn:000032FC
.text$mn:000032FC ; Attributes: bp-based frame
.text$mn:000032FC
.text$mn:000032FC ; wchar_t * __cdecl std::addressof<wchar_t>(wchar_t &)
.text$mn:000032FC                 public ??$addressof@_W@std@@YAPA_WAA_W@Z
.text$mn:000032FC ??$addressof@_W@std@@YAPA_WAA_W@Z proc near
.text$mn:000032FC                                         ; CODE XREF: std::_String_val<std::_Simple_types<wchar_t>>::_Myptr(void)+19p
.text$mn:000032FC
.text$mn:000032FC arg_0           = dword ptr  8
.text$mn:000032FC
.text$mn:000032FC                 push    ebp
.text$mn:000032FD                 mov     ebp, esp
.text$mn:000032FF                 mov     eax, [ebp+arg_0]
.text$mn:00003302                 pop     ebp
.text$mn:00003303                 retn
.text$mn:00003303 ??$addressof@_W@std@@YAPA_WAA_W@Z endp
.text$mn:00003303
.text$mn:00003303 _text$mn        ends
.text$mn:00003303
.text$mn:00003304 ; ===========================================================================
.text$mn:00003304
.text$mn:00003304 ; Segment type: Pure code
.text$mn:00003304 ; Segment permissions: Read/Execute
.text$mn:00003304 _text$mn        segment para public 'CODE' use32
.text$mn:00003304                 assume cs:_text$mn
.text$mn:00003304                 ;org 3304h
.text$mn:00003304 ; COMDAT (pick any)
.text$mn:00003304                 assume es:nothing, ss:nothing, ds:_data, fs:nothing, gs:nothing
.text$mn:00003304
.text$mn:00003304 ; =============== S U B R O U T I N E =======================================
.text$mn:00003304
.text$mn:00003304 ; Attributes: bp-based frame
.text$mn:00003304
.text$mn:00003304 ; int __stdcall std::_Wrap_alloc<std::allocator<char>>::construct<char *,char * &>(void *, int)
.text$mn:00003304                 public ??$construct@PADAAPAD@?$_Wrap_alloc@V?$allocator@D@std@@@std@@QAEXPAPADAAPAD@Z
.text$mn:00003304 ??$construct@PADAAPAD@?$_Wrap_alloc@V?$allocator@D@std@@@std@@QAEXPAPADAAPAD@Z proc near
.text$mn:00003304                                         ; CODE XREF: $LN19+4Bp
.text$mn:00003304
.text$mn:00003304 var_4           = dword ptr -4
.text$mn:00003304 arg_0           = dword ptr  8
.text$mn:00003304 arg_4           = dword ptr  0Ch
.text$mn:00003304
.text$mn:00003304                 push    ebp
.text$mn:00003305                 mov     ebp, esp
.text$mn:00003307                 push    ecx
.text$mn:00003308                 mov     [ebp+var_4], ecx
.text$mn:0000330B                 mov     eax, [ebp+arg_4]
.text$mn:0000330E                 push    eax
.text$mn:0000330F                 call    ??$forward@AAPAD@std@@YAAAPADAAPAD@Z ; std::forward<char * &>(char * &)
.text$mn:00003314                 add     esp, 4
.text$mn:00003317                 push    eax             ; int
.text$mn:00003318                 mov     ecx, [ebp+arg_0]
.text$mn:0000331B                 push    ecx             ; void *
.text$mn:0000331C                 mov     edx, [ebp+var_4]
.text$mn:0000331F                 push    edx             ; int
.text$mn:00003320                 call    ??$construct@PADAAPAD@?$allocator_traits@V?$allocator@D@std@@@std@@SAXAAV?$allocator@D@1@PAPADAAPAD@Z ; std::allocator_traits<std::allocator<char>>::construct<char *,char * &>(std::allocator<char> &,char * *,char * &)
.text$mn:00003325                 add     esp, 0Ch
.text$mn:00003328                 mov     esp, ebp
.text$mn:0000332A                 pop     ebp
.text$mn:0000332B                 retn    8
.text$mn:0000332B ??$construct@PADAAPAD@?$_Wrap_alloc@V?$allocator@D@std@@@std@@QAEXPAPADAAPAD@Z endp
.text$mn:0000332B
.text$mn:0000332B ; ---------------------------------------------------------------------------
.text$mn:0000332E                 align 10h
.text$mn:0000332E _text$mn        ends
.text$mn:0000332E
.text$mn:00003330 ; ===========================================================================
.text$mn:00003330
.text$mn:00003330 ; Segment type: Pure code
.text$mn:00003330 ; Segment permissions: Read/Execute
.text$mn:00003330 _text$mn        segment para public 'CODE' use32
.text$mn:00003330                 assume cs:_text$mn
.text$mn:00003330                 ;org 3330h
.text$mn:00003330 ; COMDAT (pick any)
.text$mn:00003330                 assume es:nothing, ss:nothing, ds:_data, fs:nothing, gs:nothing
.text$mn:00003330
.text$mn:00003330 ; =============== S U B R O U T I N E =======================================
.text$mn:00003330
.text$mn:00003330 ; Attributes: bp-based frame
.text$mn:00003330
.text$mn:00003330 ; int __stdcall std::allocator<char>::construct<char *,char * &>(void *, int)
.text$mn:00003330                 public ??$construct@PADAAPAD@?$allocator@D@std@@QAEXPAPADAAPAD@Z
.text$mn:00003330 ??$construct@PADAAPAD@?$allocator@D@std@@QAEXPAPADAAPAD@Z proc near
.text$mn:00003330                                         ; CODE XREF: std::allocator_traits<std::allocator<char>>::construct<char *,char * &>(std::allocator<char> &,char * *,char * &)+17p
.text$mn:00003330
.text$mn:00003330 var_1C          = dword ptr -1Ch
.text$mn:00003330 var_18          = dword ptr -18h
.text$mn:00003330 var_14          = dword ptr -14h
.text$mn:00003330 var_10          = dword ptr -10h
.text$mn:00003330 var_C           = dword ptr -0Ch
.text$mn:00003330 var_4           = dword ptr -4
.text$mn:00003330 arg_0           = dword ptr  8
.text$mn:00003330 arg_4           = dword ptr  0Ch
.text$mn:00003330
.text$mn:00003330                 push    ebp
.text$mn:00003331                 mov     ebp, esp
.text$mn:00003333                 push    0FFFFFFFFh
.text$mn:00003335                 push    offset __ehhandler$??$construct@PADAAPAD@?$allocator@D@std@@QAEXPAPADAAPAD@Z
.text$mn:0000333A                 mov     eax, large fs:0
.text$mn:00003340                 push    eax
.text$mn:00003341                 sub     esp, 10h
.text$mn:00003344                 mov     eax, dword ptr ds:___security_cookie
.text$mn:00003349                 xor     eax, ebp
.text$mn:0000334B                 push    eax
.text$mn:0000334C                 lea     eax, [ebp+var_C]
.text$mn:0000334F                 mov     large fs:0, eax
.text$mn:00003355                 mov     [ebp+var_18], ecx
.text$mn:00003358                 mov     eax, [ebp+arg_0]
.text$mn:0000335B                 push    eax             ; void *
.text$mn:0000335C                 push    4               ; unsigned int
.text$mn:0000335E                 call    ??2@YAPAXIPAX@Z ; operator new(uint,void *)
.text$mn:00003363                 add     esp, 8
.text$mn:00003366                 mov     [ebp+var_10], eax
.text$mn:00003369                 mov     [ebp+var_4], 0
.text$mn:00003370                 cmp     [ebp+var_10], 0
.text$mn:00003374                 jz      short loc_3391
.text$mn:00003376                 mov     ecx, [ebp+arg_4]
.text$mn:00003379                 push    ecx
.text$mn:0000337A                 call    ??$forward@AAPAD@std@@YAAAPADAAPAD@Z ; std::forward<char * &>(char * &)
.text$mn:0000337F                 add     esp, 4
.text$mn:00003382                 mov     edx, [ebp+var_10]
.text$mn:00003385                 mov     eax, [eax]
.text$mn:00003387                 mov     [edx], eax
.text$mn:00003389                 mov     ecx, [ebp+var_10]
.text$mn:0000338C                 mov     [ebp+var_14], ecx
.text$mn:0000338F                 jmp     short loc_3398
.text$mn:00003391 ; ---------------------------------------------------------------------------
.text$mn:00003391
.text$mn:00003391 loc_3391:                               ; CODE XREF: std::allocator<char>::construct<char *,char * &>(char * *,char * &)+44j
.text$mn:00003391                 mov     [ebp+var_14], 0
.text$mn:00003398
.text$mn:00003398 loc_3398:                               ; CODE XREF: std::allocator<char>::construct<char *,char * &>(char * *,char * &)+5Fj
.text$mn:00003398                 mov     edx, [ebp+var_14]
.text$mn:0000339B                 mov     [ebp+var_1C], edx
.text$mn:0000339E                 mov     [ebp+var_4], 0FFFFFFFFh
.text$mn:000033A5                 mov     ecx, [ebp+var_C]
.text$mn:000033A8                 mov     large fs:0, ecx
.text$mn:000033AF                 pop     ecx
.text$mn:000033B0                 mov     esp, ebp
.text$mn:000033B2                 pop     ebp
.text$mn:000033B3                 retn    8
.text$mn:000033B3 ??$construct@PADAAPAD@?$allocator@D@std@@QAEXPAPADAAPAD@Z endp
.text$mn:000033B3
.text$mn:000033B3 ; ---------------------------------------------------------------------------
.text$mn:000033B6                 align 4
.text$mn:000033B6 _text$mn        ends
.text$mn:000033B6
.text$x:000033B8 ; ===========================================================================
.text$x:000033B8
.text$x:000033B8 ; Segment type: Pure code
.text$x:000033B8 ; Segment permissions: Read/Execute
.text$x:000033B8 _text$x         segment para public 'CODE' use32
.text$x:000033B8                 assume cs:_text$x
.text$x:000033B8                 ;org 33B8h
.text$x:000033B8 ; COMDAT (pick associative to section at 3330)
.text$x:000033B8                 assume es:nothing, ss:nothing, ds:_data, fs:nothing, gs:nothing
.text$x:000033B8
.text$x:000033B8 ; =============== S U B R O U T I N E =======================================
.text$x:000033B8
.text$x:000033B8
.text$x:000033B8 __unwindfunclet$??$construct@PADAAPAD@?$allocator@D@std@@QAEXPAPADAAPAD@Z$0 proc near
.text$x:000033B8                                         ; DATA XREF: .xdata$x:0000A0D4o
.text$x:000033B8                 mov     eax, [ebp+8]
.text$x:000033BB                 push    eax
.text$x:000033BC                 mov     eax, [ebp-10h]
.text$x:000033BF                 push    eax             ; void *
.text$x:000033C0                 call    ??3@YAXPAX0@Z   ; operator delete(void *,void *)
.text$x:000033C5                 add     esp, 8
.text$x:000033C8                 retn
.text$x:000033C8 __unwindfunclet$??$construct@PADAAPAD@?$allocator@D@std@@QAEXPAPADAAPAD@Z$0 endp
.text$x:000033C8
.text$x:000033C9
.text$x:000033C9 ; =============== S U B R O U T I N E =======================================
.text$x:000033C9
.text$x:000033C9
.text$x:000033C9 __ehhandler$??$construct@PADAAPAD@?$allocator@D@std@@QAEXPAPADAAPAD@Z proc near
.text$x:000033C9                                         ; DATA XREF: std::allocator<char>::construct<char *,char * &>(char * *,char * &)+5o
.text$x:000033C9
.text$x:000033C9 arg_4           = dword ptr  8
.text$x:000033C9
.text$x:000033C9                 mov     edx, [esp+arg_4]
.text$x:000033CD                 lea     eax, [edx+0Ch]
.text$x:000033D0                 mov     ecx, [edx-14h]
.text$x:000033D3                 xor     ecx, eax
.text$x:000033D5                 call    @__security_check_cookie@4 ; __security_check_cookie(x)
.text$x:000033DA                 mov     eax, offset __ehfuncinfo$??$construct@PADAAPAD@?$allocator@D@std@@QAEXPAPADAAPAD@Z
.text$x:000033DF                 jmp     ___CxxFrameHandler3
.text$x:000033DF __ehhandler$??$construct@PADAAPAD@?$allocator@D@std@@QAEXPAPADAAPAD@Z endp
.text$x:000033DF
.text$x:000033DF _text$x         ends
.text$x:000033DF
.text$mn:000033E4 ; ===========================================================================
.text$mn:000033E4
.text$mn:000033E4 ; Segment type: Pure code
.text$mn:000033E4 ; Segment permissions: Read/Execute
.text$mn:000033E4 _text$mn        segment para public 'CODE' use32
.text$mn:000033E4                 assume cs:_text$mn
.text$mn:000033E4                 ;org 33E4h
.text$mn:000033E4 ; COMDAT (pick any)
.text$mn:000033E4                 assume es:nothing, ss:nothing, ds:_data, fs:nothing, gs:nothing
.text$mn:000033E4
.text$mn:000033E4 ; =============== S U B R O U T I N E =======================================
.text$mn:000033E4
.text$mn:000033E4 ; Attributes: bp-based frame
.text$mn:000033E4
.text$mn:000033E4 ; int __cdecl std::allocator_traits<std::allocator<char>>::construct<char *,char * &>(int, void *, int)
.text$mn:000033E4                 public ??$construct@PADAAPAD@?$allocator_traits@V?$allocator@D@std@@@std@@SAXAAV?$allocator@D@1@PAPADAAPAD@Z
.text$mn:000033E4 ??$construct@PADAAPAD@?$allocator_traits@V?$allocator@D@std@@@std@@SAXAAV?$allocator@D@1@PAPADAAPAD@Z proc near
.text$mn:000033E4                                         ; CODE XREF: std::_Wrap_alloc<std::allocator<char>>::construct<char *,char * &>(char * *,char * &)+1Cp
.text$mn:000033E4
.text$mn:000033E4 arg_0           = dword ptr  8
.text$mn:000033E4 arg_4           = dword ptr  0Ch
.text$mn:000033E4 arg_8           = dword ptr  10h
.text$mn:000033E4
.text$mn:000033E4                 push    ebp
.text$mn:000033E5                 mov     ebp, esp
.text$mn:000033E7                 mov     eax, [ebp+arg_8]
.text$mn:000033EA                 push    eax
.text$mn:000033EB                 call    ??$forward@AAPAD@std@@YAAAPADAAPAD@Z ; std::forward<char * &>(char * &)
.text$mn:000033F0                 add     esp, 4
.text$mn:000033F3                 push    eax             ; int
.text$mn:000033F4                 mov     ecx, [ebp+arg_4]
.text$mn:000033F7                 push    ecx             ; void *
.text$mn:000033F8                 mov     ecx, [ebp+arg_0]
.text$mn:000033FB                 call    ??$construct@PADAAPAD@?$allocator@D@std@@QAEXPAPADAAPAD@Z ; std::allocator<char>::construct<char *,char * &>(char * *,char * &)
.text$mn:00003400                 pop     ebp
.text$mn:00003401                 retn
.text$mn:00003401 ??$construct@PADAAPAD@?$allocator_traits@V?$allocator@D@std@@@std@@SAXAAV?$allocator@D@1@PAPADAAPAD@Z endp
.text$mn:00003401
.text$mn:00003401 ; ---------------------------------------------------------------------------
.text$mn:00003402                 align 4
.text$mn:00003402 _text$mn        ends
.text$mn:00003402
.text$mn:00003404 ; ===========================================================================
.text$mn:00003404
.text$mn:00003404 ; Segment type: Pure code
.text$mn:00003404 ; Segment permissions: Read/Execute
.text$mn:00003404 _text$mn        segment para public 'CODE' use32
.text$mn:00003404                 assume cs:_text$mn
.text$mn:00003404                 ;org 3404h
.text$mn:00003404 ; COMDAT (pick any)
.text$mn:00003404                 assume es:nothing, ss:nothing, ds:_data, fs:nothing, gs:nothing
.text$mn:00003404
.text$mn:00003404 ; =============== S U B R O U T I N E =======================================
.text$mn:00003404
.text$mn:00003404 ; Attributes: bp-based frame
.text$mn:00003404
.text$mn:00003404 ; int __stdcall std::_Wrap_alloc<std::allocator<wchar_t const *>>::construct<wchar_t const *,wchar_t const * &>(void *, int)
.text$mn:00003404                 public ??$construct@PB_WAAPB_W@?$_Wrap_alloc@V?$allocator@PB_W@std@@@std@@QAEXPAPB_WAAPB_W@Z
.text$mn:00003404 ??$construct@PB_WAAPB_W@?$_Wrap_alloc@V?$allocator@PB_W@std@@@std@@QAEXPAPB_WAAPB_W@Z proc near
.text$mn:00003404                                         ; CODE XREF: std::vector<wchar_t const *,std::allocator<wchar_t const *>>::push_back(wchar_t const * const &)+8Dp
.text$mn:00003404
.text$mn:00003404 var_4           = dword ptr -4
.text$mn:00003404 arg_0           = dword ptr  8
.text$mn:00003404 arg_4           = dword ptr  0Ch
.text$mn:00003404
.text$mn:00003404                 push    ebp
.text$mn:00003405                 mov     ebp, esp
.text$mn:00003407                 push    ecx
.text$mn:00003408                 mov     [ebp+var_4], ecx
.text$mn:0000340B                 mov     eax, [ebp+arg_4]
.text$mn:0000340E                 push    eax
.text$mn:0000340F                 call    ??$forward@AAPB_W@std@@YAAAPB_WAAPB_W@Z ; std::forward<wchar_t const * &>(wchar_t const * &)
.text$mn:00003414                 add     esp, 4
.text$mn:00003417                 push    eax             ; int
.text$mn:00003418                 mov     ecx, [ebp+arg_0]
.text$mn:0000341B                 push    ecx             ; void *
.text$mn:0000341C                 mov     edx, [ebp+var_4]
.text$mn:0000341F                 push    edx             ; int
.text$mn:00003420                 call    ??$construct@PB_WAAPB_W@?$allocator_traits@V?$allocator@PB_W@std@@@std@@SAXAAV?$allocator@PB_W@1@PAPB_WAAPB_W@Z ; std::allocator_traits<std::allocator<wchar_t const *>>::construct<wchar_t const *,wchar_t const * &>(std::allocator<wchar_t const *> &,wchar_t const * *,wchar_t const * &)
.text$mn:00003425                 add     esp, 0Ch
.text$mn:00003428                 mov     esp, ebp
.text$mn:0000342A                 pop     ebp
.text$mn:0000342B                 retn    8
.text$mn:0000342B ??$construct@PB_WAAPB_W@?$_Wrap_alloc@V?$allocator@PB_W@std@@@std@@QAEXPAPB_WAAPB_W@Z endp
.text$mn:0000342B
.text$mn:0000342B ; ---------------------------------------------------------------------------
.text$mn:0000342E                 align 10h
.text$mn:0000342E _text$mn        ends
.text$mn:0000342E
.text$mn:00003430 ; ===========================================================================
.text$mn:00003430
.text$mn:00003430 ; Segment type: Pure code
.text$mn:00003430 ; Segment permissions: Read/Execute
.text$mn:00003430 _text$mn        segment para public 'CODE' use32
.text$mn:00003430                 assume cs:_text$mn
.text$mn:00003430                 ;org 3430h
.text$mn:00003430 ; COMDAT (pick any)
.text$mn:00003430                 assume es:nothing, ss:nothing, ds:_data, fs:nothing, gs:nothing
.text$mn:00003430
.text$mn:00003430 ; =============== S U B R O U T I N E =======================================
.text$mn:00003430
.text$mn:00003430 ; Attributes: bp-based frame
.text$mn:00003430
.text$mn:00003430 ; int __stdcall std::allocator<wchar_t const *>::construct<wchar_t const *,wchar_t const * &>(void *, int)
.text$mn:00003430                 public ??$construct@PB_WAAPB_W@?$allocator@PB_W@std@@QAEXPAPB_WAAPB_W@Z
.text$mn:00003430 ??$construct@PB_WAAPB_W@?$allocator@PB_W@std@@QAEXPAPB_WAAPB_W@Z proc near
.text$mn:00003430                                         ; CODE XREF: std::allocator_traits<std::allocator<wchar_t const *>>::construct<wchar_t const *,wchar_t const * &>(std::allocator<wchar_t const *> &,wchar_t const * *,wchar_t const * &)+17p
.text$mn:00003430
.text$mn:00003430 var_1C          = dword ptr -1Ch
.text$mn:00003430 var_18          = dword ptr -18h
.text$mn:00003430 var_14          = dword ptr -14h
.text$mn:00003430 var_10          = dword ptr -10h
.text$mn:00003430 var_C           = dword ptr -0Ch
.text$mn:00003430 var_4           = dword ptr -4
.text$mn:00003430 arg_0           = dword ptr  8
.text$mn:00003430 arg_4           = dword ptr  0Ch
.text$mn:00003430
.text$mn:00003430                 push    ebp
.text$mn:00003431                 mov     ebp, esp
.text$mn:00003433                 push    0FFFFFFFFh
.text$mn:00003435                 push    offset __ehhandler$??$construct@PB_WAAPB_W@?$allocator@PB_W@std@@QAEXPAPB_WAAPB_W@Z
.text$mn:0000343A                 mov     eax, large fs:0
.text$mn:00003440                 push    eax
.text$mn:00003441                 sub     esp, 10h
.text$mn:00003444                 mov     eax, dword ptr ds:___security_cookie
.text$mn:00003449                 xor     eax, ebp
.text$mn:0000344B                 push    eax
.text$mn:0000344C                 lea     eax, [ebp+var_C]
.text$mn:0000344F                 mov     large fs:0, eax
.text$mn:00003455                 mov     [ebp+var_18], ecx
.text$mn:00003458                 mov     eax, [ebp+arg_0]
.text$mn:0000345B                 push    eax             ; void *
.text$mn:0000345C                 push    4               ; unsigned int
.text$mn:0000345E                 call    ??2@YAPAXIPAX@Z ; operator new(uint,void *)
.text$mn:00003463                 add     esp, 8
.text$mn:00003466                 mov     [ebp+var_10], eax
.text$mn:00003469                 mov     [ebp+var_4], 0
.text$mn:00003470                 cmp     [ebp+var_10], 0
.text$mn:00003474                 jz      short loc_3491
.text$mn:00003476                 mov     ecx, [ebp+arg_4]
.text$mn:00003479                 push    ecx
.text$mn:0000347A                 call    ??$forward@AAPB_W@std@@YAAAPB_WAAPB_W@Z ; std::forward<wchar_t const * &>(wchar_t const * &)
.text$mn:0000347F                 add     esp, 4
.text$mn:00003482                 mov     edx, [ebp+var_10]
.text$mn:00003485                 mov     eax, [eax]
.text$mn:00003487                 mov     [edx], eax
.text$mn:00003489                 mov     ecx, [ebp+var_10]
.text$mn:0000348C                 mov     [ebp+var_14], ecx
.text$mn:0000348F                 jmp     short loc_3498
.text$mn:00003491 ; ---------------------------------------------------------------------------
.text$mn:00003491
.text$mn:00003491 loc_3491:                               ; CODE XREF: std::allocator<wchar_t const *>::construct<wchar_t const *,wchar_t const * &>(wchar_t const * *,wchar_t const * &)+44j
.text$mn:00003491                 mov     [ebp+var_14], 0
.text$mn:00003498
.text$mn:00003498 loc_3498:                               ; CODE XREF: std::allocator<wchar_t const *>::construct<wchar_t const *,wchar_t const * &>(wchar_t const * *,wchar_t const * &)+5Fj
.text$mn:00003498                 mov     edx, [ebp+var_14]
.text$mn:0000349B                 mov     [ebp+var_1C], edx
.text$mn:0000349E                 mov     [ebp+var_4], 0FFFFFFFFh
.text$mn:000034A5                 mov     ecx, [ebp+var_C]
.text$mn:000034A8                 mov     large fs:0, ecx
.text$mn:000034AF                 pop     ecx
.text$mn:000034B0                 mov     esp, ebp
.text$mn:000034B2                 pop     ebp
.text$mn:000034B3                 retn    8
.text$mn:000034B3 ??$construct@PB_WAAPB_W@?$allocator@PB_W@std@@QAEXPAPB_WAAPB_W@Z endp
.text$mn:000034B3
.text$mn:000034B3 ; ---------------------------------------------------------------------------
.text$mn:000034B6                 align 4
.text$mn:000034B6 _text$mn        ends
.text$mn:000034B6
.text$x:000034B8 ; ===========================================================================
.text$x:000034B8
.text$x:000034B8 ; Segment type: Pure code
.text$x:000034B8 ; Segment permissions: Read/Execute
.text$x:000034B8 _text$x         segment para public 'CODE' use32
.text$x:000034B8                 assume cs:_text$x
.text$x:000034B8                 ;org 34B8h
.text$x:000034B8 ; COMDAT (pick associative to section at 3430)
.text$x:000034B8                 assume es:nothing, ss:nothing, ds:_data, fs:nothing, gs:nothing
.text$x:000034B8
.text$x:000034B8 ; =============== S U B R O U T I N E =======================================
.text$x:000034B8
.text$x:000034B8
.text$x:000034B8 __unwindfunclet$??$construct@PB_WAAPB_W@?$allocator@PB_W@std@@QAEXPAPB_WAAPB_W@Z$0 proc near
.text$x:000034B8                                         ; DATA XREF: .xdata$x:0000A024o
.text$x:000034B8                 mov     eax, [ebp+8]
.text$x:000034BB                 push    eax
.text$x:000034BC                 mov     eax, [ebp-10h]
.text$x:000034BF                 push    eax             ; void *
.text$x:000034C0                 call    ??3@YAXPAX0@Z   ; operator delete(void *,void *)
.text$x:000034C5                 add     esp, 8
.text$x:000034C8                 retn
.text$x:000034C8 __unwindfunclet$??$construct@PB_WAAPB_W@?$allocator@PB_W@std@@QAEXPAPB_WAAPB_W@Z$0 endp
.text$x:000034C8
.text$x:000034C9
.text$x:000034C9 ; =============== S U B R O U T I N E =======================================
.text$x:000034C9
.text$x:000034C9
.text$x:000034C9 __ehhandler$??$construct@PB_WAAPB_W@?$allocator@PB_W@std@@QAEXPAPB_WAAPB_W@Z proc near
.text$x:000034C9                                         ; DATA XREF: std::allocator<wchar_t const *>::construct<wchar_t const *,wchar_t const * &>(wchar_t const * *,wchar_t const * &)+5o
.text$x:000034C9
.text$x:000034C9 arg_4           = dword ptr  8
.text$x:000034C9
.text$x:000034C9                 mov     edx, [esp+arg_4]
.text$x:000034CD                 lea     eax, [edx+0Ch]
.text$x:000034D0                 mov     ecx, [edx-14h]
.text$x:000034D3                 xor     ecx, eax
.text$x:000034D5                 call    @__security_check_cookie@4 ; __security_check_cookie(x)
.text$x:000034DA                 mov     eax, offset __ehfuncinfo$??$construct@PB_WAAPB_W@?$allocator@PB_W@std@@QAEXPAPB_WAAPB_W@Z
.text$x:000034DF                 jmp     ___CxxFrameHandler3
.text$x:000034DF __ehhandler$??$construct@PB_WAAPB_W@?$allocator@PB_W@std@@QAEXPAPB_WAAPB_W@Z endp
.text$x:000034DF
.text$x:000034DF _text$x         ends
.text$x:000034DF
.text$mn:000034E4 ; ===========================================================================
.text$mn:000034E4
.text$mn:000034E4 ; Segment type: Pure code
.text$mn:000034E4 ; Segment permissions: Read/Execute
.text$mn:000034E4 _text$mn        segment para public 'CODE' use32
.text$mn:000034E4                 assume cs:_text$mn
.text$mn:000034E4                 ;org 34E4h
.text$mn:000034E4 ; COMDAT (pick any)
.text$mn:000034E4                 assume es:nothing, ss:nothing, ds:_data, fs:nothing, gs:nothing
.text$mn:000034E4
.text$mn:000034E4 ; =============== S U B R O U T I N E =======================================
.text$mn:000034E4
.text$mn:000034E4 ; Attributes: bp-based frame
.text$mn:000034E4
.text$mn:000034E4 ; int __cdecl std::allocator_traits<std::allocator<wchar_t const *>>::construct<wchar_t const *,wchar_t const * &>(int, void *, int)
.text$mn:000034E4                 public ??$construct@PB_WAAPB_W@?$allocator_traits@V?$allocator@PB_W@std@@@std@@SAXAAV?$allocator@PB_W@1@PAPB_WAAPB_W@Z
.text$mn:000034E4 ??$construct@PB_WAAPB_W@?$allocator_traits@V?$allocator@PB_W@std@@@std@@SAXAAV?$allocator@PB_W@1@PAPB_WAAPB_W@Z proc near
.text$mn:000034E4                                         ; CODE XREF: std::_Wrap_alloc<std::allocator<wchar_t const *>>::construct<wchar_t const *,wchar_t const * &>(wchar_t const * *,wchar_t const * &)+1Cp
.text$mn:000034E4
.text$mn:000034E4 arg_0           = dword ptr  8
.text$mn:000034E4 arg_4           = dword ptr  0Ch
.text$mn:000034E4 arg_8           = dword ptr  10h
.text$mn:000034E4
.text$mn:000034E4                 push    ebp
.text$mn:000034E5                 mov     ebp, esp
.text$mn:000034E7                 mov     eax, [ebp+arg_8]
.text$mn:000034EA                 push    eax
.text$mn:000034EB                 call    ??$forward@AAPB_W@std@@YAAAPB_WAAPB_W@Z ; std::forward<wchar_t const * &>(wchar_t const * &)
.text$mn:000034F0                 add     esp, 4
.text$mn:000034F3                 push    eax             ; int
.text$mn:000034F4                 mov     ecx, [ebp+arg_4]
.text$mn:000034F7                 push    ecx             ; void *
.text$mn:000034F8                 mov     ecx, [ebp+arg_0]
.text$mn:000034FB                 call    ??$construct@PB_WAAPB_W@?$allocator@PB_W@std@@QAEXPAPB_WAAPB_W@Z ; std::allocator<wchar_t const *>::construct<wchar_t const *,wchar_t const * &>(wchar_t const * *,wchar_t const * &)
.text$mn:00003500                 pop     ebp
.text$mn:00003501                 retn
.text$mn:00003501 ??$construct@PB_WAAPB_W@?$allocator_traits@V?$allocator@PB_W@std@@@std@@SAXAAV?$allocator@PB_W@1@PAPB_WAAPB_W@Z endp
.text$mn:00003501
.text$mn:00003501 ; ---------------------------------------------------------------------------
.text$mn:00003502                 align 4
.text$mn:00003502 _text$mn        ends
.text$mn:00003502
.text$mn:00003504 ; ===========================================================================
.text$mn:00003504
.text$mn:00003504 ; Segment type: Pure code
.text$mn:00003504 ; Segment permissions: Read/Execute
.text$mn:00003504 _text$mn        segment para public 'CODE' use32
.text$mn:00003504                 assume cs:_text$mn
.text$mn:00003504                 ;org 3504h
.text$mn:00003504 ; COMDAT (pick any)
.text$mn:00003504                 assume es:nothing, ss:nothing, ds:_data, fs:nothing, gs:nothing
.text$mn:00003504
.text$mn:00003504 ; =============== S U B R O U T I N E =======================================
.text$mn:00003504
.text$mn:00003504 ; Attributes: bp-based frame
.text$mn:00003504
.text$mn:00003504 ; int __stdcall std::_Wrap_alloc<std::allocator<wchar_t const *>>::construct<wchar_t const *,wchar_t const * const &>(void *, int)
.text$mn:00003504                 public ??$construct@PB_WABQB_W@?$_Wrap_alloc@V?$allocator@PB_W@std@@@std@@QAEXPAPB_WABQB_W@Z
.text$mn:00003504 ??$construct@PB_WABQB_W@?$_Wrap_alloc@V?$allocator@PB_W@std@@@std@@QAEXPAPB_WABQB_W@Z proc near
.text$mn:00003504                                         ; CODE XREF: std::vector<wchar_t const *,std::allocator<wchar_t const *>>::push_back(wchar_t const * const &)+EAp
.text$mn:00003504
.text$mn:00003504 var_4           = dword ptr -4
.text$mn:00003504 arg_0           = dword ptr  8
.text$mn:00003504 arg_4           = dword ptr  0Ch
.text$mn:00003504
.text$mn:00003504                 push    ebp
.text$mn:00003505                 mov     ebp, esp
.text$mn:00003507                 push    ecx
.text$mn:00003508                 mov     [ebp+var_4], ecx
.text$mn:0000350B                 mov     eax, [ebp+arg_4]
.text$mn:0000350E                 push    eax
.text$mn:0000350F                 call    ??$forward@ABQB_W@std@@YAABQB_WABQB_W@Z ; std::forward<wchar_t const * const &>(wchar_t const * const &)
.text$mn:00003514                 add     esp, 4
.text$mn:00003517                 push    eax             ; int
.text$mn:00003518                 mov     ecx, [ebp+arg_0]
.text$mn:0000351B                 push    ecx             ; void *
.text$mn:0000351C                 mov     edx, [ebp+var_4]
.text$mn:0000351F                 push    edx             ; int
.text$mn:00003520                 call    ??$construct@PB_WABQB_W@?$allocator_traits@V?$allocator@PB_W@std@@@std@@SAXAAV?$allocator@PB_W@1@PAPB_WABQB_W@Z ; std::allocator_traits<std::allocator<wchar_t const *>>::construct<wchar_t const *,wchar_t const * const &>(std::allocator<wchar_t const *> &,wchar_t const * *,wchar_t const * const &)
.text$mn:00003525                 add     esp, 0Ch
.text$mn:00003528                 mov     esp, ebp
.text$mn:0000352A                 pop     ebp
.text$mn:0000352B                 retn    8
.text$mn:0000352B ??$construct@PB_WABQB_W@?$_Wrap_alloc@V?$allocator@PB_W@std@@@std@@QAEXPAPB_WABQB_W@Z endp
.text$mn:0000352B
.text$mn:0000352B ; ---------------------------------------------------------------------------
.text$mn:0000352E                 align 10h
.text$mn:0000352E _text$mn        ends
.text$mn:0000352E
.text$mn:00003530 ; ===========================================================================
.text$mn:00003530
.text$mn:00003530 ; Segment type: Pure code
.text$mn:00003530 ; Segment permissions: Read/Execute
.text$mn:00003530 _text$mn        segment para public 'CODE' use32
.text$mn:00003530                 assume cs:_text$mn
.text$mn:00003530                 ;org 3530h
.text$mn:00003530 ; COMDAT (pick any)
.text$mn:00003530                 assume es:nothing, ss:nothing, ds:_data, fs:nothing, gs:nothing
.text$mn:00003530
.text$mn:00003530 ; =============== S U B R O U T I N E =======================================
.text$mn:00003530
.text$mn:00003530 ; Attributes: bp-based frame
.text$mn:00003530
.text$mn:00003530 ; int __cdecl std::allocator_traits<std::allocator<wchar_t const *>>::construct<wchar_t const *,wchar_t const * const &>(int, void *, int)
.text$mn:00003530                 public ??$construct@PB_WABQB_W@?$allocator_traits@V?$allocator@PB_W@std@@@std@@SAXAAV?$allocator@PB_W@1@PAPB_WABQB_W@Z
.text$mn:00003530 ??$construct@PB_WABQB_W@?$allocator_traits@V?$allocator@PB_W@std@@@std@@SAXAAV?$allocator@PB_W@1@PAPB_WABQB_W@Z proc near
.text$mn:00003530                                         ; CODE XREF: std::_Wrap_alloc<std::allocator<wchar_t const *>>::construct<wchar_t const *,wchar_t const * const &>(wchar_t const * *,wchar_t const * const &)+1Cp
.text$mn:00003530
.text$mn:00003530 arg_0           = dword ptr  8
.text$mn:00003530 arg_4           = dword ptr  0Ch
.text$mn:00003530 arg_8           = dword ptr  10h
.text$mn:00003530
.text$mn:00003530                 push    ebp
.text$mn:00003531                 mov     ebp, esp
.text$mn:00003533                 mov     eax, [ebp+arg_8]
.text$mn:00003536                 push    eax
.text$mn:00003537                 call    ??$forward@ABQB_W@std@@YAABQB_WABQB_W@Z ; std::forward<wchar_t const * const &>(wchar_t const * const &)
.text$mn:0000353C                 add     esp, 4
.text$mn:0000353F                 push    eax             ; int
.text$mn:00003540                 mov     ecx, [ebp+arg_4]
.text$mn:00003543                 push    ecx             ; void *
.text$mn:00003544                 mov     ecx, [ebp+arg_0]
.text$mn:00003547                 call    ?construct@?$allocator@PB_W@std@@QAEXPAPB_WABQB_W@Z ; std::allocator<wchar_t const *>::construct(wchar_t const * *,wchar_t const * const &)
.text$mn:0000354C                 pop     ebp
.text$mn:0000354D                 retn
.text$mn:0000354D ??$construct@PB_WABQB_W@?$allocator_traits@V?$allocator@PB_W@std@@@std@@SAXAAV?$allocator@PB_W@1@PAPB_WABQB_W@Z endp
.text$mn:0000354D
.text$mn:0000354D ; ---------------------------------------------------------------------------
.text$mn:0000354E                 align 10h
.text$mn:0000354E _text$mn        ends
.text$mn:0000354E
.text$mn:00003550 ; ===========================================================================
.text$mn:00003550
.text$mn:00003550 ; Segment type: Pure code
.text$mn:00003550 ; Segment permissions: Read/Execute
.text$mn:00003550 _text$mn        segment para public 'CODE' use32
.text$mn:00003550                 assume cs:_text$mn
.text$mn:00003550                 ;org 3550h
.text$mn:00003550 ; COMDAT (pick any)
.text$mn:00003550                 assume es:nothing, ss:nothing, ds:_data, fs:nothing, gs:nothing
.text$mn:00003550
.text$mn:00003550 ; =============== S U B R O U T I N E =======================================
.text$mn:00003550
.text$mn:00003550 ; Attributes: bp-based frame
.text$mn:00003550
.text$mn:00003550 ; int __stdcall std::_Wrap_alloc<std::allocator<FunctionValues>>::construct<FunctionValues,FunctionValues &>(void *, int)
.text$mn:00003550                 public ??$construct@UFunctionValues@@AAU1@@?$_Wrap_alloc@V?$allocator@UFunctionValues@@@std@@@std@@QAEXPAUFunctionValues@@AAU2@@Z
.text$mn:00003550 ??$construct@UFunctionValues@@AAU1@@?$_Wrap_alloc@V?$allocator@UFunctionValues@@@std@@@std@@QAEXPAUFunctionValues@@AAU2@@Z proc near
.text$mn:00003550                                         ; CODE XREF: std::vector<FunctionValues,std::allocator<FunctionValues>>::push_back(FunctionValues const &)+8Dp
.text$mn:00003550
.text$mn:00003550 var_4           = dword ptr -4
.text$mn:00003550 arg_0           = dword ptr  8
.text$mn:00003550 arg_4           = dword ptr  0Ch
.text$mn:00003550
.text$mn:00003550                 push    ebp
.text$mn:00003551                 mov     ebp, esp
.text$mn:00003553                 push    ecx
.text$mn:00003554                 mov     [ebp+var_4], ecx
.text$mn:00003557                 mov     eax, [ebp+arg_4]
.text$mn:0000355A                 push    eax
.text$mn:0000355B                 call    ??$forward@AAUFunctionValues@@@std@@YAAAUFunctionValues@@AAU1@@Z ; std::forward<FunctionValues &>(FunctionValues &)
.text$mn:00003560                 add     esp, 4
.text$mn:00003563                 push    eax             ; int
.text$mn:00003564                 mov     ecx, [ebp+arg_0]
.text$mn:00003567                 push    ecx             ; void *
.text$mn:00003568                 mov     edx, [ebp+var_4]
.text$mn:0000356B                 push    edx             ; int
.text$mn:0000356C                 call    ??$construct@UFunctionValues@@AAU1@@?$allocator_traits@V?$allocator@UFunctionValues@@@std@@@std@@SAXAAV?$allocator@UFunctionValues@@@1@PAUFunctionValues@@AAU3@@Z ; std::allocator_traits<std::allocator<FunctionValues>>::construct<FunctionValues,FunctionValues &>(std::allocator<FunctionValues> &,FunctionValues *,FunctionValues &)
.text$mn:00003571                 add     esp, 0Ch
.text$mn:00003574                 mov     esp, ebp
.text$mn:00003576                 pop     ebp
.text$mn:00003577                 retn    8
.text$mn:00003577 ??$construct@UFunctionValues@@AAU1@@?$_Wrap_alloc@V?$allocator@UFunctionValues@@@std@@@std@@QAEXPAUFunctionValues@@AAU2@@Z endp
.text$mn:00003577
.text$mn:00003577 ; ---------------------------------------------------------------------------
.text$mn:0000357A                 align 4
.text$mn:0000357A _text$mn        ends
.text$mn:0000357A
.text$mn:0000357C ; ===========================================================================
.text$mn:0000357C
.text$mn:0000357C ; Segment type: Pure code
.text$mn:0000357C ; Segment permissions: Read/Execute
.text$mn:0000357C _text$mn        segment para public 'CODE' use32
.text$mn:0000357C                 assume cs:_text$mn
.text$mn:0000357C                 ;org 357Ch
.text$mn:0000357C ; COMDAT (pick any)
.text$mn:0000357C                 assume es:nothing, ss:nothing, ds:_data, fs:nothing, gs:nothing
.text$mn:0000357C
.text$mn:0000357C ; =============== S U B R O U T I N E =======================================
.text$mn:0000357C
.text$mn:0000357C ; Attributes: bp-based frame
.text$mn:0000357C
.text$mn:0000357C ; int __stdcall std::allocator<FunctionValues>::construct<FunctionValues,FunctionValues &>(void *, int)
.text$mn:0000357C                 public ??$construct@UFunctionValues@@AAU1@@?$allocator@UFunctionValues@@@std@@QAEXPAUFunctionValues@@AAU2@@Z
.text$mn:0000357C ??$construct@UFunctionValues@@AAU1@@?$allocator@UFunctionValues@@@std@@QAEXPAUFunctionValues@@AAU2@@Z proc near
.text$mn:0000357C                                         ; CODE XREF: std::allocator_traits<std::allocator<FunctionValues>>::construct<FunctionValues,FunctionValues &>(std::allocator<FunctionValues> &,FunctionValues *,FunctionValues &)+17p
.text$mn:0000357C
.text$mn:0000357C var_1C          = dword ptr -1Ch
.text$mn:0000357C var_18          = dword ptr -18h
.text$mn:0000357C var_14          = dword ptr -14h
.text$mn:0000357C var_10          = dword ptr -10h
.text$mn:0000357C var_C           = dword ptr -0Ch
.text$mn:0000357C var_4           = dword ptr -4
.text$mn:0000357C arg_0           = dword ptr  8
.text$mn:0000357C arg_4           = dword ptr  0Ch
.text$mn:0000357C
.text$mn:0000357C                 push    ebp
.text$mn:0000357D                 mov     ebp, esp
.text$mn:0000357F                 push    0FFFFFFFFh
.text$mn:00003581                 push    offset __ehhandler$??$construct@UFunctionValues@@AAU1@@?$allocator@UFunctionValues@@@std@@QAEXPAUFunctionValues@@AAU2@@Z
.text$mn:00003586                 mov     eax, large fs:0
.text$mn:0000358C                 push    eax
.text$mn:0000358D                 sub     esp, 10h
.text$mn:00003590                 mov     eax, dword ptr ds:___security_cookie
.text$mn:00003595                 xor     eax, ebp
.text$mn:00003597                 push    eax
.text$mn:00003598                 lea     eax, [ebp+var_C]
.text$mn:0000359B                 mov     large fs:0, eax
.text$mn:000035A1                 mov     [ebp+var_18], ecx
.text$mn:000035A4                 mov     eax, [ebp+arg_0]
.text$mn:000035A7                 push    eax             ; void *
.text$mn:000035A8                 push    10h             ; unsigned int
.text$mn:000035AA                 call    ??2@YAPAXIPAX@Z ; operator new(uint,void *)
.text$mn:000035AF                 add     esp, 8
.text$mn:000035B2                 mov     [ebp+var_10], eax
.text$mn:000035B5                 mov     [ebp+var_4], 0
.text$mn:000035BC                 cmp     [ebp+var_10], 0
.text$mn:000035C0                 jz      short loc_35EF
.text$mn:000035C2                 mov     ecx, [ebp+arg_4]
.text$mn:000035C5                 push    ecx
.text$mn:000035C6                 call    ??$forward@AAUFunctionValues@@@std@@YAAAUFunctionValues@@AAU1@@Z ; std::forward<FunctionValues &>(FunctionValues &)
.text$mn:000035CB                 add     esp, 4
.text$mn:000035CE                 mov     edx, [ebp+var_10]
.text$mn:000035D1                 mov     ecx, [eax]
.text$mn:000035D3                 mov     [edx], ecx
.text$mn:000035D5                 mov     ecx, [eax+4]
.text$mn:000035D8                 mov     [edx+4], ecx
.text$mn:000035DB                 mov     ecx, [eax+8]
.text$mn:000035DE                 mov     [edx+8], ecx
.text$mn:000035E1                 mov     eax, [eax+0Ch]
.text$mn:000035E4                 mov     [edx+0Ch], eax
.text$mn:000035E7                 mov     ecx, [ebp+var_10]
.text$mn:000035EA                 mov     [ebp+var_14], ecx
.text$mn:000035ED                 jmp     short loc_35F6
.text$mn:000035EF ; ---------------------------------------------------------------------------
.text$mn:000035EF
.text$mn:000035EF loc_35EF:                               ; CODE XREF: std::allocator<FunctionValues>::construct<FunctionValues,FunctionValues &>(FunctionValues *,FunctionValues &)+44j
.text$mn:000035EF                 mov     [ebp+var_14], 0
.text$mn:000035F6
.text$mn:000035F6 loc_35F6:                               ; CODE XREF: std::allocator<FunctionValues>::construct<FunctionValues,FunctionValues &>(FunctionValues *,FunctionValues &)+71j
.text$mn:000035F6                 mov     edx, [ebp+var_14]
.text$mn:000035F9                 mov     [ebp+var_1C], edx
.text$mn:000035FC                 mov     [ebp+var_4], 0FFFFFFFFh
.text$mn:00003603                 mov     ecx, [ebp+var_C]
.text$mn:00003606                 mov     large fs:0, ecx
.text$mn:0000360D                 pop     ecx
.text$mn:0000360E                 mov     esp, ebp
.text$mn:00003610                 pop     ebp
.text$mn:00003611                 retn    8
.text$mn:00003611 ??$construct@UFunctionValues@@AAU1@@?$allocator@UFunctionValues@@@std@@QAEXPAUFunctionValues@@AAU2@@Z endp
.text$mn:00003611
.text$mn:00003611 _text$mn        ends
.text$mn:00003611
.text$x:00003614 ; ===========================================================================
.text$x:00003614
.text$x:00003614 ; Segment type: Pure code
.text$x:00003614 ; Segment permissions: Read/Execute
.text$x:00003614 _text$x         segment para public 'CODE' use32
.text$x:00003614                 assume cs:_text$x
.text$x:00003614                 ;org 3614h
.text$x:00003614 ; COMDAT (pick associative to section at 357C)
.text$x:00003614                 assume es:nothing, ss:nothing, ds:_data, fs:nothing, gs:nothing
.text$x:00003614
.text$x:00003614 ; =============== S U B R O U T I N E =======================================
.text$x:00003614
.text$x:00003614
.text$x:00003614 __unwindfunclet$??$construct@UFunctionValues@@AAU1@@?$allocator@UFunctionValues@@@std@@QAEXPAUFunctionValues@@AAU2@@Z$0 proc near
.text$x:00003614                                         ; DATA XREF: .xdata$x:0000A0A8o
.text$x:00003614                 mov     eax, [ebp+8]
.text$x:00003617                 push    eax
.text$x:00003618                 mov     eax, [ebp-10h]
.text$x:0000361B                 push    eax             ; void *
.text$x:0000361C                 call    ??3@YAXPAX0@Z   ; operator delete(void *,void *)
.text$x:00003621                 add     esp, 8
.text$x:00003624                 retn
.text$x:00003624 __unwindfunclet$??$construct@UFunctionValues@@AAU1@@?$allocator@UFunctionValues@@@std@@QAEXPAUFunctionValues@@AAU2@@Z$0 endp
.text$x:00003624
.text$x:00003625
.text$x:00003625 ; =============== S U B R O U T I N E =======================================
.text$x:00003625
.text$x:00003625
.text$x:00003625 __ehhandler$??$construct@UFunctionValues@@AAU1@@?$allocator@UFunctionValues@@@std@@QAEXPAUFunctionValues@@AAU2@@Z proc near
.text$x:00003625                                         ; DATA XREF: std::allocator<FunctionValues>::construct<FunctionValues,FunctionValues &>(FunctionValues *,FunctionValues &)+5o
.text$x:00003625
.text$x:00003625 arg_4           = dword ptr  8
.text$x:00003625
.text$x:00003625                 mov     edx, [esp+arg_4]
.text$x:00003629                 lea     eax, [edx+0Ch]
.text$x:0000362C                 mov     ecx, [edx-14h]
.text$x:0000362F                 xor     ecx, eax
.text$x:00003631                 call    @__security_check_cookie@4 ; __security_check_cookie(x)
.text$x:00003636                 mov     eax, offset __ehfuncinfo$??$construct@UFunctionValues@@AAU1@@?$allocator@UFunctionValues@@@std@@QAEXPAUFunctionValues@@AAU2@@Z
.text$x:0000363B                 jmp     ___CxxFrameHandler3
.text$x:0000363B __ehhandler$??$construct@UFunctionValues@@AAU1@@?$allocator@UFunctionValues@@@std@@QAEXPAUFunctionValues@@AAU2@@Z endp
.text$x:0000363B
.text$x:0000363B _text$x         ends
.text$x:0000363B
.text$mn:00003640 ; ===========================================================================
.text$mn:00003640
.text$mn:00003640 ; Segment type: Pure code
.text$mn:00003640 ; Segment permissions: Read/Execute
.text$mn:00003640 _text$mn        segment para public 'CODE' use32
.text$mn:00003640                 assume cs:_text$mn
.text$mn:00003640                 ;org 3640h
.text$mn:00003640 ; COMDAT (pick any)
.text$mn:00003640                 assume es:nothing, ss:nothing, ds:_data, fs:nothing, gs:nothing
.text$mn:00003640
.text$mn:00003640 ; =============== S U B R O U T I N E =======================================
.text$mn:00003640
.text$mn:00003640 ; Attributes: bp-based frame
.text$mn:00003640
.text$mn:00003640 ; int __cdecl std::allocator_traits<std::allocator<FunctionValues>>::construct<FunctionValues,FunctionValues &>(int, void *, int)
.text$mn:00003640                 public ??$construct@UFunctionValues@@AAU1@@?$allocator_traits@V?$allocator@UFunctionValues@@@std@@@std@@SAXAAV?$allocator@UFunctionValues@@@1@PAUFunctionValues@@AAU3@@Z
.text$mn:00003640 ??$construct@UFunctionValues@@AAU1@@?$allocator_traits@V?$allocator@UFunctionValues@@@std@@@std@@SAXAAV?$allocator@UFunctionValues@@@1@PAUFunctionValues@@AAU3@@Z proc near
.text$mn:00003640                                         ; CODE XREF: std::_Wrap_alloc<std::allocator<FunctionValues>>::construct<FunctionValues,FunctionValues &>(FunctionValues *,FunctionValues &)+1Cp
.text$mn:00003640
.text$mn:00003640 arg_0           = dword ptr  8
.text$mn:00003640 arg_4           = dword ptr  0Ch
.text$mn:00003640 arg_8           = dword ptr  10h
.text$mn:00003640
.text$mn:00003640                 push    ebp
.text$mn:00003641                 mov     ebp, esp
.text$mn:00003643                 mov     eax, [ebp+arg_8]
.text$mn:00003646                 push    eax
.text$mn:00003647                 call    ??$forward@AAUFunctionValues@@@std@@YAAAUFunctionValues@@AAU1@@Z ; std::forward<FunctionValues &>(FunctionValues &)
.text$mn:0000364C                 add     esp, 4
.text$mn:0000364F                 push    eax             ; int
.text$mn:00003650                 mov     ecx, [ebp+arg_4]
.text$mn:00003653                 push    ecx             ; void *
.text$mn:00003654                 mov     ecx, [ebp+arg_0]
.text$mn:00003657                 call    ??$construct@UFunctionValues@@AAU1@@?$allocator@UFunctionValues@@@std@@QAEXPAUFunctionValues@@AAU2@@Z ; std::allocator<FunctionValues>::construct<FunctionValues,FunctionValues &>(FunctionValues *,FunctionValues &)
.text$mn:0000365C                 pop     ebp
.text$mn:0000365D                 retn
.text$mn:0000365D ??$construct@UFunctionValues@@AAU1@@?$allocator_traits@V?$allocator@UFunctionValues@@@std@@@std@@SAXAAV?$allocator@UFunctionValues@@@1@PAUFunctionValues@@AAU3@@Z endp
.text$mn:0000365D
.text$mn:0000365D ; ---------------------------------------------------------------------------
.text$mn:0000365E                 align 10h
.text$mn:0000365E _text$mn        ends
.text$mn:0000365E
.text$mn:00003660 ; ===========================================================================
.text$mn:00003660
.text$mn:00003660 ; Segment type: Pure code
.text$mn:00003660 ; Segment permissions: Read/Execute
.text$mn:00003660 _text$mn        segment para public 'CODE' use32
.text$mn:00003660                 assume cs:_text$mn
.text$mn:00003660                 ;org 3660h
.text$mn:00003660 ; COMDAT (pick any)
.text$mn:00003660                 assume es:nothing, ss:nothing, ds:_data, fs:nothing, gs:nothing
.text$mn:00003660
.text$mn:00003660 ; =============== S U B R O U T I N E =======================================
.text$mn:00003660
.text$mn:00003660 ; Attributes: bp-based frame
.text$mn:00003660
.text$mn:00003660 ; int __stdcall std::_Wrap_alloc<std::allocator<FunctionValues>>::construct<FunctionValues,FunctionValues const &>(void *, int)
.text$mn:00003660                 public ??$construct@UFunctionValues@@ABU1@@?$_Wrap_alloc@V?$allocator@UFunctionValues@@@std@@@std@@QAEXPAUFunctionValues@@ABU2@@Z
.text$mn:00003660 ??$construct@UFunctionValues@@ABU1@@?$_Wrap_alloc@V?$allocator@UFunctionValues@@@std@@@std@@QAEXPAUFunctionValues@@ABU2@@Z proc near
.text$mn:00003660                                         ; CODE XREF: std::vector<FunctionValues,std::allocator<FunctionValues>>::push_back(FunctionValues const &)+EAp
.text$mn:00003660
.text$mn:00003660 var_4           = dword ptr -4
.text$mn:00003660 arg_0           = dword ptr  8
.text$mn:00003660 arg_4           = dword ptr  0Ch
.text$mn:00003660
.text$mn:00003660                 push    ebp
.text$mn:00003661                 mov     ebp, esp
.text$mn:00003663                 push    ecx
.text$mn:00003664                 mov     [ebp+var_4], ecx
.text$mn:00003667                 mov     eax, [ebp+arg_4]
.text$mn:0000366A                 push    eax
.text$mn:0000366B                 call    ??$forward@ABUFunctionValues@@@std@@YAABUFunctionValues@@ABU1@@Z ; std::forward<FunctionValues const &>(FunctionValues const &)
.text$mn:00003670                 add     esp, 4
.text$mn:00003673                 push    eax             ; int
.text$mn:00003674                 mov     ecx, [ebp+arg_0]
.text$mn:00003677                 push    ecx             ; void *
.text$mn:00003678                 mov     edx, [ebp+var_4]
.text$mn:0000367B                 push    edx             ; int
.text$mn:0000367C                 call    ??$construct@UFunctionValues@@ABU1@@?$allocator_traits@V?$allocator@UFunctionValues@@@std@@@std@@SAXAAV?$allocator@UFunctionValues@@@1@PAUFunctionValues@@ABU3@@Z ; std::allocator_traits<std::allocator<FunctionValues>>::construct<FunctionValues,FunctionValues const &>(std::allocator<FunctionValues> &,FunctionValues *,FunctionValues const &)
.text$mn:00003681                 add     esp, 0Ch
.text$mn:00003684                 mov     esp, ebp
.text$mn:00003686                 pop     ebp
.text$mn:00003687                 retn    8
.text$mn:00003687 ??$construct@UFunctionValues@@ABU1@@?$_Wrap_alloc@V?$allocator@UFunctionValues@@@std@@@std@@QAEXPAUFunctionValues@@ABU2@@Z endp
.text$mn:00003687
.text$mn:00003687 ; ---------------------------------------------------------------------------
.text$mn:0000368A                 align 4
.text$mn:0000368A _text$mn        ends
.text$mn:0000368A
.text$mn:0000368C ; ===========================================================================
.text$mn:0000368C
.text$mn:0000368C ; Segment type: Pure code
.text$mn:0000368C ; Segment permissions: Read/Execute
.text$mn:0000368C _text$mn        segment para public 'CODE' use32
.text$mn:0000368C                 assume cs:_text$mn
.text$mn:0000368C                 ;org 368Ch
.text$mn:0000368C ; COMDAT (pick any)
.text$mn:0000368C                 assume es:nothing, ss:nothing, ds:_data, fs:nothing, gs:nothing
.text$mn:0000368C
.text$mn:0000368C ; =============== S U B R O U T I N E =======================================
.text$mn:0000368C
.text$mn:0000368C ; Attributes: bp-based frame
.text$mn:0000368C
.text$mn:0000368C ; int __cdecl std::allocator_traits<std::allocator<FunctionValues>>::construct<FunctionValues,FunctionValues const &>(int, void *, int)
.text$mn:0000368C                 public ??$construct@UFunctionValues@@ABU1@@?$allocator_traits@V?$allocator@UFunctionValues@@@std@@@std@@SAXAAV?$allocator@UFunctionValues@@@1@PAUFunctionValues@@ABU3@@Z
.text$mn:0000368C ??$construct@UFunctionValues@@ABU1@@?$allocator_traits@V?$allocator@UFunctionValues@@@std@@@std@@SAXAAV?$allocator@UFunctionValues@@@1@PAUFunctionValues@@ABU3@@Z proc near
.text$mn:0000368C                                         ; CODE XREF: std::_Wrap_alloc<std::allocator<FunctionValues>>::construct<FunctionValues,FunctionValues const &>(FunctionValues *,FunctionValues const &)+1Cp
.text$mn:0000368C
.text$mn:0000368C arg_0           = dword ptr  8
.text$mn:0000368C arg_4           = dword ptr  0Ch
.text$mn:0000368C arg_8           = dword ptr  10h
.text$mn:0000368C
.text$mn:0000368C                 push    ebp
.text$mn:0000368D                 mov     ebp, esp
.text$mn:0000368F                 mov     eax, [ebp+arg_8]
.text$mn:00003692                 push    eax
.text$mn:00003693                 call    ??$forward@ABUFunctionValues@@@std@@YAABUFunctionValues@@ABU1@@Z ; std::forward<FunctionValues const &>(FunctionValues const &)
.text$mn:00003698                 add     esp, 4
.text$mn:0000369B                 push    eax             ; int
.text$mn:0000369C                 mov     ecx, [ebp+arg_4]
.text$mn:0000369F                 push    ecx             ; void *
.text$mn:000036A0                 mov     ecx, [ebp+arg_0]
.text$mn:000036A3                 call    ?construct@?$allocator@UFunctionValues@@@std@@QAEXPAUFunctionValues@@ABU3@@Z ; std::allocator<FunctionValues>::construct(FunctionValues *,FunctionValues const &)
.text$mn:000036A8                 pop     ebp
.text$mn:000036A9                 retn
.text$mn:000036A9 ??$construct@UFunctionValues@@ABU1@@?$allocator_traits@V?$allocator@UFunctionValues@@@std@@@std@@SAXAAV?$allocator@UFunctionValues@@@1@PAUFunctionValues@@ABU3@@Z endp
.text$mn:000036A9
.text$mn:000036A9 ; ---------------------------------------------------------------------------
.text$mn:000036AA                 align 4
.text$mn:000036AA _text$mn        ends
.text$mn:000036AA
.text$mn:000036AC ; ===========================================================================
.text$mn:000036AC
.text$mn:000036AC ; Segment type: Pure code
.text$mn:000036AC ; Segment permissions: Read/Execute
.text$mn:000036AC _text$mn        segment para public 'CODE' use32
.text$mn:000036AC                 assume cs:_text$mn
.text$mn:000036AC                 ;org 36ACh
.text$mn:000036AC ; COMDAT (pick any)
.text$mn:000036AC                 assume es:nothing, ss:nothing, ds:_data, fs:nothing, gs:nothing
.text$mn:000036AC
.text$mn:000036AC ; =============== S U B R O U T I N E =======================================
.text$mn:000036AC
.text$mn:000036AC ; Attributes: bp-based frame
.text$mn:000036AC
.text$mn:000036AC ; int __stdcall std::_Wrap_alloc<std::allocator<FunctionValues>>::construct<FunctionValues,FunctionValues>(void *, int)
.text$mn:000036AC                 public ??$construct@UFunctionValues@@U1@@?$_Wrap_alloc@V?$allocator@UFunctionValues@@@std@@@std@@QAEXPAUFunctionValues@@$$QAU2@@Z
.text$mn:000036AC ??$construct@UFunctionValues@@U1@@?$_Wrap_alloc@V?$allocator@UFunctionValues@@@std@@@std@@QAEXPAUFunctionValues@@$$QAU2@@Z proc near
.text$mn:000036AC                                         ; CODE XREF: std::_Uninit_move<FunctionValues *,FunctionValues *,std::allocator<FunctionValues>,FunctionValues>(FunctionValues *,FunctionValues *,FunctionValues *,std::_Wrap_alloc<std::allocator<FunctionValues>> &,FunctionValues *,std::_Nonscalar_ptr_iterator_tag)+8Ep
.text$mn:000036AC
.text$mn:000036AC var_4           = dword ptr -4
.text$mn:000036AC arg_0           = dword ptr  8
.text$mn:000036AC arg_4           = dword ptr  0Ch
.text$mn:000036AC
.text$mn:000036AC                 push    ebp
.text$mn:000036AD                 mov     ebp, esp
.text$mn:000036AF                 push    ecx
.text$mn:000036B0                 mov     [ebp+var_4], ecx
.text$mn:000036B3                 mov     eax, [ebp+arg_4]
.text$mn:000036B6                 push    eax
.text$mn:000036B7                 call    ??$forward@UFunctionValues@@@std@@YA$$QAUFunctionValues@@AAU1@@Z ; std::forward<FunctionValues>(FunctionValues &)
.text$mn:000036BC                 add     esp, 4
.text$mn:000036BF                 push    eax             ; int
.text$mn:000036C0                 mov     ecx, [ebp+arg_0]
.text$mn:000036C3                 push    ecx             ; void *
.text$mn:000036C4                 mov     edx, [ebp+var_4]
.text$mn:000036C7                 push    edx             ; int
.text$mn:000036C8                 call    ??$construct@UFunctionValues@@U1@@?$allocator_traits@V?$allocator@UFunctionValues@@@std@@@std@@SAXAAV?$allocator@UFunctionValues@@@1@PAUFunctionValues@@$$QAU3@@Z ; std::allocator_traits<std::allocator<FunctionValues>>::construct<FunctionValues,FunctionValues>(std::allocator<FunctionValues> &,FunctionValues *,FunctionValues &&)
.text$mn:000036CD                 add     esp, 0Ch
.text$mn:000036D0                 mov     esp, ebp
.text$mn:000036D2                 pop     ebp
.text$mn:000036D3                 retn    8
.text$mn:000036D3 ??$construct@UFunctionValues@@U1@@?$_Wrap_alloc@V?$allocator@UFunctionValues@@@std@@@std@@QAEXPAUFunctionValues@@$$QAU2@@Z endp
.text$mn:000036D3
.text$mn:000036D3 ; ---------------------------------------------------------------------------
.text$mn:000036D6                 align 4
.text$mn:000036D6 _text$mn        ends
.text$mn:000036D6
.text$mn:000036D8 ; ===========================================================================
.text$mn:000036D8
.text$mn:000036D8 ; Segment type: Pure code
.text$mn:000036D8 ; Segment permissions: Read/Execute
.text$mn:000036D8 _text$mn        segment para public 'CODE' use32
.text$mn:000036D8                 assume cs:_text$mn
.text$mn:000036D8                 ;org 36D8h
.text$mn:000036D8 ; COMDAT (pick any)
.text$mn:000036D8                 assume es:nothing, ss:nothing, ds:_data, fs:nothing, gs:nothing
.text$mn:000036D8
.text$mn:000036D8 ; =============== S U B R O U T I N E =======================================
.text$mn:000036D8
.text$mn:000036D8 ; Attributes: bp-based frame
.text$mn:000036D8
.text$mn:000036D8 ; int __stdcall std::allocator<FunctionValues>::construct<FunctionValues,FunctionValues>(void *, int)
.text$mn:000036D8                 public ??$construct@UFunctionValues@@U1@@?$allocator@UFunctionValues@@@std@@QAEXPAUFunctionValues@@$$QAU2@@Z
.text$mn:000036D8 ??$construct@UFunctionValues@@U1@@?$allocator@UFunctionValues@@@std@@QAEXPAUFunctionValues@@$$QAU2@@Z proc near
.text$mn:000036D8                                         ; CODE XREF: std::allocator_traits<std::allocator<FunctionValues>>::construct<FunctionValues,FunctionValues>(std::allocator<FunctionValues> &,FunctionValues *,FunctionValues &&)+17p
.text$mn:000036D8
.text$mn:000036D8 var_1C          = dword ptr -1Ch
.text$mn:000036D8 var_18          = dword ptr -18h
.text$mn:000036D8 var_14          = dword ptr -14h
.text$mn:000036D8 var_10          = dword ptr -10h
.text$mn:000036D8 var_C           = dword ptr -0Ch
.text$mn:000036D8 var_4           = dword ptr -4
.text$mn:000036D8 arg_0           = dword ptr  8
.text$mn:000036D8 arg_4           = dword ptr  0Ch
.text$mn:000036D8
.text$mn:000036D8                 push    ebp
.text$mn:000036D9                 mov     ebp, esp
.text$mn:000036DB                 push    0FFFFFFFFh
.text$mn:000036DD                 push    offset __ehhandler$??$construct@UFunctionValues@@U1@@?$allocator@UFunctionValues@@@std@@QAEXPAUFunctionValues@@$$QAU2@@Z
.text$mn:000036E2                 mov     eax, large fs:0
.text$mn:000036E8                 push    eax
.text$mn:000036E9                 sub     esp, 10h
.text$mn:000036EC                 mov     eax, dword ptr ds:___security_cookie
.text$mn:000036F1                 xor     eax, ebp
.text$mn:000036F3                 push    eax
.text$mn:000036F4                 lea     eax, [ebp+var_C]
.text$mn:000036F7                 mov     large fs:0, eax
.text$mn:000036FD                 mov     [ebp+var_18], ecx
.text$mn:00003700                 mov     eax, [ebp+arg_0]
.text$mn:00003703                 push    eax             ; void *
.text$mn:00003704                 push    10h             ; unsigned int
.text$mn:00003706                 call    ??2@YAPAXIPAX@Z ; operator new(uint,void *)
.text$mn:0000370B                 add     esp, 8
.text$mn:0000370E                 mov     [ebp+var_10], eax
.text$mn:00003711                 mov     [ebp+var_4], 0
.text$mn:00003718                 cmp     [ebp+var_10], 0
.text$mn:0000371C                 jz      short loc_374B
.text$mn:0000371E                 mov     ecx, [ebp+arg_4]
.text$mn:00003721                 push    ecx
.text$mn:00003722                 call    ??$forward@UFunctionValues@@@std@@YA$$QAUFunctionValues@@AAU1@@Z ; std::forward<FunctionValues>(FunctionValues &)
.text$mn:00003727                 add     esp, 4
.text$mn:0000372A                 mov     edx, [ebp+var_10]
.text$mn:0000372D                 mov     ecx, [eax]
.text$mn:0000372F                 mov     [edx], ecx
.text$mn:00003731                 mov     ecx, [eax+4]
.text$mn:00003734                 mov     [edx+4], ecx
.text$mn:00003737                 mov     ecx, [eax+8]
.text$mn:0000373A                 mov     [edx+8], ecx
.text$mn:0000373D                 mov     eax, [eax+0Ch]
.text$mn:00003740                 mov     [edx+0Ch], eax
.text$mn:00003743                 mov     ecx, [ebp+var_10]
.text$mn:00003746                 mov     [ebp+var_14], ecx
.text$mn:00003749                 jmp     short loc_3752
.text$mn:0000374B ; ---------------------------------------------------------------------------
.text$mn:0000374B
.text$mn:0000374B loc_374B:                               ; CODE XREF: std::allocator<FunctionValues>::construct<FunctionValues,FunctionValues>(FunctionValues *,FunctionValues &&)+44j
.text$mn:0000374B                 mov     [ebp+var_14], 0
.text$mn:00003752
.text$mn:00003752 loc_3752:                               ; CODE XREF: std::allocator<FunctionValues>::construct<FunctionValues,FunctionValues>(FunctionValues *,FunctionValues &&)+71j
.text$mn:00003752                 mov     edx, [ebp+var_14]
.text$mn:00003755                 mov     [ebp+var_1C], edx
.text$mn:00003758                 mov     [ebp+var_4], 0FFFFFFFFh
.text$mn:0000375F                 mov     ecx, [ebp+var_C]
.text$mn:00003762                 mov     large fs:0, ecx
.text$mn:00003769                 pop     ecx
.text$mn:0000376A                 mov     esp, ebp
.text$mn:0000376C                 pop     ebp
.text$mn:0000376D                 retn    8
.text$mn:0000376D ??$construct@UFunctionValues@@U1@@?$allocator@UFunctionValues@@@std@@QAEXPAUFunctionValues@@$$QAU2@@Z endp
.text$mn:0000376D
.text$mn:0000376D _text$mn        ends
.text$mn:0000376D
.text$x:00003770 ; ===========================================================================
.text$x:00003770
.text$x:00003770 ; Segment type: Pure code
.text$x:00003770 ; Segment permissions: Read/Execute
.text$x:00003770 _text$x         segment para public 'CODE' use32
.text$x:00003770                 assume cs:_text$x
.text$x:00003770                 ;org 3770h
.text$x:00003770 ; COMDAT (pick associative to section at 36D8)
.text$x:00003770                 assume es:nothing, ss:nothing, ds:_data, fs:nothing, gs:nothing
.text$x:00003770
.text$x:00003770 ; =============== S U B R O U T I N E =======================================
.text$x:00003770
.text$x:00003770
.text$x:00003770 __unwindfunclet$??$construct@UFunctionValues@@U1@@?$allocator@UFunctionValues@@@std@@QAEXPAUFunctionValues@@$$QAU2@@Z$0 proc near
.text$x:00003770                                         ; DATA XREF: .xdata$x:0000A2E8o
.text$x:00003770                 mov     eax, [ebp+8]
.text$x:00003773                 push    eax
.text$x:00003774                 mov     eax, [ebp-10h]
.text$x:00003777                 push    eax             ; void *
.text$x:00003778                 call    ??3@YAXPAX0@Z   ; operator delete(void *,void *)
.text$x:0000377D                 add     esp, 8
.text$x:00003780                 retn
.text$x:00003780 __unwindfunclet$??$construct@UFunctionValues@@U1@@?$allocator@UFunctionValues@@@std@@QAEXPAUFunctionValues@@$$QAU2@@Z$0 endp
.text$x:00003780
.text$x:00003781
.text$x:00003781 ; =============== S U B R O U T I N E =======================================
.text$x:00003781
.text$x:00003781
.text$x:00003781 __ehhandler$??$construct@UFunctionValues@@U1@@?$allocator@UFunctionValues@@@std@@QAEXPAUFunctionValues@@$$QAU2@@Z proc near
.text$x:00003781                                         ; DATA XREF: std::allocator<FunctionValues>::construct<FunctionValues,FunctionValues>(FunctionValues *,FunctionValues &&)+5o
.text$x:00003781
.text$x:00003781 arg_4           = dword ptr  8
.text$x:00003781
.text$x:00003781                 mov     edx, [esp+arg_4]
.text$x:00003785                 lea     eax, [edx+0Ch]
.text$x:00003788                 mov     ecx, [edx-14h]
.text$x:0000378B                 xor     ecx, eax
.text$x:0000378D                 call    @__security_check_cookie@4 ; __security_check_cookie(x)
.text$x:00003792                 mov     eax, offset __ehfuncinfo$??$construct@UFunctionValues@@U1@@?$allocator@UFunctionValues@@@std@@QAEXPAUFunctionValues@@$$QAU2@@Z
.text$x:00003797                 jmp     ___CxxFrameHandler3
.text$x:00003797 __ehhandler$??$construct@UFunctionValues@@U1@@?$allocator@UFunctionValues@@@std@@QAEXPAUFunctionValues@@$$QAU2@@Z endp
.text$x:00003797
.text$x:00003797 _text$x         ends
.text$x:00003797
.text$mn:0000379C ; ===========================================================================
.text$mn:0000379C
.text$mn:0000379C ; Segment type: Pure code
.text$mn:0000379C ; Segment permissions: Read/Execute
.text$mn:0000379C _text$mn        segment para public 'CODE' use32
.text$mn:0000379C                 assume cs:_text$mn
.text$mn:0000379C                 ;org 379Ch
.text$mn:0000379C ; COMDAT (pick any)
.text$mn:0000379C                 assume es:nothing, ss:nothing, ds:_data, fs:nothing, gs:nothing
.text$mn:0000379C
.text$mn:0000379C ; =============== S U B R O U T I N E =======================================
.text$mn:0000379C
.text$mn:0000379C ; Attributes: bp-based frame
.text$mn:0000379C
.text$mn:0000379C ; int __cdecl std::allocator_traits<std::allocator<FunctionValues>>::construct<FunctionValues,FunctionValues>(int, void *, int)
.text$mn:0000379C                 public ??$construct@UFunctionValues@@U1@@?$allocator_traits@V?$allocator@UFunctionValues@@@std@@@std@@SAXAAV?$allocator@UFunctionValues@@@1@PAUFunctionValues@@$$QAU3@@Z
.text$mn:0000379C ??$construct@UFunctionValues@@U1@@?$allocator_traits@V?$allocator@UFunctionValues@@@std@@@std@@SAXAAV?$allocator@UFunctionValues@@@1@PAUFunctionValues@@$$QAU3@@Z proc near
.text$mn:0000379C                                         ; CODE XREF: std::_Wrap_alloc<std::allocator<FunctionValues>>::construct<FunctionValues,FunctionValues>(FunctionValues *,FunctionValues &&)+1Cp
.text$mn:0000379C
.text$mn:0000379C arg_0           = dword ptr  8
.text$mn:0000379C arg_4           = dword ptr  0Ch
.text$mn:0000379C arg_8           = dword ptr  10h
.text$mn:0000379C
.text$mn:0000379C                 push    ebp
.text$mn:0000379D                 mov     ebp, esp
.text$mn:0000379F                 mov     eax, [ebp+arg_8]
.text$mn:000037A2                 push    eax
.text$mn:000037A3                 call    ??$forward@UFunctionValues@@@std@@YA$$QAUFunctionValues@@AAU1@@Z ; std::forward<FunctionValues>(FunctionValues &)
.text$mn:000037A8                 add     esp, 4
.text$mn:000037AB                 push    eax             ; int
.text$mn:000037AC                 mov     ecx, [ebp+arg_4]
.text$mn:000037AF                 push    ecx             ; void *
.text$mn:000037B0                 mov     ecx, [ebp+arg_0]
.text$mn:000037B3                 call    ??$construct@UFunctionValues@@U1@@?$allocator@UFunctionValues@@@std@@QAEXPAUFunctionValues@@$$QAU2@@Z ; std::allocator<FunctionValues>::construct<FunctionValues,FunctionValues>(FunctionValues *,FunctionValues &&)
.text$mn:000037B8                 pop     ebp
.text$mn:000037B9                 retn
.text$mn:000037B9 ??$construct@UFunctionValues@@U1@@?$allocator_traits@V?$allocator@UFunctionValues@@@std@@@std@@SAXAAV?$allocator@UFunctionValues@@@1@PAUFunctionValues@@$$QAU3@@Z endp
.text$mn:000037B9
.text$mn:000037B9 ; ---------------------------------------------------------------------------
.text$mn:000037BA                 align 4
.text$mn:000037BA _text$mn        ends
.text$mn:000037BA
.text$mn:000037BC ; ===========================================================================
.text$mn:000037BC
.text$mn:000037BC ; Segment type: Pure code
.text$mn:000037BC ; Segment permissions: Read/Execute
.text$mn:000037BC _text$mn        segment para public 'CODE' use32
.text$mn:000037BC                 assume cs:_text$mn
.text$mn:000037BC                 ;org 37BCh
.text$mn:000037BC ; COMDAT (pick any)
.text$mn:000037BC                 assume es:nothing, ss:nothing, ds:_data, fs:nothing, gs:nothing
.text$mn:000037BC
.text$mn:000037BC ; =============== S U B R O U T I N E =======================================
.text$mn:000037BC
.text$mn:000037BC ; Attributes: bp-based frame
.text$mn:000037BC
.text$mn:000037BC ; int __stdcall std::_Wrap_alloc<std::allocator<Token>>::construct<Token,Token>(void *, int)
.text$mn:000037BC                 public ??$construct@UToken@@U1@@?$_Wrap_alloc@V?$allocator@UToken@@@std@@@std@@QAEXPAUToken@@$$QAU2@@Z
.text$mn:000037BC ??$construct@UToken@@U1@@?$_Wrap_alloc@V?$allocator@UToken@@@std@@@std@@QAEXPAUToken@@$$QAU2@@Z proc near
.text$mn:000037BC                                         ; CODE XREF: std::_Uninit_move<Token *,Token *,std::allocator<Token>,Token>(Token *,Token *,Token *,std::_Wrap_alloc<std::allocator<Token>> &,Token *,std::_Nonscalar_ptr_iterator_tag)+8Ep
.text$mn:000037BC                                         ; std::vector<Token,std::allocator<Token>>::push_back(Token &&)+9Dp ...
.text$mn:000037BC
.text$mn:000037BC var_4           = dword ptr -4
.text$mn:000037BC arg_0           = dword ptr  8
.text$mn:000037BC arg_4           = dword ptr  0Ch
.text$mn:000037BC
.text$mn:000037BC                 push    ebp
.text$mn:000037BD                 mov     ebp, esp
.text$mn:000037BF                 push    ecx
.text$mn:000037C0                 mov     [ebp+var_4], ecx
.text$mn:000037C3                 mov     eax, [ebp+arg_4]
.text$mn:000037C6                 push    eax
.text$mn:000037C7                 call    ??$forward@UToken@@@std@@YA$$QAUToken@@AAU1@@Z ; std::forward<Token>(Token &)
.text$mn:000037CC                 add     esp, 4
.text$mn:000037CF                 push    eax             ; int
.text$mn:000037D0                 mov     ecx, [ebp+arg_0]
.text$mn:000037D3                 push    ecx             ; void *
.text$mn:000037D4                 mov     edx, [ebp+var_4]
.text$mn:000037D7                 push    edx             ; int
.text$mn:000037D8                 call    ??$construct@UToken@@U1@@?$allocator_traits@V?$allocator@UToken@@@std@@@std@@SAXAAV?$allocator@UToken@@@1@PAUToken@@$$QAU3@@Z ; std::allocator_traits<std::allocator<Token>>::construct<Token,Token>(std::allocator<Token> &,Token *,Token &&)
.text$mn:000037DD                 add     esp, 0Ch
.text$mn:000037E0                 mov     esp, ebp
.text$mn:000037E2                 pop     ebp
.text$mn:000037E3                 retn    8
.text$mn:000037E3 ??$construct@UToken@@U1@@?$_Wrap_alloc@V?$allocator@UToken@@@std@@@std@@QAEXPAUToken@@$$QAU2@@Z endp
.text$mn:000037E3
.text$mn:000037E3 ; ---------------------------------------------------------------------------
.text$mn:000037E6                 align 4
.text$mn:000037E6 _text$mn        ends
.text$mn:000037E6
.text$mn:000037E8 ; ===========================================================================
.text$mn:000037E8
.text$mn:000037E8 ; Segment type: Pure code
.text$mn:000037E8 ; Segment permissions: Read/Execute
.text$mn:000037E8 _text$mn        segment para public 'CODE' use32
.text$mn:000037E8                 assume cs:_text$mn
.text$mn:000037E8                 ;org 37E8h
.text$mn:000037E8 ; COMDAT (pick any)
.text$mn:000037E8                 assume es:nothing, ss:nothing, ds:_data, fs:nothing, gs:nothing
.text$mn:000037E8
.text$mn:000037E8 ; =============== S U B R O U T I N E =======================================
.text$mn:000037E8
.text$mn:000037E8 ; Attributes: bp-based frame
.text$mn:000037E8
.text$mn:000037E8 ; int __stdcall std::allocator<Token>::construct<Token,Token>(void *, int)
.text$mn:000037E8                 public ??$construct@UToken@@U1@@?$allocator@UToken@@@std@@QAEXPAUToken@@$$QAU2@@Z
.text$mn:000037E8 ??$construct@UToken@@U1@@?$allocator@UToken@@@std@@QAEXPAUToken@@$$QAU2@@Z proc near
.text$mn:000037E8                                         ; CODE XREF: std::allocator_traits<std::allocator<Token>>::construct<Token,Token>(std::allocator<Token> &,Token *,Token &&)+17p
.text$mn:000037E8
.text$mn:000037E8 var_1C          = dword ptr -1Ch
.text$mn:000037E8 var_18          = dword ptr -18h
.text$mn:000037E8 var_14          = dword ptr -14h
.text$mn:000037E8 var_10          = dword ptr -10h
.text$mn:000037E8 var_C           = dword ptr -0Ch
.text$mn:000037E8 var_4           = dword ptr -4
.text$mn:000037E8 arg_0           = dword ptr  8
.text$mn:000037E8 arg_4           = dword ptr  0Ch
.text$mn:000037E8
.text$mn:000037E8                 push    ebp
.text$mn:000037E9                 mov     ebp, esp
.text$mn:000037EB                 push    0FFFFFFFFh
.text$mn:000037ED                 push    offset __ehhandler$??$construct@UToken@@U1@@?$allocator@UToken@@@std@@QAEXPAUToken@@$$QAU2@@Z
.text$mn:000037F2                 mov     eax, large fs:0
.text$mn:000037F8                 push    eax
.text$mn:000037F9                 sub     esp, 10h
.text$mn:000037FC                 mov     eax, dword ptr ds:___security_cookie
.text$mn:00003801                 xor     eax, ebp
.text$mn:00003803                 push    eax
.text$mn:00003804                 lea     eax, [ebp+var_C]
.text$mn:00003807                 mov     large fs:0, eax
.text$mn:0000380D                 mov     [ebp+var_18], ecx
.text$mn:00003810                 mov     eax, [ebp+arg_0]
.text$mn:00003813                 push    eax             ; void *
.text$mn:00003814                 push    0Ch             ; unsigned int
.text$mn:00003816                 call    ??2@YAPAXIPAX@Z ; operator new(uint,void *)
.text$mn:0000381B                 add     esp, 8
.text$mn:0000381E                 mov     [ebp+var_10], eax
.text$mn:00003821                 mov     [ebp+var_4], 0
.text$mn:00003828                 cmp     [ebp+var_10], 0
.text$mn:0000382C                 jz      short loc_3855
.text$mn:0000382E                 mov     ecx, [ebp+arg_4]
.text$mn:00003831                 push    ecx
.text$mn:00003832                 call    ??$forward@UToken@@@std@@YA$$QAUToken@@AAU1@@Z ; std::forward<Token>(Token &)
.text$mn:00003837                 add     esp, 4
.text$mn:0000383A                 mov     edx, [ebp+var_10]
.text$mn:0000383D                 mov     ecx, [eax]
.text$mn:0000383F                 mov     [edx], ecx
.text$mn:00003841                 mov     ecx, [eax+4]
.text$mn:00003844                 mov     [edx+4], ecx
.text$mn:00003847                 mov     eax, [eax+8]
.text$mn:0000384A                 mov     [edx+8], eax
.text$mn:0000384D                 mov     ecx, [ebp+var_10]
.text$mn:00003850                 mov     [ebp+var_14], ecx
.text$mn:00003853                 jmp     short loc_385C
.text$mn:00003855 ; ---------------------------------------------------------------------------
.text$mn:00003855
.text$mn:00003855 loc_3855:                               ; CODE XREF: std::allocator<Token>::construct<Token,Token>(Token *,Token &&)+44j
.text$mn:00003855                 mov     [ebp+var_14], 0
.text$mn:0000385C
.text$mn:0000385C loc_385C:                               ; CODE XREF: std::allocator<Token>::construct<Token,Token>(Token *,Token &&)+6Bj
.text$mn:0000385C                 mov     edx, [ebp+var_14]
.text$mn:0000385F                 mov     [ebp+var_1C], edx
.text$mn:00003862                 mov     [ebp+var_4], 0FFFFFFFFh
.text$mn:00003869                 mov     ecx, [ebp+var_C]
.text$mn:0000386C                 mov     large fs:0, ecx
.text$mn:00003873                 pop     ecx
.text$mn:00003874                 mov     esp, ebp
.text$mn:00003876                 pop     ebp
.text$mn:00003877                 retn    8
.text$mn:00003877 ??$construct@UToken@@U1@@?$allocator@UToken@@@std@@QAEXPAUToken@@$$QAU2@@Z endp
.text$mn:00003877
.text$mn:00003877 ; ---------------------------------------------------------------------------
.text$mn:0000387A                 align 4
.text$mn:0000387A _text$mn        ends
.text$mn:0000387A
.text$x:0000387C ; ===========================================================================
.text$x:0000387C
.text$x:0000387C ; Segment type: Pure code
.text$x:0000387C ; Segment permissions: Read/Execute
.text$x:0000387C _text$x         segment para public 'CODE' use32
.text$x:0000387C                 assume cs:_text$x
.text$x:0000387C                 ;org 387Ch
.text$x:0000387C ; COMDAT (pick associative to section at 37E8)
.text$x:0000387C                 assume es:nothing, ss:nothing, ds:_data, fs:nothing, gs:nothing
.text$x:0000387C
.text$x:0000387C ; =============== S U B R O U T I N E =======================================
.text$x:0000387C
.text$x:0000387C
.text$x:0000387C __unwindfunclet$??$construct@UToken@@U1@@?$allocator@UToken@@@std@@QAEXPAUToken@@$$QAU2@@Z$0 proc near
.text$x:0000387C                                         ; DATA XREF: .xdata$x:0000A07Co
.text$x:0000387C                 mov     eax, [ebp+8]
.text$x:0000387F                 push    eax
.text$x:00003880                 mov     eax, [ebp-10h]
.text$x:00003883                 push    eax             ; void *
.text$x:00003884                 call    ??3@YAXPAX0@Z   ; operator delete(void *,void *)
.text$x:00003889                 add     esp, 8
.text$x:0000388C                 retn
.text$x:0000388C __unwindfunclet$??$construct@UToken@@U1@@?$allocator@UToken@@@std@@QAEXPAUToken@@$$QAU2@@Z$0 endp
.text$x:0000388C
.text$x:0000388D
.text$x:0000388D ; =============== S U B R O U T I N E =======================================
.text$x:0000388D
.text$x:0000388D
.text$x:0000388D __ehhandler$??$construct@UToken@@U1@@?$allocator@UToken@@@std@@QAEXPAUToken@@$$QAU2@@Z proc near
.text$x:0000388D                                         ; DATA XREF: std::allocator<Token>::construct<Token,Token>(Token *,Token &&)+5o
.text$x:0000388D
.text$x:0000388D arg_4           = dword ptr  8
.text$x:0000388D
.text$x:0000388D                 mov     edx, [esp+arg_4]
.text$x:00003891                 lea     eax, [edx+0Ch]
.text$x:00003894                 mov     ecx, [edx-14h]
.text$x:00003897                 xor     ecx, eax
.text$x:00003899                 call    @__security_check_cookie@4 ; __security_check_cookie(x)
.text$x:0000389E                 mov     eax, offset __ehfuncinfo$??$construct@UToken@@U1@@?$allocator@UToken@@@std@@QAEXPAUToken@@$$QAU2@@Z
.text$x:000038A3                 jmp     ___CxxFrameHandler3
.text$x:000038A3 __ehhandler$??$construct@UToken@@U1@@?$allocator@UToken@@@std@@QAEXPAUToken@@$$QAU2@@Z endp
.text$x:000038A3
.text$x:000038A3 _text$x         ends
.text$x:000038A3
.text$mn:000038A8 ; ===========================================================================
.text$mn:000038A8
.text$mn:000038A8 ; Segment type: Pure code
.text$mn:000038A8 ; Segment permissions: Read/Execute
.text$mn:000038A8 _text$mn        segment para public 'CODE' use32
.text$mn:000038A8                 assume cs:_text$mn
.text$mn:000038A8                 ;org 38A8h
.text$mn:000038A8 ; COMDAT (pick any)
.text$mn:000038A8                 assume es:nothing, ss:nothing, ds:_data, fs:nothing, gs:nothing
.text$mn:000038A8
.text$mn:000038A8 ; =============== S U B R O U T I N E =======================================
.text$mn:000038A8
.text$mn:000038A8 ; Attributes: bp-based frame
.text$mn:000038A8
.text$mn:000038A8 ; int __cdecl std::allocator_traits<std::allocator<Token>>::construct<Token,Token>(int, void *, int)
.text$mn:000038A8                 public ??$construct@UToken@@U1@@?$allocator_traits@V?$allocator@UToken@@@std@@@std@@SAXAAV?$allocator@UToken@@@1@PAUToken@@$$QAU3@@Z
.text$mn:000038A8 ??$construct@UToken@@U1@@?$allocator_traits@V?$allocator@UToken@@@std@@@std@@SAXAAV?$allocator@UToken@@@1@PAUToken@@$$QAU3@@Z proc near
.text$mn:000038A8                                         ; CODE XREF: std::_Wrap_alloc<std::allocator<Token>>::construct<Token,Token>(Token *,Token &&)+1Cp
.text$mn:000038A8
.text$mn:000038A8 arg_0           = dword ptr  8
.text$mn:000038A8 arg_4           = dword ptr  0Ch
.text$mn:000038A8 arg_8           = dword ptr  10h
.text$mn:000038A8
.text$mn:000038A8                 push    ebp
.text$mn:000038A9                 mov     ebp, esp
.text$mn:000038AB                 mov     eax, [ebp+arg_8]
.text$mn:000038AE                 push    eax
.text$mn:000038AF                 call    ??$forward@UToken@@@std@@YA$$QAUToken@@AAU1@@Z ; std::forward<Token>(Token &)
.text$mn:000038B4                 add     esp, 4
.text$mn:000038B7                 push    eax             ; int
.text$mn:000038B8                 mov     ecx, [ebp+arg_4]
.text$mn:000038BB                 push    ecx             ; void *
.text$mn:000038BC                 mov     ecx, [ebp+arg_0]
.text$mn:000038BF                 call    ??$construct@UToken@@U1@@?$allocator@UToken@@@std@@QAEXPAUToken@@$$QAU2@@Z ; std::allocator<Token>::construct<Token,Token>(Token *,Token &&)
.text$mn:000038C4                 pop     ebp
.text$mn:000038C5                 retn
.text$mn:000038C5 ??$construct@UToken@@U1@@?$allocator_traits@V?$allocator@UToken@@@std@@@std@@SAXAAV?$allocator@UToken@@@1@PAUToken@@$$QAU3@@Z endp
.text$mn:000038C5
.text$mn:000038C5 ; ---------------------------------------------------------------------------
.text$mn:000038C6                 align 4
.text$mn:000038C6 _text$mn        ends
.text$mn:000038C6
.text$mn:000038C8 ; ===========================================================================
.text$mn:000038C8
.text$mn:000038C8 ; Segment type: Pure code
.text$mn:000038C8 ; Segment permissions: Read/Execute
.text$mn:000038C8 _text$mn        segment para public 'CODE' use32
.text$mn:000038C8                 assume cs:_text$mn
.text$mn:000038C8                 ;org 38C8h
.text$mn:000038C8 ; COMDAT (pick any)
.text$mn:000038C8                 assume es:nothing, ss:nothing, ds:_data, fs:nothing, gs:nothing
.text$mn:000038C8
.text$mn:000038C8 ; =============== S U B R O U T I N E =======================================
.text$mn:000038C8
.text$mn:000038C8 ; Attributes: bp-based frame
.text$mn:000038C8
.text$mn:000038C8 ; int __stdcall std::_Wrap_alloc<std::allocator<std::_Container_proxy>>::construct<std::_Container_proxy,std::_Container_proxy>(void *, int)
.text$mn:000038C8                 public ??$construct@U_Container_proxy@std@@U12@@?$_Wrap_alloc@V?$allocator@U_Container_proxy@std@@@std@@@std@@QAEXPAU_Container_proxy@1@$$QAU21@@Z
.text$mn:000038C8 ??$construct@U_Container_proxy@std@@U12@@?$_Wrap_alloc@V?$allocator@U_Container_proxy@std@@@std@@@std@@QAEXPAU_Container_proxy@1@$$QAU21@@Z proc near
.text$mn:000038C8                                         ; CODE XREF: std::_Vector_alloc<0,std::_Vec_base_types<wchar_t const *,std::allocator<wchar_t const *>>>::_Alloc_proxy(void)+32p
.text$mn:000038C8                                         ; std::_Vector_alloc<0,std::_Vec_base_types<FunctionValues,std::allocator<FunctionValues>>>::_Alloc_proxy(void)+32p ...
.text$mn:000038C8
.text$mn:000038C8 var_4           = dword ptr -4
.text$mn:000038C8 arg_0           = dword ptr  8
.text$mn:000038C8 arg_4           = dword ptr  0Ch
.text$mn:000038C8
.text$mn:000038C8                 push    ebp
.text$mn:000038C9                 mov     ebp, esp
.text$mn:000038CB                 push    ecx
.text$mn:000038CC                 mov     [ebp+var_4], ecx
.text$mn:000038CF                 mov     eax, [ebp+arg_4]
.text$mn:000038D2                 push    eax
.text$mn:000038D3                 call    ??$forward@U_Container_proxy@std@@@std@@YA$$QAU_Container_proxy@0@AAU10@@Z ; std::forward<std::_Container_proxy>(std::_Container_proxy &)
.text$mn:000038D8                 add     esp, 4
.text$mn:000038DB                 push    eax             ; int
.text$mn:000038DC                 mov     ecx, [ebp+arg_0]
.text$mn:000038DF                 push    ecx             ; void *
.text$mn:000038E0                 mov     edx, [ebp+var_4]
.text$mn:000038E3                 push    edx             ; int
.text$mn:000038E4                 call    ??$construct@U_Container_proxy@std@@U12@@?$allocator_traits@V?$allocator@U_Container_proxy@std@@@std@@@std@@SAXAAV?$allocator@U_Container_proxy@std@@@1@PAU_Container_proxy@1@$$QAU31@@Z ; std::allocator_traits<std::allocator<std::_Container_proxy>>::construct<std::_Container_proxy,std::_Container_proxy>(std::allocator<std::_Container_proxy> &,std::_Container_proxy *,std::_Container_proxy &&)
.text$mn:000038E9                 add     esp, 0Ch
.text$mn:000038EC                 mov     esp, ebp
.text$mn:000038EE                 pop     ebp
.text$mn:000038EF                 retn    8
.text$mn:000038EF ??$construct@U_Container_proxy@std@@U12@@?$_Wrap_alloc@V?$allocator@U_Container_proxy@std@@@std@@@std@@QAEXPAU_Container_proxy@1@$$QAU21@@Z endp
.text$mn:000038EF
.text$mn:000038EF ; ---------------------------------------------------------------------------
.text$mn:000038F2                 align 4
.text$mn:000038F2 _text$mn        ends
.text$mn:000038F2
.text$mn:000038F4 ; ===========================================================================
.text$mn:000038F4
.text$mn:000038F4 ; Segment type: Pure code
.text$mn:000038F4 ; Segment permissions: Read/Execute
.text$mn:000038F4 _text$mn        segment para public 'CODE' use32
.text$mn:000038F4                 assume cs:_text$mn
.text$mn:000038F4                 ;org 38F4h
.text$mn:000038F4 ; COMDAT (pick any)
.text$mn:000038F4                 assume es:nothing, ss:nothing, ds:_data, fs:nothing, gs:nothing
.text$mn:000038F4
.text$mn:000038F4 ; =============== S U B R O U T I N E =======================================
.text$mn:000038F4
.text$mn:000038F4 ; Attributes: bp-based frame
.text$mn:000038F4
.text$mn:000038F4 ; int __stdcall std::allocator<std::_Container_proxy>::construct<std::_Container_proxy,std::_Container_proxy>(void *, int)
.text$mn:000038F4                 public ??$construct@U_Container_proxy@std@@U12@@?$allocator@U_Container_proxy@std@@@std@@QAEXPAU_Container_proxy@1@$$QAU21@@Z
.text$mn:000038F4 ??$construct@U_Container_proxy@std@@U12@@?$allocator@U_Container_proxy@std@@@std@@QAEXPAU_Container_proxy@1@$$QAU21@@Z proc near
.text$mn:000038F4                                         ; CODE XREF: std::allocator_traits<std::allocator<std::_Container_proxy>>::construct<std::_Container_proxy,std::_Container_proxy>(std::allocator<std::_Container_proxy> &,std::_Container_proxy *,std::_Container_proxy &&)+17p
.text$mn:000038F4                                         ; std::_String_alloc<0,std::_String_base_types<char,std::allocator<char>>>::_Alloc_proxy(void)+32p
.text$mn:000038F4
.text$mn:000038F4 var_1C          = dword ptr -1Ch
.text$mn:000038F4 var_18          = dword ptr -18h
.text$mn:000038F4 var_14          = dword ptr -14h
.text$mn:000038F4 var_10          = dword ptr -10h
.text$mn:000038F4 var_C           = dword ptr -0Ch
.text$mn:000038F4 var_4           = dword ptr -4
.text$mn:000038F4 arg_0           = dword ptr  8
.text$mn:000038F4 arg_4           = dword ptr  0Ch
.text$mn:000038F4
.text$mn:000038F4                 push    ebp
.text$mn:000038F5                 mov     ebp, esp
.text$mn:000038F7                 push    0FFFFFFFFh
.text$mn:000038F9                 push    offset __ehhandler$??$construct@U_Container_proxy@std@@U12@@?$allocator@U_Container_proxy@std@@@std@@QAEXPAU_Container_proxy@1@$$QAU21@@Z
.text$mn:000038FE                 mov     eax, large fs:0
.text$mn:00003904                 push    eax
.text$mn:00003905                 sub     esp, 10h
.text$mn:00003908                 mov     eax, dword ptr ds:___security_cookie
.text$mn:0000390D                 xor     eax, ebp
.text$mn:0000390F                 push    eax
.text$mn:00003910                 lea     eax, [ebp+var_C]
.text$mn:00003913                 mov     large fs:0, eax
.text$mn:00003919                 mov     [ebp+var_18], ecx
.text$mn:0000391C                 mov     eax, [ebp+arg_0]
.text$mn:0000391F                 push    eax             ; void *
.text$mn:00003920                 push    8               ; unsigned int
.text$mn:00003922                 call    ??2@YAPAXIPAX@Z ; operator new(uint,void *)
.text$mn:00003927                 add     esp, 8
.text$mn:0000392A                 mov     [ebp+var_10], eax
.text$mn:0000392D                 mov     [ebp+var_4], 0
.text$mn:00003934                 cmp     [ebp+var_10], 0
.text$mn:00003938                 jz      short loc_395B
.text$mn:0000393A                 mov     ecx, [ebp+arg_4]
.text$mn:0000393D                 push    ecx
.text$mn:0000393E                 call    ??$forward@U_Container_proxy@std@@@std@@YA$$QAU_Container_proxy@0@AAU10@@Z ; std::forward<std::_Container_proxy>(std::_Container_proxy &)
.text$mn:00003943                 add     esp, 4
.text$mn:00003946                 mov     edx, [eax]
.text$mn:00003948                 mov     eax, [eax+4]
.text$mn:0000394B                 mov     ecx, [ebp+var_10]
.text$mn:0000394E                 mov     [ecx], edx
.text$mn:00003950                 mov     [ecx+4], eax
.text$mn:00003953                 mov     edx, [ebp+var_10]
.text$mn:00003956                 mov     [ebp+var_14], edx
.text$mn:00003959                 jmp     short loc_3962
.text$mn:0000395B ; ---------------------------------------------------------------------------
.text$mn:0000395B
.text$mn:0000395B loc_395B:                               ; CODE XREF: std::allocator<std::_Container_proxy>::construct<std::_Container_proxy,std::_Container_proxy>(std::_Container_proxy *,std::_Container_proxy &&)+44j
.text$mn:0000395B                 mov     [ebp+var_14], 0
.text$mn:00003962
.text$mn:00003962 loc_3962:                               ; CODE XREF: std::allocator<std::_Container_proxy>::construct<std::_Container_proxy,std::_Container_proxy>(std::_Container_proxy *,std::_Container_proxy &&)+65j
.text$mn:00003962                 mov     eax, [ebp+var_14]
.text$mn:00003965                 mov     [ebp+var_1C], eax
.text$mn:00003968                 mov     [ebp+var_4], 0FFFFFFFFh
.text$mn:0000396F                 mov     ecx, [ebp+var_C]
.text$mn:00003972                 mov     large fs:0, ecx
.text$mn:00003979                 pop     ecx
.text$mn:0000397A                 mov     esp, ebp
.text$mn:0000397C                 pop     ebp
.text$mn:0000397D                 retn    8
.text$mn:0000397D ??$construct@U_Container_proxy@std@@U12@@?$allocator@U_Container_proxy@std@@@std@@QAEXPAU_Container_proxy@1@$$QAU21@@Z endp
.text$mn:0000397D
.text$mn:0000397D _text$mn        ends
.text$mn:0000397D
.text$x:00003980 ; ===========================================================================
.text$x:00003980
.text$x:00003980 ; Segment type: Pure code
.text$x:00003980 ; Segment permissions: Read/Execute
.text$x:00003980 _text$x         segment para public 'CODE' use32
.text$x:00003980                 assume cs:_text$x
.text$x:00003980                 ;org 3980h
.text$x:00003980 ; COMDAT (pick associative to section at 38F4)
.text$x:00003980                 assume es:nothing, ss:nothing, ds:_data, fs:nothing, gs:nothing
.text$x:00003980
.text$x:00003980 ; =============== S U B R O U T I N E =======================================
.text$x:00003980
.text$x:00003980
.text$x:00003980 __unwindfunclet$??$construct@U_Container_proxy@std@@U12@@?$allocator@U_Container_proxy@std@@@std@@QAEXPAU_Container_proxy@1@$$QAU21@@Z$0 proc near
.text$x:00003980                                         ; DATA XREF: .xdata$x:00009FF8o
.text$x:00003980                 mov     eax, [ebp+8]
.text$x:00003983                 push    eax
.text$x:00003984                 mov     eax, [ebp-10h]
.text$x:00003987                 push    eax             ; void *
.text$x:00003988                 call    ??3@YAXPAX0@Z   ; operator delete(void *,void *)
.text$x:0000398D                 add     esp, 8
.text$x:00003990                 retn
.text$x:00003990 __unwindfunclet$??$construct@U_Container_proxy@std@@U12@@?$allocator@U_Container_proxy@std@@@std@@QAEXPAU_Container_proxy@1@$$QAU21@@Z$0 endp
.text$x:00003990
.text$x:00003991
.text$x:00003991 ; =============== S U B R O U T I N E =======================================
.text$x:00003991
.text$x:00003991
.text$x:00003991 __ehhandler$??$construct@U_Container_proxy@std@@U12@@?$allocator@U_Container_proxy@std@@@std@@QAEXPAU_Container_proxy@1@$$QAU21@@Z proc near
.text$x:00003991                                         ; DATA XREF: std::allocator<std::_Container_proxy>::construct<std::_Container_proxy,std::_Container_proxy>(std::_Container_proxy *,std::_Container_proxy &&)+5o
.text$x:00003991
.text$x:00003991 arg_4           = dword ptr  8
.text$x:00003991
.text$x:00003991                 mov     edx, [esp+arg_4]
.text$x:00003995                 lea     eax, [edx+0Ch]
.text$x:00003998                 mov     ecx, [edx-14h]
.text$x:0000399B                 xor     ecx, eax
.text$x:0000399D                 call    @__security_check_cookie@4 ; __security_check_cookie(x)
.text$x:000039A2                 mov     eax, offset __ehfuncinfo$??$construct@U_Container_proxy@std@@U12@@?$allocator@U_Container_proxy@std@@@std@@QAEXPAU_Container_proxy@1@$$QAU21@@Z
.text$x:000039A7                 jmp     ___CxxFrameHandler3
.text$x:000039A7 __ehhandler$??$construct@U_Container_proxy@std@@U12@@?$allocator@U_Container_proxy@std@@@std@@QAEXPAU_Container_proxy@1@$$QAU21@@Z endp
.text$x:000039A7
.text$x:000039A7 _text$x         ends
.text$x:000039A7
.text$mn:000039AC ; ===========================================================================
.text$mn:000039AC
.text$mn:000039AC ; Segment type: Pure code
.text$mn:000039AC ; Segment permissions: Read/Execute
.text$mn:000039AC _text$mn        segment para public 'CODE' use32
.text$mn:000039AC                 assume cs:_text$mn
.text$mn:000039AC                 ;org 39ACh
.text$mn:000039AC ; COMDAT (pick any)
.text$mn:000039AC                 assume es:nothing, ss:nothing, ds:_data, fs:nothing, gs:nothing
.text$mn:000039AC
.text$mn:000039AC ; =============== S U B R O U T I N E =======================================
.text$mn:000039AC
.text$mn:000039AC ; Attributes: bp-based frame
.text$mn:000039AC
.text$mn:000039AC ; int __cdecl std::allocator_traits<std::allocator<std::_Container_proxy>>::construct<std::_Container_proxy,std::_Container_proxy>(int, void *, int)
.text$mn:000039AC                 public ??$construct@U_Container_proxy@std@@U12@@?$allocator_traits@V?$allocator@U_Container_proxy@std@@@std@@@std@@SAXAAV?$allocator@U_Container_proxy@std@@@1@PAU_Container_proxy@1@$$QAU31@@Z
.text$mn:000039AC ??$construct@U_Container_proxy@std@@U12@@?$allocator_traits@V?$allocator@U_Container_proxy@std@@@std@@@std@@SAXAAV?$allocator@U_Container_proxy@std@@@1@PAU_Container_proxy@1@$$QAU31@@Z proc near
.text$mn:000039AC                                         ; CODE XREF: std::_Wrap_alloc<std::allocator<std::_Container_proxy>>::construct<std::_Container_proxy,std::_Container_proxy>(std::_Container_proxy *,std::_Container_proxy &&)+1Cp
.text$mn:000039AC
.text$mn:000039AC arg_0           = dword ptr  8
.text$mn:000039AC arg_4           = dword ptr  0Ch
.text$mn:000039AC arg_8           = dword ptr  10h
.text$mn:000039AC
.text$mn:000039AC                 push    ebp
.text$mn:000039AD                 mov     ebp, esp
.text$mn:000039AF                 mov     eax, [ebp+arg_8]
.text$mn:000039B2                 push    eax
.text$mn:000039B3                 call    ??$forward@U_Container_proxy@std@@@std@@YA$$QAU_Container_proxy@0@AAU10@@Z ; std::forward<std::_Container_proxy>(std::_Container_proxy &)
.text$mn:000039B8                 add     esp, 4
.text$mn:000039BB                 push    eax             ; int
.text$mn:000039BC                 mov     ecx, [ebp+arg_4]
.text$mn:000039BF                 push    ecx             ; void *
.text$mn:000039C0                 mov     ecx, [ebp+arg_0]
.text$mn:000039C3                 call    ??$construct@U_Container_proxy@std@@U12@@?$allocator@U_Container_proxy@std@@@std@@QAEXPAU_Container_proxy@1@$$QAU21@@Z ; std::allocator<std::_Container_proxy>::construct<std::_Container_proxy,std::_Container_proxy>(std::_Container_proxy *,std::_Container_proxy &&)
.text$mn:000039C8                 pop     ebp
.text$mn:000039C9                 retn
.text$mn:000039C9 ??$construct@U_Container_proxy@std@@U12@@?$allocator_traits@V?$allocator@U_Container_proxy@std@@@std@@@std@@SAXAAV?$allocator@U_Container_proxy@std@@@1@PAU_Container_proxy@1@$$QAU31@@Z endp
.text$mn:000039C9
.text$mn:000039C9 ; ---------------------------------------------------------------------------
.text$mn:000039CA                 align 4
.text$mn:000039CA _text$mn        ends
.text$mn:000039CA
.text$mn:000039CC ; ===========================================================================
.text$mn:000039CC
.text$mn:000039CC ; Segment type: Pure code
.text$mn:000039CC ; Segment permissions: Read/Execute
.text$mn:000039CC _text$mn        segment para public 'CODE' use32
.text$mn:000039CC                 assume cs:_text$mn
.text$mn:000039CC                 ;org 39CCh
.text$mn:000039CC ; COMDAT (pick any)
.text$mn:000039CC                 assume es:nothing, ss:nothing, ds:_data, fs:nothing, gs:nothing
.text$mn:000039CC
.text$mn:000039CC ; =============== S U B R O U T I N E =======================================
.text$mn:000039CC
.text$mn:000039CC ; Attributes: bp-based frame
.text$mn:000039CC
.text$mn:000039CC ; int __stdcall std::_Wrap_alloc<std::allocator<std::vector<wchar_t const *,std::allocator<wchar_t const *>>>>::construct<std::vector<wchar_t const *,std::allocator<wchar_t const *>>,std::vector<wchar_t const *,std::allocator<wchar_t const *>> &>(void *, int)
.text$mn:000039CC                 public ??$construct@V?$vector@PB_WV?$allocator@PB_W@std@@@std@@AAV12@@?$_Wrap_alloc@V?$allocator@V?$vector@PB_WV?$allocator@PB_W@std@@@std@@@std@@@std@@QAEXPAV?$vector@PB_WV?$allocator@PB_W@std@@@1@AAV21@@Z
.text$mn:000039CC ??$construct@V?$vector@PB_WV?$allocator@PB_W@std@@@std@@AAV12@@?$_Wrap_alloc@V?$allocator@V?$vector@PB_WV?$allocator@PB_W@std@@@std@@@std@@@std@@QAEXPAV?$vector@PB_WV?$allocator@PB_W@std@@@1@AAV21@@Z proc near
.text$mn:000039CC                                         ; CODE XREF: std::vector<std::vector<wchar_t const *,std::allocator<wchar_t const *>>,std::allocator<std::vector<wchar_t const *,std::allocator<wchar_t const *>>>>::push_back(std::vector<wchar_t const *,std::allocator<wchar_t const *>> const &)+8Dp
.text$mn:000039CC
.text$mn:000039CC var_4           = dword ptr -4
.text$mn:000039CC arg_0           = dword ptr  8
.text$mn:000039CC arg_4           = dword ptr  0Ch
.text$mn:000039CC
.text$mn:000039CC                 push    ebp
.text$mn:000039CD                 mov     ebp, esp
.text$mn:000039CF                 push    ecx
.text$mn:000039D0                 mov     [ebp+var_4], ecx
.text$mn:000039D3                 mov     eax, [ebp+arg_4]
.text$mn:000039D6                 push    eax
.text$mn:000039D7                 call    ??$forward@AAV?$vector@PB_WV?$allocator@PB_W@std@@@std@@@std@@YAAAV?$vector@PB_WV?$allocator@PB_W@std@@@0@AAV10@@Z ; std::forward<std::vector<wchar_t const *,std::allocator<wchar_t const *>> &>(std::vector<wchar_t const *,std::allocator<wchar_t const *>> &)
.text$mn:000039DC                 add     esp, 4
.text$mn:000039DF                 push    eax             ; int
.text$mn:000039E0                 mov     ecx, [ebp+arg_0]
.text$mn:000039E3                 push    ecx             ; void *
.text$mn:000039E4                 mov     edx, [ebp+var_4]
.text$mn:000039E7                 push    edx             ; int
.text$mn:000039E8                 call    ??$construct@V?$vector@PB_WV?$allocator@PB_W@std@@@std@@AAV12@@?$allocator_traits@V?$allocator@V?$vector@PB_WV?$allocator@PB_W@std@@@std@@@std@@@std@@SAXAAV?$allocator@V?$vector@PB_WV?$allocator@PB_W@std@@@std@@@1@PAV?$vector@PB_WV?$allocator@PB_W@std@@@1@AAV31@@Z ; std::allocator_traits<std::allocator<std::vector<wchar_t const *,std::allocator<wchar_t const *>>>>::construct<std::vector<wchar_t const *,std::allocator<wchar_t const *>>,std::vector<wchar_t const *,std::allocator<wchar_t const *>> &>(std::allocator<std::vector<wchar_t const *,std::allocator<wchar_t const *>>> &,std::vector<wchar_t const *,std::allocator<wchar_t const *>> *,std::vector<wchar_t const *,std::allocator<wchar_t const *>> &)
.text$mn:000039ED                 add     esp, 0Ch
.text$mn:000039F0                 mov     esp, ebp
.text$mn:000039F2                 pop     ebp
.text$mn:000039F3                 retn    8
.text$mn:000039F3 ??$construct@V?$vector@PB_WV?$allocator@PB_W@std@@@std@@AAV12@@?$_Wrap_alloc@V?$allocator@V?$vector@PB_WV?$allocator@PB_W@std@@@std@@@std@@@std@@QAEXPAV?$vector@PB_WV?$allocator@PB_W@std@@@1@AAV21@@Z endp
.text$mn:000039F3
.text$mn:000039F3 ; ---------------------------------------------------------------------------
.text$mn:000039F6                 align 4
.text$mn:000039F6 _text$mn        ends
.text$mn:000039F6
.text$mn:000039F8 ; ===========================================================================
.text$mn:000039F8
.text$mn:000039F8 ; Segment type: Pure code
.text$mn:000039F8 ; Segment permissions: Read/Execute
.text$mn:000039F8 _text$mn        segment para public 'CODE' use32
.text$mn:000039F8                 assume cs:_text$mn
.text$mn:000039F8                 ;org 39F8h
.text$mn:000039F8 ; COMDAT (pick any)
.text$mn:000039F8                 assume es:nothing, ss:nothing, ds:_data, fs:nothing, gs:nothing
.text$mn:000039F8
.text$mn:000039F8 ; =============== S U B R O U T I N E =======================================
.text$mn:000039F8
.text$mn:000039F8 ; Attributes: bp-based frame
.text$mn:000039F8
.text$mn:000039F8 ; int __stdcall std::allocator<std::vector<wchar_t const *,std::allocator<wchar_t const *>>>::construct<std::vector<wchar_t const *,std::allocator<wchar_t const *>>,std::vector<wchar_t const *,std::allocator<wchar_t const *>> &>(void *, int)
.text$mn:000039F8                 public ??$construct@V?$vector@PB_WV?$allocator@PB_W@std@@@std@@AAV12@@?$allocator@V?$vector@PB_WV?$allocator@PB_W@std@@@std@@@std@@QAEXPAV?$vector@PB_WV?$allocator@PB_W@std@@@1@AAV21@@Z
.text$mn:000039F8 ??$construct@V?$vector@PB_WV?$allocator@PB_W@std@@@std@@AAV12@@?$allocator@V?$vector@PB_WV?$allocator@PB_W@std@@@std@@@std@@QAEXPAV?$vector@PB_WV?$allocator@PB_W@std@@@1@AAV21@@Z proc near
.text$mn:000039F8                                         ; CODE XREF: std::allocator_traits<std::allocator<std::vector<wchar_t const *,std::allocator<wchar_t const *>>>>::construct<std::vector<wchar_t const *,std::allocator<wchar_t const *>>,std::vector<wchar_t const *,std::allocator<wchar_t const *>> &>(std::allocator<std::vector<wchar_t const *,std::allocator<wchar_t const *>>> &,std::vector<wchar_t const *,std::allocator<wchar_t const *>> *,std::vector<wchar_t const *,std::allocator<wchar_t const *>> &)+17p
.text$mn:000039F8
.text$mn:000039F8 var_1C          = dword ptr -1Ch
.text$mn:000039F8 var_18          = dword ptr -18h
.text$mn:000039F8 var_14          = dword ptr -14h
.text$mn:000039F8 var_10          = dword ptr -10h
.text$mn:000039F8 var_C           = dword ptr -0Ch
.text$mn:000039F8 var_4           = dword ptr -4
.text$mn:000039F8 arg_0           = dword ptr  8
.text$mn:000039F8 arg_4           = dword ptr  0Ch
.text$mn:000039F8
.text$mn:000039F8                 push    ebp
.text$mn:000039F9                 mov     ebp, esp
.text$mn:000039FB                 push    0FFFFFFFFh
.text$mn:000039FD                 push    offset __ehhandler$??$construct@V?$vector@PB_WV?$allocator@PB_W@std@@@std@@AAV12@@?$allocator@V?$vector@PB_WV?$allocator@PB_W@std@@@std@@@std@@QAEXPAV?$vector@PB_WV?$allocator@PB_W@std@@@1@AAV21@@Z
.text$mn:00003A02                 mov     eax, large fs:0
.text$mn:00003A08                 push    eax
.text$mn:00003A09                 sub     esp, 10h
.text$mn:00003A0C                 mov     eax, dword ptr ds:___security_cookie
.text$mn:00003A11                 xor     eax, ebp
.text$mn:00003A13                 push    eax
.text$mn:00003A14                 lea     eax, [ebp+var_C]
.text$mn:00003A17                 mov     large fs:0, eax
.text$mn:00003A1D                 mov     [ebp+var_18], ecx
.text$mn:00003A20                 mov     eax, [ebp+arg_0]
.text$mn:00003A23                 push    eax             ; void *
.text$mn:00003A24                 push    10h             ; unsigned int
.text$mn:00003A26                 call    ??2@YAPAXIPAX@Z ; operator new(uint,void *)
.text$mn:00003A2B                 add     esp, 8
.text$mn:00003A2E                 mov     [ebp+var_10], eax
.text$mn:00003A31                 mov     [ebp+var_4], 0
.text$mn:00003A38                 cmp     [ebp+var_10], 0
.text$mn:00003A3C                 jz      short loc_3A58
.text$mn:00003A3E                 mov     ecx, [ebp+arg_4]
.text$mn:00003A41                 push    ecx
.text$mn:00003A42                 call    ??$forward@AAV?$vector@PB_WV?$allocator@PB_W@std@@@std@@@std@@YAAAV?$vector@PB_WV?$allocator@PB_W@std@@@0@AAV10@@Z ; std::forward<std::vector<wchar_t const *,std::allocator<wchar_t const *>> &>(std::vector<wchar_t const *,std::allocator<wchar_t const *>> &)
.text$mn:00003A47                 add     esp, 4
.text$mn:00003A4A                 push    eax
.text$mn:00003A4B                 mov     ecx, [ebp+var_10]
.text$mn:00003A4E                 call    ??0?$vector@PB_WV?$allocator@PB_W@std@@@std@@QAE@ABV01@@Z ; std::vector<wchar_t const *,std::allocator<wchar_t const *>>::vector<wchar_t const *,std::allocator<wchar_t const *>>(std::vector<wchar_t const *,std::allocator<wchar_t const *>> const &)
.text$mn:00003A53                 mov     [ebp+var_14], eax
.text$mn:00003A56                 jmp     short loc_3A5F
.text$mn:00003A58 ; ---------------------------------------------------------------------------
.text$mn:00003A58
.text$mn:00003A58 loc_3A58:                               ; CODE XREF: std::allocator<std::vector<wchar_t const *,std::allocator<wchar_t const *>>>::construct<std::vector<wchar_t const *,std::allocator<wchar_t const *>>,std::vector<wchar_t const *,std::allocator<wchar_t const *>> &>(std::vector<wchar_t const *,std::allocator<wchar_t const *>> *,std::vector<wchar_t const *,std::allocator<wchar_t const *>> &)+44j
.text$mn:00003A58                 mov     [ebp+var_14], 0
.text$mn:00003A5F
.text$mn:00003A5F loc_3A5F:                               ; CODE XREF: std::allocator<std::vector<wchar_t const *,std::allocator<wchar_t const *>>>::construct<std::vector<wchar_t const *,std::allocator<wchar_t const *>>,std::vector<wchar_t const *,std::allocator<wchar_t const *>> &>(std::vector<wchar_t const *,std::allocator<wchar_t const *>> *,std::vector<wchar_t const *,std::allocator<wchar_t const *>> &)+5Ej
.text$mn:00003A5F                 mov     edx, [ebp+var_14]
.text$mn:00003A62                 mov     [ebp+var_1C], edx
.text$mn:00003A65                 mov     [ebp+var_4], 0FFFFFFFFh
.text$mn:00003A6C                 mov     ecx, [ebp+var_C]
.text$mn:00003A6F                 mov     large fs:0, ecx
.text$mn:00003A76                 pop     ecx
.text$mn:00003A77                 mov     esp, ebp
.text$mn:00003A79                 pop     ebp
.text$mn:00003A7A                 retn    8
.text$mn:00003A7A ??$construct@V?$vector@PB_WV?$allocator@PB_W@std@@@std@@AAV12@@?$allocator@V?$vector@PB_WV?$allocator@PB_W@std@@@std@@@std@@QAEXPAV?$vector@PB_WV?$allocator@PB_W@std@@@1@AAV21@@Z endp
.text$mn:00003A7A
.text$mn:00003A7A ; ---------------------------------------------------------------------------
.text$mn:00003A7D                 align 10h
.text$mn:00003A7D _text$mn        ends
.text$mn:00003A7D
.text$x:00003A80 ; ===========================================================================
.text$x:00003A80
.text$x:00003A80 ; Segment type: Pure code
.text$x:00003A80 ; Segment permissions: Read/Execute
.text$x:00003A80 _text$x         segment para public 'CODE' use32
.text$x:00003A80                 assume cs:_text$x
.text$x:00003A80                 ;org 3A80h
.text$x:00003A80 ; COMDAT (pick associative to section at 39F8)
.text$x:00003A80                 assume es:nothing, ss:nothing, ds:_data, fs:nothing, gs:nothing
.text$x:00003A80
.text$x:00003A80 ; =============== S U B R O U T I N E =======================================
.text$x:00003A80
.text$x:00003A80
.text$x:00003A80 __unwindfunclet$??$construct@V?$vector@PB_WV?$allocator@PB_W@std@@@std@@AAV12@@?$allocator@V?$vector@PB_WV?$allocator@PB_W@std@@@std@@@std@@QAEXPAV?$vector@PB_WV?$allocator@PB_W@std@@@1@AAV21@@Z$0 proc near
.text$x:00003A80                                         ; DATA XREF: .xdata$x:0000A050o
.text$x:00003A80                 mov     eax, [ebp+8]
.text$x:00003A83                 push    eax
.text$x:00003A84                 mov     eax, [ebp-10h]
.text$x:00003A87                 push    eax             ; void *
.text$x:00003A88                 call    ??3@YAXPAX0@Z   ; operator delete(void *,void *)
.text$x:00003A8D                 add     esp, 8
.text$x:00003A90                 retn
.text$x:00003A90 __unwindfunclet$??$construct@V?$vector@PB_WV?$allocator@PB_W@std@@@std@@AAV12@@?$allocator@V?$vector@PB_WV?$allocator@PB_W@std@@@std@@@std@@QAEXPAV?$vector@PB_WV?$allocator@PB_W@std@@@1@AAV21@@Z$0 endp
.text$x:00003A90
.text$x:00003A91
.text$x:00003A91 ; =============== S U B R O U T I N E =======================================
.text$x:00003A91
.text$x:00003A91
.text$x:00003A91 __ehhandler$??$construct@V?$vector@PB_WV?$allocator@PB_W@std@@@std@@AAV12@@?$allocator@V?$vector@PB_WV?$allocator@PB_W@std@@@std@@@std@@QAEXPAV?$vector@PB_WV?$allocator@PB_W@std@@@1@AAV21@@Z proc near
.text$x:00003A91                                         ; DATA XREF: std::allocator<std::vector<wchar_t const *,std::allocator<wchar_t const *>>>::construct<std::vector<wchar_t const *,std::allocator<wchar_t const *>>,std::vector<wchar_t const *,std::allocator<wchar_t const *>> &>(std::vector<wchar_t const *,std::allocator<wchar_t const *>> *,std::vector<wchar_t const *,std::allocator<wchar_t const *>> &)+5o
.text$x:00003A91
.text$x:00003A91 arg_4           = dword ptr  8
.text$x:00003A91
.text$x:00003A91                 mov     edx, [esp+arg_4]
.text$x:00003A95                 lea     eax, [edx+0Ch]
.text$x:00003A98                 mov     ecx, [edx-14h]
.text$x:00003A9B                 xor     ecx, eax
.text$x:00003A9D                 call    @__security_check_cookie@4 ; __security_check_cookie(x)
.text$x:00003AA2                 mov     eax, offset __ehfuncinfo$??$construct@V?$vector@PB_WV?$allocator@PB_W@std@@@std@@AAV12@@?$allocator@V?$vector@PB_WV?$allocator@PB_W@std@@@std@@@std@@QAEXPAV?$vector@PB_WV?$allocator@PB_W@std@@@1@AAV21@@Z
.text$x:00003AA7                 jmp     ___CxxFrameHandler3
.text$x:00003AA7 __ehhandler$??$construct@V?$vector@PB_WV?$allocator@PB_W@std@@@std@@AAV12@@?$allocator@V?$vector@PB_WV?$allocator@PB_W@std@@@std@@@std@@QAEXPAV?$vector@PB_WV?$allocator@PB_W@std@@@1@AAV21@@Z endp
.text$x:00003AA7
.text$x:00003AA7 _text$x         ends
.text$x:00003AA7
.text$mn:00003AAC ; ===========================================================================
.text$mn:00003AAC
.text$mn:00003AAC ; Segment type: Pure code
.text$mn:00003AAC ; Segment permissions: Read/Execute
.text$mn:00003AAC _text$mn        segment para public 'CODE' use32
.text$mn:00003AAC                 assume cs:_text$mn
.text$mn:00003AAC                 ;org 3AACh
.text$mn:00003AAC ; COMDAT (pick any)
.text$mn:00003AAC                 assume es:nothing, ss:nothing, ds:_data, fs:nothing, gs:nothing
.text$mn:00003AAC
.text$mn:00003AAC ; =============== S U B R O U T I N E =======================================
.text$mn:00003AAC
.text$mn:00003AAC ; Attributes: bp-based frame
.text$mn:00003AAC
.text$mn:00003AAC ; int __cdecl std::allocator_traits<std::allocator<std::vector<wchar_t const *,std::allocator<wchar_t const *>>>>::construct<std::vector<wchar_t const *,std::allocator<wchar_t const *>>,std::vector<wchar_t const *,std::allocator<wchar_t const *>> &>(int, void *, int)
.text$mn:00003AAC                 public ??$construct@V?$vector@PB_WV?$allocator@PB_W@std@@@std@@AAV12@@?$allocator_traits@V?$allocator@V?$vector@PB_WV?$allocator@PB_W@std@@@std@@@std@@@std@@SAXAAV?$allocator@V?$vector@PB_WV?$allocator@PB_W@std@@@std@@@1@PAV?$vector@PB_WV?$allocator@PB_W@std@@@1@AAV31@@Z
.text$mn:00003AAC ??$construct@V?$vector@PB_WV?$allocator@PB_W@std@@@std@@AAV12@@?$allocator_traits@V?$allocator@V?$vector@PB_WV?$allocator@PB_W@std@@@std@@@std@@@std@@SAXAAV?$allocator@V?$vector@PB_WV?$allocator@PB_W@std@@@std@@@1@PAV?$vector@PB_WV?$allocator@PB_W@std@@@1@AAV31@@Z proc near
.text$mn:00003AAC                                         ; CODE XREF: std::_Wrap_alloc<std::allocator<std::vector<wchar_t const *,std::allocator<wchar_t const *>>>>::construct<std::vector<wchar_t const *,std::allocator<wchar_t const *>>,std::vector<wchar_t const *,std::allocator<wchar_t const *>> &>(std::vector<wchar_t const *,std::allocator<wchar_t const *>> *,std::vector<wchar_t const *,std::allocator<wchar_t const *>> &)+1Cp
.text$mn:00003AAC
.text$mn:00003AAC arg_0           = dword ptr  8
.text$mn:00003AAC arg_4           = dword ptr  0Ch
.text$mn:00003AAC arg_8           = dword ptr  10h
.text$mn:00003AAC
.text$mn:00003AAC                 push    ebp
.text$mn:00003AAD                 mov     ebp, esp
.text$mn:00003AAF                 mov     eax, [ebp+arg_8]
.text$mn:00003AB2                 push    eax
.text$mn:00003AB3                 call    ??$forward@AAV?$vector@PB_WV?$allocator@PB_W@std@@@std@@@std@@YAAAV?$vector@PB_WV?$allocator@PB_W@std@@@0@AAV10@@Z ; std::forward<std::vector<wchar_t const *,std::allocator<wchar_t const *>> &>(std::vector<wchar_t const *,std::allocator<wchar_t const *>> &)
.text$mn:00003AB8                 add     esp, 4
.text$mn:00003ABB                 push    eax             ; int
.text$mn:00003ABC                 mov     ecx, [ebp+arg_4]
.text$mn:00003ABF                 push    ecx             ; void *
.text$mn:00003AC0                 mov     ecx, [ebp+arg_0]
.text$mn:00003AC3                 call    ??$construct@V?$vector@PB_WV?$allocator@PB_W@std@@@std@@AAV12@@?$allocator@V?$vector@PB_WV?$allocator@PB_W@std@@@std@@@std@@QAEXPAV?$vector@PB_WV?$allocator@PB_W@std@@@1@AAV21@@Z ; std::allocator<std::vector<wchar_t const *,std::allocator<wchar_t const *>>>::construct<std::vector<wchar_t const *,std::allocator<wchar_t const *>>,std::vector<wchar_t const *,std::allocator<wchar_t const *>> &>(std::vector<wchar_t const *,std::allocator<wchar_t const *>> *,std::vector<wchar_t const *,std::allocator<wchar_t const *>> &)
.text$mn:00003AC8                 pop     ebp
.text$mn:00003AC9                 retn
.text$mn:00003AC9 ??$construct@V?$vector@PB_WV?$allocator@PB_W@std@@@std@@AAV12@@?$allocator_traits@V?$allocator@V?$vector@PB_WV?$allocator@PB_W@std@@@std@@@std@@@std@@SAXAAV?$allocator@V?$vector@PB_WV?$allocator@PB_W@std@@@std@@@1@PAV?$vector@PB_WV?$allocator@PB_W@std@@@1@AAV31@@Z endp
.text$mn:00003AC9
.text$mn:00003AC9 ; ---------------------------------------------------------------------------
.text$mn:00003ACA                 align 4
.text$mn:00003ACA _text$mn        ends
.text$mn:00003ACA
.text$mn:00003ACC ; ===========================================================================
.text$mn:00003ACC
.text$mn:00003ACC ; Segment type: Pure code
.text$mn:00003ACC ; Segment permissions: Read/Execute
.text$mn:00003ACC _text$mn        segment para public 'CODE' use32
.text$mn:00003ACC                 assume cs:_text$mn
.text$mn:00003ACC                 ;org 3ACCh
.text$mn:00003ACC ; COMDAT (pick any)
.text$mn:00003ACC                 assume es:nothing, ss:nothing, ds:_data, fs:nothing, gs:nothing
.text$mn:00003ACC
.text$mn:00003ACC ; =============== S U B R O U T I N E =======================================
.text$mn:00003ACC
.text$mn:00003ACC ; Attributes: bp-based frame
.text$mn:00003ACC
.text$mn:00003ACC ; int __stdcall std::_Wrap_alloc<std::allocator<std::vector<wchar_t const *,std::allocator<wchar_t const *>>>>::construct<std::vector<wchar_t const *,std::allocator<wchar_t const *>>,std::vector<wchar_t const *,std::allocator<wchar_t const *>> const &>(void *, int)
.text$mn:00003ACC                 public ??$construct@V?$vector@PB_WV?$allocator@PB_W@std@@@std@@ABV12@@?$_Wrap_alloc@V?$allocator@V?$vector@PB_WV?$allocator@PB_W@std@@@std@@@std@@@std@@QAEXPAV?$vector@PB_WV?$allocator@PB_W@std@@@1@ABV21@@Z
.text$mn:00003ACC ??$construct@V?$vector@PB_WV?$allocator@PB_W@std@@@std@@ABV12@@?$_Wrap_alloc@V?$allocator@V?$vector@PB_WV?$allocator@PB_W@std@@@std@@@std@@@std@@QAEXPAV?$vector@PB_WV?$allocator@PB_W@std@@@1@ABV21@@Z proc near
.text$mn:00003ACC                                         ; CODE XREF: std::vector<std::vector<wchar_t const *,std::allocator<wchar_t const *>>,std::allocator<std::vector<wchar_t const *,std::allocator<wchar_t const *>>>>::push_back(std::vector<wchar_t const *,std::allocator<wchar_t const *>> const &)+EAp
.text$mn:00003ACC
.text$mn:00003ACC var_4           = dword ptr -4
.text$mn:00003ACC arg_0           = dword ptr  8
.text$mn:00003ACC arg_4           = dword ptr  0Ch
.text$mn:00003ACC
.text$mn:00003ACC                 push    ebp
.text$mn:00003ACD                 mov     ebp, esp
.text$mn:00003ACF                 push    ecx
.text$mn:00003AD0                 mov     [ebp+var_4], ecx
.text$mn:00003AD3                 mov     eax, [ebp+arg_4]
.text$mn:00003AD6                 push    eax
.text$mn:00003AD7                 call    ??$forward@ABV?$vector@PB_WV?$allocator@PB_W@std@@@std@@@std@@YAABV?$vector@PB_WV?$allocator@PB_W@std@@@0@ABV10@@Z ; std::forward<std::vector<wchar_t const *,std::allocator<wchar_t const *>> const &>(std::vector<wchar_t const *,std::allocator<wchar_t const *>> const &)
.text$mn:00003ADC                 add     esp, 4
.text$mn:00003ADF                 push    eax             ; int
.text$mn:00003AE0                 mov     ecx, [ebp+arg_0]
.text$mn:00003AE3                 push    ecx             ; void *
.text$mn:00003AE4                 mov     edx, [ebp+var_4]
.text$mn:00003AE7                 push    edx             ; int
.text$mn:00003AE8                 call    ??$construct@V?$vector@PB_WV?$allocator@PB_W@std@@@std@@ABV12@@?$allocator_traits@V?$allocator@V?$vector@PB_WV?$allocator@PB_W@std@@@std@@@std@@@std@@SAXAAV?$allocator@V?$vector@PB_WV?$allocator@PB_W@std@@@std@@@1@PAV?$vector@PB_WV?$allocator@PB_W@std@@@1@ABV31@@Z ; std::allocator_traits<std::allocator<std::vector<wchar_t const *,std::allocator<wchar_t const *>>>>::construct<std::vector<wchar_t const *,std::allocator<wchar_t const *>>,std::vector<wchar_t const *,std::allocator<wchar_t const *>> const &>(std::allocator<std::vector<wchar_t const *,std::allocator<wchar_t const *>>> &,std::vector<wchar_t const *,std::allocator<wchar_t const *>> *,std::vector<wchar_t const *,std::allocator<wchar_t const *>> const &)
.text$mn:00003AED                 add     esp, 0Ch
.text$mn:00003AF0                 mov     esp, ebp
.text$mn:00003AF2                 pop     ebp
.text$mn:00003AF3                 retn    8
.text$mn:00003AF3 ??$construct@V?$vector@PB_WV?$allocator@PB_W@std@@@std@@ABV12@@?$_Wrap_alloc@V?$allocator@V?$vector@PB_WV?$allocator@PB_W@std@@@std@@@std@@@std@@QAEXPAV?$vector@PB_WV?$allocator@PB_W@std@@@1@ABV21@@Z endp
.text$mn:00003AF3
.text$mn:00003AF3 ; ---------------------------------------------------------------------------
.text$mn:00003AF6                 align 4
.text$mn:00003AF6 _text$mn        ends
.text$mn:00003AF6
.text$mn:00003AF8 ; ===========================================================================
.text$mn:00003AF8
.text$mn:00003AF8 ; Segment type: Pure code
.text$mn:00003AF8 ; Segment permissions: Read/Execute
.text$mn:00003AF8 _text$mn        segment para public 'CODE' use32
.text$mn:00003AF8                 assume cs:_text$mn
.text$mn:00003AF8                 ;org 3AF8h
.text$mn:00003AF8 ; COMDAT (pick any)
.text$mn:00003AF8                 assume es:nothing, ss:nothing, ds:_data, fs:nothing, gs:nothing
.text$mn:00003AF8
.text$mn:00003AF8 ; =============== S U B R O U T I N E =======================================
.text$mn:00003AF8
.text$mn:00003AF8 ; Attributes: bp-based frame
.text$mn:00003AF8
.text$mn:00003AF8 ; int __cdecl std::allocator_traits<std::allocator<std::vector<wchar_t const *,std::allocator<wchar_t const *>>>>::construct<std::vector<wchar_t const *,std::allocator<wchar_t const *>>,std::vector<wchar_t const *,std::allocator<wchar_t const *>> const &>(int, void *, int)
.text$mn:00003AF8                 public ??$construct@V?$vector@PB_WV?$allocator@PB_W@std@@@std@@ABV12@@?$allocator_traits@V?$allocator@V?$vector@PB_WV?$allocator@PB_W@std@@@std@@@std@@@std@@SAXAAV?$allocator@V?$vector@PB_WV?$allocator@PB_W@std@@@std@@@1@PAV?$vector@PB_WV?$allocator@PB_W@std@@@1@ABV31@@Z
.text$mn:00003AF8 ??$construct@V?$vector@PB_WV?$allocator@PB_W@std@@@std@@ABV12@@?$allocator_traits@V?$allocator@V?$vector@PB_WV?$allocator@PB_W@std@@@std@@@std@@@std@@SAXAAV?$allocator@V?$vector@PB_WV?$allocator@PB_W@std@@@std@@@1@PAV?$vector@PB_WV?$allocator@PB_W@std@@@1@ABV31@@Z proc near
.text$mn:00003AF8                                         ; CODE XREF: std::_Wrap_alloc<std::allocator<std::vector<wchar_t const *,std::allocator<wchar_t const *>>>>::construct<std::vector<wchar_t const *,std::allocator<wchar_t const *>>,std::vector<wchar_t const *,std::allocator<wchar_t const *>> const &>(std::vector<wchar_t const *,std::allocator<wchar_t const *>> *,std::vector<wchar_t const *,std::allocator<wchar_t const *>> const &)+1Cp
.text$mn:00003AF8
.text$mn:00003AF8 arg_0           = dword ptr  8
.text$mn:00003AF8 arg_4           = dword ptr  0Ch
.text$mn:00003AF8 arg_8           = dword ptr  10h
.text$mn:00003AF8
.text$mn:00003AF8                 push    ebp
.text$mn:00003AF9                 mov     ebp, esp
.text$mn:00003AFB                 mov     eax, [ebp+arg_8]
.text$mn:00003AFE                 push    eax
.text$mn:00003AFF                 call    ??$forward@ABV?$vector@PB_WV?$allocator@PB_W@std@@@std@@@std@@YAABV?$vector@PB_WV?$allocator@PB_W@std@@@0@ABV10@@Z ; std::forward<std::vector<wchar_t const *,std::allocator<wchar_t const *>> const &>(std::vector<wchar_t const *,std::allocator<wchar_t const *>> const &)
.text$mn:00003B04                 add     esp, 4
.text$mn:00003B07                 push    eax             ; int
.text$mn:00003B08                 mov     ecx, [ebp+arg_4]
.text$mn:00003B0B                 push    ecx             ; void *
.text$mn:00003B0C                 mov     ecx, [ebp+arg_0]
.text$mn:00003B0F                 call    ?construct@?$allocator@V?$vector@PB_WV?$allocator@PB_W@std@@@std@@@std@@QAEXPAV?$vector@PB_WV?$allocator@PB_W@std@@@2@ABV32@@Z ; std::allocator<std::vector<wchar_t const *,std::allocator<wchar_t const *>>>::construct(std::vector<wchar_t const *,std::allocator<wchar_t const *>> *,std::vector<wchar_t const *,std::allocator<wchar_t const *>> const &)
.text$mn:00003B14                 pop     ebp
.text$mn:00003B15                 retn
.text$mn:00003B15 ??$construct@V?$vector@PB_WV?$allocator@PB_W@std@@@std@@ABV12@@?$allocator_traits@V?$allocator@V?$vector@PB_WV?$allocator@PB_W@std@@@std@@@std@@@std@@SAXAAV?$allocator@V?$vector@PB_WV?$allocator@PB_W@std@@@std@@@1@PAV?$vector@PB_WV?$allocator@PB_W@std@@@1@ABV31@@Z endp
.text$mn:00003B15
.text$mn:00003B15 ; ---------------------------------------------------------------------------
.text$mn:00003B16                 align 4
.text$mn:00003B16 _text$mn        ends
.text$mn:00003B16
.text$mn:00003B18 ; ===========================================================================
.text$mn:00003B18
.text$mn:00003B18 ; Segment type: Pure code
.text$mn:00003B18 ; Segment permissions: Read/Execute
.text$mn:00003B18 _text$mn        segment para public 'CODE' use32
.text$mn:00003B18                 assume cs:_text$mn
.text$mn:00003B18                 ;org 3B18h
.text$mn:00003B18 ; COMDAT (pick any)
.text$mn:00003B18                 assume es:nothing, ss:nothing, ds:_data, fs:nothing, gs:nothing
.text$mn:00003B18
.text$mn:00003B18 ; =============== S U B R O U T I N E =======================================
.text$mn:00003B18
.text$mn:00003B18 ; Attributes: bp-based frame
.text$mn:00003B18
.text$mn:00003B18 ; int __stdcall std::_Wrap_alloc<std::allocator<std::vector<wchar_t const *,std::allocator<wchar_t const *>>>>::construct<std::vector<wchar_t const *,std::allocator<wchar_t const *>>,std::vector<wchar_t const *,std::allocator<wchar_t const *>>>(void *, int)
.text$mn:00003B18                 public ??$construct@V?$vector@PB_WV?$allocator@PB_W@std@@@std@@V12@@?$_Wrap_alloc@V?$allocator@V?$vector@PB_WV?$allocator@PB_W@std@@@std@@@std@@@std@@QAEXPAV?$vector@PB_WV?$allocator@PB_W@std@@@1@$$QAV21@@Z
.text$mn:00003B18 ??$construct@V?$vector@PB_WV?$allocator@PB_W@std@@@std@@V12@@?$_Wrap_alloc@V?$allocator@V?$vector@PB_WV?$allocator@PB_W@std@@@std@@@std@@@std@@QAEXPAV?$vector@PB_WV?$allocator@PB_W@std@@@1@$$QAV21@@Z proc near
.text$mn:00003B18                                         ; CODE XREF: std::_Uninit_move<std::vector<wchar_t const *,std::allocator<wchar_t const *>> *,std::vector<wchar_t const *,std::allocator<wchar_t const *>> *,std::allocator<std::vector<wchar_t const *,std::allocator<wchar_t const *>>>,std::vector<wchar_t const *,std::allocator<wchar_t const *>>>(std::vector<wchar_t const *,std::allocator<wchar_t const *>> *,std::vector<wchar_t const *,std::allocator<wchar_t const *>> *,std::vector<wchar_t const *,std::allocator<wchar_t const *>> *,std::_Wrap_alloc<std::allocator<std::vector<wchar_t const *,std::allocator<wchar_t const *>>>> &,std::vector<wchar_t const *,std::allocator<wchar_t const *>> *,std::_Nonscalar_ptr_iterator_tag)+8Ep
.text$mn:00003B18
.text$mn:00003B18 var_4           = dword ptr -4
.text$mn:00003B18 arg_0           = dword ptr  8
.text$mn:00003B18 arg_4           = dword ptr  0Ch
.text$mn:00003B18
.text$mn:00003B18                 push    ebp
.text$mn:00003B19                 mov     ebp, esp
.text$mn:00003B1B                 push    ecx
.text$mn:00003B1C                 mov     [ebp+var_4], ecx
.text$mn:00003B1F                 mov     eax, [ebp+arg_4]
.text$mn:00003B22                 push    eax
.text$mn:00003B23                 call    ??$forward@V?$vector@PB_WV?$allocator@PB_W@std@@@std@@@std@@YA$$QAV?$vector@PB_WV?$allocator@PB_W@std@@@0@AAV10@@Z ; std::forward<std::vector<wchar_t const *,std::allocator<wchar_t const *>>>(std::vector<wchar_t const *,std::allocator<wchar_t const *>> &)
.text$mn:00003B28                 add     esp, 4
.text$mn:00003B2B                 push    eax             ; int
.text$mn:00003B2C                 mov     ecx, [ebp+arg_0]
.text$mn:00003B2F                 push    ecx             ; void *
.text$mn:00003B30                 mov     edx, [ebp+var_4]
.text$mn:00003B33                 push    edx             ; int
.text$mn:00003B34                 call    ??$construct@V?$vector@PB_WV?$allocator@PB_W@std@@@std@@V12@@?$allocator_traits@V?$allocator@V?$vector@PB_WV?$allocator@PB_W@std@@@std@@@std@@@std@@SAXAAV?$allocator@V?$vector@PB_WV?$allocator@PB_W@std@@@std@@@1@PAV?$vector@PB_WV?$allocator@PB_W@std@@@1@$$QAV31@@Z ; std::allocator_traits<std::allocator<std::vector<wchar_t const *,std::allocator<wchar_t const *>>>>::construct<std::vector<wchar_t const *,std::allocator<wchar_t const *>>,std::vector<wchar_t const *,std::allocator<wchar_t const *>>>(std::allocator<std::vector<wchar_t const *,std::allocator<wchar_t const *>>> &,std::vector<wchar_t const *,std::allocator<wchar_t const *>> *,std::vector<wchar_t const *,std::allocator<wchar_t const *>> &&)
.text$mn:00003B39                 add     esp, 0Ch
.text$mn:00003B3C                 mov     esp, ebp
.text$mn:00003B3E                 pop     ebp
.text$mn:00003B3F                 retn    8
.text$mn:00003B3F ??$construct@V?$vector@PB_WV?$allocator@PB_W@std@@@std@@V12@@?$_Wrap_alloc@V?$allocator@V?$vector@PB_WV?$allocator@PB_W@std@@@std@@@std@@@std@@QAEXPAV?$vector@PB_WV?$allocator@PB_W@std@@@1@$$QAV21@@Z endp
.text$mn:00003B3F
.text$mn:00003B3F ; ---------------------------------------------------------------------------
.text$mn:00003B42                 align 4
.text$mn:00003B42 _text$mn        ends
.text$mn:00003B42
.text$mn:00003B44 ; ===========================================================================
.text$mn:00003B44
.text$mn:00003B44 ; Segment type: Pure code
.text$mn:00003B44 ; Segment permissions: Read/Execute
.text$mn:00003B44 _text$mn        segment para public 'CODE' use32
.text$mn:00003B44                 assume cs:_text$mn
.text$mn:00003B44                 ;org 3B44h
.text$mn:00003B44 ; COMDAT (pick any)
.text$mn:00003B44                 assume es:nothing, ss:nothing, ds:_data, fs:nothing, gs:nothing
.text$mn:00003B44
.text$mn:00003B44 ; =============== S U B R O U T I N E =======================================
.text$mn:00003B44
.text$mn:00003B44 ; Attributes: bp-based frame
.text$mn:00003B44
.text$mn:00003B44 ; int __stdcall std::allocator<std::vector<wchar_t const *,std::allocator<wchar_t const *>>>::construct<std::vector<wchar_t const *,std::allocator<wchar_t const *>>,std::vector<wchar_t const *,std::allocator<wchar_t const *>>>(void *, int)
.text$mn:00003B44                 public ??$construct@V?$vector@PB_WV?$allocator@PB_W@std@@@std@@V12@@?$allocator@V?$vector@PB_WV?$allocator@PB_W@std@@@std@@@std@@QAEXPAV?$vector@PB_WV?$allocator@PB_W@std@@@1@$$QAV21@@Z
.text$mn:00003B44 ??$construct@V?$vector@PB_WV?$allocator@PB_W@std@@@std@@V12@@?$allocator@V?$vector@PB_WV?$allocator@PB_W@std@@@std@@@std@@QAEXPAV?$vector@PB_WV?$allocator@PB_W@std@@@1@$$QAV21@@Z proc near
.text$mn:00003B44                                         ; CODE XREF: std::allocator_traits<std::allocator<std::vector<wchar_t const *,std::allocator<wchar_t const *>>>>::construct<std::vector<wchar_t const *,std::allocator<wchar_t const *>>,std::vector<wchar_t const *,std::allocator<wchar_t const *>>>(std::allocator<std::vector<wchar_t const *,std::allocator<wchar_t const *>>> &,std::vector<wchar_t const *,std::allocator<wchar_t const *>> *,std::vector<wchar_t const *,std::allocator<wchar_t const *>> &&)+17p
.text$mn:00003B44
.text$mn:00003B44 var_1C          = dword ptr -1Ch
.text$mn:00003B44 var_18          = dword ptr -18h
.text$mn:00003B44 var_14          = dword ptr -14h
.text$mn:00003B44 var_10          = dword ptr -10h
.text$mn:00003B44 var_C           = dword ptr -0Ch
.text$mn:00003B44 var_4           = dword ptr -4
.text$mn:00003B44 arg_0           = dword ptr  8
.text$mn:00003B44 arg_4           = dword ptr  0Ch
.text$mn:00003B44
.text$mn:00003B44                 push    ebp
.text$mn:00003B45                 mov     ebp, esp
.text$mn:00003B47                 push    0FFFFFFFFh
.text$mn:00003B49                 push    offset __ehhandler$??$construct@V?$vector@PB_WV?$allocator@PB_W@std@@@std@@V12@@?$allocator@V?$vector@PB_WV?$allocator@PB_W@std@@@std@@@std@@QAEXPAV?$vector@PB_WV?$allocator@PB_W@std@@@1@$$QAV21@@Z
.text$mn:00003B4E                 mov     eax, large fs:0
.text$mn:00003B54                 push    eax
.text$mn:00003B55                 sub     esp, 10h
.text$mn:00003B58                 mov     eax, dword ptr ds:___security_cookie
.text$mn:00003B5D                 xor     eax, ebp
.text$mn:00003B5F                 push    eax
.text$mn:00003B60                 lea     eax, [ebp+var_C]
.text$mn:00003B63                 mov     large fs:0, eax
.text$mn:00003B69                 mov     [ebp+var_18], ecx
.text$mn:00003B6C                 mov     eax, [ebp+arg_0]
.text$mn:00003B6F                 push    eax             ; void *
.text$mn:00003B70                 push    10h             ; unsigned int
.text$mn:00003B72                 call    ??2@YAPAXIPAX@Z ; operator new(uint,void *)
.text$mn:00003B77                 add     esp, 8
.text$mn:00003B7A                 mov     [ebp+var_10], eax
.text$mn:00003B7D                 mov     [ebp+var_4], 0
.text$mn:00003B84                 cmp     [ebp+var_10], 0
.text$mn:00003B88                 jz      short loc_3BA4
.text$mn:00003B8A                 mov     ecx, [ebp+arg_4]
.text$mn:00003B8D                 push    ecx
.text$mn:00003B8E                 call    ??$forward@V?$vector@PB_WV?$allocator@PB_W@std@@@std@@@std@@YA$$QAV?$vector@PB_WV?$allocator@PB_W@std@@@0@AAV10@@Z ; std::forward<std::vector<wchar_t const *,std::allocator<wchar_t const *>>>(std::vector<wchar_t const *,std::allocator<wchar_t const *>> &)
.text$mn:00003B93                 add     esp, 4
.text$mn:00003B96                 push    eax
.text$mn:00003B97                 mov     ecx, [ebp+var_10]
.text$mn:00003B9A                 call    ??0?$vector@PB_WV?$allocator@PB_W@std@@@std@@QAE@$$QAV01@@Z ; std::vector<wchar_t const *,std::allocator<wchar_t const *>>::vector<wchar_t const *,std::allocator<wchar_t const *>>(std::vector<wchar_t const *,std::allocator<wchar_t const *>> &&)
.text$mn:00003B9F                 mov     [ebp+var_14], eax
.text$mn:00003BA2                 jmp     short loc_3BAB
.text$mn:00003BA4 ; ---------------------------------------------------------------------------
.text$mn:00003BA4
.text$mn:00003BA4 loc_3BA4:                               ; CODE XREF: std::allocator<std::vector<wchar_t const *,std::allocator<wchar_t const *>>>::construct<std::vector<wchar_t const *,std::allocator<wchar_t const *>>,std::vector<wchar_t const *,std::allocator<wchar_t const *>>>(std::vector<wchar_t const *,std::allocator<wchar_t const *>> *,std::vector<wchar_t const *,std::allocator<wchar_t const *>> &&)+44j
.text$mn:00003BA4                 mov     [ebp+var_14], 0
.text$mn:00003BAB
.text$mn:00003BAB loc_3BAB:                               ; CODE XREF: std::allocator<std::vector<wchar_t const *,std::allocator<wchar_t const *>>>::construct<std::vector<wchar_t const *,std::allocator<wchar_t const *>>,std::vector<wchar_t const *,std::allocator<wchar_t const *>>>(std::vector<wchar_t const *,std::allocator<wchar_t const *>> *,std::vector<wchar_t const *,std::allocator<wchar_t const *>> &&)+5Ej
.text$mn:00003BAB                 mov     edx, [ebp+var_14]
.text$mn:00003BAE                 mov     [ebp+var_1C], edx
.text$mn:00003BB1                 mov     [ebp+var_4], 0FFFFFFFFh
.text$mn:00003BB8                 mov     ecx, [ebp+var_C]
.text$mn:00003BBB                 mov     large fs:0, ecx
.text$mn:00003BC2                 pop     ecx
.text$mn:00003BC3                 mov     esp, ebp
.text$mn:00003BC5                 pop     ebp
.text$mn:00003BC6                 retn    8
.text$mn:00003BC6 ??$construct@V?$vector@PB_WV?$allocator@PB_W@std@@@std@@V12@@?$allocator@V?$vector@PB_WV?$allocator@PB_W@std@@@std@@@std@@QAEXPAV?$vector@PB_WV?$allocator@PB_W@std@@@1@$$QAV21@@Z endp
.text$mn:00003BC6
.text$mn:00003BC6 ; ---------------------------------------------------------------------------
.text$mn:00003BC9                 align 4
.text$mn:00003BC9 _text$mn        ends
.text$mn:00003BC9
.text$x:00003BCC ; ===========================================================================
.text$x:00003BCC
.text$x:00003BCC ; Segment type: Pure code
.text$x:00003BCC ; Segment permissions: Read/Execute
.text$x:00003BCC _text$x         segment para public 'CODE' use32
.text$x:00003BCC                 assume cs:_text$x
.text$x:00003BCC                 ;org 3BCCh
.text$x:00003BCC ; COMDAT (pick associative to section at 3B44)
.text$x:00003BCC                 assume es:nothing, ss:nothing, ds:_data, fs:nothing, gs:nothing
.text$x:00003BCC
.text$x:00003BCC ; =============== S U B R O U T I N E =======================================
.text$x:00003BCC
.text$x:00003BCC
.text$x:00003BCC __unwindfunclet$??$construct@V?$vector@PB_WV?$allocator@PB_W@std@@@std@@V12@@?$allocator@V?$vector@PB_WV?$allocator@PB_W@std@@@std@@@std@@QAEXPAV?$vector@PB_WV?$allocator@PB_W@std@@@1@$$QAV21@@Z$0 proc near
.text$x:00003BCC                                         ; DATA XREF: .xdata$x:0000A2BCo
.text$x:00003BCC                 mov     eax, [ebp+8]
.text$x:00003BCF                 push    eax
.text$x:00003BD0                 mov     eax, [ebp-10h]
.text$x:00003BD3                 push    eax             ; void *
.text$x:00003BD4                 call    ??3@YAXPAX0@Z   ; operator delete(void *,void *)
.text$x:00003BD9                 add     esp, 8
.text$x:00003BDC                 retn
.text$x:00003BDC __unwindfunclet$??$construct@V?$vector@PB_WV?$allocator@PB_W@std@@@std@@V12@@?$allocator@V?$vector@PB_WV?$allocator@PB_W@std@@@std@@@std@@QAEXPAV?$vector@PB_WV?$allocator@PB_W@std@@@1@$$QAV21@@Z$0 endp
.text$x:00003BDC
.text$x:00003BDD
.text$x:00003BDD ; =============== S U B R O U T I N E =======================================
.text$x:00003BDD
.text$x:00003BDD
.text$x:00003BDD __ehhandler$??$construct@V?$vector@PB_WV?$allocator@PB_W@std@@@std@@V12@@?$allocator@V?$vector@PB_WV?$allocator@PB_W@std@@@std@@@std@@QAEXPAV?$vector@PB_WV?$allocator@PB_W@std@@@1@$$QAV21@@Z proc near
.text$x:00003BDD                                         ; DATA XREF: std::allocator<std::vector<wchar_t const *,std::allocator<wchar_t const *>>>::construct<std::vector<wchar_t const *,std::allocator<wchar_t const *>>,std::vector<wchar_t const *,std::allocator<wchar_t const *>>>(std::vector<wchar_t const *,std::allocator<wchar_t const *>> *,std::vector<wchar_t const *,std::allocator<wchar_t const *>> &&)+5o
.text$x:00003BDD
.text$x:00003BDD arg_4           = dword ptr  8
.text$x:00003BDD
.text$x:00003BDD                 mov     edx, [esp+arg_4]
.text$x:00003BE1                 lea     eax, [edx+0Ch]
.text$x:00003BE4                 mov     ecx, [edx-14h]
.text$x:00003BE7                 xor     ecx, eax
.text$x:00003BE9                 call    @__security_check_cookie@4 ; __security_check_cookie(x)
.text$x:00003BEE                 mov     eax, offset __ehfuncinfo$??$construct@V?$vector@PB_WV?$allocator@PB_W@std@@@std@@V12@@?$allocator@V?$vector@PB_WV?$allocator@PB_W@std@@@std@@@std@@QAEXPAV?$vector@PB_WV?$allocator@PB_W@std@@@1@$$QAV21@@Z
.text$x:00003BF3                 jmp     ___CxxFrameHandler3
.text$x:00003BF3 __ehhandler$??$construct@V?$vector@PB_WV?$allocator@PB_W@std@@@std@@V12@@?$allocator@V?$vector@PB_WV?$allocator@PB_W@std@@@std@@@std@@QAEXPAV?$vector@PB_WV?$allocator@PB_W@std@@@1@$$QAV21@@Z endp
.text$x:00003BF3
.text$x:00003BF3 _text$x         ends
.text$x:00003BF3
.text$mn:00003BF8 ; ===========================================================================
.text$mn:00003BF8
.text$mn:00003BF8 ; Segment type: Pure code
.text$mn:00003BF8 ; Segment permissions: Read/Execute
.text$mn:00003BF8 _text$mn        segment para public 'CODE' use32
.text$mn:00003BF8                 assume cs:_text$mn
.text$mn:00003BF8                 ;org 3BF8h
.text$mn:00003BF8 ; COMDAT (pick any)
.text$mn:00003BF8                 assume es:nothing, ss:nothing, ds:_data, fs:nothing, gs:nothing
.text$mn:00003BF8
.text$mn:00003BF8 ; =============== S U B R O U T I N E =======================================
.text$mn:00003BF8
.text$mn:00003BF8 ; Attributes: bp-based frame
.text$mn:00003BF8
.text$mn:00003BF8 ; int __cdecl std::allocator_traits<std::allocator<std::vector<wchar_t const *,std::allocator<wchar_t const *>>>>::construct<std::vector<wchar_t const *,std::allocator<wchar_t const *>>,std::vector<wchar_t const *,std::allocator<wchar_t const *>>>(int, void *, int)
.text$mn:00003BF8                 public ??$construct@V?$vector@PB_WV?$allocator@PB_W@std@@@std@@V12@@?$allocator_traits@V?$allocator@V?$vector@PB_WV?$allocator@PB_W@std@@@std@@@std@@@std@@SAXAAV?$allocator@V?$vector@PB_WV?$allocator@PB_W@std@@@std@@@1@PAV?$vector@PB_WV?$allocator@PB_W@std@@@1@$$QAV31@@Z
.text$mn:00003BF8 ??$construct@V?$vector@PB_WV?$allocator@PB_W@std@@@std@@V12@@?$allocator_traits@V?$allocator@V?$vector@PB_WV?$allocator@PB_W@std@@@std@@@std@@@std@@SAXAAV?$allocator@V?$vector@PB_WV?$allocator@PB_W@std@@@std@@@1@PAV?$vector@PB_WV?$allocator@PB_W@std@@@1@$$QAV31@@Z proc near
.text$mn:00003BF8                                         ; CODE XREF: std::_Wrap_alloc<std::allocator<std::vector<wchar_t const *,std::allocator<wchar_t const *>>>>::construct<std::vector<wchar_t const *,std::allocator<wchar_t const *>>,std::vector<wchar_t const *,std::allocator<wchar_t const *>>>(std::vector<wchar_t const *,std::allocator<wchar_t const *>> *,std::vector<wchar_t const *,std::allocator<wchar_t const *>> &&)+1Cp
.text$mn:00003BF8
.text$mn:00003BF8 arg_0           = dword ptr  8
.text$mn:00003BF8 arg_4           = dword ptr  0Ch
.text$mn:00003BF8 arg_8           = dword ptr  10h
.text$mn:00003BF8
.text$mn:00003BF8                 push    ebp
.text$mn:00003BF9                 mov     ebp, esp
.text$mn:00003BFB                 mov     eax, [ebp+arg_8]
.text$mn:00003BFE                 push    eax
.text$mn:00003BFF                 call    ??$forward@V?$vector@PB_WV?$allocator@PB_W@std@@@std@@@std@@YA$$QAV?$vector@PB_WV?$allocator@PB_W@std@@@0@AAV10@@Z ; std::forward<std::vector<wchar_t const *,std::allocator<wchar_t const *>>>(std::vector<wchar_t const *,std::allocator<wchar_t const *>> &)
.text$mn:00003C04                 add     esp, 4
.text$mn:00003C07                 push    eax             ; int
.text$mn:00003C08                 mov     ecx, [ebp+arg_4]
.text$mn:00003C0B                 push    ecx             ; void *
.text$mn:00003C0C                 mov     ecx, [ebp+arg_0]
.text$mn:00003C0F                 call    ??$construct@V?$vector@PB_WV?$allocator@PB_W@std@@@std@@V12@@?$allocator@V?$vector@PB_WV?$allocator@PB_W@std@@@std@@@std@@QAEXPAV?$vector@PB_WV?$allocator@PB_W@std@@@1@$$QAV21@@Z ; std::allocator<std::vector<wchar_t const *,std::allocator<wchar_t const *>>>::construct<std::vector<wchar_t const *,std::allocator<wchar_t const *>>,std::vector<wchar_t const *,std::allocator<wchar_t const *>>>(std::vector<wchar_t const *,std::allocator<wchar_t const *>> *,std::vector<wchar_t const *,std::allocator<wchar_t const *>> &&)
.text$mn:00003C14                 pop     ebp
.text$mn:00003C15                 retn
.text$mn:00003C15 ??$construct@V?$vector@PB_WV?$allocator@PB_W@std@@@std@@V12@@?$allocator_traits@V?$allocator@V?$vector@PB_WV?$allocator@PB_W@std@@@std@@@std@@@std@@SAXAAV?$allocator@V?$vector@PB_WV?$allocator@PB_W@std@@@std@@@1@PAV?$vector@PB_WV?$allocator@PB_W@std@@@1@$$QAV31@@Z endp
.text$mn:00003C15
.text$mn:00003C15 ; ---------------------------------------------------------------------------
.text$mn:00003C16                 align 4
.text$mn:00003C16 _text$mn        ends
.text$mn:00003C16
.text$mn:00003C18 ; ===========================================================================
.text$mn:00003C18
.text$mn:00003C18 ; Segment type: Pure code
.text$mn:00003C18 ; Segment permissions: Read/Execute
.text$mn:00003C18 _text$mn        segment para public 'CODE' use32
.text$mn:00003C18                 assume cs:_text$mn
.text$mn:00003C18                 ;org 3C18h
.text$mn:00003C18 ; COMDAT (pick any)
.text$mn:00003C18                 assume es:nothing, ss:nothing, ds:_data, fs:nothing, gs:nothing
.text$mn:00003C18
.text$mn:00003C18 ; =============== S U B R O U T I N E =======================================
.text$mn:00003C18
.text$mn:00003C18 ; Attributes: bp-based frame
.text$mn:00003C18
.text$mn:00003C18 ; public: void __thiscall std::_Wrap_alloc<class std::allocator<char>>::destroy<char *>(char * *)
.text$mn:00003C18                 public ??$destroy@PAD@?$_Wrap_alloc@V?$allocator@D@std@@@std@@QAEXPAPAD@Z
.text$mn:00003C18 ??$destroy@PAD@?$_Wrap_alloc@V?$allocator@D@std@@@std@@QAEXPAPAD@Z proc near
.text$mn:00003C18                                         ; CODE XREF: std::basic_string<char,std::char_traits<char>,std::allocator<char>>::_Tidy(bool,uint)+3Ap
.text$mn:00003C18
.text$mn:00003C18 var_4           = dword ptr -4
.text$mn:00003C18 arg_0           = dword ptr  8
.text$mn:00003C18
.text$mn:00003C18                 push    ebp
.text$mn:00003C19                 mov     ebp, esp
.text$mn:00003C1B                 push    ecx
.text$mn:00003C1C                 mov     [ebp+var_4], ecx
.text$mn:00003C1F                 mov     eax, [ebp+arg_0]
.text$mn:00003C22                 push    eax
.text$mn:00003C23                 mov     ecx, [ebp+var_4]
.text$mn:00003C26                 push    ecx
.text$mn:00003C27                 call    ??$destroy@PAD@?$allocator_traits@V?$allocator@D@std@@@std@@SAXAAV?$allocator@D@1@PAPAD@Z ; std::allocator_traits<std::allocator<char>>::destroy<char *>(std::allocator<char> &,char * *)
.text$mn:00003C2C                 add     esp, 8
.text$mn:00003C2F                 mov     esp, ebp
.text$mn:00003C31                 pop     ebp
.text$mn:00003C32                 retn    4
.text$mn:00003C32 ??$destroy@PAD@?$_Wrap_alloc@V?$allocator@D@std@@@std@@QAEXPAPAD@Z endp
.text$mn:00003C32
.text$mn:00003C32 ; ---------------------------------------------------------------------------
.text$mn:00003C35                 align 4
.text$mn:00003C35 _text$mn        ends
.text$mn:00003C35
.text$mn:00003C38 ; ===========================================================================
.text$mn:00003C38
.text$mn:00003C38 ; Segment type: Pure code
.text$mn:00003C38 ; Segment permissions: Read/Execute
.text$mn:00003C38 _text$mn        segment para public 'CODE' use32
.text$mn:00003C38                 assume cs:_text$mn
.text$mn:00003C38                 ;org 3C38h
.text$mn:00003C38 ; COMDAT (pick any)
.text$mn:00003C38                 assume es:nothing, ss:nothing, ds:_data, fs:nothing, gs:nothing
.text$mn:00003C38
.text$mn:00003C38 ; =============== S U B R O U T I N E =======================================
.text$mn:00003C38
.text$mn:00003C38 ; Attributes: bp-based frame
.text$mn:00003C38
.text$mn:00003C38 ; public: void __thiscall std::allocator<char>::destroy<char *>(char * *)
.text$mn:00003C38                 public ??$destroy@PAD@?$allocator@D@std@@QAEXPAPAD@Z
.text$mn:00003C38 ??$destroy@PAD@?$allocator@D@std@@QAEXPAPAD@Z proc near
.text$mn:00003C38                                         ; CODE XREF: std::allocator_traits<std::allocator<char>>::destroy<char *>(std::allocator<char> &,char * *)+Ap
.text$mn:00003C38
.text$mn:00003C38 var_4           = dword ptr -4
.text$mn:00003C38
.text$mn:00003C38                 push    ebp
.text$mn:00003C39                 mov     ebp, esp
.text$mn:00003C3B                 push    ecx
.text$mn:00003C3C                 mov     [ebp+var_4], ecx
.text$mn:00003C3F                 mov     esp, ebp
.text$mn:00003C41                 pop     ebp
.text$mn:00003C42                 retn    4
.text$mn:00003C42 ??$destroy@PAD@?$allocator@D@std@@QAEXPAPAD@Z endp
.text$mn:00003C42
.text$mn:00003C42 ; ---------------------------------------------------------------------------
.text$mn:00003C45                 align 4
.text$mn:00003C45 _text$mn        ends
.text$mn:00003C45
.text$mn:00003C48 ; ===========================================================================
.text$mn:00003C48
.text$mn:00003C48 ; Segment type: Pure code
.text$mn:00003C48 ; Segment permissions: Read/Execute
.text$mn:00003C48 _text$mn        segment para public 'CODE' use32
.text$mn:00003C48                 assume cs:_text$mn
.text$mn:00003C48                 ;org 3C48h
.text$mn:00003C48 ; COMDAT (pick any)
.text$mn:00003C48                 assume es:nothing, ss:nothing, ds:_data, fs:nothing, gs:nothing
.text$mn:00003C48
.text$mn:00003C48 ; =============== S U B R O U T I N E =======================================
.text$mn:00003C48
.text$mn:00003C48 ; Attributes: bp-based frame
.text$mn:00003C48
.text$mn:00003C48 ; public: static void __cdecl std::allocator_traits<class std::allocator<char>>::destroy<char *>(class std::allocator<char> &, char * *)
.text$mn:00003C48                 public ??$destroy@PAD@?$allocator_traits@V?$allocator@D@std@@@std@@SAXAAV?$allocator@D@1@PAPAD@Z
.text$mn:00003C48 ??$destroy@PAD@?$allocator_traits@V?$allocator@D@std@@@std@@SAXAAV?$allocator@D@1@PAPAD@Z proc near
.text$mn:00003C48                                         ; CODE XREF: std::_Wrap_alloc<std::allocator<char>>::destroy<char *>(char * *)+Fp
.text$mn:00003C48
.text$mn:00003C48 arg_0           = dword ptr  8
.text$mn:00003C48 arg_4           = dword ptr  0Ch
.text$mn:00003C48
.text$mn:00003C48                 push    ebp
.text$mn:00003C49                 mov     ebp, esp
.text$mn:00003C4B                 mov     eax, [ebp+arg_4]
.text$mn:00003C4E                 push    eax
.text$mn:00003C4F                 mov     ecx, [ebp+arg_0]
.text$mn:00003C52                 call    ??$destroy@PAD@?$allocator@D@std@@QAEXPAPAD@Z ; std::allocator<char>::destroy<char *>(char * *)
.text$mn:00003C57                 pop     ebp
.text$mn:00003C58                 retn
.text$mn:00003C58 ??$destroy@PAD@?$allocator_traits@V?$allocator@D@std@@@std@@SAXAAV?$allocator@D@1@PAPAD@Z endp
.text$mn:00003C58
.text$mn:00003C58 ; ---------------------------------------------------------------------------
.text$mn:00003C59                 align 4
.text$mn:00003C59 _text$mn        ends
.text$mn:00003C59
.text$mn:00003C5C ; ===========================================================================
.text$mn:00003C5C
.text$mn:00003C5C ; Segment type: Pure code
.text$mn:00003C5C ; Segment permissions: Read/Execute
.text$mn:00003C5C _text$mn        segment para public 'CODE' use32
.text$mn:00003C5C                 assume cs:_text$mn
.text$mn:00003C5C                 ;org 3C5Ch
.text$mn:00003C5C ; COMDAT (pick any)
.text$mn:00003C5C                 assume es:nothing, ss:nothing, ds:_data, fs:nothing, gs:nothing
.text$mn:00003C5C
.text$mn:00003C5C ; =============== S U B R O U T I N E =======================================
.text$mn:00003C5C
.text$mn:00003C5C ; Attributes: bp-based frame
.text$mn:00003C5C
.text$mn:00003C5C ; public: void __thiscall std::_Wrap_alloc<class std::allocator<struct FunctionValues>>::destroy<struct FunctionValues>(struct FunctionValues *)
.text$mn:00003C5C                 public ??$destroy@UFunctionValues@@@?$_Wrap_alloc@V?$allocator@UFunctionValues@@@std@@@std@@QAEXPAUFunctionValues@@@Z
.text$mn:00003C5C ??$destroy@UFunctionValues@@@?$_Wrap_alloc@V?$allocator@UFunctionValues@@@std@@@std@@QAEXPAUFunctionValues@@@Z proc near
.text$mn:00003C5C                                         ; CODE XREF: std::_Destroy_range<std::_Wrap_alloc<std::allocator<FunctionValues>>>(FunctionValues *,FunctionValues *,std::_Wrap_alloc<std::allocator<FunctionValues>> &,std::_Nonscalar_ptr_iterator_tag)+1Dp
.text$mn:00003C5C                                         ; __catch$??$_Uninit_move@PAUFunctionValues@@PAU1@V?$allocator@UFunctionValues@@@std@@U1@@std@@YAPAUFunctionValues@@PAU1@00AAU?$_Wrap_alloc@V?$allocator@UFunctionValues@@@std@@@0@0U_Nonscalar_ptr_iterator_tag@0@@Z$0+1Ap ...
.text$mn:00003C5C
.text$mn:00003C5C var_4           = dword ptr -4
.text$mn:00003C5C arg_0           = dword ptr  8
.text$mn:00003C5C
.text$mn:00003C5C                 push    ebp
.text$mn:00003C5D                 mov     ebp, esp
.text$mn:00003C5F                 push    ecx
.text$mn:00003C60                 mov     [ebp+var_4], ecx
.text$mn:00003C63                 mov     eax, [ebp+arg_0]
.text$mn:00003C66                 push    eax
.text$mn:00003C67                 mov     ecx, [ebp+var_4]
.text$mn:00003C6A                 push    ecx
.text$mn:00003C6B                 call    ??$destroy@UFunctionValues@@@?$allocator_traits@V?$allocator@UFunctionValues@@@std@@@std@@SAXAAV?$allocator@UFunctionValues@@@1@PAUFunctionValues@@@Z ; std::allocator_traits<std::allocator<FunctionValues>>::destroy<FunctionValues>(std::allocator<FunctionValues> &,FunctionValues *)
.text$mn:00003C70                 add     esp, 8
.text$mn:00003C73                 mov     esp, ebp
.text$mn:00003C75                 pop     ebp
.text$mn:00003C76                 retn    4
.text$mn:00003C76 ??$destroy@UFunctionValues@@@?$_Wrap_alloc@V?$allocator@UFunctionValues@@@std@@@std@@QAEXPAUFunctionValues@@@Z endp
.text$mn:00003C76
.text$mn:00003C76 ; ---------------------------------------------------------------------------
.text$mn:00003C79                 align 4
.text$mn:00003C79 _text$mn        ends
.text$mn:00003C79
.text$mn:00003C7C ; ===========================================================================
.text$mn:00003C7C
.text$mn:00003C7C ; Segment type: Pure code
.text$mn:00003C7C ; Segment permissions: Read/Execute
.text$mn:00003C7C _text$mn        segment para public 'CODE' use32
.text$mn:00003C7C                 assume cs:_text$mn
.text$mn:00003C7C                 ;org 3C7Ch
.text$mn:00003C7C ; COMDAT (pick any)
.text$mn:00003C7C                 assume es:nothing, ss:nothing, ds:_data, fs:nothing, gs:nothing
.text$mn:00003C7C
.text$mn:00003C7C ; =============== S U B R O U T I N E =======================================
.text$mn:00003C7C
.text$mn:00003C7C ; Attributes: bp-based frame
.text$mn:00003C7C
.text$mn:00003C7C ; public: void __thiscall std::allocator<struct FunctionValues>::destroy<struct FunctionValues>(struct FunctionValues *)
.text$mn:00003C7C                 public ??$destroy@UFunctionValues@@@?$allocator@UFunctionValues@@@std@@QAEXPAUFunctionValues@@@Z
.text$mn:00003C7C ??$destroy@UFunctionValues@@@?$allocator@UFunctionValues@@@std@@QAEXPAUFunctionValues@@@Z proc near
.text$mn:00003C7C                                         ; CODE XREF: std::allocator_traits<std::allocator<FunctionValues>>::destroy<FunctionValues>(std::allocator<FunctionValues> &,FunctionValues *)+Ap
.text$mn:00003C7C
.text$mn:00003C7C var_4           = dword ptr -4
.text$mn:00003C7C
.text$mn:00003C7C                 push    ebp
.text$mn:00003C7D                 mov     ebp, esp
.text$mn:00003C7F                 push    ecx
.text$mn:00003C80                 mov     [ebp+var_4], ecx
.text$mn:00003C83                 mov     esp, ebp
.text$mn:00003C85                 pop     ebp
.text$mn:00003C86                 retn    4
.text$mn:00003C86 ??$destroy@UFunctionValues@@@?$allocator@UFunctionValues@@@std@@QAEXPAUFunctionValues@@@Z endp
.text$mn:00003C86
.text$mn:00003C86 ; ---------------------------------------------------------------------------
.text$mn:00003C89                 align 4
.text$mn:00003C89 _text$mn        ends
.text$mn:00003C89
.text$mn:00003C8C ; ===========================================================================
.text$mn:00003C8C
.text$mn:00003C8C ; Segment type: Pure code
.text$mn:00003C8C ; Segment permissions: Read/Execute
.text$mn:00003C8C _text$mn        segment para public 'CODE' use32
.text$mn:00003C8C                 assume cs:_text$mn
.text$mn:00003C8C                 ;org 3C8Ch
.text$mn:00003C8C ; COMDAT (pick any)
.text$mn:00003C8C                 assume es:nothing, ss:nothing, ds:_data, fs:nothing, gs:nothing
.text$mn:00003C8C
.text$mn:00003C8C ; =============== S U B R O U T I N E =======================================
.text$mn:00003C8C
.text$mn:00003C8C ; Attributes: bp-based frame
.text$mn:00003C8C
.text$mn:00003C8C ; public: static void __cdecl std::allocator_traits<class std::allocator<struct FunctionValues>>::destroy<struct FunctionValues>(class std::allocator<struct FunctionValues> &, struct FunctionValues *)
.text$mn:00003C8C                 public ??$destroy@UFunctionValues@@@?$allocator_traits@V?$allocator@UFunctionValues@@@std@@@std@@SAXAAV?$allocator@UFunctionValues@@@1@PAUFunctionValues@@@Z
.text$mn:00003C8C ??$destroy@UFunctionValues@@@?$allocator_traits@V?$allocator@UFunctionValues@@@std@@@std@@SAXAAV?$allocator@UFunctionValues@@@1@PAUFunctionValues@@@Z proc near
.text$mn:00003C8C                                         ; CODE XREF: std::_Wrap_alloc<std::allocator<FunctionValues>>::destroy<FunctionValues>(FunctionValues *)+Fp
.text$mn:00003C8C
.text$mn:00003C8C arg_0           = dword ptr  8
.text$mn:00003C8C arg_4           = dword ptr  0Ch
.text$mn:00003C8C
.text$mn:00003C8C                 push    ebp
.text$mn:00003C8D                 mov     ebp, esp
.text$mn:00003C8F                 mov     eax, [ebp+arg_4]
.text$mn:00003C92                 push    eax
.text$mn:00003C93                 mov     ecx, [ebp+arg_0]
.text$mn:00003C96                 call    ??$destroy@UFunctionValues@@@?$allocator@UFunctionValues@@@std@@QAEXPAUFunctionValues@@@Z ; std::allocator<FunctionValues>::destroy<FunctionValues>(FunctionValues *)
.text$mn:00003C9B                 pop     ebp
.text$mn:00003C9C                 retn
.text$mn:00003C9C ??$destroy@UFunctionValues@@@?$allocator_traits@V?$allocator@UFunctionValues@@@std@@@std@@SAXAAV?$allocator@UFunctionValues@@@1@PAUFunctionValues@@@Z endp
.text$mn:00003C9C
.text$mn:00003C9C ; ---------------------------------------------------------------------------
.text$mn:00003C9D                 align 10h
.text$mn:00003C9D _text$mn        ends
.text$mn:00003C9D
.text$mn:00003CA0 ; ===========================================================================
.text$mn:00003CA0
.text$mn:00003CA0 ; Segment type: Pure code
.text$mn:00003CA0 ; Segment permissions: Read/Execute
.text$mn:00003CA0 _text$mn        segment para public 'CODE' use32
.text$mn:00003CA0                 assume cs:_text$mn
.text$mn:00003CA0                 ;org 3CA0h
.text$mn:00003CA0 ; COMDAT (pick any)
.text$mn:00003CA0                 assume es:nothing, ss:nothing, ds:_data, fs:nothing, gs:nothing
.text$mn:00003CA0
.text$mn:00003CA0 ; =============== S U B R O U T I N E =======================================
.text$mn:00003CA0
.text$mn:00003CA0 ; Attributes: bp-based frame
.text$mn:00003CA0
.text$mn:00003CA0 ; public: void __thiscall std::_Wrap_alloc<class std::allocator<struct Token>>::destroy<struct Token>(struct Token *)
.text$mn:00003CA0                 public ??$destroy@UToken@@@?$_Wrap_alloc@V?$allocator@UToken@@@std@@@std@@QAEXPAUToken@@@Z
.text$mn:00003CA0 ??$destroy@UToken@@@?$_Wrap_alloc@V?$allocator@UToken@@@std@@@std@@QAEXPAUToken@@@Z proc near
.text$mn:00003CA0                                         ; CODE XREF: std::_Destroy_range<std::_Wrap_alloc<std::allocator<Token>>>(Token *,Token *,std::_Wrap_alloc<std::allocator<Token>> &,std::_Nonscalar_ptr_iterator_tag)+1Dp
.text$mn:00003CA0                                         ; __catch$??$_Uninit_move@PAUToken@@PAU1@V?$allocator@UToken@@@std@@U1@@std@@YAPAUToken@@PAU1@00AAU?$_Wrap_alloc@V?$allocator@UToken@@@std@@@0@0U_Nonscalar_ptr_iterator_tag@0@@Z$0+1Ap
.text$mn:00003CA0
.text$mn:00003CA0 var_4           = dword ptr -4
.text$mn:00003CA0 arg_0           = dword ptr  8
.text$mn:00003CA0
.text$mn:00003CA0                 push    ebp
.text$mn:00003CA1                 mov     ebp, esp
.text$mn:00003CA3                 push    ecx
.text$mn:00003CA4                 mov     [ebp+var_4], ecx
.text$mn:00003CA7                 mov     eax, [ebp+arg_0]
.text$mn:00003CAA                 push    eax
.text$mn:00003CAB                 mov     ecx, [ebp+var_4]
.text$mn:00003CAE                 push    ecx
.text$mn:00003CAF                 call    ??$destroy@UToken@@@?$allocator_traits@V?$allocator@UToken@@@std@@@std@@SAXAAV?$allocator@UToken@@@1@PAUToken@@@Z ; std::allocator_traits<std::allocator<Token>>::destroy<Token>(std::allocator<Token> &,Token *)
.text$mn:00003CB4                 add     esp, 8
.text$mn:00003CB7                 mov     esp, ebp
.text$mn:00003CB9                 pop     ebp
.text$mn:00003CBA                 retn    4
.text$mn:00003CBA ??$destroy@UToken@@@?$_Wrap_alloc@V?$allocator@UToken@@@std@@@std@@QAEXPAUToken@@@Z endp
.text$mn:00003CBA
.text$mn:00003CBA ; ---------------------------------------------------------------------------
.text$mn:00003CBD                 align 10h
.text$mn:00003CBD _text$mn        ends
.text$mn:00003CBD
.text$mn:00003CC0 ; ===========================================================================
.text$mn:00003CC0
.text$mn:00003CC0 ; Segment type: Pure code
.text$mn:00003CC0 ; Segment permissions: Read/Execute
.text$mn:00003CC0 _text$mn        segment para public 'CODE' use32
.text$mn:00003CC0                 assume cs:_text$mn
.text$mn:00003CC0                 ;org 3CC0h
.text$mn:00003CC0 ; COMDAT (pick any)
.text$mn:00003CC0                 assume es:nothing, ss:nothing, ds:_data, fs:nothing, gs:nothing
.text$mn:00003CC0
.text$mn:00003CC0 ; =============== S U B R O U T I N E =======================================
.text$mn:00003CC0
.text$mn:00003CC0 ; Attributes: bp-based frame
.text$mn:00003CC0
.text$mn:00003CC0 ; public: void __thiscall std::allocator<struct Token>::destroy<struct Token>(struct Token *)
.text$mn:00003CC0                 public ??$destroy@UToken@@@?$allocator@UToken@@@std@@QAEXPAUToken@@@Z
.text$mn:00003CC0 ??$destroy@UToken@@@?$allocator@UToken@@@std@@QAEXPAUToken@@@Z proc near
.text$mn:00003CC0                                         ; CODE XREF: std::allocator_traits<std::allocator<Token>>::destroy<Token>(std::allocator<Token> &,Token *)+Ap
.text$mn:00003CC0
.text$mn:00003CC0 var_4           = dword ptr -4
.text$mn:00003CC0
.text$mn:00003CC0                 push    ebp
.text$mn:00003CC1                 mov     ebp, esp
.text$mn:00003CC3                 push    ecx
.text$mn:00003CC4                 mov     [ebp+var_4], ecx
.text$mn:00003CC7                 mov     esp, ebp
.text$mn:00003CC9                 pop     ebp
.text$mn:00003CCA                 retn    4
.text$mn:00003CCA ??$destroy@UToken@@@?$allocator@UToken@@@std@@QAEXPAUToken@@@Z endp
.text$mn:00003CCA
.text$mn:00003CCA ; ---------------------------------------------------------------------------
.text$mn:00003CCD                 align 10h
.text$mn:00003CCD _text$mn        ends
.text$mn:00003CCD
.text$mn:00003CD0 ; ===========================================================================
.text$mn:00003CD0
.text$mn:00003CD0 ; Segment type: Pure code
.text$mn:00003CD0 ; Segment permissions: Read/Execute
.text$mn:00003CD0 _text$mn        segment para public 'CODE' use32
.text$mn:00003CD0                 assume cs:_text$mn
.text$mn:00003CD0                 ;org 3CD0h
.text$mn:00003CD0 ; COMDAT (pick any)
.text$mn:00003CD0                 assume es:nothing, ss:nothing, ds:_data, fs:nothing, gs:nothing
.text$mn:00003CD0
.text$mn:00003CD0 ; =============== S U B R O U T I N E =======================================
.text$mn:00003CD0
.text$mn:00003CD0 ; Attributes: bp-based frame
.text$mn:00003CD0
.text$mn:00003CD0 ; public: static void __cdecl std::allocator_traits<class std::allocator<struct Token>>::destroy<struct Token>(class std::allocator<struct Token> &, struct Token *)
.text$mn:00003CD0                 public ??$destroy@UToken@@@?$allocator_traits@V?$allocator@UToken@@@std@@@std@@SAXAAV?$allocator@UToken@@@1@PAUToken@@@Z
.text$mn:00003CD0 ??$destroy@UToken@@@?$allocator_traits@V?$allocator@UToken@@@std@@@std@@SAXAAV?$allocator@UToken@@@1@PAUToken@@@Z proc near
.text$mn:00003CD0                                         ; CODE XREF: std::_Wrap_alloc<std::allocator<Token>>::destroy<Token>(Token *)+Fp
.text$mn:00003CD0
.text$mn:00003CD0 arg_0           = dword ptr  8
.text$mn:00003CD0 arg_4           = dword ptr  0Ch
.text$mn:00003CD0
.text$mn:00003CD0                 push    ebp
.text$mn:00003CD1                 mov     ebp, esp
.text$mn:00003CD3                 mov     eax, [ebp+arg_4]
.text$mn:00003CD6                 push    eax
.text$mn:00003CD7                 mov     ecx, [ebp+arg_0]
.text$mn:00003CDA                 call    ??$destroy@UToken@@@?$allocator@UToken@@@std@@QAEXPAUToken@@@Z ; std::allocator<Token>::destroy<Token>(Token *)
.text$mn:00003CDF                 pop     ebp
.text$mn:00003CE0                 retn
.text$mn:00003CE0 ??$destroy@UToken@@@?$allocator_traits@V?$allocator@UToken@@@std@@@std@@SAXAAV?$allocator@UToken@@@1@PAUToken@@@Z endp
.text$mn:00003CE0
.text$mn:00003CE0 ; ---------------------------------------------------------------------------
.text$mn:00003CE1                 align 4
.text$mn:00003CE1 _text$mn        ends
.text$mn:00003CE1
.text$mn:00003CE4 ; ===========================================================================
.text$mn:00003CE4
.text$mn:00003CE4 ; Segment type: Pure code
.text$mn:00003CE4 ; Segment permissions: Read/Execute
.text$mn:00003CE4 _text$mn        segment para public 'CODE' use32
.text$mn:00003CE4                 assume cs:_text$mn
.text$mn:00003CE4                 ;org 3CE4h
.text$mn:00003CE4 ; COMDAT (pick any)
.text$mn:00003CE4                 assume es:nothing, ss:nothing, ds:_data, fs:nothing, gs:nothing
.text$mn:00003CE4
.text$mn:00003CE4 ; =============== S U B R O U T I N E =======================================
.text$mn:00003CE4
.text$mn:00003CE4 ; Attributes: bp-based frame
.text$mn:00003CE4
.text$mn:00003CE4 ; public: void __thiscall std::_Wrap_alloc<class std::allocator<struct std::_Container_proxy>>::destroy<struct std::_Container_proxy>(struct std::_Container_proxy *)
.text$mn:00003CE4                 public ??$destroy@U_Container_proxy@std@@@?$_Wrap_alloc@V?$allocator@U_Container_proxy@std@@@std@@@std@@QAEXPAU_Container_proxy@1@@Z
.text$mn:00003CE4 ??$destroy@U_Container_proxy@std@@@?$_Wrap_alloc@V?$allocator@U_Container_proxy@std@@@std@@@std@@QAEXPAU_Container_proxy@1@@Z proc near
.text$mn:00003CE4                                         ; CODE XREF: std::_Vector_alloc<0,std::_Vec_base_types<wchar_t const *,std::allocator<wchar_t const *>>>::_Free_proxy(void)+22p
.text$mn:00003CE4                                         ; std::_Vector_alloc<0,std::_Vec_base_types<FunctionValues,std::allocator<FunctionValues>>>::_Free_proxy(void)+22p ...
.text$mn:00003CE4
.text$mn:00003CE4 var_4           = dword ptr -4
.text$mn:00003CE4 arg_0           = dword ptr  8
.text$mn:00003CE4
.text$mn:00003CE4                 push    ebp
.text$mn:00003CE5                 mov     ebp, esp
.text$mn:00003CE7                 push    ecx
.text$mn:00003CE8                 mov     [ebp+var_4], ecx
.text$mn:00003CEB                 mov     eax, [ebp+arg_0]
.text$mn:00003CEE                 push    eax
.text$mn:00003CEF                 mov     ecx, [ebp+var_4]
.text$mn:00003CF2                 push    ecx
.text$mn:00003CF3                 call    ??$destroy@U_Container_proxy@std@@@?$allocator_traits@V?$allocator@U_Container_proxy@std@@@std@@@std@@SAXAAV?$allocator@U_Container_proxy@std@@@1@PAU_Container_proxy@1@@Z ; std::allocator_traits<std::allocator<std::_Container_proxy>>::destroy<std::_Container_proxy>(std::allocator<std::_Container_proxy> &,std::_Container_proxy *)
.text$mn:00003CF8                 add     esp, 8
.text$mn:00003CFB                 mov     esp, ebp
.text$mn:00003CFD                 pop     ebp
.text$mn:00003CFE                 retn    4
.text$mn:00003CFE ??$destroy@U_Container_proxy@std@@@?$_Wrap_alloc@V?$allocator@U_Container_proxy@std@@@std@@@std@@QAEXPAU_Container_proxy@1@@Z endp
.text$mn:00003CFE
.text$mn:00003CFE ; ---------------------------------------------------------------------------
.text$mn:00003D01                 align 4
.text$mn:00003D01 _text$mn        ends
.text$mn:00003D01
.text$mn:00003D04 ; ===========================================================================
.text$mn:00003D04
.text$mn:00003D04 ; Segment type: Pure code
.text$mn:00003D04 ; Segment permissions: Read/Execute
.text$mn:00003D04 _text$mn        segment para public 'CODE' use32
.text$mn:00003D04                 assume cs:_text$mn
.text$mn:00003D04                 ;org 3D04h
.text$mn:00003D04 ; COMDAT (pick any)
.text$mn:00003D04                 assume es:nothing, ss:nothing, ds:_data, fs:nothing, gs:nothing
.text$mn:00003D04
.text$mn:00003D04 ; =============== S U B R O U T I N E =======================================
.text$mn:00003D04
.text$mn:00003D04 ; Attributes: bp-based frame
.text$mn:00003D04
.text$mn:00003D04 ; public: void __thiscall std::allocator<struct std::_Container_proxy>::destroy<struct std::_Container_proxy>(struct std::_Container_proxy *)
.text$mn:00003D04                 public ??$destroy@U_Container_proxy@std@@@?$allocator@U_Container_proxy@std@@@std@@QAEXPAU_Container_proxy@1@@Z
.text$mn:00003D04 ??$destroy@U_Container_proxy@std@@@?$allocator@U_Container_proxy@std@@@std@@QAEXPAU_Container_proxy@1@@Z proc near
.text$mn:00003D04                                         ; CODE XREF: std::allocator_traits<std::allocator<std::_Container_proxy>>::destroy<std::_Container_proxy>(std::allocator<std::_Container_proxy> &,std::_Container_proxy *)+Ap
.text$mn:00003D04                                         ; std::_String_alloc<0,std::_String_base_types<char,std::allocator<char>>>::_Free_proxy(void)+22p
.text$mn:00003D04
.text$mn:00003D04 var_4           = dword ptr -4
.text$mn:00003D04
.text$mn:00003D04                 push    ebp
.text$mn:00003D05                 mov     ebp, esp
.text$mn:00003D07                 push    ecx
.text$mn:00003D08                 mov     [ebp+var_4], ecx
.text$mn:00003D0B                 mov     esp, ebp
.text$mn:00003D0D                 pop     ebp
.text$mn:00003D0E                 retn    4
.text$mn:00003D0E ??$destroy@U_Container_proxy@std@@@?$allocator@U_Container_proxy@std@@@std@@QAEXPAU_Container_proxy@1@@Z endp
.text$mn:00003D0E
.text$mn:00003D0E ; ---------------------------------------------------------------------------
.text$mn:00003D11                 align 4
.text$mn:00003D11 _text$mn        ends
.text$mn:00003D11
.text$mn:00003D14 ; ===========================================================================
.text$mn:00003D14
.text$mn:00003D14 ; Segment type: Pure code
.text$mn:00003D14 ; Segment permissions: Read/Execute
.text$mn:00003D14 _text$mn        segment para public 'CODE' use32
.text$mn:00003D14                 assume cs:_text$mn
.text$mn:00003D14                 ;org 3D14h
.text$mn:00003D14 ; COMDAT (pick any)
.text$mn:00003D14                 assume es:nothing, ss:nothing, ds:_data, fs:nothing, gs:nothing
.text$mn:00003D14
.text$mn:00003D14 ; =============== S U B R O U T I N E =======================================
.text$mn:00003D14
.text$mn:00003D14 ; Attributes: bp-based frame
.text$mn:00003D14
.text$mn:00003D14 ; public: static void __cdecl std::allocator_traits<class std::allocator<struct std::_Container_proxy>>::destroy<struct std::_Container_proxy>(class std::allocator<struct std::_Container_proxy> &, struct std::_Container_proxy *)
.text$mn:00003D14                 public ??$destroy@U_Container_proxy@std@@@?$allocator_traits@V?$allocator@U_Container_proxy@std@@@std@@@std@@SAXAAV?$allocator@U_Container_proxy@std@@@1@PAU_Container_proxy@1@@Z
.text$mn:00003D14 ??$destroy@U_Container_proxy@std@@@?$allocator_traits@V?$allocator@U_Container_proxy@std@@@std@@@std@@SAXAAV?$allocator@U_Container_proxy@std@@@1@PAU_Container_proxy@1@@Z proc near
.text$mn:00003D14                                         ; CODE XREF: std::_Wrap_alloc<std::allocator<std::_Container_proxy>>::destroy<std::_Container_proxy>(std::_Container_proxy *)+Fp
.text$mn:00003D14
.text$mn:00003D14 arg_0           = dword ptr  8
.text$mn:00003D14 arg_4           = dword ptr  0Ch
.text$mn:00003D14
.text$mn:00003D14                 push    ebp
.text$mn:00003D15                 mov     ebp, esp
.text$mn:00003D17                 mov     eax, [ebp+arg_4]
.text$mn:00003D1A                 push    eax
.text$mn:00003D1B                 mov     ecx, [ebp+arg_0]
.text$mn:00003D1E                 call    ??$destroy@U_Container_proxy@std@@@?$allocator@U_Container_proxy@std@@@std@@QAEXPAU_Container_proxy@1@@Z ; std::allocator<std::_Container_proxy>::destroy<std::_Container_proxy>(std::_Container_proxy *)
.text$mn:00003D23                 pop     ebp
.text$mn:00003D24                 retn
.text$mn:00003D24 ??$destroy@U_Container_proxy@std@@@?$allocator_traits@V?$allocator@U_Container_proxy@std@@@std@@@std@@SAXAAV?$allocator@U_Container_proxy@std@@@1@PAU_Container_proxy@1@@Z endp
.text$mn:00003D24
.text$mn:00003D24 ; ---------------------------------------------------------------------------
.text$mn:00003D25                 align 4
.text$mn:00003D25 _text$mn        ends
.text$mn:00003D25
.text$mn:00003D28 ; ===========================================================================
.text$mn:00003D28
.text$mn:00003D28 ; Segment type: Pure code
.text$mn:00003D28 ; Segment permissions: Read/Execute
.text$mn:00003D28 _text$mn        segment para public 'CODE' use32
.text$mn:00003D28                 assume cs:_text$mn
.text$mn:00003D28                 ;org 3D28h
.text$mn:00003D28 ; COMDAT (pick any)
.text$mn:00003D28                 assume es:nothing, ss:nothing, ds:_data, fs:nothing, gs:nothing
.text$mn:00003D28
.text$mn:00003D28 ; =============== S U B R O U T I N E =======================================
.text$mn:00003D28
.text$mn:00003D28 ; Attributes: bp-based frame
.text$mn:00003D28
.text$mn:00003D28 ; public: void __thiscall std::_Wrap_alloc<class std::allocator<class std::vector<wchar_t const *, class std::allocator<wchar_t const *>>>>::destroy<class std::vector<wchar_t const *, class std::allocator<wchar_t const *>>>(class std::vector<wchar_t const *, class std::allocator<wchar_t const *>> *)
.text$mn:00003D28                 public ??$destroy@V?$vector@PB_WV?$allocator@PB_W@std@@@std@@@?$_Wrap_alloc@V?$allocator@V?$vector@PB_WV?$allocator@PB_W@std@@@std@@@std@@@std@@QAEXPAV?$vector@PB_WV?$allocator@PB_W@std@@@1@@Z
.text$mn:00003D28 ??$destroy@V?$vector@PB_WV?$allocator@PB_W@std@@@std@@@?$_Wrap_alloc@V?$allocator@V?$vector@PB_WV?$allocator@PB_W@std@@@std@@@std@@@std@@QAEXPAV?$vector@PB_WV?$allocator@PB_W@std@@@1@@Z proc near
.text$mn:00003D28                                         ; CODE XREF: std::_Destroy_range<std::_Wrap_alloc<std::allocator<std::vector<wchar_t const *,std::allocator<wchar_t const *>>>>>(std::vector<wchar_t const *,std::allocator<wchar_t const *>> *,std::vector<wchar_t const *,std::allocator<wchar_t const *>> *,std::_Wrap_alloc<std::allocator<std::vector<wchar_t const *,std::allocator<wchar_t const *>>>> &,std::_Nonscalar_ptr_iterator_tag)+1Dp
.text$mn:00003D28                                         ; __catch$??$_Uninit_move@PAV?$vector@PB_WV?$allocator@PB_W@std@@@std@@PAV12@V?$allocator@V?$vector@PB_WV?$allocator@PB_W@std@@@std@@@2@V12@@std@@YAPAV?$vector@PB_WV?$allocator@PB_W@std@@@0@PAV10@00AAU?$_Wrap_alloc@V?$allocator@V?$vector@PB_WV?$allocator@PB_W@std@@@std@@@std@@@0@0U_Nonscalar_ptr_iterator_tag@0@@Z$0+1Ap
.text$mn:00003D28
.text$mn:00003D28 var_4           = dword ptr -4
.text$mn:00003D28 arg_0           = dword ptr  8
.text$mn:00003D28
.text$mn:00003D28                 push    ebp
.text$mn:00003D29                 mov     ebp, esp
.text$mn:00003D2B                 push    ecx
.text$mn:00003D2C                 mov     [ebp+var_4], ecx
.text$mn:00003D2F                 mov     eax, [ebp+arg_0]
.text$mn:00003D32                 push    eax
.text$mn:00003D33                 mov     ecx, [ebp+var_4]
.text$mn:00003D36                 push    ecx
.text$mn:00003D37                 call    ??$destroy@V?$vector@PB_WV?$allocator@PB_W@std@@@std@@@?$allocator_traits@V?$allocator@V?$vector@PB_WV?$allocator@PB_W@std@@@std@@@std@@@std@@SAXAAV?$allocator@V?$vector@PB_WV?$allocator@PB_W@std@@@std@@@1@PAV?$vector@PB_WV?$allocator@PB_W@std@@@1@@Z ; std::allocator_traits<std::allocator<std::vector<wchar_t const *,std::allocator<wchar_t const *>>>>::destroy<std::vector<wchar_t const *,std::allocator<wchar_t const *>>>(std::allocator<std::vector<wchar_t const *,std::allocator<wchar_t const *>>> &,std::vector<wchar_t const *,std::allocator<wchar_t const *>> *)
.text$mn:00003D3C                 add     esp, 8
.text$mn:00003D3F                 mov     esp, ebp
.text$mn:00003D41                 pop     ebp
.text$mn:00003D42                 retn    4
.text$mn:00003D42 ??$destroy@V?$vector@PB_WV?$allocator@PB_W@std@@@std@@@?$_Wrap_alloc@V?$allocator@V?$vector@PB_WV?$allocator@PB_W@std@@@std@@@std@@@std@@QAEXPAV?$vector@PB_WV?$allocator@PB_W@std@@@1@@Z endp
.text$mn:00003D42
.text$mn:00003D42 ; ---------------------------------------------------------------------------
.text$mn:00003D45                 align 4
.text$mn:00003D45 _text$mn        ends
.text$mn:00003D45
.text$mn:00003D48 ; ===========================================================================
.text$mn:00003D48
.text$mn:00003D48 ; Segment type: Pure code
.text$mn:00003D48 ; Segment permissions: Read/Execute
.text$mn:00003D48 _text$mn        segment para public 'CODE' use32
.text$mn:00003D48                 assume cs:_text$mn
.text$mn:00003D48                 ;org 3D48h
.text$mn:00003D48 ; COMDAT (pick any)
.text$mn:00003D48                 assume es:nothing, ss:nothing, ds:_data, fs:nothing, gs:nothing
.text$mn:00003D48
.text$mn:00003D48 ; =============== S U B R O U T I N E =======================================
.text$mn:00003D48
.text$mn:00003D48 ; Attributes: bp-based frame
.text$mn:00003D48
.text$mn:00003D48 ; public: void __thiscall std::allocator<class std::vector<wchar_t const *, class std::allocator<wchar_t const *>>>::destroy<class std::vector<wchar_t const *, class std::allocator<wchar_t const *>>>(class std::vector<wchar_t const *, class std::allocator<wchar_t const *>> *)
.text$mn:00003D48                 public ??$destroy@V?$vector@PB_WV?$allocator@PB_W@std@@@std@@@?$allocator@V?$vector@PB_WV?$allocator@PB_W@std@@@std@@@std@@QAEXPAV?$vector@PB_WV?$allocator@PB_W@std@@@1@@Z
.text$mn:00003D48 ??$destroy@V?$vector@PB_WV?$allocator@PB_W@std@@@std@@@?$allocator@V?$vector@PB_WV?$allocator@PB_W@std@@@std@@@std@@QAEXPAV?$vector@PB_WV?$allocator@PB_W@std@@@1@@Z proc near
.text$mn:00003D48                                         ; CODE XREF: std::allocator_traits<std::allocator<std::vector<wchar_t const *,std::allocator<wchar_t const *>>>>::destroy<std::vector<wchar_t const *,std::allocator<wchar_t const *>>>(std::allocator<std::vector<wchar_t const *,std::allocator<wchar_t const *>>> &,std::vector<wchar_t const *,std::allocator<wchar_t const *>> *)+Ap
.text$mn:00003D48
.text$mn:00003D48 var_4           = dword ptr -4
.text$mn:00003D48 arg_0           = dword ptr  8
.text$mn:00003D48
.text$mn:00003D48                 push    ebp
.text$mn:00003D49                 mov     ebp, esp
.text$mn:00003D4B                 push    ecx
.text$mn:00003D4C                 mov     [ebp+var_4], ecx
.text$mn:00003D4F                 push    0
.text$mn:00003D51                 mov     ecx, [ebp+arg_0]
.text$mn:00003D54                 call    ??_G?$vector@PB_WV?$allocator@PB_W@std@@@std@@QAEPAXI@Z ; std::vector<wchar_t const *,std::allocator<wchar_t const *>>::`scalar deleting destructor'(uint)
.text$mn:00003D59                 mov     esp, ebp
.text$mn:00003D5B                 pop     ebp
.text$mn:00003D5C                 retn    4
.text$mn:00003D5C ??$destroy@V?$vector@PB_WV?$allocator@PB_W@std@@@std@@@?$allocator@V?$vector@PB_WV?$allocator@PB_W@std@@@std@@@std@@QAEXPAV?$vector@PB_WV?$allocator@PB_W@std@@@1@@Z endp
.text$mn:00003D5C
.text$mn:00003D5C ; ---------------------------------------------------------------------------
.text$mn:00003D5F                 align 10h
.text$mn:00003D5F _text$mn        ends
.text$mn:00003D5F
.text$mn:00003D60 ; ===========================================================================
.text$mn:00003D60
.text$mn:00003D60 ; Segment type: Pure code
.text$mn:00003D60 ; Segment permissions: Read/Execute
.text$mn:00003D60 _text$mn        segment para public 'CODE' use32
.text$mn:00003D60                 assume cs:_text$mn
.text$mn:00003D60                 ;org 3D60h
.text$mn:00003D60 ; COMDAT (pick any)
.text$mn:00003D60                 assume es:nothing, ss:nothing, ds:_data, fs:nothing, gs:nothing
.text$mn:00003D60
.text$mn:00003D60 ; =============== S U B R O U T I N E =======================================
.text$mn:00003D60
.text$mn:00003D60 ; Attributes: bp-based frame
.text$mn:00003D60
.text$mn:00003D60 ; public: static void __cdecl std::allocator_traits<class std::allocator<class std::vector<wchar_t const *, class std::allocator<wchar_t const *>>>>::destroy<class std::vector<wchar_t const *, class std::allocator<wchar_t const *>>>(class std::allocator<class std::vector<wchar_t const *, class std::allocator<wchar_t const *>>> &, class std::vector<wchar_t const *, class std::allocator<wchar_t const *>> *)
.text$mn:00003D60                 public ??$destroy@V?$vector@PB_WV?$allocator@PB_W@std@@@std@@@?$allocator_traits@V?$allocator@V?$vector@PB_WV?$allocator@PB_W@std@@@std@@@std@@@std@@SAXAAV?$allocator@V?$vector@PB_WV?$allocator@PB_W@std@@@std@@@1@PAV?$vector@PB_WV?$allocator@PB_W@std@@@1@@Z
.text$mn:00003D60 ??$destroy@V?$vector@PB_WV?$allocator@PB_W@std@@@std@@@?$allocator_traits@V?$allocator@V?$vector@PB_WV?$allocator@PB_W@std@@@std@@@std@@@std@@SAXAAV?$allocator@V?$vector@PB_WV?$allocator@PB_W@std@@@std@@@1@PAV?$vector@PB_WV?$allocator@PB_W@std@@@1@@Z proc near
.text$mn:00003D60                                         ; CODE XREF: std::_Wrap_alloc<std::allocator<std::vector<wchar_t const *,std::allocator<wchar_t const *>>>>::destroy<std::vector<wchar_t const *,std::allocator<wchar_t const *>>>(std::vector<wchar_t const *,std::allocator<wchar_t const *>> *)+Fp
.text$mn:00003D60
.text$mn:00003D60 arg_0           = dword ptr  8
.text$mn:00003D60 arg_4           = dword ptr  0Ch
.text$mn:00003D60
.text$mn:00003D60                 push    ebp
.text$mn:00003D61                 mov     ebp, esp
.text$mn:00003D63                 mov     eax, [ebp+arg_4]
.text$mn:00003D66                 push    eax
.text$mn:00003D67                 mov     ecx, [ebp+arg_0]
.text$mn:00003D6A                 call    ??$destroy@V?$vector@PB_WV?$allocator@PB_W@std@@@std@@@?$allocator@V?$vector@PB_WV?$allocator@PB_W@std@@@std@@@std@@QAEXPAV?$vector@PB_WV?$allocator@PB_W@std@@@1@@Z ; std::allocator<std::vector<wchar_t const *,std::allocator<wchar_t const *>>>::destroy<std::vector<wchar_t const *,std::allocator<wchar_t const *>>>(std::vector<wchar_t const *,std::allocator<wchar_t const *>> *)
.text$mn:00003D6F                 pop     ebp
.text$mn:00003D70                 retn
.text$mn:00003D70 ??$destroy@V?$vector@PB_WV?$allocator@PB_W@std@@@std@@@?$allocator_traits@V?$allocator@V?$vector@PB_WV?$allocator@PB_W@std@@@std@@@std@@@std@@SAXAAV?$allocator@V?$vector@PB_WV?$allocator@PB_W@std@@@std@@@1@PAV?$vector@PB_WV?$allocator@PB_W@std@@@1@@Z endp
.text$mn:00003D70
.text$mn:00003D70 ; ---------------------------------------------------------------------------
.text$mn:00003D71                 align 4
.text$mn:00003D71 _text$mn        ends
.text$mn:00003D71
.text$mn:00003D74 ; ===========================================================================
.text$mn:00003D74
.text$mn:00003D74 ; Segment type: Pure code
.text$mn:00003D74 ; Segment permissions: Read/Execute
.text$mn:00003D74 _text$mn        segment para public 'CODE' use32
.text$mn:00003D74                 assume cs:_text$mn
.text$mn:00003D74                 ;org 3D74h
.text$mn:00003D74 ; COMDAT (pick any)
.text$mn:00003D74                 assume es:nothing, ss:nothing, ds:_data, fs:nothing, gs:nothing
.text$mn:00003D74
.text$mn:00003D74 ; =============== S U B R O U T I N E =======================================
.text$mn:00003D74
.text$mn:00003D74 ; Attributes: bp-based frame
.text$mn:00003D74
.text$mn:00003D74 ; char * & __cdecl std::forward<char * &>(char * &)
.text$mn:00003D74                 public ??$forward@AAPAD@std@@YAAAPADAAPAD@Z
.text$mn:00003D74 ??$forward@AAPAD@std@@YAAAPADAAPAD@Z proc near
.text$mn:00003D74                                         ; CODE XREF: std::_Wrap_alloc<std::allocator<char>>::construct<char *,char * &>(char * *,char * &)+Bp
.text$mn:00003D74                                         ; std::allocator<char>::construct<char *,char * &>(char * *,char * &)+4Ap ...
.text$mn:00003D74
.text$mn:00003D74 arg_0           = dword ptr  8
.text$mn:00003D74
.text$mn:00003D74                 push    ebp
.text$mn:00003D75                 mov     ebp, esp
.text$mn:00003D77                 mov     eax, [ebp+arg_0]
.text$mn:00003D7A                 pop     ebp
.text$mn:00003D7B                 retn
.text$mn:00003D7B ??$forward@AAPAD@std@@YAAAPADAAPAD@Z endp
.text$mn:00003D7B
.text$mn:00003D7B _text$mn        ends
.text$mn:00003D7B
.text$mn:00003D7C ; ===========================================================================
.text$mn:00003D7C
.text$mn:00003D7C ; Segment type: Pure code
.text$mn:00003D7C ; Segment permissions: Read/Execute
.text$mn:00003D7C _text$mn        segment para public 'CODE' use32
.text$mn:00003D7C                 assume cs:_text$mn
.text$mn:00003D7C                 ;org 3D7Ch
.text$mn:00003D7C ; COMDAT (pick any)
.text$mn:00003D7C                 assume es:nothing, ss:nothing, ds:_data, fs:nothing, gs:nothing
.text$mn:00003D7C
.text$mn:00003D7C ; =============== S U B R O U T I N E =======================================
.text$mn:00003D7C
.text$mn:00003D7C ; Attributes: bp-based frame
.text$mn:00003D7C
.text$mn:00003D7C ; wchar_t const * & __cdecl std::forward<wchar_t const * &>(wchar_t const * &)
.text$mn:00003D7C                 public ??$forward@AAPB_W@std@@YAAAPB_WAAPB_W@Z
.text$mn:00003D7C ??$forward@AAPB_W@std@@YAAAPB_WAAPB_W@Z proc near
.text$mn:00003D7C                                         ; CODE XREF: std::_Wrap_alloc<std::allocator<wchar_t const *>>::construct<wchar_t const *,wchar_t const * &>(wchar_t const * *,wchar_t const * &)+Bp
.text$mn:00003D7C                                         ; std::allocator<wchar_t const *>::construct<wchar_t const *,wchar_t const * &>(wchar_t const * *,wchar_t const * &)+4Ap ...
.text$mn:00003D7C
.text$mn:00003D7C arg_0           = dword ptr  8
.text$mn:00003D7C
.text$mn:00003D7C                 push    ebp
.text$mn:00003D7D                 mov     ebp, esp
.text$mn:00003D7F                 mov     eax, [ebp+arg_0]
.text$mn:00003D82                 pop     ebp
.text$mn:00003D83                 retn
.text$mn:00003D83 ??$forward@AAPB_W@std@@YAAAPB_WAAPB_W@Z endp
.text$mn:00003D83
.text$mn:00003D83 _text$mn        ends
.text$mn:00003D83
.text$mn:00003D84 ; ===========================================================================
.text$mn:00003D84
.text$mn:00003D84 ; Segment type: Pure code
.text$mn:00003D84 ; Segment permissions: Read/Execute
.text$mn:00003D84 _text$mn        segment para public 'CODE' use32
.text$mn:00003D84                 assume cs:_text$mn
.text$mn:00003D84                 ;org 3D84h
.text$mn:00003D84 ; COMDAT (pick any)
.text$mn:00003D84                 assume es:nothing, ss:nothing, ds:_data, fs:nothing, gs:nothing
.text$mn:00003D84
.text$mn:00003D84 ; =============== S U B R O U T I N E =======================================
.text$mn:00003D84
.text$mn:00003D84 ; Attributes: bp-based frame
.text$mn:00003D84
.text$mn:00003D84 ; struct FunctionValues & __cdecl std::forward<struct FunctionValues &>(struct FunctionValues &)
.text$mn:00003D84                 public ??$forward@AAUFunctionValues@@@std@@YAAAUFunctionValues@@AAU1@@Z
.text$mn:00003D84 ??$forward@AAUFunctionValues@@@std@@YAAAUFunctionValues@@AAU1@@Z proc near
.text$mn:00003D84                                         ; CODE XREF: std::_Wrap_alloc<std::allocator<FunctionValues>>::construct<FunctionValues,FunctionValues &>(FunctionValues *,FunctionValues &)+Bp
.text$mn:00003D84                                         ; std::allocator<FunctionValues>::construct<FunctionValues,FunctionValues &>(FunctionValues *,FunctionValues &)+4Ap ...
.text$mn:00003D84
.text$mn:00003D84 arg_0           = dword ptr  8
.text$mn:00003D84
.text$mn:00003D84                 push    ebp
.text$mn:00003D85                 mov     ebp, esp
.text$mn:00003D87                 mov     eax, [ebp+arg_0]
.text$mn:00003D8A                 pop     ebp
.text$mn:00003D8B                 retn
.text$mn:00003D8B ??$forward@AAUFunctionValues@@@std@@YAAAUFunctionValues@@AAU1@@Z endp
.text$mn:00003D8B
.text$mn:00003D8B _text$mn        ends
.text$mn:00003D8B
.text$mn:00003D8C ; ===========================================================================
.text$mn:00003D8C
.text$mn:00003D8C ; Segment type: Pure code
.text$mn:00003D8C ; Segment permissions: Read/Execute
.text$mn:00003D8C _text$mn        segment para public 'CODE' use32
.text$mn:00003D8C                 assume cs:_text$mn
.text$mn:00003D8C                 ;org 3D8Ch
.text$mn:00003D8C ; COMDAT (pick any)
.text$mn:00003D8C                 assume es:nothing, ss:nothing, ds:_data, fs:nothing, gs:nothing
.text$mn:00003D8C
.text$mn:00003D8C ; =============== S U B R O U T I N E =======================================
.text$mn:00003D8C
.text$mn:00003D8C ; Attributes: bp-based frame
.text$mn:00003D8C
.text$mn:00003D8C ; class std::vector<wchar_t const *, class std::allocator<wchar_t const *>> & __cdecl std::forward<class std::vector<wchar_t const *, class std::allocator<wchar_t const *>> &>(class std::vector<wchar_t const *, class std::allocator<wchar_t const *>> &)
.text$mn:00003D8C                 public ??$forward@AAV?$vector@PB_WV?$allocator@PB_W@std@@@std@@@std@@YAAAV?$vector@PB_WV?$allocator@PB_W@std@@@0@AAV10@@Z
.text$mn:00003D8C ??$forward@AAV?$vector@PB_WV?$allocator@PB_W@std@@@std@@@std@@YAAAV?$vector@PB_WV?$allocator@PB_W@std@@@0@AAV10@@Z proc near
.text$mn:00003D8C                                         ; CODE XREF: std::_Wrap_alloc<std::allocator<std::vector<wchar_t const *,std::allocator<wchar_t const *>>>>::construct<std::vector<wchar_t const *,std::allocator<wchar_t const *>>,std::vector<wchar_t const *,std::allocator<wchar_t const *>> &>(std::vector<wchar_t const *,std::allocator<wchar_t const *>> *,std::vector<wchar_t const *,std::allocator<wchar_t const *>> &)+Bp
.text$mn:00003D8C                                         ; std::allocator<std::vector<wchar_t const *,std::allocator<wchar_t const *>>>::construct<std::vector<wchar_t const *,std::allocator<wchar_t const *>>,std::vector<wchar_t const *,std::allocator<wchar_t const *>> &>(std::vector<wchar_t const *,std::allocator<wchar_t const *>> *,std::vector<wchar_t const *,std::allocator<wchar_t const *>> &)+4Ap ...
.text$mn:00003D8C
.text$mn:00003D8C arg_0           = dword ptr  8
.text$mn:00003D8C
.text$mn:00003D8C                 push    ebp
.text$mn:00003D8D                 mov     ebp, esp
.text$mn:00003D8F                 mov     eax, [ebp+arg_0]
.text$mn:00003D92                 pop     ebp
.text$mn:00003D93                 retn
.text$mn:00003D93 ??$forward@AAV?$vector@PB_WV?$allocator@PB_W@std@@@std@@@std@@YAAAV?$vector@PB_WV?$allocator@PB_W@std@@@0@AAV10@@Z endp
.text$mn:00003D93
.text$mn:00003D93 _text$mn        ends
.text$mn:00003D93
.text$mn:00003D94 ; ===========================================================================
.text$mn:00003D94
.text$mn:00003D94 ; Segment type: Pure code
.text$mn:00003D94 ; Segment permissions: Read/Execute
.text$mn:00003D94 _text$mn        segment para public 'CODE' use32
.text$mn:00003D94                 assume cs:_text$mn
.text$mn:00003D94                 ;org 3D94h
.text$mn:00003D94 ; COMDAT (pick any)
.text$mn:00003D94                 assume es:nothing, ss:nothing, ds:_data, fs:nothing, gs:nothing
.text$mn:00003D94
.text$mn:00003D94 ; =============== S U B R O U T I N E =======================================
.text$mn:00003D94
.text$mn:00003D94 ; Attributes: bp-based frame
.text$mn:00003D94
.text$mn:00003D94 ; wchar_t const * const & __cdecl std::forward<wchar_t const * const &>(wchar_t const * const &)
.text$mn:00003D94                 public ??$forward@ABQB_W@std@@YAABQB_WABQB_W@Z
.text$mn:00003D94 ??$forward@ABQB_W@std@@YAABQB_WABQB_W@Z proc near
.text$mn:00003D94                                         ; CODE XREF: std::_Wrap_alloc<std::allocator<wchar_t const *>>::construct<wchar_t const *,wchar_t const * const &>(wchar_t const * *,wchar_t const * const &)+Bp
.text$mn:00003D94                                         ; std::allocator_traits<std::allocator<wchar_t const *>>::construct<wchar_t const *,wchar_t const * const &>(std::allocator<wchar_t const *> &,wchar_t const * *,wchar_t const * const &)+7p
.text$mn:00003D94
.text$mn:00003D94 arg_0           = dword ptr  8
.text$mn:00003D94
.text$mn:00003D94                 push    ebp
.text$mn:00003D95                 mov     ebp, esp
.text$mn:00003D97                 mov     eax, [ebp+arg_0]
.text$mn:00003D9A                 pop     ebp
.text$mn:00003D9B                 retn
.text$mn:00003D9B ??$forward@ABQB_W@std@@YAABQB_WABQB_W@Z endp
.text$mn:00003D9B
.text$mn:00003D9B _text$mn        ends
.text$mn:00003D9B
.text$mn:00003D9C ; ===========================================================================
.text$mn:00003D9C
.text$mn:00003D9C ; Segment type: Pure code
.text$mn:00003D9C ; Segment permissions: Read/Execute
.text$mn:00003D9C _text$mn        segment para public 'CODE' use32
.text$mn:00003D9C                 assume cs:_text$mn
.text$mn:00003D9C                 ;org 3D9Ch
.text$mn:00003D9C ; COMDAT (pick any)
.text$mn:00003D9C                 assume es:nothing, ss:nothing, ds:_data, fs:nothing, gs:nothing
.text$mn:00003D9C
.text$mn:00003D9C ; =============== S U B R O U T I N E =======================================
.text$mn:00003D9C
.text$mn:00003D9C ; Attributes: bp-based frame
.text$mn:00003D9C
.text$mn:00003D9C ; struct FunctionValues const & __cdecl std::forward<struct FunctionValues const &>(struct FunctionValues const &)
.text$mn:00003D9C                 public ??$forward@ABUFunctionValues@@@std@@YAABUFunctionValues@@ABU1@@Z
.text$mn:00003D9C ??$forward@ABUFunctionValues@@@std@@YAABUFunctionValues@@ABU1@@Z proc near
.text$mn:00003D9C                                         ; CODE XREF: std::_Wrap_alloc<std::allocator<FunctionValues>>::construct<FunctionValues,FunctionValues const &>(FunctionValues *,FunctionValues const &)+Bp
.text$mn:00003D9C                                         ; std::allocator_traits<std::allocator<FunctionValues>>::construct<FunctionValues,FunctionValues const &>(std::allocator<FunctionValues> &,FunctionValues *,FunctionValues const &)+7p
.text$mn:00003D9C
.text$mn:00003D9C arg_0           = dword ptr  8
.text$mn:00003D9C
.text$mn:00003D9C                 push    ebp
.text$mn:00003D9D                 mov     ebp, esp
.text$mn:00003D9F                 mov     eax, [ebp+arg_0]
.text$mn:00003DA2                 pop     ebp
.text$mn:00003DA3                 retn
.text$mn:00003DA3 ??$forward@ABUFunctionValues@@@std@@YAABUFunctionValues@@ABU1@@Z endp
.text$mn:00003DA3
.text$mn:00003DA3 _text$mn        ends
.text$mn:00003DA3
.text$mn:00003DA4 ; ===========================================================================
.text$mn:00003DA4
.text$mn:00003DA4 ; Segment type: Pure code
.text$mn:00003DA4 ; Segment permissions: Read/Execute
.text$mn:00003DA4 _text$mn        segment para public 'CODE' use32
.text$mn:00003DA4                 assume cs:_text$mn
.text$mn:00003DA4                 ;org 3DA4h
.text$mn:00003DA4 ; COMDAT (pick any)
.text$mn:00003DA4                 assume es:nothing, ss:nothing, ds:_data, fs:nothing, gs:nothing
.text$mn:00003DA4
.text$mn:00003DA4 ; =============== S U B R O U T I N E =======================================
.text$mn:00003DA4
.text$mn:00003DA4 ; Attributes: bp-based frame
.text$mn:00003DA4
.text$mn:00003DA4 ; class std::vector<wchar_t const *, class std::allocator<wchar_t const *>> const & __cdecl std::forward<class std::vector<wchar_t const *, class std::allocator<wchar_t const *>> const &>(class std::vector<wchar_t const *, class std::allocator<wchar_t const *>> const &)
.text$mn:00003DA4                 public ??$forward@ABV?$vector@PB_WV?$allocator@PB_W@std@@@std@@@std@@YAABV?$vector@PB_WV?$allocator@PB_W@std@@@0@ABV10@@Z
.text$mn:00003DA4 ??$forward@ABV?$vector@PB_WV?$allocator@PB_W@std@@@std@@@std@@YAABV?$vector@PB_WV?$allocator@PB_W@std@@@0@ABV10@@Z proc near
.text$mn:00003DA4                                         ; CODE XREF: std::_Wrap_alloc<std::allocator<std::vector<wchar_t const *,std::allocator<wchar_t const *>>>>::construct<std::vector<wchar_t const *,std::allocator<wchar_t const *>>,std::vector<wchar_t const *,std::allocator<wchar_t const *>> const &>(std::vector<wchar_t const *,std::allocator<wchar_t const *>> *,std::vector<wchar_t const *,std::allocator<wchar_t const *>> const &)+Bp
.text$mn:00003DA4                                         ; std::allocator_traits<std::allocator<std::vector<wchar_t const *,std::allocator<wchar_t const *>>>>::construct<std::vector<wchar_t const *,std::allocator<wchar_t const *>>,std::vector<wchar_t const *,std::allocator<wchar_t const *>> const &>(std::allocator<std::vector<wchar_t const *,std::allocator<wchar_t const *>>> &,std::vector<wchar_t const *,std::allocator<wchar_t const *>> *,std::vector<wchar_t const *,std::allocator<wchar_t const *>> const &)+7p
.text$mn:00003DA4
.text$mn:00003DA4 arg_0           = dword ptr  8
.text$mn:00003DA4
.text$mn:00003DA4                 push    ebp
.text$mn:00003DA5                 mov     ebp, esp
.text$mn:00003DA7                 mov     eax, [ebp+arg_0]
.text$mn:00003DAA                 pop     ebp
.text$mn:00003DAB                 retn
.text$mn:00003DAB ??$forward@ABV?$vector@PB_WV?$allocator@PB_W@std@@@std@@@std@@YAABV?$vector@PB_WV?$allocator@PB_W@std@@@0@ABV10@@Z endp
.text$mn:00003DAB
.text$mn:00003DAB _text$mn        ends
.text$mn:00003DAB
.text$mn:00003DAC ; ===========================================================================
.text$mn:00003DAC
.text$mn:00003DAC ; Segment type: Pure code
.text$mn:00003DAC ; Segment permissions: Read/Execute
.text$mn:00003DAC _text$mn        segment para public 'CODE' use32
.text$mn:00003DAC                 assume cs:_text$mn
.text$mn:00003DAC                 ;org 3DACh
.text$mn:00003DAC ; COMDAT (pick any)
.text$mn:00003DAC                 assume es:nothing, ss:nothing, ds:_data, fs:nothing, gs:nothing
.text$mn:00003DAC
.text$mn:00003DAC ; =============== S U B R O U T I N E =======================================
.text$mn:00003DAC
.text$mn:00003DAC ; Attributes: bp-based frame
.text$mn:00003DAC
.text$mn:00003DAC ; struct FunctionValues && __cdecl std::forward<struct FunctionValues>(struct FunctionValues &)
.text$mn:00003DAC                 public ??$forward@UFunctionValues@@@std@@YA$$QAUFunctionValues@@AAU1@@Z
.text$mn:00003DAC ??$forward@UFunctionValues@@@std@@YA$$QAUFunctionValues@@AAU1@@Z proc near
.text$mn:00003DAC                                         ; CODE XREF: std::_Wrap_alloc<std::allocator<FunctionValues>>::construct<FunctionValues,FunctionValues>(FunctionValues *,FunctionValues &&)+Bp
.text$mn:00003DAC                                         ; std::allocator<FunctionValues>::construct<FunctionValues,FunctionValues>(FunctionValues *,FunctionValues &&)+4Ap ...
.text$mn:00003DAC
.text$mn:00003DAC arg_0           = dword ptr  8
.text$mn:00003DAC
.text$mn:00003DAC                 push    ebp
.text$mn:00003DAD                 mov     ebp, esp
.text$mn:00003DAF                 mov     eax, [ebp+arg_0]
.text$mn:00003DB2                 pop     ebp
.text$mn:00003DB3                 retn
.text$mn:00003DB3 ??$forward@UFunctionValues@@@std@@YA$$QAUFunctionValues@@AAU1@@Z endp
.text$mn:00003DB3
.text$mn:00003DB3 _text$mn        ends
.text$mn:00003DB3
.text$mn:00003DB4 ; ===========================================================================
.text$mn:00003DB4
.text$mn:00003DB4 ; Segment type: Pure code
.text$mn:00003DB4 ; Segment permissions: Read/Execute
.text$mn:00003DB4 _text$mn        segment para public 'CODE' use32
.text$mn:00003DB4                 assume cs:_text$mn
.text$mn:00003DB4                 ;org 3DB4h
.text$mn:00003DB4 ; COMDAT (pick any)
.text$mn:00003DB4                 assume es:nothing, ss:nothing, ds:_data, fs:nothing, gs:nothing
.text$mn:00003DB4
.text$mn:00003DB4 ; =============== S U B R O U T I N E =======================================
.text$mn:00003DB4
.text$mn:00003DB4 ; Attributes: bp-based frame
.text$mn:00003DB4
.text$mn:00003DB4 ; struct Token && __cdecl std::forward<struct Token>(struct Token &)
.text$mn:00003DB4                 public ??$forward@UToken@@@std@@YA$$QAUToken@@AAU1@@Z
.text$mn:00003DB4 ??$forward@UToken@@@std@@YA$$QAUToken@@AAU1@@Z proc near
.text$mn:00003DB4                                         ; CODE XREF: std::_Wrap_alloc<std::allocator<Token>>::construct<Token,Token>(Token *,Token &&)+Bp
.text$mn:00003DB4                                         ; std::allocator<Token>::construct<Token,Token>(Token *,Token &&)+4Ap ...
.text$mn:00003DB4
.text$mn:00003DB4 arg_0           = dword ptr  8
.text$mn:00003DB4
.text$mn:00003DB4                 push    ebp
.text$mn:00003DB5                 mov     ebp, esp
.text$mn:00003DB7                 mov     eax, [ebp+arg_0]
.text$mn:00003DBA                 pop     ebp
.text$mn:00003DBB                 retn
.text$mn:00003DBB ??$forward@UToken@@@std@@YA$$QAUToken@@AAU1@@Z endp
.text$mn:00003DBB
.text$mn:00003DBB _text$mn        ends
.text$mn:00003DBB
.text$mn:00003DBC ; ===========================================================================
.text$mn:00003DBC
.text$mn:00003DBC ; Segment type: Pure code
.text$mn:00003DBC ; Segment permissions: Read/Execute
.text$mn:00003DBC _text$mn        segment para public 'CODE' use32
.text$mn:00003DBC                 assume cs:_text$mn
.text$mn:00003DBC                 ;org 3DBCh
.text$mn:00003DBC ; COMDAT (pick any)
.text$mn:00003DBC                 assume es:nothing, ss:nothing, ds:_data, fs:nothing, gs:nothing
.text$mn:00003DBC
.text$mn:00003DBC ; =============== S U B R O U T I N E =======================================
.text$mn:00003DBC
.text$mn:00003DBC ; Attributes: bp-based frame
.text$mn:00003DBC
.text$mn:00003DBC ; struct std::_Container_proxy && __cdecl std::forward<struct std::_Container_proxy>(struct std::_Container_proxy &)
.text$mn:00003DBC                 public ??$forward@U_Container_proxy@std@@@std@@YA$$QAU_Container_proxy@0@AAU10@@Z
.text$mn:00003DBC ??$forward@U_Container_proxy@std@@@std@@YA$$QAU_Container_proxy@0@AAU10@@Z proc near
.text$mn:00003DBC                                         ; CODE XREF: std::_Wrap_alloc<std::allocator<std::_Container_proxy>>::construct<std::_Container_proxy,std::_Container_proxy>(std::_Container_proxy *,std::_Container_proxy &&)+Bp
.text$mn:00003DBC                                         ; std::allocator<std::_Container_proxy>::construct<std::_Container_proxy,std::_Container_proxy>(std::_Container_proxy *,std::_Container_proxy &&)+4Ap ...
.text$mn:00003DBC
.text$mn:00003DBC arg_0           = dword ptr  8
.text$mn:00003DBC
.text$mn:00003DBC                 push    ebp
.text$mn:00003DBD                 mov     ebp, esp
.text$mn:00003DBF                 mov     eax, [ebp+arg_0]
.text$mn:00003DC2                 pop     ebp
.text$mn:00003DC3                 retn
.text$mn:00003DC3 ??$forward@U_Container_proxy@std@@@std@@YA$$QAU_Container_proxy@0@AAU10@@Z endp
.text$mn:00003DC3
.text$mn:00003DC3 _text$mn        ends
.text$mn:00003DC3
.text$mn:00003DC4 ; ===========================================================================
.text$mn:00003DC4
.text$mn:00003DC4 ; Segment type: Pure code
.text$mn:00003DC4 ; Segment permissions: Read/Execute
.text$mn:00003DC4 _text$mn        segment para public 'CODE' use32
.text$mn:00003DC4                 assume cs:_text$mn
.text$mn:00003DC4                 ;org 3DC4h
.text$mn:00003DC4 ; COMDAT (pick any)
.text$mn:00003DC4                 assume es:nothing, ss:nothing, ds:_data, fs:nothing, gs:nothing
.text$mn:00003DC4
.text$mn:00003DC4 ; =============== S U B R O U T I N E =======================================
.text$mn:00003DC4
.text$mn:00003DC4 ; Attributes: bp-based frame
.text$mn:00003DC4
.text$mn:00003DC4 ; class std::vector<wchar_t const *, class std::allocator<wchar_t const *>> && __cdecl std::forward<class std::vector<wchar_t const *, class std::allocator<wchar_t const *>>>(class std::vector<wchar_t const *, class std::allocator<wchar_t const *>> &)
.text$mn:00003DC4                 public ??$forward@V?$vector@PB_WV?$allocator@PB_W@std@@@std@@@std@@YA$$QAV?$vector@PB_WV?$allocator@PB_W@std@@@0@AAV10@@Z
.text$mn:00003DC4 ??$forward@V?$vector@PB_WV?$allocator@PB_W@std@@@std@@@std@@YA$$QAV?$vector@PB_WV?$allocator@PB_W@std@@@0@AAV10@@Z proc near
.text$mn:00003DC4                                         ; CODE XREF: std::_Wrap_alloc<std::allocator<std::vector<wchar_t const *,std::allocator<wchar_t const *>>>>::construct<std::vector<wchar_t const *,std::allocator<wchar_t const *>>,std::vector<wchar_t const *,std::allocator<wchar_t const *>>>(std::vector<wchar_t const *,std::allocator<wchar_t const *>> *,std::vector<wchar_t const *,std::allocator<wchar_t const *>> &&)+Bp
.text$mn:00003DC4                                         ; std::allocator<std::vector<wchar_t const *,std::allocator<wchar_t const *>>>::construct<std::vector<wchar_t const *,std::allocator<wchar_t const *>>,std::vector<wchar_t const *,std::allocator<wchar_t const *>>>(std::vector<wchar_t const *,std::allocator<wchar_t const *>> *,std::vector<wchar_t const *,std::allocator<wchar_t const *>> &&)+4Ap ...
.text$mn:00003DC4
.text$mn:00003DC4 arg_0           = dword ptr  8
.text$mn:00003DC4
.text$mn:00003DC4                 push    ebp
.text$mn:00003DC5                 mov     ebp, esp
.text$mn:00003DC7                 mov     eax, [ebp+arg_0]
.text$mn:00003DCA                 pop     ebp
.text$mn:00003DCB                 retn
.text$mn:00003DCB ??$forward@V?$vector@PB_WV?$allocator@PB_W@std@@@std@@@std@@YA$$QAV?$vector@PB_WV?$allocator@PB_W@std@@@0@AAV10@@Z endp
.text$mn:00003DCB
.text$mn:00003DCB _text$mn        ends
.text$mn:00003DCB
.text$mn:00003DCC ; ===========================================================================
.text$mn:00003DCC
.text$mn:00003DCC ; Segment type: Pure code
.text$mn:00003DCC ; Segment permissions: Read/Execute
.text$mn:00003DCC _text$mn        segment para public 'CODE' use32
.text$mn:00003DCC                 assume cs:_text$mn
.text$mn:00003DCC                 ;org 3DCCh
.text$mn:00003DCC ; COMDAT (pick any)
.text$mn:00003DCC                 assume es:nothing, ss:nothing, ds:_data, fs:nothing, gs:nothing
.text$mn:00003DCC
.text$mn:00003DCC ; =============== S U B R O U T I N E =======================================
.text$mn:00003DCC
.text$mn:00003DCC ; Attributes: bp-based frame
.text$mn:00003DCC
.text$mn:00003DCC ; int __stdcall std::_Iterator012<std::random_access_iterator_tag,wchar_t const *,int,wchar_t const * const *,wchar_t const * const &,std::_Iterator_base12>::_Iterator012<std::random_access_iterator_tag,wchar_t const *,int,wchar_t const * const *,wchar_t const * const &,std::_Iterator_base12>(struct std::_Iterator_base12 *)
.text$mn:00003DCC                 public ??0?$_Iterator012@Urandom_access_iterator_tag@std@@PB_WHPBQB_WABQB_WU_Iterator_base12@2@@std@@QAE@ABU01@@Z
.text$mn:00003DCC ??0?$_Iterator012@Urandom_access_iterator_tag@std@@PB_WHPBQB_WABQB_WU_Iterator_base12@2@@std@@QAE@ABU01@@Z proc near
.text$mn:00003DCC                                         ; CODE XREF: std::_Vector_const_iterator<std::_Vector_val<std::_Simple_types<wchar_t const *>>>::_Vector_const_iterator<std::_Vector_val<std::_Simple_types<wchar_t const *>>>(std::_Vector_const_iterator<std::_Vector_val<std::_Simple_types<wchar_t const *>>> const &)+2Dp
.text$mn:00003DCC
.text$mn:00003DCC var_10          = dword ptr -10h
.text$mn:00003DCC var_C           = dword ptr -0Ch
.text$mn:00003DCC var_4           = dword ptr -4
.text$mn:00003DCC arg_0           = dword ptr  8
.text$mn:00003DCC
.text$mn:00003DCC                 push    ebp
.text$mn:00003DCD                 mov     ebp, esp
.text$mn:00003DCF                 push    0FFFFFFFFh
.text$mn:00003DD1                 push    offset __ehhandler$??0?$_Iterator012@Urandom_access_iterator_tag@std@@PB_WHPBQB_WABQB_WU_Iterator_base12@2@@std@@QAE@ABU01@@Z
.text$mn:00003DD6                 mov     eax, large fs:0
.text$mn:00003DDC                 push    eax
.text$mn:00003DDD                 push    ecx
.text$mn:00003DDE                 mov     eax, dword ptr ds:___security_cookie
.text$mn:00003DE3                 xor     eax, ebp
.text$mn:00003DE5                 push    eax
.text$mn:00003DE6                 lea     eax, [ebp+var_C]
.text$mn:00003DE9                 mov     large fs:0, eax
.text$mn:00003DEF                 mov     [ebp+var_10], ecx
.text$mn:00003DF2                 mov     eax, [ebp+arg_0]
.text$mn:00003DF5                 push    eax             ; struct std::_Iterator_base12 *
.text$mn:00003DF6                 mov     ecx, [ebp+var_10] ; this
.text$mn:00003DF9                 call    ??0_Iterator_base12@std@@QAE@ABU01@@Z ; std::_Iterator_base12::_Iterator_base12(std::_Iterator_base12 const &)
.text$mn:00003DFE                 mov     [ebp+var_4], 0
.text$mn:00003E05                 mov     [ebp+var_4], 0FFFFFFFFh
.text$mn:00003E0C                 mov     eax, [ebp+var_10]
.text$mn:00003E0F                 mov     ecx, [ebp+var_C]
.text$mn:00003E12                 mov     large fs:0, ecx
.text$mn:00003E19                 pop     ecx
.text$mn:00003E1A                 mov     esp, ebp
.text$mn:00003E1C                 pop     ebp
.text$mn:00003E1D                 retn    4
.text$mn:00003E1D ??0?$_Iterator012@Urandom_access_iterator_tag@std@@PB_WHPBQB_WABQB_WU_Iterator_base12@2@@std@@QAE@ABU01@@Z endp
.text$mn:00003E1D
.text$mn:00003E1D _text$mn        ends
.text$mn:00003E1D
.text$x:00003E20 ; ===========================================================================
.text$x:00003E20
.text$x:00003E20 ; Segment type: Pure code
.text$x:00003E20 ; Segment permissions: Read/Execute
.text$x:00003E20 _text$x         segment para public 'CODE' use32
.text$x:00003E20                 assume cs:_text$x
.text$x:00003E20                 ;org 3E20h
.text$x:00003E20 ; COMDAT (pick associative to section at 3DCC)
.text$x:00003E20                 assume es:nothing, ss:nothing, ds:_data, fs:nothing, gs:nothing
.text$x:00003E20
.text$x:00003E20 ; =============== S U B R O U T I N E =======================================
.text$x:00003E20
.text$x:00003E20
.text$x:00003E20 __unwindfunclet$??0?$_Iterator012@Urandom_access_iterator_tag@std@@PB_WHPBQB_WABQB_WU_Iterator_base12@2@@std@@QAE@ABU01@@Z$0 proc near
.text$x:00003E20                                         ; DATA XREF: .xdata$x:00009F48o
.text$x:00003E20                 mov     ecx, [ebp-10h]  ; this
.text$x:00003E23                 jmp     ??1_Iterator_base12@std@@QAE@XZ ; std::_Iterator_base12::~_Iterator_base12(void)
.text$x:00003E23 __unwindfunclet$??0?$_Iterator012@Urandom_access_iterator_tag@std@@PB_WHPBQB_WABQB_WU_Iterator_base12@2@@std@@QAE@ABU01@@Z$0 endp
.text$x:00003E23
.text$x:00003E28
.text$x:00003E28 ; =============== S U B R O U T I N E =======================================
.text$x:00003E28
.text$x:00003E28
.text$x:00003E28 __ehhandler$??0?$_Iterator012@Urandom_access_iterator_tag@std@@PB_WHPBQB_WABQB_WU_Iterator_base12@2@@std@@QAE@ABU01@@Z proc near
.text$x:00003E28                                         ; DATA XREF: std::_Iterator012<std::random_access_iterator_tag,wchar_t const *,int,wchar_t const * const *,wchar_t const * const &,std::_Iterator_base12>::_Iterator012<std::random_access_iterator_tag,wchar_t const *,int,wchar_t const * const *,wchar_t const * const &,std::_Iterator_base12>(std::_Iterator012<std::random_access_iterator_tag,wchar_t const *,int,wchar_t const * const *,wchar_t const * const &,std::_Iterator_base12> const &)+5o
.text$x:00003E28
.text$x:00003E28 arg_4           = dword ptr  8
.text$x:00003E28
.text$x:00003E28                 mov     edx, [esp+arg_4]
.text$x:00003E2C                 lea     eax, [edx+0Ch]
.text$x:00003E2F                 mov     ecx, [edx-8]
.text$x:00003E32                 xor     ecx, eax
.text$x:00003E34                 call    @__security_check_cookie@4 ; __security_check_cookie(x)
.text$x:00003E39                 mov     eax, offset __ehfuncinfo$??0?$_Iterator012@Urandom_access_iterator_tag@std@@PB_WHPBQB_WABQB_WU_Iterator_base12@2@@std@@QAE@ABU01@@Z
.text$x:00003E3E                 jmp     ___CxxFrameHandler3
.text$x:00003E3E __ehhandler$??0?$_Iterator012@Urandom_access_iterator_tag@std@@PB_WHPBQB_WABQB_WU_Iterator_base12@2@@std@@QAE@ABU01@@Z endp
.text$x:00003E3E
.text$x:00003E3E ; ---------------------------------------------------------------------------
.text$x:00003E43                 align 4
.text$x:00003E43 _text$x         ends
.text$x:00003E43
.text$mn:00003E44 ; ===========================================================================
.text$mn:00003E44
.text$mn:00003E44 ; Segment type: Pure code
.text$mn:00003E44 ; Segment permissions: Read/Execute
.text$mn:00003E44 _text$mn        segment para public 'CODE' use32
.text$mn:00003E44                 assume cs:_text$mn
.text$mn:00003E44                 ;org 3E44h
.text$mn:00003E44 ; COMDAT (pick any)
.text$mn:00003E44                 assume es:nothing, ss:nothing, ds:_data, fs:nothing, gs:nothing
.text$mn:00003E44
.text$mn:00003E44 ; =============== S U B R O U T I N E =======================================
.text$mn:00003E44
.text$mn:00003E44 ; Attributes: bp-based frame
.text$mn:00003E44
.text$mn:00003E44 ; public: __thiscall std::_Iterator012<struct std::random_access_iterator_tag, wchar_t const *, int, wchar_t const * const *, wchar_t const * const &, struct std::_Iterator_base12>::_Iterator012<struct std::random_access_iterator_tag, wchar_t const *, int, wchar_t const * const *, wchar_t const * const &, struct std::_Iterator_base12>(void)
.text$mn:00003E44                 public ??0?$_Iterator012@Urandom_access_iterator_tag@std@@PB_WHPBQB_WABQB_WU_Iterator_base12@2@@std@@QAE@XZ
.text$mn:00003E44 ??0?$_Iterator012@Urandom_access_iterator_tag@std@@PB_WHPBQB_WABQB_WU_Iterator_base12@2@@std@@QAE@XZ proc near
.text$mn:00003E44                                         ; CODE XREF: std::_Vector_const_iterator<std::_Vector_val<std::_Simple_types<wchar_t const *>>>::_Vector_const_iterator<std::_Vector_val<std::_Simple_types<wchar_t const *>>>(wchar_t const * *,std::_Container_base12 const *)+29p
.text$mn:00003E44
.text$mn:00003E44 var_10          = dword ptr -10h
.text$mn:00003E44 var_C           = dword ptr -0Ch
.text$mn:00003E44 var_4           = dword ptr -4
.text$mn:00003E44
.text$mn:00003E44                 push    ebp
.text$mn:00003E45                 mov     ebp, esp
.text$mn:00003E47                 push    0FFFFFFFFh
.text$mn:00003E49                 push    offset __ehhandler$??0?$_Iterator012@Urandom_access_iterator_tag@std@@PB_WHPBQB_WABQB_WU_Iterator_base12@2@@std@@QAE@XZ
.text$mn:00003E4E                 mov     eax, large fs:0
.text$mn:00003E54                 push    eax
.text$mn:00003E55                 push    ecx
.text$mn:00003E56                 mov     eax, dword ptr ds:___security_cookie
.text$mn:00003E5B                 xor     eax, ebp
.text$mn:00003E5D                 push    eax
.text$mn:00003E5E                 lea     eax, [ebp+var_C]
.text$mn:00003E61                 mov     large fs:0, eax
.text$mn:00003E67                 mov     [ebp+var_10], ecx
.text$mn:00003E6A                 mov     ecx, [ebp+var_10] ; this
.text$mn:00003E6D                 call    ??0_Iterator_base12@std@@QAE@XZ ; std::_Iterator_base12::_Iterator_base12(void)
.text$mn:00003E72                 mov     [ebp+var_4], 0
.text$mn:00003E79                 mov     [ebp+var_4], 0FFFFFFFFh
.text$mn:00003E80                 mov     eax, [ebp+var_10]
.text$mn:00003E83                 mov     ecx, [ebp+var_C]
.text$mn:00003E86                 mov     large fs:0, ecx
.text$mn:00003E8D                 pop     ecx
.text$mn:00003E8E                 mov     esp, ebp
.text$mn:00003E90                 pop     ebp
.text$mn:00003E91                 retn
.text$mn:00003E91 ??0?$_Iterator012@Urandom_access_iterator_tag@std@@PB_WHPBQB_WABQB_WU_Iterator_base12@2@@std@@QAE@XZ endp
.text$mn:00003E91
.text$mn:00003E91 ; ---------------------------------------------------------------------------
.text$mn:00003E92                 align 4
.text$mn:00003E92 _text$mn        ends
.text$mn:00003E92
.text$x:00003E94 ; ===========================================================================
.text$x:00003E94
.text$x:00003E94 ; Segment type: Pure code
.text$x:00003E94 ; Segment permissions: Read/Execute
.text$x:00003E94 _text$x         segment para public 'CODE' use32
.text$x:00003E94                 assume cs:_text$x
.text$x:00003E94                 ;org 3E94h
.text$x:00003E94 ; COMDAT (pick associative to section at 3E44)
.text$x:00003E94                 assume es:nothing, ss:nothing, ds:_data, fs:nothing, gs:nothing
.text$x:00003E94
.text$x:00003E94 ; =============== S U B R O U T I N E =======================================
.text$x:00003E94
.text$x:00003E94
.text$x:00003E94 __unwindfunclet$??0?$_Iterator012@Urandom_access_iterator_tag@std@@PB_WHPBQB_WABQB_WU_Iterator_base12@2@@std@@QAE@XZ$0 proc near
.text$x:00003E94                                         ; DATA XREF: .xdata$x:00009EF0o
.text$x:00003E94                 mov     ecx, [ebp-10h]  ; this
.text$x:00003E97                 jmp     ??1_Iterator_base12@std@@QAE@XZ ; std::_Iterator_base12::~_Iterator_base12(void)
.text$x:00003E97 __unwindfunclet$??0?$_Iterator012@Urandom_access_iterator_tag@std@@PB_WHPBQB_WABQB_WU_Iterator_base12@2@@std@@QAE@XZ$0 endp
.text$x:00003E97
.text$x:00003E9C
.text$x:00003E9C ; =============== S U B R O U T I N E =======================================
.text$x:00003E9C
.text$x:00003E9C
.text$x:00003E9C __ehhandler$??0?$_Iterator012@Urandom_access_iterator_tag@std@@PB_WHPBQB_WABQB_WU_Iterator_base12@2@@std@@QAE@XZ proc near
.text$x:00003E9C                                         ; DATA XREF: std::_Iterator012<std::random_access_iterator_tag,wchar_t const *,int,wchar_t const * const *,wchar_t const * const &,std::_Iterator_base12>::_Iterator012<std::random_access_iterator_tag,wchar_t const *,int,wchar_t const * const *,wchar_t const * const &,std::_Iterator_base12>(void)+5o
.text$x:00003E9C
.text$x:00003E9C arg_4           = dword ptr  8
.text$x:00003E9C
.text$x:00003E9C                 mov     edx, [esp+arg_4]
.text$x:00003EA0                 lea     eax, [edx+0Ch]
.text$x:00003EA3                 mov     ecx, [edx-8]
.text$x:00003EA6                 xor     ecx, eax
.text$x:00003EA8                 call    @__security_check_cookie@4 ; __security_check_cookie(x)
.text$x:00003EAD                 mov     eax, offset __ehfuncinfo$??0?$_Iterator012@Urandom_access_iterator_tag@std@@PB_WHPBQB_WABQB_WU_Iterator_base12@2@@std@@QAE@XZ
.text$x:00003EB2                 jmp     ___CxxFrameHandler3
.text$x:00003EB2 __ehhandler$??0?$_Iterator012@Urandom_access_iterator_tag@std@@PB_WHPBQB_WABQB_WU_Iterator_base12@2@@std@@QAE@XZ endp
.text$x:00003EB2
.text$x:00003EB2 ; ---------------------------------------------------------------------------
.text$x:00003EB7                 align 4
.text$x:00003EB7 _text$x         ends
.text$x:00003EB7
.text$mn:00003EB8 ; ===========================================================================
.text$mn:00003EB8
.text$mn:00003EB8 ; Segment type: Pure code
.text$mn:00003EB8 ; Segment permissions: Read/Execute
.text$mn:00003EB8 _text$mn        segment para public 'CODE' use32
.text$mn:00003EB8                 assume cs:_text$mn
.text$mn:00003EB8                 ;org 3EB8h
.text$mn:00003EB8 ; COMDAT (pick any)
.text$mn:00003EB8                 assume es:nothing, ss:nothing, ds:_data, fs:nothing, gs:nothing
.text$mn:00003EB8
.text$mn:00003EB8 ; =============== S U B R O U T I N E =======================================
.text$mn:00003EB8
.text$mn:00003EB8 ; Attributes: bp-based frame
.text$mn:00003EB8
.text$mn:00003EB8 ; int __stdcall std::_Iterator012<std::random_access_iterator_tag,FunctionValues,int,FunctionValues const *,FunctionValues const &,std::_Iterator_base12>::_Iterator012<std::random_access_iterator_tag,FunctionValues,int,FunctionValues const *,FunctionValues const &,std::_Iterator_base12>(struct std::_Iterator_base12 *)
.text$mn:00003EB8                 public ??0?$_Iterator012@Urandom_access_iterator_tag@std@@UFunctionValues@@HPBU3@ABU3@U_Iterator_base12@2@@std@@QAE@ABU01@@Z
.text$mn:00003EB8 ??0?$_Iterator012@Urandom_access_iterator_tag@std@@UFunctionValues@@HPBU3@ABU3@U_Iterator_base12@2@@std@@QAE@ABU01@@Z proc near
.text$mn:00003EB8                                         ; CODE XREF: std::_Vector_const_iterator<std::_Vector_val<std::_Simple_types<FunctionValues>>>::_Vector_const_iterator<std::_Vector_val<std::_Simple_types<FunctionValues>>>(std::_Vector_const_iterator<std::_Vector_val<std::_Simple_types<FunctionValues>>> const &)+2Dp
.text$mn:00003EB8
.text$mn:00003EB8 var_10          = dword ptr -10h
.text$mn:00003EB8 var_C           = dword ptr -0Ch
.text$mn:00003EB8 var_4           = dword ptr -4
.text$mn:00003EB8 arg_0           = dword ptr  8
.text$mn:00003EB8
.text$mn:00003EB8                 push    ebp
.text$mn:00003EB9                 mov     ebp, esp
.text$mn:00003EBB                 push    0FFFFFFFFh
.text$mn:00003EBD                 push    offset __ehhandler$??0?$_Iterator012@Urandom_access_iterator_tag@std@@UFunctionValues@@HPBU3@ABU3@U_Iterator_base12@2@@std@@QAE@ABU01@@Z
.text$mn:00003EC2                 mov     eax, large fs:0
.text$mn:00003EC8                 push    eax
.text$mn:00003EC9                 push    ecx
.text$mn:00003ECA                 mov     eax, dword ptr ds:___security_cookie
.text$mn:00003ECF                 xor     eax, ebp
.text$mn:00003ED1                 push    eax
.text$mn:00003ED2                 lea     eax, [ebp+var_C]
.text$mn:00003ED5                 mov     large fs:0, eax
.text$mn:00003EDB                 mov     [ebp+var_10], ecx
.text$mn:00003EDE                 mov     eax, [ebp+arg_0]
.text$mn:00003EE1                 push    eax             ; struct std::_Iterator_base12 *
.text$mn:00003EE2                 mov     ecx, [ebp+var_10] ; this
.text$mn:00003EE5                 call    ??0_Iterator_base12@std@@QAE@ABU01@@Z ; std::_Iterator_base12::_Iterator_base12(std::_Iterator_base12 const &)
.text$mn:00003EEA                 mov     [ebp+var_4], 0
.text$mn:00003EF1                 mov     [ebp+var_4], 0FFFFFFFFh
.text$mn:00003EF8                 mov     eax, [ebp+var_10]
.text$mn:00003EFB                 mov     ecx, [ebp+var_C]
.text$mn:00003EFE                 mov     large fs:0, ecx
.text$mn:00003F05                 pop     ecx
.text$mn:00003F06                 mov     esp, ebp
.text$mn:00003F08                 pop     ebp
.text$mn:00003F09                 retn    4
.text$mn:00003F09 ??0?$_Iterator012@Urandom_access_iterator_tag@std@@UFunctionValues@@HPBU3@ABU3@U_Iterator_base12@2@@std@@QAE@ABU01@@Z endp
.text$mn:00003F09
.text$mn:00003F09 _text$mn        ends
.text$mn:00003F09
.text$x:00003F0C ; ===========================================================================
.text$x:00003F0C
.text$x:00003F0C ; Segment type: Pure code
.text$x:00003F0C ; Segment permissions: Read/Execute
.text$x:00003F0C _text$x         segment para public 'CODE' use32
.text$x:00003F0C                 assume cs:_text$x
.text$x:00003F0C                 ;org 3F0Ch
.text$x:00003F0C ; COMDAT (pick associative to section at 3EB8)
.text$x:00003F0C                 assume es:nothing, ss:nothing, ds:_data, fs:nothing, gs:nothing
.text$x:00003F0C
.text$x:00003F0C ; =============== S U B R O U T I N E =======================================
.text$x:00003F0C
.text$x:00003F0C
.text$x:00003F0C __unwindfunclet$??0?$_Iterator012@Urandom_access_iterator_tag@std@@UFunctionValues@@HPBU3@ABU3@U_Iterator_base12@2@@std@@QAE@ABU01@@Z$0 proc near
.text$x:00003F0C                                         ; DATA XREF: .xdata$x:00009D88o
.text$x:00003F0C                 mov     ecx, [ebp-10h]  ; this
.text$x:00003F0F                 jmp     ??1_Iterator_base12@std@@QAE@XZ ; std::_Iterator_base12::~_Iterator_base12(void)
.text$x:00003F0F __unwindfunclet$??0?$_Iterator012@Urandom_access_iterator_tag@std@@UFunctionValues@@HPBU3@ABU3@U_Iterator_base12@2@@std@@QAE@ABU01@@Z$0 endp
.text$x:00003F0F
.text$x:00003F14
.text$x:00003F14 ; =============== S U B R O U T I N E =======================================
.text$x:00003F14
.text$x:00003F14
.text$x:00003F14 __ehhandler$??0?$_Iterator012@Urandom_access_iterator_tag@std@@UFunctionValues@@HPBU3@ABU3@U_Iterator_base12@2@@std@@QAE@ABU01@@Z proc near
.text$x:00003F14                                         ; DATA XREF: std::_Iterator012<std::random_access_iterator_tag,FunctionValues,int,FunctionValues const *,FunctionValues const &,std::_Iterator_base12>::_Iterator012<std::random_access_iterator_tag,FunctionValues,int,FunctionValues const *,FunctionValues const &,std::_Iterator_base12>(std::_Iterator012<std::random_access_iterator_tag,FunctionValues,int,FunctionValues const *,FunctionValues const &,std::_Iterator_base12> const &)+5o
.text$x:00003F14
.text$x:00003F14 arg_4           = dword ptr  8
.text$x:00003F14
.text$x:00003F14                 mov     edx, [esp+arg_4]
.text$x:00003F18                 lea     eax, [edx+0Ch]
.text$x:00003F1B                 mov     ecx, [edx-8]
.text$x:00003F1E                 xor     ecx, eax
.text$x:00003F20                 call    @__security_check_cookie@4 ; __security_check_cookie(x)
.text$x:00003F25                 mov     eax, offset __ehfuncinfo$??0?$_Iterator012@Urandom_access_iterator_tag@std@@UFunctionValues@@HPBU3@ABU3@U_Iterator_base12@2@@std@@QAE@ABU01@@Z
.text$x:00003F2A                 jmp     ___CxxFrameHandler3
.text$x:00003F2A __ehhandler$??0?$_Iterator012@Urandom_access_iterator_tag@std@@UFunctionValues@@HPBU3@ABU3@U_Iterator_base12@2@@std@@QAE@ABU01@@Z endp
.text$x:00003F2A
.text$x:00003F2A ; ---------------------------------------------------------------------------
.text$x:00003F2F                 align 10h
.text$x:00003F2F _text$x         ends
.text$x:00003F2F
.text$mn:00003F30 ; ===========================================================================
.text$mn:00003F30
.text$mn:00003F30 ; Segment type: Pure code
.text$mn:00003F30 ; Segment permissions: Read/Execute
.text$mn:00003F30 _text$mn        segment para public 'CODE' use32
.text$mn:00003F30                 assume cs:_text$mn
.text$mn:00003F30                 ;org 3F30h
.text$mn:00003F30 ; COMDAT (pick any)
.text$mn:00003F30                 assume es:nothing, ss:nothing, ds:_data, fs:nothing, gs:nothing
.text$mn:00003F30
.text$mn:00003F30 ; =============== S U B R O U T I N E =======================================
.text$mn:00003F30
.text$mn:00003F30 ; Attributes: bp-based frame
.text$mn:00003F30
.text$mn:00003F30 ; public: __thiscall std::_Iterator012<struct std::random_access_iterator_tag, struct FunctionValues, int, struct FunctionValues const *, struct FunctionValues const &, struct std::_Iterator_base12>::_Iterator012<struct std::random_access_iterator_tag, struct FunctionValues, int, struct FunctionValues const *, struct FunctionValues const &, struct std::_Iterator_base12>(void)
.text$mn:00003F30                 public ??0?$_Iterator012@Urandom_access_iterator_tag@std@@UFunctionValues@@HPBU3@ABU3@U_Iterator_base12@2@@std@@QAE@XZ
.text$mn:00003F30 ??0?$_Iterator012@Urandom_access_iterator_tag@std@@UFunctionValues@@HPBU3@ABU3@U_Iterator_base12@2@@std@@QAE@XZ proc near
.text$mn:00003F30                                         ; CODE XREF: std::_Vector_const_iterator<std::_Vector_val<std::_Simple_types<FunctionValues>>>::_Vector_const_iterator<std::_Vector_val<std::_Simple_types<FunctionValues>>>(FunctionValues *,std::_Container_base12 const *)+29p
.text$mn:00003F30
.text$mn:00003F30 var_10          = dword ptr -10h
.text$mn:00003F30 var_C           = dword ptr -0Ch
.text$mn:00003F30 var_4           = dword ptr -4
.text$mn:00003F30
.text$mn:00003F30                 push    ebp
.text$mn:00003F31                 mov     ebp, esp
.text$mn:00003F33                 push    0FFFFFFFFh
.text$mn:00003F35                 push    offset __ehhandler$??0?$_Iterator012@Urandom_access_iterator_tag@std@@UFunctionValues@@HPBU3@ABU3@U_Iterator_base12@2@@std@@QAE@XZ
.text$mn:00003F3A                 mov     eax, large fs:0
.text$mn:00003F40                 push    eax
.text$mn:00003F41                 push    ecx
.text$mn:00003F42                 mov     eax, dword ptr ds:___security_cookie
.text$mn:00003F47                 xor     eax, ebp
.text$mn:00003F49                 push    eax
.text$mn:00003F4A                 lea     eax, [ebp+var_C]
.text$mn:00003F4D                 mov     large fs:0, eax
.text$mn:00003F53                 mov     [ebp+var_10], ecx
.text$mn:00003F56                 mov     ecx, [ebp+var_10] ; this
.text$mn:00003F59                 call    ??0_Iterator_base12@std@@QAE@XZ ; std::_Iterator_base12::_Iterator_base12(void)
.text$mn:00003F5E                 mov     [ebp+var_4], 0
.text$mn:00003F65                 mov     [ebp+var_4], 0FFFFFFFFh
.text$mn:00003F6C                 mov     eax, [ebp+var_10]
.text$mn:00003F6F                 mov     ecx, [ebp+var_C]
.text$mn:00003F72                 mov     large fs:0, ecx
.text$mn:00003F79                 pop     ecx
.text$mn:00003F7A                 mov     esp, ebp
.text$mn:00003F7C                 pop     ebp
.text$mn:00003F7D                 retn
.text$mn:00003F7D ??0?$_Iterator012@Urandom_access_iterator_tag@std@@UFunctionValues@@HPBU3@ABU3@U_Iterator_base12@2@@std@@QAE@XZ endp
.text$mn:00003F7D
.text$mn:00003F7D ; ---------------------------------------------------------------------------
.text$mn:00003F7E                 align 10h
.text$mn:00003F7E _text$mn        ends
.text$mn:00003F7E
.text$x:00003F80 ; ===========================================================================
.text$x:00003F80
.text$x:00003F80 ; Segment type: Pure code
.text$x:00003F80 ; Segment permissions: Read/Execute
.text$x:00003F80 _text$x         segment para public 'CODE' use32
.text$x:00003F80                 assume cs:_text$x
.text$x:00003F80                 ;org 3F80h
.text$x:00003F80 ; COMDAT (pick associative to section at 3F30)
.text$x:00003F80                 assume es:nothing, ss:nothing, ds:_data, fs:nothing, gs:nothing
.text$x:00003F80
.text$x:00003F80 ; =============== S U B R O U T I N E =======================================
.text$x:00003F80
.text$x:00003F80
.text$x:00003F80 __unwindfunclet$??0?$_Iterator012@Urandom_access_iterator_tag@std@@UFunctionValues@@HPBU3@ABU3@U_Iterator_base12@2@@std@@QAE@XZ$0 proc near
.text$x:00003F80                                         ; DATA XREF: .xdata$x:00009D30o
.text$x:00003F80                 mov     ecx, [ebp-10h]  ; this
.text$x:00003F83                 jmp     ??1_Iterator_base12@std@@QAE@XZ ; std::_Iterator_base12::~_Iterator_base12(void)
.text$x:00003F83 __unwindfunclet$??0?$_Iterator012@Urandom_access_iterator_tag@std@@UFunctionValues@@HPBU3@ABU3@U_Iterator_base12@2@@std@@QAE@XZ$0 endp
.text$x:00003F83
.text$x:00003F88
.text$x:00003F88 ; =============== S U B R O U T I N E =======================================
.text$x:00003F88
.text$x:00003F88
.text$x:00003F88 __ehhandler$??0?$_Iterator012@Urandom_access_iterator_tag@std@@UFunctionValues@@HPBU3@ABU3@U_Iterator_base12@2@@std@@QAE@XZ proc near
.text$x:00003F88                                         ; DATA XREF: std::_Iterator012<std::random_access_iterator_tag,FunctionValues,int,FunctionValues const *,FunctionValues const &,std::_Iterator_base12>::_Iterator012<std::random_access_iterator_tag,FunctionValues,int,FunctionValues const *,FunctionValues const &,std::_Iterator_base12>(void)+5o
.text$x:00003F88
.text$x:00003F88 arg_4           = dword ptr  8
.text$x:00003F88
.text$x:00003F88                 mov     edx, [esp+arg_4]
.text$x:00003F8C                 lea     eax, [edx+0Ch]
.text$x:00003F8F                 mov     ecx, [edx-8]
.text$x:00003F92                 xor     ecx, eax
.text$x:00003F94                 call    @__security_check_cookie@4 ; __security_check_cookie(x)
.text$x:00003F99                 mov     eax, offset __ehfuncinfo$??0?$_Iterator012@Urandom_access_iterator_tag@std@@UFunctionValues@@HPBU3@ABU3@U_Iterator_base12@2@@std@@QAE@XZ
.text$x:00003F9E                 jmp     ___CxxFrameHandler3
.text$x:00003F9E __ehhandler$??0?$_Iterator012@Urandom_access_iterator_tag@std@@UFunctionValues@@HPBU3@ABU3@U_Iterator_base12@2@@std@@QAE@XZ endp
.text$x:00003F9E
.text$x:00003F9E ; ---------------------------------------------------------------------------
.text$x:00003FA3                 align 4
.text$x:00003FA3 _text$x         ends
.text$x:00003FA3
.text$mn:00003FA4 ; ===========================================================================
.text$mn:00003FA4
.text$mn:00003FA4 ; Segment type: Pure code
.text$mn:00003FA4 ; Segment permissions: Read/Execute
.text$mn:00003FA4 _text$mn        segment para public 'CODE' use32
.text$mn:00003FA4                 assume cs:_text$mn
.text$mn:00003FA4                 ;org 3FA4h
.text$mn:00003FA4 ; COMDAT (pick any)
.text$mn:00003FA4                 assume es:nothing, ss:nothing, ds:_data, fs:nothing, gs:nothing
.text$mn:00003FA4
.text$mn:00003FA4 ; =============== S U B R O U T I N E =======================================
.text$mn:00003FA4
.text$mn:00003FA4 ; Attributes: bp-based frame
.text$mn:00003FA4
.text$mn:00003FA4 ; public: __thiscall std::_String_alloc<0, struct std::_String_base_types<char, class std::allocator<char>>>::_String_alloc<0, struct std::_String_base_types<char, class std::allocator<char>>>(class std::allocator<char> const &)
.text$mn:00003FA4                 public ??0?$_String_alloc@$0A@U?$_String_base_types@DV?$allocator@D@std@@@std@@@std@@QAE@ABV?$allocator@D@1@@Z
.text$mn:00003FA4 ??0?$_String_alloc@$0A@U?$_String_base_types@DV?$allocator@D@std@@@std@@@std@@QAE@ABV?$allocator@D@1@@Z proc near
.text$mn:00003FA4                                         ; CODE XREF: std::basic_string<char,std::char_traits<char>,std::allocator<char>>::basic_string<char,std::char_traits<char>,std::allocator<char>>(char const *)+34p
.text$mn:00003FA4
.text$mn:00003FA4 var_10          = dword ptr -10h
.text$mn:00003FA4 var_C           = dword ptr -0Ch
.text$mn:00003FA4 var_4           = dword ptr -4
.text$mn:00003FA4
.text$mn:00003FA4                 push    ebp
.text$mn:00003FA5                 mov     ebp, esp
.text$mn:00003FA7                 push    0FFFFFFFFh
.text$mn:00003FA9                 push    offset __ehhandler$??0?$_String_alloc@$0A@U?$_String_base_types@DV?$allocator@D@std@@@std@@@std@@QAE@ABV?$allocator@D@1@@Z
.text$mn:00003FAE                 mov     eax, large fs:0
.text$mn:00003FB4                 push    eax
.text$mn:00003FB5                 push    ecx
.text$mn:00003FB6                 mov     eax, dword ptr ds:___security_cookie
.text$mn:00003FBB                 xor     eax, ebp
.text$mn:00003FBD                 push    eax
.text$mn:00003FBE                 lea     eax, [ebp+var_C]
.text$mn:00003FC1                 mov     large fs:0, eax
.text$mn:00003FC7                 mov     [ebp+var_10], ecx
.text$mn:00003FCA                 mov     ecx, [ebp+var_10]
.text$mn:00003FCD                 call    ??0?$_String_val@U?$_Simple_types@D@std@@@std@@QAE@XZ ; std::_String_val<std::_Simple_types<char>>::_String_val<std::_Simple_types<char>>(void)
.text$mn:00003FD2                 mov     [ebp+var_4], 0
.text$mn:00003FD9                 mov     ecx, [ebp+var_10]
.text$mn:00003FDC                 call    ?_Alloc_proxy@?$_String_alloc@$0A@U?$_String_base_types@DV?$allocator@D@std@@@std@@@std@@QAEXXZ ; std::_String_alloc<0,std::_String_base_types<char,std::allocator<char>>>::_Alloc_proxy(void)
.text$mn:00003FE1                 mov     [ebp+var_4], 0FFFFFFFFh
.text$mn:00003FE8                 mov     eax, [ebp+var_10]
.text$mn:00003FEB                 mov     ecx, [ebp+var_C]
.text$mn:00003FEE                 mov     large fs:0, ecx
.text$mn:00003FF5                 pop     ecx
.text$mn:00003FF6                 mov     esp, ebp
.text$mn:00003FF8                 pop     ebp
.text$mn:00003FF9                 retn    4
.text$mn:00003FF9 ??0?$_String_alloc@$0A@U?$_String_base_types@DV?$allocator@D@std@@@std@@@std@@QAE@ABV?$allocator@D@1@@Z endp
.text$mn:00003FF9
.text$mn:00003FF9 _text$mn        ends
.text$mn:00003FF9
.text$x:00003FFC ; ===========================================================================
.text$x:00003FFC
.text$x:00003FFC ; Segment type: Pure code
.text$x:00003FFC ; Segment permissions: Read/Execute
.text$x:00003FFC _text$x         segment para public 'CODE' use32
.text$x:00003FFC                 assume cs:_text$x
.text$x:00003FFC                 ;org 3FFCh
.text$x:00003FFC ; COMDAT (pick associative to section at 3FA4)
.text$x:00003FFC                 assume es:nothing, ss:nothing, ds:_data, fs:nothing, gs:nothing
.text$x:00003FFC
.text$x:00003FFC ; =============== S U B R O U T I N E =======================================
.text$x:00003FFC
.text$x:00003FFC
.text$x:00003FFC __unwindfunclet$??0?$_String_alloc@$0A@U?$_String_base_types@DV?$allocator@D@std@@@std@@@std@@QAE@ABV?$allocator@D@1@@Z$0 proc near
.text$x:00003FFC                                         ; DATA XREF: .xdata$x:00009360o
.text$x:00003FFC                 mov     ecx, [ebp-10h]
.text$x:00003FFF                 jmp     ??1?$_String_val@U?$_Simple_types@D@std@@@std@@QAE@XZ ; std::_String_val<std::_Simple_types<char>>::~_String_val<std::_Simple_types<char>>(void)
.text$x:00003FFF __unwindfunclet$??0?$_String_alloc@$0A@U?$_String_base_types@DV?$allocator@D@std@@@std@@@std@@QAE@ABV?$allocator@D@1@@Z$0 endp
.text$x:00003FFF
.text$x:00004004
.text$x:00004004 ; =============== S U B R O U T I N E =======================================
.text$x:00004004
.text$x:00004004
.text$x:00004004 __ehhandler$??0?$_String_alloc@$0A@U?$_String_base_types@DV?$allocator@D@std@@@std@@@std@@QAE@ABV?$allocator@D@1@@Z proc near
.text$x:00004004                                         ; DATA XREF: std::_String_alloc<0,std::_String_base_types<char,std::allocator<char>>>::_String_alloc<0,std::_String_base_types<char,std::allocator<char>>>(std::allocator<char> const &)+5o
.text$x:00004004
.text$x:00004004 arg_4           = dword ptr  8
.text$x:00004004
.text$x:00004004                 mov     edx, [esp+arg_4]
.text$x:00004008                 lea     eax, [edx+0Ch]
.text$x:0000400B                 mov     ecx, [edx-8]
.text$x:0000400E                 xor     ecx, eax
.text$x:00004010                 call    @__security_check_cookie@4 ; __security_check_cookie(x)
.text$x:00004015                 mov     eax, offset __ehfuncinfo$??0?$_String_alloc@$0A@U?$_String_base_types@DV?$allocator@D@std@@@std@@@std@@QAE@ABV?$allocator@D@1@@Z
.text$x:0000401A                 jmp     ___CxxFrameHandler3
.text$x:0000401A __ehhandler$??0?$_String_alloc@$0A@U?$_String_base_types@DV?$allocator@D@std@@@std@@@std@@QAE@ABV?$allocator@D@1@@Z endp
.text$x:0000401A
.text$x:0000401A ; ---------------------------------------------------------------------------
.text$x:0000401F                 align 10h
.text$x:0000401F _text$x         ends
.text$x:0000401F
.text$mn:00004020 ; ===========================================================================
.text$mn:00004020
.text$mn:00004020 ; Segment type: Pure code
.text$mn:00004020 ; Segment permissions: Read/Execute
.text$mn:00004020 _text$mn        segment para public 'CODE' use32
.text$mn:00004020                 assume cs:_text$mn
.text$mn:00004020                 ;org 4020h
.text$mn:00004020 ; COMDAT (pick any)
.text$mn:00004020                 assume es:nothing, ss:nothing, ds:_data, fs:nothing, gs:nothing
.text$mn:00004020
.text$mn:00004020 ; =============== S U B R O U T I N E =======================================
.text$mn:00004020
.text$mn:00004020 ; Attributes: bp-based frame
.text$mn:00004020
.text$mn:00004020 ; public: __thiscall std::_String_val<struct std::_Simple_types<char>>::_String_val<struct std::_Simple_types<char>>(void)
.text$mn:00004020                 public ??0?$_String_val@U?$_Simple_types@D@std@@@std@@QAE@XZ
.text$mn:00004020 ??0?$_String_val@U?$_Simple_types@D@std@@@std@@QAE@XZ proc near
.text$mn:00004020                                         ; CODE XREF: std::_String_alloc<0,std::_String_base_types<char,std::allocator<char>>>::_String_alloc<0,std::_String_base_types<char,std::allocator<char>>>(std::allocator<char> const &)+29p
.text$mn:00004020
.text$mn:00004020 var_10          = dword ptr -10h
.text$mn:00004020 var_C           = dword ptr -0Ch
.text$mn:00004020 var_4           = dword ptr -4
.text$mn:00004020
.text$mn:00004020                 push    ebp
.text$mn:00004021                 mov     ebp, esp
.text$mn:00004023                 push    0FFFFFFFFh
.text$mn:00004025                 push    offset __ehhandler$??0?$_String_val@U?$_Simple_types@D@std@@@std@@QAE@XZ
.text$mn:0000402A                 mov     eax, large fs:0
.text$mn:00004030                 push    eax
.text$mn:00004031                 push    ecx
.text$mn:00004032                 mov     eax, dword ptr ds:___security_cookie
.text$mn:00004037                 xor     eax, ebp
.text$mn:00004039                 push    eax
.text$mn:0000403A                 lea     eax, [ebp+var_C]
.text$mn:0000403D                 mov     large fs:0, eax
.text$mn:00004043                 mov     [ebp+var_10], ecx
.text$mn:00004046                 mov     ecx, [ebp+var_10] ; this
.text$mn:00004049                 call    ??0_Container_base12@std@@QAE@XZ ; std::_Container_base12::_Container_base12(void)
.text$mn:0000404E                 mov     [ebp+var_4], 0
.text$mn:00004055                 mov     eax, [ebp+var_10]
.text$mn:00004058                 mov     dword ptr [eax+14h], 0
.text$mn:0000405F                 mov     ecx, [ebp+var_10]
.text$mn:00004062                 mov     dword ptr [ecx+18h], 0
.text$mn:00004069                 mov     [ebp+var_4], 0FFFFFFFFh
.text$mn:00004070                 mov     eax, [ebp+var_10]
.text$mn:00004073                 mov     ecx, [ebp+var_C]
.text$mn:00004076                 mov     large fs:0, ecx
.text$mn:0000407D                 pop     ecx
.text$mn:0000407E                 mov     esp, ebp
.text$mn:00004080                 pop     ebp
.text$mn:00004081                 retn
.text$mn:00004081 ??0?$_String_val@U?$_Simple_types@D@std@@@std@@QAE@XZ endp
.text$mn:00004081
.text$mn:00004081 ; ---------------------------------------------------------------------------
.text$mn:00004082                 align 4
.text$mn:00004082 _text$mn        ends
.text$mn:00004082
.text$x:00004084 ; ===========================================================================
.text$x:00004084
.text$x:00004084 ; Segment type: Pure code
.text$x:00004084 ; Segment permissions: Read/Execute
.text$x:00004084 _text$x         segment para public 'CODE' use32
.text$x:00004084                 assume cs:_text$x
.text$x:00004084                 ;org 4084h
.text$x:00004084 ; COMDAT (pick associative to section at 4020)
.text$x:00004084                 assume es:nothing, ss:nothing, ds:_data, fs:nothing, gs:nothing
.text$x:00004084
.text$x:00004084 ; =============== S U B R O U T I N E =======================================
.text$x:00004084
.text$x:00004084
.text$x:00004084 __unwindfunclet$??0?$_String_val@U?$_Simple_types@D@std@@@std@@QAE@XZ$0 proc near
.text$x:00004084                                         ; DATA XREF: .xdata$x:00009308o
.text$x:00004084                 mov     ecx, [ebp-10h]  ; this
.text$x:00004087                 jmp     ??1_Container_base12@std@@QAE@XZ ; std::_Container_base12::~_Container_base12(void)
.text$x:00004087 __unwindfunclet$??0?$_String_val@U?$_Simple_types@D@std@@@std@@QAE@XZ$0 endp
.text$x:00004087
.text$x:0000408C
.text$x:0000408C ; =============== S U B R O U T I N E =======================================
.text$x:0000408C
.text$x:0000408C
.text$x:0000408C __ehhandler$??0?$_String_val@U?$_Simple_types@D@std@@@std@@QAE@XZ proc near
.text$x:0000408C                                         ; DATA XREF: std::_String_val<std::_Simple_types<char>>::_String_val<std::_Simple_types<char>>(void)+5o
.text$x:0000408C
.text$x:0000408C arg_4           = dword ptr  8
.text$x:0000408C
.text$x:0000408C                 mov     edx, [esp+arg_4]
.text$x:00004090                 lea     eax, [edx+0Ch]
.text$x:00004093                 mov     ecx, [edx-8]
.text$x:00004096                 xor     ecx, eax
.text$x:00004098                 call    @__security_check_cookie@4 ; __security_check_cookie(x)
.text$x:0000409D                 mov     eax, offset __ehfuncinfo$??0?$_String_val@U?$_Simple_types@D@std@@@std@@QAE@XZ
.text$x:000040A2                 jmp     ___CxxFrameHandler3
.text$x:000040A2 __ehhandler$??0?$_String_val@U?$_Simple_types@D@std@@@std@@QAE@XZ endp
.text$x:000040A2
.text$x:000040A2 ; ---------------------------------------------------------------------------
.text$x:000040A7                 align 4
.text$x:000040A7 _text$x         ends
.text$x:000040A7
.text$mn:000040A8 ; ===========================================================================
.text$mn:000040A8
.text$mn:000040A8 ; Segment type: Pure code
.text$mn:000040A8 ; Segment permissions: Read/Execute
.text$mn:000040A8 _text$mn        segment para public 'CODE' use32
.text$mn:000040A8                 assume cs:_text$mn
.text$mn:000040A8                 ;org 40A8h
.text$mn:000040A8 ; COMDAT (pick any)
.text$mn:000040A8                 assume es:nothing, ss:nothing, ds:_data, fs:nothing, gs:nothing
.text$mn:000040A8
.text$mn:000040A8 ; =============== S U B R O U T I N E =======================================
.text$mn:000040A8
.text$mn:000040A8 ; Attributes: bp-based frame
.text$mn:000040A8
.text$mn:000040A8 ; public: __thiscall std::_Vector_alloc<0, struct std::_Vec_base_types<wchar_t const *, class std::allocator<wchar_t const *>>>::_Vector_alloc<0, struct std::_Vec_base_types<wchar_t const *, class std::allocator<wchar_t const *>>>(class std::allocator<wchar_t const *> const &)
.text$mn:000040A8                 public ??0?$_Vector_alloc@$0A@U?$_Vec_base_types@PB_WV?$allocator@PB_W@std@@@std@@@std@@QAE@ABV?$allocator@PB_W@1@@Z
.text$mn:000040A8 ??0?$_Vector_alloc@$0A@U?$_Vec_base_types@PB_WV?$allocator@PB_W@std@@@std@@@std@@QAE@ABV?$allocator@PB_W@1@@Z proc near
.text$mn:000040A8                                         ; CODE XREF: std::vector<wchar_t const *,std::allocator<wchar_t const *>>::vector<wchar_t const *,std::allocator<wchar_t const *>>(std::vector<wchar_t const *,std::allocator<wchar_t const *>> &&)+38p
.text$mn:000040A8                                         ; std::vector<wchar_t const *,std::allocator<wchar_t const *>>::vector<wchar_t const *,std::allocator<wchar_t const *>>(std::vector<wchar_t const *,std::allocator<wchar_t const *>> const &)+4Ap ...
.text$mn:000040A8
.text$mn:000040A8 var_10          = dword ptr -10h
.text$mn:000040A8 var_C           = dword ptr -0Ch
.text$mn:000040A8 var_4           = dword ptr -4
.text$mn:000040A8
.text$mn:000040A8                 push    ebp
.text$mn:000040A9                 mov     ebp, esp
.text$mn:000040AB                 push    0FFFFFFFFh
.text$mn:000040AD                 push    offset __ehhandler$??0?$_Vector_alloc@$0A@U?$_Vec_base_types@PB_WV?$allocator@PB_W@std@@@std@@@std@@QAE@ABV?$allocator@PB_W@1@@Z
.text$mn:000040B2                 mov     eax, large fs:0
.text$mn:000040B8                 push    eax
.text$mn:000040B9                 push    ecx
.text$mn:000040BA                 mov     eax, dword ptr ds:___security_cookie
.text$mn:000040BF                 xor     eax, ebp
.text$mn:000040C1                 push    eax
.text$mn:000040C2                 lea     eax, [ebp+var_C]
.text$mn:000040C5                 mov     large fs:0, eax
.text$mn:000040CB                 mov     [ebp+var_10], ecx
.text$mn:000040CE                 mov     ecx, [ebp+var_10]
.text$mn:000040D1                 call    ??0?$_Vector_val@U?$_Simple_types@PB_W@std@@@std@@QAE@XZ ; std::_Vector_val<std::_Simple_types<wchar_t const *>>::_Vector_val<std::_Simple_types<wchar_t const *>>(void)
.text$mn:000040D6                 mov     [ebp+var_4], 0
.text$mn:000040DD                 mov     ecx, [ebp+var_10]
.text$mn:000040E0                 call    ?_Alloc_proxy@?$_Vector_alloc@$0A@U?$_Vec_base_types@PB_WV?$allocator@PB_W@std@@@std@@@std@@QAEXXZ ; std::_Vector_alloc<0,std::_Vec_base_types<wchar_t const *,std::allocator<wchar_t const *>>>::_Alloc_proxy(void)
.text$mn:000040E5                 mov     [ebp+var_4], 0FFFFFFFFh
.text$mn:000040EC                 mov     eax, [ebp+var_10]
.text$mn:000040EF                 mov     ecx, [ebp+var_C]
.text$mn:000040F2                 mov     large fs:0, ecx
.text$mn:000040F9                 pop     ecx
.text$mn:000040FA                 mov     esp, ebp
.text$mn:000040FC                 pop     ebp
.text$mn:000040FD                 retn    4
.text$mn:000040FD ??0?$_Vector_alloc@$0A@U?$_Vec_base_types@PB_WV?$allocator@PB_W@std@@@std@@@std@@QAE@ABV?$allocator@PB_W@1@@Z endp
.text$mn:000040FD
.text$mn:000040FD _text$mn        ends
.text$mn:000040FD
.text$x:00004100 ; ===========================================================================
.text$x:00004100
.text$x:00004100 ; Segment type: Pure code
.text$x:00004100 ; Segment permissions: Read/Execute
.text$x:00004100 _text$x         segment para public 'CODE' use32
.text$x:00004100                 assume cs:_text$x
.text$x:00004100                 ;org 4100h
.text$x:00004100 ; COMDAT (pick associative to section at 40A8)
.text$x:00004100                 assume es:nothing, ss:nothing, ds:_data, fs:nothing, gs:nothing
.text$x:00004100
.text$x:00004100 ; =============== S U B R O U T I N E =======================================
.text$x:00004100
.text$x:00004100
.text$x:00004100 __unwindfunclet$??0?$_Vector_alloc@$0A@U?$_Vec_base_types@PB_WV?$allocator@PB_W@std@@@std@@@std@@QAE@ABV?$allocator@PB_W@1@@Z$0 proc near
.text$x:00004100                                         ; DATA XREF: .xdata$x:00009680o
.text$x:00004100                 mov     ecx, [ebp-10h]
.text$x:00004103                 jmp     ??1?$_Vector_val@U?$_Simple_types@PB_W@std@@@std@@QAE@XZ ; std::_Vector_val<std::_Simple_types<wchar_t const *>>::~_Vector_val<std::_Simple_types<wchar_t const *>>(void)
.text$x:00004103 __unwindfunclet$??0?$_Vector_alloc@$0A@U?$_Vec_base_types@PB_WV?$allocator@PB_W@std@@@std@@@std@@QAE@ABV?$allocator@PB_W@1@@Z$0 endp
.text$x:00004103
.text$x:00004108
.text$x:00004108 ; =============== S U B R O U T I N E =======================================
.text$x:00004108
.text$x:00004108
.text$x:00004108 __ehhandler$??0?$_Vector_alloc@$0A@U?$_Vec_base_types@PB_WV?$allocator@PB_W@std@@@std@@@std@@QAE@ABV?$allocator@PB_W@1@@Z proc near
.text$x:00004108                                         ; DATA XREF: std::_Vector_alloc<0,std::_Vec_base_types<wchar_t const *,std::allocator<wchar_t const *>>>::_Vector_alloc<0,std::_Vec_base_types<wchar_t const *,std::allocator<wchar_t const *>>>(std::allocator<wchar_t const *> const &)+5o
.text$x:00004108
.text$x:00004108 arg_4           = dword ptr  8
.text$x:00004108
.text$x:00004108                 mov     edx, [esp+arg_4]
.text$x:0000410C                 lea     eax, [edx+0Ch]
.text$x:0000410F                 mov     ecx, [edx-8]
.text$x:00004112                 xor     ecx, eax
.text$x:00004114                 call    @__security_check_cookie@4 ; __security_check_cookie(x)
.text$x:00004119                 mov     eax, offset __ehfuncinfo$??0?$_Vector_alloc@$0A@U?$_Vec_base_types@PB_WV?$allocator@PB_W@std@@@std@@@std@@QAE@ABV?$allocator@PB_W@1@@Z
.text$x:0000411E                 jmp     ___CxxFrameHandler3
.text$x:0000411E __ehhandler$??0?$_Vector_alloc@$0A@U?$_Vec_base_types@PB_WV?$allocator@PB_W@std@@@std@@@std@@QAE@ABV?$allocator@PB_W@1@@Z endp
.text$x:0000411E
.text$x:0000411E ; ---------------------------------------------------------------------------
.text$x:00004123                 align 4
.text$x:00004123 _text$x         ends
.text$x:00004123
.text$mn:00004124 ; ===========================================================================
.text$mn:00004124
.text$mn:00004124 ; Segment type: Pure code
.text$mn:00004124 ; Segment permissions: Read/Execute
.text$mn:00004124 _text$mn        segment para public 'CODE' use32
.text$mn:00004124                 assume cs:_text$mn
.text$mn:00004124                 ;org 4124h
.text$mn:00004124 ; COMDAT (pick any)
.text$mn:00004124                 assume es:nothing, ss:nothing, ds:_data, fs:nothing, gs:nothing
.text$mn:00004124
.text$mn:00004124 ; =============== S U B R O U T I N E =======================================
.text$mn:00004124
.text$mn:00004124 ; Attributes: bp-based frame
.text$mn:00004124
.text$mn:00004124 ; public: __thiscall std::_Vector_alloc<0, struct std::_Vec_base_types<struct FunctionValues, class std::allocator<struct FunctionValues>>>::_Vector_alloc<0, struct std::_Vec_base_types<struct FunctionValues, class std::allocator<struct FunctionValues>>>(class std::allocator<struct FunctionValues> const &)
.text$mn:00004124                 public ??0?$_Vector_alloc@$0A@U?$_Vec_base_types@UFunctionValues@@V?$allocator@UFunctionValues@@@std@@@std@@@std@@QAE@ABV?$allocator@UFunctionValues@@@1@@Z
.text$mn:00004124 ??0?$_Vector_alloc@$0A@U?$_Vec_base_types@UFunctionValues@@V?$allocator@UFunctionValues@@@std@@@std@@@std@@QAE@ABV?$allocator@UFunctionValues@@@1@@Z proc near
.text$mn:00004124                                         ; CODE XREF: std::vector<FunctionValues,std::allocator<FunctionValues>>::vector<FunctionValues,std::allocator<FunctionValues>>(void)+34p
.text$mn:00004124
.text$mn:00004124 var_10          = dword ptr -10h
.text$mn:00004124 var_C           = dword ptr -0Ch
.text$mn:00004124 var_4           = dword ptr -4
.text$mn:00004124
.text$mn:00004124                 push    ebp
.text$mn:00004125                 mov     ebp, esp
.text$mn:00004127                 push    0FFFFFFFFh
.text$mn:00004129                 push    offset __ehhandler$??0?$_Vector_alloc@$0A@U?$_Vec_base_types@UFunctionValues@@V?$allocator@UFunctionValues@@@std@@@std@@@std@@QAE@ABV?$allocator@UFunctionValues@@@1@@Z
.text$mn:0000412E                 mov     eax, large fs:0
.text$mn:00004134                 push    eax
.text$mn:00004135                 push    ecx
.text$mn:00004136                 mov     eax, dword ptr ds:___security_cookie
.text$mn:0000413B                 xor     eax, ebp
.text$mn:0000413D                 push    eax
.text$mn:0000413E                 lea     eax, [ebp+var_C]
.text$mn:00004141                 mov     large fs:0, eax
.text$mn:00004147                 mov     [ebp+var_10], ecx
.text$mn:0000414A                 mov     ecx, [ebp+var_10]
.text$mn:0000414D                 call    ??0?$_Vector_val@U?$_Simple_types@UFunctionValues@@@std@@@std@@QAE@XZ ; std::_Vector_val<std::_Simple_types<FunctionValues>>::_Vector_val<std::_Simple_types<FunctionValues>>(void)
.text$mn:00004152                 mov     [ebp+var_4], 0
.text$mn:00004159                 mov     ecx, [ebp+var_10]
.text$mn:0000415C                 call    ?_Alloc_proxy@?$_Vector_alloc@$0A@U?$_Vec_base_types@UFunctionValues@@V?$allocator@UFunctionValues@@@std@@@std@@@std@@QAEXXZ ; std::_Vector_alloc<0,std::_Vec_base_types<FunctionValues,std::allocator<FunctionValues>>>::_Alloc_proxy(void)
.text$mn:00004161                 mov     [ebp+var_4], 0FFFFFFFFh
.text$mn:00004168                 mov     eax, [ebp+var_10]
.text$mn:0000416B                 mov     ecx, [ebp+var_C]
.text$mn:0000416E                 mov     large fs:0, ecx
.text$mn:00004175                 pop     ecx
.text$mn:00004176                 mov     esp, ebp
.text$mn:00004178                 pop     ebp
.text$mn:00004179                 retn    4
.text$mn:00004179 ??0?$_Vector_alloc@$0A@U?$_Vec_base_types@UFunctionValues@@V?$allocator@UFunctionValues@@@std@@@std@@@std@@QAE@ABV?$allocator@UFunctionValues@@@1@@Z endp
.text$mn:00004179
.text$mn:00004179 _text$mn        ends
.text$mn:00004179
.text$x:0000417C ; ===========================================================================
.text$x:0000417C
.text$x:0000417C ; Segment type: Pure code
.text$x:0000417C ; Segment permissions: Read/Execute
.text$x:0000417C _text$x         segment para public 'CODE' use32
.text$x:0000417C                 assume cs:_text$x
.text$x:0000417C                 ;org 417Ch
.text$x:0000417C ; COMDAT (pick associative to section at 4124)
.text$x:0000417C                 assume es:nothing, ss:nothing, ds:_data, fs:nothing, gs:nothing
.text$x:0000417C
.text$x:0000417C ; =============== S U B R O U T I N E =======================================
.text$x:0000417C
.text$x:0000417C
.text$x:0000417C __unwindfunclet$??0?$_Vector_alloc@$0A@U?$_Vec_base_types@UFunctionValues@@V?$allocator@UFunctionValues@@@std@@@std@@@std@@QAE@ABV?$allocator@UFunctionValues@@@1@@Z$0 proc near
.text$x:0000417C                                         ; DATA XREF: .xdata$x:00009B9Co
.text$x:0000417C                 mov     ecx, [ebp-10h]
.text$x:0000417F                 jmp     ??1?$_Vector_val@U?$_Simple_types@UFunctionValues@@@std@@@std@@QAE@XZ ; std::_Vector_val<std::_Simple_types<FunctionValues>>::~_Vector_val<std::_Simple_types<FunctionValues>>(void)
.text$x:0000417F __unwindfunclet$??0?$_Vector_alloc@$0A@U?$_Vec_base_types@UFunctionValues@@V?$allocator@UFunctionValues@@@std@@@std@@@std@@QAE@ABV?$allocator@UFunctionValues@@@1@@Z$0 endp
.text$x:0000417F
.text$x:00004184
.text$x:00004184 ; =============== S U B R O U T I N E =======================================
.text$x:00004184
.text$x:00004184
.text$x:00004184 __ehhandler$??0?$_Vector_alloc@$0A@U?$_Vec_base_types@UFunctionValues@@V?$allocator@UFunctionValues@@@std@@@std@@@std@@QAE@ABV?$allocator@UFunctionValues@@@1@@Z proc near
.text$x:00004184                                         ; DATA XREF: std::_Vector_alloc<0,std::_Vec_base_types<FunctionValues,std::allocator<FunctionValues>>>::_Vector_alloc<0,std::_Vec_base_types<FunctionValues,std::allocator<FunctionValues>>>(std::allocator<FunctionValues> const &)+5o
.text$x:00004184
.text$x:00004184 arg_4           = dword ptr  8
.text$x:00004184
.text$x:00004184                 mov     edx, [esp+arg_4]
.text$x:00004188                 lea     eax, [edx+0Ch]
.text$x:0000418B                 mov     ecx, [edx-8]
.text$x:0000418E                 xor     ecx, eax
.text$x:00004190                 call    @__security_check_cookie@4 ; __security_check_cookie(x)
.text$x:00004195                 mov     eax, offset __ehfuncinfo$??0?$_Vector_alloc@$0A@U?$_Vec_base_types@UFunctionValues@@V?$allocator@UFunctionValues@@@std@@@std@@@std@@QAE@ABV?$allocator@UFunctionValues@@@1@@Z
.text$x:0000419A                 jmp     ___CxxFrameHandler3
.text$x:0000419A __ehhandler$??0?$_Vector_alloc@$0A@U?$_Vec_base_types@UFunctionValues@@V?$allocator@UFunctionValues@@@std@@@std@@@std@@QAE@ABV?$allocator@UFunctionValues@@@1@@Z endp
.text$x:0000419A
.text$x:0000419A ; ---------------------------------------------------------------------------
.text$x:0000419F                 align 10h
.text$x:0000419F _text$x         ends
.text$x:0000419F
.text$mn:000041A0 ; ===========================================================================
.text$mn:000041A0
.text$mn:000041A0 ; Segment type: Pure code
.text$mn:000041A0 ; Segment permissions: Read/Execute
.text$mn:000041A0 _text$mn        segment para public 'CODE' use32
.text$mn:000041A0                 assume cs:_text$mn
.text$mn:000041A0                 ;org 41A0h
.text$mn:000041A0 ; COMDAT (pick any)
.text$mn:000041A0                 assume es:nothing, ss:nothing, ds:_data, fs:nothing, gs:nothing
.text$mn:000041A0
.text$mn:000041A0 ; =============== S U B R O U T I N E =======================================
.text$mn:000041A0
.text$mn:000041A0 ; Attributes: bp-based frame
.text$mn:000041A0
.text$mn:000041A0 ; public: __thiscall std::_Vector_alloc<0, struct std::_Vec_base_types<struct Token, class std::allocator<struct Token>>>::_Vector_alloc<0, struct std::_Vec_base_types<struct Token, class std::allocator<struct Token>>>(class std::allocator<struct Token> const &)
.text$mn:000041A0                 public ??0?$_Vector_alloc@$0A@U?$_Vec_base_types@UToken@@V?$allocator@UToken@@@std@@@std@@@std@@QAE@ABV?$allocator@UToken@@@1@@Z
.text$mn:000041A0 ??0?$_Vector_alloc@$0A@U?$_Vec_base_types@UToken@@V?$allocator@UToken@@@std@@@std@@@std@@QAE@ABV?$allocator@UToken@@@1@@Z proc near
.text$mn:000041A0                                         ; CODE XREF: std::vector<Token,std::allocator<Token>>::vector<Token,std::allocator<Token>>(void)+34p
.text$mn:000041A0
.text$mn:000041A0 var_10          = dword ptr -10h
.text$mn:000041A0 var_C           = dword ptr -0Ch
.text$mn:000041A0 var_4           = dword ptr -4
.text$mn:000041A0
.text$mn:000041A0                 push    ebp
.text$mn:000041A1                 mov     ebp, esp
.text$mn:000041A3                 push    0FFFFFFFFh
.text$mn:000041A5                 push    offset __ehhandler$??0?$_Vector_alloc@$0A@U?$_Vec_base_types@UToken@@V?$allocator@UToken@@@std@@@std@@@std@@QAE@ABV?$allocator@UToken@@@1@@Z
.text$mn:000041AA                 mov     eax, large fs:0
.text$mn:000041B0                 push    eax
.text$mn:000041B1                 push    ecx
.text$mn:000041B2                 mov     eax, dword ptr ds:___security_cookie
.text$mn:000041B7                 xor     eax, ebp
.text$mn:000041B9                 push    eax
.text$mn:000041BA                 lea     eax, [ebp+var_C]
.text$mn:000041BD                 mov     large fs:0, eax
.text$mn:000041C3                 mov     [ebp+var_10], ecx
.text$mn:000041C6                 mov     ecx, [ebp+var_10]
.text$mn:000041C9                 call    ??0?$_Vector_val@U?$_Simple_types@UToken@@@std@@@std@@QAE@XZ ; std::_Vector_val<std::_Simple_types<Token>>::_Vector_val<std::_Simple_types<Token>>(void)
.text$mn:000041CE                 mov     [ebp+var_4], 0
.text$mn:000041D5                 mov     ecx, [ebp+var_10]
.text$mn:000041D8                 call    ?_Alloc_proxy@?$_Vector_alloc@$0A@U?$_Vec_base_types@UToken@@V?$allocator@UToken@@@std@@@std@@@std@@QAEXXZ ; std::_Vector_alloc<0,std::_Vec_base_types<Token,std::allocator<Token>>>::_Alloc_proxy(void)
.text$mn:000041DD                 mov     [ebp+var_4], 0FFFFFFFFh
.text$mn:000041E4                 mov     eax, [ebp+var_10]
.text$mn:000041E7                 mov     ecx, [ebp+var_C]
.text$mn:000041EA                 mov     large fs:0, ecx
.text$mn:000041F1                 pop     ecx
.text$mn:000041F2                 mov     esp, ebp
.text$mn:000041F4                 pop     ebp
.text$mn:000041F5                 retn    4
.text$mn:000041F5 ??0?$_Vector_alloc@$0A@U?$_Vec_base_types@UToken@@V?$allocator@UToken@@@std@@@std@@@std@@QAE@ABV?$allocator@UToken@@@1@@Z endp
.text$mn:000041F5
.text$mn:000041F5 _text$mn        ends
.text$mn:000041F5
.text$x:000041F8 ; ===========================================================================
.text$x:000041F8
.text$x:000041F8 ; Segment type: Pure code
.text$x:000041F8 ; Segment permissions: Read/Execute
.text$x:000041F8 _text$x         segment para public 'CODE' use32
.text$x:000041F8                 assume cs:_text$x
.text$x:000041F8                 ;org 41F8h
.text$x:000041F8 ; COMDAT (pick associative to section at 41A0)
.text$x:000041F8                 assume es:nothing, ss:nothing, ds:_data, fs:nothing, gs:nothing
.text$x:000041F8
.text$x:000041F8 ; =============== S U B R O U T I N E =======================================
.text$x:000041F8
.text$x:000041F8
.text$x:000041F8 __unwindfunclet$??0?$_Vector_alloc@$0A@U?$_Vec_base_types@UToken@@V?$allocator@UToken@@@std@@@std@@@std@@QAE@ABV?$allocator@UToken@@@1@@Z$0 proc near
.text$x:000041F8                                         ; DATA XREF: .xdata$x:00009A10o
.text$x:000041F8                 mov     ecx, [ebp-10h]
.text$x:000041FB                 jmp     ??1?$_Vector_val@U?$_Simple_types@UToken@@@std@@@std@@QAE@XZ ; std::_Vector_val<std::_Simple_types<Token>>::~_Vector_val<std::_Simple_types<Token>>(void)
.text$x:000041FB __unwindfunclet$??0?$_Vector_alloc@$0A@U?$_Vec_base_types@UToken@@V?$allocator@UToken@@@std@@@std@@@std@@QAE@ABV?$allocator@UToken@@@1@@Z$0 endp
.text$x:000041FB
.text$x:00004200
.text$x:00004200 ; =============== S U B R O U T I N E =======================================
.text$x:00004200
.text$x:00004200
.text$x:00004200 __ehhandler$??0?$_Vector_alloc@$0A@U?$_Vec_base_types@UToken@@V?$allocator@UToken@@@std@@@std@@@std@@QAE@ABV?$allocator@UToken@@@1@@Z proc near
.text$x:00004200                                         ; DATA XREF: std::_Vector_alloc<0,std::_Vec_base_types<Token,std::allocator<Token>>>::_Vector_alloc<0,std::_Vec_base_types<Token,std::allocator<Token>>>(std::allocator<Token> const &)+5o
.text$x:00004200
.text$x:00004200 arg_4           = dword ptr  8
.text$x:00004200
.text$x:00004200                 mov     edx, [esp+arg_4]
.text$x:00004204                 lea     eax, [edx+0Ch]
.text$x:00004207                 mov     ecx, [edx-8]
.text$x:0000420A                 xor     ecx, eax
.text$x:0000420C                 call    @__security_check_cookie@4 ; __security_check_cookie(x)
.text$x:00004211                 mov     eax, offset __ehfuncinfo$??0?$_Vector_alloc@$0A@U?$_Vec_base_types@UToken@@V?$allocator@UToken@@@std@@@std@@@std@@QAE@ABV?$allocator@UToken@@@1@@Z
.text$x:00004216                 jmp     ___CxxFrameHandler3
.text$x:00004216 __ehhandler$??0?$_Vector_alloc@$0A@U?$_Vec_base_types@UToken@@V?$allocator@UToken@@@std@@@std@@@std@@QAE@ABV?$allocator@UToken@@@1@@Z endp
.text$x:00004216
.text$x:00004216 ; ---------------------------------------------------------------------------
.text$x:0000421B                 align 4
.text$x:0000421B _text$x         ends
.text$x:0000421B
.text$mn:0000421C ; ===========================================================================
.text$mn:0000421C
.text$mn:0000421C ; Segment type: Pure code
.text$mn:0000421C ; Segment permissions: Read/Execute
.text$mn:0000421C _text$mn        segment para public 'CODE' use32
.text$mn:0000421C                 assume cs:_text$mn
.text$mn:0000421C                 ;org 421Ch
.text$mn:0000421C ; COMDAT (pick any)
.text$mn:0000421C                 assume es:nothing, ss:nothing, ds:_data, fs:nothing, gs:nothing
.text$mn:0000421C
.text$mn:0000421C ; =============== S U B R O U T I N E =======================================
.text$mn:0000421C
.text$mn:0000421C ; Attributes: bp-based frame
.text$mn:0000421C
.text$mn:0000421C ; int __stdcall std::_Vector_const_iterator<std::_Vector_val<std::_Simple_types<wchar_t const *>>>::_Vector_const_iterator<std::_Vector_val<std::_Simple_types<wchar_t const *>>>(struct std::_Iterator_base12 *)
.text$mn:0000421C                 public ??0?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@PB_W@std@@@std@@@std@@QAE@ABV01@@Z
.text$mn:0000421C ??0?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@PB_W@std@@@std@@@std@@QAE@ABV01@@Z proc near
.text$mn:0000421C                                         ; CODE XREF: std::vector<wchar_t const *,std::allocator<wchar_t const *>>::_Ucopy<std::_Vector_const_iterator<std::_Vector_val<std::_Simple_types<wchar_t const *>>>>(std::_Vector_const_iterator<std::_Vector_val<std::_Simple_types<wchar_t const *>>>,std::_Vector_const_iterator<std::_Vector_val<std::_Simple_types<wchar_t const *>>>,wchar_t const * *)+4Fp
.text$mn:0000421C                                         ; std::vector<wchar_t const *,std::allocator<wchar_t const *>>::_Ucopy<std::_Vector_const_iterator<std::_Vector_val<std::_Simple_types<wchar_t const *>>>>(std::_Vector_const_iterator<std::_Vector_val<std::_Simple_types<wchar_t const *>>>,std::_Vector_const_iterator<std::_Vector_val<std::_Simple_types<wchar_t const *>>>,wchar_t const * *)+6Dp ...
.text$mn:0000421C
.text$mn:0000421C var_10          = dword ptr -10h
.text$mn:0000421C var_C           = dword ptr -0Ch
.text$mn:0000421C var_4           = dword ptr -4
.text$mn:0000421C arg_0           = dword ptr  8
.text$mn:0000421C
.text$mn:0000421C                 push    ebp
.text$mn:0000421D                 mov     ebp, esp
.text$mn:0000421F                 push    0FFFFFFFFh
.text$mn:00004221                 push    offset __ehhandler$??0?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@PB_W@std@@@std@@@std@@QAE@ABV01@@Z
.text$mn:00004226                 mov     eax, large fs:0
.text$mn:0000422C                 push    eax
.text$mn:0000422D                 push    ecx
.text$mn:0000422E                 mov     eax, dword ptr ds:___security_cookie
.text$mn:00004233                 xor     eax, ebp
.text$mn:00004235                 push    eax
.text$mn:00004236                 lea     eax, [ebp+var_C]
.text$mn:00004239                 mov     large fs:0, eax
.text$mn:0000423F                 mov     [ebp+var_10], ecx
.text$mn:00004242                 mov     eax, [ebp+arg_0]
.text$mn:00004245                 push    eax             ; struct std::_Iterator_base12 *
.text$mn:00004246                 mov     ecx, [ebp+var_10]
.text$mn:00004249                 call    ??0?$_Iterator012@Urandom_access_iterator_tag@std@@PB_WHPBQB_WABQB_WU_Iterator_base12@2@@std@@QAE@ABU01@@Z ; std::_Iterator012<std::random_access_iterator_tag,wchar_t const *,int,wchar_t const * const *,wchar_t const * const &,std::_Iterator_base12>::_Iterator012<std::random_access_iterator_tag,wchar_t const *,int,wchar_t const * const *,wchar_t const * const &,std::_Iterator_base12>(std::_Iterator012<std::random_access_iterator_tag,wchar_t const *,int,wchar_t const * const *,wchar_t const * const &,std::_Iterator_base12> const &)
.text$mn:0000424E                 mov     [ebp+var_4], 0
.text$mn:00004255                 mov     ecx, [ebp+var_10]
.text$mn:00004258                 mov     edx, [ebp+arg_0]
.text$mn:0000425B                 mov     eax, [edx+8]
.text$mn:0000425E                 mov     [ecx+8], eax
.text$mn:00004261                 mov     [ebp+var_4], 0FFFFFFFFh
.text$mn:00004268                 mov     eax, [ebp+var_10]
.text$mn:0000426B                 mov     ecx, [ebp+var_C]
.text$mn:0000426E                 mov     large fs:0, ecx
.text$mn:00004275                 pop     ecx
.text$mn:00004276                 mov     esp, ebp
.text$mn:00004278                 pop     ebp
.text$mn:00004279                 retn    4
.text$mn:00004279 ??0?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@PB_W@std@@@std@@@std@@QAE@ABV01@@Z endp
.text$mn:00004279
.text$mn:00004279 _text$mn        ends
.text$mn:00004279
.text$x:0000427C ; ===========================================================================
.text$x:0000427C
.text$x:0000427C ; Segment type: Pure code
.text$x:0000427C ; Segment permissions: Read/Execute
.text$x:0000427C _text$x         segment para public 'CODE' use32
.text$x:0000427C                 assume cs:_text$x
.text$x:0000427C                 ;org 427Ch
.text$x:0000427C ; COMDAT (pick associative to section at 421C)
.text$x:0000427C                 assume es:nothing, ss:nothing, ds:_data, fs:nothing, gs:nothing
.text$x:0000427C
.text$x:0000427C ; =============== S U B R O U T I N E =======================================
.text$x:0000427C
.text$x:0000427C
.text$x:0000427C __unwindfunclet$??0?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@PB_W@std@@@std@@@std@@QAE@ABV01@@Z$0 proc near
.text$x:0000427C                                         ; DATA XREF: .xdata$x:00009FCCo
.text$x:0000427C                 mov     ecx, [ebp-10h]
.text$x:0000427F                 jmp     ??1?$_Iterator012@Urandom_access_iterator_tag@std@@PB_WHPBQB_WABQB_WU_Iterator_base12@2@@std@@QAE@XZ ; std::_Iterator012<std::random_access_iterator_tag,wchar_t const *,int,wchar_t const * const *,wchar_t const * const &,std::_Iterator_base12>::~_Iterator012<std::random_access_iterator_tag,wchar_t const *,int,wchar_t const * const *,wchar_t const * const &,std::_Iterator_base12>(void)
.text$x:0000427F __unwindfunclet$??0?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@PB_W@std@@@std@@@std@@QAE@ABV01@@Z$0 endp
.text$x:0000427F
.text$x:00004284
.text$x:00004284 ; =============== S U B R O U T I N E =======================================
.text$x:00004284
.text$x:00004284
.text$x:00004284 __ehhandler$??0?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@PB_W@std@@@std@@@std@@QAE@ABV01@@Z proc near
.text$x:00004284                                         ; DATA XREF: std::_Vector_const_iterator<std::_Vector_val<std::_Simple_types<wchar_t const *>>>::_Vector_const_iterator<std::_Vector_val<std::_Simple_types<wchar_t const *>>>(std::_Vector_const_iterator<std::_Vector_val<std::_Simple_types<wchar_t const *>>> const &)+5o
.text$x:00004284
.text$x:00004284 arg_4           = dword ptr  8
.text$x:00004284
.text$x:00004284                 mov     edx, [esp+arg_4]
.text$x:00004288                 lea     eax, [edx+0Ch]
.text$x:0000428B                 mov     ecx, [edx-8]
.text$x:0000428E                 xor     ecx, eax
.text$x:00004290                 call    @__security_check_cookie@4 ; __security_check_cookie(x)
.text$x:00004295                 mov     eax, offset __ehfuncinfo$??0?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@PB_W@std@@@std@@@std@@QAE@ABV01@@Z
.text$x:0000429A                 jmp     ___CxxFrameHandler3
.text$x:0000429A __ehhandler$??0?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@PB_W@std@@@std@@@std@@QAE@ABV01@@Z endp
.text$x:0000429A
.text$x:0000429A ; ---------------------------------------------------------------------------
.text$x:0000429F                 align 10h
.text$x:0000429F _text$x         ends
.text$x:0000429F
.text$mn:000042A0 ; ===========================================================================
.text$mn:000042A0
.text$mn:000042A0 ; Segment type: Pure code
.text$mn:000042A0 ; Segment permissions: Read/Execute
.text$mn:000042A0 _text$mn        segment para public 'CODE' use32
.text$mn:000042A0                 assume cs:_text$mn
.text$mn:000042A0                 ;org 42A0h
.text$mn:000042A0 ; COMDAT (pick any)
.text$mn:000042A0                 assume es:nothing, ss:nothing, ds:_data, fs:nothing, gs:nothing
.text$mn:000042A0
.text$mn:000042A0 ; =============== S U B R O U T I N E =======================================
.text$mn:000042A0
.text$mn:000042A0 ; Attributes: bp-based frame
.text$mn:000042A0
.text$mn:000042A0 ; int __stdcall std::_Vector_const_iterator<std::_Vector_val<std::_Simple_types<wchar_t const *>>>::_Vector_const_iterator<std::_Vector_val<std::_Simple_types<wchar_t const *>>>(int, struct std::_Container_base12 *)
.text$mn:000042A0                 public ??0?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@PB_W@std@@@std@@@std@@QAE@PAPB_WPBU_Container_base12@1@@Z
.text$mn:000042A0 ??0?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@PB_W@std@@@std@@@std@@QAE@PAPB_WPBU_Container_base12@1@@Z proc near
.text$mn:000042A0                                         ; CODE XREF: std::vector<wchar_t const *,std::allocator<wchar_t const *>>::begin(void)+3Dp
.text$mn:000042A0                                         ; std::vector<wchar_t const *,std::allocator<wchar_t const *>>::end(void)+3Dp
.text$mn:000042A0
.text$mn:000042A0 var_10          = dword ptr -10h
.text$mn:000042A0 var_C           = dword ptr -0Ch
.text$mn:000042A0 var_4           = dword ptr -4
.text$mn:000042A0 arg_0           = dword ptr  8
.text$mn:000042A0 arg_4           = dword ptr  0Ch
.text$mn:000042A0
.text$mn:000042A0                 push    ebp
.text$mn:000042A1                 mov     ebp, esp
.text$mn:000042A3                 push    0FFFFFFFFh
.text$mn:000042A5                 push    offset __ehhandler$??0?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@PB_W@std@@@std@@@std@@QAE@PAPB_WPBU_Container_base12@1@@Z
.text$mn:000042AA                 mov     eax, large fs:0
.text$mn:000042B0                 push    eax
.text$mn:000042B1                 push    ecx
.text$mn:000042B2                 mov     eax, dword ptr ds:___security_cookie
.text$mn:000042B7                 xor     eax, ebp
.text$mn:000042B9                 push    eax
.text$mn:000042BA                 lea     eax, [ebp+var_C]
.text$mn:000042BD                 mov     large fs:0, eax
.text$mn:000042C3                 mov     [ebp+var_10], ecx
.text$mn:000042C6                 mov     ecx, [ebp+var_10]
.text$mn:000042C9                 call    ??0?$_Iterator012@Urandom_access_iterator_tag@std@@PB_WHPBQB_WABQB_WU_Iterator_base12@2@@std@@QAE@XZ ; std::_Iterator012<std::random_access_iterator_tag,wchar_t const *,int,wchar_t const * const *,wchar_t const * const &,std::_Iterator_base12>::_Iterator012<std::random_access_iterator_tag,wchar_t const *,int,wchar_t const * const *,wchar_t const * const &,std::_Iterator_base12>(void)
.text$mn:000042CE                 mov     [ebp+var_4], 0
.text$mn:000042D5                 mov     eax, [ebp+var_10]
.text$mn:000042D8                 mov     ecx, [ebp+arg_0]
.text$mn:000042DB                 mov     [eax+8], ecx
.text$mn:000042DE                 mov     edx, [ebp+arg_4]
.text$mn:000042E1                 push    edx             ; struct std::_Container_base12 *
.text$mn:000042E2                 mov     ecx, [ebp+var_10] ; this
.text$mn:000042E5                 call    ?_Adopt@_Iterator_base12@std@@QAEXPBU_Container_base12@2@@Z ; std::_Iterator_base12::_Adopt(std::_Container_base12 const *)
.text$mn:000042EA                 mov     [ebp+var_4], 0FFFFFFFFh
.text$mn:000042F1                 mov     eax, [ebp+var_10]
.text$mn:000042F4                 mov     ecx, [ebp+var_C]
.text$mn:000042F7                 mov     large fs:0, ecx
.text$mn:000042FE                 pop     ecx
.text$mn:000042FF                 mov     esp, ebp
.text$mn:00004301                 pop     ebp
.text$mn:00004302                 retn    8
.text$mn:00004302 ??0?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@PB_W@std@@@std@@@std@@QAE@PAPB_WPBU_Container_base12@1@@Z endp
.text$mn:00004302
.text$mn:00004302 ; ---------------------------------------------------------------------------
.text$mn:00004305                 align 4
.text$mn:00004305 _text$mn        ends
.text$mn:00004305
.text$x:00004308 ; ===========================================================================
.text$x:00004308
.text$x:00004308 ; Segment type: Pure code
.text$x:00004308 ; Segment permissions: Read/Execute
.text$x:00004308 _text$x         segment para public 'CODE' use32
.text$x:00004308                 assume cs:_text$x
.text$x:00004308                 ;org 4308h
.text$x:00004308 ; COMDAT (pick associative to section at 42A0)
.text$x:00004308                 assume es:nothing, ss:nothing, ds:_data, fs:nothing, gs:nothing
.text$x:00004308
.text$x:00004308 ; =============== S U B R O U T I N E =======================================
.text$x:00004308
.text$x:00004308
.text$x:00004308 __unwindfunclet$??0?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@PB_W@std@@@std@@@std@@QAE@PAPB_WPBU_Container_base12@1@@Z$0 proc near
.text$x:00004308                                         ; DATA XREF: .xdata$x:00009F74o
.text$x:00004308                 mov     ecx, [ebp-10h]
.text$x:0000430B                 jmp     ??1?$_Iterator012@Urandom_access_iterator_tag@std@@PB_WHPBQB_WABQB_WU_Iterator_base12@2@@std@@QAE@XZ ; std::_Iterator012<std::random_access_iterator_tag,wchar_t const *,int,wchar_t const * const *,wchar_t const * const &,std::_Iterator_base12>::~_Iterator012<std::random_access_iterator_tag,wchar_t const *,int,wchar_t const * const *,wchar_t const * const &,std::_Iterator_base12>(void)
.text$x:0000430B __unwindfunclet$??0?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@PB_W@std@@@std@@@std@@QAE@PAPB_WPBU_Container_base12@1@@Z$0 endp
.text$x:0000430B
.text$x:00004310
.text$x:00004310 ; =============== S U B R O U T I N E =======================================
.text$x:00004310
.text$x:00004310
.text$x:00004310 __ehhandler$??0?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@PB_W@std@@@std@@@std@@QAE@PAPB_WPBU_Container_base12@1@@Z proc near
.text$x:00004310                                         ; DATA XREF: std::_Vector_const_iterator<std::_Vector_val<std::_Simple_types<wchar_t const *>>>::_Vector_const_iterator<std::_Vector_val<std::_Simple_types<wchar_t const *>>>(wchar_t const * *,std::_Container_base12 const *)+5o
.text$x:00004310
.text$x:00004310 arg_4           = dword ptr  8
.text$x:00004310
.text$x:00004310                 mov     edx, [esp+arg_4]
.text$x:00004314                 lea     eax, [edx+0Ch]
.text$x:00004317                 mov     ecx, [edx-8]
.text$x:0000431A                 xor     ecx, eax
.text$x:0000431C                 call    @__security_check_cookie@4 ; __security_check_cookie(x)
.text$x:00004321                 mov     eax, offset __ehfuncinfo$??0?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@PB_W@std@@@std@@@std@@QAE@PAPB_WPBU_Container_base12@1@@Z
.text$x:00004326                 jmp     ___CxxFrameHandler3
.text$x:00004326 __ehhandler$??0?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@PB_W@std@@@std@@@std@@QAE@PAPB_WPBU_Container_base12@1@@Z endp
.text$x:00004326
.text$x:00004326 ; ---------------------------------------------------------------------------
.text$x:0000432B                 align 4
.text$x:0000432B _text$x         ends
.text$x:0000432B
.text$mn:0000432C ; ===========================================================================
.text$mn:0000432C
.text$mn:0000432C ; Segment type: Pure code
.text$mn:0000432C ; Segment permissions: Read/Execute
.text$mn:0000432C _text$mn        segment para public 'CODE' use32
.text$mn:0000432C                 assume cs:_text$mn
.text$mn:0000432C                 ;org 432Ch
.text$mn:0000432C ; COMDAT (pick any)
.text$mn:0000432C                 assume es:nothing, ss:nothing, ds:_data, fs:nothing, gs:nothing
.text$mn:0000432C
.text$mn:0000432C ; =============== S U B R O U T I N E =======================================
.text$mn:0000432C
.text$mn:0000432C ; Attributes: bp-based frame
.text$mn:0000432C
.text$mn:0000432C ; int __stdcall std::_Vector_const_iterator<std::_Vector_val<std::_Simple_types<FunctionValues>>>::_Vector_const_iterator<std::_Vector_val<std::_Simple_types<FunctionValues>>>(struct std::_Iterator_base12 *)
.text$mn:0000432C                 public ??0?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@UFunctionValues@@@std@@@std@@@std@@QAE@ABV01@@Z
.text$mn:0000432C ??0?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@UFunctionValues@@@std@@@std@@@std@@QAE@ABV01@@Z proc near
.text$mn:0000432C                                         ; CODE XREF: std::_Vector_iterator<std::_Vector_val<std::_Simple_types<FunctionValues>>>::_Vector_iterator<std::_Vector_val<std::_Simple_types<FunctionValues>>>(std::_Vector_iterator<std::_Vector_val<std::_Simple_types<FunctionValues>>> const &)+2Dp
.text$mn:0000432C
.text$mn:0000432C var_10          = dword ptr -10h
.text$mn:0000432C var_C           = dword ptr -0Ch
.text$mn:0000432C var_4           = dword ptr -4
.text$mn:0000432C arg_0           = dword ptr  8
.text$mn:0000432C
.text$mn:0000432C                 push    ebp
.text$mn:0000432D                 mov     ebp, esp
.text$mn:0000432F                 push    0FFFFFFFFh
.text$mn:00004331                 push    offset __ehhandler$??0?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@UFunctionValues@@@std@@@std@@@std@@QAE@ABV01@@Z
.text$mn:00004336                 mov     eax, large fs:0
.text$mn:0000433C                 push    eax
.text$mn:0000433D                 push    ecx
.text$mn:0000433E                 mov     eax, dword ptr ds:___security_cookie
.text$mn:00004343                 xor     eax, ebp
.text$mn:00004345                 push    eax
.text$mn:00004346                 lea     eax, [ebp+var_C]
.text$mn:00004349                 mov     large fs:0, eax
.text$mn:0000434F                 mov     [ebp+var_10], ecx
.text$mn:00004352                 mov     eax, [ebp+arg_0]
.text$mn:00004355                 push    eax             ; struct std::_Iterator_base12 *
.text$mn:00004356                 mov     ecx, [ebp+var_10]
.text$mn:00004359                 call    ??0?$_Iterator012@Urandom_access_iterator_tag@std@@UFunctionValues@@HPBU3@ABU3@U_Iterator_base12@2@@std@@QAE@ABU01@@Z ; std::_Iterator012<std::random_access_iterator_tag,FunctionValues,int,FunctionValues const *,FunctionValues const &,std::_Iterator_base12>::_Iterator012<std::random_access_iterator_tag,FunctionValues,int,FunctionValues const *,FunctionValues const &,std::_Iterator_base12>(std::_Iterator012<std::random_access_iterator_tag,FunctionValues,int,FunctionValues const *,FunctionValues const &,std::_Iterator_base12> const &)
.text$mn:0000435E                 mov     [ebp+var_4], 0
.text$mn:00004365                 mov     ecx, [ebp+var_10]
.text$mn:00004368                 mov     edx, [ebp+arg_0]
.text$mn:0000436B                 mov     eax, [edx+8]
.text$mn:0000436E                 mov     [ecx+8], eax
.text$mn:00004371                 mov     [ebp+var_4], 0FFFFFFFFh
.text$mn:00004378                 mov     eax, [ebp+var_10]
.text$mn:0000437B                 mov     ecx, [ebp+var_C]
.text$mn:0000437E                 mov     large fs:0, ecx
.text$mn:00004385                 pop     ecx
.text$mn:00004386                 mov     esp, ebp
.text$mn:00004388                 pop     ebp
.text$mn:00004389                 retn    4
.text$mn:00004389 ??0?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@UFunctionValues@@@std@@@std@@@std@@QAE@ABV01@@Z endp
.text$mn:00004389
.text$mn:00004389 _text$mn        ends
.text$mn:00004389
.text$x:0000438C ; ===========================================================================
.text$x:0000438C
.text$x:0000438C ; Segment type: Pure code
.text$x:0000438C ; Segment permissions: Read/Execute
.text$x:0000438C _text$x         segment para public 'CODE' use32
.text$x:0000438C                 assume cs:_text$x
.text$x:0000438C                 ;org 438Ch
.text$x:0000438C ; COMDAT (pick associative to section at 432C)
.text$x:0000438C                 assume es:nothing, ss:nothing, ds:_data, fs:nothing, gs:nothing
.text$x:0000438C
.text$x:0000438C ; =============== S U B R O U T I N E =======================================
.text$x:0000438C
.text$x:0000438C
.text$x:0000438C __unwindfunclet$??0?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@UFunctionValues@@@std@@@std@@@std@@QAE@ABV01@@Z$0 proc near
.text$x:0000438C                                         ; DATA XREF: .xdata$x:00009E0Co
.text$x:0000438C                 mov     ecx, [ebp-10h]
.text$x:0000438F                 jmp     ??1?$_Iterator012@Urandom_access_iterator_tag@std@@UFunctionValues@@HPBU3@ABU3@U_Iterator_base12@2@@std@@QAE@XZ ; std::_Iterator012<std::random_access_iterator_tag,FunctionValues,int,FunctionValues const *,FunctionValues const &,std::_Iterator_base12>::~_Iterator012<std::random_access_iterator_tag,FunctionValues,int,FunctionValues const *,FunctionValues const &,std::_Iterator_base12>(void)
.text$x:0000438F __unwindfunclet$??0?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@UFunctionValues@@@std@@@std@@@std@@QAE@ABV01@@Z$0 endp
.text$x:0000438F
.text$x:00004394
.text$x:00004394 ; =============== S U B R O U T I N E =======================================
.text$x:00004394
.text$x:00004394
.text$x:00004394 __ehhandler$??0?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@UFunctionValues@@@std@@@std@@@std@@QAE@ABV01@@Z proc near
.text$x:00004394                                         ; DATA XREF: std::_Vector_const_iterator<std::_Vector_val<std::_Simple_types<FunctionValues>>>::_Vector_const_iterator<std::_Vector_val<std::_Simple_types<FunctionValues>>>(std::_Vector_const_iterator<std::_Vector_val<std::_Simple_types<FunctionValues>>> const &)+5o
.text$x:00004394
.text$x:00004394 arg_4           = dword ptr  8
.text$x:00004394
.text$x:00004394                 mov     edx, [esp+arg_4]
.text$x:00004398                 lea     eax, [edx+0Ch]
.text$x:0000439B                 mov     ecx, [edx-8]
.text$x:0000439E                 xor     ecx, eax
.text$x:000043A0                 call    @__security_check_cookie@4 ; __security_check_cookie(x)
.text$x:000043A5                 mov     eax, offset __ehfuncinfo$??0?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@UFunctionValues@@@std@@@std@@@std@@QAE@ABV01@@Z
.text$x:000043AA                 jmp     ___CxxFrameHandler3
.text$x:000043AA __ehhandler$??0?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@UFunctionValues@@@std@@@std@@@std@@QAE@ABV01@@Z endp
.text$x:000043AA
.text$x:000043AA ; ---------------------------------------------------------------------------
.text$x:000043AF                 align 10h
.text$x:000043AF _text$x         ends
.text$x:000043AF
.text$mn:000043B0 ; ===========================================================================
.text$mn:000043B0
.text$mn:000043B0 ; Segment type: Pure code
.text$mn:000043B0 ; Segment permissions: Read/Execute
.text$mn:000043B0 _text$mn        segment para public 'CODE' use32
.text$mn:000043B0                 assume cs:_text$mn
.text$mn:000043B0                 ;org 43B0h
.text$mn:000043B0 ; COMDAT (pick any)
.text$mn:000043B0                 assume es:nothing, ss:nothing, ds:_data, fs:nothing, gs:nothing
.text$mn:000043B0
.text$mn:000043B0 ; =============== S U B R O U T I N E =======================================
.text$mn:000043B0
.text$mn:000043B0 ; Attributes: bp-based frame
.text$mn:000043B0
.text$mn:000043B0 ; int __stdcall std::_Vector_const_iterator<std::_Vector_val<std::_Simple_types<FunctionValues>>>::_Vector_const_iterator<std::_Vector_val<std::_Simple_types<FunctionValues>>>(int, struct std::_Container_base12 *)
.text$mn:000043B0                 public ??0?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@UFunctionValues@@@std@@@std@@@std@@QAE@PAUFunctionValues@@PBU_Container_base12@1@@Z
.text$mn:000043B0 ??0?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@UFunctionValues@@@std@@@std@@@std@@QAE@PAUFunctionValues@@PBU_Container_base12@1@@Z proc near
.text$mn:000043B0                                         ; CODE XREF: std::_Vector_iterator<std::_Vector_val<std::_Simple_types<FunctionValues>>>::_Vector_iterator<std::_Vector_val<std::_Simple_types<FunctionValues>>>(FunctionValues *,std::_Container_base12 const *)+31p
.text$mn:000043B0
.text$mn:000043B0 var_10          = dword ptr -10h
.text$mn:000043B0 var_C           = dword ptr -0Ch
.text$mn:000043B0 var_4           = dword ptr -4
.text$mn:000043B0 arg_0           = dword ptr  8
.text$mn:000043B0 arg_4           = dword ptr  0Ch
.text$mn:000043B0
.text$mn:000043B0                 push    ebp
.text$mn:000043B1                 mov     ebp, esp
.text$mn:000043B3                 push    0FFFFFFFFh
.text$mn:000043B5                 push    offset __ehhandler$??0?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@UFunctionValues@@@std@@@std@@@std@@QAE@PAUFunctionValues@@PBU_Container_base12@1@@Z
.text$mn:000043BA                 mov     eax, large fs:0
.text$mn:000043C0                 push    eax
.text$mn:000043C1                 push    ecx
.text$mn:000043C2                 mov     eax, dword ptr ds:___security_cookie
.text$mn:000043C7                 xor     eax, ebp
.text$mn:000043C9                 push    eax
.text$mn:000043CA                 lea     eax, [ebp+var_C]
.text$mn:000043CD                 mov     large fs:0, eax
.text$mn:000043D3                 mov     [ebp+var_10], ecx
.text$mn:000043D6                 mov     ecx, [ebp+var_10]
.text$mn:000043D9                 call    ??0?$_Iterator012@Urandom_access_iterator_tag@std@@UFunctionValues@@HPBU3@ABU3@U_Iterator_base12@2@@std@@QAE@XZ ; std::_Iterator012<std::random_access_iterator_tag,FunctionValues,int,FunctionValues const *,FunctionValues const &,std::_Iterator_base12>::_Iterator012<std::random_access_iterator_tag,FunctionValues,int,FunctionValues const *,FunctionValues const &,std::_Iterator_base12>(void)
.text$mn:000043DE                 mov     [ebp+var_4], 0
.text$mn:000043E5                 mov     eax, [ebp+var_10]
.text$mn:000043E8                 mov     ecx, [ebp+arg_0]
.text$mn:000043EB                 mov     [eax+8], ecx
.text$mn:000043EE                 mov     edx, [ebp+arg_4]
.text$mn:000043F1                 push    edx             ; struct std::_Container_base12 *
.text$mn:000043F2                 mov     ecx, [ebp+var_10] ; this
.text$mn:000043F5                 call    ?_Adopt@_Iterator_base12@std@@QAEXPBU_Container_base12@2@@Z ; std::_Iterator_base12::_Adopt(std::_Container_base12 const *)
.text$mn:000043FA                 mov     [ebp+var_4], 0FFFFFFFFh
.text$mn:00004401                 mov     eax, [ebp+var_10]
.text$mn:00004404                 mov     ecx, [ebp+var_C]
.text$mn:00004407                 mov     large fs:0, ecx
.text$mn:0000440E                 pop     ecx
.text$mn:0000440F                 mov     esp, ebp
.text$mn:00004411                 pop     ebp
.text$mn:00004412                 retn    8
.text$mn:00004412 ??0?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@UFunctionValues@@@std@@@std@@@std@@QAE@PAUFunctionValues@@PBU_Container_base12@1@@Z endp
.text$mn:00004412
.text$mn:00004412 ; ---------------------------------------------------------------------------
.text$mn:00004415                 align 4
.text$mn:00004415 _text$mn        ends
.text$mn:00004415
.text$x:00004418 ; ===========================================================================
.text$x:00004418
.text$x:00004418 ; Segment type: Pure code
.text$x:00004418 ; Segment permissions: Read/Execute
.text$x:00004418 _text$x         segment para public 'CODE' use32
.text$x:00004418                 assume cs:_text$x
.text$x:00004418                 ;org 4418h
.text$x:00004418 ; COMDAT (pick associative to section at 43B0)
.text$x:00004418                 assume es:nothing, ss:nothing, ds:_data, fs:nothing, gs:nothing
.text$x:00004418
.text$x:00004418 ; =============== S U B R O U T I N E =======================================
.text$x:00004418
.text$x:00004418
.text$x:00004418 __unwindfunclet$??0?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@UFunctionValues@@@std@@@std@@@std@@QAE@PAUFunctionValues@@PBU_Container_base12@1@@Z$0 proc near
.text$x:00004418                                         ; DATA XREF: .xdata$x:00009DB4o
.text$x:00004418                 mov     ecx, [ebp-10h]
.text$x:0000441B                 jmp     ??1?$_Iterator012@Urandom_access_iterator_tag@std@@UFunctionValues@@HPBU3@ABU3@U_Iterator_base12@2@@std@@QAE@XZ ; std::_Iterator012<std::random_access_iterator_tag,FunctionValues,int,FunctionValues const *,FunctionValues const &,std::_Iterator_base12>::~_Iterator012<std::random_access_iterator_tag,FunctionValues,int,FunctionValues const *,FunctionValues const &,std::_Iterator_base12>(void)
.text$x:0000441B __unwindfunclet$??0?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@UFunctionValues@@@std@@@std@@@std@@QAE@PAUFunctionValues@@PBU_Container_base12@1@@Z$0 endp
.text$x:0000441B
.text$x:00004420
.text$x:00004420 ; =============== S U B R O U T I N E =======================================
.text$x:00004420
.text$x:00004420
.text$x:00004420 __ehhandler$??0?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@UFunctionValues@@@std@@@std@@@std@@QAE@PAUFunctionValues@@PBU_Container_base12@1@@Z proc near
.text$x:00004420                                         ; DATA XREF: std::_Vector_const_iterator<std::_Vector_val<std::_Simple_types<FunctionValues>>>::_Vector_const_iterator<std::_Vector_val<std::_Simple_types<FunctionValues>>>(FunctionValues *,std::_Container_base12 const *)+5o
.text$x:00004420
.text$x:00004420 arg_4           = dword ptr  8
.text$x:00004420
.text$x:00004420                 mov     edx, [esp+arg_4]
.text$x:00004424                 lea     eax, [edx+0Ch]
.text$x:00004427                 mov     ecx, [edx-8]
.text$x:0000442A                 xor     ecx, eax
.text$x:0000442C                 call    @__security_check_cookie@4 ; __security_check_cookie(x)
.text$x:00004431                 mov     eax, offset __ehfuncinfo$??0?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@UFunctionValues@@@std@@@std@@@std@@QAE@PAUFunctionValues@@PBU_Container_base12@1@@Z
.text$x:00004436                 jmp     ___CxxFrameHandler3
.text$x:00004436 __ehhandler$??0?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@UFunctionValues@@@std@@@std@@@std@@QAE@PAUFunctionValues@@PBU_Container_base12@1@@Z endp
.text$x:00004436
.text$x:00004436 ; ---------------------------------------------------------------------------
.text$x:0000443B                 align 4
.text$x:0000443B _text$x         ends
.text$x:0000443B
.text$mn:0000443C ; ===========================================================================
.text$mn:0000443C
.text$mn:0000443C ; Segment type: Pure code
.text$mn:0000443C ; Segment permissions: Read/Execute
.text$mn:0000443C _text$mn        segment para public 'CODE' use32
.text$mn:0000443C                 assume cs:_text$mn
.text$mn:0000443C                 ;org 443Ch
.text$mn:0000443C ; COMDAT (pick any)
.text$mn:0000443C                 assume es:nothing, ss:nothing, ds:_data, fs:nothing, gs:nothing
.text$mn:0000443C
.text$mn:0000443C ; =============== S U B R O U T I N E =======================================
.text$mn:0000443C
.text$mn:0000443C ; Attributes: bp-based frame
.text$mn:0000443C
.text$mn:0000443C ; int __stdcall std::_Vector_iterator<std::_Vector_val<std::_Simple_types<FunctionValues>>>::_Vector_iterator<std::_Vector_val<std::_Simple_types<FunctionValues>>>(struct std::_Iterator_base12 *)
.text$mn:0000443C                 public ??0?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@UFunctionValues@@@std@@@std@@@std@@QAE@ABV01@@Z
.text$mn:0000443C ??0?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@UFunctionValues@@@std@@@std@@@std@@QAE@ABV01@@Z proc near
.text$mn:0000443C                                         ; CODE XREF: std::_Vector_iterator<std::_Vector_val<std::_Simple_types<FunctionValues>>>::operator-(int)+36p
.text$mn:0000443C                                         ; std::_Vector_iterator<std::_Vector_val<std::_Simple_types<FunctionValues>>>::operator-(int)+52p
.text$mn:0000443C
.text$mn:0000443C var_10          = dword ptr -10h
.text$mn:0000443C var_C           = dword ptr -0Ch
.text$mn:0000443C var_4           = dword ptr -4
.text$mn:0000443C arg_0           = dword ptr  8
.text$mn:0000443C
.text$mn:0000443C                 push    ebp
.text$mn:0000443D                 mov     ebp, esp
.text$mn:0000443F                 push    0FFFFFFFFh
.text$mn:00004441                 push    offset __ehhandler$??0?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@UFunctionValues@@@std@@@std@@@std@@QAE@ABV01@@Z
.text$mn:00004446                 mov     eax, large fs:0
.text$mn:0000444C                 push    eax
.text$mn:0000444D                 push    ecx
.text$mn:0000444E                 mov     eax, dword ptr ds:___security_cookie
.text$mn:00004453                 xor     eax, ebp
.text$mn:00004455                 push    eax
.text$mn:00004456                 lea     eax, [ebp+var_C]
.text$mn:00004459                 mov     large fs:0, eax
.text$mn:0000445F                 mov     [ebp+var_10], ecx
.text$mn:00004462                 mov     eax, [ebp+arg_0]
.text$mn:00004465                 push    eax             ; struct std::_Iterator_base12 *
.text$mn:00004466                 mov     ecx, [ebp+var_10]
.text$mn:00004469                 call    ??0?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@UFunctionValues@@@std@@@std@@@std@@QAE@ABV01@@Z ; std::_Vector_const_iterator<std::_Vector_val<std::_Simple_types<FunctionValues>>>::_Vector_const_iterator<std::_Vector_val<std::_Simple_types<FunctionValues>>>(std::_Vector_const_iterator<std::_Vector_val<std::_Simple_types<FunctionValues>>> const &)
.text$mn:0000446E                 mov     [ebp+var_4], 0
.text$mn:00004475                 mov     [ebp+var_4], 0FFFFFFFFh
.text$mn:0000447C                 mov     eax, [ebp+var_10]
.text$mn:0000447F                 mov     ecx, [ebp+var_C]
.text$mn:00004482                 mov     large fs:0, ecx
.text$mn:00004489                 pop     ecx
.text$mn:0000448A                 mov     esp, ebp
.text$mn:0000448C                 pop     ebp
.text$mn:0000448D                 retn    4
.text$mn:0000448D ??0?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@UFunctionValues@@@std@@@std@@@std@@QAE@ABV01@@Z endp
.text$mn:0000448D
.text$mn:0000448D _text$mn        ends
.text$mn:0000448D
.text$x:00004490 ; ===========================================================================
.text$x:00004490
.text$x:00004490 ; Segment type: Pure code
.text$x:00004490 ; Segment permissions: Read/Execute
.text$x:00004490 _text$x         segment para public 'CODE' use32
.text$x:00004490                 assume cs:_text$x
.text$x:00004490                 ;org 4490h
.text$x:00004490 ; COMDAT (pick associative to section at 443C)
.text$x:00004490                 assume es:nothing, ss:nothing, ds:_data, fs:nothing, gs:nothing
.text$x:00004490
.text$x:00004490 ; =============== S U B R O U T I N E =======================================
.text$x:00004490
.text$x:00004490
.text$x:00004490 __unwindfunclet$??0?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@UFunctionValues@@@std@@@std@@@std@@QAE@ABV01@@Z$0 proc near
.text$x:00004490                                         ; DATA XREF: .xdata$x:00009EC4o
.text$x:00004490                 mov     ecx, [ebp-10h]
.text$x:00004493                 jmp     ??1?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@UFunctionValues@@@std@@@std@@@std@@QAE@XZ ; std::_Vector_const_iterator<std::_Vector_val<std::_Simple_types<FunctionValues>>>::~_Vector_const_iterator<std::_Vector_val<std::_Simple_types<FunctionValues>>>(void)
.text$x:00004493 __unwindfunclet$??0?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@UFunctionValues@@@std@@@std@@@std@@QAE@ABV01@@Z$0 endp
.text$x:00004493
.text$x:00004498
.text$x:00004498 ; =============== S U B R O U T I N E =======================================
.text$x:00004498
.text$x:00004498
.text$x:00004498 __ehhandler$??0?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@UFunctionValues@@@std@@@std@@@std@@QAE@ABV01@@Z proc near
.text$x:00004498                                         ; DATA XREF: std::_Vector_iterator<std::_Vector_val<std::_Simple_types<FunctionValues>>>::_Vector_iterator<std::_Vector_val<std::_Simple_types<FunctionValues>>>(std::_Vector_iterator<std::_Vector_val<std::_Simple_types<FunctionValues>>> const &)+5o
.text$x:00004498
.text$x:00004498 arg_4           = dword ptr  8
.text$x:00004498
.text$x:00004498                 mov     edx, [esp+arg_4]
.text$x:0000449C                 lea     eax, [edx+0Ch]
.text$x:0000449F                 mov     ecx, [edx-8]
.text$x:000044A2                 xor     ecx, eax
.text$x:000044A4                 call    @__security_check_cookie@4 ; __security_check_cookie(x)
.text$x:000044A9                 mov     eax, offset __ehfuncinfo$??0?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@UFunctionValues@@@std@@@std@@@std@@QAE@ABV01@@Z
.text$x:000044AE                 jmp     ___CxxFrameHandler3
.text$x:000044AE __ehhandler$??0?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@UFunctionValues@@@std@@@std@@@std@@QAE@ABV01@@Z endp
.text$x:000044AE
.text$x:000044AE ; ---------------------------------------------------------------------------
.text$x:000044B3                 align 4
.text$x:000044B3 _text$x         ends
.text$x:000044B3
.text$mn:000044B4 ; ===========================================================================
.text$mn:000044B4
.text$mn:000044B4 ; Segment type: Pure code
.text$mn:000044B4 ; Segment permissions: Read/Execute
.text$mn:000044B4 _text$mn        segment para public 'CODE' use32
.text$mn:000044B4                 assume cs:_text$mn
.text$mn:000044B4                 ;org 44B4h
.text$mn:000044B4 ; COMDAT (pick any)
.text$mn:000044B4                 assume es:nothing, ss:nothing, ds:_data, fs:nothing, gs:nothing
.text$mn:000044B4
.text$mn:000044B4 ; =============== S U B R O U T I N E =======================================
.text$mn:000044B4
.text$mn:000044B4 ; Attributes: bp-based frame
.text$mn:000044B4
.text$mn:000044B4 ; int __stdcall std::_Vector_iterator<std::_Vector_val<std::_Simple_types<FunctionValues>>>::_Vector_iterator<std::_Vector_val<std::_Simple_types<FunctionValues>>>(int, struct std::_Container_base12 *)
.text$mn:000044B4                 public ??0?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@UFunctionValues@@@std@@@std@@@std@@QAE@PAUFunctionValues@@PBU_Container_base12@1@@Z
.text$mn:000044B4 ??0?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@UFunctionValues@@@std@@@std@@@std@@QAE@PAUFunctionValues@@PBU_Container_base12@1@@Z proc near
.text$mn:000044B4                                         ; CODE XREF: std::vector<FunctionValues,std::allocator<FunctionValues>>::end(void)+3Dp
.text$mn:000044B4
.text$mn:000044B4 var_10          = dword ptr -10h
.text$mn:000044B4 var_C           = dword ptr -0Ch
.text$mn:000044B4 var_4           = dword ptr -4
.text$mn:000044B4 arg_0           = dword ptr  8
.text$mn:000044B4 arg_4           = dword ptr  0Ch
.text$mn:000044B4
.text$mn:000044B4                 push    ebp
.text$mn:000044B5                 mov     ebp, esp
.text$mn:000044B7                 push    0FFFFFFFFh
.text$mn:000044B9                 push    offset __ehhandler$??0?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@UFunctionValues@@@std@@@std@@@std@@QAE@PAUFunctionValues@@PBU_Container_base12@1@@Z
.text$mn:000044BE                 mov     eax, large fs:0
.text$mn:000044C4                 push    eax
.text$mn:000044C5                 push    ecx
.text$mn:000044C6                 mov     eax, dword ptr ds:___security_cookie
.text$mn:000044CB                 xor     eax, ebp
.text$mn:000044CD                 push    eax
.text$mn:000044CE                 lea     eax, [ebp+var_C]
.text$mn:000044D1                 mov     large fs:0, eax
.text$mn:000044D7                 mov     [ebp+var_10], ecx
.text$mn:000044DA                 mov     eax, [ebp+arg_4]
.text$mn:000044DD                 push    eax             ; struct std::_Container_base12 *
.text$mn:000044DE                 mov     ecx, [ebp+arg_0]
.text$mn:000044E1                 push    ecx             ; int
.text$mn:000044E2                 mov     ecx, [ebp+var_10]
.text$mn:000044E5                 call    ??0?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@UFunctionValues@@@std@@@std@@@std@@QAE@PAUFunctionValues@@PBU_Container_base12@1@@Z ; std::_Vector_const_iterator<std::_Vector_val<std::_Simple_types<FunctionValues>>>::_Vector_const_iterator<std::_Vector_val<std::_Simple_types<FunctionValues>>>(FunctionValues *,std::_Container_base12 const *)
.text$mn:000044EA                 mov     [ebp+var_4], 0
.text$mn:000044F1                 mov     [ebp+var_4], 0FFFFFFFFh
.text$mn:000044F8                 mov     eax, [ebp+var_10]
.text$mn:000044FB                 mov     ecx, [ebp+var_C]
.text$mn:000044FE                 mov     large fs:0, ecx
.text$mn:00004505                 pop     ecx
.text$mn:00004506                 mov     esp, ebp
.text$mn:00004508                 pop     ebp
.text$mn:00004509                 retn    8
.text$mn:00004509 ??0?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@UFunctionValues@@@std@@@std@@@std@@QAE@PAUFunctionValues@@PBU_Container_base12@1@@Z endp
.text$mn:00004509
.text$mn:00004509 _text$mn        ends
.text$mn:00004509
.text$x:0000450C ; ===========================================================================
.text$x:0000450C
.text$x:0000450C ; Segment type: Pure code
.text$x:0000450C ; Segment permissions: Read/Execute
.text$x:0000450C _text$x         segment para public 'CODE' use32
.text$x:0000450C                 assume cs:_text$x
.text$x:0000450C                 ;org 450Ch
.text$x:0000450C ; COMDAT (pick associative to section at 44B4)
.text$x:0000450C                 assume es:nothing, ss:nothing, ds:_data, fs:nothing, gs:nothing
.text$x:0000450C
.text$x:0000450C ; =============== S U B R O U T I N E =======================================
.text$x:0000450C
.text$x:0000450C
.text$x:0000450C __unwindfunclet$??0?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@UFunctionValues@@@std@@@std@@@std@@QAE@PAUFunctionValues@@PBU_Container_base12@1@@Z$0 proc near
.text$x:0000450C                                         ; DATA XREF: .xdata$x:00009E38o
.text$x:0000450C                 mov     ecx, [ebp-10h]
.text$x:0000450F                 jmp     ??1?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@UFunctionValues@@@std@@@std@@@std@@QAE@XZ ; std::_Vector_const_iterator<std::_Vector_val<std::_Simple_types<FunctionValues>>>::~_Vector_const_iterator<std::_Vector_val<std::_Simple_types<FunctionValues>>>(void)
.text$x:0000450F __unwindfunclet$??0?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@UFunctionValues@@@std@@@std@@@std@@QAE@PAUFunctionValues@@PBU_Container_base12@1@@Z$0 endp
.text$x:0000450F
.text$x:00004514
.text$x:00004514 ; =============== S U B R O U T I N E =======================================
.text$x:00004514
.text$x:00004514
.text$x:00004514 __ehhandler$??0?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@UFunctionValues@@@std@@@std@@@std@@QAE@PAUFunctionValues@@PBU_Container_base12@1@@Z proc near
.text$x:00004514                                         ; DATA XREF: std::_Vector_iterator<std::_Vector_val<std::_Simple_types<FunctionValues>>>::_Vector_iterator<std::_Vector_val<std::_Simple_types<FunctionValues>>>(FunctionValues *,std::_Container_base12 const *)+5o
.text$x:00004514
.text$x:00004514 arg_4           = dword ptr  8
.text$x:00004514
.text$x:00004514                 mov     edx, [esp+arg_4]
.text$x:00004518                 lea     eax, [edx+0Ch]
.text$x:0000451B                 mov     ecx, [edx-8]
.text$x:0000451E                 xor     ecx, eax
.text$x:00004520                 call    @__security_check_cookie@4 ; __security_check_cookie(x)
.text$x:00004525                 mov     eax, offset __ehfuncinfo$??0?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@UFunctionValues@@@std@@@std@@@std@@QAE@PAUFunctionValues@@PBU_Container_base12@1@@Z
.text$x:0000452A                 jmp     ___CxxFrameHandler3
.text$x:0000452A __ehhandler$??0?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@UFunctionValues@@@std@@@std@@@std@@QAE@PAUFunctionValues@@PBU_Container_base12@1@@Z endp
.text$x:0000452A
.text$x:0000452A ; ---------------------------------------------------------------------------
.text$x:0000452F                 align 10h
.text$x:0000452F _text$x         ends
.text$x:0000452F
.text$mn:00004530 ; ===========================================================================
.text$mn:00004530
.text$mn:00004530 ; Segment type: Pure code
.text$mn:00004530 ; Segment permissions: Read/Execute
.text$mn:00004530 _text$mn        segment para public 'CODE' use32
.text$mn:00004530                 assume cs:_text$mn
.text$mn:00004530                 ;org 4530h
.text$mn:00004530 ; COMDAT (pick any)
.text$mn:00004530                 assume es:nothing, ss:nothing, ds:_data, fs:nothing, gs:nothing
.text$mn:00004530
.text$mn:00004530 ; =============== S U B R O U T I N E =======================================
.text$mn:00004530
.text$mn:00004530 ; Attributes: bp-based frame
.text$mn:00004530
.text$mn:00004530 ; public: __thiscall std::_Vector_val<struct std::_Simple_types<wchar_t const *>>::_Vector_val<struct std::_Simple_types<wchar_t const *>>(void)
.text$mn:00004530                 public ??0?$_Vector_val@U?$_Simple_types@PB_W@std@@@std@@QAE@XZ
.text$mn:00004530 ??0?$_Vector_val@U?$_Simple_types@PB_W@std@@@std@@QAE@XZ proc near
.text$mn:00004530                                         ; CODE XREF: std::_Vector_alloc<0,std::_Vec_base_types<wchar_t const *,std::allocator<wchar_t const *>>>::_Vector_alloc<0,std::_Vec_base_types<wchar_t const *,std::allocator<wchar_t const *>>>(std::allocator<wchar_t const *> const &)+29p
.text$mn:00004530
.text$mn:00004530 var_10          = dword ptr -10h
.text$mn:00004530 var_C           = dword ptr -0Ch
.text$mn:00004530 var_4           = dword ptr -4
.text$mn:00004530
.text$mn:00004530                 push    ebp
.text$mn:00004531                 mov     ebp, esp
.text$mn:00004533                 push    0FFFFFFFFh
.text$mn:00004535                 push    offset __ehhandler$??0?$_Vector_val@U?$_Simple_types@PB_W@std@@@std@@QAE@XZ
.text$mn:0000453A                 mov     eax, large fs:0
.text$mn:00004540                 push    eax
.text$mn:00004541                 push    ecx
.text$mn:00004542                 mov     eax, dword ptr ds:___security_cookie
.text$mn:00004547                 xor     eax, ebp
.text$mn:00004549                 push    eax
.text$mn:0000454A                 lea     eax, [ebp+var_C]
.text$mn:0000454D                 mov     large fs:0, eax
.text$mn:00004553                 mov     [ebp+var_10], ecx
.text$mn:00004556                 mov     ecx, [ebp+var_10] ; this
.text$mn:00004559                 call    ??0_Container_base12@std@@QAE@XZ ; std::_Container_base12::_Container_base12(void)
.text$mn:0000455E                 mov     [ebp+var_4], 0
.text$mn:00004565                 mov     eax, [ebp+var_10]
.text$mn:00004568                 mov     dword ptr [eax+4], 0
.text$mn:0000456F                 mov     ecx, [ebp+var_10]
.text$mn:00004572                 mov     dword ptr [ecx+8], 0
.text$mn:00004579                 mov     edx, [ebp+var_10]
.text$mn:0000457C                 mov     dword ptr [edx+0Ch], 0
.text$mn:00004583                 mov     [ebp+var_4], 0FFFFFFFFh
.text$mn:0000458A                 mov     eax, [ebp+var_10]
.text$mn:0000458D                 mov     ecx, [ebp+var_C]
.text$mn:00004590                 mov     large fs:0, ecx
.text$mn:00004597                 pop     ecx
.text$mn:00004598                 mov     esp, ebp
.text$mn:0000459A                 pop     ebp
.text$mn:0000459B                 retn
.text$mn:0000459B ??0?$_Vector_val@U?$_Simple_types@PB_W@std@@@std@@QAE@XZ endp
.text$mn:0000459B
.text$mn:0000459B _text$mn        ends
.text$mn:0000459B
.text$x:0000459C ; ===========================================================================
.text$x:0000459C
.text$x:0000459C ; Segment type: Pure code
.text$x:0000459C ; Segment permissions: Read/Execute
.text$x:0000459C _text$x         segment para public 'CODE' use32
.text$x:0000459C                 assume cs:_text$x
.text$x:0000459C                 ;org 459Ch
.text$x:0000459C ; COMDAT (pick associative to section at 4530)
.text$x:0000459C                 assume es:nothing, ss:nothing, ds:_data, fs:nothing, gs:nothing
.text$x:0000459C
.text$x:0000459C ; =============== S U B R O U T I N E =======================================
.text$x:0000459C
.text$x:0000459C
.text$x:0000459C __unwindfunclet$??0?$_Vector_val@U?$_Simple_types@PB_W@std@@@std@@QAE@XZ$0 proc near
.text$x:0000459C                                         ; DATA XREF: .xdata$x:00009628o
.text$x:0000459C                 mov     ecx, [ebp-10h]  ; this
.text$x:0000459F                 jmp     ??1_Container_base12@std@@QAE@XZ ; std::_Container_base12::~_Container_base12(void)
.text$x:0000459F __unwindfunclet$??0?$_Vector_val@U?$_Simple_types@PB_W@std@@@std@@QAE@XZ$0 endp
.text$x:0000459F
.text$x:000045A4
.text$x:000045A4 ; =============== S U B R O U T I N E =======================================
.text$x:000045A4
.text$x:000045A4
.text$x:000045A4 __ehhandler$??0?$_Vector_val@U?$_Simple_types@PB_W@std@@@std@@QAE@XZ proc near
.text$x:000045A4                                         ; DATA XREF: std::_Vector_val<std::_Simple_types<wchar_t const *>>::_Vector_val<std::_Simple_types<wchar_t const *>>(void)+5o
.text$x:000045A4
.text$x:000045A4 arg_4           = dword ptr  8
.text$x:000045A4
.text$x:000045A4                 mov     edx, [esp+arg_4]
.text$x:000045A8                 lea     eax, [edx+0Ch]
.text$x:000045AB                 mov     ecx, [edx-8]
.text$x:000045AE                 xor     ecx, eax
.text$x:000045B0                 call    @__security_check_cookie@4 ; __security_check_cookie(x)
.text$x:000045B5                 mov     eax, offset __ehfuncinfo$??0?$_Vector_val@U?$_Simple_types@PB_W@std@@@std@@QAE@XZ
.text$x:000045BA                 jmp     ___CxxFrameHandler3
.text$x:000045BA __ehhandler$??0?$_Vector_val@U?$_Simple_types@PB_W@std@@@std@@QAE@XZ endp
.text$x:000045BA
.text$x:000045BA ; ---------------------------------------------------------------------------
.text$x:000045BF                 align 10h
.text$x:000045BF _text$x         ends
.text$x:000045BF
.text$mn:000045C0 ; ===========================================================================
.text$mn:000045C0
.text$mn:000045C0 ; Segment type: Pure code
.text$mn:000045C0 ; Segment permissions: Read/Execute
.text$mn:000045C0 _text$mn        segment para public 'CODE' use32
.text$mn:000045C0                 assume cs:_text$mn
.text$mn:000045C0                 ;org 45C0h
.text$mn:000045C0 ; COMDAT (pick any)
.text$mn:000045C0                 assume es:nothing, ss:nothing, ds:_data, fs:nothing, gs:nothing
.text$mn:000045C0
.text$mn:000045C0 ; =============== S U B R O U T I N E =======================================
.text$mn:000045C0
.text$mn:000045C0 ; Attributes: bp-based frame
.text$mn:000045C0
.text$mn:000045C0 ; public: __thiscall std::_Vector_val<struct std::_Simple_types<struct FunctionValues>>::_Vector_val<struct std::_Simple_types<struct FunctionValues>>(void)
.text$mn:000045C0                 public ??0?$_Vector_val@U?$_Simple_types@UFunctionValues@@@std@@@std@@QAE@XZ
.text$mn:000045C0 ??0?$_Vector_val@U?$_Simple_types@UFunctionValues@@@std@@@std@@QAE@XZ proc near
.text$mn:000045C0                                         ; CODE XREF: std::_Vector_alloc<0,std::_Vec_base_types<FunctionValues,std::allocator<FunctionValues>>>::_Vector_alloc<0,std::_Vec_base_types<FunctionValues,std::allocator<FunctionValues>>>(std::allocator<FunctionValues> const &)+29p
.text$mn:000045C0
.text$mn:000045C0 var_10          = dword ptr -10h
.text$mn:000045C0 var_C           = dword ptr -0Ch
.text$mn:000045C0 var_4           = dword ptr -4
.text$mn:000045C0
.text$mn:000045C0                 push    ebp
.text$mn:000045C1                 mov     ebp, esp
.text$mn:000045C3                 push    0FFFFFFFFh
.text$mn:000045C5                 push    offset __ehhandler$??0?$_Vector_val@U?$_Simple_types@UFunctionValues@@@std@@@std@@QAE@XZ
.text$mn:000045CA                 mov     eax, large fs:0
.text$mn:000045D0                 push    eax
.text$mn:000045D1                 push    ecx
.text$mn:000045D2                 mov     eax, dword ptr ds:___security_cookie
.text$mn:000045D7                 xor     eax, ebp
.text$mn:000045D9                 push    eax
.text$mn:000045DA                 lea     eax, [ebp+var_C]
.text$mn:000045DD                 mov     large fs:0, eax
.text$mn:000045E3                 mov     [ebp+var_10], ecx
.text$mn:000045E6                 mov     ecx, [ebp+var_10] ; this
.text$mn:000045E9                 call    ??0_Container_base12@std@@QAE@XZ ; std::_Container_base12::_Container_base12(void)
.text$mn:000045EE                 mov     [ebp+var_4], 0
.text$mn:000045F5                 mov     eax, [ebp+var_10]
.text$mn:000045F8                 mov     dword ptr [eax+4], 0
.text$mn:000045FF                 mov     ecx, [ebp+var_10]
.text$mn:00004602                 mov     dword ptr [ecx+8], 0
.text$mn:00004609                 mov     edx, [ebp+var_10]
.text$mn:0000460C                 mov     dword ptr [edx+0Ch], 0
.text$mn:00004613                 mov     [ebp+var_4], 0FFFFFFFFh
.text$mn:0000461A                 mov     eax, [ebp+var_10]
.text$mn:0000461D                 mov     ecx, [ebp+var_C]
.text$mn:00004620                 mov     large fs:0, ecx
.text$mn:00004627                 pop     ecx
.text$mn:00004628                 mov     esp, ebp
.text$mn:0000462A                 pop     ebp
.text$mn:0000462B                 retn
.text$mn:0000462B ??0?$_Vector_val@U?$_Simple_types@UFunctionValues@@@std@@@std@@QAE@XZ endp
.text$mn:0000462B
.text$mn:0000462B _text$mn        ends
.text$mn:0000462B
.text$x:0000462C ; ===========================================================================
.text$x:0000462C
.text$x:0000462C ; Segment type: Pure code
.text$x:0000462C ; Segment permissions: Read/Execute
.text$x:0000462C _text$x         segment para public 'CODE' use32
.text$x:0000462C                 assume cs:_text$x
.text$x:0000462C                 ;org 462Ch
.text$x:0000462C ; COMDAT (pick associative to section at 45C0)
.text$x:0000462C                 assume es:nothing, ss:nothing, ds:_data, fs:nothing, gs:nothing
.text$x:0000462C
.text$x:0000462C ; =============== S U B R O U T I N E =======================================
.text$x:0000462C
.text$x:0000462C
.text$x:0000462C __unwindfunclet$??0?$_Vector_val@U?$_Simple_types@UFunctionValues@@@std@@@std@@QAE@XZ$0 proc near
.text$x:0000462C                                         ; DATA XREF: .xdata$x:00009B44o
.text$x:0000462C                 mov     ecx, [ebp-10h]  ; this
.text$x:0000462F                 jmp     ??1_Container_base12@std@@QAE@XZ ; std::_Container_base12::~_Container_base12(void)
.text$x:0000462F __unwindfunclet$??0?$_Vector_val@U?$_Simple_types@UFunctionValues@@@std@@@std@@QAE@XZ$0 endp
.text$x:0000462F
.text$x:00004634
.text$x:00004634 ; =============== S U B R O U T I N E =======================================
.text$x:00004634
.text$x:00004634
.text$x:00004634 __ehhandler$??0?$_Vector_val@U?$_Simple_types@UFunctionValues@@@std@@@std@@QAE@XZ proc near
.text$x:00004634                                         ; DATA XREF: std::_Vector_val<std::_Simple_types<FunctionValues>>::_Vector_val<std::_Simple_types<FunctionValues>>(void)+5o
.text$x:00004634
.text$x:00004634 arg_4           = dword ptr  8
.text$x:00004634
.text$x:00004634                 mov     edx, [esp+arg_4]
.text$x:00004638                 lea     eax, [edx+0Ch]
.text$x:0000463B                 mov     ecx, [edx-8]
.text$x:0000463E                 xor     ecx, eax
.text$x:00004640                 call    @__security_check_cookie@4 ; __security_check_cookie(x)
.text$x:00004645                 mov     eax, offset __ehfuncinfo$??0?$_Vector_val@U?$_Simple_types@UFunctionValues@@@std@@@std@@QAE@XZ
.text$x:0000464A                 jmp     ___CxxFrameHandler3
.text$x:0000464A __ehhandler$??0?$_Vector_val@U?$_Simple_types@UFunctionValues@@@std@@@std@@QAE@XZ endp
.text$x:0000464A
.text$x:0000464A ; ---------------------------------------------------------------------------
.text$x:0000464F                 align 10h
.text$x:0000464F _text$x         ends
.text$x:0000464F
.text$mn:00004650 ; ===========================================================================
.text$mn:00004650
.text$mn:00004650 ; Segment type: Pure code
.text$mn:00004650 ; Segment permissions: Read/Execute
.text$mn:00004650 _text$mn        segment para public 'CODE' use32
.text$mn:00004650                 assume cs:_text$mn
.text$mn:00004650                 ;org 4650h
.text$mn:00004650 ; COMDAT (pick any)
.text$mn:00004650                 assume es:nothing, ss:nothing, ds:_data, fs:nothing, gs:nothing
.text$mn:00004650
.text$mn:00004650 ; =============== S U B R O U T I N E =======================================
.text$mn:00004650
.text$mn:00004650 ; Attributes: bp-based frame
.text$mn:00004650
.text$mn:00004650 ; public: __thiscall std::_Vector_val<struct std::_Simple_types<struct Token>>::_Vector_val<struct std::_Simple_types<struct Token>>(void)
.text$mn:00004650                 public ??0?$_Vector_val@U?$_Simple_types@UToken@@@std@@@std@@QAE@XZ
.text$mn:00004650 ??0?$_Vector_val@U?$_Simple_types@UToken@@@std@@@std@@QAE@XZ proc near
.text$mn:00004650                                         ; CODE XREF: std::_Vector_alloc<0,std::_Vec_base_types<Token,std::allocator<Token>>>::_Vector_alloc<0,std::_Vec_base_types<Token,std::allocator<Token>>>(std::allocator<Token> const &)+29p
.text$mn:00004650
.text$mn:00004650 var_10          = dword ptr -10h
.text$mn:00004650 var_C           = dword ptr -0Ch
.text$mn:00004650 var_4           = dword ptr -4
.text$mn:00004650
.text$mn:00004650                 push    ebp
.text$mn:00004651                 mov     ebp, esp
.text$mn:00004653                 push    0FFFFFFFFh
.text$mn:00004655                 push    offset __ehhandler$??0?$_Vector_val@U?$_Simple_types@UToken@@@std@@@std@@QAE@XZ
.text$mn:0000465A                 mov     eax, large fs:0
.text$mn:00004660                 push    eax
.text$mn:00004661                 push    ecx
.text$mn:00004662                 mov     eax, dword ptr ds:___security_cookie
.text$mn:00004667                 xor     eax, ebp
.text$mn:00004669                 push    eax
.text$mn:0000466A                 lea     eax, [ebp+var_C]
.text$mn:0000466D                 mov     large fs:0, eax
.text$mn:00004673                 mov     [ebp+var_10], ecx
.text$mn:00004676                 mov     ecx, [ebp+var_10] ; this
.text$mn:00004679                 call    ??0_Container_base12@std@@QAE@XZ ; std::_Container_base12::_Container_base12(void)
.text$mn:0000467E                 mov     [ebp+var_4], 0
.text$mn:00004685                 mov     eax, [ebp+var_10]
.text$mn:00004688                 mov     dword ptr [eax+4], 0
.text$mn:0000468F                 mov     ecx, [ebp+var_10]
.text$mn:00004692                 mov     dword ptr [ecx+8], 0
.text$mn:00004699                 mov     edx, [ebp+var_10]
.text$mn:0000469C                 mov     dword ptr [edx+0Ch], 0
.text$mn:000046A3                 mov     [ebp+var_4], 0FFFFFFFFh
.text$mn:000046AA                 mov     eax, [ebp+var_10]
.text$mn:000046AD                 mov     ecx, [ebp+var_C]
.text$mn:000046B0                 mov     large fs:0, ecx
.text$mn:000046B7                 pop     ecx
.text$mn:000046B8                 mov     esp, ebp
.text$mn:000046BA                 pop     ebp
.text$mn:000046BB                 retn
.text$mn:000046BB ??0?$_Vector_val@U?$_Simple_types@UToken@@@std@@@std@@QAE@XZ endp
.text$mn:000046BB
.text$mn:000046BB _text$mn        ends
.text$mn:000046BB
.text$x:000046BC ; ===========================================================================
.text$x:000046BC
.text$x:000046BC ; Segment type: Pure code
.text$x:000046BC ; Segment permissions: Read/Execute
.text$x:000046BC _text$x         segment para public 'CODE' use32
.text$x:000046BC                 assume cs:_text$x
.text$x:000046BC                 ;org 46BCh
.text$x:000046BC ; COMDAT (pick associative to section at 4650)
.text$x:000046BC                 assume es:nothing, ss:nothing, ds:_data, fs:nothing, gs:nothing
.text$x:000046BC
.text$x:000046BC ; =============== S U B R O U T I N E =======================================
.text$x:000046BC
.text$x:000046BC
.text$x:000046BC __unwindfunclet$??0?$_Vector_val@U?$_Simple_types@UToken@@@std@@@std@@QAE@XZ$0 proc near
.text$x:000046BC                                         ; DATA XREF: .xdata$x:000099B8o
.text$x:000046BC                 mov     ecx, [ebp-10h]  ; this
.text$x:000046BF                 jmp     ??1_Container_base12@std@@QAE@XZ ; std::_Container_base12::~_Container_base12(void)
.text$x:000046BF __unwindfunclet$??0?$_Vector_val@U?$_Simple_types@UToken@@@std@@@std@@QAE@XZ$0 endp
.text$x:000046BF
.text$x:000046C4
.text$x:000046C4 ; =============== S U B R O U T I N E =======================================
.text$x:000046C4
.text$x:000046C4
.text$x:000046C4 __ehhandler$??0?$_Vector_val@U?$_Simple_types@UToken@@@std@@@std@@QAE@XZ proc near
.text$x:000046C4                                         ; DATA XREF: std::_Vector_val<std::_Simple_types<Token>>::_Vector_val<std::_Simple_types<Token>>(void)+5o
.text$x:000046C4
.text$x:000046C4 arg_4           = dword ptr  8
.text$x:000046C4
.text$x:000046C4                 mov     edx, [esp+arg_4]
.text$x:000046C8                 lea     eax, [edx+0Ch]
.text$x:000046CB                 mov     ecx, [edx-8]
.text$x:000046CE                 xor     ecx, eax
.text$x:000046D0                 call    @__security_check_cookie@4 ; __security_check_cookie(x)
.text$x:000046D5                 mov     eax, offset __ehfuncinfo$??0?$_Vector_val@U?$_Simple_types@UToken@@@std@@@std@@QAE@XZ
.text$x:000046DA                 jmp     ___CxxFrameHandler3
.text$x:000046DA __ehhandler$??0?$_Vector_val@U?$_Simple_types@UToken@@@std@@@std@@QAE@XZ endp
.text$x:000046DA
.text$x:000046DA ; ---------------------------------------------------------------------------
.text$x:000046DF                 align 10h
.text$x:000046DF _text$x         ends
.text$x:000046DF
.text$mn:000046E0 ; ===========================================================================
.text$mn:000046E0
.text$mn:000046E0 ; Segment type: Pure code
.text$mn:000046E0 ; Segment permissions: Read/Execute
.text$mn:000046E0 _text$mn        segment para public 'CODE' use32
.text$mn:000046E0                 assume cs:_text$mn
.text$mn:000046E0                 ;org 46E0h
.text$mn:000046E0 ; COMDAT (pick any)
.text$mn:000046E0                 assume es:nothing, ss:nothing, ds:_data, fs:nothing, gs:nothing
.text$mn:000046E0
.text$mn:000046E0 ; =============== S U B R O U T I N E =======================================
.text$mn:000046E0
.text$mn:000046E0 ; Attributes: bp-based frame
.text$mn:000046E0
.text$mn:000046E0 ; public: __thiscall std::_Wrap_alloc<class std::allocator<char>>::_Wrap_alloc<class std::allocator<char>>(void)
.text$mn:000046E0                 public ??0?$_Wrap_alloc@V?$allocator@D@std@@@std@@QAE@XZ
.text$mn:000046E0 ??0?$_Wrap_alloc@V?$allocator@D@std@@@std@@QAE@XZ proc near
.text$mn:000046E0                                         ; CODE XREF: std::_String_alloc<0,std::_String_base_types<char,std::allocator<char>>>::_Getal(void)+Ap
.text$mn:000046E0
.text$mn:000046E0 var_4           = dword ptr -4
.text$mn:000046E0
.text$mn:000046E0                 push    ebp
.text$mn:000046E1                 mov     ebp, esp
.text$mn:000046E3                 push    ecx
.text$mn:000046E4                 mov     [ebp+var_4], ecx
.text$mn:000046E7                 mov     ecx, [ebp+var_4]
.text$mn:000046EA                 call    ??0?$allocator@D@std@@QAE@XZ ; std::allocator<char>::allocator<char>(void)
.text$mn:000046EF                 mov     eax, [ebp+var_4]
.text$mn:000046F2                 mov     esp, ebp
.text$mn:000046F4                 pop     ebp
.text$mn:000046F5                 retn
.text$mn:000046F5 ??0?$_Wrap_alloc@V?$allocator@D@std@@@std@@QAE@XZ endp
.text$mn:000046F5
.text$mn:000046F5 ; ---------------------------------------------------------------------------
.text$mn:000046F6                 align 4
.text$mn:000046F6 _text$mn        ends
.text$mn:000046F6
.text$mn:000046F8 ; ===========================================================================
.text$mn:000046F8
.text$mn:000046F8 ; Segment type: Pure code
.text$mn:000046F8 ; Segment permissions: Read/Execute
.text$mn:000046F8 _text$mn        segment para public 'CODE' use32
.text$mn:000046F8                 assume cs:_text$mn
.text$mn:000046F8                 ;org 46F8h
.text$mn:000046F8 ; COMDAT (pick any)
.text$mn:000046F8                 assume es:nothing, ss:nothing, ds:_data, fs:nothing, gs:nothing
.text$mn:000046F8
.text$mn:000046F8 ; =============== S U B R O U T I N E =======================================
.text$mn:000046F8
.text$mn:000046F8 ; Attributes: bp-based frame
.text$mn:000046F8
.text$mn:000046F8 ; public: __thiscall std::_Wrap_alloc<class std::allocator<wchar_t const *>>::_Wrap_alloc<class std::allocator<wchar_t const *>>(class std::allocator<wchar_t const *> const &)
.text$mn:000046F8                 public ??0?$_Wrap_alloc@V?$allocator@PB_W@std@@@std@@QAE@ABV?$allocator@PB_W@1@@Z
.text$mn:000046F8 ??0?$_Wrap_alloc@V?$allocator@PB_W@std@@@std@@QAE@ABV?$allocator@PB_W@1@@Z proc near
.text$mn:000046F8                                         ; CODE XREF: std::_Wrap_alloc<std::allocator<wchar_t const *>>::select_on_container_copy_construction(void)+1Dp
.text$mn:000046F8
.text$mn:000046F8 var_4           = dword ptr -4
.text$mn:000046F8 arg_0           = dword ptr  8
.text$mn:000046F8
.text$mn:000046F8                 push    ebp
.text$mn:000046F9                 mov     ebp, esp
.text$mn:000046FB                 push    ecx
.text$mn:000046FC                 mov     [ebp+var_4], ecx
.text$mn:000046FF                 mov     eax, [ebp+arg_0]
.text$mn:00004702                 push    eax
.text$mn:00004703                 mov     ecx, [ebp+var_4]
.text$mn:00004706                 call    ??0?$allocator@PB_W@std@@QAE@ABV01@@Z ; std::allocator<wchar_t const *>::allocator<wchar_t const *>(std::allocator<wchar_t const *> const &)
.text$mn:0000470B                 mov     eax, [ebp+var_4]
.text$mn:0000470E                 mov     esp, ebp
.text$mn:00004710                 pop     ebp
.text$mn:00004711                 retn    4
.text$mn:00004711 ??0?$_Wrap_alloc@V?$allocator@PB_W@std@@@std@@QAE@ABV?$allocator@PB_W@1@@Z endp
.text$mn:00004711
.text$mn:00004711 _text$mn        ends
.text$mn:00004711
.text$mn:00004714 ; ===========================================================================
.text$mn:00004714
.text$mn:00004714 ; Segment type: Pure code
.text$mn:00004714 ; Segment permissions: Read/Execute
.text$mn:00004714 _text$mn        segment para public 'CODE' use32
.text$mn:00004714                 assume cs:_text$mn
.text$mn:00004714                 ;org 4714h
.text$mn:00004714 ; COMDAT (pick any)
.text$mn:00004714                 assume es:nothing, ss:nothing, ds:_data, fs:nothing, gs:nothing
.text$mn:00004714
.text$mn:00004714 ; =============== S U B R O U T I N E =======================================
.text$mn:00004714
.text$mn:00004714 ; Attributes: bp-based frame
.text$mn:00004714
.text$mn:00004714 ; public: __thiscall std::_Wrap_alloc<class std::allocator<wchar_t const *>>::_Wrap_alloc<class std::allocator<wchar_t const *>>(void)
.text$mn:00004714                 public ??0?$_Wrap_alloc@V?$allocator@PB_W@std@@@std@@QAE@XZ
.text$mn:00004714 ??0?$_Wrap_alloc@V?$allocator@PB_W@std@@@std@@QAE@XZ proc near
.text$mn:00004714                                         ; CODE XREF: std::_Vector_alloc<0,std::_Vec_base_types<wchar_t const *,std::allocator<wchar_t const *>>>::_Getal(void)+Ap
.text$mn:00004714
.text$mn:00004714 var_4           = dword ptr -4
.text$mn:00004714
.text$mn:00004714                 push    ebp
.text$mn:00004715                 mov     ebp, esp
.text$mn:00004717                 push    ecx
.text$mn:00004718                 mov     [ebp+var_4], ecx
.text$mn:0000471B                 mov     ecx, [ebp+var_4]
.text$mn:0000471E                 call    ??0?$allocator@PB_W@std@@QAE@XZ ; std::allocator<wchar_t const *>::allocator<wchar_t const *>(void)
.text$mn:00004723                 mov     eax, [ebp+var_4]
.text$mn:00004726                 mov     esp, ebp
.text$mn:00004728                 pop     ebp
.text$mn:00004729                 retn
.text$mn:00004729 ??0?$_Wrap_alloc@V?$allocator@PB_W@std@@@std@@QAE@XZ endp
.text$mn:00004729
.text$mn:00004729 ; ---------------------------------------------------------------------------
.text$mn:0000472A                 align 4
.text$mn:0000472A _text$mn        ends
.text$mn:0000472A
.text$mn:0000472C ; ===========================================================================
.text$mn:0000472C
.text$mn:0000472C ; Segment type: Pure code
.text$mn:0000472C ; Segment permissions: Read/Execute
.text$mn:0000472C _text$mn        segment para public 'CODE' use32
.text$mn:0000472C                 assume cs:_text$mn
.text$mn:0000472C                 ;org 472Ch
.text$mn:0000472C ; COMDAT (pick any)
.text$mn:0000472C                 assume es:nothing, ss:nothing, ds:_data, fs:nothing, gs:nothing
.text$mn:0000472C
.text$mn:0000472C ; =============== S U B R O U T I N E =======================================
.text$mn:0000472C
.text$mn:0000472C ; Attributes: bp-based frame
.text$mn:0000472C
.text$mn:0000472C ; public: __thiscall std::_Wrap_alloc<class std::allocator<struct FunctionValues>>::_Wrap_alloc<class std::allocator<struct FunctionValues>>(void)
.text$mn:0000472C                 public ??0?$_Wrap_alloc@V?$allocator@UFunctionValues@@@std@@@std@@QAE@XZ
.text$mn:0000472C ??0?$_Wrap_alloc@V?$allocator@UFunctionValues@@@std@@@std@@QAE@XZ proc near
.text$mn:0000472C                                         ; CODE XREF: std::_Vector_alloc<0,std::_Vec_base_types<FunctionValues,std::allocator<FunctionValues>>>::_Getal(void)+Ap
.text$mn:0000472C
.text$mn:0000472C var_4           = dword ptr -4
.text$mn:0000472C
.text$mn:0000472C                 push    ebp
.text$mn:0000472D                 mov     ebp, esp
.text$mn:0000472F                 push    ecx
.text$mn:00004730                 mov     [ebp+var_4], ecx
.text$mn:00004733                 mov     ecx, [ebp+var_4]
.text$mn:00004736                 call    ??0?$allocator@UFunctionValues@@@std@@QAE@XZ ; std::allocator<FunctionValues>::allocator<FunctionValues>(void)
.text$mn:0000473B                 mov     eax, [ebp+var_4]
.text$mn:0000473E                 mov     esp, ebp
.text$mn:00004740                 pop     ebp
.text$mn:00004741                 retn
.text$mn:00004741 ??0?$_Wrap_alloc@V?$allocator@UFunctionValues@@@std@@@std@@QAE@XZ endp
.text$mn:00004741
.text$mn:00004741 ; ---------------------------------------------------------------------------
.text$mn:00004742                 align 4
.text$mn:00004742 _text$mn        ends
.text$mn:00004742
.text$mn:00004744 ; ===========================================================================
.text$mn:00004744
.text$mn:00004744 ; Segment type: Pure code
.text$mn:00004744 ; Segment permissions: Read/Execute
.text$mn:00004744 _text$mn        segment para public 'CODE' use32
.text$mn:00004744                 assume cs:_text$mn
.text$mn:00004744                 ;org 4744h
.text$mn:00004744 ; COMDAT (pick any)
.text$mn:00004744                 assume es:nothing, ss:nothing, ds:_data, fs:nothing, gs:nothing
.text$mn:00004744
.text$mn:00004744 ; =============== S U B R O U T I N E =======================================
.text$mn:00004744
.text$mn:00004744 ; Attributes: bp-based frame
.text$mn:00004744
.text$mn:00004744 ; public: __thiscall std::_Wrap_alloc<class std::allocator<struct Token>>::_Wrap_alloc<class std::allocator<struct Token>>(void)
.text$mn:00004744                 public ??0?$_Wrap_alloc@V?$allocator@UToken@@@std@@@std@@QAE@XZ
.text$mn:00004744 ??0?$_Wrap_alloc@V?$allocator@UToken@@@std@@@std@@QAE@XZ proc near
.text$mn:00004744                                         ; CODE XREF: std::_Vector_alloc<0,std::_Vec_base_types<Token,std::allocator<Token>>>::_Getal(void)+Ap
.text$mn:00004744
.text$mn:00004744 var_4           = dword ptr -4
.text$mn:00004744
.text$mn:00004744                 push    ebp
.text$mn:00004745                 mov     ebp, esp
.text$mn:00004747                 push    ecx
.text$mn:00004748                 mov     [ebp+var_4], ecx
.text$mn:0000474B                 mov     ecx, [ebp+var_4]
.text$mn:0000474E                 call    ??0?$allocator@UToken@@@std@@QAE@XZ ; std::allocator<Token>::allocator<Token>(void)
.text$mn:00004753                 mov     eax, [ebp+var_4]
.text$mn:00004756                 mov     esp, ebp
.text$mn:00004758                 pop     ebp
.text$mn:00004759                 retn
.text$mn:00004759 ??0?$_Wrap_alloc@V?$allocator@UToken@@@std@@@std@@QAE@XZ endp
.text$mn:00004759
.text$mn:00004759 ; ---------------------------------------------------------------------------
.text$mn:0000475A                 align 4
.text$mn:0000475A _text$mn        ends
.text$mn:0000475A
.text$mn:0000475C ; ===========================================================================
.text$mn:0000475C
.text$mn:0000475C ; Segment type: Pure code
.text$mn:0000475C ; Segment permissions: Read/Execute
.text$mn:0000475C _text$mn        segment para public 'CODE' use32
.text$mn:0000475C                 assume cs:_text$mn
.text$mn:0000475C                 ;org 475Ch
.text$mn:0000475C ; COMDAT (pick any)
.text$mn:0000475C                 assume es:nothing, ss:nothing, ds:_data, fs:nothing, gs:nothing
.text$mn:0000475C
.text$mn:0000475C ; =============== S U B R O U T I N E =======================================
.text$mn:0000475C
.text$mn:0000475C ; Attributes: bp-based frame
.text$mn:0000475C
.text$mn:0000475C ; public: __thiscall std::_Wrap_alloc<class std::allocator<struct std::_Container_proxy>>::_Wrap_alloc<class std::allocator<struct std::_Container_proxy>>(void)
.text$mn:0000475C                 public ??0?$_Wrap_alloc@V?$allocator@U_Container_proxy@std@@@std@@@std@@QAE@XZ
.text$mn:0000475C ??0?$_Wrap_alloc@V?$allocator@U_Container_proxy@std@@@std@@@std@@QAE@XZ proc near
.text$mn:0000475C                                         ; CODE XREF: std::_Vector_alloc<0,std::_Vec_base_types<wchar_t const *,std::allocator<wchar_t const *>>>::_Alloc_proxy(void)+Cp
.text$mn:0000475C                                         ; std::_Vector_alloc<0,std::_Vec_base_types<FunctionValues,std::allocator<FunctionValues>>>::_Alloc_proxy(void)+Cp ...
.text$mn:0000475C
.text$mn:0000475C var_4           = dword ptr -4
.text$mn:0000475C
.text$mn:0000475C                 push    ebp
.text$mn:0000475D                 mov     ebp, esp
.text$mn:0000475F                 push    ecx
.text$mn:00004760                 mov     [ebp+var_4], ecx
.text$mn:00004763                 mov     ecx, [ebp+var_4]
.text$mn:00004766                 call    ??0?$allocator@U_Container_proxy@std@@@std@@QAE@XZ ; std::allocator<std::_Container_proxy>::allocator<std::_Container_proxy>(void)
.text$mn:0000476B                 mov     eax, [ebp+var_4]
.text$mn:0000476E                 mov     esp, ebp
.text$mn:00004770                 pop     ebp
.text$mn:00004771                 retn
.text$mn:00004771 ??0?$_Wrap_alloc@V?$allocator@U_Container_proxy@std@@@std@@@std@@QAE@XZ endp
.text$mn:00004771
.text$mn:00004771 ; ---------------------------------------------------------------------------
.text$mn:00004772                 align 4
.text$mn:00004772 _text$mn        ends
.text$mn:00004772
.text$mn:00004774 ; ===========================================================================
.text$mn:00004774
.text$mn:00004774 ; Segment type: Pure code
.text$mn:00004774 ; Segment permissions: Read/Execute
.text$mn:00004774 _text$mn        segment para public 'CODE' use32
.text$mn:00004774                 assume cs:_text$mn
.text$mn:00004774                 ;org 4774h
.text$mn:00004774 ; COMDAT (pick any)
.text$mn:00004774                 assume es:nothing, ss:nothing, ds:_data, fs:nothing, gs:nothing
.text$mn:00004774
.text$mn:00004774 ; =============== S U B R O U T I N E =======================================
.text$mn:00004774
.text$mn:00004774 ; Attributes: bp-based frame
.text$mn:00004774
.text$mn:00004774 ; public: __thiscall std::_Wrap_alloc<class std::allocator<class std::vector<wchar_t const *, class std::allocator<wchar_t const *>>>>::_Wrap_alloc<class std::allocator<class std::vector<wchar_t const *, class std::allocator<wchar_t const *>>>>(void)
.text$mn:00004774                 public ??0?$_Wrap_alloc@V?$allocator@V?$vector@PB_WV?$allocator@PB_W@std@@@std@@@std@@@std@@QAE@XZ
.text$mn:00004774 ??0?$_Wrap_alloc@V?$allocator@V?$vector@PB_WV?$allocator@PB_W@std@@@std@@@std@@@std@@QAE@XZ proc near
.text$mn:00004774                                         ; CODE XREF: std::_Vector_alloc<0,std::_Vec_base_types<std::vector<wchar_t const *,std::allocator<wchar_t const *>>,std::allocator<std::vector<wchar_t const *,std::allocator<wchar_t const *>>>>>::_Getal(void)+Ap
.text$mn:00004774
.text$mn:00004774 var_4           = dword ptr -4
.text$mn:00004774
.text$mn:00004774                 push    ebp
.text$mn:00004775                 mov     ebp, esp
.text$mn:00004777                 push    ecx
.text$mn:00004778                 mov     [ebp+var_4], ecx
.text$mn:0000477B                 mov     ecx, [ebp+var_4]
.text$mn:0000477E                 call    ??0?$allocator@V?$vector@PB_WV?$allocator@PB_W@std@@@std@@@std@@QAE@XZ ; std::allocator<std::vector<wchar_t const *,std::allocator<wchar_t const *>>>::allocator<std::vector<wchar_t const *,std::allocator<wchar_t const *>>>(void)
.text$mn:00004783                 mov     eax, [ebp+var_4]
.text$mn:00004786                 mov     esp, ebp
.text$mn:00004788                 pop     ebp
.text$mn:00004789                 retn
.text$mn:00004789 ??0?$_Wrap_alloc@V?$allocator@V?$vector@PB_WV?$allocator@PB_W@std@@@std@@@std@@@std@@QAE@XZ endp
.text$mn:00004789
.text$mn:00004789 ; ---------------------------------------------------------------------------
.text$mn:0000478A                 align 4
.text$mn:0000478A _text$mn        ends
.text$mn:0000478A
.text$mn:0000478C ; ===========================================================================
.text$mn:0000478C
.text$mn:0000478C ; Segment type: Pure code
.text$mn:0000478C ; Segment permissions: Read/Execute
.text$mn:0000478C _text$mn        segment para public 'CODE' use32
.text$mn:0000478C                 assume cs:_text$mn
.text$mn:0000478C                 ;org 478Ch
.text$mn:0000478C ; COMDAT (pick any)
.text$mn:0000478C                 assume es:nothing, ss:nothing, ds:_data, fs:nothing, gs:nothing
.text$mn:0000478C
.text$mn:0000478C ; =============== S U B R O U T I N E =======================================
.text$mn:0000478C
.text$mn:0000478C ; Attributes: bp-based frame
.text$mn:0000478C
.text$mn:0000478C ; public: __thiscall std::allocator<char>::allocator<char>(void)
.text$mn:0000478C                 public ??0?$allocator@D@std@@QAE@XZ
.text$mn:0000478C ??0?$allocator@D@std@@QAE@XZ proc near  ; CODE XREF: std::_Wrap_alloc<std::allocator<char>>::_Wrap_alloc<std::allocator<char>>(void)+Ap
.text$mn:0000478C                                         ; std::basic_string<char,std::char_traits<char>,std::allocator<char>>::basic_string<char,std::char_traits<char>,std::allocator<char>>(char const *)+2Bp
.text$mn:0000478C
.text$mn:0000478C var_4           = dword ptr -4
.text$mn:0000478C
.text$mn:0000478C                 push    ebp
.text$mn:0000478D                 mov     ebp, esp
.text$mn:0000478F                 push    ecx
.text$mn:00004790                 mov     [ebp+var_4], ecx
.text$mn:00004793                 mov     eax, [ebp+var_4]
.text$mn:00004796                 mov     esp, ebp
.text$mn:00004798                 pop     ebp
.text$mn:00004799                 retn
.text$mn:00004799 ??0?$allocator@D@std@@QAE@XZ endp
.text$mn:00004799
.text$mn:00004799 ; ---------------------------------------------------------------------------
.text$mn:0000479A                 align 4
.text$mn:0000479A _text$mn        ends
.text$mn:0000479A
.text$mn:0000479C ; ===========================================================================
.text$mn:0000479C
.text$mn:0000479C ; Segment type: Pure code
.text$mn:0000479C ; Segment permissions: Read/Execute
.text$mn:0000479C _text$mn        segment para public 'CODE' use32
.text$mn:0000479C                 assume cs:_text$mn
.text$mn:0000479C                 ;org 479Ch
.text$mn:0000479C ; COMDAT (pick any)
.text$mn:0000479C                 assume es:nothing, ss:nothing, ds:_data, fs:nothing, gs:nothing
.text$mn:0000479C
.text$mn:0000479C ; =============== S U B R O U T I N E =======================================
.text$mn:0000479C
.text$mn:0000479C ; Attributes: bp-based frame
.text$mn:0000479C
.text$mn:0000479C ; public: __thiscall std::allocator<wchar_t const *>::allocator<wchar_t const *>(class std::allocator<wchar_t const *> const &)
.text$mn:0000479C                 public ??0?$allocator@PB_W@std@@QAE@ABV01@@Z
.text$mn:0000479C ??0?$allocator@PB_W@std@@QAE@ABV01@@Z proc near
.text$mn:0000479C                                         ; CODE XREF: std::_Wrap_alloc<std::allocator<wchar_t const *>>::_Wrap_alloc<std::allocator<wchar_t const *>>(std::allocator<wchar_t const *> const &)+Ep
.text$mn:0000479C                                         ; std::allocator<wchar_t const *>::select_on_container_copy_construction(void)+Ep
.text$mn:0000479C
.text$mn:0000479C var_4           = dword ptr -4
.text$mn:0000479C
.text$mn:0000479C                 push    ebp
.text$mn:0000479D                 mov     ebp, esp
.text$mn:0000479F                 push    ecx
.text$mn:000047A0                 mov     [ebp+var_4], ecx
.text$mn:000047A3                 mov     eax, [ebp+var_4]
.text$mn:000047A6                 mov     esp, ebp
.text$mn:000047A8                 pop     ebp
.text$mn:000047A9                 retn    4
.text$mn:000047A9 ??0?$allocator@PB_W@std@@QAE@ABV01@@Z endp
.text$mn:000047A9
.text$mn:000047A9 _text$mn        ends
.text$mn:000047A9
.text$mn:000047AC ; ===========================================================================
.text$mn:000047AC
.text$mn:000047AC ; Segment type: Pure code
.text$mn:000047AC ; Segment permissions: Read/Execute
.text$mn:000047AC _text$mn        segment para public 'CODE' use32
.text$mn:000047AC                 assume cs:_text$mn
.text$mn:000047AC                 ;org 47ACh
.text$mn:000047AC ; COMDAT (pick any)
.text$mn:000047AC                 assume es:nothing, ss:nothing, ds:_data, fs:nothing, gs:nothing
.text$mn:000047AC
.text$mn:000047AC ; =============== S U B R O U T I N E =======================================
.text$mn:000047AC
.text$mn:000047AC ; Attributes: bp-based frame
.text$mn:000047AC
.text$mn:000047AC ; public: __thiscall std::allocator<wchar_t const *>::allocator<wchar_t const *>(void)
.text$mn:000047AC                 public ??0?$allocator@PB_W@std@@QAE@XZ
.text$mn:000047AC ??0?$allocator@PB_W@std@@QAE@XZ proc near
.text$mn:000047AC                                         ; CODE XREF: std::_Wrap_alloc<std::allocator<wchar_t const *>>::_Wrap_alloc<std::allocator<wchar_t const *>>(void)+Ap
.text$mn:000047AC                                         ; std::vector<wchar_t const *,std::allocator<wchar_t const *>>::vector<wchar_t const *,std::allocator<wchar_t const *>>(void)+2Bp
.text$mn:000047AC
.text$mn:000047AC var_4           = dword ptr -4
.text$mn:000047AC
.text$mn:000047AC                 push    ebp
.text$mn:000047AD                 mov     ebp, esp
.text$mn:000047AF                 push    ecx
.text$mn:000047B0                 mov     [ebp+var_4], ecx
.text$mn:000047B3                 mov     eax, [ebp+var_4]
.text$mn:000047B6                 mov     esp, ebp
.text$mn:000047B8                 pop     ebp
.text$mn:000047B9                 retn
.text$mn:000047B9 ??0?$allocator@PB_W@std@@QAE@XZ endp
.text$mn:000047B9
.text$mn:000047B9 ; ---------------------------------------------------------------------------
.text$mn:000047BA                 align 4
.text$mn:000047BA _text$mn        ends
.text$mn:000047BA
.text$mn:000047BC ; ===========================================================================
.text$mn:000047BC
.text$mn:000047BC ; Segment type: Pure code
.text$mn:000047BC ; Segment permissions: Read/Execute
.text$mn:000047BC _text$mn        segment para public 'CODE' use32
.text$mn:000047BC                 assume cs:_text$mn
.text$mn:000047BC                 ;org 47BCh
.text$mn:000047BC ; COMDAT (pick any)
.text$mn:000047BC                 assume es:nothing, ss:nothing, ds:_data, fs:nothing, gs:nothing
.text$mn:000047BC
.text$mn:000047BC ; =============== S U B R O U T I N E =======================================
.text$mn:000047BC
.text$mn:000047BC ; Attributes: bp-based frame
.text$mn:000047BC
.text$mn:000047BC ; public: __thiscall std::allocator<struct FunctionValues>::allocator<struct FunctionValues>(void)
.text$mn:000047BC                 public ??0?$allocator@UFunctionValues@@@std@@QAE@XZ
.text$mn:000047BC ??0?$allocator@UFunctionValues@@@std@@QAE@XZ proc near
.text$mn:000047BC                                         ; CODE XREF: std::_Wrap_alloc<std::allocator<FunctionValues>>::_Wrap_alloc<std::allocator<FunctionValues>>(void)+Ap
.text$mn:000047BC                                         ; std::vector<FunctionValues,std::allocator<FunctionValues>>::vector<FunctionValues,std::allocator<FunctionValues>>(void)+2Bp
.text$mn:000047BC
.text$mn:000047BC var_4           = dword ptr -4
.text$mn:000047BC
.text$mn:000047BC                 push    ebp
.text$mn:000047BD                 mov     ebp, esp
.text$mn:000047BF                 push    ecx
.text$mn:000047C0                 mov     [ebp+var_4], ecx
.text$mn:000047C3                 mov     eax, [ebp+var_4]
.text$mn:000047C6                 mov     esp, ebp
.text$mn:000047C8                 pop     ebp
.text$mn:000047C9                 retn
.text$mn:000047C9 ??0?$allocator@UFunctionValues@@@std@@QAE@XZ endp
.text$mn:000047C9
.text$mn:000047C9 ; ---------------------------------------------------------------------------
.text$mn:000047CA                 align 4
.text$mn:000047CA _text$mn        ends
.text$mn:000047CA
.text$mn:000047CC ; ===========================================================================
.text$mn:000047CC
.text$mn:000047CC ; Segment type: Pure code
.text$mn:000047CC ; Segment permissions: Read/Execute
.text$mn:000047CC _text$mn        segment para public 'CODE' use32
.text$mn:000047CC                 assume cs:_text$mn
.text$mn:000047CC                 ;org 47CCh
.text$mn:000047CC ; COMDAT (pick any)
.text$mn:000047CC                 assume es:nothing, ss:nothing, ds:_data, fs:nothing, gs:nothing
.text$mn:000047CC
.text$mn:000047CC ; =============== S U B R O U T I N E =======================================
.text$mn:000047CC
.text$mn:000047CC ; Attributes: bp-based frame
.text$mn:000047CC
.text$mn:000047CC ; public: __thiscall std::allocator<struct Token>::allocator<struct Token>(void)
.text$mn:000047CC                 public ??0?$allocator@UToken@@@std@@QAE@XZ
.text$mn:000047CC ??0?$allocator@UToken@@@std@@QAE@XZ proc near
.text$mn:000047CC                                         ; CODE XREF: std::_Wrap_alloc<std::allocator<Token>>::_Wrap_alloc<std::allocator<Token>>(void)+Ap
.text$mn:000047CC                                         ; std::vector<Token,std::allocator<Token>>::vector<Token,std::allocator<Token>>(void)+2Bp
.text$mn:000047CC
.text$mn:000047CC var_4           = dword ptr -4
.text$mn:000047CC
.text$mn:000047CC                 push    ebp
.text$mn:000047CD                 mov     ebp, esp
.text$mn:000047CF                 push    ecx
.text$mn:000047D0                 mov     [ebp+var_4], ecx
.text$mn:000047D3                 mov     eax, [ebp+var_4]
.text$mn:000047D6                 mov     esp, ebp
.text$mn:000047D8                 pop     ebp
.text$mn:000047D9                 retn
.text$mn:000047D9 ??0?$allocator@UToken@@@std@@QAE@XZ endp
.text$mn:000047D9
.text$mn:000047D9 ; ---------------------------------------------------------------------------
.text$mn:000047DA                 align 4
.text$mn:000047DA _text$mn        ends
.text$mn:000047DA
.text$mn:000047DC ; ===========================================================================
.text$mn:000047DC
.text$mn:000047DC ; Segment type: Pure code
.text$mn:000047DC ; Segment permissions: Read/Execute
.text$mn:000047DC _text$mn        segment para public 'CODE' use32
.text$mn:000047DC                 assume cs:_text$mn
.text$mn:000047DC                 ;org 47DCh
.text$mn:000047DC ; COMDAT (pick any)
.text$mn:000047DC                 assume es:nothing, ss:nothing, ds:_data, fs:nothing, gs:nothing
.text$mn:000047DC
.text$mn:000047DC ; =============== S U B R O U T I N E =======================================
.text$mn:000047DC
.text$mn:000047DC ; Attributes: bp-based frame
.text$mn:000047DC
.text$mn:000047DC ; public: __thiscall std::allocator<struct std::_Container_proxy>::allocator<struct std::_Container_proxy>(void)
.text$mn:000047DC                 public ??0?$allocator@U_Container_proxy@std@@@std@@QAE@XZ
.text$mn:000047DC ??0?$allocator@U_Container_proxy@std@@@std@@QAE@XZ proc near
.text$mn:000047DC                                         ; CODE XREF: std::_Wrap_alloc<std::allocator<std::_Container_proxy>>::_Wrap_alloc<std::allocator<std::_Container_proxy>>(void)+Ap
.text$mn:000047DC                                         ; std::_String_alloc<0,std::_String_base_types<char,std::allocator<char>>>::_Alloc_proxy(void)+Cp ...
.text$mn:000047DC
.text$mn:000047DC var_4           = dword ptr -4
.text$mn:000047DC
.text$mn:000047DC                 push    ebp
.text$mn:000047DD                 mov     ebp, esp
.text$mn:000047DF                 push    ecx
.text$mn:000047E0                 mov     [ebp+var_4], ecx
.text$mn:000047E3                 mov     eax, [ebp+var_4]
.text$mn:000047E6                 mov     esp, ebp
.text$mn:000047E8                 pop     ebp
.text$mn:000047E9                 retn
.text$mn:000047E9 ??0?$allocator@U_Container_proxy@std@@@std@@QAE@XZ endp
.text$mn:000047E9
.text$mn:000047E9 ; ---------------------------------------------------------------------------
.text$mn:000047EA                 align 4
.text$mn:000047EA _text$mn        ends
.text$mn:000047EA
.text$mn:000047EC ; ===========================================================================
.text$mn:000047EC
.text$mn:000047EC ; Segment type: Pure code
.text$mn:000047EC ; Segment permissions: Read/Execute
.text$mn:000047EC _text$mn        segment para public 'CODE' use32
.text$mn:000047EC                 assume cs:_text$mn
.text$mn:000047EC                 ;org 47ECh
.text$mn:000047EC ; COMDAT (pick any)
.text$mn:000047EC                 assume es:nothing, ss:nothing, ds:_data, fs:nothing, gs:nothing
.text$mn:000047EC
.text$mn:000047EC ; =============== S U B R O U T I N E =======================================
.text$mn:000047EC
.text$mn:000047EC ; Attributes: bp-based frame
.text$mn:000047EC
.text$mn:000047EC ; public: __thiscall std::allocator<class std::vector<wchar_t const *, class std::allocator<wchar_t const *>>>::allocator<class std::vector<wchar_t const *, class std::allocator<wchar_t const *>>>(void)
.text$mn:000047EC                 public ??0?$allocator@V?$vector@PB_WV?$allocator@PB_W@std@@@std@@@std@@QAE@XZ
.text$mn:000047EC ??0?$allocator@V?$vector@PB_WV?$allocator@PB_W@std@@@std@@@std@@QAE@XZ proc near
.text$mn:000047EC                                         ; CODE XREF: std::_Wrap_alloc<std::allocator<std::vector<wchar_t const *,std::allocator<wchar_t const *>>>>::_Wrap_alloc<std::allocator<std::vector<wchar_t const *,std::allocator<wchar_t const *>>>>(void)+Ap
.text$mn:000047EC
.text$mn:000047EC var_4           = dword ptr -4
.text$mn:000047EC
.text$mn:000047EC                 push    ebp
.text$mn:000047ED                 mov     ebp, esp
.text$mn:000047EF                 push    ecx
.text$mn:000047F0                 mov     [ebp+var_4], ecx
.text$mn:000047F3                 mov     eax, [ebp+var_4]
.text$mn:000047F6                 mov     esp, ebp
.text$mn:000047F8                 pop     ebp
.text$mn:000047F9                 retn
.text$mn:000047F9 ??0?$allocator@V?$vector@PB_WV?$allocator@PB_W@std@@@std@@@std@@QAE@XZ endp
.text$mn:000047F9
.text$mn:000047F9 ; ---------------------------------------------------------------------------
.text$mn:000047FA                 align 4
.text$mn:000047FA _text$mn        ends
.text$mn:000047FA
.text$mn:000047FC ; ===========================================================================
.text$mn:000047FC
.text$mn:000047FC ; Segment type: Pure code
.text$mn:000047FC ; Segment permissions: Read/Execute
.text$mn:000047FC _text$mn        segment para public 'CODE' use32
.text$mn:000047FC                 assume cs:_text$mn
.text$mn:000047FC                 ;org 47FCh
.text$mn:000047FC ; COMDAT (pick any)
.text$mn:000047FC                 assume es:nothing, ss:nothing, ds:_data, fs:nothing, gs:nothing
.text$mn:000047FC
.text$mn:000047FC ; =============== S U B R O U T I N E =======================================
.text$mn:000047FC
.text$mn:000047FC ; Attributes: bp-based frame
.text$mn:000047FC
.text$mn:000047FC ; int __stdcall std::basic_string<char,std::char_traits<char>,std::allocator<char>>::basic_string<char,std::char_traits<char>,std::allocator<char>>(char *Str)
.text$mn:000047FC                 public ??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@PBD@Z
.text$mn:000047FC ??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@PBD@Z proc near
.text$mn:000047FC                                         ; CODE XREF: std::_Generic_error_category::message(int)+5Ap
.text$mn:000047FC                                         ; std::_Iostream_error_category::message(int)+3Dp ...
.text$mn:000047FC
.text$mn:000047FC var_14          = dword ptr -14h
.text$mn:000047FC var_D           = byte ptr -0Dh
.text$mn:000047FC var_C           = dword ptr -0Ch
.text$mn:000047FC var_4           = dword ptr -4
.text$mn:000047FC Str             = dword ptr  8
.text$mn:000047FC
.text$mn:000047FC                 push    ebp
.text$mn:000047FD                 mov     ebp, esp
.text$mn:000047FF                 push    0FFFFFFFFh
.text$mn:00004801                 push    offset __ehhandler$??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@PBD@Z
.text$mn:00004806                 mov     eax, large fs:0
.text$mn:0000480C                 push    eax
.text$mn:0000480D                 sub     esp, 8
.text$mn:00004810                 mov     eax, dword ptr ds:___security_cookie
.text$mn:00004815                 xor     eax, ebp
.text$mn:00004817                 push    eax
.text$mn:00004818                 lea     eax, [ebp+var_C]
.text$mn:0000481B                 mov     large fs:0, eax
.text$mn:00004821                 mov     [ebp+var_14], ecx
.text$mn:00004824                 lea     ecx, [ebp+var_D]
.text$mn:00004827                 call    ??0?$allocator@D@std@@QAE@XZ ; std::allocator<char>::allocator<char>(void)
.text$mn:0000482C                 push    eax
.text$mn:0000482D                 mov     ecx, [ebp+var_14]
.text$mn:00004830                 call    ??0?$_String_alloc@$0A@U?$_String_base_types@DV?$allocator@D@std@@@std@@@std@@QAE@ABV?$allocator@D@1@@Z ; std::_String_alloc<0,std::_String_base_types<char,std::allocator<char>>>::_String_alloc<0,std::_String_base_types<char,std::allocator<char>>>(std::allocator<char> const &)
.text$mn:00004835                 mov     [ebp+var_4], 0
.text$mn:0000483C                 push    0               ; Size
.text$mn:0000483E                 push    0               ; char
.text$mn:00004840                 mov     ecx, [ebp+var_14]
.text$mn:00004843                 call    ?_Tidy@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEX_NI@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char>>::_Tidy(bool,uint)
.text$mn:00004848                 mov     eax, [ebp+Str]
.text$mn:0000484B                 push    eax             ; Str
.text$mn:0000484C                 mov     ecx, [ebp+var_14]
.text$mn:0000484F                 call    ?assign@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV12@PBD@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char>>::assign(char const *)
.text$mn:00004854                 mov     [ebp+var_4], 0FFFFFFFFh
.text$mn:0000485B                 mov     eax, [ebp+var_14]
.text$mn:0000485E                 mov     ecx, [ebp+var_C]
.text$mn:00004861                 mov     large fs:0, ecx
.text$mn:00004868                 pop     ecx
.text$mn:00004869                 mov     esp, ebp
.text$mn:0000486B                 pop     ebp
.text$mn:0000486C                 retn    4
.text$mn:0000486C ??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@PBD@Z endp
.text$mn:0000486C
.text$mn:0000486C ; ---------------------------------------------------------------------------
.text$mn:0000486F                 align 10h
.text$mn:0000486F _text$mn        ends
.text$mn:0000486F
.text$x:00004870 ; ===========================================================================
.text$x:00004870
.text$x:00004870 ; Segment type: Pure code
.text$x:00004870 ; Segment permissions: Read/Execute
.text$x:00004870 _text$x         segment para public 'CODE' use32
.text$x:00004870                 assume cs:_text$x
.text$x:00004870                 ;org 4870h
.text$x:00004870 ; COMDAT (pick associative to section at 47FC)
.text$x:00004870                 assume es:nothing, ss:nothing, ds:_data, fs:nothing, gs:nothing
.text$x:00004870
.text$x:00004870 ; =============== S U B R O U T I N E =======================================
.text$x:00004870
.text$x:00004870
.text$x:00004870 __unwindfunclet$??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@PBD@Z$0 proc near
.text$x:00004870                                         ; DATA XREF: .xdata$x:000093B8o
.text$x:00004870                 mov     ecx, [ebp-14h]
.text$x:00004873                 jmp     ??1?$_String_alloc@$0A@U?$_String_base_types@DV?$allocator@D@std@@@std@@@std@@QAE@XZ ; std::_String_alloc<0,std::_String_base_types<char,std::allocator<char>>>::~_String_alloc<0,std::_String_base_types<char,std::allocator<char>>>(void)
.text$x:00004873 __unwindfunclet$??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@PBD@Z$0 endp
.text$x:00004873
.text$x:00004878
.text$x:00004878 ; =============== S U B R O U T I N E =======================================
.text$x:00004878
.text$x:00004878
.text$x:00004878 __ehhandler$??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@PBD@Z proc near
.text$x:00004878                                         ; DATA XREF: std::basic_string<char,std::char_traits<char>,std::allocator<char>>::basic_string<char,std::char_traits<char>,std::allocator<char>>(char const *)+5o
.text$x:00004878
.text$x:00004878 arg_4           = dword ptr  8
.text$x:00004878
.text$x:00004878                 mov     edx, [esp+arg_4]
.text$x:0000487C                 lea     eax, [edx+0Ch]
.text$x:0000487F                 mov     ecx, [edx-0Ch]
.text$x:00004882                 xor     ecx, eax
.text$x:00004884                 call    @__security_check_cookie@4 ; __security_check_cookie(x)
.text$x:00004889                 mov     eax, offset __ehfuncinfo$??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@PBD@Z
.text$x:0000488E                 jmp     ___CxxFrameHandler3
.text$x:0000488E __ehhandler$??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@PBD@Z endp
.text$x:0000488E
.text$x:0000488E ; ---------------------------------------------------------------------------
.text$x:00004893                 align 4
.text$x:00004893 _text$x         ends
.text$x:00004893
.text$mn:00004894 ; ===========================================================================
.text$mn:00004894
.text$mn:00004894 ; Segment type: Pure code
.text$mn:00004894 ; Segment permissions: Read/Execute
.text$mn:00004894 _text$mn        segment para public 'CODE' use32
.text$mn:00004894                 assume cs:_text$mn
.text$mn:00004894                 ;org 4894h
.text$mn:00004894 ; COMDAT (pick any)
.text$mn:00004894                 assume es:nothing, ss:nothing, ds:_data, fs:nothing, gs:nothing
.text$mn:00004894
.text$mn:00004894 ; =============== S U B R O U T I N E =======================================
.text$mn:00004894
.text$mn:00004894 ; Attributes: bp-based frame
.text$mn:00004894
.text$mn:00004894 ; public: __thiscall std::vector<wchar_t const *, class std::allocator<wchar_t const *>>::vector<wchar_t const *, class std::allocator<wchar_t const *>>(class std::vector<wchar_t const *, class std::allocator<wchar_t const *>> &&)
.text$mn:00004894                 public ??0?$vector@PB_WV?$allocator@PB_W@std@@@std@@QAE@$$QAV01@@Z
.text$mn:00004894 ??0?$vector@PB_WV?$allocator@PB_W@std@@@std@@QAE@$$QAV01@@Z proc near
.text$mn:00004894                                         ; CODE XREF: std::allocator<std::vector<wchar_t const *,std::allocator<wchar_t const *>>>::construct<std::vector<wchar_t const *,std::allocator<wchar_t const *>>,std::vector<wchar_t const *,std::allocator<wchar_t const *>>>(std::vector<wchar_t const *,std::allocator<wchar_t const *>> *,std::vector<wchar_t const *,std::allocator<wchar_t const *>> &&)+56p
.text$mn:00004894
.text$mn:00004894 var_14          = dword ptr -14h
.text$mn:00004894 var_E           = byte ptr -0Eh
.text$mn:00004894 var_D           = byte ptr -0Dh
.text$mn:00004894 var_C           = dword ptr -0Ch
.text$mn:00004894 var_4           = dword ptr -4
.text$mn:00004894 arg_0           = dword ptr  8
.text$mn:00004894
.text$mn:00004894                 push    ebp
.text$mn:00004895                 mov     ebp, esp
.text$mn:00004897                 push    0FFFFFFFFh
.text$mn:00004899                 push    offset __ehhandler$??0?$vector@PB_WV?$allocator@PB_W@std@@@std@@QAE@$$QAV01@@Z
.text$mn:0000489E                 mov     eax, large fs:0
.text$mn:000048A4                 push    eax
.text$mn:000048A5                 sub     esp, 8
.text$mn:000048A8                 mov     eax, dword ptr ds:___security_cookie
.text$mn:000048AD                 xor     eax, ebp
.text$mn:000048AF                 push    eax
.text$mn:000048B0                 lea     eax, [ebp+var_C]
.text$mn:000048B3                 mov     large fs:0, eax
.text$mn:000048B9                 mov     [ebp+var_14], ecx
.text$mn:000048BC                 lea     eax, [ebp+var_E]
.text$mn:000048BF                 push    eax
.text$mn:000048C0                 mov     ecx, [ebp+arg_0]
.text$mn:000048C3                 call    ?_Getal@?$_Vector_alloc@$0A@U?$_Vec_base_types@PB_WV?$allocator@PB_W@std@@@std@@@std@@QBE?AU?$_Wrap_alloc@V?$allocator@PB_W@std@@@2@XZ ; std::_Vector_alloc<0,std::_Vec_base_types<wchar_t const *,std::allocator<wchar_t const *>>>::_Getal(void)
.text$mn:000048C8                 push    eax
.text$mn:000048C9                 mov     ecx, [ebp+var_14]
.text$mn:000048CC                 call    ??0?$_Vector_alloc@$0A@U?$_Vec_base_types@PB_WV?$allocator@PB_W@std@@@std@@@std@@QAE@ABV?$allocator@PB_W@1@@Z ; std::_Vector_alloc<0,std::_Vec_base_types<wchar_t const *,std::allocator<wchar_t const *>>>::_Vector_alloc<0,std::_Vec_base_types<wchar_t const *,std::allocator<wchar_t const *>>>(std::allocator<wchar_t const *> const &)
.text$mn:000048D1                 mov     [ebp+var_4], 0
.text$mn:000048D8                 xor     ecx, ecx
.text$mn:000048DA                 mov     [ebp+var_D], cl
.text$mn:000048DD                 movzx   edx, [ebp+var_D]
.text$mn:000048E1                 push    edx             ; int
.text$mn:000048E2                 mov     eax, [ebp+arg_0]
.text$mn:000048E5                 push    eax
.text$mn:000048E6                 call    ??$forward@V?$vector@PB_WV?$allocator@PB_W@std@@@std@@@std@@YA$$QAV?$vector@PB_WV?$allocator@PB_W@std@@@0@AAV10@@Z ; std::forward<std::vector<wchar_t const *,std::allocator<wchar_t const *>>>(std::vector<wchar_t const *,std::allocator<wchar_t const *>> &)
.text$mn:000048EB                 add     esp, 4
.text$mn:000048EE                 push    eax             ; struct std::_Container_base12 *
.text$mn:000048EF                 mov     ecx, [ebp+var_14]
.text$mn:000048F2                 call    ?_Assign_rv@?$vector@PB_WV?$allocator@PB_W@std@@@std@@QAEX$$QAV12@U?$integral_constant@_N$00@2@@Z ; std::vector<wchar_t const *,std::allocator<wchar_t const *>>::_Assign_rv(std::vector<wchar_t const *,std::allocator<wchar_t const *>> &&,std::integral_constant<bool,1>)
.text$mn:000048F7                 mov     [ebp+var_4], 0FFFFFFFFh
.text$mn:000048FE                 mov     eax, [ebp+var_14]
.text$mn:00004901                 mov     ecx, [ebp+var_C]
.text$mn:00004904                 mov     large fs:0, ecx
.text$mn:0000490B                 pop     ecx
.text$mn:0000490C                 mov     esp, ebp
.text$mn:0000490E                 pop     ebp
.text$mn:0000490F                 retn    4
.text$mn:0000490F ??0?$vector@PB_WV?$allocator@PB_W@std@@@std@@QAE@$$QAV01@@Z endp
.text$mn:0000490F
.text$mn:0000490F ; ---------------------------------------------------------------------------
.text$mn:00004912                 align 4
.text$mn:00004912 _text$mn        ends
.text$mn:00004912
.text$x:00004914 ; ===========================================================================
.text$x:00004914
.text$x:00004914 ; Segment type: Pure code
.text$x:00004914 ; Segment permissions: Read/Execute
.text$x:00004914 _text$x         segment para public 'CODE' use32
.text$x:00004914                 assume cs:_text$x
.text$x:00004914                 ;org 4914h
.text$x:00004914 ; COMDAT (pick associative to section at 4894)
.text$x:00004914                 assume es:nothing, ss:nothing, ds:_data, fs:nothing, gs:nothing
.text$x:00004914
.text$x:00004914 ; =============== S U B R O U T I N E =======================================
.text$x:00004914
.text$x:00004914
.text$x:00004914 __unwindfunclet$??0?$vector@PB_WV?$allocator@PB_W@std@@@std@@QAE@$$QAV01@@Z$0 proc near
.text$x:00004914                                         ; DATA XREF: .xdata$x:00009774o
.text$x:00004914                 mov     ecx, [ebp-14h]
.text$x:00004917                 jmp     ??1?$_Vector_alloc@$0A@U?$_Vec_base_types@PB_WV?$allocator@PB_W@std@@@std@@@std@@QAE@XZ ; std::_Vector_alloc<0,std::_Vec_base_types<wchar_t const *,std::allocator<wchar_t const *>>>::~_Vector_alloc<0,std::_Vec_base_types<wchar_t const *,std::allocator<wchar_t const *>>>(void)
.text$x:00004917 __unwindfunclet$??0?$vector@PB_WV?$allocator@PB_W@std@@@std@@QAE@$$QAV01@@Z$0 endp
.text$x:00004917
.text$x:0000491C
.text$x:0000491C ; =============== S U B R O U T I N E =======================================
.text$x:0000491C
.text$x:0000491C
.text$x:0000491C __ehhandler$??0?$vector@PB_WV?$allocator@PB_W@std@@@std@@QAE@$$QAV01@@Z proc near
.text$x:0000491C                                         ; DATA XREF: std::vector<wchar_t const *,std::allocator<wchar_t const *>>::vector<wchar_t const *,std::allocator<wchar_t const *>>(std::vector<wchar_t const *,std::allocator<wchar_t const *>> &&)+5o
.text$x:0000491C
.text$x:0000491C arg_4           = dword ptr  8
.text$x:0000491C
.text$x:0000491C                 mov     edx, [esp+arg_4]
.text$x:00004920                 lea     eax, [edx+0Ch]
.text$x:00004923                 mov     ecx, [edx-0Ch]
.text$x:00004926                 xor     ecx, eax
.text$x:00004928                 call    @__security_check_cookie@4 ; __security_check_cookie(x)
.text$x:0000492D                 mov     eax, offset __ehfuncinfo$??0?$vector@PB_WV?$allocator@PB_W@std@@@std@@QAE@$$QAV01@@Z
.text$x:00004932                 jmp     ___CxxFrameHandler3
.text$x:00004932 __ehhandler$??0?$vector@PB_WV?$allocator@PB_W@std@@@std@@QAE@$$QAV01@@Z endp
.text$x:00004932
.text$x:00004932 ; ---------------------------------------------------------------------------
.text$x:00004937                 align 4
.text$x:00004937 _text$x         ends
.text$x:00004937
.text$mn:00004938 ; ===========================================================================
.text$mn:00004938
.text$mn:00004938 ; Segment type: Pure code
.text$mn:00004938 ; Segment permissions: Read/Execute
.text$mn:00004938 _text$mn        segment para public 'CODE' use32
.text$mn:00004938                 assume cs:_text$mn
.text$mn:00004938                 ;org 4938h
.text$mn:00004938 ; COMDAT (pick any)
.text$mn:00004938                 assume es:nothing, ss:nothing, ds:_data, fs:nothing, gs:nothing
.text$mn:00004938
.text$mn:00004938 ; =============== S U B R O U T I N E =======================================
.text$mn:00004938
.text$mn:00004938 ; Attributes: bp-based frame
.text$mn:00004938
.text$mn:00004938 ; public: __thiscall std::vector<wchar_t const *, class std::allocator<wchar_t const *>>::vector<wchar_t const *, class std::allocator<wchar_t const *>>(class std::vector<wchar_t const *, class std::allocator<wchar_t const *>> const &)
.text$mn:00004938                 public ??0?$vector@PB_WV?$allocator@PB_W@std@@@std@@QAE@ABV01@@Z
.text$mn:00004938 ??0?$vector@PB_WV?$allocator@PB_W@std@@@std@@QAE@ABV01@@Z proc near
.text$mn:00004938                                         ; CODE XREF: std::allocator<std::vector<wchar_t const *,std::allocator<wchar_t const *>>>::construct<std::vector<wchar_t const *,std::allocator<wchar_t const *>>,std::vector<wchar_t const *,std::allocator<wchar_t const *>> &>(std::vector<wchar_t const *,std::allocator<wchar_t const *>> *,std::vector<wchar_t const *,std::allocator<wchar_t const *>> &)+56p
.text$mn:00004938                                         ; std::allocator<std::vector<wchar_t const *,std::allocator<wchar_t const *>>>::construct(std::vector<wchar_t const *,std::allocator<wchar_t const *>> *,std::vector<wchar_t const *,std::allocator<wchar_t const *>> const &)+4Dp
.text$mn:00004938
.text$mn:00004938 var_34          = dword ptr -34h
.text$mn:00004938 var_30          = dword ptr -30h
.text$mn:00004938 var_2C          = dword ptr -2Ch
.text$mn:00004938 var_28          = dword ptr -28h
.text$mn:00004938 var_24          = dword ptr -24h
.text$mn:00004938 var_20          = dword ptr -20h
.text$mn:00004938 var_1C          = dword ptr -1Ch
.text$mn:00004938 var_18          = dword ptr -18h
.text$mn:00004938 var_12          = byte ptr -12h
.text$mn:00004938 var_11          = byte ptr -11h
.text$mn:00004938 var_10          = dword ptr -10h
.text$mn:00004938 var_C           = dword ptr -0Ch
.text$mn:00004938 var_4           = dword ptr -4
.text$mn:00004938 arg_0           = dword ptr  8
.text$mn:00004938
.text$mn:00004938 ; FUNCTION CHUNK AT .text$mn:00004A22 SIZE 00000009 BYTES
.text$mn:00004938 ; FUNCTION CHUNK AT .text$mn:00004A32 SIZE 0000001E BYTES
.text$mn:00004938
.text$mn:00004938                 push    ebp
.text$mn:00004939                 mov     ebp, esp
.text$mn:0000493B                 push    0FFFFFFFFh
.text$mn:0000493D                 push    offset __ehhandler$??0?$vector@PB_WV?$allocator@PB_W@std@@@std@@QAE@ABV01@@Z
.text$mn:00004942                 mov     eax, large fs:0
.text$mn:00004948                 push    eax
.text$mn:00004949                 push    ecx
.text$mn:0000494A                 sub     esp, 24h
.text$mn:0000494D                 push    ebx
.text$mn:0000494E                 push    esi
.text$mn:0000494F                 push    edi
.text$mn:00004950                 mov     eax, dword ptr ds:___security_cookie
.text$mn:00004955                 xor     eax, ebp
.text$mn:00004957                 push    eax
.text$mn:00004958                 lea     eax, [ebp+var_C]
.text$mn:0000495B                 mov     large fs:0, eax
.text$mn:00004961                 mov     [ebp+var_10], esp
.text$mn:00004964                 mov     [ebp+var_18], ecx
.text$mn:00004967                 lea     eax, [ebp+var_11]
.text$mn:0000496A                 push    eax
.text$mn:0000496B                 lea     ecx, [ebp+var_12]
.text$mn:0000496E                 push    ecx
.text$mn:0000496F                 mov     ecx, [ebp+arg_0]
.text$mn:00004972                 call    ?_Getal@?$_Vector_alloc@$0A@U?$_Vec_base_types@PB_WV?$allocator@PB_W@std@@@std@@@std@@QBE?AU?$_Wrap_alloc@V?$allocator@PB_W@std@@@2@XZ ; std::_Vector_alloc<0,std::_Vec_base_types<wchar_t const *,std::allocator<wchar_t const *>>>::_Getal(void)
.text$mn:00004977                 mov     ecx, eax
.text$mn:00004979                 call    ?select_on_container_copy_construction@?$_Wrap_alloc@V?$allocator@PB_W@std@@@std@@QBE?AU12@XZ ; std::_Wrap_alloc<std::allocator<wchar_t const *>>::select_on_container_copy_construction(void)
.text$mn:0000497E                 push    eax
.text$mn:0000497F                 mov     ecx, [ebp+var_18]
.text$mn:00004982                 call    ??0?$_Vector_alloc@$0A@U?$_Vec_base_types@PB_WV?$allocator@PB_W@std@@@std@@@std@@QAE@ABV?$allocator@PB_W@1@@Z ; std::_Vector_alloc<0,std::_Vec_base_types<wchar_t const *,std::allocator<wchar_t const *>>>::_Vector_alloc<0,std::_Vec_base_types<wchar_t const *,std::allocator<wchar_t const *>>>(std::allocator<wchar_t const *> const &)
.text$mn:00004987                 mov     [ebp+var_4], 0
.text$mn:0000498E                 mov     ecx, [ebp+arg_0]
.text$mn:00004991                 call    ?size@?$vector@PB_WV?$allocator@PB_W@std@@@std@@QBEIXZ ; std::vector<wchar_t const *,std::allocator<wchar_t const *>>::size(void)
.text$mn:00004996                 push    eax
.text$mn:00004997                 mov     ecx, [ebp+var_18]
.text$mn:0000499A                 call    ?_Buy@?$vector@PB_WV?$allocator@PB_W@std@@@std@@IAE_NI@Z ; std::vector<wchar_t const *,std::allocator<wchar_t const *>>::_Buy(uint)
.text$mn:0000499F                 movzx   edx, al
.text$mn:000049A2                 test    edx, edx
.text$mn:000049A4                 jz      loc_4A32
.text$mn:000049AA                 mov     byte ptr [ebp+var_4], 1
.text$mn:000049AE                 mov     eax, [ebp+var_18]
.text$mn:000049B1                 mov     ecx, [eax+4]
.text$mn:000049B4                 push    ecx
.text$mn:000049B5                 sub     esp, 0Ch
.text$mn:000049B8                 mov     edx, esp
.text$mn:000049BA                 mov     [ebp+var_28], esp
.text$mn:000049BD                 push    edx
.text$mn:000049BE                 mov     ecx, [ebp+arg_0]
.text$mn:000049C1                 call    ?end@?$vector@PB_WV?$allocator@PB_W@std@@@std@@QBE?AV?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@PB_W@std@@@std@@@2@XZ ; std::vector<wchar_t const *,std::allocator<wchar_t const *>>::end(void)
.text$mn:000049C6                 mov     [ebp+var_1C], eax
.text$mn:000049C9                 mov     eax, [ebp+var_1C]
.text$mn:000049CC                 mov     [ebp+var_2C], eax
.text$mn:000049CF                 mov     byte ptr [ebp+var_4], 2
.text$mn:000049D3                 sub     esp, 0Ch
.text$mn:000049D6                 mov     ecx, esp
.text$mn:000049D8                 mov     [ebp+var_30], esp
.text$mn:000049DB                 push    ecx
.text$mn:000049DC                 mov     ecx, [ebp+arg_0]
.text$mn:000049DF                 call    ?begin@?$vector@PB_WV?$allocator@PB_W@std@@@std@@QBE?AV?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@PB_W@std@@@std@@@2@XZ ; std::vector<wchar_t const *,std::allocator<wchar_t const *>>::begin(void)
.text$mn:000049E4                 mov     [ebp+var_20], eax
.text$mn:000049E7                 mov     edx, [ebp+var_20]
.text$mn:000049EA                 mov     [ebp+var_34], edx
.text$mn:000049ED                 mov     byte ptr [ebp+var_4], 3
.text$mn:000049F1                 mov     byte ptr [ebp+var_4], 1
.text$mn:000049F5                 mov     ecx, [ebp+var_18]
.text$mn:000049F8                 call    ??$_Ucopy@V?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@PB_W@std@@@std@@@std@@@?$vector@PB_WV?$allocator@PB_W@std@@@std@@IAEPAPB_WV?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@PB_W@std@@@std@@@1@0PAPB_W@Z ; std::vector<wchar_t const *,std::allocator<wchar_t const *>>::_Ucopy<std::_Vector_const_iterator<std::_Vector_val<std::_Simple_types<wchar_t const *>>>>(std::_Vector_const_iterator<std::_Vector_val<std::_Simple_types<wchar_t const *>>>,std::_Vector_const_iterator<std::_Vector_val<std::_Simple_types<wchar_t const *>>>,wchar_t const * *)
.text$mn:000049FD                 mov     [ebp+var_24], eax
.text$mn:00004A00                 mov     eax, [ebp+var_18]
.text$mn:00004A03                 mov     ecx, [ebp+var_24]
.text$mn:00004A06                 mov     [eax+8], ecx
.text$mn:00004A09                 jmp     short loc_4A22
.text$mn:00004A09 ??0?$vector@PB_WV?$allocator@PB_W@std@@@std@@QAE@ABV01@@Z endp
.text$mn:00004A09
.text$mn:00004A0B
.text$mn:00004A0B ; =============== S U B R O U T I N E =======================================
.text$mn:00004A0B
.text$mn:00004A0B ; Attributes: noreturn
.text$mn:00004A0B
.text$mn:00004A0B __catch$??0?$vector@PB_WV?$allocator@PB_W@std@@@std@@QAE@ABV01@@Z$0 proc near
.text$mn:00004A0B                                         ; DATA XREF: .xdata$x:0000970Co
.text$mn:00004A0B                 mov     ecx, [ebp-18h]
.text$mn:00004A0E                 call    ?_Tidy@?$vector@PB_WV?$allocator@PB_W@std@@@std@@IAEXXZ ; std::vector<wchar_t const *,std::allocator<wchar_t const *>>::_Tidy(void)
.text$mn:00004A13                 push    0
.text$mn:00004A15                 push    0
.text$mn:00004A17                 call    __CxxThrowException@8 ; _CxxThrowException(x,x)
.text$mn:00004A17 __catch$??0?$vector@PB_WV?$allocator@PB_W@std@@@std@@QAE@ABV01@@Z$0 endp
.text$mn:00004A17
.text$mn:00004A1C ; ---------------------------------------------------------------------------
.text$mn:00004A1C                 mov     eax, offset $LN11
.text$mn:00004A21                 retn
.text$mn:00004A22 ; ---------------------------------------------------------------------------
.text$mn:00004A22 ; START OF FUNCTION CHUNK FOR ??0?$vector@PB_WV?$allocator@PB_W@std@@@std@@QAE@ABV01@@Z
.text$mn:00004A22
.text$mn:00004A22 loc_4A22:                               ; CODE XREF: std::vector<wchar_t const *,std::allocator<wchar_t const *>>::vector<wchar_t const *,std::allocator<wchar_t const *>>(std::vector<wchar_t const *,std::allocator<wchar_t const *>> const &)+D1j
.text$mn:00004A22                 mov     [ebp+var_4], 0
.text$mn:00004A29                 jmp     short loc_4A32
.text$mn:00004A29 ; END OF FUNCTION CHUNK FOR ??0?$vector@PB_WV?$allocator@PB_W@std@@@std@@QAE@ABV01@@Z
.text$mn:00004A2B
.text$mn:00004A2B ; =============== S U B R O U T I N E =======================================
.text$mn:00004A2B
.text$mn:00004A2B
.text$mn:00004A2B $LN11           proc near               ; DATA XREF: .text$mn:00004A1Co
.text$mn:00004A2B                 mov     dword ptr [ebp-4], 0
.text$mn:00004A2B $LN11           endp ; sp-analysis failed
.text$mn:00004A2B
.text$mn:00004A32 ; START OF FUNCTION CHUNK FOR ??0?$vector@PB_WV?$allocator@PB_W@std@@@std@@QAE@ABV01@@Z
.text$mn:00004A32
.text$mn:00004A32 loc_4A32:                               ; CODE XREF: std::vector<wchar_t const *,std::allocator<wchar_t const *>>::vector<wchar_t const *,std::allocator<wchar_t const *>>(std::vector<wchar_t const *,std::allocator<wchar_t const *>> const &)+6Cj
.text$mn:00004A32                                         ; std::vector<wchar_t const *,std::allocator<wchar_t const *>>::vector<wchar_t const *,std::allocator<wchar_t const *>>(std::vector<wchar_t const *,std::allocator<wchar_t const *>> const &)+F1j
.text$mn:00004A32                 mov     [ebp+var_4], 0FFFFFFFFh
.text$mn:00004A39                 mov     eax, [ebp+var_18]
.text$mn:00004A3C                 mov     ecx, [ebp+var_C]
.text$mn:00004A3F                 mov     large fs:0, ecx
.text$mn:00004A46                 pop     ecx
.text$mn:00004A47                 pop     edi
.text$mn:00004A48                 pop     esi
.text$mn:00004A49                 pop     ebx
.text$mn:00004A4A                 mov     esp, ebp
.text$mn:00004A4C                 pop     ebp
.text$mn:00004A4D                 retn    4
.text$mn:00004A4D ; END OF FUNCTION CHUNK FOR ??0?$vector@PB_WV?$allocator@PB_W@std@@@std@@QAE@ABV01@@Z
.text$mn:00004A4D _text$mn        ends
.text$mn:00004A4D
.text$x:00004A50 ; ===========================================================================
.text$x:00004A50
.text$x:00004A50 ; Segment type: Pure code
.text$x:00004A50 ; Segment permissions: Read/Execute
.text$x:00004A50 _text$x         segment para public 'CODE' use32
.text$x:00004A50                 assume cs:_text$x
.text$x:00004A50                 ;org 4A50h
.text$x:00004A50 ; COMDAT (pick associative to section at 4938)
.text$x:00004A50                 assume es:nothing, ss:nothing, ds:_data, fs:nothing, gs:nothing
.text$x:00004A50
.text$x:00004A50 ; =============== S U B R O U T I N E =======================================
.text$x:00004A50
.text$x:00004A50
.text$x:00004A50 __unwindfunclet$??0?$vector@PB_WV?$allocator@PB_W@std@@@std@@QAE@ABV01@@Z$2 proc near
.text$x:00004A50                                         ; DATA XREF: .xdata$x:0000974Co
.text$x:00004A50                 mov     ecx, [ebp-18h]
.text$x:00004A53                 jmp     ??1?$_Vector_alloc@$0A@U?$_Vec_base_types@PB_WV?$allocator@PB_W@std@@@std@@@std@@QAE@XZ ; std::_Vector_alloc<0,std::_Vec_base_types<wchar_t const *,std::allocator<wchar_t const *>>>::~_Vector_alloc<0,std::_Vec_base_types<wchar_t const *,std::allocator<wchar_t const *>>>(void)
.text$x:00004A53 __unwindfunclet$??0?$vector@PB_WV?$allocator@PB_W@std@@@std@@QAE@ABV01@@Z$2 endp
.text$x:00004A53
.text$x:00004A58
.text$x:00004A58 ; =============== S U B R O U T I N E =======================================
.text$x:00004A58
.text$x:00004A58
.text$x:00004A58 __unwindfunclet$??0?$vector@PB_WV?$allocator@PB_W@std@@@std@@QAE@ABV01@@Z$3 proc near
.text$x:00004A58                                         ; DATA XREF: .xdata$x:0000975Co
.text$x:00004A58                 mov     ecx, [ebp-28h]
.text$x:00004A5B                 jmp     ??1?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@PB_W@std@@@std@@@std@@QAE@XZ ; std::_Vector_const_iterator<std::_Vector_val<std::_Simple_types<wchar_t const *>>>::~_Vector_const_iterator<std::_Vector_val<std::_Simple_types<wchar_t const *>>>(void)
.text$x:00004A5B __unwindfunclet$??0?$vector@PB_WV?$allocator@PB_W@std@@@std@@QAE@ABV01@@Z$3 endp
.text$x:00004A5B
.text$x:00004A60
.text$x:00004A60 ; =============== S U B R O U T I N E =======================================
.text$x:00004A60
.text$x:00004A60
.text$x:00004A60 __unwindfunclet$??0?$vector@PB_WV?$allocator@PB_W@std@@@std@@QAE@ABV01@@Z$4 proc near
.text$x:00004A60                                         ; DATA XREF: .xdata$x:00009764o
.text$x:00004A60                 mov     ecx, [ebp-30h]
.text$x:00004A63                 jmp     ??1?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@PB_W@std@@@std@@@std@@QAE@XZ ; std::_Vector_const_iterator<std::_Vector_val<std::_Simple_types<wchar_t const *>>>::~_Vector_const_iterator<std::_Vector_val<std::_Simple_types<wchar_t const *>>>(void)
.text$x:00004A63 __unwindfunclet$??0?$vector@PB_WV?$allocator@PB_W@std@@@std@@QAE@ABV01@@Z$4 endp
.text$x:00004A63
.text$x:00004A68
.text$x:00004A68 ; =============== S U B R O U T I N E =======================================
.text$x:00004A68
.text$x:00004A68
.text$x:00004A68 __ehhandler$??0?$vector@PB_WV?$allocator@PB_W@std@@@std@@QAE@ABV01@@Z proc near
.text$x:00004A68                                         ; DATA XREF: std::vector<wchar_t const *,std::allocator<wchar_t const *>>::vector<wchar_t const *,std::allocator<wchar_t const *>>(std::vector<wchar_t const *,std::allocator<wchar_t const *>> const &)+5o
.text$x:00004A68
.text$x:00004A68 arg_4           = dword ptr  8
.text$x:00004A68
.text$x:00004A68                 mov     edx, [esp+arg_4]
.text$x:00004A6C                 lea     eax, [edx+0Ch]
.text$x:00004A6F                 mov     ecx, [edx-38h]
.text$x:00004A72                 xor     ecx, eax
.text$x:00004A74                 call    @__security_check_cookie@4 ; __security_check_cookie(x)
.text$x:00004A79                 mov     eax, offset __ehfuncinfo$??0?$vector@PB_WV?$allocator@PB_W@std@@@std@@QAE@ABV01@@Z
.text$x:00004A7E                 jmp     ___CxxFrameHandler3
.text$x:00004A7E __ehhandler$??0?$vector@PB_WV?$allocator@PB_W@std@@@std@@QAE@ABV01@@Z endp
.text$x:00004A7E
.text$x:00004A7E ; ---------------------------------------------------------------------------
.text$x:00004A83                 align 4
.text$x:00004A83 _text$x         ends
.text$x:00004A83
.text$mn:00004A84 ; ===========================================================================
.text$mn:00004A84
.text$mn:00004A84 ; Segment type: Pure code
.text$mn:00004A84 ; Segment permissions: Read/Execute
.text$mn:00004A84 _text$mn        segment para public 'CODE' use32
.text$mn:00004A84                 assume cs:_text$mn
.text$mn:00004A84                 ;org 4A84h
.text$mn:00004A84 ; COMDAT (pick any)
.text$mn:00004A84                 assume es:nothing, ss:nothing, ds:_data, fs:nothing, gs:nothing
.text$mn:00004A84
.text$mn:00004A84 ; =============== S U B R O U T I N E =======================================
.text$mn:00004A84
.text$mn:00004A84 ; Attributes: bp-based frame
.text$mn:00004A84
.text$mn:00004A84 ; public: __thiscall std::vector<wchar_t const *, class std::allocator<wchar_t const *>>::vector<wchar_t const *, class std::allocator<wchar_t const *>>(void)
.text$mn:00004A84                 public ??0?$vector@PB_WV?$allocator@PB_W@std@@@std@@QAE@XZ
.text$mn:00004A84 ??0?$vector@PB_WV?$allocator@PB_W@std@@@std@@QAE@XZ proc near
.text$mn:00004A84                                         ; CODE XREF: FunctionCallTip::loadFunction(void)+119p
.text$mn:00004A84
.text$mn:00004A84 var_14          = dword ptr -14h
.text$mn:00004A84 var_D           = byte ptr -0Dh
.text$mn:00004A84 var_C           = dword ptr -0Ch
.text$mn:00004A84 var_4           = dword ptr -4
.text$mn:00004A84
.text$mn:00004A84                 push    ebp
.text$mn:00004A85                 mov     ebp, esp
.text$mn:00004A87                 push    0FFFFFFFFh
.text$mn:00004A89                 push    offset __ehhandler$??0?$vector@PB_WV?$allocator@PB_W@std@@@std@@QAE@XZ
.text$mn:00004A8E                 mov     eax, large fs:0
.text$mn:00004A94                 push    eax
.text$mn:00004A95                 sub     esp, 8
.text$mn:00004A98                 mov     eax, dword ptr ds:___security_cookie
.text$mn:00004A9D                 xor     eax, ebp
.text$mn:00004A9F                 push    eax
.text$mn:00004AA0                 lea     eax, [ebp+var_C]
.text$mn:00004AA3                 mov     large fs:0, eax
.text$mn:00004AA9                 mov     [ebp+var_14], ecx
.text$mn:00004AAC                 lea     ecx, [ebp+var_D]
.text$mn:00004AAF                 call    ??0?$allocator@PB_W@std@@QAE@XZ ; std::allocator<wchar_t const *>::allocator<wchar_t const *>(void)
.text$mn:00004AB4                 push    eax
.text$mn:00004AB5                 mov     ecx, [ebp+var_14]
.text$mn:00004AB8                 call    ??0?$_Vector_alloc@$0A@U?$_Vec_base_types@PB_WV?$allocator@PB_W@std@@@std@@@std@@QAE@ABV?$allocator@PB_W@1@@Z ; std::_Vector_alloc<0,std::_Vec_base_types<wchar_t const *,std::allocator<wchar_t const *>>>::_Vector_alloc<0,std::_Vec_base_types<wchar_t const *,std::allocator<wchar_t const *>>>(std::allocator<wchar_t const *> const &)
.text$mn:00004ABD                 mov     [ebp+var_4], 0
.text$mn:00004AC4                 mov     [ebp+var_4], 0FFFFFFFFh
.text$mn:00004ACB                 mov     eax, [ebp+var_14]
.text$mn:00004ACE                 mov     ecx, [ebp+var_C]
.text$mn:00004AD1                 mov     large fs:0, ecx
.text$mn:00004AD8                 pop     ecx
.text$mn:00004AD9                 mov     esp, ebp
.text$mn:00004ADB                 pop     ebp
.text$mn:00004ADC                 retn
.text$mn:00004ADC ??0?$vector@PB_WV?$allocator@PB_W@std@@@std@@QAE@XZ endp
.text$mn:00004ADC
.text$mn:00004ADC ; ---------------------------------------------------------------------------
.text$mn:00004ADD                 align 10h
.text$mn:00004ADD _text$mn        ends
.text$mn:00004ADD
.text$x:00004AE0 ; ===========================================================================
.text$x:00004AE0
.text$x:00004AE0 ; Segment type: Pure code
.text$x:00004AE0 ; Segment permissions: Read/Execute
.text$x:00004AE0 _text$x         segment para public 'CODE' use32
.text$x:00004AE0                 assume cs:_text$x
.text$x:00004AE0                 ;org 4AE0h
.text$x:00004AE0 ; COMDAT (pick associative to section at 4A84)
.text$x:00004AE0                 assume es:nothing, ss:nothing, ds:_data, fs:nothing, gs:nothing
.text$x:00004AE0
.text$x:00004AE0 ; =============== S U B R O U T I N E =======================================
.text$x:00004AE0
.text$x:00004AE0
.text$x:00004AE0 __unwindfunclet$??0?$vector@PB_WV?$allocator@PB_W@std@@@std@@QAE@XZ$0 proc near
.text$x:00004AE0                                         ; DATA XREF: .xdata$x:000096D8o
.text$x:00004AE0                 mov     ecx, [ebp-14h]
.text$x:00004AE3                 jmp     ??1?$_Vector_alloc@$0A@U?$_Vec_base_types@PB_WV?$allocator@PB_W@std@@@std@@@std@@QAE@XZ ; std::_Vector_alloc<0,std::_Vec_base_types<wchar_t const *,std::allocator<wchar_t const *>>>::~_Vector_alloc<0,std::_Vec_base_types<wchar_t const *,std::allocator<wchar_t const *>>>(void)
.text$x:00004AE3 __unwindfunclet$??0?$vector@PB_WV?$allocator@PB_W@std@@@std@@QAE@XZ$0 endp
.text$x:00004AE3
.text$x:00004AE8
.text$x:00004AE8 ; =============== S U B R O U T I N E =======================================
.text$x:00004AE8
.text$x:00004AE8
.text$x:00004AE8 __ehhandler$??0?$vector@PB_WV?$allocator@PB_W@std@@@std@@QAE@XZ proc near
.text$x:00004AE8                                         ; DATA XREF: std::vector<wchar_t const *,std::allocator<wchar_t const *>>::vector<wchar_t const *,std::allocator<wchar_t const *>>(void)+5o
.text$x:00004AE8
.text$x:00004AE8 arg_4           = dword ptr  8
.text$x:00004AE8
.text$x:00004AE8                 mov     edx, [esp+arg_4]
.text$x:00004AEC                 lea     eax, [edx+0Ch]
.text$x:00004AEF                 mov     ecx, [edx-0Ch]
.text$x:00004AF2                 xor     ecx, eax
.text$x:00004AF4                 call    @__security_check_cookie@4 ; __security_check_cookie(x)
.text$x:00004AF9                 mov     eax, offset __ehfuncinfo$??0?$vector@PB_WV?$allocator@PB_W@std@@@std@@QAE@XZ
.text$x:00004AFE                 jmp     ___CxxFrameHandler3
.text$x:00004AFE __ehhandler$??0?$vector@PB_WV?$allocator@PB_W@std@@@std@@QAE@XZ endp
.text$x:00004AFE
.text$x:00004AFE ; ---------------------------------------------------------------------------
.text$x:00004B03                 align 4
.text$x:00004B03 _text$x         ends
.text$x:00004B03
.text$mn:00004B04 ; ===========================================================================
.text$mn:00004B04
.text$mn:00004B04 ; Segment type: Pure code
.text$mn:00004B04 ; Segment permissions: Read/Execute
.text$mn:00004B04 _text$mn        segment para public 'CODE' use32
.text$mn:00004B04                 assume cs:_text$mn
.text$mn:00004B04                 ;org 4B04h
.text$mn:00004B04 ; COMDAT (pick any)
.text$mn:00004B04                 assume es:nothing, ss:nothing, ds:_data, fs:nothing, gs:nothing
.text$mn:00004B04
.text$mn:00004B04 ; =============== S U B R O U T I N E =======================================
.text$mn:00004B04
.text$mn:00004B04 ; Attributes: bp-based frame
.text$mn:00004B04
.text$mn:00004B04 ; public: __thiscall std::vector<struct FunctionValues, class std::allocator<struct FunctionValues>>::vector<struct FunctionValues, class std::allocator<struct FunctionValues>>(void)
.text$mn:00004B04                 public ??0?$vector@UFunctionValues@@V?$allocator@UFunctionValues@@@std@@@std@@QAE@XZ
.text$mn:00004B04 ??0?$vector@UFunctionValues@@V?$allocator@UFunctionValues@@@std@@@std@@QAE@XZ proc near
.text$mn:00004B04                                         ; CODE XREF: FunctionCallTip::getCursorFunction(void)+320p
.text$mn:00004B04
.text$mn:00004B04 var_14          = dword ptr -14h
.text$mn:00004B04 var_D           = byte ptr -0Dh
.text$mn:00004B04 var_C           = dword ptr -0Ch
.text$mn:00004B04 var_4           = dword ptr -4
.text$mn:00004B04
.text$mn:00004B04                 push    ebp
.text$mn:00004B05                 mov     ebp, esp
.text$mn:00004B07                 push    0FFFFFFFFh
.text$mn:00004B09                 push    offset __ehhandler$??0?$vector@UFunctionValues@@V?$allocator@UFunctionValues@@@std@@@std@@QAE@XZ
.text$mn:00004B0E                 mov     eax, large fs:0
.text$mn:00004B14                 push    eax
.text$mn:00004B15                 sub     esp, 8
.text$mn:00004B18                 mov     eax, dword ptr ds:___security_cookie
.text$mn:00004B1D                 xor     eax, ebp
.text$mn:00004B1F                 push    eax
.text$mn:00004B20                 lea     eax, [ebp+var_C]
.text$mn:00004B23                 mov     large fs:0, eax
.text$mn:00004B29                 mov     [ebp+var_14], ecx
.text$mn:00004B2C                 lea     ecx, [ebp+var_D]
.text$mn:00004B2F                 call    ??0?$allocator@UFunctionValues@@@std@@QAE@XZ ; std::allocator<FunctionValues>::allocator<FunctionValues>(void)
.text$mn:00004B34                 push    eax
.text$mn:00004B35                 mov     ecx, [ebp+var_14]
.text$mn:00004B38                 call    ??0?$_Vector_alloc@$0A@U?$_Vec_base_types@UFunctionValues@@V?$allocator@UFunctionValues@@@std@@@std@@@std@@QAE@ABV?$allocator@UFunctionValues@@@1@@Z ; std::_Vector_alloc<0,std::_Vec_base_types<FunctionValues,std::allocator<FunctionValues>>>::_Vector_alloc<0,std::_Vec_base_types<FunctionValues,std::allocator<FunctionValues>>>(std::allocator<FunctionValues> const &)
.text$mn:00004B3D                 mov     [ebp+var_4], 0
.text$mn:00004B44                 mov     [ebp+var_4], 0FFFFFFFFh
.text$mn:00004B4B                 mov     eax, [ebp+var_14]
.text$mn:00004B4E                 mov     ecx, [ebp+var_C]
.text$mn:00004B51                 mov     large fs:0, ecx
.text$mn:00004B58                 pop     ecx
.text$mn:00004B59                 mov     esp, ebp
.text$mn:00004B5B                 pop     ebp
.text$mn:00004B5C                 retn
.text$mn:00004B5C ??0?$vector@UFunctionValues@@V?$allocator@UFunctionValues@@@std@@@std@@QAE@XZ endp
.text$mn:00004B5C
.text$mn:00004B5C ; ---------------------------------------------------------------------------
.text$mn:00004B5D                 align 10h
.text$mn:00004B5D _text$mn        ends
.text$mn:00004B5D
.text$x:00004B60 ; ===========================================================================
.text$x:00004B60
.text$x:00004B60 ; Segment type: Pure code
.text$x:00004B60 ; Segment permissions: Read/Execute
.text$x:00004B60 _text$x         segment para public 'CODE' use32
.text$x:00004B60                 assume cs:_text$x
.text$x:00004B60                 ;org 4B60h
.text$x:00004B60 ; COMDAT (pick associative to section at 4B04)
.text$x:00004B60                 assume es:nothing, ss:nothing, ds:_data, fs:nothing, gs:nothing
.text$x:00004B60
.text$x:00004B60 ; =============== S U B R O U T I N E =======================================
.text$x:00004B60
.text$x:00004B60
.text$x:00004B60 __unwindfunclet$??0?$vector@UFunctionValues@@V?$allocator@UFunctionValues@@@std@@@std@@QAE@XZ$0 proc near
.text$x:00004B60                                         ; DATA XREF: .xdata$x:00009BF4o
.text$x:00004B60                 mov     ecx, [ebp-14h]
.text$x:00004B63                 jmp     ??1?$_Vector_alloc@$0A@U?$_Vec_base_types@UFunctionValues@@V?$allocator@UFunctionValues@@@std@@@std@@@std@@QAE@XZ ; std::_Vector_alloc<0,std::_Vec_base_types<FunctionValues,std::allocator<FunctionValues>>>::~_Vector_alloc<0,std::_Vec_base_types<FunctionValues,std::allocator<FunctionValues>>>(void)
.text$x:00004B63 __unwindfunclet$??0?$vector@UFunctionValues@@V?$allocator@UFunctionValues@@@std@@@std@@QAE@XZ$0 endp
.text$x:00004B63
.text$x:00004B68
.text$x:00004B68 ; =============== S U B R O U T I N E =======================================
.text$x:00004B68
.text$x:00004B68
.text$x:00004B68 __ehhandler$??0?$vector@UFunctionValues@@V?$allocator@UFunctionValues@@@std@@@std@@QAE@XZ proc near
.text$x:00004B68                                         ; DATA XREF: std::vector<FunctionValues,std::allocator<FunctionValues>>::vector<FunctionValues,std::allocator<FunctionValues>>(void)+5o
.text$x:00004B68
.text$x:00004B68 arg_4           = dword ptr  8
.text$x:00004B68
.text$x:00004B68                 mov     edx, [esp+arg_4]
.text$x:00004B6C                 lea     eax, [edx+0Ch]
.text$x:00004B6F                 mov     ecx, [edx-0Ch]
.text$x:00004B72                 xor     ecx, eax
.text$x:00004B74                 call    @__security_check_cookie@4 ; __security_check_cookie(x)
.text$x:00004B79                 mov     eax, offset __ehfuncinfo$??0?$vector@UFunctionValues@@V?$allocator@UFunctionValues@@@std@@@std@@QAE@XZ
.text$x:00004B7E                 jmp     ___CxxFrameHandler3
.text$x:00004B7E __ehhandler$??0?$vector@UFunctionValues@@V?$allocator@UFunctionValues@@@std@@@std@@QAE@XZ endp
.text$x:00004B7E
.text$x:00004B7E ; ---------------------------------------------------------------------------
.text$x:00004B83                 align 4
.text$x:00004B83 _text$x         ends
.text$x:00004B83
.text$mn:00004B84 ; ===========================================================================
.text$mn:00004B84
.text$mn:00004B84 ; Segment type: Pure code
.text$mn:00004B84 ; Segment permissions: Read/Execute
.text$mn:00004B84 _text$mn        segment para public 'CODE' use32
.text$mn:00004B84                 assume cs:_text$mn
.text$mn:00004B84                 ;org 4B84h
.text$mn:00004B84 ; COMDAT (pick any)
.text$mn:00004B84                 assume es:nothing, ss:nothing, ds:_data, fs:nothing, gs:nothing
.text$mn:00004B84
.text$mn:00004B84 ; =============== S U B R O U T I N E =======================================
.text$mn:00004B84
.text$mn:00004B84 ; Attributes: bp-based frame
.text$mn:00004B84
.text$mn:00004B84 ; public: __thiscall std::vector<struct Token, class std::allocator<struct Token>>::vector<struct Token, class std::allocator<struct Token>>(void)
.text$mn:00004B84                 public ??0?$vector@UToken@@V?$allocator@UToken@@@std@@@std@@QAE@XZ
.text$mn:00004B84 ??0?$vector@UToken@@V?$allocator@UToken@@@std@@@std@@QAE@XZ proc near
.text$mn:00004B84                                         ; CODE XREF: FunctionCallTip::getCursorFunction(void)+13Ep
.text$mn:00004B84
.text$mn:00004B84 var_14          = dword ptr -14h
.text$mn:00004B84 var_D           = byte ptr -0Dh
.text$mn:00004B84 var_C           = dword ptr -0Ch
.text$mn:00004B84 var_4           = dword ptr -4
.text$mn:00004B84
.text$mn:00004B84                 push    ebp
.text$mn:00004B85                 mov     ebp, esp
.text$mn:00004B87                 push    0FFFFFFFFh
.text$mn:00004B89                 push    offset __ehhandler$??0?$vector@UToken@@V?$allocator@UToken@@@std@@@std@@QAE@XZ
.text$mn:00004B8E                 mov     eax, large fs:0
.text$mn:00004B94                 push    eax
.text$mn:00004B95                 sub     esp, 8
.text$mn:00004B98                 mov     eax, dword ptr ds:___security_cookie
.text$mn:00004B9D                 xor     eax, ebp
.text$mn:00004B9F                 push    eax
.text$mn:00004BA0                 lea     eax, [ebp+var_C]
.text$mn:00004BA3                 mov     large fs:0, eax
.text$mn:00004BA9                 mov     [ebp+var_14], ecx
.text$mn:00004BAC                 lea     ecx, [ebp+var_D]
.text$mn:00004BAF                 call    ??0?$allocator@UToken@@@std@@QAE@XZ ; std::allocator<Token>::allocator<Token>(void)
.text$mn:00004BB4                 push    eax
.text$mn:00004BB5                 mov     ecx, [ebp+var_14]
.text$mn:00004BB8                 call    ??0?$_Vector_alloc@$0A@U?$_Vec_base_types@UToken@@V?$allocator@UToken@@@std@@@std@@@std@@QAE@ABV?$allocator@UToken@@@1@@Z ; std::_Vector_alloc<0,std::_Vec_base_types<Token,std::allocator<Token>>>::_Vector_alloc<0,std::_Vec_base_types<Token,std::allocator<Token>>>(std::allocator<Token> const &)
.text$mn:00004BBD                 mov     [ebp+var_4], 0
.text$mn:00004BC4                 mov     [ebp+var_4], 0FFFFFFFFh
.text$mn:00004BCB                 mov     eax, [ebp+var_14]
.text$mn:00004BCE                 mov     ecx, [ebp+var_C]
.text$mn:00004BD1                 mov     large fs:0, ecx
.text$mn:00004BD8                 pop     ecx
.text$mn:00004BD9                 mov     esp, ebp
.text$mn:00004BDB                 pop     ebp
.text$mn:00004BDC                 retn
.text$mn:00004BDC ??0?$vector@UToken@@V?$allocator@UToken@@@std@@@std@@QAE@XZ endp
.text$mn:00004BDC
.text$mn:00004BDC ; ---------------------------------------------------------------------------
.text$mn:00004BDD                 align 10h
.text$mn:00004BDD _text$mn        ends
.text$mn:00004BDD
.text$x:00004BE0 ; ===========================================================================
.text$x:00004BE0
.text$x:00004BE0 ; Segment type: Pure code
.text$x:00004BE0 ; Segment permissions: Read/Execute
.text$x:00004BE0 _text$x         segment para public 'CODE' use32
.text$x:00004BE0                 assume cs:_text$x
.text$x:00004BE0                 ;org 4BE0h
.text$x:00004BE0 ; COMDAT (pick associative to section at 4B84)
.text$x:00004BE0                 assume es:nothing, ss:nothing, ds:_data, fs:nothing, gs:nothing
.text$x:00004BE0
.text$x:00004BE0 ; =============== S U B R O U T I N E =======================================
.text$x:00004BE0
.text$x:00004BE0
.text$x:00004BE0 __unwindfunclet$??0?$vector@UToken@@V?$allocator@UToken@@@std@@@std@@QAE@XZ$0 proc near
.text$x:00004BE0                                         ; DATA XREF: .xdata$x:00009A68o
.text$x:00004BE0                 mov     ecx, [ebp-14h]
.text$x:00004BE3                 jmp     ??1?$_Vector_alloc@$0A@U?$_Vec_base_types@UToken@@V?$allocator@UToken@@@std@@@std@@@std@@QAE@XZ ; std::_Vector_alloc<0,std::_Vec_base_types<Token,std::allocator<Token>>>::~_Vector_alloc<0,std::_Vec_base_types<Token,std::allocator<Token>>>(void)
.text$x:00004BE3 __unwindfunclet$??0?$vector@UToken@@V?$allocator@UToken@@@std@@@std@@QAE@XZ$0 endp
.text$x:00004BE3
.text$x:00004BE8
.text$x:00004BE8 ; =============== S U B R O U T I N E =======================================
.text$x:00004BE8
.text$x:00004BE8
.text$x:00004BE8 __ehhandler$??0?$vector@UToken@@V?$allocator@UToken@@@std@@@std@@QAE@XZ proc near
.text$x:00004BE8                                         ; DATA XREF: std::vector<Token,std::allocator<Token>>::vector<Token,std::allocator<Token>>(void)+5o
.text$x:00004BE8
.text$x:00004BE8 arg_4           = dword ptr  8
.text$x:00004BE8
.text$x:00004BE8                 mov     edx, [esp+arg_4]
.text$x:00004BEC                 lea     eax, [edx+0Ch]
.text$x:00004BEF                 mov     ecx, [edx-0Ch]
.text$x:00004BF2                 xor     ecx, eax
.text$x:00004BF4                 call    @__security_check_cookie@4 ; __security_check_cookie(x)
.text$x:00004BF9                 mov     eax, offset __ehfuncinfo$??0?$vector@UToken@@V?$allocator@UToken@@@std@@@std@@QAE@XZ
.text$x:00004BFE                 jmp     ___CxxFrameHandler3
.text$x:00004BFE __ehhandler$??0?$vector@UToken@@V?$allocator@UToken@@@std@@@std@@QAE@XZ endp
.text$x:00004BFE
.text$x:00004BFE ; ---------------------------------------------------------------------------
.text$x:00004C03                 align 4
.text$x:00004C03 _text$x         ends
.text$x:00004C03
.text$mn:00004C04 ; ===========================================================================
.text$mn:00004C04
.text$mn:00004C04 ; Segment type: Pure code
.text$mn:00004C04 ; Segment permissions: Read/Execute
.text$mn:00004C04 _text$mn        segment para public 'CODE' use32
.text$mn:00004C04                 assume cs:_text$mn
.text$mn:00004C04                 ;org 4C04h
.text$mn:00004C04 ; COMDAT (pick any)
.text$mn:00004C04                 assume es:nothing, ss:nothing, ds:_data, fs:nothing, gs:nothing
.text$mn:00004C04
.text$mn:00004C04 ; =============== S U B R O U T I N E =======================================
.text$mn:00004C04
.text$mn:00004C04 ; Attributes: bp-based frame
.text$mn:00004C04
.text$mn:00004C04 ; _DWORD __thiscall FunctionValues::FunctionValues(FunctionValues *__hidden this)
.text$mn:00004C04                 public ??0FunctionValues@@QAE@XZ
.text$mn:00004C04 ??0FunctionValues@@QAE@XZ proc near     ; CODE XREF: FunctionCallTip::getCursorFunction(void)+32Fp
.text$mn:00004C04                                         ; FunctionCallTip::getCursorFunction(void)+33Ap ...
.text$mn:00004C04
.text$mn:00004C04 var_4           = dword ptr -4
.text$mn:00004C04
.text$mn:00004C04                 push    ebp
.text$mn:00004C05                 mov     ebp, esp
.text$mn:00004C07                 push    ecx
.text$mn:00004C08                 mov     [ebp+var_4], ecx
.text$mn:00004C0B                 mov     eax, [ebp+var_4]
.text$mn:00004C0E                 mov     dword ptr [eax], 0FFFFFFFFh
.text$mn:00004C14                 mov     ecx, [ebp+var_4]
.text$mn:00004C17                 mov     dword ptr [ecx+4], 0FFFFFFFFh
.text$mn:00004C1E                 mov     edx, [ebp+var_4]
.text$mn:00004C21                 mov     dword ptr [edx+8], 0
.text$mn:00004C28                 mov     eax, [ebp+var_4]
.text$mn:00004C2B                 mov     dword ptr [eax+0Ch], 0FFFFFFFFh
.text$mn:00004C32                 mov     eax, [ebp+var_4]
.text$mn:00004C35                 mov     esp, ebp
.text$mn:00004C37                 pop     ebp
.text$mn:00004C38                 retn
.text$mn:00004C38 ??0FunctionValues@@QAE@XZ endp
.text$mn:00004C38
.text$mn:00004C38 ; ---------------------------------------------------------------------------
.text$mn:00004C39                 align 4
.text$mn:00004C39 _text$mn        ends
.text$mn:00004C39
.text$mn:00004C3C ; ===========================================================================
.text$mn:00004C3C
.text$mn:00004C3C ; Segment type: Pure code
.text$mn:00004C3C ; Segment permissions: Read/Execute
.text$mn:00004C3C _text$mn        segment para public 'CODE' use32
.text$mn:00004C3C                 assume cs:_text$mn
.text$mn:00004C3C                 ;org 4C3Ch
.text$mn:00004C3C ; COMDAT (pick any)
.text$mn:00004C3C                 assume es:nothing, ss:nothing, ds:_data, fs:nothing, gs:nothing
.text$mn:00004C3C
.text$mn:00004C3C ; =============== S U B R O U T I N E =======================================
.text$mn:00004C3C
.text$mn:00004C3C ; Attributes: bp-based frame
.text$mn:00004C3C
.text$mn:00004C3C ; _DWORD __thiscall Token::Token(Token *this, wchar_t *, int, bool)
.text$mn:00004C3C                 public ??0Token@@QAE@PA_WH_N@Z
.text$mn:00004C3C ??0Token@@QAE@PA_WH_N@Z proc near       ; CODE XREF: FunctionCallTip::getCursorFunction(void)+278p
.text$mn:00004C3C                                         ; FunctionCallTip::getCursorFunction(void)+2F3p
.text$mn:00004C3C
.text$mn:00004C3C var_4           = dword ptr -4
.text$mn:00004C3C arg_0           = dword ptr  8
.text$mn:00004C3C arg_4           = dword ptr  0Ch
.text$mn:00004C3C arg_8           = byte ptr  10h
.text$mn:00004C3C
.text$mn:00004C3C                 push    ebp
.text$mn:00004C3D                 mov     ebp, esp
.text$mn:00004C3F                 push    ecx
.text$mn:00004C40                 mov     [ebp+var_4], ecx
.text$mn:00004C43                 mov     eax, [ebp+var_4]
.text$mn:00004C46                 mov     ecx, [ebp+arg_0]
.text$mn:00004C49                 mov     [eax], ecx
.text$mn:00004C4B                 mov     edx, [ebp+var_4]
.text$mn:00004C4E                 mov     eax, [ebp+arg_4]
.text$mn:00004C51                 mov     [edx+4], eax
.text$mn:00004C54                 mov     ecx, [ebp+var_4]
.text$mn:00004C57                 mov     dl, [ebp+arg_8]
.text$mn:00004C5A                 mov     [ecx+8], dl
.text$mn:00004C5D                 mov     eax, [ebp+var_4]
.text$mn:00004C60                 mov     esp, ebp
.text$mn:00004C62                 pop     ebp
.text$mn:00004C63                 retn    0Ch
.text$mn:00004C63 ??0Token@@QAE@PA_WH_N@Z endp
.text$mn:00004C63
.text$mn:00004C63 ; ---------------------------------------------------------------------------
.text$mn:00004C66                 align 4
.text$mn:00004C66 _text$mn        ends
.text$mn:00004C66
.text$mn:00004C68 ; ===========================================================================
.text$mn:00004C68
.text$mn:00004C68 ; Segment type: Pure code
.text$mn:00004C68 ; Segment permissions: Read/Execute
.text$mn:00004C68 _text$mn        segment para public 'CODE' use32
.text$mn:00004C68                 assume cs:_text$mn
.text$mn:00004C68                 ;org 4C68h
.text$mn:00004C68 ; COMDAT (pick any)
.text$mn:00004C68                 assume es:nothing, ss:nothing, ds:_data, fs:nothing, gs:nothing
.text$mn:00004C68
.text$mn:00004C68 ; =============== S U B R O U T I N E =======================================
.text$mn:00004C68
.text$mn:00004C68 ; Attributes: bp-based frame
.text$mn:00004C68
.text$mn:00004C68 ; _DWORD __thiscall std::_Container_base12::_Container_base12(std::_Container_base12 *__hidden this)
.text$mn:00004C68                 public ??0_Container_base12@std@@QAE@XZ
.text$mn:00004C68 ??0_Container_base12@std@@QAE@XZ proc near
.text$mn:00004C68                                         ; CODE XREF: std::_String_val<std::_Simple_types<char>>::_String_val<std::_Simple_types<char>>(void)+29p
.text$mn:00004C68                                         ; std::_Vector_val<std::_Simple_types<wchar_t const *>>::_Vector_val<std::_Simple_types<wchar_t const *>>(void)+29p ...
.text$mn:00004C68
.text$mn:00004C68 var_4           = dword ptr -4
.text$mn:00004C68
.text$mn:00004C68                 push    ebp
.text$mn:00004C69                 mov     ebp, esp
.text$mn:00004C6B                 push    ecx
.text$mn:00004C6C                 mov     [ebp+var_4], ecx
.text$mn:00004C6F                 mov     eax, [ebp+var_4]
.text$mn:00004C72                 mov     dword ptr [eax], 0
.text$mn:00004C78                 mov     eax, [ebp+var_4]
.text$mn:00004C7B                 mov     esp, ebp
.text$mn:00004C7D                 pop     ebp
.text$mn:00004C7E                 retn
.text$mn:00004C7E ??0_Container_base12@std@@QAE@XZ endp
.text$mn:00004C7E
.text$mn:00004C7E ; ---------------------------------------------------------------------------
.text$mn:00004C7F                 align 10h
.text$mn:00004C7F _text$mn        ends
.text$mn:00004C7F
.text$mn:00004C80 ; ===========================================================================
.text$mn:00004C80
.text$mn:00004C80 ; Segment type: Pure code
.text$mn:00004C80 ; Segment permissions: Read/Execute
.text$mn:00004C80 _text$mn        segment para public 'CODE' use32
.text$mn:00004C80                 assume cs:_text$mn
.text$mn:00004C80                 ;org 4C80h
.text$mn:00004C80 ; COMDAT (pick any)
.text$mn:00004C80                 assume es:nothing, ss:nothing, ds:_data, fs:nothing, gs:nothing
.text$mn:00004C80
.text$mn:00004C80 ; =============== S U B R O U T I N E =======================================
.text$mn:00004C80
.text$mn:00004C80 ; Attributes: bp-based frame
.text$mn:00004C80
.text$mn:00004C80 ; _DWORD __thiscall std::_Container_proxy::_Container_proxy(std::_Container_proxy *__hidden this)
.text$mn:00004C80                 public ??0_Container_proxy@std@@QAE@XZ
.text$mn:00004C80 ??0_Container_proxy@std@@QAE@XZ proc near
.text$mn:00004C80                                         ; CODE XREF: std::_String_alloc<0,std::_String_base_types<char,std::allocator<char>>>::_Alloc_proxy(void)+23p
.text$mn:00004C80                                         ; std::_Vector_alloc<0,std::_Vec_base_types<wchar_t const *,std::allocator<wchar_t const *>>>::_Alloc_proxy(void)+23p ...
.text$mn:00004C80
.text$mn:00004C80 var_4           = dword ptr -4
.text$mn:00004C80
.text$mn:00004C80                 push    ebp
.text$mn:00004C81                 mov     ebp, esp
.text$mn:00004C83                 push    ecx
.text$mn:00004C84                 mov     [ebp+var_4], ecx
.text$mn:00004C87                 mov     eax, [ebp+var_4]
.text$mn:00004C8A                 mov     dword ptr [eax], 0
.text$mn:00004C90                 mov     ecx, [ebp+var_4]
.text$mn:00004C93                 mov     dword ptr [ecx+4], 0
.text$mn:00004C9A                 mov     eax, [ebp+var_4]
.text$mn:00004C9D                 mov     esp, ebp
.text$mn:00004C9F                 pop     ebp
.text$mn:00004CA0                 retn
.text$mn:00004CA0 ??0_Container_proxy@std@@QAE@XZ endp
.text$mn:00004CA0
.text$mn:00004CA0 ; ---------------------------------------------------------------------------
.text$mn:00004CA1                 align 4
.text$mn:00004CA1 _text$mn        ends
.text$mn:00004CA1
.text$mn:00004CA4 ; ===========================================================================
.text$mn:00004CA4
.text$mn:00004CA4 ; Segment type: Pure code
.text$mn:00004CA4 ; Segment permissions: Read/Execute
.text$mn:00004CA4 _text$mn        segment para public 'CODE' use32
.text$mn:00004CA4                 assume cs:_text$mn
.text$mn:00004CA4                 ;org 4CA4h
.text$mn:00004CA4 ; COMDAT (pick any)
.text$mn:00004CA4                 assume es:nothing, ss:nothing, ds:_data, fs:nothing, gs:nothing
.text$mn:00004CA4
.text$mn:00004CA4 ; =============== S U B R O U T I N E =======================================
.text$mn:00004CA4
.text$mn:00004CA4 ; Attributes: bp-based frame
.text$mn:00004CA4
.text$mn:00004CA4 ; _DWORD __thiscall std::_Generic_error_category::_Generic_error_category(std::_Generic_error_category *__hidden this)
.text$mn:00004CA4                 public ??0_Generic_error_category@std@@QAE@XZ
.text$mn:00004CA4 ??0_Generic_error_category@std@@QAE@XZ proc near
.text$mn:00004CA4                                         ; CODE XREF: std::_Iostream_error_category::_Iostream_error_category(void)+29p
.text$mn:00004CA4                                         ; std::_System_error_category::_System_error_category(void)+29p ...
.text$mn:00004CA4
.text$mn:00004CA4 var_10          = dword ptr -10h
.text$mn:00004CA4 var_C           = dword ptr -0Ch
.text$mn:00004CA4 var_4           = dword ptr -4
.text$mn:00004CA4
.text$mn:00004CA4                 push    ebp
.text$mn:00004CA5                 mov     ebp, esp
.text$mn:00004CA7                 push    0FFFFFFFFh
.text$mn:00004CA9                 push    offset __ehhandler$??0_Generic_error_category@std@@QAE@XZ
.text$mn:00004CAE                 mov     eax, large fs:0
.text$mn:00004CB4                 push    eax
.text$mn:00004CB5                 push    ecx
.text$mn:00004CB6                 mov     eax, dword ptr ds:___security_cookie
.text$mn:00004CBB                 xor     eax, ebp
.text$mn:00004CBD                 push    eax
.text$mn:00004CBE                 lea     eax, [ebp+var_C]
.text$mn:00004CC1                 mov     large fs:0, eax
.text$mn:00004CC7                 mov     [ebp+var_10], ecx
.text$mn:00004CCA                 mov     ecx, [ebp+var_10] ; this
.text$mn:00004CCD                 call    ??0error_category@std@@QAE@XZ ; std::error_category::error_category(void)
.text$mn:00004CD2                 mov     [ebp+var_4], 0
.text$mn:00004CD9                 mov     eax, [ebp+var_10]
.text$mn:00004CDC                 mov     dword ptr [eax], offset ??_7_Generic_error_category@std@@6B@ ; const std::_Generic_error_category::`vftable'
.text$mn:00004CE2                 mov     [ebp+var_4], 0FFFFFFFFh
.text$mn:00004CE9                 mov     eax, [ebp+var_10]
.text$mn:00004CEC                 mov     ecx, [ebp+var_C]
.text$mn:00004CEF                 mov     large fs:0, ecx
.text$mn:00004CF6                 pop     ecx
.text$mn:00004CF7                 mov     esp, ebp
.text$mn:00004CF9                 pop     ebp
.text$mn:00004CFA                 retn
.text$mn:00004CFA ??0_Generic_error_category@std@@QAE@XZ endp
.text$mn:00004CFA
.text$mn:00004CFA ; ---------------------------------------------------------------------------
.text$mn:00004CFB                 align 4
.text$mn:00004CFB _text$mn        ends
.text$mn:00004CFB
.text$x:00004CFC ; ===========================================================================
.text$x:00004CFC
.text$x:00004CFC ; Segment type: Pure code
.text$x:00004CFC ; Segment permissions: Read/Execute
.text$x:00004CFC _text$x         segment para public 'CODE' use32
.text$x:00004CFC                 assume cs:_text$x
.text$x:00004CFC                 ;org 4CFCh
.text$x:00004CFC ; COMDAT (pick associative to section at 4CA4)
.text$x:00004CFC                 assume es:nothing, ss:nothing, ds:_data, fs:nothing, gs:nothing
.text$x:00004CFC
.text$x:00004CFC ; =============== S U B R O U T I N E =======================================
.text$x:00004CFC
.text$x:00004CFC
.text$x:00004CFC __unwindfunclet$??0_Generic_error_category@std@@QAE@XZ$0 proc near
.text$x:00004CFC                                         ; DATA XREF: .xdata$x:0000949Co
.text$x:00004CFC                 mov     ecx, [ebp-10h]  ; this
.text$x:00004CFF                 jmp     ??1error_category@std@@UAE@XZ ; std::error_category::~error_category(void)
.text$x:00004CFF __unwindfunclet$??0_Generic_error_category@std@@QAE@XZ$0 endp
.text$x:00004CFF
.text$x:00004D04
.text$x:00004D04 ; =============== S U B R O U T I N E =======================================
.text$x:00004D04
.text$x:00004D04
.text$x:00004D04 __ehhandler$??0_Generic_error_category@std@@QAE@XZ proc near
.text$x:00004D04                                         ; DATA XREF: std::_Generic_error_category::_Generic_error_category(void)+5o
.text$x:00004D04
.text$x:00004D04 arg_4           = dword ptr  8
.text$x:00004D04
.text$x:00004D04                 mov     edx, [esp+arg_4]
.text$x:00004D08                 lea     eax, [edx+0Ch]
.text$x:00004D0B                 mov     ecx, [edx-8]
.text$x:00004D0E                 xor     ecx, eax
.text$x:00004D10                 call    @__security_check_cookie@4 ; __security_check_cookie(x)
.text$x:00004D15                 mov     eax, offset __ehfuncinfo$??0_Generic_error_category@std@@QAE@XZ
.text$x:00004D1A                 jmp     ___CxxFrameHandler3
.text$x:00004D1A __ehhandler$??0_Generic_error_category@std@@QAE@XZ endp
.text$x:00004D1A
.text$x:00004D1A ; ---------------------------------------------------------------------------
.text$x:00004D1F                 align 10h
.text$x:00004D1F _text$x         ends
.text$x:00004D1F
.text$mn:00004D20 ; ===========================================================================
.text$mn:00004D20
.text$mn:00004D20 ; Segment type: Pure code
.text$mn:00004D20 ; Segment permissions: Read/Execute
.text$mn:00004D20 _text$mn        segment para public 'CODE' use32
.text$mn:00004D20                 assume cs:_text$mn
.text$mn:00004D20                 ;org 4D20h
.text$mn:00004D20 ; COMDAT (pick any)
.text$mn:00004D20                 assume es:nothing, ss:nothing, ds:_data, fs:nothing, gs:nothing
.text$mn:00004D20
.text$mn:00004D20 ; =============== S U B R O U T I N E =======================================
.text$mn:00004D20
.text$mn:00004D20 ; Attributes: bp-based frame
.text$mn:00004D20
.text$mn:00004D20 ; _DWORD __thiscall std::_Ignore::_Ignore(std::_Ignore *__hidden this)
.text$mn:00004D20                 public ??0_Ignore@std@@QAE@XZ
.text$mn:00004D20 ??0_Ignore@std@@QAE@XZ proc near        ; CODE XREF: std::`dynamic initializer for 'ignore''(void)+8p
.text$mn:00004D20
.text$mn:00004D20 var_4           = dword ptr -4
.text$mn:00004D20
.text$mn:00004D20                 push    ebp
.text$mn:00004D21                 mov     ebp, esp
.text$mn:00004D23                 push    ecx
.text$mn:00004D24                 mov     [ebp+var_4], ecx
.text$mn:00004D27                 mov     eax, [ebp+var_4]
.text$mn:00004D2A                 mov     esp, ebp
.text$mn:00004D2C                 pop     ebp
.text$mn:00004D2D                 retn
.text$mn:00004D2D ??0_Ignore@std@@QAE@XZ endp
.text$mn:00004D2D
.text$mn:00004D2D ; ---------------------------------------------------------------------------
.text$mn:00004D2E                 align 10h
.text$mn:00004D2E _text$mn        ends
.text$mn:00004D2E
.text$mn:00004D30 ; ===========================================================================
.text$mn:00004D30
.text$mn:00004D30 ; Segment type: Pure code
.text$mn:00004D30 ; Segment permissions: Read/Execute
.text$mn:00004D30 _text$mn        segment para public 'CODE' use32
.text$mn:00004D30                 assume cs:_text$mn
.text$mn:00004D30                 ;org 4D30h
.text$mn:00004D30 ; COMDAT (pick any)
.text$mn:00004D30                 assume es:nothing, ss:nothing, ds:_data, fs:nothing, gs:nothing
.text$mn:00004D30
.text$mn:00004D30 ; =============== S U B R O U T I N E =======================================
.text$mn:00004D30
.text$mn:00004D30 ; Attributes: bp-based frame
.text$mn:00004D30
.text$mn:00004D30 ; _DWORD __thiscall std::_Iostream_error_category::_Iostream_error_category(std::_Iostream_error_category *__hidden this)
.text$mn:00004D30                 public ??0_Iostream_error_category@std@@QAE@XZ
.text$mn:00004D30 ??0_Iostream_error_category@std@@QAE@XZ proc near
.text$mn:00004D30                                         ; CODE XREF: `dynamic initializer for 'std::_Iostream_error_category std::_Error_objects<int>::_Iostream_object''(void)+8p
.text$mn:00004D30
.text$mn:00004D30 var_10          = dword ptr -10h
.text$mn:00004D30 var_C           = dword ptr -0Ch
.text$mn:00004D30 var_4           = dword ptr -4
.text$mn:00004D30
.text$mn:00004D30                 push    ebp
.text$mn:00004D31                 mov     ebp, esp
.text$mn:00004D33                 push    0FFFFFFFFh
.text$mn:00004D35                 push    offset __ehhandler$??0_Iostream_error_category@std@@QAE@XZ
.text$mn:00004D3A                 mov     eax, large fs:0
.text$mn:00004D40                 push    eax
.text$mn:00004D41                 push    ecx
.text$mn:00004D42                 mov     eax, dword ptr ds:___security_cookie
.text$mn:00004D47                 xor     eax, ebp
.text$mn:00004D49                 push    eax
.text$mn:00004D4A                 lea     eax, [ebp+var_C]
.text$mn:00004D4D                 mov     large fs:0, eax
.text$mn:00004D53                 mov     [ebp+var_10], ecx
.text$mn:00004D56                 mov     ecx, [ebp+var_10] ; this
.text$mn:00004D59                 call    ??0_Generic_error_category@std@@QAE@XZ ; std::_Generic_error_category::_Generic_error_category(void)
.text$mn:00004D5E                 mov     [ebp+var_4], 0
.text$mn:00004D65                 mov     eax, [ebp+var_10]
.text$mn:00004D68                 mov     dword ptr [eax], offset ??_7_Iostream_error_category@std@@6B@ ; const std::_Iostream_error_category::`vftable'
.text$mn:00004D6E                 mov     [ebp+var_4], 0FFFFFFFFh
.text$mn:00004D75                 mov     eax, [ebp+var_10]
.text$mn:00004D78                 mov     ecx, [ebp+var_C]
.text$mn:00004D7B                 mov     large fs:0, ecx
.text$mn:00004D82                 pop     ecx
.text$mn:00004D83                 mov     esp, ebp
.text$mn:00004D85                 pop     ebp
.text$mn:00004D86                 retn
.text$mn:00004D86 ??0_Iostream_error_category@std@@QAE@XZ endp
.text$mn:00004D86
.text$mn:00004D86 ; ---------------------------------------------------------------------------
.text$mn:00004D87                 align 4
.text$mn:00004D87 _text$mn        ends
.text$mn:00004D87
.text$x:00004D88 ; ===========================================================================
.text$x:00004D88
.text$x:00004D88 ; Segment type: Pure code
.text$x:00004D88 ; Segment permissions: Read/Execute
.text$x:00004D88 _text$x         segment para public 'CODE' use32
.text$x:00004D88                 assume cs:_text$x
.text$x:00004D88                 ;org 4D88h
.text$x:00004D88 ; COMDAT (pick associative to section at 4D30)
.text$x:00004D88                 assume es:nothing, ss:nothing, ds:_data, fs:nothing, gs:nothing
.text$x:00004D88
.text$x:00004D88 ; =============== S U B R O U T I N E =======================================
.text$x:00004D88
.text$x:00004D88
.text$x:00004D88 __unwindfunclet$??0_Iostream_error_category@std@@QAE@XZ$0 proc near
.text$x:00004D88                                         ; DATA XREF: .xdata$x:00009520o
.text$x:00004D88                 mov     ecx, [ebp-10h]  ; this
.text$x:00004D8B                 jmp     ??1_Generic_error_category@std@@UAE@XZ ; std::_Generic_error_category::~_Generic_error_category(void)
.text$x:00004D8B __unwindfunclet$??0_Iostream_error_category@std@@QAE@XZ$0 endp
.text$x:00004D8B
.text$x:00004D90
.text$x:00004D90 ; =============== S U B R O U T I N E =======================================
.text$x:00004D90
.text$x:00004D90
.text$x:00004D90 __ehhandler$??0_Iostream_error_category@std@@QAE@XZ proc near
.text$x:00004D90                                         ; DATA XREF: std::_Iostream_error_category::_Iostream_error_category(void)+5o
.text$x:00004D90
.text$x:00004D90 arg_4           = dword ptr  8
.text$x:00004D90
.text$x:00004D90                 mov     edx, [esp+arg_4]
.text$x:00004D94                 lea     eax, [edx+0Ch]
.text$x:00004D97                 mov     ecx, [edx-8]
.text$x:00004D9A                 xor     ecx, eax
.text$x:00004D9C                 call    @__security_check_cookie@4 ; __security_check_cookie(x)
.text$x:00004DA1                 mov     eax, offset __ehfuncinfo$??0_Iostream_error_category@std@@QAE@XZ
.text$x:00004DA6                 jmp     ___CxxFrameHandler3
.text$x:00004DA6 __ehhandler$??0_Iostream_error_category@std@@QAE@XZ endp
.text$x:00004DA6
.text$x:00004DA6 ; ---------------------------------------------------------------------------
.text$x:00004DAB                 align 4
.text$x:00004DAB _text$x         ends
.text$x:00004DAB
.text$mn:00004DAC ; ===========================================================================
.text$mn:00004DAC
.text$mn:00004DAC ; Segment type: Pure code
.text$mn:00004DAC ; Segment permissions: Read/Execute
.text$mn:00004DAC _text$mn        segment para public 'CODE' use32
.text$mn:00004DAC                 assume cs:_text$mn
.text$mn:00004DAC                 ;org 4DACh
.text$mn:00004DAC ; COMDAT (pick any)
.text$mn:00004DAC                 assume es:nothing, ss:nothing, ds:_data, fs:nothing, gs:nothing
.text$mn:00004DAC
.text$mn:00004DAC ; =============== S U B R O U T I N E =======================================
.text$mn:00004DAC
.text$mn:00004DAC ; Attributes: bp-based frame
.text$mn:00004DAC
.text$mn:00004DAC ; _DWORD __thiscall std::_Iterator_base12::_Iterator_base12(std::_Iterator_base12 *this, const struct std::_Iterator_base12 *)
.text$mn:00004DAC                 public ??0_Iterator_base12@std@@QAE@ABU01@@Z
.text$mn:00004DAC ??0_Iterator_base12@std@@QAE@ABU01@@Z proc near
.text$mn:00004DAC                                         ; CODE XREF: std::_Iterator012<std::random_access_iterator_tag,wchar_t const *,int,wchar_t const * const *,wchar_t const * const &,std::_Iterator_base12>::_Iterator012<std::random_access_iterator_tag,wchar_t const *,int,wchar_t const * const *,wchar_t const * const &,std::_Iterator_base12>(std::_Iterator012<std::random_access_iterator_tag,wchar_t const *,int,wchar_t const * const *,wchar_t const * const &,std::_Iterator_base12> const &)+2Dp
.text$mn:00004DAC                                         ; std::_Iterator012<std::random_access_iterator_tag,FunctionValues,int,FunctionValues const *,FunctionValues const &,std::_Iterator_base12>::_Iterator012<std::random_access_iterator_tag,FunctionValues,int,FunctionValues const *,FunctionValues const &,std::_Iterator_base12>(std::_Iterator012<std::random_access_iterator_tag,FunctionValues,int,FunctionValues const *,FunctionValues const &,std::_Iterator_base12> const &)+2Dp
.text$mn:00004DAC
.text$mn:00004DAC var_4           = dword ptr -4
.text$mn:00004DAC arg_0           = dword ptr  8
.text$mn:00004DAC
.text$mn:00004DAC                 push    ebp
.text$mn:00004DAD                 mov     ebp, esp
.text$mn:00004DAF                 push    ecx
.text$mn:00004DB0                 mov     [ebp+var_4], ecx
.text$mn:00004DB3                 mov     eax, [ebp+var_4]
.text$mn:00004DB6                 mov     dword ptr [eax], 0
.text$mn:00004DBC                 mov     ecx, [ebp+var_4]
.text$mn:00004DBF                 mov     dword ptr [ecx+4], 0
.text$mn:00004DC6                 mov     edx, [ebp+arg_0]
.text$mn:00004DC9                 push    edx
.text$mn:00004DCA                 mov     ecx, [ebp+var_4]
.text$mn:00004DCD                 call    ??4_Iterator_base12@std@@QAEAAU01@ABU01@@Z ; std::_Iterator_base12::operator=(std::_Iterator_base12 const &)
.text$mn:00004DD2                 mov     eax, [ebp+var_4]
.text$mn:00004DD5                 mov     esp, ebp
.text$mn:00004DD7                 pop     ebp
.text$mn:00004DD8                 retn    4
.text$mn:00004DD8 ??0_Iterator_base12@std@@QAE@ABU01@@Z endp
.text$mn:00004DD8
.text$mn:00004DD8 ; ---------------------------------------------------------------------------
.text$mn:00004DDB                 align 4
.text$mn:00004DDB _text$mn        ends
.text$mn:00004DDB
.text$mn:00004DDC ; ===========================================================================
.text$mn:00004DDC
.text$mn:00004DDC ; Segment type: Pure code
.text$mn:00004DDC ; Segment permissions: Read/Execute
.text$mn:00004DDC _text$mn        segment para public 'CODE' use32
.text$mn:00004DDC                 assume cs:_text$mn
.text$mn:00004DDC                 ;org 4DDCh
.text$mn:00004DDC ; COMDAT (pick any)
.text$mn:00004DDC                 assume es:nothing, ss:nothing, ds:_data, fs:nothing, gs:nothing
.text$mn:00004DDC
.text$mn:00004DDC ; =============== S U B R O U T I N E =======================================
.text$mn:00004DDC
.text$mn:00004DDC ; Attributes: bp-based frame
.text$mn:00004DDC
.text$mn:00004DDC ; _DWORD __thiscall std::_Iterator_base12::_Iterator_base12(std::_Iterator_base12 *__hidden this)
.text$mn:00004DDC                 public ??0_Iterator_base12@std@@QAE@XZ
.text$mn:00004DDC ??0_Iterator_base12@std@@QAE@XZ proc near
.text$mn:00004DDC                                         ; CODE XREF: std::_Iterator012<std::random_access_iterator_tag,wchar_t const *,int,wchar_t const * const *,wchar_t const * const &,std::_Iterator_base12>::_Iterator012<std::random_access_iterator_tag,wchar_t const *,int,wchar_t const * const *,wchar_t const * const &,std::_Iterator_base12>(void)+29p
.text$mn:00004DDC                                         ; std::_Iterator012<std::random_access_iterator_tag,FunctionValues,int,FunctionValues const *,FunctionValues const &,std::_Iterator_base12>::_Iterator012<std::random_access_iterator_tag,FunctionValues,int,FunctionValues const *,FunctionValues const &,std::_Iterator_base12>(void)+29p
.text$mn:00004DDC
.text$mn:00004DDC var_4           = dword ptr -4
.text$mn:00004DDC
.text$mn:00004DDC                 push    ebp
.text$mn:00004DDD                 mov     ebp, esp
.text$mn:00004DDF                 push    ecx
.text$mn:00004DE0                 mov     [ebp+var_4], ecx
.text$mn:00004DE3                 mov     eax, [ebp+var_4]
.text$mn:00004DE6                 mov     dword ptr [eax], 0
.text$mn:00004DEC                 mov     ecx, [ebp+var_4]
.text$mn:00004DEF                 mov     dword ptr [ecx+4], 0
.text$mn:00004DF6                 mov     eax, [ebp+var_4]
.text$mn:00004DF9                 mov     esp, ebp
.text$mn:00004DFB                 pop     ebp
.text$mn:00004DFC                 retn
.text$mn:00004DFC ??0_Iterator_base12@std@@QAE@XZ endp
.text$mn:00004DFC
.text$mn:00004DFC ; ---------------------------------------------------------------------------
.text$mn:00004DFD                 align 10h
.text$mn:00004DFD _text$mn        ends
.text$mn:00004DFD
.text$mn:00004E00 ; ===========================================================================
.text$mn:00004E00
.text$mn:00004E00 ; Segment type: Pure code
.text$mn:00004E00 ; Segment permissions: Read/Execute
.text$mn:00004E00 _text$mn        segment para public 'CODE' use32
.text$mn:00004E00                 assume cs:_text$mn
.text$mn:00004E00                 ;org 4E00h
.text$mn:00004E00 ; COMDAT (pick any)
.text$mn:00004E00                 assume es:nothing, ss:nothing, ds:_data, fs:nothing, gs:nothing
.text$mn:00004E00
.text$mn:00004E00 ; =============== S U B R O U T I N E =======================================
.text$mn:00004E00
.text$mn:00004E00 ; Attributes: bp-based frame
.text$mn:00004E00
.text$mn:00004E00 ; _DWORD __thiscall std::_System_error_category::_System_error_category(std::_System_error_category *__hidden this)
.text$mn:00004E00                 public ??0_System_error_category@std@@QAE@XZ
.text$mn:00004E00 ??0_System_error_category@std@@QAE@XZ proc near
.text$mn:00004E00                                         ; CODE XREF: `dynamic initializer for 'std::_System_error_category std::_Error_objects<int>::_System_object''(void)+8p
.text$mn:00004E00
.text$mn:00004E00 var_10          = dword ptr -10h
.text$mn:00004E00 var_C           = dword ptr -0Ch
.text$mn:00004E00 var_4           = dword ptr -4
.text$mn:00004E00
.text$mn:00004E00                 push    ebp
.text$mn:00004E01                 mov     ebp, esp
.text$mn:00004E03                 push    0FFFFFFFFh
.text$mn:00004E05                 push    offset __ehhandler$??0_System_error_category@std@@QAE@XZ
.text$mn:00004E0A                 mov     eax, large fs:0
.text$mn:00004E10                 push    eax
.text$mn:00004E11                 push    ecx
.text$mn:00004E12                 mov     eax, dword ptr ds:___security_cookie
.text$mn:00004E17                 xor     eax, ebp
.text$mn:00004E19                 push    eax
.text$mn:00004E1A                 lea     eax, [ebp+var_C]
.text$mn:00004E1D                 mov     large fs:0, eax
.text$mn:00004E23                 mov     [ebp+var_10], ecx
.text$mn:00004E26                 mov     ecx, [ebp+var_10] ; this
.text$mn:00004E29                 call    ??0_Generic_error_category@std@@QAE@XZ ; std::_Generic_error_category::_Generic_error_category(void)
.text$mn:00004E2E                 mov     [ebp+var_4], 0
.text$mn:00004E35                 mov     eax, [ebp+var_10]
.text$mn:00004E38                 mov     dword ptr [eax], offset ??_7_System_error_category@std@@6B@ ; const std::_System_error_category::`vftable'
.text$mn:00004E3E                 mov     [ebp+var_4], 0FFFFFFFFh
.text$mn:00004E45                 mov     eax, [ebp+var_10]
.text$mn:00004E48                 mov     ecx, [ebp+var_C]
.text$mn:00004E4B                 mov     large fs:0, ecx
.text$mn:00004E52                 pop     ecx
.text$mn:00004E53                 mov     esp, ebp
.text$mn:00004E55                 pop     ebp
.text$mn:00004E56                 retn
.text$mn:00004E56 ??0_System_error_category@std@@QAE@XZ endp
.text$mn:00004E56
.text$mn:00004E56 ; ---------------------------------------------------------------------------
.text$mn:00004E57                 align 4
.text$mn:00004E57 _text$mn        ends
.text$mn:00004E57
.text$x:00004E58 ; ===========================================================================
.text$x:00004E58
.text$x:00004E58 ; Segment type: Pure code
.text$x:00004E58 ; Segment permissions: Read/Execute
.text$x:00004E58 _text$x         segment para public 'CODE' use32
.text$x:00004E58                 assume cs:_text$x
.text$x:00004E58                 ;org 4E58h
.text$x:00004E58 ; COMDAT (pick associative to section at 4E00)
.text$x:00004E58                 assume es:nothing, ss:nothing, ds:_data, fs:nothing, gs:nothing
.text$x:00004E58
.text$x:00004E58 ; =============== S U B R O U T I N E =======================================
.text$x:00004E58
.text$x:00004E58
.text$x:00004E58 __unwindfunclet$??0_System_error_category@std@@QAE@XZ$0 proc near
.text$x:00004E58                                         ; DATA XREF: .xdata$x:000095A4o
.text$x:00004E58                 mov     ecx, [ebp-10h]  ; this
.text$x:00004E5B                 jmp     ??1_Generic_error_category@std@@UAE@XZ ; std::_Generic_error_category::~_Generic_error_category(void)
.text$x:00004E5B __unwindfunclet$??0_System_error_category@std@@QAE@XZ$0 endp
.text$x:00004E5B
.text$x:00004E60
.text$x:00004E60 ; =============== S U B R O U T I N E =======================================
.text$x:00004E60
.text$x:00004E60
.text$x:00004E60 __ehhandler$??0_System_error_category@std@@QAE@XZ proc near
.text$x:00004E60                                         ; DATA XREF: std::_System_error_category::_System_error_category(void)+5o
.text$x:00004E60
.text$x:00004E60 arg_4           = dword ptr  8
.text$x:00004E60
.text$x:00004E60                 mov     edx, [esp+arg_4]
.text$x:00004E64                 lea     eax, [edx+0Ch]
.text$x:00004E67                 mov     ecx, [edx-8]
.text$x:00004E6A                 xor     ecx, eax
.text$x:00004E6C                 call    @__security_check_cookie@4 ; __security_check_cookie(x)
.text$x:00004E71                 mov     eax, offset __ehfuncinfo$??0_System_error_category@std@@QAE@XZ
.text$x:00004E76                 jmp     ___CxxFrameHandler3
.text$x:00004E76 __ehhandler$??0_System_error_category@std@@QAE@XZ endp
.text$x:00004E76
.text$x:00004E76 ; ---------------------------------------------------------------------------
.text$x:00004E7B                 align 4
.text$x:00004E7B _text$x         ends
.text$x:00004E7B
.text$mn:00004E7C ; ===========================================================================
.text$mn:00004E7C
.text$mn:00004E7C ; Segment type: Pure code
.text$mn:00004E7C ; Segment permissions: Read/Execute
.text$mn:00004E7C _text$mn        segment para public 'CODE' use32
.text$mn:00004E7C                 assume cs:_text$mn
.text$mn:00004E7C                 ;org 4E7Ch
.text$mn:00004E7C ; COMDAT (pick any)
.text$mn:00004E7C                 assume es:nothing, ss:nothing, ds:_data, fs:nothing, gs:nothing
.text$mn:00004E7C
.text$mn:00004E7C ; =============== S U B R O U T I N E =======================================
.text$mn:00004E7C
.text$mn:00004E7C ; Attributes: bp-based frame
.text$mn:00004E7C
.text$mn:00004E7C ; _DWORD __thiscall std::error_category::error_category(std::error_category *__hidden this)
.text$mn:00004E7C                 public ??0error_category@std@@QAE@XZ
.text$mn:00004E7C ??0error_category@std@@QAE@XZ proc near ; CODE XREF: std::_Generic_error_category::_Generic_error_category(void)+29p
.text$mn:00004E7C
.text$mn:00004E7C var_4           = dword ptr -4
.text$mn:00004E7C
.text$mn:00004E7C                 push    ebp
.text$mn:00004E7D                 mov     ebp, esp
.text$mn:00004E7F                 push    ecx
.text$mn:00004E80                 mov     [ebp+var_4], ecx
.text$mn:00004E83                 mov     eax, [ebp+var_4]
.text$mn:00004E86                 mov     dword ptr [eax], offset ??_7error_category@std@@6B@ ; const std::error_category::`vftable'
.text$mn:00004E8C                 mov     eax, [ebp+var_4]
.text$mn:00004E8F                 mov     esp, ebp
.text$mn:00004E91                 pop     ebp
.text$mn:00004E92                 retn
.text$mn:00004E92 ??0error_category@std@@QAE@XZ endp
.text$mn:00004E92
.text$mn:00004E92 ; ---------------------------------------------------------------------------
.text$mn:00004E93                 align 4
.text$mn:00004E93 _text$mn        ends
.text$mn:00004E93
.text$mn:00004E94 ; ===========================================================================
.text$mn:00004E94
.text$mn:00004E94 ; Segment type: Pure code
.text$mn:00004E94 ; Segment permissions: Read/Execute
.text$mn:00004E94 _text$mn        segment para public 'CODE' use32
.text$mn:00004E94                 assume cs:_text$mn
.text$mn:00004E94                 ;org 4E94h
.text$mn:00004E94 ; COMDAT (pick any)
.text$mn:00004E94                 assume es:nothing, ss:nothing, ds:_data, fs:nothing, gs:nothing
.text$mn:00004E94
.text$mn:00004E94 ; =============== S U B R O U T I N E =======================================
.text$mn:00004E94
.text$mn:00004E94 ; Attributes: bp-based frame
.text$mn:00004E94
.text$mn:00004E94 ; _DWORD __thiscall std::error_condition::error_condition(std::error_condition *this, int, const struct std::error_category *)
.text$mn:00004E94                 public ??0error_condition@std@@QAE@HABVerror_category@1@@Z
.text$mn:00004E94 ??0error_condition@std@@QAE@HABVerror_category@1@@Z proc near
.text$mn:00004E94                                         ; CODE XREF: std::_System_error_category::default_error_condition(int)+24p
.text$mn:00004E94                                         ; std::_System_error_category::default_error_condition(int)+3Dp ...
.text$mn:00004E94
.text$mn:00004E94 var_4           = dword ptr -4
.text$mn:00004E94 arg_0           = dword ptr  8
.text$mn:00004E94 arg_4           = dword ptr  0Ch
.text$mn:00004E94
.text$mn:00004E94                 push    ebp
.text$mn:00004E95                 mov     ebp, esp
.text$mn:00004E97                 push    ecx
.text$mn:00004E98                 mov     [ebp+var_4], ecx
.text$mn:00004E9B                 mov     eax, [ebp+var_4]
.text$mn:00004E9E                 mov     ecx, [ebp+arg_0]
.text$mn:00004EA1                 mov     [eax], ecx
.text$mn:00004EA3                 mov     edx, [ebp+var_4]
.text$mn:00004EA6                 mov     eax, [ebp+arg_4]
.text$mn:00004EA9                 mov     [edx+4], eax
.text$mn:00004EAC                 mov     eax, [ebp+var_4]
.text$mn:00004EAF                 mov     esp, ebp
.text$mn:00004EB1                 pop     ebp
.text$mn:00004EB2                 retn    8
.text$mn:00004EB2 ??0error_condition@std@@QAE@HABVerror_category@1@@Z endp
.text$mn:00004EB2
.text$mn:00004EB2 ; ---------------------------------------------------------------------------
.text$mn:00004EB5                 align 4
.text$mn:00004EB5 _text$mn        ends
.text$mn:00004EB5
.text$mn:00004EB8 ; ===========================================================================
.text$mn:00004EB8
.text$mn:00004EB8 ; Segment type: Pure code
.text$mn:00004EB8 ; Segment permissions: Read/Execute
.text$mn:00004EB8 _text$mn        segment para public 'CODE' use32
.text$mn:00004EB8                 assume cs:_text$mn
.text$mn:00004EB8                 ;org 4EB8h
.text$mn:00004EB8 ; COMDAT (pick any)
.text$mn:00004EB8                 assume es:nothing, ss:nothing, ds:_data, fs:nothing, gs:nothing
.text$mn:00004EB8
.text$mn:00004EB8 ; =============== S U B R O U T I N E =======================================
.text$mn:00004EB8
.text$mn:00004EB8 ; Attributes: bp-based frame
.text$mn:00004EB8
.text$mn:00004EB8 ; _DWORD __thiscall std::locale::id::id(std::locale::id *this, unsigned int)
.text$mn:00004EB8                 public ??0id@locale@std@@QAE@I@Z
.text$mn:00004EB8 ??0id@locale@std@@QAE@I@Z proc near     ; CODE XREF: `dynamic initializer for 'std::locale::id std::num_put<char,std::back_insert_iterator<std::basic_string<char,std::char_traits<char>,std::allocator<char>>>>::id''(void)+Ap
.text$mn:00004EB8                                         ; `dynamic initializer for 'std::locale::id std::num_put<wchar_t,std::back_insert_iterator<std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>>>>::id''(void)+Ap ...
.text$mn:00004EB8
.text$mn:00004EB8 var_4           = dword ptr -4
.text$mn:00004EB8 arg_0           = dword ptr  8
.text$mn:00004EB8
.text$mn:00004EB8                 push    ebp
.text$mn:00004EB9                 mov     ebp, esp
.text$mn:00004EBB                 push    ecx
.text$mn:00004EBC                 mov     [ebp+var_4], ecx
.text$mn:00004EBF                 mov     eax, [ebp+var_4]
.text$mn:00004EC2                 mov     ecx, [ebp+arg_0]
.text$mn:00004EC5                 mov     [eax], ecx
.text$mn:00004EC7                 mov     eax, [ebp+var_4]
.text$mn:00004ECA                 mov     esp, ebp
.text$mn:00004ECC                 pop     ebp
.text$mn:00004ECD                 retn    4
.text$mn:00004ECD ??0id@locale@std@@QAE@I@Z endp
.text$mn:00004ECD
.text$mn:00004ECD _text$mn        ends
.text$mn:00004ECD
.text$mn:00004ED0 ; ===========================================================================
.text$mn:00004ED0
.text$mn:00004ED0 ; Segment type: Pure code
.text$mn:00004ED0 ; Segment permissions: Read/Execute
.text$mn:00004ED0 _text$mn        segment para public 'CODE' use32
.text$mn:00004ED0                 assume cs:_text$mn
.text$mn:00004ED0                 ;org 4ED0h
.text$mn:00004ED0 ; COMDAT (pick any)
.text$mn:00004ED0                 assume es:nothing, ss:nothing, ds:_data, fs:nothing, gs:nothing
.text$mn:00004ED0
.text$mn:00004ED0 ; =============== S U B R O U T I N E =======================================
.text$mn:00004ED0
.text$mn:00004ED0 ; Attributes: bp-based frame
.text$mn:00004ED0
.text$mn:00004ED0 ; public: __thiscall std::_Iterator012<struct std::random_access_iterator_tag, wchar_t const *, int, wchar_t const * const *, wchar_t const * const &, struct std::_Iterator_base12>::~_Iterator012<struct std::random_access_iterator_tag, wchar_t const *, int, wchar_t const * const *, wchar_t const * const &, struct std::_Iterator_base12>(void)
.text$mn:00004ED0                 public ??1?$_Iterator012@Urandom_access_iterator_tag@std@@PB_WHPBQB_WABQB_WU_Iterator_base12@2@@std@@QAE@XZ
.text$mn:00004ED0 ??1?$_Iterator012@Urandom_access_iterator_tag@std@@PB_WHPBQB_WABQB_WU_Iterator_base12@2@@std@@QAE@XZ proc near
.text$mn:00004ED0                                         ; CODE XREF: __unwindfunclet$??0?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@PB_W@std@@@std@@@std@@QAE@ABV01@@Z$0+3j
.text$mn:00004ED0                                         ; __unwindfunclet$??0?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@PB_W@std@@@std@@@std@@QAE@PAPB_WPBU_Container_base12@1@@Z$0+3j ...
.text$mn:00004ED0
.text$mn:00004ED0 var_10          = dword ptr -10h
.text$mn:00004ED0 var_C           = dword ptr -0Ch
.text$mn:00004ED0 var_4           = dword ptr -4
.text$mn:00004ED0
.text$mn:00004ED0                 push    ebp
.text$mn:00004ED1                 mov     ebp, esp
.text$mn:00004ED3                 push    0FFFFFFFFh
.text$mn:00004ED5                 push    offset __ehhandler$??1?$_Iterator012@Urandom_access_iterator_tag@std@@PB_WHPBQB_WABQB_WU_Iterator_base12@2@@std@@QAE@XZ
.text$mn:00004EDA                 mov     eax, large fs:0
.text$mn:00004EE0                 push    eax
.text$mn:00004EE1                 push    ecx
.text$mn:00004EE2                 mov     eax, dword ptr ds:___security_cookie
.text$mn:00004EE7                 xor     eax, ebp
.text$mn:00004EE9                 push    eax
.text$mn:00004EEA                 lea     eax, [ebp+var_C]
.text$mn:00004EED                 mov     large fs:0, eax
.text$mn:00004EF3                 mov     [ebp+var_10], ecx
.text$mn:00004EF6                 mov     [ebp+var_4], 0
.text$mn:00004EFD                 mov     [ebp+var_4], 0FFFFFFFFh
.text$mn:00004F04                 mov     ecx, [ebp+var_10] ; this
.text$mn:00004F07                 call    ??1_Iterator_base12@std@@QAE@XZ ; std::_Iterator_base12::~_Iterator_base12(void)
.text$mn:00004F0C                 mov     ecx, [ebp+var_C]
.text$mn:00004F0F                 mov     large fs:0, ecx
.text$mn:00004F16                 pop     ecx
.text$mn:00004F17                 mov     esp, ebp
.text$mn:00004F19                 pop     ebp
.text$mn:00004F1A                 retn
.text$mn:00004F1A ??1?$_Iterator012@Urandom_access_iterator_tag@std@@PB_WHPBQB_WABQB_WU_Iterator_base12@2@@std@@QAE@XZ endp
.text$mn:00004F1A
.text$mn:00004F1A ; ---------------------------------------------------------------------------
.text$mn:00004F1B                 align 4
.text$mn:00004F1B _text$mn        ends
.text$mn:00004F1B
.text$x:00004F1C ; ===========================================================================
.text$x:00004F1C
.text$x:00004F1C ; Segment type: Pure code
.text$x:00004F1C ; Segment permissions: Read/Execute
.text$x:00004F1C _text$x         segment para public 'CODE' use32
.text$x:00004F1C                 assume cs:_text$x
.text$x:00004F1C                 ;org 4F1Ch
.text$x:00004F1C ; COMDAT (pick associative to section at 4ED0)
.text$x:00004F1C                 assume es:nothing, ss:nothing, ds:_data, fs:nothing, gs:nothing
.text$x:00004F1C
.text$x:00004F1C ; =============== S U B R O U T I N E =======================================
.text$x:00004F1C
.text$x:00004F1C
.text$x:00004F1C __unwindfunclet$??1?$_Iterator012@Urandom_access_iterator_tag@std@@PB_WHPBQB_WABQB_WU_Iterator_base12@2@@std@@QAE@XZ$0 proc near
.text$x:00004F1C                                         ; DATA XREF: .xdata$x:00009F1Co
.text$x:00004F1C                 mov     ecx, [ebp-10h]  ; this
.text$x:00004F1F                 jmp     ??1_Iterator_base12@std@@QAE@XZ ; std::_Iterator_base12::~_Iterator_base12(void)
.text$x:00004F1F __unwindfunclet$??1?$_Iterator012@Urandom_access_iterator_tag@std@@PB_WHPBQB_WABQB_WU_Iterator_base12@2@@std@@QAE@XZ$0 endp
.text$x:00004F1F
.text$x:00004F24
.text$x:00004F24 ; =============== S U B R O U T I N E =======================================
.text$x:00004F24
.text$x:00004F24
.text$x:00004F24 __ehhandler$??1?$_Iterator012@Urandom_access_iterator_tag@std@@PB_WHPBQB_WABQB_WU_Iterator_base12@2@@std@@QAE@XZ proc near
.text$x:00004F24                                         ; DATA XREF: std::_Iterator012<std::random_access_iterator_tag,wchar_t const *,int,wchar_t const * const *,wchar_t const * const &,std::_Iterator_base12>::~_Iterator012<std::random_access_iterator_tag,wchar_t const *,int,wchar_t const * const *,wchar_t const * const &,std::_Iterator_base12>(void)+5o
.text$x:00004F24
.text$x:00004F24 arg_4           = dword ptr  8
.text$x:00004F24
.text$x:00004F24                 mov     edx, [esp+arg_4]
.text$x:00004F28                 lea     eax, [edx+0Ch]
.text$x:00004F2B                 mov     ecx, [edx-8]
.text$x:00004F2E                 xor     ecx, eax
.text$x:00004F30                 call    @__security_check_cookie@4 ; __security_check_cookie(x)
.text$x:00004F35                 mov     eax, offset __ehfuncinfo$??1?$_Iterator012@Urandom_access_iterator_tag@std@@PB_WHPBQB_WABQB_WU_Iterator_base12@2@@std@@QAE@XZ
.text$x:00004F3A                 jmp     ___CxxFrameHandler3
.text$x:00004F3A __ehhandler$??1?$_Iterator012@Urandom_access_iterator_tag@std@@PB_WHPBQB_WABQB_WU_Iterator_base12@2@@std@@QAE@XZ endp
.text$x:00004F3A
.text$x:00004F3A ; ---------------------------------------------------------------------------
.text$x:00004F3F                 align 10h
.text$x:00004F3F _text$x         ends
.text$x:00004F3F
.text$mn:00004F40 ; ===========================================================================
.text$mn:00004F40
.text$mn:00004F40 ; Segment type: Pure code
.text$mn:00004F40 ; Segment permissions: Read/Execute
.text$mn:00004F40 _text$mn        segment para public 'CODE' use32
.text$mn:00004F40                 assume cs:_text$mn
.text$mn:00004F40                 ;org 4F40h
.text$mn:00004F40 ; COMDAT (pick any)
.text$mn:00004F40                 assume es:nothing, ss:nothing, ds:_data, fs:nothing, gs:nothing
.text$mn:00004F40
.text$mn:00004F40 ; =============== S U B R O U T I N E =======================================
.text$mn:00004F40
.text$mn:00004F40 ; Attributes: bp-based frame
.text$mn:00004F40
.text$mn:00004F40 ; public: __thiscall std::_Iterator012<struct std::random_access_iterator_tag, struct FunctionValues, int, struct FunctionValues const *, struct FunctionValues const &, struct std::_Iterator_base12>::~_Iterator012<struct std::random_access_iterator_tag, struct FunctionValues, int, struct FunctionValues const *, struct FunctionValues const &, struct std::_Iterator_base12>(void)
.text$mn:00004F40                 public ??1?$_Iterator012@Urandom_access_iterator_tag@std@@UFunctionValues@@HPBU3@ABU3@U_Iterator_base12@2@@std@@QAE@XZ
.text$mn:00004F40 ??1?$_Iterator012@Urandom_access_iterator_tag@std@@UFunctionValues@@HPBU3@ABU3@U_Iterator_base12@2@@std@@QAE@XZ proc near
.text$mn:00004F40                                         ; CODE XREF: __unwindfunclet$??0?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@UFunctionValues@@@std@@@std@@@std@@QAE@ABV01@@Z$0+3j
.text$mn:00004F40                                         ; __unwindfunclet$??0?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@UFunctionValues@@@std@@@std@@@std@@QAE@PAUFunctionValues@@PBU_Container_base12@1@@Z$0+3j ...
.text$mn:00004F40
.text$mn:00004F40 var_10          = dword ptr -10h
.text$mn:00004F40 var_C           = dword ptr -0Ch
.text$mn:00004F40 var_4           = dword ptr -4
.text$mn:00004F40
.text$mn:00004F40                 push    ebp
.text$mn:00004F41                 mov     ebp, esp
.text$mn:00004F43                 push    0FFFFFFFFh
.text$mn:00004F45                 push    offset __ehhandler$??1?$_Iterator012@Urandom_access_iterator_tag@std@@UFunctionValues@@HPBU3@ABU3@U_Iterator_base12@2@@std@@QAE@XZ
.text$mn:00004F4A                 mov     eax, large fs:0
.text$mn:00004F50                 push    eax
.text$mn:00004F51                 push    ecx
.text$mn:00004F52                 mov     eax, dword ptr ds:___security_cookie
.text$mn:00004F57                 xor     eax, ebp
.text$mn:00004F59                 push    eax
.text$mn:00004F5A                 lea     eax, [ebp+var_C]
.text$mn:00004F5D                 mov     large fs:0, eax
.text$mn:00004F63                 mov     [ebp+var_10], ecx
.text$mn:00004F66                 mov     [ebp+var_4], 0
.text$mn:00004F6D                 mov     [ebp+var_4], 0FFFFFFFFh
.text$mn:00004F74                 mov     ecx, [ebp+var_10] ; this
.text$mn:00004F77                 call    ??1_Iterator_base12@std@@QAE@XZ ; std::_Iterator_base12::~_Iterator_base12(void)
.text$mn:00004F7C                 mov     ecx, [ebp+var_C]
.text$mn:00004F7F                 mov     large fs:0, ecx
.text$mn:00004F86                 pop     ecx
.text$mn:00004F87                 mov     esp, ebp
.text$mn:00004F89                 pop     ebp
.text$mn:00004F8A                 retn
.text$mn:00004F8A ??1?$_Iterator012@Urandom_access_iterator_tag@std@@UFunctionValues@@HPBU3@ABU3@U_Iterator_base12@2@@std@@QAE@XZ endp
.text$mn:00004F8A
.text$mn:00004F8A ; ---------------------------------------------------------------------------
.text$mn:00004F8B                 align 4
.text$mn:00004F8B _text$mn        ends
.text$mn:00004F8B
.text$x:00004F8C ; ===========================================================================
.text$x:00004F8C
.text$x:00004F8C ; Segment type: Pure code
.text$x:00004F8C ; Segment permissions: Read/Execute
.text$x:00004F8C _text$x         segment para public 'CODE' use32
.text$x:00004F8C                 assume cs:_text$x
.text$x:00004F8C                 ;org 4F8Ch
.text$x:00004F8C ; COMDAT (pick associative to section at 4F40)
.text$x:00004F8C                 assume es:nothing, ss:nothing, ds:_data, fs:nothing, gs:nothing
.text$x:00004F8C
.text$x:00004F8C ; =============== S U B R O U T I N E =======================================
.text$x:00004F8C
.text$x:00004F8C
.text$x:00004F8C __unwindfunclet$??1?$_Iterator012@Urandom_access_iterator_tag@std@@UFunctionValues@@HPBU3@ABU3@U_Iterator_base12@2@@std@@QAE@XZ$0 proc near
.text$x:00004F8C                                         ; DATA XREF: .xdata$x:00009D5Co
.text$x:00004F8C                 mov     ecx, [ebp-10h]  ; this
.text$x:00004F8F                 jmp     ??1_Iterator_base12@std@@QAE@XZ ; std::_Iterator_base12::~_Iterator_base12(void)
.text$x:00004F8F __unwindfunclet$??1?$_Iterator012@Urandom_access_iterator_tag@std@@UFunctionValues@@HPBU3@ABU3@U_Iterator_base12@2@@std@@QAE@XZ$0 endp
.text$x:00004F8F
.text$x:00004F94
.text$x:00004F94 ; =============== S U B R O U T I N E =======================================
.text$x:00004F94
.text$x:00004F94
.text$x:00004F94 __ehhandler$??1?$_Iterator012@Urandom_access_iterator_tag@std@@UFunctionValues@@HPBU3@ABU3@U_Iterator_base12@2@@std@@QAE@XZ proc near
.text$x:00004F94                                         ; DATA XREF: std::_Iterator012<std::random_access_iterator_tag,FunctionValues,int,FunctionValues const *,FunctionValues const &,std::_Iterator_base12>::~_Iterator012<std::random_access_iterator_tag,FunctionValues,int,FunctionValues const *,FunctionValues const &,std::_Iterator_base12>(void)+5o
.text$x:00004F94
.text$x:00004F94 arg_4           = dword ptr  8
.text$x:00004F94
.text$x:00004F94                 mov     edx, [esp+arg_4]
.text$x:00004F98                 lea     eax, [edx+0Ch]
.text$x:00004F9B                 mov     ecx, [edx-8]
.text$x:00004F9E                 xor     ecx, eax
.text$x:00004FA0                 call    @__security_check_cookie@4 ; __security_check_cookie(x)
.text$x:00004FA5                 mov     eax, offset __ehfuncinfo$??1?$_Iterator012@Urandom_access_iterator_tag@std@@UFunctionValues@@HPBU3@ABU3@U_Iterator_base12@2@@std@@QAE@XZ
.text$x:00004FAA                 jmp     ___CxxFrameHandler3
.text$x:00004FAA __ehhandler$??1?$_Iterator012@Urandom_access_iterator_tag@std@@UFunctionValues@@HPBU3@ABU3@U_Iterator_base12@2@@std@@QAE@XZ endp
.text$x:00004FAA
.text$x:00004FAA ; ---------------------------------------------------------------------------
.text$x:00004FAF                 align 10h
.text$x:00004FAF _text$x         ends
.text$x:00004FAF
.text$mn:00004FB0 ; ===========================================================================
.text$mn:00004FB0
.text$mn:00004FB0 ; Segment type: Pure code
.text$mn:00004FB0 ; Segment permissions: Read/Execute
.text$mn:00004FB0 _text$mn        segment para public 'CODE' use32
.text$mn:00004FB0                 assume cs:_text$mn
.text$mn:00004FB0                 ;org 4FB0h
.text$mn:00004FB0 ; COMDAT (pick any)
.text$mn:00004FB0                 assume es:nothing, ss:nothing, ds:_data, fs:nothing, gs:nothing
.text$mn:00004FB0
.text$mn:00004FB0 ; =============== S U B R O U T I N E =======================================
.text$mn:00004FB0
.text$mn:00004FB0 ; Attributes: bp-based frame
.text$mn:00004FB0
.text$mn:00004FB0 ; public: __thiscall std::_String_alloc<0, struct std::_String_base_types<char, class std::allocator<char>>>::~_String_alloc<0, struct std::_String_base_types<char, class std::allocator<char>>>(void)
.text$mn:00004FB0                 public ??1?$_String_alloc@$0A@U?$_String_base_types@DV?$allocator@D@std@@@std@@@std@@QAE@XZ
.text$mn:00004FB0 ??1?$_String_alloc@$0A@U?$_String_base_types@DV?$allocator@D@std@@@std@@@std@@QAE@XZ proc near
.text$mn:00004FB0                                         ; CODE XREF: __unwindfunclet$??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@PBD@Z$0+3j
.text$mn:00004FB0                                         ; std::basic_string<char,std::char_traits<char>,std::allocator<char>>::~basic_string<char,std::char_traits<char>,std::allocator<char>>(void)+43p ...
.text$mn:00004FB0
.text$mn:00004FB0 var_10          = dword ptr -10h
.text$mn:00004FB0 var_C           = dword ptr -0Ch
.text$mn:00004FB0 var_4           = dword ptr -4
.text$mn:00004FB0
.text$mn:00004FB0                 push    ebp
.text$mn:00004FB1                 mov     ebp, esp
.text$mn:00004FB3                 push    0FFFFFFFFh
.text$mn:00004FB5                 push    offset __ehhandler$??1?$_String_alloc@$0A@U?$_String_base_types@DV?$allocator@D@std@@@std@@@std@@QAE@XZ
.text$mn:00004FBA                 mov     eax, large fs:0
.text$mn:00004FC0                 push    eax
.text$mn:00004FC1                 push    ecx
.text$mn:00004FC2                 mov     eax, dword ptr ds:___security_cookie
.text$mn:00004FC7                 xor     eax, ebp
.text$mn:00004FC9                 push    eax
.text$mn:00004FCA                 lea     eax, [ebp+var_C]
.text$mn:00004FCD                 mov     large fs:0, eax
.text$mn:00004FD3                 mov     [ebp+var_10], ecx
.text$mn:00004FD6                 mov     [ebp+var_4], 0
.text$mn:00004FDD                 mov     ecx, [ebp+var_10]
.text$mn:00004FE0                 call    ?_Free_proxy@?$_String_alloc@$0A@U?$_String_base_types@DV?$allocator@D@std@@@std@@@std@@QAEXXZ ; std::_String_alloc<0,std::_String_base_types<char,std::allocator<char>>>::_Free_proxy(void)
.text$mn:00004FE5                 mov     [ebp+var_4], 0FFFFFFFFh
.text$mn:00004FEC                 mov     ecx, [ebp+var_10]
.text$mn:00004FEF                 call    ??1?$_String_val@U?$_Simple_types@D@std@@@std@@QAE@XZ ; std::_String_val<std::_Simple_types<char>>::~_String_val<std::_Simple_types<char>>(void)
.text$mn:00004FF4                 mov     ecx, [ebp+var_C]
.text$mn:00004FF7                 mov     large fs:0, ecx
.text$mn:00004FFE                 pop     ecx
.text$mn:00004FFF                 mov     esp, ebp
.text$mn:00005001                 pop     ebp
.text$mn:00005002                 retn
.text$mn:00005002 ??1?$_String_alloc@$0A@U?$_String_base_types@DV?$allocator@D@std@@@std@@@std@@QAE@XZ endp
.text$mn:00005002
.text$mn:00005002 ; ---------------------------------------------------------------------------
.text$mn:00005003                 align 4
.text$mn:00005003 _text$mn        ends
.text$mn:00005003
.text$x:00005004 ; ===========================================================================
.text$x:00005004
.text$x:00005004 ; Segment type: Pure code
.text$x:00005004 ; Segment permissions: Read/Execute
.text$x:00005004 _text$x         segment para public 'CODE' use32
.text$x:00005004                 assume cs:_text$x
.text$x:00005004                 ;org 5004h
.text$x:00005004 ; COMDAT (pick associative to section at 4FB0)
.text$x:00005004                 assume es:nothing, ss:nothing, ds:_data, fs:nothing, gs:nothing
.text$x:00005004
.text$x:00005004 ; =============== S U B R O U T I N E =======================================
.text$x:00005004
.text$x:00005004
.text$x:00005004 __unwindfunclet$??1?$_String_alloc@$0A@U?$_String_base_types@DV?$allocator@D@std@@@std@@@std@@QAE@XZ$0 proc near
.text$x:00005004                                         ; DATA XREF: .xdata$x:0000938Co
.text$x:00005004                 mov     ecx, [ebp-10h]
.text$x:00005007                 jmp     ??1?$_String_val@U?$_Simple_types@D@std@@@std@@QAE@XZ ; std::_String_val<std::_Simple_types<char>>::~_String_val<std::_Simple_types<char>>(void)
.text$x:00005007 __unwindfunclet$??1?$_String_alloc@$0A@U?$_String_base_types@DV?$allocator@D@std@@@std@@@std@@QAE@XZ$0 endp
.text$x:00005007
.text$x:0000500C
.text$x:0000500C ; =============== S U B R O U T I N E =======================================
.text$x:0000500C
.text$x:0000500C
.text$x:0000500C __ehhandler$??1?$_String_alloc@$0A@U?$_String_base_types@DV?$allocator@D@std@@@std@@@std@@QAE@XZ proc near
.text$x:0000500C                                         ; DATA XREF: std::_String_alloc<0,std::_String_base_types<char,std::allocator<char>>>::~_String_alloc<0,std::_String_base_types<char,std::allocator<char>>>(void)+5o
.text$x:0000500C
.text$x:0000500C arg_4           = dword ptr  8
.text$x:0000500C
.text$x:0000500C                 mov     edx, [esp+arg_4]
.text$x:00005010                 lea     eax, [edx+0Ch]
.text$x:00005013                 mov     ecx, [edx-8]
.text$x:00005016                 xor     ecx, eax
.text$x:00005018                 call    @__security_check_cookie@4 ; __security_check_cookie(x)
.text$x:0000501D                 mov     eax, offset __ehfuncinfo$??1?$_String_alloc@$0A@U?$_String_base_types@DV?$allocator@D@std@@@std@@@std@@QAE@XZ
.text$x:00005022                 jmp     ___CxxFrameHandler3
.text$x:00005022 __ehhandler$??1?$_String_alloc@$0A@U?$_String_base_types@DV?$allocator@D@std@@@std@@@std@@QAE@XZ endp
.text$x:00005022
.text$x:00005022 ; ---------------------------------------------------------------------------
.text$x:00005027                 align 4
.text$x:00005027 _text$x         ends
.text$x:00005027
.text$mn:00005028 ; ===========================================================================
.text$mn:00005028
.text$mn:00005028 ; Segment type: Pure code
.text$mn:00005028 ; Segment permissions: Read/Execute
.text$mn:00005028 _text$mn        segment para public 'CODE' use32
.text$mn:00005028                 assume cs:_text$mn
.text$mn:00005028                 ;org 5028h
.text$mn:00005028 ; COMDAT (pick any)
.text$mn:00005028                 assume es:nothing, ss:nothing, ds:_data, fs:nothing, gs:nothing
.text$mn:00005028
.text$mn:00005028 ; =============== S U B R O U T I N E =======================================
.text$mn:00005028
.text$mn:00005028 ; Attributes: bp-based frame
.text$mn:00005028
.text$mn:00005028 ; public: __thiscall std::_String_val<struct std::_Simple_types<char>>::~_String_val<struct std::_Simple_types<char>>(void)
.text$mn:00005028                 public ??1?$_String_val@U?$_Simple_types@D@std@@@std@@QAE@XZ
.text$mn:00005028 ??1?$_String_val@U?$_Simple_types@D@std@@@std@@QAE@XZ proc near
.text$mn:00005028                                         ; CODE XREF: __unwindfunclet$??0?$_String_alloc@$0A@U?$_String_base_types@DV?$allocator@D@std@@@std@@@std@@QAE@ABV?$allocator@D@1@@Z$0+3j
.text$mn:00005028                                         ; std::_String_alloc<0,std::_String_base_types<char,std::allocator<char>>>::~_String_alloc<0,std::_String_base_types<char,std::allocator<char>>>(void)+3Fp ...
.text$mn:00005028
.text$mn:00005028 var_10          = dword ptr -10h
.text$mn:00005028 var_C           = dword ptr -0Ch
.text$mn:00005028 var_4           = dword ptr -4
.text$mn:00005028
.text$mn:00005028                 push    ebp
.text$mn:00005029                 mov     ebp, esp
.text$mn:0000502B                 push    0FFFFFFFFh
.text$mn:0000502D                 push    offset __ehhandler$??1?$_String_val@U?$_Simple_types@D@std@@@std@@QAE@XZ
.text$mn:00005032                 mov     eax, large fs:0
.text$mn:00005038                 push    eax
.text$mn:00005039                 push    ecx
.text$mn:0000503A                 mov     eax, dword ptr ds:___security_cookie
.text$mn:0000503F                 xor     eax, ebp
.text$mn:00005041                 push    eax
.text$mn:00005042                 lea     eax, [ebp+var_C]
.text$mn:00005045                 mov     large fs:0, eax
.text$mn:0000504B                 mov     [ebp+var_10], ecx
.text$mn:0000504E                 mov     [ebp+var_4], 0
.text$mn:00005055                 mov     [ebp+var_4], 0FFFFFFFFh
.text$mn:0000505C                 mov     ecx, [ebp+var_10] ; this
.text$mn:0000505F                 call    ??1_Container_base12@std@@QAE@XZ ; std::_Container_base12::~_Container_base12(void)
.text$mn:00005064                 mov     ecx, [ebp+var_C]
.text$mn:00005067                 mov     large fs:0, ecx
.text$mn:0000506E                 pop     ecx
.text$mn:0000506F                 mov     esp, ebp
.text$mn:00005071                 pop     ebp
.text$mn:00005072                 retn
.text$mn:00005072 ??1?$_String_val@U?$_Simple_types@D@std@@@std@@QAE@XZ endp
.text$mn:00005072
.text$mn:00005072 ; ---------------------------------------------------------------------------
.text$mn:00005073                 align 4
.text$mn:00005073 _text$mn        ends
.text$mn:00005073
.text$x:00005074 ; ===========================================================================
.text$x:00005074
.text$x:00005074 ; Segment type: Pure code
.text$x:00005074 ; Segment permissions: Read/Execute
.text$x:00005074 _text$x         segment para public 'CODE' use32
.text$x:00005074                 assume cs:_text$x
.text$x:00005074                 ;org 5074h
.text$x:00005074 ; COMDAT (pick associative to section at 5028)
.text$x:00005074                 assume es:nothing, ss:nothing, ds:_data, fs:nothing, gs:nothing
.text$x:00005074
.text$x:00005074 ; =============== S U B R O U T I N E =======================================
.text$x:00005074
.text$x:00005074
.text$x:00005074 __unwindfunclet$??1?$_String_val@U?$_Simple_types@D@std@@@std@@QAE@XZ$0 proc near
.text$x:00005074                                         ; DATA XREF: .xdata$x:00009334o
.text$x:00005074                 mov     ecx, [ebp-10h]  ; this
.text$x:00005077                 jmp     ??1_Container_base12@std@@QAE@XZ ; std::_Container_base12::~_Container_base12(void)
.text$x:00005077 __unwindfunclet$??1?$_String_val@U?$_Simple_types@D@std@@@std@@QAE@XZ$0 endp
.text$x:00005077
.text$x:0000507C
.text$x:0000507C ; =============== S U B R O U T I N E =======================================
.text$x:0000507C
.text$x:0000507C
.text$x:0000507C __ehhandler$??1?$_String_val@U?$_Simple_types@D@std@@@std@@QAE@XZ proc near
.text$x:0000507C                                         ; DATA XREF: std::_String_val<std::_Simple_types<char>>::~_String_val<std::_Simple_types<char>>(void)+5o
.text$x:0000507C
.text$x:0000507C arg_4           = dword ptr  8
.text$x:0000507C
.text$x:0000507C                 mov     edx, [esp+arg_4]
.text$x:00005080                 lea     eax, [edx+0Ch]
.text$x:00005083                 mov     ecx, [edx-8]
.text$x:00005086                 xor     ecx, eax
.text$x:00005088                 call    @__security_check_cookie@4 ; __security_check_cookie(x)
.text$x:0000508D                 mov     eax, offset __ehfuncinfo$??1?$_String_val@U?$_Simple_types@D@std@@@std@@QAE@XZ
.text$x:00005092                 jmp     ___CxxFrameHandler3
.text$x:00005092 __ehhandler$??1?$_String_val@U?$_Simple_types@D@std@@@std@@QAE@XZ endp
.text$x:00005092
.text$x:00005092 ; ---------------------------------------------------------------------------
.text$x:00005097                 align 4
.text$x:00005097 _text$x         ends
.text$x:00005097
.text$mn:00005098 ; ===========================================================================
.text$mn:00005098
.text$mn:00005098 ; Segment type: Pure code
.text$mn:00005098 ; Segment permissions: Read/Execute
.text$mn:00005098 _text$mn        segment para public 'CODE' use32
.text$mn:00005098                 assume cs:_text$mn
.text$mn:00005098                 ;org 5098h
.text$mn:00005098 ; COMDAT (pick any)
.text$mn:00005098                 assume es:nothing, ss:nothing, ds:_data, fs:nothing, gs:nothing
.text$mn:00005098
.text$mn:00005098 ; =============== S U B R O U T I N E =======================================
.text$mn:00005098
.text$mn:00005098 ; Attributes: bp-based frame
.text$mn:00005098
.text$mn:00005098 ; public: __thiscall std::_Vector_alloc<0, struct std::_Vec_base_types<wchar_t const *, class std::allocator<wchar_t const *>>>::~_Vector_alloc<0, struct std::_Vec_base_types<wchar_t const *, class std::allocator<wchar_t const *>>>(void)
.text$mn:00005098                 public ??1?$_Vector_alloc@$0A@U?$_Vec_base_types@PB_WV?$allocator@PB_W@std@@@std@@@std@@QAE@XZ
.text$mn:00005098 ??1?$_Vector_alloc@$0A@U?$_Vec_base_types@PB_WV?$allocator@PB_W@std@@@std@@@std@@QAE@XZ proc near
.text$mn:00005098                                         ; CODE XREF: __unwindfunclet$??0?$vector@PB_WV?$allocator@PB_W@std@@@std@@QAE@$$QAV01@@Z$0+3j
.text$mn:00005098                                         ; __unwindfunclet$??0?$vector@PB_WV?$allocator@PB_W@std@@@std@@QAE@ABV01@@Z$2+3j ...
.text$mn:00005098
.text$mn:00005098 var_10          = dword ptr -10h
.text$mn:00005098 var_C           = dword ptr -0Ch
.text$mn:00005098 var_4           = dword ptr -4
.text$mn:00005098
.text$mn:00005098                 push    ebp
.text$mn:00005099                 mov     ebp, esp
.text$mn:0000509B                 push    0FFFFFFFFh
.text$mn:0000509D                 push    offset __ehhandler$??1?$_Vector_alloc@$0A@U?$_Vec_base_types@PB_WV?$allocator@PB_W@std@@@std@@@std@@QAE@XZ
.text$mn:000050A2                 mov     eax, large fs:0
.text$mn:000050A8                 push    eax
.text$mn:000050A9                 push    ecx
.text$mn:000050AA                 mov     eax, dword ptr ds:___security_cookie
.text$mn:000050AF                 xor     eax, ebp
.text$mn:000050B1                 push    eax
.text$mn:000050B2                 lea     eax, [ebp+var_C]
.text$mn:000050B5                 mov     large fs:0, eax
.text$mn:000050BB                 mov     [ebp+var_10], ecx
.text$mn:000050BE                 mov     [ebp+var_4], 0
.text$mn:000050C5                 mov     ecx, [ebp+var_10]
.text$mn:000050C8                 call    ?_Free_proxy@?$_Vector_alloc@$0A@U?$_Vec_base_types@PB_WV?$allocator@PB_W@std@@@std@@@std@@QAEXXZ ; std::_Vector_alloc<0,std::_Vec_base_types<wchar_t const *,std::allocator<wchar_t const *>>>::_Free_proxy(void)
.text$mn:000050CD                 mov     [ebp+var_4], 0FFFFFFFFh
.text$mn:000050D4                 mov     ecx, [ebp+var_10]
.text$mn:000050D7                 call    ??1?$_Vector_val@U?$_Simple_types@PB_W@std@@@std@@QAE@XZ ; std::_Vector_val<std::_Simple_types<wchar_t const *>>::~_Vector_val<std::_Simple_types<wchar_t const *>>(void)
.text$mn:000050DC                 mov     ecx, [ebp+var_C]
.text$mn:000050DF                 mov     large fs:0, ecx
.text$mn:000050E6                 pop     ecx
.text$mn:000050E7                 mov     esp, ebp
.text$mn:000050E9                 pop     ebp
.text$mn:000050EA                 retn
.text$mn:000050EA ??1?$_Vector_alloc@$0A@U?$_Vec_base_types@PB_WV?$allocator@PB_W@std@@@std@@@std@@QAE@XZ endp
.text$mn:000050EA
.text$mn:000050EA ; ---------------------------------------------------------------------------
.text$mn:000050EB                 align 4
.text$mn:000050EB _text$mn        ends
.text$mn:000050EB
.text$x:000050EC ; ===========================================================================
.text$x:000050EC
.text$x:000050EC ; Segment type: Pure code
.text$x:000050EC ; Segment permissions: Read/Execute
.text$x:000050EC _text$x         segment para public 'CODE' use32
.text$x:000050EC                 assume cs:_text$x
.text$x:000050EC                 ;org 50ECh
.text$x:000050EC ; COMDAT (pick associative to section at 5098)
.text$x:000050EC                 assume es:nothing, ss:nothing, ds:_data, fs:nothing, gs:nothing
.text$x:000050EC
.text$x:000050EC ; =============== S U B R O U T I N E =======================================
.text$x:000050EC
.text$x:000050EC
.text$x:000050EC __unwindfunclet$??1?$_Vector_alloc@$0A@U?$_Vec_base_types@PB_WV?$allocator@PB_W@std@@@std@@@std@@QAE@XZ$0 proc near
.text$x:000050EC                                         ; DATA XREF: .xdata$x:000096ACo
.text$x:000050EC                 mov     ecx, [ebp-10h]
.text$x:000050EF                 jmp     ??1?$_Vector_val@U?$_Simple_types@PB_W@std@@@std@@QAE@XZ ; std::_Vector_val<std::_Simple_types<wchar_t const *>>::~_Vector_val<std::_Simple_types<wchar_t const *>>(void)
.text$x:000050EF __unwindfunclet$??1?$_Vector_alloc@$0A@U?$_Vec_base_types@PB_WV?$allocator@PB_W@std@@@std@@@std@@QAE@XZ$0 endp
.text$x:000050EF
.text$x:000050F4
.text$x:000050F4 ; =============== S U B R O U T I N E =======================================
.text$x:000050F4
.text$x:000050F4
.text$x:000050F4 __ehhandler$??1?$_Vector_alloc@$0A@U?$_Vec_base_types@PB_WV?$allocator@PB_W@std@@@std@@@std@@QAE@XZ proc near
.text$x:000050F4                                         ; DATA XREF: std::_Vector_alloc<0,std::_Vec_base_types<wchar_t const *,std::allocator<wchar_t const *>>>::~_Vector_alloc<0,std::_Vec_base_types<wchar_t const *,std::allocator<wchar_t const *>>>(void)+5o
.text$x:000050F4
.text$x:000050F4 arg_4           = dword ptr  8
.text$x:000050F4
.text$x:000050F4                 mov     edx, [esp+arg_4]
.text$x:000050F8                 lea     eax, [edx+0Ch]
.text$x:000050FB                 mov     ecx, [edx-8]
.text$x:000050FE                 xor     ecx, eax
.text$x:00005100                 call    @__security_check_cookie@4 ; __security_check_cookie(x)
.text$x:00005105                 mov     eax, offset __ehfuncinfo$??1?$_Vector_alloc@$0A@U?$_Vec_base_types@PB_WV?$allocator@PB_W@std@@@std@@@std@@QAE@XZ
.text$x:0000510A                 jmp     ___CxxFrameHandler3
.text$x:0000510A __ehhandler$??1?$_Vector_alloc@$0A@U?$_Vec_base_types@PB_WV?$allocator@PB_W@std@@@std@@@std@@QAE@XZ endp
.text$x:0000510A
.text$x:0000510A ; ---------------------------------------------------------------------------
.text$x:0000510F                 align 10h
.text$x:0000510F _text$x         ends
.text$x:0000510F
.text$mn:00005110 ; ===========================================================================
.text$mn:00005110
.text$mn:00005110 ; Segment type: Pure code
.text$mn:00005110 ; Segment permissions: Read/Execute
.text$mn:00005110 _text$mn        segment para public 'CODE' use32
.text$mn:00005110                 assume cs:_text$mn
.text$mn:00005110                 ;org 5110h
.text$mn:00005110 ; COMDAT (pick any)
.text$mn:00005110                 assume es:nothing, ss:nothing, ds:_data, fs:nothing, gs:nothing
.text$mn:00005110
.text$mn:00005110 ; =============== S U B R O U T I N E =======================================
.text$mn:00005110
.text$mn:00005110 ; Attributes: bp-based frame
.text$mn:00005110
.text$mn:00005110 ; public: __thiscall std::_Vector_alloc<0, struct std::_Vec_base_types<struct FunctionValues, class std::allocator<struct FunctionValues>>>::~_Vector_alloc<0, struct std::_Vec_base_types<struct FunctionValues, class std::allocator<struct FunctionValues>>>(void)
.text$mn:00005110                 public ??1?$_Vector_alloc@$0A@U?$_Vec_base_types@UFunctionValues@@V?$allocator@UFunctionValues@@@std@@@std@@@std@@QAE@XZ
.text$mn:00005110 ??1?$_Vector_alloc@$0A@U?$_Vec_base_types@UFunctionValues@@V?$allocator@UFunctionValues@@@std@@@std@@@std@@QAE@XZ proc near
.text$mn:00005110                                         ; CODE XREF: __unwindfunclet$??0?$vector@UFunctionValues@@V?$allocator@UFunctionValues@@@std@@@std@@QAE@XZ$0+3j
.text$mn:00005110                                         ; std::vector<FunctionValues,std::allocator<FunctionValues>>::~vector<FunctionValues,std::allocator<FunctionValues>>(void)+3Fp ...
.text$mn:00005110
.text$mn:00005110 var_10          = dword ptr -10h
.text$mn:00005110 var_C           = dword ptr -0Ch
.text$mn:00005110 var_4           = dword ptr -4
.text$mn:00005110
.text$mn:00005110                 push    ebp
.text$mn:00005111                 mov     ebp, esp
.text$mn:00005113                 push    0FFFFFFFFh
.text$mn:00005115                 push    offset __ehhandler$??1?$_Vector_alloc@$0A@U?$_Vec_base_types@UFunctionValues@@V?$allocator@UFunctionValues@@@std@@@std@@@std@@QAE@XZ
.text$mn:0000511A                 mov     eax, large fs:0
.text$mn:00005120                 push    eax
.text$mn:00005121                 push    ecx
.text$mn:00005122                 mov     eax, dword ptr ds:___security_cookie
.text$mn:00005127                 xor     eax, ebp
.text$mn:00005129                 push    eax
.text$mn:0000512A                 lea     eax, [ebp+var_C]
.text$mn:0000512D                 mov     large fs:0, eax
.text$mn:00005133                 mov     [ebp+var_10], ecx
.text$mn:00005136                 mov     [ebp+var_4], 0
.text$mn:0000513D                 mov     ecx, [ebp+var_10]
.text$mn:00005140                 call    ?_Free_proxy@?$_Vector_alloc@$0A@U?$_Vec_base_types@UFunctionValues@@V?$allocator@UFunctionValues@@@std@@@std@@@std@@QAEXXZ ; std::_Vector_alloc<0,std::_Vec_base_types<FunctionValues,std::allocator<FunctionValues>>>::_Free_proxy(void)
.text$mn:00005145                 mov     [ebp+var_4], 0FFFFFFFFh
.text$mn:0000514C                 mov     ecx, [ebp+var_10]
.text$mn:0000514F                 call    ??1?$_Vector_val@U?$_Simple_types@UFunctionValues@@@std@@@std@@QAE@XZ ; std::_Vector_val<std::_Simple_types<FunctionValues>>::~_Vector_val<std::_Simple_types<FunctionValues>>(void)
.text$mn:00005154                 mov     ecx, [ebp+var_C]
.text$mn:00005157                 mov     large fs:0, ecx
.text$mn:0000515E                 pop     ecx
.text$mn:0000515F                 mov     esp, ebp
.text$mn:00005161                 pop     ebp
.text$mn:00005162                 retn
.text$mn:00005162 ??1?$_Vector_alloc@$0A@U?$_Vec_base_types@UFunctionValues@@V?$allocator@UFunctionValues@@@std@@@std@@@std@@QAE@XZ endp
.text$mn:00005162
.text$mn:00005162 ; ---------------------------------------------------------------------------
.text$mn:00005163                 align 4
.text$mn:00005163 _text$mn        ends
.text$mn:00005163
.text$x:00005164 ; ===========================================================================
.text$x:00005164
.text$x:00005164 ; Segment type: Pure code
.text$x:00005164 ; Segment permissions: Read/Execute
.text$x:00005164 _text$x         segment para public 'CODE' use32
.text$x:00005164                 assume cs:_text$x
.text$x:00005164                 ;org 5164h
.text$x:00005164 ; COMDAT (pick associative to section at 5110)
.text$x:00005164                 assume es:nothing, ss:nothing, ds:_data, fs:nothing, gs:nothing
.text$x:00005164
.text$x:00005164 ; =============== S U B R O U T I N E =======================================
.text$x:00005164
.text$x:00005164
.text$x:00005164 __unwindfunclet$??1?$_Vector_alloc@$0A@U?$_Vec_base_types@UFunctionValues@@V?$allocator@UFunctionValues@@@std@@@std@@@std@@QAE@XZ$0 proc near
.text$x:00005164                                         ; DATA XREF: .xdata$x:00009BC8o
.text$x:00005164                 mov     ecx, [ebp-10h]
.text$x:00005167                 jmp     ??1?$_Vector_val@U?$_Simple_types@UFunctionValues@@@std@@@std@@QAE@XZ ; std::_Vector_val<std::_Simple_types<FunctionValues>>::~_Vector_val<std::_Simple_types<FunctionValues>>(void)
.text$x:00005167 __unwindfunclet$??1?$_Vector_alloc@$0A@U?$_Vec_base_types@UFunctionValues@@V?$allocator@UFunctionValues@@@std@@@std@@@std@@QAE@XZ$0 endp
.text$x:00005167
.text$x:0000516C
.text$x:0000516C ; =============== S U B R O U T I N E =======================================
.text$x:0000516C
.text$x:0000516C
.text$x:0000516C __ehhandler$??1?$_Vector_alloc@$0A@U?$_Vec_base_types@UFunctionValues@@V?$allocator@UFunctionValues@@@std@@@std@@@std@@QAE@XZ proc near
.text$x:0000516C                                         ; DATA XREF: std::_Vector_alloc<0,std::_Vec_base_types<FunctionValues,std::allocator<FunctionValues>>>::~_Vector_alloc<0,std::_Vec_base_types<FunctionValues,std::allocator<FunctionValues>>>(void)+5o
.text$x:0000516C
.text$x:0000516C arg_4           = dword ptr  8
.text$x:0000516C
.text$x:0000516C                 mov     edx, [esp+arg_4]
.text$x:00005170                 lea     eax, [edx+0Ch]
.text$x:00005173                 mov     ecx, [edx-8]
.text$x:00005176                 xor     ecx, eax
.text$x:00005178                 call    @__security_check_cookie@4 ; __security_check_cookie(x)
.text$x:0000517D                 mov     eax, offset __ehfuncinfo$??1?$_Vector_alloc@$0A@U?$_Vec_base_types@UFunctionValues@@V?$allocator@UFunctionValues@@@std@@@std@@@std@@QAE@XZ
.text$x:00005182                 jmp     ___CxxFrameHandler3
.text$x:00005182 __ehhandler$??1?$_Vector_alloc@$0A@U?$_Vec_base_types@UFunctionValues@@V?$allocator@UFunctionValues@@@std@@@std@@@std@@QAE@XZ endp
.text$x:00005182
.text$x:00005182 ; ---------------------------------------------------------------------------
.text$x:00005187                 align 4
.text$x:00005187 _text$x         ends
.text$x:00005187
.text$mn:00005188 ; ===========================================================================
.text$mn:00005188
.text$mn:00005188 ; Segment type: Pure code
.text$mn:00005188 ; Segment permissions: Read/Execute
.text$mn:00005188 _text$mn        segment para public 'CODE' use32
.text$mn:00005188                 assume cs:_text$mn
.text$mn:00005188                 ;org 5188h
.text$mn:00005188 ; COMDAT (pick any)
.text$mn:00005188                 assume es:nothing, ss:nothing, ds:_data, fs:nothing, gs:nothing
.text$mn:00005188
.text$mn:00005188 ; =============== S U B R O U T I N E =======================================
.text$mn:00005188
.text$mn:00005188 ; Attributes: bp-based frame
.text$mn:00005188
.text$mn:00005188 ; public: __thiscall std::_Vector_alloc<0, struct std::_Vec_base_types<struct Token, class std::allocator<struct Token>>>::~_Vector_alloc<0, struct std::_Vec_base_types<struct Token, class std::allocator<struct Token>>>(void)
.text$mn:00005188                 public ??1?$_Vector_alloc@$0A@U?$_Vec_base_types@UToken@@V?$allocator@UToken@@@std@@@std@@@std@@QAE@XZ
.text$mn:00005188 ??1?$_Vector_alloc@$0A@U?$_Vec_base_types@UToken@@V?$allocator@UToken@@@std@@@std@@@std@@QAE@XZ proc near
.text$mn:00005188                                         ; CODE XREF: __unwindfunclet$??0?$vector@UToken@@V?$allocator@UToken@@@std@@@std@@QAE@XZ$0+3j
.text$mn:00005188                                         ; std::vector<Token,std::allocator<Token>>::~vector<Token,std::allocator<Token>>(void)+3Fp ...
.text$mn:00005188
.text$mn:00005188 var_10          = dword ptr -10h
.text$mn:00005188 var_C           = dword ptr -0Ch
.text$mn:00005188 var_4           = dword ptr -4
.text$mn:00005188
.text$mn:00005188                 push    ebp
.text$mn:00005189                 mov     ebp, esp
.text$mn:0000518B                 push    0FFFFFFFFh
.text$mn:0000518D                 push    offset __ehhandler$??1?$_Vector_alloc@$0A@U?$_Vec_base_types@UToken@@V?$allocator@UToken@@@std@@@std@@@std@@QAE@XZ
.text$mn:00005192                 mov     eax, large fs:0
.text$mn:00005198                 push    eax
.text$mn:00005199                 push    ecx
.text$mn:0000519A                 mov     eax, dword ptr ds:___security_cookie
.text$mn:0000519F                 xor     eax, ebp
.text$mn:000051A1                 push    eax
.text$mn:000051A2                 lea     eax, [ebp+var_C]
.text$mn:000051A5                 mov     large fs:0, eax
.text$mn:000051AB                 mov     [ebp+var_10], ecx
.text$mn:000051AE                 mov     [ebp+var_4], 0
.text$mn:000051B5                 mov     ecx, [ebp+var_10]
.text$mn:000051B8                 call    ?_Free_proxy@?$_Vector_alloc@$0A@U?$_Vec_base_types@UToken@@V?$allocator@UToken@@@std@@@std@@@std@@QAEXXZ ; std::_Vector_alloc<0,std::_Vec_base_types<Token,std::allocator<Token>>>::_Free_proxy(void)
.text$mn:000051BD                 mov     [ebp+var_4], 0FFFFFFFFh
.text$mn:000051C4                 mov     ecx, [ebp+var_10]
.text$mn:000051C7                 call    ??1?$_Vector_val@U?$_Simple_types@UToken@@@std@@@std@@QAE@XZ ; std::_Vector_val<std::_Simple_types<Token>>::~_Vector_val<std::_Simple_types<Token>>(void)
.text$mn:000051CC                 mov     ecx, [ebp+var_C]
.text$mn:000051CF                 mov     large fs:0, ecx
.text$mn:000051D6                 pop     ecx
.text$mn:000051D7                 mov     esp, ebp
.text$mn:000051D9                 pop     ebp
.text$mn:000051DA                 retn
.text$mn:000051DA ??1?$_Vector_alloc@$0A@U?$_Vec_base_types@UToken@@V?$allocator@UToken@@@std@@@std@@@std@@QAE@XZ endp
.text$mn:000051DA
.text$mn:000051DA ; ---------------------------------------------------------------------------
.text$mn:000051DB                 align 4
.text$mn:000051DB _text$mn        ends
.text$mn:000051DB
.text$x:000051DC ; ===========================================================================
.text$x:000051DC
.text$x:000051DC ; Segment type: Pure code
.text$x:000051DC ; Segment permissions: Read/Execute
.text$x:000051DC _text$x         segment para public 'CODE' use32
.text$x:000051DC                 assume cs:_text$x
.text$x:000051DC                 ;org 51DCh
.text$x:000051DC ; COMDAT (pick associative to section at 5188)
.text$x:000051DC                 assume es:nothing, ss:nothing, ds:_data, fs:nothing, gs:nothing
.text$x:000051DC
.text$x:000051DC ; =============== S U B R O U T I N E =======================================
.text$x:000051DC
.text$x:000051DC
.text$x:000051DC __unwindfunclet$??1?$_Vector_alloc@$0A@U?$_Vec_base_types@UToken@@V?$allocator@UToken@@@std@@@std@@@std@@QAE@XZ$0 proc near
.text$x:000051DC                                         ; DATA XREF: .xdata$x:00009A3Co
.text$x:000051DC                 mov     ecx, [ebp-10h]
.text$x:000051DF                 jmp     ??1?$_Vector_val@U?$_Simple_types@UToken@@@std@@@std@@QAE@XZ ; std::_Vector_val<std::_Simple_types<Token>>::~_Vector_val<std::_Simple_types<Token>>(void)
.text$x:000051DF __unwindfunclet$??1?$_Vector_alloc@$0A@U?$_Vec_base_types@UToken@@V?$allocator@UToken@@@std@@@std@@@std@@QAE@XZ$0 endp
.text$x:000051DF
.text$x:000051E4
.text$x:000051E4 ; =============== S U B R O U T I N E =======================================
.text$x:000051E4
.text$x:000051E4
.text$x:000051E4 __ehhandler$??1?$_Vector_alloc@$0A@U?$_Vec_base_types@UToken@@V?$allocator@UToken@@@std@@@std@@@std@@QAE@XZ proc near
.text$x:000051E4                                         ; DATA XREF: std::_Vector_alloc<0,std::_Vec_base_types<Token,std::allocator<Token>>>::~_Vector_alloc<0,std::_Vec_base_types<Token,std::allocator<Token>>>(void)+5o
.text$x:000051E4
.text$x:000051E4 arg_4           = dword ptr  8
.text$x:000051E4
.text$x:000051E4                 mov     edx, [esp+arg_4]
.text$x:000051E8                 lea     eax, [edx+0Ch]
.text$x:000051EB                 mov     ecx, [edx-8]
.text$x:000051EE                 xor     ecx, eax
.text$x:000051F0                 call    @__security_check_cookie@4 ; __security_check_cookie(x)
.text$x:000051F5                 mov     eax, offset __ehfuncinfo$??1?$_Vector_alloc@$0A@U?$_Vec_base_types@UToken@@V?$allocator@UToken@@@std@@@std@@@std@@QAE@XZ
.text$x:000051FA                 jmp     ___CxxFrameHandler3
.text$x:000051FA __ehhandler$??1?$_Vector_alloc@$0A@U?$_Vec_base_types@UToken@@V?$allocator@UToken@@@std@@@std@@@std@@QAE@XZ endp
.text$x:000051FA
.text$x:000051FA ; ---------------------------------------------------------------------------
.text$x:000051FF                 align 10h
.text$x:000051FF _text$x         ends
.text$x:000051FF
.text$mn:00005200 ; ===========================================================================
.text$mn:00005200
.text$mn:00005200 ; Segment type: Pure code
.text$mn:00005200 ; Segment permissions: Read/Execute
.text$mn:00005200 _text$mn        segment para public 'CODE' use32
.text$mn:00005200                 assume cs:_text$mn
.text$mn:00005200                 ;org 5200h
.text$mn:00005200 ; COMDAT (pick any)
.text$mn:00005200                 assume es:nothing, ss:nothing, ds:_data, fs:nothing, gs:nothing
.text$mn:00005200
.text$mn:00005200 ; =============== S U B R O U T I N E =======================================
.text$mn:00005200
.text$mn:00005200 ; Attributes: bp-based frame
.text$mn:00005200
.text$mn:00005200 ; public: __thiscall std::_Vector_const_iterator<class std::_Vector_val<struct std::_Simple_types<wchar_t const *>>>::~_Vector_const_iterator<class std::_Vector_val<struct std::_Simple_types<wchar_t const *>>>(void)
.text$mn:00005200                 public ??1?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@PB_W@std@@@std@@@std@@QAE@XZ
.text$mn:00005200 ??1?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@PB_W@std@@@std@@@std@@QAE@XZ proc near
.text$mn:00005200                                         ; CODE XREF: std::vector<wchar_t const *,std::allocator<wchar_t const *>>::_Ucopy<std::_Vector_const_iterator<std::_Vector_val<std::_Simple_types<wchar_t const *>>>>(std::_Vector_const_iterator<std::_Vector_val<std::_Simple_types<wchar_t const *>>>,std::_Vector_const_iterator<std::_Vector_val<std::_Simple_types<wchar_t const *>>>,wchar_t const * *)+9Bp
.text$mn:00005200                                         ; std::vector<wchar_t const *,std::allocator<wchar_t const *>>::_Ucopy<std::_Vector_const_iterator<std::_Vector_val<std::_Simple_types<wchar_t const *>>>>(std::_Vector_const_iterator<std::_Vector_val<std::_Simple_types<wchar_t const *>>>,std::_Vector_const_iterator<std::_Vector_val<std::_Simple_types<wchar_t const *>>>,wchar_t const * *)+AAp ...
.text$mn:00005200
.text$mn:00005200 var_10          = dword ptr -10h
.text$mn:00005200 var_C           = dword ptr -0Ch
.text$mn:00005200 var_4           = dword ptr -4
.text$mn:00005200
.text$mn:00005200                 push    ebp
.text$mn:00005201                 mov     ebp, esp
.text$mn:00005203                 push    0FFFFFFFFh
.text$mn:00005205                 push    offset __ehhandler$??1?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@PB_W@std@@@std@@@std@@QAE@XZ
.text$mn:0000520A                 mov     eax, large fs:0
.text$mn:00005210                 push    eax
.text$mn:00005211                 push    ecx
.text$mn:00005212                 mov     eax, dword ptr ds:___security_cookie
.text$mn:00005217                 xor     eax, ebp
.text$mn:00005219                 push    eax
.text$mn:0000521A                 lea     eax, [ebp+var_C]
.text$mn:0000521D                 mov     large fs:0, eax
.text$mn:00005223                 mov     [ebp+var_10], ecx
.text$mn:00005226                 mov     [ebp+var_4], 0
.text$mn:0000522D                 mov     [ebp+var_4], 0FFFFFFFFh
.text$mn:00005234                 mov     ecx, [ebp+var_10]
.text$mn:00005237                 call    ??1?$_Iterator012@Urandom_access_iterator_tag@std@@PB_WHPBQB_WABQB_WU_Iterator_base12@2@@std@@QAE@XZ ; std::_Iterator012<std::random_access_iterator_tag,wchar_t const *,int,wchar_t const * const *,wchar_t const * const &,std::_Iterator_base12>::~_Iterator012<std::random_access_iterator_tag,wchar_t const *,int,wchar_t const * const *,wchar_t const * const &,std::_Iterator_base12>(void)
.text$mn:0000523C                 mov     ecx, [ebp+var_C]
.text$mn:0000523F                 mov     large fs:0, ecx
.text$mn:00005246                 pop     ecx
.text$mn:00005247                 mov     esp, ebp
.text$mn:00005249                 pop     ebp
.text$mn:0000524A                 retn
.text$mn:0000524A ??1?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@PB_W@std@@@std@@@std@@QAE@XZ endp
.text$mn:0000524A
.text$mn:0000524A ; ---------------------------------------------------------------------------
.text$mn:0000524B                 align 4
.text$mn:0000524B _text$mn        ends
.text$mn:0000524B
.text$x:0000524C ; ===========================================================================
.text$x:0000524C
.text$x:0000524C ; Segment type: Pure code
.text$x:0000524C ; Segment permissions: Read/Execute
.text$x:0000524C _text$x         segment para public 'CODE' use32
.text$x:0000524C                 assume cs:_text$x
.text$x:0000524C                 ;org 524Ch
.text$x:0000524C ; COMDAT (pick associative to section at 5200)
.text$x:0000524C                 assume es:nothing, ss:nothing, ds:_data, fs:nothing, gs:nothing
.text$x:0000524C
.text$x:0000524C ; =============== S U B R O U T I N E =======================================
.text$x:0000524C
.text$x:0000524C
.text$x:0000524C __unwindfunclet$??1?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@PB_W@std@@@std@@@std@@QAE@XZ$0 proc near
.text$x:0000524C                                         ; DATA XREF: .xdata$x:00009FA0o
.text$x:0000524C                 mov     ecx, [ebp-10h]
.text$x:0000524F                 jmp     ??1?$_Iterator012@Urandom_access_iterator_tag@std@@PB_WHPBQB_WABQB_WU_Iterator_base12@2@@std@@QAE@XZ ; std::_Iterator012<std::random_access_iterator_tag,wchar_t const *,int,wchar_t const * const *,wchar_t const * const &,std::_Iterator_base12>::~_Iterator012<std::random_access_iterator_tag,wchar_t const *,int,wchar_t const * const *,wchar_t const * const &,std::_Iterator_base12>(void)
.text$x:0000524F __unwindfunclet$??1?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@PB_W@std@@@std@@@std@@QAE@XZ$0 endp
.text$x:0000524F
.text$x:00005254
.text$x:00005254 ; =============== S U B R O U T I N E =======================================
.text$x:00005254
.text$x:00005254
.text$x:00005254 __ehhandler$??1?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@PB_W@std@@@std@@@std@@QAE@XZ proc near
.text$x:00005254                                         ; DATA XREF: std::_Vector_const_iterator<std::_Vector_val<std::_Simple_types<wchar_t const *>>>::~_Vector_const_iterator<std::_Vector_val<std::_Simple_types<wchar_t const *>>>(void)+5o
.text$x:00005254
.text$x:00005254 arg_4           = dword ptr  8
.text$x:00005254
.text$x:00005254                 mov     edx, [esp+arg_4]
.text$x:00005258                 lea     eax, [edx+0Ch]
.text$x:0000525B                 mov     ecx, [edx-8]
.text$x:0000525E                 xor     ecx, eax
.text$x:00005260                 call    @__security_check_cookie@4 ; __security_check_cookie(x)
.text$x:00005265                 mov     eax, offset __ehfuncinfo$??1?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@PB_W@std@@@std@@@std@@QAE@XZ
.text$x:0000526A                 jmp     ___CxxFrameHandler3
.text$x:0000526A __ehhandler$??1?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@PB_W@std@@@std@@@std@@QAE@XZ endp
.text$x:0000526A
.text$x:0000526A ; ---------------------------------------------------------------------------
.text$x:0000526F                 align 10h
.text$x:0000526F _text$x         ends
.text$x:0000526F
.text$mn:00005270 ; ===========================================================================
.text$mn:00005270
.text$mn:00005270 ; Segment type: Pure code
.text$mn:00005270 ; Segment permissions: Read/Execute
.text$mn:00005270 _text$mn        segment para public 'CODE' use32
.text$mn:00005270                 assume cs:_text$mn
.text$mn:00005270                 ;org 5270h
.text$mn:00005270 ; COMDAT (pick any)
.text$mn:00005270                 assume es:nothing, ss:nothing, ds:_data, fs:nothing, gs:nothing
.text$mn:00005270
.text$mn:00005270 ; =============== S U B R O U T I N E =======================================
.text$mn:00005270
.text$mn:00005270 ; Attributes: bp-based frame
.text$mn:00005270
.text$mn:00005270 ; public: __thiscall std::_Vector_const_iterator<class std::_Vector_val<struct std::_Simple_types<struct FunctionValues>>>::~_Vector_const_iterator<class std::_Vector_val<struct std::_Simple_types<struct FunctionValues>>>(void)
.text$mn:00005270                 public ??1?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@UFunctionValues@@@std@@@std@@@std@@QAE@XZ
.text$mn:00005270 ??1?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@UFunctionValues@@@std@@@std@@@std@@QAE@XZ proc near
.text$mn:00005270                                         ; CODE XREF: __unwindfunclet$??0?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@UFunctionValues@@@std@@@std@@@std@@QAE@ABV01@@Z$0+3j
.text$mn:00005270                                         ; __unwindfunclet$??0?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@UFunctionValues@@@std@@@std@@@std@@QAE@PAUFunctionValues@@PBU_Container_base12@1@@Z$0+3j ...
.text$mn:00005270
.text$mn:00005270 var_10          = dword ptr -10h
.text$mn:00005270 var_C           = dword ptr -0Ch
.text$mn:00005270 var_4           = dword ptr -4
.text$mn:00005270
.text$mn:00005270                 push    ebp
.text$mn:00005271                 mov     ebp, esp
.text$mn:00005273                 push    0FFFFFFFFh
.text$mn:00005275                 push    offset __ehhandler$??1?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@UFunctionValues@@@std@@@std@@@std@@QAE@XZ
.text$mn:0000527A                 mov     eax, large fs:0
.text$mn:00005280                 push    eax
.text$mn:00005281                 push    ecx
.text$mn:00005282                 mov     eax, dword ptr ds:___security_cookie
.text$mn:00005287                 xor     eax, ebp
.text$mn:00005289                 push    eax
.text$mn:0000528A                 lea     eax, [ebp+var_C]
.text$mn:0000528D                 mov     large fs:0, eax
.text$mn:00005293                 mov     [ebp+var_10], ecx
.text$mn:00005296                 mov     [ebp+var_4], 0
.text$mn:0000529D                 mov     [ebp+var_4], 0FFFFFFFFh
.text$mn:000052A4                 mov     ecx, [ebp+var_10]
.text$mn:000052A7                 call    ??1?$_Iterator012@Urandom_access_iterator_tag@std@@UFunctionValues@@HPBU3@ABU3@U_Iterator_base12@2@@std@@QAE@XZ ; std::_Iterator012<std::random_access_iterator_tag,FunctionValues,int,FunctionValues const *,FunctionValues const &,std::_Iterator_base12>::~_Iterator012<std::random_access_iterator_tag,FunctionValues,int,FunctionValues const *,FunctionValues const &,std::_Iterator_base12>(void)
.text$mn:000052AC                 mov     ecx, [ebp+var_C]
.text$mn:000052AF                 mov     large fs:0, ecx
.text$mn:000052B6                 pop     ecx
.text$mn:000052B7                 mov     esp, ebp
.text$mn:000052B9                 pop     ebp
.text$mn:000052BA                 retn
.text$mn:000052BA ??1?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@UFunctionValues@@@std@@@std@@@std@@QAE@XZ endp
.text$mn:000052BA
.text$mn:000052BA ; ---------------------------------------------------------------------------
.text$mn:000052BB                 align 4
.text$mn:000052BB _text$mn        ends
.text$mn:000052BB
.text$x:000052BC ; ===========================================================================
.text$x:000052BC
.text$x:000052BC ; Segment type: Pure code
.text$x:000052BC ; Segment permissions: Read/Execute
.text$x:000052BC _text$x         segment para public 'CODE' use32
.text$x:000052BC                 assume cs:_text$x
.text$x:000052BC                 ;org 52BCh
.text$x:000052BC ; COMDAT (pick associative to section at 5270)
.text$x:000052BC                 assume es:nothing, ss:nothing, ds:_data, fs:nothing, gs:nothing
.text$x:000052BC
.text$x:000052BC ; =============== S U B R O U T I N E =======================================
.text$x:000052BC
.text$x:000052BC
.text$x:000052BC __unwindfunclet$??1?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@UFunctionValues@@@std@@@std@@@std@@QAE@XZ$0 proc near
.text$x:000052BC                                         ; DATA XREF: .xdata$x:00009DE0o
.text$x:000052BC                 mov     ecx, [ebp-10h]
.text$x:000052BF                 jmp     ??1?$_Iterator012@Urandom_access_iterator_tag@std@@UFunctionValues@@HPBU3@ABU3@U_Iterator_base12@2@@std@@QAE@XZ ; std::_Iterator012<std::random_access_iterator_tag,FunctionValues,int,FunctionValues const *,FunctionValues const &,std::_Iterator_base12>::~_Iterator012<std::random_access_iterator_tag,FunctionValues,int,FunctionValues const *,FunctionValues const &,std::_Iterator_base12>(void)
.text$x:000052BF __unwindfunclet$??1?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@UFunctionValues@@@std@@@std@@@std@@QAE@XZ$0 endp
.text$x:000052BF
.text$x:000052C4
.text$x:000052C4 ; =============== S U B R O U T I N E =======================================
.text$x:000052C4
.text$x:000052C4
.text$x:000052C4 __ehhandler$??1?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@UFunctionValues@@@std@@@std@@@std@@QAE@XZ proc near
.text$x:000052C4                                         ; DATA XREF: std::_Vector_const_iterator<std::_Vector_val<std::_Simple_types<FunctionValues>>>::~_Vector_const_iterator<std::_Vector_val<std::_Simple_types<FunctionValues>>>(void)+5o
.text$x:000052C4
.text$x:000052C4 arg_4           = dword ptr  8
.text$x:000052C4
.text$x:000052C4                 mov     edx, [esp+arg_4]
.text$x:000052C8                 lea     eax, [edx+0Ch]
.text$x:000052CB                 mov     ecx, [edx-8]
.text$x:000052CE                 xor     ecx, eax
.text$x:000052D0                 call    @__security_check_cookie@4 ; __security_check_cookie(x)
.text$x:000052D5                 mov     eax, offset __ehfuncinfo$??1?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@UFunctionValues@@@std@@@std@@@std@@QAE@XZ
.text$x:000052DA                 jmp     ___CxxFrameHandler3
.text$x:000052DA __ehhandler$??1?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@UFunctionValues@@@std@@@std@@@std@@QAE@XZ endp
.text$x:000052DA
.text$x:000052DA ; ---------------------------------------------------------------------------
.text$x:000052DF                 align 10h
.text$x:000052DF _text$x         ends
.text$x:000052DF
.text$mn:000052E0 ; ===========================================================================
.text$mn:000052E0
.text$mn:000052E0 ; Segment type: Pure code
.text$mn:000052E0 ; Segment permissions: Read/Execute
.text$mn:000052E0 _text$mn        segment para public 'CODE' use32
.text$mn:000052E0                 assume cs:_text$mn
.text$mn:000052E0                 ;org 52E0h
.text$mn:000052E0 ; COMDAT (pick any)
.text$mn:000052E0                 assume es:nothing, ss:nothing, ds:_data, fs:nothing, gs:nothing
.text$mn:000052E0
.text$mn:000052E0 ; =============== S U B R O U T I N E =======================================
.text$mn:000052E0
.text$mn:000052E0 ; Attributes: bp-based frame
.text$mn:000052E0
.text$mn:000052E0 ; public: __thiscall std::_Vector_iterator<class std::_Vector_val<struct std::_Simple_types<struct FunctionValues>>>::~_Vector_iterator<class std::_Vector_val<struct std::_Simple_types<struct FunctionValues>>>(void)
.text$mn:000052E0                 public ??1?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@UFunctionValues@@@std@@@std@@@std@@QAE@XZ
.text$mn:000052E0 ??1?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@UFunctionValues@@@std@@@std@@@std@@QAE@XZ proc near
.text$mn:000052E0                                         ; CODE XREF: std::_Vector_iterator<std::_Vector_val<std::_Simple_types<FunctionValues>>>::operator-(int)+67p
.text$mn:000052E0                                         ; __unwindfunclet$??G?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@UFunctionValues@@@std@@@std@@@std@@QBE?AV01@H@Z$0+3j ...
.text$mn:000052E0
.text$mn:000052E0 var_10          = dword ptr -10h
.text$mn:000052E0 var_C           = dword ptr -0Ch
.text$mn:000052E0 var_4           = dword ptr -4
.text$mn:000052E0
.text$mn:000052E0                 push    ebp
.text$mn:000052E1                 mov     ebp, esp
.text$mn:000052E3                 push    0FFFFFFFFh
.text$mn:000052E5                 push    offset __ehhandler$??1?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@UFunctionValues@@@std@@@std@@@std@@QAE@XZ
.text$mn:000052EA                 mov     eax, large fs:0
.text$mn:000052F0                 push    eax
.text$mn:000052F1                 push    ecx
.text$mn:000052F2                 mov     eax, dword ptr ds:___security_cookie
.text$mn:000052F7                 xor     eax, ebp
.text$mn:000052F9                 push    eax
.text$mn:000052FA                 lea     eax, [ebp+var_C]
.text$mn:000052FD                 mov     large fs:0, eax
.text$mn:00005303                 mov     [ebp+var_10], ecx
.text$mn:00005306                 mov     [ebp+var_4], 0
.text$mn:0000530D                 mov     [ebp+var_4], 0FFFFFFFFh
.text$mn:00005314                 mov     ecx, [ebp+var_10]
.text$mn:00005317                 call    ??1?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@UFunctionValues@@@std@@@std@@@std@@QAE@XZ ; std::_Vector_const_iterator<std::_Vector_val<std::_Simple_types<FunctionValues>>>::~_Vector_const_iterator<std::_Vector_val<std::_Simple_types<FunctionValues>>>(void)
.text$mn:0000531C                 mov     ecx, [ebp+var_C]
.text$mn:0000531F                 mov     large fs:0, ecx
.text$mn:00005326                 pop     ecx
.text$mn:00005327                 mov     esp, ebp
.text$mn:00005329                 pop     ebp
.text$mn:0000532A                 retn
.text$mn:0000532A ??1?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@UFunctionValues@@@std@@@std@@@std@@QAE@XZ endp
.text$mn:0000532A
.text$mn:0000532A ; ---------------------------------------------------------------------------
.text$mn:0000532B                 align 4
.text$mn:0000532B _text$mn        ends
.text$mn:0000532B
.text$x:0000532C ; ===========================================================================
.text$x:0000532C
.text$x:0000532C ; Segment type: Pure code
.text$x:0000532C ; Segment permissions: Read/Execute
.text$x:0000532C _text$x         segment para public 'CODE' use32
.text$x:0000532C                 assume cs:_text$x
.text$x:0000532C                 ;org 532Ch
.text$x:0000532C ; COMDAT (pick associative to section at 52E0)
.text$x:0000532C                 assume es:nothing, ss:nothing, ds:_data, fs:nothing, gs:nothing
.text$x:0000532C
.text$x:0000532C ; =============== S U B R O U T I N E =======================================
.text$x:0000532C
.text$x:0000532C
.text$x:0000532C __unwindfunclet$??1?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@UFunctionValues@@@std@@@std@@@std@@QAE@XZ$0 proc near
.text$x:0000532C                                         ; DATA XREF: .xdata$x:00009E98o
.text$x:0000532C                 mov     ecx, [ebp-10h]
.text$x:0000532F                 jmp     ??1?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@UFunctionValues@@@std@@@std@@@std@@QAE@XZ ; std::_Vector_const_iterator<std::_Vector_val<std::_Simple_types<FunctionValues>>>::~_Vector_const_iterator<std::_Vector_val<std::_Simple_types<FunctionValues>>>(void)
.text$x:0000532F __unwindfunclet$??1?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@UFunctionValues@@@std@@@std@@@std@@QAE@XZ$0 endp
.text$x:0000532F
.text$x:00005334
.text$x:00005334 ; =============== S U B R O U T I N E =======================================
.text$x:00005334
.text$x:00005334
.text$x:00005334 __ehhandler$??1?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@UFunctionValues@@@std@@@std@@@std@@QAE@XZ proc near
.text$x:00005334                                         ; DATA XREF: std::_Vector_iterator<std::_Vector_val<std::_Simple_types<FunctionValues>>>::~_Vector_iterator<std::_Vector_val<std::_Simple_types<FunctionValues>>>(void)+5o
.text$x:00005334
.text$x:00005334 arg_4           = dword ptr  8
.text$x:00005334
.text$x:00005334                 mov     edx, [esp+arg_4]
.text$x:00005338                 lea     eax, [edx+0Ch]
.text$x:0000533B                 mov     ecx, [edx-8]
.text$x:0000533E                 xor     ecx, eax
.text$x:00005340                 call    @__security_check_cookie@4 ; __security_check_cookie(x)
.text$x:00005345                 mov     eax, offset __ehfuncinfo$??1?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@UFunctionValues@@@std@@@std@@@std@@QAE@XZ
.text$x:0000534A                 jmp     ___CxxFrameHandler3
.text$x:0000534A __ehhandler$??1?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@UFunctionValues@@@std@@@std@@@std@@QAE@XZ endp
.text$x:0000534A
.text$x:0000534A ; ---------------------------------------------------------------------------
.text$x:0000534F                 align 10h
.text$x:0000534F _text$x         ends
.text$x:0000534F
.text$mn:00005350 ; ===========================================================================
.text$mn:00005350
.text$mn:00005350 ; Segment type: Pure code
.text$mn:00005350 ; Segment permissions: Read/Execute
.text$mn:00005350 _text$mn        segment para public 'CODE' use32
.text$mn:00005350                 assume cs:_text$mn
.text$mn:00005350                 ;org 5350h
.text$mn:00005350 ; COMDAT (pick any)
.text$mn:00005350                 assume es:nothing, ss:nothing, ds:_data, fs:nothing, gs:nothing
.text$mn:00005350
.text$mn:00005350 ; =============== S U B R O U T I N E =======================================
.text$mn:00005350
.text$mn:00005350 ; Attributes: bp-based frame
.text$mn:00005350
.text$mn:00005350 ; public: __thiscall std::_Vector_val<struct std::_Simple_types<wchar_t const *>>::~_Vector_val<struct std::_Simple_types<wchar_t const *>>(void)
.text$mn:00005350                 public ??1?$_Vector_val@U?$_Simple_types@PB_W@std@@@std@@QAE@XZ
.text$mn:00005350 ??1?$_Vector_val@U?$_Simple_types@PB_W@std@@@std@@QAE@XZ proc near
.text$mn:00005350                                         ; CODE XREF: __unwindfunclet$??0?$_Vector_alloc@$0A@U?$_Vec_base_types@PB_WV?$allocator@PB_W@std@@@std@@@std@@QAE@ABV?$allocator@PB_W@1@@Z$0+3j
.text$mn:00005350                                         ; std::_Vector_alloc<0,std::_Vec_base_types<wchar_t const *,std::allocator<wchar_t const *>>>::~_Vector_alloc<0,std::_Vec_base_types<wchar_t const *,std::allocator<wchar_t const *>>>(void)+3Fp ...
.text$mn:00005350
.text$mn:00005350 var_10          = dword ptr -10h
.text$mn:00005350 var_C           = dword ptr -0Ch
.text$mn:00005350 var_4           = dword ptr -4
.text$mn:00005350
.text$mn:00005350                 push    ebp
.text$mn:00005351                 mov     ebp, esp
.text$mn:00005353                 push    0FFFFFFFFh
.text$mn:00005355                 push    offset __ehhandler$??1?$_Vector_val@U?$_Simple_types@PB_W@std@@@std@@QAE@XZ
.text$mn:0000535A                 mov     eax, large fs:0
.text$mn:00005360                 push    eax
.text$mn:00005361                 push    ecx
.text$mn:00005362                 mov     eax, dword ptr ds:___security_cookie
.text$mn:00005367                 xor     eax, ebp
.text$mn:00005369                 push    eax
.text$mn:0000536A                 lea     eax, [ebp+var_C]
.text$mn:0000536D                 mov     large fs:0, eax
.text$mn:00005373                 mov     [ebp+var_10], ecx
.text$mn:00005376                 mov     [ebp+var_4], 0
.text$mn:0000537D                 mov     [ebp+var_4], 0FFFFFFFFh
.text$mn:00005384                 mov     ecx, [ebp+var_10] ; this
.text$mn:00005387                 call    ??1_Container_base12@std@@QAE@XZ ; std::_Container_base12::~_Container_base12(void)
.text$mn:0000538C                 mov     ecx, [ebp+var_C]
.text$mn:0000538F                 mov     large fs:0, ecx
.text$mn:00005396                 pop     ecx
.text$mn:00005397                 mov     esp, ebp
.text$mn:00005399                 pop     ebp
.text$mn:0000539A                 retn
.text$mn:0000539A ??1?$_Vector_val@U?$_Simple_types@PB_W@std@@@std@@QAE@XZ endp
.text$mn:0000539A
.text$mn:0000539A ; ---------------------------------------------------------------------------
.text$mn:0000539B                 align 4
.text$mn:0000539B _text$mn        ends
.text$mn:0000539B
.text$x:0000539C ; ===========================================================================
.text$x:0000539C
.text$x:0000539C ; Segment type: Pure code
.text$x:0000539C ; Segment permissions: Read/Execute
.text$x:0000539C _text$x         segment para public 'CODE' use32
.text$x:0000539C                 assume cs:_text$x
.text$x:0000539C                 ;org 539Ch
.text$x:0000539C ; COMDAT (pick associative to section at 5350)
.text$x:0000539C                 assume es:nothing, ss:nothing, ds:_data, fs:nothing, gs:nothing
.text$x:0000539C
.text$x:0000539C ; =============== S U B R O U T I N E =======================================
.text$x:0000539C
.text$x:0000539C
.text$x:0000539C __unwindfunclet$??1?$_Vector_val@U?$_Simple_types@PB_W@std@@@std@@QAE@XZ$0 proc near
.text$x:0000539C                                         ; DATA XREF: .xdata$x:00009654o
.text$x:0000539C                 mov     ecx, [ebp-10h]  ; this
.text$x:0000539F                 jmp     ??1_Container_base12@std@@QAE@XZ ; std::_Container_base12::~_Container_base12(void)
.text$x:0000539F __unwindfunclet$??1?$_Vector_val@U?$_Simple_types@PB_W@std@@@std@@QAE@XZ$0 endp
.text$x:0000539F
.text$x:000053A4
.text$x:000053A4 ; =============== S U B R O U T I N E =======================================
.text$x:000053A4
.text$x:000053A4
.text$x:000053A4 __ehhandler$??1?$_Vector_val@U?$_Simple_types@PB_W@std@@@std@@QAE@XZ proc near
.text$x:000053A4                                         ; DATA XREF: std::_Vector_val<std::_Simple_types<wchar_t const *>>::~_Vector_val<std::_Simple_types<wchar_t const *>>(void)+5o
.text$x:000053A4
.text$x:000053A4 arg_4           = dword ptr  8
.text$x:000053A4
.text$x:000053A4                 mov     edx, [esp+arg_4]
.text$x:000053A8                 lea     eax, [edx+0Ch]
.text$x:000053AB                 mov     ecx, [edx-8]
.text$x:000053AE                 xor     ecx, eax
.text$x:000053B0                 call    @__security_check_cookie@4 ; __security_check_cookie(x)
.text$x:000053B5                 mov     eax, offset __ehfuncinfo$??1?$_Vector_val@U?$_Simple_types@PB_W@std@@@std@@QAE@XZ
.text$x:000053BA                 jmp     ___CxxFrameHandler3
.text$x:000053BA __ehhandler$??1?$_Vector_val@U?$_Simple_types@PB_W@std@@@std@@QAE@XZ endp
.text$x:000053BA
.text$x:000053BA ; ---------------------------------------------------------------------------
.text$x:000053BF                 align 10h
.text$x:000053BF _text$x         ends
.text$x:000053BF
.text$mn:000053C0 ; ===========================================================================
.text$mn:000053C0
.text$mn:000053C0 ; Segment type: Pure code
.text$mn:000053C0 ; Segment permissions: Read/Execute
.text$mn:000053C0 _text$mn        segment para public 'CODE' use32
.text$mn:000053C0                 assume cs:_text$mn
.text$mn:000053C0                 ;org 53C0h
.text$mn:000053C0 ; COMDAT (pick any)
.text$mn:000053C0                 assume es:nothing, ss:nothing, ds:_data, fs:nothing, gs:nothing
.text$mn:000053C0
.text$mn:000053C0 ; =============== S U B R O U T I N E =======================================
.text$mn:000053C0
.text$mn:000053C0 ; Attributes: bp-based frame
.text$mn:000053C0
.text$mn:000053C0 ; public: __thiscall std::_Vector_val<struct std::_Simple_types<struct FunctionValues>>::~_Vector_val<struct std::_Simple_types<struct FunctionValues>>(void)
.text$mn:000053C0                 public ??1?$_Vector_val@U?$_Simple_types@UFunctionValues@@@std@@@std@@QAE@XZ
.text$mn:000053C0 ??1?$_Vector_val@U?$_Simple_types@UFunctionValues@@@std@@@std@@QAE@XZ proc near
.text$mn:000053C0                                         ; CODE XREF: __unwindfunclet$??0?$_Vector_alloc@$0A@U?$_Vec_base_types@UFunctionValues@@V?$allocator@UFunctionValues@@@std@@@std@@@std@@QAE@ABV?$allocator@UFunctionValues@@@1@@Z$0+3j
.text$mn:000053C0                                         ; std::_Vector_alloc<0,std::_Vec_base_types<FunctionValues,std::allocator<FunctionValues>>>::~_Vector_alloc<0,std::_Vec_base_types<FunctionValues,std::allocator<FunctionValues>>>(void)+3Fp ...
.text$mn:000053C0
.text$mn:000053C0 var_10          = dword ptr -10h
.text$mn:000053C0 var_C           = dword ptr -0Ch
.text$mn:000053C0 var_4           = dword ptr -4
.text$mn:000053C0
.text$mn:000053C0                 push    ebp
.text$mn:000053C1                 mov     ebp, esp
.text$mn:000053C3                 push    0FFFFFFFFh
.text$mn:000053C5                 push    offset __ehhandler$??1?$_Vector_val@U?$_Simple_types@UFunctionValues@@@std@@@std@@QAE@XZ
.text$mn:000053CA                 mov     eax, large fs:0
.text$mn:000053D0                 push    eax
.text$mn:000053D1                 push    ecx
.text$mn:000053D2                 mov     eax, dword ptr ds:___security_cookie
.text$mn:000053D7                 xor     eax, ebp
.text$mn:000053D9                 push    eax
.text$mn:000053DA                 lea     eax, [ebp+var_C]
.text$mn:000053DD                 mov     large fs:0, eax
.text$mn:000053E3                 mov     [ebp+var_10], ecx
.text$mn:000053E6                 mov     [ebp+var_4], 0
.text$mn:000053ED                 mov     [ebp+var_4], 0FFFFFFFFh
.text$mn:000053F4                 mov     ecx, [ebp+var_10] ; this
.text$mn:000053F7                 call    ??1_Container_base12@std@@QAE@XZ ; std::_Container_base12::~_Container_base12(void)
.text$mn:000053FC                 mov     ecx, [ebp+var_C]
.text$mn:000053FF                 mov     large fs:0, ecx
.text$mn:00005406                 pop     ecx
.text$mn:00005407                 mov     esp, ebp
.text$mn:00005409                 pop     ebp
.text$mn:0000540A                 retn
.text$mn:0000540A ??1?$_Vector_val@U?$_Simple_types@UFunctionValues@@@std@@@std@@QAE@XZ endp
.text$mn:0000540A
.text$mn:0000540A ; ---------------------------------------------------------------------------
.text$mn:0000540B                 align 4
.text$mn:0000540B _text$mn        ends
.text$mn:0000540B
.text$x:0000540C ; ===========================================================================
.text$x:0000540C
.text$x:0000540C ; Segment type: Pure code
.text$x:0000540C ; Segment permissions: Read/Execute
.text$x:0000540C _text$x         segment para public 'CODE' use32
.text$x:0000540C                 assume cs:_text$x
.text$x:0000540C                 ;org 540Ch
.text$x:0000540C ; COMDAT (pick associative to section at 53C0)
.text$x:0000540C                 assume es:nothing, ss:nothing, ds:_data, fs:nothing, gs:nothing
.text$x:0000540C
.text$x:0000540C ; =============== S U B R O U T I N E =======================================
.text$x:0000540C
.text$x:0000540C
.text$x:0000540C __unwindfunclet$??1?$_Vector_val@U?$_Simple_types@UFunctionValues@@@std@@@std@@QAE@XZ$0 proc near
.text$x:0000540C                                         ; DATA XREF: .xdata$x:00009B70o
.text$x:0000540C                 mov     ecx, [ebp-10h]  ; this
.text$x:0000540F                 jmp     ??1_Container_base12@std@@QAE@XZ ; std::_Container_base12::~_Container_base12(void)
.text$x:0000540F __unwindfunclet$??1?$_Vector_val@U?$_Simple_types@UFunctionValues@@@std@@@std@@QAE@XZ$0 endp
.text$x:0000540F
.text$x:00005414
.text$x:00005414 ; =============== S U B R O U T I N E =======================================
.text$x:00005414
.text$x:00005414
.text$x:00005414 __ehhandler$??1?$_Vector_val@U?$_Simple_types@UFunctionValues@@@std@@@std@@QAE@XZ proc near
.text$x:00005414                                         ; DATA XREF: std::_Vector_val<std::_Simple_types<FunctionValues>>::~_Vector_val<std::_Simple_types<FunctionValues>>(void)+5o
.text$x:00005414
.text$x:00005414 arg_4           = dword ptr  8
.text$x:00005414
.text$x:00005414                 mov     edx, [esp+arg_4]
.text$x:00005418                 lea     eax, [edx+0Ch]
.text$x:0000541B                 mov     ecx, [edx-8]
.text$x:0000541E                 xor     ecx, eax
.text$x:00005420                 call    @__security_check_cookie@4 ; __security_check_cookie(x)
.text$x:00005425                 mov     eax, offset __ehfuncinfo$??1?$_Vector_val@U?$_Simple_types@UFunctionValues@@@std@@@std@@QAE@XZ
.text$x:0000542A                 jmp     ___CxxFrameHandler3
.text$x:0000542A __ehhandler$??1?$_Vector_val@U?$_Simple_types@UFunctionValues@@@std@@@std@@QAE@XZ endp
.text$x:0000542A
.text$x:0000542A ; ---------------------------------------------------------------------------
.text$x:0000542F                 align 10h
.text$x:0000542F _text$x         ends
.text$x:0000542F
.text$mn:00005430 ; ===========================================================================
.text$mn:00005430
.text$mn:00005430 ; Segment type: Pure code
.text$mn:00005430 ; Segment permissions: Read/Execute
.text$mn:00005430 _text$mn        segment para public 'CODE' use32
.text$mn:00005430                 assume cs:_text$mn
.text$mn:00005430                 ;org 5430h
.text$mn:00005430 ; COMDAT (pick any)
.text$mn:00005430                 assume es:nothing, ss:nothing, ds:_data, fs:nothing, gs:nothing
.text$mn:00005430
.text$mn:00005430 ; =============== S U B R O U T I N E =======================================
.text$mn:00005430
.text$mn:00005430 ; Attributes: bp-based frame
.text$mn:00005430
.text$mn:00005430 ; public: __thiscall std::_Vector_val<struct std::_Simple_types<struct Token>>::~_Vector_val<struct std::_Simple_types<struct Token>>(void)
.text$mn:00005430                 public ??1?$_Vector_val@U?$_Simple_types@UToken@@@std@@@std@@QAE@XZ
.text$mn:00005430 ??1?$_Vector_val@U?$_Simple_types@UToken@@@std@@@std@@QAE@XZ proc near
.text$mn:00005430                                         ; CODE XREF: __unwindfunclet$??0?$_Vector_alloc@$0A@U?$_Vec_base_types@UToken@@V?$allocator@UToken@@@std@@@std@@@std@@QAE@ABV?$allocator@UToken@@@1@@Z$0+3j
.text$mn:00005430                                         ; std::_Vector_alloc<0,std::_Vec_base_types<Token,std::allocator<Token>>>::~_Vector_alloc<0,std::_Vec_base_types<Token,std::allocator<Token>>>(void)+3Fp ...
.text$mn:00005430
.text$mn:00005430 var_10          = dword ptr -10h
.text$mn:00005430 var_C           = dword ptr -0Ch
.text$mn:00005430 var_4           = dword ptr -4
.text$mn:00005430
.text$mn:00005430                 push    ebp
.text$mn:00005431                 mov     ebp, esp
.text$mn:00005433                 push    0FFFFFFFFh
.text$mn:00005435                 push    offset __ehhandler$??1?$_Vector_val@U?$_Simple_types@UToken@@@std@@@std@@QAE@XZ
.text$mn:0000543A                 mov     eax, large fs:0
.text$mn:00005440                 push    eax
.text$mn:00005441                 push    ecx
.text$mn:00005442                 mov     eax, dword ptr ds:___security_cookie
.text$mn:00005447                 xor     eax, ebp
.text$mn:00005449                 push    eax
.text$mn:0000544A                 lea     eax, [ebp+var_C]
.text$mn:0000544D                 mov     large fs:0, eax
.text$mn:00005453                 mov     [ebp+var_10], ecx
.text$mn:00005456                 mov     [ebp+var_4], 0
.text$mn:0000545D                 mov     [ebp+var_4], 0FFFFFFFFh
.text$mn:00005464                 mov     ecx, [ebp+var_10] ; this
.text$mn:00005467                 call    ??1_Container_base12@std@@QAE@XZ ; std::_Container_base12::~_Container_base12(void)
.text$mn:0000546C                 mov     ecx, [ebp+var_C]
.text$mn:0000546F                 mov     large fs:0, ecx
.text$mn:00005476                 pop     ecx
.text$mn:00005477                 mov     esp, ebp
.text$mn:00005479                 pop     ebp
.text$mn:0000547A                 retn
.text$mn:0000547A ??1?$_Vector_val@U?$_Simple_types@UToken@@@std@@@std@@QAE@XZ endp
.text$mn:0000547A
.text$mn:0000547A ; ---------------------------------------------------------------------------
.text$mn:0000547B                 align 4
.text$mn:0000547B _text$mn        ends
.text$mn:0000547B
.text$x:0000547C ; ===========================================================================
.text$x:0000547C
.text$x:0000547C ; Segment type: Pure code
.text$x:0000547C ; Segment permissions: Read/Execute
.text$x:0000547C _text$x         segment para public 'CODE' use32
.text$x:0000547C                 assume cs:_text$x
.text$x:0000547C                 ;org 547Ch
.text$x:0000547C ; COMDAT (pick associative to section at 5430)
.text$x:0000547C                 assume es:nothing, ss:nothing, ds:_data, fs:nothing, gs:nothing
.text$x:0000547C
.text$x:0000547C ; =============== S U B R O U T I N E =======================================
.text$x:0000547C
.text$x:0000547C
.text$x:0000547C __unwindfunclet$??1?$_Vector_val@U?$_Simple_types@UToken@@@std@@@std@@QAE@XZ$0 proc near
.text$x:0000547C                                         ; DATA XREF: .xdata$x:000099E4o
.text$x:0000547C                 mov     ecx, [ebp-10h]  ; this
.text$x:0000547F                 jmp     ??1_Container_base12@std@@QAE@XZ ; std::_Container_base12::~_Container_base12(void)
.text$x:0000547F __unwindfunclet$??1?$_Vector_val@U?$_Simple_types@UToken@@@std@@@std@@QAE@XZ$0 endp
.text$x:0000547F
.text$x:00005484
.text$x:00005484 ; =============== S U B R O U T I N E =======================================
.text$x:00005484
.text$x:00005484
.text$x:00005484 __ehhandler$??1?$_Vector_val@U?$_Simple_types@UToken@@@std@@@std@@QAE@XZ proc near
.text$x:00005484                                         ; DATA XREF: std::_Vector_val<std::_Simple_types<Token>>::~_Vector_val<std::_Simple_types<Token>>(void)+5o
.text$x:00005484
.text$x:00005484 arg_4           = dword ptr  8
.text$x:00005484
.text$x:00005484                 mov     edx, [esp+arg_4]
.text$x:00005488                 lea     eax, [edx+0Ch]
.text$x:0000548B                 mov     ecx, [edx-8]
.text$x:0000548E                 xor     ecx, eax
.text$x:00005490                 call    @__security_check_cookie@4 ; __security_check_cookie(x)
.text$x:00005495                 mov     eax, offset __ehfuncinfo$??1?$_Vector_val@U?$_Simple_types@UToken@@@std@@@std@@QAE@XZ
.text$x:0000549A                 jmp     ___CxxFrameHandler3
.text$x:0000549A __ehhandler$??1?$_Vector_val@U?$_Simple_types@UToken@@@std@@@std@@QAE@XZ endp
.text$x:0000549A
.text$x:0000549A ; ---------------------------------------------------------------------------
.text$x:0000549F                 align 10h
.text$x:0000549F _text$x         ends
.text$x:0000549F
.text$mn:000054A0 ; ===========================================================================
.text$mn:000054A0
.text$mn:000054A0 ; Segment type: Pure code
.text$mn:000054A0 ; Segment permissions: Read/Execute
.text$mn:000054A0 _text$mn        segment para public 'CODE' use32
.text$mn:000054A0                 assume cs:_text$mn
.text$mn:000054A0                 ;org 54A0h
.text$mn:000054A0 ; COMDAT (pick any)
.text$mn:000054A0                 assume es:nothing, ss:nothing, ds:_data, fs:nothing, gs:nothing
.text$mn:000054A0
.text$mn:000054A0 ; =============== S U B R O U T I N E =======================================
.text$mn:000054A0
.text$mn:000054A0 ; Attributes: bp-based frame
.text$mn:000054A0
.text$mn:000054A0 ; public: __thiscall std::basic_string<char, struct std::char_traits<char>, class std::allocator<char>>::~basic_string<char, struct std::char_traits<char>, class std::allocator<char>>(void)
.text$mn:000054A0                 public ??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ
.text$mn:000054A0 ??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ proc near
.text$mn:000054A0                                         ; CODE XREF: __unwindfunclet$?message@_Generic_error_category@std@@UBE?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@2@H@Z$0+13j
.text$mn:000054A0                                         ; __unwindfunclet$?message@_Iostream_error_category@std@@UBE?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@2@H@Z$0+13j ...
.text$mn:000054A0
.text$mn:000054A0 var_10          = dword ptr -10h
.text$mn:000054A0 var_C           = dword ptr -0Ch
.text$mn:000054A0 var_4           = dword ptr -4
.text$mn:000054A0
.text$mn:000054A0                 push    ebp
.text$mn:000054A1                 mov     ebp, esp
.text$mn:000054A3                 push    0FFFFFFFFh
.text$mn:000054A5                 push    offset __ehhandler$??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ
.text$mn:000054AA                 mov     eax, large fs:0
.text$mn:000054B0                 push    eax
.text$mn:000054B1                 push    ecx
.text$mn:000054B2                 mov     eax, dword ptr ds:___security_cookie
.text$mn:000054B7                 xor     eax, ebp
.text$mn:000054B9                 push    eax
.text$mn:000054BA                 lea     eax, [ebp+var_C]
.text$mn:000054BD                 mov     large fs:0, eax
.text$mn:000054C3                 mov     [ebp+var_10], ecx
.text$mn:000054C6                 mov     [ebp+var_4], 0
.text$mn:000054CD                 push    0               ; Size
.text$mn:000054CF                 push    1               ; char
.text$mn:000054D1                 mov     ecx, [ebp+var_10]
.text$mn:000054D4                 call    ?_Tidy@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEX_NI@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char>>::_Tidy(bool,uint)
.text$mn:000054D9                 mov     [ebp+var_4], 0FFFFFFFFh
.text$mn:000054E0                 mov     ecx, [ebp+var_10]
.text$mn:000054E3                 call    ??1?$_String_alloc@$0A@U?$_String_base_types@DV?$allocator@D@std@@@std@@@std@@QAE@XZ ; std::_String_alloc<0,std::_String_base_types<char,std::allocator<char>>>::~_String_alloc<0,std::_String_base_types<char,std::allocator<char>>>(void)
.text$mn:000054E8                 mov     ecx, [ebp+var_C]
.text$mn:000054EB                 mov     large fs:0, ecx
.text$mn:000054F2                 pop     ecx
.text$mn:000054F3                 mov     esp, ebp
.text$mn:000054F5                 pop     ebp
.text$mn:000054F6                 retn
.text$mn:000054F6 ??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ endp
.text$mn:000054F6
.text$mn:000054F6 ; ---------------------------------------------------------------------------
.text$mn:000054F7                 align 4
.text$mn:000054F7 _text$mn        ends
.text$mn:000054F7
.text$x:000054F8 ; ===========================================================================
.text$x:000054F8
.text$x:000054F8 ; Segment type: Pure code
.text$x:000054F8 ; Segment permissions: Read/Execute
.text$x:000054F8 _text$x         segment para public 'CODE' use32
.text$x:000054F8                 assume cs:_text$x
.text$x:000054F8                 ;org 54F8h
.text$x:000054F8 ; COMDAT (pick associative to section at 54A0)
.text$x:000054F8                 assume es:nothing, ss:nothing, ds:_data, fs:nothing, gs:nothing
.text$x:000054F8
.text$x:000054F8 ; =============== S U B R O U T I N E =======================================
.text$x:000054F8
.text$x:000054F8
.text$x:000054F8 __unwindfunclet$??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ$0 proc near
.text$x:000054F8                                         ; DATA XREF: .xdata$x:000093E4o
.text$x:000054F8                 mov     ecx, [ebp-10h]
.text$x:000054FB                 jmp     ??1?$_String_alloc@$0A@U?$_String_base_types@DV?$allocator@D@std@@@std@@@std@@QAE@XZ ; std::_String_alloc<0,std::_String_base_types<char,std::allocator<char>>>::~_String_alloc<0,std::_String_base_types<char,std::allocator<char>>>(void)
.text$x:000054FB __unwindfunclet$??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ$0 endp
.text$x:000054FB
.text$x:00005500
.text$x:00005500 ; =============== S U B R O U T I N E =======================================
.text$x:00005500
.text$x:00005500
.text$x:00005500 __ehhandler$??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ proc near
.text$x:00005500                                         ; DATA XREF: std::basic_string<char,std::char_traits<char>,std::allocator<char>>::~basic_string<char,std::char_traits<char>,std::allocator<char>>(void)+5o
.text$x:00005500
.text$x:00005500 arg_4           = dword ptr  8
.text$x:00005500
.text$x:00005500                 mov     edx, [esp+arg_4]
.text$x:00005504                 lea     eax, [edx+0Ch]
.text$x:00005507                 mov     ecx, [edx-8]
.text$x:0000550A                 xor     ecx, eax
.text$x:0000550C                 call    @__security_check_cookie@4 ; __security_check_cookie(x)
.text$x:00005511                 mov     eax, offset __ehfuncinfo$??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ
.text$x:00005516                 jmp     ___CxxFrameHandler3
.text$x:00005516 __ehhandler$??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ endp
.text$x:00005516
.text$x:00005516 ; ---------------------------------------------------------------------------
.text$x:0000551B                 align 4
.text$x:0000551B _text$x         ends
.text$x:0000551B
.text$mn:0000551C ; ===========================================================================
.text$mn:0000551C
.text$mn:0000551C ; Segment type: Pure code
.text$mn:0000551C ; Segment permissions: Read/Execute
.text$mn:0000551C _text$mn        segment para public 'CODE' use32
.text$mn:0000551C                 assume cs:_text$mn
.text$mn:0000551C                 ;org 551Ch
.text$mn:0000551C ; COMDAT (pick any)
.text$mn:0000551C                 assume es:nothing, ss:nothing, ds:_data, fs:nothing, gs:nothing
.text$mn:0000551C
.text$mn:0000551C ; =============== S U B R O U T I N E =======================================
.text$mn:0000551C
.text$mn:0000551C ; Attributes: bp-based frame
.text$mn:0000551C
.text$mn:0000551C ; public: __thiscall std::vector<wchar_t const *, class std::allocator<wchar_t const *>>::~vector<wchar_t const *, class std::allocator<wchar_t const *>>(void)
.text$mn:0000551C                 public ??1?$vector@PB_WV?$allocator@PB_W@std@@@std@@QAE@XZ
.text$mn:0000551C ??1?$vector@PB_WV?$allocator@PB_W@std@@@std@@QAE@XZ proc near
.text$mn:0000551C                                         ; CODE XREF: FunctionCallTip::loadFunction(void)+260p
.text$mn:0000551C                                         ; FunctionCallTip::loadFunction(void)+278p ...
.text$mn:0000551C
.text$mn:0000551C var_10          = dword ptr -10h
.text$mn:0000551C var_C           = dword ptr -0Ch
.text$mn:0000551C var_4           = dword ptr -4
.text$mn:0000551C
.text$mn:0000551C                 push    ebp
.text$mn:0000551D                 mov     ebp, esp
.text$mn:0000551F                 push    0FFFFFFFFh
.text$mn:00005521                 push    offset __ehhandler$??1?$vector@PB_WV?$allocator@PB_W@std@@@std@@QAE@XZ
.text$mn:00005526                 mov     eax, large fs:0
.text$mn:0000552C                 push    eax
.text$mn:0000552D                 push    ecx
.text$mn:0000552E                 mov     eax, dword ptr ds:___security_cookie
.text$mn:00005533                 xor     eax, ebp
.text$mn:00005535                 push    eax
.text$mn:00005536                 lea     eax, [ebp+var_C]
.text$mn:00005539                 mov     large fs:0, eax
.text$mn:0000553F                 mov     [ebp+var_10], ecx
.text$mn:00005542                 mov     [ebp+var_4], 0
.text$mn:00005549                 mov     ecx, [ebp+var_10]
.text$mn:0000554C                 call    ?_Tidy@?$vector@PB_WV?$allocator@PB_W@std@@@std@@IAEXXZ ; std::vector<wchar_t const *,std::allocator<wchar_t const *>>::_Tidy(void)
.text$mn:00005551                 mov     [ebp+var_4], 0FFFFFFFFh
.text$mn:00005558                 mov     ecx, [ebp+var_10]
.text$mn:0000555B                 call    ??1?$_Vector_alloc@$0A@U?$_Vec_base_types@PB_WV?$allocator@PB_W@std@@@std@@@std@@QAE@XZ ; std::_Vector_alloc<0,std::_Vec_base_types<wchar_t const *,std::allocator<wchar_t const *>>>::~_Vector_alloc<0,std::_Vec_base_types<wchar_t const *,std::allocator<wchar_t const *>>>(void)
.text$mn:00005560                 mov     ecx, [ebp+var_C]
.text$mn:00005563                 mov     large fs:0, ecx
.text$mn:0000556A                 pop     ecx
.text$mn:0000556B                 mov     esp, ebp
.text$mn:0000556D                 pop     ebp
.text$mn:0000556E                 retn
.text$mn:0000556E ??1?$vector@PB_WV?$allocator@PB_W@std@@@std@@QAE@XZ endp
.text$mn:0000556E
.text$mn:0000556E ; ---------------------------------------------------------------------------
.text$mn:0000556F                 align 10h
.text$mn:0000556F _text$mn        ends
.text$mn:0000556F
.text$x:00005570 ; ===========================================================================
.text$x:00005570
.text$x:00005570 ; Segment type: Pure code
.text$x:00005570 ; Segment permissions: Read/Execute
.text$x:00005570 _text$x         segment para public 'CODE' use32
.text$x:00005570                 assume cs:_text$x
.text$x:00005570                 ;org 5570h
.text$x:00005570 ; COMDAT (pick associative to section at 551C)
.text$x:00005570                 assume es:nothing, ss:nothing, ds:_data, fs:nothing, gs:nothing
.text$x:00005570
.text$x:00005570 ; =============== S U B R O U T I N E =======================================
.text$x:00005570
.text$x:00005570
.text$x:00005570 __unwindfunclet$??1?$vector@PB_WV?$allocator@PB_W@std@@@std@@QAE@XZ$0 proc near
.text$x:00005570                                         ; DATA XREF: .xdata$x:000097A0o
.text$x:00005570                 mov     ecx, [ebp-10h]
.text$x:00005573                 jmp     ??1?$_Vector_alloc@$0A@U?$_Vec_base_types@PB_WV?$allocator@PB_W@std@@@std@@@std@@QAE@XZ ; std::_Vector_alloc<0,std::_Vec_base_types<wchar_t const *,std::allocator<wchar_t const *>>>::~_Vector_alloc<0,std::_Vec_base_types<wchar_t const *,std::allocator<wchar_t const *>>>(void)
.text$x:00005573 __unwindfunclet$??1?$vector@PB_WV?$allocator@PB_W@std@@@std@@QAE@XZ$0 endp
.text$x:00005573
.text$x:00005578
.text$x:00005578 ; =============== S U B R O U T I N E =======================================
.text$x:00005578
.text$x:00005578
.text$x:00005578 __ehhandler$??1?$vector@PB_WV?$allocator@PB_W@std@@@std@@QAE@XZ proc near
.text$x:00005578                                         ; DATA XREF: std::vector<wchar_t const *,std::allocator<wchar_t const *>>::~vector<wchar_t const *,std::allocator<wchar_t const *>>(void)+5o
.text$x:00005578
.text$x:00005578 arg_4           = dword ptr  8
.text$x:00005578
.text$x:00005578                 mov     edx, [esp+arg_4]
.text$x:0000557C                 lea     eax, [edx+0Ch]
.text$x:0000557F                 mov     ecx, [edx-8]
.text$x:00005582                 xor     ecx, eax
.text$x:00005584                 call    @__security_check_cookie@4 ; __security_check_cookie(x)
.text$x:00005589                 mov     eax, offset __ehfuncinfo$??1?$vector@PB_WV?$allocator@PB_W@std@@@std@@QAE@XZ
.text$x:0000558E                 jmp     ___CxxFrameHandler3
.text$x:0000558E __ehhandler$??1?$vector@PB_WV?$allocator@PB_W@std@@@std@@QAE@XZ endp
.text$x:0000558E
.text$x:0000558E ; ---------------------------------------------------------------------------
.text$x:00005593                 align 4
.text$x:00005593 _text$x         ends
.text$x:00005593
.text$mn:00005594 ; ===========================================================================
.text$mn:00005594
.text$mn:00005594 ; Segment type: Pure code
.text$mn:00005594 ; Segment permissions: Read/Execute
.text$mn:00005594 _text$mn        segment para public 'CODE' use32
.text$mn:00005594                 assume cs:_text$mn
.text$mn:00005594                 ;org 5594h
.text$mn:00005594 ; COMDAT (pick any)
.text$mn:00005594                 assume es:nothing, ss:nothing, ds:_data, fs:nothing, gs:nothing
.text$mn:00005594
.text$mn:00005594 ; =============== S U B R O U T I N E =======================================
.text$mn:00005594
.text$mn:00005594 ; Attributes: bp-based frame
.text$mn:00005594
.text$mn:00005594 ; public: __thiscall std::vector<struct FunctionValues, class std::allocator<struct FunctionValues>>::~vector<struct FunctionValues, class std::allocator<struct FunctionValues>>(void)
.text$mn:00005594                 public ??1?$vector@UFunctionValues@@V?$allocator@UFunctionValues@@@std@@@std@@QAE@XZ
.text$mn:00005594 ??1?$vector@UFunctionValues@@V?$allocator@UFunctionValues@@@std@@@std@@QAE@XZ proc near
.text$mn:00005594                                         ; CODE XREF: FunctionCallTip::getCursorFunction(void)+803p
.text$mn:00005594                                         ; __unwindfunclet$?getCursorFunction@FunctionCallTip@@AAE_NXZ$1+6j
.text$mn:00005594
.text$mn:00005594 var_10          = dword ptr -10h
.text$mn:00005594 var_C           = dword ptr -0Ch
.text$mn:00005594 var_4           = dword ptr -4
.text$mn:00005594
.text$mn:00005594                 push    ebp
.text$mn:00005595                 mov     ebp, esp
.text$mn:00005597                 push    0FFFFFFFFh
.text$mn:00005599                 push    offset __ehhandler$??1?$vector@UFunctionValues@@V?$allocator@UFunctionValues@@@std@@@std@@QAE@XZ
.text$mn:0000559E                 mov     eax, large fs:0
.text$mn:000055A4                 push    eax
.text$mn:000055A5                 push    ecx
.text$mn:000055A6                 mov     eax, dword ptr ds:___security_cookie
.text$mn:000055AB                 xor     eax, ebp
.text$mn:000055AD                 push    eax
.text$mn:000055AE                 lea     eax, [ebp+var_C]
.text$mn:000055B1                 mov     large fs:0, eax
.text$mn:000055B7                 mov     [ebp+var_10], ecx
.text$mn:000055BA                 mov     [ebp+var_4], 0
.text$mn:000055C1                 mov     ecx, [ebp+var_10]
.text$mn:000055C4                 call    ?_Tidy@?$vector@UFunctionValues@@V?$allocator@UFunctionValues@@@std@@@std@@IAEXXZ ; std::vector<FunctionValues,std::allocator<FunctionValues>>::_Tidy(void)
.text$mn:000055C9                 mov     [ebp+var_4], 0FFFFFFFFh
.text$mn:000055D0                 mov     ecx, [ebp+var_10]
.text$mn:000055D3                 call    ??1?$_Vector_alloc@$0A@U?$_Vec_base_types@UFunctionValues@@V?$allocator@UFunctionValues@@@std@@@std@@@std@@QAE@XZ ; std::_Vector_alloc<0,std::_Vec_base_types<FunctionValues,std::allocator<FunctionValues>>>::~_Vector_alloc<0,std::_Vec_base_types<FunctionValues,std::allocator<FunctionValues>>>(void)
.text$mn:000055D8                 mov     ecx, [ebp+var_C]
.text$mn:000055DB                 mov     large fs:0, ecx
.text$mn:000055E2                 pop     ecx
.text$mn:000055E3                 mov     esp, ebp
.text$mn:000055E5                 pop     ebp
.text$mn:000055E6                 retn
.text$mn:000055E6 ??1?$vector@UFunctionValues@@V?$allocator@UFunctionValues@@@std@@@std@@QAE@XZ endp
.text$mn:000055E6
.text$mn:000055E6 ; ---------------------------------------------------------------------------
.text$mn:000055E7                 align 4
.text$mn:000055E7 _text$mn        ends
.text$mn:000055E7
.text$x:000055E8 ; ===========================================================================
.text$x:000055E8
.text$x:000055E8 ; Segment type: Pure code
.text$x:000055E8 ; Segment permissions: Read/Execute
.text$x:000055E8 _text$x         segment para public 'CODE' use32
.text$x:000055E8                 assume cs:_text$x
.text$x:000055E8                 ;org 55E8h
.text$x:000055E8 ; COMDAT (pick associative to section at 5594)
.text$x:000055E8                 assume es:nothing, ss:nothing, ds:_data, fs:nothing, gs:nothing
.text$x:000055E8
.text$x:000055E8 ; =============== S U B R O U T I N E =======================================
.text$x:000055E8
.text$x:000055E8
.text$x:000055E8 __unwindfunclet$??1?$vector@UFunctionValues@@V?$allocator@UFunctionValues@@@std@@@std@@QAE@XZ$0 proc near
.text$x:000055E8                                         ; DATA XREF: .xdata$x:00009C20o
.text$x:000055E8                 mov     ecx, [ebp-10h]
.text$x:000055EB                 jmp     ??1?$_Vector_alloc@$0A@U?$_Vec_base_types@UFunctionValues@@V?$allocator@UFunctionValues@@@std@@@std@@@std@@QAE@XZ ; std::_Vector_alloc<0,std::_Vec_base_types<FunctionValues,std::allocator<FunctionValues>>>::~_Vector_alloc<0,std::_Vec_base_types<FunctionValues,std::allocator<FunctionValues>>>(void)
.text$x:000055EB __unwindfunclet$??1?$vector@UFunctionValues@@V?$allocator@UFunctionValues@@@std@@@std@@QAE@XZ$0 endp
.text$x:000055EB
.text$x:000055F0
.text$x:000055F0 ; =============== S U B R O U T I N E =======================================
.text$x:000055F0
.text$x:000055F0
.text$x:000055F0 __ehhandler$??1?$vector@UFunctionValues@@V?$allocator@UFunctionValues@@@std@@@std@@QAE@XZ proc near
.text$x:000055F0                                         ; DATA XREF: std::vector<FunctionValues,std::allocator<FunctionValues>>::~vector<FunctionValues,std::allocator<FunctionValues>>(void)+5o
.text$x:000055F0
.text$x:000055F0 arg_4           = dword ptr  8
.text$x:000055F0
.text$x:000055F0                 mov     edx, [esp+arg_4]
.text$x:000055F4                 lea     eax, [edx+0Ch]
.text$x:000055F7                 mov     ecx, [edx-8]
.text$x:000055FA                 xor     ecx, eax
.text$x:000055FC                 call    @__security_check_cookie@4 ; __security_check_cookie(x)
.text$x:00005601                 mov     eax, offset __ehfuncinfo$??1?$vector@UFunctionValues@@V?$allocator@UFunctionValues@@@std@@@std@@QAE@XZ
.text$x:00005606                 jmp     ___CxxFrameHandler3
.text$x:00005606 __ehhandler$??1?$vector@UFunctionValues@@V?$allocator@UFunctionValues@@@std@@@std@@QAE@XZ endp
.text$x:00005606
.text$x:00005606 ; ---------------------------------------------------------------------------
.text$x:0000560B                 align 4
.text$x:0000560B _text$x         ends
.text$x:0000560B
.text$mn:0000560C ; ===========================================================================
.text$mn:0000560C
.text$mn:0000560C ; Segment type: Pure code
.text$mn:0000560C ; Segment permissions: Read/Execute
.text$mn:0000560C _text$mn        segment para public 'CODE' use32
.text$mn:0000560C                 assume cs:_text$mn
.text$mn:0000560C                 ;org 560Ch
.text$mn:0000560C ; COMDAT (pick any)
.text$mn:0000560C                 assume es:nothing, ss:nothing, ds:_data, fs:nothing, gs:nothing
.text$mn:0000560C
.text$mn:0000560C ; =============== S U B R O U T I N E =======================================
.text$mn:0000560C
.text$mn:0000560C ; Attributes: bp-based frame
.text$mn:0000560C
.text$mn:0000560C ; public: __thiscall std::vector<struct Token, class std::allocator<struct Token>>::~vector<struct Token, class std::allocator<struct Token>>(void)
.text$mn:0000560C                 public ??1?$vector@UToken@@V?$allocator@UToken@@@std@@@std@@QAE@XZ
.text$mn:0000560C ??1?$vector@UToken@@V?$allocator@UToken@@@std@@@std@@QAE@XZ proc near
.text$mn:0000560C                                         ; CODE XREF: FunctionCallTip::getCursorFunction(void)+815p
.text$mn:0000560C                                         ; __unwindfunclet$?getCursorFunction@FunctionCallTip@@AAE_NXZ$0+6j
.text$mn:0000560C
.text$mn:0000560C var_10          = dword ptr -10h
.text$mn:0000560C var_C           = dword ptr -0Ch
.text$mn:0000560C var_4           = dword ptr -4
.text$mn:0000560C
.text$mn:0000560C                 push    ebp
.text$mn:0000560D                 mov     ebp, esp
.text$mn:0000560F                 push    0FFFFFFFFh
.text$mn:00005611                 push    offset __ehhandler$??1?$vector@UToken@@V?$allocator@UToken@@@std@@@std@@QAE@XZ
.text$mn:00005616                 mov     eax, large fs:0
.text$mn:0000561C                 push    eax
.text$mn:0000561D                 push    ecx
.text$mn:0000561E                 mov     eax, dword ptr ds:___security_cookie
.text$mn:00005623                 xor     eax, ebp
.text$mn:00005625                 push    eax
.text$mn:00005626                 lea     eax, [ebp+var_C]
.text$mn:00005629                 mov     large fs:0, eax
.text$mn:0000562F                 mov     [ebp+var_10], ecx
.text$mn:00005632                 mov     [ebp+var_4], 0
.text$mn:00005639                 mov     ecx, [ebp+var_10]
.text$mn:0000563C                 call    ?_Tidy@?$vector@UToken@@V?$allocator@UToken@@@std@@@std@@IAEXXZ ; std::vector<Token,std::allocator<Token>>::_Tidy(void)
.text$mn:00005641                 mov     [ebp+var_4], 0FFFFFFFFh
.text$mn:00005648                 mov     ecx, [ebp+var_10]
.text$mn:0000564B                 call    ??1?$_Vector_alloc@$0A@U?$_Vec_base_types@UToken@@V?$allocator@UToken@@@std@@@std@@@std@@QAE@XZ ; std::_Vector_alloc<0,std::_Vec_base_types<Token,std::allocator<Token>>>::~_Vector_alloc<0,std::_Vec_base_types<Token,std::allocator<Token>>>(void)
.text$mn:00005650                 mov     ecx, [ebp+var_C]
.text$mn:00005653                 mov     large fs:0, ecx
.text$mn:0000565A                 pop     ecx
.text$mn:0000565B                 mov     esp, ebp
.text$mn:0000565D                 pop     ebp
.text$mn:0000565E                 retn
.text$mn:0000565E ??1?$vector@UToken@@V?$allocator@UToken@@@std@@@std@@QAE@XZ endp
.text$mn:0000565E
.text$mn:0000565E ; ---------------------------------------------------------------------------
.text$mn:0000565F                 align 10h
.text$mn:0000565F _text$mn        ends
.text$mn:0000565F
.text$x:00005660 ; ===========================================================================
.text$x:00005660
.text$x:00005660 ; Segment type: Pure code
.text$x:00005660 ; Segment permissions: Read/Execute
.text$x:00005660 _text$x         segment para public 'CODE' use32
.text$x:00005660                 assume cs:_text$x
.text$x:00005660                 ;org 5660h
.text$x:00005660 ; COMDAT (pick associative to section at 560C)
.text$x:00005660                 assume es:nothing, ss:nothing, ds:_data, fs:nothing, gs:nothing
.text$x:00005660
.text$x:00005660 ; =============== S U B R O U T I N E =======================================
.text$x:00005660
.text$x:00005660
.text$x:00005660 __unwindfunclet$??1?$vector@UToken@@V?$allocator@UToken@@@std@@@std@@QAE@XZ$0 proc near
.text$x:00005660                                         ; DATA XREF: .xdata$x:00009A94o
.text$x:00005660                 mov     ecx, [ebp-10h]
.text$x:00005663                 jmp     ??1?$_Vector_alloc@$0A@U?$_Vec_base_types@UToken@@V?$allocator@UToken@@@std@@@std@@@std@@QAE@XZ ; std::_Vector_alloc<0,std::_Vec_base_types<Token,std::allocator<Token>>>::~_Vector_alloc<0,std::_Vec_base_types<Token,std::allocator<Token>>>(void)
.text$x:00005663 __unwindfunclet$??1?$vector@UToken@@V?$allocator@UToken@@@std@@@std@@QAE@XZ$0 endp
.text$x:00005663
.text$x:00005668
.text$x:00005668 ; =============== S U B R O U T I N E =======================================
.text$x:00005668
.text$x:00005668
.text$x:00005668 __ehhandler$??1?$vector@UToken@@V?$allocator@UToken@@@std@@@std@@QAE@XZ proc near
.text$x:00005668                                         ; DATA XREF: std::vector<Token,std::allocator<Token>>::~vector<Token,std::allocator<Token>>(void)+5o
.text$x:00005668
.text$x:00005668 arg_4           = dword ptr  8
.text$x:00005668
.text$x:00005668                 mov     edx, [esp+arg_4]
.text$x:0000566C                 lea     eax, [edx+0Ch]
.text$x:0000566F                 mov     ecx, [edx-8]
.text$x:00005672                 xor     ecx, eax
.text$x:00005674                 call    @__security_check_cookie@4 ; __security_check_cookie(x)
.text$x:00005679                 mov     eax, offset __ehfuncinfo$??1?$vector@UToken@@V?$allocator@UToken@@@std@@@std@@QAE@XZ
.text$x:0000567E                 jmp     ___CxxFrameHandler3
.text$x:0000567E __ehhandler$??1?$vector@UToken@@V?$allocator@UToken@@@std@@@std@@QAE@XZ endp
.text$x:0000567E
.text$x:0000567E ; ---------------------------------------------------------------------------
.text$x:00005683                 align 4
.text$x:00005683 _text$x         ends
.text$x:00005683
.text$mn:00005684 ; ===========================================================================
.text$mn:00005684
.text$mn:00005684 ; Segment type: Pure code
.text$mn:00005684 ; Segment permissions: Read/Execute
.text$mn:00005684 _text$mn        segment para public 'CODE' use32
.text$mn:00005684                 assume cs:_text$mn
.text$mn:00005684                 ;org 5684h
.text$mn:00005684 ; COMDAT (pick any)
.text$mn:00005684                 assume es:nothing, ss:nothing, ds:_data, fs:nothing, gs:nothing
.text$mn:00005684
.text$mn:00005684 ; =============== S U B R O U T I N E =======================================
.text$mn:00005684
.text$mn:00005684 ; Attributes: bp-based frame
.text$mn:00005684
.text$mn:00005684 ; _DWORD __thiscall std::_Container_base12::~_Container_base12(std::_Container_base12 *__hidden this)
.text$mn:00005684                 public ??1_Container_base12@std@@QAE@XZ
.text$mn:00005684 ??1_Container_base12@std@@QAE@XZ proc near
.text$mn:00005684                                         ; CODE XREF: __unwindfunclet$??0?$_String_val@U?$_Simple_types@D@std@@@std@@QAE@XZ$0+3j
.text$mn:00005684                                         ; __unwindfunclet$??0?$_Vector_val@U?$_Simple_types@PB_W@std@@@std@@QAE@XZ$0+3j ...
.text$mn:00005684
.text$mn:00005684 var_4           = dword ptr -4
.text$mn:00005684
.text$mn:00005684                 push    ebp
.text$mn:00005685                 mov     ebp, esp
.text$mn:00005687                 push    ecx
.text$mn:00005688                 mov     [ebp+var_4], ecx
.text$mn:0000568B                 mov     ecx, [ebp+var_4] ; this
.text$mn:0000568E                 call    ?_Orphan_all@_Container_base12@std@@QAEXXZ ; std::_Container_base12::_Orphan_all(void)
.text$mn:00005693                 mov     esp, ebp
.text$mn:00005695                 pop     ebp
.text$mn:00005696                 retn
.text$mn:00005696 ??1_Container_base12@std@@QAE@XZ endp
.text$mn:00005696
.text$mn:00005696 ; ---------------------------------------------------------------------------
.text$mn:00005697                 align 4
.text$mn:00005697 _text$mn        ends
.text$mn:00005697
.text$mn:00005698 ; ===========================================================================
.text$mn:00005698
.text$mn:00005698 ; Segment type: Pure code
.text$mn:00005698 ; Segment permissions: Read/Execute
.text$mn:00005698 _text$mn        segment para public 'CODE' use32
.text$mn:00005698                 assume cs:_text$mn
.text$mn:00005698                 ;org 5698h
.text$mn:00005698 ; COMDAT (pick any)
.text$mn:00005698                 assume es:nothing, ss:nothing, ds:_data, fs:nothing, gs:nothing
.text$mn:00005698
.text$mn:00005698 ; =============== S U B R O U T I N E =======================================
.text$mn:00005698
.text$mn:00005698 ; Attributes: bp-based frame
.text$mn:00005698
.text$mn:00005698 ; _DWORD __thiscall std::_Generic_error_category::~_Generic_error_category(std::_Generic_error_category *__hidden this)
.text$mn:00005698                 public ??1_Generic_error_category@std@@UAE@XZ
.text$mn:00005698 ??1_Generic_error_category@std@@UAE@XZ proc near
.text$mn:00005698                                         ; CODE XREF: __unwindfunclet$??0_Iostream_error_category@std@@QAE@XZ$0+3j
.text$mn:00005698                                         ; __unwindfunclet$??0_System_error_category@std@@QAE@XZ$0+3j ...
.text$mn:00005698
.text$mn:00005698 var_10          = dword ptr -10h
.text$mn:00005698 var_C           = dword ptr -0Ch
.text$mn:00005698 var_4           = dword ptr -4
.text$mn:00005698
.text$mn:00005698                 push    ebp
.text$mn:00005699                 mov     ebp, esp
.text$mn:0000569B                 push    0FFFFFFFFh
.text$mn:0000569D                 push    offset __ehhandler$??1_Generic_error_category@std@@UAE@XZ
.text$mn:000056A2                 mov     eax, large fs:0
.text$mn:000056A8                 push    eax
.text$mn:000056A9                 push    ecx
.text$mn:000056AA                 mov     eax, dword ptr ds:___security_cookie
.text$mn:000056AF                 xor     eax, ebp
.text$mn:000056B1                 push    eax
.text$mn:000056B2                 lea     eax, [ebp+var_C]
.text$mn:000056B5                 mov     large fs:0, eax
.text$mn:000056BB                 mov     [ebp+var_10], ecx
.text$mn:000056BE                 mov     [ebp+var_4], 0
.text$mn:000056C5                 mov     [ebp+var_4], 0FFFFFFFFh
.text$mn:000056CC                 mov     ecx, [ebp+var_10] ; this
.text$mn:000056CF                 call    ??1error_category@std@@UAE@XZ ; std::error_category::~error_category(void)
.text$mn:000056D4                 mov     ecx, [ebp+var_C]
.text$mn:000056D7                 mov     large fs:0, ecx
.text$mn:000056DE                 pop     ecx
.text$mn:000056DF                 mov     esp, ebp
.text$mn:000056E1                 pop     ebp
.text$mn:000056E2                 retn
.text$mn:000056E2 ??1_Generic_error_category@std@@UAE@XZ endp
.text$mn:000056E2
.text$mn:000056E2 ; ---------------------------------------------------------------------------
.text$mn:000056E3                 align 4
.text$mn:000056E3 _text$mn        ends
.text$mn:000056E3
.text$x:000056E4 ; ===========================================================================
.text$x:000056E4
.text$x:000056E4 ; Segment type: Pure code
.text$x:000056E4 ; Segment permissions: Read/Execute
.text$x:000056E4 _text$x         segment para public 'CODE' use32
.text$x:000056E4                 assume cs:_text$x
.text$x:000056E4                 ;org 56E4h
.text$x:000056E4 ; COMDAT (pick associative to section at 5698)
.text$x:000056E4                 assume es:nothing, ss:nothing, ds:_data, fs:nothing, gs:nothing
.text$x:000056E4
.text$x:000056E4 ; =============== S U B R O U T I N E =======================================
.text$x:000056E4
.text$x:000056E4
.text$x:000056E4 __unwindfunclet$??1_Generic_error_category@std@@UAE@XZ$0 proc near
.text$x:000056E4                                         ; DATA XREF: .xdata$x:000094F4o
.text$x:000056E4                 mov     ecx, [ebp-10h]  ; this
.text$x:000056E7                 jmp     ??1error_category@std@@UAE@XZ ; std::error_category::~error_category(void)
.text$x:000056E7 __unwindfunclet$??1_Generic_error_category@std@@UAE@XZ$0 endp
.text$x:000056E7
.text$x:000056EC
.text$x:000056EC ; =============== S U B R O U T I N E =======================================
.text$x:000056EC
.text$x:000056EC
.text$x:000056EC __ehhandler$??1_Generic_error_category@std@@UAE@XZ proc near
.text$x:000056EC                                         ; DATA XREF: std::_Generic_error_category::~_Generic_error_category(void)+5o
.text$x:000056EC
.text$x:000056EC arg_4           = dword ptr  8
.text$x:000056EC
.text$x:000056EC                 mov     edx, [esp+arg_4]
.text$x:000056F0                 lea     eax, [edx+0Ch]
.text$x:000056F3                 mov     ecx, [edx-8]
.text$x:000056F6                 xor     ecx, eax
.text$x:000056F8                 call    @__security_check_cookie@4 ; __security_check_cookie(x)
.text$x:000056FD                 mov     eax, offset __ehfuncinfo$??1_Generic_error_category@std@@UAE@XZ
.text$x:00005702                 jmp     ___CxxFrameHandler3
.text$x:00005702 __ehhandler$??1_Generic_error_category@std@@UAE@XZ endp
.text$x:00005702
.text$x:00005702 ; ---------------------------------------------------------------------------
.text$x:00005707                 align 4
.text$x:00005707 _text$x         ends
.text$x:00005707
.text$mn:00005708 ; ===========================================================================
.text$mn:00005708
.text$mn:00005708 ; Segment type: Pure code
.text$mn:00005708 ; Segment permissions: Read/Execute
.text$mn:00005708 _text$mn        segment para public 'CODE' use32
.text$mn:00005708                 assume cs:_text$mn
.text$mn:00005708                 ;org 5708h
.text$mn:00005708 ; COMDAT (pick any)
.text$mn:00005708                 assume es:nothing, ss:nothing, ds:_data, fs:nothing, gs:nothing
.text$mn:00005708
.text$mn:00005708 ; =============== S U B R O U T I N E =======================================
.text$mn:00005708
.text$mn:00005708 ; Attributes: bp-based frame
.text$mn:00005708
.text$mn:00005708 ; _DWORD __thiscall std::_Iostream_error_category::~_Iostream_error_category(std::_Iostream_error_category *__hidden this)
.text$mn:00005708                 public ??1_Iostream_error_category@std@@UAE@XZ
.text$mn:00005708 ??1_Iostream_error_category@std@@UAE@XZ proc near
.text$mn:00005708                                         ; CODE XREF: std::_Iostream_error_category::`scalar deleting destructor'(uint)+Ap
.text$mn:00005708                                         ; `dynamic atexit destructor for 'std::_Iostream_error_category std::_Error_objects<int>::_Iostream_object''(void)+8p
.text$mn:00005708
.text$mn:00005708 var_10          = dword ptr -10h
.text$mn:00005708 var_C           = dword ptr -0Ch
.text$mn:00005708 var_4           = dword ptr -4
.text$mn:00005708
.text$mn:00005708                 push    ebp
.text$mn:00005709                 mov     ebp, esp
.text$mn:0000570B                 push    0FFFFFFFFh
.text$mn:0000570D                 push    offset __ehhandler$??1_Iostream_error_category@std@@UAE@XZ
.text$mn:00005712                 mov     eax, large fs:0
.text$mn:00005718                 push    eax
.text$mn:00005719                 push    ecx
.text$mn:0000571A                 mov     eax, dword ptr ds:___security_cookie
.text$mn:0000571F                 xor     eax, ebp
.text$mn:00005721                 push    eax
.text$mn:00005722                 lea     eax, [ebp+var_C]
.text$mn:00005725                 mov     large fs:0, eax
.text$mn:0000572B                 mov     [ebp+var_10], ecx
.text$mn:0000572E                 mov     [ebp+var_4], 0
.text$mn:00005735                 mov     [ebp+var_4], 0FFFFFFFFh
.text$mn:0000573C                 mov     ecx, [ebp+var_10] ; this
.text$mn:0000573F                 call    ??1_Generic_error_category@std@@UAE@XZ ; std::_Generic_error_category::~_Generic_error_category(void)
.text$mn:00005744                 mov     ecx, [ebp+var_C]
.text$mn:00005747                 mov     large fs:0, ecx
.text$mn:0000574E                 pop     ecx
.text$mn:0000574F                 mov     esp, ebp
.text$mn:00005751                 pop     ebp
.text$mn:00005752                 retn
.text$mn:00005752 ??1_Iostream_error_category@std@@UAE@XZ endp
.text$mn:00005752
.text$mn:00005752 ; ---------------------------------------------------------------------------
.text$mn:00005753                 align 4
.text$mn:00005753 _text$mn        ends
.text$mn:00005753
.text$x:00005754 ; ===========================================================================
.text$x:00005754
.text$x:00005754 ; Segment type: Pure code
.text$x:00005754 ; Segment permissions: Read/Execute
.text$x:00005754 _text$x         segment para public 'CODE' use32
.text$x:00005754                 assume cs:_text$x
.text$x:00005754                 ;org 5754h
.text$x:00005754 ; COMDAT (pick associative to section at 5708)
.text$x:00005754                 assume es:nothing, ss:nothing, ds:_data, fs:nothing, gs:nothing
.text$x:00005754
.text$x:00005754 ; =============== S U B R O U T I N E =======================================
.text$x:00005754
.text$x:00005754
.text$x:00005754 __unwindfunclet$??1_Iostream_error_category@std@@UAE@XZ$0 proc near
.text$x:00005754                                         ; DATA XREF: .xdata$x:00009578o
.text$x:00005754                 mov     ecx, [ebp-10h]  ; this
.text$x:00005757                 jmp     ??1_Generic_error_category@std@@UAE@XZ ; std::_Generic_error_category::~_Generic_error_category(void)
.text$x:00005757 __unwindfunclet$??1_Iostream_error_category@std@@UAE@XZ$0 endp
.text$x:00005757
.text$x:0000575C
.text$x:0000575C ; =============== S U B R O U T I N E =======================================
.text$x:0000575C
.text$x:0000575C
.text$x:0000575C __ehhandler$??1_Iostream_error_category@std@@UAE@XZ proc near
.text$x:0000575C                                         ; DATA XREF: std::_Iostream_error_category::~_Iostream_error_category(void)+5o
.text$x:0000575C
.text$x:0000575C arg_4           = dword ptr  8
.text$x:0000575C
.text$x:0000575C                 mov     edx, [esp+arg_4]
.text$x:00005760                 lea     eax, [edx+0Ch]
.text$x:00005763                 mov     ecx, [edx-8]
.text$x:00005766                 xor     ecx, eax
.text$x:00005768                 call    @__security_check_cookie@4 ; __security_check_cookie(x)
.text$x:0000576D                 mov     eax, offset __ehfuncinfo$??1_Iostream_error_category@std@@UAE@XZ
.text$x:00005772                 jmp     ___CxxFrameHandler3
.text$x:00005772 __ehhandler$??1_Iostream_error_category@std@@UAE@XZ endp
.text$x:00005772
.text$x:00005772 ; ---------------------------------------------------------------------------
.text$x:00005777                 align 4
.text$x:00005777 _text$x         ends
.text$x:00005777
.text$mn:00005778 ; ===========================================================================
.text$mn:00005778
.text$mn:00005778 ; Segment type: Pure code
.text$mn:00005778 ; Segment permissions: Read/Execute
.text$mn:00005778 _text$mn        segment para public 'CODE' use32
.text$mn:00005778                 assume cs:_text$mn
.text$mn:00005778                 ;org 5778h
.text$mn:00005778 ; COMDAT (pick any)
.text$mn:00005778                 assume es:nothing, ss:nothing, ds:_data, fs:nothing, gs:nothing
.text$mn:00005778
.text$mn:00005778 ; =============== S U B R O U T I N E =======================================
.text$mn:00005778
.text$mn:00005778 ; Attributes: bp-based frame
.text$mn:00005778
.text$mn:00005778 ; _DWORD __thiscall std::_Iterator_base12::~_Iterator_base12(std::_Iterator_base12 *__hidden this)
.text$mn:00005778                 public ??1_Iterator_base12@std@@QAE@XZ
.text$mn:00005778 ??1_Iterator_base12@std@@QAE@XZ proc near
.text$mn:00005778                                         ; CODE XREF: __unwindfunclet$??0?$_Iterator012@Urandom_access_iterator_tag@std@@PB_WHPBQB_WABQB_WU_Iterator_base12@2@@std@@QAE@ABU01@@Z$0+3j
.text$mn:00005778                                         ; __unwindfunclet$??0?$_Iterator012@Urandom_access_iterator_tag@std@@PB_WHPBQB_WABQB_WU_Iterator_base12@2@@std@@QAE@XZ$0+3j ...
.text$mn:00005778
.text$mn:00005778 var_14          = byte ptr -14h
.text$mn:00005778 var_10          = dword ptr -10h
.text$mn:00005778 var_C           = dword ptr -0Ch
.text$mn:00005778 var_4           = dword ptr -4
.text$mn:00005778
.text$mn:00005778                 push    ebp
.text$mn:00005779                 mov     ebp, esp
.text$mn:0000577B                 push    0FFFFFFFFh
.text$mn:0000577D                 push    offset __ehhandler$??1_Iterator_base12@std@@QAE@XZ
.text$mn:00005782                 mov     eax, large fs:0
.text$mn:00005788                 push    eax
.text$mn:00005789                 sub     esp, 8
.text$mn:0000578C                 mov     eax, dword ptr ds:___security_cookie
.text$mn:00005791                 xor     eax, ebp
.text$mn:00005793                 push    eax
.text$mn:00005794                 lea     eax, [ebp+var_C]
.text$mn:00005797                 mov     large fs:0, eax
.text$mn:0000579D                 mov     [ebp+var_10], ecx
.text$mn:000057A0                 push    3               ; int
.text$mn:000057A2                 lea     ecx, [ebp+var_14] ; this
.text$mn:000057A5                 call    ??0_Lockit@std@@QAE@H@Z ; std::_Lockit::_Lockit(int)
.text$mn:000057AA                 mov     [ebp+var_4], 0
.text$mn:000057B1                 mov     ecx, [ebp+var_10] ; this
.text$mn:000057B4                 call    ?_Orphan_me@_Iterator_base12@std@@QAEXXZ ; std::_Iterator_base12::_Orphan_me(void)
.text$mn:000057B9                 mov     [ebp+var_4], 0FFFFFFFFh
.text$mn:000057C0                 lea     ecx, [ebp+var_14] ; this
.text$mn:000057C3                 call    ??1_Lockit@std@@QAE@XZ ; std::_Lockit::~_Lockit(void)
.text$mn:000057C8                 mov     ecx, [ebp+var_C]
.text$mn:000057CB                 mov     large fs:0, ecx
.text$mn:000057D2                 pop     ecx
.text$mn:000057D3                 mov     esp, ebp
.text$mn:000057D5                 pop     ebp
.text$mn:000057D6                 retn
.text$mn:000057D6 ??1_Iterator_base12@std@@QAE@XZ endp
.text$mn:000057D6
.text$mn:000057D6 ; ---------------------------------------------------------------------------
.text$mn:000057D7                 align 4
.text$mn:000057D7 _text$mn        ends
.text$mn:000057D7
.text$x:000057D8 ; ===========================================================================
.text$x:000057D8
.text$x:000057D8 ; Segment type: Pure code
.text$x:000057D8 ; Segment permissions: Read/Execute
.text$x:000057D8 _text$x         segment para public 'CODE' use32
.text$x:000057D8                 assume cs:_text$x
.text$x:000057D8                 ;org 57D8h
.text$x:000057D8 ; COMDAT (pick associative to section at 5778)
.text$x:000057D8                 assume es:nothing, ss:nothing, ds:_data, fs:nothing, gs:nothing
.text$x:000057D8
.text$x:000057D8 ; =============== S U B R O U T I N E =======================================
.text$x:000057D8
.text$x:000057D8
.text$x:000057D8 __unwindfunclet$??1_Iterator_base12@std@@QAE@XZ$0 proc near
.text$x:000057D8                                         ; DATA XREF: .xdata$x:000092A8o
.text$x:000057D8                 lea     ecx, [ebp-14h]  ; this
.text$x:000057DB                 jmp     ??1_Lockit@std@@QAE@XZ ; std::_Lockit::~_Lockit(void)
.text$x:000057DB __unwindfunclet$??1_Iterator_base12@std@@QAE@XZ$0 endp
.text$x:000057DB
.text$x:000057E0
.text$x:000057E0 ; =============== S U B R O U T I N E =======================================
.text$x:000057E0
.text$x:000057E0
.text$x:000057E0 __ehhandler$??1_Iterator_base12@std@@QAE@XZ proc near
.text$x:000057E0                                         ; DATA XREF: std::_Iterator_base12::~_Iterator_base12(void)+5o
.text$x:000057E0
.text$x:000057E0 arg_4           = dword ptr  8
.text$x:000057E0
.text$x:000057E0                 mov     edx, [esp+arg_4]
.text$x:000057E4                 lea     eax, [edx+0Ch]
.text$x:000057E7                 mov     ecx, [edx-0Ch]
.text$x:000057EA                 xor     ecx, eax
.text$x:000057EC                 call    @__security_check_cookie@4 ; __security_check_cookie(x)
.text$x:000057F1                 mov     eax, offset __ehfuncinfo$??1_Iterator_base12@std@@QAE@XZ
.text$x:000057F6                 jmp     ___CxxFrameHandler3
.text$x:000057F6 __ehhandler$??1_Iterator_base12@std@@QAE@XZ endp
.text$x:000057F6
.text$x:000057F6 ; ---------------------------------------------------------------------------
.text$x:000057FB                 align 4
.text$x:000057FB _text$x         ends
.text$x:000057FB
.text$mn:000057FC ; ===========================================================================
.text$mn:000057FC
.text$mn:000057FC ; Segment type: Pure code
.text$mn:000057FC ; Segment permissions: Read/Execute
.text$mn:000057FC _text$mn        segment para public 'CODE' use32
.text$mn:000057FC                 assume cs:_text$mn
.text$mn:000057FC                 ;org 57FCh
.text$mn:000057FC ; COMDAT (pick any)
.text$mn:000057FC                 assume es:nothing, ss:nothing, ds:_data, fs:nothing, gs:nothing
.text$mn:000057FC
.text$mn:000057FC ; =============== S U B R O U T I N E =======================================
.text$mn:000057FC
.text$mn:000057FC ; Attributes: bp-based frame
.text$mn:000057FC
.text$mn:000057FC ; _DWORD __thiscall std::_System_error_category::~_System_error_category(std::_System_error_category *__hidden this)
.text$mn:000057FC                 public ??1_System_error_category@std@@UAE@XZ
.text$mn:000057FC ??1_System_error_category@std@@UAE@XZ proc near
.text$mn:000057FC                                         ; CODE XREF: std::_System_error_category::`scalar deleting destructor'(uint)+Ap
.text$mn:000057FC                                         ; `dynamic atexit destructor for 'std::_System_error_category std::_Error_objects<int>::_System_object''(void)+8p
.text$mn:000057FC
.text$mn:000057FC var_10          = dword ptr -10h
.text$mn:000057FC var_C           = dword ptr -0Ch
.text$mn:000057FC var_4           = dword ptr -4
.text$mn:000057FC
.text$mn:000057FC                 push    ebp
.text$mn:000057FD                 mov     ebp, esp
.text$mn:000057FF                 push    0FFFFFFFFh
.text$mn:00005801                 push    offset __ehhandler$??1_System_error_category@std@@UAE@XZ
.text$mn:00005806                 mov     eax, large fs:0
.text$mn:0000580C                 push    eax
.text$mn:0000580D                 push    ecx
.text$mn:0000580E                 mov     eax, dword ptr ds:___security_cookie
.text$mn:00005813                 xor     eax, ebp
.text$mn:00005815                 push    eax
.text$mn:00005816                 lea     eax, [ebp+var_C]
.text$mn:00005819                 mov     large fs:0, eax
.text$mn:0000581F                 mov     [ebp+var_10], ecx
.text$mn:00005822                 mov     [ebp+var_4], 0
.text$mn:00005829                 mov     [ebp+var_4], 0FFFFFFFFh
.text$mn:00005830                 mov     ecx, [ebp+var_10] ; this
.text$mn:00005833                 call    ??1_Generic_error_category@std@@UAE@XZ ; std::_Generic_error_category::~_Generic_error_category(void)
.text$mn:00005838                 mov     ecx, [ebp+var_C]
.text$mn:0000583B                 mov     large fs:0, ecx
.text$mn:00005842                 pop     ecx
.text$mn:00005843                 mov     esp, ebp
.text$mn:00005845                 pop     ebp
.text$mn:00005846                 retn
.text$mn:00005846 ??1_System_error_category@std@@UAE@XZ endp
.text$mn:00005846
.text$mn:00005846 ; ---------------------------------------------------------------------------
.text$mn:00005847                 align 4
.text$mn:00005847 _text$mn        ends
.text$mn:00005847
.text$x:00005848 ; ===========================================================================
.text$x:00005848
.text$x:00005848 ; Segment type: Pure code
.text$x:00005848 ; Segment permissions: Read/Execute
.text$x:00005848 _text$x         segment para public 'CODE' use32
.text$x:00005848                 assume cs:_text$x
.text$x:00005848                 ;org 5848h
.text$x:00005848 ; COMDAT (pick associative to section at 57FC)
.text$x:00005848                 assume es:nothing, ss:nothing, ds:_data, fs:nothing, gs:nothing
.text$x:00005848
.text$x:00005848 ; =============== S U B R O U T I N E =======================================
.text$x:00005848
.text$x:00005848
.text$x:00005848 __unwindfunclet$??1_System_error_category@std@@UAE@XZ$0 proc near
.text$x:00005848                                         ; DATA XREF: .xdata$x:000095FCo
.text$x:00005848                 mov     ecx, [ebp-10h]  ; this
.text$x:0000584B                 jmp     ??1_Generic_error_category@std@@UAE@XZ ; std::_Generic_error_category::~_Generic_error_category(void)
.text$x:0000584B __unwindfunclet$??1_System_error_category@std@@UAE@XZ$0 endp
.text$x:0000584B
.text$x:00005850
.text$x:00005850 ; =============== S U B R O U T I N E =======================================
.text$x:00005850
.text$x:00005850
.text$x:00005850 __ehhandler$??1_System_error_category@std@@UAE@XZ proc near
.text$x:00005850                                         ; DATA XREF: std::_System_error_category::~_System_error_category(void)+5o
.text$x:00005850
.text$x:00005850 arg_4           = dword ptr  8
.text$x:00005850
.text$x:00005850                 mov     edx, [esp+arg_4]
.text$x:00005854                 lea     eax, [edx+0Ch]
.text$x:00005857                 mov     ecx, [edx-8]
.text$x:0000585A                 xor     ecx, eax
.text$x:0000585C                 call    @__security_check_cookie@4 ; __security_check_cookie(x)
.text$x:00005861                 mov     eax, offset __ehfuncinfo$??1_System_error_category@std@@UAE@XZ
.text$x:00005866                 jmp     ___CxxFrameHandler3
.text$x:00005866 __ehhandler$??1_System_error_category@std@@UAE@XZ endp
.text$x:00005866
.text$x:00005866 ; ---------------------------------------------------------------------------
.text$x:0000586B                 align 4
.text$x:0000586B _text$x         ends
.text$x:0000586B
.text$mn:0000586C ; ===========================================================================
.text$mn:0000586C
.text$mn:0000586C ; Segment type: Pure code
.text$mn:0000586C ; Segment permissions: Read/Execute
.text$mn:0000586C _text$mn        segment para public 'CODE' use32
.text$mn:0000586C                 assume cs:_text$mn
.text$mn:0000586C                 ;org 586Ch
.text$mn:0000586C ; COMDAT (pick any)
.text$mn:0000586C                 assume es:nothing, ss:nothing, ds:_data, fs:nothing, gs:nothing
.text$mn:0000586C
.text$mn:0000586C ; =============== S U B R O U T I N E =======================================
.text$mn:0000586C
.text$mn:0000586C ; Attributes: bp-based frame
.text$mn:0000586C
.text$mn:0000586C ; _DWORD __thiscall std::error_category::~error_category(std::error_category *__hidden this)
.text$mn:0000586C                 public ??1error_category@std@@UAE@XZ
.text$mn:0000586C ??1error_category@std@@UAE@XZ proc near ; CODE XREF: __unwindfunclet$??0_Generic_error_category@std@@QAE@XZ$0+3j
.text$mn:0000586C                                         ; std::_Generic_error_category::~_Generic_error_category(void)+37p ...
.text$mn:0000586C
.text$mn:0000586C var_4           = dword ptr -4
.text$mn:0000586C
.text$mn:0000586C                 push    ebp
.text$mn:0000586D                 mov     ebp, esp
.text$mn:0000586F                 push    ecx
.text$mn:00005870                 mov     [ebp+var_4], ecx
.text$mn:00005873                 mov     eax, [ebp+var_4]
.text$mn:00005876                 mov     dword ptr [eax], offset ??_7error_category@std@@6B@ ; const std::error_category::`vftable'
.text$mn:0000587C                 mov     esp, ebp
.text$mn:0000587E                 pop     ebp
.text$mn:0000587F                 retn
.text$mn:0000587F ??1error_category@std@@UAE@XZ endp
.text$mn:0000587F
.text$mn:0000587F _text$mn        ends
.text$mn:0000587F
.text$mn:00005880 ; ===========================================================================
.text$mn:00005880
.text$mn:00005880 ; Segment type: Pure code
.text$mn:00005880 ; Segment permissions: Read/Execute
.text$mn:00005880 _text$mn        segment para public 'CODE' use32
.text$mn:00005880                 assume cs:_text$mn
.text$mn:00005880                 ;org 5880h
.text$mn:00005880 ; COMDAT (pick any)
.text$mn:00005880                 assume es:nothing, ss:nothing, ds:_data, fs:nothing, gs:nothing
.text$mn:00005880
.text$mn:00005880 ; =============== S U B R O U T I N E =======================================
.text$mn:00005880
.text$mn:00005880 ; Attributes: bp-based frame
.text$mn:00005880
.text$mn:00005880 ; void *__cdecl operator new(unsigned int, void *)
.text$mn:00005880                 public ??2@YAPAXIPAX@Z
.text$mn:00005880 ??2@YAPAXIPAX@Z proc near               ; CODE XREF: std::allocator<char>::construct<char *,char * &>(char * *,char * &)+2Ep
.text$mn:00005880                                         ; std::allocator<wchar_t const *>::construct<wchar_t const *,wchar_t const * &>(wchar_t const * *,wchar_t const * &)+2Ep ...
.text$mn:00005880
.text$mn:00005880 arg_4           = dword ptr  0Ch
.text$mn:00005880
.text$mn:00005880                 push    ebp
.text$mn:00005881                 mov     ebp, esp
.text$mn:00005883                 mov     eax, [ebp+arg_4]
.text$mn:00005886                 pop     ebp
.text$mn:00005887                 retn
.text$mn:00005887 ??2@YAPAXIPAX@Z endp
.text$mn:00005887
.text$mn:00005887 _text$mn        ends
.text$mn:00005887
.text$mn:00005888 ; ===========================================================================
.text$mn:00005888
.text$mn:00005888 ; Segment type: Pure code
.text$mn:00005888 ; Segment permissions: Read/Execute
.text$mn:00005888 _text$mn        segment para public 'CODE' use32
.text$mn:00005888                 assume cs:_text$mn
.text$mn:00005888                 ;org 5888h
.text$mn:00005888 ; COMDAT (pick any)
.text$mn:00005888                 assume es:nothing, ss:nothing, ds:_data, fs:nothing, gs:nothing
.text$mn:00005888
.text$mn:00005888 ; =============== S U B R O U T I N E =======================================
.text$mn:00005888
.text$mn:00005888 ; Attributes: bp-based frame
.text$mn:00005888
.text$mn:00005888 ; void __cdecl operator delete(void *)
.text$mn:00005888                 public ??3@YAXPAX0@Z
.text$mn:00005888 ??3@YAXPAX0@Z   proc near               ; CODE XREF: __unwindfunclet$??$construct@PADAAPAD@?$allocator@D@std@@QAEXPAPADAAPAD@Z$0+8p
.text$mn:00005888                                         ; __unwindfunclet$??$construct@PB_WAAPB_W@?$allocator@PB_W@std@@QAEXPAPB_WAAPB_W@Z$0+8p ...
.text$mn:00005888                 push    ebp
.text$mn:00005889                 mov     ebp, esp
.text$mn:0000588B                 pop     ebp
.text$mn:0000588C                 retn
.text$mn:0000588C ??3@YAXPAX0@Z   endp
.text$mn:0000588C
.text$mn:0000588C ; ---------------------------------------------------------------------------
.text$mn:0000588D                 align 10h
.text$mn:0000588D _text$mn        ends
.text$mn:0000588D
.text$mn:00005890 ; ===========================================================================
.text$mn:00005890
.text$mn:00005890 ; Segment type: Pure code
.text$mn:00005890 ; Segment permissions: Read/Execute
.text$mn:00005890 _text$mn        segment para public 'CODE' use32
.text$mn:00005890                 assume cs:_text$mn
.text$mn:00005890                 ;org 5890h
.text$mn:00005890 ; COMDAT (pick any)
.text$mn:00005890                 assume es:nothing, ss:nothing, ds:_data, fs:nothing, gs:nothing
.text$mn:00005890
.text$mn:00005890 ; =============== S U B R O U T I N E =======================================
.text$mn:00005890
.text$mn:00005890 ; Attributes: bp-based frame
.text$mn:00005890
.text$mn:00005890 ; public: struct std::_Iterator_base12 & __thiscall std::_Iterator_base12::operator=(struct std::_Iterator_base12 const &)
.text$mn:00005890                 public ??4_Iterator_base12@std@@QAEAAU01@ABU01@@Z
.text$mn:00005890 ??4_Iterator_base12@std@@QAEAAU01@ABU01@@Z proc near
.text$mn:00005890                                         ; CODE XREF: std::_Iterator_base12::_Iterator_base12(std::_Iterator_base12 const &)+21p
.text$mn:00005890
.text$mn:00005890 var_14          = byte ptr -14h
.text$mn:00005890 var_10          = dword ptr -10h
.text$mn:00005890 var_C           = dword ptr -0Ch
.text$mn:00005890 var_4           = dword ptr -4
.text$mn:00005890 arg_0           = dword ptr  8
.text$mn:00005890
.text$mn:00005890                 push    ebp
.text$mn:00005891                 mov     ebp, esp
.text$mn:00005893                 push    0FFFFFFFFh
.text$mn:00005895                 push    offset __ehhandler$??4_Iterator_base12@std@@QAEAAU01@ABU01@@Z
.text$mn:0000589A                 mov     eax, large fs:0
.text$mn:000058A0                 push    eax
.text$mn:000058A1                 sub     esp, 8
.text$mn:000058A4                 mov     eax, dword ptr ds:___security_cookie
.text$mn:000058A9                 xor     eax, ebp
.text$mn:000058AB                 push    eax
.text$mn:000058AC                 lea     eax, [ebp+var_C]
.text$mn:000058AF                 mov     large fs:0, eax
.text$mn:000058B5                 mov     [ebp+var_10], ecx
.text$mn:000058B8                 mov     eax, [ebp+var_10]
.text$mn:000058BB                 mov     ecx, [ebp+arg_0]
.text$mn:000058BE                 mov     edx, [eax]
.text$mn:000058C0                 cmp     edx, [ecx]
.text$mn:000058C2                 jnz     short loc_58C6
.text$mn:000058C4                 jmp     short loc_5908
.text$mn:000058C6 ; ---------------------------------------------------------------------------
.text$mn:000058C6
.text$mn:000058C6 loc_58C6:                               ; CODE XREF: std::_Iterator_base12::operator=(std::_Iterator_base12 const &)+32j
.text$mn:000058C6                 mov     eax, [ebp+arg_0]
.text$mn:000058C9                 cmp     dword ptr [eax], 0
.text$mn:000058CC                 jz      short loc_58E0
.text$mn:000058CE                 mov     ecx, [ebp+arg_0]
.text$mn:000058D1                 mov     edx, [ecx]
.text$mn:000058D3                 mov     eax, [edx]
.text$mn:000058D5                 push    eax             ; struct std::_Container_base12 *
.text$mn:000058D6                 mov     ecx, [ebp+var_10] ; this
.text$mn:000058D9                 call    ?_Adopt@_Iterator_base12@std@@QAEXPBU_Container_base12@2@@Z ; std::_Iterator_base12::_Adopt(std::_Container_base12 const *)
.text$mn:000058DE                 jmp     short loc_5908
.text$mn:000058E0 ; ---------------------------------------------------------------------------
.text$mn:000058E0
.text$mn:000058E0 loc_58E0:                               ; CODE XREF: std::_Iterator_base12::operator=(std::_Iterator_base12 const &)+3Cj
.text$mn:000058E0                 push    3               ; int
.text$mn:000058E2                 lea     ecx, [ebp+var_14] ; this
.text$mn:000058E5                 call    ??0_Lockit@std@@QAE@H@Z ; std::_Lockit::_Lockit(int)
.text$mn:000058EA                 mov     [ebp+var_4], 0
.text$mn:000058F1                 mov     ecx, [ebp+var_10] ; this
.text$mn:000058F4                 call    ?_Orphan_me@_Iterator_base12@std@@QAEXXZ ; std::_Iterator_base12::_Orphan_me(void)
.text$mn:000058F9                 mov     [ebp+var_4], 0FFFFFFFFh
.text$mn:00005900                 lea     ecx, [ebp+var_14] ; this
.text$mn:00005903                 call    ??1_Lockit@std@@QAE@XZ ; std::_Lockit::~_Lockit(void)
.text$mn:00005908
.text$mn:00005908 loc_5908:                               ; CODE XREF: std::_Iterator_base12::operator=(std::_Iterator_base12 const &)+34j
.text$mn:00005908                                         ; std::_Iterator_base12::operator=(std::_Iterator_base12 const &)+4Ej
.text$mn:00005908                 mov     eax, [ebp+var_10]
.text$mn:0000590B                 mov     ecx, [ebp+var_C]
.text$mn:0000590E                 mov     large fs:0, ecx
.text$mn:00005915                 pop     ecx
.text$mn:00005916                 mov     esp, ebp
.text$mn:00005918                 pop     ebp
.text$mn:00005919                 retn    4
.text$mn:00005919 ??4_Iterator_base12@std@@QAEAAU01@ABU01@@Z endp
.text$mn:00005919
.text$mn:00005919 _text$mn        ends
.text$mn:00005919
.text$x:0000591C ; ===========================================================================
.text$x:0000591C
.text$x:0000591C ; Segment type: Pure code
.text$x:0000591C ; Segment permissions: Read/Execute
.text$x:0000591C _text$x         segment para public 'CODE' use32
.text$x:0000591C                 assume cs:_text$x
.text$x:0000591C                 ;org 591Ch
.text$x:0000591C ; COMDAT (pick associative to section at 5890)
.text$x:0000591C                 assume es:nothing, ss:nothing, ds:_data, fs:nothing, gs:nothing
.text$x:0000591C
.text$x:0000591C ; =============== S U B R O U T I N E =======================================
.text$x:0000591C
.text$x:0000591C
.text$x:0000591C __unwindfunclet$??4_Iterator_base12@std@@QAEAAU01@ABU01@@Z$0 proc near
.text$x:0000591C                                         ; DATA XREF: .xdata$x:0000927Co
.text$x:0000591C                 lea     ecx, [ebp-14h]  ; this
.text$x:0000591F                 jmp     ??1_Lockit@std@@QAE@XZ ; std::_Lockit::~_Lockit(void)
.text$x:0000591F __unwindfunclet$??4_Iterator_base12@std@@QAEAAU01@ABU01@@Z$0 endp
.text$x:0000591F
.text$x:00005924
.text$x:00005924 ; =============== S U B R O U T I N E =======================================
.text$x:00005924
.text$x:00005924
.text$x:00005924 __ehhandler$??4_Iterator_base12@std@@QAEAAU01@ABU01@@Z proc near
.text$x:00005924                                         ; DATA XREF: std::_Iterator_base12::operator=(std::_Iterator_base12 const &)+5o
.text$x:00005924
.text$x:00005924 arg_4           = dword ptr  8
.text$x:00005924
.text$x:00005924                 mov     edx, [esp+arg_4]
.text$x:00005928                 lea     eax, [edx+0Ch]
.text$x:0000592B                 mov     ecx, [edx-0Ch]
.text$x:0000592E                 xor     ecx, eax
.text$x:00005930                 call    @__security_check_cookie@4 ; __security_check_cookie(x)
.text$x:00005935                 mov     eax, offset __ehfuncinfo$??4_Iterator_base12@std@@QAEAAU01@ABU01@@Z
.text$x:0000593A                 jmp     ___CxxFrameHandler3
.text$x:0000593A __ehhandler$??4_Iterator_base12@std@@QAEAAU01@ABU01@@Z endp
.text$x:0000593A
.text$x:0000593A ; ---------------------------------------------------------------------------
.text$x:0000593F                 align 10h
.text$x:0000593F _text$x         ends
.text$x:0000593F
.text$mn:00005940 ; ===========================================================================
.text$mn:00005940
.text$mn:00005940 ; Segment type: Pure code
.text$mn:00005940 ; Segment permissions: Read/Execute
.text$mn:00005940 _text$mn        segment para public 'CODE' use32
.text$mn:00005940                 assume cs:_text$mn
.text$mn:00005940                 ;org 5940h
.text$mn:00005940 ; COMDAT (pick any)
.text$mn:00005940                 assume es:nothing, ss:nothing, ds:_data, fs:nothing, gs:nothing
.text$mn:00005940
.text$mn:00005940 ; =============== S U B R O U T I N E =======================================
.text$mn:00005940
.text$mn:00005940 ; Attributes: bp-based frame
.text$mn:00005940
.text$mn:00005940 ; public: bool __thiscall std::error_category::operator==(class std::error_category const &)const
.text$mn:00005940                 public ??8error_category@std@@QBE_NABV01@@Z
.text$mn:00005940 ??8error_category@std@@QBE_NABV01@@Z proc near
.text$mn:00005940                                         ; CODE XREF: std::error_condition::operator==(std::error_condition const &)+1Dp
.text$mn:00005940                                         ; std::error_category::equivalent(std::error_code const &,int)+15p
.text$mn:00005940
.text$mn:00005940 var_8           = dword ptr -8
.text$mn:00005940 var_4           = dword ptr -4
.text$mn:00005940 arg_0           = dword ptr  8
.text$mn:00005940
.text$mn:00005940                 push    ebp
.text$mn:00005941                 mov     ebp, esp
.text$mn:00005943                 sub     esp, 8
.text$mn:00005946                 mov     [ebp+var_8], ecx
.text$mn:00005949                 mov     eax, [ebp+var_8]
.text$mn:0000594C                 cmp     eax, [ebp+arg_0]
.text$mn:0000594F                 jnz     short loc_595A
.text$mn:00005951                 mov     [ebp+var_4], 1
.text$mn:00005958                 jmp     short loc_5961
.text$mn:0000595A ; ---------------------------------------------------------------------------
.text$mn:0000595A
.text$mn:0000595A loc_595A:                               ; CODE XREF: std::error_category::operator==(std::error_category const &)+Fj
.text$mn:0000595A                 mov     [ebp+var_4], 0
.text$mn:00005961
.text$mn:00005961 loc_5961:                               ; CODE XREF: std::error_category::operator==(std::error_category const &)+18j
.text$mn:00005961                 mov     al, byte ptr [ebp+var_4]
.text$mn:00005964                 mov     esp, ebp
.text$mn:00005966                 pop     ebp
.text$mn:00005967                 retn    4
.text$mn:00005967 ??8error_category@std@@QBE_NABV01@@Z endp
.text$mn:00005967
.text$mn:00005967 ; ---------------------------------------------------------------------------
.text$mn:0000596A                 align 4
.text$mn:0000596A _text$mn        ends
.text$mn:0000596A
.text$mn:0000596C ; ===========================================================================
.text$mn:0000596C
.text$mn:0000596C ; Segment type: Pure code
.text$mn:0000596C ; Segment permissions: Read/Execute
.text$mn:0000596C _text$mn        segment para public 'CODE' use32
.text$mn:0000596C                 assume cs:_text$mn
.text$mn:0000596C                 ;org 596Ch
.text$mn:0000596C ; COMDAT (pick any)
.text$mn:0000596C                 assume es:nothing, ss:nothing, ds:_data, fs:nothing, gs:nothing
.text$mn:0000596C
.text$mn:0000596C ; =============== S U B R O U T I N E =======================================
.text$mn:0000596C
.text$mn:0000596C ; Attributes: bp-based frame
.text$mn:0000596C
.text$mn:0000596C ; int __stdcall std::error_condition::operator==(std::error_condition *)
.text$mn:0000596C                 public ??8error_condition@std@@QBE_NABV01@@Z
.text$mn:0000596C ??8error_condition@std@@QBE_NABV01@@Z proc near
.text$mn:0000596C                                         ; CODE XREF: std::error_category::equivalent(int,std::error_condition const &)+24p
.text$mn:0000596C
.text$mn:0000596C var_8           = dword ptr -8
.text$mn:0000596C var_4           = dword ptr -4
.text$mn:0000596C arg_0           = dword ptr  8
.text$mn:0000596C
.text$mn:0000596C                 push    ebp
.text$mn:0000596D                 mov     ebp, esp
.text$mn:0000596F                 sub     esp, 8
.text$mn:00005972                 push    esi
.text$mn:00005973                 mov     [ebp+var_4], ecx
.text$mn:00005976                 mov     ecx, [ebp+arg_0] ; this
.text$mn:00005979                 call    ?category@error_condition@std@@QBEABVerror_category@2@XZ ; std::error_condition::category(void)
.text$mn:0000597E                 push    eax
.text$mn:0000597F                 mov     ecx, [ebp+var_4] ; this
.text$mn:00005982                 call    ?category@error_condition@std@@QBEABVerror_category@2@XZ ; std::error_condition::category(void)
.text$mn:00005987                 mov     ecx, eax
.text$mn:00005989                 call    ??8error_category@std@@QBE_NABV01@@Z ; std::error_category::operator==(std::error_category const &)
.text$mn:0000598E                 movzx   eax, al
.text$mn:00005991                 test    eax, eax
.text$mn:00005993                 jz      short loc_59B4
.text$mn:00005995                 mov     ecx, [ebp+var_4] ; this
.text$mn:00005998                 call    ?value@error_condition@std@@QBEHXZ ; std::error_condition::value(void)
.text$mn:0000599D                 mov     esi, eax
.text$mn:0000599F                 mov     ecx, [ebp+arg_0] ; this
.text$mn:000059A2                 call    ?value@error_condition@std@@QBEHXZ ; std::error_condition::value(void)
.text$mn:000059A7                 cmp     esi, eax
.text$mn:000059A9                 jnz     short loc_59B4
.text$mn:000059AB                 mov     [ebp+var_8], 1
.text$mn:000059B2                 jmp     short loc_59BB
.text$mn:000059B4 ; ---------------------------------------------------------------------------
.text$mn:000059B4
.text$mn:000059B4 loc_59B4:                               ; CODE XREF: std::error_condition::operator==(std::error_condition const &)+27j
.text$mn:000059B4                                         ; std::error_condition::operator==(std::error_condition const &)+3Dj
.text$mn:000059B4                 mov     [ebp+var_8], 0
.text$mn:000059BB
.text$mn:000059BB loc_59BB:                               ; CODE XREF: std::error_condition::operator==(std::error_condition const &)+46j
.text$mn:000059BB                 mov     al, byte ptr [ebp+var_8]
.text$mn:000059BE                 pop     esi
.text$mn:000059BF                 mov     esp, ebp
.text$mn:000059C1                 pop     ebp
.text$mn:000059C2                 retn    4
.text$mn:000059C2 ??8error_condition@std@@QBE_NABV01@@Z endp
.text$mn:000059C2
.text$mn:000059C2 ; ---------------------------------------------------------------------------
.text$mn:000059C5                 align 4
.text$mn:000059C5 _text$mn        ends
.text$mn:000059C5
.text$mn:000059C8 ; ===========================================================================
.text$mn:000059C8
.text$mn:000059C8 ; Segment type: Pure code
.text$mn:000059C8 ; Segment permissions: Read/Execute
.text$mn:000059C8 _text$mn        segment para public 'CODE' use32
.text$mn:000059C8                 assume cs:_text$mn
.text$mn:000059C8                 ;org 59C8h
.text$mn:000059C8 ; COMDAT (pick any)
.text$mn:000059C8                 assume es:nothing, ss:nothing, ds:_data, fs:nothing, gs:nothing
.text$mn:000059C8
.text$mn:000059C8 ; =============== S U B R O U T I N E =======================================
.text$mn:000059C8
.text$mn:000059C8 ; Attributes: bp-based frame
.text$mn:000059C8
.text$mn:000059C8 ; public: struct FunctionValues const & __thiscall std::_Vector_const_iterator<class std::_Vector_val<struct std::_Simple_types<struct FunctionValues>>>::operator*(void)const
.text$mn:000059C8                 public ??D?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@UFunctionValues@@@std@@@std@@@std@@QBEABUFunctionValues@@XZ
.text$mn:000059C8 ??D?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@UFunctionValues@@@std@@@std@@@std@@QBEABUFunctionValues@@XZ proc near
.text$mn:000059C8                                         ; CODE XREF: std::_Vector_iterator<std::_Vector_val<std::_Simple_types<FunctionValues>>>::operator*(void)+Ap
.text$mn:000059C8
.text$mn:000059C8 var_4           = dword ptr -4
.text$mn:000059C8
.text$mn:000059C8                 push    ebp
.text$mn:000059C9                 mov     ebp, esp
.text$mn:000059CB                 push    ecx
.text$mn:000059CC                 mov     [ebp+var_4], ecx
.text$mn:000059CF                 mov     ecx, [ebp+var_4] ; this
.text$mn:000059D2                 call    ?_Getcont@_Iterator_base12@std@@QBEPBU_Container_base12@2@XZ ; std::_Iterator_base12::_Getcont(void)
.text$mn:000059D7                 test    eax, eax
.text$mn:000059D9                 jz      short loc_5A0A
.text$mn:000059DB                 mov     eax, [ebp+var_4]
.text$mn:000059DE                 cmp     dword ptr [eax+8], 0
.text$mn:000059E2                 jz      short loc_5A0A
.text$mn:000059E4                 mov     ecx, [ebp+var_4] ; this
.text$mn:000059E7                 call    ?_Getcont@_Iterator_base12@std@@QBEPBU_Container_base12@2@XZ ; std::_Iterator_base12::_Getcont(void)
.text$mn:000059EC                 mov     ecx, [ebp+var_4]
.text$mn:000059EF                 mov     edx, [ecx+8]
.text$mn:000059F2                 cmp     edx, [eax+4]
.text$mn:000059F5                 jb      short loc_5A0A
.text$mn:000059F7                 mov     ecx, [ebp+var_4] ; this
.text$mn:000059FA                 call    ?_Getcont@_Iterator_base12@std@@QBEPBU_Container_base12@2@XZ ; std::_Iterator_base12::_Getcont(void)
.text$mn:000059FF                 mov     ecx, [ebp+var_4]
.text$mn:00005A02                 mov     edx, [eax+8]
.text$mn:00005A05                 cmp     edx, [ecx+8]
.text$mn:00005A08                 ja      short loc_5A69
.text$mn:00005A0A
.text$mn:00005A0A loc_5A0A:                               ; CODE XREF: std::_Vector_const_iterator<std::_Vector_val<std::_Simple_types<FunctionValues>>>::operator*(void)+11j
.text$mn:00005A0A                                         ; std::_Vector_const_iterator<std::_Vector_val<std::_Simple_types<FunctionValues>>>::operator*(void)+1Aj ...
.text$mn:00005A0A                 push    48h ; 'H'       ; unsigned int
.text$mn:00005A0C                 push    offset ??_C@_1IM@EINEHPHE@?$AAC?$AA?3?$AA?2?$AAP?$AAr?$AAo?$AAg?$AAr?$AAa?$AAm?$AA?5?$AAF?$AAi?$AAl?$AAe?$AAs?$AA?5?$AA?$CI?$AAx?$AA8?$AA6?$AA?$CJ?$AA?2?$AAM?$AAi?$AAc?$AAr?$AAo?$AAs?$AAo?$AAf?$AAt@ ; "C:\\Program Files (x86)\\Microsoft Visu"...
.text$mn:00005A11                 push    offset ??_C@_1EG@FOHJJHAC@?$AAv?$AAe?$AAc?$AAt?$AAo?$AAr?$AA?5?$AAi?$AAt?$AAe?$AAr?$AAa?$AAt?$AAo?$AAr?$AA?5?$AAn?$AAo?$AAt?$AA?5?$AAd?$AAe?$AAr?$AAe?$AAf?$AAe?$AAr?$AAe?$AAn?$AAc?$AAa?$AAb@ ; "vector iterator not dereferencable"
.text$mn:00005A16                 call    ?_Debug_message@std@@YAXPB_W0I@Z ; std::_Debug_message(wchar_t const *,wchar_t const *,uint)
.text$mn:00005A1B                 add     esp, 0Ch
.text$mn:00005A1E                 mov     eax, offset ??_C@_0CE@OFMIGAMM@Standard?5C?$CL?$CL?5Libraries?5Out?5of?5Ra@ ; "Standard C++ Libraries Out of Range"
.text$mn:00005A23                 test    eax, eax
.text$mn:00005A25                 jz      short loc_5A2B
.text$mn:00005A27                 xor     ecx, ecx
.text$mn:00005A29                 jnz     short loc_5A4E
.text$mn:00005A2B
.text$mn:00005A2B loc_5A2B:                               ; CODE XREF: std::_Vector_const_iterator<std::_Vector_val<std::_Simple_types<FunctionValues>>>::operator*(void)+5Dj
.text$mn:00005A2B                 push    offset ??_C@_1FG@IBPIFFN@?$AA?$CC?$AAS?$AAt?$AAa?$AAn?$AAd?$AAa?$AAr?$AAd?$AA?5?$AAC?$AA?$CL?$AA?$CL?$AA?5?$AAL?$AAi?$AAb?$AAr?$AAa?$AAr?$AAi?$AAe?$AAs?$AA?5?$AAO?$AAu?$AAt?$AA?5?$AAo?$AAf?$AA?5?$AAR@ ; "\"Standard C++ Libraries Out of Range\""...
.text$mn:00005A30                 push    offset ??_C@_15GANGMFKL@?$AA?$CF?$AAs?$AA?$AA@ ; "%s"
.text$mn:00005A35                 push    0
.text$mn:00005A37                 push    49h ; 'I'
.text$mn:00005A39                 push    offset ??_C@_1IM@EINEHPHE@?$AAC?$AA?3?$AA?2?$AAP?$AAr?$AAo?$AAg?$AAr?$AAa?$AAm?$AA?5?$AAF?$AAi?$AAl?$AAe?$AAs?$AA?5?$AA?$CI?$AAx?$AA8?$AA6?$AA?$CJ?$AA?2?$AAM?$AAi?$AAc?$AAr?$AAo?$AAs?$AAo?$AAf?$AAt@ ; "C:\\Program Files (x86)\\Microsoft Visu"...
.text$mn:00005A3E                 push    2
.text$mn:00005A40                 call    __CrtDbgReportW
.text$mn:00005A45                 add     esp, 18h
.text$mn:00005A48                 cmp     eax, 1
.text$mn:00005A4B                 jnz     short loc_5A4E
.text$mn:00005A4D                 int     3               ; Trap to Debugger
.text$mn:00005A4E
.text$mn:00005A4E loc_5A4E:                               ; CODE XREF: std::_Vector_const_iterator<std::_Vector_val<std::_Simple_types<FunctionValues>>>::operator*(void)+61j
.text$mn:00005A4E                                         ; std::_Vector_const_iterator<std::_Vector_val<std::_Simple_types<FunctionValues>>>::operator*(void)+83j
.text$mn:00005A4E                 push    0
.text$mn:00005A50                 push    49h ; 'I'
.text$mn:00005A52                 push    offset ??_C@_1IM@EINEHPHE@?$AAC?$AA?3?$AA?2?$AAP?$AAr?$AAo?$AAg?$AAr?$AAa?$AAm?$AA?5?$AAF?$AAi?$AAl?$AAe?$AAs?$AA?5?$AA?$CI?$AAx?$AA8?$AA6?$AA?$CJ?$AA?2?$AAM?$AAi?$AAc?$AAr?$AAo?$AAs?$AAo?$AAf?$AAt@ ; "C:\\Program Files (x86)\\Microsoft Visu"...
.text$mn:00005A57                 push    offset ??_C@_1OI@FONGOOEE@?$AAs?$AAt?$AAd?$AA?3?$AA?3?$AA_?$AAV?$AAe?$AAc?$AAt?$AAo?$AAr?$AA_?$AAc?$AAo?$AAn?$AAs?$AAt?$AA_?$AAi?$AAt?$AAe?$AAr?$AAa?$AAt?$AAo?$AAr?$AA?$DM?$AAc?$AAl?$AAa?$AAs@ ; "std::_Vector_const_iterator<class std::"...
.text$mn:00005A5C                 push    offset ??_C@_1BO@MEPPHOO@?$AA?$CC?$AAo?$AAu?$AAt?$AA?5?$AAo?$AAf?$AA?5?$AAr?$AAa?$AAn?$AAg?$AAe?$AA?$CC?$AA?$AA@ ; "\"out of range\""
.text$mn:00005A61                 call    __invalid_parameter
.text$mn:00005A66                 add     esp, 14h
.text$mn:00005A69
.text$mn:00005A69 loc_5A69:                               ; CODE XREF: std::_Vector_const_iterator<std::_Vector_val<std::_Simple_types<FunctionValues>>>::operator*(void)+40j
.text$mn:00005A69                 mov     eax, [ebp+var_4]
.text$mn:00005A6C                 mov     eax, [eax+8]
.text$mn:00005A6F                 mov     esp, ebp
.text$mn:00005A71                 pop     ebp
.text$mn:00005A72                 retn
.text$mn:00005A72 ??D?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@UFunctionValues@@@std@@@std@@@std@@QBEABUFunctionValues@@XZ endp
.text$mn:00005A72
.text$mn:00005A72 ; ---------------------------------------------------------------------------
.text$mn:00005A73                 align 4
.text$mn:00005A73 _text$mn        ends
.text$mn:00005A73
.text$mn:00005A74 ; ===========================================================================
.text$mn:00005A74
.text$mn:00005A74 ; Segment type: Pure code
.text$mn:00005A74 ; Segment permissions: Read/Execute
.text$mn:00005A74 _text$mn        segment para public 'CODE' use32
.text$mn:00005A74                 assume cs:_text$mn
.text$mn:00005A74                 ;org 5A74h
.text$mn:00005A74 ; COMDAT (pick any)
.text$mn:00005A74                 assume es:nothing, ss:nothing, ds:_data, fs:nothing, gs:nothing
.text$mn:00005A74
.text$mn:00005A74 ; =============== S U B R O U T I N E =======================================
.text$mn:00005A74
.text$mn:00005A74 ; Attributes: bp-based frame
.text$mn:00005A74
.text$mn:00005A74 ; public: struct FunctionValues & __thiscall std::_Vector_iterator<class std::_Vector_val<struct std::_Simple_types<struct FunctionValues>>>::operator*(void)const
.text$mn:00005A74                 public ??D?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@UFunctionValues@@@std@@@std@@@std@@QBEAAUFunctionValues@@XZ
.text$mn:00005A74 ??D?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@UFunctionValues@@@std@@@std@@@std@@QBEAAUFunctionValues@@XZ proc near
.text$mn:00005A74                                         ; CODE XREF: std::vector<FunctionValues,std::allocator<FunctionValues>>::back(void)+62p
.text$mn:00005A74
.text$mn:00005A74 var_4           = dword ptr -4
.text$mn:00005A74
.text$mn:00005A74                 push    ebp
.text$mn:00005A75                 mov     ebp, esp
.text$mn:00005A77                 push    ecx
.text$mn:00005A78                 mov     [ebp+var_4], ecx
.text$mn:00005A7B                 mov     ecx, [ebp+var_4]
.text$mn:00005A7E                 call    ??D?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@UFunctionValues@@@std@@@std@@@std@@QBEABUFunctionValues@@XZ ; std::_Vector_const_iterator<std::_Vector_val<std::_Simple_types<FunctionValues>>>::operator*(void)
.text$mn:00005A83                 mov     esp, ebp
.text$mn:00005A85                 pop     ebp
.text$mn:00005A86                 retn
.text$mn:00005A86 ??D?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@UFunctionValues@@@std@@@std@@@std@@QBEAAUFunctionValues@@XZ endp
.text$mn:00005A86
.text$mn:00005A86 ; ---------------------------------------------------------------------------
.text$mn:00005A87                 align 4
.text$mn:00005A87 _text$mn        ends
.text$mn:00005A87
.text$mn:00005A88 ; ===========================================================================
.text$mn:00005A88
.text$mn:00005A88 ; Segment type: Pure code
.text$mn:00005A88 ; Segment permissions: Read/Execute
.text$mn:00005A88 _text$mn        segment para public 'CODE' use32
.text$mn:00005A88                 assume cs:_text$mn
.text$mn:00005A88                 ;org 5A88h
.text$mn:00005A88 ; COMDAT (pick any)
.text$mn:00005A88                 assume es:nothing, ss:nothing, ds:_data, fs:nothing, gs:nothing
.text$mn:00005A88
.text$mn:00005A88 ; =============== S U B R O U T I N E =======================================
.text$mn:00005A88
.text$mn:00005A88 ; Attributes: bp-based frame
.text$mn:00005A88
.text$mn:00005A88 ; public: class std::_Vector_iterator<class std::_Vector_val<struct std::_Simple_types<struct FunctionValues>>> __thiscall std::_Vector_iterator<class std::_Vector_val<struct std::_Simple_types<struct FunctionValues>>>::operator-(int)const
.text$mn:00005A88                 public ??G?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@UFunctionValues@@@std@@@std@@@std@@QBE?AV01@H@Z
.text$mn:00005A88 ??G?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@UFunctionValues@@@std@@@std@@@std@@QBE?AV01@H@Z proc near
.text$mn:00005A88                                         ; CODE XREF: std::vector<FunctionValues,std::allocator<FunctionValues>>::back(void)+4Dp
.text$mn:00005A88
.text$mn:00005A88 var_20          = byte ptr -20h
.text$mn:00005A88 var_14          = dword ptr -14h
.text$mn:00005A88 var_10          = dword ptr -10h
.text$mn:00005A88 var_C           = dword ptr -0Ch
.text$mn:00005A88 var_4           = dword ptr -4
.text$mn:00005A88 arg_0           = dword ptr  8
.text$mn:00005A88 arg_4           = dword ptr  0Ch
.text$mn:00005A88
.text$mn:00005A88                 push    ebp
.text$mn:00005A89                 mov     ebp, esp
.text$mn:00005A8B                 push    0FFFFFFFFh
.text$mn:00005A8D                 push    offset __ehhandler$??G?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@UFunctionValues@@@std@@@std@@@std@@QBE?AV01@H@Z
.text$mn:00005A92                 mov     eax, large fs:0
.text$mn:00005A98                 push    eax
.text$mn:00005A99                 sub     esp, 14h
.text$mn:00005A9C                 mov     eax, dword ptr ds:___security_cookie
.text$mn:00005AA1                 xor     eax, ebp
.text$mn:00005AA3                 push    eax
.text$mn:00005AA4                 lea     eax, [ebp+var_C]
.text$mn:00005AA7                 mov     large fs:0, eax
.text$mn:00005AAD                 mov     [ebp+var_14], ecx
.text$mn:00005AB0                 mov     [ebp+var_10], 0
.text$mn:00005AB7                 mov     eax, [ebp+var_14]
.text$mn:00005ABA                 push    eax             ; struct std::_Iterator_base12 *
.text$mn:00005ABB                 lea     ecx, [ebp+var_20]
.text$mn:00005ABE                 call    ??0?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@UFunctionValues@@@std@@@std@@@std@@QAE@ABV01@@Z ; std::_Vector_iterator<std::_Vector_val<std::_Simple_types<FunctionValues>>>::_Vector_iterator<std::_Vector_val<std::_Simple_types<FunctionValues>>>(std::_Vector_iterator<std::_Vector_val<std::_Simple_types<FunctionValues>>> const &)
.text$mn:00005AC3                 mov     [ebp+var_4], 1
.text$mn:00005ACA                 mov     ecx, [ebp+arg_4]
.text$mn:00005ACD                 push    ecx
.text$mn:00005ACE                 lea     ecx, [ebp+var_20]
.text$mn:00005AD1                 call    ??Z?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@UFunctionValues@@@std@@@std@@@std@@QAEAAV01@H@Z ; std::_Vector_iterator<std::_Vector_val<std::_Simple_types<FunctionValues>>>::operator-=(int)
.text$mn:00005AD6                 push    eax             ; struct std::_Iterator_base12 *
.text$mn:00005AD7                 mov     ecx, [ebp+arg_0]
.text$mn:00005ADA                 call    ??0?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@UFunctionValues@@@std@@@std@@@std@@QAE@ABV01@@Z ; std::_Vector_iterator<std::_Vector_val<std::_Simple_types<FunctionValues>>>::_Vector_iterator<std::_Vector_val<std::_Simple_types<FunctionValues>>>(std::_Vector_iterator<std::_Vector_val<std::_Simple_types<FunctionValues>>> const &)
.text$mn:00005ADF                 mov     edx, [ebp+var_10]
.text$mn:00005AE2                 or      edx, 1
.text$mn:00005AE5                 mov     [ebp+var_10], edx
.text$mn:00005AE8                 mov     byte ptr [ebp+var_4], 0
.text$mn:00005AEC                 lea     ecx, [ebp+var_20]
.text$mn:00005AEF                 call    ??1?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@UFunctionValues@@@std@@@std@@@std@@QAE@XZ ; std::_Vector_iterator<std::_Vector_val<std::_Simple_types<FunctionValues>>>::~_Vector_iterator<std::_Vector_val<std::_Simple_types<FunctionValues>>>(void)
.text$mn:00005AF4                 mov     eax, [ebp+arg_0]
.text$mn:00005AF7                 mov     ecx, [ebp+var_C]
.text$mn:00005AFA                 mov     large fs:0, ecx
.text$mn:00005B01                 pop     ecx
.text$mn:00005B02                 mov     esp, ebp
.text$mn:00005B04                 pop     ebp
.text$mn:00005B05                 retn    8
.text$mn:00005B05 ??G?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@UFunctionValues@@@std@@@std@@@std@@QBE?AV01@H@Z endp
.text$mn:00005B05
.text$mn:00005B05 _text$mn        ends
.text$mn:00005B05
.text$x:00005B08 ; ===========================================================================
.text$x:00005B08
.text$x:00005B08 ; Segment type: Pure code
.text$x:00005B08 ; Segment permissions: Read/Execute
.text$x:00005B08 _text$x         segment para public 'CODE' use32
.text$x:00005B08                 assume cs:_text$x
.text$x:00005B08                 ;org 5B08h
.text$x:00005B08 ; COMDAT (pick associative to section at 5A88)
.text$x:00005B08                 assume es:nothing, ss:nothing, ds:_data, fs:nothing, gs:nothing
.text$x:00005B08
.text$x:00005B08 ; =============== S U B R O U T I N E =======================================
.text$x:00005B08
.text$x:00005B08
.text$x:00005B08 __unwindfunclet$??G?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@UFunctionValues@@@std@@@std@@@std@@QBE?AV01@H@Z$0 proc near
.text$x:00005B08                                         ; DATA XREF: .xdata$x:00009E6Co
.text$x:00005B08                 lea     ecx, [ebp-20h]
.text$x:00005B0B                 jmp     ??1?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@UFunctionValues@@@std@@@std@@@std@@QAE@XZ ; std::_Vector_iterator<std::_Vector_val<std::_Simple_types<FunctionValues>>>::~_Vector_iterator<std::_Vector_val<std::_Simple_types<FunctionValues>>>(void)
.text$x:00005B0B __unwindfunclet$??G?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@UFunctionValues@@@std@@@std@@@std@@QBE?AV01@H@Z$0 endp
.text$x:00005B0B
.text$x:00005B10
.text$x:00005B10 ; =============== S U B R O U T I N E =======================================
.text$x:00005B10
.text$x:00005B10
.text$x:00005B10 __unwindfunclet$??G?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@UFunctionValues@@@std@@@std@@@std@@QBE?AV01@H@Z$1 proc near
.text$x:00005B10                                         ; DATA XREF: .xdata$x:00009E64o
.text$x:00005B10                 mov     eax, [ebp-10h]
.text$x:00005B13                 and     eax, 1
.text$x:00005B16                 jz      $LN5
.text$x:00005B1C                 and     dword ptr [ebp-10h], 0FFFFFFFEh
.text$x:00005B20                 mov     ecx, [ebp+8]
.text$x:00005B23                 jmp     ??1?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@UFunctionValues@@@std@@@std@@@std@@QAE@XZ ; std::_Vector_iterator<std::_Vector_val<std::_Simple_types<FunctionValues>>>::~_Vector_iterator<std::_Vector_val<std::_Simple_types<FunctionValues>>>(void)
.text$x:00005B28 ; ---------------------------------------------------------------------------
.text$x:00005B28
.text$x:00005B28 $LN5:                                   ; CODE XREF: __unwindfunclet$??G?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@UFunctionValues@@@std@@@std@@@std@@QBE?AV01@H@Z$1+6j
.text$x:00005B28                 retn
.text$x:00005B28 __unwindfunclet$??G?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@UFunctionValues@@@std@@@std@@@std@@QBE?AV01@H@Z$1 endp
.text$x:00005B28
.text$x:00005B29
.text$x:00005B29 ; =============== S U B R O U T I N E =======================================
.text$x:00005B29
.text$x:00005B29
.text$x:00005B29 __ehhandler$??G?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@UFunctionValues@@@std@@@std@@@std@@QBE?AV01@H@Z proc near
.text$x:00005B29                                         ; DATA XREF: std::_Vector_iterator<std::_Vector_val<std::_Simple_types<FunctionValues>>>::operator-(int)+5o
.text$x:00005B29
.text$x:00005B29 arg_4           = dword ptr  8
.text$x:00005B29
.text$x:00005B29                 mov     edx, [esp+arg_4]
.text$x:00005B2D                 lea     eax, [edx+0Ch]
.text$x:00005B30                 mov     ecx, [edx-18h]
.text$x:00005B33                 xor     ecx, eax
.text$x:00005B35                 call    @__security_check_cookie@4 ; __security_check_cookie(x)
.text$x:00005B3A                 mov     eax, offset __ehfuncinfo$??G?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@UFunctionValues@@@std@@@std@@@std@@QBE?AV01@H@Z
.text$x:00005B3F                 jmp     ___CxxFrameHandler3
.text$x:00005B3F __ehhandler$??G?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@UFunctionValues@@@std@@@std@@@std@@QBE?AV01@H@Z endp
.text$x:00005B3F
.text$x:00005B3F _text$x         ends
.text$x:00005B3F
.text$mn:00005B44 ; ===========================================================================
.text$mn:00005B44
.text$mn:00005B44 ; Segment type: Pure code
.text$mn:00005B44 ; Segment permissions: Read/Execute
.text$mn:00005B44 _text$mn        segment para public 'CODE' use32
.text$mn:00005B44                 assume cs:_text$mn
.text$mn:00005B44                 ;org 5B44h
.text$mn:00005B44 ; COMDAT (pick any)
.text$mn:00005B44                 assume es:nothing, ss:nothing, ds:_data, fs:nothing, gs:nothing
.text$mn:00005B44
.text$mn:00005B44 ; =============== S U B R O U T I N E =======================================
.text$mn:00005B44
.text$mn:00005B44 ; Attributes: bp-based frame
.text$mn:00005B44
.text$mn:00005B44 ; public: class std::_Vector_const_iterator<class std::_Vector_val<struct std::_Simple_types<struct FunctionValues>>> & __thiscall std::_Vector_const_iterator<class std::_Vector_val<struct std::_Simple_types<struct FunctionValues>>>::operator+=(int)
.text$mn:00005B44                 public ??Y?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@UFunctionValues@@@std@@@std@@@std@@QAEAAV01@H@Z
.text$mn:00005B44 ??Y?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@UFunctionValues@@@std@@@std@@@std@@QAEAAV01@H@Z proc near
.text$mn:00005B44                                         ; CODE XREF: std::_Vector_iterator<std::_Vector_val<std::_Simple_types<FunctionValues>>>::operator+=(int)+Ep
.text$mn:00005B44
.text$mn:00005B44 var_4           = dword ptr -4
.text$mn:00005B44 arg_0           = dword ptr  8
.text$mn:00005B44
.text$mn:00005B44                 push    ebp
.text$mn:00005B45                 mov     ebp, esp
.text$mn:00005B47                 push    ecx
.text$mn:00005B48                 push    esi
.text$mn:00005B49                 mov     [ebp+var_4], ecx
.text$mn:00005B4C                 mov     ecx, [ebp+var_4] ; this
.text$mn:00005B4F                 call    ?_Getcont@_Iterator_base12@std@@QBEPBU_Container_base12@2@XZ ; std::_Iterator_base12::_Getcont(void)
.text$mn:00005B54                 test    eax, eax
.text$mn:00005B56                 jz      short loc_5B8A
.text$mn:00005B58                 mov     esi, [ebp+arg_0]
.text$mn:00005B5B                 shl     esi, 4
.text$mn:00005B5E                 mov     eax, [ebp+var_4]
.text$mn:00005B61                 add     esi, [eax+8]
.text$mn:00005B64                 mov     ecx, [ebp+var_4] ; this
.text$mn:00005B67                 call    ?_Getcont@_Iterator_base12@std@@QBEPBU_Container_base12@2@XZ ; std::_Iterator_base12::_Getcont(void)
.text$mn:00005B6C                 cmp     esi, [eax+4]
.text$mn:00005B6F                 jb      short loc_5B8A
.text$mn:00005B71                 mov     ecx, [ebp+var_4] ; this
.text$mn:00005B74                 call    ?_Getcont@_Iterator_base12@std@@QBEPBU_Container_base12@2@XZ ; std::_Iterator_base12::_Getcont(void)
.text$mn:00005B79                 mov     ecx, [ebp+arg_0]
.text$mn:00005B7C                 shl     ecx, 4
.text$mn:00005B7F                 mov     edx, [ebp+var_4]
.text$mn:00005B82                 add     ecx, [edx+8]
.text$mn:00005B85                 cmp     [eax+8], ecx
.text$mn:00005B88                 jnb     short loc_5BF2
.text$mn:00005B8A
.text$mn:00005B8A loc_5B8A:                               ; CODE XREF: std::_Vector_const_iterator<std::_Vector_val<std::_Simple_types<FunctionValues>>>::operator+=(int)+12j
.text$mn:00005B8A                                         ; std::_Vector_const_iterator<std::_Vector_val<std::_Simple_types<FunctionValues>>>::operator+=(int)+2Bj
.text$mn:00005B8A                 push    9Fh ; 'ƒ'       ; unsigned int
.text$mn:00005B8F                 push    offset ??_C@_1IM@EINEHPHE@?$AAC?$AA?3?$AA?2?$AAP?$AAr?$AAo?$AAg?$AAr?$AAa?$AAm?$AA?5?$AAF?$AAi?$AAl?$AAe?$AAs?$AA?5?$AA?$CI?$AAx?$AA8?$AA6?$AA?$CJ?$AA?2?$AAM?$AAi?$AAc?$AAr?$AAo?$AAs?$AAo?$AAf?$AAt@ ; "C:\\Program Files (x86)\\Microsoft Visu"...
.text$mn:00005B94                 push    offset ??_C@_1EM@FKAOCOMF@?$AAv?$AAe?$AAc?$AAt?$AAo?$AAr?$AA?5?$AAi?$AAt?$AAe?$AAr?$AAa?$AAt?$AAo?$AAr?$AA?5?$AA?$CL?$AA?5?$AAo?$AAf?$AAf?$AAs?$AAe?$AAt?$AA?5?$AAo?$AAu?$AAt?$AA?5?$AAo?$AAf?$AA?5@ ; "vector iterator + offset out of range"
.text$mn:00005B99                 call    ?_Debug_message@std@@YAXPB_W0I@Z ; std::_Debug_message(wchar_t const *,wchar_t const *,uint)
.text$mn:00005B9E                 add     esp, 0Ch
.text$mn:00005BA1                 mov     eax, offset ??_C@_0CE@OFMIGAMM@Standard?5C?$CL?$CL?5Libraries?5Out?5of?5Ra@ ; "Standard C++ Libraries Out of Range"
.text$mn:00005BA6                 test    eax, eax
.text$mn:00005BA8                 jz      short loc_5BAE
.text$mn:00005BAA                 xor     ecx, ecx
.text$mn:00005BAC                 jnz     short loc_5BD4
.text$mn:00005BAE
.text$mn:00005BAE loc_5BAE:                               ; CODE XREF: std::_Vector_const_iterator<std::_Vector_val<std::_Simple_types<FunctionValues>>>::operator+=(int)+64j
.text$mn:00005BAE                 push    offset ??_C@_1FG@IBPIFFN@?$AA?$CC?$AAS?$AAt?$AAa?$AAn?$AAd?$AAa?$AAr?$AAd?$AA?5?$AAC?$AA?$CL?$AA?$CL?$AA?5?$AAL?$AAi?$AAb?$AAr?$AAa?$AAr?$AAi?$AAe?$AAs?$AA?5?$AAO?$AAu?$AAt?$AA?5?$AAo?$AAf?$AA?5?$AAR@ ; "\"Standard C++ Libraries Out of Range\""...
.text$mn:00005BB3                 push    offset ??_C@_15GANGMFKL@?$AA?$CF?$AAs?$AA?$AA@ ; "%s"
.text$mn:00005BB8                 push    0
.text$mn:00005BBA                 push    0A0h ; 'á'
.text$mn:00005BBF                 push    offset ??_C@_1IM@EINEHPHE@?$AAC?$AA?3?$AA?2?$AAP?$AAr?$AAo?$AAg?$AAr?$AAa?$AAm?$AA?5?$AAF?$AAi?$AAl?$AAe?$AAs?$AA?5?$AA?$CI?$AAx?$AA8?$AA6?$AA?$CJ?$AA?2?$AAM?$AAi?$AAc?$AAr?$AAo?$AAs?$AAo?$AAf?$AAt@ ; "C:\\Program Files (x86)\\Microsoft Visu"...
.text$mn:00005BC4                 push    2
.text$mn:00005BC6                 call    __CrtDbgReportW
.text$mn:00005BCB                 add     esp, 18h
.text$mn:00005BCE                 cmp     eax, 1
.text$mn:00005BD1                 jnz     short loc_5BD4
.text$mn:00005BD3                 int     3               ; Trap to Debugger
.text$mn:00005BD4
.text$mn:00005BD4 loc_5BD4:                               ; CODE XREF: std::_Vector_const_iterator<std::_Vector_val<std::_Simple_types<FunctionValues>>>::operator+=(int)+68j
.text$mn:00005BD4                                         ; std::_Vector_const_iterator<std::_Vector_val<std::_Simple_types<FunctionValues>>>::operator+=(int)+8Dj
.text$mn:00005BD4                 push    0
.text$mn:00005BD6                 push    0A0h ; 'á'
.text$mn:00005BDB                 push    offset ??_C@_1IM@EINEHPHE@?$AAC?$AA?3?$AA?2?$AAP?$AAr?$AAo?$AAg?$AAr?$AAa?$AAm?$AA?5?$AAF?$AAi?$AAl?$AAe?$AAs?$AA?5?$AA?$CI?$AAx?$AA8?$AA6?$AA?$CJ?$AA?2?$AAM?$AAi?$AAc?$AAr?$AAo?$AAs?$AAo?$AAf?$AAt@ ; "C:\\Program Files (x86)\\Microsoft Visu"...
.text$mn:00005BE0                 push    offset ??_C@_1OK@BKLKOIHB@?$AAs?$AAt?$AAd?$AA?3?$AA?3?$AA_?$AAV?$AAe?$AAc?$AAt?$AAo?$AAr?$AA_?$AAc?$AAo?$AAn?$AAs?$AAt?$AA_?$AAi?$AAt?$AAe?$AAr?$AAa?$AAt?$AAo?$AAr?$AA?$DM?$AAc?$AAl?$AAa?$AAs@ ; "std::_Vector_const_iterator<class std::"...
.text$mn:00005BE5                 push    offset ??_C@_1BO@MEPPHOO@?$AA?$CC?$AAo?$AAu?$AAt?$AA?5?$AAo?$AAf?$AA?5?$AAr?$AAa?$AAn?$AAg?$AAe?$AA?$CC?$AA?$AA@ ; "\"out of range\""
.text$mn:00005BEA                 call    __invalid_parameter
.text$mn:00005BEF                 add     esp, 14h
.text$mn:00005BF2
.text$mn:00005BF2 loc_5BF2:                               ; CODE XREF: std::_Vector_const_iterator<std::_Vector_val<std::_Simple_types<FunctionValues>>>::operator+=(int)+44j
.text$mn:00005BF2                 mov     eax, [ebp+arg_0]
.text$mn:00005BF5                 shl     eax, 4
.text$mn:00005BF8                 mov     ecx, [ebp+var_4]
.text$mn:00005BFB                 add     eax, [ecx+8]
.text$mn:00005BFE                 mov     edx, [ebp+var_4]
.text$mn:00005C01                 mov     [edx+8], eax
.text$mn:00005C04                 mov     eax, [ebp+var_4]
.text$mn:00005C07                 pop     esi
.text$mn:00005C08                 mov     esp, ebp
.text$mn:00005C0A                 pop     ebp
.text$mn:00005C0B                 retn    4
.text$mn:00005C0B ??Y?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@UFunctionValues@@@std@@@std@@@std@@QAEAAV01@H@Z endp
.text$mn:00005C0B
.text$mn:00005C0B ; ---------------------------------------------------------------------------
.text$mn:00005C0E                 align 10h
.text$mn:00005C0E _text$mn        ends
.text$mn:00005C0E
.text$mn:00005C10 ; ===========================================================================
.text$mn:00005C10
.text$mn:00005C10 ; Segment type: Pure code
.text$mn:00005C10 ; Segment permissions: Read/Execute
.text$mn:00005C10 _text$mn        segment para public 'CODE' use32
.text$mn:00005C10                 assume cs:_text$mn
.text$mn:00005C10                 ;org 5C10h
.text$mn:00005C10 ; COMDAT (pick any)
.text$mn:00005C10                 assume es:nothing, ss:nothing, ds:_data, fs:nothing, gs:nothing
.text$mn:00005C10
.text$mn:00005C10 ; =============== S U B R O U T I N E =======================================
.text$mn:00005C10
.text$mn:00005C10 ; Attributes: bp-based frame
.text$mn:00005C10
.text$mn:00005C10 ; public: class std::_Vector_iterator<class std::_Vector_val<struct std::_Simple_types<struct FunctionValues>>> & __thiscall std::_Vector_iterator<class std::_Vector_val<struct std::_Simple_types<struct FunctionValues>>>::operator+=(int)
.text$mn:00005C10                 public ??Y?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@UFunctionValues@@@std@@@std@@@std@@QAEAAV01@H@Z
.text$mn:00005C10 ??Y?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@UFunctionValues@@@std@@@std@@@std@@QAEAAV01@H@Z proc near
.text$mn:00005C10                                         ; CODE XREF: std::_Vector_iterator<std::_Vector_val<std::_Simple_types<FunctionValues>>>::operator-=(int)+10p
.text$mn:00005C10
.text$mn:00005C10 var_4           = dword ptr -4
.text$mn:00005C10 arg_0           = dword ptr  8
.text$mn:00005C10
.text$mn:00005C10                 push    ebp
.text$mn:00005C11                 mov     ebp, esp
.text$mn:00005C13                 push    ecx
.text$mn:00005C14                 mov     [ebp+var_4], ecx
.text$mn:00005C17                 mov     eax, [ebp+arg_0]
.text$mn:00005C1A                 push    eax
.text$mn:00005C1B                 mov     ecx, [ebp+var_4]
.text$mn:00005C1E                 call    ??Y?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@UFunctionValues@@@std@@@std@@@std@@QAEAAV01@H@Z ; std::_Vector_const_iterator<std::_Vector_val<std::_Simple_types<FunctionValues>>>::operator+=(int)
.text$mn:00005C23                 mov     eax, [ebp+var_4]
.text$mn:00005C26                 mov     esp, ebp
.text$mn:00005C28                 pop     ebp
.text$mn:00005C29                 retn    4
.text$mn:00005C29 ??Y?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@UFunctionValues@@@std@@@std@@@std@@QAEAAV01@H@Z endp
.text$mn:00005C29
.text$mn:00005C29 _text$mn        ends
.text$mn:00005C29
.text$mn:00005C2C ; ===========================================================================
.text$mn:00005C2C
.text$mn:00005C2C ; Segment type: Pure code
.text$mn:00005C2C ; Segment permissions: Read/Execute
.text$mn:00005C2C _text$mn        segment para public 'CODE' use32
.text$mn:00005C2C                 assume cs:_text$mn
.text$mn:00005C2C                 ;org 5C2Ch
.text$mn:00005C2C ; COMDAT (pick any)
.text$mn:00005C2C                 assume es:nothing, ss:nothing, ds:_data, fs:nothing, gs:nothing
.text$mn:00005C2C
.text$mn:00005C2C ; =============== S U B R O U T I N E =======================================
.text$mn:00005C2C
.text$mn:00005C2C ; Attributes: bp-based frame
.text$mn:00005C2C
.text$mn:00005C2C ; public: class std::_Vector_iterator<class std::_Vector_val<struct std::_Simple_types<struct FunctionValues>>> & __thiscall std::_Vector_iterator<class std::_Vector_val<struct std::_Simple_types<struct FunctionValues>>>::operator-=(int)
.text$mn:00005C2C                 public ??Z?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@UFunctionValues@@@std@@@std@@@std@@QAEAAV01@H@Z
.text$mn:00005C2C ??Z?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@UFunctionValues@@@std@@@std@@@std@@QAEAAV01@H@Z proc near
.text$mn:00005C2C                                         ; CODE XREF: std::_Vector_iterator<std::_Vector_val<std::_Simple_types<FunctionValues>>>::operator-(int)+49p
.text$mn:00005C2C
.text$mn:00005C2C var_4           = dword ptr -4
.text$mn:00005C2C arg_0           = dword ptr  8
.text$mn:00005C2C
.text$mn:00005C2C                 push    ebp
.text$mn:00005C2D                 mov     ebp, esp
.text$mn:00005C2F                 push    ecx
.text$mn:00005C30                 mov     [ebp+var_4], ecx
.text$mn:00005C33                 mov     eax, [ebp+arg_0]
.text$mn:00005C36                 neg     eax
.text$mn:00005C38                 push    eax
.text$mn:00005C39                 mov     ecx, [ebp+var_4]
.text$mn:00005C3C                 call    ??Y?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@UFunctionValues@@@std@@@std@@@std@@QAEAAV01@H@Z ; std::_Vector_iterator<std::_Vector_val<std::_Simple_types<FunctionValues>>>::operator+=(int)
.text$mn:00005C41                 mov     esp, ebp
.text$mn:00005C43                 pop     ebp
.text$mn:00005C44                 retn    4
.text$mn:00005C44 ??Z?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@UFunctionValues@@@std@@@std@@@std@@QAEAAV01@H@Z endp
.text$mn:00005C44
.text$mn:00005C44 ; ---------------------------------------------------------------------------
.text$mn:00005C47                 align 4
.text$mn:00005C47 _text$mn        ends
.text$mn:00005C47
.text$mn:00005C48 ; ===========================================================================
.text$mn:00005C48
.text$mn:00005C48 ; Segment type: Pure code
.text$mn:00005C48 ; Segment permissions: Read/Execute
.text$mn:00005C48 _text$mn        segment para public 'CODE' use32
.text$mn:00005C48                 assume cs:_text$mn
.text$mn:00005C48                 ;org 5C48h
.text$mn:00005C48 ; COMDAT (pick any)
.text$mn:00005C48                 assume es:nothing, ss:nothing, ds:_data, fs:nothing, gs:nothing
.text$mn:00005C48
.text$mn:00005C48 ; =============== S U B R O U T I N E =======================================
.text$mn:00005C48
.text$mn:00005C48 ; Attributes: bp-based frame
.text$mn:00005C48
.text$mn:00005C48 ; public: void * __thiscall std::vector<wchar_t const *, class std::allocator<wchar_t const *>>::`scalar deleting destructor'(unsigned int)
.text$mn:00005C48                 public ??_G?$vector@PB_WV?$allocator@PB_W@std@@@std@@QAEPAXI@Z
.text$mn:00005C48 ??_G?$vector@PB_WV?$allocator@PB_W@std@@@std@@QAEPAXI@Z proc near
.text$mn:00005C48                                         ; CODE XREF: std::allocator<std::vector<wchar_t const *,std::allocator<wchar_t const *>>>::destroy<std::vector<wchar_t const *,std::allocator<wchar_t const *>>>(std::vector<wchar_t const *,std::allocator<wchar_t const *>> *)+Cp
.text$mn:00005C48
.text$mn:00005C48 var_4           = dword ptr -4
.text$mn:00005C48 arg_0           = dword ptr  8
.text$mn:00005C48
.text$mn:00005C48                 push    ebp
.text$mn:00005C49                 mov     ebp, esp
.text$mn:00005C4B                 push    ecx
.text$mn:00005C4C                 mov     [ebp+var_4], ecx
.text$mn:00005C4F                 mov     ecx, [ebp+var_4]
.text$mn:00005C52                 call    ??1?$vector@PB_WV?$allocator@PB_W@std@@@std@@QAE@XZ ; std::vector<wchar_t const *,std::allocator<wchar_t const *>>::~vector<wchar_t const *,std::allocator<wchar_t const *>>(void)
.text$mn:00005C57                 mov     eax, [ebp+arg_0]
.text$mn:00005C5A                 and     eax, 1
.text$mn:00005C5D                 jz      short loc_5C6B
.text$mn:00005C5F                 mov     ecx, [ebp+var_4]
.text$mn:00005C62                 push    ecx             ; void *
.text$mn:00005C63                 call    ??3@YAXPAX@Z    ; operator delete(void *)
.text$mn:00005C68                 add     esp, 4
.text$mn:00005C6B
.text$mn:00005C6B loc_5C6B:                               ; CODE XREF: std::vector<wchar_t const *,std::allocator<wchar_t const *>>::`scalar deleting destructor'(uint)+15j
.text$mn:00005C6B                 mov     eax, [ebp+var_4]
.text$mn:00005C6E                 mov     esp, ebp
.text$mn:00005C70                 pop     ebp
.text$mn:00005C71                 retn    4
.text$mn:00005C71 ??_G?$vector@PB_WV?$allocator@PB_W@std@@@std@@QAEPAXI@Z endp
.text$mn:00005C71
.text$mn:00005C71 _text$mn        ends
.text$mn:00005C71
.text$mn:00005C74 ; ===========================================================================
.text$mn:00005C74
.text$mn:00005C74 ; Segment type: Pure code
.text$mn:00005C74 ; Segment permissions: Read/Execute
.text$mn:00005C74 _text$mn        segment para public 'CODE' use32
.text$mn:00005C74                 assume cs:_text$mn
.text$mn:00005C74                 ;org 5C74h
.text$mn:00005C74 ; COMDAT (pick any)
.text$mn:00005C74                 assume es:nothing, ss:nothing, ds:_data, fs:nothing, gs:nothing
.text$mn:00005C74
.text$mn:00005C74 ; =============== S U B R O U T I N E =======================================
.text$mn:00005C74
.text$mn:00005C74 ; Attributes: bp-based frame
.text$mn:00005C74
.text$mn:00005C74 ; public: virtual void * __thiscall std::_Generic_error_category::`scalar deleting destructor'(unsigned int)
.text$mn:00005C74                 public ??_G_Generic_error_category@std@@UAEPAXI@Z
.text$mn:00005C74 ??_G_Generic_error_category@std@@UAEPAXI@Z proc near
.text$mn:00005C74
.text$mn:00005C74 var_4           = dword ptr -4
.text$mn:00005C74 arg_0           = dword ptr  8
.text$mn:00005C74
.text$mn:00005C74                 push    ebp
.text$mn:00005C75                 mov     ebp, esp
.text$mn:00005C77                 push    ecx
.text$mn:00005C78                 mov     [ebp+var_4], ecx
.text$mn:00005C7B                 mov     ecx, [ebp+var_4] ; this
.text$mn:00005C7E                 call    ??1_Generic_error_category@std@@UAE@XZ ; std::_Generic_error_category::~_Generic_error_category(void)
.text$mn:00005C83                 mov     eax, [ebp+arg_0]
.text$mn:00005C86                 and     eax, 1
.text$mn:00005C89                 jz      short loc_5C97
.text$mn:00005C8B                 mov     ecx, [ebp+var_4]
.text$mn:00005C8E                 push    ecx             ; void *
.text$mn:00005C8F                 call    ??3@YAXPAX@Z    ; operator delete(void *)
.text$mn:00005C94                 add     esp, 4
.text$mn:00005C97
.text$mn:00005C97 loc_5C97:                               ; CODE XREF: std::_Generic_error_category::`scalar deleting destructor'(uint)+15j
.text$mn:00005C97                 mov     eax, [ebp+var_4]
.text$mn:00005C9A                 mov     esp, ebp
.text$mn:00005C9C                 pop     ebp
.text$mn:00005C9D                 retn    4
.text$mn:00005C9D ??_G_Generic_error_category@std@@UAEPAXI@Z endp
.text$mn:00005C9D
.text$mn:00005C9D _text$mn        ends
.text$mn:00005C9D
.text$mn:00005CA0 ; ===========================================================================
.text$mn:00005CA0
.text$mn:00005CA0 ; Segment type: Pure code
.text$mn:00005CA0 ; Segment permissions: Read/Execute
.text$mn:00005CA0 _text$mn        segment para public 'CODE' use32
.text$mn:00005CA0                 assume cs:_text$mn
.text$mn:00005CA0                 ;org 5CA0h
.text$mn:00005CA0 ; COMDAT (pick any)
.text$mn:00005CA0                 assume es:nothing, ss:nothing, ds:_data, fs:nothing, gs:nothing
.text$mn:00005CA0
.text$mn:00005CA0 ; =============== S U B R O U T I N E =======================================
.text$mn:00005CA0
.text$mn:00005CA0 ; Attributes: bp-based frame
.text$mn:00005CA0
.text$mn:00005CA0 ; public: virtual void * __thiscall std::_Iostream_error_category::`scalar deleting destructor'(unsigned int)
.text$mn:00005CA0                 public ??_G_Iostream_error_category@std@@UAEPAXI@Z
.text$mn:00005CA0 ??_G_Iostream_error_category@std@@UAEPAXI@Z proc near
.text$mn:00005CA0
.text$mn:00005CA0 var_4           = dword ptr -4
.text$mn:00005CA0 arg_0           = dword ptr  8
.text$mn:00005CA0
.text$mn:00005CA0                 push    ebp
.text$mn:00005CA1                 mov     ebp, esp
.text$mn:00005CA3                 push    ecx
.text$mn:00005CA4                 mov     [ebp+var_4], ecx
.text$mn:00005CA7                 mov     ecx, [ebp+var_4] ; this
.text$mn:00005CAA                 call    ??1_Iostream_error_category@std@@UAE@XZ ; std::_Iostream_error_category::~_Iostream_error_category(void)
.text$mn:00005CAF                 mov     eax, [ebp+arg_0]
.text$mn:00005CB2                 and     eax, 1
.text$mn:00005CB5                 jz      short loc_5CC3
.text$mn:00005CB7                 mov     ecx, [ebp+var_4]
.text$mn:00005CBA                 push    ecx             ; void *
.text$mn:00005CBB                 call    ??3@YAXPAX@Z    ; operator delete(void *)
.text$mn:00005CC0                 add     esp, 4
.text$mn:00005CC3
.text$mn:00005CC3 loc_5CC3:                               ; CODE XREF: std::_Iostream_error_category::`scalar deleting destructor'(uint)+15j
.text$mn:00005CC3                 mov     eax, [ebp+var_4]
.text$mn:00005CC6                 mov     esp, ebp
.text$mn:00005CC8                 pop     ebp
.text$mn:00005CC9                 retn    4
.text$mn:00005CC9 ??_G_Iostream_error_category@std@@UAEPAXI@Z endp
.text$mn:00005CC9
.text$mn:00005CC9 _text$mn        ends
.text$mn:00005CC9
.text$mn:00005CCC ; ===========================================================================
.text$mn:00005CCC
.text$mn:00005CCC ; Segment type: Pure code
.text$mn:00005CCC ; Segment permissions: Read/Execute
.text$mn:00005CCC _text$mn        segment para public 'CODE' use32
.text$mn:00005CCC                 assume cs:_text$mn
.text$mn:00005CCC                 ;org 5CCCh
.text$mn:00005CCC ; COMDAT (pick any)
.text$mn:00005CCC                 assume es:nothing, ss:nothing, ds:_data, fs:nothing, gs:nothing
.text$mn:00005CCC
.text$mn:00005CCC ; =============== S U B R O U T I N E =======================================
.text$mn:00005CCC
.text$mn:00005CCC ; Attributes: bp-based frame
.text$mn:00005CCC
.text$mn:00005CCC ; public: virtual void * __thiscall std::_System_error_category::`scalar deleting destructor'(unsigned int)
.text$mn:00005CCC                 public ??_G_System_error_category@std@@UAEPAXI@Z
.text$mn:00005CCC ??_G_System_error_category@std@@UAEPAXI@Z proc near
.text$mn:00005CCC
.text$mn:00005CCC var_4           = dword ptr -4
.text$mn:00005CCC arg_0           = dword ptr  8
.text$mn:00005CCC
.text$mn:00005CCC                 push    ebp
.text$mn:00005CCD                 mov     ebp, esp
.text$mn:00005CCF                 push    ecx
.text$mn:00005CD0                 mov     [ebp+var_4], ecx
.text$mn:00005CD3                 mov     ecx, [ebp+var_4] ; this
.text$mn:00005CD6                 call    ??1_System_error_category@std@@UAE@XZ ; std::_System_error_category::~_System_error_category(void)
.text$mn:00005CDB                 mov     eax, [ebp+arg_0]
.text$mn:00005CDE                 and     eax, 1
.text$mn:00005CE1                 jz      short loc_5CEF
.text$mn:00005CE3                 mov     ecx, [ebp+var_4]
.text$mn:00005CE6                 push    ecx             ; void *
.text$mn:00005CE7                 call    ??3@YAXPAX@Z    ; operator delete(void *)
.text$mn:00005CEC                 add     esp, 4
.text$mn:00005CEF
.text$mn:00005CEF loc_5CEF:                               ; CODE XREF: std::_System_error_category::`scalar deleting destructor'(uint)+15j
.text$mn:00005CEF                 mov     eax, [ebp+var_4]
.text$mn:00005CF2                 mov     esp, ebp
.text$mn:00005CF4                 pop     ebp
.text$mn:00005CF5                 retn    4
.text$mn:00005CF5 ??_G_System_error_category@std@@UAEPAXI@Z endp
.text$mn:00005CF5
.text$mn:00005CF5 _text$mn        ends
.text$mn:00005CF5
.text$mn:00005CF8 ; ===========================================================================
.text$mn:00005CF8
.text$mn:00005CF8 ; Segment type: Pure code
.text$mn:00005CF8 ; Segment permissions: Read/Execute
.text$mn:00005CF8 _text$mn        segment para public 'CODE' use32
.text$mn:00005CF8                 assume cs:_text$mn
.text$mn:00005CF8                 ;org 5CF8h
.text$mn:00005CF8 ; COMDAT (pick any)
.text$mn:00005CF8                 assume es:nothing, ss:nothing, ds:_data, fs:nothing, gs:nothing
.text$mn:00005CF8
.text$mn:00005CF8 ; =============== S U B R O U T I N E =======================================
.text$mn:00005CF8
.text$mn:00005CF8 ; Attributes: bp-based frame
.text$mn:00005CF8
.text$mn:00005CF8 ; public: virtual void * __thiscall std::error_category::`scalar deleting destructor'(unsigned int)
.text$mn:00005CF8                 public ??_Gerror_category@std@@UAEPAXI@Z
.text$mn:00005CF8 ??_Gerror_category@std@@UAEPAXI@Z proc near
.text$mn:00005CF8
.text$mn:00005CF8 var_4           = dword ptr -4
.text$mn:00005CF8 arg_0           = dword ptr  8
.text$mn:00005CF8
.text$mn:00005CF8                 push    ebp
.text$mn:00005CF9                 mov     ebp, esp
.text$mn:00005CFB                 push    ecx
.text$mn:00005CFC                 mov     [ebp+var_4], ecx
.text$mn:00005CFF                 mov     ecx, [ebp+var_4] ; this
.text$mn:00005D02                 call    ??1error_category@std@@UAE@XZ ; std::error_category::~error_category(void)
.text$mn:00005D07                 mov     eax, [ebp+arg_0]
.text$mn:00005D0A                 and     eax, 1
.text$mn:00005D0D                 jz      short loc_5D1B
.text$mn:00005D0F                 mov     ecx, [ebp+var_4]
.text$mn:00005D12                 push    ecx             ; void *
.text$mn:00005D13                 call    ??3@YAXPAX@Z    ; operator delete(void *)
.text$mn:00005D18                 add     esp, 4
.text$mn:00005D1B
.text$mn:00005D1B loc_5D1B:                               ; CODE XREF: std::error_category::`scalar deleting destructor'(uint)+15j
.text$mn:00005D1B                 mov     eax, [ebp+var_4]
.text$mn:00005D1E                 mov     esp, ebp
.text$mn:00005D20                 pop     ebp
.text$mn:00005D21                 retn    4
.text$mn:00005D21 ??_Gerror_category@std@@UAEPAXI@Z endp
.text$mn:00005D21
.text$mn:00005D21 _text$mn        ends
.text$mn:00005D21
.text$di:00005D24 ; ===========================================================================
.text$di:00005D24
.text$di:00005D24 ; Segment type: Pure code
.text$di:00005D24 ; Segment permissions: Read/Execute
.text$di:00005D24 _text$di        segment para public 'CODE' use32
.text$di:00005D24                 assume cs:_text$di
.text$di:00005D24                 ;org 5D24h
.text$di:00005D24 ; COMDAT (pick any)
.text$di:00005D24                 assume es:nothing, ss:nothing, ds:_data, fs:nothing, gs:nothing
.text$di:00005D24
.text$di:00005D24 ; =============== S U B R O U T I N E =======================================
.text$di:00005D24
.text$di:00005D24 ; Attributes: bp-based frame
.text$di:00005D24
.text$di:00005D24 ; void __cdecl `dynamic initializer for 'public: static class std::_Generic_error_category std::_Error_objects<int>::_Generic_object''(void)
.text$di:00005D24 ??__E?_Generic_object@?$_Error_objects@H@std@@2V_Generic_error_category@2@A@@YAXXZ proc near
.text$di:00005D24                                         ; DATA XREF: .CRT$XCU:void (*std::_Error_objects<int>::_Generic_object$initializer$)(void)o
.text$di:00005D24                 push    ebp
.text$di:00005D25                 mov     ebp, esp
.text$di:00005D27                 mov     ecx, offset ?_Generic_object@?$_Error_objects@H@std@@2V_Generic_error_category@2@A ; this
.text$di:00005D2C                 call    ??0_Generic_error_category@std@@QAE@XZ ; std::_Generic_error_category::_Generic_error_category(void)
.text$di:00005D31                 push    offset ??__F?_Generic_object@?$_Error_objects@H@std@@2V_Generic_error_category@2@A@@YAXXZ ; void (__cdecl *)()
.text$di:00005D36                 call    _atexit
.text$di:00005D3B                 add     esp, 4
.text$di:00005D3E                 pop     ebp
.text$di:00005D3F                 retn
.text$di:00005D3F ??__E?_Generic_object@?$_Error_objects@H@std@@2V_Generic_error_category@2@A@@YAXXZ endp
.text$di:00005D3F
.text$di:00005D3F _text$di        ends
.text$di:00005D3F
.text$di:00005D40 ; ===========================================================================
.text$di:00005D40
.text$di:00005D40 ; Segment type: Pure code
.text$di:00005D40 ; Segment permissions: Read/Execute
.text$di:00005D40 _text$di        segment para public 'CODE' use32
.text$di:00005D40                 assume cs:_text$di
.text$di:00005D40                 ;org 5D40h
.text$di:00005D40 ; COMDAT (pick any)
.text$di:00005D40                 assume es:nothing, ss:nothing, ds:_data, fs:nothing, gs:nothing
.text$di:00005D40
.text$di:00005D40 ; =============== S U B R O U T I N E =======================================
.text$di:00005D40
.text$di:00005D40 ; Attributes: bp-based frame
.text$di:00005D40
.text$di:00005D40 ; void __cdecl `dynamic initializer for 'public: static class std::_Iostream_error_category std::_Error_objects<int>::_Iostream_object''(void)
.text$di:00005D40 ??__E?_Iostream_object@?$_Error_objects@H@std@@2V_Iostream_error_category@2@A@@YAXXZ proc near
.text$di:00005D40                                         ; DATA XREF: .CRT$XCU:void (*std::_Error_objects<int>::_Iostream_object$initializer$)(void)o
.text$di:00005D40                 push    ebp
.text$di:00005D41                 mov     ebp, esp
.text$di:00005D43                 mov     ecx, offset ?_Iostream_object@?$_Error_objects@H@std@@2V_Iostream_error_category@2@A ; this
.text$di:00005D48                 call    ??0_Iostream_error_category@std@@QAE@XZ ; std::_Iostream_error_category::_Iostream_error_category(void)
.text$di:00005D4D                 push    offset ??__F?_Iostream_object@?$_Error_objects@H@std@@2V_Iostream_error_category@2@A@@YAXXZ ; void (__cdecl *)()
.text$di:00005D52                 call    _atexit
.text$di:00005D57                 add     esp, 4
.text$di:00005D5A                 pop     ebp
.text$di:00005D5B                 retn
.text$di:00005D5B ??__E?_Iostream_object@?$_Error_objects@H@std@@2V_Iostream_error_category@2@A@@YAXXZ endp
.text$di:00005D5B
.text$di:00005D5B _text$di        ends
.text$di:00005D5B
.text$di:00005D5C ; ===========================================================================
.text$di:00005D5C
.text$di:00005D5C ; Segment type: Pure code
.text$di:00005D5C ; Segment permissions: Read/Execute
.text$di:00005D5C _text$di        segment para public 'CODE' use32
.text$di:00005D5C                 assume cs:_text$di
.text$di:00005D5C                 ;org 5D5Ch
.text$di:00005D5C ; COMDAT (pick any)
.text$di:00005D5C                 assume es:nothing, ss:nothing, ds:_data, fs:nothing, gs:nothing
.text$di:00005D5C
.text$di:00005D5C ; =============== S U B R O U T I N E =======================================
.text$di:00005D5C
.text$di:00005D5C ; Attributes: bp-based frame
.text$di:00005D5C
.text$di:00005D5C ; void __cdecl `dynamic initializer for 'public: static class std::_System_error_category std::_Error_objects<int>::_System_object''(void)
.text$di:00005D5C ??__E?_System_object@?$_Error_objects@H@std@@2V_System_error_category@2@A@@YAXXZ proc near
.text$di:00005D5C                                         ; DATA XREF: .CRT$XCU:void (*std::_Error_objects<int>::_System_object$initializer$)(void)o
.text$di:00005D5C                 push    ebp
.text$di:00005D5D                 mov     ebp, esp
.text$di:00005D5F                 mov     ecx, offset ?_System_object@?$_Error_objects@H@std@@2V_System_error_category@2@A ; this
.text$di:00005D64                 call    ??0_System_error_category@std@@QAE@XZ ; std::_System_error_category::_System_error_category(void)
.text$di:00005D69                 push    offset ??__F?_System_object@?$_Error_objects@H@std@@2V_System_error_category@2@A@@YAXXZ ; void (__cdecl *)()
.text$di:00005D6E                 call    _atexit
.text$di:00005D73                 add     esp, 4
.text$di:00005D76                 pop     ebp
.text$di:00005D77                 retn
.text$di:00005D77 ??__E?_System_object@?$_Error_objects@H@std@@2V_System_error_category@2@A@@YAXXZ endp
.text$di:00005D77
.text$di:00005D77 _text$di        ends
.text$di:00005D77
.text$di:00005D78 ; ===========================================================================
.text$di:00005D78
.text$di:00005D78 ; Segment type: Pure code
.text$di:00005D78 ; Segment permissions: Read/Execute
.text$di:00005D78 _text$di        segment para public 'CODE' use32
.text$di:00005D78                 assume cs:_text$di
.text$di:00005D78                 ;org 5D78h
.text$di:00005D78 ; COMDAT (pick any)
.text$di:00005D78                 assume es:nothing, ss:nothing, ds:_data, fs:nothing, gs:nothing
.text$di:00005D78
.text$di:00005D78 ; =============== S U B R O U T I N E =======================================
.text$di:00005D78
.text$di:00005D78 ; Attributes: bp-based frame
.text$di:00005D78
.text$di:00005D78 ; void __cdecl `dynamic initializer for 'public: static class std::locale::id std::num_put<char, class std::back_insert_iterator<class std::basic_string<char, struct std::char_traits<char>, class std::allocator<char>>>>::id''(void)
.text$di:00005D78 ??__E?id@?$num_put@DV?$back_insert_iterator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@std@@2V0locale@2@A@@YAXXZ proc near
.text$di:00005D78                                         ; DATA XREF: .CRT$XCU:void (*std::num_put<char,std::back_insert_iterator<std::basic_string<char,std::char_traits<char>,std::allocator<char>>>>::id$initializer$)(void)o
.text$di:00005D78                 push    ebp
.text$di:00005D79                 mov     ebp, esp
.text$di:00005D7B                 push    0               ; unsigned int
.text$di:00005D7D                 mov     ecx, offset ?id@?$num_put@DV?$back_insert_iterator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@std@@2V0locale@2@A ; this
.text$di:00005D82                 call    ??0id@locale@std@@QAE@I@Z ; std::locale::id::id(uint)
.text$di:00005D87                 pop     ebp
.text$di:00005D88                 retn
.text$di:00005D88 ??__E?id@?$num_put@DV?$back_insert_iterator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@std@@2V0locale@2@A@@YAXXZ endp
.text$di:00005D88
.text$di:00005D88 ; ---------------------------------------------------------------------------
.text$di:00005D89                 align 4
.text$di:00005D89 _text$di        ends
.text$di:00005D89
.text$di:00005D8C ; ===========================================================================
.text$di:00005D8C
.text$di:00005D8C ; Segment type: Pure code
.text$di:00005D8C ; Segment permissions: Read/Execute
.text$di:00005D8C _text$di        segment para public 'CODE' use32
.text$di:00005D8C                 assume cs:_text$di
.text$di:00005D8C                 ;org 5D8Ch
.text$di:00005D8C ; COMDAT (pick any)
.text$di:00005D8C                 assume es:nothing, ss:nothing, ds:_data, fs:nothing, gs:nothing
.text$di:00005D8C
.text$di:00005D8C ; =============== S U B R O U T I N E =======================================
.text$di:00005D8C
.text$di:00005D8C ; Attributes: bp-based frame
.text$di:00005D8C
.text$di:00005D8C ; void __cdecl `dynamic initializer for 'public: static class std::locale::id std::num_put<wchar_t, class std::back_insert_iterator<class std::basic_string<wchar_t, struct std::char_traits<wchar_t>, class std::allocator<wchar_t>>>>::id''(void)
.text$di:00005D8C ??__E?id@?$num_put@_WV?$back_insert_iterator@V?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@@std@@@std@@2V0locale@2@A@@YAXXZ proc near
.text$di:00005D8C                                         ; DATA XREF: .CRT$XCU:void (*std::num_put<wchar_t,std::back_insert_iterator<std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>>>>::id$initializer$)(void)o
.text$di:00005D8C                 push    ebp
.text$di:00005D8D                 mov     ebp, esp
.text$di:00005D8F                 push    0               ; unsigned int
.text$di:00005D91                 mov     ecx, offset ?id@?$num_put@_WV?$back_insert_iterator@V?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@@std@@@std@@2V0locale@2@A ; this
.text$di:00005D96                 call    ??0id@locale@std@@QAE@I@Z ; std::locale::id::id(uint)
.text$di:00005D9B                 pop     ebp
.text$di:00005D9C                 retn
.text$di:00005D9C ??__E?id@?$num_put@_WV?$back_insert_iterator@V?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@@std@@@std@@2V0locale@2@A@@YAXXZ endp
.text$di:00005D9C
.text$di:00005D9C ; ---------------------------------------------------------------------------
.text$di:00005D9D                 align 10h
.text$di:00005D9D _text$di        ends
.text$di:00005D9D
.text$di:00005DA0 ; ===========================================================================
.text$di:00005DA0
.text$di:00005DA0 ; Segment type: Pure code
.text$di:00005DA0 ; Segment permissions: Read/Execute
.text$di:00005DA0 _text$di        segment para public 'CODE' use32
.text$di:00005DA0                 assume cs:_text$di
.text$di:00005DA0                 ;org 5DA0h
.text$di:00005DA0 ; COMDAT (pick any)
.text$di:00005DA0                 assume es:nothing, ss:nothing, ds:_data, fs:nothing, gs:nothing
.text$di:00005DA0
.text$di:00005DA0 ; =============== S U B R O U T I N E =======================================
.text$di:00005DA0
.text$di:00005DA0 ; Attributes: bp-based frame
.text$di:00005DA0
.text$di:00005DA0 ; void __cdecl `dynamic initializer for 'public: static class std::locale::id std::numpunct<char>::id''(void)
.text$di:00005DA0 ??__E?id@?$numpunct@D@std@@2V0locale@2@A@@YAXXZ proc near
.text$di:00005DA0                                         ; DATA XREF: .CRT$XCU:void (*std::numpunct<char>::id$initializer$)(void)o
.text$di:00005DA0                 push    ebp
.text$di:00005DA1                 mov     ebp, esp
.text$di:00005DA3                 push    0               ; unsigned int
.text$di:00005DA5                 mov     ecx, offset ?id@?$numpunct@D@std@@2V0locale@2@A ; this
.text$di:00005DAA                 call    ??0id@locale@std@@QAE@I@Z ; std::locale::id::id(uint)
.text$di:00005DAF                 pop     ebp
.text$di:00005DB0                 retn
.text$di:00005DB0 ??__E?id@?$numpunct@D@std@@2V0locale@2@A@@YAXXZ endp
.text$di:00005DB0
.text$di:00005DB0 ; ---------------------------------------------------------------------------
.text$di:00005DB1                 align 4
.text$di:00005DB1 _text$di        ends
.text$di:00005DB1
.text$di:00005DB4 ; ===========================================================================
.text$di:00005DB4
.text$di:00005DB4 ; Segment type: Pure code
.text$di:00005DB4 ; Segment permissions: Read/Execute
.text$di:00005DB4 _text$di        segment para public 'CODE' use32
.text$di:00005DB4                 assume cs:_text$di
.text$di:00005DB4                 ;org 5DB4h
.text$di:00005DB4 ; COMDAT (pick any)
.text$di:00005DB4                 assume es:nothing, ss:nothing, ds:_data, fs:nothing, gs:nothing
.text$di:00005DB4
.text$di:00005DB4 ; =============== S U B R O U T I N E =======================================
.text$di:00005DB4
.text$di:00005DB4 ; Attributes: bp-based frame
.text$di:00005DB4
.text$di:00005DB4 ; void __cdecl `dynamic initializer for 'public: static class std::locale::id std::numpunct<wchar_t>::id''(void)
.text$di:00005DB4 ??__E?id@?$numpunct@_W@std@@2V0locale@2@A@@YAXXZ proc near
.text$di:00005DB4                                         ; DATA XREF: .CRT$XCU:void (*std::numpunct<wchar_t>::id$initializer$)(void)o
.text$di:00005DB4                 push    ebp
.text$di:00005DB5                 mov     ebp, esp
.text$di:00005DB7                 push    0               ; unsigned int
.text$di:00005DB9                 mov     ecx, offset ?id@?$numpunct@_W@std@@2V0locale@2@A ; this
.text$di:00005DBE                 call    ??0id@locale@std@@QAE@I@Z ; std::locale::id::id(uint)
.text$di:00005DC3                 pop     ebp
.text$di:00005DC4                 retn
.text$di:00005DC4 ??__E?id@?$numpunct@_W@std@@2V0locale@2@A@@YAXXZ endp
.text$di:00005DC4
.text$di:00005DC4 ; ---------------------------------------------------------------------------
.text$di:00005DC5                 align 4
.text$di:00005DC5 _text$di        ends
.text$di:00005DC5
.text$di:00005DC8 ; ===========================================================================
.text$di:00005DC8
.text$di:00005DC8 ; Segment type: Pure code
.text$di:00005DC8 ; Segment permissions: Read/Execute
.text$di:00005DC8 _text$di        segment para public 'CODE' use32
.text$di:00005DC8                 assume cs:_text$di
.text$di:00005DC8                 ;org 5DC8h
.text$di:00005DC8 ; COMDAT (pick any)
.text$di:00005DC8                 assume es:nothing, ss:nothing, ds:_data, fs:nothing, gs:nothing
.text$di:00005DC8
.text$di:00005DC8 ; =============== S U B R O U T I N E =======================================
.text$di:00005DC8
.text$di:00005DC8 ; Attributes: bp-based frame
.text$di:00005DC8
.text$di:00005DC8 ; void __cdecl std::`dynamic initializer for '_Tuple_alloc''(void)
.text$di:00005DC8 ??__E_Tuple_alloc@std@@YAXXZ proc near  ; DATA XREF: .CRT$XCU:__Tuple_alloc$initializer$o
.text$di:00005DC8
.text$di:00005DC8 var_1           = byte ptr -1
.text$di:00005DC8
.text$di:00005DC8                 push    ebp
.text$di:00005DC9                 mov     ebp, esp
.text$di:00005DCB                 push    ecx
.text$di:00005DCC                 xor     eax, eax
.text$di:00005DCE                 mov     [ebp+var_1], al
.text$di:00005DD1                 mov     esp, ebp
.text$di:00005DD3                 pop     ebp
.text$di:00005DD4                 retn
.text$di:00005DD4 ??__E_Tuple_alloc@std@@YAXXZ endp
.text$di:00005DD4
.text$di:00005DD4 ; ---------------------------------------------------------------------------
.text$di:00005DD5                 align 4
.text$di:00005DD5 _text$di        ends
.text$di:00005DD5
.text$di:00005DD8 ; ===========================================================================
.text$di:00005DD8
.text$di:00005DD8 ; Segment type: Pure code
.text$di:00005DD8 ; Segment permissions: Read/Execute
.text$di:00005DD8 _text$di        segment para public 'CODE' use32
.text$di:00005DD8                 assume cs:_text$di
.text$di:00005DD8                 ;org 5DD8h
.text$di:00005DD8 ; COMDAT (pick any)
.text$di:00005DD8                 assume es:nothing, ss:nothing, ds:_data, fs:nothing, gs:nothing
.text$di:00005DD8
.text$di:00005DD8 ; =============== S U B R O U T I N E =======================================
.text$di:00005DD8
.text$di:00005DD8 ; Attributes: bp-based frame
.text$di:00005DD8
.text$di:00005DD8 ; void __cdecl std::`dynamic initializer for 'allocator_arg''(void)
.text$di:00005DD8 ??__Eallocator_arg@std@@YAXXZ proc near ; DATA XREF: .CRT$XCU:_allocator_arg$initializer$o
.text$di:00005DD8
.text$di:00005DD8 var_1           = byte ptr -1
.text$di:00005DD8
.text$di:00005DD8                 push    ebp
.text$di:00005DD9                 mov     ebp, esp
.text$di:00005DDB                 push    ecx
.text$di:00005DDC                 xor     eax, eax
.text$di:00005DDE                 mov     [ebp+var_1], al
.text$di:00005DE1                 mov     esp, ebp
.text$di:00005DE3                 pop     ebp
.text$di:00005DE4                 retn
.text$di:00005DE4 ??__Eallocator_arg@std@@YAXXZ endp
.text$di:00005DE4
.text$di:00005DE4 ; ---------------------------------------------------------------------------
.text$di:00005DE5                 align 4
.text$di:00005DE5 _text$di        ends
.text$di:00005DE5
.text$di:00005DE8 ; ===========================================================================
.text$di:00005DE8
.text$di:00005DE8 ; Segment type: Pure code
.text$di:00005DE8 ; Segment permissions: Read/Execute
.text$di:00005DE8 _text$di        segment para public 'CODE' use32
.text$di:00005DE8                 assume cs:_text$di
.text$di:00005DE8                 ;org 5DE8h
.text$di:00005DE8 ; COMDAT (pick any)
.text$di:00005DE8                 assume es:nothing, ss:nothing, ds:_data, fs:nothing, gs:nothing
.text$di:00005DE8
.text$di:00005DE8 ; =============== S U B R O U T I N E =======================================
.text$di:00005DE8
.text$di:00005DE8 ; Attributes: bp-based frame
.text$di:00005DE8
.text$di:00005DE8 ; void __cdecl std::`dynamic initializer for 'ignore''(void)
.text$di:00005DE8 ??__Eignore@std@@YAXXZ proc near        ; DATA XREF: .CRT$XCU:_ignore$initializer$o
.text$di:00005DE8                 push    ebp
.text$di:00005DE9                 mov     ebp, esp
.text$di:00005DEB                 mov     ecx, offset _ignore ; this
.text$di:00005DF0                 call    ??0_Ignore@std@@QAE@XZ ; std::_Ignore::_Ignore(void)
.text$di:00005DF5                 pop     ebp
.text$di:00005DF6                 retn
.text$di:00005DF6 ??__Eignore@std@@YAXXZ endp
.text$di:00005DF6
.text$di:00005DF6 ; ---------------------------------------------------------------------------
.text$di:00005DF7                 align 4
.text$di:00005DF7 _text$di        ends
.text$di:00005DF7
.text$di:00005DF8 ; ===========================================================================
.text$di:00005DF8
.text$di:00005DF8 ; Segment type: Pure code
.text$di:00005DF8 ; Segment permissions: Read/Execute
.text$di:00005DF8 _text$di        segment para public 'CODE' use32
.text$di:00005DF8                 assume cs:_text$di
.text$di:00005DF8                 ;org 5DF8h
.text$di:00005DF8 ; COMDAT (pick any)
.text$di:00005DF8                 assume es:nothing, ss:nothing, ds:_data, fs:nothing, gs:nothing
.text$di:00005DF8
.text$di:00005DF8 ; =============== S U B R O U T I N E =======================================
.text$di:00005DF8
.text$di:00005DF8 ; Attributes: bp-based frame
.text$di:00005DF8
.text$di:00005DF8 ; void __cdecl std::`dynamic initializer for 'piecewise_construct''(void)
.text$di:00005DF8 ??__Epiecewise_construct@std@@YAXXZ proc near
.text$di:00005DF8                                         ; DATA XREF: .CRT$XCU:_piecewise_construct$initializer$o
.text$di:00005DF8
.text$di:00005DF8 var_1           = byte ptr -1
.text$di:00005DF8
.text$di:00005DF8                 push    ebp
.text$di:00005DF9                 mov     ebp, esp
.text$di:00005DFB                 push    ecx
.text$di:00005DFC                 xor     eax, eax
.text$di:00005DFE                 mov     [ebp+var_1], al
.text$di:00005E01                 mov     esp, ebp
.text$di:00005E03                 pop     ebp
.text$di:00005E04                 retn
.text$di:00005E04 ??__Epiecewise_construct@std@@YAXXZ endp
.text$di:00005E04
.text$di:00005E04 ; ---------------------------------------------------------------------------
.text$di:00005E05                 align 4
.text$di:00005E05 _text$di        ends
.text$di:00005E05
.text$yd:00005E08 ; ===========================================================================
.text$yd:00005E08
.text$yd:00005E08 ; Segment type: Pure code
.text$yd:00005E08 ; Segment permissions: Read/Execute
.text$yd:00005E08 _text$yd        segment para public 'CODE' use32
.text$yd:00005E08                 assume cs:_text$yd
.text$yd:00005E08                 ;org 5E08h
.text$yd:00005E08 ; COMDAT (pick any)
.text$yd:00005E08                 assume es:nothing, ss:nothing, ds:_data, fs:nothing, gs:nothing
.text$yd:00005E08
.text$yd:00005E08 ; =============== S U B R O U T I N E =======================================
.text$yd:00005E08
.text$yd:00005E08 ; Attributes: bp-based frame
.text$yd:00005E08
.text$yd:00005E08 ; void __cdecl `dynamic atexit destructor for 'public: static std::_Generic_error_category std::_Error_objects<int>::_Generic_object''()
.text$yd:00005E08 ??__F?_Generic_object@?$_Error_objects@H@std@@2V_Generic_error_category@2@A@@YAXXZ proc near
.text$yd:00005E08                                         ; DATA XREF: `dynamic initializer for 'std::_Generic_error_category std::_Error_objects<int>::_Generic_object''(void)+Do
.text$yd:00005E08                 push    ebp
.text$yd:00005E09                 mov     ebp, esp
.text$yd:00005E0B                 mov     ecx, offset ?_Generic_object@?$_Error_objects@H@std@@2V_Generic_error_category@2@A ; this
.text$yd:00005E10                 call    ??1_Generic_error_category@std@@UAE@XZ ; std::_Generic_error_category::~_Generic_error_category(void)
.text$yd:00005E15                 pop     ebp
.text$yd:00005E16                 retn
.text$yd:00005E16 ??__F?_Generic_object@?$_Error_objects@H@std@@2V_Generic_error_category@2@A@@YAXXZ endp
.text$yd:00005E16
.text$yd:00005E16 ; ---------------------------------------------------------------------------
.text$yd:00005E17                 align 4
.text$yd:00005E17 _text$yd        ends
.text$yd:00005E17
.text$yd:00005E18 ; ===========================================================================
.text$yd:00005E18
.text$yd:00005E18 ; Segment type: Pure code
.text$yd:00005E18 ; Segment permissions: Read/Execute
.text$yd:00005E18 _text$yd        segment para public 'CODE' use32
.text$yd:00005E18                 assume cs:_text$yd
.text$yd:00005E18                 ;org 5E18h
.text$yd:00005E18 ; COMDAT (pick any)
.text$yd:00005E18                 assume es:nothing, ss:nothing, ds:_data, fs:nothing, gs:nothing
.text$yd:00005E18
.text$yd:00005E18 ; =============== S U B R O U T I N E =======================================
.text$yd:00005E18
.text$yd:00005E18 ; Attributes: bp-based frame
.text$yd:00005E18
.text$yd:00005E18 ; void __cdecl `dynamic atexit destructor for 'public: static std::_Iostream_error_category std::_Error_objects<int>::_Iostream_object''()
.text$yd:00005E18 ??__F?_Iostream_object@?$_Error_objects@H@std@@2V_Iostream_error_category@2@A@@YAXXZ proc near
.text$yd:00005E18                                         ; DATA XREF: `dynamic initializer for 'std::_Iostream_error_category std::_Error_objects<int>::_Iostream_object''(void)+Do
.text$yd:00005E18                 push    ebp
.text$yd:00005E19                 mov     ebp, esp
.text$yd:00005E1B                 mov     ecx, offset ?_Iostream_object@?$_Error_objects@H@std@@2V_Iostream_error_category@2@A ; this
.text$yd:00005E20                 call    ??1_Iostream_error_category@std@@UAE@XZ ; std::_Iostream_error_category::~_Iostream_error_category(void)
.text$yd:00005E25                 pop     ebp
.text$yd:00005E26                 retn
.text$yd:00005E26 ??__F?_Iostream_object@?$_Error_objects@H@std@@2V_Iostream_error_category@2@A@@YAXXZ endp
.text$yd:00005E26
.text$yd:00005E26 ; ---------------------------------------------------------------------------
.text$yd:00005E27                 align 4
.text$yd:00005E27 _text$yd        ends
.text$yd:00005E27
.text$yd:00005E28 ; ===========================================================================
.text$yd:00005E28
.text$yd:00005E28 ; Segment type: Pure code
.text$yd:00005E28 ; Segment permissions: Read/Execute
.text$yd:00005E28 _text$yd        segment para public 'CODE' use32
.text$yd:00005E28                 assume cs:_text$yd
.text$yd:00005E28                 ;org 5E28h
.text$yd:00005E28 ; COMDAT (pick any)
.text$yd:00005E28                 assume es:nothing, ss:nothing, ds:_data, fs:nothing, gs:nothing
.text$yd:00005E28
.text$yd:00005E28 ; =============== S U B R O U T I N E =======================================
.text$yd:00005E28
.text$yd:00005E28 ; Attributes: bp-based frame
.text$yd:00005E28
.text$yd:00005E28 ; void __cdecl `dynamic atexit destructor for 'public: static std::_System_error_category std::_Error_objects<int>::_System_object''()
.text$yd:00005E28 ??__F?_System_object@?$_Error_objects@H@std@@2V_System_error_category@2@A@@YAXXZ proc near
.text$yd:00005E28                                         ; DATA XREF: `dynamic initializer for 'std::_System_error_category std::_Error_objects<int>::_System_object''(void)+Do
.text$yd:00005E28                 push    ebp
.text$yd:00005E29                 mov     ebp, esp
.text$yd:00005E2B                 mov     ecx, offset ?_System_object@?$_Error_objects@H@std@@2V_System_error_category@2@A ; this
.text$yd:00005E30                 call    ??1_System_error_category@std@@UAE@XZ ; std::_System_error_category::~_System_error_category(void)
.text$yd:00005E35                 pop     ebp
.text$yd:00005E36                 retn
.text$yd:00005E36 ??__F?_System_object@?$_Error_objects@H@std@@2V_System_error_category@2@A@@YAXXZ endp
.text$yd:00005E36
.text$yd:00005E36 ; ---------------------------------------------------------------------------
.text$yd:00005E37                 align 4
.text$yd:00005E37 _text$yd        ends
.text$yd:00005E37
.text$mn:00005E38 ; ===========================================================================
.text$mn:00005E38
.text$mn:00005E38 ; Segment type: Pure code
.text$mn:00005E38 ; Segment permissions: Read/Execute
.text$mn:00005E38 _text$mn        segment para public 'CODE' use32
.text$mn:00005E38                 assume cs:_text$mn
.text$mn:00005E38                 ;org 5E38h
.text$mn:00005E38 ; COMDAT (pick any)
.text$mn:00005E38                 assume es:nothing, ss:nothing, ds:_data, fs:nothing, gs:nothing
.text$mn:00005E38
.text$mn:00005E38 ; =============== S U B R O U T I N E =======================================
.text$mn:00005E38
.text$mn:00005E38 ; Attributes: bp-based frame
.text$mn:00005E38
.text$mn:00005E38 ; void __thiscall std::_Iterator_base12::_Adopt(std::_Iterator_base12 *this, const struct std::_Container_base12 *)
.text$mn:00005E38                 public ?_Adopt@_Iterator_base12@std@@QAEXPBU_Container_base12@2@@Z
.text$mn:00005E38 ?_Adopt@_Iterator_base12@std@@QAEXPBU_Container_base12@2@@Z proc near
.text$mn:00005E38                                         ; CODE XREF: std::_Vector_const_iterator<std::_Vector_val<std::_Simple_types<wchar_t const *>>>::_Vector_const_iterator<std::_Vector_val<std::_Simple_types<wchar_t const *>>>(wchar_t const * *,std::_Container_base12 const *)+45p
.text$mn:00005E38                                         ; std::_Vector_const_iterator<std::_Vector_val<std::_Simple_types<FunctionValues>>>::_Vector_const_iterator<std::_Vector_val<std::_Simple_types<FunctionValues>>>(FunctionValues *,std::_Container_base12 const *)+45p ...
.text$mn:00005E38
.text$mn:00005E38 var_1C          = byte ptr -1Ch
.text$mn:00005E38 var_18          = byte ptr -18h
.text$mn:00005E38 var_14          = dword ptr -14h
.text$mn:00005E38 var_10          = dword ptr -10h
.text$mn:00005E38 var_C           = dword ptr -0Ch
.text$mn:00005E38 var_4           = dword ptr -4
.text$mn:00005E38 arg_0           = dword ptr  8
.text$mn:00005E38
.text$mn:00005E38                 push    ebp
.text$mn:00005E39                 mov     ebp, esp
.text$mn:00005E3B                 push    0FFFFFFFFh
.text$mn:00005E3D                 push    offset __ehhandler$?_Adopt@_Iterator_base12@std@@QAEXPBU_Container_base12@2@@Z
.text$mn:00005E42                 mov     eax, large fs:0
.text$mn:00005E48                 push    eax
.text$mn:00005E49                 sub     esp, 10h
.text$mn:00005E4C                 mov     eax, dword ptr ds:___security_cookie
.text$mn:00005E51                 xor     eax, ebp
.text$mn:00005E53                 push    eax
.text$mn:00005E54                 lea     eax, [ebp+var_C]
.text$mn:00005E57                 mov     large fs:0, eax
.text$mn:00005E5D                 mov     [ebp+var_10], ecx
.text$mn:00005E60                 cmp     [ebp+arg_0], 0
.text$mn:00005E64                 jnz     short loc_5E90
.text$mn:00005E66                 push    3               ; int
.text$mn:00005E68                 lea     ecx, [ebp+var_18] ; this
.text$mn:00005E6B                 call    ??0_Lockit@std@@QAE@H@Z ; std::_Lockit::_Lockit(int)
.text$mn:00005E70                 mov     [ebp+var_4], 0
.text$mn:00005E77                 mov     ecx, [ebp+var_10] ; this
.text$mn:00005E7A                 call    ?_Orphan_me@_Iterator_base12@std@@QAEXXZ ; std::_Iterator_base12::_Orphan_me(void)
.text$mn:00005E7F                 mov     [ebp+var_4], 0FFFFFFFFh
.text$mn:00005E86                 lea     ecx, [ebp+var_18] ; this
.text$mn:00005E89                 call    ??1_Lockit@std@@QAE@XZ ; std::_Lockit::~_Lockit(void)
.text$mn:00005E8E                 jmp     short loc_5EE7
.text$mn:00005E90 ; ---------------------------------------------------------------------------
.text$mn:00005E90
.text$mn:00005E90 loc_5E90:                               ; CODE XREF: std::_Iterator_base12::_Adopt(std::_Container_base12 const *)+2Cj
.text$mn:00005E90                 mov     eax, [ebp+arg_0]
.text$mn:00005E93                 mov     ecx, [eax]
.text$mn:00005E95                 mov     [ebp+var_14], ecx
.text$mn:00005E98                 mov     edx, [ebp+var_10]
.text$mn:00005E9B                 mov     eax, [edx]
.text$mn:00005E9D                 cmp     eax, [ebp+var_14]
.text$mn:00005EA0                 jz      short loc_5EE7
.text$mn:00005EA2                 push    3               ; int
.text$mn:00005EA4                 lea     ecx, [ebp+var_1C] ; this
.text$mn:00005EA7                 call    ??0_Lockit@std@@QAE@H@Z ; std::_Lockit::_Lockit(int)
.text$mn:00005EAC                 mov     [ebp+var_4], 1
.text$mn:00005EB3                 mov     ecx, [ebp+var_10] ; this
.text$mn:00005EB6                 call    ?_Orphan_me@_Iterator_base12@std@@QAEXXZ ; std::_Iterator_base12::_Orphan_me(void)
.text$mn:00005EBB                 mov     ecx, [ebp+var_10]
.text$mn:00005EBE                 mov     edx, [ebp+var_14]
.text$mn:00005EC1                 mov     eax, [edx+4]
.text$mn:00005EC4                 mov     [ecx+4], eax
.text$mn:00005EC7                 mov     ecx, [ebp+var_14]
.text$mn:00005ECA                 mov     edx, [ebp+var_10]
.text$mn:00005ECD                 mov     [ecx+4], edx
.text$mn:00005ED0                 mov     eax, [ebp+var_10]
.text$mn:00005ED3                 mov     ecx, [ebp+var_14]
.text$mn:00005ED6                 mov     [eax], ecx
.text$mn:00005ED8                 mov     [ebp+var_4], 0FFFFFFFFh
.text$mn:00005EDF                 lea     ecx, [ebp+var_1C] ; this
.text$mn:00005EE2                 call    ??1_Lockit@std@@QAE@XZ ; std::_Lockit::~_Lockit(void)
.text$mn:00005EE7
.text$mn:00005EE7 loc_5EE7:                               ; CODE XREF: std::_Iterator_base12::_Adopt(std::_Container_base12 const *)+56j
.text$mn:00005EE7                                         ; std::_Iterator_base12::_Adopt(std::_Container_base12 const *)+68j
.text$mn:00005EE7                 mov     ecx, [ebp+var_C]
.text$mn:00005EEA                 mov     large fs:0, ecx
.text$mn:00005EF1                 pop     ecx
.text$mn:00005EF2                 mov     esp, ebp
.text$mn:00005EF4                 pop     ebp
.text$mn:00005EF5                 retn    4
.text$mn:00005EF5 ?_Adopt@_Iterator_base12@std@@QAEXPBU_Container_base12@2@@Z endp
.text$mn:00005EF5
.text$mn:00005EF5 _text$mn        ends
.text$mn:00005EF5
.text$x:00005EF8 ; ===========================================================================
.text$x:00005EF8
.text$x:00005EF8 ; Segment type: Pure code
.text$x:00005EF8 ; Segment permissions: Read/Execute
.text$x:00005EF8 _text$x         segment para public 'CODE' use32
.text$x:00005EF8                 assume cs:_text$x
.text$x:00005EF8                 ;org 5EF8h
.text$x:00005EF8 ; COMDAT (pick associative to section at 5E38)
.text$x:00005EF8                 assume es:nothing, ss:nothing, ds:_data, fs:nothing, gs:nothing
.text$x:00005EF8
.text$x:00005EF8 ; =============== S U B R O U T I N E =======================================
.text$x:00005EF8
.text$x:00005EF8
.text$x:00005EF8 __unwindfunclet$?_Adopt@_Iterator_base12@std@@QAEXPBU_Container_base12@2@@Z$0 proc near
.text$x:00005EF8                                         ; DATA XREF: .xdata$x:000092D4o
.text$x:00005EF8                 lea     ecx, [ebp-18h]  ; this
.text$x:00005EFB                 jmp     ??1_Lockit@std@@QAE@XZ ; std::_Lockit::~_Lockit(void)
.text$x:00005EFB __unwindfunclet$?_Adopt@_Iterator_base12@std@@QAEXPBU_Container_base12@2@@Z$0 endp
.text$x:00005EFB
.text$x:00005F00
.text$x:00005F00 ; =============== S U B R O U T I N E =======================================
.text$x:00005F00
.text$x:00005F00
.text$x:00005F00 __unwindfunclet$?_Adopt@_Iterator_base12@std@@QAEXPBU_Container_base12@2@@Z$1 proc near
.text$x:00005F00                                         ; DATA XREF: .xdata$x:000092DCo
.text$x:00005F00                 lea     ecx, [ebp-1Ch]  ; this
.text$x:00005F03                 jmp     ??1_Lockit@std@@QAE@XZ ; std::_Lockit::~_Lockit(void)
.text$x:00005F03 __unwindfunclet$?_Adopt@_Iterator_base12@std@@QAEXPBU_Container_base12@2@@Z$1 endp
.text$x:00005F03
.text$x:00005F08
.text$x:00005F08 ; =============== S U B R O U T I N E =======================================
.text$x:00005F08
.text$x:00005F08
.text$x:00005F08 __ehhandler$?_Adopt@_Iterator_base12@std@@QAEXPBU_Container_base12@2@@Z proc near
.text$x:00005F08                                         ; DATA XREF: std::_Iterator_base12::_Adopt(std::_Container_base12 const *)+5o
.text$x:00005F08
.text$x:00005F08 arg_4           = dword ptr  8
.text$x:00005F08
.text$x:00005F08                 mov     edx, [esp+arg_4]
.text$x:00005F0C                 lea     eax, [edx+0Ch]
.text$x:00005F0F                 mov     ecx, [edx-14h]
.text$x:00005F12                 xor     ecx, eax
.text$x:00005F14                 call    @__security_check_cookie@4 ; __security_check_cookie(x)
.text$x:00005F19                 mov     eax, offset __ehfuncinfo$?_Adopt@_Iterator_base12@std@@QAEXPBU_Container_base12@2@@Z
.text$x:00005F1E                 jmp     ___CxxFrameHandler3
.text$x:00005F1E __ehhandler$?_Adopt@_Iterator_base12@std@@QAEXPBU_Container_base12@2@@Z endp
.text$x:00005F1E
.text$x:00005F1E ; ---------------------------------------------------------------------------
.text$x:00005F23                 align 4
.text$x:00005F23 _text$x         ends
.text$x:00005F23
.text$mn:00005F24 ; ===========================================================================
.text$mn:00005F24
.text$mn:00005F24 ; Segment type: Pure code
.text$mn:00005F24 ; Segment permissions: Read/Execute
.text$mn:00005F24 _text$mn        segment para public 'CODE' use32
.text$mn:00005F24                 assume cs:_text$mn
.text$mn:00005F24                 ;org 5F24h
.text$mn:00005F24 ; COMDAT (pick any)
.text$mn:00005F24                 assume es:nothing, ss:nothing, ds:_data, fs:nothing, gs:nothing
.text$mn:00005F24
.text$mn:00005F24 ; =============== S U B R O U T I N E =======================================
.text$mn:00005F24
.text$mn:00005F24 ; Attributes: bp-based frame
.text$mn:00005F24
.text$mn:00005F24 ; public: void __thiscall std::_String_alloc<0, struct std::_String_base_types<char, class std::allocator<char>>>::_Alloc_proxy(void)
.text$mn:00005F24                 public ?_Alloc_proxy@?$_String_alloc@$0A@U?$_String_base_types@DV?$allocator@D@std@@@std@@@std@@QAEXXZ
.text$mn:00005F24 ?_Alloc_proxy@?$_String_alloc@$0A@U?$_String_base_types@DV?$allocator@D@std@@@std@@@std@@QAEXXZ proc near
.text$mn:00005F24                                         ; CODE XREF: std::_String_alloc<0,std::_String_base_types<char,std::allocator<char>>>::_String_alloc<0,std::_String_base_types<char,std::allocator<char>>>(std::allocator<char> const &)+38p
.text$mn:00005F24
.text$mn:00005F24 var_10          = byte ptr -10h
.text$mn:00005F24 var_8           = dword ptr -8
.text$mn:00005F24 var_1           = byte ptr -1
.text$mn:00005F24
.text$mn:00005F24                 push    ebp
.text$mn:00005F25                 mov     ebp, esp
.text$mn:00005F27                 sub     esp, 10h
.text$mn:00005F2A                 mov     [ebp+var_8], ecx
.text$mn:00005F2D                 lea     ecx, [ebp+var_1]
.text$mn:00005F30                 call    ??0?$allocator@U_Container_proxy@std@@@std@@QAE@XZ ; std::allocator<std::_Container_proxy>::allocator<std::_Container_proxy>(void)
.text$mn:00005F35                 push    1
.text$mn:00005F37                 lea     ecx, [ebp+var_1]
.text$mn:00005F3A                 call    ?allocate@?$allocator@U_Container_proxy@std@@@std@@QAEPAU_Container_proxy@2@I@Z ; std::allocator<std::_Container_proxy>::allocate(uint)
.text$mn:00005F3F                 mov     ecx, [ebp+var_8]
.text$mn:00005F42                 mov     [ecx], eax
.text$mn:00005F44                 lea     ecx, [ebp+var_10] ; this
.text$mn:00005F47                 call    ??0_Container_proxy@std@@QAE@XZ ; std::_Container_proxy::_Container_proxy(void)
.text$mn:00005F4C                 push    eax             ; int
.text$mn:00005F4D                 mov     edx, [ebp+var_8]
.text$mn:00005F50                 mov     eax, [edx]
.text$mn:00005F52                 push    eax             ; void *
.text$mn:00005F53                 lea     ecx, [ebp+var_1]
.text$mn:00005F56                 call    ??$construct@U_Container_proxy@std@@U12@@?$allocator@U_Container_proxy@std@@@std@@QAEXPAU_Container_proxy@1@$$QAU21@@Z ; std::allocator<std::_Container_proxy>::construct<std::_Container_proxy,std::_Container_proxy>(std::_Container_proxy *,std::_Container_proxy &&)
.text$mn:00005F5B                 mov     ecx, [ebp+var_8]
.text$mn:00005F5E                 mov     edx, [ecx]
.text$mn:00005F60                 mov     eax, [ebp+var_8]
.text$mn:00005F63                 mov     [edx], eax
.text$mn:00005F65                 mov     esp, ebp
.text$mn:00005F67                 pop     ebp
.text$mn:00005F68                 retn
.text$mn:00005F68 ?_Alloc_proxy@?$_String_alloc@$0A@U?$_String_base_types@DV?$allocator@D@std@@@std@@@std@@QAEXXZ endp
.text$mn:00005F68
.text$mn:00005F68 ; ---------------------------------------------------------------------------
.text$mn:00005F69                 align 4
.text$mn:00005F69 _text$mn        ends
.text$mn:00005F69
.text$mn:00005F6C ; ===========================================================================
.text$mn:00005F6C
.text$mn:00005F6C ; Segment type: Pure code
.text$mn:00005F6C ; Segment permissions: Read/Execute
.text$mn:00005F6C _text$mn        segment para public 'CODE' use32
.text$mn:00005F6C                 assume cs:_text$mn
.text$mn:00005F6C                 ;org 5F6Ch
.text$mn:00005F6C ; COMDAT (pick any)
.text$mn:00005F6C                 assume es:nothing, ss:nothing, ds:_data, fs:nothing, gs:nothing
.text$mn:00005F6C
.text$mn:00005F6C ; =============== S U B R O U T I N E =======================================
.text$mn:00005F6C
.text$mn:00005F6C ; Attributes: bp-based frame
.text$mn:00005F6C
.text$mn:00005F6C ; public: void __thiscall std::_Vector_alloc<0, struct std::_Vec_base_types<wchar_t const *, class std::allocator<wchar_t const *>>>::_Alloc_proxy(void)
.text$mn:00005F6C                 public ?_Alloc_proxy@?$_Vector_alloc@$0A@U?$_Vec_base_types@PB_WV?$allocator@PB_W@std@@@std@@@std@@QAEXXZ
.text$mn:00005F6C ?_Alloc_proxy@?$_Vector_alloc@$0A@U?$_Vec_base_types@PB_WV?$allocator@PB_W@std@@@std@@@std@@QAEXXZ proc near
.text$mn:00005F6C                                         ; CODE XREF: std::_Vector_alloc<0,std::_Vec_base_types<wchar_t const *,std::allocator<wchar_t const *>>>::_Vector_alloc<0,std::_Vec_base_types<wchar_t const *,std::allocator<wchar_t const *>>>(std::allocator<wchar_t const *> const &)+38p
.text$mn:00005F6C
.text$mn:00005F6C var_10          = byte ptr -10h
.text$mn:00005F6C var_8           = dword ptr -8
.text$mn:00005F6C var_1           = byte ptr -1
.text$mn:00005F6C
.text$mn:00005F6C                 push    ebp
.text$mn:00005F6D                 mov     ebp, esp
.text$mn:00005F6F                 sub     esp, 10h
.text$mn:00005F72                 mov     [ebp+var_8], ecx
.text$mn:00005F75                 lea     ecx, [ebp+var_1]
.text$mn:00005F78                 call    ??0?$_Wrap_alloc@V?$allocator@U_Container_proxy@std@@@std@@@std@@QAE@XZ ; std::_Wrap_alloc<std::allocator<std::_Container_proxy>>::_Wrap_alloc<std::allocator<std::_Container_proxy>>(void)
.text$mn:00005F7D                 push    1
.text$mn:00005F7F                 lea     ecx, [ebp+var_1]
.text$mn:00005F82                 call    ?allocate@?$_Wrap_alloc@V?$allocator@U_Container_proxy@std@@@std@@@std@@QAEPAU_Container_proxy@2@I@Z ; std::_Wrap_alloc<std::allocator<std::_Container_proxy>>::allocate(uint)
.text$mn:00005F87                 mov     ecx, [ebp+var_8]
.text$mn:00005F8A                 mov     [ecx], eax
.text$mn:00005F8C                 lea     ecx, [ebp+var_10] ; this
.text$mn:00005F8F                 call    ??0_Container_proxy@std@@QAE@XZ ; std::_Container_proxy::_Container_proxy(void)
.text$mn:00005F94                 push    eax             ; int
.text$mn:00005F95                 mov     edx, [ebp+var_8]
.text$mn:00005F98                 mov     eax, [edx]
.text$mn:00005F9A                 push    eax             ; void *
.text$mn:00005F9B                 lea     ecx, [ebp+var_1]
.text$mn:00005F9E                 call    ??$construct@U_Container_proxy@std@@U12@@?$_Wrap_alloc@V?$allocator@U_Container_proxy@std@@@std@@@std@@QAEXPAU_Container_proxy@1@$$QAU21@@Z ; std::_Wrap_alloc<std::allocator<std::_Container_proxy>>::construct<std::_Container_proxy,std::_Container_proxy>(std::_Container_proxy *,std::_Container_proxy &&)
.text$mn:00005FA3                 mov     ecx, [ebp+var_8]
.text$mn:00005FA6                 mov     edx, [ecx]
.text$mn:00005FA8                 mov     eax, [ebp+var_8]
.text$mn:00005FAB                 mov     [edx], eax
.text$mn:00005FAD                 mov     esp, ebp
.text$mn:00005FAF                 pop     ebp
.text$mn:00005FB0                 retn
.text$mn:00005FB0 ?_Alloc_proxy@?$_Vector_alloc@$0A@U?$_Vec_base_types@PB_WV?$allocator@PB_W@std@@@std@@@std@@QAEXXZ endp
.text$mn:00005FB0
.text$mn:00005FB0 ; ---------------------------------------------------------------------------
.text$mn:00005FB1                 align 4
.text$mn:00005FB1 _text$mn        ends
.text$mn:00005FB1
.text$mn:00005FB4 ; ===========================================================================
.text$mn:00005FB4
.text$mn:00005FB4 ; Segment type: Pure code
.text$mn:00005FB4 ; Segment permissions: Read/Execute
.text$mn:00005FB4 _text$mn        segment para public 'CODE' use32
.text$mn:00005FB4                 assume cs:_text$mn
.text$mn:00005FB4                 ;org 5FB4h
.text$mn:00005FB4 ; COMDAT (pick any)
.text$mn:00005FB4                 assume es:nothing, ss:nothing, ds:_data, fs:nothing, gs:nothing
.text$mn:00005FB4
.text$mn:00005FB4 ; =============== S U B R O U T I N E =======================================
.text$mn:00005FB4
.text$mn:00005FB4 ; Attributes: bp-based frame
.text$mn:00005FB4
.text$mn:00005FB4 ; public: void __thiscall std::_Vector_alloc<0, struct std::_Vec_base_types<struct FunctionValues, class std::allocator<struct FunctionValues>>>::_Alloc_proxy(void)
.text$mn:00005FB4                 public ?_Alloc_proxy@?$_Vector_alloc@$0A@U?$_Vec_base_types@UFunctionValues@@V?$allocator@UFunctionValues@@@std@@@std@@@std@@QAEXXZ
.text$mn:00005FB4 ?_Alloc_proxy@?$_Vector_alloc@$0A@U?$_Vec_base_types@UFunctionValues@@V?$allocator@UFunctionValues@@@std@@@std@@@std@@QAEXXZ proc near
.text$mn:00005FB4                                         ; CODE XREF: std::_Vector_alloc<0,std::_Vec_base_types<FunctionValues,std::allocator<FunctionValues>>>::_Vector_alloc<0,std::_Vec_base_types<FunctionValues,std::allocator<FunctionValues>>>(std::allocator<FunctionValues> const &)+38p
.text$mn:00005FB4
.text$mn:00005FB4 var_10          = byte ptr -10h
.text$mn:00005FB4 var_8           = dword ptr -8
.text$mn:00005FB4 var_1           = byte ptr -1
.text$mn:00005FB4
.text$mn:00005FB4                 push    ebp
.text$mn:00005FB5                 mov     ebp, esp
.text$mn:00005FB7                 sub     esp, 10h
.text$mn:00005FBA                 mov     [ebp+var_8], ecx
.text$mn:00005FBD                 lea     ecx, [ebp+var_1]
.text$mn:00005FC0                 call    ??0?$_Wrap_alloc@V?$allocator@U_Container_proxy@std@@@std@@@std@@QAE@XZ ; std::_Wrap_alloc<std::allocator<std::_Container_proxy>>::_Wrap_alloc<std::allocator<std::_Container_proxy>>(void)
.text$mn:00005FC5                 push    1
.text$mn:00005FC7                 lea     ecx, [ebp+var_1]
.text$mn:00005FCA                 call    ?allocate@?$_Wrap_alloc@V?$allocator@U_Container_proxy@std@@@std@@@std@@QAEPAU_Container_proxy@2@I@Z ; std::_Wrap_alloc<std::allocator<std::_Container_proxy>>::allocate(uint)
.text$mn:00005FCF                 mov     ecx, [ebp+var_8]
.text$mn:00005FD2                 mov     [ecx], eax
.text$mn:00005FD4                 lea     ecx, [ebp+var_10] ; this
.text$mn:00005FD7                 call    ??0_Container_proxy@std@@QAE@XZ ; std::_Container_proxy::_Container_proxy(void)
.text$mn:00005FDC                 push    eax             ; int
.text$mn:00005FDD                 mov     edx, [ebp+var_8]
.text$mn:00005FE0                 mov     eax, [edx]
.text$mn:00005FE2                 push    eax             ; void *
.text$mn:00005FE3                 lea     ecx, [ebp+var_1]
.text$mn:00005FE6                 call    ??$construct@U_Container_proxy@std@@U12@@?$_Wrap_alloc@V?$allocator@U_Container_proxy@std@@@std@@@std@@QAEXPAU_Container_proxy@1@$$QAU21@@Z ; std::_Wrap_alloc<std::allocator<std::_Container_proxy>>::construct<std::_Container_proxy,std::_Container_proxy>(std::_Container_proxy *,std::_Container_proxy &&)
.text$mn:00005FEB                 mov     ecx, [ebp+var_8]
.text$mn:00005FEE                 mov     edx, [ecx]
.text$mn:00005FF0                 mov     eax, [ebp+var_8]
.text$mn:00005FF3                 mov     [edx], eax
.text$mn:00005FF5                 mov     esp, ebp
.text$mn:00005FF7                 pop     ebp
.text$mn:00005FF8                 retn
.text$mn:00005FF8 ?_Alloc_proxy@?$_Vector_alloc@$0A@U?$_Vec_base_types@UFunctionValues@@V?$allocator@UFunctionValues@@@std@@@std@@@std@@QAEXXZ endp
.text$mn:00005FF8
.text$mn:00005FF8 ; ---------------------------------------------------------------------------
.text$mn:00005FF9                 align 4
.text$mn:00005FF9 _text$mn        ends
.text$mn:00005FF9
.text$mn:00005FFC ; ===========================================================================
.text$mn:00005FFC
.text$mn:00005FFC ; Segment type: Pure code
.text$mn:00005FFC ; Segment permissions: Read/Execute
.text$mn:00005FFC _text$mn        segment para public 'CODE' use32
.text$mn:00005FFC                 assume cs:_text$mn
.text$mn:00005FFC                 ;org 5FFCh
.text$mn:00005FFC ; COMDAT (pick any)
.text$mn:00005FFC                 assume es:nothing, ss:nothing, ds:_data, fs:nothing, gs:nothing
.text$mn:00005FFC
.text$mn:00005FFC ; =============== S U B R O U T I N E =======================================
.text$mn:00005FFC
.text$mn:00005FFC ; Attributes: bp-based frame
.text$mn:00005FFC
.text$mn:00005FFC ; public: void __thiscall std::_Vector_alloc<0, struct std::_Vec_base_types<struct Token, class std::allocator<struct Token>>>::_Alloc_proxy(void)
.text$mn:00005FFC                 public ?_Alloc_proxy@?$_Vector_alloc@$0A@U?$_Vec_base_types@UToken@@V?$allocator@UToken@@@std@@@std@@@std@@QAEXXZ
.text$mn:00005FFC ?_Alloc_proxy@?$_Vector_alloc@$0A@U?$_Vec_base_types@UToken@@V?$allocator@UToken@@@std@@@std@@@std@@QAEXXZ proc near
.text$mn:00005FFC                                         ; CODE XREF: std::_Vector_alloc<0,std::_Vec_base_types<Token,std::allocator<Token>>>::_Vector_alloc<0,std::_Vec_base_types<Token,std::allocator<Token>>>(std::allocator<Token> const &)+38p
.text$mn:00005FFC
.text$mn:00005FFC var_10          = byte ptr -10h
.text$mn:00005FFC var_8           = dword ptr -8
.text$mn:00005FFC var_1           = byte ptr -1
.text$mn:00005FFC
.text$mn:00005FFC                 push    ebp
.text$mn:00005FFD                 mov     ebp, esp
.text$mn:00005FFF                 sub     esp, 10h
.text$mn:00006002                 mov     [ebp+var_8], ecx
.text$mn:00006005                 lea     ecx, [ebp+var_1]
.text$mn:00006008                 call    ??0?$_Wrap_alloc@V?$allocator@U_Container_proxy@std@@@std@@@std@@QAE@XZ ; std::_Wrap_alloc<std::allocator<std::_Container_proxy>>::_Wrap_alloc<std::allocator<std::_Container_proxy>>(void)
.text$mn:0000600D                 push    1
.text$mn:0000600F                 lea     ecx, [ebp+var_1]
.text$mn:00006012                 call    ?allocate@?$_Wrap_alloc@V?$allocator@U_Container_proxy@std@@@std@@@std@@QAEPAU_Container_proxy@2@I@Z ; std::_Wrap_alloc<std::allocator<std::_Container_proxy>>::allocate(uint)
.text$mn:00006017                 mov     ecx, [ebp+var_8]
.text$mn:0000601A                 mov     [ecx], eax
.text$mn:0000601C                 lea     ecx, [ebp+var_10] ; this
.text$mn:0000601F                 call    ??0_Container_proxy@std@@QAE@XZ ; std::_Container_proxy::_Container_proxy(void)
.text$mn:00006024                 push    eax             ; int
.text$mn:00006025                 mov     edx, [ebp+var_8]
.text$mn:00006028                 mov     eax, [edx]
.text$mn:0000602A                 push    eax             ; void *
.text$mn:0000602B                 lea     ecx, [ebp+var_1]
.text$mn:0000602E                 call    ??$construct@U_Container_proxy@std@@U12@@?$_Wrap_alloc@V?$allocator@U_Container_proxy@std@@@std@@@std@@QAEXPAU_Container_proxy@1@$$QAU21@@Z ; std::_Wrap_alloc<std::allocator<std::_Container_proxy>>::construct<std::_Container_proxy,std::_Container_proxy>(std::_Container_proxy *,std::_Container_proxy &&)
.text$mn:00006033                 mov     ecx, [ebp+var_8]
.text$mn:00006036                 mov     edx, [ecx]
.text$mn:00006038                 mov     eax, [ebp+var_8]
.text$mn:0000603B                 mov     [edx], eax
.text$mn:0000603D                 mov     esp, ebp
.text$mn:0000603F                 pop     ebp
.text$mn:00006040                 retn
.text$mn:00006040 ?_Alloc_proxy@?$_Vector_alloc@$0A@U?$_Vec_base_types@UToken@@V?$allocator@UToken@@@std@@@std@@@std@@QAEXXZ endp
.text$mn:00006040
.text$mn:00006040 ; ---------------------------------------------------------------------------
.text$mn:00006041                 align 4
.text$mn:00006041 _text$mn        ends
.text$mn:00006041
.text$mn:00006044 ; ===========================================================================
.text$mn:00006044
.text$mn:00006044 ; Segment type: Pure code
.text$mn:00006044 ; Segment permissions: Read/Execute
.text$mn:00006044 _text$mn        segment para public 'CODE' use32
.text$mn:00006044                 assume cs:_text$mn
.text$mn:00006044                 ;org 6044h
.text$mn:00006044 ; COMDAT (pick any)
.text$mn:00006044                 assume es:nothing, ss:nothing, ds:_data, fs:nothing, gs:nothing
.text$mn:00006044
.text$mn:00006044 ; =============== S U B R O U T I N E =======================================
.text$mn:00006044
.text$mn:00006044 ; Attributes: bp-based frame
.text$mn:00006044
.text$mn:00006044 ; int __stdcall std::vector<wchar_t const *,std::allocator<wchar_t const *>>::_Assign_rv(struct std::_Container_base12 *, int)
.text$mn:00006044                 public ?_Assign_rv@?$vector@PB_WV?$allocator@PB_W@std@@@std@@QAEX$$QAV12@U?$integral_constant@_N$00@2@@Z
.text$mn:00006044 ?_Assign_rv@?$vector@PB_WV?$allocator@PB_W@std@@@std@@QAEX$$QAV12@U?$integral_constant@_N$00@2@@Z proc near
.text$mn:00006044                                         ; CODE XREF: std::vector<wchar_t const *,std::allocator<wchar_t const *>>::vector<wchar_t const *,std::allocator<wchar_t const *>>(std::vector<wchar_t const *,std::allocator<wchar_t const *>> &&)+5Ep
.text$mn:00006044
.text$mn:00006044 var_4           = dword ptr -4
.text$mn:00006044 arg_0           = dword ptr  8
.text$mn:00006044
.text$mn:00006044                 push    ebp
.text$mn:00006045                 mov     ebp, esp
.text$mn:00006047                 push    ecx
.text$mn:00006048                 mov     [ebp+var_4], ecx
.text$mn:0000604B                 mov     eax, [ebp+arg_0]
.text$mn:0000604E                 push    eax             ; struct std::_Container_base12 *
.text$mn:0000604F                 mov     ecx, [ebp+var_4] ; this
.text$mn:00006052                 call    ?_Swap_all@_Container_base12@std@@QAEXAAU12@@Z ; std::_Container_base12::_Swap_all(std::_Container_base12 &)
.text$mn:00006057                 mov     ecx, [ebp+var_4]
.text$mn:0000605A                 mov     edx, [ebp+arg_0]
.text$mn:0000605D                 mov     eax, [edx+4]
.text$mn:00006060                 mov     [ecx+4], eax
.text$mn:00006063                 mov     ecx, [ebp+var_4]
.text$mn:00006066                 mov     edx, [ebp+arg_0]
.text$mn:00006069                 mov     eax, [edx+8]
.text$mn:0000606C                 mov     [ecx+8], eax
.text$mn:0000606F                 mov     ecx, [ebp+var_4]
.text$mn:00006072                 mov     edx, [ebp+arg_0]
.text$mn:00006075                 mov     eax, [edx+0Ch]
.text$mn:00006078                 mov     [ecx+0Ch], eax
.text$mn:0000607B                 mov     ecx, [ebp+arg_0]
.text$mn:0000607E                 mov     dword ptr [ecx+4], 0
.text$mn:00006085                 mov     edx, [ebp+arg_0]
.text$mn:00006088                 mov     dword ptr [edx+8], 0
.text$mn:0000608F                 mov     eax, [ebp+arg_0]
.text$mn:00006092                 mov     dword ptr [eax+0Ch], 0
.text$mn:00006099                 mov     esp, ebp
.text$mn:0000609B                 pop     ebp
.text$mn:0000609C                 retn    8
.text$mn:0000609C ?_Assign_rv@?$vector@PB_WV?$allocator@PB_W@std@@@std@@QAEX$$QAV12@U?$integral_constant@_N$00@2@@Z endp
.text$mn:0000609C
.text$mn:0000609C ; ---------------------------------------------------------------------------
.text$mn:0000609F                 align 10h
.text$mn:0000609F _text$mn        ends
.text$mn:0000609F
.text$mn:000060A0 ; ===========================================================================
.text$mn:000060A0
.text$mn:000060A0 ; Segment type: Pure code
.text$mn:000060A0 ; Segment permissions: Read/Execute
.text$mn:000060A0 _text$mn        segment para public 'CODE' use32
.text$mn:000060A0                 assume cs:_text$mn
.text$mn:000060A0                 ;org 60A0h
.text$mn:000060A0 ; COMDAT (pick any)
.text$mn:000060A0                 assume es:nothing, ss:nothing, ds:_data, fs:nothing, gs:nothing
.text$mn:000060A0
.text$mn:000060A0 ; =============== S U B R O U T I N E =======================================
.text$mn:000060A0
.text$mn:000060A0 ; Attributes: bp-based frame
.text$mn:000060A0
.text$mn:000060A0 ; protected: bool __thiscall std::vector<wchar_t const *, class std::allocator<wchar_t const *>>::_Buy(unsigned int)
.text$mn:000060A0                 public ?_Buy@?$vector@PB_WV?$allocator@PB_W@std@@@std@@IAE_NI@Z
.text$mn:000060A0 ?_Buy@?$vector@PB_WV?$allocator@PB_W@std@@@std@@IAE_NI@Z proc near
.text$mn:000060A0                                         ; CODE XREF: std::vector<wchar_t const *,std::allocator<wchar_t const *>>::vector<wchar_t const *,std::allocator<wchar_t const *>>(std::vector<wchar_t const *,std::allocator<wchar_t const *>> const &)+62p
.text$mn:000060A0
.text$mn:000060A0 var_8           = dword ptr -8
.text$mn:000060A0 var_1           = byte ptr -1
.text$mn:000060A0 arg_0           = dword ptr  8
.text$mn:000060A0
.text$mn:000060A0                 push    ebp
.text$mn:000060A1                 mov     ebp, esp
.text$mn:000060A3                 sub     esp, 8
.text$mn:000060A6                 mov     [ebp+var_8], ecx
.text$mn:000060A9                 mov     eax, [ebp+var_8]
.text$mn:000060AC                 mov     dword ptr [eax+4], 0
.text$mn:000060B3                 mov     ecx, [ebp+var_8]
.text$mn:000060B6                 mov     dword ptr [ecx+8], 0
.text$mn:000060BD                 mov     edx, [ebp+var_8]
.text$mn:000060C0                 mov     dword ptr [edx+0Ch], 0
.text$mn:000060C7                 cmp     [ebp+arg_0], 0
.text$mn:000060CB                 jnz     short loc_60D3
.text$mn:000060CD                 xor     al, al
.text$mn:000060CF                 jmp     short loc_6127
.text$mn:000060D1 ; ---------------------------------------------------------------------------
.text$mn:000060D1                 jmp     short loc_6125
.text$mn:000060D3 ; ---------------------------------------------------------------------------
.text$mn:000060D3
.text$mn:000060D3 loc_60D3:                               ; CODE XREF: std::vector<wchar_t const *,std::allocator<wchar_t const *>>::_Buy(uint)+2Bj
.text$mn:000060D3                 mov     ecx, [ebp+var_8]
.text$mn:000060D6                 call    ?max_size@?$vector@PB_WV?$allocator@PB_W@std@@@std@@QBEIXZ ; std::vector<wchar_t const *,std::allocator<wchar_t const *>>::max_size(void)
.text$mn:000060DB                 cmp     eax, [ebp+arg_0]
.text$mn:000060DE                 jnb     short loc_60EA
.text$mn:000060E0                 mov     ecx, [ebp+var_8]
.text$mn:000060E3                 call    ?_Xlen@?$vector@PB_WV?$allocator@PB_W@std@@@std@@IBEXXZ ; std::vector<wchar_t const *,std::allocator<wchar_t const *>>::_Xlen(void)
.text$mn:000060E8                 jmp     short loc_6125
.text$mn:000060EA ; ---------------------------------------------------------------------------
.text$mn:000060EA
.text$mn:000060EA loc_60EA:                               ; CODE XREF: std::vector<wchar_t const *,std::allocator<wchar_t const *>>::_Buy(uint)+3Ej
.text$mn:000060EA                 mov     eax, [ebp+arg_0]
.text$mn:000060ED                 push    eax
.text$mn:000060EE                 lea     ecx, [ebp+var_1]
.text$mn:000060F1                 push    ecx
.text$mn:000060F2                 mov     ecx, [ebp+var_8]
.text$mn:000060F5                 call    ?_Getal@?$_Vector_alloc@$0A@U?$_Vec_base_types@PB_WV?$allocator@PB_W@std@@@std@@@std@@QBE?AU?$_Wrap_alloc@V?$allocator@PB_W@std@@@2@XZ ; std::_Vector_alloc<0,std::_Vec_base_types<wchar_t const *,std::allocator<wchar_t const *>>>::_Getal(void)
.text$mn:000060FA                 mov     ecx, eax
.text$mn:000060FC                 call    ?allocate@?$_Wrap_alloc@V?$allocator@PB_W@std@@@std@@QAEPAPB_WI@Z ; std::_Wrap_alloc<std::allocator<wchar_t const *>>::allocate(uint)
.text$mn:00006101                 mov     edx, [ebp+var_8]
.text$mn:00006104                 mov     [edx+4], eax
.text$mn:00006107                 mov     eax, [ebp+var_8]
.text$mn:0000610A                 mov     ecx, [ebp+var_8]
.text$mn:0000610D                 mov     edx, [ecx+4]
.text$mn:00006110                 mov     [eax+8], edx
.text$mn:00006113                 mov     eax, [ebp+var_8]
.text$mn:00006116                 mov     ecx, [eax+4]
.text$mn:00006119                 mov     edx, [ebp+arg_0]
.text$mn:0000611C                 lea     eax, [ecx+edx*4]
.text$mn:0000611F                 mov     ecx, [ebp+var_8]
.text$mn:00006122                 mov     [ecx+0Ch], eax
.text$mn:00006125
.text$mn:00006125 loc_6125:                               ; CODE XREF: std::vector<wchar_t const *,std::allocator<wchar_t const *>>::_Buy(uint)+31j
.text$mn:00006125                                         ; std::vector<wchar_t const *,std::allocator<wchar_t const *>>::_Buy(uint)+48j
.text$mn:00006125                 mov     al, 1
.text$mn:00006127
.text$mn:00006127 loc_6127:                               ; CODE XREF: std::vector<wchar_t const *,std::allocator<wchar_t const *>>::_Buy(uint)+2Fj
.text$mn:00006127                 mov     esp, ebp
.text$mn:00006129                 pop     ebp
.text$mn:0000612A                 retn    4
.text$mn:0000612A ?_Buy@?$vector@PB_WV?$allocator@PB_W@std@@@std@@IAE_NI@Z endp
.text$mn:0000612A
.text$mn:0000612A ; ---------------------------------------------------------------------------
.text$mn:0000612D                 align 10h
.text$mn:0000612D _text$mn        ends
.text$mn:0000612D
.text$mn:00006130 ; ===========================================================================
.text$mn:00006130
.text$mn:00006130 ; Segment type: Pure code
.text$mn:00006130 ; Segment permissions: Read/Execute
.text$mn:00006130 _text$mn        segment para public 'CODE' use32
.text$mn:00006130                 assume cs:_text$mn
.text$mn:00006130                 ;org 6130h
.text$mn:00006130 ; COMDAT (pick any)
.text$mn:00006130                 assume es:nothing, ss:nothing, ds:_data, fs:nothing, gs:nothing
.text$mn:00006130
.text$mn:00006130 ; =============== S U B R O U T I N E =======================================
.text$mn:00006130
.text$mn:00006130 ; Attributes: bp-based frame
.text$mn:00006130
.text$mn:00006130 ; void __thiscall std::_Iterator_base12::_Clrcont(std::_Iterator_base12 *__hidden this)
.text$mn:00006130                 public ?_Clrcont@_Iterator_base12@std@@QAEXXZ
.text$mn:00006130 ?_Clrcont@_Iterator_base12@std@@QAEXXZ proc near
.text$mn:00006130                                         ; CODE XREF: std::vector<wchar_t const *,std::allocator<wchar_t const *>>::_Orphan_range(wchar_t const * *,wchar_t const * *)+80p
.text$mn:00006130                                         ; std::vector<FunctionValues,std::allocator<FunctionValues>>::_Orphan_range(FunctionValues *,FunctionValues *)+80p ...
.text$mn:00006130
.text$mn:00006130 var_4           = dword ptr -4
.text$mn:00006130
.text$mn:00006130                 push    ebp
.text$mn:00006131                 mov     ebp, esp
.text$mn:00006133                 push    ecx
.text$mn:00006134                 mov     [ebp+var_4], ecx
.text$mn:00006137                 mov     eax, [ebp+var_4]
.text$mn:0000613A                 mov     dword ptr [eax], 0
.text$mn:00006140                 mov     esp, ebp
.text$mn:00006142                 pop     ebp
.text$mn:00006143                 retn
.text$mn:00006143 ?_Clrcont@_Iterator_base12@std@@QAEXXZ endp
.text$mn:00006143
.text$mn:00006143 _text$mn        ends
.text$mn:00006143
.text$mn:00006144 ; ===========================================================================
.text$mn:00006144
.text$mn:00006144 ; Segment type: Pure code
.text$mn:00006144 ; Segment permissions: Read/Execute
.text$mn:00006144 _text$mn        segment para public 'CODE' use32
.text$mn:00006144                 assume cs:_text$mn
.text$mn:00006144                 ;org 6144h
.text$mn:00006144 ; COMDAT (pick any)
.text$mn:00006144                 assume es:nothing, ss:nothing, ds:_data, fs:nothing, gs:nothing
.text$mn:00006144
.text$mn:00006144 ; =============== S U B R O U T I N E =======================================
.text$mn:00006144
.text$mn:00006144 ; Attributes: bp-based frame
.text$mn:00006144
.text$mn:00006144 ; public: void __thiscall std::basic_string<char, struct std::char_traits<char>, class std::allocator<char>>::_Copy(unsigned int, unsigned int)
.text$mn:00006144                 public ?_Copy@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEXII@Z
.text$mn:00006144 ?_Copy@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEXII@Z proc near
.text$mn:00006144                                         ; CODE XREF: std::basic_string<char,std::char_traits<char>,std::allocator<char>>::_Grow(uint,bool)+37p
.text$mn:00006144
.text$mn:00006144 var_20          = dword ptr -20h
.text$mn:00006144 var_1C          = dword ptr -1Ch
.text$mn:00006144 var_18          = dword ptr -18h
.text$mn:00006144 var_11          = byte ptr -11h
.text$mn:00006144 var_10          = dword ptr -10h
.text$mn:00006144 var_C           = byte ptr -0Ch
.text$mn:00006144 var_4           = dword ptr -4
.text$mn:00006144 arg_0           = dword ptr  8
.text$mn:00006144
.text$mn:00006144 ; FUNCTION CHUNK AT .text$mn:00006266 SIZE 00000009 BYTES
.text$mn:00006144
.text$mn:00006144                 push    ebp
.text$mn:00006145                 mov     ebp, esp
.text$mn:00006147                 push    0FFFFFFFFh
.text$mn:00006149                 push    offset __ehhandler$?_Copy@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEXII@Z
.text$mn:0000614E                 mov     eax, large fs:0
.text$mn:00006154                 push    eax
.text$mn:00006155                 push    ecx
.text$mn:00006156                 sub     esp, 10h
.text$mn:00006159                 push    ebx
.text$mn:0000615A                 push    esi
.text$mn:0000615B                 push    edi
.text$mn:0000615C                 mov     eax, dword ptr ds:___security_cookie
.text$mn:00006161                 xor     eax, ebp
.text$mn:00006163                 push    eax
.text$mn:00006164                 lea     eax, [ebp+var_C]
.text$mn:00006167                 mov     large fs:0, eax
.text$mn:0000616D                 mov     [ebp+var_10], esp
.text$mn:00006170                 mov     [ebp+var_18], ecx
.text$mn:00006173                 mov     eax, [ebp+arg_0]
.text$mn:00006176                 or      eax, 0Fh
.text$mn:00006179                 mov     [ebp+var_1C], eax
.text$mn:0000617C                 mov     ecx, [ebp+var_18]
.text$mn:0000617F                 call    ?max_size@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QBEIXZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char>>::max_size(void)
.text$mn:00006184                 cmp     eax, [ebp+var_1C]
.text$mn:00006187                 jnb     short loc_6191
.text$mn:00006189                 mov     ecx, [ebp+arg_0]
.text$mn:0000618C                 mov     [ebp+var_1C], ecx
.text$mn:0000618F                 jmp     short loc_61E3
.text$mn:00006191 ; ---------------------------------------------------------------------------
.text$mn:00006191
.text$mn:00006191 loc_6191:                               ; CODE XREF: std::basic_string<char,std::char_traits<char>,std::allocator<char>>::_Copy(uint,uint)+43j
.text$mn:00006191                 mov     edx, [ebp+var_18]
.text$mn:00006194                 mov     ecx, [edx+18h]
.text$mn:00006197                 shr     ecx, 1
.text$mn:00006199                 mov     eax, [ebp+var_1C]
.text$mn:0000619C                 xor     edx, edx
.text$mn:0000619E                 mov     esi, 3
.text$mn:000061A3                 div     esi
.text$mn:000061A5                 cmp     ecx, eax
.text$mn:000061A7                 ja      short loc_61AB
.text$mn:000061A9                 jmp     short loc_61E3
.text$mn:000061AB ; ---------------------------------------------------------------------------
.text$mn:000061AB
.text$mn:000061AB loc_61AB:                               ; CODE XREF: std::basic_string<char,std::char_traits<char>,std::allocator<char>>::_Copy(uint,uint)+63j
.text$mn:000061AB                 mov     ecx, [ebp+var_18]
.text$mn:000061AE                 call    ?max_size@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QBEIXZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char>>::max_size(void)
.text$mn:000061B3                 mov     edx, [ebp+var_18]
.text$mn:000061B6                 mov     ecx, [edx+18h]
.text$mn:000061B9                 shr     ecx, 1
.text$mn:000061BB                 sub     eax, ecx
.text$mn:000061BD                 mov     edx, [ebp+var_18]
.text$mn:000061C0                 cmp     [edx+18h], eax
.text$mn:000061C3                 ja      short loc_61D8
.text$mn:000061C5                 mov     eax, [ebp+var_18]
.text$mn:000061C8                 mov     ecx, [eax+18h]
.text$mn:000061CB                 shr     ecx, 1
.text$mn:000061CD                 mov     edx, [ebp+var_18]
.text$mn:000061D0                 add     ecx, [edx+18h]
.text$mn:000061D3                 mov     [ebp+var_1C], ecx
.text$mn:000061D6                 jmp     short loc_61E3
.text$mn:000061D8 ; ---------------------------------------------------------------------------
.text$mn:000061D8
.text$mn:000061D8 loc_61D8:                               ; CODE XREF: std::basic_string<char,std::char_traits<char>,std::allocator<char>>::_Copy(uint,uint)+7Fj
.text$mn:000061D8                 mov     ecx, [ebp+var_18]
.text$mn:000061DB                 call    ?max_size@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QBEIXZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char>>::max_size(void)
.text$mn:000061E0                 mov     [ebp+var_1C], eax
.text$mn:000061E3
.text$mn:000061E3 loc_61E3:                               ; CODE XREF: std::basic_string<char,std::char_traits<char>,std::allocator<char>>::_Copy(uint,uint)+4Bj
.text$mn:000061E3                                         ; std::basic_string<char,std::char_traits<char>,std::allocator<char>>::_Copy(uint,uint)+65j ...
.text$mn:000061E3                 mov     [ebp+var_4], 0
.text$mn:000061EA                 mov     eax, [ebp+var_1C]
.text$mn:000061ED                 add     eax, 1
.text$mn:000061F0                 push    eax
.text$mn:000061F1                 lea     ecx, [ebp+var_11]
.text$mn:000061F4                 push    ecx
.text$mn:000061F5                 mov     ecx, [ebp+var_18]
.text$mn:000061F8                 call    ?_Getal@?$_String_alloc@$0A@U?$_String_base_types@DV?$allocator@D@std@@@std@@@std@@QBE?AU?$_Wrap_alloc@V?$allocator@D@std@@@2@XZ ; std::_String_alloc<0,std::_String_base_types<char,std::allocator<char>>>::_Getal(void)
.text$mn:000061FD                 mov     ecx, eax
.text$mn:000061FF                 call    ?allocate@?$_Wrap_alloc@V?$allocator@D@std@@@std@@QAEPADI@Z ; std::_Wrap_alloc<std::allocator<char>>::allocate(uint)
.text$mn:00006204                 mov     [ebp+var_20], eax
.text$mn:00006207                 jmp     short loc_6266
.text$mn:00006207 ?_Copy@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEXII@Z endp
.text$mn:00006207
.text$mn:00006209
.text$mn:00006209 ; =============== S U B R O U T I N E =======================================
.text$mn:00006209
.text$mn:00006209
.text$mn:00006209 __catch$?_Copy@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEXII@Z$0 proc near
.text$mn:00006209                                         ; DATA XREF: .xdata$x:00009418o
.text$mn:00006209
.text$mn:00006209 ; FUNCTION CHUNK AT .text$mn:00006250 SIZE 00000009 BYTES
.text$mn:00006209 ; FUNCTION CHUNK AT .text$mn:00006260 SIZE 00000006 BYTES
.text$mn:00006209
.text$mn:00006209                 mov     [ebp-10h], esp
.text$mn:0000620C                 mov     edx, [ebp+8]
.text$mn:0000620F                 mov     [ebp-1Ch], edx
.text$mn:00006212                 mov     byte ptr [ebp-4], 2
.text$mn:00006216                 mov     eax, [ebp-1Ch]
.text$mn:00006219                 add     eax, 1
.text$mn:0000621C                 push    eax
.text$mn:0000621D                 lea     ecx, [ebp-12h]
.text$mn:00006220                 push    ecx
.text$mn:00006221                 mov     ecx, [ebp-18h]
.text$mn:00006224                 call    ?_Getal@?$_String_alloc@$0A@U?$_String_base_types@DV?$allocator@D@std@@@std@@@std@@QBE?AU?$_Wrap_alloc@V?$allocator@D@std@@@2@XZ ; std::_String_alloc<0,std::_String_base_types<char,std::allocator<char>>>::_Getal(void)
.text$mn:00006229                 mov     ecx, eax
.text$mn:0000622B                 call    ?allocate@?$_Wrap_alloc@V?$allocator@D@std@@@std@@QAEPADI@Z ; std::_Wrap_alloc<std::allocator<char>>::allocate(uint)
.text$mn:00006230                 mov     [ebp-20h], eax
.text$mn:00006233                 jmp     short loc_6250
.text$mn:00006233 __catch$?_Copy@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEXII@Z$0 endp
.text$mn:00006233
.text$mn:00006235
.text$mn:00006235 ; =============== S U B R O U T I N E =======================================
.text$mn:00006235
.text$mn:00006235 ; Attributes: noreturn
.text$mn:00006235
.text$mn:00006235 __catch$?_Copy@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEXII@Z$1 proc near
.text$mn:00006235                                         ; DATA XREF: .xdata$x:00009428o
.text$mn:00006235                 push    0               ; Size
.text$mn:00006237                 push    1               ; char
.text$mn:00006239                 mov     ecx, [ebp-18h]
.text$mn:0000623C                 call    ?_Tidy@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEX_NI@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char>>::_Tidy(bool,uint)
.text$mn:00006241                 push    0
.text$mn:00006243                 push    0
.text$mn:00006245                 call    __CxxThrowException@8 ; _CxxThrowException(x,x)
.text$mn:00006245 __catch$?_Copy@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEXII@Z$1 endp
.text$mn:00006245
.text$mn:0000624A ; ---------------------------------------------------------------------------
.text$mn:0000624A                 mov     eax, offset $LN17
.text$mn:0000624F                 retn
.text$mn:00006250 ; ---------------------------------------------------------------------------
.text$mn:00006250 ; START OF FUNCTION CHUNK FOR __catch$?_Copy@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEXII@Z$0
.text$mn:00006250
.text$mn:00006250 loc_6250:                               ; CODE XREF: __catch$?_Copy@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEXII@Z$0+2Aj
.text$mn:00006250                 mov     dword ptr [ebp-4], 1
.text$mn:00006257                 jmp     short loc_6260
.text$mn:00006257 ; END OF FUNCTION CHUNK FOR __catch$?_Copy@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEXII@Z$0
.text$mn:00006259
.text$mn:00006259 ; =============== S U B R O U T I N E =======================================
.text$mn:00006259
.text$mn:00006259
.text$mn:00006259 $LN17           proc near               ; DATA XREF: .text$mn:0000624Ao
.text$mn:00006259                 mov     dword ptr [ebp-4], 1
.text$mn:00006259 $LN17           endp ; sp-analysis failed
.text$mn:00006259
.text$mn:00006260 ; START OF FUNCTION CHUNK FOR __catch$?_Copy@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEXII@Z$0
.text$mn:00006260
.text$mn:00006260 loc_6260:                               ; CODE XREF: __catch$?_Copy@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEXII@Z$0+4Ej
.text$mn:00006260                 mov     eax, offset $LN19
.text$mn:00006265                 retn
.text$mn:00006265 ; END OF FUNCTION CHUNK FOR __catch$?_Copy@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEXII@Z$0
.text$mn:00006266 ; ---------------------------------------------------------------------------
.text$mn:00006266 ; START OF FUNCTION CHUNK FOR ?_Copy@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEXII@Z
.text$mn:00006266
.text$mn:00006266 loc_6266:                               ; CODE XREF: std::basic_string<char,std::char_traits<char>,std::allocator<char>>::_Copy(uint,uint)+C3j
.text$mn:00006266                 mov     [ebp+var_4], 0FFFFFFFFh
.text$mn:0000626D                 jmp     short loc_6276
.text$mn:0000626D ; END OF FUNCTION CHUNK FOR ?_Copy@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEXII@Z
.text$mn:0000626F
.text$mn:0000626F ; =============== S U B R O U T I N E =======================================
.text$mn:0000626F
.text$mn:0000626F
.text$mn:0000626F $LN19           proc near               ; DATA XREF: __catch$?_Copy@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEXII@Z$0:loc_6260o
.text$mn:0000626F                 mov     dword ptr [ebp-4], 0FFFFFFFFh
.text$mn:00006276
.text$mn:00006276 loc_6276:                               ; CODE XREF: std::basic_string<char,std::char_traits<char>,std::allocator<char>>::_Copy(uint,uint)+129j
.text$mn:00006276                 cmp     dword ptr [ebp+0Ch], 0
.text$mn:0000627A                 jbe     short loc_6295
.text$mn:0000627C                 mov     edx, [ebp+0Ch]
.text$mn:0000627F                 push    edx             ; Size
.text$mn:00006280                 mov     ecx, [ebp-18h]
.text$mn:00006283                 call    ?_Myptr@?$_String_val@U?$_Simple_types@D@std@@@std@@QAEPADXZ ; std::_String_val<std::_Simple_types<char>>::_Myptr(void)
.text$mn:00006288                 push    eax             ; Src
.text$mn:00006289                 mov     eax, [ebp-20h]
.text$mn:0000628C                 push    eax             ; Dst
.text$mn:0000628D                 call    ?copy@?$char_traits@D@std@@SAPADPADPBDI@Z ; std::char_traits<char>::copy(char *,char const *,uint)
.text$mn:00006292                 add     esp, 0Ch
.text$mn:00006295
.text$mn:00006295 loc_6295:                               ; CODE XREF: $LN19+Bj
.text$mn:00006295                 push    0               ; Size
.text$mn:00006297                 push    1               ; char
.text$mn:00006299                 mov     ecx, [ebp-18h]
.text$mn:0000629C                 call    ?_Tidy@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEX_NI@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char>>::_Tidy(bool,uint)
.text$mn:000062A1                 lea     ecx, [ebp-20h]
.text$mn:000062A4                 push    ecx             ; int
.text$mn:000062A5                 mov     edx, [ebp-18h]
.text$mn:000062A8                 add     edx, 4
.text$mn:000062AB                 push    edx             ; void *
.text$mn:000062AC                 lea     eax, [ebp-13h]
.text$mn:000062AF                 push    eax
.text$mn:000062B0                 mov     ecx, [ebp-18h]
.text$mn:000062B3                 call    ?_Getal@?$_String_alloc@$0A@U?$_String_base_types@DV?$allocator@D@std@@@std@@@std@@QBE?AU?$_Wrap_alloc@V?$allocator@D@std@@@2@XZ ; std::_String_alloc<0,std::_String_base_types<char,std::allocator<char>>>::_Getal(void)
.text$mn:000062B8                 mov     ecx, eax
.text$mn:000062BA                 call    ??$construct@PADAAPAD@?$_Wrap_alloc@V?$allocator@D@std@@@std@@QAEXPAPADAAPAD@Z ; std::_Wrap_alloc<std::allocator<char>>::construct<char *,char * &>(char * *,char * &)
.text$mn:000062BF                 mov     ecx, [ebp-18h]
.text$mn:000062C2                 mov     edx, [ebp-1Ch]
.text$mn:000062C5                 mov     [ecx+18h], edx
.text$mn:000062C8                 mov     eax, [ebp+0Ch]
.text$mn:000062CB                 push    eax
.text$mn:000062CC                 mov     ecx, [ebp-18h]
.text$mn:000062CF                 call    ?_Eos@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEXI@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char>>::_Eos(uint)
.text$mn:000062D4                 mov     ecx, [ebp-0Ch]
.text$mn:000062D7                 mov     large fs:0, ecx
.text$mn:000062DE                 pop     ecx
.text$mn:000062DF                 pop     edi
.text$mn:000062E0                 pop     esi
.text$mn:000062E1                 pop     ebx
.text$mn:000062E2                 mov     esp, ebp
.text$mn:000062E4                 pop     ebp
.text$mn:000062E5                 retn    8
.text$mn:000062E5 $LN19           endp ; sp-analysis failed
.text$mn:000062E5
.text$mn:000062E5 _text$mn        ends
.text$mn:000062E5
.text$x:000062E8 ; ===========================================================================
.text$x:000062E8
.text$x:000062E8 ; Segment type: Pure code
.text$x:000062E8 ; Segment permissions: Read/Execute
.text$x:000062E8 _text$x         segment para public 'CODE' use32
.text$x:000062E8                 assume cs:_text$x
.text$x:000062E8                 ;org 62E8h
.text$x:000062E8 ; COMDAT (pick associative to section at 6144)
.text$x:000062E8                 assume es:nothing, ss:nothing, ds:_data, fs:nothing, gs:nothing
.text$x:000062E8
.text$x:000062E8 ; =============== S U B R O U T I N E =======================================
.text$x:000062E8
.text$x:000062E8
.text$x:000062E8 __ehhandler$?_Copy@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEXII@Z proc near
.text$x:000062E8                                         ; DATA XREF: std::basic_string<char,std::char_traits<char>,std::allocator<char>>::_Copy(uint,uint)+5o
.text$x:000062E8
.text$x:000062E8 arg_4           = dword ptr  8
.text$x:000062E8
.text$x:000062E8                 mov     edx, [esp+arg_4]
.text$x:000062EC                 lea     eax, [edx+0Ch]
.text$x:000062EF                 mov     ecx, [edx-24h]
.text$x:000062F2                 xor     ecx, eax
.text$x:000062F4                 call    @__security_check_cookie@4 ; __security_check_cookie(x)
.text$x:000062F9                 mov     eax, offset __ehfuncinfo$?_Copy@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEXII@Z
.text$x:000062FE                 jmp     ___CxxFrameHandler3
.text$x:000062FE __ehhandler$?_Copy@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEXII@Z endp
.text$x:000062FE
.text$x:000062FE ; ---------------------------------------------------------------------------
.text$x:00006303                 align 4
.text$x:00006303 _text$x         ends
.text$x:00006303
.text$mn:00006304 ; ===========================================================================
.text$mn:00006304
.text$mn:00006304 ; Segment type: Pure code
.text$mn:00006304 ; Segment permissions: Read/Execute
.text$mn:00006304 _text$mn        segment para public 'CODE' use32
.text$mn:00006304                 assume cs:_text$mn
.text$mn:00006304                 ;org 6304h
.text$mn:00006304 ; COMDAT (pick any)
.text$mn:00006304                 assume es:nothing, ss:nothing, ds:_data, fs:nothing, gs:nothing
.text$mn:00006304
.text$mn:00006304 ; =============== S U B R O U T I N E =======================================
.text$mn:00006304
.text$mn:00006304 ; Attributes: bp-based frame
.text$mn:00006304
.text$mn:00006304 ; protected: void __thiscall std::vector<wchar_t const *, class std::allocator<wchar_t const *>>::_Destroy(wchar_t const * *, wchar_t const * *)
.text$mn:00006304                 public ?_Destroy@?$vector@PB_WV?$allocator@PB_W@std@@@std@@IAEXPAPB_W0@Z
.text$mn:00006304 ?_Destroy@?$vector@PB_WV?$allocator@PB_W@std@@@std@@IAEXPAPB_W0@Z proc near
.text$mn:00006304                                         ; CODE XREF: std::vector<wchar_t const *,std::allocator<wchar_t const *>>::_Reallocate(uint)+CBp
.text$mn:00006304                                         ; std::vector<wchar_t const *,std::allocator<wchar_t const *>>::_Tidy(void)+2Bp ...
.text$mn:00006304
.text$mn:00006304 var_8           = dword ptr -8
.text$mn:00006304 var_1           = byte ptr -1
.text$mn:00006304 arg_0           = dword ptr  8
.text$mn:00006304 arg_4           = dword ptr  0Ch
.text$mn:00006304
.text$mn:00006304                 push    ebp
.text$mn:00006305                 mov     ebp, esp
.text$mn:00006307                 sub     esp, 8
.text$mn:0000630A                 mov     [ebp+var_8], ecx
.text$mn:0000630D                 lea     eax, [ebp+var_1]
.text$mn:00006310                 push    eax
.text$mn:00006311                 mov     ecx, [ebp+var_8]
.text$mn:00006314                 call    ?_Getal@?$_Vector_alloc@$0A@U?$_Vec_base_types@PB_WV?$allocator@PB_W@std@@@std@@@std@@QBE?AU?$_Wrap_alloc@V?$allocator@PB_W@std@@@2@XZ ; std::_Vector_alloc<0,std::_Vec_base_types<wchar_t const *,std::allocator<wchar_t const *>>>::_Getal(void)
.text$mn:00006319                 lea     ecx, [ebp+var_1]
.text$mn:0000631C                 push    ecx
.text$mn:0000631D                 mov     edx, [ebp+arg_4]
.text$mn:00006320                 push    edx
.text$mn:00006321                 mov     eax, [ebp+arg_0]
.text$mn:00006324                 push    eax
.text$mn:00006325                 call    ??$_Destroy_range@U?$_Wrap_alloc@V?$allocator@PB_W@std@@@std@@@std@@YAXPAPB_W0AAU?$_Wrap_alloc@V?$allocator@PB_W@std@@@0@@Z ; std::_Destroy_range<std::_Wrap_alloc<std::allocator<wchar_t const *>>>(wchar_t const * *,wchar_t const * *,std::_Wrap_alloc<std::allocator<wchar_t const *>> &)
.text$mn:0000632A                 add     esp, 0Ch
.text$mn:0000632D                 mov     esp, ebp
.text$mn:0000632F                 pop     ebp
.text$mn:00006330                 retn    8
.text$mn:00006330 ?_Destroy@?$vector@PB_WV?$allocator@PB_W@std@@@std@@IAEXPAPB_W0@Z endp
.text$mn:00006330
.text$mn:00006330 ; ---------------------------------------------------------------------------
.text$mn:00006333                 align 4
.text$mn:00006333 _text$mn        ends
.text$mn:00006333
.text$mn:00006334 ; ===========================================================================
.text$mn:00006334
.text$mn:00006334 ; Segment type: Pure code
.text$mn:00006334 ; Segment permissions: Read/Execute
.text$mn:00006334 _text$mn        segment para public 'CODE' use32
.text$mn:00006334                 assume cs:_text$mn
.text$mn:00006334                 ;org 6334h
.text$mn:00006334 ; COMDAT (pick any)
.text$mn:00006334                 assume es:nothing, ss:nothing, ds:_data, fs:nothing, gs:nothing
.text$mn:00006334
.text$mn:00006334 ; =============== S U B R O U T I N E =======================================
.text$mn:00006334
.text$mn:00006334 ; Attributes: bp-based frame
.text$mn:00006334
.text$mn:00006334 ; protected: void __thiscall std::vector<struct FunctionValues, class std::allocator<struct FunctionValues>>::_Destroy(struct FunctionValues *, struct FunctionValues *)
.text$mn:00006334                 public ?_Destroy@?$vector@UFunctionValues@@V?$allocator@UFunctionValues@@@std@@@std@@IAEXPAUFunctionValues@@0@Z
.text$mn:00006334 ?_Destroy@?$vector@UFunctionValues@@V?$allocator@UFunctionValues@@@std@@@std@@IAEXPAUFunctionValues@@0@Z proc near
.text$mn:00006334                                         ; CODE XREF: std::vector<FunctionValues,std::allocator<FunctionValues>>::_Reallocate(uint)+CBp
.text$mn:00006334                                         ; std::vector<FunctionValues,std::allocator<FunctionValues>>::_Tidy(void)+2Bp ...
.text$mn:00006334
.text$mn:00006334 var_8           = dword ptr -8
.text$mn:00006334 var_1           = byte ptr -1
.text$mn:00006334 arg_0           = dword ptr  8
.text$mn:00006334 arg_4           = dword ptr  0Ch
.text$mn:00006334
.text$mn:00006334                 push    ebp
.text$mn:00006335                 mov     ebp, esp
.text$mn:00006337                 sub     esp, 8
.text$mn:0000633A                 mov     [ebp+var_8], ecx
.text$mn:0000633D                 lea     eax, [ebp+var_1]
.text$mn:00006340                 push    eax
.text$mn:00006341                 mov     ecx, [ebp+var_8]
.text$mn:00006344                 call    ?_Getal@?$_Vector_alloc@$0A@U?$_Vec_base_types@UFunctionValues@@V?$allocator@UFunctionValues@@@std@@@std@@@std@@QBE?AU?$_Wrap_alloc@V?$allocator@UFunctionValues@@@std@@@2@XZ ; std::_Vector_alloc<0,std::_Vec_base_types<FunctionValues,std::allocator<FunctionValues>>>::_Getal(void)
.text$mn:00006349                 lea     ecx, [ebp+var_1]
.text$mn:0000634C                 push    ecx
.text$mn:0000634D                 mov     edx, [ebp+arg_4]
.text$mn:00006350                 push    edx
.text$mn:00006351                 mov     eax, [ebp+arg_0]
.text$mn:00006354                 push    eax
.text$mn:00006355                 call    ??$_Destroy_range@U?$_Wrap_alloc@V?$allocator@UFunctionValues@@@std@@@std@@@std@@YAXPAUFunctionValues@@0AAU?$_Wrap_alloc@V?$allocator@UFunctionValues@@@std@@@0@@Z ; std::_Destroy_range<std::_Wrap_alloc<std::allocator<FunctionValues>>>(FunctionValues *,FunctionValues *,std::_Wrap_alloc<std::allocator<FunctionValues>> &)
.text$mn:0000635A                 add     esp, 0Ch
.text$mn:0000635D                 mov     esp, ebp
.text$mn:0000635F                 pop     ebp
.text$mn:00006360                 retn    8
.text$mn:00006360 ?_Destroy@?$vector@UFunctionValues@@V?$allocator@UFunctionValues@@@std@@@std@@IAEXPAUFunctionValues@@0@Z endp
.text$mn:00006360
.text$mn:00006360 ; ---------------------------------------------------------------------------
.text$mn:00006363                 align 4
.text$mn:00006363 _text$mn        ends
.text$mn:00006363
.text$mn:00006364 ; ===========================================================================
.text$mn:00006364
.text$mn:00006364 ; Segment type: Pure code
.text$mn:00006364 ; Segment permissions: Read/Execute
.text$mn:00006364 _text$mn        segment para public 'CODE' use32
.text$mn:00006364                 assume cs:_text$mn
.text$mn:00006364                 ;org 6364h
.text$mn:00006364 ; COMDAT (pick any)
.text$mn:00006364                 assume es:nothing, ss:nothing, ds:_data, fs:nothing, gs:nothing
.text$mn:00006364
.text$mn:00006364 ; =============== S U B R O U T I N E =======================================
.text$mn:00006364
.text$mn:00006364 ; Attributes: bp-based frame
.text$mn:00006364
.text$mn:00006364 ; protected: void __thiscall std::vector<struct Token, class std::allocator<struct Token>>::_Destroy(struct Token *, struct Token *)
.text$mn:00006364                 public ?_Destroy@?$vector@UToken@@V?$allocator@UToken@@@std@@@std@@IAEXPAUToken@@0@Z
.text$mn:00006364 ?_Destroy@?$vector@UToken@@V?$allocator@UToken@@@std@@@std@@IAEXPAUToken@@0@Z proc near
.text$mn:00006364                                         ; CODE XREF: std::vector<Token,std::allocator<Token>>::_Reallocate(uint)+CBp
.text$mn:00006364                                         ; std::vector<Token,std::allocator<Token>>::_Tidy(void)+2Bp
.text$mn:00006364
.text$mn:00006364 var_8           = dword ptr -8
.text$mn:00006364 var_1           = byte ptr -1
.text$mn:00006364 arg_0           = dword ptr  8
.text$mn:00006364 arg_4           = dword ptr  0Ch
.text$mn:00006364
.text$mn:00006364                 push    ebp
.text$mn:00006365                 mov     ebp, esp
.text$mn:00006367                 sub     esp, 8
.text$mn:0000636A                 mov     [ebp+var_8], ecx
.text$mn:0000636D                 lea     eax, [ebp+var_1]
.text$mn:00006370                 push    eax
.text$mn:00006371                 mov     ecx, [ebp+var_8]
.text$mn:00006374                 call    ?_Getal@?$_Vector_alloc@$0A@U?$_Vec_base_types@UToken@@V?$allocator@UToken@@@std@@@std@@@std@@QBE?AU?$_Wrap_alloc@V?$allocator@UToken@@@std@@@2@XZ ; std::_Vector_alloc<0,std::_Vec_base_types<Token,std::allocator<Token>>>::_Getal(void)
.text$mn:00006379                 lea     ecx, [ebp+var_1]
.text$mn:0000637C                 push    ecx
.text$mn:0000637D                 mov     edx, [ebp+arg_4]
.text$mn:00006380                 push    edx
.text$mn:00006381                 mov     eax, [ebp+arg_0]
.text$mn:00006384                 push    eax
.text$mn:00006385                 call    ??$_Destroy_range@U?$_Wrap_alloc@V?$allocator@UToken@@@std@@@std@@@std@@YAXPAUToken@@0AAU?$_Wrap_alloc@V?$allocator@UToken@@@std@@@0@@Z ; std::_Destroy_range<std::_Wrap_alloc<std::allocator<Token>>>(Token *,Token *,std::_Wrap_alloc<std::allocator<Token>> &)
.text$mn:0000638A                 add     esp, 0Ch
.text$mn:0000638D                 mov     esp, ebp
.text$mn:0000638F                 pop     ebp
.text$mn:00006390                 retn    8
.text$mn:00006390 ?_Destroy@?$vector@UToken@@V?$allocator@UToken@@@std@@@std@@IAEXPAUToken@@0@Z endp
.text$mn:00006390
.text$mn:00006390 ; ---------------------------------------------------------------------------
.text$mn:00006393                 align 4
.text$mn:00006393 _text$mn        ends
.text$mn:00006393
.text$mn:00006394 ; ===========================================================================
.text$mn:00006394
.text$mn:00006394 ; Segment type: Pure code
.text$mn:00006394 ; Segment permissions: Read/Execute
.text$mn:00006394 _text$mn        segment para public 'CODE' use32
.text$mn:00006394                 assume cs:_text$mn
.text$mn:00006394                 ;org 6394h
.text$mn:00006394 ; COMDAT (pick any)
.text$mn:00006394                 assume es:nothing, ss:nothing, ds:_data, fs:nothing, gs:nothing
.text$mn:00006394
.text$mn:00006394 ; =============== S U B R O U T I N E =======================================
.text$mn:00006394
.text$mn:00006394 ; Attributes: bp-based frame
.text$mn:00006394
.text$mn:00006394 ; protected: void __thiscall std::vector<class std::vector<wchar_t const *, class std::allocator<wchar_t const *>>, class std::allocator<class std::vector<wchar_t const *, class std::allocator<wchar_t const *>>>>::_Destroy(class std::vector<wchar_t const *, class std::allocator<wchar_t const *>> *, class std::vector<wchar_t const *, class std::allocator<wchar_t const *>> *)
.text$mn:00006394                 public ?_Destroy@?$vector@V?$vector@PB_WV?$allocator@PB_W@std@@@std@@V?$allocator@V?$vector@PB_WV?$allocator@PB_W@std@@@std@@@2@@std@@IAEXPAV?$vector@PB_WV?$allocator@PB_W@std@@@2@0@Z
.text$mn:00006394 ?_Destroy@?$vector@V?$vector@PB_WV?$allocator@PB_W@std@@@std@@V?$allocator@V?$vector@PB_WV?$allocator@PB_W@std@@@std@@@2@@std@@IAEXPAV?$vector@PB_WV?$allocator@PB_W@std@@@2@0@Z proc near
.text$mn:00006394                                         ; CODE XREF: std::vector<std::vector<wchar_t const *,std::allocator<wchar_t const *>>,std::allocator<std::vector<wchar_t const *,std::allocator<wchar_t const *>>>>::_Reallocate(uint)+CBp
.text$mn:00006394                                         ; std::vector<std::vector<wchar_t const *,std::allocator<wchar_t const *>>,std::allocator<std::vector<wchar_t const *,std::allocator<wchar_t const *>>>>::clear(void)+20p
.text$mn:00006394
.text$mn:00006394 var_8           = dword ptr -8
.text$mn:00006394 var_1           = byte ptr -1
.text$mn:00006394 arg_0           = dword ptr  8
.text$mn:00006394 arg_4           = dword ptr  0Ch
.text$mn:00006394
.text$mn:00006394                 push    ebp
.text$mn:00006395                 mov     ebp, esp
.text$mn:00006397                 sub     esp, 8
.text$mn:0000639A                 mov     [ebp+var_8], ecx
.text$mn:0000639D                 lea     eax, [ebp+var_1]
.text$mn:000063A0                 push    eax
.text$mn:000063A1                 mov     ecx, [ebp+var_8]
.text$mn:000063A4                 call    ?_Getal@?$_Vector_alloc@$0A@U?$_Vec_base_types@V?$vector@PB_WV?$allocator@PB_W@std@@@std@@V?$allocator@V?$vector@PB_WV?$allocator@PB_W@std@@@std@@@2@@std@@@std@@QBE?AU?$_Wrap_alloc@V?$allocator@V?$vector@PB_WV?$allocator@PB_W@std@@@std@@@std@@@2@XZ ; std::_Vector_alloc<0,std::_Vec_base_types<std::vector<wchar_t const *,std::allocator<wchar_t const *>>,std::allocator<std::vector<wchar_t const *,std::allocator<wchar_t const *>>>>>::_Getal(void)
.text$mn:000063A9                 lea     ecx, [ebp+var_1]
.text$mn:000063AC                 push    ecx
.text$mn:000063AD                 mov     edx, [ebp+arg_4]
.text$mn:000063B0                 push    edx
.text$mn:000063B1                 mov     eax, [ebp+arg_0]
.text$mn:000063B4                 push    eax
.text$mn:000063B5                 call    ??$_Destroy_range@U?$_Wrap_alloc@V?$allocator@V?$vector@PB_WV?$allocator@PB_W@std@@@std@@@std@@@std@@@std@@YAXPAV?$vector@PB_WV?$allocator@PB_W@std@@@0@0AAU?$_Wrap_alloc@V?$allocator@V?$vector@PB_WV?$allocator@PB_W@std@@@std@@@std@@@0@@Z ; std::_Destroy_range<std::_Wrap_alloc<std::allocator<std::vector<wchar_t const *,std::allocator<wchar_t const *>>>>>(std::vector<wchar_t const *,std::allocator<wchar_t const *>> *,std::vector<wchar_t const *,std::allocator<wchar_t const *>> *,std::_Wrap_alloc<std::allocator<std::vector<wchar_t const *,std::allocator<wchar_t const *>>>> &)
.text$mn:000063BA                 add     esp, 0Ch
.text$mn:000063BD                 mov     esp, ebp
.text$mn:000063BF                 pop     ebp
.text$mn:000063C0                 retn    8
.text$mn:000063C0 ?_Destroy@?$vector@V?$vector@PB_WV?$allocator@PB_W@std@@@std@@V?$allocator@V?$vector@PB_WV?$allocator@PB_W@std@@@std@@@2@@std@@IAEXPAV?$vector@PB_WV?$allocator@PB_W@std@@@2@0@Z endp
.text$mn:000063C0
.text$mn:000063C0 ; ---------------------------------------------------------------------------
.text$mn:000063C3                 align 4
.text$mn:000063C3 _text$mn        ends
.text$mn:000063C3
.text$mn:000063C4 ; ===========================================================================
.text$mn:000063C4
.text$mn:000063C4 ; Segment type: Pure code
.text$mn:000063C4 ; Segment permissions: Read/Execute
.text$mn:000063C4 _text$mn        segment para public 'CODE' use32
.text$mn:000063C4                 assume cs:_text$mn
.text$mn:000063C4                 ;org 63C4h
.text$mn:000063C4 ; COMDAT (pick any)
.text$mn:000063C4                 assume es:nothing, ss:nothing, ds:_data, fs:nothing, gs:nothing
.text$mn:000063C4
.text$mn:000063C4 ; =============== S U B R O U T I N E =======================================
.text$mn:000063C4
.text$mn:000063C4 ; Attributes: bp-based frame
.text$mn:000063C4
.text$mn:000063C4 ; public: void __thiscall std::basic_string<char, struct std::char_traits<char>, class std::allocator<char>>::_Eos(unsigned int)
.text$mn:000063C4                 public ?_Eos@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEXI@Z
.text$mn:000063C4 ?_Eos@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEXI@Z proc near
.text$mn:000063C4                                         ; CODE XREF: $LN19+60p
.text$mn:000063C4                                         ; std::basic_string<char,std::char_traits<char>,std::allocator<char>>::_Grow(uint,bool)+83p ...
.text$mn:000063C4
.text$mn:000063C4 var_8           = dword ptr -8
.text$mn:000063C4 var_1           = byte ptr -1
.text$mn:000063C4 arg_0           = dword ptr  8
.text$mn:000063C4
.text$mn:000063C4                 push    ebp
.text$mn:000063C5                 mov     ebp, esp
.text$mn:000063C7                 sub     esp, 8
.text$mn:000063CA                 mov     [ebp+var_8], ecx
.text$mn:000063CD                 mov     [ebp+var_1], 0
.text$mn:000063D1                 mov     eax, [ebp+var_8]
.text$mn:000063D4                 mov     ecx, [ebp+arg_0]
.text$mn:000063D7                 mov     [eax+14h], ecx
.text$mn:000063DA                 lea     edx, [ebp+var_1]
.text$mn:000063DD                 push    edx
.text$mn:000063DE                 mov     ecx, [ebp+var_8]
.text$mn:000063E1                 call    ?_Myptr@?$_String_val@U?$_Simple_types@D@std@@@std@@QAEPADXZ ; std::_String_val<std::_Simple_types<char>>::_Myptr(void)
.text$mn:000063E6                 add     eax, [ebp+arg_0]
.text$mn:000063E9                 push    eax
.text$mn:000063EA                 call    ?assign@?$char_traits@D@std@@SAXAADABD@Z ; std::char_traits<char>::assign(char &,char const &)
.text$mn:000063EF                 add     esp, 8
.text$mn:000063F2                 mov     esp, ebp
.text$mn:000063F4                 pop     ebp
.text$mn:000063F5                 retn    4
.text$mn:000063F5 ?_Eos@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEXI@Z endp
.text$mn:000063F5
.text$mn:000063F5 _text$mn        ends
.text$mn:000063F5
.text$mn:000063F8 ; ===========================================================================
.text$mn:000063F8
.text$mn:000063F8 ; Segment type: Pure code
.text$mn:000063F8 ; Segment permissions: Read/Execute
.text$mn:000063F8 _text$mn        segment para public 'CODE' use32
.text$mn:000063F8                 assume cs:_text$mn
.text$mn:000063F8                 ;org 63F8h
.text$mn:000063F8 ; COMDAT (pick any)
.text$mn:000063F8                 assume es:nothing, ss:nothing, ds:_data, fs:nothing, gs:nothing
.text$mn:000063F8
.text$mn:000063F8 ; =============== S U B R O U T I N E =======================================
.text$mn:000063F8
.text$mn:000063F8 ; Attributes: bp-based frame
.text$mn:000063F8
.text$mn:000063F8 ; public: void __thiscall std::_String_alloc<0, struct std::_String_base_types<char, class std::allocator<char>>>::_Free_proxy(void)
.text$mn:000063F8                 public ?_Free_proxy@?$_String_alloc@$0A@U?$_String_base_types@DV?$allocator@D@std@@@std@@@std@@QAEXXZ
.text$mn:000063F8 ?_Free_proxy@?$_String_alloc@$0A@U?$_String_base_types@DV?$allocator@D@std@@@std@@@std@@QAEXXZ proc near
.text$mn:000063F8                                         ; CODE XREF: std::_String_alloc<0,std::_String_base_types<char,std::allocator<char>>>::~_String_alloc<0,std::_String_base_types<char,std::allocator<char>>>(void)+30p
.text$mn:000063F8
.text$mn:000063F8 var_8           = dword ptr -8
.text$mn:000063F8 var_1           = byte ptr -1
.text$mn:000063F8
.text$mn:000063F8                 push    ebp
.text$mn:000063F9                 mov     ebp, esp
.text$mn:000063FB                 sub     esp, 8
.text$mn:000063FE                 mov     [ebp+var_8], ecx
.text$mn:00006401                 lea     ecx, [ebp+var_1]
.text$mn:00006404                 call    ??0?$allocator@U_Container_proxy@std@@@std@@QAE@XZ ; std::allocator<std::_Container_proxy>::allocator<std::_Container_proxy>(void)
.text$mn:00006409                 mov     ecx, [ebp+var_8] ; this
.text$mn:0000640C                 call    ?_Orphan_all@_Container_base12@std@@QAEXXZ ; std::_Container_base12::_Orphan_all(void)
.text$mn:00006411                 mov     eax, [ebp+var_8]
.text$mn:00006414                 mov     ecx, [eax]
.text$mn:00006416                 push    ecx
.text$mn:00006417                 lea     ecx, [ebp+var_1]
.text$mn:0000641A                 call    ??$destroy@U_Container_proxy@std@@@?$allocator@U_Container_proxy@std@@@std@@QAEXPAU_Container_proxy@1@@Z ; std::allocator<std::_Container_proxy>::destroy<std::_Container_proxy>(std::_Container_proxy *)
.text$mn:0000641F                 push    1               ; int
.text$mn:00006421                 mov     edx, [ebp+var_8]
.text$mn:00006424                 mov     eax, [edx]
.text$mn:00006426                 push    eax             ; void *
.text$mn:00006427                 lea     ecx, [ebp+var_1]
.text$mn:0000642A                 call    ?deallocate@?$allocator@U_Container_proxy@std@@@std@@QAEXPAU_Container_proxy@2@I@Z ; std::allocator<std::_Container_proxy>::deallocate(std::_Container_proxy *,uint)
.text$mn:0000642F                 mov     ecx, [ebp+var_8]
.text$mn:00006432                 mov     dword ptr [ecx], 0
.text$mn:00006438                 mov     esp, ebp
.text$mn:0000643A                 pop     ebp
.text$mn:0000643B                 retn
.text$mn:0000643B ?_Free_proxy@?$_String_alloc@$0A@U?$_String_base_types@DV?$allocator@D@std@@@std@@@std@@QAEXXZ endp
.text$mn:0000643B
.text$mn:0000643B _text$mn        ends
.text$mn:0000643B
.text$mn:0000643C ; ===========================================================================
.text$mn:0000643C
.text$mn:0000643C ; Segment type: Pure code
.text$mn:0000643C ; Segment permissions: Read/Execute
.text$mn:0000643C _text$mn        segment para public 'CODE' use32
.text$mn:0000643C                 assume cs:_text$mn
.text$mn:0000643C                 ;org 643Ch
.text$mn:0000643C ; COMDAT (pick any)
.text$mn:0000643C                 assume es:nothing, ss:nothing, ds:_data, fs:nothing, gs:nothing
.text$mn:0000643C
.text$mn:0000643C ; =============== S U B R O U T I N E =======================================
.text$mn:0000643C
.text$mn:0000643C ; Attributes: bp-based frame
.text$mn:0000643C
.text$mn:0000643C ; public: void __thiscall std::_Vector_alloc<0, struct std::_Vec_base_types<wchar_t const *, class std::allocator<wchar_t const *>>>::_Free_proxy(void)
.text$mn:0000643C                 public ?_Free_proxy@?$_Vector_alloc@$0A@U?$_Vec_base_types@PB_WV?$allocator@PB_W@std@@@std@@@std@@QAEXXZ
.text$mn:0000643C ?_Free_proxy@?$_Vector_alloc@$0A@U?$_Vec_base_types@PB_WV?$allocator@PB_W@std@@@std@@@std@@QAEXXZ proc near
.text$mn:0000643C                                         ; CODE XREF: std::_Vector_alloc<0,std::_Vec_base_types<wchar_t const *,std::allocator<wchar_t const *>>>::~_Vector_alloc<0,std::_Vec_base_types<wchar_t const *,std::allocator<wchar_t const *>>>(void)+30p
.text$mn:0000643C
.text$mn:0000643C var_8           = dword ptr -8
.text$mn:0000643C var_1           = byte ptr -1
.text$mn:0000643C
.text$mn:0000643C                 push    ebp
.text$mn:0000643D                 mov     ebp, esp
.text$mn:0000643F                 sub     esp, 8
.text$mn:00006442                 mov     [ebp+var_8], ecx
.text$mn:00006445                 lea     ecx, [ebp+var_1]
.text$mn:00006448                 call    ??0?$_Wrap_alloc@V?$allocator@U_Container_proxy@std@@@std@@@std@@QAE@XZ ; std::_Wrap_alloc<std::allocator<std::_Container_proxy>>::_Wrap_alloc<std::allocator<std::_Container_proxy>>(void)
.text$mn:0000644D                 mov     ecx, [ebp+var_8] ; this
.text$mn:00006450                 call    ?_Orphan_all@_Container_base12@std@@QAEXXZ ; std::_Container_base12::_Orphan_all(void)
.text$mn:00006455                 mov     eax, [ebp+var_8]
.text$mn:00006458                 mov     ecx, [eax]
.text$mn:0000645A                 push    ecx
.text$mn:0000645B                 lea     ecx, [ebp+var_1]
.text$mn:0000645E                 call    ??$destroy@U_Container_proxy@std@@@?$_Wrap_alloc@V?$allocator@U_Container_proxy@std@@@std@@@std@@QAEXPAU_Container_proxy@1@@Z ; std::_Wrap_alloc<std::allocator<std::_Container_proxy>>::destroy<std::_Container_proxy>(std::_Container_proxy *)
.text$mn:00006463                 push    1               ; int
.text$mn:00006465                 mov     edx, [ebp+var_8]
.text$mn:00006468                 mov     eax, [edx]
.text$mn:0000646A                 push    eax             ; void *
.text$mn:0000646B                 lea     ecx, [ebp+var_1]
.text$mn:0000646E                 call    ?deallocate@?$_Wrap_alloc@V?$allocator@U_Container_proxy@std@@@std@@@std@@QAEXPAU_Container_proxy@2@I@Z ; std::_Wrap_alloc<std::allocator<std::_Container_proxy>>::deallocate(std::_Container_proxy *,uint)
.text$mn:00006473                 mov     ecx, [ebp+var_8]
.text$mn:00006476                 mov     dword ptr [ecx], 0
.text$mn:0000647C                 mov     esp, ebp
.text$mn:0000647E                 pop     ebp
.text$mn:0000647F                 retn
.text$mn:0000647F ?_Free_proxy@?$_Vector_alloc@$0A@U?$_Vec_base_types@PB_WV?$allocator@PB_W@std@@@std@@@std@@QAEXXZ endp
.text$mn:0000647F
.text$mn:0000647F _text$mn        ends
.text$mn:0000647F
.text$mn:00006480 ; ===========================================================================
.text$mn:00006480
.text$mn:00006480 ; Segment type: Pure code
.text$mn:00006480 ; Segment permissions: Read/Execute
.text$mn:00006480 _text$mn        segment para public 'CODE' use32
.text$mn:00006480                 assume cs:_text$mn
.text$mn:00006480                 ;org 6480h
.text$mn:00006480 ; COMDAT (pick any)
.text$mn:00006480                 assume es:nothing, ss:nothing, ds:_data, fs:nothing, gs:nothing
.text$mn:00006480
.text$mn:00006480 ; =============== S U B R O U T I N E =======================================
.text$mn:00006480
.text$mn:00006480 ; Attributes: bp-based frame
.text$mn:00006480
.text$mn:00006480 ; public: void __thiscall std::_Vector_alloc<0, struct std::_Vec_base_types<struct FunctionValues, class std::allocator<struct FunctionValues>>>::_Free_proxy(void)
.text$mn:00006480                 public ?_Free_proxy@?$_Vector_alloc@$0A@U?$_Vec_base_types@UFunctionValues@@V?$allocator@UFunctionValues@@@std@@@std@@@std@@QAEXXZ
.text$mn:00006480 ?_Free_proxy@?$_Vector_alloc@$0A@U?$_Vec_base_types@UFunctionValues@@V?$allocator@UFunctionValues@@@std@@@std@@@std@@QAEXXZ proc near
.text$mn:00006480                                         ; CODE XREF: std::_Vector_alloc<0,std::_Vec_base_types<FunctionValues,std::allocator<FunctionValues>>>::~_Vector_alloc<0,std::_Vec_base_types<FunctionValues,std::allocator<FunctionValues>>>(void)+30p
.text$mn:00006480
.text$mn:00006480 var_8           = dword ptr -8
.text$mn:00006480 var_1           = byte ptr -1
.text$mn:00006480
.text$mn:00006480                 push    ebp
.text$mn:00006481                 mov     ebp, esp
.text$mn:00006483                 sub     esp, 8
.text$mn:00006486                 mov     [ebp+var_8], ecx
.text$mn:00006489                 lea     ecx, [ebp+var_1]
.text$mn:0000648C                 call    ??0?$_Wrap_alloc@V?$allocator@U_Container_proxy@std@@@std@@@std@@QAE@XZ ; std::_Wrap_alloc<std::allocator<std::_Container_proxy>>::_Wrap_alloc<std::allocator<std::_Container_proxy>>(void)
.text$mn:00006491                 mov     ecx, [ebp+var_8] ; this
.text$mn:00006494                 call    ?_Orphan_all@_Container_base12@std@@QAEXXZ ; std::_Container_base12::_Orphan_all(void)
.text$mn:00006499                 mov     eax, [ebp+var_8]
.text$mn:0000649C                 mov     ecx, [eax]
.text$mn:0000649E                 push    ecx
.text$mn:0000649F                 lea     ecx, [ebp+var_1]
.text$mn:000064A2                 call    ??$destroy@U_Container_proxy@std@@@?$_Wrap_alloc@V?$allocator@U_Container_proxy@std@@@std@@@std@@QAEXPAU_Container_proxy@1@@Z ; std::_Wrap_alloc<std::allocator<std::_Container_proxy>>::destroy<std::_Container_proxy>(std::_Container_proxy *)
.text$mn:000064A7                 push    1               ; int
.text$mn:000064A9                 mov     edx, [ebp+var_8]
.text$mn:000064AC                 mov     eax, [edx]
.text$mn:000064AE                 push    eax             ; void *
.text$mn:000064AF                 lea     ecx, [ebp+var_1]
.text$mn:000064B2                 call    ?deallocate@?$_Wrap_alloc@V?$allocator@U_Container_proxy@std@@@std@@@std@@QAEXPAU_Container_proxy@2@I@Z ; std::_Wrap_alloc<std::allocator<std::_Container_proxy>>::deallocate(std::_Container_proxy *,uint)
.text$mn:000064B7                 mov     ecx, [ebp+var_8]
.text$mn:000064BA                 mov     dword ptr [ecx], 0
.text$mn:000064C0                 mov     esp, ebp
.text$mn:000064C2                 pop     ebp
.text$mn:000064C3                 retn
.text$mn:000064C3 ?_Free_proxy@?$_Vector_alloc@$0A@U?$_Vec_base_types@UFunctionValues@@V?$allocator@UFunctionValues@@@std@@@std@@@std@@QAEXXZ endp
.text$mn:000064C3
.text$mn:000064C3 _text$mn        ends
.text$mn:000064C3
.text$mn:000064C4 ; ===========================================================================
.text$mn:000064C4
.text$mn:000064C4 ; Segment type: Pure code
.text$mn:000064C4 ; Segment permissions: Read/Execute
.text$mn:000064C4 _text$mn        segment para public 'CODE' use32
.text$mn:000064C4                 assume cs:_text$mn
.text$mn:000064C4                 ;org 64C4h
.text$mn:000064C4 ; COMDAT (pick any)
.text$mn:000064C4                 assume es:nothing, ss:nothing, ds:_data, fs:nothing, gs:nothing
.text$mn:000064C4
.text$mn:000064C4 ; =============== S U B R O U T I N E =======================================
.text$mn:000064C4
.text$mn:000064C4 ; Attributes: bp-based frame
.text$mn:000064C4
.text$mn:000064C4 ; public: void __thiscall std::_Vector_alloc<0, struct std::_Vec_base_types<struct Token, class std::allocator<struct Token>>>::_Free_proxy(void)
.text$mn:000064C4                 public ?_Free_proxy@?$_Vector_alloc@$0A@U?$_Vec_base_types@UToken@@V?$allocator@UToken@@@std@@@std@@@std@@QAEXXZ
.text$mn:000064C4 ?_Free_proxy@?$_Vector_alloc@$0A@U?$_Vec_base_types@UToken@@V?$allocator@UToken@@@std@@@std@@@std@@QAEXXZ proc near
.text$mn:000064C4                                         ; CODE XREF: std::_Vector_alloc<0,std::_Vec_base_types<Token,std::allocator<Token>>>::~_Vector_alloc<0,std::_Vec_base_types<Token,std::allocator<Token>>>(void)+30p
.text$mn:000064C4
.text$mn:000064C4 var_8           = dword ptr -8
.text$mn:000064C4 var_1           = byte ptr -1
.text$mn:000064C4
.text$mn:000064C4                 push    ebp
.text$mn:000064C5                 mov     ebp, esp
.text$mn:000064C7                 sub     esp, 8
.text$mn:000064CA                 mov     [ebp+var_8], ecx
.text$mn:000064CD                 lea     ecx, [ebp+var_1]
.text$mn:000064D0                 call    ??0?$_Wrap_alloc@V?$allocator@U_Container_proxy@std@@@std@@@std@@QAE@XZ ; std::_Wrap_alloc<std::allocator<std::_Container_proxy>>::_Wrap_alloc<std::allocator<std::_Container_proxy>>(void)
.text$mn:000064D5                 mov     ecx, [ebp+var_8] ; this
.text$mn:000064D8                 call    ?_Orphan_all@_Container_base12@std@@QAEXXZ ; std::_Container_base12::_Orphan_all(void)
.text$mn:000064DD                 mov     eax, [ebp+var_8]
.text$mn:000064E0                 mov     ecx, [eax]
.text$mn:000064E2                 push    ecx
.text$mn:000064E3                 lea     ecx, [ebp+var_1]
.text$mn:000064E6                 call    ??$destroy@U_Container_proxy@std@@@?$_Wrap_alloc@V?$allocator@U_Container_proxy@std@@@std@@@std@@QAEXPAU_Container_proxy@1@@Z ; std::_Wrap_alloc<std::allocator<std::_Container_proxy>>::destroy<std::_Container_proxy>(std::_Container_proxy *)
.text$mn:000064EB                 push    1               ; int
.text$mn:000064ED                 mov     edx, [ebp+var_8]
.text$mn:000064F0                 mov     eax, [edx]
.text$mn:000064F2                 push    eax             ; void *
.text$mn:000064F3                 lea     ecx, [ebp+var_1]
.text$mn:000064F6                 call    ?deallocate@?$_Wrap_alloc@V?$allocator@U_Container_proxy@std@@@std@@@std@@QAEXPAU_Container_proxy@2@I@Z ; std::_Wrap_alloc<std::allocator<std::_Container_proxy>>::deallocate(std::_Container_proxy *,uint)
.text$mn:000064FB                 mov     ecx, [ebp+var_8]
.text$mn:000064FE                 mov     dword ptr [ecx], 0
.text$mn:00006504                 mov     esp, ebp
.text$mn:00006506                 pop     ebp
.text$mn:00006507                 retn
.text$mn:00006507 ?_Free_proxy@?$_Vector_alloc@$0A@U?$_Vec_base_types@UToken@@V?$allocator@UToken@@@std@@@std@@@std@@QAEXXZ endp
.text$mn:00006507
.text$mn:00006507 _text$mn        ends
.text$mn:00006507
.text$mn:00006508 ; ===========================================================================
.text$mn:00006508
.text$mn:00006508 ; Segment type: Pure code
.text$mn:00006508 ; Segment permissions: Read/Execute
.text$mn:00006508 _text$mn        segment para public 'CODE' use32
.text$mn:00006508                 assume cs:_text$mn
.text$mn:00006508                 ;org 6508h
.text$mn:00006508 ; COMDAT (pick any)
.text$mn:00006508                 assume es:nothing, ss:nothing, ds:_data, fs:nothing, gs:nothing
.text$mn:00006508
.text$mn:00006508 ; =============== S U B R O U T I N E =======================================
.text$mn:00006508
.text$mn:00006508 ; Attributes: bp-based frame
.text$mn:00006508
.text$mn:00006508 ; public: struct std::_Wrap_alloc<class std::allocator<char>> __thiscall std::_String_alloc<0, struct std::_String_base_types<char, class std::allocator<char>>>::_Getal(void)const
.text$mn:00006508                 public ?_Getal@?$_String_alloc@$0A@U?$_String_base_types@DV?$allocator@D@std@@@std@@@std@@QBE?AU?$_Wrap_alloc@V?$allocator@D@std@@@2@XZ
.text$mn:00006508 ?_Getal@?$_String_alloc@$0A@U?$_String_base_types@DV?$allocator@D@std@@@std@@@std@@QBE?AU?$_Wrap_alloc@V?$allocator@D@std@@@2@XZ proc near
.text$mn:00006508                                         ; CODE XREF: std::basic_string<char,std::char_traits<char>,std::allocator<char>>::_Copy(uint,uint)+B4p
.text$mn:00006508                                         ; __catch$?_Copy@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEXII@Z$0+1Bp ...
.text$mn:00006508
.text$mn:00006508 var_4           = dword ptr -4
.text$mn:00006508 arg_0           = dword ptr  8
.text$mn:00006508
.text$mn:00006508                 push    ebp
.text$mn:00006509                 mov     ebp, esp
.text$mn:0000650B                 push    ecx
.text$mn:0000650C                 mov     [ebp+var_4], ecx
.text$mn:0000650F                 mov     ecx, [ebp+arg_0]
.text$mn:00006512                 call    ??0?$_Wrap_alloc@V?$allocator@D@std@@@std@@QAE@XZ ; std::_Wrap_alloc<std::allocator<char>>::_Wrap_alloc<std::allocator<char>>(void)
.text$mn:00006517                 mov     eax, [ebp+arg_0]
.text$mn:0000651A                 mov     esp, ebp
.text$mn:0000651C                 pop     ebp
.text$mn:0000651D                 retn    4
.text$mn:0000651D ?_Getal@?$_String_alloc@$0A@U?$_String_base_types@DV?$allocator@D@std@@@std@@@std@@QBE?AU?$_Wrap_alloc@V?$allocator@D@std@@@2@XZ endp
.text$mn:0000651D
.text$mn:0000651D _text$mn        ends
.text$mn:0000651D
.text$mn:00006520 ; ===========================================================================
.text$mn:00006520
.text$mn:00006520 ; Segment type: Pure code
.text$mn:00006520 ; Segment permissions: Read/Execute
.text$mn:00006520 _text$mn        segment para public 'CODE' use32
.text$mn:00006520                 assume cs:_text$mn
.text$mn:00006520                 ;org 6520h
.text$mn:00006520 ; COMDAT (pick any)
.text$mn:00006520                 assume es:nothing, ss:nothing, ds:_data, fs:nothing, gs:nothing
.text$mn:00006520
.text$mn:00006520 ; =============== S U B R O U T I N E =======================================
.text$mn:00006520
.text$mn:00006520 ; Attributes: bp-based frame
.text$mn:00006520
.text$mn:00006520 ; public: struct std::_Wrap_alloc<class std::allocator<wchar_t const *>> __thiscall std::_Vector_alloc<0, struct std::_Vec_base_types<wchar_t const *, class std::allocator<wchar_t const *>>>::_Getal(void)const
.text$mn:00006520                 public ?_Getal@?$_Vector_alloc@$0A@U?$_Vec_base_types@PB_WV?$allocator@PB_W@std@@@std@@@std@@QBE?AU?$_Wrap_alloc@V?$allocator@PB_W@std@@@2@XZ
.text$mn:00006520 ?_Getal@?$_Vector_alloc@$0A@U?$_Vec_base_types@PB_WV?$allocator@PB_W@std@@@std@@@std@@QBE?AU?$_Wrap_alloc@V?$allocator@PB_W@std@@@2@XZ proc near
.text$mn:00006520                                         ; CODE XREF: std::vector<wchar_t const *,std::allocator<wchar_t const *>>::_Ucopy<std::_Vector_const_iterator<std::_Vector_val<std::_Simple_types<wchar_t const *>>>>(std::_Vector_const_iterator<std::_Vector_val<std::_Simple_types<wchar_t const *>>>,std::_Vector_const_iterator<std::_Vector_val<std::_Simple_types<wchar_t const *>>>,wchar_t const * *)+36p
.text$mn:00006520                                         ; std::vector<wchar_t const *,std::allocator<wchar_t const *>>::_Umove<wchar_t const * *>(wchar_t const * *,wchar_t const * *,wchar_t const * *)+10p ...
.text$mn:00006520
.text$mn:00006520 var_4           = dword ptr -4
.text$mn:00006520 arg_0           = dword ptr  8
.text$mn:00006520
.text$mn:00006520                 push    ebp
.text$mn:00006521                 mov     ebp, esp
.text$mn:00006523                 push    ecx
.text$mn:00006524                 mov     [ebp+var_4], ecx
.text$mn:00006527                 mov     ecx, [ebp+arg_0]
.text$mn:0000652A                 call    ??0?$_Wrap_alloc@V?$allocator@PB_W@std@@@std@@QAE@XZ ; std::_Wrap_alloc<std::allocator<wchar_t const *>>::_Wrap_alloc<std::allocator<wchar_t const *>>(void)
.text$mn:0000652F                 mov     eax, [ebp+arg_0]
.text$mn:00006532                 mov     esp, ebp
.text$mn:00006534                 pop     ebp
.text$mn:00006535                 retn    4
.text$mn:00006535 ?_Getal@?$_Vector_alloc@$0A@U?$_Vec_base_types@PB_WV?$allocator@PB_W@std@@@std@@@std@@QBE?AU?$_Wrap_alloc@V?$allocator@PB_W@std@@@2@XZ endp
.text$mn:00006535
.text$mn:00006535 _text$mn        ends
.text$mn:00006535
.text$mn:00006538 ; ===========================================================================
.text$mn:00006538
.text$mn:00006538 ; Segment type: Pure code
.text$mn:00006538 ; Segment permissions: Read/Execute
.text$mn:00006538 _text$mn        segment para public 'CODE' use32
.text$mn:00006538                 assume cs:_text$mn
.text$mn:00006538                 ;org 6538h
.text$mn:00006538 ; COMDAT (pick any)
.text$mn:00006538                 assume es:nothing, ss:nothing, ds:_data, fs:nothing, gs:nothing
.text$mn:00006538
.text$mn:00006538 ; =============== S U B R O U T I N E =======================================
.text$mn:00006538
.text$mn:00006538 ; Attributes: bp-based frame
.text$mn:00006538
.text$mn:00006538 ; public: struct std::_Wrap_alloc<class std::allocator<struct FunctionValues>> __thiscall std::_Vector_alloc<0, struct std::_Vec_base_types<struct FunctionValues, class std::allocator<struct FunctionValues>>>::_Getal(void)const
.text$mn:00006538                 public ?_Getal@?$_Vector_alloc@$0A@U?$_Vec_base_types@UFunctionValues@@V?$allocator@UFunctionValues@@@std@@@std@@@std@@QBE?AU?$_Wrap_alloc@V?$allocator@UFunctionValues@@@std@@@2@XZ
.text$mn:00006538 ?_Getal@?$_Vector_alloc@$0A@U?$_Vec_base_types@UFunctionValues@@V?$allocator@UFunctionValues@@@std@@@std@@@std@@QBE?AU?$_Wrap_alloc@V?$allocator@UFunctionValues@@@std@@@2@XZ proc near
.text$mn:00006538                                         ; CODE XREF: std::vector<FunctionValues,std::allocator<FunctionValues>>::_Umove<FunctionValues *>(FunctionValues *,FunctionValues *,FunctionValues *)+10p
.text$mn:00006538                                         ; std::vector<FunctionValues,std::allocator<FunctionValues>>::_Destroy(FunctionValues *,FunctionValues *)+10p ...
.text$mn:00006538
.text$mn:00006538 var_4           = dword ptr -4
.text$mn:00006538 arg_0           = dword ptr  8
.text$mn:00006538
.text$mn:00006538                 push    ebp
.text$mn:00006539                 mov     ebp, esp
.text$mn:0000653B                 push    ecx
.text$mn:0000653C                 mov     [ebp+var_4], ecx
.text$mn:0000653F                 mov     ecx, [ebp+arg_0]
.text$mn:00006542                 call    ??0?$_Wrap_alloc@V?$allocator@UFunctionValues@@@std@@@std@@QAE@XZ ; std::_Wrap_alloc<std::allocator<FunctionValues>>::_Wrap_alloc<std::allocator<FunctionValues>>(void)
.text$mn:00006547                 mov     eax, [ebp+arg_0]
.text$mn:0000654A                 mov     esp, ebp
.text$mn:0000654C                 pop     ebp
.text$mn:0000654D                 retn    4
.text$mn:0000654D ?_Getal@?$_Vector_alloc@$0A@U?$_Vec_base_types@UFunctionValues@@V?$allocator@UFunctionValues@@@std@@@std@@@std@@QBE?AU?$_Wrap_alloc@V?$allocator@UFunctionValues@@@std@@@2@XZ endp
.text$mn:0000654D
.text$mn:0000654D _text$mn        ends
.text$mn:0000654D
.text$mn:00006550 ; ===========================================================================
.text$mn:00006550
.text$mn:00006550 ; Segment type: Pure code
.text$mn:00006550 ; Segment permissions: Read/Execute
.text$mn:00006550 _text$mn        segment para public 'CODE' use32
.text$mn:00006550                 assume cs:_text$mn
.text$mn:00006550                 ;org 6550h
.text$mn:00006550 ; COMDAT (pick any)
.text$mn:00006550                 assume es:nothing, ss:nothing, ds:_data, fs:nothing, gs:nothing
.text$mn:00006550
.text$mn:00006550 ; =============== S U B R O U T I N E =======================================
.text$mn:00006550
.text$mn:00006550 ; Attributes: bp-based frame
.text$mn:00006550
.text$mn:00006550 ; public: struct std::_Wrap_alloc<class std::allocator<struct Token>> __thiscall std::_Vector_alloc<0, struct std::_Vec_base_types<struct Token, class std::allocator<struct Token>>>::_Getal(void)const
.text$mn:00006550                 public ?_Getal@?$_Vector_alloc@$0A@U?$_Vec_base_types@UToken@@V?$allocator@UToken@@@std@@@std@@@std@@QBE?AU?$_Wrap_alloc@V?$allocator@UToken@@@std@@@2@XZ
.text$mn:00006550 ?_Getal@?$_Vector_alloc@$0A@U?$_Vec_base_types@UToken@@V?$allocator@UToken@@@std@@@std@@@std@@QBE?AU?$_Wrap_alloc@V?$allocator@UToken@@@std@@@2@XZ proc near
.text$mn:00006550                                         ; CODE XREF: std::vector<Token,std::allocator<Token>>::_Umove<Token *>(Token *,Token *,Token *)+10p
.text$mn:00006550                                         ; std::vector<Token,std::allocator<Token>>::_Destroy(Token *,Token *)+10p ...
.text$mn:00006550
.text$mn:00006550 var_4           = dword ptr -4
.text$mn:00006550 arg_0           = dword ptr  8
.text$mn:00006550
.text$mn:00006550                 push    ebp
.text$mn:00006551                 mov     ebp, esp
.text$mn:00006553                 push    ecx
.text$mn:00006554                 mov     [ebp+var_4], ecx
.text$mn:00006557                 mov     ecx, [ebp+arg_0]
.text$mn:0000655A                 call    ??0?$_Wrap_alloc@V?$allocator@UToken@@@std@@@std@@QAE@XZ ; std::_Wrap_alloc<std::allocator<Token>>::_Wrap_alloc<std::allocator<Token>>(void)
.text$mn:0000655F                 mov     eax, [ebp+arg_0]
.text$mn:00006562                 mov     esp, ebp
.text$mn:00006564                 pop     ebp
.text$mn:00006565                 retn    4
.text$mn:00006565 ?_Getal@?$_Vector_alloc@$0A@U?$_Vec_base_types@UToken@@V?$allocator@UToken@@@std@@@std@@@std@@QBE?AU?$_Wrap_alloc@V?$allocator@UToken@@@std@@@2@XZ endp
.text$mn:00006565
.text$mn:00006565 _text$mn        ends
.text$mn:00006565
.text$mn:00006568 ; ===========================================================================
.text$mn:00006568
.text$mn:00006568 ; Segment type: Pure code
.text$mn:00006568 ; Segment permissions: Read/Execute
.text$mn:00006568 _text$mn        segment para public 'CODE' use32
.text$mn:00006568                 assume cs:_text$mn
.text$mn:00006568                 ;org 6568h
.text$mn:00006568 ; COMDAT (pick any)
.text$mn:00006568                 assume es:nothing, ss:nothing, ds:_data, fs:nothing, gs:nothing
.text$mn:00006568
.text$mn:00006568 ; =============== S U B R O U T I N E =======================================
.text$mn:00006568
.text$mn:00006568 ; Attributes: bp-based frame
.text$mn:00006568
.text$mn:00006568 ; public: struct std::_Wrap_alloc<class std::allocator<class std::vector<wchar_t const *, class std::allocator<wchar_t const *>>>> __thiscall std::_Vector_alloc<0, struct std::_Vec_base_types<class std::vector<wchar_t const *, class std::allocator<wchar_t const *>>, class std::allocator<class std::vector<wchar_t const *, class std::allocator<wchar_t const *>>>>>::_Getal(void)const
.text$mn:00006568                 public ?_Getal@?$_Vector_alloc@$0A@U?$_Vec_base_types@V?$vector@PB_WV?$allocator@PB_W@std@@@std@@V?$allocator@V?$vector@PB_WV?$allocator@PB_W@std@@@std@@@2@@std@@@std@@QBE?AU?$_Wrap_alloc@V?$allocator@V?$vector@PB_WV?$allocator@PB_W@std@@@std@@@std@@@2@XZ
.text$mn:00006568 ?_Getal@?$_Vector_alloc@$0A@U?$_Vec_base_types@V?$vector@PB_WV?$allocator@PB_W@std@@@std@@V?$allocator@V?$vector@PB_WV?$allocator@PB_W@std@@@std@@@2@@std@@@std@@QBE?AU?$_Wrap_alloc@V?$allocator@V?$vector@PB_WV?$allocator@PB_W@std@@@std@@@std@@@2@XZ proc near
.text$mn:00006568                                         ; CODE XREF: std::vector<std::vector<wchar_t const *,std::allocator<wchar_t const *>>,std::allocator<std::vector<wchar_t const *,std::allocator<wchar_t const *>>>>::_Umove<std::vector<wchar_t const *,std::allocator<wchar_t const *>> *>(std::vector<wchar_t const *,std::allocator<wchar_t const *>> *,std::vector<wchar_t const *,std::allocator<wchar_t const *>> *,std::vector<wchar_t const *,std::allocator<wchar_t const *>> *)+10p
.text$mn:00006568                                         ; std::vector<std::vector<wchar_t const *,std::allocator<wchar_t const *>>,std::allocator<std::vector<wchar_t const *,std::allocator<wchar_t const *>>>>::_Destroy(std::vector<wchar_t const *,std::allocator<wchar_t const *>> *,std::vector<wchar_t const *,std::allocator<wchar_t const *>> *)+10p ...
.text$mn:00006568
.text$mn:00006568 var_4           = dword ptr -4
.text$mn:00006568 arg_0           = dword ptr  8
.text$mn:00006568
.text$mn:00006568                 push    ebp
.text$mn:00006569                 mov     ebp, esp
.text$mn:0000656B                 push    ecx
.text$mn:0000656C                 mov     [ebp+var_4], ecx
.text$mn:0000656F                 mov     ecx, [ebp+arg_0]
.text$mn:00006572                 call    ??0?$_Wrap_alloc@V?$allocator@V?$vector@PB_WV?$allocator@PB_W@std@@@std@@@std@@@std@@QAE@XZ ; std::_Wrap_alloc<std::allocator<std::vector<wchar_t const *,std::allocator<wchar_t const *>>>>::_Wrap_alloc<std::allocator<std::vector<wchar_t const *,std::allocator<wchar_t const *>>>>(void)
.text$mn:00006577                 mov     eax, [ebp+arg_0]
.text$mn:0000657A                 mov     esp, ebp
.text$mn:0000657C                 pop     ebp
.text$mn:0000657D                 retn    4
.text$mn:0000657D ?_Getal@?$_Vector_alloc@$0A@U?$_Vec_base_types@V?$vector@PB_WV?$allocator@PB_W@std@@@std@@V?$allocator@V?$vector@PB_WV?$allocator@PB_W@std@@@std@@@2@@std@@@std@@QBE?AU?$_Wrap_alloc@V?$allocator@V?$vector@PB_WV?$allocator@PB_W@std@@@std@@@std@@@2@XZ endp
.text$mn:0000657D
.text$mn:0000657D _text$mn        ends
.text$mn:0000657D
.text$mn:00006580 ; ===========================================================================
.text$mn:00006580
.text$mn:00006580 ; Segment type: Pure code
.text$mn:00006580 ; Segment permissions: Read/Execute
.text$mn:00006580 _text$mn        segment para public 'CODE' use32
.text$mn:00006580                 assume cs:_text$mn
.text$mn:00006580                 ;org 6580h
.text$mn:00006580 ; COMDAT (pick any)
.text$mn:00006580                 assume es:nothing, ss:nothing, ds:_data, fs:nothing, gs:nothing
.text$mn:00006580
.text$mn:00006580 ; =============== S U B R O U T I N E =======================================
.text$mn:00006580
.text$mn:00006580 ; Attributes: bp-based frame
.text$mn:00006580
.text$mn:00006580 ; const struct std::_Container_base12 *__thiscall std::_Iterator_base12::_Getcont(std::_Iterator_base12 *__hidden this)
.text$mn:00006580                 public ?_Getcont@_Iterator_base12@std@@QBEPBU_Container_base12@2@XZ
.text$mn:00006580 ?_Getcont@_Iterator_base12@std@@QBEPBU_Container_base12@2@XZ proc near
.text$mn:00006580                                         ; CODE XREF: std::_Vector_const_iterator<std::_Vector_val<std::_Simple_types<FunctionValues>>>::operator*(void)+Ap
.text$mn:00006580                                         ; std::_Vector_const_iterator<std::_Vector_val<std::_Simple_types<FunctionValues>>>::operator*(void)+1Fp ...
.text$mn:00006580
.text$mn:00006580 var_8           = dword ptr -8
.text$mn:00006580 var_4           = dword ptr -4
.text$mn:00006580
.text$mn:00006580                 push    ebp
.text$mn:00006581                 mov     ebp, esp
.text$mn:00006583                 sub     esp, 8
.text$mn:00006586                 mov     [ebp+var_4], ecx
.text$mn:00006589                 mov     eax, [ebp+var_4]
.text$mn:0000658C                 cmp     dword ptr [eax], 0
.text$mn:0000658F                 jnz     short loc_659A
.text$mn:00006591                 mov     [ebp+var_8], 0
.text$mn:00006598                 jmp     short loc_65A4
.text$mn:0000659A ; ---------------------------------------------------------------------------
.text$mn:0000659A
.text$mn:0000659A loc_659A:                               ; CODE XREF: std::_Iterator_base12::_Getcont(void)+Fj
.text$mn:0000659A                 mov     ecx, [ebp+var_4]
.text$mn:0000659D                 mov     edx, [ecx]
.text$mn:0000659F                 mov     eax, [edx]
.text$mn:000065A1                 mov     [ebp+var_8], eax
.text$mn:000065A4
.text$mn:000065A4 loc_65A4:                               ; CODE XREF: std::_Iterator_base12::_Getcont(void)+18j
.text$mn:000065A4                 mov     eax, [ebp+var_8]
.text$mn:000065A7                 mov     esp, ebp
.text$mn:000065A9                 pop     ebp
.text$mn:000065AA                 retn
.text$mn:000065AA ?_Getcont@_Iterator_base12@std@@QBEPBU_Container_base12@2@XZ endp
.text$mn:000065AA
.text$mn:000065AA ; ---------------------------------------------------------------------------
.text$mn:000065AB                 align 4
.text$mn:000065AB _text$mn        ends
.text$mn:000065AB
.text$mn:000065AC ; ===========================================================================
.text$mn:000065AC
.text$mn:000065AC ; Segment type: Pure code
.text$mn:000065AC ; Segment permissions: Read/Execute
.text$mn:000065AC _text$mn        segment para public 'CODE' use32
.text$mn:000065AC                 assume cs:_text$mn
.text$mn:000065AC                 ;org 65ACh
.text$mn:000065AC ; COMDAT (pick any)
.text$mn:000065AC                 assume es:nothing, ss:nothing, ds:_data, fs:nothing, gs:nothing
.text$mn:000065AC
.text$mn:000065AC ; =============== S U B R O U T I N E =======================================
.text$mn:000065AC
.text$mn:000065AC ; Attributes: bp-based frame
.text$mn:000065AC
.text$mn:000065AC ; struct std::_Iterator_base12 **__thiscall std::_Container_base12::_Getpfirst(std::_Container_base12 *__hidden this)
.text$mn:000065AC                 public ?_Getpfirst@_Container_base12@std@@QBEPAPAU_Iterator_base12@2@XZ
.text$mn:000065AC ?_Getpfirst@_Container_base12@std@@QBEPAPAU_Iterator_base12@2@XZ proc near
.text$mn:000065AC                                         ; CODE XREF: std::vector<wchar_t const *,std::allocator<wchar_t const *>>::_Orphan_range(wchar_t const * *,wchar_t const * *)+3Cp
.text$mn:000065AC                                         ; std::vector<FunctionValues,std::allocator<FunctionValues>>::_Orphan_range(FunctionValues *,FunctionValues *)+3Cp ...
.text$mn:000065AC
.text$mn:000065AC var_8           = dword ptr -8
.text$mn:000065AC var_4           = dword ptr -4
.text$mn:000065AC
.text$mn:000065AC                 push    ebp
.text$mn:000065AD                 mov     ebp, esp
.text$mn:000065AF                 sub     esp, 8
.text$mn:000065B2                 mov     [ebp+var_4], ecx
.text$mn:000065B5                 mov     eax, [ebp+var_4]
.text$mn:000065B8                 cmp     dword ptr [eax], 0
.text$mn:000065BB                 jnz     short loc_65C6
.text$mn:000065BD                 mov     [ebp+var_8], 0
.text$mn:000065C4                 jmp     short loc_65D1
.text$mn:000065C6 ; ---------------------------------------------------------------------------
.text$mn:000065C6
.text$mn:000065C6 loc_65C6:                               ; CODE XREF: std::_Container_base12::_Getpfirst(void)+Fj
.text$mn:000065C6                 mov     ecx, [ebp+var_4]
.text$mn:000065C9                 mov     edx, [ecx]
.text$mn:000065CB                 add     edx, 4
.text$mn:000065CE                 mov     [ebp+var_8], edx
.text$mn:000065D1
.text$mn:000065D1 loc_65D1:                               ; CODE XREF: std::_Container_base12::_Getpfirst(void)+18j
.text$mn:000065D1                 mov     eax, [ebp+var_8]
.text$mn:000065D4                 mov     esp, ebp
.text$mn:000065D6                 pop     ebp
.text$mn:000065D7                 retn
.text$mn:000065D7 ?_Getpfirst@_Container_base12@std@@QBEPAPAU_Iterator_base12@2@XZ endp
.text$mn:000065D7
.text$mn:000065D7 _text$mn        ends
.text$mn:000065D7
.text$mn:000065D8 ; ===========================================================================
.text$mn:000065D8
.text$mn:000065D8 ; Segment type: Pure code
.text$mn:000065D8 ; Segment permissions: Read/Execute
.text$mn:000065D8 _text$mn        segment para public 'CODE' use32
.text$mn:000065D8                 assume cs:_text$mn
.text$mn:000065D8                 ;org 65D8h
.text$mn:000065D8 ; COMDAT (pick any)
.text$mn:000065D8                 assume es:nothing, ss:nothing, ds:_data, fs:nothing, gs:nothing
.text$mn:000065D8
.text$mn:000065D8 ; =============== S U B R O U T I N E =======================================
.text$mn:000065D8
.text$mn:000065D8 ; Attributes: bp-based frame
.text$mn:000065D8
.text$mn:000065D8 ; struct std::_Iterator_base12 **__thiscall std::_Iterator_base12::_Getpnext(std::_Iterator_base12 *__hidden this)
.text$mn:000065D8                 public ?_Getpnext@_Iterator_base12@std@@QAEPAPAU12@XZ
.text$mn:000065D8 ?_Getpnext@_Iterator_base12@std@@QAEPAPAU12@XZ proc near
.text$mn:000065D8                                         ; CODE XREF: std::vector<wchar_t const *,std::allocator<wchar_t const *>>::_Orphan_range(wchar_t const * *,wchar_t const * *)+71p
.text$mn:000065D8                                         ; std::vector<wchar_t const *,std::allocator<wchar_t const *>>::_Orphan_range(wchar_t const * *,wchar_t const * *)+8Ap ...
.text$mn:000065D8
.text$mn:000065D8 var_4           = dword ptr -4
.text$mn:000065D8
.text$mn:000065D8                 push    ebp
.text$mn:000065D9                 mov     ebp, esp
.text$mn:000065DB                 push    ecx
.text$mn:000065DC                 mov     [ebp+var_4], ecx
.text$mn:000065DF                 mov     eax, [ebp+var_4]
.text$mn:000065E2                 add     eax, 4
.text$mn:000065E5                 mov     esp, ebp
.text$mn:000065E7                 pop     ebp
.text$mn:000065E8                 retn
.text$mn:000065E8 ?_Getpnext@_Iterator_base12@std@@QAEPAPAU12@XZ endp
.text$mn:000065E8
.text$mn:000065E8 ; ---------------------------------------------------------------------------
.text$mn:000065E9                 align 4
.text$mn:000065E9 _text$mn        ends
.text$mn:000065E9
.text$mn:000065EC ; ===========================================================================
.text$mn:000065EC
.text$mn:000065EC ; Segment type: Pure code
.text$mn:000065EC ; Segment permissions: Read/Execute
.text$mn:000065EC _text$mn        segment para public 'CODE' use32
.text$mn:000065EC                 assume cs:_text$mn
.text$mn:000065EC                 ;org 65ECh
.text$mn:000065EC ; COMDAT (pick any)
.text$mn:000065EC                 assume es:nothing, ss:nothing, ds:_data, fs:nothing, gs:nothing
.text$mn:000065EC
.text$mn:000065EC ; =============== S U B R O U T I N E =======================================
.text$mn:000065EC
.text$mn:000065EC ; Attributes: bp-based frame
.text$mn:000065EC
.text$mn:000065EC ; public: bool __thiscall std::basic_string<char, struct std::char_traits<char>, class std::allocator<char>>::_Grow(unsigned int, bool)
.text$mn:000065EC                 public ?_Grow@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE_NI_N@Z
.text$mn:000065EC ?_Grow@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE_NI_N@Z proc near
.text$mn:000065EC                                         ; CODE XREF: std::basic_string<char,std::char_traits<char>,std::allocator<char>>::assign(std::basic_string<char,std::char_traits<char>,std::allocator<char>> const &,uint,uint)+6Ap
.text$mn:000065EC                                         ; std::basic_string<char,std::char_traits<char>,std::allocator<char>>::assign(char const *,uint)+5Fp
.text$mn:000065EC
.text$mn:000065EC var_C           = dword ptr -0Ch
.text$mn:000065EC Size            = dword ptr -8
.text$mn:000065EC var_4           = dword ptr -4
.text$mn:000065EC arg_0           = dword ptr  8
.text$mn:000065EC arg_4           = byte ptr  0Ch
.text$mn:000065EC
.text$mn:000065EC                 push    ebp
.text$mn:000065ED                 mov     ebp, esp
.text$mn:000065EF                 sub     esp, 0Ch
.text$mn:000065F2                 mov     [ebp+var_4], ecx
.text$mn:000065F5                 mov     ecx, [ebp+var_4]
.text$mn:000065F8                 call    ?max_size@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QBEIXZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char>>::max_size(void)
.text$mn:000065FD                 cmp     eax, [ebp+arg_0]
.text$mn:00006600                 jnb     short loc_660A
.text$mn:00006602                 mov     ecx, [ebp+var_4]
.text$mn:00006605                 call    ?_Xlen@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QBEXXZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char>>::_Xlen(void)
.text$mn:0000660A
.text$mn:0000660A loc_660A:                               ; CODE XREF: std::basic_string<char,std::char_traits<char>,std::allocator<char>>::_Grow(uint,bool)+14j
.text$mn:0000660A                 mov     eax, [ebp+var_4]
.text$mn:0000660D                 mov     ecx, [eax+18h]
.text$mn:00006610                 cmp     ecx, [ebp+arg_0]
.text$mn:00006613                 jnb     short loc_662A
.text$mn:00006615                 mov     edx, [ebp+var_4]
.text$mn:00006618                 mov     eax, [edx+14h]
.text$mn:0000661B                 push    eax
.text$mn:0000661C                 mov     ecx, [ebp+arg_0]
.text$mn:0000661F                 push    ecx
.text$mn:00006620                 mov     ecx, [ebp+var_4]
.text$mn:00006623                 call    ?_Copy@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEXII@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char>>::_Copy(uint,uint)
.text$mn:00006628                 jmp     short loc_6674
.text$mn:0000662A ; ---------------------------------------------------------------------------
.text$mn:0000662A
.text$mn:0000662A loc_662A:                               ; CODE XREF: std::basic_string<char,std::char_traits<char>,std::allocator<char>>::_Grow(uint,bool)+27j
.text$mn:0000662A                 movzx   edx, [ebp+arg_4]
.text$mn:0000662E                 test    edx, edx
.text$mn:00006630                 jz      short loc_6664
.text$mn:00006632                 cmp     [ebp+arg_0], 10h
.text$mn:00006636                 jnb     short loc_6664
.text$mn:00006638                 mov     eax, [ebp+var_4]
.text$mn:0000663B                 mov     ecx, [ebp+arg_0]
.text$mn:0000663E                 cmp     ecx, [eax+14h]
.text$mn:00006641                 jnb     short loc_664B
.text$mn:00006643                 mov     edx, [ebp+arg_0]
.text$mn:00006646                 mov     [ebp+Size], edx
.text$mn:00006649                 jmp     short loc_6654
.text$mn:0000664B ; ---------------------------------------------------------------------------
.text$mn:0000664B
.text$mn:0000664B loc_664B:                               ; CODE XREF: std::basic_string<char,std::char_traits<char>,std::allocator<char>>::_Grow(uint,bool)+55j
.text$mn:0000664B                 mov     eax, [ebp+var_4]
.text$mn:0000664E                 mov     ecx, [eax+14h]
.text$mn:00006651                 mov     [ebp+Size], ecx
.text$mn:00006654
.text$mn:00006654 loc_6654:                               ; CODE XREF: std::basic_string<char,std::char_traits<char>,std::allocator<char>>::_Grow(uint,bool)+5Dj
.text$mn:00006654                 mov     edx, [ebp+Size]
.text$mn:00006657                 push    edx             ; Size
.text$mn:00006658                 push    1               ; char
.text$mn:0000665A                 mov     ecx, [ebp+var_4]
.text$mn:0000665D                 call    ?_Tidy@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEX_NI@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char>>::_Tidy(bool,uint)
.text$mn:00006662                 jmp     short loc_6674
.text$mn:00006664 ; ---------------------------------------------------------------------------
.text$mn:00006664
.text$mn:00006664 loc_6664:                               ; CODE XREF: std::basic_string<char,std::char_traits<char>,std::allocator<char>>::_Grow(uint,bool)+44j
.text$mn:00006664                                         ; std::basic_string<char,std::char_traits<char>,std::allocator<char>>::_Grow(uint,bool)+4Aj
.text$mn:00006664                 cmp     [ebp+arg_0], 0
.text$mn:00006668                 jnz     short loc_6674
.text$mn:0000666A                 push    0
.text$mn:0000666C                 mov     ecx, [ebp+var_4]
.text$mn:0000666F                 call    ?_Eos@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEXI@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char>>::_Eos(uint)
.text$mn:00006674
.text$mn:00006674 loc_6674:                               ; CODE XREF: std::basic_string<char,std::char_traits<char>,std::allocator<char>>::_Grow(uint,bool)+3Cj
.text$mn:00006674                                         ; std::basic_string<char,std::char_traits<char>,std::allocator<char>>::_Grow(uint,bool)+76j ...
.text$mn:00006674                 cmp     [ebp+arg_0], 0
.text$mn:00006678                 jbe     short loc_6683
.text$mn:0000667A                 mov     [ebp+var_C], 1
.text$mn:00006681                 jmp     short loc_668A
.text$mn:00006683 ; ---------------------------------------------------------------------------
.text$mn:00006683
.text$mn:00006683 loc_6683:                               ; CODE XREF: std::basic_string<char,std::char_traits<char>,std::allocator<char>>::_Grow(uint,bool)+8Cj
.text$mn:00006683                 mov     [ebp+var_C], 0
.text$mn:0000668A
.text$mn:0000668A loc_668A:                               ; CODE XREF: std::basic_string<char,std::char_traits<char>,std::allocator<char>>::_Grow(uint,bool)+95j
.text$mn:0000668A                 mov     al, byte ptr [ebp+var_C]
.text$mn:0000668D                 mov     esp, ebp
.text$mn:0000668F                 pop     ebp
.text$mn:00006690                 retn    8
.text$mn:00006690 ?_Grow@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE_NI_N@Z endp
.text$mn:00006690
.text$mn:00006690 ; ---------------------------------------------------------------------------
.text$mn:00006693                 align 4
.text$mn:00006693 _text$mn        ends
.text$mn:00006693
.text$mn:00006694 ; ===========================================================================
.text$mn:00006694
.text$mn:00006694 ; Segment type: Pure code
.text$mn:00006694 ; Segment permissions: Read/Execute
.text$mn:00006694 _text$mn        segment para public 'CODE' use32
.text$mn:00006694                 assume cs:_text$mn
.text$mn:00006694                 ;org 6694h
.text$mn:00006694 ; COMDAT (pick any)
.text$mn:00006694                 assume es:nothing, ss:nothing, ds:_data, fs:nothing, gs:nothing
.text$mn:00006694
.text$mn:00006694 ; =============== S U B R O U T I N E =======================================
.text$mn:00006694
.text$mn:00006694 ; Attributes: bp-based frame
.text$mn:00006694
.text$mn:00006694 ; protected: unsigned int __thiscall std::vector<wchar_t const *, class std::allocator<wchar_t const *>>::_Grow_to(unsigned int)const
.text$mn:00006694                 public ?_Grow_to@?$vector@PB_WV?$allocator@PB_W@std@@@std@@IBEII@Z
.text$mn:00006694 ?_Grow_to@?$vector@PB_WV?$allocator@PB_W@std@@@std@@IBEII@Z proc near
.text$mn:00006694                                         ; CODE XREF: std::vector<wchar_t const *,std::allocator<wchar_t const *>>::_Reserve(uint)+45p
.text$mn:00006694
.text$mn:00006694 var_C           = dword ptr -0Ch
.text$mn:00006694 var_8           = dword ptr -8
.text$mn:00006694 var_4           = dword ptr -4
.text$mn:00006694 arg_0           = dword ptr  8
.text$mn:00006694
.text$mn:00006694                 push    ebp
.text$mn:00006695                 mov     ebp, esp
.text$mn:00006697                 sub     esp, 0Ch
.text$mn:0000669A                 mov     [ebp+var_8], ecx
.text$mn:0000669D                 mov     ecx, [ebp+var_8]
.text$mn:000066A0                 call    ?capacity@?$vector@PB_WV?$allocator@PB_W@std@@@std@@QBEIXZ ; std::vector<wchar_t const *,std::allocator<wchar_t const *>>::capacity(void)
.text$mn:000066A5                 mov     [ebp+var_4], eax
.text$mn:000066A8                 mov     ecx, [ebp+var_8]
.text$mn:000066AB                 call    ?max_size@?$vector@PB_WV?$allocator@PB_W@std@@@std@@QBEIXZ ; std::vector<wchar_t const *,std::allocator<wchar_t const *>>::max_size(void)
.text$mn:000066B0                 mov     ecx, [ebp+var_4]
.text$mn:000066B3                 shr     ecx, 1
.text$mn:000066B5                 sub     eax, ecx
.text$mn:000066B7                 cmp     eax, [ebp+var_4]
.text$mn:000066BA                 jnb     short loc_66C5
.text$mn:000066BC                 mov     [ebp+var_C], 0
.text$mn:000066C3                 jmp     short loc_66D0
.text$mn:000066C5 ; ---------------------------------------------------------------------------
.text$mn:000066C5
.text$mn:000066C5 loc_66C5:                               ; CODE XREF: std::vector<wchar_t const *,std::allocator<wchar_t const *>>::_Grow_to(uint)+26j
.text$mn:000066C5                 mov     edx, [ebp+var_4]
.text$mn:000066C8                 shr     edx, 1
.text$mn:000066CA                 add     edx, [ebp+var_4]
.text$mn:000066CD                 mov     [ebp+var_C], edx
.text$mn:000066D0
.text$mn:000066D0 loc_66D0:                               ; CODE XREF: std::vector<wchar_t const *,std::allocator<wchar_t const *>>::_Grow_to(uint)+2Fj
.text$mn:000066D0                 mov     eax, [ebp+var_C]
.text$mn:000066D3                 mov     [ebp+var_4], eax
.text$mn:000066D6                 mov     ecx, [ebp+var_4]
.text$mn:000066D9                 cmp     ecx, [ebp+arg_0]
.text$mn:000066DC                 jnb     short loc_66E4
.text$mn:000066DE                 mov     edx, [ebp+arg_0]
.text$mn:000066E1                 mov     [ebp+var_4], edx
.text$mn:000066E4
.text$mn:000066E4 loc_66E4:                               ; CODE XREF: std::vector<wchar_t const *,std::allocator<wchar_t const *>>::_Grow_to(uint)+48j
.text$mn:000066E4                 mov     eax, [ebp+var_4]
.text$mn:000066E7                 mov     esp, ebp
.text$mn:000066E9                 pop     ebp
.text$mn:000066EA                 retn    4
.text$mn:000066EA ?_Grow_to@?$vector@PB_WV?$allocator@PB_W@std@@@std@@IBEII@Z endp
.text$mn:000066EA
.text$mn:000066EA ; ---------------------------------------------------------------------------
.text$mn:000066ED                 align 10h
.text$mn:000066ED _text$mn        ends
.text$mn:000066ED
.text$mn:000066F0 ; ===========================================================================
.text$mn:000066F0
.text$mn:000066F0 ; Segment type: Pure code
.text$mn:000066F0 ; Segment permissions: Read/Execute
.text$mn:000066F0 _text$mn        segment para public 'CODE' use32
.text$mn:000066F0                 assume cs:_text$mn
.text$mn:000066F0                 ;org 66F0h
.text$mn:000066F0 ; COMDAT (pick any)
.text$mn:000066F0                 assume es:nothing, ss:nothing, ds:_data, fs:nothing, gs:nothing
.text$mn:000066F0
.text$mn:000066F0 ; =============== S U B R O U T I N E =======================================
.text$mn:000066F0
.text$mn:000066F0 ; Attributes: bp-based frame
.text$mn:000066F0
.text$mn:000066F0 ; protected: unsigned int __thiscall std::vector<struct FunctionValues, class std::allocator<struct FunctionValues>>::_Grow_to(unsigned int)const
.text$mn:000066F0                 public ?_Grow_to@?$vector@UFunctionValues@@V?$allocator@UFunctionValues@@@std@@@std@@IBEII@Z
.text$mn:000066F0 ?_Grow_to@?$vector@UFunctionValues@@V?$allocator@UFunctionValues@@@std@@@std@@IBEII@Z proc near
.text$mn:000066F0                                         ; CODE XREF: std::vector<FunctionValues,std::allocator<FunctionValues>>::_Reserve(uint)+45p
.text$mn:000066F0
.text$mn:000066F0 var_C           = dword ptr -0Ch
.text$mn:000066F0 var_8           = dword ptr -8
.text$mn:000066F0 var_4           = dword ptr -4
.text$mn:000066F0 arg_0           = dword ptr  8
.text$mn:000066F0
.text$mn:000066F0                 push    ebp
.text$mn:000066F1                 mov     ebp, esp
.text$mn:000066F3                 sub     esp, 0Ch
.text$mn:000066F6                 mov     [ebp+var_8], ecx
.text$mn:000066F9                 mov     ecx, [ebp+var_8]
.text$mn:000066FC                 call    ?capacity@?$vector@UFunctionValues@@V?$allocator@UFunctionValues@@@std@@@std@@QBEIXZ ; std::vector<FunctionValues,std::allocator<FunctionValues>>::capacity(void)
.text$mn:00006701                 mov     [ebp+var_4], eax
.text$mn:00006704                 mov     ecx, [ebp+var_8]
.text$mn:00006707                 call    ?max_size@?$vector@UFunctionValues@@V?$allocator@UFunctionValues@@@std@@@std@@QBEIXZ ; std::vector<FunctionValues,std::allocator<FunctionValues>>::max_size(void)
.text$mn:0000670C                 mov     ecx, [ebp+var_4]
.text$mn:0000670F                 shr     ecx, 1
.text$mn:00006711                 sub     eax, ecx
.text$mn:00006713                 cmp     eax, [ebp+var_4]
.text$mn:00006716                 jnb     short loc_6721
.text$mn:00006718                 mov     [ebp+var_C], 0
.text$mn:0000671F                 jmp     short loc_672C
.text$mn:00006721 ; ---------------------------------------------------------------------------
.text$mn:00006721
.text$mn:00006721 loc_6721:                               ; CODE XREF: std::vector<FunctionValues,std::allocator<FunctionValues>>::_Grow_to(uint)+26j
.text$mn:00006721                 mov     edx, [ebp+var_4]
.text$mn:00006724                 shr     edx, 1
.text$mn:00006726                 add     edx, [ebp+var_4]
.text$mn:00006729                 mov     [ebp+var_C], edx
.text$mn:0000672C
.text$mn:0000672C loc_672C:                               ; CODE XREF: std::vector<FunctionValues,std::allocator<FunctionValues>>::_Grow_to(uint)+2Fj
.text$mn:0000672C                 mov     eax, [ebp+var_C]
.text$mn:0000672F                 mov     [ebp+var_4], eax
.text$mn:00006732                 mov     ecx, [ebp+var_4]
.text$mn:00006735                 cmp     ecx, [ebp+arg_0]
.text$mn:00006738                 jnb     short loc_6740
.text$mn:0000673A                 mov     edx, [ebp+arg_0]
.text$mn:0000673D                 mov     [ebp+var_4], edx
.text$mn:00006740
.text$mn:00006740 loc_6740:                               ; CODE XREF: std::vector<FunctionValues,std::allocator<FunctionValues>>::_Grow_to(uint)+48j
.text$mn:00006740                 mov     eax, [ebp+var_4]
.text$mn:00006743                 mov     esp, ebp
.text$mn:00006745                 pop     ebp
.text$mn:00006746                 retn    4
.text$mn:00006746 ?_Grow_to@?$vector@UFunctionValues@@V?$allocator@UFunctionValues@@@std@@@std@@IBEII@Z endp
.text$mn:00006746
.text$mn:00006746 ; ---------------------------------------------------------------------------
.text$mn:00006749                 align 4
.text$mn:00006749 _text$mn        ends
.text$mn:00006749
.text$mn:0000674C ; ===========================================================================
.text$mn:0000674C
.text$mn:0000674C ; Segment type: Pure code
.text$mn:0000674C ; Segment permissions: Read/Execute
.text$mn:0000674C _text$mn        segment para public 'CODE' use32
.text$mn:0000674C                 assume cs:_text$mn
.text$mn:0000674C                 ;org 674Ch
.text$mn:0000674C ; COMDAT (pick any)
.text$mn:0000674C                 assume es:nothing, ss:nothing, ds:_data, fs:nothing, gs:nothing
.text$mn:0000674C
.text$mn:0000674C ; =============== S U B R O U T I N E =======================================
.text$mn:0000674C
.text$mn:0000674C ; Attributes: bp-based frame
.text$mn:0000674C
.text$mn:0000674C ; protected: unsigned int __thiscall std::vector<struct Token, class std::allocator<struct Token>>::_Grow_to(unsigned int)const
.text$mn:0000674C                 public ?_Grow_to@?$vector@UToken@@V?$allocator@UToken@@@std@@@std@@IBEII@Z
.text$mn:0000674C ?_Grow_to@?$vector@UToken@@V?$allocator@UToken@@@std@@@std@@IBEII@Z proc near
.text$mn:0000674C                                         ; CODE XREF: std::vector<Token,std::allocator<Token>>::_Reserve(uint)+45p
.text$mn:0000674C
.text$mn:0000674C var_C           = dword ptr -0Ch
.text$mn:0000674C var_8           = dword ptr -8
.text$mn:0000674C var_4           = dword ptr -4
.text$mn:0000674C arg_0           = dword ptr  8
.text$mn:0000674C
.text$mn:0000674C                 push    ebp
.text$mn:0000674D                 mov     ebp, esp
.text$mn:0000674F                 sub     esp, 0Ch
.text$mn:00006752                 mov     [ebp+var_8], ecx
.text$mn:00006755                 mov     ecx, [ebp+var_8]
.text$mn:00006758                 call    ?capacity@?$vector@UToken@@V?$allocator@UToken@@@std@@@std@@QBEIXZ ; std::vector<Token,std::allocator<Token>>::capacity(void)
.text$mn:0000675D                 mov     [ebp+var_4], eax
.text$mn:00006760                 mov     ecx, [ebp+var_8]
.text$mn:00006763                 call    ?max_size@?$vector@UToken@@V?$allocator@UToken@@@std@@@std@@QBEIXZ ; std::vector<Token,std::allocator<Token>>::max_size(void)
.text$mn:00006768                 mov     ecx, [ebp+var_4]
.text$mn:0000676B                 shr     ecx, 1
.text$mn:0000676D                 sub     eax, ecx
.text$mn:0000676F                 cmp     eax, [ebp+var_4]
.text$mn:00006772                 jnb     short loc_677D
.text$mn:00006774                 mov     [ebp+var_C], 0
.text$mn:0000677B                 jmp     short loc_6788
.text$mn:0000677D ; ---------------------------------------------------------------------------
.text$mn:0000677D
.text$mn:0000677D loc_677D:                               ; CODE XREF: std::vector<Token,std::allocator<Token>>::_Grow_to(uint)+26j
.text$mn:0000677D                 mov     edx, [ebp+var_4]
.text$mn:00006780                 shr     edx, 1
.text$mn:00006782                 add     edx, [ebp+var_4]
.text$mn:00006785                 mov     [ebp+var_C], edx
.text$mn:00006788
.text$mn:00006788 loc_6788:                               ; CODE XREF: std::vector<Token,std::allocator<Token>>::_Grow_to(uint)+2Fj
.text$mn:00006788                 mov     eax, [ebp+var_C]
.text$mn:0000678B                 mov     [ebp+var_4], eax
.text$mn:0000678E                 mov     ecx, [ebp+var_4]
.text$mn:00006791                 cmp     ecx, [ebp+arg_0]
.text$mn:00006794                 jnb     short loc_679C
.text$mn:00006796                 mov     edx, [ebp+arg_0]
.text$mn:00006799                 mov     [ebp+var_4], edx
.text$mn:0000679C
.text$mn:0000679C loc_679C:                               ; CODE XREF: std::vector<Token,std::allocator<Token>>::_Grow_to(uint)+48j
.text$mn:0000679C                 mov     eax, [ebp+var_4]
.text$mn:0000679F                 mov     esp, ebp
.text$mn:000067A1                 pop     ebp
.text$mn:000067A2                 retn    4
.text$mn:000067A2 ?_Grow_to@?$vector@UToken@@V?$allocator@UToken@@@std@@@std@@IBEII@Z endp
.text$mn:000067A2
.text$mn:000067A2 ; ---------------------------------------------------------------------------
.text$mn:000067A5                 align 4
.text$mn:000067A5 _text$mn        ends
.text$mn:000067A5
.text$mn:000067A8 ; ===========================================================================
.text$mn:000067A8
.text$mn:000067A8 ; Segment type: Pure code
.text$mn:000067A8 ; Segment permissions: Read/Execute
.text$mn:000067A8 _text$mn        segment para public 'CODE' use32
.text$mn:000067A8                 assume cs:_text$mn
.text$mn:000067A8                 ;org 67A8h
.text$mn:000067A8 ; COMDAT (pick any)
.text$mn:000067A8                 assume es:nothing, ss:nothing, ds:_data, fs:nothing, gs:nothing
.text$mn:000067A8
.text$mn:000067A8 ; =============== S U B R O U T I N E =======================================
.text$mn:000067A8
.text$mn:000067A8 ; Attributes: bp-based frame
.text$mn:000067A8
.text$mn:000067A8 ; protected: unsigned int __thiscall std::vector<class std::vector<wchar_t const *, class std::allocator<wchar_t const *>>, class std::allocator<class std::vector<wchar_t const *, class std::allocator<wchar_t const *>>>>::_Grow_to(unsigned int)const
.text$mn:000067A8                 public ?_Grow_to@?$vector@V?$vector@PB_WV?$allocator@PB_W@std@@@std@@V?$allocator@V?$vector@PB_WV?$allocator@PB_W@std@@@std@@@2@@std@@IBEII@Z
.text$mn:000067A8 ?_Grow_to@?$vector@V?$vector@PB_WV?$allocator@PB_W@std@@@std@@V?$allocator@V?$vector@PB_WV?$allocator@PB_W@std@@@std@@@2@@std@@IBEII@Z proc near
.text$mn:000067A8                                         ; CODE XREF: std::vector<std::vector<wchar_t const *,std::allocator<wchar_t const *>>,std::allocator<std::vector<wchar_t const *,std::allocator<wchar_t const *>>>>::_Reserve(uint)+45p
.text$mn:000067A8
.text$mn:000067A8 var_C           = dword ptr -0Ch
.text$mn:000067A8 var_8           = dword ptr -8
.text$mn:000067A8 var_4           = dword ptr -4
.text$mn:000067A8 arg_0           = dword ptr  8
.text$mn:000067A8
.text$mn:000067A8                 push    ebp
.text$mn:000067A9                 mov     ebp, esp
.text$mn:000067AB                 sub     esp, 0Ch
.text$mn:000067AE                 mov     [ebp+var_8], ecx
.text$mn:000067B1                 mov     ecx, [ebp+var_8]
.text$mn:000067B4                 call    ?capacity@?$vector@V?$vector@PB_WV?$allocator@PB_W@std@@@std@@V?$allocator@V?$vector@PB_WV?$allocator@PB_W@std@@@std@@@2@@std@@QBEIXZ ; std::vector<std::vector<wchar_t const *,std::allocator<wchar_t const *>>,std::allocator<std::vector<wchar_t const *,std::allocator<wchar_t const *>>>>::capacity(void)
.text$mn:000067B9                 mov     [ebp+var_4], eax
.text$mn:000067BC                 mov     ecx, [ebp+var_8]
.text$mn:000067BF                 call    ?max_size@?$vector@V?$vector@PB_WV?$allocator@PB_W@std@@@std@@V?$allocator@V?$vector@PB_WV?$allocator@PB_W@std@@@std@@@2@@std@@QBEIXZ ; std::vector<std::vector<wchar_t const *,std::allocator<wchar_t const *>>,std::allocator<std::vector<wchar_t const *,std::allocator<wchar_t const *>>>>::max_size(void)
.text$mn:000067C4                 mov     ecx, [ebp+var_4]
.text$mn:000067C7                 shr     ecx, 1
.text$mn:000067C9                 sub     eax, ecx
.text$mn:000067CB                 cmp     eax, [ebp+var_4]
.text$mn:000067CE                 jnb     short loc_67D9
.text$mn:000067D0                 mov     [ebp+var_C], 0
.text$mn:000067D7                 jmp     short loc_67E4
.text$mn:000067D9 ; ---------------------------------------------------------------------------
.text$mn:000067D9
.text$mn:000067D9 loc_67D9:                               ; CODE XREF: std::vector<std::vector<wchar_t const *,std::allocator<wchar_t const *>>,std::allocator<std::vector<wchar_t const *,std::allocator<wchar_t const *>>>>::_Grow_to(uint)+26j
.text$mn:000067D9                 mov     edx, [ebp+var_4]
.text$mn:000067DC                 shr     edx, 1
.text$mn:000067DE                 add     edx, [ebp+var_4]
.text$mn:000067E1                 mov     [ebp+var_C], edx
.text$mn:000067E4
.text$mn:000067E4 loc_67E4:                               ; CODE XREF: std::vector<std::vector<wchar_t const *,std::allocator<wchar_t const *>>,std::allocator<std::vector<wchar_t const *,std::allocator<wchar_t const *>>>>::_Grow_to(uint)+2Fj
.text$mn:000067E4                 mov     eax, [ebp+var_C]
.text$mn:000067E7                 mov     [ebp+var_4], eax
.text$mn:000067EA                 mov     ecx, [ebp+var_4]
.text$mn:000067ED                 cmp     ecx, [ebp+arg_0]
.text$mn:000067F0                 jnb     short loc_67F8
.text$mn:000067F2                 mov     edx, [ebp+arg_0]
.text$mn:000067F5                 mov     [ebp+var_4], edx
.text$mn:000067F8
.text$mn:000067F8 loc_67F8:                               ; CODE XREF: std::vector<std::vector<wchar_t const *,std::allocator<wchar_t const *>>,std::allocator<std::vector<wchar_t const *,std::allocator<wchar_t const *>>>>::_Grow_to(uint)+48j
.text$mn:000067F8                 mov     eax, [ebp+var_4]
.text$mn:000067FB                 mov     esp, ebp
.text$mn:000067FD                 pop     ebp
.text$mn:000067FE                 retn    4
.text$mn:000067FE ?_Grow_to@?$vector@V?$vector@PB_WV?$allocator@PB_W@std@@@std@@V?$allocator@V?$vector@PB_WV?$allocator@PB_W@std@@@std@@@2@@std@@IBEII@Z endp
.text$mn:000067FE
.text$mn:000067FE ; ---------------------------------------------------------------------------
.text$mn:00006801                 align 4
.text$mn:00006801 _text$mn        ends
.text$mn:00006801
.text$mn:00006804 ; ===========================================================================
.text$mn:00006804
.text$mn:00006804 ; Segment type: Pure code
.text$mn:00006804 ; Segment permissions: Read/Execute
.text$mn:00006804 _text$mn        segment para public 'CODE' use32
.text$mn:00006804                 assume cs:_text$mn
.text$mn:00006804                 ;org 6804h
.text$mn:00006804 ; COMDAT (pick any)
.text$mn:00006804                 assume es:nothing, ss:nothing, ds:_data, fs:nothing, gs:nothing
.text$mn:00006804
.text$mn:00006804 ; =============== S U B R O U T I N E =======================================
.text$mn:00006804
.text$mn:00006804 ; Attributes: bp-based frame
.text$mn:00006804
.text$mn:00006804 ; public: bool __thiscall std::basic_string<char, struct std::char_traits<char>, class std::allocator<char>>::_Inside(char const *)
.text$mn:00006804                 public ?_Inside@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE_NPBD@Z
.text$mn:00006804 ?_Inside@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE_NPBD@Z proc near
.text$mn:00006804                                         ; CODE XREF: std::basic_string<char,std::char_traits<char>,std::allocator<char>>::assign(char const *,uint)+2Ap
.text$mn:00006804
.text$mn:00006804 var_4           = dword ptr -4
.text$mn:00006804 arg_0           = dword ptr  8
.text$mn:00006804
.text$mn:00006804                 push    ebp
.text$mn:00006805                 mov     ebp, esp
.text$mn:00006807                 push    ecx
.text$mn:00006808                 mov     [ebp+var_4], ecx
.text$mn:0000680B                 cmp     [ebp+arg_0], 0
.text$mn:0000680F                 jz      short loc_6831
.text$mn:00006811                 mov     ecx, [ebp+var_4]
.text$mn:00006814                 call    ?_Myptr@?$_String_val@U?$_Simple_types@D@std@@@std@@QAEPADXZ ; std::_String_val<std::_Simple_types<char>>::_Myptr(void)
.text$mn:00006819                 cmp     [ebp+arg_0], eax
.text$mn:0000681C                 jb      short loc_6831
.text$mn:0000681E                 mov     ecx, [ebp+var_4]
.text$mn:00006821                 call    ?_Myptr@?$_String_val@U?$_Simple_types@D@std@@@std@@QAEPADXZ ; std::_String_val<std::_Simple_types<char>>::_Myptr(void)
.text$mn:00006826                 mov     ecx, [ebp+var_4]
.text$mn:00006829                 add     eax, [ecx+14h]
.text$mn:0000682C                 cmp     eax, [ebp+arg_0]
.text$mn:0000682F                 ja      short loc_6837
.text$mn:00006831
.text$mn:00006831 loc_6831:                               ; CODE XREF: std::basic_string<char,std::char_traits<char>,std::allocator<char>>::_Inside(char const *)+Bj
.text$mn:00006831                                         ; std::basic_string<char,std::char_traits<char>,std::allocator<char>>::_Inside(char const *)+18j
.text$mn:00006831                 xor     al, al
.text$mn:00006833                 jmp     short loc_6839
.text$mn:00006835 ; ---------------------------------------------------------------------------
.text$mn:00006835                 jmp     short loc_6839
.text$mn:00006837 ; ---------------------------------------------------------------------------
.text$mn:00006837
.text$mn:00006837 loc_6837:                               ; CODE XREF: std::basic_string<char,std::char_traits<char>,std::allocator<char>>::_Inside(char const *)+2Bj
.text$mn:00006837                 mov     al, 1
.text$mn:00006839
.text$mn:00006839 loc_6839:                               ; CODE XREF: std::basic_string<char,std::char_traits<char>,std::allocator<char>>::_Inside(char const *)+2Fj
.text$mn:00006839                                         ; std::basic_string<char,std::char_traits<char>,std::allocator<char>>::_Inside(char const *)+31j
.text$mn:00006839                 mov     esp, ebp
.text$mn:0000683B                 pop     ebp
.text$mn:0000683C                 retn    4
.text$mn:0000683C ?_Inside@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE_NPBD@Z endp
.text$mn:0000683C
.text$mn:0000683C ; ---------------------------------------------------------------------------
.text$mn:0000683F                 align 10h
.text$mn:0000683F _text$mn        ends
.text$mn:0000683F
.text$mn:00006840 ; ===========================================================================
.text$mn:00006840
.text$mn:00006840 ; Segment type: Pure code
.text$mn:00006840 ; Segment permissions: Read/Execute
.text$mn:00006840 _text$mn        segment para public 'CODE' use32
.text$mn:00006840                 assume cs:_text$mn
.text$mn:00006840                 ;org 6840h
.text$mn:00006840 ; COMDAT (pick any)
.text$mn:00006840                 assume es:nothing, ss:nothing, ds:_data, fs:nothing, gs:nothing
.text$mn:00006840
.text$mn:00006840 ; =============== S U B R O U T I N E =======================================
.text$mn:00006840
.text$mn:00006840 ; Attributes: bp-based frame
.text$mn:00006840
.text$mn:00006840 ; protected: bool __thiscall std::vector<wchar_t const *, class std::allocator<wchar_t const *>>::_Inside(wchar_t const * const *)const
.text$mn:00006840                 public ?_Inside@?$vector@PB_WV?$allocator@PB_W@std@@@std@@IBE_NPBQB_W@Z
.text$mn:00006840 ?_Inside@?$vector@PB_WV?$allocator@PB_W@std@@@std@@IBE_NPBQB_W@Z proc near
.text$mn:00006840                                         ; CODE XREF: std::vector<wchar_t const *,std::allocator<wchar_t const *>>::push_back(wchar_t const * const &)+19p
.text$mn:00006840
.text$mn:00006840 var_8           = dword ptr -8
.text$mn:00006840 var_4           = dword ptr -4
.text$mn:00006840 arg_0           = dword ptr  8
.text$mn:00006840
.text$mn:00006840                 push    ebp
.text$mn:00006841                 mov     ebp, esp
.text$mn:00006843                 sub     esp, 8
.text$mn:00006846                 mov     [ebp+var_4], ecx
.text$mn:00006849                 mov     eax, [ebp+var_4]
.text$mn:0000684C                 mov     ecx, [ebp+arg_0]
.text$mn:0000684F                 cmp     ecx, [eax+8]
.text$mn:00006852                 jnb     short loc_6868
.text$mn:00006854                 mov     edx, [ebp+var_4]
.text$mn:00006857                 mov     eax, [edx+4]
.text$mn:0000685A                 cmp     eax, [ebp+arg_0]
.text$mn:0000685D                 ja      short loc_6868
.text$mn:0000685F                 mov     [ebp+var_8], 1
.text$mn:00006866                 jmp     short loc_686F
.text$mn:00006868 ; ---------------------------------------------------------------------------
.text$mn:00006868
.text$mn:00006868 loc_6868:                               ; CODE XREF: std::vector<wchar_t const *,std::allocator<wchar_t const *>>::_Inside(wchar_t const * const *)+12j
.text$mn:00006868                                         ; std::vector<wchar_t const *,std::allocator<wchar_t const *>>::_Inside(wchar_t const * const *)+1Dj
.text$mn:00006868                 mov     [ebp+var_8], 0
.text$mn:0000686F
.text$mn:0000686F loc_686F:                               ; CODE XREF: std::vector<wchar_t const *,std::allocator<wchar_t const *>>::_Inside(wchar_t const * const *)+26j
.text$mn:0000686F                 mov     al, byte ptr [ebp+var_8]
.text$mn:00006872                 mov     esp, ebp
.text$mn:00006874                 pop     ebp
.text$mn:00006875                 retn    4
.text$mn:00006875 ?_Inside@?$vector@PB_WV?$allocator@PB_W@std@@@std@@IBE_NPBQB_W@Z endp
.text$mn:00006875
.text$mn:00006875 _text$mn        ends
.text$mn:00006875
.text$mn:00006878 ; ===========================================================================
.text$mn:00006878
.text$mn:00006878 ; Segment type: Pure code
.text$mn:00006878 ; Segment permissions: Read/Execute
.text$mn:00006878 _text$mn        segment para public 'CODE' use32
.text$mn:00006878                 assume cs:_text$mn
.text$mn:00006878                 ;org 6878h
.text$mn:00006878 ; COMDAT (pick any)
.text$mn:00006878                 assume es:nothing, ss:nothing, ds:_data, fs:nothing, gs:nothing
.text$mn:00006878
.text$mn:00006878 ; =============== S U B R O U T I N E =======================================
.text$mn:00006878
.text$mn:00006878 ; Attributes: bp-based frame
.text$mn:00006878
.text$mn:00006878 ; protected: bool __thiscall std::vector<struct FunctionValues, class std::allocator<struct FunctionValues>>::_Inside(struct FunctionValues const *)const
.text$mn:00006878                 public ?_Inside@?$vector@UFunctionValues@@V?$allocator@UFunctionValues@@@std@@@std@@IBE_NPBUFunctionValues@@@Z
.text$mn:00006878 ?_Inside@?$vector@UFunctionValues@@V?$allocator@UFunctionValues@@@std@@@std@@IBE_NPBUFunctionValues@@@Z proc near
.text$mn:00006878                                         ; CODE XREF: std::vector<FunctionValues,std::allocator<FunctionValues>>::push_back(FunctionValues const &)+19p
.text$mn:00006878
.text$mn:00006878 var_8           = dword ptr -8
.text$mn:00006878 var_4           = dword ptr -4
.text$mn:00006878 arg_0           = dword ptr  8
.text$mn:00006878
.text$mn:00006878                 push    ebp
.text$mn:00006879                 mov     ebp, esp
.text$mn:0000687B                 sub     esp, 8
.text$mn:0000687E                 mov     [ebp+var_4], ecx
.text$mn:00006881                 mov     eax, [ebp+var_4]
.text$mn:00006884                 mov     ecx, [ebp+arg_0]
.text$mn:00006887                 cmp     ecx, [eax+8]
.text$mn:0000688A                 jnb     short loc_68A0
.text$mn:0000688C                 mov     edx, [ebp+var_4]
.text$mn:0000688F                 mov     eax, [edx+4]
.text$mn:00006892                 cmp     eax, [ebp+arg_0]
.text$mn:00006895                 ja      short loc_68A0
.text$mn:00006897                 mov     [ebp+var_8], 1
.text$mn:0000689E                 jmp     short loc_68A7
.text$mn:000068A0 ; ---------------------------------------------------------------------------
.text$mn:000068A0
.text$mn:000068A0 loc_68A0:                               ; CODE XREF: std::vector<FunctionValues,std::allocator<FunctionValues>>::_Inside(FunctionValues const *)+12j
.text$mn:000068A0                                         ; std::vector<FunctionValues,std::allocator<FunctionValues>>::_Inside(FunctionValues const *)+1Dj
.text$mn:000068A0                 mov     [ebp+var_8], 0
.text$mn:000068A7
.text$mn:000068A7 loc_68A7:                               ; CODE XREF: std::vector<FunctionValues,std::allocator<FunctionValues>>::_Inside(FunctionValues const *)+26j
.text$mn:000068A7                 mov     al, byte ptr [ebp+var_8]
.text$mn:000068AA                 mov     esp, ebp
.text$mn:000068AC                 pop     ebp
.text$mn:000068AD                 retn    4
.text$mn:000068AD ?_Inside@?$vector@UFunctionValues@@V?$allocator@UFunctionValues@@@std@@@std@@IBE_NPBUFunctionValues@@@Z endp
.text$mn:000068AD
.text$mn:000068AD _text$mn        ends
.text$mn:000068AD
.text$mn:000068B0 ; ===========================================================================
.text$mn:000068B0
.text$mn:000068B0 ; Segment type: Pure code
.text$mn:000068B0 ; Segment permissions: Read/Execute
.text$mn:000068B0 _text$mn        segment para public 'CODE' use32
.text$mn:000068B0                 assume cs:_text$mn
.text$mn:000068B0                 ;org 68B0h
.text$mn:000068B0 ; COMDAT (pick any)
.text$mn:000068B0                 assume es:nothing, ss:nothing, ds:_data, fs:nothing, gs:nothing
.text$mn:000068B0
.text$mn:000068B0 ; =============== S U B R O U T I N E =======================================
.text$mn:000068B0
.text$mn:000068B0 ; Attributes: bp-based frame
.text$mn:000068B0
.text$mn:000068B0 ; protected: bool __thiscall std::vector<struct Token, class std::allocator<struct Token>>::_Inside(struct Token const *)const
.text$mn:000068B0                 public ?_Inside@?$vector@UToken@@V?$allocator@UToken@@@std@@@std@@IBE_NPBUToken@@@Z
.text$mn:000068B0 ?_Inside@?$vector@UToken@@V?$allocator@UToken@@@std@@@std@@IBE_NPBUToken@@@Z proc near
.text$mn:000068B0                                         ; CODE XREF: std::vector<Token,std::allocator<Token>>::push_back(Token &&)+19p
.text$mn:000068B0
.text$mn:000068B0 var_8           = dword ptr -8
.text$mn:000068B0 var_4           = dword ptr -4
.text$mn:000068B0 arg_0           = dword ptr  8
.text$mn:000068B0
.text$mn:000068B0                 push    ebp
.text$mn:000068B1                 mov     ebp, esp
.text$mn:000068B3                 sub     esp, 8
.text$mn:000068B6                 mov     [ebp+var_4], ecx
.text$mn:000068B9                 mov     eax, [ebp+var_4]
.text$mn:000068BC                 mov     ecx, [ebp+arg_0]
.text$mn:000068BF                 cmp     ecx, [eax+8]
.text$mn:000068C2                 jnb     short loc_68D8
.text$mn:000068C4                 mov     edx, [ebp+var_4]
.text$mn:000068C7                 mov     eax, [edx+4]
.text$mn:000068CA                 cmp     eax, [ebp+arg_0]
.text$mn:000068CD                 ja      short loc_68D8
.text$mn:000068CF                 mov     [ebp+var_8], 1
.text$mn:000068D6                 jmp     short loc_68DF
.text$mn:000068D8 ; ---------------------------------------------------------------------------
.text$mn:000068D8
.text$mn:000068D8 loc_68D8:                               ; CODE XREF: std::vector<Token,std::allocator<Token>>::_Inside(Token const *)+12j
.text$mn:000068D8                                         ; std::vector<Token,std::allocator<Token>>::_Inside(Token const *)+1Dj
.text$mn:000068D8                 mov     [ebp+var_8], 0
.text$mn:000068DF
.text$mn:000068DF loc_68DF:                               ; CODE XREF: std::vector<Token,std::allocator<Token>>::_Inside(Token const *)+26j
.text$mn:000068DF                 mov     al, byte ptr [ebp+var_8]
.text$mn:000068E2                 mov     esp, ebp
.text$mn:000068E4                 pop     ebp
.text$mn:000068E5                 retn    4
.text$mn:000068E5 ?_Inside@?$vector@UToken@@V?$allocator@UToken@@@std@@@std@@IBE_NPBUToken@@@Z endp
.text$mn:000068E5
.text$mn:000068E5 _text$mn        ends
.text$mn:000068E5
.text$mn:000068E8 ; ===========================================================================
.text$mn:000068E8
.text$mn:000068E8 ; Segment type: Pure code
.text$mn:000068E8 ; Segment permissions: Read/Execute
.text$mn:000068E8 _text$mn        segment para public 'CODE' use32
.text$mn:000068E8                 assume cs:_text$mn
.text$mn:000068E8                 ;org 68E8h
.text$mn:000068E8 ; COMDAT (pick any)
.text$mn:000068E8                 assume es:nothing, ss:nothing, ds:_data, fs:nothing, gs:nothing
.text$mn:000068E8
.text$mn:000068E8 ; =============== S U B R O U T I N E =======================================
.text$mn:000068E8
.text$mn:000068E8 ; Attributes: bp-based frame
.text$mn:000068E8
.text$mn:000068E8 ; protected: bool __thiscall std::vector<class std::vector<wchar_t const *, class std::allocator<wchar_t const *>>, class std::allocator<class std::vector<wchar_t const *, class std::allocator<wchar_t const *>>>>::_Inside(class std::vector<wchar_t const *, class std::allocator<wchar_t const *>> const *)const
.text$mn:000068E8                 public ?_Inside@?$vector@V?$vector@PB_WV?$allocator@PB_W@std@@@std@@V?$allocator@V?$vector@PB_WV?$allocator@PB_W@std@@@std@@@2@@std@@IBE_NPBV?$vector@PB_WV?$allocator@PB_W@std@@@2@@Z
.text$mn:000068E8 ?_Inside@?$vector@V?$vector@PB_WV?$allocator@PB_W@std@@@std@@V?$allocator@V?$vector@PB_WV?$allocator@PB_W@std@@@std@@@2@@std@@IBE_NPBV?$vector@PB_WV?$allocator@PB_W@std@@@2@@Z proc near
.text$mn:000068E8                                         ; CODE XREF: std::vector<std::vector<wchar_t const *,std::allocator<wchar_t const *>>,std::allocator<std::vector<wchar_t const *,std::allocator<wchar_t const *>>>>::push_back(std::vector<wchar_t const *,std::allocator<wchar_t const *>> const &)+19p
.text$mn:000068E8
.text$mn:000068E8 var_8           = dword ptr -8
.text$mn:000068E8 var_4           = dword ptr -4
.text$mn:000068E8 arg_0           = dword ptr  8
.text$mn:000068E8
.text$mn:000068E8                 push    ebp
.text$mn:000068E9                 mov     ebp, esp
.text$mn:000068EB                 sub     esp, 8
.text$mn:000068EE                 mov     [ebp+var_4], ecx
.text$mn:000068F1                 mov     eax, [ebp+var_4]
.text$mn:000068F4                 mov     ecx, [ebp+arg_0]
.text$mn:000068F7                 cmp     ecx, [eax+8]
.text$mn:000068FA                 jnb     short loc_6910
.text$mn:000068FC                 mov     edx, [ebp+var_4]
.text$mn:000068FF                 mov     eax, [edx+4]
.text$mn:00006902                 cmp     eax, [ebp+arg_0]
.text$mn:00006905                 ja      short loc_6910
.text$mn:00006907                 mov     [ebp+var_8], 1
.text$mn:0000690E                 jmp     short loc_6917
.text$mn:00006910 ; ---------------------------------------------------------------------------
.text$mn:00006910
.text$mn:00006910 loc_6910:                               ; CODE XREF: std::vector<std::vector<wchar_t const *,std::allocator<wchar_t const *>>,std::allocator<std::vector<wchar_t const *,std::allocator<wchar_t const *>>>>::_Inside(std::vector<wchar_t const *,std::allocator<wchar_t const *>> const *)+12j
.text$mn:00006910                                         ; std::vector<std::vector<wchar_t const *,std::allocator<wchar_t const *>>,std::allocator<std::vector<wchar_t const *,std::allocator<wchar_t const *>>>>::_Inside(std::vector<wchar_t const *,std::allocator<wchar_t const *>> const *)+1Dj
.text$mn:00006910                 mov     [ebp+var_8], 0
.text$mn:00006917
.text$mn:00006917 loc_6917:                               ; CODE XREF: std::vector<std::vector<wchar_t const *,std::allocator<wchar_t const *>>,std::allocator<std::vector<wchar_t const *,std::allocator<wchar_t const *>>>>::_Inside(std::vector<wchar_t const *,std::allocator<wchar_t const *>> const *)+26j
.text$mn:00006917                 mov     al, byte ptr [ebp+var_8]
.text$mn:0000691A                 mov     esp, ebp
.text$mn:0000691C                 pop     ebp
.text$mn:0000691D                 retn    4
.text$mn:0000691D ?_Inside@?$vector@V?$vector@PB_WV?$allocator@PB_W@std@@@std@@V?$allocator@V?$vector@PB_WV?$allocator@PB_W@std@@@std@@@2@@std@@IBE_NPBV?$vector@PB_WV?$allocator@PB_W@std@@@2@@Z endp
.text$mn:0000691D
.text$mn:0000691D _text$mn        ends
.text$mn:0000691D
.text$mn:00006920 ; ===========================================================================
.text$mn:00006920
.text$mn:00006920 ; Segment type: Pure code
.text$mn:00006920 ; Segment permissions: Read/Execute
.text$mn:00006920 _text$mn        segment para public 'CODE' use32
.text$mn:00006920                 assume cs:_text$mn
.text$mn:00006920                 ;org 6920h
.text$mn:00006920 ; COMDAT (pick any)
.text$mn:00006920                 assume es:nothing, ss:nothing, ds:_data, fs:nothing, gs:nothing
.text$mn:00006920
.text$mn:00006920 ; =============== S U B R O U T I N E =======================================
.text$mn:00006920
.text$mn:00006920 ; Attributes: bp-based frame
.text$mn:00006920
.text$mn:00006920 ; public: char * __thiscall std::_String_val<struct std::_Simple_types<char>>::_Myptr(void)
.text$mn:00006920                 public ?_Myptr@?$_String_val@U?$_Simple_types@D@std@@@std@@QAEPADXZ
.text$mn:00006920 ?_Myptr@?$_String_val@U?$_Simple_types@D@std@@@std@@QAEPADXZ proc near
.text$mn:00006920                                         ; CODE XREF: $LN19+14p
.text$mn:00006920                                         ; std::basic_string<char,std::char_traits<char>,std::allocator<char>>::_Eos(uint)+1Dp ...
.text$mn:00006920
.text$mn:00006920 var_8           = dword ptr -8
.text$mn:00006920 var_4           = dword ptr -4
.text$mn:00006920
.text$mn:00006920                 push    ebp
.text$mn:00006921                 mov     ebp, esp
.text$mn:00006923                 sub     esp, 8
.text$mn:00006926                 mov     [ebp+var_4], ecx
.text$mn:00006929                 mov     eax, [ebp+var_4]
.text$mn:0000692C                 cmp     dword ptr [eax+18h], 10h
.text$mn:00006930                 jb      short loc_6946
.text$mn:00006932                 mov     ecx, [ebp+var_4]
.text$mn:00006935                 mov     edx, [ecx+4]
.text$mn:00006938                 push    edx
.text$mn:00006939                 call    ??$addressof@D@std@@YAPADAAD@Z ; std::addressof<char>(char &)
.text$mn:0000693E                 add     esp, 4
.text$mn:00006941                 mov     [ebp+var_8], eax
.text$mn:00006944                 jmp     short loc_694F
.text$mn:00006946 ; ---------------------------------------------------------------------------
.text$mn:00006946
.text$mn:00006946 loc_6946:                               ; CODE XREF: std::_String_val<std::_Simple_types<char>>::_Myptr(void)+10j
.text$mn:00006946                 mov     eax, [ebp+var_4]
.text$mn:00006949                 add     eax, 4
.text$mn:0000694C                 mov     [ebp+var_8], eax
.text$mn:0000694F
.text$mn:0000694F loc_694F:                               ; CODE XREF: std::_String_val<std::_Simple_types<char>>::_Myptr(void)+24j
.text$mn:0000694F                 mov     eax, [ebp+var_8]
.text$mn:00006952                 mov     esp, ebp
.text$mn:00006954                 pop     ebp
.text$mn:00006955                 retn
.text$mn:00006955 ?_Myptr@?$_String_val@U?$_Simple_types@D@std@@@std@@QAEPADXZ endp
.text$mn:00006955
.text$mn:00006955 ; ---------------------------------------------------------------------------
.text$mn:00006956                 align 4
.text$mn:00006956 _text$mn        ends
.text$mn:00006956
.text$mn:00006958 ; ===========================================================================
.text$mn:00006958
.text$mn:00006958 ; Segment type: Pure code
.text$mn:00006958 ; Segment permissions: Read/Execute
.text$mn:00006958 _text$mn        segment para public 'CODE' use32
.text$mn:00006958                 assume cs:_text$mn
.text$mn:00006958                 ;org 6958h
.text$mn:00006958 ; COMDAT (pick any)
.text$mn:00006958                 assume es:nothing, ss:nothing, ds:_data, fs:nothing, gs:nothing
.text$mn:00006958
.text$mn:00006958 ; =============== S U B R O U T I N E =======================================
.text$mn:00006958
.text$mn:00006958 ; Attributes: bp-based frame
.text$mn:00006958
.text$mn:00006958 ; public: char const * __thiscall std::_String_val<struct std::_Simple_types<char>>::_Myptr(void)const
.text$mn:00006958                 public ?_Myptr@?$_String_val@U?$_Simple_types@D@std@@@std@@QBEPBDXZ
.text$mn:00006958 ?_Myptr@?$_String_val@U?$_Simple_types@D@std@@@std@@QBEPBDXZ proc near
.text$mn:00006958                                         ; CODE XREF: std::basic_string<char,std::char_traits<char>,std::allocator<char>>::assign(std::basic_string<char,std::char_traits<char>,std::allocator<char>> const &,uint,uint)+7Dp
.text$mn:00006958
.text$mn:00006958 var_8           = dword ptr -8
.text$mn:00006958 var_4           = dword ptr -4
.text$mn:00006958
.text$mn:00006958                 push    ebp
.text$mn:00006959                 mov     ebp, esp
.text$mn:0000695B                 sub     esp, 8
.text$mn:0000695E                 mov     [ebp+var_4], ecx
.text$mn:00006961                 mov     eax, [ebp+var_4]
.text$mn:00006964                 cmp     dword ptr [eax+18h], 10h
.text$mn:00006968                 jb      short loc_697E
.text$mn:0000696A                 mov     ecx, [ebp+var_4]
.text$mn:0000696D                 mov     edx, [ecx+4]
.text$mn:00006970                 push    edx
.text$mn:00006971                 call    ??$addressof@D@std@@YAPADAAD@Z ; std::addressof<char>(char &)
.text$mn:00006976                 add     esp, 4
.text$mn:00006979                 mov     [ebp+var_8], eax
.text$mn:0000697C                 jmp     short loc_6987
.text$mn:0000697E ; ---------------------------------------------------------------------------
.text$mn:0000697E
.text$mn:0000697E loc_697E:                               ; CODE XREF: std::_String_val<std::_Simple_types<char>>::_Myptr(void)+10j
.text$mn:0000697E                 mov     eax, [ebp+var_4]
.text$mn:00006981                 add     eax, 4
.text$mn:00006984                 mov     [ebp+var_8], eax
.text$mn:00006987
.text$mn:00006987 loc_6987:                               ; CODE XREF: std::_String_val<std::_Simple_types<char>>::_Myptr(void)+24j
.text$mn:00006987                 mov     eax, [ebp+var_8]
.text$mn:0000698A                 mov     esp, ebp
.text$mn:0000698C                 pop     ebp
.text$mn:0000698D                 retn
.text$mn:0000698D ?_Myptr@?$_String_val@U?$_Simple_types@D@std@@@std@@QBEPBDXZ endp
.text$mn:0000698D
.text$mn:0000698D ; ---------------------------------------------------------------------------
.text$mn:0000698E                 align 10h
.text$mn:0000698E _text$mn        ends
.text$mn:0000698E
.text$mn:00006990 ; ===========================================================================
.text$mn:00006990
.text$mn:00006990 ; Segment type: Pure code
.text$mn:00006990 ; Segment permissions: Read/Execute
.text$mn:00006990 _text$mn        segment para public 'CODE' use32
.text$mn:00006990                 assume cs:_text$mn
.text$mn:00006990                 ;org 6990h
.text$mn:00006990 ; COMDAT (pick any)
.text$mn:00006990                 assume es:nothing, ss:nothing, ds:_data, fs:nothing, gs:nothing
.text$mn:00006990
.text$mn:00006990 ; =============== S U B R O U T I N E =======================================
.text$mn:00006990
.text$mn:00006990 ; Attributes: bp-based frame
.text$mn:00006990
.text$mn:00006990 ; public: wchar_t const * __thiscall std::_String_val<struct std::_Simple_types<wchar_t>>::_Myptr(void)const
.text$mn:00006990                 public ?_Myptr@?$_String_val@U?$_Simple_types@_W@std@@@std@@QBEPB_WXZ
.text$mn:00006990 ?_Myptr@?$_String_val@U?$_Simple_types@_W@std@@@std@@QBEPB_WXZ proc near
.text$mn:00006990                                         ; CODE XREF: std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>>::c_str(void)+Ap
.text$mn:00006990
.text$mn:00006990 var_8           = dword ptr -8
.text$mn:00006990 var_4           = dword ptr -4
.text$mn:00006990
.text$mn:00006990                 push    ebp
.text$mn:00006991                 mov     ebp, esp
.text$mn:00006993                 sub     esp, 8
.text$mn:00006996                 mov     [ebp+var_4], ecx
.text$mn:00006999                 mov     eax, [ebp+var_4]
.text$mn:0000699C                 cmp     dword ptr [eax+18h], 8
.text$mn:000069A0                 jb      short loc_69B6
.text$mn:000069A2                 mov     ecx, [ebp+var_4]
.text$mn:000069A5                 mov     edx, [ecx+4]
.text$mn:000069A8                 push    edx
.text$mn:000069A9                 call    ??$addressof@_W@std@@YAPA_WAA_W@Z ; std::addressof<wchar_t>(wchar_t &)
.text$mn:000069AE                 add     esp, 4
.text$mn:000069B1                 mov     [ebp+var_8], eax
.text$mn:000069B4                 jmp     short loc_69BF
.text$mn:000069B6 ; ---------------------------------------------------------------------------
.text$mn:000069B6
.text$mn:000069B6 loc_69B6:                               ; CODE XREF: std::_String_val<std::_Simple_types<wchar_t>>::_Myptr(void)+10j
.text$mn:000069B6                 mov     eax, [ebp+var_4]
.text$mn:000069B9                 add     eax, 4
.text$mn:000069BC                 mov     [ebp+var_8], eax
.text$mn:000069BF
.text$mn:000069BF loc_69BF:                               ; CODE XREF: std::_String_val<std::_Simple_types<wchar_t>>::_Myptr(void)+24j
.text$mn:000069BF                 mov     eax, [ebp+var_8]
.text$mn:000069C2                 mov     esp, ebp
.text$mn:000069C4                 pop     ebp
.text$mn:000069C5                 retn
.text$mn:000069C5 ?_Myptr@?$_String_val@U?$_Simple_types@_W@std@@@std@@QBEPB_WXZ endp
.text$mn:000069C5
.text$mn:000069C5 ; ---------------------------------------------------------------------------
.text$mn:000069C6                 align 4
.text$mn:000069C6 _text$mn        ends
.text$mn:000069C6
.text$mn:000069C8 ; ===========================================================================
.text$mn:000069C8
.text$mn:000069C8 ; Segment type: Pure code
.text$mn:000069C8 ; Segment permissions: Read/Execute
.text$mn:000069C8 _text$mn        segment para public 'CODE' use32
.text$mn:000069C8                 assume cs:_text$mn
.text$mn:000069C8                 ;org 69C8h
.text$mn:000069C8 ; COMDAT (pick any)
.text$mn:000069C8                 assume es:nothing, ss:nothing, ds:_data, fs:nothing, gs:nothing
.text$mn:000069C8
.text$mn:000069C8 ; =============== S U B R O U T I N E =======================================
.text$mn:000069C8
.text$mn:000069C8 ; Attributes: bp-based frame
.text$mn:000069C8
.text$mn:000069C8 ; void __thiscall std::_Container_base12::_Orphan_all(std::_Container_base12 *__hidden this)
.text$mn:000069C8                 public ?_Orphan_all@_Container_base12@std@@QAEXXZ
.text$mn:000069C8 ?_Orphan_all@_Container_base12@std@@QAEXXZ proc near
.text$mn:000069C8                                         ; CODE XREF: std::_Container_base12::~_Container_base12(void)+Ap
.text$mn:000069C8                                         ; std::_String_alloc<0,std::_String_base_types<char,std::allocator<char>>>::_Free_proxy(void)+14p ...
.text$mn:000069C8
.text$mn:000069C8 var_18          = byte ptr -18h
.text$mn:000069C8 var_14          = dword ptr -14h
.text$mn:000069C8 var_10          = dword ptr -10h
.text$mn:000069C8 var_C           = dword ptr -0Ch
.text$mn:000069C8 var_4           = dword ptr -4
.text$mn:000069C8
.text$mn:000069C8                 push    ebp
.text$mn:000069C9                 mov     ebp, esp
.text$mn:000069CB                 push    0FFFFFFFFh
.text$mn:000069CD                 push    offset __ehhandler$?_Orphan_all@_Container_base12@std@@QAEXXZ
.text$mn:000069D2                 mov     eax, large fs:0
.text$mn:000069D8                 push    eax
.text$mn:000069D9                 sub     esp, 0Ch
.text$mn:000069DC                 mov     eax, dword ptr ds:___security_cookie
.text$mn:000069E1                 xor     eax, ebp
.text$mn:000069E3                 push    eax
.text$mn:000069E4                 lea     eax, [ebp+var_C]
.text$mn:000069E7                 mov     large fs:0, eax
.text$mn:000069ED                 mov     [ebp+var_14], ecx
.text$mn:000069F0                 mov     eax, [ebp+var_14]
.text$mn:000069F3                 cmp     dword ptr [eax], 0
.text$mn:000069F6                 jz      short loc_6A53
.text$mn:000069F8                 push    3               ; int
.text$mn:000069FA                 lea     ecx, [ebp+var_18] ; this
.text$mn:000069FD                 call    ??0_Lockit@std@@QAE@H@Z ; std::_Lockit::_Lockit(int)
.text$mn:00006A02                 mov     [ebp+var_4], 0
.text$mn:00006A09                 mov     ecx, [ebp+var_14]
.text$mn:00006A0C                 mov     edx, [ecx]
.text$mn:00006A0E                 add     edx, 4
.text$mn:00006A11                 mov     [ebp+var_10], edx
.text$mn:00006A14                 jmp     short loc_6A23
.text$mn:00006A16 ; ---------------------------------------------------------------------------
.text$mn:00006A16
.text$mn:00006A16 loc_6A16:                               ; CODE XREF: std::_Container_base12::_Orphan_all(void)+6Ej
.text$mn:00006A16                 mov     eax, [ebp+var_10]
.text$mn:00006A19                 mov     ecx, [eax]
.text$mn:00006A1B                 mov     edx, [ebp+var_10]
.text$mn:00006A1E                 mov     eax, [ecx+4]
.text$mn:00006A21                 mov     [edx], eax
.text$mn:00006A23
.text$mn:00006A23 loc_6A23:                               ; CODE XREF: std::_Container_base12::_Orphan_all(void)+4Cj
.text$mn:00006A23                 mov     ecx, [ebp+var_10]
.text$mn:00006A26                 cmp     dword ptr [ecx], 0
.text$mn:00006A29                 jz      short loc_6A38
.text$mn:00006A2B                 mov     edx, [ebp+var_10]
.text$mn:00006A2E                 mov     eax, [edx]
.text$mn:00006A30                 mov     dword ptr [eax], 0
.text$mn:00006A36                 jmp     short loc_6A16
.text$mn:00006A38 ; ---------------------------------------------------------------------------
.text$mn:00006A38
.text$mn:00006A38 loc_6A38:                               ; CODE XREF: std::_Container_base12::_Orphan_all(void)+61j
.text$mn:00006A38                 mov     ecx, [ebp+var_14]
.text$mn:00006A3B                 mov     edx, [ecx]
.text$mn:00006A3D                 mov     dword ptr [edx+4], 0
.text$mn:00006A44                 mov     [ebp+var_4], 0FFFFFFFFh
.text$mn:00006A4B                 lea     ecx, [ebp+var_18] ; this
.text$mn:00006A4E                 call    ??1_Lockit@std@@QAE@XZ ; std::_Lockit::~_Lockit(void)
.text$mn:00006A53
.text$mn:00006A53 loc_6A53:                               ; CODE XREF: std::_Container_base12::_Orphan_all(void)+2Ej
.text$mn:00006A53                 mov     ecx, [ebp+var_C]
.text$mn:00006A56                 mov     large fs:0, ecx
.text$mn:00006A5D                 pop     ecx
.text$mn:00006A5E                 mov     esp, ebp
.text$mn:00006A60                 pop     ebp
.text$mn:00006A61                 retn
.text$mn:00006A61 ?_Orphan_all@_Container_base12@std@@QAEXXZ endp
.text$mn:00006A61
.text$mn:00006A61 ; ---------------------------------------------------------------------------
.text$mn:00006A62                 align 4
.text$mn:00006A62 _text$mn        ends
.text$mn:00006A62
.text$x:00006A64 ; ===========================================================================
.text$x:00006A64
.text$x:00006A64 ; Segment type: Pure code
.text$x:00006A64 ; Segment permissions: Read/Execute
.text$x:00006A64 _text$x         segment para public 'CODE' use32
.text$x:00006A64                 assume cs:_text$x
.text$x:00006A64                 ;org 6A64h
.text$x:00006A64 ; COMDAT (pick associative to section at 69C8)
.text$x:00006A64                 assume es:nothing, ss:nothing, ds:_data, fs:nothing, gs:nothing
.text$x:00006A64
.text$x:00006A64 ; =============== S U B R O U T I N E =======================================
.text$x:00006A64
.text$x:00006A64
.text$x:00006A64 __unwindfunclet$?_Orphan_all@_Container_base12@std@@QAEXXZ$0 proc near
.text$x:00006A64                                         ; DATA XREF: .xdata$x:00009224o
.text$x:00006A64                 lea     ecx, [ebp-18h]  ; this
.text$x:00006A67                 jmp     ??1_Lockit@std@@QAE@XZ ; std::_Lockit::~_Lockit(void)
.text$x:00006A67 __unwindfunclet$?_Orphan_all@_Container_base12@std@@QAEXXZ$0 endp
.text$x:00006A67
.text$x:00006A6C
.text$x:00006A6C ; =============== S U B R O U T I N E =======================================
.text$x:00006A6C
.text$x:00006A6C
.text$x:00006A6C __ehhandler$?_Orphan_all@_Container_base12@std@@QAEXXZ proc near
.text$x:00006A6C                                         ; DATA XREF: std::_Container_base12::_Orphan_all(void)+5o
.text$x:00006A6C
.text$x:00006A6C arg_4           = dword ptr  8
.text$x:00006A6C
.text$x:00006A6C                 mov     edx, [esp+arg_4]
.text$x:00006A70                 lea     eax, [edx+0Ch]
.text$x:00006A73                 mov     ecx, [edx-10h]
.text$x:00006A76                 xor     ecx, eax
.text$x:00006A78                 call    @__security_check_cookie@4 ; __security_check_cookie(x)
.text$x:00006A7D                 mov     eax, offset __ehfuncinfo$?_Orphan_all@_Container_base12@std@@QAEXXZ
.text$x:00006A82                 jmp     ___CxxFrameHandler3
.text$x:00006A82 __ehhandler$?_Orphan_all@_Container_base12@std@@QAEXXZ endp
.text$x:00006A82
.text$x:00006A82 ; ---------------------------------------------------------------------------
.text$x:00006A87                 align 4
.text$x:00006A87 _text$x         ends
.text$x:00006A87
.text$mn:00006A88 ; ===========================================================================
.text$mn:00006A88
.text$mn:00006A88 ; Segment type: Pure code
.text$mn:00006A88 ; Segment permissions: Read/Execute
.text$mn:00006A88 _text$mn        segment para public 'CODE' use32
.text$mn:00006A88                 assume cs:_text$mn
.text$mn:00006A88                 ;org 6A88h
.text$mn:00006A88 ; COMDAT (pick any)
.text$mn:00006A88                 assume es:nothing, ss:nothing, ds:_data, fs:nothing, gs:nothing
.text$mn:00006A88
.text$mn:00006A88 ; =============== S U B R O U T I N E =======================================
.text$mn:00006A88
.text$mn:00006A88 ; Attributes: bp-based frame
.text$mn:00006A88
.text$mn:00006A88 ; void __thiscall std::_Iterator_base12::_Orphan_me(std::_Iterator_base12 *__hidden this)
.text$mn:00006A88                 public ?_Orphan_me@_Iterator_base12@std@@QAEXXZ
.text$mn:00006A88 ?_Orphan_me@_Iterator_base12@std@@QAEXXZ proc near
.text$mn:00006A88                                         ; CODE XREF: std::_Iterator_base12::~_Iterator_base12(void)+3Cp
.text$mn:00006A88                                         ; std::_Iterator_base12::operator=(std::_Iterator_base12 const &)+64p ...
.text$mn:00006A88
.text$mn:00006A88 var_8           = dword ptr -8
.text$mn:00006A88 var_4           = dword ptr -4
.text$mn:00006A88
.text$mn:00006A88                 push    ebp
.text$mn:00006A89                 mov     ebp, esp
.text$mn:00006A8B                 sub     esp, 8
.text$mn:00006A8E                 mov     [ebp+var_8], ecx
.text$mn:00006A91                 mov     eax, [ebp+var_8]
.text$mn:00006A94                 cmp     dword ptr [eax], 0
.text$mn:00006A97                 jz      short loc_6AF6
.text$mn:00006A99                 mov     ecx, [ebp+var_8]
.text$mn:00006A9C                 mov     edx, [ecx]
.text$mn:00006A9E                 add     edx, 4
.text$mn:00006AA1                 mov     [ebp+var_4], edx
.text$mn:00006AA4
.text$mn:00006AA4 loc_6AA4:                               ; CODE XREF: std::_Iterator_base12::_Orphan_me(void)+39j
.text$mn:00006AA4                 mov     eax, [ebp+var_4]
.text$mn:00006AA7                 cmp     dword ptr [eax], 0
.text$mn:00006AAA                 jz      short loc_6AC3
.text$mn:00006AAC                 mov     ecx, [ebp+var_4]
.text$mn:00006AAF                 mov     edx, [ecx]
.text$mn:00006AB1                 cmp     edx, [ebp+var_8]
.text$mn:00006AB4                 jz      short loc_6AC3
.text$mn:00006AB6                 mov     eax, [ebp+var_4]
.text$mn:00006AB9                 mov     ecx, [eax]
.text$mn:00006ABB                 add     ecx, 4
.text$mn:00006ABE                 mov     [ebp+var_4], ecx
.text$mn:00006AC1                 jmp     short loc_6AA4
.text$mn:00006AC3 ; ---------------------------------------------------------------------------
.text$mn:00006AC3
.text$mn:00006AC3 loc_6AC3:                               ; CODE XREF: std::_Iterator_base12::_Orphan_me(void)+22j
.text$mn:00006AC3                                         ; std::_Iterator_base12::_Orphan_me(void)+2Cj
.text$mn:00006AC3                 mov     edx, [ebp+var_4]
.text$mn:00006AC6                 cmp     dword ptr [edx], 0
.text$mn:00006AC9                 jnz     short loc_6AE2
.text$mn:00006ACB                 push    0C9h ; '+'      ; unsigned int
.text$mn:00006AD0                 push    offset ??_C@_1JA@EADLBAJ@?$AAC?$AA?3?$AA?2?$AAP?$AAr?$AAo?$AAg?$AAr?$AAa?$AAm?$AA?5?$AAF?$AAi?$AAl?$AAe?$AAs?$AA?5?$AA?$CI?$AAx?$AA8?$AA6?$AA?$CJ?$AA?2?$AAM?$AAi?$AAc?$AAr?$AAo?$AAs?$AAo?$AAf?$AAt@ ; "C:\\Program Files (x86)\\Microsoft Visu"...
.text$mn:00006AD5                 push    offset ??_C@_1DC@POOIKBAO@?$AAI?$AAT?$AAE?$AAR?$AAA?$AAT?$AAO?$AAR?$AA?5?$AAL?$AAI?$AAS?$AAT?$AA?5?$AAC?$AAO?$AAR?$AAR?$AAU?$AAP?$AAT?$AAE?$AAD?$AA?$CB?$AA?$AA@ ; "ITERATOR LIST CORRUPTED!"
.text$mn:00006ADA                 call    ?_Debug_message@std@@YAXPB_W0I@Z ; std::_Debug_message(wchar_t const *,wchar_t const *,uint)
.text$mn:00006ADF                 add     esp, 0Ch
.text$mn:00006AE2
.text$mn:00006AE2 loc_6AE2:                               ; CODE XREF: std::_Iterator_base12::_Orphan_me(void)+41j
.text$mn:00006AE2                 mov     eax, [ebp+var_4]
.text$mn:00006AE5                 mov     ecx, [ebp+var_8]
.text$mn:00006AE8                 mov     edx, [ecx+4]
.text$mn:00006AEB                 mov     [eax], edx
.text$mn:00006AED                 mov     eax, [ebp+var_8]
.text$mn:00006AF0                 mov     dword ptr [eax], 0
.text$mn:00006AF6
.text$mn:00006AF6 loc_6AF6:                               ; CODE XREF: std::_Iterator_base12::_Orphan_me(void)+Fj
.text$mn:00006AF6                 mov     esp, ebp
.text$mn:00006AF8                 pop     ebp
.text$mn:00006AF9                 retn
.text$mn:00006AF9 ?_Orphan_me@_Iterator_base12@std@@QAEXXZ endp
.text$mn:00006AF9
.text$mn:00006AF9 ; ---------------------------------------------------------------------------
.text$mn:00006AFA                 align 4
.text$mn:00006AFA _text$mn        ends
.text$mn:00006AFA
.text$mn:00006AFC ; ===========================================================================
.text$mn:00006AFC
.text$mn:00006AFC ; Segment type: Pure code
.text$mn:00006AFC ; Segment permissions: Read/Execute
.text$mn:00006AFC _text$mn        segment para public 'CODE' use32
.text$mn:00006AFC                 assume cs:_text$mn
.text$mn:00006AFC                 ;org 6AFCh
.text$mn:00006AFC ; COMDAT (pick any)
.text$mn:00006AFC                 assume es:nothing, ss:nothing, ds:_data, fs:nothing, gs:nothing
.text$mn:00006AFC
.text$mn:00006AFC ; =============== S U B R O U T I N E =======================================
.text$mn:00006AFC
.text$mn:00006AFC ; Attributes: bp-based frame
.text$mn:00006AFC
.text$mn:00006AFC ; protected: void __thiscall std::vector<wchar_t const *, class std::allocator<wchar_t const *>>::_Orphan_range(wchar_t const * *, wchar_t const * *)const
.text$mn:00006AFC                 public ?_Orphan_range@?$vector@PB_WV?$allocator@PB_W@std@@@std@@IBEXPAPB_W0@Z
.text$mn:00006AFC ?_Orphan_range@?$vector@PB_WV?$allocator@PB_W@std@@@std@@IBEXPAPB_W0@Z proc near
.text$mn:00006AFC                                         ; CODE XREF: std::vector<wchar_t const *,std::allocator<wchar_t const *>>::push_back(wchar_t const * const &)+66p
.text$mn:00006AFC                                         ; std::vector<wchar_t const *,std::allocator<wchar_t const *>>::push_back(wchar_t const * const &)+CCp
.text$mn:00006AFC
.text$mn:00006AFC var_18          = byte ptr -18h
.text$mn:00006AFC var_14          = dword ptr -14h
.text$mn:00006AFC var_10          = dword ptr -10h
.text$mn:00006AFC var_C           = dword ptr -0Ch
.text$mn:00006AFC var_4           = dword ptr -4
.text$mn:00006AFC arg_0           = dword ptr  8
.text$mn:00006AFC arg_4           = dword ptr  0Ch
.text$mn:00006AFC
.text$mn:00006AFC                 push    ebp
.text$mn:00006AFD                 mov     ebp, esp
.text$mn:00006AFF                 push    0FFFFFFFFh
.text$mn:00006B01                 push    offset __ehhandler$?_Orphan_range@?$vector@PB_WV?$allocator@PB_W@std@@@std@@IBEXPAPB_W0@Z
.text$mn:00006B06                 mov     eax, large fs:0
.text$mn:00006B0C                 push    eax
.text$mn:00006B0D                 sub     esp, 0Ch
.text$mn:00006B10                 mov     eax, dword ptr ds:___security_cookie
.text$mn:00006B15                 xor     eax, ebp
.text$mn:00006B17                 push    eax
.text$mn:00006B18                 lea     eax, [ebp+var_C]
.text$mn:00006B1B                 mov     large fs:0, eax
.text$mn:00006B21                 mov     [ebp+var_14], ecx
.text$mn:00006B24                 push    3               ; int
.text$mn:00006B26                 lea     ecx, [ebp+var_18] ; this
.text$mn:00006B29                 call    ??0_Lockit@std@@QAE@H@Z ; std::_Lockit::_Lockit(int)
.text$mn:00006B2E                 mov     [ebp+var_4], 0
.text$mn:00006B35                 mov     ecx, [ebp+var_14] ; this
.text$mn:00006B38                 call    ?_Getpfirst@_Container_base12@std@@QBEPAPAU_Iterator_base12@2@XZ ; std::_Container_base12::_Getpfirst(void)
.text$mn:00006B3D                 mov     [ebp+var_10], eax
.text$mn:00006B40                 cmp     [ebp+var_10], 0
.text$mn:00006B44                 jz      short loc_6B94
.text$mn:00006B46
.text$mn:00006B46 loc_6B46:                               ; CODE XREF: std::vector<wchar_t const *,std::allocator<wchar_t const *>>::_Orphan_range(wchar_t const * *,wchar_t const * *):loc_6B92j
.text$mn:00006B46                 mov     eax, [ebp+var_10]
.text$mn:00006B49                 cmp     dword ptr [eax], 0
.text$mn:00006B4C                 jz      short loc_6B94
.text$mn:00006B4E                 mov     ecx, [ebp+var_10]
.text$mn:00006B51                 mov     edx, [ecx]
.text$mn:00006B53                 mov     eax, [edx+8]
.text$mn:00006B56                 cmp     eax, [ebp+arg_0]
.text$mn:00006B59                 jb      short loc_6B68
.text$mn:00006B5B                 mov     ecx, [ebp+var_10]
.text$mn:00006B5E                 mov     edx, [ecx]
.text$mn:00006B60                 mov     eax, [ebp+arg_4]
.text$mn:00006B63                 cmp     eax, [edx+8]
.text$mn:00006B66                 jnb     short loc_6B77
.text$mn:00006B68
.text$mn:00006B68 loc_6B68:                               ; CODE XREF: std::vector<wchar_t const *,std::allocator<wchar_t const *>>::_Orphan_range(wchar_t const * *,wchar_t const * *)+5Dj
.text$mn:00006B68                 mov     ecx, [ebp+var_10]
.text$mn:00006B6B                 mov     ecx, [ecx]      ; this
.text$mn:00006B6D                 call    ?_Getpnext@_Iterator_base12@std@@QAEPAPAU12@XZ ; std::_Iterator_base12::_Getpnext(void)
.text$mn:00006B72                 mov     [ebp+var_10], eax
.text$mn:00006B75                 jmp     short loc_6B92
.text$mn:00006B77 ; ---------------------------------------------------------------------------
.text$mn:00006B77
.text$mn:00006B77 loc_6B77:                               ; CODE XREF: std::vector<wchar_t const *,std::allocator<wchar_t const *>>::_Orphan_range(wchar_t const * *,wchar_t const * *)+6Aj
.text$mn:00006B77                 mov     edx, [ebp+var_10]
.text$mn:00006B7A                 mov     ecx, [edx]      ; this
.text$mn:00006B7C                 call    ?_Clrcont@_Iterator_base12@std@@QAEXXZ ; std::_Iterator_base12::_Clrcont(void)
.text$mn:00006B81                 mov     eax, [ebp+var_10]
.text$mn:00006B84                 mov     ecx, [eax]      ; this
.text$mn:00006B86                 call    ?_Getpnext@_Iterator_base12@std@@QAEPAPAU12@XZ ; std::_Iterator_base12::_Getpnext(void)
.text$mn:00006B8B                 mov     ecx, [ebp+var_10]
.text$mn:00006B8E                 mov     edx, [eax]
.text$mn:00006B90                 mov     [ecx], edx
.text$mn:00006B92
.text$mn:00006B92 loc_6B92:                               ; CODE XREF: std::vector<wchar_t const *,std::allocator<wchar_t const *>>::_Orphan_range(wchar_t const * *,wchar_t const * *)+79j
.text$mn:00006B92                 jmp     short loc_6B46
.text$mn:00006B94 ; ---------------------------------------------------------------------------
.text$mn:00006B94
.text$mn:00006B94 loc_6B94:                               ; CODE XREF: std::vector<wchar_t const *,std::allocator<wchar_t const *>>::_Orphan_range(wchar_t const * *,wchar_t const * *)+48j
.text$mn:00006B94                                         ; std::vector<wchar_t const *,std::allocator<wchar_t const *>>::_Orphan_range(wchar_t const * *,wchar_t const * *)+50j
.text$mn:00006B94                 mov     [ebp+var_4], 0FFFFFFFFh
.text$mn:00006B9B                 lea     ecx, [ebp+var_18] ; this
.text$mn:00006B9E                 call    ??1_Lockit@std@@QAE@XZ ; std::_Lockit::~_Lockit(void)
.text$mn:00006BA3                 mov     ecx, [ebp+var_C]
.text$mn:00006BA6                 mov     large fs:0, ecx
.text$mn:00006BAD                 pop     ecx
.text$mn:00006BAE                 mov     esp, ebp
.text$mn:00006BB0                 pop     ebp
.text$mn:00006BB1                 retn    8
.text$mn:00006BB1 ?_Orphan_range@?$vector@PB_WV?$allocator@PB_W@std@@@std@@IBEXPAPB_W0@Z endp
.text$mn:00006BB1
.text$mn:00006BB1 _text$mn        ends
.text$mn:00006BB1
.text$x:00006BB4 ; ===========================================================================
.text$x:00006BB4
.text$x:00006BB4 ; Segment type: Pure code
.text$x:00006BB4 ; Segment permissions: Read/Execute
.text$x:00006BB4 _text$x         segment para public 'CODE' use32
.text$x:00006BB4                 assume cs:_text$x
.text$x:00006BB4                 ;org 6BB4h
.text$x:00006BB4 ; COMDAT (pick associative to section at 6AFC)
.text$x:00006BB4                 assume es:nothing, ss:nothing, ds:_data, fs:nothing, gs:nothing
.text$x:00006BB4
.text$x:00006BB4 ; =============== S U B R O U T I N E =======================================
.text$x:00006BB4
.text$x:00006BB4
.text$x:00006BB4 __unwindfunclet$?_Orphan_range@?$vector@PB_WV?$allocator@PB_W@std@@@std@@IBEXPAPB_W0@Z$0 proc near
.text$x:00006BB4                                         ; DATA XREF: .xdata$x:0000987Co
.text$x:00006BB4                 lea     ecx, [ebp-18h]  ; this
.text$x:00006BB7                 jmp     ??1_Lockit@std@@QAE@XZ ; std::_Lockit::~_Lockit(void)
.text$x:00006BB7 __unwindfunclet$?_Orphan_range@?$vector@PB_WV?$allocator@PB_W@std@@@std@@IBEXPAPB_W0@Z$0 endp
.text$x:00006BB7
.text$x:00006BBC
.text$x:00006BBC ; =============== S U B R O U T I N E =======================================
.text$x:00006BBC
.text$x:00006BBC
.text$x:00006BBC __ehhandler$?_Orphan_range@?$vector@PB_WV?$allocator@PB_W@std@@@std@@IBEXPAPB_W0@Z proc near
.text$x:00006BBC                                         ; DATA XREF: std::vector<wchar_t const *,std::allocator<wchar_t const *>>::_Orphan_range(wchar_t const * *,wchar_t const * *)+5o
.text$x:00006BBC
.text$x:00006BBC arg_4           = dword ptr  8
.text$x:00006BBC
.text$x:00006BBC                 mov     edx, [esp+arg_4]
.text$x:00006BC0                 lea     eax, [edx+0Ch]
.text$x:00006BC3                 mov     ecx, [edx-10h]
.text$x:00006BC6                 xor     ecx, eax
.text$x:00006BC8                 call    @__security_check_cookie@4 ; __security_check_cookie(x)
.text$x:00006BCD                 mov     eax, offset __ehfuncinfo$?_Orphan_range@?$vector@PB_WV?$allocator@PB_W@std@@@std@@IBEXPAPB_W0@Z
.text$x:00006BD2                 jmp     ___CxxFrameHandler3
.text$x:00006BD2 __ehhandler$?_Orphan_range@?$vector@PB_WV?$allocator@PB_W@std@@@std@@IBEXPAPB_W0@Z endp
.text$x:00006BD2
.text$x:00006BD2 ; ---------------------------------------------------------------------------
.text$x:00006BD7                 align 4
.text$x:00006BD7 _text$x         ends
.text$x:00006BD7
.text$mn:00006BD8 ; ===========================================================================
.text$mn:00006BD8
.text$mn:00006BD8 ; Segment type: Pure code
.text$mn:00006BD8 ; Segment permissions: Read/Execute
.text$mn:00006BD8 _text$mn        segment para public 'CODE' use32
.text$mn:00006BD8                 assume cs:_text$mn
.text$mn:00006BD8                 ;org 6BD8h
.text$mn:00006BD8 ; COMDAT (pick any)
.text$mn:00006BD8                 assume es:nothing, ss:nothing, ds:_data, fs:nothing, gs:nothing
.text$mn:00006BD8
.text$mn:00006BD8 ; =============== S U B R O U T I N E =======================================
.text$mn:00006BD8
.text$mn:00006BD8 ; Attributes: bp-based frame
.text$mn:00006BD8
.text$mn:00006BD8 ; protected: void __thiscall std::vector<struct FunctionValues, class std::allocator<struct FunctionValues>>::_Orphan_range(struct FunctionValues *, struct FunctionValues *)const
.text$mn:00006BD8                 public ?_Orphan_range@?$vector@UFunctionValues@@V?$allocator@UFunctionValues@@@std@@@std@@IBEXPAUFunctionValues@@0@Z
.text$mn:00006BD8 ?_Orphan_range@?$vector@UFunctionValues@@V?$allocator@UFunctionValues@@@std@@@std@@IBEXPAUFunctionValues@@0@Z proc near
.text$mn:00006BD8                                         ; CODE XREF: std::vector<FunctionValues,std::allocator<FunctionValues>>::pop_back(void)+45p
.text$mn:00006BD8                                         ; std::vector<FunctionValues,std::allocator<FunctionValues>>::push_back(FunctionValues const &)+66p ...
.text$mn:00006BD8
.text$mn:00006BD8 var_18          = byte ptr -18h
.text$mn:00006BD8 var_14          = dword ptr -14h
.text$mn:00006BD8 var_10          = dword ptr -10h
.text$mn:00006BD8 var_C           = dword ptr -0Ch
.text$mn:00006BD8 var_4           = dword ptr -4
.text$mn:00006BD8 arg_0           = dword ptr  8
.text$mn:00006BD8 arg_4           = dword ptr  0Ch
.text$mn:00006BD8
.text$mn:00006BD8                 push    ebp
.text$mn:00006BD9                 mov     ebp, esp
.text$mn:00006BDB                 push    0FFFFFFFFh
.text$mn:00006BDD                 push    offset __ehhandler$?_Orphan_range@?$vector@UFunctionValues@@V?$allocator@UFunctionValues@@@std@@@std@@IBEXPAUFunctionValues@@0@Z
.text$mn:00006BE2                 mov     eax, large fs:0
.text$mn:00006BE8                 push    eax
.text$mn:00006BE9                 sub     esp, 0Ch
.text$mn:00006BEC                 mov     eax, dword ptr ds:___security_cookie
.text$mn:00006BF1                 xor     eax, ebp
.text$mn:00006BF3                 push    eax
.text$mn:00006BF4                 lea     eax, [ebp+var_C]
.text$mn:00006BF7                 mov     large fs:0, eax
.text$mn:00006BFD                 mov     [ebp+var_14], ecx
.text$mn:00006C00                 push    3               ; int
.text$mn:00006C02                 lea     ecx, [ebp+var_18] ; this
.text$mn:00006C05                 call    ??0_Lockit@std@@QAE@H@Z ; std::_Lockit::_Lockit(int)
.text$mn:00006C0A                 mov     [ebp+var_4], 0
.text$mn:00006C11                 mov     ecx, [ebp+var_14] ; this
.text$mn:00006C14                 call    ?_Getpfirst@_Container_base12@std@@QBEPAPAU_Iterator_base12@2@XZ ; std::_Container_base12::_Getpfirst(void)
.text$mn:00006C19                 mov     [ebp+var_10], eax
.text$mn:00006C1C                 cmp     [ebp+var_10], 0
.text$mn:00006C20                 jz      short loc_6C70
.text$mn:00006C22
.text$mn:00006C22 loc_6C22:                               ; CODE XREF: std::vector<FunctionValues,std::allocator<FunctionValues>>::_Orphan_range(FunctionValues *,FunctionValues *):loc_6C6Ej
.text$mn:00006C22                 mov     eax, [ebp+var_10]
.text$mn:00006C25                 cmp     dword ptr [eax], 0
.text$mn:00006C28                 jz      short loc_6C70
.text$mn:00006C2A                 mov     ecx, [ebp+var_10]
.text$mn:00006C2D                 mov     edx, [ecx]
.text$mn:00006C2F                 mov     eax, [edx+8]
.text$mn:00006C32                 cmp     eax, [ebp+arg_0]
.text$mn:00006C35                 jb      short loc_6C44
.text$mn:00006C37                 mov     ecx, [ebp+var_10]
.text$mn:00006C3A                 mov     edx, [ecx]
.text$mn:00006C3C                 mov     eax, [ebp+arg_4]
.text$mn:00006C3F                 cmp     eax, [edx+8]
.text$mn:00006C42                 jnb     short loc_6C53
.text$mn:00006C44
.text$mn:00006C44 loc_6C44:                               ; CODE XREF: std::vector<FunctionValues,std::allocator<FunctionValues>>::_Orphan_range(FunctionValues *,FunctionValues *)+5Dj
.text$mn:00006C44                 mov     ecx, [ebp+var_10]
.text$mn:00006C47                 mov     ecx, [ecx]      ; this
.text$mn:00006C49                 call    ?_Getpnext@_Iterator_base12@std@@QAEPAPAU12@XZ ; std::_Iterator_base12::_Getpnext(void)
.text$mn:00006C4E                 mov     [ebp+var_10], eax
.text$mn:00006C51                 jmp     short loc_6C6E
.text$mn:00006C53 ; ---------------------------------------------------------------------------
.text$mn:00006C53
.text$mn:00006C53 loc_6C53:                               ; CODE XREF: std::vector<FunctionValues,std::allocator<FunctionValues>>::_Orphan_range(FunctionValues *,FunctionValues *)+6Aj
.text$mn:00006C53                 mov     edx, [ebp+var_10]
.text$mn:00006C56                 mov     ecx, [edx]      ; this
.text$mn:00006C58                 call    ?_Clrcont@_Iterator_base12@std@@QAEXXZ ; std::_Iterator_base12::_Clrcont(void)
.text$mn:00006C5D                 mov     eax, [ebp+var_10]
.text$mn:00006C60                 mov     ecx, [eax]      ; this
.text$mn:00006C62                 call    ?_Getpnext@_Iterator_base12@std@@QAEPAPAU12@XZ ; std::_Iterator_base12::_Getpnext(void)
.text$mn:00006C67                 mov     ecx, [ebp+var_10]
.text$mn:00006C6A                 mov     edx, [eax]
.text$mn:00006C6C                 mov     [ecx], edx
.text$mn:00006C6E
.text$mn:00006C6E loc_6C6E:                               ; CODE XREF: std::vector<FunctionValues,std::allocator<FunctionValues>>::_Orphan_range(FunctionValues *,FunctionValues *)+79j
.text$mn:00006C6E                 jmp     short loc_6C22
.text$mn:00006C70 ; ---------------------------------------------------------------------------
.text$mn:00006C70
.text$mn:00006C70 loc_6C70:                               ; CODE XREF: std::vector<FunctionValues,std::allocator<FunctionValues>>::_Orphan_range(FunctionValues *,FunctionValues *)+48j
.text$mn:00006C70                                         ; std::vector<FunctionValues,std::allocator<FunctionValues>>::_Orphan_range(FunctionValues *,FunctionValues *)+50j
.text$mn:00006C70                 mov     [ebp+var_4], 0FFFFFFFFh
.text$mn:00006C77                 lea     ecx, [ebp+var_18] ; this
.text$mn:00006C7A                 call    ??1_Lockit@std@@QAE@XZ ; std::_Lockit::~_Lockit(void)
.text$mn:00006C7F                 mov     ecx, [ebp+var_C]
.text$mn:00006C82                 mov     large fs:0, ecx
.text$mn:00006C89                 pop     ecx
.text$mn:00006C8A                 mov     esp, ebp
.text$mn:00006C8C                 pop     ebp
.text$mn:00006C8D                 retn    8
.text$mn:00006C8D ?_Orphan_range@?$vector@UFunctionValues@@V?$allocator@UFunctionValues@@@std@@@std@@IBEXPAUFunctionValues@@0@Z endp
.text$mn:00006C8D
.text$mn:00006C8D _text$mn        ends
.text$mn:00006C8D
.text$x:00006C90 ; ===========================================================================
.text$x:00006C90
.text$x:00006C90 ; Segment type: Pure code
.text$x:00006C90 ; Segment permissions: Read/Execute
.text$x:00006C90 _text$x         segment para public 'CODE' use32
.text$x:00006C90                 assume cs:_text$x
.text$x:00006C90                 ;org 6C90h
.text$x:00006C90 ; COMDAT (pick associative to section at 6BD8)
.text$x:00006C90                 assume es:nothing, ss:nothing, ds:_data, fs:nothing, gs:nothing
.text$x:00006C90
.text$x:00006C90 ; =============== S U B R O U T I N E =======================================
.text$x:00006C90
.text$x:00006C90
.text$x:00006C90 __unwindfunclet$?_Orphan_range@?$vector@UFunctionValues@@V?$allocator@UFunctionValues@@@std@@@std@@IBEXPAUFunctionValues@@0@Z$0 proc near
.text$x:00006C90                                         ; DATA XREF: .xdata$x:00009D04o
.text$x:00006C90                 lea     ecx, [ebp-18h]  ; this
.text$x:00006C93                 jmp     ??1_Lockit@std@@QAE@XZ ; std::_Lockit::~_Lockit(void)
.text$x:00006C93 __unwindfunclet$?_Orphan_range@?$vector@UFunctionValues@@V?$allocator@UFunctionValues@@@std@@@std@@IBEXPAUFunctionValues@@0@Z$0 endp
.text$x:00006C93
.text$x:00006C98
.text$x:00006C98 ; =============== S U B R O U T I N E =======================================
.text$x:00006C98
.text$x:00006C98
.text$x:00006C98 __ehhandler$?_Orphan_range@?$vector@UFunctionValues@@V?$allocator@UFunctionValues@@@std@@@std@@IBEXPAUFunctionValues@@0@Z proc near
.text$x:00006C98                                         ; DATA XREF: std::vector<FunctionValues,std::allocator<FunctionValues>>::_Orphan_range(FunctionValues *,FunctionValues *)+5o
.text$x:00006C98
.text$x:00006C98 arg_4           = dword ptr  8
.text$x:00006C98
.text$x:00006C98                 mov     edx, [esp+arg_4]
.text$x:00006C9C                 lea     eax, [edx+0Ch]
.text$x:00006C9F                 mov     ecx, [edx-10h]
.text$x:00006CA2                 xor     ecx, eax
.text$x:00006CA4                 call    @__security_check_cookie@4 ; __security_check_cookie(x)
.text$x:00006CA9                 mov     eax, offset __ehfuncinfo$?_Orphan_range@?$vector@UFunctionValues@@V?$allocator@UFunctionValues@@@std@@@std@@IBEXPAUFunctionValues@@0@Z
.text$x:00006CAE                 jmp     ___CxxFrameHandler3
.text$x:00006CAE __ehhandler$?_Orphan_range@?$vector@UFunctionValues@@V?$allocator@UFunctionValues@@@std@@@std@@IBEXPAUFunctionValues@@0@Z endp
.text$x:00006CAE
.text$x:00006CAE ; ---------------------------------------------------------------------------
.text$x:00006CB3                 align 4
.text$x:00006CB3 _text$x         ends
.text$x:00006CB3
.text$mn:00006CB4 ; ===========================================================================
.text$mn:00006CB4
.text$mn:00006CB4 ; Segment type: Pure code
.text$mn:00006CB4 ; Segment permissions: Read/Execute
.text$mn:00006CB4 _text$mn        segment para public 'CODE' use32
.text$mn:00006CB4                 assume cs:_text$mn
.text$mn:00006CB4                 ;org 6CB4h
.text$mn:00006CB4 ; COMDAT (pick any)
.text$mn:00006CB4                 assume es:nothing, ss:nothing, ds:_data, fs:nothing, gs:nothing
.text$mn:00006CB4
.text$mn:00006CB4 ; =============== S U B R O U T I N E =======================================
.text$mn:00006CB4
.text$mn:00006CB4 ; Attributes: bp-based frame
.text$mn:00006CB4
.text$mn:00006CB4 ; protected: void __thiscall std::vector<struct Token, class std::allocator<struct Token>>::_Orphan_range(struct Token *, struct Token *)const
.text$mn:00006CB4                 public ?_Orphan_range@?$vector@UToken@@V?$allocator@UToken@@@std@@@std@@IBEXPAUToken@@0@Z
.text$mn:00006CB4 ?_Orphan_range@?$vector@UToken@@V?$allocator@UToken@@@std@@@std@@IBEXPAUToken@@0@Z proc near
.text$mn:00006CB4                                         ; CODE XREF: std::vector<Token,std::allocator<Token>>::push_back(Token &&)+6Fp
.text$mn:00006CB4                                         ; std::vector<Token,std::allocator<Token>>::push_back(Token &&)+DCp
.text$mn:00006CB4
.text$mn:00006CB4 var_18          = byte ptr -18h
.text$mn:00006CB4 var_14          = dword ptr -14h
.text$mn:00006CB4 var_10          = dword ptr -10h
.text$mn:00006CB4 var_C           = dword ptr -0Ch
.text$mn:00006CB4 var_4           = dword ptr -4
.text$mn:00006CB4 arg_0           = dword ptr  8
.text$mn:00006CB4 arg_4           = dword ptr  0Ch
.text$mn:00006CB4
.text$mn:00006CB4                 push    ebp
.text$mn:00006CB5                 mov     ebp, esp
.text$mn:00006CB7                 push    0FFFFFFFFh
.text$mn:00006CB9                 push    offset __ehhandler$?_Orphan_range@?$vector@UToken@@V?$allocator@UToken@@@std@@@std@@IBEXPAUToken@@0@Z
.text$mn:00006CBE                 mov     eax, large fs:0
.text$mn:00006CC4                 push    eax
.text$mn:00006CC5                 sub     esp, 0Ch
.text$mn:00006CC8                 mov     eax, dword ptr ds:___security_cookie
.text$mn:00006CCD                 xor     eax, ebp
.text$mn:00006CCF                 push    eax
.text$mn:00006CD0                 lea     eax, [ebp+var_C]
.text$mn:00006CD3                 mov     large fs:0, eax
.text$mn:00006CD9                 mov     [ebp+var_14], ecx
.text$mn:00006CDC                 push    3               ; int
.text$mn:00006CDE                 lea     ecx, [ebp+var_18] ; this
.text$mn:00006CE1                 call    ??0_Lockit@std@@QAE@H@Z ; std::_Lockit::_Lockit(int)
.text$mn:00006CE6                 mov     [ebp+var_4], 0
.text$mn:00006CED                 mov     ecx, [ebp+var_14] ; this
.text$mn:00006CF0                 call    ?_Getpfirst@_Container_base12@std@@QBEPAPAU_Iterator_base12@2@XZ ; std::_Container_base12::_Getpfirst(void)
.text$mn:00006CF5                 mov     [ebp+var_10], eax
.text$mn:00006CF8                 cmp     [ebp+var_10], 0
.text$mn:00006CFC                 jz      short loc_6D4C
.text$mn:00006CFE
.text$mn:00006CFE loc_6CFE:                               ; CODE XREF: std::vector<Token,std::allocator<Token>>::_Orphan_range(Token *,Token *):loc_6D4Aj
.text$mn:00006CFE                 mov     eax, [ebp+var_10]
.text$mn:00006D01                 cmp     dword ptr [eax], 0
.text$mn:00006D04                 jz      short loc_6D4C
.text$mn:00006D06                 mov     ecx, [ebp+var_10]
.text$mn:00006D09                 mov     edx, [ecx]
.text$mn:00006D0B                 mov     eax, [edx+8]
.text$mn:00006D0E                 cmp     eax, [ebp+arg_0]
.text$mn:00006D11                 jb      short loc_6D20
.text$mn:00006D13                 mov     ecx, [ebp+var_10]
.text$mn:00006D16                 mov     edx, [ecx]
.text$mn:00006D18                 mov     eax, [ebp+arg_4]
.text$mn:00006D1B                 cmp     eax, [edx+8]
.text$mn:00006D1E                 jnb     short loc_6D2F
.text$mn:00006D20
.text$mn:00006D20 loc_6D20:                               ; CODE XREF: std::vector<Token,std::allocator<Token>>::_Orphan_range(Token *,Token *)+5Dj
.text$mn:00006D20                 mov     ecx, [ebp+var_10]
.text$mn:00006D23                 mov     ecx, [ecx]      ; this
.text$mn:00006D25                 call    ?_Getpnext@_Iterator_base12@std@@QAEPAPAU12@XZ ; std::_Iterator_base12::_Getpnext(void)
.text$mn:00006D2A                 mov     [ebp+var_10], eax
.text$mn:00006D2D                 jmp     short loc_6D4A
.text$mn:00006D2F ; ---------------------------------------------------------------------------
.text$mn:00006D2F
.text$mn:00006D2F loc_6D2F:                               ; CODE XREF: std::vector<Token,std::allocator<Token>>::_Orphan_range(Token *,Token *)+6Aj
.text$mn:00006D2F                 mov     edx, [ebp+var_10]
.text$mn:00006D32                 mov     ecx, [edx]      ; this
.text$mn:00006D34                 call    ?_Clrcont@_Iterator_base12@std@@QAEXXZ ; std::_Iterator_base12::_Clrcont(void)
.text$mn:00006D39                 mov     eax, [ebp+var_10]
.text$mn:00006D3C                 mov     ecx, [eax]      ; this
.text$mn:00006D3E                 call    ?_Getpnext@_Iterator_base12@std@@QAEPAPAU12@XZ ; std::_Iterator_base12::_Getpnext(void)
.text$mn:00006D43                 mov     ecx, [ebp+var_10]
.text$mn:00006D46                 mov     edx, [eax]
.text$mn:00006D48                 mov     [ecx], edx
.text$mn:00006D4A
.text$mn:00006D4A loc_6D4A:                               ; CODE XREF: std::vector<Token,std::allocator<Token>>::_Orphan_range(Token *,Token *)+79j
.text$mn:00006D4A                 jmp     short loc_6CFE
.text$mn:00006D4C ; ---------------------------------------------------------------------------
.text$mn:00006D4C
.text$mn:00006D4C loc_6D4C:                               ; CODE XREF: std::vector<Token,std::allocator<Token>>::_Orphan_range(Token *,Token *)+48j
.text$mn:00006D4C                                         ; std::vector<Token,std::allocator<Token>>::_Orphan_range(Token *,Token *)+50j
.text$mn:00006D4C                 mov     [ebp+var_4], 0FFFFFFFFh
.text$mn:00006D53                 lea     ecx, [ebp+var_18] ; this
.text$mn:00006D56                 call    ??1_Lockit@std@@QAE@XZ ; std::_Lockit::~_Lockit(void)
.text$mn:00006D5B                 mov     ecx, [ebp+var_C]
.text$mn:00006D5E                 mov     large fs:0, ecx
.text$mn:00006D65                 pop     ecx
.text$mn:00006D66                 mov     esp, ebp
.text$mn:00006D68                 pop     ebp
.text$mn:00006D69                 retn    8
.text$mn:00006D69 ?_Orphan_range@?$vector@UToken@@V?$allocator@UToken@@@std@@@std@@IBEXPAUToken@@0@Z endp
.text$mn:00006D69
.text$mn:00006D69 _text$mn        ends
.text$mn:00006D69
.text$x:00006D6C ; ===========================================================================
.text$x:00006D6C
.text$x:00006D6C ; Segment type: Pure code
.text$x:00006D6C ; Segment permissions: Read/Execute
.text$x:00006D6C _text$x         segment para public 'CODE' use32
.text$x:00006D6C                 assume cs:_text$x
.text$x:00006D6C                 ;org 6D6Ch
.text$x:00006D6C ; COMDAT (pick associative to section at 6CB4)
.text$x:00006D6C                 assume es:nothing, ss:nothing, ds:_data, fs:nothing, gs:nothing
.text$x:00006D6C
.text$x:00006D6C ; =============== S U B R O U T I N E =======================================
.text$x:00006D6C
.text$x:00006D6C
.text$x:00006D6C __unwindfunclet$?_Orphan_range@?$vector@UToken@@V?$allocator@UToken@@@std@@@std@@IBEXPAUToken@@0@Z$0 proc near
.text$x:00006D6C                                         ; DATA XREF: .xdata$x:00009B18o
.text$x:00006D6C                 lea     ecx, [ebp-18h]  ; this
.text$x:00006D6F                 jmp     ??1_Lockit@std@@QAE@XZ ; std::_Lockit::~_Lockit(void)
.text$x:00006D6F __unwindfunclet$?_Orphan_range@?$vector@UToken@@V?$allocator@UToken@@@std@@@std@@IBEXPAUToken@@0@Z$0 endp
.text$x:00006D6F
.text$x:00006D74
.text$x:00006D74 ; =============== S U B R O U T I N E =======================================
.text$x:00006D74
.text$x:00006D74
.text$x:00006D74 __ehhandler$?_Orphan_range@?$vector@UToken@@V?$allocator@UToken@@@std@@@std@@IBEXPAUToken@@0@Z proc near
.text$x:00006D74                                         ; DATA XREF: std::vector<Token,std::allocator<Token>>::_Orphan_range(Token *,Token *)+5o
.text$x:00006D74
.text$x:00006D74 arg_4           = dword ptr  8
.text$x:00006D74
.text$x:00006D74                 mov     edx, [esp+arg_4]
.text$x:00006D78                 lea     eax, [edx+0Ch]
.text$x:00006D7B                 mov     ecx, [edx-10h]
.text$x:00006D7E                 xor     ecx, eax
.text$x:00006D80                 call    @__security_check_cookie@4 ; __security_check_cookie(x)
.text$x:00006D85                 mov     eax, offset __ehfuncinfo$?_Orphan_range@?$vector@UToken@@V?$allocator@UToken@@@std@@@std@@IBEXPAUToken@@0@Z
.text$x:00006D8A                 jmp     ___CxxFrameHandler3
.text$x:00006D8A __ehhandler$?_Orphan_range@?$vector@UToken@@V?$allocator@UToken@@@std@@@std@@IBEXPAUToken@@0@Z endp
.text$x:00006D8A
.text$x:00006D8A ; ---------------------------------------------------------------------------
.text$x:00006D8F                 align 10h
.text$x:00006D8F _text$x         ends
.text$x:00006D8F
.text$mn:00006D90 ; ===========================================================================
.text$mn:00006D90
.text$mn:00006D90 ; Segment type: Pure code
.text$mn:00006D90 ; Segment permissions: Read/Execute
.text$mn:00006D90 _text$mn        segment para public 'CODE' use32
.text$mn:00006D90                 assume cs:_text$mn
.text$mn:00006D90                 ;org 6D90h
.text$mn:00006D90 ; COMDAT (pick any)
.text$mn:00006D90                 assume es:nothing, ss:nothing, ds:_data, fs:nothing, gs:nothing
.text$mn:00006D90
.text$mn:00006D90 ; =============== S U B R O U T I N E =======================================
.text$mn:00006D90
.text$mn:00006D90 ; Attributes: bp-based frame
.text$mn:00006D90
.text$mn:00006D90 ; protected: void __thiscall std::vector<class std::vector<wchar_t const *, class std::allocator<wchar_t const *>>, class std::allocator<class std::vector<wchar_t const *, class std::allocator<wchar_t const *>>>>::_Orphan_range(class std::vector<wchar_t const *, class std::allocator<wchar_t const *>> *, class std::vector<wchar_t const *, class std::allocator<wchar_t const *>> *)const
.text$mn:00006D90                 public ?_Orphan_range@?$vector@V?$vector@PB_WV?$allocator@PB_W@std@@@std@@V?$allocator@V?$vector@PB_WV?$allocator@PB_W@std@@@std@@@2@@std@@IBEXPAV?$vector@PB_WV?$allocator@PB_W@std@@@2@0@Z
.text$mn:00006D90 ?_Orphan_range@?$vector@V?$vector@PB_WV?$allocator@PB_W@std@@@std@@V?$allocator@V?$vector@PB_WV?$allocator@PB_W@std@@@std@@@2@@std@@IBEXPAV?$vector@PB_WV?$allocator@PB_W@std@@@2@0@Z proc near
.text$mn:00006D90                                         ; CODE XREF: std::vector<std::vector<wchar_t const *,std::allocator<wchar_t const *>>,std::allocator<std::vector<wchar_t const *,std::allocator<wchar_t const *>>>>::push_back(std::vector<wchar_t const *,std::allocator<wchar_t const *>> const &)+66p
.text$mn:00006D90                                         ; std::vector<std::vector<wchar_t const *,std::allocator<wchar_t const *>>,std::allocator<std::vector<wchar_t const *,std::allocator<wchar_t const *>>>>::push_back(std::vector<wchar_t const *,std::allocator<wchar_t const *>> const &)+CCp
.text$mn:00006D90
.text$mn:00006D90 var_18          = byte ptr -18h
.text$mn:00006D90 var_14          = dword ptr -14h
.text$mn:00006D90 var_10          = dword ptr -10h
.text$mn:00006D90 var_C           = dword ptr -0Ch
.text$mn:00006D90 var_4           = dword ptr -4
.text$mn:00006D90 arg_0           = dword ptr  8
.text$mn:00006D90 arg_4           = dword ptr  0Ch
.text$mn:00006D90
.text$mn:00006D90                 push    ebp
.text$mn:00006D91                 mov     ebp, esp
.text$mn:00006D93                 push    0FFFFFFFFh
.text$mn:00006D95                 push    offset __ehhandler$?_Orphan_range@?$vector@V?$vector@PB_WV?$allocator@PB_W@std@@@std@@V?$allocator@V?$vector@PB_WV?$allocator@PB_W@std@@@std@@@2@@std@@IBEXPAV?$vector@PB_WV?$allocator@PB_W@std@@@2@0@Z
.text$mn:00006D9A                 mov     eax, large fs:0
.text$mn:00006DA0                 push    eax
.text$mn:00006DA1                 sub     esp, 0Ch
.text$mn:00006DA4                 mov     eax, dword ptr ds:___security_cookie
.text$mn:00006DA9                 xor     eax, ebp
.text$mn:00006DAB                 push    eax
.text$mn:00006DAC                 lea     eax, [ebp+var_C]
.text$mn:00006DAF                 mov     large fs:0, eax
.text$mn:00006DB5                 mov     [ebp+var_14], ecx
.text$mn:00006DB8                 push    3               ; int
.text$mn:00006DBA                 lea     ecx, [ebp+var_18] ; this
.text$mn:00006DBD                 call    ??0_Lockit@std@@QAE@H@Z ; std::_Lockit::_Lockit(int)
.text$mn:00006DC2                 mov     [ebp+var_4], 0
.text$mn:00006DC9                 mov     ecx, [ebp+var_14] ; this
.text$mn:00006DCC                 call    ?_Getpfirst@_Container_base12@std@@QBEPAPAU_Iterator_base12@2@XZ ; std::_Container_base12::_Getpfirst(void)
.text$mn:00006DD1                 mov     [ebp+var_10], eax
.text$mn:00006DD4                 cmp     [ebp+var_10], 0
.text$mn:00006DD8                 jz      short loc_6E28
.text$mn:00006DDA
.text$mn:00006DDA loc_6DDA:                               ; CODE XREF: std::vector<std::vector<wchar_t const *,std::allocator<wchar_t const *>>,std::allocator<std::vector<wchar_t const *,std::allocator<wchar_t const *>>>>::_Orphan_range(std::vector<wchar_t const *,std::allocator<wchar_t const *>> *,std::vector<wchar_t const *,std::allocator<wchar_t const *>> *):loc_6E26j
.text$mn:00006DDA                 mov     eax, [ebp+var_10]
.text$mn:00006DDD                 cmp     dword ptr [eax], 0
.text$mn:00006DE0                 jz      short loc_6E28
.text$mn:00006DE2                 mov     ecx, [ebp+var_10]
.text$mn:00006DE5                 mov     edx, [ecx]
.text$mn:00006DE7                 mov     eax, [edx+8]
.text$mn:00006DEA                 cmp     eax, [ebp+arg_0]
.text$mn:00006DED                 jb      short loc_6DFC
.text$mn:00006DEF                 mov     ecx, [ebp+var_10]
.text$mn:00006DF2                 mov     edx, [ecx]
.text$mn:00006DF4                 mov     eax, [ebp+arg_4]
.text$mn:00006DF7                 cmp     eax, [edx+8]
.text$mn:00006DFA                 jnb     short loc_6E0B
.text$mn:00006DFC
.text$mn:00006DFC loc_6DFC:                               ; CODE XREF: std::vector<std::vector<wchar_t const *,std::allocator<wchar_t const *>>,std::allocator<std::vector<wchar_t const *,std::allocator<wchar_t const *>>>>::_Orphan_range(std::vector<wchar_t const *,std::allocator<wchar_t const *>> *,std::vector<wchar_t const *,std::allocator<wchar_t const *>> *)+5Dj
.text$mn:00006DFC                 mov     ecx, [ebp+var_10]
.text$mn:00006DFF                 mov     ecx, [ecx]      ; this
.text$mn:00006E01                 call    ?_Getpnext@_Iterator_base12@std@@QAEPAPAU12@XZ ; std::_Iterator_base12::_Getpnext(void)
.text$mn:00006E06                 mov     [ebp+var_10], eax
.text$mn:00006E09                 jmp     short loc_6E26
.text$mn:00006E0B ; ---------------------------------------------------------------------------
.text$mn:00006E0B
.text$mn:00006E0B loc_6E0B:                               ; CODE XREF: std::vector<std::vector<wchar_t const *,std::allocator<wchar_t const *>>,std::allocator<std::vector<wchar_t const *,std::allocator<wchar_t const *>>>>::_Orphan_range(std::vector<wchar_t const *,std::allocator<wchar_t const *>> *,std::vector<wchar_t const *,std::allocator<wchar_t const *>> *)+6Aj
.text$mn:00006E0B                 mov     edx, [ebp+var_10]
.text$mn:00006E0E                 mov     ecx, [edx]      ; this
.text$mn:00006E10                 call    ?_Clrcont@_Iterator_base12@std@@QAEXXZ ; std::_Iterator_base12::_Clrcont(void)
.text$mn:00006E15                 mov     eax, [ebp+var_10]
.text$mn:00006E18                 mov     ecx, [eax]      ; this
.text$mn:00006E1A                 call    ?_Getpnext@_Iterator_base12@std@@QAEPAPAU12@XZ ; std::_Iterator_base12::_Getpnext(void)
.text$mn:00006E1F                 mov     ecx, [ebp+var_10]
.text$mn:00006E22                 mov     edx, [eax]
.text$mn:00006E24                 mov     [ecx], edx
.text$mn:00006E26
.text$mn:00006E26 loc_6E26:                               ; CODE XREF: std::vector<std::vector<wchar_t const *,std::allocator<wchar_t const *>>,std::allocator<std::vector<wchar_t const *,std::allocator<wchar_t const *>>>>::_Orphan_range(std::vector<wchar_t const *,std::allocator<wchar_t const *>> *,std::vector<wchar_t const *,std::allocator<wchar_t const *>> *)+79j
.text$mn:00006E26                 jmp     short loc_6DDA
.text$mn:00006E28 ; ---------------------------------------------------------------------------
.text$mn:00006E28
.text$mn:00006E28 loc_6E28:                               ; CODE XREF: std::vector<std::vector<wchar_t const *,std::allocator<wchar_t const *>>,std::allocator<std::vector<wchar_t const *,std::allocator<wchar_t const *>>>>::_Orphan_range(std::vector<wchar_t const *,std::allocator<wchar_t const *>> *,std::vector<wchar_t const *,std::allocator<wchar_t const *>> *)+48j
.text$mn:00006E28                                         ; std::vector<std::vector<wchar_t const *,std::allocator<wchar_t const *>>,std::allocator<std::vector<wchar_t const *,std::allocator<wchar_t const *>>>>::_Orphan_range(std::vector<wchar_t const *,std::allocator<wchar_t const *>> *,std::vector<wchar_t const *,std::allocator<wchar_t const *>> *)+50j
.text$mn:00006E28                 mov     [ebp+var_4], 0FFFFFFFFh
.text$mn:00006E2F                 lea     ecx, [ebp+var_18] ; this
.text$mn:00006E32                 call    ??1_Lockit@std@@QAE@XZ ; std::_Lockit::~_Lockit(void)
.text$mn:00006E37                 mov     ecx, [ebp+var_C]
.text$mn:00006E3A                 mov     large fs:0, ecx
.text$mn:00006E41                 pop     ecx
.text$mn:00006E42                 mov     esp, ebp
.text$mn:00006E44                 pop     ebp
.text$mn:00006E45                 retn    8
.text$mn:00006E45 ?_Orphan_range@?$vector@V?$vector@PB_WV?$allocator@PB_W@std@@@std@@V?$allocator@V?$vector@PB_WV?$allocator@PB_W@std@@@std@@@2@@std@@IBEXPAV?$vector@PB_WV?$allocator@PB_W@std@@@2@0@Z endp
.text$mn:00006E45
.text$mn:00006E45 _text$mn        ends
.text$mn:00006E45
.text$x:00006E48 ; ===========================================================================
.text$x:00006E48
.text$x:00006E48 ; Segment type: Pure code
.text$x:00006E48 ; Segment permissions: Read/Execute
.text$x:00006E48 _text$x         segment para public 'CODE' use32
.text$x:00006E48                 assume cs:_text$x
.text$x:00006E48                 ;org 6E48h
.text$x:00006E48 ; COMDAT (pick associative to section at 6D90)
.text$x:00006E48                 assume es:nothing, ss:nothing, ds:_data, fs:nothing, gs:nothing
.text$x:00006E48
.text$x:00006E48 ; =============== S U B R O U T I N E =======================================
.text$x:00006E48
.text$x:00006E48
.text$x:00006E48 __unwindfunclet$?_Orphan_range@?$vector@V?$vector@PB_WV?$allocator@PB_W@std@@@std@@V?$allocator@V?$vector@PB_WV?$allocator@PB_W@std@@@std@@@2@@std@@IBEXPAV?$vector@PB_WV?$allocator@PB_W@std@@@2@0@Z$0 proc near
.text$x:00006E48                                         ; DATA XREF: .xdata$x:0000992Co
.text$x:00006E48                 lea     ecx, [ebp-18h]  ; this
.text$x:00006E4B                 jmp     ??1_Lockit@std@@QAE@XZ ; std::_Lockit::~_Lockit(void)
.text$x:00006E4B __unwindfunclet$?_Orphan_range@?$vector@V?$vector@PB_WV?$allocator@PB_W@std@@@std@@V?$allocator@V?$vector@PB_WV?$allocator@PB_W@std@@@std@@@2@@std@@IBEXPAV?$vector@PB_WV?$allocator@PB_W@std@@@2@0@Z$0 endp
.text$x:00006E4B
.text$x:00006E50
.text$x:00006E50 ; =============== S U B R O U T I N E =======================================
.text$x:00006E50
.text$x:00006E50
.text$x:00006E50 __ehhandler$?_Orphan_range@?$vector@V?$vector@PB_WV?$allocator@PB_W@std@@@std@@V?$allocator@V?$vector@PB_WV?$allocator@PB_W@std@@@std@@@2@@std@@IBEXPAV?$vector@PB_WV?$allocator@PB_W@std@@@2@0@Z proc near
.text$x:00006E50                                         ; DATA XREF: std::vector<std::vector<wchar_t const *,std::allocator<wchar_t const *>>,std::allocator<std::vector<wchar_t const *,std::allocator<wchar_t const *>>>>::_Orphan_range(std::vector<wchar_t const *,std::allocator<wchar_t const *>> *,std::vector<wchar_t const *,std::allocator<wchar_t const *>> *)+5o
.text$x:00006E50
.text$x:00006E50 arg_4           = dword ptr  8
.text$x:00006E50
.text$x:00006E50                 mov     edx, [esp+arg_4]
.text$x:00006E54                 lea     eax, [edx+0Ch]
.text$x:00006E57                 mov     ecx, [edx-10h]
.text$x:00006E5A                 xor     ecx, eax
.text$x:00006E5C                 call    @__security_check_cookie@4 ; __security_check_cookie(x)
.text$x:00006E61                 mov     eax, offset __ehfuncinfo$?_Orphan_range@?$vector@V?$vector@PB_WV?$allocator@PB_W@std@@@std@@V?$allocator@V?$vector@PB_WV?$allocator@PB_W@std@@@std@@@2@@std@@IBEXPAV?$vector@PB_WV?$allocator@PB_W@std@@@2@0@Z
.text$x:00006E66                 jmp     ___CxxFrameHandler3
.text$x:00006E66 __ehhandler$?_Orphan_range@?$vector@V?$vector@PB_WV?$allocator@PB_W@std@@@std@@V?$allocator@V?$vector@PB_WV?$allocator@PB_W@std@@@std@@@2@@std@@IBEXPAV?$vector@PB_WV?$allocator@PB_W@std@@@2@0@Z endp
.text$x:00006E66
.text$x:00006E66 ; ---------------------------------------------------------------------------
.text$x:00006E6B                 align 4
.text$x:00006E6B _text$x         ends
.text$x:00006E6B
.text$mn:00006E6C ; ===========================================================================
.text$mn:00006E6C
.text$mn:00006E6C ; Segment type: Pure code
.text$mn:00006E6C ; Segment permissions: Read/Execute
.text$mn:00006E6C _text$mn        segment para public 'CODE' use32
.text$mn:00006E6C                 assume cs:_text$mn
.text$mn:00006E6C                 ;org 6E6Ch
.text$mn:00006E6C ; COMDAT (pick any)
.text$mn:00006E6C                 assume es:nothing, ss:nothing, ds:_data, fs:nothing, gs:nothing
.text$mn:00006E6C
.text$mn:00006E6C ; =============== S U B R O U T I N E =======================================
.text$mn:00006E6C
.text$mn:00006E6C ; Attributes: bp-based frame
.text$mn:00006E6C
.text$mn:00006E6C ; protected: void __thiscall std::vector<wchar_t const *, class std::allocator<wchar_t const *>>::_Reallocate(unsigned int)
.text$mn:00006E6C                 public ?_Reallocate@?$vector@PB_WV?$allocator@PB_W@std@@@std@@IAEXI@Z
.text$mn:00006E6C ?_Reallocate@?$vector@PB_WV?$allocator@PB_W@std@@@std@@IAEXI@Z proc near
.text$mn:00006E6C                                         ; CODE XREF: std::vector<wchar_t const *,std::allocator<wchar_t const *>>::_Reserve(uint)+4Ep
.text$mn:00006E6C
.text$mn:00006E6C var_20          = dword ptr -20h
.text$mn:00006E6C var_1C          = dword ptr -1Ch
.text$mn:00006E6C var_18          = dword ptr -18h
.text$mn:00006E6C var_13          = byte ptr -13h
.text$mn:00006E6C var_11          = byte ptr -11h
.text$mn:00006E6C var_10          = dword ptr -10h
.text$mn:00006E6C var_C           = dword ptr -0Ch
.text$mn:00006E6C var_4           = dword ptr -4
.text$mn:00006E6C arg_0           = dword ptr  8
.text$mn:00006E6C
.text$mn:00006E6C ; FUNCTION CHUNK AT .text$mn:00006F02 SIZE 00000009 BYTES
.text$mn:00006E6C ; FUNCTION CHUNK AT .text$mn:00006F12 SIZE 00000097 BYTES
.text$mn:00006E6C
.text$mn:00006E6C                 push    ebp
.text$mn:00006E6D                 mov     ebp, esp
.text$mn:00006E6F                 push    0FFFFFFFFh
.text$mn:00006E71                 push    offset __ehhandler$?_Reallocate@?$vector@PB_WV?$allocator@PB_W@std@@@std@@IAEXI@Z
.text$mn:00006E76                 mov     eax, large fs:0
.text$mn:00006E7C                 push    eax
.text$mn:00006E7D                 push    ecx
.text$mn:00006E7E                 sub     esp, 10h
.text$mn:00006E81                 push    ebx
.text$mn:00006E82                 push    esi
.text$mn:00006E83                 push    edi
.text$mn:00006E84                 mov     eax, dword ptr ds:___security_cookie
.text$mn:00006E89                 xor     eax, ebp
.text$mn:00006E8B                 push    eax
.text$mn:00006E8C                 lea     eax, [ebp+var_C]
.text$mn:00006E8F                 mov     large fs:0, eax
.text$mn:00006E95                 mov     [ebp+var_10], esp
.text$mn:00006E98                 mov     [ebp+var_18], ecx
.text$mn:00006E9B                 mov     eax, [ebp+arg_0]
.text$mn:00006E9E                 push    eax
.text$mn:00006E9F                 lea     ecx, [ebp+var_11]
.text$mn:00006EA2                 push    ecx
.text$mn:00006EA3                 mov     ecx, [ebp+var_18]
.text$mn:00006EA6                 call    ?_Getal@?$_Vector_alloc@$0A@U?$_Vec_base_types@PB_WV?$allocator@PB_W@std@@@std@@@std@@QBE?AU?$_Wrap_alloc@V?$allocator@PB_W@std@@@2@XZ ; std::_Vector_alloc<0,std::_Vec_base_types<wchar_t const *,std::allocator<wchar_t const *>>>::_Getal(void)
.text$mn:00006EAB                 mov     ecx, eax
.text$mn:00006EAD                 call    ?allocate@?$_Wrap_alloc@V?$allocator@PB_W@std@@@std@@QAEPAPB_WI@Z ; std::_Wrap_alloc<std::allocator<wchar_t const *>>::allocate(uint)
.text$mn:00006EB2                 mov     [ebp+var_1C], eax
.text$mn:00006EB5                 mov     [ebp+var_4], 0
.text$mn:00006EBC                 mov     edx, [ebp+var_1C]
.text$mn:00006EBF                 push    edx
.text$mn:00006EC0                 mov     eax, [ebp+var_18]
.text$mn:00006EC3                 mov     ecx, [eax+8]
.text$mn:00006EC6                 push    ecx
.text$mn:00006EC7                 mov     edx, [ebp+var_18]
.text$mn:00006ECA                 mov     eax, [edx+4]
.text$mn:00006ECD                 push    eax
.text$mn:00006ECE                 mov     ecx, [ebp+var_18]
.text$mn:00006ED1                 call    ??$_Umove@PAPB_W@?$vector@PB_WV?$allocator@PB_W@std@@@std@@IAEPAPB_WPAPB_W00@Z ; std::vector<wchar_t const *,std::allocator<wchar_t const *>>::_Umove<wchar_t const * *>(wchar_t const * *,wchar_t const * *,wchar_t const * *)
.text$mn:00006ED6                 jmp     short loc_6F02
.text$mn:00006ED6 ?_Reallocate@?$vector@PB_WV?$allocator@PB_W@std@@@std@@IAEXI@Z endp
.text$mn:00006ED6
.text$mn:00006ED8
.text$mn:00006ED8 ; =============== S U B R O U T I N E =======================================
.text$mn:00006ED8
.text$mn:00006ED8 ; Attributes: noreturn
.text$mn:00006ED8
.text$mn:00006ED8 __catch$?_Reallocate@?$vector@PB_WV?$allocator@PB_W@std@@@std@@IAEXI@Z$0 proc near
.text$mn:00006ED8                                         ; DATA XREF: .xdata$x:0000982Co
.text$mn:00006ED8                 mov     ecx, [ebp+8]
.text$mn:00006EDB                 push    ecx             ; int
.text$mn:00006EDC                 mov     edx, [ebp-1Ch]
.text$mn:00006EDF                 push    edx             ; void *
.text$mn:00006EE0                 lea     eax, [ebp-12h]
.text$mn:00006EE3                 push    eax
.text$mn:00006EE4                 mov     ecx, [ebp-18h]
.text$mn:00006EE7                 call    ?_Getal@?$_Vector_alloc@$0A@U?$_Vec_base_types@PB_WV?$allocator@PB_W@std@@@std@@@std@@QBE?AU?$_Wrap_alloc@V?$allocator@PB_W@std@@@2@XZ ; std::_Vector_alloc<0,std::_Vec_base_types<wchar_t const *,std::allocator<wchar_t const *>>>::_Getal(void)
.text$mn:00006EEC                 mov     ecx, eax
.text$mn:00006EEE                 call    ?deallocate@?$_Wrap_alloc@V?$allocator@PB_W@std@@@std@@QAEXPAPB_WI@Z ; std::_Wrap_alloc<std::allocator<wchar_t const *>>::deallocate(wchar_t const * *,uint)
.text$mn:00006EF3                 push    0
.text$mn:00006EF5                 push    0
.text$mn:00006EF7                 call    __CxxThrowException@8 ; _CxxThrowException(x,x)
.text$mn:00006EF7 __catch$?_Reallocate@?$vector@PB_WV?$allocator@PB_W@std@@@std@@IAEXI@Z$0 endp
.text$mn:00006EF7
.text$mn:00006EFC ; ---------------------------------------------------------------------------
.text$mn:00006EFC                 mov     eax, offset $LN8
.text$mn:00006F01                 retn
.text$mn:00006F02 ; ---------------------------------------------------------------------------
.text$mn:00006F02 ; START OF FUNCTION CHUNK FOR ?_Reallocate@?$vector@PB_WV?$allocator@PB_W@std@@@std@@IAEXI@Z
.text$mn:00006F02
.text$mn:00006F02 loc_6F02:                               ; CODE XREF: std::vector<wchar_t const *,std::allocator<wchar_t const *>>::_Reallocate(uint)+6Aj
.text$mn:00006F02                 mov     [ebp+var_4], 0FFFFFFFFh
.text$mn:00006F09                 jmp     short loc_6F12
.text$mn:00006F09 ; END OF FUNCTION CHUNK FOR ?_Reallocate@?$vector@PB_WV?$allocator@PB_W@std@@@std@@IAEXI@Z
.text$mn:00006F0B
.text$mn:00006F0B ; =============== S U B R O U T I N E =======================================
.text$mn:00006F0B
.text$mn:00006F0B
.text$mn:00006F0B $LN8            proc near               ; DATA XREF: .text$mn:00006EFCo
.text$mn:00006F0B                 mov     dword ptr [ebp-4], 0FFFFFFFFh
.text$mn:00006F0B $LN8            endp ; sp-analysis failed
.text$mn:00006F0B
.text$mn:00006F12 ; START OF FUNCTION CHUNK FOR ?_Reallocate@?$vector@PB_WV?$allocator@PB_W@std@@@std@@IAEXI@Z
.text$mn:00006F12
.text$mn:00006F12 loc_6F12:                               ; CODE XREF: std::vector<wchar_t const *,std::allocator<wchar_t const *>>::_Reallocate(uint)+9Dj
.text$mn:00006F12                 mov     ecx, [ebp+var_18]
.text$mn:00006F15                 call    ?size@?$vector@PB_WV?$allocator@PB_W@std@@@std@@QBEIXZ ; std::vector<wchar_t const *,std::allocator<wchar_t const *>>::size(void)
.text$mn:00006F1A                 mov     [ebp+var_20], eax
.text$mn:00006F1D                 mov     ecx, [ebp+var_18]
.text$mn:00006F20                 cmp     dword ptr [ecx+4], 0
.text$mn:00006F24                 jz      short loc_6F66
.text$mn:00006F26                 mov     edx, [ebp+var_18]
.text$mn:00006F29                 mov     eax, [edx+8]
.text$mn:00006F2C                 push    eax
.text$mn:00006F2D                 mov     ecx, [ebp+var_18]
.text$mn:00006F30                 mov     edx, [ecx+4]
.text$mn:00006F33                 push    edx
.text$mn:00006F34                 mov     ecx, [ebp+var_18]
.text$mn:00006F37                 call    ?_Destroy@?$vector@PB_WV?$allocator@PB_W@std@@@std@@IAEXPAPB_W0@Z ; std::vector<wchar_t const *,std::allocator<wchar_t const *>>::_Destroy(wchar_t const * *,wchar_t const * *)
.text$mn:00006F3C                 mov     eax, [ebp+var_18]
.text$mn:00006F3F                 mov     ecx, [ebp+var_18]
.text$mn:00006F42                 mov     edx, [eax+0Ch]
.text$mn:00006F45                 sub     edx, [ecx+4]
.text$mn:00006F48                 sar     edx, 2
.text$mn:00006F4B                 push    edx             ; int
.text$mn:00006F4C                 mov     eax, [ebp+var_18]
.text$mn:00006F4F                 mov     ecx, [eax+4]
.text$mn:00006F52                 push    ecx             ; void *
.text$mn:00006F53                 lea     edx, [ebp+var_13]
.text$mn:00006F56                 push    edx
.text$mn:00006F57                 mov     ecx, [ebp+var_18]
.text$mn:00006F5A                 call    ?_Getal@?$_Vector_alloc@$0A@U?$_Vec_base_types@PB_WV?$allocator@PB_W@std@@@std@@@std@@QBE?AU?$_Wrap_alloc@V?$allocator@PB_W@std@@@2@XZ ; std::_Vector_alloc<0,std::_Vec_base_types<wchar_t const *,std::allocator<wchar_t const *>>>::_Getal(void)
.text$mn:00006F5F                 mov     ecx, eax
.text$mn:00006F61                 call    ?deallocate@?$_Wrap_alloc@V?$allocator@PB_W@std@@@std@@QAEXPAPB_WI@Z ; std::_Wrap_alloc<std::allocator<wchar_t const *>>::deallocate(wchar_t const * *,uint)
.text$mn:00006F66
.text$mn:00006F66 loc_6F66:                               ; CODE XREF: std::vector<wchar_t const *,std::allocator<wchar_t const *>>::_Reallocate(uint)+B8j
.text$mn:00006F66                 mov     ecx, [ebp+var_18] ; this
.text$mn:00006F69                 call    ?_Orphan_all@_Container_base12@std@@QAEXXZ ; std::_Container_base12::_Orphan_all(void)
.text$mn:00006F6E                 mov     eax, [ebp+arg_0]
.text$mn:00006F71                 mov     ecx, [ebp+var_1C]
.text$mn:00006F74                 lea     edx, [ecx+eax*4]
.text$mn:00006F77                 mov     eax, [ebp+var_18]
.text$mn:00006F7A                 mov     [eax+0Ch], edx
.text$mn:00006F7D                 mov     ecx, [ebp+var_20]
.text$mn:00006F80                 mov     edx, [ebp+var_1C]
.text$mn:00006F83                 lea     eax, [edx+ecx*4]
.text$mn:00006F86                 mov     ecx, [ebp+var_18]
.text$mn:00006F89                 mov     [ecx+8], eax
.text$mn:00006F8C                 mov     edx, [ebp+var_18]
.text$mn:00006F8F                 mov     eax, [ebp+var_1C]
.text$mn:00006F92                 mov     [edx+4], eax
.text$mn:00006F95                 mov     ecx, [ebp+var_C]
.text$mn:00006F98                 mov     large fs:0, ecx
.text$mn:00006F9F                 pop     ecx
.text$mn:00006FA0                 pop     edi
.text$mn:00006FA1                 pop     esi
.text$mn:00006FA2                 pop     ebx
.text$mn:00006FA3                 mov     esp, ebp
.text$mn:00006FA5                 pop     ebp
.text$mn:00006FA6                 retn    4
.text$mn:00006FA6 ; END OF FUNCTION CHUNK FOR ?_Reallocate@?$vector@PB_WV?$allocator@PB_W@std@@@std@@IAEXI@Z
.text$mn:00006FA6 ; ---------------------------------------------------------------------------
.text$mn:00006FA9                 align 4
.text$mn:00006FA9 _text$mn        ends
.text$mn:00006FA9
.text$x:00006FAC ; ===========================================================================
.text$x:00006FAC
.text$x:00006FAC ; Segment type: Pure code
.text$x:00006FAC ; Segment permissions: Read/Execute
.text$x:00006FAC _text$x         segment para public 'CODE' use32
.text$x:00006FAC                 assume cs:_text$x
.text$x:00006FAC                 ;org 6FACh
.text$x:00006FAC ; COMDAT (pick associative to section at 6E6C)
.text$x:00006FAC                 assume es:nothing, ss:nothing, ds:_data, fs:nothing, gs:nothing
.text$x:00006FAC
.text$x:00006FAC ; =============== S U B R O U T I N E =======================================
.text$x:00006FAC
.text$x:00006FAC
.text$x:00006FAC __ehhandler$?_Reallocate@?$vector@PB_WV?$allocator@PB_W@std@@@std@@IAEXI@Z proc near
.text$x:00006FAC                                         ; DATA XREF: std::vector<wchar_t const *,std::allocator<wchar_t const *>>::_Reallocate(uint)+5o
.text$x:00006FAC
.text$x:00006FAC arg_4           = dword ptr  8
.text$x:00006FAC
.text$x:00006FAC                 mov     edx, [esp+arg_4]
.text$x:00006FB0                 lea     eax, [edx+0Ch]
.text$x:00006FB3                 mov     ecx, [edx-24h]
.text$x:00006FB6                 xor     ecx, eax
.text$x:00006FB8                 call    @__security_check_cookie@4 ; __security_check_cookie(x)
.text$x:00006FBD                 mov     eax, offset __ehfuncinfo$?_Reallocate@?$vector@PB_WV?$allocator@PB_W@std@@@std@@IAEXI@Z
.text$x:00006FC2                 jmp     ___CxxFrameHandler3
.text$x:00006FC2 __ehhandler$?_Reallocate@?$vector@PB_WV?$allocator@PB_W@std@@@std@@IAEXI@Z endp
.text$x:00006FC2
.text$x:00006FC2 ; ---------------------------------------------------------------------------
.text$x:00006FC7                 align 4
.text$x:00006FC7 _text$x         ends
.text$x:00006FC7
.text$mn:00006FC8 ; ===========================================================================
.text$mn:00006FC8
.text$mn:00006FC8 ; Segment type: Pure code
.text$mn:00006FC8 ; Segment permissions: Read/Execute
.text$mn:00006FC8 _text$mn        segment para public 'CODE' use32
.text$mn:00006FC8                 assume cs:_text$mn
.text$mn:00006FC8                 ;org 6FC8h
.text$mn:00006FC8 ; COMDAT (pick any)
.text$mn:00006FC8                 assume es:nothing, ss:nothing, ds:_data, fs:nothing, gs:nothing
.text$mn:00006FC8
.text$mn:00006FC8 ; =============== S U B R O U T I N E =======================================
.text$mn:00006FC8
.text$mn:00006FC8 ; Attributes: bp-based frame
.text$mn:00006FC8
.text$mn:00006FC8 ; protected: void __thiscall std::vector<struct FunctionValues, class std::allocator<struct FunctionValues>>::_Reallocate(unsigned int)
.text$mn:00006FC8                 public ?_Reallocate@?$vector@UFunctionValues@@V?$allocator@UFunctionValues@@@std@@@std@@IAEXI@Z
.text$mn:00006FC8 ?_Reallocate@?$vector@UFunctionValues@@V?$allocator@UFunctionValues@@@std@@@std@@IAEXI@Z proc near
.text$mn:00006FC8                                         ; CODE XREF: std::vector<FunctionValues,std::allocator<FunctionValues>>::_Reserve(uint)+4Ep
.text$mn:00006FC8
.text$mn:00006FC8 var_20          = dword ptr -20h
.text$mn:00006FC8 var_1C          = dword ptr -1Ch
.text$mn:00006FC8 var_18          = dword ptr -18h
.text$mn:00006FC8 var_13          = byte ptr -13h
.text$mn:00006FC8 var_11          = byte ptr -11h
.text$mn:00006FC8 var_10          = dword ptr -10h
.text$mn:00006FC8 var_C           = dword ptr -0Ch
.text$mn:00006FC8 var_4           = dword ptr -4
.text$mn:00006FC8 arg_0           = dword ptr  8
.text$mn:00006FC8
.text$mn:00006FC8 ; FUNCTION CHUNK AT .text$mn:0000705E SIZE 00000009 BYTES
.text$mn:00006FC8 ; FUNCTION CHUNK AT .text$mn:0000706E SIZE 00000097 BYTES
.text$mn:00006FC8
.text$mn:00006FC8                 push    ebp
.text$mn:00006FC9                 mov     ebp, esp
.text$mn:00006FCB                 push    0FFFFFFFFh
.text$mn:00006FCD                 push    offset __ehhandler$?_Reallocate@?$vector@UFunctionValues@@V?$allocator@UFunctionValues@@@std@@@std@@IAEXI@Z
.text$mn:00006FD2                 mov     eax, large fs:0
.text$mn:00006FD8                 push    eax
.text$mn:00006FD9                 push    ecx
.text$mn:00006FDA                 sub     esp, 10h
.text$mn:00006FDD                 push    ebx
.text$mn:00006FDE                 push    esi
.text$mn:00006FDF                 push    edi
.text$mn:00006FE0                 mov     eax, dword ptr ds:___security_cookie
.text$mn:00006FE5                 xor     eax, ebp
.text$mn:00006FE7                 push    eax
.text$mn:00006FE8                 lea     eax, [ebp+var_C]
.text$mn:00006FEB                 mov     large fs:0, eax
.text$mn:00006FF1                 mov     [ebp+var_10], esp
.text$mn:00006FF4                 mov     [ebp+var_18], ecx
.text$mn:00006FF7                 mov     eax, [ebp+arg_0]
.text$mn:00006FFA                 push    eax
.text$mn:00006FFB                 lea     ecx, [ebp+var_11]
.text$mn:00006FFE                 push    ecx
.text$mn:00006FFF                 mov     ecx, [ebp+var_18]
.text$mn:00007002                 call    ?_Getal@?$_Vector_alloc@$0A@U?$_Vec_base_types@UFunctionValues@@V?$allocator@UFunctionValues@@@std@@@std@@@std@@QBE?AU?$_Wrap_alloc@V?$allocator@UFunctionValues@@@std@@@2@XZ ; std::_Vector_alloc<0,std::_Vec_base_types<FunctionValues,std::allocator<FunctionValues>>>::_Getal(void)
.text$mn:00007007                 mov     ecx, eax
.text$mn:00007009                 call    ?allocate@?$_Wrap_alloc@V?$allocator@UFunctionValues@@@std@@@std@@QAEPAUFunctionValues@@I@Z ; std::_Wrap_alloc<std::allocator<FunctionValues>>::allocate(uint)
.text$mn:0000700E                 mov     [ebp+var_1C], eax
.text$mn:00007011                 mov     [ebp+var_4], 0
.text$mn:00007018                 mov     edx, [ebp+var_1C]
.text$mn:0000701B                 push    edx
.text$mn:0000701C                 mov     eax, [ebp+var_18]
.text$mn:0000701F                 mov     ecx, [eax+8]
.text$mn:00007022                 push    ecx
.text$mn:00007023                 mov     edx, [ebp+var_18]
.text$mn:00007026                 mov     eax, [edx+4]
.text$mn:00007029                 push    eax
.text$mn:0000702A                 mov     ecx, [ebp+var_18]
.text$mn:0000702D                 call    ??$_Umove@PAUFunctionValues@@@?$vector@UFunctionValues@@V?$allocator@UFunctionValues@@@std@@@std@@IAEPAUFunctionValues@@PAU2@00@Z ; std::vector<FunctionValues,std::allocator<FunctionValues>>::_Umove<FunctionValues *>(FunctionValues *,FunctionValues *,FunctionValues *)
.text$mn:00007032                 jmp     short loc_705E
.text$mn:00007032 ?_Reallocate@?$vector@UFunctionValues@@V?$allocator@UFunctionValues@@@std@@@std@@IAEXI@Z endp
.text$mn:00007032
.text$mn:00007034
.text$mn:00007034 ; =============== S U B R O U T I N E =======================================
.text$mn:00007034
.text$mn:00007034 ; Attributes: noreturn
.text$mn:00007034
.text$mn:00007034 __catch$?_Reallocate@?$vector@UFunctionValues@@V?$allocator@UFunctionValues@@@std@@@std@@IAEXI@Z$0 proc near
.text$mn:00007034                                         ; DATA XREF: .xdata$x:00009CB4o
.text$mn:00007034                 mov     ecx, [ebp+8]
.text$mn:00007037                 push    ecx             ; int
.text$mn:00007038                 mov     edx, [ebp-1Ch]
.text$mn:0000703B                 push    edx             ; void *
.text$mn:0000703C                 lea     eax, [ebp-12h]
.text$mn:0000703F                 push    eax
.text$mn:00007040                 mov     ecx, [ebp-18h]
.text$mn:00007043                 call    ?_Getal@?$_Vector_alloc@$0A@U?$_Vec_base_types@UFunctionValues@@V?$allocator@UFunctionValues@@@std@@@std@@@std@@QBE?AU?$_Wrap_alloc@V?$allocator@UFunctionValues@@@std@@@2@XZ ; std::_Vector_alloc<0,std::_Vec_base_types<FunctionValues,std::allocator<FunctionValues>>>::_Getal(void)
.text$mn:00007048                 mov     ecx, eax
.text$mn:0000704A                 call    ?deallocate@?$_Wrap_alloc@V?$allocator@UFunctionValues@@@std@@@std@@QAEXPAUFunctionValues@@I@Z ; std::_Wrap_alloc<std::allocator<FunctionValues>>::deallocate(FunctionValues *,uint)
.text$mn:0000704F                 push    0
.text$mn:00007051                 push    0
.text$mn:00007053                 call    __CxxThrowException@8 ; _CxxThrowException(x,x)
.text$mn:00007053 __catch$?_Reallocate@?$vector@UFunctionValues@@V?$allocator@UFunctionValues@@@std@@@std@@IAEXI@Z$0 endp
.text$mn:00007053
.text$mn:00007058 ; ---------------------------------------------------------------------------
.text$mn:00007058                 mov     eax, offset $LN8_2
.text$mn:0000705D                 retn
.text$mn:0000705E ; ---------------------------------------------------------------------------
.text$mn:0000705E ; START OF FUNCTION CHUNK FOR ?_Reallocate@?$vector@UFunctionValues@@V?$allocator@UFunctionValues@@@std@@@std@@IAEXI@Z
.text$mn:0000705E
.text$mn:0000705E loc_705E:                               ; CODE XREF: std::vector<FunctionValues,std::allocator<FunctionValues>>::_Reallocate(uint)+6Aj
.text$mn:0000705E                 mov     [ebp+var_4], 0FFFFFFFFh
.text$mn:00007065                 jmp     short loc_706E
.text$mn:00007065 ; END OF FUNCTION CHUNK FOR ?_Reallocate@?$vector@UFunctionValues@@V?$allocator@UFunctionValues@@@std@@@std@@IAEXI@Z
.text$mn:00007067
.text$mn:00007067 ; =============== S U B R O U T I N E =======================================
.text$mn:00007067
.text$mn:00007067
.text$mn:00007067 $LN8_2          proc near               ; DATA XREF: .text$mn:00007058o
.text$mn:00007067                 mov     dword ptr [ebp-4], 0FFFFFFFFh
.text$mn:00007067 $LN8_2          endp ; sp-analysis failed
.text$mn:00007067
.text$mn:0000706E ; START OF FUNCTION CHUNK FOR ?_Reallocate@?$vector@UFunctionValues@@V?$allocator@UFunctionValues@@@std@@@std@@IAEXI@Z
.text$mn:0000706E
.text$mn:0000706E loc_706E:                               ; CODE XREF: std::vector<FunctionValues,std::allocator<FunctionValues>>::_Reallocate(uint)+9Dj
.text$mn:0000706E                 mov     ecx, [ebp+var_18]
.text$mn:00007071                 call    ?size@?$vector@UFunctionValues@@V?$allocator@UFunctionValues@@@std@@@std@@QBEIXZ ; std::vector<FunctionValues,std::allocator<FunctionValues>>::size(void)
.text$mn:00007076                 mov     [ebp+var_20], eax
.text$mn:00007079                 mov     ecx, [ebp+var_18]
.text$mn:0000707C                 cmp     dword ptr [ecx+4], 0
.text$mn:00007080                 jz      short loc_70C2
.text$mn:00007082                 mov     edx, [ebp+var_18]
.text$mn:00007085                 mov     eax, [edx+8]
.text$mn:00007088                 push    eax
.text$mn:00007089                 mov     ecx, [ebp+var_18]
.text$mn:0000708C                 mov     edx, [ecx+4]
.text$mn:0000708F                 push    edx
.text$mn:00007090                 mov     ecx, [ebp+var_18]
.text$mn:00007093                 call    ?_Destroy@?$vector@UFunctionValues@@V?$allocator@UFunctionValues@@@std@@@std@@IAEXPAUFunctionValues@@0@Z ; std::vector<FunctionValues,std::allocator<FunctionValues>>::_Destroy(FunctionValues *,FunctionValues *)
.text$mn:00007098                 mov     eax, [ebp+var_18]
.text$mn:0000709B                 mov     ecx, [ebp+var_18]
.text$mn:0000709E                 mov     edx, [eax+0Ch]
.text$mn:000070A1                 sub     edx, [ecx+4]
.text$mn:000070A4                 sar     edx, 4
.text$mn:000070A7                 push    edx             ; int
.text$mn:000070A8                 mov     eax, [ebp+var_18]
.text$mn:000070AB                 mov     ecx, [eax+4]
.text$mn:000070AE                 push    ecx             ; void *
.text$mn:000070AF                 lea     edx, [ebp+var_13]
.text$mn:000070B2                 push    edx
.text$mn:000070B3                 mov     ecx, [ebp+var_18]
.text$mn:000070B6                 call    ?_Getal@?$_Vector_alloc@$0A@U?$_Vec_base_types@UFunctionValues@@V?$allocator@UFunctionValues@@@std@@@std@@@std@@QBE?AU?$_Wrap_alloc@V?$allocator@UFunctionValues@@@std@@@2@XZ ; std::_Vector_alloc<0,std::_Vec_base_types<FunctionValues,std::allocator<FunctionValues>>>::_Getal(void)
.text$mn:000070BB                 mov     ecx, eax
.text$mn:000070BD                 call    ?deallocate@?$_Wrap_alloc@V?$allocator@UFunctionValues@@@std@@@std@@QAEXPAUFunctionValues@@I@Z ; std::_Wrap_alloc<std::allocator<FunctionValues>>::deallocate(FunctionValues *,uint)
.text$mn:000070C2
.text$mn:000070C2 loc_70C2:                               ; CODE XREF: std::vector<FunctionValues,std::allocator<FunctionValues>>::_Reallocate(uint)+B8j
.text$mn:000070C2                 mov     ecx, [ebp+var_18] ; this
.text$mn:000070C5                 call    ?_Orphan_all@_Container_base12@std@@QAEXXZ ; std::_Container_base12::_Orphan_all(void)
.text$mn:000070CA                 mov     eax, [ebp+arg_0]
.text$mn:000070CD                 shl     eax, 4
.text$mn:000070D0                 add     eax, [ebp+var_1C]
.text$mn:000070D3                 mov     ecx, [ebp+var_18]
.text$mn:000070D6                 mov     [ecx+0Ch], eax
.text$mn:000070D9                 mov     edx, [ebp+var_20]
.text$mn:000070DC                 shl     edx, 4
.text$mn:000070DF                 add     edx, [ebp+var_1C]
.text$mn:000070E2                 mov     eax, [ebp+var_18]
.text$mn:000070E5                 mov     [eax+8], edx
.text$mn:000070E8                 mov     ecx, [ebp+var_18]
.text$mn:000070EB                 mov     edx, [ebp+var_1C]
.text$mn:000070EE                 mov     [ecx+4], edx
.text$mn:000070F1                 mov     ecx, [ebp+var_C]
.text$mn:000070F4                 mov     large fs:0, ecx
.text$mn:000070FB                 pop     ecx
.text$mn:000070FC                 pop     edi
.text$mn:000070FD                 pop     esi
.text$mn:000070FE                 pop     ebx
.text$mn:000070FF                 mov     esp, ebp
.text$mn:00007101                 pop     ebp
.text$mn:00007102                 retn    4
.text$mn:00007102 ; END OF FUNCTION CHUNK FOR ?_Reallocate@?$vector@UFunctionValues@@V?$allocator@UFunctionValues@@@std@@@std@@IAEXI@Z
.text$mn:00007102 ; ---------------------------------------------------------------------------
.text$mn:00007105                 align 4
.text$mn:00007105 _text$mn        ends
.text$mn:00007105
.text$x:00007108 ; ===========================================================================
.text$x:00007108
.text$x:00007108 ; Segment type: Pure code
.text$x:00007108 ; Segment permissions: Read/Execute
.text$x:00007108 _text$x         segment para public 'CODE' use32
.text$x:00007108                 assume cs:_text$x
.text$x:00007108                 ;org 7108h
.text$x:00007108 ; COMDAT (pick associative to section at 6FC8)
.text$x:00007108                 assume es:nothing, ss:nothing, ds:_data, fs:nothing, gs:nothing
.text$x:00007108
.text$x:00007108 ; =============== S U B R O U T I N E =======================================
.text$x:00007108
.text$x:00007108
.text$x:00007108 __ehhandler$?_Reallocate@?$vector@UFunctionValues@@V?$allocator@UFunctionValues@@@std@@@std@@IAEXI@Z proc near
.text$x:00007108                                         ; DATA XREF: std::vector<FunctionValues,std::allocator<FunctionValues>>::_Reallocate(uint)+5o
.text$x:00007108
.text$x:00007108 arg_4           = dword ptr  8
.text$x:00007108
.text$x:00007108                 mov     edx, [esp+arg_4]
.text$x:0000710C                 lea     eax, [edx+0Ch]
.text$x:0000710F                 mov     ecx, [edx-24h]
.text$x:00007112                 xor     ecx, eax
.text$x:00007114                 call    @__security_check_cookie@4 ; __security_check_cookie(x)
.text$x:00007119                 mov     eax, offset __ehfuncinfo$?_Reallocate@?$vector@UFunctionValues@@V?$allocator@UFunctionValues@@@std@@@std@@IAEXI@Z
.text$x:0000711E                 jmp     ___CxxFrameHandler3
.text$x:0000711E __ehhandler$?_Reallocate@?$vector@UFunctionValues@@V?$allocator@UFunctionValues@@@std@@@std@@IAEXI@Z endp
.text$x:0000711E
.text$x:0000711E ; ---------------------------------------------------------------------------
.text$x:00007123                 align 4
.text$x:00007123 _text$x         ends
.text$x:00007123
.text$mn:00007124 ; ===========================================================================
.text$mn:00007124
.text$mn:00007124 ; Segment type: Pure code
.text$mn:00007124 ; Segment permissions: Read/Execute
.text$mn:00007124 _text$mn        segment para public 'CODE' use32
.text$mn:00007124                 assume cs:_text$mn
.text$mn:00007124                 ;org 7124h
.text$mn:00007124 ; COMDAT (pick any)
.text$mn:00007124                 assume es:nothing, ss:nothing, ds:_data, fs:nothing, gs:nothing
.text$mn:00007124
.text$mn:00007124 ; =============== S U B R O U T I N E =======================================
.text$mn:00007124
.text$mn:00007124 ; Attributes: bp-based frame
.text$mn:00007124
.text$mn:00007124 ; protected: void __thiscall std::vector<struct Token, class std::allocator<struct Token>>::_Reallocate(unsigned int)
.text$mn:00007124                 public ?_Reallocate@?$vector@UToken@@V?$allocator@UToken@@@std@@@std@@IAEXI@Z
.text$mn:00007124 ?_Reallocate@?$vector@UToken@@V?$allocator@UToken@@@std@@@std@@IAEXI@Z proc near
.text$mn:00007124                                         ; CODE XREF: std::vector<Token,std::allocator<Token>>::_Reserve(uint)+4Ep
.text$mn:00007124
.text$mn:00007124 var_20          = dword ptr -20h
.text$mn:00007124 var_1C          = dword ptr -1Ch
.text$mn:00007124 var_18          = dword ptr -18h
.text$mn:00007124 var_13          = byte ptr -13h
.text$mn:00007124 var_11          = byte ptr -11h
.text$mn:00007124 var_10          = dword ptr -10h
.text$mn:00007124 var_C           = dword ptr -0Ch
.text$mn:00007124 var_4           = dword ptr -4
.text$mn:00007124 arg_0           = dword ptr  8
.text$mn:00007124
.text$mn:00007124 ; FUNCTION CHUNK AT .text$mn:000071BA SIZE 00000009 BYTES
.text$mn:00007124 ; FUNCTION CHUNK AT .text$mn:000071CA SIZE 00000098 BYTES
.text$mn:00007124
.text$mn:00007124                 push    ebp
.text$mn:00007125                 mov     ebp, esp
.text$mn:00007127                 push    0FFFFFFFFh
.text$mn:00007129                 push    offset __ehhandler$?_Reallocate@?$vector@UToken@@V?$allocator@UToken@@@std@@@std@@IAEXI@Z
.text$mn:0000712E                 mov     eax, large fs:0
.text$mn:00007134                 push    eax
.text$mn:00007135                 push    ecx
.text$mn:00007136                 sub     esp, 10h
.text$mn:00007139                 push    ebx
.text$mn:0000713A                 push    esi
.text$mn:0000713B                 push    edi
.text$mn:0000713C                 mov     eax, dword ptr ds:___security_cookie
.text$mn:00007141                 xor     eax, ebp
.text$mn:00007143                 push    eax
.text$mn:00007144                 lea     eax, [ebp+var_C]
.text$mn:00007147                 mov     large fs:0, eax
.text$mn:0000714D                 mov     [ebp+var_10], esp
.text$mn:00007150                 mov     [ebp+var_18], ecx
.text$mn:00007153                 mov     eax, [ebp+arg_0]
.text$mn:00007156                 push    eax
.text$mn:00007157                 lea     ecx, [ebp+var_11]
.text$mn:0000715A                 push    ecx
.text$mn:0000715B                 mov     ecx, [ebp+var_18]
.text$mn:0000715E                 call    ?_Getal@?$_Vector_alloc@$0A@U?$_Vec_base_types@UToken@@V?$allocator@UToken@@@std@@@std@@@std@@QBE?AU?$_Wrap_alloc@V?$allocator@UToken@@@std@@@2@XZ ; std::_Vector_alloc<0,std::_Vec_base_types<Token,std::allocator<Token>>>::_Getal(void)
.text$mn:00007163                 mov     ecx, eax
.text$mn:00007165                 call    ?allocate@?$_Wrap_alloc@V?$allocator@UToken@@@std@@@std@@QAEPAUToken@@I@Z ; std::_Wrap_alloc<std::allocator<Token>>::allocate(uint)
.text$mn:0000716A                 mov     [ebp+var_1C], eax
.text$mn:0000716D                 mov     [ebp+var_4], 0
.text$mn:00007174                 mov     edx, [ebp+var_1C]
.text$mn:00007177                 push    edx
.text$mn:00007178                 mov     eax, [ebp+var_18]
.text$mn:0000717B                 mov     ecx, [eax+8]
.text$mn:0000717E                 push    ecx
.text$mn:0000717F                 mov     edx, [ebp+var_18]
.text$mn:00007182                 mov     eax, [edx+4]
.text$mn:00007185                 push    eax
.text$mn:00007186                 mov     ecx, [ebp+var_18]
.text$mn:00007189                 call    ??$_Umove@PAUToken@@@?$vector@UToken@@V?$allocator@UToken@@@std@@@std@@IAEPAUToken@@PAU2@00@Z ; std::vector<Token,std::allocator<Token>>::_Umove<Token *>(Token *,Token *,Token *)
.text$mn:0000718E                 jmp     short loc_71BA
.text$mn:0000718E ?_Reallocate@?$vector@UToken@@V?$allocator@UToken@@@std@@@std@@IAEXI@Z endp
.text$mn:0000718E
.text$mn:00007190
.text$mn:00007190 ; =============== S U B R O U T I N E =======================================
.text$mn:00007190
.text$mn:00007190 ; Attributes: noreturn
.text$mn:00007190
.text$mn:00007190 __catch$?_Reallocate@?$vector@UToken@@V?$allocator@UToken@@@std@@@std@@IAEXI@Z$0 proc near
.text$mn:00007190                                         ; DATA XREF: .xdata$x:00009AC8o
.text$mn:00007190                 mov     ecx, [ebp+8]
.text$mn:00007193                 push    ecx             ; int
.text$mn:00007194                 mov     edx, [ebp-1Ch]
.text$mn:00007197                 push    edx             ; void *
.text$mn:00007198                 lea     eax, [ebp-12h]
.text$mn:0000719B                 push    eax
.text$mn:0000719C                 mov     ecx, [ebp-18h]
.text$mn:0000719F                 call    ?_Getal@?$_Vector_alloc@$0A@U?$_Vec_base_types@UToken@@V?$allocator@UToken@@@std@@@std@@@std@@QBE?AU?$_Wrap_alloc@V?$allocator@UToken@@@std@@@2@XZ ; std::_Vector_alloc<0,std::_Vec_base_types<Token,std::allocator<Token>>>::_Getal(void)
.text$mn:000071A4                 mov     ecx, eax
.text$mn:000071A6                 call    ?deallocate@?$_Wrap_alloc@V?$allocator@UToken@@@std@@@std@@QAEXPAUToken@@I@Z ; std::_Wrap_alloc<std::allocator<Token>>::deallocate(Token *,uint)
.text$mn:000071AB                 push    0
.text$mn:000071AD                 push    0
.text$mn:000071AF                 call    __CxxThrowException@8 ; _CxxThrowException(x,x)
.text$mn:000071AF __catch$?_Reallocate@?$vector@UToken@@V?$allocator@UToken@@@std@@@std@@IAEXI@Z$0 endp
.text$mn:000071AF
.text$mn:000071B4 ; ---------------------------------------------------------------------------
.text$mn:000071B4                 mov     eax, offset $LN8_1
.text$mn:000071B9                 retn
.text$mn:000071BA ; ---------------------------------------------------------------------------
.text$mn:000071BA ; START OF FUNCTION CHUNK FOR ?_Reallocate@?$vector@UToken@@V?$allocator@UToken@@@std@@@std@@IAEXI@Z
.text$mn:000071BA
.text$mn:000071BA loc_71BA:                               ; CODE XREF: std::vector<Token,std::allocator<Token>>::_Reallocate(uint)+6Aj
.text$mn:000071BA                 mov     [ebp+var_4], 0FFFFFFFFh
.text$mn:000071C1                 jmp     short loc_71CA
.text$mn:000071C1 ; END OF FUNCTION CHUNK FOR ?_Reallocate@?$vector@UToken@@V?$allocator@UToken@@@std@@@std@@IAEXI@Z
.text$mn:000071C3
.text$mn:000071C3 ; =============== S U B R O U T I N E =======================================
.text$mn:000071C3
.text$mn:000071C3
.text$mn:000071C3 $LN8_1          proc near               ; DATA XREF: .text$mn:000071B4o
.text$mn:000071C3                 mov     dword ptr [ebp-4], 0FFFFFFFFh
.text$mn:000071C3 $LN8_1          endp ; sp-analysis failed
.text$mn:000071C3
.text$mn:000071CA ; START OF FUNCTION CHUNK FOR ?_Reallocate@?$vector@UToken@@V?$allocator@UToken@@@std@@@std@@IAEXI@Z
.text$mn:000071CA
.text$mn:000071CA loc_71CA:                               ; CODE XREF: std::vector<Token,std::allocator<Token>>::_Reallocate(uint)+9Dj
.text$mn:000071CA                 mov     ecx, [ebp+var_18]
.text$mn:000071CD                 call    ?size@?$vector@UToken@@V?$allocator@UToken@@@std@@@std@@QBEIXZ ; std::vector<Token,std::allocator<Token>>::size(void)
.text$mn:000071D2                 mov     [ebp+var_20], eax
.text$mn:000071D5                 mov     ecx, [ebp+var_18]
.text$mn:000071D8                 cmp     dword ptr [ecx+4], 0
.text$mn:000071DC                 jz      short loc_7223
.text$mn:000071DE                 mov     edx, [ebp+var_18]
.text$mn:000071E1                 mov     eax, [edx+8]
.text$mn:000071E4                 push    eax
.text$mn:000071E5                 mov     ecx, [ebp+var_18]
.text$mn:000071E8                 mov     edx, [ecx+4]
.text$mn:000071EB                 push    edx
.text$mn:000071EC                 mov     ecx, [ebp+var_18]
.text$mn:000071EF                 call    ?_Destroy@?$vector@UToken@@V?$allocator@UToken@@@std@@@std@@IAEXPAUToken@@0@Z ; std::vector<Token,std::allocator<Token>>::_Destroy(Token *,Token *)
.text$mn:000071F4                 mov     eax, [ebp+var_18]
.text$mn:000071F7                 mov     ecx, [ebp+var_18]
.text$mn:000071FA                 mov     eax, [eax+0Ch]
.text$mn:000071FD                 sub     eax, [ecx+4]
.text$mn:00007200                 cdq
.text$mn:00007201                 mov     ecx, 0Ch
.text$mn:00007206                 idiv    ecx
.text$mn:00007208                 push    eax             ; int
.text$mn:00007209                 mov     edx, [ebp+var_18]
.text$mn:0000720C                 mov     eax, [edx+4]
.text$mn:0000720F                 push    eax             ; void *
.text$mn:00007210                 lea     ecx, [ebp+var_13]
.text$mn:00007213                 push    ecx
.text$mn:00007214                 mov     ecx, [ebp+var_18]
.text$mn:00007217                 call    ?_Getal@?$_Vector_alloc@$0A@U?$_Vec_base_types@UToken@@V?$allocator@UToken@@@std@@@std@@@std@@QBE?AU?$_Wrap_alloc@V?$allocator@UToken@@@std@@@2@XZ ; std::_Vector_alloc<0,std::_Vec_base_types<Token,std::allocator<Token>>>::_Getal(void)
.text$mn:0000721C                 mov     ecx, eax
.text$mn:0000721E                 call    ?deallocate@?$_Wrap_alloc@V?$allocator@UToken@@@std@@@std@@QAEXPAUToken@@I@Z ; std::_Wrap_alloc<std::allocator<Token>>::deallocate(Token *,uint)
.text$mn:00007223
.text$mn:00007223 loc_7223:                               ; CODE XREF: std::vector<Token,std::allocator<Token>>::_Reallocate(uint)+B8j
.text$mn:00007223                 mov     ecx, [ebp+var_18] ; this
.text$mn:00007226                 call    ?_Orphan_all@_Container_base12@std@@QAEXXZ ; std::_Container_base12::_Orphan_all(void)
.text$mn:0000722B                 imul    edx, [ebp+arg_0], 0Ch
.text$mn:0000722F                 add     edx, [ebp+var_1C]
.text$mn:00007232                 mov     eax, [ebp+var_18]
.text$mn:00007235                 mov     [eax+0Ch], edx
.text$mn:00007238                 imul    ecx, [ebp+var_20], 0Ch
.text$mn:0000723C                 add     ecx, [ebp+var_1C]
.text$mn:0000723F                 mov     edx, [ebp+var_18]
.text$mn:00007242                 mov     [edx+8], ecx
.text$mn:00007245                 mov     eax, [ebp+var_18]
.text$mn:00007248                 mov     ecx, [ebp+var_1C]
.text$mn:0000724B                 mov     [eax+4], ecx
.text$mn:0000724E                 mov     ecx, [ebp+var_C]
.text$mn:00007251                 mov     large fs:0, ecx
.text$mn:00007258                 pop     ecx
.text$mn:00007259                 pop     edi
.text$mn:0000725A                 pop     esi
.text$mn:0000725B                 pop     ebx
.text$mn:0000725C                 mov     esp, ebp
.text$mn:0000725E                 pop     ebp
.text$mn:0000725F                 retn    4
.text$mn:0000725F ; END OF FUNCTION CHUNK FOR ?_Reallocate@?$vector@UToken@@V?$allocator@UToken@@@std@@@std@@IAEXI@Z
.text$mn:0000725F ; ---------------------------------------------------------------------------
.text$mn:00007262                 align 4
.text$mn:00007262 _text$mn        ends
.text$mn:00007262
.text$x:00007264 ; ===========================================================================
.text$x:00007264
.text$x:00007264 ; Segment type: Pure code
.text$x:00007264 ; Segment permissions: Read/Execute
.text$x:00007264 _text$x         segment para public 'CODE' use32
.text$x:00007264                 assume cs:_text$x
.text$x:00007264                 ;org 7264h
.text$x:00007264 ; COMDAT (pick associative to section at 7124)
.text$x:00007264                 assume es:nothing, ss:nothing, ds:_data, fs:nothing, gs:nothing
.text$x:00007264
.text$x:00007264 ; =============== S U B R O U T I N E =======================================
.text$x:00007264
.text$x:00007264
.text$x:00007264 __ehhandler$?_Reallocate@?$vector@UToken@@V?$allocator@UToken@@@std@@@std@@IAEXI@Z proc near
.text$x:00007264                                         ; DATA XREF: std::vector<Token,std::allocator<Token>>::_Reallocate(uint)+5o
.text$x:00007264
.text$x:00007264 arg_4           = dword ptr  8
.text$x:00007264
.text$x:00007264                 mov     edx, [esp+arg_4]
.text$x:00007268                 lea     eax, [edx+0Ch]
.text$x:0000726B                 mov     ecx, [edx-24h]
.text$x:0000726E                 xor     ecx, eax
.text$x:00007270                 call    @__security_check_cookie@4 ; __security_check_cookie(x)
.text$x:00007275                 mov     eax, offset __ehfuncinfo$?_Reallocate@?$vector@UToken@@V?$allocator@UToken@@@std@@@std@@IAEXI@Z
.text$x:0000727A                 jmp     ___CxxFrameHandler3
.text$x:0000727A __ehhandler$?_Reallocate@?$vector@UToken@@V?$allocator@UToken@@@std@@@std@@IAEXI@Z endp
.text$x:0000727A
.text$x:0000727A ; ---------------------------------------------------------------------------
.text$x:0000727F                 align 10h
.text$x:0000727F _text$x         ends
.text$x:0000727F
.text$mn:00007280 ; ===========================================================================
.text$mn:00007280
.text$mn:00007280 ; Segment type: Pure code
.text$mn:00007280 ; Segment permissions: Read/Execute
.text$mn:00007280 _text$mn        segment para public 'CODE' use32
.text$mn:00007280                 assume cs:_text$mn
.text$mn:00007280                 ;org 7280h
.text$mn:00007280 ; COMDAT (pick any)
.text$mn:00007280                 assume es:nothing, ss:nothing, ds:_data, fs:nothing, gs:nothing
.text$mn:00007280
.text$mn:00007280 ; =============== S U B R O U T I N E =======================================
.text$mn:00007280
.text$mn:00007280 ; Attributes: bp-based frame
.text$mn:00007280
.text$mn:00007280 ; protected: void __thiscall std::vector<class std::vector<wchar_t const *, class std::allocator<wchar_t const *>>, class std::allocator<class std::vector<wchar_t const *, class std::allocator<wchar_t const *>>>>::_Reallocate(unsigned int)
.text$mn:00007280                 public ?_Reallocate@?$vector@V?$vector@PB_WV?$allocator@PB_W@std@@@std@@V?$allocator@V?$vector@PB_WV?$allocator@PB_W@std@@@std@@@2@@std@@IAEXI@Z
.text$mn:00007280 ?_Reallocate@?$vector@V?$vector@PB_WV?$allocator@PB_W@std@@@std@@V?$allocator@V?$vector@PB_WV?$allocator@PB_W@std@@@std@@@2@@std@@IAEXI@Z proc near
.text$mn:00007280                                         ; CODE XREF: std::vector<std::vector<wchar_t const *,std::allocator<wchar_t const *>>,std::allocator<std::vector<wchar_t const *,std::allocator<wchar_t const *>>>>::_Reserve(uint)+4Ep
.text$mn:00007280
.text$mn:00007280 var_20          = dword ptr -20h
.text$mn:00007280 var_1C          = dword ptr -1Ch
.text$mn:00007280 var_18          = dword ptr -18h
.text$mn:00007280 var_13          = byte ptr -13h
.text$mn:00007280 var_11          = byte ptr -11h
.text$mn:00007280 var_10          = dword ptr -10h
.text$mn:00007280 var_C           = dword ptr -0Ch
.text$mn:00007280 var_4           = dword ptr -4
.text$mn:00007280 arg_0           = dword ptr  8
.text$mn:00007280
.text$mn:00007280 ; FUNCTION CHUNK AT .text$mn:00007316 SIZE 00000009 BYTES
.text$mn:00007280 ; FUNCTION CHUNK AT .text$mn:00007326 SIZE 00000097 BYTES
.text$mn:00007280
.text$mn:00007280                 push    ebp
.text$mn:00007281                 mov     ebp, esp
.text$mn:00007283                 push    0FFFFFFFFh
.text$mn:00007285                 push    offset __ehhandler$?_Reallocate@?$vector@V?$vector@PB_WV?$allocator@PB_W@std@@@std@@V?$allocator@V?$vector@PB_WV?$allocator@PB_W@std@@@std@@@2@@std@@IAEXI@Z
.text$mn:0000728A                 mov     eax, large fs:0
.text$mn:00007290                 push    eax
.text$mn:00007291                 push    ecx
.text$mn:00007292                 sub     esp, 10h
.text$mn:00007295                 push    ebx
.text$mn:00007296                 push    esi
.text$mn:00007297                 push    edi
.text$mn:00007298                 mov     eax, dword ptr ds:___security_cookie
.text$mn:0000729D                 xor     eax, ebp
.text$mn:0000729F                 push    eax
.text$mn:000072A0                 lea     eax, [ebp+var_C]
.text$mn:000072A3                 mov     large fs:0, eax
.text$mn:000072A9                 mov     [ebp+var_10], esp
.text$mn:000072AC                 mov     [ebp+var_18], ecx
.text$mn:000072AF                 mov     eax, [ebp+arg_0]
.text$mn:000072B2                 push    eax
.text$mn:000072B3                 lea     ecx, [ebp+var_11]
.text$mn:000072B6                 push    ecx
.text$mn:000072B7                 mov     ecx, [ebp+var_18]
.text$mn:000072BA                 call    ?_Getal@?$_Vector_alloc@$0A@U?$_Vec_base_types@V?$vector@PB_WV?$allocator@PB_W@std@@@std@@V?$allocator@V?$vector@PB_WV?$allocator@PB_W@std@@@std@@@2@@std@@@std@@QBE?AU?$_Wrap_alloc@V?$allocator@V?$vector@PB_WV?$allocator@PB_W@std@@@std@@@std@@@2@XZ ; std::_Vector_alloc<0,std::_Vec_base_types<std::vector<wchar_t const *,std::allocator<wchar_t const *>>,std::allocator<std::vector<wchar_t const *,std::allocator<wchar_t const *>>>>>::_Getal(void)
.text$mn:000072BF                 mov     ecx, eax
.text$mn:000072C1                 call    ?allocate@?$_Wrap_alloc@V?$allocator@V?$vector@PB_WV?$allocator@PB_W@std@@@std@@@std@@@std@@QAEPAV?$vector@PB_WV?$allocator@PB_W@std@@@2@I@Z ; std::_Wrap_alloc<std::allocator<std::vector<wchar_t const *,std::allocator<wchar_t const *>>>>::allocate(uint)
.text$mn:000072C6                 mov     [ebp+var_1C], eax
.text$mn:000072C9                 mov     [ebp+var_4], 0
.text$mn:000072D0                 mov     edx, [ebp+var_1C]
.text$mn:000072D3                 push    edx
.text$mn:000072D4                 mov     eax, [ebp+var_18]
.text$mn:000072D7                 mov     ecx, [eax+8]
.text$mn:000072DA                 push    ecx
.text$mn:000072DB                 mov     edx, [ebp+var_18]
.text$mn:000072DE                 mov     eax, [edx+4]
.text$mn:000072E1                 push    eax
.text$mn:000072E2                 mov     ecx, [ebp+var_18]
.text$mn:000072E5                 call    ??$_Umove@PAV?$vector@PB_WV?$allocator@PB_W@std@@@std@@@?$vector@V?$vector@PB_WV?$allocator@PB_W@std@@@std@@V?$allocator@V?$vector@PB_WV?$allocator@PB_W@std@@@std@@@2@@std@@IAEPAV?$vector@PB_WV?$allocator@PB_W@std@@@1@PAV21@00@Z ; std::vector<std::vector<wchar_t const *,std::allocator<wchar_t const *>>,std::allocator<std::vector<wchar_t const *,std::allocator<wchar_t const *>>>>::_Umove<std::vector<wchar_t const *,std::allocator<wchar_t const *>> *>(std::vector<wchar_t const *,std::allocator<wchar_t const *>> *,std::vector<wchar_t const *,std::allocator<wchar_t const *>> *,std::vector<wchar_t const *,std::allocator<wchar_t const *>> *)
.text$mn:000072EA                 jmp     short loc_7316
.text$mn:000072EA ?_Reallocate@?$vector@V?$vector@PB_WV?$allocator@PB_W@std@@@std@@V?$allocator@V?$vector@PB_WV?$allocator@PB_W@std@@@std@@@2@@std@@IAEXI@Z endp
.text$mn:000072EA
.text$mn:000072EC
.text$mn:000072EC ; =============== S U B R O U T I N E =======================================
.text$mn:000072EC
.text$mn:000072EC ; Attributes: noreturn
.text$mn:000072EC
.text$mn:000072EC __catch$?_Reallocate@?$vector@V?$vector@PB_WV?$allocator@PB_W@std@@@std@@V?$allocator@V?$vector@PB_WV?$allocator@PB_W@std@@@std@@@2@@std@@IAEXI@Z$0 proc near
.text$mn:000072EC                                         ; DATA XREF: .xdata$x:000098DCo
.text$mn:000072EC                 mov     ecx, [ebp+8]
.text$mn:000072EF                 push    ecx             ; int
.text$mn:000072F0                 mov     edx, [ebp-1Ch]
.text$mn:000072F3                 push    edx             ; void *
.text$mn:000072F4                 lea     eax, [ebp-12h]
.text$mn:000072F7                 push    eax
.text$mn:000072F8                 mov     ecx, [ebp-18h]
.text$mn:000072FB                 call    ?_Getal@?$_Vector_alloc@$0A@U?$_Vec_base_types@V?$vector@PB_WV?$allocator@PB_W@std@@@std@@V?$allocator@V?$vector@PB_WV?$allocator@PB_W@std@@@std@@@2@@std@@@std@@QBE?AU?$_Wrap_alloc@V?$allocator@V?$vector@PB_WV?$allocator@PB_W@std@@@std@@@std@@@2@XZ ; std::_Vector_alloc<0,std::_Vec_base_types<std::vector<wchar_t const *,std::allocator<wchar_t const *>>,std::allocator<std::vector<wchar_t const *,std::allocator<wchar_t const *>>>>>::_Getal(void)
.text$mn:00007300                 mov     ecx, eax
.text$mn:00007302                 call    ?deallocate@?$_Wrap_alloc@V?$allocator@V?$vector@PB_WV?$allocator@PB_W@std@@@std@@@std@@@std@@QAEXPAV?$vector@PB_WV?$allocator@PB_W@std@@@2@I@Z ; std::_Wrap_alloc<std::allocator<std::vector<wchar_t const *,std::allocator<wchar_t const *>>>>::deallocate(std::vector<wchar_t const *,std::allocator<wchar_t const *>> *,uint)
.text$mn:00007307                 push    0
.text$mn:00007309                 push    0
.text$mn:0000730B                 call    __CxxThrowException@8 ; _CxxThrowException(x,x)
.text$mn:0000730B __catch$?_Reallocate@?$vector@V?$vector@PB_WV?$allocator@PB_W@std@@@std@@V?$allocator@V?$vector@PB_WV?$allocator@PB_W@std@@@std@@@2@@std@@IAEXI@Z$0 endp
.text$mn:0000730B
.text$mn:00007310 ; ---------------------------------------------------------------------------
.text$mn:00007310                 mov     eax, offset $LN8_0
.text$mn:00007315                 retn
.text$mn:00007316 ; ---------------------------------------------------------------------------
.text$mn:00007316 ; START OF FUNCTION CHUNK FOR ?_Reallocate@?$vector@V?$vector@PB_WV?$allocator@PB_W@std@@@std@@V?$allocator@V?$vector@PB_WV?$allocator@PB_W@std@@@std@@@2@@std@@IAEXI@Z
.text$mn:00007316
.text$mn:00007316 loc_7316:                               ; CODE XREF: std::vector<std::vector<wchar_t const *,std::allocator<wchar_t const *>>,std::allocator<std::vector<wchar_t const *,std::allocator<wchar_t const *>>>>::_Reallocate(uint)+6Aj
.text$mn:00007316                 mov     [ebp+var_4], 0FFFFFFFFh
.text$mn:0000731D                 jmp     short loc_7326
.text$mn:0000731D ; END OF FUNCTION CHUNK FOR ?_Reallocate@?$vector@V?$vector@PB_WV?$allocator@PB_W@std@@@std@@V?$allocator@V?$vector@PB_WV?$allocator@PB_W@std@@@std@@@2@@std@@IAEXI@Z
.text$mn:0000731F
.text$mn:0000731F ; =============== S U B R O U T I N E =======================================
.text$mn:0000731F
.text$mn:0000731F
.text$mn:0000731F $LN8_0          proc near               ; DATA XREF: .text$mn:00007310o
.text$mn:0000731F                 mov     dword ptr [ebp-4], 0FFFFFFFFh
.text$mn:0000731F $LN8_0          endp ; sp-analysis failed
.text$mn:0000731F
.text$mn:00007326 ; START OF FUNCTION CHUNK FOR ?_Reallocate@?$vector@V?$vector@PB_WV?$allocator@PB_W@std@@@std@@V?$allocator@V?$vector@PB_WV?$allocator@PB_W@std@@@std@@@2@@std@@IAEXI@Z
.text$mn:00007326
.text$mn:00007326 loc_7326:                               ; CODE XREF: std::vector<std::vector<wchar_t const *,std::allocator<wchar_t const *>>,std::allocator<std::vector<wchar_t const *,std::allocator<wchar_t const *>>>>::_Reallocate(uint)+9Dj
.text$mn:00007326                 mov     ecx, [ebp+var_18]
.text$mn:00007329                 call    ?size@?$vector@V?$vector@PB_WV?$allocator@PB_W@std@@@std@@V?$allocator@V?$vector@PB_WV?$allocator@PB_W@std@@@std@@@2@@std@@QBEIXZ ; std::vector<std::vector<wchar_t const *,std::allocator<wchar_t const *>>,std::allocator<std::vector<wchar_t const *,std::allocator<wchar_t const *>>>>::size(void)
.text$mn:0000732E                 mov     [ebp+var_20], eax
.text$mn:00007331                 mov     ecx, [ebp+var_18]
.text$mn:00007334                 cmp     dword ptr [ecx+4], 0
.text$mn:00007338                 jz      short loc_737A
.text$mn:0000733A                 mov     edx, [ebp+var_18]
.text$mn:0000733D                 mov     eax, [edx+8]
.text$mn:00007340                 push    eax
.text$mn:00007341                 mov     ecx, [ebp+var_18]
.text$mn:00007344                 mov     edx, [ecx+4]
.text$mn:00007347                 push    edx
.text$mn:00007348                 mov     ecx, [ebp+var_18]
.text$mn:0000734B                 call    ?_Destroy@?$vector@V?$vector@PB_WV?$allocator@PB_W@std@@@std@@V?$allocator@V?$vector@PB_WV?$allocator@PB_W@std@@@std@@@2@@std@@IAEXPAV?$vector@PB_WV?$allocator@PB_W@std@@@2@0@Z ; std::vector<std::vector<wchar_t const *,std::allocator<wchar_t const *>>,std::allocator<std::vector<wchar_t const *,std::allocator<wchar_t const *>>>>::_Destroy(std::vector<wchar_t const *,std::allocator<wchar_t const *>> *,std::vector<wchar_t const *,std::allocator<wchar_t const *>> *)
.text$mn:00007350                 mov     eax, [ebp+var_18]
.text$mn:00007353                 mov     ecx, [ebp+var_18]
.text$mn:00007356                 mov     edx, [eax+0Ch]
.text$mn:00007359                 sub     edx, [ecx+4]
.text$mn:0000735C                 sar     edx, 4
.text$mn:0000735F                 push    edx             ; int
.text$mn:00007360                 mov     eax, [ebp+var_18]
.text$mn:00007363                 mov     ecx, [eax+4]
.text$mn:00007366                 push    ecx             ; void *
.text$mn:00007367                 lea     edx, [ebp+var_13]
.text$mn:0000736A                 push    edx
.text$mn:0000736B                 mov     ecx, [ebp+var_18]
.text$mn:0000736E                 call    ?_Getal@?$_Vector_alloc@$0A@U?$_Vec_base_types@V?$vector@PB_WV?$allocator@PB_W@std@@@std@@V?$allocator@V?$vector@PB_WV?$allocator@PB_W@std@@@std@@@2@@std@@@std@@QBE?AU?$_Wrap_alloc@V?$allocator@V?$vector@PB_WV?$allocator@PB_W@std@@@std@@@std@@@2@XZ ; std::_Vector_alloc<0,std::_Vec_base_types<std::vector<wchar_t const *,std::allocator<wchar_t const *>>,std::allocator<std::vector<wchar_t const *,std::allocator<wchar_t const *>>>>>::_Getal(void)
.text$mn:00007373                 mov     ecx, eax
.text$mn:00007375                 call    ?deallocate@?$_Wrap_alloc@V?$allocator@V?$vector@PB_WV?$allocator@PB_W@std@@@std@@@std@@@std@@QAEXPAV?$vector@PB_WV?$allocator@PB_W@std@@@2@I@Z ; std::_Wrap_alloc<std::allocator<std::vector<wchar_t const *,std::allocator<wchar_t const *>>>>::deallocate(std::vector<wchar_t const *,std::allocator<wchar_t const *>> *,uint)
.text$mn:0000737A
.text$mn:0000737A loc_737A:                               ; CODE XREF: std::vector<std::vector<wchar_t const *,std::allocator<wchar_t const *>>,std::allocator<std::vector<wchar_t const *,std::allocator<wchar_t const *>>>>::_Reallocate(uint)+B8j
.text$mn:0000737A                 mov     ecx, [ebp+var_18] ; this
.text$mn:0000737D                 call    ?_Orphan_all@_Container_base12@std@@QAEXXZ ; std::_Container_base12::_Orphan_all(void)
.text$mn:00007382                 mov     eax, [ebp+arg_0]
.text$mn:00007385                 shl     eax, 4
.text$mn:00007388                 add     eax, [ebp+var_1C]
.text$mn:0000738B                 mov     ecx, [ebp+var_18]
.text$mn:0000738E                 mov     [ecx+0Ch], eax
.text$mn:00007391                 mov     edx, [ebp+var_20]
.text$mn:00007394                 shl     edx, 4
.text$mn:00007397                 add     edx, [ebp+var_1C]
.text$mn:0000739A                 mov     eax, [ebp+var_18]
.text$mn:0000739D                 mov     [eax+8], edx
.text$mn:000073A0                 mov     ecx, [ebp+var_18]
.text$mn:000073A3                 mov     edx, [ebp+var_1C]
.text$mn:000073A6                 mov     [ecx+4], edx
.text$mn:000073A9                 mov     ecx, [ebp+var_C]
.text$mn:000073AC                 mov     large fs:0, ecx
.text$mn:000073B3                 pop     ecx
.text$mn:000073B4                 pop     edi
.text$mn:000073B5                 pop     esi
.text$mn:000073B6                 pop     ebx
.text$mn:000073B7                 mov     esp, ebp
.text$mn:000073B9                 pop     ebp
.text$mn:000073BA                 retn    4
.text$mn:000073BA ; END OF FUNCTION CHUNK FOR ?_Reallocate@?$vector@V?$vector@PB_WV?$allocator@PB_W@std@@@std@@V?$allocator@V?$vector@PB_WV?$allocator@PB_W@std@@@std@@@2@@std@@IAEXI@Z
.text$mn:000073BA ; ---------------------------------------------------------------------------
.text$mn:000073BD                 align 10h
.text$mn:000073BD _text$mn        ends
.text$mn:000073BD
.text$x:000073C0 ; ===========================================================================
.text$x:000073C0
.text$x:000073C0 ; Segment type: Pure code
.text$x:000073C0 ; Segment permissions: Read/Execute
.text$x:000073C0 _text$x         segment para public 'CODE' use32
.text$x:000073C0                 assume cs:_text$x
.text$x:000073C0                 ;org 73C0h
.text$x:000073C0 ; COMDAT (pick associative to section at 7280)
.text$x:000073C0                 assume es:nothing, ss:nothing, ds:_data, fs:nothing, gs:nothing
.text$x:000073C0
.text$x:000073C0 ; =============== S U B R O U T I N E =======================================
.text$x:000073C0
.text$x:000073C0
.text$x:000073C0 __ehhandler$?_Reallocate@?$vector@V?$vector@PB_WV?$allocator@PB_W@std@@@std@@V?$allocator@V?$vector@PB_WV?$allocator@PB_W@std@@@std@@@2@@std@@IAEXI@Z proc near
.text$x:000073C0                                         ; DATA XREF: std::vector<std::vector<wchar_t const *,std::allocator<wchar_t const *>>,std::allocator<std::vector<wchar_t const *,std::allocator<wchar_t const *>>>>::_Reallocate(uint)+5o
.text$x:000073C0
.text$x:000073C0 arg_4           = dword ptr  8
.text$x:000073C0
.text$x:000073C0                 mov     edx, [esp+arg_4]
.text$x:000073C4                 lea     eax, [edx+0Ch]
.text$x:000073C7                 mov     ecx, [edx-24h]
.text$x:000073CA                 xor     ecx, eax
.text$x:000073CC                 call    @__security_check_cookie@4 ; __security_check_cookie(x)
.text$x:000073D1                 mov     eax, offset __ehfuncinfo$?_Reallocate@?$vector@V?$vector@PB_WV?$allocator@PB_W@std@@@std@@V?$allocator@V?$vector@PB_WV?$allocator@PB_W@std@@@std@@@2@@std@@IAEXI@Z
.text$x:000073D6                 jmp     ___CxxFrameHandler3
.text$x:000073D6 __ehhandler$?_Reallocate@?$vector@V?$vector@PB_WV?$allocator@PB_W@std@@@std@@V?$allocator@V?$vector@PB_WV?$allocator@PB_W@std@@@std@@@2@@std@@IAEXI@Z endp
.text$x:000073D6
.text$x:000073D6 ; ---------------------------------------------------------------------------
.text$x:000073DB                 align 4
.text$x:000073DB _text$x         ends
.text$x:000073DB
.text$mn:000073DC ; ===========================================================================
.text$mn:000073DC
.text$mn:000073DC ; Segment type: Pure code
.text$mn:000073DC ; Segment permissions: Read/Execute
.text$mn:000073DC _text$mn        segment para public 'CODE' use32
.text$mn:000073DC                 assume cs:_text$mn
.text$mn:000073DC                 ;org 73DCh
.text$mn:000073DC ; COMDAT (pick any)
.text$mn:000073DC                 assume es:nothing, ss:nothing, ds:_data, fs:nothing, gs:nothing
.text$mn:000073DC
.text$mn:000073DC ; =============== S U B R O U T I N E =======================================
.text$mn:000073DC
.text$mn:000073DC ; Attributes: bp-based frame
.text$mn:000073DC
.text$mn:000073DC ; protected: void __thiscall std::vector<wchar_t const *, class std::allocator<wchar_t const *>>::_Reserve(unsigned int)
.text$mn:000073DC                 public ?_Reserve@?$vector@PB_WV?$allocator@PB_W@std@@@std@@IAEXI@Z
.text$mn:000073DC ?_Reserve@?$vector@PB_WV?$allocator@PB_W@std@@@std@@IAEXI@Z proc near
.text$mn:000073DC                                         ; CODE XREF: std::vector<wchar_t const *,std::allocator<wchar_t const *>>::push_back(wchar_t const * const &)+50p
.text$mn:000073DC                                         ; std::vector<wchar_t const *,std::allocator<wchar_t const *>>::push_back(wchar_t const * const &)+B6p
.text$mn:000073DC
.text$mn:000073DC var_4           = dword ptr -4
.text$mn:000073DC arg_0           = dword ptr  8
.text$mn:000073DC
.text$mn:000073DC                 push    ebp
.text$mn:000073DD                 mov     ebp, esp
.text$mn:000073DF                 push    ecx
.text$mn:000073E0                 push    esi
.text$mn:000073E1                 mov     [ebp+var_4], ecx
.text$mn:000073E4                 mov     ecx, [ebp+var_4]
.text$mn:000073E7                 call    ?_Unused_capacity@?$vector@PB_WV?$allocator@PB_W@std@@@std@@QBEIXZ ; std::vector<wchar_t const *,std::allocator<wchar_t const *>>::_Unused_capacity(void)
.text$mn:000073EC                 cmp     eax, [ebp+arg_0]
.text$mn:000073EF                 jnb     short loc_742F
.text$mn:000073F1                 mov     ecx, [ebp+var_4]
.text$mn:000073F4                 call    ?max_size@?$vector@PB_WV?$allocator@PB_W@std@@@std@@QBEIXZ ; std::vector<wchar_t const *,std::allocator<wchar_t const *>>::max_size(void)
.text$mn:000073F9                 mov     esi, eax
.text$mn:000073FB                 mov     ecx, [ebp+var_4]
.text$mn:000073FE                 call    ?size@?$vector@PB_WV?$allocator@PB_W@std@@@std@@QBEIXZ ; std::vector<wchar_t const *,std::allocator<wchar_t const *>>::size(void)
.text$mn:00007403                 sub     esi, eax
.text$mn:00007405                 cmp     esi, [ebp+arg_0]
.text$mn:00007408                 jnb     short loc_7412
.text$mn:0000740A                 mov     ecx, [ebp+var_4]
.text$mn:0000740D                 call    ?_Xlen@?$vector@PB_WV?$allocator@PB_W@std@@@std@@IBEXXZ ; std::vector<wchar_t const *,std::allocator<wchar_t const *>>::_Xlen(void)
.text$mn:00007412
.text$mn:00007412 loc_7412:                               ; CODE XREF: std::vector<wchar_t const *,std::allocator<wchar_t const *>>::_Reserve(uint)+2Cj
.text$mn:00007412                 mov     ecx, [ebp+var_4]
.text$mn:00007415                 call    ?size@?$vector@PB_WV?$allocator@PB_W@std@@@std@@QBEIXZ ; std::vector<wchar_t const *,std::allocator<wchar_t const *>>::size(void)
.text$mn:0000741A                 add     eax, [ebp+arg_0]
.text$mn:0000741D                 push    eax
.text$mn:0000741E                 mov     ecx, [ebp+var_4]
.text$mn:00007421                 call    ?_Grow_to@?$vector@PB_WV?$allocator@PB_W@std@@@std@@IBEII@Z ; std::vector<wchar_t const *,std::allocator<wchar_t const *>>::_Grow_to(uint)
.text$mn:00007426                 push    eax
.text$mn:00007427                 mov     ecx, [ebp+var_4]
.text$mn:0000742A                 call    ?_Reallocate@?$vector@PB_WV?$allocator@PB_W@std@@@std@@IAEXI@Z ; std::vector<wchar_t const *,std::allocator<wchar_t const *>>::_Reallocate(uint)
.text$mn:0000742F
.text$mn:0000742F loc_742F:                               ; CODE XREF: std::vector<wchar_t const *,std::allocator<wchar_t const *>>::_Reserve(uint)+13j
.text$mn:0000742F                 pop     esi
.text$mn:00007430                 mov     esp, ebp
.text$mn:00007432                 pop     ebp
.text$mn:00007433                 retn    4
.text$mn:00007433 ?_Reserve@?$vector@PB_WV?$allocator@PB_W@std@@@std@@IAEXI@Z endp
.text$mn:00007433
.text$mn:00007433 ; ---------------------------------------------------------------------------
.text$mn:00007436                 align 4
.text$mn:00007436 _text$mn        ends
.text$mn:00007436
.text$mn:00007438 ; ===========================================================================
.text$mn:00007438
.text$mn:00007438 ; Segment type: Pure code
.text$mn:00007438 ; Segment permissions: Read/Execute
.text$mn:00007438 _text$mn        segment para public 'CODE' use32
.text$mn:00007438                 assume cs:_text$mn
.text$mn:00007438                 ;org 7438h
.text$mn:00007438 ; COMDAT (pick any)
.text$mn:00007438                 assume es:nothing, ss:nothing, ds:_data, fs:nothing, gs:nothing
.text$mn:00007438
.text$mn:00007438 ; =============== S U B R O U T I N E =======================================
.text$mn:00007438
.text$mn:00007438 ; Attributes: bp-based frame
.text$mn:00007438
.text$mn:00007438 ; protected: void __thiscall std::vector<struct FunctionValues, class std::allocator<struct FunctionValues>>::_Reserve(unsigned int)
.text$mn:00007438                 public ?_Reserve@?$vector@UFunctionValues@@V?$allocator@UFunctionValues@@@std@@@std@@IAEXI@Z
.text$mn:00007438 ?_Reserve@?$vector@UFunctionValues@@V?$allocator@UFunctionValues@@@std@@@std@@IAEXI@Z proc near
.text$mn:00007438                                         ; CODE XREF: std::vector<FunctionValues,std::allocator<FunctionValues>>::push_back(FunctionValues const &)+50p
.text$mn:00007438                                         ; std::vector<FunctionValues,std::allocator<FunctionValues>>::push_back(FunctionValues const &)+B6p
.text$mn:00007438
.text$mn:00007438 var_4           = dword ptr -4
.text$mn:00007438 arg_0           = dword ptr  8
.text$mn:00007438
.text$mn:00007438                 push    ebp
.text$mn:00007439                 mov     ebp, esp
.text$mn:0000743B                 push    ecx
.text$mn:0000743C                 push    esi
.text$mn:0000743D                 mov     [ebp+var_4], ecx
.text$mn:00007440                 mov     ecx, [ebp+var_4]
.text$mn:00007443                 call    ?_Unused_capacity@?$vector@UFunctionValues@@V?$allocator@UFunctionValues@@@std@@@std@@QBEIXZ ; std::vector<FunctionValues,std::allocator<FunctionValues>>::_Unused_capacity(void)
.text$mn:00007448                 cmp     eax, [ebp+arg_0]
.text$mn:0000744B                 jnb     short loc_748B
.text$mn:0000744D                 mov     ecx, [ebp+var_4]
.text$mn:00007450                 call    ?max_size@?$vector@UFunctionValues@@V?$allocator@UFunctionValues@@@std@@@std@@QBEIXZ ; std::vector<FunctionValues,std::allocator<FunctionValues>>::max_size(void)
.text$mn:00007455                 mov     esi, eax
.text$mn:00007457                 mov     ecx, [ebp+var_4]
.text$mn:0000745A                 call    ?size@?$vector@UFunctionValues@@V?$allocator@UFunctionValues@@@std@@@std@@QBEIXZ ; std::vector<FunctionValues,std::allocator<FunctionValues>>::size(void)
.text$mn:0000745F                 sub     esi, eax
.text$mn:00007461                 cmp     esi, [ebp+arg_0]
.text$mn:00007464                 jnb     short loc_746E
.text$mn:00007466                 mov     ecx, [ebp+var_4]
.text$mn:00007469                 call    ?_Xlen@?$vector@UFunctionValues@@V?$allocator@UFunctionValues@@@std@@@std@@IBEXXZ ; std::vector<FunctionValues,std::allocator<FunctionValues>>::_Xlen(void)
.text$mn:0000746E
.text$mn:0000746E loc_746E:                               ; CODE XREF: std::vector<FunctionValues,std::allocator<FunctionValues>>::_Reserve(uint)+2Cj
.text$mn:0000746E                 mov     ecx, [ebp+var_4]
.text$mn:00007471                 call    ?size@?$vector@UFunctionValues@@V?$allocator@UFunctionValues@@@std@@@std@@QBEIXZ ; std::vector<FunctionValues,std::allocator<FunctionValues>>::size(void)
.text$mn:00007476                 add     eax, [ebp+arg_0]
.text$mn:00007479                 push    eax
.text$mn:0000747A                 mov     ecx, [ebp+var_4]
.text$mn:0000747D                 call    ?_Grow_to@?$vector@UFunctionValues@@V?$allocator@UFunctionValues@@@std@@@std@@IBEII@Z ; std::vector<FunctionValues,std::allocator<FunctionValues>>::_Grow_to(uint)
.text$mn:00007482                 push    eax
.text$mn:00007483                 mov     ecx, [ebp+var_4]
.text$mn:00007486                 call    ?_Reallocate@?$vector@UFunctionValues@@V?$allocator@UFunctionValues@@@std@@@std@@IAEXI@Z ; std::vector<FunctionValues,std::allocator<FunctionValues>>::_Reallocate(uint)
.text$mn:0000748B
.text$mn:0000748B loc_748B:                               ; CODE XREF: std::vector<FunctionValues,std::allocator<FunctionValues>>::_Reserve(uint)+13j
.text$mn:0000748B                 pop     esi
.text$mn:0000748C                 mov     esp, ebp
.text$mn:0000748E                 pop     ebp
.text$mn:0000748F                 retn    4
.text$mn:0000748F ?_Reserve@?$vector@UFunctionValues@@V?$allocator@UFunctionValues@@@std@@@std@@IAEXI@Z endp
.text$mn:0000748F
.text$mn:0000748F ; ---------------------------------------------------------------------------
.text$mn:00007492                 align 4
.text$mn:00007492 _text$mn        ends
.text$mn:00007492
.text$mn:00007494 ; ===========================================================================
.text$mn:00007494
.text$mn:00007494 ; Segment type: Pure code
.text$mn:00007494 ; Segment permissions: Read/Execute
.text$mn:00007494 _text$mn        segment para public 'CODE' use32
.text$mn:00007494                 assume cs:_text$mn
.text$mn:00007494                 ;org 7494h
.text$mn:00007494 ; COMDAT (pick any)
.text$mn:00007494                 assume es:nothing, ss:nothing, ds:_data, fs:nothing, gs:nothing
.text$mn:00007494
.text$mn:00007494 ; =============== S U B R O U T I N E =======================================
.text$mn:00007494
.text$mn:00007494 ; Attributes: bp-based frame
.text$mn:00007494
.text$mn:00007494 ; protected: void __thiscall std::vector<struct Token, class std::allocator<struct Token>>::_Reserve(unsigned int)
.text$mn:00007494                 public ?_Reserve@?$vector@UToken@@V?$allocator@UToken@@@std@@@std@@IAEXI@Z
.text$mn:00007494 ?_Reserve@?$vector@UToken@@V?$allocator@UToken@@@std@@@std@@IAEXI@Z proc near
.text$mn:00007494                                         ; CODE XREF: std::vector<Token,std::allocator<Token>>::push_back(Token &&)+59p
.text$mn:00007494                                         ; std::vector<Token,std::allocator<Token>>::push_back(Token &&)+C6p
.text$mn:00007494
.text$mn:00007494 var_4           = dword ptr -4
.text$mn:00007494 arg_0           = dword ptr  8
.text$mn:00007494
.text$mn:00007494                 push    ebp
.text$mn:00007495                 mov     ebp, esp
.text$mn:00007497                 push    ecx
.text$mn:00007498                 push    esi
.text$mn:00007499                 mov     [ebp+var_4], ecx
.text$mn:0000749C                 mov     ecx, [ebp+var_4]
.text$mn:0000749F                 call    ?_Unused_capacity@?$vector@UToken@@V?$allocator@UToken@@@std@@@std@@QBEIXZ ; std::vector<Token,std::allocator<Token>>::_Unused_capacity(void)
.text$mn:000074A4                 cmp     eax, [ebp+arg_0]
.text$mn:000074A7                 jnb     short loc_74E7
.text$mn:000074A9                 mov     ecx, [ebp+var_4]
.text$mn:000074AC                 call    ?max_size@?$vector@UToken@@V?$allocator@UToken@@@std@@@std@@QBEIXZ ; std::vector<Token,std::allocator<Token>>::max_size(void)
.text$mn:000074B1                 mov     esi, eax
.text$mn:000074B3                 mov     ecx, [ebp+var_4]
.text$mn:000074B6                 call    ?size@?$vector@UToken@@V?$allocator@UToken@@@std@@@std@@QBEIXZ ; std::vector<Token,std::allocator<Token>>::size(void)
.text$mn:000074BB                 sub     esi, eax
.text$mn:000074BD                 cmp     esi, [ebp+arg_0]
.text$mn:000074C0                 jnb     short loc_74CA
.text$mn:000074C2                 mov     ecx, [ebp+var_4]
.text$mn:000074C5                 call    ?_Xlen@?$vector@UToken@@V?$allocator@UToken@@@std@@@std@@IBEXXZ ; std::vector<Token,std::allocator<Token>>::_Xlen(void)
.text$mn:000074CA
.text$mn:000074CA loc_74CA:                               ; CODE XREF: std::vector<Token,std::allocator<Token>>::_Reserve(uint)+2Cj
.text$mn:000074CA                 mov     ecx, [ebp+var_4]
.text$mn:000074CD                 call    ?size@?$vector@UToken@@V?$allocator@UToken@@@std@@@std@@QBEIXZ ; std::vector<Token,std::allocator<Token>>::size(void)
.text$mn:000074D2                 add     eax, [ebp+arg_0]
.text$mn:000074D5                 push    eax
.text$mn:000074D6                 mov     ecx, [ebp+var_4]
.text$mn:000074D9                 call    ?_Grow_to@?$vector@UToken@@V?$allocator@UToken@@@std@@@std@@IBEII@Z ; std::vector<Token,std::allocator<Token>>::_Grow_to(uint)
.text$mn:000074DE                 push    eax
.text$mn:000074DF                 mov     ecx, [ebp+var_4]
.text$mn:000074E2                 call    ?_Reallocate@?$vector@UToken@@V?$allocator@UToken@@@std@@@std@@IAEXI@Z ; std::vector<Token,std::allocator<Token>>::_Reallocate(uint)
.text$mn:000074E7
.text$mn:000074E7 loc_74E7:                               ; CODE XREF: std::vector<Token,std::allocator<Token>>::_Reserve(uint)+13j
.text$mn:000074E7                 pop     esi
.text$mn:000074E8                 mov     esp, ebp
.text$mn:000074EA                 pop     ebp
.text$mn:000074EB                 retn    4
.text$mn:000074EB ?_Reserve@?$vector@UToken@@V?$allocator@UToken@@@std@@@std@@IAEXI@Z endp
.text$mn:000074EB
.text$mn:000074EB ; ---------------------------------------------------------------------------
.text$mn:000074EE                 align 10h
.text$mn:000074EE _text$mn        ends
.text$mn:000074EE
.text$mn:000074F0 ; ===========================================================================
.text$mn:000074F0
.text$mn:000074F0 ; Segment type: Pure code
.text$mn:000074F0 ; Segment permissions: Read/Execute
.text$mn:000074F0 _text$mn        segment para public 'CODE' use32
.text$mn:000074F0                 assume cs:_text$mn
.text$mn:000074F0                 ;org 74F0h
.text$mn:000074F0 ; COMDAT (pick any)
.text$mn:000074F0                 assume es:nothing, ss:nothing, ds:_data, fs:nothing, gs:nothing
.text$mn:000074F0
.text$mn:000074F0 ; =============== S U B R O U T I N E =======================================
.text$mn:000074F0
.text$mn:000074F0 ; Attributes: bp-based frame
.text$mn:000074F0
.text$mn:000074F0 ; protected: void __thiscall std::vector<class std::vector<wchar_t const *, class std::allocator<wchar_t const *>>, class std::allocator<class std::vector<wchar_t const *, class std::allocator<wchar_t const *>>>>::_Reserve(unsigned int)
.text$mn:000074F0                 public ?_Reserve@?$vector@V?$vector@PB_WV?$allocator@PB_W@std@@@std@@V?$allocator@V?$vector@PB_WV?$allocator@PB_W@std@@@std@@@2@@std@@IAEXI@Z
.text$mn:000074F0 ?_Reserve@?$vector@V?$vector@PB_WV?$allocator@PB_W@std@@@std@@V?$allocator@V?$vector@PB_WV?$allocator@PB_W@std@@@std@@@2@@std@@IAEXI@Z proc near
.text$mn:000074F0                                         ; CODE XREF: std::vector<std::vector<wchar_t const *,std::allocator<wchar_t const *>>,std::allocator<std::vector<wchar_t const *,std::allocator<wchar_t const *>>>>::push_back(std::vector<wchar_t const *,std::allocator<wchar_t const *>> const &)+50p
.text$mn:000074F0                                         ; std::vector<std::vector<wchar_t const *,std::allocator<wchar_t const *>>,std::allocator<std::vector<wchar_t const *,std::allocator<wchar_t const *>>>>::push_back(std::vector<wchar_t const *,std::allocator<wchar_t const *>> const &)+B6p
.text$mn:000074F0
.text$mn:000074F0 var_4           = dword ptr -4
.text$mn:000074F0 arg_0           = dword ptr  8
.text$mn:000074F0
.text$mn:000074F0                 push    ebp
.text$mn:000074F1                 mov     ebp, esp
.text$mn:000074F3                 push    ecx
.text$mn:000074F4                 push    esi
.text$mn:000074F5                 mov     [ebp+var_4], ecx
.text$mn:000074F8                 mov     ecx, [ebp+var_4]
.text$mn:000074FB                 call    ?_Unused_capacity@?$vector@V?$vector@PB_WV?$allocator@PB_W@std@@@std@@V?$allocator@V?$vector@PB_WV?$allocator@PB_W@std@@@std@@@2@@std@@QBEIXZ ; std::vector<std::vector<wchar_t const *,std::allocator<wchar_t const *>>,std::allocator<std::vector<wchar_t const *,std::allocator<wchar_t const *>>>>::_Unused_capacity(void)
.text$mn:00007500                 cmp     eax, [ebp+arg_0]
.text$mn:00007503                 jnb     short loc_7543
.text$mn:00007505                 mov     ecx, [ebp+var_4]
.text$mn:00007508                 call    ?max_size@?$vector@V?$vector@PB_WV?$allocator@PB_W@std@@@std@@V?$allocator@V?$vector@PB_WV?$allocator@PB_W@std@@@std@@@2@@std@@QBEIXZ ; std::vector<std::vector<wchar_t const *,std::allocator<wchar_t const *>>,std::allocator<std::vector<wchar_t const *,std::allocator<wchar_t const *>>>>::max_size(void)
.text$mn:0000750D                 mov     esi, eax
.text$mn:0000750F                 mov     ecx, [ebp+var_4]
.text$mn:00007512                 call    ?size@?$vector@V?$vector@PB_WV?$allocator@PB_W@std@@@std@@V?$allocator@V?$vector@PB_WV?$allocator@PB_W@std@@@std@@@2@@std@@QBEIXZ ; std::vector<std::vector<wchar_t const *,std::allocator<wchar_t const *>>,std::allocator<std::vector<wchar_t const *,std::allocator<wchar_t const *>>>>::size(void)
.text$mn:00007517                 sub     esi, eax
.text$mn:00007519                 cmp     esi, [ebp+arg_0]
.text$mn:0000751C                 jnb     short loc_7526
.text$mn:0000751E                 mov     ecx, [ebp+var_4]
.text$mn:00007521                 call    ?_Xlen@?$vector@V?$vector@PB_WV?$allocator@PB_W@std@@@std@@V?$allocator@V?$vector@PB_WV?$allocator@PB_W@std@@@std@@@2@@std@@IBEXXZ ; std::vector<std::vector<wchar_t const *,std::allocator<wchar_t const *>>,std::allocator<std::vector<wchar_t const *,std::allocator<wchar_t const *>>>>::_Xlen(void)
.text$mn:00007526
.text$mn:00007526 loc_7526:                               ; CODE XREF: std::vector<std::vector<wchar_t const *,std::allocator<wchar_t const *>>,std::allocator<std::vector<wchar_t const *,std::allocator<wchar_t const *>>>>::_Reserve(uint)+2Cj
.text$mn:00007526                 mov     ecx, [ebp+var_4]
.text$mn:00007529                 call    ?size@?$vector@V?$vector@PB_WV?$allocator@PB_W@std@@@std@@V?$allocator@V?$vector@PB_WV?$allocator@PB_W@std@@@std@@@2@@std@@QBEIXZ ; std::vector<std::vector<wchar_t const *,std::allocator<wchar_t const *>>,std::allocator<std::vector<wchar_t const *,std::allocator<wchar_t const *>>>>::size(void)
.text$mn:0000752E                 add     eax, [ebp+arg_0]
.text$mn:00007531                 push    eax
.text$mn:00007532                 mov     ecx, [ebp+var_4]
.text$mn:00007535                 call    ?_Grow_to@?$vector@V?$vector@PB_WV?$allocator@PB_W@std@@@std@@V?$allocator@V?$vector@PB_WV?$allocator@PB_W@std@@@std@@@2@@std@@IBEII@Z ; std::vector<std::vector<wchar_t const *,std::allocator<wchar_t const *>>,std::allocator<std::vector<wchar_t const *,std::allocator<wchar_t const *>>>>::_Grow_to(uint)
.text$mn:0000753A                 push    eax
.text$mn:0000753B                 mov     ecx, [ebp+var_4]
.text$mn:0000753E                 call    ?_Reallocate@?$vector@V?$vector@PB_WV?$allocator@PB_W@std@@@std@@V?$allocator@V?$vector@PB_WV?$allocator@PB_W@std@@@std@@@2@@std@@IAEXI@Z ; std::vector<std::vector<wchar_t const *,std::allocator<wchar_t const *>>,std::allocator<std::vector<wchar_t const *,std::allocator<wchar_t const *>>>>::_Reallocate(uint)
.text$mn:00007543
.text$mn:00007543 loc_7543:                               ; CODE XREF: std::vector<std::vector<wchar_t const *,std::allocator<wchar_t const *>>,std::allocator<std::vector<wchar_t const *,std::allocator<wchar_t const *>>>>::_Reserve(uint)+13j
.text$mn:00007543                 pop     esi
.text$mn:00007544                 mov     esp, ebp
.text$mn:00007546                 pop     ebp
.text$mn:00007547                 retn    4
.text$mn:00007547 ?_Reserve@?$vector@V?$vector@PB_WV?$allocator@PB_W@std@@@std@@V?$allocator@V?$vector@PB_WV?$allocator@PB_W@std@@@std@@@2@@std@@IAEXI@Z endp
.text$mn:00007547
.text$mn:00007547 ; ---------------------------------------------------------------------------
.text$mn:0000754A                 align 4
.text$mn:0000754A _text$mn        ends
.text$mn:0000754A
.text$mn:0000754C ; ===========================================================================
.text$mn:0000754C
.text$mn:0000754C ; Segment type: Pure code
.text$mn:0000754C ; Segment permissions: Read/Execute
.text$mn:0000754C _text$mn        segment para public 'CODE' use32
.text$mn:0000754C                 assume cs:_text$mn
.text$mn:0000754C                 ;org 754Ch
.text$mn:0000754C ; COMDAT (pick any)
.text$mn:0000754C                 assume es:nothing, ss:nothing, ds:_data, fs:nothing, gs:nothing
.text$mn:0000754C
.text$mn:0000754C ; =============== S U B R O U T I N E =======================================
.text$mn:0000754C
.text$mn:0000754C ; Attributes: bp-based frame
.text$mn:0000754C
.text$mn:0000754C ; void __thiscall std::_Container_base12::_Swap_all(std::_Container_base12 *this, struct std::_Container_base12 *)
.text$mn:0000754C                 public ?_Swap_all@_Container_base12@std@@QAEXAAU12@@Z
.text$mn:0000754C ?_Swap_all@_Container_base12@std@@QAEXAAU12@@Z proc near
.text$mn:0000754C                                         ; CODE XREF: std::vector<wchar_t const *,std::allocator<wchar_t const *>>::_Assign_rv(std::vector<wchar_t const *,std::allocator<wchar_t const *>> &&,std::integral_constant<bool,1>)+Ep
.text$mn:0000754C
.text$mn:0000754C var_18          = byte ptr -18h
.text$mn:0000754C var_14          = dword ptr -14h
.text$mn:0000754C var_10          = dword ptr -10h
.text$mn:0000754C var_C           = dword ptr -0Ch
.text$mn:0000754C var_4           = dword ptr -4
.text$mn:0000754C arg_0           = dword ptr  8
.text$mn:0000754C
.text$mn:0000754C                 push    ebp
.text$mn:0000754D                 mov     ebp, esp
.text$mn:0000754F                 push    0FFFFFFFFh
.text$mn:00007551                 push    offset __ehhandler$?_Swap_all@_Container_base12@std@@QAEXAAU12@@Z
.text$mn:00007556                 mov     eax, large fs:0
.text$mn:0000755C                 push    eax
.text$mn:0000755D                 sub     esp, 0Ch
.text$mn:00007560                 mov     eax, dword ptr ds:___security_cookie
.text$mn:00007565                 xor     eax, ebp
.text$mn:00007567                 push    eax
.text$mn:00007568                 lea     eax, [ebp+var_C]
.text$mn:0000756B                 mov     large fs:0, eax
.text$mn:00007571                 mov     [ebp+var_10], ecx
.text$mn:00007574                 push    3               ; int
.text$mn:00007576                 lea     ecx, [ebp+var_18] ; this
.text$mn:00007579                 call    ??0_Lockit@std@@QAE@H@Z ; std::_Lockit::_Lockit(int)
.text$mn:0000757E                 mov     [ebp+var_4], 0
.text$mn:00007585                 mov     eax, [ebp+var_10]
.text$mn:00007588                 mov     ecx, [eax]
.text$mn:0000758A                 mov     [ebp+var_14], ecx
.text$mn:0000758D                 mov     edx, [ebp+var_10]
.text$mn:00007590                 mov     eax, [ebp+arg_0]
.text$mn:00007593                 mov     ecx, [eax]
.text$mn:00007595                 mov     [edx], ecx
.text$mn:00007597                 mov     edx, [ebp+arg_0]
.text$mn:0000759A                 mov     eax, [ebp+var_14]
.text$mn:0000759D                 mov     [edx], eax
.text$mn:0000759F                 mov     ecx, [ebp+var_10]
.text$mn:000075A2                 cmp     dword ptr [ecx], 0
.text$mn:000075A5                 jz      short loc_75B1
.text$mn:000075A7                 mov     edx, [ebp+var_10]
.text$mn:000075AA                 mov     eax, [edx]
.text$mn:000075AC                 mov     ecx, [ebp+var_10]
.text$mn:000075AF                 mov     [eax], ecx
.text$mn:000075B1
.text$mn:000075B1 loc_75B1:                               ; CODE XREF: std::_Container_base12::_Swap_all(std::_Container_base12 &)+59j
.text$mn:000075B1                 mov     edx, [ebp+arg_0]
.text$mn:000075B4                 cmp     dword ptr [edx], 0
.text$mn:000075B7                 jz      short loc_75C3
.text$mn:000075B9                 mov     eax, [ebp+arg_0]
.text$mn:000075BC                 mov     ecx, [eax]
.text$mn:000075BE                 mov     edx, [ebp+arg_0]
.text$mn:000075C1                 mov     [ecx], edx
.text$mn:000075C3
.text$mn:000075C3 loc_75C3:                               ; CODE XREF: std::_Container_base12::_Swap_all(std::_Container_base12 &)+6Bj
.text$mn:000075C3                 mov     [ebp+var_4], 0FFFFFFFFh
.text$mn:000075CA                 lea     ecx, [ebp+var_18] ; this
.text$mn:000075CD                 call    ??1_Lockit@std@@QAE@XZ ; std::_Lockit::~_Lockit(void)
.text$mn:000075D2                 mov     ecx, [ebp+var_C]
.text$mn:000075D5                 mov     large fs:0, ecx
.text$mn:000075DC                 pop     ecx
.text$mn:000075DD                 mov     esp, ebp
.text$mn:000075DF                 pop     ebp
.text$mn:000075E0                 retn    4
.text$mn:000075E0 ?_Swap_all@_Container_base12@std@@QAEXAAU12@@Z endp
.text$mn:000075E0
.text$mn:000075E0 ; ---------------------------------------------------------------------------
.text$mn:000075E3                 align 4
.text$mn:000075E3 _text$mn        ends
.text$mn:000075E3
.text$x:000075E4 ; ===========================================================================
.text$x:000075E4
.text$x:000075E4 ; Segment type: Pure code
.text$x:000075E4 ; Segment permissions: Read/Execute
.text$x:000075E4 _text$x         segment para public 'CODE' use32
.text$x:000075E4                 assume cs:_text$x
.text$x:000075E4                 ;org 75E4h
.text$x:000075E4 ; COMDAT (pick associative to section at 754C)
.text$x:000075E4                 assume es:nothing, ss:nothing, ds:_data, fs:nothing, gs:nothing
.text$x:000075E4
.text$x:000075E4 ; =============== S U B R O U T I N E =======================================
.text$x:000075E4
.text$x:000075E4
.text$x:000075E4 __unwindfunclet$?_Swap_all@_Container_base12@std@@QAEXAAU12@@Z$0 proc near
.text$x:000075E4                                         ; DATA XREF: .xdata$x:00009250o
.text$x:000075E4                 lea     ecx, [ebp-18h]  ; this
.text$x:000075E7                 jmp     ??1_Lockit@std@@QAE@XZ ; std::_Lockit::~_Lockit(void)
.text$x:000075E7 __unwindfunclet$?_Swap_all@_Container_base12@std@@QAEXAAU12@@Z$0 endp
.text$x:000075E7
.text$x:000075EC
.text$x:000075EC ; =============== S U B R O U T I N E =======================================
.text$x:000075EC
.text$x:000075EC
.text$x:000075EC __ehhandler$?_Swap_all@_Container_base12@std@@QAEXAAU12@@Z proc near
.text$x:000075EC                                         ; DATA XREF: std::_Container_base12::_Swap_all(std::_Container_base12 &)+5o
.text$x:000075EC
.text$x:000075EC arg_4           = dword ptr  8
.text$x:000075EC
.text$x:000075EC                 mov     edx, [esp+arg_4]
.text$x:000075F0                 lea     eax, [edx+0Ch]
.text$x:000075F3                 mov     ecx, [edx-10h]
.text$x:000075F6                 xor     ecx, eax
.text$x:000075F8                 call    @__security_check_cookie@4 ; __security_check_cookie(x)
.text$x:000075FD                 mov     eax, offset __ehfuncinfo$?_Swap_all@_Container_base12@std@@QAEXAAU12@@Z
.text$x:00007602                 jmp     ___CxxFrameHandler3
.text$x:00007602 __ehhandler$?_Swap_all@_Container_base12@std@@QAEXAAU12@@Z endp
.text$x:00007602
.text$x:00007602 ; ---------------------------------------------------------------------------
.text$x:00007607                 align 4
.text$x:00007607 _text$x         ends
.text$x:00007607
.text$mn:00007608 ; ===========================================================================
.text$mn:00007608
.text$mn:00007608 ; Segment type: Pure code
.text$mn:00007608 ; Segment permissions: Read/Execute
.text$mn:00007608 _text$mn        segment para public 'CODE' use32
.text$mn:00007608                 assume cs:_text$mn
.text$mn:00007608                 ;org 7608h
.text$mn:00007608 ; COMDAT (pick any)
.text$mn:00007608                 assume es:nothing, ss:nothing, ds:_data, fs:nothing, gs:nothing
.text$mn:00007608
.text$mn:00007608 ; =============== S U B R O U T I N E =======================================
.text$mn:00007608
.text$mn:00007608 ; Attributes: bp-based frame
.text$mn:00007608
.text$mn:00007608 ; int __stdcall std::basic_string<char,std::char_traits<char>,std::allocator<char>>::_Tidy(char, size_t Size)
.text$mn:00007608                 public ?_Tidy@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEX_NI@Z
.text$mn:00007608 ?_Tidy@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEX_NI@Z proc near
.text$mn:00007608                                         ; CODE XREF: std::basic_string<char,std::char_traits<char>,std::allocator<char>>::basic_string<char,std::char_traits<char>,std::allocator<char>>(char const *)+47p
.text$mn:00007608                                         ; std::basic_string<char,std::char_traits<char>,std::allocator<char>>::~basic_string<char,std::char_traits<char>,std::allocator<char>>(void)+34p ...
.text$mn:00007608
.text$mn:00007608 var_C           = dword ptr -0Ch
.text$mn:00007608 var_8           = dword ptr -8
.text$mn:00007608 var_2           = byte ptr -2
.text$mn:00007608 var_1           = byte ptr -1
.text$mn:00007608 arg_0           = byte ptr  8
.text$mn:00007608 Size            = dword ptr  0Ch
.text$mn:00007608
.text$mn:00007608                 push    ebp
.text$mn:00007609                 mov     ebp, esp
.text$mn:0000760B                 sub     esp, 0Ch
.text$mn:0000760E                 mov     [ebp+var_8], ecx
.text$mn:00007611                 movzx   eax, [ebp+arg_0]
.text$mn:00007615                 test    eax, eax
.text$mn:00007617                 jnz     short loc_761B
.text$mn:00007619                 jmp     short loc_768E
.text$mn:0000761B ; ---------------------------------------------------------------------------
.text$mn:0000761B
.text$mn:0000761B loc_761B:                               ; CODE XREF: std::basic_string<char,std::char_traits<char>,std::allocator<char>>::_Tidy(bool,uint)+Fj
.text$mn:0000761B                 mov     ecx, [ebp+var_8]
.text$mn:0000761E                 cmp     dword ptr [ecx+18h], 10h
.text$mn:00007622                 jb      short loc_768E
.text$mn:00007624                 mov     edx, [ebp+var_8]
.text$mn:00007627                 mov     eax, [edx+4]
.text$mn:0000762A                 mov     [ebp+var_C], eax
.text$mn:0000762D                 mov     ecx, [ebp+var_8]
.text$mn:00007630                 add     ecx, 4
.text$mn:00007633                 push    ecx
.text$mn:00007634                 lea     edx, [ebp+var_1]
.text$mn:00007637                 push    edx
.text$mn:00007638                 mov     ecx, [ebp+var_8]
.text$mn:0000763B                 call    ?_Getal@?$_String_alloc@$0A@U?$_String_base_types@DV?$allocator@D@std@@@std@@@std@@QBE?AU?$_Wrap_alloc@V?$allocator@D@std@@@2@XZ ; std::_String_alloc<0,std::_String_base_types<char,std::allocator<char>>>::_Getal(void)
.text$mn:00007640                 mov     ecx, eax
.text$mn:00007642                 call    ??$destroy@PAD@?$_Wrap_alloc@V?$allocator@D@std@@@std@@QAEXPAPAD@Z ; std::_Wrap_alloc<std::allocator<char>>::destroy<char *>(char * *)
.text$mn:00007647                 cmp     [ebp+Size], 0
.text$mn:0000764B                 jbe     short loc_766D
.text$mn:0000764D                 mov     eax, [ebp+Size]
.text$mn:00007650                 push    eax             ; Size
.text$mn:00007651                 mov     ecx, [ebp+var_C]
.text$mn:00007654                 push    ecx
.text$mn:00007655                 call    ??$addressof@D@std@@YAPADAAD@Z ; std::addressof<char>(char &)
.text$mn:0000765A                 add     esp, 4
.text$mn:0000765D                 push    eax             ; Src
.text$mn:0000765E                 mov     edx, [ebp+var_8]
.text$mn:00007661                 add     edx, 4
.text$mn:00007664                 push    edx             ; Dst
.text$mn:00007665                 call    ?copy@?$char_traits@D@std@@SAPADPADPBDI@Z ; std::char_traits<char>::copy(char *,char const *,uint)
.text$mn:0000766A                 add     esp, 0Ch
.text$mn:0000766D
.text$mn:0000766D loc_766D:                               ; CODE XREF: std::basic_string<char,std::char_traits<char>,std::allocator<char>>::_Tidy(bool,uint)+43j
.text$mn:0000766D                 mov     eax, [ebp+var_8]
.text$mn:00007670                 mov     ecx, [eax+18h]
.text$mn:00007673                 add     ecx, 1
.text$mn:00007676                 push    ecx             ; int
.text$mn:00007677                 mov     edx, [ebp+var_C]
.text$mn:0000767A                 push    edx             ; void *
.text$mn:0000767B                 lea     eax, [ebp+var_2]
.text$mn:0000767E                 push    eax
.text$mn:0000767F                 mov     ecx, [ebp+var_8]
.text$mn:00007682                 call    ?_Getal@?$_String_alloc@$0A@U?$_String_base_types@DV?$allocator@D@std@@@std@@@std@@QBE?AU?$_Wrap_alloc@V?$allocator@D@std@@@2@XZ ; std::_String_alloc<0,std::_String_base_types<char,std::allocator<char>>>::_Getal(void)
.text$mn:00007687                 mov     ecx, eax
.text$mn:00007689                 call    ?deallocate@?$_Wrap_alloc@V?$allocator@D@std@@@std@@QAEXPADI@Z ; std::_Wrap_alloc<std::allocator<char>>::deallocate(char *,uint)
.text$mn:0000768E
.text$mn:0000768E loc_768E:                               ; CODE XREF: std::basic_string<char,std::char_traits<char>,std::allocator<char>>::_Tidy(bool,uint)+11j
.text$mn:0000768E                                         ; std::basic_string<char,std::char_traits<char>,std::allocator<char>>::_Tidy(bool,uint)+1Aj
.text$mn:0000768E                 mov     ecx, [ebp+var_8]
.text$mn:00007691                 mov     dword ptr [ecx+18h], 0Fh
.text$mn:00007698                 mov     edx, [ebp+Size]
.text$mn:0000769B                 push    edx
.text$mn:0000769C                 mov     ecx, [ebp+var_8]
.text$mn:0000769F                 call    ?_Eos@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEXI@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char>>::_Eos(uint)
.text$mn:000076A4                 mov     esp, ebp
.text$mn:000076A6                 pop     ebp
.text$mn:000076A7                 retn    8
.text$mn:000076A7 ?_Tidy@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEX_NI@Z endp
.text$mn:000076A7
.text$mn:000076A7 ; ---------------------------------------------------------------------------
.text$mn:000076AA                 align 4
.text$mn:000076AA _text$mn        ends
.text$mn:000076AA
.text$mn:000076AC ; ===========================================================================
.text$mn:000076AC
.text$mn:000076AC ; Segment type: Pure code
.text$mn:000076AC ; Segment permissions: Read/Execute
.text$mn:000076AC _text$mn        segment para public 'CODE' use32
.text$mn:000076AC                 assume cs:_text$mn
.text$mn:000076AC                 ;org 76ACh
.text$mn:000076AC ; COMDAT (pick any)
.text$mn:000076AC                 assume es:nothing, ss:nothing, ds:_data, fs:nothing, gs:nothing
.text$mn:000076AC
.text$mn:000076AC ; =============== S U B R O U T I N E =======================================
.text$mn:000076AC
.text$mn:000076AC ; Attributes: bp-based frame
.text$mn:000076AC
.text$mn:000076AC ; protected: void __thiscall std::vector<wchar_t const *, class std::allocator<wchar_t const *>>::_Tidy(void)
.text$mn:000076AC                 public ?_Tidy@?$vector@PB_WV?$allocator@PB_W@std@@@std@@IAEXXZ
.text$mn:000076AC ?_Tidy@?$vector@PB_WV?$allocator@PB_W@std@@@std@@IAEXXZ proc near
.text$mn:000076AC                                         ; CODE XREF: __catch$??0?$vector@PB_WV?$allocator@PB_W@std@@@std@@QAE@ABV01@@Z$0+3p
.text$mn:000076AC                                         ; std::vector<wchar_t const *,std::allocator<wchar_t const *>>::~vector<wchar_t const *,std::allocator<wchar_t const *>>(void)+30p
.text$mn:000076AC
.text$mn:000076AC var_8           = dword ptr -8
.text$mn:000076AC var_1           = byte ptr -1
.text$mn:000076AC
.text$mn:000076AC                 push    ebp
.text$mn:000076AD                 mov     ebp, esp
.text$mn:000076AF                 sub     esp, 8
.text$mn:000076B2                 mov     [ebp+var_8], ecx
.text$mn:000076B5                 mov     eax, [ebp+var_8]
.text$mn:000076B8                 cmp     dword ptr [eax+4], 0
.text$mn:000076BC                 jz      short loc_7724
.text$mn:000076BE                 mov     ecx, [ebp+var_8] ; this
.text$mn:000076C1                 call    ?_Orphan_all@_Container_base12@std@@QAEXXZ ; std::_Container_base12::_Orphan_all(void)
.text$mn:000076C6                 mov     ecx, [ebp+var_8]
.text$mn:000076C9                 mov     edx, [ecx+8]
.text$mn:000076CC                 push    edx
.text$mn:000076CD                 mov     eax, [ebp+var_8]
.text$mn:000076D0                 mov     ecx, [eax+4]
.text$mn:000076D3                 push    ecx
.text$mn:000076D4                 mov     ecx, [ebp+var_8]
.text$mn:000076D7                 call    ?_Destroy@?$vector@PB_WV?$allocator@PB_W@std@@@std@@IAEXPAPB_W0@Z ; std::vector<wchar_t const *,std::allocator<wchar_t const *>>::_Destroy(wchar_t const * *,wchar_t const * *)
.text$mn:000076DC                 mov     edx, [ebp+var_8]
.text$mn:000076DF                 mov     eax, [ebp+var_8]
.text$mn:000076E2                 mov     ecx, [edx+0Ch]
.text$mn:000076E5                 sub     ecx, [eax+4]
.text$mn:000076E8                 sar     ecx, 2
.text$mn:000076EB                 push    ecx             ; int
.text$mn:000076EC                 mov     edx, [ebp+var_8]
.text$mn:000076EF                 mov     eax, [edx+4]
.text$mn:000076F2                 push    eax             ; void *
.text$mn:000076F3                 lea     ecx, [ebp+var_1]
.text$mn:000076F6                 push    ecx
.text$mn:000076F7                 mov     ecx, [ebp+var_8]
.text$mn:000076FA                 call    ?_Getal@?$_Vector_alloc@$0A@U?$_Vec_base_types@PB_WV?$allocator@PB_W@std@@@std@@@std@@QBE?AU?$_Wrap_alloc@V?$allocator@PB_W@std@@@2@XZ ; std::_Vector_alloc<0,std::_Vec_base_types<wchar_t const *,std::allocator<wchar_t const *>>>::_Getal(void)
.text$mn:000076FF                 mov     ecx, eax
.text$mn:00007701                 call    ?deallocate@?$_Wrap_alloc@V?$allocator@PB_W@std@@@std@@QAEXPAPB_WI@Z ; std::_Wrap_alloc<std::allocator<wchar_t const *>>::deallocate(wchar_t const * *,uint)
.text$mn:00007706                 mov     edx, [ebp+var_8]
.text$mn:00007709                 mov     dword ptr [edx+4], 0
.text$mn:00007710                 mov     eax, [ebp+var_8]
.text$mn:00007713                 mov     dword ptr [eax+8], 0
.text$mn:0000771A                 mov     ecx, [ebp+var_8]
.text$mn:0000771D                 mov     dword ptr [ecx+0Ch], 0
.text$mn:00007724
.text$mn:00007724 loc_7724:                               ; CODE XREF: std::vector<wchar_t const *,std::allocator<wchar_t const *>>::_Tidy(void)+10j
.text$mn:00007724                 mov     esp, ebp
.text$mn:00007726                 pop     ebp
.text$mn:00007727                 retn
.text$mn:00007727 ?_Tidy@?$vector@PB_WV?$allocator@PB_W@std@@@std@@IAEXXZ endp
.text$mn:00007727
.text$mn:00007727 _text$mn        ends
.text$mn:00007727
.text$mn:00007728 ; ===========================================================================
.text$mn:00007728
.text$mn:00007728 ; Segment type: Pure code
.text$mn:00007728 ; Segment permissions: Read/Execute
.text$mn:00007728 _text$mn        segment para public 'CODE' use32
.text$mn:00007728                 assume cs:_text$mn
.text$mn:00007728                 ;org 7728h
.text$mn:00007728 ; COMDAT (pick any)
.text$mn:00007728                 assume es:nothing, ss:nothing, ds:_data, fs:nothing, gs:nothing
.text$mn:00007728
.text$mn:00007728 ; =============== S U B R O U T I N E =======================================
.text$mn:00007728
.text$mn:00007728 ; Attributes: bp-based frame
.text$mn:00007728
.text$mn:00007728 ; protected: void __thiscall std::vector<struct FunctionValues, class std::allocator<struct FunctionValues>>::_Tidy(void)
.text$mn:00007728                 public ?_Tidy@?$vector@UFunctionValues@@V?$allocator@UFunctionValues@@@std@@@std@@IAEXXZ
.text$mn:00007728 ?_Tidy@?$vector@UFunctionValues@@V?$allocator@UFunctionValues@@@std@@@std@@IAEXXZ proc near
.text$mn:00007728                                         ; CODE XREF: std::vector<FunctionValues,std::allocator<FunctionValues>>::~vector<FunctionValues,std::allocator<FunctionValues>>(void)+30p
.text$mn:00007728
.text$mn:00007728 var_8           = dword ptr -8
.text$mn:00007728 var_1           = byte ptr -1
.text$mn:00007728
.text$mn:00007728                 push    ebp
.text$mn:00007729                 mov     ebp, esp
.text$mn:0000772B                 sub     esp, 8
.text$mn:0000772E                 mov     [ebp+var_8], ecx
.text$mn:00007731                 mov     eax, [ebp+var_8]
.text$mn:00007734                 cmp     dword ptr [eax+4], 0
.text$mn:00007738                 jz      short loc_77A0
.text$mn:0000773A                 mov     ecx, [ebp+var_8] ; this
.text$mn:0000773D                 call    ?_Orphan_all@_Container_base12@std@@QAEXXZ ; std::_Container_base12::_Orphan_all(void)
.text$mn:00007742                 mov     ecx, [ebp+var_8]
.text$mn:00007745                 mov     edx, [ecx+8]
.text$mn:00007748                 push    edx
.text$mn:00007749                 mov     eax, [ebp+var_8]
.text$mn:0000774C                 mov     ecx, [eax+4]
.text$mn:0000774F                 push    ecx
.text$mn:00007750                 mov     ecx, [ebp+var_8]
.text$mn:00007753                 call    ?_Destroy@?$vector@UFunctionValues@@V?$allocator@UFunctionValues@@@std@@@std@@IAEXPAUFunctionValues@@0@Z ; std::vector<FunctionValues,std::allocator<FunctionValues>>::_Destroy(FunctionValues *,FunctionValues *)
.text$mn:00007758                 mov     edx, [ebp+var_8]
.text$mn:0000775B                 mov     eax, [ebp+var_8]
.text$mn:0000775E                 mov     ecx, [edx+0Ch]
.text$mn:00007761                 sub     ecx, [eax+4]
.text$mn:00007764                 sar     ecx, 4
.text$mn:00007767                 push    ecx             ; int
.text$mn:00007768                 mov     edx, [ebp+var_8]
.text$mn:0000776B                 mov     eax, [edx+4]
.text$mn:0000776E                 push    eax             ; void *
.text$mn:0000776F                 lea     ecx, [ebp+var_1]
.text$mn:00007772                 push    ecx
.text$mn:00007773                 mov     ecx, [ebp+var_8]
.text$mn:00007776                 call    ?_Getal@?$_Vector_alloc@$0A@U?$_Vec_base_types@UFunctionValues@@V?$allocator@UFunctionValues@@@std@@@std@@@std@@QBE?AU?$_Wrap_alloc@V?$allocator@UFunctionValues@@@std@@@2@XZ ; std::_Vector_alloc<0,std::_Vec_base_types<FunctionValues,std::allocator<FunctionValues>>>::_Getal(void)
.text$mn:0000777B                 mov     ecx, eax
.text$mn:0000777D                 call    ?deallocate@?$_Wrap_alloc@V?$allocator@UFunctionValues@@@std@@@std@@QAEXPAUFunctionValues@@I@Z ; std::_Wrap_alloc<std::allocator<FunctionValues>>::deallocate(FunctionValues *,uint)
.text$mn:00007782                 mov     edx, [ebp+var_8]
.text$mn:00007785                 mov     dword ptr [edx+4], 0
.text$mn:0000778C                 mov     eax, [ebp+var_8]
.text$mn:0000778F                 mov     dword ptr [eax+8], 0
.text$mn:00007796                 mov     ecx, [ebp+var_8]
.text$mn:00007799                 mov     dword ptr [ecx+0Ch], 0
.text$mn:000077A0
.text$mn:000077A0 loc_77A0:                               ; CODE XREF: std::vector<FunctionValues,std::allocator<FunctionValues>>::_Tidy(void)+10j
.text$mn:000077A0                 mov     esp, ebp
.text$mn:000077A2                 pop     ebp
.text$mn:000077A3                 retn
.text$mn:000077A3 ?_Tidy@?$vector@UFunctionValues@@V?$allocator@UFunctionValues@@@std@@@std@@IAEXXZ endp
.text$mn:000077A3
.text$mn:000077A3 _text$mn        ends
.text$mn:000077A3
.text$mn:000077A4 ; ===========================================================================
.text$mn:000077A4
.text$mn:000077A4 ; Segment type: Pure code
.text$mn:000077A4 ; Segment permissions: Read/Execute
.text$mn:000077A4 _text$mn        segment para public 'CODE' use32
.text$mn:000077A4                 assume cs:_text$mn
.text$mn:000077A4                 ;org 77A4h
.text$mn:000077A4 ; COMDAT (pick any)
.text$mn:000077A4                 assume es:nothing, ss:nothing, ds:_data, fs:nothing, gs:nothing
.text$mn:000077A4
.text$mn:000077A4 ; =============== S U B R O U T I N E =======================================
.text$mn:000077A4
.text$mn:000077A4 ; Attributes: bp-based frame
.text$mn:000077A4
.text$mn:000077A4 ; protected: void __thiscall std::vector<struct Token, class std::allocator<struct Token>>::_Tidy(void)
.text$mn:000077A4                 public ?_Tidy@?$vector@UToken@@V?$allocator@UToken@@@std@@@std@@IAEXXZ
.text$mn:000077A4 ?_Tidy@?$vector@UToken@@V?$allocator@UToken@@@std@@@std@@IAEXXZ proc near
.text$mn:000077A4                                         ; CODE XREF: std::vector<Token,std::allocator<Token>>::~vector<Token,std::allocator<Token>>(void)+30p
.text$mn:000077A4
.text$mn:000077A4 var_8           = dword ptr -8
.text$mn:000077A4 var_1           = byte ptr -1
.text$mn:000077A4
.text$mn:000077A4                 push    ebp
.text$mn:000077A5                 mov     ebp, esp
.text$mn:000077A7                 sub     esp, 8
.text$mn:000077AA                 mov     [ebp+var_8], ecx
.text$mn:000077AD                 mov     eax, [ebp+var_8]
.text$mn:000077B0                 cmp     dword ptr [eax+4], 0
.text$mn:000077B4                 jz      short loc_7823
.text$mn:000077B6                 mov     ecx, [ebp+var_8] ; this
.text$mn:000077B9                 call    ?_Orphan_all@_Container_base12@std@@QAEXXZ ; std::_Container_base12::_Orphan_all(void)
.text$mn:000077BE                 mov     ecx, [ebp+var_8]
.text$mn:000077C1                 mov     edx, [ecx+8]
.text$mn:000077C4                 push    edx
.text$mn:000077C5                 mov     eax, [ebp+var_8]
.text$mn:000077C8                 mov     ecx, [eax+4]
.text$mn:000077CB                 push    ecx
.text$mn:000077CC                 mov     ecx, [ebp+var_8]
.text$mn:000077CF                 call    ?_Destroy@?$vector@UToken@@V?$allocator@UToken@@@std@@@std@@IAEXPAUToken@@0@Z ; std::vector<Token,std::allocator<Token>>::_Destroy(Token *,Token *)
.text$mn:000077D4                 mov     edx, [ebp+var_8]
.text$mn:000077D7                 mov     eax, [ebp+var_8]
.text$mn:000077DA                 mov     ecx, [edx+0Ch]
.text$mn:000077DD                 sub     ecx, [eax+4]
.text$mn:000077E0                 mov     eax, ecx
.text$mn:000077E2                 cdq
.text$mn:000077E3                 mov     ecx, 0Ch
.text$mn:000077E8                 idiv    ecx
.text$mn:000077EA                 push    eax             ; int
.text$mn:000077EB                 mov     edx, [ebp+var_8]
.text$mn:000077EE                 mov     eax, [edx+4]
.text$mn:000077F1                 push    eax             ; void *
.text$mn:000077F2                 lea     ecx, [ebp+var_1]
.text$mn:000077F5                 push    ecx
.text$mn:000077F6                 mov     ecx, [ebp+var_8]
.text$mn:000077F9                 call    ?_Getal@?$_Vector_alloc@$0A@U?$_Vec_base_types@UToken@@V?$allocator@UToken@@@std@@@std@@@std@@QBE?AU?$_Wrap_alloc@V?$allocator@UToken@@@std@@@2@XZ ; std::_Vector_alloc<0,std::_Vec_base_types<Token,std::allocator<Token>>>::_Getal(void)
.text$mn:000077FE                 mov     ecx, eax
.text$mn:00007800                 call    ?deallocate@?$_Wrap_alloc@V?$allocator@UToken@@@std@@@std@@QAEXPAUToken@@I@Z ; std::_Wrap_alloc<std::allocator<Token>>::deallocate(Token *,uint)
.text$mn:00007805                 mov     edx, [ebp+var_8]
.text$mn:00007808                 mov     dword ptr [edx+4], 0
.text$mn:0000780F                 mov     eax, [ebp+var_8]
.text$mn:00007812                 mov     dword ptr [eax+8], 0
.text$mn:00007819                 mov     ecx, [ebp+var_8]
.text$mn:0000781C                 mov     dword ptr [ecx+0Ch], 0
.text$mn:00007823
.text$mn:00007823 loc_7823:                               ; CODE XREF: std::vector<Token,std::allocator<Token>>::_Tidy(void)+10j
.text$mn:00007823                 mov     esp, ebp
.text$mn:00007825                 pop     ebp
.text$mn:00007826                 retn
.text$mn:00007826 ?_Tidy@?$vector@UToken@@V?$allocator@UToken@@@std@@@std@@IAEXXZ endp
.text$mn:00007826
.text$mn:00007826 ; ---------------------------------------------------------------------------
.text$mn:00007827                 align 4
.text$mn:00007827 _text$mn        ends
.text$mn:00007827
.text$mn:00007828 ; ===========================================================================
.text$mn:00007828
.text$mn:00007828 ; Segment type: Pure code
.text$mn:00007828 ; Segment permissions: Read/Execute
.text$mn:00007828 _text$mn        segment para public 'CODE' use32
.text$mn:00007828                 assume cs:_text$mn
.text$mn:00007828                 ;org 7828h
.text$mn:00007828 ; COMDAT (pick any)
.text$mn:00007828                 assume es:nothing, ss:nothing, ds:_data, fs:nothing, gs:nothing
.text$mn:00007828
.text$mn:00007828 ; =============== S U B R O U T I N E =======================================
.text$mn:00007828
.text$mn:00007828 ; Attributes: bp-based frame
.text$mn:00007828
.text$mn:00007828 ; public: wchar_t const * const * __thiscall std::_Vector_const_iterator<class std::_Vector_val<struct std::_Simple_types<wchar_t const *>>>::_Unchecked(void)const
.text$mn:00007828                 public ?_Unchecked@?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@PB_W@std@@@std@@@std@@QBEPBQB_WXZ
.text$mn:00007828 ?_Unchecked@?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@PB_W@std@@@std@@@std@@QBEPBQB_WXZ proc near
.text$mn:00007828                                         ; CODE XREF: std::_Unchecked<std::_Vector_val<std::_Simple_types<wchar_t const *>>>(std::_Vector_const_iterator<std::_Vector_val<std::_Simple_types<wchar_t const *>>>)+2Dp
.text$mn:00007828
.text$mn:00007828 var_4           = dword ptr -4
.text$mn:00007828
.text$mn:00007828                 push    ebp
.text$mn:00007829                 mov     ebp, esp
.text$mn:0000782B                 push    ecx
.text$mn:0000782C                 mov     [ebp+var_4], ecx
.text$mn:0000782F                 mov     eax, [ebp+var_4]
.text$mn:00007832                 mov     eax, [eax+8]
.text$mn:00007835                 mov     esp, ebp
.text$mn:00007837                 pop     ebp
.text$mn:00007838                 retn
.text$mn:00007838 ?_Unchecked@?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@PB_W@std@@@std@@@std@@QBEPBQB_WXZ endp
.text$mn:00007838
.text$mn:00007838 ; ---------------------------------------------------------------------------
.text$mn:00007839                 align 4
.text$mn:00007839 _text$mn        ends
.text$mn:00007839
.text$mn:0000783C ; ===========================================================================
.text$mn:0000783C
.text$mn:0000783C ; Segment type: Pure code
.text$mn:0000783C ; Segment permissions: Read/Execute
.text$mn:0000783C _text$mn        segment para public 'CODE' use32
.text$mn:0000783C                 assume cs:_text$mn
.text$mn:0000783C                 ;org 783Ch
.text$mn:0000783C ; COMDAT (pick any)
.text$mn:0000783C                 assume es:nothing, ss:nothing, ds:_data, fs:nothing, gs:nothing
.text$mn:0000783C
.text$mn:0000783C ; =============== S U B R O U T I N E =======================================
.text$mn:0000783C
.text$mn:0000783C ; Attributes: bp-based frame
.text$mn:0000783C
.text$mn:0000783C ; public: unsigned int __thiscall std::vector<wchar_t const *, class std::allocator<wchar_t const *>>::_Unused_capacity(void)const
.text$mn:0000783C                 public ?_Unused_capacity@?$vector@PB_WV?$allocator@PB_W@std@@@std@@QBEIXZ
.text$mn:0000783C ?_Unused_capacity@?$vector@PB_WV?$allocator@PB_W@std@@@std@@QBEIXZ proc near
.text$mn:0000783C                                         ; CODE XREF: std::vector<wchar_t const *,std::allocator<wchar_t const *>>::_Reserve(uint)+Bp
.text$mn:0000783C
.text$mn:0000783C var_4           = dword ptr -4
.text$mn:0000783C
.text$mn:0000783C                 push    ebp
.text$mn:0000783D                 mov     ebp, esp
.text$mn:0000783F                 push    ecx
.text$mn:00007840                 mov     [ebp+var_4], ecx
.text$mn:00007843                 mov     eax, [ebp+var_4]
.text$mn:00007846                 mov     ecx, [ebp+var_4]
.text$mn:00007849                 mov     eax, [eax+0Ch]
.text$mn:0000784C                 sub     eax, [ecx+8]
.text$mn:0000784F                 sar     eax, 2
.text$mn:00007852                 mov     esp, ebp
.text$mn:00007854                 pop     ebp
.text$mn:00007855                 retn
.text$mn:00007855 ?_Unused_capacity@?$vector@PB_WV?$allocator@PB_W@std@@@std@@QBEIXZ endp
.text$mn:00007855
.text$mn:00007855 ; ---------------------------------------------------------------------------
.text$mn:00007856                 align 4
.text$mn:00007856 _text$mn        ends
.text$mn:00007856
.text$mn:00007858 ; ===========================================================================
.text$mn:00007858
.text$mn:00007858 ; Segment type: Pure code
.text$mn:00007858 ; Segment permissions: Read/Execute
.text$mn:00007858 _text$mn        segment para public 'CODE' use32
.text$mn:00007858                 assume cs:_text$mn
.text$mn:00007858                 ;org 7858h
.text$mn:00007858 ; COMDAT (pick any)
.text$mn:00007858                 assume es:nothing, ss:nothing, ds:_data, fs:nothing, gs:nothing
.text$mn:00007858
.text$mn:00007858 ; =============== S U B R O U T I N E =======================================
.text$mn:00007858
.text$mn:00007858 ; Attributes: bp-based frame
.text$mn:00007858
.text$mn:00007858 ; public: unsigned int __thiscall std::vector<struct FunctionValues, class std::allocator<struct FunctionValues>>::_Unused_capacity(void)const
.text$mn:00007858                 public ?_Unused_capacity@?$vector@UFunctionValues@@V?$allocator@UFunctionValues@@@std@@@std@@QBEIXZ
.text$mn:00007858 ?_Unused_capacity@?$vector@UFunctionValues@@V?$allocator@UFunctionValues@@@std@@@std@@QBEIXZ proc near
.text$mn:00007858                                         ; CODE XREF: std::vector<FunctionValues,std::allocator<FunctionValues>>::_Reserve(uint)+Bp
.text$mn:00007858
.text$mn:00007858 var_4           = dword ptr -4
.text$mn:00007858
.text$mn:00007858                 push    ebp
.text$mn:00007859                 mov     ebp, esp
.text$mn:0000785B                 push    ecx
.text$mn:0000785C                 mov     [ebp+var_4], ecx
.text$mn:0000785F                 mov     eax, [ebp+var_4]
.text$mn:00007862                 mov     ecx, [ebp+var_4]
.text$mn:00007865                 mov     eax, [eax+0Ch]
.text$mn:00007868                 sub     eax, [ecx+8]
.text$mn:0000786B                 sar     eax, 4
.text$mn:0000786E                 mov     esp, ebp
.text$mn:00007870                 pop     ebp
.text$mn:00007871                 retn
.text$mn:00007871 ?_Unused_capacity@?$vector@UFunctionValues@@V?$allocator@UFunctionValues@@@std@@@std@@QBEIXZ endp
.text$mn:00007871
.text$mn:00007871 ; ---------------------------------------------------------------------------
.text$mn:00007872                 align 4
.text$mn:00007872 _text$mn        ends
.text$mn:00007872
.text$mn:00007874 ; ===========================================================================
.text$mn:00007874
.text$mn:00007874 ; Segment type: Pure code
.text$mn:00007874 ; Segment permissions: Read/Execute
.text$mn:00007874 _text$mn        segment para public 'CODE' use32
.text$mn:00007874                 assume cs:_text$mn
.text$mn:00007874                 ;org 7874h
.text$mn:00007874 ; COMDAT (pick any)
.text$mn:00007874                 assume es:nothing, ss:nothing, ds:_data, fs:nothing, gs:nothing
.text$mn:00007874
.text$mn:00007874 ; =============== S U B R O U T I N E =======================================
.text$mn:00007874
.text$mn:00007874 ; Attributes: bp-based frame
.text$mn:00007874
.text$mn:00007874 ; public: unsigned int __thiscall std::vector<struct Token, class std::allocator<struct Token>>::_Unused_capacity(void)const
.text$mn:00007874                 public ?_Unused_capacity@?$vector@UToken@@V?$allocator@UToken@@@std@@@std@@QBEIXZ
.text$mn:00007874 ?_Unused_capacity@?$vector@UToken@@V?$allocator@UToken@@@std@@@std@@QBEIXZ proc near
.text$mn:00007874                                         ; CODE XREF: std::vector<Token,std::allocator<Token>>::_Reserve(uint)+Bp
.text$mn:00007874
.text$mn:00007874 var_4           = dword ptr -4
.text$mn:00007874
.text$mn:00007874                 push    ebp
.text$mn:00007875                 mov     ebp, esp
.text$mn:00007877                 push    ecx
.text$mn:00007878                 mov     [ebp+var_4], ecx
.text$mn:0000787B                 mov     eax, [ebp+var_4]
.text$mn:0000787E                 mov     ecx, [ebp+var_4]
.text$mn:00007881                 mov     eax, [eax+0Ch]
.text$mn:00007884                 sub     eax, [ecx+8]
.text$mn:00007887                 cdq
.text$mn:00007888                 mov     ecx, 0Ch
.text$mn:0000788D                 idiv    ecx
.text$mn:0000788F                 mov     esp, ebp
.text$mn:00007891                 pop     ebp
.text$mn:00007892                 retn
.text$mn:00007892 ?_Unused_capacity@?$vector@UToken@@V?$allocator@UToken@@@std@@@std@@QBEIXZ endp
.text$mn:00007892
.text$mn:00007892 ; ---------------------------------------------------------------------------
.text$mn:00007893                 align 4
.text$mn:00007893 _text$mn        ends
.text$mn:00007893
.text$mn:00007894 ; ===========================================================================
.text$mn:00007894
.text$mn:00007894 ; Segment type: Pure code
.text$mn:00007894 ; Segment permissions: Read/Execute
.text$mn:00007894 _text$mn        segment para public 'CODE' use32
.text$mn:00007894                 assume cs:_text$mn
.text$mn:00007894                 ;org 7894h
.text$mn:00007894 ; COMDAT (pick any)
.text$mn:00007894                 assume es:nothing, ss:nothing, ds:_data, fs:nothing, gs:nothing
.text$mn:00007894
.text$mn:00007894 ; =============== S U B R O U T I N E =======================================
.text$mn:00007894
.text$mn:00007894 ; Attributes: bp-based frame
.text$mn:00007894
.text$mn:00007894 ; public: unsigned int __thiscall std::vector<class std::vector<wchar_t const *, class std::allocator<wchar_t const *>>, class std::allocator<class std::vector<wchar_t const *, class std::allocator<wchar_t const *>>>>::_Unused_capacity(void)const
.text$mn:00007894                 public ?_Unused_capacity@?$vector@V?$vector@PB_WV?$allocator@PB_W@std@@@std@@V?$allocator@V?$vector@PB_WV?$allocator@PB_W@std@@@std@@@2@@std@@QBEIXZ
.text$mn:00007894 ?_Unused_capacity@?$vector@V?$vector@PB_WV?$allocator@PB_W@std@@@std@@V?$allocator@V?$vector@PB_WV?$allocator@PB_W@std@@@std@@@2@@std@@QBEIXZ proc near
.text$mn:00007894                                         ; CODE XREF: std::vector<std::vector<wchar_t const *,std::allocator<wchar_t const *>>,std::allocator<std::vector<wchar_t const *,std::allocator<wchar_t const *>>>>::_Reserve(uint)+Bp
.text$mn:00007894
.text$mn:00007894 var_4           = dword ptr -4
.text$mn:00007894
.text$mn:00007894                 push    ebp
.text$mn:00007895                 mov     ebp, esp
.text$mn:00007897                 push    ecx
.text$mn:00007898                 mov     [ebp+var_4], ecx
.text$mn:0000789B                 mov     eax, [ebp+var_4]
.text$mn:0000789E                 mov     ecx, [ebp+var_4]
.text$mn:000078A1                 mov     eax, [eax+0Ch]
.text$mn:000078A4                 sub     eax, [ecx+8]
.text$mn:000078A7                 sar     eax, 4
.text$mn:000078AA                 mov     esp, ebp
.text$mn:000078AC                 pop     ebp
.text$mn:000078AD                 retn
.text$mn:000078AD ?_Unused_capacity@?$vector@V?$vector@PB_WV?$allocator@PB_W@std@@@std@@V?$allocator@V?$vector@PB_WV?$allocator@PB_W@std@@@std@@@2@@std@@QBEIXZ endp
.text$mn:000078AD
.text$mn:000078AD ; ---------------------------------------------------------------------------
.text$mn:000078AE                 align 10h
.text$mn:000078AE _text$mn        ends
.text$mn:000078AE
.text$mn:000078B0 ; ===========================================================================
.text$mn:000078B0
.text$mn:000078B0 ; Segment type: Pure code
.text$mn:000078B0 ; Segment permissions: Read/Execute
.text$mn:000078B0 _text$mn        segment para public 'CODE' use32
.text$mn:000078B0                 assume cs:_text$mn
.text$mn:000078B0                 ;org 78B0h
.text$mn:000078B0 ; COMDAT (pick any)
.text$mn:000078B0                 assume es:nothing, ss:nothing, ds:_data, fs:nothing, gs:nothing
.text$mn:000078B0
.text$mn:000078B0 ; =============== S U B R O U T I N E =======================================
.text$mn:000078B0
.text$mn:000078B0 ; Attributes: bp-based frame
.text$mn:000078B0
.text$mn:000078B0 ; public: void __thiscall std::basic_string<char, struct std::char_traits<char>, class std::allocator<char>>::_Xlen(void)const
.text$mn:000078B0                 public ?_Xlen@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QBEXXZ
.text$mn:000078B0 ?_Xlen@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QBEXXZ proc near
.text$mn:000078B0                                         ; CODE XREF: std::basic_string<char,std::char_traits<char>,std::allocator<char>>::_Grow(uint,bool)+19p
.text$mn:000078B0
.text$mn:000078B0 var_4           = dword ptr -4
.text$mn:000078B0
.text$mn:000078B0                 push    ebp
.text$mn:000078B1                 mov     ebp, esp
.text$mn:000078B3                 push    ecx
.text$mn:000078B4                 mov     [ebp+var_4], ecx
.text$mn:000078B7                 push    offset ??_C@_0BA@JFNIOLAK@string?5too?5long?$AA@ ; "string too long"
.text$mn:000078BC                 call    ?_Xlength_error@std@@YAXPBD@Z ; std::_Xlength_error(char const *)
.text$mn:000078C1                 mov     esp, ebp
.text$mn:000078C3                 pop     ebp
.text$mn:000078C4                 retn
.text$mn:000078C4 ?_Xlen@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QBEXXZ endp
.text$mn:000078C4
.text$mn:000078C4 ; ---------------------------------------------------------------------------
.text$mn:000078C5                 align 4
.text$mn:000078C5 _text$mn        ends
.text$mn:000078C5
.text$mn:000078C8 ; ===========================================================================
.text$mn:000078C8
.text$mn:000078C8 ; Segment type: Pure code
.text$mn:000078C8 ; Segment permissions: Read/Execute
.text$mn:000078C8 _text$mn        segment para public 'CODE' use32
.text$mn:000078C8                 assume cs:_text$mn
.text$mn:000078C8                 ;org 78C8h
.text$mn:000078C8 ; COMDAT (pick any)
.text$mn:000078C8                 assume es:nothing, ss:nothing, ds:_data, fs:nothing, gs:nothing
.text$mn:000078C8
.text$mn:000078C8 ; =============== S U B R O U T I N E =======================================
.text$mn:000078C8
.text$mn:000078C8 ; Attributes: bp-based frame
.text$mn:000078C8
.text$mn:000078C8 ; protected: void __thiscall std::vector<wchar_t const *, class std::allocator<wchar_t const *>>::_Xlen(void)const
.text$mn:000078C8                 public ?_Xlen@?$vector@PB_WV?$allocator@PB_W@std@@@std@@IBEXXZ
.text$mn:000078C8 ?_Xlen@?$vector@PB_WV?$allocator@PB_W@std@@@std@@IBEXXZ proc near
.text$mn:000078C8                                         ; CODE XREF: std::vector<wchar_t const *,std::allocator<wchar_t const *>>::_Buy(uint)+43p
.text$mn:000078C8                                         ; std::vector<wchar_t const *,std::allocator<wchar_t const *>>::_Reserve(uint)+31p
.text$mn:000078C8
.text$mn:000078C8 var_4           = dword ptr -4
.text$mn:000078C8
.text$mn:000078C8                 push    ebp
.text$mn:000078C9                 mov     ebp, esp
.text$mn:000078CB                 push    ecx
.text$mn:000078CC                 mov     [ebp+var_4], ecx
.text$mn:000078CF                 push    offset ??_C@_0BD@OLBABOEK@vector?$DMT?$DO?5too?5long?$AA@ ; "vector<T> too long"
.text$mn:000078D4                 call    ?_Xlength_error@std@@YAXPBD@Z ; std::_Xlength_error(char const *)
.text$mn:000078D9                 mov     esp, ebp
.text$mn:000078DB                 pop     ebp
.text$mn:000078DC                 retn
.text$mn:000078DC ?_Xlen@?$vector@PB_WV?$allocator@PB_W@std@@@std@@IBEXXZ endp
.text$mn:000078DC
.text$mn:000078DC ; ---------------------------------------------------------------------------
.text$mn:000078DD                 align 10h
.text$mn:000078DD _text$mn        ends
.text$mn:000078DD
.text$mn:000078E0 ; ===========================================================================
.text$mn:000078E0
.text$mn:000078E0 ; Segment type: Pure code
.text$mn:000078E0 ; Segment permissions: Read/Execute
.text$mn:000078E0 _text$mn        segment para public 'CODE' use32
.text$mn:000078E0                 assume cs:_text$mn
.text$mn:000078E0                 ;org 78E0h
.text$mn:000078E0 ; COMDAT (pick any)
.text$mn:000078E0                 assume es:nothing, ss:nothing, ds:_data, fs:nothing, gs:nothing
.text$mn:000078E0
.text$mn:000078E0 ; =============== S U B R O U T I N E =======================================
.text$mn:000078E0
.text$mn:000078E0 ; Attributes: bp-based frame
.text$mn:000078E0
.text$mn:000078E0 ; protected: void __thiscall std::vector<struct FunctionValues, class std::allocator<struct FunctionValues>>::_Xlen(void)const
.text$mn:000078E0                 public ?_Xlen@?$vector@UFunctionValues@@V?$allocator@UFunctionValues@@@std@@@std@@IBEXXZ
.text$mn:000078E0 ?_Xlen@?$vector@UFunctionValues@@V?$allocator@UFunctionValues@@@std@@@std@@IBEXXZ proc near
.text$mn:000078E0                                         ; CODE XREF: std::vector<FunctionValues,std::allocator<FunctionValues>>::_Reserve(uint)+31p
.text$mn:000078E0
.text$mn:000078E0 var_4           = dword ptr -4
.text$mn:000078E0
.text$mn:000078E0                 push    ebp
.text$mn:000078E1                 mov     ebp, esp
.text$mn:000078E3                 push    ecx
.text$mn:000078E4                 mov     [ebp+var_4], ecx
.text$mn:000078E7                 push    offset ??_C@_0BD@OLBABOEK@vector?$DMT?$DO?5too?5long?$AA@ ; "vector<T> too long"
.text$mn:000078EC                 call    ?_Xlength_error@std@@YAXPBD@Z ; std::_Xlength_error(char const *)
.text$mn:000078F1                 mov     esp, ebp
.text$mn:000078F3                 pop     ebp
.text$mn:000078F4                 retn
.text$mn:000078F4 ?_Xlen@?$vector@UFunctionValues@@V?$allocator@UFunctionValues@@@std@@@std@@IBEXXZ endp
.text$mn:000078F4
.text$mn:000078F4 ; ---------------------------------------------------------------------------
.text$mn:000078F5                 align 4
.text$mn:000078F5 _text$mn        ends
.text$mn:000078F5
.text$mn:000078F8 ; ===========================================================================
.text$mn:000078F8
.text$mn:000078F8 ; Segment type: Pure code
.text$mn:000078F8 ; Segment permissions: Read/Execute
.text$mn:000078F8 _text$mn        segment para public 'CODE' use32
.text$mn:000078F8                 assume cs:_text$mn
.text$mn:000078F8                 ;org 78F8h
.text$mn:000078F8 ; COMDAT (pick any)
.text$mn:000078F8                 assume es:nothing, ss:nothing, ds:_data, fs:nothing, gs:nothing
.text$mn:000078F8
.text$mn:000078F8 ; =============== S U B R O U T I N E =======================================
.text$mn:000078F8
.text$mn:000078F8 ; Attributes: bp-based frame
.text$mn:000078F8
.text$mn:000078F8 ; protected: void __thiscall std::vector<struct Token, class std::allocator<struct Token>>::_Xlen(void)const
.text$mn:000078F8                 public ?_Xlen@?$vector@UToken@@V?$allocator@UToken@@@std@@@std@@IBEXXZ
.text$mn:000078F8 ?_Xlen@?$vector@UToken@@V?$allocator@UToken@@@std@@@std@@IBEXXZ proc near
.text$mn:000078F8                                         ; CODE XREF: std::vector<Token,std::allocator<Token>>::_Reserve(uint)+31p
.text$mn:000078F8
.text$mn:000078F8 var_4           = dword ptr -4
.text$mn:000078F8
.text$mn:000078F8                 push    ebp
.text$mn:000078F9                 mov     ebp, esp
.text$mn:000078FB                 push    ecx
.text$mn:000078FC                 mov     [ebp+var_4], ecx
.text$mn:000078FF                 push    offset ??_C@_0BD@OLBABOEK@vector?$DMT?$DO?5too?5long?$AA@ ; "vector<T> too long"
.text$mn:00007904                 call    ?_Xlength_error@std@@YAXPBD@Z ; std::_Xlength_error(char const *)
.text$mn:00007909                 mov     esp, ebp
.text$mn:0000790B                 pop     ebp
.text$mn:0000790C                 retn
.text$mn:0000790C ?_Xlen@?$vector@UToken@@V?$allocator@UToken@@@std@@@std@@IBEXXZ endp
.text$mn:0000790C
.text$mn:0000790C ; ---------------------------------------------------------------------------
.text$mn:0000790D                 align 10h
.text$mn:0000790D _text$mn        ends
.text$mn:0000790D
.text$mn:00007910 ; ===========================================================================
.text$mn:00007910
.text$mn:00007910 ; Segment type: Pure code
.text$mn:00007910 ; Segment permissions: Read/Execute
.text$mn:00007910 _text$mn        segment para public 'CODE' use32
.text$mn:00007910                 assume cs:_text$mn
.text$mn:00007910                 ;org 7910h
.text$mn:00007910 ; COMDAT (pick any)
.text$mn:00007910                 assume es:nothing, ss:nothing, ds:_data, fs:nothing, gs:nothing
.text$mn:00007910
.text$mn:00007910 ; =============== S U B R O U T I N E =======================================
.text$mn:00007910
.text$mn:00007910 ; Attributes: bp-based frame
.text$mn:00007910
.text$mn:00007910 ; protected: void __thiscall std::vector<class std::vector<wchar_t const *, class std::allocator<wchar_t const *>>, class std::allocator<class std::vector<wchar_t const *, class std::allocator<wchar_t const *>>>>::_Xlen(void)const
.text$mn:00007910                 public ?_Xlen@?$vector@V?$vector@PB_WV?$allocator@PB_W@std@@@std@@V?$allocator@V?$vector@PB_WV?$allocator@PB_W@std@@@std@@@2@@std@@IBEXXZ
.text$mn:00007910 ?_Xlen@?$vector@V?$vector@PB_WV?$allocator@PB_W@std@@@std@@V?$allocator@V?$vector@PB_WV?$allocator@PB_W@std@@@std@@@2@@std@@IBEXXZ proc near
.text$mn:00007910                                         ; CODE XREF: std::vector<std::vector<wchar_t const *,std::allocator<wchar_t const *>>,std::allocator<std::vector<wchar_t const *,std::allocator<wchar_t const *>>>>::_Reserve(uint)+31p
.text$mn:00007910
.text$mn:00007910 var_4           = dword ptr -4
.text$mn:00007910
.text$mn:00007910                 push    ebp
.text$mn:00007911                 mov     ebp, esp
.text$mn:00007913                 push    ecx
.text$mn:00007914                 mov     [ebp+var_4], ecx
.text$mn:00007917                 push    offset ??_C@_0BD@OLBABOEK@vector?$DMT?$DO?5too?5long?$AA@ ; "vector<T> too long"
.text$mn:0000791C                 call    ?_Xlength_error@std@@YAXPBD@Z ; std::_Xlength_error(char const *)
.text$mn:00007921                 mov     esp, ebp
.text$mn:00007923                 pop     ebp
.text$mn:00007924                 retn
.text$mn:00007924 ?_Xlen@?$vector@V?$vector@PB_WV?$allocator@PB_W@std@@@std@@V?$allocator@V?$vector@PB_WV?$allocator@PB_W@std@@@std@@@2@@std@@IBEXXZ endp
.text$mn:00007924
.text$mn:00007924 ; ---------------------------------------------------------------------------
.text$mn:00007925                 align 4
.text$mn:00007925 _text$mn        ends
.text$mn:00007925
.text$mn:00007928 ; ===========================================================================
.text$mn:00007928
.text$mn:00007928 ; Segment type: Pure code
.text$mn:00007928 ; Segment permissions: Read/Execute
.text$mn:00007928 _text$mn        segment para public 'CODE' use32
.text$mn:00007928                 assume cs:_text$mn
.text$mn:00007928                 ;org 7928h
.text$mn:00007928 ; COMDAT (pick any)
.text$mn:00007928                 assume es:nothing, ss:nothing, ds:_data, fs:nothing, gs:nothing
.text$mn:00007928
.text$mn:00007928 ; =============== S U B R O U T I N E =======================================
.text$mn:00007928
.text$mn:00007928 ; Attributes: bp-based frame
.text$mn:00007928
.text$mn:00007928 ; public: void __thiscall std::basic_string<char, struct std::char_traits<char>, class std::allocator<char>>::_Xran(void)const
.text$mn:00007928                 public ?_Xran@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QBEXXZ
.text$mn:00007928 ?_Xran@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QBEXXZ proc near
.text$mn:00007928                                         ; CODE XREF: std::basic_string<char,std::char_traits<char>,std::allocator<char>>::assign(std::basic_string<char,std::char_traits<char>,std::allocator<char>> const &,uint,uint)+19p
.text$mn:00007928                                         ; std::basic_string<char,std::char_traits<char>,std::allocator<char>>::erase(uint)+15p ...
.text$mn:00007928
.text$mn:00007928 var_4           = dword ptr -4
.text$mn:00007928
.text$mn:00007928                 push    ebp
.text$mn:00007929                 mov     ebp, esp
.text$mn:0000792B                 push    ecx
.text$mn:0000792C                 mov     [ebp+var_4], ecx
.text$mn:0000792F                 push    offset ??_C@_0BI@CFPLBAOH@invalid?5string?5position?$AA@ ; "invalid string position"
.text$mn:00007934                 call    ?_Xout_of_range@std@@YAXPBD@Z ; std::_Xout_of_range(char const *)
.text$mn:00007939                 mov     esp, ebp
.text$mn:0000793B                 pop     ebp
.text$mn:0000793C                 retn
.text$mn:0000793C ?_Xran@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QBEXXZ endp
.text$mn:0000793C
.text$mn:0000793C ; ---------------------------------------------------------------------------
.text$mn:0000793D                 align 10h
.text$mn:0000793D _text$mn        ends
.text$mn:0000793D
.text$mn:00007940 ; ===========================================================================
.text$mn:00007940
.text$mn:00007940 ; Segment type: Pure code
.text$mn:00007940 ; Segment permissions: Read/Execute
.text$mn:00007940 _text$mn        segment para public 'CODE' use32
.text$mn:00007940                 assume cs:_text$mn
.text$mn:00007940                 ;org 7940h
.text$mn:00007940 ; COMDAT (pick any)
.text$mn:00007940                 assume es:nothing, ss:nothing, ds:_data, fs:nothing, gs:nothing
.text$mn:00007940
.text$mn:00007940 ; =============== S U B R O U T I N E =======================================
.text$mn:00007940
.text$mn:00007940 ; Attributes: bp-based frame
.text$mn:00007940
.text$mn:00007940 ; protected: void __thiscall std::vector<wchar_t const *, class std::allocator<wchar_t const *>>::_Xran(void)const
.text$mn:00007940                 public ?_Xran@?$vector@PB_WV?$allocator@PB_W@std@@@std@@IBEXXZ
.text$mn:00007940 ?_Xran@?$vector@PB_WV?$allocator@PB_W@std@@@std@@IBEXXZ proc near
.text$mn:00007940                                         ; CODE XREF: std::vector<wchar_t const *,std::allocator<wchar_t const *>>::at(uint)+17p
.text$mn:00007940
.text$mn:00007940 var_4           = dword ptr -4
.text$mn:00007940
.text$mn:00007940                 push    ebp
.text$mn:00007941                 mov     ebp, esp
.text$mn:00007943                 push    ecx
.text$mn:00007944                 mov     [ebp+var_4], ecx
.text$mn:00007947                 push    offset ??_C@_0BM@NMJKDPPO@invalid?5vector?$DMT?$DO?5subscript?$AA@ ; "invalid vector<T> subscript"
.text$mn:0000794C                 call    ?_Xout_of_range@std@@YAXPBD@Z ; std::_Xout_of_range(char const *)
.text$mn:00007951                 mov     esp, ebp
.text$mn:00007953                 pop     ebp
.text$mn:00007954                 retn
.text$mn:00007954 ?_Xran@?$vector@PB_WV?$allocator@PB_W@std@@@std@@IBEXXZ endp
.text$mn:00007954
.text$mn:00007954 ; ---------------------------------------------------------------------------
.text$mn:00007955                 align 4
.text$mn:00007955 _text$mn        ends
.text$mn:00007955
.text$mn:00007958 ; ===========================================================================
.text$mn:00007958
.text$mn:00007958 ; Segment type: Pure code
.text$mn:00007958 ; Segment permissions: Read/Execute
.text$mn:00007958 _text$mn        segment para public 'CODE' use32
.text$mn:00007958                 assume cs:_text$mn
.text$mn:00007958                 ;org 7958h
.text$mn:00007958 ; COMDAT (pick any)
.text$mn:00007958                 assume es:nothing, ss:nothing, ds:_data, fs:nothing, gs:nothing
.text$mn:00007958
.text$mn:00007958 ; =============== S U B R O U T I N E =======================================
.text$mn:00007958
.text$mn:00007958 ; Attributes: bp-based frame
.text$mn:00007958
.text$mn:00007958 ; protected: void __thiscall std::vector<struct Token, class std::allocator<struct Token>>::_Xran(void)const
.text$mn:00007958                 public ?_Xran@?$vector@UToken@@V?$allocator@UToken@@@std@@@std@@IBEXXZ
.text$mn:00007958 ?_Xran@?$vector@UToken@@V?$allocator@UToken@@@std@@@std@@IBEXXZ proc near
.text$mn:00007958                                         ; CODE XREF: std::vector<Token,std::allocator<Token>>::at(uint)+17p
.text$mn:00007958
.text$mn:00007958 var_4           = dword ptr -4
.text$mn:00007958
.text$mn:00007958                 push    ebp
.text$mn:00007959                 mov     ebp, esp
.text$mn:0000795B                 push    ecx
.text$mn:0000795C                 mov     [ebp+var_4], ecx
.text$mn:0000795F                 push    offset ??_C@_0BM@NMJKDPPO@invalid?5vector?$DMT?$DO?5subscript?$AA@ ; "invalid vector<T> subscript"
.text$mn:00007964                 call    ?_Xout_of_range@std@@YAXPBD@Z ; std::_Xout_of_range(char const *)
.text$mn:00007969                 mov     esp, ebp
.text$mn:0000796B                 pop     ebp
.text$mn:0000796C                 retn
.text$mn:0000796C ?_Xran@?$vector@UToken@@V?$allocator@UToken@@@std@@@std@@IBEXXZ endp
.text$mn:0000796C
.text$mn:0000796C ; ---------------------------------------------------------------------------
.text$mn:0000796D                 align 10h
.text$mn:0000796D _text$mn        ends
.text$mn:0000796D
.text$mn:00007970 ; ===========================================================================
.text$mn:00007970
.text$mn:00007970 ; Segment type: Pure code
.text$mn:00007970 ; Segment permissions: Read/Execute
.text$mn:00007970 _text$mn        segment para public 'CODE' use32
.text$mn:00007970                 assume cs:_text$mn
.text$mn:00007970                 ;org 7970h
.text$mn:00007970 ; COMDAT (pick any)
.text$mn:00007970                 assume es:nothing, ss:nothing, ds:_data, fs:nothing, gs:nothing
.text$mn:00007970
.text$mn:00007970 ; =============== S U B R O U T I N E =======================================
.text$mn:00007970
.text$mn:00007970 ; Attributes: bp-based frame
.text$mn:00007970
.text$mn:00007970 ; protected: void __thiscall std::vector<class std::vector<wchar_t const *, class std::allocator<wchar_t const *>>, class std::allocator<class std::vector<wchar_t const *, class std::allocator<wchar_t const *>>>>::_Xran(void)const
.text$mn:00007970                 public ?_Xran@?$vector@V?$vector@PB_WV?$allocator@PB_W@std@@@std@@V?$allocator@V?$vector@PB_WV?$allocator@PB_W@std@@@std@@@2@@std@@IBEXXZ
.text$mn:00007970 ?_Xran@?$vector@V?$vector@PB_WV?$allocator@PB_W@std@@@std@@V?$allocator@V?$vector@PB_WV?$allocator@PB_W@std@@@std@@@2@@std@@IBEXXZ proc near
.text$mn:00007970                                         ; CODE XREF: std::vector<std::vector<wchar_t const *,std::allocator<wchar_t const *>>,std::allocator<std::vector<wchar_t const *,std::allocator<wchar_t const *>>>>::at(uint)+17p
.text$mn:00007970
.text$mn:00007970 var_4           = dword ptr -4
.text$mn:00007970
.text$mn:00007970                 push    ebp
.text$mn:00007971                 mov     ebp, esp
.text$mn:00007973                 push    ecx
.text$mn:00007974                 mov     [ebp+var_4], ecx
.text$mn:00007977                 push    offset ??_C@_0BM@NMJKDPPO@invalid?5vector?$DMT?$DO?5subscript?$AA@ ; "invalid vector<T> subscript"
.text$mn:0000797C                 call    ?_Xout_of_range@std@@YAXPBD@Z ; std::_Xout_of_range(char const *)
.text$mn:00007981                 mov     esp, ebp
.text$mn:00007983                 pop     ebp
.text$mn:00007984                 retn
.text$mn:00007984 ?_Xran@?$vector@V?$vector@PB_WV?$allocator@PB_W@std@@@std@@V?$allocator@V?$vector@PB_WV?$allocator@PB_W@std@@@std@@@2@@std@@IBEXXZ endp
.text$mn:00007984
.text$mn:00007984 ; ---------------------------------------------------------------------------
.text$mn:00007985                 align 4
.text$mn:00007985 _text$mn        ends
.text$mn:00007985
.text$mn:00007988 ; ===========================================================================
.text$mn:00007988
.text$mn:00007988 ; Segment type: Pure code
.text$mn:00007988 ; Segment permissions: Read/Execute
.text$mn:00007988 _text$mn        segment para public 'CODE' use32
.text$mn:00007988                 assume cs:_text$mn
.text$mn:00007988                 ;org 7988h
.text$mn:00007988 ; COMDAT (pick any)
.text$mn:00007988                 assume es:nothing, ss:nothing, ds:_data, fs:nothing, gs:nothing
.text$mn:00007988
.text$mn:00007988 ; =============== S U B R O U T I N E =======================================
.text$mn:00007988
.text$mn:00007988 ; Attributes: bp-based frame
.text$mn:00007988
.text$mn:00007988 ; public: char * __thiscall std::_Wrap_alloc<class std::allocator<char>>::allocate(unsigned int)
.text$mn:00007988                 public ?allocate@?$_Wrap_alloc@V?$allocator@D@std@@@std@@QAEPADI@Z
.text$mn:00007988 ?allocate@?$_Wrap_alloc@V?$allocator@D@std@@@std@@QAEPADI@Z proc near
.text$mn:00007988                                         ; CODE XREF: std::basic_string<char,std::char_traits<char>,std::allocator<char>>::_Copy(uint,uint)+BBp
.text$mn:00007988                                         ; __catch$?_Copy@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEXII@Z$0+22p
.text$mn:00007988
.text$mn:00007988 var_4           = dword ptr -4
.text$mn:00007988 arg_0           = dword ptr  8
.text$mn:00007988
.text$mn:00007988                 push    ebp
.text$mn:00007989                 mov     ebp, esp
.text$mn:0000798B                 push    ecx
.text$mn:0000798C                 mov     [ebp+var_4], ecx
.text$mn:0000798F                 mov     eax, [ebp+arg_0]
.text$mn:00007992                 push    eax
.text$mn:00007993                 mov     ecx, [ebp+var_4]
.text$mn:00007996                 call    ?allocate@?$allocator@D@std@@QAEPADI@Z ; std::allocator<char>::allocate(uint)
.text$mn:0000799B                 mov     esp, ebp
.text$mn:0000799D                 pop     ebp
.text$mn:0000799E                 retn    4
.text$mn:0000799E ?allocate@?$_Wrap_alloc@V?$allocator@D@std@@@std@@QAEPADI@Z endp
.text$mn:0000799E
.text$mn:0000799E ; ---------------------------------------------------------------------------
.text$mn:000079A1                 align 4
.text$mn:000079A1 _text$mn        ends
.text$mn:000079A1
.text$mn:000079A4 ; ===========================================================================
.text$mn:000079A4
.text$mn:000079A4 ; Segment type: Pure code
.text$mn:000079A4 ; Segment permissions: Read/Execute
.text$mn:000079A4 _text$mn        segment para public 'CODE' use32
.text$mn:000079A4                 assume cs:_text$mn
.text$mn:000079A4                 ;org 79A4h
.text$mn:000079A4 ; COMDAT (pick any)
.text$mn:000079A4                 assume es:nothing, ss:nothing, ds:_data, fs:nothing, gs:nothing
.text$mn:000079A4
.text$mn:000079A4 ; =============== S U B R O U T I N E =======================================
.text$mn:000079A4
.text$mn:000079A4 ; Attributes: bp-based frame
.text$mn:000079A4
.text$mn:000079A4 ; public: wchar_t const * * __thiscall std::_Wrap_alloc<class std::allocator<wchar_t const *>>::allocate(unsigned int)
.text$mn:000079A4                 public ?allocate@?$_Wrap_alloc@V?$allocator@PB_W@std@@@std@@QAEPAPB_WI@Z
.text$mn:000079A4 ?allocate@?$_Wrap_alloc@V?$allocator@PB_W@std@@@std@@QAEPAPB_WI@Z proc near
.text$mn:000079A4                                         ; CODE XREF: std::vector<wchar_t const *,std::allocator<wchar_t const *>>::_Buy(uint)+5Cp
.text$mn:000079A4                                         ; std::vector<wchar_t const *,std::allocator<wchar_t const *>>::_Reallocate(uint)+41p
.text$mn:000079A4
.text$mn:000079A4 var_4           = dword ptr -4
.text$mn:000079A4 arg_0           = dword ptr  8
.text$mn:000079A4
.text$mn:000079A4                 push    ebp
.text$mn:000079A5                 mov     ebp, esp
.text$mn:000079A7                 push    ecx
.text$mn:000079A8                 mov     [ebp+var_4], ecx
.text$mn:000079AB                 mov     eax, [ebp+arg_0]
.text$mn:000079AE                 push    eax
.text$mn:000079AF                 mov     ecx, [ebp+var_4]
.text$mn:000079B2                 call    ?allocate@?$allocator@PB_W@std@@QAEPAPB_WI@Z ; std::allocator<wchar_t const *>::allocate(uint)
.text$mn:000079B7                 mov     esp, ebp
.text$mn:000079B9                 pop     ebp
.text$mn:000079BA                 retn    4
.text$mn:000079BA ?allocate@?$_Wrap_alloc@V?$allocator@PB_W@std@@@std@@QAEPAPB_WI@Z endp
.text$mn:000079BA
.text$mn:000079BA ; ---------------------------------------------------------------------------
.text$mn:000079BD                 align 10h
.text$mn:000079BD _text$mn        ends
.text$mn:000079BD
.text$mn:000079C0 ; ===========================================================================
.text$mn:000079C0
.text$mn:000079C0 ; Segment type: Pure code
.text$mn:000079C0 ; Segment permissions: Read/Execute
.text$mn:000079C0 _text$mn        segment para public 'CODE' use32
.text$mn:000079C0                 assume cs:_text$mn
.text$mn:000079C0                 ;org 79C0h
.text$mn:000079C0 ; COMDAT (pick any)
.text$mn:000079C0                 assume es:nothing, ss:nothing, ds:_data, fs:nothing, gs:nothing
.text$mn:000079C0
.text$mn:000079C0 ; =============== S U B R O U T I N E =======================================
.text$mn:000079C0
.text$mn:000079C0 ; Attributes: bp-based frame
.text$mn:000079C0
.text$mn:000079C0 ; public: struct FunctionValues * __thiscall std::_Wrap_alloc<class std::allocator<struct FunctionValues>>::allocate(unsigned int)
.text$mn:000079C0                 public ?allocate@?$_Wrap_alloc@V?$allocator@UFunctionValues@@@std@@@std@@QAEPAUFunctionValues@@I@Z
.text$mn:000079C0 ?allocate@?$_Wrap_alloc@V?$allocator@UFunctionValues@@@std@@@std@@QAEPAUFunctionValues@@I@Z proc near
.text$mn:000079C0                                         ; CODE XREF: std::vector<FunctionValues,std::allocator<FunctionValues>>::_Reallocate(uint)+41p
.text$mn:000079C0
.text$mn:000079C0 var_4           = dword ptr -4
.text$mn:000079C0 arg_0           = dword ptr  8
.text$mn:000079C0
.text$mn:000079C0                 push    ebp
.text$mn:000079C1                 mov     ebp, esp
.text$mn:000079C3                 push    ecx
.text$mn:000079C4                 mov     [ebp+var_4], ecx
.text$mn:000079C7                 mov     eax, [ebp+arg_0]
.text$mn:000079CA                 push    eax
.text$mn:000079CB                 mov     ecx, [ebp+var_4]
.text$mn:000079CE                 call    ?allocate@?$allocator@UFunctionValues@@@std@@QAEPAUFunctionValues@@I@Z ; std::allocator<FunctionValues>::allocate(uint)
.text$mn:000079D3                 mov     esp, ebp
.text$mn:000079D5                 pop     ebp
.text$mn:000079D6                 retn    4
.text$mn:000079D6 ?allocate@?$_Wrap_alloc@V?$allocator@UFunctionValues@@@std@@@std@@QAEPAUFunctionValues@@I@Z endp
.text$mn:000079D6
.text$mn:000079D6 ; ---------------------------------------------------------------------------
.text$mn:000079D9                 align 4
.text$mn:000079D9 _text$mn        ends
.text$mn:000079D9
.text$mn:000079DC ; ===========================================================================
.text$mn:000079DC
.text$mn:000079DC ; Segment type: Pure code
.text$mn:000079DC ; Segment permissions: Read/Execute
.text$mn:000079DC _text$mn        segment para public 'CODE' use32
.text$mn:000079DC                 assume cs:_text$mn
.text$mn:000079DC                 ;org 79DCh
.text$mn:000079DC ; COMDAT (pick any)
.text$mn:000079DC                 assume es:nothing, ss:nothing, ds:_data, fs:nothing, gs:nothing
.text$mn:000079DC
.text$mn:000079DC ; =============== S U B R O U T I N E =======================================
.text$mn:000079DC
.text$mn:000079DC ; Attributes: bp-based frame
.text$mn:000079DC
.text$mn:000079DC ; public: struct Token * __thiscall std::_Wrap_alloc<class std::allocator<struct Token>>::allocate(unsigned int)
.text$mn:000079DC                 public ?allocate@?$_Wrap_alloc@V?$allocator@UToken@@@std@@@std@@QAEPAUToken@@I@Z
.text$mn:000079DC ?allocate@?$_Wrap_alloc@V?$allocator@UToken@@@std@@@std@@QAEPAUToken@@I@Z proc near
.text$mn:000079DC                                         ; CODE XREF: std::vector<Token,std::allocator<Token>>::_Reallocate(uint)+41p
.text$mn:000079DC
.text$mn:000079DC var_4           = dword ptr -4
.text$mn:000079DC arg_0           = dword ptr  8
.text$mn:000079DC
.text$mn:000079DC                 push    ebp
.text$mn:000079DD                 mov     ebp, esp
.text$mn:000079DF                 push    ecx
.text$mn:000079E0                 mov     [ebp+var_4], ecx
.text$mn:000079E3                 mov     eax, [ebp+arg_0]
.text$mn:000079E6                 push    eax
.text$mn:000079E7                 mov     ecx, [ebp+var_4]
.text$mn:000079EA                 call    ?allocate@?$allocator@UToken@@@std@@QAEPAUToken@@I@Z ; std::allocator<Token>::allocate(uint)
.text$mn:000079EF                 mov     esp, ebp
.text$mn:000079F1                 pop     ebp
.text$mn:000079F2                 retn    4
.text$mn:000079F2 ?allocate@?$_Wrap_alloc@V?$allocator@UToken@@@std@@@std@@QAEPAUToken@@I@Z endp
.text$mn:000079F2
.text$mn:000079F2 ; ---------------------------------------------------------------------------
.text$mn:000079F5                 align 4
.text$mn:000079F5 _text$mn        ends
.text$mn:000079F5
.text$mn:000079F8 ; ===========================================================================
.text$mn:000079F8
.text$mn:000079F8 ; Segment type: Pure code
.text$mn:000079F8 ; Segment permissions: Read/Execute
.text$mn:000079F8 _text$mn        segment para public 'CODE' use32
.text$mn:000079F8                 assume cs:_text$mn
.text$mn:000079F8                 ;org 79F8h
.text$mn:000079F8 ; COMDAT (pick any)
.text$mn:000079F8                 assume es:nothing, ss:nothing, ds:_data, fs:nothing, gs:nothing
.text$mn:000079F8
.text$mn:000079F8 ; =============== S U B R O U T I N E =======================================
.text$mn:000079F8
.text$mn:000079F8 ; Attributes: bp-based frame
.text$mn:000079F8
.text$mn:000079F8 ; public: struct std::_Container_proxy * __thiscall std::_Wrap_alloc<class std::allocator<struct std::_Container_proxy>>::allocate(unsigned int)
.text$mn:000079F8                 public ?allocate@?$_Wrap_alloc@V?$allocator@U_Container_proxy@std@@@std@@@std@@QAEPAU_Container_proxy@2@I@Z
.text$mn:000079F8 ?allocate@?$_Wrap_alloc@V?$allocator@U_Container_proxy@std@@@std@@@std@@QAEPAU_Container_proxy@2@I@Z proc near
.text$mn:000079F8                                         ; CODE XREF: std::_Vector_alloc<0,std::_Vec_base_types<wchar_t const *,std::allocator<wchar_t const *>>>::_Alloc_proxy(void)+16p
.text$mn:000079F8                                         ; std::_Vector_alloc<0,std::_Vec_base_types<FunctionValues,std::allocator<FunctionValues>>>::_Alloc_proxy(void)+16p ...
.text$mn:000079F8
.text$mn:000079F8 var_4           = dword ptr -4
.text$mn:000079F8 arg_0           = dword ptr  8
.text$mn:000079F8
.text$mn:000079F8                 push    ebp
.text$mn:000079F9                 mov     ebp, esp
.text$mn:000079FB                 push    ecx
.text$mn:000079FC                 mov     [ebp+var_4], ecx
.text$mn:000079FF                 mov     eax, [ebp+arg_0]
.text$mn:00007A02                 push    eax
.text$mn:00007A03                 mov     ecx, [ebp+var_4]
.text$mn:00007A06                 call    ?allocate@?$allocator@U_Container_proxy@std@@@std@@QAEPAU_Container_proxy@2@I@Z ; std::allocator<std::_Container_proxy>::allocate(uint)
.text$mn:00007A0B                 mov     esp, ebp
.text$mn:00007A0D                 pop     ebp
.text$mn:00007A0E                 retn    4
.text$mn:00007A0E ?allocate@?$_Wrap_alloc@V?$allocator@U_Container_proxy@std@@@std@@@std@@QAEPAU_Container_proxy@2@I@Z endp
.text$mn:00007A0E
.text$mn:00007A0E ; ---------------------------------------------------------------------------
.text$mn:00007A11                 align 4
.text$mn:00007A11 _text$mn        ends
.text$mn:00007A11
.text$mn:00007A14 ; ===========================================================================
.text$mn:00007A14
.text$mn:00007A14 ; Segment type: Pure code
.text$mn:00007A14 ; Segment permissions: Read/Execute
.text$mn:00007A14 _text$mn        segment para public 'CODE' use32
.text$mn:00007A14                 assume cs:_text$mn
.text$mn:00007A14                 ;org 7A14h
.text$mn:00007A14 ; COMDAT (pick any)
.text$mn:00007A14                 assume es:nothing, ss:nothing, ds:_data, fs:nothing, gs:nothing
.text$mn:00007A14
.text$mn:00007A14 ; =============== S U B R O U T I N E =======================================
.text$mn:00007A14
.text$mn:00007A14 ; Attributes: bp-based frame
.text$mn:00007A14
.text$mn:00007A14 ; public: class std::vector<wchar_t const *, class std::allocator<wchar_t const *>> * __thiscall std::_Wrap_alloc<class std::allocator<class std::vector<wchar_t const *, class std::allocator<wchar_t const *>>>>::allocate(unsigned int)
.text$mn:00007A14                 public ?allocate@?$_Wrap_alloc@V?$allocator@V?$vector@PB_WV?$allocator@PB_W@std@@@std@@@std@@@std@@QAEPAV?$vector@PB_WV?$allocator@PB_W@std@@@2@I@Z
.text$mn:00007A14 ?allocate@?$_Wrap_alloc@V?$allocator@V?$vector@PB_WV?$allocator@PB_W@std@@@std@@@std@@@std@@QAEPAV?$vector@PB_WV?$allocator@PB_W@std@@@2@I@Z proc near
.text$mn:00007A14                                         ; CODE XREF: std::vector<std::vector<wchar_t const *,std::allocator<wchar_t const *>>,std::allocator<std::vector<wchar_t const *,std::allocator<wchar_t const *>>>>::_Reallocate(uint)+41p
.text$mn:00007A14
.text$mn:00007A14 var_4           = dword ptr -4
.text$mn:00007A14 arg_0           = dword ptr  8
.text$mn:00007A14
.text$mn:00007A14                 push    ebp
.text$mn:00007A15                 mov     ebp, esp
.text$mn:00007A17                 push    ecx
.text$mn:00007A18                 mov     [ebp+var_4], ecx
.text$mn:00007A1B                 mov     eax, [ebp+arg_0]
.text$mn:00007A1E                 push    eax
.text$mn:00007A1F                 mov     ecx, [ebp+var_4]
.text$mn:00007A22                 call    ?allocate@?$allocator@V?$vector@PB_WV?$allocator@PB_W@std@@@std@@@std@@QAEPAV?$vector@PB_WV?$allocator@PB_W@std@@@2@I@Z ; std::allocator<std::vector<wchar_t const *,std::allocator<wchar_t const *>>>::allocate(uint)
.text$mn:00007A27                 mov     esp, ebp
.text$mn:00007A29                 pop     ebp
.text$mn:00007A2A                 retn    4
.text$mn:00007A2A ?allocate@?$_Wrap_alloc@V?$allocator@V?$vector@PB_WV?$allocator@PB_W@std@@@std@@@std@@@std@@QAEPAV?$vector@PB_WV?$allocator@PB_W@std@@@2@I@Z endp
.text$mn:00007A2A
.text$mn:00007A2A ; ---------------------------------------------------------------------------
.text$mn:00007A2D                 align 10h
.text$mn:00007A2D _text$mn        ends
.text$mn:00007A2D
.text$mn:00007A30 ; ===========================================================================
.text$mn:00007A30
.text$mn:00007A30 ; Segment type: Pure code
.text$mn:00007A30 ; Segment permissions: Read/Execute
.text$mn:00007A30 _text$mn        segment para public 'CODE' use32
.text$mn:00007A30                 assume cs:_text$mn
.text$mn:00007A30                 ;org 7A30h
.text$mn:00007A30 ; COMDAT (pick any)
.text$mn:00007A30                 assume es:nothing, ss:nothing, ds:_data, fs:nothing, gs:nothing
.text$mn:00007A30
.text$mn:00007A30 ; =============== S U B R O U T I N E =======================================
.text$mn:00007A30
.text$mn:00007A30 ; Attributes: bp-based frame
.text$mn:00007A30
.text$mn:00007A30 ; public: char * __thiscall std::allocator<char>::allocate(unsigned int)
.text$mn:00007A30                 public ?allocate@?$allocator@D@std@@QAEPADI@Z
.text$mn:00007A30 ?allocate@?$allocator@D@std@@QAEPADI@Z proc near
.text$mn:00007A30                                         ; CODE XREF: std::_Wrap_alloc<std::allocator<char>>::allocate(uint)+Ep
.text$mn:00007A30
.text$mn:00007A30 var_4           = dword ptr -4
.text$mn:00007A30 arg_0           = dword ptr  8
.text$mn:00007A30
.text$mn:00007A30                 push    ebp
.text$mn:00007A31                 mov     ebp, esp
.text$mn:00007A33                 push    ecx
.text$mn:00007A34                 mov     [ebp+var_4], ecx
.text$mn:00007A37                 push    0
.text$mn:00007A39                 mov     eax, [ebp+arg_0]
.text$mn:00007A3C                 push    eax
.text$mn:00007A3D                 call    ??$_Allocate@D@std@@YAPADIPAD@Z ; std::_Allocate<char>(uint,char *)
.text$mn:00007A42                 add     esp, 8
.text$mn:00007A45                 mov     esp, ebp
.text$mn:00007A47                 pop     ebp
.text$mn:00007A48                 retn    4
.text$mn:00007A48 ?allocate@?$allocator@D@std@@QAEPADI@Z endp
.text$mn:00007A48
.text$mn:00007A48 ; ---------------------------------------------------------------------------
.text$mn:00007A4B                 align 4
.text$mn:00007A4B _text$mn        ends
.text$mn:00007A4B
.text$mn:00007A4C ; ===========================================================================
.text$mn:00007A4C
.text$mn:00007A4C ; Segment type: Pure code
.text$mn:00007A4C ; Segment permissions: Read/Execute
.text$mn:00007A4C _text$mn        segment para public 'CODE' use32
.text$mn:00007A4C                 assume cs:_text$mn
.text$mn:00007A4C                 ;org 7A4Ch
.text$mn:00007A4C ; COMDAT (pick any)
.text$mn:00007A4C                 assume es:nothing, ss:nothing, ds:_data, fs:nothing, gs:nothing
.text$mn:00007A4C
.text$mn:00007A4C ; =============== S U B R O U T I N E =======================================
.text$mn:00007A4C
.text$mn:00007A4C ; Attributes: bp-based frame
.text$mn:00007A4C
.text$mn:00007A4C ; public: wchar_t const * * __thiscall std::allocator<wchar_t const *>::allocate(unsigned int)
.text$mn:00007A4C                 public ?allocate@?$allocator@PB_W@std@@QAEPAPB_WI@Z
.text$mn:00007A4C ?allocate@?$allocator@PB_W@std@@QAEPAPB_WI@Z proc near
.text$mn:00007A4C                                         ; CODE XREF: std::_Wrap_alloc<std::allocator<wchar_t const *>>::allocate(uint)+Ep
.text$mn:00007A4C
.text$mn:00007A4C var_4           = dword ptr -4
.text$mn:00007A4C arg_0           = dword ptr  8
.text$mn:00007A4C
.text$mn:00007A4C                 push    ebp
.text$mn:00007A4D                 mov     ebp, esp
.text$mn:00007A4F                 push    ecx
.text$mn:00007A50                 mov     [ebp+var_4], ecx
.text$mn:00007A53                 push    0
.text$mn:00007A55                 mov     eax, [ebp+arg_0]
.text$mn:00007A58                 push    eax
.text$mn:00007A59                 call    ??$_Allocate@PB_W@std@@YAPAPB_WIPAPB_W@Z ; std::_Allocate<wchar_t const *>(uint,wchar_t const * *)
.text$mn:00007A5E                 add     esp, 8
.text$mn:00007A61                 mov     esp, ebp
.text$mn:00007A63                 pop     ebp
.text$mn:00007A64                 retn    4
.text$mn:00007A64 ?allocate@?$allocator@PB_W@std@@QAEPAPB_WI@Z endp
.text$mn:00007A64
.text$mn:00007A64 ; ---------------------------------------------------------------------------
.text$mn:00007A67                 align 4
.text$mn:00007A67 _text$mn        ends
.text$mn:00007A67
.text$mn:00007A68 ; ===========================================================================
.text$mn:00007A68
.text$mn:00007A68 ; Segment type: Pure code
.text$mn:00007A68 ; Segment permissions: Read/Execute
.text$mn:00007A68 _text$mn        segment para public 'CODE' use32
.text$mn:00007A68                 assume cs:_text$mn
.text$mn:00007A68                 ;org 7A68h
.text$mn:00007A68 ; COMDAT (pick any)
.text$mn:00007A68                 assume es:nothing, ss:nothing, ds:_data, fs:nothing, gs:nothing
.text$mn:00007A68
.text$mn:00007A68 ; =============== S U B R O U T I N E =======================================
.text$mn:00007A68
.text$mn:00007A68 ; Attributes: bp-based frame
.text$mn:00007A68
.text$mn:00007A68 ; public: struct FunctionValues * __thiscall std::allocator<struct FunctionValues>::allocate(unsigned int)
.text$mn:00007A68                 public ?allocate@?$allocator@UFunctionValues@@@std@@QAEPAUFunctionValues@@I@Z
.text$mn:00007A68 ?allocate@?$allocator@UFunctionValues@@@std@@QAEPAUFunctionValues@@I@Z proc near
.text$mn:00007A68                                         ; CODE XREF: std::_Wrap_alloc<std::allocator<FunctionValues>>::allocate(uint)+Ep
.text$mn:00007A68
.text$mn:00007A68 var_4           = dword ptr -4
.text$mn:00007A68 arg_0           = dword ptr  8
.text$mn:00007A68
.text$mn:00007A68                 push    ebp
.text$mn:00007A69                 mov     ebp, esp
.text$mn:00007A6B                 push    ecx
.text$mn:00007A6C                 mov     [ebp+var_4], ecx
.text$mn:00007A6F                 push    0
.text$mn:00007A71                 mov     eax, [ebp+arg_0]
.text$mn:00007A74                 push    eax
.text$mn:00007A75                 call    ??$_Allocate@UFunctionValues@@@std@@YAPAUFunctionValues@@IPAU1@@Z ; std::_Allocate<FunctionValues>(uint,FunctionValues *)
.text$mn:00007A7A                 add     esp, 8
.text$mn:00007A7D                 mov     esp, ebp
.text$mn:00007A7F                 pop     ebp
.text$mn:00007A80                 retn    4
.text$mn:00007A80 ?allocate@?$allocator@UFunctionValues@@@std@@QAEPAUFunctionValues@@I@Z endp
.text$mn:00007A80
.text$mn:00007A80 ; ---------------------------------------------------------------------------
.text$mn:00007A83                 align 4
.text$mn:00007A83 _text$mn        ends
.text$mn:00007A83
.text$mn:00007A84 ; ===========================================================================
.text$mn:00007A84
.text$mn:00007A84 ; Segment type: Pure code
.text$mn:00007A84 ; Segment permissions: Read/Execute
.text$mn:00007A84 _text$mn        segment para public 'CODE' use32
.text$mn:00007A84                 assume cs:_text$mn
.text$mn:00007A84                 ;org 7A84h
.text$mn:00007A84 ; COMDAT (pick any)
.text$mn:00007A84                 assume es:nothing, ss:nothing, ds:_data, fs:nothing, gs:nothing
.text$mn:00007A84
.text$mn:00007A84 ; =============== S U B R O U T I N E =======================================
.text$mn:00007A84
.text$mn:00007A84 ; Attributes: bp-based frame
.text$mn:00007A84
.text$mn:00007A84 ; public: struct Token * __thiscall std::allocator<struct Token>::allocate(unsigned int)
.text$mn:00007A84                 public ?allocate@?$allocator@UToken@@@std@@QAEPAUToken@@I@Z
.text$mn:00007A84 ?allocate@?$allocator@UToken@@@std@@QAEPAUToken@@I@Z proc near
.text$mn:00007A84                                         ; CODE XREF: std::_Wrap_alloc<std::allocator<Token>>::allocate(uint)+Ep
.text$mn:00007A84
.text$mn:00007A84 var_4           = dword ptr -4
.text$mn:00007A84 arg_0           = dword ptr  8
.text$mn:00007A84
.text$mn:00007A84                 push    ebp
.text$mn:00007A85                 mov     ebp, esp
.text$mn:00007A87                 push    ecx
.text$mn:00007A88                 mov     [ebp+var_4], ecx
.text$mn:00007A8B                 push    0
.text$mn:00007A8D                 mov     eax, [ebp+arg_0]
.text$mn:00007A90                 push    eax
.text$mn:00007A91                 call    ??$_Allocate@UToken@@@std@@YAPAUToken@@IPAU1@@Z ; std::_Allocate<Token>(uint,Token *)
.text$mn:00007A96                 add     esp, 8
.text$mn:00007A99                 mov     esp, ebp
.text$mn:00007A9B                 pop     ebp
.text$mn:00007A9C                 retn    4
.text$mn:00007A9C ?allocate@?$allocator@UToken@@@std@@QAEPAUToken@@I@Z endp
.text$mn:00007A9C
.text$mn:00007A9C ; ---------------------------------------------------------------------------
.text$mn:00007A9F                 align 10h
.text$mn:00007A9F _text$mn        ends
.text$mn:00007A9F
.text$mn:00007AA0 ; ===========================================================================
.text$mn:00007AA0
.text$mn:00007AA0 ; Segment type: Pure code
.text$mn:00007AA0 ; Segment permissions: Read/Execute
.text$mn:00007AA0 _text$mn        segment para public 'CODE' use32
.text$mn:00007AA0                 assume cs:_text$mn
.text$mn:00007AA0                 ;org 7AA0h
.text$mn:00007AA0 ; COMDAT (pick any)
.text$mn:00007AA0                 assume es:nothing, ss:nothing, ds:_data, fs:nothing, gs:nothing
.text$mn:00007AA0
.text$mn:00007AA0 ; =============== S U B R O U T I N E =======================================
.text$mn:00007AA0
.text$mn:00007AA0 ; Attributes: bp-based frame
.text$mn:00007AA0
.text$mn:00007AA0 ; public: struct std::_Container_proxy * __thiscall std::allocator<struct std::_Container_proxy>::allocate(unsigned int)
.text$mn:00007AA0                 public ?allocate@?$allocator@U_Container_proxy@std@@@std@@QAEPAU_Container_proxy@2@I@Z
.text$mn:00007AA0 ?allocate@?$allocator@U_Container_proxy@std@@@std@@QAEPAU_Container_proxy@2@I@Z proc near
.text$mn:00007AA0                                         ; CODE XREF: std::_String_alloc<0,std::_String_base_types<char,std::allocator<char>>>::_Alloc_proxy(void)+16p
.text$mn:00007AA0                                         ; std::_Wrap_alloc<std::allocator<std::_Container_proxy>>::allocate(uint)+Ep
.text$mn:00007AA0
.text$mn:00007AA0 var_4           = dword ptr -4
.text$mn:00007AA0 arg_0           = dword ptr  8
.text$mn:00007AA0
.text$mn:00007AA0                 push    ebp
.text$mn:00007AA1                 mov     ebp, esp
.text$mn:00007AA3                 push    ecx
.text$mn:00007AA4                 mov     [ebp+var_4], ecx
.text$mn:00007AA7                 push    0
.text$mn:00007AA9                 mov     eax, [ebp+arg_0]
.text$mn:00007AAC                 push    eax
.text$mn:00007AAD                 call    ??$_Allocate@U_Container_proxy@std@@@std@@YAPAU_Container_proxy@0@IPAU10@@Z ; std::_Allocate<std::_Container_proxy>(uint,std::_Container_proxy *)
.text$mn:00007AB2                 add     esp, 8
.text$mn:00007AB5                 mov     esp, ebp
.text$mn:00007AB7                 pop     ebp
.text$mn:00007AB8                 retn    4
.text$mn:00007AB8 ?allocate@?$allocator@U_Container_proxy@std@@@std@@QAEPAU_Container_proxy@2@I@Z endp
.text$mn:00007AB8
.text$mn:00007AB8 ; ---------------------------------------------------------------------------
.text$mn:00007ABB                 align 4
.text$mn:00007ABB _text$mn        ends
.text$mn:00007ABB
.text$mn:00007ABC ; ===========================================================================
.text$mn:00007ABC
.text$mn:00007ABC ; Segment type: Pure code
.text$mn:00007ABC ; Segment permissions: Read/Execute
.text$mn:00007ABC _text$mn        segment para public 'CODE' use32
.text$mn:00007ABC                 assume cs:_text$mn
.text$mn:00007ABC                 ;org 7ABCh
.text$mn:00007ABC ; COMDAT (pick any)
.text$mn:00007ABC                 assume es:nothing, ss:nothing, ds:_data, fs:nothing, gs:nothing
.text$mn:00007ABC
.text$mn:00007ABC ; =============== S U B R O U T I N E =======================================
.text$mn:00007ABC
.text$mn:00007ABC ; Attributes: bp-based frame
.text$mn:00007ABC
.text$mn:00007ABC ; public: class std::vector<wchar_t const *, class std::allocator<wchar_t const *>> * __thiscall std::allocator<class std::vector<wchar_t const *, class std::allocator<wchar_t const *>>>::allocate(unsigned int)
.text$mn:00007ABC                 public ?allocate@?$allocator@V?$vector@PB_WV?$allocator@PB_W@std@@@std@@@std@@QAEPAV?$vector@PB_WV?$allocator@PB_W@std@@@2@I@Z
.text$mn:00007ABC ?allocate@?$allocator@V?$vector@PB_WV?$allocator@PB_W@std@@@std@@@std@@QAEPAV?$vector@PB_WV?$allocator@PB_W@std@@@2@I@Z proc near
.text$mn:00007ABC                                         ; CODE XREF: std::_Wrap_alloc<std::allocator<std::vector<wchar_t const *,std::allocator<wchar_t const *>>>>::allocate(uint)+Ep
.text$mn:00007ABC
.text$mn:00007ABC var_4           = dword ptr -4
.text$mn:00007ABC arg_0           = dword ptr  8
.text$mn:00007ABC
.text$mn:00007ABC                 push    ebp
.text$mn:00007ABD                 mov     ebp, esp
.text$mn:00007ABF                 push    ecx
.text$mn:00007AC0                 mov     [ebp+var_4], ecx
.text$mn:00007AC3                 push    0
.text$mn:00007AC5                 mov     eax, [ebp+arg_0]
.text$mn:00007AC8                 push    eax
.text$mn:00007AC9                 call    ??$_Allocate@V?$vector@PB_WV?$allocator@PB_W@std@@@std@@@std@@YAPAV?$vector@PB_WV?$allocator@PB_W@std@@@0@IPAV10@@Z ; std::_Allocate<std::vector<wchar_t const *,std::allocator<wchar_t const *>>>(uint,std::vector<wchar_t const *,std::allocator<wchar_t const *>> *)
.text$mn:00007ACE                 add     esp, 8
.text$mn:00007AD1                 mov     esp, ebp
.text$mn:00007AD3                 pop     ebp
.text$mn:00007AD4                 retn    4
.text$mn:00007AD4 ?allocate@?$allocator@V?$vector@PB_WV?$allocator@PB_W@std@@@std@@@std@@QAEPAV?$vector@PB_WV?$allocator@PB_W@std@@@2@I@Z endp
.text$mn:00007AD4
.text$mn:00007AD4 ; ---------------------------------------------------------------------------
.text$mn:00007AD7                 align 4
.text$mn:00007AD7 _text$mn        ends
.text$mn:00007AD7
.text$mn:00007AD8 ; ===========================================================================
.text$mn:00007AD8
.text$mn:00007AD8 ; Segment type: Pure code
.text$mn:00007AD8 ; Segment permissions: Read/Execute
.text$mn:00007AD8 _text$mn        segment para public 'CODE' use32
.text$mn:00007AD8                 assume cs:_text$mn
.text$mn:00007AD8                 ;org 7AD8h
.text$mn:00007AD8 ; COMDAT (pick any)
.text$mn:00007AD8                 assume es:nothing, ss:nothing, ds:_data, fs:nothing, gs:nothing
.text$mn:00007AD8
.text$mn:00007AD8 ; =============== S U B R O U T I N E =======================================
.text$mn:00007AD8
.text$mn:00007AD8 ; Attributes: bp-based frame
.text$mn:00007AD8
.text$mn:00007AD8 ; public: class std::basic_string<char, struct std::char_traits<char>, class std::allocator<char>> & __thiscall std::basic_string<char, struct std::char_traits<char>, class std::allocator<char>>::assign(class std::basic_string<char, struct std::char_traits<char>, class std::allocator<char>> const &, unsigned int, unsigned int)
.text$mn:00007AD8                 public ?assign@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV12@ABV12@II@Z
.text$mn:00007AD8 ?assign@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV12@ABV12@II@Z proc near
.text$mn:00007AD8                                         ; CODE XREF: std::basic_string<char,std::char_traits<char>,std::allocator<char>>::assign(char const *,uint)+4Fp
.text$mn:00007AD8
.text$mn:00007AD8 Size            = dword ptr -8
.text$mn:00007AD8 var_4           = dword ptr -4
.text$mn:00007AD8 arg_0           = dword ptr  8
.text$mn:00007AD8 arg_4           = dword ptr  0Ch
.text$mn:00007AD8 arg_8           = dword ptr  10h
.text$mn:00007AD8
.text$mn:00007AD8                 push    ebp
.text$mn:00007AD9                 mov     ebp, esp
.text$mn:00007ADB                 sub     esp, 8
.text$mn:00007ADE                 mov     [ebp+var_4], ecx
.text$mn:00007AE1                 mov     ecx, [ebp+arg_0]
.text$mn:00007AE4                 call    ?size@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QBEIXZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char>>::size(void)
.text$mn:00007AE9                 cmp     eax, [ebp+arg_4]
.text$mn:00007AEC                 jnb     short loc_7AF6
.text$mn:00007AEE                 mov     ecx, [ebp+var_4]
.text$mn:00007AF1                 call    ?_Xran@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QBEXXZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char>>::_Xran(void)
.text$mn:00007AF6
.text$mn:00007AF6 loc_7AF6:                               ; CODE XREF: std::basic_string<char,std::char_traits<char>,std::allocator<char>>::assign(std::basic_string<char,std::char_traits<char>,std::allocator<char>> const &,uint,uint)+14j
.text$mn:00007AF6                 mov     ecx, [ebp+arg_0]
.text$mn:00007AF9                 call    ?size@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QBEIXZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char>>::size(void)
.text$mn:00007AFE                 sub     eax, [ebp+arg_4]
.text$mn:00007B01                 mov     [ebp+Size], eax
.text$mn:00007B04                 mov     eax, [ebp+arg_8]
.text$mn:00007B07                 cmp     eax, [ebp+Size]
.text$mn:00007B0A                 jnb     short loc_7B12
.text$mn:00007B0C                 mov     ecx, [ebp+arg_8]
.text$mn:00007B0F                 mov     [ebp+Size], ecx
.text$mn:00007B12
.text$mn:00007B12 loc_7B12:                               ; CODE XREF: std::basic_string<char,std::char_traits<char>,std::allocator<char>>::assign(std::basic_string<char,std::char_traits<char>,std::allocator<char>> const &,uint,uint)+32j
.text$mn:00007B12                 mov     edx, [ebp+var_4]
.text$mn:00007B15                 cmp     edx, [ebp+arg_0]
.text$mn:00007B18                 jnz     short loc_7B39
.text$mn:00007B1A                 mov     eax, [ebp+arg_4]
.text$mn:00007B1D                 add     eax, [ebp+Size]
.text$mn:00007B20                 push    eax
.text$mn:00007B21                 mov     ecx, [ebp+var_4]
.text$mn:00007B24                 call    ?erase@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV12@I@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char>>::erase(uint)
.text$mn:00007B29                 mov     ecx, [ebp+arg_4]
.text$mn:00007B2C                 push    ecx
.text$mn:00007B2D                 push    0
.text$mn:00007B2F                 mov     ecx, [ebp+var_4]
.text$mn:00007B32                 call    ?erase@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV12@II@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char>>::erase(uint,uint)
.text$mn:00007B37                 jmp     short loc_7B7B
.text$mn:00007B39 ; ---------------------------------------------------------------------------
.text$mn:00007B39
.text$mn:00007B39 loc_7B39:                               ; CODE XREF: std::basic_string<char,std::char_traits<char>,std::allocator<char>>::assign(std::basic_string<char,std::char_traits<char>,std::allocator<char>> const &,uint,uint)+40j
.text$mn:00007B39                 push    0
.text$mn:00007B3B                 mov     edx, [ebp+Size]
.text$mn:00007B3E                 push    edx
.text$mn:00007B3F                 mov     ecx, [ebp+var_4]
.text$mn:00007B42                 call    ?_Grow@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE_NI_N@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char>>::_Grow(uint,bool)
.text$mn:00007B47                 movzx   eax, al
.text$mn:00007B4A                 test    eax, eax
.text$mn:00007B4C                 jz      short loc_7B7B
.text$mn:00007B4E                 mov     ecx, [ebp+Size]
.text$mn:00007B51                 push    ecx             ; Size
.text$mn:00007B52                 mov     ecx, [ebp+arg_0]
.text$mn:00007B55                 call    ?_Myptr@?$_String_val@U?$_Simple_types@D@std@@@std@@QBEPBDXZ ; std::_String_val<std::_Simple_types<char>>::_Myptr(void)
.text$mn:00007B5A                 add     eax, [ebp+arg_4]
.text$mn:00007B5D                 push    eax             ; Src
.text$mn:00007B5E                 mov     ecx, [ebp+var_4]
.text$mn:00007B61                 call    ?_Myptr@?$_String_val@U?$_Simple_types@D@std@@@std@@QAEPADXZ ; std::_String_val<std::_Simple_types<char>>::_Myptr(void)
.text$mn:00007B66                 push    eax             ; Dst
.text$mn:00007B67                 call    ?copy@?$char_traits@D@std@@SAPADPADPBDI@Z ; std::char_traits<char>::copy(char *,char const *,uint)
.text$mn:00007B6C                 add     esp, 0Ch
.text$mn:00007B6F                 mov     edx, [ebp+Size]
.text$mn:00007B72                 push    edx
.text$mn:00007B73                 mov     ecx, [ebp+var_4]
.text$mn:00007B76                 call    ?_Eos@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEXI@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char>>::_Eos(uint)
.text$mn:00007B7B
.text$mn:00007B7B loc_7B7B:                               ; CODE XREF: std::basic_string<char,std::char_traits<char>,std::allocator<char>>::assign(std::basic_string<char,std::char_traits<char>,std::allocator<char>> const &,uint,uint)+5Fj
.text$mn:00007B7B                                         ; std::basic_string<char,std::char_traits<char>,std::allocator<char>>::assign(std::basic_string<char,std::char_traits<char>,std::allocator<char>> const &,uint,uint)+74j
.text$mn:00007B7B                 mov     eax, [ebp+var_4]
.text$mn:00007B7E                 mov     esp, ebp
.text$mn:00007B80                 pop     ebp
.text$mn:00007B81                 retn    0Ch
.text$mn:00007B81 ?assign@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV12@ABV12@II@Z endp
.text$mn:00007B81
.text$mn:00007B81 _text$mn        ends
.text$mn:00007B81
.text$mn:00007B84 ; ===========================================================================
.text$mn:00007B84
.text$mn:00007B84 ; Segment type: Pure code
.text$mn:00007B84 ; Segment permissions: Read/Execute
.text$mn:00007B84 _text$mn        segment para public 'CODE' use32
.text$mn:00007B84                 assume cs:_text$mn
.text$mn:00007B84                 ;org 7B84h
.text$mn:00007B84 ; COMDAT (pick any)
.text$mn:00007B84                 assume es:nothing, ss:nothing, ds:_data, fs:nothing, gs:nothing
.text$mn:00007B84
.text$mn:00007B84 ; =============== S U B R O U T I N E =======================================
.text$mn:00007B84
.text$mn:00007B84 ; Attributes: bp-based frame
.text$mn:00007B84
.text$mn:00007B84 ; int __stdcall std::basic_string<char,std::char_traits<char>,std::allocator<char>>::assign(char *Str)
.text$mn:00007B84                 public ?assign@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV12@PBD@Z
.text$mn:00007B84 ?assign@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV12@PBD@Z proc near
.text$mn:00007B84                                         ; CODE XREF: std::basic_string<char,std::char_traits<char>,std::allocator<char>>::basic_string<char,std::char_traits<char>,std::allocator<char>>(char const *)+53p
.text$mn:00007B84
.text$mn:00007B84 var_4           = dword ptr -4
.text$mn:00007B84 Str             = dword ptr  8
.text$mn:00007B84
.text$mn:00007B84                 push    ebp
.text$mn:00007B85                 mov     ebp, esp
.text$mn:00007B87                 push    ecx
.text$mn:00007B88                 mov     [ebp+var_4], ecx
.text$mn:00007B8B                 push    490h            ; unsigned int
.text$mn:00007B90                 push    offset ??_C@_1IO@FEAPGJBD@?$AAC?$AA?3?$AA?2?$AAP?$AAr?$AAo?$AAg?$AAr?$AAa?$AAm?$AA?5?$AAF?$AAi?$AAl?$AAe?$AAs?$AA?5?$AA?$CI?$AAx?$AA8?$AA6?$AA?$CJ?$AA?2?$AAM?$AAi?$AAc?$AAr?$AAo?$AAs?$AAo?$AAf?$AAt@ ; "C:\\Program Files (x86)\\Microsoft Visu"...
.text$mn:00007B95                 mov     eax, [ebp+Str]
.text$mn:00007B98                 push    eax             ; int
.text$mn:00007B99                 call    ??$_Debug_pointer@D@std@@YAXPBDPB_WI@Z ; std::_Debug_pointer<char>(char const *,wchar_t const *,uint)
.text$mn:00007B9E                 add     esp, 0Ch
.text$mn:00007BA1                 mov     ecx, [ebp+Str]
.text$mn:00007BA4                 push    ecx             ; Str
.text$mn:00007BA5                 call    ?length@?$char_traits@D@std@@SAIPBD@Z ; std::char_traits<char>::length(char const *)
.text$mn:00007BAA                 add     esp, 4
.text$mn:00007BAD                 push    eax             ; Size
.text$mn:00007BAE                 mov     edx, [ebp+Str]
.text$mn:00007BB1                 push    edx             ; Src
.text$mn:00007BB2                 mov     ecx, [ebp+var_4]
.text$mn:00007BB5                 call    ?assign@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV12@PBDI@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char>>::assign(char const *,uint)
.text$mn:00007BBA                 mov     esp, ebp
.text$mn:00007BBC                 pop     ebp
.text$mn:00007BBD                 retn    4
.text$mn:00007BBD ?assign@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV12@PBD@Z endp
.text$mn:00007BBD
.text$mn:00007BBD _text$mn        ends
.text$mn:00007BBD
.text$mn:00007BC0 ; ===========================================================================
.text$mn:00007BC0
.text$mn:00007BC0 ; Segment type: Pure code
.text$mn:00007BC0 ; Segment permissions: Read/Execute
.text$mn:00007BC0 _text$mn        segment para public 'CODE' use32
.text$mn:00007BC0                 assume cs:_text$mn
.text$mn:00007BC0                 ;org 7BC0h
.text$mn:00007BC0 ; COMDAT (pick any)
.text$mn:00007BC0                 assume es:nothing, ss:nothing, ds:_data, fs:nothing, gs:nothing
.text$mn:00007BC0
.text$mn:00007BC0 ; =============== S U B R O U T I N E =======================================
.text$mn:00007BC0
.text$mn:00007BC0 ; Attributes: bp-based frame
.text$mn:00007BC0
.text$mn:00007BC0 ; int __stdcall std::basic_string<char,std::char_traits<char>,std::allocator<char>>::assign(void *Src, size_t Size)
.text$mn:00007BC0                 public ?assign@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV12@PBDI@Z
.text$mn:00007BC0 ?assign@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV12@PBDI@Z proc near
.text$mn:00007BC0                                         ; CODE XREF: std::basic_string<char,std::char_traits<char>,std::allocator<char>>::assign(char const *)+31p
.text$mn:00007BC0
.text$mn:00007BC0 var_4           = dword ptr -4
.text$mn:00007BC0 Src             = dword ptr  8
.text$mn:00007BC0 Size            = dword ptr  0Ch
.text$mn:00007BC0
.text$mn:00007BC0                 push    ebp
.text$mn:00007BC1                 mov     ebp, esp
.text$mn:00007BC3                 push    ecx
.text$mn:00007BC4                 mov     [ebp+var_4], ecx
.text$mn:00007BC7                 cmp     [ebp+Size], 0
.text$mn:00007BCB                 jz      short loc_7BE3
.text$mn:00007BCD                 push    47Fh            ; unsigned int
.text$mn:00007BD2                 push    offset ??_C@_1IO@FEAPGJBD@?$AAC?$AA?3?$AA?2?$AAP?$AAr?$AAo?$AAg?$AAr?$AAa?$AAm?$AA?5?$AAF?$AAi?$AAl?$AAe?$AAs?$AA?5?$AA?$CI?$AAx?$AA8?$AA6?$AA?$CJ?$AA?2?$AAM?$AAi?$AAc?$AAr?$AAo?$AAs?$AAo?$AAf?$AAt@ ; "C:\\Program Files (x86)\\Microsoft Visu"...
.text$mn:00007BD7                 mov     eax, [ebp+Src]
.text$mn:00007BDA                 push    eax             ; int
.text$mn:00007BDB                 call    ??$_Debug_pointer@D@std@@YAXPBDPB_WI@Z ; std::_Debug_pointer<char>(char const *,wchar_t const *,uint)
.text$mn:00007BE0                 add     esp, 0Ch
.text$mn:00007BE3
.text$mn:00007BE3 loc_7BE3:                               ; CODE XREF: std::basic_string<char,std::char_traits<char>,std::allocator<char>>::assign(char const *,uint)+Bj
.text$mn:00007BE3                 mov     ecx, [ebp+Src]
.text$mn:00007BE6                 push    ecx
.text$mn:00007BE7                 mov     ecx, [ebp+var_4]
.text$mn:00007BEA                 call    ?_Inside@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE_NPBD@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char>>::_Inside(char const *)
.text$mn:00007BEF                 movzx   edx, al
.text$mn:00007BF2                 test    edx, edx
.text$mn:00007BF4                 jz      short loc_7C16
.text$mn:00007BF6                 mov     eax, [ebp+Size]
.text$mn:00007BF9                 push    eax
.text$mn:00007BFA                 mov     ecx, [ebp+var_4]
.text$mn:00007BFD                 call    ?_Myptr@?$_String_val@U?$_Simple_types@D@std@@@std@@QAEPADXZ ; std::_String_val<std::_Simple_types<char>>::_Myptr(void)
.text$mn:00007C02                 mov     ecx, [ebp+Src]
.text$mn:00007C05                 sub     ecx, eax
.text$mn:00007C07                 push    ecx
.text$mn:00007C08                 mov     edx, [ebp+var_4]
.text$mn:00007C0B                 push    edx
.text$mn:00007C0C                 mov     ecx, [ebp+var_4]
.text$mn:00007C0F                 call    ?assign@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV12@ABV12@II@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char>>::assign(std::basic_string<char,std::char_traits<char>,std::allocator<char>> const &,uint,uint)
.text$mn:00007C14                 jmp     short loc_7C53
.text$mn:00007C16 ; ---------------------------------------------------------------------------
.text$mn:00007C16
.text$mn:00007C16 loc_7C16:                               ; CODE XREF: std::basic_string<char,std::char_traits<char>,std::allocator<char>>::assign(char const *,uint)+34j
.text$mn:00007C16                 push    0
.text$mn:00007C18                 mov     eax, [ebp+Size]
.text$mn:00007C1B                 push    eax
.text$mn:00007C1C                 mov     ecx, [ebp+var_4]
.text$mn:00007C1F                 call    ?_Grow@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE_NI_N@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char>>::_Grow(uint,bool)
.text$mn:00007C24                 movzx   ecx, al
.text$mn:00007C27                 test    ecx, ecx
.text$mn:00007C29                 jz      short loc_7C50
.text$mn:00007C2B                 mov     edx, [ebp+Size]
.text$mn:00007C2E                 push    edx             ; Size
.text$mn:00007C2F                 mov     eax, [ebp+Src]
.text$mn:00007C32                 push    eax             ; Src
.text$mn:00007C33                 mov     ecx, [ebp+var_4]
.text$mn:00007C36                 call    ?_Myptr@?$_String_val@U?$_Simple_types@D@std@@@std@@QAEPADXZ ; std::_String_val<std::_Simple_types<char>>::_Myptr(void)
.text$mn:00007C3B                 push    eax             ; Dst
.text$mn:00007C3C                 call    ?copy@?$char_traits@D@std@@SAPADPADPBDI@Z ; std::char_traits<char>::copy(char *,char const *,uint)
.text$mn:00007C41                 add     esp, 0Ch
.text$mn:00007C44                 mov     ecx, [ebp+Size]
.text$mn:00007C47                 push    ecx
.text$mn:00007C48                 mov     ecx, [ebp+var_4]
.text$mn:00007C4B                 call    ?_Eos@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEXI@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char>>::_Eos(uint)
.text$mn:00007C50
.text$mn:00007C50 loc_7C50:                               ; CODE XREF: std::basic_string<char,std::char_traits<char>,std::allocator<char>>::assign(char const *,uint)+69j
.text$mn:00007C50                 mov     eax, [ebp+var_4]
.text$mn:00007C53
.text$mn:00007C53 loc_7C53:                               ; CODE XREF: std::basic_string<char,std::char_traits<char>,std::allocator<char>>::assign(char const *,uint)+54j
.text$mn:00007C53                 mov     esp, ebp
.text$mn:00007C55                 pop     ebp
.text$mn:00007C56                 retn    8
.text$mn:00007C56 ?assign@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV12@PBDI@Z endp
.text$mn:00007C56
.text$mn:00007C56 ; ---------------------------------------------------------------------------
.text$mn:00007C59                 align 4
.text$mn:00007C59 _text$mn        ends
.text$mn:00007C59
.text$mn:00007C5C ; ===========================================================================
.text$mn:00007C5C
.text$mn:00007C5C ; Segment type: Pure code
.text$mn:00007C5C ; Segment permissions: Read/Execute
.text$mn:00007C5C _text$mn        segment para public 'CODE' use32
.text$mn:00007C5C                 assume cs:_text$mn
.text$mn:00007C5C                 ;org 7C5Ch
.text$mn:00007C5C ; COMDAT (pick any)
.text$mn:00007C5C                 assume es:nothing, ss:nothing, ds:_data, fs:nothing, gs:nothing
.text$mn:00007C5C
.text$mn:00007C5C ; =============== S U B R O U T I N E =======================================
.text$mn:00007C5C
.text$mn:00007C5C ; Attributes: bp-based frame
.text$mn:00007C5C
.text$mn:00007C5C ; public: static void __cdecl std::char_traits<char>::assign(char &, char const &)
.text$mn:00007C5C                 public ?assign@?$char_traits@D@std@@SAXAADABD@Z
.text$mn:00007C5C ?assign@?$char_traits@D@std@@SAXAADABD@Z proc near
.text$mn:00007C5C                                         ; CODE XREF: std::basic_string<char,std::char_traits<char>,std::allocator<char>>::_Eos(uint)+26p
.text$mn:00007C5C
.text$mn:00007C5C arg_0           = dword ptr  8
.text$mn:00007C5C arg_4           = dword ptr  0Ch
.text$mn:00007C5C
.text$mn:00007C5C                 push    ebp
.text$mn:00007C5D                 mov     ebp, esp
.text$mn:00007C5F                 mov     eax, [ebp+arg_0]
.text$mn:00007C62                 mov     ecx, [ebp+arg_4]
.text$mn:00007C65                 mov     dl, [ecx]
.text$mn:00007C67                 mov     [eax], dl
.text$mn:00007C69                 pop     ebp
.text$mn:00007C6A                 retn
.text$mn:00007C6A ?assign@?$char_traits@D@std@@SAXAADABD@Z endp
.text$mn:00007C6A
.text$mn:00007C6A ; ---------------------------------------------------------------------------
.text$mn:00007C6B                 align 4
.text$mn:00007C6B _text$mn        ends
.text$mn:00007C6B
.text$mn:00007C6C ; ===========================================================================
.text$mn:00007C6C
.text$mn:00007C6C ; Segment type: Pure code
.text$mn:00007C6C ; Segment permissions: Read/Execute
.text$mn:00007C6C _text$mn        segment para public 'CODE' use32
.text$mn:00007C6C                 assume cs:_text$mn
.text$mn:00007C6C                 ;org 7C6Ch
.text$mn:00007C6C ; COMDAT (pick any)
.text$mn:00007C6C                 assume es:nothing, ss:nothing, ds:_data, fs:nothing, gs:nothing
.text$mn:00007C6C
.text$mn:00007C6C ; =============== S U B R O U T I N E =======================================
.text$mn:00007C6C
.text$mn:00007C6C ; Attributes: bp-based frame
.text$mn:00007C6C
.text$mn:00007C6C ; public: wchar_t const * & __thiscall std::vector<wchar_t const *, class std::allocator<wchar_t const *>>::at(unsigned int)
.text$mn:00007C6C                 public ?at@?$vector@PB_WV?$allocator@PB_W@std@@@std@@QAEAAPB_WI@Z
.text$mn:00007C6C ?at@?$vector@PB_WV?$allocator@PB_W@std@@@std@@QAEAAPB_WI@Z proc near
.text$mn:00007C6C                                         ; CODE XREF: FunctionCallTip::showCalltip(void)+10Fp
.text$mn:00007C6C                                         ; FunctionCallTip::showCalltip(void)+12Fp ...
.text$mn:00007C6C
.text$mn:00007C6C var_4           = dword ptr -4
.text$mn:00007C6C arg_0           = dword ptr  8
.text$mn:00007C6C
.text$mn:00007C6C                 push    ebp
.text$mn:00007C6D                 mov     ebp, esp
.text$mn:00007C6F                 push    ecx
.text$mn:00007C70                 mov     [ebp+var_4], ecx
.text$mn:00007C73                 mov     ecx, [ebp+var_4]
.text$mn:00007C76                 call    ?size@?$vector@PB_WV?$allocator@PB_W@std@@@std@@QBEIXZ ; std::vector<wchar_t const *,std::allocator<wchar_t const *>>::size(void)
.text$mn:00007C7B                 cmp     eax, [ebp+arg_0]
.text$mn:00007C7E                 ja      short loc_7C88
.text$mn:00007C80                 mov     ecx, [ebp+var_4]
.text$mn:00007C83                 call    ?_Xran@?$vector@PB_WV?$allocator@PB_W@std@@@std@@IBEXXZ ; std::vector<wchar_t const *,std::allocator<wchar_t const *>>::_Xran(void)
.text$mn:00007C88
.text$mn:00007C88 loc_7C88:                               ; CODE XREF: std::vector<wchar_t const *,std::allocator<wchar_t const *>>::at(uint)+12j
.text$mn:00007C88                 mov     eax, [ebp+var_4]
.text$mn:00007C8B                 mov     ecx, [eax+4]
.text$mn:00007C8E                 mov     edx, [ebp+arg_0]
.text$mn:00007C91                 lea     eax, [ecx+edx*4]
.text$mn:00007C94                 mov     esp, ebp
.text$mn:00007C96                 pop     ebp
.text$mn:00007C97                 retn    4
.text$mn:00007C97 ?at@?$vector@PB_WV?$allocator@PB_W@std@@@std@@QAEAAPB_WI@Z endp
.text$mn:00007C97
.text$mn:00007C97 ; ---------------------------------------------------------------------------
.text$mn:00007C9A                 align 4
.text$mn:00007C9A _text$mn        ends
.text$mn:00007C9A
.text$mn:00007C9C ; ===========================================================================
.text$mn:00007C9C
.text$mn:00007C9C ; Segment type: Pure code
.text$mn:00007C9C ; Segment permissions: Read/Execute
.text$mn:00007C9C _text$mn        segment para public 'CODE' use32
.text$mn:00007C9C                 assume cs:_text$mn
.text$mn:00007C9C                 ;org 7C9Ch
.text$mn:00007C9C ; COMDAT (pick any)
.text$mn:00007C9C                 assume es:nothing, ss:nothing, ds:_data, fs:nothing, gs:nothing
.text$mn:00007C9C
.text$mn:00007C9C ; =============== S U B R O U T I N E =======================================
.text$mn:00007C9C
.text$mn:00007C9C ; Attributes: bp-based frame
.text$mn:00007C9C
.text$mn:00007C9C ; public: struct Token & __thiscall std::vector<struct Token, class std::allocator<struct Token>>::at(unsigned int)
.text$mn:00007C9C                 public ?at@?$vector@UToken@@V?$allocator@UToken@@@std@@@std@@QAEAAUToken@@I@Z
.text$mn:00007C9C ?at@?$vector@UToken@@V?$allocator@UToken@@@std@@@std@@QAEAAUToken@@I@Z proc near
.text$mn:00007C9C                                         ; CODE XREF: FunctionCallTip::getCursorFunction(void)+383p
.text$mn:00007C9C                                         ; FunctionCallTip::getCursorFunction(void)+645p
.text$mn:00007C9C
.text$mn:00007C9C var_4           = dword ptr -4
.text$mn:00007C9C arg_0           = dword ptr  8
.text$mn:00007C9C
.text$mn:00007C9C                 push    ebp
.text$mn:00007C9D                 mov     ebp, esp
.text$mn:00007C9F                 push    ecx
.text$mn:00007CA0                 mov     [ebp+var_4], ecx
.text$mn:00007CA3                 mov     ecx, [ebp+var_4]
.text$mn:00007CA6                 call    ?size@?$vector@UToken@@V?$allocator@UToken@@@std@@@std@@QBEIXZ ; std::vector<Token,std::allocator<Token>>::size(void)
.text$mn:00007CAB                 cmp     eax, [ebp+arg_0]
.text$mn:00007CAE                 ja      short loc_7CB8
.text$mn:00007CB0                 mov     ecx, [ebp+var_4]
.text$mn:00007CB3                 call    ?_Xran@?$vector@UToken@@V?$allocator@UToken@@@std@@@std@@IBEXXZ ; std::vector<Token,std::allocator<Token>>::_Xran(void)
.text$mn:00007CB8
.text$mn:00007CB8 loc_7CB8:                               ; CODE XREF: std::vector<Token,std::allocator<Token>>::at(uint)+12j
.text$mn:00007CB8                 imul    eax, [ebp+arg_0], 0Ch
.text$mn:00007CBC                 mov     ecx, [ebp+var_4]
.text$mn:00007CBF                 add     eax, [ecx+4]
.text$mn:00007CC2                 mov     esp, ebp
.text$mn:00007CC4                 pop     ebp
.text$mn:00007CC5                 retn    4
.text$mn:00007CC5 ?at@?$vector@UToken@@V?$allocator@UToken@@@std@@@std@@QAEAAUToken@@I@Z endp
.text$mn:00007CC5
.text$mn:00007CC5 _text$mn        ends
.text$mn:00007CC5
.text$mn:00007CC8 ; ===========================================================================
.text$mn:00007CC8
.text$mn:00007CC8 ; Segment type: Pure code
.text$mn:00007CC8 ; Segment permissions: Read/Execute
.text$mn:00007CC8 _text$mn        segment para public 'CODE' use32
.text$mn:00007CC8                 assume cs:_text$mn
.text$mn:00007CC8                 ;org 7CC8h
.text$mn:00007CC8 ; COMDAT (pick any)
.text$mn:00007CC8                 assume es:nothing, ss:nothing, ds:_data, fs:nothing, gs:nothing
.text$mn:00007CC8
.text$mn:00007CC8 ; =============== S U B R O U T I N E =======================================
.text$mn:00007CC8
.text$mn:00007CC8 ; Attributes: bp-based frame
.text$mn:00007CC8
.text$mn:00007CC8 ; public: class std::vector<wchar_t const *, class std::allocator<wchar_t const *>> & __thiscall std::vector<class std::vector<wchar_t const *, class std::allocator<wchar_t const *>>, class std::allocator<class std::vector<wchar_t const *, class std::allocator<wchar_t const *>>>>::at(unsigned int)
.text$mn:00007CC8                 public ?at@?$vector@V?$vector@PB_WV?$allocator@PB_W@std@@@std@@V?$allocator@V?$vector@PB_WV?$allocator@PB_W@std@@@std@@@2@@std@@QAEAAV?$vector@PB_WV?$allocator@PB_W@std@@@2@I@Z
.text$mn:00007CC8 ?at@?$vector@V?$vector@PB_WV?$allocator@PB_W@std@@@std@@V?$allocator@V?$vector@PB_WV?$allocator@PB_W@std@@@std@@@2@@std@@QAEAAV?$vector@PB_WV?$allocator@PB_W@std@@@2@I@Z proc near
.text$mn:00007CC8                                         ; CODE XREF: FunctionCallTip::showCalltip(void)+42p
.text$mn:00007CC8                                         ; FunctionCallTip::showCalltip(void)+C3p
.text$mn:00007CC8
.text$mn:00007CC8 var_4           = dword ptr -4
.text$mn:00007CC8 arg_0           = dword ptr  8
.text$mn:00007CC8
.text$mn:00007CC8                 push    ebp
.text$mn:00007CC9                 mov     ebp, esp
.text$mn:00007CCB                 push    ecx
.text$mn:00007CCC                 mov     [ebp+var_4], ecx
.text$mn:00007CCF                 mov     ecx, [ebp+var_4]
.text$mn:00007CD2                 call    ?size@?$vector@V?$vector@PB_WV?$allocator@PB_W@std@@@std@@V?$allocator@V?$vector@PB_WV?$allocator@PB_W@std@@@std@@@2@@std@@QBEIXZ ; std::vector<std::vector<wchar_t const *,std::allocator<wchar_t const *>>,std::allocator<std::vector<wchar_t const *,std::allocator<wchar_t const *>>>>::size(void)
.text$mn:00007CD7                 cmp     eax, [ebp+arg_0]
.text$mn:00007CDA                 ja      short loc_7CE4
.text$mn:00007CDC                 mov     ecx, [ebp+var_4]
.text$mn:00007CDF                 call    ?_Xran@?$vector@V?$vector@PB_WV?$allocator@PB_W@std@@@std@@V?$allocator@V?$vector@PB_WV?$allocator@PB_W@std@@@std@@@2@@std@@IBEXXZ ; std::vector<std::vector<wchar_t const *,std::allocator<wchar_t const *>>,std::allocator<std::vector<wchar_t const *,std::allocator<wchar_t const *>>>>::_Xran(void)
.text$mn:00007CE4
.text$mn:00007CE4 loc_7CE4:                               ; CODE XREF: std::vector<std::vector<wchar_t const *,std::allocator<wchar_t const *>>,std::allocator<std::vector<wchar_t const *,std::allocator<wchar_t const *>>>>::at(uint)+12j
.text$mn:00007CE4                 mov     eax, [ebp+arg_0]
.text$mn:00007CE7                 shl     eax, 4
.text$mn:00007CEA                 mov     ecx, [ebp+var_4]
.text$mn:00007CED                 add     eax, [ecx+4]
.text$mn:00007CF0                 mov     esp, ebp
.text$mn:00007CF2                 pop     ebp
.text$mn:00007CF3                 retn    4
.text$mn:00007CF3 ?at@?$vector@V?$vector@PB_WV?$allocator@PB_W@std@@@std@@V?$allocator@V?$vector@PB_WV?$allocator@PB_W@std@@@std@@@2@@std@@QAEAAV?$vector@PB_WV?$allocator@PB_W@std@@@2@I@Z endp
.text$mn:00007CF3
.text$mn:00007CF3 ; ---------------------------------------------------------------------------
.text$mn:00007CF6                 align 4
.text$mn:00007CF6 _text$mn        ends
.text$mn:00007CF6
.text$mn:00007CF8 ; ===========================================================================
.text$mn:00007CF8
.text$mn:00007CF8 ; Segment type: Pure code
.text$mn:00007CF8 ; Segment permissions: Read/Execute
.text$mn:00007CF8 _text$mn        segment para public 'CODE' use32
.text$mn:00007CF8                 assume cs:_text$mn
.text$mn:00007CF8                 ;org 7CF8h
.text$mn:00007CF8 ; COMDAT (pick any)
.text$mn:00007CF8                 assume es:nothing, ss:nothing, ds:_data, fs:nothing, gs:nothing
.text$mn:00007CF8
.text$mn:00007CF8 ; =============== S U B R O U T I N E =======================================
.text$mn:00007CF8
.text$mn:00007CF8 ; Attributes: bp-based frame
.text$mn:00007CF8
.text$mn:00007CF8 ; public: struct FunctionValues & __thiscall std::vector<struct FunctionValues, class std::allocator<struct FunctionValues>>::back(void)
.text$mn:00007CF8                 public ?back@?$vector@UFunctionValues@@V?$allocator@UFunctionValues@@@std@@@std@@QAEAAUFunctionValues@@XZ
.text$mn:00007CF8 ?back@?$vector@UFunctionValues@@V?$allocator@UFunctionValues@@@std@@@std@@QAEAAUFunctionValues@@XZ proc near
.text$mn:00007CF8                                         ; CODE XREF: FunctionCallTip::getCursorFunction(void)+503p
.text$mn:00007CF8                                         ; FunctionCallTip::getCursorFunction(void)+5F6p
.text$mn:00007CF8
.text$mn:00007CF8 var_3C          = byte ptr -3Ch
.text$mn:00007CF8 var_30          = byte ptr -30h
.text$mn:00007CF8 var_24          = dword ptr -24h
.text$mn:00007CF8 var_20          = dword ptr -20h
.text$mn:00007CF8 var_1C          = dword ptr -1Ch
.text$mn:00007CF8 var_18          = dword ptr -18h
.text$mn:00007CF8 var_14          = dword ptr -14h
.text$mn:00007CF8 var_10          = dword ptr -10h
.text$mn:00007CF8 var_C           = dword ptr -0Ch
.text$mn:00007CF8 var_4           = dword ptr -4
.text$mn:00007CF8
.text$mn:00007CF8                 push    ebp
.text$mn:00007CF9                 mov     ebp, esp
.text$mn:00007CFB                 push    0FFFFFFFFh
.text$mn:00007CFD                 push    offset __ehhandler$?back@?$vector@UFunctionValues@@V?$allocator@UFunctionValues@@@std@@@std@@QAEAAUFunctionValues@@XZ
.text$mn:00007D02                 mov     eax, large fs:0
.text$mn:00007D08                 push    eax
.text$mn:00007D09                 sub     esp, 30h
.text$mn:00007D0C                 mov     eax, dword ptr ds:___security_cookie
.text$mn:00007D11                 xor     eax, ebp
.text$mn:00007D13                 push    eax
.text$mn:00007D14                 lea     eax, [ebp+var_C]
.text$mn:00007D17                 mov     large fs:0, eax
.text$mn:00007D1D                 mov     [ebp+var_10], ecx
.text$mn:00007D20                 push    1
.text$mn:00007D22                 lea     eax, [ebp+var_30]
.text$mn:00007D25                 push    eax
.text$mn:00007D26                 lea     ecx, [ebp+var_3C]
.text$mn:00007D29                 push    ecx
.text$mn:00007D2A                 mov     ecx, [ebp+var_10]
.text$mn:00007D2D                 call    ?end@?$vector@UFunctionValues@@V?$allocator@UFunctionValues@@@std@@@std@@QAE?AV?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@UFunctionValues@@@std@@@std@@@2@XZ ; std::vector<FunctionValues,std::allocator<FunctionValues>>::end(void)
.text$mn:00007D32                 mov     [ebp+var_14], eax
.text$mn:00007D35                 mov     edx, [ebp+var_14]
.text$mn:00007D38                 mov     [ebp+var_18], edx
.text$mn:00007D3B                 mov     [ebp+var_4], 0
.text$mn:00007D42                 mov     ecx, [ebp+var_18]
.text$mn:00007D45                 call    ??G?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@UFunctionValues@@@std@@@std@@@std@@QBE?AV01@H@Z ; std::_Vector_iterator<std::_Vector_val<std::_Simple_types<FunctionValues>>>::operator-(int)
.text$mn:00007D4A                 mov     [ebp+var_1C], eax
.text$mn:00007D4D                 mov     eax, [ebp+var_1C]
.text$mn:00007D50                 mov     [ebp+var_20], eax
.text$mn:00007D53                 mov     byte ptr [ebp+var_4], 1
.text$mn:00007D57                 mov     ecx, [ebp+var_20]
.text$mn:00007D5A                 call    ??D?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@UFunctionValues@@@std@@@std@@@std@@QBEAAUFunctionValues@@XZ ; std::_Vector_iterator<std::_Vector_val<std::_Simple_types<FunctionValues>>>::operator*(void)
.text$mn:00007D5F                 mov     [ebp+var_24], eax
.text$mn:00007D62                 mov     byte ptr [ebp+var_4], 0
.text$mn:00007D66                 lea     ecx, [ebp+var_30]
.text$mn:00007D69                 call    ??1?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@UFunctionValues@@@std@@@std@@@std@@QAE@XZ ; std::_Vector_iterator<std::_Vector_val<std::_Simple_types<FunctionValues>>>::~_Vector_iterator<std::_Vector_val<std::_Simple_types<FunctionValues>>>(void)
.text$mn:00007D6E                 mov     [ebp+var_4], 0FFFFFFFFh
.text$mn:00007D75                 lea     ecx, [ebp+var_3C]
.text$mn:00007D78                 call    ??1?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@UFunctionValues@@@std@@@std@@@std@@QAE@XZ ; std::_Vector_iterator<std::_Vector_val<std::_Simple_types<FunctionValues>>>::~_Vector_iterator<std::_Vector_val<std::_Simple_types<FunctionValues>>>(void)
.text$mn:00007D7D                 mov     eax, [ebp+var_24]
.text$mn:00007D80                 mov     ecx, [ebp+var_C]
.text$mn:00007D83                 mov     large fs:0, ecx
.text$mn:00007D8A                 pop     ecx
.text$mn:00007D8B                 mov     esp, ebp
.text$mn:00007D8D                 pop     ebp
.text$mn:00007D8E                 retn
.text$mn:00007D8E ?back@?$vector@UFunctionValues@@V?$allocator@UFunctionValues@@@std@@@std@@QAEAAUFunctionValues@@XZ endp
.text$mn:00007D8E
.text$mn:00007D8E ; ---------------------------------------------------------------------------
.text$mn:00007D8F                 align 10h
.text$mn:00007D8F _text$mn        ends
.text$mn:00007D8F
.text$x:00007D90 ; ===========================================================================
.text$x:00007D90
.text$x:00007D90 ; Segment type: Pure code
.text$x:00007D90 ; Segment permissions: Read/Execute
.text$x:00007D90 _text$x         segment para public 'CODE' use32
.text$x:00007D90                 assume cs:_text$x
.text$x:00007D90                 ;org 7D90h
.text$x:00007D90 ; COMDAT (pick associative to section at 7CF8)
.text$x:00007D90                 assume es:nothing, ss:nothing, ds:_data, fs:nothing, gs:nothing
.text$x:00007D90
.text$x:00007D90 ; =============== S U B R O U T I N E =======================================
.text$x:00007D90
.text$x:00007D90
.text$x:00007D90 __unwindfunclet$?back@?$vector@UFunctionValues@@V?$allocator@UFunctionValues@@@std@@@std@@QAEAAUFunctionValues@@XZ$0 proc near
.text$x:00007D90                                         ; DATA XREF: .xdata$x:00009C78o
.text$x:00007D90                 lea     ecx, [ebp-3Ch]
.text$x:00007D93                 jmp     ??1?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@UFunctionValues@@@std@@@std@@@std@@QAE@XZ ; std::_Vector_iterator<std::_Vector_val<std::_Simple_types<FunctionValues>>>::~_Vector_iterator<std::_Vector_val<std::_Simple_types<FunctionValues>>>(void)
.text$x:00007D93 __unwindfunclet$?back@?$vector@UFunctionValues@@V?$allocator@UFunctionValues@@@std@@@std@@QAEAAUFunctionValues@@XZ$0 endp
.text$x:00007D93
.text$x:00007D98
.text$x:00007D98 ; =============== S U B R O U T I N E =======================================
.text$x:00007D98
.text$x:00007D98
.text$x:00007D98 __unwindfunclet$?back@?$vector@UFunctionValues@@V?$allocator@UFunctionValues@@@std@@@std@@QAEAAUFunctionValues@@XZ$1 proc near
.text$x:00007D98                                         ; DATA XREF: .xdata$x:00009C80o
.text$x:00007D98                 lea     ecx, [ebp-30h]
.text$x:00007D9B                 jmp     ??1?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@UFunctionValues@@@std@@@std@@@std@@QAE@XZ ; std::_Vector_iterator<std::_Vector_val<std::_Simple_types<FunctionValues>>>::~_Vector_iterator<std::_Vector_val<std::_Simple_types<FunctionValues>>>(void)
.text$x:00007D9B __unwindfunclet$?back@?$vector@UFunctionValues@@V?$allocator@UFunctionValues@@@std@@@std@@QAEAAUFunctionValues@@XZ$1 endp
.text$x:00007D9B
.text$x:00007DA0
.text$x:00007DA0 ; =============== S U B R O U T I N E =======================================
.text$x:00007DA0
.text$x:00007DA0
.text$x:00007DA0 __ehhandler$?back@?$vector@UFunctionValues@@V?$allocator@UFunctionValues@@@std@@@std@@QAEAAUFunctionValues@@XZ proc near
.text$x:00007DA0                                         ; DATA XREF: std::vector<FunctionValues,std::allocator<FunctionValues>>::back(void)+5o
.text$x:00007DA0
.text$x:00007DA0 arg_4           = dword ptr  8
.text$x:00007DA0
.text$x:00007DA0                 mov     edx, [esp+arg_4]
.text$x:00007DA4                 lea     eax, [edx+0Ch]
.text$x:00007DA7                 mov     ecx, [edx-34h]
.text$x:00007DAA                 xor     ecx, eax
.text$x:00007DAC                 call    @__security_check_cookie@4 ; __security_check_cookie(x)
.text$x:00007DB1                 mov     eax, offset __ehfuncinfo$?back@?$vector@UFunctionValues@@V?$allocator@UFunctionValues@@@std@@@std@@QAEAAUFunctionValues@@XZ
.text$x:00007DB6                 jmp     ___CxxFrameHandler3
.text$x:00007DB6 __ehhandler$?back@?$vector@UFunctionValues@@V?$allocator@UFunctionValues@@@std@@@std@@QAEAAUFunctionValues@@XZ endp
.text$x:00007DB6
.text$x:00007DB6 ; ---------------------------------------------------------------------------
.text$x:00007DBB                 align 4
.text$x:00007DBB _text$x         ends
.text$x:00007DBB
.text$mn:00007DBC ; ===========================================================================
.text$mn:00007DBC
.text$mn:00007DBC ; Segment type: Pure code
.text$mn:00007DBC ; Segment permissions: Read/Execute
.text$mn:00007DBC _text$mn        segment para public 'CODE' use32
.text$mn:00007DBC                 assume cs:_text$mn
.text$mn:00007DBC                 ;org 7DBCh
.text$mn:00007DBC ; COMDAT (pick any)
.text$mn:00007DBC                 assume es:nothing, ss:nothing, ds:_data, fs:nothing, gs:nothing
.text$mn:00007DBC
.text$mn:00007DBC ; =============== S U B R O U T I N E =======================================
.text$mn:00007DBC
.text$mn:00007DBC ; Attributes: bp-based frame
.text$mn:00007DBC
.text$mn:00007DBC ; public: class std::_Vector_const_iterator<class std::_Vector_val<struct std::_Simple_types<wchar_t const *>>> __thiscall std::vector<wchar_t const *, class std::allocator<wchar_t const *>>::begin(void)const
.text$mn:00007DBC                 public ?begin@?$vector@PB_WV?$allocator@PB_W@std@@@std@@QBE?AV?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@PB_W@std@@@std@@@2@XZ
.text$mn:00007DBC ?begin@?$vector@PB_WV?$allocator@PB_W@std@@@std@@QBE?AV?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@PB_W@std@@@std@@@2@XZ proc near
.text$mn:00007DBC                                         ; CODE XREF: std::vector<wchar_t const *,std::allocator<wchar_t const *>>::vector<wchar_t const *,std::allocator<wchar_t const *>>(std::vector<wchar_t const *,std::allocator<wchar_t const *>> const &)+A7p
.text$mn:00007DBC
.text$mn:00007DBC var_14          = dword ptr -14h
.text$mn:00007DBC var_10          = dword ptr -10h
.text$mn:00007DBC var_C           = dword ptr -0Ch
.text$mn:00007DBC var_4           = dword ptr -4
.text$mn:00007DBC arg_0           = dword ptr  8
.text$mn:00007DBC
.text$mn:00007DBC                 push    ebp
.text$mn:00007DBD                 mov     ebp, esp
.text$mn:00007DBF                 push    0FFFFFFFFh
.text$mn:00007DC1                 push    offset __ehhandler$?begin@?$vector@PB_WV?$allocator@PB_W@std@@@std@@QBE?AV?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@PB_W@std@@@std@@@2@XZ
.text$mn:00007DC6                 mov     eax, large fs:0
.text$mn:00007DCC                 push    eax
.text$mn:00007DCD                 sub     esp, 8
.text$mn:00007DD0                 mov     eax, dword ptr ds:___security_cookie
.text$mn:00007DD5                 xor     eax, ebp
.text$mn:00007DD7                 push    eax
.text$mn:00007DD8                 lea     eax, [ebp+var_C]
.text$mn:00007DDB                 mov     large fs:0, eax
.text$mn:00007DE1                 mov     [ebp+var_10], ecx
.text$mn:00007DE4                 mov     [ebp+var_14], 0
.text$mn:00007DEB                 mov     eax, [ebp+var_10]
.text$mn:00007DEE                 push    eax             ; struct std::_Container_base12 *
.text$mn:00007DEF                 mov     ecx, [ebp+var_10]
.text$mn:00007DF2                 mov     edx, [ecx+4]
.text$mn:00007DF5                 push    edx             ; int
.text$mn:00007DF6                 mov     ecx, [ebp+arg_0]
.text$mn:00007DF9                 call    ??0?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@PB_W@std@@@std@@@std@@QAE@PAPB_WPBU_Container_base12@1@@Z ; std::_Vector_const_iterator<std::_Vector_val<std::_Simple_types<wchar_t const *>>>::_Vector_const_iterator<std::_Vector_val<std::_Simple_types<wchar_t const *>>>(wchar_t const * *,std::_Container_base12 const *)
.text$mn:00007DFE                 mov     [ebp+var_4], 0
.text$mn:00007E05                 mov     eax, [ebp+var_14]
.text$mn:00007E08                 or      eax, 1
.text$mn:00007E0B                 mov     [ebp+var_14], eax
.text$mn:00007E0E                 mov     eax, [ebp+arg_0]
.text$mn:00007E11                 mov     ecx, [ebp+var_C]
.text$mn:00007E14                 mov     large fs:0, ecx
.text$mn:00007E1B                 pop     ecx
.text$mn:00007E1C                 mov     esp, ebp
.text$mn:00007E1E                 pop     ebp
.text$mn:00007E1F                 retn    4
.text$mn:00007E1F ?begin@?$vector@PB_WV?$allocator@PB_W@std@@@std@@QBE?AV?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@PB_W@std@@@std@@@2@XZ endp
.text$mn:00007E1F
.text$mn:00007E1F ; ---------------------------------------------------------------------------
.text$mn:00007E22                 align 4
.text$mn:00007E22 _text$mn        ends
.text$mn:00007E22
.text$x:00007E24 ; ===========================================================================
.text$x:00007E24
.text$x:00007E24 ; Segment type: Pure code
.text$x:00007E24 ; Segment permissions: Read/Execute
.text$x:00007E24 _text$x         segment para public 'CODE' use32
.text$x:00007E24                 assume cs:_text$x
.text$x:00007E24                 ;org 7E24h
.text$x:00007E24 ; COMDAT (pick associative to section at 7DBC)
.text$x:00007E24                 assume es:nothing, ss:nothing, ds:_data, fs:nothing, gs:nothing
.text$x:00007E24
.text$x:00007E24 ; =============== S U B R O U T I N E =======================================
.text$x:00007E24
.text$x:00007E24
.text$x:00007E24 __unwindfunclet$?begin@?$vector@PB_WV?$allocator@PB_W@std@@@std@@QBE?AV?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@PB_W@std@@@std@@@2@XZ$0 proc near
.text$x:00007E24                                         ; DATA XREF: .xdata$x:000097CCo
.text$x:00007E24                 mov     eax, [ebp-14h]
.text$x:00007E27                 and     eax, 1
.text$x:00007E2A                 jz      $LN4
.text$x:00007E30                 and     dword ptr [ebp-14h], 0FFFFFFFEh
.text$x:00007E34                 mov     ecx, [ebp+8]
.text$x:00007E37                 jmp     ??1?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@PB_W@std@@@std@@@std@@QAE@XZ ; std::_Vector_const_iterator<std::_Vector_val<std::_Simple_types<wchar_t const *>>>::~_Vector_const_iterator<std::_Vector_val<std::_Simple_types<wchar_t const *>>>(void)
.text$x:00007E3C ; ---------------------------------------------------------------------------
.text$x:00007E3C
.text$x:00007E3C $LN4:                                   ; CODE XREF: __unwindfunclet$?begin@?$vector@PB_WV?$allocator@PB_W@std@@@std@@QBE?AV?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@PB_W@std@@@std@@@2@XZ$0+6j
.text$x:00007E3C                 retn
.text$x:00007E3C __unwindfunclet$?begin@?$vector@PB_WV?$allocator@PB_W@std@@@std@@QBE?AV?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@PB_W@std@@@std@@@2@XZ$0 endp
.text$x:00007E3C
.text$x:00007E3D
.text$x:00007E3D ; =============== S U B R O U T I N E =======================================
.text$x:00007E3D
.text$x:00007E3D
.text$x:00007E3D __ehhandler$?begin@?$vector@PB_WV?$allocator@PB_W@std@@@std@@QBE?AV?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@PB_W@std@@@std@@@2@XZ proc near
.text$x:00007E3D                                         ; DATA XREF: std::vector<wchar_t const *,std::allocator<wchar_t const *>>::begin(void)+5o
.text$x:00007E3D
.text$x:00007E3D arg_4           = dword ptr  8
.text$x:00007E3D
.text$x:00007E3D                 mov     edx, [esp+arg_4]
.text$x:00007E41                 lea     eax, [edx+0Ch]
.text$x:00007E44                 mov     ecx, [edx-0Ch]
.text$x:00007E47                 xor     ecx, eax
.text$x:00007E49                 call    @__security_check_cookie@4 ; __security_check_cookie(x)
.text$x:00007E4E                 mov     eax, offset __ehfuncinfo$?begin@?$vector@PB_WV?$allocator@PB_W@std@@@std@@QBE?AV?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@PB_W@std@@@std@@@2@XZ
.text$x:00007E53                 jmp     ___CxxFrameHandler3
.text$x:00007E53 __ehhandler$?begin@?$vector@PB_WV?$allocator@PB_W@std@@@std@@QBE?AV?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@PB_W@std@@@std@@@2@XZ endp
.text$x:00007E53
.text$x:00007E53 _text$x         ends
.text$x:00007E53
.text$mn:00007E58 ; ===========================================================================
.text$mn:00007E58
.text$mn:00007E58 ; Segment type: Pure code
.text$mn:00007E58 ; Segment permissions: Read/Execute
.text$mn:00007E58 _text$mn        segment para public 'CODE' use32
.text$mn:00007E58                 assume cs:_text$mn
.text$mn:00007E58                 ;org 7E58h
.text$mn:00007E58 ; COMDAT (pick any)
.text$mn:00007E58                 assume es:nothing, ss:nothing, ds:_data, fs:nothing, gs:nothing
.text$mn:00007E58
.text$mn:00007E58 ; =============== S U B R O U T I N E =======================================
.text$mn:00007E58
.text$mn:00007E58 ; Attributes: bp-based frame
.text$mn:00007E58
.text$mn:00007E58 ; public: wchar_t const * __thiscall std::basic_string<wchar_t, struct std::char_traits<wchar_t>, class std::allocator<wchar_t>>::c_str(void)const
.text$mn:00007E58                 public ?c_str@?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QBEPB_WXZ
.text$mn:00007E58 ?c_str@?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QBEPB_WXZ proc near
.text$mn:00007E58                                         ; CODE XREF: FunctionCallTip::isAdditionalWordChar(wchar_t)+Fp
.text$mn:00007E58
.text$mn:00007E58 var_4           = dword ptr -4
.text$mn:00007E58
.text$mn:00007E58                 push    ebp
.text$mn:00007E59                 mov     ebp, esp
.text$mn:00007E5B                 push    ecx
.text$mn:00007E5C                 mov     [ebp+var_4], ecx
.text$mn:00007E5F                 mov     ecx, [ebp+var_4]
.text$mn:00007E62                 call    ?_Myptr@?$_String_val@U?$_Simple_types@_W@std@@@std@@QBEPB_WXZ ; std::_String_val<std::_Simple_types<wchar_t>>::_Myptr(void)
.text$mn:00007E67                 mov     esp, ebp
.text$mn:00007E69                 pop     ebp
.text$mn:00007E6A                 retn
.text$mn:00007E6A ?c_str@?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QBEPB_WXZ endp
.text$mn:00007E6A
.text$mn:00007E6A ; ---------------------------------------------------------------------------
.text$mn:00007E6B                 align 4
.text$mn:00007E6B _text$mn        ends
.text$mn:00007E6B
.text$mn:00007E6C ; ===========================================================================
.text$mn:00007E6C
.text$mn:00007E6C ; Segment type: Pure code
.text$mn:00007E6C ; Segment permissions: Read/Execute
.text$mn:00007E6C _text$mn        segment para public 'CODE' use32
.text$mn:00007E6C                 assume cs:_text$mn
.text$mn:00007E6C                 ;org 7E6Ch
.text$mn:00007E6C ; COMDAT (pick any)
.text$mn:00007E6C                 assume es:nothing, ss:nothing, ds:_data, fs:nothing, gs:nothing
.text$mn:00007E6C
.text$mn:00007E6C ; =============== S U B R O U T I N E =======================================
.text$mn:00007E6C
.text$mn:00007E6C ; Attributes: bp-based frame
.text$mn:00007E6C
.text$mn:00007E6C ; public: unsigned int __thiscall std::vector<wchar_t const *, class std::allocator<wchar_t const *>>::capacity(void)const
.text$mn:00007E6C                 public ?capacity@?$vector@PB_WV?$allocator@PB_W@std@@@std@@QBEIXZ
.text$mn:00007E6C ?capacity@?$vector@PB_WV?$allocator@PB_W@std@@@std@@QBEIXZ proc near
.text$mn:00007E6C                                         ; CODE XREF: std::vector<wchar_t const *,std::allocator<wchar_t const *>>::_Grow_to(uint)+Cp
.text$mn:00007E6C
.text$mn:00007E6C var_4           = dword ptr -4
.text$mn:00007E6C
.text$mn:00007E6C                 push    ebp
.text$mn:00007E6D                 mov     ebp, esp
.text$mn:00007E6F                 push    ecx
.text$mn:00007E70                 mov     [ebp+var_4], ecx
.text$mn:00007E73                 mov     eax, [ebp+var_4]
.text$mn:00007E76                 mov     ecx, [ebp+var_4]
.text$mn:00007E79                 mov     eax, [eax+0Ch]
.text$mn:00007E7C                 sub     eax, [ecx+4]
.text$mn:00007E7F                 sar     eax, 2
.text$mn:00007E82                 mov     esp, ebp
.text$mn:00007E84                 pop     ebp
.text$mn:00007E85                 retn
.text$mn:00007E85 ?capacity@?$vector@PB_WV?$allocator@PB_W@std@@@std@@QBEIXZ endp
.text$mn:00007E85
.text$mn:00007E85 ; ---------------------------------------------------------------------------
.text$mn:00007E86                 align 4
.text$mn:00007E86 _text$mn        ends
.text$mn:00007E86
.text$mn:00007E88 ; ===========================================================================
.text$mn:00007E88
.text$mn:00007E88 ; Segment type: Pure code
.text$mn:00007E88 ; Segment permissions: Read/Execute
.text$mn:00007E88 _text$mn        segment para public 'CODE' use32
.text$mn:00007E88                 assume cs:_text$mn
.text$mn:00007E88                 ;org 7E88h
.text$mn:00007E88 ; COMDAT (pick any)
.text$mn:00007E88                 assume es:nothing, ss:nothing, ds:_data, fs:nothing, gs:nothing
.text$mn:00007E88
.text$mn:00007E88 ; =============== S U B R O U T I N E =======================================
.text$mn:00007E88
.text$mn:00007E88 ; Attributes: bp-based frame
.text$mn:00007E88
.text$mn:00007E88 ; public: unsigned int __thiscall std::vector<struct FunctionValues, class std::allocator<struct FunctionValues>>::capacity(void)const
.text$mn:00007E88                 public ?capacity@?$vector@UFunctionValues@@V?$allocator@UFunctionValues@@@std@@@std@@QBEIXZ
.text$mn:00007E88 ?capacity@?$vector@UFunctionValues@@V?$allocator@UFunctionValues@@@std@@@std@@QBEIXZ proc near
.text$mn:00007E88                                         ; CODE XREF: std::vector<FunctionValues,std::allocator<FunctionValues>>::_Grow_to(uint)+Cp
.text$mn:00007E88
.text$mn:00007E88 var_4           = dword ptr -4
.text$mn:00007E88
.text$mn:00007E88                 push    ebp
.text$mn:00007E89                 mov     ebp, esp
.text$mn:00007E8B                 push    ecx
.text$mn:00007E8C                 mov     [ebp+var_4], ecx
.text$mn:00007E8F                 mov     eax, [ebp+var_4]
.text$mn:00007E92                 mov     ecx, [ebp+var_4]
.text$mn:00007E95                 mov     eax, [eax+0Ch]
.text$mn:00007E98                 sub     eax, [ecx+4]
.text$mn:00007E9B                 sar     eax, 4
.text$mn:00007E9E                 mov     esp, ebp
.text$mn:00007EA0                 pop     ebp
.text$mn:00007EA1                 retn
.text$mn:00007EA1 ?capacity@?$vector@UFunctionValues@@V?$allocator@UFunctionValues@@@std@@@std@@QBEIXZ endp
.text$mn:00007EA1
.text$mn:00007EA1 ; ---------------------------------------------------------------------------
.text$mn:00007EA2                 align 4
.text$mn:00007EA2 _text$mn        ends
.text$mn:00007EA2
.text$mn:00007EA4 ; ===========================================================================
.text$mn:00007EA4
.text$mn:00007EA4 ; Segment type: Pure code
.text$mn:00007EA4 ; Segment permissions: Read/Execute
.text$mn:00007EA4 _text$mn        segment para public 'CODE' use32
.text$mn:00007EA4                 assume cs:_text$mn
.text$mn:00007EA4                 ;org 7EA4h
.text$mn:00007EA4 ; COMDAT (pick any)
.text$mn:00007EA4                 assume es:nothing, ss:nothing, ds:_data, fs:nothing, gs:nothing
.text$mn:00007EA4
.text$mn:00007EA4 ; =============== S U B R O U T I N E =======================================
.text$mn:00007EA4
.text$mn:00007EA4 ; Attributes: bp-based frame
.text$mn:00007EA4
.text$mn:00007EA4 ; public: unsigned int __thiscall std::vector<struct Token, class std::allocator<struct Token>>::capacity(void)const
.text$mn:00007EA4                 public ?capacity@?$vector@UToken@@V?$allocator@UToken@@@std@@@std@@QBEIXZ
.text$mn:00007EA4 ?capacity@?$vector@UToken@@V?$allocator@UToken@@@std@@@std@@QBEIXZ proc near
.text$mn:00007EA4                                         ; CODE XREF: std::vector<Token,std::allocator<Token>>::_Grow_to(uint)+Cp
.text$mn:00007EA4
.text$mn:00007EA4 var_4           = dword ptr -4
.text$mn:00007EA4
.text$mn:00007EA4                 push    ebp
.text$mn:00007EA5                 mov     ebp, esp
.text$mn:00007EA7                 push    ecx
.text$mn:00007EA8                 mov     [ebp+var_4], ecx
.text$mn:00007EAB                 mov     eax, [ebp+var_4]
.text$mn:00007EAE                 mov     ecx, [ebp+var_4]
.text$mn:00007EB1                 mov     eax, [eax+0Ch]
.text$mn:00007EB4                 sub     eax, [ecx+4]
.text$mn:00007EB7                 cdq
.text$mn:00007EB8                 mov     ecx, 0Ch
.text$mn:00007EBD                 idiv    ecx
.text$mn:00007EBF                 mov     esp, ebp
.text$mn:00007EC1                 pop     ebp
.text$mn:00007EC2                 retn
.text$mn:00007EC2 ?capacity@?$vector@UToken@@V?$allocator@UToken@@@std@@@std@@QBEIXZ endp
.text$mn:00007EC2
.text$mn:00007EC2 ; ---------------------------------------------------------------------------
.text$mn:00007EC3                 align 4
.text$mn:00007EC3 _text$mn        ends
.text$mn:00007EC3
.text$mn:00007EC4 ; ===========================================================================
.text$mn:00007EC4
.text$mn:00007EC4 ; Segment type: Pure code
.text$mn:00007EC4 ; Segment permissions: Read/Execute
.text$mn:00007EC4 _text$mn        segment para public 'CODE' use32
.text$mn:00007EC4                 assume cs:_text$mn
.text$mn:00007EC4                 ;org 7EC4h
.text$mn:00007EC4 ; COMDAT (pick any)
.text$mn:00007EC4                 assume es:nothing, ss:nothing, ds:_data, fs:nothing, gs:nothing
.text$mn:00007EC4
.text$mn:00007EC4 ; =============== S U B R O U T I N E =======================================
.text$mn:00007EC4
.text$mn:00007EC4 ; Attributes: bp-based frame
.text$mn:00007EC4
.text$mn:00007EC4 ; public: unsigned int __thiscall std::vector<class std::vector<wchar_t const *, class std::allocator<wchar_t const *>>, class std::allocator<class std::vector<wchar_t const *, class std::allocator<wchar_t const *>>>>::capacity(void)const
.text$mn:00007EC4                 public ?capacity@?$vector@V?$vector@PB_WV?$allocator@PB_W@std@@@std@@V?$allocator@V?$vector@PB_WV?$allocator@PB_W@std@@@std@@@2@@std@@QBEIXZ
.text$mn:00007EC4 ?capacity@?$vector@V?$vector@PB_WV?$allocator@PB_W@std@@@std@@V?$allocator@V?$vector@PB_WV?$allocator@PB_W@std@@@std@@@2@@std@@QBEIXZ proc near
.text$mn:00007EC4                                         ; CODE XREF: std::vector<std::vector<wchar_t const *,std::allocator<wchar_t const *>>,std::allocator<std::vector<wchar_t const *,std::allocator<wchar_t const *>>>>::_Grow_to(uint)+Cp
.text$mn:00007EC4
.text$mn:00007EC4 var_4           = dword ptr -4
.text$mn:00007EC4
.text$mn:00007EC4                 push    ebp
.text$mn:00007EC5                 mov     ebp, esp
.text$mn:00007EC7                 push    ecx
.text$mn:00007EC8                 mov     [ebp+var_4], ecx
.text$mn:00007ECB                 mov     eax, [ebp+var_4]
.text$mn:00007ECE                 mov     ecx, [ebp+var_4]
.text$mn:00007ED1                 mov     eax, [eax+0Ch]
.text$mn:00007ED4                 sub     eax, [ecx+4]
.text$mn:00007ED7                 sar     eax, 4
.text$mn:00007EDA                 mov     esp, ebp
.text$mn:00007EDC                 pop     ebp
.text$mn:00007EDD                 retn
.text$mn:00007EDD ?capacity@?$vector@V?$vector@PB_WV?$allocator@PB_W@std@@@std@@V?$allocator@V?$vector@PB_WV?$allocator@PB_W@std@@@std@@@2@@std@@QBEIXZ endp
.text$mn:00007EDD
.text$mn:00007EDD ; ---------------------------------------------------------------------------
.text$mn:00007EDE                 align 10h
.text$mn:00007EDE _text$mn        ends
.text$mn:00007EDE
.text$mn:00007EE0 ; ===========================================================================
.text$mn:00007EE0
.text$mn:00007EE0 ; Segment type: Pure code
.text$mn:00007EE0 ; Segment permissions: Read/Execute
.text$mn:00007EE0 _text$mn        segment para public 'CODE' use32
.text$mn:00007EE0                 assume cs:_text$mn
.text$mn:00007EE0                 ;org 7EE0h
.text$mn:00007EE0 ; COMDAT (pick any)
.text$mn:00007EE0                 assume es:nothing, ss:nothing, ds:_data, fs:nothing, gs:nothing
.text$mn:00007EE0
.text$mn:00007EE0 ; =============== S U B R O U T I N E =======================================
.text$mn:00007EE0
.text$mn:00007EE0 ; Attributes: bp-based frame
.text$mn:00007EE0
.text$mn:00007EE0 ; const struct std::error_category *__thiscall std::error_code::category(std::error_code *__hidden this)
.text$mn:00007EE0                 public ?category@error_code@std@@QBEABVerror_category@2@XZ
.text$mn:00007EE0 ?category@error_code@std@@QBEABVerror_category@2@XZ proc near
.text$mn:00007EE0                                         ; CODE XREF: std::error_category::equivalent(std::error_code const &,int)+Cp
.text$mn:00007EE0
.text$mn:00007EE0 var_4           = dword ptr -4
.text$mn:00007EE0
.text$mn:00007EE0                 push    ebp
.text$mn:00007EE1                 mov     ebp, esp
.text$mn:00007EE3                 push    ecx
.text$mn:00007EE4                 mov     [ebp+var_4], ecx
.text$mn:00007EE7                 mov     eax, [ebp+var_4]
.text$mn:00007EEA                 mov     eax, [eax+4]
.text$mn:00007EED                 mov     esp, ebp
.text$mn:00007EEF                 pop     ebp
.text$mn:00007EF0                 retn
.text$mn:00007EF0 ?category@error_code@std@@QBEABVerror_category@2@XZ endp
.text$mn:00007EF0
.text$mn:00007EF0 ; ---------------------------------------------------------------------------
.text$mn:00007EF1                 align 4
.text$mn:00007EF1 _text$mn        ends
.text$mn:00007EF1
.text$mn:00007EF4 ; ===========================================================================
.text$mn:00007EF4
.text$mn:00007EF4 ; Segment type: Pure code
.text$mn:00007EF4 ; Segment permissions: Read/Execute
.text$mn:00007EF4 _text$mn        segment para public 'CODE' use32
.text$mn:00007EF4                 assume cs:_text$mn
.text$mn:00007EF4                 ;org 7EF4h
.text$mn:00007EF4 ; COMDAT (pick any)
.text$mn:00007EF4                 assume es:nothing, ss:nothing, ds:_data, fs:nothing, gs:nothing
.text$mn:00007EF4
.text$mn:00007EF4 ; =============== S U B R O U T I N E =======================================
.text$mn:00007EF4
.text$mn:00007EF4 ; Attributes: bp-based frame
.text$mn:00007EF4
.text$mn:00007EF4 ; const struct std::error_category *__thiscall std::error_condition::category(std::error_condition *__hidden this)
.text$mn:00007EF4                 public ?category@error_condition@std@@QBEABVerror_category@2@XZ
.text$mn:00007EF4 ?category@error_condition@std@@QBEABVerror_category@2@XZ proc near
.text$mn:00007EF4                                         ; CODE XREF: std::error_condition::operator==(std::error_condition const &)+Dp
.text$mn:00007EF4                                         ; std::error_condition::operator==(std::error_condition const &)+16p
.text$mn:00007EF4
.text$mn:00007EF4 var_4           = dword ptr -4
.text$mn:00007EF4
.text$mn:00007EF4                 push    ebp
.text$mn:00007EF5                 mov     ebp, esp
.text$mn:00007EF7                 push    ecx
.text$mn:00007EF8                 mov     [ebp+var_4], ecx
.text$mn:00007EFB                 mov     eax, [ebp+var_4]
.text$mn:00007EFE                 mov     eax, [eax+4]
.text$mn:00007F01                 mov     esp, ebp
.text$mn:00007F03                 pop     ebp
.text$mn:00007F04                 retn
.text$mn:00007F04 ?category@error_condition@std@@QBEABVerror_category@2@XZ endp
.text$mn:00007F04
.text$mn:00007F04 ; ---------------------------------------------------------------------------
.text$mn:00007F05                 align 4
.text$mn:00007F05 _text$mn        ends
.text$mn:00007F05
.text$mn:00007F08 ; ===========================================================================
.text$mn:00007F08
.text$mn:00007F08 ; Segment type: Pure code
.text$mn:00007F08 ; Segment permissions: Read/Execute
.text$mn:00007F08 _text$mn        segment para public 'CODE' use32
.text$mn:00007F08                 assume cs:_text$mn
.text$mn:00007F08                 ;org 7F08h
.text$mn:00007F08 ; COMDAT (pick any)
.text$mn:00007F08                 assume es:nothing, ss:nothing, ds:_data, fs:nothing, gs:nothing
.text$mn:00007F08
.text$mn:00007F08 ; =============== S U B R O U T I N E =======================================
.text$mn:00007F08
.text$mn:00007F08 ; Attributes: bp-based frame
.text$mn:00007F08
.text$mn:00007F08 ; public: void __thiscall std::vector<wchar_t const *, class std::allocator<wchar_t const *>>::clear(void)
.text$mn:00007F08                 public ?clear@?$vector@PB_WV?$allocator@PB_W@std@@@std@@QAEXXZ
.text$mn:00007F08 ?clear@?$vector@PB_WV?$allocator@PB_W@std@@@std@@QAEXXZ proc near
.text$mn:00007F08                                         ; CODE XREF: FunctionCallTip::loadFunction(void)+21Fp
.text$mn:00007F08                                         ; FunctionCallTip::reset(void)+40p ...
.text$mn:00007F08
.text$mn:00007F08 var_4           = dword ptr -4
.text$mn:00007F08
.text$mn:00007F08                 push    ebp
.text$mn:00007F09                 mov     ebp, esp
.text$mn:00007F0B                 push    ecx
.text$mn:00007F0C                 mov     [ebp+var_4], ecx
.text$mn:00007F0F                 mov     ecx, [ebp+var_4] ; this
.text$mn:00007F12                 call    ?_Orphan_all@_Container_base12@std@@QAEXXZ ; std::_Container_base12::_Orphan_all(void)
.text$mn:00007F17                 mov     eax, [ebp+var_4]
.text$mn:00007F1A                 mov     ecx, [eax+8]
.text$mn:00007F1D                 push    ecx
.text$mn:00007F1E                 mov     edx, [ebp+var_4]
.text$mn:00007F21                 mov     eax, [edx+4]
.text$mn:00007F24                 push    eax
.text$mn:00007F25                 mov     ecx, [ebp+var_4]
.text$mn:00007F28                 call    ?_Destroy@?$vector@PB_WV?$allocator@PB_W@std@@@std@@IAEXPAPB_W0@Z ; std::vector<wchar_t const *,std::allocator<wchar_t const *>>::_Destroy(wchar_t const * *,wchar_t const * *)
.text$mn:00007F2D                 mov     ecx, [ebp+var_4]
.text$mn:00007F30                 mov     edx, [ebp+var_4]
.text$mn:00007F33                 mov     eax, [edx+4]
.text$mn:00007F36                 mov     [ecx+8], eax
.text$mn:00007F39                 mov     esp, ebp
.text$mn:00007F3B                 pop     ebp
.text$mn:00007F3C                 retn
.text$mn:00007F3C ?clear@?$vector@PB_WV?$allocator@PB_W@std@@@std@@QAEXXZ endp
.text$mn:00007F3C
.text$mn:00007F3C ; ---------------------------------------------------------------------------
.text$mn:00007F3D                 align 10h
.text$mn:00007F3D _text$mn        ends
.text$mn:00007F3D
.text$mn:00007F40 ; ===========================================================================
.text$mn:00007F40
.text$mn:00007F40 ; Segment type: Pure code
.text$mn:00007F40 ; Segment permissions: Read/Execute
.text$mn:00007F40 _text$mn        segment para public 'CODE' use32
.text$mn:00007F40                 assume cs:_text$mn
.text$mn:00007F40                 ;org 7F40h
.text$mn:00007F40 ; COMDAT (pick any)
.text$mn:00007F40                 assume es:nothing, ss:nothing, ds:_data, fs:nothing, gs:nothing
.text$mn:00007F40
.text$mn:00007F40 ; =============== S U B R O U T I N E =======================================
.text$mn:00007F40
.text$mn:00007F40 ; Attributes: bp-based frame
.text$mn:00007F40
.text$mn:00007F40 ; public: void __thiscall std::vector<struct FunctionValues, class std::allocator<struct FunctionValues>>::clear(void)
.text$mn:00007F40                 public ?clear@?$vector@UFunctionValues@@V?$allocator@UFunctionValues@@@std@@@std@@QAEXXZ
.text$mn:00007F40 ?clear@?$vector@UFunctionValues@@V?$allocator@UFunctionValues@@@std@@@std@@QAEXXZ proc near
.text$mn:00007F40                                         ; CODE XREF: FunctionCallTip::getCursorFunction(void)+590p
.text$mn:00007F40
.text$mn:00007F40 var_4           = dword ptr -4
.text$mn:00007F40
.text$mn:00007F40                 push    ebp
.text$mn:00007F41                 mov     ebp, esp
.text$mn:00007F43                 push    ecx
.text$mn:00007F44                 mov     [ebp+var_4], ecx
.text$mn:00007F47                 mov     ecx, [ebp+var_4] ; this
.text$mn:00007F4A                 call    ?_Orphan_all@_Container_base12@std@@QAEXXZ ; std::_Container_base12::_Orphan_all(void)
.text$mn:00007F4F                 mov     eax, [ebp+var_4]
.text$mn:00007F52                 mov     ecx, [eax+8]
.text$mn:00007F55                 push    ecx
.text$mn:00007F56                 mov     edx, [ebp+var_4]
.text$mn:00007F59                 mov     eax, [edx+4]
.text$mn:00007F5C                 push    eax
.text$mn:00007F5D                 mov     ecx, [ebp+var_4]
.text$mn:00007F60                 call    ?_Destroy@?$vector@UFunctionValues@@V?$allocator@UFunctionValues@@@std@@@std@@IAEXPAUFunctionValues@@0@Z ; std::vector<FunctionValues,std::allocator<FunctionValues>>::_Destroy(FunctionValues *,FunctionValues *)
.text$mn:00007F65                 mov     ecx, [ebp+var_4]
.text$mn:00007F68                 mov     edx, [ebp+var_4]
.text$mn:00007F6B                 mov     eax, [edx+4]
.text$mn:00007F6E                 mov     [ecx+8], eax
.text$mn:00007F71                 mov     esp, ebp
.text$mn:00007F73                 pop     ebp
.text$mn:00007F74                 retn
.text$mn:00007F74 ?clear@?$vector@UFunctionValues@@V?$allocator@UFunctionValues@@@std@@@std@@QAEXXZ endp
.text$mn:00007F74
.text$mn:00007F74 ; ---------------------------------------------------------------------------
.text$mn:00007F75                 align 4
.text$mn:00007F75 _text$mn        ends
.text$mn:00007F75
.text$mn:00007F78 ; ===========================================================================
.text$mn:00007F78
.text$mn:00007F78 ; Segment type: Pure code
.text$mn:00007F78 ; Segment permissions: Read/Execute
.text$mn:00007F78 _text$mn        segment para public 'CODE' use32
.text$mn:00007F78                 assume cs:_text$mn
.text$mn:00007F78                 ;org 7F78h
.text$mn:00007F78 ; COMDAT (pick any)
.text$mn:00007F78                 assume es:nothing, ss:nothing, ds:_data, fs:nothing, gs:nothing
.text$mn:00007F78
.text$mn:00007F78 ; =============== S U B R O U T I N E =======================================
.text$mn:00007F78
.text$mn:00007F78 ; Attributes: bp-based frame
.text$mn:00007F78
.text$mn:00007F78 ; public: void __thiscall std::vector<class std::vector<wchar_t const *, class std::allocator<wchar_t const *>>, class std::allocator<class std::vector<wchar_t const *, class std::allocator<wchar_t const *>>>>::clear(void)
.text$mn:00007F78                 public ?clear@?$vector@V?$vector@PB_WV?$allocator@PB_W@std@@@std@@V?$allocator@V?$vector@PB_WV?$allocator@PB_W@std@@@std@@@2@@std@@QAEXXZ
.text$mn:00007F78 ?clear@?$vector@V?$vector@PB_WV?$allocator@PB_W@std@@@std@@V?$allocator@V?$vector@PB_WV?$allocator@PB_W@std@@@std@@@2@@std@@QAEXXZ proc near
.text$mn:00007F78                                         ; CODE XREF: FunctionCallTip::reset(void)+2Bp
.text$mn:00007F78
.text$mn:00007F78 var_4           = dword ptr -4
.text$mn:00007F78
.text$mn:00007F78                 push    ebp
.text$mn:00007F79                 mov     ebp, esp
.text$mn:00007F7B                 push    ecx
.text$mn:00007F7C                 mov     [ebp+var_4], ecx
.text$mn:00007F7F                 mov     ecx, [ebp+var_4] ; this
.text$mn:00007F82                 call    ?_Orphan_all@_Container_base12@std@@QAEXXZ ; std::_Container_base12::_Orphan_all(void)
.text$mn:00007F87                 mov     eax, [ebp+var_4]
.text$mn:00007F8A                 mov     ecx, [eax+8]
.text$mn:00007F8D                 push    ecx
.text$mn:00007F8E                 mov     edx, [ebp+var_4]
.text$mn:00007F91                 mov     eax, [edx+4]
.text$mn:00007F94                 push    eax
.text$mn:00007F95                 mov     ecx, [ebp+var_4]
.text$mn:00007F98                 call    ?_Destroy@?$vector@V?$vector@PB_WV?$allocator@PB_W@std@@@std@@V?$allocator@V?$vector@PB_WV?$allocator@PB_W@std@@@std@@@2@@std@@IAEXPAV?$vector@PB_WV?$allocator@PB_W@std@@@2@0@Z ; std::vector<std::vector<wchar_t const *,std::allocator<wchar_t const *>>,std::allocator<std::vector<wchar_t const *,std::allocator<wchar_t const *>>>>::_Destroy(std::vector<wchar_t const *,std::allocator<wchar_t const *>> *,std::vector<wchar_t const *,std::allocator<wchar_t const *>> *)
.text$mn:00007F9D                 mov     ecx, [ebp+var_4]
.text$mn:00007FA0                 mov     edx, [ebp+var_4]
.text$mn:00007FA3                 mov     eax, [edx+4]
.text$mn:00007FA6                 mov     [ecx+8], eax
.text$mn:00007FA9                 mov     esp, ebp
.text$mn:00007FAB                 pop     ebp
.text$mn:00007FAC                 retn
.text$mn:00007FAC ?clear@?$vector@V?$vector@PB_WV?$allocator@PB_W@std@@@std@@V?$allocator@V?$vector@PB_WV?$allocator@PB_W@std@@@std@@@2@@std@@QAEXXZ endp
.text$mn:00007FAC
.text$mn:00007FAC ; ---------------------------------------------------------------------------
.text$mn:00007FAD                 align 10h
.text$mn:00007FAD _text$mn        ends
.text$mn:00007FAD
.text$mn:00007FB0 ; ===========================================================================
.text$mn:00007FB0
.text$mn:00007FB0 ; Segment type: Pure code
.text$mn:00007FB0 ; Segment permissions: Read/Execute
.text$mn:00007FB0 _text$mn        segment para public 'CODE' use32
.text$mn:00007FB0                 assume cs:_text$mn
.text$mn:00007FB0                 ;org 7FB0h
.text$mn:00007FB0 ; COMDAT (pick any)
.text$mn:00007FB0                 assume es:nothing, ss:nothing, ds:_data, fs:nothing, gs:nothing
.text$mn:00007FB0
.text$mn:00007FB0 ; =============== S U B R O U T I N E =======================================
.text$mn:00007FB0
.text$mn:00007FB0 ; Attributes: bp-based frame
.text$mn:00007FB0
.text$mn:00007FB0 ; int __stdcall std::allocator<wchar_t const *>::construct(void *, int)
.text$mn:00007FB0                 public ?construct@?$allocator@PB_W@std@@QAEXPAPB_WABQB_W@Z
.text$mn:00007FB0 ?construct@?$allocator@PB_W@std@@QAEXPAPB_WABQB_W@Z proc near
.text$mn:00007FB0                                         ; CODE XREF: std::allocator_traits<std::allocator<wchar_t const *>>::construct<wchar_t const *,wchar_t const * const &>(std::allocator<wchar_t const *> &,wchar_t const * *,wchar_t const * const &)+17p
.text$mn:00007FB0
.text$mn:00007FB0 var_C           = dword ptr -0Ch
.text$mn:00007FB0 var_8           = dword ptr -8
.text$mn:00007FB0 var_4           = dword ptr -4
.text$mn:00007FB0 arg_0           = dword ptr  8
.text$mn:00007FB0 arg_4           = dword ptr  0Ch
.text$mn:00007FB0
.text$mn:00007FB0                 push    ebp
.text$mn:00007FB1                 mov     ebp, esp
.text$mn:00007FB3                 sub     esp, 0Ch
.text$mn:00007FB6                 mov     [ebp+var_C], ecx
.text$mn:00007FB9                 mov     eax, [ebp+arg_0]
.text$mn:00007FBC                 push    eax             ; void *
.text$mn:00007FBD                 push    4               ; unsigned int
.text$mn:00007FBF                 call    ??2@YAPAXIPAX@Z ; operator new(uint,void *)
.text$mn:00007FC4                 add     esp, 8
.text$mn:00007FC7                 mov     [ebp+var_4], eax
.text$mn:00007FCA                 cmp     [ebp+var_4], 0
.text$mn:00007FCE                 jz      short loc_7FE2
.text$mn:00007FD0                 mov     ecx, [ebp+var_4]
.text$mn:00007FD3                 mov     edx, [ebp+arg_4]
.text$mn:00007FD6                 mov     eax, [edx]
.text$mn:00007FD8                 mov     [ecx], eax
.text$mn:00007FDA                 mov     ecx, [ebp+var_4]
.text$mn:00007FDD                 mov     [ebp+var_8], ecx
.text$mn:00007FE0                 jmp     short loc_7FE9
.text$mn:00007FE2 ; ---------------------------------------------------------------------------
.text$mn:00007FE2
.text$mn:00007FE2 loc_7FE2:                               ; CODE XREF: std::allocator<wchar_t const *>::construct(wchar_t const * *,wchar_t const * const &)+1Ej
.text$mn:00007FE2                 mov     [ebp+var_8], 0
.text$mn:00007FE9
.text$mn:00007FE9 loc_7FE9:                               ; CODE XREF: std::allocator<wchar_t const *>::construct(wchar_t const * *,wchar_t const * const &)+30j
.text$mn:00007FE9                 mov     esp, ebp
.text$mn:00007FEB                 pop     ebp
.text$mn:00007FEC                 retn    8
.text$mn:00007FEC ?construct@?$allocator@PB_W@std@@QAEXPAPB_WABQB_W@Z endp
.text$mn:00007FEC
.text$mn:00007FEC ; ---------------------------------------------------------------------------
.text$mn:00007FEF                 align 10h
.text$mn:00007FEF _text$mn        ends
.text$mn:00007FEF
.text$mn:00007FF0 ; ===========================================================================
.text$mn:00007FF0
.text$mn:00007FF0 ; Segment type: Pure code
.text$mn:00007FF0 ; Segment permissions: Read/Execute
.text$mn:00007FF0 _text$mn        segment para public 'CODE' use32
.text$mn:00007FF0                 assume cs:_text$mn
.text$mn:00007FF0                 ;org 7FF0h
.text$mn:00007FF0 ; COMDAT (pick any)
.text$mn:00007FF0                 assume es:nothing, ss:nothing, ds:_data, fs:nothing, gs:nothing
.text$mn:00007FF0
.text$mn:00007FF0 ; =============== S U B R O U T I N E =======================================
.text$mn:00007FF0
.text$mn:00007FF0 ; Attributes: bp-based frame
.text$mn:00007FF0
.text$mn:00007FF0 ; int __stdcall std::allocator<FunctionValues>::construct(void *, int)
.text$mn:00007FF0                 public ?construct@?$allocator@UFunctionValues@@@std@@QAEXPAUFunctionValues@@ABU3@@Z
.text$mn:00007FF0 ?construct@?$allocator@UFunctionValues@@@std@@QAEXPAUFunctionValues@@ABU3@@Z proc near
.text$mn:00007FF0                                         ; CODE XREF: std::allocator_traits<std::allocator<FunctionValues>>::construct<FunctionValues,FunctionValues const &>(std::allocator<FunctionValues> &,FunctionValues *,FunctionValues const &)+17p
.text$mn:00007FF0
.text$mn:00007FF0 var_C           = dword ptr -0Ch
.text$mn:00007FF0 var_8           = dword ptr -8
.text$mn:00007FF0 var_4           = dword ptr -4
.text$mn:00007FF0 arg_0           = dword ptr  8
.text$mn:00007FF0 arg_4           = dword ptr  0Ch
.text$mn:00007FF0
.text$mn:00007FF0                 push    ebp
.text$mn:00007FF1                 mov     ebp, esp
.text$mn:00007FF3                 sub     esp, 0Ch
.text$mn:00007FF6                 mov     [ebp+var_C], ecx
.text$mn:00007FF9                 mov     eax, [ebp+arg_0]
.text$mn:00007FFC                 push    eax             ; void *
.text$mn:00007FFD                 push    10h             ; unsigned int
.text$mn:00007FFF                 call    ??2@YAPAXIPAX@Z ; operator new(uint,void *)
.text$mn:00008004                 add     esp, 8
.text$mn:00008007                 mov     [ebp+var_4], eax
.text$mn:0000800A                 cmp     [ebp+var_4], 0
.text$mn:0000800E                 jz      short loc_8034
.text$mn:00008010                 mov     ecx, [ebp+arg_4]
.text$mn:00008013                 mov     edx, [ebp+var_4]
.text$mn:00008016                 mov     eax, [ecx]
.text$mn:00008018                 mov     [edx], eax
.text$mn:0000801A                 mov     eax, [ecx+4]
.text$mn:0000801D                 mov     [edx+4], eax
.text$mn:00008020                 mov     eax, [ecx+8]
.text$mn:00008023                 mov     [edx+8], eax
.text$mn:00008026                 mov     ecx, [ecx+0Ch]
.text$mn:00008029                 mov     [edx+0Ch], ecx
.text$mn:0000802C                 mov     edx, [ebp+var_4]
.text$mn:0000802F                 mov     [ebp+var_8], edx
.text$mn:00008032                 jmp     short loc_803B
.text$mn:00008034 ; ---------------------------------------------------------------------------
.text$mn:00008034
.text$mn:00008034 loc_8034:                               ; CODE XREF: std::allocator<FunctionValues>::construct(FunctionValues *,FunctionValues const &)+1Ej
.text$mn:00008034                 mov     [ebp+var_8], 0
.text$mn:0000803B
.text$mn:0000803B loc_803B:                               ; CODE XREF: std::allocator<FunctionValues>::construct(FunctionValues *,FunctionValues const &)+42j
.text$mn:0000803B                 mov     esp, ebp
.text$mn:0000803D                 pop     ebp
.text$mn:0000803E                 retn    8
.text$mn:0000803E ?construct@?$allocator@UFunctionValues@@@std@@QAEXPAUFunctionValues@@ABU3@@Z endp
.text$mn:0000803E
.text$mn:0000803E ; ---------------------------------------------------------------------------
.text$mn:00008041                 align 4
.text$mn:00008041 _text$mn        ends
.text$mn:00008041
.text$mn:00008044 ; ===========================================================================
.text$mn:00008044
.text$mn:00008044 ; Segment type: Pure code
.text$mn:00008044 ; Segment permissions: Read/Execute
.text$mn:00008044 _text$mn        segment para public 'CODE' use32
.text$mn:00008044                 assume cs:_text$mn
.text$mn:00008044                 ;org 8044h
.text$mn:00008044 ; COMDAT (pick any)
.text$mn:00008044                 assume es:nothing, ss:nothing, ds:_data, fs:nothing, gs:nothing
.text$mn:00008044
.text$mn:00008044 ; =============== S U B R O U T I N E =======================================
.text$mn:00008044
.text$mn:00008044 ; Attributes: bp-based frame
.text$mn:00008044
.text$mn:00008044 ; int __stdcall std::allocator<std::vector<wchar_t const *,std::allocator<wchar_t const *>>>::construct(void *, int)
.text$mn:00008044                 public ?construct@?$allocator@V?$vector@PB_WV?$allocator@PB_W@std@@@std@@@std@@QAEXPAV?$vector@PB_WV?$allocator@PB_W@std@@@2@ABV32@@Z
.text$mn:00008044 ?construct@?$allocator@V?$vector@PB_WV?$allocator@PB_W@std@@@std@@@std@@QAEXPAV?$vector@PB_WV?$allocator@PB_W@std@@@2@ABV32@@Z proc near
.text$mn:00008044                                         ; CODE XREF: std::allocator_traits<std::allocator<std::vector<wchar_t const *,std::allocator<wchar_t const *>>>>::construct<std::vector<wchar_t const *,std::allocator<wchar_t const *>>,std::vector<wchar_t const *,std::allocator<wchar_t const *>> const &>(std::allocator<std::vector<wchar_t const *,std::allocator<wchar_t const *>>> &,std::vector<wchar_t const *,std::allocator<wchar_t const *>> *,std::vector<wchar_t const *,std::allocator<wchar_t const *>> const &)+17p
.text$mn:00008044
.text$mn:00008044 var_1C          = dword ptr -1Ch
.text$mn:00008044 var_18          = dword ptr -18h
.text$mn:00008044 var_14          = dword ptr -14h
.text$mn:00008044 var_10          = dword ptr -10h
.text$mn:00008044 var_C           = dword ptr -0Ch
.text$mn:00008044 var_4           = dword ptr -4
.text$mn:00008044 arg_0           = dword ptr  8
.text$mn:00008044 arg_4           = dword ptr  0Ch
.text$mn:00008044
.text$mn:00008044                 push    ebp
.text$mn:00008045                 mov     ebp, esp
.text$mn:00008047                 push    0FFFFFFFFh
.text$mn:00008049                 push    offset __ehhandler$?construct@?$allocator@V?$vector@PB_WV?$allocator@PB_W@std@@@std@@@std@@QAEXPAV?$vector@PB_WV?$allocator@PB_W@std@@@2@ABV32@@Z
.text$mn:0000804E                 mov     eax, large fs:0
.text$mn:00008054                 push    eax
.text$mn:00008055                 sub     esp, 10h
.text$mn:00008058                 mov     eax, dword ptr ds:___security_cookie
.text$mn:0000805D                 xor     eax, ebp
.text$mn:0000805F                 push    eax
.text$mn:00008060                 lea     eax, [ebp+var_C]
.text$mn:00008063                 mov     large fs:0, eax
.text$mn:00008069                 mov     [ebp+var_18], ecx
.text$mn:0000806C                 mov     eax, [ebp+arg_0]
.text$mn:0000806F                 push    eax             ; void *
.text$mn:00008070                 push    10h             ; unsigned int
.text$mn:00008072                 call    ??2@YAPAXIPAX@Z ; operator new(uint,void *)
.text$mn:00008077                 add     esp, 8
.text$mn:0000807A                 mov     [ebp+var_10], eax
.text$mn:0000807D                 mov     [ebp+var_4], 0
.text$mn:00008084                 cmp     [ebp+var_10], 0
.text$mn:00008088                 jz      short loc_809B
.text$mn:0000808A                 mov     ecx, [ebp+arg_4]
.text$mn:0000808D                 push    ecx
.text$mn:0000808E                 mov     ecx, [ebp+var_10]
.text$mn:00008091                 call    ??0?$vector@PB_WV?$allocator@PB_W@std@@@std@@QAE@ABV01@@Z ; std::vector<wchar_t const *,std::allocator<wchar_t const *>>::vector<wchar_t const *,std::allocator<wchar_t const *>>(std::vector<wchar_t const *,std::allocator<wchar_t const *>> const &)
.text$mn:00008096                 mov     [ebp+var_14], eax
.text$mn:00008099                 jmp     short loc_80A2
.text$mn:0000809B ; ---------------------------------------------------------------------------
.text$mn:0000809B
.text$mn:0000809B loc_809B:                               ; CODE XREF: std::allocator<std::vector<wchar_t const *,std::allocator<wchar_t const *>>>::construct(std::vector<wchar_t const *,std::allocator<wchar_t const *>> *,std::vector<wchar_t const *,std::allocator<wchar_t const *>> const &)+44j
.text$mn:0000809B                 mov     [ebp+var_14], 0
.text$mn:000080A2
.text$mn:000080A2 loc_80A2:                               ; CODE XREF: std::allocator<std::vector<wchar_t const *,std::allocator<wchar_t const *>>>::construct(std::vector<wchar_t const *,std::allocator<wchar_t const *>> *,std::vector<wchar_t const *,std::allocator<wchar_t const *>> const &)+55j
.text$mn:000080A2                 mov     edx, [ebp+var_14]
.text$mn:000080A5                 mov     [ebp+var_1C], edx
.text$mn:000080A8                 mov     [ebp+var_4], 0FFFFFFFFh
.text$mn:000080AF                 mov     ecx, [ebp+var_C]
.text$mn:000080B2                 mov     large fs:0, ecx
.text$mn:000080B9                 pop     ecx
.text$mn:000080BA                 mov     esp, ebp
.text$mn:000080BC                 pop     ebp
.text$mn:000080BD                 retn    8
.text$mn:000080BD ?construct@?$allocator@V?$vector@PB_WV?$allocator@PB_W@std@@@std@@@std@@QAEXPAV?$vector@PB_WV?$allocator@PB_W@std@@@2@ABV32@@Z endp
.text$mn:000080BD
.text$mn:000080BD _text$mn        ends
.text$mn:000080BD
.text$x:000080C0 ; ===========================================================================
.text$x:000080C0
.text$x:000080C0 ; Segment type: Pure code
.text$x:000080C0 ; Segment permissions: Read/Execute
.text$x:000080C0 _text$x         segment para public 'CODE' use32
.text$x:000080C0                 assume cs:_text$x
.text$x:000080C0                 ;org 80C0h
.text$x:000080C0 ; COMDAT (pick associative to section at 8044)
.text$x:000080C0                 assume es:nothing, ss:nothing, ds:_data, fs:nothing, gs:nothing
.text$x:000080C0
.text$x:000080C0 ; =============== S U B R O U T I N E =======================================
.text$x:000080C0
.text$x:000080C0
.text$x:000080C0 __unwindfunclet$?construct@?$allocator@V?$vector@PB_WV?$allocator@PB_W@std@@@std@@@std@@QAEXPAV?$vector@PB_WV?$allocator@PB_W@std@@@2@ABV32@@Z$0 proc near
.text$x:000080C0                                         ; DATA XREF: .xdata$x:000098A8o
.text$x:000080C0                 mov     eax, [ebp+8]
.text$x:000080C3                 push    eax
.text$x:000080C4                 mov     eax, [ebp-10h]
.text$x:000080C7                 push    eax             ; void *
.text$x:000080C8                 call    ??3@YAXPAX0@Z   ; operator delete(void *,void *)
.text$x:000080CD                 add     esp, 8
.text$x:000080D0                 retn
.text$x:000080D0 __unwindfunclet$?construct@?$allocator@V?$vector@PB_WV?$allocator@PB_W@std@@@std@@@std@@QAEXPAV?$vector@PB_WV?$allocator@PB_W@std@@@2@ABV32@@Z$0 endp
.text$x:000080D0
.text$x:000080D1
.text$x:000080D1 ; =============== S U B R O U T I N E =======================================
.text$x:000080D1
.text$x:000080D1
.text$x:000080D1 __ehhandler$?construct@?$allocator@V?$vector@PB_WV?$allocator@PB_W@std@@@std@@@std@@QAEXPAV?$vector@PB_WV?$allocator@PB_W@std@@@2@ABV32@@Z proc near
.text$x:000080D1                                         ; DATA XREF: std::allocator<std::vector<wchar_t const *,std::allocator<wchar_t const *>>>::construct(std::vector<wchar_t const *,std::allocator<wchar_t const *>> *,std::vector<wchar_t const *,std::allocator<wchar_t const *>> const &)+5o
.text$x:000080D1
.text$x:000080D1 arg_4           = dword ptr  8
.text$x:000080D1
.text$x:000080D1                 mov     edx, [esp+arg_4]
.text$x:000080D5                 lea     eax, [edx+0Ch]
.text$x:000080D8                 mov     ecx, [edx-14h]
.text$x:000080DB                 xor     ecx, eax
.text$x:000080DD                 call    @__security_check_cookie@4 ; __security_check_cookie(x)
.text$x:000080E2                 mov     eax, offset __ehfuncinfo$?construct@?$allocator@V?$vector@PB_WV?$allocator@PB_W@std@@@std@@@std@@QAEXPAV?$vector@PB_WV?$allocator@PB_W@std@@@2@ABV32@@Z
.text$x:000080E7                 jmp     ___CxxFrameHandler3
.text$x:000080E7 __ehhandler$?construct@?$allocator@V?$vector@PB_WV?$allocator@PB_W@std@@@std@@@std@@QAEXPAV?$vector@PB_WV?$allocator@PB_W@std@@@2@ABV32@@Z endp
.text$x:000080E7
.text$x:000080E7 _text$x         ends
.text$x:000080E7
.text$mn:000080EC ; ===========================================================================
.text$mn:000080EC
.text$mn:000080EC ; Segment type: Pure code
.text$mn:000080EC ; Segment permissions: Read/Execute
.text$mn:000080EC _text$mn        segment para public 'CODE' use32
.text$mn:000080EC                 assume cs:_text$mn
.text$mn:000080EC                 ;org 80ECh
.text$mn:000080EC ; COMDAT (pick any)
.text$mn:000080EC                 assume es:nothing, ss:nothing, ds:_data, fs:nothing, gs:nothing
.text$mn:000080EC
.text$mn:000080EC ; =============== S U B R O U T I N E =======================================
.text$mn:000080EC
.text$mn:000080EC ; Attributes: bp-based frame
.text$mn:000080EC
.text$mn:000080EC ; int __cdecl std::char_traits<char>::copy(void *Dst, void *Src, size_t Size)
.text$mn:000080EC                 public ?copy@?$char_traits@D@std@@SAPADPADPBDI@Z
.text$mn:000080EC ?copy@?$char_traits@D@std@@SAPADPADPBDI@Z proc near ; CODE XREF: $LN19+1Ep
.text$mn:000080EC                                         ; std::basic_string<char,std::char_traits<char>,std::allocator<char>>::_Tidy(bool,uint)+5Dp ...
.text$mn:000080EC
.text$mn:000080EC var_4           = dword ptr -4
.text$mn:000080EC Dst             = dword ptr  8
.text$mn:000080EC Src             = dword ptr  0Ch
.text$mn:000080EC Size            = dword ptr  10h
.text$mn:000080EC
.text$mn:000080EC                 push    ebp
.text$mn:000080ED                 mov     ebp, esp
.text$mn:000080EF                 push    ecx
.text$mn:000080F0                 cmp     [ebp+Size], 0
.text$mn:000080F4                 jnz     short loc_80FE
.text$mn:000080F6                 mov     eax, [ebp+Dst]
.text$mn:000080F9                 mov     [ebp+var_4], eax
.text$mn:000080FC                 jmp     short loc_8115
.text$mn:000080FE ; ---------------------------------------------------------------------------
.text$mn:000080FE
.text$mn:000080FE loc_80FE:                               ; CODE XREF: std::char_traits<char>::copy(char *,char const *,uint)+8j
.text$mn:000080FE                 mov     ecx, [ebp+Size]
.text$mn:00008101                 push    ecx             ; Size
.text$mn:00008102                 mov     edx, [ebp+Src]
.text$mn:00008105                 push    edx             ; Src
.text$mn:00008106                 mov     eax, [ebp+Dst]
.text$mn:00008109                 push    eax             ; Dst
.text$mn:0000810A                 call    _memcpy
.text$mn:0000810F                 add     esp, 0Ch
.text$mn:00008112                 mov     [ebp+var_4], eax
.text$mn:00008115
.text$mn:00008115 loc_8115:                               ; CODE XREF: std::char_traits<char>::copy(char *,char const *,uint)+10j
.text$mn:00008115                 mov     eax, [ebp+var_4]
.text$mn:00008118                 mov     esp, ebp
.text$mn:0000811A                 pop     ebp
.text$mn:0000811B                 retn
.text$mn:0000811B ?copy@?$char_traits@D@std@@SAPADPADPBDI@Z endp
.text$mn:0000811B
.text$mn:0000811B _text$mn        ends
.text$mn:0000811B
.text$mn:0000811C ; ===========================================================================
.text$mn:0000811C
.text$mn:0000811C ; Segment type: Pure code
.text$mn:0000811C ; Segment permissions: Read/Execute
.text$mn:0000811C _text$mn        segment para public 'CODE' use32
.text$mn:0000811C                 assume cs:_text$mn
.text$mn:0000811C                 ;org 811Ch
.text$mn:0000811C ; COMDAT (pick any)
.text$mn:0000811C                 assume es:nothing, ss:nothing, ds:_data, fs:nothing, gs:nothing
.text$mn:0000811C
.text$mn:0000811C ; =============== S U B R O U T I N E =======================================
.text$mn:0000811C
.text$mn:0000811C ; Attributes: bp-based frame
.text$mn:0000811C
.text$mn:0000811C ; int __stdcall std::_Wrap_alloc<std::allocator<char>>::deallocate(void *, int)
.text$mn:0000811C                 public ?deallocate@?$_Wrap_alloc@V?$allocator@D@std@@@std@@QAEXPADI@Z
.text$mn:0000811C ?deallocate@?$_Wrap_alloc@V?$allocator@D@std@@@std@@QAEXPADI@Z proc near
.text$mn:0000811C                                         ; CODE XREF: std::basic_string<char,std::char_traits<char>,std::allocator<char>>::_Tidy(bool,uint)+81p
.text$mn:0000811C
.text$mn:0000811C var_4           = dword ptr -4
.text$mn:0000811C arg_0           = dword ptr  8
.text$mn:0000811C arg_4           = dword ptr  0Ch
.text$mn:0000811C
.text$mn:0000811C                 push    ebp
.text$mn:0000811D                 mov     ebp, esp
.text$mn:0000811F                 push    ecx
.text$mn:00008120                 mov     [ebp+var_4], ecx
.text$mn:00008123                 mov     eax, [ebp+arg_4]
.text$mn:00008126                 push    eax             ; int
.text$mn:00008127                 mov     ecx, [ebp+arg_0]
.text$mn:0000812A                 push    ecx             ; void *
.text$mn:0000812B                 mov     ecx, [ebp+var_4]
.text$mn:0000812E                 call    ?deallocate@?$allocator@D@std@@QAEXPADI@Z ; std::allocator<char>::deallocate(char *,uint)
.text$mn:00008133                 mov     esp, ebp
.text$mn:00008135                 pop     ebp
.text$mn:00008136                 retn    8
.text$mn:00008136 ?deallocate@?$_Wrap_alloc@V?$allocator@D@std@@@std@@QAEXPADI@Z endp
.text$mn:00008136
.text$mn:00008136 ; ---------------------------------------------------------------------------
.text$mn:00008139                 align 4
.text$mn:00008139 _text$mn        ends
.text$mn:00008139
.text$mn:0000813C ; ===========================================================================
.text$mn:0000813C
.text$mn:0000813C ; Segment type: Pure code
.text$mn:0000813C ; Segment permissions: Read/Execute
.text$mn:0000813C _text$mn        segment para public 'CODE' use32
.text$mn:0000813C                 assume cs:_text$mn
.text$mn:0000813C                 ;org 813Ch
.text$mn:0000813C ; COMDAT (pick any)
.text$mn:0000813C                 assume es:nothing, ss:nothing, ds:_data, fs:nothing, gs:nothing
.text$mn:0000813C
.text$mn:0000813C ; =============== S U B R O U T I N E =======================================
.text$mn:0000813C
.text$mn:0000813C ; Attributes: bp-based frame
.text$mn:0000813C
.text$mn:0000813C ; int __stdcall std::_Wrap_alloc<std::allocator<wchar_t const *>>::deallocate(void *, int)
.text$mn:0000813C                 public ?deallocate@?$_Wrap_alloc@V?$allocator@PB_W@std@@@std@@QAEXPAPB_WI@Z
.text$mn:0000813C ?deallocate@?$_Wrap_alloc@V?$allocator@PB_W@std@@@std@@QAEXPAPB_WI@Z proc near
.text$mn:0000813C                                         ; CODE XREF: __catch$?_Reallocate@?$vector@PB_WV?$allocator@PB_W@std@@@std@@IAEXI@Z$0+16p
.text$mn:0000813C                                         ; std::vector<wchar_t const *,std::allocator<wchar_t const *>>::_Reallocate(uint)+F5p ...
.text$mn:0000813C
.text$mn:0000813C var_4           = dword ptr -4
.text$mn:0000813C arg_0           = dword ptr  8
.text$mn:0000813C arg_4           = dword ptr  0Ch
.text$mn:0000813C
.text$mn:0000813C                 push    ebp
.text$mn:0000813D                 mov     ebp, esp
.text$mn:0000813F                 push    ecx
.text$mn:00008140                 mov     [ebp+var_4], ecx
.text$mn:00008143                 mov     eax, [ebp+arg_4]
.text$mn:00008146                 push    eax             ; int
.text$mn:00008147                 mov     ecx, [ebp+arg_0]
.text$mn:0000814A                 push    ecx             ; void *
.text$mn:0000814B                 mov     ecx, [ebp+var_4]
.text$mn:0000814E                 call    ?deallocate@?$allocator@PB_W@std@@QAEXPAPB_WI@Z ; std::allocator<wchar_t const *>::deallocate(wchar_t const * *,uint)
.text$mn:00008153                 mov     esp, ebp
.text$mn:00008155                 pop     ebp
.text$mn:00008156                 retn    8
.text$mn:00008156 ?deallocate@?$_Wrap_alloc@V?$allocator@PB_W@std@@@std@@QAEXPAPB_WI@Z endp
.text$mn:00008156
.text$mn:00008156 ; ---------------------------------------------------------------------------
.text$mn:00008159                 align 4
.text$mn:00008159 _text$mn        ends
.text$mn:00008159
.text$mn:0000815C ; ===========================================================================
.text$mn:0000815C
.text$mn:0000815C ; Segment type: Pure code
.text$mn:0000815C ; Segment permissions: Read/Execute
.text$mn:0000815C _text$mn        segment para public 'CODE' use32
.text$mn:0000815C                 assume cs:_text$mn
.text$mn:0000815C                 ;org 815Ch
.text$mn:0000815C ; COMDAT (pick any)
.text$mn:0000815C                 assume es:nothing, ss:nothing, ds:_data, fs:nothing, gs:nothing
.text$mn:0000815C
.text$mn:0000815C ; =============== S U B R O U T I N E =======================================
.text$mn:0000815C
.text$mn:0000815C ; Attributes: bp-based frame
.text$mn:0000815C
.text$mn:0000815C ; int __stdcall std::_Wrap_alloc<std::allocator<FunctionValues>>::deallocate(void *, int)
.text$mn:0000815C                 public ?deallocate@?$_Wrap_alloc@V?$allocator@UFunctionValues@@@std@@@std@@QAEXPAUFunctionValues@@I@Z
.text$mn:0000815C ?deallocate@?$_Wrap_alloc@V?$allocator@UFunctionValues@@@std@@@std@@QAEXPAUFunctionValues@@I@Z proc near
.text$mn:0000815C                                         ; CODE XREF: __catch$?_Reallocate@?$vector@UFunctionValues@@V?$allocator@UFunctionValues@@@std@@@std@@IAEXI@Z$0+16p
.text$mn:0000815C                                         ; std::vector<FunctionValues,std::allocator<FunctionValues>>::_Reallocate(uint)+F5p ...
.text$mn:0000815C
.text$mn:0000815C var_4           = dword ptr -4
.text$mn:0000815C arg_0           = dword ptr  8
.text$mn:0000815C arg_4           = dword ptr  0Ch
.text$mn:0000815C
.text$mn:0000815C                 push    ebp
.text$mn:0000815D                 mov     ebp, esp
.text$mn:0000815F                 push    ecx
.text$mn:00008160                 mov     [ebp+var_4], ecx
.text$mn:00008163                 mov     eax, [ebp+arg_4]
.text$mn:00008166                 push    eax             ; int
.text$mn:00008167                 mov     ecx, [ebp+arg_0]
.text$mn:0000816A                 push    ecx             ; void *
.text$mn:0000816B                 mov     ecx, [ebp+var_4]
.text$mn:0000816E                 call    ?deallocate@?$allocator@UFunctionValues@@@std@@QAEXPAUFunctionValues@@I@Z ; std::allocator<FunctionValues>::deallocate(FunctionValues *,uint)
.text$mn:00008173                 mov     esp, ebp
.text$mn:00008175                 pop     ebp
.text$mn:00008176                 retn    8
.text$mn:00008176 ?deallocate@?$_Wrap_alloc@V?$allocator@UFunctionValues@@@std@@@std@@QAEXPAUFunctionValues@@I@Z endp
.text$mn:00008176
.text$mn:00008176 ; ---------------------------------------------------------------------------
.text$mn:00008179                 align 4
.text$mn:00008179 _text$mn        ends
.text$mn:00008179
.text$mn:0000817C ; ===========================================================================
.text$mn:0000817C
.text$mn:0000817C ; Segment type: Pure code
.text$mn:0000817C ; Segment permissions: Read/Execute
.text$mn:0000817C _text$mn        segment para public 'CODE' use32
.text$mn:0000817C                 assume cs:_text$mn
.text$mn:0000817C                 ;org 817Ch
.text$mn:0000817C ; COMDAT (pick any)
.text$mn:0000817C                 assume es:nothing, ss:nothing, ds:_data, fs:nothing, gs:nothing
.text$mn:0000817C
.text$mn:0000817C ; =============== S U B R O U T I N E =======================================
.text$mn:0000817C
.text$mn:0000817C ; Attributes: bp-based frame
.text$mn:0000817C
.text$mn:0000817C ; int __stdcall std::_Wrap_alloc<std::allocator<Token>>::deallocate(void *, int)
.text$mn:0000817C                 public ?deallocate@?$_Wrap_alloc@V?$allocator@UToken@@@std@@@std@@QAEXPAUToken@@I@Z
.text$mn:0000817C ?deallocate@?$_Wrap_alloc@V?$allocator@UToken@@@std@@@std@@QAEXPAUToken@@I@Z proc near
.text$mn:0000817C                                         ; CODE XREF: __catch$?_Reallocate@?$vector@UToken@@V?$allocator@UToken@@@std@@@std@@IAEXI@Z$0+16p
.text$mn:0000817C                                         ; std::vector<Token,std::allocator<Token>>::_Reallocate(uint)+FAp ...
.text$mn:0000817C
.text$mn:0000817C var_4           = dword ptr -4
.text$mn:0000817C arg_0           = dword ptr  8
.text$mn:0000817C arg_4           = dword ptr  0Ch
.text$mn:0000817C
.text$mn:0000817C                 push    ebp
.text$mn:0000817D                 mov     ebp, esp
.text$mn:0000817F                 push    ecx
.text$mn:00008180                 mov     [ebp+var_4], ecx
.text$mn:00008183                 mov     eax, [ebp+arg_4]
.text$mn:00008186                 push    eax             ; int
.text$mn:00008187                 mov     ecx, [ebp+arg_0]
.text$mn:0000818A                 push    ecx             ; void *
.text$mn:0000818B                 mov     ecx, [ebp+var_4]
.text$mn:0000818E                 call    ?deallocate@?$allocator@UToken@@@std@@QAEXPAUToken@@I@Z ; std::allocator<Token>::deallocate(Token *,uint)
.text$mn:00008193                 mov     esp, ebp
.text$mn:00008195                 pop     ebp
.text$mn:00008196                 retn    8
.text$mn:00008196 ?deallocate@?$_Wrap_alloc@V?$allocator@UToken@@@std@@@std@@QAEXPAUToken@@I@Z endp
.text$mn:00008196
.text$mn:00008196 ; ---------------------------------------------------------------------------
.text$mn:00008199                 align 4
.text$mn:00008199 _text$mn        ends
.text$mn:00008199
.text$mn:0000819C ; ===========================================================================
.text$mn:0000819C
.text$mn:0000819C ; Segment type: Pure code
.text$mn:0000819C ; Segment permissions: Read/Execute
.text$mn:0000819C _text$mn        segment para public 'CODE' use32
.text$mn:0000819C                 assume cs:_text$mn
.text$mn:0000819C                 ;org 819Ch
.text$mn:0000819C ; COMDAT (pick any)
.text$mn:0000819C                 assume es:nothing, ss:nothing, ds:_data, fs:nothing, gs:nothing
.text$mn:0000819C
.text$mn:0000819C ; =============== S U B R O U T I N E =======================================
.text$mn:0000819C
.text$mn:0000819C ; Attributes: bp-based frame
.text$mn:0000819C
.text$mn:0000819C ; int __stdcall std::_Wrap_alloc<std::allocator<std::_Container_proxy>>::deallocate(void *, int)
.text$mn:0000819C                 public ?deallocate@?$_Wrap_alloc@V?$allocator@U_Container_proxy@std@@@std@@@std@@QAEXPAU_Container_proxy@2@I@Z
.text$mn:0000819C ?deallocate@?$_Wrap_alloc@V?$allocator@U_Container_proxy@std@@@std@@@std@@QAEXPAU_Container_proxy@2@I@Z proc near
.text$mn:0000819C                                         ; CODE XREF: std::_Vector_alloc<0,std::_Vec_base_types<wchar_t const *,std::allocator<wchar_t const *>>>::_Free_proxy(void)+32p
.text$mn:0000819C                                         ; std::_Vector_alloc<0,std::_Vec_base_types<FunctionValues,std::allocator<FunctionValues>>>::_Free_proxy(void)+32p ...
.text$mn:0000819C
.text$mn:0000819C var_4           = dword ptr -4
.text$mn:0000819C arg_0           = dword ptr  8
.text$mn:0000819C arg_4           = dword ptr  0Ch
.text$mn:0000819C
.text$mn:0000819C                 push    ebp
.text$mn:0000819D                 mov     ebp, esp
.text$mn:0000819F                 push    ecx
.text$mn:000081A0                 mov     [ebp+var_4], ecx
.text$mn:000081A3                 mov     eax, [ebp+arg_4]
.text$mn:000081A6                 push    eax             ; int
.text$mn:000081A7                 mov     ecx, [ebp+arg_0]
.text$mn:000081AA                 push    ecx             ; void *
.text$mn:000081AB                 mov     ecx, [ebp+var_4]
.text$mn:000081AE                 call    ?deallocate@?$allocator@U_Container_proxy@std@@@std@@QAEXPAU_Container_proxy@2@I@Z ; std::allocator<std::_Container_proxy>::deallocate(std::_Container_proxy *,uint)
.text$mn:000081B3                 mov     esp, ebp
.text$mn:000081B5                 pop     ebp
.text$mn:000081B6                 retn    8
.text$mn:000081B6 ?deallocate@?$_Wrap_alloc@V?$allocator@U_Container_proxy@std@@@std@@@std@@QAEXPAU_Container_proxy@2@I@Z endp
.text$mn:000081B6
.text$mn:000081B6 ; ---------------------------------------------------------------------------
.text$mn:000081B9                 align 4
.text$mn:000081B9 _text$mn        ends
.text$mn:000081B9
.text$mn:000081BC ; ===========================================================================
.text$mn:000081BC
.text$mn:000081BC ; Segment type: Pure code
.text$mn:000081BC ; Segment permissions: Read/Execute
.text$mn:000081BC _text$mn        segment para public 'CODE' use32
.text$mn:000081BC                 assume cs:_text$mn
.text$mn:000081BC                 ;org 81BCh
.text$mn:000081BC ; COMDAT (pick any)
.text$mn:000081BC                 assume es:nothing, ss:nothing, ds:_data, fs:nothing, gs:nothing
.text$mn:000081BC
.text$mn:000081BC ; =============== S U B R O U T I N E =======================================
.text$mn:000081BC
.text$mn:000081BC ; Attributes: bp-based frame
.text$mn:000081BC
.text$mn:000081BC ; int __stdcall std::_Wrap_alloc<std::allocator<std::vector<wchar_t const *,std::allocator<wchar_t const *>>>>::deallocate(void *, int)
.text$mn:000081BC                 public ?deallocate@?$_Wrap_alloc@V?$allocator@V?$vector@PB_WV?$allocator@PB_W@std@@@std@@@std@@@std@@QAEXPAV?$vector@PB_WV?$allocator@PB_W@std@@@2@I@Z
.text$mn:000081BC ?deallocate@?$_Wrap_alloc@V?$allocator@V?$vector@PB_WV?$allocator@PB_W@std@@@std@@@std@@@std@@QAEXPAV?$vector@PB_WV?$allocator@PB_W@std@@@2@I@Z proc near
.text$mn:000081BC                                         ; CODE XREF: __catch$?_Reallocate@?$vector@V?$vector@PB_WV?$allocator@PB_W@std@@@std@@V?$allocator@V?$vector@PB_WV?$allocator@PB_W@std@@@std@@@2@@std@@IAEXI@Z$0+16p
.text$mn:000081BC                                         ; std::vector<std::vector<wchar_t const *,std::allocator<wchar_t const *>>,std::allocator<std::vector<wchar_t const *,std::allocator<wchar_t const *>>>>::_Reallocate(uint)+F5p
.text$mn:000081BC
.text$mn:000081BC var_4           = dword ptr -4
.text$mn:000081BC arg_0           = dword ptr  8
.text$mn:000081BC arg_4           = dword ptr  0Ch
.text$mn:000081BC
.text$mn:000081BC                 push    ebp
.text$mn:000081BD                 mov     ebp, esp
.text$mn:000081BF                 push    ecx
.text$mn:000081C0                 mov     [ebp+var_4], ecx
.text$mn:000081C3                 mov     eax, [ebp+arg_4]
.text$mn:000081C6                 push    eax             ; int
.text$mn:000081C7                 mov     ecx, [ebp+arg_0]
.text$mn:000081CA                 push    ecx             ; void *
.text$mn:000081CB                 mov     ecx, [ebp+var_4]
.text$mn:000081CE                 call    ?deallocate@?$allocator@V?$vector@PB_WV?$allocator@PB_W@std@@@std@@@std@@QAEXPAV?$vector@PB_WV?$allocator@PB_W@std@@@2@I@Z ; std::allocator<std::vector<wchar_t const *,std::allocator<wchar_t const *>>>::deallocate(std::vector<wchar_t const *,std::allocator<wchar_t const *>> *,uint)
.text$mn:000081D3                 mov     esp, ebp
.text$mn:000081D5                 pop     ebp
.text$mn:000081D6                 retn    8
.text$mn:000081D6 ?deallocate@?$_Wrap_alloc@V?$allocator@V?$vector@PB_WV?$allocator@PB_W@std@@@std@@@std@@@std@@QAEXPAV?$vector@PB_WV?$allocator@PB_W@std@@@2@I@Z endp
.text$mn:000081D6
.text$mn:000081D6 ; ---------------------------------------------------------------------------
.text$mn:000081D9                 align 4
.text$mn:000081D9 _text$mn        ends
.text$mn:000081D9
.text$mn:000081DC ; ===========================================================================
.text$mn:000081DC
.text$mn:000081DC ; Segment type: Pure code
.text$mn:000081DC ; Segment permissions: Read/Execute
.text$mn:000081DC _text$mn        segment para public 'CODE' use32
.text$mn:000081DC                 assume cs:_text$mn
.text$mn:000081DC                 ;org 81DCh
.text$mn:000081DC ; COMDAT (pick any)
.text$mn:000081DC                 assume es:nothing, ss:nothing, ds:_data, fs:nothing, gs:nothing
.text$mn:000081DC
.text$mn:000081DC ; =============== S U B R O U T I N E =======================================
.text$mn:000081DC
.text$mn:000081DC ; Attributes: bp-based frame
.text$mn:000081DC
.text$mn:000081DC ; int __stdcall std::allocator<char>::deallocate(void *, int)
.text$mn:000081DC                 public ?deallocate@?$allocator@D@std@@QAEXPADI@Z
.text$mn:000081DC ?deallocate@?$allocator@D@std@@QAEXPADI@Z proc near
.text$mn:000081DC                                         ; CODE XREF: std::_Wrap_alloc<std::allocator<char>>::deallocate(char *,uint)+12p
.text$mn:000081DC
.text$mn:000081DC var_4           = dword ptr -4
.text$mn:000081DC arg_0           = dword ptr  8
.text$mn:000081DC
.text$mn:000081DC                 push    ebp
.text$mn:000081DD                 mov     ebp, esp
.text$mn:000081DF                 push    ecx
.text$mn:000081E0                 mov     [ebp+var_4], ecx
.text$mn:000081E3                 mov     eax, [ebp+arg_0]
.text$mn:000081E6                 push    eax             ; void *
.text$mn:000081E7                 call    ??3@YAXPAX@Z    ; operator delete(void *)
.text$mn:000081EC                 add     esp, 4
.text$mn:000081EF                 mov     esp, ebp
.text$mn:000081F1                 pop     ebp
.text$mn:000081F2                 retn    8
.text$mn:000081F2 ?deallocate@?$allocator@D@std@@QAEXPADI@Z endp
.text$mn:000081F2
.text$mn:000081F2 ; ---------------------------------------------------------------------------
.text$mn:000081F5                 align 4
.text$mn:000081F5 _text$mn        ends
.text$mn:000081F5
.text$mn:000081F8 ; ===========================================================================
.text$mn:000081F8
.text$mn:000081F8 ; Segment type: Pure code
.text$mn:000081F8 ; Segment permissions: Read/Execute
.text$mn:000081F8 _text$mn        segment para public 'CODE' use32
.text$mn:000081F8                 assume cs:_text$mn
.text$mn:000081F8                 ;org 81F8h
.text$mn:000081F8 ; COMDAT (pick any)
.text$mn:000081F8                 assume es:nothing, ss:nothing, ds:_data, fs:nothing, gs:nothing
.text$mn:000081F8
.text$mn:000081F8 ; =============== S U B R O U T I N E =======================================
.text$mn:000081F8
.text$mn:000081F8 ; Attributes: bp-based frame
.text$mn:000081F8
.text$mn:000081F8 ; int __stdcall std::allocator<wchar_t const *>::deallocate(void *, int)
.text$mn:000081F8                 public ?deallocate@?$allocator@PB_W@std@@QAEXPAPB_WI@Z
.text$mn:000081F8 ?deallocate@?$allocator@PB_W@std@@QAEXPAPB_WI@Z proc near
.text$mn:000081F8                                         ; CODE XREF: std::_Wrap_alloc<std::allocator<wchar_t const *>>::deallocate(wchar_t const * *,uint)+12p
.text$mn:000081F8
.text$mn:000081F8 var_4           = dword ptr -4
.text$mn:000081F8 arg_0           = dword ptr  8
.text$mn:000081F8
.text$mn:000081F8                 push    ebp
.text$mn:000081F9                 mov     ebp, esp
.text$mn:000081FB                 push    ecx
.text$mn:000081FC                 mov     [ebp+var_4], ecx
.text$mn:000081FF                 mov     eax, [ebp+arg_0]
.text$mn:00008202                 push    eax             ; void *
.text$mn:00008203                 call    ??3@YAXPAX@Z    ; operator delete(void *)
.text$mn:00008208                 add     esp, 4
.text$mn:0000820B                 mov     esp, ebp
.text$mn:0000820D                 pop     ebp
.text$mn:0000820E                 retn    8
.text$mn:0000820E ?deallocate@?$allocator@PB_W@std@@QAEXPAPB_WI@Z endp
.text$mn:0000820E
.text$mn:0000820E ; ---------------------------------------------------------------------------
.text$mn:00008211                 align 4
.text$mn:00008211 _text$mn        ends
.text$mn:00008211
.text$mn:00008214 ; ===========================================================================
.text$mn:00008214
.text$mn:00008214 ; Segment type: Pure code
.text$mn:00008214 ; Segment permissions: Read/Execute
.text$mn:00008214 _text$mn        segment para public 'CODE' use32
.text$mn:00008214                 assume cs:_text$mn
.text$mn:00008214                 ;org 8214h
.text$mn:00008214 ; COMDAT (pick any)
.text$mn:00008214                 assume es:nothing, ss:nothing, ds:_data, fs:nothing, gs:nothing
.text$mn:00008214
.text$mn:00008214 ; =============== S U B R O U T I N E =======================================
.text$mn:00008214
.text$mn:00008214 ; Attributes: bp-based frame
.text$mn:00008214
.text$mn:00008214 ; int __stdcall std::allocator<FunctionValues>::deallocate(void *, int)
.text$mn:00008214                 public ?deallocate@?$allocator@UFunctionValues@@@std@@QAEXPAUFunctionValues@@I@Z
.text$mn:00008214 ?deallocate@?$allocator@UFunctionValues@@@std@@QAEXPAUFunctionValues@@I@Z proc near
.text$mn:00008214                                         ; CODE XREF: std::_Wrap_alloc<std::allocator<FunctionValues>>::deallocate(FunctionValues *,uint)+12p
.text$mn:00008214
.text$mn:00008214 var_4           = dword ptr -4
.text$mn:00008214 arg_0           = dword ptr  8
.text$mn:00008214
.text$mn:00008214                 push    ebp
.text$mn:00008215                 mov     ebp, esp
.text$mn:00008217                 push    ecx
.text$mn:00008218                 mov     [ebp+var_4], ecx
.text$mn:0000821B                 mov     eax, [ebp+arg_0]
.text$mn:0000821E                 push    eax             ; void *
.text$mn:0000821F                 call    ??3@YAXPAX@Z    ; operator delete(void *)
.text$mn:00008224                 add     esp, 4
.text$mn:00008227                 mov     esp, ebp
.text$mn:00008229                 pop     ebp
.text$mn:0000822A                 retn    8
.text$mn:0000822A ?deallocate@?$allocator@UFunctionValues@@@std@@QAEXPAUFunctionValues@@I@Z endp
.text$mn:0000822A
.text$mn:0000822A ; ---------------------------------------------------------------------------
.text$mn:0000822D                 align 10h
.text$mn:0000822D _text$mn        ends
.text$mn:0000822D
.text$mn:00008230 ; ===========================================================================
.text$mn:00008230
.text$mn:00008230 ; Segment type: Pure code
.text$mn:00008230 ; Segment permissions: Read/Execute
.text$mn:00008230 _text$mn        segment para public 'CODE' use32
.text$mn:00008230                 assume cs:_text$mn
.text$mn:00008230                 ;org 8230h
.text$mn:00008230 ; COMDAT (pick any)
.text$mn:00008230                 assume es:nothing, ss:nothing, ds:_data, fs:nothing, gs:nothing
.text$mn:00008230
.text$mn:00008230 ; =============== S U B R O U T I N E =======================================
.text$mn:00008230
.text$mn:00008230 ; Attributes: bp-based frame
.text$mn:00008230
.text$mn:00008230 ; int __stdcall std::allocator<Token>::deallocate(void *, int)
.text$mn:00008230                 public ?deallocate@?$allocator@UToken@@@std@@QAEXPAUToken@@I@Z
.text$mn:00008230 ?deallocate@?$allocator@UToken@@@std@@QAEXPAUToken@@I@Z proc near
.text$mn:00008230                                         ; CODE XREF: std::_Wrap_alloc<std::allocator<Token>>::deallocate(Token *,uint)+12p
.text$mn:00008230
.text$mn:00008230 var_4           = dword ptr -4
.text$mn:00008230 arg_0           = dword ptr  8
.text$mn:00008230
.text$mn:00008230                 push    ebp
.text$mn:00008231                 mov     ebp, esp
.text$mn:00008233                 push    ecx
.text$mn:00008234                 mov     [ebp+var_4], ecx
.text$mn:00008237                 mov     eax, [ebp+arg_0]
.text$mn:0000823A                 push    eax             ; void *
.text$mn:0000823B                 call    ??3@YAXPAX@Z    ; operator delete(void *)
.text$mn:00008240                 add     esp, 4
.text$mn:00008243                 mov     esp, ebp
.text$mn:00008245                 pop     ebp
.text$mn:00008246                 retn    8
.text$mn:00008246 ?deallocate@?$allocator@UToken@@@std@@QAEXPAUToken@@I@Z endp
.text$mn:00008246
.text$mn:00008246 ; ---------------------------------------------------------------------------
.text$mn:00008249                 align 4
.text$mn:00008249 _text$mn        ends
.text$mn:00008249
.text$mn:0000824C ; ===========================================================================
.text$mn:0000824C
.text$mn:0000824C ; Segment type: Pure code
.text$mn:0000824C ; Segment permissions: Read/Execute
.text$mn:0000824C _text$mn        segment para public 'CODE' use32
.text$mn:0000824C                 assume cs:_text$mn
.text$mn:0000824C                 ;org 824Ch
.text$mn:0000824C ; COMDAT (pick any)
.text$mn:0000824C                 assume es:nothing, ss:nothing, ds:_data, fs:nothing, gs:nothing
.text$mn:0000824C
.text$mn:0000824C ; =============== S U B R O U T I N E =======================================
.text$mn:0000824C
.text$mn:0000824C ; Attributes: bp-based frame
.text$mn:0000824C
.text$mn:0000824C ; int __stdcall std::allocator<std::_Container_proxy>::deallocate(void *, int)
.text$mn:0000824C                 public ?deallocate@?$allocator@U_Container_proxy@std@@@std@@QAEXPAU_Container_proxy@2@I@Z
.text$mn:0000824C ?deallocate@?$allocator@U_Container_proxy@std@@@std@@QAEXPAU_Container_proxy@2@I@Z proc near
.text$mn:0000824C                                         ; CODE XREF: std::_String_alloc<0,std::_String_base_types<char,std::allocator<char>>>::_Free_proxy(void)+32p
.text$mn:0000824C                                         ; std::_Wrap_alloc<std::allocator<std::_Container_proxy>>::deallocate(std::_Container_proxy *,uint)+12p
.text$mn:0000824C
.text$mn:0000824C var_4           = dword ptr -4
.text$mn:0000824C arg_0           = dword ptr  8
.text$mn:0000824C
.text$mn:0000824C                 push    ebp
.text$mn:0000824D                 mov     ebp, esp
.text$mn:0000824F                 push    ecx
.text$mn:00008250                 mov     [ebp+var_4], ecx
.text$mn:00008253                 mov     eax, [ebp+arg_0]
.text$mn:00008256                 push    eax             ; void *
.text$mn:00008257                 call    ??3@YAXPAX@Z    ; operator delete(void *)
.text$mn:0000825C                 add     esp, 4
.text$mn:0000825F                 mov     esp, ebp
.text$mn:00008261                 pop     ebp
.text$mn:00008262                 retn    8
.text$mn:00008262 ?deallocate@?$allocator@U_Container_proxy@std@@@std@@QAEXPAU_Container_proxy@2@I@Z endp
.text$mn:00008262
.text$mn:00008262 ; ---------------------------------------------------------------------------
.text$mn:00008265                 align 4
.text$mn:00008265 _text$mn        ends
.text$mn:00008265
.text$mn:00008268 ; ===========================================================================
.text$mn:00008268
.text$mn:00008268 ; Segment type: Pure code
.text$mn:00008268 ; Segment permissions: Read/Execute
.text$mn:00008268 _text$mn        segment para public 'CODE' use32
.text$mn:00008268                 assume cs:_text$mn
.text$mn:00008268                 ;org 8268h
.text$mn:00008268 ; COMDAT (pick any)
.text$mn:00008268                 assume es:nothing, ss:nothing, ds:_data, fs:nothing, gs:nothing
.text$mn:00008268
.text$mn:00008268 ; =============== S U B R O U T I N E =======================================
.text$mn:00008268
.text$mn:00008268 ; Attributes: bp-based frame
.text$mn:00008268
.text$mn:00008268 ; int __stdcall std::allocator<std::vector<wchar_t const *,std::allocator<wchar_t const *>>>::deallocate(void *, int)
.text$mn:00008268                 public ?deallocate@?$allocator@V?$vector@PB_WV?$allocator@PB_W@std@@@std@@@std@@QAEXPAV?$vector@PB_WV?$allocator@PB_W@std@@@2@I@Z
.text$mn:00008268 ?deallocate@?$allocator@V?$vector@PB_WV?$allocator@PB_W@std@@@std@@@std@@QAEXPAV?$vector@PB_WV?$allocator@PB_W@std@@@2@I@Z proc near
.text$mn:00008268                                         ; CODE XREF: std::_Wrap_alloc<std::allocator<std::vector<wchar_t const *,std::allocator<wchar_t const *>>>>::deallocate(std::vector<wchar_t const *,std::allocator<wchar_t const *>> *,uint)+12p
.text$mn:00008268
.text$mn:00008268 var_4           = dword ptr -4
.text$mn:00008268 arg_0           = dword ptr  8
.text$mn:00008268
.text$mn:00008268                 push    ebp
.text$mn:00008269                 mov     ebp, esp
.text$mn:0000826B                 push    ecx
.text$mn:0000826C                 mov     [ebp+var_4], ecx
.text$mn:0000826F                 mov     eax, [ebp+arg_0]
.text$mn:00008272                 push    eax             ; void *
.text$mn:00008273                 call    ??3@YAXPAX@Z    ; operator delete(void *)
.text$mn:00008278                 add     esp, 4
.text$mn:0000827B                 mov     esp, ebp
.text$mn:0000827D                 pop     ebp
.text$mn:0000827E                 retn    8
.text$mn:0000827E ?deallocate@?$allocator@V?$vector@PB_WV?$allocator@PB_W@std@@@std@@@std@@QAEXPAV?$vector@PB_WV?$allocator@PB_W@std@@@2@I@Z endp
.text$mn:0000827E
.text$mn:0000827E ; ---------------------------------------------------------------------------
.text$mn:00008281                 align 4
.text$mn:00008281 _text$mn        ends
.text$mn:00008281
.text$mn:00008284 ; ===========================================================================
.text$mn:00008284
.text$mn:00008284 ; Segment type: Pure code
.text$mn:00008284 ; Segment permissions: Read/Execute
.text$mn:00008284 _text$mn        segment para public 'CODE' use32
.text$mn:00008284                 assume cs:_text$mn
.text$mn:00008284                 ;org 8284h
.text$mn:00008284 ; COMDAT (pick any)
.text$mn:00008284                 assume es:nothing, ss:nothing, ds:_data, fs:nothing, gs:nothing
.text$mn:00008284
.text$mn:00008284 ; =============== S U B R O U T I N E =======================================
.text$mn:00008284
.text$mn:00008284 ; Attributes: bp-based frame
.text$mn:00008284
.text$mn:00008284 ; public: virtual class std::error_condition __thiscall std::_System_error_category::default_error_condition(int)const
.text$mn:00008284                 public ?default_error_condition@_System_error_category@std@@UBE?AVerror_condition@2@H@Z
.text$mn:00008284 ?default_error_condition@_System_error_category@std@@UBE?AVerror_condition@2@H@Z proc near
.text$mn:00008284                                         ; DATA XREF: .rdata:0000A478o
.text$mn:00008284
.text$mn:00008284 var_4           = dword ptr -4
.text$mn:00008284 arg_0           = dword ptr  8
.text$mn:00008284 arg_4           = dword ptr  0Ch
.text$mn:00008284
.text$mn:00008284                 push    ebp
.text$mn:00008285                 mov     ebp, esp
.text$mn:00008287                 push    ecx
.text$mn:00008288                 mov     [ebp+var_4], ecx
.text$mn:0000828B                 mov     eax, [ebp+arg_4]
.text$mn:0000828E                 push    eax             ; int
.text$mn:0000828F                 call    ?_Syserror_map@std@@YAPBDH@Z ; std::_Syserror_map(int)
.text$mn:00008294                 add     esp, 4
.text$mn:00008297                 test    eax, eax
.text$mn:00008299                 jz      short loc_82B4
.text$mn:0000829B                 call    ?generic_category@std@@YAABVerror_category@1@XZ ; std::generic_category(void)
.text$mn:000082A0                 push    eax             ; struct std::error_category *
.text$mn:000082A1                 mov     ecx, [ebp+arg_4]
.text$mn:000082A4                 push    ecx             ; int
.text$mn:000082A5                 mov     ecx, [ebp+arg_0] ; this
.text$mn:000082A8                 call    ??0error_condition@std@@QAE@HABVerror_category@1@@Z ; std::error_condition::error_condition(int,std::error_category const &)
.text$mn:000082AD                 mov     eax, [ebp+arg_0]
.text$mn:000082B0                 jmp     short loc_82C9
.text$mn:000082B2 ; ---------------------------------------------------------------------------
.text$mn:000082B2                 jmp     short loc_82C9
.text$mn:000082B4 ; ---------------------------------------------------------------------------
.text$mn:000082B4
.text$mn:000082B4 loc_82B4:                               ; CODE XREF: std::_System_error_category::default_error_condition(int)+15j
.text$mn:000082B4                 call    ?system_category@std@@YAABVerror_category@1@XZ ; std::system_category(void)
.text$mn:000082B9                 push    eax             ; struct std::error_category *
.text$mn:000082BA                 mov     edx, [ebp+arg_4]
.text$mn:000082BD                 push    edx             ; int
.text$mn:000082BE                 mov     ecx, [ebp+arg_0] ; this
.text$mn:000082C1                 call    ??0error_condition@std@@QAE@HABVerror_category@1@@Z ; std::error_condition::error_condition(int,std::error_category const &)
.text$mn:000082C6                 mov     eax, [ebp+arg_0]
.text$mn:000082C9
.text$mn:000082C9 loc_82C9:                               ; CODE XREF: std::_System_error_category::default_error_condition(int)+2Cj
.text$mn:000082C9                                         ; std::_System_error_category::default_error_condition(int)+2Ej
.text$mn:000082C9                 mov     esp, ebp
.text$mn:000082CB                 pop     ebp
.text$mn:000082CC                 retn    8
.text$mn:000082CC ?default_error_condition@_System_error_category@std@@UBE?AVerror_condition@2@H@Z endp
.text$mn:000082CC
.text$mn:000082CC ; ---------------------------------------------------------------------------
.text$mn:000082CF                 align 10h
.text$mn:000082CF _text$mn        ends
.text$mn:000082CF
.text$mn:000082D0 ; ===========================================================================
.text$mn:000082D0
.text$mn:000082D0 ; Segment type: Pure code
.text$mn:000082D0 ; Segment permissions: Read/Execute
.text$mn:000082D0 _text$mn        segment para public 'CODE' use32
.text$mn:000082D0                 assume cs:_text$mn
.text$mn:000082D0                 ;org 82D0h
.text$mn:000082D0 ; COMDAT (pick any)
.text$mn:000082D0                 assume es:nothing, ss:nothing, ds:_data, fs:nothing, gs:nothing
.text$mn:000082D0
.text$mn:000082D0 ; =============== S U B R O U T I N E =======================================
.text$mn:000082D0
.text$mn:000082D0 ; Attributes: bp-based frame
.text$mn:000082D0
.text$mn:000082D0 ; public: virtual class std::error_condition __thiscall std::error_category::default_error_condition(int)const
.text$mn:000082D0                 public ?default_error_condition@error_category@std@@UBE?AVerror_condition@2@H@Z
.text$mn:000082D0 ?default_error_condition@error_category@std@@UBE?AVerror_condition@2@H@Z proc near
.text$mn:000082D0                                         ; DATA XREF: .rdata:0000A3E8o
.text$mn:000082D0                                         ; .rdata:0000A404o ...
.text$mn:000082D0
.text$mn:000082D0 var_4           = dword ptr -4
.text$mn:000082D0 arg_0           = dword ptr  8
.text$mn:000082D0 arg_4           = dword ptr  0Ch
.text$mn:000082D0
.text$mn:000082D0                 push    ebp
.text$mn:000082D1                 mov     ebp, esp
.text$mn:000082D3                 push    ecx
.text$mn:000082D4                 mov     [ebp+var_4], ecx
.text$mn:000082D7                 mov     eax, [ebp+var_4]
.text$mn:000082DA                 push    eax             ; struct std::error_category *
.text$mn:000082DB                 mov     ecx, [ebp+arg_4]
.text$mn:000082DE                 push    ecx             ; int
.text$mn:000082DF                 mov     ecx, [ebp+arg_0] ; this
.text$mn:000082E2                 call    ??0error_condition@std@@QAE@HABVerror_category@1@@Z ; std::error_condition::error_condition(int,std::error_category const &)
.text$mn:000082E7                 mov     eax, [ebp+arg_0]
.text$mn:000082EA                 mov     esp, ebp
.text$mn:000082EC                 pop     ebp
.text$mn:000082ED                 retn    8
.text$mn:000082ED ?default_error_condition@error_category@std@@UBE?AVerror_condition@2@H@Z endp
.text$mn:000082ED
.text$mn:000082ED _text$mn        ends
.text$mn:000082ED
.text$mn:000082F0 ; ===========================================================================
.text$mn:000082F0
.text$mn:000082F0 ; Segment type: Pure code
.text$mn:000082F0 ; Segment permissions: Read/Execute
.text$mn:000082F0 _text$mn        segment para public 'CODE' use32
.text$mn:000082F0                 assume cs:_text$mn
.text$mn:000082F0                 ;org 82F0h
.text$mn:000082F0 ; COMDAT (pick any)
.text$mn:000082F0                 assume es:nothing, ss:nothing, ds:_data, fs:nothing, gs:nothing
.text$mn:000082F0
.text$mn:000082F0 ; =============== S U B R O U T I N E =======================================
.text$mn:000082F0
.text$mn:000082F0 ; Attributes: bp-based frame
.text$mn:000082F0
.text$mn:000082F0 ; public: bool __thiscall std::vector<struct FunctionValues, class std::allocator<struct FunctionValues>>::empty(void)const
.text$mn:000082F0                 public ?empty@?$vector@UFunctionValues@@V?$allocator@UFunctionValues@@@std@@@std@@QBE_NXZ
.text$mn:000082F0 ?empty@?$vector@UFunctionValues@@V?$allocator@UFunctionValues@@@std@@@std@@QBE_NXZ proc near
.text$mn:000082F0                                         ; CODE XREF: std::vector<FunctionValues,std::allocator<FunctionValues>>::pop_back(void)+Cp
.text$mn:000082F0
.text$mn:000082F0 var_8           = dword ptr -8
.text$mn:000082F0 var_4           = dword ptr -4
.text$mn:000082F0
.text$mn:000082F0                 push    ebp
.text$mn:000082F1                 mov     ebp, esp
.text$mn:000082F3                 sub     esp, 8
.text$mn:000082F6                 mov     [ebp+var_4], ecx
.text$mn:000082F9                 mov     eax, [ebp+var_4]
.text$mn:000082FC                 mov     ecx, [ebp+var_4]
.text$mn:000082FF                 mov     edx, [eax+4]
.text$mn:00008302                 cmp     edx, [ecx+8]
.text$mn:00008305                 jnz     short loc_8310
.text$mn:00008307                 mov     [ebp+var_8], 1
.text$mn:0000830E                 jmp     short loc_8317
.text$mn:00008310 ; ---------------------------------------------------------------------------
.text$mn:00008310
.text$mn:00008310 loc_8310:                               ; CODE XREF: std::vector<FunctionValues,std::allocator<FunctionValues>>::empty(void)+15j
.text$mn:00008310                 mov     [ebp+var_8], 0
.text$mn:00008317
.text$mn:00008317 loc_8317:                               ; CODE XREF: std::vector<FunctionValues,std::allocator<FunctionValues>>::empty(void)+1Ej
.text$mn:00008317                 mov     al, byte ptr [ebp+var_8]
.text$mn:0000831A                 mov     esp, ebp
.text$mn:0000831C                 pop     ebp
.text$mn:0000831D                 retn
.text$mn:0000831D ?empty@?$vector@UFunctionValues@@V?$allocator@UFunctionValues@@@std@@@std@@QBE_NXZ endp
.text$mn:0000831D
.text$mn:0000831D ; ---------------------------------------------------------------------------
.text$mn:0000831E                 align 10h
.text$mn:0000831E _text$mn        ends
.text$mn:0000831E
.text$mn:00008320 ; ===========================================================================
.text$mn:00008320
.text$mn:00008320 ; Segment type: Pure code
.text$mn:00008320 ; Segment permissions: Read/Execute
.text$mn:00008320 _text$mn        segment para public 'CODE' use32
.text$mn:00008320                 assume cs:_text$mn
.text$mn:00008320                 ;org 8320h
.text$mn:00008320 ; COMDAT (pick any)
.text$mn:00008320                 assume es:nothing, ss:nothing, ds:_data, fs:nothing, gs:nothing
.text$mn:00008320
.text$mn:00008320 ; =============== S U B R O U T I N E =======================================
.text$mn:00008320
.text$mn:00008320 ; Attributes: bp-based frame
.text$mn:00008320
.text$mn:00008320 ; public: class std::_Vector_const_iterator<class std::_Vector_val<struct std::_Simple_types<wchar_t const *>>> __thiscall std::vector<wchar_t const *, class std::allocator<wchar_t const *>>::end(void)const
.text$mn:00008320                 public ?end@?$vector@PB_WV?$allocator@PB_W@std@@@std@@QBE?AV?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@PB_W@std@@@std@@@2@XZ
.text$mn:00008320 ?end@?$vector@PB_WV?$allocator@PB_W@std@@@std@@QBE?AV?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@PB_W@std@@@std@@@2@XZ proc near
.text$mn:00008320                                         ; CODE XREF: std::vector<wchar_t const *,std::allocator<wchar_t const *>>::vector<wchar_t const *,std::allocator<wchar_t const *>>(std::vector<wchar_t const *,std::allocator<wchar_t const *>> const &)+89p
.text$mn:00008320
.text$mn:00008320 var_14          = dword ptr -14h
.text$mn:00008320 var_10          = dword ptr -10h
.text$mn:00008320 var_C           = dword ptr -0Ch
.text$mn:00008320 var_4           = dword ptr -4
.text$mn:00008320 arg_0           = dword ptr  8
.text$mn:00008320
.text$mn:00008320                 push    ebp
.text$mn:00008321                 mov     ebp, esp
.text$mn:00008323                 push    0FFFFFFFFh
.text$mn:00008325                 push    offset __ehhandler$?end@?$vector@PB_WV?$allocator@PB_W@std@@@std@@QBE?AV?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@PB_W@std@@@std@@@2@XZ
.text$mn:0000832A                 mov     eax, large fs:0
.text$mn:00008330                 push    eax
.text$mn:00008331                 sub     esp, 8
.text$mn:00008334                 mov     eax, dword ptr ds:___security_cookie
.text$mn:00008339                 xor     eax, ebp
.text$mn:0000833B                 push    eax
.text$mn:0000833C                 lea     eax, [ebp+var_C]
.text$mn:0000833F                 mov     large fs:0, eax
.text$mn:00008345                 mov     [ebp+var_10], ecx
.text$mn:00008348                 mov     [ebp+var_14], 0
.text$mn:0000834F                 mov     eax, [ebp+var_10]
.text$mn:00008352                 push    eax             ; struct std::_Container_base12 *
.text$mn:00008353                 mov     ecx, [ebp+var_10]
.text$mn:00008356                 mov     edx, [ecx+8]
.text$mn:00008359                 push    edx             ; int
.text$mn:0000835A                 mov     ecx, [ebp+arg_0]
.text$mn:0000835D                 call    ??0?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@PB_W@std@@@std@@@std@@QAE@PAPB_WPBU_Container_base12@1@@Z ; std::_Vector_const_iterator<std::_Vector_val<std::_Simple_types<wchar_t const *>>>::_Vector_const_iterator<std::_Vector_val<std::_Simple_types<wchar_t const *>>>(wchar_t const * *,std::_Container_base12 const *)
.text$mn:00008362                 mov     [ebp+var_4], 0
.text$mn:00008369                 mov     eax, [ebp+var_14]
.text$mn:0000836C                 or      eax, 1
.text$mn:0000836F                 mov     [ebp+var_14], eax
.text$mn:00008372                 mov     eax, [ebp+arg_0]
.text$mn:00008375                 mov     ecx, [ebp+var_C]
.text$mn:00008378                 mov     large fs:0, ecx
.text$mn:0000837F                 pop     ecx
.text$mn:00008380                 mov     esp, ebp
.text$mn:00008382                 pop     ebp
.text$mn:00008383                 retn    4
.text$mn:00008383 ?end@?$vector@PB_WV?$allocator@PB_W@std@@@std@@QBE?AV?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@PB_W@std@@@std@@@2@XZ endp
.text$mn:00008383
.text$mn:00008383 ; ---------------------------------------------------------------------------
.text$mn:00008386                 align 4
.text$mn:00008386 _text$mn        ends
.text$mn:00008386
.text$x:00008388 ; ===========================================================================
.text$x:00008388
.text$x:00008388 ; Segment type: Pure code
.text$x:00008388 ; Segment permissions: Read/Execute
.text$x:00008388 _text$x         segment para public 'CODE' use32
.text$x:00008388                 assume cs:_text$x
.text$x:00008388                 ;org 8388h
.text$x:00008388 ; COMDAT (pick associative to section at 8320)
.text$x:00008388                 assume es:nothing, ss:nothing, ds:_data, fs:nothing, gs:nothing
.text$x:00008388
.text$x:00008388 ; =============== S U B R O U T I N E =======================================
.text$x:00008388
.text$x:00008388
.text$x:00008388 __unwindfunclet$?end@?$vector@PB_WV?$allocator@PB_W@std@@@std@@QBE?AV?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@PB_W@std@@@std@@@2@XZ$0 proc near
.text$x:00008388                                         ; DATA XREF: .xdata$x:000097F8o
.text$x:00008388                 mov     eax, [ebp-14h]
.text$x:0000838B                 and     eax, 1
.text$x:0000838E                 jz      $LN4_0
.text$x:00008394                 and     dword ptr [ebp-14h], 0FFFFFFFEh
.text$x:00008398                 mov     ecx, [ebp+8]
.text$x:0000839B                 jmp     ??1?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@PB_W@std@@@std@@@std@@QAE@XZ ; std::_Vector_const_iterator<std::_Vector_val<std::_Simple_types<wchar_t const *>>>::~_Vector_const_iterator<std::_Vector_val<std::_Simple_types<wchar_t const *>>>(void)
.text$x:000083A0 ; ---------------------------------------------------------------------------
.text$x:000083A0
.text$x:000083A0 $LN4_0:                                 ; CODE XREF: __unwindfunclet$?end@?$vector@PB_WV?$allocator@PB_W@std@@@std@@QBE?AV?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@PB_W@std@@@std@@@2@XZ$0+6j
.text$x:000083A0                 retn
.text$x:000083A0 __unwindfunclet$?end@?$vector@PB_WV?$allocator@PB_W@std@@@std@@QBE?AV?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@PB_W@std@@@std@@@2@XZ$0 endp
.text$x:000083A0
.text$x:000083A1
.text$x:000083A1 ; =============== S U B R O U T I N E =======================================
.text$x:000083A1
.text$x:000083A1
.text$x:000083A1 __ehhandler$?end@?$vector@PB_WV?$allocator@PB_W@std@@@std@@QBE?AV?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@PB_W@std@@@std@@@2@XZ proc near
.text$x:000083A1                                         ; DATA XREF: std::vector<wchar_t const *,std::allocator<wchar_t const *>>::end(void)+5o
.text$x:000083A1
.text$x:000083A1 arg_4           = dword ptr  8
.text$x:000083A1
.text$x:000083A1                 mov     edx, [esp+arg_4]
.text$x:000083A5                 lea     eax, [edx+0Ch]
.text$x:000083A8                 mov     ecx, [edx-0Ch]
.text$x:000083AB                 xor     ecx, eax
.text$x:000083AD                 call    @__security_check_cookie@4 ; __security_check_cookie(x)
.text$x:000083B2                 mov     eax, offset __ehfuncinfo$?end@?$vector@PB_WV?$allocator@PB_W@std@@@std@@QBE?AV?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@PB_W@std@@@std@@@2@XZ
.text$x:000083B7                 jmp     ___CxxFrameHandler3
.text$x:000083B7 __ehhandler$?end@?$vector@PB_WV?$allocator@PB_W@std@@@std@@QBE?AV?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@PB_W@std@@@std@@@2@XZ endp
.text$x:000083B7
.text$x:000083B7 _text$x         ends
.text$x:000083B7
.text$mn:000083BC ; ===========================================================================
.text$mn:000083BC
.text$mn:000083BC ; Segment type: Pure code
.text$mn:000083BC ; Segment permissions: Read/Execute
.text$mn:000083BC _text$mn        segment para public 'CODE' use32
.text$mn:000083BC                 assume cs:_text$mn
.text$mn:000083BC                 ;org 83BCh
.text$mn:000083BC ; COMDAT (pick any)
.text$mn:000083BC                 assume es:nothing, ss:nothing, ds:_data, fs:nothing, gs:nothing
.text$mn:000083BC
.text$mn:000083BC ; =============== S U B R O U T I N E =======================================
.text$mn:000083BC
.text$mn:000083BC ; Attributes: bp-based frame
.text$mn:000083BC
.text$mn:000083BC ; public: class std::_Vector_iterator<class std::_Vector_val<struct std::_Simple_types<struct FunctionValues>>> __thiscall std::vector<struct FunctionValues, class std::allocator<struct FunctionValues>>::end(void)
.text$mn:000083BC                 public ?end@?$vector@UFunctionValues@@V?$allocator@UFunctionValues@@@std@@@std@@QAE?AV?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@UFunctionValues@@@std@@@std@@@2@XZ
.text$mn:000083BC ?end@?$vector@UFunctionValues@@V?$allocator@UFunctionValues@@@std@@@std@@QAE?AV?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@UFunctionValues@@@std@@@std@@@2@XZ proc near
.text$mn:000083BC                                         ; CODE XREF: std::vector<FunctionValues,std::allocator<FunctionValues>>::back(void)+35p
.text$mn:000083BC
.text$mn:000083BC var_14          = dword ptr -14h
.text$mn:000083BC var_10          = dword ptr -10h
.text$mn:000083BC var_C           = dword ptr -0Ch
.text$mn:000083BC var_4           = dword ptr -4
.text$mn:000083BC arg_0           = dword ptr  8
.text$mn:000083BC
.text$mn:000083BC                 push    ebp
.text$mn:000083BD                 mov     ebp, esp
.text$mn:000083BF                 push    0FFFFFFFFh
.text$mn:000083C1                 push    offset __ehhandler$?end@?$vector@UFunctionValues@@V?$allocator@UFunctionValues@@@std@@@std@@QAE?AV?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@UFunctionValues@@@std@@@std@@@2@XZ
.text$mn:000083C6                 mov     eax, large fs:0
.text$mn:000083CC                 push    eax
.text$mn:000083CD                 sub     esp, 8
.text$mn:000083D0                 mov     eax, dword ptr ds:___security_cookie
.text$mn:000083D5                 xor     eax, ebp
.text$mn:000083D7                 push    eax
.text$mn:000083D8                 lea     eax, [ebp+var_C]
.text$mn:000083DB                 mov     large fs:0, eax
.text$mn:000083E1                 mov     [ebp+var_10], ecx
.text$mn:000083E4                 mov     [ebp+var_14], 0
.text$mn:000083EB                 mov     eax, [ebp+var_10]
.text$mn:000083EE                 push    eax             ; struct std::_Container_base12 *
.text$mn:000083EF                 mov     ecx, [ebp+var_10]
.text$mn:000083F2                 mov     edx, [ecx+8]
.text$mn:000083F5                 push    edx             ; int
.text$mn:000083F6                 mov     ecx, [ebp+arg_0]
.text$mn:000083F9                 call    ??0?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@UFunctionValues@@@std@@@std@@@std@@QAE@PAUFunctionValues@@PBU_Container_base12@1@@Z ; std::_Vector_iterator<std::_Vector_val<std::_Simple_types<FunctionValues>>>::_Vector_iterator<std::_Vector_val<std::_Simple_types<FunctionValues>>>(FunctionValues *,std::_Container_base12 const *)
.text$mn:000083FE                 mov     [ebp+var_4], 0
.text$mn:00008405                 mov     eax, [ebp+var_14]
.text$mn:00008408                 or      eax, 1
.text$mn:0000840B                 mov     [ebp+var_14], eax
.text$mn:0000840E                 mov     eax, [ebp+arg_0]
.text$mn:00008411                 mov     ecx, [ebp+var_C]
.text$mn:00008414                 mov     large fs:0, ecx
.text$mn:0000841B                 pop     ecx
.text$mn:0000841C                 mov     esp, ebp
.text$mn:0000841E                 pop     ebp
.text$mn:0000841F                 retn    4
.text$mn:0000841F ?end@?$vector@UFunctionValues@@V?$allocator@UFunctionValues@@@std@@@std@@QAE?AV?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@UFunctionValues@@@std@@@std@@@2@XZ endp
.text$mn:0000841F
.text$mn:0000841F ; ---------------------------------------------------------------------------
.text$mn:00008422                 align 4
.text$mn:00008422 _text$mn        ends
.text$mn:00008422
.text$x:00008424 ; ===========================================================================
.text$x:00008424
.text$x:00008424 ; Segment type: Pure code
.text$x:00008424 ; Segment permissions: Read/Execute
.text$x:00008424 _text$x         segment para public 'CODE' use32
.text$x:00008424                 assume cs:_text$x
.text$x:00008424                 ;org 8424h
.text$x:00008424 ; COMDAT (pick associative to section at 83BC)
.text$x:00008424                 assume es:nothing, ss:nothing, ds:_data, fs:nothing, gs:nothing
.text$x:00008424
.text$x:00008424 ; =============== S U B R O U T I N E =======================================
.text$x:00008424
.text$x:00008424
.text$x:00008424 __unwindfunclet$?end@?$vector@UFunctionValues@@V?$allocator@UFunctionValues@@@std@@@std@@QAE?AV?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@UFunctionValues@@@std@@@std@@@2@XZ$0 proc near
.text$x:00008424                                         ; DATA XREF: .xdata$x:00009C4Co
.text$x:00008424                 mov     eax, [ebp-14h]
.text$x:00008427                 and     eax, 1
.text$x:0000842A                 jz      $LN4_1
.text$x:00008430                 and     dword ptr [ebp-14h], 0FFFFFFFEh
.text$x:00008434                 mov     ecx, [ebp+8]
.text$x:00008437                 jmp     ??1?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@UFunctionValues@@@std@@@std@@@std@@QAE@XZ ; std::_Vector_iterator<std::_Vector_val<std::_Simple_types<FunctionValues>>>::~_Vector_iterator<std::_Vector_val<std::_Simple_types<FunctionValues>>>(void)
.text$x:0000843C ; ---------------------------------------------------------------------------
.text$x:0000843C
.text$x:0000843C $LN4_1:                                 ; CODE XREF: __unwindfunclet$?end@?$vector@UFunctionValues@@V?$allocator@UFunctionValues@@@std@@@std@@QAE?AV?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@UFunctionValues@@@std@@@std@@@2@XZ$0+6j
.text$x:0000843C                 retn
.text$x:0000843C __unwindfunclet$?end@?$vector@UFunctionValues@@V?$allocator@UFunctionValues@@@std@@@std@@QAE?AV?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@UFunctionValues@@@std@@@std@@@2@XZ$0 endp
.text$x:0000843C
.text$x:0000843D
.text$x:0000843D ; =============== S U B R O U T I N E =======================================
.text$x:0000843D
.text$x:0000843D
.text$x:0000843D __ehhandler$?end@?$vector@UFunctionValues@@V?$allocator@UFunctionValues@@@std@@@std@@QAE?AV?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@UFunctionValues@@@std@@@std@@@2@XZ proc near
.text$x:0000843D                                         ; DATA XREF: std::vector<FunctionValues,std::allocator<FunctionValues>>::end(void)+5o
.text$x:0000843D
.text$x:0000843D arg_4           = dword ptr  8
.text$x:0000843D
.text$x:0000843D                 mov     edx, [esp+arg_4]
.text$x:00008441                 lea     eax, [edx+0Ch]
.text$x:00008444                 mov     ecx, [edx-0Ch]
.text$x:00008447                 xor     ecx, eax
.text$x:00008449                 call    @__security_check_cookie@4 ; __security_check_cookie(x)
.text$x:0000844E                 mov     eax, offset __ehfuncinfo$?end@?$vector@UFunctionValues@@V?$allocator@UFunctionValues@@@std@@@std@@QAE?AV?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@UFunctionValues@@@std@@@std@@@2@XZ
.text$x:00008453                 jmp     ___CxxFrameHandler3
.text$x:00008453 __ehhandler$?end@?$vector@UFunctionValues@@V?$allocator@UFunctionValues@@@std@@@std@@QAE?AV?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@UFunctionValues@@@std@@@std@@@2@XZ endp
.text$x:00008453
.text$x:00008453 _text$x         ends
.text$x:00008453
.text$mn:00008458 ; ===========================================================================
.text$mn:00008458
.text$mn:00008458 ; Segment type: Pure code
.text$mn:00008458 ; Segment permissions: Read/Execute
.text$mn:00008458 _text$mn        segment para public 'CODE' use32
.text$mn:00008458                 assume cs:_text$mn
.text$mn:00008458                 ;org 8458h
.text$mn:00008458 ; COMDAT (pick any)
.text$mn:00008458                 assume es:nothing, ss:nothing, ds:_data, fs:nothing, gs:nothing
.text$mn:00008458
.text$mn:00008458 ; =============== S U B R O U T I N E =======================================
.text$mn:00008458
.text$mn:00008458 ; Attributes: bp-based frame
.text$mn:00008458
.text$mn:00008458 ; bool __thiscall std::error_category::equivalent(std::error_category *this, const struct std::error_code *, int)
.text$mn:00008458                 public ?equivalent@error_category@std@@UBE_NABVerror_code@2@H@Z
.text$mn:00008458 ?equivalent@error_category@std@@UBE_NABVerror_code@2@H@Z proc near
.text$mn:00008458                                         ; DATA XREF: .rdata:0000A3ECo
.text$mn:00008458                                         ; .rdata:0000A408o ...
.text$mn:00008458
.text$mn:00008458 var_8           = dword ptr -8
.text$mn:00008458 var_4           = dword ptr -4
.text$mn:00008458 arg_0           = dword ptr  8
.text$mn:00008458 arg_4           = dword ptr  0Ch
.text$mn:00008458
.text$mn:00008458                 push    ebp
.text$mn:00008459                 mov     ebp, esp
.text$mn:0000845B                 sub     esp, 8
.text$mn:0000845E                 mov     [ebp+var_8], ecx
.text$mn:00008461                 mov     ecx, [ebp+arg_0] ; this
.text$mn:00008464                 call    ?category@error_code@std@@QBEABVerror_category@2@XZ ; std::error_code::category(void)
.text$mn:00008469                 push    eax
.text$mn:0000846A                 mov     ecx, [ebp+var_8]
.text$mn:0000846D                 call    ??8error_category@std@@QBE_NABV01@@Z ; std::error_category::operator==(std::error_category const &)
.text$mn:00008472                 movzx   eax, al
.text$mn:00008475                 test    eax, eax
.text$mn:00008477                 jz      short loc_848F
.text$mn:00008479                 mov     ecx, [ebp+arg_0] ; this
.text$mn:0000847C                 call    ?value@error_code@std@@QBEHXZ ; std::error_code::value(void)
.text$mn:00008481                 cmp     eax, [ebp+arg_4]
.text$mn:00008484                 jnz     short loc_848F
.text$mn:00008486                 mov     [ebp+var_4], 1
.text$mn:0000848D                 jmp     short loc_8496
.text$mn:0000848F ; ---------------------------------------------------------------------------
.text$mn:0000848F
.text$mn:0000848F loc_848F:                               ; CODE XREF: std::error_category::equivalent(std::error_code const &,int)+1Fj
.text$mn:0000848F                                         ; std::error_category::equivalent(std::error_code const &,int)+2Cj
.text$mn:0000848F                 mov     [ebp+var_4], 0
.text$mn:00008496
.text$mn:00008496 loc_8496:                               ; CODE XREF: std::error_category::equivalent(std::error_code const &,int)+35j
.text$mn:00008496                 mov     al, byte ptr [ebp+var_4]
.text$mn:00008499                 mov     esp, ebp
.text$mn:0000849B                 pop     ebp
.text$mn:0000849C                 retn    8
.text$mn:0000849C ?equivalent@error_category@std@@UBE_NABVerror_code@2@H@Z endp
.text$mn:0000849C
.text$mn:0000849C ; ---------------------------------------------------------------------------
.text$mn:0000849F                 align 10h
.text$mn:0000849F _text$mn        ends
.text$mn:0000849F
.text$mn:000084A0 ; ===========================================================================
.text$mn:000084A0
.text$mn:000084A0 ; Segment type: Pure code
.text$mn:000084A0 ; Segment permissions: Read/Execute
.text$mn:000084A0 _text$mn        segment para public 'CODE' use32
.text$mn:000084A0                 assume cs:_text$mn
.text$mn:000084A0                 ;org 84A0h
.text$mn:000084A0 ; COMDAT (pick any)
.text$mn:000084A0                 assume es:nothing, ss:nothing, ds:_data, fs:nothing, gs:nothing
.text$mn:000084A0
.text$mn:000084A0 ; =============== S U B R O U T I N E =======================================
.text$mn:000084A0
.text$mn:000084A0 ; Attributes: bp-based frame
.text$mn:000084A0
.text$mn:000084A0 ; bool __thiscall std::error_category::equivalent(std::error_category *this, int, const struct std::error_condition *)
.text$mn:000084A0                 public ?equivalent@error_category@std@@UBE_NHABVerror_condition@2@@Z
.text$mn:000084A0 ?equivalent@error_category@std@@UBE_NHABVerror_condition@2@@Z proc near
.text$mn:000084A0                                         ; DATA XREF: .rdata:0000A3F0o
.text$mn:000084A0                                         ; .rdata:0000A40Co ...
.text$mn:000084A0
.text$mn:000084A0 var_C           = byte ptr -0Ch
.text$mn:000084A0 var_4           = dword ptr -4
.text$mn:000084A0 arg_0           = dword ptr  8
.text$mn:000084A0 arg_4           = dword ptr  0Ch
.text$mn:000084A0
.text$mn:000084A0                 push    ebp
.text$mn:000084A1                 mov     ebp, esp
.text$mn:000084A3                 sub     esp, 0Ch
.text$mn:000084A6                 mov     [ebp+var_4], ecx
.text$mn:000084A9                 mov     eax, [ebp+arg_4]
.text$mn:000084AC                 push    eax             ; std::error_condition *
.text$mn:000084AD                 mov     ecx, [ebp+arg_0]
.text$mn:000084B0                 push    ecx
.text$mn:000084B1                 lea     edx, [ebp+var_C]
.text$mn:000084B4                 push    edx
.text$mn:000084B5                 mov     eax, [ebp+var_4]
.text$mn:000084B8                 mov     edx, [eax]
.text$mn:000084BA                 mov     ecx, [ebp+var_4]
.text$mn:000084BD                 mov     eax, [edx+0Ch]
.text$mn:000084C0                 call    eax
.text$mn:000084C2                 mov     ecx, eax
.text$mn:000084C4                 call    ??8error_condition@std@@QBE_NABV01@@Z ; std::error_condition::operator==(std::error_condition const &)
.text$mn:000084C9                 mov     esp, ebp
.text$mn:000084CB                 pop     ebp
.text$mn:000084CC                 retn    8
.text$mn:000084CC ?equivalent@error_category@std@@UBE_NHABVerror_condition@2@@Z endp
.text$mn:000084CC
.text$mn:000084CC ; ---------------------------------------------------------------------------
.text$mn:000084CF                 align 10h
.text$mn:000084CF _text$mn        ends
.text$mn:000084CF
.text$mn:000084D0 ; ===========================================================================
.text$mn:000084D0
.text$mn:000084D0 ; Segment type: Pure code
.text$mn:000084D0 ; Segment permissions: Read/Execute
.text$mn:000084D0 _text$mn        segment para public 'CODE' use32
.text$mn:000084D0                 assume cs:_text$mn
.text$mn:000084D0                 ;org 84D0h
.text$mn:000084D0 ; COMDAT (pick any)
.text$mn:000084D0                 assume es:nothing, ss:nothing, ds:_data, fs:nothing, gs:nothing
.text$mn:000084D0
.text$mn:000084D0 ; =============== S U B R O U T I N E =======================================
.text$mn:000084D0
.text$mn:000084D0 ; Attributes: bp-based frame
.text$mn:000084D0
.text$mn:000084D0 ; public: class std::basic_string<char, struct std::char_traits<char>, class std::allocator<char>> & __thiscall std::basic_string<char, struct std::char_traits<char>, class std::allocator<char>>::erase(unsigned int)
.text$mn:000084D0                 public ?erase@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV12@I@Z
.text$mn:000084D0 ?erase@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV12@I@Z proc near
.text$mn:000084D0                                         ; CODE XREF: std::basic_string<char,std::char_traits<char>,std::allocator<char>>::assign(std::basic_string<char,std::char_traits<char>,std::allocator<char>> const &,uint,uint)+4Cp
.text$mn:000084D0
.text$mn:000084D0 var_4           = dword ptr -4
.text$mn:000084D0 arg_0           = dword ptr  8
.text$mn:000084D0
.text$mn:000084D0                 push    ebp
.text$mn:000084D1                 mov     ebp, esp
.text$mn:000084D3                 push    ecx
.text$mn:000084D4                 mov     [ebp+var_4], ecx
.text$mn:000084D7                 mov     eax, [ebp+var_4]
.text$mn:000084DA                 mov     ecx, [eax+14h]
.text$mn:000084DD                 cmp     ecx, [ebp+arg_0]
.text$mn:000084E0                 jnb     short loc_84EA
.text$mn:000084E2                 mov     ecx, [ebp+var_4]
.text$mn:000084E5                 call    ?_Xran@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QBEXXZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char>>::_Xran(void)
.text$mn:000084EA
.text$mn:000084EA loc_84EA:                               ; CODE XREF: std::basic_string<char,std::char_traits<char>,std::allocator<char>>::erase(uint)+10j
.text$mn:000084EA                 mov     edx, [ebp+arg_0]
.text$mn:000084ED                 push    edx
.text$mn:000084EE                 mov     ecx, [ebp+var_4]
.text$mn:000084F1                 call    ?_Eos@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEXI@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char>>::_Eos(uint)
.text$mn:000084F6                 mov     eax, [ebp+var_4]
.text$mn:000084F9                 mov     esp, ebp
.text$mn:000084FB                 pop     ebp
.text$mn:000084FC                 retn    4
.text$mn:000084FC ?erase@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV12@I@Z endp
.text$mn:000084FC
.text$mn:000084FC ; ---------------------------------------------------------------------------
.text$mn:000084FF                 align 10h
.text$mn:000084FF _text$mn        ends
.text$mn:000084FF
.text$mn:00008500 ; ===========================================================================
.text$mn:00008500
.text$mn:00008500 ; Segment type: Pure code
.text$mn:00008500 ; Segment permissions: Read/Execute
.text$mn:00008500 _text$mn        segment para public 'CODE' use32
.text$mn:00008500                 assume cs:_text$mn
.text$mn:00008500                 ;org 8500h
.text$mn:00008500 ; COMDAT (pick any)
.text$mn:00008500                 assume es:nothing, ss:nothing, ds:_data, fs:nothing, gs:nothing
.text$mn:00008500
.text$mn:00008500 ; =============== S U B R O U T I N E =======================================
.text$mn:00008500
.text$mn:00008500 ; Attributes: bp-based frame
.text$mn:00008500
.text$mn:00008500 ; public: class std::basic_string<char, struct std::char_traits<char>, class std::allocator<char>> & __thiscall std::basic_string<char, struct std::char_traits<char>, class std::allocator<char>>::erase(unsigned int, unsigned int)
.text$mn:00008500                 public ?erase@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV12@II@Z
.text$mn:00008500 ?erase@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV12@II@Z proc near
.text$mn:00008500                                         ; CODE XREF: std::basic_string<char,std::char_traits<char>,std::allocator<char>>::assign(std::basic_string<char,std::char_traits<char>,std::allocator<char>> const &,uint,uint)+5Ap
.text$mn:00008500
.text$mn:00008500 var_C           = dword ptr -0Ch
.text$mn:00008500 Dst             = dword ptr -8
.text$mn:00008500 var_4           = dword ptr -4
.text$mn:00008500 arg_0           = dword ptr  8
.text$mn:00008500 arg_4           = dword ptr  0Ch
.text$mn:00008500
.text$mn:00008500                 push    ebp
.text$mn:00008501                 mov     ebp, esp
.text$mn:00008503                 sub     esp, 0Ch
.text$mn:00008506                 mov     [ebp+var_4], ecx
.text$mn:00008509                 mov     eax, [ebp+var_4]
.text$mn:0000850C                 mov     ecx, [eax+14h]
.text$mn:0000850F                 cmp     ecx, [ebp+arg_0]
.text$mn:00008512                 jnb     short loc_851C
.text$mn:00008514                 mov     ecx, [ebp+var_4]
.text$mn:00008517                 call    ?_Xran@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QBEXXZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char>>::_Xran(void)
.text$mn:0000851C
.text$mn:0000851C loc_851C:                               ; CODE XREF: std::basic_string<char,std::char_traits<char>,std::allocator<char>>::erase(uint,uint)+12j
.text$mn:0000851C                 mov     edx, [ebp+var_4]
.text$mn:0000851F                 mov     eax, [edx+14h]
.text$mn:00008522                 sub     eax, [ebp+arg_0]
.text$mn:00008525                 cmp     eax, [ebp+arg_4]
.text$mn:00008528                 ja      short loc_8538
.text$mn:0000852A                 mov     ecx, [ebp+arg_0]
.text$mn:0000852D                 push    ecx
.text$mn:0000852E                 mov     ecx, [ebp+var_4]
.text$mn:00008531                 call    ?_Eos@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEXI@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char>>::_Eos(uint)
.text$mn:00008536                 jmp     short loc_857E
.text$mn:00008538 ; ---------------------------------------------------------------------------
.text$mn:00008538
.text$mn:00008538 loc_8538:                               ; CODE XREF: std::basic_string<char,std::char_traits<char>,std::allocator<char>>::erase(uint,uint)+28j
.text$mn:00008538                 cmp     [ebp+arg_4], 0
.text$mn:0000853C                 jbe     short loc_857E
.text$mn:0000853E                 mov     ecx, [ebp+var_4]
.text$mn:00008541                 call    ?_Myptr@?$_String_val@U?$_Simple_types@D@std@@@std@@QAEPADXZ ; std::_String_val<std::_Simple_types<char>>::_Myptr(void)
.text$mn:00008546                 add     eax, [ebp+arg_0]
.text$mn:00008549                 mov     [ebp+Dst], eax
.text$mn:0000854C                 mov     edx, [ebp+var_4]
.text$mn:0000854F                 mov     eax, [edx+14h]
.text$mn:00008552                 sub     eax, [ebp+arg_4]
.text$mn:00008555                 mov     [ebp+var_C], eax
.text$mn:00008558                 mov     ecx, [ebp+var_C]
.text$mn:0000855B                 sub     ecx, [ebp+arg_0]
.text$mn:0000855E                 push    ecx             ; Size
.text$mn:0000855F                 mov     edx, [ebp+Dst]
.text$mn:00008562                 add     edx, [ebp+arg_4]
.text$mn:00008565                 push    edx             ; Src
.text$mn:00008566                 mov     eax, [ebp+Dst]
.text$mn:00008569                 push    eax             ; Dst
.text$mn:0000856A                 call    ?move@?$char_traits@D@std@@SAPADPADPBDI@Z ; std::char_traits<char>::move(char *,char const *,uint)
.text$mn:0000856F                 add     esp, 0Ch
.text$mn:00008572                 mov     ecx, [ebp+var_C]
.text$mn:00008575                 push    ecx
.text$mn:00008576                 mov     ecx, [ebp+var_4]
.text$mn:00008579                 call    ?_Eos@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEXI@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char>>::_Eos(uint)
.text$mn:0000857E
.text$mn:0000857E loc_857E:                               ; CODE XREF: std::basic_string<char,std::char_traits<char>,std::allocator<char>>::erase(uint,uint)+36j
.text$mn:0000857E                                         ; std::basic_string<char,std::char_traits<char>,std::allocator<char>>::erase(uint,uint)+3Cj
.text$mn:0000857E                 mov     eax, [ebp+var_4]
.text$mn:00008581                 mov     esp, ebp
.text$mn:00008583                 pop     ebp
.text$mn:00008584                 retn    8
.text$mn:00008584 ?erase@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV12@II@Z endp
.text$mn:00008584
.text$mn:00008584 ; ---------------------------------------------------------------------------
.text$mn:00008587                 align 4
.text$mn:00008587 _text$mn        ends
.text$mn:00008587
.text$mn:00008588 ; ===========================================================================
.text$mn:00008588
.text$mn:00008588 ; Segment type: Pure code
.text$mn:00008588 ; Segment permissions: Read/Execute
.text$mn:00008588 _text$mn        segment para public 'CODE' use32
.text$mn:00008588                 assume cs:_text$mn
.text$mn:00008588                 ;org 8588h
.text$mn:00008588 ; COMDAT (pick any)
.text$mn:00008588                 assume es:nothing, ss:nothing, ds:_data, fs:nothing, gs:nothing
.text$mn:00008588
.text$mn:00008588 ; =============== S U B R O U T I N E =======================================
.text$mn:00008588
.text$mn:00008588 ; Attributes: bp-based frame
.text$mn:00008588
.text$mn:00008588 ; __int32 __thiscall ScintillaEditView::execute(ScintillaEditView *this, unsigned int, unsigned int, __int32)
.text$mn:00008588                 public ?execute@ScintillaEditView@@QBEJIIJ@Z
.text$mn:00008588 ?execute@ScintillaEditView@@QBEJIIJ@Z proc near
.text$mn:00008588                                         ; CODE XREF: FunctionCallTip::updateCalltip(int,bool)+3Cp
.text$mn:00008588                                         ; FunctionCallTip::close(void)+31p ...
.text$mn:00008588
.text$mn:00008588 var_4           = dword ptr -4
.text$mn:00008588 arg_0           = dword ptr  8
.text$mn:00008588 arg_4           = dword ptr  0Ch
.text$mn:00008588 arg_8           = dword ptr  10h
.text$mn:00008588
.text$mn:00008588                 push    ebp
.text$mn:00008589                 mov     ebp, esp
.text$mn:0000858B                 push    ecx
.text$mn:0000858C                 mov     [ebp+var_4], ecx
.text$mn:0000858F                 mov     eax, [ebp+arg_8]
.text$mn:00008592                 push    eax
.text$mn:00008593                 mov     ecx, [ebp+arg_4]
.text$mn:00008596                 push    ecx
.text$mn:00008597                 mov     edx, [ebp+arg_0]
.text$mn:0000859A                 push    edx
.text$mn:0000859B                 mov     eax, [ebp+var_4]
.text$mn:0000859E                 mov     ecx, [eax+14h]
.text$mn:000085A1                 push    ecx
.text$mn:000085A2                 mov     edx, [ebp+var_4]
.text$mn:000085A5                 mov     eax, [edx+10h]
.text$mn:000085A8                 call    eax
.text$mn:000085AA                 add     esp, 10h
.text$mn:000085AD                 mov     esp, ebp
.text$mn:000085AF                 pop     ebp
.text$mn:000085B0                 retn    0Ch
.text$mn:000085B0 ?execute@ScintillaEditView@@QBEJIIJ@Z endp
.text$mn:000085B0
.text$mn:000085B0 ; ---------------------------------------------------------------------------
.text$mn:000085B3                 align 4
.text$mn:000085B3 _text$mn        ends
.text$mn:000085B3
.text$mn:000085B4 ; ===========================================================================
.text$mn:000085B4
.text$mn:000085B4 ; Segment type: Pure code
.text$mn:000085B4 ; Segment permissions: Read/Execute
.text$mn:000085B4 _text$mn        segment para public 'CODE' use32
.text$mn:000085B4                 assume cs:_text$mn
.text$mn:000085B4                 ;org 85B4h
.text$mn:000085B4 ; COMDAT (pick any)
.text$mn:000085B4                 assume es:nothing, ss:nothing, ds:_data, fs:nothing, gs:nothing
.text$mn:000085B4
.text$mn:000085B4 ; =============== S U B R O U T I N E =======================================
.text$mn:000085B4
.text$mn:000085B4 ; Attributes: bp-based frame
.text$mn:000085B4
.text$mn:000085B4 ; const struct std::error_category *__cdecl std::generic_category()
.text$mn:000085B4                 public ?generic_category@std@@YAABVerror_category@1@XZ
.text$mn:000085B4 ?generic_category@std@@YAABVerror_category@1@XZ proc near
.text$mn:000085B4                                         ; CODE XREF: std::_System_error_category::default_error_condition(int)+17p
.text$mn:000085B4                 push    ebp
.text$mn:000085B5                 mov     ebp, esp
.text$mn:000085B7                 mov     eax, offset ?_Generic_object@?$_Error_objects@H@std@@2V_Generic_error_category@2@A ; std::_Generic_error_category std::_Error_objects<int>::_Generic_object
.text$mn:000085BC                 pop     ebp
.text$mn:000085BD                 retn
.text$mn:000085BD ?generic_category@std@@YAABVerror_category@1@XZ endp
.text$mn:000085BD
.text$mn:000085BD ; ---------------------------------------------------------------------------
.text$mn:000085BE                 align 10h
.text$mn:000085BE _text$mn        ends
.text$mn:000085BE
.text$mn:000085C0 ; ===========================================================================
.text$mn:000085C0
.text$mn:000085C0 ; Segment type: Pure code
.text$mn:000085C0 ; Segment permissions: Read/Execute
.text$mn:000085C0 _text$mn        segment para public 'CODE' use32
.text$mn:000085C0                 assume cs:_text$mn
.text$mn:000085C0                 ;org 85C0h
.text$mn:000085C0 ; COMDAT (pick any)
.text$mn:000085C0                 assume es:nothing, ss:nothing, ds:_data, fs:nothing, gs:nothing
.text$mn:000085C0
.text$mn:000085C0 ; =============== S U B R O U T I N E =======================================
.text$mn:000085C0
.text$mn:000085C0 ; Attributes: bp-based frame
.text$mn:000085C0
.text$mn:000085C0 ; bool __thiscall FunctionCallTip::isAdditionalWordChar(FunctionCallTip *this, wchar_t)
.text$mn:000085C0                 public ?isAdditionalWordChar@FunctionCallTip@@ABE_N_W@Z
.text$mn:000085C0 ?isAdditionalWordChar@FunctionCallTip@@ABE_N_W@Z proc near
.text$mn:000085C0                                         ; CODE XREF: FunctionCallTip::getCursorFunction(void)+1BEp
.text$mn:000085C0                                         ; FunctionCallTip::getCursorFunction(void)+213p
.text$mn:000085C0
.text$mn:000085C0 var_10          = dword ptr -10h
.text$mn:000085C0 var_C           = dword ptr -0Ch
.text$mn:000085C0 var_8           = dword ptr -8
.text$mn:000085C0 var_4           = dword ptr -4
.text$mn:000085C0 arg_0           = word ptr  8
.text$mn:000085C0
.text$mn:000085C0                 push    ebp
.text$mn:000085C1                 mov     ebp, esp
.text$mn:000085C3                 sub     esp, 10h
.text$mn:000085C6                 mov     [ebp+var_8], ecx
.text$mn:000085C9                 mov     ecx, [ebp+var_8]
.text$mn:000085CC                 add     ecx, 5Ch ; '\'
.text$mn:000085CF                 call    ?c_str@?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QBEPB_WXZ ; std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>>::c_str(void)
.text$mn:000085D4                 mov     [ebp+var_10], eax
.text$mn:000085D7                 mov     ecx, [ebp+var_8]
.text$mn:000085DA                 add     ecx, 5Ch ; '\'
.text$mn:000085DD                 call    ?length@?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QBEIXZ ; std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>>::length(void)
.text$mn:000085E2                 mov     [ebp+var_C], eax
.text$mn:000085E5                 mov     [ebp+var_4], 0
.text$mn:000085EC                 jmp     short loc_85F7
.text$mn:000085EE ; ---------------------------------------------------------------------------
.text$mn:000085EE
.text$mn:000085EE loc_85EE:                               ; CODE XREF: FunctionCallTip::isAdditionalWordChar(wchar_t):loc_8615j
.text$mn:000085EE                 mov     eax, [ebp+var_4]
.text$mn:000085F1                 add     eax, 1
.text$mn:000085F4                 mov     [ebp+var_4], eax
.text$mn:000085F7
.text$mn:000085F7 loc_85F7:                               ; CODE XREF: FunctionCallTip::isAdditionalWordChar(wchar_t)+2Cj
.text$mn:000085F7                 mov     ecx, [ebp+var_4]
.text$mn:000085FA                 cmp     ecx, [ebp+var_C]
.text$mn:000085FD                 jnb     short loc_8617
.text$mn:000085FF                 movzx   edx, [ebp+arg_0]
.text$mn:00008603                 mov     eax, [ebp+var_4]
.text$mn:00008606                 mov     ecx, [ebp+var_10]
.text$mn:00008609                 movzx   eax, word ptr [ecx+eax*2]
.text$mn:0000860D                 cmp     edx, eax
.text$mn:0000860F                 jnz     short loc_8615
.text$mn:00008611                 mov     al, 1
.text$mn:00008613                 jmp     short loc_8619
.text$mn:00008615 ; ---------------------------------------------------------------------------
.text$mn:00008615
.text$mn:00008615 loc_8615:                               ; CODE XREF: FunctionCallTip::isAdditionalWordChar(wchar_t)+4Fj
.text$mn:00008615                 jmp     short loc_85EE
.text$mn:00008617 ; ---------------------------------------------------------------------------
.text$mn:00008617
.text$mn:00008617 loc_8617:                               ; CODE XREF: FunctionCallTip::isAdditionalWordChar(wchar_t)+3Dj
.text$mn:00008617                 xor     al, al
.text$mn:00008619
.text$mn:00008619 loc_8619:                               ; CODE XREF: FunctionCallTip::isAdditionalWordChar(wchar_t)+53j
.text$mn:00008619                 mov     esp, ebp
.text$mn:0000861B                 pop     ebp
.text$mn:0000861C                 retn    4
.text$mn:0000861C ?isAdditionalWordChar@FunctionCallTip@@ABE_N_W@Z endp
.text$mn:0000861C
.text$mn:0000861C ; ---------------------------------------------------------------------------
.text$mn:0000861F                 align 10h
.text$mn:0000861F _text$mn        ends
.text$mn:0000861F
.text$mn:00008620 ; ===========================================================================
.text$mn:00008620
.text$mn:00008620 ; Segment type: Pure code
.text$mn:00008620 ; Segment permissions: Read/Execute
.text$mn:00008620 _text$mn        segment para public 'CODE' use32
.text$mn:00008620                 assume cs:_text$mn
.text$mn:00008620                 ;org 8620h
.text$mn:00008620 ; COMDAT (pick any)
.text$mn:00008620                 assume es:nothing, ss:nothing, ds:_data, fs:nothing, gs:nothing
.text$mn:00008620
.text$mn:00008620 ; =============== S U B R O U T I N E =======================================
.text$mn:00008620
.text$mn:00008620 ; Attributes: bp-based frame
.text$mn:00008620
.text$mn:00008620 ; bool __thiscall FunctionCallTip::isBasicWordChar(FunctionCallTip *this, wchar_t)
.text$mn:00008620                 public ?isBasicWordChar@FunctionCallTip@@ABE_N_W@Z
.text$mn:00008620 ?isBasicWordChar@FunctionCallTip@@ABE_N_W@Z proc near
.text$mn:00008620                                         ; CODE XREF: FunctionCallTip::getCursorFunction(void)+1A4p
.text$mn:00008620                                         ; FunctionCallTip::getCursorFunction(void)+1F9p
.text$mn:00008620
.text$mn:00008620 var_8           = dword ptr -8
.text$mn:00008620 var_4           = dword ptr -4
.text$mn:00008620 arg_0           = word ptr  8
.text$mn:00008620
.text$mn:00008620                 push    ebp
.text$mn:00008621                 mov     ebp, esp
.text$mn:00008623                 sub     esp, 8
.text$mn:00008626                 mov     [ebp+var_8], ecx
.text$mn:00008629                 movzx   eax, [ebp+arg_0]
.text$mn:0000862D                 cmp     eax, 41h ; 'A'
.text$mn:00008630                 jl      short loc_863B
.text$mn:00008632                 movzx   ecx, [ebp+arg_0]
.text$mn:00008636                 cmp     ecx, 5Ah ; 'Z'
.text$mn:00008639                 jle     short loc_8671
.text$mn:0000863B
.text$mn:0000863B loc_863B:                               ; CODE XREF: FunctionCallTip::isBasicWordChar(wchar_t)+10j
.text$mn:0000863B                 movzx   edx, [ebp+arg_0]
.text$mn:0000863F                 cmp     edx, 61h ; 'a'
.text$mn:00008642                 jl      short loc_864D
.text$mn:00008644                 movzx   eax, [ebp+arg_0]
.text$mn:00008648                 cmp     eax, 7Ah ; 'z'
.text$mn:0000864B                 jle     short loc_8671
.text$mn:0000864D
.text$mn:0000864D loc_864D:                               ; CODE XREF: FunctionCallTip::isBasicWordChar(wchar_t)+22j
.text$mn:0000864D                 movzx   ecx, [ebp+arg_0]
.text$mn:00008651                 cmp     ecx, 30h ; '0'
.text$mn:00008654                 jl      short loc_865F
.text$mn:00008656                 movzx   edx, [ebp+arg_0]
.text$mn:0000865A                 cmp     edx, 39h ; '9'
.text$mn:0000865D                 jle     short loc_8671
.text$mn:0000865F
.text$mn:0000865F loc_865F:                               ; CODE XREF: FunctionCallTip::isBasicWordChar(wchar_t)+34j
.text$mn:0000865F                 movzx   eax, [ebp+arg_0]
.text$mn:00008663                 cmp     eax, 5Fh ; '_'
.text$mn:00008666                 jz      short loc_8671
.text$mn:00008668                 mov     [ebp+var_4], 0
.text$mn:0000866F                 jmp     short loc_8678
.text$mn:00008671 ; ---------------------------------------------------------------------------
.text$mn:00008671
.text$mn:00008671 loc_8671:                               ; CODE XREF: FunctionCallTip::isBasicWordChar(wchar_t)+19j
.text$mn:00008671                                         ; FunctionCallTip::isBasicWordChar(wchar_t)+2Bj ...
.text$mn:00008671                 mov     [ebp+var_4], 1
.text$mn:00008678
.text$mn:00008678 loc_8678:                               ; CODE XREF: FunctionCallTip::isBasicWordChar(wchar_t)+4Fj
.text$mn:00008678                 mov     al, byte ptr [ebp+var_4]
.text$mn:0000867B                 mov     esp, ebp
.text$mn:0000867D                 pop     ebp
.text$mn:0000867E                 retn    4
.text$mn:0000867E ?isBasicWordChar@FunctionCallTip@@ABE_N_W@Z endp
.text$mn:0000867E
.text$mn:0000867E ; ---------------------------------------------------------------------------
.text$mn:00008681                 align 4
.text$mn:00008681 _text$mn        ends
.text$mn:00008681
.text$mn:00008684 ; ===========================================================================
.text$mn:00008684
.text$mn:00008684 ; Segment type: Pure code
.text$mn:00008684 ; Segment permissions: Read/Execute
.text$mn:00008684 _text$mn        segment para public 'CODE' use32
.text$mn:00008684                 assume cs:_text$mn
.text$mn:00008684                 ;org 8684h
.text$mn:00008684 ; COMDAT (pick any)
.text$mn:00008684                 assume es:nothing, ss:nothing, ds:_data, fs:nothing, gs:nothing
.text$mn:00008684
.text$mn:00008684 ; =============== S U B R O U T I N E =======================================
.text$mn:00008684
.text$mn:00008684 ; Attributes: bp-based frame
.text$mn:00008684
.text$mn:00008684 ; bool __thiscall FunctionCallTip::isVisible(FunctionCallTip *__hidden this)
.text$mn:00008684                 public ?isVisible@FunctionCallTip@@QAE_NXZ
.text$mn:00008684 ?isVisible@FunctionCallTip@@QAE_NXZ proc near
.text$mn:00008684                                         ; CODE XREF: FunctionCallTip::setLanguageXML(TiXmlElement *)+Cp
.text$mn:00008684                                         ; FunctionCallTip::updateCalltip(int,bool)+1Ep ...
.text$mn:00008684
.text$mn:00008684 var_C           = dword ptr -0Ch
.text$mn:00008684 var_8           = dword ptr -8
.text$mn:00008684 var_4           = dword ptr -4
.text$mn:00008684
.text$mn:00008684                 push    ebp
.text$mn:00008685                 mov     ebp, esp
.text$mn:00008687                 sub     esp, 0Ch
.text$mn:0000868A                 mov     [ebp+var_4], ecx
.text$mn:0000868D                 mov     eax, [ebp+var_4]
.text$mn:00008690                 cmp     dword ptr [eax], 0
.text$mn:00008693                 jz      short loc_86C5
.text$mn:00008695                 push    0               ; __int32
.text$mn:00008697                 push    0               ; unsigned int
.text$mn:00008699                 push    89Ah            ; unsigned int
.text$mn:0000869E                 mov     ecx, [ebp+var_4]
.text$mn:000086A1                 mov     ecx, [ecx]      ; this
.text$mn:000086A3                 call    ?execute@ScintillaEditView@@QBEJIIJ@Z ; ScintillaEditView::execute(uint,uint,long)
.text$mn:000086A8                 cmp     eax, 1
.text$mn:000086AB                 jnz     short loc_86B6
.text$mn:000086AD                 mov     [ebp+var_8], 1
.text$mn:000086B4                 jmp     short loc_86BD
.text$mn:000086B6 ; ---------------------------------------------------------------------------
.text$mn:000086B6
.text$mn:000086B6 loc_86B6:                               ; CODE XREF: FunctionCallTip::isVisible(void)+27j
.text$mn:000086B6                 mov     [ebp+var_8], 0
.text$mn:000086BD
.text$mn:000086BD loc_86BD:                               ; CODE XREF: FunctionCallTip::isVisible(void)+30j
.text$mn:000086BD                 mov     edx, [ebp+var_8]
.text$mn:000086C0                 mov     [ebp+var_C], edx
.text$mn:000086C3                 jmp     short loc_86CC
.text$mn:000086C5 ; ---------------------------------------------------------------------------
.text$mn:000086C5
.text$mn:000086C5 loc_86C5:                               ; CODE XREF: FunctionCallTip::isVisible(void)+Fj
.text$mn:000086C5                 mov     [ebp+var_C], 0
.text$mn:000086CC
.text$mn:000086CC loc_86CC:                               ; CODE XREF: FunctionCallTip::isVisible(void)+3Fj
.text$mn:000086CC                 mov     al, byte ptr [ebp+var_C]
.text$mn:000086CF                 mov     esp, ebp
.text$mn:000086D1                 pop     ebp
.text$mn:000086D2                 retn
.text$mn:000086D2 ?isVisible@FunctionCallTip@@QAE_NXZ endp
.text$mn:000086D2
.text$mn:000086D2 ; ---------------------------------------------------------------------------
.text$mn:000086D3                 align 4
.text$mn:000086D3 _text$mn        ends
.text$mn:000086D3
.text$mn:000086D4 ; ===========================================================================
.text$mn:000086D4
.text$mn:000086D4 ; Segment type: Pure code
.text$mn:000086D4 ; Segment permissions: Read/Execute
.text$mn:000086D4 _text$mn        segment para public 'CODE' use32
.text$mn:000086D4                 assume cs:_text$mn
.text$mn:000086D4                 ;org 86D4h
.text$mn:000086D4 ; COMDAT (pick any)
.text$mn:000086D4                 assume es:nothing, ss:nothing, ds:_data, fs:nothing, gs:nothing
.text$mn:000086D4
.text$mn:000086D4 ; =============== S U B R O U T I N E =======================================
.text$mn:000086D4
.text$mn:000086D4 ; Attributes: bp-based frame
.text$mn:000086D4
.text$mn:000086D4 ; public: unsigned int __thiscall std::basic_string<wchar_t, struct std::char_traits<wchar_t>, class std::allocator<wchar_t>>::length(void)const
.text$mn:000086D4                 public ?length@?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QBEIXZ
.text$mn:000086D4 ?length@?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QBEIXZ proc near
.text$mn:000086D4                                         ; CODE XREF: FunctionCallTip::isAdditionalWordChar(wchar_t)+1Dp
.text$mn:000086D4
.text$mn:000086D4 var_4           = dword ptr -4
.text$mn:000086D4
.text$mn:000086D4                 push    ebp
.text$mn:000086D5                 mov     ebp, esp
.text$mn:000086D7                 push    ecx
.text$mn:000086D8                 mov     [ebp+var_4], ecx
.text$mn:000086DB                 mov     eax, [ebp+var_4]
.text$mn:000086DE                 mov     eax, [eax+14h]
.text$mn:000086E1                 mov     esp, ebp
.text$mn:000086E3                 pop     ebp
.text$mn:000086E4                 retn
.text$mn:000086E4 ?length@?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QBEIXZ endp
.text$mn:000086E4
.text$mn:000086E4 ; ---------------------------------------------------------------------------
.text$mn:000086E5                 align 4
.text$mn:000086E5 _text$mn        ends
.text$mn:000086E5
.text$mn:000086E8 ; ===========================================================================
.text$mn:000086E8
.text$mn:000086E8 ; Segment type: Pure code
.text$mn:000086E8 ; Segment permissions: Read/Execute
.text$mn:000086E8 _text$mn        segment para public 'CODE' use32
.text$mn:000086E8                 assume cs:_text$mn
.text$mn:000086E8                 ;org 86E8h
.text$mn:000086E8 ; COMDAT (pick any)
.text$mn:000086E8                 assume es:nothing, ss:nothing, ds:_data, fs:nothing, gs:nothing
.text$mn:000086E8
.text$mn:000086E8 ; =============== S U B R O U T I N E =======================================
.text$mn:000086E8
.text$mn:000086E8 ; Attributes: bp-based frame
.text$mn:000086E8
.text$mn:000086E8 ; int __cdecl std::char_traits<char>::length(char *Str)
.text$mn:000086E8                 public ?length@?$char_traits@D@std@@SAIPBD@Z
.text$mn:000086E8 ?length@?$char_traits@D@std@@SAIPBD@Z proc near
.text$mn:000086E8                                         ; CODE XREF: std::basic_string<char,std::char_traits<char>,std::allocator<char>>::assign(char const *)+21p
.text$mn:000086E8
.text$mn:000086E8 var_4           = dword ptr -4
.text$mn:000086E8 Str             = dword ptr  8
.text$mn:000086E8
.text$mn:000086E8                 push    ebp
.text$mn:000086E9                 mov     ebp, esp
.text$mn:000086EB                 push    ecx
.text$mn:000086EC                 mov     eax, [ebp+Str]
.text$mn:000086EF                 movsx   ecx, byte ptr [eax]
.text$mn:000086F2                 test    ecx, ecx
.text$mn:000086F4                 jnz     short loc_86FF
.text$mn:000086F6                 mov     [ebp+var_4], 0
.text$mn:000086FD                 jmp     short loc_870E
.text$mn:000086FF ; ---------------------------------------------------------------------------
.text$mn:000086FF
.text$mn:000086FF loc_86FF:                               ; CODE XREF: std::char_traits<char>::length(char const *)+Cj
.text$mn:000086FF                 mov     edx, [ebp+Str]
.text$mn:00008702                 push    edx             ; Str
.text$mn:00008703                 call    _strlen
.text$mn:00008708                 add     esp, 4
.text$mn:0000870B                 mov     [ebp+var_4], eax
.text$mn:0000870E
.text$mn:0000870E loc_870E:                               ; CODE XREF: std::char_traits<char>::length(char const *)+15j
.text$mn:0000870E                 mov     eax, [ebp+var_4]
.text$mn:00008711                 mov     esp, ebp
.text$mn:00008713                 pop     ebp
.text$mn:00008714                 retn
.text$mn:00008714 ?length@?$char_traits@D@std@@SAIPBD@Z endp
.text$mn:00008714
.text$mn:00008714 ; ---------------------------------------------------------------------------
.text$mn:00008715                 align 4
.text$mn:00008715 _text$mn        ends
.text$mn:00008715
.text$mn:00008718 ; ===========================================================================
.text$mn:00008718
.text$mn:00008718 ; Segment type: Pure code
.text$mn:00008718 ; Segment permissions: Read/Execute
.text$mn:00008718 _text$mn        segment para public 'CODE' use32
.text$mn:00008718                 assume cs:_text$mn
.text$mn:00008718                 ;org 8718h
.text$mn:00008718 ; COMDAT (pick any)
.text$mn:00008718                 assume es:nothing, ss:nothing, ds:_data, fs:nothing, gs:nothing
.text$mn:00008718
.text$mn:00008718 ; =============== S U B R O U T I N E =======================================
.text$mn:00008718
.text$mn:00008718 ; Attributes: bp-based frame
.text$mn:00008718
.text$mn:00008718 ; bool __cdecl lower(wchar_t)
.text$mn:00008718                 public ?lower@@YA_N_W@Z
.text$mn:00008718 ?lower@@YA_N_W@Z proc near              ; CODE XREF: testNameNoCase(wchar_t const *,wchar_t const *,int)+72p
.text$mn:00008718                                         ; testNameNoCase(wchar_t const *,wchar_t const *,int)+A2p ...
.text$mn:00008718
.text$mn:00008718 var_4           = dword ptr -4
.text$mn:00008718 arg_0           = word ptr  8
.text$mn:00008718
.text$mn:00008718                 push    ebp
.text$mn:00008719                 mov     ebp, esp
.text$mn:0000871B                 push    ecx
.text$mn:0000871C                 movzx   eax, [ebp+arg_0]
.text$mn:00008720                 cmp     eax, 61h ; 'a'
.text$mn:00008723                 jl      short loc_8737
.text$mn:00008725                 movzx   ecx, [ebp+arg_0]
.text$mn:00008729                 cmp     ecx, 7Ah ; 'z'
.text$mn:0000872C                 jg      short loc_8737
.text$mn:0000872E                 mov     [ebp+var_4], 1
.text$mn:00008735                 jmp     short loc_873E
.text$mn:00008737 ; ---------------------------------------------------------------------------
.text$mn:00008737
.text$mn:00008737 loc_8737:                               ; CODE XREF: lower(wchar_t)+Bj
.text$mn:00008737                                         ; lower(wchar_t)+14j
.text$mn:00008737                 mov     [ebp+var_4], 0
.text$mn:0000873E
.text$mn:0000873E loc_873E:                               ; CODE XREF: lower(wchar_t)+1Dj
.text$mn:0000873E                 mov     al, byte ptr [ebp+var_4]
.text$mn:00008741                 mov     esp, ebp
.text$mn:00008743                 pop     ebp
.text$mn:00008744                 retn
.text$mn:00008744 ?lower@@YA_N_W@Z endp
.text$mn:00008744
.text$mn:00008744 ; ---------------------------------------------------------------------------
.text$mn:00008745                 align 4
.text$mn:00008745 _text$mn        ends
.text$mn:00008745
.text$mn:00008748 ; ===========================================================================
.text$mn:00008748
.text$mn:00008748 ; Segment type: Pure code
.text$mn:00008748 ; Segment permissions: Read/Execute
.text$mn:00008748 _text$mn        segment para public 'CODE' use32
.text$mn:00008748                 assume cs:_text$mn
.text$mn:00008748                 ;org 8748h
.text$mn:00008748 ; COMDAT (pick any)
.text$mn:00008748                 assume es:nothing, ss:nothing, ds:_data, fs:nothing, gs:nothing
.text$mn:00008748
.text$mn:00008748 ; =============== S U B R O U T I N E =======================================
.text$mn:00008748
.text$mn:00008748 ; Attributes: bp-based frame
.text$mn:00008748
.text$mn:00008748 ; bool __cdecl match(wchar_t, wchar_t)
.text$mn:00008748                 public ?match@@YA_N_W0@Z
.text$mn:00008748 ?match@@YA_N_W0@Z proc near             ; CODE XREF: testNameNoCase(wchar_t const *,wchar_t const *,int)+30p
.text$mn:00008748
.text$mn:00008748 var_8           = dword ptr -8
.text$mn:00008748 var_4           = dword ptr -4
.text$mn:00008748 arg_0           = word ptr  8
.text$mn:00008748 arg_4           = word ptr  0Ch
.text$mn:00008748
.text$mn:00008748                 push    ebp
.text$mn:00008749                 mov     ebp, esp
.text$mn:0000874B                 sub     esp, 8
.text$mn:0000874E                 movzx   eax, [ebp+arg_0]
.text$mn:00008752                 movzx   ecx, [ebp+arg_4]
.text$mn:00008756                 cmp     eax, ecx
.text$mn:00008758                 jnz     short loc_875E
.text$mn:0000875A                 mov     al, 1
.text$mn:0000875C                 jmp     short loc_87D0
.text$mn:0000875E ; ---------------------------------------------------------------------------
.text$mn:0000875E
.text$mn:0000875E loc_875E:                               ; CODE XREF: match(wchar_t,wchar_t)+10j
.text$mn:0000875E                 movzx   edx, [ebp+arg_0]
.text$mn:00008762                 push    edx             ; wchar_t
.text$mn:00008763                 call    ?lower@@YA_N_W@Z ; lower(wchar_t)
.text$mn:00008768                 add     esp, 4
.text$mn:0000876B                 movzx   eax, al
.text$mn:0000876E                 test    eax, eax
.text$mn:00008770                 jz      short loc_8796
.text$mn:00008772                 movzx   ecx, [ebp+arg_0]
.text$mn:00008776                 sub     ecx, 20h ; ' '
.text$mn:00008779                 movzx   edx, [ebp+arg_4]
.text$mn:0000877D                 cmp     ecx, edx
.text$mn:0000877F                 jnz     short loc_878A
.text$mn:00008781                 mov     [ebp+var_4], 1
.text$mn:00008788                 jmp     short loc_8791
.text$mn:0000878A ; ---------------------------------------------------------------------------
.text$mn:0000878A
.text$mn:0000878A loc_878A:                               ; CODE XREF: match(wchar_t,wchar_t)+37j
.text$mn:0000878A                 mov     [ebp+var_4], 0
.text$mn:00008791
.text$mn:00008791 loc_8791:                               ; CODE XREF: match(wchar_t,wchar_t)+40j
.text$mn:00008791                 mov     al, byte ptr [ebp+var_4]
.text$mn:00008794                 jmp     short loc_87D0
.text$mn:00008796 ; ---------------------------------------------------------------------------
.text$mn:00008796
.text$mn:00008796 loc_8796:                               ; CODE XREF: match(wchar_t,wchar_t)+28j
.text$mn:00008796                 movzx   eax, [ebp+arg_4]
.text$mn:0000879A                 push    eax             ; wchar_t
.text$mn:0000879B                 call    ?lower@@YA_N_W@Z ; lower(wchar_t)
.text$mn:000087A0                 add     esp, 4
.text$mn:000087A3                 movzx   ecx, al
.text$mn:000087A6                 test    ecx, ecx
.text$mn:000087A8                 jz      short loc_87CE
.text$mn:000087AA                 movzx   edx, [ebp+arg_4]
.text$mn:000087AE                 sub     edx, 20h ; ' '
.text$mn:000087B1                 movzx   eax, [ebp+arg_0]
.text$mn:000087B5                 cmp     edx, eax
.text$mn:000087B7                 jnz     short loc_87C2
.text$mn:000087B9                 mov     [ebp+var_8], 1
.text$mn:000087C0                 jmp     short loc_87C9
.text$mn:000087C2 ; ---------------------------------------------------------------------------
.text$mn:000087C2
.text$mn:000087C2 loc_87C2:                               ; CODE XREF: match(wchar_t,wchar_t)+6Fj
.text$mn:000087C2                 mov     [ebp+var_8], 0
.text$mn:000087C9
.text$mn:000087C9 loc_87C9:                               ; CODE XREF: match(wchar_t,wchar_t)+78j
.text$mn:000087C9                 mov     al, byte ptr [ebp+var_8]
.text$mn:000087CC                 jmp     short loc_87D0
.text$mn:000087CE ; ---------------------------------------------------------------------------
.text$mn:000087CE
.text$mn:000087CE loc_87CE:                               ; CODE XREF: match(wchar_t,wchar_t)+60j
.text$mn:000087CE                 xor     al, al
.text$mn:000087D0
.text$mn:000087D0 loc_87D0:                               ; CODE XREF: match(wchar_t,wchar_t)+14j
.text$mn:000087D0                                         ; match(wchar_t,wchar_t)+4Cj ...
.text$mn:000087D0                 mov     esp, ebp
.text$mn:000087D2                 pop     ebp
.text$mn:000087D3                 retn
.text$mn:000087D3 ?match@@YA_N_W0@Z endp
.text$mn:000087D3
.text$mn:000087D3 _text$mn        ends
.text$mn:000087D3
.text$mn:000087D4 ; ===========================================================================
.text$mn:000087D4
.text$mn:000087D4 ; Segment type: Pure code
.text$mn:000087D4 ; Segment permissions: Read/Execute
.text$mn:000087D4 _text$mn        segment para public 'CODE' use32
.text$mn:000087D4                 assume cs:_text$mn
.text$mn:000087D4                 ;org 87D4h
.text$mn:000087D4 ; COMDAT (pick any)
.text$mn:000087D4                 assume es:nothing, ss:nothing, ds:_data, fs:nothing, gs:nothing
.text$mn:000087D4
.text$mn:000087D4 ; =============== S U B R O U T I N E =======================================
.text$mn:000087D4
.text$mn:000087D4 ; Attributes: bp-based frame
.text$mn:000087D4
.text$mn:000087D4 ; public: unsigned int __thiscall std::_Wrap_alloc<class std::allocator<char>>::max_size(void)const
.text$mn:000087D4                 public ?max_size@?$_Wrap_alloc@V?$allocator@D@std@@@std@@QBEIXZ
.text$mn:000087D4 ?max_size@?$_Wrap_alloc@V?$allocator@D@std@@@std@@QBEIXZ proc near
.text$mn:000087D4                                         ; CODE XREF: std::basic_string<char,std::char_traits<char>,std::allocator<char>>::max_size(void)+17p
.text$mn:000087D4
.text$mn:000087D4 var_4           = dword ptr -4
.text$mn:000087D4
.text$mn:000087D4                 push    ebp
.text$mn:000087D5                 mov     ebp, esp
.text$mn:000087D7                 push    ecx
.text$mn:000087D8                 mov     [ebp+var_4], ecx
.text$mn:000087DB                 mov     eax, [ebp+var_4]
.text$mn:000087DE                 push    eax
.text$mn:000087DF                 call    ?max_size@?$allocator_traits@V?$allocator@D@std@@@std@@SAIABV?$allocator@D@2@@Z ; std::allocator_traits<std::allocator<char>>::max_size(std::allocator<char> const &)
.text$mn:000087E4                 add     esp, 4
.text$mn:000087E7                 mov     esp, ebp
.text$mn:000087E9                 pop     ebp
.text$mn:000087EA                 retn
.text$mn:000087EA ?max_size@?$_Wrap_alloc@V?$allocator@D@std@@@std@@QBEIXZ endp
.text$mn:000087EA
.text$mn:000087EA ; ---------------------------------------------------------------------------
.text$mn:000087EB                 align 4
.text$mn:000087EB _text$mn        ends
.text$mn:000087EB
.text$mn:000087EC ; ===========================================================================
.text$mn:000087EC
.text$mn:000087EC ; Segment type: Pure code
.text$mn:000087EC ; Segment permissions: Read/Execute
.text$mn:000087EC _text$mn        segment para public 'CODE' use32
.text$mn:000087EC                 assume cs:_text$mn
.text$mn:000087EC                 ;org 87ECh
.text$mn:000087EC ; COMDAT (pick any)
.text$mn:000087EC                 assume es:nothing, ss:nothing, ds:_data, fs:nothing, gs:nothing
.text$mn:000087EC
.text$mn:000087EC ; =============== S U B R O U T I N E =======================================
.text$mn:000087EC
.text$mn:000087EC ; Attributes: bp-based frame
.text$mn:000087EC
.text$mn:000087EC ; public: unsigned int __thiscall std::_Wrap_alloc<class std::allocator<wchar_t const *>>::max_size(void)const
.text$mn:000087EC                 public ?max_size@?$_Wrap_alloc@V?$allocator@PB_W@std@@@std@@QBEIXZ
.text$mn:000087EC ?max_size@?$_Wrap_alloc@V?$allocator@PB_W@std@@@std@@QBEIXZ proc near
.text$mn:000087EC                                         ; CODE XREF: std::vector<wchar_t const *,std::allocator<wchar_t const *>>::max_size(void)+17p
.text$mn:000087EC
.text$mn:000087EC var_4           = dword ptr -4
.text$mn:000087EC
.text$mn:000087EC                 push    ebp
.text$mn:000087ED                 mov     ebp, esp
.text$mn:000087EF                 push    ecx
.text$mn:000087F0                 mov     [ebp+var_4], ecx
.text$mn:000087F3                 mov     eax, [ebp+var_4]
.text$mn:000087F6                 push    eax
.text$mn:000087F7                 call    ?max_size@?$allocator_traits@V?$allocator@PB_W@std@@@std@@SAIABV?$allocator@PB_W@2@@Z ; std::allocator_traits<std::allocator<wchar_t const *>>::max_size(std::allocator<wchar_t const *> const &)
.text$mn:000087FC                 add     esp, 4
.text$mn:000087FF                 mov     esp, ebp
.text$mn:00008801                 pop     ebp
.text$mn:00008802                 retn
.text$mn:00008802 ?max_size@?$_Wrap_alloc@V?$allocator@PB_W@std@@@std@@QBEIXZ endp
.text$mn:00008802
.text$mn:00008802 ; ---------------------------------------------------------------------------
.text$mn:00008803                 align 4
.text$mn:00008803 _text$mn        ends
.text$mn:00008803
.text$mn:00008804 ; ===========================================================================
.text$mn:00008804
.text$mn:00008804 ; Segment type: Pure code
.text$mn:00008804 ; Segment permissions: Read/Execute
.text$mn:00008804 _text$mn        segment para public 'CODE' use32
.text$mn:00008804                 assume cs:_text$mn
.text$mn:00008804                 ;org 8804h
.text$mn:00008804 ; COMDAT (pick any)
.text$mn:00008804                 assume es:nothing, ss:nothing, ds:_data, fs:nothing, gs:nothing
.text$mn:00008804
.text$mn:00008804 ; =============== S U B R O U T I N E =======================================
.text$mn:00008804
.text$mn:00008804 ; Attributes: bp-based frame
.text$mn:00008804
.text$mn:00008804 ; public: unsigned int __thiscall std::_Wrap_alloc<class std::allocator<struct FunctionValues>>::max_size(void)const
.text$mn:00008804                 public ?max_size@?$_Wrap_alloc@V?$allocator@UFunctionValues@@@std@@@std@@QBEIXZ
.text$mn:00008804 ?max_size@?$_Wrap_alloc@V?$allocator@UFunctionValues@@@std@@@std@@QBEIXZ proc near
.text$mn:00008804                                         ; CODE XREF: std::vector<FunctionValues,std::allocator<FunctionValues>>::max_size(void)+17p
.text$mn:00008804
.text$mn:00008804 var_4           = dword ptr -4
.text$mn:00008804
.text$mn:00008804                 push    ebp
.text$mn:00008805                 mov     ebp, esp
.text$mn:00008807                 push    ecx
.text$mn:00008808                 mov     [ebp+var_4], ecx
.text$mn:0000880B                 mov     eax, [ebp+var_4]
.text$mn:0000880E                 push    eax
.text$mn:0000880F                 call    ?max_size@?$allocator_traits@V?$allocator@UFunctionValues@@@std@@@std@@SAIABV?$allocator@UFunctionValues@@@2@@Z ; std::allocator_traits<std::allocator<FunctionValues>>::max_size(std::allocator<FunctionValues> const &)
.text$mn:00008814                 add     esp, 4
.text$mn:00008817                 mov     esp, ebp
.text$mn:00008819                 pop     ebp
.text$mn:0000881A                 retn
.text$mn:0000881A ?max_size@?$_Wrap_alloc@V?$allocator@UFunctionValues@@@std@@@std@@QBEIXZ endp
.text$mn:0000881A
.text$mn:0000881A ; ---------------------------------------------------------------------------
.text$mn:0000881B                 align 4
.text$mn:0000881B _text$mn        ends
.text$mn:0000881B
.text$mn:0000881C ; ===========================================================================
.text$mn:0000881C
.text$mn:0000881C ; Segment type: Pure code
.text$mn:0000881C ; Segment permissions: Read/Execute
.text$mn:0000881C _text$mn        segment para public 'CODE' use32
.text$mn:0000881C                 assume cs:_text$mn
.text$mn:0000881C                 ;org 881Ch
.text$mn:0000881C ; COMDAT (pick any)
.text$mn:0000881C                 assume es:nothing, ss:nothing, ds:_data, fs:nothing, gs:nothing
.text$mn:0000881C
.text$mn:0000881C ; =============== S U B R O U T I N E =======================================
.text$mn:0000881C
.text$mn:0000881C ; Attributes: bp-based frame
.text$mn:0000881C
.text$mn:0000881C ; public: unsigned int __thiscall std::_Wrap_alloc<class std::allocator<struct Token>>::max_size(void)const
.text$mn:0000881C                 public ?max_size@?$_Wrap_alloc@V?$allocator@UToken@@@std@@@std@@QBEIXZ
.text$mn:0000881C ?max_size@?$_Wrap_alloc@V?$allocator@UToken@@@std@@@std@@QBEIXZ proc near
.text$mn:0000881C                                         ; CODE XREF: std::vector<Token,std::allocator<Token>>::max_size(void)+17p
.text$mn:0000881C
.text$mn:0000881C var_4           = dword ptr -4
.text$mn:0000881C
.text$mn:0000881C                 push    ebp
.text$mn:0000881D                 mov     ebp, esp
.text$mn:0000881F                 push    ecx
.text$mn:00008820                 mov     [ebp+var_4], ecx
.text$mn:00008823                 mov     eax, [ebp+var_4]
.text$mn:00008826                 push    eax
.text$mn:00008827                 call    ?max_size@?$allocator_traits@V?$allocator@UToken@@@std@@@std@@SAIABV?$allocator@UToken@@@2@@Z ; std::allocator_traits<std::allocator<Token>>::max_size(std::allocator<Token> const &)
.text$mn:0000882C                 add     esp, 4
.text$mn:0000882F                 mov     esp, ebp
.text$mn:00008831                 pop     ebp
.text$mn:00008832                 retn
.text$mn:00008832 ?max_size@?$_Wrap_alloc@V?$allocator@UToken@@@std@@@std@@QBEIXZ endp
.text$mn:00008832
.text$mn:00008832 ; ---------------------------------------------------------------------------
.text$mn:00008833                 align 4
.text$mn:00008833 _text$mn        ends
.text$mn:00008833
.text$mn:00008834 ; ===========================================================================
.text$mn:00008834
.text$mn:00008834 ; Segment type: Pure code
.text$mn:00008834 ; Segment permissions: Read/Execute
.text$mn:00008834 _text$mn        segment para public 'CODE' use32
.text$mn:00008834                 assume cs:_text$mn
.text$mn:00008834                 ;org 8834h
.text$mn:00008834 ; COMDAT (pick any)
.text$mn:00008834                 assume es:nothing, ss:nothing, ds:_data, fs:nothing, gs:nothing
.text$mn:00008834
.text$mn:00008834 ; =============== S U B R O U T I N E =======================================
.text$mn:00008834
.text$mn:00008834 ; Attributes: bp-based frame
.text$mn:00008834
.text$mn:00008834 ; public: unsigned int __thiscall std::_Wrap_alloc<class std::allocator<class std::vector<wchar_t const *, class std::allocator<wchar_t const *>>>>::max_size(void)const
.text$mn:00008834                 public ?max_size@?$_Wrap_alloc@V?$allocator@V?$vector@PB_WV?$allocator@PB_W@std@@@std@@@std@@@std@@QBEIXZ
.text$mn:00008834 ?max_size@?$_Wrap_alloc@V?$allocator@V?$vector@PB_WV?$allocator@PB_W@std@@@std@@@std@@@std@@QBEIXZ proc near
.text$mn:00008834                                         ; CODE XREF: std::vector<std::vector<wchar_t const *,std::allocator<wchar_t const *>>,std::allocator<std::vector<wchar_t const *,std::allocator<wchar_t const *>>>>::max_size(void)+17p
.text$mn:00008834
.text$mn:00008834 var_4           = dword ptr -4
.text$mn:00008834
.text$mn:00008834                 push    ebp
.text$mn:00008835                 mov     ebp, esp
.text$mn:00008837                 push    ecx
.text$mn:00008838                 mov     [ebp+var_4], ecx
.text$mn:0000883B                 mov     eax, [ebp+var_4]
.text$mn:0000883E                 push    eax
.text$mn:0000883F                 call    ?max_size@?$allocator_traits@V?$allocator@V?$vector@PB_WV?$allocator@PB_W@std@@@std@@@std@@@std@@SAIABV?$allocator@V?$vector@PB_WV?$allocator@PB_W@std@@@std@@@2@@Z ; std::allocator_traits<std::allocator<std::vector<wchar_t const *,std::allocator<wchar_t const *>>>>::max_size(std::allocator<std::vector<wchar_t const *,std::allocator<wchar_t const *>>> const &)
.text$mn:00008844                 add     esp, 4
.text$mn:00008847                 mov     esp, ebp
.text$mn:00008849                 pop     ebp
.text$mn:0000884A                 retn
.text$mn:0000884A ?max_size@?$_Wrap_alloc@V?$allocator@V?$vector@PB_WV?$allocator@PB_W@std@@@std@@@std@@@std@@QBEIXZ endp
.text$mn:0000884A
.text$mn:0000884A ; ---------------------------------------------------------------------------
.text$mn:0000884B                 align 4
.text$mn:0000884B _text$mn        ends
.text$mn:0000884B
.text$mn:0000884C ; ===========================================================================
.text$mn:0000884C
.text$mn:0000884C ; Segment type: Pure code
.text$mn:0000884C ; Segment permissions: Read/Execute
.text$mn:0000884C _text$mn        segment para public 'CODE' use32
.text$mn:0000884C                 assume cs:_text$mn
.text$mn:0000884C                 ;org 884Ch
.text$mn:0000884C ; COMDAT (pick any)
.text$mn:0000884C                 assume es:nothing, ss:nothing, ds:_data, fs:nothing, gs:nothing
.text$mn:0000884C
.text$mn:0000884C ; =============== S U B R O U T I N E =======================================
.text$mn:0000884C
.text$mn:0000884C ; Attributes: bp-based frame
.text$mn:0000884C
.text$mn:0000884C ; public: unsigned int __thiscall std::allocator<char>::max_size(void)const
.text$mn:0000884C                 public ?max_size@?$allocator@D@std@@QBEIXZ
.text$mn:0000884C ?max_size@?$allocator@D@std@@QBEIXZ proc near
.text$mn:0000884C                                         ; CODE XREF: std::allocator_traits<std::allocator<char>>::max_size(std::allocator<char> const &)+6p
.text$mn:0000884C
.text$mn:0000884C var_4           = dword ptr -4
.text$mn:0000884C
.text$mn:0000884C                 push    ebp
.text$mn:0000884D                 mov     ebp, esp
.text$mn:0000884F                 push    ecx
.text$mn:00008850                 mov     [ebp+var_4], ecx
.text$mn:00008853                 or      eax, 0FFFFFFFFh
.text$mn:00008856                 mov     esp, ebp
.text$mn:00008858                 pop     ebp
.text$mn:00008859                 retn
.text$mn:00008859 ?max_size@?$allocator@D@std@@QBEIXZ endp
.text$mn:00008859
.text$mn:00008859 ; ---------------------------------------------------------------------------
.text$mn:0000885A                 align 4
.text$mn:0000885A _text$mn        ends
.text$mn:0000885A
.text$mn:0000885C ; ===========================================================================
.text$mn:0000885C
.text$mn:0000885C ; Segment type: Pure code
.text$mn:0000885C ; Segment permissions: Read/Execute
.text$mn:0000885C _text$mn        segment para public 'CODE' use32
.text$mn:0000885C                 assume cs:_text$mn
.text$mn:0000885C                 ;org 885Ch
.text$mn:0000885C ; COMDAT (pick any)
.text$mn:0000885C                 assume es:nothing, ss:nothing, ds:_data, fs:nothing, gs:nothing
.text$mn:0000885C
.text$mn:0000885C ; =============== S U B R O U T I N E =======================================
.text$mn:0000885C
.text$mn:0000885C ; Attributes: bp-based frame
.text$mn:0000885C
.text$mn:0000885C ; public: unsigned int __thiscall std::allocator<wchar_t const *>::max_size(void)const
.text$mn:0000885C                 public ?max_size@?$allocator@PB_W@std@@QBEIXZ
.text$mn:0000885C ?max_size@?$allocator@PB_W@std@@QBEIXZ proc near
.text$mn:0000885C                                         ; CODE XREF: std::allocator_traits<std::allocator<wchar_t const *>>::max_size(std::allocator<wchar_t const *> const &)+6p
.text$mn:0000885C
.text$mn:0000885C var_4           = dword ptr -4
.text$mn:0000885C
.text$mn:0000885C                 push    ebp
.text$mn:0000885D                 mov     ebp, esp
.text$mn:0000885F                 push    ecx
.text$mn:00008860                 mov     [ebp+var_4], ecx
.text$mn:00008863                 mov     eax, 3FFFFFFFh
.text$mn:00008868                 mov     esp, ebp
.text$mn:0000886A                 pop     ebp
.text$mn:0000886B                 retn
.text$mn:0000886B ?max_size@?$allocator@PB_W@std@@QBEIXZ endp
.text$mn:0000886B
.text$mn:0000886B _text$mn        ends
.text$mn:0000886B
.text$mn:0000886C ; ===========================================================================
.text$mn:0000886C
.text$mn:0000886C ; Segment type: Pure code
.text$mn:0000886C ; Segment permissions: Read/Execute
.text$mn:0000886C _text$mn        segment para public 'CODE' use32
.text$mn:0000886C                 assume cs:_text$mn
.text$mn:0000886C                 ;org 886Ch
.text$mn:0000886C ; COMDAT (pick any)
.text$mn:0000886C                 assume es:nothing, ss:nothing, ds:_data, fs:nothing, gs:nothing
.text$mn:0000886C
.text$mn:0000886C ; =============== S U B R O U T I N E =======================================
.text$mn:0000886C
.text$mn:0000886C ; Attributes: bp-based frame
.text$mn:0000886C
.text$mn:0000886C ; public: unsigned int __thiscall std::allocator<struct FunctionValues>::max_size(void)const
.text$mn:0000886C                 public ?max_size@?$allocator@UFunctionValues@@@std@@QBEIXZ
.text$mn:0000886C ?max_size@?$allocator@UFunctionValues@@@std@@QBEIXZ proc near
.text$mn:0000886C                                         ; CODE XREF: std::allocator_traits<std::allocator<FunctionValues>>::max_size(std::allocator<FunctionValues> const &)+6p
.text$mn:0000886C
.text$mn:0000886C var_4           = dword ptr -4
.text$mn:0000886C
.text$mn:0000886C                 push    ebp
.text$mn:0000886D                 mov     ebp, esp
.text$mn:0000886F                 push    ecx
.text$mn:00008870                 mov     [ebp+var_4], ecx
.text$mn:00008873                 mov     eax, 0FFFFFFFh
.text$mn:00008878                 mov     esp, ebp
.text$mn:0000887A                 pop     ebp
.text$mn:0000887B                 retn
.text$mn:0000887B ?max_size@?$allocator@UFunctionValues@@@std@@QBEIXZ endp
.text$mn:0000887B
.text$mn:0000887B _text$mn        ends
.text$mn:0000887B
.text$mn:0000887C ; ===========================================================================
.text$mn:0000887C
.text$mn:0000887C ; Segment type: Pure code
.text$mn:0000887C ; Segment permissions: Read/Execute
.text$mn:0000887C _text$mn        segment para public 'CODE' use32
.text$mn:0000887C                 assume cs:_text$mn
.text$mn:0000887C                 ;org 887Ch
.text$mn:0000887C ; COMDAT (pick any)
.text$mn:0000887C                 assume es:nothing, ss:nothing, ds:_data, fs:nothing, gs:nothing
.text$mn:0000887C
.text$mn:0000887C ; =============== S U B R O U T I N E =======================================
.text$mn:0000887C
.text$mn:0000887C ; Attributes: bp-based frame
.text$mn:0000887C
.text$mn:0000887C ; public: unsigned int __thiscall std::allocator<struct Token>::max_size(void)const
.text$mn:0000887C                 public ?max_size@?$allocator@UToken@@@std@@QBEIXZ
.text$mn:0000887C ?max_size@?$allocator@UToken@@@std@@QBEIXZ proc near
.text$mn:0000887C                                         ; CODE XREF: std::allocator_traits<std::allocator<Token>>::max_size(std::allocator<Token> const &)+6p
.text$mn:0000887C
.text$mn:0000887C var_4           = dword ptr -4
.text$mn:0000887C
.text$mn:0000887C                 push    ebp
.text$mn:0000887D                 mov     ebp, esp
.text$mn:0000887F                 push    ecx
.text$mn:00008880                 mov     [ebp+var_4], ecx
.text$mn:00008883                 mov     eax, 15555555h
.text$mn:00008888                 mov     esp, ebp
.text$mn:0000888A                 pop     ebp
.text$mn:0000888B                 retn
.text$mn:0000888B ?max_size@?$allocator@UToken@@@std@@QBEIXZ endp
.text$mn:0000888B
.text$mn:0000888B _text$mn        ends
.text$mn:0000888B
.text$mn:0000888C ; ===========================================================================
.text$mn:0000888C
.text$mn:0000888C ; Segment type: Pure code
.text$mn:0000888C ; Segment permissions: Read/Execute
.text$mn:0000888C _text$mn        segment para public 'CODE' use32
.text$mn:0000888C                 assume cs:_text$mn
.text$mn:0000888C                 ;org 888Ch
.text$mn:0000888C ; COMDAT (pick any)
.text$mn:0000888C                 assume es:nothing, ss:nothing, ds:_data, fs:nothing, gs:nothing
.text$mn:0000888C
.text$mn:0000888C ; =============== S U B R O U T I N E =======================================
.text$mn:0000888C
.text$mn:0000888C ; Attributes: bp-based frame
.text$mn:0000888C
.text$mn:0000888C ; public: unsigned int __thiscall std::allocator<class std::vector<wchar_t const *, class std::allocator<wchar_t const *>>>::max_size(void)const
.text$mn:0000888C                 public ?max_size@?$allocator@V?$vector@PB_WV?$allocator@PB_W@std@@@std@@@std@@QBEIXZ
.text$mn:0000888C ?max_size@?$allocator@V?$vector@PB_WV?$allocator@PB_W@std@@@std@@@std@@QBEIXZ proc near
.text$mn:0000888C                                         ; CODE XREF: std::allocator_traits<std::allocator<std::vector<wchar_t const *,std::allocator<wchar_t const *>>>>::max_size(std::allocator<std::vector<wchar_t const *,std::allocator<wchar_t const *>>> const &)+6p
.text$mn:0000888C
.text$mn:0000888C var_4           = dword ptr -4
.text$mn:0000888C
.text$mn:0000888C                 push    ebp
.text$mn:0000888D                 mov     ebp, esp
.text$mn:0000888F                 push    ecx
.text$mn:00008890                 mov     [ebp+var_4], ecx
.text$mn:00008893                 mov     eax, 0FFFFFFFh
.text$mn:00008898                 mov     esp, ebp
.text$mn:0000889A                 pop     ebp
.text$mn:0000889B                 retn
.text$mn:0000889B ?max_size@?$allocator@V?$vector@PB_WV?$allocator@PB_W@std@@@std@@@std@@QBEIXZ endp
.text$mn:0000889B
.text$mn:0000889B _text$mn        ends
.text$mn:0000889B
.text$mn:0000889C ; ===========================================================================
.text$mn:0000889C
.text$mn:0000889C ; Segment type: Pure code
.text$mn:0000889C ; Segment permissions: Read/Execute
.text$mn:0000889C _text$mn        segment para public 'CODE' use32
.text$mn:0000889C                 assume cs:_text$mn
.text$mn:0000889C                 ;org 889Ch
.text$mn:0000889C ; COMDAT (pick any)
.text$mn:0000889C                 assume es:nothing, ss:nothing, ds:_data, fs:nothing, gs:nothing
.text$mn:0000889C
.text$mn:0000889C ; =============== S U B R O U T I N E =======================================
.text$mn:0000889C
.text$mn:0000889C ; Attributes: bp-based frame
.text$mn:0000889C
.text$mn:0000889C ; public: static unsigned int __cdecl std::allocator_traits<class std::allocator<char>>::max_size(class std::allocator<char> const &)
.text$mn:0000889C                 public ?max_size@?$allocator_traits@V?$allocator@D@std@@@std@@SAIABV?$allocator@D@2@@Z
.text$mn:0000889C ?max_size@?$allocator_traits@V?$allocator@D@std@@@std@@SAIABV?$allocator@D@2@@Z proc near
.text$mn:0000889C                                         ; CODE XREF: std::_Wrap_alloc<std::allocator<char>>::max_size(void)+Bp
.text$mn:0000889C
.text$mn:0000889C arg_0           = dword ptr  8
.text$mn:0000889C
.text$mn:0000889C                 push    ebp
.text$mn:0000889D                 mov     ebp, esp
.text$mn:0000889F                 mov     ecx, [ebp+arg_0]
.text$mn:000088A2                 call    ?max_size@?$allocator@D@std@@QBEIXZ ; std::allocator<char>::max_size(void)
.text$mn:000088A7                 pop     ebp
.text$mn:000088A8                 retn
.text$mn:000088A8 ?max_size@?$allocator_traits@V?$allocator@D@std@@@std@@SAIABV?$allocator@D@2@@Z endp
.text$mn:000088A8
.text$mn:000088A8 ; ---------------------------------------------------------------------------
.text$mn:000088A9                 align 4
.text$mn:000088A9 _text$mn        ends
.text$mn:000088A9
.text$mn:000088AC ; ===========================================================================
.text$mn:000088AC
.text$mn:000088AC ; Segment type: Pure code
.text$mn:000088AC ; Segment permissions: Read/Execute
.text$mn:000088AC _text$mn        segment para public 'CODE' use32
.text$mn:000088AC                 assume cs:_text$mn
.text$mn:000088AC                 ;org 88ACh
.text$mn:000088AC ; COMDAT (pick any)
.text$mn:000088AC                 assume es:nothing, ss:nothing, ds:_data, fs:nothing, gs:nothing
.text$mn:000088AC
.text$mn:000088AC ; =============== S U B R O U T I N E =======================================
.text$mn:000088AC
.text$mn:000088AC ; Attributes: bp-based frame
.text$mn:000088AC
.text$mn:000088AC ; public: static unsigned int __cdecl std::allocator_traits<class std::allocator<wchar_t const *>>::max_size(class std::allocator<wchar_t const *> const &)
.text$mn:000088AC                 public ?max_size@?$allocator_traits@V?$allocator@PB_W@std@@@std@@SAIABV?$allocator@PB_W@2@@Z
.text$mn:000088AC ?max_size@?$allocator_traits@V?$allocator@PB_W@std@@@std@@SAIABV?$allocator@PB_W@2@@Z proc near
.text$mn:000088AC                                         ; CODE XREF: std::_Wrap_alloc<std::allocator<wchar_t const *>>::max_size(void)+Bp
.text$mn:000088AC
.text$mn:000088AC arg_0           = dword ptr  8
.text$mn:000088AC
.text$mn:000088AC                 push    ebp
.text$mn:000088AD                 mov     ebp, esp
.text$mn:000088AF                 mov     ecx, [ebp+arg_0]
.text$mn:000088B2                 call    ?max_size@?$allocator@PB_W@std@@QBEIXZ ; std::allocator<wchar_t const *>::max_size(void)
.text$mn:000088B7                 pop     ebp
.text$mn:000088B8                 retn
.text$mn:000088B8 ?max_size@?$allocator_traits@V?$allocator@PB_W@std@@@std@@SAIABV?$allocator@PB_W@2@@Z endp
.text$mn:000088B8
.text$mn:000088B8 ; ---------------------------------------------------------------------------
.text$mn:000088B9                 align 4
.text$mn:000088B9 _text$mn        ends
.text$mn:000088B9
.text$mn:000088BC ; ===========================================================================
.text$mn:000088BC
.text$mn:000088BC ; Segment type: Pure code
.text$mn:000088BC ; Segment permissions: Read/Execute
.text$mn:000088BC _text$mn        segment para public 'CODE' use32
.text$mn:000088BC                 assume cs:_text$mn
.text$mn:000088BC                 ;org 88BCh
.text$mn:000088BC ; COMDAT (pick any)
.text$mn:000088BC                 assume es:nothing, ss:nothing, ds:_data, fs:nothing, gs:nothing
.text$mn:000088BC
.text$mn:000088BC ; =============== S U B R O U T I N E =======================================
.text$mn:000088BC
.text$mn:000088BC ; Attributes: bp-based frame
.text$mn:000088BC
.text$mn:000088BC ; public: static unsigned int __cdecl std::allocator_traits<class std::allocator<struct FunctionValues>>::max_size(class std::allocator<struct FunctionValues> const &)
.text$mn:000088BC                 public ?max_size@?$allocator_traits@V?$allocator@UFunctionValues@@@std@@@std@@SAIABV?$allocator@UFunctionValues@@@2@@Z
.text$mn:000088BC ?max_size@?$allocator_traits@V?$allocator@UFunctionValues@@@std@@@std@@SAIABV?$allocator@UFunctionValues@@@2@@Z proc near
.text$mn:000088BC                                         ; CODE XREF: std::_Wrap_alloc<std::allocator<FunctionValues>>::max_size(void)+Bp
.text$mn:000088BC
.text$mn:000088BC arg_0           = dword ptr  8
.text$mn:000088BC
.text$mn:000088BC                 push    ebp
.text$mn:000088BD                 mov     ebp, esp
.text$mn:000088BF                 mov     ecx, [ebp+arg_0]
.text$mn:000088C2                 call    ?max_size@?$allocator@UFunctionValues@@@std@@QBEIXZ ; std::allocator<FunctionValues>::max_size(void)
.text$mn:000088C7                 pop     ebp
.text$mn:000088C8                 retn
.text$mn:000088C8 ?max_size@?$allocator_traits@V?$allocator@UFunctionValues@@@std@@@std@@SAIABV?$allocator@UFunctionValues@@@2@@Z endp
.text$mn:000088C8
.text$mn:000088C8 ; ---------------------------------------------------------------------------
.text$mn:000088C9                 align 4
.text$mn:000088C9 _text$mn        ends
.text$mn:000088C9
.text$mn:000088CC ; ===========================================================================
.text$mn:000088CC
.text$mn:000088CC ; Segment type: Pure code
.text$mn:000088CC ; Segment permissions: Read/Execute
.text$mn:000088CC _text$mn        segment para public 'CODE' use32
.text$mn:000088CC                 assume cs:_text$mn
.text$mn:000088CC                 ;org 88CCh
.text$mn:000088CC ; COMDAT (pick any)
.text$mn:000088CC                 assume es:nothing, ss:nothing, ds:_data, fs:nothing, gs:nothing
.text$mn:000088CC
.text$mn:000088CC ; =============== S U B R O U T I N E =======================================
.text$mn:000088CC
.text$mn:000088CC ; Attributes: bp-based frame
.text$mn:000088CC
.text$mn:000088CC ; public: static unsigned int __cdecl std::allocator_traits<class std::allocator<struct Token>>::max_size(class std::allocator<struct Token> const &)
.text$mn:000088CC                 public ?max_size@?$allocator_traits@V?$allocator@UToken@@@std@@@std@@SAIABV?$allocator@UToken@@@2@@Z
.text$mn:000088CC ?max_size@?$allocator_traits@V?$allocator@UToken@@@std@@@std@@SAIABV?$allocator@UToken@@@2@@Z proc near
.text$mn:000088CC                                         ; CODE XREF: std::_Wrap_alloc<std::allocator<Token>>::max_size(void)+Bp
.text$mn:000088CC
.text$mn:000088CC arg_0           = dword ptr  8
.text$mn:000088CC
.text$mn:000088CC                 push    ebp
.text$mn:000088CD                 mov     ebp, esp
.text$mn:000088CF                 mov     ecx, [ebp+arg_0]
.text$mn:000088D2                 call    ?max_size@?$allocator@UToken@@@std@@QBEIXZ ; std::allocator<Token>::max_size(void)
.text$mn:000088D7                 pop     ebp
.text$mn:000088D8                 retn
.text$mn:000088D8 ?max_size@?$allocator_traits@V?$allocator@UToken@@@std@@@std@@SAIABV?$allocator@UToken@@@2@@Z endp
.text$mn:000088D8
.text$mn:000088D8 ; ---------------------------------------------------------------------------
.text$mn:000088D9                 align 4
.text$mn:000088D9 _text$mn        ends
.text$mn:000088D9
.text$mn:000088DC ; ===========================================================================
.text$mn:000088DC
.text$mn:000088DC ; Segment type: Pure code
.text$mn:000088DC ; Segment permissions: Read/Execute
.text$mn:000088DC _text$mn        segment para public 'CODE' use32
.text$mn:000088DC                 assume cs:_text$mn
.text$mn:000088DC                 ;org 88DCh
.text$mn:000088DC ; COMDAT (pick any)
.text$mn:000088DC                 assume es:nothing, ss:nothing, ds:_data, fs:nothing, gs:nothing
.text$mn:000088DC
.text$mn:000088DC ; =============== S U B R O U T I N E =======================================
.text$mn:000088DC
.text$mn:000088DC ; Attributes: bp-based frame
.text$mn:000088DC
.text$mn:000088DC ; public: static unsigned int __cdecl std::allocator_traits<class std::allocator<class std::vector<wchar_t const *, class std::allocator<wchar_t const *>>>>::max_size(class std::allocator<class std::vector<wchar_t const *, class std::allocator<wchar_t const *>>> const &)
.text$mn:000088DC                 public ?max_size@?$allocator_traits@V?$allocator@V?$vector@PB_WV?$allocator@PB_W@std@@@std@@@std@@@std@@SAIABV?$allocator@V?$vector@PB_WV?$allocator@PB_W@std@@@std@@@2@@Z
.text$mn:000088DC ?max_size@?$allocator_traits@V?$allocator@V?$vector@PB_WV?$allocator@PB_W@std@@@std@@@std@@@std@@SAIABV?$allocator@V?$vector@PB_WV?$allocator@PB_W@std@@@std@@@2@@Z proc near
.text$mn:000088DC                                         ; CODE XREF: std::_Wrap_alloc<std::allocator<std::vector<wchar_t const *,std::allocator<wchar_t const *>>>>::max_size(void)+Bp
.text$mn:000088DC
.text$mn:000088DC arg_0           = dword ptr  8
.text$mn:000088DC
.text$mn:000088DC                 push    ebp
.text$mn:000088DD                 mov     ebp, esp
.text$mn:000088DF                 mov     ecx, [ebp+arg_0]
.text$mn:000088E2                 call    ?max_size@?$allocator@V?$vector@PB_WV?$allocator@PB_W@std@@@std@@@std@@QBEIXZ ; std::allocator<std::vector<wchar_t const *,std::allocator<wchar_t const *>>>::max_size(void)
.text$mn:000088E7                 pop     ebp
.text$mn:000088E8                 retn
.text$mn:000088E8 ?max_size@?$allocator_traits@V?$allocator@V?$vector@PB_WV?$allocator@PB_W@std@@@std@@@std@@@std@@SAIABV?$allocator@V?$vector@PB_WV?$allocator@PB_W@std@@@std@@@2@@Z endp
.text$mn:000088E8
.text$mn:000088E8 ; ---------------------------------------------------------------------------
.text$mn:000088E9                 align 4
.text$mn:000088E9 _text$mn        ends
.text$mn:000088E9
.text$mn:000088EC ; ===========================================================================
.text$mn:000088EC
.text$mn:000088EC ; Segment type: Pure code
.text$mn:000088EC ; Segment permissions: Read/Execute
.text$mn:000088EC _text$mn        segment para public 'CODE' use32
.text$mn:000088EC                 assume cs:_text$mn
.text$mn:000088EC                 ;org 88ECh
.text$mn:000088EC ; COMDAT (pick any)
.text$mn:000088EC                 assume es:nothing, ss:nothing, ds:_data, fs:nothing, gs:nothing
.text$mn:000088EC
.text$mn:000088EC ; =============== S U B R O U T I N E =======================================
.text$mn:000088EC
.text$mn:000088EC ; Attributes: bp-based frame
.text$mn:000088EC
.text$mn:000088EC ; public: unsigned int __thiscall std::basic_string<char, struct std::char_traits<char>, class std::allocator<char>>::max_size(void)const
.text$mn:000088EC                 public ?max_size@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QBEIXZ
.text$mn:000088EC ?max_size@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QBEIXZ proc near
.text$mn:000088EC                                         ; CODE XREF: std::basic_string<char,std::char_traits<char>,std::allocator<char>>::_Copy(uint,uint)+3Bp
.text$mn:000088EC                                         ; std::basic_string<char,std::char_traits<char>,std::allocator<char>>::_Copy(uint,uint)+6Ap ...
.text$mn:000088EC
.text$mn:000088EC var_10          = dword ptr -10h
.text$mn:000088EC var_C           = dword ptr -0Ch
.text$mn:000088EC var_8           = dword ptr -8
.text$mn:000088EC var_1           = byte ptr -1
.text$mn:000088EC
.text$mn:000088EC                 push    ebp
.text$mn:000088ED                 mov     ebp, esp
.text$mn:000088EF                 sub     esp, 10h
.text$mn:000088F2                 mov     [ebp+var_10], ecx
.text$mn:000088F5                 lea     eax, [ebp+var_1]
.text$mn:000088F8                 push    eax
.text$mn:000088F9                 mov     ecx, [ebp+var_10]
.text$mn:000088FC                 call    ?_Getal@?$_String_alloc@$0A@U?$_String_base_types@DV?$allocator@D@std@@@std@@@std@@QBE?AU?$_Wrap_alloc@V?$allocator@D@std@@@2@XZ ; std::_String_alloc<0,std::_String_base_types<char,std::allocator<char>>>::_Getal(void)
.text$mn:00008901                 mov     ecx, eax
.text$mn:00008903                 call    ?max_size@?$_Wrap_alloc@V?$allocator@D@std@@@std@@QBEIXZ ; std::_Wrap_alloc<std::allocator<char>>::max_size(void)
.text$mn:00008908                 mov     [ebp+var_8], eax
.text$mn:0000890B                 cmp     [ebp+var_8], 1
.text$mn:0000890F                 ja      short loc_891A
.text$mn:00008911                 mov     [ebp+var_C], 1
.text$mn:00008918                 jmp     short loc_8923
.text$mn:0000891A ; ---------------------------------------------------------------------------
.text$mn:0000891A
.text$mn:0000891A loc_891A:                               ; CODE XREF: std::basic_string<char,std::char_traits<char>,std::allocator<char>>::max_size(void)+23j
.text$mn:0000891A                 mov     ecx, [ebp+var_8]
.text$mn:0000891D                 sub     ecx, 1
.text$mn:00008920                 mov     [ebp+var_C], ecx
.text$mn:00008923
.text$mn:00008923 loc_8923:                               ; CODE XREF: std::basic_string<char,std::char_traits<char>,std::allocator<char>>::max_size(void)+2Cj
.text$mn:00008923                 mov     eax, [ebp+var_C]
.text$mn:00008926                 mov     esp, ebp
.text$mn:00008928                 pop     ebp
.text$mn:00008929                 retn
.text$mn:00008929 ?max_size@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QBEIXZ endp
.text$mn:00008929
.text$mn:00008929 ; ---------------------------------------------------------------------------
.text$mn:0000892A                 align 4
.text$mn:0000892A _text$mn        ends
.text$mn:0000892A
.text$mn:0000892C ; ===========================================================================
.text$mn:0000892C
.text$mn:0000892C ; Segment type: Pure code
.text$mn:0000892C ; Segment permissions: Read/Execute
.text$mn:0000892C _text$mn        segment para public 'CODE' use32
.text$mn:0000892C                 assume cs:_text$mn
.text$mn:0000892C                 ;org 892Ch
.text$mn:0000892C ; COMDAT (pick any)
.text$mn:0000892C                 assume es:nothing, ss:nothing, ds:_data, fs:nothing, gs:nothing
.text$mn:0000892C
.text$mn:0000892C ; =============== S U B R O U T I N E =======================================
.text$mn:0000892C
.text$mn:0000892C ; Attributes: bp-based frame
.text$mn:0000892C
.text$mn:0000892C ; public: unsigned int __thiscall std::vector<wchar_t const *, class std::allocator<wchar_t const *>>::max_size(void)const
.text$mn:0000892C                 public ?max_size@?$vector@PB_WV?$allocator@PB_W@std@@@std@@QBEIXZ
.text$mn:0000892C ?max_size@?$vector@PB_WV?$allocator@PB_W@std@@@std@@QBEIXZ proc near
.text$mn:0000892C                                         ; CODE XREF: std::vector<wchar_t const *,std::allocator<wchar_t const *>>::_Buy(uint)+36p
.text$mn:0000892C                                         ; std::vector<wchar_t const *,std::allocator<wchar_t const *>>::_Grow_to(uint)+17p ...
.text$mn:0000892C
.text$mn:0000892C var_8           = dword ptr -8
.text$mn:0000892C var_1           = byte ptr -1
.text$mn:0000892C
.text$mn:0000892C                 push    ebp
.text$mn:0000892D                 mov     ebp, esp
.text$mn:0000892F                 sub     esp, 8
.text$mn:00008932                 mov     [ebp+var_8], ecx
.text$mn:00008935                 lea     eax, [ebp+var_1]
.text$mn:00008938                 push    eax
.text$mn:00008939                 mov     ecx, [ebp+var_8]
.text$mn:0000893C                 call    ?_Getal@?$_Vector_alloc@$0A@U?$_Vec_base_types@PB_WV?$allocator@PB_W@std@@@std@@@std@@QBE?AU?$_Wrap_alloc@V?$allocator@PB_W@std@@@2@XZ ; std::_Vector_alloc<0,std::_Vec_base_types<wchar_t const *,std::allocator<wchar_t const *>>>::_Getal(void)
.text$mn:00008941                 mov     ecx, eax
.text$mn:00008943                 call    ?max_size@?$_Wrap_alloc@V?$allocator@PB_W@std@@@std@@QBEIXZ ; std::_Wrap_alloc<std::allocator<wchar_t const *>>::max_size(void)
.text$mn:00008948                 mov     esp, ebp
.text$mn:0000894A                 pop     ebp
.text$mn:0000894B                 retn
.text$mn:0000894B ?max_size@?$vector@PB_WV?$allocator@PB_W@std@@@std@@QBEIXZ endp
.text$mn:0000894B
.text$mn:0000894B _text$mn        ends
.text$mn:0000894B
.text$mn:0000894C ; ===========================================================================
.text$mn:0000894C
.text$mn:0000894C ; Segment type: Pure code
.text$mn:0000894C ; Segment permissions: Read/Execute
.text$mn:0000894C _text$mn        segment para public 'CODE' use32
.text$mn:0000894C                 assume cs:_text$mn
.text$mn:0000894C                 ;org 894Ch
.text$mn:0000894C ; COMDAT (pick any)
.text$mn:0000894C                 assume es:nothing, ss:nothing, ds:_data, fs:nothing, gs:nothing
.text$mn:0000894C
.text$mn:0000894C ; =============== S U B R O U T I N E =======================================
.text$mn:0000894C
.text$mn:0000894C ; Attributes: bp-based frame
.text$mn:0000894C
.text$mn:0000894C ; public: unsigned int __thiscall std::vector<struct FunctionValues, class std::allocator<struct FunctionValues>>::max_size(void)const
.text$mn:0000894C                 public ?max_size@?$vector@UFunctionValues@@V?$allocator@UFunctionValues@@@std@@@std@@QBEIXZ
.text$mn:0000894C ?max_size@?$vector@UFunctionValues@@V?$allocator@UFunctionValues@@@std@@@std@@QBEIXZ proc near
.text$mn:0000894C                                         ; CODE XREF: std::vector<FunctionValues,std::allocator<FunctionValues>>::_Grow_to(uint)+17p
.text$mn:0000894C                                         ; std::vector<FunctionValues,std::allocator<FunctionValues>>::_Reserve(uint)+18p
.text$mn:0000894C
.text$mn:0000894C var_8           = dword ptr -8
.text$mn:0000894C var_1           = byte ptr -1
.text$mn:0000894C
.text$mn:0000894C                 push    ebp
.text$mn:0000894D                 mov     ebp, esp
.text$mn:0000894F                 sub     esp, 8
.text$mn:00008952                 mov     [ebp+var_8], ecx
.text$mn:00008955                 lea     eax, [ebp+var_1]
.text$mn:00008958                 push    eax
.text$mn:00008959                 mov     ecx, [ebp+var_8]
.text$mn:0000895C                 call    ?_Getal@?$_Vector_alloc@$0A@U?$_Vec_base_types@UFunctionValues@@V?$allocator@UFunctionValues@@@std@@@std@@@std@@QBE?AU?$_Wrap_alloc@V?$allocator@UFunctionValues@@@std@@@2@XZ ; std::_Vector_alloc<0,std::_Vec_base_types<FunctionValues,std::allocator<FunctionValues>>>::_Getal(void)
.text$mn:00008961                 mov     ecx, eax
.text$mn:00008963                 call    ?max_size@?$_Wrap_alloc@V?$allocator@UFunctionValues@@@std@@@std@@QBEIXZ ; std::_Wrap_alloc<std::allocator<FunctionValues>>::max_size(void)
.text$mn:00008968                 mov     esp, ebp
.text$mn:0000896A                 pop     ebp
.text$mn:0000896B                 retn
.text$mn:0000896B ?max_size@?$vector@UFunctionValues@@V?$allocator@UFunctionValues@@@std@@@std@@QBEIXZ endp
.text$mn:0000896B
.text$mn:0000896B _text$mn        ends
.text$mn:0000896B
.text$mn:0000896C ; ===========================================================================
.text$mn:0000896C
.text$mn:0000896C ; Segment type: Pure code
.text$mn:0000896C ; Segment permissions: Read/Execute
.text$mn:0000896C _text$mn        segment para public 'CODE' use32
.text$mn:0000896C                 assume cs:_text$mn
.text$mn:0000896C                 ;org 896Ch
.text$mn:0000896C ; COMDAT (pick any)
.text$mn:0000896C                 assume es:nothing, ss:nothing, ds:_data, fs:nothing, gs:nothing
.text$mn:0000896C
.text$mn:0000896C ; =============== S U B R O U T I N E =======================================
.text$mn:0000896C
.text$mn:0000896C ; Attributes: bp-based frame
.text$mn:0000896C
.text$mn:0000896C ; public: unsigned int __thiscall std::vector<struct Token, class std::allocator<struct Token>>::max_size(void)const
.text$mn:0000896C                 public ?max_size@?$vector@UToken@@V?$allocator@UToken@@@std@@@std@@QBEIXZ
.text$mn:0000896C ?max_size@?$vector@UToken@@V?$allocator@UToken@@@std@@@std@@QBEIXZ proc near
.text$mn:0000896C                                         ; CODE XREF: std::vector<Token,std::allocator<Token>>::_Grow_to(uint)+17p
.text$mn:0000896C                                         ; std::vector<Token,std::allocator<Token>>::_Reserve(uint)+18p
.text$mn:0000896C
.text$mn:0000896C var_8           = dword ptr -8
.text$mn:0000896C var_1           = byte ptr -1
.text$mn:0000896C
.text$mn:0000896C                 push    ebp
.text$mn:0000896D                 mov     ebp, esp
.text$mn:0000896F                 sub     esp, 8
.text$mn:00008972                 mov     [ebp+var_8], ecx
.text$mn:00008975                 lea     eax, [ebp+var_1]
.text$mn:00008978                 push    eax
.text$mn:00008979                 mov     ecx, [ebp+var_8]
.text$mn:0000897C                 call    ?_Getal@?$_Vector_alloc@$0A@U?$_Vec_base_types@UToken@@V?$allocator@UToken@@@std@@@std@@@std@@QBE?AU?$_Wrap_alloc@V?$allocator@UToken@@@std@@@2@XZ ; std::_Vector_alloc<0,std::_Vec_base_types<Token,std::allocator<Token>>>::_Getal(void)
.text$mn:00008981                 mov     ecx, eax
.text$mn:00008983                 call    ?max_size@?$_Wrap_alloc@V?$allocator@UToken@@@std@@@std@@QBEIXZ ; std::_Wrap_alloc<std::allocator<Token>>::max_size(void)
.text$mn:00008988                 mov     esp, ebp
.text$mn:0000898A                 pop     ebp
.text$mn:0000898B                 retn
.text$mn:0000898B ?max_size@?$vector@UToken@@V?$allocator@UToken@@@std@@@std@@QBEIXZ endp
.text$mn:0000898B
.text$mn:0000898B _text$mn        ends
.text$mn:0000898B
.text$mn:0000898C ; ===========================================================================
.text$mn:0000898C
.text$mn:0000898C ; Segment type: Pure code
.text$mn:0000898C ; Segment permissions: Read/Execute
.text$mn:0000898C _text$mn        segment para public 'CODE' use32
.text$mn:0000898C                 assume cs:_text$mn
.text$mn:0000898C                 ;org 898Ch
.text$mn:0000898C ; COMDAT (pick any)
.text$mn:0000898C                 assume es:nothing, ss:nothing, ds:_data, fs:nothing, gs:nothing
.text$mn:0000898C
.text$mn:0000898C ; =============== S U B R O U T I N E =======================================
.text$mn:0000898C
.text$mn:0000898C ; Attributes: bp-based frame
.text$mn:0000898C
.text$mn:0000898C ; public: unsigned int __thiscall std::vector<class std::vector<wchar_t const *, class std::allocator<wchar_t const *>>, class std::allocator<class std::vector<wchar_t const *, class std::allocator<wchar_t const *>>>>::max_size(void)const
.text$mn:0000898C                 public ?max_size@?$vector@V?$vector@PB_WV?$allocator@PB_W@std@@@std@@V?$allocator@V?$vector@PB_WV?$allocator@PB_W@std@@@std@@@2@@std@@QBEIXZ
.text$mn:0000898C ?max_size@?$vector@V?$vector@PB_WV?$allocator@PB_W@std@@@std@@V?$allocator@V?$vector@PB_WV?$allocator@PB_W@std@@@std@@@2@@std@@QBEIXZ proc near
.text$mn:0000898C                                         ; CODE XREF: std::vector<std::vector<wchar_t const *,std::allocator<wchar_t const *>>,std::allocator<std::vector<wchar_t const *,std::allocator<wchar_t const *>>>>::_Grow_to(uint)+17p
.text$mn:0000898C                                         ; std::vector<std::vector<wchar_t const *,std::allocator<wchar_t const *>>,std::allocator<std::vector<wchar_t const *,std::allocator<wchar_t const *>>>>::_Reserve(uint)+18p
.text$mn:0000898C
.text$mn:0000898C var_8           = dword ptr -8
.text$mn:0000898C var_1           = byte ptr -1
.text$mn:0000898C
.text$mn:0000898C                 push    ebp
.text$mn:0000898D                 mov     ebp, esp
.text$mn:0000898F                 sub     esp, 8
.text$mn:00008992                 mov     [ebp+var_8], ecx
.text$mn:00008995                 lea     eax, [ebp+var_1]
.text$mn:00008998                 push    eax
.text$mn:00008999                 mov     ecx, [ebp+var_8]
.text$mn:0000899C                 call    ?_Getal@?$_Vector_alloc@$0A@U?$_Vec_base_types@V?$vector@PB_WV?$allocator@PB_W@std@@@std@@V?$allocator@V?$vector@PB_WV?$allocator@PB_W@std@@@std@@@2@@std@@@std@@QBE?AU?$_Wrap_alloc@V?$allocator@V?$vector@PB_WV?$allocator@PB_W@std@@@std@@@std@@@2@XZ ; std::_Vector_alloc<0,std::_Vec_base_types<std::vector<wchar_t const *,std::allocator<wchar_t const *>>,std::allocator<std::vector<wchar_t const *,std::allocator<wchar_t const *>>>>>::_Getal(void)
.text$mn:000089A1                 mov     ecx, eax
.text$mn:000089A3                 call    ?max_size@?$_Wrap_alloc@V?$allocator@V?$vector@PB_WV?$allocator@PB_W@std@@@std@@@std@@@std@@QBEIXZ ; std::_Wrap_alloc<std::allocator<std::vector<wchar_t const *,std::allocator<wchar_t const *>>>>::max_size(void)
.text$mn:000089A8                 mov     esp, ebp
.text$mn:000089AA                 pop     ebp
.text$mn:000089AB                 retn
.text$mn:000089AB ?max_size@?$vector@V?$vector@PB_WV?$allocator@PB_W@std@@@std@@V?$allocator@V?$vector@PB_WV?$allocator@PB_W@std@@@std@@@2@@std@@QBEIXZ endp
.text$mn:000089AB
.text$mn:000089AB _text$mn        ends
.text$mn:000089AB
.text$mn:000089AC ; ===========================================================================
.text$mn:000089AC
.text$mn:000089AC ; Segment type: Pure code
.text$mn:000089AC ; Segment permissions: Read/Execute
.text$mn:000089AC _text$mn        segment para public 'CODE' use32
.text$mn:000089AC                 assume cs:_text$mn
.text$mn:000089AC                 ;org 89ACh
.text$mn:000089AC ; COMDAT (pick any)
.text$mn:000089AC                 assume es:nothing, ss:nothing, ds:_data, fs:nothing, gs:nothing
.text$mn:000089AC
.text$mn:000089AC ; =============== S U B R O U T I N E =======================================
.text$mn:000089AC
.text$mn:000089AC ; Attributes: bp-based frame
.text$mn:000089AC
.text$mn:000089AC ; public: virtual class std::basic_string<char, struct std::char_traits<char>, class std::allocator<char>> __thiscall std::_Generic_error_category::message(int)const
.text$mn:000089AC                 public ?message@_Generic_error_category@std@@UBE?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@2@H@Z
.text$mn:000089AC ?message@_Generic_error_category@std@@UBE?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@2@H@Z proc near
.text$mn:000089AC                                         ; CODE XREF: std::_Iostream_error_category::message(int)+64p
.text$mn:000089AC                                         ; DATA XREF: .rdata:0000A400o
.text$mn:000089AC
.text$mn:000089AC var_1C          = dword ptr -1Ch
.text$mn:000089AC var_18          = dword ptr -18h
.text$mn:000089AC Str             = dword ptr -14h
.text$mn:000089AC var_10          = dword ptr -10h
.text$mn:000089AC var_C           = dword ptr -0Ch
.text$mn:000089AC var_4           = dword ptr -4
.text$mn:000089AC arg_0           = dword ptr  8
.text$mn:000089AC arg_4           = dword ptr  0Ch
.text$mn:000089AC
.text$mn:000089AC                 push    ebp
.text$mn:000089AD                 mov     ebp, esp
.text$mn:000089AF                 push    0FFFFFFFFh
.text$mn:000089B1                 push    offset __ehhandler$?message@_Generic_error_category@std@@UBE?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@2@H@Z
.text$mn:000089B6                 mov     eax, large fs:0
.text$mn:000089BC                 push    eax
.text$mn:000089BD                 sub     esp, 10h
.text$mn:000089C0                 mov     eax, dword ptr ds:___security_cookie
.text$mn:000089C5                 xor     eax, ebp
.text$mn:000089C7                 push    eax
.text$mn:000089C8                 lea     eax, [ebp+var_C]
.text$mn:000089CB                 mov     large fs:0, eax
.text$mn:000089D1                 mov     [ebp+var_1C], ecx
.text$mn:000089D4                 mov     [ebp+var_18], 0
.text$mn:000089DB                 mov     eax, [ebp+arg_4]
.text$mn:000089DE                 push    eax             ; int
.text$mn:000089DF                 call    ?_Syserror_map@std@@YAPBDH@Z ; std::_Syserror_map(int)
.text$mn:000089E4                 add     esp, 4
.text$mn:000089E7                 mov     [ebp+var_10], eax
.text$mn:000089EA                 cmp     [ebp+var_10], 0
.text$mn:000089EE                 jz      short loc_89F8
.text$mn:000089F0                 mov     ecx, [ebp+var_10]
.text$mn:000089F3                 mov     [ebp+Str], ecx
.text$mn:000089F6                 jmp     short loc_89FF
.text$mn:000089F8 ; ---------------------------------------------------------------------------
.text$mn:000089F8
.text$mn:000089F8 loc_89F8:                               ; CODE XREF: std::_Generic_error_category::message(int)+42j
.text$mn:000089F8                 mov     [ebp+Str], offset ??_C@_0O@BFJCFAAK@unknown?5error?$AA@ ; "unknown error"
.text$mn:000089FF
.text$mn:000089FF loc_89FF:                               ; CODE XREF: std::_Generic_error_category::message(int)+4Aj
.text$mn:000089FF                 mov     edx, [ebp+Str]
.text$mn:00008A02                 push    edx             ; Str
.text$mn:00008A03                 mov     ecx, [ebp+arg_0]
.text$mn:00008A06                 call    ??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@PBD@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char>>::basic_string<char,std::char_traits<char>,std::allocator<char>>(char const *)
.text$mn:00008A0B                 mov     [ebp+var_4], 0
.text$mn:00008A12                 mov     eax, [ebp+var_18]
.text$mn:00008A15                 or      eax, 1
.text$mn:00008A18                 mov     [ebp+var_18], eax
.text$mn:00008A1B                 mov     eax, [ebp+arg_0]
.text$mn:00008A1E                 mov     ecx, [ebp+var_C]
.text$mn:00008A21                 mov     large fs:0, ecx
.text$mn:00008A28                 pop     ecx
.text$mn:00008A29                 mov     esp, ebp
.text$mn:00008A2B                 pop     ebp
.text$mn:00008A2C                 retn    8
.text$mn:00008A2C ?message@_Generic_error_category@std@@UBE?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@2@H@Z endp
.text$mn:00008A2C
.text$mn:00008A2C ; ---------------------------------------------------------------------------
.text$mn:00008A2F                 align 10h
.text$mn:00008A2F _text$mn        ends
.text$mn:00008A2F
.text$x:00008A30 ; ===========================================================================
.text$x:00008A30
.text$x:00008A30 ; Segment type: Pure code
.text$x:00008A30 ; Segment permissions: Read/Execute
.text$x:00008A30 _text$x         segment para public 'CODE' use32
.text$x:00008A30                 assume cs:_text$x
.text$x:00008A30                 ;org 8A30h
.text$x:00008A30 ; COMDAT (pick associative to section at 89AC)
.text$x:00008A30                 assume es:nothing, ss:nothing, ds:_data, fs:nothing, gs:nothing
.text$x:00008A30
.text$x:00008A30 ; =============== S U B R O U T I N E =======================================
.text$x:00008A30
.text$x:00008A30
.text$x:00008A30 __unwindfunclet$?message@_Generic_error_category@std@@UBE?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@2@H@Z$0 proc near
.text$x:00008A30                                         ; DATA XREF: .xdata$x:000094C8o
.text$x:00008A30                 mov     eax, [ebp-18h]
.text$x:00008A33                 and     eax, 1
.text$x:00008A36                 jz      $LN6
.text$x:00008A3C                 and     dword ptr [ebp-18h], 0FFFFFFFEh
.text$x:00008A40                 mov     ecx, [ebp+8]
.text$x:00008A43                 jmp     ??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char>>::~basic_string<char,std::char_traits<char>,std::allocator<char>>(void)
.text$x:00008A48 ; ---------------------------------------------------------------------------
.text$x:00008A48
.text$x:00008A48 $LN6:                                   ; CODE XREF: __unwindfunclet$?message@_Generic_error_category@std@@UBE?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@2@H@Z$0+6j
.text$x:00008A48                 retn
.text$x:00008A48 __unwindfunclet$?message@_Generic_error_category@std@@UBE?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@2@H@Z$0 endp
.text$x:00008A48
.text$x:00008A49
.text$x:00008A49 ; =============== S U B R O U T I N E =======================================
.text$x:00008A49
.text$x:00008A49
.text$x:00008A49 __ehhandler$?message@_Generic_error_category@std@@UBE?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@2@H@Z proc near
.text$x:00008A49                                         ; DATA XREF: std::_Generic_error_category::message(int)+5o
.text$x:00008A49
.text$x:00008A49 arg_4           = dword ptr  8
.text$x:00008A49
.text$x:00008A49                 mov     edx, [esp+arg_4]
.text$x:00008A4D                 lea     eax, [edx+0Ch]
.text$x:00008A50                 mov     ecx, [edx-14h]
.text$x:00008A53                 xor     ecx, eax
.text$x:00008A55                 call    @__security_check_cookie@4 ; __security_check_cookie(x)
.text$x:00008A5A                 mov     eax, offset __ehfuncinfo$?message@_Generic_error_category@std@@UBE?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@2@H@Z
.text$x:00008A5F                 jmp     ___CxxFrameHandler3
.text$x:00008A5F __ehhandler$?message@_Generic_error_category@std@@UBE?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@2@H@Z endp
.text$x:00008A5F
.text$x:00008A5F _text$x         ends
.text$x:00008A5F
.text$mn:00008A64 ; ===========================================================================
.text$mn:00008A64
.text$mn:00008A64 ; Segment type: Pure code
.text$mn:00008A64 ; Segment permissions: Read/Execute
.text$mn:00008A64 _text$mn        segment para public 'CODE' use32
.text$mn:00008A64                 assume cs:_text$mn
.text$mn:00008A64                 ;org 8A64h
.text$mn:00008A64 ; COMDAT (pick any)
.text$mn:00008A64                 assume es:nothing, ss:nothing, ds:_data, fs:nothing, gs:nothing
.text$mn:00008A64
.text$mn:00008A64 ; =============== S U B R O U T I N E =======================================
.text$mn:00008A64
.text$mn:00008A64 ; Attributes: bp-based frame
.text$mn:00008A64
.text$mn:00008A64 ; public: virtual class std::basic_string<char, struct std::char_traits<char>, class std::allocator<char>> __thiscall std::_Iostream_error_category::message(int)const
.text$mn:00008A64                 public ?message@_Iostream_error_category@std@@UBE?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@2@H@Z
.text$mn:00008A64 ?message@_Iostream_error_category@std@@UBE?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@2@H@Z proc near
.text$mn:00008A64                                         ; DATA XREF: .rdata:0000A434o
.text$mn:00008A64
.text$mn:00008A64 var_14          = dword ptr -14h
.text$mn:00008A64 var_10          = dword ptr -10h
.text$mn:00008A64 var_C           = dword ptr -0Ch
.text$mn:00008A64 var_4           = dword ptr -4
.text$mn:00008A64 arg_0           = dword ptr  8
.text$mn:00008A64 arg_4           = dword ptr  0Ch
.text$mn:00008A64
.text$mn:00008A64                 push    ebp
.text$mn:00008A65                 mov     ebp, esp
.text$mn:00008A67                 push    0FFFFFFFFh
.text$mn:00008A69                 push    offset __ehhandler$?message@_Iostream_error_category@std@@UBE?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@2@H@Z
.text$mn:00008A6E                 mov     eax, large fs:0
.text$mn:00008A74                 push    eax
.text$mn:00008A75                 sub     esp, 8
.text$mn:00008A78                 mov     eax, dword ptr ds:___security_cookie
.text$mn:00008A7D                 xor     eax, ebp
.text$mn:00008A7F                 push    eax
.text$mn:00008A80                 lea     eax, [ebp+var_C]
.text$mn:00008A83                 mov     large fs:0, eax
.text$mn:00008A89                 mov     [ebp+var_14], ecx
.text$mn:00008A8C                 mov     [ebp+var_10], 0
.text$mn:00008A93                 cmp     [ebp+arg_4], 1
.text$mn:00008A97                 jnz     short loc_8ABD
.text$mn:00008A99                 push    offset ??_C@_0BG@PADBLCHM@iostream?5stream?5error?$AA@ ; "iostream stream error"
.text$mn:00008A9E                 mov     ecx, [ebp+arg_0]
.text$mn:00008AA1                 call    ??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@PBD@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char>>::basic_string<char,std::char_traits<char>,std::allocator<char>>(char const *)
.text$mn:00008AA6                 mov     [ebp+var_4], 0
.text$mn:00008AAD                 mov     eax, [ebp+var_10]
.text$mn:00008AB0                 or      eax, 1
.text$mn:00008AB3                 mov     [ebp+var_10], eax
.text$mn:00008AB6                 mov     eax, [ebp+arg_0]
.text$mn:00008AB9                 jmp     short loc_8AE0
.text$mn:00008ABB ; ---------------------------------------------------------------------------
.text$mn:00008ABB                 jmp     short loc_8AE0
.text$mn:00008ABD ; ---------------------------------------------------------------------------
.text$mn:00008ABD
.text$mn:00008ABD loc_8ABD:                               ; CODE XREF: std::_Iostream_error_category::message(int)+33j
.text$mn:00008ABD                 mov     ecx, [ebp+arg_4]
.text$mn:00008AC0                 push    ecx
.text$mn:00008AC1                 mov     edx, [ebp+arg_0]
.text$mn:00008AC4                 push    edx
.text$mn:00008AC5                 mov     ecx, [ebp+var_14]
.text$mn:00008AC8                 call    ?message@_Generic_error_category@std@@UBE?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@2@H@Z ; std::_Generic_error_category::message(int)
.text$mn:00008ACD                 mov     [ebp+var_4], 0
.text$mn:00008AD4                 mov     eax, [ebp+var_10]
.text$mn:00008AD7                 or      eax, 1
.text$mn:00008ADA                 mov     [ebp+var_10], eax
.text$mn:00008ADD                 mov     eax, [ebp+arg_0]
.text$mn:00008AE0
.text$mn:00008AE0 loc_8AE0:                               ; CODE XREF: std::_Iostream_error_category::message(int)+55j
.text$mn:00008AE0                                         ; std::_Iostream_error_category::message(int)+57j
.text$mn:00008AE0                 mov     ecx, [ebp+var_C]
.text$mn:00008AE3                 mov     large fs:0, ecx
.text$mn:00008AEA                 pop     ecx
.text$mn:00008AEB                 mov     esp, ebp
.text$mn:00008AED                 pop     ebp
.text$mn:00008AEE                 retn    8
.text$mn:00008AEE ?message@_Iostream_error_category@std@@UBE?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@2@H@Z endp
.text$mn:00008AEE
.text$mn:00008AEE ; ---------------------------------------------------------------------------
.text$mn:00008AF1                 align 4
.text$mn:00008AF1 _text$mn        ends
.text$mn:00008AF1
.text$x:00008AF4 ; ===========================================================================
.text$x:00008AF4
.text$x:00008AF4 ; Segment type: Pure code
.text$x:00008AF4 ; Segment permissions: Read/Execute
.text$x:00008AF4 _text$x         segment para public 'CODE' use32
.text$x:00008AF4                 assume cs:_text$x
.text$x:00008AF4                 ;org 8AF4h
.text$x:00008AF4 ; COMDAT (pick associative to section at 8A64)
.text$x:00008AF4                 assume es:nothing, ss:nothing, ds:_data, fs:nothing, gs:nothing
.text$x:00008AF4
.text$x:00008AF4 ; =============== S U B R O U T I N E =======================================
.text$x:00008AF4
.text$x:00008AF4
.text$x:00008AF4 __unwindfunclet$?message@_Iostream_error_category@std@@UBE?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@2@H@Z$0 proc near
.text$x:00008AF4                                         ; DATA XREF: .xdata$x:0000954Co
.text$x:00008AF4                 mov     eax, [ebp-10h]
.text$x:00008AF7                 and     eax, 1
.text$x:00008AFA                 jz      $LN6_0
.text$x:00008B00                 and     dword ptr [ebp-10h], 0FFFFFFFEh
.text$x:00008B04                 mov     ecx, [ebp+8]
.text$x:00008B07                 jmp     ??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char>>::~basic_string<char,std::char_traits<char>,std::allocator<char>>(void)
.text$x:00008B0C ; ---------------------------------------------------------------------------
.text$x:00008B0C
.text$x:00008B0C $LN6_0:                                 ; CODE XREF: __unwindfunclet$?message@_Iostream_error_category@std@@UBE?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@2@H@Z$0+6j
.text$x:00008B0C                 retn
.text$x:00008B0C __unwindfunclet$?message@_Iostream_error_category@std@@UBE?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@2@H@Z$0 endp
.text$x:00008B0C
.text$x:00008B0D
.text$x:00008B0D ; =============== S U B R O U T I N E =======================================
.text$x:00008B0D
.text$x:00008B0D
.text$x:00008B0D __ehhandler$?message@_Iostream_error_category@std@@UBE?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@2@H@Z proc near
.text$x:00008B0D                                         ; DATA XREF: std::_Iostream_error_category::message(int)+5o
.text$x:00008B0D
.text$x:00008B0D arg_4           = dword ptr  8
.text$x:00008B0D
.text$x:00008B0D                 mov     edx, [esp+arg_4]
.text$x:00008B11                 lea     eax, [edx+0Ch]
.text$x:00008B14                 mov     ecx, [edx-0Ch]
.text$x:00008B17                 xor     ecx, eax
.text$x:00008B19                 call    @__security_check_cookie@4 ; __security_check_cookie(x)
.text$x:00008B1E                 mov     eax, offset __ehfuncinfo$?message@_Iostream_error_category@std@@UBE?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@2@H@Z
.text$x:00008B23                 jmp     ___CxxFrameHandler3
.text$x:00008B23 __ehhandler$?message@_Iostream_error_category@std@@UBE?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@2@H@Z endp
.text$x:00008B23
.text$x:00008B23 _text$x         ends
.text$x:00008B23
.text$mn:00008B28 ; ===========================================================================
.text$mn:00008B28
.text$mn:00008B28 ; Segment type: Pure code
.text$mn:00008B28 ; Segment permissions: Read/Execute
.text$mn:00008B28 _text$mn        segment para public 'CODE' use32
.text$mn:00008B28                 assume cs:_text$mn
.text$mn:00008B28                 ;org 8B28h
.text$mn:00008B28 ; COMDAT (pick any)
.text$mn:00008B28                 assume es:nothing, ss:nothing, ds:_data, fs:nothing, gs:nothing
.text$mn:00008B28
.text$mn:00008B28 ; =============== S U B R O U T I N E =======================================
.text$mn:00008B28
.text$mn:00008B28 ; Attributes: bp-based frame
.text$mn:00008B28
.text$mn:00008B28 ; public: virtual class std::basic_string<char, struct std::char_traits<char>, class std::allocator<char>> __thiscall std::_System_error_category::message(int)const
.text$mn:00008B28                 public ?message@_System_error_category@std@@UBE?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@2@H@Z
.text$mn:00008B28 ?message@_System_error_category@std@@UBE?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@2@H@Z proc near
.text$mn:00008B28                                         ; DATA XREF: .rdata:0000A474o
.text$mn:00008B28
.text$mn:00008B28 var_1C          = dword ptr -1Ch
.text$mn:00008B28 var_18          = dword ptr -18h
.text$mn:00008B28 Str             = dword ptr -14h
.text$mn:00008B28 var_10          = dword ptr -10h
.text$mn:00008B28 var_C           = dword ptr -0Ch
.text$mn:00008B28 var_4           = dword ptr -4
.text$mn:00008B28 arg_0           = dword ptr  8
.text$mn:00008B28 arg_4           = dword ptr  0Ch
.text$mn:00008B28
.text$mn:00008B28                 push    ebp
.text$mn:00008B29                 mov     ebp, esp
.text$mn:00008B2B                 push    0FFFFFFFFh
.text$mn:00008B2D                 push    offset __ehhandler$?message@_System_error_category@std@@UBE?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@2@H@Z
.text$mn:00008B32                 mov     eax, large fs:0
.text$mn:00008B38                 push    eax
.text$mn:00008B39                 sub     esp, 10h
.text$mn:00008B3C                 mov     eax, dword ptr ds:___security_cookie
.text$mn:00008B41                 xor     eax, ebp
.text$mn:00008B43                 push    eax
.text$mn:00008B44                 lea     eax, [ebp+var_C]
.text$mn:00008B47                 mov     large fs:0, eax
.text$mn:00008B4D                 mov     [ebp+var_1C], ecx
.text$mn:00008B50                 mov     [ebp+var_18], 0
.text$mn:00008B57                 mov     eax, [ebp+arg_4]
.text$mn:00008B5A                 push    eax             ; int
.text$mn:00008B5B                 call    ?_Winerror_map@std@@YAPBDH@Z ; std::_Winerror_map(int)
.text$mn:00008B60                 add     esp, 4
.text$mn:00008B63                 mov     [ebp+var_10], eax
.text$mn:00008B66                 cmp     [ebp+var_10], 0
.text$mn:00008B6A                 jz      short loc_8B74
.text$mn:00008B6C                 mov     ecx, [ebp+var_10]
.text$mn:00008B6F                 mov     [ebp+Str], ecx
.text$mn:00008B72                 jmp     short loc_8B7B
.text$mn:00008B74 ; ---------------------------------------------------------------------------
.text$mn:00008B74
.text$mn:00008B74 loc_8B74:                               ; CODE XREF: std::_System_error_category::message(int)+42j
.text$mn:00008B74                 mov     [ebp+Str], offset ??_C@_0O@BFJCFAAK@unknown?5error?$AA@ ; "unknown error"
.text$mn:00008B7B
.text$mn:00008B7B loc_8B7B:                               ; CODE XREF: std::_System_error_category::message(int)+4Aj
.text$mn:00008B7B                 mov     edx, [ebp+Str]
.text$mn:00008B7E                 push    edx             ; Str
.text$mn:00008B7F                 mov     ecx, [ebp+arg_0]
.text$mn:00008B82                 call    ??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@PBD@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char>>::basic_string<char,std::char_traits<char>,std::allocator<char>>(char const *)
.text$mn:00008B87                 mov     [ebp+var_4], 0
.text$mn:00008B8E                 mov     eax, [ebp+var_18]
.text$mn:00008B91                 or      eax, 1
.text$mn:00008B94                 mov     [ebp+var_18], eax
.text$mn:00008B97                 mov     eax, [ebp+arg_0]
.text$mn:00008B9A                 mov     ecx, [ebp+var_C]
.text$mn:00008B9D                 mov     large fs:0, ecx
.text$mn:00008BA4                 pop     ecx
.text$mn:00008BA5                 mov     esp, ebp
.text$mn:00008BA7                 pop     ebp
.text$mn:00008BA8                 retn    8
.text$mn:00008BA8 ?message@_System_error_category@std@@UBE?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@2@H@Z endp
.text$mn:00008BA8
.text$mn:00008BA8 ; ---------------------------------------------------------------------------
.text$mn:00008BAB                 align 4
.text$mn:00008BAB _text$mn        ends
.text$mn:00008BAB
.text$x:00008BAC ; ===========================================================================
.text$x:00008BAC
.text$x:00008BAC ; Segment type: Pure code
.text$x:00008BAC ; Segment permissions: Read/Execute
.text$x:00008BAC _text$x         segment para public 'CODE' use32
.text$x:00008BAC                 assume cs:_text$x
.text$x:00008BAC                 ;org 8BACh
.text$x:00008BAC ; COMDAT (pick associative to section at 8B28)
.text$x:00008BAC                 assume es:nothing, ss:nothing, ds:_data, fs:nothing, gs:nothing
.text$x:00008BAC
.text$x:00008BAC ; =============== S U B R O U T I N E =======================================
.text$x:00008BAC
.text$x:00008BAC
.text$x:00008BAC __unwindfunclet$?message@_System_error_category@std@@UBE?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@2@H@Z$0 proc near
.text$x:00008BAC                                         ; DATA XREF: .xdata$x:000095D0o
.text$x:00008BAC                 mov     eax, [ebp-18h]
.text$x:00008BAF                 and     eax, 1
.text$x:00008BB2                 jz      $LN6_1
.text$x:00008BB8                 and     dword ptr [ebp-18h], 0FFFFFFFEh
.text$x:00008BBC                 mov     ecx, [ebp+8]
.text$x:00008BBF                 jmp     ??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char>>::~basic_string<char,std::char_traits<char>,std::allocator<char>>(void)
.text$x:00008BC4 ; ---------------------------------------------------------------------------
.text$x:00008BC4
.text$x:00008BC4 $LN6_1:                                 ; CODE XREF: __unwindfunclet$?message@_System_error_category@std@@UBE?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@2@H@Z$0+6j
.text$x:00008BC4                 retn
.text$x:00008BC4 __unwindfunclet$?message@_System_error_category@std@@UBE?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@2@H@Z$0 endp
.text$x:00008BC4
.text$x:00008BC5
.text$x:00008BC5 ; =============== S U B R O U T I N E =======================================
.text$x:00008BC5
.text$x:00008BC5
.text$x:00008BC5 __ehhandler$?message@_System_error_category@std@@UBE?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@2@H@Z proc near
.text$x:00008BC5                                         ; DATA XREF: std::_System_error_category::message(int)+5o
.text$x:00008BC5
.text$x:00008BC5 arg_4           = dword ptr  8
.text$x:00008BC5
.text$x:00008BC5                 mov     edx, [esp+arg_4]
.text$x:00008BC9                 lea     eax, [edx+0Ch]
.text$x:00008BCC                 mov     ecx, [edx-14h]
.text$x:00008BCF                 xor     ecx, eax
.text$x:00008BD1                 call    @__security_check_cookie@4 ; __security_check_cookie(x)
.text$x:00008BD6                 mov     eax, offset __ehfuncinfo$?message@_System_error_category@std@@UBE?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@2@H@Z
.text$x:00008BDB                 jmp     ___CxxFrameHandler3
.text$x:00008BDB __ehhandler$?message@_System_error_category@std@@UBE?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@2@H@Z endp
.text$x:00008BDB
.text$x:00008BDB _text$x         ends
.text$x:00008BDB
.text$mn:00008BE0 ; ===========================================================================
.text$mn:00008BE0
.text$mn:00008BE0 ; Segment type: Pure code
.text$mn:00008BE0 ; Segment permissions: Read/Execute
.text$mn:00008BE0 _text$mn        segment para public 'CODE' use32
.text$mn:00008BE0                 assume cs:_text$mn
.text$mn:00008BE0                 ;org 8BE0h
.text$mn:00008BE0 ; COMDAT (pick any)
.text$mn:00008BE0                 assume es:nothing, ss:nothing, ds:_data, fs:nothing, gs:nothing
.text$mn:00008BE0
.text$mn:00008BE0 ; =============== S U B R O U T I N E =======================================
.text$mn:00008BE0
.text$mn:00008BE0 ; Attributes: bp-based frame
.text$mn:00008BE0
.text$mn:00008BE0 ; int __cdecl std::char_traits<char>::move(void *Dst, void *Src, size_t Size)
.text$mn:00008BE0                 public ?move@?$char_traits@D@std@@SAPADPADPBDI@Z
.text$mn:00008BE0 ?move@?$char_traits@D@std@@SAPADPADPBDI@Z proc near
.text$mn:00008BE0                                         ; CODE XREF: std::basic_string<char,std::char_traits<char>,std::allocator<char>>::erase(uint,uint)+6Ap
.text$mn:00008BE0
.text$mn:00008BE0 var_4           = dword ptr -4
.text$mn:00008BE0 Dst             = dword ptr  8
.text$mn:00008BE0 Src             = dword ptr  0Ch
.text$mn:00008BE0 Size            = dword ptr  10h
.text$mn:00008BE0
.text$mn:00008BE0                 push    ebp
.text$mn:00008BE1                 mov     ebp, esp
.text$mn:00008BE3                 push    ecx
.text$mn:00008BE4                 cmp     [ebp+Size], 0
.text$mn:00008BE8                 jnz     short loc_8BF2
.text$mn:00008BEA                 mov     eax, [ebp+Dst]
.text$mn:00008BED                 mov     [ebp+var_4], eax
.text$mn:00008BF0                 jmp     short loc_8C09
.text$mn:00008BF2 ; ---------------------------------------------------------------------------
.text$mn:00008BF2
.text$mn:00008BF2 loc_8BF2:                               ; CODE XREF: std::char_traits<char>::move(char *,char const *,uint)+8j
.text$mn:00008BF2                 mov     ecx, [ebp+Size]
.text$mn:00008BF5                 push    ecx             ; Size
.text$mn:00008BF6                 mov     edx, [ebp+Src]
.text$mn:00008BF9                 push    edx             ; Src
.text$mn:00008BFA                 mov     eax, [ebp+Dst]
.text$mn:00008BFD                 push    eax             ; Dst
.text$mn:00008BFE                 call    _memmove
.text$mn:00008C03                 add     esp, 0Ch
.text$mn:00008C06                 mov     [ebp+var_4], eax
.text$mn:00008C09
.text$mn:00008C09 loc_8C09:                               ; CODE XREF: std::char_traits<char>::move(char *,char const *,uint)+10j
.text$mn:00008C09                 mov     eax, [ebp+var_4]
.text$mn:00008C0C                 mov     esp, ebp
.text$mn:00008C0E                 pop     ebp
.text$mn:00008C0F                 retn
.text$mn:00008C0F ?move@?$char_traits@D@std@@SAPADPADPBDI@Z endp
.text$mn:00008C0F
.text$mn:00008C0F _text$mn        ends
.text$mn:00008C0F
.text$mn:00008C10 ; ===========================================================================
.text$mn:00008C10
.text$mn:00008C10 ; Segment type: Pure code
.text$mn:00008C10 ; Segment permissions: Read/Execute
.text$mn:00008C10 _text$mn        segment para public 'CODE' use32
.text$mn:00008C10                 assume cs:_text$mn
.text$mn:00008C10                 ;org 8C10h
.text$mn:00008C10 ; COMDAT (pick any)
.text$mn:00008C10                 assume es:nothing, ss:nothing, ds:_data, fs:nothing, gs:nothing
.text$mn:00008C10
.text$mn:00008C10 ; =============== S U B R O U T I N E =======================================
.text$mn:00008C10
.text$mn:00008C10 ; Attributes: bp-based frame
.text$mn:00008C10
.text$mn:00008C10 ; const char *__thiscall std::_Generic_error_category::name(std::_Generic_error_category *__hidden this)
.text$mn:00008C10                 public ?name@_Generic_error_category@std@@UBEPBDXZ
.text$mn:00008C10 ?name@_Generic_error_category@std@@UBEPBDXZ proc near
.text$mn:00008C10                                         ; DATA XREF: .rdata:0000A3FCo
.text$mn:00008C10
.text$mn:00008C10 var_4           = dword ptr -4
.text$mn:00008C10
.text$mn:00008C10                 push    ebp
.text$mn:00008C11                 mov     ebp, esp
.text$mn:00008C13                 push    ecx
.text$mn:00008C14                 mov     [ebp+var_4], ecx
.text$mn:00008C17                 mov     eax, offset ??_C@_07DCLBNMLN@generic?$AA@ ; "generic"
.text$mn:00008C1C                 mov     esp, ebp
.text$mn:00008C1E                 pop     ebp
.text$mn:00008C1F                 retn
.text$mn:00008C1F ?name@_Generic_error_category@std@@UBEPBDXZ endp
.text$mn:00008C1F
.text$mn:00008C1F _text$mn        ends
.text$mn:00008C1F
.text$mn:00008C20 ; ===========================================================================
.text$mn:00008C20
.text$mn:00008C20 ; Segment type: Pure code
.text$mn:00008C20 ; Segment permissions: Read/Execute
.text$mn:00008C20 _text$mn        segment para public 'CODE' use32
.text$mn:00008C20                 assume cs:_text$mn
.text$mn:00008C20                 ;org 8C20h
.text$mn:00008C20 ; COMDAT (pick any)
.text$mn:00008C20                 assume es:nothing, ss:nothing, ds:_data, fs:nothing, gs:nothing
.text$mn:00008C20
.text$mn:00008C20 ; =============== S U B R O U T I N E =======================================
.text$mn:00008C20
.text$mn:00008C20 ; Attributes: bp-based frame
.text$mn:00008C20
.text$mn:00008C20 ; const char *__thiscall std::_Iostream_error_category::name(std::_Iostream_error_category *__hidden this)
.text$mn:00008C20                 public ?name@_Iostream_error_category@std@@UBEPBDXZ
.text$mn:00008C20 ?name@_Iostream_error_category@std@@UBEPBDXZ proc near
.text$mn:00008C20                                         ; DATA XREF: .rdata:0000A430o
.text$mn:00008C20
.text$mn:00008C20 var_4           = dword ptr -4
.text$mn:00008C20
.text$mn:00008C20                 push    ebp
.text$mn:00008C21                 mov     ebp, esp
.text$mn:00008C23                 push    ecx
.text$mn:00008C24                 mov     [ebp+var_4], ecx
.text$mn:00008C27                 mov     eax, offset ??_C@_08LLGCOLLL@iostream?$AA@ ; "iostream"
.text$mn:00008C2C                 mov     esp, ebp
.text$mn:00008C2E                 pop     ebp
.text$mn:00008C2F                 retn
.text$mn:00008C2F ?name@_Iostream_error_category@std@@UBEPBDXZ endp
.text$mn:00008C2F
.text$mn:00008C2F _text$mn        ends
.text$mn:00008C2F
.text$mn:00008C30 ; ===========================================================================
.text$mn:00008C30
.text$mn:00008C30 ; Segment type: Pure code
.text$mn:00008C30 ; Segment permissions: Read/Execute
.text$mn:00008C30 _text$mn        segment para public 'CODE' use32
.text$mn:00008C30                 assume cs:_text$mn
.text$mn:00008C30                 ;org 8C30h
.text$mn:00008C30 ; COMDAT (pick any)
.text$mn:00008C30                 assume es:nothing, ss:nothing, ds:_data, fs:nothing, gs:nothing
.text$mn:00008C30
.text$mn:00008C30 ; =============== S U B R O U T I N E =======================================
.text$mn:00008C30
.text$mn:00008C30 ; Attributes: bp-based frame
.text$mn:00008C30
.text$mn:00008C30 ; const char *__thiscall std::_System_error_category::name(std::_System_error_category *__hidden this)
.text$mn:00008C30                 public ?name@_System_error_category@std@@UBEPBDXZ
.text$mn:00008C30 ?name@_System_error_category@std@@UBEPBDXZ proc near
.text$mn:00008C30                                         ; DATA XREF: .rdata:0000A470o
.text$mn:00008C30
.text$mn:00008C30 var_4           = dword ptr -4
.text$mn:00008C30
.text$mn:00008C30                 push    ebp
.text$mn:00008C31                 mov     ebp, esp
.text$mn:00008C33                 push    ecx
.text$mn:00008C34                 mov     [ebp+var_4], ecx
.text$mn:00008C37                 mov     eax, offset ??_C@_06FHFOAHML@system?$AA@ ; "system"
.text$mn:00008C3C                 mov     esp, ebp
.text$mn:00008C3E                 pop     ebp
.text$mn:00008C3F                 retn
.text$mn:00008C3F ?name@_System_error_category@std@@UBEPBDXZ endp
.text$mn:00008C3F
.text$mn:00008C3F _text$mn        ends
.text$mn:00008C3F
.text$mn:00008C40 ; ===========================================================================
.text$mn:00008C40
.text$mn:00008C40 ; Segment type: Pure code
.text$mn:00008C40 ; Segment permissions: Read/Execute
.text$mn:00008C40 _text$mn        segment para public 'CODE' use32
.text$mn:00008C40                 assume cs:_text$mn
.text$mn:00008C40                 ;org 8C40h
.text$mn:00008C40 ; COMDAT (pick any)
.text$mn:00008C40                 assume es:nothing, ss:nothing, ds:_data, fs:nothing, gs:nothing
.text$mn:00008C40
.text$mn:00008C40 ; =============== S U B R O U T I N E =======================================
.text$mn:00008C40
.text$mn:00008C40 ; Attributes: bp-based frame
.text$mn:00008C40
.text$mn:00008C40 ; public: void __thiscall std::vector<struct FunctionValues, class std::allocator<struct FunctionValues>>::pop_back(void)
.text$mn:00008C40                 public ?pop_back@?$vector@UFunctionValues@@V?$allocator@UFunctionValues@@@std@@@std@@QAEXXZ
.text$mn:00008C40 ?pop_back@?$vector@UFunctionValues@@V?$allocator@UFunctionValues@@@std@@@std@@QAEXXZ proc near
.text$mn:00008C40                                         ; CODE XREF: FunctionCallTip::getCursorFunction(void)+531p
.text$mn:00008C40                                         ; FunctionCallTip::getCursorFunction(void)+624p
.text$mn:00008C40
.text$mn:00008C40 var_8           = dword ptr -8
.text$mn:00008C40 var_1           = byte ptr -1
.text$mn:00008C40
.text$mn:00008C40                 push    ebp
.text$mn:00008C41                 mov     ebp, esp
.text$mn:00008C43                 sub     esp, 8
.text$mn:00008C46                 mov     [ebp+var_8], ecx
.text$mn:00008C49                 mov     ecx, [ebp+var_8]
.text$mn:00008C4C                 call    ?empty@?$vector@UFunctionValues@@V?$allocator@UFunctionValues@@@std@@@std@@QBE_NXZ ; std::vector<FunctionValues,std::allocator<FunctionValues>>::empty(void)
.text$mn:00008C51                 movzx   eax, al
.text$mn:00008C54                 test    eax, eax
.text$mn:00008C56                 jz      short loc_8C71
.text$mn:00008C58                 push    4F5h            ; unsigned int
.text$mn:00008C5D                 push    offset ??_C@_1IM@EINEHPHE@?$AAC?$AA?3?$AA?2?$AAP?$AAr?$AAo?$AAg?$AAr?$AAa?$AAm?$AA?5?$AAF?$AAi?$AAl?$AAe?$AAs?$AA?5?$AA?$CI?$AAx?$AA8?$AA6?$AA?$CJ?$AA?2?$AAM?$AAi?$AAc?$AAr?$AAo?$AAs?$AAo?$AAf?$AAt@ ; "C:\\Program Files (x86)\\Microsoft Visu"...
.text$mn:00008C62                 push    offset ??_C@_1DA@JIKEAPDO@?$AAv?$AAe?$AAc?$AAt?$AAo?$AAr?$AA?5?$AAe?$AAm?$AAp?$AAt?$AAy?$AA?5?$AAb?$AAe?$AAf?$AAo?$AAr?$AAe?$AA?5?$AAp?$AAo?$AAp?$AA?$AA@ ; "vector empty before pop"
.text$mn:00008C67                 call    ?_Debug_message@std@@YAXPB_W0I@Z ; std::_Debug_message(wchar_t const *,wchar_t const *,uint)
.text$mn:00008C6C                 add     esp, 0Ch
.text$mn:00008C6F                 jmp     short loc_8CB6
.text$mn:00008C71 ; ---------------------------------------------------------------------------
.text$mn:00008C71
.text$mn:00008C71 loc_8C71:                               ; CODE XREF: std::vector<FunctionValues,std::allocator<FunctionValues>>::pop_back(void)+16j
.text$mn:00008C71                 mov     ecx, [ebp+var_8]
.text$mn:00008C74                 mov     edx, [ecx+8]
.text$mn:00008C77                 push    edx
.text$mn:00008C78                 mov     eax, [ebp+var_8]
.text$mn:00008C7B                 mov     ecx, [eax+8]
.text$mn:00008C7E                 sub     ecx, 10h
.text$mn:00008C81                 push    ecx
.text$mn:00008C82                 mov     ecx, [ebp+var_8]
.text$mn:00008C85                 call    ?_Orphan_range@?$vector@UFunctionValues@@V?$allocator@UFunctionValues@@@std@@@std@@IBEXPAUFunctionValues@@0@Z ; std::vector<FunctionValues,std::allocator<FunctionValues>>::_Orphan_range(FunctionValues *,FunctionValues *)
.text$mn:00008C8A                 mov     edx, [ebp+var_8]
.text$mn:00008C8D                 mov     eax, [edx+8]
.text$mn:00008C90                 sub     eax, 10h
.text$mn:00008C93                 push    eax
.text$mn:00008C94                 lea     ecx, [ebp+var_1]
.text$mn:00008C97                 push    ecx
.text$mn:00008C98                 mov     ecx, [ebp+var_8]
.text$mn:00008C9B                 call    ?_Getal@?$_Vector_alloc@$0A@U?$_Vec_base_types@UFunctionValues@@V?$allocator@UFunctionValues@@@std@@@std@@@std@@QBE?AU?$_Wrap_alloc@V?$allocator@UFunctionValues@@@std@@@2@XZ ; std::_Vector_alloc<0,std::_Vec_base_types<FunctionValues,std::allocator<FunctionValues>>>::_Getal(void)
.text$mn:00008CA0                 mov     ecx, eax
.text$mn:00008CA2                 call    ??$destroy@UFunctionValues@@@?$_Wrap_alloc@V?$allocator@UFunctionValues@@@std@@@std@@QAEXPAUFunctionValues@@@Z ; std::_Wrap_alloc<std::allocator<FunctionValues>>::destroy<FunctionValues>(FunctionValues *)
.text$mn:00008CA7                 mov     edx, [ebp+var_8]
.text$mn:00008CAA                 mov     eax, [edx+8]
.text$mn:00008CAD                 sub     eax, 10h
.text$mn:00008CB0                 mov     ecx, [ebp+var_8]
.text$mn:00008CB3                 mov     [ecx+8], eax
.text$mn:00008CB6
.text$mn:00008CB6 loc_8CB6:                               ; CODE XREF: std::vector<FunctionValues,std::allocator<FunctionValues>>::pop_back(void)+2Fj
.text$mn:00008CB6                 mov     esp, ebp
.text$mn:00008CB8                 pop     ebp
.text$mn:00008CB9                 retn
.text$mn:00008CB9 ?pop_back@?$vector@UFunctionValues@@V?$allocator@UFunctionValues@@@std@@@std@@QAEXXZ endp
.text$mn:00008CB9
.text$mn:00008CB9 ; ---------------------------------------------------------------------------
.text$mn:00008CBA                 align 4
.text$mn:00008CBA _text$mn        ends
.text$mn:00008CBA
.text$mn:00008CBC ; ===========================================================================
.text$mn:00008CBC
.text$mn:00008CBC ; Segment type: Pure code
.text$mn:00008CBC ; Segment permissions: Read/Execute
.text$mn:00008CBC _text$mn        segment para public 'CODE' use32
.text$mn:00008CBC                 assume cs:_text$mn
.text$mn:00008CBC                 ;org 8CBCh
.text$mn:00008CBC ; COMDAT (pick any)
.text$mn:00008CBC                 assume es:nothing, ss:nothing, ds:_data, fs:nothing, gs:nothing
.text$mn:00008CBC
.text$mn:00008CBC ; =============== S U B R O U T I N E =======================================
.text$mn:00008CBC
.text$mn:00008CBC ; Attributes: bp-based frame
.text$mn:00008CBC
.text$mn:00008CBC ; public: void __thiscall std::vector<wchar_t const *, class std::allocator<wchar_t const *>>::push_back(wchar_t const * const &)
.text$mn:00008CBC                 public ?push_back@?$vector@PB_WV?$allocator@PB_W@std@@@std@@QAEXABQB_W@Z
.text$mn:00008CBC ?push_back@?$vector@PB_WV?$allocator@PB_W@std@@@std@@QAEXABQB_W@Z proc near
.text$mn:00008CBC                                         ; CODE XREF: FunctionCallTip::loadFunction(void)+17Dp
.text$mn:00008CBC                                         ; FunctionCallTip::loadFunction(void)+1A2p ...
.text$mn:00008CBC
.text$mn:00008CBC var_C           = dword ptr -0Ch
.text$mn:00008CBC var_8           = dword ptr -8
.text$mn:00008CBC var_2           = byte ptr -2
.text$mn:00008CBC var_1           = byte ptr -1
.text$mn:00008CBC arg_0           = dword ptr  8
.text$mn:00008CBC
.text$mn:00008CBC                 push    ebp
.text$mn:00008CBD                 mov     ebp, esp
.text$mn:00008CBF                 sub     esp, 0Ch
.text$mn:00008CC2                 mov     [ebp+var_8], ecx
.text$mn:00008CC5                 mov     eax, [ebp+arg_0]
.text$mn:00008CC8                 push    eax
.text$mn:00008CC9                 call    ??$addressof@QB_W@std@@YAPBQB_WABQB_W@Z ; std::addressof<wchar_t const * const>(wchar_t const * const &)
.text$mn:00008CCE                 add     esp, 4
.text$mn:00008CD1                 push    eax
.text$mn:00008CD2                 mov     ecx, [ebp+var_8]
.text$mn:00008CD5                 call    ?_Inside@?$vector@PB_WV?$allocator@PB_W@std@@@std@@IBE_NPBQB_W@Z ; std::vector<wchar_t const *,std::allocator<wchar_t const *>>::_Inside(wchar_t const * const *)
.text$mn:00008CDA                 movzx   ecx, al
.text$mn:00008CDD                 test    ecx, ecx
.text$mn:00008CDF                 jz      short loc_8D5F
.text$mn:00008CE1                 mov     edx, [ebp+arg_0]
.text$mn:00008CE4                 push    edx
.text$mn:00008CE5                 call    ??$addressof@QB_W@std@@YAPBQB_WABQB_W@Z ; std::addressof<wchar_t const * const>(wchar_t const * const &)
.text$mn:00008CEA                 add     esp, 4
.text$mn:00008CED                 mov     ecx, [ebp+var_8]
.text$mn:00008CF0                 sub     eax, [ecx+4]
.text$mn:00008CF3                 sar     eax, 2
.text$mn:00008CF6                 mov     [ebp+var_C], eax
.text$mn:00008CF9                 mov     edx, [ebp+var_8]
.text$mn:00008CFC                 mov     eax, [ebp+var_8]
.text$mn:00008CFF                 mov     ecx, [edx+8]
.text$mn:00008D02                 cmp     ecx, [eax+0Ch]
.text$mn:00008D05                 jnz     short loc_8D11
.text$mn:00008D07                 push    1
.text$mn:00008D09                 mov     ecx, [ebp+var_8]
.text$mn:00008D0C                 call    ?_Reserve@?$vector@PB_WV?$allocator@PB_W@std@@@std@@IAEXI@Z ; std::vector<wchar_t const *,std::allocator<wchar_t const *>>::_Reserve(uint)
.text$mn:00008D11
.text$mn:00008D11 loc_8D11:                               ; CODE XREF: std::vector<wchar_t const *,std::allocator<wchar_t const *>>::push_back(wchar_t const * const &)+49j
.text$mn:00008D11                 mov     edx, [ebp+var_8]
.text$mn:00008D14                 mov     eax, [edx+8]
.text$mn:00008D17                 push    eax
.text$mn:00008D18                 mov     ecx, [ebp+var_8]
.text$mn:00008D1B                 mov     edx, [ecx+8]
.text$mn:00008D1E                 push    edx
.text$mn:00008D1F                 mov     ecx, [ebp+var_8]
.text$mn:00008D22                 call    ?_Orphan_range@?$vector@PB_WV?$allocator@PB_W@std@@@std@@IBEXPAPB_W0@Z ; std::vector<wchar_t const *,std::allocator<wchar_t const *>>::_Orphan_range(wchar_t const * *,wchar_t const * *)
.text$mn:00008D27                 mov     eax, [ebp+var_8]
.text$mn:00008D2A                 mov     ecx, [eax+4]
.text$mn:00008D2D                 mov     edx, [ebp+var_C]
.text$mn:00008D30                 lea     eax, [ecx+edx*4]
.text$mn:00008D33                 push    eax             ; int
.text$mn:00008D34                 mov     ecx, [ebp+var_8]
.text$mn:00008D37                 mov     edx, [ecx+8]
.text$mn:00008D3A                 push    edx             ; void *
.text$mn:00008D3B                 lea     eax, [ebp+var_1]
.text$mn:00008D3E                 push    eax
.text$mn:00008D3F                 mov     ecx, [ebp+var_8]
.text$mn:00008D42                 call    ?_Getal@?$_Vector_alloc@$0A@U?$_Vec_base_types@PB_WV?$allocator@PB_W@std@@@std@@@std@@QBE?AU?$_Wrap_alloc@V?$allocator@PB_W@std@@@2@XZ ; std::_Vector_alloc<0,std::_Vec_base_types<wchar_t const *,std::allocator<wchar_t const *>>>::_Getal(void)
.text$mn:00008D47                 mov     ecx, eax
.text$mn:00008D49                 call    ??$construct@PB_WAAPB_W@?$_Wrap_alloc@V?$allocator@PB_W@std@@@std@@QAEXPAPB_WAAPB_W@Z ; std::_Wrap_alloc<std::allocator<wchar_t const *>>::construct<wchar_t const *,wchar_t const * &>(wchar_t const * *,wchar_t const * &)
.text$mn:00008D4E                 mov     ecx, [ebp+var_8]
.text$mn:00008D51                 mov     edx, [ecx+8]
.text$mn:00008D54                 add     edx, 4
.text$mn:00008D57                 mov     eax, [ebp+var_8]
.text$mn:00008D5A                 mov     [eax+8], edx
.text$mn:00008D5D                 jmp     short loc_8DBA
.text$mn:00008D5F ; ---------------------------------------------------------------------------
.text$mn:00008D5F
.text$mn:00008D5F loc_8D5F:                               ; CODE XREF: std::vector<wchar_t const *,std::allocator<wchar_t const *>>::push_back(wchar_t const * const &)+23j
.text$mn:00008D5F                 mov     ecx, [ebp+var_8]
.text$mn:00008D62                 mov     edx, [ebp+var_8]
.text$mn:00008D65                 mov     eax, [ecx+8]
.text$mn:00008D68                 cmp     eax, [edx+0Ch]
.text$mn:00008D6B                 jnz     short loc_8D77
.text$mn:00008D6D                 push    1
.text$mn:00008D6F                 mov     ecx, [ebp+var_8]
.text$mn:00008D72                 call    ?_Reserve@?$vector@PB_WV?$allocator@PB_W@std@@@std@@IAEXI@Z ; std::vector<wchar_t const *,std::allocator<wchar_t const *>>::_Reserve(uint)
.text$mn:00008D77
.text$mn:00008D77 loc_8D77:                               ; CODE XREF: std::vector<wchar_t const *,std::allocator<wchar_t const *>>::push_back(wchar_t const * const &)+AFj
.text$mn:00008D77                 mov     ecx, [ebp+var_8]
.text$mn:00008D7A                 mov     edx, [ecx+8]
.text$mn:00008D7D                 push    edx
.text$mn:00008D7E                 mov     eax, [ebp+var_8]
.text$mn:00008D81                 mov     ecx, [eax+8]
.text$mn:00008D84                 push    ecx
.text$mn:00008D85                 mov     ecx, [ebp+var_8]
.text$mn:00008D88                 call    ?_Orphan_range@?$vector@PB_WV?$allocator@PB_W@std@@@std@@IBEXPAPB_W0@Z ; std::vector<wchar_t const *,std::allocator<wchar_t const *>>::_Orphan_range(wchar_t const * *,wchar_t const * *)
.text$mn:00008D8D                 mov     edx, [ebp+arg_0]
.text$mn:00008D90                 push    edx             ; int
.text$mn:00008D91                 mov     eax, [ebp+var_8]
.text$mn:00008D94                 mov     ecx, [eax+8]
.text$mn:00008D97                 push    ecx             ; void *
.text$mn:00008D98                 lea     edx, [ebp+var_2]
.text$mn:00008D9B                 push    edx
.text$mn:00008D9C                 mov     ecx, [ebp+var_8]
.text$mn:00008D9F                 call    ?_Getal@?$_Vector_alloc@$0A@U?$_Vec_base_types@PB_WV?$allocator@PB_W@std@@@std@@@std@@QBE?AU?$_Wrap_alloc@V?$allocator@PB_W@std@@@2@XZ ; std::_Vector_alloc<0,std::_Vec_base_types<wchar_t const *,std::allocator<wchar_t const *>>>::_Getal(void)
.text$mn:00008DA4                 mov     ecx, eax
.text$mn:00008DA6                 call    ??$construct@PB_WABQB_W@?$_Wrap_alloc@V?$allocator@PB_W@std@@@std@@QAEXPAPB_WABQB_W@Z ; std::_Wrap_alloc<std::allocator<wchar_t const *>>::construct<wchar_t const *,wchar_t const * const &>(wchar_t const * *,wchar_t const * const &)
.text$mn:00008DAB                 mov     eax, [ebp+var_8]
.text$mn:00008DAE                 mov     ecx, [eax+8]
.text$mn:00008DB1                 add     ecx, 4
.text$mn:00008DB4                 mov     edx, [ebp+var_8]
.text$mn:00008DB7                 mov     [edx+8], ecx
.text$mn:00008DBA
.text$mn:00008DBA loc_8DBA:                               ; CODE XREF: std::vector<wchar_t const *,std::allocator<wchar_t const *>>::push_back(wchar_t const * const &)+A1j
.text$mn:00008DBA                 mov     esp, ebp
.text$mn:00008DBC                 pop     ebp
.text$mn:00008DBD                 retn    4
.text$mn:00008DBD ?push_back@?$vector@PB_WV?$allocator@PB_W@std@@@std@@QAEXABQB_W@Z endp
.text$mn:00008DBD
.text$mn:00008DBD _text$mn        ends
.text$mn:00008DBD
.text$mn:00008DC0 ; ===========================================================================
.text$mn:00008DC0
.text$mn:00008DC0 ; Segment type: Pure code
.text$mn:00008DC0 ; Segment permissions: Read/Execute
.text$mn:00008DC0 _text$mn        segment para public 'CODE' use32
.text$mn:00008DC0                 assume cs:_text$mn
.text$mn:00008DC0                 ;org 8DC0h
.text$mn:00008DC0 ; COMDAT (pick any)
.text$mn:00008DC0                 assume es:nothing, ss:nothing, ds:_data, fs:nothing, gs:nothing
.text$mn:00008DC0
.text$mn:00008DC0 ; =============== S U B R O U T I N E =======================================
.text$mn:00008DC0
.text$mn:00008DC0 ; Attributes: bp-based frame
.text$mn:00008DC0
.text$mn:00008DC0 ; public: void __thiscall std::vector<struct FunctionValues, class std::allocator<struct FunctionValues>>::push_back(struct FunctionValues const &)
.text$mn:00008DC0                 public ?push_back@?$vector@UFunctionValues@@V?$allocator@UFunctionValues@@@std@@@std@@QAEXABUFunctionValues@@@Z
.text$mn:00008DC0 ?push_back@?$vector@UFunctionValues@@V?$allocator@UFunctionValues@@@std@@@std@@QAEXABUFunctionValues@@@Z proc near
.text$mn:00008DC0                                         ; CODE XREF: FunctionCallTip::getCursorFunction(void)+41Fp
.text$mn:00008DC0
.text$mn:00008DC0 var_C           = dword ptr -0Ch
.text$mn:00008DC0 var_8           = dword ptr -8
.text$mn:00008DC0 var_2           = byte ptr -2
.text$mn:00008DC0 var_1           = byte ptr -1
.text$mn:00008DC0 arg_0           = dword ptr  8
.text$mn:00008DC0
.text$mn:00008DC0                 push    ebp
.text$mn:00008DC1                 mov     ebp, esp
.text$mn:00008DC3                 sub     esp, 0Ch
.text$mn:00008DC6                 mov     [ebp+var_8], ecx
.text$mn:00008DC9                 mov     eax, [ebp+arg_0]
.text$mn:00008DCC                 push    eax
.text$mn:00008DCD                 call    ??$addressof@$$CBUFunctionValues@@@std@@YAPBUFunctionValues@@ABU1@@Z ; std::addressof<FunctionValues const>(FunctionValues const &)
.text$mn:00008DD2                 add     esp, 4
.text$mn:00008DD5                 push    eax
.text$mn:00008DD6                 mov     ecx, [ebp+var_8]
.text$mn:00008DD9                 call    ?_Inside@?$vector@UFunctionValues@@V?$allocator@UFunctionValues@@@std@@@std@@IBE_NPBUFunctionValues@@@Z ; std::vector<FunctionValues,std::allocator<FunctionValues>>::_Inside(FunctionValues const *)
.text$mn:00008DDE                 movzx   ecx, al
.text$mn:00008DE1                 test    ecx, ecx
.text$mn:00008DE3                 jz      short loc_8E63
.text$mn:00008DE5                 mov     edx, [ebp+arg_0]
.text$mn:00008DE8                 push    edx
.text$mn:00008DE9                 call    ??$addressof@$$CBUFunctionValues@@@std@@YAPBUFunctionValues@@ABU1@@Z ; std::addressof<FunctionValues const>(FunctionValues const &)
.text$mn:00008DEE                 add     esp, 4
.text$mn:00008DF1                 mov     ecx, [ebp+var_8]
.text$mn:00008DF4                 sub     eax, [ecx+4]
.text$mn:00008DF7                 sar     eax, 4
.text$mn:00008DFA                 mov     [ebp+var_C], eax
.text$mn:00008DFD                 mov     edx, [ebp+var_8]
.text$mn:00008E00                 mov     eax, [ebp+var_8]
.text$mn:00008E03                 mov     ecx, [edx+8]
.text$mn:00008E06                 cmp     ecx, [eax+0Ch]
.text$mn:00008E09                 jnz     short loc_8E15
.text$mn:00008E0B                 push    1
.text$mn:00008E0D                 mov     ecx, [ebp+var_8]
.text$mn:00008E10                 call    ?_Reserve@?$vector@UFunctionValues@@V?$allocator@UFunctionValues@@@std@@@std@@IAEXI@Z ; std::vector<FunctionValues,std::allocator<FunctionValues>>::_Reserve(uint)
.text$mn:00008E15
.text$mn:00008E15 loc_8E15:                               ; CODE XREF: std::vector<FunctionValues,std::allocator<FunctionValues>>::push_back(FunctionValues const &)+49j
.text$mn:00008E15                 mov     edx, [ebp+var_8]
.text$mn:00008E18                 mov     eax, [edx+8]
.text$mn:00008E1B                 push    eax
.text$mn:00008E1C                 mov     ecx, [ebp+var_8]
.text$mn:00008E1F                 mov     edx, [ecx+8]
.text$mn:00008E22                 push    edx
.text$mn:00008E23                 mov     ecx, [ebp+var_8]
.text$mn:00008E26                 call    ?_Orphan_range@?$vector@UFunctionValues@@V?$allocator@UFunctionValues@@@std@@@std@@IBEXPAUFunctionValues@@0@Z ; std::vector<FunctionValues,std::allocator<FunctionValues>>::_Orphan_range(FunctionValues *,FunctionValues *)
.text$mn:00008E2B                 mov     eax, [ebp+var_C]
.text$mn:00008E2E                 shl     eax, 4
.text$mn:00008E31                 mov     ecx, [ebp+var_8]
.text$mn:00008E34                 add     eax, [ecx+4]
.text$mn:00008E37                 push    eax             ; int
.text$mn:00008E38                 mov     edx, [ebp+var_8]
.text$mn:00008E3B                 mov     eax, [edx+8]
.text$mn:00008E3E                 push    eax             ; void *
.text$mn:00008E3F                 lea     ecx, [ebp+var_1]
.text$mn:00008E42                 push    ecx
.text$mn:00008E43                 mov     ecx, [ebp+var_8]
.text$mn:00008E46                 call    ?_Getal@?$_Vector_alloc@$0A@U?$_Vec_base_types@UFunctionValues@@V?$allocator@UFunctionValues@@@std@@@std@@@std@@QBE?AU?$_Wrap_alloc@V?$allocator@UFunctionValues@@@std@@@2@XZ ; std::_Vector_alloc<0,std::_Vec_base_types<FunctionValues,std::allocator<FunctionValues>>>::_Getal(void)
.text$mn:00008E4B                 mov     ecx, eax
.text$mn:00008E4D                 call    ??$construct@UFunctionValues@@AAU1@@?$_Wrap_alloc@V?$allocator@UFunctionValues@@@std@@@std@@QAEXPAUFunctionValues@@AAU2@@Z ; std::_Wrap_alloc<std::allocator<FunctionValues>>::construct<FunctionValues,FunctionValues &>(FunctionValues *,FunctionValues &)
.text$mn:00008E52                 mov     edx, [ebp+var_8]
.text$mn:00008E55                 mov     eax, [edx+8]
.text$mn:00008E58                 add     eax, 10h
.text$mn:00008E5B                 mov     ecx, [ebp+var_8]
.text$mn:00008E5E                 mov     [ecx+8], eax
.text$mn:00008E61                 jmp     short loc_8EBE
.text$mn:00008E63 ; ---------------------------------------------------------------------------
.text$mn:00008E63
.text$mn:00008E63 loc_8E63:                               ; CODE XREF: std::vector<FunctionValues,std::allocator<FunctionValues>>::push_back(FunctionValues const &)+23j
.text$mn:00008E63                 mov     edx, [ebp+var_8]
.text$mn:00008E66                 mov     eax, [ebp+var_8]
.text$mn:00008E69                 mov     ecx, [edx+8]
.text$mn:00008E6C                 cmp     ecx, [eax+0Ch]
.text$mn:00008E6F                 jnz     short loc_8E7B
.text$mn:00008E71                 push    1
.text$mn:00008E73                 mov     ecx, [ebp+var_8]
.text$mn:00008E76                 call    ?_Reserve@?$vector@UFunctionValues@@V?$allocator@UFunctionValues@@@std@@@std@@IAEXI@Z ; std::vector<FunctionValues,std::allocator<FunctionValues>>::_Reserve(uint)
.text$mn:00008E7B
.text$mn:00008E7B loc_8E7B:                               ; CODE XREF: std::vector<FunctionValues,std::allocator<FunctionValues>>::push_back(FunctionValues const &)+AFj
.text$mn:00008E7B                 mov     edx, [ebp+var_8]
.text$mn:00008E7E                 mov     eax, [edx+8]
.text$mn:00008E81                 push    eax
.text$mn:00008E82                 mov     ecx, [ebp+var_8]
.text$mn:00008E85                 mov     edx, [ecx+8]
.text$mn:00008E88                 push    edx
.text$mn:00008E89                 mov     ecx, [ebp+var_8]
.text$mn:00008E8C                 call    ?_Orphan_range@?$vector@UFunctionValues@@V?$allocator@UFunctionValues@@@std@@@std@@IBEXPAUFunctionValues@@0@Z ; std::vector<FunctionValues,std::allocator<FunctionValues>>::_Orphan_range(FunctionValues *,FunctionValues *)
.text$mn:00008E91                 mov     eax, [ebp+arg_0]
.text$mn:00008E94                 push    eax             ; int
.text$mn:00008E95                 mov     ecx, [ebp+var_8]
.text$mn:00008E98                 mov     edx, [ecx+8]
.text$mn:00008E9B                 push    edx             ; void *
.text$mn:00008E9C                 lea     eax, [ebp+var_2]
.text$mn:00008E9F                 push    eax
.text$mn:00008EA0                 mov     ecx, [ebp+var_8]
.text$mn:00008EA3                 call    ?_Getal@?$_Vector_alloc@$0A@U?$_Vec_base_types@UFunctionValues@@V?$allocator@UFunctionValues@@@std@@@std@@@std@@QBE?AU?$_Wrap_alloc@V?$allocator@UFunctionValues@@@std@@@2@XZ ; std::_Vector_alloc<0,std::_Vec_base_types<FunctionValues,std::allocator<FunctionValues>>>::_Getal(void)
.text$mn:00008EA8                 mov     ecx, eax
.text$mn:00008EAA                 call    ??$construct@UFunctionValues@@ABU1@@?$_Wrap_alloc@V?$allocator@UFunctionValues@@@std@@@std@@QAEXPAUFunctionValues@@ABU2@@Z ; std::_Wrap_alloc<std::allocator<FunctionValues>>::construct<FunctionValues,FunctionValues const &>(FunctionValues *,FunctionValues const &)
.text$mn:00008EAF                 mov     ecx, [ebp+var_8]
.text$mn:00008EB2                 mov     edx, [ecx+8]
.text$mn:00008EB5                 add     edx, 10h
.text$mn:00008EB8                 mov     eax, [ebp+var_8]
.text$mn:00008EBB                 mov     [eax+8], edx
.text$mn:00008EBE
.text$mn:00008EBE loc_8EBE:                               ; CODE XREF: std::vector<FunctionValues,std::allocator<FunctionValues>>::push_back(FunctionValues const &)+A1j
.text$mn:00008EBE                 mov     esp, ebp
.text$mn:00008EC0                 pop     ebp
.text$mn:00008EC1                 retn    4
.text$mn:00008EC1 ?push_back@?$vector@UFunctionValues@@V?$allocator@UFunctionValues@@@std@@@std@@QAEXABUFunctionValues@@@Z endp
.text$mn:00008EC1
.text$mn:00008EC1 _text$mn        ends
.text$mn:00008EC1
.text$mn:00008EC4 ; ===========================================================================
.text$mn:00008EC4
.text$mn:00008EC4 ; Segment type: Pure code
.text$mn:00008EC4 ; Segment permissions: Read/Execute
.text$mn:00008EC4 _text$mn        segment para public 'CODE' use32
.text$mn:00008EC4                 assume cs:_text$mn
.text$mn:00008EC4                 ;org 8EC4h
.text$mn:00008EC4 ; COMDAT (pick any)
.text$mn:00008EC4                 assume es:nothing, ss:nothing, ds:_data, fs:nothing, gs:nothing
.text$mn:00008EC4
.text$mn:00008EC4 ; =============== S U B R O U T I N E =======================================
.text$mn:00008EC4
.text$mn:00008EC4 ; Attributes: bp-based frame
.text$mn:00008EC4
.text$mn:00008EC4 ; public: void __thiscall std::vector<struct Token, class std::allocator<struct Token>>::push_back(struct Token &&)
.text$mn:00008EC4                 public ?push_back@?$vector@UToken@@V?$allocator@UToken@@@std@@@std@@QAEX$$QAUToken@@@Z
.text$mn:00008EC4 ?push_back@?$vector@UToken@@V?$allocator@UToken@@@std@@@std@@QAEX$$QAUToken@@@Z proc near
.text$mn:00008EC4                                         ; CODE XREF: FunctionCallTip::getCursorFunction(void)+284p
.text$mn:00008EC4                                         ; FunctionCallTip::getCursorFunction(void)+2FFp
.text$mn:00008EC4
.text$mn:00008EC4 var_C           = dword ptr -0Ch
.text$mn:00008EC4 var_8           = dword ptr -8
.text$mn:00008EC4 var_2           = byte ptr -2
.text$mn:00008EC4 var_1           = byte ptr -1
.text$mn:00008EC4 arg_0           = dword ptr  8
.text$mn:00008EC4
.text$mn:00008EC4                 push    ebp
.text$mn:00008EC5                 mov     ebp, esp
.text$mn:00008EC7                 sub     esp, 0Ch
.text$mn:00008ECA                 mov     [ebp+var_8], ecx
.text$mn:00008ECD                 mov     eax, [ebp+arg_0]
.text$mn:00008ED0                 push    eax
.text$mn:00008ED1                 call    ??$addressof@UToken@@@std@@YAPAUToken@@AAU1@@Z ; std::addressof<Token>(Token &)
.text$mn:00008ED6                 add     esp, 4
.text$mn:00008ED9                 push    eax
.text$mn:00008EDA                 mov     ecx, [ebp+var_8]
.text$mn:00008EDD                 call    ?_Inside@?$vector@UToken@@V?$allocator@UToken@@@std@@@std@@IBE_NPBUToken@@@Z ; std::vector<Token,std::allocator<Token>>::_Inside(Token const *)
.text$mn:00008EE2                 movzx   ecx, al
.text$mn:00008EE5                 test    ecx, ecx
.text$mn:00008EE7                 jz      loc_8F77
.text$mn:00008EED                 mov     edx, [ebp+arg_0]
.text$mn:00008EF0                 push    edx
.text$mn:00008EF1                 call    ??$addressof@UToken@@@std@@YAPAUToken@@AAU1@@Z ; std::addressof<Token>(Token &)
.text$mn:00008EF6                 add     esp, 4
.text$mn:00008EF9                 mov     ecx, [ebp+var_8]
.text$mn:00008EFC                 sub     eax, [ecx+4]
.text$mn:00008EFF                 cdq
.text$mn:00008F00                 mov     ecx, 0Ch
.text$mn:00008F05                 idiv    ecx
.text$mn:00008F07                 mov     [ebp+var_C], eax
.text$mn:00008F0A                 mov     edx, [ebp+var_8]
.text$mn:00008F0D                 mov     eax, [ebp+var_8]
.text$mn:00008F10                 mov     ecx, [edx+8]
.text$mn:00008F13                 cmp     ecx, [eax+0Ch]
.text$mn:00008F16                 jnz     short loc_8F22
.text$mn:00008F18                 push    1
.text$mn:00008F1A                 mov     ecx, [ebp+var_8]
.text$mn:00008F1D                 call    ?_Reserve@?$vector@UToken@@V?$allocator@UToken@@@std@@@std@@IAEXI@Z ; std::vector<Token,std::allocator<Token>>::_Reserve(uint)
.text$mn:00008F22
.text$mn:00008F22 loc_8F22:                               ; CODE XREF: std::vector<Token,std::allocator<Token>>::push_back(Token &&)+52j
.text$mn:00008F22                 mov     edx, [ebp+var_8]
.text$mn:00008F25                 mov     eax, [edx+8]
.text$mn:00008F28                 push    eax
.text$mn:00008F29                 mov     ecx, [ebp+var_8]
.text$mn:00008F2C                 mov     edx, [ecx+8]
.text$mn:00008F2F                 push    edx
.text$mn:00008F30                 mov     ecx, [ebp+var_8]
.text$mn:00008F33                 call    ?_Orphan_range@?$vector@UToken@@V?$allocator@UToken@@@std@@@std@@IBEXPAUToken@@0@Z ; std::vector<Token,std::allocator<Token>>::_Orphan_range(Token *,Token *)
.text$mn:00008F38                 imul    eax, [ebp+var_C], 0Ch
.text$mn:00008F3C                 mov     ecx, [ebp+var_8]
.text$mn:00008F3F                 add     eax, [ecx+4]
.text$mn:00008F42                 push    eax
.text$mn:00008F43                 call    ??$forward@UToken@@@std@@YA$$QAUToken@@AAU1@@Z ; std::forward<Token>(Token &)
.text$mn:00008F48                 add     esp, 4
.text$mn:00008F4B                 push    eax             ; int
.text$mn:00008F4C                 mov     edx, [ebp+var_8]
.text$mn:00008F4F                 mov     eax, [edx+8]
.text$mn:00008F52                 push    eax             ; void *
.text$mn:00008F53                 lea     ecx, [ebp+var_1]
.text$mn:00008F56                 push    ecx
.text$mn:00008F57                 mov     ecx, [ebp+var_8]
.text$mn:00008F5A                 call    ?_Getal@?$_Vector_alloc@$0A@U?$_Vec_base_types@UToken@@V?$allocator@UToken@@@std@@@std@@@std@@QBE?AU?$_Wrap_alloc@V?$allocator@UToken@@@std@@@2@XZ ; std::_Vector_alloc<0,std::_Vec_base_types<Token,std::allocator<Token>>>::_Getal(void)
.text$mn:00008F5F                 mov     ecx, eax
.text$mn:00008F61                 call    ??$construct@UToken@@U1@@?$_Wrap_alloc@V?$allocator@UToken@@@std@@@std@@QAEXPAUToken@@$$QAU2@@Z ; std::_Wrap_alloc<std::allocator<Token>>::construct<Token,Token>(Token *,Token &&)
.text$mn:00008F66                 mov     edx, [ebp+var_8]
.text$mn:00008F69                 mov     eax, [edx+8]
.text$mn:00008F6C                 add     eax, 0Ch
.text$mn:00008F6F                 mov     ecx, [ebp+var_8]
.text$mn:00008F72                 mov     [ecx+8], eax
.text$mn:00008F75                 jmp     short loc_8FDB
.text$mn:00008F77 ; ---------------------------------------------------------------------------
.text$mn:00008F77
.text$mn:00008F77 loc_8F77:                               ; CODE XREF: std::vector<Token,std::allocator<Token>>::push_back(Token &&)+23j
.text$mn:00008F77                 mov     edx, [ebp+var_8]
.text$mn:00008F7A                 mov     eax, [ebp+var_8]
.text$mn:00008F7D                 mov     ecx, [edx+8]
.text$mn:00008F80                 cmp     ecx, [eax+0Ch]
.text$mn:00008F83                 jnz     short loc_8F8F
.text$mn:00008F85                 push    1
.text$mn:00008F87                 mov     ecx, [ebp+var_8]
.text$mn:00008F8A                 call    ?_Reserve@?$vector@UToken@@V?$allocator@UToken@@@std@@@std@@IAEXI@Z ; std::vector<Token,std::allocator<Token>>::_Reserve(uint)
.text$mn:00008F8F
.text$mn:00008F8F loc_8F8F:                               ; CODE XREF: std::vector<Token,std::allocator<Token>>::push_back(Token &&)+BFj
.text$mn:00008F8F                 mov     edx, [ebp+var_8]
.text$mn:00008F92                 mov     eax, [edx+8]
.text$mn:00008F95                 push    eax
.text$mn:00008F96                 mov     ecx, [ebp+var_8]
.text$mn:00008F99                 mov     edx, [ecx+8]
.text$mn:00008F9C                 push    edx
.text$mn:00008F9D                 mov     ecx, [ebp+var_8]
.text$mn:00008FA0                 call    ?_Orphan_range@?$vector@UToken@@V?$allocator@UToken@@@std@@@std@@IBEXPAUToken@@0@Z ; std::vector<Token,std::allocator<Token>>::_Orphan_range(Token *,Token *)
.text$mn:00008FA5                 mov     eax, [ebp+arg_0]
.text$mn:00008FA8                 push    eax
.text$mn:00008FA9                 call    ??$forward@UToken@@@std@@YA$$QAUToken@@AAU1@@Z ; std::forward<Token>(Token &)
.text$mn:00008FAE                 add     esp, 4
.text$mn:00008FB1                 push    eax             ; int
.text$mn:00008FB2                 mov     ecx, [ebp+var_8]
.text$mn:00008FB5                 mov     edx, [ecx+8]
.text$mn:00008FB8                 push    edx             ; void *
.text$mn:00008FB9                 lea     eax, [ebp+var_2]
.text$mn:00008FBC                 push    eax
.text$mn:00008FBD                 mov     ecx, [ebp+var_8]
.text$mn:00008FC0                 call    ?_Getal@?$_Vector_alloc@$0A@U?$_Vec_base_types@UToken@@V?$allocator@UToken@@@std@@@std@@@std@@QBE?AU?$_Wrap_alloc@V?$allocator@UToken@@@std@@@2@XZ ; std::_Vector_alloc<0,std::_Vec_base_types<Token,std::allocator<Token>>>::_Getal(void)
.text$mn:00008FC5                 mov     ecx, eax
.text$mn:00008FC7                 call    ??$construct@UToken@@U1@@?$_Wrap_alloc@V?$allocator@UToken@@@std@@@std@@QAEXPAUToken@@$$QAU2@@Z ; std::_Wrap_alloc<std::allocator<Token>>::construct<Token,Token>(Token *,Token &&)
.text$mn:00008FCC                 mov     ecx, [ebp+var_8]
.text$mn:00008FCF                 mov     edx, [ecx+8]
.text$mn:00008FD2                 add     edx, 0Ch
.text$mn:00008FD5                 mov     eax, [ebp+var_8]
.text$mn:00008FD8                 mov     [eax+8], edx
.text$mn:00008FDB
.text$mn:00008FDB loc_8FDB:                               ; CODE XREF: std::vector<Token,std::allocator<Token>>::push_back(Token &&)+B1j
.text$mn:00008FDB                 mov     esp, ebp
.text$mn:00008FDD                 pop     ebp
.text$mn:00008FDE                 retn    4
.text$mn:00008FDE ?push_back@?$vector@UToken@@V?$allocator@UToken@@@std@@@std@@QAEX$$QAUToken@@@Z endp
.text$mn:00008FDE
.text$mn:00008FDE ; ---------------------------------------------------------------------------
.text$mn:00008FE1                 align 4
.text$mn:00008FE1 _text$mn        ends
.text$mn:00008FE1
.text$mn:00008FE4 ; ===========================================================================
.text$mn:00008FE4
.text$mn:00008FE4 ; Segment type: Pure code
.text$mn:00008FE4 ; Segment permissions: Read/Execute
.text$mn:00008FE4 _text$mn        segment para public 'CODE' use32
.text$mn:00008FE4                 assume cs:_text$mn
.text$mn:00008FE4                 ;org 8FE4h
.text$mn:00008FE4 ; COMDAT (pick any)
.text$mn:00008FE4                 assume es:nothing, ss:nothing, ds:_data, fs:nothing, gs:nothing
.text$mn:00008FE4
.text$mn:00008FE4 ; =============== S U B R O U T I N E =======================================
.text$mn:00008FE4
.text$mn:00008FE4 ; Attributes: bp-based frame
.text$mn:00008FE4
.text$mn:00008FE4 ; public: void __thiscall std::vector<class std::vector<wchar_t const *, class std::allocator<wchar_t const *>>, class std::allocator<class std::vector<wchar_t const *, class std::allocator<wchar_t const *>>>>::push_back(class std::vector<wchar_t const *, class std::allocator<wchar_t const *>> const &)
.text$mn:00008FE4                 public ?push_back@?$vector@V?$vector@PB_WV?$allocator@PB_W@std@@@std@@V?$allocator@V?$vector@PB_WV?$allocator@PB_W@std@@@std@@@2@@std@@QAEXABV?$vector@PB_WV?$allocator@PB_W@std@@@2@@Z
.text$mn:00008FE4 ?push_back@?$vector@V?$vector@PB_WV?$allocator@PB_W@std@@@std@@V?$allocator@V?$vector@PB_WV?$allocator@PB_W@std@@@std@@@2@@std@@QAEXABV?$vector@PB_WV?$allocator@PB_W@std@@@2@@Z proc near
.text$mn:00008FE4                                         ; CODE XREF: FunctionCallTip::loadFunction(void)+217p
.text$mn:00008FE4
.text$mn:00008FE4 var_C           = dword ptr -0Ch
.text$mn:00008FE4 var_8           = dword ptr -8
.text$mn:00008FE4 var_2           = byte ptr -2
.text$mn:00008FE4 var_1           = byte ptr -1
.text$mn:00008FE4 arg_0           = dword ptr  8
.text$mn:00008FE4
.text$mn:00008FE4                 push    ebp
.text$mn:00008FE5                 mov     ebp, esp
.text$mn:00008FE7                 sub     esp, 0Ch
.text$mn:00008FEA                 mov     [ebp+var_8], ecx
.text$mn:00008FED                 mov     eax, [ebp+arg_0]
.text$mn:00008FF0                 push    eax
.text$mn:00008FF1                 call    ??$addressof@$$CBV?$vector@PB_WV?$allocator@PB_W@std@@@std@@@std@@YAPBV?$vector@PB_WV?$allocator@PB_W@std@@@0@ABV10@@Z ; std::addressof<std::vector<wchar_t const *,std::allocator<wchar_t const *>> const>(std::vector<wchar_t const *,std::allocator<wchar_t const *>> const &)
.text$mn:00008FF6                 add     esp, 4
.text$mn:00008FF9                 push    eax
.text$mn:00008FFA                 mov     ecx, [ebp+var_8]
.text$mn:00008FFD                 call    ?_Inside@?$vector@V?$vector@PB_WV?$allocator@PB_W@std@@@std@@V?$allocator@V?$vector@PB_WV?$allocator@PB_W@std@@@std@@@2@@std@@IBE_NPBV?$vector@PB_WV?$allocator@PB_W@std@@@2@@Z ; std::vector<std::vector<wchar_t const *,std::allocator<wchar_t const *>>,std::allocator<std::vector<wchar_t const *,std::allocator<wchar_t const *>>>>::_Inside(std::vector<wchar_t const *,std::allocator<wchar_t const *>> const *)
.text$mn:00009002                 movzx   ecx, al
.text$mn:00009005                 test    ecx, ecx
.text$mn:00009007                 jz      short loc_9087
.text$mn:00009009                 mov     edx, [ebp+arg_0]
.text$mn:0000900C                 push    edx
.text$mn:0000900D                 call    ??$addressof@$$CBV?$vector@PB_WV?$allocator@PB_W@std@@@std@@@std@@YAPBV?$vector@PB_WV?$allocator@PB_W@std@@@0@ABV10@@Z ; std::addressof<std::vector<wchar_t const *,std::allocator<wchar_t const *>> const>(std::vector<wchar_t const *,std::allocator<wchar_t const *>> const &)
.text$mn:00009012                 add     esp, 4
.text$mn:00009015                 mov     ecx, [ebp+var_8]
.text$mn:00009018                 sub     eax, [ecx+4]
.text$mn:0000901B                 sar     eax, 4
.text$mn:0000901E                 mov     [ebp+var_C], eax
.text$mn:00009021                 mov     edx, [ebp+var_8]
.text$mn:00009024                 mov     eax, [ebp+var_8]
.text$mn:00009027                 mov     ecx, [edx+8]
.text$mn:0000902A                 cmp     ecx, [eax+0Ch]
.text$mn:0000902D                 jnz     short loc_9039
.text$mn:0000902F                 push    1
.text$mn:00009031                 mov     ecx, [ebp+var_8]
.text$mn:00009034                 call    ?_Reserve@?$vector@V?$vector@PB_WV?$allocator@PB_W@std@@@std@@V?$allocator@V?$vector@PB_WV?$allocator@PB_W@std@@@std@@@2@@std@@IAEXI@Z ; std::vector<std::vector<wchar_t const *,std::allocator<wchar_t const *>>,std::allocator<std::vector<wchar_t const *,std::allocator<wchar_t const *>>>>::_Reserve(uint)
.text$mn:00009039
.text$mn:00009039 loc_9039:                               ; CODE XREF: std::vector<std::vector<wchar_t const *,std::allocator<wchar_t const *>>,std::allocator<std::vector<wchar_t const *,std::allocator<wchar_t const *>>>>::push_back(std::vector<wchar_t const *,std::allocator<wchar_t const *>> const &)+49j
.text$mn:00009039                 mov     edx, [ebp+var_8]
.text$mn:0000903C                 mov     eax, [edx+8]
.text$mn:0000903F                 push    eax
.text$mn:00009040                 mov     ecx, [ebp+var_8]
.text$mn:00009043                 mov     edx, [ecx+8]
.text$mn:00009046                 push    edx
.text$mn:00009047                 mov     ecx, [ebp+var_8]
.text$mn:0000904A                 call    ?_Orphan_range@?$vector@V?$vector@PB_WV?$allocator@PB_W@std@@@std@@V?$allocator@V?$vector@PB_WV?$allocator@PB_W@std@@@std@@@2@@std@@IBEXPAV?$vector@PB_WV?$allocator@PB_W@std@@@2@0@Z ; std::vector<std::vector<wchar_t const *,std::allocator<wchar_t const *>>,std::allocator<std::vector<wchar_t const *,std::allocator<wchar_t const *>>>>::_Orphan_range(std::vector<wchar_t const *,std::allocator<wchar_t const *>> *,std::vector<wchar_t const *,std::allocator<wchar_t const *>> *)
.text$mn:0000904F                 mov     eax, [ebp+var_C]
.text$mn:00009052                 shl     eax, 4
.text$mn:00009055                 mov     ecx, [ebp+var_8]
.text$mn:00009058                 add     eax, [ecx+4]
.text$mn:0000905B                 push    eax             ; int
.text$mn:0000905C                 mov     edx, [ebp+var_8]
.text$mn:0000905F                 mov     eax, [edx+8]
.text$mn:00009062                 push    eax             ; void *
.text$mn:00009063                 lea     ecx, [ebp+var_1]
.text$mn:00009066                 push    ecx
.text$mn:00009067                 mov     ecx, [ebp+var_8]
.text$mn:0000906A                 call    ?_Getal@?$_Vector_alloc@$0A@U?$_Vec_base_types@V?$vector@PB_WV?$allocator@PB_W@std@@@std@@V?$allocator@V?$vector@PB_WV?$allocator@PB_W@std@@@std@@@2@@std@@@std@@QBE?AU?$_Wrap_alloc@V?$allocator@V?$vector@PB_WV?$allocator@PB_W@std@@@std@@@std@@@2@XZ ; std::_Vector_alloc<0,std::_Vec_base_types<std::vector<wchar_t const *,std::allocator<wchar_t const *>>,std::allocator<std::vector<wchar_t const *,std::allocator<wchar_t const *>>>>>::_Getal(void)
.text$mn:0000906F                 mov     ecx, eax
.text$mn:00009071                 call    ??$construct@V?$vector@PB_WV?$allocator@PB_W@std@@@std@@AAV12@@?$_Wrap_alloc@V?$allocator@V?$vector@PB_WV?$allocator@PB_W@std@@@std@@@std@@@std@@QAEXPAV?$vector@PB_WV?$allocator@PB_W@std@@@1@AAV21@@Z ; std::_Wrap_alloc<std::allocator<std::vector<wchar_t const *,std::allocator<wchar_t const *>>>>::construct<std::vector<wchar_t const *,std::allocator<wchar_t const *>>,std::vector<wchar_t const *,std::allocator<wchar_t const *>> &>(std::vector<wchar_t const *,std::allocator<wchar_t const *>> *,std::vector<wchar_t const *,std::allocator<wchar_t const *>> &)
.text$mn:00009076                 mov     edx, [ebp+var_8]
.text$mn:00009079                 mov     eax, [edx+8]
.text$mn:0000907C                 add     eax, 10h
.text$mn:0000907F                 mov     ecx, [ebp+var_8]
.text$mn:00009082                 mov     [ecx+8], eax
.text$mn:00009085                 jmp     short loc_90E2
.text$mn:00009087 ; ---------------------------------------------------------------------------
.text$mn:00009087
.text$mn:00009087 loc_9087:                               ; CODE XREF: std::vector<std::vector<wchar_t const *,std::allocator<wchar_t const *>>,std::allocator<std::vector<wchar_t const *,std::allocator<wchar_t const *>>>>::push_back(std::vector<wchar_t const *,std::allocator<wchar_t const *>> const &)+23j
.text$mn:00009087                 mov     edx, [ebp+var_8]
.text$mn:0000908A                 mov     eax, [ebp+var_8]
.text$mn:0000908D                 mov     ecx, [edx+8]
.text$mn:00009090                 cmp     ecx, [eax+0Ch]
.text$mn:00009093                 jnz     short loc_909F
.text$mn:00009095                 push    1
.text$mn:00009097                 mov     ecx, [ebp+var_8]
.text$mn:0000909A                 call    ?_Reserve@?$vector@V?$vector@PB_WV?$allocator@PB_W@std@@@std@@V?$allocator@V?$vector@PB_WV?$allocator@PB_W@std@@@std@@@2@@std@@IAEXI@Z ; std::vector<std::vector<wchar_t const *,std::allocator<wchar_t const *>>,std::allocator<std::vector<wchar_t const *,std::allocator<wchar_t const *>>>>::_Reserve(uint)
.text$mn:0000909F
.text$mn:0000909F loc_909F:                               ; CODE XREF: std::vector<std::vector<wchar_t const *,std::allocator<wchar_t const *>>,std::allocator<std::vector<wchar_t const *,std::allocator<wchar_t const *>>>>::push_back(std::vector<wchar_t const *,std::allocator<wchar_t const *>> const &)+AFj
.text$mn:0000909F                 mov     edx, [ebp+var_8]
.text$mn:000090A2                 mov     eax, [edx+8]
.text$mn:000090A5                 push    eax
.text$mn:000090A6                 mov     ecx, [ebp+var_8]
.text$mn:000090A9                 mov     edx, [ecx+8]
.text$mn:000090AC                 push    edx
.text$mn:000090AD                 mov     ecx, [ebp+var_8]
.text$mn:000090B0                 call    ?_Orphan_range@?$vector@V?$vector@PB_WV?$allocator@PB_W@std@@@std@@V?$allocator@V?$vector@PB_WV?$allocator@PB_W@std@@@std@@@2@@std@@IBEXPAV?$vector@PB_WV?$allocator@PB_W@std@@@2@0@Z ; std::vector<std::vector<wchar_t const *,std::allocator<wchar_t const *>>,std::allocator<std::vector<wchar_t const *,std::allocator<wchar_t const *>>>>::_Orphan_range(std::vector<wchar_t const *,std::allocator<wchar_t const *>> *,std::vector<wchar_t const *,std::allocator<wchar_t const *>> *)
.text$mn:000090B5                 mov     eax, [ebp+arg_0]
.text$mn:000090B8                 push    eax             ; int
.text$mn:000090B9                 mov     ecx, [ebp+var_8]
.text$mn:000090BC                 mov     edx, [ecx+8]
.text$mn:000090BF                 push    edx             ; void *
.text$mn:000090C0                 lea     eax, [ebp+var_2]
.text$mn:000090C3                 push    eax
.text$mn:000090C4                 mov     ecx, [ebp+var_8]
.text$mn:000090C7                 call    ?_Getal@?$_Vector_alloc@$0A@U?$_Vec_base_types@V?$vector@PB_WV?$allocator@PB_W@std@@@std@@V?$allocator@V?$vector@PB_WV?$allocator@PB_W@std@@@std@@@2@@std@@@std@@QBE?AU?$_Wrap_alloc@V?$allocator@V?$vector@PB_WV?$allocator@PB_W@std@@@std@@@std@@@2@XZ ; std::_Vector_alloc<0,std::_Vec_base_types<std::vector<wchar_t const *,std::allocator<wchar_t const *>>,std::allocator<std::vector<wchar_t const *,std::allocator<wchar_t const *>>>>>::_Getal(void)
.text$mn:000090CC                 mov     ecx, eax
.text$mn:000090CE                 call    ??$construct@V?$vector@PB_WV?$allocator@PB_W@std@@@std@@ABV12@@?$_Wrap_alloc@V?$allocator@V?$vector@PB_WV?$allocator@PB_W@std@@@std@@@std@@@std@@QAEXPAV?$vector@PB_WV?$allocator@PB_W@std@@@1@ABV21@@Z ; std::_Wrap_alloc<std::allocator<std::vector<wchar_t const *,std::allocator<wchar_t const *>>>>::construct<std::vector<wchar_t const *,std::allocator<wchar_t const *>>,std::vector<wchar_t const *,std::allocator<wchar_t const *>> const &>(std::vector<wchar_t const *,std::allocator<wchar_t const *>> *,std::vector<wchar_t const *,std::allocator<wchar_t const *>> const &)
.text$mn:000090D3                 mov     ecx, [ebp+var_8]
.text$mn:000090D6                 mov     edx, [ecx+8]
.text$mn:000090D9                 add     edx, 10h
.text$mn:000090DC                 mov     eax, [ebp+var_8]
.text$mn:000090DF                 mov     [eax+8], edx
.text$mn:000090E2
.text$mn:000090E2 loc_90E2:                               ; CODE XREF: std::vector<std::vector<wchar_t const *,std::allocator<wchar_t const *>>,std::allocator<std::vector<wchar_t const *,std::allocator<wchar_t const *>>>>::push_back(std::vector<wchar_t const *,std::allocator<wchar_t const *>> const &)+A1j
.text$mn:000090E2                 mov     esp, ebp
.text$mn:000090E4                 pop     ebp
.text$mn:000090E5                 retn    4
.text$mn:000090E5 ?push_back@?$vector@V?$vector@PB_WV?$allocator@PB_W@std@@@std@@V?$allocator@V?$vector@PB_WV?$allocator@PB_W@std@@@std@@@2@@std@@QAEXABV?$vector@PB_WV?$allocator@PB_W@std@@@2@@Z endp
.text$mn:000090E5
.text$mn:000090E5 _text$mn        ends
.text$mn:000090E5
.text$mn:000090E8 ; ===========================================================================
.text$mn:000090E8
.text$mn:000090E8 ; Segment type: Pure code
.text$mn:000090E8 ; Segment permissions: Read/Execute
.text$mn:000090E8 _text$mn        segment para public 'CODE' use32
.text$mn:000090E8                 assume cs:_text$mn
.text$mn:000090E8                 ;org 90E8h
.text$mn:000090E8 ; COMDAT (pick any)
.text$mn:000090E8                 assume es:nothing, ss:nothing, ds:_data, fs:nothing, gs:nothing
.text$mn:000090E8
.text$mn:000090E8 ; =============== S U B R O U T I N E =======================================
.text$mn:000090E8
.text$mn:000090E8 ; Attributes: bp-based frame
.text$mn:000090E8
.text$mn:000090E8 ; public: struct std::_Wrap_alloc<class std::allocator<wchar_t const *>> __thiscall std::_Wrap_alloc<class std::allocator<wchar_t const *>>::select_on_container_copy_construction(void)const
.text$mn:000090E8                 public ?select_on_container_copy_construction@?$_Wrap_alloc@V?$allocator@PB_W@std@@@std@@QBE?AU12@XZ
.text$mn:000090E8 ?select_on_container_copy_construction@?$_Wrap_alloc@V?$allocator@PB_W@std@@@std@@QBE?AU12@XZ proc near
.text$mn:000090E8                                         ; CODE XREF: std::vector<wchar_t const *,std::allocator<wchar_t const *>>::vector<wchar_t const *,std::allocator<wchar_t const *>>(std::vector<wchar_t const *,std::allocator<wchar_t const *>> const &)+41p
.text$mn:000090E8
.text$mn:000090E8 var_8           = dword ptr -8
.text$mn:000090E8 var_1           = byte ptr -1
.text$mn:000090E8 arg_0           = dword ptr  8
.text$mn:000090E8
.text$mn:000090E8                 push    ebp
.text$mn:000090E9                 mov     ebp, esp
.text$mn:000090EB                 sub     esp, 8
.text$mn:000090EE                 mov     [ebp+var_8], ecx
.text$mn:000090F1                 mov     eax, [ebp+var_8]
.text$mn:000090F4                 push    eax
.text$mn:000090F5                 lea     ecx, [ebp+var_1]
.text$mn:000090F8                 push    ecx
.text$mn:000090F9                 call    ?select_on_container_copy_construction@?$allocator_traits@V?$allocator@PB_W@std@@@std@@SA?AV?$allocator@PB_W@2@ABV32@@Z ; std::allocator_traits<std::allocator<wchar_t const *>>::select_on_container_copy_construction(std::allocator<wchar_t const *> const &)
.text$mn:000090FE                 add     esp, 8
.text$mn:00009101                 push    eax
.text$mn:00009102                 mov     ecx, [ebp+arg_0]
.text$mn:00009105                 call    ??0?$_Wrap_alloc@V?$allocator@PB_W@std@@@std@@QAE@ABV?$allocator@PB_W@1@@Z ; std::_Wrap_alloc<std::allocator<wchar_t const *>>::_Wrap_alloc<std::allocator<wchar_t const *>>(std::allocator<wchar_t const *> const &)
.text$mn:0000910A                 mov     eax, [ebp+arg_0]
.text$mn:0000910D                 mov     esp, ebp
.text$mn:0000910F                 pop     ebp
.text$mn:00009110                 retn    4
.text$mn:00009110 ?select_on_container_copy_construction@?$_Wrap_alloc@V?$allocator@PB_W@std@@@std@@QBE?AU12@XZ endp
.text$mn:00009110
.text$mn:00009110 ; ---------------------------------------------------------------------------
.text$mn:00009113                 align 4
.text$mn:00009113 _text$mn        ends
.text$mn:00009113
.text$mn:00009114 ; ===========================================================================
.text$mn:00009114
.text$mn:00009114 ; Segment type: Pure code
.text$mn:00009114 ; Segment permissions: Read/Execute
.text$mn:00009114 _text$mn        segment para public 'CODE' use32
.text$mn:00009114                 assume cs:_text$mn
.text$mn:00009114                 ;org 9114h
.text$mn:00009114 ; COMDAT (pick any)
.text$mn:00009114                 assume es:nothing, ss:nothing, ds:_data, fs:nothing, gs:nothing
.text$mn:00009114
.text$mn:00009114 ; =============== S U B R O U T I N E =======================================
.text$mn:00009114
.text$mn:00009114 ; Attributes: bp-based frame
.text$mn:00009114
.text$mn:00009114 ; public: class std::allocator<wchar_t const *> __thiscall std::allocator<wchar_t const *>::select_on_container_copy_construction(void)const
.text$mn:00009114                 public ?select_on_container_copy_construction@?$allocator@PB_W@std@@QBE?AV12@XZ
.text$mn:00009114 ?select_on_container_copy_construction@?$allocator@PB_W@std@@QBE?AV12@XZ proc near
.text$mn:00009114                                         ; CODE XREF: std::allocator_traits<std::allocator<wchar_t const *>>::select_on_container_copy_construction(std::allocator<wchar_t const *> const &)+Ap
.text$mn:00009114
.text$mn:00009114 var_4           = dword ptr -4
.text$mn:00009114 arg_0           = dword ptr  8
.text$mn:00009114
.text$mn:00009114                 push    ebp
.text$mn:00009115                 mov     ebp, esp
.text$mn:00009117                 push    ecx
.text$mn:00009118                 mov     [ebp+var_4], ecx
.text$mn:0000911B                 mov     eax, [ebp+var_4]
.text$mn:0000911E                 push    eax
.text$mn:0000911F                 mov     ecx, [ebp+arg_0]
.text$mn:00009122                 call    ??0?$allocator@PB_W@std@@QAE@ABV01@@Z ; std::allocator<wchar_t const *>::allocator<wchar_t const *>(std::allocator<wchar_t const *> const &)
.text$mn:00009127                 mov     eax, [ebp+arg_0]
.text$mn:0000912A                 mov     esp, ebp
.text$mn:0000912C                 pop     ebp
.text$mn:0000912D                 retn    4
.text$mn:0000912D ?select_on_container_copy_construction@?$allocator@PB_W@std@@QBE?AV12@XZ endp
.text$mn:0000912D
.text$mn:0000912D _text$mn        ends
.text$mn:0000912D
.text$mn:00009130 ; ===========================================================================
.text$mn:00009130
.text$mn:00009130 ; Segment type: Pure code
.text$mn:00009130 ; Segment permissions: Read/Execute
.text$mn:00009130 _text$mn        segment para public 'CODE' use32
.text$mn:00009130                 assume cs:_text$mn
.text$mn:00009130                 ;org 9130h
.text$mn:00009130 ; COMDAT (pick any)
.text$mn:00009130                 assume es:nothing, ss:nothing, ds:_data, fs:nothing, gs:nothing
.text$mn:00009130
.text$mn:00009130 ; =============== S U B R O U T I N E =======================================
.text$mn:00009130
.text$mn:00009130 ; Attributes: bp-based frame
.text$mn:00009130
.text$mn:00009130 ; public: static class std::allocator<wchar_t const *> __cdecl std::allocator_traits<class std::allocator<wchar_t const *>>::select_on_container_copy_construction(class std::allocator<wchar_t const *> const &)
.text$mn:00009130                 public ?select_on_container_copy_construction@?$allocator_traits@V?$allocator@PB_W@std@@@std@@SA?AV?$allocator@PB_W@2@ABV32@@Z
.text$mn:00009130 ?select_on_container_copy_construction@?$allocator_traits@V?$allocator@PB_W@std@@@std@@SA?AV?$allocator@PB_W@2@ABV32@@Z proc near
.text$mn:00009130                                         ; CODE XREF: std::_Wrap_alloc<std::allocator<wchar_t const *>>::select_on_container_copy_construction(void)+11p
.text$mn:00009130
.text$mn:00009130 arg_0           = dword ptr  8
.text$mn:00009130 arg_4           = dword ptr  0Ch
.text$mn:00009130
.text$mn:00009130                 push    ebp
.text$mn:00009131                 mov     ebp, esp
.text$mn:00009133                 mov     eax, [ebp+arg_0]
.text$mn:00009136                 push    eax
.text$mn:00009137                 mov     ecx, [ebp+arg_4]
.text$mn:0000913A                 call    ?select_on_container_copy_construction@?$allocator@PB_W@std@@QBE?AV12@XZ ; std::allocator<wchar_t const *>::select_on_container_copy_construction(void)
.text$mn:0000913F                 mov     eax, [ebp+arg_0]
.text$mn:00009142                 pop     ebp
.text$mn:00009143                 retn
.text$mn:00009143 ?select_on_container_copy_construction@?$allocator_traits@V?$allocator@PB_W@std@@@std@@SA?AV?$allocator@PB_W@2@ABV32@@Z endp
.text$mn:00009143
.text$mn:00009143 _text$mn        ends
.text$mn:00009143
.text$mn:00009144 ; ===========================================================================
.text$mn:00009144
.text$mn:00009144 ; Segment type: Pure code
.text$mn:00009144 ; Segment permissions: Read/Execute
.text$mn:00009144 _text$mn        segment para public 'CODE' use32
.text$mn:00009144                 assume cs:_text$mn
.text$mn:00009144                 ;org 9144h
.text$mn:00009144 ; COMDAT (pick any)
.text$mn:00009144                 assume es:nothing, ss:nothing, ds:_data, fs:nothing, gs:nothing
.text$mn:00009144
.text$mn:00009144 ; =============== S U B R O U T I N E =======================================
.text$mn:00009144
.text$mn:00009144 ; Attributes: bp-based frame
.text$mn:00009144
.text$mn:00009144 ; public: unsigned int __thiscall std::basic_string<char, struct std::char_traits<char>, class std::allocator<char>>::size(void)const
.text$mn:00009144                 public ?size@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QBEIXZ
.text$mn:00009144 ?size@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QBEIXZ proc near
.text$mn:00009144                                         ; CODE XREF: std::basic_string<char,std::char_traits<char>,std::allocator<char>>::assign(std::basic_string<char,std::char_traits<char>,std::allocator<char>> const &,uint,uint)+Cp
.text$mn:00009144                                         ; std::basic_string<char,std::char_traits<char>,std::allocator<char>>::assign(std::basic_string<char,std::char_traits<char>,std::allocator<char>> const &,uint,uint)+21p
.text$mn:00009144
.text$mn:00009144 var_4           = dword ptr -4
.text$mn:00009144
.text$mn:00009144                 push    ebp
.text$mn:00009145                 mov     ebp, esp
.text$mn:00009147                 push    ecx
.text$mn:00009148                 mov     [ebp+var_4], ecx
.text$mn:0000914B                 mov     eax, [ebp+var_4]
.text$mn:0000914E                 mov     eax, [eax+14h]
.text$mn:00009151                 mov     esp, ebp
.text$mn:00009153                 pop     ebp
.text$mn:00009154                 retn
.text$mn:00009154 ?size@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QBEIXZ endp
.text$mn:00009154
.text$mn:00009154 ; ---------------------------------------------------------------------------
.text$mn:00009155                 align 4
.text$mn:00009155 _text$mn        ends
.text$mn:00009155
.text$mn:00009158 ; ===========================================================================
.text$mn:00009158
.text$mn:00009158 ; Segment type: Pure code
.text$mn:00009158 ; Segment permissions: Read/Execute
.text$mn:00009158 _text$mn        segment para public 'CODE' use32
.text$mn:00009158                 assume cs:_text$mn
.text$mn:00009158                 ;org 9158h
.text$mn:00009158 ; COMDAT (pick any)
.text$mn:00009158                 assume es:nothing, ss:nothing, ds:_data, fs:nothing, gs:nothing
.text$mn:00009158
.text$mn:00009158 ; =============== S U B R O U T I N E =======================================
.text$mn:00009158
.text$mn:00009158 ; Attributes: bp-based frame
.text$mn:00009158
.text$mn:00009158 ; public: unsigned int __thiscall std::vector<wchar_t const *, class std::allocator<wchar_t const *>>::size(void)const
.text$mn:00009158                 public ?size@?$vector@PB_WV?$allocator@PB_W@std@@@std@@QBEIXZ
.text$mn:00009158 ?size@?$vector@PB_WV?$allocator@PB_W@std@@@std@@QBEIXZ proc near
.text$mn:00009158                                         ; CODE XREF: FunctionCallTip::showCalltip(void)+53p
.text$mn:00009158                                         ; FunctionCallTip::showCalltip(void)+CAp ...
.text$mn:00009158
.text$mn:00009158 var_4           = dword ptr -4
.text$mn:00009158
.text$mn:00009158                 push    ebp
.text$mn:00009159                 mov     ebp, esp
.text$mn:0000915B                 push    ecx
.text$mn:0000915C                 mov     [ebp+var_4], ecx
.text$mn:0000915F                 mov     eax, [ebp+var_4]
.text$mn:00009162                 mov     ecx, [ebp+var_4]
.text$mn:00009165                 mov     eax, [eax+8]
.text$mn:00009168                 sub     eax, [ecx+4]
.text$mn:0000916B                 sar     eax, 2
.text$mn:0000916E                 mov     esp, ebp
.text$mn:00009170                 pop     ebp
.text$mn:00009171                 retn
.text$mn:00009171 ?size@?$vector@PB_WV?$allocator@PB_W@std@@@std@@QBEIXZ endp
.text$mn:00009171
.text$mn:00009171 ; ---------------------------------------------------------------------------
.text$mn:00009172                 align 4
.text$mn:00009172 _text$mn        ends
.text$mn:00009172
.text$mn:00009174 ; ===========================================================================
.text$mn:00009174
.text$mn:00009174 ; Segment type: Pure code
.text$mn:00009174 ; Segment permissions: Read/Execute
.text$mn:00009174 _text$mn        segment para public 'CODE' use32
.text$mn:00009174                 assume cs:_text$mn
.text$mn:00009174                 ;org 9174h
.text$mn:00009174 ; COMDAT (pick any)
.text$mn:00009174                 assume es:nothing, ss:nothing, ds:_data, fs:nothing, gs:nothing
.text$mn:00009174
.text$mn:00009174 ; =============== S U B R O U T I N E =======================================
.text$mn:00009174
.text$mn:00009174 ; Attributes: bp-based frame
.text$mn:00009174
.text$mn:00009174 ; public: unsigned int __thiscall std::vector<struct FunctionValues, class std::allocator<struct FunctionValues>>::size(void)const
.text$mn:00009174                 public ?size@?$vector@UFunctionValues@@V?$allocator@UFunctionValues@@@std@@@std@@QBEIXZ
.text$mn:00009174 ?size@?$vector@UFunctionValues@@V?$allocator@UFunctionValues@@@std@@@std@@QBEIXZ proc near
.text$mn:00009174                                         ; CODE XREF: FunctionCallTip::getCursorFunction(void)+4F4p
.text$mn:00009174                                         ; FunctionCallTip::getCursorFunction(void)+5E7p ...
.text$mn:00009174
.text$mn:00009174 var_4           = dword ptr -4
.text$mn:00009174
.text$mn:00009174                 push    ebp
.text$mn:00009175                 mov     ebp, esp
.text$mn:00009177                 push    ecx
.text$mn:00009178                 mov     [ebp+var_4], ecx
.text$mn:0000917B                 mov     eax, [ebp+var_4]
.text$mn:0000917E                 mov     ecx, [ebp+var_4]
.text$mn:00009181                 mov     eax, [eax+8]
.text$mn:00009184                 sub     eax, [ecx+4]
.text$mn:00009187                 sar     eax, 4
.text$mn:0000918A                 mov     esp, ebp
.text$mn:0000918C                 pop     ebp
.text$mn:0000918D                 retn
.text$mn:0000918D ?size@?$vector@UFunctionValues@@V?$allocator@UFunctionValues@@@std@@@std@@QBEIXZ endp
.text$mn:0000918D
.text$mn:0000918D ; ---------------------------------------------------------------------------
.text$mn:0000918E                 align 10h
.text$mn:0000918E _text$mn        ends
.text$mn:0000918E
.text$mn:00009190 ; ===========================================================================
.text$mn:00009190
.text$mn:00009190 ; Segment type: Pure code
.text$mn:00009190 ; Segment permissions: Read/Execute
.text$mn:00009190 _text$mn        segment para public 'CODE' use32
.text$mn:00009190                 assume cs:_text$mn
.text$mn:00009190                 ;org 9190h
.text$mn:00009190 ; COMDAT (pick any)
.text$mn:00009190                 assume es:nothing, ss:nothing, ds:_data, fs:nothing, gs:nothing
.text$mn:00009190
.text$mn:00009190 ; =============== S U B R O U T I N E =======================================
.text$mn:00009190
.text$mn:00009190 ; Attributes: bp-based frame
.text$mn:00009190
.text$mn:00009190 ; public: unsigned int __thiscall std::vector<struct Token, class std::allocator<struct Token>>::size(void)const
.text$mn:00009190                 public ?size@?$vector@UToken@@V?$allocator@UToken@@@std@@@std@@QBEIXZ
.text$mn:00009190 ?size@?$vector@UToken@@V?$allocator@UToken@@@std@@@std@@QBEIXZ proc near
.text$mn:00009190                                         ; CODE XREF: FunctionCallTip::getCursorFunction(void)+30Fp
.text$mn:00009190                                         ; std::vector<Token,std::allocator<Token>>::_Reallocate(uint)+A9p ...
.text$mn:00009190
.text$mn:00009190 var_4           = dword ptr -4
.text$mn:00009190
.text$mn:00009190                 push    ebp
.text$mn:00009191                 mov     ebp, esp
.text$mn:00009193                 push    ecx
.text$mn:00009194                 mov     [ebp+var_4], ecx
.text$mn:00009197                 mov     eax, [ebp+var_4]
.text$mn:0000919A                 mov     ecx, [ebp+var_4]
.text$mn:0000919D                 mov     eax, [eax+8]
.text$mn:000091A0                 sub     eax, [ecx+4]
.text$mn:000091A3                 cdq
.text$mn:000091A4                 mov     ecx, 0Ch
.text$mn:000091A9                 idiv    ecx
.text$mn:000091AB                 mov     esp, ebp
.text$mn:000091AD                 pop     ebp
.text$mn:000091AE                 retn
.text$mn:000091AE ?size@?$vector@UToken@@V?$allocator@UToken@@@std@@@std@@QBEIXZ endp
.text$mn:000091AE
.text$mn:000091AE ; ---------------------------------------------------------------------------
.text$mn:000091AF                 align 10h
.text$mn:000091AF _text$mn        ends
.text$mn:000091AF
.text$mn:000091B0 ; ===========================================================================
.text$mn:000091B0
.text$mn:000091B0 ; Segment type: Pure code
.text$mn:000091B0 ; Segment permissions: Read/Execute
.text$mn:000091B0 _text$mn        segment para public 'CODE' use32
.text$mn:000091B0                 assume cs:_text$mn
.text$mn:000091B0                 ;org 91B0h
.text$mn:000091B0 ; COMDAT (pick any)
.text$mn:000091B0                 assume es:nothing, ss:nothing, ds:_data, fs:nothing, gs:nothing
.text$mn:000091B0
.text$mn:000091B0 ; =============== S U B R O U T I N E =======================================
.text$mn:000091B0
.text$mn:000091B0 ; Attributes: bp-based frame
.text$mn:000091B0
.text$mn:000091B0 ; public: unsigned int __thiscall std::vector<class std::vector<wchar_t const *, class std::allocator<wchar_t const *>>, class std::allocator<class std::vector<wchar_t const *, class std::allocator<wchar_t const *>>>>::size(void)const
.text$mn:000091B0                 public ?size@?$vector@V?$vector@PB_WV?$allocator@PB_W@std@@@std@@V?$allocator@V?$vector@PB_WV?$allocator@PB_W@std@@@std@@@2@@std@@QBEIXZ
.text$mn:000091B0 ?size@?$vector@V?$vector@PB_WV?$allocator@PB_W@std@@@std@@V?$allocator@V?$vector@PB_WV?$allocator@PB_W@std@@@std@@@2@@std@@QBEIXZ proc near
.text$mn:000091B0                                         ; CODE XREF: FunctionCallTip::loadFunction(void)+23Ep
.text$mn:000091B0                                         ; FunctionCallTip::showCalltip(void)+7Fp ...
.text$mn:000091B0
.text$mn:000091B0 var_4           = dword ptr -4
.text$mn:000091B0
.text$mn:000091B0                 push    ebp
.text$mn:000091B1                 mov     ebp, esp
.text$mn:000091B3                 push    ecx
.text$mn:000091B4                 mov     [ebp+var_4], ecx
.text$mn:000091B7                 mov     eax, [ebp+var_4]
.text$mn:000091BA                 mov     ecx, [ebp+var_4]
.text$mn:000091BD                 mov     eax, [eax+8]
.text$mn:000091C0                 sub     eax, [ecx+4]
.text$mn:000091C3                 sar     eax, 4
.text$mn:000091C6                 mov     esp, ebp
.text$mn:000091C8                 pop     ebp
.text$mn:000091C9                 retn
.text$mn:000091C9 ?size@?$vector@V?$vector@PB_WV?$allocator@PB_W@std@@@std@@V?$allocator@V?$vector@PB_WV?$allocator@PB_W@std@@@std@@@2@@std@@QBEIXZ endp
.text$mn:000091C9
.text$mn:000091C9 ; ---------------------------------------------------------------------------
.text$mn:000091CA                 align 4
.text$mn:000091CA _text$mn        ends
.text$mn:000091CA
.text$mn:000091CC ; ===========================================================================
.text$mn:000091CC
.text$mn:000091CC ; Segment type: Pure code
.text$mn:000091CC ; Segment permissions: Read/Execute
.text$mn:000091CC _text$mn        segment para public 'CODE' use32
.text$mn:000091CC                 assume cs:_text$mn
.text$mn:000091CC                 ;org 91CCh
.text$mn:000091CC ; COMDAT (pick any)
.text$mn:000091CC                 assume es:nothing, ss:nothing, ds:_data, fs:nothing, gs:nothing
.text$mn:000091CC
.text$mn:000091CC ; =============== S U B R O U T I N E =======================================
.text$mn:000091CC
.text$mn:000091CC ; Attributes: bp-based frame
.text$mn:000091CC
.text$mn:000091CC ; const struct std::error_category *__cdecl std::system_category()
.text$mn:000091CC                 public ?system_category@std@@YAABVerror_category@1@XZ
.text$mn:000091CC ?system_category@std@@YAABVerror_category@1@XZ proc near
.text$mn:000091CC                                         ; CODE XREF: std::_System_error_category::default_error_condition(int):loc_82B4p
.text$mn:000091CC                 push    ebp
.text$mn:000091CD                 mov     ebp, esp
.text$mn:000091CF                 mov     eax, offset ?_System_object@?$_Error_objects@H@std@@2V_System_error_category@2@A ; std::_System_error_category std::_Error_objects<int>::_System_object
.text$mn:000091D4                 pop     ebp
.text$mn:000091D5                 retn
.text$mn:000091D5 ?system_category@std@@YAABVerror_category@1@XZ endp
.text$mn:000091D5
.text$mn:000091D5 ; ---------------------------------------------------------------------------
.text$mn:000091D6                 align 4
.text$mn:000091D6 _text$mn        ends
.text$mn:000091D6
.text$mn:000091D8 ; ===========================================================================
.text$mn:000091D8
.text$mn:000091D8 ; Segment type: Pure code
.text$mn:000091D8 ; Segment permissions: Read/Execute
.text$mn:000091D8 _text$mn        segment para public 'CODE' use32
.text$mn:000091D8                 assume cs:_text$mn
.text$mn:000091D8                 ;org 91D8h
.text$mn:000091D8 ; COMDAT (pick any)
.text$mn:000091D8                 assume es:nothing, ss:nothing, ds:_data, fs:nothing, gs:nothing
.text$mn:000091D8
.text$mn:000091D8 ; =============== S U B R O U T I N E =======================================
.text$mn:000091D8
.text$mn:000091D8 ; Attributes: bp-based frame
.text$mn:000091D8
.text$mn:000091D8 ; int __thiscall std::error_code::value(std::error_code *__hidden this)
.text$mn:000091D8                 public ?value@error_code@std@@QBEHXZ
.text$mn:000091D8 ?value@error_code@std@@QBEHXZ proc near ; CODE XREF: std::error_category::equivalent(std::error_code const &,int)+24p
.text$mn:000091D8
.text$mn:000091D8 var_4           = dword ptr -4
.text$mn:000091D8
.text$mn:000091D8                 push    ebp
.text$mn:000091D9                 mov     ebp, esp
.text$mn:000091DB                 push    ecx
.text$mn:000091DC                 mov     [ebp+var_4], ecx
.text$mn:000091DF                 mov     eax, [ebp+var_4]
.text$mn:000091E2                 mov     eax, [eax]
.text$mn:000091E4                 mov     esp, ebp
.text$mn:000091E6                 pop     ebp
.text$mn:000091E7                 retn
.text$mn:000091E7 ?value@error_code@std@@QBEHXZ endp
.text$mn:000091E7
.text$mn:000091E7 _text$mn        ends
.text$mn:000091E7
.text$mn:000091E8 ; ===========================================================================
.text$mn:000091E8
.text$mn:000091E8 ; Segment type: Pure code
.text$mn:000091E8 ; Segment permissions: Read/Execute
.text$mn:000091E8 _text$mn        segment para public 'CODE' use32
.text$mn:000091E8                 assume cs:_text$mn
.text$mn:000091E8                 ;org 91E8h
.text$mn:000091E8 ; COMDAT (pick any)
.text$mn:000091E8                 assume es:nothing, ss:nothing, ds:_data, fs:nothing, gs:nothing
.text$mn:000091E8
.text$mn:000091E8 ; =============== S U B R O U T I N E =======================================
.text$mn:000091E8
.text$mn:000091E8 ; Attributes: bp-based frame
.text$mn:000091E8
.text$mn:000091E8 ; int __thiscall std::error_condition::value(std::error_condition *__hidden this)
.text$mn:000091E8                 public ?value@error_condition@std@@QBEHXZ
.text$mn:000091E8 ?value@error_condition@std@@QBEHXZ proc near
.text$mn:000091E8                                         ; CODE XREF: std::error_condition::operator==(std::error_condition const &)+2Cp
.text$mn:000091E8                                         ; std::error_condition::operator==(std::error_condition const &)+36p
.text$mn:000091E8
.text$mn:000091E8 var_4           = dword ptr -4
.text$mn:000091E8
.text$mn:000091E8                 push    ebp
.text$mn:000091E9                 mov     ebp, esp
.text$mn:000091EB                 push    ecx
.text$mn:000091EC                 mov     [ebp+var_4], ecx
.text$mn:000091EF                 mov     eax, [ebp+var_4]
.text$mn:000091F2                 mov     eax, [eax]
.text$mn:000091F4                 mov     esp, ebp
.text$mn:000091F6                 pop     ebp
.text$mn:000091F7                 retn
.text$mn:000091F7 ?value@error_condition@std@@QBEHXZ endp
.text$mn:000091F7
.text$mn:000091F7 _text$mn        ends
.text$mn:000091F7
.text$mn:000091F8 ; ===========================================================================
.text$mn:000091F8
.text$mn:000091F8 ; Segment type: Pure code
.text$mn:000091F8 ; Segment permissions: Read/Execute
.text$mn:000091F8 _text$mn        segment para public 'CODE' use32
.text$mn:000091F8                 assume cs:_text$mn
.text$mn:000091F8                 ;org 91F8h
.text$mn:000091F8 ; COMDAT (pick any)
.text$mn:000091F8                 assume es:nothing, ss:nothing, ds:_data, fs:nothing, gs:nothing
.text$mn:000091F8
.text$mn:000091F8 ; =============== S U B R O U T I N E =======================================
.text$mn:000091F8
.text$mn:000091F8 ; Attributes: bp-based frame
.text$mn:000091F8
.text$mn:000091F8                 public _hypot
.text$mn:000091F8 _hypot          proc near
.text$mn:000091F8
.text$mn:000091F8 var_10          = qword ptr -10h
.text$mn:000091F8 var_8           = qword ptr -8
.text$mn:000091F8 arg_0           = qword ptr  8
.text$mn:000091F8 arg_8           = qword ptr  10h
.text$mn:000091F8
.text$mn:000091F8                 push    ebp
.text$mn:000091F9                 mov     ebp, esp
.text$mn:000091FB                 sub     esp, 8
.text$mn:000091FE                 movsd   xmm0, [ebp+arg_8]
.text$mn:00009203                 movsd   [esp+8+var_8], xmm0
.text$mn:00009208                 sub     esp, 8
.text$mn:0000920B                 movsd   xmm0, [ebp+arg_0]
.text$mn:00009210                 movsd   [esp+10h+var_10], xmm0
.text$mn:00009215                 call    __hypot
.text$mn:0000921A                 add     esp, 10h
.text$mn:0000921D                 pop     ebp
.text$mn:0000921E                 retn
.text$mn:0000921E _hypot          endp
.text$mn:0000921E
.text$mn:0000921E ; ---------------------------------------------------------------------------
.text$mn:0000921F                 align 10h
.text$mn:0000921F _text$mn        ends
.text$mn:0000921F
.xdata$x:00009220 ; ===========================================================================
.xdata$x:00009220
.xdata$x:00009220 ; Segment type: Pure data
.xdata$x:00009220 ; Segment permissions: Read
.xdata$x:00009220 _xdata$x        segment dword public 'DATA' use32
.xdata$x:00009220                 assume cs:_xdata$x
.xdata$x:00009220                 ;org 9220h
.xdata$x:00009220 ; COMDAT (pick associative to section at 69C8)
.xdata$x:00009220 __unwindtable$?_Orphan_all@_Container_base12@std@@QAEXXZ db 0FFh
.xdata$x:00009220                                         ; DATA XREF: .xdata$x:00009230o
.xdata$x:00009221                 db 0FFh
.xdata$x:00009222                 db 0FFh
.xdata$x:00009223                 db 0FFh
.xdata$x:00009224                 dd offset __unwindfunclet$?_Orphan_all@_Container_base12@std@@QAEXXZ$0
.xdata$x:00009228 __ehfuncinfo$?_Orphan_all@_Container_base12@std@@QAEXXZ db  22h ; "
.xdata$x:00009228                                         ; DATA XREF: __ehhandler$?_Orphan_all@_Container_base12@std@@QAEXXZ+11o
.xdata$x:00009229                 db    5
.xdata$x:0000922A                 db  93h ; ô
.xdata$x:0000922B                 db  19h
.xdata$x:0000922C                 db    1
.xdata$x:0000922D                 db    0
.xdata$x:0000922E                 db    0
.xdata$x:0000922F                 db    0
.xdata$x:00009230                 dd offset __unwindtable$?_Orphan_all@_Container_base12@std@@QAEXXZ
.xdata$x:00009234                 db    0
.xdata$x:00009235                 db    0
.xdata$x:00009236                 db    0
.xdata$x:00009237                 db    0
.xdata$x:00009238                 db    0
.xdata$x:00009239                 db    0
.xdata$x:0000923A                 db    0
.xdata$x:0000923B                 db    0
.xdata$x:0000923C                 db    0
.xdata$x:0000923D                 db    0
.xdata$x:0000923E                 db    0
.xdata$x:0000923F                 db    0
.xdata$x:00009240                 db    0
.xdata$x:00009241                 db    0
.xdata$x:00009242                 db    0
.xdata$x:00009243                 db    0
.xdata$x:00009244                 db    0
.xdata$x:00009245                 db    0
.xdata$x:00009246                 db    0
.xdata$x:00009247                 db    0
.xdata$x:00009248                 db    0
.xdata$x:00009249                 db    0
.xdata$x:0000924A                 db    0
.xdata$x:0000924B                 db    0
.xdata$x:0000924B _xdata$x        ends
.xdata$x:0000924B
.xdata$x:0000924C ; ===========================================================================
.xdata$x:0000924C
.xdata$x:0000924C ; Segment type: Pure data
.xdata$x:0000924C ; Segment permissions: Read
.xdata$x:0000924C _xdata$x        segment dword public 'DATA' use32
.xdata$x:0000924C                 assume cs:_xdata$x
.xdata$x:0000924C                 ;org 924Ch
.xdata$x:0000924C ; COMDAT (pick associative to section at 754C)
.xdata$x:0000924C __unwindtable$?_Swap_all@_Container_base12@std@@QAEXAAU12@@Z db 0FFh
.xdata$x:0000924C                                         ; DATA XREF: .xdata$x:0000925Co
.xdata$x:0000924D                 db 0FFh
.xdata$x:0000924E                 db 0FFh
.xdata$x:0000924F                 db 0FFh
.xdata$x:00009250                 dd offset __unwindfunclet$?_Swap_all@_Container_base12@std@@QAEXAAU12@@Z$0
.xdata$x:00009254 __ehfuncinfo$?_Swap_all@_Container_base12@std@@QAEXAAU12@@Z db  22h ; "
.xdata$x:00009254                                         ; DATA XREF: __ehhandler$?_Swap_all@_Container_base12@std@@QAEXAAU12@@Z+11o
.xdata$x:00009255                 db    5
.xdata$x:00009256                 db  93h ; ô
.xdata$x:00009257                 db  19h
.xdata$x:00009258                 db    1
.xdata$x:00009259                 db    0
.xdata$x:0000925A                 db    0
.xdata$x:0000925B                 db    0
.xdata$x:0000925C                 dd offset __unwindtable$?_Swap_all@_Container_base12@std@@QAEXAAU12@@Z
.xdata$x:00009260                 db    0
.xdata$x:00009261                 db    0
.xdata$x:00009262                 db    0
.xdata$x:00009263                 db    0
.xdata$x:00009264                 db    0
.xdata$x:00009265                 db    0
.xdata$x:00009266                 db    0
.xdata$x:00009267                 db    0
.xdata$x:00009268                 db    0
.xdata$x:00009269                 db    0
.xdata$x:0000926A                 db    0
.xdata$x:0000926B                 db    0
.xdata$x:0000926C                 db    0
.xdata$x:0000926D                 db    0
.xdata$x:0000926E                 db    0
.xdata$x:0000926F                 db    0
.xdata$x:00009270                 db    0
.xdata$x:00009271                 db    0
.xdata$x:00009272                 db    0
.xdata$x:00009273                 db    0
.xdata$x:00009274                 db    0
.xdata$x:00009275                 db    0
.xdata$x:00009276                 db    0
.xdata$x:00009277                 db    0
.xdata$x:00009277 _xdata$x        ends
.xdata$x:00009277
.xdata$x:00009278 ; ===========================================================================
.xdata$x:00009278
.xdata$x:00009278 ; Segment type: Pure data
.xdata$x:00009278 ; Segment permissions: Read
.xdata$x:00009278 _xdata$x        segment dword public 'DATA' use32
.xdata$x:00009278                 assume cs:_xdata$x
.xdata$x:00009278                 ;org 9278h
.xdata$x:00009278 ; COMDAT (pick associative to section at 5890)
.xdata$x:00009278 __unwindtable$??4_Iterator_base12@std@@QAEAAU01@ABU01@@Z db 0FFh
.xdata$x:00009278                                         ; DATA XREF: .xdata$x:00009288o
.xdata$x:00009279                 db 0FFh
.xdata$x:0000927A                 db 0FFh
.xdata$x:0000927B                 db 0FFh
.xdata$x:0000927C                 dd offset __unwindfunclet$??4_Iterator_base12@std@@QAEAAU01@ABU01@@Z$0
.xdata$x:00009280 __ehfuncinfo$??4_Iterator_base12@std@@QAEAAU01@ABU01@@Z db  22h ; "
.xdata$x:00009280                                         ; DATA XREF: __ehhandler$??4_Iterator_base12@std@@QAEAAU01@ABU01@@Z+11o
.xdata$x:00009281                 db    5
.xdata$x:00009282                 db  93h ; ô
.xdata$x:00009283                 db  19h
.xdata$x:00009284                 db    1
.xdata$x:00009285                 db    0
.xdata$x:00009286                 db    0
.xdata$x:00009287                 db    0
.xdata$x:00009288                 dd offset __unwindtable$??4_Iterator_base12@std@@QAEAAU01@ABU01@@Z
.xdata$x:0000928C                 db    0
.xdata$x:0000928D                 db    0
.xdata$x:0000928E                 db    0
.xdata$x:0000928F                 db    0
.xdata$x:00009290                 db    0
.xdata$x:00009291                 db    0
.xdata$x:00009292                 db    0
.xdata$x:00009293                 db    0
.xdata$x:00009294                 db    0
.xdata$x:00009295                 db    0
.xdata$x:00009296                 db    0
.xdata$x:00009297                 db    0
.xdata$x:00009298                 db    0
.xdata$x:00009299                 db    0
.xdata$x:0000929A                 db    0
.xdata$x:0000929B                 db    0
.xdata$x:0000929C                 db    0
.xdata$x:0000929D                 db    0
.xdata$x:0000929E                 db    0
.xdata$x:0000929F                 db    0
.xdata$x:000092A0                 db    0
.xdata$x:000092A1                 db    0
.xdata$x:000092A2                 db    0
.xdata$x:000092A3                 db    0
.xdata$x:000092A3 _xdata$x        ends
.xdata$x:000092A3
.xdata$x:000092A4 ; ===========================================================================
.xdata$x:000092A4
.xdata$x:000092A4 ; Segment type: Pure data
.xdata$x:000092A4 ; Segment permissions: Read
.xdata$x:000092A4 _xdata$x        segment dword public 'DATA' use32
.xdata$x:000092A4                 assume cs:_xdata$x
.xdata$x:000092A4                 ;org 92A4h
.xdata$x:000092A4 ; COMDAT (pick associative to section at 5778)
.xdata$x:000092A4 __unwindtable$??1_Iterator_base12@std@@QAE@XZ db 0FFh
.xdata$x:000092A4                                         ; DATA XREF: .xdata$x:000092B4o
.xdata$x:000092A5                 db 0FFh
.xdata$x:000092A6                 db 0FFh
.xdata$x:000092A7                 db 0FFh
.xdata$x:000092A8                 dd offset __unwindfunclet$??1_Iterator_base12@std@@QAE@XZ$0
.xdata$x:000092AC __ehfuncinfo$??1_Iterator_base12@std@@QAE@XZ db  22h ; "
.xdata$x:000092AC                                         ; DATA XREF: __ehhandler$??1_Iterator_base12@std@@QAE@XZ+11o
.xdata$x:000092AD                 db    5
.xdata$x:000092AE                 db  93h ; ô
.xdata$x:000092AF                 db  19h
.xdata$x:000092B0                 db    1
.xdata$x:000092B1                 db    0
.xdata$x:000092B2                 db    0
.xdata$x:000092B3                 db    0
.xdata$x:000092B4                 dd offset __unwindtable$??1_Iterator_base12@std@@QAE@XZ
.xdata$x:000092B8                 db    0
.xdata$x:000092B9                 db    0
.xdata$x:000092BA                 db    0
.xdata$x:000092BB                 db    0
.xdata$x:000092BC                 db    0
.xdata$x:000092BD                 db    0
.xdata$x:000092BE                 db    0
.xdata$x:000092BF                 db    0
.xdata$x:000092C0                 db    0
.xdata$x:000092C1                 db    0
.xdata$x:000092C2                 db    0
.xdata$x:000092C3                 db    0
.xdata$x:000092C4                 db    0
.xdata$x:000092C5                 db    0
.xdata$x:000092C6                 db    0
.xdata$x:000092C7                 db    0
.xdata$x:000092C8                 db    0
.xdata$x:000092C9                 db    0
.xdata$x:000092CA                 db    0
.xdata$x:000092CB                 db    0
.xdata$x:000092CC                 db    0
.xdata$x:000092CD                 db    0
.xdata$x:000092CE                 db    0
.xdata$x:000092CF                 db    0
.xdata$x:000092CF _xdata$x        ends
.xdata$x:000092CF
.xdata$x:000092D0 ; ===========================================================================
.xdata$x:000092D0
.xdata$x:000092D0 ; Segment type: Pure data
.xdata$x:000092D0 ; Segment permissions: Read
.xdata$x:000092D0 _xdata$x        segment dword public 'DATA' use32
.xdata$x:000092D0                 assume cs:_xdata$x
.xdata$x:000092D0                 ;org 92D0h
.xdata$x:000092D0 ; COMDAT (pick associative to section at 5E38)
.xdata$x:000092D0 __unwindtable$?_Adopt@_Iterator_base12@std@@QAEXPBU_Container_base12@2@@Z db 0FFh
.xdata$x:000092D0                                         ; DATA XREF: .xdata$x:000092E8o
.xdata$x:000092D1                 db 0FFh
.xdata$x:000092D2                 db 0FFh
.xdata$x:000092D3                 db 0FFh
.xdata$x:000092D4                 dd offset __unwindfunclet$?_Adopt@_Iterator_base12@std@@QAEXPBU_Container_base12@2@@Z$0
.xdata$x:000092D8                 db 0FFh
.xdata$x:000092D9                 db 0FFh
.xdata$x:000092DA                 db 0FFh
.xdata$x:000092DB                 db 0FFh
.xdata$x:000092DC                 dd offset __unwindfunclet$?_Adopt@_Iterator_base12@std@@QAEXPBU_Container_base12@2@@Z$1
.xdata$x:000092E0 __ehfuncinfo$?_Adopt@_Iterator_base12@std@@QAEXPBU_Container_base12@2@@Z db  22h ; "
.xdata$x:000092E0                                         ; DATA XREF: __ehhandler$?_Adopt@_Iterator_base12@std@@QAEXPBU_Container_base12@2@@Z+11o
.xdata$x:000092E1                 db    5
.xdata$x:000092E2                 db  93h ; ô
.xdata$x:000092E3                 db  19h
.xdata$x:000092E4                 db    2
.xdata$x:000092E5                 db    0
.xdata$x:000092E6                 db    0
.xdata$x:000092E7                 db    0
.xdata$x:000092E8                 dd offset __unwindtable$?_Adopt@_Iterator_base12@std@@QAEXPBU_Container_base12@2@@Z
.xdata$x:000092EC                 db    0
.xdata$x:000092ED                 db    0
.xdata$x:000092EE                 db    0
.xdata$x:000092EF                 db    0
.xdata$x:000092F0                 db    0
.xdata$x:000092F1                 db    0
.xdata$x:000092F2                 db    0
.xdata$x:000092F3                 db    0
.xdata$x:000092F4                 db    0
.xdata$x:000092F5                 db    0
.xdata$x:000092F6                 db    0
.xdata$x:000092F7                 db    0
.xdata$x:000092F8                 db    0
.xdata$x:000092F9                 db    0
.xdata$x:000092FA                 db    0
.xdata$x:000092FB                 db    0
.xdata$x:000092FC                 db    0
.xdata$x:000092FD                 db    0
.xdata$x:000092FE                 db    0
.xdata$x:000092FF                 db    0
.xdata$x:00009300                 db    0
.xdata$x:00009301                 db    0
.xdata$x:00009302                 db    0
.xdata$x:00009303                 db    0
.xdata$x:00009303 _xdata$x        ends
.xdata$x:00009303
.xdata$x:00009304 ; ===========================================================================
.xdata$x:00009304
.xdata$x:00009304 ; Segment type: Pure data
.xdata$x:00009304 ; Segment permissions: Read
.xdata$x:00009304 _xdata$x        segment dword public 'DATA' use32
.xdata$x:00009304                 assume cs:_xdata$x
.xdata$x:00009304                 ;org 9304h
.xdata$x:00009304 ; COMDAT (pick associative to section at 4020)
.xdata$x:00009304 __unwindtable$??0?$_String_val@U?$_Simple_types@D@std@@@std@@QAE@XZ db 0FFh
.xdata$x:00009304                                         ; DATA XREF: .xdata$x:00009314o
.xdata$x:00009305                 db 0FFh
.xdata$x:00009306                 db 0FFh
.xdata$x:00009307                 db 0FFh
.xdata$x:00009308                 dd offset __unwindfunclet$??0?$_String_val@U?$_Simple_types@D@std@@@std@@QAE@XZ$0
.xdata$x:0000930C __ehfuncinfo$??0?$_String_val@U?$_Simple_types@D@std@@@std@@QAE@XZ db  22h ; "
.xdata$x:0000930C                                         ; DATA XREF: __ehhandler$??0?$_String_val@U?$_Simple_types@D@std@@@std@@QAE@XZ+11o
.xdata$x:0000930D                 db    5
.xdata$x:0000930E                 db  93h ; ô
.xdata$x:0000930F                 db  19h
.xdata$x:00009310                 db    1
.xdata$x:00009311                 db    0
.xdata$x:00009312                 db    0
.xdata$x:00009313                 db    0
.xdata$x:00009314                 dd offset __unwindtable$??0?$_String_val@U?$_Simple_types@D@std@@@std@@QAE@XZ
.xdata$x:00009318                 db    0
.xdata$x:00009319                 db    0
.xdata$x:0000931A                 db    0
.xdata$x:0000931B                 db    0
.xdata$x:0000931C                 db    0
.xdata$x:0000931D                 db    0
.xdata$x:0000931E                 db    0
.xdata$x:0000931F                 db    0
.xdata$x:00009320                 db    0
.xdata$x:00009321                 db    0
.xdata$x:00009322                 db    0
.xdata$x:00009323                 db    0
.xdata$x:00009324                 db    0
.xdata$x:00009325                 db    0
.xdata$x:00009326                 db    0
.xdata$x:00009327                 db    0
.xdata$x:00009328                 db    0
.xdata$x:00009329                 db    0
.xdata$x:0000932A                 db    0
.xdata$x:0000932B                 db    0
.xdata$x:0000932C                 db    0
.xdata$x:0000932D                 db    0
.xdata$x:0000932E                 db    0
.xdata$x:0000932F                 db    0
.xdata$x:0000932F _xdata$x        ends
.xdata$x:0000932F
.xdata$x:00009330 ; ===========================================================================
.xdata$x:00009330
.xdata$x:00009330 ; Segment type: Pure data
.xdata$x:00009330 ; Segment permissions: Read
.xdata$x:00009330 _xdata$x        segment dword public 'DATA' use32
.xdata$x:00009330                 assume cs:_xdata$x
.xdata$x:00009330                 ;org 9330h
.xdata$x:00009330 ; COMDAT (pick associative to section at 5028)
.xdata$x:00009330 __unwindtable$??1?$_String_val@U?$_Simple_types@D@std@@@std@@QAE@XZ db 0FFh
.xdata$x:00009330                                         ; DATA XREF: .xdata$x:00009340o
.xdata$x:00009331                 db 0FFh
.xdata$x:00009332                 db 0FFh
.xdata$x:00009333                 db 0FFh
.xdata$x:00009334                 dd offset __unwindfunclet$??1?$_String_val@U?$_Simple_types@D@std@@@std@@QAE@XZ$0
.xdata$x:00009338 __ehfuncinfo$??1?$_String_val@U?$_Simple_types@D@std@@@std@@QAE@XZ db  22h ; "
.xdata$x:00009338                                         ; DATA XREF: __ehhandler$??1?$_String_val@U?$_Simple_types@D@std@@@std@@QAE@XZ+11o
.xdata$x:00009339                 db    5
.xdata$x:0000933A                 db  93h ; ô
.xdata$x:0000933B                 db  19h
.xdata$x:0000933C                 db    1
.xdata$x:0000933D                 db    0
.xdata$x:0000933E                 db    0
.xdata$x:0000933F                 db    0
.xdata$x:00009340                 dd offset __unwindtable$??1?$_String_val@U?$_Simple_types@D@std@@@std@@QAE@XZ
.xdata$x:00009344                 db    0
.xdata$x:00009345                 db    0
.xdata$x:00009346                 db    0
.xdata$x:00009347                 db    0
.xdata$x:00009348                 db    0
.xdata$x:00009349                 db    0
.xdata$x:0000934A                 db    0
.xdata$x:0000934B                 db    0
.xdata$x:0000934C                 db    0
.xdata$x:0000934D                 db    0
.xdata$x:0000934E                 db    0
.xdata$x:0000934F                 db    0
.xdata$x:00009350                 db    0
.xdata$x:00009351                 db    0
.xdata$x:00009352                 db    0
.xdata$x:00009353                 db    0
.xdata$x:00009354                 db    0
.xdata$x:00009355                 db    0
.xdata$x:00009356                 db    0
.xdata$x:00009357                 db    0
.xdata$x:00009358                 db    0
.xdata$x:00009359                 db    0
.xdata$x:0000935A                 db    0
.xdata$x:0000935B                 db    0
.xdata$x:0000935B _xdata$x        ends
.xdata$x:0000935B
.xdata$x:0000935C ; ===========================================================================
.xdata$x:0000935C
.xdata$x:0000935C ; Segment type: Pure data
.xdata$x:0000935C ; Segment permissions: Read
.xdata$x:0000935C _xdata$x        segment dword public 'DATA' use32
.xdata$x:0000935C                 assume cs:_xdata$x
.xdata$x:0000935C                 ;org 935Ch
.xdata$x:0000935C ; COMDAT (pick associative to section at 3FA4)
.xdata$x:0000935C __unwindtable$??0?$_String_alloc@$0A@U?$_String_base_types@DV?$allocator@D@std@@@std@@@std@@QAE@ABV?$allocator@D@1@@Z db 0FFh
.xdata$x:0000935C                                         ; DATA XREF: .xdata$x:0000936Co
.xdata$x:0000935D                 db 0FFh
.xdata$x:0000935E                 db 0FFh
.xdata$x:0000935F                 db 0FFh
.xdata$x:00009360                 dd offset __unwindfunclet$??0?$_String_alloc@$0A@U?$_String_base_types@DV?$allocator@D@std@@@std@@@std@@QAE@ABV?$allocator@D@1@@Z$0
.xdata$x:00009364 __ehfuncinfo$??0?$_String_alloc@$0A@U?$_String_base_types@DV?$allocator@D@std@@@std@@@std@@QAE@ABV?$allocator@D@1@@Z db  22h ; "
.xdata$x:00009364                                         ; DATA XREF: __ehhandler$??0?$_String_alloc@$0A@U?$_String_base_types@DV?$allocator@D@std@@@std@@@std@@QAE@ABV?$allocator@D@1@@Z+11o
.xdata$x:00009365                 db    5
.xdata$x:00009366                 db  93h ; ô
.xdata$x:00009367                 db  19h
.xdata$x:00009368                 db    1
.xdata$x:00009369                 db    0
.xdata$x:0000936A                 db    0
.xdata$x:0000936B                 db    0
.xdata$x:0000936C                 dd offset __unwindtable$??0?$_String_alloc@$0A@U?$_String_base_types@DV?$allocator@D@std@@@std@@@std@@QAE@ABV?$allocator@D@1@@Z
.xdata$x:00009370                 db    0
.xdata$x:00009371                 db    0
.xdata$x:00009372                 db    0
.xdata$x:00009373                 db    0
.xdata$x:00009374                 db    0
.xdata$x:00009375                 db    0
.xdata$x:00009376                 db    0
.xdata$x:00009377                 db    0
.xdata$x:00009378                 db    0
.xdata$x:00009379                 db    0
.xdata$x:0000937A                 db    0
.xdata$x:0000937B                 db    0
.xdata$x:0000937C                 db    0
.xdata$x:0000937D                 db    0
.xdata$x:0000937E                 db    0
.xdata$x:0000937F                 db    0
.xdata$x:00009380                 db    0
.xdata$x:00009381                 db    0
.xdata$x:00009382                 db    0
.xdata$x:00009383                 db    0
.xdata$x:00009384                 db    0
.xdata$x:00009385                 db    0
.xdata$x:00009386                 db    0
.xdata$x:00009387                 db    0
.xdata$x:00009387 _xdata$x        ends
.xdata$x:00009387
.xdata$x:00009388 ; ===========================================================================
.xdata$x:00009388
.xdata$x:00009388 ; Segment type: Pure data
.xdata$x:00009388 ; Segment permissions: Read
.xdata$x:00009388 _xdata$x        segment dword public 'DATA' use32
.xdata$x:00009388                 assume cs:_xdata$x
.xdata$x:00009388                 ;org 9388h
.xdata$x:00009388 ; COMDAT (pick associative to section at 4FB0)
.xdata$x:00009388 __unwindtable$??1?$_String_alloc@$0A@U?$_String_base_types@DV?$allocator@D@std@@@std@@@std@@QAE@XZ db 0FFh
.xdata$x:00009388                                         ; DATA XREF: .xdata$x:00009398o
.xdata$x:00009389                 db 0FFh
.xdata$x:0000938A                 db 0FFh
.xdata$x:0000938B                 db 0FFh
.xdata$x:0000938C                 dd offset __unwindfunclet$??1?$_String_alloc@$0A@U?$_String_base_types@DV?$allocator@D@std@@@std@@@std@@QAE@XZ$0
.xdata$x:00009390 __ehfuncinfo$??1?$_String_alloc@$0A@U?$_String_base_types@DV?$allocator@D@std@@@std@@@std@@QAE@XZ db  22h ; "
.xdata$x:00009390                                         ; DATA XREF: __ehhandler$??1?$_String_alloc@$0A@U?$_String_base_types@DV?$allocator@D@std@@@std@@@std@@QAE@XZ+11o
.xdata$x:00009391                 db    5
.xdata$x:00009392                 db  93h ; ô
.xdata$x:00009393                 db  19h
.xdata$x:00009394                 db    1
.xdata$x:00009395                 db    0
.xdata$x:00009396                 db    0
.xdata$x:00009397                 db    0
.xdata$x:00009398                 dd offset __unwindtable$??1?$_String_alloc@$0A@U?$_String_base_types@DV?$allocator@D@std@@@std@@@std@@QAE@XZ
.xdata$x:0000939C                 db    0
.xdata$x:0000939D                 db    0
.xdata$x:0000939E                 db    0
.xdata$x:0000939F                 db    0
.xdata$x:000093A0                 db    0
.xdata$x:000093A1                 db    0
.xdata$x:000093A2                 db    0
.xdata$x:000093A3                 db    0
.xdata$x:000093A4                 db    0
.xdata$x:000093A5                 db    0
.xdata$x:000093A6                 db    0
.xdata$x:000093A7                 db    0
.xdata$x:000093A8                 db    0
.xdata$x:000093A9                 db    0
.xdata$x:000093AA                 db    0
.xdata$x:000093AB                 db    0
.xdata$x:000093AC                 db    0
.xdata$x:000093AD                 db    0
.xdata$x:000093AE                 db    0
.xdata$x:000093AF                 db    0
.xdata$x:000093B0                 db    0
.xdata$x:000093B1                 db    0
.xdata$x:000093B2                 db    0
.xdata$x:000093B3                 db    0
.xdata$x:000093B3 _xdata$x        ends
.xdata$x:000093B3
.xdata$x:000093B4 ; ===========================================================================
.xdata$x:000093B4
.xdata$x:000093B4 ; Segment type: Pure data
.xdata$x:000093B4 ; Segment permissions: Read
.xdata$x:000093B4 _xdata$x        segment dword public 'DATA' use32
.xdata$x:000093B4                 assume cs:_xdata$x
.xdata$x:000093B4                 ;org 93B4h
.xdata$x:000093B4 ; COMDAT (pick associative to section at 47FC)
.xdata$x:000093B4 __unwindtable$??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@PBD@Z db 0FFh
.xdata$x:000093B4                                         ; DATA XREF: .xdata$x:000093C4o
.xdata$x:000093B5                 db 0FFh
.xdata$x:000093B6                 db 0FFh
.xdata$x:000093B7                 db 0FFh
.xdata$x:000093B8                 dd offset __unwindfunclet$??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@PBD@Z$0
.xdata$x:000093BC __ehfuncinfo$??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@PBD@Z db  22h ; "
.xdata$x:000093BC                                         ; DATA XREF: __ehhandler$??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@PBD@Z+11o
.xdata$x:000093BD                 db    5
.xdata$x:000093BE                 db  93h ; ô
.xdata$x:000093BF                 db  19h
.xdata$x:000093C0                 db    1
.xdata$x:000093C1                 db    0
.xdata$x:000093C2                 db    0
.xdata$x:000093C3                 db    0
.xdata$x:000093C4                 dd offset __unwindtable$??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@PBD@Z
.xdata$x:000093C8                 align 20h
.xdata$x:000093C8 _xdata$x        ends
.xdata$x:000093C8
.xdata$x:000093E0 ; ===========================================================================
.xdata$x:000093E0
.xdata$x:000093E0 ; Segment type: Pure data
.xdata$x:000093E0 ; Segment permissions: Read
.xdata$x:000093E0 _xdata$x        segment dword public 'DATA' use32
.xdata$x:000093E0                 assume cs:_xdata$x
.xdata$x:000093E0                 ;org 93E0h
.xdata$x:000093E0 ; COMDAT (pick associative to section at 54A0)
.xdata$x:000093E0 __unwindtable$??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ db 0FFh
.xdata$x:000093E0                                         ; DATA XREF: .xdata$x:000093F0o
.xdata$x:000093E1                 db 0FFh
.xdata$x:000093E2                 db 0FFh
.xdata$x:000093E3                 db 0FFh
.xdata$x:000093E4                 dd offset __unwindfunclet$??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ$0
.xdata$x:000093E8 __ehfuncinfo$??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ db  22h ; "
.xdata$x:000093E8                                         ; DATA XREF: __ehhandler$??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ+11o
.xdata$x:000093E9                 db    5
.xdata$x:000093EA                 db  93h ; ô
.xdata$x:000093EB                 db  19h
.xdata$x:000093EC                 db    1
.xdata$x:000093ED                 db    0
.xdata$x:000093EE                 db    0
.xdata$x:000093EF                 db    0
.xdata$x:000093F0                 dd offset __unwindtable$??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ
.xdata$x:000093F4                 db    0
.xdata$x:000093F5                 db    0
.xdata$x:000093F6                 db    0
.xdata$x:000093F7                 db    0
.xdata$x:000093F8                 db    0
.xdata$x:000093F9                 db    0
.xdata$x:000093FA                 db    0
.xdata$x:000093FB                 db    0
.xdata$x:000093FC                 db    0
.xdata$x:000093FD                 db    0
.xdata$x:000093FE                 db    0
.xdata$x:000093FF                 db    0
.xdata$x:00009400                 db    0
.xdata$x:00009401                 db    0
.xdata$x:00009402                 db    0
.xdata$x:00009403                 db    0
.xdata$x:00009404                 db    0
.xdata$x:00009405                 db    0
.xdata$x:00009406                 db    0
.xdata$x:00009407                 db    0
.xdata$x:00009408                 db    0
.xdata$x:00009409                 db    0
.xdata$x:0000940A                 db    0
.xdata$x:0000940B                 db    0
.xdata$x:0000940B _xdata$x        ends
.xdata$x:0000940B
.xdata$x:0000940C ; ===========================================================================
.xdata$x:0000940C
.xdata$x:0000940C ; Segment type: Pure data
.xdata$x:0000940C ; Segment permissions: Read
.xdata$x:0000940C _xdata$x        segment dword public 'DATA' use32
.xdata$x:0000940C                 assume cs:_xdata$x
.xdata$x:0000940C                 ;org 940Ch
.xdata$x:0000940C ; COMDAT (pick associative to section at 6144)
.xdata$x:0000940C __catchsym$?_Copy@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEXII@Z$5 db    0
.xdata$x:0000940C                                         ; DATA XREF: .xdata$x:00009494o
.xdata$x:0000940D                 db    0
.xdata$x:0000940E                 db    0
.xdata$x:0000940F                 db    0
.xdata$x:00009410                 db    0
.xdata$x:00009411                 db    0
.xdata$x:00009412                 db    0
.xdata$x:00009413                 db    0
.xdata$x:00009414                 db    0
.xdata$x:00009415                 db    0
.xdata$x:00009416                 db    0
.xdata$x:00009417                 db    0
.xdata$x:00009418                 dd offset __catch$?_Copy@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEXII@Z$0
.xdata$x:0000941C __catchsym$?_Copy@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEXII@Z$4 db    0
.xdata$x:0000941C                                         ; DATA XREF: .xdata$x:00009480o
.xdata$x:0000941D                 db    0
.xdata$x:0000941E                 db    0
.xdata$x:0000941F                 db    0
.xdata$x:00009420                 db    0
.xdata$x:00009421                 db    0
.xdata$x:00009422                 db    0
.xdata$x:00009423                 db    0
.xdata$x:00009424                 db    0
.xdata$x:00009425                 db    0
.xdata$x:00009426                 db    0
.xdata$x:00009427                 db    0
.xdata$x:00009428                 dd offset __catch$?_Copy@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEXII@Z$1
.xdata$x:0000942C __unwindtable$?_Copy@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEXII@Z db 0FFh
.xdata$x:0000942C                                         ; DATA XREF: .xdata$x:00009454o
.xdata$x:0000942D                 db 0FFh
.xdata$x:0000942E                 db 0FFh
.xdata$x:0000942F                 db 0FFh
.xdata$x:00009430                 db    0
.xdata$x:00009431                 db    0
.xdata$x:00009432                 db    0
.xdata$x:00009433                 db    0
.xdata$x:00009434                 db 0FFh
.xdata$x:00009435                 db 0FFh
.xdata$x:00009436                 db 0FFh
.xdata$x:00009437                 db 0FFh
.xdata$x:00009438                 db    0
.xdata$x:00009439                 db    0
.xdata$x:0000943A                 db    0
.xdata$x:0000943B                 db    0
.xdata$x:0000943C                 db    1
.xdata$x:0000943D                 db    0
.xdata$x:0000943E                 db    0
.xdata$x:0000943F                 db    0
.xdata$x:00009440                 db    0
.xdata$x:00009441                 db    0
.xdata$x:00009442                 db    0
.xdata$x:00009443                 db    0
.xdata$x:00009444                 db    1
.xdata$x:00009445                 db    0
.xdata$x:00009446                 db    0
.xdata$x:00009447                 db    0
.xdata$x:00009448                 db    0
.xdata$x:00009449                 db    0
.xdata$x:0000944A                 db    0
.xdata$x:0000944B                 db    0
.xdata$x:0000944C __ehfuncinfo$?_Copy@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEXII@Z db  22h ; "
.xdata$x:0000944C                                         ; DATA XREF: __ehhandler$?_Copy@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEXII@Z+11o
.xdata$x:0000944D                 db    5
.xdata$x:0000944E                 db  93h ; ô
.xdata$x:0000944F                 db  19h
.xdata$x:00009450                 db    4
.xdata$x:00009451                 db    0
.xdata$x:00009452                 db    0
.xdata$x:00009453                 db    0
.xdata$x:00009454                 dd offset __unwindtable$?_Copy@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEXII@Z
.xdata$x:00009458                 db    2
.xdata$x:00009459                 db    0
.xdata$x:0000945A                 db    0
.xdata$x:0000945B                 db    0
.xdata$x:0000945C                 dd offset __tryblocktable$?_Copy@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEXII@Z
.xdata$x:00009460                 db    0
.xdata$x:00009461                 db    0
.xdata$x:00009462                 db    0
.xdata$x:00009463                 db    0
.xdata$x:00009464                 db    0
.xdata$x:00009465                 db    0
.xdata$x:00009466                 db    0
.xdata$x:00009467                 db    0
.xdata$x:00009468                 db    0
.xdata$x:00009469                 db    0
.xdata$x:0000946A                 db    0
.xdata$x:0000946B                 db    0
.xdata$x:0000946C                 db    0
.xdata$x:0000946D                 db    0
.xdata$x:0000946E                 db    0
.xdata$x:0000946F                 db    0
.xdata$x:00009470 __tryblocktable$?_Copy@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEXII@Z db    2
.xdata$x:00009470                                         ; DATA XREF: .xdata$x:0000945Co
.xdata$x:00009471                 db    0
.xdata$x:00009472                 db    0
.xdata$x:00009473                 db    0
.xdata$x:00009474                 db    2
.xdata$x:00009475                 db    0
.xdata$x:00009476                 db    0
.xdata$x:00009477                 db    0
.xdata$x:00009478                 db    3
.xdata$x:00009479                 db    0
.xdata$x:0000947A                 db    0
.xdata$x:0000947B                 db    0
.xdata$x:0000947C                 db    1
.xdata$x:0000947D                 db    0
.xdata$x:0000947E                 db    0
.xdata$x:0000947F                 db    0
.xdata$x:00009480                 dd offset __catchsym$?_Copy@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEXII@Z$4
.xdata$x:00009484                 db    0
.xdata$x:00009485                 db    0
.xdata$x:00009486                 db    0
.xdata$x:00009487                 db    0
.xdata$x:00009488                 db    0
.xdata$x:00009489                 db    0
.xdata$x:0000948A                 db    0
.xdata$x:0000948B                 db    0
.xdata$x:0000948C                 db    3
.xdata$x:0000948D                 db    0
.xdata$x:0000948E                 db    0
.xdata$x:0000948F                 db    0
.xdata$x:00009490                 db    1
.xdata$x:00009491                 db    0
.xdata$x:00009492                 db    0
.xdata$x:00009493                 db    0
.xdata$x:00009494                 dd offset __catchsym$?_Copy@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEXII@Z$5
.xdata$x:00009494 _xdata$x        ends
.xdata$x:00009494
.xdata$x:00009498 ; ===========================================================================
.xdata$x:00009498
.xdata$x:00009498 ; Segment type: Pure data
.xdata$x:00009498 ; Segment permissions: Read
.xdata$x:00009498 _xdata$x        segment dword public 'DATA' use32
.xdata$x:00009498                 assume cs:_xdata$x
.xdata$x:00009498                 ;org 9498h
.xdata$x:00009498 ; COMDAT (pick associative to section at 4CA4)
.xdata$x:00009498 __unwindtable$??0_Generic_error_category@std@@QAE@XZ db 0FFh
.xdata$x:00009498                                         ; DATA XREF: .xdata$x:000094A8o
.xdata$x:00009499                 db 0FFh
.xdata$x:0000949A                 db 0FFh
.xdata$x:0000949B                 db 0FFh
.xdata$x:0000949C                 dd offset __unwindfunclet$??0_Generic_error_category@std@@QAE@XZ$0
.xdata$x:000094A0 __ehfuncinfo$??0_Generic_error_category@std@@QAE@XZ db  22h ; "
.xdata$x:000094A0                                         ; DATA XREF: __ehhandler$??0_Generic_error_category@std@@QAE@XZ+11o
.xdata$x:000094A1                 db    5
.xdata$x:000094A2                 db  93h ; ô
.xdata$x:000094A3                 db  19h
.xdata$x:000094A4                 db    1
.xdata$x:000094A5                 db    0
.xdata$x:000094A6                 db    0
.xdata$x:000094A7                 db    0
.xdata$x:000094A8                 dd offset __unwindtable$??0_Generic_error_category@std@@QAE@XZ
.xdata$x:000094AC                 db    0
.xdata$x:000094AD                 db    0
.xdata$x:000094AE                 db    0
.xdata$x:000094AF                 db    0
.xdata$x:000094B0                 db    0
.xdata$x:000094B1                 db    0
.xdata$x:000094B2                 db    0
.xdata$x:000094B3                 db    0
.xdata$x:000094B4                 db    0
.xdata$x:000094B5                 db    0
.xdata$x:000094B6                 db    0
.xdata$x:000094B7                 db    0
.xdata$x:000094B8                 db    0
.xdata$x:000094B9                 db    0
.xdata$x:000094BA                 db    0
.xdata$x:000094BB                 db    0
.xdata$x:000094BC                 db    0
.xdata$x:000094BD                 db    0
.xdata$x:000094BE                 db    0
.xdata$x:000094BF                 db    0
.xdata$x:000094C0                 db    0
.xdata$x:000094C1                 db    0
.xdata$x:000094C2                 db    0
.xdata$x:000094C3                 db    0
.xdata$x:000094C3 _xdata$x        ends
.xdata$x:000094C3
.xdata$x:000094C4 ; ===========================================================================
.xdata$x:000094C4
.xdata$x:000094C4 ; Segment type: Pure data
.xdata$x:000094C4 ; Segment permissions: Read
.xdata$x:000094C4 _xdata$x        segment dword public 'DATA' use32
.xdata$x:000094C4                 assume cs:_xdata$x
.xdata$x:000094C4                 ;org 94C4h
.xdata$x:000094C4 ; COMDAT (pick associative to section at 89AC)
.xdata$x:000094C4 __unwindtable$?message@_Generic_error_category@std@@UBE?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@2@H@Z db 0FFh
.xdata$x:000094C4                                         ; DATA XREF: .xdata$x:000094D4o
.xdata$x:000094C5                 db 0FFh
.xdata$x:000094C6                 db 0FFh
.xdata$x:000094C7                 db 0FFh
.xdata$x:000094C8                 dd offset __unwindfunclet$?message@_Generic_error_category@std@@UBE?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@2@H@Z$0
.xdata$x:000094CC __ehfuncinfo$?message@_Generic_error_category@std@@UBE?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@2@H@Z db  22h ; "
.xdata$x:000094CC                                         ; DATA XREF: __ehhandler$?message@_Generic_error_category@std@@UBE?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@2@H@Z+11o
.xdata$x:000094CD                 db    5
.xdata$x:000094CE                 db  93h ; ô
.xdata$x:000094CF                 db  19h
.xdata$x:000094D0                 db    1
.xdata$x:000094D1                 db    0
.xdata$x:000094D2                 db    0
.xdata$x:000094D3                 db    0
.xdata$x:000094D4                 dd offset __unwindtable$?message@_Generic_error_category@std@@UBE?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@2@H@Z
.xdata$x:000094D8                 db    0
.xdata$x:000094D9                 db    0
.xdata$x:000094DA                 db    0
.xdata$x:000094DB                 db    0
.xdata$x:000094DC                 db    0
.xdata$x:000094DD                 db    0
.xdata$x:000094DE                 db    0
.xdata$x:000094DF                 db    0
.xdata$x:000094E0                 db    0
.xdata$x:000094E1                 db    0
.xdata$x:000094E2                 db    0
.xdata$x:000094E3                 db    0
.xdata$x:000094E4                 db    0
.xdata$x:000094E5                 db    0
.xdata$x:000094E6                 db    0
.xdata$x:000094E7                 db    0
.xdata$x:000094E8                 db    0
.xdata$x:000094E9                 db    0
.xdata$x:000094EA                 db    0
.xdata$x:000094EB                 db    0
.xdata$x:000094EC                 db    0
.xdata$x:000094ED                 db    0
.xdata$x:000094EE                 db    0
.xdata$x:000094EF                 db    0
.xdata$x:000094EF _xdata$x        ends
.xdata$x:000094EF
.xdata$x:000094F0 ; ===========================================================================
.xdata$x:000094F0
.xdata$x:000094F0 ; Segment type: Pure data
.xdata$x:000094F0 ; Segment permissions: Read
.xdata$x:000094F0 _xdata$x        segment dword public 'DATA' use32
.xdata$x:000094F0                 assume cs:_xdata$x
.xdata$x:000094F0                 ;org 94F0h
.xdata$x:000094F0 ; COMDAT (pick associative to section at 5698)
.xdata$x:000094F0 __unwindtable$??1_Generic_error_category@std@@UAE@XZ db 0FFh
.xdata$x:000094F0                                         ; DATA XREF: .xdata$x:00009500o
.xdata$x:000094F1                 db 0FFh
.xdata$x:000094F2                 db 0FFh
.xdata$x:000094F3                 db 0FFh
.xdata$x:000094F4                 dd offset __unwindfunclet$??1_Generic_error_category@std@@UAE@XZ$0
.xdata$x:000094F8 __ehfuncinfo$??1_Generic_error_category@std@@UAE@XZ db  22h ; "
.xdata$x:000094F8                                         ; DATA XREF: __ehhandler$??1_Generic_error_category@std@@UAE@XZ+11o
.xdata$x:000094F9                 db    5
.xdata$x:000094FA                 db  93h ; ô
.xdata$x:000094FB                 db  19h
.xdata$x:000094FC                 db    1
.xdata$x:000094FD                 db    0
.xdata$x:000094FE                 db    0
.xdata$x:000094FF                 db    0
.xdata$x:00009500                 dd offset __unwindtable$??1_Generic_error_category@std@@UAE@XZ
.xdata$x:00009504                 db    0
.xdata$x:00009505                 db    0
.xdata$x:00009506                 db    0
.xdata$x:00009507                 db    0
.xdata$x:00009508                 db    0
.xdata$x:00009509                 db    0
.xdata$x:0000950A                 db    0
.xdata$x:0000950B                 db    0
.xdata$x:0000950C                 db    0
.xdata$x:0000950D                 db    0
.xdata$x:0000950E                 db    0
.xdata$x:0000950F                 db    0
.xdata$x:00009510                 db    0
.xdata$x:00009511                 db    0
.xdata$x:00009512                 db    0
.xdata$x:00009513                 db    0
.xdata$x:00009514                 db    0
.xdata$x:00009515                 db    0
.xdata$x:00009516                 db    0
.xdata$x:00009517                 db    0
.xdata$x:00009518                 db    0
.xdata$x:00009519                 db    0
.xdata$x:0000951A                 db    0
.xdata$x:0000951B                 db    0
.xdata$x:0000951B _xdata$x        ends
.xdata$x:0000951B
.xdata$x:0000951C ; ===========================================================================
.xdata$x:0000951C
.xdata$x:0000951C ; Segment type: Pure data
.xdata$x:0000951C ; Segment permissions: Read
.xdata$x:0000951C _xdata$x        segment dword public 'DATA' use32
.xdata$x:0000951C                 assume cs:_xdata$x
.xdata$x:0000951C                 ;org 951Ch
.xdata$x:0000951C ; COMDAT (pick associative to section at 4D30)
.xdata$x:0000951C __unwindtable$??0_Iostream_error_category@std@@QAE@XZ db 0FFh
.xdata$x:0000951C                                         ; DATA XREF: .xdata$x:0000952Co
.xdata$x:0000951D                 db 0FFh
.xdata$x:0000951E                 db 0FFh
.xdata$x:0000951F                 db 0FFh
.xdata$x:00009520                 dd offset __unwindfunclet$??0_Iostream_error_category@std@@QAE@XZ$0
.xdata$x:00009524 __ehfuncinfo$??0_Iostream_error_category@std@@QAE@XZ db  22h ; "
.xdata$x:00009524                                         ; DATA XREF: __ehhandler$??0_Iostream_error_category@std@@QAE@XZ+11o
.xdata$x:00009525                 db    5
.xdata$x:00009526                 db  93h ; ô
.xdata$x:00009527                 db  19h
.xdata$x:00009528                 db    1
.xdata$x:00009529                 db    0
.xdata$x:0000952A                 db    0
.xdata$x:0000952B                 db    0
.xdata$x:0000952C                 dd offset __unwindtable$??0_Iostream_error_category@std@@QAE@XZ
.xdata$x:00009530                 db    0
.xdata$x:00009531                 db    0
.xdata$x:00009532                 db    0
.xdata$x:00009533                 db    0
.xdata$x:00009534                 db    0
.xdata$x:00009535                 db    0
.xdata$x:00009536                 db    0
.xdata$x:00009537                 db    0
.xdata$x:00009538                 db    0
.xdata$x:00009539                 db    0
.xdata$x:0000953A                 db    0
.xdata$x:0000953B                 db    0
.xdata$x:0000953C                 db    0
.xdata$x:0000953D                 db    0
.xdata$x:0000953E                 db    0
.xdata$x:0000953F                 db    0
.xdata$x:00009540                 db    0
.xdata$x:00009541                 db    0
.xdata$x:00009542                 db    0
.xdata$x:00009543                 db    0
.xdata$x:00009544                 db    0
.xdata$x:00009545                 db    0
.xdata$x:00009546                 db    0
.xdata$x:00009547                 db    0
.xdata$x:00009547 _xdata$x        ends
.xdata$x:00009547
.xdata$x:00009548 ; ===========================================================================
.xdata$x:00009548
.xdata$x:00009548 ; Segment type: Pure data
.xdata$x:00009548 ; Segment permissions: Read
.xdata$x:00009548 _xdata$x        segment dword public 'DATA' use32
.xdata$x:00009548                 assume cs:_xdata$x
.xdata$x:00009548                 ;org 9548h
.xdata$x:00009548 ; COMDAT (pick associative to section at 8A64)
.xdata$x:00009548 __unwindtable$?message@_Iostream_error_category@std@@UBE?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@2@H@Z db 0FFh
.xdata$x:00009548                                         ; DATA XREF: .xdata$x:00009558o
.xdata$x:00009549                 db 0FFh
.xdata$x:0000954A                 db 0FFh
.xdata$x:0000954B                 db 0FFh
.xdata$x:0000954C                 dd offset __unwindfunclet$?message@_Iostream_error_category@std@@UBE?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@2@H@Z$0
.xdata$x:00009550 __ehfuncinfo$?message@_Iostream_error_category@std@@UBE?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@2@H@Z db  22h ; "
.xdata$x:00009550                                         ; DATA XREF: __ehhandler$?message@_Iostream_error_category@std@@UBE?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@2@H@Z+11o
.xdata$x:00009551                 db    5
.xdata$x:00009552                 db  93h ; ô
.xdata$x:00009553                 db  19h
.xdata$x:00009554                 db    1
.xdata$x:00009555                 db    0
.xdata$x:00009556                 db    0
.xdata$x:00009557                 db    0
.xdata$x:00009558                 dd offset __unwindtable$?message@_Iostream_error_category@std@@UBE?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@2@H@Z
.xdata$x:0000955C                 db    0
.xdata$x:0000955D                 db    0
.xdata$x:0000955E                 db    0
.xdata$x:0000955F                 db    0
.xdata$x:00009560                 db    0
.xdata$x:00009561                 db    0
.xdata$x:00009562                 db    0
.xdata$x:00009563                 db    0
.xdata$x:00009564                 db    0
.xdata$x:00009565                 db    0
.xdata$x:00009566                 db    0
.xdata$x:00009567                 db    0
.xdata$x:00009568                 db    0
.xdata$x:00009569                 db    0
.xdata$x:0000956A                 db    0
.xdata$x:0000956B                 db    0
.xdata$x:0000956C                 db    0
.xdata$x:0000956D                 db    0
.xdata$x:0000956E                 db    0
.xdata$x:0000956F                 db    0
.xdata$x:00009570                 db    0
.xdata$x:00009571                 db    0
.xdata$x:00009572                 db    0
.xdata$x:00009573                 db    0
.xdata$x:00009573 _xdata$x        ends
.xdata$x:00009573
.xdata$x:00009574 ; ===========================================================================
.xdata$x:00009574
.xdata$x:00009574 ; Segment type: Pure data
.xdata$x:00009574 ; Segment permissions: Read
.xdata$x:00009574 _xdata$x        segment dword public 'DATA' use32
.xdata$x:00009574                 assume cs:_xdata$x
.xdata$x:00009574                 ;org 9574h
.xdata$x:00009574 ; COMDAT (pick associative to section at 5708)
.xdata$x:00009574 __unwindtable$??1_Iostream_error_category@std@@UAE@XZ db 0FFh
.xdata$x:00009574                                         ; DATA XREF: .xdata$x:00009584o
.xdata$x:00009575                 db 0FFh
.xdata$x:00009576                 db 0FFh
.xdata$x:00009577                 db 0FFh
.xdata$x:00009578                 dd offset __unwindfunclet$??1_Iostream_error_category@std@@UAE@XZ$0
.xdata$x:0000957C __ehfuncinfo$??1_Iostream_error_category@std@@UAE@XZ db  22h ; "
.xdata$x:0000957C                                         ; DATA XREF: __ehhandler$??1_Iostream_error_category@std@@UAE@XZ+11o
.xdata$x:0000957D                 db    5
.xdata$x:0000957E                 db  93h ; ô
.xdata$x:0000957F                 db  19h
.xdata$x:00009580                 db    1
.xdata$x:00009581                 db    0
.xdata$x:00009582                 db    0
.xdata$x:00009583                 db    0
.xdata$x:00009584                 dd offset __unwindtable$??1_Iostream_error_category@std@@UAE@XZ
.xdata$x:00009588                 align 20h
.xdata$x:00009588 _xdata$x        ends
.xdata$x:00009588
.xdata$x:000095A0 ; ===========================================================================
.xdata$x:000095A0
.xdata$x:000095A0 ; Segment type: Pure data
.xdata$x:000095A0 ; Segment permissions: Read
.xdata$x:000095A0 _xdata$x        segment dword public 'DATA' use32
.xdata$x:000095A0                 assume cs:_xdata$x
.xdata$x:000095A0                 ;org 95A0h
.xdata$x:000095A0 ; COMDAT (pick associative to section at 4E00)
.xdata$x:000095A0 __unwindtable$??0_System_error_category@std@@QAE@XZ db 0FFh
.xdata$x:000095A0                                         ; DATA XREF: .xdata$x:000095B0o
.xdata$x:000095A1                 db 0FFh
.xdata$x:000095A2                 db 0FFh
.xdata$x:000095A3                 db 0FFh
.xdata$x:000095A4                 dd offset __unwindfunclet$??0_System_error_category@std@@QAE@XZ$0
.xdata$x:000095A8 __ehfuncinfo$??0_System_error_category@std@@QAE@XZ db  22h ; "
.xdata$x:000095A8                                         ; DATA XREF: __ehhandler$??0_System_error_category@std@@QAE@XZ+11o
.xdata$x:000095A9                 db    5
.xdata$x:000095AA                 db  93h ; ô
.xdata$x:000095AB                 db  19h
.xdata$x:000095AC                 db    1
.xdata$x:000095AD                 db    0
.xdata$x:000095AE                 db    0
.xdata$x:000095AF                 db    0
.xdata$x:000095B0                 dd offset __unwindtable$??0_System_error_category@std@@QAE@XZ
.xdata$x:000095B4                 db    0
.xdata$x:000095B5                 db    0
.xdata$x:000095B6                 db    0
.xdata$x:000095B7                 db    0
.xdata$x:000095B8                 db    0
.xdata$x:000095B9                 db    0
.xdata$x:000095BA                 db    0
.xdata$x:000095BB                 db    0
.xdata$x:000095BC                 db    0
.xdata$x:000095BD                 db    0
.xdata$x:000095BE                 db    0
.xdata$x:000095BF                 db    0
.xdata$x:000095C0                 db    0
.xdata$x:000095C1                 db    0
.xdata$x:000095C2                 db    0
.xdata$x:000095C3                 db    0
.xdata$x:000095C4                 db    0
.xdata$x:000095C5                 db    0
.xdata$x:000095C6                 db    0
.xdata$x:000095C7                 db    0
.xdata$x:000095C8                 db    0
.xdata$x:000095C9                 db    0
.xdata$x:000095CA                 db    0
.xdata$x:000095CB                 db    0
.xdata$x:000095CB _xdata$x        ends
.xdata$x:000095CB
.xdata$x:000095CC ; ===========================================================================
.xdata$x:000095CC
.xdata$x:000095CC ; Segment type: Pure data
.xdata$x:000095CC ; Segment permissions: Read
.xdata$x:000095CC _xdata$x        segment dword public 'DATA' use32
.xdata$x:000095CC                 assume cs:_xdata$x
.xdata$x:000095CC                 ;org 95CCh
.xdata$x:000095CC ; COMDAT (pick associative to section at 8B28)
.xdata$x:000095CC __unwindtable$?message@_System_error_category@std@@UBE?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@2@H@Z db 0FFh
.xdata$x:000095CC                                         ; DATA XREF: .xdata$x:000095DCo
.xdata$x:000095CD                 db 0FFh
.xdata$x:000095CE                 db 0FFh
.xdata$x:000095CF                 db 0FFh
.xdata$x:000095D0                 dd offset __unwindfunclet$?message@_System_error_category@std@@UBE?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@2@H@Z$0
.xdata$x:000095D4 __ehfuncinfo$?message@_System_error_category@std@@UBE?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@2@H@Z db  22h ; "
.xdata$x:000095D4                                         ; DATA XREF: __ehhandler$?message@_System_error_category@std@@UBE?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@2@H@Z+11o
.xdata$x:000095D5                 db    5
.xdata$x:000095D6                 db  93h ; ô
.xdata$x:000095D7                 db  19h
.xdata$x:000095D8                 db    1
.xdata$x:000095D9                 db    0
.xdata$x:000095DA                 db    0
.xdata$x:000095DB                 db    0
.xdata$x:000095DC                 dd offset __unwindtable$?message@_System_error_category@std@@UBE?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@2@H@Z
.xdata$x:000095E0                 db    0
.xdata$x:000095E1                 db    0
.xdata$x:000095E2                 db    0
.xdata$x:000095E3                 db    0
.xdata$x:000095E4                 db    0
.xdata$x:000095E5                 db    0
.xdata$x:000095E6                 db    0
.xdata$x:000095E7                 db    0
.xdata$x:000095E8                 db    0
.xdata$x:000095E9                 db    0
.xdata$x:000095EA                 db    0
.xdata$x:000095EB                 db    0
.xdata$x:000095EC                 db    0
.xdata$x:000095ED                 db    0
.xdata$x:000095EE                 db    0
.xdata$x:000095EF                 db    0
.xdata$x:000095F0                 db    0
.xdata$x:000095F1                 db    0
.xdata$x:000095F2                 db    0
.xdata$x:000095F3                 db    0
.xdata$x:000095F4                 db    0
.xdata$x:000095F5                 db    0
.xdata$x:000095F6                 db    0
.xdata$x:000095F7                 db    0
.xdata$x:000095F7 _xdata$x        ends
.xdata$x:000095F7
.xdata$x:000095F8 ; ===========================================================================
.xdata$x:000095F8
.xdata$x:000095F8 ; Segment type: Pure data
.xdata$x:000095F8 ; Segment permissions: Read
.xdata$x:000095F8 _xdata$x        segment dword public 'DATA' use32
.xdata$x:000095F8                 assume cs:_xdata$x
.xdata$x:000095F8                 ;org 95F8h
.xdata$x:000095F8 ; COMDAT (pick associative to section at 57FC)
.xdata$x:000095F8 __unwindtable$??1_System_error_category@std@@UAE@XZ db 0FFh
.xdata$x:000095F8                                         ; DATA XREF: .xdata$x:00009608o
.xdata$x:000095F9                 db 0FFh
.xdata$x:000095FA                 db 0FFh
.xdata$x:000095FB                 db 0FFh
.xdata$x:000095FC                 dd offset __unwindfunclet$??1_System_error_category@std@@UAE@XZ$0
.xdata$x:00009600 __ehfuncinfo$??1_System_error_category@std@@UAE@XZ db  22h ; "
.xdata$x:00009600                                         ; DATA XREF: __ehhandler$??1_System_error_category@std@@UAE@XZ+11o
.xdata$x:00009601                 db    5
.xdata$x:00009602                 db  93h ; ô
.xdata$x:00009603                 db  19h
.xdata$x:00009604                 db    1
.xdata$x:00009605                 db    0
.xdata$x:00009606                 db    0
.xdata$x:00009607                 db    0
.xdata$x:00009608                 dd offset __unwindtable$??1_System_error_category@std@@UAE@XZ
.xdata$x:0000960C                 db    0
.xdata$x:0000960D                 db    0
.xdata$x:0000960E                 db    0
.xdata$x:0000960F                 db    0
.xdata$x:00009610                 db    0
.xdata$x:00009611                 db    0
.xdata$x:00009612                 db    0
.xdata$x:00009613                 db    0
.xdata$x:00009614                 db    0
.xdata$x:00009615                 db    0
.xdata$x:00009616                 db    0
.xdata$x:00009617                 db    0
.xdata$x:00009618                 db    0
.xdata$x:00009619                 db    0
.xdata$x:0000961A                 db    0
.xdata$x:0000961B                 db    0
.xdata$x:0000961C                 db    0
.xdata$x:0000961D                 db    0
.xdata$x:0000961E                 db    0
.xdata$x:0000961F                 db    0
.xdata$x:00009620                 db    0
.xdata$x:00009621                 db    0
.xdata$x:00009622                 db    0
.xdata$x:00009623                 db    0
.xdata$x:00009623 _xdata$x        ends
.xdata$x:00009623
.xdata$x:00009624 ; ===========================================================================
.xdata$x:00009624
.xdata$x:00009624 ; Segment type: Pure data
.xdata$x:00009624 ; Segment permissions: Read
.xdata$x:00009624 _xdata$x        segment dword public 'DATA' use32
.xdata$x:00009624                 assume cs:_xdata$x
.xdata$x:00009624                 ;org 9624h
.xdata$x:00009624 ; COMDAT (pick associative to section at 4530)
.xdata$x:00009624 __unwindtable$??0?$_Vector_val@U?$_Simple_types@PB_W@std@@@std@@QAE@XZ db 0FFh
.xdata$x:00009624                                         ; DATA XREF: .xdata$x:00009634o
.xdata$x:00009625                 db 0FFh
.xdata$x:00009626                 db 0FFh
.xdata$x:00009627                 db 0FFh
.xdata$x:00009628                 dd offset __unwindfunclet$??0?$_Vector_val@U?$_Simple_types@PB_W@std@@@std@@QAE@XZ$0
.xdata$x:0000962C __ehfuncinfo$??0?$_Vector_val@U?$_Simple_types@PB_W@std@@@std@@QAE@XZ db  22h ; "
.xdata$x:0000962C                                         ; DATA XREF: __ehhandler$??0?$_Vector_val@U?$_Simple_types@PB_W@std@@@std@@QAE@XZ+11o
.xdata$x:0000962D                 db    5
.xdata$x:0000962E                 db  93h ; ô
.xdata$x:0000962F                 db  19h
.xdata$x:00009630                 db    1
.xdata$x:00009631                 db    0
.xdata$x:00009632                 db    0
.xdata$x:00009633                 db    0
.xdata$x:00009634                 dd offset __unwindtable$??0?$_Vector_val@U?$_Simple_types@PB_W@std@@@std@@QAE@XZ
.xdata$x:00009638                 db    0
.xdata$x:00009639                 db    0
.xdata$x:0000963A                 db    0
.xdata$x:0000963B                 db    0
.xdata$x:0000963C                 db    0
.xdata$x:0000963D                 db    0
.xdata$x:0000963E                 db    0
.xdata$x:0000963F                 db    0
.xdata$x:00009640                 db    0
.xdata$x:00009641                 db    0
.xdata$x:00009642                 db    0
.xdata$x:00009643                 db    0
.xdata$x:00009644                 db    0
.xdata$x:00009645                 db    0
.xdata$x:00009646                 db    0
.xdata$x:00009647                 db    0
.xdata$x:00009648                 db    0
.xdata$x:00009649                 db    0
.xdata$x:0000964A                 db    0
.xdata$x:0000964B                 db    0
.xdata$x:0000964C                 db    0
.xdata$x:0000964D                 db    0
.xdata$x:0000964E                 db    0
.xdata$x:0000964F                 db    0
.xdata$x:0000964F _xdata$x        ends
.xdata$x:0000964F
.xdata$x:00009650 ; ===========================================================================
.xdata$x:00009650
.xdata$x:00009650 ; Segment type: Pure data
.xdata$x:00009650 ; Segment permissions: Read
.xdata$x:00009650 _xdata$x        segment dword public 'DATA' use32
.xdata$x:00009650                 assume cs:_xdata$x
.xdata$x:00009650                 ;org 9650h
.xdata$x:00009650 ; COMDAT (pick associative to section at 5350)
.xdata$x:00009650 __unwindtable$??1?$_Vector_val@U?$_Simple_types@PB_W@std@@@std@@QAE@XZ db 0FFh
.xdata$x:00009650                                         ; DATA XREF: .xdata$x:00009660o
.xdata$x:00009651                 db 0FFh
.xdata$x:00009652                 db 0FFh
.xdata$x:00009653                 db 0FFh
.xdata$x:00009654                 dd offset __unwindfunclet$??1?$_Vector_val@U?$_Simple_types@PB_W@std@@@std@@QAE@XZ$0
.xdata$x:00009658 __ehfuncinfo$??1?$_Vector_val@U?$_Simple_types@PB_W@std@@@std@@QAE@XZ db  22h ; "
.xdata$x:00009658                                         ; DATA XREF: __ehhandler$??1?$_Vector_val@U?$_Simple_types@PB_W@std@@@std@@QAE@XZ+11o
.xdata$x:00009659                 db    5
.xdata$x:0000965A                 db  93h ; ô
.xdata$x:0000965B                 db  19h
.xdata$x:0000965C                 db    1
.xdata$x:0000965D                 db    0
.xdata$x:0000965E                 db    0
.xdata$x:0000965F                 db    0
.xdata$x:00009660                 dd offset __unwindtable$??1?$_Vector_val@U?$_Simple_types@PB_W@std@@@std@@QAE@XZ
.xdata$x:00009664                 db    0
.xdata$x:00009665                 db    0
.xdata$x:00009666                 db    0
.xdata$x:00009667                 db    0
.xdata$x:00009668                 db    0
.xdata$x:00009669                 db    0
.xdata$x:0000966A                 db    0
.xdata$x:0000966B                 db    0
.xdata$x:0000966C                 db    0
.xdata$x:0000966D                 db    0
.xdata$x:0000966E                 db    0
.xdata$x:0000966F                 db    0
.xdata$x:00009670                 db    0
.xdata$x:00009671                 db    0
.xdata$x:00009672                 db    0
.xdata$x:00009673                 db    0
.xdata$x:00009674                 db    0
.xdata$x:00009675                 db    0
.xdata$x:00009676                 db    0
.xdata$x:00009677                 db    0
.xdata$x:00009678                 db    0
.xdata$x:00009679                 db    0
.xdata$x:0000967A                 db    0
.xdata$x:0000967B                 db    0
.xdata$x:0000967B _xdata$x        ends
.xdata$x:0000967B
.xdata$x:0000967C ; ===========================================================================
.xdata$x:0000967C
.xdata$x:0000967C ; Segment type: Pure data
.xdata$x:0000967C ; Segment permissions: Read
.xdata$x:0000967C _xdata$x        segment dword public 'DATA' use32
.xdata$x:0000967C                 assume cs:_xdata$x
.xdata$x:0000967C                 ;org 967Ch
.xdata$x:0000967C ; COMDAT (pick associative to section at 40A8)
.xdata$x:0000967C __unwindtable$??0?$_Vector_alloc@$0A@U?$_Vec_base_types@PB_WV?$allocator@PB_W@std@@@std@@@std@@QAE@ABV?$allocator@PB_W@1@@Z db 0FFh
.xdata$x:0000967C                                         ; DATA XREF: .xdata$x:0000968Co
.xdata$x:0000967D                 db 0FFh
.xdata$x:0000967E                 db 0FFh
.xdata$x:0000967F                 db 0FFh
.xdata$x:00009680                 dd offset __unwindfunclet$??0?$_Vector_alloc@$0A@U?$_Vec_base_types@PB_WV?$allocator@PB_W@std@@@std@@@std@@QAE@ABV?$allocator@PB_W@1@@Z$0
.xdata$x:00009684 __ehfuncinfo$??0?$_Vector_alloc@$0A@U?$_Vec_base_types@PB_WV?$allocator@PB_W@std@@@std@@@std@@QAE@ABV?$allocator@PB_W@1@@Z db  22h ; "
.xdata$x:00009684                                         ; DATA XREF: __ehhandler$??0?$_Vector_alloc@$0A@U?$_Vec_base_types@PB_WV?$allocator@PB_W@std@@@std@@@std@@QAE@ABV?$allocator@PB_W@1@@Z+11o
.xdata$x:00009685                 db    5
.xdata$x:00009686                 db  93h ; ô
.xdata$x:00009687                 db  19h
.xdata$x:00009688                 db    1
.xdata$x:00009689                 db    0
.xdata$x:0000968A                 db    0
.xdata$x:0000968B                 db    0
.xdata$x:0000968C                 dd offset __unwindtable$??0?$_Vector_alloc@$0A@U?$_Vec_base_types@PB_WV?$allocator@PB_W@std@@@std@@@std@@QAE@ABV?$allocator@PB_W@1@@Z
.xdata$x:00009690                 db    0
.xdata$x:00009691                 db    0
.xdata$x:00009692                 db    0
.xdata$x:00009693                 db    0
.xdata$x:00009694                 db    0
.xdata$x:00009695                 db    0
.xdata$x:00009696                 db    0
.xdata$x:00009697                 db    0
.xdata$x:00009698                 db    0
.xdata$x:00009699                 db    0
.xdata$x:0000969A                 db    0
.xdata$x:0000969B                 db    0
.xdata$x:0000969C                 db    0
.xdata$x:0000969D                 db    0
.xdata$x:0000969E                 db    0
.xdata$x:0000969F                 db    0
.xdata$x:000096A0                 db    0
.xdata$x:000096A1                 db    0
.xdata$x:000096A2                 db    0
.xdata$x:000096A3                 db    0
.xdata$x:000096A4                 db    0
.xdata$x:000096A5                 db    0
.xdata$x:000096A6                 db    0
.xdata$x:000096A7                 db    0
.xdata$x:000096A7 _xdata$x        ends
.xdata$x:000096A7
.xdata$x:000096A8 ; ===========================================================================
.xdata$x:000096A8
.xdata$x:000096A8 ; Segment type: Pure data
.xdata$x:000096A8 ; Segment permissions: Read
.xdata$x:000096A8 _xdata$x        segment dword public 'DATA' use32
.xdata$x:000096A8                 assume cs:_xdata$x
.xdata$x:000096A8                 ;org 96A8h
.xdata$x:000096A8 ; COMDAT (pick associative to section at 5098)
.xdata$x:000096A8 __unwindtable$??1?$_Vector_alloc@$0A@U?$_Vec_base_types@PB_WV?$allocator@PB_W@std@@@std@@@std@@QAE@XZ db 0FFh
.xdata$x:000096A8                                         ; DATA XREF: .xdata$x:000096B8o
.xdata$x:000096A9                 db 0FFh
.xdata$x:000096AA                 db 0FFh
.xdata$x:000096AB                 db 0FFh
.xdata$x:000096AC                 dd offset __unwindfunclet$??1?$_Vector_alloc@$0A@U?$_Vec_base_types@PB_WV?$allocator@PB_W@std@@@std@@@std@@QAE@XZ$0
.xdata$x:000096B0 __ehfuncinfo$??1?$_Vector_alloc@$0A@U?$_Vec_base_types@PB_WV?$allocator@PB_W@std@@@std@@@std@@QAE@XZ db  22h ; "
.xdata$x:000096B0                                         ; DATA XREF: __ehhandler$??1?$_Vector_alloc@$0A@U?$_Vec_base_types@PB_WV?$allocator@PB_W@std@@@std@@@std@@QAE@XZ+11o
.xdata$x:000096B1                 db    5
.xdata$x:000096B2                 db  93h ; ô
.xdata$x:000096B3                 db  19h
.xdata$x:000096B4                 db    1
.xdata$x:000096B5                 db    0
.xdata$x:000096B6                 db    0
.xdata$x:000096B7                 db    0
.xdata$x:000096B8                 dd offset __unwindtable$??1?$_Vector_alloc@$0A@U?$_Vec_base_types@PB_WV?$allocator@PB_W@std@@@std@@@std@@QAE@XZ
.xdata$x:000096BC                 db    0
.xdata$x:000096BD                 db    0
.xdata$x:000096BE                 db    0
.xdata$x:000096BF                 db    0
.xdata$x:000096C0                 db    0
.xdata$x:000096C1                 db    0
.xdata$x:000096C2                 db    0
.xdata$x:000096C3                 db    0
.xdata$x:000096C4                 db    0
.xdata$x:000096C5                 db    0
.xdata$x:000096C6                 db    0
.xdata$x:000096C7                 db    0
.xdata$x:000096C8                 db    0
.xdata$x:000096C9                 db    0
.xdata$x:000096CA                 db    0
.xdata$x:000096CB                 db    0
.xdata$x:000096CC                 db    0
.xdata$x:000096CD                 db    0
.xdata$x:000096CE                 db    0
.xdata$x:000096CF                 db    0
.xdata$x:000096D0                 db    0
.xdata$x:000096D1                 db    0
.xdata$x:000096D2                 db    0
.xdata$x:000096D3                 db    0
.xdata$x:000096D3 _xdata$x        ends
.xdata$x:000096D3
.xdata$x:000096D4 ; ===========================================================================
.xdata$x:000096D4
.xdata$x:000096D4 ; Segment type: Pure data
.xdata$x:000096D4 ; Segment permissions: Read
.xdata$x:000096D4 _xdata$x        segment dword public 'DATA' use32
.xdata$x:000096D4                 assume cs:_xdata$x
.xdata$x:000096D4                 ;org 96D4h
.xdata$x:000096D4 ; COMDAT (pick associative to section at 4A84)
.xdata$x:000096D4 __unwindtable$??0?$vector@PB_WV?$allocator@PB_W@std@@@std@@QAE@XZ db 0FFh
.xdata$x:000096D4                                         ; DATA XREF: .xdata$x:000096E4o
.xdata$x:000096D5                 db 0FFh
.xdata$x:000096D6                 db 0FFh
.xdata$x:000096D7                 db 0FFh
.xdata$x:000096D8                 dd offset __unwindfunclet$??0?$vector@PB_WV?$allocator@PB_W@std@@@std@@QAE@XZ$0
.xdata$x:000096DC __ehfuncinfo$??0?$vector@PB_WV?$allocator@PB_W@std@@@std@@QAE@XZ db  22h ; "
.xdata$x:000096DC                                         ; DATA XREF: __ehhandler$??0?$vector@PB_WV?$allocator@PB_W@std@@@std@@QAE@XZ+11o
.xdata$x:000096DD                 db    5
.xdata$x:000096DE                 db  93h ; ô
.xdata$x:000096DF                 db  19h
.xdata$x:000096E0                 db    1
.xdata$x:000096E1                 db    0
.xdata$x:000096E2                 db    0
.xdata$x:000096E3                 db    0
.xdata$x:000096E4                 dd offset __unwindtable$??0?$vector@PB_WV?$allocator@PB_W@std@@@std@@QAE@XZ
.xdata$x:000096E8                 align 20h
.xdata$x:000096E8 _xdata$x        ends
.xdata$x:000096E8
.xdata$x:00009700 ; ===========================================================================
.xdata$x:00009700
.xdata$x:00009700 ; Segment type: Pure data
.xdata$x:00009700 ; Segment permissions: Read
.xdata$x:00009700 _xdata$x        segment dword public 'DATA' use32
.xdata$x:00009700                 assume cs:_xdata$x
.xdata$x:00009700                 ;org 9700h
.xdata$x:00009700 ; COMDAT (pick associative to section at 4938)
.xdata$x:00009700 __catchsym$??0?$vector@PB_WV?$allocator@PB_W@std@@@std@@QAE@ABV01@@Z$5 db    0
.xdata$x:00009700                                         ; DATA XREF: .xdata$x:00009720o
.xdata$x:00009701                 db    0
.xdata$x:00009702                 db    0
.xdata$x:00009703                 db    0
.xdata$x:00009704                 db    0
.xdata$x:00009705                 db    0
.xdata$x:00009706                 db    0
.xdata$x:00009707                 db    0
.xdata$x:00009708                 db    0
.xdata$x:00009709                 db    0
.xdata$x:0000970A                 db    0
.xdata$x:0000970B                 db    0
.xdata$x:0000970C                 dd offset __catch$??0?$vector@PB_WV?$allocator@PB_W@std@@@std@@QAE@ABV01@@Z$0
.xdata$x:00009710 __tryblocktable$??0?$vector@PB_WV?$allocator@PB_W@std@@@std@@QAE@ABV01@@Z db    1
.xdata$x:00009710                                         ; DATA XREF: .xdata$x:00009734o
.xdata$x:00009711                 db    0
.xdata$x:00009712                 db    0
.xdata$x:00009713                 db    0
.xdata$x:00009714                 db    3
.xdata$x:00009715                 db    0
.xdata$x:00009716                 db    0
.xdata$x:00009717                 db    0
.xdata$x:00009718                 db    4
.xdata$x:00009719                 db    0
.xdata$x:0000971A                 db    0
.xdata$x:0000971B                 db    0
.xdata$x:0000971C                 db    1
.xdata$x:0000971D                 db    0
.xdata$x:0000971E                 db    0
.xdata$x:0000971F                 db    0
.xdata$x:00009720                 dd offset __catchsym$??0?$vector@PB_WV?$allocator@PB_W@std@@@std@@QAE@ABV01@@Z$5
.xdata$x:00009724 __ehfuncinfo$??0?$vector@PB_WV?$allocator@PB_W@std@@@std@@QAE@ABV01@@Z db  22h ; "
.xdata$x:00009724                                         ; DATA XREF: __ehhandler$??0?$vector@PB_WV?$allocator@PB_W@std@@@std@@QAE@ABV01@@Z+11o
.xdata$x:00009725                 db    5
.xdata$x:00009726                 db  93h ; ô
.xdata$x:00009727                 db  19h
.xdata$x:00009728                 db    5
.xdata$x:00009729                 db    0
.xdata$x:0000972A                 db    0
.xdata$x:0000972B                 db    0
.xdata$x:0000972C                 dd offset __unwindtable$??0?$vector@PB_WV?$allocator@PB_W@std@@@std@@QAE@ABV01@@Z
.xdata$x:00009730                 db    1
.xdata$x:00009731                 db    0
.xdata$x:00009732                 db    0
.xdata$x:00009733                 db    0
.xdata$x:00009734                 dd offset __tryblocktable$??0?$vector@PB_WV?$allocator@PB_W@std@@@std@@QAE@ABV01@@Z
.xdata$x:00009738                 db    0
.xdata$x:00009739                 db    0
.xdata$x:0000973A                 db    0
.xdata$x:0000973B                 db    0
.xdata$x:0000973C                 db    0
.xdata$x:0000973D                 db    0
.xdata$x:0000973E                 db    0
.xdata$x:0000973F                 db    0
.xdata$x:00009740                 db    0
.xdata$x:00009741                 db    0
.xdata$x:00009742                 db    0
.xdata$x:00009743                 db    0
.xdata$x:00009744                 db    0
.xdata$x:00009745                 db    0
.xdata$x:00009746                 db    0
.xdata$x:00009747                 db    0
.xdata$x:00009748 __unwindtable$??0?$vector@PB_WV?$allocator@PB_W@std@@@std@@QAE@ABV01@@Z db 0FFh
.xdata$x:00009748                                         ; DATA XREF: .xdata$x:0000972Co
.xdata$x:00009749                 db 0FFh
.xdata$x:0000974A                 db 0FFh
.xdata$x:0000974B                 db 0FFh
.xdata$x:0000974C                 dd offset __unwindfunclet$??0?$vector@PB_WV?$allocator@PB_W@std@@@std@@QAE@ABV01@@Z$2
.xdata$x:00009750                 db    0
.xdata$x:00009751                 db    0
.xdata$x:00009752                 db    0
.xdata$x:00009753                 db    0
.xdata$x:00009754                 db    0
.xdata$x:00009755                 db    0
.xdata$x:00009756                 db    0
.xdata$x:00009757                 db    0
.xdata$x:00009758                 db    1
.xdata$x:00009759                 db    0
.xdata$x:0000975A                 db    0
.xdata$x:0000975B                 db    0
.xdata$x:0000975C                 dd offset __unwindfunclet$??0?$vector@PB_WV?$allocator@PB_W@std@@@std@@QAE@ABV01@@Z$3
.xdata$x:00009760                 db    2
.xdata$x:00009761                 db    0
.xdata$x:00009762                 db    0
.xdata$x:00009763                 db    0
.xdata$x:00009764                 dd offset __unwindfunclet$??0?$vector@PB_WV?$allocator@PB_W@std@@@std@@QAE@ABV01@@Z$4
.xdata$x:00009768                 align 10h
.xdata$x:00009768 _xdata$x        ends
.xdata$x:00009768
.xdata$x:00009770 ; ===========================================================================
.xdata$x:00009770
.xdata$x:00009770 ; Segment type: Pure data
.xdata$x:00009770 ; Segment permissions: Read
.xdata$x:00009770 _xdata$x        segment dword public 'DATA' use32
.xdata$x:00009770                 assume cs:_xdata$x
.xdata$x:00009770                 ;org 9770h
.xdata$x:00009770 ; COMDAT (pick associative to section at 4894)
.xdata$x:00009770 __unwindtable$??0?$vector@PB_WV?$allocator@PB_W@std@@@std@@QAE@$$QAV01@@Z db 0FFh
.xdata$x:00009770                                         ; DATA XREF: .xdata$x:00009780o
.xdata$x:00009771                 db 0FFh
.xdata$x:00009772                 db 0FFh
.xdata$x:00009773                 db 0FFh
.xdata$x:00009774                 dd offset __unwindfunclet$??0?$vector@PB_WV?$allocator@PB_W@std@@@std@@QAE@$$QAV01@@Z$0
.xdata$x:00009778 __ehfuncinfo$??0?$vector@PB_WV?$allocator@PB_W@std@@@std@@QAE@$$QAV01@@Z db  22h ; "
.xdata$x:00009778                                         ; DATA XREF: __ehhandler$??0?$vector@PB_WV?$allocator@PB_W@std@@@std@@QAE@$$QAV01@@Z+11o
.xdata$x:00009779                 db    5
.xdata$x:0000977A                 db  93h ; ô
.xdata$x:0000977B                 db  19h
.xdata$x:0000977C                 db    1
.xdata$x:0000977D                 db    0
.xdata$x:0000977E                 db    0
.xdata$x:0000977F                 db    0
.xdata$x:00009780                 dd offset __unwindtable$??0?$vector@PB_WV?$allocator@PB_W@std@@@std@@QAE@$$QAV01@@Z
.xdata$x:00009784                 db    0
.xdata$x:00009785                 db    0
.xdata$x:00009786                 db    0
.xdata$x:00009787                 db    0
.xdata$x:00009788                 db    0
.xdata$x:00009789                 db    0
.xdata$x:0000978A                 db    0
.xdata$x:0000978B                 db    0
.xdata$x:0000978C                 db    0
.xdata$x:0000978D                 db    0
.xdata$x:0000978E                 db    0
.xdata$x:0000978F                 db    0
.xdata$x:00009790                 db    0
.xdata$x:00009791                 db    0
.xdata$x:00009792                 db    0
.xdata$x:00009793                 db    0
.xdata$x:00009794                 db    0
.xdata$x:00009795                 db    0
.xdata$x:00009796                 db    0
.xdata$x:00009797                 db    0
.xdata$x:00009798                 db    0
.xdata$x:00009799                 db    0
.xdata$x:0000979A                 db    0
.xdata$x:0000979B                 db    0
.xdata$x:0000979B _xdata$x        ends
.xdata$x:0000979B
.xdata$x:0000979C ; ===========================================================================
.xdata$x:0000979C
.xdata$x:0000979C ; Segment type: Pure data
.xdata$x:0000979C ; Segment permissions: Read
.xdata$x:0000979C _xdata$x        segment dword public 'DATA' use32
.xdata$x:0000979C                 assume cs:_xdata$x
.xdata$x:0000979C                 ;org 979Ch
.xdata$x:0000979C ; COMDAT (pick associative to section at 551C)
.xdata$x:0000979C __unwindtable$??1?$vector@PB_WV?$allocator@PB_W@std@@@std@@QAE@XZ db 0FFh
.xdata$x:0000979C                                         ; DATA XREF: .xdata$x:000097ACo
.xdata$x:0000979D                 db 0FFh
.xdata$x:0000979E                 db 0FFh
.xdata$x:0000979F                 db 0FFh
.xdata$x:000097A0                 dd offset __unwindfunclet$??1?$vector@PB_WV?$allocator@PB_W@std@@@std@@QAE@XZ$0
.xdata$x:000097A4 __ehfuncinfo$??1?$vector@PB_WV?$allocator@PB_W@std@@@std@@QAE@XZ db  22h ; "
.xdata$x:000097A4                                         ; DATA XREF: __ehhandler$??1?$vector@PB_WV?$allocator@PB_W@std@@@std@@QAE@XZ+11o
.xdata$x:000097A5                 db    5
.xdata$x:000097A6                 db  93h ; ô
.xdata$x:000097A7                 db  19h
.xdata$x:000097A8                 db    1
.xdata$x:000097A9                 db    0
.xdata$x:000097AA                 db    0
.xdata$x:000097AB                 db    0
.xdata$x:000097AC                 dd offset __unwindtable$??1?$vector@PB_WV?$allocator@PB_W@std@@@std@@QAE@XZ
.xdata$x:000097B0                 db    0
.xdata$x:000097B1                 db    0
.xdata$x:000097B2                 db    0
.xdata$x:000097B3                 db    0
.xdata$x:000097B4                 db    0
.xdata$x:000097B5                 db    0
.xdata$x:000097B6                 db    0
.xdata$x:000097B7                 db    0
.xdata$x:000097B8                 db    0
.xdata$x:000097B9                 db    0
.xdata$x:000097BA                 db    0
.xdata$x:000097BB                 db    0
.xdata$x:000097BC                 db    0
.xdata$x:000097BD                 db    0
.xdata$x:000097BE                 db    0
.xdata$x:000097BF                 db    0
.xdata$x:000097C0                 db    0
.xdata$x:000097C1                 db    0
.xdata$x:000097C2                 db    0
.xdata$x:000097C3                 db    0
.xdata$x:000097C4                 db    0
.xdata$x:000097C5                 db    0
.xdata$x:000097C6                 db    0
.xdata$x:000097C7                 db    0
.xdata$x:000097C7 _xdata$x        ends
.xdata$x:000097C7
.xdata$x:000097C8 ; ===========================================================================
.xdata$x:000097C8
.xdata$x:000097C8 ; Segment type: Pure data
.xdata$x:000097C8 ; Segment permissions: Read
.xdata$x:000097C8 _xdata$x        segment dword public 'DATA' use32
.xdata$x:000097C8                 assume cs:_xdata$x
.xdata$x:000097C8                 ;org 97C8h
.xdata$x:000097C8 ; COMDAT (pick associative to section at 7DBC)
.xdata$x:000097C8 __unwindtable$?begin@?$vector@PB_WV?$allocator@PB_W@std@@@std@@QBE?AV?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@PB_W@std@@@std@@@2@XZ db 0FFh
.xdata$x:000097C8                                         ; DATA XREF: .xdata$x:000097D8o
.xdata$x:000097C9                 db 0FFh
.xdata$x:000097CA                 db 0FFh
.xdata$x:000097CB                 db 0FFh
.xdata$x:000097CC                 dd offset __unwindfunclet$?begin@?$vector@PB_WV?$allocator@PB_W@std@@@std@@QBE?AV?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@PB_W@std@@@std@@@2@XZ$0
.xdata$x:000097D0 __ehfuncinfo$?begin@?$vector@PB_WV?$allocator@PB_W@std@@@std@@QBE?AV?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@PB_W@std@@@std@@@2@XZ db  22h ; "
.xdata$x:000097D0                                         ; DATA XREF: __ehhandler$?begin@?$vector@PB_WV?$allocator@PB_W@std@@@std@@QBE?AV?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@PB_W@std@@@std@@@2@XZ+11o
.xdata$x:000097D1                 db    5
.xdata$x:000097D2                 db  93h ; ô
.xdata$x:000097D3                 db  19h
.xdata$x:000097D4                 db    1
.xdata$x:000097D5                 db    0
.xdata$x:000097D6                 db    0
.xdata$x:000097D7                 db    0
.xdata$x:000097D8                 dd offset __unwindtable$?begin@?$vector@PB_WV?$allocator@PB_W@std@@@std@@QBE?AV?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@PB_W@std@@@std@@@2@XZ
.xdata$x:000097DC                 db    0
.xdata$x:000097DD                 db    0
.xdata$x:000097DE                 db    0
.xdata$x:000097DF                 db    0
.xdata$x:000097E0                 db    0
.xdata$x:000097E1                 db    0
.xdata$x:000097E2                 db    0
.xdata$x:000097E3                 db    0
.xdata$x:000097E4                 db    0
.xdata$x:000097E5                 db    0
.xdata$x:000097E6                 db    0
.xdata$x:000097E7                 db    0
.xdata$x:000097E8                 db    0
.xdata$x:000097E9                 db    0
.xdata$x:000097EA                 db    0
.xdata$x:000097EB                 db    0
.xdata$x:000097EC                 db    0
.xdata$x:000097ED                 db    0
.xdata$x:000097EE                 db    0
.xdata$x:000097EF                 db    0
.xdata$x:000097F0                 db    0
.xdata$x:000097F1                 db    0
.xdata$x:000097F2                 db    0
.xdata$x:000097F3                 db    0
.xdata$x:000097F3 _xdata$x        ends
.xdata$x:000097F3
.xdata$x:000097F4 ; ===========================================================================
.xdata$x:000097F4
.xdata$x:000097F4 ; Segment type: Pure data
.xdata$x:000097F4 ; Segment permissions: Read
.xdata$x:000097F4 _xdata$x        segment dword public 'DATA' use32
.xdata$x:000097F4                 assume cs:_xdata$x
.xdata$x:000097F4                 ;org 97F4h
.xdata$x:000097F4 ; COMDAT (pick associative to section at 8320)
.xdata$x:000097F4 __unwindtable$?end@?$vector@PB_WV?$allocator@PB_W@std@@@std@@QBE?AV?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@PB_W@std@@@std@@@2@XZ db 0FFh
.xdata$x:000097F4                                         ; DATA XREF: .xdata$x:00009804o
.xdata$x:000097F5                 db 0FFh
.xdata$x:000097F6                 db 0FFh
.xdata$x:000097F7                 db 0FFh
.xdata$x:000097F8                 dd offset __unwindfunclet$?end@?$vector@PB_WV?$allocator@PB_W@std@@@std@@QBE?AV?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@PB_W@std@@@std@@@2@XZ$0
.xdata$x:000097FC __ehfuncinfo$?end@?$vector@PB_WV?$allocator@PB_W@std@@@std@@QBE?AV?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@PB_W@std@@@std@@@2@XZ db  22h ; "
.xdata$x:000097FC                                         ; DATA XREF: __ehhandler$?end@?$vector@PB_WV?$allocator@PB_W@std@@@std@@QBE?AV?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@PB_W@std@@@std@@@2@XZ+11o
.xdata$x:000097FD                 db    5
.xdata$x:000097FE                 db  93h ; ô
.xdata$x:000097FF                 db  19h
.xdata$x:00009800                 db    1
.xdata$x:00009801                 db    0
.xdata$x:00009802                 db    0
.xdata$x:00009803                 db    0
.xdata$x:00009804                 dd offset __unwindtable$?end@?$vector@PB_WV?$allocator@PB_W@std@@@std@@QBE?AV?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@PB_W@std@@@std@@@2@XZ
.xdata$x:00009808                 align 20h
.xdata$x:00009808 _xdata$x        ends
.xdata$x:00009808
.xdata$x:00009820 ; ===========================================================================
.xdata$x:00009820
.xdata$x:00009820 ; Segment type: Pure data
.xdata$x:00009820 ; Segment permissions: Read
.xdata$x:00009820 _xdata$x        segment dword public 'DATA' use32
.xdata$x:00009820                 assume cs:_xdata$x
.xdata$x:00009820                 ;org 9820h
.xdata$x:00009820 ; COMDAT (pick associative to section at 6E6C)
.xdata$x:00009820 __catchsym$?_Reallocate@?$vector@PB_WV?$allocator@PB_W@std@@@std@@IAEXI@Z$2 db    0
.xdata$x:00009820                                         ; DATA XREF: .xdata$x:00009850o
.xdata$x:00009821                 db    0
.xdata$x:00009822                 db    0
.xdata$x:00009823                 db    0
.xdata$x:00009824                 db    0
.xdata$x:00009825                 db    0
.xdata$x:00009826                 db    0
.xdata$x:00009827                 db    0
.xdata$x:00009828                 db    0
.xdata$x:00009829                 db    0
.xdata$x:0000982A                 db    0
.xdata$x:0000982B                 db    0
.xdata$x:0000982C                 dd offset __catch$?_Reallocate@?$vector@PB_WV?$allocator@PB_W@std@@@std@@IAEXI@Z$0
.xdata$x:00009830 __unwindtable$?_Reallocate@?$vector@PB_WV?$allocator@PB_W@std@@@std@@IAEXI@Z db 0FFh
.xdata$x:00009830                                         ; DATA XREF: .xdata$x:0000985Co
.xdata$x:00009831                 db 0FFh
.xdata$x:00009832                 db 0FFh
.xdata$x:00009833                 db 0FFh
.xdata$x:00009834                 db    0
.xdata$x:00009835                 db    0
.xdata$x:00009836                 db    0
.xdata$x:00009837                 db    0
.xdata$x:00009838                 db 0FFh
.xdata$x:00009839                 db 0FFh
.xdata$x:0000983A                 db 0FFh
.xdata$x:0000983B                 db 0FFh
.xdata$x:0000983C                 db    0
.xdata$x:0000983D                 db    0
.xdata$x:0000983E                 db    0
.xdata$x:0000983F                 db    0
.xdata$x:00009840 __tryblocktable$?_Reallocate@?$vector@PB_WV?$allocator@PB_W@std@@@std@@IAEXI@Z db    0
.xdata$x:00009840                                         ; DATA XREF: .xdata$x:00009864o
.xdata$x:00009841                 db    0
.xdata$x:00009842                 db    0
.xdata$x:00009843                 db    0
.xdata$x:00009844                 db    0
.xdata$x:00009845                 db    0
.xdata$x:00009846                 db    0
.xdata$x:00009847                 db    0
.xdata$x:00009848                 db    1
.xdata$x:00009849                 db    0
.xdata$x:0000984A                 db    0
.xdata$x:0000984B                 db    0
.xdata$x:0000984C                 db    1
.xdata$x:0000984D                 db    0
.xdata$x:0000984E                 db    0
.xdata$x:0000984F                 db    0
.xdata$x:00009850                 dd offset __catchsym$?_Reallocate@?$vector@PB_WV?$allocator@PB_W@std@@@std@@IAEXI@Z$2
.xdata$x:00009854 __ehfuncinfo$?_Reallocate@?$vector@PB_WV?$allocator@PB_W@std@@@std@@IAEXI@Z db  22h ; "
.xdata$x:00009854                                         ; DATA XREF: __ehhandler$?_Reallocate@?$vector@PB_WV?$allocator@PB_W@std@@@std@@IAEXI@Z+11o
.xdata$x:00009855                 db    5
.xdata$x:00009856                 db  93h ; ô
.xdata$x:00009857                 db  19h
.xdata$x:00009858                 db    2
.xdata$x:00009859                 db    0
.xdata$x:0000985A                 db    0
.xdata$x:0000985B                 db    0
.xdata$x:0000985C                 dd offset __unwindtable$?_Reallocate@?$vector@PB_WV?$allocator@PB_W@std@@@std@@IAEXI@Z
.xdata$x:00009860                 db    1
.xdata$x:00009861                 db    0
.xdata$x:00009862                 db    0
.xdata$x:00009863                 db    0
.xdata$x:00009864                 dd offset __tryblocktable$?_Reallocate@?$vector@PB_WV?$allocator@PB_W@std@@@std@@IAEXI@Z
.xdata$x:00009868                 db    0
.xdata$x:00009869                 db    0
.xdata$x:0000986A                 db    0
.xdata$x:0000986B                 db    0
.xdata$x:0000986C                 db    0
.xdata$x:0000986D                 db    0
.xdata$x:0000986E                 db    0
.xdata$x:0000986F                 db    0
.xdata$x:00009870                 db    0
.xdata$x:00009871                 db    0
.xdata$x:00009872                 db    0
.xdata$x:00009873                 db    0
.xdata$x:00009874                 db    0
.xdata$x:00009875                 db    0
.xdata$x:00009876                 db    0
.xdata$x:00009877                 db    0
.xdata$x:00009877 _xdata$x        ends
.xdata$x:00009877
.xdata$x:00009878 ; ===========================================================================
.xdata$x:00009878
.xdata$x:00009878 ; Segment type: Pure data
.xdata$x:00009878 ; Segment permissions: Read
.xdata$x:00009878 _xdata$x        segment dword public 'DATA' use32
.xdata$x:00009878                 assume cs:_xdata$x
.xdata$x:00009878                 ;org 9878h
.xdata$x:00009878 ; COMDAT (pick associative to section at 6AFC)
.xdata$x:00009878 __unwindtable$?_Orphan_range@?$vector@PB_WV?$allocator@PB_W@std@@@std@@IBEXPAPB_W0@Z db 0FFh
.xdata$x:00009878                                         ; DATA XREF: .xdata$x:00009888o
.xdata$x:00009879                 db 0FFh
.xdata$x:0000987A                 db 0FFh
.xdata$x:0000987B                 db 0FFh
.xdata$x:0000987C                 dd offset __unwindfunclet$?_Orphan_range@?$vector@PB_WV?$allocator@PB_W@std@@@std@@IBEXPAPB_W0@Z$0
.xdata$x:00009880 __ehfuncinfo$?_Orphan_range@?$vector@PB_WV?$allocator@PB_W@std@@@std@@IBEXPAPB_W0@Z db  22h ; "
.xdata$x:00009880                                         ; DATA XREF: __ehhandler$?_Orphan_range@?$vector@PB_WV?$allocator@PB_W@std@@@std@@IBEXPAPB_W0@Z+11o
.xdata$x:00009881                 db    5
.xdata$x:00009882                 db  93h ; ô
.xdata$x:00009883                 db  19h
.xdata$x:00009884                 db    1
.xdata$x:00009885                 db    0
.xdata$x:00009886                 db    0
.xdata$x:00009887                 db    0
.xdata$x:00009888                 dd offset __unwindtable$?_Orphan_range@?$vector@PB_WV?$allocator@PB_W@std@@@std@@IBEXPAPB_W0@Z
.xdata$x:0000988C                 db    0
.xdata$x:0000988D                 db    0
.xdata$x:0000988E                 db    0
.xdata$x:0000988F                 db    0
.xdata$x:00009890                 db    0
.xdata$x:00009891                 db    0
.xdata$x:00009892                 db    0
.xdata$x:00009893                 db    0
.xdata$x:00009894                 db    0
.xdata$x:00009895                 db    0
.xdata$x:00009896                 db    0
.xdata$x:00009897                 db    0
.xdata$x:00009898                 db    0
.xdata$x:00009899                 db    0
.xdata$x:0000989A                 db    0
.xdata$x:0000989B                 db    0
.xdata$x:0000989C                 db    0
.xdata$x:0000989D                 db    0
.xdata$x:0000989E                 db    0
.xdata$x:0000989F                 db    0
.xdata$x:000098A0                 db    0
.xdata$x:000098A1                 db    0
.xdata$x:000098A2                 db    0
.xdata$x:000098A3                 db    0
.xdata$x:000098A3 _xdata$x        ends
.xdata$x:000098A3
.xdata$x:000098A4 ; ===========================================================================
.xdata$x:000098A4
.xdata$x:000098A4 ; Segment type: Pure data
.xdata$x:000098A4 ; Segment permissions: Read
.xdata$x:000098A4 _xdata$x        segment dword public 'DATA' use32
.xdata$x:000098A4                 assume cs:_xdata$x
.xdata$x:000098A4                 ;org 98A4h
.xdata$x:000098A4 ; COMDAT (pick associative to section at 8044)
.xdata$x:000098A4 __unwindtable$?construct@?$allocator@V?$vector@PB_WV?$allocator@PB_W@std@@@std@@@std@@QAEXPAV?$vector@PB_WV?$allocator@PB_W@std@@@2@ABV32@@Z db 0FFh
.xdata$x:000098A4                                         ; DATA XREF: .xdata$x:000098B4o
.xdata$x:000098A5                 db 0FFh
.xdata$x:000098A6                 db 0FFh
.xdata$x:000098A7                 db 0FFh
.xdata$x:000098A8                 dd offset __unwindfunclet$?construct@?$allocator@V?$vector@PB_WV?$allocator@PB_W@std@@@std@@@std@@QAEXPAV?$vector@PB_WV?$allocator@PB_W@std@@@2@ABV32@@Z$0
.xdata$x:000098AC __ehfuncinfo$?construct@?$allocator@V?$vector@PB_WV?$allocator@PB_W@std@@@std@@@std@@QAEXPAV?$vector@PB_WV?$allocator@PB_W@std@@@2@ABV32@@Z db  22h ; "
.xdata$x:000098AC                                         ; DATA XREF: __ehhandler$?construct@?$allocator@V?$vector@PB_WV?$allocator@PB_W@std@@@std@@@std@@QAEXPAV?$vector@PB_WV?$allocator@PB_W@std@@@2@ABV32@@Z+11o
.xdata$x:000098AD                 db    5
.xdata$x:000098AE                 db  93h ; ô
.xdata$x:000098AF                 db  19h
.xdata$x:000098B0                 db    1
.xdata$x:000098B1                 db    0
.xdata$x:000098B2                 db    0
.xdata$x:000098B3                 db    0
.xdata$x:000098B4                 dd offset __unwindtable$?construct@?$allocator@V?$vector@PB_WV?$allocator@PB_W@std@@@std@@@std@@QAEXPAV?$vector@PB_WV?$allocator@PB_W@std@@@2@ABV32@@Z
.xdata$x:000098B8                 db    0
.xdata$x:000098B9                 db    0
.xdata$x:000098BA                 db    0
.xdata$x:000098BB                 db    0
.xdata$x:000098BC                 db    0
.xdata$x:000098BD                 db    0
.xdata$x:000098BE                 db    0
.xdata$x:000098BF                 db    0
.xdata$x:000098C0                 db    0
.xdata$x:000098C1                 db    0
.xdata$x:000098C2                 db    0
.xdata$x:000098C3                 db    0
.xdata$x:000098C4                 db    0
.xdata$x:000098C5                 db    0
.xdata$x:000098C6                 db    0
.xdata$x:000098C7                 db    0
.xdata$x:000098C8                 db    0
.xdata$x:000098C9                 db    0
.xdata$x:000098CA                 db    0
.xdata$x:000098CB                 db    0
.xdata$x:000098CC                 db    0
.xdata$x:000098CD                 db    0
.xdata$x:000098CE                 db    0
.xdata$x:000098CF                 db    0
.xdata$x:000098CF _xdata$x        ends
.xdata$x:000098CF
.xdata$x:000098D0 ; ===========================================================================
.xdata$x:000098D0
.xdata$x:000098D0 ; Segment type: Pure data
.xdata$x:000098D0 ; Segment permissions: Read
.xdata$x:000098D0 _xdata$x        segment dword public 'DATA' use32
.xdata$x:000098D0                 assume cs:_xdata$x
.xdata$x:000098D0                 ;org 98D0h
.xdata$x:000098D0 ; COMDAT (pick associative to section at 7280)
.xdata$x:000098D0 __catchsym$?_Reallocate@?$vector@V?$vector@PB_WV?$allocator@PB_W@std@@@std@@V?$allocator@V?$vector@PB_WV?$allocator@PB_W@std@@@std@@@2@@std@@IAEXI@Z$2 db    0
.xdata$x:000098D0                                         ; DATA XREF: .xdata$x:00009900o
.xdata$x:000098D1                 db    0
.xdata$x:000098D2                 db    0
.xdata$x:000098D3                 db    0
.xdata$x:000098D4                 db    0
.xdata$x:000098D5                 db    0
.xdata$x:000098D6                 db    0
.xdata$x:000098D7                 db    0
.xdata$x:000098D8                 db    0
.xdata$x:000098D9                 db    0
.xdata$x:000098DA                 db    0
.xdata$x:000098DB                 db    0
.xdata$x:000098DC                 dd offset __catch$?_Reallocate@?$vector@V?$vector@PB_WV?$allocator@PB_W@std@@@std@@V?$allocator@V?$vector@PB_WV?$allocator@PB_W@std@@@std@@@2@@std@@IAEXI@Z$0
.xdata$x:000098E0 __unwindtable$?_Reallocate@?$vector@V?$vector@PB_WV?$allocator@PB_W@std@@@std@@V?$allocator@V?$vector@PB_WV?$allocator@PB_W@std@@@std@@@2@@std@@IAEXI@Z db 0FFh
.xdata$x:000098E0                                         ; DATA XREF: .xdata$x:0000990Co
.xdata$x:000098E1                 db 0FFh
.xdata$x:000098E2                 db 0FFh
.xdata$x:000098E3                 db 0FFh
.xdata$x:000098E4                 db    0
.xdata$x:000098E5                 db    0
.xdata$x:000098E6                 db    0
.xdata$x:000098E7                 db    0
.xdata$x:000098E8                 db 0FFh
.xdata$x:000098E9                 db 0FFh
.xdata$x:000098EA                 db 0FFh
.xdata$x:000098EB                 db 0FFh
.xdata$x:000098EC                 db    0
.xdata$x:000098ED                 db    0
.xdata$x:000098EE                 db    0
.xdata$x:000098EF                 db    0
.xdata$x:000098F0 __tryblocktable$?_Reallocate@?$vector@V?$vector@PB_WV?$allocator@PB_W@std@@@std@@V?$allocator@V?$vector@PB_WV?$allocator@PB_W@std@@@std@@@2@@std@@IAEXI@Z db    0
.xdata$x:000098F0                                         ; DATA XREF: .xdata$x:00009914o
.xdata$x:000098F1                 db    0
.xdata$x:000098F2                 db    0
.xdata$x:000098F3                 db    0
.xdata$x:000098F4                 db    0
.xdata$x:000098F5                 db    0
.xdata$x:000098F6                 db    0
.xdata$x:000098F7                 db    0
.xdata$x:000098F8                 db    1
.xdata$x:000098F9                 db    0
.xdata$x:000098FA                 db    0
.xdata$x:000098FB                 db    0
.xdata$x:000098FC                 db    1
.xdata$x:000098FD                 db    0
.xdata$x:000098FE                 db    0
.xdata$x:000098FF                 db    0
.xdata$x:00009900                 dd offset __catchsym$?_Reallocate@?$vector@V?$vector@PB_WV?$allocator@PB_W@std@@@std@@V?$allocator@V?$vector@PB_WV?$allocator@PB_W@std@@@std@@@2@@std@@IAEXI@Z$2
.xdata$x:00009904 __ehfuncinfo$?_Reallocate@?$vector@V?$vector@PB_WV?$allocator@PB_W@std@@@std@@V?$allocator@V?$vector@PB_WV?$allocator@PB_W@std@@@std@@@2@@std@@IAEXI@Z db  22h ; "
.xdata$x:00009904                                         ; DATA XREF: __ehhandler$?_Reallocate@?$vector@V?$vector@PB_WV?$allocator@PB_W@std@@@std@@V?$allocator@V?$vector@PB_WV?$allocator@PB_W@std@@@std@@@2@@std@@IAEXI@Z+11o
.xdata$x:00009905                 db    5
.xdata$x:00009906                 db  93h ; ô
.xdata$x:00009907                 db  19h
.xdata$x:00009908                 db    2
.xdata$x:00009909                 db    0
.xdata$x:0000990A                 db    0
.xdata$x:0000990B                 db    0
.xdata$x:0000990C                 dd offset __unwindtable$?_Reallocate@?$vector@V?$vector@PB_WV?$allocator@PB_W@std@@@std@@V?$allocator@V?$vector@PB_WV?$allocator@PB_W@std@@@std@@@2@@std@@IAEXI@Z
.xdata$x:00009910                 db    1
.xdata$x:00009911                 db    0
.xdata$x:00009912                 db    0
.xdata$x:00009913                 db    0
.xdata$x:00009914                 dd offset __tryblocktable$?_Reallocate@?$vector@V?$vector@PB_WV?$allocator@PB_W@std@@@std@@V?$allocator@V?$vector@PB_WV?$allocator@PB_W@std@@@std@@@2@@std@@IAEXI@Z
.xdata$x:00009918                 db    0
.xdata$x:00009919                 db    0
.xdata$x:0000991A                 db    0
.xdata$x:0000991B                 db    0
.xdata$x:0000991C                 db    0
.xdata$x:0000991D                 db    0
.xdata$x:0000991E                 db    0
.xdata$x:0000991F                 db    0
.xdata$x:00009920                 db    0
.xdata$x:00009921                 db    0
.xdata$x:00009922                 db    0
.xdata$x:00009923                 db    0
.xdata$x:00009924                 db    0
.xdata$x:00009925                 db    0
.xdata$x:00009926                 db    0
.xdata$x:00009927                 db    0
.xdata$x:00009927 _xdata$x        ends
.xdata$x:00009927
.xdata$x:00009928 ; ===========================================================================
.xdata$x:00009928
.xdata$x:00009928 ; Segment type: Pure data
.xdata$x:00009928 ; Segment permissions: Read
.xdata$x:00009928 _xdata$x        segment dword public 'DATA' use32
.xdata$x:00009928                 assume cs:_xdata$x
.xdata$x:00009928                 ;org 9928h
.xdata$x:00009928 ; COMDAT (pick associative to section at 6D90)
.xdata$x:00009928 __unwindtable$?_Orphan_range@?$vector@V?$vector@PB_WV?$allocator@PB_W@std@@@std@@V?$allocator@V?$vector@PB_WV?$allocator@PB_W@std@@@std@@@2@@std@@IBEXPAV?$vector@PB_WV?$allocator@PB_W@std@@@2@0@Z db 0FFh
.xdata$x:00009928                                         ; DATA XREF: .xdata$x:00009938o
.xdata$x:00009929                 db 0FFh
.xdata$x:0000992A                 db 0FFh
.xdata$x:0000992B                 db 0FFh
.xdata$x:0000992C                 dd offset __unwindfunclet$?_Orphan_range@?$vector@V?$vector@PB_WV?$allocator@PB_W@std@@@std@@V?$allocator@V?$vector@PB_WV?$allocator@PB_W@std@@@std@@@2@@std@@IBEXPAV?$vector@PB_WV?$allocator@PB_W@std@@@2@0@Z$0
.xdata$x:00009930 __ehfuncinfo$?_Orphan_range@?$vector@V?$vector@PB_WV?$allocator@PB_W@std@@@std@@V?$allocator@V?$vector@PB_WV?$allocator@PB_W@std@@@std@@@2@@std@@IBEXPAV?$vector@PB_WV?$allocator@PB_W@std@@@2@0@Z db  22h ; "
.xdata$x:00009930                                         ; DATA XREF: __ehhandler$?_Orphan_range@?$vector@V?$vector@PB_WV?$allocator@PB_W@std@@@std@@V?$allocator@V?$vector@PB_WV?$allocator@PB_W@std@@@std@@@2@@std@@IBEXPAV?$vector@PB_WV?$allocator@PB_W@std@@@2@0@Z+11o
.xdata$x:00009931                 db    5
.xdata$x:00009932                 db  93h ; ô
.xdata$x:00009933                 db  19h
.xdata$x:00009934                 db    1
.xdata$x:00009935                 db    0
.xdata$x:00009936                 db    0
.xdata$x:00009937                 db    0
.xdata$x:00009938                 dd offset __unwindtable$?_Orphan_range@?$vector@V?$vector@PB_WV?$allocator@PB_W@std@@@std@@V?$allocator@V?$vector@PB_WV?$allocator@PB_W@std@@@std@@@2@@std@@IBEXPAV?$vector@PB_WV?$allocator@PB_W@std@@@2@0@Z
.xdata$x:0000993C                 db    0
.xdata$x:0000993D                 db    0
.xdata$x:0000993E                 db    0
.xdata$x:0000993F                 db    0
.xdata$x:00009940                 db    0
.xdata$x:00009941                 db    0
.xdata$x:00009942                 db    0
.xdata$x:00009943                 db    0
.xdata$x:00009944                 db    0
.xdata$x:00009945                 db    0
.xdata$x:00009946                 db    0
.xdata$x:00009947                 db    0
.xdata$x:00009948                 db    0
.xdata$x:00009949                 db    0
.xdata$x:0000994A                 db    0
.xdata$x:0000994B                 db    0
.xdata$x:0000994C                 db    0
.xdata$x:0000994D                 db    0
.xdata$x:0000994E                 db    0
.xdata$x:0000994F                 db    0
.xdata$x:00009950                 db    0
.xdata$x:00009951                 db    0
.xdata$x:00009952                 db    0
.xdata$x:00009953                 db    0
.xdata$x:00009953 _xdata$x        ends
.xdata$x:00009953
.xdata$x:00009954 ; ===========================================================================
.xdata$x:00009954
.xdata$x:00009954 ; Segment type: Pure data
.xdata$x:00009954 ; Segment permissions: Read
.xdata$x:00009954 _xdata$x        segment dword public 'DATA' use32
.xdata$x:00009954                 assume cs:_xdata$x
.xdata$x:00009954                 ;org 9954h
.xdata$x:00009954 __unwindtable$?loadFunction@FunctionCallTip@@AAE_NXZ db 0FFh
.xdata$x:00009954                                         ; DATA XREF: .xdata$x:00009974o
.xdata$x:00009955                 db 0FFh
.xdata$x:00009956                 db 0FFh
.xdata$x:00009957                 db 0FFh
.xdata$x:00009958                 dd offset __unwindfunclet$?loadFunction@FunctionCallTip@@AAE_NXZ$0
.xdata$x:0000995C __unwindtable$?getCursorFunction@FunctionCallTip@@AAE_NXZ db 0FFh
.xdata$x:0000995C                                         ; DATA XREF: .xdata$x:00009998o
.xdata$x:0000995D                 db 0FFh
.xdata$x:0000995E                 db 0FFh
.xdata$x:0000995F                 db 0FFh
.xdata$x:00009960                 dd offset __unwindfunclet$?getCursorFunction@FunctionCallTip@@AAE_NXZ$0
.xdata$x:00009964                 align 8
.xdata$x:00009968                 dd offset __unwindfunclet$?getCursorFunction@FunctionCallTip@@AAE_NXZ$1
.xdata$x:0000996C __ehfuncinfo$?loadFunction@FunctionCallTip@@AAE_NXZ db  22h ; "
.xdata$x:0000996C                                         ; DATA XREF: __ehhandler$?loadFunction@FunctionCallTip@@AAE_NXZ+11o
.xdata$x:0000996D                 db    5
.xdata$x:0000996E                 db  93h ; ô
.xdata$x:0000996F                 db  19h
.xdata$x:00009970                 db    1
.xdata$x:00009971                 db    0
.xdata$x:00009972                 db    0
.xdata$x:00009973                 db    0
.xdata$x:00009974                 dd offset __unwindtable$?loadFunction@FunctionCallTip@@AAE_NXZ
.xdata$x:00009978                 db    0
.xdata$x:00009979                 db    0
.xdata$x:0000997A                 db    0
.xdata$x:0000997B                 db    0
.xdata$x:0000997C                 db    0
.xdata$x:0000997D                 db    0
.xdata$x:0000997E                 db    0
.xdata$x:0000997F                 db    0
.xdata$x:00009980                 db    0
.xdata$x:00009981                 db    0
.xdata$x:00009982                 db    0
.xdata$x:00009983                 db    0
.xdata$x:00009984                 db    0
.xdata$x:00009985                 db    0
.xdata$x:00009986                 db    0
.xdata$x:00009987                 db    0
.xdata$x:00009988                 db    0
.xdata$x:00009989                 db    0
.xdata$x:0000998A                 db    0
.xdata$x:0000998B                 db    0
.xdata$x:0000998C                 db    0
.xdata$x:0000998D                 db    0
.xdata$x:0000998E                 db    0
.xdata$x:0000998F                 db    0
.xdata$x:00009990 __ehfuncinfo$?getCursorFunction@FunctionCallTip@@AAE_NXZ db  22h ; "
.xdata$x:00009990                                         ; DATA XREF: __ehhandler$?getCursorFunction@FunctionCallTip@@AAE_NXZ+1Eo
.xdata$x:00009991                 db    5
.xdata$x:00009992                 db  93h ; ô
.xdata$x:00009993                 db  19h
.xdata$x:00009994                 db    2
.xdata$x:00009995                 db    0
.xdata$x:00009996                 db    0
.xdata$x:00009997                 db    0
.xdata$x:00009998                 dd offset __unwindtable$?getCursorFunction@FunctionCallTip@@AAE_NXZ
.xdata$x:0000999C                 db    0
.xdata$x:0000999D                 db    0
.xdata$x:0000999E                 db    0
.xdata$x:0000999F                 db    0
.xdata$x:000099A0                 db    0
.xdata$x:000099A1                 db    0
.xdata$x:000099A2                 db    0
.xdata$x:000099A3                 db    0
.xdata$x:000099A4                 db    0
.xdata$x:000099A5                 db    0
.xdata$x:000099A6                 db    0
.xdata$x:000099A7                 db    0
.xdata$x:000099A8                 db    0
.xdata$x:000099A9                 db    0
.xdata$x:000099AA                 db    0
.xdata$x:000099AB                 db    0
.xdata$x:000099AC                 db    0
.xdata$x:000099AD                 db    0
.xdata$x:000099AE                 db    0
.xdata$x:000099AF                 db    0
.xdata$x:000099B0                 db    0
.xdata$x:000099B1                 db    0
.xdata$x:000099B2                 db    0
.xdata$x:000099B3                 db    0
.xdata$x:000099B3 _xdata$x        ends
.xdata$x:000099B3
.xdata$x:000099B4 ; ===========================================================================
.xdata$x:000099B4
.xdata$x:000099B4 ; Segment type: Pure data
.xdata$x:000099B4 ; Segment permissions: Read
.xdata$x:000099B4 _xdata$x        segment dword public 'DATA' use32
.xdata$x:000099B4                 assume cs:_xdata$x
.xdata$x:000099B4                 ;org 99B4h
.xdata$x:000099B4 ; COMDAT (pick associative to section at 4650)
.xdata$x:000099B4 __unwindtable$??0?$_Vector_val@U?$_Simple_types@UToken@@@std@@@std@@QAE@XZ db 0FFh
.xdata$x:000099B4                                         ; DATA XREF: .xdata$x:000099C4o
.xdata$x:000099B5                 db 0FFh
.xdata$x:000099B6                 db 0FFh
.xdata$x:000099B7                 db 0FFh
.xdata$x:000099B8                 dd offset __unwindfunclet$??0?$_Vector_val@U?$_Simple_types@UToken@@@std@@@std@@QAE@XZ$0
.xdata$x:000099BC __ehfuncinfo$??0?$_Vector_val@U?$_Simple_types@UToken@@@std@@@std@@QAE@XZ db  22h ; "
.xdata$x:000099BC                                         ; DATA XREF: __ehhandler$??0?$_Vector_val@U?$_Simple_types@UToken@@@std@@@std@@QAE@XZ+11o
.xdata$x:000099BD                 db    5
.xdata$x:000099BE                 db  93h ; ô
.xdata$x:000099BF                 db  19h
.xdata$x:000099C0                 db    1
.xdata$x:000099C1                 db    0
.xdata$x:000099C2                 db    0
.xdata$x:000099C3                 db    0
.xdata$x:000099C4                 dd offset __unwindtable$??0?$_Vector_val@U?$_Simple_types@UToken@@@std@@@std@@QAE@XZ
.xdata$x:000099C8                 align 20h
.xdata$x:000099C8 _xdata$x        ends
.xdata$x:000099C8
.xdata$x:000099E0 ; ===========================================================================
.xdata$x:000099E0
.xdata$x:000099E0 ; Segment type: Pure data
.xdata$x:000099E0 ; Segment permissions: Read
.xdata$x:000099E0 _xdata$x        segment dword public 'DATA' use32
.xdata$x:000099E0                 assume cs:_xdata$x
.xdata$x:000099E0                 ;org 99E0h
.xdata$x:000099E0 ; COMDAT (pick associative to section at 5430)
.xdata$x:000099E0 __unwindtable$??1?$_Vector_val@U?$_Simple_types@UToken@@@std@@@std@@QAE@XZ db 0FFh
.xdata$x:000099E0                                         ; DATA XREF: .xdata$x:000099F0o
.xdata$x:000099E1                 db 0FFh
.xdata$x:000099E2                 db 0FFh
.xdata$x:000099E3                 db 0FFh
.xdata$x:000099E4                 dd offset __unwindfunclet$??1?$_Vector_val@U?$_Simple_types@UToken@@@std@@@std@@QAE@XZ$0
.xdata$x:000099E8 __ehfuncinfo$??1?$_Vector_val@U?$_Simple_types@UToken@@@std@@@std@@QAE@XZ db  22h ; "
.xdata$x:000099E8                                         ; DATA XREF: __ehhandler$??1?$_Vector_val@U?$_Simple_types@UToken@@@std@@@std@@QAE@XZ+11o
.xdata$x:000099E9                 db    5
.xdata$x:000099EA                 db  93h ; ô
.xdata$x:000099EB                 db  19h
.xdata$x:000099EC                 db    1
.xdata$x:000099ED                 db    0
.xdata$x:000099EE                 db    0
.xdata$x:000099EF                 db    0
.xdata$x:000099F0                 dd offset __unwindtable$??1?$_Vector_val@U?$_Simple_types@UToken@@@std@@@std@@QAE@XZ
.xdata$x:000099F4                 db    0
.xdata$x:000099F5                 db    0
.xdata$x:000099F6                 db    0
.xdata$x:000099F7                 db    0
.xdata$x:000099F8                 db    0
.xdata$x:000099F9                 db    0
.xdata$x:000099FA                 db    0
.xdata$x:000099FB                 db    0
.xdata$x:000099FC                 db    0
.xdata$x:000099FD                 db    0
.xdata$x:000099FE                 db    0
.xdata$x:000099FF                 db    0
.xdata$x:00009A00                 db    0
.xdata$x:00009A01                 db    0
.xdata$x:00009A02                 db    0
.xdata$x:00009A03                 db    0
.xdata$x:00009A04                 db    0
.xdata$x:00009A05                 db    0
.xdata$x:00009A06                 db    0
.xdata$x:00009A07                 db    0
.xdata$x:00009A08                 db    0
.xdata$x:00009A09                 db    0
.xdata$x:00009A0A                 db    0
.xdata$x:00009A0B                 db    0
.xdata$x:00009A0B _xdata$x        ends
.xdata$x:00009A0B
.xdata$x:00009A0C ; ===========================================================================
.xdata$x:00009A0C
.xdata$x:00009A0C ; Segment type: Pure data
.xdata$x:00009A0C ; Segment permissions: Read
.xdata$x:00009A0C _xdata$x        segment dword public 'DATA' use32
.xdata$x:00009A0C                 assume cs:_xdata$x
.xdata$x:00009A0C                 ;org 9A0Ch
.xdata$x:00009A0C ; COMDAT (pick associative to section at 41A0)
.xdata$x:00009A0C __unwindtable$??0?$_Vector_alloc@$0A@U?$_Vec_base_types@UToken@@V?$allocator@UToken@@@std@@@std@@@std@@QAE@ABV?$allocator@UToken@@@1@@Z db 0FFh
.xdata$x:00009A0C                                         ; DATA XREF: .xdata$x:00009A1Co
.xdata$x:00009A0D                 db 0FFh
.xdata$x:00009A0E                 db 0FFh
.xdata$x:00009A0F                 db 0FFh
.xdata$x:00009A10                 dd offset __unwindfunclet$??0?$_Vector_alloc@$0A@U?$_Vec_base_types@UToken@@V?$allocator@UToken@@@std@@@std@@@std@@QAE@ABV?$allocator@UToken@@@1@@Z$0
.xdata$x:00009A14 __ehfuncinfo$??0?$_Vector_alloc@$0A@U?$_Vec_base_types@UToken@@V?$allocator@UToken@@@std@@@std@@@std@@QAE@ABV?$allocator@UToken@@@1@@Z db  22h ; "
.xdata$x:00009A14                                         ; DATA XREF: __ehhandler$??0?$_Vector_alloc@$0A@U?$_Vec_base_types@UToken@@V?$allocator@UToken@@@std@@@std@@@std@@QAE@ABV?$allocator@UToken@@@1@@Z+11o
.xdata$x:00009A15                 db    5
.xdata$x:00009A16                 db  93h ; ô
.xdata$x:00009A17                 db  19h
.xdata$x:00009A18                 db    1
.xdata$x:00009A19                 db    0
.xdata$x:00009A1A                 db    0
.xdata$x:00009A1B                 db    0
.xdata$x:00009A1C                 dd offset __unwindtable$??0?$_Vector_alloc@$0A@U?$_Vec_base_types@UToken@@V?$allocator@UToken@@@std@@@std@@@std@@QAE@ABV?$allocator@UToken@@@1@@Z
.xdata$x:00009A20                 db    0
.xdata$x:00009A21                 db    0
.xdata$x:00009A22                 db    0
.xdata$x:00009A23                 db    0
.xdata$x:00009A24                 db    0
.xdata$x:00009A25                 db    0
.xdata$x:00009A26                 db    0
.xdata$x:00009A27                 db    0
.xdata$x:00009A28                 db    0
.xdata$x:00009A29                 db    0
.xdata$x:00009A2A                 db    0
.xdata$x:00009A2B                 db    0
.xdata$x:00009A2C                 db    0
.xdata$x:00009A2D                 db    0
.xdata$x:00009A2E                 db    0
.xdata$x:00009A2F                 db    0
.xdata$x:00009A30                 db    0
.xdata$x:00009A31                 db    0
.xdata$x:00009A32                 db    0
.xdata$x:00009A33                 db    0
.xdata$x:00009A34                 db    0
.xdata$x:00009A35                 db    0
.xdata$x:00009A36                 db    0
.xdata$x:00009A37                 db    0
.xdata$x:00009A37 _xdata$x        ends
.xdata$x:00009A37
.xdata$x:00009A38 ; ===========================================================================
.xdata$x:00009A38
.xdata$x:00009A38 ; Segment type: Pure data
.xdata$x:00009A38 ; Segment permissions: Read
.xdata$x:00009A38 _xdata$x        segment dword public 'DATA' use32
.xdata$x:00009A38                 assume cs:_xdata$x
.xdata$x:00009A38                 ;org 9A38h
.xdata$x:00009A38 ; COMDAT (pick associative to section at 5188)
.xdata$x:00009A38 __unwindtable$??1?$_Vector_alloc@$0A@U?$_Vec_base_types@UToken@@V?$allocator@UToken@@@std@@@std@@@std@@QAE@XZ db 0FFh
.xdata$x:00009A38                                         ; DATA XREF: .xdata$x:00009A48o
.xdata$x:00009A39                 db 0FFh
.xdata$x:00009A3A                 db 0FFh
.xdata$x:00009A3B                 db 0FFh
.xdata$x:00009A3C                 dd offset __unwindfunclet$??1?$_Vector_alloc@$0A@U?$_Vec_base_types@UToken@@V?$allocator@UToken@@@std@@@std@@@std@@QAE@XZ$0
.xdata$x:00009A40 __ehfuncinfo$??1?$_Vector_alloc@$0A@U?$_Vec_base_types@UToken@@V?$allocator@UToken@@@std@@@std@@@std@@QAE@XZ db  22h ; "
.xdata$x:00009A40                                         ; DATA XREF: __ehhandler$??1?$_Vector_alloc@$0A@U?$_Vec_base_types@UToken@@V?$allocator@UToken@@@std@@@std@@@std@@QAE@XZ+11o
.xdata$x:00009A41                 db    5
.xdata$x:00009A42                 db  93h ; ô
.xdata$x:00009A43                 db  19h
.xdata$x:00009A44                 db    1
.xdata$x:00009A45                 db    0
.xdata$x:00009A46                 db    0
.xdata$x:00009A47                 db    0
.xdata$x:00009A48                 dd offset __unwindtable$??1?$_Vector_alloc@$0A@U?$_Vec_base_types@UToken@@V?$allocator@UToken@@@std@@@std@@@std@@QAE@XZ
.xdata$x:00009A4C                 db    0
.xdata$x:00009A4D                 db    0
.xdata$x:00009A4E                 db    0
.xdata$x:00009A4F                 db    0
.xdata$x:00009A50                 db    0
.xdata$x:00009A51                 db    0
.xdata$x:00009A52                 db    0
.xdata$x:00009A53                 db    0
.xdata$x:00009A54                 db    0
.xdata$x:00009A55                 db    0
.xdata$x:00009A56                 db    0
.xdata$x:00009A57                 db    0
.xdata$x:00009A58                 db    0
.xdata$x:00009A59                 db    0
.xdata$x:00009A5A                 db    0
.xdata$x:00009A5B                 db    0
.xdata$x:00009A5C                 db    0
.xdata$x:00009A5D                 db    0
.xdata$x:00009A5E                 db    0
.xdata$x:00009A5F                 db    0
.xdata$x:00009A60                 db    0
.xdata$x:00009A61                 db    0
.xdata$x:00009A62                 db    0
.xdata$x:00009A63                 db    0
.xdata$x:00009A63 _xdata$x        ends
.xdata$x:00009A63
.xdata$x:00009A64 ; ===========================================================================
.xdata$x:00009A64
.xdata$x:00009A64 ; Segment type: Pure data
.xdata$x:00009A64 ; Segment permissions: Read
.xdata$x:00009A64 _xdata$x        segment dword public 'DATA' use32
.xdata$x:00009A64                 assume cs:_xdata$x
.xdata$x:00009A64                 ;org 9A64h
.xdata$x:00009A64 ; COMDAT (pick associative to section at 4B84)
.xdata$x:00009A64 __unwindtable$??0?$vector@UToken@@V?$allocator@UToken@@@std@@@std@@QAE@XZ db 0FFh
.xdata$x:00009A64                                         ; DATA XREF: .xdata$x:00009A74o
.xdata$x:00009A65                 db 0FFh
.xdata$x:00009A66                 db 0FFh
.xdata$x:00009A67                 db 0FFh
.xdata$x:00009A68                 dd offset __unwindfunclet$??0?$vector@UToken@@V?$allocator@UToken@@@std@@@std@@QAE@XZ$0
.xdata$x:00009A6C __ehfuncinfo$??0?$vector@UToken@@V?$allocator@UToken@@@std@@@std@@QAE@XZ db  22h ; "
.xdata$x:00009A6C                                         ; DATA XREF: __ehhandler$??0?$vector@UToken@@V?$allocator@UToken@@@std@@@std@@QAE@XZ+11o
.xdata$x:00009A6D                 db    5
.xdata$x:00009A6E                 db  93h ; ô
.xdata$x:00009A6F                 db  19h
.xdata$x:00009A70                 db    1
.xdata$x:00009A71                 db    0
.xdata$x:00009A72                 db    0
.xdata$x:00009A73                 db    0
.xdata$x:00009A74                 dd offset __unwindtable$??0?$vector@UToken@@V?$allocator@UToken@@@std@@@std@@QAE@XZ
.xdata$x:00009A78                 db    0
.xdata$x:00009A79                 db    0
.xdata$x:00009A7A                 db    0
.xdata$x:00009A7B                 db    0
.xdata$x:00009A7C                 db    0
.xdata$x:00009A7D                 db    0
.xdata$x:00009A7E                 db    0
.xdata$x:00009A7F                 db    0
.xdata$x:00009A80                 db    0
.xdata$x:00009A81                 db    0
.xdata$x:00009A82                 db    0
.xdata$x:00009A83                 db    0
.xdata$x:00009A84                 db    0
.xdata$x:00009A85                 db    0
.xdata$x:00009A86                 db    0
.xdata$x:00009A87                 db    0
.xdata$x:00009A88                 db    0
.xdata$x:00009A89                 db    0
.xdata$x:00009A8A                 db    0
.xdata$x:00009A8B                 db    0
.xdata$x:00009A8C                 db    0
.xdata$x:00009A8D                 db    0
.xdata$x:00009A8E                 db    0
.xdata$x:00009A8F                 db    0
.xdata$x:00009A8F _xdata$x        ends
.xdata$x:00009A8F
.xdata$x:00009A90 ; ===========================================================================
.xdata$x:00009A90
.xdata$x:00009A90 ; Segment type: Pure data
.xdata$x:00009A90 ; Segment permissions: Read
.xdata$x:00009A90 _xdata$x        segment dword public 'DATA' use32
.xdata$x:00009A90                 assume cs:_xdata$x
.xdata$x:00009A90                 ;org 9A90h
.xdata$x:00009A90 ; COMDAT (pick associative to section at 560C)
.xdata$x:00009A90 __unwindtable$??1?$vector@UToken@@V?$allocator@UToken@@@std@@@std@@QAE@XZ db 0FFh
.xdata$x:00009A90                                         ; DATA XREF: .xdata$x:00009AA0o
.xdata$x:00009A91                 db 0FFh
.xdata$x:00009A92                 db 0FFh
.xdata$x:00009A93                 db 0FFh
.xdata$x:00009A94                 dd offset __unwindfunclet$??1?$vector@UToken@@V?$allocator@UToken@@@std@@@std@@QAE@XZ$0
.xdata$x:00009A98 __ehfuncinfo$??1?$vector@UToken@@V?$allocator@UToken@@@std@@@std@@QAE@XZ db  22h ; "
.xdata$x:00009A98                                         ; DATA XREF: __ehhandler$??1?$vector@UToken@@V?$allocator@UToken@@@std@@@std@@QAE@XZ+11o
.xdata$x:00009A99                 db    5
.xdata$x:00009A9A                 db  93h ; ô
.xdata$x:00009A9B                 db  19h
.xdata$x:00009A9C                 db    1
.xdata$x:00009A9D                 db    0
.xdata$x:00009A9E                 db    0
.xdata$x:00009A9F                 db    0
.xdata$x:00009AA0                 dd offset __unwindtable$??1?$vector@UToken@@V?$allocator@UToken@@@std@@@std@@QAE@XZ
.xdata$x:00009AA4                 db    0
.xdata$x:00009AA5                 db    0
.xdata$x:00009AA6                 db    0
.xdata$x:00009AA7                 db    0
.xdata$x:00009AA8                 db    0
.xdata$x:00009AA9                 db    0
.xdata$x:00009AAA                 db    0
.xdata$x:00009AAB                 db    0
.xdata$x:00009AAC                 db    0
.xdata$x:00009AAD                 db    0
.xdata$x:00009AAE                 db    0
.xdata$x:00009AAF                 db    0
.xdata$x:00009AB0                 db    0
.xdata$x:00009AB1                 db    0
.xdata$x:00009AB2                 db    0
.xdata$x:00009AB3                 db    0
.xdata$x:00009AB4                 db    0
.xdata$x:00009AB5                 db    0
.xdata$x:00009AB6                 db    0
.xdata$x:00009AB7                 db    0
.xdata$x:00009AB8                 db    0
.xdata$x:00009AB9                 db    0
.xdata$x:00009ABA                 db    0
.xdata$x:00009ABB                 db    0
.xdata$x:00009ABB _xdata$x        ends
.xdata$x:00009ABB
.xdata$x:00009ABC ; ===========================================================================
.xdata$x:00009ABC
.xdata$x:00009ABC ; Segment type: Pure data
.xdata$x:00009ABC ; Segment permissions: Read
.xdata$x:00009ABC _xdata$x        segment dword public 'DATA' use32
.xdata$x:00009ABC                 assume cs:_xdata$x
.xdata$x:00009ABC                 ;org 9ABCh
.xdata$x:00009ABC ; COMDAT (pick associative to section at 7124)
.xdata$x:00009ABC __catchsym$?_Reallocate@?$vector@UToken@@V?$allocator@UToken@@@std@@@std@@IAEXI@Z$2 db    0
.xdata$x:00009ABC                                         ; DATA XREF: .xdata$x:00009AECo
.xdata$x:00009ABD                 db    0
.xdata$x:00009ABE                 db    0
.xdata$x:00009ABF                 db    0
.xdata$x:00009AC0                 db    0
.xdata$x:00009AC1                 db    0
.xdata$x:00009AC2                 db    0
.xdata$x:00009AC3                 db    0
.xdata$x:00009AC4                 db    0
.xdata$x:00009AC5                 db    0
.xdata$x:00009AC6                 db    0
.xdata$x:00009AC7                 db    0
.xdata$x:00009AC8                 dd offset __catch$?_Reallocate@?$vector@UToken@@V?$allocator@UToken@@@std@@@std@@IAEXI@Z$0
.xdata$x:00009ACC __unwindtable$?_Reallocate@?$vector@UToken@@V?$allocator@UToken@@@std@@@std@@IAEXI@Z db 0FFh
.xdata$x:00009ACC                                         ; DATA XREF: .xdata$x:00009AF8o
.xdata$x:00009ACD                 db 0FFh
.xdata$x:00009ACE                 db 0FFh
.xdata$x:00009ACF                 db 0FFh
.xdata$x:00009AD0                 db    0
.xdata$x:00009AD1                 db    0
.xdata$x:00009AD2                 db    0
.xdata$x:00009AD3                 db    0
.xdata$x:00009AD4                 db 0FFh
.xdata$x:00009AD5                 db 0FFh
.xdata$x:00009AD6                 db 0FFh
.xdata$x:00009AD7                 db 0FFh
.xdata$x:00009AD8                 db    0
.xdata$x:00009AD9                 db    0
.xdata$x:00009ADA                 db    0
.xdata$x:00009ADB                 db    0
.xdata$x:00009ADC __tryblocktable$?_Reallocate@?$vector@UToken@@V?$allocator@UToken@@@std@@@std@@IAEXI@Z db    0
.xdata$x:00009ADC                                         ; DATA XREF: .xdata$x:00009B00o
.xdata$x:00009ADD                 db    0
.xdata$x:00009ADE                 db    0
.xdata$x:00009ADF                 db    0
.xdata$x:00009AE0                 db    0
.xdata$x:00009AE1                 db    0
.xdata$x:00009AE2                 db    0
.xdata$x:00009AE3                 db    0
.xdata$x:00009AE4                 db    1
.xdata$x:00009AE5                 db    0
.xdata$x:00009AE6                 db    0
.xdata$x:00009AE7                 db    0
.xdata$x:00009AE8                 db    1
.xdata$x:00009AE9                 db    0
.xdata$x:00009AEA                 db    0
.xdata$x:00009AEB                 db    0
.xdata$x:00009AEC                 dd offset __catchsym$?_Reallocate@?$vector@UToken@@V?$allocator@UToken@@@std@@@std@@IAEXI@Z$2
.xdata$x:00009AF0 __ehfuncinfo$?_Reallocate@?$vector@UToken@@V?$allocator@UToken@@@std@@@std@@IAEXI@Z db  22h ; "
.xdata$x:00009AF0                                         ; DATA XREF: __ehhandler$?_Reallocate@?$vector@UToken@@V?$allocator@UToken@@@std@@@std@@IAEXI@Z+11o
.xdata$x:00009AF1                 db    5
.xdata$x:00009AF2                 db  93h ; ô
.xdata$x:00009AF3                 db  19h
.xdata$x:00009AF4                 db    2
.xdata$x:00009AF5                 db    0
.xdata$x:00009AF6                 db    0
.xdata$x:00009AF7                 db    0
.xdata$x:00009AF8                 dd offset __unwindtable$?_Reallocate@?$vector@UToken@@V?$allocator@UToken@@@std@@@std@@IAEXI@Z
.xdata$x:00009AFC                 db    1
.xdata$x:00009AFD                 db    0
.xdata$x:00009AFE                 db    0
.xdata$x:00009AFF                 db    0
.xdata$x:00009B00                 dd offset __tryblocktable$?_Reallocate@?$vector@UToken@@V?$allocator@UToken@@@std@@@std@@IAEXI@Z
.xdata$x:00009B04                 db    0
.xdata$x:00009B05                 db    0
.xdata$x:00009B06                 db    0
.xdata$x:00009B07                 db    0
.xdata$x:00009B08                 db    0
.xdata$x:00009B09                 db    0
.xdata$x:00009B0A                 db    0
.xdata$x:00009B0B                 db    0
.xdata$x:00009B0C                 db    0
.xdata$x:00009B0D                 db    0
.xdata$x:00009B0E                 db    0
.xdata$x:00009B0F                 db    0
.xdata$x:00009B10                 db    0
.xdata$x:00009B11                 db    0
.xdata$x:00009B12                 db    0
.xdata$x:00009B13                 db    0
.xdata$x:00009B13 _xdata$x        ends
.xdata$x:00009B13
.xdata$x:00009B14 ; ===========================================================================
.xdata$x:00009B14
.xdata$x:00009B14 ; Segment type: Pure data
.xdata$x:00009B14 ; Segment permissions: Read
.xdata$x:00009B14 _xdata$x        segment dword public 'DATA' use32
.xdata$x:00009B14                 assume cs:_xdata$x
.xdata$x:00009B14                 ;org 9B14h
.xdata$x:00009B14 ; COMDAT (pick associative to section at 6CB4)
.xdata$x:00009B14 __unwindtable$?_Orphan_range@?$vector@UToken@@V?$allocator@UToken@@@std@@@std@@IBEXPAUToken@@0@Z db 0FFh
.xdata$x:00009B14                                         ; DATA XREF: .xdata$x:00009B24o
.xdata$x:00009B15                 db 0FFh
.xdata$x:00009B16                 db 0FFh
.xdata$x:00009B17                 db 0FFh
.xdata$x:00009B18                 dd offset __unwindfunclet$?_Orphan_range@?$vector@UToken@@V?$allocator@UToken@@@std@@@std@@IBEXPAUToken@@0@Z$0
.xdata$x:00009B1C __ehfuncinfo$?_Orphan_range@?$vector@UToken@@V?$allocator@UToken@@@std@@@std@@IBEXPAUToken@@0@Z db  22h ; "
.xdata$x:00009B1C                                         ; DATA XREF: __ehhandler$?_Orphan_range@?$vector@UToken@@V?$allocator@UToken@@@std@@@std@@IBEXPAUToken@@0@Z+11o
.xdata$x:00009B1D                 db    5
.xdata$x:00009B1E                 db  93h ; ô
.xdata$x:00009B1F                 db  19h
.xdata$x:00009B20                 db    1
.xdata$x:00009B21                 db    0
.xdata$x:00009B22                 db    0
.xdata$x:00009B23                 db    0
.xdata$x:00009B24                 dd offset __unwindtable$?_Orphan_range@?$vector@UToken@@V?$allocator@UToken@@@std@@@std@@IBEXPAUToken@@0@Z
.xdata$x:00009B28                 align 20h
.xdata$x:00009B28 _xdata$x        ends
.xdata$x:00009B28
.xdata$x:00009B40 ; ===========================================================================
.xdata$x:00009B40
.xdata$x:00009B40 ; Segment type: Pure data
.xdata$x:00009B40 ; Segment permissions: Read
.xdata$x:00009B40 _xdata$x        segment dword public 'DATA' use32
.xdata$x:00009B40                 assume cs:_xdata$x
.xdata$x:00009B40                 ;org 9B40h
.xdata$x:00009B40 ; COMDAT (pick associative to section at 45C0)
.xdata$x:00009B40 __unwindtable$??0?$_Vector_val@U?$_Simple_types@UFunctionValues@@@std@@@std@@QAE@XZ db 0FFh
.xdata$x:00009B40                                         ; DATA XREF: .xdata$x:00009B50o
.xdata$x:00009B41                 db 0FFh
.xdata$x:00009B42                 db 0FFh
.xdata$x:00009B43                 db 0FFh
.xdata$x:00009B44                 dd offset __unwindfunclet$??0?$_Vector_val@U?$_Simple_types@UFunctionValues@@@std@@@std@@QAE@XZ$0
.xdata$x:00009B48 __ehfuncinfo$??0?$_Vector_val@U?$_Simple_types@UFunctionValues@@@std@@@std@@QAE@XZ db  22h ; "
.xdata$x:00009B48                                         ; DATA XREF: __ehhandler$??0?$_Vector_val@U?$_Simple_types@UFunctionValues@@@std@@@std@@QAE@XZ+11o
.xdata$x:00009B49                 db    5
.xdata$x:00009B4A                 db  93h ; ô
.xdata$x:00009B4B                 db  19h
.xdata$x:00009B4C                 db    1
.xdata$x:00009B4D                 db    0
.xdata$x:00009B4E                 db    0
.xdata$x:00009B4F                 db    0
.xdata$x:00009B50                 dd offset __unwindtable$??0?$_Vector_val@U?$_Simple_types@UFunctionValues@@@std@@@std@@QAE@XZ
.xdata$x:00009B54                 db    0
.xdata$x:00009B55                 db    0
.xdata$x:00009B56                 db    0
.xdata$x:00009B57                 db    0
.xdata$x:00009B58                 db    0
.xdata$x:00009B59                 db    0
.xdata$x:00009B5A                 db    0
.xdata$x:00009B5B                 db    0
.xdata$x:00009B5C                 db    0
.xdata$x:00009B5D                 db    0
.xdata$x:00009B5E                 db    0
.xdata$x:00009B5F                 db    0
.xdata$x:00009B60                 db    0
.xdata$x:00009B61                 db    0
.xdata$x:00009B62                 db    0
.xdata$x:00009B63                 db    0
.xdata$x:00009B64                 db    0
.xdata$x:00009B65                 db    0
.xdata$x:00009B66                 db    0
.xdata$x:00009B67                 db    0
.xdata$x:00009B68                 db    0
.xdata$x:00009B69                 db    0
.xdata$x:00009B6A                 db    0
.xdata$x:00009B6B                 db    0
.xdata$x:00009B6B _xdata$x        ends
.xdata$x:00009B6B
.xdata$x:00009B6C ; ===========================================================================
.xdata$x:00009B6C
.xdata$x:00009B6C ; Segment type: Pure data
.xdata$x:00009B6C ; Segment permissions: Read
.xdata$x:00009B6C _xdata$x        segment dword public 'DATA' use32
.xdata$x:00009B6C                 assume cs:_xdata$x
.xdata$x:00009B6C                 ;org 9B6Ch
.xdata$x:00009B6C ; COMDAT (pick associative to section at 53C0)
.xdata$x:00009B6C __unwindtable$??1?$_Vector_val@U?$_Simple_types@UFunctionValues@@@std@@@std@@QAE@XZ db 0FFh
.xdata$x:00009B6C                                         ; DATA XREF: .xdata$x:00009B7Co
.xdata$x:00009B6D                 db 0FFh
.xdata$x:00009B6E                 db 0FFh
.xdata$x:00009B6F                 db 0FFh
.xdata$x:00009B70                 dd offset __unwindfunclet$??1?$_Vector_val@U?$_Simple_types@UFunctionValues@@@std@@@std@@QAE@XZ$0
.xdata$x:00009B74 __ehfuncinfo$??1?$_Vector_val@U?$_Simple_types@UFunctionValues@@@std@@@std@@QAE@XZ db  22h ; "
.xdata$x:00009B74                                         ; DATA XREF: __ehhandler$??1?$_Vector_val@U?$_Simple_types@UFunctionValues@@@std@@@std@@QAE@XZ+11o
.xdata$x:00009B75                 db    5
.xdata$x:00009B76                 db  93h ; ô
.xdata$x:00009B77                 db  19h
.xdata$x:00009B78                 db    1
.xdata$x:00009B79                 db    0
.xdata$x:00009B7A                 db    0
.xdata$x:00009B7B                 db    0
.xdata$x:00009B7C                 dd offset __unwindtable$??1?$_Vector_val@U?$_Simple_types@UFunctionValues@@@std@@@std@@QAE@XZ
.xdata$x:00009B80                 db    0
.xdata$x:00009B81                 db    0
.xdata$x:00009B82                 db    0
.xdata$x:00009B83                 db    0
.xdata$x:00009B84                 db    0
.xdata$x:00009B85                 db    0
.xdata$x:00009B86                 db    0
.xdata$x:00009B87                 db    0
.xdata$x:00009B88                 db    0
.xdata$x:00009B89                 db    0
.xdata$x:00009B8A                 db    0
.xdata$x:00009B8B                 db    0
.xdata$x:00009B8C                 db    0
.xdata$x:00009B8D                 db    0
.xdata$x:00009B8E                 db    0
.xdata$x:00009B8F                 db    0
.xdata$x:00009B90                 db    0
.xdata$x:00009B91                 db    0
.xdata$x:00009B92                 db    0
.xdata$x:00009B93                 db    0
.xdata$x:00009B94                 db    0
.xdata$x:00009B95                 db    0
.xdata$x:00009B96                 db    0
.xdata$x:00009B97                 db    0
.xdata$x:00009B97 _xdata$x        ends
.xdata$x:00009B97
.xdata$x:00009B98 ; ===========================================================================
.xdata$x:00009B98
.xdata$x:00009B98 ; Segment type: Pure data
.xdata$x:00009B98 ; Segment permissions: Read
.xdata$x:00009B98 _xdata$x        segment dword public 'DATA' use32
.xdata$x:00009B98                 assume cs:_xdata$x
.xdata$x:00009B98                 ;org 9B98h
.xdata$x:00009B98 ; COMDAT (pick associative to section at 4124)
.xdata$x:00009B98 __unwindtable$??0?$_Vector_alloc@$0A@U?$_Vec_base_types@UFunctionValues@@V?$allocator@UFunctionValues@@@std@@@std@@@std@@QAE@ABV?$allocator@UFunctionValues@@@1@@Z db 0FFh
.xdata$x:00009B98                                         ; DATA XREF: .xdata$x:00009BA8o
.xdata$x:00009B99                 db 0FFh
.xdata$x:00009B9A                 db 0FFh
.xdata$x:00009B9B                 db 0FFh
.xdata$x:00009B9C                 dd offset __unwindfunclet$??0?$_Vector_alloc@$0A@U?$_Vec_base_types@UFunctionValues@@V?$allocator@UFunctionValues@@@std@@@std@@@std@@QAE@ABV?$allocator@UFunctionValues@@@1@@Z$0
.xdata$x:00009BA0 __ehfuncinfo$??0?$_Vector_alloc@$0A@U?$_Vec_base_types@UFunctionValues@@V?$allocator@UFunctionValues@@@std@@@std@@@std@@QAE@ABV?$allocator@UFunctionValues@@@1@@Z db  22h ; "
.xdata$x:00009BA0                                         ; DATA XREF: __ehhandler$??0?$_Vector_alloc@$0A@U?$_Vec_base_types@UFunctionValues@@V?$allocator@UFunctionValues@@@std@@@std@@@std@@QAE@ABV?$allocator@UFunctionValues@@@1@@Z+11o
.xdata$x:00009BA1                 db    5
.xdata$x:00009BA2                 db  93h ; ô
.xdata$x:00009BA3                 db  19h
.xdata$x:00009BA4                 db    1
.xdata$x:00009BA5                 db    0
.xdata$x:00009BA6                 db    0
.xdata$x:00009BA7                 db    0
.xdata$x:00009BA8                 dd offset __unwindtable$??0?$_Vector_alloc@$0A@U?$_Vec_base_types@UFunctionValues@@V?$allocator@UFunctionValues@@@std@@@std@@@std@@QAE@ABV?$allocator@UFunctionValues@@@1@@Z
.xdata$x:00009BAC                 db    0
.xdata$x:00009BAD                 db    0
.xdata$x:00009BAE                 db    0
.xdata$x:00009BAF                 db    0
.xdata$x:00009BB0                 db    0
.xdata$x:00009BB1                 db    0
.xdata$x:00009BB2                 db    0
.xdata$x:00009BB3                 db    0
.xdata$x:00009BB4                 db    0
.xdata$x:00009BB5                 db    0
.xdata$x:00009BB6                 db    0
.xdata$x:00009BB7                 db    0
.xdata$x:00009BB8                 db    0
.xdata$x:00009BB9                 db    0
.xdata$x:00009BBA                 db    0
.xdata$x:00009BBB                 db    0
.xdata$x:00009BBC                 db    0
.xdata$x:00009BBD                 db    0
.xdata$x:00009BBE                 db    0
.xdata$x:00009BBF                 db    0
.xdata$x:00009BC0                 db    0
.xdata$x:00009BC1                 db    0
.xdata$x:00009BC2                 db    0
.xdata$x:00009BC3                 db    0
.xdata$x:00009BC3 _xdata$x        ends
.xdata$x:00009BC3
.xdata$x:00009BC4 ; ===========================================================================
.xdata$x:00009BC4
.xdata$x:00009BC4 ; Segment type: Pure data
.xdata$x:00009BC4 ; Segment permissions: Read
.xdata$x:00009BC4 _xdata$x        segment dword public 'DATA' use32
.xdata$x:00009BC4                 assume cs:_xdata$x
.xdata$x:00009BC4                 ;org 9BC4h
.xdata$x:00009BC4 ; COMDAT (pick associative to section at 5110)
.xdata$x:00009BC4 __unwindtable$??1?$_Vector_alloc@$0A@U?$_Vec_base_types@UFunctionValues@@V?$allocator@UFunctionValues@@@std@@@std@@@std@@QAE@XZ db 0FFh
.xdata$x:00009BC4                                         ; DATA XREF: .xdata$x:00009BD4o
.xdata$x:00009BC5                 db 0FFh
.xdata$x:00009BC6                 db 0FFh
.xdata$x:00009BC7                 db 0FFh
.xdata$x:00009BC8                 dd offset __unwindfunclet$??1?$_Vector_alloc@$0A@U?$_Vec_base_types@UFunctionValues@@V?$allocator@UFunctionValues@@@std@@@std@@@std@@QAE@XZ$0
.xdata$x:00009BCC __ehfuncinfo$??1?$_Vector_alloc@$0A@U?$_Vec_base_types@UFunctionValues@@V?$allocator@UFunctionValues@@@std@@@std@@@std@@QAE@XZ db  22h ; "
.xdata$x:00009BCC                                         ; DATA XREF: __ehhandler$??1?$_Vector_alloc@$0A@U?$_Vec_base_types@UFunctionValues@@V?$allocator@UFunctionValues@@@std@@@std@@@std@@QAE@XZ+11o
.xdata$x:00009BCD                 db    5
.xdata$x:00009BCE                 db  93h ; ô
.xdata$x:00009BCF                 db  19h
.xdata$x:00009BD0                 db    1
.xdata$x:00009BD1                 db    0
.xdata$x:00009BD2                 db    0
.xdata$x:00009BD3                 db    0
.xdata$x:00009BD4                 dd offset __unwindtable$??1?$_Vector_alloc@$0A@U?$_Vec_base_types@UFunctionValues@@V?$allocator@UFunctionValues@@@std@@@std@@@std@@QAE@XZ
.xdata$x:00009BD8                 db    0
.xdata$x:00009BD9                 db    0
.xdata$x:00009BDA                 db    0
.xdata$x:00009BDB                 db    0
.xdata$x:00009BDC                 db    0
.xdata$x:00009BDD                 db    0
.xdata$x:00009BDE                 db    0
.xdata$x:00009BDF                 db    0
.xdata$x:00009BE0                 db    0
.xdata$x:00009BE1                 db    0
.xdata$x:00009BE2                 db    0
.xdata$x:00009BE3                 db    0
.xdata$x:00009BE4                 db    0
.xdata$x:00009BE5                 db    0
.xdata$x:00009BE6                 db    0
.xdata$x:00009BE7                 db    0
.xdata$x:00009BE8                 db    0
.xdata$x:00009BE9                 db    0
.xdata$x:00009BEA                 db    0
.xdata$x:00009BEB                 db    0
.xdata$x:00009BEC                 db    0
.xdata$x:00009BED                 db    0
.xdata$x:00009BEE                 db    0
.xdata$x:00009BEF                 db    0
.xdata$x:00009BEF _xdata$x        ends
.xdata$x:00009BEF
.xdata$x:00009BF0 ; ===========================================================================
.xdata$x:00009BF0
.xdata$x:00009BF0 ; Segment type: Pure data
.xdata$x:00009BF0 ; Segment permissions: Read
.xdata$x:00009BF0 _xdata$x        segment dword public 'DATA' use32
.xdata$x:00009BF0                 assume cs:_xdata$x
.xdata$x:00009BF0                 ;org 9BF0h
.xdata$x:00009BF0 ; COMDAT (pick associative to section at 4B04)
.xdata$x:00009BF0 __unwindtable$??0?$vector@UFunctionValues@@V?$allocator@UFunctionValues@@@std@@@std@@QAE@XZ db 0FFh
.xdata$x:00009BF0                                         ; DATA XREF: .xdata$x:00009C00o
.xdata$x:00009BF1                 db 0FFh
.xdata$x:00009BF2                 db 0FFh
.xdata$x:00009BF3                 db 0FFh
.xdata$x:00009BF4                 dd offset __unwindfunclet$??0?$vector@UFunctionValues@@V?$allocator@UFunctionValues@@@std@@@std@@QAE@XZ$0
.xdata$x:00009BF8 __ehfuncinfo$??0?$vector@UFunctionValues@@V?$allocator@UFunctionValues@@@std@@@std@@QAE@XZ db  22h ; "
.xdata$x:00009BF8                                         ; DATA XREF: __ehhandler$??0?$vector@UFunctionValues@@V?$allocator@UFunctionValues@@@std@@@std@@QAE@XZ+11o
.xdata$x:00009BF9                 db    5
.xdata$x:00009BFA                 db  93h ; ô
.xdata$x:00009BFB                 db  19h
.xdata$x:00009BFC                 db    1
.xdata$x:00009BFD                 db    0
.xdata$x:00009BFE                 db    0
.xdata$x:00009BFF                 db    0
.xdata$x:00009C00                 dd offset __unwindtable$??0?$vector@UFunctionValues@@V?$allocator@UFunctionValues@@@std@@@std@@QAE@XZ
.xdata$x:00009C04                 db    0
.xdata$x:00009C05                 db    0
.xdata$x:00009C06                 db    0
.xdata$x:00009C07                 db    0
.xdata$x:00009C08                 db    0
.xdata$x:00009C09                 db    0
.xdata$x:00009C0A                 db    0
.xdata$x:00009C0B                 db    0
.xdata$x:00009C0C                 db    0
.xdata$x:00009C0D                 db    0
.xdata$x:00009C0E                 db    0
.xdata$x:00009C0F                 db    0
.xdata$x:00009C10                 db    0
.xdata$x:00009C11                 db    0
.xdata$x:00009C12                 db    0
.xdata$x:00009C13                 db    0
.xdata$x:00009C14                 db    0
.xdata$x:00009C15                 db    0
.xdata$x:00009C16                 db    0
.xdata$x:00009C17                 db    0
.xdata$x:00009C18                 db    0
.xdata$x:00009C19                 db    0
.xdata$x:00009C1A                 db    0
.xdata$x:00009C1B                 db    0
.xdata$x:00009C1B _xdata$x        ends
.xdata$x:00009C1B
.xdata$x:00009C1C ; ===========================================================================
.xdata$x:00009C1C
.xdata$x:00009C1C ; Segment type: Pure data
.xdata$x:00009C1C ; Segment permissions: Read
.xdata$x:00009C1C _xdata$x        segment dword public 'DATA' use32
.xdata$x:00009C1C                 assume cs:_xdata$x
.xdata$x:00009C1C                 ;org 9C1Ch
.xdata$x:00009C1C ; COMDAT (pick associative to section at 5594)
.xdata$x:00009C1C __unwindtable$??1?$vector@UFunctionValues@@V?$allocator@UFunctionValues@@@std@@@std@@QAE@XZ db 0FFh
.xdata$x:00009C1C                                         ; DATA XREF: .xdata$x:00009C2Co
.xdata$x:00009C1D                 db 0FFh
.xdata$x:00009C1E                 db 0FFh
.xdata$x:00009C1F                 db 0FFh
.xdata$x:00009C20                 dd offset __unwindfunclet$??1?$vector@UFunctionValues@@V?$allocator@UFunctionValues@@@std@@@std@@QAE@XZ$0
.xdata$x:00009C24 __ehfuncinfo$??1?$vector@UFunctionValues@@V?$allocator@UFunctionValues@@@std@@@std@@QAE@XZ db  22h ; "
.xdata$x:00009C24                                         ; DATA XREF: __ehhandler$??1?$vector@UFunctionValues@@V?$allocator@UFunctionValues@@@std@@@std@@QAE@XZ+11o
.xdata$x:00009C25                 db    5
.xdata$x:00009C26                 db  93h ; ô
.xdata$x:00009C27                 db  19h
.xdata$x:00009C28                 db    1
.xdata$x:00009C29                 db    0
.xdata$x:00009C2A                 db    0
.xdata$x:00009C2B                 db    0
.xdata$x:00009C2C                 dd offset __unwindtable$??1?$vector@UFunctionValues@@V?$allocator@UFunctionValues@@@std@@@std@@QAE@XZ
.xdata$x:00009C30                 db    0
.xdata$x:00009C31                 db    0
.xdata$x:00009C32                 db    0
.xdata$x:00009C33                 db    0
.xdata$x:00009C34                 db    0
.xdata$x:00009C35                 db    0
.xdata$x:00009C36                 db    0
.xdata$x:00009C37                 db    0
.xdata$x:00009C38                 db    0
.xdata$x:00009C39                 db    0
.xdata$x:00009C3A                 db    0
.xdata$x:00009C3B                 db    0
.xdata$x:00009C3C                 db    0
.xdata$x:00009C3D                 db    0
.xdata$x:00009C3E                 db    0
.xdata$x:00009C3F                 db    0
.xdata$x:00009C40                 db    0
.xdata$x:00009C41                 db    0
.xdata$x:00009C42                 db    0
.xdata$x:00009C43                 db    0
.xdata$x:00009C44                 db    0
.xdata$x:00009C45                 db    0
.xdata$x:00009C46                 db    0
.xdata$x:00009C47                 db    0
.xdata$x:00009C47 _xdata$x        ends
.xdata$x:00009C47
.xdata$x:00009C48 ; ===========================================================================
.xdata$x:00009C48
.xdata$x:00009C48 ; Segment type: Pure data
.xdata$x:00009C48 ; Segment permissions: Read
.xdata$x:00009C48 _xdata$x        segment dword public 'DATA' use32
.xdata$x:00009C48                 assume cs:_xdata$x
.xdata$x:00009C48                 ;org 9C48h
.xdata$x:00009C48 ; COMDAT (pick associative to section at 83BC)
.xdata$x:00009C48 __unwindtable$?end@?$vector@UFunctionValues@@V?$allocator@UFunctionValues@@@std@@@std@@QAE?AV?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@UFunctionValues@@@std@@@std@@@2@XZ db 0FFh
.xdata$x:00009C48                                         ; DATA XREF: .xdata$x:00009C58o
.xdata$x:00009C49                 db 0FFh
.xdata$x:00009C4A                 db 0FFh
.xdata$x:00009C4B                 db 0FFh
.xdata$x:00009C4C                 dd offset __unwindfunclet$?end@?$vector@UFunctionValues@@V?$allocator@UFunctionValues@@@std@@@std@@QAE?AV?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@UFunctionValues@@@std@@@std@@@2@XZ$0
.xdata$x:00009C50 __ehfuncinfo$?end@?$vector@UFunctionValues@@V?$allocator@UFunctionValues@@@std@@@std@@QAE?AV?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@UFunctionValues@@@std@@@std@@@2@XZ db  22h ; "
.xdata$x:00009C50                                         ; DATA XREF: __ehhandler$?end@?$vector@UFunctionValues@@V?$allocator@UFunctionValues@@@std@@@std@@QAE?AV?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@UFunctionValues@@@std@@@std@@@2@XZ+11o
.xdata$x:00009C51                 db    5
.xdata$x:00009C52                 db  93h ; ô
.xdata$x:00009C53                 db  19h
.xdata$x:00009C54                 db    1
.xdata$x:00009C55                 db    0
.xdata$x:00009C56                 db    0
.xdata$x:00009C57                 db    0
.xdata$x:00009C58                 dd offset __unwindtable$?end@?$vector@UFunctionValues@@V?$allocator@UFunctionValues@@@std@@@std@@QAE?AV?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@UFunctionValues@@@std@@@std@@@2@XZ
.xdata$x:00009C5C                 db    0
.xdata$x:00009C5D                 db    0
.xdata$x:00009C5E                 db    0
.xdata$x:00009C5F                 db    0
.xdata$x:00009C60                 db    0
.xdata$x:00009C61                 db    0
.xdata$x:00009C62                 db    0
.xdata$x:00009C63                 db    0
.xdata$x:00009C64                 db    0
.xdata$x:00009C65                 db    0
.xdata$x:00009C66                 db    0
.xdata$x:00009C67                 db    0
.xdata$x:00009C68                 db    0
.xdata$x:00009C69                 db    0
.xdata$x:00009C6A                 db    0
.xdata$x:00009C6B                 db    0
.xdata$x:00009C6C                 db    0
.xdata$x:00009C6D                 db    0
.xdata$x:00009C6E                 db    0
.xdata$x:00009C6F                 db    0
.xdata$x:00009C70                 db    0
.xdata$x:00009C71                 db    0
.xdata$x:00009C72                 db    0
.xdata$x:00009C73                 db    0
.xdata$x:00009C73 _xdata$x        ends
.xdata$x:00009C73
.xdata$x:00009C74 ; ===========================================================================
.xdata$x:00009C74
.xdata$x:00009C74 ; Segment type: Pure data
.xdata$x:00009C74 ; Segment permissions: Read
.xdata$x:00009C74 _xdata$x        segment dword public 'DATA' use32
.xdata$x:00009C74                 assume cs:_xdata$x
.xdata$x:00009C74                 ;org 9C74h
.xdata$x:00009C74 ; COMDAT (pick associative to section at 7CF8)
.xdata$x:00009C74 __unwindtable$?back@?$vector@UFunctionValues@@V?$allocator@UFunctionValues@@@std@@@std@@QAEAAUFunctionValues@@XZ db 0FFh
.xdata$x:00009C74                                         ; DATA XREF: .xdata$x:00009C8Co
.xdata$x:00009C75                 db 0FFh
.xdata$x:00009C76                 db 0FFh
.xdata$x:00009C77                 db 0FFh
.xdata$x:00009C78                 dd offset __unwindfunclet$?back@?$vector@UFunctionValues@@V?$allocator@UFunctionValues@@@std@@@std@@QAEAAUFunctionValues@@XZ$0
.xdata$x:00009C7C                 align 10h
.xdata$x:00009C80                 dd offset __unwindfunclet$?back@?$vector@UFunctionValues@@V?$allocator@UFunctionValues@@@std@@@std@@QAEAAUFunctionValues@@XZ$1
.xdata$x:00009C84 __ehfuncinfo$?back@?$vector@UFunctionValues@@V?$allocator@UFunctionValues@@@std@@@std@@QAEAAUFunctionValues@@XZ db  22h ; "
.xdata$x:00009C84                                         ; DATA XREF: __ehhandler$?back@?$vector@UFunctionValues@@V?$allocator@UFunctionValues@@@std@@@std@@QAEAAUFunctionValues@@XZ+11o
.xdata$x:00009C85                 db    5
.xdata$x:00009C86                 db  93h ; ô
.xdata$x:00009C87                 db  19h
.xdata$x:00009C88                 db    2
.xdata$x:00009C89                 db    0
.xdata$x:00009C8A                 db    0
.xdata$x:00009C8B                 db    0
.xdata$x:00009C8C                 dd offset __unwindtable$?back@?$vector@UFunctionValues@@V?$allocator@UFunctionValues@@@std@@@std@@QAEAAUFunctionValues@@XZ
.xdata$x:00009C90                 db    0
.xdata$x:00009C91                 db    0
.xdata$x:00009C92                 db    0
.xdata$x:00009C93                 db    0
.xdata$x:00009C94                 db    0
.xdata$x:00009C95                 db    0
.xdata$x:00009C96                 db    0
.xdata$x:00009C97                 db    0
.xdata$x:00009C98                 db    0
.xdata$x:00009C99                 db    0
.xdata$x:00009C9A                 db    0
.xdata$x:00009C9B                 db    0
.xdata$x:00009C9C                 db    0
.xdata$x:00009C9D                 db    0
.xdata$x:00009C9E                 db    0
.xdata$x:00009C9F                 db    0
.xdata$x:00009CA0                 db    0
.xdata$x:00009CA1                 db    0
.xdata$x:00009CA2                 db    0
.xdata$x:00009CA3                 db    0
.xdata$x:00009CA4                 db    0
.xdata$x:00009CA5                 db    0
.xdata$x:00009CA6                 db    0
.xdata$x:00009CA7                 db    0
.xdata$x:00009CA7 _xdata$x        ends
.xdata$x:00009CA7
.xdata$x:00009CA8 ; ===========================================================================
.xdata$x:00009CA8
.xdata$x:00009CA8 ; Segment type: Pure data
.xdata$x:00009CA8 ; Segment permissions: Read
.xdata$x:00009CA8 _xdata$x        segment dword public 'DATA' use32
.xdata$x:00009CA8                 assume cs:_xdata$x
.xdata$x:00009CA8                 ;org 9CA8h
.xdata$x:00009CA8 ; COMDAT (pick associative to section at 6FC8)
.xdata$x:00009CA8 __catchsym$?_Reallocate@?$vector@UFunctionValues@@V?$allocator@UFunctionValues@@@std@@@std@@IAEXI@Z$2 db    0
.xdata$x:00009CA8                                         ; DATA XREF: .xdata$x:00009CD8o
.xdata$x:00009CA9                 db    0
.xdata$x:00009CAA                 db    0
.xdata$x:00009CAB                 db    0
.xdata$x:00009CAC                 db    0
.xdata$x:00009CAD                 db    0
.xdata$x:00009CAE                 db    0
.xdata$x:00009CAF                 db    0
.xdata$x:00009CB0                 db    0
.xdata$x:00009CB1                 db    0
.xdata$x:00009CB2                 db    0
.xdata$x:00009CB3                 db    0
.xdata$x:00009CB4                 dd offset __catch$?_Reallocate@?$vector@UFunctionValues@@V?$allocator@UFunctionValues@@@std@@@std@@IAEXI@Z$0
.xdata$x:00009CB8 __unwindtable$?_Reallocate@?$vector@UFunctionValues@@V?$allocator@UFunctionValues@@@std@@@std@@IAEXI@Z db 0FFh
.xdata$x:00009CB8                                         ; DATA XREF: .xdata$x:00009CE4o
.xdata$x:00009CB9                 db 0FFh
.xdata$x:00009CBA                 db 0FFh
.xdata$x:00009CBB                 db 0FFh
.xdata$x:00009CBC                 db    0
.xdata$x:00009CBD                 db    0
.xdata$x:00009CBE                 db    0
.xdata$x:00009CBF                 db    0
.xdata$x:00009CC0                 db 0FFh
.xdata$x:00009CC1                 db 0FFh
.xdata$x:00009CC2                 db 0FFh
.xdata$x:00009CC3                 db 0FFh
.xdata$x:00009CC4                 db    0
.xdata$x:00009CC5                 db    0
.xdata$x:00009CC6                 db    0
.xdata$x:00009CC7                 db    0
.xdata$x:00009CC8 __tryblocktable$?_Reallocate@?$vector@UFunctionValues@@V?$allocator@UFunctionValues@@@std@@@std@@IAEXI@Z db    0
.xdata$x:00009CC8                                         ; DATA XREF: .xdata$x:00009CECo
.xdata$x:00009CC9                 db    0
.xdata$x:00009CCA                 db    0
.xdata$x:00009CCB                 db    0
.xdata$x:00009CCC                 db    0
.xdata$x:00009CCD                 db    0
.xdata$x:00009CCE                 db    0
.xdata$x:00009CCF                 db    0
.xdata$x:00009CD0                 db    1
.xdata$x:00009CD1                 db    0
.xdata$x:00009CD2                 db    0
.xdata$x:00009CD3                 db    0
.xdata$x:00009CD4                 db    1
.xdata$x:00009CD5                 db    0
.xdata$x:00009CD6                 db    0
.xdata$x:00009CD7                 db    0
.xdata$x:00009CD8                 dd offset __catchsym$?_Reallocate@?$vector@UFunctionValues@@V?$allocator@UFunctionValues@@@std@@@std@@IAEXI@Z$2
.xdata$x:00009CDC __ehfuncinfo$?_Reallocate@?$vector@UFunctionValues@@V?$allocator@UFunctionValues@@@std@@@std@@IAEXI@Z db  22h ; "
.xdata$x:00009CDC                                         ; DATA XREF: __ehhandler$?_Reallocate@?$vector@UFunctionValues@@V?$allocator@UFunctionValues@@@std@@@std@@IAEXI@Z+11o
.xdata$x:00009CDD                 db    5
.xdata$x:00009CDE                 db  93h ; ô
.xdata$x:00009CDF                 db  19h
.xdata$x:00009CE0                 db    2
.xdata$x:00009CE1                 db    0
.xdata$x:00009CE2                 db    0
.xdata$x:00009CE3                 db    0
.xdata$x:00009CE4                 dd offset __unwindtable$?_Reallocate@?$vector@UFunctionValues@@V?$allocator@UFunctionValues@@@std@@@std@@IAEXI@Z
.xdata$x:00009CE8                 db    1
.xdata$x:00009CE9                 db    0
.xdata$x:00009CEA                 db    0
.xdata$x:00009CEB                 db    0
.xdata$x:00009CEC                 dd offset __tryblocktable$?_Reallocate@?$vector@UFunctionValues@@V?$allocator@UFunctionValues@@@std@@@std@@IAEXI@Z
.xdata$x:00009CF0                 align 20h
.xdata$x:00009CF0 _xdata$x        ends
.xdata$x:00009CF0
.xdata$x:00009D00 ; ===========================================================================
.xdata$x:00009D00
.xdata$x:00009D00 ; Segment type: Pure data
.xdata$x:00009D00 ; Segment permissions: Read
.xdata$x:00009D00 _xdata$x        segment dword public 'DATA' use32
.xdata$x:00009D00                 assume cs:_xdata$x
.xdata$x:00009D00                 ;org 9D00h
.xdata$x:00009D00 ; COMDAT (pick associative to section at 6BD8)
.xdata$x:00009D00 __unwindtable$?_Orphan_range@?$vector@UFunctionValues@@V?$allocator@UFunctionValues@@@std@@@std@@IBEXPAUFunctionValues@@0@Z db 0FFh
.xdata$x:00009D00                                         ; DATA XREF: .xdata$x:00009D10o
.xdata$x:00009D01                 db 0FFh
.xdata$x:00009D02                 db 0FFh
.xdata$x:00009D03                 db 0FFh
.xdata$x:00009D04                 dd offset __unwindfunclet$?_Orphan_range@?$vector@UFunctionValues@@V?$allocator@UFunctionValues@@@std@@@std@@IBEXPAUFunctionValues@@0@Z$0
.xdata$x:00009D08 __ehfuncinfo$?_Orphan_range@?$vector@UFunctionValues@@V?$allocator@UFunctionValues@@@std@@@std@@IBEXPAUFunctionValues@@0@Z db  22h ; "
.xdata$x:00009D08                                         ; DATA XREF: __ehhandler$?_Orphan_range@?$vector@UFunctionValues@@V?$allocator@UFunctionValues@@@std@@@std@@IBEXPAUFunctionValues@@0@Z+11o
.xdata$x:00009D09                 db    5
.xdata$x:00009D0A                 db  93h ; ô
.xdata$x:00009D0B                 db  19h
.xdata$x:00009D0C                 db    1
.xdata$x:00009D0D                 db    0
.xdata$x:00009D0E                 db    0
.xdata$x:00009D0F                 db    0
.xdata$x:00009D10                 dd offset __unwindtable$?_Orphan_range@?$vector@UFunctionValues@@V?$allocator@UFunctionValues@@@std@@@std@@IBEXPAUFunctionValues@@0@Z
.xdata$x:00009D14                 db    0
.xdata$x:00009D15                 db    0
.xdata$x:00009D16                 db    0
.xdata$x:00009D17                 db    0
.xdata$x:00009D18                 db    0
.xdata$x:00009D19                 db    0
.xdata$x:00009D1A                 db    0
.xdata$x:00009D1B                 db    0
.xdata$x:00009D1C                 db    0
.xdata$x:00009D1D                 db    0
.xdata$x:00009D1E                 db    0
.xdata$x:00009D1F                 db    0
.xdata$x:00009D20                 db    0
.xdata$x:00009D21                 db    0
.xdata$x:00009D22                 db    0
.xdata$x:00009D23                 db    0
.xdata$x:00009D24                 db    0
.xdata$x:00009D25                 db    0
.xdata$x:00009D26                 db    0
.xdata$x:00009D27                 db    0
.xdata$x:00009D28                 db    0
.xdata$x:00009D29                 db    0
.xdata$x:00009D2A                 db    0
.xdata$x:00009D2B                 db    0
.xdata$x:00009D2B _xdata$x        ends
.xdata$x:00009D2B
.xdata$x:00009D2C ; ===========================================================================
.xdata$x:00009D2C
.xdata$x:00009D2C ; Segment type: Pure data
.xdata$x:00009D2C ; Segment permissions: Read
.xdata$x:00009D2C _xdata$x        segment dword public 'DATA' use32
.xdata$x:00009D2C                 assume cs:_xdata$x
.xdata$x:00009D2C                 ;org 9D2Ch
.xdata$x:00009D2C ; COMDAT (pick associative to section at 3F30)
.xdata$x:00009D2C __unwindtable$??0?$_Iterator012@Urandom_access_iterator_tag@std@@UFunctionValues@@HPBU3@ABU3@U_Iterator_base12@2@@std@@QAE@XZ db 0FFh
.xdata$x:00009D2C                                         ; DATA XREF: .xdata$x:00009D3Co
.xdata$x:00009D2D                 db 0FFh
.xdata$x:00009D2E                 db 0FFh
.xdata$x:00009D2F                 db 0FFh
.xdata$x:00009D30                 dd offset __unwindfunclet$??0?$_Iterator012@Urandom_access_iterator_tag@std@@UFunctionValues@@HPBU3@ABU3@U_Iterator_base12@2@@std@@QAE@XZ$0
.xdata$x:00009D34 __ehfuncinfo$??0?$_Iterator012@Urandom_access_iterator_tag@std@@UFunctionValues@@HPBU3@ABU3@U_Iterator_base12@2@@std@@QAE@XZ db  22h ; "
.xdata$x:00009D34                                         ; DATA XREF: __ehhandler$??0?$_Iterator012@Urandom_access_iterator_tag@std@@UFunctionValues@@HPBU3@ABU3@U_Iterator_base12@2@@std@@QAE@XZ+11o
.xdata$x:00009D35                 db    5
.xdata$x:00009D36                 db  93h ; ô
.xdata$x:00009D37                 db  19h
.xdata$x:00009D38                 db    1
.xdata$x:00009D39                 db    0
.xdata$x:00009D3A                 db    0
.xdata$x:00009D3B                 db    0
.xdata$x:00009D3C                 dd offset __unwindtable$??0?$_Iterator012@Urandom_access_iterator_tag@std@@UFunctionValues@@HPBU3@ABU3@U_Iterator_base12@2@@std@@QAE@XZ
.xdata$x:00009D40                 db    0
.xdata$x:00009D41                 db    0
.xdata$x:00009D42                 db    0
.xdata$x:00009D43                 db    0
.xdata$x:00009D44                 db    0
.xdata$x:00009D45                 db    0
.xdata$x:00009D46                 db    0
.xdata$x:00009D47                 db    0
.xdata$x:00009D48                 db    0
.xdata$x:00009D49                 db    0
.xdata$x:00009D4A                 db    0
.xdata$x:00009D4B                 db    0
.xdata$x:00009D4C                 db    0
.xdata$x:00009D4D                 db    0
.xdata$x:00009D4E                 db    0
.xdata$x:00009D4F                 db    0
.xdata$x:00009D50                 db    0
.xdata$x:00009D51                 db    0
.xdata$x:00009D52                 db    0
.xdata$x:00009D53                 db    0
.xdata$x:00009D54                 db    0
.xdata$x:00009D55                 db    0
.xdata$x:00009D56                 db    0
.xdata$x:00009D57                 db    0
.xdata$x:00009D57 _xdata$x        ends
.xdata$x:00009D57
.xdata$x:00009D58 ; ===========================================================================
.xdata$x:00009D58
.xdata$x:00009D58 ; Segment type: Pure data
.xdata$x:00009D58 ; Segment permissions: Read
.xdata$x:00009D58 _xdata$x        segment dword public 'DATA' use32
.xdata$x:00009D58                 assume cs:_xdata$x
.xdata$x:00009D58                 ;org 9D58h
.xdata$x:00009D58 ; COMDAT (pick associative to section at 4F40)
.xdata$x:00009D58 __unwindtable$??1?$_Iterator012@Urandom_access_iterator_tag@std@@UFunctionValues@@HPBU3@ABU3@U_Iterator_base12@2@@std@@QAE@XZ db 0FFh
.xdata$x:00009D58                                         ; DATA XREF: .xdata$x:00009D68o
.xdata$x:00009D59                 db 0FFh
.xdata$x:00009D5A                 db 0FFh
.xdata$x:00009D5B                 db 0FFh
.xdata$x:00009D5C                 dd offset __unwindfunclet$??1?$_Iterator012@Urandom_access_iterator_tag@std@@UFunctionValues@@HPBU3@ABU3@U_Iterator_base12@2@@std@@QAE@XZ$0
.xdata$x:00009D60 __ehfuncinfo$??1?$_Iterator012@Urandom_access_iterator_tag@std@@UFunctionValues@@HPBU3@ABU3@U_Iterator_base12@2@@std@@QAE@XZ db  22h ; "
.xdata$x:00009D60                                         ; DATA XREF: __ehhandler$??1?$_Iterator012@Urandom_access_iterator_tag@std@@UFunctionValues@@HPBU3@ABU3@U_Iterator_base12@2@@std@@QAE@XZ+11o
.xdata$x:00009D61                 db    5
.xdata$x:00009D62                 db  93h ; ô
.xdata$x:00009D63                 db  19h
.xdata$x:00009D64                 db    1
.xdata$x:00009D65                 db    0
.xdata$x:00009D66                 db    0
.xdata$x:00009D67                 db    0
.xdata$x:00009D68                 dd offset __unwindtable$??1?$_Iterator012@Urandom_access_iterator_tag@std@@UFunctionValues@@HPBU3@ABU3@U_Iterator_base12@2@@std@@QAE@XZ
.xdata$x:00009D6C                 db    0
.xdata$x:00009D6D                 db    0
.xdata$x:00009D6E                 db    0
.xdata$x:00009D6F                 db    0
.xdata$x:00009D70                 db    0
.xdata$x:00009D71                 db    0
.xdata$x:00009D72                 db    0
.xdata$x:00009D73                 db    0
.xdata$x:00009D74                 db    0
.xdata$x:00009D75                 db    0
.xdata$x:00009D76                 db    0
.xdata$x:00009D77                 db    0
.xdata$x:00009D78                 db    0
.xdata$x:00009D79                 db    0
.xdata$x:00009D7A                 db    0
.xdata$x:00009D7B                 db    0
.xdata$x:00009D7C                 db    0
.xdata$x:00009D7D                 db    0
.xdata$x:00009D7E                 db    0
.xdata$x:00009D7F                 db    0
.xdata$x:00009D80                 db    0
.xdata$x:00009D81                 db    0
.xdata$x:00009D82                 db    0
.xdata$x:00009D83                 db    0
.xdata$x:00009D83 _xdata$x        ends
.xdata$x:00009D83
.xdata$x:00009D84 ; ===========================================================================
.xdata$x:00009D84
.xdata$x:00009D84 ; Segment type: Pure data
.xdata$x:00009D84 ; Segment permissions: Read
.xdata$x:00009D84 _xdata$x        segment dword public 'DATA' use32
.xdata$x:00009D84                 assume cs:_xdata$x
.xdata$x:00009D84                 ;org 9D84h
.xdata$x:00009D84 ; COMDAT (pick associative to section at 3EB8)
.xdata$x:00009D84 __unwindtable$??0?$_Iterator012@Urandom_access_iterator_tag@std@@UFunctionValues@@HPBU3@ABU3@U_Iterator_base12@2@@std@@QAE@ABU01@@Z db 0FFh
.xdata$x:00009D84                                         ; DATA XREF: .xdata$x:00009D94o
.xdata$x:00009D85                 db 0FFh
.xdata$x:00009D86                 db 0FFh
.xdata$x:00009D87                 db 0FFh
.xdata$x:00009D88                 dd offset __unwindfunclet$??0?$_Iterator012@Urandom_access_iterator_tag@std@@UFunctionValues@@HPBU3@ABU3@U_Iterator_base12@2@@std@@QAE@ABU01@@Z$0
.xdata$x:00009D8C __ehfuncinfo$??0?$_Iterator012@Urandom_access_iterator_tag@std@@UFunctionValues@@HPBU3@ABU3@U_Iterator_base12@2@@std@@QAE@ABU01@@Z db  22h ; "
.xdata$x:00009D8C                                         ; DATA XREF: __ehhandler$??0?$_Iterator012@Urandom_access_iterator_tag@std@@UFunctionValues@@HPBU3@ABU3@U_Iterator_base12@2@@std@@QAE@ABU01@@Z+11o
.xdata$x:00009D8D                 db    5
.xdata$x:00009D8E                 db  93h ; ô
.xdata$x:00009D8F                 db  19h
.xdata$x:00009D90                 db    1
.xdata$x:00009D91                 db    0
.xdata$x:00009D92                 db    0
.xdata$x:00009D93                 db    0
.xdata$x:00009D94                 dd offset __unwindtable$??0?$_Iterator012@Urandom_access_iterator_tag@std@@UFunctionValues@@HPBU3@ABU3@U_Iterator_base12@2@@std@@QAE@ABU01@@Z
.xdata$x:00009D98                 db    0
.xdata$x:00009D99                 db    0
.xdata$x:00009D9A                 db    0
.xdata$x:00009D9B                 db    0
.xdata$x:00009D9C                 db    0
.xdata$x:00009D9D                 db    0
.xdata$x:00009D9E                 db    0
.xdata$x:00009D9F                 db    0
.xdata$x:00009DA0                 db    0
.xdata$x:00009DA1                 db    0
.xdata$x:00009DA2                 db    0
.xdata$x:00009DA3                 db    0
.xdata$x:00009DA4                 db    0
.xdata$x:00009DA5                 db    0
.xdata$x:00009DA6                 db    0
.xdata$x:00009DA7                 db    0
.xdata$x:00009DA8                 db    0
.xdata$x:00009DA9                 db    0
.xdata$x:00009DAA                 db    0
.xdata$x:00009DAB                 db    0
.xdata$x:00009DAC                 db    0
.xdata$x:00009DAD                 db    0
.xdata$x:00009DAE                 db    0
.xdata$x:00009DAF                 db    0
.xdata$x:00009DAF _xdata$x        ends
.xdata$x:00009DAF
.xdata$x:00009DB0 ; ===========================================================================
.xdata$x:00009DB0
.xdata$x:00009DB0 ; Segment type: Pure data
.xdata$x:00009DB0 ; Segment permissions: Read
.xdata$x:00009DB0 _xdata$x        segment dword public 'DATA' use32
.xdata$x:00009DB0                 assume cs:_xdata$x
.xdata$x:00009DB0                 ;org 9DB0h
.xdata$x:00009DB0 ; COMDAT (pick associative to section at 43B0)
.xdata$x:00009DB0 __unwindtable$??0?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@UFunctionValues@@@std@@@std@@@std@@QAE@PAUFunctionValues@@PBU_Container_base12@1@@Z db 0FFh
.xdata$x:00009DB0                                         ; DATA XREF: .xdata$x:00009DC0o
.xdata$x:00009DB1                 db 0FFh
.xdata$x:00009DB2                 db 0FFh
.xdata$x:00009DB3                 db 0FFh
.xdata$x:00009DB4                 dd offset __unwindfunclet$??0?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@UFunctionValues@@@std@@@std@@@std@@QAE@PAUFunctionValues@@PBU_Container_base12@1@@Z$0
.xdata$x:00009DB8 __ehfuncinfo$??0?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@UFunctionValues@@@std@@@std@@@std@@QAE@PAUFunctionValues@@PBU_Container_base12@1@@Z db  22h ; "
.xdata$x:00009DB8                                         ; DATA XREF: __ehhandler$??0?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@UFunctionValues@@@std@@@std@@@std@@QAE@PAUFunctionValues@@PBU_Container_base12@1@@Z+11o
.xdata$x:00009DB9                 db    5
.xdata$x:00009DBA                 db  93h ; ô
.xdata$x:00009DBB                 db  19h
.xdata$x:00009DBC                 db    1
.xdata$x:00009DBD                 db    0
.xdata$x:00009DBE                 db    0
.xdata$x:00009DBF                 db    0
.xdata$x:00009DC0                 dd offset __unwindtable$??0?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@UFunctionValues@@@std@@@std@@@std@@QAE@PAUFunctionValues@@PBU_Container_base12@1@@Z
.xdata$x:00009DC4                 db    0
.xdata$x:00009DC5                 db    0
.xdata$x:00009DC6                 db    0
.xdata$x:00009DC7                 db    0
.xdata$x:00009DC8                 db    0
.xdata$x:00009DC9                 db    0
.xdata$x:00009DCA                 db    0
.xdata$x:00009DCB                 db    0
.xdata$x:00009DCC                 db    0
.xdata$x:00009DCD                 db    0
.xdata$x:00009DCE                 db    0
.xdata$x:00009DCF                 db    0
.xdata$x:00009DD0                 db    0
.xdata$x:00009DD1                 db    0
.xdata$x:00009DD2                 db    0
.xdata$x:00009DD3                 db    0
.xdata$x:00009DD4                 db    0
.xdata$x:00009DD5                 db    0
.xdata$x:00009DD6                 db    0
.xdata$x:00009DD7                 db    0
.xdata$x:00009DD8                 db    0
.xdata$x:00009DD9                 db    0
.xdata$x:00009DDA                 db    0
.xdata$x:00009DDB                 db    0
.xdata$x:00009DDB _xdata$x        ends
.xdata$x:00009DDB
.xdata$x:00009DDC ; ===========================================================================
.xdata$x:00009DDC
.xdata$x:00009DDC ; Segment type: Pure data
.xdata$x:00009DDC ; Segment permissions: Read
.xdata$x:00009DDC _xdata$x        segment dword public 'DATA' use32
.xdata$x:00009DDC                 assume cs:_xdata$x
.xdata$x:00009DDC                 ;org 9DDCh
.xdata$x:00009DDC ; COMDAT (pick associative to section at 5270)
.xdata$x:00009DDC __unwindtable$??1?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@UFunctionValues@@@std@@@std@@@std@@QAE@XZ db 0FFh
.xdata$x:00009DDC                                         ; DATA XREF: .xdata$x:00009DECo
.xdata$x:00009DDD                 db 0FFh
.xdata$x:00009DDE                 db 0FFh
.xdata$x:00009DDF                 db 0FFh
.xdata$x:00009DE0                 dd offset __unwindfunclet$??1?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@UFunctionValues@@@std@@@std@@@std@@QAE@XZ$0
.xdata$x:00009DE4 __ehfuncinfo$??1?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@UFunctionValues@@@std@@@std@@@std@@QAE@XZ db  22h ; "
.xdata$x:00009DE4                                         ; DATA XREF: __ehhandler$??1?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@UFunctionValues@@@std@@@std@@@std@@QAE@XZ+11o
.xdata$x:00009DE5                 db    5
.xdata$x:00009DE6                 db  93h ; ô
.xdata$x:00009DE7                 db  19h
.xdata$x:00009DE8                 db    1
.xdata$x:00009DE9                 db    0
.xdata$x:00009DEA                 db    0
.xdata$x:00009DEB                 db    0
.xdata$x:00009DEC                 dd offset __unwindtable$??1?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@UFunctionValues@@@std@@@std@@@std@@QAE@XZ
.xdata$x:00009DF0                 db    0
.xdata$x:00009DF1                 db    0
.xdata$x:00009DF2                 db    0
.xdata$x:00009DF3                 db    0
.xdata$x:00009DF4                 db    0
.xdata$x:00009DF5                 db    0
.xdata$x:00009DF6                 db    0
.xdata$x:00009DF7                 db    0
.xdata$x:00009DF8                 db    0
.xdata$x:00009DF9                 db    0
.xdata$x:00009DFA                 db    0
.xdata$x:00009DFB                 db    0
.xdata$x:00009DFC                 db    0
.xdata$x:00009DFD                 db    0
.xdata$x:00009DFE                 db    0
.xdata$x:00009DFF                 db    0
.xdata$x:00009E00                 db    0
.xdata$x:00009E01                 db    0
.xdata$x:00009E02                 db    0
.xdata$x:00009E03                 db    0
.xdata$x:00009E04                 db    0
.xdata$x:00009E05                 db    0
.xdata$x:00009E06                 db    0
.xdata$x:00009E07                 db    0
.xdata$x:00009E07 _xdata$x        ends
.xdata$x:00009E07
.xdata$x:00009E08 ; ===========================================================================
.xdata$x:00009E08
.xdata$x:00009E08 ; Segment type: Pure data
.xdata$x:00009E08 ; Segment permissions: Read
.xdata$x:00009E08 _xdata$x        segment dword public 'DATA' use32
.xdata$x:00009E08                 assume cs:_xdata$x
.xdata$x:00009E08                 ;org 9E08h
.xdata$x:00009E08 ; COMDAT (pick associative to section at 432C)
.xdata$x:00009E08 __unwindtable$??0?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@UFunctionValues@@@std@@@std@@@std@@QAE@ABV01@@Z db 0FFh
.xdata$x:00009E08                                         ; DATA XREF: .xdata$x:00009E18o
.xdata$x:00009E09                 db 0FFh
.xdata$x:00009E0A                 db 0FFh
.xdata$x:00009E0B                 db 0FFh
.xdata$x:00009E0C                 dd offset __unwindfunclet$??0?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@UFunctionValues@@@std@@@std@@@std@@QAE@ABV01@@Z$0
.xdata$x:00009E10 __ehfuncinfo$??0?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@UFunctionValues@@@std@@@std@@@std@@QAE@ABV01@@Z db  22h ; "
.xdata$x:00009E10                                         ; DATA XREF: __ehhandler$??0?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@UFunctionValues@@@std@@@std@@@std@@QAE@ABV01@@Z+11o
.xdata$x:00009E11                 db    5
.xdata$x:00009E12                 db  93h ; ô
.xdata$x:00009E13                 db  19h
.xdata$x:00009E14                 db    1
.xdata$x:00009E15                 db    0
.xdata$x:00009E16                 db    0
.xdata$x:00009E17                 db    0
.xdata$x:00009E18                 dd offset __unwindtable$??0?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@UFunctionValues@@@std@@@std@@@std@@QAE@ABV01@@Z
.xdata$x:00009E1C                 db    0
.xdata$x:00009E1D                 db    0
.xdata$x:00009E1E                 db    0
.xdata$x:00009E1F                 db    0
.xdata$x:00009E20                 db    0
.xdata$x:00009E21                 db    0
.xdata$x:00009E22                 db    0
.xdata$x:00009E23                 db    0
.xdata$x:00009E24                 db    0
.xdata$x:00009E25                 db    0
.xdata$x:00009E26                 db    0
.xdata$x:00009E27                 db    0
.xdata$x:00009E28                 db    0
.xdata$x:00009E29                 db    0
.xdata$x:00009E2A                 db    0
.xdata$x:00009E2B                 db    0
.xdata$x:00009E2C                 db    0
.xdata$x:00009E2D                 db    0
.xdata$x:00009E2E                 db    0
.xdata$x:00009E2F                 db    0
.xdata$x:00009E30                 db    0
.xdata$x:00009E31                 db    0
.xdata$x:00009E32                 db    0
.xdata$x:00009E33                 db    0
.xdata$x:00009E33 _xdata$x        ends
.xdata$x:00009E33
.xdata$x:00009E34 ; ===========================================================================
.xdata$x:00009E34
.xdata$x:00009E34 ; Segment type: Pure data
.xdata$x:00009E34 ; Segment permissions: Read
.xdata$x:00009E34 _xdata$x        segment dword public 'DATA' use32
.xdata$x:00009E34                 assume cs:_xdata$x
.xdata$x:00009E34                 ;org 9E34h
.xdata$x:00009E34 ; COMDAT (pick associative to section at 44B4)
.xdata$x:00009E34 __unwindtable$??0?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@UFunctionValues@@@std@@@std@@@std@@QAE@PAUFunctionValues@@PBU_Container_base12@1@@Z db 0FFh
.xdata$x:00009E34                                         ; DATA XREF: .xdata$x:00009E44o
.xdata$x:00009E35                 db 0FFh
.xdata$x:00009E36                 db 0FFh
.xdata$x:00009E37                 db 0FFh
.xdata$x:00009E38                 dd offset __unwindfunclet$??0?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@UFunctionValues@@@std@@@std@@@std@@QAE@PAUFunctionValues@@PBU_Container_base12@1@@Z$0
.xdata$x:00009E3C __ehfuncinfo$??0?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@UFunctionValues@@@std@@@std@@@std@@QAE@PAUFunctionValues@@PBU_Container_base12@1@@Z db  22h ; "
.xdata$x:00009E3C                                         ; DATA XREF: __ehhandler$??0?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@UFunctionValues@@@std@@@std@@@std@@QAE@PAUFunctionValues@@PBU_Container_base12@1@@Z+11o
.xdata$x:00009E3D                 db    5
.xdata$x:00009E3E                 db  93h ; ô
.xdata$x:00009E3F                 db  19h
.xdata$x:00009E40                 db    1
.xdata$x:00009E41                 db    0
.xdata$x:00009E42                 db    0
.xdata$x:00009E43                 db    0
.xdata$x:00009E44                 dd offset __unwindtable$??0?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@UFunctionValues@@@std@@@std@@@std@@QAE@PAUFunctionValues@@PBU_Container_base12@1@@Z
.xdata$x:00009E48                 align 20h
.xdata$x:00009E48 _xdata$x        ends
.xdata$x:00009E48
.xdata$x:00009E60 ; ===========================================================================
.xdata$x:00009E60
.xdata$x:00009E60 ; Segment type: Pure data
.xdata$x:00009E60 ; Segment permissions: Read
.xdata$x:00009E60 _xdata$x        segment dword public 'DATA' use32
.xdata$x:00009E60                 assume cs:_xdata$x
.xdata$x:00009E60                 ;org 9E60h
.xdata$x:00009E60 ; COMDAT (pick associative to section at 5A88)
.xdata$x:00009E60 __unwindtable$??G?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@UFunctionValues@@@std@@@std@@@std@@QBE?AV01@H@Z db 0FFh
.xdata$x:00009E60                                         ; DATA XREF: .xdata$x:00009E78o
.xdata$x:00009E61                 db 0FFh
.xdata$x:00009E62                 db 0FFh
.xdata$x:00009E63                 db 0FFh
.xdata$x:00009E64                 dd offset __unwindfunclet$??G?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@UFunctionValues@@@std@@@std@@@std@@QBE?AV01@H@Z$1
.xdata$x:00009E68                 db    0
.xdata$x:00009E69                 db    0
.xdata$x:00009E6A                 db    0
.xdata$x:00009E6B                 db    0
.xdata$x:00009E6C                 dd offset __unwindfunclet$??G?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@UFunctionValues@@@std@@@std@@@std@@QBE?AV01@H@Z$0
.xdata$x:00009E70 __ehfuncinfo$??G?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@UFunctionValues@@@std@@@std@@@std@@QBE?AV01@H@Z db  22h ; "
.xdata$x:00009E70                                         ; DATA XREF: __ehhandler$??G?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@UFunctionValues@@@std@@@std@@@std@@QBE?AV01@H@Z+11o
.xdata$x:00009E71                 db    5
.xdata$x:00009E72                 db  93h ; ô
.xdata$x:00009E73                 db  19h
.xdata$x:00009E74                 db    2
.xdata$x:00009E75                 db    0
.xdata$x:00009E76                 db    0
.xdata$x:00009E77                 db    0
.xdata$x:00009E78                 dd offset __unwindtable$??G?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@UFunctionValues@@@std@@@std@@@std@@QBE?AV01@H@Z
.xdata$x:00009E7C                 db    0
.xdata$x:00009E7D                 db    0
.xdata$x:00009E7E                 db    0
.xdata$x:00009E7F                 db    0
.xdata$x:00009E80                 db    0
.xdata$x:00009E81                 db    0
.xdata$x:00009E82                 db    0
.xdata$x:00009E83                 db    0
.xdata$x:00009E84                 db    0
.xdata$x:00009E85                 db    0
.xdata$x:00009E86                 db    0
.xdata$x:00009E87                 db    0
.xdata$x:00009E88                 db    0
.xdata$x:00009E89                 db    0
.xdata$x:00009E8A                 db    0
.xdata$x:00009E8B                 db    0
.xdata$x:00009E8C                 db    0
.xdata$x:00009E8D                 db    0
.xdata$x:00009E8E                 db    0
.xdata$x:00009E8F                 db    0
.xdata$x:00009E90                 db    0
.xdata$x:00009E91                 db    0
.xdata$x:00009E92                 db    0
.xdata$x:00009E93                 db    0
.xdata$x:00009E93 _xdata$x        ends
.xdata$x:00009E93
.xdata$x:00009E94 ; ===========================================================================
.xdata$x:00009E94
.xdata$x:00009E94 ; Segment type: Pure data
.xdata$x:00009E94 ; Segment permissions: Read
.xdata$x:00009E94 _xdata$x        segment dword public 'DATA' use32
.xdata$x:00009E94                 assume cs:_xdata$x
.xdata$x:00009E94                 ;org 9E94h
.xdata$x:00009E94 ; COMDAT (pick associative to section at 52E0)
.xdata$x:00009E94 __unwindtable$??1?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@UFunctionValues@@@std@@@std@@@std@@QAE@XZ db 0FFh
.xdata$x:00009E94                                         ; DATA XREF: .xdata$x:00009EA4o
.xdata$x:00009E95                 db 0FFh
.xdata$x:00009E96                 db 0FFh
.xdata$x:00009E97                 db 0FFh
.xdata$x:00009E98                 dd offset __unwindfunclet$??1?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@UFunctionValues@@@std@@@std@@@std@@QAE@XZ$0
.xdata$x:00009E9C __ehfuncinfo$??1?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@UFunctionValues@@@std@@@std@@@std@@QAE@XZ db  22h ; "
.xdata$x:00009E9C                                         ; DATA XREF: __ehhandler$??1?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@UFunctionValues@@@std@@@std@@@std@@QAE@XZ+11o
.xdata$x:00009E9D                 db    5
.xdata$x:00009E9E                 db  93h ; ô
.xdata$x:00009E9F                 db  19h
.xdata$x:00009EA0                 db    1
.xdata$x:00009EA1                 db    0
.xdata$x:00009EA2                 db    0
.xdata$x:00009EA3                 db    0
.xdata$x:00009EA4                 dd offset __unwindtable$??1?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@UFunctionValues@@@std@@@std@@@std@@QAE@XZ
.xdata$x:00009EA8                 align 20h
.xdata$x:00009EA8 _xdata$x        ends
.xdata$x:00009EA8
.xdata$x:00009EC0 ; ===========================================================================
.xdata$x:00009EC0
.xdata$x:00009EC0 ; Segment type: Pure data
.xdata$x:00009EC0 ; Segment permissions: Read
.xdata$x:00009EC0 _xdata$x        segment dword public 'DATA' use32
.xdata$x:00009EC0                 assume cs:_xdata$x
.xdata$x:00009EC0                 ;org 9EC0h
.xdata$x:00009EC0 ; COMDAT (pick associative to section at 443C)
.xdata$x:00009EC0 __unwindtable$??0?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@UFunctionValues@@@std@@@std@@@std@@QAE@ABV01@@Z db 0FFh
.xdata$x:00009EC0                                         ; DATA XREF: .xdata$x:00009ED0o
.xdata$x:00009EC1                 db 0FFh
.xdata$x:00009EC2                 db 0FFh
.xdata$x:00009EC3                 db 0FFh
.xdata$x:00009EC4                 dd offset __unwindfunclet$??0?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@UFunctionValues@@@std@@@std@@@std@@QAE@ABV01@@Z$0
.xdata$x:00009EC8 __ehfuncinfo$??0?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@UFunctionValues@@@std@@@std@@@std@@QAE@ABV01@@Z db  22h ; "
.xdata$x:00009EC8                                         ; DATA XREF: __ehhandler$??0?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@UFunctionValues@@@std@@@std@@@std@@QAE@ABV01@@Z+11o
.xdata$x:00009EC9                 db    5
.xdata$x:00009ECA                 db  93h ; ô
.xdata$x:00009ECB                 db  19h
.xdata$x:00009ECC                 db    1
.xdata$x:00009ECD                 db    0
.xdata$x:00009ECE                 db    0
.xdata$x:00009ECF                 db    0
.xdata$x:00009ED0                 dd offset __unwindtable$??0?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@UFunctionValues@@@std@@@std@@@std@@QAE@ABV01@@Z
.xdata$x:00009ED4                 db    0
.xdata$x:00009ED5                 db    0
.xdata$x:00009ED6                 db    0
.xdata$x:00009ED7                 db    0
.xdata$x:00009ED8                 db    0
.xdata$x:00009ED9                 db    0
.xdata$x:00009EDA                 db    0
.xdata$x:00009EDB                 db    0
.xdata$x:00009EDC                 db    0
.xdata$x:00009EDD                 db    0
.xdata$x:00009EDE                 db    0
.xdata$x:00009EDF                 db    0
.xdata$x:00009EE0                 db    0
.xdata$x:00009EE1                 db    0
.xdata$x:00009EE2                 db    0
.xdata$x:00009EE3                 db    0
.xdata$x:00009EE4                 db    0
.xdata$x:00009EE5                 db    0
.xdata$x:00009EE6                 db    0
.xdata$x:00009EE7                 db    0
.xdata$x:00009EE8                 db    0
.xdata$x:00009EE9                 db    0
.xdata$x:00009EEA                 db    0
.xdata$x:00009EEB                 db    0
.xdata$x:00009EEB _xdata$x        ends
.xdata$x:00009EEB
.xdata$x:00009EEC ; ===========================================================================
.xdata$x:00009EEC
.xdata$x:00009EEC ; Segment type: Pure data
.xdata$x:00009EEC ; Segment permissions: Read
.xdata$x:00009EEC _xdata$x        segment dword public 'DATA' use32
.xdata$x:00009EEC                 assume cs:_xdata$x
.xdata$x:00009EEC                 ;org 9EECh
.xdata$x:00009EEC ; COMDAT (pick associative to section at 3E44)
.xdata$x:00009EEC __unwindtable$??0?$_Iterator012@Urandom_access_iterator_tag@std@@PB_WHPBQB_WABQB_WU_Iterator_base12@2@@std@@QAE@XZ db 0FFh
.xdata$x:00009EEC                                         ; DATA XREF: .xdata$x:00009EFCo
.xdata$x:00009EED                 db 0FFh
.xdata$x:00009EEE                 db 0FFh
.xdata$x:00009EEF                 db 0FFh
.xdata$x:00009EF0                 dd offset __unwindfunclet$??0?$_Iterator012@Urandom_access_iterator_tag@std@@PB_WHPBQB_WABQB_WU_Iterator_base12@2@@std@@QAE@XZ$0
.xdata$x:00009EF4 __ehfuncinfo$??0?$_Iterator012@Urandom_access_iterator_tag@std@@PB_WHPBQB_WABQB_WU_Iterator_base12@2@@std@@QAE@XZ db  22h ; "
.xdata$x:00009EF4                                         ; DATA XREF: __ehhandler$??0?$_Iterator012@Urandom_access_iterator_tag@std@@PB_WHPBQB_WABQB_WU_Iterator_base12@2@@std@@QAE@XZ+11o
.xdata$x:00009EF5                 db    5
.xdata$x:00009EF6                 db  93h ; ô
.xdata$x:00009EF7                 db  19h
.xdata$x:00009EF8                 db    1
.xdata$x:00009EF9                 db    0
.xdata$x:00009EFA                 db    0
.xdata$x:00009EFB                 db    0
.xdata$x:00009EFC                 dd offset __unwindtable$??0?$_Iterator012@Urandom_access_iterator_tag@std@@PB_WHPBQB_WABQB_WU_Iterator_base12@2@@std@@QAE@XZ
.xdata$x:00009F00                 db    0
.xdata$x:00009F01                 db    0
.xdata$x:00009F02                 db    0
.xdata$x:00009F03                 db    0
.xdata$x:00009F04                 db    0
.xdata$x:00009F05                 db    0
.xdata$x:00009F06                 db    0
.xdata$x:00009F07                 db    0
.xdata$x:00009F08                 db    0
.xdata$x:00009F09                 db    0
.xdata$x:00009F0A                 db    0
.xdata$x:00009F0B                 db    0
.xdata$x:00009F0C                 db    0
.xdata$x:00009F0D                 db    0
.xdata$x:00009F0E                 db    0
.xdata$x:00009F0F                 db    0
.xdata$x:00009F10                 db    0
.xdata$x:00009F11                 db    0
.xdata$x:00009F12                 db    0
.xdata$x:00009F13                 db    0
.xdata$x:00009F14                 db    0
.xdata$x:00009F15                 db    0
.xdata$x:00009F16                 db    0
.xdata$x:00009F17                 db    0
.xdata$x:00009F17 _xdata$x        ends
.xdata$x:00009F17
.xdata$x:00009F18 ; ===========================================================================
.xdata$x:00009F18
.xdata$x:00009F18 ; Segment type: Pure data
.xdata$x:00009F18 ; Segment permissions: Read
.xdata$x:00009F18 _xdata$x        segment dword public 'DATA' use32
.xdata$x:00009F18                 assume cs:_xdata$x
.xdata$x:00009F18                 ;org 9F18h
.xdata$x:00009F18 ; COMDAT (pick associative to section at 4ED0)
.xdata$x:00009F18 __unwindtable$??1?$_Iterator012@Urandom_access_iterator_tag@std@@PB_WHPBQB_WABQB_WU_Iterator_base12@2@@std@@QAE@XZ db 0FFh
.xdata$x:00009F18                                         ; DATA XREF: .xdata$x:00009F28o
.xdata$x:00009F19                 db 0FFh
.xdata$x:00009F1A                 db 0FFh
.xdata$x:00009F1B                 db 0FFh
.xdata$x:00009F1C                 dd offset __unwindfunclet$??1?$_Iterator012@Urandom_access_iterator_tag@std@@PB_WHPBQB_WABQB_WU_Iterator_base12@2@@std@@QAE@XZ$0
.xdata$x:00009F20 __ehfuncinfo$??1?$_Iterator012@Urandom_access_iterator_tag@std@@PB_WHPBQB_WABQB_WU_Iterator_base12@2@@std@@QAE@XZ db  22h ; "
.xdata$x:00009F20                                         ; DATA XREF: __ehhandler$??1?$_Iterator012@Urandom_access_iterator_tag@std@@PB_WHPBQB_WABQB_WU_Iterator_base12@2@@std@@QAE@XZ+11o
.xdata$x:00009F21                 db    5
.xdata$x:00009F22                 db  93h ; ô
.xdata$x:00009F23                 db  19h
.xdata$x:00009F24                 db    1
.xdata$x:00009F25                 db    0
.xdata$x:00009F26                 db    0
.xdata$x:00009F27                 db    0
.xdata$x:00009F28                 dd offset __unwindtable$??1?$_Iterator012@Urandom_access_iterator_tag@std@@PB_WHPBQB_WABQB_WU_Iterator_base12@2@@std@@QAE@XZ
.xdata$x:00009F2C                 db    0
.xdata$x:00009F2D                 db    0
.xdata$x:00009F2E                 db    0
.xdata$x:00009F2F                 db    0
.xdata$x:00009F30                 db    0
.xdata$x:00009F31                 db    0
.xdata$x:00009F32                 db    0
.xdata$x:00009F33                 db    0
.xdata$x:00009F34                 db    0
.xdata$x:00009F35                 db    0
.xdata$x:00009F36                 db    0
.xdata$x:00009F37                 db    0
.xdata$x:00009F38                 db    0
.xdata$x:00009F39                 db    0
.xdata$x:00009F3A                 db    0
.xdata$x:00009F3B                 db    0
.xdata$x:00009F3C                 db    0
.xdata$x:00009F3D                 db    0
.xdata$x:00009F3E                 db    0
.xdata$x:00009F3F                 db    0
.xdata$x:00009F40                 db    0
.xdata$x:00009F41                 db    0
.xdata$x:00009F42                 db    0
.xdata$x:00009F43                 db    0
.xdata$x:00009F43 _xdata$x        ends
.xdata$x:00009F43
.xdata$x:00009F44 ; ===========================================================================
.xdata$x:00009F44
.xdata$x:00009F44 ; Segment type: Pure data
.xdata$x:00009F44 ; Segment permissions: Read
.xdata$x:00009F44 _xdata$x        segment dword public 'DATA' use32
.xdata$x:00009F44                 assume cs:_xdata$x
.xdata$x:00009F44                 ;org 9F44h
.xdata$x:00009F44 ; COMDAT (pick associative to section at 3DCC)
.xdata$x:00009F44 __unwindtable$??0?$_Iterator012@Urandom_access_iterator_tag@std@@PB_WHPBQB_WABQB_WU_Iterator_base12@2@@std@@QAE@ABU01@@Z db 0FFh
.xdata$x:00009F44                                         ; DATA XREF: .xdata$x:00009F54o
.xdata$x:00009F45                 db 0FFh
.xdata$x:00009F46                 db 0FFh
.xdata$x:00009F47                 db 0FFh
.xdata$x:00009F48                 dd offset __unwindfunclet$??0?$_Iterator012@Urandom_access_iterator_tag@std@@PB_WHPBQB_WABQB_WU_Iterator_base12@2@@std@@QAE@ABU01@@Z$0
.xdata$x:00009F4C __ehfuncinfo$??0?$_Iterator012@Urandom_access_iterator_tag@std@@PB_WHPBQB_WABQB_WU_Iterator_base12@2@@std@@QAE@ABU01@@Z db  22h ; "
.xdata$x:00009F4C                                         ; DATA XREF: __ehhandler$??0?$_Iterator012@Urandom_access_iterator_tag@std@@PB_WHPBQB_WABQB_WU_Iterator_base12@2@@std@@QAE@ABU01@@Z+11o
.xdata$x:00009F4D                 db    5
.xdata$x:00009F4E                 db  93h ; ô
.xdata$x:00009F4F                 db  19h
.xdata$x:00009F50                 db    1
.xdata$x:00009F51                 db    0
.xdata$x:00009F52                 db    0
.xdata$x:00009F53                 db    0
.xdata$x:00009F54                 dd offset __unwindtable$??0?$_Iterator012@Urandom_access_iterator_tag@std@@PB_WHPBQB_WABQB_WU_Iterator_base12@2@@std@@QAE@ABU01@@Z
.xdata$x:00009F58                 db    0
.xdata$x:00009F59                 db    0
.xdata$x:00009F5A                 db    0
.xdata$x:00009F5B                 db    0
.xdata$x:00009F5C                 db    0
.xdata$x:00009F5D                 db    0
.xdata$x:00009F5E                 db    0
.xdata$x:00009F5F                 db    0
.xdata$x:00009F60                 db    0
.xdata$x:00009F61                 db    0
.xdata$x:00009F62                 db    0
.xdata$x:00009F63                 db    0
.xdata$x:00009F64                 db    0
.xdata$x:00009F65                 db    0
.xdata$x:00009F66                 db    0
.xdata$x:00009F67                 db    0
.xdata$x:00009F68                 db    0
.xdata$x:00009F69                 db    0
.xdata$x:00009F6A                 db    0
.xdata$x:00009F6B                 db    0
.xdata$x:00009F6C                 db    0
.xdata$x:00009F6D                 db    0
.xdata$x:00009F6E                 db    0
.xdata$x:00009F6F                 db    0
.xdata$x:00009F6F _xdata$x        ends
.xdata$x:00009F6F
.xdata$x:00009F70 ; ===========================================================================
.xdata$x:00009F70
.xdata$x:00009F70 ; Segment type: Pure data
.xdata$x:00009F70 ; Segment permissions: Read
.xdata$x:00009F70 _xdata$x        segment dword public 'DATA' use32
.xdata$x:00009F70                 assume cs:_xdata$x
.xdata$x:00009F70                 ;org 9F70h
.xdata$x:00009F70 ; COMDAT (pick associative to section at 42A0)
.xdata$x:00009F70 __unwindtable$??0?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@PB_W@std@@@std@@@std@@QAE@PAPB_WPBU_Container_base12@1@@Z db 0FFh
.xdata$x:00009F70                                         ; DATA XREF: .xdata$x:00009F80o
.xdata$x:00009F71                 db 0FFh
.xdata$x:00009F72                 db 0FFh
.xdata$x:00009F73                 db 0FFh
.xdata$x:00009F74                 dd offset __unwindfunclet$??0?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@PB_W@std@@@std@@@std@@QAE@PAPB_WPBU_Container_base12@1@@Z$0
.xdata$x:00009F78 __ehfuncinfo$??0?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@PB_W@std@@@std@@@std@@QAE@PAPB_WPBU_Container_base12@1@@Z db  22h ; "
.xdata$x:00009F78                                         ; DATA XREF: __ehhandler$??0?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@PB_W@std@@@std@@@std@@QAE@PAPB_WPBU_Container_base12@1@@Z+11o
.xdata$x:00009F79                 db    5
.xdata$x:00009F7A                 db  93h ; ô
.xdata$x:00009F7B                 db  19h
.xdata$x:00009F7C                 db    1
.xdata$x:00009F7D                 db    0
.xdata$x:00009F7E                 db    0
.xdata$x:00009F7F                 db    0
.xdata$x:00009F80                 dd offset __unwindtable$??0?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@PB_W@std@@@std@@@std@@QAE@PAPB_WPBU_Container_base12@1@@Z
.xdata$x:00009F84                 db    0
.xdata$x:00009F85                 db    0
.xdata$x:00009F86                 db    0
.xdata$x:00009F87                 db    0
.xdata$x:00009F88                 db    0
.xdata$x:00009F89                 db    0
.xdata$x:00009F8A                 db    0
.xdata$x:00009F8B                 db    0
.xdata$x:00009F8C                 db    0
.xdata$x:00009F8D                 db    0
.xdata$x:00009F8E                 db    0
.xdata$x:00009F8F                 db    0
.xdata$x:00009F90                 db    0
.xdata$x:00009F91                 db    0
.xdata$x:00009F92                 db    0
.xdata$x:00009F93                 db    0
.xdata$x:00009F94                 db    0
.xdata$x:00009F95                 db    0
.xdata$x:00009F96                 db    0
.xdata$x:00009F97                 db    0
.xdata$x:00009F98                 db    0
.xdata$x:00009F99                 db    0
.xdata$x:00009F9A                 db    0
.xdata$x:00009F9B                 db    0
.xdata$x:00009F9B _xdata$x        ends
.xdata$x:00009F9B
.xdata$x:00009F9C ; ===========================================================================
.xdata$x:00009F9C
.xdata$x:00009F9C ; Segment type: Pure data
.xdata$x:00009F9C ; Segment permissions: Read
.xdata$x:00009F9C _xdata$x        segment dword public 'DATA' use32
.xdata$x:00009F9C                 assume cs:_xdata$x
.xdata$x:00009F9C                 ;org 9F9Ch
.xdata$x:00009F9C ; COMDAT (pick associative to section at 5200)
.xdata$x:00009F9C __unwindtable$??1?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@PB_W@std@@@std@@@std@@QAE@XZ db 0FFh
.xdata$x:00009F9C                                         ; DATA XREF: .xdata$x:00009FACo
.xdata$x:00009F9D                 db 0FFh
.xdata$x:00009F9E                 db 0FFh
.xdata$x:00009F9F                 db 0FFh
.xdata$x:00009FA0                 dd offset __unwindfunclet$??1?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@PB_W@std@@@std@@@std@@QAE@XZ$0
.xdata$x:00009FA4 __ehfuncinfo$??1?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@PB_W@std@@@std@@@std@@QAE@XZ db  22h ; "
.xdata$x:00009FA4                                         ; DATA XREF: __ehhandler$??1?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@PB_W@std@@@std@@@std@@QAE@XZ+11o
.xdata$x:00009FA5                 db    5
.xdata$x:00009FA6                 db  93h ; ô
.xdata$x:00009FA7                 db  19h
.xdata$x:00009FA8                 db    1
.xdata$x:00009FA9                 db    0
.xdata$x:00009FAA                 db    0
.xdata$x:00009FAB                 db    0
.xdata$x:00009FAC                 dd offset __unwindtable$??1?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@PB_W@std@@@std@@@std@@QAE@XZ
.xdata$x:00009FB0                 db    0
.xdata$x:00009FB1                 db    0
.xdata$x:00009FB2                 db    0
.xdata$x:00009FB3                 db    0
.xdata$x:00009FB4                 db    0
.xdata$x:00009FB5                 db    0
.xdata$x:00009FB6                 db    0
.xdata$x:00009FB7                 db    0
.xdata$x:00009FB8                 db    0
.xdata$x:00009FB9                 db    0
.xdata$x:00009FBA                 db    0
.xdata$x:00009FBB                 db    0
.xdata$x:00009FBC                 db    0
.xdata$x:00009FBD                 db    0
.xdata$x:00009FBE                 db    0
.xdata$x:00009FBF                 db    0
.xdata$x:00009FC0                 db    0
.xdata$x:00009FC1                 db    0
.xdata$x:00009FC2                 db    0
.xdata$x:00009FC3                 db    0
.xdata$x:00009FC4                 db    0
.xdata$x:00009FC5                 db    0
.xdata$x:00009FC6                 db    0
.xdata$x:00009FC7                 db    0
.xdata$x:00009FC7 _xdata$x        ends
.xdata$x:00009FC7
.xdata$x:00009FC8 ; ===========================================================================
.xdata$x:00009FC8
.xdata$x:00009FC8 ; Segment type: Pure data
.xdata$x:00009FC8 ; Segment permissions: Read
.xdata$x:00009FC8 _xdata$x        segment dword public 'DATA' use32
.xdata$x:00009FC8                 assume cs:_xdata$x
.xdata$x:00009FC8                 ;org 9FC8h
.xdata$x:00009FC8 ; COMDAT (pick associative to section at 421C)
.xdata$x:00009FC8 __unwindtable$??0?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@PB_W@std@@@std@@@std@@QAE@ABV01@@Z db 0FFh
.xdata$x:00009FC8                                         ; DATA XREF: .xdata$x:00009FD8o
.xdata$x:00009FC9                 db 0FFh
.xdata$x:00009FCA                 db 0FFh
.xdata$x:00009FCB                 db 0FFh
.xdata$x:00009FCC                 dd offset __unwindfunclet$??0?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@PB_W@std@@@std@@@std@@QAE@ABV01@@Z$0
.xdata$x:00009FD0 __ehfuncinfo$??0?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@PB_W@std@@@std@@@std@@QAE@ABV01@@Z db  22h ; "
.xdata$x:00009FD0                                         ; DATA XREF: __ehhandler$??0?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@PB_W@std@@@std@@@std@@QAE@ABV01@@Z+11o
.xdata$x:00009FD1                 db    5
.xdata$x:00009FD2                 db  93h ; ô
.xdata$x:00009FD3                 db  19h
.xdata$x:00009FD4                 db    1
.xdata$x:00009FD5                 db    0
.xdata$x:00009FD6                 db    0
.xdata$x:00009FD7                 db    0
.xdata$x:00009FD8                 dd offset __unwindtable$??0?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@PB_W@std@@@std@@@std@@QAE@ABV01@@Z
.xdata$x:00009FDC                 db    0
.xdata$x:00009FDD                 db    0
.xdata$x:00009FDE                 db    0
.xdata$x:00009FDF                 db    0
.xdata$x:00009FE0                 db    0
.xdata$x:00009FE1                 db    0
.xdata$x:00009FE2                 db    0
.xdata$x:00009FE3                 db    0
.xdata$x:00009FE4                 db    0
.xdata$x:00009FE5                 db    0
.xdata$x:00009FE6                 db    0
.xdata$x:00009FE7                 db    0
.xdata$x:00009FE8                 db    0
.xdata$x:00009FE9                 db    0
.xdata$x:00009FEA                 db    0
.xdata$x:00009FEB                 db    0
.xdata$x:00009FEC                 db    0
.xdata$x:00009FED                 db    0
.xdata$x:00009FEE                 db    0
.xdata$x:00009FEF                 db    0
.xdata$x:00009FF0                 db    0
.xdata$x:00009FF1                 db    0
.xdata$x:00009FF2                 db    0
.xdata$x:00009FF3                 db    0
.xdata$x:00009FF3 _xdata$x        ends
.xdata$x:00009FF3
.xdata$x:00009FF4 ; ===========================================================================
.xdata$x:00009FF4
.xdata$x:00009FF4 ; Segment type: Pure data
.xdata$x:00009FF4 ; Segment permissions: Read
.xdata$x:00009FF4 _xdata$x        segment dword public 'DATA' use32
.xdata$x:00009FF4                 assume cs:_xdata$x
.xdata$x:00009FF4                 ;org 9FF4h
.xdata$x:00009FF4 ; COMDAT (pick associative to section at 38F4)
.xdata$x:00009FF4 __unwindtable$??$construct@U_Container_proxy@std@@U12@@?$allocator@U_Container_proxy@std@@@std@@QAEXPAU_Container_proxy@1@$$QAU21@@Z db 0FFh
.xdata$x:00009FF4                                         ; DATA XREF: .xdata$x:0000A004o
.xdata$x:00009FF5                 db 0FFh
.xdata$x:00009FF6                 db 0FFh
.xdata$x:00009FF7                 db 0FFh
.xdata$x:00009FF8                 dd offset __unwindfunclet$??$construct@U_Container_proxy@std@@U12@@?$allocator@U_Container_proxy@std@@@std@@QAEXPAU_Container_proxy@1@$$QAU21@@Z$0
.xdata$x:00009FFC __ehfuncinfo$??$construct@U_Container_proxy@std@@U12@@?$allocator@U_Container_proxy@std@@@std@@QAEXPAU_Container_proxy@1@$$QAU21@@Z db  22h ; "
.xdata$x:00009FFC                                         ; DATA XREF: __ehhandler$??$construct@U_Container_proxy@std@@U12@@?$allocator@U_Container_proxy@std@@@std@@QAEXPAU_Container_proxy@1@$$QAU21@@Z+11o
.xdata$x:00009FFD                 db    5
.xdata$x:00009FFE                 db  93h ; ô
.xdata$x:00009FFF                 db  19h
.xdata$x:0000A000                 db    1
.xdata$x:0000A001                 db    0
.xdata$x:0000A002                 db    0
.xdata$x:0000A003                 db    0
.xdata$x:0000A004                 dd offset __unwindtable$??$construct@U_Container_proxy@std@@U12@@?$allocator@U_Container_proxy@std@@@std@@QAEXPAU_Container_proxy@1@$$QAU21@@Z
.xdata$x:0000A008                 align 20h
.xdata$x:0000A008 _xdata$x        ends
.xdata$x:0000A008
.xdata$x:0000A020 ; ===========================================================================
.xdata$x:0000A020
.xdata$x:0000A020 ; Segment type: Pure data
.xdata$x:0000A020 ; Segment permissions: Read
.xdata$x:0000A020 _xdata$x        segment dword public 'DATA' use32
.xdata$x:0000A020                 assume cs:_xdata$x
.xdata$x:0000A020                 ;org 0A020h
.xdata$x:0000A020 ; COMDAT (pick associative to section at 3430)
.xdata$x:0000A020 __unwindtable$??$construct@PB_WAAPB_W@?$allocator@PB_W@std@@QAEXPAPB_WAAPB_W@Z db 0FFh
.xdata$x:0000A020                                         ; DATA XREF: .xdata$x:0000A030o
.xdata$x:0000A021                 db 0FFh
.xdata$x:0000A022                 db 0FFh
.xdata$x:0000A023                 db 0FFh
.xdata$x:0000A024                 dd offset __unwindfunclet$??$construct@PB_WAAPB_W@?$allocator@PB_W@std@@QAEXPAPB_WAAPB_W@Z$0
.xdata$x:0000A028 __ehfuncinfo$??$construct@PB_WAAPB_W@?$allocator@PB_W@std@@QAEXPAPB_WAAPB_W@Z db  22h ; "
.xdata$x:0000A028                                         ; DATA XREF: __ehhandler$??$construct@PB_WAAPB_W@?$allocator@PB_W@std@@QAEXPAPB_WAAPB_W@Z+11o
.xdata$x:0000A029                 db    5
.xdata$x:0000A02A                 db  93h ; ô
.xdata$x:0000A02B                 db  19h
.xdata$x:0000A02C                 db    1
.xdata$x:0000A02D                 db    0
.xdata$x:0000A02E                 db    0
.xdata$x:0000A02F                 db    0
.xdata$x:0000A030                 dd offset __unwindtable$??$construct@PB_WAAPB_W@?$allocator@PB_W@std@@QAEXPAPB_WAAPB_W@Z
.xdata$x:0000A034                 db    0
.xdata$x:0000A035                 db    0
.xdata$x:0000A036                 db    0
.xdata$x:0000A037                 db    0
.xdata$x:0000A038                 db    0
.xdata$x:0000A039                 db    0
.xdata$x:0000A03A                 db    0
.xdata$x:0000A03B                 db    0
.xdata$x:0000A03C                 db    0
.xdata$x:0000A03D                 db    0
.xdata$x:0000A03E                 db    0
.xdata$x:0000A03F                 db    0
.xdata$x:0000A040                 db    0
.xdata$x:0000A041                 db    0
.xdata$x:0000A042                 db    0
.xdata$x:0000A043                 db    0
.xdata$x:0000A044                 db    0
.xdata$x:0000A045                 db    0
.xdata$x:0000A046                 db    0
.xdata$x:0000A047                 db    0
.xdata$x:0000A048                 db    0
.xdata$x:0000A049                 db    0
.xdata$x:0000A04A                 db    0
.xdata$x:0000A04B                 db    0
.xdata$x:0000A04B _xdata$x        ends
.xdata$x:0000A04B
.xdata$x:0000A04C ; ===========================================================================
.xdata$x:0000A04C
.xdata$x:0000A04C ; Segment type: Pure data
.xdata$x:0000A04C ; Segment permissions: Read
.xdata$x:0000A04C _xdata$x        segment dword public 'DATA' use32
.xdata$x:0000A04C                 assume cs:_xdata$x
.xdata$x:0000A04C                 ;org 0A04Ch
.xdata$x:0000A04C ; COMDAT (pick associative to section at 39F8)
.xdata$x:0000A04C __unwindtable$??$construct@V?$vector@PB_WV?$allocator@PB_W@std@@@std@@AAV12@@?$allocator@V?$vector@PB_WV?$allocator@PB_W@std@@@std@@@std@@QAEXPAV?$vector@PB_WV?$allocator@PB_W@std@@@1@AAV21@@Z db 0FFh
.xdata$x:0000A04C                                         ; DATA XREF: .xdata$x:0000A05Co
.xdata$x:0000A04D                 db 0FFh
.xdata$x:0000A04E                 db 0FFh
.xdata$x:0000A04F                 db 0FFh
.xdata$x:0000A050                 dd offset __unwindfunclet$??$construct@V?$vector@PB_WV?$allocator@PB_W@std@@@std@@AAV12@@?$allocator@V?$vector@PB_WV?$allocator@PB_W@std@@@std@@@std@@QAEXPAV?$vector@PB_WV?$allocator@PB_W@std@@@1@AAV21@@Z$0
.xdata$x:0000A054 __ehfuncinfo$??$construct@V?$vector@PB_WV?$allocator@PB_W@std@@@std@@AAV12@@?$allocator@V?$vector@PB_WV?$allocator@PB_W@std@@@std@@@std@@QAEXPAV?$vector@PB_WV?$allocator@PB_W@std@@@1@AAV21@@Z db  22h ; "
.xdata$x:0000A054                                         ; DATA XREF: __ehhandler$??$construct@V?$vector@PB_WV?$allocator@PB_W@std@@@std@@AAV12@@?$allocator@V?$vector@PB_WV?$allocator@PB_W@std@@@std@@@std@@QAEXPAV?$vector@PB_WV?$allocator@PB_W@std@@@1@AAV21@@Z+11o
.xdata$x:0000A055                 db    5
.xdata$x:0000A056                 db  93h ; ô
.xdata$x:0000A057                 db  19h
.xdata$x:0000A058                 db    1
.xdata$x:0000A059                 db    0
.xdata$x:0000A05A                 db    0
.xdata$x:0000A05B                 db    0
.xdata$x:0000A05C                 dd offset __unwindtable$??$construct@V?$vector@PB_WV?$allocator@PB_W@std@@@std@@AAV12@@?$allocator@V?$vector@PB_WV?$allocator@PB_W@std@@@std@@@std@@QAEXPAV?$vector@PB_WV?$allocator@PB_W@std@@@1@AAV21@@Z
.xdata$x:0000A060                 db    0
.xdata$x:0000A061                 db    0
.xdata$x:0000A062                 db    0
.xdata$x:0000A063                 db    0
.xdata$x:0000A064                 db    0
.xdata$x:0000A065                 db    0
.xdata$x:0000A066                 db    0
.xdata$x:0000A067                 db    0
.xdata$x:0000A068                 db    0
.xdata$x:0000A069                 db    0
.xdata$x:0000A06A                 db    0
.xdata$x:0000A06B                 db    0
.xdata$x:0000A06C                 db    0
.xdata$x:0000A06D                 db    0
.xdata$x:0000A06E                 db    0
.xdata$x:0000A06F                 db    0
.xdata$x:0000A070                 db    0
.xdata$x:0000A071                 db    0
.xdata$x:0000A072                 db    0
.xdata$x:0000A073                 db    0
.xdata$x:0000A074                 db    0
.xdata$x:0000A075                 db    0
.xdata$x:0000A076                 db    0
.xdata$x:0000A077                 db    0
.xdata$x:0000A077 _xdata$x        ends
.xdata$x:0000A077
.xdata$x:0000A078 ; ===========================================================================
.xdata$x:0000A078
.xdata$x:0000A078 ; Segment type: Pure data
.xdata$x:0000A078 ; Segment permissions: Read
.xdata$x:0000A078 _xdata$x        segment dword public 'DATA' use32
.xdata$x:0000A078                 assume cs:_xdata$x
.xdata$x:0000A078                 ;org 0A078h
.xdata$x:0000A078 ; COMDAT (pick associative to section at 37E8)
.xdata$x:0000A078 __unwindtable$??$construct@UToken@@U1@@?$allocator@UToken@@@std@@QAEXPAUToken@@$$QAU2@@Z db 0FFh
.xdata$x:0000A078                                         ; DATA XREF: .xdata$x:0000A088o
.xdata$x:0000A079                 db 0FFh
.xdata$x:0000A07A                 db 0FFh
.xdata$x:0000A07B                 db 0FFh
.xdata$x:0000A07C                 dd offset __unwindfunclet$??$construct@UToken@@U1@@?$allocator@UToken@@@std@@QAEXPAUToken@@$$QAU2@@Z$0
.xdata$x:0000A080 __ehfuncinfo$??$construct@UToken@@U1@@?$allocator@UToken@@@std@@QAEXPAUToken@@$$QAU2@@Z db  22h ; "
.xdata$x:0000A080                                         ; DATA XREF: __ehhandler$??$construct@UToken@@U1@@?$allocator@UToken@@@std@@QAEXPAUToken@@$$QAU2@@Z+11o
.xdata$x:0000A081                 db    5
.xdata$x:0000A082                 db  93h ; ô
.xdata$x:0000A083                 db  19h
.xdata$x:0000A084                 db    1
.xdata$x:0000A085                 db    0
.xdata$x:0000A086                 db    0
.xdata$x:0000A087                 db    0
.xdata$x:0000A088                 dd offset __unwindtable$??$construct@UToken@@U1@@?$allocator@UToken@@@std@@QAEXPAUToken@@$$QAU2@@Z
.xdata$x:0000A08C                 db    0
.xdata$x:0000A08D                 db    0
.xdata$x:0000A08E                 db    0
.xdata$x:0000A08F                 db    0
.xdata$x:0000A090                 db    0
.xdata$x:0000A091                 db    0
.xdata$x:0000A092                 db    0
.xdata$x:0000A093                 db    0
.xdata$x:0000A094                 db    0
.xdata$x:0000A095                 db    0
.xdata$x:0000A096                 db    0
.xdata$x:0000A097                 db    0
.xdata$x:0000A098                 db    0
.xdata$x:0000A099                 db    0
.xdata$x:0000A09A                 db    0
.xdata$x:0000A09B                 db    0
.xdata$x:0000A09C                 db    0
.xdata$x:0000A09D                 db    0
.xdata$x:0000A09E                 db    0
.xdata$x:0000A09F                 db    0
.xdata$x:0000A0A0                 db    0
.xdata$x:0000A0A1                 db    0
.xdata$x:0000A0A2                 db    0
.xdata$x:0000A0A3                 db    0
.xdata$x:0000A0A3 _xdata$x        ends
.xdata$x:0000A0A3
.xdata$x:0000A0A4 ; ===========================================================================
.xdata$x:0000A0A4
.xdata$x:0000A0A4 ; Segment type: Pure data
.xdata$x:0000A0A4 ; Segment permissions: Read
.xdata$x:0000A0A4 _xdata$x        segment dword public 'DATA' use32
.xdata$x:0000A0A4                 assume cs:_xdata$x
.xdata$x:0000A0A4                 ;org 0A0A4h
.xdata$x:0000A0A4 ; COMDAT (pick associative to section at 357C)
.xdata$x:0000A0A4 __unwindtable$??$construct@UFunctionValues@@AAU1@@?$allocator@UFunctionValues@@@std@@QAEXPAUFunctionValues@@AAU2@@Z db 0FFh
.xdata$x:0000A0A4                                         ; DATA XREF: .xdata$x:0000A0B4o
.xdata$x:0000A0A5                 db 0FFh
.xdata$x:0000A0A6                 db 0FFh
.xdata$x:0000A0A7                 db 0FFh
.xdata$x:0000A0A8                 dd offset __unwindfunclet$??$construct@UFunctionValues@@AAU1@@?$allocator@UFunctionValues@@@std@@QAEXPAUFunctionValues@@AAU2@@Z$0
.xdata$x:0000A0AC __ehfuncinfo$??$construct@UFunctionValues@@AAU1@@?$allocator@UFunctionValues@@@std@@QAEXPAUFunctionValues@@AAU2@@Z db  22h ; "
.xdata$x:0000A0AC                                         ; DATA XREF: __ehhandler$??$construct@UFunctionValues@@AAU1@@?$allocator@UFunctionValues@@@std@@QAEXPAUFunctionValues@@AAU2@@Z+11o
.xdata$x:0000A0AD                 db    5
.xdata$x:0000A0AE                 db  93h ; ô
.xdata$x:0000A0AF                 db  19h
.xdata$x:0000A0B0                 db    1
.xdata$x:0000A0B1                 db    0
.xdata$x:0000A0B2                 db    0
.xdata$x:0000A0B3                 db    0
.xdata$x:0000A0B4                 dd offset __unwindtable$??$construct@UFunctionValues@@AAU1@@?$allocator@UFunctionValues@@@std@@QAEXPAUFunctionValues@@AAU2@@Z
.xdata$x:0000A0B8                 db    0
.xdata$x:0000A0B9                 db    0
.xdata$x:0000A0BA                 db    0
.xdata$x:0000A0BB                 db    0
.xdata$x:0000A0BC                 db    0
.xdata$x:0000A0BD                 db    0
.xdata$x:0000A0BE                 db    0
.xdata$x:0000A0BF                 db    0
.xdata$x:0000A0C0                 db    0
.xdata$x:0000A0C1                 db    0
.xdata$x:0000A0C2                 db    0
.xdata$x:0000A0C3                 db    0
.xdata$x:0000A0C4                 db    0
.xdata$x:0000A0C5                 db    0
.xdata$x:0000A0C6                 db    0
.xdata$x:0000A0C7                 db    0
.xdata$x:0000A0C8                 db    0
.xdata$x:0000A0C9                 db    0
.xdata$x:0000A0CA                 db    0
.xdata$x:0000A0CB                 db    0
.xdata$x:0000A0CC                 db    0
.xdata$x:0000A0CD                 db    0
.xdata$x:0000A0CE                 db    0
.xdata$x:0000A0CF                 db    0
.xdata$x:0000A0CF _xdata$x        ends
.xdata$x:0000A0CF
.xdata$x:0000A0D0 ; ===========================================================================
.xdata$x:0000A0D0
.xdata$x:0000A0D0 ; Segment type: Pure data
.xdata$x:0000A0D0 ; Segment permissions: Read
.xdata$x:0000A0D0 _xdata$x        segment dword public 'DATA' use32
.xdata$x:0000A0D0                 assume cs:_xdata$x
.xdata$x:0000A0D0                 ;org 0A0D0h
.xdata$x:0000A0D0 ; COMDAT (pick associative to section at 3330)
.xdata$x:0000A0D0 __unwindtable$??$construct@PADAAPAD@?$allocator@D@std@@QAEXPAPADAAPAD@Z db 0FFh
.xdata$x:0000A0D0                                         ; DATA XREF: .xdata$x:0000A0E0o
.xdata$x:0000A0D1                 db 0FFh
.xdata$x:0000A0D2                 db 0FFh
.xdata$x:0000A0D3                 db 0FFh
.xdata$x:0000A0D4                 dd offset __unwindfunclet$??$construct@PADAAPAD@?$allocator@D@std@@QAEXPAPADAAPAD@Z$0
.xdata$x:0000A0D8 __ehfuncinfo$??$construct@PADAAPAD@?$allocator@D@std@@QAEXPAPADAAPAD@Z db  22h ; "
.xdata$x:0000A0D8                                         ; DATA XREF: __ehhandler$??$construct@PADAAPAD@?$allocator@D@std@@QAEXPAPADAAPAD@Z+11o
.xdata$x:0000A0D9                 db    5
.xdata$x:0000A0DA                 db  93h ; ô
.xdata$x:0000A0DB                 db  19h
.xdata$x:0000A0DC                 db    1
.xdata$x:0000A0DD                 db    0
.xdata$x:0000A0DE                 db    0
.xdata$x:0000A0DF                 db    0
.xdata$x:0000A0E0                 dd offset __unwindtable$??$construct@PADAAPAD@?$allocator@D@std@@QAEXPAPADAAPAD@Z
.xdata$x:0000A0E4                 db    0
.xdata$x:0000A0E5                 db    0
.xdata$x:0000A0E6                 db    0
.xdata$x:0000A0E7                 db    0
.xdata$x:0000A0E8                 db    0
.xdata$x:0000A0E9                 db    0
.xdata$x:0000A0EA                 db    0
.xdata$x:0000A0EB                 db    0
.xdata$x:0000A0EC                 db    0
.xdata$x:0000A0ED                 db    0
.xdata$x:0000A0EE                 db    0
.xdata$x:0000A0EF                 db    0
.xdata$x:0000A0F0                 db    0
.xdata$x:0000A0F1                 db    0
.xdata$x:0000A0F2                 db    0
.xdata$x:0000A0F3                 db    0
.xdata$x:0000A0F4                 db    0
.xdata$x:0000A0F5                 db    0
.xdata$x:0000A0F6                 db    0
.xdata$x:0000A0F7                 db    0
.xdata$x:0000A0F8                 db    0
.xdata$x:0000A0F9                 db    0
.xdata$x:0000A0FA                 db    0
.xdata$x:0000A0FB                 db    0
.xdata$x:0000A0FB _xdata$x        ends
.xdata$x:0000A0FB
.xdata$x:0000A0FC ; ===========================================================================
.xdata$x:0000A0FC
.xdata$x:0000A0FC ; Segment type: Pure data
.xdata$x:0000A0FC ; Segment permissions: Read
.xdata$x:0000A0FC _xdata$x        segment dword public 'DATA' use32
.xdata$x:0000A0FC                 assume cs:_xdata$x
.xdata$x:0000A0FC                 ;org 0A0FCh
.xdata$x:0000A0FC ; COMDAT (pick associative to section at 28C8)
.xdata$x:0000A0FC __unwindtable$??$_Ucopy@V?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@PB_W@std@@@std@@@std@@@?$vector@PB_WV?$allocator@PB_W@std@@@std@@IAEPAPB_WV?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@PB_W@std@@@std@@@1@0PAPB_W@Z db 0FFh
.xdata$x:0000A0FC                                         ; DATA XREF: .xdata$x:0000A124o
.xdata$x:0000A0FD                 db 0FFh
.xdata$x:0000A0FE                 db 0FFh
.xdata$x:0000A0FF                 db 0FFh
.xdata$x:0000A100                 dd offset __unwindfunclet$??$_Ucopy@V?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@PB_W@std@@@std@@@std@@@?$vector@PB_WV?$allocator@PB_W@std@@@std@@IAEPAPB_WV?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@PB_W@std@@@std@@@1@0PAPB_W@Z$0
.xdata$x:0000A104                 align 8
.xdata$x:0000A108                 dd offset __unwindfunclet$??$_Ucopy@V?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@PB_W@std@@@std@@@std@@@?$vector@PB_WV?$allocator@PB_W@std@@@std@@IAEPAPB_WV?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@PB_W@std@@@std@@@1@0PAPB_W@Z$1
.xdata$x:0000A10C                 db    1
.xdata$x:0000A10D                 db    0
.xdata$x:0000A10E                 db    0
.xdata$x:0000A10F                 db    0
.xdata$x:0000A110                 dd offset __unwindfunclet$??$_Ucopy@V?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@PB_W@std@@@std@@@std@@@?$vector@PB_WV?$allocator@PB_W@std@@@std@@IAEPAPB_WV?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@PB_W@std@@@std@@@1@0PAPB_W@Z$2
.xdata$x:0000A114                 db    2
.xdata$x:0000A115                 db    0
.xdata$x:0000A116                 db    0
.xdata$x:0000A117                 db    0
.xdata$x:0000A118                 dd offset __unwindfunclet$??$_Ucopy@V?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@PB_W@std@@@std@@@std@@@?$vector@PB_WV?$allocator@PB_W@std@@@std@@IAEPAPB_WV?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@PB_W@std@@@std@@@1@0PAPB_W@Z$3
.xdata$x:0000A11C __ehfuncinfo$??$_Ucopy@V?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@PB_W@std@@@std@@@std@@@?$vector@PB_WV?$allocator@PB_W@std@@@std@@IAEPAPB_WV?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@PB_W@std@@@std@@@1@0PAPB_W@Z db  22h ; "
.xdata$x:0000A11C                                         ; DATA XREF: __ehhandler$??$_Ucopy@V?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@PB_W@std@@@std@@@std@@@?$vector@PB_WV?$allocator@PB_W@std@@@std@@IAEPAPB_WV?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@PB_W@std@@@std@@@1@0PAPB_W@Z+11o
.xdata$x:0000A11D                 db    5
.xdata$x:0000A11E                 db  93h ; ô
.xdata$x:0000A11F                 db  19h
.xdata$x:0000A120                 db    4
.xdata$x:0000A121                 db    0
.xdata$x:0000A122                 db    0
.xdata$x:0000A123                 db    0
.xdata$x:0000A124                 dd offset __unwindtable$??$_Ucopy@V?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@PB_W@std@@@std@@@std@@@?$vector@PB_WV?$allocator@PB_W@std@@@std@@IAEPAPB_WV?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@PB_W@std@@@std@@@1@0PAPB_W@Z
.xdata$x:0000A128                 align 20h
.xdata$x:0000A128 _xdata$x        ends
.xdata$x:0000A128
.xdata$x:0000A140 ; ===========================================================================
.xdata$x:0000A140
.xdata$x:0000A140 ; Segment type: Pure data
.xdata$x:0000A140 ; Segment permissions: Read
.xdata$x:0000A140 _xdata$x        segment dword public 'DATA' use32
.xdata$x:0000A140                 assume cs:_xdata$x
.xdata$x:0000A140                 ;org 0A140h
.xdata$x:0000A140 ; COMDAT (pick associative to section at 2F00)
.xdata$x:0000A140 __catchsym$??$_Uninit_move@PAV?$vector@PB_WV?$allocator@PB_W@std@@@std@@PAV12@V?$allocator@V?$vector@PB_WV?$allocator@PB_W@std@@@std@@@2@V12@@std@@YAPAV?$vector@PB_WV?$allocator@PB_W@std@@@0@PAV10@00AAU?$_Wrap_alloc@V?$allocator@V?$vector@PB_WV?$allocator@PB_W@std@@@std@@@std@@@0@0U_Nonscalar_ptr_iterator_tag@0@@Z$2 db    0
.xdata$x:0000A140                                         ; DATA XREF: .xdata$x:0000A170o
.xdata$x:0000A141                 db    0
.xdata$x:0000A142                 db    0
.xdata$x:0000A143                 db    0
.xdata$x:0000A144                 db    0
.xdata$x:0000A145                 db    0
.xdata$x:0000A146                 db    0
.xdata$x:0000A147                 db    0
.xdata$x:0000A148                 db    0
.xdata$x:0000A149                 db    0
.xdata$x:0000A14A                 db    0
.xdata$x:0000A14B                 db    0
.xdata$x:0000A14C                 dd offset __catch$??$_Uninit_move@PAV?$vector@PB_WV?$allocator@PB_W@std@@@std@@PAV12@V?$allocator@V?$vector@PB_WV?$allocator@PB_W@std@@@std@@@2@V12@@std@@YAPAV?$vector@PB_WV?$allocator@PB_W@std@@@0@PAV10@00AAU?$_Wrap_alloc@V?$allocator@V?$vector@PB_WV?$allocator@PB_W@std@@@std@@@std@@@0@0U_Nonscalar_ptr_iterator_tag@0@@Z$0
.xdata$x:0000A150 __unwindtable$??$_Uninit_move@PAV?$vector@PB_WV?$allocator@PB_W@std@@@std@@PAV12@V?$allocator@V?$vector@PB_WV?$allocator@PB_W@std@@@std@@@2@V12@@std@@YAPAV?$vector@PB_WV?$allocator@PB_W@std@@@0@PAV10@00AAU?$_Wrap_alloc@V?$allocator@V?$vector@PB_WV?$allocator@PB_W@std@@@std@@@std@@@0@0U_Nonscalar_ptr_iterator_tag@0@@Z db 0FFh
.xdata$x:0000A150                                         ; DATA XREF: .xdata$x:0000A17Co
.xdata$x:0000A151                 db 0FFh
.xdata$x:0000A152                 db 0FFh
.xdata$x:0000A153                 db 0FFh
.xdata$x:0000A154                 db    0
.xdata$x:0000A155                 db    0
.xdata$x:0000A156                 db    0
.xdata$x:0000A157                 db    0
.xdata$x:0000A158                 db 0FFh
.xdata$x:0000A159                 db 0FFh
.xdata$x:0000A15A                 db 0FFh
.xdata$x:0000A15B                 db 0FFh
.xdata$x:0000A15C                 db    0
.xdata$x:0000A15D                 db    0
.xdata$x:0000A15E                 db    0
.xdata$x:0000A15F                 db    0
.xdata$x:0000A160 __tryblocktable$??$_Uninit_move@PAV?$vector@PB_WV?$allocator@PB_W@std@@@std@@PAV12@V?$allocator@V?$vector@PB_WV?$allocator@PB_W@std@@@std@@@2@V12@@std@@YAPAV?$vector@PB_WV?$allocator@PB_W@std@@@0@PAV10@00AAU?$_Wrap_alloc@V?$allocator@V?$vector@PB_WV?$allocator@PB_W@std@@@std@@@std@@@0@0U_Nonscalar_ptr_iterator_tag@0@@Z db    0
.xdata$x:0000A160                                         ; DATA XREF: .xdata$x:0000A184o
.xdata$x:0000A161                 db    0
.xdata$x:0000A162                 db    0
.xdata$x:0000A163                 db    0
.xdata$x:0000A164                 db    0
.xdata$x:0000A165                 db    0
.xdata$x:0000A166                 db    0
.xdata$x:0000A167                 db    0
.xdata$x:0000A168                 db    1
.xdata$x:0000A169                 db    0
.xdata$x:0000A16A                 db    0
.xdata$x:0000A16B                 db    0
.xdata$x:0000A16C                 db    1
.xdata$x:0000A16D                 db    0
.xdata$x:0000A16E                 db    0
.xdata$x:0000A16F                 db    0
.xdata$x:0000A170                 dd offset __catchsym$??$_Uninit_move@PAV?$vector@PB_WV?$allocator@PB_W@std@@@std@@PAV12@V?$allocator@V?$vector@PB_WV?$allocator@PB_W@std@@@std@@@2@V12@@std@@YAPAV?$vector@PB_WV?$allocator@PB_W@std@@@0@PAV10@00AAU?$_Wrap_alloc@V?$allocator@V?$vector@PB_WV?$allocator@PB_W@std@@@std@@@std@@@0@0U_Nonscalar_ptr_iterator_tag@0@@Z$2
.xdata$x:0000A174 __ehfuncinfo$??$_Uninit_move@PAV?$vector@PB_WV?$allocator@PB_W@std@@@std@@PAV12@V?$allocator@V?$vector@PB_WV?$allocator@PB_W@std@@@std@@@2@V12@@std@@YAPAV?$vector@PB_WV?$allocator@PB_W@std@@@0@PAV10@00AAU?$_Wrap_alloc@V?$allocator@V?$vector@PB_WV?$allocator@PB_W@std@@@std@@@std@@@0@0U_Nonscalar_ptr_iterator_tag@0@@Z db  22h ; "
.xdata$x:0000A174                                         ; DATA XREF: __ehhandler$??$_Uninit_move@PAV?$vector@PB_WV?$allocator@PB_W@std@@@std@@PAV12@V?$allocator@V?$vector@PB_WV?$allocator@PB_W@std@@@std@@@2@V12@@std@@YAPAV?$vector@PB_WV?$allocator@PB_W@std@@@0@PAV10@00AAU?$_Wrap_alloc@V?$allocator@V?$vector@PB_WV?$allocator@PB_W@std@@@std@@@std@@@0@0U_Nonscalar_ptr_iterator_tag@0@@Z+11o
.xdata$x:0000A175                 db    5
.xdata$x:0000A176                 db  93h ; ô
.xdata$x:0000A177                 db  19h
.xdata$x:0000A178                 db    2
.xdata$x:0000A179                 db    0
.xdata$x:0000A17A                 db    0
.xdata$x:0000A17B                 db    0
.xdata$x:0000A17C                 dd offset __unwindtable$??$_Uninit_move@PAV?$vector@PB_WV?$allocator@PB_W@std@@@std@@PAV12@V?$allocator@V?$vector@PB_WV?$allocator@PB_W@std@@@std@@@2@V12@@std@@YAPAV?$vector@PB_WV?$allocator@PB_W@std@@@0@PAV10@00AAU?$_Wrap_alloc@V?$allocator@V?$vector@PB_WV?$allocator@PB_W@std@@@std@@@std@@@0@0U_Nonscalar_ptr_iterator_tag@0@@Z
.xdata$x:0000A180                 db    1
.xdata$x:0000A181                 db    0
.xdata$x:0000A182                 db    0
.xdata$x:0000A183                 db    0
.xdata$x:0000A184                 dd offset __tryblocktable$??$_Uninit_move@PAV?$vector@PB_WV?$allocator@PB_W@std@@@std@@PAV12@V?$allocator@V?$vector@PB_WV?$allocator@PB_W@std@@@std@@@2@V12@@std@@YAPAV?$vector@PB_WV?$allocator@PB_W@std@@@0@PAV10@00AAU?$_Wrap_alloc@V?$allocator@V?$vector@PB_WV?$allocator@PB_W@std@@@std@@@std@@@0@0U_Nonscalar_ptr_iterator_tag@0@@Z
.xdata$x:0000A188                 db    0
.xdata$x:0000A189                 db    0
.xdata$x:0000A18A                 db    0
.xdata$x:0000A18B                 db    0
.xdata$x:0000A18C                 db    0
.xdata$x:0000A18D                 db    0
.xdata$x:0000A18E                 db    0
.xdata$x:0000A18F                 db    0
.xdata$x:0000A190                 db    0
.xdata$x:0000A191                 db    0
.xdata$x:0000A192                 db    0
.xdata$x:0000A193                 db    0
.xdata$x:0000A194                 db    0
.xdata$x:0000A195                 db    0
.xdata$x:0000A196                 db    0
.xdata$x:0000A197                 db    0
.xdata$x:0000A197 _xdata$x        ends
.xdata$x:0000A197
.xdata$x:0000A198 ; ===========================================================================
.xdata$x:0000A198
.xdata$x:0000A198 ; Segment type: Pure data
.xdata$x:0000A198 ; Segment permissions: Read
.xdata$x:0000A198 _xdata$x        segment dword public 'DATA' use32
.xdata$x:0000A198                 assume cs:_xdata$x
.xdata$x:0000A198                 ;org 0A198h
.xdata$x:0000A198 ; COMDAT (pick associative to section at 2DB0)
.xdata$x:0000A198 __catchsym$??$_Uninit_move@PAUToken@@PAU1@V?$allocator@UToken@@@std@@U1@@std@@YAPAUToken@@PAU1@00AAU?$_Wrap_alloc@V?$allocator@UToken@@@std@@@0@0U_Nonscalar_ptr_iterator_tag@0@@Z$2 db    0
.xdata$x:0000A198                                         ; DATA XREF: .xdata$x:0000A1C8o
.xdata$x:0000A199                 db    0
.xdata$x:0000A19A                 db    0
.xdata$x:0000A19B                 db    0
.xdata$x:0000A19C                 db    0
.xdata$x:0000A19D                 db    0
.xdata$x:0000A19E                 db    0
.xdata$x:0000A19F                 db    0
.xdata$x:0000A1A0                 db    0
.xdata$x:0000A1A1                 db    0
.xdata$x:0000A1A2                 db    0
.xdata$x:0000A1A3                 db    0
.xdata$x:0000A1A4                 dd offset __catch$??$_Uninit_move@PAUToken@@PAU1@V?$allocator@UToken@@@std@@U1@@std@@YAPAUToken@@PAU1@00AAU?$_Wrap_alloc@V?$allocator@UToken@@@std@@@0@0U_Nonscalar_ptr_iterator_tag@0@@Z$0
.xdata$x:0000A1A8 __unwindtable$??$_Uninit_move@PAUToken@@PAU1@V?$allocator@UToken@@@std@@U1@@std@@YAPAUToken@@PAU1@00AAU?$_Wrap_alloc@V?$allocator@UToken@@@std@@@0@0U_Nonscalar_ptr_iterator_tag@0@@Z db 0FFh
.xdata$x:0000A1A8                                         ; DATA XREF: .xdata$x:0000A1D4o
.xdata$x:0000A1A9                 db 0FFh
.xdata$x:0000A1AA                 db 0FFh
.xdata$x:0000A1AB                 db 0FFh
.xdata$x:0000A1AC                 db    0
.xdata$x:0000A1AD                 db    0
.xdata$x:0000A1AE                 db    0
.xdata$x:0000A1AF                 db    0
.xdata$x:0000A1B0                 db 0FFh
.xdata$x:0000A1B1                 db 0FFh
.xdata$x:0000A1B2                 db 0FFh
.xdata$x:0000A1B3                 db 0FFh
.xdata$x:0000A1B4                 db    0
.xdata$x:0000A1B5                 db    0
.xdata$x:0000A1B6                 db    0
.xdata$x:0000A1B7                 db    0
.xdata$x:0000A1B8 __tryblocktable$??$_Uninit_move@PAUToken@@PAU1@V?$allocator@UToken@@@std@@U1@@std@@YAPAUToken@@PAU1@00AAU?$_Wrap_alloc@V?$allocator@UToken@@@std@@@0@0U_Nonscalar_ptr_iterator_tag@0@@Z db    0
.xdata$x:0000A1B8                                         ; DATA XREF: .xdata$x:0000A1DCo
.xdata$x:0000A1B9                 db    0
.xdata$x:0000A1BA                 db    0
.xdata$x:0000A1BB                 db    0
.xdata$x:0000A1BC                 db    0
.xdata$x:0000A1BD                 db    0
.xdata$x:0000A1BE                 db    0
.xdata$x:0000A1BF                 db    0
.xdata$x:0000A1C0                 db    1
.xdata$x:0000A1C1                 db    0
.xdata$x:0000A1C2                 db    0
.xdata$x:0000A1C3                 db    0
.xdata$x:0000A1C4                 db    1
.xdata$x:0000A1C5                 db    0
.xdata$x:0000A1C6                 db    0
.xdata$x:0000A1C7                 db    0
.xdata$x:0000A1C8                 dd offset __catchsym$??$_Uninit_move@PAUToken@@PAU1@V?$allocator@UToken@@@std@@U1@@std@@YAPAUToken@@PAU1@00AAU?$_Wrap_alloc@V?$allocator@UToken@@@std@@@0@0U_Nonscalar_ptr_iterator_tag@0@@Z$2
.xdata$x:0000A1CC __ehfuncinfo$??$_Uninit_move@PAUToken@@PAU1@V?$allocator@UToken@@@std@@U1@@std@@YAPAUToken@@PAU1@00AAU?$_Wrap_alloc@V?$allocator@UToken@@@std@@@0@0U_Nonscalar_ptr_iterator_tag@0@@Z db  22h ; "
.xdata$x:0000A1CC                                         ; DATA XREF: __ehhandler$??$_Uninit_move@PAUToken@@PAU1@V?$allocator@UToken@@@std@@U1@@std@@YAPAUToken@@PAU1@00AAU?$_Wrap_alloc@V?$allocator@UToken@@@std@@@0@0U_Nonscalar_ptr_iterator_tag@0@@Z+11o
.xdata$x:0000A1CD                 db    5
.xdata$x:0000A1CE                 db  93h ; ô
.xdata$x:0000A1CF                 db  19h
.xdata$x:0000A1D0                 db    2
.xdata$x:0000A1D1                 db    0
.xdata$x:0000A1D2                 db    0
.xdata$x:0000A1D3                 db    0
.xdata$x:0000A1D4                 dd offset __unwindtable$??$_Uninit_move@PAUToken@@PAU1@V?$allocator@UToken@@@std@@U1@@std@@YAPAUToken@@PAU1@00AAU?$_Wrap_alloc@V?$allocator@UToken@@@std@@@0@0U_Nonscalar_ptr_iterator_tag@0@@Z
.xdata$x:0000A1D8                 db    1
.xdata$x:0000A1D9                 db    0
.xdata$x:0000A1DA                 db    0
.xdata$x:0000A1DB                 db    0
.xdata$x:0000A1DC                 dd offset __tryblocktable$??$_Uninit_move@PAUToken@@PAU1@V?$allocator@UToken@@@std@@U1@@std@@YAPAUToken@@PAU1@00AAU?$_Wrap_alloc@V?$allocator@UToken@@@std@@@0@0U_Nonscalar_ptr_iterator_tag@0@@Z
.xdata$x:0000A1E0                 db    0
.xdata$x:0000A1E1                 db    0
.xdata$x:0000A1E2                 db    0
.xdata$x:0000A1E3                 db    0
.xdata$x:0000A1E4                 db    0
.xdata$x:0000A1E5                 db    0
.xdata$x:0000A1E6                 db    0
.xdata$x:0000A1E7                 db    0
.xdata$x:0000A1E8                 db    0
.xdata$x:0000A1E9                 db    0
.xdata$x:0000A1EA                 db    0
.xdata$x:0000A1EB                 db    0
.xdata$x:0000A1EC                 db    0
.xdata$x:0000A1ED                 db    0
.xdata$x:0000A1EE                 db    0
.xdata$x:0000A1EF                 db    0
.xdata$x:0000A1EF _xdata$x        ends
.xdata$x:0000A1EF
.xdata$x:0000A1F0 ; ===========================================================================
.xdata$x:0000A1F0
.xdata$x:0000A1F0 ; Segment type: Pure data
.xdata$x:0000A1F0 ; Segment permissions: Read
.xdata$x:0000A1F0 _xdata$x        segment dword public 'DATA' use32
.xdata$x:0000A1F0                 assume cs:_xdata$x
.xdata$x:0000A1F0                 ;org 0A1F0h
.xdata$x:0000A1F0 ; COMDAT (pick associative to section at 2C60)
.xdata$x:0000A1F0 __catchsym$??$_Uninit_move@PAUFunctionValues@@PAU1@V?$allocator@UFunctionValues@@@std@@U1@@std@@YAPAUFunctionValues@@PAU1@00AAU?$_Wrap_alloc@V?$allocator@UFunctionValues@@@std@@@0@0U_Nonscalar_ptr_iterator_tag@0@@Z$2 db    0
.xdata$x:0000A1F0                                         ; DATA XREF: .xdata$x:0000A220o
.xdata$x:0000A1F1                 db    0
.xdata$x:0000A1F2                 db    0
.xdata$x:0000A1F3                 db    0
.xdata$x:0000A1F4                 db    0
.xdata$x:0000A1F5                 db    0
.xdata$x:0000A1F6                 db    0
.xdata$x:0000A1F7                 db    0
.xdata$x:0000A1F8                 db    0
.xdata$x:0000A1F9                 db    0
.xdata$x:0000A1FA                 db    0
.xdata$x:0000A1FB                 db    0
.xdata$x:0000A1FC                 dd offset __catch$??$_Uninit_move@PAUFunctionValues@@PAU1@V?$allocator@UFunctionValues@@@std@@U1@@std@@YAPAUFunctionValues@@PAU1@00AAU?$_Wrap_alloc@V?$allocator@UFunctionValues@@@std@@@0@0U_Nonscalar_ptr_iterator_tag@0@@Z$0
.xdata$x:0000A200 __unwindtable$??$_Uninit_move@PAUFunctionValues@@PAU1@V?$allocator@UFunctionValues@@@std@@U1@@std@@YAPAUFunctionValues@@PAU1@00AAU?$_Wrap_alloc@V?$allocator@UFunctionValues@@@std@@@0@0U_Nonscalar_ptr_iterator_tag@0@@Z db 0FFh
.xdata$x:0000A200                                         ; DATA XREF: .xdata$x:0000A22Co
.xdata$x:0000A201                 db 0FFh
.xdata$x:0000A202                 db 0FFh
.xdata$x:0000A203                 db 0FFh
.xdata$x:0000A204                 db    0
.xdata$x:0000A205                 db    0
.xdata$x:0000A206                 db    0
.xdata$x:0000A207                 db    0
.xdata$x:0000A208                 db 0FFh
.xdata$x:0000A209                 db 0FFh
.xdata$x:0000A20A                 db 0FFh
.xdata$x:0000A20B                 db 0FFh
.xdata$x:0000A20C                 db    0
.xdata$x:0000A20D                 db    0
.xdata$x:0000A20E                 db    0
.xdata$x:0000A20F                 db    0
.xdata$x:0000A210 __tryblocktable$??$_Uninit_move@PAUFunctionValues@@PAU1@V?$allocator@UFunctionValues@@@std@@U1@@std@@YAPAUFunctionValues@@PAU1@00AAU?$_Wrap_alloc@V?$allocator@UFunctionValues@@@std@@@0@0U_Nonscalar_ptr_iterator_tag@0@@Z db    0
.xdata$x:0000A210                                         ; DATA XREF: .xdata$x:0000A234o
.xdata$x:0000A211                 db    0
.xdata$x:0000A212                 db    0
.xdata$x:0000A213                 db    0
.xdata$x:0000A214                 db    0
.xdata$x:0000A215                 db    0
.xdata$x:0000A216                 db    0
.xdata$x:0000A217                 db    0
.xdata$x:0000A218                 db    1
.xdata$x:0000A219                 db    0
.xdata$x:0000A21A                 db    0
.xdata$x:0000A21B                 db    0
.xdata$x:0000A21C                 db    1
.xdata$x:0000A21D                 db    0
.xdata$x:0000A21E                 db    0
.xdata$x:0000A21F                 db    0
.xdata$x:0000A220                 dd offset __catchsym$??$_Uninit_move@PAUFunctionValues@@PAU1@V?$allocator@UFunctionValues@@@std@@U1@@std@@YAPAUFunctionValues@@PAU1@00AAU?$_Wrap_alloc@V?$allocator@UFunctionValues@@@std@@@0@0U_Nonscalar_ptr_iterator_tag@0@@Z$2
.xdata$x:0000A224 __ehfuncinfo$??$_Uninit_move@PAUFunctionValues@@PAU1@V?$allocator@UFunctionValues@@@std@@U1@@std@@YAPAUFunctionValues@@PAU1@00AAU?$_Wrap_alloc@V?$allocator@UFunctionValues@@@std@@@0@0U_Nonscalar_ptr_iterator_tag@0@@Z db  22h ; "
.xdata$x:0000A224                                         ; DATA XREF: __ehhandler$??$_Uninit_move@PAUFunctionValues@@PAU1@V?$allocator@UFunctionValues@@@std@@U1@@std@@YAPAUFunctionValues@@PAU1@00AAU?$_Wrap_alloc@V?$allocator@UFunctionValues@@@std@@@0@0U_Nonscalar_ptr_iterator_tag@0@@Z+11o
.xdata$x:0000A225                 db    5
.xdata$x:0000A226                 db  93h ; ô
.xdata$x:0000A227                 db  19h
.xdata$x:0000A228                 db    2
.xdata$x:0000A229                 db    0
.xdata$x:0000A22A                 db    0
.xdata$x:0000A22B                 db    0
.xdata$x:0000A22C                 dd offset __unwindtable$??$_Uninit_move@PAUFunctionValues@@PAU1@V?$allocator@UFunctionValues@@@std@@U1@@std@@YAPAUFunctionValues@@PAU1@00AAU?$_Wrap_alloc@V?$allocator@UFunctionValues@@@std@@@0@0U_Nonscalar_ptr_iterator_tag@0@@Z
.xdata$x:0000A230                 db    1
.xdata$x:0000A231                 db    0
.xdata$x:0000A232                 db    0
.xdata$x:0000A233                 db    0
.xdata$x:0000A234                 dd offset __tryblocktable$??$_Uninit_move@PAUFunctionValues@@PAU1@V?$allocator@UFunctionValues@@@std@@U1@@std@@YAPAUFunctionValues@@PAU1@00AAU?$_Wrap_alloc@V?$allocator@UFunctionValues@@@std@@@0@0U_Nonscalar_ptr_iterator_tag@0@@Z
.xdata$x:0000A238                 db    0
.xdata$x:0000A239                 db    0
.xdata$x:0000A23A                 db    0
.xdata$x:0000A23B                 db    0
.xdata$x:0000A23C                 db    0
.xdata$x:0000A23D                 db    0
.xdata$x:0000A23E                 db    0
.xdata$x:0000A23F                 db    0
.xdata$x:0000A240                 db    0
.xdata$x:0000A241                 db    0
.xdata$x:0000A242                 db    0
.xdata$x:0000A243                 db    0
.xdata$x:0000A244                 db    0
.xdata$x:0000A245                 db    0
.xdata$x:0000A246                 db    0
.xdata$x:0000A247                 db    0
.xdata$x:0000A247 _xdata$x        ends
.xdata$x:0000A247
.xdata$x:0000A248 ; ===========================================================================
.xdata$x:0000A248
.xdata$x:0000A248 ; Segment type: Pure data
.xdata$x:0000A248 ; Segment permissions: Read
.xdata$x:0000A248 _xdata$x        segment dword public 'DATA' use32
.xdata$x:0000A248                 assume cs:_xdata$x
.xdata$x:0000A248                 ;org 0A248h
.xdata$x:0000A248 ; COMDAT (pick associative to section at 306C)
.xdata$x:0000A248 __unwindtable$??$_Uninitialized_copy@V?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@PB_W@std@@@std@@@std@@PAPB_WU?$_Wrap_alloc@V?$allocator@PB_W@std@@@2@@std@@YAPAPB_WV?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@PB_W@std@@@std@@@0@0PAPB_WAAU?$_Wrap_alloc@V?$allocator@PB_W@std@@@0@@Z db 0FFh
.xdata$x:0000A248                                         ; DATA XREF: .xdata$x:0000A270o
.xdata$x:0000A249                 db 0FFh
.xdata$x:0000A24A                 db 0FFh
.xdata$x:0000A24B                 db 0FFh
.xdata$x:0000A24C                 dd offset __unwindfunclet$??$_Uninitialized_copy@V?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@PB_W@std@@@std@@@std@@PAPB_WU?$_Wrap_alloc@V?$allocator@PB_W@std@@@2@@std@@YAPAPB_WV?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@PB_W@std@@@std@@@0@0PAPB_WAAU?$_Wrap_alloc@V?$allocator@PB_W@std@@@0@@Z$0
.xdata$x:0000A250                 db    0
.xdata$x:0000A251                 db    0
.xdata$x:0000A252                 db    0
.xdata$x:0000A253                 db    0
.xdata$x:0000A254                 dd offset __unwindfunclet$??$_Uninitialized_copy@V?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@PB_W@std@@@std@@@std@@PAPB_WU?$_Wrap_alloc@V?$allocator@PB_W@std@@@2@@std@@YAPAPB_WV?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@PB_W@std@@@std@@@0@0PAPB_WAAU?$_Wrap_alloc@V?$allocator@PB_W@std@@@0@@Z$1
.xdata$x:0000A258                 db    1
.xdata$x:0000A259                 db    0
.xdata$x:0000A25A                 db    0
.xdata$x:0000A25B                 db    0
.xdata$x:0000A25C                 dd offset __unwindfunclet$??$_Uninitialized_copy@V?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@PB_W@std@@@std@@@std@@PAPB_WU?$_Wrap_alloc@V?$allocator@PB_W@std@@@2@@std@@YAPAPB_WV?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@PB_W@std@@@std@@@0@0PAPB_WAAU?$_Wrap_alloc@V?$allocator@PB_W@std@@@0@@Z$2
.xdata$x:0000A260                 db    1
.xdata$x:0000A261                 db    0
.xdata$x:0000A262                 db    0
.xdata$x:0000A263                 db    0
.xdata$x:0000A264                 dd offset __unwindfunclet$??$_Uninitialized_copy@V?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@PB_W@std@@@std@@@std@@PAPB_WU?$_Wrap_alloc@V?$allocator@PB_W@std@@@2@@std@@YAPAPB_WV?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@PB_W@std@@@std@@@0@0PAPB_WAAU?$_Wrap_alloc@V?$allocator@PB_W@std@@@0@@Z$3
.xdata$x:0000A268 __ehfuncinfo$??$_Uninitialized_copy@V?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@PB_W@std@@@std@@@std@@PAPB_WU?$_Wrap_alloc@V?$allocator@PB_W@std@@@2@@std@@YAPAPB_WV?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@PB_W@std@@@std@@@0@0PAPB_WAAU?$_Wrap_alloc@V?$allocator@PB_W@std@@@0@@Z db  22h ; "
.xdata$x:0000A268                                         ; DATA XREF: __ehhandler$??$_Uninitialized_copy@V?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@PB_W@std@@@std@@@std@@PAPB_WU?$_Wrap_alloc@V?$allocator@PB_W@std@@@2@@std@@YAPAPB_WV?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@PB_W@std@@@std@@@0@0PAPB_WAAU?$_Wrap_alloc@V?$allocator@PB_W@std@@@0@@Z+11o
.xdata$x:0000A269                 db    5
.xdata$x:0000A26A                 db  93h ; ô
.xdata$x:0000A26B                 db  19h
.xdata$x:0000A26C                 db    4
.xdata$x:0000A26D                 db    0
.xdata$x:0000A26E                 db    0
.xdata$x:0000A26F                 db    0
.xdata$x:0000A270                 dd offset __unwindtable$??$_Uninitialized_copy@V?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@PB_W@std@@@std@@@std@@PAPB_WU?$_Wrap_alloc@V?$allocator@PB_W@std@@@2@@std@@YAPAPB_WV?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@PB_W@std@@@std@@@0@0PAPB_WAAU?$_Wrap_alloc@V?$allocator@PB_W@std@@@0@@Z
.xdata$x:0000A274                 db    0
.xdata$x:0000A275                 db    0
.xdata$x:0000A276                 db    0
.xdata$x:0000A277                 db    0
.xdata$x:0000A278                 db    0
.xdata$x:0000A279                 db    0
.xdata$x:0000A27A                 db    0
.xdata$x:0000A27B                 db    0
.xdata$x:0000A27C                 db    0
.xdata$x:0000A27D                 db    0
.xdata$x:0000A27E                 db    0
.xdata$x:0000A27F                 db    0
.xdata$x:0000A280                 db    0
.xdata$x:0000A281                 db    0
.xdata$x:0000A282                 db    0
.xdata$x:0000A283                 db    0
.xdata$x:0000A284                 db    0
.xdata$x:0000A285                 db    0
.xdata$x:0000A286                 db    0
.xdata$x:0000A287                 db    0
.xdata$x:0000A288                 db    0
.xdata$x:0000A289                 db    0
.xdata$x:0000A28A                 db    0
.xdata$x:0000A28B                 db    0
.xdata$x:0000A28B _xdata$x        ends
.xdata$x:0000A28B
.xdata$x:0000A28C ; ===========================================================================
.xdata$x:0000A28C
.xdata$x:0000A28C ; Segment type: Pure data
.xdata$x:0000A28C ; Segment permissions: Read
.xdata$x:0000A28C _xdata$x        segment dword public 'DATA' use32
.xdata$x:0000A28C                 assume cs:_xdata$x
.xdata$x:0000A28C                 ;org 0A28Ch
.xdata$x:0000A28C ; COMDAT (pick associative to section at 2AB8)
.xdata$x:0000A28C __unwindtable$??$_Unchecked@V?$_Vector_val@U?$_Simple_types@PB_W@std@@@std@@@std@@YAPBQB_WV?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@PB_W@std@@@std@@@0@@Z db 0FFh
.xdata$x:0000A28C                                         ; DATA XREF: .xdata$x:0000A29Co
.xdata$x:0000A28D                 db 0FFh
.xdata$x:0000A28E                 db 0FFh
.xdata$x:0000A28F                 db 0FFh
.xdata$x:0000A290                 dd offset __unwindfunclet$??$_Unchecked@V?$_Vector_val@U?$_Simple_types@PB_W@std@@@std@@@std@@YAPBQB_WV?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@PB_W@std@@@std@@@0@@Z$0
.xdata$x:0000A294 __ehfuncinfo$??$_Unchecked@V?$_Vector_val@U?$_Simple_types@PB_W@std@@@std@@@std@@YAPBQB_WV?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@PB_W@std@@@std@@@0@@Z db  22h ; "
.xdata$x:0000A294                                         ; DATA XREF: __ehhandler$??$_Unchecked@V?$_Vector_val@U?$_Simple_types@PB_W@std@@@std@@@std@@YAPBQB_WV?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@PB_W@std@@@std@@@0@@Z+11o
.xdata$x:0000A295                 db    5
.xdata$x:0000A296                 db  93h ; ô
.xdata$x:0000A297                 db  19h
.xdata$x:0000A298                 db    1
.xdata$x:0000A299                 db    0
.xdata$x:0000A29A                 db    0
.xdata$x:0000A29B                 db    0
.xdata$x:0000A29C                 dd offset __unwindtable$??$_Unchecked@V?$_Vector_val@U?$_Simple_types@PB_W@std@@@std@@@std@@YAPBQB_WV?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@PB_W@std@@@std@@@0@@Z
.xdata$x:0000A2A0                 db    0
.xdata$x:0000A2A1                 db    0
.xdata$x:0000A2A2                 db    0
.xdata$x:0000A2A3                 db    0
.xdata$x:0000A2A4                 db    0
.xdata$x:0000A2A5                 db    0
.xdata$x:0000A2A6                 db    0
.xdata$x:0000A2A7                 db    0
.xdata$x:0000A2A8                 db    0
.xdata$x:0000A2A9                 db    0
.xdata$x:0000A2AA                 db    0
.xdata$x:0000A2AB                 db    0
.xdata$x:0000A2AC                 db    0
.xdata$x:0000A2AD                 db    0
.xdata$x:0000A2AE                 db    0
.xdata$x:0000A2AF                 db    0
.xdata$x:0000A2B0                 db    0
.xdata$x:0000A2B1                 db    0
.xdata$x:0000A2B2                 db    0
.xdata$x:0000A2B3                 db    0
.xdata$x:0000A2B4                 db    0
.xdata$x:0000A2B5                 db    0
.xdata$x:0000A2B6                 db    0
.xdata$x:0000A2B7                 db    0
.xdata$x:0000A2B7 _xdata$x        ends
.xdata$x:0000A2B7
.xdata$x:0000A2B8 ; ===========================================================================
.xdata$x:0000A2B8
.xdata$x:0000A2B8 ; Segment type: Pure data
.xdata$x:0000A2B8 ; Segment permissions: Read
.xdata$x:0000A2B8 _xdata$x        segment dword public 'DATA' use32
.xdata$x:0000A2B8                 assume cs:_xdata$x
.xdata$x:0000A2B8                 ;org 0A2B8h
.xdata$x:0000A2B8 ; COMDAT (pick associative to section at 3B44)
.xdata$x:0000A2B8 __unwindtable$??$construct@V?$vector@PB_WV?$allocator@PB_W@std@@@std@@V12@@?$allocator@V?$vector@PB_WV?$allocator@PB_W@std@@@std@@@std@@QAEXPAV?$vector@PB_WV?$allocator@PB_W@std@@@1@$$QAV21@@Z db 0FFh
.xdata$x:0000A2B8                                         ; DATA XREF: .xdata$x:0000A2C8o
.xdata$x:0000A2B9                 db 0FFh
.xdata$x:0000A2BA                 db 0FFh
.xdata$x:0000A2BB                 db 0FFh
.xdata$x:0000A2BC                 dd offset __unwindfunclet$??$construct@V?$vector@PB_WV?$allocator@PB_W@std@@@std@@V12@@?$allocator@V?$vector@PB_WV?$allocator@PB_W@std@@@std@@@std@@QAEXPAV?$vector@PB_WV?$allocator@PB_W@std@@@1@$$QAV21@@Z$0
.xdata$x:0000A2C0 __ehfuncinfo$??$construct@V?$vector@PB_WV?$allocator@PB_W@std@@@std@@V12@@?$allocator@V?$vector@PB_WV?$allocator@PB_W@std@@@std@@@std@@QAEXPAV?$vector@PB_WV?$allocator@PB_W@std@@@1@$$QAV21@@Z db  22h ; "
.xdata$x:0000A2C0                                         ; DATA XREF: __ehhandler$??$construct@V?$vector@PB_WV?$allocator@PB_W@std@@@std@@V12@@?$allocator@V?$vector@PB_WV?$allocator@PB_W@std@@@std@@@std@@QAEXPAV?$vector@PB_WV?$allocator@PB_W@std@@@1@$$QAV21@@Z+11o
.xdata$x:0000A2C1                 db    5
.xdata$x:0000A2C2                 db  93h ; ô
.xdata$x:0000A2C3                 db  19h
.xdata$x:0000A2C4                 db    1
.xdata$x:0000A2C5                 db    0
.xdata$x:0000A2C6                 db    0
.xdata$x:0000A2C7                 db    0
.xdata$x:0000A2C8                 dd offset __unwindtable$??$construct@V?$vector@PB_WV?$allocator@PB_W@std@@@std@@V12@@?$allocator@V?$vector@PB_WV?$allocator@PB_W@std@@@std@@@std@@QAEXPAV?$vector@PB_WV?$allocator@PB_W@std@@@1@$$QAV21@@Z
.xdata$x:0000A2CC                 db    0
.xdata$x:0000A2CD                 db    0
.xdata$x:0000A2CE                 db    0
.xdata$x:0000A2CF                 db    0
.xdata$x:0000A2D0                 db    0
.xdata$x:0000A2D1                 db    0
.xdata$x:0000A2D2                 db    0
.xdata$x:0000A2D3                 db    0
.xdata$x:0000A2D4                 db    0
.xdata$x:0000A2D5                 db    0
.xdata$x:0000A2D6                 db    0
.xdata$x:0000A2D7                 db    0
.xdata$x:0000A2D8                 db    0
.xdata$x:0000A2D9                 db    0
.xdata$x:0000A2DA                 db    0
.xdata$x:0000A2DB                 db    0
.xdata$x:0000A2DC                 db    0
.xdata$x:0000A2DD                 db    0
.xdata$x:0000A2DE                 db    0
.xdata$x:0000A2DF                 db    0
.xdata$x:0000A2E0                 db    0
.xdata$x:0000A2E1                 db    0
.xdata$x:0000A2E2                 db    0
.xdata$x:0000A2E3                 db    0
.xdata$x:0000A2E3 _xdata$x        ends
.xdata$x:0000A2E3
.xdata$x:0000A2E4 ; ===========================================================================
.xdata$x:0000A2E4
.xdata$x:0000A2E4 ; Segment type: Pure data
.xdata$x:0000A2E4 ; Segment permissions: Read
.xdata$x:0000A2E4 _xdata$x        segment dword public 'DATA' use32
.xdata$x:0000A2E4                 assume cs:_xdata$x
.xdata$x:0000A2E4                 ;org 0A2E4h
.xdata$x:0000A2E4 ; COMDAT (pick associative to section at 36D8)
.xdata$x:0000A2E4 __unwindtable$??$construct@UFunctionValues@@U1@@?$allocator@UFunctionValues@@@std@@QAEXPAUFunctionValues@@$$QAU2@@Z db 0FFh
.xdata$x:0000A2E4                                         ; DATA XREF: .xdata$x:0000A2F4o
.xdata$x:0000A2E5                 db 0FFh
.xdata$x:0000A2E6                 db 0FFh
.xdata$x:0000A2E7                 db 0FFh
.xdata$x:0000A2E8                 dd offset __unwindfunclet$??$construct@UFunctionValues@@U1@@?$allocator@UFunctionValues@@@std@@QAEXPAUFunctionValues@@$$QAU2@@Z$0
.xdata$x:0000A2EC __ehfuncinfo$??$construct@UFunctionValues@@U1@@?$allocator@UFunctionValues@@@std@@QAEXPAUFunctionValues@@$$QAU2@@Z db  22h ; "
.xdata$x:0000A2EC                                         ; DATA XREF: __ehhandler$??$construct@UFunctionValues@@U1@@?$allocator@UFunctionValues@@@std@@QAEXPAUFunctionValues@@$$QAU2@@Z+11o
.xdata$x:0000A2ED                 db    5
.xdata$x:0000A2EE                 db  93h ; ô
.xdata$x:0000A2EF                 db  19h
.xdata$x:0000A2F0                 db    1
.xdata$x:0000A2F1                 db    0
.xdata$x:0000A2F2                 db    0
.xdata$x:0000A2F3                 db    0
.xdata$x:0000A2F4                 dd offset __unwindtable$??$construct@UFunctionValues@@U1@@?$allocator@UFunctionValues@@@std@@QAEXPAUFunctionValues@@$$QAU2@@Z
.xdata$x:0000A2F8                 db    0
.xdata$x:0000A2F9                 db    0
.xdata$x:0000A2FA                 db    0
.xdata$x:0000A2FB                 db    0
.xdata$x:0000A2FC                 db    0
.xdata$x:0000A2FD                 db    0
.xdata$x:0000A2FE                 db    0
.xdata$x:0000A2FF                 db    0
.xdata$x:0000A300                 db    0
.xdata$x:0000A301                 db    0
.xdata$x:0000A302                 db    0
.xdata$x:0000A303                 db    0
.xdata$x:0000A304                 db    0
.xdata$x:0000A305                 db    0
.xdata$x:0000A306                 db    0
.xdata$x:0000A307                 db    0
.xdata$x:0000A308                 db    0
.xdata$x:0000A309                 db    0
.xdata$x:0000A30A                 db    0
.xdata$x:0000A30B                 db    0
.xdata$x:0000A30C                 db    0
.xdata$x:0000A30D                 db    0
.xdata$x:0000A30E                 db    0
.xdata$x:0000A30F                 db    0
.xdata$x:0000A30F _xdata$x        ends
.xdata$x:0000A30F
.bss:0000A310 ; ===========================================================================
.bss:0000A310
.bss:0000A310 ; Segment type: Uninitialized
.bss:0000A310 ; Segment permissions: Read/Write
.bss:0000A310 _bss            segment byte public 'BSS' use32
.bss:0000A310                 assume cs:_bss
.bss:0000A310                 ;org 0A310h
.bss:0000A310                 assume es:nothing, ss:nothing, ds:_data, fs:nothing, gs:nothing
.bss:0000A310 __Tuple_alloc   db    ? ;
.bss:0000A311 ; std::_Ignore ignore
.bss:0000A311 _ignore         db    ? ;               ; DATA XREF: std::`dynamic initializer for 'ignore''(void)+3o
.bss:0000A312 _allocator_arg  db    ? ;
.bss:0000A313 _piecewise_construct db    ? ;
.bss:0000A313 _bss            ends
.bss:0000A313
.rdata:0000A314 ; ===========================================================================
.rdata:0000A314
.rdata:0000A314 ; Segment type: Pure data
.rdata:0000A314 ; Segment permissions: Read
.rdata:0000A314 ; Segment alignment 'qword' can not be represented in assembly
.rdata:0000A314 _rdata          segment para public 'DATA' use32
.rdata:0000A314                 assume cs:_rdata
.rdata:0000A314                 ;org 0A314h
.rdata:0000A314 ; COMDAT (pick any)
.rdata:0000A314                 public ??_C@_1JA@EADLBAJ@?$AAC?$AA?3?$AA?2?$AAP?$AAr?$AAo?$AAg?$AAr?$AAa?$AAm?$AA?5?$AAF?$AAi?$AAl?$AAe?$AAs?$AA?5?$AA?$CI?$AAx?$AA8?$AA6?$AA?$CJ?$AA?2?$AAM?$AAi?$AAc?$AAr?$AAo?$AAs?$AAo?$AAf?$AAt@
.rdata:0000A314 ; wchar_t `string'
.rdata:0000A314 ??_C@_1JA@EADLBAJ@?$AAC?$AA?3?$AA?2?$AAP?$AAr?$AAo?$AAg?$AAr?$AAa?$AAm?$AA?5?$AAF?$AAi?$AAl?$AAe?$AAs?$AA?5?$AA?$CI?$AAx?$AA8?$AA6?$AA?$CJ?$AA?2?$AAM?$AAi?$AAc?$AAr?$AAo?$AAs?$AAo?$AAf?$AAt@:
.rdata:0000A314                                         ; DATA XREF: std::_Iterator_base12::_Orphan_me(void)+48o
.rdata:0000A314                 unicode 0, <C:\Program Files (x86)\Microsoft Visual Studio 12.0\VC\in>
.rdata:0000A314                 unicode 0, <clude\xutility>,0
.rdata:0000A314 _rdata          ends
.rdata:0000A314
.rdata:0000A3A4 ; ===========================================================================
.rdata:0000A3A4
.rdata:0000A3A4 ; Segment type: Pure data
.rdata:0000A3A4 ; Segment permissions: Read
.rdata:0000A3A4 _rdata          segment dword public 'DATA' use32
.rdata:0000A3A4                 assume cs:_rdata
.rdata:0000A3A4                 ;org 0A3A4h
.rdata:0000A3A4 ; COMDAT (pick any)
.rdata:0000A3A4                 public ??_C@_1DC@POOIKBAO@?$AAI?$AAT?$AAE?$AAR?$AAA?$AAT?$AAO?$AAR?$AA?5?$AAL?$AAI?$AAS?$AAT?$AA?5?$AAC?$AAO?$AAR?$AAR?$AAU?$AAP?$AAT?$AAE?$AAD?$AA?$CB?$AA?$AA@
.rdata:0000A3A4 ; wchar_t `string'
.rdata:0000A3A4 ??_C@_1DC@POOIKBAO@?$AAI?$AAT?$AAE?$AAR?$AAA?$AAT?$AAO?$AAR?$AA?5?$AAL?$AAI?$AAS?$AAT?$AA?5?$AAC?$AAO?$AAR?$AAR?$AAU?$AAP?$AAT?$AAE?$AAD?$AA?$CB?$AA?$AA@:
.rdata:0000A3A4                                         ; DATA XREF: std::_Iterator_base12::_Orphan_me(void)+4Do
.rdata:0000A3A4                 unicode 0, <ITERATOR LIST CORRUPTED!>,0
.rdata:0000A3D6                 align 4
.rdata:0000A3D6 _rdata          ends
.rdata:0000A3D6
.rdata:0000A3D8 ; ===========================================================================
.rdata:0000A3D8
.rdata:0000A3D8 ; Segment type: Pure data
.rdata:0000A3D8 ; Segment permissions: Read
.rdata:0000A3D8 _rdata          segment dword public 'DATA' use32
.rdata:0000A3D8                 assume cs:_rdata
.rdata:0000A3D8                 ;org 0A3D8h
.rdata:0000A3D8 ; COMDAT (pick largest)
.rdata:0000A3D8                 dd offset ??_R4error_category@std@@6B@ ; const std::error_category::`RTTI Complete Object Locator'
.rdata:0000A3DC                 public ??_7error_category@std@@6B@
.rdata:0000A3DC ; const std::error_category::`vftable'
.rdata:0000A3DC ??_7error_category@std@@6B@ dd offset ??_Eerror_category@std@@UAEPAXI@Z
.rdata:0000A3DC                                         ; DATA XREF: std::error_category::error_category(void)+Ao
.rdata:0000A3DC                                         ; std::error_category::~error_category(void)+Ao
.rdata:0000A3DC                                         ; std::error_category::`vector deleting destructor'(uint)
.rdata:0000A3E0                 dd offset __purecall
.rdata:0000A3E4                 dd offset __purecall
.rdata:0000A3E8                 dd offset ?default_error_condition@error_category@std@@UBE?AVerror_condition@2@H@Z ; std::error_category::default_error_condition(int)
.rdata:0000A3EC                 dd offset ?equivalent@error_category@std@@UBE_NABVerror_code@2@H@Z ; std::error_category::equivalent(std::error_code const &,int)
.rdata:0000A3F0                 dd offset ?equivalent@error_category@std@@UBE_NHABVerror_condition@2@@Z ; std::error_category::equivalent(int,std::error_condition const &)
.rdata:0000A3F0 _rdata          ends
.rdata:0000A3F0
.rdata:0000A3F4 ; ===========================================================================
.rdata:0000A3F4
.rdata:0000A3F4 ; Segment type: Pure data
.rdata:0000A3F4 ; Segment permissions: Read
.rdata:0000A3F4 _rdata          segment dword public 'DATA' use32
.rdata:0000A3F4                 assume cs:_rdata
.rdata:0000A3F4                 ;org 0A3F4h
.rdata:0000A3F4 ; COMDAT (pick largest)
.rdata:0000A3F4                 dd offset ??_R4_Generic_error_category@std@@6B@ ; const std::_Generic_error_category::`RTTI Complete Object Locator'
.rdata:0000A3F8                 public ??_7_Generic_error_category@std@@6B@
.rdata:0000A3F8 ; const std::_Generic_error_category::`vftable'
.rdata:0000A3F8 ??_7_Generic_error_category@std@@6B@ dd offset ??_E_Generic_error_category@std@@UAEPAXI@Z
.rdata:0000A3F8                                         ; DATA XREF: std::_Generic_error_category::_Generic_error_category(void)+38o
.rdata:0000A3F8                                         ; std::_Generic_error_category::`vector deleting destructor'(uint)
.rdata:0000A3FC                 dd offset ?name@_Generic_error_category@std@@UBEPBDXZ ; std::_Generic_error_category::name(void)
.rdata:0000A400                 dd offset ?message@_Generic_error_category@std@@UBE?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@2@H@Z ; std::_Generic_error_category::message(int)
.rdata:0000A404                 dd offset ?default_error_condition@error_category@std@@UBE?AVerror_condition@2@H@Z ; std::error_category::default_error_condition(int)
.rdata:0000A408                 dd offset ?equivalent@error_category@std@@UBE_NABVerror_code@2@H@Z ; std::error_category::equivalent(std::error_code const &,int)
.rdata:0000A40C                 dd offset ?equivalent@error_category@std@@UBE_NHABVerror_condition@2@@Z ; std::error_category::equivalent(int,std::error_condition const &)
.rdata:0000A40C _rdata          ends
.rdata:0000A40C
.rdata:0000A410 ; ===========================================================================
.rdata:0000A410
.rdata:0000A410 ; Segment type: Pure data
.rdata:0000A410 ; Segment permissions: Read
.rdata:0000A410 _rdata          segment dword public 'DATA' use32
.rdata:0000A410                 assume cs:_rdata
.rdata:0000A410                 ;org 0A410h
.rdata:0000A410 ; COMDAT (pick any)
.rdata:0000A410                 public ??_C@_07DCLBNMLN@generic?$AA@
.rdata:0000A410 ; `string'
.rdata:0000A410 ??_C@_07DCLBNMLN@generic?$AA@ db 'generic',0
.rdata:0000A410                                         ; DATA XREF: std::_Generic_error_category::name(void)+7o
.rdata:0000A410 _rdata          ends
.rdata:0000A410
.rdata:0000A418 ; ===========================================================================
.rdata:0000A418
.rdata:0000A418 ; Segment type: Pure data
.rdata:0000A418 ; Segment permissions: Read
.rdata:0000A418 _rdata          segment dword public 'DATA' use32
.rdata:0000A418                 assume cs:_rdata
.rdata:0000A418                 ;org 0A418h
.rdata:0000A418 ; COMDAT (pick any)
.rdata:0000A418                 public ??_C@_0O@BFJCFAAK@unknown?5error?$AA@
.rdata:0000A418 ; `string'
.rdata:0000A418 ??_C@_0O@BFJCFAAK@unknown?5error?$AA@ db 'unknown error',0
.rdata:0000A418                                         ; DATA XREF: std::_Generic_error_category::message(int):loc_89F8o
.rdata:0000A418                                         ; std::_System_error_category::message(int):loc_8B74o
.rdata:0000A426                 align 4
.rdata:0000A426 _rdata          ends
.rdata:0000A426
.rdata:0000A428 ; ===========================================================================
.rdata:0000A428
.rdata:0000A428 ; Segment type: Pure data
.rdata:0000A428 ; Segment permissions: Read
.rdata:0000A428 _rdata          segment dword public 'DATA' use32
.rdata:0000A428                 assume cs:_rdata
.rdata:0000A428                 ;org 0A428h
.rdata:0000A428 ; COMDAT (pick largest)
.rdata:0000A428                 dd offset ??_R4_Iostream_error_category@std@@6B@ ; const std::_Iostream_error_category::`RTTI Complete Object Locator'
.rdata:0000A42C                 public ??_7_Iostream_error_category@std@@6B@
.rdata:0000A42C ; const std::_Iostream_error_category::`vftable'
.rdata:0000A42C ??_7_Iostream_error_category@std@@6B@ dd offset ??_E_Iostream_error_category@std@@UAEPAXI@Z
.rdata:0000A42C                                         ; DATA XREF: std::_Iostream_error_category::_Iostream_error_category(void)+38o
.rdata:0000A42C                                         ; std::_Iostream_error_category::`vector deleting destructor'(uint)
.rdata:0000A430                 dd offset ?name@_Iostream_error_category@std@@UBEPBDXZ ; std::_Iostream_error_category::name(void)
.rdata:0000A434                 dd offset ?message@_Iostream_error_category@std@@UBE?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@2@H@Z ; std::_Iostream_error_category::message(int)
.rdata:0000A438                 dd offset ?default_error_condition@error_category@std@@UBE?AVerror_condition@2@H@Z ; std::error_category::default_error_condition(int)
.rdata:0000A43C                 dd offset ?equivalent@error_category@std@@UBE_NABVerror_code@2@H@Z ; std::error_category::equivalent(std::error_code const &,int)
.rdata:0000A440                 dd offset ?equivalent@error_category@std@@UBE_NHABVerror_condition@2@@Z ; std::error_category::equivalent(int,std::error_condition const &)
.rdata:0000A440 _rdata          ends
.rdata:0000A440
.rdata:0000A444 ; ===========================================================================
.rdata:0000A444
.rdata:0000A444 ; Segment type: Pure data
.rdata:0000A444 ; Segment permissions: Read
.rdata:0000A444 _rdata          segment dword public 'DATA' use32
.rdata:0000A444                 assume cs:_rdata
.rdata:0000A444                 ;org 0A444h
.rdata:0000A444 ; COMDAT (pick any)
.rdata:0000A444                 public ??_C@_08LLGCOLLL@iostream?$AA@
.rdata:0000A444 ; `string'
.rdata:0000A444 ??_C@_08LLGCOLLL@iostream?$AA@ db 'iostream',0
.rdata:0000A444                                         ; DATA XREF: std::_Iostream_error_category::name(void)+7o
.rdata:0000A44D                 align 10h
.rdata:0000A44D _rdata          ends
.rdata:0000A44D
.rdata:0000A450 ; ===========================================================================
.rdata:0000A450
.rdata:0000A450 ; Segment type: Pure data
.rdata:0000A450 ; Segment permissions: Read
.rdata:0000A450 _rdata          segment dword public 'DATA' use32
.rdata:0000A450                 assume cs:_rdata
.rdata:0000A450                 ;org 0A450h
.rdata:0000A450 ; COMDAT (pick any)
.rdata:0000A450                 public ??_C@_0BG@PADBLCHM@iostream?5stream?5error?$AA@
.rdata:0000A450 ; char `string'[]
.rdata:0000A450 ??_C@_0BG@PADBLCHM@iostream?5stream?5error?$AA@ db 'iostream stream error',0
.rdata:0000A450                                         ; DATA XREF: std::_Iostream_error_category::message(int)+35o
.rdata:0000A466                 align 4
.rdata:0000A466 _rdata          ends
.rdata:0000A466
.rdata:0000A468 ; ===========================================================================
.rdata:0000A468
.rdata:0000A468 ; Segment type: Pure data
.rdata:0000A468 ; Segment permissions: Read
.rdata:0000A468 _rdata          segment dword public 'DATA' use32
.rdata:0000A468                 assume cs:_rdata
.rdata:0000A468                 ;org 0A468h
.rdata:0000A468 ; COMDAT (pick largest)
.rdata:0000A468                 dd offset ??_R4_System_error_category@std@@6B@ ; const std::_System_error_category::`RTTI Complete Object Locator'
.rdata:0000A46C                 public ??_7_System_error_category@std@@6B@
.rdata:0000A46C ; const std::_System_error_category::`vftable'
.rdata:0000A46C ??_7_System_error_category@std@@6B@ dd offset ??_E_System_error_category@std@@UAEPAXI@Z
.rdata:0000A46C                                         ; DATA XREF: std::_System_error_category::_System_error_category(void)+38o
.rdata:0000A46C                                         ; std::_System_error_category::`vector deleting destructor'(uint)
.rdata:0000A470                 dd offset ?name@_System_error_category@std@@UBEPBDXZ ; std::_System_error_category::name(void)
.rdata:0000A474                 dd offset ?message@_System_error_category@std@@UBE?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@2@H@Z ; std::_System_error_category::message(int)
.rdata:0000A478                 dd offset ?default_error_condition@_System_error_category@std@@UBE?AVerror_condition@2@H@Z ; std::_System_error_category::default_error_condition(int)
.rdata:0000A47C                 dd offset ?equivalent@error_category@std@@UBE_NABVerror_code@2@H@Z ; std::error_category::equivalent(std::error_code const &,int)
.rdata:0000A480                 dd offset ?equivalent@error_category@std@@UBE_NHABVerror_condition@2@@Z ; std::error_category::equivalent(int,std::error_condition const &)
.rdata:0000A480 _rdata          ends
.rdata:0000A480
.rdata:0000A484 ; ===========================================================================
.rdata:0000A484
.rdata:0000A484 ; Segment type: Pure data
.rdata:0000A484 ; Segment permissions: Read
.rdata:0000A484 _rdata          segment dword public 'DATA' use32
.rdata:0000A484                 assume cs:_rdata
.rdata:0000A484                 ;org 0A484h
.rdata:0000A484 ; COMDAT (pick any)
.rdata:0000A484                 public ??_C@_06FHFOAHML@system?$AA@
.rdata:0000A484 ; `string'
.rdata:0000A484 ??_C@_06FHFOAHML@system?$AA@ db 'system',0
.rdata:0000A484                                         ; DATA XREF: std::_System_error_category::name(void)+7o
.rdata:0000A48B                 align 4
.rdata:0000A48B _rdata          ends
.rdata:0000A48B
.bss:0000A48C ; ===========================================================================
.bss:0000A48C
.bss:0000A48C ; Segment type: Uninitialized
.bss:0000A48C ; Segment permissions: Read/Write
.bss:0000A48C _bss            segment dword public 'BSS' use32
.bss:0000A48C                 assume cs:_bss
.bss:0000A48C                 ;org 0A48Ch
.bss:0000A48C ; COMDAT (pick any)
.bss:0000A48C                 assume es:nothing, ss:nothing, ds:_data, fs:nothing, gs:nothing
.bss:0000A48C                 public ?_Generic_object@?$_Error_objects@H@std@@2V_Generic_error_category@2@A
.bss:0000A48C ; std::_Generic_error_category std::_Error_objects<int>::_Generic_object
.bss:0000A48C ?_Generic_object@?$_Error_objects@H@std@@2V_Generic_error_category@2@A db    ? ;
.bss:0000A48C                                         ; DATA XREF: `dynamic initializer for 'std::_Generic_error_category std::_Error_objects<int>::_Generic_object''(void)+3o
.bss:0000A48C                                         ; `dynamic atexit destructor for 'std::_Generic_error_category std::_Error_objects<int>::_Generic_object''(void)+3o ...
.bss:0000A48D                 db    ? ;
.bss:0000A48E                 db    ? ;
.bss:0000A48F                 db    ? ;
.bss:0000A48F _bss            ends
.bss:0000A48F
.bss:0000A490 ; ===========================================================================
.bss:0000A490
.bss:0000A490 ; Segment type: Uninitialized
.bss:0000A490 ; Segment permissions: Read/Write
.bss:0000A490 _bss            segment dword public 'BSS' use32
.bss:0000A490                 assume cs:_bss
.bss:0000A490                 ;org 0A490h
.bss:0000A490 ; COMDAT (pick any)
.bss:0000A490                 assume es:nothing, ss:nothing, ds:_data, fs:nothing, gs:nothing
.bss:0000A490                 public ?_Iostream_object@?$_Error_objects@H@std@@2V_Iostream_error_category@2@A
.bss:0000A490 ; std::_Iostream_error_category std::_Error_objects<int>::_Iostream_object
.bss:0000A490 ?_Iostream_object@?$_Error_objects@H@std@@2V_Iostream_error_category@2@A db    ? ;
.bss:0000A490                                         ; DATA XREF: `dynamic initializer for 'std::_Iostream_error_category std::_Error_objects<int>::_Iostream_object''(void)+3o
.bss:0000A490                                         ; `dynamic atexit destructor for 'std::_Iostream_error_category std::_Error_objects<int>::_Iostream_object''(void)+3o
.bss:0000A491                 db    ? ;
.bss:0000A492                 db    ? ;
.bss:0000A493                 db    ? ;
.bss:0000A493 _bss            ends
.bss:0000A493
.bss:0000A494 ; ===========================================================================
.bss:0000A494
.bss:0000A494 ; Segment type: Uninitialized
.bss:0000A494 ; Segment permissions: Read/Write
.bss:0000A494 _bss            segment dword public 'BSS' use32
.bss:0000A494                 assume cs:_bss
.bss:0000A494                 ;org 0A494h
.bss:0000A494 ; COMDAT (pick any)
.bss:0000A494                 assume es:nothing, ss:nothing, ds:_data, fs:nothing, gs:nothing
.bss:0000A494                 public ?_System_object@?$_Error_objects@H@std@@2V_System_error_category@2@A
.bss:0000A494 ; std::_System_error_category std::_Error_objects<int>::_System_object
.bss:0000A494 ?_System_object@?$_Error_objects@H@std@@2V_System_error_category@2@A db    ? ;
.bss:0000A494                                         ; DATA XREF: `dynamic initializer for 'std::_System_error_category std::_Error_objects<int>::_System_object''(void)+3o
.bss:0000A494                                         ; `dynamic atexit destructor for 'std::_System_error_category std::_Error_objects<int>::_System_object''(void)+3o ...
.bss:0000A495                 db    ? ;
.bss:0000A496                 db    ? ;
.bss:0000A497                 db    ? ;
.bss:0000A497 _bss            ends
.bss:0000A497
.bss:0000A498 ; ===========================================================================
.bss:0000A498
.bss:0000A498 ; Segment type: Uninitialized
.bss:0000A498 ; Segment permissions: Read/Write
.bss:0000A498 _bss            segment dword public 'BSS' use32
.bss:0000A498                 assume cs:_bss
.bss:0000A498                 ;org 0A498h
.bss:0000A498 ; COMDAT (pick any)
.bss:0000A498                 assume es:nothing, ss:nothing, ds:_data, fs:nothing, gs:nothing
.bss:0000A498                 public ?id@?$num_put@DV?$back_insert_iterator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@std@@2V0locale@2@A
.bss:0000A498 ; std::locale::id std::num_put<char,std::back_insert_iterator<std::basic_string<char,std::char_traits<char>,std::allocator<char>>>>::id
.bss:0000A498 ?id@?$num_put@DV?$back_insert_iterator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@std@@2V0locale@2@A db    ? ;
.bss:0000A498                                         ; DATA XREF: `dynamic initializer for 'std::locale::id std::num_put<char,std::back_insert_iterator<std::basic_string<char,std::char_traits<char>,std::allocator<char>>>>::id''(void)+5o
.bss:0000A499                 db    ? ;
.bss:0000A49A                 db    ? ;
.bss:0000A49B                 db    ? ;
.bss:0000A49B _bss            ends
.bss:0000A49B
.bss:0000A49C ; ===========================================================================
.bss:0000A49C
.bss:0000A49C ; Segment type: Uninitialized
.bss:0000A49C ; Segment permissions: Read/Write
.bss:0000A49C _bss            segment dword public 'BSS' use32
.bss:0000A49C                 assume cs:_bss
.bss:0000A49C                 ;org 0A49Ch
.bss:0000A49C ; COMDAT (pick any)
.bss:0000A49C                 assume es:nothing, ss:nothing, ds:_data, fs:nothing, gs:nothing
.bss:0000A49C                 public ?id@?$num_put@_WV?$back_insert_iterator@V?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@@std@@@std@@2V0locale@2@A
.bss:0000A49C ; std::locale::id std::num_put<wchar_t,std::back_insert_iterator<std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>>>>::id
.bss:0000A49C ?id@?$num_put@_WV?$back_insert_iterator@V?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@@std@@@std@@2V0locale@2@A db    ? ;
.bss:0000A49C                                         ; DATA XREF: `dynamic initializer for 'std::locale::id std::num_put<wchar_t,std::back_insert_iterator<std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>>>>::id''(void)+5o
.bss:0000A49D                 db    ? ;
.bss:0000A49E                 db    ? ;
.bss:0000A49F                 db    ? ;
.bss:0000A49F _bss            ends
.bss:0000A49F
.rdata:0000A4A0 ; ===========================================================================
.rdata:0000A4A0
.rdata:0000A4A0 ; Segment type: Pure data
.rdata:0000A4A0 ; Segment permissions: Read
.rdata:0000A4A0 ; Segment alignment 'qword' can not be represented in assembly
.rdata:0000A4A0 _rdata          segment para public 'DATA' use32
.rdata:0000A4A0                 assume cs:_rdata
.rdata:0000A4A0                 ;org 0A4A0h
.rdata:0000A4A0 ; COMDAT (pick any)
.rdata:0000A4A0                 public ??_C@_1IO@FEAPGJBD@?$AAC?$AA?3?$AA?2?$AAP?$AAr?$AAo?$AAg?$AAr?$AAa?$AAm?$AA?5?$AAF?$AAi?$AAl?$AAe?$AAs?$AA?5?$AA?$CI?$AAx?$AA8?$AA6?$AA?$CJ?$AA?2?$AAM?$AAi?$AAc?$AAr?$AAo?$AAs?$AAo?$AAf?$AAt@
.rdata:0000A4A0 ; wchar_t `string'
.rdata:0000A4A0 ??_C@_1IO@FEAPGJBD@?$AAC?$AA?3?$AA?2?$AAP?$AAr?$AAo?$AAg?$AAr?$AAa?$AAm?$AA?5?$AAF?$AAi?$AAl?$AAe?$AAs?$AA?5?$AA?$CI?$AAx?$AA8?$AA6?$AA?$CJ?$AA?2?$AAM?$AAi?$AAc?$AAr?$AAo?$AAs?$AAo?$AAf?$AAt@:
.rdata:0000A4A0                                         ; DATA XREF: std::basic_string<char,std::char_traits<char>,std::allocator<char>>::assign(char const *)+Co
.rdata:0000A4A0                                         ; std::basic_string<char,std::char_traits<char>,std::allocator<char>>::assign(char const *,uint)+12o
.rdata:0000A4A0                 unicode 0, <C:\Program Files (x86)\Microsoft Visual Studio 12.0\VC\in>
.rdata:0000A4A0                 unicode 0, <clude\xstring>,0
.rdata:0000A52E                 align 10h
.rdata:0000A52E _rdata          ends
.rdata:0000A52E
.bss:0000A530 ; ===========================================================================
.bss:0000A530
.bss:0000A530 ; Segment type: Uninitialized
.bss:0000A530 ; Segment permissions: Read/Write
.bss:0000A530 _bss            segment dword public 'BSS' use32
.bss:0000A530                 assume cs:_bss
.bss:0000A530                 ;org 0A530h
.bss:0000A530 ; COMDAT (pick any)
.bss:0000A530                 assume es:nothing, ss:nothing, ds:_data, fs:nothing, gs:nothing
.bss:0000A530                 public ?id@?$numpunct@D@std@@2V0locale@2@A
.bss:0000A530 ; std::locale::id std::numpunct<char>::id
.bss:0000A530 ?id@?$numpunct@D@std@@2V0locale@2@A db    ? ;
.bss:0000A530                                         ; DATA XREF: `dynamic initializer for 'std::locale::id std::numpunct<char>::id''(void)+5o
.bss:0000A531                 db    ? ;
.bss:0000A532                 db    ? ;
.bss:0000A533                 db    ? ;
.bss:0000A533 _bss            ends
.bss:0000A533
.bss:0000A534 ; ===========================================================================
.bss:0000A534
.bss:0000A534 ; Segment type: Uninitialized
.bss:0000A534 ; Segment permissions: Read/Write
.bss:0000A534 _bss            segment dword public 'BSS' use32
.bss:0000A534                 assume cs:_bss
.bss:0000A534                 ;org 0A534h
.bss:0000A534 ; COMDAT (pick any)
.bss:0000A534                 assume es:nothing, ss:nothing, ds:_data, fs:nothing, gs:nothing
.bss:0000A534                 public ?id@?$numpunct@_W@std@@2V0locale@2@A
.bss:0000A534 ; std::locale::id std::numpunct<wchar_t>::id
.bss:0000A534 ?id@?$numpunct@_W@std@@2V0locale@2@A db    ? ;
.bss:0000A534                                         ; DATA XREF: `dynamic initializer for 'std::locale::id std::numpunct<wchar_t>::id''(void)+5o
.bss:0000A535                 db    ? ;
.bss:0000A536                 db    ? ;
.bss:0000A537                 db    ? ;
.bss:0000A537 _bss            ends
.bss:0000A537
.rdata:0000A538 ; ===========================================================================
.rdata:0000A538
.rdata:0000A538 ; Segment type: Pure data
.rdata:0000A538 ; Segment permissions: Read
.rdata:0000A538 ; Segment alignment 'qword' can not be represented in assembly
.rdata:0000A538 _rdata          segment para public 'DATA' use32
.rdata:0000A538                 assume cs:_rdata
.rdata:0000A538                 ;org 0A538h
.rdata:0000A538 ; COMDAT (pick any)
.rdata:0000A538                 public ??_C@_1IM@EINEHPHE@?$AAC?$AA?3?$AA?2?$AAP?$AAr?$AAo?$AAg?$AAr?$AAa?$AAm?$AA?5?$AAF?$AAi?$AAl?$AAe?$AAs?$AA?5?$AA?$CI?$AAx?$AA8?$AA6?$AA?$CJ?$AA?2?$AAM?$AAi?$AAc?$AAr?$AAo?$AAs?$AAo?$AAf?$AAt@
.rdata:0000A538 ; wchar_t `string'
.rdata:0000A538 ??_C@_1IM@EINEHPHE@?$AAC?$AA?3?$AA?2?$AAP?$AAr?$AAo?$AAg?$AAr?$AAa?$AAm?$AA?5?$AAF?$AAi?$AAl?$AAe?$AAs?$AA?5?$AA?$CI?$AAx?$AA8?$AA6?$AA?$CJ?$AA?2?$AAM?$AAi?$AAc?$AAr?$AAo?$AAs?$AAo?$AAf?$AAt@:
.rdata:0000A538                                         ; DATA XREF: std::_Vector_const_iterator<std::_Vector_val<std::_Simple_types<FunctionValues>>>::operator*(void)+44o
.rdata:0000A538                                         ; std::_Vector_const_iterator<std::_Vector_val<std::_Simple_types<FunctionValues>>>::operator*(void)+71o ...
.rdata:0000A538                 unicode 0, <C:\Program Files (x86)\Microsoft Visual Studio 12.0\VC\in>
.rdata:0000A538                 unicode 0, <clude\vector>,0
.rdata:0000A538 _rdata          ends
.rdata:0000A538
.rdata:0000A5C4 ; ===========================================================================
.rdata:0000A5C4
.rdata:0000A5C4 ; Segment type: Pure data
.rdata:0000A5C4 ; Segment permissions: Read
.rdata:0000A5C4 _rdata          segment dword public 'DATA' use32
.rdata:0000A5C4                 assume cs:_rdata
.rdata:0000A5C4                 ;org 0A5C4h
.rdata:0000A5C4 ; COMDAT (pick any)
.rdata:0000A5C4                 public ??_C@_0CE@OFMIGAMM@Standard?5C?$CL?$CL?5Libraries?5Out?5of?5Ra@
.rdata:0000A5C4 ; `string'
.rdata:0000A5C4 ??_C@_0CE@OFMIGAMM@Standard?5C?$CL?$CL?5Libraries?5Out?5of?5Ra@ db 'Standard C++ Libraries Out of Range',0
.rdata:0000A5C4                                         ; DATA XREF: std::_Vector_const_iterator<std::_Vector_val<std::_Simple_types<FunctionValues>>>::operator*(void)+56o
.rdata:0000A5C4                                         ; std::_Vector_const_iterator<std::_Vector_val<std::_Simple_types<FunctionValues>>>::operator+=(int)+5Do
.rdata:0000A5C4 _rdata          ends
.rdata:0000A5C4
.rdata:0000A5E8 ; ===========================================================================
.rdata:0000A5E8
.rdata:0000A5E8 ; Segment type: Pure data
.rdata:0000A5E8 ; Segment permissions: Read
.rdata:0000A5E8 ; Segment alignment 'qword' can not be represented in assembly
.rdata:0000A5E8 _rdata          segment para public 'DATA' use32
.rdata:0000A5E8                 assume cs:_rdata
.rdata:0000A5E8                 ;org 0A5E8h
.rdata:0000A5E8 ; COMDAT (pick any)
.rdata:0000A5E8                 public ??_C@_1FG@IBPIFFN@?$AA?$CC?$AAS?$AAt?$AAa?$AAn?$AAd?$AAa?$AAr?$AAd?$AA?5?$AAC?$AA?$CL?$AA?$CL?$AA?5?$AAL?$AAi?$AAb?$AAr?$AAa?$AAr?$AAi?$AAe?$AAs?$AA?5?$AAO?$AAu?$AAt?$AA?5?$AAo?$AAf?$AA?5?$AAR@
.rdata:0000A5E8 ; `string'
.rdata:0000A5E8 ??_C@_1FG@IBPIFFN@?$AA?$CC?$AAS?$AAt?$AAa?$AAn?$AAd?$AAa?$AAr?$AAd?$AA?5?$AAC?$AA?$CL?$AA?$CL?$AA?5?$AAL?$AAi?$AAb?$AAr?$AAa?$AAr?$AAi?$AAe?$AAs?$AA?5?$AAO?$AAu?$AAt?$AA?5?$AAo?$AAf?$AA?5?$AAR@:
.rdata:0000A5E8                                         ; DATA XREF: std::_Vector_const_iterator<std::_Vector_val<std::_Simple_types<FunctionValues>>>::operator*(void):loc_5A2Bo
.rdata:0000A5E8                                         ; std::_Vector_const_iterator<std::_Vector_val<std::_Simple_types<FunctionValues>>>::operator+=(int):loc_5BAEo
.rdata:0000A5E8                 unicode 0, <"Standard C++ Libraries Out of Range" && 0>,0
.rdata:0000A63E                 align 10h
.rdata:0000A63E _rdata          ends
.rdata:0000A63E
.rdata:0000A640 ; ===========================================================================
.rdata:0000A640
.rdata:0000A640 ; Segment type: Pure data
.rdata:0000A640 ; Segment permissions: Read
.rdata:0000A640 _rdata          segment dword public 'DATA' use32
.rdata:0000A640                 assume cs:_rdata
.rdata:0000A640                 ;org 0A640h
.rdata:0000A640 ; COMDAT (pick any)
.rdata:0000A640                 public ??_C@_15GANGMFKL@?$AA?$CF?$AAs?$AA?$AA@
.rdata:0000A640 ; `string'
.rdata:0000A640 ??_C@_15GANGMFKL@?$AA?$CF?$AAs?$AA?$AA@:
.rdata:0000A640                                         ; DATA XREF: std::_Vector_const_iterator<std::_Vector_val<std::_Simple_types<FunctionValues>>>::operator*(void)+68o
.rdata:0000A640                                         ; std::_Vector_const_iterator<std::_Vector_val<std::_Simple_types<FunctionValues>>>::operator+=(int)+6Fo
.rdata:0000A640                 unicode 0, <%s>,0
.rdata:0000A646                 align 4
.rdata:0000A646 _rdata          ends
.rdata:0000A646
.rdata:0000A648 ; ===========================================================================
.rdata:0000A648
.rdata:0000A648 ; Segment type: Pure data
.rdata:0000A648 ; Segment permissions: Read
.rdata:0000A648 _rdata          segment dword public 'DATA' use32
.rdata:0000A648                 assume cs:_rdata
.rdata:0000A648                 ;org 0A648h
.rdata:0000A648 ; COMDAT (pick any)
.rdata:0000A648                 public ??_C@_1BO@MEPPHOO@?$AA?$CC?$AAo?$AAu?$AAt?$AA?5?$AAo?$AAf?$AA?5?$AAr?$AAa?$AAn?$AAg?$AAe?$AA?$CC?$AA?$AA@
.rdata:0000A648 ; `string'
.rdata:0000A648 ??_C@_1BO@MEPPHOO@?$AA?$CC?$AAo?$AAu?$AAt?$AA?5?$AAo?$AAf?$AA?5?$AAr?$AAa?$AAn?$AAg?$AAe?$AA?$CC?$AA?$AA@:
.rdata:0000A648                                         ; DATA XREF: std::_Vector_const_iterator<std::_Vector_val<std::_Simple_types<FunctionValues>>>::operator*(void)+94o
.rdata:0000A648                                         ; std::_Vector_const_iterator<std::_Vector_val<std::_Simple_types<FunctionValues>>>::operator+=(int)+A1o
.rdata:0000A648                 unicode 0, <"out of range">,0
.rdata:0000A666                 align 4
.rdata:0000A666 _rdata          ends
.rdata:0000A666
.rdata:0000A668 ; ===========================================================================
.rdata:0000A668
.rdata:0000A668 ; Segment type: Pure data
.rdata:0000A668 ; Segment permissions: Read
.rdata:0000A668 _rdata          segment dword public 'DATA' use32
.rdata:0000A668                 assume cs:_rdata
.rdata:0000A668                 ;org 0A668h
.rdata:0000A668 ; COMDAT (pick any)
.rdata:0000A668                 public ??_C@_1DA@JIKEAPDO@?$AAv?$AAe?$AAc?$AAt?$AAo?$AAr?$AA?5?$AAe?$AAm?$AAp?$AAt?$AAy?$AA?5?$AAb?$AAe?$AAf?$AAo?$AAr?$AAe?$AA?5?$AAp?$AAo?$AAp?$AA?$AA@
.rdata:0000A668 ; wchar_t `string'
.rdata:0000A668 ??_C@_1DA@JIKEAPDO@?$AAv?$AAe?$AAc?$AAt?$AAo?$AAr?$AA?5?$AAe?$AAm?$AAp?$AAt?$AAy?$AA?5?$AAb?$AAe?$AAf?$AAo?$AAr?$AAe?$AA?5?$AAp?$AAo?$AAp?$AA?$AA@:
.rdata:0000A668                                         ; DATA XREF: std::vector<FunctionValues,std::allocator<FunctionValues>>::pop_back(void)+22o
.rdata:0000A668                 unicode 0, <vector empty before pop>,0
.rdata:0000A668 _rdata          ends
.rdata:0000A668
.rdata:0000A698 ; ===========================================================================
.rdata:0000A698
.rdata:0000A698 ; Segment type: Pure data
.rdata:0000A698 ; Segment permissions: Read
.rdata:0000A698 _rdata          segment dword public 'DATA' use32
.rdata:0000A698                 assume cs:_rdata
.rdata:0000A698                 ;org 0A698h
.rdata:0000A698 ; COMDAT (pick any)
.rdata:0000A698                 public ??_C@_0BM@NMJKDPPO@invalid?5vector?$DMT?$DO?5subscript?$AA@
.rdata:0000A698 ; char `string'[]
.rdata:0000A698 ??_C@_0BM@NMJKDPPO@invalid?5vector?$DMT?$DO?5subscript?$AA@ db 'invalid vector<T> subscript',0
.rdata:0000A698                                         ; DATA XREF: std::vector<wchar_t const *,std::allocator<wchar_t const *>>::_Xran(void)+7o
.rdata:0000A698                                         ; std::vector<Token,std::allocator<Token>>::_Xran(void)+7o ...
.rdata:0000A698 _rdata          ends
.rdata:0000A698
.rdata:0000A6B4 ; ===========================================================================
.rdata:0000A6B4
.rdata:0000A6B4 ; Segment type: Pure data
.rdata:0000A6B4 ; Segment permissions: Read
.rdata:0000A6B4 _rdata          segment dword public 'DATA' use32
.rdata:0000A6B4                 assume cs:_rdata
.rdata:0000A6B4                 ;org 0A6B4h
.rdata:0000A6B4 ; COMDAT (pick any)
.rdata:0000A6B4                 public ??_C@_0BA@JFNIOLAK@string?5too?5long?$AA@
.rdata:0000A6B4 ; char `string'[]
.rdata:0000A6B4 ??_C@_0BA@JFNIOLAK@string?5too?5long?$AA@ db 'string too long',0
.rdata:0000A6B4                                         ; DATA XREF: std::basic_string<char,std::char_traits<char>,std::allocator<char>>::_Xlen(void)+7o
.rdata:0000A6B4 _rdata          ends
.rdata:0000A6B4
.rdata:0000A6C4 ; ===========================================================================
.rdata:0000A6C4
.rdata:0000A6C4 ; Segment type: Pure data
.rdata:0000A6C4 ; Segment permissions: Read
.rdata:0000A6C4 _rdata          segment dword public 'DATA' use32
.rdata:0000A6C4                 assume cs:_rdata
.rdata:0000A6C4                 ;org 0A6C4h
.rdata:0000A6C4 ; COMDAT (pick any)
.rdata:0000A6C4                 public ??_C@_0BI@CFPLBAOH@invalid?5string?5position?$AA@
.rdata:0000A6C4 ; char `string'[]
.rdata:0000A6C4 ??_C@_0BI@CFPLBAOH@invalid?5string?5position?$AA@ db 'invalid string position',0
.rdata:0000A6C4                                         ; DATA XREF: std::basic_string<char,std::char_traits<char>,std::allocator<char>>::_Xran(void)+7o
.rdata:0000A6C4 _rdata          ends
.rdata:0000A6C4
.rdata:0000A6DC ; ===========================================================================
.rdata:0000A6DC
.rdata:0000A6DC ; Segment type: Pure data
.rdata:0000A6DC ; Segment permissions: Read
.rdata:0000A6DC _rdata          segment dword public 'DATA' use32
.rdata:0000A6DC                 assume cs:_rdata
.rdata:0000A6DC                 ;org 0A6DCh
.rdata:0000A6DC ; COMDAT (pick any)
.rdata:0000A6DC                 public ??_C@_0BD@OLBABOEK@vector?$DMT?$DO?5too?5long?$AA@
.rdata:0000A6DC ; char `string'[]
.rdata:0000A6DC ??_C@_0BD@OLBABOEK@vector?$DMT?$DO?5too?5long?$AA@ db 'vector<T> too long',0
.rdata:0000A6DC                                         ; DATA XREF: std::vector<wchar_t const *,std::allocator<wchar_t const *>>::_Xlen(void)+7o
.rdata:0000A6DC                                         ; std::vector<FunctionValues,std::allocator<FunctionValues>>::_Xlen(void)+7o ...
.rdata:0000A6EF                 align 10h
.rdata:0000A6EF _rdata          ends
.rdata:0000A6EF
.rdata:0000A6F0 ; ===========================================================================
.rdata:0000A6F0
.rdata:0000A6F0 ; Segment type: Pure data
.rdata:0000A6F0 ; Segment permissions: Read
.rdata:0000A6F0 ; Segment alignment 'qword' can not be represented in assembly
.rdata:0000A6F0 _rdata          segment para public 'DATA' use32
.rdata:0000A6F0                 assume cs:_rdata
.rdata:0000A6F0                 ;org 0A6F0h
.rdata:0000A6F0 ; COMDAT (pick any)
.rdata:0000A6F0                 public ??_C@_1EM@FKAOCOMF@?$AAv?$AAe?$AAc?$AAt?$AAo?$AAr?$AA?5?$AAi?$AAt?$AAe?$AAr?$AAa?$AAt?$AAo?$AAr?$AA?5?$AA?$CL?$AA?5?$AAo?$AAf?$AAf?$AAs?$AAe?$AAt?$AA?5?$AAo?$AAu?$AAt?$AA?5?$AAo?$AAf?$AA?5@
.rdata:0000A6F0 ; wchar_t `string'
.rdata:0000A6F0 ??_C@_1EM@FKAOCOMF@?$AAv?$AAe?$AAc?$AAt?$AAo?$AAr?$AA?5?$AAi?$AAt?$AAe?$AAr?$AAa?$AAt?$AAo?$AAr?$AA?5?$AA?$CL?$AA?5?$AAo?$AAf?$AAf?$AAs?$AAe?$AAt?$AA?5?$AAo?$AAu?$AAt?$AA?5?$AAo?$AAf?$AA?5@:
.rdata:0000A6F0                                         ; DATA XREF: std::_Vector_const_iterator<std::_Vector_val<std::_Simple_types<FunctionValues>>>::operator+=(int)+50o
.rdata:0000A6F0                 unicode 0, <vector iterator + offset out of range>,0
.rdata:0000A6F0 _rdata          ends
.rdata:0000A6F0
.rdata:0000A73C ; ===========================================================================
.rdata:0000A73C
.rdata:0000A73C ; Segment type: Pure data
.rdata:0000A73C ; Segment permissions: Read
.rdata:0000A73C ; Segment alignment 'qword' can not be represented in assembly
.rdata:0000A73C _rdata          segment para public 'DATA' use32
.rdata:0000A73C                 assume cs:_rdata
.rdata:0000A73C                 ;org 0A73Ch
.rdata:0000A73C ; COMDAT (pick any)
.rdata:0000A73C                 public ??_C@_1EG@FOHJJHAC@?$AAv?$AAe?$AAc?$AAt?$AAo?$AAr?$AA?5?$AAi?$AAt?$AAe?$AAr?$AAa?$AAt?$AAo?$AAr?$AA?5?$AAn?$AAo?$AAt?$AA?5?$AAd?$AAe?$AAr?$AAe?$AAf?$AAe?$AAr?$AAe?$AAn?$AAc?$AAa?$AAb@
.rdata:0000A73C ; wchar_t `string'
.rdata:0000A73C ??_C@_1EG@FOHJJHAC@?$AAv?$AAe?$AAc?$AAt?$AAo?$AAr?$AA?5?$AAi?$AAt?$AAe?$AAr?$AAa?$AAt?$AAo?$AAr?$AA?5?$AAn?$AAo?$AAt?$AA?5?$AAd?$AAe?$AAr?$AAe?$AAf?$AAe?$AAr?$AAe?$AAn?$AAc?$AAa?$AAb@:
.rdata:0000A73C                                         ; DATA XREF: std::_Vector_const_iterator<std::_Vector_val<std::_Simple_types<FunctionValues>>>::operator*(void)+49o
.rdata:0000A73C                 unicode 0, <vector iterator not dereferencable>,0
.rdata:0000A782                 align 4
.rdata:0000A782 _rdata          ends
.rdata:0000A782
.rdata:0000A784 ; ===========================================================================
.rdata:0000A784
.rdata:0000A784 ; Segment type: Pure data
.rdata:0000A784 ; Segment permissions: Read
.rdata:0000A784 ; Segment alignment 'qword' can not be represented in assembly
.rdata:0000A784 _rdata          segment para public 'DATA' use32
.rdata:0000A784                 assume cs:_rdata
.rdata:0000A784                 ;org 0A784h
.rdata:0000A784 ; COMDAT (pick any)
.rdata:0000A784                 public ??_C@_1OI@FONGOOEE@?$AAs?$AAt?$AAd?$AA?3?$AA?3?$AA_?$AAV?$AAe?$AAc?$AAt?$AAo?$AAr?$AA_?$AAc?$AAo?$AAn?$AAs?$AAt?$AA_?$AAi?$AAt?$AAe?$AAr?$AAa?$AAt?$AAo?$AAr?$AA?$DM?$AAc?$AAl?$AAa?$AAs@
.rdata:0000A784 ; `string'
.rdata:0000A784 ??_C@_1OI@FONGOOEE@?$AAs?$AAt?$AAd?$AA?3?$AA?3?$AA_?$AAV?$AAe?$AAc?$AAt?$AAo?$AAr?$AA_?$AAc?$AAo?$AAn?$AAs?$AAt?$AA_?$AAi?$AAt?$AAe?$AAr?$AAa?$AAt?$AAo?$AAr?$AA?$DM?$AAc?$AAl?$AAa?$AAs@:
.rdata:0000A784                                         ; DATA XREF: std::_Vector_const_iterator<std::_Vector_val<std::_Simple_types<FunctionValues>>>::operator*(void)+8Fo
.rdata:0000A784                 unicode 0, <std::_Vector_const_iterator>
.rdata:0000A784                 dw 3Ch
.rdata:0000A784                 unicode 0, <class std::_Vector_val>
.rdata:0000A784                 dw 3Ch
.rdata:0000A784                 unicode 0, <struct std::_Simple_types>
.rdata:0000A784                 dw 3Ch
.rdata:0000A784                 unicode 0, <struct FunctionValues>
.rdata:0000A784                 dw 3Eh
.rdata:0000A784                 unicode 0, < >
.rdata:0000A784                 dw 3Eh
.rdata:0000A784                 unicode 0, < >
.rdata:0000A784                 dw 3Eh
.rdata:0000A784                 unicode 0, <::operator *>,0
.rdata:0000A784 _rdata          ends
.rdata:0000A784
.rdata:0000A86C ; ===========================================================================
.rdata:0000A86C
.rdata:0000A86C ; Segment type: Pure data
.rdata:0000A86C ; Segment permissions: Read
.rdata:0000A86C ; Segment alignment 'qword' can not be represented in assembly
.rdata:0000A86C _rdata          segment para public 'DATA' use32
.rdata:0000A86C                 assume cs:_rdata
.rdata:0000A86C                 ;org 0A86Ch
.rdata:0000A86C ; COMDAT (pick any)
.rdata:0000A86C                 public ??_C@_1OK@BKLKOIHB@?$AAs?$AAt?$AAd?$AA?3?$AA?3?$AA_?$AAV?$AAe?$AAc?$AAt?$AAo?$AAr?$AA_?$AAc?$AAo?$AAn?$AAs?$AAt?$AA_?$AAi?$AAt?$AAe?$AAr?$AAa?$AAt?$AAo?$AAr?$AA?$DM?$AAc?$AAl?$AAa?$AAs@
.rdata:0000A86C ; `string'
.rdata:0000A86C ??_C@_1OK@BKLKOIHB@?$AAs?$AAt?$AAd?$AA?3?$AA?3?$AA_?$AAV?$AAe?$AAc?$AAt?$AAo?$AAr?$AA_?$AAc?$AAo?$AAn?$AAs?$AAt?$AA_?$AAi?$AAt?$AAe?$AAr?$AAa?$AAt?$AAo?$AAr?$AA?$DM?$AAc?$AAl?$AAa?$AAs@:
.rdata:0000A86C                                         ; DATA XREF: std::_Vector_const_iterator<std::_Vector_val<std::_Simple_types<FunctionValues>>>::operator+=(int)+9Co
.rdata:0000A86C                 unicode 0, <std::_Vector_const_iterator>
.rdata:0000A86C                 dw 3Ch
.rdata:0000A86C                 unicode 0, <class std::_Vector_val>
.rdata:0000A86C                 dw 3Ch
.rdata:0000A86C                 unicode 0, <struct std::_Simple_types>
.rdata:0000A86C                 dw 3Ch
.rdata:0000A86C                 unicode 0, <struct FunctionValues>
.rdata:0000A86C                 dw 3Eh
.rdata:0000A86C                 unicode 0, < >
.rdata:0000A86C                 dw 3Eh
.rdata:0000A86C                 unicode 0, < >
.rdata:0000A86C                 dw 3Eh
.rdata:0000A86C                 unicode 0, <::operator +=>,0
.rdata:0000A956                 align 4
.rdata:0000A956 _rdata          ends
.rdata:0000A956
.rdata:0000A958 ; ===========================================================================
.rdata:0000A958
.rdata:0000A958 ; Segment type: Pure data
.rdata:0000A958 ; Segment permissions: Read
.rdata:0000A958 _rdata          segment dword public 'DATA' use32
.rdata:0000A958                 assume cs:_rdata
.rdata:0000A958                 ;org 0A958h
.rdata:0000A958 ; COMDAT (pick any)
.rdata:0000A958                 public ??_C@_1CK@EOPGIILJ@?$AAi?$AAn?$AAv?$AAa?$AAl?$AAi?$AAd?$AA?5?$AAn?$AAu?$AAl?$AAl?$AA?5?$AAp?$AAo?$AAi?$AAn?$AAt?$AAe?$AAr?$AA?$AA@
.rdata:0000A958 ; wchar_t `string'
.rdata:0000A958 ??_C@_1CK@EOPGIILJ@?$AAi?$AAn?$AAv?$AAa?$AAl?$AAi?$AAd?$AA?5?$AAn?$AAu?$AAl?$AAl?$AA?5?$AAp?$AAo?$AAi?$AAn?$AAt?$AAe?$AAr?$AA?$AA@:
.rdata:0000A958                                         ; DATA XREF: std::_Debug_pointer<char>(char const *,wchar_t const *,uint)+11o
.rdata:0000A958                                         ; std::_Debug_pointer<wchar_t const *>(wchar_t const * *,wchar_t const *,uint)+11o ...
.rdata:0000A958                 unicode 0, <invalid null pointer>,0
.rdata:0000A982                 align 4
.rdata:0000A982 _rdata          ends
.rdata:0000A982
.rdata:0000A984 ; ===========================================================================
.rdata:0000A984
.rdata:0000A984 ; Segment type: Pure data
.rdata:0000A984 ; Segment permissions: Read
.rdata:0000A984 _rdata          segment dword public 'DATA' use32
.rdata:0000A984                 assume cs:_rdata
.rdata:0000A984                 ;org 0A984h
.rdata:0000A984 ; COMDAT (pick any)
.rdata:0000A984                 public ??_C@_1CO@DGLIKNHI@?$AAi?$AAn?$AAv?$AAa?$AAl?$AAi?$AAd?$AA?5?$AAi?$AAt?$AAe?$AAr?$AAa?$AAt?$AAo?$AAr?$AA?5?$AAr?$AAa?$AAn?$AAg?$AAe?$AA?$AA@
.rdata:0000A984 ; wchar_t `string'
.rdata:0000A984 ??_C@_1CO@DGLIKNHI@?$AAi?$AAn?$AAv?$AAa?$AAl?$AAi?$AAd?$AA?5?$AAi?$AAt?$AAe?$AAr?$AAa?$AAt?$AAo?$AAr?$AA?5?$AAr?$AAa?$AAn?$AAg?$AAe?$AA?$AA@:
.rdata:0000A984                                         ; DATA XREF: std::_Debug_range2<wchar_t const * *>(wchar_t const * *,wchar_t const * *,wchar_t const *,uint,std::random_access_iterator_tag)+43o
.rdata:0000A984                                         ; std::_Debug_range2<FunctionValues *>(FunctionValues *,FunctionValues *,wchar_t const *,uint,std::random_access_iterator_tag)+43o ...
.rdata:0000A984                 unicode 0, <invalid iterator range>,0
.rdata:0000A9B2                 align 4
.rdata:0000A9B2 _rdata          ends
.rdata:0000A9B2
.rdata:0000A9B4 ; ===========================================================================
.rdata:0000A9B4
.rdata:0000A9B4 ; Segment type: Pure data
.rdata:0000A9B4 ; Segment permissions: Read
.rdata:0000A9B4 ; Segment alignment 'qword' can not be represented in assembly
.rdata:0000A9B4 _rdata          segment para public 'DATA' use32
.rdata:0000A9B4                 assume cs:_rdata
.rdata:0000A9B4                 ;org 0A9B4h
.rdata:0000A9B4 ; COMDAT (pick any)
.rdata:0000A9B4                 public ??_C@_1IO@LKIDJAMC@?$AAC?$AA?3?$AA?2?$AAP?$AAr?$AAo?$AAg?$AAr?$AAa?$AAm?$AA?5?$AAF?$AAi?$AAl?$AAe?$AAs?$AA?5?$AA?$CI?$AAx?$AA8?$AA6?$AA?$CJ?$AA?2?$AAM?$AAi?$AAc?$AAr?$AAo?$AAs?$AAo?$AAf?$AAt@
.rdata:0000A9B4 ; wchar_t `string'
.rdata:0000A9B4 ??_C@_1IO@LKIDJAMC@?$AAC?$AA?3?$AA?2?$AAP?$AAr?$AAo?$AAg?$AAr?$AAa?$AAm?$AA?5?$AAF?$AAi?$AAl?$AAe?$AAs?$AA?5?$AA?$CI?$AAx?$AA8?$AA6?$AA?$CJ?$AA?2?$AAM?$AAi?$AAc?$AAr?$AAo?$AAs?$AAo?$AAf?$AAt@:
.rdata:0000A9B4                                         ; DATA XREF: std::_Uninit_copy<wchar_t const * const,wchar_t const *>(wchar_t const * const *,wchar_t const * const *,wchar_t const * *,std::_Wrap_alloc<std::allocator<wchar_t const *>> &,std::_Scalar_ptr_iterator_tag)+9o
.rdata:0000A9B4                                         ; std::_Uninit_copy<wchar_t const * const,wchar_t const *>(wchar_t const * const *,wchar_t const * const *,wchar_t const * *,std::_Wrap_alloc<std::allocator<wchar_t const *>> &,std::_Scalar_ptr_iterator_tag)+23o ...
.rdata:0000A9B4                 unicode 0, <C:\Program Files (x86)\Microsoft Visual Studio 12.0\VC\in>
.rdata:0000A9B4                 unicode 0, <clude\xmemory>,0
.rdata:0000AA42                 align 4
.rdata:0000AA42 _rdata          ends
.rdata:0000AA42
.rdata$r:0000AA44 ; ===========================================================================
.rdata$r:0000AA44
.rdata$r:0000AA44 ; Segment type: Pure data
.rdata$r:0000AA44 ; Segment permissions: Read
.rdata$r:0000AA44 _rdata$r        segment dword public 'DATA' use32
.rdata$r:0000AA44                 assume cs:_rdata$r
.rdata$r:0000AA44                 ;org 0AA44h
.rdata$r:0000AA44 ; COMDAT (pick any)
.rdata$r:0000AA44                 public ??_R4error_category@std@@6B@
.rdata$r:0000AA44 ; const std::error_category::`RTTI Complete Object Locator'
.rdata$r:0000AA44 ??_R4error_category@std@@6B@ db    0    ; DATA XREF: .rdata:0000A3D8o
.rdata$r:0000AA45                 db    0
.rdata$r:0000AA46                 db    0
.rdata$r:0000AA47                 db    0
.rdata$r:0000AA48                 db    0
.rdata$r:0000AA49                 db    0
.rdata$r:0000AA4A                 db    0
.rdata$r:0000AA4B                 db    0
.rdata$r:0000AA4C                 db    0
.rdata$r:0000AA4D                 db    0
.rdata$r:0000AA4E                 db    0
.rdata$r:0000AA4F                 db    0
.rdata$r:0000AA50                 dd offset ??_R0?AVerror_category@std@@@8 ; std::error_category `RTTI Type Descriptor'
.rdata$r:0000AA54                 dd offset ??_R3error_category@std@@8 ; std::error_category::`RTTI Class Hierarchy Descriptor'
.rdata$r:0000AA54 _rdata$r        ends
.rdata$r:0000AA54
.data$r:0000AA58 ; ===========================================================================
.data$r:0000AA58
.data$r:0000AA58 ; Segment type: Pure data
.data$r:0000AA58 ; Segment permissions: Read/Write
.data$r:0000AA58 _data$r         segment dword public 'DATA' use32
.data$r:0000AA58                 assume cs:_data$r
.data$r:0000AA58                 ;org 0AA58h
.data$r:0000AA58 ; COMDAT (pick any)
.data$r:0000AA58                 public ??_R0?AVerror_category@std@@@8
.data$r:0000AA58 ; class std::error_category `RTTI Type Descriptor'
.data$r:0000AA58 ??_R0?AVerror_category@std@@@8 dd offset ??_7type_info@@6B@
.data$r:0000AA58                                         ; DATA XREF: .rdata$r:0000AA50o
.data$r:0000AA58                                         ; .rdata$r:std::error_category::`RTTI Base Class Descriptor at (0,-1,0,64)'o
.data$r:0000AA58                                         ; const type_info::`vftable'
.data$r:0000AA5C                 align 10h
.data$r:0000AA60 a_?averror_cate db '.?AVerror_category@std@@',0
.data$r:0000AA79                 align 4
.data$r:0000AA79 _data$r         ends
.data$r:0000AA79
.rdata$r:0000AA7C ; ===========================================================================
.rdata$r:0000AA7C
.rdata$r:0000AA7C ; Segment type: Pure data
.rdata$r:0000AA7C ; Segment permissions: Read
.rdata$r:0000AA7C _rdata$r        segment dword public 'DATA' use32
.rdata$r:0000AA7C                 assume cs:_rdata$r
.rdata$r:0000AA7C                 ;org 0AA7Ch
.rdata$r:0000AA7C ; COMDAT (pick any)
.rdata$r:0000AA7C                 public ??_R3error_category@std@@8
.rdata$r:0000AA7C ; std::error_category::`RTTI Class Hierarchy Descriptor'
.rdata$r:0000AA7C ??_R3error_category@std@@8 db    0      ; DATA XREF: .rdata$r:0000AA54o
.rdata$r:0000AA7C                                         ; .rdata$r:0000AAACo
.rdata$r:0000AA7D                 db    0
.rdata$r:0000AA7E                 db    0
.rdata$r:0000AA7F                 db    0
.rdata$r:0000AA80                 db    0
.rdata$r:0000AA81                 db    0
.rdata$r:0000AA82                 db    0
.rdata$r:0000AA83                 db    0
.rdata$r:0000AA84                 db    1
.rdata$r:0000AA85                 db    0
.rdata$r:0000AA86                 db    0
.rdata$r:0000AA87                 db    0
.rdata$r:0000AA88                 dd offset ??_R2error_category@std@@8 ; std::error_category::`RTTI Base Class Array'
.rdata$r:0000AA88 _rdata$r        ends
.rdata$r:0000AA88
.rdata$r:0000AA8C ; ===========================================================================
.rdata$r:0000AA8C
.rdata$r:0000AA8C ; Segment type: Pure data
.rdata$r:0000AA8C ; Segment permissions: Read
.rdata$r:0000AA8C _rdata$r        segment dword public 'DATA' use32
.rdata$r:0000AA8C                 assume cs:_rdata$r
.rdata$r:0000AA8C                 ;org 0AA8Ch
.rdata$r:0000AA8C ; COMDAT (pick any)
.rdata$r:0000AA8C                 public ??_R2error_category@std@@8
.rdata$r:0000AA8C ; std::error_category::`RTTI Base Class Array'
.rdata$r:0000AA8C ??_R2error_category@std@@8 dd offset ??_R1A@?0A@EA@error_category@std@@8
.rdata$r:0000AA8C                                         ; DATA XREF: .rdata$r:0000AA88o
.rdata$r:0000AA8C                                         ; std::error_category::`RTTI Base Class Descriptor at (0,-1,0,64)'
.rdata$r:0000AA90                 db    0
.rdata$r:0000AA91                 align 4
.rdata$r:0000AA91 _rdata$r        ends
.rdata$r:0000AA91
.rdata$r:0000AA94 ; ===========================================================================
.rdata$r:0000AA94
.rdata$r:0000AA94 ; Segment type: Pure data
.rdata$r:0000AA94 ; Segment permissions: Read
.rdata$r:0000AA94 _rdata$r        segment dword public 'DATA' use32
.rdata$r:0000AA94                 assume cs:_rdata$r
.rdata$r:0000AA94                 ;org 0AA94h
.rdata$r:0000AA94 ; COMDAT (pick any)
.rdata$r:0000AA94                 public ??_R1A@?0A@EA@error_category@std@@8
.rdata$r:0000AA94 ; std::error_category::`RTTI Base Class Descriptor at (0, -1, 0, 64)'
.rdata$r:0000AA94 ??_R1A@?0A@EA@error_category@std@@8 dd offset ??_R0?AVerror_category@std@@@8
.rdata$r:0000AA94                                         ; DATA XREF: .rdata$r:std::error_category::`RTTI Base Class Array'o
.rdata$r:0000AA94                                         ; .rdata$r:0000AB04o ...
.rdata$r:0000AA94                                         ; std::error_category `RTTI Type Descriptor'
.rdata$r:0000AA98                 align 10h
.rdata$r:0000AAA0                 db 0FFh
.rdata$r:0000AAA1                 db 0FFh
.rdata$r:0000AAA2                 db 0FFh
.rdata$r:0000AAA3                 db 0FFh
.rdata$r:0000AAA4                 db    0
.rdata$r:0000AAA5                 db    0
.rdata$r:0000AAA6                 db    0
.rdata$r:0000AAA7                 db    0
.rdata$r:0000AAA8                 db  40h ; @
.rdata$r:0000AAA9                 db    0
.rdata$r:0000AAAA                 db    0
.rdata$r:0000AAAB                 db    0
.rdata$r:0000AAAC                 dd offset ??_R3error_category@std@@8 ; std::error_category::`RTTI Class Hierarchy Descriptor'
.rdata$r:0000AAAC _rdata$r        ends
.rdata$r:0000AAAC
.rdata$r:0000AAB0 ; ===========================================================================
.rdata$r:0000AAB0
.rdata$r:0000AAB0 ; Segment type: Pure data
.rdata$r:0000AAB0 ; Segment permissions: Read
.rdata$r:0000AAB0 _rdata$r        segment dword public 'DATA' use32
.rdata$r:0000AAB0                 assume cs:_rdata$r
.rdata$r:0000AAB0                 ;org 0AAB0h
.rdata$r:0000AAB0 ; COMDAT (pick any)
.rdata$r:0000AAB0                 public ??_R4_Generic_error_category@std@@6B@
.rdata$r:0000AAB0 ; const std::_Generic_error_category::`RTTI Complete Object Locator'
.rdata$r:0000AAB0 ??_R4_Generic_error_category@std@@6B@ db    0
.rdata$r:0000AAB0                                         ; DATA XREF: .rdata:0000A3F4o
.rdata$r:0000AAB1                 db    0
.rdata$r:0000AAB2                 db    0
.rdata$r:0000AAB3                 db    0
.rdata$r:0000AAB4                 db    0
.rdata$r:0000AAB5                 db    0
.rdata$r:0000AAB6                 db    0
.rdata$r:0000AAB7                 db    0
.rdata$r:0000AAB8                 db    0
.rdata$r:0000AAB9                 db    0
.rdata$r:0000AABA                 db    0
.rdata$r:0000AABB                 db    0
.rdata$r:0000AABC                 dd offset ??_R0?AV_Generic_error_category@std@@@8 ; std::_Generic_error_category `RTTI Type Descriptor'
.rdata$r:0000AAC0                 dd offset ??_R3_Generic_error_category@std@@8 ; std::_Generic_error_category::`RTTI Class Hierarchy Descriptor'
.rdata$r:0000AAC0 _rdata$r        ends
.rdata$r:0000AAC0
.data$r:0000AAC4 ; ===========================================================================
.data$r:0000AAC4
.data$r:0000AAC4 ; Segment type: Pure data
.data$r:0000AAC4 ; Segment permissions: Read/Write
.data$r:0000AAC4 _data$r         segment dword public 'DATA' use32
.data$r:0000AAC4                 assume cs:_data$r
.data$r:0000AAC4                 ;org 0AAC4h
.data$r:0000AAC4 ; COMDAT (pick any)
.data$r:0000AAC4                 public ??_R0?AV_Generic_error_category@std@@@8
.data$r:0000AAC4 ; class std::_Generic_error_category `RTTI Type Descriptor'
.data$r:0000AAC4 ??_R0?AV_Generic_error_category@std@@@8 dd offset ??_7type_info@@6B@
.data$r:0000AAC4                                         ; DATA XREF: .rdata$r:0000AABCo
.data$r:0000AAC4                                         ; .rdata$r:std::_Generic_error_category::`RTTI Base Class Descriptor at (0,-1,0,64)'o
.data$r:0000AAC4                                         ; const type_info::`vftable'
.data$r:0000AAC8                 db    0
.data$r:0000AAC9                 db    0
.data$r:0000AACA                 db    0
.data$r:0000AACB                 db    0
.data$r:0000AACC                 db  2Eh ; .
.data$r:0000AACD                 db  3Fh ; ?
.data$r:0000AACE                 db  41h ; A
.data$r:0000AACF                 db  56h ; V
.data$r:0000AAD0                 db  5Fh ; _
.data$r:0000AAD1                 db  47h ; G
.data$r:0000AAD2                 db  65h ; e
.data$r:0000AAD3                 db  6Eh ; n
.data$r:0000AAD4                 db  65h ; e
.data$r:0000AAD5                 db  72h ; r
.data$r:0000AAD6                 db  69h ; i
.data$r:0000AAD7                 db  63h ; c
.data$r:0000AAD8                 db  5Fh ; _
.data$r:0000AAD9                 db  65h ; e
.data$r:0000AADA                 db  72h ; r
.data$r:0000AADB                 db  72h ; r
.data$r:0000AADC                 db  6Fh ; o
.data$r:0000AADD                 db  72h ; r
.data$r:0000AADE                 db  5Fh ; _
.data$r:0000AADF                 db  63h ; c
.data$r:0000AAE0                 db  61h ; a
.data$r:0000AAE1                 db  74h ; t
.data$r:0000AAE2                 db  65h ; e
.data$r:0000AAE3                 db  67h ; g
.data$r:0000AAE4                 db  6Fh ; o
.data$r:0000AAE5                 db  72h ; r
.data$r:0000AAE6                 db  79h ; y
.data$r:0000AAE7                 db  40h ; @
.data$r:0000AAE8                 db  73h ; s
.data$r:0000AAE9                 db  74h ; t
.data$r:0000AAEA                 db  64h ; d
.data$r:0000AAEB                 db  40h ; @
.data$r:0000AAEC                 db  40h ; @
.data$r:0000AAED                 db    0
.data$r:0000AAEE                 align 10h
.data$r:0000AAEE _data$r         ends
.data$r:0000AAEE
.rdata$r:0000AAF0 ; ===========================================================================
.rdata$r:0000AAF0
.rdata$r:0000AAF0 ; Segment type: Pure data
.rdata$r:0000AAF0 ; Segment permissions: Read
.rdata$r:0000AAF0 _rdata$r        segment dword public 'DATA' use32
.rdata$r:0000AAF0                 assume cs:_rdata$r
.rdata$r:0000AAF0                 ;org 0AAF0h
.rdata$r:0000AAF0 ; COMDAT (pick any)
.rdata$r:0000AAF0                 public ??_R3_Generic_error_category@std@@8
.rdata$r:0000AAF0 ; std::_Generic_error_category::`RTTI Class Hierarchy Descriptor'
.rdata$r:0000AAF0 ??_R3_Generic_error_category@std@@8 db    0
.rdata$r:0000AAF0                                         ; DATA XREF: .rdata$r:0000AAC0o
.rdata$r:0000AAF0                                         ; .rdata$r:0000AB24o
.rdata$r:0000AAF1                 db    0
.rdata$r:0000AAF2                 db    0
.rdata$r:0000AAF3                 db    0
.rdata$r:0000AAF4                 db    0
.rdata$r:0000AAF5                 db    0
.rdata$r:0000AAF6                 db    0
.rdata$r:0000AAF7                 db    0
.rdata$r:0000AAF8                 db    2
.rdata$r:0000AAF9                 db    0
.rdata$r:0000AAFA                 db    0
.rdata$r:0000AAFB                 db    0
.rdata$r:0000AAFC                 dd offset ??_R2_Generic_error_category@std@@8 ; std::_Generic_error_category::`RTTI Base Class Array'
.rdata$r:0000AAFC _rdata$r        ends
.rdata$r:0000AAFC
.rdata$r:0000AB00 ; ===========================================================================
.rdata$r:0000AB00
.rdata$r:0000AB00 ; Segment type: Pure data
.rdata$r:0000AB00 ; Segment permissions: Read
.rdata$r:0000AB00 _rdata$r        segment dword public 'DATA' use32
.rdata$r:0000AB00                 assume cs:_rdata$r
.rdata$r:0000AB00                 ;org 0AB00h
.rdata$r:0000AB00 ; COMDAT (pick any)
.rdata$r:0000AB00                 public ??_R2_Generic_error_category@std@@8
.rdata$r:0000AB00 ; std::_Generic_error_category::`RTTI Base Class Array'
.rdata$r:0000AB00 ??_R2_Generic_error_category@std@@8 dd offset ??_R1A@?0A@EA@_Generic_error_category@std@@8
.rdata$r:0000AB00                                         ; DATA XREF: .rdata$r:0000AAFCo
.rdata$r:0000AB00                                         ; std::_Generic_error_category::`RTTI Base Class Descriptor at (0,-1,0,64)'
.rdata$r:0000AB04                 dd offset ??_R1A@?0A@EA@error_category@std@@8 ; std::error_category::`RTTI Base Class Descriptor at (0,-1,0,64)'
.rdata$r:0000AB08                 db    0
.rdata$r:0000AB09                 align 4
.rdata$r:0000AB09 _rdata$r        ends
.rdata$r:0000AB09
.rdata$r:0000AB0C ; ===========================================================================
.rdata$r:0000AB0C
.rdata$r:0000AB0C ; Segment type: Pure data
.rdata$r:0000AB0C ; Segment permissions: Read
.rdata$r:0000AB0C _rdata$r        segment dword public 'DATA' use32
.rdata$r:0000AB0C                 assume cs:_rdata$r
.rdata$r:0000AB0C                 ;org 0AB0Ch
.rdata$r:0000AB0C ; COMDAT (pick any)
.rdata$r:0000AB0C                 public ??_R1A@?0A@EA@_Generic_error_category@std@@8
.rdata$r:0000AB0C ; std::_Generic_error_category::`RTTI Base Class Descriptor at (0, -1, 0, 64)'
.rdata$r:0000AB0C ??_R1A@?0A@EA@_Generic_error_category@std@@8 dd offset ??_R0?AV_Generic_error_category@std@@@8
.rdata$r:0000AB0C                                         ; DATA XREF: .rdata$r:std::_Generic_error_category::`RTTI Base Class Array'o
.rdata$r:0000AB0C                                         ; .rdata$r:0000AB7Co ...
.rdata$r:0000AB0C                                         ; std::_Generic_error_category `RTTI Type Descriptor'
.rdata$r:0000AB10                 db    1
.rdata$r:0000AB11                 db    0
.rdata$r:0000AB12                 db    0
.rdata$r:0000AB13                 db    0
.rdata$r:0000AB14                 db    0
.rdata$r:0000AB15                 db    0
.rdata$r:0000AB16                 db    0
.rdata$r:0000AB17                 db    0
.rdata$r:0000AB18                 db 0FFh
.rdata$r:0000AB19                 db 0FFh
.rdata$r:0000AB1A                 db 0FFh
.rdata$r:0000AB1B                 db 0FFh
.rdata$r:0000AB1C                 db    0
.rdata$r:0000AB1D                 db    0
.rdata$r:0000AB1E                 db    0
.rdata$r:0000AB1F                 db    0
.rdata$r:0000AB20                 db  40h ; @
.rdata$r:0000AB21                 db    0
.rdata$r:0000AB22                 db    0
.rdata$r:0000AB23                 db    0
.rdata$r:0000AB24                 dd offset ??_R3_Generic_error_category@std@@8 ; std::_Generic_error_category::`RTTI Class Hierarchy Descriptor'
.rdata$r:0000AB24 _rdata$r        ends
.rdata$r:0000AB24
.rdata$r:0000AB28 ; ===========================================================================
.rdata$r:0000AB28
.rdata$r:0000AB28 ; Segment type: Pure data
.rdata$r:0000AB28 ; Segment permissions: Read
.rdata$r:0000AB28 _rdata$r        segment dword public 'DATA' use32
.rdata$r:0000AB28                 assume cs:_rdata$r
.rdata$r:0000AB28                 ;org 0AB28h
.rdata$r:0000AB28 ; COMDAT (pick any)
.rdata$r:0000AB28                 public ??_R4_Iostream_error_category@std@@6B@
.rdata$r:0000AB28 ; const std::_Iostream_error_category::`RTTI Complete Object Locator'
.rdata$r:0000AB28 ??_R4_Iostream_error_category@std@@6B@ db    0
.rdata$r:0000AB28                                         ; DATA XREF: .rdata:0000A428o
.rdata$r:0000AB29                 db    0
.rdata$r:0000AB2A                 db    0
.rdata$r:0000AB2B                 db    0
.rdata$r:0000AB2C                 db    0
.rdata$r:0000AB2D                 db    0
.rdata$r:0000AB2E                 db    0
.rdata$r:0000AB2F                 db    0
.rdata$r:0000AB30                 db    0
.rdata$r:0000AB31                 db    0
.rdata$r:0000AB32                 db    0
.rdata$r:0000AB33                 db    0
.rdata$r:0000AB34                 dd offset ??_R0?AV_Iostream_error_category@std@@@8 ; std::_Iostream_error_category `RTTI Type Descriptor'
.rdata$r:0000AB38                 dd offset ??_R3_Iostream_error_category@std@@8 ; std::_Iostream_error_category::`RTTI Class Hierarchy Descriptor'
.rdata$r:0000AB38 _rdata$r        ends
.rdata$r:0000AB38
.data$r:0000AB3C ; ===========================================================================
.data$r:0000AB3C
.data$r:0000AB3C ; Segment type: Pure data
.data$r:0000AB3C ; Segment permissions: Read/Write
.data$r:0000AB3C _data$r         segment dword public 'DATA' use32
.data$r:0000AB3C                 assume cs:_data$r
.data$r:0000AB3C                 ;org 0AB3Ch
.data$r:0000AB3C ; COMDAT (pick any)
.data$r:0000AB3C                 public ??_R0?AV_Iostream_error_category@std@@@8
.data$r:0000AB3C ; class std::_Iostream_error_category `RTTI Type Descriptor'
.data$r:0000AB3C ??_R0?AV_Iostream_error_category@std@@@8 dd offset ??_7type_info@@6B@
.data$r:0000AB3C                                         ; DATA XREF: .rdata$r:0000AB34o
.data$r:0000AB3C                                         ; .rdata$r:std::_Iostream_error_category::`RTTI Base Class Descriptor at (0,-1,0,64)'o
.data$r:0000AB3C                                         ; const type_info::`vftable'
.data$r:0000AB40                 db    0
.data$r:0000AB41                 db    0
.data$r:0000AB42                 db    0
.data$r:0000AB43                 db    0
.data$r:0000AB44                 db  2Eh ; .
.data$r:0000AB45                 db  3Fh ; ?
.data$r:0000AB46                 db  41h ; A
.data$r:0000AB47                 db  56h ; V
.data$r:0000AB48                 db  5Fh ; _
.data$r:0000AB49                 db  49h ; I
.data$r:0000AB4A                 db  6Fh ; o
.data$r:0000AB4B                 db  73h ; s
.data$r:0000AB4C                 db  74h ; t
.data$r:0000AB4D                 db  72h ; r
.data$r:0000AB4E                 db  65h ; e
.data$r:0000AB4F                 db  61h ; a
.data$r:0000AB50                 db  6Dh ; m
.data$r:0000AB51                 db  5Fh ; _
.data$r:0000AB52                 db  65h ; e
.data$r:0000AB53                 db  72h ; r
.data$r:0000AB54                 db  72h ; r
.data$r:0000AB55                 db  6Fh ; o
.data$r:0000AB56                 db  72h ; r
.data$r:0000AB57                 db  5Fh ; _
.data$r:0000AB58                 db  63h ; c
.data$r:0000AB59                 db  61h ; a
.data$r:0000AB5A                 db  74h ; t
.data$r:0000AB5B                 db  65h ; e
.data$r:0000AB5C                 db  67h ; g
.data$r:0000AB5D                 db  6Fh ; o
.data$r:0000AB5E                 db  72h ; r
.data$r:0000AB5F                 db  79h ; y
.data$r:0000AB60                 db  40h ; @
.data$r:0000AB61                 db  73h ; s
.data$r:0000AB62                 db  74h ; t
.data$r:0000AB63                 db  64h ; d
.data$r:0000AB64                 db  40h ; @
.data$r:0000AB65                 db  40h ; @
.data$r:0000AB66                 db    0
.data$r:0000AB67                 align 4
.data$r:0000AB67 _data$r         ends
.data$r:0000AB67
.rdata$r:0000AB68 ; ===========================================================================
.rdata$r:0000AB68
.rdata$r:0000AB68 ; Segment type: Pure data
.rdata$r:0000AB68 ; Segment permissions: Read
.rdata$r:0000AB68 _rdata$r        segment dword public 'DATA' use32
.rdata$r:0000AB68                 assume cs:_rdata$r
.rdata$r:0000AB68                 ;org 0AB68h
.rdata$r:0000AB68 ; COMDAT (pick any)
.rdata$r:0000AB68                 public ??_R3_Iostream_error_category@std@@8
.rdata$r:0000AB68 ; std::_Iostream_error_category::`RTTI Class Hierarchy Descriptor'
.rdata$r:0000AB68 ??_R3_Iostream_error_category@std@@8 db    0
.rdata$r:0000AB68                                         ; DATA XREF: .rdata$r:0000AB38o
.rdata$r:0000AB68                                         ; .rdata$r:0000ABA0o
.rdata$r:0000AB69                 db    0
.rdata$r:0000AB6A                 db    0
.rdata$r:0000AB6B                 db    0
.rdata$r:0000AB6C                 db    0
.rdata$r:0000AB6D                 db    0
.rdata$r:0000AB6E                 db    0
.rdata$r:0000AB6F                 db    0
.rdata$r:0000AB70                 db    3
.rdata$r:0000AB71                 db    0
.rdata$r:0000AB72                 db    0
.rdata$r:0000AB73                 db    0
.rdata$r:0000AB74                 dd offset ??_R2_Iostream_error_category@std@@8 ; std::_Iostream_error_category::`RTTI Base Class Array'
.rdata$r:0000AB74 _rdata$r        ends
.rdata$r:0000AB74
.rdata$r:0000AB78 ; ===========================================================================
.rdata$r:0000AB78
.rdata$r:0000AB78 ; Segment type: Pure data
.rdata$r:0000AB78 ; Segment permissions: Read
.rdata$r:0000AB78 _rdata$r        segment dword public 'DATA' use32
.rdata$r:0000AB78                 assume cs:_rdata$r
.rdata$r:0000AB78                 ;org 0AB78h
.rdata$r:0000AB78 ; COMDAT (pick any)
.rdata$r:0000AB78                 public ??_R2_Iostream_error_category@std@@8
.rdata$r:0000AB78 ; std::_Iostream_error_category::`RTTI Base Class Array'
.rdata$r:0000AB78 ??_R2_Iostream_error_category@std@@8 dd offset ??_R1A@?0A@EA@_Iostream_error_category@std@@8
.rdata$r:0000AB78                                         ; DATA XREF: .rdata$r:0000AB74o
.rdata$r:0000AB78                                         ; std::_Iostream_error_category::`RTTI Base Class Descriptor at (0,-1,0,64)'
.rdata$r:0000AB7C                 dd offset ??_R1A@?0A@EA@_Generic_error_category@std@@8 ; std::_Generic_error_category::`RTTI Base Class Descriptor at (0,-1,0,64)'
.rdata$r:0000AB80                 dd offset ??_R1A@?0A@EA@error_category@std@@8 ; std::error_category::`RTTI Base Class Descriptor at (0,-1,0,64)'
.rdata$r:0000AB84                 db    0
.rdata$r:0000AB85                 align 4
.rdata$r:0000AB85 _rdata$r        ends
.rdata$r:0000AB85
.rdata$r:0000AB88 ; ===========================================================================
.rdata$r:0000AB88
.rdata$r:0000AB88 ; Segment type: Pure data
.rdata$r:0000AB88 ; Segment permissions: Read
.rdata$r:0000AB88 _rdata$r        segment dword public 'DATA' use32
.rdata$r:0000AB88                 assume cs:_rdata$r
.rdata$r:0000AB88                 ;org 0AB88h
.rdata$r:0000AB88 ; COMDAT (pick any)
.rdata$r:0000AB88                 public ??_R1A@?0A@EA@_Iostream_error_category@std@@8
.rdata$r:0000AB88 ; std::_Iostream_error_category::`RTTI Base Class Descriptor at (0, -1, 0, 64)'
.rdata$r:0000AB88 ??_R1A@?0A@EA@_Iostream_error_category@std@@8 dd offset ??_R0?AV_Iostream_error_category@std@@@8
.rdata$r:0000AB88                                         ; DATA XREF: .rdata$r:std::_Iostream_error_category::`RTTI Base Class Array'o
.rdata$r:0000AB88                                         ; std::_Iostream_error_category `RTTI Type Descriptor'
.rdata$r:0000AB8C                 db    2
.rdata$r:0000AB8D                 db    0
.rdata$r:0000AB8E                 db    0
.rdata$r:0000AB8F                 db    0
.rdata$r:0000AB90                 db    0
.rdata$r:0000AB91                 db    0
.rdata$r:0000AB92                 db    0
.rdata$r:0000AB93                 db    0
.rdata$r:0000AB94                 db 0FFh
.rdata$r:0000AB95                 db 0FFh
.rdata$r:0000AB96                 db 0FFh
.rdata$r:0000AB97                 db 0FFh
.rdata$r:0000AB98                 db    0
.rdata$r:0000AB99                 db    0
.rdata$r:0000AB9A                 db    0
.rdata$r:0000AB9B                 db    0
.rdata$r:0000AB9C                 db  40h ; @
.rdata$r:0000AB9D                 db    0
.rdata$r:0000AB9E                 db    0
.rdata$r:0000AB9F                 db    0
.rdata$r:0000ABA0                 dd offset ??_R3_Iostream_error_category@std@@8 ; std::_Iostream_error_category::`RTTI Class Hierarchy Descriptor'
.rdata$r:0000ABA0 _rdata$r        ends
.rdata$r:0000ABA0
.rdata$r:0000ABA4 ; ===========================================================================
.rdata$r:0000ABA4
.rdata$r:0000ABA4 ; Segment type: Pure data
.rdata$r:0000ABA4 ; Segment permissions: Read
.rdata$r:0000ABA4 _rdata$r        segment dword public 'DATA' use32
.rdata$r:0000ABA4                 assume cs:_rdata$r
.rdata$r:0000ABA4                 ;org 0ABA4h
.rdata$r:0000ABA4 ; COMDAT (pick any)
.rdata$r:0000ABA4                 public ??_R4_System_error_category@std@@6B@
.rdata$r:0000ABA4 ; const std::_System_error_category::`RTTI Complete Object Locator'
.rdata$r:0000ABA4 ??_R4_System_error_category@std@@6B@ db    0 ; DATA XREF: .rdata:0000A468o
.rdata$r:0000ABA5                 db    0
.rdata$r:0000ABA6                 db    0
.rdata$r:0000ABA7                 db    0
.rdata$r:0000ABA8                 db    0
.rdata$r:0000ABA9                 db    0
.rdata$r:0000ABAA                 db    0
.rdata$r:0000ABAB                 db    0
.rdata$r:0000ABAC                 db    0
.rdata$r:0000ABAD                 db    0
.rdata$r:0000ABAE                 db    0
.rdata$r:0000ABAF                 db    0
.rdata$r:0000ABB0                 dd offset ??_R0?AV_System_error_category@std@@@8 ; std::_System_error_category `RTTI Type Descriptor'
.rdata$r:0000ABB4                 dd offset ??_R3_System_error_category@std@@8 ; std::_System_error_category::`RTTI Class Hierarchy Descriptor'
.rdata$r:0000ABB4 _rdata$r        ends
.rdata$r:0000ABB4
.data$r:0000ABB8 ; ===========================================================================
.data$r:0000ABB8
.data$r:0000ABB8 ; Segment type: Pure data
.data$r:0000ABB8 ; Segment permissions: Read/Write
.data$r:0000ABB8 _data$r         segment dword public 'DATA' use32
.data$r:0000ABB8                 assume cs:_data$r
.data$r:0000ABB8                 ;org 0ABB8h
.data$r:0000ABB8 ; COMDAT (pick any)
.data$r:0000ABB8                 public ??_R0?AV_System_error_category@std@@@8
.data$r:0000ABB8 ; class std::_System_error_category `RTTI Type Descriptor'
.data$r:0000ABB8 ??_R0?AV_System_error_category@std@@@8 dd offset ??_7type_info@@6B@
.data$r:0000ABB8                                         ; DATA XREF: .rdata$r:0000ABB0o
.data$r:0000ABB8                                         ; .rdata$r:std::_System_error_category::`RTTI Base Class Descriptor at (0,-1,0,64)'o
.data$r:0000ABB8                                         ; const type_info::`vftable'
.data$r:0000ABBC                 align 10h
.data$r:0000ABC0 a_?av_system_er db '.?AV_System_error_category@std@@',0
.data$r:0000ABE1                 align 4
.data$r:0000ABE1 _data$r         ends
.data$r:0000ABE1
.rdata$r:0000ABE4 ; ===========================================================================
.rdata$r:0000ABE4
.rdata$r:0000ABE4 ; Segment type: Pure data
.rdata$r:0000ABE4 ; Segment permissions: Read
.rdata$r:0000ABE4 _rdata$r        segment dword public 'DATA' use32
.rdata$r:0000ABE4                 assume cs:_rdata$r
.rdata$r:0000ABE4                 ;org 0ABE4h
.rdata$r:0000ABE4 ; COMDAT (pick any)
.rdata$r:0000ABE4                 public ??_R3_System_error_category@std@@8
.rdata$r:0000ABE4 ; std::_System_error_category::`RTTI Class Hierarchy Descriptor'
.rdata$r:0000ABE4 ??_R3_System_error_category@std@@8 db    0 ; DATA XREF: .rdata$r:0000ABB4o
.rdata$r:0000ABE4                                         ; .rdata$r:0000AC1Co
.rdata$r:0000ABE5                 db    0
.rdata$r:0000ABE6                 db    0
.rdata$r:0000ABE7                 db    0
.rdata$r:0000ABE8                 db    0
.rdata$r:0000ABE9                 db    0
.rdata$r:0000ABEA                 db    0
.rdata$r:0000ABEB                 db    0
.rdata$r:0000ABEC                 db    3
.rdata$r:0000ABED                 db    0
.rdata$r:0000ABEE                 db    0
.rdata$r:0000ABEF                 db    0
.rdata$r:0000ABF0                 dd offset ??_R2_System_error_category@std@@8 ; std::_System_error_category::`RTTI Base Class Array'
.rdata$r:0000ABF0 _rdata$r        ends
.rdata$r:0000ABF0
.rdata$r:0000ABF4 ; ===========================================================================
.rdata$r:0000ABF4
.rdata$r:0000ABF4 ; Segment type: Pure data
.rdata$r:0000ABF4 ; Segment permissions: Read
.rdata$r:0000ABF4 _rdata$r        segment dword public 'DATA' use32
.rdata$r:0000ABF4                 assume cs:_rdata$r
.rdata$r:0000ABF4                 ;org 0ABF4h
.rdata$r:0000ABF4 ; COMDAT (pick any)
.rdata$r:0000ABF4                 public ??_R2_System_error_category@std@@8
.rdata$r:0000ABF4 ; std::_System_error_category::`RTTI Base Class Array'
.rdata$r:0000ABF4 ??_R2_System_error_category@std@@8 dd offset ??_R1A@?0A@EA@_System_error_category@std@@8
.rdata$r:0000ABF4                                         ; DATA XREF: .rdata$r:0000ABF0o
.rdata$r:0000ABF4                                         ; std::_System_error_category::`RTTI Base Class Descriptor at (0,-1,0,64)'
.rdata$r:0000ABF8                 dd offset ??_R1A@?0A@EA@_Generic_error_category@std@@8 ; std::_Generic_error_category::`RTTI Base Class Descriptor at (0,-1,0,64)'
.rdata$r:0000ABFC                 dd offset ??_R1A@?0A@EA@error_category@std@@8 ; std::error_category::`RTTI Base Class Descriptor at (0,-1,0,64)'
.rdata$r:0000AC00                 db    0
.rdata$r:0000AC01                 align 4
.rdata$r:0000AC01 _rdata$r        ends
.rdata$r:0000AC01
.rdata$r:0000AC04 ; ===========================================================================
.rdata$r:0000AC04
.rdata$r:0000AC04 ; Segment type: Pure data
.rdata$r:0000AC04 ; Segment permissions: Read
.rdata$r:0000AC04 _rdata$r        segment dword public 'DATA' use32
.rdata$r:0000AC04                 assume cs:_rdata$r
.rdata$r:0000AC04                 ;org 0AC04h
.rdata$r:0000AC04 ; COMDAT (pick any)
.rdata$r:0000AC04                 public ??_R1A@?0A@EA@_System_error_category@std@@8
.rdata$r:0000AC04 ; std::_System_error_category::`RTTI Base Class Descriptor at (0, -1, 0, 64)'
.rdata$r:0000AC04 ??_R1A@?0A@EA@_System_error_category@std@@8 dd offset ??_R0?AV_System_error_category@std@@@8
.rdata$r:0000AC04                                         ; DATA XREF: .rdata$r:std::_System_error_category::`RTTI Base Class Array'o
.rdata$r:0000AC04                                         ; std::_System_error_category `RTTI Type Descriptor'
.rdata$r:0000AC08                 db    2
.rdata$r:0000AC09                 db    0
.rdata$r:0000AC0A                 db    0
.rdata$r:0000AC0B                 db    0
.rdata$r:0000AC0C                 db    0
.rdata$r:0000AC0D                 db    0
.rdata$r:0000AC0E                 db    0
.rdata$r:0000AC0F                 db    0
.rdata$r:0000AC10                 db 0FFh
.rdata$r:0000AC11                 db 0FFh
.rdata$r:0000AC12                 db 0FFh
.rdata$r:0000AC13                 db 0FFh
.rdata$r:0000AC14                 db    0
.rdata$r:0000AC15                 db    0
.rdata$r:0000AC16                 db    0
.rdata$r:0000AC17                 db    0
.rdata$r:0000AC18                 db  40h ; @
.rdata$r:0000AC19                 db    0
.rdata$r:0000AC1A                 db    0
.rdata$r:0000AC1B                 db    0
.rdata$r:0000AC1C                 dd offset ??_R3_System_error_category@std@@8 ; std::_System_error_category::`RTTI Class Hierarchy Descriptor'
.rdata$r:0000AC1C _rdata$r        ends
.rdata$r:0000AC1C
.CRT$XCU:0000AC20 ; ===========================================================================
.CRT$XCU:0000AC20
.CRT$XCU:0000AC20 ; Segment type: Pure data
.CRT$XCU:0000AC20 ; Segment permissions: Read
.CRT$XCU:0000AC20 _CRT$XCU        segment dword public 'DATA' use32
.CRT$XCU:0000AC20                 assume cs:_CRT$XCU
.CRT$XCU:0000AC20                 ;org 0AC20h
.CRT$XCU:0000AC20 _piecewise_construct$initializer$ dd offset ??__Epiecewise_construct@std@@YAXXZ ; std::`dynamic initializer for 'piecewise_construct''(void)
.CRT$XCU:0000AC24 _allocator_arg$initializer$ dd offset ??__Eallocator_arg@std@@YAXXZ ; std::`dynamic initializer for 'allocator_arg''(void)
.CRT$XCU:0000AC28 _ignore$initializer$ dd offset ??__Eignore@std@@YAXXZ ; std::`dynamic initializer for 'ignore''(void)
.CRT$XCU:0000AC2C __Tuple_alloc$initializer$ dd offset ??__E_Tuple_alloc@std@@YAXXZ ; std::`dynamic initializer for '_Tuple_alloc''(void)
.CRT$XCU:0000AC2C _CRT$XCU        ends
.CRT$XCU:0000AC2C
.CRT$XCU:0000AC30 ; ===========================================================================
.CRT$XCU:0000AC30
.CRT$XCU:0000AC30 ; Segment type: Pure data
.CRT$XCU:0000AC30 ; Segment permissions: Read
.CRT$XCU:0000AC30 _CRT$XCU        segment dword public 'DATA' use32
.CRT$XCU:0000AC30                 assume cs:_CRT$XCU
.CRT$XCU:0000AC30                 ;org 0AC30h
.CRT$XCU:0000AC30 ; COMDAT (pick associative to section at A48C)
.CRT$XCU:0000AC30 ; public: static void (__cdecl *std::_Error_objects<int>::_Generic_object$initializer$)(void)
.CRT$XCU:0000AC30 ?_Generic_object$initializer$@?$_Error_objects@H@std@@2P6AXXZA dd offset ??__E?_Generic_object@?$_Error_objects@H@std@@2V_Generic_error_category@2@A@@YAXXZ ; `dynamic initializer for 'std::_Generic_error_category std::_Error_objects<int>::_Generic_object''(void)
.CRT$XCU:0000AC30 _CRT$XCU        ends
.CRT$XCU:0000AC30
.CRT$XCU:0000AC34 ; ===========================================================================
.CRT$XCU:0000AC34
.CRT$XCU:0000AC34 ; Segment type: Pure data
.CRT$XCU:0000AC34 ; Segment permissions: Read
.CRT$XCU:0000AC34 _CRT$XCU        segment dword public 'DATA' use32
.CRT$XCU:0000AC34                 assume cs:_CRT$XCU
.CRT$XCU:0000AC34                 ;org 0AC34h
.CRT$XCU:0000AC34 ; COMDAT (pick associative to section at A490)
.CRT$XCU:0000AC34 ; public: static void (__cdecl *std::_Error_objects<int>::_Iostream_object$initializer$)(void)
.CRT$XCU:0000AC34 ?_Iostream_object$initializer$@?$_Error_objects@H@std@@2P6AXXZA dd offset ??__E?_Iostream_object@?$_Error_objects@H@std@@2V_Iostream_error_category@2@A@@YAXXZ ; `dynamic initializer for 'std::_Iostream_error_category std::_Error_objects<int>::_Iostream_object''(void)
.CRT$XCU:0000AC34 _CRT$XCU        ends
.CRT$XCU:0000AC34
.CRT$XCU:0000AC38 ; ===========================================================================
.CRT$XCU:0000AC38
.CRT$XCU:0000AC38 ; Segment type: Pure data
.CRT$XCU:0000AC38 ; Segment permissions: Read
.CRT$XCU:0000AC38 _CRT$XCU        segment dword public 'DATA' use32
.CRT$XCU:0000AC38                 assume cs:_CRT$XCU
.CRT$XCU:0000AC38                 ;org 0AC38h
.CRT$XCU:0000AC38 ; COMDAT (pick associative to section at A494)
.CRT$XCU:0000AC38 ; public: static void (__cdecl *std::_Error_objects<int>::_System_object$initializer$)(void)
.CRT$XCU:0000AC38 ?_System_object$initializer$@?$_Error_objects@H@std@@2P6AXXZA dd offset ??__E?_System_object@?$_Error_objects@H@std@@2V_System_error_category@2@A@@YAXXZ ; `dynamic initializer for 'std::_System_error_category std::_Error_objects<int>::_System_object''(void)
.CRT$XCU:0000AC38 _CRT$XCU        ends
.CRT$XCU:0000AC38
.CRT$XCU:0000AC3C ; ===========================================================================
.CRT$XCU:0000AC3C
.CRT$XCU:0000AC3C ; Segment type: Pure data
.CRT$XCU:0000AC3C ; Segment permissions: Read
.CRT$XCU:0000AC3C _CRT$XCU        segment dword public 'DATA' use32
.CRT$XCU:0000AC3C                 assume cs:_CRT$XCU
.CRT$XCU:0000AC3C                 ;org 0AC3Ch
.CRT$XCU:0000AC3C ; COMDAT (pick associative to section at A498)
.CRT$XCU:0000AC3C ; public: static void (__cdecl *std::num_put<char, class std::back_insert_iterator<class std::basic_string<char, struct std::char_traits<char>, class std::allocator<char>>>>::id$initializer$)(void)
.CRT$XCU:0000AC3C ?id$initializer$@?$num_put@DV?$back_insert_iterator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@std@@2P6AXXZA dd offset ??__E?id@?$num_put@DV?$back_insert_iterator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@std@@2V0locale@2@A@@YAXXZ ; `dynamic initializer for 'std::locale::id std::num_put<char,std::back_insert_iterator<std::basic_string<char,std::char_traits<char>,std::allocator<char>>>>::id''(void)
.CRT$XCU:0000AC3C _CRT$XCU        ends
.CRT$XCU:0000AC3C
.CRT$XCU:0000AC40 ; ===========================================================================
.CRT$XCU:0000AC40
.CRT$XCU:0000AC40 ; Segment type: Pure data
.CRT$XCU:0000AC40 ; Segment permissions: Read
.CRT$XCU:0000AC40 _CRT$XCU        segment dword public 'DATA' use32
.CRT$XCU:0000AC40                 assume cs:_CRT$XCU
.CRT$XCU:0000AC40                 ;org 0AC40h
.CRT$XCU:0000AC40 ; COMDAT (pick associative to section at A49C)
.CRT$XCU:0000AC40 ; public: static void (__cdecl *std::num_put<wchar_t, class std::back_insert_iterator<class std::basic_string<wchar_t, struct std::char_traits<wchar_t>, class std::allocator<wchar_t>>>>::id$initializer$)(void)
.CRT$XCU:0000AC40 ?id$initializer$@?$num_put@_WV?$back_insert_iterator@V?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@@std@@@std@@2P6AXXZA dd offset ??__E?id@?$num_put@_WV?$back_insert_iterator@V?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@@std@@@std@@2V0locale@2@A@@YAXXZ ; `dynamic initializer for 'std::locale::id std::num_put<wchar_t,std::back_insert_iterator<std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>>>>::id''(void)
.CRT$XCU:0000AC40 _CRT$XCU        ends
.CRT$XCU:0000AC40
.CRT$XCU:0000AC44 ; ===========================================================================
.CRT$XCU:0000AC44
.CRT$XCU:0000AC44 ; Segment type: Pure data
.CRT$XCU:0000AC44 ; Segment permissions: Read
.CRT$XCU:0000AC44 _CRT$XCU        segment dword public 'DATA' use32
.CRT$XCU:0000AC44                 assume cs:_CRT$XCU
.CRT$XCU:0000AC44                 ;org 0AC44h
.CRT$XCU:0000AC44 ; COMDAT (pick associative to section at A530)
.CRT$XCU:0000AC44 ; public: static void (__cdecl *std::numpunct<char>::id$initializer$)(void)
.CRT$XCU:0000AC44 ?id$initializer$@?$numpunct@D@std@@2P6AXXZA dd offset ??__E?id@?$numpunct@D@std@@2V0locale@2@A@@YAXXZ ; `dynamic initializer for 'std::locale::id std::numpunct<char>::id''(void)
.CRT$XCU:0000AC44 _CRT$XCU        ends
.CRT$XCU:0000AC44
.CRT$XCU:0000AC48 ; ===========================================================================
.CRT$XCU:0000AC48
.CRT$XCU:0000AC48 ; Segment type: Pure data
.CRT$XCU:0000AC48 ; Segment permissions: Read
.CRT$XCU:0000AC48 _CRT$XCU        segment dword public 'DATA' use32
.CRT$XCU:0000AC48                 assume cs:_CRT$XCU
.CRT$XCU:0000AC48                 ;org 0AC48h
.CRT$XCU:0000AC48 ; COMDAT (pick associative to section at A534)
.CRT$XCU:0000AC48 ; public: static void (__cdecl *std::numpunct<wchar_t>::id$initializer$)(void)
.CRT$XCU:0000AC48 ?id$initializer$@?$numpunct@_W@std@@2P6AXXZA dd offset ??__E?id@?$numpunct@_W@std@@2V0locale@2@A@@YAXXZ ; `dynamic initializer for 'std::locale::id std::numpunct<wchar_t>::id''(void)
.CRT$XCU:0000AC48 _CRT$XCU        ends
.CRT$XCU:0000AC48
UNDEF:0000AC50 ; ===========================================================================
UNDEF:0000AC50
UNDEF:0000AC50 ; Segment type: Externs
UNDEF:0000AC50 ; UNDEF
UNDEF:0000AC50                 extrn __purecall:near   ; DATA XREF: .rdata:0000A3E0o
UNDEF:0000AC50                                         ; .rdata:0000A3E4o
UNDEF:0000AC54 ; void *__cdecl operator new(unsigned int)
UNDEF:0000AC54                 extrn ??2@YAPAXI@Z:near ; CODE XREF: std::_Allocate<char>(uint,char *)+1Dp
UNDEF:0000AC54                                         ; std::_Allocate<wchar_t const *>(uint,wchar_t const * *)+23p ...
UNDEF:0000AC58 ; void __cdecl operator delete(void *)
UNDEF:0000AC58                 extrn ??3@YAXPAX@Z:near ; CODE XREF: std::vector<wchar_t const *,std::allocator<wchar_t const *>>::`scalar deleting destructor'(uint)+1Bp
UNDEF:0000AC58                                         ; std::_Generic_error_category::`scalar deleting destructor'(uint)+1Bp ...
UNDEF:0000AC5C ; int __cdecl atexit(void (__cdecl *)())
UNDEF:0000AC5C                 extrn _atexit:near      ; CODE XREF: `dynamic initializer for 'std::_Generic_error_category std::_Error_objects<int>::_Generic_object''(void)+12p
UNDEF:0000AC5C                                         ; `dynamic initializer for 'std::_Iostream_error_category std::_Error_objects<int>::_Iostream_object''(void)+12p ...
UNDEF:0000AC60                 extrn ___report_rangecheckfailure:near
UNDEF:0000AC60                                         ; CODE XREF: FunctionCallTip::showCalltip(void):loc_1D4Ap
UNDEF:0000AC64                 extrn __invalid_parameter:near
UNDEF:0000AC64                                         ; CODE XREF: std::_Vector_const_iterator<std::_Vector_val<std::_Simple_types<FunctionValues>>>::operator*(void)+99p
UNDEF:0000AC64                                         ; std::_Vector_const_iterator<std::_Vector_val<std::_Simple_types<FunctionValues>>>::operator+=(int)+A6p
UNDEF:0000AC68 ; void *__cdecl memcpy(void *Dst, const void *Src, size_t Size)
UNDEF:0000AC68                 extrn _memcpy:near      ; CODE XREF: std::char_traits<char>::copy(char *,char const *,uint)+1Ep
UNDEF:0000AC6C ; size_t __cdecl strlen(const char *Str)
UNDEF:0000AC6C                 extrn _strlen:near      ; CODE XREF: std::char_traits<char>::length(char const *)+1Bp
UNDEF:0000AC70 ; void *__cdecl memmove(void *Dst, const void *Src, size_t Size)
UNDEF:0000AC70                 extrn _memmove:near     ; CODE XREF: std::_Uninit_copy<wchar_t const * const,wchar_t const *>(wchar_t const * const *,wchar_t const * const *,wchar_t const * *,std::_Wrap_alloc<std::allocator<wchar_t const *>> &,std::_Scalar_ptr_iterator_tag)+4Fp
UNDEF:0000AC70                                         ; std::_Uninit_move<wchar_t const *,wchar_t const *,wchar_t const *>(wchar_t const * *,wchar_t const * *,wchar_t const * *,std::_Wrap_alloc<std::allocator<wchar_t const *>> &,wchar_t const * *,std::_Scalar_ptr_iterator_tag)+4Fp ...
UNDEF:0000AC74 ; int __cdecl wcsncmp(const wchar_t *Str1, const wchar_t *Str2, size_t MaxCount)
UNDEF:0000AC74                 extrn _wcsncmp:near     ; CODE XREF: FunctionCallTip::getCursorFunction(void)+71Ep
UNDEF:0000AC78 ; int __stdcall lstrcmpW(LPCWSTR lpString1, LPCWSTR lpString2)
UNDEF:0000AC78                 extrn __imp__lstrcmpW@8:near
UNDEF:0000AC78                                         ; CODE XREF: FunctionCallTip::loadFunction(void)+B5p
UNDEF:0000AC78                                         ; FunctionCallTip::loadFunction(void)+E3p
UNDEF:0000AC78                                         ; DATA XREF: ...
UNDEF:0000AC7C ; LPWSTR __stdcall lstrcpyW(LPWSTR lpString1, LPCWSTR lpString2)
UNDEF:0000AC7C                 extrn __imp__lstrcpyW@8:near
UNDEF:0000AC7C                                         ; CODE XREF: FunctionCallTip::getCursorFunction(void)+7CDp
UNDEF:0000AC7C                                         ; DATA XREF: FunctionCallTip::getCursorFunction(void)+7CDr
UNDEF:0000AC80 ; LPWSTR __stdcall lstrcatW(LPWSTR lpString1, LPCWSTR lpString2)
UNDEF:0000AC80                 extrn __imp__lstrcatW@8:near
UNDEF:0000AC80                                         ; CODE XREF: FunctionCallTip::showCalltip(void)+2C1p
UNDEF:0000AC80                                         ; FunctionCallTip::showCalltip(void)+2D3p ...
UNDEF:0000AC84 ; int __stdcall lstrlenW(LPCWSTR lpString)
UNDEF:0000AC84                 extrn __imp__lstrlenW@4:near
UNDEF:0000AC84                                         ; CODE XREF: FunctionCallTip::getCursorFunction(void)+6B4p
UNDEF:0000AC84                                         ; FunctionCallTip::getCursorFunction(void)+706p ...
UNDEF:0000AC88 ; int _wsprintfW(LPWSTR, LPCWSTR, ...)
UNDEF:0000AC88                 extrn __imp__wsprintfW:near
UNDEF:0000AC88                                         ; CODE XREF: FunctionCallTip::showCalltip(void)+2AAp
UNDEF:0000AC88                                         ; DATA XREF: FunctionCallTip::showCalltip(void)+2AAr
UNDEF:0000AC8C ; _DWORD __thiscall std::_Lockit::_Lockit(std::_Lockit *__hidden this, int)
UNDEF:0000AC8C                 extrn ??0_Lockit@std@@QAE@H@Z:near
UNDEF:0000AC8C                                         ; CODE XREF: std::_Iterator_base12::~_Iterator_base12(void)+2Dp
UNDEF:0000AC8C                                         ; std::_Iterator_base12::operator=(std::_Iterator_base12 const &)+55p ...
UNDEF:0000AC90 ; _DWORD __thiscall std::_Lockit::~_Lockit(std::_Lockit *__hidden this)
UNDEF:0000AC90                 extrn ??1_Lockit@std@@QAE@XZ:near
UNDEF:0000AC90                                         ; CODE XREF: std::_Iterator_base12::~_Iterator_base12(void)+4Bp
UNDEF:0000AC90                                         ; __unwindfunclet$??1_Iterator_base12@std@@QAE@XZ$0+3j ...
UNDEF:0000AC94                 extrn __hypot:near      ; CODE XREF: _hypot+1Dp
UNDEF:0000AC98 ; void __cdecl operator delete[](void *)
UNDEF:0000AC98                 extrn ??_V@YAXPAX@Z:near
UNDEF:0000AC98                                         ; CODE XREF: FunctionCallTip::setLanguageXML(TiXmlElement *)+47p
UNDEF:0000AC98                                         ; FunctionCallTip::getCursorFunction(void)+77Dp ...
UNDEF:0000AC9C ; void *__cdecl operator new[](unsigned int)
UNDEF:0000AC9C                 extrn ??_U@YAPAXI@Z:near
UNDEF:0000AC9C                                         ; CODE XREF: FunctionCallTip::getCursorFunction(void)+79Fp
UNDEF:0000ACA0                 extrn __CrtDbgReportW:near
UNDEF:0000ACA0                                         ; CODE XREF: std::_Vector_const_iterator<std::_Vector_val<std::_Simple_types<FunctionValues>>>::operator*(void)+78p
UNDEF:0000ACA0                                         ; std::_Vector_const_iterator<std::_Vector_val<std::_Simple_types<FunctionValues>>>::operator+=(int)+82p
UNDEF:0000ACA4 ; void __cdecl std::_Debug_message(const wchar_t *, const wchar_t *, unsigned int)
UNDEF:0000ACA4                 extrn ?_Debug_message@std@@YAXPB_W0I@Z:near
UNDEF:0000ACA4                                         ; CODE XREF: std::_Debug_pointer<char>(char const *,wchar_t const *,uint)+16p
UNDEF:0000ACA4                                         ; std::_Debug_pointer<wchar_t const *>(wchar_t const * *,wchar_t const *,uint)+16p ...
UNDEF:0000ACA8 ; void __cdecl std::_Xbad_alloc()
UNDEF:0000ACA8                 extrn ?_Xbad_alloc@std@@YAXXZ:near
UNDEF:0000ACA8                                         ; CODE XREF: std::_Allocate<char>(uint,char *):loc_21CEp
UNDEF:0000ACA8                                         ; std::_Allocate<wchar_t const *>(uint,wchar_t const * *):loc_2210p ...
UNDEF:0000ACAC ; void __cdecl std::_Xlength_error(const char *)
UNDEF:0000ACAC                 extrn ?_Xlength_error@std@@YAXPBD@Z:near
UNDEF:0000ACAC                                         ; CODE XREF: std::basic_string<char,std::char_traits<char>,std::allocator<char>>::_Xlen(void)+Cp
UNDEF:0000ACAC                                         ; std::vector<wchar_t const *,std::allocator<wchar_t const *>>::_Xlen(void)+Cp ...
UNDEF:0000ACB0 ; void __cdecl std::_Xout_of_range(const char *)
UNDEF:0000ACB0                 extrn ?_Xout_of_range@std@@YAXPBD@Z:near
UNDEF:0000ACB0                                         ; CODE XREF: std::basic_string<char,std::char_traits<char>,std::allocator<char>>::_Xran(void)+Cp
UNDEF:0000ACB0                                         ; std::vector<wchar_t const *,std::allocator<wchar_t const *>>::_Xran(void)+Cp ...
UNDEF:0000ACB4 ; public: virtual void * __thiscall std::error_category::`vector deleting destructor'(unsigned int)
UNDEF:0000ACB4                 extrn ??_Eerror_category@std@@UAEPAXI@Z:near ; weak
UNDEF:0000ACB4                                         ; DATA XREF: .rdata:const std::error_category::`vftable'o
UNDEF:0000ACB8 ; const char *__cdecl std::_Syserror_map(int)
UNDEF:0000ACB8                 extrn ?_Syserror_map@std@@YAPBDH@Z:near
UNDEF:0000ACB8                                         ; CODE XREF: std::_System_error_category::default_error_condition(int)+Bp
UNDEF:0000ACB8                                         ; std::_Generic_error_category::message(int)+33p
UNDEF:0000ACBC ; const char *__cdecl std::_Winerror_map(int)
UNDEF:0000ACBC                 extrn ?_Winerror_map@std@@YAPBDH@Z:near
UNDEF:0000ACBC                                         ; CODE XREF: std::_System_error_category::message(int)+33p
UNDEF:0000ACC0 ; public: virtual void * __thiscall std::_Generic_error_category::`vector deleting destructor'(unsigned int)
UNDEF:0000ACC0                 extrn ??_E_Generic_error_category@std@@UAEPAXI@Z:near ; weak
UNDEF:0000ACC0                                         ; DATA XREF: .rdata:const std::_Generic_error_category::`vftable'o
UNDEF:0000ACC4 ; public: virtual void * __thiscall std::_Iostream_error_category::`vector deleting destructor'(unsigned int)
UNDEF:0000ACC4                 extrn ??_E_Iostream_error_category@std@@UAEPAXI@Z:near ; weak
UNDEF:0000ACC4                                         ; DATA XREF: .rdata:const std::_Iostream_error_category::`vftable'o
UNDEF:0000ACC8 ; public: virtual void * __thiscall std::_System_error_category::`vector deleting destructor'(unsigned int)
UNDEF:0000ACC8                 extrn ??_E_System_error_category@std@@UAEPAXI@Z:near ; weak
UNDEF:0000ACC8                                         ; DATA XREF: .rdata:const std::_System_error_category::`vftable'o
UNDEF:0000ACCC ; struct TiXmlElement *__thiscall TiXmlNode::NextSiblingElement(TiXmlNode *__hidden this, const wchar_t *)
UNDEF:0000ACCC                 extrn ?NextSiblingElement@TiXmlNode@@QBEPAVTiXmlElement@@PB_W@Z:near
UNDEF:0000ACCC                                         ; CODE XREF: FunctionCallTip::loadFunction(void)+4Dp
UNDEF:0000ACCC                                         ; FunctionCallTip::loadFunction(void)+149p ...
UNDEF:0000ACD0 ; struct TiXmlElement *__thiscall TiXmlNode::FirstChildElement(TiXmlNode *__hidden this, const wchar_t *)
UNDEF:0000ACD0                 extrn ?FirstChildElement@TiXmlNode@@QBEPAVTiXmlElement@@PB_W@Z:near
UNDEF:0000ACD0                                         ; CODE XREF: FunctionCallTip::loadFunction(void)+130p
UNDEF:0000ACD0                                         ; FunctionCallTip::loadFunction(void)+1C7p
UNDEF:0000ACD4 ; const wchar_t *__thiscall TiXmlElement::Attribute(TiXmlElement *__hidden this, const wchar_t *)
UNDEF:0000ACD4                 extrn ?Attribute@TiXmlElement@@QBEPB_WPB_W@Z:near
UNDEF:0000ACD4                                         ; CODE XREF: FunctionCallTip::loadFunction(void)+6Ep
UNDEF:0000ACD4                                         ; FunctionCallTip::loadFunction(void)+CCp ...
UNDEF:0000ACD8 ; void __thiscall ScintillaEditView::showCallTip(ScintillaEditView *__hidden this, int, const wchar_t *)
UNDEF:0000ACD8                 extrn ?showCallTip@ScintillaEditView@@QAEXHPB_W@Z:near
UNDEF:0000ACD8                                         ; CODE XREF: FunctionCallTip::showCalltip(void)+470p
UNDEF:0000ACDC ; void __thiscall ScintillaEditView::getLine(ScintillaEditView *__hidden this, int, wchar_t *, int)
UNDEF:0000ACDC                 extrn ?getLine@ScintillaEditView@@QAEXHPA_WH@Z:near
UNDEF:0000ACDC                                         ; CODE XREF: FunctionCallTip::getCursorFunction(void)+133p
UNDEF:0000ACE0 ; __fastcall __security_check_cookie(x)
UNDEF:0000ACE0                 extrn @__security_check_cookie@4:near
UNDEF:0000ACE0                                         ; CODE XREF: FunctionCallTip::getCursorFunction(void)+830p
UNDEF:0000ACE0                                         ; FunctionCallTip::showCalltip(void)+4B3p ...
UNDEF:0000ACE4 ; __stdcall _CxxThrowException(x, x)
UNDEF:0000ACE4                 extrn __CxxThrowException@8:near
UNDEF:0000ACE4                                         ; CODE XREF: __catch$??$_Uninit_move@PAUFunctionValues@@PAU1@V?$allocator@UFunctionValues@@@std@@U1@@std@@YAPAUFunctionValues@@PAU1@00AAU?$_Wrap_alloc@V?$allocator@UFunctionValues@@@std@@@0@0U_Nonscalar_ptr_iterator_tag@0@@Z$0+25p
UNDEF:0000ACE4                                         ; __catch$??$_Uninit_move@PAUToken@@PAU1@V?$allocator@UToken@@@std@@U1@@std@@YAPAUToken@@PAU1@00AAU?$_Wrap_alloc@V?$allocator@UToken@@@std@@@0@0U_Nonscalar_ptr_iterator_tag@0@@Z$0+25p ...
UNDEF:0000ACE8                 extrn ___CxxFrameHandler3:near
UNDEF:0000ACE8                                         ; CODE XREF: __ehhandler$?getCursorFunction@FunctionCallTip@@AAE_NXZ+23j
UNDEF:0000ACE8                                         ; __ehhandler$?loadFunction@FunctionCallTip@@AAE_NXZ+16j ...
UNDEF:0000ACEC                 extrn __chkstk:near     ; CODE XREF: FunctionCallTip::showCalltip(void)+8p
UNDEF:0000ACF0 ; void *__cdecl memset(void *Dst, int Val, size_t Size)
UNDEF:0000ACF0                 extrn _memset:near      ; CODE XREF: FunctionCallTip::getCursorFunction(void)+10Ep
UNDEF:0000ACF4 ; const type_info::`vftable'
UNDEF:0000ACF4                 extrn ??_7type_info@@6B@:near
UNDEF:0000ACF4                                         ; DATA XREF: .data$r:std::error_category `RTTI Type Descriptor'o
UNDEF:0000ACF4                                         ; .data$r:std::_Generic_error_category `RTTI Type Descriptor'o ...
UNDEF:0000ACF8                 extrn ___security_cookie:near
UNDEF:0000ACF8                                         ; DATA XREF: FunctionCallTip::getCursorFunction(void)+17r
UNDEF:0000ACF8                                         ; FunctionCallTip::loadFunction(void)+14r ...
UNDEF:0000ACFC                 extrn __fltused:near
UNDEF:0000ACFC
UNDEF:0000ACFC
UNDEF:0000ACFC                 end