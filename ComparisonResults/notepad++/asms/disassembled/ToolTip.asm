.rdata:00000000 ;
.rdata:00000000 ; +-------------------------------------------------------------------------+
.rdata:00000000 ; |   This file has been generated by The Interactive Disassembler (IDA)    |
.rdata:00000000 ; |           Copyright (c) 2015 Hex-Rays, <support@hex-rays.com>           |
.rdata:00000000 ; |                      License info: 48-3677-7074-51                      |
.rdata:00000000 ; |             Michalis Polychronakis, Stony Brook University              |
.rdata:00000000 ; +-------------------------------------------------------------------------+
.rdata:00000000 ;
.rdata:00000000 ; Input MD5   : 79EA8821E1C15E8726E21B1E7A04CA0B
.rdata:00000000 ; Input CRC32 : DFFC59D5
.rdata:00000000
.rdata:00000000 ; File Name   : C:\workspace\notepad-plus-plus-6.7.9.2\PowerEditor\visual.net\Unicode Debug\ToolTip.obj
.rdata:00000000 ; Format      : COFF (X386MAGIC)
.rdata:00000000 ; includelib "libcpmtd"
.rdata:00000000 ; includelib "uuid.lib"
.rdata:00000000 ; must resolve: ?_Generic_object@?$_Error_objects@H@std@@2V_Generic_error_category@2@A
.rdata:00000000 ; must resolve: ?_Iostream_object@?$_Error_objects@H@std@@2V_Iostream_error_category@2@A
.rdata:00000000 ; must resolve: ?_System_object@?$_Error_objects@H@std@@2V_System_error_category@2@A
.rdata:00000000 ; includelib "LIBCMTD"
.rdata:00000000 ; includelib "OLDNAMES"
.rdata:00000000
.rdata:00000000                 include uni.inc ; see unicode subdir of ida for info on unicode
.rdata:00000000
.rdata:00000000                 .686p
.rdata:00000000                 .mmx
.rdata:00000000                 .model flat
.rdata:00000000
.rdata:00000000 ; ===========================================================================
.rdata:00000000
.rdata:00000000 ; Segment type: Pure data
.rdata:00000000 ; Segment permissions: Read
.rdata:00000000 _rdata          segment dword public 'DATA' use32
.rdata:00000000                 assume cs:_rdata
.rdata:00000000 ; const WCHAR _SG94143
.rdata:00000000 $SG94143:                               ; DATA XREF: ToolTip::init(HINSTANCE__ *,HWND__ *)+49o
.rdata:00000000                 unicode 0, <tooltips_class32>,0
.rdata:00000022                 align 4
.rdata:00000024 ; char _SG94147[]
.rdata:00000024 $SG94147        db 'ToolTip::init : CreateWindowEx() function return null',0
.rdata:00000024                                         ; DATA XREF: ToolTip::init(HINSTANCE__ *,HWND__ *)+65o
.rdata:0000005A                 align 4
.rdata:0000005A _rdata          ends
.rdata:0000005A
.text$mn:0000005C ; ===========================================================================
.text$mn:0000005C
.text$mn:0000005C ; Segment type: Pure code
.text$mn:0000005C ; Segment permissions: Read/Execute
.text$mn:0000005C _text$mn        segment para public 'CODE' use32
.text$mn:0000005C                 assume cs:_text$mn
.text$mn:0000005C                 ;org 5Ch
.text$mn:0000005C                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text$mn:0000005C
.text$mn:0000005C ; =============== S U B R O U T I N E =======================================
.text$mn:0000005C
.text$mn:0000005C ; Attributes: bp-based frame
.text$mn:0000005C
.text$mn:0000005C ; void __thiscall ToolTip::init(ToolTip *this, HINSTANCE, HWND)
.text$mn:0000005C                 public ?init@ToolTip@@UAEXPAUHINSTANCE__@@PAUHWND__@@@Z
.text$mn:0000005C ?init@ToolTip@@UAEXPAUHINSTANCE__@@PAUHWND__@@@Z proc near
.text$mn:0000005C
.text$mn:0000005C var_10          = byte ptr -10h
.text$mn:0000005C dwNewLong       = dword ptr -4
.text$mn:0000005C arg_0           = dword ptr  8
.text$mn:0000005C arg_4           = dword ptr  0Ch
.text$mn:0000005C
.text$mn:0000005C                 push    ebp
.text$mn:0000005D                 mov     ebp, esp
.text$mn:0000005F                 sub     esp, 10h
.text$mn:00000062                 mov     [ebp+dwNewLong], ecx
.text$mn:00000065                 mov     eax, [ebp+dwNewLong]
.text$mn:00000068                 cmp     dword ptr [eax+0Ch], 0
.text$mn:0000006C                 jnz     loc_109
.text$mn:00000072                 mov     ecx, [ebp+arg_4]
.text$mn:00000075                 push    ecx             ; HWND
.text$mn:00000076                 mov     edx, [ebp+arg_0]
.text$mn:00000079                 push    edx             ; HINSTANCE
.text$mn:0000007A                 mov     ecx, [ebp+dwNewLong] ; this
.text$mn:0000007D                 call    ?init@Window@@UAEXPAUHINSTANCE__@@PAUHWND__@@@Z ; Window::init(HINSTANCE__ *,HWND__ *)
.text$mn:00000082                 push    0               ; lpParam
.text$mn:00000084                 push    0               ; hInstance
.text$mn:00000086                 push    0               ; hMenu
.text$mn:00000088                 push    0               ; hWndParent
.text$mn:0000008A                 push    80000000h       ; nHeight
.text$mn:0000008F                 push    80000000h       ; nWidth
.text$mn:00000094                 push    80000000h       ; Y
.text$mn:00000099                 push    80000000h       ; X
.text$mn:0000009E                 push    80000003h       ; dwStyle
.text$mn:000000A3                 push    0               ; lpWindowName
.text$mn:000000A5                 push    offset $SG94143 ; "tooltips_class32"
.text$mn:000000AA                 push    0               ; dwExStyle
.text$mn:000000AC                 call    dword ptr ds:__imp__CreateWindowExW@48 ; CreateWindowExW(x,x,x,x,x,x,x,x,x,x,x,x)
.text$mn:000000B2                 mov     ecx, [ebp+dwNewLong]
.text$mn:000000B5                 mov     [ecx+0Ch], eax
.text$mn:000000B8                 mov     edx, [ebp+dwNewLong]
.text$mn:000000BB                 cmp     dword ptr [edx+0Ch], 0
.text$mn:000000BF                 jnz     short loc_DC
.text$mn:000000C1                 push    offset $SG94147 ; "ToolTip::init : CreateWindowEx() functi"...
.text$mn:000000C6                 lea     ecx, [ebp+var_10] ; this
.text$mn:000000C9                 call    ??0runtime_error@std@@QAE@PBD@Z ; std::runtime_error::runtime_error(char const *)
.text$mn:000000CE                 push    offset __TI2?AVruntime_error@std@@
.text$mn:000000D3                 lea     eax, [ebp+var_10]
.text$mn:000000D6                 push    eax
.text$mn:000000D7                 call    __CxxThrowException@8 ; _CxxThrowException(x,x)
.text$mn:000000DC ; ---------------------------------------------------------------------------
.text$mn:000000DC
.text$mn:000000DC loc_DC:                                 ; CODE XREF: ToolTip::init(HINSTANCE__ *,HWND__ *)+63j
.text$mn:000000DC                 mov     ecx, [ebp+dwNewLong]
.text$mn:000000DF                 push    ecx             ; dwNewLong
.text$mn:000000E0                 push    0FFFFFFEBh      ; nIndex
.text$mn:000000E2                 mov     edx, [ebp+dwNewLong]
.text$mn:000000E5                 mov     eax, [edx+0Ch]
.text$mn:000000E8                 push    eax             ; hWnd
.text$mn:000000E9                 call    dword ptr ds:__imp__SetWindowLongW@12 ; SetWindowLongW(x,x,x)
.text$mn:000000EF                 push    offset ?staticWinProc@ToolTip@@KGJPAUHWND__@@IIJ@Z ; dwNewLong
.text$mn:000000F4                 push    0FFFFFFFCh      ; nIndex
.text$mn:000000F6                 mov     ecx, [ebp+dwNewLong]
.text$mn:000000F9                 mov     edx, [ecx+0Ch]
.text$mn:000000FC                 push    edx             ; hWnd
.text$mn:000000FD                 call    dword ptr ds:__imp__SetWindowLongW@12 ; SetWindowLongW(x,x,x)
.text$mn:00000103                 mov     ecx, [ebp+dwNewLong]
.text$mn:00000106                 mov     [ecx+10h], eax
.text$mn:00000109
.text$mn:00000109 loc_109:                                ; CODE XREF: ToolTip::init(HINSTANCE__ *,HWND__ *)+10j
.text$mn:00000109                 mov     esp, ebp
.text$mn:0000010B                 pop     ebp
.text$mn:0000010C                 retn    8
.text$mn:0000010C ?init@ToolTip@@UAEXPAUHINSTANCE__@@PAUHWND__@@@Z endp
.text$mn:0000010C
.text$mn:0000010C ; ---------------------------------------------------------------------------
.text$mn:0000010F                 db 0Dh dup(0CCh)
.text$mn:0000011C
.text$mn:0000011C ; =============== S U B R O U T I N E =======================================
.text$mn:0000011C
.text$mn:0000011C ; Attributes: bp-based frame
.text$mn:0000011C
.text$mn:0000011C ; void __thiscall ToolTip::Show(ToolTip *this, struct tagRECT, LPCWSTR lpString, int, int)
.text$mn:0000011C                 public ?Show@ToolTip@@QAEXUtagRECT@@PB_WHH@Z
.text$mn:0000011C ?Show@ToolTip@@QAEXUtagRECT@@PB_WHH@Z proc near
.text$mn:0000011C
.text$mn:0000011C wParam          = dword ptr -8
.text$mn:0000011C var_4           = dword ptr -4
.text$mn:0000011C arg_0           = tagRECT ptr  8
.text$mn:0000011C lpString        = dword ptr  18h
.text$mn:0000011C arg_14          = dword ptr  1Ch
.text$mn:0000011C arg_18          = dword ptr  20h
.text$mn:0000011C
.text$mn:0000011C                 push    ebp
.text$mn:0000011D                 mov     ebp, esp
.text$mn:0000011F                 sub     esp, 8
.text$mn:00000122                 mov     [ebp+var_4], ecx
.text$mn:00000125                 mov     eax, [ebp+var_4]
.text$mn:00000128                 mov     edx, [eax]
.text$mn:0000012A                 mov     ecx, [ebp+var_4]
.text$mn:0000012D                 mov     eax, [edx+2Ch]
.text$mn:00000130                 call    eax
.text$mn:00000132                 movzx   ecx, al
.text$mn:00000135                 test    ecx, ecx
.text$mn:00000137                 jz      short loc_146
.text$mn:00000139                 mov     edx, [ebp+var_4]
.text$mn:0000013C                 mov     eax, [edx]
.text$mn:0000013E                 mov     ecx, [ebp+var_4]
.text$mn:00000141                 mov     edx, [eax+8]
.text$mn:00000144                 call    edx
.text$mn:00000146
.text$mn:00000146 loc_146:                                ; CODE XREF: ToolTip::Show(tagRECT,wchar_t const *,int,int)+1Bj
.text$mn:00000146                 mov     eax, [ebp+lpString]
.text$mn:00000149                 push    eax             ; lpString
.text$mn:0000014A                 call    dword ptr ds:__imp__lstrlenW@4 ; lstrlenW(x)
.text$mn:00000150                 test    eax, eax
.text$mn:00000152                 jnz     short loc_159
.text$mn:00000154                 jmp     loc_262
.text$mn:00000159 ; ---------------------------------------------------------------------------
.text$mn:00000159
.text$mn:00000159 loc_159:                                ; CODE XREF: ToolTip::Show(tagRECT,wchar_t const *,int,int)+36j
.text$mn:00000159                 mov     ecx, [ebp+var_4]
.text$mn:0000015C                 mov     dword ptr [ecx+18h], 30h ; '0'
.text$mn:00000163                 mov     edx, [ebp+var_4]
.text$mn:00000166                 mov     dword ptr [edx+1Ch], 0A0h ; 'รก'
.text$mn:0000016D                 mov     eax, [ebp+var_4]
.text$mn:00000170                 mov     ecx, [eax+8]
.text$mn:00000173                 push    ecx             ; hWnd
.text$mn:00000174                 call    dword ptr ds:__imp__GetParent@4 ; GetParent(x)
.text$mn:0000017A                 mov     edx, [ebp+var_4]
.text$mn:0000017D                 mov     [edx+20h], eax
.text$mn:00000180                 mov     eax, [ebp+var_4]
.text$mn:00000183                 mov     ecx, [ebp+var_4]
.text$mn:00000186                 mov     edx, [ecx+4]
.text$mn:00000189                 mov     [eax+38h], edx
.text$mn:0000018C                 mov     eax, [ebp+var_4]
.text$mn:0000018F                 mov     dword ptr [eax+24h], 0
.text$mn:00000196                 mov     ecx, [ebp+var_4]
.text$mn:00000199                 mov     edx, [ebp+arg_0.left]
.text$mn:0000019C                 mov     [ecx+28h], edx
.text$mn:0000019F                 mov     eax, [ebp+var_4]
.text$mn:000001A2                 mov     ecx, [ebp+arg_0.top]
.text$mn:000001A5                 mov     [eax+2Ch], ecx
.text$mn:000001A8                 mov     edx, [ebp+var_4]
.text$mn:000001AB                 mov     eax, [ebp+arg_0.right]
.text$mn:000001AE                 mov     [edx+30h], eax
.text$mn:000001B1                 mov     ecx, [ebp+var_4]
.text$mn:000001B4                 mov     edx, [ebp+arg_0.bottom]
.text$mn:000001B7                 mov     [ecx+34h], edx
.text$mn:000001BA                 push    0               ; lParam
.text$mn:000001BC                 push    0               ; wParam
.text$mn:000001BE                 push    31h ; '1'       ; Msg
.text$mn:000001C0                 mov     eax, [ebp+var_4]
.text$mn:000001C3                 mov     ecx, [eax+8]
.text$mn:000001C6                 push    ecx             ; hWnd
.text$mn:000001C7                 call    dword ptr ds:__imp__SendMessageW@16 ; SendMessageW(x,x,x,x)
.text$mn:000001CD                 mov     [ebp+wParam], eax
.text$mn:000001D0                 push    1               ; lParam
.text$mn:000001D2                 mov     edx, [ebp+wParam]
.text$mn:000001D5                 push    edx             ; wParam
.text$mn:000001D6                 push    30h ; '0'       ; Msg
.text$mn:000001D8                 mov     eax, [ebp+var_4]
.text$mn:000001DB                 mov     ecx, [eax+0Ch]
.text$mn:000001DE                 push    ecx             ; hWnd
.text$mn:000001DF                 call    dword ptr ds:__imp__SendMessageW@16 ; SendMessageW(x,x,x,x)
.text$mn:000001E5                 mov     edx, [ebp+var_4]
.text$mn:000001E8                 mov     eax, [ebp+lpString]
.text$mn:000001EB                 mov     [edx+3Ch], eax
.text$mn:000001EE                 mov     ecx, [ebp+var_4]
.text$mn:000001F1                 add     ecx, 18h
.text$mn:000001F4                 push    ecx             ; lParam
.text$mn:000001F5                 push    0               ; wParam
.text$mn:000001F7                 push    432h            ; Msg
.text$mn:000001FC                 mov     edx, [ebp+var_4]
.text$mn:000001FF                 mov     eax, [edx+0Ch]
.text$mn:00000202                 push    eax             ; hWnd
.text$mn:00000203                 call    dword ptr ds:__imp__SendMessageW@16 ; SendMessageW(x,x,x,x)
.text$mn:00000209                 mov     ecx, [ebp+var_4]
.text$mn:0000020C                 mov     edx, [ecx+28h]
.text$mn:0000020F                 add     edx, [ebp+arg_14]
.text$mn:00000212                 and     edx, 0FFFFh
.text$mn:00000218                 movzx   eax, dx
.text$mn:0000021B                 mov     ecx, [ebp+var_4]
.text$mn:0000021E                 mov     edx, [ecx+2Ch]
.text$mn:00000221                 add     edx, [ebp+arg_18]
.text$mn:00000224                 and     edx, 0FFFFh
.text$mn:0000022A                 movzx   ecx, dx
.text$mn:0000022D                 shl     ecx, 10h
.text$mn:00000230                 or      eax, ecx
.text$mn:00000232                 push    eax             ; lParam
.text$mn:00000233                 push    0               ; wParam
.text$mn:00000235                 push    412h            ; Msg
.text$mn:0000023A                 mov     edx, [ebp+var_4]
.text$mn:0000023D                 mov     eax, [edx+0Ch]
.text$mn:00000240                 push    eax             ; hWnd
.text$mn:00000241                 call    dword ptr ds:__imp__SendMessageW@16 ; SendMessageW(x,x,x,x)
.text$mn:00000247                 mov     ecx, [ebp+var_4]
.text$mn:0000024A                 add     ecx, 18h
.text$mn:0000024D                 push    ecx             ; lParam
.text$mn:0000024E                 push    1               ; wParam
.text$mn:00000250                 push    411h            ; Msg
.text$mn:00000255                 mov     edx, [ebp+var_4]
.text$mn:00000258                 mov     eax, [edx+0Ch]
.text$mn:0000025B                 push    eax             ; hWnd
.text$mn:0000025C                 call    dword ptr ds:__imp__SendMessageW@16 ; SendMessageW(x,x,x,x)
.text$mn:00000262
.text$mn:00000262 loc_262:                                ; CODE XREF: ToolTip::Show(tagRECT,wchar_t const *,int,int)+38j
.text$mn:00000262                 mov     esp, ebp
.text$mn:00000264                 pop     ebp
.text$mn:00000265                 retn    1Ch
.text$mn:00000265 ?Show@ToolTip@@QAEXUtagRECT@@PB_WHH@Z endp
.text$mn:00000265
.text$mn:00000265 ; ---------------------------------------------------------------------------
.text$mn:00000268                 db 4 dup(0CCh)
.text$mn:0000026C
.text$mn:0000026C ; =============== S U B R O U T I N E =======================================
.text$mn:0000026C
.text$mn:0000026C ; Attributes: bp-based frame
.text$mn:0000026C
.text$mn:0000026C ; __int32 __thiscall ToolTip::runProc(ToolTip *this, UINT Msg, WPARAM wParam, __int32)
.text$mn:0000026C                 public ?runProc@ToolTip@@IAEJIIJ@Z
.text$mn:0000026C ?runProc@ToolTip@@IAEJIIJ@Z proc near   ; CODE XREF: ToolTip::staticWinProc(HWND__ *,uint,uint,long)+1Dp
.text$mn:0000026C
.text$mn:0000026C var_4           = dword ptr -4
.text$mn:0000026C Msg             = dword ptr  8
.text$mn:0000026C wParam          = dword ptr  0Ch
.text$mn:0000026C lParam          = dword ptr  10h
.text$mn:0000026C
.text$mn:0000026C                 push    ebp
.text$mn:0000026D                 mov     ebp, esp
.text$mn:0000026F                 push    ecx
.text$mn:00000270                 mov     [ebp+var_4], ecx
.text$mn:00000273                 mov     eax, [ebp+lParam]
.text$mn:00000276                 push    eax             ; lParam
.text$mn:00000277                 mov     ecx, [ebp+wParam]
.text$mn:0000027A                 push    ecx             ; wParam
.text$mn:0000027B                 mov     edx, [ebp+Msg]
.text$mn:0000027E                 push    edx             ; Msg
.text$mn:0000027F                 mov     eax, [ebp+var_4]
.text$mn:00000282                 mov     ecx, [eax+0Ch]
.text$mn:00000285                 push    ecx             ; hWnd
.text$mn:00000286                 mov     edx, [ebp+var_4]
.text$mn:00000289                 mov     eax, [edx+10h]
.text$mn:0000028C                 push    eax             ; lpPrevWndFunc
.text$mn:0000028D                 call    dword ptr ds:__imp__CallWindowProcW@20 ; CallWindowProcW(x,x,x,x,x)
.text$mn:00000293                 mov     esp, ebp
.text$mn:00000295                 pop     ebp
.text$mn:00000296                 retn    0Ch
.text$mn:00000296 ?runProc@ToolTip@@IAEJIIJ@Z endp
.text$mn:00000296
.text$mn:00000296 ; ---------------------------------------------------------------------------
.text$mn:00000299                 align 4
.text$mn:00000299 _text$mn        ends
.text$mn:00000299
.text$mn:0000029C ; ===========================================================================
.text$mn:0000029C
.text$mn:0000029C ; Segment type: Pure code
.text$mn:0000029C ; Segment permissions: Read/Execute
.text$mn:0000029C _text$mn        segment para public 'CODE' use32
.text$mn:0000029C                 assume cs:_text$mn
.text$mn:0000029C                 ;org 29Ch
.text$mn:0000029C ; COMDAT (pick any)
.text$mn:0000029C                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text$mn:0000029C
.text$mn:0000029C ; =============== S U B R O U T I N E =======================================
.text$mn:0000029C
.text$mn:0000029C ; Attributes: bp-based frame
.text$mn:0000029C
.text$mn:0000029C ; char * __cdecl std::_Allocate<char>(unsigned int, char *)
.text$mn:0000029C                 public ??$_Allocate@D@std@@YAPADIPAD@Z
.text$mn:0000029C ??$_Allocate@D@std@@YAPADIPAD@Z proc near
.text$mn:0000029C                                         ; CODE XREF: std::allocator<char>::allocate(uint)+Dp
.text$mn:0000029C
.text$mn:0000029C var_4           = dword ptr -4
.text$mn:0000029C arg_0           = dword ptr  8
.text$mn:0000029C
.text$mn:0000029C                 push    ebp
.text$mn:0000029D                 mov     ebp, esp
.text$mn:0000029F                 push    ecx
.text$mn:000002A0                 mov     [ebp+var_4], 0
.text$mn:000002A7                 cmp     [ebp+arg_0], 0
.text$mn:000002AB                 jnz     short loc_2AF
.text$mn:000002AD                 jmp     short loc_2CF
.text$mn:000002AF ; ---------------------------------------------------------------------------
.text$mn:000002AF
.text$mn:000002AF loc_2AF:                                ; CODE XREF: std::_Allocate<char>(uint,char *)+Fj
.text$mn:000002AF                 cmp     [ebp+arg_0], 0FFFFFFFFh
.text$mn:000002B3                 ja      short loc_2CA
.text$mn:000002B5                 mov     eax, [ebp+arg_0]
.text$mn:000002B8                 push    eax             ; unsigned int
.text$mn:000002B9                 call    ??2@YAPAXI@Z    ; operator new(uint)
.text$mn:000002BE                 add     esp, 4
.text$mn:000002C1                 mov     [ebp+var_4], eax
.text$mn:000002C4                 cmp     [ebp+var_4], 0
.text$mn:000002C8                 jnz     short loc_2CF
.text$mn:000002CA
.text$mn:000002CA loc_2CA:                                ; CODE XREF: std::_Allocate<char>(uint,char *)+17j
.text$mn:000002CA                 call    ?_Xbad_alloc@std@@YAXXZ ; std::_Xbad_alloc(void)
.text$mn:000002CF
.text$mn:000002CF loc_2CF:                                ; CODE XREF: std::_Allocate<char>(uint,char *)+11j
.text$mn:000002CF                                         ; std::_Allocate<char>(uint,char *)+2Cj
.text$mn:000002CF                 mov     eax, [ebp+var_4]
.text$mn:000002D2                 mov     esp, ebp
.text$mn:000002D4                 pop     ebp
.text$mn:000002D5                 retn
.text$mn:000002D5 ??$_Allocate@D@std@@YAPADIPAD@Z endp
.text$mn:000002D5
.text$mn:000002D5 ; ---------------------------------------------------------------------------
.text$mn:000002D6                 align 4
.text$mn:000002D6 _text$mn        ends
.text$mn:000002D6
.text$mn:000002D8 ; ===========================================================================
.text$mn:000002D8
.text$mn:000002D8 ; Segment type: Pure code
.text$mn:000002D8 ; Segment permissions: Read/Execute
.text$mn:000002D8 _text$mn        segment para public 'CODE' use32
.text$mn:000002D8                 assume cs:_text$mn
.text$mn:000002D8                 ;org 2D8h
.text$mn:000002D8 ; COMDAT (pick any)
.text$mn:000002D8                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text$mn:000002D8
.text$mn:000002D8 ; =============== S U B R O U T I N E =======================================
.text$mn:000002D8
.text$mn:000002D8 ; Attributes: bp-based frame
.text$mn:000002D8
.text$mn:000002D8 ; struct std::_Container_proxy * __cdecl std::_Allocate<struct std::_Container_proxy>(unsigned int, struct std::_Container_proxy *)
.text$mn:000002D8                 public ??$_Allocate@U_Container_proxy@std@@@std@@YAPAU_Container_proxy@0@IPAU10@@Z
.text$mn:000002D8 ??$_Allocate@U_Container_proxy@std@@@std@@YAPAU_Container_proxy@0@IPAU10@@Z proc near
.text$mn:000002D8                                         ; CODE XREF: std::allocator<std::_Container_proxy>::allocate(uint)+Dp
.text$mn:000002D8
.text$mn:000002D8 var_4           = dword ptr -4
.text$mn:000002D8 arg_0           = dword ptr  8
.text$mn:000002D8
.text$mn:000002D8                 push    ebp
.text$mn:000002D9                 mov     ebp, esp
.text$mn:000002DB                 push    ecx
.text$mn:000002DC                 mov     [ebp+var_4], 0
.text$mn:000002E3                 cmp     [ebp+arg_0], 0
.text$mn:000002E7                 jnz     short loc_2EB
.text$mn:000002E9                 jmp     short loc_311
.text$mn:000002EB ; ---------------------------------------------------------------------------
.text$mn:000002EB
.text$mn:000002EB loc_2EB:                                ; CODE XREF: std::_Allocate<std::_Container_proxy>(uint,std::_Container_proxy *)+Fj
.text$mn:000002EB                 cmp     [ebp+arg_0], 1FFFFFFFh
.text$mn:000002F2                 ja      short loc_30C
.text$mn:000002F4                 mov     eax, [ebp+arg_0]
.text$mn:000002F7                 shl     eax, 3
.text$mn:000002FA                 push    eax             ; unsigned int
.text$mn:000002FB                 call    ??2@YAPAXI@Z    ; operator new(uint)
.text$mn:00000300                 add     esp, 4
.text$mn:00000303                 mov     [ebp+var_4], eax
.text$mn:00000306                 cmp     [ebp+var_4], 0
.text$mn:0000030A                 jnz     short loc_311
.text$mn:0000030C
.text$mn:0000030C loc_30C:                                ; CODE XREF: std::_Allocate<std::_Container_proxy>(uint,std::_Container_proxy *)+1Aj
.text$mn:0000030C                 call    ?_Xbad_alloc@std@@YAXXZ ; std::_Xbad_alloc(void)
.text$mn:00000311
.text$mn:00000311 loc_311:                                ; CODE XREF: std::_Allocate<std::_Container_proxy>(uint,std::_Container_proxy *)+11j
.text$mn:00000311                                         ; std::_Allocate<std::_Container_proxy>(uint,std::_Container_proxy *)+32j
.text$mn:00000311                 mov     eax, [ebp+var_4]
.text$mn:00000314                 mov     esp, ebp
.text$mn:00000316                 pop     ebp
.text$mn:00000317                 retn
.text$mn:00000317 ??$_Allocate@U_Container_proxy@std@@@std@@YAPAU_Container_proxy@0@IPAU10@@Z endp
.text$mn:00000317
.text$mn:00000317 _text$mn        ends
.text$mn:00000317
.text$mn:00000318 ; ===========================================================================
.text$mn:00000318
.text$mn:00000318 ; Segment type: Pure code
.text$mn:00000318 ; Segment permissions: Read/Execute
.text$mn:00000318 _text$mn        segment para public 'CODE' use32
.text$mn:00000318                 assume cs:_text$mn
.text$mn:00000318                 ;org 318h
.text$mn:00000318 ; COMDAT (pick any)
.text$mn:00000318                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text$mn:00000318
.text$mn:00000318 ; =============== S U B R O U T I N E =======================================
.text$mn:00000318
.text$mn:00000318 ; Attributes: bp-based frame
.text$mn:00000318
.text$mn:00000318 ; int __cdecl std::_Debug_pointer<char>(int, wchar_t *, unsigned int)
.text$mn:00000318                 public ??$_Debug_pointer@D@std@@YAXPBDPB_WI@Z
.text$mn:00000318 ??$_Debug_pointer@D@std@@YAXPBDPB_WI@Z proc near
.text$mn:00000318                                         ; CODE XREF: std::basic_string<char,std::char_traits<char>,std::allocator<char>>::assign(char const *)+15p
.text$mn:00000318                                         ; std::basic_string<char,std::char_traits<char>,std::allocator<char>>::assign(char const *,uint)+1Bp
.text$mn:00000318
.text$mn:00000318 arg_0           = dword ptr  8
.text$mn:00000318 arg_4           = dword ptr  0Ch
.text$mn:00000318 arg_8           = dword ptr  10h
.text$mn:00000318
.text$mn:00000318                 push    ebp
.text$mn:00000319                 mov     ebp, esp
.text$mn:0000031B                 cmp     [ebp+arg_0], 0
.text$mn:0000031F                 jnz     short loc_336
.text$mn:00000321                 mov     eax, [ebp+arg_8]
.text$mn:00000324                 push    eax             ; unsigned int
.text$mn:00000325                 mov     ecx, [ebp+arg_4]
.text$mn:00000328                 push    ecx             ; wchar_t *
.text$mn:00000329                 push    offset ??_C@_1CK@EOPGIILJ@?$AAi?$AAn?$AAv?$AAa?$AAl?$AAi?$AAd?$AA?5?$AAn?$AAu?$AAl?$AAl?$AA?5?$AAp?$AAo?$AAi?$AAn?$AAt?$AAe?$AAr?$AA?$AA@ ; "invalid null pointer"
.text$mn:0000032E                 call    ?_Debug_message@std@@YAXPB_W0I@Z ; std::_Debug_message(wchar_t const *,wchar_t const *,uint)
.text$mn:00000333                 add     esp, 0Ch
.text$mn:00000336
.text$mn:00000336 loc_336:                                ; CODE XREF: std::_Debug_pointer<char>(char const *,wchar_t const *,uint)+7j
.text$mn:00000336                 pop     ebp
.text$mn:00000337                 retn
.text$mn:00000337 ??$_Debug_pointer@D@std@@YAXPBDPB_WI@Z endp
.text$mn:00000337
.text$mn:00000337 _text$mn        ends
.text$mn:00000337
.text$mn:00000338 ; ===========================================================================
.text$mn:00000338
.text$mn:00000338 ; Segment type: Pure code
.text$mn:00000338 ; Segment permissions: Read/Execute
.text$mn:00000338 _text$mn        segment para public 'CODE' use32
.text$mn:00000338                 assume cs:_text$mn
.text$mn:00000338                 ;org 338h
.text$mn:00000338 ; COMDAT (pick any)
.text$mn:00000338                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text$mn:00000338
.text$mn:00000338 ; =============== S U B R O U T I N E =======================================
.text$mn:00000338
.text$mn:00000338 ; Attributes: bp-based frame
.text$mn:00000338
.text$mn:00000338 ; char * __cdecl std::addressof<char>(char &)
.text$mn:00000338                 public ??$addressof@D@std@@YAPADAAD@Z
.text$mn:00000338 ??$addressof@D@std@@YAPADAAD@Z proc near
.text$mn:00000338                                         ; CODE XREF: std::_String_val<std::_Simple_types<char>>::_Myptr(void)+19p
.text$mn:00000338                                         ; std::_String_val<std::_Simple_types<char>>::_Myptr(void)+19p ...
.text$mn:00000338
.text$mn:00000338 arg_0           = dword ptr  8
.text$mn:00000338
.text$mn:00000338                 push    ebp
.text$mn:00000339                 mov     ebp, esp
.text$mn:0000033B                 mov     eax, [ebp+arg_0]
.text$mn:0000033E                 pop     ebp
.text$mn:0000033F                 retn
.text$mn:0000033F ??$addressof@D@std@@YAPADAAD@Z endp
.text$mn:0000033F
.text$mn:0000033F _text$mn        ends
.text$mn:0000033F
.text$mn:00000340 ; ===========================================================================
.text$mn:00000340
.text$mn:00000340 ; Segment type: Pure code
.text$mn:00000340 ; Segment permissions: Read/Execute
.text$mn:00000340 _text$mn        segment para public 'CODE' use32
.text$mn:00000340                 assume cs:_text$mn
.text$mn:00000340                 ;org 340h
.text$mn:00000340 ; COMDAT (pick any)
.text$mn:00000340                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text$mn:00000340
.text$mn:00000340 ; =============== S U B R O U T I N E =======================================
.text$mn:00000340
.text$mn:00000340 ; Attributes: bp-based frame
.text$mn:00000340
.text$mn:00000340 ; int __stdcall std::_Wrap_alloc<std::allocator<char>>::construct<char *,char * &>(void *, int)
.text$mn:00000340                 public ??$construct@PADAAPAD@?$_Wrap_alloc@V?$allocator@D@std@@@std@@QAEXPAPADAAPAD@Z
.text$mn:00000340 ??$construct@PADAAPAD@?$_Wrap_alloc@V?$allocator@D@std@@@std@@QAEXPAPADAAPAD@Z proc near
.text$mn:00000340                                         ; CODE XREF: $LN19+4Bp
.text$mn:00000340
.text$mn:00000340 var_4           = dword ptr -4
.text$mn:00000340 arg_0           = dword ptr  8
.text$mn:00000340 arg_4           = dword ptr  0Ch
.text$mn:00000340
.text$mn:00000340                 push    ebp
.text$mn:00000341                 mov     ebp, esp
.text$mn:00000343                 push    ecx
.text$mn:00000344                 mov     [ebp+var_4], ecx
.text$mn:00000347                 mov     eax, [ebp+arg_4]
.text$mn:0000034A                 push    eax
.text$mn:0000034B                 call    ??$forward@AAPAD@std@@YAAAPADAAPAD@Z ; std::forward<char * &>(char * &)
.text$mn:00000350                 add     esp, 4
.text$mn:00000353                 push    eax             ; int
.text$mn:00000354                 mov     ecx, [ebp+arg_0]
.text$mn:00000357                 push    ecx             ; void *
.text$mn:00000358                 mov     edx, [ebp+var_4]
.text$mn:0000035B                 push    edx             ; int
.text$mn:0000035C                 call    ??$construct@PADAAPAD@?$allocator_traits@V?$allocator@D@std@@@std@@SAXAAV?$allocator@D@1@PAPADAAPAD@Z ; std::allocator_traits<std::allocator<char>>::construct<char *,char * &>(std::allocator<char> &,char * *,char * &)
.text$mn:00000361                 add     esp, 0Ch
.text$mn:00000364                 mov     esp, ebp
.text$mn:00000366                 pop     ebp
.text$mn:00000367                 retn    8
.text$mn:00000367 ??$construct@PADAAPAD@?$_Wrap_alloc@V?$allocator@D@std@@@std@@QAEXPAPADAAPAD@Z endp
.text$mn:00000367
.text$mn:00000367 ; ---------------------------------------------------------------------------
.text$mn:0000036A                 align 4
.text$mn:0000036A _text$mn        ends
.text$mn:0000036A
.text$mn:0000036C ; ===========================================================================
.text$mn:0000036C
.text$mn:0000036C ; Segment type: Pure code
.text$mn:0000036C ; Segment permissions: Read/Execute
.text$mn:0000036C _text$mn        segment para public 'CODE' use32
.text$mn:0000036C                 assume cs:_text$mn
.text$mn:0000036C                 ;org 36Ch
.text$mn:0000036C ; COMDAT (pick any)
.text$mn:0000036C                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text$mn:0000036C
.text$mn:0000036C ; =============== S U B R O U T I N E =======================================
.text$mn:0000036C
.text$mn:0000036C ; Attributes: bp-based frame
.text$mn:0000036C
.text$mn:0000036C ; int __stdcall std::allocator<char>::construct<char *,char * &>(void *, int)
.text$mn:0000036C                 public ??$construct@PADAAPAD@?$allocator@D@std@@QAEXPAPADAAPAD@Z
.text$mn:0000036C ??$construct@PADAAPAD@?$allocator@D@std@@QAEXPAPADAAPAD@Z proc near
.text$mn:0000036C                                         ; CODE XREF: std::allocator_traits<std::allocator<char>>::construct<char *,char * &>(std::allocator<char> &,char * *,char * &)+17p
.text$mn:0000036C
.text$mn:0000036C var_1C          = dword ptr -1Ch
.text$mn:0000036C var_18          = dword ptr -18h
.text$mn:0000036C var_14          = dword ptr -14h
.text$mn:0000036C var_10          = dword ptr -10h
.text$mn:0000036C var_C           = dword ptr -0Ch
.text$mn:0000036C var_4           = dword ptr -4
.text$mn:0000036C arg_0           = dword ptr  8
.text$mn:0000036C arg_4           = dword ptr  0Ch
.text$mn:0000036C
.text$mn:0000036C                 push    ebp
.text$mn:0000036D                 mov     ebp, esp
.text$mn:0000036F                 push    0FFFFFFFFh
.text$mn:00000371                 push    offset __ehhandler$??$construct@PADAAPAD@?$allocator@D@std@@QAEXPAPADAAPAD@Z
.text$mn:00000376                 mov     eax, large fs:0
.text$mn:0000037C                 push    eax
.text$mn:0000037D                 sub     esp, 10h
.text$mn:00000380                 mov     eax, dword ptr ds:___security_cookie
.text$mn:00000385                 xor     eax, ebp
.text$mn:00000387                 push    eax
.text$mn:00000388                 lea     eax, [ebp+var_C]
.text$mn:0000038B                 mov     large fs:0, eax
.text$mn:00000391                 mov     [ebp+var_18], ecx
.text$mn:00000394                 mov     eax, [ebp+arg_0]
.text$mn:00000397                 push    eax             ; void *
.text$mn:00000398                 push    4               ; unsigned int
.text$mn:0000039A                 call    ??2@YAPAXIPAX@Z ; operator new(uint,void *)
.text$mn:0000039F                 add     esp, 8
.text$mn:000003A2                 mov     [ebp+var_10], eax
.text$mn:000003A5                 mov     [ebp+var_4], 0
.text$mn:000003AC                 cmp     [ebp+var_10], 0
.text$mn:000003B0                 jz      short loc_3CD
.text$mn:000003B2                 mov     ecx, [ebp+arg_4]
.text$mn:000003B5                 push    ecx
.text$mn:000003B6                 call    ??$forward@AAPAD@std@@YAAAPADAAPAD@Z ; std::forward<char * &>(char * &)
.text$mn:000003BB                 add     esp, 4
.text$mn:000003BE                 mov     edx, [ebp+var_10]
.text$mn:000003C1                 mov     eax, [eax]
.text$mn:000003C3                 mov     [edx], eax
.text$mn:000003C5                 mov     ecx, [ebp+var_10]
.text$mn:000003C8                 mov     [ebp+var_14], ecx
.text$mn:000003CB                 jmp     short loc_3D4
.text$mn:000003CD ; ---------------------------------------------------------------------------
.text$mn:000003CD
.text$mn:000003CD loc_3CD:                                ; CODE XREF: std::allocator<char>::construct<char *,char * &>(char * *,char * &)+44j
.text$mn:000003CD                 mov     [ebp+var_14], 0
.text$mn:000003D4
.text$mn:000003D4 loc_3D4:                                ; CODE XREF: std::allocator<char>::construct<char *,char * &>(char * *,char * &)+5Fj
.text$mn:000003D4                 mov     edx, [ebp+var_14]
.text$mn:000003D7                 mov     [ebp+var_1C], edx
.text$mn:000003DA                 mov     [ebp+var_4], 0FFFFFFFFh
.text$mn:000003E1                 mov     ecx, [ebp+var_C]
.text$mn:000003E4                 mov     large fs:0, ecx
.text$mn:000003EB                 pop     ecx
.text$mn:000003EC                 mov     esp, ebp
.text$mn:000003EE                 pop     ebp
.text$mn:000003EF                 retn    8
.text$mn:000003EF ??$construct@PADAAPAD@?$allocator@D@std@@QAEXPAPADAAPAD@Z endp
.text$mn:000003EF
.text$mn:000003EF ; ---------------------------------------------------------------------------
.text$mn:000003F2                 align 4
.text$mn:000003F2 _text$mn        ends
.text$mn:000003F2
.text$x:000003F4 ; ===========================================================================
.text$x:000003F4
.text$x:000003F4 ; Segment type: Pure code
.text$x:000003F4 ; Segment permissions: Read/Execute
.text$x:000003F4 _text$x         segment para public 'CODE' use32
.text$x:000003F4                 assume cs:_text$x
.text$x:000003F4                 ;org 3F4h
.text$x:000003F4 ; COMDAT (pick associative to section at 36C)
.text$x:000003F4                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text$x:000003F4
.text$x:000003F4 ; =============== S U B R O U T I N E =======================================
.text$x:000003F4
.text$x:000003F4
.text$x:000003F4 __unwindfunclet$??$construct@PADAAPAD@?$allocator@D@std@@QAEXPAPADAAPAD@Z$0 proc near
.text$x:000003F4                                         ; DATA XREF: .xdata$x:00002134o
.text$x:000003F4                 mov     eax, [ebp+8]
.text$x:000003F7                 push    eax
.text$x:000003F8                 mov     eax, [ebp-10h]
.text$x:000003FB                 push    eax             ; void *
.text$x:000003FC                 call    ??3@YAXPAX0@Z   ; operator delete(void *,void *)
.text$x:00000401                 add     esp, 8
.text$x:00000404                 retn
.text$x:00000404 __unwindfunclet$??$construct@PADAAPAD@?$allocator@D@std@@QAEXPAPADAAPAD@Z$0 endp
.text$x:00000404
.text$x:00000405
.text$x:00000405 ; =============== S U B R O U T I N E =======================================
.text$x:00000405
.text$x:00000405
.text$x:00000405 __ehhandler$??$construct@PADAAPAD@?$allocator@D@std@@QAEXPAPADAAPAD@Z proc near
.text$x:00000405                                         ; DATA XREF: std::allocator<char>::construct<char *,char * &>(char * *,char * &)+5o
.text$x:00000405
.text$x:00000405 arg_4           = dword ptr  8
.text$x:00000405
.text$x:00000405                 mov     edx, [esp+arg_4]
.text$x:00000409                 lea     eax, [edx+0Ch]
.text$x:0000040C                 mov     ecx, [edx-14h]
.text$x:0000040F                 xor     ecx, eax
.text$x:00000411                 call    @__security_check_cookie@4 ; __security_check_cookie(x)
.text$x:00000416                 mov     eax, offset __ehfuncinfo$??$construct@PADAAPAD@?$allocator@D@std@@QAEXPAPADAAPAD@Z
.text$x:0000041B                 jmp     ___CxxFrameHandler3
.text$x:0000041B __ehhandler$??$construct@PADAAPAD@?$allocator@D@std@@QAEXPAPADAAPAD@Z endp
.text$x:0000041B
.text$x:0000041B _text$x         ends
.text$x:0000041B
.text$mn:00000420 ; ===========================================================================
.text$mn:00000420
.text$mn:00000420 ; Segment type: Pure code
.text$mn:00000420 ; Segment permissions: Read/Execute
.text$mn:00000420 _text$mn        segment para public 'CODE' use32
.text$mn:00000420                 assume cs:_text$mn
.text$mn:00000420                 ;org 420h
.text$mn:00000420 ; COMDAT (pick any)
.text$mn:00000420                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text$mn:00000420
.text$mn:00000420 ; =============== S U B R O U T I N E =======================================
.text$mn:00000420
.text$mn:00000420 ; Attributes: bp-based frame
.text$mn:00000420
.text$mn:00000420 ; int __cdecl std::allocator_traits<std::allocator<char>>::construct<char *,char * &>(int, void *, int)
.text$mn:00000420                 public ??$construct@PADAAPAD@?$allocator_traits@V?$allocator@D@std@@@std@@SAXAAV?$allocator@D@1@PAPADAAPAD@Z
.text$mn:00000420 ??$construct@PADAAPAD@?$allocator_traits@V?$allocator@D@std@@@std@@SAXAAV?$allocator@D@1@PAPADAAPAD@Z proc near
.text$mn:00000420                                         ; CODE XREF: std::_Wrap_alloc<std::allocator<char>>::construct<char *,char * &>(char * *,char * &)+1Cp
.text$mn:00000420
.text$mn:00000420 arg_0           = dword ptr  8
.text$mn:00000420 arg_4           = dword ptr  0Ch
.text$mn:00000420 arg_8           = dword ptr  10h
.text$mn:00000420
.text$mn:00000420                 push    ebp
.text$mn:00000421                 mov     ebp, esp
.text$mn:00000423                 mov     eax, [ebp+arg_8]
.text$mn:00000426                 push    eax
.text$mn:00000427                 call    ??$forward@AAPAD@std@@YAAAPADAAPAD@Z ; std::forward<char * &>(char * &)
.text$mn:0000042C                 add     esp, 4
.text$mn:0000042F                 push    eax             ; int
.text$mn:00000430                 mov     ecx, [ebp+arg_4]
.text$mn:00000433                 push    ecx             ; void *
.text$mn:00000434                 mov     ecx, [ebp+arg_0]
.text$mn:00000437                 call    ??$construct@PADAAPAD@?$allocator@D@std@@QAEXPAPADAAPAD@Z ; std::allocator<char>::construct<char *,char * &>(char * *,char * &)
.text$mn:0000043C                 pop     ebp
.text$mn:0000043D                 retn
.text$mn:0000043D ??$construct@PADAAPAD@?$allocator_traits@V?$allocator@D@std@@@std@@SAXAAV?$allocator@D@1@PAPADAAPAD@Z endp
.text$mn:0000043D
.text$mn:0000043D ; ---------------------------------------------------------------------------
.text$mn:0000043E                 align 10h
.text$mn:0000043E _text$mn        ends
.text$mn:0000043E
.text$mn:00000440 ; ===========================================================================
.text$mn:00000440
.text$mn:00000440 ; Segment type: Pure code
.text$mn:00000440 ; Segment permissions: Read/Execute
.text$mn:00000440 _text$mn        segment para public 'CODE' use32
.text$mn:00000440                 assume cs:_text$mn
.text$mn:00000440                 ;org 440h
.text$mn:00000440 ; COMDAT (pick any)
.text$mn:00000440                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text$mn:00000440
.text$mn:00000440 ; =============== S U B R O U T I N E =======================================
.text$mn:00000440
.text$mn:00000440 ; Attributes: bp-based frame
.text$mn:00000440
.text$mn:00000440 ; int __stdcall std::allocator<std::_Container_proxy>::construct<std::_Container_proxy,std::_Container_proxy>(void *, int)
.text$mn:00000440                 public ??$construct@U_Container_proxy@std@@U12@@?$allocator@U_Container_proxy@std@@@std@@QAEXPAU_Container_proxy@1@$$QAU21@@Z
.text$mn:00000440 ??$construct@U_Container_proxy@std@@U12@@?$allocator@U_Container_proxy@std@@@std@@QAEXPAU_Container_proxy@1@$$QAU21@@Z proc near
.text$mn:00000440                                         ; CODE XREF: std::_String_alloc<0,std::_String_base_types<char,std::allocator<char>>>::_Alloc_proxy(void)+32p
.text$mn:00000440
.text$mn:00000440 var_1C          = dword ptr -1Ch
.text$mn:00000440 var_18          = dword ptr -18h
.text$mn:00000440 var_14          = dword ptr -14h
.text$mn:00000440 var_10          = dword ptr -10h
.text$mn:00000440 var_C           = dword ptr -0Ch
.text$mn:00000440 var_4           = dword ptr -4
.text$mn:00000440 arg_0           = dword ptr  8
.text$mn:00000440 arg_4           = dword ptr  0Ch
.text$mn:00000440
.text$mn:00000440                 push    ebp
.text$mn:00000441                 mov     ebp, esp
.text$mn:00000443                 push    0FFFFFFFFh
.text$mn:00000445                 push    offset __ehhandler$??$construct@U_Container_proxy@std@@U12@@?$allocator@U_Container_proxy@std@@@std@@QAEXPAU_Container_proxy@1@$$QAU21@@Z
.text$mn:0000044A                 mov     eax, large fs:0
.text$mn:00000450                 push    eax
.text$mn:00000451                 sub     esp, 10h
.text$mn:00000454                 mov     eax, dword ptr ds:___security_cookie
.text$mn:00000459                 xor     eax, ebp
.text$mn:0000045B                 push    eax
.text$mn:0000045C                 lea     eax, [ebp+var_C]
.text$mn:0000045F                 mov     large fs:0, eax
.text$mn:00000465                 mov     [ebp+var_18], ecx
.text$mn:00000468                 mov     eax, [ebp+arg_0]
.text$mn:0000046B                 push    eax             ; void *
.text$mn:0000046C                 push    8               ; unsigned int
.text$mn:0000046E                 call    ??2@YAPAXIPAX@Z ; operator new(uint,void *)
.text$mn:00000473                 add     esp, 8
.text$mn:00000476                 mov     [ebp+var_10], eax
.text$mn:00000479                 mov     [ebp+var_4], 0
.text$mn:00000480                 cmp     [ebp+var_10], 0
.text$mn:00000484                 jz      short loc_4A7
.text$mn:00000486                 mov     ecx, [ebp+arg_4]
.text$mn:00000489                 push    ecx
.text$mn:0000048A                 call    ??$forward@U_Container_proxy@std@@@std@@YA$$QAU_Container_proxy@0@AAU10@@Z ; std::forward<std::_Container_proxy>(std::_Container_proxy &)
.text$mn:0000048F                 add     esp, 4
.text$mn:00000492                 mov     edx, [eax]
.text$mn:00000494                 mov     eax, [eax+4]
.text$mn:00000497                 mov     ecx, [ebp+var_10]
.text$mn:0000049A                 mov     [ecx], edx
.text$mn:0000049C                 mov     [ecx+4], eax
.text$mn:0000049F                 mov     edx, [ebp+var_10]
.text$mn:000004A2                 mov     [ebp+var_14], edx
.text$mn:000004A5                 jmp     short loc_4AE
.text$mn:000004A7 ; ---------------------------------------------------------------------------
.text$mn:000004A7
.text$mn:000004A7 loc_4A7:                                ; CODE XREF: std::allocator<std::_Container_proxy>::construct<std::_Container_proxy,std::_Container_proxy>(std::_Container_proxy *,std::_Container_proxy &&)+44j
.text$mn:000004A7                 mov     [ebp+var_14], 0
.text$mn:000004AE
.text$mn:000004AE loc_4AE:                                ; CODE XREF: std::allocator<std::_Container_proxy>::construct<std::_Container_proxy,std::_Container_proxy>(std::_Container_proxy *,std::_Container_proxy &&)+65j
.text$mn:000004AE                 mov     eax, [ebp+var_14]
.text$mn:000004B1                 mov     [ebp+var_1C], eax
.text$mn:000004B4                 mov     [ebp+var_4], 0FFFFFFFFh
.text$mn:000004BB                 mov     ecx, [ebp+var_C]
.text$mn:000004BE                 mov     large fs:0, ecx
.text$mn:000004C5                 pop     ecx
.text$mn:000004C6                 mov     esp, ebp
.text$mn:000004C8                 pop     ebp
.text$mn:000004C9                 retn    8
.text$mn:000004C9 ??$construct@U_Container_proxy@std@@U12@@?$allocator@U_Container_proxy@std@@@std@@QAEXPAU_Container_proxy@1@$$QAU21@@Z endp
.text$mn:000004C9
.text$mn:000004C9 _text$mn        ends
.text$mn:000004C9
.text$x:000004CC ; ===========================================================================
.text$x:000004CC
.text$x:000004CC ; Segment type: Pure code
.text$x:000004CC ; Segment permissions: Read/Execute
.text$x:000004CC _text$x         segment para public 'CODE' use32
.text$x:000004CC                 assume cs:_text$x
.text$x:000004CC                 ;org 4CCh
.text$x:000004CC ; COMDAT (pick associative to section at 440)
.text$x:000004CC                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text$x:000004CC
.text$x:000004CC ; =============== S U B R O U T I N E =======================================
.text$x:000004CC
.text$x:000004CC
.text$x:000004CC __unwindfunclet$??$construct@U_Container_proxy@std@@U12@@?$allocator@U_Container_proxy@std@@@std@@QAEXPAU_Container_proxy@1@$$QAU21@@Z$0 proc near
.text$x:000004CC                                         ; DATA XREF: .xdata$x:00002108o
.text$x:000004CC                 mov     eax, [ebp+8]
.text$x:000004CF                 push    eax
.text$x:000004D0                 mov     eax, [ebp-10h]
.text$x:000004D3                 push    eax             ; void *
.text$x:000004D4                 call    ??3@YAXPAX0@Z   ; operator delete(void *,void *)
.text$x:000004D9                 add     esp, 8
.text$x:000004DC                 retn
.text$x:000004DC __unwindfunclet$??$construct@U_Container_proxy@std@@U12@@?$allocator@U_Container_proxy@std@@@std@@QAEXPAU_Container_proxy@1@$$QAU21@@Z$0 endp
.text$x:000004DC
.text$x:000004DD
.text$x:000004DD ; =============== S U B R O U T I N E =======================================
.text$x:000004DD
.text$x:000004DD
.text$x:000004DD __ehhandler$??$construct@U_Container_proxy@std@@U12@@?$allocator@U_Container_proxy@std@@@std@@QAEXPAU_Container_proxy@1@$$QAU21@@Z proc near
.text$x:000004DD                                         ; DATA XREF: std::allocator<std::_Container_proxy>::construct<std::_Container_proxy,std::_Container_proxy>(std::_Container_proxy *,std::_Container_proxy &&)+5o
.text$x:000004DD
.text$x:000004DD arg_4           = dword ptr  8
.text$x:000004DD
.text$x:000004DD                 mov     edx, [esp+arg_4]
.text$x:000004E1                 lea     eax, [edx+0Ch]
.text$x:000004E4                 mov     ecx, [edx-14h]
.text$x:000004E7                 xor     ecx, eax
.text$x:000004E9                 call    @__security_check_cookie@4 ; __security_check_cookie(x)
.text$x:000004EE                 mov     eax, offset __ehfuncinfo$??$construct@U_Container_proxy@std@@U12@@?$allocator@U_Container_proxy@std@@@std@@QAEXPAU_Container_proxy@1@$$QAU21@@Z
.text$x:000004F3                 jmp     ___CxxFrameHandler3
.text$x:000004F3 __ehhandler$??$construct@U_Container_proxy@std@@U12@@?$allocator@U_Container_proxy@std@@@std@@QAEXPAU_Container_proxy@1@$$QAU21@@Z endp
.text$x:000004F3
.text$x:000004F3 _text$x         ends
.text$x:000004F3
.text$mn:000004F8 ; ===========================================================================
.text$mn:000004F8
.text$mn:000004F8 ; Segment type: Pure code
.text$mn:000004F8 ; Segment permissions: Read/Execute
.text$mn:000004F8 _text$mn        segment para public 'CODE' use32
.text$mn:000004F8                 assume cs:_text$mn
.text$mn:000004F8                 ;org 4F8h
.text$mn:000004F8 ; COMDAT (pick any)
.text$mn:000004F8                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text$mn:000004F8
.text$mn:000004F8 ; =============== S U B R O U T I N E =======================================
.text$mn:000004F8
.text$mn:000004F8 ; Attributes: bp-based frame
.text$mn:000004F8
.text$mn:000004F8 ; public: void __thiscall std::_Wrap_alloc<class std::allocator<char>>::destroy<char *>(char * *)
.text$mn:000004F8                 public ??$destroy@PAD@?$_Wrap_alloc@V?$allocator@D@std@@@std@@QAEXPAPAD@Z
.text$mn:000004F8 ??$destroy@PAD@?$_Wrap_alloc@V?$allocator@D@std@@@std@@QAEXPAPAD@Z proc near
.text$mn:000004F8                                         ; CODE XREF: std::basic_string<char,std::char_traits<char>,std::allocator<char>>::_Tidy(bool,uint)+3Ap
.text$mn:000004F8
.text$mn:000004F8 var_4           = dword ptr -4
.text$mn:000004F8 arg_0           = dword ptr  8
.text$mn:000004F8
.text$mn:000004F8                 push    ebp
.text$mn:000004F9                 mov     ebp, esp
.text$mn:000004FB                 push    ecx
.text$mn:000004FC                 mov     [ebp+var_4], ecx
.text$mn:000004FF                 mov     eax, [ebp+arg_0]
.text$mn:00000502                 push    eax
.text$mn:00000503                 mov     ecx, [ebp+var_4]
.text$mn:00000506                 push    ecx
.text$mn:00000507                 call    ??$destroy@PAD@?$allocator_traits@V?$allocator@D@std@@@std@@SAXAAV?$allocator@D@1@PAPAD@Z ; std::allocator_traits<std::allocator<char>>::destroy<char *>(std::allocator<char> &,char * *)
.text$mn:0000050C                 add     esp, 8
.text$mn:0000050F                 mov     esp, ebp
.text$mn:00000511                 pop     ebp
.text$mn:00000512                 retn    4
.text$mn:00000512 ??$destroy@PAD@?$_Wrap_alloc@V?$allocator@D@std@@@std@@QAEXPAPAD@Z endp
.text$mn:00000512
.text$mn:00000512 ; ---------------------------------------------------------------------------
.text$mn:00000515                 align 4
.text$mn:00000515 _text$mn        ends
.text$mn:00000515
.text$mn:00000518 ; ===========================================================================
.text$mn:00000518
.text$mn:00000518 ; Segment type: Pure code
.text$mn:00000518 ; Segment permissions: Read/Execute
.text$mn:00000518 _text$mn        segment para public 'CODE' use32
.text$mn:00000518                 assume cs:_text$mn
.text$mn:00000518                 ;org 518h
.text$mn:00000518 ; COMDAT (pick any)
.text$mn:00000518                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text$mn:00000518
.text$mn:00000518 ; =============== S U B R O U T I N E =======================================
.text$mn:00000518
.text$mn:00000518 ; Attributes: bp-based frame
.text$mn:00000518
.text$mn:00000518 ; public: void __thiscall std::allocator<char>::destroy<char *>(char * *)
.text$mn:00000518                 public ??$destroy@PAD@?$allocator@D@std@@QAEXPAPAD@Z
.text$mn:00000518 ??$destroy@PAD@?$allocator@D@std@@QAEXPAPAD@Z proc near
.text$mn:00000518                                         ; CODE XREF: std::allocator_traits<std::allocator<char>>::destroy<char *>(std::allocator<char> &,char * *)+Ap
.text$mn:00000518
.text$mn:00000518 var_4           = dword ptr -4
.text$mn:00000518
.text$mn:00000518                 push    ebp
.text$mn:00000519                 mov     ebp, esp
.text$mn:0000051B                 push    ecx
.text$mn:0000051C                 mov     [ebp+var_4], ecx
.text$mn:0000051F                 mov     esp, ebp
.text$mn:00000521                 pop     ebp
.text$mn:00000522                 retn    4
.text$mn:00000522 ??$destroy@PAD@?$allocator@D@std@@QAEXPAPAD@Z endp
.text$mn:00000522
.text$mn:00000522 ; ---------------------------------------------------------------------------
.text$mn:00000525                 align 4
.text$mn:00000525 _text$mn        ends
.text$mn:00000525
.text$mn:00000528 ; ===========================================================================
.text$mn:00000528
.text$mn:00000528 ; Segment type: Pure code
.text$mn:00000528 ; Segment permissions: Read/Execute
.text$mn:00000528 _text$mn        segment para public 'CODE' use32
.text$mn:00000528                 assume cs:_text$mn
.text$mn:00000528                 ;org 528h
.text$mn:00000528 ; COMDAT (pick any)
.text$mn:00000528                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text$mn:00000528
.text$mn:00000528 ; =============== S U B R O U T I N E =======================================
.text$mn:00000528
.text$mn:00000528 ; Attributes: bp-based frame
.text$mn:00000528
.text$mn:00000528 ; public: static void __cdecl std::allocator_traits<class std::allocator<char>>::destroy<char *>(class std::allocator<char> &, char * *)
.text$mn:00000528                 public ??$destroy@PAD@?$allocator_traits@V?$allocator@D@std@@@std@@SAXAAV?$allocator@D@1@PAPAD@Z
.text$mn:00000528 ??$destroy@PAD@?$allocator_traits@V?$allocator@D@std@@@std@@SAXAAV?$allocator@D@1@PAPAD@Z proc near
.text$mn:00000528                                         ; CODE XREF: std::_Wrap_alloc<std::allocator<char>>::destroy<char *>(char * *)+Fp
.text$mn:00000528
.text$mn:00000528 arg_0           = dword ptr  8
.text$mn:00000528 arg_4           = dword ptr  0Ch
.text$mn:00000528
.text$mn:00000528                 push    ebp
.text$mn:00000529                 mov     ebp, esp
.text$mn:0000052B                 mov     eax, [ebp+arg_4]
.text$mn:0000052E                 push    eax
.text$mn:0000052F                 mov     ecx, [ebp+arg_0]
.text$mn:00000532                 call    ??$destroy@PAD@?$allocator@D@std@@QAEXPAPAD@Z ; std::allocator<char>::destroy<char *>(char * *)
.text$mn:00000537                 pop     ebp
.text$mn:00000538                 retn
.text$mn:00000538 ??$destroy@PAD@?$allocator_traits@V?$allocator@D@std@@@std@@SAXAAV?$allocator@D@1@PAPAD@Z endp
.text$mn:00000538
.text$mn:00000538 ; ---------------------------------------------------------------------------
.text$mn:00000539                 align 4
.text$mn:00000539 _text$mn        ends
.text$mn:00000539
.text$mn:0000053C ; ===========================================================================
.text$mn:0000053C
.text$mn:0000053C ; Segment type: Pure code
.text$mn:0000053C ; Segment permissions: Read/Execute
.text$mn:0000053C _text$mn        segment para public 'CODE' use32
.text$mn:0000053C                 assume cs:_text$mn
.text$mn:0000053C                 ;org 53Ch
.text$mn:0000053C ; COMDAT (pick any)
.text$mn:0000053C                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text$mn:0000053C
.text$mn:0000053C ; =============== S U B R O U T I N E =======================================
.text$mn:0000053C
.text$mn:0000053C ; Attributes: bp-based frame
.text$mn:0000053C
.text$mn:0000053C ; public: void __thiscall std::allocator<struct std::_Container_proxy>::destroy<struct std::_Container_proxy>(struct std::_Container_proxy *)
.text$mn:0000053C                 public ??$destroy@U_Container_proxy@std@@@?$allocator@U_Container_proxy@std@@@std@@QAEXPAU_Container_proxy@1@@Z
.text$mn:0000053C ??$destroy@U_Container_proxy@std@@@?$allocator@U_Container_proxy@std@@@std@@QAEXPAU_Container_proxy@1@@Z proc near
.text$mn:0000053C                                         ; CODE XREF: std::_String_alloc<0,std::_String_base_types<char,std::allocator<char>>>::_Free_proxy(void)+22p
.text$mn:0000053C
.text$mn:0000053C var_4           = dword ptr -4
.text$mn:0000053C
.text$mn:0000053C                 push    ebp
.text$mn:0000053D                 mov     ebp, esp
.text$mn:0000053F                 push    ecx
.text$mn:00000540                 mov     [ebp+var_4], ecx
.text$mn:00000543                 mov     esp, ebp
.text$mn:00000545                 pop     ebp
.text$mn:00000546                 retn    4
.text$mn:00000546 ??$destroy@U_Container_proxy@std@@@?$allocator@U_Container_proxy@std@@@std@@QAEXPAU_Container_proxy@1@@Z endp
.text$mn:00000546
.text$mn:00000546 ; ---------------------------------------------------------------------------
.text$mn:00000549                 align 4
.text$mn:00000549 _text$mn        ends
.text$mn:00000549
.text$mn:0000054C ; ===========================================================================
.text$mn:0000054C
.text$mn:0000054C ; Segment type: Pure code
.text$mn:0000054C ; Segment permissions: Read/Execute
.text$mn:0000054C _text$mn        segment para public 'CODE' use32
.text$mn:0000054C                 assume cs:_text$mn
.text$mn:0000054C                 ;org 54Ch
.text$mn:0000054C ; COMDAT (pick any)
.text$mn:0000054C                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text$mn:0000054C
.text$mn:0000054C ; =============== S U B R O U T I N E =======================================
.text$mn:0000054C
.text$mn:0000054C ; Attributes: bp-based frame
.text$mn:0000054C
.text$mn:0000054C ; char * & __cdecl std::forward<char * &>(char * &)
.text$mn:0000054C                 public ??$forward@AAPAD@std@@YAAAPADAAPAD@Z
.text$mn:0000054C ??$forward@AAPAD@std@@YAAAPADAAPAD@Z proc near
.text$mn:0000054C                                         ; CODE XREF: std::_Wrap_alloc<std::allocator<char>>::construct<char *,char * &>(char * *,char * &)+Bp
.text$mn:0000054C                                         ; std::allocator<char>::construct<char *,char * &>(char * *,char * &)+4Ap ...
.text$mn:0000054C
.text$mn:0000054C arg_0           = dword ptr  8
.text$mn:0000054C
.text$mn:0000054C                 push    ebp
.text$mn:0000054D                 mov     ebp, esp
.text$mn:0000054F                 mov     eax, [ebp+arg_0]
.text$mn:00000552                 pop     ebp
.text$mn:00000553                 retn
.text$mn:00000553 ??$forward@AAPAD@std@@YAAAPADAAPAD@Z endp
.text$mn:00000553
.text$mn:00000553 _text$mn        ends
.text$mn:00000553
.text$mn:00000554 ; ===========================================================================
.text$mn:00000554
.text$mn:00000554 ; Segment type: Pure code
.text$mn:00000554 ; Segment permissions: Read/Execute
.text$mn:00000554 _text$mn        segment para public 'CODE' use32
.text$mn:00000554                 assume cs:_text$mn
.text$mn:00000554                 ;org 554h
.text$mn:00000554 ; COMDAT (pick any)
.text$mn:00000554                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text$mn:00000554
.text$mn:00000554 ; =============== S U B R O U T I N E =======================================
.text$mn:00000554
.text$mn:00000554 ; Attributes: bp-based frame
.text$mn:00000554
.text$mn:00000554 ; struct std::_Container_proxy && __cdecl std::forward<struct std::_Container_proxy>(struct std::_Container_proxy &)
.text$mn:00000554                 public ??$forward@U_Container_proxy@std@@@std@@YA$$QAU_Container_proxy@0@AAU10@@Z
.text$mn:00000554 ??$forward@U_Container_proxy@std@@@std@@YA$$QAU_Container_proxy@0@AAU10@@Z proc near
.text$mn:00000554                                         ; CODE XREF: std::allocator<std::_Container_proxy>::construct<std::_Container_proxy,std::_Container_proxy>(std::_Container_proxy *,std::_Container_proxy &&)+4Ap
.text$mn:00000554
.text$mn:00000554 arg_0           = dword ptr  8
.text$mn:00000554
.text$mn:00000554                 push    ebp
.text$mn:00000555                 mov     ebp, esp
.text$mn:00000557                 mov     eax, [ebp+arg_0]
.text$mn:0000055A                 pop     ebp
.text$mn:0000055B                 retn
.text$mn:0000055B ??$forward@U_Container_proxy@std@@@std@@YA$$QAU_Container_proxy@0@AAU10@@Z endp
.text$mn:0000055B
.text$mn:0000055B _text$mn        ends
.text$mn:0000055B
.text$mn:0000055C ; ===========================================================================
.text$mn:0000055C
.text$mn:0000055C ; Segment type: Pure code
.text$mn:0000055C ; Segment permissions: Read/Execute
.text$mn:0000055C _text$mn        segment para public 'CODE' use32
.text$mn:0000055C                 assume cs:_text$mn
.text$mn:0000055C                 ;org 55Ch
.text$mn:0000055C ; COMDAT (pick any)
.text$mn:0000055C                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text$mn:0000055C
.text$mn:0000055C ; =============== S U B R O U T I N E =======================================
.text$mn:0000055C
.text$mn:0000055C ; Attributes: bp-based frame
.text$mn:0000055C
.text$mn:0000055C ; public: __thiscall std::_String_alloc<0, struct std::_String_base_types<char, class std::allocator<char>>>::_String_alloc<0, struct std::_String_base_types<char, class std::allocator<char>>>(class std::allocator<char> const &)
.text$mn:0000055C                 public ??0?$_String_alloc@$0A@U?$_String_base_types@DV?$allocator@D@std@@@std@@@std@@QAE@ABV?$allocator@D@1@@Z
.text$mn:0000055C ??0?$_String_alloc@$0A@U?$_String_base_types@DV?$allocator@D@std@@@std@@@std@@QAE@ABV?$allocator@D@1@@Z proc near
.text$mn:0000055C                                         ; CODE XREF: std::basic_string<char,std::char_traits<char>,std::allocator<char>>::basic_string<char,std::char_traits<char>,std::allocator<char>>(char const *)+34p
.text$mn:0000055C
.text$mn:0000055C var_10          = dword ptr -10h
.text$mn:0000055C var_C           = dword ptr -0Ch
.text$mn:0000055C var_4           = dword ptr -4
.text$mn:0000055C
.text$mn:0000055C                 push    ebp
.text$mn:0000055D                 mov     ebp, esp
.text$mn:0000055F                 push    0FFFFFFFFh
.text$mn:00000561                 push    offset __ehhandler$??0?$_String_alloc@$0A@U?$_String_base_types@DV?$allocator@D@std@@@std@@@std@@QAE@ABV?$allocator@D@1@@Z
.text$mn:00000566                 mov     eax, large fs:0
.text$mn:0000056C                 push    eax
.text$mn:0000056D                 push    ecx
.text$mn:0000056E                 mov     eax, dword ptr ds:___security_cookie
.text$mn:00000573                 xor     eax, ebp
.text$mn:00000575                 push    eax
.text$mn:00000576                 lea     eax, [ebp+var_C]
.text$mn:00000579                 mov     large fs:0, eax
.text$mn:0000057F                 mov     [ebp+var_10], ecx
.text$mn:00000582                 mov     ecx, [ebp+var_10]
.text$mn:00000585                 call    ??0?$_String_val@U?$_Simple_types@D@std@@@std@@QAE@XZ ; std::_String_val<std::_Simple_types<char>>::_String_val<std::_Simple_types<char>>(void)
.text$mn:0000058A                 mov     [ebp+var_4], 0
.text$mn:00000591                 mov     ecx, [ebp+var_10]
.text$mn:00000594                 call    ?_Alloc_proxy@?$_String_alloc@$0A@U?$_String_base_types@DV?$allocator@D@std@@@std@@@std@@QAEXXZ ; std::_String_alloc<0,std::_String_base_types<char,std::allocator<char>>>::_Alloc_proxy(void)
.text$mn:00000599                 mov     [ebp+var_4], 0FFFFFFFFh
.text$mn:000005A0                 mov     eax, [ebp+var_10]
.text$mn:000005A3                 mov     ecx, [ebp+var_C]
.text$mn:000005A6                 mov     large fs:0, ecx
.text$mn:000005AD                 pop     ecx
.text$mn:000005AE                 mov     esp, ebp
.text$mn:000005B0                 pop     ebp
.text$mn:000005B1                 retn    4
.text$mn:000005B1 ??0?$_String_alloc@$0A@U?$_String_base_types@DV?$allocator@D@std@@@std@@@std@@QAE@ABV?$allocator@D@1@@Z endp
.text$mn:000005B1
.text$mn:000005B1 _text$mn        ends
.text$mn:000005B1
.text$x:000005B4 ; ===========================================================================
.text$x:000005B4
.text$x:000005B4 ; Segment type: Pure code
.text$x:000005B4 ; Segment permissions: Read/Execute
.text$x:000005B4 _text$x         segment para public 'CODE' use32
.text$x:000005B4                 assume cs:_text$x
.text$x:000005B4                 ;org 5B4h
.text$x:000005B4 ; COMDAT (pick associative to section at 55C)
.text$x:000005B4                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text$x:000005B4
.text$x:000005B4 ; =============== S U B R O U T I N E =======================================
.text$x:000005B4
.text$x:000005B4
.text$x:000005B4 __unwindfunclet$??0?$_String_alloc@$0A@U?$_String_base_types@DV?$allocator@D@std@@@std@@@std@@QAE@ABV?$allocator@D@1@@Z$0 proc near
.text$x:000005B4                                         ; DATA XREF: .xdata$x:00001DBCo
.text$x:000005B4                 mov     ecx, [ebp-10h]
.text$x:000005B7                 jmp     ??1?$_String_val@U?$_Simple_types@D@std@@@std@@QAE@XZ ; std::_String_val<std::_Simple_types<char>>::~_String_val<std::_Simple_types<char>>(void)
.text$x:000005B7 __unwindfunclet$??0?$_String_alloc@$0A@U?$_String_base_types@DV?$allocator@D@std@@@std@@@std@@QAE@ABV?$allocator@D@1@@Z$0 endp
.text$x:000005B7
.text$x:000005BC
.text$x:000005BC ; =============== S U B R O U T I N E =======================================
.text$x:000005BC
.text$x:000005BC
.text$x:000005BC __ehhandler$??0?$_String_alloc@$0A@U?$_String_base_types@DV?$allocator@D@std@@@std@@@std@@QAE@ABV?$allocator@D@1@@Z proc near
.text$x:000005BC                                         ; DATA XREF: std::_String_alloc<0,std::_String_base_types<char,std::allocator<char>>>::_String_alloc<0,std::_String_base_types<char,std::allocator<char>>>(std::allocator<char> const &)+5o
.text$x:000005BC
.text$x:000005BC arg_4           = dword ptr  8
.text$x:000005BC
.text$x:000005BC                 mov     edx, [esp+arg_4]
.text$x:000005C0                 lea     eax, [edx+0Ch]
.text$x:000005C3                 mov     ecx, [edx-8]
.text$x:000005C6                 xor     ecx, eax
.text$x:000005C8                 call    @__security_check_cookie@4 ; __security_check_cookie(x)
.text$x:000005CD                 mov     eax, offset __ehfuncinfo$??0?$_String_alloc@$0A@U?$_String_base_types@DV?$allocator@D@std@@@std@@@std@@QAE@ABV?$allocator@D@1@@Z
.text$x:000005D2                 jmp     ___CxxFrameHandler3
.text$x:000005D2 __ehhandler$??0?$_String_alloc@$0A@U?$_String_base_types@DV?$allocator@D@std@@@std@@@std@@QAE@ABV?$allocator@D@1@@Z endp
.text$x:000005D2
.text$x:000005D2 ; ---------------------------------------------------------------------------
.text$x:000005D7                 align 4
.text$x:000005D7 _text$x         ends
.text$x:000005D7
.text$mn:000005D8 ; ===========================================================================
.text$mn:000005D8
.text$mn:000005D8 ; Segment type: Pure code
.text$mn:000005D8 ; Segment permissions: Read/Execute
.text$mn:000005D8 _text$mn        segment para public 'CODE' use32
.text$mn:000005D8                 assume cs:_text$mn
.text$mn:000005D8                 ;org 5D8h
.text$mn:000005D8 ; COMDAT (pick any)
.text$mn:000005D8                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text$mn:000005D8
.text$mn:000005D8 ; =============== S U B R O U T I N E =======================================
.text$mn:000005D8
.text$mn:000005D8 ; Attributes: bp-based frame
.text$mn:000005D8
.text$mn:000005D8 ; public: __thiscall std::_String_val<struct std::_Simple_types<char>>::_String_val<struct std::_Simple_types<char>>(void)
.text$mn:000005D8                 public ??0?$_String_val@U?$_Simple_types@D@std@@@std@@QAE@XZ
.text$mn:000005D8 ??0?$_String_val@U?$_Simple_types@D@std@@@std@@QAE@XZ proc near
.text$mn:000005D8                                         ; CODE XREF: std::_String_alloc<0,std::_String_base_types<char,std::allocator<char>>>::_String_alloc<0,std::_String_base_types<char,std::allocator<char>>>(std::allocator<char> const &)+29p
.text$mn:000005D8
.text$mn:000005D8 var_10          = dword ptr -10h
.text$mn:000005D8 var_C           = dword ptr -0Ch
.text$mn:000005D8 var_4           = dword ptr -4
.text$mn:000005D8
.text$mn:000005D8                 push    ebp
.text$mn:000005D9                 mov     ebp, esp
.text$mn:000005DB                 push    0FFFFFFFFh
.text$mn:000005DD                 push    offset __ehhandler$??0?$_String_val@U?$_Simple_types@D@std@@@std@@QAE@XZ
.text$mn:000005E2                 mov     eax, large fs:0
.text$mn:000005E8                 push    eax
.text$mn:000005E9                 push    ecx
.text$mn:000005EA                 mov     eax, dword ptr ds:___security_cookie
.text$mn:000005EF                 xor     eax, ebp
.text$mn:000005F1                 push    eax
.text$mn:000005F2                 lea     eax, [ebp+var_C]
.text$mn:000005F5                 mov     large fs:0, eax
.text$mn:000005FB                 mov     [ebp+var_10], ecx
.text$mn:000005FE                 mov     ecx, [ebp+var_10] ; this
.text$mn:00000601                 call    ??0_Container_base12@std@@QAE@XZ ; std::_Container_base12::_Container_base12(void)
.text$mn:00000606                 mov     [ebp+var_4], 0
.text$mn:0000060D                 mov     eax, [ebp+var_10]
.text$mn:00000610                 mov     dword ptr [eax+14h], 0
.text$mn:00000617                 mov     ecx, [ebp+var_10]
.text$mn:0000061A                 mov     dword ptr [ecx+18h], 0
.text$mn:00000621                 mov     [ebp+var_4], 0FFFFFFFFh
.text$mn:00000628                 mov     eax, [ebp+var_10]
.text$mn:0000062B                 mov     ecx, [ebp+var_C]
.text$mn:0000062E                 mov     large fs:0, ecx
.text$mn:00000635                 pop     ecx
.text$mn:00000636                 mov     esp, ebp
.text$mn:00000638                 pop     ebp
.text$mn:00000639                 retn
.text$mn:00000639 ??0?$_String_val@U?$_Simple_types@D@std@@@std@@QAE@XZ endp
.text$mn:00000639
.text$mn:00000639 ; ---------------------------------------------------------------------------
.text$mn:0000063A                 align 4
.text$mn:0000063A _text$mn        ends
.text$mn:0000063A
.text$x:0000063C ; ===========================================================================
.text$x:0000063C
.text$x:0000063C ; Segment type: Pure code
.text$x:0000063C ; Segment permissions: Read/Execute
.text$x:0000063C _text$x         segment para public 'CODE' use32
.text$x:0000063C                 assume cs:_text$x
.text$x:0000063C                 ;org 63Ch
.text$x:0000063C ; COMDAT (pick associative to section at 5D8)
.text$x:0000063C                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text$x:0000063C
.text$x:0000063C ; =============== S U B R O U T I N E =======================================
.text$x:0000063C
.text$x:0000063C
.text$x:0000063C __unwindfunclet$??0?$_String_val@U?$_Simple_types@D@std@@@std@@QAE@XZ$0 proc near
.text$x:0000063C                                         ; DATA XREF: .xdata$x:00001D64o
.text$x:0000063C                 mov     ecx, [ebp-10h]  ; this
.text$x:0000063F                 jmp     ??1_Container_base12@std@@QAE@XZ ; std::_Container_base12::~_Container_base12(void)
.text$x:0000063F __unwindfunclet$??0?$_String_val@U?$_Simple_types@D@std@@@std@@QAE@XZ$0 endp
.text$x:0000063F
.text$x:00000644
.text$x:00000644 ; =============== S U B R O U T I N E =======================================
.text$x:00000644
.text$x:00000644
.text$x:00000644 __ehhandler$??0?$_String_val@U?$_Simple_types@D@std@@@std@@QAE@XZ proc near
.text$x:00000644                                         ; DATA XREF: std::_String_val<std::_Simple_types<char>>::_String_val<std::_Simple_types<char>>(void)+5o
.text$x:00000644
.text$x:00000644 arg_4           = dword ptr  8
.text$x:00000644
.text$x:00000644                 mov     edx, [esp+arg_4]
.text$x:00000648                 lea     eax, [edx+0Ch]
.text$x:0000064B                 mov     ecx, [edx-8]
.text$x:0000064E                 xor     ecx, eax
.text$x:00000650                 call    @__security_check_cookie@4 ; __security_check_cookie(x)
.text$x:00000655                 mov     eax, offset __ehfuncinfo$??0?$_String_val@U?$_Simple_types@D@std@@@std@@QAE@XZ
.text$x:0000065A                 jmp     ___CxxFrameHandler3
.text$x:0000065A __ehhandler$??0?$_String_val@U?$_Simple_types@D@std@@@std@@QAE@XZ endp
.text$x:0000065A
.text$x:0000065A ; ---------------------------------------------------------------------------
.text$x:0000065F                 align 10h
.text$x:0000065F _text$x         ends
.text$x:0000065F
.text$mn:00000660 ; ===========================================================================
.text$mn:00000660
.text$mn:00000660 ; Segment type: Pure code
.text$mn:00000660 ; Segment permissions: Read/Execute
.text$mn:00000660 _text$mn        segment para public 'CODE' use32
.text$mn:00000660                 assume cs:_text$mn
.text$mn:00000660                 ;org 660h
.text$mn:00000660 ; COMDAT (pick any)
.text$mn:00000660                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text$mn:00000660
.text$mn:00000660 ; =============== S U B R O U T I N E =======================================
.text$mn:00000660
.text$mn:00000660 ; Attributes: bp-based frame
.text$mn:00000660
.text$mn:00000660 ; public: __thiscall std::_Wrap_alloc<class std::allocator<char>>::_Wrap_alloc<class std::allocator<char>>(void)
.text$mn:00000660                 public ??0?$_Wrap_alloc@V?$allocator@D@std@@@std@@QAE@XZ
.text$mn:00000660 ??0?$_Wrap_alloc@V?$allocator@D@std@@@std@@QAE@XZ proc near
.text$mn:00000660                                         ; CODE XREF: std::_String_alloc<0,std::_String_base_types<char,std::allocator<char>>>::_Getal(void)+Ap
.text$mn:00000660
.text$mn:00000660 var_4           = dword ptr -4
.text$mn:00000660
.text$mn:00000660                 push    ebp
.text$mn:00000661                 mov     ebp, esp
.text$mn:00000663                 push    ecx
.text$mn:00000664                 mov     [ebp+var_4], ecx
.text$mn:00000667                 mov     ecx, [ebp+var_4]
.text$mn:0000066A                 call    ??0?$allocator@D@std@@QAE@XZ ; std::allocator<char>::allocator<char>(void)
.text$mn:0000066F                 mov     eax, [ebp+var_4]
.text$mn:00000672                 mov     esp, ebp
.text$mn:00000674                 pop     ebp
.text$mn:00000675                 retn
.text$mn:00000675 ??0?$_Wrap_alloc@V?$allocator@D@std@@@std@@QAE@XZ endp
.text$mn:00000675
.text$mn:00000675 ; ---------------------------------------------------------------------------
.text$mn:00000676                 align 4
.text$mn:00000676 _text$mn        ends
.text$mn:00000676
.text$mn:00000678 ; ===========================================================================
.text$mn:00000678
.text$mn:00000678 ; Segment type: Pure code
.text$mn:00000678 ; Segment permissions: Read/Execute
.text$mn:00000678 _text$mn        segment para public 'CODE' use32
.text$mn:00000678                 assume cs:_text$mn
.text$mn:00000678                 ;org 678h
.text$mn:00000678 ; COMDAT (pick any)
.text$mn:00000678                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text$mn:00000678
.text$mn:00000678 ; =============== S U B R O U T I N E =======================================
.text$mn:00000678
.text$mn:00000678 ; Attributes: bp-based frame
.text$mn:00000678
.text$mn:00000678 ; public: __thiscall std::allocator<char>::allocator<char>(void)
.text$mn:00000678                 public ??0?$allocator@D@std@@QAE@XZ
.text$mn:00000678 ??0?$allocator@D@std@@QAE@XZ proc near  ; CODE XREF: std::_Wrap_alloc<std::allocator<char>>::_Wrap_alloc<std::allocator<char>>(void)+Ap
.text$mn:00000678                                         ; std::basic_string<char,std::char_traits<char>,std::allocator<char>>::basic_string<char,std::char_traits<char>,std::allocator<char>>(char const *)+2Bp
.text$mn:00000678
.text$mn:00000678 var_4           = dword ptr -4
.text$mn:00000678
.text$mn:00000678                 push    ebp
.text$mn:00000679                 mov     ebp, esp
.text$mn:0000067B                 push    ecx
.text$mn:0000067C                 mov     [ebp+var_4], ecx
.text$mn:0000067F                 mov     eax, [ebp+var_4]
.text$mn:00000682                 mov     esp, ebp
.text$mn:00000684                 pop     ebp
.text$mn:00000685                 retn
.text$mn:00000685 ??0?$allocator@D@std@@QAE@XZ endp
.text$mn:00000685
.text$mn:00000685 ; ---------------------------------------------------------------------------
.text$mn:00000686                 align 4
.text$mn:00000686 _text$mn        ends
.text$mn:00000686
.text$mn:00000688 ; ===========================================================================
.text$mn:00000688
.text$mn:00000688 ; Segment type: Pure code
.text$mn:00000688 ; Segment permissions: Read/Execute
.text$mn:00000688 _text$mn        segment para public 'CODE' use32
.text$mn:00000688                 assume cs:_text$mn
.text$mn:00000688                 ;org 688h
.text$mn:00000688 ; COMDAT (pick any)
.text$mn:00000688                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text$mn:00000688
.text$mn:00000688 ; =============== S U B R O U T I N E =======================================
.text$mn:00000688
.text$mn:00000688 ; Attributes: bp-based frame
.text$mn:00000688
.text$mn:00000688 ; public: __thiscall std::allocator<struct std::_Container_proxy>::allocator<struct std::_Container_proxy>(void)
.text$mn:00000688                 public ??0?$allocator@U_Container_proxy@std@@@std@@QAE@XZ
.text$mn:00000688 ??0?$allocator@U_Container_proxy@std@@@std@@QAE@XZ proc near
.text$mn:00000688                                         ; CODE XREF: std::_String_alloc<0,std::_String_base_types<char,std::allocator<char>>>::_Alloc_proxy(void)+Cp
.text$mn:00000688                                         ; std::_String_alloc<0,std::_String_base_types<char,std::allocator<char>>>::_Free_proxy(void)+Cp
.text$mn:00000688
.text$mn:00000688 var_4           = dword ptr -4
.text$mn:00000688
.text$mn:00000688                 push    ebp
.text$mn:00000689                 mov     ebp, esp
.text$mn:0000068B                 push    ecx
.text$mn:0000068C                 mov     [ebp+var_4], ecx
.text$mn:0000068F                 mov     eax, [ebp+var_4]
.text$mn:00000692                 mov     esp, ebp
.text$mn:00000694                 pop     ebp
.text$mn:00000695                 retn
.text$mn:00000695 ??0?$allocator@U_Container_proxy@std@@@std@@QAE@XZ endp
.text$mn:00000695
.text$mn:00000695 ; ---------------------------------------------------------------------------
.text$mn:00000696                 align 4
.text$mn:00000696 _text$mn        ends
.text$mn:00000696
.text$mn:00000698 ; ===========================================================================
.text$mn:00000698
.text$mn:00000698 ; Segment type: Pure code
.text$mn:00000698 ; Segment permissions: Read/Execute
.text$mn:00000698 _text$mn        segment para public 'CODE' use32
.text$mn:00000698                 assume cs:_text$mn
.text$mn:00000698                 ;org 698h
.text$mn:00000698 ; COMDAT (pick any)
.text$mn:00000698                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text$mn:00000698
.text$mn:00000698 ; =============== S U B R O U T I N E =======================================
.text$mn:00000698
.text$mn:00000698 ; Attributes: bp-based frame
.text$mn:00000698
.text$mn:00000698 ; int __stdcall std::basic_string<char,std::char_traits<char>,std::allocator<char>>::basic_string<char,std::char_traits<char>,std::allocator<char>>(char *Str)
.text$mn:00000698                 public ??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@PBD@Z
.text$mn:00000698 ??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@PBD@Z proc near
.text$mn:00000698                                         ; CODE XREF: std::_Generic_error_category::message(int)+5Ap
.text$mn:00000698                                         ; std::_Iostream_error_category::message(int)+3Dp ...
.text$mn:00000698
.text$mn:00000698 var_14          = dword ptr -14h
.text$mn:00000698 var_D           = byte ptr -0Dh
.text$mn:00000698 var_C           = dword ptr -0Ch
.text$mn:00000698 var_4           = dword ptr -4
.text$mn:00000698 Str             = dword ptr  8
.text$mn:00000698
.text$mn:00000698                 push    ebp
.text$mn:00000699                 mov     ebp, esp
.text$mn:0000069B                 push    0FFFFFFFFh
.text$mn:0000069D                 push    offset __ehhandler$??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@PBD@Z
.text$mn:000006A2                 mov     eax, large fs:0
.text$mn:000006A8                 push    eax
.text$mn:000006A9                 sub     esp, 8
.text$mn:000006AC                 mov     eax, dword ptr ds:___security_cookie
.text$mn:000006B1                 xor     eax, ebp
.text$mn:000006B3                 push    eax
.text$mn:000006B4                 lea     eax, [ebp+var_C]
.text$mn:000006B7                 mov     large fs:0, eax
.text$mn:000006BD                 mov     [ebp+var_14], ecx
.text$mn:000006C0                 lea     ecx, [ebp+var_D]
.text$mn:000006C3                 call    ??0?$allocator@D@std@@QAE@XZ ; std::allocator<char>::allocator<char>(void)
.text$mn:000006C8                 push    eax
.text$mn:000006C9                 mov     ecx, [ebp+var_14]
.text$mn:000006CC                 call    ??0?$_String_alloc@$0A@U?$_String_base_types@DV?$allocator@D@std@@@std@@@std@@QAE@ABV?$allocator@D@1@@Z ; std::_String_alloc<0,std::_String_base_types<char,std::allocator<char>>>::_String_alloc<0,std::_String_base_types<char,std::allocator<char>>>(std::allocator<char> const &)
.text$mn:000006D1                 mov     [ebp+var_4], 0
.text$mn:000006D8                 push    0               ; Size
.text$mn:000006DA                 push    0               ; char
.text$mn:000006DC                 mov     ecx, [ebp+var_14]
.text$mn:000006DF                 call    ?_Tidy@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEX_NI@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char>>::_Tidy(bool,uint)
.text$mn:000006E4                 mov     eax, [ebp+Str]
.text$mn:000006E7                 push    eax             ; Str
.text$mn:000006E8                 mov     ecx, [ebp+var_14]
.text$mn:000006EB                 call    ?assign@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV12@PBD@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char>>::assign(char const *)
.text$mn:000006F0                 mov     [ebp+var_4], 0FFFFFFFFh
.text$mn:000006F7                 mov     eax, [ebp+var_14]
.text$mn:000006FA                 mov     ecx, [ebp+var_C]
.text$mn:000006FD                 mov     large fs:0, ecx
.text$mn:00000704                 pop     ecx
.text$mn:00000705                 mov     esp, ebp
.text$mn:00000707                 pop     ebp
.text$mn:00000708                 retn    4
.text$mn:00000708 ??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@PBD@Z endp
.text$mn:00000708
.text$mn:00000708 ; ---------------------------------------------------------------------------
.text$mn:0000070B                 align 4
.text$mn:0000070B _text$mn        ends
.text$mn:0000070B
.text$x:0000070C ; ===========================================================================
.text$x:0000070C
.text$x:0000070C ; Segment type: Pure code
.text$x:0000070C ; Segment permissions: Read/Execute
.text$x:0000070C _text$x         segment para public 'CODE' use32
.text$x:0000070C                 assume cs:_text$x
.text$x:0000070C                 ;org 70Ch
.text$x:0000070C ; COMDAT (pick associative to section at 698)
.text$x:0000070C                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text$x:0000070C
.text$x:0000070C ; =============== S U B R O U T I N E =======================================
.text$x:0000070C
.text$x:0000070C
.text$x:0000070C __unwindfunclet$??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@PBD@Z$0 proc near
.text$x:0000070C                                         ; DATA XREF: .xdata$x:00001E14o
.text$x:0000070C                 mov     ecx, [ebp-14h]
.text$x:0000070F                 jmp     ??1?$_String_alloc@$0A@U?$_String_base_types@DV?$allocator@D@std@@@std@@@std@@QAE@XZ ; std::_String_alloc<0,std::_String_base_types<char,std::allocator<char>>>::~_String_alloc<0,std::_String_base_types<char,std::allocator<char>>>(void)
.text$x:0000070F __unwindfunclet$??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@PBD@Z$0 endp
.text$x:0000070F
.text$x:00000714
.text$x:00000714 ; =============== S U B R O U T I N E =======================================
.text$x:00000714
.text$x:00000714
.text$x:00000714 __ehhandler$??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@PBD@Z proc near
.text$x:00000714                                         ; DATA XREF: std::basic_string<char,std::char_traits<char>,std::allocator<char>>::basic_string<char,std::char_traits<char>,std::allocator<char>>(char const *)+5o
.text$x:00000714
.text$x:00000714 arg_4           = dword ptr  8
.text$x:00000714
.text$x:00000714                 mov     edx, [esp+arg_4]
.text$x:00000718                 lea     eax, [edx+0Ch]
.text$x:0000071B                 mov     ecx, [edx-0Ch]
.text$x:0000071E                 xor     ecx, eax
.text$x:00000720                 call    @__security_check_cookie@4 ; __security_check_cookie(x)
.text$x:00000725                 mov     eax, offset __ehfuncinfo$??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@PBD@Z
.text$x:0000072A                 jmp     ___CxxFrameHandler3
.text$x:0000072A __ehhandler$??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@PBD@Z endp
.text$x:0000072A
.text$x:0000072A ; ---------------------------------------------------------------------------
.text$x:0000072F                 align 10h
.text$x:0000072F _text$x         ends
.text$x:0000072F
.text$mn:00000730 ; ===========================================================================
.text$mn:00000730
.text$mn:00000730 ; Segment type: Pure code
.text$mn:00000730 ; Segment permissions: Read/Execute
.text$mn:00000730 _text$mn        segment para public 'CODE' use32
.text$mn:00000730                 assume cs:_text$mn
.text$mn:00000730                 ;org 730h
.text$mn:00000730 ; COMDAT (pick any)
.text$mn:00000730                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text$mn:00000730
.text$mn:00000730 ; =============== S U B R O U T I N E =======================================
.text$mn:00000730
.text$mn:00000730 ; Attributes: bp-based frame
.text$mn:00000730
.text$mn:00000730 ; _DWORD __thiscall std::_Container_base12::_Container_base12(std::_Container_base12 *__hidden this)
.text$mn:00000730                 public ??0_Container_base12@std@@QAE@XZ
.text$mn:00000730 ??0_Container_base12@std@@QAE@XZ proc near
.text$mn:00000730                                         ; CODE XREF: std::_String_val<std::_Simple_types<char>>::_String_val<std::_Simple_types<char>>(void)+29p
.text$mn:00000730
.text$mn:00000730 var_4           = dword ptr -4
.text$mn:00000730
.text$mn:00000730                 push    ebp
.text$mn:00000731                 mov     ebp, esp
.text$mn:00000733                 push    ecx
.text$mn:00000734                 mov     [ebp+var_4], ecx
.text$mn:00000737                 mov     eax, [ebp+var_4]
.text$mn:0000073A                 mov     dword ptr [eax], 0
.text$mn:00000740                 mov     eax, [ebp+var_4]
.text$mn:00000743                 mov     esp, ebp
.text$mn:00000745                 pop     ebp
.text$mn:00000746                 retn
.text$mn:00000746 ??0_Container_base12@std@@QAE@XZ endp
.text$mn:00000746
.text$mn:00000746 ; ---------------------------------------------------------------------------
.text$mn:00000747                 align 4
.text$mn:00000747 _text$mn        ends
.text$mn:00000747
.text$mn:00000748 ; ===========================================================================
.text$mn:00000748
.text$mn:00000748 ; Segment type: Pure code
.text$mn:00000748 ; Segment permissions: Read/Execute
.text$mn:00000748 _text$mn        segment para public 'CODE' use32
.text$mn:00000748                 assume cs:_text$mn
.text$mn:00000748                 ;org 748h
.text$mn:00000748 ; COMDAT (pick any)
.text$mn:00000748                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text$mn:00000748
.text$mn:00000748 ; =============== S U B R O U T I N E =======================================
.text$mn:00000748
.text$mn:00000748 ; Attributes: bp-based frame
.text$mn:00000748
.text$mn:00000748 ; _DWORD __thiscall std::_Container_proxy::_Container_proxy(std::_Container_proxy *__hidden this)
.text$mn:00000748                 public ??0_Container_proxy@std@@QAE@XZ
.text$mn:00000748 ??0_Container_proxy@std@@QAE@XZ proc near
.text$mn:00000748                                         ; CODE XREF: std::_String_alloc<0,std::_String_base_types<char,std::allocator<char>>>::_Alloc_proxy(void)+23p
.text$mn:00000748
.text$mn:00000748 var_4           = dword ptr -4
.text$mn:00000748
.text$mn:00000748                 push    ebp
.text$mn:00000749                 mov     ebp, esp
.text$mn:0000074B                 push    ecx
.text$mn:0000074C                 mov     [ebp+var_4], ecx
.text$mn:0000074F                 mov     eax, [ebp+var_4]
.text$mn:00000752                 mov     dword ptr [eax], 0
.text$mn:00000758                 mov     ecx, [ebp+var_4]
.text$mn:0000075B                 mov     dword ptr [ecx+4], 0
.text$mn:00000762                 mov     eax, [ebp+var_4]
.text$mn:00000765                 mov     esp, ebp
.text$mn:00000767                 pop     ebp
.text$mn:00000768                 retn
.text$mn:00000768 ??0_Container_proxy@std@@QAE@XZ endp
.text$mn:00000768
.text$mn:00000768 ; ---------------------------------------------------------------------------
.text$mn:00000769                 align 4
.text$mn:00000769 _text$mn        ends
.text$mn:00000769
.text$mn:0000076C ; ===========================================================================
.text$mn:0000076C
.text$mn:0000076C ; Segment type: Pure code
.text$mn:0000076C ; Segment permissions: Read/Execute
.text$mn:0000076C _text$mn        segment para public 'CODE' use32
.text$mn:0000076C                 assume cs:_text$mn
.text$mn:0000076C                 ;org 76Ch
.text$mn:0000076C ; COMDAT (pick any)
.text$mn:0000076C                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text$mn:0000076C
.text$mn:0000076C ; =============== S U B R O U T I N E =======================================
.text$mn:0000076C
.text$mn:0000076C ; Attributes: bp-based frame
.text$mn:0000076C
.text$mn:0000076C ; _DWORD __thiscall std::_Generic_error_category::_Generic_error_category(std::_Generic_error_category *__hidden this)
.text$mn:0000076C                 public ??0_Generic_error_category@std@@QAE@XZ
.text$mn:0000076C ??0_Generic_error_category@std@@QAE@XZ proc near
.text$mn:0000076C                                         ; CODE XREF: std::_Iostream_error_category::_Iostream_error_category(void)+29p
.text$mn:0000076C                                         ; std::_System_error_category::_System_error_category(void)+29p ...
.text$mn:0000076C
.text$mn:0000076C var_10          = dword ptr -10h
.text$mn:0000076C var_C           = dword ptr -0Ch
.text$mn:0000076C var_4           = dword ptr -4
.text$mn:0000076C
.text$mn:0000076C                 push    ebp
.text$mn:0000076D                 mov     ebp, esp
.text$mn:0000076F                 push    0FFFFFFFFh
.text$mn:00000771                 push    offset __ehhandler$??0_Generic_error_category@std@@QAE@XZ
.text$mn:00000776                 mov     eax, large fs:0
.text$mn:0000077C                 push    eax
.text$mn:0000077D                 push    ecx
.text$mn:0000077E                 mov     eax, dword ptr ds:___security_cookie
.text$mn:00000783                 xor     eax, ebp
.text$mn:00000785                 push    eax
.text$mn:00000786                 lea     eax, [ebp+var_C]
.text$mn:00000789                 mov     large fs:0, eax
.text$mn:0000078F                 mov     [ebp+var_10], ecx
.text$mn:00000792                 mov     ecx, [ebp+var_10] ; this
.text$mn:00000795                 call    ??0error_category@std@@QAE@XZ ; std::error_category::error_category(void)
.text$mn:0000079A                 mov     [ebp+var_4], 0
.text$mn:000007A1                 mov     eax, [ebp+var_10]
.text$mn:000007A4                 mov     dword ptr [eax], offset ??_7_Generic_error_category@std@@6B@ ; const std::_Generic_error_category::`vftable'
.text$mn:000007AA                 mov     [ebp+var_4], 0FFFFFFFFh
.text$mn:000007B1                 mov     eax, [ebp+var_10]
.text$mn:000007B4                 mov     ecx, [ebp+var_C]
.text$mn:000007B7                 mov     large fs:0, ecx
.text$mn:000007BE                 pop     ecx
.text$mn:000007BF                 mov     esp, ebp
.text$mn:000007C1                 pop     ebp
.text$mn:000007C2                 retn
.text$mn:000007C2 ??0_Generic_error_category@std@@QAE@XZ endp
.text$mn:000007C2
.text$mn:000007C2 ; ---------------------------------------------------------------------------
.text$mn:000007C3                 align 4
.text$mn:000007C3 _text$mn        ends
.text$mn:000007C3
.text$x:000007C4 ; ===========================================================================
.text$x:000007C4
.text$x:000007C4 ; Segment type: Pure code
.text$x:000007C4 ; Segment permissions: Read/Execute
.text$x:000007C4 _text$x         segment para public 'CODE' use32
.text$x:000007C4                 assume cs:_text$x
.text$x:000007C4                 ;org 7C4h
.text$x:000007C4 ; COMDAT (pick associative to section at 76C)
.text$x:000007C4                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text$x:000007C4
.text$x:000007C4 ; =============== S U B R O U T I N E =======================================
.text$x:000007C4
.text$x:000007C4
.text$x:000007C4 __unwindfunclet$??0_Generic_error_category@std@@QAE@XZ$0 proc near
.text$x:000007C4                                         ; DATA XREF: .xdata$x:00001F7Co
.text$x:000007C4                 mov     ecx, [ebp-10h]  ; this
.text$x:000007C7                 jmp     ??1error_category@std@@UAE@XZ ; std::error_category::~error_category(void)
.text$x:000007C7 __unwindfunclet$??0_Generic_error_category@std@@QAE@XZ$0 endp
.text$x:000007C7
.text$x:000007CC
.text$x:000007CC ; =============== S U B R O U T I N E =======================================
.text$x:000007CC
.text$x:000007CC
.text$x:000007CC __ehhandler$??0_Generic_error_category@std@@QAE@XZ proc near
.text$x:000007CC                                         ; DATA XREF: std::_Generic_error_category::_Generic_error_category(void)+5o
.text$x:000007CC
.text$x:000007CC arg_4           = dword ptr  8
.text$x:000007CC
.text$x:000007CC                 mov     edx, [esp+arg_4]
.text$x:000007D0                 lea     eax, [edx+0Ch]
.text$x:000007D3                 mov     ecx, [edx-8]
.text$x:000007D6                 xor     ecx, eax
.text$x:000007D8                 call    @__security_check_cookie@4 ; __security_check_cookie(x)
.text$x:000007DD                 mov     eax, offset __ehfuncinfo$??0_Generic_error_category@std@@QAE@XZ
.text$x:000007E2                 jmp     ___CxxFrameHandler3
.text$x:000007E2 __ehhandler$??0_Generic_error_category@std@@QAE@XZ endp
.text$x:000007E2
.text$x:000007E2 ; ---------------------------------------------------------------------------
.text$x:000007E7                 align 4
.text$x:000007E7 _text$x         ends
.text$x:000007E7
.text$mn:000007E8 ; ===========================================================================
.text$mn:000007E8
.text$mn:000007E8 ; Segment type: Pure code
.text$mn:000007E8 ; Segment permissions: Read/Execute
.text$mn:000007E8 _text$mn        segment para public 'CODE' use32
.text$mn:000007E8                 assume cs:_text$mn
.text$mn:000007E8                 ;org 7E8h
.text$mn:000007E8 ; COMDAT (pick any)
.text$mn:000007E8                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text$mn:000007E8
.text$mn:000007E8 ; =============== S U B R O U T I N E =======================================
.text$mn:000007E8
.text$mn:000007E8 ; Attributes: bp-based frame
.text$mn:000007E8
.text$mn:000007E8 ; _DWORD __thiscall std::_Iostream_error_category::_Iostream_error_category(std::_Iostream_error_category *__hidden this)
.text$mn:000007E8                 public ??0_Iostream_error_category@std@@QAE@XZ
.text$mn:000007E8 ??0_Iostream_error_category@std@@QAE@XZ proc near
.text$mn:000007E8                                         ; CODE XREF: `dynamic initializer for 'std::_Iostream_error_category std::_Error_objects<int>::_Iostream_object''(void)+8p
.text$mn:000007E8
.text$mn:000007E8 var_10          = dword ptr -10h
.text$mn:000007E8 var_C           = dword ptr -0Ch
.text$mn:000007E8 var_4           = dword ptr -4
.text$mn:000007E8
.text$mn:000007E8                 push    ebp
.text$mn:000007E9                 mov     ebp, esp
.text$mn:000007EB                 push    0FFFFFFFFh
.text$mn:000007ED                 push    offset __ehhandler$??0_Iostream_error_category@std@@QAE@XZ
.text$mn:000007F2                 mov     eax, large fs:0
.text$mn:000007F8                 push    eax
.text$mn:000007F9                 push    ecx
.text$mn:000007FA                 mov     eax, dword ptr ds:___security_cookie
.text$mn:000007FF                 xor     eax, ebp
.text$mn:00000801                 push    eax
.text$mn:00000802                 lea     eax, [ebp+var_C]
.text$mn:00000805                 mov     large fs:0, eax
.text$mn:0000080B                 mov     [ebp+var_10], ecx
.text$mn:0000080E                 mov     ecx, [ebp+var_10] ; this
.text$mn:00000811                 call    ??0_Generic_error_category@std@@QAE@XZ ; std::_Generic_error_category::_Generic_error_category(void)
.text$mn:00000816                 mov     [ebp+var_4], 0
.text$mn:0000081D                 mov     eax, [ebp+var_10]
.text$mn:00000820                 mov     dword ptr [eax], offset ??_7_Iostream_error_category@std@@6B@ ; const std::_Iostream_error_category::`vftable'
.text$mn:00000826                 mov     [ebp+var_4], 0FFFFFFFFh
.text$mn:0000082D                 mov     eax, [ebp+var_10]
.text$mn:00000830                 mov     ecx, [ebp+var_C]
.text$mn:00000833                 mov     large fs:0, ecx
.text$mn:0000083A                 pop     ecx
.text$mn:0000083B                 mov     esp, ebp
.text$mn:0000083D                 pop     ebp
.text$mn:0000083E                 retn
.text$mn:0000083E ??0_Iostream_error_category@std@@QAE@XZ endp
.text$mn:0000083E
.text$mn:0000083E ; ---------------------------------------------------------------------------
.text$mn:0000083F                 align 10h
.text$mn:0000083F _text$mn        ends
.text$mn:0000083F
.text$x:00000840 ; ===========================================================================
.text$x:00000840
.text$x:00000840 ; Segment type: Pure code
.text$x:00000840 ; Segment permissions: Read/Execute
.text$x:00000840 _text$x         segment para public 'CODE' use32
.text$x:00000840                 assume cs:_text$x
.text$x:00000840                 ;org 840h
.text$x:00000840 ; COMDAT (pick associative to section at 7E8)
.text$x:00000840                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text$x:00000840
.text$x:00000840 ; =============== S U B R O U T I N E =======================================
.text$x:00000840
.text$x:00000840
.text$x:00000840 __unwindfunclet$??0_Iostream_error_category@std@@QAE@XZ$0 proc near
.text$x:00000840                                         ; DATA XREF: .xdata$x:00002000o
.text$x:00000840                 mov     ecx, [ebp-10h]  ; this
.text$x:00000843                 jmp     ??1_Generic_error_category@std@@UAE@XZ ; std::_Generic_error_category::~_Generic_error_category(void)
.text$x:00000843 __unwindfunclet$??0_Iostream_error_category@std@@QAE@XZ$0 endp
.text$x:00000843
.text$x:00000848
.text$x:00000848 ; =============== S U B R O U T I N E =======================================
.text$x:00000848
.text$x:00000848
.text$x:00000848 __ehhandler$??0_Iostream_error_category@std@@QAE@XZ proc near
.text$x:00000848                                         ; DATA XREF: std::_Iostream_error_category::_Iostream_error_category(void)+5o
.text$x:00000848
.text$x:00000848 arg_4           = dword ptr  8
.text$x:00000848
.text$x:00000848                 mov     edx, [esp+arg_4]
.text$x:0000084C                 lea     eax, [edx+0Ch]
.text$x:0000084F                 mov     ecx, [edx-8]
.text$x:00000852                 xor     ecx, eax
.text$x:00000854                 call    @__security_check_cookie@4 ; __security_check_cookie(x)
.text$x:00000859                 mov     eax, offset __ehfuncinfo$??0_Iostream_error_category@std@@QAE@XZ
.text$x:0000085E                 jmp     ___CxxFrameHandler3
.text$x:0000085E __ehhandler$??0_Iostream_error_category@std@@QAE@XZ endp
.text$x:0000085E
.text$x:0000085E ; ---------------------------------------------------------------------------
.text$x:00000863                 align 4
.text$x:00000863 _text$x         ends
.text$x:00000863
.text$mn:00000864 ; ===========================================================================
.text$mn:00000864
.text$mn:00000864 ; Segment type: Pure code
.text$mn:00000864 ; Segment permissions: Read/Execute
.text$mn:00000864 _text$mn        segment para public 'CODE' use32
.text$mn:00000864                 assume cs:_text$mn
.text$mn:00000864                 ;org 864h
.text$mn:00000864 ; COMDAT (pick any)
.text$mn:00000864                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text$mn:00000864
.text$mn:00000864 ; =============== S U B R O U T I N E =======================================
.text$mn:00000864
.text$mn:00000864 ; Attributes: bp-based frame
.text$mn:00000864
.text$mn:00000864 ; _DWORD __thiscall std::_System_error_category::_System_error_category(std::_System_error_category *__hidden this)
.text$mn:00000864                 public ??0_System_error_category@std@@QAE@XZ
.text$mn:00000864 ??0_System_error_category@std@@QAE@XZ proc near
.text$mn:00000864                                         ; CODE XREF: `dynamic initializer for 'std::_System_error_category std::_Error_objects<int>::_System_object''(void)+8p
.text$mn:00000864
.text$mn:00000864 var_10          = dword ptr -10h
.text$mn:00000864 var_C           = dword ptr -0Ch
.text$mn:00000864 var_4           = dword ptr -4
.text$mn:00000864
.text$mn:00000864                 push    ebp
.text$mn:00000865                 mov     ebp, esp
.text$mn:00000867                 push    0FFFFFFFFh
.text$mn:00000869                 push    offset __ehhandler$??0_System_error_category@std@@QAE@XZ
.text$mn:0000086E                 mov     eax, large fs:0
.text$mn:00000874                 push    eax
.text$mn:00000875                 push    ecx
.text$mn:00000876                 mov     eax, dword ptr ds:___security_cookie
.text$mn:0000087B                 xor     eax, ebp
.text$mn:0000087D                 push    eax
.text$mn:0000087E                 lea     eax, [ebp+var_C]
.text$mn:00000881                 mov     large fs:0, eax
.text$mn:00000887                 mov     [ebp+var_10], ecx
.text$mn:0000088A                 mov     ecx, [ebp+var_10] ; this
.text$mn:0000088D                 call    ??0_Generic_error_category@std@@QAE@XZ ; std::_Generic_error_category::_Generic_error_category(void)
.text$mn:00000892                 mov     [ebp+var_4], 0
.text$mn:00000899                 mov     eax, [ebp+var_10]
.text$mn:0000089C                 mov     dword ptr [eax], offset ??_7_System_error_category@std@@6B@ ; const std::_System_error_category::`vftable'
.text$mn:000008A2                 mov     [ebp+var_4], 0FFFFFFFFh
.text$mn:000008A9                 mov     eax, [ebp+var_10]
.text$mn:000008AC                 mov     ecx, [ebp+var_C]
.text$mn:000008AF                 mov     large fs:0, ecx
.text$mn:000008B6                 pop     ecx
.text$mn:000008B7                 mov     esp, ebp
.text$mn:000008B9                 pop     ebp
.text$mn:000008BA                 retn
.text$mn:000008BA ??0_System_error_category@std@@QAE@XZ endp
.text$mn:000008BA
.text$mn:000008BA ; ---------------------------------------------------------------------------
.text$mn:000008BB                 align 4
.text$mn:000008BB _text$mn        ends
.text$mn:000008BB
.text$x:000008BC ; ===========================================================================
.text$x:000008BC
.text$x:000008BC ; Segment type: Pure code
.text$x:000008BC ; Segment permissions: Read/Execute
.text$x:000008BC _text$x         segment para public 'CODE' use32
.text$x:000008BC                 assume cs:_text$x
.text$x:000008BC                 ;org 8BCh
.text$x:000008BC ; COMDAT (pick associative to section at 864)
.text$x:000008BC                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text$x:000008BC
.text$x:000008BC ; =============== S U B R O U T I N E =======================================
.text$x:000008BC
.text$x:000008BC
.text$x:000008BC __unwindfunclet$??0_System_error_category@std@@QAE@XZ$0 proc near
.text$x:000008BC                                         ; DATA XREF: .xdata$x:00002084o
.text$x:000008BC                 mov     ecx, [ebp-10h]  ; this
.text$x:000008BF                 jmp     ??1_Generic_error_category@std@@UAE@XZ ; std::_Generic_error_category::~_Generic_error_category(void)
.text$x:000008BF __unwindfunclet$??0_System_error_category@std@@QAE@XZ$0 endp
.text$x:000008BF
.text$x:000008C4
.text$x:000008C4 ; =============== S U B R O U T I N E =======================================
.text$x:000008C4
.text$x:000008C4
.text$x:000008C4 __ehhandler$??0_System_error_category@std@@QAE@XZ proc near
.text$x:000008C4                                         ; DATA XREF: std::_System_error_category::_System_error_category(void)+5o
.text$x:000008C4
.text$x:000008C4 arg_4           = dword ptr  8
.text$x:000008C4
.text$x:000008C4                 mov     edx, [esp+arg_4]
.text$x:000008C8                 lea     eax, [edx+0Ch]
.text$x:000008CB                 mov     ecx, [edx-8]
.text$x:000008CE                 xor     ecx, eax
.text$x:000008D0                 call    @__security_check_cookie@4 ; __security_check_cookie(x)
.text$x:000008D5                 mov     eax, offset __ehfuncinfo$??0_System_error_category@std@@QAE@XZ
.text$x:000008DA                 jmp     ___CxxFrameHandler3
.text$x:000008DA __ehhandler$??0_System_error_category@std@@QAE@XZ endp
.text$x:000008DA
.text$x:000008DA ; ---------------------------------------------------------------------------
.text$x:000008DF                 align 10h
.text$x:000008DF _text$x         ends
.text$x:000008DF
.text$mn:000008E0 ; ===========================================================================
.text$mn:000008E0
.text$mn:000008E0 ; Segment type: Pure code
.text$mn:000008E0 ; Segment permissions: Read/Execute
.text$mn:000008E0 _text$mn        segment para public 'CODE' use32
.text$mn:000008E0                 assume cs:_text$mn
.text$mn:000008E0                 ;org 8E0h
.text$mn:000008E0 ; COMDAT (pick any)
.text$mn:000008E0                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text$mn:000008E0
.text$mn:000008E0 ; =============== S U B R O U T I N E =======================================
.text$mn:000008E0
.text$mn:000008E0 ; Attributes: bp-based frame
.text$mn:000008E0
.text$mn:000008E0 ; _DWORD __thiscall std::error_category::error_category(std::error_category *__hidden this)
.text$mn:000008E0                 public ??0error_category@std@@QAE@XZ
.text$mn:000008E0 ??0error_category@std@@QAE@XZ proc near ; CODE XREF: std::_Generic_error_category::_Generic_error_category(void)+29p
.text$mn:000008E0
.text$mn:000008E0 var_4           = dword ptr -4
.text$mn:000008E0
.text$mn:000008E0                 push    ebp
.text$mn:000008E1                 mov     ebp, esp
.text$mn:000008E3                 push    ecx
.text$mn:000008E4                 mov     [ebp+var_4], ecx
.text$mn:000008E7                 mov     eax, [ebp+var_4]
.text$mn:000008EA                 mov     dword ptr [eax], offset ??_7error_category@std@@6B@ ; const std::error_category::`vftable'
.text$mn:000008F0                 mov     eax, [ebp+var_4]
.text$mn:000008F3                 mov     esp, ebp
.text$mn:000008F5                 pop     ebp
.text$mn:000008F6                 retn
.text$mn:000008F6 ??0error_category@std@@QAE@XZ endp
.text$mn:000008F6
.text$mn:000008F6 ; ---------------------------------------------------------------------------
.text$mn:000008F7                 align 4
.text$mn:000008F7 _text$mn        ends
.text$mn:000008F7
.text$mn:000008F8 ; ===========================================================================
.text$mn:000008F8
.text$mn:000008F8 ; Segment type: Pure code
.text$mn:000008F8 ; Segment permissions: Read/Execute
.text$mn:000008F8 _text$mn        segment para public 'CODE' use32
.text$mn:000008F8                 assume cs:_text$mn
.text$mn:000008F8                 ;org 8F8h
.text$mn:000008F8 ; COMDAT (pick any)
.text$mn:000008F8                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text$mn:000008F8
.text$mn:000008F8 ; =============== S U B R O U T I N E =======================================
.text$mn:000008F8
.text$mn:000008F8 ; Attributes: bp-based frame
.text$mn:000008F8
.text$mn:000008F8 ; _DWORD __thiscall std::error_condition::error_condition(std::error_condition *this, int, const struct std::error_category *)
.text$mn:000008F8                 public ??0error_condition@std@@QAE@HABVerror_category@1@@Z
.text$mn:000008F8 ??0error_condition@std@@QAE@HABVerror_category@1@@Z proc near
.text$mn:000008F8                                         ; CODE XREF: std::_System_error_category::default_error_condition(int)+24p
.text$mn:000008F8                                         ; std::_System_error_category::default_error_condition(int)+3Dp ...
.text$mn:000008F8
.text$mn:000008F8 var_4           = dword ptr -4
.text$mn:000008F8 arg_0           = dword ptr  8
.text$mn:000008F8 arg_4           = dword ptr  0Ch
.text$mn:000008F8
.text$mn:000008F8                 push    ebp
.text$mn:000008F9                 mov     ebp, esp
.text$mn:000008FB                 push    ecx
.text$mn:000008FC                 mov     [ebp+var_4], ecx
.text$mn:000008FF                 mov     eax, [ebp+var_4]
.text$mn:00000902                 mov     ecx, [ebp+arg_0]
.text$mn:00000905                 mov     [eax], ecx
.text$mn:00000907                 mov     edx, [ebp+var_4]
.text$mn:0000090A                 mov     eax, [ebp+arg_4]
.text$mn:0000090D                 mov     [edx+4], eax
.text$mn:00000910                 mov     eax, [ebp+var_4]
.text$mn:00000913                 mov     esp, ebp
.text$mn:00000915                 pop     ebp
.text$mn:00000916                 retn    8
.text$mn:00000916 ??0error_condition@std@@QAE@HABVerror_category@1@@Z endp
.text$mn:00000916
.text$mn:00000916 ; ---------------------------------------------------------------------------
.text$mn:00000919                 align 4
.text$mn:00000919 _text$mn        ends
.text$mn:00000919
.text$mn:0000091C ; ===========================================================================
.text$mn:0000091C
.text$mn:0000091C ; Segment type: Pure code
.text$mn:0000091C ; Segment permissions: Read/Execute
.text$mn:0000091C _text$mn        segment para public 'CODE' use32
.text$mn:0000091C                 assume cs:_text$mn
.text$mn:0000091C                 ;org 91Ch
.text$mn:0000091C ; COMDAT (pick any)
.text$mn:0000091C                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text$mn:0000091C
.text$mn:0000091C ; =============== S U B R O U T I N E =======================================
.text$mn:0000091C
.text$mn:0000091C ; Attributes: bp-based frame
.text$mn:0000091C
.text$mn:0000091C ; _DWORD __thiscall std::runtime_error::runtime_error(std::runtime_error *this, const struct std::runtime_error *)
.text$mn:0000091C                 public ??0runtime_error@std@@QAE@ABV01@@Z
.text$mn:0000091C ??0runtime_error@std@@QAE@ABV01@@Z proc near
.text$mn:0000091C                                         ; DATA XREF: .xdata$x:000021C0o
.text$mn:0000091C
.text$mn:0000091C var_10          = dword ptr -10h
.text$mn:0000091C var_C           = dword ptr -0Ch
.text$mn:0000091C var_4           = dword ptr -4
.text$mn:0000091C arg_0           = dword ptr  8
.text$mn:0000091C
.text$mn:0000091C                 push    ebp
.text$mn:0000091D                 mov     ebp, esp
.text$mn:0000091F                 push    0FFFFFFFFh
.text$mn:00000921                 push    offset __ehhandler$??0runtime_error@std@@QAE@ABV01@@Z
.text$mn:00000926                 mov     eax, large fs:0
.text$mn:0000092C                 push    eax
.text$mn:0000092D                 push    ecx
.text$mn:0000092E                 mov     eax, dword ptr ds:___security_cookie
.text$mn:00000933                 xor     eax, ebp
.text$mn:00000935                 push    eax
.text$mn:00000936                 lea     eax, [ebp+var_C]
.text$mn:00000939                 mov     large fs:0, eax
.text$mn:0000093F                 mov     [ebp+var_10], ecx
.text$mn:00000942                 mov     eax, [ebp+arg_0]
.text$mn:00000945                 push    eax             ; struct std::exception *
.text$mn:00000946                 mov     ecx, [ebp+var_10] ; this
.text$mn:00000949                 call    ??0exception@std@@QAE@ABV01@@Z ; std::exception::exception(std::exception const &)
.text$mn:0000094E                 mov     [ebp+var_4], 0
.text$mn:00000955                 mov     ecx, [ebp+var_10]
.text$mn:00000958                 mov     dword ptr [ecx], offset ??_7runtime_error@std@@6B@ ; const std::runtime_error::`vftable'
.text$mn:0000095E                 mov     [ebp+var_4], 0FFFFFFFFh
.text$mn:00000965                 mov     eax, [ebp+var_10]
.text$mn:00000968                 mov     ecx, [ebp+var_C]
.text$mn:0000096B                 mov     large fs:0, ecx
.text$mn:00000972                 pop     ecx
.text$mn:00000973                 mov     esp, ebp
.text$mn:00000975                 pop     ebp
.text$mn:00000976                 retn    4
.text$mn:00000976 ??0runtime_error@std@@QAE@ABV01@@Z endp
.text$mn:00000976
.text$mn:00000976 ; ---------------------------------------------------------------------------
.text$mn:00000979                 align 4
.text$mn:00000979 _text$mn        ends
.text$mn:00000979
.text$x:0000097C ; ===========================================================================
.text$x:0000097C
.text$x:0000097C ; Segment type: Pure code
.text$x:0000097C ; Segment permissions: Read/Execute
.text$x:0000097C _text$x         segment para public 'CODE' use32
.text$x:0000097C                 assume cs:_text$x
.text$x:0000097C                 ;org 97Ch
.text$x:0000097C ; COMDAT (pick associative to section at 91C)
.text$x:0000097C                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text$x:0000097C
.text$x:0000097C ; =============== S U B R O U T I N E =======================================
.text$x:0000097C
.text$x:0000097C
.text$x:0000097C __unwindfunclet$??0runtime_error@std@@QAE@ABV01@@Z$0 proc near
.text$x:0000097C                                         ; DATA XREF: .xdata$x:00001F50o
.text$x:0000097C                 mov     ecx, [ebp-10h]  ; this
.text$x:0000097F                 jmp     ??1exception@std@@UAE@XZ ; std::exception::~exception(void)
.text$x:0000097F __unwindfunclet$??0runtime_error@std@@QAE@ABV01@@Z$0 endp
.text$x:0000097F
.text$x:00000984
.text$x:00000984 ; =============== S U B R O U T I N E =======================================
.text$x:00000984
.text$x:00000984
.text$x:00000984 __ehhandler$??0runtime_error@std@@QAE@ABV01@@Z proc near
.text$x:00000984                                         ; DATA XREF: std::runtime_error::runtime_error(std::runtime_error const &)+5o
.text$x:00000984
.text$x:00000984 arg_4           = dword ptr  8
.text$x:00000984
.text$x:00000984                 mov     edx, [esp+arg_4]
.text$x:00000988                 lea     eax, [edx+0Ch]
.text$x:0000098B                 mov     ecx, [edx-8]
.text$x:0000098E                 xor     ecx, eax
.text$x:00000990                 call    @__security_check_cookie@4 ; __security_check_cookie(x)
.text$x:00000995                 mov     eax, offset __ehfuncinfo$??0runtime_error@std@@QAE@ABV01@@Z
.text$x:0000099A                 jmp     ___CxxFrameHandler3
.text$x:0000099A __ehhandler$??0runtime_error@std@@QAE@ABV01@@Z endp
.text$x:0000099A
.text$x:0000099A ; ---------------------------------------------------------------------------
.text$x:0000099F                 align 10h
.text$x:0000099F _text$x         ends
.text$x:0000099F
.text$mn:000009A0 ; ===========================================================================
.text$mn:000009A0
.text$mn:000009A0 ; Segment type: Pure code
.text$mn:000009A0 ; Segment permissions: Read/Execute
.text$mn:000009A0 _text$mn        segment para public 'CODE' use32
.text$mn:000009A0                 assume cs:_text$mn
.text$mn:000009A0                 ;org 9A0h
.text$mn:000009A0 ; COMDAT (pick any)
.text$mn:000009A0                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text$mn:000009A0
.text$mn:000009A0 ; =============== S U B R O U T I N E =======================================
.text$mn:000009A0
.text$mn:000009A0 ; Attributes: bp-based frame
.text$mn:000009A0
.text$mn:000009A0 ; _DWORD __thiscall std::runtime_error::runtime_error(std::runtime_error *this, const char *)
.text$mn:000009A0                 public ??0runtime_error@std@@QAE@PBD@Z
.text$mn:000009A0 ??0runtime_error@std@@QAE@PBD@Z proc near
.text$mn:000009A0                                         ; CODE XREF: ToolTip::init(HINSTANCE__ *,HWND__ *)+6Dp
.text$mn:000009A0
.text$mn:000009A0 var_10          = dword ptr -10h
.text$mn:000009A0 var_C           = dword ptr -0Ch
.text$mn:000009A0 var_4           = dword ptr -4
.text$mn:000009A0 arg_0           = dword ptr  8
.text$mn:000009A0
.text$mn:000009A0                 push    ebp
.text$mn:000009A1                 mov     ebp, esp
.text$mn:000009A3                 push    0FFFFFFFFh
.text$mn:000009A5                 push    offset __ehhandler$??0runtime_error@std@@QAE@PBD@Z
.text$mn:000009AA                 mov     eax, large fs:0
.text$mn:000009B0                 push    eax
.text$mn:000009B1                 push    ecx
.text$mn:000009B2                 mov     eax, dword ptr ds:___security_cookie
.text$mn:000009B7                 xor     eax, ebp
.text$mn:000009B9                 push    eax
.text$mn:000009BA                 lea     eax, [ebp+var_C]
.text$mn:000009BD                 mov     large fs:0, eax
.text$mn:000009C3                 mov     [ebp+var_10], ecx
.text$mn:000009C6                 lea     eax, [ebp+arg_0]
.text$mn:000009C9                 push    eax             ; char **
.text$mn:000009CA                 mov     ecx, [ebp+var_10] ; this
.text$mn:000009CD                 call    ??0exception@std@@QAE@ABQBD@Z ; std::exception::exception(char const * const &)
.text$mn:000009D2                 mov     [ebp+var_4], 0
.text$mn:000009D9                 mov     ecx, [ebp+var_10]
.text$mn:000009DC                 mov     dword ptr [ecx], offset ??_7runtime_error@std@@6B@ ; const std::runtime_error::`vftable'
.text$mn:000009E2                 mov     [ebp+var_4], 0FFFFFFFFh
.text$mn:000009E9                 mov     eax, [ebp+var_10]
.text$mn:000009EC                 mov     ecx, [ebp+var_C]
.text$mn:000009EF                 mov     large fs:0, ecx
.text$mn:000009F6                 pop     ecx
.text$mn:000009F7                 mov     esp, ebp
.text$mn:000009F9                 pop     ebp
.text$mn:000009FA                 retn    4
.text$mn:000009FA ??0runtime_error@std@@QAE@PBD@Z endp
.text$mn:000009FA
.text$mn:000009FA ; ---------------------------------------------------------------------------
.text$mn:000009FD                 align 10h
.text$mn:000009FD _text$mn        ends
.text$mn:000009FD
.text$x:00000A00 ; ===========================================================================
.text$x:00000A00
.text$x:00000A00 ; Segment type: Pure code
.text$x:00000A00 ; Segment permissions: Read/Execute
.text$x:00000A00 _text$x         segment para public 'CODE' use32
.text$x:00000A00                 assume cs:_text$x
.text$x:00000A00                 ;org 0A00h
.text$x:00000A00 ; COMDAT (pick associative to section at 9A0)
.text$x:00000A00                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text$x:00000A00
.text$x:00000A00 ; =============== S U B R O U T I N E =======================================
.text$x:00000A00
.text$x:00000A00
.text$x:00000A00 __unwindfunclet$??0runtime_error@std@@QAE@PBD@Z$0 proc near
.text$x:00000A00                                         ; DATA XREF: .xdata$x:00001EF8o
.text$x:00000A00                 mov     ecx, [ebp-10h]  ; this
.text$x:00000A03                 jmp     ??1exception@std@@UAE@XZ ; std::exception::~exception(void)
.text$x:00000A03 __unwindfunclet$??0runtime_error@std@@QAE@PBD@Z$0 endp
.text$x:00000A03
.text$x:00000A08
.text$x:00000A08 ; =============== S U B R O U T I N E =======================================
.text$x:00000A08
.text$x:00000A08
.text$x:00000A08 __ehhandler$??0runtime_error@std@@QAE@PBD@Z proc near
.text$x:00000A08                                         ; DATA XREF: std::runtime_error::runtime_error(char const *)+5o
.text$x:00000A08
.text$x:00000A08 arg_4           = dword ptr  8
.text$x:00000A08
.text$x:00000A08                 mov     edx, [esp+arg_4]
.text$x:00000A0C                 lea     eax, [edx+0Ch]
.text$x:00000A0F                 mov     ecx, [edx-8]
.text$x:00000A12                 xor     ecx, eax
.text$x:00000A14                 call    @__security_check_cookie@4 ; __security_check_cookie(x)
.text$x:00000A19                 mov     eax, offset __ehfuncinfo$??0runtime_error@std@@QAE@PBD@Z
.text$x:00000A1E                 jmp     ___CxxFrameHandler3
.text$x:00000A1E __ehhandler$??0runtime_error@std@@QAE@PBD@Z endp
.text$x:00000A1E
.text$x:00000A1E ; ---------------------------------------------------------------------------
.text$x:00000A23                 align 4
.text$x:00000A23 _text$x         ends
.text$x:00000A23
.text$mn:00000A24 ; ===========================================================================
.text$mn:00000A24
.text$mn:00000A24 ; Segment type: Pure code
.text$mn:00000A24 ; Segment permissions: Read/Execute
.text$mn:00000A24 _text$mn        segment para public 'CODE' use32
.text$mn:00000A24                 assume cs:_text$mn
.text$mn:00000A24                 ;org 0A24h
.text$mn:00000A24 ; COMDAT (pick any)
.text$mn:00000A24                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text$mn:00000A24
.text$mn:00000A24 ; =============== S U B R O U T I N E =======================================
.text$mn:00000A24
.text$mn:00000A24 ; Attributes: bp-based frame
.text$mn:00000A24
.text$mn:00000A24 ; public: __thiscall std::_String_alloc<0, struct std::_String_base_types<char, class std::allocator<char>>>::~_String_alloc<0, struct std::_String_base_types<char, class std::allocator<char>>>(void)
.text$mn:00000A24                 public ??1?$_String_alloc@$0A@U?$_String_base_types@DV?$allocator@D@std@@@std@@@std@@QAE@XZ
.text$mn:00000A24 ??1?$_String_alloc@$0A@U?$_String_base_types@DV?$allocator@D@std@@@std@@@std@@QAE@XZ proc near
.text$mn:00000A24                                         ; CODE XREF: __unwindfunclet$??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@PBD@Z$0+3j
.text$mn:00000A24                                         ; std::basic_string<char,std::char_traits<char>,std::allocator<char>>::~basic_string<char,std::char_traits<char>,std::allocator<char>>(void)+43p ...
.text$mn:00000A24
.text$mn:00000A24 var_10          = dword ptr -10h
.text$mn:00000A24 var_C           = dword ptr -0Ch
.text$mn:00000A24 var_4           = dword ptr -4
.text$mn:00000A24
.text$mn:00000A24                 push    ebp
.text$mn:00000A25                 mov     ebp, esp
.text$mn:00000A27                 push    0FFFFFFFFh
.text$mn:00000A29                 push    offset __ehhandler$??1?$_String_alloc@$0A@U?$_String_base_types@DV?$allocator@D@std@@@std@@@std@@QAE@XZ
.text$mn:00000A2E                 mov     eax, large fs:0
.text$mn:00000A34                 push    eax
.text$mn:00000A35                 push    ecx
.text$mn:00000A36                 mov     eax, dword ptr ds:___security_cookie
.text$mn:00000A3B                 xor     eax, ebp
.text$mn:00000A3D                 push    eax
.text$mn:00000A3E                 lea     eax, [ebp+var_C]
.text$mn:00000A41                 mov     large fs:0, eax
.text$mn:00000A47                 mov     [ebp+var_10], ecx
.text$mn:00000A4A                 mov     [ebp+var_4], 0
.text$mn:00000A51                 mov     ecx, [ebp+var_10]
.text$mn:00000A54                 call    ?_Free_proxy@?$_String_alloc@$0A@U?$_String_base_types@DV?$allocator@D@std@@@std@@@std@@QAEXXZ ; std::_String_alloc<0,std::_String_base_types<char,std::allocator<char>>>::_Free_proxy(void)
.text$mn:00000A59                 mov     [ebp+var_4], 0FFFFFFFFh
.text$mn:00000A60                 mov     ecx, [ebp+var_10]
.text$mn:00000A63                 call    ??1?$_String_val@U?$_Simple_types@D@std@@@std@@QAE@XZ ; std::_String_val<std::_Simple_types<char>>::~_String_val<std::_Simple_types<char>>(void)
.text$mn:00000A68                 mov     ecx, [ebp+var_C]
.text$mn:00000A6B                 mov     large fs:0, ecx
.text$mn:00000A72                 pop     ecx
.text$mn:00000A73                 mov     esp, ebp
.text$mn:00000A75                 pop     ebp
.text$mn:00000A76                 retn
.text$mn:00000A76 ??1?$_String_alloc@$0A@U?$_String_base_types@DV?$allocator@D@std@@@std@@@std@@QAE@XZ endp
.text$mn:00000A76
.text$mn:00000A76 ; ---------------------------------------------------------------------------
.text$mn:00000A77                 align 4
.text$mn:00000A77 _text$mn        ends
.text$mn:00000A77
.text$x:00000A78 ; ===========================================================================
.text$x:00000A78
.text$x:00000A78 ; Segment type: Pure code
.text$x:00000A78 ; Segment permissions: Read/Execute
.text$x:00000A78 _text$x         segment para public 'CODE' use32
.text$x:00000A78                 assume cs:_text$x
.text$x:00000A78                 ;org 0A78h
.text$x:00000A78 ; COMDAT (pick associative to section at A24)
.text$x:00000A78                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text$x:00000A78
.text$x:00000A78 ; =============== S U B R O U T I N E =======================================
.text$x:00000A78
.text$x:00000A78
.text$x:00000A78 __unwindfunclet$??1?$_String_alloc@$0A@U?$_String_base_types@DV?$allocator@D@std@@@std@@@std@@QAE@XZ$0 proc near
.text$x:00000A78                                         ; DATA XREF: .xdata$x:00001DE8o
.text$x:00000A78                 mov     ecx, [ebp-10h]
.text$x:00000A7B                 jmp     ??1?$_String_val@U?$_Simple_types@D@std@@@std@@QAE@XZ ; std::_String_val<std::_Simple_types<char>>::~_String_val<std::_Simple_types<char>>(void)
.text$x:00000A7B __unwindfunclet$??1?$_String_alloc@$0A@U?$_String_base_types@DV?$allocator@D@std@@@std@@@std@@QAE@XZ$0 endp
.text$x:00000A7B
.text$x:00000A80
.text$x:00000A80 ; =============== S U B R O U T I N E =======================================
.text$x:00000A80
.text$x:00000A80
.text$x:00000A80 __ehhandler$??1?$_String_alloc@$0A@U?$_String_base_types@DV?$allocator@D@std@@@std@@@std@@QAE@XZ proc near
.text$x:00000A80                                         ; DATA XREF: std::_String_alloc<0,std::_String_base_types<char,std::allocator<char>>>::~_String_alloc<0,std::_String_base_types<char,std::allocator<char>>>(void)+5o
.text$x:00000A80
.text$x:00000A80 arg_4           = dword ptr  8
.text$x:00000A80
.text$x:00000A80                 mov     edx, [esp+arg_4]
.text$x:00000A84                 lea     eax, [edx+0Ch]
.text$x:00000A87                 mov     ecx, [edx-8]
.text$x:00000A8A                 xor     ecx, eax
.text$x:00000A8C                 call    @__security_check_cookie@4 ; __security_check_cookie(x)
.text$x:00000A91                 mov     eax, offset __ehfuncinfo$??1?$_String_alloc@$0A@U?$_String_base_types@DV?$allocator@D@std@@@std@@@std@@QAE@XZ
.text$x:00000A96                 jmp     ___CxxFrameHandler3
.text$x:00000A96 __ehhandler$??1?$_String_alloc@$0A@U?$_String_base_types@DV?$allocator@D@std@@@std@@@std@@QAE@XZ endp
.text$x:00000A96
.text$x:00000A96 ; ---------------------------------------------------------------------------
.text$x:00000A9B                 align 4
.text$x:00000A9B _text$x         ends
.text$x:00000A9B
.text$mn:00000A9C ; ===========================================================================
.text$mn:00000A9C
.text$mn:00000A9C ; Segment type: Pure code
.text$mn:00000A9C ; Segment permissions: Read/Execute
.text$mn:00000A9C _text$mn        segment para public 'CODE' use32
.text$mn:00000A9C                 assume cs:_text$mn
.text$mn:00000A9C                 ;org 0A9Ch
.text$mn:00000A9C ; COMDAT (pick any)
.text$mn:00000A9C                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text$mn:00000A9C
.text$mn:00000A9C ; =============== S U B R O U T I N E =======================================
.text$mn:00000A9C
.text$mn:00000A9C ; Attributes: bp-based frame
.text$mn:00000A9C
.text$mn:00000A9C ; public: __thiscall std::_String_val<struct std::_Simple_types<char>>::~_String_val<struct std::_Simple_types<char>>(void)
.text$mn:00000A9C                 public ??1?$_String_val@U?$_Simple_types@D@std@@@std@@QAE@XZ
.text$mn:00000A9C ??1?$_String_val@U?$_Simple_types@D@std@@@std@@QAE@XZ proc near
.text$mn:00000A9C                                         ; CODE XREF: __unwindfunclet$??0?$_String_alloc@$0A@U?$_String_base_types@DV?$allocator@D@std@@@std@@@std@@QAE@ABV?$allocator@D@1@@Z$0+3j
.text$mn:00000A9C                                         ; std::_String_alloc<0,std::_String_base_types<char,std::allocator<char>>>::~_String_alloc<0,std::_String_base_types<char,std::allocator<char>>>(void)+3Fp ...
.text$mn:00000A9C
.text$mn:00000A9C var_10          = dword ptr -10h
.text$mn:00000A9C var_C           = dword ptr -0Ch
.text$mn:00000A9C var_4           = dword ptr -4
.text$mn:00000A9C
.text$mn:00000A9C                 push    ebp
.text$mn:00000A9D                 mov     ebp, esp
.text$mn:00000A9F                 push    0FFFFFFFFh
.text$mn:00000AA1                 push    offset __ehhandler$??1?$_String_val@U?$_Simple_types@D@std@@@std@@QAE@XZ
.text$mn:00000AA6                 mov     eax, large fs:0
.text$mn:00000AAC                 push    eax
.text$mn:00000AAD                 push    ecx
.text$mn:00000AAE                 mov     eax, dword ptr ds:___security_cookie
.text$mn:00000AB3                 xor     eax, ebp
.text$mn:00000AB5                 push    eax
.text$mn:00000AB6                 lea     eax, [ebp+var_C]
.text$mn:00000AB9                 mov     large fs:0, eax
.text$mn:00000ABF                 mov     [ebp+var_10], ecx
.text$mn:00000AC2                 mov     [ebp+var_4], 0
.text$mn:00000AC9                 mov     [ebp+var_4], 0FFFFFFFFh
.text$mn:00000AD0                 mov     ecx, [ebp+var_10] ; this
.text$mn:00000AD3                 call    ??1_Container_base12@std@@QAE@XZ ; std::_Container_base12::~_Container_base12(void)
.text$mn:00000AD8                 mov     ecx, [ebp+var_C]
.text$mn:00000ADB                 mov     large fs:0, ecx
.text$mn:00000AE2                 pop     ecx
.text$mn:00000AE3                 mov     esp, ebp
.text$mn:00000AE5                 pop     ebp
.text$mn:00000AE6                 retn
.text$mn:00000AE6 ??1?$_String_val@U?$_Simple_types@D@std@@@std@@QAE@XZ endp
.text$mn:00000AE6
.text$mn:00000AE6 ; ---------------------------------------------------------------------------
.text$mn:00000AE7                 align 4
.text$mn:00000AE7 _text$mn        ends
.text$mn:00000AE7
.text$x:00000AE8 ; ===========================================================================
.text$x:00000AE8
.text$x:00000AE8 ; Segment type: Pure code
.text$x:00000AE8 ; Segment permissions: Read/Execute
.text$x:00000AE8 _text$x         segment para public 'CODE' use32
.text$x:00000AE8                 assume cs:_text$x
.text$x:00000AE8                 ;org 0AE8h
.text$x:00000AE8 ; COMDAT (pick associative to section at A9C)
.text$x:00000AE8                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text$x:00000AE8
.text$x:00000AE8 ; =============== S U B R O U T I N E =======================================
.text$x:00000AE8
.text$x:00000AE8
.text$x:00000AE8 __unwindfunclet$??1?$_String_val@U?$_Simple_types@D@std@@@std@@QAE@XZ$0 proc near
.text$x:00000AE8                                         ; DATA XREF: .xdata$x:00001D90o
.text$x:00000AE8                 mov     ecx, [ebp-10h]  ; this
.text$x:00000AEB                 jmp     ??1_Container_base12@std@@QAE@XZ ; std::_Container_base12::~_Container_base12(void)
.text$x:00000AEB __unwindfunclet$??1?$_String_val@U?$_Simple_types@D@std@@@std@@QAE@XZ$0 endp
.text$x:00000AEB
.text$x:00000AF0
.text$x:00000AF0 ; =============== S U B R O U T I N E =======================================
.text$x:00000AF0
.text$x:00000AF0
.text$x:00000AF0 __ehhandler$??1?$_String_val@U?$_Simple_types@D@std@@@std@@QAE@XZ proc near
.text$x:00000AF0                                         ; DATA XREF: std::_String_val<std::_Simple_types<char>>::~_String_val<std::_Simple_types<char>>(void)+5o
.text$x:00000AF0
.text$x:00000AF0 arg_4           = dword ptr  8
.text$x:00000AF0
.text$x:00000AF0                 mov     edx, [esp+arg_4]
.text$x:00000AF4                 lea     eax, [edx+0Ch]
.text$x:00000AF7                 mov     ecx, [edx-8]
.text$x:00000AFA                 xor     ecx, eax
.text$x:00000AFC                 call    @__security_check_cookie@4 ; __security_check_cookie(x)
.text$x:00000B01                 mov     eax, offset __ehfuncinfo$??1?$_String_val@U?$_Simple_types@D@std@@@std@@QAE@XZ
.text$x:00000B06                 jmp     ___CxxFrameHandler3
.text$x:00000B06 __ehhandler$??1?$_String_val@U?$_Simple_types@D@std@@@std@@QAE@XZ endp
.text$x:00000B06
.text$x:00000B06 ; ---------------------------------------------------------------------------
.text$x:00000B0B                 align 4
.text$x:00000B0B _text$x         ends
.text$x:00000B0B
.text$mn:00000B0C ; ===========================================================================
.text$mn:00000B0C
.text$mn:00000B0C ; Segment type: Pure code
.text$mn:00000B0C ; Segment permissions: Read/Execute
.text$mn:00000B0C _text$mn        segment para public 'CODE' use32
.text$mn:00000B0C                 assume cs:_text$mn
.text$mn:00000B0C                 ;org 0B0Ch
.text$mn:00000B0C ; COMDAT (pick any)
.text$mn:00000B0C                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text$mn:00000B0C
.text$mn:00000B0C ; =============== S U B R O U T I N E =======================================
.text$mn:00000B0C
.text$mn:00000B0C ; Attributes: bp-based frame
.text$mn:00000B0C
.text$mn:00000B0C ; public: __thiscall std::basic_string<char, struct std::char_traits<char>, class std::allocator<char>>::~basic_string<char, struct std::char_traits<char>, class std::allocator<char>>(void)
.text$mn:00000B0C                 public ??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ
.text$mn:00000B0C ??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ proc near
.text$mn:00000B0C                                         ; CODE XREF: __unwindfunclet$?message@_Generic_error_category@std@@UBE?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@2@H@Z$0+13j
.text$mn:00000B0C                                         ; __unwindfunclet$?message@_Iostream_error_category@std@@UBE?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@2@H@Z$0+13j ...
.text$mn:00000B0C
.text$mn:00000B0C var_10          = dword ptr -10h
.text$mn:00000B0C var_C           = dword ptr -0Ch
.text$mn:00000B0C var_4           = dword ptr -4
.text$mn:00000B0C
.text$mn:00000B0C                 push    ebp
.text$mn:00000B0D                 mov     ebp, esp
.text$mn:00000B0F                 push    0FFFFFFFFh
.text$mn:00000B11                 push    offset __ehhandler$??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ
.text$mn:00000B16                 mov     eax, large fs:0
.text$mn:00000B1C                 push    eax
.text$mn:00000B1D                 push    ecx
.text$mn:00000B1E                 mov     eax, dword ptr ds:___security_cookie
.text$mn:00000B23                 xor     eax, ebp
.text$mn:00000B25                 push    eax
.text$mn:00000B26                 lea     eax, [ebp+var_C]
.text$mn:00000B29                 mov     large fs:0, eax
.text$mn:00000B2F                 mov     [ebp+var_10], ecx
.text$mn:00000B32                 mov     [ebp+var_4], 0
.text$mn:00000B39                 push    0               ; Size
.text$mn:00000B3B                 push    1               ; char
.text$mn:00000B3D                 mov     ecx, [ebp+var_10]
.text$mn:00000B40                 call    ?_Tidy@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEX_NI@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char>>::_Tidy(bool,uint)
.text$mn:00000B45                 mov     [ebp+var_4], 0FFFFFFFFh
.text$mn:00000B4C                 mov     ecx, [ebp+var_10]
.text$mn:00000B4F                 call    ??1?$_String_alloc@$0A@U?$_String_base_types@DV?$allocator@D@std@@@std@@@std@@QAE@XZ ; std::_String_alloc<0,std::_String_base_types<char,std::allocator<char>>>::~_String_alloc<0,std::_String_base_types<char,std::allocator<char>>>(void)
.text$mn:00000B54                 mov     ecx, [ebp+var_C]
.text$mn:00000B57                 mov     large fs:0, ecx
.text$mn:00000B5E                 pop     ecx
.text$mn:00000B5F                 mov     esp, ebp
.text$mn:00000B61                 pop     ebp
.text$mn:00000B62                 retn
.text$mn:00000B62 ??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ endp
.text$mn:00000B62
.text$mn:00000B62 ; ---------------------------------------------------------------------------
.text$mn:00000B63                 align 4
.text$mn:00000B63 _text$mn        ends
.text$mn:00000B63
.text$x:00000B64 ; ===========================================================================
.text$x:00000B64
.text$x:00000B64 ; Segment type: Pure code
.text$x:00000B64 ; Segment permissions: Read/Execute
.text$x:00000B64 _text$x         segment para public 'CODE' use32
.text$x:00000B64                 assume cs:_text$x
.text$x:00000B64                 ;org 0B64h
.text$x:00000B64 ; COMDAT (pick associative to section at B0C)
.text$x:00000B64                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text$x:00000B64
.text$x:00000B64 ; =============== S U B R O U T I N E =======================================
.text$x:00000B64
.text$x:00000B64
.text$x:00000B64 __unwindfunclet$??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ$0 proc near
.text$x:00000B64                                         ; DATA XREF: .xdata$x:00001E40o
.text$x:00000B64                 mov     ecx, [ebp-10h]
.text$x:00000B67                 jmp     ??1?$_String_alloc@$0A@U?$_String_base_types@DV?$allocator@D@std@@@std@@@std@@QAE@XZ ; std::_String_alloc<0,std::_String_base_types<char,std::allocator<char>>>::~_String_alloc<0,std::_String_base_types<char,std::allocator<char>>>(void)
.text$x:00000B67 __unwindfunclet$??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ$0 endp
.text$x:00000B67
.text$x:00000B6C
.text$x:00000B6C ; =============== S U B R O U T I N E =======================================
.text$x:00000B6C
.text$x:00000B6C
.text$x:00000B6C __ehhandler$??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ proc near
.text$x:00000B6C                                         ; DATA XREF: std::basic_string<char,std::char_traits<char>,std::allocator<char>>::~basic_string<char,std::char_traits<char>,std::allocator<char>>(void)+5o
.text$x:00000B6C
.text$x:00000B6C arg_4           = dword ptr  8
.text$x:00000B6C
.text$x:00000B6C                 mov     edx, [esp+arg_4]
.text$x:00000B70                 lea     eax, [edx+0Ch]
.text$x:00000B73                 mov     ecx, [edx-8]
.text$x:00000B76                 xor     ecx, eax
.text$x:00000B78                 call    @__security_check_cookie@4 ; __security_check_cookie(x)
.text$x:00000B7D                 mov     eax, offset __ehfuncinfo$??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ
.text$x:00000B82                 jmp     ___CxxFrameHandler3
.text$x:00000B82 __ehhandler$??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ endp
.text$x:00000B82
.text$x:00000B82 ; ---------------------------------------------------------------------------
.text$x:00000B87                 align 4
.text$x:00000B87 _text$x         ends
.text$x:00000B87
.text$mn:00000B88 ; ===========================================================================
.text$mn:00000B88
.text$mn:00000B88 ; Segment type: Pure code
.text$mn:00000B88 ; Segment permissions: Read/Execute
.text$mn:00000B88 _text$mn        segment para public 'CODE' use32
.text$mn:00000B88                 assume cs:_text$mn
.text$mn:00000B88                 ;org 0B88h
.text$mn:00000B88 ; COMDAT (pick any)
.text$mn:00000B88                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text$mn:00000B88
.text$mn:00000B88 ; =============== S U B R O U T I N E =======================================
.text$mn:00000B88
.text$mn:00000B88 ; Attributes: bp-based frame
.text$mn:00000B88
.text$mn:00000B88 ; _DWORD __thiscall std::_Container_base12::~_Container_base12(std::_Container_base12 *__hidden this)
.text$mn:00000B88                 public ??1_Container_base12@std@@QAE@XZ
.text$mn:00000B88 ??1_Container_base12@std@@QAE@XZ proc near
.text$mn:00000B88                                         ; CODE XREF: __unwindfunclet$??0?$_String_val@U?$_Simple_types@D@std@@@std@@QAE@XZ$0+3j
.text$mn:00000B88                                         ; std::_String_val<std::_Simple_types<char>>::~_String_val<std::_Simple_types<char>>(void)+37p ...
.text$mn:00000B88
.text$mn:00000B88 var_4           = dword ptr -4
.text$mn:00000B88
.text$mn:00000B88                 push    ebp
.text$mn:00000B89                 mov     ebp, esp
.text$mn:00000B8B                 push    ecx
.text$mn:00000B8C                 mov     [ebp+var_4], ecx
.text$mn:00000B8F                 mov     ecx, [ebp+var_4] ; this
.text$mn:00000B92                 call    ?_Orphan_all@_Container_base12@std@@QAEXXZ ; std::_Container_base12::_Orphan_all(void)
.text$mn:00000B97                 mov     esp, ebp
.text$mn:00000B99                 pop     ebp
.text$mn:00000B9A                 retn
.text$mn:00000B9A ??1_Container_base12@std@@QAE@XZ endp
.text$mn:00000B9A
.text$mn:00000B9A ; ---------------------------------------------------------------------------
.text$mn:00000B9B                 align 4
.text$mn:00000B9B _text$mn        ends
.text$mn:00000B9B
.text$mn:00000B9C ; ===========================================================================
.text$mn:00000B9C
.text$mn:00000B9C ; Segment type: Pure code
.text$mn:00000B9C ; Segment permissions: Read/Execute
.text$mn:00000B9C _text$mn        segment para public 'CODE' use32
.text$mn:00000B9C                 assume cs:_text$mn
.text$mn:00000B9C                 ;org 0B9Ch
.text$mn:00000B9C ; COMDAT (pick any)
.text$mn:00000B9C                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text$mn:00000B9C
.text$mn:00000B9C ; =============== S U B R O U T I N E =======================================
.text$mn:00000B9C
.text$mn:00000B9C ; Attributes: bp-based frame
.text$mn:00000B9C
.text$mn:00000B9C ; _DWORD __thiscall std::_Generic_error_category::~_Generic_error_category(std::_Generic_error_category *__hidden this)
.text$mn:00000B9C                 public ??1_Generic_error_category@std@@UAE@XZ
.text$mn:00000B9C ??1_Generic_error_category@std@@UAE@XZ proc near
.text$mn:00000B9C                                         ; CODE XREF: __unwindfunclet$??0_Iostream_error_category@std@@QAE@XZ$0+3j
.text$mn:00000B9C                                         ; __unwindfunclet$??0_System_error_category@std@@QAE@XZ$0+3j ...
.text$mn:00000B9C
.text$mn:00000B9C var_10          = dword ptr -10h
.text$mn:00000B9C var_C           = dword ptr -0Ch
.text$mn:00000B9C var_4           = dword ptr -4
.text$mn:00000B9C
.text$mn:00000B9C                 push    ebp
.text$mn:00000B9D                 mov     ebp, esp
.text$mn:00000B9F                 push    0FFFFFFFFh
.text$mn:00000BA1                 push    offset __ehhandler$??1_Generic_error_category@std@@UAE@XZ
.text$mn:00000BA6                 mov     eax, large fs:0
.text$mn:00000BAC                 push    eax
.text$mn:00000BAD                 push    ecx
.text$mn:00000BAE                 mov     eax, dword ptr ds:___security_cookie
.text$mn:00000BB3                 xor     eax, ebp
.text$mn:00000BB5                 push    eax
.text$mn:00000BB6                 lea     eax, [ebp+var_C]
.text$mn:00000BB9                 mov     large fs:0, eax
.text$mn:00000BBF                 mov     [ebp+var_10], ecx
.text$mn:00000BC2                 mov     [ebp+var_4], 0
.text$mn:00000BC9                 mov     [ebp+var_4], 0FFFFFFFFh
.text$mn:00000BD0                 mov     ecx, [ebp+var_10] ; this
.text$mn:00000BD3                 call    ??1error_category@std@@UAE@XZ ; std::error_category::~error_category(void)
.text$mn:00000BD8                 mov     ecx, [ebp+var_C]
.text$mn:00000BDB                 mov     large fs:0, ecx
.text$mn:00000BE2                 pop     ecx
.text$mn:00000BE3                 mov     esp, ebp
.text$mn:00000BE5                 pop     ebp
.text$mn:00000BE6                 retn
.text$mn:00000BE6 ??1_Generic_error_category@std@@UAE@XZ endp
.text$mn:00000BE6
.text$mn:00000BE6 ; ---------------------------------------------------------------------------
.text$mn:00000BE7                 align 4
.text$mn:00000BE7 _text$mn        ends
.text$mn:00000BE7
.text$x:00000BE8 ; ===========================================================================
.text$x:00000BE8
.text$x:00000BE8 ; Segment type: Pure code
.text$x:00000BE8 ; Segment permissions: Read/Execute
.text$x:00000BE8 _text$x         segment para public 'CODE' use32
.text$x:00000BE8                 assume cs:_text$x
.text$x:00000BE8                 ;org 0BE8h
.text$x:00000BE8 ; COMDAT (pick associative to section at B9C)
.text$x:00000BE8                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text$x:00000BE8
.text$x:00000BE8 ; =============== S U B R O U T I N E =======================================
.text$x:00000BE8
.text$x:00000BE8
.text$x:00000BE8 __unwindfunclet$??1_Generic_error_category@std@@UAE@XZ$0 proc near
.text$x:00000BE8                                         ; DATA XREF: .xdata$x:00001FD4o
.text$x:00000BE8                 mov     ecx, [ebp-10h]  ; this
.text$x:00000BEB                 jmp     ??1error_category@std@@UAE@XZ ; std::error_category::~error_category(void)
.text$x:00000BEB __unwindfunclet$??1_Generic_error_category@std@@UAE@XZ$0 endp
.text$x:00000BEB
.text$x:00000BF0
.text$x:00000BF0 ; =============== S U B R O U T I N E =======================================
.text$x:00000BF0
.text$x:00000BF0
.text$x:00000BF0 __ehhandler$??1_Generic_error_category@std@@UAE@XZ proc near
.text$x:00000BF0                                         ; DATA XREF: std::_Generic_error_category::~_Generic_error_category(void)+5o
.text$x:00000BF0
.text$x:00000BF0 arg_4           = dword ptr  8
.text$x:00000BF0
.text$x:00000BF0                 mov     edx, [esp+arg_4]
.text$x:00000BF4                 lea     eax, [edx+0Ch]
.text$x:00000BF7                 mov     ecx, [edx-8]
.text$x:00000BFA                 xor     ecx, eax
.text$x:00000BFC                 call    @__security_check_cookie@4 ; __security_check_cookie(x)
.text$x:00000C01                 mov     eax, offset __ehfuncinfo$??1_Generic_error_category@std@@UAE@XZ
.text$x:00000C06                 jmp     ___CxxFrameHandler3
.text$x:00000C06 __ehhandler$??1_Generic_error_category@std@@UAE@XZ endp
.text$x:00000C06
.text$x:00000C06 ; ---------------------------------------------------------------------------
.text$x:00000C0B                 align 4
.text$x:00000C0B _text$x         ends
.text$x:00000C0B
.text$mn:00000C0C ; ===========================================================================
.text$mn:00000C0C
.text$mn:00000C0C ; Segment type: Pure code
.text$mn:00000C0C ; Segment permissions: Read/Execute
.text$mn:00000C0C _text$mn        segment para public 'CODE' use32
.text$mn:00000C0C                 assume cs:_text$mn
.text$mn:00000C0C                 ;org 0C0Ch
.text$mn:00000C0C ; COMDAT (pick any)
.text$mn:00000C0C                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text$mn:00000C0C
.text$mn:00000C0C ; =============== S U B R O U T I N E =======================================
.text$mn:00000C0C
.text$mn:00000C0C ; Attributes: bp-based frame
.text$mn:00000C0C
.text$mn:00000C0C ; _DWORD __thiscall std::_Iostream_error_category::~_Iostream_error_category(std::_Iostream_error_category *__hidden this)
.text$mn:00000C0C                 public ??1_Iostream_error_category@std@@UAE@XZ
.text$mn:00000C0C ??1_Iostream_error_category@std@@UAE@XZ proc near
.text$mn:00000C0C                                         ; CODE XREF: std::_Iostream_error_category::`scalar deleting destructor'(uint)+Ap
.text$mn:00000C0C                                         ; `dynamic atexit destructor for 'std::_Iostream_error_category std::_Error_objects<int>::_Iostream_object''(void)+8p
.text$mn:00000C0C
.text$mn:00000C0C var_10          = dword ptr -10h
.text$mn:00000C0C var_C           = dword ptr -0Ch
.text$mn:00000C0C var_4           = dword ptr -4
.text$mn:00000C0C
.text$mn:00000C0C                 push    ebp
.text$mn:00000C0D                 mov     ebp, esp
.text$mn:00000C0F                 push    0FFFFFFFFh
.text$mn:00000C11                 push    offset __ehhandler$??1_Iostream_error_category@std@@UAE@XZ
.text$mn:00000C16                 mov     eax, large fs:0
.text$mn:00000C1C                 push    eax
.text$mn:00000C1D                 push    ecx
.text$mn:00000C1E                 mov     eax, dword ptr ds:___security_cookie
.text$mn:00000C23                 xor     eax, ebp
.text$mn:00000C25                 push    eax
.text$mn:00000C26                 lea     eax, [ebp+var_C]
.text$mn:00000C29                 mov     large fs:0, eax
.text$mn:00000C2F                 mov     [ebp+var_10], ecx
.text$mn:00000C32                 mov     [ebp+var_4], 0
.text$mn:00000C39                 mov     [ebp+var_4], 0FFFFFFFFh
.text$mn:00000C40                 mov     ecx, [ebp+var_10] ; this
.text$mn:00000C43                 call    ??1_Generic_error_category@std@@UAE@XZ ; std::_Generic_error_category::~_Generic_error_category(void)
.text$mn:00000C48                 mov     ecx, [ebp+var_C]
.text$mn:00000C4B                 mov     large fs:0, ecx
.text$mn:00000C52                 pop     ecx
.text$mn:00000C53                 mov     esp, ebp
.text$mn:00000C55                 pop     ebp
.text$mn:00000C56                 retn
.text$mn:00000C56 ??1_Iostream_error_category@std@@UAE@XZ endp
.text$mn:00000C56
.text$mn:00000C56 ; ---------------------------------------------------------------------------
.text$mn:00000C57                 align 4
.text$mn:00000C57 _text$mn        ends
.text$mn:00000C57
.text$x:00000C58 ; ===========================================================================
.text$x:00000C58
.text$x:00000C58 ; Segment type: Pure code
.text$x:00000C58 ; Segment permissions: Read/Execute
.text$x:00000C58 _text$x         segment para public 'CODE' use32
.text$x:00000C58                 assume cs:_text$x
.text$x:00000C58                 ;org 0C58h
.text$x:00000C58 ; COMDAT (pick associative to section at C0C)
.text$x:00000C58                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text$x:00000C58
.text$x:00000C58 ; =============== S U B R O U T I N E =======================================
.text$x:00000C58
.text$x:00000C58
.text$x:00000C58 __unwindfunclet$??1_Iostream_error_category@std@@UAE@XZ$0 proc near
.text$x:00000C58                                         ; DATA XREF: .xdata$x:00002058o
.text$x:00000C58                 mov     ecx, [ebp-10h]  ; this
.text$x:00000C5B                 jmp     ??1_Generic_error_category@std@@UAE@XZ ; std::_Generic_error_category::~_Generic_error_category(void)
.text$x:00000C5B __unwindfunclet$??1_Iostream_error_category@std@@UAE@XZ$0 endp
.text$x:00000C5B
.text$x:00000C60
.text$x:00000C60 ; =============== S U B R O U T I N E =======================================
.text$x:00000C60
.text$x:00000C60
.text$x:00000C60 __ehhandler$??1_Iostream_error_category@std@@UAE@XZ proc near
.text$x:00000C60                                         ; DATA XREF: std::_Iostream_error_category::~_Iostream_error_category(void)+5o
.text$x:00000C60
.text$x:00000C60 arg_4           = dword ptr  8
.text$x:00000C60
.text$x:00000C60                 mov     edx, [esp+arg_4]
.text$x:00000C64                 lea     eax, [edx+0Ch]
.text$x:00000C67                 mov     ecx, [edx-8]
.text$x:00000C6A                 xor     ecx, eax
.text$x:00000C6C                 call    @__security_check_cookie@4 ; __security_check_cookie(x)
.text$x:00000C71                 mov     eax, offset __ehfuncinfo$??1_Iostream_error_category@std@@UAE@XZ
.text$x:00000C76                 jmp     ___CxxFrameHandler3
.text$x:00000C76 __ehhandler$??1_Iostream_error_category@std@@UAE@XZ endp
.text$x:00000C76
.text$x:00000C76 ; ---------------------------------------------------------------------------
.text$x:00000C7B                 align 4
.text$x:00000C7B _text$x         ends
.text$x:00000C7B
.text$mn:00000C7C ; ===========================================================================
.text$mn:00000C7C
.text$mn:00000C7C ; Segment type: Pure code
.text$mn:00000C7C ; Segment permissions: Read/Execute
.text$mn:00000C7C _text$mn        segment para public 'CODE' use32
.text$mn:00000C7C                 assume cs:_text$mn
.text$mn:00000C7C                 ;org 0C7Ch
.text$mn:00000C7C ; COMDAT (pick any)
.text$mn:00000C7C                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text$mn:00000C7C
.text$mn:00000C7C ; =============== S U B R O U T I N E =======================================
.text$mn:00000C7C
.text$mn:00000C7C ; Attributes: bp-based frame
.text$mn:00000C7C
.text$mn:00000C7C ; _DWORD __thiscall std::_System_error_category::~_System_error_category(std::_System_error_category *__hidden this)
.text$mn:00000C7C                 public ??1_System_error_category@std@@UAE@XZ
.text$mn:00000C7C ??1_System_error_category@std@@UAE@XZ proc near
.text$mn:00000C7C                                         ; CODE XREF: std::_System_error_category::`scalar deleting destructor'(uint)+Ap
.text$mn:00000C7C                                         ; `dynamic atexit destructor for 'std::_System_error_category std::_Error_objects<int>::_System_object''(void)+8p
.text$mn:00000C7C
.text$mn:00000C7C var_10          = dword ptr -10h
.text$mn:00000C7C var_C           = dword ptr -0Ch
.text$mn:00000C7C var_4           = dword ptr -4
.text$mn:00000C7C
.text$mn:00000C7C                 push    ebp
.text$mn:00000C7D                 mov     ebp, esp
.text$mn:00000C7F                 push    0FFFFFFFFh
.text$mn:00000C81                 push    offset __ehhandler$??1_System_error_category@std@@UAE@XZ
.text$mn:00000C86                 mov     eax, large fs:0
.text$mn:00000C8C                 push    eax
.text$mn:00000C8D                 push    ecx
.text$mn:00000C8E                 mov     eax, dword ptr ds:___security_cookie
.text$mn:00000C93                 xor     eax, ebp
.text$mn:00000C95                 push    eax
.text$mn:00000C96                 lea     eax, [ebp+var_C]
.text$mn:00000C99                 mov     large fs:0, eax
.text$mn:00000C9F                 mov     [ebp+var_10], ecx
.text$mn:00000CA2                 mov     [ebp+var_4], 0
.text$mn:00000CA9                 mov     [ebp+var_4], 0FFFFFFFFh
.text$mn:00000CB0                 mov     ecx, [ebp+var_10] ; this
.text$mn:00000CB3                 call    ??1_Generic_error_category@std@@UAE@XZ ; std::_Generic_error_category::~_Generic_error_category(void)
.text$mn:00000CB8                 mov     ecx, [ebp+var_C]
.text$mn:00000CBB                 mov     large fs:0, ecx
.text$mn:00000CC2                 pop     ecx
.text$mn:00000CC3                 mov     esp, ebp
.text$mn:00000CC5                 pop     ebp
.text$mn:00000CC6                 retn
.text$mn:00000CC6 ??1_System_error_category@std@@UAE@XZ endp
.text$mn:00000CC6
.text$mn:00000CC6 ; ---------------------------------------------------------------------------
.text$mn:00000CC7                 align 4
.text$mn:00000CC7 _text$mn        ends
.text$mn:00000CC7
.text$x:00000CC8 ; ===========================================================================
.text$x:00000CC8
.text$x:00000CC8 ; Segment type: Pure code
.text$x:00000CC8 ; Segment permissions: Read/Execute
.text$x:00000CC8 _text$x         segment para public 'CODE' use32
.text$x:00000CC8                 assume cs:_text$x
.text$x:00000CC8                 ;org 0CC8h
.text$x:00000CC8 ; COMDAT (pick associative to section at C7C)
.text$x:00000CC8                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text$x:00000CC8
.text$x:00000CC8 ; =============== S U B R O U T I N E =======================================
.text$x:00000CC8
.text$x:00000CC8
.text$x:00000CC8 __unwindfunclet$??1_System_error_category@std@@UAE@XZ$0 proc near
.text$x:00000CC8                                         ; DATA XREF: .xdata$x:000020DCo
.text$x:00000CC8                 mov     ecx, [ebp-10h]  ; this
.text$x:00000CCB                 jmp     ??1_Generic_error_category@std@@UAE@XZ ; std::_Generic_error_category::~_Generic_error_category(void)
.text$x:00000CCB __unwindfunclet$??1_System_error_category@std@@UAE@XZ$0 endp
.text$x:00000CCB
.text$x:00000CD0
.text$x:00000CD0 ; =============== S U B R O U T I N E =======================================
.text$x:00000CD0
.text$x:00000CD0
.text$x:00000CD0 __ehhandler$??1_System_error_category@std@@UAE@XZ proc near
.text$x:00000CD0                                         ; DATA XREF: std::_System_error_category::~_System_error_category(void)+5o
.text$x:00000CD0
.text$x:00000CD0 arg_4           = dword ptr  8
.text$x:00000CD0
.text$x:00000CD0                 mov     edx, [esp+arg_4]
.text$x:00000CD4                 lea     eax, [edx+0Ch]
.text$x:00000CD7                 mov     ecx, [edx-8]
.text$x:00000CDA                 xor     ecx, eax
.text$x:00000CDC                 call    @__security_check_cookie@4 ; __security_check_cookie(x)
.text$x:00000CE1                 mov     eax, offset __ehfuncinfo$??1_System_error_category@std@@UAE@XZ
.text$x:00000CE6                 jmp     ___CxxFrameHandler3
.text$x:00000CE6 __ehhandler$??1_System_error_category@std@@UAE@XZ endp
.text$x:00000CE6
.text$x:00000CE6 ; ---------------------------------------------------------------------------
.text$x:00000CEB                 align 4
.text$x:00000CEB _text$x         ends
.text$x:00000CEB
.text$mn:00000CEC ; ===========================================================================
.text$mn:00000CEC
.text$mn:00000CEC ; Segment type: Pure code
.text$mn:00000CEC ; Segment permissions: Read/Execute
.text$mn:00000CEC _text$mn        segment para public 'CODE' use32
.text$mn:00000CEC                 assume cs:_text$mn
.text$mn:00000CEC                 ;org 0CECh
.text$mn:00000CEC ; COMDAT (pick any)
.text$mn:00000CEC                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text$mn:00000CEC
.text$mn:00000CEC ; =============== S U B R O U T I N E =======================================
.text$mn:00000CEC
.text$mn:00000CEC ; Attributes: bp-based frame
.text$mn:00000CEC
.text$mn:00000CEC ; _DWORD __thiscall std::error_category::~error_category(std::error_category *__hidden this)
.text$mn:00000CEC                 public ??1error_category@std@@UAE@XZ
.text$mn:00000CEC ??1error_category@std@@UAE@XZ proc near ; CODE XREF: __unwindfunclet$??0_Generic_error_category@std@@QAE@XZ$0+3j
.text$mn:00000CEC                                         ; std::_Generic_error_category::~_Generic_error_category(void)+37p ...
.text$mn:00000CEC
.text$mn:00000CEC var_4           = dword ptr -4
.text$mn:00000CEC
.text$mn:00000CEC                 push    ebp
.text$mn:00000CED                 mov     ebp, esp
.text$mn:00000CEF                 push    ecx
.text$mn:00000CF0                 mov     [ebp+var_4], ecx
.text$mn:00000CF3                 mov     eax, [ebp+var_4]
.text$mn:00000CF6                 mov     dword ptr [eax], offset ??_7error_category@std@@6B@ ; const std::error_category::`vftable'
.text$mn:00000CFC                 mov     esp, ebp
.text$mn:00000CFE                 pop     ebp
.text$mn:00000CFF                 retn
.text$mn:00000CFF ??1error_category@std@@UAE@XZ endp
.text$mn:00000CFF
.text$mn:00000CFF _text$mn        ends
.text$mn:00000CFF
.text$mn:00000D00 ; ===========================================================================
.text$mn:00000D00
.text$mn:00000D00 ; Segment type: Pure code
.text$mn:00000D00 ; Segment permissions: Read/Execute
.text$mn:00000D00 _text$mn        segment para public 'CODE' use32
.text$mn:00000D00                 assume cs:_text$mn
.text$mn:00000D00                 ;org 0D00h
.text$mn:00000D00 ; COMDAT (pick any)
.text$mn:00000D00                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text$mn:00000D00
.text$mn:00000D00 ; =============== S U B R O U T I N E =======================================
.text$mn:00000D00
.text$mn:00000D00 ; Attributes: bp-based frame
.text$mn:00000D00
.text$mn:00000D00 ; _DWORD __thiscall std::runtime_error::~runtime_error(std::runtime_error *__hidden this)
.text$mn:00000D00                 public ??1runtime_error@std@@UAE@XZ
.text$mn:00000D00 ??1runtime_error@std@@UAE@XZ proc near  ; CODE XREF: std::runtime_error::`scalar deleting destructor'(uint)+Ap
.text$mn:00000D00                                         ; DATA XREF: .xdata$x:00002170o
.text$mn:00000D00
.text$mn:00000D00 var_10          = dword ptr -10h
.text$mn:00000D00 var_C           = dword ptr -0Ch
.text$mn:00000D00 var_4           = dword ptr -4
.text$mn:00000D00
.text$mn:00000D00                 push    ebp
.text$mn:00000D01                 mov     ebp, esp
.text$mn:00000D03                 push    0FFFFFFFFh
.text$mn:00000D05                 push    offset __ehhandler$??1runtime_error@std@@UAE@XZ
.text$mn:00000D0A                 mov     eax, large fs:0
.text$mn:00000D10                 push    eax
.text$mn:00000D11                 push    ecx
.text$mn:00000D12                 mov     eax, dword ptr ds:___security_cookie
.text$mn:00000D17                 xor     eax, ebp
.text$mn:00000D19                 push    eax
.text$mn:00000D1A                 lea     eax, [ebp+var_C]
.text$mn:00000D1D                 mov     large fs:0, eax
.text$mn:00000D23                 mov     [ebp+var_10], ecx
.text$mn:00000D26                 mov     [ebp+var_4], 0
.text$mn:00000D2D                 mov     [ebp+var_4], 0FFFFFFFFh
.text$mn:00000D34                 mov     ecx, [ebp+var_10] ; this
.text$mn:00000D37                 call    ??1exception@std@@UAE@XZ ; std::exception::~exception(void)
.text$mn:00000D3C                 mov     ecx, [ebp+var_C]
.text$mn:00000D3F                 mov     large fs:0, ecx
.text$mn:00000D46                 pop     ecx
.text$mn:00000D47                 mov     esp, ebp
.text$mn:00000D49                 pop     ebp
.text$mn:00000D4A                 retn
.text$mn:00000D4A ??1runtime_error@std@@UAE@XZ endp
.text$mn:00000D4A
.text$mn:00000D4A ; ---------------------------------------------------------------------------
.text$mn:00000D4B                 align 4
.text$mn:00000D4B _text$mn        ends
.text$mn:00000D4B
.text$x:00000D4C ; ===========================================================================
.text$x:00000D4C
.text$x:00000D4C ; Segment type: Pure code
.text$x:00000D4C ; Segment permissions: Read/Execute
.text$x:00000D4C _text$x         segment para public 'CODE' use32
.text$x:00000D4C                 assume cs:_text$x
.text$x:00000D4C                 ;org 0D4Ch
.text$x:00000D4C ; COMDAT (pick associative to section at D00)
.text$x:00000D4C                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text$x:00000D4C
.text$x:00000D4C ; =============== S U B R O U T I N E =======================================
.text$x:00000D4C
.text$x:00000D4C
.text$x:00000D4C __unwindfunclet$??1runtime_error@std@@UAE@XZ$0 proc near
.text$x:00000D4C                                         ; DATA XREF: .xdata$x:00001F24o
.text$x:00000D4C                 mov     ecx, [ebp-10h]  ; this
.text$x:00000D4F                 jmp     ??1exception@std@@UAE@XZ ; std::exception::~exception(void)
.text$x:00000D4F __unwindfunclet$??1runtime_error@std@@UAE@XZ$0 endp
.text$x:00000D4F
.text$x:00000D54
.text$x:00000D54 ; =============== S U B R O U T I N E =======================================
.text$x:00000D54
.text$x:00000D54
.text$x:00000D54 __ehhandler$??1runtime_error@std@@UAE@XZ proc near
.text$x:00000D54                                         ; DATA XREF: std::runtime_error::~runtime_error(void)+5o
.text$x:00000D54
.text$x:00000D54 arg_4           = dword ptr  8
.text$x:00000D54
.text$x:00000D54                 mov     edx, [esp+arg_4]
.text$x:00000D58                 lea     eax, [edx+0Ch]
.text$x:00000D5B                 mov     ecx, [edx-8]
.text$x:00000D5E                 xor     ecx, eax
.text$x:00000D60                 call    @__security_check_cookie@4 ; __security_check_cookie(x)
.text$x:00000D65                 mov     eax, offset __ehfuncinfo$??1runtime_error@std@@UAE@XZ
.text$x:00000D6A                 jmp     ___CxxFrameHandler3
.text$x:00000D6A __ehhandler$??1runtime_error@std@@UAE@XZ endp
.text$x:00000D6A
.text$x:00000D6A ; ---------------------------------------------------------------------------
.text$x:00000D6F                 align 10h
.text$x:00000D6F _text$x         ends
.text$x:00000D6F
.text$mn:00000D70 ; ===========================================================================
.text$mn:00000D70
.text$mn:00000D70 ; Segment type: Pure code
.text$mn:00000D70 ; Segment permissions: Read/Execute
.text$mn:00000D70 _text$mn        segment para public 'CODE' use32
.text$mn:00000D70                 assume cs:_text$mn
.text$mn:00000D70                 ;org 0D70h
.text$mn:00000D70 ; COMDAT (pick any)
.text$mn:00000D70                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text$mn:00000D70
.text$mn:00000D70 ; =============== S U B R O U T I N E =======================================
.text$mn:00000D70
.text$mn:00000D70 ; Attributes: bp-based frame
.text$mn:00000D70
.text$mn:00000D70 ; void *__cdecl operator new(unsigned int, void *)
.text$mn:00000D70                 public ??2@YAPAXIPAX@Z
.text$mn:00000D70 ??2@YAPAXIPAX@Z proc near               ; CODE XREF: std::allocator<char>::construct<char *,char * &>(char * *,char * &)+2Ep
.text$mn:00000D70                                         ; std::allocator<std::_Container_proxy>::construct<std::_Container_proxy,std::_Container_proxy>(std::_Container_proxy *,std::_Container_proxy &&)+2Ep
.text$mn:00000D70
.text$mn:00000D70 arg_4           = dword ptr  0Ch
.text$mn:00000D70
.text$mn:00000D70                 push    ebp
.text$mn:00000D71                 mov     ebp, esp
.text$mn:00000D73                 mov     eax, [ebp+arg_4]
.text$mn:00000D76                 pop     ebp
.text$mn:00000D77                 retn
.text$mn:00000D77 ??2@YAPAXIPAX@Z endp
.text$mn:00000D77
.text$mn:00000D77 _text$mn        ends
.text$mn:00000D77
.text$mn:00000D78 ; ===========================================================================
.text$mn:00000D78
.text$mn:00000D78 ; Segment type: Pure code
.text$mn:00000D78 ; Segment permissions: Read/Execute
.text$mn:00000D78 _text$mn        segment para public 'CODE' use32
.text$mn:00000D78                 assume cs:_text$mn
.text$mn:00000D78                 ;org 0D78h
.text$mn:00000D78 ; COMDAT (pick any)
.text$mn:00000D78                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text$mn:00000D78
.text$mn:00000D78 ; =============== S U B R O U T I N E =======================================
.text$mn:00000D78
.text$mn:00000D78 ; Attributes: bp-based frame
.text$mn:00000D78
.text$mn:00000D78 ; void __cdecl operator delete(void *)
.text$mn:00000D78                 public ??3@YAXPAX0@Z
.text$mn:00000D78 ??3@YAXPAX0@Z   proc near               ; CODE XREF: __unwindfunclet$??$construct@PADAAPAD@?$allocator@D@std@@QAEXPAPADAAPAD@Z$0+8p
.text$mn:00000D78                                         ; __unwindfunclet$??$construct@U_Container_proxy@std@@U12@@?$allocator@U_Container_proxy@std@@@std@@QAEXPAU_Container_proxy@1@$$QAU21@@Z$0+8p
.text$mn:00000D78                 push    ebp
.text$mn:00000D79                 mov     ebp, esp
.text$mn:00000D7B                 pop     ebp
.text$mn:00000D7C                 retn
.text$mn:00000D7C ??3@YAXPAX0@Z   endp
.text$mn:00000D7C
.text$mn:00000D7C ; ---------------------------------------------------------------------------
.text$mn:00000D7D                 align 10h
.text$mn:00000D7D _text$mn        ends
.text$mn:00000D7D
.text$mn:00000D80 ; ===========================================================================
.text$mn:00000D80
.text$mn:00000D80 ; Segment type: Pure code
.text$mn:00000D80 ; Segment permissions: Read/Execute
.text$mn:00000D80 _text$mn        segment para public 'CODE' use32
.text$mn:00000D80                 assume cs:_text$mn
.text$mn:00000D80                 ;org 0D80h
.text$mn:00000D80 ; COMDAT (pick any)
.text$mn:00000D80                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text$mn:00000D80
.text$mn:00000D80 ; =============== S U B R O U T I N E =======================================
.text$mn:00000D80
.text$mn:00000D80 ; Attributes: bp-based frame
.text$mn:00000D80
.text$mn:00000D80 ; public: bool __thiscall std::error_category::operator==(class std::error_category const &)const
.text$mn:00000D80                 public ??8error_category@std@@QBE_NABV01@@Z
.text$mn:00000D80 ??8error_category@std@@QBE_NABV01@@Z proc near
.text$mn:00000D80                                         ; CODE XREF: std::error_condition::operator==(std::error_condition const &)+1Dp
.text$mn:00000D80                                         ; std::error_category::equivalent(std::error_code const &,int)+15p
.text$mn:00000D80
.text$mn:00000D80 var_8           = dword ptr -8
.text$mn:00000D80 var_4           = dword ptr -4
.text$mn:00000D80 arg_0           = dword ptr  8
.text$mn:00000D80
.text$mn:00000D80                 push    ebp
.text$mn:00000D81                 mov     ebp, esp
.text$mn:00000D83                 sub     esp, 8
.text$mn:00000D86                 mov     [ebp+var_8], ecx
.text$mn:00000D89                 mov     eax, [ebp+var_8]
.text$mn:00000D8C                 cmp     eax, [ebp+arg_0]
.text$mn:00000D8F                 jnz     short loc_D9A
.text$mn:00000D91                 mov     [ebp+var_4], 1
.text$mn:00000D98                 jmp     short loc_DA1
.text$mn:00000D9A ; ---------------------------------------------------------------------------
.text$mn:00000D9A
.text$mn:00000D9A loc_D9A:                                ; CODE XREF: std::error_category::operator==(std::error_category const &)+Fj
.text$mn:00000D9A                 mov     [ebp+var_4], 0
.text$mn:00000DA1
.text$mn:00000DA1 loc_DA1:                                ; CODE XREF: std::error_category::operator==(std::error_category const &)+18j
.text$mn:00000DA1                 mov     al, byte ptr [ebp+var_4]
.text$mn:00000DA4                 mov     esp, ebp
.text$mn:00000DA6                 pop     ebp
.text$mn:00000DA7                 retn    4
.text$mn:00000DA7 ??8error_category@std@@QBE_NABV01@@Z endp
.text$mn:00000DA7
.text$mn:00000DA7 ; ---------------------------------------------------------------------------
.text$mn:00000DAA                 align 4
.text$mn:00000DAA _text$mn        ends
.text$mn:00000DAA
.text$mn:00000DAC ; ===========================================================================
.text$mn:00000DAC
.text$mn:00000DAC ; Segment type: Pure code
.text$mn:00000DAC ; Segment permissions: Read/Execute
.text$mn:00000DAC _text$mn        segment para public 'CODE' use32
.text$mn:00000DAC                 assume cs:_text$mn
.text$mn:00000DAC                 ;org 0DACh
.text$mn:00000DAC ; COMDAT (pick any)
.text$mn:00000DAC                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text$mn:00000DAC
.text$mn:00000DAC ; =============== S U B R O U T I N E =======================================
.text$mn:00000DAC
.text$mn:00000DAC ; Attributes: bp-based frame
.text$mn:00000DAC
.text$mn:00000DAC ; int __stdcall std::error_condition::operator==(std::error_condition *)
.text$mn:00000DAC                 public ??8error_condition@std@@QBE_NABV01@@Z
.text$mn:00000DAC ??8error_condition@std@@QBE_NABV01@@Z proc near
.text$mn:00000DAC                                         ; CODE XREF: std::error_category::equivalent(int,std::error_condition const &)+24p
.text$mn:00000DAC
.text$mn:00000DAC var_8           = dword ptr -8
.text$mn:00000DAC var_4           = dword ptr -4
.text$mn:00000DAC arg_0           = dword ptr  8
.text$mn:00000DAC
.text$mn:00000DAC                 push    ebp
.text$mn:00000DAD                 mov     ebp, esp
.text$mn:00000DAF                 sub     esp, 8
.text$mn:00000DB2                 push    esi
.text$mn:00000DB3                 mov     [ebp+var_4], ecx
.text$mn:00000DB6                 mov     ecx, [ebp+arg_0] ; this
.text$mn:00000DB9                 call    ?category@error_condition@std@@QBEABVerror_category@2@XZ ; std::error_condition::category(void)
.text$mn:00000DBE                 push    eax
.text$mn:00000DBF                 mov     ecx, [ebp+var_4] ; this
.text$mn:00000DC2                 call    ?category@error_condition@std@@QBEABVerror_category@2@XZ ; std::error_condition::category(void)
.text$mn:00000DC7                 mov     ecx, eax
.text$mn:00000DC9                 call    ??8error_category@std@@QBE_NABV01@@Z ; std::error_category::operator==(std::error_category const &)
.text$mn:00000DCE                 movzx   eax, al
.text$mn:00000DD1                 test    eax, eax
.text$mn:00000DD3                 jz      short loc_DF4
.text$mn:00000DD5                 mov     ecx, [ebp+var_4] ; this
.text$mn:00000DD8                 call    ?value@error_condition@std@@QBEHXZ ; std::error_condition::value(void)
.text$mn:00000DDD                 mov     esi, eax
.text$mn:00000DDF                 mov     ecx, [ebp+arg_0] ; this
.text$mn:00000DE2                 call    ?value@error_condition@std@@QBEHXZ ; std::error_condition::value(void)
.text$mn:00000DE7                 cmp     esi, eax
.text$mn:00000DE9                 jnz     short loc_DF4
.text$mn:00000DEB                 mov     [ebp+var_8], 1
.text$mn:00000DF2                 jmp     short loc_DFB
.text$mn:00000DF4 ; ---------------------------------------------------------------------------
.text$mn:00000DF4
.text$mn:00000DF4 loc_DF4:                                ; CODE XREF: std::error_condition::operator==(std::error_condition const &)+27j
.text$mn:00000DF4                                         ; std::error_condition::operator==(std::error_condition const &)+3Dj
.text$mn:00000DF4                 mov     [ebp+var_8], 0
.text$mn:00000DFB
.text$mn:00000DFB loc_DFB:                                ; CODE XREF: std::error_condition::operator==(std::error_condition const &)+46j
.text$mn:00000DFB                 mov     al, byte ptr [ebp+var_8]
.text$mn:00000DFE                 pop     esi
.text$mn:00000DFF                 mov     esp, ebp
.text$mn:00000E01                 pop     ebp
.text$mn:00000E02                 retn    4
.text$mn:00000E02 ??8error_condition@std@@QBE_NABV01@@Z endp
.text$mn:00000E02
.text$mn:00000E02 ; ---------------------------------------------------------------------------
.text$mn:00000E05                 align 4
.text$mn:00000E05 _text$mn        ends
.text$mn:00000E05
.text$mn:00000E08 ; ===========================================================================
.text$mn:00000E08
.text$mn:00000E08 ; Segment type: Pure code
.text$mn:00000E08 ; Segment permissions: Read/Execute
.text$mn:00000E08 _text$mn        segment para public 'CODE' use32
.text$mn:00000E08                 assume cs:_text$mn
.text$mn:00000E08                 ;org 0E08h
.text$mn:00000E08 ; COMDAT (pick any)
.text$mn:00000E08                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text$mn:00000E08
.text$mn:00000E08 ; =============== S U B R O U T I N E =======================================
.text$mn:00000E08
.text$mn:00000E08 ; Attributes: bp-based frame
.text$mn:00000E08
.text$mn:00000E08 ; public: virtual void * __thiscall std::_Generic_error_category::`scalar deleting destructor'(unsigned int)
.text$mn:00000E08                 public ??_G_Generic_error_category@std@@UAEPAXI@Z
.text$mn:00000E08 ??_G_Generic_error_category@std@@UAEPAXI@Z proc near
.text$mn:00000E08
.text$mn:00000E08 var_4           = dword ptr -4
.text$mn:00000E08 arg_0           = dword ptr  8
.text$mn:00000E08
.text$mn:00000E08                 push    ebp
.text$mn:00000E09                 mov     ebp, esp
.text$mn:00000E0B                 push    ecx
.text$mn:00000E0C                 mov     [ebp+var_4], ecx
.text$mn:00000E0F                 mov     ecx, [ebp+var_4] ; this
.text$mn:00000E12                 call    ??1_Generic_error_category@std@@UAE@XZ ; std::_Generic_error_category::~_Generic_error_category(void)
.text$mn:00000E17                 mov     eax, [ebp+arg_0]
.text$mn:00000E1A                 and     eax, 1
.text$mn:00000E1D                 jz      short loc_E2B
.text$mn:00000E1F                 mov     ecx, [ebp+var_4]
.text$mn:00000E22                 push    ecx             ; void *
.text$mn:00000E23                 call    ??3@YAXPAX@Z    ; operator delete(void *)
.text$mn:00000E28                 add     esp, 4
.text$mn:00000E2B
.text$mn:00000E2B loc_E2B:                                ; CODE XREF: std::_Generic_error_category::`scalar deleting destructor'(uint)+15j
.text$mn:00000E2B                 mov     eax, [ebp+var_4]
.text$mn:00000E2E                 mov     esp, ebp
.text$mn:00000E30                 pop     ebp
.text$mn:00000E31                 retn    4
.text$mn:00000E31 ??_G_Generic_error_category@std@@UAEPAXI@Z endp
.text$mn:00000E31
.text$mn:00000E31 _text$mn        ends
.text$mn:00000E31
.text$mn:00000E34 ; ===========================================================================
.text$mn:00000E34
.text$mn:00000E34 ; Segment type: Pure code
.text$mn:00000E34 ; Segment permissions: Read/Execute
.text$mn:00000E34 _text$mn        segment para public 'CODE' use32
.text$mn:00000E34                 assume cs:_text$mn
.text$mn:00000E34                 ;org 0E34h
.text$mn:00000E34 ; COMDAT (pick any)
.text$mn:00000E34                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text$mn:00000E34
.text$mn:00000E34 ; =============== S U B R O U T I N E =======================================
.text$mn:00000E34
.text$mn:00000E34 ; Attributes: bp-based frame
.text$mn:00000E34
.text$mn:00000E34 ; public: virtual void * __thiscall std::_Iostream_error_category::`scalar deleting destructor'(unsigned int)
.text$mn:00000E34                 public ??_G_Iostream_error_category@std@@UAEPAXI@Z
.text$mn:00000E34 ??_G_Iostream_error_category@std@@UAEPAXI@Z proc near
.text$mn:00000E34
.text$mn:00000E34 var_4           = dword ptr -4
.text$mn:00000E34 arg_0           = dword ptr  8
.text$mn:00000E34
.text$mn:00000E34                 push    ebp
.text$mn:00000E35                 mov     ebp, esp
.text$mn:00000E37                 push    ecx
.text$mn:00000E38                 mov     [ebp+var_4], ecx
.text$mn:00000E3B                 mov     ecx, [ebp+var_4] ; this
.text$mn:00000E3E                 call    ??1_Iostream_error_category@std@@UAE@XZ ; std::_Iostream_error_category::~_Iostream_error_category(void)
.text$mn:00000E43                 mov     eax, [ebp+arg_0]
.text$mn:00000E46                 and     eax, 1
.text$mn:00000E49                 jz      short loc_E57
.text$mn:00000E4B                 mov     ecx, [ebp+var_4]
.text$mn:00000E4E                 push    ecx             ; void *
.text$mn:00000E4F                 call    ??3@YAXPAX@Z    ; operator delete(void *)
.text$mn:00000E54                 add     esp, 4
.text$mn:00000E57
.text$mn:00000E57 loc_E57:                                ; CODE XREF: std::_Iostream_error_category::`scalar deleting destructor'(uint)+15j
.text$mn:00000E57                 mov     eax, [ebp+var_4]
.text$mn:00000E5A                 mov     esp, ebp
.text$mn:00000E5C                 pop     ebp
.text$mn:00000E5D                 retn    4
.text$mn:00000E5D ??_G_Iostream_error_category@std@@UAEPAXI@Z endp
.text$mn:00000E5D
.text$mn:00000E5D _text$mn        ends
.text$mn:00000E5D
.text$mn:00000E60 ; ===========================================================================
.text$mn:00000E60
.text$mn:00000E60 ; Segment type: Pure code
.text$mn:00000E60 ; Segment permissions: Read/Execute
.text$mn:00000E60 _text$mn        segment para public 'CODE' use32
.text$mn:00000E60                 assume cs:_text$mn
.text$mn:00000E60                 ;org 0E60h
.text$mn:00000E60 ; COMDAT (pick any)
.text$mn:00000E60                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text$mn:00000E60
.text$mn:00000E60 ; =============== S U B R O U T I N E =======================================
.text$mn:00000E60
.text$mn:00000E60 ; Attributes: bp-based frame
.text$mn:00000E60
.text$mn:00000E60 ; public: virtual void * __thiscall std::_System_error_category::`scalar deleting destructor'(unsigned int)
.text$mn:00000E60                 public ??_G_System_error_category@std@@UAEPAXI@Z
.text$mn:00000E60 ??_G_System_error_category@std@@UAEPAXI@Z proc near
.text$mn:00000E60
.text$mn:00000E60 var_4           = dword ptr -4
.text$mn:00000E60 arg_0           = dword ptr  8
.text$mn:00000E60
.text$mn:00000E60                 push    ebp
.text$mn:00000E61                 mov     ebp, esp
.text$mn:00000E63                 push    ecx
.text$mn:00000E64                 mov     [ebp+var_4], ecx
.text$mn:00000E67                 mov     ecx, [ebp+var_4] ; this
.text$mn:00000E6A                 call    ??1_System_error_category@std@@UAE@XZ ; std::_System_error_category::~_System_error_category(void)
.text$mn:00000E6F                 mov     eax, [ebp+arg_0]
.text$mn:00000E72                 and     eax, 1
.text$mn:00000E75                 jz      short loc_E83
.text$mn:00000E77                 mov     ecx, [ebp+var_4]
.text$mn:00000E7A                 push    ecx             ; void *
.text$mn:00000E7B                 call    ??3@YAXPAX@Z    ; operator delete(void *)
.text$mn:00000E80                 add     esp, 4
.text$mn:00000E83
.text$mn:00000E83 loc_E83:                                ; CODE XREF: std::_System_error_category::`scalar deleting destructor'(uint)+15j
.text$mn:00000E83                 mov     eax, [ebp+var_4]
.text$mn:00000E86                 mov     esp, ebp
.text$mn:00000E88                 pop     ebp
.text$mn:00000E89                 retn    4
.text$mn:00000E89 ??_G_System_error_category@std@@UAEPAXI@Z endp
.text$mn:00000E89
.text$mn:00000E89 _text$mn        ends
.text$mn:00000E89
.text$mn:00000E8C ; ===========================================================================
.text$mn:00000E8C
.text$mn:00000E8C ; Segment type: Pure code
.text$mn:00000E8C ; Segment permissions: Read/Execute
.text$mn:00000E8C _text$mn        segment para public 'CODE' use32
.text$mn:00000E8C                 assume cs:_text$mn
.text$mn:00000E8C                 ;org 0E8Ch
.text$mn:00000E8C ; COMDAT (pick any)
.text$mn:00000E8C                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text$mn:00000E8C
.text$mn:00000E8C ; =============== S U B R O U T I N E =======================================
.text$mn:00000E8C
.text$mn:00000E8C ; Attributes: bp-based frame
.text$mn:00000E8C
.text$mn:00000E8C ; public: virtual void * __thiscall std::error_category::`scalar deleting destructor'(unsigned int)
.text$mn:00000E8C                 public ??_Gerror_category@std@@UAEPAXI@Z
.text$mn:00000E8C ??_Gerror_category@std@@UAEPAXI@Z proc near
.text$mn:00000E8C
.text$mn:00000E8C var_4           = dword ptr -4
.text$mn:00000E8C arg_0           = dword ptr  8
.text$mn:00000E8C
.text$mn:00000E8C                 push    ebp
.text$mn:00000E8D                 mov     ebp, esp
.text$mn:00000E8F                 push    ecx
.text$mn:00000E90                 mov     [ebp+var_4], ecx
.text$mn:00000E93                 mov     ecx, [ebp+var_4] ; this
.text$mn:00000E96                 call    ??1error_category@std@@UAE@XZ ; std::error_category::~error_category(void)
.text$mn:00000E9B                 mov     eax, [ebp+arg_0]
.text$mn:00000E9E                 and     eax, 1
.text$mn:00000EA1                 jz      short loc_EAF
.text$mn:00000EA3                 mov     ecx, [ebp+var_4]
.text$mn:00000EA6                 push    ecx             ; void *
.text$mn:00000EA7                 call    ??3@YAXPAX@Z    ; operator delete(void *)
.text$mn:00000EAC                 add     esp, 4
.text$mn:00000EAF
.text$mn:00000EAF loc_EAF:                                ; CODE XREF: std::error_category::`scalar deleting destructor'(uint)+15j
.text$mn:00000EAF                 mov     eax, [ebp+var_4]
.text$mn:00000EB2                 mov     esp, ebp
.text$mn:00000EB4                 pop     ebp
.text$mn:00000EB5                 retn    4
.text$mn:00000EB5 ??_Gerror_category@std@@UAEPAXI@Z endp
.text$mn:00000EB5
.text$mn:00000EB5 _text$mn        ends
.text$mn:00000EB5
.text$mn:00000EB8 ; ===========================================================================
.text$mn:00000EB8
.text$mn:00000EB8 ; Segment type: Pure code
.text$mn:00000EB8 ; Segment permissions: Read/Execute
.text$mn:00000EB8 _text$mn        segment para public 'CODE' use32
.text$mn:00000EB8                 assume cs:_text$mn
.text$mn:00000EB8                 ;org 0EB8h
.text$mn:00000EB8 ; COMDAT (pick any)
.text$mn:00000EB8                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text$mn:00000EB8
.text$mn:00000EB8 ; =============== S U B R O U T I N E =======================================
.text$mn:00000EB8
.text$mn:00000EB8 ; Attributes: bp-based frame
.text$mn:00000EB8
.text$mn:00000EB8 ; public: virtual void * __thiscall std::runtime_error::`scalar deleting destructor'(unsigned int)
.text$mn:00000EB8                 public ??_Gruntime_error@std@@UAEPAXI@Z
.text$mn:00000EB8 ??_Gruntime_error@std@@UAEPAXI@Z proc near
.text$mn:00000EB8
.text$mn:00000EB8 var_4           = dword ptr -4
.text$mn:00000EB8 arg_0           = dword ptr  8
.text$mn:00000EB8
.text$mn:00000EB8                 push    ebp
.text$mn:00000EB9                 mov     ebp, esp
.text$mn:00000EBB                 push    ecx
.text$mn:00000EBC                 mov     [ebp+var_4], ecx
.text$mn:00000EBF                 mov     ecx, [ebp+var_4] ; this
.text$mn:00000EC2                 call    ??1runtime_error@std@@UAE@XZ ; std::runtime_error::~runtime_error(void)
.text$mn:00000EC7                 mov     eax, [ebp+arg_0]
.text$mn:00000ECA                 and     eax, 1
.text$mn:00000ECD                 jz      short loc_EDB
.text$mn:00000ECF                 mov     ecx, [ebp+var_4]
.text$mn:00000ED2                 push    ecx             ; void *
.text$mn:00000ED3                 call    ??3@YAXPAX@Z    ; operator delete(void *)
.text$mn:00000ED8                 add     esp, 4
.text$mn:00000EDB
.text$mn:00000EDB loc_EDB:                                ; CODE XREF: std::runtime_error::`scalar deleting destructor'(uint)+15j
.text$mn:00000EDB                 mov     eax, [ebp+var_4]
.text$mn:00000EDE                 mov     esp, ebp
.text$mn:00000EE0                 pop     ebp
.text$mn:00000EE1                 retn    4
.text$mn:00000EE1 ??_Gruntime_error@std@@UAEPAXI@Z endp
.text$mn:00000EE1
.text$mn:00000EE1 _text$mn        ends
.text$mn:00000EE1
.text$di:00000EE4 ; ===========================================================================
.text$di:00000EE4
.text$di:00000EE4 ; Segment type: Pure code
.text$di:00000EE4 ; Segment permissions: Read/Execute
.text$di:00000EE4 _text$di        segment para public 'CODE' use32
.text$di:00000EE4                 assume cs:_text$di
.text$di:00000EE4                 ;org 0EE4h
.text$di:00000EE4 ; COMDAT (pick any)
.text$di:00000EE4                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text$di:00000EE4
.text$di:00000EE4 ; =============== S U B R O U T I N E =======================================
.text$di:00000EE4
.text$di:00000EE4 ; Attributes: bp-based frame
.text$di:00000EE4
.text$di:00000EE4 ; void __cdecl `dynamic initializer for 'public: static class std::_Generic_error_category std::_Error_objects<int>::_Generic_object''(void)
.text$di:00000EE4 ??__E?_Generic_object@?$_Error_objects@H@std@@2V_Generic_error_category@2@A@@YAXXZ proc near
.text$di:00000EE4                                         ; DATA XREF: .CRT$XCU:void (*std::_Error_objects<int>::_Generic_object$initializer$)(void)o
.text$di:00000EE4                 push    ebp
.text$di:00000EE5                 mov     ebp, esp
.text$di:00000EE7                 mov     ecx, offset ?_Generic_object@?$_Error_objects@H@std@@2V_Generic_error_category@2@A ; this
.text$di:00000EEC                 call    ??0_Generic_error_category@std@@QAE@XZ ; std::_Generic_error_category::_Generic_error_category(void)
.text$di:00000EF1                 push    offset ??__F?_Generic_object@?$_Error_objects@H@std@@2V_Generic_error_category@2@A@@YAXXZ ; void (__cdecl *)()
.text$di:00000EF6                 call    _atexit
.text$di:00000EFB                 add     esp, 4
.text$di:00000EFE                 pop     ebp
.text$di:00000EFF                 retn
.text$di:00000EFF ??__E?_Generic_object@?$_Error_objects@H@std@@2V_Generic_error_category@2@A@@YAXXZ endp
.text$di:00000EFF
.text$di:00000EFF _text$di        ends
.text$di:00000EFF
.text$di:00000F00 ; ===========================================================================
.text$di:00000F00
.text$di:00000F00 ; Segment type: Pure code
.text$di:00000F00 ; Segment permissions: Read/Execute
.text$di:00000F00 _text$di        segment para public 'CODE' use32
.text$di:00000F00                 assume cs:_text$di
.text$di:00000F00                 ;org 0F00h
.text$di:00000F00 ; COMDAT (pick any)
.text$di:00000F00                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text$di:00000F00
.text$di:00000F00 ; =============== S U B R O U T I N E =======================================
.text$di:00000F00
.text$di:00000F00 ; Attributes: bp-based frame
.text$di:00000F00
.text$di:00000F00 ; void __cdecl `dynamic initializer for 'public: static class std::_Iostream_error_category std::_Error_objects<int>::_Iostream_object''(void)
.text$di:00000F00 ??__E?_Iostream_object@?$_Error_objects@H@std@@2V_Iostream_error_category@2@A@@YAXXZ proc near
.text$di:00000F00                                         ; DATA XREF: .CRT$XCU:void (*std::_Error_objects<int>::_Iostream_object$initializer$)(void)o
.text$di:00000F00                 push    ebp
.text$di:00000F01                 mov     ebp, esp
.text$di:00000F03                 mov     ecx, offset ?_Iostream_object@?$_Error_objects@H@std@@2V_Iostream_error_category@2@A ; this
.text$di:00000F08                 call    ??0_Iostream_error_category@std@@QAE@XZ ; std::_Iostream_error_category::_Iostream_error_category(void)
.text$di:00000F0D                 push    offset ??__F?_Iostream_object@?$_Error_objects@H@std@@2V_Iostream_error_category@2@A@@YAXXZ ; void (__cdecl *)()
.text$di:00000F12                 call    _atexit
.text$di:00000F17                 add     esp, 4
.text$di:00000F1A                 pop     ebp
.text$di:00000F1B                 retn
.text$di:00000F1B ??__E?_Iostream_object@?$_Error_objects@H@std@@2V_Iostream_error_category@2@A@@YAXXZ endp
.text$di:00000F1B
.text$di:00000F1B _text$di        ends
.text$di:00000F1B
.text$di:00000F1C ; ===========================================================================
.text$di:00000F1C
.text$di:00000F1C ; Segment type: Pure code
.text$di:00000F1C ; Segment permissions: Read/Execute
.text$di:00000F1C _text$di        segment para public 'CODE' use32
.text$di:00000F1C                 assume cs:_text$di
.text$di:00000F1C                 ;org 0F1Ch
.text$di:00000F1C ; COMDAT (pick any)
.text$di:00000F1C                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text$di:00000F1C
.text$di:00000F1C ; =============== S U B R O U T I N E =======================================
.text$di:00000F1C
.text$di:00000F1C ; Attributes: bp-based frame
.text$di:00000F1C
.text$di:00000F1C ; void __cdecl `dynamic initializer for 'public: static class std::_System_error_category std::_Error_objects<int>::_System_object''(void)
.text$di:00000F1C ??__E?_System_object@?$_Error_objects@H@std@@2V_System_error_category@2@A@@YAXXZ proc near
.text$di:00000F1C                                         ; DATA XREF: .CRT$XCU:void (*std::_Error_objects<int>::_System_object$initializer$)(void)o
.text$di:00000F1C                 push    ebp
.text$di:00000F1D                 mov     ebp, esp
.text$di:00000F1F                 mov     ecx, offset ?_System_object@?$_Error_objects@H@std@@2V_System_error_category@2@A ; this
.text$di:00000F24                 call    ??0_System_error_category@std@@QAE@XZ ; std::_System_error_category::_System_error_category(void)
.text$di:00000F29                 push    offset ??__F?_System_object@?$_Error_objects@H@std@@2V_System_error_category@2@A@@YAXXZ ; void (__cdecl *)()
.text$di:00000F2E                 call    _atexit
.text$di:00000F33                 add     esp, 4
.text$di:00000F36                 pop     ebp
.text$di:00000F37                 retn
.text$di:00000F37 ??__E?_System_object@?$_Error_objects@H@std@@2V_System_error_category@2@A@@YAXXZ endp
.text$di:00000F37
.text$di:00000F37 _text$di        ends
.text$di:00000F37
.text$di:00000F38 ; ===========================================================================
.text$di:00000F38
.text$di:00000F38 ; Segment type: Pure code
.text$di:00000F38 ; Segment permissions: Read/Execute
.text$di:00000F38 _text$di        segment para public 'CODE' use32
.text$di:00000F38                 assume cs:_text$di
.text$di:00000F38                 ;org 0F38h
.text$di:00000F38 ; COMDAT (pick any)
.text$di:00000F38                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text$di:00000F38
.text$di:00000F38 ; =============== S U B R O U T I N E =======================================
.text$di:00000F38
.text$di:00000F38 ; Attributes: bp-based frame
.text$di:00000F38
.text$di:00000F38 ; void __cdecl std::`dynamic initializer for 'allocator_arg''(void)
.text$di:00000F38 ??__Eallocator_arg@std@@YAXXZ proc near ; DATA XREF: .CRT$XCU:_allocator_arg$initializer$o
.text$di:00000F38
.text$di:00000F38 var_1           = byte ptr -1
.text$di:00000F38
.text$di:00000F38                 push    ebp
.text$di:00000F39                 mov     ebp, esp
.text$di:00000F3B                 push    ecx
.text$di:00000F3C                 xor     eax, eax
.text$di:00000F3E                 mov     [ebp+var_1], al
.text$di:00000F41                 mov     esp, ebp
.text$di:00000F43                 pop     ebp
.text$di:00000F44                 retn
.text$di:00000F44 ??__Eallocator_arg@std@@YAXXZ endp
.text$di:00000F44
.text$di:00000F44 ; ---------------------------------------------------------------------------
.text$di:00000F45                 align 4
.text$di:00000F45 _text$di        ends
.text$di:00000F45
.text$di:00000F48 ; ===========================================================================
.text$di:00000F48
.text$di:00000F48 ; Segment type: Pure code
.text$di:00000F48 ; Segment permissions: Read/Execute
.text$di:00000F48 _text$di        segment para public 'CODE' use32
.text$di:00000F48                 assume cs:_text$di
.text$di:00000F48                 ;org 0F48h
.text$di:00000F48 ; COMDAT (pick any)
.text$di:00000F48                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text$di:00000F48
.text$di:00000F48 ; =============== S U B R O U T I N E =======================================
.text$di:00000F48
.text$di:00000F48 ; Attributes: bp-based frame
.text$di:00000F48
.text$di:00000F48 ; void __cdecl std::`dynamic initializer for 'piecewise_construct''(void)
.text$di:00000F48 ??__Epiecewise_construct@std@@YAXXZ proc near
.text$di:00000F48                                         ; DATA XREF: .CRT$XCU:_piecewise_construct$initializer$o
.text$di:00000F48
.text$di:00000F48 var_1           = byte ptr -1
.text$di:00000F48
.text$di:00000F48                 push    ebp
.text$di:00000F49                 mov     ebp, esp
.text$di:00000F4B                 push    ecx
.text$di:00000F4C                 xor     eax, eax
.text$di:00000F4E                 mov     [ebp+var_1], al
.text$di:00000F51                 mov     esp, ebp
.text$di:00000F53                 pop     ebp
.text$di:00000F54                 retn
.text$di:00000F54 ??__Epiecewise_construct@std@@YAXXZ endp
.text$di:00000F54
.text$di:00000F54 ; ---------------------------------------------------------------------------
.text$di:00000F55                 align 4
.text$di:00000F55 _text$di        ends
.text$di:00000F55
.text$yd:00000F58 ; ===========================================================================
.text$yd:00000F58
.text$yd:00000F58 ; Segment type: Pure code
.text$yd:00000F58 ; Segment permissions: Read/Execute
.text$yd:00000F58 _text$yd        segment para public 'CODE' use32
.text$yd:00000F58                 assume cs:_text$yd
.text$yd:00000F58                 ;org 0F58h
.text$yd:00000F58 ; COMDAT (pick any)
.text$yd:00000F58                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text$yd:00000F58
.text$yd:00000F58 ; =============== S U B R O U T I N E =======================================
.text$yd:00000F58
.text$yd:00000F58 ; Attributes: bp-based frame
.text$yd:00000F58
.text$yd:00000F58 ; void __cdecl `dynamic atexit destructor for 'public: static std::_Generic_error_category std::_Error_objects<int>::_Generic_object''()
.text$yd:00000F58 ??__F?_Generic_object@?$_Error_objects@H@std@@2V_Generic_error_category@2@A@@YAXXZ proc near
.text$yd:00000F58                                         ; DATA XREF: `dynamic initializer for 'std::_Generic_error_category std::_Error_objects<int>::_Generic_object''(void)+Do
.text$yd:00000F58                 push    ebp
.text$yd:00000F59                 mov     ebp, esp
.text$yd:00000F5B                 mov     ecx, offset ?_Generic_object@?$_Error_objects@H@std@@2V_Generic_error_category@2@A ; this
.text$yd:00000F60                 call    ??1_Generic_error_category@std@@UAE@XZ ; std::_Generic_error_category::~_Generic_error_category(void)
.text$yd:00000F65                 pop     ebp
.text$yd:00000F66                 retn
.text$yd:00000F66 ??__F?_Generic_object@?$_Error_objects@H@std@@2V_Generic_error_category@2@A@@YAXXZ endp
.text$yd:00000F66
.text$yd:00000F66 ; ---------------------------------------------------------------------------
.text$yd:00000F67                 align 4
.text$yd:00000F67 _text$yd        ends
.text$yd:00000F67
.text$yd:00000F68 ; ===========================================================================
.text$yd:00000F68
.text$yd:00000F68 ; Segment type: Pure code
.text$yd:00000F68 ; Segment permissions: Read/Execute
.text$yd:00000F68 _text$yd        segment para public 'CODE' use32
.text$yd:00000F68                 assume cs:_text$yd
.text$yd:00000F68                 ;org 0F68h
.text$yd:00000F68 ; COMDAT (pick any)
.text$yd:00000F68                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text$yd:00000F68
.text$yd:00000F68 ; =============== S U B R O U T I N E =======================================
.text$yd:00000F68
.text$yd:00000F68 ; Attributes: bp-based frame
.text$yd:00000F68
.text$yd:00000F68 ; void __cdecl `dynamic atexit destructor for 'public: static std::_Iostream_error_category std::_Error_objects<int>::_Iostream_object''()
.text$yd:00000F68 ??__F?_Iostream_object@?$_Error_objects@H@std@@2V_Iostream_error_category@2@A@@YAXXZ proc near
.text$yd:00000F68                                         ; DATA XREF: `dynamic initializer for 'std::_Iostream_error_category std::_Error_objects<int>::_Iostream_object''(void)+Do
.text$yd:00000F68                 push    ebp
.text$yd:00000F69                 mov     ebp, esp
.text$yd:00000F6B                 mov     ecx, offset ?_Iostream_object@?$_Error_objects@H@std@@2V_Iostream_error_category@2@A ; this
.text$yd:00000F70                 call    ??1_Iostream_error_category@std@@UAE@XZ ; std::_Iostream_error_category::~_Iostream_error_category(void)
.text$yd:00000F75                 pop     ebp
.text$yd:00000F76                 retn
.text$yd:00000F76 ??__F?_Iostream_object@?$_Error_objects@H@std@@2V_Iostream_error_category@2@A@@YAXXZ endp
.text$yd:00000F76
.text$yd:00000F76 ; ---------------------------------------------------------------------------
.text$yd:00000F77                 align 4
.text$yd:00000F77 _text$yd        ends
.text$yd:00000F77
.text$yd:00000F78 ; ===========================================================================
.text$yd:00000F78
.text$yd:00000F78 ; Segment type: Pure code
.text$yd:00000F78 ; Segment permissions: Read/Execute
.text$yd:00000F78 _text$yd        segment para public 'CODE' use32
.text$yd:00000F78                 assume cs:_text$yd
.text$yd:00000F78                 ;org 0F78h
.text$yd:00000F78 ; COMDAT (pick any)
.text$yd:00000F78                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text$yd:00000F78
.text$yd:00000F78 ; =============== S U B R O U T I N E =======================================
.text$yd:00000F78
.text$yd:00000F78 ; Attributes: bp-based frame
.text$yd:00000F78
.text$yd:00000F78 ; void __cdecl `dynamic atexit destructor for 'public: static std::_System_error_category std::_Error_objects<int>::_System_object''()
.text$yd:00000F78 ??__F?_System_object@?$_Error_objects@H@std@@2V_System_error_category@2@A@@YAXXZ proc near
.text$yd:00000F78                                         ; DATA XREF: `dynamic initializer for 'std::_System_error_category std::_Error_objects<int>::_System_object''(void)+Do
.text$yd:00000F78                 push    ebp
.text$yd:00000F79                 mov     ebp, esp
.text$yd:00000F7B                 mov     ecx, offset ?_System_object@?$_Error_objects@H@std@@2V_System_error_category@2@A ; this
.text$yd:00000F80                 call    ??1_System_error_category@std@@UAE@XZ ; std::_System_error_category::~_System_error_category(void)
.text$yd:00000F85                 pop     ebp
.text$yd:00000F86                 retn
.text$yd:00000F86 ??__F?_System_object@?$_Error_objects@H@std@@2V_System_error_category@2@A@@YAXXZ endp
.text$yd:00000F86
.text$yd:00000F86 ; ---------------------------------------------------------------------------
.text$yd:00000F87                 align 4
.text$yd:00000F87 _text$yd        ends
.text$yd:00000F87
.text$mn:00000F88 ; ===========================================================================
.text$mn:00000F88
.text$mn:00000F88 ; Segment type: Pure code
.text$mn:00000F88 ; Segment permissions: Read/Execute
.text$mn:00000F88 _text$mn        segment para public 'CODE' use32
.text$mn:00000F88                 assume cs:_text$mn
.text$mn:00000F88                 ;org 0F88h
.text$mn:00000F88 ; COMDAT (pick any)
.text$mn:00000F88                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text$mn:00000F88
.text$mn:00000F88 ; =============== S U B R O U T I N E =======================================
.text$mn:00000F88
.text$mn:00000F88 ; Attributes: bp-based frame
.text$mn:00000F88
.text$mn:00000F88 ; public: void __thiscall std::_String_alloc<0, struct std::_String_base_types<char, class std::allocator<char>>>::_Alloc_proxy(void)
.text$mn:00000F88                 public ?_Alloc_proxy@?$_String_alloc@$0A@U?$_String_base_types@DV?$allocator@D@std@@@std@@@std@@QAEXXZ
.text$mn:00000F88 ?_Alloc_proxy@?$_String_alloc@$0A@U?$_String_base_types@DV?$allocator@D@std@@@std@@@std@@QAEXXZ proc near
.text$mn:00000F88                                         ; CODE XREF: std::_String_alloc<0,std::_String_base_types<char,std::allocator<char>>>::_String_alloc<0,std::_String_base_types<char,std::allocator<char>>>(std::allocator<char> const &)+38p
.text$mn:00000F88
.text$mn:00000F88 var_10          = byte ptr -10h
.text$mn:00000F88 var_8           = dword ptr -8
.text$mn:00000F88 var_1           = byte ptr -1
.text$mn:00000F88
.text$mn:00000F88                 push    ebp
.text$mn:00000F89                 mov     ebp, esp
.text$mn:00000F8B                 sub     esp, 10h
.text$mn:00000F8E                 mov     [ebp+var_8], ecx
.text$mn:00000F91                 lea     ecx, [ebp+var_1]
.text$mn:00000F94                 call    ??0?$allocator@U_Container_proxy@std@@@std@@QAE@XZ ; std::allocator<std::_Container_proxy>::allocator<std::_Container_proxy>(void)
.text$mn:00000F99                 push    1
.text$mn:00000F9B                 lea     ecx, [ebp+var_1]
.text$mn:00000F9E                 call    ?allocate@?$allocator@U_Container_proxy@std@@@std@@QAEPAU_Container_proxy@2@I@Z ; std::allocator<std::_Container_proxy>::allocate(uint)
.text$mn:00000FA3                 mov     ecx, [ebp+var_8]
.text$mn:00000FA6                 mov     [ecx], eax
.text$mn:00000FA8                 lea     ecx, [ebp+var_10] ; this
.text$mn:00000FAB                 call    ??0_Container_proxy@std@@QAE@XZ ; std::_Container_proxy::_Container_proxy(void)
.text$mn:00000FB0                 push    eax             ; int
.text$mn:00000FB1                 mov     edx, [ebp+var_8]
.text$mn:00000FB4                 mov     eax, [edx]
.text$mn:00000FB6                 push    eax             ; void *
.text$mn:00000FB7                 lea     ecx, [ebp+var_1]
.text$mn:00000FBA                 call    ??$construct@U_Container_proxy@std@@U12@@?$allocator@U_Container_proxy@std@@@std@@QAEXPAU_Container_proxy@1@$$QAU21@@Z ; std::allocator<std::_Container_proxy>::construct<std::_Container_proxy,std::_Container_proxy>(std::_Container_proxy *,std::_Container_proxy &&)
.text$mn:00000FBF                 mov     ecx, [ebp+var_8]
.text$mn:00000FC2                 mov     edx, [ecx]
.text$mn:00000FC4                 mov     eax, [ebp+var_8]
.text$mn:00000FC7                 mov     [edx], eax
.text$mn:00000FC9                 mov     esp, ebp
.text$mn:00000FCB                 pop     ebp
.text$mn:00000FCC                 retn
.text$mn:00000FCC ?_Alloc_proxy@?$_String_alloc@$0A@U?$_String_base_types@DV?$allocator@D@std@@@std@@@std@@QAEXXZ endp
.text$mn:00000FCC
.text$mn:00000FCC ; ---------------------------------------------------------------------------
.text$mn:00000FCD                 align 10h
.text$mn:00000FCD _text$mn        ends
.text$mn:00000FCD
.text$mn:00000FD0 ; ===========================================================================
.text$mn:00000FD0
.text$mn:00000FD0 ; Segment type: Pure code
.text$mn:00000FD0 ; Segment permissions: Read/Execute
.text$mn:00000FD0 _text$mn        segment para public 'CODE' use32
.text$mn:00000FD0                 assume cs:_text$mn
.text$mn:00000FD0                 ;org 0FD0h
.text$mn:00000FD0 ; COMDAT (pick any)
.text$mn:00000FD0                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text$mn:00000FD0
.text$mn:00000FD0 ; =============== S U B R O U T I N E =======================================
.text$mn:00000FD0
.text$mn:00000FD0 ; Attributes: bp-based frame
.text$mn:00000FD0
.text$mn:00000FD0 ; public: void __thiscall std::basic_string<char, struct std::char_traits<char>, class std::allocator<char>>::_Copy(unsigned int, unsigned int)
.text$mn:00000FD0                 public ?_Copy@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEXII@Z
.text$mn:00000FD0 ?_Copy@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEXII@Z proc near
.text$mn:00000FD0                                         ; CODE XREF: std::basic_string<char,std::char_traits<char>,std::allocator<char>>::_Grow(uint,bool)+37p
.text$mn:00000FD0
.text$mn:00000FD0 var_20          = dword ptr -20h
.text$mn:00000FD0 var_1C          = dword ptr -1Ch
.text$mn:00000FD0 var_18          = dword ptr -18h
.text$mn:00000FD0 var_11          = byte ptr -11h
.text$mn:00000FD0 var_10          = dword ptr -10h
.text$mn:00000FD0 var_C           = byte ptr -0Ch
.text$mn:00000FD0 var_4           = dword ptr -4
.text$mn:00000FD0 arg_0           = dword ptr  8
.text$mn:00000FD0
.text$mn:00000FD0 ; FUNCTION CHUNK AT .text$mn:000010F2 SIZE 00000009 BYTES
.text$mn:00000FD0
.text$mn:00000FD0                 push    ebp
.text$mn:00000FD1                 mov     ebp, esp
.text$mn:00000FD3                 push    0FFFFFFFFh
.text$mn:00000FD5                 push    offset __ehhandler$?_Copy@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEXII@Z
.text$mn:00000FDA                 mov     eax, large fs:0
.text$mn:00000FE0                 push    eax
.text$mn:00000FE1                 push    ecx
.text$mn:00000FE2                 sub     esp, 10h
.text$mn:00000FE5                 push    ebx
.text$mn:00000FE6                 push    esi
.text$mn:00000FE7                 push    edi
.text$mn:00000FE8                 mov     eax, dword ptr ds:___security_cookie
.text$mn:00000FED                 xor     eax, ebp
.text$mn:00000FEF                 push    eax
.text$mn:00000FF0                 lea     eax, [ebp+var_C]
.text$mn:00000FF3                 mov     large fs:0, eax
.text$mn:00000FF9                 mov     [ebp+var_10], esp
.text$mn:00000FFC                 mov     [ebp+var_18], ecx
.text$mn:00000FFF                 mov     eax, [ebp+arg_0]
.text$mn:00001002                 or      eax, 0Fh
.text$mn:00001005                 mov     [ebp+var_1C], eax
.text$mn:00001008                 mov     ecx, [ebp+var_18]
.text$mn:0000100B                 call    ?max_size@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QBEIXZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char>>::max_size(void)
.text$mn:00001010                 cmp     eax, [ebp+var_1C]
.text$mn:00001013                 jnb     short loc_101D
.text$mn:00001015                 mov     ecx, [ebp+arg_0]
.text$mn:00001018                 mov     [ebp+var_1C], ecx
.text$mn:0000101B                 jmp     short loc_106F
.text$mn:0000101D ; ---------------------------------------------------------------------------
.text$mn:0000101D
.text$mn:0000101D loc_101D:                               ; CODE XREF: std::basic_string<char,std::char_traits<char>,std::allocator<char>>::_Copy(uint,uint)+43j
.text$mn:0000101D                 mov     edx, [ebp+var_18]
.text$mn:00001020                 mov     ecx, [edx+18h]
.text$mn:00001023                 shr     ecx, 1
.text$mn:00001025                 mov     eax, [ebp+var_1C]
.text$mn:00001028                 xor     edx, edx
.text$mn:0000102A                 mov     esi, 3
.text$mn:0000102F                 div     esi
.text$mn:00001031                 cmp     ecx, eax
.text$mn:00001033                 ja      short loc_1037
.text$mn:00001035                 jmp     short loc_106F
.text$mn:00001037 ; ---------------------------------------------------------------------------
.text$mn:00001037
.text$mn:00001037 loc_1037:                               ; CODE XREF: std::basic_string<char,std::char_traits<char>,std::allocator<char>>::_Copy(uint,uint)+63j
.text$mn:00001037                 mov     ecx, [ebp+var_18]
.text$mn:0000103A                 call    ?max_size@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QBEIXZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char>>::max_size(void)
.text$mn:0000103F                 mov     edx, [ebp+var_18]
.text$mn:00001042                 mov     ecx, [edx+18h]
.text$mn:00001045                 shr     ecx, 1
.text$mn:00001047                 sub     eax, ecx
.text$mn:00001049                 mov     edx, [ebp+var_18]
.text$mn:0000104C                 cmp     [edx+18h], eax
.text$mn:0000104F                 ja      short loc_1064
.text$mn:00001051                 mov     eax, [ebp+var_18]
.text$mn:00001054                 mov     ecx, [eax+18h]
.text$mn:00001057                 shr     ecx, 1
.text$mn:00001059                 mov     edx, [ebp+var_18]
.text$mn:0000105C                 add     ecx, [edx+18h]
.text$mn:0000105F                 mov     [ebp+var_1C], ecx
.text$mn:00001062                 jmp     short loc_106F
.text$mn:00001064 ; ---------------------------------------------------------------------------
.text$mn:00001064
.text$mn:00001064 loc_1064:                               ; CODE XREF: std::basic_string<char,std::char_traits<char>,std::allocator<char>>::_Copy(uint,uint)+7Fj
.text$mn:00001064                 mov     ecx, [ebp+var_18]
.text$mn:00001067                 call    ?max_size@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QBEIXZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char>>::max_size(void)
.text$mn:0000106C                 mov     [ebp+var_1C], eax
.text$mn:0000106F
.text$mn:0000106F loc_106F:                               ; CODE XREF: std::basic_string<char,std::char_traits<char>,std::allocator<char>>::_Copy(uint,uint)+4Bj
.text$mn:0000106F                                         ; std::basic_string<char,std::char_traits<char>,std::allocator<char>>::_Copy(uint,uint)+65j ...
.text$mn:0000106F                 mov     [ebp+var_4], 0
.text$mn:00001076                 mov     eax, [ebp+var_1C]
.text$mn:00001079                 add     eax, 1
.text$mn:0000107C                 push    eax
.text$mn:0000107D                 lea     ecx, [ebp+var_11]
.text$mn:00001080                 push    ecx
.text$mn:00001081                 mov     ecx, [ebp+var_18]
.text$mn:00001084                 call    ?_Getal@?$_String_alloc@$0A@U?$_String_base_types@DV?$allocator@D@std@@@std@@@std@@QBE?AU?$_Wrap_alloc@V?$allocator@D@std@@@2@XZ ; std::_String_alloc<0,std::_String_base_types<char,std::allocator<char>>>::_Getal(void)
.text$mn:00001089                 mov     ecx, eax
.text$mn:0000108B                 call    ?allocate@?$_Wrap_alloc@V?$allocator@D@std@@@std@@QAEPADI@Z ; std::_Wrap_alloc<std::allocator<char>>::allocate(uint)
.text$mn:00001090                 mov     [ebp+var_20], eax
.text$mn:00001093                 jmp     short loc_10F2
.text$mn:00001093 ?_Copy@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEXII@Z endp
.text$mn:00001093
.text$mn:00001095
.text$mn:00001095 ; =============== S U B R O U T I N E =======================================
.text$mn:00001095
.text$mn:00001095
.text$mn:00001095 __catch$?_Copy@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEXII@Z$0 proc near
.text$mn:00001095                                         ; DATA XREF: .xdata$x:00001E74o
.text$mn:00001095
.text$mn:00001095 ; FUNCTION CHUNK AT .text$mn:000010DC SIZE 00000009 BYTES
.text$mn:00001095 ; FUNCTION CHUNK AT .text$mn:000010EC SIZE 00000006 BYTES
.text$mn:00001095
.text$mn:00001095                 mov     [ebp-10h], esp
.text$mn:00001098                 mov     edx, [ebp+8]
.text$mn:0000109B                 mov     [ebp-1Ch], edx
.text$mn:0000109E                 mov     byte ptr [ebp-4], 2
.text$mn:000010A2                 mov     eax, [ebp-1Ch]
.text$mn:000010A5                 add     eax, 1
.text$mn:000010A8                 push    eax
.text$mn:000010A9                 lea     ecx, [ebp-12h]
.text$mn:000010AC                 push    ecx
.text$mn:000010AD                 mov     ecx, [ebp-18h]
.text$mn:000010B0                 call    ?_Getal@?$_String_alloc@$0A@U?$_String_base_types@DV?$allocator@D@std@@@std@@@std@@QBE?AU?$_Wrap_alloc@V?$allocator@D@std@@@2@XZ ; std::_String_alloc<0,std::_String_base_types<char,std::allocator<char>>>::_Getal(void)
.text$mn:000010B5                 mov     ecx, eax
.text$mn:000010B7                 call    ?allocate@?$_Wrap_alloc@V?$allocator@D@std@@@std@@QAEPADI@Z ; std::_Wrap_alloc<std::allocator<char>>::allocate(uint)
.text$mn:000010BC                 mov     [ebp-20h], eax
.text$mn:000010BF                 jmp     short loc_10DC
.text$mn:000010BF __catch$?_Copy@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEXII@Z$0 endp
.text$mn:000010BF
.text$mn:000010C1
.text$mn:000010C1 ; =============== S U B R O U T I N E =======================================
.text$mn:000010C1
.text$mn:000010C1 ; Attributes: noreturn
.text$mn:000010C1
.text$mn:000010C1 __catch$?_Copy@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEXII@Z$1 proc near
.text$mn:000010C1                                         ; DATA XREF: .xdata$x:00001E84o
.text$mn:000010C1                 push    0               ; Size
.text$mn:000010C3                 push    1               ; char
.text$mn:000010C5                 mov     ecx, [ebp-18h]
.text$mn:000010C8                 call    ?_Tidy@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEX_NI@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char>>::_Tidy(bool,uint)
.text$mn:000010CD                 push    0
.text$mn:000010CF                 push    0
.text$mn:000010D1                 call    __CxxThrowException@8 ; _CxxThrowException(x,x)
.text$mn:000010D1 __catch$?_Copy@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEXII@Z$1 endp
.text$mn:000010D1
.text$mn:000010D6 ; ---------------------------------------------------------------------------
.text$mn:000010D6                 mov     eax, offset $LN17
.text$mn:000010DB                 retn
.text$mn:000010DC ; ---------------------------------------------------------------------------
.text$mn:000010DC ; START OF FUNCTION CHUNK FOR __catch$?_Copy@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEXII@Z$0
.text$mn:000010DC
.text$mn:000010DC loc_10DC:                               ; CODE XREF: __catch$?_Copy@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEXII@Z$0+2Aj
.text$mn:000010DC                 mov     dword ptr [ebp-4], 1
.text$mn:000010E3                 jmp     short loc_10EC
.text$mn:000010E3 ; END OF FUNCTION CHUNK FOR __catch$?_Copy@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEXII@Z$0
.text$mn:000010E5
.text$mn:000010E5 ; =============== S U B R O U T I N E =======================================
.text$mn:000010E5
.text$mn:000010E5
.text$mn:000010E5 $LN17           proc near               ; DATA XREF: .text$mn:000010D6o
.text$mn:000010E5                 mov     dword ptr [ebp-4], 1
.text$mn:000010E5 $LN17           endp ; sp-analysis failed
.text$mn:000010E5
.text$mn:000010EC ; START OF FUNCTION CHUNK FOR __catch$?_Copy@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEXII@Z$0
.text$mn:000010EC
.text$mn:000010EC loc_10EC:                               ; CODE XREF: __catch$?_Copy@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEXII@Z$0+4Ej
.text$mn:000010EC                 mov     eax, offset $LN19
.text$mn:000010F1                 retn
.text$mn:000010F1 ; END OF FUNCTION CHUNK FOR __catch$?_Copy@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEXII@Z$0
.text$mn:000010F2 ; ---------------------------------------------------------------------------
.text$mn:000010F2 ; START OF FUNCTION CHUNK FOR ?_Copy@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEXII@Z
.text$mn:000010F2
.text$mn:000010F2 loc_10F2:                               ; CODE XREF: std::basic_string<char,std::char_traits<char>,std::allocator<char>>::_Copy(uint,uint)+C3j
.text$mn:000010F2                 mov     [ebp+var_4], 0FFFFFFFFh
.text$mn:000010F9                 jmp     short loc_1102
.text$mn:000010F9 ; END OF FUNCTION CHUNK FOR ?_Copy@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEXII@Z
.text$mn:000010FB
.text$mn:000010FB ; =============== S U B R O U T I N E =======================================
.text$mn:000010FB
.text$mn:000010FB
.text$mn:000010FB $LN19           proc near               ; DATA XREF: __catch$?_Copy@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEXII@Z$0:loc_10ECo
.text$mn:000010FB                 mov     dword ptr [ebp-4], 0FFFFFFFFh
.text$mn:00001102
.text$mn:00001102 loc_1102:                               ; CODE XREF: std::basic_string<char,std::char_traits<char>,std::allocator<char>>::_Copy(uint,uint)+129j
.text$mn:00001102                 cmp     dword ptr [ebp+0Ch], 0
.text$mn:00001106                 jbe     short loc_1121
.text$mn:00001108                 mov     edx, [ebp+0Ch]
.text$mn:0000110B                 push    edx             ; Size
.text$mn:0000110C                 mov     ecx, [ebp-18h]
.text$mn:0000110F                 call    ?_Myptr@?$_String_val@U?$_Simple_types@D@std@@@std@@QAEPADXZ ; std::_String_val<std::_Simple_types<char>>::_Myptr(void)
.text$mn:00001114                 push    eax             ; Src
.text$mn:00001115                 mov     eax, [ebp-20h]
.text$mn:00001118                 push    eax             ; Dst
.text$mn:00001119                 call    ?copy@?$char_traits@D@std@@SAPADPADPBDI@Z ; std::char_traits<char>::copy(char *,char const *,uint)
.text$mn:0000111E                 add     esp, 0Ch
.text$mn:00001121
.text$mn:00001121 loc_1121:                               ; CODE XREF: $LN19+Bj
.text$mn:00001121                 push    0               ; Size
.text$mn:00001123                 push    1               ; char
.text$mn:00001125                 mov     ecx, [ebp-18h]
.text$mn:00001128                 call    ?_Tidy@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEX_NI@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char>>::_Tidy(bool,uint)
.text$mn:0000112D                 lea     ecx, [ebp-20h]
.text$mn:00001130                 push    ecx             ; int
.text$mn:00001131                 mov     edx, [ebp-18h]
.text$mn:00001134                 add     edx, 4
.text$mn:00001137                 push    edx             ; void *
.text$mn:00001138                 lea     eax, [ebp-13h]
.text$mn:0000113B                 push    eax
.text$mn:0000113C                 mov     ecx, [ebp-18h]
.text$mn:0000113F                 call    ?_Getal@?$_String_alloc@$0A@U?$_String_base_types@DV?$allocator@D@std@@@std@@@std@@QBE?AU?$_Wrap_alloc@V?$allocator@D@std@@@2@XZ ; std::_String_alloc<0,std::_String_base_types<char,std::allocator<char>>>::_Getal(void)
.text$mn:00001144                 mov     ecx, eax
.text$mn:00001146                 call    ??$construct@PADAAPAD@?$_Wrap_alloc@V?$allocator@D@std@@@std@@QAEXPAPADAAPAD@Z ; std::_Wrap_alloc<std::allocator<char>>::construct<char *,char * &>(char * *,char * &)
.text$mn:0000114B                 mov     ecx, [ebp-18h]
.text$mn:0000114E                 mov     edx, [ebp-1Ch]
.text$mn:00001151                 mov     [ecx+18h], edx
.text$mn:00001154                 mov     eax, [ebp+0Ch]
.text$mn:00001157                 push    eax
.text$mn:00001158                 mov     ecx, [ebp-18h]
.text$mn:0000115B                 call    ?_Eos@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEXI@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char>>::_Eos(uint)
.text$mn:00001160                 mov     ecx, [ebp-0Ch]
.text$mn:00001163                 mov     large fs:0, ecx
.text$mn:0000116A                 pop     ecx
.text$mn:0000116B                 pop     edi
.text$mn:0000116C                 pop     esi
.text$mn:0000116D                 pop     ebx
.text$mn:0000116E                 mov     esp, ebp
.text$mn:00001170                 pop     ebp
.text$mn:00001171                 retn    8
.text$mn:00001171 $LN19           endp ; sp-analysis failed
.text$mn:00001171
.text$mn:00001171 _text$mn        ends
.text$mn:00001171
.text$x:00001174 ; ===========================================================================
.text$x:00001174
.text$x:00001174 ; Segment type: Pure code
.text$x:00001174 ; Segment permissions: Read/Execute
.text$x:00001174 _text$x         segment para public 'CODE' use32
.text$x:00001174                 assume cs:_text$x
.text$x:00001174                 ;org 1174h
.text$x:00001174 ; COMDAT (pick associative to section at FD0)
.text$x:00001174                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text$x:00001174
.text$x:00001174 ; =============== S U B R O U T I N E =======================================
.text$x:00001174
.text$x:00001174
.text$x:00001174 __ehhandler$?_Copy@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEXII@Z proc near
.text$x:00001174                                         ; DATA XREF: std::basic_string<char,std::char_traits<char>,std::allocator<char>>::_Copy(uint,uint)+5o
.text$x:00001174
.text$x:00001174 arg_4           = dword ptr  8
.text$x:00001174
.text$x:00001174                 mov     edx, [esp+arg_4]
.text$x:00001178                 lea     eax, [edx+0Ch]
.text$x:0000117B                 mov     ecx, [edx-24h]
.text$x:0000117E                 xor     ecx, eax
.text$x:00001180                 call    @__security_check_cookie@4 ; __security_check_cookie(x)
.text$x:00001185                 mov     eax, offset __ehfuncinfo$?_Copy@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEXII@Z
.text$x:0000118A                 jmp     ___CxxFrameHandler3
.text$x:0000118A __ehhandler$?_Copy@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEXII@Z endp
.text$x:0000118A
.text$x:0000118A ; ---------------------------------------------------------------------------
.text$x:0000118F                 align 10h
.text$x:0000118F _text$x         ends
.text$x:0000118F
.text$mn:00001190 ; ===========================================================================
.text$mn:00001190
.text$mn:00001190 ; Segment type: Pure code
.text$mn:00001190 ; Segment permissions: Read/Execute
.text$mn:00001190 _text$mn        segment para public 'CODE' use32
.text$mn:00001190                 assume cs:_text$mn
.text$mn:00001190                 ;org 1190h
.text$mn:00001190 ; COMDAT (pick any)
.text$mn:00001190                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text$mn:00001190
.text$mn:00001190 ; =============== S U B R O U T I N E =======================================
.text$mn:00001190
.text$mn:00001190 ; Attributes: bp-based frame
.text$mn:00001190
.text$mn:00001190 ; public: void __thiscall std::basic_string<char, struct std::char_traits<char>, class std::allocator<char>>::_Eos(unsigned int)
.text$mn:00001190                 public ?_Eos@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEXI@Z
.text$mn:00001190 ?_Eos@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEXI@Z proc near
.text$mn:00001190                                         ; CODE XREF: $LN19+60p
.text$mn:00001190                                         ; std::basic_string<char,std::char_traits<char>,std::allocator<char>>::_Grow(uint,bool)+83p ...
.text$mn:00001190
.text$mn:00001190 var_8           = dword ptr -8
.text$mn:00001190 var_1           = byte ptr -1
.text$mn:00001190 arg_0           = dword ptr  8
.text$mn:00001190
.text$mn:00001190                 push    ebp
.text$mn:00001191                 mov     ebp, esp
.text$mn:00001193                 sub     esp, 8
.text$mn:00001196                 mov     [ebp+var_8], ecx
.text$mn:00001199                 mov     [ebp+var_1], 0
.text$mn:0000119D                 mov     eax, [ebp+var_8]
.text$mn:000011A0                 mov     ecx, [ebp+arg_0]
.text$mn:000011A3                 mov     [eax+14h], ecx
.text$mn:000011A6                 lea     edx, [ebp+var_1]
.text$mn:000011A9                 push    edx
.text$mn:000011AA                 mov     ecx, [ebp+var_8]
.text$mn:000011AD                 call    ?_Myptr@?$_String_val@U?$_Simple_types@D@std@@@std@@QAEPADXZ ; std::_String_val<std::_Simple_types<char>>::_Myptr(void)
.text$mn:000011B2                 add     eax, [ebp+arg_0]
.text$mn:000011B5                 push    eax
.text$mn:000011B6                 call    ?assign@?$char_traits@D@std@@SAXAADABD@Z ; std::char_traits<char>::assign(char &,char const &)
.text$mn:000011BB                 add     esp, 8
.text$mn:000011BE                 mov     esp, ebp
.text$mn:000011C0                 pop     ebp
.text$mn:000011C1                 retn    4
.text$mn:000011C1 ?_Eos@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEXI@Z endp
.text$mn:000011C1
.text$mn:000011C1 _text$mn        ends
.text$mn:000011C1
.text$mn:000011C4 ; ===========================================================================
.text$mn:000011C4
.text$mn:000011C4 ; Segment type: Pure code
.text$mn:000011C4 ; Segment permissions: Read/Execute
.text$mn:000011C4 _text$mn        segment para public 'CODE' use32
.text$mn:000011C4                 assume cs:_text$mn
.text$mn:000011C4                 ;org 11C4h
.text$mn:000011C4 ; COMDAT (pick any)
.text$mn:000011C4                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text$mn:000011C4
.text$mn:000011C4 ; =============== S U B R O U T I N E =======================================
.text$mn:000011C4
.text$mn:000011C4 ; Attributes: bp-based frame
.text$mn:000011C4
.text$mn:000011C4 ; public: void __thiscall std::_String_alloc<0, struct std::_String_base_types<char, class std::allocator<char>>>::_Free_proxy(void)
.text$mn:000011C4                 public ?_Free_proxy@?$_String_alloc@$0A@U?$_String_base_types@DV?$allocator@D@std@@@std@@@std@@QAEXXZ
.text$mn:000011C4 ?_Free_proxy@?$_String_alloc@$0A@U?$_String_base_types@DV?$allocator@D@std@@@std@@@std@@QAEXXZ proc near
.text$mn:000011C4                                         ; CODE XREF: std::_String_alloc<0,std::_String_base_types<char,std::allocator<char>>>::~_String_alloc<0,std::_String_base_types<char,std::allocator<char>>>(void)+30p
.text$mn:000011C4
.text$mn:000011C4 var_8           = dword ptr -8
.text$mn:000011C4 var_1           = byte ptr -1
.text$mn:000011C4
.text$mn:000011C4                 push    ebp
.text$mn:000011C5                 mov     ebp, esp
.text$mn:000011C7                 sub     esp, 8
.text$mn:000011CA                 mov     [ebp+var_8], ecx
.text$mn:000011CD                 lea     ecx, [ebp+var_1]
.text$mn:000011D0                 call    ??0?$allocator@U_Container_proxy@std@@@std@@QAE@XZ ; std::allocator<std::_Container_proxy>::allocator<std::_Container_proxy>(void)
.text$mn:000011D5                 mov     ecx, [ebp+var_8] ; this
.text$mn:000011D8                 call    ?_Orphan_all@_Container_base12@std@@QAEXXZ ; std::_Container_base12::_Orphan_all(void)
.text$mn:000011DD                 mov     eax, [ebp+var_8]
.text$mn:000011E0                 mov     ecx, [eax]
.text$mn:000011E2                 push    ecx
.text$mn:000011E3                 lea     ecx, [ebp+var_1]
.text$mn:000011E6                 call    ??$destroy@U_Container_proxy@std@@@?$allocator@U_Container_proxy@std@@@std@@QAEXPAU_Container_proxy@1@@Z ; std::allocator<std::_Container_proxy>::destroy<std::_Container_proxy>(std::_Container_proxy *)
.text$mn:000011EB                 push    1               ; int
.text$mn:000011ED                 mov     edx, [ebp+var_8]
.text$mn:000011F0                 mov     eax, [edx]
.text$mn:000011F2                 push    eax             ; void *
.text$mn:000011F3                 lea     ecx, [ebp+var_1]
.text$mn:000011F6                 call    ?deallocate@?$allocator@U_Container_proxy@std@@@std@@QAEXPAU_Container_proxy@2@I@Z ; std::allocator<std::_Container_proxy>::deallocate(std::_Container_proxy *,uint)
.text$mn:000011FB                 mov     ecx, [ebp+var_8]
.text$mn:000011FE                 mov     dword ptr [ecx], 0
.text$mn:00001204                 mov     esp, ebp
.text$mn:00001206                 pop     ebp
.text$mn:00001207                 retn
.text$mn:00001207 ?_Free_proxy@?$_String_alloc@$0A@U?$_String_base_types@DV?$allocator@D@std@@@std@@@std@@QAEXXZ endp
.text$mn:00001207
.text$mn:00001207 _text$mn        ends
.text$mn:00001207
.text$mn:00001208 ; ===========================================================================
.text$mn:00001208
.text$mn:00001208 ; Segment type: Pure code
.text$mn:00001208 ; Segment permissions: Read/Execute
.text$mn:00001208 _text$mn        segment para public 'CODE' use32
.text$mn:00001208                 assume cs:_text$mn
.text$mn:00001208                 ;org 1208h
.text$mn:00001208 ; COMDAT (pick any)
.text$mn:00001208                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text$mn:00001208
.text$mn:00001208 ; =============== S U B R O U T I N E =======================================
.text$mn:00001208
.text$mn:00001208 ; Attributes: bp-based frame
.text$mn:00001208
.text$mn:00001208 ; public: struct std::_Wrap_alloc<class std::allocator<char>> __thiscall std::_String_alloc<0, struct std::_String_base_types<char, class std::allocator<char>>>::_Getal(void)const
.text$mn:00001208                 public ?_Getal@?$_String_alloc@$0A@U?$_String_base_types@DV?$allocator@D@std@@@std@@@std@@QBE?AU?$_Wrap_alloc@V?$allocator@D@std@@@2@XZ
.text$mn:00001208 ?_Getal@?$_String_alloc@$0A@U?$_String_base_types@DV?$allocator@D@std@@@std@@@std@@QBE?AU?$_Wrap_alloc@V?$allocator@D@std@@@2@XZ proc near
.text$mn:00001208                                         ; CODE XREF: std::basic_string<char,std::char_traits<char>,std::allocator<char>>::_Copy(uint,uint)+B4p
.text$mn:00001208                                         ; __catch$?_Copy@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEXII@Z$0+1Bp ...
.text$mn:00001208
.text$mn:00001208 var_4           = dword ptr -4
.text$mn:00001208 arg_0           = dword ptr  8
.text$mn:00001208
.text$mn:00001208                 push    ebp
.text$mn:00001209                 mov     ebp, esp
.text$mn:0000120B                 push    ecx
.text$mn:0000120C                 mov     [ebp+var_4], ecx
.text$mn:0000120F                 mov     ecx, [ebp+arg_0]
.text$mn:00001212                 call    ??0?$_Wrap_alloc@V?$allocator@D@std@@@std@@QAE@XZ ; std::_Wrap_alloc<std::allocator<char>>::_Wrap_alloc<std::allocator<char>>(void)
.text$mn:00001217                 mov     eax, [ebp+arg_0]
.text$mn:0000121A                 mov     esp, ebp
.text$mn:0000121C                 pop     ebp
.text$mn:0000121D                 retn    4
.text$mn:0000121D ?_Getal@?$_String_alloc@$0A@U?$_String_base_types@DV?$allocator@D@std@@@std@@@std@@QBE?AU?$_Wrap_alloc@V?$allocator@D@std@@@2@XZ endp
.text$mn:0000121D
.text$mn:0000121D _text$mn        ends
.text$mn:0000121D
.text$mn:00001220 ; ===========================================================================
.text$mn:00001220
.text$mn:00001220 ; Segment type: Pure code
.text$mn:00001220 ; Segment permissions: Read/Execute
.text$mn:00001220 _text$mn        segment para public 'CODE' use32
.text$mn:00001220                 assume cs:_text$mn
.text$mn:00001220                 ;org 1220h
.text$mn:00001220 ; COMDAT (pick any)
.text$mn:00001220                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text$mn:00001220
.text$mn:00001220 ; =============== S U B R O U T I N E =======================================
.text$mn:00001220
.text$mn:00001220 ; Attributes: bp-based frame
.text$mn:00001220
.text$mn:00001220 ; public: bool __thiscall std::basic_string<char, struct std::char_traits<char>, class std::allocator<char>>::_Grow(unsigned int, bool)
.text$mn:00001220                 public ?_Grow@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE_NI_N@Z
.text$mn:00001220 ?_Grow@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE_NI_N@Z proc near
.text$mn:00001220                                         ; CODE XREF: std::basic_string<char,std::char_traits<char>,std::allocator<char>>::assign(std::basic_string<char,std::char_traits<char>,std::allocator<char>> const &,uint,uint)+6Ap
.text$mn:00001220                                         ; std::basic_string<char,std::char_traits<char>,std::allocator<char>>::assign(char const *,uint)+5Fp
.text$mn:00001220
.text$mn:00001220 var_C           = dword ptr -0Ch
.text$mn:00001220 Size            = dword ptr -8
.text$mn:00001220 var_4           = dword ptr -4
.text$mn:00001220 arg_0           = dword ptr  8
.text$mn:00001220 arg_4           = byte ptr  0Ch
.text$mn:00001220
.text$mn:00001220                 push    ebp
.text$mn:00001221                 mov     ebp, esp
.text$mn:00001223                 sub     esp, 0Ch
.text$mn:00001226                 mov     [ebp+var_4], ecx
.text$mn:00001229                 mov     ecx, [ebp+var_4]
.text$mn:0000122C                 call    ?max_size@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QBEIXZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char>>::max_size(void)
.text$mn:00001231                 cmp     eax, [ebp+arg_0]
.text$mn:00001234                 jnb     short loc_123E
.text$mn:00001236                 mov     ecx, [ebp+var_4]
.text$mn:00001239                 call    ?_Xlen@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QBEXXZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char>>::_Xlen(void)
.text$mn:0000123E
.text$mn:0000123E loc_123E:                               ; CODE XREF: std::basic_string<char,std::char_traits<char>,std::allocator<char>>::_Grow(uint,bool)+14j
.text$mn:0000123E                 mov     eax, [ebp+var_4]
.text$mn:00001241                 mov     ecx, [eax+18h]
.text$mn:00001244                 cmp     ecx, [ebp+arg_0]
.text$mn:00001247                 jnb     short loc_125E
.text$mn:00001249                 mov     edx, [ebp+var_4]
.text$mn:0000124C                 mov     eax, [edx+14h]
.text$mn:0000124F                 push    eax
.text$mn:00001250                 mov     ecx, [ebp+arg_0]
.text$mn:00001253                 push    ecx
.text$mn:00001254                 mov     ecx, [ebp+var_4]
.text$mn:00001257                 call    ?_Copy@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEXII@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char>>::_Copy(uint,uint)
.text$mn:0000125C                 jmp     short loc_12A8
.text$mn:0000125E ; ---------------------------------------------------------------------------
.text$mn:0000125E
.text$mn:0000125E loc_125E:                               ; CODE XREF: std::basic_string<char,std::char_traits<char>,std::allocator<char>>::_Grow(uint,bool)+27j
.text$mn:0000125E                 movzx   edx, [ebp+arg_4]
.text$mn:00001262                 test    edx, edx
.text$mn:00001264                 jz      short loc_1298
.text$mn:00001266                 cmp     [ebp+arg_0], 10h
.text$mn:0000126A                 jnb     short loc_1298
.text$mn:0000126C                 mov     eax, [ebp+var_4]
.text$mn:0000126F                 mov     ecx, [ebp+arg_0]
.text$mn:00001272                 cmp     ecx, [eax+14h]
.text$mn:00001275                 jnb     short loc_127F
.text$mn:00001277                 mov     edx, [ebp+arg_0]
.text$mn:0000127A                 mov     [ebp+Size], edx
.text$mn:0000127D                 jmp     short loc_1288
.text$mn:0000127F ; ---------------------------------------------------------------------------
.text$mn:0000127F
.text$mn:0000127F loc_127F:                               ; CODE XREF: std::basic_string<char,std::char_traits<char>,std::allocator<char>>::_Grow(uint,bool)+55j
.text$mn:0000127F                 mov     eax, [ebp+var_4]
.text$mn:00001282                 mov     ecx, [eax+14h]
.text$mn:00001285                 mov     [ebp+Size], ecx
.text$mn:00001288
.text$mn:00001288 loc_1288:                               ; CODE XREF: std::basic_string<char,std::char_traits<char>,std::allocator<char>>::_Grow(uint,bool)+5Dj
.text$mn:00001288                 mov     edx, [ebp+Size]
.text$mn:0000128B                 push    edx             ; Size
.text$mn:0000128C                 push    1               ; char
.text$mn:0000128E                 mov     ecx, [ebp+var_4]
.text$mn:00001291                 call    ?_Tidy@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEX_NI@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char>>::_Tidy(bool,uint)
.text$mn:00001296                 jmp     short loc_12A8
.text$mn:00001298 ; ---------------------------------------------------------------------------
.text$mn:00001298
.text$mn:00001298 loc_1298:                               ; CODE XREF: std::basic_string<char,std::char_traits<char>,std::allocator<char>>::_Grow(uint,bool)+44j
.text$mn:00001298                                         ; std::basic_string<char,std::char_traits<char>,std::allocator<char>>::_Grow(uint,bool)+4Aj
.text$mn:00001298                 cmp     [ebp+arg_0], 0
.text$mn:0000129C                 jnz     short loc_12A8
.text$mn:0000129E                 push    0
.text$mn:000012A0                 mov     ecx, [ebp+var_4]
.text$mn:000012A3                 call    ?_Eos@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEXI@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char>>::_Eos(uint)
.text$mn:000012A8
.text$mn:000012A8 loc_12A8:                               ; CODE XREF: std::basic_string<char,std::char_traits<char>,std::allocator<char>>::_Grow(uint,bool)+3Cj
.text$mn:000012A8                                         ; std::basic_string<char,std::char_traits<char>,std::allocator<char>>::_Grow(uint,bool)+76j ...
.text$mn:000012A8                 cmp     [ebp+arg_0], 0
.text$mn:000012AC                 jbe     short loc_12B7
.text$mn:000012AE                 mov     [ebp+var_C], 1
.text$mn:000012B5                 jmp     short loc_12BE
.text$mn:000012B7 ; ---------------------------------------------------------------------------
.text$mn:000012B7
.text$mn:000012B7 loc_12B7:                               ; CODE XREF: std::basic_string<char,std::char_traits<char>,std::allocator<char>>::_Grow(uint,bool)+8Cj
.text$mn:000012B7                 mov     [ebp+var_C], 0
.text$mn:000012BE
.text$mn:000012BE loc_12BE:                               ; CODE XREF: std::basic_string<char,std::char_traits<char>,std::allocator<char>>::_Grow(uint,bool)+95j
.text$mn:000012BE                 mov     al, byte ptr [ebp+var_C]
.text$mn:000012C1                 mov     esp, ebp
.text$mn:000012C3                 pop     ebp
.text$mn:000012C4                 retn    8
.text$mn:000012C4 ?_Grow@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE_NI_N@Z endp
.text$mn:000012C4
.text$mn:000012C4 ; ---------------------------------------------------------------------------
.text$mn:000012C7                 align 4
.text$mn:000012C7 _text$mn        ends
.text$mn:000012C7
.text$mn:000012C8 ; ===========================================================================
.text$mn:000012C8
.text$mn:000012C8 ; Segment type: Pure code
.text$mn:000012C8 ; Segment permissions: Read/Execute
.text$mn:000012C8 _text$mn        segment para public 'CODE' use32
.text$mn:000012C8                 assume cs:_text$mn
.text$mn:000012C8                 ;org 12C8h
.text$mn:000012C8 ; COMDAT (pick any)
.text$mn:000012C8                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text$mn:000012C8
.text$mn:000012C8 ; =============== S U B R O U T I N E =======================================
.text$mn:000012C8
.text$mn:000012C8 ; Attributes: bp-based frame
.text$mn:000012C8
.text$mn:000012C8 ; public: bool __thiscall std::basic_string<char, struct std::char_traits<char>, class std::allocator<char>>::_Inside(char const *)
.text$mn:000012C8                 public ?_Inside@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE_NPBD@Z
.text$mn:000012C8 ?_Inside@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE_NPBD@Z proc near
.text$mn:000012C8                                         ; CODE XREF: std::basic_string<char,std::char_traits<char>,std::allocator<char>>::assign(char const *,uint)+2Ap
.text$mn:000012C8
.text$mn:000012C8 var_4           = dword ptr -4
.text$mn:000012C8 arg_0           = dword ptr  8
.text$mn:000012C8
.text$mn:000012C8                 push    ebp
.text$mn:000012C9                 mov     ebp, esp
.text$mn:000012CB                 push    ecx
.text$mn:000012CC                 mov     [ebp+var_4], ecx
.text$mn:000012CF                 cmp     [ebp+arg_0], 0
.text$mn:000012D3                 jz      short loc_12F5
.text$mn:000012D5                 mov     ecx, [ebp+var_4]
.text$mn:000012D8                 call    ?_Myptr@?$_String_val@U?$_Simple_types@D@std@@@std@@QAEPADXZ ; std::_String_val<std::_Simple_types<char>>::_Myptr(void)
.text$mn:000012DD                 cmp     [ebp+arg_0], eax
.text$mn:000012E0                 jb      short loc_12F5
.text$mn:000012E2                 mov     ecx, [ebp+var_4]
.text$mn:000012E5                 call    ?_Myptr@?$_String_val@U?$_Simple_types@D@std@@@std@@QAEPADXZ ; std::_String_val<std::_Simple_types<char>>::_Myptr(void)
.text$mn:000012EA                 mov     ecx, [ebp+var_4]
.text$mn:000012ED                 add     eax, [ecx+14h]
.text$mn:000012F0                 cmp     eax, [ebp+arg_0]
.text$mn:000012F3                 ja      short loc_12FB
.text$mn:000012F5
.text$mn:000012F5 loc_12F5:                               ; CODE XREF: std::basic_string<char,std::char_traits<char>,std::allocator<char>>::_Inside(char const *)+Bj
.text$mn:000012F5                                         ; std::basic_string<char,std::char_traits<char>,std::allocator<char>>::_Inside(char const *)+18j
.text$mn:000012F5                 xor     al, al
.text$mn:000012F7                 jmp     short loc_12FD
.text$mn:000012F9 ; ---------------------------------------------------------------------------
.text$mn:000012F9                 jmp     short loc_12FD
.text$mn:000012FB ; ---------------------------------------------------------------------------
.text$mn:000012FB
.text$mn:000012FB loc_12FB:                               ; CODE XREF: std::basic_string<char,std::char_traits<char>,std::allocator<char>>::_Inside(char const *)+2Bj
.text$mn:000012FB                 mov     al, 1
.text$mn:000012FD
.text$mn:000012FD loc_12FD:                               ; CODE XREF: std::basic_string<char,std::char_traits<char>,std::allocator<char>>::_Inside(char const *)+2Fj
.text$mn:000012FD                                         ; std::basic_string<char,std::char_traits<char>,std::allocator<char>>::_Inside(char const *)+31j
.text$mn:000012FD                 mov     esp, ebp
.text$mn:000012FF                 pop     ebp
.text$mn:00001300                 retn    4
.text$mn:00001300 ?_Inside@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE_NPBD@Z endp
.text$mn:00001300
.text$mn:00001300 ; ---------------------------------------------------------------------------
.text$mn:00001303                 align 4
.text$mn:00001303 _text$mn        ends
.text$mn:00001303
.text$mn:00001304 ; ===========================================================================
.text$mn:00001304
.text$mn:00001304 ; Segment type: Pure code
.text$mn:00001304 ; Segment permissions: Read/Execute
.text$mn:00001304 _text$mn        segment para public 'CODE' use32
.text$mn:00001304                 assume cs:_text$mn
.text$mn:00001304                 ;org 1304h
.text$mn:00001304 ; COMDAT (pick any)
.text$mn:00001304                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text$mn:00001304
.text$mn:00001304 ; =============== S U B R O U T I N E =======================================
.text$mn:00001304
.text$mn:00001304 ; Attributes: bp-based frame
.text$mn:00001304
.text$mn:00001304 ; public: char * __thiscall std::_String_val<struct std::_Simple_types<char>>::_Myptr(void)
.text$mn:00001304                 public ?_Myptr@?$_String_val@U?$_Simple_types@D@std@@@std@@QAEPADXZ
.text$mn:00001304 ?_Myptr@?$_String_val@U?$_Simple_types@D@std@@@std@@QAEPADXZ proc near
.text$mn:00001304                                         ; CODE XREF: $LN19+14p
.text$mn:00001304                                         ; std::basic_string<char,std::char_traits<char>,std::allocator<char>>::_Eos(uint)+1Dp ...
.text$mn:00001304
.text$mn:00001304 var_8           = dword ptr -8
.text$mn:00001304 var_4           = dword ptr -4
.text$mn:00001304
.text$mn:00001304                 push    ebp
.text$mn:00001305                 mov     ebp, esp
.text$mn:00001307                 sub     esp, 8
.text$mn:0000130A                 mov     [ebp+var_4], ecx
.text$mn:0000130D                 mov     eax, [ebp+var_4]
.text$mn:00001310                 cmp     dword ptr [eax+18h], 10h
.text$mn:00001314                 jb      short loc_132A
.text$mn:00001316                 mov     ecx, [ebp+var_4]
.text$mn:00001319                 mov     edx, [ecx+4]
.text$mn:0000131C                 push    edx
.text$mn:0000131D                 call    ??$addressof@D@std@@YAPADAAD@Z ; std::addressof<char>(char &)
.text$mn:00001322                 add     esp, 4
.text$mn:00001325                 mov     [ebp+var_8], eax
.text$mn:00001328                 jmp     short loc_1333
.text$mn:0000132A ; ---------------------------------------------------------------------------
.text$mn:0000132A
.text$mn:0000132A loc_132A:                               ; CODE XREF: std::_String_val<std::_Simple_types<char>>::_Myptr(void)+10j
.text$mn:0000132A                 mov     eax, [ebp+var_4]
.text$mn:0000132D                 add     eax, 4
.text$mn:00001330                 mov     [ebp+var_8], eax
.text$mn:00001333
.text$mn:00001333 loc_1333:                               ; CODE XREF: std::_String_val<std::_Simple_types<char>>::_Myptr(void)+24j
.text$mn:00001333                 mov     eax, [ebp+var_8]
.text$mn:00001336                 mov     esp, ebp
.text$mn:00001338                 pop     ebp
.text$mn:00001339                 retn
.text$mn:00001339 ?_Myptr@?$_String_val@U?$_Simple_types@D@std@@@std@@QAEPADXZ endp
.text$mn:00001339
.text$mn:00001339 ; ---------------------------------------------------------------------------
.text$mn:0000133A                 align 4
.text$mn:0000133A _text$mn        ends
.text$mn:0000133A
.text$mn:0000133C ; ===========================================================================
.text$mn:0000133C
.text$mn:0000133C ; Segment type: Pure code
.text$mn:0000133C ; Segment permissions: Read/Execute
.text$mn:0000133C _text$mn        segment para public 'CODE' use32
.text$mn:0000133C                 assume cs:_text$mn
.text$mn:0000133C                 ;org 133Ch
.text$mn:0000133C ; COMDAT (pick any)
.text$mn:0000133C                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text$mn:0000133C
.text$mn:0000133C ; =============== S U B R O U T I N E =======================================
.text$mn:0000133C
.text$mn:0000133C ; Attributes: bp-based frame
.text$mn:0000133C
.text$mn:0000133C ; public: char const * __thiscall std::_String_val<struct std::_Simple_types<char>>::_Myptr(void)const
.text$mn:0000133C                 public ?_Myptr@?$_String_val@U?$_Simple_types@D@std@@@std@@QBEPBDXZ
.text$mn:0000133C ?_Myptr@?$_String_val@U?$_Simple_types@D@std@@@std@@QBEPBDXZ proc near
.text$mn:0000133C                                         ; CODE XREF: std::basic_string<char,std::char_traits<char>,std::allocator<char>>::assign(std::basic_string<char,std::char_traits<char>,std::allocator<char>> const &,uint,uint)+7Dp
.text$mn:0000133C
.text$mn:0000133C var_8           = dword ptr -8
.text$mn:0000133C var_4           = dword ptr -4
.text$mn:0000133C
.text$mn:0000133C                 push    ebp
.text$mn:0000133D                 mov     ebp, esp
.text$mn:0000133F                 sub     esp, 8
.text$mn:00001342                 mov     [ebp+var_4], ecx
.text$mn:00001345                 mov     eax, [ebp+var_4]
.text$mn:00001348                 cmp     dword ptr [eax+18h], 10h
.text$mn:0000134C                 jb      short loc_1362
.text$mn:0000134E                 mov     ecx, [ebp+var_4]
.text$mn:00001351                 mov     edx, [ecx+4]
.text$mn:00001354                 push    edx
.text$mn:00001355                 call    ??$addressof@D@std@@YAPADAAD@Z ; std::addressof<char>(char &)
.text$mn:0000135A                 add     esp, 4
.text$mn:0000135D                 mov     [ebp+var_8], eax
.text$mn:00001360                 jmp     short loc_136B
.text$mn:00001362 ; ---------------------------------------------------------------------------
.text$mn:00001362
.text$mn:00001362 loc_1362:                               ; CODE XREF: std::_String_val<std::_Simple_types<char>>::_Myptr(void)+10j
.text$mn:00001362                 mov     eax, [ebp+var_4]
.text$mn:00001365                 add     eax, 4
.text$mn:00001368                 mov     [ebp+var_8], eax
.text$mn:0000136B
.text$mn:0000136B loc_136B:                               ; CODE XREF: std::_String_val<std::_Simple_types<char>>::_Myptr(void)+24j
.text$mn:0000136B                 mov     eax, [ebp+var_8]
.text$mn:0000136E                 mov     esp, ebp
.text$mn:00001370                 pop     ebp
.text$mn:00001371                 retn
.text$mn:00001371 ?_Myptr@?$_String_val@U?$_Simple_types@D@std@@@std@@QBEPBDXZ endp
.text$mn:00001371
.text$mn:00001371 ; ---------------------------------------------------------------------------
.text$mn:00001372                 align 4
.text$mn:00001372 _text$mn        ends
.text$mn:00001372
.text$mn:00001374 ; ===========================================================================
.text$mn:00001374
.text$mn:00001374 ; Segment type: Pure code
.text$mn:00001374 ; Segment permissions: Read/Execute
.text$mn:00001374 _text$mn        segment para public 'CODE' use32
.text$mn:00001374                 assume cs:_text$mn
.text$mn:00001374                 ;org 1374h
.text$mn:00001374 ; COMDAT (pick any)
.text$mn:00001374                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text$mn:00001374
.text$mn:00001374 ; =============== S U B R O U T I N E =======================================
.text$mn:00001374
.text$mn:00001374 ; Attributes: bp-based frame
.text$mn:00001374
.text$mn:00001374 ; void __thiscall std::_Container_base12::_Orphan_all(std::_Container_base12 *__hidden this)
.text$mn:00001374                 public ?_Orphan_all@_Container_base12@std@@QAEXXZ
.text$mn:00001374 ?_Orphan_all@_Container_base12@std@@QAEXXZ proc near
.text$mn:00001374                                         ; CODE XREF: std::_Container_base12::~_Container_base12(void)+Ap
.text$mn:00001374                                         ; std::_String_alloc<0,std::_String_base_types<char,std::allocator<char>>>::_Free_proxy(void)+14p
.text$mn:00001374
.text$mn:00001374 var_18          = byte ptr -18h
.text$mn:00001374 var_14          = dword ptr -14h
.text$mn:00001374 var_10          = dword ptr -10h
.text$mn:00001374 var_C           = dword ptr -0Ch
.text$mn:00001374 var_4           = dword ptr -4
.text$mn:00001374
.text$mn:00001374                 push    ebp
.text$mn:00001375                 mov     ebp, esp
.text$mn:00001377                 push    0FFFFFFFFh
.text$mn:00001379                 push    offset __ehhandler$?_Orphan_all@_Container_base12@std@@QAEXXZ
.text$mn:0000137E                 mov     eax, large fs:0
.text$mn:00001384                 push    eax
.text$mn:00001385                 sub     esp, 0Ch
.text$mn:00001388                 mov     eax, dword ptr ds:___security_cookie
.text$mn:0000138D                 xor     eax, ebp
.text$mn:0000138F                 push    eax
.text$mn:00001390                 lea     eax, [ebp+var_C]
.text$mn:00001393                 mov     large fs:0, eax
.text$mn:00001399                 mov     [ebp+var_14], ecx
.text$mn:0000139C                 mov     eax, [ebp+var_14]
.text$mn:0000139F                 cmp     dword ptr [eax], 0
.text$mn:000013A2                 jz      short loc_13FF
.text$mn:000013A4                 push    3               ; int
.text$mn:000013A6                 lea     ecx, [ebp+var_18] ; this
.text$mn:000013A9                 call    ??0_Lockit@std@@QAE@H@Z ; std::_Lockit::_Lockit(int)
.text$mn:000013AE                 mov     [ebp+var_4], 0
.text$mn:000013B5                 mov     ecx, [ebp+var_14]
.text$mn:000013B8                 mov     edx, [ecx]
.text$mn:000013BA                 add     edx, 4
.text$mn:000013BD                 mov     [ebp+var_10], edx
.text$mn:000013C0                 jmp     short loc_13CF
.text$mn:000013C2 ; ---------------------------------------------------------------------------
.text$mn:000013C2
.text$mn:000013C2 loc_13C2:                               ; CODE XREF: std::_Container_base12::_Orphan_all(void)+6Ej
.text$mn:000013C2                 mov     eax, [ebp+var_10]
.text$mn:000013C5                 mov     ecx, [eax]
.text$mn:000013C7                 mov     edx, [ebp+var_10]
.text$mn:000013CA                 mov     eax, [ecx+4]
.text$mn:000013CD                 mov     [edx], eax
.text$mn:000013CF
.text$mn:000013CF loc_13CF:                               ; CODE XREF: std::_Container_base12::_Orphan_all(void)+4Cj
.text$mn:000013CF                 mov     ecx, [ebp+var_10]
.text$mn:000013D2                 cmp     dword ptr [ecx], 0
.text$mn:000013D5                 jz      short loc_13E4
.text$mn:000013D7                 mov     edx, [ebp+var_10]
.text$mn:000013DA                 mov     eax, [edx]
.text$mn:000013DC                 mov     dword ptr [eax], 0
.text$mn:000013E2                 jmp     short loc_13C2
.text$mn:000013E4 ; ---------------------------------------------------------------------------
.text$mn:000013E4
.text$mn:000013E4 loc_13E4:                               ; CODE XREF: std::_Container_base12::_Orphan_all(void)+61j
.text$mn:000013E4                 mov     ecx, [ebp+var_14]
.text$mn:000013E7                 mov     edx, [ecx]
.text$mn:000013E9                 mov     dword ptr [edx+4], 0
.text$mn:000013F0                 mov     [ebp+var_4], 0FFFFFFFFh
.text$mn:000013F7                 lea     ecx, [ebp+var_18] ; this
.text$mn:000013FA                 call    ??1_Lockit@std@@QAE@XZ ; std::_Lockit::~_Lockit(void)
.text$mn:000013FF
.text$mn:000013FF loc_13FF:                               ; CODE XREF: std::_Container_base12::_Orphan_all(void)+2Ej
.text$mn:000013FF                 mov     ecx, [ebp+var_C]
.text$mn:00001402                 mov     large fs:0, ecx
.text$mn:00001409                 pop     ecx
.text$mn:0000140A                 mov     esp, ebp
.text$mn:0000140C                 pop     ebp
.text$mn:0000140D                 retn
.text$mn:0000140D ?_Orphan_all@_Container_base12@std@@QAEXXZ endp
.text$mn:0000140D
.text$mn:0000140D ; ---------------------------------------------------------------------------
.text$mn:0000140E                 align 10h
.text$mn:0000140E _text$mn        ends
.text$mn:0000140E
.text$x:00001410 ; ===========================================================================
.text$x:00001410
.text$x:00001410 ; Segment type: Pure code
.text$x:00001410 ; Segment permissions: Read/Execute
.text$x:00001410 _text$x         segment para public 'CODE' use32
.text$x:00001410                 assume cs:_text$x
.text$x:00001410                 ;org 1410h
.text$x:00001410 ; COMDAT (pick associative to section at 1374)
.text$x:00001410                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text$x:00001410
.text$x:00001410 ; =============== S U B R O U T I N E =======================================
.text$x:00001410
.text$x:00001410
.text$x:00001410 __unwindfunclet$?_Orphan_all@_Container_base12@std@@QAEXXZ$0 proc near
.text$x:00001410                                         ; DATA XREF: .xdata$x:00001D38o
.text$x:00001410                 lea     ecx, [ebp-18h]  ; this
.text$x:00001413                 jmp     ??1_Lockit@std@@QAE@XZ ; std::_Lockit::~_Lockit(void)
.text$x:00001413 __unwindfunclet$?_Orphan_all@_Container_base12@std@@QAEXXZ$0 endp
.text$x:00001413
.text$x:00001418
.text$x:00001418 ; =============== S U B R O U T I N E =======================================
.text$x:00001418
.text$x:00001418
.text$x:00001418 __ehhandler$?_Orphan_all@_Container_base12@std@@QAEXXZ proc near
.text$x:00001418                                         ; DATA XREF: std::_Container_base12::_Orphan_all(void)+5o
.text$x:00001418
.text$x:00001418 arg_4           = dword ptr  8
.text$x:00001418
.text$x:00001418                 mov     edx, [esp+arg_4]
.text$x:0000141C                 lea     eax, [edx+0Ch]
.text$x:0000141F                 mov     ecx, [edx-10h]
.text$x:00001422                 xor     ecx, eax
.text$x:00001424                 call    @__security_check_cookie@4 ; __security_check_cookie(x)
.text$x:00001429                 mov     eax, offset __ehfuncinfo$?_Orphan_all@_Container_base12@std@@QAEXXZ
.text$x:0000142E                 jmp     ___CxxFrameHandler3
.text$x:0000142E __ehhandler$?_Orphan_all@_Container_base12@std@@QAEXXZ endp
.text$x:0000142E
.text$x:0000142E ; ---------------------------------------------------------------------------
.text$x:00001433                 align 4
.text$x:00001433 _text$x         ends
.text$x:00001433
.text$mn:00001434 ; ===========================================================================
.text$mn:00001434
.text$mn:00001434 ; Segment type: Pure code
.text$mn:00001434 ; Segment permissions: Read/Execute
.text$mn:00001434 _text$mn        segment para public 'CODE' use32
.text$mn:00001434                 assume cs:_text$mn
.text$mn:00001434                 ;org 1434h
.text$mn:00001434 ; COMDAT (pick any)
.text$mn:00001434                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text$mn:00001434
.text$mn:00001434 ; =============== S U B R O U T I N E =======================================
.text$mn:00001434
.text$mn:00001434 ; Attributes: bp-based frame
.text$mn:00001434
.text$mn:00001434 ; int __stdcall std::basic_string<char,std::char_traits<char>,std::allocator<char>>::_Tidy(char, size_t Size)
.text$mn:00001434                 public ?_Tidy@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEX_NI@Z
.text$mn:00001434 ?_Tidy@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEX_NI@Z proc near
.text$mn:00001434                                         ; CODE XREF: std::basic_string<char,std::char_traits<char>,std::allocator<char>>::basic_string<char,std::char_traits<char>,std::allocator<char>>(char const *)+47p
.text$mn:00001434                                         ; std::basic_string<char,std::char_traits<char>,std::allocator<char>>::~basic_string<char,std::char_traits<char>,std::allocator<char>>(void)+34p ...
.text$mn:00001434
.text$mn:00001434 var_C           = dword ptr -0Ch
.text$mn:00001434 var_8           = dword ptr -8
.text$mn:00001434 var_2           = byte ptr -2
.text$mn:00001434 var_1           = byte ptr -1
.text$mn:00001434 arg_0           = byte ptr  8
.text$mn:00001434 Size            = dword ptr  0Ch
.text$mn:00001434
.text$mn:00001434                 push    ebp
.text$mn:00001435                 mov     ebp, esp
.text$mn:00001437                 sub     esp, 0Ch
.text$mn:0000143A                 mov     [ebp+var_8], ecx
.text$mn:0000143D                 movzx   eax, [ebp+arg_0]
.text$mn:00001441                 test    eax, eax
.text$mn:00001443                 jnz     short loc_1447
.text$mn:00001445                 jmp     short loc_14BA
.text$mn:00001447 ; ---------------------------------------------------------------------------
.text$mn:00001447
.text$mn:00001447 loc_1447:                               ; CODE XREF: std::basic_string<char,std::char_traits<char>,std::allocator<char>>::_Tidy(bool,uint)+Fj
.text$mn:00001447                 mov     ecx, [ebp+var_8]
.text$mn:0000144A                 cmp     dword ptr [ecx+18h], 10h
.text$mn:0000144E                 jb      short loc_14BA
.text$mn:00001450                 mov     edx, [ebp+var_8]
.text$mn:00001453                 mov     eax, [edx+4]
.text$mn:00001456                 mov     [ebp+var_C], eax
.text$mn:00001459                 mov     ecx, [ebp+var_8]
.text$mn:0000145C                 add     ecx, 4
.text$mn:0000145F                 push    ecx
.text$mn:00001460                 lea     edx, [ebp+var_1]
.text$mn:00001463                 push    edx
.text$mn:00001464                 mov     ecx, [ebp+var_8]
.text$mn:00001467                 call    ?_Getal@?$_String_alloc@$0A@U?$_String_base_types@DV?$allocator@D@std@@@std@@@std@@QBE?AU?$_Wrap_alloc@V?$allocator@D@std@@@2@XZ ; std::_String_alloc<0,std::_String_base_types<char,std::allocator<char>>>::_Getal(void)
.text$mn:0000146C                 mov     ecx, eax
.text$mn:0000146E                 call    ??$destroy@PAD@?$_Wrap_alloc@V?$allocator@D@std@@@std@@QAEXPAPAD@Z ; std::_Wrap_alloc<std::allocator<char>>::destroy<char *>(char * *)
.text$mn:00001473                 cmp     [ebp+Size], 0
.text$mn:00001477                 jbe     short loc_1499
.text$mn:00001479                 mov     eax, [ebp+Size]
.text$mn:0000147C                 push    eax             ; Size
.text$mn:0000147D                 mov     ecx, [ebp+var_C]
.text$mn:00001480                 push    ecx
.text$mn:00001481                 call    ??$addressof@D@std@@YAPADAAD@Z ; std::addressof<char>(char &)
.text$mn:00001486                 add     esp, 4
.text$mn:00001489                 push    eax             ; Src
.text$mn:0000148A                 mov     edx, [ebp+var_8]
.text$mn:0000148D                 add     edx, 4
.text$mn:00001490                 push    edx             ; Dst
.text$mn:00001491                 call    ?copy@?$char_traits@D@std@@SAPADPADPBDI@Z ; std::char_traits<char>::copy(char *,char const *,uint)
.text$mn:00001496                 add     esp, 0Ch
.text$mn:00001499
.text$mn:00001499 loc_1499:                               ; CODE XREF: std::basic_string<char,std::char_traits<char>,std::allocator<char>>::_Tidy(bool,uint)+43j
.text$mn:00001499                 mov     eax, [ebp+var_8]
.text$mn:0000149C                 mov     ecx, [eax+18h]
.text$mn:0000149F                 add     ecx, 1
.text$mn:000014A2                 push    ecx             ; int
.text$mn:000014A3                 mov     edx, [ebp+var_C]
.text$mn:000014A6                 push    edx             ; void *
.text$mn:000014A7                 lea     eax, [ebp+var_2]
.text$mn:000014AA                 push    eax
.text$mn:000014AB                 mov     ecx, [ebp+var_8]
.text$mn:000014AE                 call    ?_Getal@?$_String_alloc@$0A@U?$_String_base_types@DV?$allocator@D@std@@@std@@@std@@QBE?AU?$_Wrap_alloc@V?$allocator@D@std@@@2@XZ ; std::_String_alloc<0,std::_String_base_types<char,std::allocator<char>>>::_Getal(void)
.text$mn:000014B3                 mov     ecx, eax
.text$mn:000014B5                 call    ?deallocate@?$_Wrap_alloc@V?$allocator@D@std@@@std@@QAEXPADI@Z ; std::_Wrap_alloc<std::allocator<char>>::deallocate(char *,uint)
.text$mn:000014BA
.text$mn:000014BA loc_14BA:                               ; CODE XREF: std::basic_string<char,std::char_traits<char>,std::allocator<char>>::_Tidy(bool,uint)+11j
.text$mn:000014BA                                         ; std::basic_string<char,std::char_traits<char>,std::allocator<char>>::_Tidy(bool,uint)+1Aj
.text$mn:000014BA                 mov     ecx, [ebp+var_8]
.text$mn:000014BD                 mov     dword ptr [ecx+18h], 0Fh
.text$mn:000014C4                 mov     edx, [ebp+Size]
.text$mn:000014C7                 push    edx
.text$mn:000014C8                 mov     ecx, [ebp+var_8]
.text$mn:000014CB                 call    ?_Eos@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEXI@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char>>::_Eos(uint)
.text$mn:000014D0                 mov     esp, ebp
.text$mn:000014D2                 pop     ebp
.text$mn:000014D3                 retn    8
.text$mn:000014D3 ?_Tidy@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEX_NI@Z endp
.text$mn:000014D3
.text$mn:000014D3 ; ---------------------------------------------------------------------------
.text$mn:000014D6                 align 4
.text$mn:000014D6 _text$mn        ends
.text$mn:000014D6
.text$mn:000014D8 ; ===========================================================================
.text$mn:000014D8
.text$mn:000014D8 ; Segment type: Pure code
.text$mn:000014D8 ; Segment permissions: Read/Execute
.text$mn:000014D8 _text$mn        segment para public 'CODE' use32
.text$mn:000014D8                 assume cs:_text$mn
.text$mn:000014D8                 ;org 14D8h
.text$mn:000014D8 ; COMDAT (pick any)
.text$mn:000014D8                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text$mn:000014D8
.text$mn:000014D8 ; =============== S U B R O U T I N E =======================================
.text$mn:000014D8
.text$mn:000014D8 ; Attributes: bp-based frame
.text$mn:000014D8
.text$mn:000014D8 ; public: void __thiscall std::basic_string<char, struct std::char_traits<char>, class std::allocator<char>>::_Xlen(void)const
.text$mn:000014D8                 public ?_Xlen@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QBEXXZ
.text$mn:000014D8 ?_Xlen@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QBEXXZ proc near
.text$mn:000014D8                                         ; CODE XREF: std::basic_string<char,std::char_traits<char>,std::allocator<char>>::_Grow(uint,bool)+19p
.text$mn:000014D8
.text$mn:000014D8 var_4           = dword ptr -4
.text$mn:000014D8
.text$mn:000014D8                 push    ebp
.text$mn:000014D9                 mov     ebp, esp
.text$mn:000014DB                 push    ecx
.text$mn:000014DC                 mov     [ebp+var_4], ecx
.text$mn:000014DF                 push    offset ??_C@_0BA@JFNIOLAK@string?5too?5long?$AA@ ; "string too long"
.text$mn:000014E4                 call    ?_Xlength_error@std@@YAXPBD@Z ; std::_Xlength_error(char const *)
.text$mn:000014E9                 mov     esp, ebp
.text$mn:000014EB                 pop     ebp
.text$mn:000014EC                 retn
.text$mn:000014EC ?_Xlen@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QBEXXZ endp
.text$mn:000014EC
.text$mn:000014EC ; ---------------------------------------------------------------------------
.text$mn:000014ED                 align 10h
.text$mn:000014ED _text$mn        ends
.text$mn:000014ED
.text$mn:000014F0 ; ===========================================================================
.text$mn:000014F0
.text$mn:000014F0 ; Segment type: Pure code
.text$mn:000014F0 ; Segment permissions: Read/Execute
.text$mn:000014F0 _text$mn        segment para public 'CODE' use32
.text$mn:000014F0                 assume cs:_text$mn
.text$mn:000014F0                 ;org 14F0h
.text$mn:000014F0 ; COMDAT (pick any)
.text$mn:000014F0                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text$mn:000014F0
.text$mn:000014F0 ; =============== S U B R O U T I N E =======================================
.text$mn:000014F0
.text$mn:000014F0 ; Attributes: bp-based frame
.text$mn:000014F0
.text$mn:000014F0 ; public: void __thiscall std::basic_string<char, struct std::char_traits<char>, class std::allocator<char>>::_Xran(void)const
.text$mn:000014F0                 public ?_Xran@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QBEXXZ
.text$mn:000014F0 ?_Xran@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QBEXXZ proc near
.text$mn:000014F0                                         ; CODE XREF: std::basic_string<char,std::char_traits<char>,std::allocator<char>>::assign(std::basic_string<char,std::char_traits<char>,std::allocator<char>> const &,uint,uint)+19p
.text$mn:000014F0                                         ; std::basic_string<char,std::char_traits<char>,std::allocator<char>>::erase(uint)+15p ...
.text$mn:000014F0
.text$mn:000014F0 var_4           = dword ptr -4
.text$mn:000014F0
.text$mn:000014F0                 push    ebp
.text$mn:000014F1                 mov     ebp, esp
.text$mn:000014F3                 push    ecx
.text$mn:000014F4                 mov     [ebp+var_4], ecx
.text$mn:000014F7                 push    offset ??_C@_0BI@CFPLBAOH@invalid?5string?5position?$AA@ ; "invalid string position"
.text$mn:000014FC                 call    ?_Xout_of_range@std@@YAXPBD@Z ; std::_Xout_of_range(char const *)
.text$mn:00001501                 mov     esp, ebp
.text$mn:00001503                 pop     ebp
.text$mn:00001504                 retn
.text$mn:00001504 ?_Xran@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QBEXXZ endp
.text$mn:00001504
.text$mn:00001504 ; ---------------------------------------------------------------------------
.text$mn:00001505                 align 4
.text$mn:00001505 _text$mn        ends
.text$mn:00001505
.text$mn:00001508 ; ===========================================================================
.text$mn:00001508
.text$mn:00001508 ; Segment type: Pure code
.text$mn:00001508 ; Segment permissions: Read/Execute
.text$mn:00001508 _text$mn        segment para public 'CODE' use32
.text$mn:00001508                 assume cs:_text$mn
.text$mn:00001508                 ;org 1508h
.text$mn:00001508 ; COMDAT (pick any)
.text$mn:00001508                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text$mn:00001508
.text$mn:00001508 ; =============== S U B R O U T I N E =======================================
.text$mn:00001508
.text$mn:00001508 ; Attributes: bp-based frame
.text$mn:00001508
.text$mn:00001508 ; public: char * __thiscall std::_Wrap_alloc<class std::allocator<char>>::allocate(unsigned int)
.text$mn:00001508                 public ?allocate@?$_Wrap_alloc@V?$allocator@D@std@@@std@@QAEPADI@Z
.text$mn:00001508 ?allocate@?$_Wrap_alloc@V?$allocator@D@std@@@std@@QAEPADI@Z proc near
.text$mn:00001508                                         ; CODE XREF: std::basic_string<char,std::char_traits<char>,std::allocator<char>>::_Copy(uint,uint)+BBp
.text$mn:00001508                                         ; __catch$?_Copy@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEXII@Z$0+22p
.text$mn:00001508
.text$mn:00001508 var_4           = dword ptr -4
.text$mn:00001508 arg_0           = dword ptr  8
.text$mn:00001508
.text$mn:00001508                 push    ebp
.text$mn:00001509                 mov     ebp, esp
.text$mn:0000150B                 push    ecx
.text$mn:0000150C                 mov     [ebp+var_4], ecx
.text$mn:0000150F                 mov     eax, [ebp+arg_0]
.text$mn:00001512                 push    eax
.text$mn:00001513                 mov     ecx, [ebp+var_4]
.text$mn:00001516                 call    ?allocate@?$allocator@D@std@@QAEPADI@Z ; std::allocator<char>::allocate(uint)
.text$mn:0000151B                 mov     esp, ebp
.text$mn:0000151D                 pop     ebp
.text$mn:0000151E                 retn    4
.text$mn:0000151E ?allocate@?$_Wrap_alloc@V?$allocator@D@std@@@std@@QAEPADI@Z endp
.text$mn:0000151E
.text$mn:0000151E ; ---------------------------------------------------------------------------
.text$mn:00001521                 align 4
.text$mn:00001521 _text$mn        ends
.text$mn:00001521
.text$mn:00001524 ; ===========================================================================
.text$mn:00001524
.text$mn:00001524 ; Segment type: Pure code
.text$mn:00001524 ; Segment permissions: Read/Execute
.text$mn:00001524 _text$mn        segment para public 'CODE' use32
.text$mn:00001524                 assume cs:_text$mn
.text$mn:00001524                 ;org 1524h
.text$mn:00001524 ; COMDAT (pick any)
.text$mn:00001524                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text$mn:00001524
.text$mn:00001524 ; =============== S U B R O U T I N E =======================================
.text$mn:00001524
.text$mn:00001524 ; Attributes: bp-based frame
.text$mn:00001524
.text$mn:00001524 ; public: char * __thiscall std::allocator<char>::allocate(unsigned int)
.text$mn:00001524                 public ?allocate@?$allocator@D@std@@QAEPADI@Z
.text$mn:00001524 ?allocate@?$allocator@D@std@@QAEPADI@Z proc near
.text$mn:00001524                                         ; CODE XREF: std::_Wrap_alloc<std::allocator<char>>::allocate(uint)+Ep
.text$mn:00001524
.text$mn:00001524 var_4           = dword ptr -4
.text$mn:00001524 arg_0           = dword ptr  8
.text$mn:00001524
.text$mn:00001524                 push    ebp
.text$mn:00001525                 mov     ebp, esp
.text$mn:00001527                 push    ecx
.text$mn:00001528                 mov     [ebp+var_4], ecx
.text$mn:0000152B                 push    0
.text$mn:0000152D                 mov     eax, [ebp+arg_0]
.text$mn:00001530                 push    eax
.text$mn:00001531                 call    ??$_Allocate@D@std@@YAPADIPAD@Z ; std::_Allocate<char>(uint,char *)
.text$mn:00001536                 add     esp, 8
.text$mn:00001539                 mov     esp, ebp
.text$mn:0000153B                 pop     ebp
.text$mn:0000153C                 retn    4
.text$mn:0000153C ?allocate@?$allocator@D@std@@QAEPADI@Z endp
.text$mn:0000153C
.text$mn:0000153C ; ---------------------------------------------------------------------------
.text$mn:0000153F                 align 10h
.text$mn:0000153F _text$mn        ends
.text$mn:0000153F
.text$mn:00001540 ; ===========================================================================
.text$mn:00001540
.text$mn:00001540 ; Segment type: Pure code
.text$mn:00001540 ; Segment permissions: Read/Execute
.text$mn:00001540 _text$mn        segment para public 'CODE' use32
.text$mn:00001540                 assume cs:_text$mn
.text$mn:00001540                 ;org 1540h
.text$mn:00001540 ; COMDAT (pick any)
.text$mn:00001540                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text$mn:00001540
.text$mn:00001540 ; =============== S U B R O U T I N E =======================================
.text$mn:00001540
.text$mn:00001540 ; Attributes: bp-based frame
.text$mn:00001540
.text$mn:00001540 ; public: struct std::_Container_proxy * __thiscall std::allocator<struct std::_Container_proxy>::allocate(unsigned int)
.text$mn:00001540                 public ?allocate@?$allocator@U_Container_proxy@std@@@std@@QAEPAU_Container_proxy@2@I@Z
.text$mn:00001540 ?allocate@?$allocator@U_Container_proxy@std@@@std@@QAEPAU_Container_proxy@2@I@Z proc near
.text$mn:00001540                                         ; CODE XREF: std::_String_alloc<0,std::_String_base_types<char,std::allocator<char>>>::_Alloc_proxy(void)+16p
.text$mn:00001540
.text$mn:00001540 var_4           = dword ptr -4
.text$mn:00001540 arg_0           = dword ptr  8
.text$mn:00001540
.text$mn:00001540                 push    ebp
.text$mn:00001541                 mov     ebp, esp
.text$mn:00001543                 push    ecx
.text$mn:00001544                 mov     [ebp+var_4], ecx
.text$mn:00001547                 push    0
.text$mn:00001549                 mov     eax, [ebp+arg_0]
.text$mn:0000154C                 push    eax
.text$mn:0000154D                 call    ??$_Allocate@U_Container_proxy@std@@@std@@YAPAU_Container_proxy@0@IPAU10@@Z ; std::_Allocate<std::_Container_proxy>(uint,std::_Container_proxy *)
.text$mn:00001552                 add     esp, 8
.text$mn:00001555                 mov     esp, ebp
.text$mn:00001557                 pop     ebp
.text$mn:00001558                 retn    4
.text$mn:00001558 ?allocate@?$allocator@U_Container_proxy@std@@@std@@QAEPAU_Container_proxy@2@I@Z endp
.text$mn:00001558
.text$mn:00001558 ; ---------------------------------------------------------------------------
.text$mn:0000155B                 align 4
.text$mn:0000155B _text$mn        ends
.text$mn:0000155B
.text$mn:0000155C ; ===========================================================================
.text$mn:0000155C
.text$mn:0000155C ; Segment type: Pure code
.text$mn:0000155C ; Segment permissions: Read/Execute
.text$mn:0000155C _text$mn        segment para public 'CODE' use32
.text$mn:0000155C                 assume cs:_text$mn
.text$mn:0000155C                 ;org 155Ch
.text$mn:0000155C ; COMDAT (pick any)
.text$mn:0000155C                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text$mn:0000155C
.text$mn:0000155C ; =============== S U B R O U T I N E =======================================
.text$mn:0000155C
.text$mn:0000155C ; Attributes: bp-based frame
.text$mn:0000155C
.text$mn:0000155C ; public: class std::basic_string<char, struct std::char_traits<char>, class std::allocator<char>> & __thiscall std::basic_string<char, struct std::char_traits<char>, class std::allocator<char>>::assign(class std::basic_string<char, struct std::char_traits<char>, class std::allocator<char>> const &, unsigned int, unsigned int)
.text$mn:0000155C                 public ?assign@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV12@ABV12@II@Z
.text$mn:0000155C ?assign@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV12@ABV12@II@Z proc near
.text$mn:0000155C                                         ; CODE XREF: std::basic_string<char,std::char_traits<char>,std::allocator<char>>::assign(char const *,uint)+4Fp
.text$mn:0000155C
.text$mn:0000155C Size            = dword ptr -8
.text$mn:0000155C var_4           = dword ptr -4
.text$mn:0000155C arg_0           = dword ptr  8
.text$mn:0000155C arg_4           = dword ptr  0Ch
.text$mn:0000155C arg_8           = dword ptr  10h
.text$mn:0000155C
.text$mn:0000155C                 push    ebp
.text$mn:0000155D                 mov     ebp, esp
.text$mn:0000155F                 sub     esp, 8
.text$mn:00001562                 mov     [ebp+var_4], ecx
.text$mn:00001565                 mov     ecx, [ebp+arg_0]
.text$mn:00001568                 call    ?size@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QBEIXZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char>>::size(void)
.text$mn:0000156D                 cmp     eax, [ebp+arg_4]
.text$mn:00001570                 jnb     short loc_157A
.text$mn:00001572                 mov     ecx, [ebp+var_4]
.text$mn:00001575                 call    ?_Xran@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QBEXXZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char>>::_Xran(void)
.text$mn:0000157A
.text$mn:0000157A loc_157A:                               ; CODE XREF: std::basic_string<char,std::char_traits<char>,std::allocator<char>>::assign(std::basic_string<char,std::char_traits<char>,std::allocator<char>> const &,uint,uint)+14j
.text$mn:0000157A                 mov     ecx, [ebp+arg_0]
.text$mn:0000157D                 call    ?size@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QBEIXZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char>>::size(void)
.text$mn:00001582                 sub     eax, [ebp+arg_4]
.text$mn:00001585                 mov     [ebp+Size], eax
.text$mn:00001588                 mov     eax, [ebp+arg_8]
.text$mn:0000158B                 cmp     eax, [ebp+Size]
.text$mn:0000158E                 jnb     short loc_1596
.text$mn:00001590                 mov     ecx, [ebp+arg_8]
.text$mn:00001593                 mov     [ebp+Size], ecx
.text$mn:00001596
.text$mn:00001596 loc_1596:                               ; CODE XREF: std::basic_string<char,std::char_traits<char>,std::allocator<char>>::assign(std::basic_string<char,std::char_traits<char>,std::allocator<char>> const &,uint,uint)+32j
.text$mn:00001596                 mov     edx, [ebp+var_4]
.text$mn:00001599                 cmp     edx, [ebp+arg_0]
.text$mn:0000159C                 jnz     short loc_15BD
.text$mn:0000159E                 mov     eax, [ebp+arg_4]
.text$mn:000015A1                 add     eax, [ebp+Size]
.text$mn:000015A4                 push    eax
.text$mn:000015A5                 mov     ecx, [ebp+var_4]
.text$mn:000015A8                 call    ?erase@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV12@I@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char>>::erase(uint)
.text$mn:000015AD                 mov     ecx, [ebp+arg_4]
.text$mn:000015B0                 push    ecx
.text$mn:000015B1                 push    0
.text$mn:000015B3                 mov     ecx, [ebp+var_4]
.text$mn:000015B6                 call    ?erase@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV12@II@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char>>::erase(uint,uint)
.text$mn:000015BB                 jmp     short loc_15FF
.text$mn:000015BD ; ---------------------------------------------------------------------------
.text$mn:000015BD
.text$mn:000015BD loc_15BD:                               ; CODE XREF: std::basic_string<char,std::char_traits<char>,std::allocator<char>>::assign(std::basic_string<char,std::char_traits<char>,std::allocator<char>> const &,uint,uint)+40j
.text$mn:000015BD                 push    0
.text$mn:000015BF                 mov     edx, [ebp+Size]
.text$mn:000015C2                 push    edx
.text$mn:000015C3                 mov     ecx, [ebp+var_4]
.text$mn:000015C6                 call    ?_Grow@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE_NI_N@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char>>::_Grow(uint,bool)
.text$mn:000015CB                 movzx   eax, al
.text$mn:000015CE                 test    eax, eax
.text$mn:000015D0                 jz      short loc_15FF
.text$mn:000015D2                 mov     ecx, [ebp+Size]
.text$mn:000015D5                 push    ecx             ; Size
.text$mn:000015D6                 mov     ecx, [ebp+arg_0]
.text$mn:000015D9                 call    ?_Myptr@?$_String_val@U?$_Simple_types@D@std@@@std@@QBEPBDXZ ; std::_String_val<std::_Simple_types<char>>::_Myptr(void)
.text$mn:000015DE                 add     eax, [ebp+arg_4]
.text$mn:000015E1                 push    eax             ; Src
.text$mn:000015E2                 mov     ecx, [ebp+var_4]
.text$mn:000015E5                 call    ?_Myptr@?$_String_val@U?$_Simple_types@D@std@@@std@@QAEPADXZ ; std::_String_val<std::_Simple_types<char>>::_Myptr(void)
.text$mn:000015EA                 push    eax             ; Dst
.text$mn:000015EB                 call    ?copy@?$char_traits@D@std@@SAPADPADPBDI@Z ; std::char_traits<char>::copy(char *,char const *,uint)
.text$mn:000015F0                 add     esp, 0Ch
.text$mn:000015F3                 mov     edx, [ebp+Size]
.text$mn:000015F6                 push    edx
.text$mn:000015F7                 mov     ecx, [ebp+var_4]
.text$mn:000015FA                 call    ?_Eos@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEXI@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char>>::_Eos(uint)
.text$mn:000015FF
.text$mn:000015FF loc_15FF:                               ; CODE XREF: std::basic_string<char,std::char_traits<char>,std::allocator<char>>::assign(std::basic_string<char,std::char_traits<char>,std::allocator<char>> const &,uint,uint)+5Fj
.text$mn:000015FF                                         ; std::basic_string<char,std::char_traits<char>,std::allocator<char>>::assign(std::basic_string<char,std::char_traits<char>,std::allocator<char>> const &,uint,uint)+74j
.text$mn:000015FF                 mov     eax, [ebp+var_4]
.text$mn:00001602                 mov     esp, ebp
.text$mn:00001604                 pop     ebp
.text$mn:00001605                 retn    0Ch
.text$mn:00001605 ?assign@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV12@ABV12@II@Z endp
.text$mn:00001605
.text$mn:00001605 _text$mn        ends
.text$mn:00001605
.text$mn:00001608 ; ===========================================================================
.text$mn:00001608
.text$mn:00001608 ; Segment type: Pure code
.text$mn:00001608 ; Segment permissions: Read/Execute
.text$mn:00001608 _text$mn        segment para public 'CODE' use32
.text$mn:00001608                 assume cs:_text$mn
.text$mn:00001608                 ;org 1608h
.text$mn:00001608 ; COMDAT (pick any)
.text$mn:00001608                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text$mn:00001608
.text$mn:00001608 ; =============== S U B R O U T I N E =======================================
.text$mn:00001608
.text$mn:00001608 ; Attributes: bp-based frame
.text$mn:00001608
.text$mn:00001608 ; int __stdcall std::basic_string<char,std::char_traits<char>,std::allocator<char>>::assign(char *Str)
.text$mn:00001608                 public ?assign@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV12@PBD@Z
.text$mn:00001608 ?assign@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV12@PBD@Z proc near
.text$mn:00001608                                         ; CODE XREF: std::basic_string<char,std::char_traits<char>,std::allocator<char>>::basic_string<char,std::char_traits<char>,std::allocator<char>>(char const *)+53p
.text$mn:00001608
.text$mn:00001608 var_4           = dword ptr -4
.text$mn:00001608 Str             = dword ptr  8
.text$mn:00001608
.text$mn:00001608                 push    ebp
.text$mn:00001609                 mov     ebp, esp
.text$mn:0000160B                 push    ecx
.text$mn:0000160C                 mov     [ebp+var_4], ecx
.text$mn:0000160F                 push    490h            ; unsigned int
.text$mn:00001614                 push    offset ??_C@_1IO@FEAPGJBD@?$AAC?$AA?3?$AA?2?$AAP?$AAr?$AAo?$AAg?$AAr?$AAa?$AAm?$AA?5?$AAF?$AAi?$AAl?$AAe?$AAs?$AA?5?$AA?$CI?$AAx?$AA8?$AA6?$AA?$CJ?$AA?2?$AAM?$AAi?$AAc?$AAr?$AAo?$AAs?$AAo?$AAf?$AAt@ ; "C:\\Program Files (x86)\\Microsoft Visu"...
.text$mn:00001619                 mov     eax, [ebp+Str]
.text$mn:0000161C                 push    eax             ; int
.text$mn:0000161D                 call    ??$_Debug_pointer@D@std@@YAXPBDPB_WI@Z ; std::_Debug_pointer<char>(char const *,wchar_t const *,uint)
.text$mn:00001622                 add     esp, 0Ch
.text$mn:00001625                 mov     ecx, [ebp+Str]
.text$mn:00001628                 push    ecx             ; Str
.text$mn:00001629                 call    ?length@?$char_traits@D@std@@SAIPBD@Z ; std::char_traits<char>::length(char const *)
.text$mn:0000162E                 add     esp, 4
.text$mn:00001631                 push    eax             ; Size
.text$mn:00001632                 mov     edx, [ebp+Str]
.text$mn:00001635                 push    edx             ; Src
.text$mn:00001636                 mov     ecx, [ebp+var_4]
.text$mn:00001639                 call    ?assign@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV12@PBDI@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char>>::assign(char const *,uint)
.text$mn:0000163E                 mov     esp, ebp
.text$mn:00001640                 pop     ebp
.text$mn:00001641                 retn    4
.text$mn:00001641 ?assign@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV12@PBD@Z endp
.text$mn:00001641
.text$mn:00001641 _text$mn        ends
.text$mn:00001641
.text$mn:00001644 ; ===========================================================================
.text$mn:00001644
.text$mn:00001644 ; Segment type: Pure code
.text$mn:00001644 ; Segment permissions: Read/Execute
.text$mn:00001644 _text$mn        segment para public 'CODE' use32
.text$mn:00001644                 assume cs:_text$mn
.text$mn:00001644                 ;org 1644h
.text$mn:00001644 ; COMDAT (pick any)
.text$mn:00001644                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text$mn:00001644
.text$mn:00001644 ; =============== S U B R O U T I N E =======================================
.text$mn:00001644
.text$mn:00001644 ; Attributes: bp-based frame
.text$mn:00001644
.text$mn:00001644 ; int __stdcall std::basic_string<char,std::char_traits<char>,std::allocator<char>>::assign(void *Src, size_t Size)
.text$mn:00001644                 public ?assign@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV12@PBDI@Z
.text$mn:00001644 ?assign@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV12@PBDI@Z proc near
.text$mn:00001644                                         ; CODE XREF: std::basic_string<char,std::char_traits<char>,std::allocator<char>>::assign(char const *)+31p
.text$mn:00001644
.text$mn:00001644 var_4           = dword ptr -4
.text$mn:00001644 Src             = dword ptr  8
.text$mn:00001644 Size            = dword ptr  0Ch
.text$mn:00001644
.text$mn:00001644                 push    ebp
.text$mn:00001645                 mov     ebp, esp
.text$mn:00001647                 push    ecx
.text$mn:00001648                 mov     [ebp+var_4], ecx
.text$mn:0000164B                 cmp     [ebp+Size], 0
.text$mn:0000164F                 jz      short loc_1667
.text$mn:00001651                 push    47Fh            ; unsigned int
.text$mn:00001656                 push    offset ??_C@_1IO@FEAPGJBD@?$AAC?$AA?3?$AA?2?$AAP?$AAr?$AAo?$AAg?$AAr?$AAa?$AAm?$AA?5?$AAF?$AAi?$AAl?$AAe?$AAs?$AA?5?$AA?$CI?$AAx?$AA8?$AA6?$AA?$CJ?$AA?2?$AAM?$AAi?$AAc?$AAr?$AAo?$AAs?$AAo?$AAf?$AAt@ ; "C:\\Program Files (x86)\\Microsoft Visu"...
.text$mn:0000165B                 mov     eax, [ebp+Src]
.text$mn:0000165E                 push    eax             ; int
.text$mn:0000165F                 call    ??$_Debug_pointer@D@std@@YAXPBDPB_WI@Z ; std::_Debug_pointer<char>(char const *,wchar_t const *,uint)
.text$mn:00001664                 add     esp, 0Ch
.text$mn:00001667
.text$mn:00001667 loc_1667:                               ; CODE XREF: std::basic_string<char,std::char_traits<char>,std::allocator<char>>::assign(char const *,uint)+Bj
.text$mn:00001667                 mov     ecx, [ebp+Src]
.text$mn:0000166A                 push    ecx
.text$mn:0000166B                 mov     ecx, [ebp+var_4]
.text$mn:0000166E                 call    ?_Inside@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE_NPBD@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char>>::_Inside(char const *)
.text$mn:00001673                 movzx   edx, al
.text$mn:00001676                 test    edx, edx
.text$mn:00001678                 jz      short loc_169A
.text$mn:0000167A                 mov     eax, [ebp+Size]
.text$mn:0000167D                 push    eax
.text$mn:0000167E                 mov     ecx, [ebp+var_4]
.text$mn:00001681                 call    ?_Myptr@?$_String_val@U?$_Simple_types@D@std@@@std@@QAEPADXZ ; std::_String_val<std::_Simple_types<char>>::_Myptr(void)
.text$mn:00001686                 mov     ecx, [ebp+Src]
.text$mn:00001689                 sub     ecx, eax
.text$mn:0000168B                 push    ecx
.text$mn:0000168C                 mov     edx, [ebp+var_4]
.text$mn:0000168F                 push    edx
.text$mn:00001690                 mov     ecx, [ebp+var_4]
.text$mn:00001693                 call    ?assign@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV12@ABV12@II@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char>>::assign(std::basic_string<char,std::char_traits<char>,std::allocator<char>> const &,uint,uint)
.text$mn:00001698                 jmp     short loc_16D7
.text$mn:0000169A ; ---------------------------------------------------------------------------
.text$mn:0000169A
.text$mn:0000169A loc_169A:                               ; CODE XREF: std::basic_string<char,std::char_traits<char>,std::allocator<char>>::assign(char const *,uint)+34j
.text$mn:0000169A                 push    0
.text$mn:0000169C                 mov     eax, [ebp+Size]
.text$mn:0000169F                 push    eax
.text$mn:000016A0                 mov     ecx, [ebp+var_4]
.text$mn:000016A3                 call    ?_Grow@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE_NI_N@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char>>::_Grow(uint,bool)
.text$mn:000016A8                 movzx   ecx, al
.text$mn:000016AB                 test    ecx, ecx
.text$mn:000016AD                 jz      short loc_16D4
.text$mn:000016AF                 mov     edx, [ebp+Size]
.text$mn:000016B2                 push    edx             ; Size
.text$mn:000016B3                 mov     eax, [ebp+Src]
.text$mn:000016B6                 push    eax             ; Src
.text$mn:000016B7                 mov     ecx, [ebp+var_4]
.text$mn:000016BA                 call    ?_Myptr@?$_String_val@U?$_Simple_types@D@std@@@std@@QAEPADXZ ; std::_String_val<std::_Simple_types<char>>::_Myptr(void)
.text$mn:000016BF                 push    eax             ; Dst
.text$mn:000016C0                 call    ?copy@?$char_traits@D@std@@SAPADPADPBDI@Z ; std::char_traits<char>::copy(char *,char const *,uint)
.text$mn:000016C5                 add     esp, 0Ch
.text$mn:000016C8                 mov     ecx, [ebp+Size]
.text$mn:000016CB                 push    ecx
.text$mn:000016CC                 mov     ecx, [ebp+var_4]
.text$mn:000016CF                 call    ?_Eos@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEXI@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char>>::_Eos(uint)
.text$mn:000016D4
.text$mn:000016D4 loc_16D4:                               ; CODE XREF: std::basic_string<char,std::char_traits<char>,std::allocator<char>>::assign(char const *,uint)+69j
.text$mn:000016D4                 mov     eax, [ebp+var_4]
.text$mn:000016D7
.text$mn:000016D7 loc_16D7:                               ; CODE XREF: std::basic_string<char,std::char_traits<char>,std::allocator<char>>::assign(char const *,uint)+54j
.text$mn:000016D7                 mov     esp, ebp
.text$mn:000016D9                 pop     ebp
.text$mn:000016DA                 retn    8
.text$mn:000016DA ?assign@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV12@PBDI@Z endp
.text$mn:000016DA
.text$mn:000016DA ; ---------------------------------------------------------------------------
.text$mn:000016DD                 align 10h
.text$mn:000016DD _text$mn        ends
.text$mn:000016DD
.text$mn:000016E0 ; ===========================================================================
.text$mn:000016E0
.text$mn:000016E0 ; Segment type: Pure code
.text$mn:000016E0 ; Segment permissions: Read/Execute
.text$mn:000016E0 _text$mn        segment para public 'CODE' use32
.text$mn:000016E0                 assume cs:_text$mn
.text$mn:000016E0                 ;org 16E0h
.text$mn:000016E0 ; COMDAT (pick any)
.text$mn:000016E0                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text$mn:000016E0
.text$mn:000016E0 ; =============== S U B R O U T I N E =======================================
.text$mn:000016E0
.text$mn:000016E0 ; Attributes: bp-based frame
.text$mn:000016E0
.text$mn:000016E0 ; public: static void __cdecl std::char_traits<char>::assign(char &, char const &)
.text$mn:000016E0                 public ?assign@?$char_traits@D@std@@SAXAADABD@Z
.text$mn:000016E0 ?assign@?$char_traits@D@std@@SAXAADABD@Z proc near
.text$mn:000016E0                                         ; CODE XREF: std::basic_string<char,std::char_traits<char>,std::allocator<char>>::_Eos(uint)+26p
.text$mn:000016E0
.text$mn:000016E0 arg_0           = dword ptr  8
.text$mn:000016E0 arg_4           = dword ptr  0Ch
.text$mn:000016E0
.text$mn:000016E0                 push    ebp
.text$mn:000016E1                 mov     ebp, esp
.text$mn:000016E3                 mov     eax, [ebp+arg_0]
.text$mn:000016E6                 mov     ecx, [ebp+arg_4]
.text$mn:000016E9                 mov     dl, [ecx]
.text$mn:000016EB                 mov     [eax], dl
.text$mn:000016ED                 pop     ebp
.text$mn:000016EE                 retn
.text$mn:000016EE ?assign@?$char_traits@D@std@@SAXAADABD@Z endp
.text$mn:000016EE
.text$mn:000016EE ; ---------------------------------------------------------------------------
.text$mn:000016EF                 align 10h
.text$mn:000016EF _text$mn        ends
.text$mn:000016EF
.text$mn:000016F0 ; ===========================================================================
.text$mn:000016F0
.text$mn:000016F0 ; Segment type: Pure code
.text$mn:000016F0 ; Segment permissions: Read/Execute
.text$mn:000016F0 _text$mn        segment para public 'CODE' use32
.text$mn:000016F0                 assume cs:_text$mn
.text$mn:000016F0                 ;org 16F0h
.text$mn:000016F0 ; COMDAT (pick any)
.text$mn:000016F0                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text$mn:000016F0
.text$mn:000016F0 ; =============== S U B R O U T I N E =======================================
.text$mn:000016F0
.text$mn:000016F0 ; Attributes: bp-based frame
.text$mn:000016F0
.text$mn:000016F0 ; const struct std::error_category *__thiscall std::error_code::category(std::error_code *__hidden this)
.text$mn:000016F0                 public ?category@error_code@std@@QBEABVerror_category@2@XZ
.text$mn:000016F0 ?category@error_code@std@@QBEABVerror_category@2@XZ proc near
.text$mn:000016F0                                         ; CODE XREF: std::error_category::equivalent(std::error_code const &,int)+Cp
.text$mn:000016F0
.text$mn:000016F0 var_4           = dword ptr -4
.text$mn:000016F0
.text$mn:000016F0                 push    ebp
.text$mn:000016F1                 mov     ebp, esp
.text$mn:000016F3                 push    ecx
.text$mn:000016F4                 mov     [ebp+var_4], ecx
.text$mn:000016F7                 mov     eax, [ebp+var_4]
.text$mn:000016FA                 mov     eax, [eax+4]
.text$mn:000016FD                 mov     esp, ebp
.text$mn:000016FF                 pop     ebp
.text$mn:00001700                 retn
.text$mn:00001700 ?category@error_code@std@@QBEABVerror_category@2@XZ endp
.text$mn:00001700
.text$mn:00001700 ; ---------------------------------------------------------------------------
.text$mn:00001701                 align 4
.text$mn:00001701 _text$mn        ends
.text$mn:00001701
.text$mn:00001704 ; ===========================================================================
.text$mn:00001704
.text$mn:00001704 ; Segment type: Pure code
.text$mn:00001704 ; Segment permissions: Read/Execute
.text$mn:00001704 _text$mn        segment para public 'CODE' use32
.text$mn:00001704                 assume cs:_text$mn
.text$mn:00001704                 ;org 1704h
.text$mn:00001704 ; COMDAT (pick any)
.text$mn:00001704                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text$mn:00001704
.text$mn:00001704 ; =============== S U B R O U T I N E =======================================
.text$mn:00001704
.text$mn:00001704 ; Attributes: bp-based frame
.text$mn:00001704
.text$mn:00001704 ; const struct std::error_category *__thiscall std::error_condition::category(std::error_condition *__hidden this)
.text$mn:00001704                 public ?category@error_condition@std@@QBEABVerror_category@2@XZ
.text$mn:00001704 ?category@error_condition@std@@QBEABVerror_category@2@XZ proc near
.text$mn:00001704                                         ; CODE XREF: std::error_condition::operator==(std::error_condition const &)+Dp
.text$mn:00001704                                         ; std::error_condition::operator==(std::error_condition const &)+16p
.text$mn:00001704
.text$mn:00001704 var_4           = dword ptr -4
.text$mn:00001704
.text$mn:00001704                 push    ebp
.text$mn:00001705                 mov     ebp, esp
.text$mn:00001707                 push    ecx
.text$mn:00001708                 mov     [ebp+var_4], ecx
.text$mn:0000170B                 mov     eax, [ebp+var_4]
.text$mn:0000170E                 mov     eax, [eax+4]
.text$mn:00001711                 mov     esp, ebp
.text$mn:00001713                 pop     ebp
.text$mn:00001714                 retn
.text$mn:00001714 ?category@error_condition@std@@QBEABVerror_category@2@XZ endp
.text$mn:00001714
.text$mn:00001714 ; ---------------------------------------------------------------------------
.text$mn:00001715                 align 4
.text$mn:00001715 _text$mn        ends
.text$mn:00001715
.text$mn:00001718 ; ===========================================================================
.text$mn:00001718
.text$mn:00001718 ; Segment type: Pure code
.text$mn:00001718 ; Segment permissions: Read/Execute
.text$mn:00001718 _text$mn        segment para public 'CODE' use32
.text$mn:00001718                 assume cs:_text$mn
.text$mn:00001718                 ;org 1718h
.text$mn:00001718 ; COMDAT (pick any)
.text$mn:00001718                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text$mn:00001718
.text$mn:00001718 ; =============== S U B R O U T I N E =======================================
.text$mn:00001718
.text$mn:00001718 ; Attributes: bp-based frame
.text$mn:00001718
.text$mn:00001718 ; int __cdecl std::char_traits<char>::copy(void *Dst, void *Src, size_t Size)
.text$mn:00001718                 public ?copy@?$char_traits@D@std@@SAPADPADPBDI@Z
.text$mn:00001718 ?copy@?$char_traits@D@std@@SAPADPADPBDI@Z proc near ; CODE XREF: $LN19+1Ep
.text$mn:00001718                                         ; std::basic_string<char,std::char_traits<char>,std::allocator<char>>::_Tidy(bool,uint)+5Dp ...
.text$mn:00001718
.text$mn:00001718 var_4           = dword ptr -4
.text$mn:00001718 Dst             = dword ptr  8
.text$mn:00001718 Src             = dword ptr  0Ch
.text$mn:00001718 Size            = dword ptr  10h
.text$mn:00001718
.text$mn:00001718                 push    ebp
.text$mn:00001719                 mov     ebp, esp
.text$mn:0000171B                 push    ecx
.text$mn:0000171C                 cmp     [ebp+Size], 0
.text$mn:00001720                 jnz     short loc_172A
.text$mn:00001722                 mov     eax, [ebp+Dst]
.text$mn:00001725                 mov     [ebp+var_4], eax
.text$mn:00001728                 jmp     short loc_1741
.text$mn:0000172A ; ---------------------------------------------------------------------------
.text$mn:0000172A
.text$mn:0000172A loc_172A:                               ; CODE XREF: std::char_traits<char>::copy(char *,char const *,uint)+8j
.text$mn:0000172A                 mov     ecx, [ebp+Size]
.text$mn:0000172D                 push    ecx             ; Size
.text$mn:0000172E                 mov     edx, [ebp+Src]
.text$mn:00001731                 push    edx             ; Src
.text$mn:00001732                 mov     eax, [ebp+Dst]
.text$mn:00001735                 push    eax             ; Dst
.text$mn:00001736                 call    _memcpy
.text$mn:0000173B                 add     esp, 0Ch
.text$mn:0000173E                 mov     [ebp+var_4], eax
.text$mn:00001741
.text$mn:00001741 loc_1741:                               ; CODE XREF: std::char_traits<char>::copy(char *,char const *,uint)+10j
.text$mn:00001741                 mov     eax, [ebp+var_4]
.text$mn:00001744                 mov     esp, ebp
.text$mn:00001746                 pop     ebp
.text$mn:00001747                 retn
.text$mn:00001747 ?copy@?$char_traits@D@std@@SAPADPADPBDI@Z endp
.text$mn:00001747
.text$mn:00001747 _text$mn        ends
.text$mn:00001747
.text$mn:00001748 ; ===========================================================================
.text$mn:00001748
.text$mn:00001748 ; Segment type: Pure code
.text$mn:00001748 ; Segment permissions: Read/Execute
.text$mn:00001748 _text$mn        segment para public 'CODE' use32
.text$mn:00001748                 assume cs:_text$mn
.text$mn:00001748                 ;org 1748h
.text$mn:00001748 ; COMDAT (pick any)
.text$mn:00001748                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text$mn:00001748
.text$mn:00001748 ; =============== S U B R O U T I N E =======================================
.text$mn:00001748
.text$mn:00001748 ; Attributes: bp-based frame
.text$mn:00001748
.text$mn:00001748 ; int __stdcall std::_Wrap_alloc<std::allocator<char>>::deallocate(void *, int)
.text$mn:00001748                 public ?deallocate@?$_Wrap_alloc@V?$allocator@D@std@@@std@@QAEXPADI@Z
.text$mn:00001748 ?deallocate@?$_Wrap_alloc@V?$allocator@D@std@@@std@@QAEXPADI@Z proc near
.text$mn:00001748                                         ; CODE XREF: std::basic_string<char,std::char_traits<char>,std::allocator<char>>::_Tidy(bool,uint)+81p
.text$mn:00001748
.text$mn:00001748 var_4           = dword ptr -4
.text$mn:00001748 arg_0           = dword ptr  8
.text$mn:00001748 arg_4           = dword ptr  0Ch
.text$mn:00001748
.text$mn:00001748                 push    ebp
.text$mn:00001749                 mov     ebp, esp
.text$mn:0000174B                 push    ecx
.text$mn:0000174C                 mov     [ebp+var_4], ecx
.text$mn:0000174F                 mov     eax, [ebp+arg_4]
.text$mn:00001752                 push    eax             ; int
.text$mn:00001753                 mov     ecx, [ebp+arg_0]
.text$mn:00001756                 push    ecx             ; void *
.text$mn:00001757                 mov     ecx, [ebp+var_4]
.text$mn:0000175A                 call    ?deallocate@?$allocator@D@std@@QAEXPADI@Z ; std::allocator<char>::deallocate(char *,uint)
.text$mn:0000175F                 mov     esp, ebp
.text$mn:00001761                 pop     ebp
.text$mn:00001762                 retn    8
.text$mn:00001762 ?deallocate@?$_Wrap_alloc@V?$allocator@D@std@@@std@@QAEXPADI@Z endp
.text$mn:00001762
.text$mn:00001762 ; ---------------------------------------------------------------------------
.text$mn:00001765                 align 4
.text$mn:00001765 _text$mn        ends
.text$mn:00001765
.text$mn:00001768 ; ===========================================================================
.text$mn:00001768
.text$mn:00001768 ; Segment type: Pure code
.text$mn:00001768 ; Segment permissions: Read/Execute
.text$mn:00001768 _text$mn        segment para public 'CODE' use32
.text$mn:00001768                 assume cs:_text$mn
.text$mn:00001768                 ;org 1768h
.text$mn:00001768 ; COMDAT (pick any)
.text$mn:00001768                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text$mn:00001768
.text$mn:00001768 ; =============== S U B R O U T I N E =======================================
.text$mn:00001768
.text$mn:00001768 ; Attributes: bp-based frame
.text$mn:00001768
.text$mn:00001768 ; int __stdcall std::allocator<char>::deallocate(void *, int)
.text$mn:00001768                 public ?deallocate@?$allocator@D@std@@QAEXPADI@Z
.text$mn:00001768 ?deallocate@?$allocator@D@std@@QAEXPADI@Z proc near
.text$mn:00001768                                         ; CODE XREF: std::_Wrap_alloc<std::allocator<char>>::deallocate(char *,uint)+12p
.text$mn:00001768
.text$mn:00001768 var_4           = dword ptr -4
.text$mn:00001768 arg_0           = dword ptr  8
.text$mn:00001768
.text$mn:00001768                 push    ebp
.text$mn:00001769                 mov     ebp, esp
.text$mn:0000176B                 push    ecx
.text$mn:0000176C                 mov     [ebp+var_4], ecx
.text$mn:0000176F                 mov     eax, [ebp+arg_0]
.text$mn:00001772                 push    eax             ; void *
.text$mn:00001773                 call    ??3@YAXPAX@Z    ; operator delete(void *)
.text$mn:00001778                 add     esp, 4
.text$mn:0000177B                 mov     esp, ebp
.text$mn:0000177D                 pop     ebp
.text$mn:0000177E                 retn    8
.text$mn:0000177E ?deallocate@?$allocator@D@std@@QAEXPADI@Z endp
.text$mn:0000177E
.text$mn:0000177E ; ---------------------------------------------------------------------------
.text$mn:00001781                 align 4
.text$mn:00001781 _text$mn        ends
.text$mn:00001781
.text$mn:00001784 ; ===========================================================================
.text$mn:00001784
.text$mn:00001784 ; Segment type: Pure code
.text$mn:00001784 ; Segment permissions: Read/Execute
.text$mn:00001784 _text$mn        segment para public 'CODE' use32
.text$mn:00001784                 assume cs:_text$mn
.text$mn:00001784                 ;org 1784h
.text$mn:00001784 ; COMDAT (pick any)
.text$mn:00001784                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text$mn:00001784
.text$mn:00001784 ; =============== S U B R O U T I N E =======================================
.text$mn:00001784
.text$mn:00001784 ; Attributes: bp-based frame
.text$mn:00001784
.text$mn:00001784 ; int __stdcall std::allocator<std::_Container_proxy>::deallocate(void *, int)
.text$mn:00001784                 public ?deallocate@?$allocator@U_Container_proxy@std@@@std@@QAEXPAU_Container_proxy@2@I@Z
.text$mn:00001784 ?deallocate@?$allocator@U_Container_proxy@std@@@std@@QAEXPAU_Container_proxy@2@I@Z proc near
.text$mn:00001784                                         ; CODE XREF: std::_String_alloc<0,std::_String_base_types<char,std::allocator<char>>>::_Free_proxy(void)+32p
.text$mn:00001784
.text$mn:00001784 var_4           = dword ptr -4
.text$mn:00001784 arg_0           = dword ptr  8
.text$mn:00001784
.text$mn:00001784                 push    ebp
.text$mn:00001785                 mov     ebp, esp
.text$mn:00001787                 push    ecx
.text$mn:00001788                 mov     [ebp+var_4], ecx
.text$mn:0000178B                 mov     eax, [ebp+arg_0]
.text$mn:0000178E                 push    eax             ; void *
.text$mn:0000178F                 call    ??3@YAXPAX@Z    ; operator delete(void *)
.text$mn:00001794                 add     esp, 4
.text$mn:00001797                 mov     esp, ebp
.text$mn:00001799                 pop     ebp
.text$mn:0000179A                 retn    8
.text$mn:0000179A ?deallocate@?$allocator@U_Container_proxy@std@@@std@@QAEXPAU_Container_proxy@2@I@Z endp
.text$mn:0000179A
.text$mn:0000179A ; ---------------------------------------------------------------------------
.text$mn:0000179D                 align 10h
.text$mn:0000179D _text$mn        ends
.text$mn:0000179D
.text$mn:000017A0 ; ===========================================================================
.text$mn:000017A0
.text$mn:000017A0 ; Segment type: Pure code
.text$mn:000017A0 ; Segment permissions: Read/Execute
.text$mn:000017A0 _text$mn        segment para public 'CODE' use32
.text$mn:000017A0                 assume cs:_text$mn
.text$mn:000017A0                 ;org 17A0h
.text$mn:000017A0 ; COMDAT (pick any)
.text$mn:000017A0                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text$mn:000017A0
.text$mn:000017A0 ; =============== S U B R O U T I N E =======================================
.text$mn:000017A0
.text$mn:000017A0 ; Attributes: bp-based frame
.text$mn:000017A0
.text$mn:000017A0 ; public: virtual class std::error_condition __thiscall std::_System_error_category::default_error_condition(int)const
.text$mn:000017A0                 public ?default_error_condition@_System_error_category@std@@UBE?AVerror_condition@2@H@Z
.text$mn:000017A0 ?default_error_condition@_System_error_category@std@@UBE?AVerror_condition@2@H@Z proc near
.text$mn:000017A0                                         ; DATA XREF: .rdata:0000229Co
.text$mn:000017A0
.text$mn:000017A0 var_4           = dword ptr -4
.text$mn:000017A0 arg_0           = dword ptr  8
.text$mn:000017A0 arg_4           = dword ptr  0Ch
.text$mn:000017A0
.text$mn:000017A0                 push    ebp
.text$mn:000017A1                 mov     ebp, esp
.text$mn:000017A3                 push    ecx
.text$mn:000017A4                 mov     [ebp+var_4], ecx
.text$mn:000017A7                 mov     eax, [ebp+arg_4]
.text$mn:000017AA                 push    eax             ; int
.text$mn:000017AB                 call    ?_Syserror_map@std@@YAPBDH@Z ; std::_Syserror_map(int)
.text$mn:000017B0                 add     esp, 4
.text$mn:000017B3                 test    eax, eax
.text$mn:000017B5                 jz      short loc_17D0
.text$mn:000017B7                 call    ?generic_category@std@@YAABVerror_category@1@XZ ; std::generic_category(void)
.text$mn:000017BC                 push    eax             ; struct std::error_category *
.text$mn:000017BD                 mov     ecx, [ebp+arg_4]
.text$mn:000017C0                 push    ecx             ; int
.text$mn:000017C1                 mov     ecx, [ebp+arg_0] ; this
.text$mn:000017C4                 call    ??0error_condition@std@@QAE@HABVerror_category@1@@Z ; std::error_condition::error_condition(int,std::error_category const &)
.text$mn:000017C9                 mov     eax, [ebp+arg_0]
.text$mn:000017CC                 jmp     short loc_17E5
.text$mn:000017CE ; ---------------------------------------------------------------------------
.text$mn:000017CE                 jmp     short loc_17E5
.text$mn:000017D0 ; ---------------------------------------------------------------------------
.text$mn:000017D0
.text$mn:000017D0 loc_17D0:                               ; CODE XREF: std::_System_error_category::default_error_condition(int)+15j
.text$mn:000017D0                 call    ?system_category@std@@YAABVerror_category@1@XZ ; std::system_category(void)
.text$mn:000017D5                 push    eax             ; struct std::error_category *
.text$mn:000017D6                 mov     edx, [ebp+arg_4]
.text$mn:000017D9                 push    edx             ; int
.text$mn:000017DA                 mov     ecx, [ebp+arg_0] ; this
.text$mn:000017DD                 call    ??0error_condition@std@@QAE@HABVerror_category@1@@Z ; std::error_condition::error_condition(int,std::error_category const &)
.text$mn:000017E2                 mov     eax, [ebp+arg_0]
.text$mn:000017E5
.text$mn:000017E5 loc_17E5:                               ; CODE XREF: std::_System_error_category::default_error_condition(int)+2Cj
.text$mn:000017E5                                         ; std::_System_error_category::default_error_condition(int)+2Ej
.text$mn:000017E5                 mov     esp, ebp
.text$mn:000017E7                 pop     ebp
.text$mn:000017E8                 retn    8
.text$mn:000017E8 ?default_error_condition@_System_error_category@std@@UBE?AVerror_condition@2@H@Z endp
.text$mn:000017E8
.text$mn:000017E8 ; ---------------------------------------------------------------------------
.text$mn:000017EB                 align 4
.text$mn:000017EB _text$mn        ends
.text$mn:000017EB
.text$mn:000017EC ; ===========================================================================
.text$mn:000017EC
.text$mn:000017EC ; Segment type: Pure code
.text$mn:000017EC ; Segment permissions: Read/Execute
.text$mn:000017EC _text$mn        segment para public 'CODE' use32
.text$mn:000017EC                 assume cs:_text$mn
.text$mn:000017EC                 ;org 17ECh
.text$mn:000017EC ; COMDAT (pick any)
.text$mn:000017EC                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text$mn:000017EC
.text$mn:000017EC ; =============== S U B R O U T I N E =======================================
.text$mn:000017EC
.text$mn:000017EC ; Attributes: bp-based frame
.text$mn:000017EC
.text$mn:000017EC ; public: virtual class std::error_condition __thiscall std::error_category::default_error_condition(int)const
.text$mn:000017EC                 public ?default_error_condition@error_category@std@@UBE?AVerror_condition@2@H@Z
.text$mn:000017EC ?default_error_condition@error_category@std@@UBE?AVerror_condition@2@H@Z proc near
.text$mn:000017EC                                         ; DATA XREF: .rdata:0000220Co
.text$mn:000017EC                                         ; .rdata:00002228o ...
.text$mn:000017EC
.text$mn:000017EC var_4           = dword ptr -4
.text$mn:000017EC arg_0           = dword ptr  8
.text$mn:000017EC arg_4           = dword ptr  0Ch
.text$mn:000017EC
.text$mn:000017EC                 push    ebp
.text$mn:000017ED                 mov     ebp, esp
.text$mn:000017EF                 push    ecx
.text$mn:000017F0                 mov     [ebp+var_4], ecx
.text$mn:000017F3                 mov     eax, [ebp+var_4]
.text$mn:000017F6                 push    eax             ; struct std::error_category *
.text$mn:000017F7                 mov     ecx, [ebp+arg_4]
.text$mn:000017FA                 push    ecx             ; int
.text$mn:000017FB                 mov     ecx, [ebp+arg_0] ; this
.text$mn:000017FE                 call    ??0error_condition@std@@QAE@HABVerror_category@1@@Z ; std::error_condition::error_condition(int,std::error_category const &)
.text$mn:00001803                 mov     eax, [ebp+arg_0]
.text$mn:00001806                 mov     esp, ebp
.text$mn:00001808                 pop     ebp
.text$mn:00001809                 retn    8
.text$mn:00001809 ?default_error_condition@error_category@std@@UBE?AVerror_condition@2@H@Z endp
.text$mn:00001809
.text$mn:00001809 _text$mn        ends
.text$mn:00001809
.text$mn:0000180C ; ===========================================================================
.text$mn:0000180C
.text$mn:0000180C ; Segment type: Pure code
.text$mn:0000180C ; Segment permissions: Read/Execute
.text$mn:0000180C _text$mn        segment para public 'CODE' use32
.text$mn:0000180C                 assume cs:_text$mn
.text$mn:0000180C                 ;org 180Ch
.text$mn:0000180C ; COMDAT (pick any)
.text$mn:0000180C                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text$mn:0000180C
.text$mn:0000180C ; =============== S U B R O U T I N E =======================================
.text$mn:0000180C
.text$mn:0000180C ; Attributes: bp-based frame
.text$mn:0000180C
.text$mn:0000180C ; bool __thiscall std::error_category::equivalent(std::error_category *this, const struct std::error_code *, int)
.text$mn:0000180C                 public ?equivalent@error_category@std@@UBE_NABVerror_code@2@H@Z
.text$mn:0000180C ?equivalent@error_category@std@@UBE_NABVerror_code@2@H@Z proc near
.text$mn:0000180C                                         ; DATA XREF: .rdata:00002210o
.text$mn:0000180C                                         ; .rdata:0000222Co ...
.text$mn:0000180C
.text$mn:0000180C var_8           = dword ptr -8
.text$mn:0000180C var_4           = dword ptr -4
.text$mn:0000180C arg_0           = dword ptr  8
.text$mn:0000180C arg_4           = dword ptr  0Ch
.text$mn:0000180C
.text$mn:0000180C                 push    ebp
.text$mn:0000180D                 mov     ebp, esp
.text$mn:0000180F                 sub     esp, 8
.text$mn:00001812                 mov     [ebp+var_8], ecx
.text$mn:00001815                 mov     ecx, [ebp+arg_0] ; this
.text$mn:00001818                 call    ?category@error_code@std@@QBEABVerror_category@2@XZ ; std::error_code::category(void)
.text$mn:0000181D                 push    eax
.text$mn:0000181E                 mov     ecx, [ebp+var_8]
.text$mn:00001821                 call    ??8error_category@std@@QBE_NABV01@@Z ; std::error_category::operator==(std::error_category const &)
.text$mn:00001826                 movzx   eax, al
.text$mn:00001829                 test    eax, eax
.text$mn:0000182B                 jz      short loc_1843
.text$mn:0000182D                 mov     ecx, [ebp+arg_0] ; this
.text$mn:00001830                 call    ?value@error_code@std@@QBEHXZ ; std::error_code::value(void)
.text$mn:00001835                 cmp     eax, [ebp+arg_4]
.text$mn:00001838                 jnz     short loc_1843
.text$mn:0000183A                 mov     [ebp+var_4], 1
.text$mn:00001841                 jmp     short loc_184A
.text$mn:00001843 ; ---------------------------------------------------------------------------
.text$mn:00001843
.text$mn:00001843 loc_1843:                               ; CODE XREF: std::error_category::equivalent(std::error_code const &,int)+1Fj
.text$mn:00001843                                         ; std::error_category::equivalent(std::error_code const &,int)+2Cj
.text$mn:00001843                 mov     [ebp+var_4], 0
.text$mn:0000184A
.text$mn:0000184A loc_184A:                               ; CODE XREF: std::error_category::equivalent(std::error_code const &,int)+35j
.text$mn:0000184A                 mov     al, byte ptr [ebp+var_4]
.text$mn:0000184D                 mov     esp, ebp
.text$mn:0000184F                 pop     ebp
.text$mn:00001850                 retn    8
.text$mn:00001850 ?equivalent@error_category@std@@UBE_NABVerror_code@2@H@Z endp
.text$mn:00001850
.text$mn:00001850 ; ---------------------------------------------------------------------------
.text$mn:00001853                 align 4
.text$mn:00001853 _text$mn        ends
.text$mn:00001853
.text$mn:00001854 ; ===========================================================================
.text$mn:00001854
.text$mn:00001854 ; Segment type: Pure code
.text$mn:00001854 ; Segment permissions: Read/Execute
.text$mn:00001854 _text$mn        segment para public 'CODE' use32
.text$mn:00001854                 assume cs:_text$mn
.text$mn:00001854                 ;org 1854h
.text$mn:00001854 ; COMDAT (pick any)
.text$mn:00001854                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text$mn:00001854
.text$mn:00001854 ; =============== S U B R O U T I N E =======================================
.text$mn:00001854
.text$mn:00001854 ; Attributes: bp-based frame
.text$mn:00001854
.text$mn:00001854 ; bool __thiscall std::error_category::equivalent(std::error_category *this, int, const struct std::error_condition *)
.text$mn:00001854                 public ?equivalent@error_category@std@@UBE_NHABVerror_condition@2@@Z
.text$mn:00001854 ?equivalent@error_category@std@@UBE_NHABVerror_condition@2@@Z proc near
.text$mn:00001854                                         ; DATA XREF: .rdata:00002214o
.text$mn:00001854                                         ; .rdata:00002230o ...
.text$mn:00001854
.text$mn:00001854 var_C           = byte ptr -0Ch
.text$mn:00001854 var_4           = dword ptr -4
.text$mn:00001854 arg_0           = dword ptr  8
.text$mn:00001854 arg_4           = dword ptr  0Ch
.text$mn:00001854
.text$mn:00001854                 push    ebp
.text$mn:00001855                 mov     ebp, esp
.text$mn:00001857                 sub     esp, 0Ch
.text$mn:0000185A                 mov     [ebp+var_4], ecx
.text$mn:0000185D                 mov     eax, [ebp+arg_4]
.text$mn:00001860                 push    eax             ; std::error_condition *
.text$mn:00001861                 mov     ecx, [ebp+arg_0]
.text$mn:00001864                 push    ecx
.text$mn:00001865                 lea     edx, [ebp+var_C]
.text$mn:00001868                 push    edx
.text$mn:00001869                 mov     eax, [ebp+var_4]
.text$mn:0000186C                 mov     edx, [eax]
.text$mn:0000186E                 mov     ecx, [ebp+var_4]
.text$mn:00001871                 mov     eax, [edx+0Ch]
.text$mn:00001874                 call    eax
.text$mn:00001876                 mov     ecx, eax
.text$mn:00001878                 call    ??8error_condition@std@@QBE_NABV01@@Z ; std::error_condition::operator==(std::error_condition const &)
.text$mn:0000187D                 mov     esp, ebp
.text$mn:0000187F                 pop     ebp
.text$mn:00001880                 retn    8
.text$mn:00001880 ?equivalent@error_category@std@@UBE_NHABVerror_condition@2@@Z endp
.text$mn:00001880
.text$mn:00001880 ; ---------------------------------------------------------------------------
.text$mn:00001883                 align 4
.text$mn:00001883 _text$mn        ends
.text$mn:00001883
.text$mn:00001884 ; ===========================================================================
.text$mn:00001884
.text$mn:00001884 ; Segment type: Pure code
.text$mn:00001884 ; Segment permissions: Read/Execute
.text$mn:00001884 _text$mn        segment para public 'CODE' use32
.text$mn:00001884                 assume cs:_text$mn
.text$mn:00001884                 ;org 1884h
.text$mn:00001884 ; COMDAT (pick any)
.text$mn:00001884                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text$mn:00001884
.text$mn:00001884 ; =============== S U B R O U T I N E =======================================
.text$mn:00001884
.text$mn:00001884 ; Attributes: bp-based frame
.text$mn:00001884
.text$mn:00001884 ; public: class std::basic_string<char, struct std::char_traits<char>, class std::allocator<char>> & __thiscall std::basic_string<char, struct std::char_traits<char>, class std::allocator<char>>::erase(unsigned int)
.text$mn:00001884                 public ?erase@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV12@I@Z
.text$mn:00001884 ?erase@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV12@I@Z proc near
.text$mn:00001884                                         ; CODE XREF: std::basic_string<char,std::char_traits<char>,std::allocator<char>>::assign(std::basic_string<char,std::char_traits<char>,std::allocator<char>> const &,uint,uint)+4Cp
.text$mn:00001884
.text$mn:00001884 var_4           = dword ptr -4
.text$mn:00001884 arg_0           = dword ptr  8
.text$mn:00001884
.text$mn:00001884                 push    ebp
.text$mn:00001885                 mov     ebp, esp
.text$mn:00001887                 push    ecx
.text$mn:00001888                 mov     [ebp+var_4], ecx
.text$mn:0000188B                 mov     eax, [ebp+var_4]
.text$mn:0000188E                 mov     ecx, [eax+14h]
.text$mn:00001891                 cmp     ecx, [ebp+arg_0]
.text$mn:00001894                 jnb     short loc_189E
.text$mn:00001896                 mov     ecx, [ebp+var_4]
.text$mn:00001899                 call    ?_Xran@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QBEXXZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char>>::_Xran(void)
.text$mn:0000189E
.text$mn:0000189E loc_189E:                               ; CODE XREF: std::basic_string<char,std::char_traits<char>,std::allocator<char>>::erase(uint)+10j
.text$mn:0000189E                 mov     edx, [ebp+arg_0]
.text$mn:000018A1                 push    edx
.text$mn:000018A2                 mov     ecx, [ebp+var_4]
.text$mn:000018A5                 call    ?_Eos@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEXI@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char>>::_Eos(uint)
.text$mn:000018AA                 mov     eax, [ebp+var_4]
.text$mn:000018AD                 mov     esp, ebp
.text$mn:000018AF                 pop     ebp
.text$mn:000018B0                 retn    4
.text$mn:000018B0 ?erase@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV12@I@Z endp
.text$mn:000018B0
.text$mn:000018B0 ; ---------------------------------------------------------------------------
.text$mn:000018B3                 align 4
.text$mn:000018B3 _text$mn        ends
.text$mn:000018B3
.text$mn:000018B4 ; ===========================================================================
.text$mn:000018B4
.text$mn:000018B4 ; Segment type: Pure code
.text$mn:000018B4 ; Segment permissions: Read/Execute
.text$mn:000018B4 _text$mn        segment para public 'CODE' use32
.text$mn:000018B4                 assume cs:_text$mn
.text$mn:000018B4                 ;org 18B4h
.text$mn:000018B4 ; COMDAT (pick any)
.text$mn:000018B4                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text$mn:000018B4
.text$mn:000018B4 ; =============== S U B R O U T I N E =======================================
.text$mn:000018B4
.text$mn:000018B4 ; Attributes: bp-based frame
.text$mn:000018B4
.text$mn:000018B4 ; public: class std::basic_string<char, struct std::char_traits<char>, class std::allocator<char>> & __thiscall std::basic_string<char, struct std::char_traits<char>, class std::allocator<char>>::erase(unsigned int, unsigned int)
.text$mn:000018B4                 public ?erase@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV12@II@Z
.text$mn:000018B4 ?erase@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV12@II@Z proc near
.text$mn:000018B4                                         ; CODE XREF: std::basic_string<char,std::char_traits<char>,std::allocator<char>>::assign(std::basic_string<char,std::char_traits<char>,std::allocator<char>> const &,uint,uint)+5Ap
.text$mn:000018B4
.text$mn:000018B4 var_C           = dword ptr -0Ch
.text$mn:000018B4 Dst             = dword ptr -8
.text$mn:000018B4 var_4           = dword ptr -4
.text$mn:000018B4 arg_0           = dword ptr  8
.text$mn:000018B4 arg_4           = dword ptr  0Ch
.text$mn:000018B4
.text$mn:000018B4                 push    ebp
.text$mn:000018B5                 mov     ebp, esp
.text$mn:000018B7                 sub     esp, 0Ch
.text$mn:000018BA                 mov     [ebp+var_4], ecx
.text$mn:000018BD                 mov     eax, [ebp+var_4]
.text$mn:000018C0                 mov     ecx, [eax+14h]
.text$mn:000018C3                 cmp     ecx, [ebp+arg_0]
.text$mn:000018C6                 jnb     short loc_18D0
.text$mn:000018C8                 mov     ecx, [ebp+var_4]
.text$mn:000018CB                 call    ?_Xran@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QBEXXZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char>>::_Xran(void)
.text$mn:000018D0
.text$mn:000018D0 loc_18D0:                               ; CODE XREF: std::basic_string<char,std::char_traits<char>,std::allocator<char>>::erase(uint,uint)+12j
.text$mn:000018D0                 mov     edx, [ebp+var_4]
.text$mn:000018D3                 mov     eax, [edx+14h]
.text$mn:000018D6                 sub     eax, [ebp+arg_0]
.text$mn:000018D9                 cmp     eax, [ebp+arg_4]
.text$mn:000018DC                 ja      short loc_18EC
.text$mn:000018DE                 mov     ecx, [ebp+arg_0]
.text$mn:000018E1                 push    ecx
.text$mn:000018E2                 mov     ecx, [ebp+var_4]
.text$mn:000018E5                 call    ?_Eos@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEXI@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char>>::_Eos(uint)
.text$mn:000018EA                 jmp     short loc_1932
.text$mn:000018EC ; ---------------------------------------------------------------------------
.text$mn:000018EC
.text$mn:000018EC loc_18EC:                               ; CODE XREF: std::basic_string<char,std::char_traits<char>,std::allocator<char>>::erase(uint,uint)+28j
.text$mn:000018EC                 cmp     [ebp+arg_4], 0
.text$mn:000018F0                 jbe     short loc_1932
.text$mn:000018F2                 mov     ecx, [ebp+var_4]
.text$mn:000018F5                 call    ?_Myptr@?$_String_val@U?$_Simple_types@D@std@@@std@@QAEPADXZ ; std::_String_val<std::_Simple_types<char>>::_Myptr(void)
.text$mn:000018FA                 add     eax, [ebp+arg_0]
.text$mn:000018FD                 mov     [ebp+Dst], eax
.text$mn:00001900                 mov     edx, [ebp+var_4]
.text$mn:00001903                 mov     eax, [edx+14h]
.text$mn:00001906                 sub     eax, [ebp+arg_4]
.text$mn:00001909                 mov     [ebp+var_C], eax
.text$mn:0000190C                 mov     ecx, [ebp+var_C]
.text$mn:0000190F                 sub     ecx, [ebp+arg_0]
.text$mn:00001912                 push    ecx             ; Size
.text$mn:00001913                 mov     edx, [ebp+Dst]
.text$mn:00001916                 add     edx, [ebp+arg_4]
.text$mn:00001919                 push    edx             ; Src
.text$mn:0000191A                 mov     eax, [ebp+Dst]
.text$mn:0000191D                 push    eax             ; Dst
.text$mn:0000191E                 call    ?move@?$char_traits@D@std@@SAPADPADPBDI@Z ; std::char_traits<char>::move(char *,char const *,uint)
.text$mn:00001923                 add     esp, 0Ch
.text$mn:00001926                 mov     ecx, [ebp+var_C]
.text$mn:00001929                 push    ecx
.text$mn:0000192A                 mov     ecx, [ebp+var_4]
.text$mn:0000192D                 call    ?_Eos@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEXI@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char>>::_Eos(uint)
.text$mn:00001932
.text$mn:00001932 loc_1932:                               ; CODE XREF: std::basic_string<char,std::char_traits<char>,std::allocator<char>>::erase(uint,uint)+36j
.text$mn:00001932                                         ; std::basic_string<char,std::char_traits<char>,std::allocator<char>>::erase(uint,uint)+3Cj
.text$mn:00001932                 mov     eax, [ebp+var_4]
.text$mn:00001935                 mov     esp, ebp
.text$mn:00001937                 pop     ebp
.text$mn:00001938                 retn    8
.text$mn:00001938 ?erase@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV12@II@Z endp
.text$mn:00001938
.text$mn:00001938 ; ---------------------------------------------------------------------------
.text$mn:0000193B                 align 4
.text$mn:0000193B _text$mn        ends
.text$mn:0000193B
.text$mn:0000193C ; ===========================================================================
.text$mn:0000193C
.text$mn:0000193C ; Segment type: Pure code
.text$mn:0000193C ; Segment permissions: Read/Execute
.text$mn:0000193C _text$mn        segment para public 'CODE' use32
.text$mn:0000193C                 assume cs:_text$mn
.text$mn:0000193C                 ;org 193Ch
.text$mn:0000193C ; COMDAT (pick any)
.text$mn:0000193C                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text$mn:0000193C
.text$mn:0000193C ; =============== S U B R O U T I N E =======================================
.text$mn:0000193C
.text$mn:0000193C ; Attributes: bp-based frame
.text$mn:0000193C
.text$mn:0000193C ; const struct std::error_category *__cdecl std::generic_category()
.text$mn:0000193C                 public ?generic_category@std@@YAABVerror_category@1@XZ
.text$mn:0000193C ?generic_category@std@@YAABVerror_category@1@XZ proc near
.text$mn:0000193C                                         ; CODE XREF: std::_System_error_category::default_error_condition(int)+17p
.text$mn:0000193C                 push    ebp
.text$mn:0000193D                 mov     ebp, esp
.text$mn:0000193F                 mov     eax, offset ?_Generic_object@?$_Error_objects@H@std@@2V_Generic_error_category@2@A ; std::_Generic_error_category std::_Error_objects<int>::_Generic_object
.text$mn:00001944                 pop     ebp
.text$mn:00001945                 retn
.text$mn:00001945 ?generic_category@std@@YAABVerror_category@1@XZ endp
.text$mn:00001945
.text$mn:00001945 ; ---------------------------------------------------------------------------
.text$mn:00001946                 align 4
.text$mn:00001946 _text$mn        ends
.text$mn:00001946
.text$mn:00001948 ; ===========================================================================
.text$mn:00001948
.text$mn:00001948 ; Segment type: Pure code
.text$mn:00001948 ; Segment permissions: Read/Execute
.text$mn:00001948 _text$mn        segment para public 'CODE' use32
.text$mn:00001948                 assume cs:_text$mn
.text$mn:00001948                 ;org 1948h
.text$mn:00001948 ; COMDAT (pick any)
.text$mn:00001948                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text$mn:00001948
.text$mn:00001948 ; =============== S U B R O U T I N E =======================================
.text$mn:00001948
.text$mn:00001948 ; Attributes: bp-based frame
.text$mn:00001948
.text$mn:00001948 ; void __thiscall Window::init(Window *this, HINSTANCE, HWND)
.text$mn:00001948                 public ?init@Window@@UAEXPAUHINSTANCE__@@PAUHWND__@@@Z
.text$mn:00001948 ?init@Window@@UAEXPAUHINSTANCE__@@PAUHWND__@@@Z proc near
.text$mn:00001948                                         ; CODE XREF: ToolTip::init(HINSTANCE__ *,HWND__ *)+21p
.text$mn:00001948
.text$mn:00001948 var_4           = dword ptr -4
.text$mn:00001948 arg_0           = dword ptr  8
.text$mn:00001948 arg_4           = dword ptr  0Ch
.text$mn:00001948
.text$mn:00001948                 push    ebp
.text$mn:00001949                 mov     ebp, esp
.text$mn:0000194B                 push    ecx
.text$mn:0000194C                 mov     [ebp+var_4], ecx
.text$mn:0000194F                 mov     eax, [ebp+var_4]
.text$mn:00001952                 mov     ecx, [ebp+arg_0]
.text$mn:00001955                 mov     [eax+4], ecx
.text$mn:00001958                 mov     edx, [ebp+var_4]
.text$mn:0000195B                 mov     eax, [ebp+arg_4]
.text$mn:0000195E                 mov     [edx+8], eax
.text$mn:00001961                 mov     esp, ebp
.text$mn:00001963                 pop     ebp
.text$mn:00001964                 retn    8
.text$mn:00001964 ?init@Window@@UAEXPAUHINSTANCE__@@PAUHWND__@@@Z endp
.text$mn:00001964
.text$mn:00001964 ; ---------------------------------------------------------------------------
.text$mn:00001967                 align 4
.text$mn:00001967 _text$mn        ends
.text$mn:00001967
.text$mn:00001968 ; ===========================================================================
.text$mn:00001968
.text$mn:00001968 ; Segment type: Pure code
.text$mn:00001968 ; Segment permissions: Read/Execute
.text$mn:00001968 _text$mn        segment para public 'CODE' use32
.text$mn:00001968                 assume cs:_text$mn
.text$mn:00001968                 ;org 1968h
.text$mn:00001968 ; COMDAT (pick any)
.text$mn:00001968                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text$mn:00001968
.text$mn:00001968 ; =============== S U B R O U T I N E =======================================
.text$mn:00001968
.text$mn:00001968 ; Attributes: bp-based frame
.text$mn:00001968
.text$mn:00001968 ; int __cdecl std::char_traits<char>::length(char *Str)
.text$mn:00001968                 public ?length@?$char_traits@D@std@@SAIPBD@Z
.text$mn:00001968 ?length@?$char_traits@D@std@@SAIPBD@Z proc near
.text$mn:00001968                                         ; CODE XREF: std::basic_string<char,std::char_traits<char>,std::allocator<char>>::assign(char const *)+21p
.text$mn:00001968
.text$mn:00001968 var_4           = dword ptr -4
.text$mn:00001968 Str             = dword ptr  8
.text$mn:00001968
.text$mn:00001968                 push    ebp
.text$mn:00001969                 mov     ebp, esp
.text$mn:0000196B                 push    ecx
.text$mn:0000196C                 mov     eax, [ebp+Str]
.text$mn:0000196F                 movsx   ecx, byte ptr [eax]
.text$mn:00001972                 test    ecx, ecx
.text$mn:00001974                 jnz     short loc_197F
.text$mn:00001976                 mov     [ebp+var_4], 0
.text$mn:0000197D                 jmp     short loc_198E
.text$mn:0000197F ; ---------------------------------------------------------------------------
.text$mn:0000197F
.text$mn:0000197F loc_197F:                               ; CODE XREF: std::char_traits<char>::length(char const *)+Cj
.text$mn:0000197F                 mov     edx, [ebp+Str]
.text$mn:00001982                 push    edx             ; Str
.text$mn:00001983                 call    _strlen
.text$mn:00001988                 add     esp, 4
.text$mn:0000198B                 mov     [ebp+var_4], eax
.text$mn:0000198E
.text$mn:0000198E loc_198E:                               ; CODE XREF: std::char_traits<char>::length(char const *)+15j
.text$mn:0000198E                 mov     eax, [ebp+var_4]
.text$mn:00001991                 mov     esp, ebp
.text$mn:00001993                 pop     ebp
.text$mn:00001994                 retn
.text$mn:00001994 ?length@?$char_traits@D@std@@SAIPBD@Z endp
.text$mn:00001994
.text$mn:00001994 ; ---------------------------------------------------------------------------
.text$mn:00001995                 align 4
.text$mn:00001995 _text$mn        ends
.text$mn:00001995
.text$mn:00001998 ; ===========================================================================
.text$mn:00001998
.text$mn:00001998 ; Segment type: Pure code
.text$mn:00001998 ; Segment permissions: Read/Execute
.text$mn:00001998 _text$mn        segment para public 'CODE' use32
.text$mn:00001998                 assume cs:_text$mn
.text$mn:00001998                 ;org 1998h
.text$mn:00001998 ; COMDAT (pick any)
.text$mn:00001998                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text$mn:00001998
.text$mn:00001998 ; =============== S U B R O U T I N E =======================================
.text$mn:00001998
.text$mn:00001998 ; Attributes: bp-based frame
.text$mn:00001998
.text$mn:00001998 ; public: unsigned int __thiscall std::_Wrap_alloc<class std::allocator<char>>::max_size(void)const
.text$mn:00001998                 public ?max_size@?$_Wrap_alloc@V?$allocator@D@std@@@std@@QBEIXZ
.text$mn:00001998 ?max_size@?$_Wrap_alloc@V?$allocator@D@std@@@std@@QBEIXZ proc near
.text$mn:00001998                                         ; CODE XREF: std::basic_string<char,std::char_traits<char>,std::allocator<char>>::max_size(void)+17p
.text$mn:00001998
.text$mn:00001998 var_4           = dword ptr -4
.text$mn:00001998
.text$mn:00001998                 push    ebp
.text$mn:00001999                 mov     ebp, esp
.text$mn:0000199B                 push    ecx
.text$mn:0000199C                 mov     [ebp+var_4], ecx
.text$mn:0000199F                 mov     eax, [ebp+var_4]
.text$mn:000019A2                 push    eax
.text$mn:000019A3                 call    ?max_size@?$allocator_traits@V?$allocator@D@std@@@std@@SAIABV?$allocator@D@2@@Z ; std::allocator_traits<std::allocator<char>>::max_size(std::allocator<char> const &)
.text$mn:000019A8                 add     esp, 4
.text$mn:000019AB                 mov     esp, ebp
.text$mn:000019AD                 pop     ebp
.text$mn:000019AE                 retn
.text$mn:000019AE ?max_size@?$_Wrap_alloc@V?$allocator@D@std@@@std@@QBEIXZ endp
.text$mn:000019AE
.text$mn:000019AE ; ---------------------------------------------------------------------------
.text$mn:000019AF                 align 10h
.text$mn:000019AF _text$mn        ends
.text$mn:000019AF
.text$mn:000019B0 ; ===========================================================================
.text$mn:000019B0
.text$mn:000019B0 ; Segment type: Pure code
.text$mn:000019B0 ; Segment permissions: Read/Execute
.text$mn:000019B0 _text$mn        segment para public 'CODE' use32
.text$mn:000019B0                 assume cs:_text$mn
.text$mn:000019B0                 ;org 19B0h
.text$mn:000019B0 ; COMDAT (pick any)
.text$mn:000019B0                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text$mn:000019B0
.text$mn:000019B0 ; =============== S U B R O U T I N E =======================================
.text$mn:000019B0
.text$mn:000019B0 ; Attributes: bp-based frame
.text$mn:000019B0
.text$mn:000019B0 ; public: unsigned int __thiscall std::allocator<char>::max_size(void)const
.text$mn:000019B0                 public ?max_size@?$allocator@D@std@@QBEIXZ
.text$mn:000019B0 ?max_size@?$allocator@D@std@@QBEIXZ proc near
.text$mn:000019B0                                         ; CODE XREF: std::allocator_traits<std::allocator<char>>::max_size(std::allocator<char> const &)+6p
.text$mn:000019B0
.text$mn:000019B0 var_4           = dword ptr -4
.text$mn:000019B0
.text$mn:000019B0                 push    ebp
.text$mn:000019B1                 mov     ebp, esp
.text$mn:000019B3                 push    ecx
.text$mn:000019B4                 mov     [ebp+var_4], ecx
.text$mn:000019B7                 or      eax, 0FFFFFFFFh
.text$mn:000019BA                 mov     esp, ebp
.text$mn:000019BC                 pop     ebp
.text$mn:000019BD                 retn
.text$mn:000019BD ?max_size@?$allocator@D@std@@QBEIXZ endp
.text$mn:000019BD
.text$mn:000019BD ; ---------------------------------------------------------------------------
.text$mn:000019BE                 align 10h
.text$mn:000019BE _text$mn        ends
.text$mn:000019BE
.text$mn:000019C0 ; ===========================================================================
.text$mn:000019C0
.text$mn:000019C0 ; Segment type: Pure code
.text$mn:000019C0 ; Segment permissions: Read/Execute
.text$mn:000019C0 _text$mn        segment para public 'CODE' use32
.text$mn:000019C0                 assume cs:_text$mn
.text$mn:000019C0                 ;org 19C0h
.text$mn:000019C0 ; COMDAT (pick any)
.text$mn:000019C0                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text$mn:000019C0
.text$mn:000019C0 ; =============== S U B R O U T I N E =======================================
.text$mn:000019C0
.text$mn:000019C0 ; Attributes: bp-based frame
.text$mn:000019C0
.text$mn:000019C0 ; public: static unsigned int __cdecl std::allocator_traits<class std::allocator<char>>::max_size(class std::allocator<char> const &)
.text$mn:000019C0                 public ?max_size@?$allocator_traits@V?$allocator@D@std@@@std@@SAIABV?$allocator@D@2@@Z
.text$mn:000019C0 ?max_size@?$allocator_traits@V?$allocator@D@std@@@std@@SAIABV?$allocator@D@2@@Z proc near
.text$mn:000019C0                                         ; CODE XREF: std::_Wrap_alloc<std::allocator<char>>::max_size(void)+Bp
.text$mn:000019C0
.text$mn:000019C0 arg_0           = dword ptr  8
.text$mn:000019C0
.text$mn:000019C0                 push    ebp
.text$mn:000019C1                 mov     ebp, esp
.text$mn:000019C3                 mov     ecx, [ebp+arg_0]
.text$mn:000019C6                 call    ?max_size@?$allocator@D@std@@QBEIXZ ; std::allocator<char>::max_size(void)
.text$mn:000019CB                 pop     ebp
.text$mn:000019CC                 retn
.text$mn:000019CC ?max_size@?$allocator_traits@V?$allocator@D@std@@@std@@SAIABV?$allocator@D@2@@Z endp
.text$mn:000019CC
.text$mn:000019CC ; ---------------------------------------------------------------------------
.text$mn:000019CD                 align 10h
.text$mn:000019CD _text$mn        ends
.text$mn:000019CD
.text$mn:000019D0 ; ===========================================================================
.text$mn:000019D0
.text$mn:000019D0 ; Segment type: Pure code
.text$mn:000019D0 ; Segment permissions: Read/Execute
.text$mn:000019D0 _text$mn        segment para public 'CODE' use32
.text$mn:000019D0                 assume cs:_text$mn
.text$mn:000019D0                 ;org 19D0h
.text$mn:000019D0 ; COMDAT (pick any)
.text$mn:000019D0                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text$mn:000019D0
.text$mn:000019D0 ; =============== S U B R O U T I N E =======================================
.text$mn:000019D0
.text$mn:000019D0 ; Attributes: bp-based frame
.text$mn:000019D0
.text$mn:000019D0 ; public: unsigned int __thiscall std::basic_string<char, struct std::char_traits<char>, class std::allocator<char>>::max_size(void)const
.text$mn:000019D0                 public ?max_size@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QBEIXZ
.text$mn:000019D0 ?max_size@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QBEIXZ proc near
.text$mn:000019D0                                         ; CODE XREF: std::basic_string<char,std::char_traits<char>,std::allocator<char>>::_Copy(uint,uint)+3Bp
.text$mn:000019D0                                         ; std::basic_string<char,std::char_traits<char>,std::allocator<char>>::_Copy(uint,uint)+6Ap ...
.text$mn:000019D0
.text$mn:000019D0 var_10          = dword ptr -10h
.text$mn:000019D0 var_C           = dword ptr -0Ch
.text$mn:000019D0 var_8           = dword ptr -8
.text$mn:000019D0 var_1           = byte ptr -1
.text$mn:000019D0
.text$mn:000019D0                 push    ebp
.text$mn:000019D1                 mov     ebp, esp
.text$mn:000019D3                 sub     esp, 10h
.text$mn:000019D6                 mov     [ebp+var_10], ecx
.text$mn:000019D9                 lea     eax, [ebp+var_1]
.text$mn:000019DC                 push    eax
.text$mn:000019DD                 mov     ecx, [ebp+var_10]
.text$mn:000019E0                 call    ?_Getal@?$_String_alloc@$0A@U?$_String_base_types@DV?$allocator@D@std@@@std@@@std@@QBE?AU?$_Wrap_alloc@V?$allocator@D@std@@@2@XZ ; std::_String_alloc<0,std::_String_base_types<char,std::allocator<char>>>::_Getal(void)
.text$mn:000019E5                 mov     ecx, eax
.text$mn:000019E7                 call    ?max_size@?$_Wrap_alloc@V?$allocator@D@std@@@std@@QBEIXZ ; std::_Wrap_alloc<std::allocator<char>>::max_size(void)
.text$mn:000019EC                 mov     [ebp+var_8], eax
.text$mn:000019EF                 cmp     [ebp+var_8], 1
.text$mn:000019F3                 ja      short loc_19FE
.text$mn:000019F5                 mov     [ebp+var_C], 1
.text$mn:000019FC                 jmp     short loc_1A07
.text$mn:000019FE ; ---------------------------------------------------------------------------
.text$mn:000019FE
.text$mn:000019FE loc_19FE:                               ; CODE XREF: std::basic_string<char,std::char_traits<char>,std::allocator<char>>::max_size(void)+23j
.text$mn:000019FE                 mov     ecx, [ebp+var_8]
.text$mn:00001A01                 sub     ecx, 1
.text$mn:00001A04                 mov     [ebp+var_C], ecx
.text$mn:00001A07
.text$mn:00001A07 loc_1A07:                               ; CODE XREF: std::basic_string<char,std::char_traits<char>,std::allocator<char>>::max_size(void)+2Cj
.text$mn:00001A07                 mov     eax, [ebp+var_C]
.text$mn:00001A0A                 mov     esp, ebp
.text$mn:00001A0C                 pop     ebp
.text$mn:00001A0D                 retn
.text$mn:00001A0D ?max_size@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QBEIXZ endp
.text$mn:00001A0D
.text$mn:00001A0D ; ---------------------------------------------------------------------------
.text$mn:00001A0E                 align 10h
.text$mn:00001A0E _text$mn        ends
.text$mn:00001A0E
.text$mn:00001A10 ; ===========================================================================
.text$mn:00001A10
.text$mn:00001A10 ; Segment type: Pure code
.text$mn:00001A10 ; Segment permissions: Read/Execute
.text$mn:00001A10 _text$mn        segment para public 'CODE' use32
.text$mn:00001A10                 assume cs:_text$mn
.text$mn:00001A10                 ;org 1A10h
.text$mn:00001A10 ; COMDAT (pick any)
.text$mn:00001A10                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text$mn:00001A10
.text$mn:00001A10 ; =============== S U B R O U T I N E =======================================
.text$mn:00001A10
.text$mn:00001A10 ; Attributes: bp-based frame
.text$mn:00001A10
.text$mn:00001A10 ; public: virtual class std::basic_string<char, struct std::char_traits<char>, class std::allocator<char>> __thiscall std::_Generic_error_category::message(int)const
.text$mn:00001A10                 public ?message@_Generic_error_category@std@@UBE?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@2@H@Z
.text$mn:00001A10 ?message@_Generic_error_category@std@@UBE?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@2@H@Z proc near
.text$mn:00001A10                                         ; CODE XREF: std::_Iostream_error_category::message(int)+64p
.text$mn:00001A10                                         ; DATA XREF: .rdata:00002224o
.text$mn:00001A10
.text$mn:00001A10 var_1C          = dword ptr -1Ch
.text$mn:00001A10 var_18          = dword ptr -18h
.text$mn:00001A10 Str             = dword ptr -14h
.text$mn:00001A10 var_10          = dword ptr -10h
.text$mn:00001A10 var_C           = dword ptr -0Ch
.text$mn:00001A10 var_4           = dword ptr -4
.text$mn:00001A10 arg_0           = dword ptr  8
.text$mn:00001A10 arg_4           = dword ptr  0Ch
.text$mn:00001A10
.text$mn:00001A10                 push    ebp
.text$mn:00001A11                 mov     ebp, esp
.text$mn:00001A13                 push    0FFFFFFFFh
.text$mn:00001A15                 push    offset __ehhandler$?message@_Generic_error_category@std@@UBE?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@2@H@Z
.text$mn:00001A1A                 mov     eax, large fs:0
.text$mn:00001A20                 push    eax
.text$mn:00001A21                 sub     esp, 10h
.text$mn:00001A24                 mov     eax, dword ptr ds:___security_cookie
.text$mn:00001A29                 xor     eax, ebp
.text$mn:00001A2B                 push    eax
.text$mn:00001A2C                 lea     eax, [ebp+var_C]
.text$mn:00001A2F                 mov     large fs:0, eax
.text$mn:00001A35                 mov     [ebp+var_1C], ecx
.text$mn:00001A38                 mov     [ebp+var_18], 0
.text$mn:00001A3F                 mov     eax, [ebp+arg_4]
.text$mn:00001A42                 push    eax             ; int
.text$mn:00001A43                 call    ?_Syserror_map@std@@YAPBDH@Z ; std::_Syserror_map(int)
.text$mn:00001A48                 add     esp, 4
.text$mn:00001A4B                 mov     [ebp+var_10], eax
.text$mn:00001A4E                 cmp     [ebp+var_10], 0
.text$mn:00001A52                 jz      short loc_1A5C
.text$mn:00001A54                 mov     ecx, [ebp+var_10]
.text$mn:00001A57                 mov     [ebp+Str], ecx
.text$mn:00001A5A                 jmp     short loc_1A63
.text$mn:00001A5C ; ---------------------------------------------------------------------------
.text$mn:00001A5C
.text$mn:00001A5C loc_1A5C:                               ; CODE XREF: std::_Generic_error_category::message(int)+42j
.text$mn:00001A5C                 mov     [ebp+Str], offset ??_C@_0O@BFJCFAAK@unknown?5error?$AA@ ; "unknown error"
.text$mn:00001A63
.text$mn:00001A63 loc_1A63:                               ; CODE XREF: std::_Generic_error_category::message(int)+4Aj
.text$mn:00001A63                 mov     edx, [ebp+Str]
.text$mn:00001A66                 push    edx             ; Str
.text$mn:00001A67                 mov     ecx, [ebp+arg_0]
.text$mn:00001A6A                 call    ??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@PBD@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char>>::basic_string<char,std::char_traits<char>,std::allocator<char>>(char const *)
.text$mn:00001A6F                 mov     [ebp+var_4], 0
.text$mn:00001A76                 mov     eax, [ebp+var_18]
.text$mn:00001A79                 or      eax, 1
.text$mn:00001A7C                 mov     [ebp+var_18], eax
.text$mn:00001A7F                 mov     eax, [ebp+arg_0]
.text$mn:00001A82                 mov     ecx, [ebp+var_C]
.text$mn:00001A85                 mov     large fs:0, ecx
.text$mn:00001A8C                 pop     ecx
.text$mn:00001A8D                 mov     esp, ebp
.text$mn:00001A8F                 pop     ebp
.text$mn:00001A90                 retn    8
.text$mn:00001A90 ?message@_Generic_error_category@std@@UBE?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@2@H@Z endp
.text$mn:00001A90
.text$mn:00001A90 ; ---------------------------------------------------------------------------
.text$mn:00001A93                 align 4
.text$mn:00001A93 _text$mn        ends
.text$mn:00001A93
.text$x:00001A94 ; ===========================================================================
.text$x:00001A94
.text$x:00001A94 ; Segment type: Pure code
.text$x:00001A94 ; Segment permissions: Read/Execute
.text$x:00001A94 _text$x         segment para public 'CODE' use32
.text$x:00001A94                 assume cs:_text$x
.text$x:00001A94                 ;org 1A94h
.text$x:00001A94 ; COMDAT (pick associative to section at 1A10)
.text$x:00001A94                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text$x:00001A94
.text$x:00001A94 ; =============== S U B R O U T I N E =======================================
.text$x:00001A94
.text$x:00001A94
.text$x:00001A94 __unwindfunclet$?message@_Generic_error_category@std@@UBE?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@2@H@Z$0 proc near
.text$x:00001A94                                         ; DATA XREF: .xdata$x:00001FA8o
.text$x:00001A94                 mov     eax, [ebp-18h]
.text$x:00001A97                 and     eax, 1
.text$x:00001A9A                 jz      $LN6
.text$x:00001AA0                 and     dword ptr [ebp-18h], 0FFFFFFFEh
.text$x:00001AA4                 mov     ecx, [ebp+8]
.text$x:00001AA7                 jmp     ??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char>>::~basic_string<char,std::char_traits<char>,std::allocator<char>>(void)
.text$x:00001AAC ; ---------------------------------------------------------------------------
.text$x:00001AAC
.text$x:00001AAC $LN6:                                   ; CODE XREF: __unwindfunclet$?message@_Generic_error_category@std@@UBE?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@2@H@Z$0+6j
.text$x:00001AAC                 retn
.text$x:00001AAC __unwindfunclet$?message@_Generic_error_category@std@@UBE?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@2@H@Z$0 endp
.text$x:00001AAC
.text$x:00001AAD
.text$x:00001AAD ; =============== S U B R O U T I N E =======================================
.text$x:00001AAD
.text$x:00001AAD
.text$x:00001AAD __ehhandler$?message@_Generic_error_category@std@@UBE?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@2@H@Z proc near
.text$x:00001AAD                                         ; DATA XREF: std::_Generic_error_category::message(int)+5o
.text$x:00001AAD
.text$x:00001AAD arg_4           = dword ptr  8
.text$x:00001AAD
.text$x:00001AAD                 mov     edx, [esp+arg_4]
.text$x:00001AB1                 lea     eax, [edx+0Ch]
.text$x:00001AB4                 mov     ecx, [edx-14h]
.text$x:00001AB7                 xor     ecx, eax
.text$x:00001AB9                 call    @__security_check_cookie@4 ; __security_check_cookie(x)
.text$x:00001ABE                 mov     eax, offset __ehfuncinfo$?message@_Generic_error_category@std@@UBE?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@2@H@Z
.text$x:00001AC3                 jmp     ___CxxFrameHandler3
.text$x:00001AC3 __ehhandler$?message@_Generic_error_category@std@@UBE?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@2@H@Z endp
.text$x:00001AC3
.text$x:00001AC3 _text$x         ends
.text$x:00001AC3
.text$mn:00001AC8 ; ===========================================================================
.text$mn:00001AC8
.text$mn:00001AC8 ; Segment type: Pure code
.text$mn:00001AC8 ; Segment permissions: Read/Execute
.text$mn:00001AC8 _text$mn        segment para public 'CODE' use32
.text$mn:00001AC8                 assume cs:_text$mn
.text$mn:00001AC8                 ;org 1AC8h
.text$mn:00001AC8 ; COMDAT (pick any)
.text$mn:00001AC8                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text$mn:00001AC8
.text$mn:00001AC8 ; =============== S U B R O U T I N E =======================================
.text$mn:00001AC8
.text$mn:00001AC8 ; Attributes: bp-based frame
.text$mn:00001AC8
.text$mn:00001AC8 ; public: virtual class std::basic_string<char, struct std::char_traits<char>, class std::allocator<char>> __thiscall std::_Iostream_error_category::message(int)const
.text$mn:00001AC8                 public ?message@_Iostream_error_category@std@@UBE?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@2@H@Z
.text$mn:00001AC8 ?message@_Iostream_error_category@std@@UBE?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@2@H@Z proc near
.text$mn:00001AC8                                         ; DATA XREF: .rdata:00002258o
.text$mn:00001AC8
.text$mn:00001AC8 var_14          = dword ptr -14h
.text$mn:00001AC8 var_10          = dword ptr -10h
.text$mn:00001AC8 var_C           = dword ptr -0Ch
.text$mn:00001AC8 var_4           = dword ptr -4
.text$mn:00001AC8 arg_0           = dword ptr  8
.text$mn:00001AC8 arg_4           = dword ptr  0Ch
.text$mn:00001AC8
.text$mn:00001AC8                 push    ebp
.text$mn:00001AC9                 mov     ebp, esp
.text$mn:00001ACB                 push    0FFFFFFFFh
.text$mn:00001ACD                 push    offset __ehhandler$?message@_Iostream_error_category@std@@UBE?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@2@H@Z
.text$mn:00001AD2                 mov     eax, large fs:0
.text$mn:00001AD8                 push    eax
.text$mn:00001AD9                 sub     esp, 8
.text$mn:00001ADC                 mov     eax, dword ptr ds:___security_cookie
.text$mn:00001AE1                 xor     eax, ebp
.text$mn:00001AE3                 push    eax
.text$mn:00001AE4                 lea     eax, [ebp+var_C]
.text$mn:00001AE7                 mov     large fs:0, eax
.text$mn:00001AED                 mov     [ebp+var_14], ecx
.text$mn:00001AF0                 mov     [ebp+var_10], 0
.text$mn:00001AF7                 cmp     [ebp+arg_4], 1
.text$mn:00001AFB                 jnz     short loc_1B21
.text$mn:00001AFD                 push    offset ??_C@_0BG@PADBLCHM@iostream?5stream?5error?$AA@ ; "iostream stream error"
.text$mn:00001B02                 mov     ecx, [ebp+arg_0]
.text$mn:00001B05                 call    ??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@PBD@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char>>::basic_string<char,std::char_traits<char>,std::allocator<char>>(char const *)
.text$mn:00001B0A                 mov     [ebp+var_4], 0
.text$mn:00001B11                 mov     eax, [ebp+var_10]
.text$mn:00001B14                 or      eax, 1
.text$mn:00001B17                 mov     [ebp+var_10], eax
.text$mn:00001B1A                 mov     eax, [ebp+arg_0]
.text$mn:00001B1D                 jmp     short loc_1B44
.text$mn:00001B1F ; ---------------------------------------------------------------------------
.text$mn:00001B1F                 jmp     short loc_1B44
.text$mn:00001B21 ; ---------------------------------------------------------------------------
.text$mn:00001B21
.text$mn:00001B21 loc_1B21:                               ; CODE XREF: std::_Iostream_error_category::message(int)+33j
.text$mn:00001B21                 mov     ecx, [ebp+arg_4]
.text$mn:00001B24                 push    ecx
.text$mn:00001B25                 mov     edx, [ebp+arg_0]
.text$mn:00001B28                 push    edx
.text$mn:00001B29                 mov     ecx, [ebp+var_14]
.text$mn:00001B2C                 call    ?message@_Generic_error_category@std@@UBE?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@2@H@Z ; std::_Generic_error_category::message(int)
.text$mn:00001B31                 mov     [ebp+var_4], 0
.text$mn:00001B38                 mov     eax, [ebp+var_10]
.text$mn:00001B3B                 or      eax, 1
.text$mn:00001B3E                 mov     [ebp+var_10], eax
.text$mn:00001B41                 mov     eax, [ebp+arg_0]
.text$mn:00001B44
.text$mn:00001B44 loc_1B44:                               ; CODE XREF: std::_Iostream_error_category::message(int)+55j
.text$mn:00001B44                                         ; std::_Iostream_error_category::message(int)+57j
.text$mn:00001B44                 mov     ecx, [ebp+var_C]
.text$mn:00001B47                 mov     large fs:0, ecx
.text$mn:00001B4E                 pop     ecx
.text$mn:00001B4F                 mov     esp, ebp
.text$mn:00001B51                 pop     ebp
.text$mn:00001B52                 retn    8
.text$mn:00001B52 ?message@_Iostream_error_category@std@@UBE?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@2@H@Z endp
.text$mn:00001B52
.text$mn:00001B52 ; ---------------------------------------------------------------------------
.text$mn:00001B55                 align 4
.text$mn:00001B55 _text$mn        ends
.text$mn:00001B55
.text$x:00001B58 ; ===========================================================================
.text$x:00001B58
.text$x:00001B58 ; Segment type: Pure code
.text$x:00001B58 ; Segment permissions: Read/Execute
.text$x:00001B58 _text$x         segment para public 'CODE' use32
.text$x:00001B58                 assume cs:_text$x
.text$x:00001B58                 ;org 1B58h
.text$x:00001B58 ; COMDAT (pick associative to section at 1AC8)
.text$x:00001B58                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text$x:00001B58
.text$x:00001B58 ; =============== S U B R O U T I N E =======================================
.text$x:00001B58
.text$x:00001B58
.text$x:00001B58 __unwindfunclet$?message@_Iostream_error_category@std@@UBE?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@2@H@Z$0 proc near
.text$x:00001B58                                         ; DATA XREF: .xdata$x:0000202Co
.text$x:00001B58                 mov     eax, [ebp-10h]
.text$x:00001B5B                 and     eax, 1
.text$x:00001B5E                 jz      $LN6_0
.text$x:00001B64                 and     dword ptr [ebp-10h], 0FFFFFFFEh
.text$x:00001B68                 mov     ecx, [ebp+8]
.text$x:00001B6B                 jmp     ??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char>>::~basic_string<char,std::char_traits<char>,std::allocator<char>>(void)
.text$x:00001B70 ; ---------------------------------------------------------------------------
.text$x:00001B70
.text$x:00001B70 $LN6_0:                                 ; CODE XREF: __unwindfunclet$?message@_Iostream_error_category@std@@UBE?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@2@H@Z$0+6j
.text$x:00001B70                 retn
.text$x:00001B70 __unwindfunclet$?message@_Iostream_error_category@std@@UBE?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@2@H@Z$0 endp
.text$x:00001B70
.text$x:00001B71
.text$x:00001B71 ; =============== S U B R O U T I N E =======================================
.text$x:00001B71
.text$x:00001B71
.text$x:00001B71 __ehhandler$?message@_Iostream_error_category@std@@UBE?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@2@H@Z proc near
.text$x:00001B71                                         ; DATA XREF: std::_Iostream_error_category::message(int)+5o
.text$x:00001B71
.text$x:00001B71 arg_4           = dword ptr  8
.text$x:00001B71
.text$x:00001B71                 mov     edx, [esp+arg_4]
.text$x:00001B75                 lea     eax, [edx+0Ch]
.text$x:00001B78                 mov     ecx, [edx-0Ch]
.text$x:00001B7B                 xor     ecx, eax
.text$x:00001B7D                 call    @__security_check_cookie@4 ; __security_check_cookie(x)
.text$x:00001B82                 mov     eax, offset __ehfuncinfo$?message@_Iostream_error_category@std@@UBE?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@2@H@Z
.text$x:00001B87                 jmp     ___CxxFrameHandler3
.text$x:00001B87 __ehhandler$?message@_Iostream_error_category@std@@UBE?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@2@H@Z endp
.text$x:00001B87
.text$x:00001B87 _text$x         ends
.text$x:00001B87
.text$mn:00001B8C ; ===========================================================================
.text$mn:00001B8C
.text$mn:00001B8C ; Segment type: Pure code
.text$mn:00001B8C ; Segment permissions: Read/Execute
.text$mn:00001B8C _text$mn        segment para public 'CODE' use32
.text$mn:00001B8C                 assume cs:_text$mn
.text$mn:00001B8C                 ;org 1B8Ch
.text$mn:00001B8C ; COMDAT (pick any)
.text$mn:00001B8C                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text$mn:00001B8C
.text$mn:00001B8C ; =============== S U B R O U T I N E =======================================
.text$mn:00001B8C
.text$mn:00001B8C ; Attributes: bp-based frame
.text$mn:00001B8C
.text$mn:00001B8C ; public: virtual class std::basic_string<char, struct std::char_traits<char>, class std::allocator<char>> __thiscall std::_System_error_category::message(int)const
.text$mn:00001B8C                 public ?message@_System_error_category@std@@UBE?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@2@H@Z
.text$mn:00001B8C ?message@_System_error_category@std@@UBE?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@2@H@Z proc near
.text$mn:00001B8C                                         ; DATA XREF: .rdata:00002298o
.text$mn:00001B8C
.text$mn:00001B8C var_1C          = dword ptr -1Ch
.text$mn:00001B8C var_18          = dword ptr -18h
.text$mn:00001B8C Str             = dword ptr -14h
.text$mn:00001B8C var_10          = dword ptr -10h
.text$mn:00001B8C var_C           = dword ptr -0Ch
.text$mn:00001B8C var_4           = dword ptr -4
.text$mn:00001B8C arg_0           = dword ptr  8
.text$mn:00001B8C arg_4           = dword ptr  0Ch
.text$mn:00001B8C
.text$mn:00001B8C                 push    ebp
.text$mn:00001B8D                 mov     ebp, esp
.text$mn:00001B8F                 push    0FFFFFFFFh
.text$mn:00001B91                 push    offset __ehhandler$?message@_System_error_category@std@@UBE?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@2@H@Z
.text$mn:00001B96                 mov     eax, large fs:0
.text$mn:00001B9C                 push    eax
.text$mn:00001B9D                 sub     esp, 10h
.text$mn:00001BA0                 mov     eax, dword ptr ds:___security_cookie
.text$mn:00001BA5                 xor     eax, ebp
.text$mn:00001BA7                 push    eax
.text$mn:00001BA8                 lea     eax, [ebp+var_C]
.text$mn:00001BAB                 mov     large fs:0, eax
.text$mn:00001BB1                 mov     [ebp+var_1C], ecx
.text$mn:00001BB4                 mov     [ebp+var_18], 0
.text$mn:00001BBB                 mov     eax, [ebp+arg_4]
.text$mn:00001BBE                 push    eax             ; int
.text$mn:00001BBF                 call    ?_Winerror_map@std@@YAPBDH@Z ; std::_Winerror_map(int)
.text$mn:00001BC4                 add     esp, 4
.text$mn:00001BC7                 mov     [ebp+var_10], eax
.text$mn:00001BCA                 cmp     [ebp+var_10], 0
.text$mn:00001BCE                 jz      short loc_1BD8
.text$mn:00001BD0                 mov     ecx, [ebp+var_10]
.text$mn:00001BD3                 mov     [ebp+Str], ecx
.text$mn:00001BD6                 jmp     short loc_1BDF
.text$mn:00001BD8 ; ---------------------------------------------------------------------------
.text$mn:00001BD8
.text$mn:00001BD8 loc_1BD8:                               ; CODE XREF: std::_System_error_category::message(int)+42j
.text$mn:00001BD8                 mov     [ebp+Str], offset ??_C@_0O@BFJCFAAK@unknown?5error?$AA@ ; "unknown error"
.text$mn:00001BDF
.text$mn:00001BDF loc_1BDF:                               ; CODE XREF: std::_System_error_category::message(int)+4Aj
.text$mn:00001BDF                 mov     edx, [ebp+Str]
.text$mn:00001BE2                 push    edx             ; Str
.text$mn:00001BE3                 mov     ecx, [ebp+arg_0]
.text$mn:00001BE6                 call    ??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@PBD@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char>>::basic_string<char,std::char_traits<char>,std::allocator<char>>(char const *)
.text$mn:00001BEB                 mov     [ebp+var_4], 0
.text$mn:00001BF2                 mov     eax, [ebp+var_18]
.text$mn:00001BF5                 or      eax, 1
.text$mn:00001BF8                 mov     [ebp+var_18], eax
.text$mn:00001BFB                 mov     eax, [ebp+arg_0]
.text$mn:00001BFE                 mov     ecx, [ebp+var_C]
.text$mn:00001C01                 mov     large fs:0, ecx
.text$mn:00001C08                 pop     ecx
.text$mn:00001C09                 mov     esp, ebp
.text$mn:00001C0B                 pop     ebp
.text$mn:00001C0C                 retn    8
.text$mn:00001C0C ?message@_System_error_category@std@@UBE?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@2@H@Z endp
.text$mn:00001C0C
.text$mn:00001C0C ; ---------------------------------------------------------------------------
.text$mn:00001C0F                 align 10h
.text$mn:00001C0F _text$mn        ends
.text$mn:00001C0F
.text$x:00001C10 ; ===========================================================================
.text$x:00001C10
.text$x:00001C10 ; Segment type: Pure code
.text$x:00001C10 ; Segment permissions: Read/Execute
.text$x:00001C10 _text$x         segment para public 'CODE' use32
.text$x:00001C10                 assume cs:_text$x
.text$x:00001C10                 ;org 1C10h
.text$x:00001C10 ; COMDAT (pick associative to section at 1B8C)
.text$x:00001C10                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text$x:00001C10
.text$x:00001C10 ; =============== S U B R O U T I N E =======================================
.text$x:00001C10
.text$x:00001C10
.text$x:00001C10 __unwindfunclet$?message@_System_error_category@std@@UBE?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@2@H@Z$0 proc near
.text$x:00001C10                                         ; DATA XREF: .xdata$x:000020B0o
.text$x:00001C10                 mov     eax, [ebp-18h]
.text$x:00001C13                 and     eax, 1
.text$x:00001C16                 jz      $LN6_1
.text$x:00001C1C                 and     dword ptr [ebp-18h], 0FFFFFFFEh
.text$x:00001C20                 mov     ecx, [ebp+8]
.text$x:00001C23                 jmp     ??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char>>::~basic_string<char,std::char_traits<char>,std::allocator<char>>(void)
.text$x:00001C28 ; ---------------------------------------------------------------------------
.text$x:00001C28
.text$x:00001C28 $LN6_1:                                 ; CODE XREF: __unwindfunclet$?message@_System_error_category@std@@UBE?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@2@H@Z$0+6j
.text$x:00001C28                 retn
.text$x:00001C28 __unwindfunclet$?message@_System_error_category@std@@UBE?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@2@H@Z$0 endp
.text$x:00001C28
.text$x:00001C29
.text$x:00001C29 ; =============== S U B R O U T I N E =======================================
.text$x:00001C29
.text$x:00001C29
.text$x:00001C29 __ehhandler$?message@_System_error_category@std@@UBE?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@2@H@Z proc near
.text$x:00001C29                                         ; DATA XREF: std::_System_error_category::message(int)+5o
.text$x:00001C29
.text$x:00001C29 arg_4           = dword ptr  8
.text$x:00001C29
.text$x:00001C29                 mov     edx, [esp+arg_4]
.text$x:00001C2D                 lea     eax, [edx+0Ch]
.text$x:00001C30                 mov     ecx, [edx-14h]
.text$x:00001C33                 xor     ecx, eax
.text$x:00001C35                 call    @__security_check_cookie@4 ; __security_check_cookie(x)
.text$x:00001C3A                 mov     eax, offset __ehfuncinfo$?message@_System_error_category@std@@UBE?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@2@H@Z
.text$x:00001C3F                 jmp     ___CxxFrameHandler3
.text$x:00001C3F __ehhandler$?message@_System_error_category@std@@UBE?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@2@H@Z endp
.text$x:00001C3F
.text$x:00001C3F _text$x         ends
.text$x:00001C3F
.text$mn:00001C44 ; ===========================================================================
.text$mn:00001C44
.text$mn:00001C44 ; Segment type: Pure code
.text$mn:00001C44 ; Segment permissions: Read/Execute
.text$mn:00001C44 _text$mn        segment para public 'CODE' use32
.text$mn:00001C44                 assume cs:_text$mn
.text$mn:00001C44                 ;org 1C44h
.text$mn:00001C44 ; COMDAT (pick any)
.text$mn:00001C44                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text$mn:00001C44
.text$mn:00001C44 ; =============== S U B R O U T I N E =======================================
.text$mn:00001C44
.text$mn:00001C44 ; Attributes: bp-based frame
.text$mn:00001C44
.text$mn:00001C44 ; int __cdecl std::char_traits<char>::move(void *Dst, void *Src, size_t Size)
.text$mn:00001C44                 public ?move@?$char_traits@D@std@@SAPADPADPBDI@Z
.text$mn:00001C44 ?move@?$char_traits@D@std@@SAPADPADPBDI@Z proc near
.text$mn:00001C44                                         ; CODE XREF: std::basic_string<char,std::char_traits<char>,std::allocator<char>>::erase(uint,uint)+6Ap
.text$mn:00001C44
.text$mn:00001C44 var_4           = dword ptr -4
.text$mn:00001C44 Dst             = dword ptr  8
.text$mn:00001C44 Src             = dword ptr  0Ch
.text$mn:00001C44 Size            = dword ptr  10h
.text$mn:00001C44
.text$mn:00001C44                 push    ebp
.text$mn:00001C45                 mov     ebp, esp
.text$mn:00001C47                 push    ecx
.text$mn:00001C48                 cmp     [ebp+Size], 0
.text$mn:00001C4C                 jnz     short loc_1C56
.text$mn:00001C4E                 mov     eax, [ebp+Dst]
.text$mn:00001C51                 mov     [ebp+var_4], eax
.text$mn:00001C54                 jmp     short loc_1C6D
.text$mn:00001C56 ; ---------------------------------------------------------------------------
.text$mn:00001C56
.text$mn:00001C56 loc_1C56:                               ; CODE XREF: std::char_traits<char>::move(char *,char const *,uint)+8j
.text$mn:00001C56                 mov     ecx, [ebp+Size]
.text$mn:00001C59                 push    ecx             ; Size
.text$mn:00001C5A                 mov     edx, [ebp+Src]
.text$mn:00001C5D                 push    edx             ; Src
.text$mn:00001C5E                 mov     eax, [ebp+Dst]
.text$mn:00001C61                 push    eax             ; Dst
.text$mn:00001C62                 call    _memmove
.text$mn:00001C67                 add     esp, 0Ch
.text$mn:00001C6A                 mov     [ebp+var_4], eax
.text$mn:00001C6D
.text$mn:00001C6D loc_1C6D:                               ; CODE XREF: std::char_traits<char>::move(char *,char const *,uint)+10j
.text$mn:00001C6D                 mov     eax, [ebp+var_4]
.text$mn:00001C70                 mov     esp, ebp
.text$mn:00001C72                 pop     ebp
.text$mn:00001C73                 retn
.text$mn:00001C73 ?move@?$char_traits@D@std@@SAPADPADPBDI@Z endp
.text$mn:00001C73
.text$mn:00001C73 _text$mn        ends
.text$mn:00001C73
.text$mn:00001C74 ; ===========================================================================
.text$mn:00001C74
.text$mn:00001C74 ; Segment type: Pure code
.text$mn:00001C74 ; Segment permissions: Read/Execute
.text$mn:00001C74 _text$mn        segment para public 'CODE' use32
.text$mn:00001C74                 assume cs:_text$mn
.text$mn:00001C74                 ;org 1C74h
.text$mn:00001C74 ; COMDAT (pick any)
.text$mn:00001C74                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text$mn:00001C74
.text$mn:00001C74 ; =============== S U B R O U T I N E =======================================
.text$mn:00001C74
.text$mn:00001C74 ; Attributes: bp-based frame
.text$mn:00001C74
.text$mn:00001C74 ; const char *__thiscall std::_Generic_error_category::name(std::_Generic_error_category *__hidden this)
.text$mn:00001C74                 public ?name@_Generic_error_category@std@@UBEPBDXZ
.text$mn:00001C74 ?name@_Generic_error_category@std@@UBEPBDXZ proc near
.text$mn:00001C74                                         ; DATA XREF: .rdata:00002220o
.text$mn:00001C74
.text$mn:00001C74 var_4           = dword ptr -4
.text$mn:00001C74
.text$mn:00001C74                 push    ebp
.text$mn:00001C75                 mov     ebp, esp
.text$mn:00001C77                 push    ecx
.text$mn:00001C78                 mov     [ebp+var_4], ecx
.text$mn:00001C7B                 mov     eax, offset ??_C@_07DCLBNMLN@generic?$AA@ ; "generic"
.text$mn:00001C80                 mov     esp, ebp
.text$mn:00001C82                 pop     ebp
.text$mn:00001C83                 retn
.text$mn:00001C83 ?name@_Generic_error_category@std@@UBEPBDXZ endp
.text$mn:00001C83
.text$mn:00001C83 _text$mn        ends
.text$mn:00001C83
.text$mn:00001C84 ; ===========================================================================
.text$mn:00001C84
.text$mn:00001C84 ; Segment type: Pure code
.text$mn:00001C84 ; Segment permissions: Read/Execute
.text$mn:00001C84 _text$mn        segment para public 'CODE' use32
.text$mn:00001C84                 assume cs:_text$mn
.text$mn:00001C84                 ;org 1C84h
.text$mn:00001C84 ; COMDAT (pick any)
.text$mn:00001C84                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text$mn:00001C84
.text$mn:00001C84 ; =============== S U B R O U T I N E =======================================
.text$mn:00001C84
.text$mn:00001C84 ; Attributes: bp-based frame
.text$mn:00001C84
.text$mn:00001C84 ; const char *__thiscall std::_Iostream_error_category::name(std::_Iostream_error_category *__hidden this)
.text$mn:00001C84                 public ?name@_Iostream_error_category@std@@UBEPBDXZ
.text$mn:00001C84 ?name@_Iostream_error_category@std@@UBEPBDXZ proc near
.text$mn:00001C84                                         ; DATA XREF: .rdata:00002254o
.text$mn:00001C84
.text$mn:00001C84 var_4           = dword ptr -4
.text$mn:00001C84
.text$mn:00001C84                 push    ebp
.text$mn:00001C85                 mov     ebp, esp
.text$mn:00001C87                 push    ecx
.text$mn:00001C88                 mov     [ebp+var_4], ecx
.text$mn:00001C8B                 mov     eax, offset ??_C@_08LLGCOLLL@iostream?$AA@ ; "iostream"
.text$mn:00001C90                 mov     esp, ebp
.text$mn:00001C92                 pop     ebp
.text$mn:00001C93                 retn
.text$mn:00001C93 ?name@_Iostream_error_category@std@@UBEPBDXZ endp
.text$mn:00001C93
.text$mn:00001C93 _text$mn        ends
.text$mn:00001C93
.text$mn:00001C94 ; ===========================================================================
.text$mn:00001C94
.text$mn:00001C94 ; Segment type: Pure code
.text$mn:00001C94 ; Segment permissions: Read/Execute
.text$mn:00001C94 _text$mn        segment para public 'CODE' use32
.text$mn:00001C94                 assume cs:_text$mn
.text$mn:00001C94                 ;org 1C94h
.text$mn:00001C94 ; COMDAT (pick any)
.text$mn:00001C94                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text$mn:00001C94
.text$mn:00001C94 ; =============== S U B R O U T I N E =======================================
.text$mn:00001C94
.text$mn:00001C94 ; Attributes: bp-based frame
.text$mn:00001C94
.text$mn:00001C94 ; const char *__thiscall std::_System_error_category::name(std::_System_error_category *__hidden this)
.text$mn:00001C94                 public ?name@_System_error_category@std@@UBEPBDXZ
.text$mn:00001C94 ?name@_System_error_category@std@@UBEPBDXZ proc near
.text$mn:00001C94                                         ; DATA XREF: .rdata:00002294o
.text$mn:00001C94
.text$mn:00001C94 var_4           = dword ptr -4
.text$mn:00001C94
.text$mn:00001C94                 push    ebp
.text$mn:00001C95                 mov     ebp, esp
.text$mn:00001C97                 push    ecx
.text$mn:00001C98                 mov     [ebp+var_4], ecx
.text$mn:00001C9B                 mov     eax, offset ??_C@_06FHFOAHML@system?$AA@ ; "system"
.text$mn:00001CA0                 mov     esp, ebp
.text$mn:00001CA2                 pop     ebp
.text$mn:00001CA3                 retn
.text$mn:00001CA3 ?name@_System_error_category@std@@UBEPBDXZ endp
.text$mn:00001CA3
.text$mn:00001CA3 _text$mn        ends
.text$mn:00001CA3
.text$mn:00001CA4 ; ===========================================================================
.text$mn:00001CA4
.text$mn:00001CA4 ; Segment type: Pure code
.text$mn:00001CA4 ; Segment permissions: Read/Execute
.text$mn:00001CA4 _text$mn        segment para public 'CODE' use32
.text$mn:00001CA4                 assume cs:_text$mn
.text$mn:00001CA4                 ;org 1CA4h
.text$mn:00001CA4 ; COMDAT (pick any)
.text$mn:00001CA4                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text$mn:00001CA4
.text$mn:00001CA4 ; =============== S U B R O U T I N E =======================================
.text$mn:00001CA4
.text$mn:00001CA4 ; Attributes: bp-based frame
.text$mn:00001CA4
.text$mn:00001CA4 ; public: unsigned int __thiscall std::basic_string<char, struct std::char_traits<char>, class std::allocator<char>>::size(void)const
.text$mn:00001CA4                 public ?size@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QBEIXZ
.text$mn:00001CA4 ?size@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QBEIXZ proc near
.text$mn:00001CA4                                         ; CODE XREF: std::basic_string<char,std::char_traits<char>,std::allocator<char>>::assign(std::basic_string<char,std::char_traits<char>,std::allocator<char>> const &,uint,uint)+Cp
.text$mn:00001CA4                                         ; std::basic_string<char,std::char_traits<char>,std::allocator<char>>::assign(std::basic_string<char,std::char_traits<char>,std::allocator<char>> const &,uint,uint)+21p
.text$mn:00001CA4
.text$mn:00001CA4 var_4           = dword ptr -4
.text$mn:00001CA4
.text$mn:00001CA4                 push    ebp
.text$mn:00001CA5                 mov     ebp, esp
.text$mn:00001CA7                 push    ecx
.text$mn:00001CA8                 mov     [ebp+var_4], ecx
.text$mn:00001CAB                 mov     eax, [ebp+var_4]
.text$mn:00001CAE                 mov     eax, [eax+14h]
.text$mn:00001CB1                 mov     esp, ebp
.text$mn:00001CB3                 pop     ebp
.text$mn:00001CB4                 retn
.text$mn:00001CB4 ?size@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QBEIXZ endp
.text$mn:00001CB4
.text$mn:00001CB4 ; ---------------------------------------------------------------------------
.text$mn:00001CB5                 align 4
.text$mn:00001CB5 _text$mn        ends
.text$mn:00001CB5
.text$mn:00001CB8 ; ===========================================================================
.text$mn:00001CB8
.text$mn:00001CB8 ; Segment type: Pure code
.text$mn:00001CB8 ; Segment permissions: Read/Execute
.text$mn:00001CB8 _text$mn        segment para public 'CODE' use32
.text$mn:00001CB8                 assume cs:_text$mn
.text$mn:00001CB8                 ;org 1CB8h
.text$mn:00001CB8 ; COMDAT (pick any)
.text$mn:00001CB8                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text$mn:00001CB8
.text$mn:00001CB8 ; =============== S U B R O U T I N E =======================================
.text$mn:00001CB8
.text$mn:00001CB8 ; Attributes: bp-based frame
.text$mn:00001CB8
.text$mn:00001CB8 ; __int32 __stdcall ToolTip::staticWinProc(HWND hWnd, UINT Msg, WPARAM wParam, __int32)
.text$mn:00001CB8                 public ?staticWinProc@ToolTip@@KGJPAUHWND__@@IIJ@Z
.text$mn:00001CB8 ?staticWinProc@ToolTip@@KGJPAUHWND__@@IIJ@Z proc near
.text$mn:00001CB8                                         ; DATA XREF: ToolTip::init(HINSTANCE__ *,HWND__ *)+93o
.text$mn:00001CB8
.text$mn:00001CB8 hWnd            = dword ptr  8
.text$mn:00001CB8 Msg             = dword ptr  0Ch
.text$mn:00001CB8 wParam          = dword ptr  10h
.text$mn:00001CB8 arg_C           = dword ptr  14h
.text$mn:00001CB8
.text$mn:00001CB8                 push    ebp
.text$mn:00001CB9                 mov     ebp, esp
.text$mn:00001CBB                 mov     eax, [ebp+arg_C]
.text$mn:00001CBE                 push    eax             ; __int32
.text$mn:00001CBF                 mov     ecx, [ebp+wParam]
.text$mn:00001CC2                 push    ecx             ; wParam
.text$mn:00001CC3                 mov     edx, [ebp+Msg]
.text$mn:00001CC6                 push    edx             ; Msg
.text$mn:00001CC7                 push    0FFFFFFEBh      ; nIndex
.text$mn:00001CC9                 mov     eax, [ebp+hWnd]
.text$mn:00001CCC                 push    eax             ; hWnd
.text$mn:00001CCD                 call    dword ptr ds:__imp__GetWindowLongW@8 ; GetWindowLongW(x,x)
.text$mn:00001CD3                 mov     ecx, eax        ; this
.text$mn:00001CD5                 call    ?runProc@ToolTip@@IAEJIIJ@Z ; ToolTip::runProc(uint,uint,long)
.text$mn:00001CDA                 pop     ebp
.text$mn:00001CDB                 retn    10h
.text$mn:00001CDB ?staticWinProc@ToolTip@@KGJPAUHWND__@@IIJ@Z endp
.text$mn:00001CDB
.text$mn:00001CDB ; ---------------------------------------------------------------------------
.text$mn:00001CDE                 align 10h
.text$mn:00001CDE _text$mn        ends
.text$mn:00001CDE
.text$mn:00001CE0 ; ===========================================================================
.text$mn:00001CE0
.text$mn:00001CE0 ; Segment type: Pure code
.text$mn:00001CE0 ; Segment permissions: Read/Execute
.text$mn:00001CE0 _text$mn        segment para public 'CODE' use32
.text$mn:00001CE0                 assume cs:_text$mn
.text$mn:00001CE0                 ;org 1CE0h
.text$mn:00001CE0 ; COMDAT (pick any)
.text$mn:00001CE0                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text$mn:00001CE0
.text$mn:00001CE0 ; =============== S U B R O U T I N E =======================================
.text$mn:00001CE0
.text$mn:00001CE0 ; Attributes: bp-based frame
.text$mn:00001CE0
.text$mn:00001CE0 ; const struct std::error_category *__cdecl std::system_category()
.text$mn:00001CE0                 public ?system_category@std@@YAABVerror_category@1@XZ
.text$mn:00001CE0 ?system_category@std@@YAABVerror_category@1@XZ proc near
.text$mn:00001CE0                                         ; CODE XREF: std::_System_error_category::default_error_condition(int):loc_17D0p
.text$mn:00001CE0                 push    ebp
.text$mn:00001CE1                 mov     ebp, esp
.text$mn:00001CE3                 mov     eax, offset ?_System_object@?$_Error_objects@H@std@@2V_System_error_category@2@A ; std::_System_error_category std::_Error_objects<int>::_System_object
.text$mn:00001CE8                 pop     ebp
.text$mn:00001CE9                 retn
.text$mn:00001CE9 ?system_category@std@@YAABVerror_category@1@XZ endp
.text$mn:00001CE9
.text$mn:00001CE9 ; ---------------------------------------------------------------------------
.text$mn:00001CEA                 align 4
.text$mn:00001CEA _text$mn        ends
.text$mn:00001CEA
.text$mn:00001CEC ; ===========================================================================
.text$mn:00001CEC
.text$mn:00001CEC ; Segment type: Pure code
.text$mn:00001CEC ; Segment permissions: Read/Execute
.text$mn:00001CEC _text$mn        segment para public 'CODE' use32
.text$mn:00001CEC                 assume cs:_text$mn
.text$mn:00001CEC                 ;org 1CECh
.text$mn:00001CEC ; COMDAT (pick any)
.text$mn:00001CEC                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text$mn:00001CEC
.text$mn:00001CEC ; =============== S U B R O U T I N E =======================================
.text$mn:00001CEC
.text$mn:00001CEC ; Attributes: bp-based frame
.text$mn:00001CEC
.text$mn:00001CEC ; int __thiscall std::error_code::value(std::error_code *__hidden this)
.text$mn:00001CEC                 public ?value@error_code@std@@QBEHXZ
.text$mn:00001CEC ?value@error_code@std@@QBEHXZ proc near ; CODE XREF: std::error_category::equivalent(std::error_code const &,int)+24p
.text$mn:00001CEC
.text$mn:00001CEC var_4           = dword ptr -4
.text$mn:00001CEC
.text$mn:00001CEC                 push    ebp
.text$mn:00001CED                 mov     ebp, esp
.text$mn:00001CEF                 push    ecx
.text$mn:00001CF0                 mov     [ebp+var_4], ecx
.text$mn:00001CF3                 mov     eax, [ebp+var_4]
.text$mn:00001CF6                 mov     eax, [eax]
.text$mn:00001CF8                 mov     esp, ebp
.text$mn:00001CFA                 pop     ebp
.text$mn:00001CFB                 retn
.text$mn:00001CFB ?value@error_code@std@@QBEHXZ endp
.text$mn:00001CFB
.text$mn:00001CFB _text$mn        ends
.text$mn:00001CFB
.text$mn:00001CFC ; ===========================================================================
.text$mn:00001CFC
.text$mn:00001CFC ; Segment type: Pure code
.text$mn:00001CFC ; Segment permissions: Read/Execute
.text$mn:00001CFC _text$mn        segment para public 'CODE' use32
.text$mn:00001CFC                 assume cs:_text$mn
.text$mn:00001CFC                 ;org 1CFCh
.text$mn:00001CFC ; COMDAT (pick any)
.text$mn:00001CFC                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text$mn:00001CFC
.text$mn:00001CFC ; =============== S U B R O U T I N E =======================================
.text$mn:00001CFC
.text$mn:00001CFC ; Attributes: bp-based frame
.text$mn:00001CFC
.text$mn:00001CFC ; int __thiscall std::error_condition::value(std::error_condition *__hidden this)
.text$mn:00001CFC                 public ?value@error_condition@std@@QBEHXZ
.text$mn:00001CFC ?value@error_condition@std@@QBEHXZ proc near
.text$mn:00001CFC                                         ; CODE XREF: std::error_condition::operator==(std::error_condition const &)+2Cp
.text$mn:00001CFC                                         ; std::error_condition::operator==(std::error_condition const &)+36p
.text$mn:00001CFC
.text$mn:00001CFC var_4           = dword ptr -4
.text$mn:00001CFC
.text$mn:00001CFC                 push    ebp
.text$mn:00001CFD                 mov     ebp, esp
.text$mn:00001CFF                 push    ecx
.text$mn:00001D00                 mov     [ebp+var_4], ecx
.text$mn:00001D03                 mov     eax, [ebp+var_4]
.text$mn:00001D06                 mov     eax, [eax]
.text$mn:00001D08                 mov     esp, ebp
.text$mn:00001D0A                 pop     ebp
.text$mn:00001D0B                 retn
.text$mn:00001D0B ?value@error_condition@std@@QBEHXZ endp
.text$mn:00001D0B
.text$mn:00001D0B _text$mn        ends
.text$mn:00001D0B
.text$mn:00001D0C ; ===========================================================================
.text$mn:00001D0C
.text$mn:00001D0C ; Segment type: Pure code
.text$mn:00001D0C ; Segment permissions: Read/Execute
.text$mn:00001D0C _text$mn        segment para public 'CODE' use32
.text$mn:00001D0C                 assume cs:_text$mn
.text$mn:00001D0C                 ;org 1D0Ch
.text$mn:00001D0C ; COMDAT (pick any)
.text$mn:00001D0C                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text$mn:00001D0C
.text$mn:00001D0C ; =============== S U B R O U T I N E =======================================
.text$mn:00001D0C
.text$mn:00001D0C ; Attributes: bp-based frame
.text$mn:00001D0C
.text$mn:00001D0C                 public _hypot
.text$mn:00001D0C _hypot          proc near
.text$mn:00001D0C
.text$mn:00001D0C var_10          = qword ptr -10h
.text$mn:00001D0C var_8           = qword ptr -8
.text$mn:00001D0C arg_0           = qword ptr  8
.text$mn:00001D0C arg_8           = qword ptr  10h
.text$mn:00001D0C
.text$mn:00001D0C                 push    ebp
.text$mn:00001D0D                 mov     ebp, esp
.text$mn:00001D0F                 sub     esp, 8
.text$mn:00001D12                 movsd   xmm0, [ebp+arg_8]
.text$mn:00001D17                 movsd   [esp+8+var_8], xmm0
.text$mn:00001D1C                 sub     esp, 8
.text$mn:00001D1F                 movsd   xmm0, [ebp+arg_0]
.text$mn:00001D24                 movsd   [esp+10h+var_10], xmm0
.text$mn:00001D29                 call    __hypot
.text$mn:00001D2E                 add     esp, 10h
.text$mn:00001D31                 pop     ebp
.text$mn:00001D32                 retn
.text$mn:00001D32 _hypot          endp
.text$mn:00001D32
.text$mn:00001D32 ; ---------------------------------------------------------------------------
.text$mn:00001D33                 align 4
.text$mn:00001D33 _text$mn        ends
.text$mn:00001D33
.xdata$x:00001D34 ; ===========================================================================
.xdata$x:00001D34
.xdata$x:00001D34 ; Segment type: Pure data
.xdata$x:00001D34 ; Segment permissions: Read
.xdata$x:00001D34 _xdata$x        segment dword public 'DATA' use32
.xdata$x:00001D34                 assume cs:_xdata$x
.xdata$x:00001D34                 ;org 1D34h
.xdata$x:00001D34 ; COMDAT (pick associative to section at 1374)
.xdata$x:00001D34 __unwindtable$?_Orphan_all@_Container_base12@std@@QAEXXZ db 0FFh
.xdata$x:00001D34                                         ; DATA XREF: .xdata$x:00001D44o
.xdata$x:00001D35                 db 0FFh
.xdata$x:00001D36                 db 0FFh
.xdata$x:00001D37                 db 0FFh
.xdata$x:00001D38                 dd offset __unwindfunclet$?_Orphan_all@_Container_base12@std@@QAEXXZ$0
.xdata$x:00001D3C __ehfuncinfo$?_Orphan_all@_Container_base12@std@@QAEXXZ db  22h ; "
.xdata$x:00001D3C                                         ; DATA XREF: __ehhandler$?_Orphan_all@_Container_base12@std@@QAEXXZ+11o
.xdata$x:00001D3D                 db    5
.xdata$x:00001D3E                 db  93h ; รด
.xdata$x:00001D3F                 db  19h
.xdata$x:00001D40                 db    1
.xdata$x:00001D41                 db    0
.xdata$x:00001D42                 db    0
.xdata$x:00001D43                 db    0
.xdata$x:00001D44                 dd offset __unwindtable$?_Orphan_all@_Container_base12@std@@QAEXXZ
.xdata$x:00001D48                 align 20h
.xdata$x:00001D48 _xdata$x        ends
.xdata$x:00001D48
.xdata$x:00001D60 ; ===========================================================================
.xdata$x:00001D60
.xdata$x:00001D60 ; Segment type: Pure data
.xdata$x:00001D60 ; Segment permissions: Read
.xdata$x:00001D60 _xdata$x        segment dword public 'DATA' use32
.xdata$x:00001D60                 assume cs:_xdata$x
.xdata$x:00001D60                 ;org 1D60h
.xdata$x:00001D60 ; COMDAT (pick associative to section at 5D8)
.xdata$x:00001D60 __unwindtable$??0?$_String_val@U?$_Simple_types@D@std@@@std@@QAE@XZ db 0FFh
.xdata$x:00001D60                                         ; DATA XREF: .xdata$x:00001D70o
.xdata$x:00001D61                 db 0FFh
.xdata$x:00001D62                 db 0FFh
.xdata$x:00001D63                 db 0FFh
.xdata$x:00001D64                 dd offset __unwindfunclet$??0?$_String_val@U?$_Simple_types@D@std@@@std@@QAE@XZ$0
.xdata$x:00001D68 __ehfuncinfo$??0?$_String_val@U?$_Simple_types@D@std@@@std@@QAE@XZ db  22h ; "
.xdata$x:00001D68                                         ; DATA XREF: __ehhandler$??0?$_String_val@U?$_Simple_types@D@std@@@std@@QAE@XZ+11o
.xdata$x:00001D69                 db    5
.xdata$x:00001D6A                 db  93h ; รด
.xdata$x:00001D6B                 db  19h
.xdata$x:00001D6C                 db    1
.xdata$x:00001D6D                 db    0
.xdata$x:00001D6E                 db    0
.xdata$x:00001D6F                 db    0
.xdata$x:00001D70                 dd offset __unwindtable$??0?$_String_val@U?$_Simple_types@D@std@@@std@@QAE@XZ
.xdata$x:00001D74                 db    0
.xdata$x:00001D75                 db    0
.xdata$x:00001D76                 db    0
.xdata$x:00001D77                 db    0
.xdata$x:00001D78                 db    0
.xdata$x:00001D79                 db    0
.xdata$x:00001D7A                 db    0
.xdata$x:00001D7B                 db    0
.xdata$x:00001D7C                 db    0
.xdata$x:00001D7D                 db    0
.xdata$x:00001D7E                 db    0
.xdata$x:00001D7F                 db    0
.xdata$x:00001D80                 db    0
.xdata$x:00001D81                 db    0
.xdata$x:00001D82                 db    0
.xdata$x:00001D83                 db    0
.xdata$x:00001D84                 db    0
.xdata$x:00001D85                 db    0
.xdata$x:00001D86                 db    0
.xdata$x:00001D87                 db    0
.xdata$x:00001D88                 db    0
.xdata$x:00001D89                 db    0
.xdata$x:00001D8A                 db    0
.xdata$x:00001D8B                 db    0
.xdata$x:00001D8B _xdata$x        ends
.xdata$x:00001D8B
.xdata$x:00001D8C ; ===========================================================================
.xdata$x:00001D8C
.xdata$x:00001D8C ; Segment type: Pure data
.xdata$x:00001D8C ; Segment permissions: Read
.xdata$x:00001D8C _xdata$x        segment dword public 'DATA' use32
.xdata$x:00001D8C                 assume cs:_xdata$x
.xdata$x:00001D8C                 ;org 1D8Ch
.xdata$x:00001D8C ; COMDAT (pick associative to section at A9C)
.xdata$x:00001D8C __unwindtable$??1?$_String_val@U?$_Simple_types@D@std@@@std@@QAE@XZ db 0FFh
.xdata$x:00001D8C                                         ; DATA XREF: .xdata$x:00001D9Co
.xdata$x:00001D8D                 db 0FFh
.xdata$x:00001D8E                 db 0FFh
.xdata$x:00001D8F                 db 0FFh
.xdata$x:00001D90                 dd offset __unwindfunclet$??1?$_String_val@U?$_Simple_types@D@std@@@std@@QAE@XZ$0
.xdata$x:00001D94 __ehfuncinfo$??1?$_String_val@U?$_Simple_types@D@std@@@std@@QAE@XZ db  22h ; "
.xdata$x:00001D94                                         ; DATA XREF: __ehhandler$??1?$_String_val@U?$_Simple_types@D@std@@@std@@QAE@XZ+11o
.xdata$x:00001D95                 db    5
.xdata$x:00001D96                 db  93h ; รด
.xdata$x:00001D97                 db  19h
.xdata$x:00001D98                 db    1
.xdata$x:00001D99                 db    0
.xdata$x:00001D9A                 db    0
.xdata$x:00001D9B                 db    0
.xdata$x:00001D9C                 dd offset __unwindtable$??1?$_String_val@U?$_Simple_types@D@std@@@std@@QAE@XZ
.xdata$x:00001DA0                 db    0
.xdata$x:00001DA1                 db    0
.xdata$x:00001DA2                 db    0
.xdata$x:00001DA3                 db    0
.xdata$x:00001DA4                 db    0
.xdata$x:00001DA5                 db    0
.xdata$x:00001DA6                 db    0
.xdata$x:00001DA7                 db    0
.xdata$x:00001DA8                 db    0
.xdata$x:00001DA9                 db    0
.xdata$x:00001DAA                 db    0
.xdata$x:00001DAB                 db    0
.xdata$x:00001DAC                 db    0
.xdata$x:00001DAD                 db    0
.xdata$x:00001DAE                 db    0
.xdata$x:00001DAF                 db    0
.xdata$x:00001DB0                 db    0
.xdata$x:00001DB1                 db    0
.xdata$x:00001DB2                 db    0
.xdata$x:00001DB3                 db    0
.xdata$x:00001DB4                 db    0
.xdata$x:00001DB5                 db    0
.xdata$x:00001DB6                 db    0
.xdata$x:00001DB7                 db    0
.xdata$x:00001DB7 _xdata$x        ends
.xdata$x:00001DB7
.xdata$x:00001DB8 ; ===========================================================================
.xdata$x:00001DB8
.xdata$x:00001DB8 ; Segment type: Pure data
.xdata$x:00001DB8 ; Segment permissions: Read
.xdata$x:00001DB8 _xdata$x        segment dword public 'DATA' use32
.xdata$x:00001DB8                 assume cs:_xdata$x
.xdata$x:00001DB8                 ;org 1DB8h
.xdata$x:00001DB8 ; COMDAT (pick associative to section at 55C)
.xdata$x:00001DB8 __unwindtable$??0?$_String_alloc@$0A@U?$_String_base_types@DV?$allocator@D@std@@@std@@@std@@QAE@ABV?$allocator@D@1@@Z db 0FFh
.xdata$x:00001DB8                                         ; DATA XREF: .xdata$x:00001DC8o
.xdata$x:00001DB9                 db 0FFh
.xdata$x:00001DBA                 db 0FFh
.xdata$x:00001DBB                 db 0FFh
.xdata$x:00001DBC                 dd offset __unwindfunclet$??0?$_String_alloc@$0A@U?$_String_base_types@DV?$allocator@D@std@@@std@@@std@@QAE@ABV?$allocator@D@1@@Z$0
.xdata$x:00001DC0 __ehfuncinfo$??0?$_String_alloc@$0A@U?$_String_base_types@DV?$allocator@D@std@@@std@@@std@@QAE@ABV?$allocator@D@1@@Z db  22h ; "
.xdata$x:00001DC0                                         ; DATA XREF: __ehhandler$??0?$_String_alloc@$0A@U?$_String_base_types@DV?$allocator@D@std@@@std@@@std@@QAE@ABV?$allocator@D@1@@Z+11o
.xdata$x:00001DC1                 db    5
.xdata$x:00001DC2                 db  93h ; รด
.xdata$x:00001DC3                 db  19h
.xdata$x:00001DC4                 db    1
.xdata$x:00001DC5                 db    0
.xdata$x:00001DC6                 db    0
.xdata$x:00001DC7                 db    0
.xdata$x:00001DC8                 dd offset __unwindtable$??0?$_String_alloc@$0A@U?$_String_base_types@DV?$allocator@D@std@@@std@@@std@@QAE@ABV?$allocator@D@1@@Z
.xdata$x:00001DCC                 db    0
.xdata$x:00001DCD                 db    0
.xdata$x:00001DCE                 db    0
.xdata$x:00001DCF                 db    0
.xdata$x:00001DD0                 db    0
.xdata$x:00001DD1                 db    0
.xdata$x:00001DD2                 db    0
.xdata$x:00001DD3                 db    0
.xdata$x:00001DD4                 db    0
.xdata$x:00001DD5                 db    0
.xdata$x:00001DD6                 db    0
.xdata$x:00001DD7                 db    0
.xdata$x:00001DD8                 db    0
.xdata$x:00001DD9                 db    0
.xdata$x:00001DDA                 db    0
.xdata$x:00001DDB                 db    0
.xdata$x:00001DDC                 db    0
.xdata$x:00001DDD                 db    0
.xdata$x:00001DDE                 db    0
.xdata$x:00001DDF                 db    0
.xdata$x:00001DE0                 db    0
.xdata$x:00001DE1                 db    0
.xdata$x:00001DE2                 db    0
.xdata$x:00001DE3                 db    0
.xdata$x:00001DE3 _xdata$x        ends
.xdata$x:00001DE3
.xdata$x:00001DE4 ; ===========================================================================
.xdata$x:00001DE4
.xdata$x:00001DE4 ; Segment type: Pure data
.xdata$x:00001DE4 ; Segment permissions: Read
.xdata$x:00001DE4 _xdata$x        segment dword public 'DATA' use32
.xdata$x:00001DE4                 assume cs:_xdata$x
.xdata$x:00001DE4                 ;org 1DE4h
.xdata$x:00001DE4 ; COMDAT (pick associative to section at A24)
.xdata$x:00001DE4 __unwindtable$??1?$_String_alloc@$0A@U?$_String_base_types@DV?$allocator@D@std@@@std@@@std@@QAE@XZ db 0FFh
.xdata$x:00001DE4                                         ; DATA XREF: .xdata$x:00001DF4o
.xdata$x:00001DE5                 db 0FFh
.xdata$x:00001DE6                 db 0FFh
.xdata$x:00001DE7                 db 0FFh
.xdata$x:00001DE8                 dd offset __unwindfunclet$??1?$_String_alloc@$0A@U?$_String_base_types@DV?$allocator@D@std@@@std@@@std@@QAE@XZ$0
.xdata$x:00001DEC __ehfuncinfo$??1?$_String_alloc@$0A@U?$_String_base_types@DV?$allocator@D@std@@@std@@@std@@QAE@XZ db  22h ; "
.xdata$x:00001DEC                                         ; DATA XREF: __ehhandler$??1?$_String_alloc@$0A@U?$_String_base_types@DV?$allocator@D@std@@@std@@@std@@QAE@XZ+11o
.xdata$x:00001DED                 db    5
.xdata$x:00001DEE                 db  93h ; รด
.xdata$x:00001DEF                 db  19h
.xdata$x:00001DF0                 db    1
.xdata$x:00001DF1                 db    0
.xdata$x:00001DF2                 db    0
.xdata$x:00001DF3                 db    0
.xdata$x:00001DF4                 dd offset __unwindtable$??1?$_String_alloc@$0A@U?$_String_base_types@DV?$allocator@D@std@@@std@@@std@@QAE@XZ
.xdata$x:00001DF8                 db    0
.xdata$x:00001DF9                 db    0
.xdata$x:00001DFA                 db    0
.xdata$x:00001DFB                 db    0
.xdata$x:00001DFC                 db    0
.xdata$x:00001DFD                 db    0
.xdata$x:00001DFE                 db    0
.xdata$x:00001DFF                 db    0
.xdata$x:00001E00                 db    0
.xdata$x:00001E01                 db    0
.xdata$x:00001E02                 db    0
.xdata$x:00001E03                 db    0
.xdata$x:00001E04                 db    0
.xdata$x:00001E05                 db    0
.xdata$x:00001E06                 db    0
.xdata$x:00001E07                 db    0
.xdata$x:00001E08                 db    0
.xdata$x:00001E09                 db    0
.xdata$x:00001E0A                 db    0
.xdata$x:00001E0B                 db    0
.xdata$x:00001E0C                 db    0
.xdata$x:00001E0D                 db    0
.xdata$x:00001E0E                 db    0
.xdata$x:00001E0F                 db    0
.xdata$x:00001E0F _xdata$x        ends
.xdata$x:00001E0F
.xdata$x:00001E10 ; ===========================================================================
.xdata$x:00001E10
.xdata$x:00001E10 ; Segment type: Pure data
.xdata$x:00001E10 ; Segment permissions: Read
.xdata$x:00001E10 _xdata$x        segment dword public 'DATA' use32
.xdata$x:00001E10                 assume cs:_xdata$x
.xdata$x:00001E10                 ;org 1E10h
.xdata$x:00001E10 ; COMDAT (pick associative to section at 698)
.xdata$x:00001E10 __unwindtable$??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@PBD@Z db 0FFh
.xdata$x:00001E10                                         ; DATA XREF: .xdata$x:00001E20o
.xdata$x:00001E11                 db 0FFh
.xdata$x:00001E12                 db 0FFh
.xdata$x:00001E13                 db 0FFh
.xdata$x:00001E14                 dd offset __unwindfunclet$??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@PBD@Z$0
.xdata$x:00001E18 __ehfuncinfo$??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@PBD@Z db  22h ; "
.xdata$x:00001E18                                         ; DATA XREF: __ehhandler$??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@PBD@Z+11o
.xdata$x:00001E19                 db    5
.xdata$x:00001E1A                 db  93h ; รด
.xdata$x:00001E1B                 db  19h
.xdata$x:00001E1C                 db    1
.xdata$x:00001E1D                 db    0
.xdata$x:00001E1E                 db    0
.xdata$x:00001E1F                 db    0
.xdata$x:00001E20                 dd offset __unwindtable$??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@PBD@Z
.xdata$x:00001E24                 db    0
.xdata$x:00001E25                 db    0
.xdata$x:00001E26                 db    0
.xdata$x:00001E27                 db    0
.xdata$x:00001E28                 db    0
.xdata$x:00001E29                 db    0
.xdata$x:00001E2A                 db    0
.xdata$x:00001E2B                 db    0
.xdata$x:00001E2C                 db    0
.xdata$x:00001E2D                 db    0
.xdata$x:00001E2E                 db    0
.xdata$x:00001E2F                 db    0
.xdata$x:00001E30                 db    0
.xdata$x:00001E31                 db    0
.xdata$x:00001E32                 db    0
.xdata$x:00001E33                 db    0
.xdata$x:00001E34                 db    0
.xdata$x:00001E35                 db    0
.xdata$x:00001E36                 db    0
.xdata$x:00001E37                 db    0
.xdata$x:00001E38                 db    0
.xdata$x:00001E39                 db    0
.xdata$x:00001E3A                 db    0
.xdata$x:00001E3B                 db    0
.xdata$x:00001E3B _xdata$x        ends
.xdata$x:00001E3B
.xdata$x:00001E3C ; ===========================================================================
.xdata$x:00001E3C
.xdata$x:00001E3C ; Segment type: Pure data
.xdata$x:00001E3C ; Segment permissions: Read
.xdata$x:00001E3C _xdata$x        segment dword public 'DATA' use32
.xdata$x:00001E3C                 assume cs:_xdata$x
.xdata$x:00001E3C                 ;org 1E3Ch
.xdata$x:00001E3C ; COMDAT (pick associative to section at B0C)
.xdata$x:00001E3C __unwindtable$??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ db 0FFh
.xdata$x:00001E3C                                         ; DATA XREF: .xdata$x:00001E4Co
.xdata$x:00001E3D                 db 0FFh
.xdata$x:00001E3E                 db 0FFh
.xdata$x:00001E3F                 db 0FFh
.xdata$x:00001E40                 dd offset __unwindfunclet$??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ$0
.xdata$x:00001E44 __ehfuncinfo$??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ db  22h ; "
.xdata$x:00001E44                                         ; DATA XREF: __ehhandler$??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ+11o
.xdata$x:00001E45                 db    5
.xdata$x:00001E46                 db  93h ; รด
.xdata$x:00001E47                 db  19h
.xdata$x:00001E48                 db    1
.xdata$x:00001E49                 db    0
.xdata$x:00001E4A                 db    0
.xdata$x:00001E4B                 db    0
.xdata$x:00001E4C                 dd offset __unwindtable$??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ
.xdata$x:00001E50                 db    0
.xdata$x:00001E51                 db    0
.xdata$x:00001E52                 db    0
.xdata$x:00001E53                 db    0
.xdata$x:00001E54                 db    0
.xdata$x:00001E55                 db    0
.xdata$x:00001E56                 db    0
.xdata$x:00001E57                 db    0
.xdata$x:00001E58                 db    0
.xdata$x:00001E59                 db    0
.xdata$x:00001E5A                 db    0
.xdata$x:00001E5B                 db    0
.xdata$x:00001E5C                 db    0
.xdata$x:00001E5D                 db    0
.xdata$x:00001E5E                 db    0
.xdata$x:00001E5F                 db    0
.xdata$x:00001E60                 db    0
.xdata$x:00001E61                 db    0
.xdata$x:00001E62                 db    0
.xdata$x:00001E63                 db    0
.xdata$x:00001E64                 db    0
.xdata$x:00001E65                 db    0
.xdata$x:00001E66                 db    0
.xdata$x:00001E67                 db    0
.xdata$x:00001E67 _xdata$x        ends
.xdata$x:00001E67
.xdata$x:00001E68 ; ===========================================================================
.xdata$x:00001E68
.xdata$x:00001E68 ; Segment type: Pure data
.xdata$x:00001E68 ; Segment permissions: Read
.xdata$x:00001E68 _xdata$x        segment dword public 'DATA' use32
.xdata$x:00001E68                 assume cs:_xdata$x
.xdata$x:00001E68                 ;org 1E68h
.xdata$x:00001E68 ; COMDAT (pick associative to section at FD0)
.xdata$x:00001E68 __catchsym$?_Copy@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEXII@Z$5 db    0
.xdata$x:00001E68                                         ; DATA XREF: .xdata$x:00001EF0o
.xdata$x:00001E69                 db    0
.xdata$x:00001E6A                 db    0
.xdata$x:00001E6B                 db    0
.xdata$x:00001E6C                 db    0
.xdata$x:00001E6D                 db    0
.xdata$x:00001E6E                 db    0
.xdata$x:00001E6F                 db    0
.xdata$x:00001E70                 db    0
.xdata$x:00001E71                 db    0
.xdata$x:00001E72                 db    0
.xdata$x:00001E73                 db    0
.xdata$x:00001E74                 dd offset __catch$?_Copy@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEXII@Z$0
.xdata$x:00001E78 __catchsym$?_Copy@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEXII@Z$4 db    0
.xdata$x:00001E78                                         ; DATA XREF: .xdata$x:00001EDCo
.xdata$x:00001E79                 db    0
.xdata$x:00001E7A                 db    0
.xdata$x:00001E7B                 db    0
.xdata$x:00001E7C                 db    0
.xdata$x:00001E7D                 db    0
.xdata$x:00001E7E                 db    0
.xdata$x:00001E7F                 db    0
.xdata$x:00001E80                 db    0
.xdata$x:00001E81                 db    0
.xdata$x:00001E82                 db    0
.xdata$x:00001E83                 db    0
.xdata$x:00001E84                 dd offset __catch$?_Copy@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEXII@Z$1
.xdata$x:00001E88 __unwindtable$?_Copy@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEXII@Z db 0FFh
.xdata$x:00001E88                                         ; DATA XREF: .xdata$x:00001EB0o
.xdata$x:00001E89                 db 0FFh
.xdata$x:00001E8A                 db 0FFh
.xdata$x:00001E8B                 db 0FFh
.xdata$x:00001E8C                 db    0
.xdata$x:00001E8D                 db    0
.xdata$x:00001E8E                 db    0
.xdata$x:00001E8F                 db    0
.xdata$x:00001E90                 db 0FFh
.xdata$x:00001E91                 db 0FFh
.xdata$x:00001E92                 db 0FFh
.xdata$x:00001E93                 db 0FFh
.xdata$x:00001E94                 db    0
.xdata$x:00001E95                 db    0
.xdata$x:00001E96                 db    0
.xdata$x:00001E97                 db    0
.xdata$x:00001E98                 db    1
.xdata$x:00001E99                 db    0
.xdata$x:00001E9A                 db    0
.xdata$x:00001E9B                 db    0
.xdata$x:00001E9C                 db    0
.xdata$x:00001E9D                 db    0
.xdata$x:00001E9E                 db    0
.xdata$x:00001E9F                 db    0
.xdata$x:00001EA0                 db    1
.xdata$x:00001EA1                 db    0
.xdata$x:00001EA2                 db    0
.xdata$x:00001EA3                 db    0
.xdata$x:00001EA4                 db    0
.xdata$x:00001EA5                 db    0
.xdata$x:00001EA6                 db    0
.xdata$x:00001EA7                 db    0
.xdata$x:00001EA8 __ehfuncinfo$?_Copy@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEXII@Z db  22h ; "
.xdata$x:00001EA8                                         ; DATA XREF: __ehhandler$?_Copy@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEXII@Z+11o
.xdata$x:00001EA9                 db    5
.xdata$x:00001EAA                 db  93h ; รด
.xdata$x:00001EAB                 db  19h
.xdata$x:00001EAC                 db    4
.xdata$x:00001EAD                 db    0
.xdata$x:00001EAE                 db    0
.xdata$x:00001EAF                 db    0
.xdata$x:00001EB0                 dd offset __unwindtable$?_Copy@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEXII@Z
.xdata$x:00001EB4                 db    2
.xdata$x:00001EB5                 db    0
.xdata$x:00001EB6                 db    0
.xdata$x:00001EB7                 db    0
.xdata$x:00001EB8                 dd offset __tryblocktable$?_Copy@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEXII@Z
.xdata$x:00001EBC                 db    0
.xdata$x:00001EBD                 db    0
.xdata$x:00001EBE                 db    0
.xdata$x:00001EBF                 db    0
.xdata$x:00001EC0                 db    0
.xdata$x:00001EC1                 db    0
.xdata$x:00001EC2                 db    0
.xdata$x:00001EC3                 db    0
.xdata$x:00001EC4                 db    0
.xdata$x:00001EC5                 db    0
.xdata$x:00001EC6                 db    0
.xdata$x:00001EC7                 db    0
.xdata$x:00001EC8                 db    0
.xdata$x:00001EC9                 db    0
.xdata$x:00001ECA                 db    0
.xdata$x:00001ECB                 db    0
.xdata$x:00001ECC __tryblocktable$?_Copy@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEXII@Z db    2
.xdata$x:00001ECC                                         ; DATA XREF: .xdata$x:00001EB8o
.xdata$x:00001ECD                 db    0
.xdata$x:00001ECE                 db    0
.xdata$x:00001ECF                 db    0
.xdata$x:00001ED0                 db    2
.xdata$x:00001ED1                 db    0
.xdata$x:00001ED2                 db    0
.xdata$x:00001ED3                 db    0
.xdata$x:00001ED4                 db    3
.xdata$x:00001ED5                 db    0
.xdata$x:00001ED6                 db    0
.xdata$x:00001ED7                 db    0
.xdata$x:00001ED8                 db    1
.xdata$x:00001ED9                 db    0
.xdata$x:00001EDA                 db    0
.xdata$x:00001EDB                 db    0
.xdata$x:00001EDC                 dd offset __catchsym$?_Copy@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEXII@Z$4
.xdata$x:00001EE0                 db    0
.xdata$x:00001EE1                 db    0
.xdata$x:00001EE2                 db    0
.xdata$x:00001EE3                 db    0
.xdata$x:00001EE4                 db    0
.xdata$x:00001EE5                 db    0
.xdata$x:00001EE6                 db    0
.xdata$x:00001EE7                 db    0
.xdata$x:00001EE8                 db    3
.xdata$x:00001EE9                 db    0
.xdata$x:00001EEA                 db    0
.xdata$x:00001EEB                 db    0
.xdata$x:00001EEC                 db    1
.xdata$x:00001EED                 db    0
.xdata$x:00001EEE                 db    0
.xdata$x:00001EEF                 db    0
.xdata$x:00001EF0                 dd offset __catchsym$?_Copy@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEXII@Z$5
.xdata$x:00001EF0 _xdata$x        ends
.xdata$x:00001EF0
.xdata$x:00001EF4 ; ===========================================================================
.xdata$x:00001EF4
.xdata$x:00001EF4 ; Segment type: Pure data
.xdata$x:00001EF4 ; Segment permissions: Read
.xdata$x:00001EF4 _xdata$x        segment dword public 'DATA' use32
.xdata$x:00001EF4                 assume cs:_xdata$x
.xdata$x:00001EF4                 ;org 1EF4h
.xdata$x:00001EF4 ; COMDAT (pick associative to section at 9A0)
.xdata$x:00001EF4 __unwindtable$??0runtime_error@std@@QAE@PBD@Z db 0FFh
.xdata$x:00001EF4                                         ; DATA XREF: .xdata$x:00001F04o
.xdata$x:00001EF5                 db 0FFh
.xdata$x:00001EF6                 db 0FFh
.xdata$x:00001EF7                 db 0FFh
.xdata$x:00001EF8                 dd offset __unwindfunclet$??0runtime_error@std@@QAE@PBD@Z$0
.xdata$x:00001EFC __ehfuncinfo$??0runtime_error@std@@QAE@PBD@Z db  22h ; "
.xdata$x:00001EFC                                         ; DATA XREF: __ehhandler$??0runtime_error@std@@QAE@PBD@Z+11o
.xdata$x:00001EFD                 db    5
.xdata$x:00001EFE                 db  93h ; รด
.xdata$x:00001EFF                 db  19h
.xdata$x:00001F00                 db    1
.xdata$x:00001F01                 db    0
.xdata$x:00001F02                 db    0
.xdata$x:00001F03                 db    0
.xdata$x:00001F04                 dd offset __unwindtable$??0runtime_error@std@@QAE@PBD@Z
.xdata$x:00001F08                 align 20h
.xdata$x:00001F08 _xdata$x        ends
.xdata$x:00001F08
.xdata$x:00001F20 ; ===========================================================================
.xdata$x:00001F20
.xdata$x:00001F20 ; Segment type: Pure data
.xdata$x:00001F20 ; Segment permissions: Read
.xdata$x:00001F20 _xdata$x        segment dword public 'DATA' use32
.xdata$x:00001F20                 assume cs:_xdata$x
.xdata$x:00001F20                 ;org 1F20h
.xdata$x:00001F20 ; COMDAT (pick associative to section at D00)
.xdata$x:00001F20 __unwindtable$??1runtime_error@std@@UAE@XZ db 0FFh
.xdata$x:00001F20                                         ; DATA XREF: .xdata$x:00001F30o
.xdata$x:00001F21                 db 0FFh
.xdata$x:00001F22                 db 0FFh
.xdata$x:00001F23                 db 0FFh
.xdata$x:00001F24                 dd offset __unwindfunclet$??1runtime_error@std@@UAE@XZ$0
.xdata$x:00001F28 __ehfuncinfo$??1runtime_error@std@@UAE@XZ db  22h ; "
.xdata$x:00001F28                                         ; DATA XREF: __ehhandler$??1runtime_error@std@@UAE@XZ+11o
.xdata$x:00001F29                 db    5
.xdata$x:00001F2A                 db  93h ; รด
.xdata$x:00001F2B                 db  19h
.xdata$x:00001F2C                 db    1
.xdata$x:00001F2D                 db    0
.xdata$x:00001F2E                 db    0
.xdata$x:00001F2F                 db    0
.xdata$x:00001F30                 dd offset __unwindtable$??1runtime_error@std@@UAE@XZ
.xdata$x:00001F34                 db    0
.xdata$x:00001F35                 db    0
.xdata$x:00001F36                 db    0
.xdata$x:00001F37                 db    0
.xdata$x:00001F38                 db    0
.xdata$x:00001F39                 db    0
.xdata$x:00001F3A                 db    0
.xdata$x:00001F3B                 db    0
.xdata$x:00001F3C                 db    0
.xdata$x:00001F3D                 db    0
.xdata$x:00001F3E                 db    0
.xdata$x:00001F3F                 db    0
.xdata$x:00001F40                 db    0
.xdata$x:00001F41                 db    0
.xdata$x:00001F42                 db    0
.xdata$x:00001F43                 db    0
.xdata$x:00001F44                 db    0
.xdata$x:00001F45                 db    0
.xdata$x:00001F46                 db    0
.xdata$x:00001F47                 db    0
.xdata$x:00001F48                 db    0
.xdata$x:00001F49                 db    0
.xdata$x:00001F4A                 db    0
.xdata$x:00001F4B                 db    0
.xdata$x:00001F4B _xdata$x        ends
.xdata$x:00001F4B
.xdata$x:00001F4C ; ===========================================================================
.xdata$x:00001F4C
.xdata$x:00001F4C ; Segment type: Pure data
.xdata$x:00001F4C ; Segment permissions: Read
.xdata$x:00001F4C _xdata$x        segment dword public 'DATA' use32
.xdata$x:00001F4C                 assume cs:_xdata$x
.xdata$x:00001F4C                 ;org 1F4Ch
.xdata$x:00001F4C ; COMDAT (pick associative to section at 91C)
.xdata$x:00001F4C __unwindtable$??0runtime_error@std@@QAE@ABV01@@Z db 0FFh
.xdata$x:00001F4C                                         ; DATA XREF: .xdata$x:00001F5Co
.xdata$x:00001F4D                 db 0FFh
.xdata$x:00001F4E                 db 0FFh
.xdata$x:00001F4F                 db 0FFh
.xdata$x:00001F50                 dd offset __unwindfunclet$??0runtime_error@std@@QAE@ABV01@@Z$0
.xdata$x:00001F54 __ehfuncinfo$??0runtime_error@std@@QAE@ABV01@@Z db  22h ; "
.xdata$x:00001F54                                         ; DATA XREF: __ehhandler$??0runtime_error@std@@QAE@ABV01@@Z+11o
.xdata$x:00001F55                 db    5
.xdata$x:00001F56                 db  93h ; รด
.xdata$x:00001F57                 db  19h
.xdata$x:00001F58                 db    1
.xdata$x:00001F59                 db    0
.xdata$x:00001F5A                 db    0
.xdata$x:00001F5B                 db    0
.xdata$x:00001F5C                 dd offset __unwindtable$??0runtime_error@std@@QAE@ABV01@@Z
.xdata$x:00001F60                 db    0
.xdata$x:00001F61                 db    0
.xdata$x:00001F62                 db    0
.xdata$x:00001F63                 db    0
.xdata$x:00001F64                 db    0
.xdata$x:00001F65                 db    0
.xdata$x:00001F66                 db    0
.xdata$x:00001F67                 db    0
.xdata$x:00001F68                 db    0
.xdata$x:00001F69                 db    0
.xdata$x:00001F6A                 db    0
.xdata$x:00001F6B                 db    0
.xdata$x:00001F6C                 db    0
.xdata$x:00001F6D                 db    0
.xdata$x:00001F6E                 db    0
.xdata$x:00001F6F                 db    0
.xdata$x:00001F70                 db    0
.xdata$x:00001F71                 db    0
.xdata$x:00001F72                 db    0
.xdata$x:00001F73                 db    0
.xdata$x:00001F74                 db    0
.xdata$x:00001F75                 db    0
.xdata$x:00001F76                 db    0
.xdata$x:00001F77                 db    0
.xdata$x:00001F77 _xdata$x        ends
.xdata$x:00001F77
.xdata$x:00001F78 ; ===========================================================================
.xdata$x:00001F78
.xdata$x:00001F78 ; Segment type: Pure data
.xdata$x:00001F78 ; Segment permissions: Read
.xdata$x:00001F78 _xdata$x        segment dword public 'DATA' use32
.xdata$x:00001F78                 assume cs:_xdata$x
.xdata$x:00001F78                 ;org 1F78h
.xdata$x:00001F78 ; COMDAT (pick associative to section at 76C)
.xdata$x:00001F78 __unwindtable$??0_Generic_error_category@std@@QAE@XZ db 0FFh
.xdata$x:00001F78                                         ; DATA XREF: .xdata$x:00001F88o
.xdata$x:00001F79                 db 0FFh
.xdata$x:00001F7A                 db 0FFh
.xdata$x:00001F7B                 db 0FFh
.xdata$x:00001F7C                 dd offset __unwindfunclet$??0_Generic_error_category@std@@QAE@XZ$0
.xdata$x:00001F80 __ehfuncinfo$??0_Generic_error_category@std@@QAE@XZ db  22h ; "
.xdata$x:00001F80                                         ; DATA XREF: __ehhandler$??0_Generic_error_category@std@@QAE@XZ+11o
.xdata$x:00001F81                 db    5
.xdata$x:00001F82                 db  93h ; รด
.xdata$x:00001F83                 db  19h
.xdata$x:00001F84                 db    1
.xdata$x:00001F85                 db    0
.xdata$x:00001F86                 db    0
.xdata$x:00001F87                 db    0
.xdata$x:00001F88                 dd offset __unwindtable$??0_Generic_error_category@std@@QAE@XZ
.xdata$x:00001F8C                 db    0
.xdata$x:00001F8D                 db    0
.xdata$x:00001F8E                 db    0
.xdata$x:00001F8F                 db    0
.xdata$x:00001F90                 db    0
.xdata$x:00001F91                 db    0
.xdata$x:00001F92                 db    0
.xdata$x:00001F93                 db    0
.xdata$x:00001F94                 db    0
.xdata$x:00001F95                 db    0
.xdata$x:00001F96                 db    0
.xdata$x:00001F97                 db    0
.xdata$x:00001F98                 db    0
.xdata$x:00001F99                 db    0
.xdata$x:00001F9A                 db    0
.xdata$x:00001F9B                 db    0
.xdata$x:00001F9C                 db    0
.xdata$x:00001F9D                 db    0
.xdata$x:00001F9E                 db    0
.xdata$x:00001F9F                 db    0
.xdata$x:00001FA0                 db    0
.xdata$x:00001FA1                 db    0
.xdata$x:00001FA2                 db    0
.xdata$x:00001FA3                 db    0
.xdata$x:00001FA3 _xdata$x        ends
.xdata$x:00001FA3
.xdata$x:00001FA4 ; ===========================================================================
.xdata$x:00001FA4
.xdata$x:00001FA4 ; Segment type: Pure data
.xdata$x:00001FA4 ; Segment permissions: Read
.xdata$x:00001FA4 _xdata$x        segment dword public 'DATA' use32
.xdata$x:00001FA4                 assume cs:_xdata$x
.xdata$x:00001FA4                 ;org 1FA4h
.xdata$x:00001FA4 ; COMDAT (pick associative to section at 1A10)
.xdata$x:00001FA4 __unwindtable$?message@_Generic_error_category@std@@UBE?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@2@H@Z db 0FFh
.xdata$x:00001FA4                                         ; DATA XREF: .xdata$x:00001FB4o
.xdata$x:00001FA5                 db 0FFh
.xdata$x:00001FA6                 db 0FFh
.xdata$x:00001FA7                 db 0FFh
.xdata$x:00001FA8                 dd offset __unwindfunclet$?message@_Generic_error_category@std@@UBE?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@2@H@Z$0
.xdata$x:00001FAC __ehfuncinfo$?message@_Generic_error_category@std@@UBE?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@2@H@Z db  22h ; "
.xdata$x:00001FAC                                         ; DATA XREF: __ehhandler$?message@_Generic_error_category@std@@UBE?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@2@H@Z+11o
.xdata$x:00001FAD                 db    5
.xdata$x:00001FAE                 db  93h ; รด
.xdata$x:00001FAF                 db  19h
.xdata$x:00001FB0                 db    1
.xdata$x:00001FB1                 db    0
.xdata$x:00001FB2                 db    0
.xdata$x:00001FB3                 db    0
.xdata$x:00001FB4                 dd offset __unwindtable$?message@_Generic_error_category@std@@UBE?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@2@H@Z
.xdata$x:00001FB8                 db    0
.xdata$x:00001FB9                 db    0
.xdata$x:00001FBA                 db    0
.xdata$x:00001FBB                 db    0
.xdata$x:00001FBC                 db    0
.xdata$x:00001FBD                 db    0
.xdata$x:00001FBE                 db    0
.xdata$x:00001FBF                 db    0
.xdata$x:00001FC0                 db    0
.xdata$x:00001FC1                 db    0
.xdata$x:00001FC2                 db    0
.xdata$x:00001FC3                 db    0
.xdata$x:00001FC4                 db    0
.xdata$x:00001FC5                 db    0
.xdata$x:00001FC6                 db    0
.xdata$x:00001FC7                 db    0
.xdata$x:00001FC8                 db    0
.xdata$x:00001FC9                 db    0
.xdata$x:00001FCA                 db    0
.xdata$x:00001FCB                 db    0
.xdata$x:00001FCC                 db    0
.xdata$x:00001FCD                 db    0
.xdata$x:00001FCE                 db    0
.xdata$x:00001FCF                 db    0
.xdata$x:00001FCF _xdata$x        ends
.xdata$x:00001FCF
.xdata$x:00001FD0 ; ===========================================================================
.xdata$x:00001FD0
.xdata$x:00001FD0 ; Segment type: Pure data
.xdata$x:00001FD0 ; Segment permissions: Read
.xdata$x:00001FD0 _xdata$x        segment dword public 'DATA' use32
.xdata$x:00001FD0                 assume cs:_xdata$x
.xdata$x:00001FD0                 ;org 1FD0h
.xdata$x:00001FD0 ; COMDAT (pick associative to section at B9C)
.xdata$x:00001FD0 __unwindtable$??1_Generic_error_category@std@@UAE@XZ db 0FFh
.xdata$x:00001FD0                                         ; DATA XREF: .xdata$x:00001FE0o
.xdata$x:00001FD1                 db 0FFh
.xdata$x:00001FD2                 db 0FFh
.xdata$x:00001FD3                 db 0FFh
.xdata$x:00001FD4                 dd offset __unwindfunclet$??1_Generic_error_category@std@@UAE@XZ$0
.xdata$x:00001FD8 __ehfuncinfo$??1_Generic_error_category@std@@UAE@XZ db  22h ; "
.xdata$x:00001FD8                                         ; DATA XREF: __ehhandler$??1_Generic_error_category@std@@UAE@XZ+11o
.xdata$x:00001FD9                 db    5
.xdata$x:00001FDA                 db  93h ; รด
.xdata$x:00001FDB                 db  19h
.xdata$x:00001FDC                 db    1
.xdata$x:00001FDD                 db    0
.xdata$x:00001FDE                 db    0
.xdata$x:00001FDF                 db    0
.xdata$x:00001FE0                 dd offset __unwindtable$??1_Generic_error_category@std@@UAE@XZ
.xdata$x:00001FE4                 db    0
.xdata$x:00001FE5                 db    0
.xdata$x:00001FE6                 db    0
.xdata$x:00001FE7                 db    0
.xdata$x:00001FE8                 db    0
.xdata$x:00001FE9                 db    0
.xdata$x:00001FEA                 db    0
.xdata$x:00001FEB                 db    0
.xdata$x:00001FEC                 db    0
.xdata$x:00001FED                 db    0
.xdata$x:00001FEE                 db    0
.xdata$x:00001FEF                 db    0
.xdata$x:00001FF0                 db    0
.xdata$x:00001FF1                 db    0
.xdata$x:00001FF2                 db    0
.xdata$x:00001FF3                 db    0
.xdata$x:00001FF4                 db    0
.xdata$x:00001FF5                 db    0
.xdata$x:00001FF6                 db    0
.xdata$x:00001FF7                 db    0
.xdata$x:00001FF8                 db    0
.xdata$x:00001FF9                 db    0
.xdata$x:00001FFA                 db    0
.xdata$x:00001FFB                 db    0
.xdata$x:00001FFB _xdata$x        ends
.xdata$x:00001FFB
.xdata$x:00001FFC ; ===========================================================================
.xdata$x:00001FFC
.xdata$x:00001FFC ; Segment type: Pure data
.xdata$x:00001FFC ; Segment permissions: Read
.xdata$x:00001FFC _xdata$x        segment dword public 'DATA' use32
.xdata$x:00001FFC                 assume cs:_xdata$x
.xdata$x:00001FFC                 ;org 1FFCh
.xdata$x:00001FFC ; COMDAT (pick associative to section at 7E8)
.xdata$x:00001FFC __unwindtable$??0_Iostream_error_category@std@@QAE@XZ db 0FFh
.xdata$x:00001FFC                                         ; DATA XREF: .xdata$x:0000200Co
.xdata$x:00001FFD                 db 0FFh
.xdata$x:00001FFE                 db 0FFh
.xdata$x:00001FFF                 db 0FFh
.xdata$x:00002000                 dd offset __unwindfunclet$??0_Iostream_error_category@std@@QAE@XZ$0
.xdata$x:00002004 __ehfuncinfo$??0_Iostream_error_category@std@@QAE@XZ db  22h ; "
.xdata$x:00002004                                         ; DATA XREF: __ehhandler$??0_Iostream_error_category@std@@QAE@XZ+11o
.xdata$x:00002005                 db    5
.xdata$x:00002006                 db  93h ; รด
.xdata$x:00002007                 db  19h
.xdata$x:00002008                 db    1
.xdata$x:00002009                 db    0
.xdata$x:0000200A                 db    0
.xdata$x:0000200B                 db    0
.xdata$x:0000200C                 dd offset __unwindtable$??0_Iostream_error_category@std@@QAE@XZ
.xdata$x:00002010                 db    0
.xdata$x:00002011                 db    0
.xdata$x:00002012                 db    0
.xdata$x:00002013                 db    0
.xdata$x:00002014                 db    0
.xdata$x:00002015                 db    0
.xdata$x:00002016                 db    0
.xdata$x:00002017                 db    0
.xdata$x:00002018                 db    0
.xdata$x:00002019                 db    0
.xdata$x:0000201A                 db    0
.xdata$x:0000201B                 db    0
.xdata$x:0000201C                 db    0
.xdata$x:0000201D                 db    0
.xdata$x:0000201E                 db    0
.xdata$x:0000201F                 db    0
.xdata$x:00002020                 db    0
.xdata$x:00002021                 db    0
.xdata$x:00002022                 db    0
.xdata$x:00002023                 db    0
.xdata$x:00002024                 db    0
.xdata$x:00002025                 db    0
.xdata$x:00002026                 db    0
.xdata$x:00002027                 db    0
.xdata$x:00002027 _xdata$x        ends
.xdata$x:00002027
.xdata$x:00002028 ; ===========================================================================
.xdata$x:00002028
.xdata$x:00002028 ; Segment type: Pure data
.xdata$x:00002028 ; Segment permissions: Read
.xdata$x:00002028 _xdata$x        segment dword public 'DATA' use32
.xdata$x:00002028                 assume cs:_xdata$x
.xdata$x:00002028                 ;org 2028h
.xdata$x:00002028 ; COMDAT (pick associative to section at 1AC8)
.xdata$x:00002028 __unwindtable$?message@_Iostream_error_category@std@@UBE?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@2@H@Z db 0FFh
.xdata$x:00002028                                         ; DATA XREF: .xdata$x:00002038o
.xdata$x:00002029                 db 0FFh
.xdata$x:0000202A                 db 0FFh
.xdata$x:0000202B                 db 0FFh
.xdata$x:0000202C                 dd offset __unwindfunclet$?message@_Iostream_error_category@std@@UBE?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@2@H@Z$0
.xdata$x:00002030 __ehfuncinfo$?message@_Iostream_error_category@std@@UBE?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@2@H@Z db  22h ; "
.xdata$x:00002030                                         ; DATA XREF: __ehhandler$?message@_Iostream_error_category@std@@UBE?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@2@H@Z+11o
.xdata$x:00002031                 db    5
.xdata$x:00002032                 db  93h ; รด
.xdata$x:00002033                 db  19h
.xdata$x:00002034                 db    1
.xdata$x:00002035                 db    0
.xdata$x:00002036                 db    0
.xdata$x:00002037                 db    0
.xdata$x:00002038                 dd offset __unwindtable$?message@_Iostream_error_category@std@@UBE?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@2@H@Z
.xdata$x:0000203C                 db    0
.xdata$x:0000203D                 db    0
.xdata$x:0000203E                 db    0
.xdata$x:0000203F                 db    0
.xdata$x:00002040                 db    0
.xdata$x:00002041                 db    0
.xdata$x:00002042                 db    0
.xdata$x:00002043                 db    0
.xdata$x:00002044                 db    0
.xdata$x:00002045                 db    0
.xdata$x:00002046                 db    0
.xdata$x:00002047                 db    0
.xdata$x:00002048                 db    0
.xdata$x:00002049                 db    0
.xdata$x:0000204A                 db    0
.xdata$x:0000204B                 db    0
.xdata$x:0000204C                 db    0
.xdata$x:0000204D                 db    0
.xdata$x:0000204E                 db    0
.xdata$x:0000204F                 db    0
.xdata$x:00002050                 db    0
.xdata$x:00002051                 db    0
.xdata$x:00002052                 db    0
.xdata$x:00002053                 db    0
.xdata$x:00002053 _xdata$x        ends
.xdata$x:00002053
.xdata$x:00002054 ; ===========================================================================
.xdata$x:00002054
.xdata$x:00002054 ; Segment type: Pure data
.xdata$x:00002054 ; Segment permissions: Read
.xdata$x:00002054 _xdata$x        segment dword public 'DATA' use32
.xdata$x:00002054                 assume cs:_xdata$x
.xdata$x:00002054                 ;org 2054h
.xdata$x:00002054 ; COMDAT (pick associative to section at C0C)
.xdata$x:00002054 __unwindtable$??1_Iostream_error_category@std@@UAE@XZ db 0FFh
.xdata$x:00002054                                         ; DATA XREF: .xdata$x:00002064o
.xdata$x:00002055                 db 0FFh
.xdata$x:00002056                 db 0FFh
.xdata$x:00002057                 db 0FFh
.xdata$x:00002058                 dd offset __unwindfunclet$??1_Iostream_error_category@std@@UAE@XZ$0
.xdata$x:0000205C __ehfuncinfo$??1_Iostream_error_category@std@@UAE@XZ db  22h ; "
.xdata$x:0000205C                                         ; DATA XREF: __ehhandler$??1_Iostream_error_category@std@@UAE@XZ+11o
.xdata$x:0000205D                 db    5
.xdata$x:0000205E                 db  93h ; รด
.xdata$x:0000205F                 db  19h
.xdata$x:00002060                 db    1
.xdata$x:00002061                 db    0
.xdata$x:00002062                 db    0
.xdata$x:00002063                 db    0
.xdata$x:00002064                 dd offset __unwindtable$??1_Iostream_error_category@std@@UAE@XZ
.xdata$x:00002068                 align 20h
.xdata$x:00002068 _xdata$x        ends
.xdata$x:00002068
.xdata$x:00002080 ; ===========================================================================
.xdata$x:00002080
.xdata$x:00002080 ; Segment type: Pure data
.xdata$x:00002080 ; Segment permissions: Read
.xdata$x:00002080 _xdata$x        segment dword public 'DATA' use32
.xdata$x:00002080                 assume cs:_xdata$x
.xdata$x:00002080                 ;org 2080h
.xdata$x:00002080 ; COMDAT (pick associative to section at 864)
.xdata$x:00002080 __unwindtable$??0_System_error_category@std@@QAE@XZ db 0FFh
.xdata$x:00002080                                         ; DATA XREF: .xdata$x:00002090o
.xdata$x:00002081                 db 0FFh
.xdata$x:00002082                 db 0FFh
.xdata$x:00002083                 db 0FFh
.xdata$x:00002084                 dd offset __unwindfunclet$??0_System_error_category@std@@QAE@XZ$0
.xdata$x:00002088 __ehfuncinfo$??0_System_error_category@std@@QAE@XZ db  22h ; "
.xdata$x:00002088                                         ; DATA XREF: __ehhandler$??0_System_error_category@std@@QAE@XZ+11o
.xdata$x:00002089                 db    5
.xdata$x:0000208A                 db  93h ; รด
.xdata$x:0000208B                 db  19h
.xdata$x:0000208C                 db    1
.xdata$x:0000208D                 db    0
.xdata$x:0000208E                 db    0
.xdata$x:0000208F                 db    0
.xdata$x:00002090                 dd offset __unwindtable$??0_System_error_category@std@@QAE@XZ
.xdata$x:00002094                 db    0
.xdata$x:00002095                 db    0
.xdata$x:00002096                 db    0
.xdata$x:00002097                 db    0
.xdata$x:00002098                 db    0
.xdata$x:00002099                 db    0
.xdata$x:0000209A                 db    0
.xdata$x:0000209B                 db    0
.xdata$x:0000209C                 db    0
.xdata$x:0000209D                 db    0
.xdata$x:0000209E                 db    0
.xdata$x:0000209F                 db    0
.xdata$x:000020A0                 db    0
.xdata$x:000020A1                 db    0
.xdata$x:000020A2                 db    0
.xdata$x:000020A3                 db    0
.xdata$x:000020A4                 db    0
.xdata$x:000020A5                 db    0
.xdata$x:000020A6                 db    0
.xdata$x:000020A7                 db    0
.xdata$x:000020A8                 db    0
.xdata$x:000020A9                 db    0
.xdata$x:000020AA                 db    0
.xdata$x:000020AB                 db    0
.xdata$x:000020AB _xdata$x        ends
.xdata$x:000020AB
.xdata$x:000020AC ; ===========================================================================
.xdata$x:000020AC
.xdata$x:000020AC ; Segment type: Pure data
.xdata$x:000020AC ; Segment permissions: Read
.xdata$x:000020AC _xdata$x        segment dword public 'DATA' use32
.xdata$x:000020AC                 assume cs:_xdata$x
.xdata$x:000020AC                 ;org 20ACh
.xdata$x:000020AC ; COMDAT (pick associative to section at 1B8C)
.xdata$x:000020AC __unwindtable$?message@_System_error_category@std@@UBE?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@2@H@Z db 0FFh
.xdata$x:000020AC                                         ; DATA XREF: .xdata$x:000020BCo
.xdata$x:000020AD                 db 0FFh
.xdata$x:000020AE                 db 0FFh
.xdata$x:000020AF                 db 0FFh
.xdata$x:000020B0                 dd offset __unwindfunclet$?message@_System_error_category@std@@UBE?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@2@H@Z$0
.xdata$x:000020B4 __ehfuncinfo$?message@_System_error_category@std@@UBE?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@2@H@Z db  22h ; "
.xdata$x:000020B4                                         ; DATA XREF: __ehhandler$?message@_System_error_category@std@@UBE?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@2@H@Z+11o
.xdata$x:000020B5                 db    5
.xdata$x:000020B6                 db  93h ; รด
.xdata$x:000020B7                 db  19h
.xdata$x:000020B8                 db    1
.xdata$x:000020B9                 db    0
.xdata$x:000020BA                 db    0
.xdata$x:000020BB                 db    0
.xdata$x:000020BC                 dd offset __unwindtable$?message@_System_error_category@std@@UBE?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@2@H@Z
.xdata$x:000020C0                 db    0
.xdata$x:000020C1                 db    0
.xdata$x:000020C2                 db    0
.xdata$x:000020C3                 db    0
.xdata$x:000020C4                 db    0
.xdata$x:000020C5                 db    0
.xdata$x:000020C6                 db    0
.xdata$x:000020C7                 db    0
.xdata$x:000020C8                 db    0
.xdata$x:000020C9                 db    0
.xdata$x:000020CA                 db    0
.xdata$x:000020CB                 db    0
.xdata$x:000020CC                 db    0
.xdata$x:000020CD                 db    0
.xdata$x:000020CE                 db    0
.xdata$x:000020CF                 db    0
.xdata$x:000020D0                 db    0
.xdata$x:000020D1                 db    0
.xdata$x:000020D2                 db    0
.xdata$x:000020D3                 db    0
.xdata$x:000020D4                 db    0
.xdata$x:000020D5                 db    0
.xdata$x:000020D6                 db    0
.xdata$x:000020D7                 db    0
.xdata$x:000020D7 _xdata$x        ends
.xdata$x:000020D7
.xdata$x:000020D8 ; ===========================================================================
.xdata$x:000020D8
.xdata$x:000020D8 ; Segment type: Pure data
.xdata$x:000020D8 ; Segment permissions: Read
.xdata$x:000020D8 _xdata$x        segment dword public 'DATA' use32
.xdata$x:000020D8                 assume cs:_xdata$x
.xdata$x:000020D8                 ;org 20D8h
.xdata$x:000020D8 ; COMDAT (pick associative to section at C7C)
.xdata$x:000020D8 __unwindtable$??1_System_error_category@std@@UAE@XZ db 0FFh
.xdata$x:000020D8                                         ; DATA XREF: .xdata$x:000020E8o
.xdata$x:000020D9                 db 0FFh
.xdata$x:000020DA                 db 0FFh
.xdata$x:000020DB                 db 0FFh
.xdata$x:000020DC                 dd offset __unwindfunclet$??1_System_error_category@std@@UAE@XZ$0
.xdata$x:000020E0 __ehfuncinfo$??1_System_error_category@std@@UAE@XZ db  22h ; "
.xdata$x:000020E0                                         ; DATA XREF: __ehhandler$??1_System_error_category@std@@UAE@XZ+11o
.xdata$x:000020E1                 db    5
.xdata$x:000020E2                 db  93h ; รด
.xdata$x:000020E3                 db  19h
.xdata$x:000020E4                 db    1
.xdata$x:000020E5                 db    0
.xdata$x:000020E6                 db    0
.xdata$x:000020E7                 db    0
.xdata$x:000020E8                 dd offset __unwindtable$??1_System_error_category@std@@UAE@XZ
.xdata$x:000020EC                 db    0
.xdata$x:000020ED                 db    0
.xdata$x:000020EE                 db    0
.xdata$x:000020EF                 db    0
.xdata$x:000020F0                 db    0
.xdata$x:000020F1                 db    0
.xdata$x:000020F2                 db    0
.xdata$x:000020F3                 db    0
.xdata$x:000020F4                 db    0
.xdata$x:000020F5                 db    0
.xdata$x:000020F6                 db    0
.xdata$x:000020F7                 db    0
.xdata$x:000020F8                 db    0
.xdata$x:000020F9                 db    0
.xdata$x:000020FA                 db    0
.xdata$x:000020FB                 db    0
.xdata$x:000020FC                 db    0
.xdata$x:000020FD                 db    0
.xdata$x:000020FE                 db    0
.xdata$x:000020FF                 db    0
.xdata$x:00002100                 db    0
.xdata$x:00002101                 db    0
.xdata$x:00002102                 db    0
.xdata$x:00002103                 db    0
.xdata$x:00002103 _xdata$x        ends
.xdata$x:00002103
.xdata$x:00002104 ; ===========================================================================
.xdata$x:00002104
.xdata$x:00002104 ; Segment type: Pure data
.xdata$x:00002104 ; Segment permissions: Read
.xdata$x:00002104 _xdata$x        segment dword public 'DATA' use32
.xdata$x:00002104                 assume cs:_xdata$x
.xdata$x:00002104                 ;org 2104h
.xdata$x:00002104 ; COMDAT (pick associative to section at 440)
.xdata$x:00002104 __unwindtable$??$construct@U_Container_proxy@std@@U12@@?$allocator@U_Container_proxy@std@@@std@@QAEXPAU_Container_proxy@1@$$QAU21@@Z db 0FFh
.xdata$x:00002104                                         ; DATA XREF: .xdata$x:00002114o
.xdata$x:00002105                 db 0FFh
.xdata$x:00002106                 db 0FFh
.xdata$x:00002107                 db 0FFh
.xdata$x:00002108                 dd offset __unwindfunclet$??$construct@U_Container_proxy@std@@U12@@?$allocator@U_Container_proxy@std@@@std@@QAEXPAU_Container_proxy@1@$$QAU21@@Z$0
.xdata$x:0000210C __ehfuncinfo$??$construct@U_Container_proxy@std@@U12@@?$allocator@U_Container_proxy@std@@@std@@QAEXPAU_Container_proxy@1@$$QAU21@@Z db  22h ; "
.xdata$x:0000210C                                         ; DATA XREF: __ehhandler$??$construct@U_Container_proxy@std@@U12@@?$allocator@U_Container_proxy@std@@@std@@QAEXPAU_Container_proxy@1@$$QAU21@@Z+11o
.xdata$x:0000210D                 db    5
.xdata$x:0000210E                 db  93h ; รด
.xdata$x:0000210F                 db  19h
.xdata$x:00002110                 db    1
.xdata$x:00002111                 db    0
.xdata$x:00002112                 db    0
.xdata$x:00002113                 db    0
.xdata$x:00002114                 dd offset __unwindtable$??$construct@U_Container_proxy@std@@U12@@?$allocator@U_Container_proxy@std@@@std@@QAEXPAU_Container_proxy@1@$$QAU21@@Z
.xdata$x:00002118                 db    0
.xdata$x:00002119                 db    0
.xdata$x:0000211A                 db    0
.xdata$x:0000211B                 db    0
.xdata$x:0000211C                 db    0
.xdata$x:0000211D                 db    0
.xdata$x:0000211E                 db    0
.xdata$x:0000211F                 db    0
.xdata$x:00002120                 db    0
.xdata$x:00002121                 db    0
.xdata$x:00002122                 db    0
.xdata$x:00002123                 db    0
.xdata$x:00002124                 db    0
.xdata$x:00002125                 db    0
.xdata$x:00002126                 db    0
.xdata$x:00002127                 db    0
.xdata$x:00002128                 db    0
.xdata$x:00002129                 db    0
.xdata$x:0000212A                 db    0
.xdata$x:0000212B                 db    0
.xdata$x:0000212C                 db    0
.xdata$x:0000212D                 db    0
.xdata$x:0000212E                 db    0
.xdata$x:0000212F                 db    0
.xdata$x:0000212F _xdata$x        ends
.xdata$x:0000212F
.xdata$x:00002130 ; ===========================================================================
.xdata$x:00002130
.xdata$x:00002130 ; Segment type: Pure data
.xdata$x:00002130 ; Segment permissions: Read
.xdata$x:00002130 _xdata$x        segment dword public 'DATA' use32
.xdata$x:00002130                 assume cs:_xdata$x
.xdata$x:00002130                 ;org 2130h
.xdata$x:00002130 ; COMDAT (pick associative to section at 36C)
.xdata$x:00002130 __unwindtable$??$construct@PADAAPAD@?$allocator@D@std@@QAEXPAPADAAPAD@Z db 0FFh
.xdata$x:00002130                                         ; DATA XREF: .xdata$x:00002140o
.xdata$x:00002131                 db 0FFh
.xdata$x:00002132                 db 0FFh
.xdata$x:00002133                 db 0FFh
.xdata$x:00002134                 dd offset __unwindfunclet$??$construct@PADAAPAD@?$allocator@D@std@@QAEXPAPADAAPAD@Z$0
.xdata$x:00002138 __ehfuncinfo$??$construct@PADAAPAD@?$allocator@D@std@@QAEXPAPADAAPAD@Z db  22h ; "
.xdata$x:00002138                                         ; DATA XREF: __ehhandler$??$construct@PADAAPAD@?$allocator@D@std@@QAEXPAPADAAPAD@Z+11o
.xdata$x:00002139                 db    5
.xdata$x:0000213A                 db  93h ; รด
.xdata$x:0000213B                 db  19h
.xdata$x:0000213C                 db    1
.xdata$x:0000213D                 db    0
.xdata$x:0000213E                 db    0
.xdata$x:0000213F                 db    0
.xdata$x:00002140                 dd offset __unwindtable$??$construct@PADAAPAD@?$allocator@D@std@@QAEXPAPADAAPAD@Z
.xdata$x:00002144                 db    0
.xdata$x:00002145                 db    0
.xdata$x:00002146                 db    0
.xdata$x:00002147                 db    0
.xdata$x:00002148                 db    0
.xdata$x:00002149                 db    0
.xdata$x:0000214A                 db    0
.xdata$x:0000214B                 db    0
.xdata$x:0000214C                 db    0
.xdata$x:0000214D                 db    0
.xdata$x:0000214E                 db    0
.xdata$x:0000214F                 db    0
.xdata$x:00002150                 db    0
.xdata$x:00002151                 db    0
.xdata$x:00002152                 db    0
.xdata$x:00002153                 db    0
.xdata$x:00002154                 db    0
.xdata$x:00002155                 db    0
.xdata$x:00002156                 db    0
.xdata$x:00002157                 db    0
.xdata$x:00002158                 db    0
.xdata$x:00002159                 db    0
.xdata$x:0000215A                 db    0
.xdata$x:0000215B                 db    0
.xdata$x:0000215B _xdata$x        ends
.xdata$x:0000215B
.bss:0000215C ; ===========================================================================
.bss:0000215C
.bss:0000215C ; Segment type: Uninitialized
.bss:0000215C ; Segment permissions: Read/Write
.bss:0000215C _bss            segment byte public 'BSS' use32
.bss:0000215C                 assume cs:_bss
.bss:0000215C                 ;org 215Ch
.bss:0000215C                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.bss:0000215C _allocator_arg  db    ? ;
.bss:0000215D _piecewise_construct db    ? ;
.bss:0000215E                 align 10h
.bss:0000215E _bss            ends
.bss:0000215E
.rdata:00002160 ; ===========================================================================
.rdata:00002160
.rdata:00002160 ; Segment type: Pure data
.rdata:00002160 ; Segment permissions: Read
.rdata:00002160 _rdata          segment dword public 'DATA' use32
.rdata:00002160                 assume cs:_rdata
.rdata:00002160                 ;org 2160h
.rdata:00002160 ; COMDAT (pick largest)
.rdata:00002160                 dd offset ??_R4runtime_error@std@@6B@ ; const std::runtime_error::`RTTI Complete Object Locator'
.rdata:00002164                 public ??_7runtime_error@std@@6B@
.rdata:00002164 ; const std::runtime_error::`vftable'
.rdata:00002164 ??_7runtime_error@std@@6B@ dd offset ??_Eruntime_error@std@@UAEPAXI@Z
.rdata:00002164                                         ; DATA XREF: std::runtime_error::runtime_error(std::runtime_error const &)+3Co
.rdata:00002164                                         ; std::runtime_error::runtime_error(char const *)+3Co
.rdata:00002164                                         ; std::runtime_error::`vector deleting destructor'(uint)
.rdata:00002168                 dd offset ?what@exception@std@@UBEPBDXZ ; std::exception::what(void)
.rdata:00002168 _rdata          ends
.rdata:00002168
.xdata$x:0000216C ; ===========================================================================
.xdata$x:0000216C
.xdata$x:0000216C ; Segment type: Pure data
.xdata$x:0000216C ; Segment permissions: Read
.xdata$x:0000216C _xdata$x        segment dword public 'DATA' use32
.xdata$x:0000216C                 assume cs:_xdata$x
.xdata$x:0000216C                 ;org 216Ch
.xdata$x:0000216C ; COMDAT (pick any)
.xdata$x:0000216C                 public __TI2?AVruntime_error@std@@
.xdata$x:0000216C __TI2?AVruntime_error@std@@ db    0     ; DATA XREF: ToolTip::init(HINSTANCE__ *,HWND__ *)+72o
.xdata$x:0000216D                 db    0
.xdata$x:0000216E                 db    0
.xdata$x:0000216F                 db    0
.xdata$x:00002170                 dd offset ??1runtime_error@std@@UAE@XZ ; std::runtime_error::~runtime_error(void)
.xdata$x:00002174                 align 8
.xdata$x:00002178                 dd offset __CTA2?AVruntime_error@std@@
.xdata$x:00002178 _xdata$x        ends
.xdata$x:00002178
.xdata$x:0000217C ; ===========================================================================
.xdata$x:0000217C
.xdata$x:0000217C ; Segment type: Pure data
.xdata$x:0000217C ; Segment permissions: Read
.xdata$x:0000217C _xdata$x        segment dword public 'DATA' use32
.xdata$x:0000217C                 assume cs:_xdata$x
.xdata$x:0000217C                 ;org 217Ch
.xdata$x:0000217C ; COMDAT (pick any)
.xdata$x:0000217C                 public __CTA2?AVruntime_error@std@@
.xdata$x:0000217C __CTA2?AVruntime_error@std@@ db    2    ; DATA XREF: .xdata$x:00002178o
.xdata$x:0000217D                 db    0
.xdata$x:0000217E                 db    0
.xdata$x:0000217F                 db    0
.xdata$x:00002180                 dd offset __CT??_R0?AVruntime_error@std@@@8??0runtime_error@std@@QAE@ABV01@@Z12
.xdata$x:00002184                 dd offset __CT??_R0?AVexception@std@@@8??0exception@std@@QAE@ABV01@@Z12
.xdata$x:00002184 _xdata$x        ends
.xdata$x:00002184
.data$r:00002188 ; ===========================================================================
.data$r:00002188
.data$r:00002188 ; Segment type: Pure data
.data$r:00002188 ; Segment permissions: Read/Write
.data$r:00002188 _data$r         segment dword public 'DATA' use32
.data$r:00002188                 assume cs:_data$r
.data$r:00002188                 ;org 2188h
.data$r:00002188 ; COMDAT (pick any)
.data$r:00002188                 public ??_R0?AVruntime_error@std@@@8
.data$r:00002188 ; class std::runtime_error `RTTI Type Descriptor'
.data$r:00002188 ??_R0?AVruntime_error@std@@@8 dd offset ??_7type_info@@6B@
.data$r:00002188                                         ; DATA XREF: .xdata$x:000021ACo
.data$r:00002188                                         ; .rdata$r:000023E0o ...
.data$r:00002188                                         ; const type_info::`vftable'
.data$r:0000218C                 align 10h
.data$r:00002190 a_?avruntime_er db '.?AVruntime_error@std@@',0
.data$r:00002190 _data$r         ends
.data$r:00002190
.xdata$x:000021A8 ; ===========================================================================
.xdata$x:000021A8
.xdata$x:000021A8 ; Segment type: Pure data
.xdata$x:000021A8 ; Segment permissions: Read
.xdata$x:000021A8 _xdata$x        segment dword public 'DATA' use32
.xdata$x:000021A8                 assume cs:_xdata$x
.xdata$x:000021A8                 ;org 21A8h
.xdata$x:000021A8 ; COMDAT (pick any)
.xdata$x:000021A8                 public __CT??_R0?AVruntime_error@std@@@8??0runtime_error@std@@QAE@ABV01@@Z12
.xdata$x:000021A8 __CT??_R0?AVruntime_error@std@@@8??0runtime_error@std@@QAE@ABV01@@Z12 db    0
.xdata$x:000021A8                                         ; DATA XREF: .xdata$x:00002180o
.xdata$x:000021A9                 db    0
.xdata$x:000021AA                 db    0
.xdata$x:000021AB                 db    0
.xdata$x:000021AC                 dd offset ??_R0?AVruntime_error@std@@@8 ; std::runtime_error `RTTI Type Descriptor'
.xdata$x:000021B0                 db    0
.xdata$x:000021B1                 db    0
.xdata$x:000021B2                 db    0
.xdata$x:000021B3                 db    0
.xdata$x:000021B4                 db 0FFh
.xdata$x:000021B5                 db 0FFh
.xdata$x:000021B6                 db 0FFh
.xdata$x:000021B7                 db 0FFh
.xdata$x:000021B8                 db    0
.xdata$x:000021B9                 db    0
.xdata$x:000021BA                 db    0
.xdata$x:000021BB                 db    0
.xdata$x:000021BC                 db  0Ch
.xdata$x:000021BD                 db    0
.xdata$x:000021BE                 db    0
.xdata$x:000021BF                 db    0
.xdata$x:000021C0                 dd offset ??0runtime_error@std@@QAE@ABV01@@Z ; std::runtime_error::runtime_error(std::runtime_error const &)
.xdata$x:000021C0 _xdata$x        ends
.xdata$x:000021C0
.data$r:000021C4 ; ===========================================================================
.data$r:000021C4
.data$r:000021C4 ; Segment type: Pure data
.data$r:000021C4 ; Segment permissions: Read/Write
.data$r:000021C4 _data$r         segment dword public 'DATA' use32
.data$r:000021C4                 assume cs:_data$r
.data$r:000021C4                 ;org 21C4h
.data$r:000021C4 ; COMDAT (pick any)
.data$r:000021C4                 public ??_R0?AVexception@std@@@8
.data$r:000021C4 ; class std::exception `RTTI Type Descriptor'
.data$r:000021C4 ??_R0?AVexception@std@@@8 dd offset ??_7type_info@@6B@
.data$r:000021C4                                         ; DATA XREF: .xdata$x:000021E4o
.data$r:000021C4                                         ; .rdata$r:std::exception::`RTTI Base Class Descriptor at (0,-1,0,64)'o
.data$r:000021C4                                         ; const type_info::`vftable'
.data$r:000021C8                 db    0
.data$r:000021C9                 db    0
.data$r:000021CA                 db    0
.data$r:000021CB                 db    0
.data$r:000021CC                 db  2Eh ; .
.data$r:000021CD                 db  3Fh ; ?
.data$r:000021CE                 db  41h ; A
.data$r:000021CF                 db  56h ; V
.data$r:000021D0                 db  65h ; e
.data$r:000021D1                 db  78h ; x
.data$r:000021D2                 db  63h ; c
.data$r:000021D3                 db  65h ; e
.data$r:000021D4                 db  70h ; p
.data$r:000021D5                 db  74h ; t
.data$r:000021D6                 db  69h ; i
.data$r:000021D7                 db  6Fh ; o
.data$r:000021D8                 db  6Eh ; n
.data$r:000021D9                 db  40h ; @
.data$r:000021DA                 db  73h ; s
.data$r:000021DB                 db  74h ; t
.data$r:000021DC                 db  64h ; d
.data$r:000021DD                 db  40h ; @
.data$r:000021DE                 db  40h ; @
.data$r:000021DF                 db    0
.data$r:000021DF _data$r         ends
.data$r:000021DF
.xdata$x:000021E0 ; ===========================================================================
.xdata$x:000021E0
.xdata$x:000021E0 ; Segment type: Pure data
.xdata$x:000021E0 ; Segment permissions: Read
.xdata$x:000021E0 _xdata$x        segment dword public 'DATA' use32
.xdata$x:000021E0                 assume cs:_xdata$x
.xdata$x:000021E0                 ;org 21E0h
.xdata$x:000021E0 ; COMDAT (pick any)
.xdata$x:000021E0                 public __CT??_R0?AVexception@std@@@8??0exception@std@@QAE@ABV01@@Z12
.xdata$x:000021E0 __CT??_R0?AVexception@std@@@8??0exception@std@@QAE@ABV01@@Z12 db    0
.xdata$x:000021E0                                         ; DATA XREF: .xdata$x:00002184o
.xdata$x:000021E1                 db    0
.xdata$x:000021E2                 db    0
.xdata$x:000021E3                 db    0
.xdata$x:000021E4                 dd offset ??_R0?AVexception@std@@@8 ; std::exception `RTTI Type Descriptor'
.xdata$x:000021E8                 db    0
.xdata$x:000021E9                 db    0
.xdata$x:000021EA                 db    0
.xdata$x:000021EB                 db    0
.xdata$x:000021EC                 db 0FFh
.xdata$x:000021ED                 db 0FFh
.xdata$x:000021EE                 db 0FFh
.xdata$x:000021EF                 db 0FFh
.xdata$x:000021F0                 db    0
.xdata$x:000021F1                 db    0
.xdata$x:000021F2                 db    0
.xdata$x:000021F3                 db    0
.xdata$x:000021F4                 db  0Ch
.xdata$x:000021F5                 db    0
.xdata$x:000021F6                 db    0
.xdata$x:000021F7                 db    0
.xdata$x:000021F8                 dd offset ??0exception@std@@QAE@ABV01@@Z ; std::exception::exception(std::exception const &)
.xdata$x:000021F8 _xdata$x        ends
.xdata$x:000021F8
.rdata:000021FC ; ===========================================================================
.rdata:000021FC
.rdata:000021FC ; Segment type: Pure data
.rdata:000021FC ; Segment permissions: Read
.rdata:000021FC _rdata          segment dword public 'DATA' use32
.rdata:000021FC                 assume cs:_rdata
.rdata:000021FC                 ;org 21FCh
.rdata:000021FC ; COMDAT (pick largest)
.rdata:000021FC                 dd offset ??_R4error_category@std@@6B@ ; const std::error_category::`RTTI Complete Object Locator'
.rdata:00002200                 public ??_7error_category@std@@6B@
.rdata:00002200 ; const std::error_category::`vftable'
.rdata:00002200 ??_7error_category@std@@6B@ dd offset ??_Eerror_category@std@@UAEPAXI@Z
.rdata:00002200                                         ; DATA XREF: std::error_category::error_category(void)+Ao
.rdata:00002200                                         ; std::error_category::~error_category(void)+Ao
.rdata:00002200                                         ; std::error_category::`vector deleting destructor'(uint)
.rdata:00002204                 dd offset __purecall
.rdata:00002208                 dd offset __purecall
.rdata:0000220C                 dd offset ?default_error_condition@error_category@std@@UBE?AVerror_condition@2@H@Z ; std::error_category::default_error_condition(int)
.rdata:00002210                 dd offset ?equivalent@error_category@std@@UBE_NABVerror_code@2@H@Z ; std::error_category::equivalent(std::error_code const &,int)
.rdata:00002214                 dd offset ?equivalent@error_category@std@@UBE_NHABVerror_condition@2@@Z ; std::error_category::equivalent(int,std::error_condition const &)
.rdata:00002214 _rdata          ends
.rdata:00002214
.rdata:00002218 ; ===========================================================================
.rdata:00002218
.rdata:00002218 ; Segment type: Pure data
.rdata:00002218 ; Segment permissions: Read
.rdata:00002218 _rdata          segment dword public 'DATA' use32
.rdata:00002218                 assume cs:_rdata
.rdata:00002218                 ;org 2218h
.rdata:00002218 ; COMDAT (pick largest)
.rdata:00002218                 dd offset ??_R4_Generic_error_category@std@@6B@ ; const std::_Generic_error_category::`RTTI Complete Object Locator'
.rdata:0000221C                 public ??_7_Generic_error_category@std@@6B@
.rdata:0000221C ; const std::_Generic_error_category::`vftable'
.rdata:0000221C ??_7_Generic_error_category@std@@6B@ dd offset ??_E_Generic_error_category@std@@UAEPAXI@Z
.rdata:0000221C                                         ; DATA XREF: std::_Generic_error_category::_Generic_error_category(void)+38o
.rdata:0000221C                                         ; std::_Generic_error_category::`vector deleting destructor'(uint)
.rdata:00002220                 dd offset ?name@_Generic_error_category@std@@UBEPBDXZ ; std::_Generic_error_category::name(void)
.rdata:00002224                 dd offset ?message@_Generic_error_category@std@@UBE?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@2@H@Z ; std::_Generic_error_category::message(int)
.rdata:00002228                 dd offset ?default_error_condition@error_category@std@@UBE?AVerror_condition@2@H@Z ; std::error_category::default_error_condition(int)
.rdata:0000222C                 dd offset ?equivalent@error_category@std@@UBE_NABVerror_code@2@H@Z ; std::error_category::equivalent(std::error_code const &,int)
.rdata:00002230                 dd offset ?equivalent@error_category@std@@UBE_NHABVerror_condition@2@@Z ; std::error_category::equivalent(int,std::error_condition const &)
.rdata:00002230 _rdata          ends
.rdata:00002230
.rdata:00002234 ; ===========================================================================
.rdata:00002234
.rdata:00002234 ; Segment type: Pure data
.rdata:00002234 ; Segment permissions: Read
.rdata:00002234 _rdata          segment dword public 'DATA' use32
.rdata:00002234                 assume cs:_rdata
.rdata:00002234                 ;org 2234h
.rdata:00002234 ; COMDAT (pick any)
.rdata:00002234                 public ??_C@_07DCLBNMLN@generic?$AA@
.rdata:00002234 ; `string'
.rdata:00002234 ??_C@_07DCLBNMLN@generic?$AA@ db 'generic',0
.rdata:00002234                                         ; DATA XREF: std::_Generic_error_category::name(void)+7o
.rdata:00002234 _rdata          ends
.rdata:00002234
.rdata:0000223C ; ===========================================================================
.rdata:0000223C
.rdata:0000223C ; Segment type: Pure data
.rdata:0000223C ; Segment permissions: Read
.rdata:0000223C _rdata          segment dword public 'DATA' use32
.rdata:0000223C                 assume cs:_rdata
.rdata:0000223C                 ;org 223Ch
.rdata:0000223C ; COMDAT (pick any)
.rdata:0000223C                 public ??_C@_0O@BFJCFAAK@unknown?5error?$AA@
.rdata:0000223C ; `string'
.rdata:0000223C ??_C@_0O@BFJCFAAK@unknown?5error?$AA@ db 'unknown error',0
.rdata:0000223C                                         ; DATA XREF: std::_Generic_error_category::message(int):loc_1A5Co
.rdata:0000223C                                         ; std::_System_error_category::message(int):loc_1BD8o
.rdata:0000224A                 align 4
.rdata:0000224A _rdata          ends
.rdata:0000224A
.rdata:0000224C ; ===========================================================================
.rdata:0000224C
.rdata:0000224C ; Segment type: Pure data
.rdata:0000224C ; Segment permissions: Read
.rdata:0000224C _rdata          segment dword public 'DATA' use32
.rdata:0000224C                 assume cs:_rdata
.rdata:0000224C                 ;org 224Ch
.rdata:0000224C ; COMDAT (pick largest)
.rdata:0000224C                 dd offset ??_R4_Iostream_error_category@std@@6B@ ; const std::_Iostream_error_category::`RTTI Complete Object Locator'
.rdata:00002250                 public ??_7_Iostream_error_category@std@@6B@
.rdata:00002250 ; const std::_Iostream_error_category::`vftable'
.rdata:00002250 ??_7_Iostream_error_category@std@@6B@ dd offset ??_E_Iostream_error_category@std@@UAEPAXI@Z
.rdata:00002250                                         ; DATA XREF: std::_Iostream_error_category::_Iostream_error_category(void)+38o
.rdata:00002250                                         ; std::_Iostream_error_category::`vector deleting destructor'(uint)
.rdata:00002254                 dd offset ?name@_Iostream_error_category@std@@UBEPBDXZ ; std::_Iostream_error_category::name(void)
.rdata:00002258                 dd offset ?message@_Iostream_error_category@std@@UBE?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@2@H@Z ; std::_Iostream_error_category::message(int)
.rdata:0000225C                 dd offset ?default_error_condition@error_category@std@@UBE?AVerror_condition@2@H@Z ; std::error_category::default_error_condition(int)
.rdata:00002260                 dd offset ?equivalent@error_category@std@@UBE_NABVerror_code@2@H@Z ; std::error_category::equivalent(std::error_code const &,int)
.rdata:00002264                 dd offset ?equivalent@error_category@std@@UBE_NHABVerror_condition@2@@Z ; std::error_category::equivalent(int,std::error_condition const &)
.rdata:00002264 _rdata          ends
.rdata:00002264
.rdata:00002268 ; ===========================================================================
.rdata:00002268
.rdata:00002268 ; Segment type: Pure data
.rdata:00002268 ; Segment permissions: Read
.rdata:00002268 _rdata          segment dword public 'DATA' use32
.rdata:00002268                 assume cs:_rdata
.rdata:00002268                 ;org 2268h
.rdata:00002268 ; COMDAT (pick any)
.rdata:00002268                 public ??_C@_08LLGCOLLL@iostream?$AA@
.rdata:00002268 ; `string'
.rdata:00002268 ??_C@_08LLGCOLLL@iostream?$AA@ db 'iostream',0
.rdata:00002268                                         ; DATA XREF: std::_Iostream_error_category::name(void)+7o
.rdata:00002271                 align 4
.rdata:00002271 _rdata          ends
.rdata:00002271
.rdata:00002274 ; ===========================================================================
.rdata:00002274
.rdata:00002274 ; Segment type: Pure data
.rdata:00002274 ; Segment permissions: Read
.rdata:00002274 _rdata          segment dword public 'DATA' use32
.rdata:00002274                 assume cs:_rdata
.rdata:00002274                 ;org 2274h
.rdata:00002274 ; COMDAT (pick any)
.rdata:00002274                 public ??_C@_0BG@PADBLCHM@iostream?5stream?5error?$AA@
.rdata:00002274 ; char `string'[]
.rdata:00002274 ??_C@_0BG@PADBLCHM@iostream?5stream?5error?$AA@ db 'iostream stream error',0
.rdata:00002274                                         ; DATA XREF: std::_Iostream_error_category::message(int)+35o
.rdata:0000228A                 align 4
.rdata:0000228A _rdata          ends
.rdata:0000228A
.rdata:0000228C ; ===========================================================================
.rdata:0000228C
.rdata:0000228C ; Segment type: Pure data
.rdata:0000228C ; Segment permissions: Read
.rdata:0000228C _rdata          segment dword public 'DATA' use32
.rdata:0000228C                 assume cs:_rdata
.rdata:0000228C                 ;org 228Ch
.rdata:0000228C ; COMDAT (pick largest)
.rdata:0000228C                 dd offset ??_R4_System_error_category@std@@6B@ ; const std::_System_error_category::`RTTI Complete Object Locator'
.rdata:00002290                 public ??_7_System_error_category@std@@6B@
.rdata:00002290 ; const std::_System_error_category::`vftable'
.rdata:00002290 ??_7_System_error_category@std@@6B@ dd offset ??_E_System_error_category@std@@UAEPAXI@Z
.rdata:00002290                                         ; DATA XREF: std::_System_error_category::_System_error_category(void)+38o
.rdata:00002290                                         ; std::_System_error_category::`vector deleting destructor'(uint)
.rdata:00002294                 dd offset ?name@_System_error_category@std@@UBEPBDXZ ; std::_System_error_category::name(void)
.rdata:00002298                 dd offset ?message@_System_error_category@std@@UBE?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@2@H@Z ; std::_System_error_category::message(int)
.rdata:0000229C                 dd offset ?default_error_condition@_System_error_category@std@@UBE?AVerror_condition@2@H@Z ; std::_System_error_category::default_error_condition(int)
.rdata:000022A0                 dd offset ?equivalent@error_category@std@@UBE_NABVerror_code@2@H@Z ; std::error_category::equivalent(std::error_code const &,int)
.rdata:000022A4                 dd offset ?equivalent@error_category@std@@UBE_NHABVerror_condition@2@@Z ; std::error_category::equivalent(int,std::error_condition const &)
.rdata:000022A4 _rdata          ends
.rdata:000022A4
.rdata:000022A8 ; ===========================================================================
.rdata:000022A8
.rdata:000022A8 ; Segment type: Pure data
.rdata:000022A8 ; Segment permissions: Read
.rdata:000022A8 _rdata          segment dword public 'DATA' use32
.rdata:000022A8                 assume cs:_rdata
.rdata:000022A8                 ;org 22A8h
.rdata:000022A8 ; COMDAT (pick any)
.rdata:000022A8                 public ??_C@_06FHFOAHML@system?$AA@
.rdata:000022A8 ; `string'
.rdata:000022A8 ??_C@_06FHFOAHML@system?$AA@ db 'system',0
.rdata:000022A8                                         ; DATA XREF: std::_System_error_category::name(void)+7o
.rdata:000022AF                 align 10h
.rdata:000022AF _rdata          ends
.rdata:000022AF
.bss:000022B0 ; ===========================================================================
.bss:000022B0
.bss:000022B0 ; Segment type: Uninitialized
.bss:000022B0 ; Segment permissions: Read/Write
.bss:000022B0 _bss            segment dword public 'BSS' use32
.bss:000022B0                 assume cs:_bss
.bss:000022B0                 ;org 22B0h
.bss:000022B0 ; COMDAT (pick any)
.bss:000022B0                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.bss:000022B0                 public ?_Generic_object@?$_Error_objects@H@std@@2V_Generic_error_category@2@A
.bss:000022B0 ; std::_Generic_error_category std::_Error_objects<int>::_Generic_object
.bss:000022B0 ?_Generic_object@?$_Error_objects@H@std@@2V_Generic_error_category@2@A db    ? ;
.bss:000022B0                                         ; DATA XREF: `dynamic initializer for 'std::_Generic_error_category std::_Error_objects<int>::_Generic_object''(void)+3o
.bss:000022B0                                         ; `dynamic atexit destructor for 'std::_Generic_error_category std::_Error_objects<int>::_Generic_object''(void)+3o ...
.bss:000022B1                 db    ? ;
.bss:000022B2                 db    ? ;
.bss:000022B3                 db    ? ;
.bss:000022B3 _bss            ends
.bss:000022B3
.bss:000022B4 ; ===========================================================================
.bss:000022B4
.bss:000022B4 ; Segment type: Uninitialized
.bss:000022B4 ; Segment permissions: Read/Write
.bss:000022B4 _bss            segment dword public 'BSS' use32
.bss:000022B4                 assume cs:_bss
.bss:000022B4                 ;org 22B4h
.bss:000022B4 ; COMDAT (pick any)
.bss:000022B4                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.bss:000022B4                 public ?_Iostream_object@?$_Error_objects@H@std@@2V_Iostream_error_category@2@A
.bss:000022B4 ; std::_Iostream_error_category std::_Error_objects<int>::_Iostream_object
.bss:000022B4 ?_Iostream_object@?$_Error_objects@H@std@@2V_Iostream_error_category@2@A db    ? ;
.bss:000022B4                                         ; DATA XREF: `dynamic initializer for 'std::_Iostream_error_category std::_Error_objects<int>::_Iostream_object''(void)+3o
.bss:000022B4                                         ; `dynamic atexit destructor for 'std::_Iostream_error_category std::_Error_objects<int>::_Iostream_object''(void)+3o
.bss:000022B5                 db    ? ;
.bss:000022B6                 db    ? ;
.bss:000022B7                 db    ? ;
.bss:000022B7 _bss            ends
.bss:000022B7
.bss:000022B8 ; ===========================================================================
.bss:000022B8
.bss:000022B8 ; Segment type: Uninitialized
.bss:000022B8 ; Segment permissions: Read/Write
.bss:000022B8 _bss            segment dword public 'BSS' use32
.bss:000022B8                 assume cs:_bss
.bss:000022B8                 ;org 22B8h
.bss:000022B8 ; COMDAT (pick any)
.bss:000022B8                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.bss:000022B8                 public ?_System_object@?$_Error_objects@H@std@@2V_System_error_category@2@A
.bss:000022B8 ; std::_System_error_category std::_Error_objects<int>::_System_object
.bss:000022B8 ?_System_object@?$_Error_objects@H@std@@2V_System_error_category@2@A db    ? ;
.bss:000022B8                                         ; DATA XREF: `dynamic initializer for 'std::_System_error_category std::_Error_objects<int>::_System_object''(void)+3o
.bss:000022B8                                         ; `dynamic atexit destructor for 'std::_System_error_category std::_Error_objects<int>::_System_object''(void)+3o ...
.bss:000022B9                 db    ? ;
.bss:000022BA                 db    ? ;
.bss:000022BB                 db    ? ;
.bss:000022BB _bss            ends
.bss:000022BB
.rdata:000022BC ; ===========================================================================
.rdata:000022BC
.rdata:000022BC ; Segment type: Pure data
.rdata:000022BC ; Segment permissions: Read
.rdata:000022BC ; Segment alignment 'qword' can not be represented in assembly
.rdata:000022BC _rdata          segment para public 'DATA' use32
.rdata:000022BC                 assume cs:_rdata
.rdata:000022BC                 ;org 22BCh
.rdata:000022BC ; COMDAT (pick any)
.rdata:000022BC                 public ??_C@_1IO@FEAPGJBD@?$AAC?$AA?3?$AA?2?$AAP?$AAr?$AAo?$AAg?$AAr?$AAa?$AAm?$AA?5?$AAF?$AAi?$AAl?$AAe?$AAs?$AA?5?$AA?$CI?$AAx?$AA8?$AA6?$AA?$CJ?$AA?2?$AAM?$AAi?$AAc?$AAr?$AAo?$AAs?$AAo?$AAf?$AAt@
.rdata:000022BC ; wchar_t `string'
.rdata:000022BC ??_C@_1IO@FEAPGJBD@?$AAC?$AA?3?$AA?2?$AAP?$AAr?$AAo?$AAg?$AAr?$AAa?$AAm?$AA?5?$AAF?$AAi?$AAl?$AAe?$AAs?$AA?5?$AA?$CI?$AAx?$AA8?$AA6?$AA?$CJ?$AA?2?$AAM?$AAi?$AAc?$AAr?$AAo?$AAs?$AAo?$AAf?$AAt@:
.rdata:000022BC                                         ; DATA XREF: std::basic_string<char,std::char_traits<char>,std::allocator<char>>::assign(char const *)+Co
.rdata:000022BC                                         ; std::basic_string<char,std::char_traits<char>,std::allocator<char>>::assign(char const *,uint)+12o
.rdata:000022BC                 unicode 0, <C:\Program Files (x86)\Microsoft Visual Studio 12.0\VC\in>
.rdata:000022BC                 unicode 0, <clude\xstring>,0
.rdata:0000234A                 align 4
.rdata:0000234A _rdata          ends
.rdata:0000234A
.rdata:0000234C ; ===========================================================================
.rdata:0000234C
.rdata:0000234C ; Segment type: Pure data
.rdata:0000234C ; Segment permissions: Read
.rdata:0000234C _rdata          segment dword public 'DATA' use32
.rdata:0000234C                 assume cs:_rdata
.rdata:0000234C                 ;org 234Ch
.rdata:0000234C ; COMDAT (pick any)
.rdata:0000234C                 public ??_C@_0BA@JFNIOLAK@string?5too?5long?$AA@
.rdata:0000234C ; char `string'[]
.rdata:0000234C ??_C@_0BA@JFNIOLAK@string?5too?5long?$AA@ db 'string too long',0
.rdata:0000234C                                         ; DATA XREF: std::basic_string<char,std::char_traits<char>,std::allocator<char>>::_Xlen(void)+7o
.rdata:0000234C _rdata          ends
.rdata:0000234C
.rdata:0000235C ; ===========================================================================
.rdata:0000235C
.rdata:0000235C ; Segment type: Pure data
.rdata:0000235C ; Segment permissions: Read
.rdata:0000235C _rdata          segment dword public 'DATA' use32
.rdata:0000235C                 assume cs:_rdata
.rdata:0000235C                 ;org 235Ch
.rdata:0000235C ; COMDAT (pick any)
.rdata:0000235C                 public ??_C@_0BI@CFPLBAOH@invalid?5string?5position?$AA@
.rdata:0000235C ; char `string'[]
.rdata:0000235C ??_C@_0BI@CFPLBAOH@invalid?5string?5position?$AA@ db 'invalid string position',0
.rdata:0000235C                                         ; DATA XREF: std::basic_string<char,std::char_traits<char>,std::allocator<char>>::_Xran(void)+7o
.rdata:0000235C _rdata          ends
.rdata:0000235C
.rdata:00002374 ; ===========================================================================
.rdata:00002374
.rdata:00002374 ; Segment type: Pure data
.rdata:00002374 ; Segment permissions: Read
.rdata:00002374 _rdata          segment dword public 'DATA' use32
.rdata:00002374                 assume cs:_rdata
.rdata:00002374                 ;org 2374h
.rdata:00002374 ; COMDAT (pick any)
.rdata:00002374                 public ??_C@_1CK@EOPGIILJ@?$AAi?$AAn?$AAv?$AAa?$AAl?$AAi?$AAd?$AA?5?$AAn?$AAu?$AAl?$AAl?$AA?5?$AAp?$AAo?$AAi?$AAn?$AAt?$AAe?$AAr?$AA?$AA@
.rdata:00002374 ; wchar_t `string'
.rdata:00002374 ??_C@_1CK@EOPGIILJ@?$AAi?$AAn?$AAv?$AAa?$AAl?$AAi?$AAd?$AA?5?$AAn?$AAu?$AAl?$AAl?$AA?5?$AAp?$AAo?$AAi?$AAn?$AAt?$AAe?$AAr?$AA?$AA@:
.rdata:00002374                                         ; DATA XREF: std::_Debug_pointer<char>(char const *,wchar_t const *,uint)+11o
.rdata:00002374                 unicode 0, <invalid null pointer>,0
.rdata:0000239E                 align 10h
.rdata:0000239E _rdata          ends
.rdata:0000239E
.rdata$r:000023A0 ; ===========================================================================
.rdata$r:000023A0
.rdata$r:000023A0 ; Segment type: Pure data
.rdata$r:000023A0 ; Segment permissions: Read
.rdata$r:000023A0 _rdata$r        segment dword public 'DATA' use32
.rdata$r:000023A0                 assume cs:_rdata$r
.rdata$r:000023A0                 ;org 23A0h
.rdata$r:000023A0 ; COMDAT (pick any)
.rdata$r:000023A0                 public ??_R1A@?0A@EA@exception@std@@8
.rdata$r:000023A0 ; std::exception::`RTTI Base Class Descriptor at (0, -1, 0, 64)'
.rdata$r:000023A0 ??_R1A@?0A@EA@exception@std@@8 dd offset ??_R0?AVexception@std@@@8
.rdata$r:000023A0                                         ; DATA XREF: .rdata$r:std::exception::`RTTI Base Class Array'o
.rdata$r:000023A0                                         ; .rdata$r:000023FCo
.rdata$r:000023A0                                         ; std::exception `RTTI Type Descriptor'
.rdata$r:000023A4                 db    0
.rdata$r:000023A5                 db    0
.rdata$r:000023A6                 db    0
.rdata$r:000023A7                 db    0
.rdata$r:000023A8                 db    0
.rdata$r:000023A9                 db    0
.rdata$r:000023AA                 db    0
.rdata$r:000023AB                 db    0
.rdata$r:000023AC                 db 0FFh
.rdata$r:000023AD                 db 0FFh
.rdata$r:000023AE                 db 0FFh
.rdata$r:000023AF                 db 0FFh
.rdata$r:000023B0                 db    0
.rdata$r:000023B1                 db    0
.rdata$r:000023B2                 db    0
.rdata$r:000023B3                 db    0
.rdata$r:000023B4                 db  40h ; @
.rdata$r:000023B5                 db    0
.rdata$r:000023B6                 db    0
.rdata$r:000023B7                 db    0
.rdata$r:000023B8                 dd offset ??_R3exception@std@@8 ; std::exception::`RTTI Class Hierarchy Descriptor'
.rdata$r:000023B8 _rdata$r        ends
.rdata$r:000023B8
.rdata$r:000023BC ; ===========================================================================
.rdata$r:000023BC
.rdata$r:000023BC ; Segment type: Pure data
.rdata$r:000023BC ; Segment permissions: Read
.rdata$r:000023BC _rdata$r        segment dword public 'DATA' use32
.rdata$r:000023BC                 assume cs:_rdata$r
.rdata$r:000023BC                 ;org 23BCh
.rdata$r:000023BC ; COMDAT (pick any)
.rdata$r:000023BC                 public ??_R3exception@std@@8
.rdata$r:000023BC ; std::exception::`RTTI Class Hierarchy Descriptor'
.rdata$r:000023BC ??_R3exception@std@@8 db    0           ; DATA XREF: .rdata$r:000023B8o
.rdata$r:000023BD                 db    0
.rdata$r:000023BE                 db    0
.rdata$r:000023BF                 db    0
.rdata$r:000023C0                 db    0
.rdata$r:000023C1                 db    0
.rdata$r:000023C2                 db    0
.rdata$r:000023C3                 db    0
.rdata$r:000023C4                 db    1
.rdata$r:000023C5                 db    0
.rdata$r:000023C6                 db    0
.rdata$r:000023C7                 db    0
.rdata$r:000023C8                 dd offset ??_R2exception@std@@8 ; std::exception::`RTTI Base Class Array'
.rdata$r:000023C8 _rdata$r        ends
.rdata$r:000023C8
.rdata$r:000023CC ; ===========================================================================
.rdata$r:000023CC
.rdata$r:000023CC ; Segment type: Pure data
.rdata$r:000023CC ; Segment permissions: Read
.rdata$r:000023CC _rdata$r        segment dword public 'DATA' use32
.rdata$r:000023CC                 assume cs:_rdata$r
.rdata$r:000023CC                 ;org 23CCh
.rdata$r:000023CC ; COMDAT (pick any)
.rdata$r:000023CC                 public ??_R2exception@std@@8
.rdata$r:000023CC ; std::exception::`RTTI Base Class Array'
.rdata$r:000023CC ??_R2exception@std@@8 dd offset ??_R1A@?0A@EA@exception@std@@8
.rdata$r:000023CC                                         ; DATA XREF: .rdata$r:000023C8o
.rdata$r:000023CC                                         ; std::exception::`RTTI Base Class Descriptor at (0,-1,0,64)'
.rdata$r:000023D0                 db    0
.rdata$r:000023D1                 align 4
.rdata$r:000023D1 _rdata$r        ends
.rdata$r:000023D1
.rdata$r:000023D4 ; ===========================================================================
.rdata$r:000023D4
.rdata$r:000023D4 ; Segment type: Pure data
.rdata$r:000023D4 ; Segment permissions: Read
.rdata$r:000023D4 _rdata$r        segment dword public 'DATA' use32
.rdata$r:000023D4                 assume cs:_rdata$r
.rdata$r:000023D4                 ;org 23D4h
.rdata$r:000023D4 ; COMDAT (pick any)
.rdata$r:000023D4                 public ??_R4runtime_error@std@@6B@
.rdata$r:000023D4 ; const std::runtime_error::`RTTI Complete Object Locator'
.rdata$r:000023D4 ??_R4runtime_error@std@@6B@ db    0     ; DATA XREF: .rdata:00002160o
.rdata$r:000023D5                 db    0
.rdata$r:000023D6                 db    0
.rdata$r:000023D7                 db    0
.rdata$r:000023D8                 db    0
.rdata$r:000023D9                 db    0
.rdata$r:000023DA                 db    0
.rdata$r:000023DB                 db    0
.rdata$r:000023DC                 db    0
.rdata$r:000023DD                 db    0
.rdata$r:000023DE                 db    0
.rdata$r:000023DF                 db    0
.rdata$r:000023E0                 dd offset ??_R0?AVruntime_error@std@@@8 ; std::runtime_error `RTTI Type Descriptor'
.rdata$r:000023E4                 dd offset ??_R3runtime_error@std@@8 ; std::runtime_error::`RTTI Class Hierarchy Descriptor'
.rdata$r:000023E4 _rdata$r        ends
.rdata$r:000023E4
.rdata$r:000023E8 ; ===========================================================================
.rdata$r:000023E8
.rdata$r:000023E8 ; Segment type: Pure data
.rdata$r:000023E8 ; Segment permissions: Read
.rdata$r:000023E8 _rdata$r        segment dword public 'DATA' use32
.rdata$r:000023E8                 assume cs:_rdata$r
.rdata$r:000023E8                 ;org 23E8h
.rdata$r:000023E8 ; COMDAT (pick any)
.rdata$r:000023E8                 public ??_R3runtime_error@std@@8
.rdata$r:000023E8 ; std::runtime_error::`RTTI Class Hierarchy Descriptor'
.rdata$r:000023E8 ??_R3runtime_error@std@@8 db    0       ; DATA XREF: .rdata$r:000023E4o
.rdata$r:000023E8                                         ; .rdata$r:0000241Co
.rdata$r:000023E9                 db    0
.rdata$r:000023EA                 db    0
.rdata$r:000023EB                 db    0
.rdata$r:000023EC                 db    0
.rdata$r:000023ED                 db    0
.rdata$r:000023EE                 db    0
.rdata$r:000023EF                 db    0
.rdata$r:000023F0                 db    2
.rdata$r:000023F1                 db    0
.rdata$r:000023F2                 db    0
.rdata$r:000023F3                 db    0
.rdata$r:000023F4                 dd offset ??_R2runtime_error@std@@8 ; std::runtime_error::`RTTI Base Class Array'
.rdata$r:000023F4 _rdata$r        ends
.rdata$r:000023F4
.rdata$r:000023F8 ; ===========================================================================
.rdata$r:000023F8
.rdata$r:000023F8 ; Segment type: Pure data
.rdata$r:000023F8 ; Segment permissions: Read
.rdata$r:000023F8 _rdata$r        segment dword public 'DATA' use32
.rdata$r:000023F8                 assume cs:_rdata$r
.rdata$r:000023F8                 ;org 23F8h
.rdata$r:000023F8 ; COMDAT (pick any)
.rdata$r:000023F8                 public ??_R2runtime_error@std@@8
.rdata$r:000023F8 ; std::runtime_error::`RTTI Base Class Array'
.rdata$r:000023F8 ??_R2runtime_error@std@@8 dd offset ??_R1A@?0A@EA@runtime_error@std@@8
.rdata$r:000023F8                                         ; DATA XREF: .rdata$r:000023F4o
.rdata$r:000023F8                                         ; std::runtime_error::`RTTI Base Class Descriptor at (0,-1,0,64)'
.rdata$r:000023FC                 dd offset ??_R1A@?0A@EA@exception@std@@8 ; std::exception::`RTTI Base Class Descriptor at (0,-1,0,64)'
.rdata$r:00002400                 db    0
.rdata$r:00002401                 align 4
.rdata$r:00002401 _rdata$r        ends
.rdata$r:00002401
.rdata$r:00002404 ; ===========================================================================
.rdata$r:00002404
.rdata$r:00002404 ; Segment type: Pure data
.rdata$r:00002404 ; Segment permissions: Read
.rdata$r:00002404 _rdata$r        segment dword public 'DATA' use32
.rdata$r:00002404                 assume cs:_rdata$r
.rdata$r:00002404                 ;org 2404h
.rdata$r:00002404 ; COMDAT (pick any)
.rdata$r:00002404                 public ??_R1A@?0A@EA@runtime_error@std@@8
.rdata$r:00002404 ; std::runtime_error::`RTTI Base Class Descriptor at (0, -1, 0, 64)'
.rdata$r:00002404 ??_R1A@?0A@EA@runtime_error@std@@8 dd offset ??_R0?AVruntime_error@std@@@8
.rdata$r:00002404                                         ; DATA XREF: .rdata$r:std::runtime_error::`RTTI Base Class Array'o
.rdata$r:00002404                                         ; std::runtime_error `RTTI Type Descriptor'
.rdata$r:00002408                 db    1
.rdata$r:00002409                 db    0
.rdata$r:0000240A                 db    0
.rdata$r:0000240B                 db    0
.rdata$r:0000240C                 db    0
.rdata$r:0000240D                 db    0
.rdata$r:0000240E                 db    0
.rdata$r:0000240F                 db    0
.rdata$r:00002410                 db 0FFh
.rdata$r:00002411                 db 0FFh
.rdata$r:00002412                 db 0FFh
.rdata$r:00002413                 db 0FFh
.rdata$r:00002414                 db    0
.rdata$r:00002415                 db    0
.rdata$r:00002416                 db    0
.rdata$r:00002417                 db    0
.rdata$r:00002418                 db  40h ; @
.rdata$r:00002419                 db    0
.rdata$r:0000241A                 db    0
.rdata$r:0000241B                 db    0
.rdata$r:0000241C                 dd offset ??_R3runtime_error@std@@8 ; std::runtime_error::`RTTI Class Hierarchy Descriptor'
.rdata$r:0000241C _rdata$r        ends
.rdata$r:0000241C
.rdata$r:00002420 ; ===========================================================================
.rdata$r:00002420
.rdata$r:00002420 ; Segment type: Pure data
.rdata$r:00002420 ; Segment permissions: Read
.rdata$r:00002420 _rdata$r        segment dword public 'DATA' use32
.rdata$r:00002420                 assume cs:_rdata$r
.rdata$r:00002420                 ;org 2420h
.rdata$r:00002420 ; COMDAT (pick any)
.rdata$r:00002420                 public ??_R4error_category@std@@6B@
.rdata$r:00002420 ; const std::error_category::`RTTI Complete Object Locator'
.rdata$r:00002420 ??_R4error_category@std@@6B@ db    0    ; DATA XREF: .rdata:000021FCo
.rdata$r:00002421                 db    0
.rdata$r:00002422                 db    0
.rdata$r:00002423                 db    0
.rdata$r:00002424                 db    0
.rdata$r:00002425                 db    0
.rdata$r:00002426                 db    0
.rdata$r:00002427                 db    0
.rdata$r:00002428                 db    0
.rdata$r:00002429                 db    0
.rdata$r:0000242A                 db    0
.rdata$r:0000242B                 db    0
.rdata$r:0000242C                 dd offset ??_R0?AVerror_category@std@@@8 ; std::error_category `RTTI Type Descriptor'
.rdata$r:00002430                 dd offset ??_R3error_category@std@@8 ; std::error_category::`RTTI Class Hierarchy Descriptor'
.rdata$r:00002430 _rdata$r        ends
.rdata$r:00002430
.data$r:00002434 ; ===========================================================================
.data$r:00002434
.data$r:00002434 ; Segment type: Pure data
.data$r:00002434 ; Segment permissions: Read/Write
.data$r:00002434 _data$r         segment dword public 'DATA' use32
.data$r:00002434                 assume cs:_data$r
.data$r:00002434                 ;org 2434h
.data$r:00002434 ; COMDAT (pick any)
.data$r:00002434                 public ??_R0?AVerror_category@std@@@8
.data$r:00002434 ; class std::error_category `RTTI Type Descriptor'
.data$r:00002434 ??_R0?AVerror_category@std@@@8 dd offset ??_7type_info@@6B@
.data$r:00002434                                         ; DATA XREF: .rdata$r:0000242Co
.data$r:00002434                                         ; .rdata$r:std::error_category::`RTTI Base Class Descriptor at (0,-1,0,64)'o
.data$r:00002434                                         ; const type_info::`vftable'
.data$r:00002438                 db    0
.data$r:00002439                 db    0
.data$r:0000243A                 db    0
.data$r:0000243B                 db    0
.data$r:0000243C                 db  2Eh ; .
.data$r:0000243D                 db  3Fh ; ?
.data$r:0000243E                 db  41h ; A
.data$r:0000243F                 db  56h ; V
.data$r:00002440                 db  65h ; e
.data$r:00002441                 db  72h ; r
.data$r:00002442                 db  72h ; r
.data$r:00002443                 db  6Fh ; o
.data$r:00002444                 db  72h ; r
.data$r:00002445                 db  5Fh ; _
.data$r:00002446                 db  63h ; c
.data$r:00002447                 db  61h ; a
.data$r:00002448                 db  74h ; t
.data$r:00002449                 db  65h ; e
.data$r:0000244A                 db  67h ; g
.data$r:0000244B                 db  6Fh ; o
.data$r:0000244C                 db  72h ; r
.data$r:0000244D                 db  79h ; y
.data$r:0000244E                 db  40h ; @
.data$r:0000244F                 db  73h ; s
.data$r:00002450                 db  74h ; t
.data$r:00002451                 db  64h ; d
.data$r:00002452                 db  40h ; @
.data$r:00002453                 db  40h ; @
.data$r:00002454                 db    0
.data$r:00002455                 align 4
.data$r:00002455 _data$r         ends
.data$r:00002455
.rdata$r:00002458 ; ===========================================================================
.rdata$r:00002458
.rdata$r:00002458 ; Segment type: Pure data
.rdata$r:00002458 ; Segment permissions: Read
.rdata$r:00002458 _rdata$r        segment dword public 'DATA' use32
.rdata$r:00002458                 assume cs:_rdata$r
.rdata$r:00002458                 ;org 2458h
.rdata$r:00002458 ; COMDAT (pick any)
.rdata$r:00002458                 public ??_R3error_category@std@@8
.rdata$r:00002458 ; std::error_category::`RTTI Class Hierarchy Descriptor'
.rdata$r:00002458 ??_R3error_category@std@@8 db    0      ; DATA XREF: .rdata$r:00002430o
.rdata$r:00002458                                         ; .rdata$r:00002488o
.rdata$r:00002459                 db    0
.rdata$r:0000245A                 db    0
.rdata$r:0000245B                 db    0
.rdata$r:0000245C                 db    0
.rdata$r:0000245D                 db    0
.rdata$r:0000245E                 db    0
.rdata$r:0000245F                 db    0
.rdata$r:00002460                 db    1
.rdata$r:00002461                 db    0
.rdata$r:00002462                 db    0
.rdata$r:00002463                 db    0
.rdata$r:00002464                 dd offset ??_R2error_category@std@@8 ; std::error_category::`RTTI Base Class Array'
.rdata$r:00002464 _rdata$r        ends
.rdata$r:00002464
.rdata$r:00002468 ; ===========================================================================
.rdata$r:00002468
.rdata$r:00002468 ; Segment type: Pure data
.rdata$r:00002468 ; Segment permissions: Read
.rdata$r:00002468 _rdata$r        segment dword public 'DATA' use32
.rdata$r:00002468                 assume cs:_rdata$r
.rdata$r:00002468                 ;org 2468h
.rdata$r:00002468 ; COMDAT (pick any)
.rdata$r:00002468                 public ??_R2error_category@std@@8
.rdata$r:00002468 ; std::error_category::`RTTI Base Class Array'
.rdata$r:00002468 ??_R2error_category@std@@8 dd offset ??_R1A@?0A@EA@error_category@std@@8
.rdata$r:00002468                                         ; DATA XREF: .rdata$r:00002464o
.rdata$r:00002468                                         ; std::error_category::`RTTI Base Class Descriptor at (0,-1,0,64)'
.rdata$r:0000246C                 db    0
.rdata$r:0000246D                 align 10h
.rdata$r:0000246D _rdata$r        ends
.rdata$r:0000246D
.rdata$r:00002470 ; ===========================================================================
.rdata$r:00002470
.rdata$r:00002470 ; Segment type: Pure data
.rdata$r:00002470 ; Segment permissions: Read
.rdata$r:00002470 _rdata$r        segment dword public 'DATA' use32
.rdata$r:00002470                 assume cs:_rdata$r
.rdata$r:00002470                 ;org 2470h
.rdata$r:00002470 ; COMDAT (pick any)
.rdata$r:00002470                 public ??_R1A@?0A@EA@error_category@std@@8
.rdata$r:00002470 ; std::error_category::`RTTI Base Class Descriptor at (0, -1, 0, 64)'
.rdata$r:00002470 ??_R1A@?0A@EA@error_category@std@@8 dd offset ??_R0?AVerror_category@std@@@8
.rdata$r:00002470                                         ; DATA XREF: .rdata$r:std::error_category::`RTTI Base Class Array'o
.rdata$r:00002470                                         ; .rdata$r:000024E0o ...
.rdata$r:00002470                                         ; std::error_category `RTTI Type Descriptor'
.rdata$r:00002474                 db    0
.rdata$r:00002475                 db    0
.rdata$r:00002476                 db    0
.rdata$r:00002477                 db    0
.rdata$r:00002478                 db    0
.rdata$r:00002479                 db    0
.rdata$r:0000247A                 db    0
.rdata$r:0000247B                 db    0
.rdata$r:0000247C                 db 0FFh
.rdata$r:0000247D                 db 0FFh
.rdata$r:0000247E                 db 0FFh
.rdata$r:0000247F                 db 0FFh
.rdata$r:00002480                 db    0
.rdata$r:00002481                 db    0
.rdata$r:00002482                 db    0
.rdata$r:00002483                 db    0
.rdata$r:00002484                 db  40h ; @
.rdata$r:00002485                 db    0
.rdata$r:00002486                 db    0
.rdata$r:00002487                 db    0
.rdata$r:00002488                 dd offset ??_R3error_category@std@@8 ; std::error_category::`RTTI Class Hierarchy Descriptor'
.rdata$r:00002488 _rdata$r        ends
.rdata$r:00002488
.rdata$r:0000248C ; ===========================================================================
.rdata$r:0000248C
.rdata$r:0000248C ; Segment type: Pure data
.rdata$r:0000248C ; Segment permissions: Read
.rdata$r:0000248C _rdata$r        segment dword public 'DATA' use32
.rdata$r:0000248C                 assume cs:_rdata$r
.rdata$r:0000248C                 ;org 248Ch
.rdata$r:0000248C ; COMDAT (pick any)
.rdata$r:0000248C                 public ??_R4_Generic_error_category@std@@6B@
.rdata$r:0000248C ; const std::_Generic_error_category::`RTTI Complete Object Locator'
.rdata$r:0000248C ??_R4_Generic_error_category@std@@6B@ db    0
.rdata$r:0000248C                                         ; DATA XREF: .rdata:00002218o
.rdata$r:0000248D                 db    0
.rdata$r:0000248E                 db    0
.rdata$r:0000248F                 db    0
.rdata$r:00002490                 db    0
.rdata$r:00002491                 db    0
.rdata$r:00002492                 db    0
.rdata$r:00002493                 db    0
.rdata$r:00002494                 db    0
.rdata$r:00002495                 db    0
.rdata$r:00002496                 db    0
.rdata$r:00002497                 db    0
.rdata$r:00002498                 dd offset ??_R0?AV_Generic_error_category@std@@@8 ; std::_Generic_error_category `RTTI Type Descriptor'
.rdata$r:0000249C                 dd offset ??_R3_Generic_error_category@std@@8 ; std::_Generic_error_category::`RTTI Class Hierarchy Descriptor'
.rdata$r:0000249C _rdata$r        ends
.rdata$r:0000249C
.data$r:000024A0 ; ===========================================================================
.data$r:000024A0
.data$r:000024A0 ; Segment type: Pure data
.data$r:000024A0 ; Segment permissions: Read/Write
.data$r:000024A0 _data$r         segment dword public 'DATA' use32
.data$r:000024A0                 assume cs:_data$r
.data$r:000024A0                 ;org 24A0h
.data$r:000024A0 ; COMDAT (pick any)
.data$r:000024A0                 public ??_R0?AV_Generic_error_category@std@@@8
.data$r:000024A0 ; class std::_Generic_error_category `RTTI Type Descriptor'
.data$r:000024A0 ??_R0?AV_Generic_error_category@std@@@8 dd offset ??_7type_info@@6B@
.data$r:000024A0                                         ; DATA XREF: .rdata$r:00002498o
.data$r:000024A0                                         ; .rdata$r:std::_Generic_error_category::`RTTI Base Class Descriptor at (0,-1,0,64)'o
.data$r:000024A0                                         ; const type_info::`vftable'
.data$r:000024A4                 align 8
.data$r:000024A8 a_?av_generic_e db '.?AV_Generic_error_category@std@@',0
.data$r:000024CA                 align 4
.data$r:000024CA _data$r         ends
.data$r:000024CA
.rdata$r:000024CC ; ===========================================================================
.rdata$r:000024CC
.rdata$r:000024CC ; Segment type: Pure data
.rdata$r:000024CC ; Segment permissions: Read
.rdata$r:000024CC _rdata$r        segment dword public 'DATA' use32
.rdata$r:000024CC                 assume cs:_rdata$r
.rdata$r:000024CC                 ;org 24CCh
.rdata$r:000024CC ; COMDAT (pick any)
.rdata$r:000024CC                 public ??_R3_Generic_error_category@std@@8
.rdata$r:000024CC ; std::_Generic_error_category::`RTTI Class Hierarchy Descriptor'
.rdata$r:000024CC ??_R3_Generic_error_category@std@@8 db    0
.rdata$r:000024CC                                         ; DATA XREF: .rdata$r:0000249Co
.rdata$r:000024CC                                         ; .rdata$r:00002500o
.rdata$r:000024CD                 db    0
.rdata$r:000024CE                 db    0
.rdata$r:000024CF                 db    0
.rdata$r:000024D0                 db    0
.rdata$r:000024D1                 db    0
.rdata$r:000024D2                 db    0
.rdata$r:000024D3                 db    0
.rdata$r:000024D4                 db    2
.rdata$r:000024D5                 db    0
.rdata$r:000024D6                 db    0
.rdata$r:000024D7                 db    0
.rdata$r:000024D8                 dd offset ??_R2_Generic_error_category@std@@8 ; std::_Generic_error_category::`RTTI Base Class Array'
.rdata$r:000024D8 _rdata$r        ends
.rdata$r:000024D8
.rdata$r:000024DC ; ===========================================================================
.rdata$r:000024DC
.rdata$r:000024DC ; Segment type: Pure data
.rdata$r:000024DC ; Segment permissions: Read
.rdata$r:000024DC _rdata$r        segment dword public 'DATA' use32
.rdata$r:000024DC                 assume cs:_rdata$r
.rdata$r:000024DC                 ;org 24DCh
.rdata$r:000024DC ; COMDAT (pick any)
.rdata$r:000024DC                 public ??_R2_Generic_error_category@std@@8
.rdata$r:000024DC ; std::_Generic_error_category::`RTTI Base Class Array'
.rdata$r:000024DC ??_R2_Generic_error_category@std@@8 dd offset ??_R1A@?0A@EA@_Generic_error_category@std@@8
.rdata$r:000024DC                                         ; DATA XREF: .rdata$r:000024D8o
.rdata$r:000024DC                                         ; std::_Generic_error_category::`RTTI Base Class Descriptor at (0,-1,0,64)'
.rdata$r:000024E0                 dd offset ??_R1A@?0A@EA@error_category@std@@8 ; std::error_category::`RTTI Base Class Descriptor at (0,-1,0,64)'
.rdata$r:000024E4                 db    0
.rdata$r:000024E5                 align 4
.rdata$r:000024E5 _rdata$r        ends
.rdata$r:000024E5
.rdata$r:000024E8 ; ===========================================================================
.rdata$r:000024E8
.rdata$r:000024E8 ; Segment type: Pure data
.rdata$r:000024E8 ; Segment permissions: Read
.rdata$r:000024E8 _rdata$r        segment dword public 'DATA' use32
.rdata$r:000024E8                 assume cs:_rdata$r
.rdata$r:000024E8                 ;org 24E8h
.rdata$r:000024E8 ; COMDAT (pick any)
.rdata$r:000024E8                 public ??_R1A@?0A@EA@_Generic_error_category@std@@8
.rdata$r:000024E8 ; std::_Generic_error_category::`RTTI Base Class Descriptor at (0, -1, 0, 64)'
.rdata$r:000024E8 ??_R1A@?0A@EA@_Generic_error_category@std@@8 dd offset ??_R0?AV_Generic_error_category@std@@@8
.rdata$r:000024E8                                         ; DATA XREF: .rdata$r:std::_Generic_error_category::`RTTI Base Class Array'o
.rdata$r:000024E8                                         ; .rdata$r:00002558o ...
.rdata$r:000024E8                                         ; std::_Generic_error_category `RTTI Type Descriptor'
.rdata$r:000024EC                 db    1
.rdata$r:000024ED                 db    0
.rdata$r:000024EE                 db    0
.rdata$r:000024EF                 db    0
.rdata$r:000024F0                 db    0
.rdata$r:000024F1                 db    0
.rdata$r:000024F2                 db    0
.rdata$r:000024F3                 db    0
.rdata$r:000024F4                 db 0FFh
.rdata$r:000024F5                 db 0FFh
.rdata$r:000024F6                 db 0FFh
.rdata$r:000024F7                 db 0FFh
.rdata$r:000024F8                 db    0
.rdata$r:000024F9                 db    0
.rdata$r:000024FA                 db    0
.rdata$r:000024FB                 db    0
.rdata$r:000024FC                 db  40h ; @
.rdata$r:000024FD                 db    0
.rdata$r:000024FE                 db    0
.rdata$r:000024FF                 db    0
.rdata$r:00002500                 dd offset ??_R3_Generic_error_category@std@@8 ; std::_Generic_error_category::`RTTI Class Hierarchy Descriptor'
.rdata$r:00002500 _rdata$r        ends
.rdata$r:00002500
.rdata$r:00002504 ; ===========================================================================
.rdata$r:00002504
.rdata$r:00002504 ; Segment type: Pure data
.rdata$r:00002504 ; Segment permissions: Read
.rdata$r:00002504 _rdata$r        segment dword public 'DATA' use32
.rdata$r:00002504                 assume cs:_rdata$r
.rdata$r:00002504                 ;org 2504h
.rdata$r:00002504 ; COMDAT (pick any)
.rdata$r:00002504                 public ??_R4_Iostream_error_category@std@@6B@
.rdata$r:00002504 ; const std::_Iostream_error_category::`RTTI Complete Object Locator'
.rdata$r:00002504 ??_R4_Iostream_error_category@std@@6B@ db    0
.rdata$r:00002504                                         ; DATA XREF: .rdata:0000224Co
.rdata$r:00002505                 db    0
.rdata$r:00002506                 db    0
.rdata$r:00002507                 db    0
.rdata$r:00002508                 db    0
.rdata$r:00002509                 db    0
.rdata$r:0000250A                 db    0
.rdata$r:0000250B                 db    0
.rdata$r:0000250C                 db    0
.rdata$r:0000250D                 db    0
.rdata$r:0000250E                 db    0
.rdata$r:0000250F                 db    0
.rdata$r:00002510                 dd offset ??_R0?AV_Iostream_error_category@std@@@8 ; std::_Iostream_error_category `RTTI Type Descriptor'
.rdata$r:00002514                 dd offset ??_R3_Iostream_error_category@std@@8 ; std::_Iostream_error_category::`RTTI Class Hierarchy Descriptor'
.rdata$r:00002514 _rdata$r        ends
.rdata$r:00002514
.data$r:00002518 ; ===========================================================================
.data$r:00002518
.data$r:00002518 ; Segment type: Pure data
.data$r:00002518 ; Segment permissions: Read/Write
.data$r:00002518 _data$r         segment dword public 'DATA' use32
.data$r:00002518                 assume cs:_data$r
.data$r:00002518                 ;org 2518h
.data$r:00002518 ; COMDAT (pick any)
.data$r:00002518                 public ??_R0?AV_Iostream_error_category@std@@@8
.data$r:00002518 ; class std::_Iostream_error_category `RTTI Type Descriptor'
.data$r:00002518 ??_R0?AV_Iostream_error_category@std@@@8 dd offset ??_7type_info@@6B@
.data$r:00002518                                         ; DATA XREF: .rdata$r:00002510o
.data$r:00002518                                         ; .rdata$r:std::_Iostream_error_category::`RTTI Base Class Descriptor at (0,-1,0,64)'o
.data$r:00002518                                         ; const type_info::`vftable'
.data$r:0000251C                 align 10h
.data$r:00002520 a_?av_iostream_ db '.?AV_Iostream_error_category@std@@',0
.data$r:00002543                 align 4
.data$r:00002543 _data$r         ends
.data$r:00002543
.rdata$r:00002544 ; ===========================================================================
.rdata$r:00002544
.rdata$r:00002544 ; Segment type: Pure data
.rdata$r:00002544 ; Segment permissions: Read
.rdata$r:00002544 _rdata$r        segment dword public 'DATA' use32
.rdata$r:00002544                 assume cs:_rdata$r
.rdata$r:00002544                 ;org 2544h
.rdata$r:00002544 ; COMDAT (pick any)
.rdata$r:00002544                 public ??_R3_Iostream_error_category@std@@8
.rdata$r:00002544 ; std::_Iostream_error_category::`RTTI Class Hierarchy Descriptor'
.rdata$r:00002544 ??_R3_Iostream_error_category@std@@8 db    0
.rdata$r:00002544                                         ; DATA XREF: .rdata$r:00002514o
.rdata$r:00002544                                         ; .rdata$r:0000257Co
.rdata$r:00002545                 db    0
.rdata$r:00002546                 db    0
.rdata$r:00002547                 db    0
.rdata$r:00002548                 db    0
.rdata$r:00002549                 db    0
.rdata$r:0000254A                 db    0
.rdata$r:0000254B                 db    0
.rdata$r:0000254C                 db    3
.rdata$r:0000254D                 db    0
.rdata$r:0000254E                 db    0
.rdata$r:0000254F                 db    0
.rdata$r:00002550                 dd offset ??_R2_Iostream_error_category@std@@8 ; std::_Iostream_error_category::`RTTI Base Class Array'
.rdata$r:00002550 _rdata$r        ends
.rdata$r:00002550
.rdata$r:00002554 ; ===========================================================================
.rdata$r:00002554
.rdata$r:00002554 ; Segment type: Pure data
.rdata$r:00002554 ; Segment permissions: Read
.rdata$r:00002554 _rdata$r        segment dword public 'DATA' use32
.rdata$r:00002554                 assume cs:_rdata$r
.rdata$r:00002554                 ;org 2554h
.rdata$r:00002554 ; COMDAT (pick any)
.rdata$r:00002554                 public ??_R2_Iostream_error_category@std@@8
.rdata$r:00002554 ; std::_Iostream_error_category::`RTTI Base Class Array'
.rdata$r:00002554 ??_R2_Iostream_error_category@std@@8 dd offset ??_R1A@?0A@EA@_Iostream_error_category@std@@8
.rdata$r:00002554                                         ; DATA XREF: .rdata$r:00002550o
.rdata$r:00002554                                         ; std::_Iostream_error_category::`RTTI Base Class Descriptor at (0,-1,0,64)'
.rdata$r:00002558                 dd offset ??_R1A@?0A@EA@_Generic_error_category@std@@8 ; std::_Generic_error_category::`RTTI Base Class Descriptor at (0,-1,0,64)'
.rdata$r:0000255C                 dd offset ??_R1A@?0A@EA@error_category@std@@8 ; std::error_category::`RTTI Base Class Descriptor at (0,-1,0,64)'
.rdata$r:00002560                 db    0
.rdata$r:00002561                 align 4
.rdata$r:00002561 _rdata$r        ends
.rdata$r:00002561
.rdata$r:00002564 ; ===========================================================================
.rdata$r:00002564
.rdata$r:00002564 ; Segment type: Pure data
.rdata$r:00002564 ; Segment permissions: Read
.rdata$r:00002564 _rdata$r        segment dword public 'DATA' use32
.rdata$r:00002564                 assume cs:_rdata$r
.rdata$r:00002564                 ;org 2564h
.rdata$r:00002564 ; COMDAT (pick any)
.rdata$r:00002564                 public ??_R1A@?0A@EA@_Iostream_error_category@std@@8
.rdata$r:00002564 ; std::_Iostream_error_category::`RTTI Base Class Descriptor at (0, -1, 0, 64)'
.rdata$r:00002564 ??_R1A@?0A@EA@_Iostream_error_category@std@@8 dd offset ??_R0?AV_Iostream_error_category@std@@@8
.rdata$r:00002564                                         ; DATA XREF: .rdata$r:std::_Iostream_error_category::`RTTI Base Class Array'o
.rdata$r:00002564                                         ; std::_Iostream_error_category `RTTI Type Descriptor'
.rdata$r:00002568                 db    2
.rdata$r:00002569                 db    0
.rdata$r:0000256A                 db    0
.rdata$r:0000256B                 db    0
.rdata$r:0000256C                 db    0
.rdata$r:0000256D                 db    0
.rdata$r:0000256E                 db    0
.rdata$r:0000256F                 db    0
.rdata$r:00002570                 db 0FFh
.rdata$r:00002571                 db 0FFh
.rdata$r:00002572                 db 0FFh
.rdata$r:00002573                 db 0FFh
.rdata$r:00002574                 db    0
.rdata$r:00002575                 db    0
.rdata$r:00002576                 db    0
.rdata$r:00002577                 db    0
.rdata$r:00002578                 db  40h ; @
.rdata$r:00002579                 db    0
.rdata$r:0000257A                 db    0
.rdata$r:0000257B                 db    0
.rdata$r:0000257C                 dd offset ??_R3_Iostream_error_category@std@@8 ; std::_Iostream_error_category::`RTTI Class Hierarchy Descriptor'
.rdata$r:0000257C _rdata$r        ends
.rdata$r:0000257C
.rdata$r:00002580 ; ===========================================================================
.rdata$r:00002580
.rdata$r:00002580 ; Segment type: Pure data
.rdata$r:00002580 ; Segment permissions: Read
.rdata$r:00002580 _rdata$r        segment dword public 'DATA' use32
.rdata$r:00002580                 assume cs:_rdata$r
.rdata$r:00002580                 ;org 2580h
.rdata$r:00002580 ; COMDAT (pick any)
.rdata$r:00002580                 public ??_R4_System_error_category@std@@6B@
.rdata$r:00002580 ; const std::_System_error_category::`RTTI Complete Object Locator'
.rdata$r:00002580 ??_R4_System_error_category@std@@6B@ db    0 ; DATA XREF: .rdata:0000228Co
.rdata$r:00002581                 db    0
.rdata$r:00002582                 db    0
.rdata$r:00002583                 db    0
.rdata$r:00002584                 db    0
.rdata$r:00002585                 db    0
.rdata$r:00002586                 db    0
.rdata$r:00002587                 db    0
.rdata$r:00002588                 db    0
.rdata$r:00002589                 db    0
.rdata$r:0000258A                 db    0
.rdata$r:0000258B                 db    0
.rdata$r:0000258C                 dd offset ??_R0?AV_System_error_category@std@@@8 ; std::_System_error_category `RTTI Type Descriptor'
.rdata$r:00002590                 dd offset ??_R3_System_error_category@std@@8 ; std::_System_error_category::`RTTI Class Hierarchy Descriptor'
.rdata$r:00002590 _rdata$r        ends
.rdata$r:00002590
.data$r:00002594 ; ===========================================================================
.data$r:00002594
.data$r:00002594 ; Segment type: Pure data
.data$r:00002594 ; Segment permissions: Read/Write
.data$r:00002594 _data$r         segment dword public 'DATA' use32
.data$r:00002594                 assume cs:_data$r
.data$r:00002594                 ;org 2594h
.data$r:00002594 ; COMDAT (pick any)
.data$r:00002594                 public ??_R0?AV_System_error_category@std@@@8
.data$r:00002594 ; class std::_System_error_category `RTTI Type Descriptor'
.data$r:00002594 ??_R0?AV_System_error_category@std@@@8 dd offset ??_7type_info@@6B@
.data$r:00002594                                         ; DATA XREF: .rdata$r:0000258Co
.data$r:00002594                                         ; .rdata$r:std::_System_error_category::`RTTI Base Class Descriptor at (0,-1,0,64)'o
.data$r:00002594                                         ; const type_info::`vftable'
.data$r:00002598                 db    0
.data$r:00002599                 db    0
.data$r:0000259A                 db    0
.data$r:0000259B                 db    0
.data$r:0000259C                 db  2Eh ; .
.data$r:0000259D                 db  3Fh ; ?
.data$r:0000259E                 db  41h ; A
.data$r:0000259F                 db  56h ; V
.data$r:000025A0                 db  5Fh ; _
.data$r:000025A1                 db  53h ; S
.data$r:000025A2                 db  79h ; y
.data$r:000025A3                 db  73h ; s
.data$r:000025A4                 db  74h ; t
.data$r:000025A5                 db  65h ; e
.data$r:000025A6                 db  6Dh ; m
.data$r:000025A7                 db  5Fh ; _
.data$r:000025A8                 db  65h ; e
.data$r:000025A9                 db  72h ; r
.data$r:000025AA                 db  72h ; r
.data$r:000025AB                 db  6Fh ; o
.data$r:000025AC                 db  72h ; r
.data$r:000025AD                 db  5Fh ; _
.data$r:000025AE                 db  63h ; c
.data$r:000025AF                 db  61h ; a
.data$r:000025B0                 db  74h ; t
.data$r:000025B1                 db  65h ; e
.data$r:000025B2                 db  67h ; g
.data$r:000025B3                 db  6Fh ; o
.data$r:000025B4                 db  72h ; r
.data$r:000025B5                 db  79h ; y
.data$r:000025B6                 db  40h ; @
.data$r:000025B7                 db  73h ; s
.data$r:000025B8                 db  74h ; t
.data$r:000025B9                 db  64h ; d
.data$r:000025BA                 db  40h ; @
.data$r:000025BB                 db  40h ; @
.data$r:000025BC                 db    0
.data$r:000025BD                 align 10h
.data$r:000025BD _data$r         ends
.data$r:000025BD
.rdata$r:000025C0 ; ===========================================================================
.rdata$r:000025C0
.rdata$r:000025C0 ; Segment type: Pure data
.rdata$r:000025C0 ; Segment permissions: Read
.rdata$r:000025C0 _rdata$r        segment dword public 'DATA' use32
.rdata$r:000025C0                 assume cs:_rdata$r
.rdata$r:000025C0                 ;org 25C0h
.rdata$r:000025C0 ; COMDAT (pick any)
.rdata$r:000025C0                 public ??_R3_System_error_category@std@@8
.rdata$r:000025C0 ; std::_System_error_category::`RTTI Class Hierarchy Descriptor'
.rdata$r:000025C0 ??_R3_System_error_category@std@@8 db    0 ; DATA XREF: .rdata$r:00002590o
.rdata$r:000025C0                                         ; .rdata$r:000025F8o
.rdata$r:000025C1                 db    0
.rdata$r:000025C2                 db    0
.rdata$r:000025C3                 db    0
.rdata$r:000025C4                 db    0
.rdata$r:000025C5                 db    0
.rdata$r:000025C6                 db    0
.rdata$r:000025C7                 db    0
.rdata$r:000025C8                 db    3
.rdata$r:000025C9                 db    0
.rdata$r:000025CA                 db    0
.rdata$r:000025CB                 db    0
.rdata$r:000025CC                 dd offset ??_R2_System_error_category@std@@8 ; std::_System_error_category::`RTTI Base Class Array'
.rdata$r:000025CC _rdata$r        ends
.rdata$r:000025CC
.rdata$r:000025D0 ; ===========================================================================
.rdata$r:000025D0
.rdata$r:000025D0 ; Segment type: Pure data
.rdata$r:000025D0 ; Segment permissions: Read
.rdata$r:000025D0 _rdata$r        segment dword public 'DATA' use32
.rdata$r:000025D0                 assume cs:_rdata$r
.rdata$r:000025D0                 ;org 25D0h
.rdata$r:000025D0 ; COMDAT (pick any)
.rdata$r:000025D0                 public ??_R2_System_error_category@std@@8
.rdata$r:000025D0 ; std::_System_error_category::`RTTI Base Class Array'
.rdata$r:000025D0 ??_R2_System_error_category@std@@8 dd offset ??_R1A@?0A@EA@_System_error_category@std@@8
.rdata$r:000025D0                                         ; DATA XREF: .rdata$r:000025CCo
.rdata$r:000025D0                                         ; std::_System_error_category::`RTTI Base Class Descriptor at (0,-1,0,64)'
.rdata$r:000025D4                 dd offset ??_R1A@?0A@EA@_Generic_error_category@std@@8 ; std::_Generic_error_category::`RTTI Base Class Descriptor at (0,-1,0,64)'
.rdata$r:000025D8                 dd offset ??_R1A@?0A@EA@error_category@std@@8 ; std::error_category::`RTTI Base Class Descriptor at (0,-1,0,64)'
.rdata$r:000025DC                 db    0
.rdata$r:000025DD                 align 10h
.rdata$r:000025DD _rdata$r        ends
.rdata$r:000025DD
.rdata$r:000025E0 ; ===========================================================================
.rdata$r:000025E0
.rdata$r:000025E0 ; Segment type: Pure data
.rdata$r:000025E0 ; Segment permissions: Read
.rdata$r:000025E0 _rdata$r        segment dword public 'DATA' use32
.rdata$r:000025E0                 assume cs:_rdata$r
.rdata$r:000025E0                 ;org 25E0h
.rdata$r:000025E0 ; COMDAT (pick any)
.rdata$r:000025E0                 public ??_R1A@?0A@EA@_System_error_category@std@@8
.rdata$r:000025E0 ; std::_System_error_category::`RTTI Base Class Descriptor at (0, -1, 0, 64)'
.rdata$r:000025E0 ??_R1A@?0A@EA@_System_error_category@std@@8 dd offset ??_R0?AV_System_error_category@std@@@8
.rdata$r:000025E0                                         ; DATA XREF: .rdata$r:std::_System_error_category::`RTTI Base Class Array'o
.rdata$r:000025E0                                         ; std::_System_error_category `RTTI Type Descriptor'
.rdata$r:000025E4                 db    2
.rdata$r:000025E5                 db    0
.rdata$r:000025E6                 db    0
.rdata$r:000025E7                 db    0
.rdata$r:000025E8                 db    0
.rdata$r:000025E9                 db    0
.rdata$r:000025EA                 db    0
.rdata$r:000025EB                 db    0
.rdata$r:000025EC                 db 0FFh
.rdata$r:000025ED                 db 0FFh
.rdata$r:000025EE                 db 0FFh
.rdata$r:000025EF                 db 0FFh
.rdata$r:000025F0                 db    0
.rdata$r:000025F1                 db    0
.rdata$r:000025F2                 db    0
.rdata$r:000025F3                 db    0
.rdata$r:000025F4                 db  40h ; @
.rdata$r:000025F5                 db    0
.rdata$r:000025F6                 db    0
.rdata$r:000025F7                 db    0
.rdata$r:000025F8                 dd offset ??_R3_System_error_category@std@@8 ; std::_System_error_category::`RTTI Class Hierarchy Descriptor'
.rdata$r:000025F8 _rdata$r        ends
.rdata$r:000025F8
.CRT$XCU:000025FC ; ===========================================================================
.CRT$XCU:000025FC
.CRT$XCU:000025FC ; Segment type: Pure data
.CRT$XCU:000025FC ; Segment permissions: Read
.CRT$XCU:000025FC _CRT$XCU        segment dword public 'DATA' use32
.CRT$XCU:000025FC                 assume cs:_CRT$XCU
.CRT$XCU:000025FC                 ;org 25FCh
.CRT$XCU:000025FC _piecewise_construct$initializer$ dd offset ??__Epiecewise_construct@std@@YAXXZ ; std::`dynamic initializer for 'piecewise_construct''(void)
.CRT$XCU:00002600 _allocator_arg$initializer$ dd offset ??__Eallocator_arg@std@@YAXXZ ; std::`dynamic initializer for 'allocator_arg''(void)
.CRT$XCU:00002600 _CRT$XCU        ends
.CRT$XCU:00002600
.CRT$XCU:00002604 ; ===========================================================================
.CRT$XCU:00002604
.CRT$XCU:00002604 ; Segment type: Pure data
.CRT$XCU:00002604 ; Segment permissions: Read
.CRT$XCU:00002604 _CRT$XCU        segment dword public 'DATA' use32
.CRT$XCU:00002604                 assume cs:_CRT$XCU
.CRT$XCU:00002604                 ;org 2604h
.CRT$XCU:00002604 ; COMDAT (pick associative to section at 22B0)
.CRT$XCU:00002604 ; public: static void (__cdecl *std::_Error_objects<int>::_Generic_object$initializer$)(void)
.CRT$XCU:00002604 ?_Generic_object$initializer$@?$_Error_objects@H@std@@2P6AXXZA dd offset ??__E?_Generic_object@?$_Error_objects@H@std@@2V_Generic_error_category@2@A@@YAXXZ ; `dynamic initializer for 'std::_Generic_error_category std::_Error_objects<int>::_Generic_object''(void)
.CRT$XCU:00002604 _CRT$XCU        ends
.CRT$XCU:00002604
.CRT$XCU:00002608 ; ===========================================================================
.CRT$XCU:00002608
.CRT$XCU:00002608 ; Segment type: Pure data
.CRT$XCU:00002608 ; Segment permissions: Read
.CRT$XCU:00002608 _CRT$XCU        segment dword public 'DATA' use32
.CRT$XCU:00002608                 assume cs:_CRT$XCU
.CRT$XCU:00002608                 ;org 2608h
.CRT$XCU:00002608 ; COMDAT (pick associative to section at 22B4)
.CRT$XCU:00002608 ; public: static void (__cdecl *std::_Error_objects<int>::_Iostream_object$initializer$)(void)
.CRT$XCU:00002608 ?_Iostream_object$initializer$@?$_Error_objects@H@std@@2P6AXXZA dd offset ??__E?_Iostream_object@?$_Error_objects@H@std@@2V_Iostream_error_category@2@A@@YAXXZ ; `dynamic initializer for 'std::_Iostream_error_category std::_Error_objects<int>::_Iostream_object''(void)
.CRT$XCU:00002608 _CRT$XCU        ends
.CRT$XCU:00002608
.CRT$XCU:0000260C ; ===========================================================================
.CRT$XCU:0000260C
.CRT$XCU:0000260C ; Segment type: Pure data
.CRT$XCU:0000260C ; Segment permissions: Read
.CRT$XCU:0000260C _CRT$XCU        segment dword public 'DATA' use32
.CRT$XCU:0000260C                 assume cs:_CRT$XCU
.CRT$XCU:0000260C                 ;org 260Ch
.CRT$XCU:0000260C ; COMDAT (pick associative to section at 22B8)
.CRT$XCU:0000260C ; public: static void (__cdecl *std::_Error_objects<int>::_System_object$initializer$)(void)
.CRT$XCU:0000260C ?_System_object$initializer$@?$_Error_objects@H@std@@2P6AXXZA dd offset ??__E?_System_object@?$_Error_objects@H@std@@2V_System_error_category@2@A@@YAXXZ ; `dynamic initializer for 'std::_System_error_category std::_Error_objects<int>::_System_object''(void)
.CRT$XCU:0000260C _CRT$XCU        ends
.CRT$XCU:0000260C
UNDEF:00002610 ; ===========================================================================
UNDEF:00002610
UNDEF:00002610 ; Segment type: Externs
UNDEF:00002610 ; UNDEF
UNDEF:00002610                 extrn __purecall:near   ; DATA XREF: .rdata:00002204o
UNDEF:00002610                                         ; .rdata:00002208o
UNDEF:00002614 ; void *__cdecl operator new(unsigned int)
UNDEF:00002614                 extrn ??2@YAPAXI@Z:near ; CODE XREF: std::_Allocate<char>(uint,char *)+1Dp
UNDEF:00002614                                         ; std::_Allocate<std::_Container_proxy>(uint,std::_Container_proxy *)+23p
UNDEF:00002618 ; void __cdecl operator delete(void *)
UNDEF:00002618                 extrn ??3@YAXPAX@Z:near ; CODE XREF: std::_Generic_error_category::`scalar deleting destructor'(uint)+1Bp
UNDEF:00002618                                         ; std::_Iostream_error_category::`scalar deleting destructor'(uint)+1Bp ...
UNDEF:0000261C ; int __cdecl atexit(void (__cdecl *)())
UNDEF:0000261C                 extrn _atexit:near      ; CODE XREF: `dynamic initializer for 'std::_Generic_error_category std::_Error_objects<int>::_Generic_object''(void)+12p
UNDEF:0000261C                                         ; `dynamic initializer for 'std::_Iostream_error_category std::_Error_objects<int>::_Iostream_object''(void)+12p ...
UNDEF:00002620 ; _DWORD __thiscall std::_Lockit::_Lockit(std::_Lockit *__hidden this, int)
UNDEF:00002620                 extrn ??0_Lockit@std@@QAE@H@Z:near
UNDEF:00002620                                         ; CODE XREF: std::_Container_base12::_Orphan_all(void)+35p
UNDEF:00002624 ; _DWORD __thiscall std::_Lockit::~_Lockit(std::_Lockit *__hidden this)
UNDEF:00002624                 extrn ??1_Lockit@std@@QAE@XZ:near
UNDEF:00002624                                         ; CODE XREF: std::_Container_base12::_Orphan_all(void)+86p
UNDEF:00002624                                         ; __unwindfunclet$?_Orphan_all@_Container_base12@std@@QAEXXZ$0+3j
UNDEF:00002628                 extrn __hypot:near      ; CODE XREF: _hypot+1Dp
UNDEF:0000262C ; void *__cdecl memcpy(void *Dst, const void *Src, size_t Size)
UNDEF:0000262C                 extrn _memcpy:near      ; CODE XREF: std::char_traits<char>::copy(char *,char const *,uint)+1Ep
UNDEF:00002630 ; size_t __cdecl strlen(const char *Str)
UNDEF:00002630                 extrn _strlen:near      ; CODE XREF: std::char_traits<char>::length(char const *)+1Bp
UNDEF:00002634 ; void *__cdecl memmove(void *Dst, const void *Src, size_t Size)
UNDEF:00002634                 extrn _memmove:near     ; CODE XREF: std::char_traits<char>::move(char *,char const *,uint)+1Ep
UNDEF:00002638 ; _DWORD __thiscall std::exception::exception(std::exception *__hidden this, const char *const *)
UNDEF:00002638                 extrn ??0exception@std@@QAE@ABQBD@Z:near
UNDEF:00002638                                         ; CODE XREF: std::runtime_error::runtime_error(char const *)+2Dp
UNDEF:0000263C ; _DWORD __thiscall std::exception::exception(std::exception *__hidden this, const struct std::exception *)
UNDEF:0000263C                 extrn ??0exception@std@@QAE@ABV01@@Z:near
UNDEF:0000263C                                         ; CODE XREF: std::runtime_error::runtime_error(std::runtime_error const &)+2Dp
UNDEF:0000263C                                         ; DATA XREF: .xdata$x:000021F8o
UNDEF:00002640 ; _DWORD __thiscall std::exception::~exception(std::exception *__hidden this)
UNDEF:00002640                 extrn ??1exception@std@@UAE@XZ:near
UNDEF:00002640                                         ; CODE XREF: __unwindfunclet$??0runtime_error@std@@QAE@ABV01@@Z$0+3j
UNDEF:00002640                                         ; __unwindfunclet$??0runtime_error@std@@QAE@PBD@Z$0+3j ...
UNDEF:00002644 ; public: virtual char const * __thiscall std::exception::what(void)const
UNDEF:00002644                 extrn ?what@exception@std@@UBEPBDXZ:near
UNDEF:00002644                                         ; DATA XREF: .rdata:00002168o
UNDEF:00002648 ; void __cdecl std::_Debug_message(const wchar_t *, const wchar_t *, unsigned int)
UNDEF:00002648                 extrn ?_Debug_message@std@@YAXPB_W0I@Z:near
UNDEF:00002648                                         ; CODE XREF: std::_Debug_pointer<char>(char const *,wchar_t const *,uint)+16p
UNDEF:0000264C ; void __cdecl std::_Xbad_alloc()
UNDEF:0000264C                 extrn ?_Xbad_alloc@std@@YAXXZ:near
UNDEF:0000264C                                         ; CODE XREF: std::_Allocate<char>(uint,char *):loc_2CAp
UNDEF:0000264C                                         ; std::_Allocate<std::_Container_proxy>(uint,std::_Container_proxy *):loc_30Cp
UNDEF:00002650 ; void __cdecl std::_Xlength_error(const char *)
UNDEF:00002650                 extrn ?_Xlength_error@std@@YAXPBD@Z:near
UNDEF:00002650                                         ; CODE XREF: std::basic_string<char,std::char_traits<char>,std::allocator<char>>::_Xlen(void)+Cp
UNDEF:00002654 ; void __cdecl std::_Xout_of_range(const char *)
UNDEF:00002654                 extrn ?_Xout_of_range@std@@YAXPBD@Z:near
UNDEF:00002654                                         ; CODE XREF: std::basic_string<char,std::char_traits<char>,std::allocator<char>>::_Xran(void)+Cp
UNDEF:00002658 ; public: virtual void * __thiscall std::runtime_error::`vector deleting destructor'(unsigned int)
UNDEF:00002658                 extrn ??_Eruntime_error@std@@UAEPAXI@Z:near ; weak
UNDEF:00002658                                         ; DATA XREF: .rdata:const std::runtime_error::`vftable'o
UNDEF:0000265C ; public: virtual void * __thiscall std::error_category::`vector deleting destructor'(unsigned int)
UNDEF:0000265C                 extrn ??_Eerror_category@std@@UAEPAXI@Z:near ; weak
UNDEF:0000265C                                         ; DATA XREF: .rdata:const std::error_category::`vftable'o
UNDEF:00002660 ; const char *__cdecl std::_Syserror_map(int)
UNDEF:00002660                 extrn ?_Syserror_map@std@@YAPBDH@Z:near
UNDEF:00002660                                         ; CODE XREF: std::_System_error_category::default_error_condition(int)+Bp
UNDEF:00002660                                         ; std::_Generic_error_category::message(int)+33p
UNDEF:00002664 ; const char *__cdecl std::_Winerror_map(int)
UNDEF:00002664                 extrn ?_Winerror_map@std@@YAPBDH@Z:near
UNDEF:00002664                                         ; CODE XREF: std::_System_error_category::message(int)+33p
UNDEF:00002668 ; public: virtual void * __thiscall std::_Generic_error_category::`vector deleting destructor'(unsigned int)
UNDEF:00002668                 extrn ??_E_Generic_error_category@std@@UAEPAXI@Z:near ; weak
UNDEF:00002668                                         ; DATA XREF: .rdata:const std::_Generic_error_category::`vftable'o
UNDEF:0000266C ; public: virtual void * __thiscall std::_Iostream_error_category::`vector deleting destructor'(unsigned int)
UNDEF:0000266C                 extrn ??_E_Iostream_error_category@std@@UAEPAXI@Z:near ; weak
UNDEF:0000266C                                         ; DATA XREF: .rdata:const std::_Iostream_error_category::`vftable'o
UNDEF:00002670 ; public: virtual void * __thiscall std::_System_error_category::`vector deleting destructor'(unsigned int)
UNDEF:00002670                 extrn ??_E_System_error_category@std@@UAEPAXI@Z:near ; weak
UNDEF:00002670                                         ; DATA XREF: .rdata:const std::_System_error_category::`vftable'o
UNDEF:00002674 ; int __stdcall lstrlenW(LPCWSTR lpString)
UNDEF:00002674                 extrn __imp__lstrlenW@4:near
UNDEF:00002674                                         ; CODE XREF: ToolTip::Show(tagRECT,wchar_t const *,int,int)+2Ep
UNDEF:00002674                                         ; DATA XREF: ToolTip::Show(tagRECT,wchar_t const *,int,int)+2Er
UNDEF:00002678 ; LRESULT __stdcall SendMessageW(HWND hWnd, UINT Msg, WPARAM wParam, LPARAM lParam)
UNDEF:00002678                 extrn __imp__SendMessageW@16:near
UNDEF:00002678                                         ; CODE XREF: ToolTip::Show(tagRECT,wchar_t const *,int,int)+ABp
UNDEF:00002678                                         ; ToolTip::Show(tagRECT,wchar_t const *,int,int)+C3p ...
UNDEF:0000267C ; LRESULT __stdcall CallWindowProcW(WNDPROC lpPrevWndFunc, HWND hWnd, UINT Msg, WPARAM wParam, LPARAM lParam)
UNDEF:0000267C                 extrn __imp__CallWindowProcW@20:near
UNDEF:0000267C                                         ; CODE XREF: ToolTip::runProc(uint,uint,long)+21p
UNDEF:0000267C                                         ; DATA XREF: ToolTip::runProc(uint,uint,long)+21r
UNDEF:00002680 ; HWND __stdcall CreateWindowExW(DWORD dwExStyle, LPCWSTR lpClassName, LPCWSTR lpWindowName, DWORD dwStyle, int X, int Y, int nWidth, int nHeight, HWND hWndParent, HMENU hMenu, HINSTANCE hInstance, LPVOID lpParam)
UNDEF:00002680                 extrn __imp__CreateWindowExW@48:near
UNDEF:00002680                                         ; CODE XREF: ToolTip::init(HINSTANCE__ *,HWND__ *)+50p
UNDEF:00002680                                         ; DATA XREF: ToolTip::init(HINSTANCE__ *,HWND__ *)+50r
UNDEF:00002684 ; LONG __stdcall GetWindowLongW(HWND hWnd, int nIndex)
UNDEF:00002684                 extrn __imp__GetWindowLongW@8:near
UNDEF:00002684                                         ; CODE XREF: ToolTip::staticWinProc(HWND__ *,uint,uint,long)+15p
UNDEF:00002684                                         ; DATA XREF: ToolTip::staticWinProc(HWND__ *,uint,uint,long)+15r
UNDEF:00002688 ; LONG __stdcall SetWindowLongW(HWND hWnd, int nIndex, LONG dwNewLong)
UNDEF:00002688                 extrn __imp__SetWindowLongW@12:near
UNDEF:00002688                                         ; CODE XREF: ToolTip::init(HINSTANCE__ *,HWND__ *)+8Dp
UNDEF:00002688                                         ; ToolTip::init(HINSTANCE__ *,HWND__ *)+A1p
UNDEF:00002688                                         ; DATA XREF: ...
UNDEF:0000268C ; HWND __stdcall GetParent(HWND hWnd)
UNDEF:0000268C                 extrn __imp__GetParent@4:near
UNDEF:0000268C                                         ; CODE XREF: ToolTip::Show(tagRECT,wchar_t const *,int,int)+58p
UNDEF:0000268C                                         ; DATA XREF: ToolTip::Show(tagRECT,wchar_t const *,int,int)+58r
UNDEF:00002690 ; __fastcall __security_check_cookie(x)
UNDEF:00002690                 extrn @__security_check_cookie@4:near
UNDEF:00002690                                         ; CODE XREF: __ehhandler$??$construct@PADAAPAD@?$allocator@D@std@@QAEXPAPADAAPAD@Z+Cp
UNDEF:00002690                                         ; __ehhandler$??$construct@U_Container_proxy@std@@U12@@?$allocator@U_Container_proxy@std@@@std@@QAEXPAU_Container_proxy@1@$$QAU21@@Z+Cp ...
UNDEF:00002694 ; __stdcall _CxxThrowException(x, x)
UNDEF:00002694                 extrn __CxxThrowException@8:near
UNDEF:00002694                                         ; CODE XREF: ToolTip::init(HINSTANCE__ *,HWND__ *)+7Bp
UNDEF:00002694                                         ; __catch$?_Copy@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEXII@Z$1+10p
UNDEF:00002698                 extrn ___CxxFrameHandler3:near
UNDEF:00002698                                         ; CODE XREF: __ehhandler$??$construct@PADAAPAD@?$allocator@D@std@@QAEXPAPADAAPAD@Z+16j
UNDEF:00002698                                         ; __ehhandler$??$construct@U_Container_proxy@std@@U12@@?$allocator@U_Container_proxy@std@@@std@@QAEXPAU_Container_proxy@1@$$QAU21@@Z+16j ...
UNDEF:0000269C ; const type_info::`vftable'
UNDEF:0000269C                 extrn ??_7type_info@@6B@:near
UNDEF:0000269C                                         ; DATA XREF: .data$r:std::runtime_error `RTTI Type Descriptor'o
UNDEF:0000269C                                         ; .data$r:std::exception `RTTI Type Descriptor'o ...
UNDEF:000026A0                 extrn ___security_cookie:near
UNDEF:000026A0                                         ; DATA XREF: std::allocator<char>::construct<char *,char * &>(char * *,char * &)+14r
UNDEF:000026A0                                         ; std::allocator<std::_Container_proxy>::construct<std::_Container_proxy,std::_Container_proxy>(std::_Container_proxy *,std::_Container_proxy &&)+14r ...
UNDEF:000026A4                 extrn __fltused:near
UNDEF:000026A4
UNDEF:000026A4