.rdata:00000000 ;
.rdata:00000000 ; +-------------------------------------------------------------------------+
.rdata:00000000 ; |   This file has been generated by The Interactive Disassembler (IDA)    |
.rdata:00000000 ; |           Copyright (c) 2015 Hex-Rays, <support@hex-rays.com>           |
.rdata:00000000 ; |                      License info: 48-3677-7074-51                      |
.rdata:00000000 ; |             Michalis Polychronakis, Stony Brook University              |
.rdata:00000000 ; +-------------------------------------------------------------------------+
.rdata:00000000 ;
.rdata:00000000 ; Input MD5   : 3BC286F1774AAD21FBBF20BE2C92DE0A
.rdata:00000000 ; Input CRC32 : DF286E0A
.rdata:00000000
.rdata:00000000 ; File Name   : C:\workspace\notepad-plus-plus-6.7.9.2\PowerEditor\visual.net\Unicode Debug\tinyxmlerror.obj
.rdata:00000000 ; Format      : COFF (X386MAGIC)
.rdata:00000000 ; includelib "libcpmtd"
.rdata:00000000 ; includelib "uuid.lib"
.rdata:00000000 ; must resolve: ?_Generic_object@?$_Error_objects@H@std@@2V_Generic_error_category@2@A
.rdata:00000000 ; must resolve: ?_Iostream_object@?$_Error_objects@H@std@@2V_Iostream_error_category@2@A
.rdata:00000000 ; must resolve: ?_System_object@?$_Error_objects@H@std@@2V_System_error_category@2@A
.rdata:00000000 ; must resolve: ?id@?$num_put@DV?$back_insert_iterator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@std@@2V0locale@2@A
.rdata:00000000 ; must resolve: ?id@?$num_put@_WV?$back_insert_iterator@V?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@@std@@@std@@2V0locale@2@A
.rdata:00000000 ; must resolve: ?id@?$numpunct@D@std@@2V0locale@2@A
.rdata:00000000 ; must resolve: ?id@?$numpunct@_W@std@@2V0locale@2@A
.rdata:00000000 ; includelib "LIBCMTD"
.rdata:00000000 ; includelib "OLDNAMES"
.rdata:00000000
.rdata:00000000                 include uni.inc ; see unicode subdir of ida for info on unicode
.rdata:00000000
.rdata:00000000                 .686p
.rdata:00000000                 .mmx
.rdata:00000000                 .model flat
.rdata:00000000
.rdata:00000000 ; ===========================================================================
.rdata:00000000
.rdata:00000000 ; Segment type: Pure data
.rdata:00000000 ; Segment permissions: Read
.rdata:00000000 _rdata          segment dword public 'DATA' use32
.rdata:00000000                 assume cs:_rdata
.rdata:00000000 $SG95533:                               ; DATA XREF: .data:wchar_t const * * TiXmlBase::errorStringo
.rdata:00000000                 unicode 0, <No error>,0
.rdata:00000012                 align 4
.rdata:00000014 $SG95534:                               ; DATA XREF: .data:00000270o
.rdata:00000014                 unicode 0, <Error>,0
.rdata:00000020 $SG95535:                               ; DATA XREF: .data:00000274o
.rdata:00000020                 unicode 0, <Failed to open file>,0
.rdata:00000048 $SG95536:                               ; DATA XREF: .data:00000278o
.rdata:00000048                 unicode 0, <Memory allocation failed.>,0
.rdata:0000007C $SG95537:                               ; DATA XREF: .data:0000027Co
.rdata:0000007C                 unicode 0, <Error parsing Element.>,0
.rdata:000000AA                 align 4
.rdata:000000AC $SG95538:                               ; DATA XREF: .data:00000280o
.rdata:000000AC                 unicode 0, <Failed to read Element name>,0
.rdata:000000E4 $SG95539:                               ; DATA XREF: .data:00000284o
.rdata:000000E4                 unicode 0, <Error reading Element value.>,0
.rdata:0000011E                 align 10h
.rdata:00000120 $SG95540:                               ; DATA XREF: .data:00000288o
.rdata:00000120                 unicode 0, <Error reading Attributes.>,0
.rdata:00000154 $SG95541:                               ; DATA XREF: .data:0000028Co
.rdata:00000154                 unicode 0, <Error: empty tag.>,0
.rdata:00000178 $SG95542:                               ; DATA XREF: .data:00000290o
.rdata:00000178                 unicode 0, <Error reading end tag.>,0
.rdata:000001A6                 align 4
.rdata:000001A8 $SG95543:                               ; DATA XREF: .data:00000294o
.rdata:000001A8                 unicode 0, <Error parsing Unknown.>,0
.rdata:000001D6                 align 4
.rdata:000001D8 $SG95544:                               ; DATA XREF: .data:00000298o
.rdata:000001D8                 unicode 0, <Error parsing Comment.>,0
.rdata:00000206                 align 4
.rdata:00000208 $SG95545:                               ; DATA XREF: .data:0000029Co
.rdata:00000208                 unicode 0, <Error parsing Declaration.>,0
.rdata:0000023E                 align 10h
.rdata:00000240 $SG95546:                               ; DATA XREF: .data:000002A0o
.rdata:00000240                 unicode 0, <Error document empty.>,0
.rdata:00000240 _rdata          ends
.rdata:00000240
.data:0000026C ; ===========================================================================
.data:0000026C
.data:0000026C ; Segment type: Pure data
.data:0000026C ; Segment permissions: Read/Write
.data:0000026C _data           segment dword public 'DATA' use32
.data:0000026C                 assume cs:_data
.data:0000026C                 ;org 26Ch
.data:0000026C                 public ?errorString@TiXmlBase@@1PAPB_WA
.data:0000026C ; protected: static wchar_t const * * TiXmlBase::errorString
.data:0000026C ?errorString@TiXmlBase@@1PAPB_WA dd offset $SG95533 ; "No error"
.data:00000270                 dd offset $SG95534      ; "Error"
.data:00000274                 dd offset $SG95535      ; "Failed to open file"
.data:00000278                 dd offset $SG95536      ; "Memory allocation failed."
.data:0000027C                 dd offset $SG95537      ; "Error parsing Element."
.data:00000280                 dd offset $SG95538      ; "Failed to read Element name"
.data:00000284                 dd offset $SG95539      ; "Error reading Element value."
.data:00000288                 dd offset $SG95540      ; "Error reading Attributes."
.data:0000028C                 dd offset $SG95541      ; "Error: empty tag."
.data:00000290                 dd offset $SG95542      ; "Error reading end tag."
.data:00000294                 dd offset $SG95543      ; "Error parsing Unknown."
.data:00000298                 dd offset $SG95544      ; "Error parsing Comment."
.data:0000029C                 dd offset $SG95545      ; "Error parsing Declaration."
.data:000002A0                 dd offset $SG95546      ; "Error document empty."
.data:000002A0 _data           ends
.data:000002A0
.text$mn:000002A4 ; ===========================================================================
.text$mn:000002A4
.text$mn:000002A4 ; Segment type: Pure code
.text$mn:000002A4 ; Segment permissions: Read/Execute
.text$mn:000002A4 _text$mn        segment para public 'CODE' use32
.text$mn:000002A4                 assume cs:_text$mn
.text$mn:000002A4                 ;org 2A4h
.text$mn:000002A4 ; COMDAT (pick any)
.text$mn:000002A4                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text$mn:000002A4
.text$mn:000002A4 ; =============== S U B R O U T I N E =======================================
.text$mn:000002A4
.text$mn:000002A4 ; Attributes: bp-based frame
.text$mn:000002A4
.text$mn:000002A4 ; char * __cdecl std::_Allocate<char>(unsigned int, char *)
.text$mn:000002A4                 public ??$_Allocate@D@std@@YAPADIPAD@Z
.text$mn:000002A4 ??$_Allocate@D@std@@YAPADIPAD@Z proc near
.text$mn:000002A4                                         ; CODE XREF: std::allocator<char>::allocate(uint)+Dp
.text$mn:000002A4
.text$mn:000002A4 var_4           = dword ptr -4
.text$mn:000002A4 arg_0           = dword ptr  8
.text$mn:000002A4
.text$mn:000002A4                 push    ebp
.text$mn:000002A5                 mov     ebp, esp
.text$mn:000002A7                 push    ecx
.text$mn:000002A8                 mov     [ebp+var_4], 0
.text$mn:000002AF                 cmp     [ebp+arg_0], 0
.text$mn:000002B3                 jnz     short loc_2B7
.text$mn:000002B5                 jmp     short loc_2D7
.text$mn:000002B7 ; ---------------------------------------------------------------------------
.text$mn:000002B7
.text$mn:000002B7 loc_2B7:                                ; CODE XREF: std::_Allocate<char>(uint,char *)+Fj
.text$mn:000002B7                 cmp     [ebp+arg_0], 0FFFFFFFFh
.text$mn:000002BB                 ja      short loc_2D2
.text$mn:000002BD                 mov     eax, [ebp+arg_0]
.text$mn:000002C0                 push    eax             ; unsigned int
.text$mn:000002C1                 call    ??2@YAPAXI@Z    ; operator new(uint)
.text$mn:000002C6                 add     esp, 4
.text$mn:000002C9                 mov     [ebp+var_4], eax
.text$mn:000002CC                 cmp     [ebp+var_4], 0
.text$mn:000002D0                 jnz     short loc_2D7
.text$mn:000002D2
.text$mn:000002D2 loc_2D2:                                ; CODE XREF: std::_Allocate<char>(uint,char *)+17j
.text$mn:000002D2                 call    ?_Xbad_alloc@std@@YAXXZ ; std::_Xbad_alloc(void)
.text$mn:000002D7
.text$mn:000002D7 loc_2D7:                                ; CODE XREF: std::_Allocate<char>(uint,char *)+11j
.text$mn:000002D7                                         ; std::_Allocate<char>(uint,char *)+2Cj
.text$mn:000002D7                 mov     eax, [ebp+var_4]
.text$mn:000002DA                 mov     esp, ebp
.text$mn:000002DC                 pop     ebp
.text$mn:000002DD                 retn
.text$mn:000002DD ??$_Allocate@D@std@@YAPADIPAD@Z endp
.text$mn:000002DD
.text$mn:000002DD ; ---------------------------------------------------------------------------
.text$mn:000002DE                 align 10h
.text$mn:000002DE _text$mn        ends
.text$mn:000002DE
.text$mn:000002E0 ; ===========================================================================
.text$mn:000002E0
.text$mn:000002E0 ; Segment type: Pure code
.text$mn:000002E0 ; Segment permissions: Read/Execute
.text$mn:000002E0 _text$mn        segment para public 'CODE' use32
.text$mn:000002E0                 assume cs:_text$mn
.text$mn:000002E0                 ;org 2E0h
.text$mn:000002E0 ; COMDAT (pick any)
.text$mn:000002E0                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text$mn:000002E0
.text$mn:000002E0 ; =============== S U B R O U T I N E =======================================
.text$mn:000002E0
.text$mn:000002E0 ; Attributes: bp-based frame
.text$mn:000002E0
.text$mn:000002E0 ; struct std::_Container_proxy * __cdecl std::_Allocate<struct std::_Container_proxy>(unsigned int, struct std::_Container_proxy *)
.text$mn:000002E0                 public ??$_Allocate@U_Container_proxy@std@@@std@@YAPAU_Container_proxy@0@IPAU10@@Z
.text$mn:000002E0 ??$_Allocate@U_Container_proxy@std@@@std@@YAPAU_Container_proxy@0@IPAU10@@Z proc near
.text$mn:000002E0                                         ; CODE XREF: std::allocator<std::_Container_proxy>::allocate(uint)+Dp
.text$mn:000002E0
.text$mn:000002E0 var_4           = dword ptr -4
.text$mn:000002E0 arg_0           = dword ptr  8
.text$mn:000002E0
.text$mn:000002E0                 push    ebp
.text$mn:000002E1                 mov     ebp, esp
.text$mn:000002E3                 push    ecx
.text$mn:000002E4                 mov     [ebp+var_4], 0
.text$mn:000002EB                 cmp     [ebp+arg_0], 0
.text$mn:000002EF                 jnz     short loc_2F3
.text$mn:000002F1                 jmp     short loc_319
.text$mn:000002F3 ; ---------------------------------------------------------------------------
.text$mn:000002F3
.text$mn:000002F3 loc_2F3:                                ; CODE XREF: std::_Allocate<std::_Container_proxy>(uint,std::_Container_proxy *)+Fj
.text$mn:000002F3                 cmp     [ebp+arg_0], 1FFFFFFFh
.text$mn:000002FA                 ja      short loc_314
.text$mn:000002FC                 mov     eax, [ebp+arg_0]
.text$mn:000002FF                 shl     eax, 3
.text$mn:00000302                 push    eax             ; unsigned int
.text$mn:00000303                 call    ??2@YAPAXI@Z    ; operator new(uint)
.text$mn:00000308                 add     esp, 4
.text$mn:0000030B                 mov     [ebp+var_4], eax
.text$mn:0000030E                 cmp     [ebp+var_4], 0
.text$mn:00000312                 jnz     short loc_319
.text$mn:00000314
.text$mn:00000314 loc_314:                                ; CODE XREF: std::_Allocate<std::_Container_proxy>(uint,std::_Container_proxy *)+1Aj
.text$mn:00000314                 call    ?_Xbad_alloc@std@@YAXXZ ; std::_Xbad_alloc(void)
.text$mn:00000319
.text$mn:00000319 loc_319:                                ; CODE XREF: std::_Allocate<std::_Container_proxy>(uint,std::_Container_proxy *)+11j
.text$mn:00000319                                         ; std::_Allocate<std::_Container_proxy>(uint,std::_Container_proxy *)+32j
.text$mn:00000319                 mov     eax, [ebp+var_4]
.text$mn:0000031C                 mov     esp, ebp
.text$mn:0000031E                 pop     ebp
.text$mn:0000031F                 retn
.text$mn:0000031F ??$_Allocate@U_Container_proxy@std@@@std@@YAPAU_Container_proxy@0@IPAU10@@Z endp
.text$mn:0000031F
.text$mn:0000031F _text$mn        ends
.text$mn:0000031F
.text$mn:00000320 ; ===========================================================================
.text$mn:00000320
.text$mn:00000320 ; Segment type: Pure code
.text$mn:00000320 ; Segment permissions: Read/Execute
.text$mn:00000320 _text$mn        segment para public 'CODE' use32
.text$mn:00000320                 assume cs:_text$mn
.text$mn:00000320                 ;org 320h
.text$mn:00000320 ; COMDAT (pick any)
.text$mn:00000320                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text$mn:00000320
.text$mn:00000320 ; =============== S U B R O U T I N E =======================================
.text$mn:00000320
.text$mn:00000320 ; Attributes: bp-based frame
.text$mn:00000320
.text$mn:00000320 ; int __cdecl std::_Debug_pointer<char>(int, wchar_t *, unsigned int)
.text$mn:00000320                 public ??$_Debug_pointer@D@std@@YAXPBDPB_WI@Z
.text$mn:00000320 ??$_Debug_pointer@D@std@@YAXPBDPB_WI@Z proc near
.text$mn:00000320                                         ; CODE XREF: std::basic_string<char,std::char_traits<char>,std::allocator<char>>::assign(char const *)+15p
.text$mn:00000320                                         ; std::basic_string<char,std::char_traits<char>,std::allocator<char>>::assign(char const *,uint)+1Bp
.text$mn:00000320
.text$mn:00000320 arg_0           = dword ptr  8
.text$mn:00000320 arg_4           = dword ptr  0Ch
.text$mn:00000320 arg_8           = dword ptr  10h
.text$mn:00000320
.text$mn:00000320                 push    ebp
.text$mn:00000321                 mov     ebp, esp
.text$mn:00000323                 cmp     [ebp+arg_0], 0
.text$mn:00000327                 jnz     short loc_33E
.text$mn:00000329                 mov     eax, [ebp+arg_8]
.text$mn:0000032C                 push    eax             ; unsigned int
.text$mn:0000032D                 mov     ecx, [ebp+arg_4]
.text$mn:00000330                 push    ecx             ; wchar_t *
.text$mn:00000331                 push    offset ??_C@_1CK@EOPGIILJ@?$AAi?$AAn?$AAv?$AAa?$AAl?$AAi?$AAd?$AA?5?$AAn?$AAu?$AAl?$AAl?$AA?5?$AAp?$AAo?$AAi?$AAn?$AAt?$AAe?$AAr?$AA?$AA@ ; "invalid null pointer"
.text$mn:00000336                 call    ?_Debug_message@std@@YAXPB_W0I@Z ; std::_Debug_message(wchar_t const *,wchar_t const *,uint)
.text$mn:0000033B                 add     esp, 0Ch
.text$mn:0000033E
.text$mn:0000033E loc_33E:                                ; CODE XREF: std::_Debug_pointer<char>(char const *,wchar_t const *,uint)+7j
.text$mn:0000033E                 pop     ebp
.text$mn:0000033F                 retn
.text$mn:0000033F ??$_Debug_pointer@D@std@@YAXPBDPB_WI@Z endp
.text$mn:0000033F
.text$mn:0000033F _text$mn        ends
.text$mn:0000033F
.text$mn:00000340 ; ===========================================================================
.text$mn:00000340
.text$mn:00000340 ; Segment type: Pure code
.text$mn:00000340 ; Segment permissions: Read/Execute
.text$mn:00000340 _text$mn        segment para public 'CODE' use32
.text$mn:00000340                 assume cs:_text$mn
.text$mn:00000340                 ;org 340h
.text$mn:00000340 ; COMDAT (pick any)
.text$mn:00000340                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text$mn:00000340
.text$mn:00000340 ; =============== S U B R O U T I N E =======================================
.text$mn:00000340
.text$mn:00000340 ; Attributes: bp-based frame
.text$mn:00000340
.text$mn:00000340 ; char * __cdecl std::addressof<char>(char &)
.text$mn:00000340                 public ??$addressof@D@std@@YAPADAAD@Z
.text$mn:00000340 ??$addressof@D@std@@YAPADAAD@Z proc near
.text$mn:00000340                                         ; CODE XREF: std::_String_val<std::_Simple_types<char>>::_Myptr(void)+19p
.text$mn:00000340                                         ; std::_String_val<std::_Simple_types<char>>::_Myptr(void)+19p ...
.text$mn:00000340
.text$mn:00000340 arg_0           = dword ptr  8
.text$mn:00000340
.text$mn:00000340                 push    ebp
.text$mn:00000341                 mov     ebp, esp
.text$mn:00000343                 mov     eax, [ebp+arg_0]
.text$mn:00000346                 pop     ebp
.text$mn:00000347                 retn
.text$mn:00000347 ??$addressof@D@std@@YAPADAAD@Z endp
.text$mn:00000347
.text$mn:00000347 _text$mn        ends
.text$mn:00000347
.text$mn:00000348 ; ===========================================================================
.text$mn:00000348
.text$mn:00000348 ; Segment type: Pure code
.text$mn:00000348 ; Segment permissions: Read/Execute
.text$mn:00000348 _text$mn        segment para public 'CODE' use32
.text$mn:00000348                 assume cs:_text$mn
.text$mn:00000348                 ;org 348h
.text$mn:00000348 ; COMDAT (pick any)
.text$mn:00000348                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text$mn:00000348
.text$mn:00000348 ; =============== S U B R O U T I N E =======================================
.text$mn:00000348
.text$mn:00000348 ; Attributes: bp-based frame
.text$mn:00000348
.text$mn:00000348 ; int __stdcall std::_Wrap_alloc<std::allocator<char>>::construct<char *,char * &>(void *, int)
.text$mn:00000348                 public ??$construct@PADAAPAD@?$_Wrap_alloc@V?$allocator@D@std@@@std@@QAEXPAPADAAPAD@Z
.text$mn:00000348 ??$construct@PADAAPAD@?$_Wrap_alloc@V?$allocator@D@std@@@std@@QAEXPAPADAAPAD@Z proc near
.text$mn:00000348                                         ; CODE XREF: $LN19+4Bp
.text$mn:00000348
.text$mn:00000348 var_4           = dword ptr -4
.text$mn:00000348 arg_0           = dword ptr  8
.text$mn:00000348 arg_4           = dword ptr  0Ch
.text$mn:00000348
.text$mn:00000348                 push    ebp
.text$mn:00000349                 mov     ebp, esp
.text$mn:0000034B                 push    ecx
.text$mn:0000034C                 mov     [ebp+var_4], ecx
.text$mn:0000034F                 mov     eax, [ebp+arg_4]
.text$mn:00000352                 push    eax
.text$mn:00000353                 call    ??$forward@AAPAD@std@@YAAAPADAAPAD@Z ; std::forward<char * &>(char * &)
.text$mn:00000358                 add     esp, 4
.text$mn:0000035B                 push    eax             ; int
.text$mn:0000035C                 mov     ecx, [ebp+arg_0]
.text$mn:0000035F                 push    ecx             ; void *
.text$mn:00000360                 mov     edx, [ebp+var_4]
.text$mn:00000363                 push    edx             ; int
.text$mn:00000364                 call    ??$construct@PADAAPAD@?$allocator_traits@V?$allocator@D@std@@@std@@SAXAAV?$allocator@D@1@PAPADAAPAD@Z ; std::allocator_traits<std::allocator<char>>::construct<char *,char * &>(std::allocator<char> &,char * *,char * &)
.text$mn:00000369                 add     esp, 0Ch
.text$mn:0000036C                 mov     esp, ebp
.text$mn:0000036E                 pop     ebp
.text$mn:0000036F                 retn    8
.text$mn:0000036F ??$construct@PADAAPAD@?$_Wrap_alloc@V?$allocator@D@std@@@std@@QAEXPAPADAAPAD@Z endp
.text$mn:0000036F
.text$mn:0000036F ; ---------------------------------------------------------------------------
.text$mn:00000372                 align 4
.text$mn:00000372 _text$mn        ends
.text$mn:00000372
.text$mn:00000374 ; ===========================================================================
.text$mn:00000374
.text$mn:00000374 ; Segment type: Pure code
.text$mn:00000374 ; Segment permissions: Read/Execute
.text$mn:00000374 _text$mn        segment para public 'CODE' use32
.text$mn:00000374                 assume cs:_text$mn
.text$mn:00000374                 ;org 374h
.text$mn:00000374 ; COMDAT (pick any)
.text$mn:00000374                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text$mn:00000374
.text$mn:00000374 ; =============== S U B R O U T I N E =======================================
.text$mn:00000374
.text$mn:00000374 ; Attributes: bp-based frame
.text$mn:00000374
.text$mn:00000374 ; int __stdcall std::allocator<char>::construct<char *,char * &>(void *, int)
.text$mn:00000374                 public ??$construct@PADAAPAD@?$allocator@D@std@@QAEXPAPADAAPAD@Z
.text$mn:00000374 ??$construct@PADAAPAD@?$allocator@D@std@@QAEXPAPADAAPAD@Z proc near
.text$mn:00000374                                         ; CODE XREF: std::allocator_traits<std::allocator<char>>::construct<char *,char * &>(std::allocator<char> &,char * *,char * &)+17p
.text$mn:00000374
.text$mn:00000374 var_1C          = dword ptr -1Ch
.text$mn:00000374 var_18          = dword ptr -18h
.text$mn:00000374 var_14          = dword ptr -14h
.text$mn:00000374 var_10          = dword ptr -10h
.text$mn:00000374 var_C           = dword ptr -0Ch
.text$mn:00000374 var_4           = dword ptr -4
.text$mn:00000374 arg_0           = dword ptr  8
.text$mn:00000374 arg_4           = dword ptr  0Ch
.text$mn:00000374
.text$mn:00000374                 push    ebp
.text$mn:00000375                 mov     ebp, esp
.text$mn:00000377                 push    0FFFFFFFFh
.text$mn:00000379                 push    offset __ehhandler$??$construct@PADAAPAD@?$allocator@D@std@@QAEXPAPADAAPAD@Z
.text$mn:0000037E                 mov     eax, large fs:0
.text$mn:00000384                 push    eax
.text$mn:00000385                 sub     esp, 10h
.text$mn:00000388                 mov     eax, dword ptr ds:___security_cookie
.text$mn:0000038D                 xor     eax, ebp
.text$mn:0000038F                 push    eax
.text$mn:00000390                 lea     eax, [ebp+var_C]
.text$mn:00000393                 mov     large fs:0, eax
.text$mn:00000399                 mov     [ebp+var_18], ecx
.text$mn:0000039C                 mov     eax, [ebp+arg_0]
.text$mn:0000039F                 push    eax             ; void *
.text$mn:000003A0                 push    4               ; unsigned int
.text$mn:000003A2                 call    ??2@YAPAXIPAX@Z ; operator new(uint,void *)
.text$mn:000003A7                 add     esp, 8
.text$mn:000003AA                 mov     [ebp+var_10], eax
.text$mn:000003AD                 mov     [ebp+var_4], 0
.text$mn:000003B4                 cmp     [ebp+var_10], 0
.text$mn:000003B8                 jz      short loc_3D5
.text$mn:000003BA                 mov     ecx, [ebp+arg_4]
.text$mn:000003BD                 push    ecx
.text$mn:000003BE                 call    ??$forward@AAPAD@std@@YAAAPADAAPAD@Z ; std::forward<char * &>(char * &)
.text$mn:000003C3                 add     esp, 4
.text$mn:000003C6                 mov     edx, [ebp+var_10]
.text$mn:000003C9                 mov     eax, [eax]
.text$mn:000003CB                 mov     [edx], eax
.text$mn:000003CD                 mov     ecx, [ebp+var_10]
.text$mn:000003D0                 mov     [ebp+var_14], ecx
.text$mn:000003D3                 jmp     short loc_3DC
.text$mn:000003D5 ; ---------------------------------------------------------------------------
.text$mn:000003D5
.text$mn:000003D5 loc_3D5:                                ; CODE XREF: std::allocator<char>::construct<char *,char * &>(char * *,char * &)+44j
.text$mn:000003D5                 mov     [ebp+var_14], 0
.text$mn:000003DC
.text$mn:000003DC loc_3DC:                                ; CODE XREF: std::allocator<char>::construct<char *,char * &>(char * *,char * &)+5Fj
.text$mn:000003DC                 mov     edx, [ebp+var_14]
.text$mn:000003DF                 mov     [ebp+var_1C], edx
.text$mn:000003E2                 mov     [ebp+var_4], 0FFFFFFFFh
.text$mn:000003E9                 mov     ecx, [ebp+var_C]
.text$mn:000003EC                 mov     large fs:0, ecx
.text$mn:000003F3                 pop     ecx
.text$mn:000003F4                 mov     esp, ebp
.text$mn:000003F6                 pop     ebp
.text$mn:000003F7                 retn    8
.text$mn:000003F7 ??$construct@PADAAPAD@?$allocator@D@std@@QAEXPAPADAAPAD@Z endp
.text$mn:000003F7
.text$mn:000003F7 ; ---------------------------------------------------------------------------
.text$mn:000003FA                 align 4
.text$mn:000003FA _text$mn        ends
.text$mn:000003FA
.text$x:000003FC ; ===========================================================================
.text$x:000003FC
.text$x:000003FC ; Segment type: Pure code
.text$x:000003FC ; Segment permissions: Read/Execute
.text$x:000003FC _text$x         segment para public 'CODE' use32
.text$x:000003FC                 assume cs:_text$x
.text$x:000003FC                 ;org 3FCh
.text$x:000003FC ; COMDAT (pick associative to section at 374)
.text$x:000003FC                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text$x:000003FC
.text$x:000003FC ; =============== S U B R O U T I N E =======================================
.text$x:000003FC
.text$x:000003FC
.text$x:000003FC __unwindfunclet$??$construct@PADAAPAD@?$allocator@D@std@@QAEXPAPADAAPAD@Z$0 proc near
.text$x:000003FC                                         ; DATA XREF: .xdata$x:00001F34o
.text$x:000003FC                 mov     eax, [ebp+8]
.text$x:000003FF                 push    eax
.text$x:00000400                 mov     eax, [ebp-10h]
.text$x:00000403                 push    eax             ; void *
.text$x:00000404                 call    ??3@YAXPAX0@Z   ; operator delete(void *,void *)
.text$x:00000409                 add     esp, 8
.text$x:0000040C                 retn
.text$x:0000040C __unwindfunclet$??$construct@PADAAPAD@?$allocator@D@std@@QAEXPAPADAAPAD@Z$0 endp
.text$x:0000040C
.text$x:0000040D
.text$x:0000040D ; =============== S U B R O U T I N E =======================================
.text$x:0000040D
.text$x:0000040D
.text$x:0000040D __ehhandler$??$construct@PADAAPAD@?$allocator@D@std@@QAEXPAPADAAPAD@Z proc near
.text$x:0000040D                                         ; DATA XREF: std::allocator<char>::construct<char *,char * &>(char * *,char * &)+5o
.text$x:0000040D
.text$x:0000040D arg_4           = dword ptr  8
.text$x:0000040D
.text$x:0000040D                 mov     edx, [esp+arg_4]
.text$x:00000411                 lea     eax, [edx+0Ch]
.text$x:00000414                 mov     ecx, [edx-14h]
.text$x:00000417                 xor     ecx, eax
.text$x:00000419                 call    @__security_check_cookie@4 ; __security_check_cookie(x)
.text$x:0000041E                 mov     eax, offset __ehfuncinfo$??$construct@PADAAPAD@?$allocator@D@std@@QAEXPAPADAAPAD@Z
.text$x:00000423                 jmp     ___CxxFrameHandler3
.text$x:00000423 __ehhandler$??$construct@PADAAPAD@?$allocator@D@std@@QAEXPAPADAAPAD@Z endp
.text$x:00000423
.text$x:00000423 _text$x         ends
.text$x:00000423
.text$mn:00000428 ; ===========================================================================
.text$mn:00000428
.text$mn:00000428 ; Segment type: Pure code
.text$mn:00000428 ; Segment permissions: Read/Execute
.text$mn:00000428 _text$mn        segment para public 'CODE' use32
.text$mn:00000428                 assume cs:_text$mn
.text$mn:00000428                 ;org 428h
.text$mn:00000428 ; COMDAT (pick any)
.text$mn:00000428                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text$mn:00000428
.text$mn:00000428 ; =============== S U B R O U T I N E =======================================
.text$mn:00000428
.text$mn:00000428 ; Attributes: bp-based frame
.text$mn:00000428
.text$mn:00000428 ; int __cdecl std::allocator_traits<std::allocator<char>>::construct<char *,char * &>(int, void *, int)
.text$mn:00000428                 public ??$construct@PADAAPAD@?$allocator_traits@V?$allocator@D@std@@@std@@SAXAAV?$allocator@D@1@PAPADAAPAD@Z
.text$mn:00000428 ??$construct@PADAAPAD@?$allocator_traits@V?$allocator@D@std@@@std@@SAXAAV?$allocator@D@1@PAPADAAPAD@Z proc near
.text$mn:00000428                                         ; CODE XREF: std::_Wrap_alloc<std::allocator<char>>::construct<char *,char * &>(char * *,char * &)+1Cp
.text$mn:00000428
.text$mn:00000428 arg_0           = dword ptr  8
.text$mn:00000428 arg_4           = dword ptr  0Ch
.text$mn:00000428 arg_8           = dword ptr  10h
.text$mn:00000428
.text$mn:00000428                 push    ebp
.text$mn:00000429                 mov     ebp, esp
.text$mn:0000042B                 mov     eax, [ebp+arg_8]
.text$mn:0000042E                 push    eax
.text$mn:0000042F                 call    ??$forward@AAPAD@std@@YAAAPADAAPAD@Z ; std::forward<char * &>(char * &)
.text$mn:00000434                 add     esp, 4
.text$mn:00000437                 push    eax             ; int
.text$mn:00000438                 mov     ecx, [ebp+arg_4]
.text$mn:0000043B                 push    ecx             ; void *
.text$mn:0000043C                 mov     ecx, [ebp+arg_0]
.text$mn:0000043F                 call    ??$construct@PADAAPAD@?$allocator@D@std@@QAEXPAPADAAPAD@Z ; std::allocator<char>::construct<char *,char * &>(char * *,char * &)
.text$mn:00000444                 pop     ebp
.text$mn:00000445                 retn
.text$mn:00000445 ??$construct@PADAAPAD@?$allocator_traits@V?$allocator@D@std@@@std@@SAXAAV?$allocator@D@1@PAPADAAPAD@Z endp
.text$mn:00000445
.text$mn:00000445 ; ---------------------------------------------------------------------------
.text$mn:00000446                 align 4
.text$mn:00000446 _text$mn        ends
.text$mn:00000446
.text$mn:00000448 ; ===========================================================================
.text$mn:00000448
.text$mn:00000448 ; Segment type: Pure code
.text$mn:00000448 ; Segment permissions: Read/Execute
.text$mn:00000448 _text$mn        segment para public 'CODE' use32
.text$mn:00000448                 assume cs:_text$mn
.text$mn:00000448                 ;org 448h
.text$mn:00000448 ; COMDAT (pick any)
.text$mn:00000448                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text$mn:00000448
.text$mn:00000448 ; =============== S U B R O U T I N E =======================================
.text$mn:00000448
.text$mn:00000448 ; Attributes: bp-based frame
.text$mn:00000448
.text$mn:00000448 ; int __stdcall std::allocator<std::_Container_proxy>::construct<std::_Container_proxy,std::_Container_proxy>(void *, int)
.text$mn:00000448                 public ??$construct@U_Container_proxy@std@@U12@@?$allocator@U_Container_proxy@std@@@std@@QAEXPAU_Container_proxy@1@$$QAU21@@Z
.text$mn:00000448 ??$construct@U_Container_proxy@std@@U12@@?$allocator@U_Container_proxy@std@@@std@@QAEXPAU_Container_proxy@1@$$QAU21@@Z proc near
.text$mn:00000448                                         ; CODE XREF: std::_String_alloc<0,std::_String_base_types<char,std::allocator<char>>>::_Alloc_proxy(void)+32p
.text$mn:00000448
.text$mn:00000448 var_1C          = dword ptr -1Ch
.text$mn:00000448 var_18          = dword ptr -18h
.text$mn:00000448 var_14          = dword ptr -14h
.text$mn:00000448 var_10          = dword ptr -10h
.text$mn:00000448 var_C           = dword ptr -0Ch
.text$mn:00000448 var_4           = dword ptr -4
.text$mn:00000448 arg_0           = dword ptr  8
.text$mn:00000448 arg_4           = dword ptr  0Ch
.text$mn:00000448
.text$mn:00000448                 push    ebp
.text$mn:00000449                 mov     ebp, esp
.text$mn:0000044B                 push    0FFFFFFFFh
.text$mn:0000044D                 push    offset __ehhandler$??$construct@U_Container_proxy@std@@U12@@?$allocator@U_Container_proxy@std@@@std@@QAEXPAU_Container_proxy@1@$$QAU21@@Z
.text$mn:00000452                 mov     eax, large fs:0
.text$mn:00000458                 push    eax
.text$mn:00000459                 sub     esp, 10h
.text$mn:0000045C                 mov     eax, dword ptr ds:___security_cookie
.text$mn:00000461                 xor     eax, ebp
.text$mn:00000463                 push    eax
.text$mn:00000464                 lea     eax, [ebp+var_C]
.text$mn:00000467                 mov     large fs:0, eax
.text$mn:0000046D                 mov     [ebp+var_18], ecx
.text$mn:00000470                 mov     eax, [ebp+arg_0]
.text$mn:00000473                 push    eax             ; void *
.text$mn:00000474                 push    8               ; unsigned int
.text$mn:00000476                 call    ??2@YAPAXIPAX@Z ; operator new(uint,void *)
.text$mn:0000047B                 add     esp, 8
.text$mn:0000047E                 mov     [ebp+var_10], eax
.text$mn:00000481                 mov     [ebp+var_4], 0
.text$mn:00000488                 cmp     [ebp+var_10], 0
.text$mn:0000048C                 jz      short loc_4AF
.text$mn:0000048E                 mov     ecx, [ebp+arg_4]
.text$mn:00000491                 push    ecx
.text$mn:00000492                 call    ??$forward@U_Container_proxy@std@@@std@@YA$$QAU_Container_proxy@0@AAU10@@Z ; std::forward<std::_Container_proxy>(std::_Container_proxy &)
.text$mn:00000497                 add     esp, 4
.text$mn:0000049A                 mov     edx, [eax]
.text$mn:0000049C                 mov     eax, [eax+4]
.text$mn:0000049F                 mov     ecx, [ebp+var_10]
.text$mn:000004A2                 mov     [ecx], edx
.text$mn:000004A4                 mov     [ecx+4], eax
.text$mn:000004A7                 mov     edx, [ebp+var_10]
.text$mn:000004AA                 mov     [ebp+var_14], edx
.text$mn:000004AD                 jmp     short loc_4B6
.text$mn:000004AF ; ---------------------------------------------------------------------------
.text$mn:000004AF
.text$mn:000004AF loc_4AF:                                ; CODE XREF: std::allocator<std::_Container_proxy>::construct<std::_Container_proxy,std::_Container_proxy>(std::_Container_proxy *,std::_Container_proxy &&)+44j
.text$mn:000004AF                 mov     [ebp+var_14], 0
.text$mn:000004B6
.text$mn:000004B6 loc_4B6:                                ; CODE XREF: std::allocator<std::_Container_proxy>::construct<std::_Container_proxy,std::_Container_proxy>(std::_Container_proxy *,std::_Container_proxy &&)+65j
.text$mn:000004B6                 mov     eax, [ebp+var_14]
.text$mn:000004B9                 mov     [ebp+var_1C], eax
.text$mn:000004BC                 mov     [ebp+var_4], 0FFFFFFFFh
.text$mn:000004C3                 mov     ecx, [ebp+var_C]
.text$mn:000004C6                 mov     large fs:0, ecx
.text$mn:000004CD                 pop     ecx
.text$mn:000004CE                 mov     esp, ebp
.text$mn:000004D0                 pop     ebp
.text$mn:000004D1                 retn    8
.text$mn:000004D1 ??$construct@U_Container_proxy@std@@U12@@?$allocator@U_Container_proxy@std@@@std@@QAEXPAU_Container_proxy@1@$$QAU21@@Z endp
.text$mn:000004D1
.text$mn:000004D1 _text$mn        ends
.text$mn:000004D1
.text$x:000004D4 ; ===========================================================================
.text$x:000004D4
.text$x:000004D4 ; Segment type: Pure code
.text$x:000004D4 ; Segment permissions: Read/Execute
.text$x:000004D4 _text$x         segment para public 'CODE' use32
.text$x:000004D4                 assume cs:_text$x
.text$x:000004D4                 ;org 4D4h
.text$x:000004D4 ; COMDAT (pick associative to section at 448)
.text$x:000004D4                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text$x:000004D4
.text$x:000004D4 ; =============== S U B R O U T I N E =======================================
.text$x:000004D4
.text$x:000004D4
.text$x:000004D4 __unwindfunclet$??$construct@U_Container_proxy@std@@U12@@?$allocator@U_Container_proxy@std@@@std@@QAEXPAU_Container_proxy@1@$$QAU21@@Z$0 proc near
.text$x:000004D4                                         ; DATA XREF: .xdata$x:00001F08o
.text$x:000004D4                 mov     eax, [ebp+8]
.text$x:000004D7                 push    eax
.text$x:000004D8                 mov     eax, [ebp-10h]
.text$x:000004DB                 push    eax             ; void *
.text$x:000004DC                 call    ??3@YAXPAX0@Z   ; operator delete(void *,void *)
.text$x:000004E1                 add     esp, 8
.text$x:000004E4                 retn
.text$x:000004E4 __unwindfunclet$??$construct@U_Container_proxy@std@@U12@@?$allocator@U_Container_proxy@std@@@std@@QAEXPAU_Container_proxy@1@$$QAU21@@Z$0 endp
.text$x:000004E4
.text$x:000004E5
.text$x:000004E5 ; =============== S U B R O U T I N E =======================================
.text$x:000004E5
.text$x:000004E5
.text$x:000004E5 __ehhandler$??$construct@U_Container_proxy@std@@U12@@?$allocator@U_Container_proxy@std@@@std@@QAEXPAU_Container_proxy@1@$$QAU21@@Z proc near
.text$x:000004E5                                         ; DATA XREF: std::allocator<std::_Container_proxy>::construct<std::_Container_proxy,std::_Container_proxy>(std::_Container_proxy *,std::_Container_proxy &&)+5o
.text$x:000004E5
.text$x:000004E5 arg_4           = dword ptr  8
.text$x:000004E5
.text$x:000004E5                 mov     edx, [esp+arg_4]
.text$x:000004E9                 lea     eax, [edx+0Ch]
.text$x:000004EC                 mov     ecx, [edx-14h]
.text$x:000004EF                 xor     ecx, eax
.text$x:000004F1                 call    @__security_check_cookie@4 ; __security_check_cookie(x)
.text$x:000004F6                 mov     eax, offset __ehfuncinfo$??$construct@U_Container_proxy@std@@U12@@?$allocator@U_Container_proxy@std@@@std@@QAEXPAU_Container_proxy@1@$$QAU21@@Z
.text$x:000004FB                 jmp     ___CxxFrameHandler3
.text$x:000004FB __ehhandler$??$construct@U_Container_proxy@std@@U12@@?$allocator@U_Container_proxy@std@@@std@@QAEXPAU_Container_proxy@1@$$QAU21@@Z endp
.text$x:000004FB
.text$x:000004FB _text$x         ends
.text$x:000004FB
.text$mn:00000500 ; ===========================================================================
.text$mn:00000500
.text$mn:00000500 ; Segment type: Pure code
.text$mn:00000500 ; Segment permissions: Read/Execute
.text$mn:00000500 _text$mn        segment para public 'CODE' use32
.text$mn:00000500                 assume cs:_text$mn
.text$mn:00000500                 ;org 500h
.text$mn:00000500 ; COMDAT (pick any)
.text$mn:00000500                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text$mn:00000500
.text$mn:00000500 ; =============== S U B R O U T I N E =======================================
.text$mn:00000500
.text$mn:00000500 ; Attributes: bp-based frame
.text$mn:00000500
.text$mn:00000500 ; public: void __thiscall std::_Wrap_alloc<class std::allocator<char>>::destroy<char *>(char * *)
.text$mn:00000500                 public ??$destroy@PAD@?$_Wrap_alloc@V?$allocator@D@std@@@std@@QAEXPAPAD@Z
.text$mn:00000500 ??$destroy@PAD@?$_Wrap_alloc@V?$allocator@D@std@@@std@@QAEXPAPAD@Z proc near
.text$mn:00000500                                         ; CODE XREF: std::basic_string<char,std::char_traits<char>,std::allocator<char>>::_Tidy(bool,uint)+3Ap
.text$mn:00000500
.text$mn:00000500 var_4           = dword ptr -4
.text$mn:00000500 arg_0           = dword ptr  8
.text$mn:00000500
.text$mn:00000500                 push    ebp
.text$mn:00000501                 mov     ebp, esp
.text$mn:00000503                 push    ecx
.text$mn:00000504                 mov     [ebp+var_4], ecx
.text$mn:00000507                 mov     eax, [ebp+arg_0]
.text$mn:0000050A                 push    eax
.text$mn:0000050B                 mov     ecx, [ebp+var_4]
.text$mn:0000050E                 push    ecx
.text$mn:0000050F                 call    ??$destroy@PAD@?$allocator_traits@V?$allocator@D@std@@@std@@SAXAAV?$allocator@D@1@PAPAD@Z ; std::allocator_traits<std::allocator<char>>::destroy<char *>(std::allocator<char> &,char * *)
.text$mn:00000514                 add     esp, 8
.text$mn:00000517                 mov     esp, ebp
.text$mn:00000519                 pop     ebp
.text$mn:0000051A                 retn    4
.text$mn:0000051A ??$destroy@PAD@?$_Wrap_alloc@V?$allocator@D@std@@@std@@QAEXPAPAD@Z endp
.text$mn:0000051A
.text$mn:0000051A ; ---------------------------------------------------------------------------
.text$mn:0000051D                 align 10h
.text$mn:0000051D _text$mn        ends
.text$mn:0000051D
.text$mn:00000520 ; ===========================================================================
.text$mn:00000520
.text$mn:00000520 ; Segment type: Pure code
.text$mn:00000520 ; Segment permissions: Read/Execute
.text$mn:00000520 _text$mn        segment para public 'CODE' use32
.text$mn:00000520                 assume cs:_text$mn
.text$mn:00000520                 ;org 520h
.text$mn:00000520 ; COMDAT (pick any)
.text$mn:00000520                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text$mn:00000520
.text$mn:00000520 ; =============== S U B R O U T I N E =======================================
.text$mn:00000520
.text$mn:00000520 ; Attributes: bp-based frame
.text$mn:00000520
.text$mn:00000520 ; public: void __thiscall std::allocator<char>::destroy<char *>(char * *)
.text$mn:00000520                 public ??$destroy@PAD@?$allocator@D@std@@QAEXPAPAD@Z
.text$mn:00000520 ??$destroy@PAD@?$allocator@D@std@@QAEXPAPAD@Z proc near
.text$mn:00000520                                         ; CODE XREF: std::allocator_traits<std::allocator<char>>::destroy<char *>(std::allocator<char> &,char * *)+Ap
.text$mn:00000520
.text$mn:00000520 var_4           = dword ptr -4
.text$mn:00000520
.text$mn:00000520                 push    ebp
.text$mn:00000521                 mov     ebp, esp
.text$mn:00000523                 push    ecx
.text$mn:00000524                 mov     [ebp+var_4], ecx
.text$mn:00000527                 mov     esp, ebp
.text$mn:00000529                 pop     ebp
.text$mn:0000052A                 retn    4
.text$mn:0000052A ??$destroy@PAD@?$allocator@D@std@@QAEXPAPAD@Z endp
.text$mn:0000052A
.text$mn:0000052A ; ---------------------------------------------------------------------------
.text$mn:0000052D                 align 10h
.text$mn:0000052D _text$mn        ends
.text$mn:0000052D
.text$mn:00000530 ; ===========================================================================
.text$mn:00000530
.text$mn:00000530 ; Segment type: Pure code
.text$mn:00000530 ; Segment permissions: Read/Execute
.text$mn:00000530 _text$mn        segment para public 'CODE' use32
.text$mn:00000530                 assume cs:_text$mn
.text$mn:00000530                 ;org 530h
.text$mn:00000530 ; COMDAT (pick any)
.text$mn:00000530                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text$mn:00000530
.text$mn:00000530 ; =============== S U B R O U T I N E =======================================
.text$mn:00000530
.text$mn:00000530 ; Attributes: bp-based frame
.text$mn:00000530
.text$mn:00000530 ; public: static void __cdecl std::allocator_traits<class std::allocator<char>>::destroy<char *>(class std::allocator<char> &, char * *)
.text$mn:00000530                 public ??$destroy@PAD@?$allocator_traits@V?$allocator@D@std@@@std@@SAXAAV?$allocator@D@1@PAPAD@Z
.text$mn:00000530 ??$destroy@PAD@?$allocator_traits@V?$allocator@D@std@@@std@@SAXAAV?$allocator@D@1@PAPAD@Z proc near
.text$mn:00000530                                         ; CODE XREF: std::_Wrap_alloc<std::allocator<char>>::destroy<char *>(char * *)+Fp
.text$mn:00000530
.text$mn:00000530 arg_0           = dword ptr  8
.text$mn:00000530 arg_4           = dword ptr  0Ch
.text$mn:00000530
.text$mn:00000530                 push    ebp
.text$mn:00000531                 mov     ebp, esp
.text$mn:00000533                 mov     eax, [ebp+arg_4]
.text$mn:00000536                 push    eax
.text$mn:00000537                 mov     ecx, [ebp+arg_0]
.text$mn:0000053A                 call    ??$destroy@PAD@?$allocator@D@std@@QAEXPAPAD@Z ; std::allocator<char>::destroy<char *>(char * *)
.text$mn:0000053F                 pop     ebp
.text$mn:00000540                 retn
.text$mn:00000540 ??$destroy@PAD@?$allocator_traits@V?$allocator@D@std@@@std@@SAXAAV?$allocator@D@1@PAPAD@Z endp
.text$mn:00000540
.text$mn:00000540 ; ---------------------------------------------------------------------------
.text$mn:00000541                 align 4
.text$mn:00000541 _text$mn        ends
.text$mn:00000541
.text$mn:00000544 ; ===========================================================================
.text$mn:00000544
.text$mn:00000544 ; Segment type: Pure code
.text$mn:00000544 ; Segment permissions: Read/Execute
.text$mn:00000544 _text$mn        segment para public 'CODE' use32
.text$mn:00000544                 assume cs:_text$mn
.text$mn:00000544                 ;org 544h
.text$mn:00000544 ; COMDAT (pick any)
.text$mn:00000544                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text$mn:00000544
.text$mn:00000544 ; =============== S U B R O U T I N E =======================================
.text$mn:00000544
.text$mn:00000544 ; Attributes: bp-based frame
.text$mn:00000544
.text$mn:00000544 ; public: void __thiscall std::allocator<struct std::_Container_proxy>::destroy<struct std::_Container_proxy>(struct std::_Container_proxy *)
.text$mn:00000544                 public ??$destroy@U_Container_proxy@std@@@?$allocator@U_Container_proxy@std@@@std@@QAEXPAU_Container_proxy@1@@Z
.text$mn:00000544 ??$destroy@U_Container_proxy@std@@@?$allocator@U_Container_proxy@std@@@std@@QAEXPAU_Container_proxy@1@@Z proc near
.text$mn:00000544                                         ; CODE XREF: std::_String_alloc<0,std::_String_base_types<char,std::allocator<char>>>::_Free_proxy(void)+22p
.text$mn:00000544
.text$mn:00000544 var_4           = dword ptr -4
.text$mn:00000544
.text$mn:00000544                 push    ebp
.text$mn:00000545                 mov     ebp, esp
.text$mn:00000547                 push    ecx
.text$mn:00000548                 mov     [ebp+var_4], ecx
.text$mn:0000054B                 mov     esp, ebp
.text$mn:0000054D                 pop     ebp
.text$mn:0000054E                 retn    4
.text$mn:0000054E ??$destroy@U_Container_proxy@std@@@?$allocator@U_Container_proxy@std@@@std@@QAEXPAU_Container_proxy@1@@Z endp
.text$mn:0000054E
.text$mn:0000054E ; ---------------------------------------------------------------------------
.text$mn:00000551                 align 4
.text$mn:00000551 _text$mn        ends
.text$mn:00000551
.text$mn:00000554 ; ===========================================================================
.text$mn:00000554
.text$mn:00000554 ; Segment type: Pure code
.text$mn:00000554 ; Segment permissions: Read/Execute
.text$mn:00000554 _text$mn        segment para public 'CODE' use32
.text$mn:00000554                 assume cs:_text$mn
.text$mn:00000554                 ;org 554h
.text$mn:00000554 ; COMDAT (pick any)
.text$mn:00000554                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text$mn:00000554
.text$mn:00000554 ; =============== S U B R O U T I N E =======================================
.text$mn:00000554
.text$mn:00000554 ; Attributes: bp-based frame
.text$mn:00000554
.text$mn:00000554 ; char * & __cdecl std::forward<char * &>(char * &)
.text$mn:00000554                 public ??$forward@AAPAD@std@@YAAAPADAAPAD@Z
.text$mn:00000554 ??$forward@AAPAD@std@@YAAAPADAAPAD@Z proc near
.text$mn:00000554                                         ; CODE XREF: std::_Wrap_alloc<std::allocator<char>>::construct<char *,char * &>(char * *,char * &)+Bp
.text$mn:00000554                                         ; std::allocator<char>::construct<char *,char * &>(char * *,char * &)+4Ap ...
.text$mn:00000554
.text$mn:00000554 arg_0           = dword ptr  8
.text$mn:00000554
.text$mn:00000554                 push    ebp
.text$mn:00000555                 mov     ebp, esp
.text$mn:00000557                 mov     eax, [ebp+arg_0]
.text$mn:0000055A                 pop     ebp
.text$mn:0000055B                 retn
.text$mn:0000055B ??$forward@AAPAD@std@@YAAAPADAAPAD@Z endp
.text$mn:0000055B
.text$mn:0000055B _text$mn        ends
.text$mn:0000055B
.text$mn:0000055C ; ===========================================================================
.text$mn:0000055C
.text$mn:0000055C ; Segment type: Pure code
.text$mn:0000055C ; Segment permissions: Read/Execute
.text$mn:0000055C _text$mn        segment para public 'CODE' use32
.text$mn:0000055C                 assume cs:_text$mn
.text$mn:0000055C                 ;org 55Ch
.text$mn:0000055C ; COMDAT (pick any)
.text$mn:0000055C                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text$mn:0000055C
.text$mn:0000055C ; =============== S U B R O U T I N E =======================================
.text$mn:0000055C
.text$mn:0000055C ; Attributes: bp-based frame
.text$mn:0000055C
.text$mn:0000055C ; struct std::_Container_proxy && __cdecl std::forward<struct std::_Container_proxy>(struct std::_Container_proxy &)
.text$mn:0000055C                 public ??$forward@U_Container_proxy@std@@@std@@YA$$QAU_Container_proxy@0@AAU10@@Z
.text$mn:0000055C ??$forward@U_Container_proxy@std@@@std@@YA$$QAU_Container_proxy@0@AAU10@@Z proc near
.text$mn:0000055C                                         ; CODE XREF: std::allocator<std::_Container_proxy>::construct<std::_Container_proxy,std::_Container_proxy>(std::_Container_proxy *,std::_Container_proxy &&)+4Ap
.text$mn:0000055C
.text$mn:0000055C arg_0           = dword ptr  8
.text$mn:0000055C
.text$mn:0000055C                 push    ebp
.text$mn:0000055D                 mov     ebp, esp
.text$mn:0000055F                 mov     eax, [ebp+arg_0]
.text$mn:00000562                 pop     ebp
.text$mn:00000563                 retn
.text$mn:00000563 ??$forward@U_Container_proxy@std@@@std@@YA$$QAU_Container_proxy@0@AAU10@@Z endp
.text$mn:00000563
.text$mn:00000563 _text$mn        ends
.text$mn:00000563
.text$mn:00000564 ; ===========================================================================
.text$mn:00000564
.text$mn:00000564 ; Segment type: Pure code
.text$mn:00000564 ; Segment permissions: Read/Execute
.text$mn:00000564 _text$mn        segment para public 'CODE' use32
.text$mn:00000564                 assume cs:_text$mn
.text$mn:00000564                 ;org 564h
.text$mn:00000564 ; COMDAT (pick any)
.text$mn:00000564                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text$mn:00000564
.text$mn:00000564 ; =============== S U B R O U T I N E =======================================
.text$mn:00000564
.text$mn:00000564 ; Attributes: bp-based frame
.text$mn:00000564
.text$mn:00000564 ; public: __thiscall std::_String_alloc<0, struct std::_String_base_types<char, class std::allocator<char>>>::_String_alloc<0, struct std::_String_base_types<char, class std::allocator<char>>>(class std::allocator<char> const &)
.text$mn:00000564                 public ??0?$_String_alloc@$0A@U?$_String_base_types@DV?$allocator@D@std@@@std@@@std@@QAE@ABV?$allocator@D@1@@Z
.text$mn:00000564 ??0?$_String_alloc@$0A@U?$_String_base_types@DV?$allocator@D@std@@@std@@@std@@QAE@ABV?$allocator@D@1@@Z proc near
.text$mn:00000564                                         ; CODE XREF: std::basic_string<char,std::char_traits<char>,std::allocator<char>>::basic_string<char,std::char_traits<char>,std::allocator<char>>(char const *)+34p
.text$mn:00000564
.text$mn:00000564 var_10          = dword ptr -10h
.text$mn:00000564 var_C           = dword ptr -0Ch
.text$mn:00000564 var_4           = dword ptr -4
.text$mn:00000564
.text$mn:00000564                 push    ebp
.text$mn:00000565                 mov     ebp, esp
.text$mn:00000567                 push    0FFFFFFFFh
.text$mn:00000569                 push    offset __ehhandler$??0?$_String_alloc@$0A@U?$_String_base_types@DV?$allocator@D@std@@@std@@@std@@QAE@ABV?$allocator@D@1@@Z
.text$mn:0000056E                 mov     eax, large fs:0
.text$mn:00000574                 push    eax
.text$mn:00000575                 push    ecx
.text$mn:00000576                 mov     eax, dword ptr ds:___security_cookie
.text$mn:0000057B                 xor     eax, ebp
.text$mn:0000057D                 push    eax
.text$mn:0000057E                 lea     eax, [ebp+var_C]
.text$mn:00000581                 mov     large fs:0, eax
.text$mn:00000587                 mov     [ebp+var_10], ecx
.text$mn:0000058A                 mov     ecx, [ebp+var_10]
.text$mn:0000058D                 call    ??0?$_String_val@U?$_Simple_types@D@std@@@std@@QAE@XZ ; std::_String_val<std::_Simple_types<char>>::_String_val<std::_Simple_types<char>>(void)
.text$mn:00000592                 mov     [ebp+var_4], 0
.text$mn:00000599                 mov     ecx, [ebp+var_10]
.text$mn:0000059C                 call    ?_Alloc_proxy@?$_String_alloc@$0A@U?$_String_base_types@DV?$allocator@D@std@@@std@@@std@@QAEXXZ ; std::_String_alloc<0,std::_String_base_types<char,std::allocator<char>>>::_Alloc_proxy(void)
.text$mn:000005A1                 mov     [ebp+var_4], 0FFFFFFFFh
.text$mn:000005A8                 mov     eax, [ebp+var_10]
.text$mn:000005AB                 mov     ecx, [ebp+var_C]
.text$mn:000005AE                 mov     large fs:0, ecx
.text$mn:000005B5                 pop     ecx
.text$mn:000005B6                 mov     esp, ebp
.text$mn:000005B8                 pop     ebp
.text$mn:000005B9                 retn    4
.text$mn:000005B9 ??0?$_String_alloc@$0A@U?$_String_base_types@DV?$allocator@D@std@@@std@@@std@@QAE@ABV?$allocator@D@1@@Z endp
.text$mn:000005B9
.text$mn:000005B9 _text$mn        ends
.text$mn:000005B9
.text$x:000005BC ; ===========================================================================
.text$x:000005BC
.text$x:000005BC ; Segment type: Pure code
.text$x:000005BC ; Segment permissions: Read/Execute
.text$x:000005BC _text$x         segment para public 'CODE' use32
.text$x:000005BC                 assume cs:_text$x
.text$x:000005BC                 ;org 5BCh
.text$x:000005BC ; COMDAT (pick associative to section at 564)
.text$x:000005BC                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text$x:000005BC
.text$x:000005BC ; =============== S U B R O U T I N E =======================================
.text$x:000005BC
.text$x:000005BC
.text$x:000005BC __unwindfunclet$??0?$_String_alloc@$0A@U?$_String_base_types@DV?$allocator@D@std@@@std@@@std@@QAE@ABV?$allocator@D@1@@Z$0 proc near
.text$x:000005BC                                         ; DATA XREF: .xdata$x:00001C40o
.text$x:000005BC                 mov     ecx, [ebp-10h]
.text$x:000005BF                 jmp     ??1?$_String_val@U?$_Simple_types@D@std@@@std@@QAE@XZ ; std::_String_val<std::_Simple_types<char>>::~_String_val<std::_Simple_types<char>>(void)
.text$x:000005BF __unwindfunclet$??0?$_String_alloc@$0A@U?$_String_base_types@DV?$allocator@D@std@@@std@@@std@@QAE@ABV?$allocator@D@1@@Z$0 endp
.text$x:000005BF
.text$x:000005C4
.text$x:000005C4 ; =============== S U B R O U T I N E =======================================
.text$x:000005C4
.text$x:000005C4
.text$x:000005C4 __ehhandler$??0?$_String_alloc@$0A@U?$_String_base_types@DV?$allocator@D@std@@@std@@@std@@QAE@ABV?$allocator@D@1@@Z proc near
.text$x:000005C4                                         ; DATA XREF: std::_String_alloc<0,std::_String_base_types<char,std::allocator<char>>>::_String_alloc<0,std::_String_base_types<char,std::allocator<char>>>(std::allocator<char> const &)+5o
.text$x:000005C4
.text$x:000005C4 arg_4           = dword ptr  8
.text$x:000005C4
.text$x:000005C4                 mov     edx, [esp+arg_4]
.text$x:000005C8                 lea     eax, [edx+0Ch]
.text$x:000005CB                 mov     ecx, [edx-8]
.text$x:000005CE                 xor     ecx, eax
.text$x:000005D0                 call    @__security_check_cookie@4 ; __security_check_cookie(x)
.text$x:000005D5                 mov     eax, offset __ehfuncinfo$??0?$_String_alloc@$0A@U?$_String_base_types@DV?$allocator@D@std@@@std@@@std@@QAE@ABV?$allocator@D@1@@Z
.text$x:000005DA                 jmp     ___CxxFrameHandler3
.text$x:000005DA __ehhandler$??0?$_String_alloc@$0A@U?$_String_base_types@DV?$allocator@D@std@@@std@@@std@@QAE@ABV?$allocator@D@1@@Z endp
.text$x:000005DA
.text$x:000005DA ; ---------------------------------------------------------------------------
.text$x:000005DF                 align 10h
.text$x:000005DF _text$x         ends
.text$x:000005DF
.text$mn:000005E0 ; ===========================================================================
.text$mn:000005E0
.text$mn:000005E0 ; Segment type: Pure code
.text$mn:000005E0 ; Segment permissions: Read/Execute
.text$mn:000005E0 _text$mn        segment para public 'CODE' use32
.text$mn:000005E0                 assume cs:_text$mn
.text$mn:000005E0                 ;org 5E0h
.text$mn:000005E0 ; COMDAT (pick any)
.text$mn:000005E0                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text$mn:000005E0
.text$mn:000005E0 ; =============== S U B R O U T I N E =======================================
.text$mn:000005E0
.text$mn:000005E0 ; Attributes: bp-based frame
.text$mn:000005E0
.text$mn:000005E0 ; public: __thiscall std::_String_val<struct std::_Simple_types<char>>::_String_val<struct std::_Simple_types<char>>(void)
.text$mn:000005E0                 public ??0?$_String_val@U?$_Simple_types@D@std@@@std@@QAE@XZ
.text$mn:000005E0 ??0?$_String_val@U?$_Simple_types@D@std@@@std@@QAE@XZ proc near
.text$mn:000005E0                                         ; CODE XREF: std::_String_alloc<0,std::_String_base_types<char,std::allocator<char>>>::_String_alloc<0,std::_String_base_types<char,std::allocator<char>>>(std::allocator<char> const &)+29p
.text$mn:000005E0
.text$mn:000005E0 var_10          = dword ptr -10h
.text$mn:000005E0 var_C           = dword ptr -0Ch
.text$mn:000005E0 var_4           = dword ptr -4
.text$mn:000005E0
.text$mn:000005E0                 push    ebp
.text$mn:000005E1                 mov     ebp, esp
.text$mn:000005E3                 push    0FFFFFFFFh
.text$mn:000005E5                 push    offset __ehhandler$??0?$_String_val@U?$_Simple_types@D@std@@@std@@QAE@XZ
.text$mn:000005EA                 mov     eax, large fs:0
.text$mn:000005F0                 push    eax
.text$mn:000005F1                 push    ecx
.text$mn:000005F2                 mov     eax, dword ptr ds:___security_cookie
.text$mn:000005F7                 xor     eax, ebp
.text$mn:000005F9                 push    eax
.text$mn:000005FA                 lea     eax, [ebp+var_C]
.text$mn:000005FD                 mov     large fs:0, eax
.text$mn:00000603                 mov     [ebp+var_10], ecx
.text$mn:00000606                 mov     ecx, [ebp+var_10] ; this
.text$mn:00000609                 call    ??0_Container_base12@std@@QAE@XZ ; std::_Container_base12::_Container_base12(void)
.text$mn:0000060E                 mov     [ebp+var_4], 0
.text$mn:00000615                 mov     eax, [ebp+var_10]
.text$mn:00000618                 mov     dword ptr [eax+14h], 0
.text$mn:0000061F                 mov     ecx, [ebp+var_10]
.text$mn:00000622                 mov     dword ptr [ecx+18h], 0
.text$mn:00000629                 mov     [ebp+var_4], 0FFFFFFFFh
.text$mn:00000630                 mov     eax, [ebp+var_10]
.text$mn:00000633                 mov     ecx, [ebp+var_C]
.text$mn:00000636                 mov     large fs:0, ecx
.text$mn:0000063D                 pop     ecx
.text$mn:0000063E                 mov     esp, ebp
.text$mn:00000640                 pop     ebp
.text$mn:00000641                 retn
.text$mn:00000641 ??0?$_String_val@U?$_Simple_types@D@std@@@std@@QAE@XZ endp
.text$mn:00000641
.text$mn:00000641 ; ---------------------------------------------------------------------------
.text$mn:00000642                 align 4
.text$mn:00000642 _text$mn        ends
.text$mn:00000642
.text$x:00000644 ; ===========================================================================
.text$x:00000644
.text$x:00000644 ; Segment type: Pure code
.text$x:00000644 ; Segment permissions: Read/Execute
.text$x:00000644 _text$x         segment para public 'CODE' use32
.text$x:00000644                 assume cs:_text$x
.text$x:00000644                 ;org 644h
.text$x:00000644 ; COMDAT (pick associative to section at 5E0)
.text$x:00000644                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text$x:00000644
.text$x:00000644 ; =============== S U B R O U T I N E =======================================
.text$x:00000644
.text$x:00000644
.text$x:00000644 __unwindfunclet$??0?$_String_val@U?$_Simple_types@D@std@@@std@@QAE@XZ$0 proc near
.text$x:00000644                                         ; DATA XREF: .xdata$x:00001BE8o
.text$x:00000644                 mov     ecx, [ebp-10h]  ; this
.text$x:00000647                 jmp     ??1_Container_base12@std@@QAE@XZ ; std::_Container_base12::~_Container_base12(void)
.text$x:00000647 __unwindfunclet$??0?$_String_val@U?$_Simple_types@D@std@@@std@@QAE@XZ$0 endp
.text$x:00000647
.text$x:0000064C
.text$x:0000064C ; =============== S U B R O U T I N E =======================================
.text$x:0000064C
.text$x:0000064C
.text$x:0000064C __ehhandler$??0?$_String_val@U?$_Simple_types@D@std@@@std@@QAE@XZ proc near
.text$x:0000064C                                         ; DATA XREF: std::_String_val<std::_Simple_types<char>>::_String_val<std::_Simple_types<char>>(void)+5o
.text$x:0000064C
.text$x:0000064C arg_4           = dword ptr  8
.text$x:0000064C
.text$x:0000064C                 mov     edx, [esp+arg_4]
.text$x:00000650                 lea     eax, [edx+0Ch]
.text$x:00000653                 mov     ecx, [edx-8]
.text$x:00000656                 xor     ecx, eax
.text$x:00000658                 call    @__security_check_cookie@4 ; __security_check_cookie(x)
.text$x:0000065D                 mov     eax, offset __ehfuncinfo$??0?$_String_val@U?$_Simple_types@D@std@@@std@@QAE@XZ
.text$x:00000662                 jmp     ___CxxFrameHandler3
.text$x:00000662 __ehhandler$??0?$_String_val@U?$_Simple_types@D@std@@@std@@QAE@XZ endp
.text$x:00000662
.text$x:00000662 ; ---------------------------------------------------------------------------
.text$x:00000667                 align 4
.text$x:00000667 _text$x         ends
.text$x:00000667
.text$mn:00000668 ; ===========================================================================
.text$mn:00000668
.text$mn:00000668 ; Segment type: Pure code
.text$mn:00000668 ; Segment permissions: Read/Execute
.text$mn:00000668 _text$mn        segment para public 'CODE' use32
.text$mn:00000668                 assume cs:_text$mn
.text$mn:00000668                 ;org 668h
.text$mn:00000668 ; COMDAT (pick any)
.text$mn:00000668                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text$mn:00000668
.text$mn:00000668 ; =============== S U B R O U T I N E =======================================
.text$mn:00000668
.text$mn:00000668 ; Attributes: bp-based frame
.text$mn:00000668
.text$mn:00000668 ; public: __thiscall std::_Wrap_alloc<class std::allocator<char>>::_Wrap_alloc<class std::allocator<char>>(void)
.text$mn:00000668                 public ??0?$_Wrap_alloc@V?$allocator@D@std@@@std@@QAE@XZ
.text$mn:00000668 ??0?$_Wrap_alloc@V?$allocator@D@std@@@std@@QAE@XZ proc near
.text$mn:00000668                                         ; CODE XREF: std::_String_alloc<0,std::_String_base_types<char,std::allocator<char>>>::_Getal(void)+Ap
.text$mn:00000668
.text$mn:00000668 var_4           = dword ptr -4
.text$mn:00000668
.text$mn:00000668                 push    ebp
.text$mn:00000669                 mov     ebp, esp
.text$mn:0000066B                 push    ecx
.text$mn:0000066C                 mov     [ebp+var_4], ecx
.text$mn:0000066F                 mov     ecx, [ebp+var_4]
.text$mn:00000672                 call    ??0?$allocator@D@std@@QAE@XZ ; std::allocator<char>::allocator<char>(void)
.text$mn:00000677                 mov     eax, [ebp+var_4]
.text$mn:0000067A                 mov     esp, ebp
.text$mn:0000067C                 pop     ebp
.text$mn:0000067D                 retn
.text$mn:0000067D ??0?$_Wrap_alloc@V?$allocator@D@std@@@std@@QAE@XZ endp
.text$mn:0000067D
.text$mn:0000067D ; ---------------------------------------------------------------------------
.text$mn:0000067E                 align 10h
.text$mn:0000067E _text$mn        ends
.text$mn:0000067E
.text$mn:00000680 ; ===========================================================================
.text$mn:00000680
.text$mn:00000680 ; Segment type: Pure code
.text$mn:00000680 ; Segment permissions: Read/Execute
.text$mn:00000680 _text$mn        segment para public 'CODE' use32
.text$mn:00000680                 assume cs:_text$mn
.text$mn:00000680                 ;org 680h
.text$mn:00000680 ; COMDAT (pick any)
.text$mn:00000680                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text$mn:00000680
.text$mn:00000680 ; =============== S U B R O U T I N E =======================================
.text$mn:00000680
.text$mn:00000680 ; Attributes: bp-based frame
.text$mn:00000680
.text$mn:00000680 ; public: __thiscall std::allocator<char>::allocator<char>(void)
.text$mn:00000680                 public ??0?$allocator@D@std@@QAE@XZ
.text$mn:00000680 ??0?$allocator@D@std@@QAE@XZ proc near  ; CODE XREF: std::_Wrap_alloc<std::allocator<char>>::_Wrap_alloc<std::allocator<char>>(void)+Ap
.text$mn:00000680                                         ; std::basic_string<char,std::char_traits<char>,std::allocator<char>>::basic_string<char,std::char_traits<char>,std::allocator<char>>(char const *)+2Bp
.text$mn:00000680
.text$mn:00000680 var_4           = dword ptr -4
.text$mn:00000680
.text$mn:00000680                 push    ebp
.text$mn:00000681                 mov     ebp, esp
.text$mn:00000683                 push    ecx
.text$mn:00000684                 mov     [ebp+var_4], ecx
.text$mn:00000687                 mov     eax, [ebp+var_4]
.text$mn:0000068A                 mov     esp, ebp
.text$mn:0000068C                 pop     ebp
.text$mn:0000068D                 retn
.text$mn:0000068D ??0?$allocator@D@std@@QAE@XZ endp
.text$mn:0000068D
.text$mn:0000068D ; ---------------------------------------------------------------------------
.text$mn:0000068E                 align 10h
.text$mn:0000068E _text$mn        ends
.text$mn:0000068E
.text$mn:00000690 ; ===========================================================================
.text$mn:00000690
.text$mn:00000690 ; Segment type: Pure code
.text$mn:00000690 ; Segment permissions: Read/Execute
.text$mn:00000690 _text$mn        segment para public 'CODE' use32
.text$mn:00000690                 assume cs:_text$mn
.text$mn:00000690                 ;org 690h
.text$mn:00000690 ; COMDAT (pick any)
.text$mn:00000690                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text$mn:00000690
.text$mn:00000690 ; =============== S U B R O U T I N E =======================================
.text$mn:00000690
.text$mn:00000690 ; Attributes: bp-based frame
.text$mn:00000690
.text$mn:00000690 ; public: __thiscall std::allocator<struct std::_Container_proxy>::allocator<struct std::_Container_proxy>(void)
.text$mn:00000690                 public ??0?$allocator@U_Container_proxy@std@@@std@@QAE@XZ
.text$mn:00000690 ??0?$allocator@U_Container_proxy@std@@@std@@QAE@XZ proc near
.text$mn:00000690                                         ; CODE XREF: std::_String_alloc<0,std::_String_base_types<char,std::allocator<char>>>::_Alloc_proxy(void)+Cp
.text$mn:00000690                                         ; std::_String_alloc<0,std::_String_base_types<char,std::allocator<char>>>::_Free_proxy(void)+Cp
.text$mn:00000690
.text$mn:00000690 var_4           = dword ptr -4
.text$mn:00000690
.text$mn:00000690                 push    ebp
.text$mn:00000691                 mov     ebp, esp
.text$mn:00000693                 push    ecx
.text$mn:00000694                 mov     [ebp+var_4], ecx
.text$mn:00000697                 mov     eax, [ebp+var_4]
.text$mn:0000069A                 mov     esp, ebp
.text$mn:0000069C                 pop     ebp
.text$mn:0000069D                 retn
.text$mn:0000069D ??0?$allocator@U_Container_proxy@std@@@std@@QAE@XZ endp
.text$mn:0000069D
.text$mn:0000069D ; ---------------------------------------------------------------------------
.text$mn:0000069E                 align 10h
.text$mn:0000069E _text$mn        ends
.text$mn:0000069E
.text$mn:000006A0 ; ===========================================================================
.text$mn:000006A0
.text$mn:000006A0 ; Segment type: Pure code
.text$mn:000006A0 ; Segment permissions: Read/Execute
.text$mn:000006A0 _text$mn        segment para public 'CODE' use32
.text$mn:000006A0                 assume cs:_text$mn
.text$mn:000006A0                 ;org 6A0h
.text$mn:000006A0 ; COMDAT (pick any)
.text$mn:000006A0                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text$mn:000006A0
.text$mn:000006A0 ; =============== S U B R O U T I N E =======================================
.text$mn:000006A0
.text$mn:000006A0 ; Attributes: bp-based frame
.text$mn:000006A0
.text$mn:000006A0 ; int __stdcall std::basic_string<char,std::char_traits<char>,std::allocator<char>>::basic_string<char,std::char_traits<char>,std::allocator<char>>(char *Str)
.text$mn:000006A0                 public ??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@PBD@Z
.text$mn:000006A0 ??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@PBD@Z proc near
.text$mn:000006A0                                         ; CODE XREF: std::_Generic_error_category::message(int)+5Ap
.text$mn:000006A0                                         ; std::_Iostream_error_category::message(int)+3Dp ...
.text$mn:000006A0
.text$mn:000006A0 var_14          = dword ptr -14h
.text$mn:000006A0 var_D           = byte ptr -0Dh
.text$mn:000006A0 var_C           = dword ptr -0Ch
.text$mn:000006A0 var_4           = dword ptr -4
.text$mn:000006A0 Str             = dword ptr  8
.text$mn:000006A0
.text$mn:000006A0                 push    ebp
.text$mn:000006A1                 mov     ebp, esp
.text$mn:000006A3                 push    0FFFFFFFFh
.text$mn:000006A5                 push    offset __ehhandler$??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@PBD@Z
.text$mn:000006AA                 mov     eax, large fs:0
.text$mn:000006B0                 push    eax
.text$mn:000006B1                 sub     esp, 8
.text$mn:000006B4                 mov     eax, dword ptr ds:___security_cookie
.text$mn:000006B9                 xor     eax, ebp
.text$mn:000006BB                 push    eax
.text$mn:000006BC                 lea     eax, [ebp+var_C]
.text$mn:000006BF                 mov     large fs:0, eax
.text$mn:000006C5                 mov     [ebp+var_14], ecx
.text$mn:000006C8                 lea     ecx, [ebp+var_D]
.text$mn:000006CB                 call    ??0?$allocator@D@std@@QAE@XZ ; std::allocator<char>::allocator<char>(void)
.text$mn:000006D0                 push    eax
.text$mn:000006D1                 mov     ecx, [ebp+var_14]
.text$mn:000006D4                 call    ??0?$_String_alloc@$0A@U?$_String_base_types@DV?$allocator@D@std@@@std@@@std@@QAE@ABV?$allocator@D@1@@Z ; std::_String_alloc<0,std::_String_base_types<char,std::allocator<char>>>::_String_alloc<0,std::_String_base_types<char,std::allocator<char>>>(std::allocator<char> const &)
.text$mn:000006D9                 mov     [ebp+var_4], 0
.text$mn:000006E0                 push    0               ; Size
.text$mn:000006E2                 push    0               ; char
.text$mn:000006E4                 mov     ecx, [ebp+var_14]
.text$mn:000006E7                 call    ?_Tidy@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEX_NI@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char>>::_Tidy(bool,uint)
.text$mn:000006EC                 mov     eax, [ebp+Str]
.text$mn:000006EF                 push    eax             ; Str
.text$mn:000006F0                 mov     ecx, [ebp+var_14]
.text$mn:000006F3                 call    ?assign@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV12@PBD@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char>>::assign(char const *)
.text$mn:000006F8                 mov     [ebp+var_4], 0FFFFFFFFh
.text$mn:000006FF                 mov     eax, [ebp+var_14]
.text$mn:00000702                 mov     ecx, [ebp+var_C]
.text$mn:00000705                 mov     large fs:0, ecx
.text$mn:0000070C                 pop     ecx
.text$mn:0000070D                 mov     esp, ebp
.text$mn:0000070F                 pop     ebp
.text$mn:00000710                 retn    4
.text$mn:00000710 ??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@PBD@Z endp
.text$mn:00000710
.text$mn:00000710 ; ---------------------------------------------------------------------------
.text$mn:00000713                 align 4
.text$mn:00000713 _text$mn        ends
.text$mn:00000713
.text$x:00000714 ; ===========================================================================
.text$x:00000714
.text$x:00000714 ; Segment type: Pure code
.text$x:00000714 ; Segment permissions: Read/Execute
.text$x:00000714 _text$x         segment para public 'CODE' use32
.text$x:00000714                 assume cs:_text$x
.text$x:00000714                 ;org 714h
.text$x:00000714 ; COMDAT (pick associative to section at 6A0)
.text$x:00000714                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text$x:00000714
.text$x:00000714 ; =============== S U B R O U T I N E =======================================
.text$x:00000714
.text$x:00000714
.text$x:00000714 __unwindfunclet$??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@PBD@Z$0 proc near
.text$x:00000714                                         ; DATA XREF: .xdata$x:00001C98o
.text$x:00000714                 mov     ecx, [ebp-14h]
.text$x:00000717                 jmp     ??1?$_String_alloc@$0A@U?$_String_base_types@DV?$allocator@D@std@@@std@@@std@@QAE@XZ ; std::_String_alloc<0,std::_String_base_types<char,std::allocator<char>>>::~_String_alloc<0,std::_String_base_types<char,std::allocator<char>>>(void)
.text$x:00000717 __unwindfunclet$??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@PBD@Z$0 endp
.text$x:00000717
.text$x:0000071C
.text$x:0000071C ; =============== S U B R O U T I N E =======================================
.text$x:0000071C
.text$x:0000071C
.text$x:0000071C __ehhandler$??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@PBD@Z proc near
.text$x:0000071C                                         ; DATA XREF: std::basic_string<char,std::char_traits<char>,std::allocator<char>>::basic_string<char,std::char_traits<char>,std::allocator<char>>(char const *)+5o
.text$x:0000071C
.text$x:0000071C arg_4           = dword ptr  8
.text$x:0000071C
.text$x:0000071C                 mov     edx, [esp+arg_4]
.text$x:00000720                 lea     eax, [edx+0Ch]
.text$x:00000723                 mov     ecx, [edx-0Ch]
.text$x:00000726                 xor     ecx, eax
.text$x:00000728                 call    @__security_check_cookie@4 ; __security_check_cookie(x)
.text$x:0000072D                 mov     eax, offset __ehfuncinfo$??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@PBD@Z
.text$x:00000732                 jmp     ___CxxFrameHandler3
.text$x:00000732 __ehhandler$??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@PBD@Z endp
.text$x:00000732
.text$x:00000732 ; ---------------------------------------------------------------------------
.text$x:00000737                 align 4
.text$x:00000737 _text$x         ends
.text$x:00000737
.text$mn:00000738 ; ===========================================================================
.text$mn:00000738
.text$mn:00000738 ; Segment type: Pure code
.text$mn:00000738 ; Segment permissions: Read/Execute
.text$mn:00000738 _text$mn        segment para public 'CODE' use32
.text$mn:00000738                 assume cs:_text$mn
.text$mn:00000738                 ;org 738h
.text$mn:00000738 ; COMDAT (pick any)
.text$mn:00000738                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text$mn:00000738
.text$mn:00000738 ; =============== S U B R O U T I N E =======================================
.text$mn:00000738
.text$mn:00000738 ; Attributes: bp-based frame
.text$mn:00000738
.text$mn:00000738 ; _DWORD __thiscall std::_Container_base12::_Container_base12(std::_Container_base12 *__hidden this)
.text$mn:00000738                 public ??0_Container_base12@std@@QAE@XZ
.text$mn:00000738 ??0_Container_base12@std@@QAE@XZ proc near
.text$mn:00000738                                         ; CODE XREF: std::_String_val<std::_Simple_types<char>>::_String_val<std::_Simple_types<char>>(void)+29p
.text$mn:00000738
.text$mn:00000738 var_4           = dword ptr -4
.text$mn:00000738
.text$mn:00000738                 push    ebp
.text$mn:00000739                 mov     ebp, esp
.text$mn:0000073B                 push    ecx
.text$mn:0000073C                 mov     [ebp+var_4], ecx
.text$mn:0000073F                 mov     eax, [ebp+var_4]
.text$mn:00000742                 mov     dword ptr [eax], 0
.text$mn:00000748                 mov     eax, [ebp+var_4]
.text$mn:0000074B                 mov     esp, ebp
.text$mn:0000074D                 pop     ebp
.text$mn:0000074E                 retn
.text$mn:0000074E ??0_Container_base12@std@@QAE@XZ endp
.text$mn:0000074E
.text$mn:0000074E ; ---------------------------------------------------------------------------
.text$mn:0000074F                 align 10h
.text$mn:0000074F _text$mn        ends
.text$mn:0000074F
.text$mn:00000750 ; ===========================================================================
.text$mn:00000750
.text$mn:00000750 ; Segment type: Pure code
.text$mn:00000750 ; Segment permissions: Read/Execute
.text$mn:00000750 _text$mn        segment para public 'CODE' use32
.text$mn:00000750                 assume cs:_text$mn
.text$mn:00000750                 ;org 750h
.text$mn:00000750 ; COMDAT (pick any)
.text$mn:00000750                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text$mn:00000750
.text$mn:00000750 ; =============== S U B R O U T I N E =======================================
.text$mn:00000750
.text$mn:00000750 ; Attributes: bp-based frame
.text$mn:00000750
.text$mn:00000750 ; _DWORD __thiscall std::_Container_proxy::_Container_proxy(std::_Container_proxy *__hidden this)
.text$mn:00000750                 public ??0_Container_proxy@std@@QAE@XZ
.text$mn:00000750 ??0_Container_proxy@std@@QAE@XZ proc near
.text$mn:00000750                                         ; CODE XREF: std::_String_alloc<0,std::_String_base_types<char,std::allocator<char>>>::_Alloc_proxy(void)+23p
.text$mn:00000750
.text$mn:00000750 var_4           = dword ptr -4
.text$mn:00000750
.text$mn:00000750                 push    ebp
.text$mn:00000751                 mov     ebp, esp
.text$mn:00000753                 push    ecx
.text$mn:00000754                 mov     [ebp+var_4], ecx
.text$mn:00000757                 mov     eax, [ebp+var_4]
.text$mn:0000075A                 mov     dword ptr [eax], 0
.text$mn:00000760                 mov     ecx, [ebp+var_4]
.text$mn:00000763                 mov     dword ptr [ecx+4], 0
.text$mn:0000076A                 mov     eax, [ebp+var_4]
.text$mn:0000076D                 mov     esp, ebp
.text$mn:0000076F                 pop     ebp
.text$mn:00000770                 retn
.text$mn:00000770 ??0_Container_proxy@std@@QAE@XZ endp
.text$mn:00000770
.text$mn:00000770 ; ---------------------------------------------------------------------------
.text$mn:00000771                 align 4
.text$mn:00000771 _text$mn        ends
.text$mn:00000771
.text$mn:00000774 ; ===========================================================================
.text$mn:00000774
.text$mn:00000774 ; Segment type: Pure code
.text$mn:00000774 ; Segment permissions: Read/Execute
.text$mn:00000774 _text$mn        segment para public 'CODE' use32
.text$mn:00000774                 assume cs:_text$mn
.text$mn:00000774                 ;org 774h
.text$mn:00000774 ; COMDAT (pick any)
.text$mn:00000774                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text$mn:00000774
.text$mn:00000774 ; =============== S U B R O U T I N E =======================================
.text$mn:00000774
.text$mn:00000774 ; Attributes: bp-based frame
.text$mn:00000774
.text$mn:00000774 ; _DWORD __thiscall std::_Generic_error_category::_Generic_error_category(std::_Generic_error_category *__hidden this)
.text$mn:00000774                 public ??0_Generic_error_category@std@@QAE@XZ
.text$mn:00000774 ??0_Generic_error_category@std@@QAE@XZ proc near
.text$mn:00000774                                         ; CODE XREF: std::_Iostream_error_category::_Iostream_error_category(void)+29p
.text$mn:00000774                                         ; std::_System_error_category::_System_error_category(void)+29p ...
.text$mn:00000774
.text$mn:00000774 var_10          = dword ptr -10h
.text$mn:00000774 var_C           = dword ptr -0Ch
.text$mn:00000774 var_4           = dword ptr -4
.text$mn:00000774
.text$mn:00000774                 push    ebp
.text$mn:00000775                 mov     ebp, esp
.text$mn:00000777                 push    0FFFFFFFFh
.text$mn:00000779                 push    offset __ehhandler$??0_Generic_error_category@std@@QAE@XZ
.text$mn:0000077E                 mov     eax, large fs:0
.text$mn:00000784                 push    eax
.text$mn:00000785                 push    ecx
.text$mn:00000786                 mov     eax, dword ptr ds:___security_cookie
.text$mn:0000078B                 xor     eax, ebp
.text$mn:0000078D                 push    eax
.text$mn:0000078E                 lea     eax, [ebp+var_C]
.text$mn:00000791                 mov     large fs:0, eax
.text$mn:00000797                 mov     [ebp+var_10], ecx
.text$mn:0000079A                 mov     ecx, [ebp+var_10] ; this
.text$mn:0000079D                 call    ??0error_category@std@@QAE@XZ ; std::error_category::error_category(void)
.text$mn:000007A2                 mov     [ebp+var_4], 0
.text$mn:000007A9                 mov     eax, [ebp+var_10]
.text$mn:000007AC                 mov     dword ptr [eax], offset ??_7_Generic_error_category@std@@6B@ ; const std::_Generic_error_category::`vftable'
.text$mn:000007B2                 mov     [ebp+var_4], 0FFFFFFFFh
.text$mn:000007B9                 mov     eax, [ebp+var_10]
.text$mn:000007BC                 mov     ecx, [ebp+var_C]
.text$mn:000007BF                 mov     large fs:0, ecx
.text$mn:000007C6                 pop     ecx
.text$mn:000007C7                 mov     esp, ebp
.text$mn:000007C9                 pop     ebp
.text$mn:000007CA                 retn
.text$mn:000007CA ??0_Generic_error_category@std@@QAE@XZ endp
.text$mn:000007CA
.text$mn:000007CA ; ---------------------------------------------------------------------------
.text$mn:000007CB                 align 4
.text$mn:000007CB _text$mn        ends
.text$mn:000007CB
.text$x:000007CC ; ===========================================================================
.text$x:000007CC
.text$x:000007CC ; Segment type: Pure code
.text$x:000007CC ; Segment permissions: Read/Execute
.text$x:000007CC _text$x         segment para public 'CODE' use32
.text$x:000007CC                 assume cs:_text$x
.text$x:000007CC                 ;org 7CCh
.text$x:000007CC ; COMDAT (pick associative to section at 774)
.text$x:000007CC                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text$x:000007CC
.text$x:000007CC ; =============== S U B R O U T I N E =======================================
.text$x:000007CC
.text$x:000007CC
.text$x:000007CC __unwindfunclet$??0_Generic_error_category@std@@QAE@XZ$0 proc near
.text$x:000007CC                                         ; DATA XREF: .xdata$x:00001D7Co
.text$x:000007CC                 mov     ecx, [ebp-10h]  ; this
.text$x:000007CF                 jmp     ??1error_category@std@@UAE@XZ ; std::error_category::~error_category(void)
.text$x:000007CF __unwindfunclet$??0_Generic_error_category@std@@QAE@XZ$0 endp
.text$x:000007CF
.text$x:000007D4
.text$x:000007D4 ; =============== S U B R O U T I N E =======================================
.text$x:000007D4
.text$x:000007D4
.text$x:000007D4 __ehhandler$??0_Generic_error_category@std@@QAE@XZ proc near
.text$x:000007D4                                         ; DATA XREF: std::_Generic_error_category::_Generic_error_category(void)+5o
.text$x:000007D4
.text$x:000007D4 arg_4           = dword ptr  8
.text$x:000007D4
.text$x:000007D4                 mov     edx, [esp+arg_4]
.text$x:000007D8                 lea     eax, [edx+0Ch]
.text$x:000007DB                 mov     ecx, [edx-8]
.text$x:000007DE                 xor     ecx, eax
.text$x:000007E0                 call    @__security_check_cookie@4 ; __security_check_cookie(x)
.text$x:000007E5                 mov     eax, offset __ehfuncinfo$??0_Generic_error_category@std@@QAE@XZ
.text$x:000007EA                 jmp     ___CxxFrameHandler3
.text$x:000007EA __ehhandler$??0_Generic_error_category@std@@QAE@XZ endp
.text$x:000007EA
.text$x:000007EA ; ---------------------------------------------------------------------------
.text$x:000007EF                 align 10h
.text$x:000007EF _text$x         ends
.text$x:000007EF
.text$mn:000007F0 ; ===========================================================================
.text$mn:000007F0
.text$mn:000007F0 ; Segment type: Pure code
.text$mn:000007F0 ; Segment permissions: Read/Execute
.text$mn:000007F0 _text$mn        segment para public 'CODE' use32
.text$mn:000007F0                 assume cs:_text$mn
.text$mn:000007F0                 ;org 7F0h
.text$mn:000007F0 ; COMDAT (pick any)
.text$mn:000007F0                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text$mn:000007F0
.text$mn:000007F0 ; =============== S U B R O U T I N E =======================================
.text$mn:000007F0
.text$mn:000007F0 ; Attributes: bp-based frame
.text$mn:000007F0
.text$mn:000007F0 ; _DWORD __thiscall std::_Iostream_error_category::_Iostream_error_category(std::_Iostream_error_category *__hidden this)
.text$mn:000007F0                 public ??0_Iostream_error_category@std@@QAE@XZ
.text$mn:000007F0 ??0_Iostream_error_category@std@@QAE@XZ proc near
.text$mn:000007F0                                         ; CODE XREF: `dynamic initializer for 'std::_Iostream_error_category std::_Error_objects<int>::_Iostream_object''(void)+8p
.text$mn:000007F0
.text$mn:000007F0 var_10          = dword ptr -10h
.text$mn:000007F0 var_C           = dword ptr -0Ch
.text$mn:000007F0 var_4           = dword ptr -4
.text$mn:000007F0
.text$mn:000007F0                 push    ebp
.text$mn:000007F1                 mov     ebp, esp
.text$mn:000007F3                 push    0FFFFFFFFh
.text$mn:000007F5                 push    offset __ehhandler$??0_Iostream_error_category@std@@QAE@XZ
.text$mn:000007FA                 mov     eax, large fs:0
.text$mn:00000800                 push    eax
.text$mn:00000801                 push    ecx
.text$mn:00000802                 mov     eax, dword ptr ds:___security_cookie
.text$mn:00000807                 xor     eax, ebp
.text$mn:00000809                 push    eax
.text$mn:0000080A                 lea     eax, [ebp+var_C]
.text$mn:0000080D                 mov     large fs:0, eax
.text$mn:00000813                 mov     [ebp+var_10], ecx
.text$mn:00000816                 mov     ecx, [ebp+var_10] ; this
.text$mn:00000819                 call    ??0_Generic_error_category@std@@QAE@XZ ; std::_Generic_error_category::_Generic_error_category(void)
.text$mn:0000081E                 mov     [ebp+var_4], 0
.text$mn:00000825                 mov     eax, [ebp+var_10]
.text$mn:00000828                 mov     dword ptr [eax], offset ??_7_Iostream_error_category@std@@6B@ ; const std::_Iostream_error_category::`vftable'
.text$mn:0000082E                 mov     [ebp+var_4], 0FFFFFFFFh
.text$mn:00000835                 mov     eax, [ebp+var_10]
.text$mn:00000838                 mov     ecx, [ebp+var_C]
.text$mn:0000083B                 mov     large fs:0, ecx
.text$mn:00000842                 pop     ecx
.text$mn:00000843                 mov     esp, ebp
.text$mn:00000845                 pop     ebp
.text$mn:00000846                 retn
.text$mn:00000846 ??0_Iostream_error_category@std@@QAE@XZ endp
.text$mn:00000846
.text$mn:00000846 ; ---------------------------------------------------------------------------
.text$mn:00000847                 align 4
.text$mn:00000847 _text$mn        ends
.text$mn:00000847
.text$x:00000848 ; ===========================================================================
.text$x:00000848
.text$x:00000848 ; Segment type: Pure code
.text$x:00000848 ; Segment permissions: Read/Execute
.text$x:00000848 _text$x         segment para public 'CODE' use32
.text$x:00000848                 assume cs:_text$x
.text$x:00000848                 ;org 848h
.text$x:00000848 ; COMDAT (pick associative to section at 7F0)
.text$x:00000848                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text$x:00000848
.text$x:00000848 ; =============== S U B R O U T I N E =======================================
.text$x:00000848
.text$x:00000848
.text$x:00000848 __unwindfunclet$??0_Iostream_error_category@std@@QAE@XZ$0 proc near
.text$x:00000848                                         ; DATA XREF: .xdata$x:00001E00o
.text$x:00000848                 mov     ecx, [ebp-10h]  ; this
.text$x:0000084B                 jmp     ??1_Generic_error_category@std@@UAE@XZ ; std::_Generic_error_category::~_Generic_error_category(void)
.text$x:0000084B __unwindfunclet$??0_Iostream_error_category@std@@QAE@XZ$0 endp
.text$x:0000084B
.text$x:00000850
.text$x:00000850 ; =============== S U B R O U T I N E =======================================
.text$x:00000850
.text$x:00000850
.text$x:00000850 __ehhandler$??0_Iostream_error_category@std@@QAE@XZ proc near
.text$x:00000850                                         ; DATA XREF: std::_Iostream_error_category::_Iostream_error_category(void)+5o
.text$x:00000850
.text$x:00000850 arg_4           = dword ptr  8
.text$x:00000850
.text$x:00000850                 mov     edx, [esp+arg_4]
.text$x:00000854                 lea     eax, [edx+0Ch]
.text$x:00000857                 mov     ecx, [edx-8]
.text$x:0000085A                 xor     ecx, eax
.text$x:0000085C                 call    @__security_check_cookie@4 ; __security_check_cookie(x)
.text$x:00000861                 mov     eax, offset __ehfuncinfo$??0_Iostream_error_category@std@@QAE@XZ
.text$x:00000866                 jmp     ___CxxFrameHandler3
.text$x:00000866 __ehhandler$??0_Iostream_error_category@std@@QAE@XZ endp
.text$x:00000866
.text$x:00000866 ; ---------------------------------------------------------------------------
.text$x:0000086B                 align 4
.text$x:0000086B _text$x         ends
.text$x:0000086B
.text$mn:0000086C ; ===========================================================================
.text$mn:0000086C
.text$mn:0000086C ; Segment type: Pure code
.text$mn:0000086C ; Segment permissions: Read/Execute
.text$mn:0000086C _text$mn        segment para public 'CODE' use32
.text$mn:0000086C                 assume cs:_text$mn
.text$mn:0000086C                 ;org 86Ch
.text$mn:0000086C ; COMDAT (pick any)
.text$mn:0000086C                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text$mn:0000086C
.text$mn:0000086C ; =============== S U B R O U T I N E =======================================
.text$mn:0000086C
.text$mn:0000086C ; Attributes: bp-based frame
.text$mn:0000086C
.text$mn:0000086C ; _DWORD __thiscall std::_System_error_category::_System_error_category(std::_System_error_category *__hidden this)
.text$mn:0000086C                 public ??0_System_error_category@std@@QAE@XZ
.text$mn:0000086C ??0_System_error_category@std@@QAE@XZ proc near
.text$mn:0000086C                                         ; CODE XREF: `dynamic initializer for 'std::_System_error_category std::_Error_objects<int>::_System_object''(void)+8p
.text$mn:0000086C
.text$mn:0000086C var_10          = dword ptr -10h
.text$mn:0000086C var_C           = dword ptr -0Ch
.text$mn:0000086C var_4           = dword ptr -4
.text$mn:0000086C
.text$mn:0000086C                 push    ebp
.text$mn:0000086D                 mov     ebp, esp
.text$mn:0000086F                 push    0FFFFFFFFh
.text$mn:00000871                 push    offset __ehhandler$??0_System_error_category@std@@QAE@XZ
.text$mn:00000876                 mov     eax, large fs:0
.text$mn:0000087C                 push    eax
.text$mn:0000087D                 push    ecx
.text$mn:0000087E                 mov     eax, dword ptr ds:___security_cookie
.text$mn:00000883                 xor     eax, ebp
.text$mn:00000885                 push    eax
.text$mn:00000886                 lea     eax, [ebp+var_C]
.text$mn:00000889                 mov     large fs:0, eax
.text$mn:0000088F                 mov     [ebp+var_10], ecx
.text$mn:00000892                 mov     ecx, [ebp+var_10] ; this
.text$mn:00000895                 call    ??0_Generic_error_category@std@@QAE@XZ ; std::_Generic_error_category::_Generic_error_category(void)
.text$mn:0000089A                 mov     [ebp+var_4], 0
.text$mn:000008A1                 mov     eax, [ebp+var_10]
.text$mn:000008A4                 mov     dword ptr [eax], offset ??_7_System_error_category@std@@6B@ ; const std::_System_error_category::`vftable'
.text$mn:000008AA                 mov     [ebp+var_4], 0FFFFFFFFh
.text$mn:000008B1                 mov     eax, [ebp+var_10]
.text$mn:000008B4                 mov     ecx, [ebp+var_C]
.text$mn:000008B7                 mov     large fs:0, ecx
.text$mn:000008BE                 pop     ecx
.text$mn:000008BF                 mov     esp, ebp
.text$mn:000008C1                 pop     ebp
.text$mn:000008C2                 retn
.text$mn:000008C2 ??0_System_error_category@std@@QAE@XZ endp
.text$mn:000008C2
.text$mn:000008C2 ; ---------------------------------------------------------------------------
.text$mn:000008C3                 align 4
.text$mn:000008C3 _text$mn        ends
.text$mn:000008C3
.text$x:000008C4 ; ===========================================================================
.text$x:000008C4
.text$x:000008C4 ; Segment type: Pure code
.text$x:000008C4 ; Segment permissions: Read/Execute
.text$x:000008C4 _text$x         segment para public 'CODE' use32
.text$x:000008C4                 assume cs:_text$x
.text$x:000008C4                 ;org 8C4h
.text$x:000008C4 ; COMDAT (pick associative to section at 86C)
.text$x:000008C4                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text$x:000008C4
.text$x:000008C4 ; =============== S U B R O U T I N E =======================================
.text$x:000008C4
.text$x:000008C4
.text$x:000008C4 __unwindfunclet$??0_System_error_category@std@@QAE@XZ$0 proc near
.text$x:000008C4                                         ; DATA XREF: .xdata$x:00001E84o
.text$x:000008C4                 mov     ecx, [ebp-10h]  ; this
.text$x:000008C7                 jmp     ??1_Generic_error_category@std@@UAE@XZ ; std::_Generic_error_category::~_Generic_error_category(void)
.text$x:000008C7 __unwindfunclet$??0_System_error_category@std@@QAE@XZ$0 endp
.text$x:000008C7
.text$x:000008CC
.text$x:000008CC ; =============== S U B R O U T I N E =======================================
.text$x:000008CC
.text$x:000008CC
.text$x:000008CC __ehhandler$??0_System_error_category@std@@QAE@XZ proc near
.text$x:000008CC                                         ; DATA XREF: std::_System_error_category::_System_error_category(void)+5o
.text$x:000008CC
.text$x:000008CC arg_4           = dword ptr  8
.text$x:000008CC
.text$x:000008CC                 mov     edx, [esp+arg_4]
.text$x:000008D0                 lea     eax, [edx+0Ch]
.text$x:000008D3                 mov     ecx, [edx-8]
.text$x:000008D6                 xor     ecx, eax
.text$x:000008D8                 call    @__security_check_cookie@4 ; __security_check_cookie(x)
.text$x:000008DD                 mov     eax, offset __ehfuncinfo$??0_System_error_category@std@@QAE@XZ
.text$x:000008E2                 jmp     ___CxxFrameHandler3
.text$x:000008E2 __ehhandler$??0_System_error_category@std@@QAE@XZ endp
.text$x:000008E2
.text$x:000008E2 ; ---------------------------------------------------------------------------
.text$x:000008E7                 align 4
.text$x:000008E7 _text$x         ends
.text$x:000008E7
.text$mn:000008E8 ; ===========================================================================
.text$mn:000008E8
.text$mn:000008E8 ; Segment type: Pure code
.text$mn:000008E8 ; Segment permissions: Read/Execute
.text$mn:000008E8 _text$mn        segment para public 'CODE' use32
.text$mn:000008E8                 assume cs:_text$mn
.text$mn:000008E8                 ;org 8E8h
.text$mn:000008E8 ; COMDAT (pick any)
.text$mn:000008E8                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text$mn:000008E8
.text$mn:000008E8 ; =============== S U B R O U T I N E =======================================
.text$mn:000008E8
.text$mn:000008E8 ; Attributes: bp-based frame
.text$mn:000008E8
.text$mn:000008E8 ; _DWORD __thiscall std::error_category::error_category(std::error_category *__hidden this)
.text$mn:000008E8                 public ??0error_category@std@@QAE@XZ
.text$mn:000008E8 ??0error_category@std@@QAE@XZ proc near ; CODE XREF: std::_Generic_error_category::_Generic_error_category(void)+29p
.text$mn:000008E8
.text$mn:000008E8 var_4           = dword ptr -4
.text$mn:000008E8
.text$mn:000008E8                 push    ebp
.text$mn:000008E9                 mov     ebp, esp
.text$mn:000008EB                 push    ecx
.text$mn:000008EC                 mov     [ebp+var_4], ecx
.text$mn:000008EF                 mov     eax, [ebp+var_4]
.text$mn:000008F2                 mov     dword ptr [eax], offset ??_7error_category@std@@6B@ ; const std::error_category::`vftable'
.text$mn:000008F8                 mov     eax, [ebp+var_4]
.text$mn:000008FB                 mov     esp, ebp
.text$mn:000008FD                 pop     ebp
.text$mn:000008FE                 retn
.text$mn:000008FE ??0error_category@std@@QAE@XZ endp
.text$mn:000008FE
.text$mn:000008FE ; ---------------------------------------------------------------------------
.text$mn:000008FF                 align 10h
.text$mn:000008FF _text$mn        ends
.text$mn:000008FF
.text$mn:00000900 ; ===========================================================================
.text$mn:00000900
.text$mn:00000900 ; Segment type: Pure code
.text$mn:00000900 ; Segment permissions: Read/Execute
.text$mn:00000900 _text$mn        segment para public 'CODE' use32
.text$mn:00000900                 assume cs:_text$mn
.text$mn:00000900                 ;org 900h
.text$mn:00000900 ; COMDAT (pick any)
.text$mn:00000900                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text$mn:00000900
.text$mn:00000900 ; =============== S U B R O U T I N E =======================================
.text$mn:00000900
.text$mn:00000900 ; Attributes: bp-based frame
.text$mn:00000900
.text$mn:00000900 ; _DWORD __thiscall std::error_condition::error_condition(std::error_condition *this, int, const struct std::error_category *)
.text$mn:00000900                 public ??0error_condition@std@@QAE@HABVerror_category@1@@Z
.text$mn:00000900 ??0error_condition@std@@QAE@HABVerror_category@1@@Z proc near
.text$mn:00000900                                         ; CODE XREF: std::_System_error_category::default_error_condition(int)+24p
.text$mn:00000900                                         ; std::_System_error_category::default_error_condition(int)+3Dp ...
.text$mn:00000900
.text$mn:00000900 var_4           = dword ptr -4
.text$mn:00000900 arg_0           = dword ptr  8
.text$mn:00000900 arg_4           = dword ptr  0Ch
.text$mn:00000900
.text$mn:00000900                 push    ebp
.text$mn:00000901                 mov     ebp, esp
.text$mn:00000903                 push    ecx
.text$mn:00000904                 mov     [ebp+var_4], ecx
.text$mn:00000907                 mov     eax, [ebp+var_4]
.text$mn:0000090A                 mov     ecx, [ebp+arg_0]
.text$mn:0000090D                 mov     [eax], ecx
.text$mn:0000090F                 mov     edx, [ebp+var_4]
.text$mn:00000912                 mov     eax, [ebp+arg_4]
.text$mn:00000915                 mov     [edx+4], eax
.text$mn:00000918                 mov     eax, [ebp+var_4]
.text$mn:0000091B                 mov     esp, ebp
.text$mn:0000091D                 pop     ebp
.text$mn:0000091E                 retn    8
.text$mn:0000091E ??0error_condition@std@@QAE@HABVerror_category@1@@Z endp
.text$mn:0000091E
.text$mn:0000091E ; ---------------------------------------------------------------------------
.text$mn:00000921                 align 4
.text$mn:00000921 _text$mn        ends
.text$mn:00000921
.text$mn:00000924 ; ===========================================================================
.text$mn:00000924
.text$mn:00000924 ; Segment type: Pure code
.text$mn:00000924 ; Segment permissions: Read/Execute
.text$mn:00000924 _text$mn        segment para public 'CODE' use32
.text$mn:00000924                 assume cs:_text$mn
.text$mn:00000924                 ;org 924h
.text$mn:00000924 ; COMDAT (pick any)
.text$mn:00000924                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text$mn:00000924
.text$mn:00000924 ; =============== S U B R O U T I N E =======================================
.text$mn:00000924
.text$mn:00000924 ; Attributes: bp-based frame
.text$mn:00000924
.text$mn:00000924 ; _DWORD __thiscall std::locale::id::id(std::locale::id *this, unsigned int)
.text$mn:00000924                 public ??0id@locale@std@@QAE@I@Z
.text$mn:00000924 ??0id@locale@std@@QAE@I@Z proc near     ; CODE XREF: `dynamic initializer for 'std::locale::id std::num_put<char,std::back_insert_iterator<std::basic_string<char,std::char_traits<char>,std::allocator<char>>>>::id''(void)+Ap
.text$mn:00000924                                         ; `dynamic initializer for 'std::locale::id std::num_put<wchar_t,std::back_insert_iterator<std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>>>>::id''(void)+Ap ...
.text$mn:00000924
.text$mn:00000924 var_4           = dword ptr -4
.text$mn:00000924 arg_0           = dword ptr  8
.text$mn:00000924
.text$mn:00000924                 push    ebp
.text$mn:00000925                 mov     ebp, esp
.text$mn:00000927                 push    ecx
.text$mn:00000928                 mov     [ebp+var_4], ecx
.text$mn:0000092B                 mov     eax, [ebp+var_4]
.text$mn:0000092E                 mov     ecx, [ebp+arg_0]
.text$mn:00000931                 mov     [eax], ecx
.text$mn:00000933                 mov     eax, [ebp+var_4]
.text$mn:00000936                 mov     esp, ebp
.text$mn:00000938                 pop     ebp
.text$mn:00000939                 retn    4
.text$mn:00000939 ??0id@locale@std@@QAE@I@Z endp
.text$mn:00000939
.text$mn:00000939 _text$mn        ends
.text$mn:00000939
.text$mn:0000093C ; ===========================================================================
.text$mn:0000093C
.text$mn:0000093C ; Segment type: Pure code
.text$mn:0000093C ; Segment permissions: Read/Execute
.text$mn:0000093C _text$mn        segment para public 'CODE' use32
.text$mn:0000093C                 assume cs:_text$mn
.text$mn:0000093C                 ;org 93Ch
.text$mn:0000093C ; COMDAT (pick any)
.text$mn:0000093C                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text$mn:0000093C
.text$mn:0000093C ; =============== S U B R O U T I N E =======================================
.text$mn:0000093C
.text$mn:0000093C ; Attributes: bp-based frame
.text$mn:0000093C
.text$mn:0000093C ; public: __thiscall std::_String_alloc<0, struct std::_String_base_types<char, class std::allocator<char>>>::~_String_alloc<0, struct std::_String_base_types<char, class std::allocator<char>>>(void)
.text$mn:0000093C                 public ??1?$_String_alloc@$0A@U?$_String_base_types@DV?$allocator@D@std@@@std@@@std@@QAE@XZ
.text$mn:0000093C ??1?$_String_alloc@$0A@U?$_String_base_types@DV?$allocator@D@std@@@std@@@std@@QAE@XZ proc near
.text$mn:0000093C                                         ; CODE XREF: __unwindfunclet$??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@PBD@Z$0+3j
.text$mn:0000093C                                         ; std::basic_string<char,std::char_traits<char>,std::allocator<char>>::~basic_string<char,std::char_traits<char>,std::allocator<char>>(void)+43p ...
.text$mn:0000093C
.text$mn:0000093C var_10          = dword ptr -10h
.text$mn:0000093C var_C           = dword ptr -0Ch
.text$mn:0000093C var_4           = dword ptr -4
.text$mn:0000093C
.text$mn:0000093C                 push    ebp
.text$mn:0000093D                 mov     ebp, esp
.text$mn:0000093F                 push    0FFFFFFFFh
.text$mn:00000941                 push    offset __ehhandler$??1?$_String_alloc@$0A@U?$_String_base_types@DV?$allocator@D@std@@@std@@@std@@QAE@XZ
.text$mn:00000946                 mov     eax, large fs:0
.text$mn:0000094C                 push    eax
.text$mn:0000094D                 push    ecx
.text$mn:0000094E                 mov     eax, dword ptr ds:___security_cookie
.text$mn:00000953                 xor     eax, ebp
.text$mn:00000955                 push    eax
.text$mn:00000956                 lea     eax, [ebp+var_C]
.text$mn:00000959                 mov     large fs:0, eax
.text$mn:0000095F                 mov     [ebp+var_10], ecx
.text$mn:00000962                 mov     [ebp+var_4], 0
.text$mn:00000969                 mov     ecx, [ebp+var_10]
.text$mn:0000096C                 call    ?_Free_proxy@?$_String_alloc@$0A@U?$_String_base_types@DV?$allocator@D@std@@@std@@@std@@QAEXXZ ; std::_String_alloc<0,std::_String_base_types<char,std::allocator<char>>>::_Free_proxy(void)
.text$mn:00000971                 mov     [ebp+var_4], 0FFFFFFFFh
.text$mn:00000978                 mov     ecx, [ebp+var_10]
.text$mn:0000097B                 call    ??1?$_String_val@U?$_Simple_types@D@std@@@std@@QAE@XZ ; std::_String_val<std::_Simple_types<char>>::~_String_val<std::_Simple_types<char>>(void)
.text$mn:00000980                 mov     ecx, [ebp+var_C]
.text$mn:00000983                 mov     large fs:0, ecx
.text$mn:0000098A                 pop     ecx
.text$mn:0000098B                 mov     esp, ebp
.text$mn:0000098D                 pop     ebp
.text$mn:0000098E                 retn
.text$mn:0000098E ??1?$_String_alloc@$0A@U?$_String_base_types@DV?$allocator@D@std@@@std@@@std@@QAE@XZ endp
.text$mn:0000098E
.text$mn:0000098E ; ---------------------------------------------------------------------------
.text$mn:0000098F                 align 10h
.text$mn:0000098F _text$mn        ends
.text$mn:0000098F
.text$x:00000990 ; ===========================================================================
.text$x:00000990
.text$x:00000990 ; Segment type: Pure code
.text$x:00000990 ; Segment permissions: Read/Execute
.text$x:00000990 _text$x         segment para public 'CODE' use32
.text$x:00000990                 assume cs:_text$x
.text$x:00000990                 ;org 990h
.text$x:00000990 ; COMDAT (pick associative to section at 93C)
.text$x:00000990                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text$x:00000990
.text$x:00000990 ; =============== S U B R O U T I N E =======================================
.text$x:00000990
.text$x:00000990
.text$x:00000990 __unwindfunclet$??1?$_String_alloc@$0A@U?$_String_base_types@DV?$allocator@D@std@@@std@@@std@@QAE@XZ$0 proc near
.text$x:00000990                                         ; DATA XREF: .xdata$x:00001C6Co
.text$x:00000990                 mov     ecx, [ebp-10h]
.text$x:00000993                 jmp     ??1?$_String_val@U?$_Simple_types@D@std@@@std@@QAE@XZ ; std::_String_val<std::_Simple_types<char>>::~_String_val<std::_Simple_types<char>>(void)
.text$x:00000993 __unwindfunclet$??1?$_String_alloc@$0A@U?$_String_base_types@DV?$allocator@D@std@@@std@@@std@@QAE@XZ$0 endp
.text$x:00000993
.text$x:00000998
.text$x:00000998 ; =============== S U B R O U T I N E =======================================
.text$x:00000998
.text$x:00000998
.text$x:00000998 __ehhandler$??1?$_String_alloc@$0A@U?$_String_base_types@DV?$allocator@D@std@@@std@@@std@@QAE@XZ proc near
.text$x:00000998                                         ; DATA XREF: std::_String_alloc<0,std::_String_base_types<char,std::allocator<char>>>::~_String_alloc<0,std::_String_base_types<char,std::allocator<char>>>(void)+5o
.text$x:00000998
.text$x:00000998 arg_4           = dword ptr  8
.text$x:00000998
.text$x:00000998                 mov     edx, [esp+arg_4]
.text$x:0000099C                 lea     eax, [edx+0Ch]
.text$x:0000099F                 mov     ecx, [edx-8]
.text$x:000009A2                 xor     ecx, eax
.text$x:000009A4                 call    @__security_check_cookie@4 ; __security_check_cookie(x)
.text$x:000009A9                 mov     eax, offset __ehfuncinfo$??1?$_String_alloc@$0A@U?$_String_base_types@DV?$allocator@D@std@@@std@@@std@@QAE@XZ
.text$x:000009AE                 jmp     ___CxxFrameHandler3
.text$x:000009AE __ehhandler$??1?$_String_alloc@$0A@U?$_String_base_types@DV?$allocator@D@std@@@std@@@std@@QAE@XZ endp
.text$x:000009AE
.text$x:000009AE ; ---------------------------------------------------------------------------
.text$x:000009B3                 align 4
.text$x:000009B3 _text$x         ends
.text$x:000009B3
.text$mn:000009B4 ; ===========================================================================
.text$mn:000009B4
.text$mn:000009B4 ; Segment type: Pure code
.text$mn:000009B4 ; Segment permissions: Read/Execute
.text$mn:000009B4 _text$mn        segment para public 'CODE' use32
.text$mn:000009B4                 assume cs:_text$mn
.text$mn:000009B4                 ;org 9B4h
.text$mn:000009B4 ; COMDAT (pick any)
.text$mn:000009B4                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text$mn:000009B4
.text$mn:000009B4 ; =============== S U B R O U T I N E =======================================
.text$mn:000009B4
.text$mn:000009B4 ; Attributes: bp-based frame
.text$mn:000009B4
.text$mn:000009B4 ; public: __thiscall std::_String_val<struct std::_Simple_types<char>>::~_String_val<struct std::_Simple_types<char>>(void)
.text$mn:000009B4                 public ??1?$_String_val@U?$_Simple_types@D@std@@@std@@QAE@XZ
.text$mn:000009B4 ??1?$_String_val@U?$_Simple_types@D@std@@@std@@QAE@XZ proc near
.text$mn:000009B4                                         ; CODE XREF: __unwindfunclet$??0?$_String_alloc@$0A@U?$_String_base_types@DV?$allocator@D@std@@@std@@@std@@QAE@ABV?$allocator@D@1@@Z$0+3j
.text$mn:000009B4                                         ; std::_String_alloc<0,std::_String_base_types<char,std::allocator<char>>>::~_String_alloc<0,std::_String_base_types<char,std::allocator<char>>>(void)+3Fp ...
.text$mn:000009B4
.text$mn:000009B4 var_10          = dword ptr -10h
.text$mn:000009B4 var_C           = dword ptr -0Ch
.text$mn:000009B4 var_4           = dword ptr -4
.text$mn:000009B4
.text$mn:000009B4                 push    ebp
.text$mn:000009B5                 mov     ebp, esp
.text$mn:000009B7                 push    0FFFFFFFFh
.text$mn:000009B9                 push    offset __ehhandler$??1?$_String_val@U?$_Simple_types@D@std@@@std@@QAE@XZ
.text$mn:000009BE                 mov     eax, large fs:0
.text$mn:000009C4                 push    eax
.text$mn:000009C5                 push    ecx
.text$mn:000009C6                 mov     eax, dword ptr ds:___security_cookie
.text$mn:000009CB                 xor     eax, ebp
.text$mn:000009CD                 push    eax
.text$mn:000009CE                 lea     eax, [ebp+var_C]
.text$mn:000009D1                 mov     large fs:0, eax
.text$mn:000009D7                 mov     [ebp+var_10], ecx
.text$mn:000009DA                 mov     [ebp+var_4], 0
.text$mn:000009E1                 mov     [ebp+var_4], 0FFFFFFFFh
.text$mn:000009E8                 mov     ecx, [ebp+var_10] ; this
.text$mn:000009EB                 call    ??1_Container_base12@std@@QAE@XZ ; std::_Container_base12::~_Container_base12(void)
.text$mn:000009F0                 mov     ecx, [ebp+var_C]
.text$mn:000009F3                 mov     large fs:0, ecx
.text$mn:000009FA                 pop     ecx
.text$mn:000009FB                 mov     esp, ebp
.text$mn:000009FD                 pop     ebp
.text$mn:000009FE                 retn
.text$mn:000009FE ??1?$_String_val@U?$_Simple_types@D@std@@@std@@QAE@XZ endp
.text$mn:000009FE
.text$mn:000009FE ; ---------------------------------------------------------------------------
.text$mn:000009FF                 align 10h
.text$mn:000009FF _text$mn        ends
.text$mn:000009FF
.text$x:00000A00 ; ===========================================================================
.text$x:00000A00
.text$x:00000A00 ; Segment type: Pure code
.text$x:00000A00 ; Segment permissions: Read/Execute
.text$x:00000A00 _text$x         segment para public 'CODE' use32
.text$x:00000A00                 assume cs:_text$x
.text$x:00000A00                 ;org 0A00h
.text$x:00000A00 ; COMDAT (pick associative to section at 9B4)
.text$x:00000A00                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text$x:00000A00
.text$x:00000A00 ; =============== S U B R O U T I N E =======================================
.text$x:00000A00
.text$x:00000A00
.text$x:00000A00 __unwindfunclet$??1?$_String_val@U?$_Simple_types@D@std@@@std@@QAE@XZ$0 proc near
.text$x:00000A00                                         ; DATA XREF: .xdata$x:00001C14o
.text$x:00000A00                 mov     ecx, [ebp-10h]  ; this
.text$x:00000A03                 jmp     ??1_Container_base12@std@@QAE@XZ ; std::_Container_base12::~_Container_base12(void)
.text$x:00000A03 __unwindfunclet$??1?$_String_val@U?$_Simple_types@D@std@@@std@@QAE@XZ$0 endp
.text$x:00000A03
.text$x:00000A08
.text$x:00000A08 ; =============== S U B R O U T I N E =======================================
.text$x:00000A08
.text$x:00000A08
.text$x:00000A08 __ehhandler$??1?$_String_val@U?$_Simple_types@D@std@@@std@@QAE@XZ proc near
.text$x:00000A08                                         ; DATA XREF: std::_String_val<std::_Simple_types<char>>::~_String_val<std::_Simple_types<char>>(void)+5o
.text$x:00000A08
.text$x:00000A08 arg_4           = dword ptr  8
.text$x:00000A08
.text$x:00000A08                 mov     edx, [esp+arg_4]
.text$x:00000A0C                 lea     eax, [edx+0Ch]
.text$x:00000A0F                 mov     ecx, [edx-8]
.text$x:00000A12                 xor     ecx, eax
.text$x:00000A14                 call    @__security_check_cookie@4 ; __security_check_cookie(x)
.text$x:00000A19                 mov     eax, offset __ehfuncinfo$??1?$_String_val@U?$_Simple_types@D@std@@@std@@QAE@XZ
.text$x:00000A1E                 jmp     ___CxxFrameHandler3
.text$x:00000A1E __ehhandler$??1?$_String_val@U?$_Simple_types@D@std@@@std@@QAE@XZ endp
.text$x:00000A1E
.text$x:00000A1E ; ---------------------------------------------------------------------------
.text$x:00000A23                 align 4
.text$x:00000A23 _text$x         ends
.text$x:00000A23
.text$mn:00000A24 ; ===========================================================================
.text$mn:00000A24
.text$mn:00000A24 ; Segment type: Pure code
.text$mn:00000A24 ; Segment permissions: Read/Execute
.text$mn:00000A24 _text$mn        segment para public 'CODE' use32
.text$mn:00000A24                 assume cs:_text$mn
.text$mn:00000A24                 ;org 0A24h
.text$mn:00000A24 ; COMDAT (pick any)
.text$mn:00000A24                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text$mn:00000A24
.text$mn:00000A24 ; =============== S U B R O U T I N E =======================================
.text$mn:00000A24
.text$mn:00000A24 ; Attributes: bp-based frame
.text$mn:00000A24
.text$mn:00000A24 ; public: __thiscall std::basic_string<char, struct std::char_traits<char>, class std::allocator<char>>::~basic_string<char, struct std::char_traits<char>, class std::allocator<char>>(void)
.text$mn:00000A24                 public ??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ
.text$mn:00000A24 ??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ proc near
.text$mn:00000A24                                         ; CODE XREF: __unwindfunclet$?message@_Generic_error_category@std@@UBE?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@2@H@Z$0+13j
.text$mn:00000A24                                         ; __unwindfunclet$?message@_Iostream_error_category@std@@UBE?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@2@H@Z$0+13j ...
.text$mn:00000A24
.text$mn:00000A24 var_10          = dword ptr -10h
.text$mn:00000A24 var_C           = dword ptr -0Ch
.text$mn:00000A24 var_4           = dword ptr -4
.text$mn:00000A24
.text$mn:00000A24                 push    ebp
.text$mn:00000A25                 mov     ebp, esp
.text$mn:00000A27                 push    0FFFFFFFFh
.text$mn:00000A29                 push    offset __ehhandler$??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ
.text$mn:00000A2E                 mov     eax, large fs:0
.text$mn:00000A34                 push    eax
.text$mn:00000A35                 push    ecx
.text$mn:00000A36                 mov     eax, dword ptr ds:___security_cookie
.text$mn:00000A3B                 xor     eax, ebp
.text$mn:00000A3D                 push    eax
.text$mn:00000A3E                 lea     eax, [ebp+var_C]
.text$mn:00000A41                 mov     large fs:0, eax
.text$mn:00000A47                 mov     [ebp+var_10], ecx
.text$mn:00000A4A                 mov     [ebp+var_4], 0
.text$mn:00000A51                 push    0               ; Size
.text$mn:00000A53                 push    1               ; char
.text$mn:00000A55                 mov     ecx, [ebp+var_10]
.text$mn:00000A58                 call    ?_Tidy@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEX_NI@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char>>::_Tidy(bool,uint)
.text$mn:00000A5D                 mov     [ebp+var_4], 0FFFFFFFFh
.text$mn:00000A64                 mov     ecx, [ebp+var_10]
.text$mn:00000A67                 call    ??1?$_String_alloc@$0A@U?$_String_base_types@DV?$allocator@D@std@@@std@@@std@@QAE@XZ ; std::_String_alloc<0,std::_String_base_types<char,std::allocator<char>>>::~_String_alloc<0,std::_String_base_types<char,std::allocator<char>>>(void)
.text$mn:00000A6C                 mov     ecx, [ebp+var_C]
.text$mn:00000A6F                 mov     large fs:0, ecx
.text$mn:00000A76                 pop     ecx
.text$mn:00000A77                 mov     esp, ebp
.text$mn:00000A79                 pop     ebp
.text$mn:00000A7A                 retn
.text$mn:00000A7A ??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ endp
.text$mn:00000A7A
.text$mn:00000A7A ; ---------------------------------------------------------------------------
.text$mn:00000A7B                 align 4
.text$mn:00000A7B _text$mn        ends
.text$mn:00000A7B
.text$x:00000A7C ; ===========================================================================
.text$x:00000A7C
.text$x:00000A7C ; Segment type: Pure code
.text$x:00000A7C ; Segment permissions: Read/Execute
.text$x:00000A7C _text$x         segment para public 'CODE' use32
.text$x:00000A7C                 assume cs:_text$x
.text$x:00000A7C                 ;org 0A7Ch
.text$x:00000A7C ; COMDAT (pick associative to section at A24)
.text$x:00000A7C                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text$x:00000A7C
.text$x:00000A7C ; =============== S U B R O U T I N E =======================================
.text$x:00000A7C
.text$x:00000A7C
.text$x:00000A7C __unwindfunclet$??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ$0 proc near
.text$x:00000A7C                                         ; DATA XREF: .xdata$x:00001CC4o
.text$x:00000A7C                 mov     ecx, [ebp-10h]
.text$x:00000A7F                 jmp     ??1?$_String_alloc@$0A@U?$_String_base_types@DV?$allocator@D@std@@@std@@@std@@QAE@XZ ; std::_String_alloc<0,std::_String_base_types<char,std::allocator<char>>>::~_String_alloc<0,std::_String_base_types<char,std::allocator<char>>>(void)
.text$x:00000A7F __unwindfunclet$??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ$0 endp
.text$x:00000A7F
.text$x:00000A84
.text$x:00000A84 ; =============== S U B R O U T I N E =======================================
.text$x:00000A84
.text$x:00000A84
.text$x:00000A84 __ehhandler$??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ proc near
.text$x:00000A84                                         ; DATA XREF: std::basic_string<char,std::char_traits<char>,std::allocator<char>>::~basic_string<char,std::char_traits<char>,std::allocator<char>>(void)+5o
.text$x:00000A84
.text$x:00000A84 arg_4           = dword ptr  8
.text$x:00000A84
.text$x:00000A84                 mov     edx, [esp+arg_4]
.text$x:00000A88                 lea     eax, [edx+0Ch]
.text$x:00000A8B                 mov     ecx, [edx-8]
.text$x:00000A8E                 xor     ecx, eax
.text$x:00000A90                 call    @__security_check_cookie@4 ; __security_check_cookie(x)
.text$x:00000A95                 mov     eax, offset __ehfuncinfo$??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ
.text$x:00000A9A                 jmp     ___CxxFrameHandler3
.text$x:00000A9A __ehhandler$??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ endp
.text$x:00000A9A
.text$x:00000A9A ; ---------------------------------------------------------------------------
.text$x:00000A9F                 align 10h
.text$x:00000A9F _text$x         ends
.text$x:00000A9F
.text$mn:00000AA0 ; ===========================================================================
.text$mn:00000AA0
.text$mn:00000AA0 ; Segment type: Pure code
.text$mn:00000AA0 ; Segment permissions: Read/Execute
.text$mn:00000AA0 _text$mn        segment para public 'CODE' use32
.text$mn:00000AA0                 assume cs:_text$mn
.text$mn:00000AA0                 ;org 0AA0h
.text$mn:00000AA0 ; COMDAT (pick any)
.text$mn:00000AA0                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text$mn:00000AA0
.text$mn:00000AA0 ; =============== S U B R O U T I N E =======================================
.text$mn:00000AA0
.text$mn:00000AA0 ; Attributes: bp-based frame
.text$mn:00000AA0
.text$mn:00000AA0 ; _DWORD __thiscall std::_Container_base12::~_Container_base12(std::_Container_base12 *__hidden this)
.text$mn:00000AA0                 public ??1_Container_base12@std@@QAE@XZ
.text$mn:00000AA0 ??1_Container_base12@std@@QAE@XZ proc near
.text$mn:00000AA0                                         ; CODE XREF: __unwindfunclet$??0?$_String_val@U?$_Simple_types@D@std@@@std@@QAE@XZ$0+3j
.text$mn:00000AA0                                         ; std::_String_val<std::_Simple_types<char>>::~_String_val<std::_Simple_types<char>>(void)+37p ...
.text$mn:00000AA0
.text$mn:00000AA0 var_4           = dword ptr -4
.text$mn:00000AA0
.text$mn:00000AA0                 push    ebp
.text$mn:00000AA1                 mov     ebp, esp
.text$mn:00000AA3                 push    ecx
.text$mn:00000AA4                 mov     [ebp+var_4], ecx
.text$mn:00000AA7                 mov     ecx, [ebp+var_4] ; this
.text$mn:00000AAA                 call    ?_Orphan_all@_Container_base12@std@@QAEXXZ ; std::_Container_base12::_Orphan_all(void)
.text$mn:00000AAF                 mov     esp, ebp
.text$mn:00000AB1                 pop     ebp
.text$mn:00000AB2                 retn
.text$mn:00000AB2 ??1_Container_base12@std@@QAE@XZ endp
.text$mn:00000AB2
.text$mn:00000AB2 ; ---------------------------------------------------------------------------
.text$mn:00000AB3                 align 4
.text$mn:00000AB3 _text$mn        ends
.text$mn:00000AB3
.text$mn:00000AB4 ; ===========================================================================
.text$mn:00000AB4
.text$mn:00000AB4 ; Segment type: Pure code
.text$mn:00000AB4 ; Segment permissions: Read/Execute
.text$mn:00000AB4 _text$mn        segment para public 'CODE' use32
.text$mn:00000AB4                 assume cs:_text$mn
.text$mn:00000AB4                 ;org 0AB4h
.text$mn:00000AB4 ; COMDAT (pick any)
.text$mn:00000AB4                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text$mn:00000AB4
.text$mn:00000AB4 ; =============== S U B R O U T I N E =======================================
.text$mn:00000AB4
.text$mn:00000AB4 ; Attributes: bp-based frame
.text$mn:00000AB4
.text$mn:00000AB4 ; _DWORD __thiscall std::_Generic_error_category::~_Generic_error_category(std::_Generic_error_category *__hidden this)
.text$mn:00000AB4                 public ??1_Generic_error_category@std@@UAE@XZ
.text$mn:00000AB4 ??1_Generic_error_category@std@@UAE@XZ proc near
.text$mn:00000AB4                                         ; CODE XREF: __unwindfunclet$??0_Iostream_error_category@std@@QAE@XZ$0+3j
.text$mn:00000AB4                                         ; __unwindfunclet$??0_System_error_category@std@@QAE@XZ$0+3j ...
.text$mn:00000AB4
.text$mn:00000AB4 var_10          = dword ptr -10h
.text$mn:00000AB4 var_C           = dword ptr -0Ch
.text$mn:00000AB4 var_4           = dword ptr -4
.text$mn:00000AB4
.text$mn:00000AB4                 push    ebp
.text$mn:00000AB5                 mov     ebp, esp
.text$mn:00000AB7                 push    0FFFFFFFFh
.text$mn:00000AB9                 push    offset __ehhandler$??1_Generic_error_category@std@@UAE@XZ
.text$mn:00000ABE                 mov     eax, large fs:0
.text$mn:00000AC4                 push    eax
.text$mn:00000AC5                 push    ecx
.text$mn:00000AC6                 mov     eax, dword ptr ds:___security_cookie
.text$mn:00000ACB                 xor     eax, ebp
.text$mn:00000ACD                 push    eax
.text$mn:00000ACE                 lea     eax, [ebp+var_C]
.text$mn:00000AD1                 mov     large fs:0, eax
.text$mn:00000AD7                 mov     [ebp+var_10], ecx
.text$mn:00000ADA                 mov     [ebp+var_4], 0
.text$mn:00000AE1                 mov     [ebp+var_4], 0FFFFFFFFh
.text$mn:00000AE8                 mov     ecx, [ebp+var_10] ; this
.text$mn:00000AEB                 call    ??1error_category@std@@UAE@XZ ; std::error_category::~error_category(void)
.text$mn:00000AF0                 mov     ecx, [ebp+var_C]
.text$mn:00000AF3                 mov     large fs:0, ecx
.text$mn:00000AFA                 pop     ecx
.text$mn:00000AFB                 mov     esp, ebp
.text$mn:00000AFD                 pop     ebp
.text$mn:00000AFE                 retn
.text$mn:00000AFE ??1_Generic_error_category@std@@UAE@XZ endp
.text$mn:00000AFE
.text$mn:00000AFE ; ---------------------------------------------------------------------------
.text$mn:00000AFF                 align 10h
.text$mn:00000AFF _text$mn        ends
.text$mn:00000AFF
.text$x:00000B00 ; ===========================================================================
.text$x:00000B00
.text$x:00000B00 ; Segment type: Pure code
.text$x:00000B00 ; Segment permissions: Read/Execute
.text$x:00000B00 _text$x         segment para public 'CODE' use32
.text$x:00000B00                 assume cs:_text$x
.text$x:00000B00                 ;org 0B00h
.text$x:00000B00 ; COMDAT (pick associative to section at AB4)
.text$x:00000B00                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text$x:00000B00
.text$x:00000B00 ; =============== S U B R O U T I N E =======================================
.text$x:00000B00
.text$x:00000B00
.text$x:00000B00 __unwindfunclet$??1_Generic_error_category@std@@UAE@XZ$0 proc near
.text$x:00000B00                                         ; DATA XREF: .xdata$x:00001DD4o
.text$x:00000B00                 mov     ecx, [ebp-10h]  ; this
.text$x:00000B03                 jmp     ??1error_category@std@@UAE@XZ ; std::error_category::~error_category(void)
.text$x:00000B03 __unwindfunclet$??1_Generic_error_category@std@@UAE@XZ$0 endp
.text$x:00000B03
.text$x:00000B08
.text$x:00000B08 ; =============== S U B R O U T I N E =======================================
.text$x:00000B08
.text$x:00000B08
.text$x:00000B08 __ehhandler$??1_Generic_error_category@std@@UAE@XZ proc near
.text$x:00000B08                                         ; DATA XREF: std::_Generic_error_category::~_Generic_error_category(void)+5o
.text$x:00000B08
.text$x:00000B08 arg_4           = dword ptr  8
.text$x:00000B08
.text$x:00000B08                 mov     edx, [esp+arg_4]
.text$x:00000B0C                 lea     eax, [edx+0Ch]
.text$x:00000B0F                 mov     ecx, [edx-8]
.text$x:00000B12                 xor     ecx, eax
.text$x:00000B14                 call    @__security_check_cookie@4 ; __security_check_cookie(x)
.text$x:00000B19                 mov     eax, offset __ehfuncinfo$??1_Generic_error_category@std@@UAE@XZ
.text$x:00000B1E                 jmp     ___CxxFrameHandler3
.text$x:00000B1E __ehhandler$??1_Generic_error_category@std@@UAE@XZ endp
.text$x:00000B1E
.text$x:00000B1E ; ---------------------------------------------------------------------------
.text$x:00000B23                 align 4
.text$x:00000B23 _text$x         ends
.text$x:00000B23
.text$mn:00000B24 ; ===========================================================================
.text$mn:00000B24
.text$mn:00000B24 ; Segment type: Pure code
.text$mn:00000B24 ; Segment permissions: Read/Execute
.text$mn:00000B24 _text$mn        segment para public 'CODE' use32
.text$mn:00000B24                 assume cs:_text$mn
.text$mn:00000B24                 ;org 0B24h
.text$mn:00000B24 ; COMDAT (pick any)
.text$mn:00000B24                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text$mn:00000B24
.text$mn:00000B24 ; =============== S U B R O U T I N E =======================================
.text$mn:00000B24
.text$mn:00000B24 ; Attributes: bp-based frame
.text$mn:00000B24
.text$mn:00000B24 ; _DWORD __thiscall std::_Iostream_error_category::~_Iostream_error_category(std::_Iostream_error_category *__hidden this)
.text$mn:00000B24                 public ??1_Iostream_error_category@std@@UAE@XZ
.text$mn:00000B24 ??1_Iostream_error_category@std@@UAE@XZ proc near
.text$mn:00000B24                                         ; CODE XREF: std::_Iostream_error_category::`scalar deleting destructor'(uint)+Ap
.text$mn:00000B24                                         ; `dynamic atexit destructor for 'std::_Iostream_error_category std::_Error_objects<int>::_Iostream_object''(void)+8p
.text$mn:00000B24
.text$mn:00000B24 var_10          = dword ptr -10h
.text$mn:00000B24 var_C           = dword ptr -0Ch
.text$mn:00000B24 var_4           = dword ptr -4
.text$mn:00000B24
.text$mn:00000B24                 push    ebp
.text$mn:00000B25                 mov     ebp, esp
.text$mn:00000B27                 push    0FFFFFFFFh
.text$mn:00000B29                 push    offset __ehhandler$??1_Iostream_error_category@std@@UAE@XZ
.text$mn:00000B2E                 mov     eax, large fs:0
.text$mn:00000B34                 push    eax
.text$mn:00000B35                 push    ecx
.text$mn:00000B36                 mov     eax, dword ptr ds:___security_cookie
.text$mn:00000B3B                 xor     eax, ebp
.text$mn:00000B3D                 push    eax
.text$mn:00000B3E                 lea     eax, [ebp+var_C]
.text$mn:00000B41                 mov     large fs:0, eax
.text$mn:00000B47                 mov     [ebp+var_10], ecx
.text$mn:00000B4A                 mov     [ebp+var_4], 0
.text$mn:00000B51                 mov     [ebp+var_4], 0FFFFFFFFh
.text$mn:00000B58                 mov     ecx, [ebp+var_10] ; this
.text$mn:00000B5B                 call    ??1_Generic_error_category@std@@UAE@XZ ; std::_Generic_error_category::~_Generic_error_category(void)
.text$mn:00000B60                 mov     ecx, [ebp+var_C]
.text$mn:00000B63                 mov     large fs:0, ecx
.text$mn:00000B6A                 pop     ecx
.text$mn:00000B6B                 mov     esp, ebp
.text$mn:00000B6D                 pop     ebp
.text$mn:00000B6E                 retn
.text$mn:00000B6E ??1_Iostream_error_category@std@@UAE@XZ endp
.text$mn:00000B6E
.text$mn:00000B6E ; ---------------------------------------------------------------------------
.text$mn:00000B6F                 align 10h
.text$mn:00000B6F _text$mn        ends
.text$mn:00000B6F
.text$x:00000B70 ; ===========================================================================
.text$x:00000B70
.text$x:00000B70 ; Segment type: Pure code
.text$x:00000B70 ; Segment permissions: Read/Execute
.text$x:00000B70 _text$x         segment para public 'CODE' use32
.text$x:00000B70                 assume cs:_text$x
.text$x:00000B70                 ;org 0B70h
.text$x:00000B70 ; COMDAT (pick associative to section at B24)
.text$x:00000B70                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text$x:00000B70
.text$x:00000B70 ; =============== S U B R O U T I N E =======================================
.text$x:00000B70
.text$x:00000B70
.text$x:00000B70 __unwindfunclet$??1_Iostream_error_category@std@@UAE@XZ$0 proc near
.text$x:00000B70                                         ; DATA XREF: .xdata$x:00001E58o
.text$x:00000B70                 mov     ecx, [ebp-10h]  ; this
.text$x:00000B73                 jmp     ??1_Generic_error_category@std@@UAE@XZ ; std::_Generic_error_category::~_Generic_error_category(void)
.text$x:00000B73 __unwindfunclet$??1_Iostream_error_category@std@@UAE@XZ$0 endp
.text$x:00000B73
.text$x:00000B78
.text$x:00000B78 ; =============== S U B R O U T I N E =======================================
.text$x:00000B78
.text$x:00000B78
.text$x:00000B78 __ehhandler$??1_Iostream_error_category@std@@UAE@XZ proc near
.text$x:00000B78                                         ; DATA XREF: std::_Iostream_error_category::~_Iostream_error_category(void)+5o
.text$x:00000B78
.text$x:00000B78 arg_4           = dword ptr  8
.text$x:00000B78
.text$x:00000B78                 mov     edx, [esp+arg_4]
.text$x:00000B7C                 lea     eax, [edx+0Ch]
.text$x:00000B7F                 mov     ecx, [edx-8]
.text$x:00000B82                 xor     ecx, eax
.text$x:00000B84                 call    @__security_check_cookie@4 ; __security_check_cookie(x)
.text$x:00000B89                 mov     eax, offset __ehfuncinfo$??1_Iostream_error_category@std@@UAE@XZ
.text$x:00000B8E                 jmp     ___CxxFrameHandler3
.text$x:00000B8E __ehhandler$??1_Iostream_error_category@std@@UAE@XZ endp
.text$x:00000B8E
.text$x:00000B8E ; ---------------------------------------------------------------------------
.text$x:00000B93                 align 4
.text$x:00000B93 _text$x         ends
.text$x:00000B93
.text$mn:00000B94 ; ===========================================================================
.text$mn:00000B94
.text$mn:00000B94 ; Segment type: Pure code
.text$mn:00000B94 ; Segment permissions: Read/Execute
.text$mn:00000B94 _text$mn        segment para public 'CODE' use32
.text$mn:00000B94                 assume cs:_text$mn
.text$mn:00000B94                 ;org 0B94h
.text$mn:00000B94 ; COMDAT (pick any)
.text$mn:00000B94                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text$mn:00000B94
.text$mn:00000B94 ; =============== S U B R O U T I N E =======================================
.text$mn:00000B94
.text$mn:00000B94 ; Attributes: bp-based frame
.text$mn:00000B94
.text$mn:00000B94 ; _DWORD __thiscall std::_System_error_category::~_System_error_category(std::_System_error_category *__hidden this)
.text$mn:00000B94                 public ??1_System_error_category@std@@UAE@XZ
.text$mn:00000B94 ??1_System_error_category@std@@UAE@XZ proc near
.text$mn:00000B94                                         ; CODE XREF: std::_System_error_category::`scalar deleting destructor'(uint)+Ap
.text$mn:00000B94                                         ; `dynamic atexit destructor for 'std::_System_error_category std::_Error_objects<int>::_System_object''(void)+8p
.text$mn:00000B94
.text$mn:00000B94 var_10          = dword ptr -10h
.text$mn:00000B94 var_C           = dword ptr -0Ch
.text$mn:00000B94 var_4           = dword ptr -4
.text$mn:00000B94
.text$mn:00000B94                 push    ebp
.text$mn:00000B95                 mov     ebp, esp
.text$mn:00000B97                 push    0FFFFFFFFh
.text$mn:00000B99                 push    offset __ehhandler$??1_System_error_category@std@@UAE@XZ
.text$mn:00000B9E                 mov     eax, large fs:0
.text$mn:00000BA4                 push    eax
.text$mn:00000BA5                 push    ecx
.text$mn:00000BA6                 mov     eax, dword ptr ds:___security_cookie
.text$mn:00000BAB                 xor     eax, ebp
.text$mn:00000BAD                 push    eax
.text$mn:00000BAE                 lea     eax, [ebp+var_C]
.text$mn:00000BB1                 mov     large fs:0, eax
.text$mn:00000BB7                 mov     [ebp+var_10], ecx
.text$mn:00000BBA                 mov     [ebp+var_4], 0
.text$mn:00000BC1                 mov     [ebp+var_4], 0FFFFFFFFh
.text$mn:00000BC8                 mov     ecx, [ebp+var_10] ; this
.text$mn:00000BCB                 call    ??1_Generic_error_category@std@@UAE@XZ ; std::_Generic_error_category::~_Generic_error_category(void)
.text$mn:00000BD0                 mov     ecx, [ebp+var_C]
.text$mn:00000BD3                 mov     large fs:0, ecx
.text$mn:00000BDA                 pop     ecx
.text$mn:00000BDB                 mov     esp, ebp
.text$mn:00000BDD                 pop     ebp
.text$mn:00000BDE                 retn
.text$mn:00000BDE ??1_System_error_category@std@@UAE@XZ endp
.text$mn:00000BDE
.text$mn:00000BDE ; ---------------------------------------------------------------------------
.text$mn:00000BDF                 align 10h
.text$mn:00000BDF _text$mn        ends
.text$mn:00000BDF
.text$x:00000BE0 ; ===========================================================================
.text$x:00000BE0
.text$x:00000BE0 ; Segment type: Pure code
.text$x:00000BE0 ; Segment permissions: Read/Execute
.text$x:00000BE0 _text$x         segment para public 'CODE' use32
.text$x:00000BE0                 assume cs:_text$x
.text$x:00000BE0                 ;org 0BE0h
.text$x:00000BE0 ; COMDAT (pick associative to section at B94)
.text$x:00000BE0                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text$x:00000BE0
.text$x:00000BE0 ; =============== S U B R O U T I N E =======================================
.text$x:00000BE0
.text$x:00000BE0
.text$x:00000BE0 __unwindfunclet$??1_System_error_category@std@@UAE@XZ$0 proc near
.text$x:00000BE0                                         ; DATA XREF: .xdata$x:00001EDCo
.text$x:00000BE0                 mov     ecx, [ebp-10h]  ; this
.text$x:00000BE3                 jmp     ??1_Generic_error_category@std@@UAE@XZ ; std::_Generic_error_category::~_Generic_error_category(void)
.text$x:00000BE3 __unwindfunclet$??1_System_error_category@std@@UAE@XZ$0 endp
.text$x:00000BE3
.text$x:00000BE8
.text$x:00000BE8 ; =============== S U B R O U T I N E =======================================
.text$x:00000BE8
.text$x:00000BE8
.text$x:00000BE8 __ehhandler$??1_System_error_category@std@@UAE@XZ proc near
.text$x:00000BE8                                         ; DATA XREF: std::_System_error_category::~_System_error_category(void)+5o
.text$x:00000BE8
.text$x:00000BE8 arg_4           = dword ptr  8
.text$x:00000BE8
.text$x:00000BE8                 mov     edx, [esp+arg_4]
.text$x:00000BEC                 lea     eax, [edx+0Ch]
.text$x:00000BEF                 mov     ecx, [edx-8]
.text$x:00000BF2                 xor     ecx, eax
.text$x:00000BF4                 call    @__security_check_cookie@4 ; __security_check_cookie(x)
.text$x:00000BF9                 mov     eax, offset __ehfuncinfo$??1_System_error_category@std@@UAE@XZ
.text$x:00000BFE                 jmp     ___CxxFrameHandler3
.text$x:00000BFE __ehhandler$??1_System_error_category@std@@UAE@XZ endp
.text$x:00000BFE
.text$x:00000BFE ; ---------------------------------------------------------------------------
.text$x:00000C03                 align 4
.text$x:00000C03 _text$x         ends
.text$x:00000C03
.text$mn:00000C04 ; ===========================================================================
.text$mn:00000C04
.text$mn:00000C04 ; Segment type: Pure code
.text$mn:00000C04 ; Segment permissions: Read/Execute
.text$mn:00000C04 _text$mn        segment para public 'CODE' use32
.text$mn:00000C04                 assume cs:_text$mn
.text$mn:00000C04                 ;org 0C04h
.text$mn:00000C04 ; COMDAT (pick any)
.text$mn:00000C04                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text$mn:00000C04
.text$mn:00000C04 ; =============== S U B R O U T I N E =======================================
.text$mn:00000C04
.text$mn:00000C04 ; Attributes: bp-based frame
.text$mn:00000C04
.text$mn:00000C04 ; _DWORD __thiscall std::error_category::~error_category(std::error_category *__hidden this)
.text$mn:00000C04                 public ??1error_category@std@@UAE@XZ
.text$mn:00000C04 ??1error_category@std@@UAE@XZ proc near ; CODE XREF: __unwindfunclet$??0_Generic_error_category@std@@QAE@XZ$0+3j
.text$mn:00000C04                                         ; std::_Generic_error_category::~_Generic_error_category(void)+37p ...
.text$mn:00000C04
.text$mn:00000C04 var_4           = dword ptr -4
.text$mn:00000C04
.text$mn:00000C04                 push    ebp
.text$mn:00000C05                 mov     ebp, esp
.text$mn:00000C07                 push    ecx
.text$mn:00000C08                 mov     [ebp+var_4], ecx
.text$mn:00000C0B                 mov     eax, [ebp+var_4]
.text$mn:00000C0E                 mov     dword ptr [eax], offset ??_7error_category@std@@6B@ ; const std::error_category::`vftable'
.text$mn:00000C14                 mov     esp, ebp
.text$mn:00000C16                 pop     ebp
.text$mn:00000C17                 retn
.text$mn:00000C17 ??1error_category@std@@UAE@XZ endp
.text$mn:00000C17
.text$mn:00000C17 _text$mn        ends
.text$mn:00000C17
.text$mn:00000C18 ; ===========================================================================
.text$mn:00000C18
.text$mn:00000C18 ; Segment type: Pure code
.text$mn:00000C18 ; Segment permissions: Read/Execute
.text$mn:00000C18 _text$mn        segment para public 'CODE' use32
.text$mn:00000C18                 assume cs:_text$mn
.text$mn:00000C18                 ;org 0C18h
.text$mn:00000C18 ; COMDAT (pick any)
.text$mn:00000C18                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text$mn:00000C18
.text$mn:00000C18 ; =============== S U B R O U T I N E =======================================
.text$mn:00000C18
.text$mn:00000C18 ; Attributes: bp-based frame
.text$mn:00000C18
.text$mn:00000C18 ; void *__cdecl operator new(unsigned int, void *)
.text$mn:00000C18                 public ??2@YAPAXIPAX@Z
.text$mn:00000C18 ??2@YAPAXIPAX@Z proc near               ; CODE XREF: std::allocator<char>::construct<char *,char * &>(char * *,char * &)+2Ep
.text$mn:00000C18                                         ; std::allocator<std::_Container_proxy>::construct<std::_Container_proxy,std::_Container_proxy>(std::_Container_proxy *,std::_Container_proxy &&)+2Ep
.text$mn:00000C18
.text$mn:00000C18 arg_4           = dword ptr  0Ch
.text$mn:00000C18
.text$mn:00000C18                 push    ebp
.text$mn:00000C19                 mov     ebp, esp
.text$mn:00000C1B                 mov     eax, [ebp+arg_4]
.text$mn:00000C1E                 pop     ebp
.text$mn:00000C1F                 retn
.text$mn:00000C1F ??2@YAPAXIPAX@Z endp
.text$mn:00000C1F
.text$mn:00000C1F _text$mn        ends
.text$mn:00000C1F
.text$mn:00000C20 ; ===========================================================================
.text$mn:00000C20
.text$mn:00000C20 ; Segment type: Pure code
.text$mn:00000C20 ; Segment permissions: Read/Execute
.text$mn:00000C20 _text$mn        segment para public 'CODE' use32
.text$mn:00000C20                 assume cs:_text$mn
.text$mn:00000C20                 ;org 0C20h
.text$mn:00000C20 ; COMDAT (pick any)
.text$mn:00000C20                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text$mn:00000C20
.text$mn:00000C20 ; =============== S U B R O U T I N E =======================================
.text$mn:00000C20
.text$mn:00000C20 ; Attributes: bp-based frame
.text$mn:00000C20
.text$mn:00000C20 ; void __cdecl operator delete(void *)
.text$mn:00000C20                 public ??3@YAXPAX0@Z
.text$mn:00000C20 ??3@YAXPAX0@Z   proc near               ; CODE XREF: __unwindfunclet$??$construct@PADAAPAD@?$allocator@D@std@@QAEXPAPADAAPAD@Z$0+8p
.text$mn:00000C20                                         ; __unwindfunclet$??$construct@U_Container_proxy@std@@U12@@?$allocator@U_Container_proxy@std@@@std@@QAEXPAU_Container_proxy@1@$$QAU21@@Z$0+8p
.text$mn:00000C20                 push    ebp
.text$mn:00000C21                 mov     ebp, esp
.text$mn:00000C23                 pop     ebp
.text$mn:00000C24                 retn
.text$mn:00000C24 ??3@YAXPAX0@Z   endp
.text$mn:00000C24
.text$mn:00000C24 ; ---------------------------------------------------------------------------
.text$mn:00000C25                 align 4
.text$mn:00000C25 _text$mn        ends
.text$mn:00000C25
.text$mn:00000C28 ; ===========================================================================
.text$mn:00000C28
.text$mn:00000C28 ; Segment type: Pure code
.text$mn:00000C28 ; Segment permissions: Read/Execute
.text$mn:00000C28 _text$mn        segment para public 'CODE' use32
.text$mn:00000C28                 assume cs:_text$mn
.text$mn:00000C28                 ;org 0C28h
.text$mn:00000C28 ; COMDAT (pick any)
.text$mn:00000C28                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text$mn:00000C28
.text$mn:00000C28 ; =============== S U B R O U T I N E =======================================
.text$mn:00000C28
.text$mn:00000C28 ; Attributes: bp-based frame
.text$mn:00000C28
.text$mn:00000C28 ; public: bool __thiscall std::error_category::operator==(class std::error_category const &)const
.text$mn:00000C28                 public ??8error_category@std@@QBE_NABV01@@Z
.text$mn:00000C28 ??8error_category@std@@QBE_NABV01@@Z proc near
.text$mn:00000C28                                         ; CODE XREF: std::error_condition::operator==(std::error_condition const &)+1Dp
.text$mn:00000C28                                         ; std::error_category::equivalent(std::error_code const &,int)+15p
.text$mn:00000C28
.text$mn:00000C28 var_8           = dword ptr -8
.text$mn:00000C28 var_4           = dword ptr -4
.text$mn:00000C28 arg_0           = dword ptr  8
.text$mn:00000C28
.text$mn:00000C28                 push    ebp
.text$mn:00000C29                 mov     ebp, esp
.text$mn:00000C2B                 sub     esp, 8
.text$mn:00000C2E                 mov     [ebp+var_8], ecx
.text$mn:00000C31                 mov     eax, [ebp+var_8]
.text$mn:00000C34                 cmp     eax, [ebp+arg_0]
.text$mn:00000C37                 jnz     short loc_C42
.text$mn:00000C39                 mov     [ebp+var_4], 1
.text$mn:00000C40                 jmp     short loc_C49
.text$mn:00000C42 ; ---------------------------------------------------------------------------
.text$mn:00000C42
.text$mn:00000C42 loc_C42:                                ; CODE XREF: std::error_category::operator==(std::error_category const &)+Fj
.text$mn:00000C42                 mov     [ebp+var_4], 0
.text$mn:00000C49
.text$mn:00000C49 loc_C49:                                ; CODE XREF: std::error_category::operator==(std::error_category const &)+18j
.text$mn:00000C49                 mov     al, byte ptr [ebp+var_4]
.text$mn:00000C4C                 mov     esp, ebp
.text$mn:00000C4E                 pop     ebp
.text$mn:00000C4F                 retn    4
.text$mn:00000C4F ??8error_category@std@@QBE_NABV01@@Z endp
.text$mn:00000C4F
.text$mn:00000C4F ; ---------------------------------------------------------------------------
.text$mn:00000C52                 align 4
.text$mn:00000C52 _text$mn        ends
.text$mn:00000C52
.text$mn:00000C54 ; ===========================================================================
.text$mn:00000C54
.text$mn:00000C54 ; Segment type: Pure code
.text$mn:00000C54 ; Segment permissions: Read/Execute
.text$mn:00000C54 _text$mn        segment para public 'CODE' use32
.text$mn:00000C54                 assume cs:_text$mn
.text$mn:00000C54                 ;org 0C54h
.text$mn:00000C54 ; COMDAT (pick any)
.text$mn:00000C54                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text$mn:00000C54
.text$mn:00000C54 ; =============== S U B R O U T I N E =======================================
.text$mn:00000C54
.text$mn:00000C54 ; Attributes: bp-based frame
.text$mn:00000C54
.text$mn:00000C54 ; int __stdcall std::error_condition::operator==(std::error_condition *)
.text$mn:00000C54                 public ??8error_condition@std@@QBE_NABV01@@Z
.text$mn:00000C54 ??8error_condition@std@@QBE_NABV01@@Z proc near
.text$mn:00000C54                                         ; CODE XREF: std::error_category::equivalent(int,std::error_condition const &)+24p
.text$mn:00000C54
.text$mn:00000C54 var_8           = dword ptr -8
.text$mn:00000C54 var_4           = dword ptr -4
.text$mn:00000C54 arg_0           = dword ptr  8
.text$mn:00000C54
.text$mn:00000C54                 push    ebp
.text$mn:00000C55                 mov     ebp, esp
.text$mn:00000C57                 sub     esp, 8
.text$mn:00000C5A                 push    esi
.text$mn:00000C5B                 mov     [ebp+var_4], ecx
.text$mn:00000C5E                 mov     ecx, [ebp+arg_0] ; this
.text$mn:00000C61                 call    ?category@error_condition@std@@QBEABVerror_category@2@XZ ; std::error_condition::category(void)
.text$mn:00000C66                 push    eax
.text$mn:00000C67                 mov     ecx, [ebp+var_4] ; this
.text$mn:00000C6A                 call    ?category@error_condition@std@@QBEABVerror_category@2@XZ ; std::error_condition::category(void)
.text$mn:00000C6F                 mov     ecx, eax
.text$mn:00000C71                 call    ??8error_category@std@@QBE_NABV01@@Z ; std::error_category::operator==(std::error_category const &)
.text$mn:00000C76                 movzx   eax, al
.text$mn:00000C79                 test    eax, eax
.text$mn:00000C7B                 jz      short loc_C9C
.text$mn:00000C7D                 mov     ecx, [ebp+var_4] ; this
.text$mn:00000C80                 call    ?value@error_condition@std@@QBEHXZ ; std::error_condition::value(void)
.text$mn:00000C85                 mov     esi, eax
.text$mn:00000C87                 mov     ecx, [ebp+arg_0] ; this
.text$mn:00000C8A                 call    ?value@error_condition@std@@QBEHXZ ; std::error_condition::value(void)
.text$mn:00000C8F                 cmp     esi, eax
.text$mn:00000C91                 jnz     short loc_C9C
.text$mn:00000C93                 mov     [ebp+var_8], 1
.text$mn:00000C9A                 jmp     short loc_CA3
.text$mn:00000C9C ; ---------------------------------------------------------------------------
.text$mn:00000C9C
.text$mn:00000C9C loc_C9C:                                ; CODE XREF: std::error_condition::operator==(std::error_condition const &)+27j
.text$mn:00000C9C                                         ; std::error_condition::operator==(std::error_condition const &)+3Dj
.text$mn:00000C9C                 mov     [ebp+var_8], 0
.text$mn:00000CA3
.text$mn:00000CA3 loc_CA3:                                ; CODE XREF: std::error_condition::operator==(std::error_condition const &)+46j
.text$mn:00000CA3                 mov     al, byte ptr [ebp+var_8]
.text$mn:00000CA6                 pop     esi
.text$mn:00000CA7                 mov     esp, ebp
.text$mn:00000CA9                 pop     ebp
.text$mn:00000CAA                 retn    4
.text$mn:00000CAA ??8error_condition@std@@QBE_NABV01@@Z endp
.text$mn:00000CAA
.text$mn:00000CAA ; ---------------------------------------------------------------------------
.text$mn:00000CAD                 align 10h
.text$mn:00000CAD _text$mn        ends
.text$mn:00000CAD
.text$mn:00000CB0 ; ===========================================================================
.text$mn:00000CB0
.text$mn:00000CB0 ; Segment type: Pure code
.text$mn:00000CB0 ; Segment permissions: Read/Execute
.text$mn:00000CB0 _text$mn        segment para public 'CODE' use32
.text$mn:00000CB0                 assume cs:_text$mn
.text$mn:00000CB0                 ;org 0CB0h
.text$mn:00000CB0 ; COMDAT (pick any)
.text$mn:00000CB0                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text$mn:00000CB0
.text$mn:00000CB0 ; =============== S U B R O U T I N E =======================================
.text$mn:00000CB0
.text$mn:00000CB0 ; Attributes: bp-based frame
.text$mn:00000CB0
.text$mn:00000CB0 ; public: virtual void * __thiscall std::_Generic_error_category::`scalar deleting destructor'(unsigned int)
.text$mn:00000CB0                 public ??_G_Generic_error_category@std@@UAEPAXI@Z
.text$mn:00000CB0 ??_G_Generic_error_category@std@@UAEPAXI@Z proc near
.text$mn:00000CB0
.text$mn:00000CB0 var_4           = dword ptr -4
.text$mn:00000CB0 arg_0           = dword ptr  8
.text$mn:00000CB0
.text$mn:00000CB0                 push    ebp
.text$mn:00000CB1                 mov     ebp, esp
.text$mn:00000CB3                 push    ecx
.text$mn:00000CB4                 mov     [ebp+var_4], ecx
.text$mn:00000CB7                 mov     ecx, [ebp+var_4] ; this
.text$mn:00000CBA                 call    ??1_Generic_error_category@std@@UAE@XZ ; std::_Generic_error_category::~_Generic_error_category(void)
.text$mn:00000CBF                 mov     eax, [ebp+arg_0]
.text$mn:00000CC2                 and     eax, 1
.text$mn:00000CC5                 jz      short loc_CD3
.text$mn:00000CC7                 mov     ecx, [ebp+var_4]
.text$mn:00000CCA                 push    ecx             ; void *
.text$mn:00000CCB                 call    ??3@YAXPAX@Z    ; operator delete(void *)
.text$mn:00000CD0                 add     esp, 4
.text$mn:00000CD3
.text$mn:00000CD3 loc_CD3:                                ; CODE XREF: std::_Generic_error_category::`scalar deleting destructor'(uint)+15j
.text$mn:00000CD3                 mov     eax, [ebp+var_4]
.text$mn:00000CD6                 mov     esp, ebp
.text$mn:00000CD8                 pop     ebp
.text$mn:00000CD9                 retn    4
.text$mn:00000CD9 ??_G_Generic_error_category@std@@UAEPAXI@Z endp
.text$mn:00000CD9
.text$mn:00000CD9 _text$mn        ends
.text$mn:00000CD9
.text$mn:00000CDC ; ===========================================================================
.text$mn:00000CDC
.text$mn:00000CDC ; Segment type: Pure code
.text$mn:00000CDC ; Segment permissions: Read/Execute
.text$mn:00000CDC _text$mn        segment para public 'CODE' use32
.text$mn:00000CDC                 assume cs:_text$mn
.text$mn:00000CDC                 ;org 0CDCh
.text$mn:00000CDC ; COMDAT (pick any)
.text$mn:00000CDC                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text$mn:00000CDC
.text$mn:00000CDC ; =============== S U B R O U T I N E =======================================
.text$mn:00000CDC
.text$mn:00000CDC ; Attributes: bp-based frame
.text$mn:00000CDC
.text$mn:00000CDC ; public: virtual void * __thiscall std::_Iostream_error_category::`scalar deleting destructor'(unsigned int)
.text$mn:00000CDC                 public ??_G_Iostream_error_category@std@@UAEPAXI@Z
.text$mn:00000CDC ??_G_Iostream_error_category@std@@UAEPAXI@Z proc near
.text$mn:00000CDC
.text$mn:00000CDC var_4           = dword ptr -4
.text$mn:00000CDC arg_0           = dword ptr  8
.text$mn:00000CDC
.text$mn:00000CDC                 push    ebp
.text$mn:00000CDD                 mov     ebp, esp
.text$mn:00000CDF                 push    ecx
.text$mn:00000CE0                 mov     [ebp+var_4], ecx
.text$mn:00000CE3                 mov     ecx, [ebp+var_4] ; this
.text$mn:00000CE6                 call    ??1_Iostream_error_category@std@@UAE@XZ ; std::_Iostream_error_category::~_Iostream_error_category(void)
.text$mn:00000CEB                 mov     eax, [ebp+arg_0]
.text$mn:00000CEE                 and     eax, 1
.text$mn:00000CF1                 jz      short loc_CFF
.text$mn:00000CF3                 mov     ecx, [ebp+var_4]
.text$mn:00000CF6                 push    ecx             ; void *
.text$mn:00000CF7                 call    ??3@YAXPAX@Z    ; operator delete(void *)
.text$mn:00000CFC                 add     esp, 4
.text$mn:00000CFF
.text$mn:00000CFF loc_CFF:                                ; CODE XREF: std::_Iostream_error_category::`scalar deleting destructor'(uint)+15j
.text$mn:00000CFF                 mov     eax, [ebp+var_4]
.text$mn:00000D02                 mov     esp, ebp
.text$mn:00000D04                 pop     ebp
.text$mn:00000D05                 retn    4
.text$mn:00000D05 ??_G_Iostream_error_category@std@@UAEPAXI@Z endp
.text$mn:00000D05
.text$mn:00000D05 _text$mn        ends
.text$mn:00000D05
.text$mn:00000D08 ; ===========================================================================
.text$mn:00000D08
.text$mn:00000D08 ; Segment type: Pure code
.text$mn:00000D08 ; Segment permissions: Read/Execute
.text$mn:00000D08 _text$mn        segment para public 'CODE' use32
.text$mn:00000D08                 assume cs:_text$mn
.text$mn:00000D08                 ;org 0D08h
.text$mn:00000D08 ; COMDAT (pick any)
.text$mn:00000D08                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text$mn:00000D08
.text$mn:00000D08 ; =============== S U B R O U T I N E =======================================
.text$mn:00000D08
.text$mn:00000D08 ; Attributes: bp-based frame
.text$mn:00000D08
.text$mn:00000D08 ; public: virtual void * __thiscall std::_System_error_category::`scalar deleting destructor'(unsigned int)
.text$mn:00000D08                 public ??_G_System_error_category@std@@UAEPAXI@Z
.text$mn:00000D08 ??_G_System_error_category@std@@UAEPAXI@Z proc near
.text$mn:00000D08
.text$mn:00000D08 var_4           = dword ptr -4
.text$mn:00000D08 arg_0           = dword ptr  8
.text$mn:00000D08
.text$mn:00000D08                 push    ebp
.text$mn:00000D09                 mov     ebp, esp
.text$mn:00000D0B                 push    ecx
.text$mn:00000D0C                 mov     [ebp+var_4], ecx
.text$mn:00000D0F                 mov     ecx, [ebp+var_4] ; this
.text$mn:00000D12                 call    ??1_System_error_category@std@@UAE@XZ ; std::_System_error_category::~_System_error_category(void)
.text$mn:00000D17                 mov     eax, [ebp+arg_0]
.text$mn:00000D1A                 and     eax, 1
.text$mn:00000D1D                 jz      short loc_D2B
.text$mn:00000D1F                 mov     ecx, [ebp+var_4]
.text$mn:00000D22                 push    ecx             ; void *
.text$mn:00000D23                 call    ??3@YAXPAX@Z    ; operator delete(void *)
.text$mn:00000D28                 add     esp, 4
.text$mn:00000D2B
.text$mn:00000D2B loc_D2B:                                ; CODE XREF: std::_System_error_category::`scalar deleting destructor'(uint)+15j
.text$mn:00000D2B                 mov     eax, [ebp+var_4]
.text$mn:00000D2E                 mov     esp, ebp
.text$mn:00000D30                 pop     ebp
.text$mn:00000D31                 retn    4
.text$mn:00000D31 ??_G_System_error_category@std@@UAEPAXI@Z endp
.text$mn:00000D31
.text$mn:00000D31 _text$mn        ends
.text$mn:00000D31
.text$mn:00000D34 ; ===========================================================================
.text$mn:00000D34
.text$mn:00000D34 ; Segment type: Pure code
.text$mn:00000D34 ; Segment permissions: Read/Execute
.text$mn:00000D34 _text$mn        segment para public 'CODE' use32
.text$mn:00000D34                 assume cs:_text$mn
.text$mn:00000D34                 ;org 0D34h
.text$mn:00000D34 ; COMDAT (pick any)
.text$mn:00000D34                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text$mn:00000D34
.text$mn:00000D34 ; =============== S U B R O U T I N E =======================================
.text$mn:00000D34
.text$mn:00000D34 ; Attributes: bp-based frame
.text$mn:00000D34
.text$mn:00000D34 ; public: virtual void * __thiscall std::error_category::`scalar deleting destructor'(unsigned int)
.text$mn:00000D34                 public ??_Gerror_category@std@@UAEPAXI@Z
.text$mn:00000D34 ??_Gerror_category@std@@UAEPAXI@Z proc near
.text$mn:00000D34
.text$mn:00000D34 var_4           = dword ptr -4
.text$mn:00000D34 arg_0           = dword ptr  8
.text$mn:00000D34
.text$mn:00000D34                 push    ebp
.text$mn:00000D35                 mov     ebp, esp
.text$mn:00000D37                 push    ecx
.text$mn:00000D38                 mov     [ebp+var_4], ecx
.text$mn:00000D3B                 mov     ecx, [ebp+var_4] ; this
.text$mn:00000D3E                 call    ??1error_category@std@@UAE@XZ ; std::error_category::~error_category(void)
.text$mn:00000D43                 mov     eax, [ebp+arg_0]
.text$mn:00000D46                 and     eax, 1
.text$mn:00000D49                 jz      short loc_D57
.text$mn:00000D4B                 mov     ecx, [ebp+var_4]
.text$mn:00000D4E                 push    ecx             ; void *
.text$mn:00000D4F                 call    ??3@YAXPAX@Z    ; operator delete(void *)
.text$mn:00000D54                 add     esp, 4
.text$mn:00000D57
.text$mn:00000D57 loc_D57:                                ; CODE XREF: std::error_category::`scalar deleting destructor'(uint)+15j
.text$mn:00000D57                 mov     eax, [ebp+var_4]
.text$mn:00000D5A                 mov     esp, ebp
.text$mn:00000D5C                 pop     ebp
.text$mn:00000D5D                 retn    4
.text$mn:00000D5D ??_Gerror_category@std@@UAEPAXI@Z endp
.text$mn:00000D5D
.text$mn:00000D5D _text$mn        ends
.text$mn:00000D5D
.text$di:00000D60 ; ===========================================================================
.text$di:00000D60
.text$di:00000D60 ; Segment type: Pure code
.text$di:00000D60 ; Segment permissions: Read/Execute
.text$di:00000D60 _text$di        segment para public 'CODE' use32
.text$di:00000D60                 assume cs:_text$di
.text$di:00000D60                 ;org 0D60h
.text$di:00000D60 ; COMDAT (pick any)
.text$di:00000D60                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text$di:00000D60
.text$di:00000D60 ; =============== S U B R O U T I N E =======================================
.text$di:00000D60
.text$di:00000D60 ; Attributes: bp-based frame
.text$di:00000D60
.text$di:00000D60 ; void __cdecl `dynamic initializer for 'public: static class std::_Generic_error_category std::_Error_objects<int>::_Generic_object''(void)
.text$di:00000D60 ??__E?_Generic_object@?$_Error_objects@H@std@@2V_Generic_error_category@2@A@@YAXXZ proc near
.text$di:00000D60                                         ; DATA XREF: .CRT$XCU:void (*std::_Error_objects<int>::_Generic_object$initializer$)(void)o
.text$di:00000D60                 push    ebp
.text$di:00000D61                 mov     ebp, esp
.text$di:00000D63                 mov     ecx, offset ?_Generic_object@?$_Error_objects@H@std@@2V_Generic_error_category@2@A ; this
.text$di:00000D68                 call    ??0_Generic_error_category@std@@QAE@XZ ; std::_Generic_error_category::_Generic_error_category(void)
.text$di:00000D6D                 push    offset ??__F?_Generic_object@?$_Error_objects@H@std@@2V_Generic_error_category@2@A@@YAXXZ ; void (__cdecl *)()
.text$di:00000D72                 call    _atexit
.text$di:00000D77                 add     esp, 4
.text$di:00000D7A                 pop     ebp
.text$di:00000D7B                 retn
.text$di:00000D7B ??__E?_Generic_object@?$_Error_objects@H@std@@2V_Generic_error_category@2@A@@YAXXZ endp
.text$di:00000D7B
.text$di:00000D7B _text$di        ends
.text$di:00000D7B
.text$di:00000D7C ; ===========================================================================
.text$di:00000D7C
.text$di:00000D7C ; Segment type: Pure code
.text$di:00000D7C ; Segment permissions: Read/Execute
.text$di:00000D7C _text$di        segment para public 'CODE' use32
.text$di:00000D7C                 assume cs:_text$di
.text$di:00000D7C                 ;org 0D7Ch
.text$di:00000D7C ; COMDAT (pick any)
.text$di:00000D7C                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text$di:00000D7C
.text$di:00000D7C ; =============== S U B R O U T I N E =======================================
.text$di:00000D7C
.text$di:00000D7C ; Attributes: bp-based frame
.text$di:00000D7C
.text$di:00000D7C ; void __cdecl `dynamic initializer for 'public: static class std::_Iostream_error_category std::_Error_objects<int>::_Iostream_object''(void)
.text$di:00000D7C ??__E?_Iostream_object@?$_Error_objects@H@std@@2V_Iostream_error_category@2@A@@YAXXZ proc near
.text$di:00000D7C                                         ; DATA XREF: .CRT$XCU:void (*std::_Error_objects<int>::_Iostream_object$initializer$)(void)o
.text$di:00000D7C                 push    ebp
.text$di:00000D7D                 mov     ebp, esp
.text$di:00000D7F                 mov     ecx, offset ?_Iostream_object@?$_Error_objects@H@std@@2V_Iostream_error_category@2@A ; this
.text$di:00000D84                 call    ??0_Iostream_error_category@std@@QAE@XZ ; std::_Iostream_error_category::_Iostream_error_category(void)
.text$di:00000D89                 push    offset ??__F?_Iostream_object@?$_Error_objects@H@std@@2V_Iostream_error_category@2@A@@YAXXZ ; void (__cdecl *)()
.text$di:00000D8E                 call    _atexit
.text$di:00000D93                 add     esp, 4
.text$di:00000D96                 pop     ebp
.text$di:00000D97                 retn
.text$di:00000D97 ??__E?_Iostream_object@?$_Error_objects@H@std@@2V_Iostream_error_category@2@A@@YAXXZ endp
.text$di:00000D97
.text$di:00000D97 _text$di        ends
.text$di:00000D97
.text$di:00000D98 ; ===========================================================================
.text$di:00000D98
.text$di:00000D98 ; Segment type: Pure code
.text$di:00000D98 ; Segment permissions: Read/Execute
.text$di:00000D98 _text$di        segment para public 'CODE' use32
.text$di:00000D98                 assume cs:_text$di
.text$di:00000D98                 ;org 0D98h
.text$di:00000D98 ; COMDAT (pick any)
.text$di:00000D98                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text$di:00000D98
.text$di:00000D98 ; =============== S U B R O U T I N E =======================================
.text$di:00000D98
.text$di:00000D98 ; Attributes: bp-based frame
.text$di:00000D98
.text$di:00000D98 ; void __cdecl `dynamic initializer for 'public: static class std::_System_error_category std::_Error_objects<int>::_System_object''(void)
.text$di:00000D98 ??__E?_System_object@?$_Error_objects@H@std@@2V_System_error_category@2@A@@YAXXZ proc near
.text$di:00000D98                                         ; DATA XREF: .CRT$XCU:void (*std::_Error_objects<int>::_System_object$initializer$)(void)o
.text$di:00000D98                 push    ebp
.text$di:00000D99                 mov     ebp, esp
.text$di:00000D9B                 mov     ecx, offset ?_System_object@?$_Error_objects@H@std@@2V_System_error_category@2@A ; this
.text$di:00000DA0                 call    ??0_System_error_category@std@@QAE@XZ ; std::_System_error_category::_System_error_category(void)
.text$di:00000DA5                 push    offset ??__F?_System_object@?$_Error_objects@H@std@@2V_System_error_category@2@A@@YAXXZ ; void (__cdecl *)()
.text$di:00000DAA                 call    _atexit
.text$di:00000DAF                 add     esp, 4
.text$di:00000DB2                 pop     ebp
.text$di:00000DB3                 retn
.text$di:00000DB3 ??__E?_System_object@?$_Error_objects@H@std@@2V_System_error_category@2@A@@YAXXZ endp
.text$di:00000DB3
.text$di:00000DB3 _text$di        ends
.text$di:00000DB3
.text$di:00000DB4 ; ===========================================================================
.text$di:00000DB4
.text$di:00000DB4 ; Segment type: Pure code
.text$di:00000DB4 ; Segment permissions: Read/Execute
.text$di:00000DB4 _text$di        segment para public 'CODE' use32
.text$di:00000DB4                 assume cs:_text$di
.text$di:00000DB4                 ;org 0DB4h
.text$di:00000DB4 ; COMDAT (pick any)
.text$di:00000DB4                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text$di:00000DB4
.text$di:00000DB4 ; =============== S U B R O U T I N E =======================================
.text$di:00000DB4
.text$di:00000DB4 ; Attributes: bp-based frame
.text$di:00000DB4
.text$di:00000DB4 ; void __cdecl `dynamic initializer for 'public: static class std::locale::id std::num_put<char, class std::back_insert_iterator<class std::basic_string<char, struct std::char_traits<char>, class std::allocator<char>>>>::id''(void)
.text$di:00000DB4 ??__E?id@?$num_put@DV?$back_insert_iterator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@std@@2V0locale@2@A@@YAXXZ proc near
.text$di:00000DB4                                         ; DATA XREF: .CRT$XCU:void (*std::num_put<char,std::back_insert_iterator<std::basic_string<char,std::char_traits<char>,std::allocator<char>>>>::id$initializer$)(void)o
.text$di:00000DB4                 push    ebp
.text$di:00000DB5                 mov     ebp, esp
.text$di:00000DB7                 push    0               ; unsigned int
.text$di:00000DB9                 mov     ecx, offset ?id@?$num_put@DV?$back_insert_iterator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@std@@2V0locale@2@A ; this
.text$di:00000DBE                 call    ??0id@locale@std@@QAE@I@Z ; std::locale::id::id(uint)
.text$di:00000DC3                 pop     ebp
.text$di:00000DC4                 retn
.text$di:00000DC4 ??__E?id@?$num_put@DV?$back_insert_iterator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@std@@2V0locale@2@A@@YAXXZ endp
.text$di:00000DC4
.text$di:00000DC4 ; ---------------------------------------------------------------------------
.text$di:00000DC5                 align 4
.text$di:00000DC5 _text$di        ends
.text$di:00000DC5
.text$di:00000DC8 ; ===========================================================================
.text$di:00000DC8
.text$di:00000DC8 ; Segment type: Pure code
.text$di:00000DC8 ; Segment permissions: Read/Execute
.text$di:00000DC8 _text$di        segment para public 'CODE' use32
.text$di:00000DC8                 assume cs:_text$di
.text$di:00000DC8                 ;org 0DC8h
.text$di:00000DC8 ; COMDAT (pick any)
.text$di:00000DC8                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text$di:00000DC8
.text$di:00000DC8 ; =============== S U B R O U T I N E =======================================
.text$di:00000DC8
.text$di:00000DC8 ; Attributes: bp-based frame
.text$di:00000DC8
.text$di:00000DC8 ; void __cdecl `dynamic initializer for 'public: static class std::locale::id std::num_put<wchar_t, class std::back_insert_iterator<class std::basic_string<wchar_t, struct std::char_traits<wchar_t>, class std::allocator<wchar_t>>>>::id''(void)
.text$di:00000DC8 ??__E?id@?$num_put@_WV?$back_insert_iterator@V?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@@std@@@std@@2V0locale@2@A@@YAXXZ proc near
.text$di:00000DC8                                         ; DATA XREF: .CRT$XCU:void (*std::num_put<wchar_t,std::back_insert_iterator<std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>>>>::id$initializer$)(void)o
.text$di:00000DC8                 push    ebp
.text$di:00000DC9                 mov     ebp, esp
.text$di:00000DCB                 push    0               ; unsigned int
.text$di:00000DCD                 mov     ecx, offset ?id@?$num_put@_WV?$back_insert_iterator@V?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@@std@@@std@@2V0locale@2@A ; this
.text$di:00000DD2                 call    ??0id@locale@std@@QAE@I@Z ; std::locale::id::id(uint)
.text$di:00000DD7                 pop     ebp
.text$di:00000DD8                 retn
.text$di:00000DD8 ??__E?id@?$num_put@_WV?$back_insert_iterator@V?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@@std@@@std@@2V0locale@2@A@@YAXXZ endp
.text$di:00000DD8
.text$di:00000DD8 ; ---------------------------------------------------------------------------
.text$di:00000DD9                 align 4
.text$di:00000DD9 _text$di        ends
.text$di:00000DD9
.text$di:00000DDC ; ===========================================================================
.text$di:00000DDC
.text$di:00000DDC ; Segment type: Pure code
.text$di:00000DDC ; Segment permissions: Read/Execute
.text$di:00000DDC _text$di        segment para public 'CODE' use32
.text$di:00000DDC                 assume cs:_text$di
.text$di:00000DDC                 ;org 0DDCh
.text$di:00000DDC ; COMDAT (pick any)
.text$di:00000DDC                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text$di:00000DDC
.text$di:00000DDC ; =============== S U B R O U T I N E =======================================
.text$di:00000DDC
.text$di:00000DDC ; Attributes: bp-based frame
.text$di:00000DDC
.text$di:00000DDC ; void __cdecl `dynamic initializer for 'public: static class std::locale::id std::numpunct<char>::id''(void)
.text$di:00000DDC ??__E?id@?$numpunct@D@std@@2V0locale@2@A@@YAXXZ proc near
.text$di:00000DDC                                         ; DATA XREF: .CRT$XCU:void (*std::numpunct<char>::id$initializer$)(void)o
.text$di:00000DDC                 push    ebp
.text$di:00000DDD                 mov     ebp, esp
.text$di:00000DDF                 push    0               ; unsigned int
.text$di:00000DE1                 mov     ecx, offset ?id@?$numpunct@D@std@@2V0locale@2@A ; this
.text$di:00000DE6                 call    ??0id@locale@std@@QAE@I@Z ; std::locale::id::id(uint)
.text$di:00000DEB                 pop     ebp
.text$di:00000DEC                 retn
.text$di:00000DEC ??__E?id@?$numpunct@D@std@@2V0locale@2@A@@YAXXZ endp
.text$di:00000DEC
.text$di:00000DEC ; ---------------------------------------------------------------------------
.text$di:00000DED                 align 10h
.text$di:00000DED _text$di        ends
.text$di:00000DED
.text$di:00000DF0 ; ===========================================================================
.text$di:00000DF0
.text$di:00000DF0 ; Segment type: Pure code
.text$di:00000DF0 ; Segment permissions: Read/Execute
.text$di:00000DF0 _text$di        segment para public 'CODE' use32
.text$di:00000DF0                 assume cs:_text$di
.text$di:00000DF0                 ;org 0DF0h
.text$di:00000DF0 ; COMDAT (pick any)
.text$di:00000DF0                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text$di:00000DF0
.text$di:00000DF0 ; =============== S U B R O U T I N E =======================================
.text$di:00000DF0
.text$di:00000DF0 ; Attributes: bp-based frame
.text$di:00000DF0
.text$di:00000DF0 ; void __cdecl `dynamic initializer for 'public: static class std::locale::id std::numpunct<wchar_t>::id''(void)
.text$di:00000DF0 ??__E?id@?$numpunct@_W@std@@2V0locale@2@A@@YAXXZ proc near
.text$di:00000DF0                                         ; DATA XREF: .CRT$XCU:void (*std::numpunct<wchar_t>::id$initializer$)(void)o
.text$di:00000DF0                 push    ebp
.text$di:00000DF1                 mov     ebp, esp
.text$di:00000DF3                 push    0               ; unsigned int
.text$di:00000DF5                 mov     ecx, offset ?id@?$numpunct@_W@std@@2V0locale@2@A ; this
.text$di:00000DFA                 call    ??0id@locale@std@@QAE@I@Z ; std::locale::id::id(uint)
.text$di:00000DFF                 pop     ebp
.text$di:00000E00                 retn
.text$di:00000E00 ??__E?id@?$numpunct@_W@std@@2V0locale@2@A@@YAXXZ endp
.text$di:00000E00
.text$di:00000E00 ; ---------------------------------------------------------------------------
.text$di:00000E01                 align 4
.text$di:00000E01 _text$di        ends
.text$di:00000E01
.text$di:00000E04 ; ===========================================================================
.text$di:00000E04
.text$di:00000E04 ; Segment type: Pure code
.text$di:00000E04 ; Segment permissions: Read/Execute
.text$di:00000E04 _text$di        segment para public 'CODE' use32
.text$di:00000E04                 assume cs:_text$di
.text$di:00000E04                 ;org 0E04h
.text$di:00000E04 ; COMDAT (pick any)
.text$di:00000E04                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text$di:00000E04
.text$di:00000E04 ; =============== S U B R O U T I N E =======================================
.text$di:00000E04
.text$di:00000E04 ; Attributes: bp-based frame
.text$di:00000E04
.text$di:00000E04 ; void __cdecl std::`dynamic initializer for 'allocator_arg''(void)
.text$di:00000E04 ??__Eallocator_arg@std@@YAXXZ proc near ; DATA XREF: .CRT$XCU:_allocator_arg$initializer$o
.text$di:00000E04
.text$di:00000E04 var_1           = byte ptr -1
.text$di:00000E04
.text$di:00000E04                 push    ebp
.text$di:00000E05                 mov     ebp, esp
.text$di:00000E07                 push    ecx
.text$di:00000E08                 xor     eax, eax
.text$di:00000E0A                 mov     [ebp+var_1], al
.text$di:00000E0D                 mov     esp, ebp
.text$di:00000E0F                 pop     ebp
.text$di:00000E10                 retn
.text$di:00000E10 ??__Eallocator_arg@std@@YAXXZ endp
.text$di:00000E10
.text$di:00000E10 ; ---------------------------------------------------------------------------
.text$di:00000E11                 align 4
.text$di:00000E11 _text$di        ends
.text$di:00000E11
.text$di:00000E14 ; ===========================================================================
.text$di:00000E14
.text$di:00000E14 ; Segment type: Pure code
.text$di:00000E14 ; Segment permissions: Read/Execute
.text$di:00000E14 _text$di        segment para public 'CODE' use32
.text$di:00000E14                 assume cs:_text$di
.text$di:00000E14                 ;org 0E14h
.text$di:00000E14 ; COMDAT (pick any)
.text$di:00000E14                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text$di:00000E14
.text$di:00000E14 ; =============== S U B R O U T I N E =======================================
.text$di:00000E14
.text$di:00000E14 ; Attributes: bp-based frame
.text$di:00000E14
.text$di:00000E14 ; void __cdecl std::`dynamic initializer for 'piecewise_construct''(void)
.text$di:00000E14 ??__Epiecewise_construct@std@@YAXXZ proc near
.text$di:00000E14                                         ; DATA XREF: .CRT$XCU:_piecewise_construct$initializer$o
.text$di:00000E14
.text$di:00000E14 var_1           = byte ptr -1
.text$di:00000E14
.text$di:00000E14                 push    ebp
.text$di:00000E15                 mov     ebp, esp
.text$di:00000E17                 push    ecx
.text$di:00000E18                 xor     eax, eax
.text$di:00000E1A                 mov     [ebp+var_1], al
.text$di:00000E1D                 mov     esp, ebp
.text$di:00000E1F                 pop     ebp
.text$di:00000E20                 retn
.text$di:00000E20 ??__Epiecewise_construct@std@@YAXXZ endp
.text$di:00000E20
.text$di:00000E20 ; ---------------------------------------------------------------------------
.text$di:00000E21                 align 4
.text$di:00000E21 _text$di        ends
.text$di:00000E21
.text$yd:00000E24 ; ===========================================================================
.text$yd:00000E24
.text$yd:00000E24 ; Segment type: Pure code
.text$yd:00000E24 ; Segment permissions: Read/Execute
.text$yd:00000E24 _text$yd        segment para public 'CODE' use32
.text$yd:00000E24                 assume cs:_text$yd
.text$yd:00000E24                 ;org 0E24h
.text$yd:00000E24 ; COMDAT (pick any)
.text$yd:00000E24                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text$yd:00000E24
.text$yd:00000E24 ; =============== S U B R O U T I N E =======================================
.text$yd:00000E24
.text$yd:00000E24 ; Attributes: bp-based frame
.text$yd:00000E24
.text$yd:00000E24 ; void __cdecl `dynamic atexit destructor for 'public: static std::_Generic_error_category std::_Error_objects<int>::_Generic_object''()
.text$yd:00000E24 ??__F?_Generic_object@?$_Error_objects@H@std@@2V_Generic_error_category@2@A@@YAXXZ proc near
.text$yd:00000E24                                         ; DATA XREF: `dynamic initializer for 'std::_Generic_error_category std::_Error_objects<int>::_Generic_object''(void)+Do
.text$yd:00000E24                 push    ebp
.text$yd:00000E25                 mov     ebp, esp
.text$yd:00000E27                 mov     ecx, offset ?_Generic_object@?$_Error_objects@H@std@@2V_Generic_error_category@2@A ; this
.text$yd:00000E2C                 call    ??1_Generic_error_category@std@@UAE@XZ ; std::_Generic_error_category::~_Generic_error_category(void)
.text$yd:00000E31                 pop     ebp
.text$yd:00000E32                 retn
.text$yd:00000E32 ??__F?_Generic_object@?$_Error_objects@H@std@@2V_Generic_error_category@2@A@@YAXXZ endp
.text$yd:00000E32
.text$yd:00000E32 ; ---------------------------------------------------------------------------
.text$yd:00000E33                 align 4
.text$yd:00000E33 _text$yd        ends
.text$yd:00000E33
.text$yd:00000E34 ; ===========================================================================
.text$yd:00000E34
.text$yd:00000E34 ; Segment type: Pure code
.text$yd:00000E34 ; Segment permissions: Read/Execute
.text$yd:00000E34 _text$yd        segment para public 'CODE' use32
.text$yd:00000E34                 assume cs:_text$yd
.text$yd:00000E34                 ;org 0E34h
.text$yd:00000E34 ; COMDAT (pick any)
.text$yd:00000E34                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text$yd:00000E34
.text$yd:00000E34 ; =============== S U B R O U T I N E =======================================
.text$yd:00000E34
.text$yd:00000E34 ; Attributes: bp-based frame
.text$yd:00000E34
.text$yd:00000E34 ; void __cdecl `dynamic atexit destructor for 'public: static std::_Iostream_error_category std::_Error_objects<int>::_Iostream_object''()
.text$yd:00000E34 ??__F?_Iostream_object@?$_Error_objects@H@std@@2V_Iostream_error_category@2@A@@YAXXZ proc near
.text$yd:00000E34                                         ; DATA XREF: `dynamic initializer for 'std::_Iostream_error_category std::_Error_objects<int>::_Iostream_object''(void)+Do
.text$yd:00000E34                 push    ebp
.text$yd:00000E35                 mov     ebp, esp
.text$yd:00000E37                 mov     ecx, offset ?_Iostream_object@?$_Error_objects@H@std@@2V_Iostream_error_category@2@A ; this
.text$yd:00000E3C                 call    ??1_Iostream_error_category@std@@UAE@XZ ; std::_Iostream_error_category::~_Iostream_error_category(void)
.text$yd:00000E41                 pop     ebp
.text$yd:00000E42                 retn
.text$yd:00000E42 ??__F?_Iostream_object@?$_Error_objects@H@std@@2V_Iostream_error_category@2@A@@YAXXZ endp
.text$yd:00000E42
.text$yd:00000E42 ; ---------------------------------------------------------------------------
.text$yd:00000E43                 align 4
.text$yd:00000E43 _text$yd        ends
.text$yd:00000E43
.text$yd:00000E44 ; ===========================================================================
.text$yd:00000E44
.text$yd:00000E44 ; Segment type: Pure code
.text$yd:00000E44 ; Segment permissions: Read/Execute
.text$yd:00000E44 _text$yd        segment para public 'CODE' use32
.text$yd:00000E44                 assume cs:_text$yd
.text$yd:00000E44                 ;org 0E44h
.text$yd:00000E44 ; COMDAT (pick any)
.text$yd:00000E44                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text$yd:00000E44
.text$yd:00000E44 ; =============== S U B R O U T I N E =======================================
.text$yd:00000E44
.text$yd:00000E44 ; Attributes: bp-based frame
.text$yd:00000E44
.text$yd:00000E44 ; void __cdecl `dynamic atexit destructor for 'public: static std::_System_error_category std::_Error_objects<int>::_System_object''()
.text$yd:00000E44 ??__F?_System_object@?$_Error_objects@H@std@@2V_System_error_category@2@A@@YAXXZ proc near
.text$yd:00000E44                                         ; DATA XREF: `dynamic initializer for 'std::_System_error_category std::_Error_objects<int>::_System_object''(void)+Do
.text$yd:00000E44                 push    ebp
.text$yd:00000E45                 mov     ebp, esp
.text$yd:00000E47                 mov     ecx, offset ?_System_object@?$_Error_objects@H@std@@2V_System_error_category@2@A ; this
.text$yd:00000E4C                 call    ??1_System_error_category@std@@UAE@XZ ; std::_System_error_category::~_System_error_category(void)
.text$yd:00000E51                 pop     ebp
.text$yd:00000E52                 retn
.text$yd:00000E52 ??__F?_System_object@?$_Error_objects@H@std@@2V_System_error_category@2@A@@YAXXZ endp
.text$yd:00000E52
.text$yd:00000E52 ; ---------------------------------------------------------------------------
.text$yd:00000E53                 align 4
.text$yd:00000E53 _text$yd        ends
.text$yd:00000E53
.text$mn:00000E54 ; ===========================================================================
.text$mn:00000E54
.text$mn:00000E54 ; Segment type: Pure code
.text$mn:00000E54 ; Segment permissions: Read/Execute
.text$mn:00000E54 _text$mn        segment para public 'CODE' use32
.text$mn:00000E54                 assume cs:_text$mn
.text$mn:00000E54                 ;org 0E54h
.text$mn:00000E54 ; COMDAT (pick any)
.text$mn:00000E54                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text$mn:00000E54
.text$mn:00000E54 ; =============== S U B R O U T I N E =======================================
.text$mn:00000E54
.text$mn:00000E54 ; Attributes: bp-based frame
.text$mn:00000E54
.text$mn:00000E54 ; public: void __thiscall std::_String_alloc<0, struct std::_String_base_types<char, class std::allocator<char>>>::_Alloc_proxy(void)
.text$mn:00000E54                 public ?_Alloc_proxy@?$_String_alloc@$0A@U?$_String_base_types@DV?$allocator@D@std@@@std@@@std@@QAEXXZ
.text$mn:00000E54 ?_Alloc_proxy@?$_String_alloc@$0A@U?$_String_base_types@DV?$allocator@D@std@@@std@@@std@@QAEXXZ proc near
.text$mn:00000E54                                         ; CODE XREF: std::_String_alloc<0,std::_String_base_types<char,std::allocator<char>>>::_String_alloc<0,std::_String_base_types<char,std::allocator<char>>>(std::allocator<char> const &)+38p
.text$mn:00000E54
.text$mn:00000E54 var_10          = byte ptr -10h
.text$mn:00000E54 var_8           = dword ptr -8
.text$mn:00000E54 var_1           = byte ptr -1
.text$mn:00000E54
.text$mn:00000E54                 push    ebp
.text$mn:00000E55                 mov     ebp, esp
.text$mn:00000E57                 sub     esp, 10h
.text$mn:00000E5A                 mov     [ebp+var_8], ecx
.text$mn:00000E5D                 lea     ecx, [ebp+var_1]
.text$mn:00000E60                 call    ??0?$allocator@U_Container_proxy@std@@@std@@QAE@XZ ; std::allocator<std::_Container_proxy>::allocator<std::_Container_proxy>(void)
.text$mn:00000E65                 push    1
.text$mn:00000E67                 lea     ecx, [ebp+var_1]
.text$mn:00000E6A                 call    ?allocate@?$allocator@U_Container_proxy@std@@@std@@QAEPAU_Container_proxy@2@I@Z ; std::allocator<std::_Container_proxy>::allocate(uint)
.text$mn:00000E6F                 mov     ecx, [ebp+var_8]
.text$mn:00000E72                 mov     [ecx], eax
.text$mn:00000E74                 lea     ecx, [ebp+var_10] ; this
.text$mn:00000E77                 call    ??0_Container_proxy@std@@QAE@XZ ; std::_Container_proxy::_Container_proxy(void)
.text$mn:00000E7C                 push    eax             ; int
.text$mn:00000E7D                 mov     edx, [ebp+var_8]
.text$mn:00000E80                 mov     eax, [edx]
.text$mn:00000E82                 push    eax             ; void *
.text$mn:00000E83                 lea     ecx, [ebp+var_1]
.text$mn:00000E86                 call    ??$construct@U_Container_proxy@std@@U12@@?$allocator@U_Container_proxy@std@@@std@@QAEXPAU_Container_proxy@1@$$QAU21@@Z ; std::allocator<std::_Container_proxy>::construct<std::_Container_proxy,std::_Container_proxy>(std::_Container_proxy *,std::_Container_proxy &&)
.text$mn:00000E8B                 mov     ecx, [ebp+var_8]
.text$mn:00000E8E                 mov     edx, [ecx]
.text$mn:00000E90                 mov     eax, [ebp+var_8]
.text$mn:00000E93                 mov     [edx], eax
.text$mn:00000E95                 mov     esp, ebp
.text$mn:00000E97                 pop     ebp
.text$mn:00000E98                 retn
.text$mn:00000E98 ?_Alloc_proxy@?$_String_alloc@$0A@U?$_String_base_types@DV?$allocator@D@std@@@std@@@std@@QAEXXZ endp
.text$mn:00000E98
.text$mn:00000E98 ; ---------------------------------------------------------------------------
.text$mn:00000E99                 align 4
.text$mn:00000E99 _text$mn        ends
.text$mn:00000E99
.text$mn:00000E9C ; ===========================================================================
.text$mn:00000E9C
.text$mn:00000E9C ; Segment type: Pure code
.text$mn:00000E9C ; Segment permissions: Read/Execute
.text$mn:00000E9C _text$mn        segment para public 'CODE' use32
.text$mn:00000E9C                 assume cs:_text$mn
.text$mn:00000E9C                 ;org 0E9Ch
.text$mn:00000E9C ; COMDAT (pick any)
.text$mn:00000E9C                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text$mn:00000E9C
.text$mn:00000E9C ; =============== S U B R O U T I N E =======================================
.text$mn:00000E9C
.text$mn:00000E9C ; Attributes: bp-based frame
.text$mn:00000E9C
.text$mn:00000E9C ; public: void __thiscall std::basic_string<char, struct std::char_traits<char>, class std::allocator<char>>::_Copy(unsigned int, unsigned int)
.text$mn:00000E9C                 public ?_Copy@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEXII@Z
.text$mn:00000E9C ?_Copy@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEXII@Z proc near
.text$mn:00000E9C                                         ; CODE XREF: std::basic_string<char,std::char_traits<char>,std::allocator<char>>::_Grow(uint,bool)+37p
.text$mn:00000E9C
.text$mn:00000E9C var_20          = dword ptr -20h
.text$mn:00000E9C var_1C          = dword ptr -1Ch
.text$mn:00000E9C var_18          = dword ptr -18h
.text$mn:00000E9C var_11          = byte ptr -11h
.text$mn:00000E9C var_10          = dword ptr -10h
.text$mn:00000E9C var_C           = byte ptr -0Ch
.text$mn:00000E9C var_4           = dword ptr -4
.text$mn:00000E9C arg_0           = dword ptr  8
.text$mn:00000E9C
.text$mn:00000E9C ; FUNCTION CHUNK AT .text$mn:00000FBE SIZE 00000009 BYTES
.text$mn:00000E9C
.text$mn:00000E9C                 push    ebp
.text$mn:00000E9D                 mov     ebp, esp
.text$mn:00000E9F                 push    0FFFFFFFFh
.text$mn:00000EA1                 push    offset __ehhandler$?_Copy@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEXII@Z
.text$mn:00000EA6                 mov     eax, large fs:0
.text$mn:00000EAC                 push    eax
.text$mn:00000EAD                 push    ecx
.text$mn:00000EAE                 sub     esp, 10h
.text$mn:00000EB1                 push    ebx
.text$mn:00000EB2                 push    esi
.text$mn:00000EB3                 push    edi
.text$mn:00000EB4                 mov     eax, dword ptr ds:___security_cookie
.text$mn:00000EB9                 xor     eax, ebp
.text$mn:00000EBB                 push    eax
.text$mn:00000EBC                 lea     eax, [ebp+var_C]
.text$mn:00000EBF                 mov     large fs:0, eax
.text$mn:00000EC5                 mov     [ebp+var_10], esp
.text$mn:00000EC8                 mov     [ebp+var_18], ecx
.text$mn:00000ECB                 mov     eax, [ebp+arg_0]
.text$mn:00000ECE                 or      eax, 0Fh
.text$mn:00000ED1                 mov     [ebp+var_1C], eax
.text$mn:00000ED4                 mov     ecx, [ebp+var_18]
.text$mn:00000ED7                 call    ?max_size@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QBEIXZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char>>::max_size(void)
.text$mn:00000EDC                 cmp     eax, [ebp+var_1C]
.text$mn:00000EDF                 jnb     short loc_EE9
.text$mn:00000EE1                 mov     ecx, [ebp+arg_0]
.text$mn:00000EE4                 mov     [ebp+var_1C], ecx
.text$mn:00000EE7                 jmp     short loc_F3B
.text$mn:00000EE9 ; ---------------------------------------------------------------------------
.text$mn:00000EE9
.text$mn:00000EE9 loc_EE9:                                ; CODE XREF: std::basic_string<char,std::char_traits<char>,std::allocator<char>>::_Copy(uint,uint)+43j
.text$mn:00000EE9                 mov     edx, [ebp+var_18]
.text$mn:00000EEC                 mov     ecx, [edx+18h]
.text$mn:00000EEF                 shr     ecx, 1
.text$mn:00000EF1                 mov     eax, [ebp+var_1C]
.text$mn:00000EF4                 xor     edx, edx
.text$mn:00000EF6                 mov     esi, 3
.text$mn:00000EFB                 div     esi
.text$mn:00000EFD                 cmp     ecx, eax
.text$mn:00000EFF                 ja      short loc_F03
.text$mn:00000F01                 jmp     short loc_F3B
.text$mn:00000F03 ; ---------------------------------------------------------------------------
.text$mn:00000F03
.text$mn:00000F03 loc_F03:                                ; CODE XREF: std::basic_string<char,std::char_traits<char>,std::allocator<char>>::_Copy(uint,uint)+63j
.text$mn:00000F03                 mov     ecx, [ebp+var_18]
.text$mn:00000F06                 call    ?max_size@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QBEIXZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char>>::max_size(void)
.text$mn:00000F0B                 mov     edx, [ebp+var_18]
.text$mn:00000F0E                 mov     ecx, [edx+18h]
.text$mn:00000F11                 shr     ecx, 1
.text$mn:00000F13                 sub     eax, ecx
.text$mn:00000F15                 mov     edx, [ebp+var_18]
.text$mn:00000F18                 cmp     [edx+18h], eax
.text$mn:00000F1B                 ja      short loc_F30
.text$mn:00000F1D                 mov     eax, [ebp+var_18]
.text$mn:00000F20                 mov     ecx, [eax+18h]
.text$mn:00000F23                 shr     ecx, 1
.text$mn:00000F25                 mov     edx, [ebp+var_18]
.text$mn:00000F28                 add     ecx, [edx+18h]
.text$mn:00000F2B                 mov     [ebp+var_1C], ecx
.text$mn:00000F2E                 jmp     short loc_F3B
.text$mn:00000F30 ; ---------------------------------------------------------------------------
.text$mn:00000F30
.text$mn:00000F30 loc_F30:                                ; CODE XREF: std::basic_string<char,std::char_traits<char>,std::allocator<char>>::_Copy(uint,uint)+7Fj
.text$mn:00000F30                 mov     ecx, [ebp+var_18]
.text$mn:00000F33                 call    ?max_size@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QBEIXZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char>>::max_size(void)
.text$mn:00000F38                 mov     [ebp+var_1C], eax
.text$mn:00000F3B
.text$mn:00000F3B loc_F3B:                                ; CODE XREF: std::basic_string<char,std::char_traits<char>,std::allocator<char>>::_Copy(uint,uint)+4Bj
.text$mn:00000F3B                                         ; std::basic_string<char,std::char_traits<char>,std::allocator<char>>::_Copy(uint,uint)+65j ...
.text$mn:00000F3B                 mov     [ebp+var_4], 0
.text$mn:00000F42                 mov     eax, [ebp+var_1C]
.text$mn:00000F45                 add     eax, 1
.text$mn:00000F48                 push    eax
.text$mn:00000F49                 lea     ecx, [ebp+var_11]
.text$mn:00000F4C                 push    ecx
.text$mn:00000F4D                 mov     ecx, [ebp+var_18]
.text$mn:00000F50                 call    ?_Getal@?$_String_alloc@$0A@U?$_String_base_types@DV?$allocator@D@std@@@std@@@std@@QBE?AU?$_Wrap_alloc@V?$allocator@D@std@@@2@XZ ; std::_String_alloc<0,std::_String_base_types<char,std::allocator<char>>>::_Getal(void)
.text$mn:00000F55                 mov     ecx, eax
.text$mn:00000F57                 call    ?allocate@?$_Wrap_alloc@V?$allocator@D@std@@@std@@QAEPADI@Z ; std::_Wrap_alloc<std::allocator<char>>::allocate(uint)
.text$mn:00000F5C                 mov     [ebp+var_20], eax
.text$mn:00000F5F                 jmp     short loc_FBE
.text$mn:00000F5F ?_Copy@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEXII@Z endp
.text$mn:00000F5F
.text$mn:00000F61
.text$mn:00000F61 ; =============== S U B R O U T I N E =======================================
.text$mn:00000F61
.text$mn:00000F61
.text$mn:00000F61 __catch$?_Copy@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEXII@Z$0 proc near
.text$mn:00000F61                                         ; DATA XREF: .xdata$x:00001CF8o
.text$mn:00000F61
.text$mn:00000F61 ; FUNCTION CHUNK AT .text$mn:00000FA8 SIZE 00000009 BYTES
.text$mn:00000F61 ; FUNCTION CHUNK AT .text$mn:00000FB8 SIZE 00000006 BYTES
.text$mn:00000F61
.text$mn:00000F61                 mov     [ebp-10h], esp
.text$mn:00000F64                 mov     edx, [ebp+8]
.text$mn:00000F67                 mov     [ebp-1Ch], edx
.text$mn:00000F6A                 mov     byte ptr [ebp-4], 2
.text$mn:00000F6E                 mov     eax, [ebp-1Ch]
.text$mn:00000F71                 add     eax, 1
.text$mn:00000F74                 push    eax
.text$mn:00000F75                 lea     ecx, [ebp-12h]
.text$mn:00000F78                 push    ecx
.text$mn:00000F79                 mov     ecx, [ebp-18h]
.text$mn:00000F7C                 call    ?_Getal@?$_String_alloc@$0A@U?$_String_base_types@DV?$allocator@D@std@@@std@@@std@@QBE?AU?$_Wrap_alloc@V?$allocator@D@std@@@2@XZ ; std::_String_alloc<0,std::_String_base_types<char,std::allocator<char>>>::_Getal(void)
.text$mn:00000F81                 mov     ecx, eax
.text$mn:00000F83                 call    ?allocate@?$_Wrap_alloc@V?$allocator@D@std@@@std@@QAEPADI@Z ; std::_Wrap_alloc<std::allocator<char>>::allocate(uint)
.text$mn:00000F88                 mov     [ebp-20h], eax
.text$mn:00000F8B                 jmp     short loc_FA8
.text$mn:00000F8B __catch$?_Copy@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEXII@Z$0 endp
.text$mn:00000F8B
.text$mn:00000F8D
.text$mn:00000F8D ; =============== S U B R O U T I N E =======================================
.text$mn:00000F8D
.text$mn:00000F8D ; Attributes: noreturn
.text$mn:00000F8D
.text$mn:00000F8D __catch$?_Copy@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEXII@Z$1 proc near
.text$mn:00000F8D                                         ; DATA XREF: .xdata$x:00001D08o
.text$mn:00000F8D                 push    0               ; Size
.text$mn:00000F8F                 push    1               ; char
.text$mn:00000F91                 mov     ecx, [ebp-18h]
.text$mn:00000F94                 call    ?_Tidy@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEX_NI@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char>>::_Tidy(bool,uint)
.text$mn:00000F99                 push    0
.text$mn:00000F9B                 push    0
.text$mn:00000F9D                 call    __CxxThrowException@8 ; _CxxThrowException(x,x)
.text$mn:00000F9D __catch$?_Copy@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEXII@Z$1 endp
.text$mn:00000F9D
.text$mn:00000FA2 ; ---------------------------------------------------------------------------
.text$mn:00000FA2                 mov     eax, offset $LN17
.text$mn:00000FA7                 retn
.text$mn:00000FA8 ; ---------------------------------------------------------------------------
.text$mn:00000FA8 ; START OF FUNCTION CHUNK FOR __catch$?_Copy@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEXII@Z$0
.text$mn:00000FA8
.text$mn:00000FA8 loc_FA8:                                ; CODE XREF: __catch$?_Copy@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEXII@Z$0+2Aj
.text$mn:00000FA8                 mov     dword ptr [ebp-4], 1
.text$mn:00000FAF                 jmp     short loc_FB8
.text$mn:00000FAF ; END OF FUNCTION CHUNK FOR __catch$?_Copy@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEXII@Z$0
.text$mn:00000FB1
.text$mn:00000FB1 ; =============== S U B R O U T I N E =======================================
.text$mn:00000FB1
.text$mn:00000FB1
.text$mn:00000FB1 $LN17           proc near               ; DATA XREF: .text$mn:00000FA2o
.text$mn:00000FB1                 mov     dword ptr [ebp-4], 1
.text$mn:00000FB1 $LN17           endp ; sp-analysis failed
.text$mn:00000FB1
.text$mn:00000FB8 ; START OF FUNCTION CHUNK FOR __catch$?_Copy@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEXII@Z$0
.text$mn:00000FB8
.text$mn:00000FB8 loc_FB8:                                ; CODE XREF: __catch$?_Copy@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEXII@Z$0+4Ej
.text$mn:00000FB8                 mov     eax, offset $LN19
.text$mn:00000FBD                 retn
.text$mn:00000FBD ; END OF FUNCTION CHUNK FOR __catch$?_Copy@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEXII@Z$0
.text$mn:00000FBE ; ---------------------------------------------------------------------------
.text$mn:00000FBE ; START OF FUNCTION CHUNK FOR ?_Copy@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEXII@Z
.text$mn:00000FBE
.text$mn:00000FBE loc_FBE:                                ; CODE XREF: std::basic_string<char,std::char_traits<char>,std::allocator<char>>::_Copy(uint,uint)+C3j
.text$mn:00000FBE                 mov     [ebp+var_4], 0FFFFFFFFh
.text$mn:00000FC5                 jmp     short loc_FCE
.text$mn:00000FC5 ; END OF FUNCTION CHUNK FOR ?_Copy@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEXII@Z
.text$mn:00000FC7
.text$mn:00000FC7 ; =============== S U B R O U T I N E =======================================
.text$mn:00000FC7
.text$mn:00000FC7
.text$mn:00000FC7 $LN19           proc near               ; DATA XREF: __catch$?_Copy@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEXII@Z$0:loc_FB8o
.text$mn:00000FC7                 mov     dword ptr [ebp-4], 0FFFFFFFFh
.text$mn:00000FCE
.text$mn:00000FCE loc_FCE:                                ; CODE XREF: std::basic_string<char,std::char_traits<char>,std::allocator<char>>::_Copy(uint,uint)+129j
.text$mn:00000FCE                 cmp     dword ptr [ebp+0Ch], 0
.text$mn:00000FD2                 jbe     short loc_FED
.text$mn:00000FD4                 mov     edx, [ebp+0Ch]
.text$mn:00000FD7                 push    edx             ; Size
.text$mn:00000FD8                 mov     ecx, [ebp-18h]
.text$mn:00000FDB                 call    ?_Myptr@?$_String_val@U?$_Simple_types@D@std@@@std@@QAEPADXZ ; std::_String_val<std::_Simple_types<char>>::_Myptr(void)
.text$mn:00000FE0                 push    eax             ; Src
.text$mn:00000FE1                 mov     eax, [ebp-20h]
.text$mn:00000FE4                 push    eax             ; Dst
.text$mn:00000FE5                 call    ?copy@?$char_traits@D@std@@SAPADPADPBDI@Z ; std::char_traits<char>::copy(char *,char const *,uint)
.text$mn:00000FEA                 add     esp, 0Ch
.text$mn:00000FED
.text$mn:00000FED loc_FED:                                ; CODE XREF: $LN19+Bj
.text$mn:00000FED                 push    0               ; Size
.text$mn:00000FEF                 push    1               ; char
.text$mn:00000FF1                 mov     ecx, [ebp-18h]
.text$mn:00000FF4                 call    ?_Tidy@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEX_NI@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char>>::_Tidy(bool,uint)
.text$mn:00000FF9                 lea     ecx, [ebp-20h]
.text$mn:00000FFC                 push    ecx             ; int
.text$mn:00000FFD                 mov     edx, [ebp-18h]
.text$mn:00001000                 add     edx, 4
.text$mn:00001003                 push    edx             ; void *
.text$mn:00001004                 lea     eax, [ebp-13h]
.text$mn:00001007                 push    eax
.text$mn:00001008                 mov     ecx, [ebp-18h]
.text$mn:0000100B                 call    ?_Getal@?$_String_alloc@$0A@U?$_String_base_types@DV?$allocator@D@std@@@std@@@std@@QBE?AU?$_Wrap_alloc@V?$allocator@D@std@@@2@XZ ; std::_String_alloc<0,std::_String_base_types<char,std::allocator<char>>>::_Getal(void)
.text$mn:00001010                 mov     ecx, eax
.text$mn:00001012                 call    ??$construct@PADAAPAD@?$_Wrap_alloc@V?$allocator@D@std@@@std@@QAEXPAPADAAPAD@Z ; std::_Wrap_alloc<std::allocator<char>>::construct<char *,char * &>(char * *,char * &)
.text$mn:00001017                 mov     ecx, [ebp-18h]
.text$mn:0000101A                 mov     edx, [ebp-1Ch]
.text$mn:0000101D                 mov     [ecx+18h], edx
.text$mn:00001020                 mov     eax, [ebp+0Ch]
.text$mn:00001023                 push    eax
.text$mn:00001024                 mov     ecx, [ebp-18h]
.text$mn:00001027                 call    ?_Eos@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEXI@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char>>::_Eos(uint)
.text$mn:0000102C                 mov     ecx, [ebp-0Ch]
.text$mn:0000102F                 mov     large fs:0, ecx
.text$mn:00001036                 pop     ecx
.text$mn:00001037                 pop     edi
.text$mn:00001038                 pop     esi
.text$mn:00001039                 pop     ebx
.text$mn:0000103A                 mov     esp, ebp
.text$mn:0000103C                 pop     ebp
.text$mn:0000103D                 retn    8
.text$mn:0000103D $LN19           endp ; sp-analysis failed
.text$mn:0000103D
.text$mn:0000103D _text$mn        ends
.text$mn:0000103D
.text$x:00001040 ; ===========================================================================
.text$x:00001040
.text$x:00001040 ; Segment type: Pure code
.text$x:00001040 ; Segment permissions: Read/Execute
.text$x:00001040 _text$x         segment para public 'CODE' use32
.text$x:00001040                 assume cs:_text$x
.text$x:00001040                 ;org 1040h
.text$x:00001040 ; COMDAT (pick associative to section at E9C)
.text$x:00001040                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text$x:00001040
.text$x:00001040 ; =============== S U B R O U T I N E =======================================
.text$x:00001040
.text$x:00001040
.text$x:00001040 __ehhandler$?_Copy@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEXII@Z proc near
.text$x:00001040                                         ; DATA XREF: std::basic_string<char,std::char_traits<char>,std::allocator<char>>::_Copy(uint,uint)+5o
.text$x:00001040
.text$x:00001040 arg_4           = dword ptr  8
.text$x:00001040
.text$x:00001040                 mov     edx, [esp+arg_4]
.text$x:00001044                 lea     eax, [edx+0Ch]
.text$x:00001047                 mov     ecx, [edx-24h]
.text$x:0000104A                 xor     ecx, eax
.text$x:0000104C                 call    @__security_check_cookie@4 ; __security_check_cookie(x)
.text$x:00001051                 mov     eax, offset __ehfuncinfo$?_Copy@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEXII@Z
.text$x:00001056                 jmp     ___CxxFrameHandler3
.text$x:00001056 __ehhandler$?_Copy@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEXII@Z endp
.text$x:00001056
.text$x:00001056 ; ---------------------------------------------------------------------------
.text$x:0000105B                 align 4
.text$x:0000105B _text$x         ends
.text$x:0000105B
.text$mn:0000105C ; ===========================================================================
.text$mn:0000105C
.text$mn:0000105C ; Segment type: Pure code
.text$mn:0000105C ; Segment permissions: Read/Execute
.text$mn:0000105C _text$mn        segment para public 'CODE' use32
.text$mn:0000105C                 assume cs:_text$mn
.text$mn:0000105C                 ;org 105Ch
.text$mn:0000105C ; COMDAT (pick any)
.text$mn:0000105C                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text$mn:0000105C
.text$mn:0000105C ; =============== S U B R O U T I N E =======================================
.text$mn:0000105C
.text$mn:0000105C ; Attributes: bp-based frame
.text$mn:0000105C
.text$mn:0000105C ; public: void __thiscall std::basic_string<char, struct std::char_traits<char>, class std::allocator<char>>::_Eos(unsigned int)
.text$mn:0000105C                 public ?_Eos@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEXI@Z
.text$mn:0000105C ?_Eos@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEXI@Z proc near
.text$mn:0000105C                                         ; CODE XREF: $LN19+60p
.text$mn:0000105C                                         ; std::basic_string<char,std::char_traits<char>,std::allocator<char>>::_Grow(uint,bool)+83p ...
.text$mn:0000105C
.text$mn:0000105C var_8           = dword ptr -8
.text$mn:0000105C var_1           = byte ptr -1
.text$mn:0000105C arg_0           = dword ptr  8
.text$mn:0000105C
.text$mn:0000105C                 push    ebp
.text$mn:0000105D                 mov     ebp, esp
.text$mn:0000105F                 sub     esp, 8
.text$mn:00001062                 mov     [ebp+var_8], ecx
.text$mn:00001065                 mov     [ebp+var_1], 0
.text$mn:00001069                 mov     eax, [ebp+var_8]
.text$mn:0000106C                 mov     ecx, [ebp+arg_0]
.text$mn:0000106F                 mov     [eax+14h], ecx
.text$mn:00001072                 lea     edx, [ebp+var_1]
.text$mn:00001075                 push    edx
.text$mn:00001076                 mov     ecx, [ebp+var_8]
.text$mn:00001079                 call    ?_Myptr@?$_String_val@U?$_Simple_types@D@std@@@std@@QAEPADXZ ; std::_String_val<std::_Simple_types<char>>::_Myptr(void)
.text$mn:0000107E                 add     eax, [ebp+arg_0]
.text$mn:00001081                 push    eax
.text$mn:00001082                 call    ?assign@?$char_traits@D@std@@SAXAADABD@Z ; std::char_traits<char>::assign(char &,char const &)
.text$mn:00001087                 add     esp, 8
.text$mn:0000108A                 mov     esp, ebp
.text$mn:0000108C                 pop     ebp
.text$mn:0000108D                 retn    4
.text$mn:0000108D ?_Eos@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEXI@Z endp
.text$mn:0000108D
.text$mn:0000108D _text$mn        ends
.text$mn:0000108D
.text$mn:00001090 ; ===========================================================================
.text$mn:00001090
.text$mn:00001090 ; Segment type: Pure code
.text$mn:00001090 ; Segment permissions: Read/Execute
.text$mn:00001090 _text$mn        segment para public 'CODE' use32
.text$mn:00001090                 assume cs:_text$mn
.text$mn:00001090                 ;org 1090h
.text$mn:00001090 ; COMDAT (pick any)
.text$mn:00001090                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text$mn:00001090
.text$mn:00001090 ; =============== S U B R O U T I N E =======================================
.text$mn:00001090
.text$mn:00001090 ; Attributes: bp-based frame
.text$mn:00001090
.text$mn:00001090 ; public: void __thiscall std::_String_alloc<0, struct std::_String_base_types<char, class std::allocator<char>>>::_Free_proxy(void)
.text$mn:00001090                 public ?_Free_proxy@?$_String_alloc@$0A@U?$_String_base_types@DV?$allocator@D@std@@@std@@@std@@QAEXXZ
.text$mn:00001090 ?_Free_proxy@?$_String_alloc@$0A@U?$_String_base_types@DV?$allocator@D@std@@@std@@@std@@QAEXXZ proc near
.text$mn:00001090                                         ; CODE XREF: std::_String_alloc<0,std::_String_base_types<char,std::allocator<char>>>::~_String_alloc<0,std::_String_base_types<char,std::allocator<char>>>(void)+30p
.text$mn:00001090
.text$mn:00001090 var_8           = dword ptr -8
.text$mn:00001090 var_1           = byte ptr -1
.text$mn:00001090
.text$mn:00001090                 push    ebp
.text$mn:00001091                 mov     ebp, esp
.text$mn:00001093                 sub     esp, 8
.text$mn:00001096                 mov     [ebp+var_8], ecx
.text$mn:00001099                 lea     ecx, [ebp+var_1]
.text$mn:0000109C                 call    ??0?$allocator@U_Container_proxy@std@@@std@@QAE@XZ ; std::allocator<std::_Container_proxy>::allocator<std::_Container_proxy>(void)
.text$mn:000010A1                 mov     ecx, [ebp+var_8] ; this
.text$mn:000010A4                 call    ?_Orphan_all@_Container_base12@std@@QAEXXZ ; std::_Container_base12::_Orphan_all(void)
.text$mn:000010A9                 mov     eax, [ebp+var_8]
.text$mn:000010AC                 mov     ecx, [eax]
.text$mn:000010AE                 push    ecx
.text$mn:000010AF                 lea     ecx, [ebp+var_1]
.text$mn:000010B2                 call    ??$destroy@U_Container_proxy@std@@@?$allocator@U_Container_proxy@std@@@std@@QAEXPAU_Container_proxy@1@@Z ; std::allocator<std::_Container_proxy>::destroy<std::_Container_proxy>(std::_Container_proxy *)
.text$mn:000010B7                 push    1               ; int
.text$mn:000010B9                 mov     edx, [ebp+var_8]
.text$mn:000010BC                 mov     eax, [edx]
.text$mn:000010BE                 push    eax             ; void *
.text$mn:000010BF                 lea     ecx, [ebp+var_1]
.text$mn:000010C2                 call    ?deallocate@?$allocator@U_Container_proxy@std@@@std@@QAEXPAU_Container_proxy@2@I@Z ; std::allocator<std::_Container_proxy>::deallocate(std::_Container_proxy *,uint)
.text$mn:000010C7                 mov     ecx, [ebp+var_8]
.text$mn:000010CA                 mov     dword ptr [ecx], 0
.text$mn:000010D0                 mov     esp, ebp
.text$mn:000010D2                 pop     ebp
.text$mn:000010D3                 retn
.text$mn:000010D3 ?_Free_proxy@?$_String_alloc@$0A@U?$_String_base_types@DV?$allocator@D@std@@@std@@@std@@QAEXXZ endp
.text$mn:000010D3
.text$mn:000010D3 _text$mn        ends
.text$mn:000010D3
.text$mn:000010D4 ; ===========================================================================
.text$mn:000010D4
.text$mn:000010D4 ; Segment type: Pure code
.text$mn:000010D4 ; Segment permissions: Read/Execute
.text$mn:000010D4 _text$mn        segment para public 'CODE' use32
.text$mn:000010D4                 assume cs:_text$mn
.text$mn:000010D4                 ;org 10D4h
.text$mn:000010D4 ; COMDAT (pick any)
.text$mn:000010D4                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text$mn:000010D4
.text$mn:000010D4 ; =============== S U B R O U T I N E =======================================
.text$mn:000010D4
.text$mn:000010D4 ; Attributes: bp-based frame
.text$mn:000010D4
.text$mn:000010D4 ; public: struct std::_Wrap_alloc<class std::allocator<char>> __thiscall std::_String_alloc<0, struct std::_String_base_types<char, class std::allocator<char>>>::_Getal(void)const
.text$mn:000010D4                 public ?_Getal@?$_String_alloc@$0A@U?$_String_base_types@DV?$allocator@D@std@@@std@@@std@@QBE?AU?$_Wrap_alloc@V?$allocator@D@std@@@2@XZ
.text$mn:000010D4 ?_Getal@?$_String_alloc@$0A@U?$_String_base_types@DV?$allocator@D@std@@@std@@@std@@QBE?AU?$_Wrap_alloc@V?$allocator@D@std@@@2@XZ proc near
.text$mn:000010D4                                         ; CODE XREF: std::basic_string<char,std::char_traits<char>,std::allocator<char>>::_Copy(uint,uint)+B4p
.text$mn:000010D4                                         ; __catch$?_Copy@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEXII@Z$0+1Bp ...
.text$mn:000010D4
.text$mn:000010D4 var_4           = dword ptr -4
.text$mn:000010D4 arg_0           = dword ptr  8
.text$mn:000010D4
.text$mn:000010D4                 push    ebp
.text$mn:000010D5                 mov     ebp, esp
.text$mn:000010D7                 push    ecx
.text$mn:000010D8                 mov     [ebp+var_4], ecx
.text$mn:000010DB                 mov     ecx, [ebp+arg_0]
.text$mn:000010DE                 call    ??0?$_Wrap_alloc@V?$allocator@D@std@@@std@@QAE@XZ ; std::_Wrap_alloc<std::allocator<char>>::_Wrap_alloc<std::allocator<char>>(void)
.text$mn:000010E3                 mov     eax, [ebp+arg_0]
.text$mn:000010E6                 mov     esp, ebp
.text$mn:000010E8                 pop     ebp
.text$mn:000010E9                 retn    4
.text$mn:000010E9 ?_Getal@?$_String_alloc@$0A@U?$_String_base_types@DV?$allocator@D@std@@@std@@@std@@QBE?AU?$_Wrap_alloc@V?$allocator@D@std@@@2@XZ endp
.text$mn:000010E9
.text$mn:000010E9 _text$mn        ends
.text$mn:000010E9
.text$mn:000010EC ; ===========================================================================
.text$mn:000010EC
.text$mn:000010EC ; Segment type: Pure code
.text$mn:000010EC ; Segment permissions: Read/Execute
.text$mn:000010EC _text$mn        segment para public 'CODE' use32
.text$mn:000010EC                 assume cs:_text$mn
.text$mn:000010EC                 ;org 10ECh
.text$mn:000010EC ; COMDAT (pick any)
.text$mn:000010EC                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text$mn:000010EC
.text$mn:000010EC ; =============== S U B R O U T I N E =======================================
.text$mn:000010EC
.text$mn:000010EC ; Attributes: bp-based frame
.text$mn:000010EC
.text$mn:000010EC ; public: bool __thiscall std::basic_string<char, struct std::char_traits<char>, class std::allocator<char>>::_Grow(unsigned int, bool)
.text$mn:000010EC                 public ?_Grow@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE_NI_N@Z
.text$mn:000010EC ?_Grow@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE_NI_N@Z proc near
.text$mn:000010EC                                         ; CODE XREF: std::basic_string<char,std::char_traits<char>,std::allocator<char>>::assign(std::basic_string<char,std::char_traits<char>,std::allocator<char>> const &,uint,uint)+6Ap
.text$mn:000010EC                                         ; std::basic_string<char,std::char_traits<char>,std::allocator<char>>::assign(char const *,uint)+5Fp
.text$mn:000010EC
.text$mn:000010EC var_C           = dword ptr -0Ch
.text$mn:000010EC Size            = dword ptr -8
.text$mn:000010EC var_4           = dword ptr -4
.text$mn:000010EC arg_0           = dword ptr  8
.text$mn:000010EC arg_4           = byte ptr  0Ch
.text$mn:000010EC
.text$mn:000010EC                 push    ebp
.text$mn:000010ED                 mov     ebp, esp
.text$mn:000010EF                 sub     esp, 0Ch
.text$mn:000010F2                 mov     [ebp+var_4], ecx
.text$mn:000010F5                 mov     ecx, [ebp+var_4]
.text$mn:000010F8                 call    ?max_size@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QBEIXZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char>>::max_size(void)
.text$mn:000010FD                 cmp     eax, [ebp+arg_0]
.text$mn:00001100                 jnb     short loc_110A
.text$mn:00001102                 mov     ecx, [ebp+var_4]
.text$mn:00001105                 call    ?_Xlen@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QBEXXZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char>>::_Xlen(void)
.text$mn:0000110A
.text$mn:0000110A loc_110A:                               ; CODE XREF: std::basic_string<char,std::char_traits<char>,std::allocator<char>>::_Grow(uint,bool)+14j
.text$mn:0000110A                 mov     eax, [ebp+var_4]
.text$mn:0000110D                 mov     ecx, [eax+18h]
.text$mn:00001110                 cmp     ecx, [ebp+arg_0]
.text$mn:00001113                 jnb     short loc_112A
.text$mn:00001115                 mov     edx, [ebp+var_4]
.text$mn:00001118                 mov     eax, [edx+14h]
.text$mn:0000111B                 push    eax
.text$mn:0000111C                 mov     ecx, [ebp+arg_0]
.text$mn:0000111F                 push    ecx
.text$mn:00001120                 mov     ecx, [ebp+var_4]
.text$mn:00001123                 call    ?_Copy@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEXII@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char>>::_Copy(uint,uint)
.text$mn:00001128                 jmp     short loc_1174
.text$mn:0000112A ; ---------------------------------------------------------------------------
.text$mn:0000112A
.text$mn:0000112A loc_112A:                               ; CODE XREF: std::basic_string<char,std::char_traits<char>,std::allocator<char>>::_Grow(uint,bool)+27j
.text$mn:0000112A                 movzx   edx, [ebp+arg_4]
.text$mn:0000112E                 test    edx, edx
.text$mn:00001130                 jz      short loc_1164
.text$mn:00001132                 cmp     [ebp+arg_0], 10h
.text$mn:00001136                 jnb     short loc_1164
.text$mn:00001138                 mov     eax, [ebp+var_4]
.text$mn:0000113B                 mov     ecx, [ebp+arg_0]
.text$mn:0000113E                 cmp     ecx, [eax+14h]
.text$mn:00001141                 jnb     short loc_114B
.text$mn:00001143                 mov     edx, [ebp+arg_0]
.text$mn:00001146                 mov     [ebp+Size], edx
.text$mn:00001149                 jmp     short loc_1154
.text$mn:0000114B ; ---------------------------------------------------------------------------
.text$mn:0000114B
.text$mn:0000114B loc_114B:                               ; CODE XREF: std::basic_string<char,std::char_traits<char>,std::allocator<char>>::_Grow(uint,bool)+55j
.text$mn:0000114B                 mov     eax, [ebp+var_4]
.text$mn:0000114E                 mov     ecx, [eax+14h]
.text$mn:00001151                 mov     [ebp+Size], ecx
.text$mn:00001154
.text$mn:00001154 loc_1154:                               ; CODE XREF: std::basic_string<char,std::char_traits<char>,std::allocator<char>>::_Grow(uint,bool)+5Dj
.text$mn:00001154                 mov     edx, [ebp+Size]
.text$mn:00001157                 push    edx             ; Size
.text$mn:00001158                 push    1               ; char
.text$mn:0000115A                 mov     ecx, [ebp+var_4]
.text$mn:0000115D                 call    ?_Tidy@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEX_NI@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char>>::_Tidy(bool,uint)
.text$mn:00001162                 jmp     short loc_1174
.text$mn:00001164 ; ---------------------------------------------------------------------------
.text$mn:00001164
.text$mn:00001164 loc_1164:                               ; CODE XREF: std::basic_string<char,std::char_traits<char>,std::allocator<char>>::_Grow(uint,bool)+44j
.text$mn:00001164                                         ; std::basic_string<char,std::char_traits<char>,std::allocator<char>>::_Grow(uint,bool)+4Aj
.text$mn:00001164                 cmp     [ebp+arg_0], 0
.text$mn:00001168                 jnz     short loc_1174
.text$mn:0000116A                 push    0
.text$mn:0000116C                 mov     ecx, [ebp+var_4]
.text$mn:0000116F                 call    ?_Eos@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEXI@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char>>::_Eos(uint)
.text$mn:00001174
.text$mn:00001174 loc_1174:                               ; CODE XREF: std::basic_string<char,std::char_traits<char>,std::allocator<char>>::_Grow(uint,bool)+3Cj
.text$mn:00001174                                         ; std::basic_string<char,std::char_traits<char>,std::allocator<char>>::_Grow(uint,bool)+76j ...
.text$mn:00001174                 cmp     [ebp+arg_0], 0
.text$mn:00001178                 jbe     short loc_1183
.text$mn:0000117A                 mov     [ebp+var_C], 1
.text$mn:00001181                 jmp     short loc_118A
.text$mn:00001183 ; ---------------------------------------------------------------------------
.text$mn:00001183
.text$mn:00001183 loc_1183:                               ; CODE XREF: std::basic_string<char,std::char_traits<char>,std::allocator<char>>::_Grow(uint,bool)+8Cj
.text$mn:00001183                 mov     [ebp+var_C], 0
.text$mn:0000118A
.text$mn:0000118A loc_118A:                               ; CODE XREF: std::basic_string<char,std::char_traits<char>,std::allocator<char>>::_Grow(uint,bool)+95j
.text$mn:0000118A                 mov     al, byte ptr [ebp+var_C]
.text$mn:0000118D                 mov     esp, ebp
.text$mn:0000118F                 pop     ebp
.text$mn:00001190                 retn    8
.text$mn:00001190 ?_Grow@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE_NI_N@Z endp
.text$mn:00001190
.text$mn:00001190 ; ---------------------------------------------------------------------------
.text$mn:00001193                 align 4
.text$mn:00001193 _text$mn        ends
.text$mn:00001193
.text$mn:00001194 ; ===========================================================================
.text$mn:00001194
.text$mn:00001194 ; Segment type: Pure code
.text$mn:00001194 ; Segment permissions: Read/Execute
.text$mn:00001194 _text$mn        segment para public 'CODE' use32
.text$mn:00001194                 assume cs:_text$mn
.text$mn:00001194                 ;org 1194h
.text$mn:00001194 ; COMDAT (pick any)
.text$mn:00001194                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text$mn:00001194
.text$mn:00001194 ; =============== S U B R O U T I N E =======================================
.text$mn:00001194
.text$mn:00001194 ; Attributes: bp-based frame
.text$mn:00001194
.text$mn:00001194 ; public: bool __thiscall std::basic_string<char, struct std::char_traits<char>, class std::allocator<char>>::_Inside(char const *)
.text$mn:00001194                 public ?_Inside@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE_NPBD@Z
.text$mn:00001194 ?_Inside@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE_NPBD@Z proc near
.text$mn:00001194                                         ; CODE XREF: std::basic_string<char,std::char_traits<char>,std::allocator<char>>::assign(char const *,uint)+2Ap
.text$mn:00001194
.text$mn:00001194 var_4           = dword ptr -4
.text$mn:00001194 arg_0           = dword ptr  8
.text$mn:00001194
.text$mn:00001194                 push    ebp
.text$mn:00001195                 mov     ebp, esp
.text$mn:00001197                 push    ecx
.text$mn:00001198                 mov     [ebp+var_4], ecx
.text$mn:0000119B                 cmp     [ebp+arg_0], 0
.text$mn:0000119F                 jz      short loc_11C1
.text$mn:000011A1                 mov     ecx, [ebp+var_4]
.text$mn:000011A4                 call    ?_Myptr@?$_String_val@U?$_Simple_types@D@std@@@std@@QAEPADXZ ; std::_String_val<std::_Simple_types<char>>::_Myptr(void)
.text$mn:000011A9                 cmp     [ebp+arg_0], eax
.text$mn:000011AC                 jb      short loc_11C1
.text$mn:000011AE                 mov     ecx, [ebp+var_4]
.text$mn:000011B1                 call    ?_Myptr@?$_String_val@U?$_Simple_types@D@std@@@std@@QAEPADXZ ; std::_String_val<std::_Simple_types<char>>::_Myptr(void)
.text$mn:000011B6                 mov     ecx, [ebp+var_4]
.text$mn:000011B9                 add     eax, [ecx+14h]
.text$mn:000011BC                 cmp     eax, [ebp+arg_0]
.text$mn:000011BF                 ja      short loc_11C7
.text$mn:000011C1
.text$mn:000011C1 loc_11C1:                               ; CODE XREF: std::basic_string<char,std::char_traits<char>,std::allocator<char>>::_Inside(char const *)+Bj
.text$mn:000011C1                                         ; std::basic_string<char,std::char_traits<char>,std::allocator<char>>::_Inside(char const *)+18j
.text$mn:000011C1                 xor     al, al
.text$mn:000011C3                 jmp     short loc_11C9
.text$mn:000011C5 ; ---------------------------------------------------------------------------
.text$mn:000011C5                 jmp     short loc_11C9
.text$mn:000011C7 ; ---------------------------------------------------------------------------
.text$mn:000011C7
.text$mn:000011C7 loc_11C7:                               ; CODE XREF: std::basic_string<char,std::char_traits<char>,std::allocator<char>>::_Inside(char const *)+2Bj
.text$mn:000011C7                 mov     al, 1
.text$mn:000011C9
.text$mn:000011C9 loc_11C9:                               ; CODE XREF: std::basic_string<char,std::char_traits<char>,std::allocator<char>>::_Inside(char const *)+2Fj
.text$mn:000011C9                                         ; std::basic_string<char,std::char_traits<char>,std::allocator<char>>::_Inside(char const *)+31j
.text$mn:000011C9                 mov     esp, ebp
.text$mn:000011CB                 pop     ebp
.text$mn:000011CC                 retn    4
.text$mn:000011CC ?_Inside@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE_NPBD@Z endp
.text$mn:000011CC
.text$mn:000011CC ; ---------------------------------------------------------------------------
.text$mn:000011CF                 align 10h
.text$mn:000011CF _text$mn        ends
.text$mn:000011CF
.text$mn:000011D0 ; ===========================================================================
.text$mn:000011D0
.text$mn:000011D0 ; Segment type: Pure code
.text$mn:000011D0 ; Segment permissions: Read/Execute
.text$mn:000011D0 _text$mn        segment para public 'CODE' use32
.text$mn:000011D0                 assume cs:_text$mn
.text$mn:000011D0                 ;org 11D0h
.text$mn:000011D0 ; COMDAT (pick any)
.text$mn:000011D0                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text$mn:000011D0
.text$mn:000011D0 ; =============== S U B R O U T I N E =======================================
.text$mn:000011D0
.text$mn:000011D0 ; Attributes: bp-based frame
.text$mn:000011D0
.text$mn:000011D0 ; public: char * __thiscall std::_String_val<struct std::_Simple_types<char>>::_Myptr(void)
.text$mn:000011D0                 public ?_Myptr@?$_String_val@U?$_Simple_types@D@std@@@std@@QAEPADXZ
.text$mn:000011D0 ?_Myptr@?$_String_val@U?$_Simple_types@D@std@@@std@@QAEPADXZ proc near
.text$mn:000011D0                                         ; CODE XREF: $LN19+14p
.text$mn:000011D0                                         ; std::basic_string<char,std::char_traits<char>,std::allocator<char>>::_Eos(uint)+1Dp ...
.text$mn:000011D0
.text$mn:000011D0 var_8           = dword ptr -8
.text$mn:000011D0 var_4           = dword ptr -4
.text$mn:000011D0
.text$mn:000011D0                 push    ebp
.text$mn:000011D1                 mov     ebp, esp
.text$mn:000011D3                 sub     esp, 8
.text$mn:000011D6                 mov     [ebp+var_4], ecx
.text$mn:000011D9                 mov     eax, [ebp+var_4]
.text$mn:000011DC                 cmp     dword ptr [eax+18h], 10h
.text$mn:000011E0                 jb      short loc_11F6
.text$mn:000011E2                 mov     ecx, [ebp+var_4]
.text$mn:000011E5                 mov     edx, [ecx+4]
.text$mn:000011E8                 push    edx
.text$mn:000011E9                 call    ??$addressof@D@std@@YAPADAAD@Z ; std::addressof<char>(char &)
.text$mn:000011EE                 add     esp, 4
.text$mn:000011F1                 mov     [ebp+var_8], eax
.text$mn:000011F4                 jmp     short loc_11FF
.text$mn:000011F6 ; ---------------------------------------------------------------------------
.text$mn:000011F6
.text$mn:000011F6 loc_11F6:                               ; CODE XREF: std::_String_val<std::_Simple_types<char>>::_Myptr(void)+10j
.text$mn:000011F6                 mov     eax, [ebp+var_4]
.text$mn:000011F9                 add     eax, 4
.text$mn:000011FC                 mov     [ebp+var_8], eax
.text$mn:000011FF
.text$mn:000011FF loc_11FF:                               ; CODE XREF: std::_String_val<std::_Simple_types<char>>::_Myptr(void)+24j
.text$mn:000011FF                 mov     eax, [ebp+var_8]
.text$mn:00001202                 mov     esp, ebp
.text$mn:00001204                 pop     ebp
.text$mn:00001205                 retn
.text$mn:00001205 ?_Myptr@?$_String_val@U?$_Simple_types@D@std@@@std@@QAEPADXZ endp
.text$mn:00001205
.text$mn:00001205 ; ---------------------------------------------------------------------------
.text$mn:00001206                 align 4
.text$mn:00001206 _text$mn        ends
.text$mn:00001206
.text$mn:00001208 ; ===========================================================================
.text$mn:00001208
.text$mn:00001208 ; Segment type: Pure code
.text$mn:00001208 ; Segment permissions: Read/Execute
.text$mn:00001208 _text$mn        segment para public 'CODE' use32
.text$mn:00001208                 assume cs:_text$mn
.text$mn:00001208                 ;org 1208h
.text$mn:00001208 ; COMDAT (pick any)
.text$mn:00001208                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text$mn:00001208
.text$mn:00001208 ; =============== S U B R O U T I N E =======================================
.text$mn:00001208
.text$mn:00001208 ; Attributes: bp-based frame
.text$mn:00001208
.text$mn:00001208 ; public: char const * __thiscall std::_String_val<struct std::_Simple_types<char>>::_Myptr(void)const
.text$mn:00001208                 public ?_Myptr@?$_String_val@U?$_Simple_types@D@std@@@std@@QBEPBDXZ
.text$mn:00001208 ?_Myptr@?$_String_val@U?$_Simple_types@D@std@@@std@@QBEPBDXZ proc near
.text$mn:00001208                                         ; CODE XREF: std::basic_string<char,std::char_traits<char>,std::allocator<char>>::assign(std::basic_string<char,std::char_traits<char>,std::allocator<char>> const &,uint,uint)+7Dp
.text$mn:00001208
.text$mn:00001208 var_8           = dword ptr -8
.text$mn:00001208 var_4           = dword ptr -4
.text$mn:00001208
.text$mn:00001208                 push    ebp
.text$mn:00001209                 mov     ebp, esp
.text$mn:0000120B                 sub     esp, 8
.text$mn:0000120E                 mov     [ebp+var_4], ecx
.text$mn:00001211                 mov     eax, [ebp+var_4]
.text$mn:00001214                 cmp     dword ptr [eax+18h], 10h
.text$mn:00001218                 jb      short loc_122E
.text$mn:0000121A                 mov     ecx, [ebp+var_4]
.text$mn:0000121D                 mov     edx, [ecx+4]
.text$mn:00001220                 push    edx
.text$mn:00001221                 call    ??$addressof@D@std@@YAPADAAD@Z ; std::addressof<char>(char &)
.text$mn:00001226                 add     esp, 4
.text$mn:00001229                 mov     [ebp+var_8], eax
.text$mn:0000122C                 jmp     short loc_1237
.text$mn:0000122E ; ---------------------------------------------------------------------------
.text$mn:0000122E
.text$mn:0000122E loc_122E:                               ; CODE XREF: std::_String_val<std::_Simple_types<char>>::_Myptr(void)+10j
.text$mn:0000122E                 mov     eax, [ebp+var_4]
.text$mn:00001231                 add     eax, 4
.text$mn:00001234                 mov     [ebp+var_8], eax
.text$mn:00001237
.text$mn:00001237 loc_1237:                               ; CODE XREF: std::_String_val<std::_Simple_types<char>>::_Myptr(void)+24j
.text$mn:00001237                 mov     eax, [ebp+var_8]
.text$mn:0000123A                 mov     esp, ebp
.text$mn:0000123C                 pop     ebp
.text$mn:0000123D                 retn
.text$mn:0000123D ?_Myptr@?$_String_val@U?$_Simple_types@D@std@@@std@@QBEPBDXZ endp
.text$mn:0000123D
.text$mn:0000123D ; ---------------------------------------------------------------------------
.text$mn:0000123E                 align 10h
.text$mn:0000123E _text$mn        ends
.text$mn:0000123E
.text$mn:00001240 ; ===========================================================================
.text$mn:00001240
.text$mn:00001240 ; Segment type: Pure code
.text$mn:00001240 ; Segment permissions: Read/Execute
.text$mn:00001240 _text$mn        segment para public 'CODE' use32
.text$mn:00001240                 assume cs:_text$mn
.text$mn:00001240                 ;org 1240h
.text$mn:00001240 ; COMDAT (pick any)
.text$mn:00001240                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text$mn:00001240
.text$mn:00001240 ; =============== S U B R O U T I N E =======================================
.text$mn:00001240
.text$mn:00001240 ; Attributes: bp-based frame
.text$mn:00001240
.text$mn:00001240 ; void __thiscall std::_Container_base12::_Orphan_all(std::_Container_base12 *__hidden this)
.text$mn:00001240                 public ?_Orphan_all@_Container_base12@std@@QAEXXZ
.text$mn:00001240 ?_Orphan_all@_Container_base12@std@@QAEXXZ proc near
.text$mn:00001240                                         ; CODE XREF: std::_Container_base12::~_Container_base12(void)+Ap
.text$mn:00001240                                         ; std::_String_alloc<0,std::_String_base_types<char,std::allocator<char>>>::_Free_proxy(void)+14p
.text$mn:00001240
.text$mn:00001240 var_18          = byte ptr -18h
.text$mn:00001240 var_14          = dword ptr -14h
.text$mn:00001240 var_10          = dword ptr -10h
.text$mn:00001240 var_C           = dword ptr -0Ch
.text$mn:00001240 var_4           = dword ptr -4
.text$mn:00001240
.text$mn:00001240                 push    ebp
.text$mn:00001241                 mov     ebp, esp
.text$mn:00001243                 push    0FFFFFFFFh
.text$mn:00001245                 push    offset __ehhandler$?_Orphan_all@_Container_base12@std@@QAEXXZ
.text$mn:0000124A                 mov     eax, large fs:0
.text$mn:00001250                 push    eax
.text$mn:00001251                 sub     esp, 0Ch
.text$mn:00001254                 mov     eax, dword ptr ds:___security_cookie
.text$mn:00001259                 xor     eax, ebp
.text$mn:0000125B                 push    eax
.text$mn:0000125C                 lea     eax, [ebp+var_C]
.text$mn:0000125F                 mov     large fs:0, eax
.text$mn:00001265                 mov     [ebp+var_14], ecx
.text$mn:00001268                 mov     eax, [ebp+var_14]
.text$mn:0000126B                 cmp     dword ptr [eax], 0
.text$mn:0000126E                 jz      short loc_12CB
.text$mn:00001270                 push    3               ; int
.text$mn:00001272                 lea     ecx, [ebp+var_18] ; this
.text$mn:00001275                 call    ??0_Lockit@std@@QAE@H@Z ; std::_Lockit::_Lockit(int)
.text$mn:0000127A                 mov     [ebp+var_4], 0
.text$mn:00001281                 mov     ecx, [ebp+var_14]
.text$mn:00001284                 mov     edx, [ecx]
.text$mn:00001286                 add     edx, 4
.text$mn:00001289                 mov     [ebp+var_10], edx
.text$mn:0000128C                 jmp     short loc_129B
.text$mn:0000128E ; ---------------------------------------------------------------------------
.text$mn:0000128E
.text$mn:0000128E loc_128E:                               ; CODE XREF: std::_Container_base12::_Orphan_all(void)+6Ej
.text$mn:0000128E                 mov     eax, [ebp+var_10]
.text$mn:00001291                 mov     ecx, [eax]
.text$mn:00001293                 mov     edx, [ebp+var_10]
.text$mn:00001296                 mov     eax, [ecx+4]
.text$mn:00001299                 mov     [edx], eax
.text$mn:0000129B
.text$mn:0000129B loc_129B:                               ; CODE XREF: std::_Container_base12::_Orphan_all(void)+4Cj
.text$mn:0000129B                 mov     ecx, [ebp+var_10]
.text$mn:0000129E                 cmp     dword ptr [ecx], 0
.text$mn:000012A1                 jz      short loc_12B0
.text$mn:000012A3                 mov     edx, [ebp+var_10]
.text$mn:000012A6                 mov     eax, [edx]
.text$mn:000012A8                 mov     dword ptr [eax], 0
.text$mn:000012AE                 jmp     short loc_128E
.text$mn:000012B0 ; ---------------------------------------------------------------------------
.text$mn:000012B0
.text$mn:000012B0 loc_12B0:                               ; CODE XREF: std::_Container_base12::_Orphan_all(void)+61j
.text$mn:000012B0                 mov     ecx, [ebp+var_14]
.text$mn:000012B3                 mov     edx, [ecx]
.text$mn:000012B5                 mov     dword ptr [edx+4], 0
.text$mn:000012BC                 mov     [ebp+var_4], 0FFFFFFFFh
.text$mn:000012C3                 lea     ecx, [ebp+var_18] ; this
.text$mn:000012C6                 call    ??1_Lockit@std@@QAE@XZ ; std::_Lockit::~_Lockit(void)
.text$mn:000012CB
.text$mn:000012CB loc_12CB:                               ; CODE XREF: std::_Container_base12::_Orphan_all(void)+2Ej
.text$mn:000012CB                 mov     ecx, [ebp+var_C]
.text$mn:000012CE                 mov     large fs:0, ecx
.text$mn:000012D5                 pop     ecx
.text$mn:000012D6                 mov     esp, ebp
.text$mn:000012D8                 pop     ebp
.text$mn:000012D9                 retn
.text$mn:000012D9 ?_Orphan_all@_Container_base12@std@@QAEXXZ endp
.text$mn:000012D9
.text$mn:000012D9 ; ---------------------------------------------------------------------------
.text$mn:000012DA                 align 4
.text$mn:000012DA _text$mn        ends
.text$mn:000012DA
.text$x:000012DC ; ===========================================================================
.text$x:000012DC
.text$x:000012DC ; Segment type: Pure code
.text$x:000012DC ; Segment permissions: Read/Execute
.text$x:000012DC _text$x         segment para public 'CODE' use32
.text$x:000012DC                 assume cs:_text$x
.text$x:000012DC                 ;org 12DCh
.text$x:000012DC ; COMDAT (pick associative to section at 1240)
.text$x:000012DC                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text$x:000012DC
.text$x:000012DC ; =============== S U B R O U T I N E =======================================
.text$x:000012DC
.text$x:000012DC
.text$x:000012DC __unwindfunclet$?_Orphan_all@_Container_base12@std@@QAEXXZ$0 proc near
.text$x:000012DC                                         ; DATA XREF: .xdata$x:00001BBCo
.text$x:000012DC                 lea     ecx, [ebp-18h]  ; this
.text$x:000012DF                 jmp     ??1_Lockit@std@@QAE@XZ ; std::_Lockit::~_Lockit(void)
.text$x:000012DF __unwindfunclet$?_Orphan_all@_Container_base12@std@@QAEXXZ$0 endp
.text$x:000012DF
.text$x:000012E4
.text$x:000012E4 ; =============== S U B R O U T I N E =======================================
.text$x:000012E4
.text$x:000012E4
.text$x:000012E4 __ehhandler$?_Orphan_all@_Container_base12@std@@QAEXXZ proc near
.text$x:000012E4                                         ; DATA XREF: std::_Container_base12::_Orphan_all(void)+5o
.text$x:000012E4
.text$x:000012E4 arg_4           = dword ptr  8
.text$x:000012E4
.text$x:000012E4                 mov     edx, [esp+arg_4]
.text$x:000012E8                 lea     eax, [edx+0Ch]
.text$x:000012EB                 mov     ecx, [edx-10h]
.text$x:000012EE                 xor     ecx, eax
.text$x:000012F0                 call    @__security_check_cookie@4 ; __security_check_cookie(x)
.text$x:000012F5                 mov     eax, offset __ehfuncinfo$?_Orphan_all@_Container_base12@std@@QAEXXZ
.text$x:000012FA                 jmp     ___CxxFrameHandler3
.text$x:000012FA __ehhandler$?_Orphan_all@_Container_base12@std@@QAEXXZ endp
.text$x:000012FA
.text$x:000012FA ; ---------------------------------------------------------------------------
.text$x:000012FF                 align 10h
.text$x:000012FF _text$x         ends
.text$x:000012FF
.text$mn:00001300 ; ===========================================================================
.text$mn:00001300
.text$mn:00001300 ; Segment type: Pure code
.text$mn:00001300 ; Segment permissions: Read/Execute
.text$mn:00001300 _text$mn        segment para public 'CODE' use32
.text$mn:00001300                 assume cs:_text$mn
.text$mn:00001300                 ;org 1300h
.text$mn:00001300 ; COMDAT (pick any)
.text$mn:00001300                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text$mn:00001300
.text$mn:00001300 ; =============== S U B R O U T I N E =======================================
.text$mn:00001300
.text$mn:00001300 ; Attributes: bp-based frame
.text$mn:00001300
.text$mn:00001300 ; int __stdcall std::basic_string<char,std::char_traits<char>,std::allocator<char>>::_Tidy(char, size_t Size)
.text$mn:00001300                 public ?_Tidy@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEX_NI@Z
.text$mn:00001300 ?_Tidy@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEX_NI@Z proc near
.text$mn:00001300                                         ; CODE XREF: std::basic_string<char,std::char_traits<char>,std::allocator<char>>::basic_string<char,std::char_traits<char>,std::allocator<char>>(char const *)+47p
.text$mn:00001300                                         ; std::basic_string<char,std::char_traits<char>,std::allocator<char>>::~basic_string<char,std::char_traits<char>,std::allocator<char>>(void)+34p ...
.text$mn:00001300
.text$mn:00001300 var_C           = dword ptr -0Ch
.text$mn:00001300 var_8           = dword ptr -8
.text$mn:00001300 var_2           = byte ptr -2
.text$mn:00001300 var_1           = byte ptr -1
.text$mn:00001300 arg_0           = byte ptr  8
.text$mn:00001300 Size            = dword ptr  0Ch
.text$mn:00001300
.text$mn:00001300                 push    ebp
.text$mn:00001301                 mov     ebp, esp
.text$mn:00001303                 sub     esp, 0Ch
.text$mn:00001306                 mov     [ebp+var_8], ecx
.text$mn:00001309                 movzx   eax, [ebp+arg_0]
.text$mn:0000130D                 test    eax, eax
.text$mn:0000130F                 jnz     short loc_1313
.text$mn:00001311                 jmp     short loc_1386
.text$mn:00001313 ; ---------------------------------------------------------------------------
.text$mn:00001313
.text$mn:00001313 loc_1313:                               ; CODE XREF: std::basic_string<char,std::char_traits<char>,std::allocator<char>>::_Tidy(bool,uint)+Fj
.text$mn:00001313                 mov     ecx, [ebp+var_8]
.text$mn:00001316                 cmp     dword ptr [ecx+18h], 10h
.text$mn:0000131A                 jb      short loc_1386
.text$mn:0000131C                 mov     edx, [ebp+var_8]
.text$mn:0000131F                 mov     eax, [edx+4]
.text$mn:00001322                 mov     [ebp+var_C], eax
.text$mn:00001325                 mov     ecx, [ebp+var_8]
.text$mn:00001328                 add     ecx, 4
.text$mn:0000132B                 push    ecx
.text$mn:0000132C                 lea     edx, [ebp+var_1]
.text$mn:0000132F                 push    edx
.text$mn:00001330                 mov     ecx, [ebp+var_8]
.text$mn:00001333                 call    ?_Getal@?$_String_alloc@$0A@U?$_String_base_types@DV?$allocator@D@std@@@std@@@std@@QBE?AU?$_Wrap_alloc@V?$allocator@D@std@@@2@XZ ; std::_String_alloc<0,std::_String_base_types<char,std::allocator<char>>>::_Getal(void)
.text$mn:00001338                 mov     ecx, eax
.text$mn:0000133A                 call    ??$destroy@PAD@?$_Wrap_alloc@V?$allocator@D@std@@@std@@QAEXPAPAD@Z ; std::_Wrap_alloc<std::allocator<char>>::destroy<char *>(char * *)
.text$mn:0000133F                 cmp     [ebp+Size], 0
.text$mn:00001343                 jbe     short loc_1365
.text$mn:00001345                 mov     eax, [ebp+Size]
.text$mn:00001348                 push    eax             ; Size
.text$mn:00001349                 mov     ecx, [ebp+var_C]
.text$mn:0000134C                 push    ecx
.text$mn:0000134D                 call    ??$addressof@D@std@@YAPADAAD@Z ; std::addressof<char>(char &)
.text$mn:00001352                 add     esp, 4
.text$mn:00001355                 push    eax             ; Src
.text$mn:00001356                 mov     edx, [ebp+var_8]
.text$mn:00001359                 add     edx, 4
.text$mn:0000135C                 push    edx             ; Dst
.text$mn:0000135D                 call    ?copy@?$char_traits@D@std@@SAPADPADPBDI@Z ; std::char_traits<char>::copy(char *,char const *,uint)
.text$mn:00001362                 add     esp, 0Ch
.text$mn:00001365
.text$mn:00001365 loc_1365:                               ; CODE XREF: std::basic_string<char,std::char_traits<char>,std::allocator<char>>::_Tidy(bool,uint)+43j
.text$mn:00001365                 mov     eax, [ebp+var_8]
.text$mn:00001368                 mov     ecx, [eax+18h]
.text$mn:0000136B                 add     ecx, 1
.text$mn:0000136E                 push    ecx             ; int
.text$mn:0000136F                 mov     edx, [ebp+var_C]
.text$mn:00001372                 push    edx             ; void *
.text$mn:00001373                 lea     eax, [ebp+var_2]
.text$mn:00001376                 push    eax
.text$mn:00001377                 mov     ecx, [ebp+var_8]
.text$mn:0000137A                 call    ?_Getal@?$_String_alloc@$0A@U?$_String_base_types@DV?$allocator@D@std@@@std@@@std@@QBE?AU?$_Wrap_alloc@V?$allocator@D@std@@@2@XZ ; std::_String_alloc<0,std::_String_base_types<char,std::allocator<char>>>::_Getal(void)
.text$mn:0000137F                 mov     ecx, eax
.text$mn:00001381                 call    ?deallocate@?$_Wrap_alloc@V?$allocator@D@std@@@std@@QAEXPADI@Z ; std::_Wrap_alloc<std::allocator<char>>::deallocate(char *,uint)
.text$mn:00001386
.text$mn:00001386 loc_1386:                               ; CODE XREF: std::basic_string<char,std::char_traits<char>,std::allocator<char>>::_Tidy(bool,uint)+11j
.text$mn:00001386                                         ; std::basic_string<char,std::char_traits<char>,std::allocator<char>>::_Tidy(bool,uint)+1Aj
.text$mn:00001386                 mov     ecx, [ebp+var_8]
.text$mn:00001389                 mov     dword ptr [ecx+18h], 0Fh
.text$mn:00001390                 mov     edx, [ebp+Size]
.text$mn:00001393                 push    edx
.text$mn:00001394                 mov     ecx, [ebp+var_8]
.text$mn:00001397                 call    ?_Eos@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEXI@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char>>::_Eos(uint)
.text$mn:0000139C                 mov     esp, ebp
.text$mn:0000139E                 pop     ebp
.text$mn:0000139F                 retn    8
.text$mn:0000139F ?_Tidy@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEX_NI@Z endp
.text$mn:0000139F
.text$mn:0000139F ; ---------------------------------------------------------------------------
.text$mn:000013A2                 align 4
.text$mn:000013A2 _text$mn        ends
.text$mn:000013A2
.text$mn:000013A4 ; ===========================================================================
.text$mn:000013A4
.text$mn:000013A4 ; Segment type: Pure code
.text$mn:000013A4 ; Segment permissions: Read/Execute
.text$mn:000013A4 _text$mn        segment para public 'CODE' use32
.text$mn:000013A4                 assume cs:_text$mn
.text$mn:000013A4                 ;org 13A4h
.text$mn:000013A4 ; COMDAT (pick any)
.text$mn:000013A4                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text$mn:000013A4
.text$mn:000013A4 ; =============== S U B R O U T I N E =======================================
.text$mn:000013A4
.text$mn:000013A4 ; Attributes: bp-based frame
.text$mn:000013A4
.text$mn:000013A4 ; public: void __thiscall std::basic_string<char, struct std::char_traits<char>, class std::allocator<char>>::_Xlen(void)const
.text$mn:000013A4                 public ?_Xlen@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QBEXXZ
.text$mn:000013A4 ?_Xlen@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QBEXXZ proc near
.text$mn:000013A4                                         ; CODE XREF: std::basic_string<char,std::char_traits<char>,std::allocator<char>>::_Grow(uint,bool)+19p
.text$mn:000013A4
.text$mn:000013A4 var_4           = dword ptr -4
.text$mn:000013A4
.text$mn:000013A4                 push    ebp
.text$mn:000013A5                 mov     ebp, esp
.text$mn:000013A7                 push    ecx
.text$mn:000013A8                 mov     [ebp+var_4], ecx
.text$mn:000013AB                 push    offset ??_C@_0BA@JFNIOLAK@string?5too?5long?$AA@ ; "string too long"
.text$mn:000013B0                 call    ?_Xlength_error@std@@YAXPBD@Z ; std::_Xlength_error(char const *)
.text$mn:000013B5                 mov     esp, ebp
.text$mn:000013B7                 pop     ebp
.text$mn:000013B8                 retn
.text$mn:000013B8 ?_Xlen@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QBEXXZ endp
.text$mn:000013B8
.text$mn:000013B8 ; ---------------------------------------------------------------------------
.text$mn:000013B9                 align 4
.text$mn:000013B9 _text$mn        ends
.text$mn:000013B9
.text$mn:000013BC ; ===========================================================================
.text$mn:000013BC
.text$mn:000013BC ; Segment type: Pure code
.text$mn:000013BC ; Segment permissions: Read/Execute
.text$mn:000013BC _text$mn        segment para public 'CODE' use32
.text$mn:000013BC                 assume cs:_text$mn
.text$mn:000013BC                 ;org 13BCh
.text$mn:000013BC ; COMDAT (pick any)
.text$mn:000013BC                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text$mn:000013BC
.text$mn:000013BC ; =============== S U B R O U T I N E =======================================
.text$mn:000013BC
.text$mn:000013BC ; Attributes: bp-based frame
.text$mn:000013BC
.text$mn:000013BC ; public: void __thiscall std::basic_string<char, struct std::char_traits<char>, class std::allocator<char>>::_Xran(void)const
.text$mn:000013BC                 public ?_Xran@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QBEXXZ
.text$mn:000013BC ?_Xran@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QBEXXZ proc near
.text$mn:000013BC                                         ; CODE XREF: std::basic_string<char,std::char_traits<char>,std::allocator<char>>::assign(std::basic_string<char,std::char_traits<char>,std::allocator<char>> const &,uint,uint)+19p
.text$mn:000013BC                                         ; std::basic_string<char,std::char_traits<char>,std::allocator<char>>::erase(uint)+15p ...
.text$mn:000013BC
.text$mn:000013BC var_4           = dword ptr -4
.text$mn:000013BC
.text$mn:000013BC                 push    ebp
.text$mn:000013BD                 mov     ebp, esp
.text$mn:000013BF                 push    ecx
.text$mn:000013C0                 mov     [ebp+var_4], ecx
.text$mn:000013C3                 push    offset ??_C@_0BI@CFPLBAOH@invalid?5string?5position?$AA@ ; "invalid string position"
.text$mn:000013C8                 call    ?_Xout_of_range@std@@YAXPBD@Z ; std::_Xout_of_range(char const *)
.text$mn:000013CD                 mov     esp, ebp
.text$mn:000013CF                 pop     ebp
.text$mn:000013D0                 retn
.text$mn:000013D0 ?_Xran@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QBEXXZ endp
.text$mn:000013D0
.text$mn:000013D0 ; ---------------------------------------------------------------------------
.text$mn:000013D1                 align 4
.text$mn:000013D1 _text$mn        ends
.text$mn:000013D1
.text$mn:000013D4 ; ===========================================================================
.text$mn:000013D4
.text$mn:000013D4 ; Segment type: Pure code
.text$mn:000013D4 ; Segment permissions: Read/Execute
.text$mn:000013D4 _text$mn        segment para public 'CODE' use32
.text$mn:000013D4                 assume cs:_text$mn
.text$mn:000013D4                 ;org 13D4h
.text$mn:000013D4 ; COMDAT (pick any)
.text$mn:000013D4                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text$mn:000013D4
.text$mn:000013D4 ; =============== S U B R O U T I N E =======================================
.text$mn:000013D4
.text$mn:000013D4 ; Attributes: bp-based frame
.text$mn:000013D4
.text$mn:000013D4 ; public: char * __thiscall std::_Wrap_alloc<class std::allocator<char>>::allocate(unsigned int)
.text$mn:000013D4                 public ?allocate@?$_Wrap_alloc@V?$allocator@D@std@@@std@@QAEPADI@Z
.text$mn:000013D4 ?allocate@?$_Wrap_alloc@V?$allocator@D@std@@@std@@QAEPADI@Z proc near
.text$mn:000013D4                                         ; CODE XREF: std::basic_string<char,std::char_traits<char>,std::allocator<char>>::_Copy(uint,uint)+BBp
.text$mn:000013D4                                         ; __catch$?_Copy@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEXII@Z$0+22p
.text$mn:000013D4
.text$mn:000013D4 var_4           = dword ptr -4
.text$mn:000013D4 arg_0           = dword ptr  8
.text$mn:000013D4
.text$mn:000013D4                 push    ebp
.text$mn:000013D5                 mov     ebp, esp
.text$mn:000013D7                 push    ecx
.text$mn:000013D8                 mov     [ebp+var_4], ecx
.text$mn:000013DB                 mov     eax, [ebp+arg_0]
.text$mn:000013DE                 push    eax
.text$mn:000013DF                 mov     ecx, [ebp+var_4]
.text$mn:000013E2                 call    ?allocate@?$allocator@D@std@@QAEPADI@Z ; std::allocator<char>::allocate(uint)
.text$mn:000013E7                 mov     esp, ebp
.text$mn:000013E9                 pop     ebp
.text$mn:000013EA                 retn    4
.text$mn:000013EA ?allocate@?$_Wrap_alloc@V?$allocator@D@std@@@std@@QAEPADI@Z endp
.text$mn:000013EA
.text$mn:000013EA ; ---------------------------------------------------------------------------
.text$mn:000013ED                 align 10h
.text$mn:000013ED _text$mn        ends
.text$mn:000013ED
.text$mn:000013F0 ; ===========================================================================
.text$mn:000013F0
.text$mn:000013F0 ; Segment type: Pure code
.text$mn:000013F0 ; Segment permissions: Read/Execute
.text$mn:000013F0 _text$mn        segment para public 'CODE' use32
.text$mn:000013F0                 assume cs:_text$mn
.text$mn:000013F0                 ;org 13F0h
.text$mn:000013F0 ; COMDAT (pick any)
.text$mn:000013F0                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text$mn:000013F0
.text$mn:000013F0 ; =============== S U B R O U T I N E =======================================
.text$mn:000013F0
.text$mn:000013F0 ; Attributes: bp-based frame
.text$mn:000013F0
.text$mn:000013F0 ; public: char * __thiscall std::allocator<char>::allocate(unsigned int)
.text$mn:000013F0                 public ?allocate@?$allocator@D@std@@QAEPADI@Z
.text$mn:000013F0 ?allocate@?$allocator@D@std@@QAEPADI@Z proc near
.text$mn:000013F0                                         ; CODE XREF: std::_Wrap_alloc<std::allocator<char>>::allocate(uint)+Ep
.text$mn:000013F0
.text$mn:000013F0 var_4           = dword ptr -4
.text$mn:000013F0 arg_0           = dword ptr  8
.text$mn:000013F0
.text$mn:000013F0                 push    ebp
.text$mn:000013F1                 mov     ebp, esp
.text$mn:000013F3                 push    ecx
.text$mn:000013F4                 mov     [ebp+var_4], ecx
.text$mn:000013F7                 push    0
.text$mn:000013F9                 mov     eax, [ebp+arg_0]
.text$mn:000013FC                 push    eax
.text$mn:000013FD                 call    ??$_Allocate@D@std@@YAPADIPAD@Z ; std::_Allocate<char>(uint,char *)
.text$mn:00001402                 add     esp, 8
.text$mn:00001405                 mov     esp, ebp
.text$mn:00001407                 pop     ebp
.text$mn:00001408                 retn    4
.text$mn:00001408 ?allocate@?$allocator@D@std@@QAEPADI@Z endp
.text$mn:00001408
.text$mn:00001408 ; ---------------------------------------------------------------------------
.text$mn:0000140B                 align 4
.text$mn:0000140B _text$mn        ends
.text$mn:0000140B
.text$mn:0000140C ; ===========================================================================
.text$mn:0000140C
.text$mn:0000140C ; Segment type: Pure code
.text$mn:0000140C ; Segment permissions: Read/Execute
.text$mn:0000140C _text$mn        segment para public 'CODE' use32
.text$mn:0000140C                 assume cs:_text$mn
.text$mn:0000140C                 ;org 140Ch
.text$mn:0000140C ; COMDAT (pick any)
.text$mn:0000140C                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text$mn:0000140C
.text$mn:0000140C ; =============== S U B R O U T I N E =======================================
.text$mn:0000140C
.text$mn:0000140C ; Attributes: bp-based frame
.text$mn:0000140C
.text$mn:0000140C ; public: struct std::_Container_proxy * __thiscall std::allocator<struct std::_Container_proxy>::allocate(unsigned int)
.text$mn:0000140C                 public ?allocate@?$allocator@U_Container_proxy@std@@@std@@QAEPAU_Container_proxy@2@I@Z
.text$mn:0000140C ?allocate@?$allocator@U_Container_proxy@std@@@std@@QAEPAU_Container_proxy@2@I@Z proc near
.text$mn:0000140C                                         ; CODE XREF: std::_String_alloc<0,std::_String_base_types<char,std::allocator<char>>>::_Alloc_proxy(void)+16p
.text$mn:0000140C
.text$mn:0000140C var_4           = dword ptr -4
.text$mn:0000140C arg_0           = dword ptr  8
.text$mn:0000140C
.text$mn:0000140C                 push    ebp
.text$mn:0000140D                 mov     ebp, esp
.text$mn:0000140F                 push    ecx
.text$mn:00001410                 mov     [ebp+var_4], ecx
.text$mn:00001413                 push    0
.text$mn:00001415                 mov     eax, [ebp+arg_0]
.text$mn:00001418                 push    eax
.text$mn:00001419                 call    ??$_Allocate@U_Container_proxy@std@@@std@@YAPAU_Container_proxy@0@IPAU10@@Z ; std::_Allocate<std::_Container_proxy>(uint,std::_Container_proxy *)
.text$mn:0000141E                 add     esp, 8
.text$mn:00001421                 mov     esp, ebp
.text$mn:00001423                 pop     ebp
.text$mn:00001424                 retn    4
.text$mn:00001424 ?allocate@?$allocator@U_Container_proxy@std@@@std@@QAEPAU_Container_proxy@2@I@Z endp
.text$mn:00001424
.text$mn:00001424 ; ---------------------------------------------------------------------------
.text$mn:00001427                 align 4
.text$mn:00001427 _text$mn        ends
.text$mn:00001427
.text$mn:00001428 ; ===========================================================================
.text$mn:00001428
.text$mn:00001428 ; Segment type: Pure code
.text$mn:00001428 ; Segment permissions: Read/Execute
.text$mn:00001428 _text$mn        segment para public 'CODE' use32
.text$mn:00001428                 assume cs:_text$mn
.text$mn:00001428                 ;org 1428h
.text$mn:00001428 ; COMDAT (pick any)
.text$mn:00001428                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text$mn:00001428
.text$mn:00001428 ; =============== S U B R O U T I N E =======================================
.text$mn:00001428
.text$mn:00001428 ; Attributes: bp-based frame
.text$mn:00001428
.text$mn:00001428 ; public: class std::basic_string<char, struct std::char_traits<char>, class std::allocator<char>> & __thiscall std::basic_string<char, struct std::char_traits<char>, class std::allocator<char>>::assign(class std::basic_string<char, struct std::char_traits<char>, class std::allocator<char>> const &, unsigned int, unsigned int)
.text$mn:00001428                 public ?assign@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV12@ABV12@II@Z
.text$mn:00001428 ?assign@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV12@ABV12@II@Z proc near
.text$mn:00001428                                         ; CODE XREF: std::basic_string<char,std::char_traits<char>,std::allocator<char>>::assign(char const *,uint)+4Fp
.text$mn:00001428
.text$mn:00001428 Size            = dword ptr -8
.text$mn:00001428 var_4           = dword ptr -4
.text$mn:00001428 arg_0           = dword ptr  8
.text$mn:00001428 arg_4           = dword ptr  0Ch
.text$mn:00001428 arg_8           = dword ptr  10h
.text$mn:00001428
.text$mn:00001428                 push    ebp
.text$mn:00001429                 mov     ebp, esp
.text$mn:0000142B                 sub     esp, 8
.text$mn:0000142E                 mov     [ebp+var_4], ecx
.text$mn:00001431                 mov     ecx, [ebp+arg_0]
.text$mn:00001434                 call    ?size@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QBEIXZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char>>::size(void)
.text$mn:00001439                 cmp     eax, [ebp+arg_4]
.text$mn:0000143C                 jnb     short loc_1446
.text$mn:0000143E                 mov     ecx, [ebp+var_4]
.text$mn:00001441                 call    ?_Xran@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QBEXXZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char>>::_Xran(void)
.text$mn:00001446
.text$mn:00001446 loc_1446:                               ; CODE XREF: std::basic_string<char,std::char_traits<char>,std::allocator<char>>::assign(std::basic_string<char,std::char_traits<char>,std::allocator<char>> const &,uint,uint)+14j
.text$mn:00001446                 mov     ecx, [ebp+arg_0]
.text$mn:00001449                 call    ?size@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QBEIXZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char>>::size(void)
.text$mn:0000144E                 sub     eax, [ebp+arg_4]
.text$mn:00001451                 mov     [ebp+Size], eax
.text$mn:00001454                 mov     eax, [ebp+arg_8]
.text$mn:00001457                 cmp     eax, [ebp+Size]
.text$mn:0000145A                 jnb     short loc_1462
.text$mn:0000145C                 mov     ecx, [ebp+arg_8]
.text$mn:0000145F                 mov     [ebp+Size], ecx
.text$mn:00001462
.text$mn:00001462 loc_1462:                               ; CODE XREF: std::basic_string<char,std::char_traits<char>,std::allocator<char>>::assign(std::basic_string<char,std::char_traits<char>,std::allocator<char>> const &,uint,uint)+32j
.text$mn:00001462                 mov     edx, [ebp+var_4]
.text$mn:00001465                 cmp     edx, [ebp+arg_0]
.text$mn:00001468                 jnz     short loc_1489
.text$mn:0000146A                 mov     eax, [ebp+arg_4]
.text$mn:0000146D                 add     eax, [ebp+Size]
.text$mn:00001470                 push    eax
.text$mn:00001471                 mov     ecx, [ebp+var_4]
.text$mn:00001474                 call    ?erase@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV12@I@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char>>::erase(uint)
.text$mn:00001479                 mov     ecx, [ebp+arg_4]
.text$mn:0000147C                 push    ecx
.text$mn:0000147D                 push    0
.text$mn:0000147F                 mov     ecx, [ebp+var_4]
.text$mn:00001482                 call    ?erase@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV12@II@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char>>::erase(uint,uint)
.text$mn:00001487                 jmp     short loc_14CB
.text$mn:00001489 ; ---------------------------------------------------------------------------
.text$mn:00001489
.text$mn:00001489 loc_1489:                               ; CODE XREF: std::basic_string<char,std::char_traits<char>,std::allocator<char>>::assign(std::basic_string<char,std::char_traits<char>,std::allocator<char>> const &,uint,uint)+40j
.text$mn:00001489                 push    0
.text$mn:0000148B                 mov     edx, [ebp+Size]
.text$mn:0000148E                 push    edx
.text$mn:0000148F                 mov     ecx, [ebp+var_4]
.text$mn:00001492                 call    ?_Grow@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE_NI_N@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char>>::_Grow(uint,bool)
.text$mn:00001497                 movzx   eax, al
.text$mn:0000149A                 test    eax, eax
.text$mn:0000149C                 jz      short loc_14CB
.text$mn:0000149E                 mov     ecx, [ebp+Size]
.text$mn:000014A1                 push    ecx             ; Size
.text$mn:000014A2                 mov     ecx, [ebp+arg_0]
.text$mn:000014A5                 call    ?_Myptr@?$_String_val@U?$_Simple_types@D@std@@@std@@QBEPBDXZ ; std::_String_val<std::_Simple_types<char>>::_Myptr(void)
.text$mn:000014AA                 add     eax, [ebp+arg_4]
.text$mn:000014AD                 push    eax             ; Src
.text$mn:000014AE                 mov     ecx, [ebp+var_4]
.text$mn:000014B1                 call    ?_Myptr@?$_String_val@U?$_Simple_types@D@std@@@std@@QAEPADXZ ; std::_String_val<std::_Simple_types<char>>::_Myptr(void)
.text$mn:000014B6                 push    eax             ; Dst
.text$mn:000014B7                 call    ?copy@?$char_traits@D@std@@SAPADPADPBDI@Z ; std::char_traits<char>::copy(char *,char const *,uint)
.text$mn:000014BC                 add     esp, 0Ch
.text$mn:000014BF                 mov     edx, [ebp+Size]
.text$mn:000014C2                 push    edx
.text$mn:000014C3                 mov     ecx, [ebp+var_4]
.text$mn:000014C6                 call    ?_Eos@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEXI@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char>>::_Eos(uint)
.text$mn:000014CB
.text$mn:000014CB loc_14CB:                               ; CODE XREF: std::basic_string<char,std::char_traits<char>,std::allocator<char>>::assign(std::basic_string<char,std::char_traits<char>,std::allocator<char>> const &,uint,uint)+5Fj
.text$mn:000014CB                                         ; std::basic_string<char,std::char_traits<char>,std::allocator<char>>::assign(std::basic_string<char,std::char_traits<char>,std::allocator<char>> const &,uint,uint)+74j
.text$mn:000014CB                 mov     eax, [ebp+var_4]
.text$mn:000014CE                 mov     esp, ebp
.text$mn:000014D0                 pop     ebp
.text$mn:000014D1                 retn    0Ch
.text$mn:000014D1 ?assign@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV12@ABV12@II@Z endp
.text$mn:000014D1
.text$mn:000014D1 _text$mn        ends
.text$mn:000014D1
.text$mn:000014D4 ; ===========================================================================
.text$mn:000014D4
.text$mn:000014D4 ; Segment type: Pure code
.text$mn:000014D4 ; Segment permissions: Read/Execute
.text$mn:000014D4 _text$mn        segment para public 'CODE' use32
.text$mn:000014D4                 assume cs:_text$mn
.text$mn:000014D4                 ;org 14D4h
.text$mn:000014D4 ; COMDAT (pick any)
.text$mn:000014D4                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text$mn:000014D4
.text$mn:000014D4 ; =============== S U B R O U T I N E =======================================
.text$mn:000014D4
.text$mn:000014D4 ; Attributes: bp-based frame
.text$mn:000014D4
.text$mn:000014D4 ; int __stdcall std::basic_string<char,std::char_traits<char>,std::allocator<char>>::assign(char *Str)
.text$mn:000014D4                 public ?assign@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV12@PBD@Z
.text$mn:000014D4 ?assign@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV12@PBD@Z proc near
.text$mn:000014D4                                         ; CODE XREF: std::basic_string<char,std::char_traits<char>,std::allocator<char>>::basic_string<char,std::char_traits<char>,std::allocator<char>>(char const *)+53p
.text$mn:000014D4
.text$mn:000014D4 var_4           = dword ptr -4
.text$mn:000014D4 Str             = dword ptr  8
.text$mn:000014D4
.text$mn:000014D4                 push    ebp
.text$mn:000014D5                 mov     ebp, esp
.text$mn:000014D7                 push    ecx
.text$mn:000014D8                 mov     [ebp+var_4], ecx
.text$mn:000014DB                 push    490h            ; unsigned int
.text$mn:000014E0                 push    offset ??_C@_1IO@FEAPGJBD@?$AAC?$AA?3?$AA?2?$AAP?$AAr?$AAo?$AAg?$AAr?$AAa?$AAm?$AA?5?$AAF?$AAi?$AAl?$AAe?$AAs?$AA?5?$AA?$CI?$AAx?$AA8?$AA6?$AA?$CJ?$AA?2?$AAM?$AAi?$AAc?$AAr?$AAo?$AAs?$AAo?$AAf?$AAt@ ; "C:\\Program Files (x86)\\Microsoft Visu"...
.text$mn:000014E5                 mov     eax, [ebp+Str]
.text$mn:000014E8                 push    eax             ; int
.text$mn:000014E9                 call    ??$_Debug_pointer@D@std@@YAXPBDPB_WI@Z ; std::_Debug_pointer<char>(char const *,wchar_t const *,uint)
.text$mn:000014EE                 add     esp, 0Ch
.text$mn:000014F1                 mov     ecx, [ebp+Str]
.text$mn:000014F4                 push    ecx             ; Str
.text$mn:000014F5                 call    ?length@?$char_traits@D@std@@SAIPBD@Z ; std::char_traits<char>::length(char const *)
.text$mn:000014FA                 add     esp, 4
.text$mn:000014FD                 push    eax             ; Size
.text$mn:000014FE                 mov     edx, [ebp+Str]
.text$mn:00001501                 push    edx             ; Src
.text$mn:00001502                 mov     ecx, [ebp+var_4]
.text$mn:00001505                 call    ?assign@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV12@PBDI@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char>>::assign(char const *,uint)
.text$mn:0000150A                 mov     esp, ebp
.text$mn:0000150C                 pop     ebp
.text$mn:0000150D                 retn    4
.text$mn:0000150D ?assign@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV12@PBD@Z endp
.text$mn:0000150D
.text$mn:0000150D _text$mn        ends
.text$mn:0000150D
.text$mn:00001510 ; ===========================================================================
.text$mn:00001510
.text$mn:00001510 ; Segment type: Pure code
.text$mn:00001510 ; Segment permissions: Read/Execute
.text$mn:00001510 _text$mn        segment para public 'CODE' use32
.text$mn:00001510                 assume cs:_text$mn
.text$mn:00001510                 ;org 1510h
.text$mn:00001510 ; COMDAT (pick any)
.text$mn:00001510                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text$mn:00001510
.text$mn:00001510 ; =============== S U B R O U T I N E =======================================
.text$mn:00001510
.text$mn:00001510 ; Attributes: bp-based frame
.text$mn:00001510
.text$mn:00001510 ; int __stdcall std::basic_string<char,std::char_traits<char>,std::allocator<char>>::assign(void *Src, size_t Size)
.text$mn:00001510                 public ?assign@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV12@PBDI@Z
.text$mn:00001510 ?assign@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV12@PBDI@Z proc near
.text$mn:00001510                                         ; CODE XREF: std::basic_string<char,std::char_traits<char>,std::allocator<char>>::assign(char const *)+31p
.text$mn:00001510
.text$mn:00001510 var_4           = dword ptr -4
.text$mn:00001510 Src             = dword ptr  8
.text$mn:00001510 Size            = dword ptr  0Ch
.text$mn:00001510
.text$mn:00001510                 push    ebp
.text$mn:00001511                 mov     ebp, esp
.text$mn:00001513                 push    ecx
.text$mn:00001514                 mov     [ebp+var_4], ecx
.text$mn:00001517                 cmp     [ebp+Size], 0
.text$mn:0000151B                 jz      short loc_1533
.text$mn:0000151D                 push    47Fh            ; unsigned int
.text$mn:00001522                 push    offset ??_C@_1IO@FEAPGJBD@?$AAC?$AA?3?$AA?2?$AAP?$AAr?$AAo?$AAg?$AAr?$AAa?$AAm?$AA?5?$AAF?$AAi?$AAl?$AAe?$AAs?$AA?5?$AA?$CI?$AAx?$AA8?$AA6?$AA?$CJ?$AA?2?$AAM?$AAi?$AAc?$AAr?$AAo?$AAs?$AAo?$AAf?$AAt@ ; "C:\\Program Files (x86)\\Microsoft Visu"...
.text$mn:00001527                 mov     eax, [ebp+Src]
.text$mn:0000152A                 push    eax             ; int
.text$mn:0000152B                 call    ??$_Debug_pointer@D@std@@YAXPBDPB_WI@Z ; std::_Debug_pointer<char>(char const *,wchar_t const *,uint)
.text$mn:00001530                 add     esp, 0Ch
.text$mn:00001533
.text$mn:00001533 loc_1533:                               ; CODE XREF: std::basic_string<char,std::char_traits<char>,std::allocator<char>>::assign(char const *,uint)+Bj
.text$mn:00001533                 mov     ecx, [ebp+Src]
.text$mn:00001536                 push    ecx
.text$mn:00001537                 mov     ecx, [ebp+var_4]
.text$mn:0000153A                 call    ?_Inside@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE_NPBD@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char>>::_Inside(char const *)
.text$mn:0000153F                 movzx   edx, al
.text$mn:00001542                 test    edx, edx
.text$mn:00001544                 jz      short loc_1566
.text$mn:00001546                 mov     eax, [ebp+Size]
.text$mn:00001549                 push    eax
.text$mn:0000154A                 mov     ecx, [ebp+var_4]
.text$mn:0000154D                 call    ?_Myptr@?$_String_val@U?$_Simple_types@D@std@@@std@@QAEPADXZ ; std::_String_val<std::_Simple_types<char>>::_Myptr(void)
.text$mn:00001552                 mov     ecx, [ebp+Src]
.text$mn:00001555                 sub     ecx, eax
.text$mn:00001557                 push    ecx
.text$mn:00001558                 mov     edx, [ebp+var_4]
.text$mn:0000155B                 push    edx
.text$mn:0000155C                 mov     ecx, [ebp+var_4]
.text$mn:0000155F                 call    ?assign@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV12@ABV12@II@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char>>::assign(std::basic_string<char,std::char_traits<char>,std::allocator<char>> const &,uint,uint)
.text$mn:00001564                 jmp     short loc_15A3
.text$mn:00001566 ; ---------------------------------------------------------------------------
.text$mn:00001566
.text$mn:00001566 loc_1566:                               ; CODE XREF: std::basic_string<char,std::char_traits<char>,std::allocator<char>>::assign(char const *,uint)+34j
.text$mn:00001566                 push    0
.text$mn:00001568                 mov     eax, [ebp+Size]
.text$mn:0000156B                 push    eax
.text$mn:0000156C                 mov     ecx, [ebp+var_4]
.text$mn:0000156F                 call    ?_Grow@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE_NI_N@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char>>::_Grow(uint,bool)
.text$mn:00001574                 movzx   ecx, al
.text$mn:00001577                 test    ecx, ecx
.text$mn:00001579                 jz      short loc_15A0
.text$mn:0000157B                 mov     edx, [ebp+Size]
.text$mn:0000157E                 push    edx             ; Size
.text$mn:0000157F                 mov     eax, [ebp+Src]
.text$mn:00001582                 push    eax             ; Src
.text$mn:00001583                 mov     ecx, [ebp+var_4]
.text$mn:00001586                 call    ?_Myptr@?$_String_val@U?$_Simple_types@D@std@@@std@@QAEPADXZ ; std::_String_val<std::_Simple_types<char>>::_Myptr(void)
.text$mn:0000158B                 push    eax             ; Dst
.text$mn:0000158C                 call    ?copy@?$char_traits@D@std@@SAPADPADPBDI@Z ; std::char_traits<char>::copy(char *,char const *,uint)
.text$mn:00001591                 add     esp, 0Ch
.text$mn:00001594                 mov     ecx, [ebp+Size]
.text$mn:00001597                 push    ecx
.text$mn:00001598                 mov     ecx, [ebp+var_4]
.text$mn:0000159B                 call    ?_Eos@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEXI@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char>>::_Eos(uint)
.text$mn:000015A0
.text$mn:000015A0 loc_15A0:                               ; CODE XREF: std::basic_string<char,std::char_traits<char>,std::allocator<char>>::assign(char const *,uint)+69j
.text$mn:000015A0                 mov     eax, [ebp+var_4]
.text$mn:000015A3
.text$mn:000015A3 loc_15A3:                               ; CODE XREF: std::basic_string<char,std::char_traits<char>,std::allocator<char>>::assign(char const *,uint)+54j
.text$mn:000015A3                 mov     esp, ebp
.text$mn:000015A5                 pop     ebp
.text$mn:000015A6                 retn    8
.text$mn:000015A6 ?assign@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV12@PBDI@Z endp
.text$mn:000015A6
.text$mn:000015A6 ; ---------------------------------------------------------------------------
.text$mn:000015A9                 align 4
.text$mn:000015A9 _text$mn        ends
.text$mn:000015A9
.text$mn:000015AC ; ===========================================================================
.text$mn:000015AC
.text$mn:000015AC ; Segment type: Pure code
.text$mn:000015AC ; Segment permissions: Read/Execute
.text$mn:000015AC _text$mn        segment para public 'CODE' use32
.text$mn:000015AC                 assume cs:_text$mn
.text$mn:000015AC                 ;org 15ACh
.text$mn:000015AC ; COMDAT (pick any)
.text$mn:000015AC                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text$mn:000015AC
.text$mn:000015AC ; =============== S U B R O U T I N E =======================================
.text$mn:000015AC
.text$mn:000015AC ; Attributes: bp-based frame
.text$mn:000015AC
.text$mn:000015AC ; public: static void __cdecl std::char_traits<char>::assign(char &, char const &)
.text$mn:000015AC                 public ?assign@?$char_traits@D@std@@SAXAADABD@Z
.text$mn:000015AC ?assign@?$char_traits@D@std@@SAXAADABD@Z proc near
.text$mn:000015AC                                         ; CODE XREF: std::basic_string<char,std::char_traits<char>,std::allocator<char>>::_Eos(uint)+26p
.text$mn:000015AC
.text$mn:000015AC arg_0           = dword ptr  8
.text$mn:000015AC arg_4           = dword ptr  0Ch
.text$mn:000015AC
.text$mn:000015AC                 push    ebp
.text$mn:000015AD                 mov     ebp, esp
.text$mn:000015AF                 mov     eax, [ebp+arg_0]
.text$mn:000015B2                 mov     ecx, [ebp+arg_4]
.text$mn:000015B5                 mov     dl, [ecx]
.text$mn:000015B7                 mov     [eax], dl
.text$mn:000015B9                 pop     ebp
.text$mn:000015BA                 retn
.text$mn:000015BA ?assign@?$char_traits@D@std@@SAXAADABD@Z endp
.text$mn:000015BA
.text$mn:000015BA ; ---------------------------------------------------------------------------
.text$mn:000015BB                 align 4
.text$mn:000015BB _text$mn        ends
.text$mn:000015BB
.text$mn:000015BC ; ===========================================================================
.text$mn:000015BC
.text$mn:000015BC ; Segment type: Pure code
.text$mn:000015BC ; Segment permissions: Read/Execute
.text$mn:000015BC _text$mn        segment para public 'CODE' use32
.text$mn:000015BC                 assume cs:_text$mn
.text$mn:000015BC                 ;org 15BCh
.text$mn:000015BC ; COMDAT (pick any)
.text$mn:000015BC                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text$mn:000015BC
.text$mn:000015BC ; =============== S U B R O U T I N E =======================================
.text$mn:000015BC
.text$mn:000015BC ; Attributes: bp-based frame
.text$mn:000015BC
.text$mn:000015BC ; const struct std::error_category *__thiscall std::error_code::category(std::error_code *__hidden this)
.text$mn:000015BC                 public ?category@error_code@std@@QBEABVerror_category@2@XZ
.text$mn:000015BC ?category@error_code@std@@QBEABVerror_category@2@XZ proc near
.text$mn:000015BC                                         ; CODE XREF: std::error_category::equivalent(std::error_code const &,int)+Cp
.text$mn:000015BC
.text$mn:000015BC var_4           = dword ptr -4
.text$mn:000015BC
.text$mn:000015BC                 push    ebp
.text$mn:000015BD                 mov     ebp, esp
.text$mn:000015BF                 push    ecx
.text$mn:000015C0                 mov     [ebp+var_4], ecx
.text$mn:000015C3                 mov     eax, [ebp+var_4]
.text$mn:000015C6                 mov     eax, [eax+4]
.text$mn:000015C9                 mov     esp, ebp
.text$mn:000015CB                 pop     ebp
.text$mn:000015CC                 retn
.text$mn:000015CC ?category@error_code@std@@QBEABVerror_category@2@XZ endp
.text$mn:000015CC
.text$mn:000015CC ; ---------------------------------------------------------------------------
.text$mn:000015CD                 align 10h
.text$mn:000015CD _text$mn        ends
.text$mn:000015CD
.text$mn:000015D0 ; ===========================================================================
.text$mn:000015D0
.text$mn:000015D0 ; Segment type: Pure code
.text$mn:000015D0 ; Segment permissions: Read/Execute
.text$mn:000015D0 _text$mn        segment para public 'CODE' use32
.text$mn:000015D0                 assume cs:_text$mn
.text$mn:000015D0                 ;org 15D0h
.text$mn:000015D0 ; COMDAT (pick any)
.text$mn:000015D0                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text$mn:000015D0
.text$mn:000015D0 ; =============== S U B R O U T I N E =======================================
.text$mn:000015D0
.text$mn:000015D0 ; Attributes: bp-based frame
.text$mn:000015D0
.text$mn:000015D0 ; const struct std::error_category *__thiscall std::error_condition::category(std::error_condition *__hidden this)
.text$mn:000015D0                 public ?category@error_condition@std@@QBEABVerror_category@2@XZ
.text$mn:000015D0 ?category@error_condition@std@@QBEABVerror_category@2@XZ proc near
.text$mn:000015D0                                         ; CODE XREF: std::error_condition::operator==(std::error_condition const &)+Dp
.text$mn:000015D0                                         ; std::error_condition::operator==(std::error_condition const &)+16p
.text$mn:000015D0
.text$mn:000015D0 var_4           = dword ptr -4
.text$mn:000015D0
.text$mn:000015D0                 push    ebp
.text$mn:000015D1                 mov     ebp, esp
.text$mn:000015D3                 push    ecx
.text$mn:000015D4                 mov     [ebp+var_4], ecx
.text$mn:000015D7                 mov     eax, [ebp+var_4]
.text$mn:000015DA                 mov     eax, [eax+4]
.text$mn:000015DD                 mov     esp, ebp
.text$mn:000015DF                 pop     ebp
.text$mn:000015E0                 retn
.text$mn:000015E0 ?category@error_condition@std@@QBEABVerror_category@2@XZ endp
.text$mn:000015E0
.text$mn:000015E0 ; ---------------------------------------------------------------------------
.text$mn:000015E1                 align 4
.text$mn:000015E1 _text$mn        ends
.text$mn:000015E1
.text$mn:000015E4 ; ===========================================================================
.text$mn:000015E4
.text$mn:000015E4 ; Segment type: Pure code
.text$mn:000015E4 ; Segment permissions: Read/Execute
.text$mn:000015E4 _text$mn        segment para public 'CODE' use32
.text$mn:000015E4                 assume cs:_text$mn
.text$mn:000015E4                 ;org 15E4h
.text$mn:000015E4 ; COMDAT (pick any)
.text$mn:000015E4                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text$mn:000015E4
.text$mn:000015E4 ; =============== S U B R O U T I N E =======================================
.text$mn:000015E4
.text$mn:000015E4 ; Attributes: bp-based frame
.text$mn:000015E4
.text$mn:000015E4 ; int __cdecl std::char_traits<char>::copy(void *Dst, void *Src, size_t Size)
.text$mn:000015E4                 public ?copy@?$char_traits@D@std@@SAPADPADPBDI@Z
.text$mn:000015E4 ?copy@?$char_traits@D@std@@SAPADPADPBDI@Z proc near ; CODE XREF: $LN19+1Ep
.text$mn:000015E4                                         ; std::basic_string<char,std::char_traits<char>,std::allocator<char>>::_Tidy(bool,uint)+5Dp ...
.text$mn:000015E4
.text$mn:000015E4 var_4           = dword ptr -4
.text$mn:000015E4 Dst             = dword ptr  8
.text$mn:000015E4 Src             = dword ptr  0Ch
.text$mn:000015E4 Size            = dword ptr  10h
.text$mn:000015E4
.text$mn:000015E4                 push    ebp
.text$mn:000015E5                 mov     ebp, esp
.text$mn:000015E7                 push    ecx
.text$mn:000015E8                 cmp     [ebp+Size], 0
.text$mn:000015EC                 jnz     short loc_15F6
.text$mn:000015EE                 mov     eax, [ebp+Dst]
.text$mn:000015F1                 mov     [ebp+var_4], eax
.text$mn:000015F4                 jmp     short loc_160D
.text$mn:000015F6 ; ---------------------------------------------------------------------------
.text$mn:000015F6
.text$mn:000015F6 loc_15F6:                               ; CODE XREF: std::char_traits<char>::copy(char *,char const *,uint)+8j
.text$mn:000015F6                 mov     ecx, [ebp+Size]
.text$mn:000015F9                 push    ecx             ; Size
.text$mn:000015FA                 mov     edx, [ebp+Src]
.text$mn:000015FD                 push    edx             ; Src
.text$mn:000015FE                 mov     eax, [ebp+Dst]
.text$mn:00001601                 push    eax             ; Dst
.text$mn:00001602                 call    _memcpy
.text$mn:00001607                 add     esp, 0Ch
.text$mn:0000160A                 mov     [ebp+var_4], eax
.text$mn:0000160D
.text$mn:0000160D loc_160D:                               ; CODE XREF: std::char_traits<char>::copy(char *,char const *,uint)+10j
.text$mn:0000160D                 mov     eax, [ebp+var_4]
.text$mn:00001610                 mov     esp, ebp
.text$mn:00001612                 pop     ebp
.text$mn:00001613                 retn
.text$mn:00001613 ?copy@?$char_traits@D@std@@SAPADPADPBDI@Z endp
.text$mn:00001613
.text$mn:00001613 _text$mn        ends
.text$mn:00001613
.text$mn:00001614 ; ===========================================================================
.text$mn:00001614
.text$mn:00001614 ; Segment type: Pure code
.text$mn:00001614 ; Segment permissions: Read/Execute
.text$mn:00001614 _text$mn        segment para public 'CODE' use32
.text$mn:00001614                 assume cs:_text$mn
.text$mn:00001614                 ;org 1614h
.text$mn:00001614 ; COMDAT (pick any)
.text$mn:00001614                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text$mn:00001614
.text$mn:00001614 ; =============== S U B R O U T I N E =======================================
.text$mn:00001614
.text$mn:00001614 ; Attributes: bp-based frame
.text$mn:00001614
.text$mn:00001614 ; int __stdcall std::_Wrap_alloc<std::allocator<char>>::deallocate(void *, int)
.text$mn:00001614                 public ?deallocate@?$_Wrap_alloc@V?$allocator@D@std@@@std@@QAEXPADI@Z
.text$mn:00001614 ?deallocate@?$_Wrap_alloc@V?$allocator@D@std@@@std@@QAEXPADI@Z proc near
.text$mn:00001614                                         ; CODE XREF: std::basic_string<char,std::char_traits<char>,std::allocator<char>>::_Tidy(bool,uint)+81p
.text$mn:00001614
.text$mn:00001614 var_4           = dword ptr -4
.text$mn:00001614 arg_0           = dword ptr  8
.text$mn:00001614 arg_4           = dword ptr  0Ch
.text$mn:00001614
.text$mn:00001614                 push    ebp
.text$mn:00001615                 mov     ebp, esp
.text$mn:00001617                 push    ecx
.text$mn:00001618                 mov     [ebp+var_4], ecx
.text$mn:0000161B                 mov     eax, [ebp+arg_4]
.text$mn:0000161E                 push    eax             ; int
.text$mn:0000161F                 mov     ecx, [ebp+arg_0]
.text$mn:00001622                 push    ecx             ; void *
.text$mn:00001623                 mov     ecx, [ebp+var_4]
.text$mn:00001626                 call    ?deallocate@?$allocator@D@std@@QAEXPADI@Z ; std::allocator<char>::deallocate(char *,uint)
.text$mn:0000162B                 mov     esp, ebp
.text$mn:0000162D                 pop     ebp
.text$mn:0000162E                 retn    8
.text$mn:0000162E ?deallocate@?$_Wrap_alloc@V?$allocator@D@std@@@std@@QAEXPADI@Z endp
.text$mn:0000162E
.text$mn:0000162E ; ---------------------------------------------------------------------------
.text$mn:00001631                 align 4
.text$mn:00001631 _text$mn        ends
.text$mn:00001631
.text$mn:00001634 ; ===========================================================================
.text$mn:00001634
.text$mn:00001634 ; Segment type: Pure code
.text$mn:00001634 ; Segment permissions: Read/Execute
.text$mn:00001634 _text$mn        segment para public 'CODE' use32
.text$mn:00001634                 assume cs:_text$mn
.text$mn:00001634                 ;org 1634h
.text$mn:00001634 ; COMDAT (pick any)
.text$mn:00001634                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text$mn:00001634
.text$mn:00001634 ; =============== S U B R O U T I N E =======================================
.text$mn:00001634
.text$mn:00001634 ; Attributes: bp-based frame
.text$mn:00001634
.text$mn:00001634 ; int __stdcall std::allocator<char>::deallocate(void *, int)
.text$mn:00001634                 public ?deallocate@?$allocator@D@std@@QAEXPADI@Z
.text$mn:00001634 ?deallocate@?$allocator@D@std@@QAEXPADI@Z proc near
.text$mn:00001634                                         ; CODE XREF: std::_Wrap_alloc<std::allocator<char>>::deallocate(char *,uint)+12p
.text$mn:00001634
.text$mn:00001634 var_4           = dword ptr -4
.text$mn:00001634 arg_0           = dword ptr  8
.text$mn:00001634
.text$mn:00001634                 push    ebp
.text$mn:00001635                 mov     ebp, esp
.text$mn:00001637                 push    ecx
.text$mn:00001638                 mov     [ebp+var_4], ecx
.text$mn:0000163B                 mov     eax, [ebp+arg_0]
.text$mn:0000163E                 push    eax             ; void *
.text$mn:0000163F                 call    ??3@YAXPAX@Z    ; operator delete(void *)
.text$mn:00001644                 add     esp, 4
.text$mn:00001647                 mov     esp, ebp
.text$mn:00001649                 pop     ebp
.text$mn:0000164A                 retn    8
.text$mn:0000164A ?deallocate@?$allocator@D@std@@QAEXPADI@Z endp
.text$mn:0000164A
.text$mn:0000164A ; ---------------------------------------------------------------------------
.text$mn:0000164D                 align 10h
.text$mn:0000164D _text$mn        ends
.text$mn:0000164D
.text$mn:00001650 ; ===========================================================================
.text$mn:00001650
.text$mn:00001650 ; Segment type: Pure code
.text$mn:00001650 ; Segment permissions: Read/Execute
.text$mn:00001650 _text$mn        segment para public 'CODE' use32
.text$mn:00001650                 assume cs:_text$mn
.text$mn:00001650                 ;org 1650h
.text$mn:00001650 ; COMDAT (pick any)
.text$mn:00001650                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text$mn:00001650
.text$mn:00001650 ; =============== S U B R O U T I N E =======================================
.text$mn:00001650
.text$mn:00001650 ; Attributes: bp-based frame
.text$mn:00001650
.text$mn:00001650 ; int __stdcall std::allocator<std::_Container_proxy>::deallocate(void *, int)
.text$mn:00001650                 public ?deallocate@?$allocator@U_Container_proxy@std@@@std@@QAEXPAU_Container_proxy@2@I@Z
.text$mn:00001650 ?deallocate@?$allocator@U_Container_proxy@std@@@std@@QAEXPAU_Container_proxy@2@I@Z proc near
.text$mn:00001650                                         ; CODE XREF: std::_String_alloc<0,std::_String_base_types<char,std::allocator<char>>>::_Free_proxy(void)+32p
.text$mn:00001650
.text$mn:00001650 var_4           = dword ptr -4
.text$mn:00001650 arg_0           = dword ptr  8
.text$mn:00001650
.text$mn:00001650                 push    ebp
.text$mn:00001651                 mov     ebp, esp
.text$mn:00001653                 push    ecx
.text$mn:00001654                 mov     [ebp+var_4], ecx
.text$mn:00001657                 mov     eax, [ebp+arg_0]
.text$mn:0000165A                 push    eax             ; void *
.text$mn:0000165B                 call    ??3@YAXPAX@Z    ; operator delete(void *)
.text$mn:00001660                 add     esp, 4
.text$mn:00001663                 mov     esp, ebp
.text$mn:00001665                 pop     ebp
.text$mn:00001666                 retn    8
.text$mn:00001666 ?deallocate@?$allocator@U_Container_proxy@std@@@std@@QAEXPAU_Container_proxy@2@I@Z endp
.text$mn:00001666
.text$mn:00001666 ; ---------------------------------------------------------------------------
.text$mn:00001669                 align 4
.text$mn:00001669 _text$mn        ends
.text$mn:00001669
.text$mn:0000166C ; ===========================================================================
.text$mn:0000166C
.text$mn:0000166C ; Segment type: Pure code
.text$mn:0000166C ; Segment permissions: Read/Execute
.text$mn:0000166C _text$mn        segment para public 'CODE' use32
.text$mn:0000166C                 assume cs:_text$mn
.text$mn:0000166C                 ;org 166Ch
.text$mn:0000166C ; COMDAT (pick any)
.text$mn:0000166C                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text$mn:0000166C
.text$mn:0000166C ; =============== S U B R O U T I N E =======================================
.text$mn:0000166C
.text$mn:0000166C ; Attributes: bp-based frame
.text$mn:0000166C
.text$mn:0000166C ; public: virtual class std::error_condition __thiscall std::_System_error_category::default_error_condition(int)const
.text$mn:0000166C                 public ?default_error_condition@_System_error_category@std@@UBE?AVerror_condition@2@H@Z
.text$mn:0000166C ?default_error_condition@_System_error_category@std@@UBE?AVerror_condition@2@H@Z proc near
.text$mn:0000166C                                         ; DATA XREF: .rdata:00002000o
.text$mn:0000166C
.text$mn:0000166C var_4           = dword ptr -4
.text$mn:0000166C arg_0           = dword ptr  8
.text$mn:0000166C arg_4           = dword ptr  0Ch
.text$mn:0000166C
.text$mn:0000166C                 push    ebp
.text$mn:0000166D                 mov     ebp, esp
.text$mn:0000166F                 push    ecx
.text$mn:00001670                 mov     [ebp+var_4], ecx
.text$mn:00001673                 mov     eax, [ebp+arg_4]
.text$mn:00001676                 push    eax             ; int
.text$mn:00001677                 call    ?_Syserror_map@std@@YAPBDH@Z ; std::_Syserror_map(int)
.text$mn:0000167C                 add     esp, 4
.text$mn:0000167F                 test    eax, eax
.text$mn:00001681                 jz      short loc_169C
.text$mn:00001683                 call    ?generic_category@std@@YAABVerror_category@1@XZ ; std::generic_category(void)
.text$mn:00001688                 push    eax             ; struct std::error_category *
.text$mn:00001689                 mov     ecx, [ebp+arg_4]
.text$mn:0000168C                 push    ecx             ; int
.text$mn:0000168D                 mov     ecx, [ebp+arg_0] ; this
.text$mn:00001690                 call    ??0error_condition@std@@QAE@HABVerror_category@1@@Z ; std::error_condition::error_condition(int,std::error_category const &)
.text$mn:00001695                 mov     eax, [ebp+arg_0]
.text$mn:00001698                 jmp     short loc_16B1
.text$mn:0000169A ; ---------------------------------------------------------------------------
.text$mn:0000169A                 jmp     short loc_16B1
.text$mn:0000169C ; ---------------------------------------------------------------------------
.text$mn:0000169C
.text$mn:0000169C loc_169C:                               ; CODE XREF: std::_System_error_category::default_error_condition(int)+15j
.text$mn:0000169C                 call    ?system_category@std@@YAABVerror_category@1@XZ ; std::system_category(void)
.text$mn:000016A1                 push    eax             ; struct std::error_category *
.text$mn:000016A2                 mov     edx, [ebp+arg_4]
.text$mn:000016A5                 push    edx             ; int
.text$mn:000016A6                 mov     ecx, [ebp+arg_0] ; this
.text$mn:000016A9                 call    ??0error_condition@std@@QAE@HABVerror_category@1@@Z ; std::error_condition::error_condition(int,std::error_category const &)
.text$mn:000016AE                 mov     eax, [ebp+arg_0]
.text$mn:000016B1
.text$mn:000016B1 loc_16B1:                               ; CODE XREF: std::_System_error_category::default_error_condition(int)+2Cj
.text$mn:000016B1                                         ; std::_System_error_category::default_error_condition(int)+2Ej
.text$mn:000016B1                 mov     esp, ebp
.text$mn:000016B3                 pop     ebp
.text$mn:000016B4                 retn    8
.text$mn:000016B4 ?default_error_condition@_System_error_category@std@@UBE?AVerror_condition@2@H@Z endp
.text$mn:000016B4
.text$mn:000016B4 ; ---------------------------------------------------------------------------
.text$mn:000016B7                 align 4
.text$mn:000016B7 _text$mn        ends
.text$mn:000016B7
.text$mn:000016B8 ; ===========================================================================
.text$mn:000016B8
.text$mn:000016B8 ; Segment type: Pure code
.text$mn:000016B8 ; Segment permissions: Read/Execute
.text$mn:000016B8 _text$mn        segment para public 'CODE' use32
.text$mn:000016B8                 assume cs:_text$mn
.text$mn:000016B8                 ;org 16B8h
.text$mn:000016B8 ; COMDAT (pick any)
.text$mn:000016B8                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text$mn:000016B8
.text$mn:000016B8 ; =============== S U B R O U T I N E =======================================
.text$mn:000016B8
.text$mn:000016B8 ; Attributes: bp-based frame
.text$mn:000016B8
.text$mn:000016B8 ; public: virtual class std::error_condition __thiscall std::error_category::default_error_condition(int)const
.text$mn:000016B8                 public ?default_error_condition@error_category@std@@UBE?AVerror_condition@2@H@Z
.text$mn:000016B8 ?default_error_condition@error_category@std@@UBE?AVerror_condition@2@H@Z proc near
.text$mn:000016B8                                         ; DATA XREF: .rdata:00001F70o
.text$mn:000016B8                                         ; .rdata:00001F8Co ...
.text$mn:000016B8
.text$mn:000016B8 var_4           = dword ptr -4
.text$mn:000016B8 arg_0           = dword ptr  8
.text$mn:000016B8 arg_4           = dword ptr  0Ch
.text$mn:000016B8
.text$mn:000016B8                 push    ebp
.text$mn:000016B9                 mov     ebp, esp
.text$mn:000016BB                 push    ecx
.text$mn:000016BC                 mov     [ebp+var_4], ecx
.text$mn:000016BF                 mov     eax, [ebp+var_4]
.text$mn:000016C2                 push    eax             ; struct std::error_category *
.text$mn:000016C3                 mov     ecx, [ebp+arg_4]
.text$mn:000016C6                 push    ecx             ; int
.text$mn:000016C7                 mov     ecx, [ebp+arg_0] ; this
.text$mn:000016CA                 call    ??0error_condition@std@@QAE@HABVerror_category@1@@Z ; std::error_condition::error_condition(int,std::error_category const &)
.text$mn:000016CF                 mov     eax, [ebp+arg_0]
.text$mn:000016D2                 mov     esp, ebp
.text$mn:000016D4                 pop     ebp
.text$mn:000016D5                 retn    8
.text$mn:000016D5 ?default_error_condition@error_category@std@@UBE?AVerror_condition@2@H@Z endp
.text$mn:000016D5
.text$mn:000016D5 _text$mn        ends
.text$mn:000016D5
.text$mn:000016D8 ; ===========================================================================
.text$mn:000016D8
.text$mn:000016D8 ; Segment type: Pure code
.text$mn:000016D8 ; Segment permissions: Read/Execute
.text$mn:000016D8 _text$mn        segment para public 'CODE' use32
.text$mn:000016D8                 assume cs:_text$mn
.text$mn:000016D8                 ;org 16D8h
.text$mn:000016D8 ; COMDAT (pick any)
.text$mn:000016D8                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text$mn:000016D8
.text$mn:000016D8 ; =============== S U B R O U T I N E =======================================
.text$mn:000016D8
.text$mn:000016D8 ; Attributes: bp-based frame
.text$mn:000016D8
.text$mn:000016D8 ; bool __thiscall std::error_category::equivalent(std::error_category *this, const struct std::error_code *, int)
.text$mn:000016D8                 public ?equivalent@error_category@std@@UBE_NABVerror_code@2@H@Z
.text$mn:000016D8 ?equivalent@error_category@std@@UBE_NABVerror_code@2@H@Z proc near
.text$mn:000016D8                                         ; DATA XREF: .rdata:00001F74o
.text$mn:000016D8                                         ; .rdata:00001F90o ...
.text$mn:000016D8
.text$mn:000016D8 var_8           = dword ptr -8
.text$mn:000016D8 var_4           = dword ptr -4
.text$mn:000016D8 arg_0           = dword ptr  8
.text$mn:000016D8 arg_4           = dword ptr  0Ch
.text$mn:000016D8
.text$mn:000016D8                 push    ebp
.text$mn:000016D9                 mov     ebp, esp
.text$mn:000016DB                 sub     esp, 8
.text$mn:000016DE                 mov     [ebp+var_8], ecx
.text$mn:000016E1                 mov     ecx, [ebp+arg_0] ; this
.text$mn:000016E4                 call    ?category@error_code@std@@QBEABVerror_category@2@XZ ; std::error_code::category(void)
.text$mn:000016E9                 push    eax
.text$mn:000016EA                 mov     ecx, [ebp+var_8]
.text$mn:000016ED                 call    ??8error_category@std@@QBE_NABV01@@Z ; std::error_category::operator==(std::error_category const &)
.text$mn:000016F2                 movzx   eax, al
.text$mn:000016F5                 test    eax, eax
.text$mn:000016F7                 jz      short loc_170F
.text$mn:000016F9                 mov     ecx, [ebp+arg_0] ; this
.text$mn:000016FC                 call    ?value@error_code@std@@QBEHXZ ; std::error_code::value(void)
.text$mn:00001701                 cmp     eax, [ebp+arg_4]
.text$mn:00001704                 jnz     short loc_170F
.text$mn:00001706                 mov     [ebp+var_4], 1
.text$mn:0000170D                 jmp     short loc_1716
.text$mn:0000170F ; ---------------------------------------------------------------------------
.text$mn:0000170F
.text$mn:0000170F loc_170F:                               ; CODE XREF: std::error_category::equivalent(std::error_code const &,int)+1Fj
.text$mn:0000170F                                         ; std::error_category::equivalent(std::error_code const &,int)+2Cj
.text$mn:0000170F                 mov     [ebp+var_4], 0
.text$mn:00001716
.text$mn:00001716 loc_1716:                               ; CODE XREF: std::error_category::equivalent(std::error_code const &,int)+35j
.text$mn:00001716                 mov     al, byte ptr [ebp+var_4]
.text$mn:00001719                 mov     esp, ebp
.text$mn:0000171B                 pop     ebp
.text$mn:0000171C                 retn    8
.text$mn:0000171C ?equivalent@error_category@std@@UBE_NABVerror_code@2@H@Z endp
.text$mn:0000171C
.text$mn:0000171C ; ---------------------------------------------------------------------------
.text$mn:0000171F                 align 10h
.text$mn:0000171F _text$mn        ends
.text$mn:0000171F
.text$mn:00001720 ; ===========================================================================
.text$mn:00001720
.text$mn:00001720 ; Segment type: Pure code
.text$mn:00001720 ; Segment permissions: Read/Execute
.text$mn:00001720 _text$mn        segment para public 'CODE' use32
.text$mn:00001720                 assume cs:_text$mn
.text$mn:00001720                 ;org 1720h
.text$mn:00001720 ; COMDAT (pick any)
.text$mn:00001720                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text$mn:00001720
.text$mn:00001720 ; =============== S U B R O U T I N E =======================================
.text$mn:00001720
.text$mn:00001720 ; Attributes: bp-based frame
.text$mn:00001720
.text$mn:00001720 ; bool __thiscall std::error_category::equivalent(std::error_category *this, int, const struct std::error_condition *)
.text$mn:00001720                 public ?equivalent@error_category@std@@UBE_NHABVerror_condition@2@@Z
.text$mn:00001720 ?equivalent@error_category@std@@UBE_NHABVerror_condition@2@@Z proc near
.text$mn:00001720                                         ; DATA XREF: .rdata:00001F78o
.text$mn:00001720                                         ; .rdata:00001F94o ...
.text$mn:00001720
.text$mn:00001720 var_C           = byte ptr -0Ch
.text$mn:00001720 var_4           = dword ptr -4
.text$mn:00001720 arg_0           = dword ptr  8
.text$mn:00001720 arg_4           = dword ptr  0Ch
.text$mn:00001720
.text$mn:00001720                 push    ebp
.text$mn:00001721                 mov     ebp, esp
.text$mn:00001723                 sub     esp, 0Ch
.text$mn:00001726                 mov     [ebp+var_4], ecx
.text$mn:00001729                 mov     eax, [ebp+arg_4]
.text$mn:0000172C                 push    eax             ; std::error_condition *
.text$mn:0000172D                 mov     ecx, [ebp+arg_0]
.text$mn:00001730                 push    ecx
.text$mn:00001731                 lea     edx, [ebp+var_C]
.text$mn:00001734                 push    edx
.text$mn:00001735                 mov     eax, [ebp+var_4]
.text$mn:00001738                 mov     edx, [eax]
.text$mn:0000173A                 mov     ecx, [ebp+var_4]
.text$mn:0000173D                 mov     eax, [edx+0Ch]
.text$mn:00001740                 call    eax
.text$mn:00001742                 mov     ecx, eax
.text$mn:00001744                 call    ??8error_condition@std@@QBE_NABV01@@Z ; std::error_condition::operator==(std::error_condition const &)
.text$mn:00001749                 mov     esp, ebp
.text$mn:0000174B                 pop     ebp
.text$mn:0000174C                 retn    8
.text$mn:0000174C ?equivalent@error_category@std@@UBE_NHABVerror_condition@2@@Z endp
.text$mn:0000174C
.text$mn:0000174C ; ---------------------------------------------------------------------------
.text$mn:0000174F                 align 10h
.text$mn:0000174F _text$mn        ends
.text$mn:0000174F
.text$mn:00001750 ; ===========================================================================
.text$mn:00001750
.text$mn:00001750 ; Segment type: Pure code
.text$mn:00001750 ; Segment permissions: Read/Execute
.text$mn:00001750 _text$mn        segment para public 'CODE' use32
.text$mn:00001750                 assume cs:_text$mn
.text$mn:00001750                 ;org 1750h
.text$mn:00001750 ; COMDAT (pick any)
.text$mn:00001750                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text$mn:00001750
.text$mn:00001750 ; =============== S U B R O U T I N E =======================================
.text$mn:00001750
.text$mn:00001750 ; Attributes: bp-based frame
.text$mn:00001750
.text$mn:00001750 ; public: class std::basic_string<char, struct std::char_traits<char>, class std::allocator<char>> & __thiscall std::basic_string<char, struct std::char_traits<char>, class std::allocator<char>>::erase(unsigned int)
.text$mn:00001750                 public ?erase@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV12@I@Z
.text$mn:00001750 ?erase@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV12@I@Z proc near
.text$mn:00001750                                         ; CODE XREF: std::basic_string<char,std::char_traits<char>,std::allocator<char>>::assign(std::basic_string<char,std::char_traits<char>,std::allocator<char>> const &,uint,uint)+4Cp
.text$mn:00001750
.text$mn:00001750 var_4           = dword ptr -4
.text$mn:00001750 arg_0           = dword ptr  8
.text$mn:00001750
.text$mn:00001750                 push    ebp
.text$mn:00001751                 mov     ebp, esp
.text$mn:00001753                 push    ecx
.text$mn:00001754                 mov     [ebp+var_4], ecx
.text$mn:00001757                 mov     eax, [ebp+var_4]
.text$mn:0000175A                 mov     ecx, [eax+14h]
.text$mn:0000175D                 cmp     ecx, [ebp+arg_0]
.text$mn:00001760                 jnb     short loc_176A
.text$mn:00001762                 mov     ecx, [ebp+var_4]
.text$mn:00001765                 call    ?_Xran@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QBEXXZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char>>::_Xran(void)
.text$mn:0000176A
.text$mn:0000176A loc_176A:                               ; CODE XREF: std::basic_string<char,std::char_traits<char>,std::allocator<char>>::erase(uint)+10j
.text$mn:0000176A                 mov     edx, [ebp+arg_0]
.text$mn:0000176D                 push    edx
.text$mn:0000176E                 mov     ecx, [ebp+var_4]
.text$mn:00001771                 call    ?_Eos@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEXI@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char>>::_Eos(uint)
.text$mn:00001776                 mov     eax, [ebp+var_4]
.text$mn:00001779                 mov     esp, ebp
.text$mn:0000177B                 pop     ebp
.text$mn:0000177C                 retn    4
.text$mn:0000177C ?erase@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV12@I@Z endp
.text$mn:0000177C
.text$mn:0000177C ; ---------------------------------------------------------------------------
.text$mn:0000177F                 align 10h
.text$mn:0000177F _text$mn        ends
.text$mn:0000177F
.text$mn:00001780 ; ===========================================================================
.text$mn:00001780
.text$mn:00001780 ; Segment type: Pure code
.text$mn:00001780 ; Segment permissions: Read/Execute
.text$mn:00001780 _text$mn        segment para public 'CODE' use32
.text$mn:00001780                 assume cs:_text$mn
.text$mn:00001780                 ;org 1780h
.text$mn:00001780 ; COMDAT (pick any)
.text$mn:00001780                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text$mn:00001780
.text$mn:00001780 ; =============== S U B R O U T I N E =======================================
.text$mn:00001780
.text$mn:00001780 ; Attributes: bp-based frame
.text$mn:00001780
.text$mn:00001780 ; public: class std::basic_string<char, struct std::char_traits<char>, class std::allocator<char>> & __thiscall std::basic_string<char, struct std::char_traits<char>, class std::allocator<char>>::erase(unsigned int, unsigned int)
.text$mn:00001780                 public ?erase@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV12@II@Z
.text$mn:00001780 ?erase@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV12@II@Z proc near
.text$mn:00001780                                         ; CODE XREF: std::basic_string<char,std::char_traits<char>,std::allocator<char>>::assign(std::basic_string<char,std::char_traits<char>,std::allocator<char>> const &,uint,uint)+5Ap
.text$mn:00001780
.text$mn:00001780 var_C           = dword ptr -0Ch
.text$mn:00001780 Dst             = dword ptr -8
.text$mn:00001780 var_4           = dword ptr -4
.text$mn:00001780 arg_0           = dword ptr  8
.text$mn:00001780 arg_4           = dword ptr  0Ch
.text$mn:00001780
.text$mn:00001780                 push    ebp
.text$mn:00001781                 mov     ebp, esp
.text$mn:00001783                 sub     esp, 0Ch
.text$mn:00001786                 mov     [ebp+var_4], ecx
.text$mn:00001789                 mov     eax, [ebp+var_4]
.text$mn:0000178C                 mov     ecx, [eax+14h]
.text$mn:0000178F                 cmp     ecx, [ebp+arg_0]
.text$mn:00001792                 jnb     short loc_179C
.text$mn:00001794                 mov     ecx, [ebp+var_4]
.text$mn:00001797                 call    ?_Xran@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QBEXXZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char>>::_Xran(void)
.text$mn:0000179C
.text$mn:0000179C loc_179C:                               ; CODE XREF: std::basic_string<char,std::char_traits<char>,std::allocator<char>>::erase(uint,uint)+12j
.text$mn:0000179C                 mov     edx, [ebp+var_4]
.text$mn:0000179F                 mov     eax, [edx+14h]
.text$mn:000017A2                 sub     eax, [ebp+arg_0]
.text$mn:000017A5                 cmp     eax, [ebp+arg_4]
.text$mn:000017A8                 ja      short loc_17B8
.text$mn:000017AA                 mov     ecx, [ebp+arg_0]
.text$mn:000017AD                 push    ecx
.text$mn:000017AE                 mov     ecx, [ebp+var_4]
.text$mn:000017B1                 call    ?_Eos@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEXI@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char>>::_Eos(uint)
.text$mn:000017B6                 jmp     short loc_17FE
.text$mn:000017B8 ; ---------------------------------------------------------------------------
.text$mn:000017B8
.text$mn:000017B8 loc_17B8:                               ; CODE XREF: std::basic_string<char,std::char_traits<char>,std::allocator<char>>::erase(uint,uint)+28j
.text$mn:000017B8                 cmp     [ebp+arg_4], 0
.text$mn:000017BC                 jbe     short loc_17FE
.text$mn:000017BE                 mov     ecx, [ebp+var_4]
.text$mn:000017C1                 call    ?_Myptr@?$_String_val@U?$_Simple_types@D@std@@@std@@QAEPADXZ ; std::_String_val<std::_Simple_types<char>>::_Myptr(void)
.text$mn:000017C6                 add     eax, [ebp+arg_0]
.text$mn:000017C9                 mov     [ebp+Dst], eax
.text$mn:000017CC                 mov     edx, [ebp+var_4]
.text$mn:000017CF                 mov     eax, [edx+14h]
.text$mn:000017D2                 sub     eax, [ebp+arg_4]
.text$mn:000017D5                 mov     [ebp+var_C], eax
.text$mn:000017D8                 mov     ecx, [ebp+var_C]
.text$mn:000017DB                 sub     ecx, [ebp+arg_0]
.text$mn:000017DE                 push    ecx             ; Size
.text$mn:000017DF                 mov     edx, [ebp+Dst]
.text$mn:000017E2                 add     edx, [ebp+arg_4]
.text$mn:000017E5                 push    edx             ; Src
.text$mn:000017E6                 mov     eax, [ebp+Dst]
.text$mn:000017E9                 push    eax             ; Dst
.text$mn:000017EA                 call    ?move@?$char_traits@D@std@@SAPADPADPBDI@Z ; std::char_traits<char>::move(char *,char const *,uint)
.text$mn:000017EF                 add     esp, 0Ch
.text$mn:000017F2                 mov     ecx, [ebp+var_C]
.text$mn:000017F5                 push    ecx
.text$mn:000017F6                 mov     ecx, [ebp+var_4]
.text$mn:000017F9                 call    ?_Eos@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEXI@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char>>::_Eos(uint)
.text$mn:000017FE
.text$mn:000017FE loc_17FE:                               ; CODE XREF: std::basic_string<char,std::char_traits<char>,std::allocator<char>>::erase(uint,uint)+36j
.text$mn:000017FE                                         ; std::basic_string<char,std::char_traits<char>,std::allocator<char>>::erase(uint,uint)+3Cj
.text$mn:000017FE                 mov     eax, [ebp+var_4]
.text$mn:00001801                 mov     esp, ebp
.text$mn:00001803                 pop     ebp
.text$mn:00001804                 retn    8
.text$mn:00001804 ?erase@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV12@II@Z endp
.text$mn:00001804
.text$mn:00001804 ; ---------------------------------------------------------------------------
.text$mn:00001807                 align 4
.text$mn:00001807 _text$mn        ends
.text$mn:00001807
.text$mn:00001808 ; ===========================================================================
.text$mn:00001808
.text$mn:00001808 ; Segment type: Pure code
.text$mn:00001808 ; Segment permissions: Read/Execute
.text$mn:00001808 _text$mn        segment para public 'CODE' use32
.text$mn:00001808                 assume cs:_text$mn
.text$mn:00001808                 ;org 1808h
.text$mn:00001808 ; COMDAT (pick any)
.text$mn:00001808                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text$mn:00001808
.text$mn:00001808 ; =============== S U B R O U T I N E =======================================
.text$mn:00001808
.text$mn:00001808 ; Attributes: bp-based frame
.text$mn:00001808
.text$mn:00001808 ; const struct std::error_category *__cdecl std::generic_category()
.text$mn:00001808                 public ?generic_category@std@@YAABVerror_category@1@XZ
.text$mn:00001808 ?generic_category@std@@YAABVerror_category@1@XZ proc near
.text$mn:00001808                                         ; CODE XREF: std::_System_error_category::default_error_condition(int)+17p
.text$mn:00001808                 push    ebp
.text$mn:00001809                 mov     ebp, esp
.text$mn:0000180B                 mov     eax, offset ?_Generic_object@?$_Error_objects@H@std@@2V_Generic_error_category@2@A ; std::_Generic_error_category std::_Error_objects<int>::_Generic_object
.text$mn:00001810                 pop     ebp
.text$mn:00001811                 retn
.text$mn:00001811 ?generic_category@std@@YAABVerror_category@1@XZ endp
.text$mn:00001811
.text$mn:00001811 ; ---------------------------------------------------------------------------
.text$mn:00001812                 align 4
.text$mn:00001812 _text$mn        ends
.text$mn:00001812
.text$mn:00001814 ; ===========================================================================
.text$mn:00001814
.text$mn:00001814 ; Segment type: Pure code
.text$mn:00001814 ; Segment permissions: Read/Execute
.text$mn:00001814 _text$mn        segment para public 'CODE' use32
.text$mn:00001814                 assume cs:_text$mn
.text$mn:00001814                 ;org 1814h
.text$mn:00001814 ; COMDAT (pick any)
.text$mn:00001814                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text$mn:00001814
.text$mn:00001814 ; =============== S U B R O U T I N E =======================================
.text$mn:00001814
.text$mn:00001814 ; Attributes: bp-based frame
.text$mn:00001814
.text$mn:00001814 ; int __cdecl std::char_traits<char>::length(char *Str)
.text$mn:00001814                 public ?length@?$char_traits@D@std@@SAIPBD@Z
.text$mn:00001814 ?length@?$char_traits@D@std@@SAIPBD@Z proc near
.text$mn:00001814                                         ; CODE XREF: std::basic_string<char,std::char_traits<char>,std::allocator<char>>::assign(char const *)+21p
.text$mn:00001814
.text$mn:00001814 var_4           = dword ptr -4
.text$mn:00001814 Str             = dword ptr  8
.text$mn:00001814
.text$mn:00001814                 push    ebp
.text$mn:00001815                 mov     ebp, esp
.text$mn:00001817                 push    ecx
.text$mn:00001818                 mov     eax, [ebp+Str]
.text$mn:0000181B                 movsx   ecx, byte ptr [eax]
.text$mn:0000181E                 test    ecx, ecx
.text$mn:00001820                 jnz     short loc_182B
.text$mn:00001822                 mov     [ebp+var_4], 0
.text$mn:00001829                 jmp     short loc_183A
.text$mn:0000182B ; ---------------------------------------------------------------------------
.text$mn:0000182B
.text$mn:0000182B loc_182B:                               ; CODE XREF: std::char_traits<char>::length(char const *)+Cj
.text$mn:0000182B                 mov     edx, [ebp+Str]
.text$mn:0000182E                 push    edx             ; Str
.text$mn:0000182F                 call    _strlen
.text$mn:00001834                 add     esp, 4
.text$mn:00001837                 mov     [ebp+var_4], eax
.text$mn:0000183A
.text$mn:0000183A loc_183A:                               ; CODE XREF: std::char_traits<char>::length(char const *)+15j
.text$mn:0000183A                 mov     eax, [ebp+var_4]
.text$mn:0000183D                 mov     esp, ebp
.text$mn:0000183F                 pop     ebp
.text$mn:00001840                 retn
.text$mn:00001840 ?length@?$char_traits@D@std@@SAIPBD@Z endp
.text$mn:00001840
.text$mn:00001840 ; ---------------------------------------------------------------------------
.text$mn:00001841                 align 4
.text$mn:00001841 _text$mn        ends
.text$mn:00001841
.text$mn:00001844 ; ===========================================================================
.text$mn:00001844
.text$mn:00001844 ; Segment type: Pure code
.text$mn:00001844 ; Segment permissions: Read/Execute
.text$mn:00001844 _text$mn        segment para public 'CODE' use32
.text$mn:00001844                 assume cs:_text$mn
.text$mn:00001844                 ;org 1844h
.text$mn:00001844 ; COMDAT (pick any)
.text$mn:00001844                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text$mn:00001844
.text$mn:00001844 ; =============== S U B R O U T I N E =======================================
.text$mn:00001844
.text$mn:00001844 ; Attributes: bp-based frame
.text$mn:00001844
.text$mn:00001844 ; public: unsigned int __thiscall std::_Wrap_alloc<class std::allocator<char>>::max_size(void)const
.text$mn:00001844                 public ?max_size@?$_Wrap_alloc@V?$allocator@D@std@@@std@@QBEIXZ
.text$mn:00001844 ?max_size@?$_Wrap_alloc@V?$allocator@D@std@@@std@@QBEIXZ proc near
.text$mn:00001844                                         ; CODE XREF: std::basic_string<char,std::char_traits<char>,std::allocator<char>>::max_size(void)+17p
.text$mn:00001844
.text$mn:00001844 var_4           = dword ptr -4
.text$mn:00001844
.text$mn:00001844                 push    ebp
.text$mn:00001845                 mov     ebp, esp
.text$mn:00001847                 push    ecx
.text$mn:00001848                 mov     [ebp+var_4], ecx
.text$mn:0000184B                 mov     eax, [ebp+var_4]
.text$mn:0000184E                 push    eax
.text$mn:0000184F                 call    ?max_size@?$allocator_traits@V?$allocator@D@std@@@std@@SAIABV?$allocator@D@2@@Z ; std::allocator_traits<std::allocator<char>>::max_size(std::allocator<char> const &)
.text$mn:00001854                 add     esp, 4
.text$mn:00001857                 mov     esp, ebp
.text$mn:00001859                 pop     ebp
.text$mn:0000185A                 retn
.text$mn:0000185A ?max_size@?$_Wrap_alloc@V?$allocator@D@std@@@std@@QBEIXZ endp
.text$mn:0000185A
.text$mn:0000185A ; ---------------------------------------------------------------------------
.text$mn:0000185B                 align 4
.text$mn:0000185B _text$mn        ends
.text$mn:0000185B
.text$mn:0000185C ; ===========================================================================
.text$mn:0000185C
.text$mn:0000185C ; Segment type: Pure code
.text$mn:0000185C ; Segment permissions: Read/Execute
.text$mn:0000185C _text$mn        segment para public 'CODE' use32
.text$mn:0000185C                 assume cs:_text$mn
.text$mn:0000185C                 ;org 185Ch
.text$mn:0000185C ; COMDAT (pick any)
.text$mn:0000185C                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text$mn:0000185C
.text$mn:0000185C ; =============== S U B R O U T I N E =======================================
.text$mn:0000185C
.text$mn:0000185C ; Attributes: bp-based frame
.text$mn:0000185C
.text$mn:0000185C ; public: unsigned int __thiscall std::allocator<char>::max_size(void)const
.text$mn:0000185C                 public ?max_size@?$allocator@D@std@@QBEIXZ
.text$mn:0000185C ?max_size@?$allocator@D@std@@QBEIXZ proc near
.text$mn:0000185C                                         ; CODE XREF: std::allocator_traits<std::allocator<char>>::max_size(std::allocator<char> const &)+6p
.text$mn:0000185C
.text$mn:0000185C var_4           = dword ptr -4
.text$mn:0000185C
.text$mn:0000185C                 push    ebp
.text$mn:0000185D                 mov     ebp, esp
.text$mn:0000185F                 push    ecx
.text$mn:00001860                 mov     [ebp+var_4], ecx
.text$mn:00001863                 or      eax, 0FFFFFFFFh
.text$mn:00001866                 mov     esp, ebp
.text$mn:00001868                 pop     ebp
.text$mn:00001869                 retn
.text$mn:00001869 ?max_size@?$allocator@D@std@@QBEIXZ endp
.text$mn:00001869
.text$mn:00001869 ; ---------------------------------------------------------------------------
.text$mn:0000186A                 align 4
.text$mn:0000186A _text$mn        ends
.text$mn:0000186A
.text$mn:0000186C ; ===========================================================================
.text$mn:0000186C
.text$mn:0000186C ; Segment type: Pure code
.text$mn:0000186C ; Segment permissions: Read/Execute
.text$mn:0000186C _text$mn        segment para public 'CODE' use32
.text$mn:0000186C                 assume cs:_text$mn
.text$mn:0000186C                 ;org 186Ch
.text$mn:0000186C ; COMDAT (pick any)
.text$mn:0000186C                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text$mn:0000186C
.text$mn:0000186C ; =============== S U B R O U T I N E =======================================
.text$mn:0000186C
.text$mn:0000186C ; Attributes: bp-based frame
.text$mn:0000186C
.text$mn:0000186C ; public: static unsigned int __cdecl std::allocator_traits<class std::allocator<char>>::max_size(class std::allocator<char> const &)
.text$mn:0000186C                 public ?max_size@?$allocator_traits@V?$allocator@D@std@@@std@@SAIABV?$allocator@D@2@@Z
.text$mn:0000186C ?max_size@?$allocator_traits@V?$allocator@D@std@@@std@@SAIABV?$allocator@D@2@@Z proc near
.text$mn:0000186C                                         ; CODE XREF: std::_Wrap_alloc<std::allocator<char>>::max_size(void)+Bp
.text$mn:0000186C
.text$mn:0000186C arg_0           = dword ptr  8
.text$mn:0000186C
.text$mn:0000186C                 push    ebp
.text$mn:0000186D                 mov     ebp, esp
.text$mn:0000186F                 mov     ecx, [ebp+arg_0]
.text$mn:00001872                 call    ?max_size@?$allocator@D@std@@QBEIXZ ; std::allocator<char>::max_size(void)
.text$mn:00001877                 pop     ebp
.text$mn:00001878                 retn
.text$mn:00001878 ?max_size@?$allocator_traits@V?$allocator@D@std@@@std@@SAIABV?$allocator@D@2@@Z endp
.text$mn:00001878
.text$mn:00001878 ; ---------------------------------------------------------------------------
.text$mn:00001879                 align 4
.text$mn:00001879 _text$mn        ends
.text$mn:00001879
.text$mn:0000187C ; ===========================================================================
.text$mn:0000187C
.text$mn:0000187C ; Segment type: Pure code
.text$mn:0000187C ; Segment permissions: Read/Execute
.text$mn:0000187C _text$mn        segment para public 'CODE' use32
.text$mn:0000187C                 assume cs:_text$mn
.text$mn:0000187C                 ;org 187Ch
.text$mn:0000187C ; COMDAT (pick any)
.text$mn:0000187C                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text$mn:0000187C
.text$mn:0000187C ; =============== S U B R O U T I N E =======================================
.text$mn:0000187C
.text$mn:0000187C ; Attributes: bp-based frame
.text$mn:0000187C
.text$mn:0000187C ; public: unsigned int __thiscall std::basic_string<char, struct std::char_traits<char>, class std::allocator<char>>::max_size(void)const
.text$mn:0000187C                 public ?max_size@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QBEIXZ
.text$mn:0000187C ?max_size@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QBEIXZ proc near
.text$mn:0000187C                                         ; CODE XREF: std::basic_string<char,std::char_traits<char>,std::allocator<char>>::_Copy(uint,uint)+3Bp
.text$mn:0000187C                                         ; std::basic_string<char,std::char_traits<char>,std::allocator<char>>::_Copy(uint,uint)+6Ap ...
.text$mn:0000187C
.text$mn:0000187C var_10          = dword ptr -10h
.text$mn:0000187C var_C           = dword ptr -0Ch
.text$mn:0000187C var_8           = dword ptr -8
.text$mn:0000187C var_1           = byte ptr -1
.text$mn:0000187C
.text$mn:0000187C                 push    ebp
.text$mn:0000187D                 mov     ebp, esp
.text$mn:0000187F                 sub     esp, 10h
.text$mn:00001882                 mov     [ebp+var_10], ecx
.text$mn:00001885                 lea     eax, [ebp+var_1]
.text$mn:00001888                 push    eax
.text$mn:00001889                 mov     ecx, [ebp+var_10]
.text$mn:0000188C                 call    ?_Getal@?$_String_alloc@$0A@U?$_String_base_types@DV?$allocator@D@std@@@std@@@std@@QBE?AU?$_Wrap_alloc@V?$allocator@D@std@@@2@XZ ; std::_String_alloc<0,std::_String_base_types<char,std::allocator<char>>>::_Getal(void)
.text$mn:00001891                 mov     ecx, eax
.text$mn:00001893                 call    ?max_size@?$_Wrap_alloc@V?$allocator@D@std@@@std@@QBEIXZ ; std::_Wrap_alloc<std::allocator<char>>::max_size(void)
.text$mn:00001898                 mov     [ebp+var_8], eax
.text$mn:0000189B                 cmp     [ebp+var_8], 1
.text$mn:0000189F                 ja      short loc_18AA
.text$mn:000018A1                 mov     [ebp+var_C], 1
.text$mn:000018A8                 jmp     short loc_18B3
.text$mn:000018AA ; ---------------------------------------------------------------------------
.text$mn:000018AA
.text$mn:000018AA loc_18AA:                               ; CODE XREF: std::basic_string<char,std::char_traits<char>,std::allocator<char>>::max_size(void)+23j
.text$mn:000018AA                 mov     ecx, [ebp+var_8]
.text$mn:000018AD                 sub     ecx, 1
.text$mn:000018B0                 mov     [ebp+var_C], ecx
.text$mn:000018B3
.text$mn:000018B3 loc_18B3:                               ; CODE XREF: std::basic_string<char,std::char_traits<char>,std::allocator<char>>::max_size(void)+2Cj
.text$mn:000018B3                 mov     eax, [ebp+var_C]
.text$mn:000018B6                 mov     esp, ebp
.text$mn:000018B8                 pop     ebp
.text$mn:000018B9                 retn
.text$mn:000018B9 ?max_size@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QBEIXZ endp
.text$mn:000018B9
.text$mn:000018B9 ; ---------------------------------------------------------------------------
.text$mn:000018BA                 align 4
.text$mn:000018BA _text$mn        ends
.text$mn:000018BA
.text$mn:000018BC ; ===========================================================================
.text$mn:000018BC
.text$mn:000018BC ; Segment type: Pure code
.text$mn:000018BC ; Segment permissions: Read/Execute
.text$mn:000018BC _text$mn        segment para public 'CODE' use32
.text$mn:000018BC                 assume cs:_text$mn
.text$mn:000018BC                 ;org 18BCh
.text$mn:000018BC ; COMDAT (pick any)
.text$mn:000018BC                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text$mn:000018BC
.text$mn:000018BC ; =============== S U B R O U T I N E =======================================
.text$mn:000018BC
.text$mn:000018BC ; Attributes: bp-based frame
.text$mn:000018BC
.text$mn:000018BC ; public: virtual class std::basic_string<char, struct std::char_traits<char>, class std::allocator<char>> __thiscall std::_Generic_error_category::message(int)const
.text$mn:000018BC                 public ?message@_Generic_error_category@std@@UBE?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@2@H@Z
.text$mn:000018BC ?message@_Generic_error_category@std@@UBE?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@2@H@Z proc near
.text$mn:000018BC                                         ; CODE XREF: std::_Iostream_error_category::message(int)+64p
.text$mn:000018BC                                         ; DATA XREF: .rdata:00001F88o
.text$mn:000018BC
.text$mn:000018BC var_1C          = dword ptr -1Ch
.text$mn:000018BC var_18          = dword ptr -18h
.text$mn:000018BC Str             = dword ptr -14h
.text$mn:000018BC var_10          = dword ptr -10h
.text$mn:000018BC var_C           = dword ptr -0Ch
.text$mn:000018BC var_4           = dword ptr -4
.text$mn:000018BC arg_0           = dword ptr  8
.text$mn:000018BC arg_4           = dword ptr  0Ch
.text$mn:000018BC
.text$mn:000018BC                 push    ebp
.text$mn:000018BD                 mov     ebp, esp
.text$mn:000018BF                 push    0FFFFFFFFh
.text$mn:000018C1                 push    offset __ehhandler$?message@_Generic_error_category@std@@UBE?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@2@H@Z
.text$mn:000018C6                 mov     eax, large fs:0
.text$mn:000018CC                 push    eax
.text$mn:000018CD                 sub     esp, 10h
.text$mn:000018D0                 mov     eax, dword ptr ds:___security_cookie
.text$mn:000018D5                 xor     eax, ebp
.text$mn:000018D7                 push    eax
.text$mn:000018D8                 lea     eax, [ebp+var_C]
.text$mn:000018DB                 mov     large fs:0, eax
.text$mn:000018E1                 mov     [ebp+var_1C], ecx
.text$mn:000018E4                 mov     [ebp+var_18], 0
.text$mn:000018EB                 mov     eax, [ebp+arg_4]
.text$mn:000018EE                 push    eax             ; int
.text$mn:000018EF                 call    ?_Syserror_map@std@@YAPBDH@Z ; std::_Syserror_map(int)
.text$mn:000018F4                 add     esp, 4
.text$mn:000018F7                 mov     [ebp+var_10], eax
.text$mn:000018FA                 cmp     [ebp+var_10], 0
.text$mn:000018FE                 jz      short loc_1908
.text$mn:00001900                 mov     ecx, [ebp+var_10]
.text$mn:00001903                 mov     [ebp+Str], ecx
.text$mn:00001906                 jmp     short loc_190F
.text$mn:00001908 ; ---------------------------------------------------------------------------
.text$mn:00001908
.text$mn:00001908 loc_1908:                               ; CODE XREF: std::_Generic_error_category::message(int)+42j
.text$mn:00001908                 mov     [ebp+Str], offset ??_C@_0O@BFJCFAAK@unknown?5error?$AA@ ; "unknown error"
.text$mn:0000190F
.text$mn:0000190F loc_190F:                               ; CODE XREF: std::_Generic_error_category::message(int)+4Aj
.text$mn:0000190F                 mov     edx, [ebp+Str]
.text$mn:00001912                 push    edx             ; Str
.text$mn:00001913                 mov     ecx, [ebp+arg_0]
.text$mn:00001916                 call    ??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@PBD@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char>>::basic_string<char,std::char_traits<char>,std::allocator<char>>(char const *)
.text$mn:0000191B                 mov     [ebp+var_4], 0
.text$mn:00001922                 mov     eax, [ebp+var_18]
.text$mn:00001925                 or      eax, 1
.text$mn:00001928                 mov     [ebp+var_18], eax
.text$mn:0000192B                 mov     eax, [ebp+arg_0]
.text$mn:0000192E                 mov     ecx, [ebp+var_C]
.text$mn:00001931                 mov     large fs:0, ecx
.text$mn:00001938                 pop     ecx
.text$mn:00001939                 mov     esp, ebp
.text$mn:0000193B                 pop     ebp
.text$mn:0000193C                 retn    8
.text$mn:0000193C ?message@_Generic_error_category@std@@UBE?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@2@H@Z endp
.text$mn:0000193C
.text$mn:0000193C ; ---------------------------------------------------------------------------
.text$mn:0000193F                 align 10h
.text$mn:0000193F _text$mn        ends
.text$mn:0000193F
.text$x:00001940 ; ===========================================================================
.text$x:00001940
.text$x:00001940 ; Segment type: Pure code
.text$x:00001940 ; Segment permissions: Read/Execute
.text$x:00001940 _text$x         segment para public 'CODE' use32
.text$x:00001940                 assume cs:_text$x
.text$x:00001940                 ;org 1940h
.text$x:00001940 ; COMDAT (pick associative to section at 18BC)
.text$x:00001940                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text$x:00001940
.text$x:00001940 ; =============== S U B R O U T I N E =======================================
.text$x:00001940
.text$x:00001940
.text$x:00001940 __unwindfunclet$?message@_Generic_error_category@std@@UBE?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@2@H@Z$0 proc near
.text$x:00001940                                         ; DATA XREF: .xdata$x:00001DA8o
.text$x:00001940                 mov     eax, [ebp-18h]
.text$x:00001943                 and     eax, 1
.text$x:00001946                 jz      $LN6
.text$x:0000194C                 and     dword ptr [ebp-18h], 0FFFFFFFEh
.text$x:00001950                 mov     ecx, [ebp+8]
.text$x:00001953                 jmp     ??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char>>::~basic_string<char,std::char_traits<char>,std::allocator<char>>(void)
.text$x:00001958 ; ---------------------------------------------------------------------------
.text$x:00001958
.text$x:00001958 $LN6:                                   ; CODE XREF: __unwindfunclet$?message@_Generic_error_category@std@@UBE?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@2@H@Z$0+6j
.text$x:00001958                 retn
.text$x:00001958 __unwindfunclet$?message@_Generic_error_category@std@@UBE?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@2@H@Z$0 endp
.text$x:00001958
.text$x:00001959
.text$x:00001959 ; =============== S U B R O U T I N E =======================================
.text$x:00001959
.text$x:00001959
.text$x:00001959 __ehhandler$?message@_Generic_error_category@std@@UBE?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@2@H@Z proc near
.text$x:00001959                                         ; DATA XREF: std::_Generic_error_category::message(int)+5o
.text$x:00001959
.text$x:00001959 arg_4           = dword ptr  8
.text$x:00001959
.text$x:00001959                 mov     edx, [esp+arg_4]
.text$x:0000195D                 lea     eax, [edx+0Ch]
.text$x:00001960                 mov     ecx, [edx-14h]
.text$x:00001963                 xor     ecx, eax
.text$x:00001965                 call    @__security_check_cookie@4 ; __security_check_cookie(x)
.text$x:0000196A                 mov     eax, offset __ehfuncinfo$?message@_Generic_error_category@std@@UBE?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@2@H@Z
.text$x:0000196F                 jmp     ___CxxFrameHandler3
.text$x:0000196F __ehhandler$?message@_Generic_error_category@std@@UBE?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@2@H@Z endp
.text$x:0000196F
.text$x:0000196F _text$x         ends
.text$x:0000196F
.text$mn:00001974 ; ===========================================================================
.text$mn:00001974
.text$mn:00001974 ; Segment type: Pure code
.text$mn:00001974 ; Segment permissions: Read/Execute
.text$mn:00001974 _text$mn        segment para public 'CODE' use32
.text$mn:00001974                 assume cs:_text$mn
.text$mn:00001974                 ;org 1974h
.text$mn:00001974 ; COMDAT (pick any)
.text$mn:00001974                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text$mn:00001974
.text$mn:00001974 ; =============== S U B R O U T I N E =======================================
.text$mn:00001974
.text$mn:00001974 ; Attributes: bp-based frame
.text$mn:00001974
.text$mn:00001974 ; public: virtual class std::basic_string<char, struct std::char_traits<char>, class std::allocator<char>> __thiscall std::_Iostream_error_category::message(int)const
.text$mn:00001974                 public ?message@_Iostream_error_category@std@@UBE?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@2@H@Z
.text$mn:00001974 ?message@_Iostream_error_category@std@@UBE?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@2@H@Z proc near
.text$mn:00001974                                         ; DATA XREF: .rdata:00001FBCo
.text$mn:00001974
.text$mn:00001974 var_14          = dword ptr -14h
.text$mn:00001974 var_10          = dword ptr -10h
.text$mn:00001974 var_C           = dword ptr -0Ch
.text$mn:00001974 var_4           = dword ptr -4
.text$mn:00001974 arg_0           = dword ptr  8
.text$mn:00001974 arg_4           = dword ptr  0Ch
.text$mn:00001974
.text$mn:00001974                 push    ebp
.text$mn:00001975                 mov     ebp, esp
.text$mn:00001977                 push    0FFFFFFFFh
.text$mn:00001979                 push    offset __ehhandler$?message@_Iostream_error_category@std@@UBE?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@2@H@Z
.text$mn:0000197E                 mov     eax, large fs:0
.text$mn:00001984                 push    eax
.text$mn:00001985                 sub     esp, 8
.text$mn:00001988                 mov     eax, dword ptr ds:___security_cookie
.text$mn:0000198D                 xor     eax, ebp
.text$mn:0000198F                 push    eax
.text$mn:00001990                 lea     eax, [ebp+var_C]
.text$mn:00001993                 mov     large fs:0, eax
.text$mn:00001999                 mov     [ebp+var_14], ecx
.text$mn:0000199C                 mov     [ebp+var_10], 0
.text$mn:000019A3                 cmp     [ebp+arg_4], 1
.text$mn:000019A7                 jnz     short loc_19CD
.text$mn:000019A9                 push    offset ??_C@_0BG@PADBLCHM@iostream?5stream?5error?$AA@ ; "iostream stream error"
.text$mn:000019AE                 mov     ecx, [ebp+arg_0]
.text$mn:000019B1                 call    ??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@PBD@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char>>::basic_string<char,std::char_traits<char>,std::allocator<char>>(char const *)
.text$mn:000019B6                 mov     [ebp+var_4], 0
.text$mn:000019BD                 mov     eax, [ebp+var_10]
.text$mn:000019C0                 or      eax, 1
.text$mn:000019C3                 mov     [ebp+var_10], eax
.text$mn:000019C6                 mov     eax, [ebp+arg_0]
.text$mn:000019C9                 jmp     short loc_19F0
.text$mn:000019CB ; ---------------------------------------------------------------------------
.text$mn:000019CB                 jmp     short loc_19F0
.text$mn:000019CD ; ---------------------------------------------------------------------------
.text$mn:000019CD
.text$mn:000019CD loc_19CD:                               ; CODE XREF: std::_Iostream_error_category::message(int)+33j
.text$mn:000019CD                 mov     ecx, [ebp+arg_4]
.text$mn:000019D0                 push    ecx
.text$mn:000019D1                 mov     edx, [ebp+arg_0]
.text$mn:000019D4                 push    edx
.text$mn:000019D5                 mov     ecx, [ebp+var_14]
.text$mn:000019D8                 call    ?message@_Generic_error_category@std@@UBE?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@2@H@Z ; std::_Generic_error_category::message(int)
.text$mn:000019DD                 mov     [ebp+var_4], 0
.text$mn:000019E4                 mov     eax, [ebp+var_10]
.text$mn:000019E7                 or      eax, 1
.text$mn:000019EA                 mov     [ebp+var_10], eax
.text$mn:000019ED                 mov     eax, [ebp+arg_0]
.text$mn:000019F0
.text$mn:000019F0 loc_19F0:                               ; CODE XREF: std::_Iostream_error_category::message(int)+55j
.text$mn:000019F0                                         ; std::_Iostream_error_category::message(int)+57j
.text$mn:000019F0                 mov     ecx, [ebp+var_C]
.text$mn:000019F3                 mov     large fs:0, ecx
.text$mn:000019FA                 pop     ecx
.text$mn:000019FB                 mov     esp, ebp
.text$mn:000019FD                 pop     ebp
.text$mn:000019FE                 retn    8
.text$mn:000019FE ?message@_Iostream_error_category@std@@UBE?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@2@H@Z endp
.text$mn:000019FE
.text$mn:000019FE ; ---------------------------------------------------------------------------
.text$mn:00001A01                 align 4
.text$mn:00001A01 _text$mn        ends
.text$mn:00001A01
.text$x:00001A04 ; ===========================================================================
.text$x:00001A04
.text$x:00001A04 ; Segment type: Pure code
.text$x:00001A04 ; Segment permissions: Read/Execute
.text$x:00001A04 _text$x         segment para public 'CODE' use32
.text$x:00001A04                 assume cs:_text$x
.text$x:00001A04                 ;org 1A04h
.text$x:00001A04 ; COMDAT (pick associative to section at 1974)
.text$x:00001A04                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text$x:00001A04
.text$x:00001A04 ; =============== S U B R O U T I N E =======================================
.text$x:00001A04
.text$x:00001A04
.text$x:00001A04 __unwindfunclet$?message@_Iostream_error_category@std@@UBE?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@2@H@Z$0 proc near
.text$x:00001A04                                         ; DATA XREF: .xdata$x:00001E2Co
.text$x:00001A04                 mov     eax, [ebp-10h]
.text$x:00001A07                 and     eax, 1
.text$x:00001A0A                 jz      $LN6_0
.text$x:00001A10                 and     dword ptr [ebp-10h], 0FFFFFFFEh
.text$x:00001A14                 mov     ecx, [ebp+8]
.text$x:00001A17                 jmp     ??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char>>::~basic_string<char,std::char_traits<char>,std::allocator<char>>(void)
.text$x:00001A1C ; ---------------------------------------------------------------------------
.text$x:00001A1C
.text$x:00001A1C $LN6_0:                                 ; CODE XREF: __unwindfunclet$?message@_Iostream_error_category@std@@UBE?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@2@H@Z$0+6j
.text$x:00001A1C                 retn
.text$x:00001A1C __unwindfunclet$?message@_Iostream_error_category@std@@UBE?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@2@H@Z$0 endp
.text$x:00001A1C
.text$x:00001A1D
.text$x:00001A1D ; =============== S U B R O U T I N E =======================================
.text$x:00001A1D
.text$x:00001A1D
.text$x:00001A1D __ehhandler$?message@_Iostream_error_category@std@@UBE?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@2@H@Z proc near
.text$x:00001A1D                                         ; DATA XREF: std::_Iostream_error_category::message(int)+5o
.text$x:00001A1D
.text$x:00001A1D arg_4           = dword ptr  8
.text$x:00001A1D
.text$x:00001A1D                 mov     edx, [esp+arg_4]
.text$x:00001A21                 lea     eax, [edx+0Ch]
.text$x:00001A24                 mov     ecx, [edx-0Ch]
.text$x:00001A27                 xor     ecx, eax
.text$x:00001A29                 call    @__security_check_cookie@4 ; __security_check_cookie(x)
.text$x:00001A2E                 mov     eax, offset __ehfuncinfo$?message@_Iostream_error_category@std@@UBE?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@2@H@Z
.text$x:00001A33                 jmp     ___CxxFrameHandler3
.text$x:00001A33 __ehhandler$?message@_Iostream_error_category@std@@UBE?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@2@H@Z endp
.text$x:00001A33
.text$x:00001A33 _text$x         ends
.text$x:00001A33
.text$mn:00001A38 ; ===========================================================================
.text$mn:00001A38
.text$mn:00001A38 ; Segment type: Pure code
.text$mn:00001A38 ; Segment permissions: Read/Execute
.text$mn:00001A38 _text$mn        segment para public 'CODE' use32
.text$mn:00001A38                 assume cs:_text$mn
.text$mn:00001A38                 ;org 1A38h
.text$mn:00001A38 ; COMDAT (pick any)
.text$mn:00001A38                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text$mn:00001A38
.text$mn:00001A38 ; =============== S U B R O U T I N E =======================================
.text$mn:00001A38
.text$mn:00001A38 ; Attributes: bp-based frame
.text$mn:00001A38
.text$mn:00001A38 ; public: virtual class std::basic_string<char, struct std::char_traits<char>, class std::allocator<char>> __thiscall std::_System_error_category::message(int)const
.text$mn:00001A38                 public ?message@_System_error_category@std@@UBE?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@2@H@Z
.text$mn:00001A38 ?message@_System_error_category@std@@UBE?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@2@H@Z proc near
.text$mn:00001A38                                         ; DATA XREF: .rdata:00001FFCo
.text$mn:00001A38
.text$mn:00001A38 var_1C          = dword ptr -1Ch
.text$mn:00001A38 var_18          = dword ptr -18h
.text$mn:00001A38 Str             = dword ptr -14h
.text$mn:00001A38 var_10          = dword ptr -10h
.text$mn:00001A38 var_C           = dword ptr -0Ch
.text$mn:00001A38 var_4           = dword ptr -4
.text$mn:00001A38 arg_0           = dword ptr  8
.text$mn:00001A38 arg_4           = dword ptr  0Ch
.text$mn:00001A38
.text$mn:00001A38                 push    ebp
.text$mn:00001A39                 mov     ebp, esp
.text$mn:00001A3B                 push    0FFFFFFFFh
.text$mn:00001A3D                 push    offset __ehhandler$?message@_System_error_category@std@@UBE?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@2@H@Z
.text$mn:00001A42                 mov     eax, large fs:0
.text$mn:00001A48                 push    eax
.text$mn:00001A49                 sub     esp, 10h
.text$mn:00001A4C                 mov     eax, dword ptr ds:___security_cookie
.text$mn:00001A51                 xor     eax, ebp
.text$mn:00001A53                 push    eax
.text$mn:00001A54                 lea     eax, [ebp+var_C]
.text$mn:00001A57                 mov     large fs:0, eax
.text$mn:00001A5D                 mov     [ebp+var_1C], ecx
.text$mn:00001A60                 mov     [ebp+var_18], 0
.text$mn:00001A67                 mov     eax, [ebp+arg_4]
.text$mn:00001A6A                 push    eax             ; int
.text$mn:00001A6B                 call    ?_Winerror_map@std@@YAPBDH@Z ; std::_Winerror_map(int)
.text$mn:00001A70                 add     esp, 4
.text$mn:00001A73                 mov     [ebp+var_10], eax
.text$mn:00001A76                 cmp     [ebp+var_10], 0
.text$mn:00001A7A                 jz      short loc_1A84
.text$mn:00001A7C                 mov     ecx, [ebp+var_10]
.text$mn:00001A7F                 mov     [ebp+Str], ecx
.text$mn:00001A82                 jmp     short loc_1A8B
.text$mn:00001A84 ; ---------------------------------------------------------------------------
.text$mn:00001A84
.text$mn:00001A84 loc_1A84:                               ; CODE XREF: std::_System_error_category::message(int)+42j
.text$mn:00001A84                 mov     [ebp+Str], offset ??_C@_0O@BFJCFAAK@unknown?5error?$AA@ ; "unknown error"
.text$mn:00001A8B
.text$mn:00001A8B loc_1A8B:                               ; CODE XREF: std::_System_error_category::message(int)+4Aj
.text$mn:00001A8B                 mov     edx, [ebp+Str]
.text$mn:00001A8E                 push    edx             ; Str
.text$mn:00001A8F                 mov     ecx, [ebp+arg_0]
.text$mn:00001A92                 call    ??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@PBD@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char>>::basic_string<char,std::char_traits<char>,std::allocator<char>>(char const *)
.text$mn:00001A97                 mov     [ebp+var_4], 0
.text$mn:00001A9E                 mov     eax, [ebp+var_18]
.text$mn:00001AA1                 or      eax, 1
.text$mn:00001AA4                 mov     [ebp+var_18], eax
.text$mn:00001AA7                 mov     eax, [ebp+arg_0]
.text$mn:00001AAA                 mov     ecx, [ebp+var_C]
.text$mn:00001AAD                 mov     large fs:0, ecx
.text$mn:00001AB4                 pop     ecx
.text$mn:00001AB5                 mov     esp, ebp
.text$mn:00001AB7                 pop     ebp
.text$mn:00001AB8                 retn    8
.text$mn:00001AB8 ?message@_System_error_category@std@@UBE?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@2@H@Z endp
.text$mn:00001AB8
.text$mn:00001AB8 ; ---------------------------------------------------------------------------
.text$mn:00001ABB                 align 4
.text$mn:00001ABB _text$mn        ends
.text$mn:00001ABB
.text$x:00001ABC ; ===========================================================================
.text$x:00001ABC
.text$x:00001ABC ; Segment type: Pure code
.text$x:00001ABC ; Segment permissions: Read/Execute
.text$x:00001ABC _text$x         segment para public 'CODE' use32
.text$x:00001ABC                 assume cs:_text$x
.text$x:00001ABC                 ;org 1ABCh
.text$x:00001ABC ; COMDAT (pick associative to section at 1A38)
.text$x:00001ABC                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text$x:00001ABC
.text$x:00001ABC ; =============== S U B R O U T I N E =======================================
.text$x:00001ABC
.text$x:00001ABC
.text$x:00001ABC __unwindfunclet$?message@_System_error_category@std@@UBE?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@2@H@Z$0 proc near
.text$x:00001ABC                                         ; DATA XREF: .xdata$x:00001EB0o
.text$x:00001ABC                 mov     eax, [ebp-18h]
.text$x:00001ABF                 and     eax, 1
.text$x:00001AC2                 jz      $LN6_1
.text$x:00001AC8                 and     dword ptr [ebp-18h], 0FFFFFFFEh
.text$x:00001ACC                 mov     ecx, [ebp+8]
.text$x:00001ACF                 jmp     ??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char>>::~basic_string<char,std::char_traits<char>,std::allocator<char>>(void)
.text$x:00001AD4 ; ---------------------------------------------------------------------------
.text$x:00001AD4
.text$x:00001AD4 $LN6_1:                                 ; CODE XREF: __unwindfunclet$?message@_System_error_category@std@@UBE?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@2@H@Z$0+6j
.text$x:00001AD4                 retn
.text$x:00001AD4 __unwindfunclet$?message@_System_error_category@std@@UBE?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@2@H@Z$0 endp
.text$x:00001AD4
.text$x:00001AD5
.text$x:00001AD5 ; =============== S U B R O U T I N E =======================================
.text$x:00001AD5
.text$x:00001AD5
.text$x:00001AD5 __ehhandler$?message@_System_error_category@std@@UBE?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@2@H@Z proc near
.text$x:00001AD5                                         ; DATA XREF: std::_System_error_category::message(int)+5o
.text$x:00001AD5
.text$x:00001AD5 arg_4           = dword ptr  8
.text$x:00001AD5
.text$x:00001AD5                 mov     edx, [esp+arg_4]
.text$x:00001AD9                 lea     eax, [edx+0Ch]
.text$x:00001ADC                 mov     ecx, [edx-14h]
.text$x:00001ADF                 xor     ecx, eax
.text$x:00001AE1                 call    @__security_check_cookie@4 ; __security_check_cookie(x)
.text$x:00001AE6                 mov     eax, offset __ehfuncinfo$?message@_System_error_category@std@@UBE?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@2@H@Z
.text$x:00001AEB                 jmp     ___CxxFrameHandler3
.text$x:00001AEB __ehhandler$?message@_System_error_category@std@@UBE?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@2@H@Z endp
.text$x:00001AEB
.text$x:00001AEB _text$x         ends
.text$x:00001AEB
.text$mn:00001AF0 ; ===========================================================================
.text$mn:00001AF0
.text$mn:00001AF0 ; Segment type: Pure code
.text$mn:00001AF0 ; Segment permissions: Read/Execute
.text$mn:00001AF0 _text$mn        segment para public 'CODE' use32
.text$mn:00001AF0                 assume cs:_text$mn
.text$mn:00001AF0                 ;org 1AF0h
.text$mn:00001AF0 ; COMDAT (pick any)
.text$mn:00001AF0                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text$mn:00001AF0
.text$mn:00001AF0 ; =============== S U B R O U T I N E =======================================
.text$mn:00001AF0
.text$mn:00001AF0 ; Attributes: bp-based frame
.text$mn:00001AF0
.text$mn:00001AF0 ; int __cdecl std::char_traits<char>::move(void *Dst, void *Src, size_t Size)
.text$mn:00001AF0                 public ?move@?$char_traits@D@std@@SAPADPADPBDI@Z
.text$mn:00001AF0 ?move@?$char_traits@D@std@@SAPADPADPBDI@Z proc near
.text$mn:00001AF0                                         ; CODE XREF: std::basic_string<char,std::char_traits<char>,std::allocator<char>>::erase(uint,uint)+6Ap
.text$mn:00001AF0
.text$mn:00001AF0 var_4           = dword ptr -4
.text$mn:00001AF0 Dst             = dword ptr  8
.text$mn:00001AF0 Src             = dword ptr  0Ch
.text$mn:00001AF0 Size            = dword ptr  10h
.text$mn:00001AF0
.text$mn:00001AF0                 push    ebp
.text$mn:00001AF1                 mov     ebp, esp
.text$mn:00001AF3                 push    ecx
.text$mn:00001AF4                 cmp     [ebp+Size], 0
.text$mn:00001AF8                 jnz     short loc_1B02
.text$mn:00001AFA                 mov     eax, [ebp+Dst]
.text$mn:00001AFD                 mov     [ebp+var_4], eax
.text$mn:00001B00                 jmp     short loc_1B19
.text$mn:00001B02 ; ---------------------------------------------------------------------------
.text$mn:00001B02
.text$mn:00001B02 loc_1B02:                               ; CODE XREF: std::char_traits<char>::move(char *,char const *,uint)+8j
.text$mn:00001B02                 mov     ecx, [ebp+Size]
.text$mn:00001B05                 push    ecx             ; Size
.text$mn:00001B06                 mov     edx, [ebp+Src]
.text$mn:00001B09                 push    edx             ; Src
.text$mn:00001B0A                 mov     eax, [ebp+Dst]
.text$mn:00001B0D                 push    eax             ; Dst
.text$mn:00001B0E                 call    _memmove
.text$mn:00001B13                 add     esp, 0Ch
.text$mn:00001B16                 mov     [ebp+var_4], eax
.text$mn:00001B19
.text$mn:00001B19 loc_1B19:                               ; CODE XREF: std::char_traits<char>::move(char *,char const *,uint)+10j
.text$mn:00001B19                 mov     eax, [ebp+var_4]
.text$mn:00001B1C                 mov     esp, ebp
.text$mn:00001B1E                 pop     ebp
.text$mn:00001B1F                 retn
.text$mn:00001B1F ?move@?$char_traits@D@std@@SAPADPADPBDI@Z endp
.text$mn:00001B1F
.text$mn:00001B1F _text$mn        ends
.text$mn:00001B1F
.text$mn:00001B20 ; ===========================================================================
.text$mn:00001B20
.text$mn:00001B20 ; Segment type: Pure code
.text$mn:00001B20 ; Segment permissions: Read/Execute
.text$mn:00001B20 _text$mn        segment para public 'CODE' use32
.text$mn:00001B20                 assume cs:_text$mn
.text$mn:00001B20                 ;org 1B20h
.text$mn:00001B20 ; COMDAT (pick any)
.text$mn:00001B20                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text$mn:00001B20
.text$mn:00001B20 ; =============== S U B R O U T I N E =======================================
.text$mn:00001B20
.text$mn:00001B20 ; Attributes: bp-based frame
.text$mn:00001B20
.text$mn:00001B20 ; const char *__thiscall std::_Generic_error_category::name(std::_Generic_error_category *__hidden this)
.text$mn:00001B20                 public ?name@_Generic_error_category@std@@UBEPBDXZ
.text$mn:00001B20 ?name@_Generic_error_category@std@@UBEPBDXZ proc near
.text$mn:00001B20                                         ; DATA XREF: .rdata:00001F84o
.text$mn:00001B20
.text$mn:00001B20 var_4           = dword ptr -4
.text$mn:00001B20
.text$mn:00001B20                 push    ebp
.text$mn:00001B21                 mov     ebp, esp
.text$mn:00001B23                 push    ecx
.text$mn:00001B24                 mov     [ebp+var_4], ecx
.text$mn:00001B27                 mov     eax, offset ??_C@_07DCLBNMLN@generic?$AA@ ; "generic"
.text$mn:00001B2C                 mov     esp, ebp
.text$mn:00001B2E                 pop     ebp
.text$mn:00001B2F                 retn
.text$mn:00001B2F ?name@_Generic_error_category@std@@UBEPBDXZ endp
.text$mn:00001B2F
.text$mn:00001B2F _text$mn        ends
.text$mn:00001B2F
.text$mn:00001B30 ; ===========================================================================
.text$mn:00001B30
.text$mn:00001B30 ; Segment type: Pure code
.text$mn:00001B30 ; Segment permissions: Read/Execute
.text$mn:00001B30 _text$mn        segment para public 'CODE' use32
.text$mn:00001B30                 assume cs:_text$mn
.text$mn:00001B30                 ;org 1B30h
.text$mn:00001B30 ; COMDAT (pick any)
.text$mn:00001B30                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text$mn:00001B30
.text$mn:00001B30 ; =============== S U B R O U T I N E =======================================
.text$mn:00001B30
.text$mn:00001B30 ; Attributes: bp-based frame
.text$mn:00001B30
.text$mn:00001B30 ; const char *__thiscall std::_Iostream_error_category::name(std::_Iostream_error_category *__hidden this)
.text$mn:00001B30                 public ?name@_Iostream_error_category@std@@UBEPBDXZ
.text$mn:00001B30 ?name@_Iostream_error_category@std@@UBEPBDXZ proc near
.text$mn:00001B30                                         ; DATA XREF: .rdata:00001FB8o
.text$mn:00001B30
.text$mn:00001B30 var_4           = dword ptr -4
.text$mn:00001B30
.text$mn:00001B30                 push    ebp
.text$mn:00001B31                 mov     ebp, esp
.text$mn:00001B33                 push    ecx
.text$mn:00001B34                 mov     [ebp+var_4], ecx
.text$mn:00001B37                 mov     eax, offset ??_C@_08LLGCOLLL@iostream?$AA@ ; "iostream"
.text$mn:00001B3C                 mov     esp, ebp
.text$mn:00001B3E                 pop     ebp
.text$mn:00001B3F                 retn
.text$mn:00001B3F ?name@_Iostream_error_category@std@@UBEPBDXZ endp
.text$mn:00001B3F
.text$mn:00001B3F _text$mn        ends
.text$mn:00001B3F
.text$mn:00001B40 ; ===========================================================================
.text$mn:00001B40
.text$mn:00001B40 ; Segment type: Pure code
.text$mn:00001B40 ; Segment permissions: Read/Execute
.text$mn:00001B40 _text$mn        segment para public 'CODE' use32
.text$mn:00001B40                 assume cs:_text$mn
.text$mn:00001B40                 ;org 1B40h
.text$mn:00001B40 ; COMDAT (pick any)
.text$mn:00001B40                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text$mn:00001B40
.text$mn:00001B40 ; =============== S U B R O U T I N E =======================================
.text$mn:00001B40
.text$mn:00001B40 ; Attributes: bp-based frame
.text$mn:00001B40
.text$mn:00001B40 ; const char *__thiscall std::_System_error_category::name(std::_System_error_category *__hidden this)
.text$mn:00001B40                 public ?name@_System_error_category@std@@UBEPBDXZ
.text$mn:00001B40 ?name@_System_error_category@std@@UBEPBDXZ proc near
.text$mn:00001B40                                         ; DATA XREF: .rdata:00001FF8o
.text$mn:00001B40
.text$mn:00001B40 var_4           = dword ptr -4
.text$mn:00001B40
.text$mn:00001B40                 push    ebp
.text$mn:00001B41                 mov     ebp, esp
.text$mn:00001B43                 push    ecx
.text$mn:00001B44                 mov     [ebp+var_4], ecx
.text$mn:00001B47                 mov     eax, offset ??_C@_06FHFOAHML@system?$AA@ ; "system"
.text$mn:00001B4C                 mov     esp, ebp
.text$mn:00001B4E                 pop     ebp
.text$mn:00001B4F                 retn
.text$mn:00001B4F ?name@_System_error_category@std@@UBEPBDXZ endp
.text$mn:00001B4F
.text$mn:00001B4F _text$mn        ends
.text$mn:00001B4F
.text$mn:00001B50 ; ===========================================================================
.text$mn:00001B50
.text$mn:00001B50 ; Segment type: Pure code
.text$mn:00001B50 ; Segment permissions: Read/Execute
.text$mn:00001B50 _text$mn        segment para public 'CODE' use32
.text$mn:00001B50                 assume cs:_text$mn
.text$mn:00001B50                 ;org 1B50h
.text$mn:00001B50 ; COMDAT (pick any)
.text$mn:00001B50                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text$mn:00001B50
.text$mn:00001B50 ; =============== S U B R O U T I N E =======================================
.text$mn:00001B50
.text$mn:00001B50 ; Attributes: bp-based frame
.text$mn:00001B50
.text$mn:00001B50 ; public: unsigned int __thiscall std::basic_string<char, struct std::char_traits<char>, class std::allocator<char>>::size(void)const
.text$mn:00001B50                 public ?size@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QBEIXZ
.text$mn:00001B50 ?size@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QBEIXZ proc near
.text$mn:00001B50                                         ; CODE XREF: std::basic_string<char,std::char_traits<char>,std::allocator<char>>::assign(std::basic_string<char,std::char_traits<char>,std::allocator<char>> const &,uint,uint)+Cp
.text$mn:00001B50                                         ; std::basic_string<char,std::char_traits<char>,std::allocator<char>>::assign(std::basic_string<char,std::char_traits<char>,std::allocator<char>> const &,uint,uint)+21p
.text$mn:00001B50
.text$mn:00001B50 var_4           = dword ptr -4
.text$mn:00001B50
.text$mn:00001B50                 push    ebp
.text$mn:00001B51                 mov     ebp, esp
.text$mn:00001B53                 push    ecx
.text$mn:00001B54                 mov     [ebp+var_4], ecx
.text$mn:00001B57                 mov     eax, [ebp+var_4]
.text$mn:00001B5A                 mov     eax, [eax+14h]
.text$mn:00001B5D                 mov     esp, ebp
.text$mn:00001B5F                 pop     ebp
.text$mn:00001B60                 retn
.text$mn:00001B60 ?size@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QBEIXZ endp
.text$mn:00001B60
.text$mn:00001B60 ; ---------------------------------------------------------------------------
.text$mn:00001B61                 align 4
.text$mn:00001B61 _text$mn        ends
.text$mn:00001B61
.text$mn:00001B64 ; ===========================================================================
.text$mn:00001B64
.text$mn:00001B64 ; Segment type: Pure code
.text$mn:00001B64 ; Segment permissions: Read/Execute
.text$mn:00001B64 _text$mn        segment para public 'CODE' use32
.text$mn:00001B64                 assume cs:_text$mn
.text$mn:00001B64                 ;org 1B64h
.text$mn:00001B64 ; COMDAT (pick any)
.text$mn:00001B64                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text$mn:00001B64
.text$mn:00001B64 ; =============== S U B R O U T I N E =======================================
.text$mn:00001B64
.text$mn:00001B64 ; Attributes: bp-based frame
.text$mn:00001B64
.text$mn:00001B64 ; const struct std::error_category *__cdecl std::system_category()
.text$mn:00001B64                 public ?system_category@std@@YAABVerror_category@1@XZ
.text$mn:00001B64 ?system_category@std@@YAABVerror_category@1@XZ proc near
.text$mn:00001B64                                         ; CODE XREF: std::_System_error_category::default_error_condition(int):loc_169Cp
.text$mn:00001B64                 push    ebp
.text$mn:00001B65                 mov     ebp, esp
.text$mn:00001B67                 mov     eax, offset ?_System_object@?$_Error_objects@H@std@@2V_System_error_category@2@A ; std::_System_error_category std::_Error_objects<int>::_System_object
.text$mn:00001B6C                 pop     ebp
.text$mn:00001B6D                 retn
.text$mn:00001B6D ?system_category@std@@YAABVerror_category@1@XZ endp
.text$mn:00001B6D
.text$mn:00001B6D ; ---------------------------------------------------------------------------
.text$mn:00001B6E                 align 10h
.text$mn:00001B6E _text$mn        ends
.text$mn:00001B6E
.text$mn:00001B70 ; ===========================================================================
.text$mn:00001B70
.text$mn:00001B70 ; Segment type: Pure code
.text$mn:00001B70 ; Segment permissions: Read/Execute
.text$mn:00001B70 _text$mn        segment para public 'CODE' use32
.text$mn:00001B70                 assume cs:_text$mn
.text$mn:00001B70                 ;org 1B70h
.text$mn:00001B70 ; COMDAT (pick any)
.text$mn:00001B70                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text$mn:00001B70
.text$mn:00001B70 ; =============== S U B R O U T I N E =======================================
.text$mn:00001B70
.text$mn:00001B70 ; Attributes: bp-based frame
.text$mn:00001B70
.text$mn:00001B70 ; int __thiscall std::error_code::value(std::error_code *__hidden this)
.text$mn:00001B70                 public ?value@error_code@std@@QBEHXZ
.text$mn:00001B70 ?value@error_code@std@@QBEHXZ proc near ; CODE XREF: std::error_category::equivalent(std::error_code const &,int)+24p
.text$mn:00001B70
.text$mn:00001B70 var_4           = dword ptr -4
.text$mn:00001B70
.text$mn:00001B70                 push    ebp
.text$mn:00001B71                 mov     ebp, esp
.text$mn:00001B73                 push    ecx
.text$mn:00001B74                 mov     [ebp+var_4], ecx
.text$mn:00001B77                 mov     eax, [ebp+var_4]
.text$mn:00001B7A                 mov     eax, [eax]
.text$mn:00001B7C                 mov     esp, ebp
.text$mn:00001B7E                 pop     ebp
.text$mn:00001B7F                 retn
.text$mn:00001B7F ?value@error_code@std@@QBEHXZ endp
.text$mn:00001B7F
.text$mn:00001B7F _text$mn        ends
.text$mn:00001B7F
.text$mn:00001B80 ; ===========================================================================
.text$mn:00001B80
.text$mn:00001B80 ; Segment type: Pure code
.text$mn:00001B80 ; Segment permissions: Read/Execute
.text$mn:00001B80 _text$mn        segment para public 'CODE' use32
.text$mn:00001B80                 assume cs:_text$mn
.text$mn:00001B80                 ;org 1B80h
.text$mn:00001B80 ; COMDAT (pick any)
.text$mn:00001B80                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text$mn:00001B80
.text$mn:00001B80 ; =============== S U B R O U T I N E =======================================
.text$mn:00001B80
.text$mn:00001B80 ; Attributes: bp-based frame
.text$mn:00001B80
.text$mn:00001B80 ; int __thiscall std::error_condition::value(std::error_condition *__hidden this)
.text$mn:00001B80                 public ?value@error_condition@std@@QBEHXZ
.text$mn:00001B80 ?value@error_condition@std@@QBEHXZ proc near
.text$mn:00001B80                                         ; CODE XREF: std::error_condition::operator==(std::error_condition const &)+2Cp
.text$mn:00001B80                                         ; std::error_condition::operator==(std::error_condition const &)+36p
.text$mn:00001B80
.text$mn:00001B80 var_4           = dword ptr -4
.text$mn:00001B80
.text$mn:00001B80                 push    ebp
.text$mn:00001B81                 mov     ebp, esp
.text$mn:00001B83                 push    ecx
.text$mn:00001B84                 mov     [ebp+var_4], ecx
.text$mn:00001B87                 mov     eax, [ebp+var_4]
.text$mn:00001B8A                 mov     eax, [eax]
.text$mn:00001B8C                 mov     esp, ebp
.text$mn:00001B8E                 pop     ebp
.text$mn:00001B8F                 retn
.text$mn:00001B8F ?value@error_condition@std@@QBEHXZ endp
.text$mn:00001B8F
.text$mn:00001B8F _text$mn        ends
.text$mn:00001B8F
.text$mn:00001B90 ; ===========================================================================
.text$mn:00001B90
.text$mn:00001B90 ; Segment type: Pure code
.text$mn:00001B90 ; Segment permissions: Read/Execute
.text$mn:00001B90 _text$mn        segment para public 'CODE' use32
.text$mn:00001B90                 assume cs:_text$mn
.text$mn:00001B90                 ;org 1B90h
.text$mn:00001B90 ; COMDAT (pick any)
.text$mn:00001B90                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text$mn:00001B90
.text$mn:00001B90 ; =============== S U B R O U T I N E =======================================
.text$mn:00001B90
.text$mn:00001B90 ; Attributes: bp-based frame
.text$mn:00001B90
.text$mn:00001B90                 public _hypot
.text$mn:00001B90 _hypot          proc near
.text$mn:00001B90
.text$mn:00001B90 var_10          = qword ptr -10h
.text$mn:00001B90 var_8           = qword ptr -8
.text$mn:00001B90 arg_0           = qword ptr  8
.text$mn:00001B90 arg_8           = qword ptr  10h
.text$mn:00001B90
.text$mn:00001B90                 push    ebp
.text$mn:00001B91                 mov     ebp, esp
.text$mn:00001B93                 sub     esp, 8
.text$mn:00001B96                 movsd   xmm0, [ebp+arg_8]
.text$mn:00001B9B                 movsd   [esp+8+var_8], xmm0
.text$mn:00001BA0                 sub     esp, 8
.text$mn:00001BA3                 movsd   xmm0, [ebp+arg_0]
.text$mn:00001BA8                 movsd   [esp+10h+var_10], xmm0
.text$mn:00001BAD                 call    __hypot
.text$mn:00001BB2                 add     esp, 10h
.text$mn:00001BB5                 pop     ebp
.text$mn:00001BB6                 retn
.text$mn:00001BB6 _hypot          endp
.text$mn:00001BB6
.text$mn:00001BB6 ; ---------------------------------------------------------------------------
.text$mn:00001BB7                 align 4
.text$mn:00001BB7 _text$mn        ends
.text$mn:00001BB7
.xdata$x:00001BB8 ; ===========================================================================
.xdata$x:00001BB8
.xdata$x:00001BB8 ; Segment type: Pure data
.xdata$x:00001BB8 ; Segment permissions: Read
.xdata$x:00001BB8 _xdata$x        segment dword public 'DATA' use32
.xdata$x:00001BB8                 assume cs:_xdata$x
.xdata$x:00001BB8                 ;org 1BB8h
.xdata$x:00001BB8 ; COMDAT (pick associative to section at 1240)
.xdata$x:00001BB8 __unwindtable$?_Orphan_all@_Container_base12@std@@QAEXXZ db 0FFh
.xdata$x:00001BB8                                         ; DATA XREF: .xdata$x:00001BC8o
.xdata$x:00001BB9                 db 0FFh
.xdata$x:00001BBA                 db 0FFh
.xdata$x:00001BBB                 db 0FFh
.xdata$x:00001BBC                 dd offset __unwindfunclet$?_Orphan_all@_Container_base12@std@@QAEXXZ$0
.xdata$x:00001BC0 __ehfuncinfo$?_Orphan_all@_Container_base12@std@@QAEXXZ db  22h ; "
.xdata$x:00001BC0                                         ; DATA XREF: __ehhandler$?_Orphan_all@_Container_base12@std@@QAEXXZ+11o
.xdata$x:00001BC1                 db    5
.xdata$x:00001BC2                 db  93h ; 
.xdata$x:00001BC3                 db  19h
.xdata$x:00001BC4                 db    1
.xdata$x:00001BC5                 db    0
.xdata$x:00001BC6                 db    0
.xdata$x:00001BC7                 db    0
.xdata$x:00001BC8                 dd offset __unwindtable$?_Orphan_all@_Container_base12@std@@QAEXXZ
.xdata$x:00001BCC                 db    0
.xdata$x:00001BCD                 db    0
.xdata$x:00001BCE                 db    0
.xdata$x:00001BCF                 db    0
.xdata$x:00001BD0                 db    0
.xdata$x:00001BD1                 db    0
.xdata$x:00001BD2                 db    0
.xdata$x:00001BD3                 db    0
.xdata$x:00001BD4                 db    0
.xdata$x:00001BD5                 db    0
.xdata$x:00001BD6                 db    0
.xdata$x:00001BD7                 db    0
.xdata$x:00001BD8                 db    0
.xdata$x:00001BD9                 db    0
.xdata$x:00001BDA                 db    0
.xdata$x:00001BDB                 db    0
.xdata$x:00001BDC                 db    0
.xdata$x:00001BDD                 db    0
.xdata$x:00001BDE                 db    0
.xdata$x:00001BDF                 db    0
.xdata$x:00001BE0                 db    0
.xdata$x:00001BE1                 db    0
.xdata$x:00001BE2                 db    0
.xdata$x:00001BE3                 db    0
.xdata$x:00001BE3 _xdata$x        ends
.xdata$x:00001BE3
.xdata$x:00001BE4 ; ===========================================================================
.xdata$x:00001BE4
.xdata$x:00001BE4 ; Segment type: Pure data
.xdata$x:00001BE4 ; Segment permissions: Read
.xdata$x:00001BE4 _xdata$x        segment dword public 'DATA' use32
.xdata$x:00001BE4                 assume cs:_xdata$x
.xdata$x:00001BE4                 ;org 1BE4h
.xdata$x:00001BE4 ; COMDAT (pick associative to section at 5E0)
.xdata$x:00001BE4 __unwindtable$??0?$_String_val@U?$_Simple_types@D@std@@@std@@QAE@XZ db 0FFh
.xdata$x:00001BE4                                         ; DATA XREF: .xdata$x:00001BF4o
.xdata$x:00001BE5                 db 0FFh
.xdata$x:00001BE6                 db 0FFh
.xdata$x:00001BE7                 db 0FFh
.xdata$x:00001BE8                 dd offset __unwindfunclet$??0?$_String_val@U?$_Simple_types@D@std@@@std@@QAE@XZ$0
.xdata$x:00001BEC __ehfuncinfo$??0?$_String_val@U?$_Simple_types@D@std@@@std@@QAE@XZ db  22h ; "
.xdata$x:00001BEC                                         ; DATA XREF: __ehhandler$??0?$_String_val@U?$_Simple_types@D@std@@@std@@QAE@XZ+11o
.xdata$x:00001BED                 db    5
.xdata$x:00001BEE                 db  93h ; 
.xdata$x:00001BEF                 db  19h
.xdata$x:00001BF0                 db    1
.xdata$x:00001BF1                 db    0
.xdata$x:00001BF2                 db    0
.xdata$x:00001BF3                 db    0
.xdata$x:00001BF4                 dd offset __unwindtable$??0?$_String_val@U?$_Simple_types@D@std@@@std@@QAE@XZ
.xdata$x:00001BF8                 db    0
.xdata$x:00001BF9                 db    0
.xdata$x:00001BFA                 db    0
.xdata$x:00001BFB                 db    0
.xdata$x:00001BFC                 db    0
.xdata$x:00001BFD                 db    0
.xdata$x:00001BFE                 db    0
.xdata$x:00001BFF                 db    0
.xdata$x:00001C00                 db    0
.xdata$x:00001C01                 db    0
.xdata$x:00001C02                 db    0
.xdata$x:00001C03                 db    0
.xdata$x:00001C04                 db    0
.xdata$x:00001C05                 db    0
.xdata$x:00001C06                 db    0
.xdata$x:00001C07                 db    0
.xdata$x:00001C08                 db    0
.xdata$x:00001C09                 db    0
.xdata$x:00001C0A                 db    0
.xdata$x:00001C0B                 db    0
.xdata$x:00001C0C                 db    0
.xdata$x:00001C0D                 db    0
.xdata$x:00001C0E                 db    0
.xdata$x:00001C0F                 db    0
.xdata$x:00001C0F _xdata$x        ends
.xdata$x:00001C0F
.xdata$x:00001C10 ; ===========================================================================
.xdata$x:00001C10
.xdata$x:00001C10 ; Segment type: Pure data
.xdata$x:00001C10 ; Segment permissions: Read
.xdata$x:00001C10 _xdata$x        segment dword public 'DATA' use32
.xdata$x:00001C10                 assume cs:_xdata$x
.xdata$x:00001C10                 ;org 1C10h
.xdata$x:00001C10 ; COMDAT (pick associative to section at 9B4)
.xdata$x:00001C10 __unwindtable$??1?$_String_val@U?$_Simple_types@D@std@@@std@@QAE@XZ db 0FFh
.xdata$x:00001C10                                         ; DATA XREF: .xdata$x:00001C20o
.xdata$x:00001C11                 db 0FFh
.xdata$x:00001C12                 db 0FFh
.xdata$x:00001C13                 db 0FFh
.xdata$x:00001C14                 dd offset __unwindfunclet$??1?$_String_val@U?$_Simple_types@D@std@@@std@@QAE@XZ$0
.xdata$x:00001C18 __ehfuncinfo$??1?$_String_val@U?$_Simple_types@D@std@@@std@@QAE@XZ db  22h ; "
.xdata$x:00001C18                                         ; DATA XREF: __ehhandler$??1?$_String_val@U?$_Simple_types@D@std@@@std@@QAE@XZ+11o
.xdata$x:00001C19                 db    5
.xdata$x:00001C1A                 db  93h ; 
.xdata$x:00001C1B                 db  19h
.xdata$x:00001C1C                 db    1
.xdata$x:00001C1D                 db    0
.xdata$x:00001C1E                 db    0
.xdata$x:00001C1F                 db    0
.xdata$x:00001C20                 dd offset __unwindtable$??1?$_String_val@U?$_Simple_types@D@std@@@std@@QAE@XZ
.xdata$x:00001C24                 db    0
.xdata$x:00001C25                 db    0
.xdata$x:00001C26                 db    0
.xdata$x:00001C27                 db    0
.xdata$x:00001C28                 db    0
.xdata$x:00001C29                 db    0
.xdata$x:00001C2A                 db    0
.xdata$x:00001C2B                 db    0
.xdata$x:00001C2C                 db    0
.xdata$x:00001C2D                 db    0
.xdata$x:00001C2E                 db    0
.xdata$x:00001C2F                 db    0
.xdata$x:00001C30                 db    0
.xdata$x:00001C31                 db    0
.xdata$x:00001C32                 db    0
.xdata$x:00001C33                 db    0
.xdata$x:00001C34                 db    0
.xdata$x:00001C35                 db    0
.xdata$x:00001C36                 db    0
.xdata$x:00001C37                 db    0
.xdata$x:00001C38                 db    0
.xdata$x:00001C39                 db    0
.xdata$x:00001C3A                 db    0
.xdata$x:00001C3B                 db    0
.xdata$x:00001C3B _xdata$x        ends
.xdata$x:00001C3B
.xdata$x:00001C3C ; ===========================================================================
.xdata$x:00001C3C
.xdata$x:00001C3C ; Segment type: Pure data
.xdata$x:00001C3C ; Segment permissions: Read
.xdata$x:00001C3C _xdata$x        segment dword public 'DATA' use32
.xdata$x:00001C3C                 assume cs:_xdata$x
.xdata$x:00001C3C                 ;org 1C3Ch
.xdata$x:00001C3C ; COMDAT (pick associative to section at 564)
.xdata$x:00001C3C __unwindtable$??0?$_String_alloc@$0A@U?$_String_base_types@DV?$allocator@D@std@@@std@@@std@@QAE@ABV?$allocator@D@1@@Z db 0FFh
.xdata$x:00001C3C                                         ; DATA XREF: .xdata$x:00001C4Co
.xdata$x:00001C3D                 db 0FFh
.xdata$x:00001C3E                 db 0FFh
.xdata$x:00001C3F                 db 0FFh
.xdata$x:00001C40                 dd offset __unwindfunclet$??0?$_String_alloc@$0A@U?$_String_base_types@DV?$allocator@D@std@@@std@@@std@@QAE@ABV?$allocator@D@1@@Z$0
.xdata$x:00001C44 __ehfuncinfo$??0?$_String_alloc@$0A@U?$_String_base_types@DV?$allocator@D@std@@@std@@@std@@QAE@ABV?$allocator@D@1@@Z db  22h ; "
.xdata$x:00001C44                                         ; DATA XREF: __ehhandler$??0?$_String_alloc@$0A@U?$_String_base_types@DV?$allocator@D@std@@@std@@@std@@QAE@ABV?$allocator@D@1@@Z+11o
.xdata$x:00001C45                 db    5
.xdata$x:00001C46                 db  93h ; 
.xdata$x:00001C47                 db  19h
.xdata$x:00001C48                 db    1
.xdata$x:00001C49                 db    0
.xdata$x:00001C4A                 db    0
.xdata$x:00001C4B                 db    0
.xdata$x:00001C4C                 dd offset __unwindtable$??0?$_String_alloc@$0A@U?$_String_base_types@DV?$allocator@D@std@@@std@@@std@@QAE@ABV?$allocator@D@1@@Z
.xdata$x:00001C50                 db    0
.xdata$x:00001C51                 db    0
.xdata$x:00001C52                 db    0
.xdata$x:00001C53                 db    0
.xdata$x:00001C54                 db    0
.xdata$x:00001C55                 db    0
.xdata$x:00001C56                 db    0
.xdata$x:00001C57                 db    0
.xdata$x:00001C58                 db    0
.xdata$x:00001C59                 db    0
.xdata$x:00001C5A                 db    0
.xdata$x:00001C5B                 db    0
.xdata$x:00001C5C                 db    0
.xdata$x:00001C5D                 db    0
.xdata$x:00001C5E                 db    0
.xdata$x:00001C5F                 db    0
.xdata$x:00001C60                 db    0
.xdata$x:00001C61                 db    0
.xdata$x:00001C62                 db    0
.xdata$x:00001C63                 db    0
.xdata$x:00001C64                 db    0
.xdata$x:00001C65                 db    0
.xdata$x:00001C66                 db    0
.xdata$x:00001C67                 db    0
.xdata$x:00001C67 _xdata$x        ends
.xdata$x:00001C67
.xdata$x:00001C68 ; ===========================================================================
.xdata$x:00001C68
.xdata$x:00001C68 ; Segment type: Pure data
.xdata$x:00001C68 ; Segment permissions: Read
.xdata$x:00001C68 _xdata$x        segment dword public 'DATA' use32
.xdata$x:00001C68                 assume cs:_xdata$x
.xdata$x:00001C68                 ;org 1C68h
.xdata$x:00001C68 ; COMDAT (pick associative to section at 93C)
.xdata$x:00001C68 __unwindtable$??1?$_String_alloc@$0A@U?$_String_base_types@DV?$allocator@D@std@@@std@@@std@@QAE@XZ db 0FFh
.xdata$x:00001C68                                         ; DATA XREF: .xdata$x:00001C78o
.xdata$x:00001C69                 db 0FFh
.xdata$x:00001C6A                 db 0FFh
.xdata$x:00001C6B                 db 0FFh
.xdata$x:00001C6C                 dd offset __unwindfunclet$??1?$_String_alloc@$0A@U?$_String_base_types@DV?$allocator@D@std@@@std@@@std@@QAE@XZ$0
.xdata$x:00001C70 __ehfuncinfo$??1?$_String_alloc@$0A@U?$_String_base_types@DV?$allocator@D@std@@@std@@@std@@QAE@XZ db  22h ; "
.xdata$x:00001C70                                         ; DATA XREF: __ehhandler$??1?$_String_alloc@$0A@U?$_String_base_types@DV?$allocator@D@std@@@std@@@std@@QAE@XZ+11o
.xdata$x:00001C71                 db    5
.xdata$x:00001C72                 db  93h ; 
.xdata$x:00001C73                 db  19h
.xdata$x:00001C74                 db    1
.xdata$x:00001C75                 db    0
.xdata$x:00001C76                 db    0
.xdata$x:00001C77                 db    0
.xdata$x:00001C78                 dd offset __unwindtable$??1?$_String_alloc@$0A@U?$_String_base_types@DV?$allocator@D@std@@@std@@@std@@QAE@XZ
.xdata$x:00001C7C                 db    0
.xdata$x:00001C7D                 db    0
.xdata$x:00001C7E                 db    0
.xdata$x:00001C7F                 db    0
.xdata$x:00001C80                 db    0
.xdata$x:00001C81                 db    0
.xdata$x:00001C82                 db    0
.xdata$x:00001C83                 db    0
.xdata$x:00001C84                 db    0
.xdata$x:00001C85                 db    0
.xdata$x:00001C86                 db    0
.xdata$x:00001C87                 db    0
.xdata$x:00001C88                 db    0
.xdata$x:00001C89                 db    0
.xdata$x:00001C8A                 db    0
.xdata$x:00001C8B                 db    0
.xdata$x:00001C8C                 db    0
.xdata$x:00001C8D                 db    0
.xdata$x:00001C8E                 db    0
.xdata$x:00001C8F                 db    0
.xdata$x:00001C90                 db    0
.xdata$x:00001C91                 db    0
.xdata$x:00001C92                 db    0
.xdata$x:00001C93                 db    0
.xdata$x:00001C93 _xdata$x        ends
.xdata$x:00001C93
.xdata$x:00001C94 ; ===========================================================================
.xdata$x:00001C94
.xdata$x:00001C94 ; Segment type: Pure data
.xdata$x:00001C94 ; Segment permissions: Read
.xdata$x:00001C94 _xdata$x        segment dword public 'DATA' use32
.xdata$x:00001C94                 assume cs:_xdata$x
.xdata$x:00001C94                 ;org 1C94h
.xdata$x:00001C94 ; COMDAT (pick associative to section at 6A0)
.xdata$x:00001C94 __unwindtable$??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@PBD@Z db 0FFh
.xdata$x:00001C94                                         ; DATA XREF: .xdata$x:00001CA4o
.xdata$x:00001C95                 db 0FFh
.xdata$x:00001C96                 db 0FFh
.xdata$x:00001C97                 db 0FFh
.xdata$x:00001C98                 dd offset __unwindfunclet$??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@PBD@Z$0
.xdata$x:00001C9C __ehfuncinfo$??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@PBD@Z db  22h ; "
.xdata$x:00001C9C                                         ; DATA XREF: __ehhandler$??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@PBD@Z+11o
.xdata$x:00001C9D                 db    5
.xdata$x:00001C9E                 db  93h ; 
.xdata$x:00001C9F                 db  19h
.xdata$x:00001CA0                 db    1
.xdata$x:00001CA1                 db    0
.xdata$x:00001CA2                 db    0
.xdata$x:00001CA3                 db    0
.xdata$x:00001CA4                 dd offset __unwindtable$??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@PBD@Z
.xdata$x:00001CA8                 align 20h
.xdata$x:00001CA8 _xdata$x        ends
.xdata$x:00001CA8
.xdata$x:00001CC0 ; ===========================================================================
.xdata$x:00001CC0
.xdata$x:00001CC0 ; Segment type: Pure data
.xdata$x:00001CC0 ; Segment permissions: Read
.xdata$x:00001CC0 _xdata$x        segment dword public 'DATA' use32
.xdata$x:00001CC0                 assume cs:_xdata$x
.xdata$x:00001CC0                 ;org 1CC0h
.xdata$x:00001CC0 ; COMDAT (pick associative to section at A24)
.xdata$x:00001CC0 __unwindtable$??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ db 0FFh
.xdata$x:00001CC0                                         ; DATA XREF: .xdata$x:00001CD0o
.xdata$x:00001CC1                 db 0FFh
.xdata$x:00001CC2                 db 0FFh
.xdata$x:00001CC3                 db 0FFh
.xdata$x:00001CC4                 dd offset __unwindfunclet$??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ$0
.xdata$x:00001CC8 __ehfuncinfo$??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ db  22h ; "
.xdata$x:00001CC8                                         ; DATA XREF: __ehhandler$??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ+11o
.xdata$x:00001CC9                 db    5
.xdata$x:00001CCA                 db  93h ; 
.xdata$x:00001CCB                 db  19h
.xdata$x:00001CCC                 db    1
.xdata$x:00001CCD                 db    0
.xdata$x:00001CCE                 db    0
.xdata$x:00001CCF                 db    0
.xdata$x:00001CD0                 dd offset __unwindtable$??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ
.xdata$x:00001CD4                 db    0
.xdata$x:00001CD5                 db    0
.xdata$x:00001CD6                 db    0
.xdata$x:00001CD7                 db    0
.xdata$x:00001CD8                 db    0
.xdata$x:00001CD9                 db    0
.xdata$x:00001CDA                 db    0
.xdata$x:00001CDB                 db    0
.xdata$x:00001CDC                 db    0
.xdata$x:00001CDD                 db    0
.xdata$x:00001CDE                 db    0
.xdata$x:00001CDF                 db    0
.xdata$x:00001CE0                 db    0
.xdata$x:00001CE1                 db    0
.xdata$x:00001CE2                 db    0
.xdata$x:00001CE3                 db    0
.xdata$x:00001CE4                 db    0
.xdata$x:00001CE5                 db    0
.xdata$x:00001CE6                 db    0
.xdata$x:00001CE7                 db    0
.xdata$x:00001CE8                 db    0
.xdata$x:00001CE9                 db    0
.xdata$x:00001CEA                 db    0
.xdata$x:00001CEB                 db    0
.xdata$x:00001CEB _xdata$x        ends
.xdata$x:00001CEB
.xdata$x:00001CEC ; ===========================================================================
.xdata$x:00001CEC
.xdata$x:00001CEC ; Segment type: Pure data
.xdata$x:00001CEC ; Segment permissions: Read
.xdata$x:00001CEC _xdata$x        segment dword public 'DATA' use32
.xdata$x:00001CEC                 assume cs:_xdata$x
.xdata$x:00001CEC                 ;org 1CECh
.xdata$x:00001CEC ; COMDAT (pick associative to section at E9C)
.xdata$x:00001CEC __catchsym$?_Copy@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEXII@Z$5 db    0
.xdata$x:00001CEC                                         ; DATA XREF: .xdata$x:00001D74o
.xdata$x:00001CED                 db    0
.xdata$x:00001CEE                 db    0
.xdata$x:00001CEF                 db    0
.xdata$x:00001CF0                 db    0
.xdata$x:00001CF1                 db    0
.xdata$x:00001CF2                 db    0
.xdata$x:00001CF3                 db    0
.xdata$x:00001CF4                 db    0
.xdata$x:00001CF5                 db    0
.xdata$x:00001CF6                 db    0
.xdata$x:00001CF7                 db    0
.xdata$x:00001CF8                 dd offset __catch$?_Copy@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEXII@Z$0
.xdata$x:00001CFC __catchsym$?_Copy@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEXII@Z$4 db    0
.xdata$x:00001CFC                                         ; DATA XREF: .xdata$x:00001D60o
.xdata$x:00001CFD                 db    0
.xdata$x:00001CFE                 db    0
.xdata$x:00001CFF                 db    0
.xdata$x:00001D00                 db    0
.xdata$x:00001D01                 db    0
.xdata$x:00001D02                 db    0
.xdata$x:00001D03                 db    0
.xdata$x:00001D04                 db    0
.xdata$x:00001D05                 db    0
.xdata$x:00001D06                 db    0
.xdata$x:00001D07                 db    0
.xdata$x:00001D08                 dd offset __catch$?_Copy@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEXII@Z$1
.xdata$x:00001D0C __unwindtable$?_Copy@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEXII@Z db 0FFh
.xdata$x:00001D0C                                         ; DATA XREF: .xdata$x:00001D34o
.xdata$x:00001D0D                 db 0FFh
.xdata$x:00001D0E                 db 0FFh
.xdata$x:00001D0F                 db 0FFh
.xdata$x:00001D10                 db    0
.xdata$x:00001D11                 db    0
.xdata$x:00001D12                 db    0
.xdata$x:00001D13                 db    0
.xdata$x:00001D14                 db 0FFh
.xdata$x:00001D15                 db 0FFh
.xdata$x:00001D16                 db 0FFh
.xdata$x:00001D17                 db 0FFh
.xdata$x:00001D18                 db    0
.xdata$x:00001D19                 db    0
.xdata$x:00001D1A                 db    0
.xdata$x:00001D1B                 db    0
.xdata$x:00001D1C                 db    1
.xdata$x:00001D1D                 db    0
.xdata$x:00001D1E                 db    0
.xdata$x:00001D1F                 db    0
.xdata$x:00001D20                 db    0
.xdata$x:00001D21                 db    0
.xdata$x:00001D22                 db    0
.xdata$x:00001D23                 db    0
.xdata$x:00001D24                 db    1
.xdata$x:00001D25                 db    0
.xdata$x:00001D26                 db    0
.xdata$x:00001D27                 db    0
.xdata$x:00001D28                 db    0
.xdata$x:00001D29                 db    0
.xdata$x:00001D2A                 db    0
.xdata$x:00001D2B                 db    0
.xdata$x:00001D2C __ehfuncinfo$?_Copy@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEXII@Z db  22h ; "
.xdata$x:00001D2C                                         ; DATA XREF: __ehhandler$?_Copy@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEXII@Z+11o
.xdata$x:00001D2D                 db    5
.xdata$x:00001D2E                 db  93h ; 
.xdata$x:00001D2F                 db  19h
.xdata$x:00001D30                 db    4
.xdata$x:00001D31                 db    0
.xdata$x:00001D32                 db    0
.xdata$x:00001D33                 db    0
.xdata$x:00001D34                 dd offset __unwindtable$?_Copy@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEXII@Z
.xdata$x:00001D38                 db    2
.xdata$x:00001D39                 db    0
.xdata$x:00001D3A                 db    0
.xdata$x:00001D3B                 db    0
.xdata$x:00001D3C                 dd offset __tryblocktable$?_Copy@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEXII@Z
.xdata$x:00001D40                 db    0
.xdata$x:00001D41                 db    0
.xdata$x:00001D42                 db    0
.xdata$x:00001D43                 db    0
.xdata$x:00001D44                 db    0
.xdata$x:00001D45                 db    0
.xdata$x:00001D46                 db    0
.xdata$x:00001D47                 db    0
.xdata$x:00001D48                 db    0
.xdata$x:00001D49                 db    0
.xdata$x:00001D4A                 db    0
.xdata$x:00001D4B                 db    0
.xdata$x:00001D4C                 db    0
.xdata$x:00001D4D                 db    0
.xdata$x:00001D4E                 db    0
.xdata$x:00001D4F                 db    0
.xdata$x:00001D50 __tryblocktable$?_Copy@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEXII@Z db    2
.xdata$x:00001D50                                         ; DATA XREF: .xdata$x:00001D3Co
.xdata$x:00001D51                 db    0
.xdata$x:00001D52                 db    0
.xdata$x:00001D53                 db    0
.xdata$x:00001D54                 db    2
.xdata$x:00001D55                 db    0
.xdata$x:00001D56                 db    0
.xdata$x:00001D57                 db    0
.xdata$x:00001D58                 db    3
.xdata$x:00001D59                 db    0
.xdata$x:00001D5A                 db    0
.xdata$x:00001D5B                 db    0
.xdata$x:00001D5C                 db    1
.xdata$x:00001D5D                 db    0
.xdata$x:00001D5E                 db    0
.xdata$x:00001D5F                 db    0
.xdata$x:00001D60                 dd offset __catchsym$?_Copy@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEXII@Z$4
.xdata$x:00001D64                 db    0
.xdata$x:00001D65                 db    0
.xdata$x:00001D66                 db    0
.xdata$x:00001D67                 db    0
.xdata$x:00001D68                 db    0
.xdata$x:00001D69                 db    0
.xdata$x:00001D6A                 db    0
.xdata$x:00001D6B                 db    0
.xdata$x:00001D6C                 db    3
.xdata$x:00001D6D                 db    0
.xdata$x:00001D6E                 db    0
.xdata$x:00001D6F                 db    0
.xdata$x:00001D70                 db    1
.xdata$x:00001D71                 db    0
.xdata$x:00001D72                 db    0
.xdata$x:00001D73                 db    0
.xdata$x:00001D74                 dd offset __catchsym$?_Copy@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEXII@Z$5
.xdata$x:00001D74 _xdata$x        ends
.xdata$x:00001D74
.xdata$x:00001D78 ; ===========================================================================
.xdata$x:00001D78
.xdata$x:00001D78 ; Segment type: Pure data
.xdata$x:00001D78 ; Segment permissions: Read
.xdata$x:00001D78 _xdata$x        segment dword public 'DATA' use32
.xdata$x:00001D78                 assume cs:_xdata$x
.xdata$x:00001D78                 ;org 1D78h
.xdata$x:00001D78 ; COMDAT (pick associative to section at 774)
.xdata$x:00001D78 __unwindtable$??0_Generic_error_category@std@@QAE@XZ db 0FFh
.xdata$x:00001D78                                         ; DATA XREF: .xdata$x:00001D88o
.xdata$x:00001D79                 db 0FFh
.xdata$x:00001D7A                 db 0FFh
.xdata$x:00001D7B                 db 0FFh
.xdata$x:00001D7C                 dd offset __unwindfunclet$??0_Generic_error_category@std@@QAE@XZ$0
.xdata$x:00001D80 __ehfuncinfo$??0_Generic_error_category@std@@QAE@XZ db  22h ; "
.xdata$x:00001D80                                         ; DATA XREF: __ehhandler$??0_Generic_error_category@std@@QAE@XZ+11o
.xdata$x:00001D81                 db    5
.xdata$x:00001D82                 db  93h ; 
.xdata$x:00001D83                 db  19h
.xdata$x:00001D84                 db    1
.xdata$x:00001D85                 db    0
.xdata$x:00001D86                 db    0
.xdata$x:00001D87                 db    0
.xdata$x:00001D88                 dd offset __unwindtable$??0_Generic_error_category@std@@QAE@XZ
.xdata$x:00001D8C                 db    0
.xdata$x:00001D8D                 db    0
.xdata$x:00001D8E                 db    0
.xdata$x:00001D8F                 db    0
.xdata$x:00001D90                 db    0
.xdata$x:00001D91                 db    0
.xdata$x:00001D92                 db    0
.xdata$x:00001D93                 db    0
.xdata$x:00001D94                 db    0
.xdata$x:00001D95                 db    0
.xdata$x:00001D96                 db    0
.xdata$x:00001D97                 db    0
.xdata$x:00001D98                 db    0
.xdata$x:00001D99                 db    0
.xdata$x:00001D9A                 db    0
.xdata$x:00001D9B                 db    0
.xdata$x:00001D9C                 db    0
.xdata$x:00001D9D                 db    0
.xdata$x:00001D9E                 db    0
.xdata$x:00001D9F                 db    0
.xdata$x:00001DA0                 db    0
.xdata$x:00001DA1                 db    0
.xdata$x:00001DA2                 db    0
.xdata$x:00001DA3                 db    0
.xdata$x:00001DA3 _xdata$x        ends
.xdata$x:00001DA3
.xdata$x:00001DA4 ; ===========================================================================
.xdata$x:00001DA4
.xdata$x:00001DA4 ; Segment type: Pure data
.xdata$x:00001DA4 ; Segment permissions: Read
.xdata$x:00001DA4 _xdata$x        segment dword public 'DATA' use32
.xdata$x:00001DA4                 assume cs:_xdata$x
.xdata$x:00001DA4                 ;org 1DA4h
.xdata$x:00001DA4 ; COMDAT (pick associative to section at 18BC)
.xdata$x:00001DA4 __unwindtable$?message@_Generic_error_category@std@@UBE?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@2@H@Z db 0FFh
.xdata$x:00001DA4                                         ; DATA XREF: .xdata$x:00001DB4o
.xdata$x:00001DA5                 db 0FFh
.xdata$x:00001DA6                 db 0FFh
.xdata$x:00001DA7                 db 0FFh
.xdata$x:00001DA8                 dd offset __unwindfunclet$?message@_Generic_error_category@std@@UBE?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@2@H@Z$0
.xdata$x:00001DAC __ehfuncinfo$?message@_Generic_error_category@std@@UBE?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@2@H@Z db  22h ; "
.xdata$x:00001DAC                                         ; DATA XREF: __ehhandler$?message@_Generic_error_category@std@@UBE?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@2@H@Z+11o
.xdata$x:00001DAD                 db    5
.xdata$x:00001DAE                 db  93h ; 
.xdata$x:00001DAF                 db  19h
.xdata$x:00001DB0                 db    1
.xdata$x:00001DB1                 db    0
.xdata$x:00001DB2                 db    0
.xdata$x:00001DB3                 db    0
.xdata$x:00001DB4                 dd offset __unwindtable$?message@_Generic_error_category@std@@UBE?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@2@H@Z
.xdata$x:00001DB8                 db    0
.xdata$x:00001DB9                 db    0
.xdata$x:00001DBA                 db    0
.xdata$x:00001DBB                 db    0
.xdata$x:00001DBC                 db    0
.xdata$x:00001DBD                 db    0
.xdata$x:00001DBE                 db    0
.xdata$x:00001DBF                 db    0
.xdata$x:00001DC0                 db    0
.xdata$x:00001DC1                 db    0
.xdata$x:00001DC2                 db    0
.xdata$x:00001DC3                 db    0
.xdata$x:00001DC4                 db    0
.xdata$x:00001DC5                 db    0
.xdata$x:00001DC6                 db    0
.xdata$x:00001DC7                 db    0
.xdata$x:00001DC8                 db    0
.xdata$x:00001DC9                 db    0
.xdata$x:00001DCA                 db    0
.xdata$x:00001DCB                 db    0
.xdata$x:00001DCC                 db    0
.xdata$x:00001DCD                 db    0
.xdata$x:00001DCE                 db    0
.xdata$x:00001DCF                 db    0
.xdata$x:00001DCF _xdata$x        ends
.xdata$x:00001DCF
.xdata$x:00001DD0 ; ===========================================================================
.xdata$x:00001DD0
.xdata$x:00001DD0 ; Segment type: Pure data
.xdata$x:00001DD0 ; Segment permissions: Read
.xdata$x:00001DD0 _xdata$x        segment dword public 'DATA' use32
.xdata$x:00001DD0                 assume cs:_xdata$x
.xdata$x:00001DD0                 ;org 1DD0h
.xdata$x:00001DD0 ; COMDAT (pick associative to section at AB4)
.xdata$x:00001DD0 __unwindtable$??1_Generic_error_category@std@@UAE@XZ db 0FFh
.xdata$x:00001DD0                                         ; DATA XREF: .xdata$x:00001DE0o
.xdata$x:00001DD1                 db 0FFh
.xdata$x:00001DD2                 db 0FFh
.xdata$x:00001DD3                 db 0FFh
.xdata$x:00001DD4                 dd offset __unwindfunclet$??1_Generic_error_category@std@@UAE@XZ$0
.xdata$x:00001DD8 __ehfuncinfo$??1_Generic_error_category@std@@UAE@XZ db  22h ; "
.xdata$x:00001DD8                                         ; DATA XREF: __ehhandler$??1_Generic_error_category@std@@UAE@XZ+11o
.xdata$x:00001DD9                 db    5
.xdata$x:00001DDA                 db  93h ; 
.xdata$x:00001DDB                 db  19h
.xdata$x:00001DDC                 db    1
.xdata$x:00001DDD                 db    0
.xdata$x:00001DDE                 db    0
.xdata$x:00001DDF                 db    0
.xdata$x:00001DE0                 dd offset __unwindtable$??1_Generic_error_category@std@@UAE@XZ
.xdata$x:00001DE4                 db    0
.xdata$x:00001DE5                 db    0
.xdata$x:00001DE6                 db    0
.xdata$x:00001DE7                 db    0
.xdata$x:00001DE8                 db    0
.xdata$x:00001DE9                 db    0
.xdata$x:00001DEA                 db    0
.xdata$x:00001DEB                 db    0
.xdata$x:00001DEC                 db    0
.xdata$x:00001DED                 db    0
.xdata$x:00001DEE                 db    0
.xdata$x:00001DEF                 db    0
.xdata$x:00001DF0                 db    0
.xdata$x:00001DF1                 db    0
.xdata$x:00001DF2                 db    0
.xdata$x:00001DF3                 db    0
.xdata$x:00001DF4                 db    0
.xdata$x:00001DF5                 db    0
.xdata$x:00001DF6                 db    0
.xdata$x:00001DF7                 db    0
.xdata$x:00001DF8                 db    0
.xdata$x:00001DF9                 db    0
.xdata$x:00001DFA                 db    0
.xdata$x:00001DFB                 db    0
.xdata$x:00001DFB _xdata$x        ends
.xdata$x:00001DFB
.xdata$x:00001DFC ; ===========================================================================
.xdata$x:00001DFC
.xdata$x:00001DFC ; Segment type: Pure data
.xdata$x:00001DFC ; Segment permissions: Read
.xdata$x:00001DFC _xdata$x        segment dword public 'DATA' use32
.xdata$x:00001DFC                 assume cs:_xdata$x
.xdata$x:00001DFC                 ;org 1DFCh
.xdata$x:00001DFC ; COMDAT (pick associative to section at 7F0)
.xdata$x:00001DFC __unwindtable$??0_Iostream_error_category@std@@QAE@XZ db 0FFh
.xdata$x:00001DFC                                         ; DATA XREF: .xdata$x:00001E0Co
.xdata$x:00001DFD                 db 0FFh
.xdata$x:00001DFE                 db 0FFh
.xdata$x:00001DFF                 db 0FFh
.xdata$x:00001E00                 dd offset __unwindfunclet$??0_Iostream_error_category@std@@QAE@XZ$0
.xdata$x:00001E04 __ehfuncinfo$??0_Iostream_error_category@std@@QAE@XZ db  22h ; "
.xdata$x:00001E04                                         ; DATA XREF: __ehhandler$??0_Iostream_error_category@std@@QAE@XZ+11o
.xdata$x:00001E05                 db    5
.xdata$x:00001E06                 db  93h ; 
.xdata$x:00001E07                 db  19h
.xdata$x:00001E08                 db    1
.xdata$x:00001E09                 db    0
.xdata$x:00001E0A                 db    0
.xdata$x:00001E0B                 db    0
.xdata$x:00001E0C                 dd offset __unwindtable$??0_Iostream_error_category@std@@QAE@XZ
.xdata$x:00001E10                 db    0
.xdata$x:00001E11                 db    0
.xdata$x:00001E12                 db    0
.xdata$x:00001E13                 db    0
.xdata$x:00001E14                 db    0
.xdata$x:00001E15                 db    0
.xdata$x:00001E16                 db    0
.xdata$x:00001E17                 db    0
.xdata$x:00001E18                 db    0
.xdata$x:00001E19                 db    0
.xdata$x:00001E1A                 db    0
.xdata$x:00001E1B                 db    0
.xdata$x:00001E1C                 db    0
.xdata$x:00001E1D                 db    0
.xdata$x:00001E1E                 db    0
.xdata$x:00001E1F                 db    0
.xdata$x:00001E20                 db    0
.xdata$x:00001E21                 db    0
.xdata$x:00001E22                 db    0
.xdata$x:00001E23                 db    0
.xdata$x:00001E24                 db    0
.xdata$x:00001E25                 db    0
.xdata$x:00001E26                 db    0
.xdata$x:00001E27                 db    0
.xdata$x:00001E27 _xdata$x        ends
.xdata$x:00001E27
.xdata$x:00001E28 ; ===========================================================================
.xdata$x:00001E28
.xdata$x:00001E28 ; Segment type: Pure data
.xdata$x:00001E28 ; Segment permissions: Read
.xdata$x:00001E28 _xdata$x        segment dword public 'DATA' use32
.xdata$x:00001E28                 assume cs:_xdata$x
.xdata$x:00001E28                 ;org 1E28h
.xdata$x:00001E28 ; COMDAT (pick associative to section at 1974)
.xdata$x:00001E28 __unwindtable$?message@_Iostream_error_category@std@@UBE?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@2@H@Z db 0FFh
.xdata$x:00001E28                                         ; DATA XREF: .xdata$x:00001E38o
.xdata$x:00001E29                 db 0FFh
.xdata$x:00001E2A                 db 0FFh
.xdata$x:00001E2B                 db 0FFh
.xdata$x:00001E2C                 dd offset __unwindfunclet$?message@_Iostream_error_category@std@@UBE?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@2@H@Z$0
.xdata$x:00001E30 __ehfuncinfo$?message@_Iostream_error_category@std@@UBE?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@2@H@Z db  22h ; "
.xdata$x:00001E30                                         ; DATA XREF: __ehhandler$?message@_Iostream_error_category@std@@UBE?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@2@H@Z+11o
.xdata$x:00001E31                 db    5
.xdata$x:00001E32                 db  93h ; 
.xdata$x:00001E33                 db  19h
.xdata$x:00001E34                 db    1
.xdata$x:00001E35                 db    0
.xdata$x:00001E36                 db    0
.xdata$x:00001E37                 db    0
.xdata$x:00001E38                 dd offset __unwindtable$?message@_Iostream_error_category@std@@UBE?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@2@H@Z
.xdata$x:00001E3C                 db    0
.xdata$x:00001E3D                 db    0
.xdata$x:00001E3E                 db    0
.xdata$x:00001E3F                 db    0
.xdata$x:00001E40                 db    0
.xdata$x:00001E41                 db    0
.xdata$x:00001E42                 db    0
.xdata$x:00001E43                 db    0
.xdata$x:00001E44                 db    0
.xdata$x:00001E45                 db    0
.xdata$x:00001E46                 db    0
.xdata$x:00001E47                 db    0
.xdata$x:00001E48                 db    0
.xdata$x:00001E49                 db    0
.xdata$x:00001E4A                 db    0
.xdata$x:00001E4B                 db    0
.xdata$x:00001E4C                 db    0
.xdata$x:00001E4D                 db    0
.xdata$x:00001E4E                 db    0
.xdata$x:00001E4F                 db    0
.xdata$x:00001E50                 db    0
.xdata$x:00001E51                 db    0
.xdata$x:00001E52                 db    0
.xdata$x:00001E53                 db    0
.xdata$x:00001E53 _xdata$x        ends
.xdata$x:00001E53
.xdata$x:00001E54 ; ===========================================================================
.xdata$x:00001E54
.xdata$x:00001E54 ; Segment type: Pure data
.xdata$x:00001E54 ; Segment permissions: Read
.xdata$x:00001E54 _xdata$x        segment dword public 'DATA' use32
.xdata$x:00001E54                 assume cs:_xdata$x
.xdata$x:00001E54                 ;org 1E54h
.xdata$x:00001E54 ; COMDAT (pick associative to section at B24)
.xdata$x:00001E54 __unwindtable$??1_Iostream_error_category@std@@UAE@XZ db 0FFh
.xdata$x:00001E54                                         ; DATA XREF: .xdata$x:00001E64o
.xdata$x:00001E55                 db 0FFh
.xdata$x:00001E56                 db 0FFh
.xdata$x:00001E57                 db 0FFh
.xdata$x:00001E58                 dd offset __unwindfunclet$??1_Iostream_error_category@std@@UAE@XZ$0
.xdata$x:00001E5C __ehfuncinfo$??1_Iostream_error_category@std@@UAE@XZ db  22h ; "
.xdata$x:00001E5C                                         ; DATA XREF: __ehhandler$??1_Iostream_error_category@std@@UAE@XZ+11o
.xdata$x:00001E5D                 db    5
.xdata$x:00001E5E                 db  93h ; 
.xdata$x:00001E5F                 db  19h
.xdata$x:00001E60                 db    1
.xdata$x:00001E61                 db    0
.xdata$x:00001E62                 db    0
.xdata$x:00001E63                 db    0
.xdata$x:00001E64                 dd offset __unwindtable$??1_Iostream_error_category@std@@UAE@XZ
.xdata$x:00001E68                 align 20h
.xdata$x:00001E68 _xdata$x        ends
.xdata$x:00001E68
.xdata$x:00001E80 ; ===========================================================================
.xdata$x:00001E80
.xdata$x:00001E80 ; Segment type: Pure data
.xdata$x:00001E80 ; Segment permissions: Read
.xdata$x:00001E80 _xdata$x        segment dword public 'DATA' use32
.xdata$x:00001E80                 assume cs:_xdata$x
.xdata$x:00001E80                 ;org 1E80h
.xdata$x:00001E80 ; COMDAT (pick associative to section at 86C)
.xdata$x:00001E80 __unwindtable$??0_System_error_category@std@@QAE@XZ db 0FFh
.xdata$x:00001E80                                         ; DATA XREF: .xdata$x:00001E90o
.xdata$x:00001E81                 db 0FFh
.xdata$x:00001E82                 db 0FFh
.xdata$x:00001E83                 db 0FFh
.xdata$x:00001E84                 dd offset __unwindfunclet$??0_System_error_category@std@@QAE@XZ$0
.xdata$x:00001E88 __ehfuncinfo$??0_System_error_category@std@@QAE@XZ db  22h ; "
.xdata$x:00001E88                                         ; DATA XREF: __ehhandler$??0_System_error_category@std@@QAE@XZ+11o
.xdata$x:00001E89                 db    5
.xdata$x:00001E8A                 db  93h ; 
.xdata$x:00001E8B                 db  19h
.xdata$x:00001E8C                 db    1
.xdata$x:00001E8D                 db    0
.xdata$x:00001E8E                 db    0
.xdata$x:00001E8F                 db    0
.xdata$x:00001E90                 dd offset __unwindtable$??0_System_error_category@std@@QAE@XZ
.xdata$x:00001E94                 db    0
.xdata$x:00001E95                 db    0
.xdata$x:00001E96                 db    0
.xdata$x:00001E97                 db    0
.xdata$x:00001E98                 db    0
.xdata$x:00001E99                 db    0
.xdata$x:00001E9A                 db    0
.xdata$x:00001E9B                 db    0
.xdata$x:00001E9C                 db    0
.xdata$x:00001E9D                 db    0
.xdata$x:00001E9E                 db    0
.xdata$x:00001E9F                 db    0
.xdata$x:00001EA0                 db    0
.xdata$x:00001EA1                 db    0
.xdata$x:00001EA2                 db    0
.xdata$x:00001EA3                 db    0
.xdata$x:00001EA4                 db    0
.xdata$x:00001EA5                 db    0
.xdata$x:00001EA6                 db    0
.xdata$x:00001EA7                 db    0
.xdata$x:00001EA8                 db    0
.xdata$x:00001EA9                 db    0
.xdata$x:00001EAA                 db    0
.xdata$x:00001EAB                 db    0
.xdata$x:00001EAB _xdata$x        ends
.xdata$x:00001EAB
.xdata$x:00001EAC ; ===========================================================================
.xdata$x:00001EAC
.xdata$x:00001EAC ; Segment type: Pure data
.xdata$x:00001EAC ; Segment permissions: Read
.xdata$x:00001EAC _xdata$x        segment dword public 'DATA' use32
.xdata$x:00001EAC                 assume cs:_xdata$x
.xdata$x:00001EAC                 ;org 1EACh
.xdata$x:00001EAC ; COMDAT (pick associative to section at 1A38)
.xdata$x:00001EAC __unwindtable$?message@_System_error_category@std@@UBE?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@2@H@Z db 0FFh
.xdata$x:00001EAC                                         ; DATA XREF: .xdata$x:00001EBCo
.xdata$x:00001EAD                 db 0FFh
.xdata$x:00001EAE                 db 0FFh
.xdata$x:00001EAF                 db 0FFh
.xdata$x:00001EB0                 dd offset __unwindfunclet$?message@_System_error_category@std@@UBE?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@2@H@Z$0
.xdata$x:00001EB4 __ehfuncinfo$?message@_System_error_category@std@@UBE?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@2@H@Z db  22h ; "
.xdata$x:00001EB4                                         ; DATA XREF: __ehhandler$?message@_System_error_category@std@@UBE?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@2@H@Z+11o
.xdata$x:00001EB5                 db    5
.xdata$x:00001EB6                 db  93h ; 
.xdata$x:00001EB7                 db  19h
.xdata$x:00001EB8                 db    1
.xdata$x:00001EB9                 db    0
.xdata$x:00001EBA                 db    0
.xdata$x:00001EBB                 db    0
.xdata$x:00001EBC                 dd offset __unwindtable$?message@_System_error_category@std@@UBE?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@2@H@Z
.xdata$x:00001EC0                 db    0
.xdata$x:00001EC1                 db    0
.xdata$x:00001EC2                 db    0
.xdata$x:00001EC3                 db    0
.xdata$x:00001EC4                 db    0
.xdata$x:00001EC5                 db    0
.xdata$x:00001EC6                 db    0
.xdata$x:00001EC7                 db    0
.xdata$x:00001EC8                 db    0
.xdata$x:00001EC9                 db    0
.xdata$x:00001ECA                 db    0
.xdata$x:00001ECB                 db    0
.xdata$x:00001ECC                 db    0
.xdata$x:00001ECD                 db    0
.xdata$x:00001ECE                 db    0
.xdata$x:00001ECF                 db    0
.xdata$x:00001ED0                 db    0
.xdata$x:00001ED1                 db    0
.xdata$x:00001ED2                 db    0
.xdata$x:00001ED3                 db    0
.xdata$x:00001ED4                 db    0
.xdata$x:00001ED5                 db    0
.xdata$x:00001ED6                 db    0
.xdata$x:00001ED7                 db    0
.xdata$x:00001ED7 _xdata$x        ends
.xdata$x:00001ED7
.xdata$x:00001ED8 ; ===========================================================================
.xdata$x:00001ED8
.xdata$x:00001ED8 ; Segment type: Pure data
.xdata$x:00001ED8 ; Segment permissions: Read
.xdata$x:00001ED8 _xdata$x        segment dword public 'DATA' use32
.xdata$x:00001ED8                 assume cs:_xdata$x
.xdata$x:00001ED8                 ;org 1ED8h
.xdata$x:00001ED8 ; COMDAT (pick associative to section at B94)
.xdata$x:00001ED8 __unwindtable$??1_System_error_category@std@@UAE@XZ db 0FFh
.xdata$x:00001ED8                                         ; DATA XREF: .xdata$x:00001EE8o
.xdata$x:00001ED9                 db 0FFh
.xdata$x:00001EDA                 db 0FFh
.xdata$x:00001EDB                 db 0FFh
.xdata$x:00001EDC                 dd offset __unwindfunclet$??1_System_error_category@std@@UAE@XZ$0
.xdata$x:00001EE0 __ehfuncinfo$??1_System_error_category@std@@UAE@XZ db  22h ; "
.xdata$x:00001EE0                                         ; DATA XREF: __ehhandler$??1_System_error_category@std@@UAE@XZ+11o
.xdata$x:00001EE1                 db    5
.xdata$x:00001EE2                 db  93h ; 
.xdata$x:00001EE3                 db  19h
.xdata$x:00001EE4                 db    1
.xdata$x:00001EE5                 db    0
.xdata$x:00001EE6                 db    0
.xdata$x:00001EE7                 db    0
.xdata$x:00001EE8                 dd offset __unwindtable$??1_System_error_category@std@@UAE@XZ
.xdata$x:00001EEC                 db    0
.xdata$x:00001EED                 db    0
.xdata$x:00001EEE                 db    0
.xdata$x:00001EEF                 db    0
.xdata$x:00001EF0                 db    0
.xdata$x:00001EF1                 db    0
.xdata$x:00001EF2                 db    0
.xdata$x:00001EF3                 db    0
.xdata$x:00001EF4                 db    0
.xdata$x:00001EF5                 db    0
.xdata$x:00001EF6                 db    0
.xdata$x:00001EF7                 db    0
.xdata$x:00001EF8                 db    0
.xdata$x:00001EF9                 db    0
.xdata$x:00001EFA                 db    0
.xdata$x:00001EFB                 db    0
.xdata$x:00001EFC                 db    0
.xdata$x:00001EFD                 db    0
.xdata$x:00001EFE                 db    0
.xdata$x:00001EFF                 db    0
.xdata$x:00001F00                 db    0
.xdata$x:00001F01                 db    0
.xdata$x:00001F02                 db    0
.xdata$x:00001F03                 db    0
.xdata$x:00001F03 _xdata$x        ends
.xdata$x:00001F03
.xdata$x:00001F04 ; ===========================================================================
.xdata$x:00001F04
.xdata$x:00001F04 ; Segment type: Pure data
.xdata$x:00001F04 ; Segment permissions: Read
.xdata$x:00001F04 _xdata$x        segment dword public 'DATA' use32
.xdata$x:00001F04                 assume cs:_xdata$x
.xdata$x:00001F04                 ;org 1F04h
.xdata$x:00001F04 ; COMDAT (pick associative to section at 448)
.xdata$x:00001F04 __unwindtable$??$construct@U_Container_proxy@std@@U12@@?$allocator@U_Container_proxy@std@@@std@@QAEXPAU_Container_proxy@1@$$QAU21@@Z db 0FFh
.xdata$x:00001F04                                         ; DATA XREF: .xdata$x:00001F14o
.xdata$x:00001F05                 db 0FFh
.xdata$x:00001F06                 db 0FFh
.xdata$x:00001F07                 db 0FFh
.xdata$x:00001F08                 dd offset __unwindfunclet$??$construct@U_Container_proxy@std@@U12@@?$allocator@U_Container_proxy@std@@@std@@QAEXPAU_Container_proxy@1@$$QAU21@@Z$0
.xdata$x:00001F0C __ehfuncinfo$??$construct@U_Container_proxy@std@@U12@@?$allocator@U_Container_proxy@std@@@std@@QAEXPAU_Container_proxy@1@$$QAU21@@Z db  22h ; "
.xdata$x:00001F0C                                         ; DATA XREF: __ehhandler$??$construct@U_Container_proxy@std@@U12@@?$allocator@U_Container_proxy@std@@@std@@QAEXPAU_Container_proxy@1@$$QAU21@@Z+11o
.xdata$x:00001F0D                 db    5
.xdata$x:00001F0E                 db  93h ; 
.xdata$x:00001F0F                 db  19h
.xdata$x:00001F10                 db    1
.xdata$x:00001F11                 db    0
.xdata$x:00001F12                 db    0
.xdata$x:00001F13                 db    0
.xdata$x:00001F14                 dd offset __unwindtable$??$construct@U_Container_proxy@std@@U12@@?$allocator@U_Container_proxy@std@@@std@@QAEXPAU_Container_proxy@1@$$QAU21@@Z
.xdata$x:00001F18                 db    0
.xdata$x:00001F19                 db    0
.xdata$x:00001F1A                 db    0
.xdata$x:00001F1B                 db    0
.xdata$x:00001F1C                 db    0
.xdata$x:00001F1D                 db    0
.xdata$x:00001F1E                 db    0
.xdata$x:00001F1F                 db    0
.xdata$x:00001F20                 db    0
.xdata$x:00001F21                 db    0
.xdata$x:00001F22                 db    0
.xdata$x:00001F23                 db    0
.xdata$x:00001F24                 db    0
.xdata$x:00001F25                 db    0
.xdata$x:00001F26                 db    0
.xdata$x:00001F27                 db    0
.xdata$x:00001F28                 db    0
.xdata$x:00001F29                 db    0
.xdata$x:00001F2A                 db    0
.xdata$x:00001F2B                 db    0
.xdata$x:00001F2C                 db    0
.xdata$x:00001F2D                 db    0
.xdata$x:00001F2E                 db    0
.xdata$x:00001F2F                 db    0
.xdata$x:00001F2F _xdata$x        ends
.xdata$x:00001F2F
.xdata$x:00001F30 ; ===========================================================================
.xdata$x:00001F30
.xdata$x:00001F30 ; Segment type: Pure data
.xdata$x:00001F30 ; Segment permissions: Read
.xdata$x:00001F30 _xdata$x        segment dword public 'DATA' use32
.xdata$x:00001F30                 assume cs:_xdata$x
.xdata$x:00001F30                 ;org 1F30h
.xdata$x:00001F30 ; COMDAT (pick associative to section at 374)
.xdata$x:00001F30 __unwindtable$??$construct@PADAAPAD@?$allocator@D@std@@QAEXPAPADAAPAD@Z db 0FFh
.xdata$x:00001F30                                         ; DATA XREF: .xdata$x:00001F40o
.xdata$x:00001F31                 db 0FFh
.xdata$x:00001F32                 db 0FFh
.xdata$x:00001F33                 db 0FFh
.xdata$x:00001F34                 dd offset __unwindfunclet$??$construct@PADAAPAD@?$allocator@D@std@@QAEXPAPADAAPAD@Z$0
.xdata$x:00001F38 __ehfuncinfo$??$construct@PADAAPAD@?$allocator@D@std@@QAEXPAPADAAPAD@Z db  22h ; "
.xdata$x:00001F38                                         ; DATA XREF: __ehhandler$??$construct@PADAAPAD@?$allocator@D@std@@QAEXPAPADAAPAD@Z+11o
.xdata$x:00001F39                 db    5
.xdata$x:00001F3A                 db  93h ; 
.xdata$x:00001F3B                 db  19h
.xdata$x:00001F3C                 db    1
.xdata$x:00001F3D                 db    0
.xdata$x:00001F3E                 db    0
.xdata$x:00001F3F                 db    0
.xdata$x:00001F40                 dd offset __unwindtable$??$construct@PADAAPAD@?$allocator@D@std@@QAEXPAPADAAPAD@Z
.xdata$x:00001F44                 db    0
.xdata$x:00001F45                 db    0
.xdata$x:00001F46                 db    0
.xdata$x:00001F47                 db    0
.xdata$x:00001F48                 db    0
.xdata$x:00001F49                 db    0
.xdata$x:00001F4A                 db    0
.xdata$x:00001F4B                 db    0
.xdata$x:00001F4C                 db    0
.xdata$x:00001F4D                 db    0
.xdata$x:00001F4E                 db    0
.xdata$x:00001F4F                 db    0
.xdata$x:00001F50                 db    0
.xdata$x:00001F51                 db    0
.xdata$x:00001F52                 db    0
.xdata$x:00001F53                 db    0
.xdata$x:00001F54                 db    0
.xdata$x:00001F55                 db    0
.xdata$x:00001F56                 db    0
.xdata$x:00001F57                 db    0
.xdata$x:00001F58                 db    0
.xdata$x:00001F59                 db    0
.xdata$x:00001F5A                 db    0
.xdata$x:00001F5B                 db    0
.xdata$x:00001F5B _xdata$x        ends
.xdata$x:00001F5B
.bss:00001F5C ; ===========================================================================
.bss:00001F5C
.bss:00001F5C ; Segment type: Uninitialized
.bss:00001F5C ; Segment permissions: Read/Write
.bss:00001F5C _bss            segment byte public 'BSS' use32
.bss:00001F5C                 assume cs:_bss
.bss:00001F5C                 ;org 1F5Ch
.bss:00001F5C                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.bss:00001F5C _allocator_arg  db    ? ;
.bss:00001F5D _piecewise_construct db    ? ;
.bss:00001F5E                 align 10h
.bss:00001F5E _bss            ends
.bss:00001F5E
.rdata:00001F60 ; ===========================================================================
.rdata:00001F60
.rdata:00001F60 ; Segment type: Pure data
.rdata:00001F60 ; Segment permissions: Read
.rdata:00001F60 _rdata          segment dword public 'DATA' use32
.rdata:00001F60                 assume cs:_rdata
.rdata:00001F60                 ;org 1F60h
.rdata:00001F60 ; COMDAT (pick largest)
.rdata:00001F60                 dd offset ??_R4error_category@std@@6B@ ; const std::error_category::`RTTI Complete Object Locator'
.rdata:00001F64                 public ??_7error_category@std@@6B@
.rdata:00001F64 ; const std::error_category::`vftable'
.rdata:00001F64 ??_7error_category@std@@6B@ dd offset ??_Eerror_category@std@@UAEPAXI@Z
.rdata:00001F64                                         ; DATA XREF: std::error_category::error_category(void)+Ao
.rdata:00001F64                                         ; std::error_category::~error_category(void)+Ao
.rdata:00001F64                                         ; std::error_category::`vector deleting destructor'(uint)
.rdata:00001F68                 dd offset __purecall
.rdata:00001F6C                 dd offset __purecall
.rdata:00001F70                 dd offset ?default_error_condition@error_category@std@@UBE?AVerror_condition@2@H@Z ; std::error_category::default_error_condition(int)
.rdata:00001F74                 dd offset ?equivalent@error_category@std@@UBE_NABVerror_code@2@H@Z ; std::error_category::equivalent(std::error_code const &,int)
.rdata:00001F78                 dd offset ?equivalent@error_category@std@@UBE_NHABVerror_condition@2@@Z ; std::error_category::equivalent(int,std::error_condition const &)
.rdata:00001F78 _rdata          ends
.rdata:00001F78
.rdata:00001F7C ; ===========================================================================
.rdata:00001F7C
.rdata:00001F7C ; Segment type: Pure data
.rdata:00001F7C ; Segment permissions: Read
.rdata:00001F7C _rdata          segment dword public 'DATA' use32
.rdata:00001F7C                 assume cs:_rdata
.rdata:00001F7C                 ;org 1F7Ch
.rdata:00001F7C ; COMDAT (pick largest)
.rdata:00001F7C                 dd offset ??_R4_Generic_error_category@std@@6B@ ; const std::_Generic_error_category::`RTTI Complete Object Locator'
.rdata:00001F80                 public ??_7_Generic_error_category@std@@6B@
.rdata:00001F80 ; const std::_Generic_error_category::`vftable'
.rdata:00001F80 ??_7_Generic_error_category@std@@6B@ dd offset ??_E_Generic_error_category@std@@UAEPAXI@Z
.rdata:00001F80                                         ; DATA XREF: std::_Generic_error_category::_Generic_error_category(void)+38o
.rdata:00001F80                                         ; std::_Generic_error_category::`vector deleting destructor'(uint)
.rdata:00001F84                 dd offset ?name@_Generic_error_category@std@@UBEPBDXZ ; std::_Generic_error_category::name(void)
.rdata:00001F88                 dd offset ?message@_Generic_error_category@std@@UBE?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@2@H@Z ; std::_Generic_error_category::message(int)
.rdata:00001F8C                 dd offset ?default_error_condition@error_category@std@@UBE?AVerror_condition@2@H@Z ; std::error_category::default_error_condition(int)
.rdata:00001F90                 dd offset ?equivalent@error_category@std@@UBE_NABVerror_code@2@H@Z ; std::error_category::equivalent(std::error_code const &,int)
.rdata:00001F94                 dd offset ?equivalent@error_category@std@@UBE_NHABVerror_condition@2@@Z ; std::error_category::equivalent(int,std::error_condition const &)
.rdata:00001F94 _rdata          ends
.rdata:00001F94
.rdata:00001F98 ; ===========================================================================
.rdata:00001F98
.rdata:00001F98 ; Segment type: Pure data
.rdata:00001F98 ; Segment permissions: Read
.rdata:00001F98 _rdata          segment dword public 'DATA' use32
.rdata:00001F98                 assume cs:_rdata
.rdata:00001F98                 ;org 1F98h
.rdata:00001F98 ; COMDAT (pick any)
.rdata:00001F98                 public ??_C@_07DCLBNMLN@generic?$AA@
.rdata:00001F98 ; `string'
.rdata:00001F98 ??_C@_07DCLBNMLN@generic?$AA@ db 'generic',0
.rdata:00001F98                                         ; DATA XREF: std::_Generic_error_category::name(void)+7o
.rdata:00001F98 _rdata          ends
.rdata:00001F98
.rdata:00001FA0 ; ===========================================================================
.rdata:00001FA0
.rdata:00001FA0 ; Segment type: Pure data
.rdata:00001FA0 ; Segment permissions: Read
.rdata:00001FA0 _rdata          segment dword public 'DATA' use32
.rdata:00001FA0                 assume cs:_rdata
.rdata:00001FA0                 ;org 1FA0h
.rdata:00001FA0 ; COMDAT (pick any)
.rdata:00001FA0                 public ??_C@_0O@BFJCFAAK@unknown?5error?$AA@
.rdata:00001FA0 ; `string'
.rdata:00001FA0 ??_C@_0O@BFJCFAAK@unknown?5error?$AA@ db 'unknown error',0
.rdata:00001FA0                                         ; DATA XREF: std::_Generic_error_category::message(int):loc_1908o
.rdata:00001FA0                                         ; std::_System_error_category::message(int):loc_1A84o
.rdata:00001FAE                 align 10h
.rdata:00001FAE _rdata          ends
.rdata:00001FAE
.rdata:00001FB0 ; ===========================================================================
.rdata:00001FB0
.rdata:00001FB0 ; Segment type: Pure data
.rdata:00001FB0 ; Segment permissions: Read
.rdata:00001FB0 _rdata          segment dword public 'DATA' use32
.rdata:00001FB0                 assume cs:_rdata
.rdata:00001FB0                 ;org 1FB0h
.rdata:00001FB0 ; COMDAT (pick largest)
.rdata:00001FB0                 dd offset ??_R4_Iostream_error_category@std@@6B@ ; const std::_Iostream_error_category::`RTTI Complete Object Locator'
.rdata:00001FB4                 public ??_7_Iostream_error_category@std@@6B@
.rdata:00001FB4 ; const std::_Iostream_error_category::`vftable'
.rdata:00001FB4 ??_7_Iostream_error_category@std@@6B@ dd offset ??_E_Iostream_error_category@std@@UAEPAXI@Z
.rdata:00001FB4                                         ; DATA XREF: std::_Iostream_error_category::_Iostream_error_category(void)+38o
.rdata:00001FB4                                         ; std::_Iostream_error_category::`vector deleting destructor'(uint)
.rdata:00001FB8                 dd offset ?name@_Iostream_error_category@std@@UBEPBDXZ ; std::_Iostream_error_category::name(void)
.rdata:00001FBC                 dd offset ?message@_Iostream_error_category@std@@UBE?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@2@H@Z ; std::_Iostream_error_category::message(int)
.rdata:00001FC0                 dd offset ?default_error_condition@error_category@std@@UBE?AVerror_condition@2@H@Z ; std::error_category::default_error_condition(int)
.rdata:00001FC4                 dd offset ?equivalent@error_category@std@@UBE_NABVerror_code@2@H@Z ; std::error_category::equivalent(std::error_code const &,int)
.rdata:00001FC8                 dd offset ?equivalent@error_category@std@@UBE_NHABVerror_condition@2@@Z ; std::error_category::equivalent(int,std::error_condition const &)
.rdata:00001FC8 _rdata          ends
.rdata:00001FC8
.rdata:00001FCC ; ===========================================================================
.rdata:00001FCC
.rdata:00001FCC ; Segment type: Pure data
.rdata:00001FCC ; Segment permissions: Read
.rdata:00001FCC _rdata          segment dword public 'DATA' use32
.rdata:00001FCC                 assume cs:_rdata
.rdata:00001FCC                 ;org 1FCCh
.rdata:00001FCC ; COMDAT (pick any)
.rdata:00001FCC                 public ??_C@_08LLGCOLLL@iostream?$AA@
.rdata:00001FCC ; `string'
.rdata:00001FCC ??_C@_08LLGCOLLL@iostream?$AA@ db 'iostream',0
.rdata:00001FCC                                         ; DATA XREF: std::_Iostream_error_category::name(void)+7o
.rdata:00001FD5                 align 4
.rdata:00001FD5 _rdata          ends
.rdata:00001FD5
.rdata:00001FD8 ; ===========================================================================
.rdata:00001FD8
.rdata:00001FD8 ; Segment type: Pure data
.rdata:00001FD8 ; Segment permissions: Read
.rdata:00001FD8 _rdata          segment dword public 'DATA' use32
.rdata:00001FD8                 assume cs:_rdata
.rdata:00001FD8                 ;org 1FD8h
.rdata:00001FD8 ; COMDAT (pick any)
.rdata:00001FD8                 public ??_C@_0BG@PADBLCHM@iostream?5stream?5error?$AA@
.rdata:00001FD8 ; char `string'[]
.rdata:00001FD8 ??_C@_0BG@PADBLCHM@iostream?5stream?5error?$AA@ db 'iostream stream error',0
.rdata:00001FD8                                         ; DATA XREF: std::_Iostream_error_category::message(int)+35o
.rdata:00001FEE                 align 10h
.rdata:00001FEE _rdata          ends
.rdata:00001FEE
.rdata:00001FF0 ; ===========================================================================
.rdata:00001FF0
.rdata:00001FF0 ; Segment type: Pure data
.rdata:00001FF0 ; Segment permissions: Read
.rdata:00001FF0 _rdata          segment dword public 'DATA' use32
.rdata:00001FF0                 assume cs:_rdata
.rdata:00001FF0                 ;org 1FF0h
.rdata:00001FF0 ; COMDAT (pick largest)
.rdata:00001FF0                 dd offset ??_R4_System_error_category@std@@6B@ ; const std::_System_error_category::`RTTI Complete Object Locator'
.rdata:00001FF4                 public ??_7_System_error_category@std@@6B@
.rdata:00001FF4 ; const std::_System_error_category::`vftable'
.rdata:00001FF4 ??_7_System_error_category@std@@6B@ dd offset ??_E_System_error_category@std@@UAEPAXI@Z
.rdata:00001FF4                                         ; DATA XREF: std::_System_error_category::_System_error_category(void)+38o
.rdata:00001FF4                                         ; std::_System_error_category::`vector deleting destructor'(uint)
.rdata:00001FF8                 dd offset ?name@_System_error_category@std@@UBEPBDXZ ; std::_System_error_category::name(void)
.rdata:00001FFC                 dd offset ?message@_System_error_category@std@@UBE?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@2@H@Z ; std::_System_error_category::message(int)
.rdata:00002000                 dd offset ?default_error_condition@_System_error_category@std@@UBE?AVerror_condition@2@H@Z ; std::_System_error_category::default_error_condition(int)
.rdata:00002004                 dd offset ?equivalent@error_category@std@@UBE_NABVerror_code@2@H@Z ; std::error_category::equivalent(std::error_code const &,int)
.rdata:00002008                 dd offset ?equivalent@error_category@std@@UBE_NHABVerror_condition@2@@Z ; std::error_category::equivalent(int,std::error_condition const &)
.rdata:00002008 _rdata          ends
.rdata:00002008
.rdata:0000200C ; ===========================================================================
.rdata:0000200C
.rdata:0000200C ; Segment type: Pure data
.rdata:0000200C ; Segment permissions: Read
.rdata:0000200C _rdata          segment dword public 'DATA' use32
.rdata:0000200C                 assume cs:_rdata
.rdata:0000200C                 ;org 200Ch
.rdata:0000200C ; COMDAT (pick any)
.rdata:0000200C                 public ??_C@_06FHFOAHML@system?$AA@
.rdata:0000200C ; `string'
.rdata:0000200C ??_C@_06FHFOAHML@system?$AA@ db 'system',0
.rdata:0000200C                                         ; DATA XREF: std::_System_error_category::name(void)+7o
.rdata:00002013                 align 4
.rdata:00002013 _rdata          ends
.rdata:00002013
.bss:00002014 ; ===========================================================================
.bss:00002014
.bss:00002014 ; Segment type: Uninitialized
.bss:00002014 ; Segment permissions: Read/Write
.bss:00002014 _bss            segment dword public 'BSS' use32
.bss:00002014                 assume cs:_bss
.bss:00002014                 ;org 2014h
.bss:00002014 ; COMDAT (pick any)
.bss:00002014                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.bss:00002014                 public ?_Generic_object@?$_Error_objects@H@std@@2V_Generic_error_category@2@A
.bss:00002014 ; std::_Generic_error_category std::_Error_objects<int>::_Generic_object
.bss:00002014 ?_Generic_object@?$_Error_objects@H@std@@2V_Generic_error_category@2@A db    ? ;
.bss:00002014                                         ; DATA XREF: `dynamic initializer for 'std::_Generic_error_category std::_Error_objects<int>::_Generic_object''(void)+3o
.bss:00002014                                         ; `dynamic atexit destructor for 'std::_Generic_error_category std::_Error_objects<int>::_Generic_object''(void)+3o ...
.bss:00002015                 db    ? ;
.bss:00002016                 db    ? ;
.bss:00002017                 db    ? ;
.bss:00002017 _bss            ends
.bss:00002017
.bss:00002018 ; ===========================================================================
.bss:00002018
.bss:00002018 ; Segment type: Uninitialized
.bss:00002018 ; Segment permissions: Read/Write
.bss:00002018 _bss            segment dword public 'BSS' use32
.bss:00002018                 assume cs:_bss
.bss:00002018                 ;org 2018h
.bss:00002018 ; COMDAT (pick any)
.bss:00002018                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.bss:00002018                 public ?_Iostream_object@?$_Error_objects@H@std@@2V_Iostream_error_category@2@A
.bss:00002018 ; std::_Iostream_error_category std::_Error_objects<int>::_Iostream_object
.bss:00002018 ?_Iostream_object@?$_Error_objects@H@std@@2V_Iostream_error_category@2@A db    ? ;
.bss:00002018                                         ; DATA XREF: `dynamic initializer for 'std::_Iostream_error_category std::_Error_objects<int>::_Iostream_object''(void)+3o
.bss:00002018                                         ; `dynamic atexit destructor for 'std::_Iostream_error_category std::_Error_objects<int>::_Iostream_object''(void)+3o
.bss:00002019                 db    ? ;
.bss:0000201A                 db    ? ;
.bss:0000201B                 db    ? ;
.bss:0000201B _bss            ends
.bss:0000201B
.bss:0000201C ; ===========================================================================
.bss:0000201C
.bss:0000201C ; Segment type: Uninitialized
.bss:0000201C ; Segment permissions: Read/Write
.bss:0000201C _bss            segment dword public 'BSS' use32
.bss:0000201C                 assume cs:_bss
.bss:0000201C                 ;org 201Ch
.bss:0000201C ; COMDAT (pick any)
.bss:0000201C                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.bss:0000201C                 public ?_System_object@?$_Error_objects@H@std@@2V_System_error_category@2@A
.bss:0000201C ; std::_System_error_category std::_Error_objects<int>::_System_object
.bss:0000201C ?_System_object@?$_Error_objects@H@std@@2V_System_error_category@2@A db    ? ;
.bss:0000201C                                         ; DATA XREF: `dynamic initializer for 'std::_System_error_category std::_Error_objects<int>::_System_object''(void)+3o
.bss:0000201C                                         ; `dynamic atexit destructor for 'std::_System_error_category std::_Error_objects<int>::_System_object''(void)+3o ...
.bss:0000201D                 db    ? ;
.bss:0000201E                 db    ? ;
.bss:0000201F                 db    ? ;
.bss:0000201F _bss            ends
.bss:0000201F
.bss:00002020 ; ===========================================================================
.bss:00002020
.bss:00002020 ; Segment type: Uninitialized
.bss:00002020 ; Segment permissions: Read/Write
.bss:00002020 _bss            segment dword public 'BSS' use32
.bss:00002020                 assume cs:_bss
.bss:00002020                 ;org 2020h
.bss:00002020 ; COMDAT (pick any)
.bss:00002020                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.bss:00002020                 public ?id@?$num_put@DV?$back_insert_iterator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@std@@2V0locale@2@A
.bss:00002020 ; std::locale::id std::num_put<char,std::back_insert_iterator<std::basic_string<char,std::char_traits<char>,std::allocator<char>>>>::id
.bss:00002020 ?id@?$num_put@DV?$back_insert_iterator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@std@@2V0locale@2@A db    ? ;
.bss:00002020                                         ; DATA XREF: `dynamic initializer for 'std::locale::id std::num_put<char,std::back_insert_iterator<std::basic_string<char,std::char_traits<char>,std::allocator<char>>>>::id''(void)+5o
.bss:00002021                 db    ? ;
.bss:00002022                 db    ? ;
.bss:00002023                 db    ? ;
.bss:00002023 _bss            ends
.bss:00002023
.bss:00002024 ; ===========================================================================
.bss:00002024
.bss:00002024 ; Segment type: Uninitialized
.bss:00002024 ; Segment permissions: Read/Write
.bss:00002024 _bss            segment dword public 'BSS' use32
.bss:00002024                 assume cs:_bss
.bss:00002024                 ;org 2024h
.bss:00002024 ; COMDAT (pick any)
.bss:00002024                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.bss:00002024                 public ?id@?$num_put@_WV?$back_insert_iterator@V?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@@std@@@std@@2V0locale@2@A
.bss:00002024 ; std::locale::id std::num_put<wchar_t,std::back_insert_iterator<std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>>>>::id
.bss:00002024 ?id@?$num_put@_WV?$back_insert_iterator@V?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@@std@@@std@@2V0locale@2@A db    ? ;
.bss:00002024                                         ; DATA XREF: `dynamic initializer for 'std::locale::id std::num_put<wchar_t,std::back_insert_iterator<std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>>>>::id''(void)+5o
.bss:00002025                 db    ? ;
.bss:00002026                 db    ? ;
.bss:00002027                 db    ? ;
.bss:00002027 _bss            ends
.bss:00002027
.rdata:00002028 ; ===========================================================================
.rdata:00002028
.rdata:00002028 ; Segment type: Pure data
.rdata:00002028 ; Segment permissions: Read
.rdata:00002028 ; Segment alignment 'qword' can not be represented in assembly
.rdata:00002028 _rdata          segment para public 'DATA' use32
.rdata:00002028                 assume cs:_rdata
.rdata:00002028                 ;org 2028h
.rdata:00002028 ; COMDAT (pick any)
.rdata:00002028                 public ??_C@_1IO@FEAPGJBD@?$AAC?$AA?3?$AA?2?$AAP?$AAr?$AAo?$AAg?$AAr?$AAa?$AAm?$AA?5?$AAF?$AAi?$AAl?$AAe?$AAs?$AA?5?$AA?$CI?$AAx?$AA8?$AA6?$AA?$CJ?$AA?2?$AAM?$AAi?$AAc?$AAr?$AAo?$AAs?$AAo?$AAf?$AAt@
.rdata:00002028 ; wchar_t `string'
.rdata:00002028 ??_C@_1IO@FEAPGJBD@?$AAC?$AA?3?$AA?2?$AAP?$AAr?$AAo?$AAg?$AAr?$AAa?$AAm?$AA?5?$AAF?$AAi?$AAl?$AAe?$AAs?$AA?5?$AA?$CI?$AAx?$AA8?$AA6?$AA?$CJ?$AA?2?$AAM?$AAi?$AAc?$AAr?$AAo?$AAs?$AAo?$AAf?$AAt@:
.rdata:00002028                                         ; DATA XREF: std::basic_string<char,std::char_traits<char>,std::allocator<char>>::assign(char const *)+Co
.rdata:00002028                                         ; std::basic_string<char,std::char_traits<char>,std::allocator<char>>::assign(char const *,uint)+12o
.rdata:00002028                 unicode 0, <C:\Program Files (x86)\Microsoft Visual Studio 12.0\VC\in>
.rdata:00002028                 unicode 0, <clude\xstring>,0
.rdata:000020B6                 align 4
.rdata:000020B6 _rdata          ends
.rdata:000020B6
.bss:000020B8 ; ===========================================================================
.bss:000020B8
.bss:000020B8 ; Segment type: Uninitialized
.bss:000020B8 ; Segment permissions: Read/Write
.bss:000020B8 _bss            segment dword public 'BSS' use32
.bss:000020B8                 assume cs:_bss
.bss:000020B8                 ;org 20B8h
.bss:000020B8 ; COMDAT (pick any)
.bss:000020B8                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.bss:000020B8                 public ?id@?$numpunct@D@std@@2V0locale@2@A
.bss:000020B8 ; std::locale::id std::numpunct<char>::id
.bss:000020B8 ?id@?$numpunct@D@std@@2V0locale@2@A db    ? ;
.bss:000020B8                                         ; DATA XREF: `dynamic initializer for 'std::locale::id std::numpunct<char>::id''(void)+5o
.bss:000020B9                 db    ? ;
.bss:000020BA                 db    ? ;
.bss:000020BB                 db    ? ;
.bss:000020BB _bss            ends
.bss:000020BB
.bss:000020BC ; ===========================================================================
.bss:000020BC
.bss:000020BC ; Segment type: Uninitialized
.bss:000020BC ; Segment permissions: Read/Write
.bss:000020BC _bss            segment dword public 'BSS' use32
.bss:000020BC                 assume cs:_bss
.bss:000020BC                 ;org 20BCh
.bss:000020BC ; COMDAT (pick any)
.bss:000020BC                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.bss:000020BC                 public ?id@?$numpunct@_W@std@@2V0locale@2@A
.bss:000020BC ; std::locale::id std::numpunct<wchar_t>::id
.bss:000020BC ?id@?$numpunct@_W@std@@2V0locale@2@A db    ? ;
.bss:000020BC                                         ; DATA XREF: `dynamic initializer for 'std::locale::id std::numpunct<wchar_t>::id''(void)+5o
.bss:000020BD                 db    ? ;
.bss:000020BE                 db    ? ;
.bss:000020BF                 db    ? ;
.bss:000020BF _bss            ends
.bss:000020BF
.rdata:000020C0 ; ===========================================================================
.rdata:000020C0
.rdata:000020C0 ; Segment type: Pure data
.rdata:000020C0 ; Segment permissions: Read
.rdata:000020C0 _rdata          segment dword public 'DATA' use32
.rdata:000020C0                 assume cs:_rdata
.rdata:000020C0                 ;org 20C0h
.rdata:000020C0 ; COMDAT (pick any)
.rdata:000020C0                 public ??_C@_0BA@JFNIOLAK@string?5too?5long?$AA@
.rdata:000020C0 ; char `string'[]
.rdata:000020C0 ??_C@_0BA@JFNIOLAK@string?5too?5long?$AA@ db 'string too long',0
.rdata:000020C0                                         ; DATA XREF: std::basic_string<char,std::char_traits<char>,std::allocator<char>>::_Xlen(void)+7o
.rdata:000020C0 _rdata          ends
.rdata:000020C0
.rdata:000020D0 ; ===========================================================================
.rdata:000020D0
.rdata:000020D0 ; Segment type: Pure data
.rdata:000020D0 ; Segment permissions: Read
.rdata:000020D0 _rdata          segment dword public 'DATA' use32
.rdata:000020D0                 assume cs:_rdata
.rdata:000020D0                 ;org 20D0h
.rdata:000020D0 ; COMDAT (pick any)
.rdata:000020D0                 public ??_C@_0BI@CFPLBAOH@invalid?5string?5position?$AA@
.rdata:000020D0 ; char `string'[]
.rdata:000020D0 ??_C@_0BI@CFPLBAOH@invalid?5string?5position?$AA@ db 'invalid string position',0
.rdata:000020D0                                         ; DATA XREF: std::basic_string<char,std::char_traits<char>,std::allocator<char>>::_Xran(void)+7o
.rdata:000020D0 _rdata          ends
.rdata:000020D0
.rdata:000020E8 ; ===========================================================================
.rdata:000020E8
.rdata:000020E8 ; Segment type: Pure data
.rdata:000020E8 ; Segment permissions: Read
.rdata:000020E8 _rdata          segment dword public 'DATA' use32
.rdata:000020E8                 assume cs:_rdata
.rdata:000020E8                 ;org 20E8h
.rdata:000020E8 ; COMDAT (pick any)
.rdata:000020E8                 public ??_C@_1CK@EOPGIILJ@?$AAi?$AAn?$AAv?$AAa?$AAl?$AAi?$AAd?$AA?5?$AAn?$AAu?$AAl?$AAl?$AA?5?$AAp?$AAo?$AAi?$AAn?$AAt?$AAe?$AAr?$AA?$AA@
.rdata:000020E8 ; wchar_t `string'
.rdata:000020E8 ??_C@_1CK@EOPGIILJ@?$AAi?$AAn?$AAv?$AAa?$AAl?$AAi?$AAd?$AA?5?$AAn?$AAu?$AAl?$AAl?$AA?5?$AAp?$AAo?$AAi?$AAn?$AAt?$AAe?$AAr?$AA?$AA@:
.rdata:000020E8                                         ; DATA XREF: std::_Debug_pointer<char>(char const *,wchar_t const *,uint)+11o
.rdata:000020E8                 unicode 0, <invalid null pointer>,0
.rdata:00002112                 align 4
.rdata:00002112 _rdata          ends
.rdata:00002112
.rdata$r:00002114 ; ===========================================================================
.rdata$r:00002114
.rdata$r:00002114 ; Segment type: Pure data
.rdata$r:00002114 ; Segment permissions: Read
.rdata$r:00002114 _rdata$r        segment dword public 'DATA' use32
.rdata$r:00002114                 assume cs:_rdata$r
.rdata$r:00002114                 ;org 2114h
.rdata$r:00002114 ; COMDAT (pick any)
.rdata$r:00002114                 public ??_R4error_category@std@@6B@
.rdata$r:00002114 ; const std::error_category::`RTTI Complete Object Locator'
.rdata$r:00002114 ??_R4error_category@std@@6B@ db    0    ; DATA XREF: .rdata:00001F60o
.rdata$r:00002115                 db    0
.rdata$r:00002116                 db    0
.rdata$r:00002117                 db    0
.rdata$r:00002118                 db    0
.rdata$r:00002119                 db    0
.rdata$r:0000211A                 db    0
.rdata$r:0000211B                 db    0
.rdata$r:0000211C                 db    0
.rdata$r:0000211D                 db    0
.rdata$r:0000211E                 db    0
.rdata$r:0000211F                 db    0
.rdata$r:00002120                 dd offset ??_R0?AVerror_category@std@@@8 ; std::error_category `RTTI Type Descriptor'
.rdata$r:00002124                 dd offset ??_R3error_category@std@@8 ; std::error_category::`RTTI Class Hierarchy Descriptor'
.rdata$r:00002124 _rdata$r        ends
.rdata$r:00002124
.data$r:00002128 ; ===========================================================================
.data$r:00002128
.data$r:00002128 ; Segment type: Pure data
.data$r:00002128 ; Segment permissions: Read/Write
.data$r:00002128 _data$r         segment dword public 'DATA' use32
.data$r:00002128                 assume cs:_data$r
.data$r:00002128                 ;org 2128h
.data$r:00002128 ; COMDAT (pick any)
.data$r:00002128                 public ??_R0?AVerror_category@std@@@8
.data$r:00002128 ; class std::error_category `RTTI Type Descriptor'
.data$r:00002128 ??_R0?AVerror_category@std@@@8 dd offset ??_7type_info@@6B@
.data$r:00002128                                         ; DATA XREF: .rdata$r:00002120o
.data$r:00002128                                         ; .rdata$r:std::error_category::`RTTI Base Class Descriptor at (0,-1,0,64)'o
.data$r:00002128                                         ; const type_info::`vftable'
.data$r:0000212C                 align 10h
.data$r:00002130 a_?averror_cate db '.?AVerror_category@std@@',0
.data$r:00002149                 align 4
.data$r:00002149 _data$r         ends
.data$r:00002149
.rdata$r:0000214C ; ===========================================================================
.rdata$r:0000214C
.rdata$r:0000214C ; Segment type: Pure data
.rdata$r:0000214C ; Segment permissions: Read
.rdata$r:0000214C _rdata$r        segment dword public 'DATA' use32
.rdata$r:0000214C                 assume cs:_rdata$r
.rdata$r:0000214C                 ;org 214Ch
.rdata$r:0000214C ; COMDAT (pick any)
.rdata$r:0000214C                 public ??_R3error_category@std@@8
.rdata$r:0000214C ; std::error_category::`RTTI Class Hierarchy Descriptor'
.rdata$r:0000214C ??_R3error_category@std@@8 db    0      ; DATA XREF: .rdata$r:00002124o
.rdata$r:0000214C                                         ; .rdata$r:0000217Co
.rdata$r:0000214D                 db    0
.rdata$r:0000214E                 db    0
.rdata$r:0000214F                 db    0
.rdata$r:00002150                 db    0
.rdata$r:00002151                 db    0
.rdata$r:00002152                 db    0
.rdata$r:00002153                 db    0
.rdata$r:00002154                 db    1
.rdata$r:00002155                 db    0
.rdata$r:00002156                 db    0
.rdata$r:00002157                 db    0
.rdata$r:00002158                 dd offset ??_R2error_category@std@@8 ; std::error_category::`RTTI Base Class Array'
.rdata$r:00002158 _rdata$r        ends
.rdata$r:00002158
.rdata$r:0000215C ; ===========================================================================
.rdata$r:0000215C
.rdata$r:0000215C ; Segment type: Pure data
.rdata$r:0000215C ; Segment permissions: Read
.rdata$r:0000215C _rdata$r        segment dword public 'DATA' use32
.rdata$r:0000215C                 assume cs:_rdata$r
.rdata$r:0000215C                 ;org 215Ch
.rdata$r:0000215C ; COMDAT (pick any)
.rdata$r:0000215C                 public ??_R2error_category@std@@8
.rdata$r:0000215C ; std::error_category::`RTTI Base Class Array'
.rdata$r:0000215C ??_R2error_category@std@@8 dd offset ??_R1A@?0A@EA@error_category@std@@8
.rdata$r:0000215C                                         ; DATA XREF: .rdata$r:00002158o
.rdata$r:0000215C                                         ; std::error_category::`RTTI Base Class Descriptor at (0,-1,0,64)'
.rdata$r:00002160                 db    0
.rdata$r:00002161                 align 4
.rdata$r:00002161 _rdata$r        ends
.rdata$r:00002161
.rdata$r:00002164 ; ===========================================================================
.rdata$r:00002164
.rdata$r:00002164 ; Segment type: Pure data
.rdata$r:00002164 ; Segment permissions: Read
.rdata$r:00002164 _rdata$r        segment dword public 'DATA' use32
.rdata$r:00002164                 assume cs:_rdata$r
.rdata$r:00002164                 ;org 2164h
.rdata$r:00002164 ; COMDAT (pick any)
.rdata$r:00002164                 public ??_R1A@?0A@EA@error_category@std@@8
.rdata$r:00002164 ; std::error_category::`RTTI Base Class Descriptor at (0, -1, 0, 64)'
.rdata$r:00002164 ??_R1A@?0A@EA@error_category@std@@8 dd offset ??_R0?AVerror_category@std@@@8
.rdata$r:00002164                                         ; DATA XREF: .rdata$r:std::error_category::`RTTI Base Class Array'o
.rdata$r:00002164                                         ; .rdata$r:000021D4o ...
.rdata$r:00002164                                         ; std::error_category `RTTI Type Descriptor'
.rdata$r:00002168                 align 10h
.rdata$r:00002170                 db 0FFh
.rdata$r:00002171                 db 0FFh
.rdata$r:00002172                 db 0FFh
.rdata$r:00002173                 db 0FFh
.rdata$r:00002174                 db    0
.rdata$r:00002175                 db    0
.rdata$r:00002176                 db    0
.rdata$r:00002177                 db    0
.rdata$r:00002178                 db  40h ; @
.rdata$r:00002179                 db    0
.rdata$r:0000217A                 db    0
.rdata$r:0000217B                 db    0
.rdata$r:0000217C                 dd offset ??_R3error_category@std@@8 ; std::error_category::`RTTI Class Hierarchy Descriptor'
.rdata$r:0000217C _rdata$r        ends
.rdata$r:0000217C
.rdata$r:00002180 ; ===========================================================================
.rdata$r:00002180
.rdata$r:00002180 ; Segment type: Pure data
.rdata$r:00002180 ; Segment permissions: Read
.rdata$r:00002180 _rdata$r        segment dword public 'DATA' use32
.rdata$r:00002180                 assume cs:_rdata$r
.rdata$r:00002180                 ;org 2180h
.rdata$r:00002180 ; COMDAT (pick any)
.rdata$r:00002180                 public ??_R4_Generic_error_category@std@@6B@
.rdata$r:00002180 ; const std::_Generic_error_category::`RTTI Complete Object Locator'
.rdata$r:00002180 ??_R4_Generic_error_category@std@@6B@ db    0
.rdata$r:00002180                                         ; DATA XREF: .rdata:00001F7Co
.rdata$r:00002181                 db    0
.rdata$r:00002182                 db    0
.rdata$r:00002183                 db    0
.rdata$r:00002184                 db    0
.rdata$r:00002185                 db    0
.rdata$r:00002186                 db    0
.rdata$r:00002187                 db    0
.rdata$r:00002188                 db    0
.rdata$r:00002189                 db    0
.rdata$r:0000218A                 db    0
.rdata$r:0000218B                 db    0
.rdata$r:0000218C                 dd offset ??_R0?AV_Generic_error_category@std@@@8 ; std::_Generic_error_category `RTTI Type Descriptor'
.rdata$r:00002190                 dd offset ??_R3_Generic_error_category@std@@8 ; std::_Generic_error_category::`RTTI Class Hierarchy Descriptor'
.rdata$r:00002190 _rdata$r        ends
.rdata$r:00002190
.data$r:00002194 ; ===========================================================================
.data$r:00002194
.data$r:00002194 ; Segment type: Pure data
.data$r:00002194 ; Segment permissions: Read/Write
.data$r:00002194 _data$r         segment dword public 'DATA' use32
.data$r:00002194                 assume cs:_data$r
.data$r:00002194                 ;org 2194h
.data$r:00002194 ; COMDAT (pick any)
.data$r:00002194                 public ??_R0?AV_Generic_error_category@std@@@8
.data$r:00002194 ; class std::_Generic_error_category `RTTI Type Descriptor'
.data$r:00002194 ??_R0?AV_Generic_error_category@std@@@8 dd offset ??_7type_info@@6B@
.data$r:00002194                                         ; DATA XREF: .rdata$r:0000218Co
.data$r:00002194                                         ; .rdata$r:std::_Generic_error_category::`RTTI Base Class Descriptor at (0,-1,0,64)'o
.data$r:00002194                                         ; const type_info::`vftable'
.data$r:00002198                 db    0
.data$r:00002199                 db    0
.data$r:0000219A                 db    0
.data$r:0000219B                 db    0
.data$r:0000219C                 db  2Eh ; .
.data$r:0000219D                 db  3Fh ; ?
.data$r:0000219E                 db  41h ; A
.data$r:0000219F                 db  56h ; V
.data$r:000021A0                 db  5Fh ; _
.data$r:000021A1                 db  47h ; G
.data$r:000021A2                 db  65h ; e
.data$r:000021A3                 db  6Eh ; n
.data$r:000021A4                 db  65h ; e
.data$r:000021A5                 db  72h ; r
.data$r:000021A6                 db  69h ; i
.data$r:000021A7                 db  63h ; c
.data$r:000021A8                 db  5Fh ; _
.data$r:000021A9                 db  65h ; e
.data$r:000021AA                 db  72h ; r
.data$r:000021AB                 db  72h ; r
.data$r:000021AC                 db  6Fh ; o
.data$r:000021AD                 db  72h ; r
.data$r:000021AE                 db  5Fh ; _
.data$r:000021AF                 db  63h ; c
.data$r:000021B0                 db  61h ; a
.data$r:000021B1                 db  74h ; t
.data$r:000021B2                 db  65h ; e
.data$r:000021B3                 db  67h ; g
.data$r:000021B4                 db  6Fh ; o
.data$r:000021B5                 db  72h ; r
.data$r:000021B6                 db  79h ; y
.data$r:000021B7                 db  40h ; @
.data$r:000021B8                 db  73h ; s
.data$r:000021B9                 db  74h ; t
.data$r:000021BA                 db  64h ; d
.data$r:000021BB                 db  40h ; @
.data$r:000021BC                 db  40h ; @
.data$r:000021BD                 db    0
.data$r:000021BE                 align 10h
.data$r:000021BE _data$r         ends
.data$r:000021BE
.rdata$r:000021C0 ; ===========================================================================
.rdata$r:000021C0
.rdata$r:000021C0 ; Segment type: Pure data
.rdata$r:000021C0 ; Segment permissions: Read
.rdata$r:000021C0 _rdata$r        segment dword public 'DATA' use32
.rdata$r:000021C0                 assume cs:_rdata$r
.rdata$r:000021C0                 ;org 21C0h
.rdata$r:000021C0 ; COMDAT (pick any)
.rdata$r:000021C0                 public ??_R3_Generic_error_category@std@@8
.rdata$r:000021C0 ; std::_Generic_error_category::`RTTI Class Hierarchy Descriptor'
.rdata$r:000021C0 ??_R3_Generic_error_category@std@@8 db    0
.rdata$r:000021C0                                         ; DATA XREF: .rdata$r:00002190o
.rdata$r:000021C0                                         ; .rdata$r:000021F4o
.rdata$r:000021C1                 db    0
.rdata$r:000021C2                 db    0
.rdata$r:000021C3                 db    0
.rdata$r:000021C4                 db    0
.rdata$r:000021C5                 db    0
.rdata$r:000021C6                 db    0
.rdata$r:000021C7                 db    0
.rdata$r:000021C8                 db    2
.rdata$r:000021C9                 db    0
.rdata$r:000021CA                 db    0
.rdata$r:000021CB                 db    0
.rdata$r:000021CC                 dd offset ??_R2_Generic_error_category@std@@8 ; std::_Generic_error_category::`RTTI Base Class Array'
.rdata$r:000021CC _rdata$r        ends
.rdata$r:000021CC
.rdata$r:000021D0 ; ===========================================================================
.rdata$r:000021D0
.rdata$r:000021D0 ; Segment type: Pure data
.rdata$r:000021D0 ; Segment permissions: Read
.rdata$r:000021D0 _rdata$r        segment dword public 'DATA' use32
.rdata$r:000021D0                 assume cs:_rdata$r
.rdata$r:000021D0                 ;org 21D0h
.rdata$r:000021D0 ; COMDAT (pick any)
.rdata$r:000021D0                 public ??_R2_Generic_error_category@std@@8
.rdata$r:000021D0 ; std::_Generic_error_category::`RTTI Base Class Array'
.rdata$r:000021D0 ??_R2_Generic_error_category@std@@8 dd offset ??_R1A@?0A@EA@_Generic_error_category@std@@8
.rdata$r:000021D0                                         ; DATA XREF: .rdata$r:000021CCo
.rdata$r:000021D0                                         ; std::_Generic_error_category::`RTTI Base Class Descriptor at (0,-1,0,64)'
.rdata$r:000021D4                 dd offset ??_R1A@?0A@EA@error_category@std@@8 ; std::error_category::`RTTI Base Class Descriptor at (0,-1,0,64)'
.rdata$r:000021D8                 db    0
.rdata$r:000021D9                 align 4
.rdata$r:000021D9 _rdata$r        ends
.rdata$r:000021D9
.rdata$r:000021DC ; ===========================================================================
.rdata$r:000021DC
.rdata$r:000021DC ; Segment type: Pure data
.rdata$r:000021DC ; Segment permissions: Read
.rdata$r:000021DC _rdata$r        segment dword public 'DATA' use32
.rdata$r:000021DC                 assume cs:_rdata$r
.rdata$r:000021DC                 ;org 21DCh
.rdata$r:000021DC ; COMDAT (pick any)
.rdata$r:000021DC                 public ??_R1A@?0A@EA@_Generic_error_category@std@@8
.rdata$r:000021DC ; std::_Generic_error_category::`RTTI Base Class Descriptor at (0, -1, 0, 64)'
.rdata$r:000021DC ??_R1A@?0A@EA@_Generic_error_category@std@@8 dd offset ??_R0?AV_Generic_error_category@std@@@8
.rdata$r:000021DC                                         ; DATA XREF: .rdata$r:std::_Generic_error_category::`RTTI Base Class Array'o
.rdata$r:000021DC                                         ; .rdata$r:0000224Co ...
.rdata$r:000021DC                                         ; std::_Generic_error_category `RTTI Type Descriptor'
.rdata$r:000021E0                 db    1
.rdata$r:000021E1                 db    0
.rdata$r:000021E2                 db    0
.rdata$r:000021E3                 db    0
.rdata$r:000021E4                 db    0
.rdata$r:000021E5                 db    0
.rdata$r:000021E6                 db    0
.rdata$r:000021E7                 db    0
.rdata$r:000021E8                 db 0FFh
.rdata$r:000021E9                 db 0FFh
.rdata$r:000021EA                 db 0FFh
.rdata$r:000021EB                 db 0FFh
.rdata$r:000021EC                 db    0
.rdata$r:000021ED                 db    0
.rdata$r:000021EE                 db    0
.rdata$r:000021EF                 db    0
.rdata$r:000021F0                 db  40h ; @
.rdata$r:000021F1                 db    0
.rdata$r:000021F2                 db    0
.rdata$r:000021F3                 db    0
.rdata$r:000021F4                 dd offset ??_R3_Generic_error_category@std@@8 ; std::_Generic_error_category::`RTTI Class Hierarchy Descriptor'
.rdata$r:000021F4 _rdata$r        ends
.rdata$r:000021F4
.rdata$r:000021F8 ; ===========================================================================
.rdata$r:000021F8
.rdata$r:000021F8 ; Segment type: Pure data
.rdata$r:000021F8 ; Segment permissions: Read
.rdata$r:000021F8 _rdata$r        segment dword public 'DATA' use32
.rdata$r:000021F8                 assume cs:_rdata$r
.rdata$r:000021F8                 ;org 21F8h
.rdata$r:000021F8 ; COMDAT (pick any)
.rdata$r:000021F8                 public ??_R4_Iostream_error_category@std@@6B@
.rdata$r:000021F8 ; const std::_Iostream_error_category::`RTTI Complete Object Locator'
.rdata$r:000021F8 ??_R4_Iostream_error_category@std@@6B@ db    0
.rdata$r:000021F8                                         ; DATA XREF: .rdata:00001FB0o
.rdata$r:000021F9                 db    0
.rdata$r:000021FA                 db    0
.rdata$r:000021FB                 db    0
.rdata$r:000021FC                 db    0
.rdata$r:000021FD                 db    0
.rdata$r:000021FE                 db    0
.rdata$r:000021FF                 db    0
.rdata$r:00002200                 db    0
.rdata$r:00002201                 db    0
.rdata$r:00002202                 db    0
.rdata$r:00002203                 db    0
.rdata$r:00002204                 dd offset ??_R0?AV_Iostream_error_category@std@@@8 ; std::_Iostream_error_category `RTTI Type Descriptor'
.rdata$r:00002208                 dd offset ??_R3_Iostream_error_category@std@@8 ; std::_Iostream_error_category::`RTTI Class Hierarchy Descriptor'
.rdata$r:00002208 _rdata$r        ends
.rdata$r:00002208
.data$r:0000220C ; ===========================================================================
.data$r:0000220C
.data$r:0000220C ; Segment type: Pure data
.data$r:0000220C ; Segment permissions: Read/Write
.data$r:0000220C _data$r         segment dword public 'DATA' use32
.data$r:0000220C                 assume cs:_data$r
.data$r:0000220C                 ;org 220Ch
.data$r:0000220C ; COMDAT (pick any)
.data$r:0000220C                 public ??_R0?AV_Iostream_error_category@std@@@8
.data$r:0000220C ; class std::_Iostream_error_category `RTTI Type Descriptor'
.data$r:0000220C ??_R0?AV_Iostream_error_category@std@@@8 dd offset ??_7type_info@@6B@
.data$r:0000220C                                         ; DATA XREF: .rdata$r:00002204o
.data$r:0000220C                                         ; .rdata$r:std::_Iostream_error_category::`RTTI Base Class Descriptor at (0,-1,0,64)'o
.data$r:0000220C                                         ; const type_info::`vftable'
.data$r:00002210                 db    0
.data$r:00002211                 db    0
.data$r:00002212                 db    0
.data$r:00002213                 db    0
.data$r:00002214                 db  2Eh ; .
.data$r:00002215                 db  3Fh ; ?
.data$r:00002216                 db  41h ; A
.data$r:00002217                 db  56h ; V
.data$r:00002218                 db  5Fh ; _
.data$r:00002219                 db  49h ; I
.data$r:0000221A                 db  6Fh ; o
.data$r:0000221B                 db  73h ; s
.data$r:0000221C                 db  74h ; t
.data$r:0000221D                 db  72h ; r
.data$r:0000221E                 db  65h ; e
.data$r:0000221F                 db  61h ; a
.data$r:00002220                 db  6Dh ; m
.data$r:00002221                 db  5Fh ; _
.data$r:00002222                 db  65h ; e
.data$r:00002223                 db  72h ; r
.data$r:00002224                 db  72h ; r
.data$r:00002225                 db  6Fh ; o
.data$r:00002226                 db  72h ; r
.data$r:00002227                 db  5Fh ; _
.data$r:00002228                 db  63h ; c
.data$r:00002229                 db  61h ; a
.data$r:0000222A                 db  74h ; t
.data$r:0000222B                 db  65h ; e
.data$r:0000222C                 db  67h ; g
.data$r:0000222D                 db  6Fh ; o
.data$r:0000222E                 db  72h ; r
.data$r:0000222F                 db  79h ; y
.data$r:00002230                 db  40h ; @
.data$r:00002231                 db  73h ; s
.data$r:00002232                 db  74h ; t
.data$r:00002233                 db  64h ; d
.data$r:00002234                 db  40h ; @
.data$r:00002235                 db  40h ; @
.data$r:00002236                 db    0
.data$r:00002237                 align 4
.data$r:00002237 _data$r         ends
.data$r:00002237
.rdata$r:00002238 ; ===========================================================================
.rdata$r:00002238
.rdata$r:00002238 ; Segment type: Pure data
.rdata$r:00002238 ; Segment permissions: Read
.rdata$r:00002238 _rdata$r        segment dword public 'DATA' use32
.rdata$r:00002238                 assume cs:_rdata$r
.rdata$r:00002238                 ;org 2238h
.rdata$r:00002238 ; COMDAT (pick any)
.rdata$r:00002238                 public ??_R3_Iostream_error_category@std@@8
.rdata$r:00002238 ; std::_Iostream_error_category::`RTTI Class Hierarchy Descriptor'
.rdata$r:00002238 ??_R3_Iostream_error_category@std@@8 db    0
.rdata$r:00002238                                         ; DATA XREF: .rdata$r:00002208o
.rdata$r:00002238                                         ; .rdata$r:00002270o
.rdata$r:00002239                 db    0
.rdata$r:0000223A                 db    0
.rdata$r:0000223B                 db    0
.rdata$r:0000223C                 db    0
.rdata$r:0000223D                 db    0
.rdata$r:0000223E                 db    0
.rdata$r:0000223F                 db    0
.rdata$r:00002240                 db    3
.rdata$r:00002241                 db    0
.rdata$r:00002242                 db    0
.rdata$r:00002243                 db    0
.rdata$r:00002244                 dd offset ??_R2_Iostream_error_category@std@@8 ; std::_Iostream_error_category::`RTTI Base Class Array'
.rdata$r:00002244 _rdata$r        ends
.rdata$r:00002244
.rdata$r:00002248 ; ===========================================================================
.rdata$r:00002248
.rdata$r:00002248 ; Segment type: Pure data
.rdata$r:00002248 ; Segment permissions: Read
.rdata$r:00002248 _rdata$r        segment dword public 'DATA' use32
.rdata$r:00002248                 assume cs:_rdata$r
.rdata$r:00002248                 ;org 2248h
.rdata$r:00002248 ; COMDAT (pick any)
.rdata$r:00002248                 public ??_R2_Iostream_error_category@std@@8
.rdata$r:00002248 ; std::_Iostream_error_category::`RTTI Base Class Array'
.rdata$r:00002248 ??_R2_Iostream_error_category@std@@8 dd offset ??_R1A@?0A@EA@_Iostream_error_category@std@@8
.rdata$r:00002248                                         ; DATA XREF: .rdata$r:00002244o
.rdata$r:00002248                                         ; std::_Iostream_error_category::`RTTI Base Class Descriptor at (0,-1,0,64)'
.rdata$r:0000224C                 dd offset ??_R1A@?0A@EA@_Generic_error_category@std@@8 ; std::_Generic_error_category::`RTTI Base Class Descriptor at (0,-1,0,64)'
.rdata$r:00002250                 dd offset ??_R1A@?0A@EA@error_category@std@@8 ; std::error_category::`RTTI Base Class Descriptor at (0,-1,0,64)'
.rdata$r:00002254                 db    0
.rdata$r:00002255                 align 4
.rdata$r:00002255 _rdata$r        ends
.rdata$r:00002255
.rdata$r:00002258 ; ===========================================================================
.rdata$r:00002258
.rdata$r:00002258 ; Segment type: Pure data
.rdata$r:00002258 ; Segment permissions: Read
.rdata$r:00002258 _rdata$r        segment dword public 'DATA' use32
.rdata$r:00002258                 assume cs:_rdata$r
.rdata$r:00002258                 ;org 2258h
.rdata$r:00002258 ; COMDAT (pick any)
.rdata$r:00002258                 public ??_R1A@?0A@EA@_Iostream_error_category@std@@8
.rdata$r:00002258 ; std::_Iostream_error_category::`RTTI Base Class Descriptor at (0, -1, 0, 64)'
.rdata$r:00002258 ??_R1A@?0A@EA@_Iostream_error_category@std@@8 dd offset ??_R0?AV_Iostream_error_category@std@@@8
.rdata$r:00002258                                         ; DATA XREF: .rdata$r:std::_Iostream_error_category::`RTTI Base Class Array'o
.rdata$r:00002258                                         ; std::_Iostream_error_category `RTTI Type Descriptor'
.rdata$r:0000225C                 db    2
.rdata$r:0000225D                 db    0
.rdata$r:0000225E                 db    0
.rdata$r:0000225F                 db    0
.rdata$r:00002260                 db    0
.rdata$r:00002261                 db    0
.rdata$r:00002262                 db    0
.rdata$r:00002263                 db    0
.rdata$r:00002264                 db 0FFh
.rdata$r:00002265                 db 0FFh
.rdata$r:00002266                 db 0FFh
.rdata$r:00002267                 db 0FFh
.rdata$r:00002268                 db    0
.rdata$r:00002269                 db    0
.rdata$r:0000226A                 db    0
.rdata$r:0000226B                 db    0
.rdata$r:0000226C                 db  40h ; @
.rdata$r:0000226D                 db    0
.rdata$r:0000226E                 db    0
.rdata$r:0000226F                 db    0
.rdata$r:00002270                 dd offset ??_R3_Iostream_error_category@std@@8 ; std::_Iostream_error_category::`RTTI Class Hierarchy Descriptor'
.rdata$r:00002270 _rdata$r        ends
.rdata$r:00002270
.rdata$r:00002274 ; ===========================================================================
.rdata$r:00002274
.rdata$r:00002274 ; Segment type: Pure data
.rdata$r:00002274 ; Segment permissions: Read
.rdata$r:00002274 _rdata$r        segment dword public 'DATA' use32
.rdata$r:00002274                 assume cs:_rdata$r
.rdata$r:00002274                 ;org 2274h
.rdata$r:00002274 ; COMDAT (pick any)
.rdata$r:00002274                 public ??_R4_System_error_category@std@@6B@
.rdata$r:00002274 ; const std::_System_error_category::`RTTI Complete Object Locator'
.rdata$r:00002274 ??_R4_System_error_category@std@@6B@ db    0 ; DATA XREF: .rdata:00001FF0o
.rdata$r:00002275                 db    0
.rdata$r:00002276                 db    0
.rdata$r:00002277                 db    0
.rdata$r:00002278                 db    0
.rdata$r:00002279                 db    0
.rdata$r:0000227A                 db    0
.rdata$r:0000227B                 db    0
.rdata$r:0000227C                 db    0
.rdata$r:0000227D                 db    0
.rdata$r:0000227E                 db    0
.rdata$r:0000227F                 db    0
.rdata$r:00002280                 dd offset ??_R0?AV_System_error_category@std@@@8 ; std::_System_error_category `RTTI Type Descriptor'
.rdata$r:00002284                 dd offset ??_R3_System_error_category@std@@8 ; std::_System_error_category::`RTTI Class Hierarchy Descriptor'
.rdata$r:00002284 _rdata$r        ends
.rdata$r:00002284
.data$r:00002288 ; ===========================================================================
.data$r:00002288
.data$r:00002288 ; Segment type: Pure data
.data$r:00002288 ; Segment permissions: Read/Write
.data$r:00002288 _data$r         segment dword public 'DATA' use32
.data$r:00002288                 assume cs:_data$r
.data$r:00002288                 ;org 2288h
.data$r:00002288 ; COMDAT (pick any)
.data$r:00002288                 public ??_R0?AV_System_error_category@std@@@8
.data$r:00002288 ; class std::_System_error_category `RTTI Type Descriptor'
.data$r:00002288 ??_R0?AV_System_error_category@std@@@8 dd offset ??_7type_info@@6B@
.data$r:00002288                                         ; DATA XREF: .rdata$r:00002280o
.data$r:00002288                                         ; .rdata$r:std::_System_error_category::`RTTI Base Class Descriptor at (0,-1,0,64)'o
.data$r:00002288                                         ; const type_info::`vftable'
.data$r:0000228C                 align 10h
.data$r:00002290 a_?av_system_er db '.?AV_System_error_category@std@@',0
.data$r:000022B1                 align 4
.data$r:000022B1 _data$r         ends
.data$r:000022B1
.rdata$r:000022B4 ; ===========================================================================
.rdata$r:000022B4
.rdata$r:000022B4 ; Segment type: Pure data
.rdata$r:000022B4 ; Segment permissions: Read
.rdata$r:000022B4 _rdata$r        segment dword public 'DATA' use32
.rdata$r:000022B4                 assume cs:_rdata$r
.rdata$r:000022B4                 ;org 22B4h
.rdata$r:000022B4 ; COMDAT (pick any)
.rdata$r:000022B4                 public ??_R3_System_error_category@std@@8
.rdata$r:000022B4 ; std::_System_error_category::`RTTI Class Hierarchy Descriptor'
.rdata$r:000022B4 ??_R3_System_error_category@std@@8 db    0 ; DATA XREF: .rdata$r:00002284o
.rdata$r:000022B4                                         ; .rdata$r:000022ECo
.rdata$r:000022B5                 db    0
.rdata$r:000022B6                 db    0
.rdata$r:000022B7                 db    0
.rdata$r:000022B8                 db    0
.rdata$r:000022B9                 db    0
.rdata$r:000022BA                 db    0
.rdata$r:000022BB                 db    0
.rdata$r:000022BC                 db    3
.rdata$r:000022BD                 db    0
.rdata$r:000022BE                 db    0
.rdata$r:000022BF                 db    0
.rdata$r:000022C0                 dd offset ??_R2_System_error_category@std@@8 ; std::_System_error_category::`RTTI Base Class Array'
.rdata$r:000022C0 _rdata$r        ends
.rdata$r:000022C0
.rdata$r:000022C4 ; ===========================================================================
.rdata$r:000022C4
.rdata$r:000022C4 ; Segment type: Pure data
.rdata$r:000022C4 ; Segment permissions: Read
.rdata$r:000022C4 _rdata$r        segment dword public 'DATA' use32
.rdata$r:000022C4                 assume cs:_rdata$r
.rdata$r:000022C4                 ;org 22C4h
.rdata$r:000022C4 ; COMDAT (pick any)
.rdata$r:000022C4                 public ??_R2_System_error_category@std@@8
.rdata$r:000022C4 ; std::_System_error_category::`RTTI Base Class Array'
.rdata$r:000022C4 ??_R2_System_error_category@std@@8 dd offset ??_R1A@?0A@EA@_System_error_category@std@@8
.rdata$r:000022C4                                         ; DATA XREF: .rdata$r:000022C0o
.rdata$r:000022C4                                         ; std::_System_error_category::`RTTI Base Class Descriptor at (0,-1,0,64)'
.rdata$r:000022C8                 dd offset ??_R1A@?0A@EA@_Generic_error_category@std@@8 ; std::_Generic_error_category::`RTTI Base Class Descriptor at (0,-1,0,64)'
.rdata$r:000022CC                 dd offset ??_R1A@?0A@EA@error_category@std@@8 ; std::error_category::`RTTI Base Class Descriptor at (0,-1,0,64)'
.rdata$r:000022D0                 db    0
.rdata$r:000022D1                 align 4
.rdata$r:000022D1 _rdata$r        ends
.rdata$r:000022D1
.rdata$r:000022D4 ; ===========================================================================
.rdata$r:000022D4
.rdata$r:000022D4 ; Segment type: Pure data
.rdata$r:000022D4 ; Segment permissions: Read
.rdata$r:000022D4 _rdata$r        segment dword public 'DATA' use32
.rdata$r:000022D4                 assume cs:_rdata$r
.rdata$r:000022D4                 ;org 22D4h
.rdata$r:000022D4 ; COMDAT (pick any)
.rdata$r:000022D4                 public ??_R1A@?0A@EA@_System_error_category@std@@8
.rdata$r:000022D4 ; std::_System_error_category::`RTTI Base Class Descriptor at (0, -1, 0, 64)'
.rdata$r:000022D4 ??_R1A@?0A@EA@_System_error_category@std@@8 dd offset ??_R0?AV_System_error_category@std@@@8
.rdata$r:000022D4                                         ; DATA XREF: .rdata$r:std::_System_error_category::`RTTI Base Class Array'o
.rdata$r:000022D4                                         ; std::_System_error_category `RTTI Type Descriptor'
.rdata$r:000022D8                 db    2
.rdata$r:000022D9                 db    0
.rdata$r:000022DA                 db    0
.rdata$r:000022DB                 db    0
.rdata$r:000022DC                 db    0
.rdata$r:000022DD                 db    0
.rdata$r:000022DE                 db    0
.rdata$r:000022DF                 db    0
.rdata$r:000022E0                 db 0FFh
.rdata$r:000022E1                 db 0FFh
.rdata$r:000022E2                 db 0FFh
.rdata$r:000022E3                 db 0FFh
.rdata$r:000022E4                 db    0
.rdata$r:000022E5                 db    0
.rdata$r:000022E6                 db    0
.rdata$r:000022E7                 db    0
.rdata$r:000022E8                 db  40h ; @
.rdata$r:000022E9                 db    0
.rdata$r:000022EA                 db    0
.rdata$r:000022EB                 db    0
.rdata$r:000022EC                 dd offset ??_R3_System_error_category@std@@8 ; std::_System_error_category::`RTTI Class Hierarchy Descriptor'
.rdata$r:000022EC _rdata$r        ends
.rdata$r:000022EC
.CRT$XCU:000022F0 ; ===========================================================================
.CRT$XCU:000022F0
.CRT$XCU:000022F0 ; Segment type: Pure data
.CRT$XCU:000022F0 ; Segment permissions: Read
.CRT$XCU:000022F0 _CRT$XCU        segment dword public 'DATA' use32
.CRT$XCU:000022F0                 assume cs:_CRT$XCU
.CRT$XCU:000022F0                 ;org 22F0h
.CRT$XCU:000022F0 _piecewise_construct$initializer$ dd offset ??__Epiecewise_construct@std@@YAXXZ ; std::`dynamic initializer for 'piecewise_construct''(void)
.CRT$XCU:000022F4 _allocator_arg$initializer$ dd offset ??__Eallocator_arg@std@@YAXXZ ; std::`dynamic initializer for 'allocator_arg''(void)
.CRT$XCU:000022F4 _CRT$XCU        ends
.CRT$XCU:000022F4
.CRT$XCU:000022F8 ; ===========================================================================
.CRT$XCU:000022F8
.CRT$XCU:000022F8 ; Segment type: Pure data
.CRT$XCU:000022F8 ; Segment permissions: Read
.CRT$XCU:000022F8 _CRT$XCU        segment dword public 'DATA' use32
.CRT$XCU:000022F8                 assume cs:_CRT$XCU
.CRT$XCU:000022F8                 ;org 22F8h
.CRT$XCU:000022F8 ; COMDAT (pick associative to section at 2014)
.CRT$XCU:000022F8 ; public: static void (__cdecl *std::_Error_objects<int>::_Generic_object$initializer$)(void)
.CRT$XCU:000022F8 ?_Generic_object$initializer$@?$_Error_objects@H@std@@2P6AXXZA dd offset ??__E?_Generic_object@?$_Error_objects@H@std@@2V_Generic_error_category@2@A@@YAXXZ ; `dynamic initializer for 'std::_Generic_error_category std::_Error_objects<int>::_Generic_object''(void)
.CRT$XCU:000022F8 _CRT$XCU        ends
.CRT$XCU:000022F8
.CRT$XCU:000022FC ; ===========================================================================
.CRT$XCU:000022FC
.CRT$XCU:000022FC ; Segment type: Pure data
.CRT$XCU:000022FC ; Segment permissions: Read
.CRT$XCU:000022FC _CRT$XCU        segment dword public 'DATA' use32
.CRT$XCU:000022FC                 assume cs:_CRT$XCU
.CRT$XCU:000022FC                 ;org 22FCh
.CRT$XCU:000022FC ; COMDAT (pick associative to section at 2018)
.CRT$XCU:000022FC ; public: static void (__cdecl *std::_Error_objects<int>::_Iostream_object$initializer$)(void)
.CRT$XCU:000022FC ?_Iostream_object$initializer$@?$_Error_objects@H@std@@2P6AXXZA dd offset ??__E?_Iostream_object@?$_Error_objects@H@std@@2V_Iostream_error_category@2@A@@YAXXZ ; `dynamic initializer for 'std::_Iostream_error_category std::_Error_objects<int>::_Iostream_object''(void)
.CRT$XCU:000022FC _CRT$XCU        ends
.CRT$XCU:000022FC
.CRT$XCU:00002300 ; ===========================================================================
.CRT$XCU:00002300
.CRT$XCU:00002300 ; Segment type: Pure data
.CRT$XCU:00002300 ; Segment permissions: Read
.CRT$XCU:00002300 _CRT$XCU        segment dword public 'DATA' use32
.CRT$XCU:00002300                 assume cs:_CRT$XCU
.CRT$XCU:00002300                 ;org 2300h
.CRT$XCU:00002300 ; COMDAT (pick associative to section at 201C)
.CRT$XCU:00002300 ; public: static void (__cdecl *std::_Error_objects<int>::_System_object$initializer$)(void)
.CRT$XCU:00002300 ?_System_object$initializer$@?$_Error_objects@H@std@@2P6AXXZA dd offset ??__E?_System_object@?$_Error_objects@H@std@@2V_System_error_category@2@A@@YAXXZ ; `dynamic initializer for 'std::_System_error_category std::_Error_objects<int>::_System_object''(void)
.CRT$XCU:00002300 _CRT$XCU        ends
.CRT$XCU:00002300
.CRT$XCU:00002304 ; ===========================================================================
.CRT$XCU:00002304
.CRT$XCU:00002304 ; Segment type: Pure data
.CRT$XCU:00002304 ; Segment permissions: Read
.CRT$XCU:00002304 _CRT$XCU        segment dword public 'DATA' use32
.CRT$XCU:00002304                 assume cs:_CRT$XCU
.CRT$XCU:00002304                 ;org 2304h
.CRT$XCU:00002304 ; COMDAT (pick associative to section at 2020)
.CRT$XCU:00002304 ; public: static void (__cdecl *std::num_put<char, class std::back_insert_iterator<class std::basic_string<char, struct std::char_traits<char>, class std::allocator<char>>>>::id$initializer$)(void)
.CRT$XCU:00002304 ?id$initializer$@?$num_put@DV?$back_insert_iterator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@std@@2P6AXXZA dd offset ??__E?id@?$num_put@DV?$back_insert_iterator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@std@@2V0locale@2@A@@YAXXZ ; `dynamic initializer for 'std::locale::id std::num_put<char,std::back_insert_iterator<std::basic_string<char,std::char_traits<char>,std::allocator<char>>>>::id''(void)
.CRT$XCU:00002304 _CRT$XCU        ends
.CRT$XCU:00002304
.CRT$XCU:00002308 ; ===========================================================================
.CRT$XCU:00002308
.CRT$XCU:00002308 ; Segment type: Pure data
.CRT$XCU:00002308 ; Segment permissions: Read
.CRT$XCU:00002308 _CRT$XCU        segment dword public 'DATA' use32
.CRT$XCU:00002308                 assume cs:_CRT$XCU
.CRT$XCU:00002308                 ;org 2308h
.CRT$XCU:00002308 ; COMDAT (pick associative to section at 2024)
.CRT$XCU:00002308 ; public: static void (__cdecl *std::num_put<wchar_t, class std::back_insert_iterator<class std::basic_string<wchar_t, struct std::char_traits<wchar_t>, class std::allocator<wchar_t>>>>::id$initializer$)(void)
.CRT$XCU:00002308 ?id$initializer$@?$num_put@_WV?$back_insert_iterator@V?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@@std@@@std@@2P6AXXZA dd offset ??__E?id@?$num_put@_WV?$back_insert_iterator@V?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@@std@@@std@@2V0locale@2@A@@YAXXZ ; `dynamic initializer for 'std::locale::id std::num_put<wchar_t,std::back_insert_iterator<std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>>>>::id''(void)
.CRT$XCU:00002308 _CRT$XCU        ends
.CRT$XCU:00002308
.CRT$XCU:0000230C ; ===========================================================================
.CRT$XCU:0000230C
.CRT$XCU:0000230C ; Segment type: Pure data
.CRT$XCU:0000230C ; Segment permissions: Read
.CRT$XCU:0000230C _CRT$XCU        segment dword public 'DATA' use32
.CRT$XCU:0000230C                 assume cs:_CRT$XCU
.CRT$XCU:0000230C                 ;org 230Ch
.CRT$XCU:0000230C ; COMDAT (pick associative to section at 20B8)
.CRT$XCU:0000230C ; public: static void (__cdecl *std::numpunct<char>::id$initializer$)(void)
.CRT$XCU:0000230C ?id$initializer$@?$numpunct@D@std@@2P6AXXZA dd offset ??__E?id@?$numpunct@D@std@@2V0locale@2@A@@YAXXZ ; `dynamic initializer for 'std::locale::id std::numpunct<char>::id''(void)
.CRT$XCU:0000230C _CRT$XCU        ends
.CRT$XCU:0000230C
.CRT$XCU:00002310 ; ===========================================================================
.CRT$XCU:00002310
.CRT$XCU:00002310 ; Segment type: Pure data
.CRT$XCU:00002310 ; Segment permissions: Read
.CRT$XCU:00002310 _CRT$XCU        segment dword public 'DATA' use32
.CRT$XCU:00002310                 assume cs:_CRT$XCU
.CRT$XCU:00002310                 ;org 2310h
.CRT$XCU:00002310 ; COMDAT (pick associative to section at 20BC)
.CRT$XCU:00002310 ; public: static void (__cdecl *std::numpunct<wchar_t>::id$initializer$)(void)
.CRT$XCU:00002310 ?id$initializer$@?$numpunct@_W@std@@2P6AXXZA dd offset ??__E?id@?$numpunct@_W@std@@2V0locale@2@A@@YAXXZ ; `dynamic initializer for 'std::locale::id std::numpunct<wchar_t>::id''(void)
.CRT$XCU:00002310 _CRT$XCU        ends
.CRT$XCU:00002310
UNDEF:00002320 ; ===========================================================================
UNDEF:00002320
UNDEF:00002320 ; Segment type: Externs
UNDEF:00002320 ; UNDEF
UNDEF:00002320                 extrn __purecall:near   ; DATA XREF: .rdata:00001F68o
UNDEF:00002320                                         ; .rdata:00001F6Co
UNDEF:00002324 ; void *__cdecl operator new(unsigned int)
UNDEF:00002324                 extrn ??2@YAPAXI@Z:near ; CODE XREF: std::_Allocate<char>(uint,char *)+1Dp
UNDEF:00002324                                         ; std::_Allocate<std::_Container_proxy>(uint,std::_Container_proxy *)+23p
UNDEF:00002328 ; void __cdecl operator delete(void *)
UNDEF:00002328                 extrn ??3@YAXPAX@Z:near ; CODE XREF: std::_Generic_error_category::`scalar deleting destructor'(uint)+1Bp
UNDEF:00002328                                         ; std::_Iostream_error_category::`scalar deleting destructor'(uint)+1Bp ...
UNDEF:0000232C ; int __cdecl atexit(void (__cdecl *)())
UNDEF:0000232C                 extrn _atexit:near      ; CODE XREF: `dynamic initializer for 'std::_Generic_error_category std::_Error_objects<int>::_Generic_object''(void)+12p
UNDEF:0000232C                                         ; `dynamic initializer for 'std::_Iostream_error_category std::_Error_objects<int>::_Iostream_object''(void)+12p ...
UNDEF:00002330 ; _DWORD __thiscall std::_Lockit::_Lockit(std::_Lockit *__hidden this, int)
UNDEF:00002330                 extrn ??0_Lockit@std@@QAE@H@Z:near
UNDEF:00002330                                         ; CODE XREF: std::_Container_base12::_Orphan_all(void)+35p
UNDEF:00002334 ; _DWORD __thiscall std::_Lockit::~_Lockit(std::_Lockit *__hidden this)
UNDEF:00002334                 extrn ??1_Lockit@std@@QAE@XZ:near
UNDEF:00002334                                         ; CODE XREF: std::_Container_base12::_Orphan_all(void)+86p
UNDEF:00002334                                         ; __unwindfunclet$?_Orphan_all@_Container_base12@std@@QAEXXZ$0+3j
UNDEF:00002338                 extrn __hypot:near      ; CODE XREF: _hypot+1Dp
UNDEF:0000233C ; void *__cdecl memcpy(void *Dst, const void *Src, size_t Size)
UNDEF:0000233C                 extrn _memcpy:near      ; CODE XREF: std::char_traits<char>::copy(char *,char const *,uint)+1Ep
UNDEF:00002340 ; size_t __cdecl strlen(const char *Str)
UNDEF:00002340                 extrn _strlen:near      ; CODE XREF: std::char_traits<char>::length(char const *)+1Bp
UNDEF:00002344 ; void *__cdecl memmove(void *Dst, const void *Src, size_t Size)
UNDEF:00002344                 extrn _memmove:near     ; CODE XREF: std::char_traits<char>::move(char *,char const *,uint)+1Ep
UNDEF:00002348 ; void __cdecl std::_Debug_message(const wchar_t *, const wchar_t *, unsigned int)
UNDEF:00002348                 extrn ?_Debug_message@std@@YAXPB_W0I@Z:near
UNDEF:00002348                                         ; CODE XREF: std::_Debug_pointer<char>(char const *,wchar_t const *,uint)+16p
UNDEF:0000234C ; void __cdecl std::_Xbad_alloc()
UNDEF:0000234C                 extrn ?_Xbad_alloc@std@@YAXXZ:near
UNDEF:0000234C                                         ; CODE XREF: std::_Allocate<char>(uint,char *):loc_2D2p
UNDEF:0000234C                                         ; std::_Allocate<std::_Container_proxy>(uint,std::_Container_proxy *):loc_314p
UNDEF:00002350 ; void __cdecl std::_Xlength_error(const char *)
UNDEF:00002350                 extrn ?_Xlength_error@std@@YAXPBD@Z:near
UNDEF:00002350                                         ; CODE XREF: std::basic_string<char,std::char_traits<char>,std::allocator<char>>::_Xlen(void)+Cp
UNDEF:00002354 ; void __cdecl std::_Xout_of_range(const char *)
UNDEF:00002354                 extrn ?_Xout_of_range@std@@YAXPBD@Z:near
UNDEF:00002354                                         ; CODE XREF: std::basic_string<char,std::char_traits<char>,std::allocator<char>>::_Xran(void)+Cp
UNDEF:00002358 ; public: virtual void * __thiscall std::error_category::`vector deleting destructor'(unsigned int)
UNDEF:00002358                 extrn ??_Eerror_category@std@@UAEPAXI@Z:near ; weak
UNDEF:00002358                                         ; DATA XREF: .rdata:const std::error_category::`vftable'o
UNDEF:0000235C ; const char *__cdecl std::_Syserror_map(int)
UNDEF:0000235C                 extrn ?_Syserror_map@std@@YAPBDH@Z:near
UNDEF:0000235C                                         ; CODE XREF: std::_System_error_category::default_error_condition(int)+Bp
UNDEF:0000235C                                         ; std::_Generic_error_category::message(int)+33p
UNDEF:00002360 ; const char *__cdecl std::_Winerror_map(int)
UNDEF:00002360                 extrn ?_Winerror_map@std@@YAPBDH@Z:near
UNDEF:00002360                                         ; CODE XREF: std::_System_error_category::message(int)+33p
UNDEF:00002364 ; public: virtual void * __thiscall std::_Generic_error_category::`vector deleting destructor'(unsigned int)
UNDEF:00002364                 extrn ??_E_Generic_error_category@std@@UAEPAXI@Z:near ; weak
UNDEF:00002364                                         ; DATA XREF: .rdata:const std::_Generic_error_category::`vftable'o
UNDEF:00002368 ; public: virtual void * __thiscall std::_Iostream_error_category::`vector deleting destructor'(unsigned int)
UNDEF:00002368                 extrn ??_E_Iostream_error_category@std@@UAEPAXI@Z:near ; weak
UNDEF:00002368                                         ; DATA XREF: .rdata:const std::_Iostream_error_category::`vftable'o
UNDEF:0000236C ; public: virtual void * __thiscall std::_System_error_category::`vector deleting destructor'(unsigned int)
UNDEF:0000236C                 extrn ??_E_System_error_category@std@@UAEPAXI@Z:near ; weak
UNDEF:0000236C                                         ; DATA XREF: .rdata:const std::_System_error_category::`vftable'o
UNDEF:00002370 ; __fastcall __security_check_cookie(x)
UNDEF:00002370                 extrn @__security_check_cookie@4:near
UNDEF:00002370                                         ; CODE XREF: __ehhandler$??$construct@PADAAPAD@?$allocator@D@std@@QAEXPAPADAAPAD@Z+Cp
UNDEF:00002370                                         ; __ehhandler$??$construct@U_Container_proxy@std@@U12@@?$allocator@U_Container_proxy@std@@@std@@QAEXPAU_Container_proxy@1@$$QAU21@@Z+Cp ...
UNDEF:00002374 ; __stdcall _CxxThrowException(x, x)
UNDEF:00002374                 extrn __CxxThrowException@8:near
UNDEF:00002374                                         ; CODE XREF: __catch$?_Copy@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEXII@Z$1+10p
UNDEF:00002378                 extrn ___CxxFrameHandler3:near
UNDEF:00002378                                         ; CODE XREF: __ehhandler$??$construct@PADAAPAD@?$allocator@D@std@@QAEXPAPADAAPAD@Z+16j
UNDEF:00002378                                         ; __ehhandler$??$construct@U_Container_proxy@std@@U12@@?$allocator@U_Container_proxy@std@@@std@@QAEXPAU_Container_proxy@1@$$QAU21@@Z+16j ...
UNDEF:0000237C ; const type_info::`vftable'
UNDEF:0000237C                 extrn ??_7type_info@@6B@:near
UNDEF:0000237C                                         ; DATA XREF: .data$r:std::error_category `RTTI Type Descriptor'o
UNDEF:0000237C                                         ; .data$r:std::_Generic_error_category `RTTI Type Descriptor'o ...
UNDEF:00002380                 extrn ___security_cookie:near
UNDEF:00002380                                         ; DATA XREF: std::allocator<char>::construct<char *,char * &>(char * *,char * &)+14r
UNDEF:00002380                                         ; std::allocator<std::_Container_proxy>::construct<std::_Container_proxy,std::_Container_proxy>(std::_Container_proxy *,std::_Container_proxy &&)+14r ...
UNDEF:00002384                 extrn __fltused:near
UNDEF:00002384
UNDEF:00002384
UNDEF:00002384                 end