.data:00000000 ;
.data:00000000 ; +-------------------------------------------------------------------------+
.data:00000000 ; |   This file has been generated by The Interactive Disassembler (IDA)    |
.data:00000000 ; |           Copyright (c) 2015 Hex-Rays, <support@hex-rays.com>           |
.data:00000000 ; |                      License info: 48-3677-7074-51                      |
.data:00000000 ; |             Michalis Polychronakis, Stony Brook University              |
.data:00000000 ; +-------------------------------------------------------------------------+
.data:00000000 ;
.data:00000000 ; Input MD5   : C57D3C4D0741C139D4DE4FEC502D2DD0
.data:00000000 ; Input CRC32 : 5A7E482B
.data:00000000
.data:00000000 ; File Name   : C:\workspace\notepad-plus-plus-6.7.9.2\PowerEditor\visual.net\Unicode Debug\ansiCharPanel.obj
.data:00000000 ; Format      : COFF (X386MAGIC)
.data:00000000 ; includelib "uuid.lib"
.data:00000000 ; includelib "libcpmtd"
.data:00000000 ; must resolve: ?_Generic_object@?$_Error_objects@H@std@@2V_Generic_error_category@2@A
.data:00000000 ; must resolve: ?_Iostream_object@?$_Error_objects@H@std@@2V_Iostream_error_category@2@A
.data:00000000 ; must resolve: ?_System_object@?$_Error_objects@H@std@@2V_System_error_category@2@A
.data:00000000 ; must resolve: ?id@?$num_put@DV?$back_insert_iterator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@std@@2V0locale@2@A
.data:00000000 ; must resolve: ?id@?$num_put@_WV?$back_insert_iterator@V?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@@std@@@std@@2V0locale@2@A
.data:00000000 ; must resolve: ?id@?$numpunct@D@std@@2V0locale@2@A
.data:00000000 ; must resolve: ?id@?$numpunct@_W@std@@2V0locale@2@A
.data:00000000 ; includelib "LIBCMTD"
.data:00000000 ; includelib "OLDNAMES"
.data:00000000
.data:00000000                 include uni.inc ; see unicode subdir of ida for info on unicode
.data:00000000
.data:00000000                 .686p
.data:00000000                 .mmx
.data:00000000                 .model flat
.data:00000000
.data:00000000 ; ===========================================================================
.data:00000000
.data:00000000 ; Segment type: Pure data
.data:00000000 ; Segment permissions: Read/Write
.data:00000000 ; Segment alignment 'qword' can not be represented in assembly
.data:00000000 _data           segment para public 'DATA' use32
.data:00000000                 assume cs:_data
.data:00000000 _acTop_xpm      dd offset $SG145410     ; "12 12 56 1"
.data:00000004                 dd offset $SG145411     ; " \tc #FFFFFF"
.data:00000008                 dd offset $SG145412     ; ".\tc #8AB2E9"
.data:0000000C                 dd offset $SG145413     ; "+\tc #CCDCF6"
.data:00000010                 dd offset $SG145414     ; "@\tc #80ABEA"
.data:00000014                 dd offset $SG145415     ; "#\tc #7DA9E8"
.data:00000018                 dd offset $SG145416     ; "$\tc #C7DAF3"
.data:0000001C                 dd offset $SG145417     ; "%\tc #79A7E6"
.data:00000020                 dd offset $SG145418     ; "&\tc #ADC8EF"
.data:00000024                 dd offset $SG145419     ; "*\tc #87B0E8"
.data:00000028                 dd offset $SG145420     ; "=\tc #BBD2F0"
.data:0000002C                 dd offset $SG145421     ; "-\tc #6EA0E2"
.data:00000030                 dd offset $SG145422     ; ";\tc #A8C7EE"
.data:00000034                 dd offset $SG145423     ; ">\tc #A3C2ED"
.data:00000038                 dd offset $SG145424     ; ",\tc #75A4E3"
.data:0000003C                 dd offset $SG145425     ; "'\tc #A7C4EB"
.data:00000040                 dd offset $SG145426     ; ")\tc #6297E1"
.data:00000044                 dd offset $SG145427     ; "!\tc #A1C1EC"
.data:00000048                 dd offset $SG145428     ; "~\tc #92B7E8"
.data:0000004C                 dd offset $SG145429     ; "{\tc #99BBE9"
.data:00000050                 dd offset $SG145430     ; "]\tc #6197DD"
.data:00000054                 dd offset $SG145431     ; "^\tc #96B9E6"
.data:00000058                 dd offset $SG145432     ; "/\tc #538EDB"
.data:0000005C                 dd offset $SG145433     ; "(\tc #99BBEA"
.data:00000060                 dd offset $SG145434     ; "_\tc #80AAE3"
.data:00000064                 dd offset $SG145435     ; ":\tc #81ABE3"
.data:00000068                 dd offset $SG145436     ; "<\tc #8AB1E4"
.data:0000006C                 dd offset $SG145437     ; "[\tc #4B88D6"
.data:00000070                 dd offset $SG145438     ; "}\tc #4882D1"
.data:00000074                 dd offset $SG145439     ; "|\tc #4384D6"
.data:00000078                 dd offset $SG145440     ; "1\tc #90B5E7"
.data:0000007C                 dd offset $SG145441     ; "2\tc #74A3E0"
.data:00000080                 dd offset $SG145442     ; "3\tc #77A4E0"
.data:00000084                 dd offset $SG145443     ; "4\tc #81ABE2"
.data:00000088                 dd offset $SG145444     ; "5\tc #437FD3"
.data:0000008C                 dd offset $SG145445     ; "6\tc #7FA2DF"
.data:00000090                 dd offset $SG145446     ; "7\tc #3577D2"
.data:00000094                 dd offset $SG145447     ; "8\tc #87AFE4"
.data:00000098                 dd offset $SG145448     ; "9\tc #72A1DF"
.data:0000009C                 dd offset $SG145449     ; "0\tc #7CA9E1"
.data:000000A0                 dd offset $SG145450     ; "a\tc #3F7AD0"
.data:000000A4                 dd offset $SG145451     ; "b\tc #85A4DE"
.data:000000A8                 dd offset $SG145452     ; "c\tc #FBFCFE"
.data:000000AC                 dd offset $SG145453     ; "d\tc #236ECD"
.data:000000B0                 dd offset $SG145454     ; "e\tc #7EA8E1"
.data:000000B4                 dd offset $SG145455     ; "f\tc #79A6E0"
.data:000000B8                 dd offset $SG145456     ; "g\tc #3D77D0"
.data:000000BC                 dd offset $SG145457     ; "h\tc #87A4DC"
.data:000000C0                 dd offset $SG145458     ; "i\tc #1A62C9"
.data:000000C4                 dd offset $SG145459     ; "j\tc #75A3DF"
.data:000000C8                 dd offset $SG145460     ; "k\tc #3C74CF"
.data:000000CC                 dd offset $SG145461     ; "l\tc #8DA6DE"
.data:000000D0                 dd offset $SG145462     ; "m\tc #1859C4"
.data:000000D4                 dd offset $SG145463     ; "n\tc #3B71CC"
.data:000000D8                 dd offset $SG145464     ; "o\tc #8EA5DD"
.data:000000DC                 dd offset $SG145465     ; "p\tc #164EC0"
.data:000000E0                 dd offset $SG145466     ; "q\tc #92A7DD"
.data:000000E4                 dd offset $SG145467     ; "    .+      "
.data:000000E8                 dd offset $SG145468     ; "    @#$     "
.data:000000EC                 dd offset $SG145469     ; "    %&*=    "
.data:000000F0                 dd offset $SG145470     ; "    -;>,'   "
.data:000000F4                 dd offset $SG145471     ; "    )!~{]^  "
.data:000000F8                 dd offset $SG145472     ; "    /(_:<[} "
.data:000000FC                 dd offset $SG145473     ; "    |123456 "
.data:00000100                 dd offset $SG145474     ; "    7890abc "
.data:00000104                 dd offset $SG145475     ; "    defgh   "
.data:00000108                 dd offset $SG145476     ; "    ijkl    "
.data:0000010C                 dd offset $SG145477     ; "    mno     "
.data:00000110                 dd offset $SG145478     ; "    pq      "
.data:00000114                 align 8
.data:00000118 _acBottom_xpm   dd offset $SG145480     ; "12 12 54 1"
.data:0000011C                 dd offset $SG145481     ; " \tc #FFFFFF"
.data:00000120                 dd offset $SG145482     ; ".\tc #C4D7F3"
.data:00000124                 dd offset $SG145483     ; "+\tc #72A1E3"
.data:00000128                 dd offset $SG145484     ; "@\tc #C1D6F2"
.data:0000012C                 dd offset $SG145485     ; "#\tc #6397E1"
.data:00000130                 dd offset $SG145486     ; "$\tc #5990DD"
.data:00000134                 dd offset $SG145487     ; "%\tc #BBD2F0"
.data:00000138                 dd offset $SG145488     ; "&\tc #7AA6E5"
.data:0000013C                 dd offset $SG145489     ; "*\tc #9ABDEA"
.data:00000140                 dd offset $SG145490     ; "=\tc #4A87D9"
.data:00000144                 dd offset $SG145491     ; "-\tc #B1CAEE"
.data:00000148                 dd offset $SG145492     ; ";\tc #75A4E3"
.data:0000014C                 dd offset $SG145493     ; ">\tc #99BBE9"
.data:00000150                 dd offset $SG145494     ; ",\tc #95B9E8"
.data:00000154                 dd offset $SG145495     ; "'\tc #3A7CD4"
.data:00000158                 dd offset $SG145496     ; ")\tc #A9C6EC"
.data:0000015C                 dd offset $SG145497     ; "!\tc #71A0E0"
.data:00000160                 dd offset $SG145498     ; "~\tc #86AFE5"
.data:00000164                 dd offset $SG145499     ; "{\tc #8DB2E6"
.data:00000168                 dd offset $SG145500     ; "]\tc #2A72CF"
.data:0000016C                 dd offset $SG145501     ; "^\tc #73A0E0"
.data:00000170                 dd offset $SG145502     ; "/\tc #6B9DE0"
.data:00000174                 dd offset $SG145503     ; "(\tc #95B8E8"
.data:00000178                 dd offset $SG145504     ; "_\tc #81ABE3"
.data:0000017C                 dd offset $SG145505     ; ":\tc #72A1DF"
.data:00000180                 dd offset $SG145506     ; "<\tc #83ADE3"
.data:00000184                 dd offset $SG145507     ; "[\tc #1B65C9"
.data:00000188                 dd offset $SG145508     ; "}\tc #5F95DC"
.data:0000018C                 dd offset $SG145509     ; "|\tc #8BB3E5"
.data:00000190                 dd offset $SG145510     ; "1\tc #77A4E0"
.data:00000194                 dd offset $SG145511     ; "2\tc #679ADC"
.data:00000198                 dd offset $SG145512     ; "3\tc #7AA6E1"
.data:0000019C                 dd offset $SG145513     ; "4\tc #195CC6"
.data:000001A0                 dd offset $SG145514     ; "5\tc #FCFDFE"
.data:000001A4                 dd offset $SG145515     ; "6\tc #8DB2E4"
.data:000001A8                 dd offset $SG145516     ; "7\tc #4885D6"
.data:000001AC                 dd offset $SG145517     ; "8\tc #7CA9E1"
.data:000001B0                 dd offset $SG145518     ; "9\tc #6698DB"
.data:000001B4                 dd offset $SG145519     ; "0\tc #71A1DE"
.data:000001B8                 dd offset $SG145520     ; "a\tc #1752C0"
.data:000001BC                 dd offset $SG145521     ; "b\tc #88ABE0"
.data:000001C0                 dd offset $SG145522     ; "c\tc #3D77D0"
.data:000001C4                 dd offset $SG145523     ; "d\tc #6E9FDD"
.data:000001C8                 dd offset $SG145524     ; "e\tc #699BDC"
.data:000001CC                 dd offset $SG145525     ; "f\tc #1547BD"
.data:000001D0                 dd offset $SG145526     ; "g\tc #8DA6DE"
.data:000001D4                 dd offset $SG145527     ; "h\tc #376BC9"
.data:000001D8                 dd offset $SG145528     ; "i\tc #6295DA"
.data:000001DC                 dd offset $SG145529     ; "j\tc #1440B9"
.data:000001E0                 dd offset $SG145530     ; "k\tc #8DA0DB"
.data:000001E4                 dd offset $SG145531     ; "l\tc #315FC4"
.data:000001E8                 dd offset $SG145532     ; "m\tc #1339B7"
.data:000001EC                 dd offset $SG145533     ; "n\tc #909FDA"
.data:000001F0                 dd offset $SG145534     ; "o\tc #1233B4"
.data:000001F4                 dd offset $SG145535     ; "         .+ "
.data:000001F8                 dd offset $SG145536     ; "        @#$ "
.data:000001FC                 dd offset $SG145537     ; "       %&*= L"
.data:00000200                 dd offset $SG145538     ; "      -;>,' "
.data:00000204                 dd offset $SG145539     ; "     )!>~{] "
.data:00000208                 dd offset $SG145540     ; "    ^/(_:<[ "
.data:0000020C                 dd offset $SG145541     ; "    (}|1234 "
.data:00000210                 dd offset $SG145542     ; "    567890a "
.data:00000214                 dd offset $SG145543     ; "      bcdef "
.data:00000218                 dd offset $SG145544     ; "       ghij "
.data:0000021C                 dd offset $SG145545     ; "        klm "
.data:00000220                 dd offset $SG145546     ; "         no "
.data:00000224                 align 8
.data:00000228 _bookmark_xpm   dd offset $SG145548     ; "13 14 54 1"
.data:0000022C                 dd offset $SG145549     ; " \tc None"
.data:00000230                 dd offset $SG145550     ; ".\tc #545254"
.data:00000234                 dd offset $SG145551     ; "+\tc #3C3E3C"
.data:00000238                 dd offset $SG145552     ; "@\tc #646464"
.data:0000023C                 dd offset $SG145553     ; "#\tc #A4A4A4"
.data:00000240                 dd offset $SG145554     ; "$\tc #B7B8B7"
.data:00000244                 dd offset $SG145555     ; "%\tc #747284"
.data:00000248                 dd offset $SG145556     ; "&\tc #B4B2C4"
.data:0000024C                 dd offset $SG145557     ; "*\tc #DCD7E4"
.data:00000250                 dd offset $SG145558     ; "=\tc #1C1A1C"
.data:00000254                 dd offset $SG145559     ; "-\tc #403E58"
.data:00000258                 dd offset $SG145560     ; ";\tc #5C5A8C"
.data:0000025C                 dd offset $SG145561     ; ">\tc #7C7EAC"
.data:00000260                 dd offset $SG145562     ; ",\tc #7C8EBC"
.data:00000264                 dd offset $SG145563     ; "'\tc #242644"
.data:00000268                 dd offset $SG145564     ; ")\tc #282668"
.data:0000026C                 dd offset $SG145565     ; "!\tc #24367C"
.data:00000270                 dd offset $SG145566     ; "~\tc #244A84"
.data:00000274                 dd offset $SG145567     ; "{\tc #2C5098"
.data:00000278                 dd offset $SG145568     ; "]\tc #14162C"
.data:0000027C                 dd offset $SG145569     ; "^\tc #142E7C"
.data:00000280                 dd offset $SG145570     ; "/\tc #143789"
.data:00000284                 dd offset $SG145571     ; "(\tc #204990"
.data:00000288                 dd offset $SG145572     ; "_\tc #174091"
.data:0000028C                 dd offset $SG145573     ; ":\tc #0C0630"
.data:00000290                 dd offset $SG145574     ; "<\tc #24327C"
.data:00000294                 dd offset $SG145575     ; "[\tc #2450A0"
.data:00000298                 dd offset $SG145576     ; "}\tc #345DB4"
.data:0000029C                 dd offset $SG145577     ; "|\tc #3C68B8"
.data:000002A0                 dd offset $SG145578     ; "1\tc #141244"
.data:000002A4                 dd offset $SG145579     ; "2\tc #24428C"
.data:000002A8                 dd offset $SG145580     ; "3\tc #3462B9"
.data:000002AC                 dd offset $SG145581     ; "4\tc #4470C4"
.data:000002B0                 dd offset $SG145582     ; "5\tc #4C7FD6"
.data:000002B4                 dd offset $SG145583     ; "6\tc #4472CC"
.data:000002B8                 dd offset $SG145584     ; "7\tc #24224C"
.data:000002BC                 dd offset $SG145585     ; "8\tc #5C8DEC"
.data:000002C0                 dd offset $SG145586     ; "9\tc #5C94F6"
.data:000002C4                 dd offset $SG145587     ; "0\tc #5482DF"
.data:000002C8                 dd offset $SG145588     ; "a\tc #619DF7"
.data:000002CC                 dd offset $SG145589     ; "b\tc #6CA6FC"
.data:000002D0                 dd offset $SG145590     ; "c\tc #64A2FC"
.data:000002D4                 dd offset $SG145591     ; "d\tc #1C2E5C"
.data:000002D8                 dd offset $SG145592     ; "e\tc #6CA2FC"
.data:000002DC                 dd offset $SG145593     ; "f\tc #74B2FC"
.data:000002E0                 dd offset $SG145594     ; "g\tc #7CB8FC"
.data:000002E4                 dd offset $SG145595     ; "h\tc #1C3264"
.data:000002E8                 dd offset $SG145596     ; "i\tc #346AD4"
.data:000002EC                 dd offset $SG145597     ; "j\tc #7CBEFC"
.data:000002F0                 dd offset $SG145598     ; "k\tc #3C72DC"
.data:000002F4                 dd offset $SG145599     ; "l\tc #243250"
.data:000002F8                 dd offset $SG145600     ; "m\tc #346AB4"
.data:000002FC                 dd offset $SG145601     ; "n\tc #3C82DC"
.data:00000300                 dd offset $SG145602     ; "o\tc #6C6A6C"
.data:00000304                 dd offset $SG145603     ; "     .+.     "
.data:00000308                 dd offset $SG145604     ; "   @##$##@   "
.data:0000030C                 dd offset $SG145605     ; "  @%&***&%@  "
.data:00000310                 dd offset $SG145606     ; " =-;>,,,>;-= "
.data:00000314                 dd offset $SG145607     ; " ')!~{{{~!)' "
.data:00000318                 dd offset $SG145608     ; "])^/({{{(_^)]"
.data:0000031C                 dd offset $SG145609     ; ":<_[}|||}[_<:"
.data:00000320                 dd offset $SG145610     ; "12[3455563[21"
.data:00000324                 dd offset $SG145611     ; "7_365899063_7"
.data:00000328                 dd offset $SG145612     ; " /|09abc904/ "
.data:0000032C                 dd offset $SG145613     ; " d}8efgfb83d "
.data:00000330                 dd offset $SG145614     ; "  hiafjgakh  "
.data:00000334                 dd offset $SG145615     ; "   l~mnm~l   "
.data:00000338                 dd offset $SG145616     ; "     o@o     "
.data:00000338 _data           ends
.data:00000338
.rdata:0000033C ; ===========================================================================
.rdata:0000033C
.rdata:0000033C ; Segment type: Pure data
.rdata:0000033C ; Segment permissions: Read
.rdata:0000033C _rdata          segment dword public 'DATA' use32
.rdata:0000033C                 assume cs:_rdata
.rdata:0000033C                 ;org 33Ch
.rdata:0000033C $SG145410       db '12 12 56 1',0       ; DATA XREF: .data:_acTop_xpmo
.rdata:00000347 $SG153182       db    0                 ; DATA XREF: AnsiCharPanel::insertChar(uchar):loc_EE6o
.rdata:00000348 $SG145411       db ' ',9,'c #FFFFFF',0  ; DATA XREF: .data:00000004o
.rdata:00000354 $SG145412       db '.',9,'c #8AB2E9',0  ; DATA XREF: .data:00000008o
.rdata:00000360 $SG145413       db '+',9,'c #CCDCF6',0  ; DATA XREF: .data:0000000Co
.rdata:0000036C $SG145414       db '@',9,'c #80ABEA',0  ; DATA XREF: .data:00000010o
.rdata:00000378 $SG145415       db '#',9,'c #7DA9E8',0  ; DATA XREF: .data:00000014o
.rdata:00000384 $SG145416       db '$',9,'c #C7DAF3',0  ; DATA XREF: .data:00000018o
.rdata:00000390 $SG145417       db '%',9,'c #79A7E6',0  ; DATA XREF: .data:0000001Co
.rdata:0000039C $SG145418       db '&',9,'c #ADC8EF',0  ; DATA XREF: .data:00000020o
.rdata:000003A8 $SG145419       db '*',9,'c #87B0E8',0  ; DATA XREF: .data:00000024o
.rdata:000003B4 $SG145420       db '=',9,'c #BBD2F0',0  ; DATA XREF: .data:00000028o
.rdata:000003C0 $SG145421       db '-',9,'c #6EA0E2',0  ; DATA XREF: .data:0000002Co
.rdata:000003CC $SG145422       db ';',9,'c #A8C7EE',0  ; DATA XREF: .data:00000030o
.rdata:000003D8 $SG145423       db '>',9,'c #A3C2ED',0  ; DATA XREF: .data:00000034o
.rdata:000003E4 $SG145424       db ',',9,'c #75A4E3',0  ; DATA XREF: .data:00000038o
.rdata:000003F0 $SG145425       db 27h,9,'c #A7C4EB',0  ; DATA XREF: .data:0000003Co
.rdata:000003FC $SG145426       db ')',9,'c #6297E1',0  ; DATA XREF: .data:00000040o
.rdata:00000408 $SG145427       db '!',9,'c #A1C1EC',0  ; DATA XREF: .data:00000044o
.rdata:00000414 $SG145428       db '~',9,'c #92B7E8',0  ; DATA XREF: .data:00000048o
.rdata:00000420 $SG145429       db '{',9,'c #99BBE9',0  ; DATA XREF: .data:0000004Co
.rdata:0000042C $SG145430       db ']',9,'c #6197DD',0  ; DATA XREF: .data:00000050o
.rdata:00000438 $SG145431       db '^',9,'c #96B9E6',0  ; DATA XREF: .data:00000054o
.rdata:00000444 $SG145432       db '/',9,'c #538EDB',0  ; DATA XREF: .data:00000058o
.rdata:00000450 $SG145433       db '(',9,'c #99BBEA',0  ; DATA XREF: .data:0000005Co
.rdata:0000045C $SG145434       db '_',9,'c #80AAE3',0  ; DATA XREF: .data:00000060o
.rdata:00000468 $SG145435       db ':',9,'c #81ABE3',0  ; DATA XREF: .data:00000064o
.rdata:00000474 $SG145436       db '<',9,'c #8AB1E4',0  ; DATA XREF: .data:00000068o
.rdata:00000480 $SG145437       db '[',9,'c #4B88D6',0  ; DATA XREF: .data:0000006Co
.rdata:0000048C $SG145438       db '}',9,'c #4882D1',0  ; DATA XREF: .data:00000070o
.rdata:00000498 $SG145439       db '|',9,'c #4384D6',0  ; DATA XREF: .data:00000074o
.rdata:000004A4 $SG145440       db '1',9,'c #90B5E7',0  ; DATA XREF: .data:00000078o
.rdata:000004B0 $SG145441       db '2',9,'c #74A3E0',0  ; DATA XREF: .data:0000007Co
.rdata:000004BC $SG145442       db '3',9,'c #77A4E0',0  ; DATA XREF: .data:00000080o
.rdata:000004C8 $SG145443       db '4',9,'c #81ABE2',0  ; DATA XREF: .data:00000084o
.rdata:000004D4 $SG145444       db '5',9,'c #437FD3',0  ; DATA XREF: .data:00000088o
.rdata:000004E0 $SG145445       db '6',9,'c #7FA2DF',0  ; DATA XREF: .data:0000008Co
.rdata:000004EC $SG145446       db '7',9,'c #3577D2',0  ; DATA XREF: .data:00000090o
.rdata:000004F8 $SG145447       db '8',9,'c #87AFE4',0  ; DATA XREF: .data:00000094o
.rdata:00000504 $SG145448       db '9',9,'c #72A1DF',0  ; DATA XREF: .data:00000098o
.rdata:00000510 $SG145449       db '0',9,'c #7CA9E1',0  ; DATA XREF: .data:0000009Co
.rdata:0000051C $SG145450       db 'a',9,'c #3F7AD0',0  ; DATA XREF: .data:000000A0o
.rdata:00000528 $SG145451       db 'b',9,'c #85A4DE',0  ; DATA XREF: .data:000000A4o
.rdata:00000534 $SG145452       db 'c',9,'c #FBFCFE',0  ; DATA XREF: .data:000000A8o
.rdata:00000540 $SG145453       db 'd',9,'c #236ECD',0  ; DATA XREF: .data:000000ACo
.rdata:0000054C $SG145454       db 'e',9,'c #7EA8E1',0  ; DATA XREF: .data:000000B0o
.rdata:00000558 $SG145455       db 'f',9,'c #79A6E0',0  ; DATA XREF: .data:000000B4o
.rdata:00000564 $SG145456       db 'g',9,'c #3D77D0',0  ; DATA XREF: .data:000000B8o
.rdata:00000570 $SG145457       db 'h',9,'c #87A4DC',0  ; DATA XREF: .data:000000BCo
.rdata:0000057C $SG145458       db 'i',9,'c #1A62C9',0  ; DATA XREF: .data:000000C0o
.rdata:00000588 $SG145459       db 'j',9,'c #75A3DF',0  ; DATA XREF: .data:000000C4o
.rdata:00000594 $SG145460       db 'k',9,'c #3C74CF',0  ; DATA XREF: .data:000000C8o
.rdata:000005A0 $SG145461       db 'l',9,'c #8DA6DE',0  ; DATA XREF: .data:000000CCo
.rdata:000005AC $SG145462       db 'm',9,'c #1859C4',0  ; DATA XREF: .data:000000D0o
.rdata:000005B8 $SG145463       db 'n',9,'c #3B71CC',0  ; DATA XREF: .data:000000D4o
.rdata:000005C4 $SG145464       db 'o',9,'c #8EA5DD',0  ; DATA XREF: .data:000000D8o
.rdata:000005D0 $SG145465       db 'p',9,'c #164EC0',0  ; DATA XREF: .data:000000DCo
.rdata:000005DC $SG145466       db 'q',9,'c #92A7DD',0  ; DATA XREF: .data:000000E0o
.rdata:000005E8 $SG145467       db '    .+      ',0     ; DATA XREF: .data:000000E4o
.rdata:000005F5                 align 4
.rdata:000005F8 $SG145468       db '    @#$     ',0     ; DATA XREF: .data:000000E8o
.rdata:00000605                 align 4
.rdata:00000608 $SG145469       db '    %&*=    ',0     ; DATA XREF: .data:000000ECo
.rdata:00000615                 align 4
.rdata:00000618 $SG145470       db '    -;>,',27h,'   ',0 ; DATA XREF: .data:000000F0o
.rdata:00000625                 align 4
.rdata:00000628 $SG145471       db '    )!~{]^  ',0     ; DATA XREF: .data:000000F4o
.rdata:00000635                 align 4
.rdata:00000638 $SG145472       db '    /(_:<[} ',0     ; DATA XREF: .data:000000F8o
.rdata:00000645                 align 4
.rdata:00000648 $SG145473       db '    |123456 ',0     ; DATA XREF: .data:000000FCo
.rdata:00000655                 align 4
.rdata:00000658 $SG145474       db '    7890abc ',0     ; DATA XREF: .data:00000100o
.rdata:00000665                 align 4
.rdata:00000668 $SG145475       db '    defgh   ',0     ; DATA XREF: .data:00000104o
.rdata:00000675                 align 4
.rdata:00000678 $SG145476       db '    ijkl    ',0     ; DATA XREF: .data:00000108o
.rdata:00000685                 align 4
.rdata:00000688 $SG145477       db '    mno     ',0     ; DATA XREF: .data:0000010Co
.rdata:00000695                 align 4
.rdata:00000698 $SG145478       db '    pq      ',0     ; DATA XREF: .data:00000110o
.rdata:000006A5                 align 4
.rdata:000006A8 $SG145480       db '12 12 54 1',0       ; DATA XREF: .data:_acBottom_xpmo
.rdata:000006B3                 align 4
.rdata:000006B4 $SG145481       db ' ',9,'c #FFFFFF',0  ; DATA XREF: .data:0000011Co
.rdata:000006C0 $SG145482       db '.',9,'c #C4D7F3',0  ; DATA XREF: .data:00000120o
.rdata:000006CC $SG145483       db '+',9,'c #72A1E3',0  ; DATA XREF: .data:00000124o
.rdata:000006D8 $SG145484       db '@',9,'c #C1D6F2',0  ; DATA XREF: .data:00000128o
.rdata:000006E4 $SG145485       db '#',9,'c #6397E1',0  ; DATA XREF: .data:0000012Co
.rdata:000006F0 $SG145486       db '$',9,'c #5990DD',0  ; DATA XREF: .data:00000130o
.rdata:000006FC $SG145487       db '%',9,'c #BBD2F0',0  ; DATA XREF: .data:00000134o
.rdata:00000708 $SG145488       db '&',9,'c #7AA6E5',0  ; DATA XREF: .data:00000138o
.rdata:00000714 $SG145489       db '*',9,'c #9ABDEA',0  ; DATA XREF: .data:0000013Co
.rdata:00000720 $SG145490       db '=',9,'c #4A87D9',0  ; DATA XREF: .data:00000140o
.rdata:0000072C $SG145491       db '-',9,'c #B1CAEE',0  ; DATA XREF: .data:00000144o
.rdata:00000738 $SG145492       db ';',9,'c #75A4E3',0  ; DATA XREF: .data:00000148o
.rdata:00000744 $SG145493       db '>',9,'c #99BBE9',0  ; DATA XREF: .data:0000014Co
.rdata:00000750 $SG145494       db ',',9,'c #95B9E8',0  ; DATA XREF: .data:00000150o
.rdata:0000075C $SG145495       db 27h,9,'c #3A7CD4',0  ; DATA XREF: .data:00000154o
.rdata:00000768 $SG145496       db ')',9,'c #A9C6EC',0  ; DATA XREF: .data:00000158o
.rdata:00000774 $SG145497       db '!',9,'c #71A0E0',0  ; DATA XREF: .data:0000015Co
.rdata:00000780 $SG145498       db '~',9,'c #86AFE5',0  ; DATA XREF: .data:00000160o
.rdata:0000078C $SG145499       db '{',9,'c #8DB2E6',0  ; DATA XREF: .data:00000164o
.rdata:00000798 $SG145500       db ']',9,'c #2A72CF',0  ; DATA XREF: .data:00000168o
.rdata:000007A4 $SG145501       db '^',9,'c #73A0E0',0  ; DATA XREF: .data:0000016Co
.rdata:000007B0 $SG145502       db '/',9,'c #6B9DE0',0  ; DATA XREF: .data:00000170o
.rdata:000007BC $SG145503       db '(',9,'c #95B8E8',0  ; DATA XREF: .data:00000174o
.rdata:000007C8 $SG145504       db '_',9,'c #81ABE3',0  ; DATA XREF: .data:00000178o
.rdata:000007D4 $SG145505       db ':',9,'c #72A1DF',0  ; DATA XREF: .data:0000017Co
.rdata:000007E0 $SG145506       db '<',9,'c #83ADE3',0  ; DATA XREF: .data:00000180o
.rdata:000007EC $SG145507       db '[',9,'c #1B65C9',0  ; DATA XREF: .data:00000184o
.rdata:000007F8 $SG145508       db '}',9,'c #5F95DC',0  ; DATA XREF: .data:00000188o
.rdata:00000804 $SG145509       db '|',9,'c #8BB3E5',0  ; DATA XREF: .data:0000018Co
.rdata:00000810 $SG145510       db '1',9,'c #77A4E0',0  ; DATA XREF: .data:00000190o
.rdata:0000081C $SG145511       db '2',9,'c #679ADC',0  ; DATA XREF: .data:00000194o
.rdata:00000828 $SG145512       db '3',9,'c #7AA6E1',0  ; DATA XREF: .data:00000198o
.rdata:00000834 $SG145513       db '4',9,'c #195CC6',0  ; DATA XREF: .data:0000019Co
.rdata:00000840 $SG145514       db '5',9,'c #FCFDFE',0  ; DATA XREF: .data:000001A0o
.rdata:0000084C $SG145515       db '6',9,'c #8DB2E4',0  ; DATA XREF: .data:000001A4o
.rdata:00000858 $SG145516       db '7',9,'c #4885D6',0  ; DATA XREF: .data:000001A8o
.rdata:00000864 $SG145517       db '8',9,'c #7CA9E1',0  ; DATA XREF: .data:000001ACo
.rdata:00000870 $SG145518       db '9',9,'c #6698DB',0  ; DATA XREF: .data:000001B0o
.rdata:0000087C $SG145519       db '0',9,'c #71A1DE',0  ; DATA XREF: .data:000001B4o
.rdata:00000888 $SG145520       db 'a',9,'c #1752C0',0  ; DATA XREF: .data:000001B8o
.rdata:00000894 $SG145521       db 'b',9,'c #88ABE0',0  ; DATA XREF: .data:000001BCo
.rdata:000008A0 $SG145522       db 'c',9,'c #3D77D0',0  ; DATA XREF: .data:000001C0o
.rdata:000008AC $SG145523       db 'd',9,'c #6E9FDD',0  ; DATA XREF: .data:000001C4o
.rdata:000008B8 $SG145524       db 'e',9,'c #699BDC',0  ; DATA XREF: .data:000001C8o
.rdata:000008C4 $SG145525       db 'f',9,'c #1547BD',0  ; DATA XREF: .data:000001CCo
.rdata:000008D0 $SG145526       db 'g',9,'c #8DA6DE',0  ; DATA XREF: .data:000001D0o
.rdata:000008DC $SG145527       db 'h',9,'c #376BC9',0  ; DATA XREF: .data:000001D4o
.rdata:000008E8 $SG145528       db 'i',9,'c #6295DA',0  ; DATA XREF: .data:000001D8o
.rdata:000008F4 $SG145529       db 'j',9,'c #1440B9',0  ; DATA XREF: .data:000001DCo
.rdata:00000900 $SG145530       db 'k',9,'c #8DA0DB',0  ; DATA XREF: .data:000001E0o
.rdata:0000090C $SG145531       db 'l',9,'c #315FC4',0  ; DATA XREF: .data:000001E4o
.rdata:00000918 $SG145532       db 'm',9,'c #1339B7',0  ; DATA XREF: .data:000001E8o
.rdata:00000924 $SG145533       db 'n',9,'c #909FDA',0  ; DATA XREF: .data:000001ECo
.rdata:00000930 $SG145534       db 'o',9,'c #1233B4',0  ; DATA XREF: .data:000001F0o
.rdata:0000093C $SG145535       db '         .+ ',0     ; DATA XREF: .data:000001F4o
.rdata:00000949                 align 4
.rdata:0000094C $SG145536       db '        @#$ ',0     ; DATA XREF: .data:000001F8o
.rdata:00000959                 align 4
.rdata:0000095C $SG145537       db '       %&*= L',0    ; DATA XREF: .data:000001FCo
.rdata:0000096A                 align 4
.rdata:0000096C $SG145538       db '      -;>,',27h,' ',0 ; DATA XREF: .data:00000200o
.rdata:00000979                 align 4
.rdata:0000097C $SG145539       db '     )!>~{] ',0     ; DATA XREF: .data:00000204o
.rdata:00000989                 align 4
.rdata:0000098C $SG145540       db '    ^/(_:<[ ',0     ; DATA XREF: .data:00000208o
.rdata:00000999                 align 4
.rdata:0000099C $SG145541       db '    (}|1234 ',0     ; DATA XREF: .data:0000020Co
.rdata:000009A9                 align 4
.rdata:000009AC $SG145542       db '    567890a ',0     ; DATA XREF: .data:00000210o
.rdata:000009B9                 align 4
.rdata:000009BC $SG145543       db '      bcdef ',0     ; DATA XREF: .data:00000214o
.rdata:000009C9                 align 4
.rdata:000009CC $SG145544       db '       ghij ',0     ; DATA XREF: .data:00000218o
.rdata:000009D9                 align 4
.rdata:000009DC $SG145545       db '        klm ',0     ; DATA XREF: .data:0000021Co
.rdata:000009E9                 align 4
.rdata:000009EC $SG145546       db '         no ',0     ; DATA XREF: .data:00000220o
.rdata:000009F9                 align 4
.rdata:000009FC $SG145548       db '13 14 54 1',0       ; DATA XREF: .data:_bookmark_xpmo
.rdata:00000A07                 align 4
.rdata:00000A08 $SG145549       db ' ',9,'c None',0     ; DATA XREF: .data:0000022Co
.rdata:00000A11                 align 4
.rdata:00000A14 $SG145550       db '.',9,'c #545254',0  ; DATA XREF: .data:00000230o
.rdata:00000A20 $SG145551       db '+',9,'c #3C3E3C',0  ; DATA XREF: .data:00000234o
.rdata:00000A2C $SG145552       db '@',9,'c #646464',0  ; DATA XREF: .data:00000238o
.rdata:00000A38 $SG145553       db '#',9,'c #A4A4A4',0  ; DATA XREF: .data:0000023Co
.rdata:00000A44 $SG145554       db '$',9,'c #B7B8B7',0  ; DATA XREF: .data:00000240o
.rdata:00000A50 $SG145555       db '%',9,'c #747284',0  ; DATA XREF: .data:00000244o
.rdata:00000A5C $SG145556       db '&',9,'c #B4B2C4',0  ; DATA XREF: .data:00000248o
.rdata:00000A68 $SG145557       db '*',9,'c #DCD7E4',0  ; DATA XREF: .data:0000024Co
.rdata:00000A74 $SG145558       db '=',9,'c #1C1A1C',0  ; DATA XREF: .data:00000250o
.rdata:00000A80 $SG145559       db '-',9,'c #403E58',0  ; DATA XREF: .data:00000254o
.rdata:00000A8C $SG145560       db ';',9,'c #5C5A8C',0  ; DATA XREF: .data:00000258o
.rdata:00000A98 $SG145561       db '>',9,'c #7C7EAC',0  ; DATA XREF: .data:0000025Co
.rdata:00000AA4 $SG145562       db ',',9,'c #7C8EBC',0  ; DATA XREF: .data:00000260o
.rdata:00000AB0 $SG145563       db 27h,9,'c #242644',0  ; DATA XREF: .data:00000264o
.rdata:00000ABC $SG145564       db ')',9,'c #282668',0  ; DATA XREF: .data:00000268o
.rdata:00000AC8 $SG145565       db '!',9,'c #24367C',0  ; DATA XREF: .data:0000026Co
.rdata:00000AD4 $SG145566       db '~',9,'c #244A84',0  ; DATA XREF: .data:00000270o
.rdata:00000AE0 $SG145567       db '{',9,'c #2C5098',0  ; DATA XREF: .data:00000274o
.rdata:00000AEC $SG145568       db ']',9,'c #14162C',0  ; DATA XREF: .data:00000278o
.rdata:00000AF8 $SG145569       db '^',9,'c #142E7C',0  ; DATA XREF: .data:0000027Co
.rdata:00000B04 $SG145570       db '/',9,'c #143789',0  ; DATA XREF: .data:00000280o
.rdata:00000B10 $SG145571       db '(',9,'c #204990',0  ; DATA XREF: .data:00000284o
.rdata:00000B1C $SG145572       db '_',9,'c #174091',0  ; DATA XREF: .data:00000288o
.rdata:00000B28 $SG145573       db ':',9,'c #0C0630',0  ; DATA XREF: .data:0000028Co
.rdata:00000B34 $SG145574       db '<',9,'c #24327C',0  ; DATA XREF: .data:00000290o
.rdata:00000B40 $SG145575       db '[',9,'c #2450A0',0  ; DATA XREF: .data:00000294o
.rdata:00000B4C $SG145576       db '}',9,'c #345DB4',0  ; DATA XREF: .data:00000298o
.rdata:00000B58 $SG145577       db '|',9,'c #3C68B8',0  ; DATA XREF: .data:0000029Co
.rdata:00000B64 $SG145578       db '1',9,'c #141244',0  ; DATA XREF: .data:000002A0o
.rdata:00000B70 $SG145579       db '2',9,'c #24428C',0  ; DATA XREF: .data:000002A4o
.rdata:00000B7C $SG145580       db '3',9,'c #3462B9',0  ; DATA XREF: .data:000002A8o
.rdata:00000B88 $SG145581       db '4',9,'c #4470C4',0  ; DATA XREF: .data:000002ACo
.rdata:00000B94 $SG145582       db '5',9,'c #4C7FD6',0  ; DATA XREF: .data:000002B0o
.rdata:00000BA0 $SG145583       db '6',9,'c #4472CC',0  ; DATA XREF: .data:000002B4o
.rdata:00000BAC $SG145584       db '7',9,'c #24224C',0  ; DATA XREF: .data:000002B8o
.rdata:00000BB8 $SG145585       db '8',9,'c #5C8DEC',0  ; DATA XREF: .data:000002BCo
.rdata:00000BC4 $SG145586       db '9',9,'c #5C94F6',0  ; DATA XREF: .data:000002C0o
.rdata:00000BD0 $SG145587       db '0',9,'c #5482DF',0  ; DATA XREF: .data:000002C4o
.rdata:00000BDC $SG145588       db 'a',9,'c #619DF7',0  ; DATA XREF: .data:000002C8o
.rdata:00000BE8 $SG145589       db 'b',9,'c #6CA6FC',0  ; DATA XREF: .data:000002CCo
.rdata:00000BF4 $SG145590       db 'c',9,'c #64A2FC',0  ; DATA XREF: .data:000002D0o
.rdata:00000C00 $SG145591       db 'd',9,'c #1C2E5C',0  ; DATA XREF: .data:000002D4o
.rdata:00000C0C $SG145592       db 'e',9,'c #6CA2FC',0  ; DATA XREF: .data:000002D8o
.rdata:00000C18 $SG145593       db 'f',9,'c #74B2FC',0  ; DATA XREF: .data:000002DCo
.rdata:00000C24 $SG145594       db 'g',9,'c #7CB8FC',0  ; DATA XREF: .data:000002E0o
.rdata:00000C30 $SG145595       db 'h',9,'c #1C3264',0  ; DATA XREF: .data:000002E4o
.rdata:00000C3C $SG145596       db 'i',9,'c #346AD4',0  ; DATA XREF: .data:000002E8o
.rdata:00000C48 $SG145597       db 'j',9,'c #7CBEFC',0  ; DATA XREF: .data:000002ECo
.rdata:00000C54 $SG145598       db 'k',9,'c #3C72DC',0  ; DATA XREF: .data:000002F0o
.rdata:00000C60 $SG145599       db 'l',9,'c #243250',0  ; DATA XREF: .data:000002F4o
.rdata:00000C6C $SG145600       db 'm',9,'c #346AB4',0  ; DATA XREF: .data:000002F8o
.rdata:00000C78 $SG145601       db 'n',9,'c #3C82DC',0  ; DATA XREF: .data:000002FCo
.rdata:00000C84 $SG145602       db 'o',9,'c #6C6A6C',0  ; DATA XREF: .data:00000300o
.rdata:00000C90 $SG145603       db '     .+.     ',0    ; DATA XREF: .data:00000304o
.rdata:00000C9E                 align 10h
.rdata:00000CA0 $SG145604       db '   @##$##@   ',0    ; DATA XREF: .data:00000308o
.rdata:00000CAE                 align 10h
.rdata:00000CB0 $SG145605       db '  @%&***&%@  ',0    ; DATA XREF: .data:0000030Co
.rdata:00000CBE                 align 10h
.rdata:00000CC0 $SG145606       db ' =-;>,,,>;-= ',0    ; DATA XREF: .data:00000310o
.rdata:00000CCE                 align 10h
.rdata:00000CD0 $SG145607       db ' ',27h,')!~{{{~!)',27h,' ',0
.rdata:00000CD0                                         ; DATA XREF: .data:00000314o
.rdata:00000CDE                 align 10h
.rdata:00000CE0 $SG145608       db '])^/({{{(_^)]',0    ; DATA XREF: .data:00000318o
.rdata:00000CEE                 align 10h
.rdata:00000CF0 $SG145609       db ':<_[}|||}[_<:',0    ; DATA XREF: .data:0000031Co
.rdata:00000CFE                 align 10h
.rdata:00000D00 $SG145610       db '12[3455563[21',0    ; DATA XREF: .data:00000320o
.rdata:00000D0E                 align 10h
.rdata:00000D10 $SG145611       db '7_365899063_7',0    ; DATA XREF: .data:00000324o
.rdata:00000D1E                 align 10h
.rdata:00000D20 $SG145612       db ' /|09abc904/ ',0    ; DATA XREF: .data:00000328o
.rdata:00000D2E                 align 10h
.rdata:00000D30 $SG145613       db ' d}8efgfb83d ',0    ; DATA XREF: .data:0000032Co
.rdata:00000D3E                 align 10h
.rdata:00000D40 $SG145614       db '  hiafjgakh  ',0    ; DATA XREF: .data:00000330o
.rdata:00000D4E                 align 10h
.rdata:00000D50 $SG145615       db '   l~mnm~l   ',0    ; DATA XREF: .data:00000334o
.rdata:00000D5E                 align 10h
.rdata:00000D60 $SG145616       db '     o@o     ',0    ; DATA XREF: .data:00000338o
.rdata:00000D6E                 align 10h
.rdata:00000D6E _rdata          ends
.rdata:00000D6E
.text$mn:00000D70 ; ===========================================================================
.text$mn:00000D70
.text$mn:00000D70 ; Segment type: Pure code
.text$mn:00000D70 ; Segment permissions: Read/Execute
.text$mn:00000D70 _text$mn        segment para public 'CODE' use32
.text$mn:00000D70                 assume cs:_text$mn
.text$mn:00000D70                 ;org 0D70h
.text$mn:00000D70                 assume es:nothing, ss:nothing, ds:_data, fs:nothing, gs:nothing
.text$mn:00000D70
.text$mn:00000D70 ; =============== S U B R O U T I N E =======================================
.text$mn:00000D70
.text$mn:00000D70 ; Attributes: bp-based frame
.text$mn:00000D70
.text$mn:00000D70 ; void __thiscall AnsiCharPanel::switchEncoding(AnsiCharPanel *__hidden this)
.text$mn:00000D70                 public ?switchEncoding@AnsiCharPanel@@QAEXXZ
.text$mn:00000D70 ?switchEncoding@AnsiCharPanel@@QAEXXZ proc near
.text$mn:00000D70
.text$mn:00000D70 var_8           = dword ptr -8
.text$mn:00000D70 var_4           = dword ptr -4
.text$mn:00000D70
.text$mn:00000D70                 push    ebp
.text$mn:00000D71                 mov     ebp, esp
.text$mn:00000D73                 sub     esp, 8
.text$mn:00000D76                 mov     [ebp+var_4], ecx
.text$mn:00000D79                 mov     eax, [ebp+var_4]
.text$mn:00000D7C                 mov     ecx, [eax+6Ch]
.text$mn:00000D7F                 mov     ecx, [ecx]      ; this
.text$mn:00000D81                 call    ?getCurrentBuffer@ScintillaEditView@@QAEPAVBuffer@@XZ ; ScintillaEditView::getCurrentBuffer(void)
.text$mn:00000D86                 mov     ecx, eax        ; this
.text$mn:00000D88                 call    ?getEncoding@Buffer@@QBEHXZ ; Buffer::getEncoding(void)
.text$mn:00000D8D                 mov     [ebp+var_8], eax
.text$mn:00000D90                 mov     edx, [ebp+var_8]
.text$mn:00000D93                 push    edx             ; int
.text$mn:00000D94                 mov     ecx, [ebp+var_4]
.text$mn:00000D97                 add     ecx, 70h ; 'p'  ; this
.text$mn:00000D9A                 call    ?resetValues@ListView@@QAEXH@Z ; ListView::resetValues(int)
.text$mn:00000D9F                 mov     esp, ebp
.text$mn:00000DA1                 pop     ebp
.text$mn:00000DA2                 retn
.text$mn:00000DA2 ?switchEncoding@AnsiCharPanel@@QAEXXZ endp
.text$mn:00000DA2
.text$mn:00000DA2 ; ---------------------------------------------------------------------------
.text$mn:00000DA3                 align 10h
.text$mn:00000DB0
.text$mn:00000DB0 ; =============== S U B R O U T I N E =======================================
.text$mn:00000DB0
.text$mn:00000DB0 ; Attributes: bp-based frame
.text$mn:00000DB0
.text$mn:00000DB0 ; void __thiscall AnsiCharPanel::insertChar(AnsiCharPanel *this, unsigned __int8)
.text$mn:00000DB0                 public ?insertChar@AnsiCharPanel@@QBEXE@Z
.text$mn:00000DB0 ?insertChar@AnsiCharPanel@@QBEXE@Z proc near
.text$mn:00000DB0                                         ; CODE XREF: AnsiCharPanel::run_dlgProc(uint,uint,long)+E9p
.text$mn:00000DB0                                         ; AnsiCharPanel::run_dlgProc(uint,uint,long)+140p
.text$mn:00000DB0
.text$mn:00000DB0 var_44          = dword ptr -44h
.text$mn:00000DB0 var_40          = dword ptr -40h
.text$mn:00000DB0 CodePage        = dword ptr -3Ch
.text$mn:00000DB0 var_38          = dword ptr -38h
.text$mn:00000DB0 var_34          = dword ptr -34h
.text$mn:00000DB0 var_30          = dword ptr -30h
.text$mn:00000DB0 var_29          = byte ptr -29h
.text$mn:00000DB0 MultiByteStr    = byte ptr -28h
.text$mn:00000DB0 WideCharStr     = word ptr -24h
.text$mn:00000DB0 Str             = byte ptr -10h
.text$mn:00000DB0 var_4           = dword ptr -4
.text$mn:00000DB0 arg_0           = byte ptr  8
.text$mn:00000DB0
.text$mn:00000DB0                 push    ebp
.text$mn:00000DB1                 mov     ebp, esp
.text$mn:00000DB3                 sub     esp, 44h
.text$mn:00000DB6                 mov     eax, dword ptr ds:___security_cookie
.text$mn:00000DBB                 xor     eax, ebp
.text$mn:00000DBD                 mov     [ebp+var_4], eax
.text$mn:00000DC0                 mov     [ebp+var_30], ecx
.text$mn:00000DC3                 mov     eax, 1
.text$mn:00000DC8                 imul    ecx, eax, 0
.text$mn:00000DCB                 mov     dl, [ebp+arg_0]
.text$mn:00000DCE                 mov     [ebp+ecx+MultiByteStr], dl
.text$mn:00000DD2                 mov     [ebp+var_40], 1
.text$mn:00000DD9                 cmp     [ebp+var_40], 2
.text$mn:00000DDD                 jnb     short loc_DE1
.text$mn:00000DDF                 jmp     short loc_DE6
.text$mn:00000DE1 ; ---------------------------------------------------------------------------
.text$mn:00000DE1
.text$mn:00000DE1 loc_DE1:                                ; CODE XREF: AnsiCharPanel::insertChar(uchar)+2Dj
.text$mn:00000DE1                 call    ___report_rangecheckfailure
.text$mn:00000DE6
.text$mn:00000DE6 loc_DE6:                                ; CODE XREF: AnsiCharPanel::insertChar(uchar)+2Fj
.text$mn:00000DE6                 mov     eax, [ebp+var_40]
.text$mn:00000DE9                 mov     [ebp+eax+MultiByteStr], 0
.text$mn:00000DEE                 mov     ecx, [ebp+var_30]
.text$mn:00000DF1                 mov     edx, [ecx+6Ch]
.text$mn:00000DF4                 mov     ecx, [edx]      ; this
.text$mn:00000DF6                 call    ?getCurrentBuffer@ScintillaEditView@@QAEPAVBuffer@@XZ ; ScintillaEditView::getCurrentBuffer(void)
.text$mn:00000DFB                 mov     ecx, eax        ; this
.text$mn:00000DFD                 call    ?getEncoding@Buffer@@QBEHXZ ; Buffer::getEncoding(void)
.text$mn:00000E02                 mov     [ebp+CodePage], eax
.text$mn:00000E05                 cmp     [ebp+CodePage], 0FFFFFFFFh
.text$mn:00000E09                 jnz     loc_EB1
.text$mn:00000E0F                 push    0               ; __int32
.text$mn:00000E11                 push    0               ; unsigned int
.text$mn:00000E13                 push    859h            ; unsigned int
.text$mn:00000E18                 mov     eax, [ebp+var_30]
.text$mn:00000E1B                 mov     ecx, [eax+6Ch]
.text$mn:00000E1E                 mov     ecx, [ecx]      ; this
.text$mn:00000E20                 call    ?execute@ScintillaEditView@@QBEJIIJ@Z ; ScintillaEditView::execute(uint,uint,long)
.text$mn:00000E25                 cmp     eax, 0FDE9h
.text$mn:00000E2A                 jnz     short loc_E35
.text$mn:00000E2C                 mov     [ebp+var_34], 1
.text$mn:00000E33                 jmp     short loc_E3C
.text$mn:00000E35 ; ---------------------------------------------------------------------------
.text$mn:00000E35
.text$mn:00000E35 loc_E35:                                ; CODE XREF: AnsiCharPanel::insertChar(uchar)+7Aj
.text$mn:00000E35                 mov     [ebp+var_34], 0
.text$mn:00000E3C
.text$mn:00000E3C loc_E3C:                                ; CODE XREF: AnsiCharPanel::insertChar(uchar)+83j
.text$mn:00000E3C                 mov     dl, byte ptr [ebp+var_34]
.text$mn:00000E3F                 mov     [ebp+var_29], dl
.text$mn:00000E42                 movzx   eax, [ebp+var_29]
.text$mn:00000E46                 test    eax, eax
.text$mn:00000E48                 jz      short loc_E7F
.text$mn:00000E4A                 push    14h             ; cchWideChar
.text$mn:00000E4C                 lea     ecx, [ebp+WideCharStr]
.text$mn:00000E4F                 push    ecx             ; lpWideCharStr
.text$mn:00000E50                 push    0FFFFFFFFh      ; cbMultiByte
.text$mn:00000E52                 lea     edx, [ebp+MultiByteStr]
.text$mn:00000E55                 push    edx             ; lpMultiByteStr
.text$mn:00000E56                 push    0               ; dwFlags
.text$mn:00000E58                 push    0               ; CodePage
.text$mn:00000E5A                 call    dword ptr ds:__imp__MultiByteToWideChar@24 ; MultiByteToWideChar(x,x,x,x,x,x)
.text$mn:00000E60                 push    0               ; lpUsedDefaultChar
.text$mn:00000E62                 push    0               ; lpDefaultChar
.text$mn:00000E64                 push    0Ah             ; cbMultiByte
.text$mn:00000E66                 lea     eax, [ebp+Str]
.text$mn:00000E69                 push    eax             ; lpMultiByteStr
.text$mn:00000E6A                 push    0FFFFFFFFh      ; cchWideChar
.text$mn:00000E6C                 lea     ecx, [ebp+WideCharStr]
.text$mn:00000E6F                 push    ecx             ; lpWideCharStr
.text$mn:00000E70                 push    0               ; dwFlags
.text$mn:00000E72                 push    0FDE9h          ; CodePage
.text$mn:00000E77                 call    dword ptr ds:__imp__WideCharToMultiByte@32 ; WideCharToMultiByte(x,x,x,x,x,x,x,x)
.text$mn:00000E7D                 jmp     short loc_EAF
.text$mn:00000E7F ; ---------------------------------------------------------------------------
.text$mn:00000E7F
.text$mn:00000E7F loc_E7F:                                ; CODE XREF: AnsiCharPanel::insertChar(uchar)+98j
.text$mn:00000E7F                 mov     edx, 1
.text$mn:00000E84                 imul    eax, edx, 0
.text$mn:00000E87                 mov     ecx, 1
.text$mn:00000E8C                 imul    edx, ecx, 0
.text$mn:00000E8F                 mov     al, [ebp+eax+MultiByteStr]
.text$mn:00000E93                 mov     [ebp+edx+Str], al
.text$mn:00000E97                 mov     ecx, 1
.text$mn:00000E9C                 shl     ecx, 0
.text$mn:00000E9F                 mov     edx, 1
.text$mn:00000EA4                 shl     edx, 0
.text$mn:00000EA7                 mov     al, [ebp+ecx+MultiByteStr]
.text$mn:00000EAB                 mov     [ebp+edx+Str], al
.text$mn:00000EAF
.text$mn:00000EAF loc_EAF:                                ; CODE XREF: AnsiCharPanel::insertChar(uchar)+CDj
.text$mn:00000EAF                 jmp     short loc_EE6
.text$mn:00000EB1 ; ---------------------------------------------------------------------------
.text$mn:00000EB1
.text$mn:00000EB1 loc_EB1:                                ; CODE XREF: AnsiCharPanel::insertChar(uchar)+59j
.text$mn:00000EB1                 push    14h             ; cchWideChar
.text$mn:00000EB3                 lea     ecx, [ebp+WideCharStr]
.text$mn:00000EB6                 push    ecx             ; lpWideCharStr
.text$mn:00000EB7                 push    0FFFFFFFFh      ; cbMultiByte
.text$mn:00000EB9                 lea     edx, [ebp+MultiByteStr]
.text$mn:00000EBC                 push    edx             ; lpMultiByteStr
.text$mn:00000EBD                 push    0               ; dwFlags
.text$mn:00000EBF                 mov     eax, [ebp+CodePage]
.text$mn:00000EC2                 push    eax             ; CodePage
.text$mn:00000EC3                 call    dword ptr ds:__imp__MultiByteToWideChar@24 ; MultiByteToWideChar(x,x,x,x,x,x)
.text$mn:00000EC9                 push    0               ; lpUsedDefaultChar
.text$mn:00000ECB                 push    0               ; lpDefaultChar
.text$mn:00000ECD                 push    0Ah             ; cbMultiByte
.text$mn:00000ECF                 lea     ecx, [ebp+Str]
.text$mn:00000ED2                 push    ecx             ; lpMultiByteStr
.text$mn:00000ED3                 push    0FFFFFFFFh      ; cchWideChar
.text$mn:00000ED5                 lea     edx, [ebp+WideCharStr]
.text$mn:00000ED8                 push    edx             ; lpWideCharStr
.text$mn:00000ED9                 push    0               ; dwFlags
.text$mn:00000EDB                 push    0FDE9h          ; CodePage
.text$mn:00000EE0                 call    dword ptr ds:__imp__WideCharToMultiByte@32 ; WideCharToMultiByte(x,x,x,x,x,x,x,x)
.text$mn:00000EE6
.text$mn:00000EE6 loc_EE6:                                ; CODE XREF: AnsiCharPanel::insertChar(uchar):loc_EAFj
.text$mn:00000EE6                 push    offset $SG153182 ; __int32
.text$mn:00000EEB                 push    0               ; unsigned int
.text$mn:00000EED                 push    87Ah            ; unsigned int
.text$mn:00000EF2                 mov     eax, [ebp+var_30]
.text$mn:00000EF5                 mov     ecx, [eax+6Ch]
.text$mn:00000EF8                 mov     ecx, [ecx]      ; this
.text$mn:00000EFA                 call    ?execute@ScintillaEditView@@QBEJIIJ@Z ; ScintillaEditView::execute(uint,uint,long)
.text$mn:00000EFF                 movzx   edx, [ebp+arg_0]
.text$mn:00000F03                 cmp     edx, 80h ; 'Ç'
.text$mn:00000F09                 jge     short loc_F14
.text$mn:00000F0B                 mov     [ebp+var_38], 1
.text$mn:00000F12                 jmp     short loc_F23
.text$mn:00000F14 ; ---------------------------------------------------------------------------
.text$mn:00000F14
.text$mn:00000F14 loc_F14:                                ; CODE XREF: AnsiCharPanel::insertChar(uchar)+159j
.text$mn:00000F14                 lea     eax, [ebp+Str]
.text$mn:00000F17                 push    eax             ; Str
.text$mn:00000F18                 call    _strlen
.text$mn:00000F1D                 add     esp, 4
.text$mn:00000F20                 mov     [ebp+var_38], eax
.text$mn:00000F23
.text$mn:00000F23 loc_F23:                                ; CODE XREF: AnsiCharPanel::insertChar(uchar)+162j
.text$mn:00000F23                 mov     ecx, [ebp+var_38]
.text$mn:00000F26                 mov     [ebp+var_44], ecx
.text$mn:00000F29                 lea     edx, [ebp+Str]
.text$mn:00000F2C                 push    edx             ; __int32
.text$mn:00000F2D                 mov     eax, [ebp+var_44]
.text$mn:00000F30                 push    eax             ; unsigned int
.text$mn:00000F31                 push    7D1h            ; unsigned int
.text$mn:00000F36                 mov     ecx, [ebp+var_30]
.text$mn:00000F39                 mov     edx, [ecx+6Ch]
.text$mn:00000F3C                 mov     ecx, [edx]      ; this
.text$mn:00000F3E                 call    ?execute@ScintillaEditView@@QBEJIIJ@Z ; ScintillaEditView::execute(uint,uint,long)
.text$mn:00000F43                 mov     eax, [ebp+var_30]
.text$mn:00000F46                 mov     ecx, [eax+6Ch]
.text$mn:00000F49                 mov     ecx, [ecx]      ; this
.text$mn:00000F4B                 call    ?getFocus@Window@@QBEXXZ ; Window::getFocus(void)
.text$mn:00000F50                 mov     ecx, [ebp+var_4]
.text$mn:00000F53                 xor     ecx, ebp
.text$mn:00000F55                 call    @__security_check_cookie@4 ; __security_check_cookie(x)
.text$mn:00000F5A                 mov     esp, ebp
.text$mn:00000F5C                 pop     ebp
.text$mn:00000F5D                 retn    4
.text$mn:00000F5D ?insertChar@AnsiCharPanel@@QBEXE@Z endp
.text$mn:00000F5D
.text$mn:00000F60
.text$mn:00000F60 ; =============== S U B R O U T I N E =======================================
.text$mn:00000F60
.text$mn:00000F60 ; Attributes: bp-based frame
.text$mn:00000F60
.text$mn:00000F60 ; int __stdcall AnsiCharPanel::run_dlgProc(AnsiCharPanel *this, unsigned int, unsigned int, __int32)
.text$mn:00000F60                 public ?run_dlgProc@AnsiCharPanel@@MAGHIIJ@Z
.text$mn:00000F60 ?run_dlgProc@AnsiCharPanel@@MAGHIIJ@Z proc near
.text$mn:00000F60
.text$mn:00000F60 nWidth          = dword ptr -28h
.text$mn:00000F60 nHeight         = dword ptr -24h
.text$mn:00000F60 var_20          = dword ptr -20h
.text$mn:00000F60 var_1C          = dword ptr -1Ch
.text$mn:00000F60 var_18          = dword ptr -18h
.text$mn:00000F60 var_14          = dword ptr -14h
.text$mn:00000F60 var_10          = dword ptr -10h
.text$mn:00000F60 var_C           = dword ptr -0Ch
.text$mn:00000F60 var_8           = dword ptr -8
.text$mn:00000F60 var_4           = dword ptr -4
.text$mn:00000F60 this            = dword ptr  8
.text$mn:00000F60 arg_4           = dword ptr  0Ch
.text$mn:00000F60 arg_8           = dword ptr  10h
.text$mn:00000F60 arg_C           = dword ptr  14h
.text$mn:00000F60
.text$mn:00000F60                 push    ebp
.text$mn:00000F61                 mov     ebp, esp
.text$mn:00000F63                 sub     esp, 28h
.text$mn:00000F66                 mov     eax, [ebp+arg_4]
.text$mn:00000F69                 mov     [ebp+var_4], eax
.text$mn:00000F6C                 cmp     [ebp+var_4], 5
.text$mn:00000F70                 jz      loc_10B3
.text$mn:00000F76                 cmp     [ebp+var_4], 4Eh ; 'N'
.text$mn:00000F7A                 jz      loc_1005
.text$mn:00000F80                 cmp     [ebp+var_4], 110h
.text$mn:00000F87                 jz      short loc_F8E
.text$mn:00000F89                 jmp     loc_10F5
.text$mn:00000F8E ; ---------------------------------------------------------------------------
.text$mn:00000F8E
.text$mn:00000F8E loc_F8E:                                ; CODE XREF: AnsiCharPanel::run_dlgProc(uint,uint,long)+27j
.text$mn:00000F8E                 mov     ecx, [ebp+this]
.text$mn:00000F91                 mov     edx, [ecx+0Ch]
.text$mn:00000F94                 push    edx
.text$mn:00000F95                 mov     eax, [ebp+this]
.text$mn:00000F98                 mov     ecx, [eax+4]
.text$mn:00000F9B                 push    ecx
.text$mn:00000F9C                 mov     ecx, [ebp+this]
.text$mn:00000F9F                 add     ecx, 70h ; 'p'
.text$mn:00000FA2                 mov     edx, [ebp+this]
.text$mn:00000FA5                 mov     eax, [edx+70h]
.text$mn:00000FA8                 mov     edx, [eax+4]
.text$mn:00000FAB                 call    edx
.text$mn:00000FAD                 mov     eax, [ebp+this]
.text$mn:00000FB0                 mov     ecx, [eax+6Ch]
.text$mn:00000FB3                 mov     ecx, [ecx]      ; this
.text$mn:00000FB5                 call    ?getCurrentBuffer@ScintillaEditView@@QAEPAVBuffer@@XZ ; ScintillaEditView::getCurrentBuffer(void)
.text$mn:00000FBA                 mov     ecx, eax        ; this
.text$mn:00000FBC                 call    ?getEncoding@Buffer@@QBEHXZ ; Buffer::getEncoding(void)
.text$mn:00000FC1                 mov     [ebp+var_8], eax
.text$mn:00000FC4                 cmp     [ebp+var_8], 0FFFFFFFFh
.text$mn:00000FC8                 jnz     short loc_FD3
.text$mn:00000FCA                 mov     [ebp+var_C], 0
.text$mn:00000FD1                 jmp     short loc_FD9
.text$mn:00000FD3 ; ---------------------------------------------------------------------------
.text$mn:00000FD3
.text$mn:00000FD3 loc_FD3:                                ; CODE XREF: AnsiCharPanel::run_dlgProc(uint,uint,long)+68j
.text$mn:00000FD3                 mov     edx, [ebp+var_8]
.text$mn:00000FD6                 mov     [ebp+var_C], edx
.text$mn:00000FD9
.text$mn:00000FD9 loc_FD9:                                ; CODE XREF: AnsiCharPanel::run_dlgProc(uint,uint,long)+71j
.text$mn:00000FD9                 mov     eax, [ebp+var_C]
.text$mn:00000FDC                 push    eax             ; int
.text$mn:00000FDD                 mov     ecx, [ebp+this]
.text$mn:00000FE0                 add     ecx, 70h ; 'p'  ; this
.text$mn:00000FE3                 call    ?setValues@ListView@@QAEXH@Z ; ListView::setValues(int)
.text$mn:00000FE8                 push    1
.text$mn:00000FEA                 mov     ecx, [ebp+this]
.text$mn:00000FED                 add     ecx, 70h ; 'p'
.text$mn:00000FF0                 mov     edx, [ebp+this]
.text$mn:00000FF3                 mov     eax, [edx+70h]
.text$mn:00000FF6                 mov     edx, [eax+0Ch]
.text$mn:00000FF9                 call    edx
.text$mn:00000FFB                 mov     eax, 1
.text$mn:00001000                 jmp     loc_1121
.text$mn:00001005 ; ---------------------------------------------------------------------------
.text$mn:00001005
.text$mn:00001005 loc_1005:                               ; CODE XREF: AnsiCharPanel::run_dlgProc(uint,uint,long)+1Aj
.text$mn:00001005                 mov     eax, [ebp+arg_C]
.text$mn:00001008                 mov     ecx, [eax+8]
.text$mn:0000100B                 mov     [ebp+var_10], ecx
.text$mn:0000100E                 cmp     [ebp+var_10], 0FFFFFF65h
.text$mn:00001015                 jz      short loc_1058
.text$mn:00001017                 cmp     [ebp+var_10], 0FFFFFFFDh
.text$mn:0000101B                 jz      short loc_1022
.text$mn:0000101D                 jmp     loc_10AC
.text$mn:00001022 ; ---------------------------------------------------------------------------
.text$mn:00001022
.text$mn:00001022 loc_1022:                               ; CODE XREF: AnsiCharPanel::run_dlgProc(uint,uint,long)+BBj
.text$mn:00001022                 mov     edx, [ebp+arg_C]
.text$mn:00001025                 mov     [ebp+var_1C], edx
.text$mn:00001028                 mov     eax, [ebp+var_1C]
.text$mn:0000102B                 mov     ecx, [eax+0Ch]
.text$mn:0000102E                 mov     [ebp+var_14], ecx
.text$mn:00001031                 cmp     [ebp+var_14], 0FFFFFFFFh
.text$mn:00001035                 jnz     short loc_1041
.text$mn:00001037                 mov     eax, 1
.text$mn:0000103C                 jmp     loc_1121
.text$mn:00001041 ; ---------------------------------------------------------------------------
.text$mn:00001041
.text$mn:00001041 loc_1041:                               ; CODE XREF: AnsiCharPanel::run_dlgProc(uint,uint,long)+D5j
.text$mn:00001041                 movzx   edx, byte ptr [ebp+var_14]
.text$mn:00001045                 push    edx             ; unsigned __int8
.text$mn:00001046                 mov     ecx, [ebp+this] ; this
.text$mn:00001049                 call    ?insertChar@AnsiCharPanel@@QBEXE@Z ; AnsiCharPanel::insertChar(uchar)
.text$mn:0000104E                 mov     eax, 1
.text$mn:00001053                 jmp     loc_1121
.text$mn:00001058 ; ---------------------------------------------------------------------------
.text$mn:00001058
.text$mn:00001058 loc_1058:                               ; CODE XREF: AnsiCharPanel::run_dlgProc(uint,uint,long)+B5j
.text$mn:00001058                 mov     eax, [ebp+arg_C]
.text$mn:0000105B                 movzx   ecx, word ptr [eax+0Ch]
.text$mn:0000105F                 mov     [ebp+var_20], ecx
.text$mn:00001062                 cmp     [ebp+var_20], 0Dh
.text$mn:00001066                 jz      short loc_106A
.text$mn:00001068                 jmp     short loc_10AC
.text$mn:0000106A ; ---------------------------------------------------------------------------
.text$mn:0000106A
.text$mn:0000106A loc_106A:                               ; CODE XREF: AnsiCharPanel::run_dlgProc(uint,uint,long)+106j
.text$mn:0000106A                 push    0               ; lParam
.text$mn:0000106C                 push    0               ; wParam
.text$mn:0000106E                 push    1042h           ; Msg
.text$mn:00001073                 mov     ecx, [ebp+this]
.text$mn:00001076                 add     ecx, 70h ; 'p'  ; this
.text$mn:00001079                 call    ?getHSelf@Window@@QBEPAUHWND__@@XZ ; Window::getHSelf(void)
.text$mn:0000107E                 push    eax             ; hWnd
.text$mn:0000107F                 call    dword ptr ds:__imp__SendMessageW@16 ; SendMessageW(x,x,x,x)
.text$mn:00001085                 mov     [ebp+var_18], eax
.text$mn:00001088                 cmp     [ebp+var_18], 0FFFFFFFFh
.text$mn:0000108C                 jnz     short loc_1098
.text$mn:0000108E                 mov     eax, 1
.text$mn:00001093                 jmp     loc_1121
.text$mn:00001098 ; ---------------------------------------------------------------------------
.text$mn:00001098
.text$mn:00001098 loc_1098:                               ; CODE XREF: AnsiCharPanel::run_dlgProc(uint,uint,long)+12Cj
.text$mn:00001098                 movzx   edx, byte ptr [ebp+var_18]
.text$mn:0000109C                 push    edx             ; unsigned __int8
.text$mn:0000109D                 mov     ecx, [ebp+this] ; this
.text$mn:000010A0                 call    ?insertChar@AnsiCharPanel@@QBEXE@Z ; AnsiCharPanel::insertChar(uchar)
.text$mn:000010A5                 mov     eax, 1
.text$mn:000010AA                 jmp     short loc_1121
.text$mn:000010AC ; ---------------------------------------------------------------------------
.text$mn:000010AC
.text$mn:000010AC loc_10AC:                               ; CODE XREF: AnsiCharPanel::run_dlgProc(uint,uint,long)+BDj
.text$mn:000010AC                                         ; AnsiCharPanel::run_dlgProc(uint,uint,long)+108j
.text$mn:000010AC                 mov     eax, 1
.text$mn:000010B1                 jmp     short loc_1121
.text$mn:000010B3 ; ---------------------------------------------------------------------------
.text$mn:000010B3
.text$mn:000010B3 loc_10B3:                               ; CODE XREF: AnsiCharPanel::run_dlgProc(uint,uint,long)+10j
.text$mn:000010B3                 mov     eax, [ebp+arg_C]
.text$mn:000010B6                 and     eax, 0FFFFh
.text$mn:000010BB                 movzx   ecx, ax
.text$mn:000010BE                 mov     [ebp+nWidth], ecx
.text$mn:000010C1                 mov     edx, [ebp+arg_C]
.text$mn:000010C4                 shr     edx, 10h
.text$mn:000010C7                 and     edx, 0FFFFh
.text$mn:000010CD                 movzx   eax, dx
.text$mn:000010D0                 mov     [ebp+nHeight], eax
.text$mn:000010D3                 push    1               ; bRepaint
.text$mn:000010D5                 mov     ecx, [ebp+nHeight]
.text$mn:000010D8                 push    ecx             ; nHeight
.text$mn:000010D9                 mov     edx, [ebp+nWidth]
.text$mn:000010DC                 push    edx             ; nWidth
.text$mn:000010DD                 push    0               ; Y
.text$mn:000010DF                 push    0               ; X
.text$mn:000010E1                 mov     ecx, [ebp+this]
.text$mn:000010E4                 add     ecx, 70h ; 'p'  ; this
.text$mn:000010E7                 call    ?getHSelf@Window@@QBEPAUHWND__@@XZ ; Window::getHSelf(void)
.text$mn:000010EC                 push    eax             ; hWnd
.text$mn:000010ED                 call    dword ptr ds:__imp__MoveWindow@24 ; MoveWindow(x,x,x,x,x,x)
.text$mn:000010F3                 jmp     short loc_110C
.text$mn:000010F5 ; ---------------------------------------------------------------------------
.text$mn:000010F5
.text$mn:000010F5 loc_10F5:                               ; CODE XREF: AnsiCharPanel::run_dlgProc(uint,uint,long)+29j
.text$mn:000010F5                 mov     eax, [ebp+arg_C]
.text$mn:000010F8                 push    eax             ; __int32
.text$mn:000010F9                 mov     ecx, [ebp+arg_8]
.text$mn:000010FC                 push    ecx             ; unsigned int
.text$mn:000010FD                 mov     edx, [ebp+arg_4]
.text$mn:00001100                 push    edx             ; unsigned int
.text$mn:00001101                 mov     eax, [ebp+this]
.text$mn:00001104                 push    eax             ; this
.text$mn:00001105                 call    ?run_dlgProc@DockingDlgInterface@@MAGHIIJ@Z ; DockingDlgInterface::run_dlgProc(uint,uint,long)
.text$mn:0000110A                 jmp     short loc_1121
.text$mn:0000110C ; ---------------------------------------------------------------------------
.text$mn:0000110C
.text$mn:0000110C loc_110C:                               ; CODE XREF: AnsiCharPanel::run_dlgProc(uint,uint,long)+193j
.text$mn:0000110C                 mov     ecx, [ebp+arg_C]
.text$mn:0000110F                 push    ecx             ; __int32
.text$mn:00001110                 mov     edx, [ebp+arg_8]
.text$mn:00001113                 push    edx             ; unsigned int
.text$mn:00001114                 mov     eax, [ebp+arg_4]
.text$mn:00001117                 push    eax             ; unsigned int
.text$mn:00001118                 mov     ecx, [ebp+this]
.text$mn:0000111B                 push    ecx             ; this
.text$mn:0000111C                 call    ?run_dlgProc@DockingDlgInterface@@MAGHIIJ@Z ; DockingDlgInterface::run_dlgProc(uint,uint,long)
.text$mn:00001121
.text$mn:00001121 loc_1121:                               ; CODE XREF: AnsiCharPanel::run_dlgProc(uint,uint,long)+A0j
.text$mn:00001121                                         ; AnsiCharPanel::run_dlgProc(uint,uint,long)+DCj ...
.text$mn:00001121                 mov     esp, ebp
.text$mn:00001123                 pop     ebp
.text$mn:00001124                 retn    10h
.text$mn:00001124 ?run_dlgProc@AnsiCharPanel@@MAGHIIJ@Z endp
.text$mn:00001124
.text$mn:00001124 ; ---------------------------------------------------------------------------
.text$mn:00001127                 align 4
.text$mn:00001127 _text$mn        ends
.text$mn:00001127
.text$mn:00001128 ; ===========================================================================
.text$mn:00001128
.text$mn:00001128 ; Segment type: Pure code
.text$mn:00001128 ; Segment permissions: Read/Execute
.text$mn:00001128 _text$mn        segment para public 'CODE' use32
.text$mn:00001128                 assume cs:_text$mn
.text$mn:00001128                 ;org 1128h
.text$mn:00001128 ; COMDAT (pick any)
.text$mn:00001128                 assume es:nothing, ss:nothing, ds:_data, fs:nothing, gs:nothing
.text$mn:00001128
.text$mn:00001128 ; =============== S U B R O U T I N E =======================================
.text$mn:00001128
.text$mn:00001128 ; Attributes: bp-based frame
.text$mn:00001128
.text$mn:00001128 ; char * __cdecl std::_Allocate<char>(unsigned int, char *)
.text$mn:00001128                 public ??$_Allocate@D@std@@YAPADIPAD@Z
.text$mn:00001128 ??$_Allocate@D@std@@YAPADIPAD@Z proc near
.text$mn:00001128                                         ; CODE XREF: std::allocator<char>::allocate(uint)+Dp
.text$mn:00001128
.text$mn:00001128 var_4           = dword ptr -4
.text$mn:00001128 arg_0           = dword ptr  8
.text$mn:00001128
.text$mn:00001128                 push    ebp
.text$mn:00001129                 mov     ebp, esp
.text$mn:0000112B                 push    ecx
.text$mn:0000112C                 mov     [ebp+var_4], 0
.text$mn:00001133                 cmp     [ebp+arg_0], 0
.text$mn:00001137                 jnz     short loc_113B
.text$mn:00001139                 jmp     short loc_115B
.text$mn:0000113B ; ---------------------------------------------------------------------------
.text$mn:0000113B
.text$mn:0000113B loc_113B:                               ; CODE XREF: std::_Allocate<char>(uint,char *)+Fj
.text$mn:0000113B                 cmp     [ebp+arg_0], 0FFFFFFFFh
.text$mn:0000113F                 ja      short loc_1156
.text$mn:00001141                 mov     eax, [ebp+arg_0]
.text$mn:00001144                 push    eax             ; unsigned int
.text$mn:00001145                 call    ??2@YAPAXI@Z    ; operator new(uint)
.text$mn:0000114A                 add     esp, 4
.text$mn:0000114D                 mov     [ebp+var_4], eax
.text$mn:00001150                 cmp     [ebp+var_4], 0
.text$mn:00001154                 jnz     short loc_115B
.text$mn:00001156
.text$mn:00001156 loc_1156:                               ; CODE XREF: std::_Allocate<char>(uint,char *)+17j
.text$mn:00001156                 call    ?_Xbad_alloc@std@@YAXXZ ; std::_Xbad_alloc(void)
.text$mn:0000115B
.text$mn:0000115B loc_115B:                               ; CODE XREF: std::_Allocate<char>(uint,char *)+11j
.text$mn:0000115B                                         ; std::_Allocate<char>(uint,char *)+2Cj
.text$mn:0000115B                 mov     eax, [ebp+var_4]
.text$mn:0000115E                 mov     esp, ebp
.text$mn:00001160                 pop     ebp
.text$mn:00001161                 retn
.text$mn:00001161 ??$_Allocate@D@std@@YAPADIPAD@Z endp
.text$mn:00001161
.text$mn:00001161 ; ---------------------------------------------------------------------------
.text$mn:00001162                 align 4
.text$mn:00001162 _text$mn        ends
.text$mn:00001162
.text$mn:00001164 ; ===========================================================================
.text$mn:00001164
.text$mn:00001164 ; Segment type: Pure code
.text$mn:00001164 ; Segment permissions: Read/Execute
.text$mn:00001164 _text$mn        segment para public 'CODE' use32
.text$mn:00001164                 assume cs:_text$mn
.text$mn:00001164                 ;org 1164h
.text$mn:00001164 ; COMDAT (pick any)
.text$mn:00001164                 assume es:nothing, ss:nothing, ds:_data, fs:nothing, gs:nothing
.text$mn:00001164
.text$mn:00001164 ; =============== S U B R O U T I N E =======================================
.text$mn:00001164
.text$mn:00001164 ; Attributes: bp-based frame
.text$mn:00001164
.text$mn:00001164 ; struct std::_Container_proxy * __cdecl std::_Allocate<struct std::_Container_proxy>(unsigned int, struct std::_Container_proxy *)
.text$mn:00001164                 public ??$_Allocate@U_Container_proxy@std@@@std@@YAPAU_Container_proxy@0@IPAU10@@Z
.text$mn:00001164 ??$_Allocate@U_Container_proxy@std@@@std@@YAPAU_Container_proxy@0@IPAU10@@Z proc near
.text$mn:00001164                                         ; CODE XREF: std::allocator<std::_Container_proxy>::allocate(uint)+Dp
.text$mn:00001164
.text$mn:00001164 var_4           = dword ptr -4
.text$mn:00001164 arg_0           = dword ptr  8
.text$mn:00001164
.text$mn:00001164                 push    ebp
.text$mn:00001165                 mov     ebp, esp
.text$mn:00001167                 push    ecx
.text$mn:00001168                 mov     [ebp+var_4], 0
.text$mn:0000116F                 cmp     [ebp+arg_0], 0
.text$mn:00001173                 jnz     short loc_1177
.text$mn:00001175                 jmp     short loc_119D
.text$mn:00001177 ; ---------------------------------------------------------------------------
.text$mn:00001177
.text$mn:00001177 loc_1177:                               ; CODE XREF: std::_Allocate<std::_Container_proxy>(uint,std::_Container_proxy *)+Fj
.text$mn:00001177                 cmp     [ebp+arg_0], 1FFFFFFFh
.text$mn:0000117E                 ja      short loc_1198
.text$mn:00001180                 mov     eax, [ebp+arg_0]
.text$mn:00001183                 shl     eax, 3
.text$mn:00001186                 push    eax             ; unsigned int
.text$mn:00001187                 call    ??2@YAPAXI@Z    ; operator new(uint)
.text$mn:0000118C                 add     esp, 4
.text$mn:0000118F                 mov     [ebp+var_4], eax
.text$mn:00001192                 cmp     [ebp+var_4], 0
.text$mn:00001196                 jnz     short loc_119D
.text$mn:00001198
.text$mn:00001198 loc_1198:                               ; CODE XREF: std::_Allocate<std::_Container_proxy>(uint,std::_Container_proxy *)+1Aj
.text$mn:00001198                 call    ?_Xbad_alloc@std@@YAXXZ ; std::_Xbad_alloc(void)
.text$mn:0000119D
.text$mn:0000119D loc_119D:                               ; CODE XREF: std::_Allocate<std::_Container_proxy>(uint,std::_Container_proxy *)+11j
.text$mn:0000119D                                         ; std::_Allocate<std::_Container_proxy>(uint,std::_Container_proxy *)+32j
.text$mn:0000119D                 mov     eax, [ebp+var_4]
.text$mn:000011A0                 mov     esp, ebp
.text$mn:000011A2                 pop     ebp
.text$mn:000011A3                 retn
.text$mn:000011A3 ??$_Allocate@U_Container_proxy@std@@@std@@YAPAU_Container_proxy@0@IPAU10@@Z endp
.text$mn:000011A3
.text$mn:000011A3 _text$mn        ends
.text$mn:000011A3
.text$mn:000011A4 ; ===========================================================================
.text$mn:000011A4
.text$mn:000011A4 ; Segment type: Pure code
.text$mn:000011A4 ; Segment permissions: Read/Execute
.text$mn:000011A4 _text$mn        segment para public 'CODE' use32
.text$mn:000011A4                 assume cs:_text$mn
.text$mn:000011A4                 ;org 11A4h
.text$mn:000011A4 ; COMDAT (pick any)
.text$mn:000011A4                 assume es:nothing, ss:nothing, ds:_data, fs:nothing, gs:nothing
.text$mn:000011A4
.text$mn:000011A4 ; =============== S U B R O U T I N E =======================================
.text$mn:000011A4
.text$mn:000011A4 ; Attributes: bp-based frame
.text$mn:000011A4
.text$mn:000011A4 ; int __cdecl std::_Debug_pointer<char>(int, wchar_t *, unsigned int)
.text$mn:000011A4                 public ??$_Debug_pointer@D@std@@YAXPBDPB_WI@Z
.text$mn:000011A4 ??$_Debug_pointer@D@std@@YAXPBDPB_WI@Z proc near
.text$mn:000011A4                                         ; CODE XREF: std::basic_string<char,std::char_traits<char>,std::allocator<char>>::assign(char const *)+15p
.text$mn:000011A4                                         ; std::basic_string<char,std::char_traits<char>,std::allocator<char>>::assign(char const *,uint)+1Bp
.text$mn:000011A4
.text$mn:000011A4 arg_0           = dword ptr  8
.text$mn:000011A4 arg_4           = dword ptr  0Ch
.text$mn:000011A4 arg_8           = dword ptr  10h
.text$mn:000011A4
.text$mn:000011A4                 push    ebp
.text$mn:000011A5                 mov     ebp, esp
.text$mn:000011A7                 cmp     [ebp+arg_0], 0
.text$mn:000011AB                 jnz     short loc_11C2
.text$mn:000011AD                 mov     eax, [ebp+arg_8]
.text$mn:000011B0                 push    eax             ; unsigned int
.text$mn:000011B1                 mov     ecx, [ebp+arg_4]
.text$mn:000011B4                 push    ecx             ; wchar_t *
.text$mn:000011B5                 push    offset ??_C@_1CK@EOPGIILJ@?$AAi?$AAn?$AAv?$AAa?$AAl?$AAi?$AAd?$AA?5?$AAn?$AAu?$AAl?$AAl?$AA?5?$AAp?$AAo?$AAi?$AAn?$AAt?$AAe?$AAr?$AA?$AA@ ; "invalid null pointer"
.text$mn:000011BA                 call    ?_Debug_message@std@@YAXPB_W0I@Z ; std::_Debug_message(wchar_t const *,wchar_t const *,uint)
.text$mn:000011BF                 add     esp, 0Ch
.text$mn:000011C2
.text$mn:000011C2 loc_11C2:                               ; CODE XREF: std::_Debug_pointer<char>(char const *,wchar_t const *,uint)+7j
.text$mn:000011C2                 pop     ebp
.text$mn:000011C3                 retn
.text$mn:000011C3 ??$_Debug_pointer@D@std@@YAXPBDPB_WI@Z endp
.text$mn:000011C3
.text$mn:000011C3 _text$mn        ends
.text$mn:000011C3
.text$mn:000011C4 ; ===========================================================================
.text$mn:000011C4
.text$mn:000011C4 ; Segment type: Pure code
.text$mn:000011C4 ; Segment permissions: Read/Execute
.text$mn:000011C4 _text$mn        segment para public 'CODE' use32
.text$mn:000011C4                 assume cs:_text$mn
.text$mn:000011C4                 ;org 11C4h
.text$mn:000011C4 ; COMDAT (pick any)
.text$mn:000011C4                 assume es:nothing, ss:nothing, ds:_data, fs:nothing, gs:nothing
.text$mn:000011C4
.text$mn:000011C4 ; =============== S U B R O U T I N E =======================================
.text$mn:000011C4
.text$mn:000011C4 ; Attributes: bp-based frame
.text$mn:000011C4
.text$mn:000011C4 ; char * __cdecl std::addressof<char>(char &)
.text$mn:000011C4                 public ??$addressof@D@std@@YAPADAAD@Z
.text$mn:000011C4 ??$addressof@D@std@@YAPADAAD@Z proc near
.text$mn:000011C4                                         ; CODE XREF: std::_String_val<std::_Simple_types<char>>::_Myptr(void)+19p
.text$mn:000011C4                                         ; std::_String_val<std::_Simple_types<char>>::_Myptr(void)+19p ...
.text$mn:000011C4
.text$mn:000011C4 arg_0           = dword ptr  8
.text$mn:000011C4
.text$mn:000011C4                 push    ebp
.text$mn:000011C5                 mov     ebp, esp
.text$mn:000011C7                 mov     eax, [ebp+arg_0]
.text$mn:000011CA                 pop     ebp
.text$mn:000011CB                 retn
.text$mn:000011CB ??$addressof@D@std@@YAPADAAD@Z endp
.text$mn:000011CB
.text$mn:000011CB _text$mn        ends
.text$mn:000011CB
.text$mn:000011CC ; ===========================================================================
.text$mn:000011CC
.text$mn:000011CC ; Segment type: Pure code
.text$mn:000011CC ; Segment permissions: Read/Execute
.text$mn:000011CC _text$mn        segment para public 'CODE' use32
.text$mn:000011CC                 assume cs:_text$mn
.text$mn:000011CC                 ;org 11CCh
.text$mn:000011CC ; COMDAT (pick any)
.text$mn:000011CC                 assume es:nothing, ss:nothing, ds:_data, fs:nothing, gs:nothing
.text$mn:000011CC
.text$mn:000011CC ; =============== S U B R O U T I N E =======================================
.text$mn:000011CC
.text$mn:000011CC ; Attributes: bp-based frame
.text$mn:000011CC
.text$mn:000011CC ; int __stdcall std::_Wrap_alloc<std::allocator<char>>::construct<char *,char * &>(void *, int)
.text$mn:000011CC                 public ??$construct@PADAAPAD@?$_Wrap_alloc@V?$allocator@D@std@@@std@@QAEXPAPADAAPAD@Z
.text$mn:000011CC ??$construct@PADAAPAD@?$_Wrap_alloc@V?$allocator@D@std@@@std@@QAEXPAPADAAPAD@Z proc near
.text$mn:000011CC                                         ; CODE XREF: $LN19+4Bp
.text$mn:000011CC
.text$mn:000011CC var_4           = dword ptr -4
.text$mn:000011CC arg_0           = dword ptr  8
.text$mn:000011CC arg_4           = dword ptr  0Ch
.text$mn:000011CC
.text$mn:000011CC                 push    ebp
.text$mn:000011CD                 mov     ebp, esp
.text$mn:000011CF                 push    ecx
.text$mn:000011D0                 mov     [ebp+var_4], ecx
.text$mn:000011D3                 mov     eax, [ebp+arg_4]
.text$mn:000011D6                 push    eax
.text$mn:000011D7                 call    ??$forward@AAPAD@std@@YAAAPADAAPAD@Z ; std::forward<char * &>(char * &)
.text$mn:000011DC                 add     esp, 4
.text$mn:000011DF                 push    eax             ; int
.text$mn:000011E0                 mov     ecx, [ebp+arg_0]
.text$mn:000011E3                 push    ecx             ; void *
.text$mn:000011E4                 mov     edx, [ebp+var_4]
.text$mn:000011E7                 push    edx             ; int
.text$mn:000011E8                 call    ??$construct@PADAAPAD@?$allocator_traits@V?$allocator@D@std@@@std@@SAXAAV?$allocator@D@1@PAPADAAPAD@Z ; std::allocator_traits<std::allocator<char>>::construct<char *,char * &>(std::allocator<char> &,char * *,char * &)
.text$mn:000011ED                 add     esp, 0Ch
.text$mn:000011F0                 mov     esp, ebp
.text$mn:000011F2                 pop     ebp
.text$mn:000011F3                 retn    8
.text$mn:000011F3 ??$construct@PADAAPAD@?$_Wrap_alloc@V?$allocator@D@std@@@std@@QAEXPAPADAAPAD@Z endp
.text$mn:000011F3
.text$mn:000011F3 ; ---------------------------------------------------------------------------
.text$mn:000011F6                 align 4
.text$mn:000011F6 _text$mn        ends
.text$mn:000011F6
.text$mn:000011F8 ; ===========================================================================
.text$mn:000011F8
.text$mn:000011F8 ; Segment type: Pure code
.text$mn:000011F8 ; Segment permissions: Read/Execute
.text$mn:000011F8 _text$mn        segment para public 'CODE' use32
.text$mn:000011F8                 assume cs:_text$mn
.text$mn:000011F8                 ;org 11F8h
.text$mn:000011F8 ; COMDAT (pick any)
.text$mn:000011F8                 assume es:nothing, ss:nothing, ds:_data, fs:nothing, gs:nothing
.text$mn:000011F8
.text$mn:000011F8 ; =============== S U B R O U T I N E =======================================
.text$mn:000011F8
.text$mn:000011F8 ; Attributes: bp-based frame
.text$mn:000011F8
.text$mn:000011F8 ; int __stdcall std::allocator<char>::construct<char *,char * &>(void *, int)
.text$mn:000011F8                 public ??$construct@PADAAPAD@?$allocator@D@std@@QAEXPAPADAAPAD@Z
.text$mn:000011F8 ??$construct@PADAAPAD@?$allocator@D@std@@QAEXPAPADAAPAD@Z proc near
.text$mn:000011F8                                         ; CODE XREF: std::allocator_traits<std::allocator<char>>::construct<char *,char * &>(std::allocator<char> &,char * *,char * &)+17p
.text$mn:000011F8
.text$mn:000011F8 var_1C          = dword ptr -1Ch
.text$mn:000011F8 var_18          = dword ptr -18h
.text$mn:000011F8 var_14          = dword ptr -14h
.text$mn:000011F8 var_10          = dword ptr -10h
.text$mn:000011F8 var_C           = dword ptr -0Ch
.text$mn:000011F8 var_4           = dword ptr -4
.text$mn:000011F8 arg_0           = dword ptr  8
.text$mn:000011F8 arg_4           = dword ptr  0Ch
.text$mn:000011F8
.text$mn:000011F8                 push    ebp
.text$mn:000011F9                 mov     ebp, esp
.text$mn:000011FB                 push    0FFFFFFFFh
.text$mn:000011FD                 push    offset __ehhandler$??$construct@PADAAPAD@?$allocator@D@std@@QAEXPAPADAAPAD@Z
.text$mn:00001202                 mov     eax, large fs:0
.text$mn:00001208                 push    eax
.text$mn:00001209                 sub     esp, 10h
.text$mn:0000120C                 mov     eax, dword ptr ds:___security_cookie
.text$mn:00001211                 xor     eax, ebp
.text$mn:00001213                 push    eax
.text$mn:00001214                 lea     eax, [ebp+var_C]
.text$mn:00001217                 mov     large fs:0, eax
.text$mn:0000121D                 mov     [ebp+var_18], ecx
.text$mn:00001220                 mov     eax, [ebp+arg_0]
.text$mn:00001223                 push    eax             ; void *
.text$mn:00001224                 push    4               ; unsigned int
.text$mn:00001226                 call    ??2@YAPAXIPAX@Z ; operator new(uint,void *)
.text$mn:0000122B                 add     esp, 8
.text$mn:0000122E                 mov     [ebp+var_10], eax
.text$mn:00001231                 mov     [ebp+var_4], 0
.text$mn:00001238                 cmp     [ebp+var_10], 0
.text$mn:0000123C                 jz      short loc_1259
.text$mn:0000123E                 mov     ecx, [ebp+arg_4]
.text$mn:00001241                 push    ecx
.text$mn:00001242                 call    ??$forward@AAPAD@std@@YAAAPADAAPAD@Z ; std::forward<char * &>(char * &)
.text$mn:00001247                 add     esp, 4
.text$mn:0000124A                 mov     edx, [ebp+var_10]
.text$mn:0000124D                 mov     eax, [eax]
.text$mn:0000124F                 mov     [edx], eax
.text$mn:00001251                 mov     ecx, [ebp+var_10]
.text$mn:00001254                 mov     [ebp+var_14], ecx
.text$mn:00001257                 jmp     short loc_1260
.text$mn:00001259 ; ---------------------------------------------------------------------------
.text$mn:00001259
.text$mn:00001259 loc_1259:                               ; CODE XREF: std::allocator<char>::construct<char *,char * &>(char * *,char * &)+44j
.text$mn:00001259                 mov     [ebp+var_14], 0
.text$mn:00001260
.text$mn:00001260 loc_1260:                               ; CODE XREF: std::allocator<char>::construct<char *,char * &>(char * *,char * &)+5Fj
.text$mn:00001260                 mov     edx, [ebp+var_14]
.text$mn:00001263                 mov     [ebp+var_1C], edx
.text$mn:00001266                 mov     [ebp+var_4], 0FFFFFFFFh
.text$mn:0000126D                 mov     ecx, [ebp+var_C]
.text$mn:00001270                 mov     large fs:0, ecx
.text$mn:00001277                 pop     ecx
.text$mn:00001278                 mov     esp, ebp
.text$mn:0000127A                 pop     ebp
.text$mn:0000127B                 retn    8
.text$mn:0000127B ??$construct@PADAAPAD@?$allocator@D@std@@QAEXPAPADAAPAD@Z endp
.text$mn:0000127B
.text$mn:0000127B ; ---------------------------------------------------------------------------
.text$mn:0000127E                 align 10h
.text$mn:0000127E _text$mn        ends
.text$mn:0000127E
.text$x:00001280 ; ===========================================================================
.text$x:00001280
.text$x:00001280 ; Segment type: Pure code
.text$x:00001280 ; Segment permissions: Read/Execute
.text$x:00001280 _text$x         segment para public 'CODE' use32
.text$x:00001280                 assume cs:_text$x
.text$x:00001280                 ;org 1280h
.text$x:00001280 ; COMDAT (pick associative to section at 11F8)
.text$x:00001280                 assume es:nothing, ss:nothing, ds:_data, fs:nothing, gs:nothing
.text$x:00001280
.text$x:00001280 ; =============== S U B R O U T I N E =======================================
.text$x:00001280
.text$x:00001280
.text$x:00001280 __unwindfunclet$??$construct@PADAAPAD@?$allocator@D@std@@QAEXPAPADAAPAD@Z$0 proc near
.text$x:00001280                                         ; DATA XREF: .xdata$x:00002EE8o
.text$x:00001280                 mov     eax, [ebp+8]
.text$x:00001283                 push    eax
.text$x:00001284                 mov     eax, [ebp-10h]
.text$x:00001287                 push    eax             ; void *
.text$x:00001288                 call    ??3@YAXPAX0@Z   ; operator delete(void *,void *)
.text$x:0000128D                 add     esp, 8
.text$x:00001290                 retn
.text$x:00001290 __unwindfunclet$??$construct@PADAAPAD@?$allocator@D@std@@QAEXPAPADAAPAD@Z$0 endp
.text$x:00001290
.text$x:00001291
.text$x:00001291 ; =============== S U B R O U T I N E =======================================
.text$x:00001291
.text$x:00001291
.text$x:00001291 __ehhandler$??$construct@PADAAPAD@?$allocator@D@std@@QAEXPAPADAAPAD@Z proc near
.text$x:00001291                                         ; DATA XREF: std::allocator<char>::construct<char *,char * &>(char * *,char * &)+5o
.text$x:00001291
.text$x:00001291 arg_4           = dword ptr  8
.text$x:00001291
.text$x:00001291                 mov     edx, [esp+arg_4]
.text$x:00001295                 lea     eax, [edx+0Ch]
.text$x:00001298                 mov     ecx, [edx-14h]
.text$x:0000129B                 xor     ecx, eax
.text$x:0000129D                 call    @__security_check_cookie@4 ; __security_check_cookie(x)
.text$x:000012A2                 mov     eax, offset __ehfuncinfo$??$construct@PADAAPAD@?$allocator@D@std@@QAEXPAPADAAPAD@Z
.text$x:000012A7                 jmp     ___CxxFrameHandler3
.text$x:000012A7 __ehhandler$??$construct@PADAAPAD@?$allocator@D@std@@QAEXPAPADAAPAD@Z endp
.text$x:000012A7
.text$x:000012A7 _text$x         ends
.text$x:000012A7
.text$mn:000012AC ; ===========================================================================
.text$mn:000012AC
.text$mn:000012AC ; Segment type: Pure code
.text$mn:000012AC ; Segment permissions: Read/Execute
.text$mn:000012AC _text$mn        segment para public 'CODE' use32
.text$mn:000012AC                 assume cs:_text$mn
.text$mn:000012AC                 ;org 12ACh
.text$mn:000012AC ; COMDAT (pick any)
.text$mn:000012AC                 assume es:nothing, ss:nothing, ds:_data, fs:nothing, gs:nothing
.text$mn:000012AC
.text$mn:000012AC ; =============== S U B R O U T I N E =======================================
.text$mn:000012AC
.text$mn:000012AC ; Attributes: bp-based frame
.text$mn:000012AC
.text$mn:000012AC ; int __cdecl std::allocator_traits<std::allocator<char>>::construct<char *,char * &>(int, void *, int)
.text$mn:000012AC                 public ??$construct@PADAAPAD@?$allocator_traits@V?$allocator@D@std@@@std@@SAXAAV?$allocator@D@1@PAPADAAPAD@Z
.text$mn:000012AC ??$construct@PADAAPAD@?$allocator_traits@V?$allocator@D@std@@@std@@SAXAAV?$allocator@D@1@PAPADAAPAD@Z proc near
.text$mn:000012AC                                         ; CODE XREF: std::_Wrap_alloc<std::allocator<char>>::construct<char *,char * &>(char * *,char * &)+1Cp
.text$mn:000012AC
.text$mn:000012AC arg_0           = dword ptr  8
.text$mn:000012AC arg_4           = dword ptr  0Ch
.text$mn:000012AC arg_8           = dword ptr  10h
.text$mn:000012AC
.text$mn:000012AC                 push    ebp
.text$mn:000012AD                 mov     ebp, esp
.text$mn:000012AF                 mov     eax, [ebp+arg_8]
.text$mn:000012B2                 push    eax
.text$mn:000012B3                 call    ??$forward@AAPAD@std@@YAAAPADAAPAD@Z ; std::forward<char * &>(char * &)
.text$mn:000012B8                 add     esp, 4
.text$mn:000012BB                 push    eax             ; int
.text$mn:000012BC                 mov     ecx, [ebp+arg_4]
.text$mn:000012BF                 push    ecx             ; void *
.text$mn:000012C0                 mov     ecx, [ebp+arg_0]
.text$mn:000012C3                 call    ??$construct@PADAAPAD@?$allocator@D@std@@QAEXPAPADAAPAD@Z ; std::allocator<char>::construct<char *,char * &>(char * *,char * &)
.text$mn:000012C8                 pop     ebp
.text$mn:000012C9                 retn
.text$mn:000012C9 ??$construct@PADAAPAD@?$allocator_traits@V?$allocator@D@std@@@std@@SAXAAV?$allocator@D@1@PAPADAAPAD@Z endp
.text$mn:000012C9
.text$mn:000012C9 ; ---------------------------------------------------------------------------
.text$mn:000012CA                 align 4
.text$mn:000012CA _text$mn        ends
.text$mn:000012CA
.text$mn:000012CC ; ===========================================================================
.text$mn:000012CC
.text$mn:000012CC ; Segment type: Pure code
.text$mn:000012CC ; Segment permissions: Read/Execute
.text$mn:000012CC _text$mn        segment para public 'CODE' use32
.text$mn:000012CC                 assume cs:_text$mn
.text$mn:000012CC                 ;org 12CCh
.text$mn:000012CC ; COMDAT (pick any)
.text$mn:000012CC                 assume es:nothing, ss:nothing, ds:_data, fs:nothing, gs:nothing
.text$mn:000012CC
.text$mn:000012CC ; =============== S U B R O U T I N E =======================================
.text$mn:000012CC
.text$mn:000012CC ; Attributes: bp-based frame
.text$mn:000012CC
.text$mn:000012CC ; int __stdcall std::allocator<std::_Container_proxy>::construct<std::_Container_proxy,std::_Container_proxy>(void *, int)
.text$mn:000012CC                 public ??$construct@U_Container_proxy@std@@U12@@?$allocator@U_Container_proxy@std@@@std@@QAEXPAU_Container_proxy@1@$$QAU21@@Z
.text$mn:000012CC ??$construct@U_Container_proxy@std@@U12@@?$allocator@U_Container_proxy@std@@@std@@QAEXPAU_Container_proxy@1@$$QAU21@@Z proc near
.text$mn:000012CC                                         ; CODE XREF: std::_String_alloc<0,std::_String_base_types<char,std::allocator<char>>>::_Alloc_proxy(void)+32p
.text$mn:000012CC
.text$mn:000012CC var_1C          = dword ptr -1Ch
.text$mn:000012CC var_18          = dword ptr -18h
.text$mn:000012CC var_14          = dword ptr -14h
.text$mn:000012CC var_10          = dword ptr -10h
.text$mn:000012CC var_C           = dword ptr -0Ch
.text$mn:000012CC var_4           = dword ptr -4
.text$mn:000012CC arg_0           = dword ptr  8
.text$mn:000012CC arg_4           = dword ptr  0Ch
.text$mn:000012CC
.text$mn:000012CC                 push    ebp
.text$mn:000012CD                 mov     ebp, esp
.text$mn:000012CF                 push    0FFFFFFFFh
.text$mn:000012D1                 push    offset __ehhandler$??$construct@U_Container_proxy@std@@U12@@?$allocator@U_Container_proxy@std@@@std@@QAEXPAU_Container_proxy@1@$$QAU21@@Z
.text$mn:000012D6                 mov     eax, large fs:0
.text$mn:000012DC                 push    eax
.text$mn:000012DD                 sub     esp, 10h
.text$mn:000012E0                 mov     eax, dword ptr ds:___security_cookie
.text$mn:000012E5                 xor     eax, ebp
.text$mn:000012E7                 push    eax
.text$mn:000012E8                 lea     eax, [ebp+var_C]
.text$mn:000012EB                 mov     large fs:0, eax
.text$mn:000012F1                 mov     [ebp+var_18], ecx
.text$mn:000012F4                 mov     eax, [ebp+arg_0]
.text$mn:000012F7                 push    eax             ; void *
.text$mn:000012F8                 push    8               ; unsigned int
.text$mn:000012FA                 call    ??2@YAPAXIPAX@Z ; operator new(uint,void *)
.text$mn:000012FF                 add     esp, 8
.text$mn:00001302                 mov     [ebp+var_10], eax
.text$mn:00001305                 mov     [ebp+var_4], 0
.text$mn:0000130C                 cmp     [ebp+var_10], 0
.text$mn:00001310                 jz      short loc_1333
.text$mn:00001312                 mov     ecx, [ebp+arg_4]
.text$mn:00001315                 push    ecx
.text$mn:00001316                 call    ??$forward@U_Container_proxy@std@@@std@@YA$$QAU_Container_proxy@0@AAU10@@Z ; std::forward<std::_Container_proxy>(std::_Container_proxy &)
.text$mn:0000131B                 add     esp, 4
.text$mn:0000131E                 mov     edx, [eax]
.text$mn:00001320                 mov     eax, [eax+4]
.text$mn:00001323                 mov     ecx, [ebp+var_10]
.text$mn:00001326                 mov     [ecx], edx
.text$mn:00001328                 mov     [ecx+4], eax
.text$mn:0000132B                 mov     edx, [ebp+var_10]
.text$mn:0000132E                 mov     [ebp+var_14], edx
.text$mn:00001331                 jmp     short loc_133A
.text$mn:00001333 ; ---------------------------------------------------------------------------
.text$mn:00001333
.text$mn:00001333 loc_1333:                               ; CODE XREF: std::allocator<std::_Container_proxy>::construct<std::_Container_proxy,std::_Container_proxy>(std::_Container_proxy *,std::_Container_proxy &&)+44j
.text$mn:00001333                 mov     [ebp+var_14], 0
.text$mn:0000133A
.text$mn:0000133A loc_133A:                               ; CODE XREF: std::allocator<std::_Container_proxy>::construct<std::_Container_proxy,std::_Container_proxy>(std::_Container_proxy *,std::_Container_proxy &&)+65j
.text$mn:0000133A                 mov     eax, [ebp+var_14]
.text$mn:0000133D                 mov     [ebp+var_1C], eax
.text$mn:00001340                 mov     [ebp+var_4], 0FFFFFFFFh
.text$mn:00001347                 mov     ecx, [ebp+var_C]
.text$mn:0000134A                 mov     large fs:0, ecx
.text$mn:00001351                 pop     ecx
.text$mn:00001352                 mov     esp, ebp
.text$mn:00001354                 pop     ebp
.text$mn:00001355                 retn    8
.text$mn:00001355 ??$construct@U_Container_proxy@std@@U12@@?$allocator@U_Container_proxy@std@@@std@@QAEXPAU_Container_proxy@1@$$QAU21@@Z endp
.text$mn:00001355
.text$mn:00001355 _text$mn        ends
.text$mn:00001355
.text$x:00001358 ; ===========================================================================
.text$x:00001358
.text$x:00001358 ; Segment type: Pure code
.text$x:00001358 ; Segment permissions: Read/Execute
.text$x:00001358 _text$x         segment para public 'CODE' use32
.text$x:00001358                 assume cs:_text$x
.text$x:00001358                 ;org 1358h
.text$x:00001358 ; COMDAT (pick associative to section at 12CC)
.text$x:00001358                 assume es:nothing, ss:nothing, ds:_data, fs:nothing, gs:nothing
.text$x:00001358
.text$x:00001358 ; =============== S U B R O U T I N E =======================================
.text$x:00001358
.text$x:00001358
.text$x:00001358 __unwindfunclet$??$construct@U_Container_proxy@std@@U12@@?$allocator@U_Container_proxy@std@@@std@@QAEXPAU_Container_proxy@1@$$QAU21@@Z$0 proc near
.text$x:00001358                                         ; DATA XREF: .xdata$x:00002EBCo
.text$x:00001358                 mov     eax, [ebp+8]
.text$x:0000135B                 push    eax
.text$x:0000135C                 mov     eax, [ebp-10h]
.text$x:0000135F                 push    eax             ; void *
.text$x:00001360                 call    ??3@YAXPAX0@Z   ; operator delete(void *,void *)
.text$x:00001365                 add     esp, 8
.text$x:00001368                 retn
.text$x:00001368 __unwindfunclet$??$construct@U_Container_proxy@std@@U12@@?$allocator@U_Container_proxy@std@@@std@@QAEXPAU_Container_proxy@1@$$QAU21@@Z$0 endp
.text$x:00001368
.text$x:00001369
.text$x:00001369 ; =============== S U B R O U T I N E =======================================
.text$x:00001369
.text$x:00001369
.text$x:00001369 __ehhandler$??$construct@U_Container_proxy@std@@U12@@?$allocator@U_Container_proxy@std@@@std@@QAEXPAU_Container_proxy@1@$$QAU21@@Z proc near
.text$x:00001369                                         ; DATA XREF: std::allocator<std::_Container_proxy>::construct<std::_Container_proxy,std::_Container_proxy>(std::_Container_proxy *,std::_Container_proxy &&)+5o
.text$x:00001369
.text$x:00001369 arg_4           = dword ptr  8
.text$x:00001369
.text$x:00001369                 mov     edx, [esp+arg_4]
.text$x:0000136D                 lea     eax, [edx+0Ch]
.text$x:00001370                 mov     ecx, [edx-14h]
.text$x:00001373                 xor     ecx, eax
.text$x:00001375                 call    @__security_check_cookie@4 ; __security_check_cookie(x)
.text$x:0000137A                 mov     eax, offset __ehfuncinfo$??$construct@U_Container_proxy@std@@U12@@?$allocator@U_Container_proxy@std@@@std@@QAEXPAU_Container_proxy@1@$$QAU21@@Z
.text$x:0000137F                 jmp     ___CxxFrameHandler3
.text$x:0000137F __ehhandler$??$construct@U_Container_proxy@std@@U12@@?$allocator@U_Container_proxy@std@@@std@@QAEXPAU_Container_proxy@1@$$QAU21@@Z endp
.text$x:0000137F
.text$x:0000137F _text$x         ends
.text$x:0000137F
.text$mn:00001384 ; ===========================================================================
.text$mn:00001384
.text$mn:00001384 ; Segment type: Pure code
.text$mn:00001384 ; Segment permissions: Read/Execute
.text$mn:00001384 _text$mn        segment para public 'CODE' use32
.text$mn:00001384                 assume cs:_text$mn
.text$mn:00001384                 ;org 1384h
.text$mn:00001384 ; COMDAT (pick any)
.text$mn:00001384                 assume es:nothing, ss:nothing, ds:_data, fs:nothing, gs:nothing
.text$mn:00001384
.text$mn:00001384 ; =============== S U B R O U T I N E =======================================
.text$mn:00001384
.text$mn:00001384 ; Attributes: bp-based frame
.text$mn:00001384
.text$mn:00001384 ; public: void __thiscall std::_Wrap_alloc<class std::allocator<char>>::destroy<char *>(char * *)
.text$mn:00001384                 public ??$destroy@PAD@?$_Wrap_alloc@V?$allocator@D@std@@@std@@QAEXPAPAD@Z
.text$mn:00001384 ??$destroy@PAD@?$_Wrap_alloc@V?$allocator@D@std@@@std@@QAEXPAPAD@Z proc near
.text$mn:00001384                                         ; CODE XREF: std::basic_string<char,std::char_traits<char>,std::allocator<char>>::_Tidy(bool,uint)+3Ap
.text$mn:00001384
.text$mn:00001384 var_4           = dword ptr -4
.text$mn:00001384 arg_0           = dword ptr  8
.text$mn:00001384
.text$mn:00001384                 push    ebp
.text$mn:00001385                 mov     ebp, esp
.text$mn:00001387                 push    ecx
.text$mn:00001388                 mov     [ebp+var_4], ecx
.text$mn:0000138B                 mov     eax, [ebp+arg_0]
.text$mn:0000138E                 push    eax
.text$mn:0000138F                 mov     ecx, [ebp+var_4]
.text$mn:00001392                 push    ecx
.text$mn:00001393                 call    ??$destroy@PAD@?$allocator_traits@V?$allocator@D@std@@@std@@SAXAAV?$allocator@D@1@PAPAD@Z ; std::allocator_traits<std::allocator<char>>::destroy<char *>(std::allocator<char> &,char * *)
.text$mn:00001398                 add     esp, 8
.text$mn:0000139B                 mov     esp, ebp
.text$mn:0000139D                 pop     ebp
.text$mn:0000139E                 retn    4
.text$mn:0000139E ??$destroy@PAD@?$_Wrap_alloc@V?$allocator@D@std@@@std@@QAEXPAPAD@Z endp
.text$mn:0000139E
.text$mn:0000139E ; ---------------------------------------------------------------------------
.text$mn:000013A1                 align 4
.text$mn:000013A1 _text$mn        ends
.text$mn:000013A1
.text$mn:000013A4 ; ===========================================================================
.text$mn:000013A4
.text$mn:000013A4 ; Segment type: Pure code
.text$mn:000013A4 ; Segment permissions: Read/Execute
.text$mn:000013A4 _text$mn        segment para public 'CODE' use32
.text$mn:000013A4                 assume cs:_text$mn
.text$mn:000013A4                 ;org 13A4h
.text$mn:000013A4 ; COMDAT (pick any)
.text$mn:000013A4                 assume es:nothing, ss:nothing, ds:_data, fs:nothing, gs:nothing
.text$mn:000013A4
.text$mn:000013A4 ; =============== S U B R O U T I N E =======================================
.text$mn:000013A4
.text$mn:000013A4 ; Attributes: bp-based frame
.text$mn:000013A4
.text$mn:000013A4 ; public: void __thiscall std::allocator<char>::destroy<char *>(char * *)
.text$mn:000013A4                 public ??$destroy@PAD@?$allocator@D@std@@QAEXPAPAD@Z
.text$mn:000013A4 ??$destroy@PAD@?$allocator@D@std@@QAEXPAPAD@Z proc near
.text$mn:000013A4                                         ; CODE XREF: std::allocator_traits<std::allocator<char>>::destroy<char *>(std::allocator<char> &,char * *)+Ap
.text$mn:000013A4
.text$mn:000013A4 var_4           = dword ptr -4
.text$mn:000013A4
.text$mn:000013A4                 push    ebp
.text$mn:000013A5                 mov     ebp, esp
.text$mn:000013A7                 push    ecx
.text$mn:000013A8                 mov     [ebp+var_4], ecx
.text$mn:000013AB                 mov     esp, ebp
.text$mn:000013AD                 pop     ebp
.text$mn:000013AE                 retn    4
.text$mn:000013AE ??$destroy@PAD@?$allocator@D@std@@QAEXPAPAD@Z endp
.text$mn:000013AE
.text$mn:000013AE ; ---------------------------------------------------------------------------
.text$mn:000013B1                 align 4
.text$mn:000013B1 _text$mn        ends
.text$mn:000013B1
.text$mn:000013B4 ; ===========================================================================
.text$mn:000013B4
.text$mn:000013B4 ; Segment type: Pure code
.text$mn:000013B4 ; Segment permissions: Read/Execute
.text$mn:000013B4 _text$mn        segment para public 'CODE' use32
.text$mn:000013B4                 assume cs:_text$mn
.text$mn:000013B4                 ;org 13B4h
.text$mn:000013B4 ; COMDAT (pick any)
.text$mn:000013B4                 assume es:nothing, ss:nothing, ds:_data, fs:nothing, gs:nothing
.text$mn:000013B4
.text$mn:000013B4 ; =============== S U B R O U T I N E =======================================
.text$mn:000013B4
.text$mn:000013B4 ; Attributes: bp-based frame
.text$mn:000013B4
.text$mn:000013B4 ; public: static void __cdecl std::allocator_traits<class std::allocator<char>>::destroy<char *>(class std::allocator<char> &, char * *)
.text$mn:000013B4                 public ??$destroy@PAD@?$allocator_traits@V?$allocator@D@std@@@std@@SAXAAV?$allocator@D@1@PAPAD@Z
.text$mn:000013B4 ??$destroy@PAD@?$allocator_traits@V?$allocator@D@std@@@std@@SAXAAV?$allocator@D@1@PAPAD@Z proc near
.text$mn:000013B4                                         ; CODE XREF: std::_Wrap_alloc<std::allocator<char>>::destroy<char *>(char * *)+Fp
.text$mn:000013B4
.text$mn:000013B4 arg_0           = dword ptr  8
.text$mn:000013B4 arg_4           = dword ptr  0Ch
.text$mn:000013B4
.text$mn:000013B4                 push    ebp
.text$mn:000013B5                 mov     ebp, esp
.text$mn:000013B7                 mov     eax, [ebp+arg_4]
.text$mn:000013BA                 push    eax
.text$mn:000013BB                 mov     ecx, [ebp+arg_0]
.text$mn:000013BE                 call    ??$destroy@PAD@?$allocator@D@std@@QAEXPAPAD@Z ; std::allocator<char>::destroy<char *>(char * *)
.text$mn:000013C3                 pop     ebp
.text$mn:000013C4                 retn
.text$mn:000013C4 ??$destroy@PAD@?$allocator_traits@V?$allocator@D@std@@@std@@SAXAAV?$allocator@D@1@PAPAD@Z endp
.text$mn:000013C4
.text$mn:000013C4 ; ---------------------------------------------------------------------------
.text$mn:000013C5                 align 4
.text$mn:000013C5 _text$mn        ends
.text$mn:000013C5
.text$mn:000013C8 ; ===========================================================================
.text$mn:000013C8
.text$mn:000013C8 ; Segment type: Pure code
.text$mn:000013C8 ; Segment permissions: Read/Execute
.text$mn:000013C8 _text$mn        segment para public 'CODE' use32
.text$mn:000013C8                 assume cs:_text$mn
.text$mn:000013C8                 ;org 13C8h
.text$mn:000013C8 ; COMDAT (pick any)
.text$mn:000013C8                 assume es:nothing, ss:nothing, ds:_data, fs:nothing, gs:nothing
.text$mn:000013C8
.text$mn:000013C8 ; =============== S U B R O U T I N E =======================================
.text$mn:000013C8
.text$mn:000013C8 ; Attributes: bp-based frame
.text$mn:000013C8
.text$mn:000013C8 ; public: void __thiscall std::allocator<struct std::_Container_proxy>::destroy<struct std::_Container_proxy>(struct std::_Container_proxy *)
.text$mn:000013C8                 public ??$destroy@U_Container_proxy@std@@@?$allocator@U_Container_proxy@std@@@std@@QAEXPAU_Container_proxy@1@@Z
.text$mn:000013C8 ??$destroy@U_Container_proxy@std@@@?$allocator@U_Container_proxy@std@@@std@@QAEXPAU_Container_proxy@1@@Z proc near
.text$mn:000013C8                                         ; CODE XREF: std::_String_alloc<0,std::_String_base_types<char,std::allocator<char>>>::_Free_proxy(void)+22p
.text$mn:000013C8
.text$mn:000013C8 var_4           = dword ptr -4
.text$mn:000013C8
.text$mn:000013C8                 push    ebp
.text$mn:000013C9                 mov     ebp, esp
.text$mn:000013CB                 push    ecx
.text$mn:000013CC                 mov     [ebp+var_4], ecx
.text$mn:000013CF                 mov     esp, ebp
.text$mn:000013D1                 pop     ebp
.text$mn:000013D2                 retn    4
.text$mn:000013D2 ??$destroy@U_Container_proxy@std@@@?$allocator@U_Container_proxy@std@@@std@@QAEXPAU_Container_proxy@1@@Z endp
.text$mn:000013D2
.text$mn:000013D2 ; ---------------------------------------------------------------------------
.text$mn:000013D5                 align 4
.text$mn:000013D5 _text$mn        ends
.text$mn:000013D5
.text$mn:000013D8 ; ===========================================================================
.text$mn:000013D8
.text$mn:000013D8 ; Segment type: Pure code
.text$mn:000013D8 ; Segment permissions: Read/Execute
.text$mn:000013D8 _text$mn        segment para public 'CODE' use32
.text$mn:000013D8                 assume cs:_text$mn
.text$mn:000013D8                 ;org 13D8h
.text$mn:000013D8 ; COMDAT (pick any)
.text$mn:000013D8                 assume es:nothing, ss:nothing, ds:_data, fs:nothing, gs:nothing
.text$mn:000013D8
.text$mn:000013D8 ; =============== S U B R O U T I N E =======================================
.text$mn:000013D8
.text$mn:000013D8 ; Attributes: bp-based frame
.text$mn:000013D8
.text$mn:000013D8 ; char * & __cdecl std::forward<char * &>(char * &)
.text$mn:000013D8                 public ??$forward@AAPAD@std@@YAAAPADAAPAD@Z
.text$mn:000013D8 ??$forward@AAPAD@std@@YAAAPADAAPAD@Z proc near
.text$mn:000013D8                                         ; CODE XREF: std::_Wrap_alloc<std::allocator<char>>::construct<char *,char * &>(char * *,char * &)+Bp
.text$mn:000013D8                                         ; std::allocator<char>::construct<char *,char * &>(char * *,char * &)+4Ap ...
.text$mn:000013D8
.text$mn:000013D8 arg_0           = dword ptr  8
.text$mn:000013D8
.text$mn:000013D8                 push    ebp
.text$mn:000013D9                 mov     ebp, esp
.text$mn:000013DB                 mov     eax, [ebp+arg_0]
.text$mn:000013DE                 pop     ebp
.text$mn:000013DF                 retn
.text$mn:000013DF ??$forward@AAPAD@std@@YAAAPADAAPAD@Z endp
.text$mn:000013DF
.text$mn:000013DF _text$mn        ends
.text$mn:000013DF
.text$mn:000013E0 ; ===========================================================================
.text$mn:000013E0
.text$mn:000013E0 ; Segment type: Pure code
.text$mn:000013E0 ; Segment permissions: Read/Execute
.text$mn:000013E0 _text$mn        segment para public 'CODE' use32
.text$mn:000013E0                 assume cs:_text$mn
.text$mn:000013E0                 ;org 13E0h
.text$mn:000013E0 ; COMDAT (pick any)
.text$mn:000013E0                 assume es:nothing, ss:nothing, ds:_data, fs:nothing, gs:nothing
.text$mn:000013E0
.text$mn:000013E0 ; =============== S U B R O U T I N E =======================================
.text$mn:000013E0
.text$mn:000013E0 ; Attributes: bp-based frame
.text$mn:000013E0
.text$mn:000013E0 ; struct std::_Container_proxy && __cdecl std::forward<struct std::_Container_proxy>(struct std::_Container_proxy &)
.text$mn:000013E0                 public ??$forward@U_Container_proxy@std@@@std@@YA$$QAU_Container_proxy@0@AAU10@@Z
.text$mn:000013E0 ??$forward@U_Container_proxy@std@@@std@@YA$$QAU_Container_proxy@0@AAU10@@Z proc near
.text$mn:000013E0                                         ; CODE XREF: std::allocator<std::_Container_proxy>::construct<std::_Container_proxy,std::_Container_proxy>(std::_Container_proxy *,std::_Container_proxy &&)+4Ap
.text$mn:000013E0
.text$mn:000013E0 arg_0           = dword ptr  8
.text$mn:000013E0
.text$mn:000013E0                 push    ebp
.text$mn:000013E1                 mov     ebp, esp
.text$mn:000013E3                 mov     eax, [ebp+arg_0]
.text$mn:000013E6                 pop     ebp
.text$mn:000013E7                 retn
.text$mn:000013E7 ??$forward@U_Container_proxy@std@@@std@@YA$$QAU_Container_proxy@0@AAU10@@Z endp
.text$mn:000013E7
.text$mn:000013E7 _text$mn        ends
.text$mn:000013E7
.text$mn:000013E8 ; ===========================================================================
.text$mn:000013E8
.text$mn:000013E8 ; Segment type: Pure code
.text$mn:000013E8 ; Segment permissions: Read/Execute
.text$mn:000013E8 _text$mn        segment para public 'CODE' use32
.text$mn:000013E8                 assume cs:_text$mn
.text$mn:000013E8                 ;org 13E8h
.text$mn:000013E8 ; COMDAT (pick any)
.text$mn:000013E8                 assume es:nothing, ss:nothing, ds:_data, fs:nothing, gs:nothing
.text$mn:000013E8
.text$mn:000013E8 ; =============== S U B R O U T I N E =======================================
.text$mn:000013E8
.text$mn:000013E8 ; Attributes: bp-based frame
.text$mn:000013E8
.text$mn:000013E8 ; public: __thiscall std::_String_alloc<0, struct std::_String_base_types<char, class std::allocator<char>>>::_String_alloc<0, struct std::_String_base_types<char, class std::allocator<char>>>(class std::allocator<char> const &)
.text$mn:000013E8                 public ??0?$_String_alloc@$0A@U?$_String_base_types@DV?$allocator@D@std@@@std@@@std@@QAE@ABV?$allocator@D@1@@Z
.text$mn:000013E8 ??0?$_String_alloc@$0A@U?$_String_base_types@DV?$allocator@D@std@@@std@@@std@@QAE@ABV?$allocator@D@1@@Z proc near
.text$mn:000013E8                                         ; CODE XREF: std::basic_string<char,std::char_traits<char>,std::allocator<char>>::basic_string<char,std::char_traits<char>,std::allocator<char>>(char const *)+34p
.text$mn:000013E8
.text$mn:000013E8 var_10          = dword ptr -10h
.text$mn:000013E8 var_C           = dword ptr -0Ch
.text$mn:000013E8 var_4           = dword ptr -4
.text$mn:000013E8
.text$mn:000013E8                 push    ebp
.text$mn:000013E9                 mov     ebp, esp
.text$mn:000013EB                 push    0FFFFFFFFh
.text$mn:000013ED                 push    offset __ehhandler$??0?$_String_alloc@$0A@U?$_String_base_types@DV?$allocator@D@std@@@std@@@std@@QAE@ABV?$allocator@D@1@@Z
.text$mn:000013F2                 mov     eax, large fs:0
.text$mn:000013F8                 push    eax
.text$mn:000013F9                 push    ecx
.text$mn:000013FA                 mov     eax, dword ptr ds:___security_cookie
.text$mn:000013FF                 xor     eax, ebp
.text$mn:00001401                 push    eax
.text$mn:00001402                 lea     eax, [ebp+var_C]
.text$mn:00001405                 mov     large fs:0, eax
.text$mn:0000140B                 mov     [ebp+var_10], ecx
.text$mn:0000140E                 mov     ecx, [ebp+var_10]
.text$mn:00001411                 call    ??0?$_String_val@U?$_Simple_types@D@std@@@std@@QAE@XZ ; std::_String_val<std::_Simple_types<char>>::_String_val<std::_Simple_types<char>>(void)
.text$mn:00001416                 mov     [ebp+var_4], 0
.text$mn:0000141D                 mov     ecx, [ebp+var_10]
.text$mn:00001420                 call    ?_Alloc_proxy@?$_String_alloc@$0A@U?$_String_base_types@DV?$allocator@D@std@@@std@@@std@@QAEXXZ ; std::_String_alloc<0,std::_String_base_types<char,std::allocator<char>>>::_Alloc_proxy(void)
.text$mn:00001425                 mov     [ebp+var_4], 0FFFFFFFFh
.text$mn:0000142C                 mov     eax, [ebp+var_10]
.text$mn:0000142F                 mov     ecx, [ebp+var_C]
.text$mn:00001432                 mov     large fs:0, ecx
.text$mn:00001439                 pop     ecx
.text$mn:0000143A                 mov     esp, ebp
.text$mn:0000143C                 pop     ebp
.text$mn:0000143D                 retn    4
.text$mn:0000143D ??0?$_String_alloc@$0A@U?$_String_base_types@DV?$allocator@D@std@@@std@@@std@@QAE@ABV?$allocator@D@1@@Z endp
.text$mn:0000143D
.text$mn:0000143D _text$mn        ends
.text$mn:0000143D
.text$x:00001440 ; ===========================================================================
.text$x:00001440
.text$x:00001440 ; Segment type: Pure code
.text$x:00001440 ; Segment permissions: Read/Execute
.text$x:00001440 _text$x         segment para public 'CODE' use32
.text$x:00001440                 assume cs:_text$x
.text$x:00001440                 ;org 1440h
.text$x:00001440 ; COMDAT (pick associative to section at 13E8)
.text$x:00001440                 assume es:nothing, ss:nothing, ds:_data, fs:nothing, gs:nothing
.text$x:00001440
.text$x:00001440 ; =============== S U B R O U T I N E =======================================
.text$x:00001440
.text$x:00001440
.text$x:00001440 __unwindfunclet$??0?$_String_alloc@$0A@U?$_String_base_types@DV?$allocator@D@std@@@std@@@std@@QAE@ABV?$allocator@D@1@@Z$0 proc near
.text$x:00001440                                         ; DATA XREF: .xdata$x:00002BF4o
.text$x:00001440                 mov     ecx, [ebp-10h]
.text$x:00001443                 jmp     ??1?$_String_val@U?$_Simple_types@D@std@@@std@@QAE@XZ ; std::_String_val<std::_Simple_types<char>>::~_String_val<std::_Simple_types<char>>(void)
.text$x:00001443 __unwindfunclet$??0?$_String_alloc@$0A@U?$_String_base_types@DV?$allocator@D@std@@@std@@@std@@QAE@ABV?$allocator@D@1@@Z$0 endp
.text$x:00001443
.text$x:00001448
.text$x:00001448 ; =============== S U B R O U T I N E =======================================
.text$x:00001448
.text$x:00001448
.text$x:00001448 __ehhandler$??0?$_String_alloc@$0A@U?$_String_base_types@DV?$allocator@D@std@@@std@@@std@@QAE@ABV?$allocator@D@1@@Z proc near
.text$x:00001448                                         ; DATA XREF: std::_String_alloc<0,std::_String_base_types<char,std::allocator<char>>>::_String_alloc<0,std::_String_base_types<char,std::allocator<char>>>(std::allocator<char> const &)+5o
.text$x:00001448
.text$x:00001448 arg_4           = dword ptr  8
.text$x:00001448
.text$x:00001448                 mov     edx, [esp+arg_4]
.text$x:0000144C                 lea     eax, [edx+0Ch]
.text$x:0000144F                 mov     ecx, [edx-8]
.text$x:00001452                 xor     ecx, eax
.text$x:00001454                 call    @__security_check_cookie@4 ; __security_check_cookie(x)
.text$x:00001459                 mov     eax, offset __ehfuncinfo$??0?$_String_alloc@$0A@U?$_String_base_types@DV?$allocator@D@std@@@std@@@std@@QAE@ABV?$allocator@D@1@@Z
.text$x:0000145E                 jmp     ___CxxFrameHandler3
.text$x:0000145E __ehhandler$??0?$_String_alloc@$0A@U?$_String_base_types@DV?$allocator@D@std@@@std@@@std@@QAE@ABV?$allocator@D@1@@Z endp
.text$x:0000145E
.text$x:0000145E ; ---------------------------------------------------------------------------
.text$x:00001463                 align 4
.text$x:00001463 _text$x         ends
.text$x:00001463
.text$mn:00001464 ; ===========================================================================
.text$mn:00001464
.text$mn:00001464 ; Segment type: Pure code
.text$mn:00001464 ; Segment permissions: Read/Execute
.text$mn:00001464 _text$mn        segment para public 'CODE' use32
.text$mn:00001464                 assume cs:_text$mn
.text$mn:00001464                 ;org 1464h
.text$mn:00001464 ; COMDAT (pick any)
.text$mn:00001464                 assume es:nothing, ss:nothing, ds:_data, fs:nothing, gs:nothing
.text$mn:00001464
.text$mn:00001464 ; =============== S U B R O U T I N E =======================================
.text$mn:00001464
.text$mn:00001464 ; Attributes: bp-based frame
.text$mn:00001464
.text$mn:00001464 ; public: __thiscall std::_String_val<struct std::_Simple_types<char>>::_String_val<struct std::_Simple_types<char>>(void)
.text$mn:00001464                 public ??0?$_String_val@U?$_Simple_types@D@std@@@std@@QAE@XZ
.text$mn:00001464 ??0?$_String_val@U?$_Simple_types@D@std@@@std@@QAE@XZ proc near
.text$mn:00001464                                         ; CODE XREF: std::_String_alloc<0,std::_String_base_types<char,std::allocator<char>>>::_String_alloc<0,std::_String_base_types<char,std::allocator<char>>>(std::allocator<char> const &)+29p
.text$mn:00001464
.text$mn:00001464 var_10          = dword ptr -10h
.text$mn:00001464 var_C           = dword ptr -0Ch
.text$mn:00001464 var_4           = dword ptr -4
.text$mn:00001464
.text$mn:00001464                 push    ebp
.text$mn:00001465                 mov     ebp, esp
.text$mn:00001467                 push    0FFFFFFFFh
.text$mn:00001469                 push    offset __ehhandler$??0?$_String_val@U?$_Simple_types@D@std@@@std@@QAE@XZ
.text$mn:0000146E                 mov     eax, large fs:0
.text$mn:00001474                 push    eax
.text$mn:00001475                 push    ecx
.text$mn:00001476                 mov     eax, dword ptr ds:___security_cookie
.text$mn:0000147B                 xor     eax, ebp
.text$mn:0000147D                 push    eax
.text$mn:0000147E                 lea     eax, [ebp+var_C]
.text$mn:00001481                 mov     large fs:0, eax
.text$mn:00001487                 mov     [ebp+var_10], ecx
.text$mn:0000148A                 mov     ecx, [ebp+var_10] ; this
.text$mn:0000148D                 call    ??0_Container_base12@std@@QAE@XZ ; std::_Container_base12::_Container_base12(void)
.text$mn:00001492                 mov     [ebp+var_4], 0
.text$mn:00001499                 mov     eax, [ebp+var_10]
.text$mn:0000149C                 mov     dword ptr [eax+14h], 0
.text$mn:000014A3                 mov     ecx, [ebp+var_10]
.text$mn:000014A6                 mov     dword ptr [ecx+18h], 0
.text$mn:000014AD                 mov     [ebp+var_4], 0FFFFFFFFh
.text$mn:000014B4                 mov     eax, [ebp+var_10]
.text$mn:000014B7                 mov     ecx, [ebp+var_C]
.text$mn:000014BA                 mov     large fs:0, ecx
.text$mn:000014C1                 pop     ecx
.text$mn:000014C2                 mov     esp, ebp
.text$mn:000014C4                 pop     ebp
.text$mn:000014C5                 retn
.text$mn:000014C5 ??0?$_String_val@U?$_Simple_types@D@std@@@std@@QAE@XZ endp
.text$mn:000014C5
.text$mn:000014C5 ; ---------------------------------------------------------------------------
.text$mn:000014C6                 align 4
.text$mn:000014C6 _text$mn        ends
.text$mn:000014C6
.text$x:000014C8 ; ===========================================================================
.text$x:000014C8
.text$x:000014C8 ; Segment type: Pure code
.text$x:000014C8 ; Segment permissions: Read/Execute
.text$x:000014C8 _text$x         segment para public 'CODE' use32
.text$x:000014C8                 assume cs:_text$x
.text$x:000014C8                 ;org 14C8h
.text$x:000014C8 ; COMDAT (pick associative to section at 1464)
.text$x:000014C8                 assume es:nothing, ss:nothing, ds:_data, fs:nothing, gs:nothing
.text$x:000014C8
.text$x:000014C8 ; =============== S U B R O U T I N E =======================================
.text$x:000014C8
.text$x:000014C8
.text$x:000014C8 __unwindfunclet$??0?$_String_val@U?$_Simple_types@D@std@@@std@@QAE@XZ$0 proc near
.text$x:000014C8                                         ; DATA XREF: .xdata$x:00002B9Co
.text$x:000014C8                 mov     ecx, [ebp-10h]  ; this
.text$x:000014CB                 jmp     ??1_Container_base12@std@@QAE@XZ ; std::_Container_base12::~_Container_base12(void)
.text$x:000014CB __unwindfunclet$??0?$_String_val@U?$_Simple_types@D@std@@@std@@QAE@XZ$0 endp
.text$x:000014CB
.text$x:000014D0
.text$x:000014D0 ; =============== S U B R O U T I N E =======================================
.text$x:000014D0
.text$x:000014D0
.text$x:000014D0 __ehhandler$??0?$_String_val@U?$_Simple_types@D@std@@@std@@QAE@XZ proc near
.text$x:000014D0                                         ; DATA XREF: std::_String_val<std::_Simple_types<char>>::_String_val<std::_Simple_types<char>>(void)+5o
.text$x:000014D0
.text$x:000014D0 arg_4           = dword ptr  8
.text$x:000014D0
.text$x:000014D0                 mov     edx, [esp+arg_4]
.text$x:000014D4                 lea     eax, [edx+0Ch]
.text$x:000014D7                 mov     ecx, [edx-8]
.text$x:000014DA                 xor     ecx, eax
.text$x:000014DC                 call    @__security_check_cookie@4 ; __security_check_cookie(x)
.text$x:000014E1                 mov     eax, offset __ehfuncinfo$??0?$_String_val@U?$_Simple_types@D@std@@@std@@QAE@XZ
.text$x:000014E6                 jmp     ___CxxFrameHandler3
.text$x:000014E6 __ehhandler$??0?$_String_val@U?$_Simple_types@D@std@@@std@@QAE@XZ endp
.text$x:000014E6
.text$x:000014E6 ; ---------------------------------------------------------------------------
.text$x:000014EB                 align 4
.text$x:000014EB _text$x         ends
.text$x:000014EB
.text$mn:000014EC ; ===========================================================================
.text$mn:000014EC
.text$mn:000014EC ; Segment type: Pure code
.text$mn:000014EC ; Segment permissions: Read/Execute
.text$mn:000014EC _text$mn        segment para public 'CODE' use32
.text$mn:000014EC                 assume cs:_text$mn
.text$mn:000014EC                 ;org 14ECh
.text$mn:000014EC ; COMDAT (pick any)
.text$mn:000014EC                 assume es:nothing, ss:nothing, ds:_data, fs:nothing, gs:nothing
.text$mn:000014EC
.text$mn:000014EC ; =============== S U B R O U T I N E =======================================
.text$mn:000014EC
.text$mn:000014EC ; Attributes: bp-based frame
.text$mn:000014EC
.text$mn:000014EC ; public: __thiscall std::_Wrap_alloc<class std::allocator<char>>::_Wrap_alloc<class std::allocator<char>>(void)
.text$mn:000014EC                 public ??0?$_Wrap_alloc@V?$allocator@D@std@@@std@@QAE@XZ
.text$mn:000014EC ??0?$_Wrap_alloc@V?$allocator@D@std@@@std@@QAE@XZ proc near
.text$mn:000014EC                                         ; CODE XREF: std::_String_alloc<0,std::_String_base_types<char,std::allocator<char>>>::_Getal(void)+Ap
.text$mn:000014EC
.text$mn:000014EC var_4           = dword ptr -4
.text$mn:000014EC
.text$mn:000014EC                 push    ebp
.text$mn:000014ED                 mov     ebp, esp
.text$mn:000014EF                 push    ecx
.text$mn:000014F0                 mov     [ebp+var_4], ecx
.text$mn:000014F3                 mov     ecx, [ebp+var_4]
.text$mn:000014F6                 call    ??0?$allocator@D@std@@QAE@XZ ; std::allocator<char>::allocator<char>(void)
.text$mn:000014FB                 mov     eax, [ebp+var_4]
.text$mn:000014FE                 mov     esp, ebp
.text$mn:00001500                 pop     ebp
.text$mn:00001501                 retn
.text$mn:00001501 ??0?$_Wrap_alloc@V?$allocator@D@std@@@std@@QAE@XZ endp
.text$mn:00001501
.text$mn:00001501 ; ---------------------------------------------------------------------------
.text$mn:00001502                 align 4
.text$mn:00001502 _text$mn        ends
.text$mn:00001502
.text$mn:00001504 ; ===========================================================================
.text$mn:00001504
.text$mn:00001504 ; Segment type: Pure code
.text$mn:00001504 ; Segment permissions: Read/Execute
.text$mn:00001504 _text$mn        segment para public 'CODE' use32
.text$mn:00001504                 assume cs:_text$mn
.text$mn:00001504                 ;org 1504h
.text$mn:00001504 ; COMDAT (pick any)
.text$mn:00001504                 assume es:nothing, ss:nothing, ds:_data, fs:nothing, gs:nothing
.text$mn:00001504
.text$mn:00001504 ; =============== S U B R O U T I N E =======================================
.text$mn:00001504
.text$mn:00001504 ; Attributes: bp-based frame
.text$mn:00001504
.text$mn:00001504 ; public: __thiscall std::allocator<char>::allocator<char>(void)
.text$mn:00001504                 public ??0?$allocator@D@std@@QAE@XZ
.text$mn:00001504 ??0?$allocator@D@std@@QAE@XZ proc near  ; CODE XREF: std::_Wrap_alloc<std::allocator<char>>::_Wrap_alloc<std::allocator<char>>(void)+Ap
.text$mn:00001504                                         ; std::basic_string<char,std::char_traits<char>,std::allocator<char>>::basic_string<char,std::char_traits<char>,std::allocator<char>>(char const *)+2Bp
.text$mn:00001504
.text$mn:00001504 var_4           = dword ptr -4
.text$mn:00001504
.text$mn:00001504                 push    ebp
.text$mn:00001505                 mov     ebp, esp
.text$mn:00001507                 push    ecx
.text$mn:00001508                 mov     [ebp+var_4], ecx
.text$mn:0000150B                 mov     eax, [ebp+var_4]
.text$mn:0000150E                 mov     esp, ebp
.text$mn:00001510                 pop     ebp
.text$mn:00001511                 retn
.text$mn:00001511 ??0?$allocator@D@std@@QAE@XZ endp
.text$mn:00001511
.text$mn:00001511 ; ---------------------------------------------------------------------------
.text$mn:00001512                 align 4
.text$mn:00001512 _text$mn        ends
.text$mn:00001512
.text$mn:00001514 ; ===========================================================================
.text$mn:00001514
.text$mn:00001514 ; Segment type: Pure code
.text$mn:00001514 ; Segment permissions: Read/Execute
.text$mn:00001514 _text$mn        segment para public 'CODE' use32
.text$mn:00001514                 assume cs:_text$mn
.text$mn:00001514                 ;org 1514h
.text$mn:00001514 ; COMDAT (pick any)
.text$mn:00001514                 assume es:nothing, ss:nothing, ds:_data, fs:nothing, gs:nothing
.text$mn:00001514
.text$mn:00001514 ; =============== S U B R O U T I N E =======================================
.text$mn:00001514
.text$mn:00001514 ; Attributes: bp-based frame
.text$mn:00001514
.text$mn:00001514 ; public: __thiscall std::allocator<struct std::_Container_proxy>::allocator<struct std::_Container_proxy>(void)
.text$mn:00001514                 public ??0?$allocator@U_Container_proxy@std@@@std@@QAE@XZ
.text$mn:00001514 ??0?$allocator@U_Container_proxy@std@@@std@@QAE@XZ proc near
.text$mn:00001514                                         ; CODE XREF: std::_String_alloc<0,std::_String_base_types<char,std::allocator<char>>>::_Alloc_proxy(void)+Cp
.text$mn:00001514                                         ; std::_String_alloc<0,std::_String_base_types<char,std::allocator<char>>>::_Free_proxy(void)+Cp
.text$mn:00001514
.text$mn:00001514 var_4           = dword ptr -4
.text$mn:00001514
.text$mn:00001514                 push    ebp
.text$mn:00001515                 mov     ebp, esp
.text$mn:00001517                 push    ecx
.text$mn:00001518                 mov     [ebp+var_4], ecx
.text$mn:0000151B                 mov     eax, [ebp+var_4]
.text$mn:0000151E                 mov     esp, ebp
.text$mn:00001520                 pop     ebp
.text$mn:00001521                 retn
.text$mn:00001521 ??0?$allocator@U_Container_proxy@std@@@std@@QAE@XZ endp
.text$mn:00001521
.text$mn:00001521 ; ---------------------------------------------------------------------------
.text$mn:00001522                 align 4
.text$mn:00001522 _text$mn        ends
.text$mn:00001522
.text$mn:00001524 ; ===========================================================================
.text$mn:00001524
.text$mn:00001524 ; Segment type: Pure code
.text$mn:00001524 ; Segment permissions: Read/Execute
.text$mn:00001524 _text$mn        segment para public 'CODE' use32
.text$mn:00001524                 assume cs:_text$mn
.text$mn:00001524                 ;org 1524h
.text$mn:00001524 ; COMDAT (pick any)
.text$mn:00001524                 assume es:nothing, ss:nothing, ds:_data, fs:nothing, gs:nothing
.text$mn:00001524
.text$mn:00001524 ; =============== S U B R O U T I N E =======================================
.text$mn:00001524
.text$mn:00001524 ; Attributes: bp-based frame
.text$mn:00001524
.text$mn:00001524 ; int __stdcall std::basic_string<char,std::char_traits<char>,std::allocator<char>>::basic_string<char,std::char_traits<char>,std::allocator<char>>(char *Str)
.text$mn:00001524                 public ??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@PBD@Z
.text$mn:00001524 ??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@PBD@Z proc near
.text$mn:00001524                                         ; CODE XREF: std::_Generic_error_category::message(int)+5Ap
.text$mn:00001524                                         ; std::_Iostream_error_category::message(int)+3Dp ...
.text$mn:00001524
.text$mn:00001524 var_14          = dword ptr -14h
.text$mn:00001524 var_D           = byte ptr -0Dh
.text$mn:00001524 var_C           = dword ptr -0Ch
.text$mn:00001524 var_4           = dword ptr -4
.text$mn:00001524 Str             = dword ptr  8
.text$mn:00001524
.text$mn:00001524                 push    ebp
.text$mn:00001525                 mov     ebp, esp
.text$mn:00001527                 push    0FFFFFFFFh
.text$mn:00001529                 push    offset __ehhandler$??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@PBD@Z
.text$mn:0000152E                 mov     eax, large fs:0
.text$mn:00001534                 push    eax
.text$mn:00001535                 sub     esp, 8
.text$mn:00001538                 mov     eax, dword ptr ds:___security_cookie
.text$mn:0000153D                 xor     eax, ebp
.text$mn:0000153F                 push    eax
.text$mn:00001540                 lea     eax, [ebp+var_C]
.text$mn:00001543                 mov     large fs:0, eax
.text$mn:00001549                 mov     [ebp+var_14], ecx
.text$mn:0000154C                 lea     ecx, [ebp+var_D]
.text$mn:0000154F                 call    ??0?$allocator@D@std@@QAE@XZ ; std::allocator<char>::allocator<char>(void)
.text$mn:00001554                 push    eax
.text$mn:00001555                 mov     ecx, [ebp+var_14]
.text$mn:00001558                 call    ??0?$_String_alloc@$0A@U?$_String_base_types@DV?$allocator@D@std@@@std@@@std@@QAE@ABV?$allocator@D@1@@Z ; std::_String_alloc<0,std::_String_base_types<char,std::allocator<char>>>::_String_alloc<0,std::_String_base_types<char,std::allocator<char>>>(std::allocator<char> const &)
.text$mn:0000155D                 mov     [ebp+var_4], 0
.text$mn:00001564                 push    0               ; Size
.text$mn:00001566                 push    0               ; char
.text$mn:00001568                 mov     ecx, [ebp+var_14]
.text$mn:0000156B                 call    ?_Tidy@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEX_NI@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char>>::_Tidy(bool,uint)
.text$mn:00001570                 mov     eax, [ebp+Str]
.text$mn:00001573                 push    eax             ; Str
.text$mn:00001574                 mov     ecx, [ebp+var_14]
.text$mn:00001577                 call    ?assign@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV12@PBD@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char>>::assign(char const *)
.text$mn:0000157C                 mov     [ebp+var_4], 0FFFFFFFFh
.text$mn:00001583                 mov     eax, [ebp+var_14]
.text$mn:00001586                 mov     ecx, [ebp+var_C]
.text$mn:00001589                 mov     large fs:0, ecx
.text$mn:00001590                 pop     ecx
.text$mn:00001591                 mov     esp, ebp
.text$mn:00001593                 pop     ebp
.text$mn:00001594                 retn    4
.text$mn:00001594 ??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@PBD@Z endp
.text$mn:00001594
.text$mn:00001594 ; ---------------------------------------------------------------------------
.text$mn:00001597                 align 4
.text$mn:00001597 _text$mn        ends
.text$mn:00001597
.text$x:00001598 ; ===========================================================================
.text$x:00001598
.text$x:00001598 ; Segment type: Pure code
.text$x:00001598 ; Segment permissions: Read/Execute
.text$x:00001598 _text$x         segment para public 'CODE' use32
.text$x:00001598                 assume cs:_text$x
.text$x:00001598                 ;org 1598h
.text$x:00001598 ; COMDAT (pick associative to section at 1524)
.text$x:00001598                 assume es:nothing, ss:nothing, ds:_data, fs:nothing, gs:nothing
.text$x:00001598
.text$x:00001598 ; =============== S U B R O U T I N E =======================================
.text$x:00001598
.text$x:00001598
.text$x:00001598 __unwindfunclet$??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@PBD@Z$0 proc near
.text$x:00001598                                         ; DATA XREF: .xdata$x:00002C4Co
.text$x:00001598                 mov     ecx, [ebp-14h]
.text$x:0000159B                 jmp     ??1?$_String_alloc@$0A@U?$_String_base_types@DV?$allocator@D@std@@@std@@@std@@QAE@XZ ; std::_String_alloc<0,std::_String_base_types<char,std::allocator<char>>>::~_String_alloc<0,std::_String_base_types<char,std::allocator<char>>>(void)
.text$x:0000159B __unwindfunclet$??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@PBD@Z$0 endp
.text$x:0000159B
.text$x:000015A0
.text$x:000015A0 ; =============== S U B R O U T I N E =======================================
.text$x:000015A0
.text$x:000015A0
.text$x:000015A0 __ehhandler$??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@PBD@Z proc near
.text$x:000015A0                                         ; DATA XREF: std::basic_string<char,std::char_traits<char>,std::allocator<char>>::basic_string<char,std::char_traits<char>,std::allocator<char>>(char const *)+5o
.text$x:000015A0
.text$x:000015A0 arg_4           = dword ptr  8
.text$x:000015A0
.text$x:000015A0                 mov     edx, [esp+arg_4]
.text$x:000015A4                 lea     eax, [edx+0Ch]
.text$x:000015A7                 mov     ecx, [edx-0Ch]
.text$x:000015AA                 xor     ecx, eax
.text$x:000015AC                 call    @__security_check_cookie@4 ; __security_check_cookie(x)
.text$x:000015B1                 mov     eax, offset __ehfuncinfo$??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@PBD@Z
.text$x:000015B6                 jmp     ___CxxFrameHandler3
.text$x:000015B6 __ehhandler$??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@PBD@Z endp
.text$x:000015B6
.text$x:000015B6 ; ---------------------------------------------------------------------------
.text$x:000015BB                 align 4
.text$x:000015BB _text$x         ends
.text$x:000015BB
.text$mn:000015BC ; ===========================================================================
.text$mn:000015BC
.text$mn:000015BC ; Segment type: Pure code
.text$mn:000015BC ; Segment permissions: Read/Execute
.text$mn:000015BC _text$mn        segment para public 'CODE' use32
.text$mn:000015BC                 assume cs:_text$mn
.text$mn:000015BC                 ;org 15BCh
.text$mn:000015BC ; COMDAT (pick any)
.text$mn:000015BC                 assume es:nothing, ss:nothing, ds:_data, fs:nothing, gs:nothing
.text$mn:000015BC
.text$mn:000015BC ; =============== S U B R O U T I N E =======================================
.text$mn:000015BC
.text$mn:000015BC ; Attributes: bp-based frame
.text$mn:000015BC
.text$mn:000015BC ; _DWORD __thiscall std::_Container_base12::_Container_base12(std::_Container_base12 *__hidden this)
.text$mn:000015BC                 public ??0_Container_base12@std@@QAE@XZ
.text$mn:000015BC ??0_Container_base12@std@@QAE@XZ proc near
.text$mn:000015BC                                         ; CODE XREF: std::_String_val<std::_Simple_types<char>>::_String_val<std::_Simple_types<char>>(void)+29p
.text$mn:000015BC
.text$mn:000015BC var_4           = dword ptr -4
.text$mn:000015BC
.text$mn:000015BC                 push    ebp
.text$mn:000015BD                 mov     ebp, esp
.text$mn:000015BF                 push    ecx
.text$mn:000015C0                 mov     [ebp+var_4], ecx
.text$mn:000015C3                 mov     eax, [ebp+var_4]
.text$mn:000015C6                 mov     dword ptr [eax], 0
.text$mn:000015CC                 mov     eax, [ebp+var_4]
.text$mn:000015CF                 mov     esp, ebp
.text$mn:000015D1                 pop     ebp
.text$mn:000015D2                 retn
.text$mn:000015D2 ??0_Container_base12@std@@QAE@XZ endp
.text$mn:000015D2
.text$mn:000015D2 ; ---------------------------------------------------------------------------
.text$mn:000015D3                 align 4
.text$mn:000015D3 _text$mn        ends
.text$mn:000015D3
.text$mn:000015D4 ; ===========================================================================
.text$mn:000015D4
.text$mn:000015D4 ; Segment type: Pure code
.text$mn:000015D4 ; Segment permissions: Read/Execute
.text$mn:000015D4 _text$mn        segment para public 'CODE' use32
.text$mn:000015D4                 assume cs:_text$mn
.text$mn:000015D4                 ;org 15D4h
.text$mn:000015D4 ; COMDAT (pick any)
.text$mn:000015D4                 assume es:nothing, ss:nothing, ds:_data, fs:nothing, gs:nothing
.text$mn:000015D4
.text$mn:000015D4 ; =============== S U B R O U T I N E =======================================
.text$mn:000015D4
.text$mn:000015D4 ; Attributes: bp-based frame
.text$mn:000015D4
.text$mn:000015D4 ; _DWORD __thiscall std::_Container_proxy::_Container_proxy(std::_Container_proxy *__hidden this)
.text$mn:000015D4                 public ??0_Container_proxy@std@@QAE@XZ
.text$mn:000015D4 ??0_Container_proxy@std@@QAE@XZ proc near
.text$mn:000015D4                                         ; CODE XREF: std::_String_alloc<0,std::_String_base_types<char,std::allocator<char>>>::_Alloc_proxy(void)+23p
.text$mn:000015D4
.text$mn:000015D4 var_4           = dword ptr -4
.text$mn:000015D4
.text$mn:000015D4                 push    ebp
.text$mn:000015D5                 mov     ebp, esp
.text$mn:000015D7                 push    ecx
.text$mn:000015D8                 mov     [ebp+var_4], ecx
.text$mn:000015DB                 mov     eax, [ebp+var_4]
.text$mn:000015DE                 mov     dword ptr [eax], 0
.text$mn:000015E4                 mov     ecx, [ebp+var_4]
.text$mn:000015E7                 mov     dword ptr [ecx+4], 0
.text$mn:000015EE                 mov     eax, [ebp+var_4]
.text$mn:000015F1                 mov     esp, ebp
.text$mn:000015F3                 pop     ebp
.text$mn:000015F4                 retn
.text$mn:000015F4 ??0_Container_proxy@std@@QAE@XZ endp
.text$mn:000015F4
.text$mn:000015F4 ; ---------------------------------------------------------------------------
.text$mn:000015F5                 align 4
.text$mn:000015F5 _text$mn        ends
.text$mn:000015F5
.text$mn:000015F8 ; ===========================================================================
.text$mn:000015F8
.text$mn:000015F8 ; Segment type: Pure code
.text$mn:000015F8 ; Segment permissions: Read/Execute
.text$mn:000015F8 _text$mn        segment para public 'CODE' use32
.text$mn:000015F8                 assume cs:_text$mn
.text$mn:000015F8                 ;org 15F8h
.text$mn:000015F8 ; COMDAT (pick any)
.text$mn:000015F8                 assume es:nothing, ss:nothing, ds:_data, fs:nothing, gs:nothing
.text$mn:000015F8
.text$mn:000015F8 ; =============== S U B R O U T I N E =======================================
.text$mn:000015F8
.text$mn:000015F8 ; Attributes: bp-based frame
.text$mn:000015F8
.text$mn:000015F8 ; _DWORD __thiscall std::_Generic_error_category::_Generic_error_category(std::_Generic_error_category *__hidden this)
.text$mn:000015F8                 public ??0_Generic_error_category@std@@QAE@XZ
.text$mn:000015F8 ??0_Generic_error_category@std@@QAE@XZ proc near
.text$mn:000015F8                                         ; CODE XREF: std::_Iostream_error_category::_Iostream_error_category(void)+29p
.text$mn:000015F8                                         ; std::_System_error_category::_System_error_category(void)+29p ...
.text$mn:000015F8
.text$mn:000015F8 var_10          = dword ptr -10h
.text$mn:000015F8 var_C           = dword ptr -0Ch
.text$mn:000015F8 var_4           = dword ptr -4
.text$mn:000015F8
.text$mn:000015F8                 push    ebp
.text$mn:000015F9                 mov     ebp, esp
.text$mn:000015FB                 push    0FFFFFFFFh
.text$mn:000015FD                 push    offset __ehhandler$??0_Generic_error_category@std@@QAE@XZ
.text$mn:00001602                 mov     eax, large fs:0
.text$mn:00001608                 push    eax
.text$mn:00001609                 push    ecx
.text$mn:0000160A                 mov     eax, dword ptr ds:___security_cookie
.text$mn:0000160F                 xor     eax, ebp
.text$mn:00001611                 push    eax
.text$mn:00001612                 lea     eax, [ebp+var_C]
.text$mn:00001615                 mov     large fs:0, eax
.text$mn:0000161B                 mov     [ebp+var_10], ecx
.text$mn:0000161E                 mov     ecx, [ebp+var_10] ; this
.text$mn:00001621                 call    ??0error_category@std@@QAE@XZ ; std::error_category::error_category(void)
.text$mn:00001626                 mov     [ebp+var_4], 0
.text$mn:0000162D                 mov     eax, [ebp+var_10]
.text$mn:00001630                 mov     dword ptr [eax], offset ??_7_Generic_error_category@std@@6B@ ; const std::_Generic_error_category::`vftable'
.text$mn:00001636                 mov     [ebp+var_4], 0FFFFFFFFh
.text$mn:0000163D                 mov     eax, [ebp+var_10]
.text$mn:00001640                 mov     ecx, [ebp+var_C]
.text$mn:00001643                 mov     large fs:0, ecx
.text$mn:0000164A                 pop     ecx
.text$mn:0000164B                 mov     esp, ebp
.text$mn:0000164D                 pop     ebp
.text$mn:0000164E                 retn
.text$mn:0000164E ??0_Generic_error_category@std@@QAE@XZ endp
.text$mn:0000164E
.text$mn:0000164E ; ---------------------------------------------------------------------------
.text$mn:0000164F                 align 10h
.text$mn:0000164F _text$mn        ends
.text$mn:0000164F
.text$x:00001650 ; ===========================================================================
.text$x:00001650
.text$x:00001650 ; Segment type: Pure code
.text$x:00001650 ; Segment permissions: Read/Execute
.text$x:00001650 _text$x         segment para public 'CODE' use32
.text$x:00001650                 assume cs:_text$x
.text$x:00001650                 ;org 1650h
.text$x:00001650 ; COMDAT (pick associative to section at 15F8)
.text$x:00001650                 assume es:nothing, ss:nothing, ds:_data, fs:nothing, gs:nothing
.text$x:00001650
.text$x:00001650 ; =============== S U B R O U T I N E =======================================
.text$x:00001650
.text$x:00001650
.text$x:00001650 __unwindfunclet$??0_Generic_error_category@std@@QAE@XZ$0 proc near
.text$x:00001650                                         ; DATA XREF: .xdata$x:00002D30o
.text$x:00001650                 mov     ecx, [ebp-10h]  ; this
.text$x:00001653                 jmp     ??1error_category@std@@UAE@XZ ; std::error_category::~error_category(void)
.text$x:00001653 __unwindfunclet$??0_Generic_error_category@std@@QAE@XZ$0 endp
.text$x:00001653
.text$x:00001658
.text$x:00001658 ; =============== S U B R O U T I N E =======================================
.text$x:00001658
.text$x:00001658
.text$x:00001658 __ehhandler$??0_Generic_error_category@std@@QAE@XZ proc near
.text$x:00001658                                         ; DATA XREF: std::_Generic_error_category::_Generic_error_category(void)+5o
.text$x:00001658
.text$x:00001658 arg_4           = dword ptr  8
.text$x:00001658
.text$x:00001658                 mov     edx, [esp+arg_4]
.text$x:0000165C                 lea     eax, [edx+0Ch]
.text$x:0000165F                 mov     ecx, [edx-8]
.text$x:00001662                 xor     ecx, eax
.text$x:00001664                 call    @__security_check_cookie@4 ; __security_check_cookie(x)
.text$x:00001669                 mov     eax, offset __ehfuncinfo$??0_Generic_error_category@std@@QAE@XZ
.text$x:0000166E                 jmp     ___CxxFrameHandler3
.text$x:0000166E __ehhandler$??0_Generic_error_category@std@@QAE@XZ endp
.text$x:0000166E
.text$x:0000166E ; ---------------------------------------------------------------------------
.text$x:00001673                 align 4
.text$x:00001673 _text$x         ends
.text$x:00001673
.text$mn:00001674 ; ===========================================================================
.text$mn:00001674
.text$mn:00001674 ; Segment type: Pure code
.text$mn:00001674 ; Segment permissions: Read/Execute
.text$mn:00001674 _text$mn        segment para public 'CODE' use32
.text$mn:00001674                 assume cs:_text$mn
.text$mn:00001674                 ;org 1674h
.text$mn:00001674 ; COMDAT (pick any)
.text$mn:00001674                 assume es:nothing, ss:nothing, ds:_data, fs:nothing, gs:nothing
.text$mn:00001674
.text$mn:00001674 ; =============== S U B R O U T I N E =======================================
.text$mn:00001674
.text$mn:00001674 ; Attributes: bp-based frame
.text$mn:00001674
.text$mn:00001674 ; _DWORD __thiscall std::_Ignore::_Ignore(std::_Ignore *__hidden this)
.text$mn:00001674                 public ??0_Ignore@std@@QAE@XZ
.text$mn:00001674 ??0_Ignore@std@@QAE@XZ proc near        ; CODE XREF: std::`dynamic initializer for 'ignore''(void)+8p
.text$mn:00001674
.text$mn:00001674 var_4           = dword ptr -4
.text$mn:00001674
.text$mn:00001674                 push    ebp
.text$mn:00001675                 mov     ebp, esp
.text$mn:00001677                 push    ecx
.text$mn:00001678                 mov     [ebp+var_4], ecx
.text$mn:0000167B                 mov     eax, [ebp+var_4]
.text$mn:0000167E                 mov     esp, ebp
.text$mn:00001680                 pop     ebp
.text$mn:00001681                 retn
.text$mn:00001681 ??0_Ignore@std@@QAE@XZ endp
.text$mn:00001681
.text$mn:00001681 ; ---------------------------------------------------------------------------
.text$mn:00001682                 align 4
.text$mn:00001682 _text$mn        ends
.text$mn:00001682
.text$mn:00001684 ; ===========================================================================
.text$mn:00001684
.text$mn:00001684 ; Segment type: Pure code
.text$mn:00001684 ; Segment permissions: Read/Execute
.text$mn:00001684 _text$mn        segment para public 'CODE' use32
.text$mn:00001684                 assume cs:_text$mn
.text$mn:00001684                 ;org 1684h
.text$mn:00001684 ; COMDAT (pick any)
.text$mn:00001684                 assume es:nothing, ss:nothing, ds:_data, fs:nothing, gs:nothing
.text$mn:00001684
.text$mn:00001684 ; =============== S U B R O U T I N E =======================================
.text$mn:00001684
.text$mn:00001684 ; Attributes: bp-based frame
.text$mn:00001684
.text$mn:00001684 ; _DWORD __thiscall std::_Iostream_error_category::_Iostream_error_category(std::_Iostream_error_category *__hidden this)
.text$mn:00001684                 public ??0_Iostream_error_category@std@@QAE@XZ
.text$mn:00001684 ??0_Iostream_error_category@std@@QAE@XZ proc near
.text$mn:00001684                                         ; CODE XREF: `dynamic initializer for 'std::_Iostream_error_category std::_Error_objects<int>::_Iostream_object''(void)+8p
.text$mn:00001684
.text$mn:00001684 var_10          = dword ptr -10h
.text$mn:00001684 var_C           = dword ptr -0Ch
.text$mn:00001684 var_4           = dword ptr -4
.text$mn:00001684
.text$mn:00001684                 push    ebp
.text$mn:00001685                 mov     ebp, esp
.text$mn:00001687                 push    0FFFFFFFFh
.text$mn:00001689                 push    offset __ehhandler$??0_Iostream_error_category@std@@QAE@XZ
.text$mn:0000168E                 mov     eax, large fs:0
.text$mn:00001694                 push    eax
.text$mn:00001695                 push    ecx
.text$mn:00001696                 mov     eax, dword ptr ds:___security_cookie
.text$mn:0000169B                 xor     eax, ebp
.text$mn:0000169D                 push    eax
.text$mn:0000169E                 lea     eax, [ebp+var_C]
.text$mn:000016A1                 mov     large fs:0, eax
.text$mn:000016A7                 mov     [ebp+var_10], ecx
.text$mn:000016AA                 mov     ecx, [ebp+var_10] ; this
.text$mn:000016AD                 call    ??0_Generic_error_category@std@@QAE@XZ ; std::_Generic_error_category::_Generic_error_category(void)
.text$mn:000016B2                 mov     [ebp+var_4], 0
.text$mn:000016B9                 mov     eax, [ebp+var_10]
.text$mn:000016BC                 mov     dword ptr [eax], offset ??_7_Iostream_error_category@std@@6B@ ; const std::_Iostream_error_category::`vftable'
.text$mn:000016C2                 mov     [ebp+var_4], 0FFFFFFFFh
.text$mn:000016C9                 mov     eax, [ebp+var_10]
.text$mn:000016CC                 mov     ecx, [ebp+var_C]
.text$mn:000016CF                 mov     large fs:0, ecx
.text$mn:000016D6                 pop     ecx
.text$mn:000016D7                 mov     esp, ebp
.text$mn:000016D9                 pop     ebp
.text$mn:000016DA                 retn
.text$mn:000016DA ??0_Iostream_error_category@std@@QAE@XZ endp
.text$mn:000016DA
.text$mn:000016DA ; ---------------------------------------------------------------------------
.text$mn:000016DB                 align 4
.text$mn:000016DB _text$mn        ends
.text$mn:000016DB
.text$x:000016DC ; ===========================================================================
.text$x:000016DC
.text$x:000016DC ; Segment type: Pure code
.text$x:000016DC ; Segment permissions: Read/Execute
.text$x:000016DC _text$x         segment para public 'CODE' use32
.text$x:000016DC                 assume cs:_text$x
.text$x:000016DC                 ;org 16DCh
.text$x:000016DC ; COMDAT (pick associative to section at 1684)
.text$x:000016DC                 assume es:nothing, ss:nothing, ds:_data, fs:nothing, gs:nothing
.text$x:000016DC
.text$x:000016DC ; =============== S U B R O U T I N E =======================================
.text$x:000016DC
.text$x:000016DC
.text$x:000016DC __unwindfunclet$??0_Iostream_error_category@std@@QAE@XZ$0 proc near
.text$x:000016DC                                         ; DATA XREF: .xdata$x:00002DB4o
.text$x:000016DC                 mov     ecx, [ebp-10h]  ; this
.text$x:000016DF                 jmp     ??1_Generic_error_category@std@@UAE@XZ ; std::_Generic_error_category::~_Generic_error_category(void)
.text$x:000016DF __unwindfunclet$??0_Iostream_error_category@std@@QAE@XZ$0 endp
.text$x:000016DF
.text$x:000016E4
.text$x:000016E4 ; =============== S U B R O U T I N E =======================================
.text$x:000016E4
.text$x:000016E4
.text$x:000016E4 __ehhandler$??0_Iostream_error_category@std@@QAE@XZ proc near
.text$x:000016E4                                         ; DATA XREF: std::_Iostream_error_category::_Iostream_error_category(void)+5o
.text$x:000016E4
.text$x:000016E4 arg_4           = dword ptr  8
.text$x:000016E4
.text$x:000016E4                 mov     edx, [esp+arg_4]
.text$x:000016E8                 lea     eax, [edx+0Ch]
.text$x:000016EB                 mov     ecx, [edx-8]
.text$x:000016EE                 xor     ecx, eax
.text$x:000016F0                 call    @__security_check_cookie@4 ; __security_check_cookie(x)
.text$x:000016F5                 mov     eax, offset __ehfuncinfo$??0_Iostream_error_category@std@@QAE@XZ
.text$x:000016FA                 jmp     ___CxxFrameHandler3
.text$x:000016FA __ehhandler$??0_Iostream_error_category@std@@QAE@XZ endp
.text$x:000016FA
.text$x:000016FA ; ---------------------------------------------------------------------------
.text$x:000016FF                 align 10h
.text$x:000016FF _text$x         ends
.text$x:000016FF
.text$mn:00001700 ; ===========================================================================
.text$mn:00001700
.text$mn:00001700 ; Segment type: Pure code
.text$mn:00001700 ; Segment permissions: Read/Execute
.text$mn:00001700 _text$mn        segment para public 'CODE' use32
.text$mn:00001700                 assume cs:_text$mn
.text$mn:00001700                 ;org 1700h
.text$mn:00001700 ; COMDAT (pick any)
.text$mn:00001700                 assume es:nothing, ss:nothing, ds:_data, fs:nothing, gs:nothing
.text$mn:00001700
.text$mn:00001700 ; =============== S U B R O U T I N E =======================================
.text$mn:00001700
.text$mn:00001700 ; Attributes: bp-based frame
.text$mn:00001700
.text$mn:00001700 ; _DWORD __thiscall std::_System_error_category::_System_error_category(std::_System_error_category *__hidden this)
.text$mn:00001700                 public ??0_System_error_category@std@@QAE@XZ
.text$mn:00001700 ??0_System_error_category@std@@QAE@XZ proc near
.text$mn:00001700                                         ; CODE XREF: `dynamic initializer for 'std::_System_error_category std::_Error_objects<int>::_System_object''(void)+8p
.text$mn:00001700
.text$mn:00001700 var_10          = dword ptr -10h
.text$mn:00001700 var_C           = dword ptr -0Ch
.text$mn:00001700 var_4           = dword ptr -4
.text$mn:00001700
.text$mn:00001700                 push    ebp
.text$mn:00001701                 mov     ebp, esp
.text$mn:00001703                 push    0FFFFFFFFh
.text$mn:00001705                 push    offset __ehhandler$??0_System_error_category@std@@QAE@XZ
.text$mn:0000170A                 mov     eax, large fs:0
.text$mn:00001710                 push    eax
.text$mn:00001711                 push    ecx
.text$mn:00001712                 mov     eax, dword ptr ds:___security_cookie
.text$mn:00001717                 xor     eax, ebp
.text$mn:00001719                 push    eax
.text$mn:0000171A                 lea     eax, [ebp+var_C]
.text$mn:0000171D                 mov     large fs:0, eax
.text$mn:00001723                 mov     [ebp+var_10], ecx
.text$mn:00001726                 mov     ecx, [ebp+var_10] ; this
.text$mn:00001729                 call    ??0_Generic_error_category@std@@QAE@XZ ; std::_Generic_error_category::_Generic_error_category(void)
.text$mn:0000172E                 mov     [ebp+var_4], 0
.text$mn:00001735                 mov     eax, [ebp+var_10]
.text$mn:00001738                 mov     dword ptr [eax], offset ??_7_System_error_category@std@@6B@ ; const std::_System_error_category::`vftable'
.text$mn:0000173E                 mov     [ebp+var_4], 0FFFFFFFFh
.text$mn:00001745                 mov     eax, [ebp+var_10]
.text$mn:00001748                 mov     ecx, [ebp+var_C]
.text$mn:0000174B                 mov     large fs:0, ecx
.text$mn:00001752                 pop     ecx
.text$mn:00001753                 mov     esp, ebp
.text$mn:00001755                 pop     ebp
.text$mn:00001756                 retn
.text$mn:00001756 ??0_System_error_category@std@@QAE@XZ endp
.text$mn:00001756
.text$mn:00001756 ; ---------------------------------------------------------------------------
.text$mn:00001757                 align 4
.text$mn:00001757 _text$mn        ends
.text$mn:00001757
.text$x:00001758 ; ===========================================================================
.text$x:00001758
.text$x:00001758 ; Segment type: Pure code
.text$x:00001758 ; Segment permissions: Read/Execute
.text$x:00001758 _text$x         segment para public 'CODE' use32
.text$x:00001758                 assume cs:_text$x
.text$x:00001758                 ;org 1758h
.text$x:00001758 ; COMDAT (pick associative to section at 1700)
.text$x:00001758                 assume es:nothing, ss:nothing, ds:_data, fs:nothing, gs:nothing
.text$x:00001758
.text$x:00001758 ; =============== S U B R O U T I N E =======================================
.text$x:00001758
.text$x:00001758
.text$x:00001758 __unwindfunclet$??0_System_error_category@std@@QAE@XZ$0 proc near
.text$x:00001758                                         ; DATA XREF: .xdata$x:00002E38o
.text$x:00001758                 mov     ecx, [ebp-10h]  ; this
.text$x:0000175B                 jmp     ??1_Generic_error_category@std@@UAE@XZ ; std::_Generic_error_category::~_Generic_error_category(void)
.text$x:0000175B __unwindfunclet$??0_System_error_category@std@@QAE@XZ$0 endp
.text$x:0000175B
.text$x:00001760
.text$x:00001760 ; =============== S U B R O U T I N E =======================================
.text$x:00001760
.text$x:00001760
.text$x:00001760 __ehhandler$??0_System_error_category@std@@QAE@XZ proc near
.text$x:00001760                                         ; DATA XREF: std::_System_error_category::_System_error_category(void)+5o
.text$x:00001760
.text$x:00001760 arg_4           = dword ptr  8
.text$x:00001760
.text$x:00001760                 mov     edx, [esp+arg_4]
.text$x:00001764                 lea     eax, [edx+0Ch]
.text$x:00001767                 mov     ecx, [edx-8]
.text$x:0000176A                 xor     ecx, eax
.text$x:0000176C                 call    @__security_check_cookie@4 ; __security_check_cookie(x)
.text$x:00001771                 mov     eax, offset __ehfuncinfo$??0_System_error_category@std@@QAE@XZ
.text$x:00001776                 jmp     ___CxxFrameHandler3
.text$x:00001776 __ehhandler$??0_System_error_category@std@@QAE@XZ endp
.text$x:00001776
.text$x:00001776 ; ---------------------------------------------------------------------------
.text$x:0000177B                 align 4
.text$x:0000177B _text$x         ends
.text$x:0000177B
.text$mn:0000177C ; ===========================================================================
.text$mn:0000177C
.text$mn:0000177C ; Segment type: Pure code
.text$mn:0000177C ; Segment permissions: Read/Execute
.text$mn:0000177C _text$mn        segment para public 'CODE' use32
.text$mn:0000177C                 assume cs:_text$mn
.text$mn:0000177C                 ;org 177Ch
.text$mn:0000177C ; COMDAT (pick any)
.text$mn:0000177C                 assume es:nothing, ss:nothing, ds:_data, fs:nothing, gs:nothing
.text$mn:0000177C
.text$mn:0000177C ; =============== S U B R O U T I N E =======================================
.text$mn:0000177C
.text$mn:0000177C ; Attributes: bp-based frame
.text$mn:0000177C
.text$mn:0000177C ; _DWORD __thiscall std::error_category::error_category(std::error_category *__hidden this)
.text$mn:0000177C                 public ??0error_category@std@@QAE@XZ
.text$mn:0000177C ??0error_category@std@@QAE@XZ proc near ; CODE XREF: std::_Generic_error_category::_Generic_error_category(void)+29p
.text$mn:0000177C
.text$mn:0000177C var_4           = dword ptr -4
.text$mn:0000177C
.text$mn:0000177C                 push    ebp
.text$mn:0000177D                 mov     ebp, esp
.text$mn:0000177F                 push    ecx
.text$mn:00001780                 mov     [ebp+var_4], ecx
.text$mn:00001783                 mov     eax, [ebp+var_4]
.text$mn:00001786                 mov     dword ptr [eax], offset ??_7error_category@std@@6B@ ; const std::error_category::`vftable'
.text$mn:0000178C                 mov     eax, [ebp+var_4]
.text$mn:0000178F                 mov     esp, ebp
.text$mn:00001791                 pop     ebp
.text$mn:00001792                 retn
.text$mn:00001792 ??0error_category@std@@QAE@XZ endp
.text$mn:00001792
.text$mn:00001792 ; ---------------------------------------------------------------------------
.text$mn:00001793                 align 4
.text$mn:00001793 _text$mn        ends
.text$mn:00001793
.text$mn:00001794 ; ===========================================================================
.text$mn:00001794
.text$mn:00001794 ; Segment type: Pure code
.text$mn:00001794 ; Segment permissions: Read/Execute
.text$mn:00001794 _text$mn        segment para public 'CODE' use32
.text$mn:00001794                 assume cs:_text$mn
.text$mn:00001794                 ;org 1794h
.text$mn:00001794 ; COMDAT (pick any)
.text$mn:00001794                 assume es:nothing, ss:nothing, ds:_data, fs:nothing, gs:nothing
.text$mn:00001794
.text$mn:00001794 ; =============== S U B R O U T I N E =======================================
.text$mn:00001794
.text$mn:00001794 ; Attributes: bp-based frame
.text$mn:00001794
.text$mn:00001794 ; _DWORD __thiscall std::error_condition::error_condition(std::error_condition *this, int, const struct std::error_category *)
.text$mn:00001794                 public ??0error_condition@std@@QAE@HABVerror_category@1@@Z
.text$mn:00001794 ??0error_condition@std@@QAE@HABVerror_category@1@@Z proc near
.text$mn:00001794                                         ; CODE XREF: std::_System_error_category::default_error_condition(int)+24p
.text$mn:00001794                                         ; std::_System_error_category::default_error_condition(int)+3Dp ...
.text$mn:00001794
.text$mn:00001794 var_4           = dword ptr -4
.text$mn:00001794 arg_0           = dword ptr  8
.text$mn:00001794 arg_4           = dword ptr  0Ch
.text$mn:00001794
.text$mn:00001794                 push    ebp
.text$mn:00001795                 mov     ebp, esp
.text$mn:00001797                 push    ecx
.text$mn:00001798                 mov     [ebp+var_4], ecx
.text$mn:0000179B                 mov     eax, [ebp+var_4]
.text$mn:0000179E                 mov     ecx, [ebp+arg_0]
.text$mn:000017A1                 mov     [eax], ecx
.text$mn:000017A3                 mov     edx, [ebp+var_4]
.text$mn:000017A6                 mov     eax, [ebp+arg_4]
.text$mn:000017A9                 mov     [edx+4], eax
.text$mn:000017AC                 mov     eax, [ebp+var_4]
.text$mn:000017AF                 mov     esp, ebp
.text$mn:000017B1                 pop     ebp
.text$mn:000017B2                 retn    8
.text$mn:000017B2 ??0error_condition@std@@QAE@HABVerror_category@1@@Z endp
.text$mn:000017B2
.text$mn:000017B2 ; ---------------------------------------------------------------------------
.text$mn:000017B5                 align 4
.text$mn:000017B5 _text$mn        ends
.text$mn:000017B5
.text$mn:000017B8 ; ===========================================================================
.text$mn:000017B8
.text$mn:000017B8 ; Segment type: Pure code
.text$mn:000017B8 ; Segment permissions: Read/Execute
.text$mn:000017B8 _text$mn        segment para public 'CODE' use32
.text$mn:000017B8                 assume cs:_text$mn
.text$mn:000017B8                 ;org 17B8h
.text$mn:000017B8 ; COMDAT (pick any)
.text$mn:000017B8                 assume es:nothing, ss:nothing, ds:_data, fs:nothing, gs:nothing
.text$mn:000017B8
.text$mn:000017B8 ; =============== S U B R O U T I N E =======================================
.text$mn:000017B8
.text$mn:000017B8 ; Attributes: bp-based frame
.text$mn:000017B8
.text$mn:000017B8 ; _DWORD __thiscall std::locale::id::id(std::locale::id *this, unsigned int)
.text$mn:000017B8                 public ??0id@locale@std@@QAE@I@Z
.text$mn:000017B8 ??0id@locale@std@@QAE@I@Z proc near     ; CODE XREF: `dynamic initializer for 'std::locale::id std::num_put<char,std::back_insert_iterator<std::basic_string<char,std::char_traits<char>,std::allocator<char>>>>::id''(void)+Ap
.text$mn:000017B8                                         ; `dynamic initializer for 'std::locale::id std::num_put<wchar_t,std::back_insert_iterator<std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>>>>::id''(void)+Ap ...
.text$mn:000017B8
.text$mn:000017B8 var_4           = dword ptr -4
.text$mn:000017B8 arg_0           = dword ptr  8
.text$mn:000017B8
.text$mn:000017B8                 push    ebp
.text$mn:000017B9                 mov     ebp, esp
.text$mn:000017BB                 push    ecx
.text$mn:000017BC                 mov     [ebp+var_4], ecx
.text$mn:000017BF                 mov     eax, [ebp+var_4]
.text$mn:000017C2                 mov     ecx, [ebp+arg_0]
.text$mn:000017C5                 mov     [eax], ecx
.text$mn:000017C7                 mov     eax, [ebp+var_4]
.text$mn:000017CA                 mov     esp, ebp
.text$mn:000017CC                 pop     ebp
.text$mn:000017CD                 retn    4
.text$mn:000017CD ??0id@locale@std@@QAE@I@Z endp
.text$mn:000017CD
.text$mn:000017CD _text$mn        ends
.text$mn:000017CD
.text$mn:000017D0 ; ===========================================================================
.text$mn:000017D0
.text$mn:000017D0 ; Segment type: Pure code
.text$mn:000017D0 ; Segment permissions: Read/Execute
.text$mn:000017D0 _text$mn        segment para public 'CODE' use32
.text$mn:000017D0                 assume cs:_text$mn
.text$mn:000017D0                 ;org 17D0h
.text$mn:000017D0 ; COMDAT (pick any)
.text$mn:000017D0                 assume es:nothing, ss:nothing, ds:_data, fs:nothing, gs:nothing
.text$mn:000017D0
.text$mn:000017D0 ; =============== S U B R O U T I N E =======================================
.text$mn:000017D0
.text$mn:000017D0 ; Attributes: bp-based frame
.text$mn:000017D0
.text$mn:000017D0 ; public: __thiscall std::_String_alloc<0, struct std::_String_base_types<char, class std::allocator<char>>>::~_String_alloc<0, struct std::_String_base_types<char, class std::allocator<char>>>(void)
.text$mn:000017D0                 public ??1?$_String_alloc@$0A@U?$_String_base_types@DV?$allocator@D@std@@@std@@@std@@QAE@XZ
.text$mn:000017D0 ??1?$_String_alloc@$0A@U?$_String_base_types@DV?$allocator@D@std@@@std@@@std@@QAE@XZ proc near
.text$mn:000017D0                                         ; CODE XREF: __unwindfunclet$??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@PBD@Z$0+3j
.text$mn:000017D0                                         ; std::basic_string<char,std::char_traits<char>,std::allocator<char>>::~basic_string<char,std::char_traits<char>,std::allocator<char>>(void)+43p ...
.text$mn:000017D0
.text$mn:000017D0 var_10          = dword ptr -10h
.text$mn:000017D0 var_C           = dword ptr -0Ch
.text$mn:000017D0 var_4           = dword ptr -4
.text$mn:000017D0
.text$mn:000017D0                 push    ebp
.text$mn:000017D1                 mov     ebp, esp
.text$mn:000017D3                 push    0FFFFFFFFh
.text$mn:000017D5                 push    offset __ehhandler$??1?$_String_alloc@$0A@U?$_String_base_types@DV?$allocator@D@std@@@std@@@std@@QAE@XZ
.text$mn:000017DA                 mov     eax, large fs:0
.text$mn:000017E0                 push    eax
.text$mn:000017E1                 push    ecx
.text$mn:000017E2                 mov     eax, dword ptr ds:___security_cookie
.text$mn:000017E7                 xor     eax, ebp
.text$mn:000017E9                 push    eax
.text$mn:000017EA                 lea     eax, [ebp+var_C]
.text$mn:000017ED                 mov     large fs:0, eax
.text$mn:000017F3                 mov     [ebp+var_10], ecx
.text$mn:000017F6                 mov     [ebp+var_4], 0
.text$mn:000017FD                 mov     ecx, [ebp+var_10]
.text$mn:00001800                 call    ?_Free_proxy@?$_String_alloc@$0A@U?$_String_base_types@DV?$allocator@D@std@@@std@@@std@@QAEXXZ ; std::_String_alloc<0,std::_String_base_types<char,std::allocator<char>>>::_Free_proxy(void)
.text$mn:00001805                 mov     [ebp+var_4], 0FFFFFFFFh
.text$mn:0000180C                 mov     ecx, [ebp+var_10]
.text$mn:0000180F                 call    ??1?$_String_val@U?$_Simple_types@D@std@@@std@@QAE@XZ ; std::_String_val<std::_Simple_types<char>>::~_String_val<std::_Simple_types<char>>(void)
.text$mn:00001814                 mov     ecx, [ebp+var_C]
.text$mn:00001817                 mov     large fs:0, ecx
.text$mn:0000181E                 pop     ecx
.text$mn:0000181F                 mov     esp, ebp
.text$mn:00001821                 pop     ebp
.text$mn:00001822                 retn
.text$mn:00001822 ??1?$_String_alloc@$0A@U?$_String_base_types@DV?$allocator@D@std@@@std@@@std@@QAE@XZ endp
.text$mn:00001822
.text$mn:00001822 ; ---------------------------------------------------------------------------
.text$mn:00001823                 align 4
.text$mn:00001823 _text$mn        ends
.text$mn:00001823
.text$x:00001824 ; ===========================================================================
.text$x:00001824
.text$x:00001824 ; Segment type: Pure code
.text$x:00001824 ; Segment permissions: Read/Execute
.text$x:00001824 _text$x         segment para public 'CODE' use32
.text$x:00001824                 assume cs:_text$x
.text$x:00001824                 ;org 1824h
.text$x:00001824 ; COMDAT (pick associative to section at 17D0)
.text$x:00001824                 assume es:nothing, ss:nothing, ds:_data, fs:nothing, gs:nothing
.text$x:00001824
.text$x:00001824 ; =============== S U B R O U T I N E =======================================
.text$x:00001824
.text$x:00001824
.text$x:00001824 __unwindfunclet$??1?$_String_alloc@$0A@U?$_String_base_types@DV?$allocator@D@std@@@std@@@std@@QAE@XZ$0 proc near
.text$x:00001824                                         ; DATA XREF: .xdata$x:00002C20o
.text$x:00001824                 mov     ecx, [ebp-10h]
.text$x:00001827                 jmp     ??1?$_String_val@U?$_Simple_types@D@std@@@std@@QAE@XZ ; std::_String_val<std::_Simple_types<char>>::~_String_val<std::_Simple_types<char>>(void)
.text$x:00001827 __unwindfunclet$??1?$_String_alloc@$0A@U?$_String_base_types@DV?$allocator@D@std@@@std@@@std@@QAE@XZ$0 endp
.text$x:00001827
.text$x:0000182C
.text$x:0000182C ; =============== S U B R O U T I N E =======================================
.text$x:0000182C
.text$x:0000182C
.text$x:0000182C __ehhandler$??1?$_String_alloc@$0A@U?$_String_base_types@DV?$allocator@D@std@@@std@@@std@@QAE@XZ proc near
.text$x:0000182C                                         ; DATA XREF: std::_String_alloc<0,std::_String_base_types<char,std::allocator<char>>>::~_String_alloc<0,std::_String_base_types<char,std::allocator<char>>>(void)+5o
.text$x:0000182C
.text$x:0000182C arg_4           = dword ptr  8
.text$x:0000182C
.text$x:0000182C                 mov     edx, [esp+arg_4]
.text$x:00001830                 lea     eax, [edx+0Ch]
.text$x:00001833                 mov     ecx, [edx-8]
.text$x:00001836                 xor     ecx, eax
.text$x:00001838                 call    @__security_check_cookie@4 ; __security_check_cookie(x)
.text$x:0000183D                 mov     eax, offset __ehfuncinfo$??1?$_String_alloc@$0A@U?$_String_base_types@DV?$allocator@D@std@@@std@@@std@@QAE@XZ
.text$x:00001842                 jmp     ___CxxFrameHandler3
.text$x:00001842 __ehhandler$??1?$_String_alloc@$0A@U?$_String_base_types@DV?$allocator@D@std@@@std@@@std@@QAE@XZ endp
.text$x:00001842
.text$x:00001842 ; ---------------------------------------------------------------------------
.text$x:00001847                 align 4
.text$x:00001847 _text$x         ends
.text$x:00001847
.text$mn:00001848 ; ===========================================================================
.text$mn:00001848
.text$mn:00001848 ; Segment type: Pure code
.text$mn:00001848 ; Segment permissions: Read/Execute
.text$mn:00001848 _text$mn        segment para public 'CODE' use32
.text$mn:00001848                 assume cs:_text$mn
.text$mn:00001848                 ;org 1848h
.text$mn:00001848 ; COMDAT (pick any)
.text$mn:00001848                 assume es:nothing, ss:nothing, ds:_data, fs:nothing, gs:nothing
.text$mn:00001848
.text$mn:00001848 ; =============== S U B R O U T I N E =======================================
.text$mn:00001848
.text$mn:00001848 ; Attributes: bp-based frame
.text$mn:00001848
.text$mn:00001848 ; public: __thiscall std::_String_val<struct std::_Simple_types<char>>::~_String_val<struct std::_Simple_types<char>>(void)
.text$mn:00001848                 public ??1?$_String_val@U?$_Simple_types@D@std@@@std@@QAE@XZ
.text$mn:00001848 ??1?$_String_val@U?$_Simple_types@D@std@@@std@@QAE@XZ proc near
.text$mn:00001848                                         ; CODE XREF: __unwindfunclet$??0?$_String_alloc@$0A@U?$_String_base_types@DV?$allocator@D@std@@@std@@@std@@QAE@ABV?$allocator@D@1@@Z$0+3j
.text$mn:00001848                                         ; std::_String_alloc<0,std::_String_base_types<char,std::allocator<char>>>::~_String_alloc<0,std::_String_base_types<char,std::allocator<char>>>(void)+3Fp ...
.text$mn:00001848
.text$mn:00001848 var_10          = dword ptr -10h
.text$mn:00001848 var_C           = dword ptr -0Ch
.text$mn:00001848 var_4           = dword ptr -4
.text$mn:00001848
.text$mn:00001848                 push    ebp
.text$mn:00001849                 mov     ebp, esp
.text$mn:0000184B                 push    0FFFFFFFFh
.text$mn:0000184D                 push    offset __ehhandler$??1?$_String_val@U?$_Simple_types@D@std@@@std@@QAE@XZ
.text$mn:00001852                 mov     eax, large fs:0
.text$mn:00001858                 push    eax
.text$mn:00001859                 push    ecx
.text$mn:0000185A                 mov     eax, dword ptr ds:___security_cookie
.text$mn:0000185F                 xor     eax, ebp
.text$mn:00001861                 push    eax
.text$mn:00001862                 lea     eax, [ebp+var_C]
.text$mn:00001865                 mov     large fs:0, eax
.text$mn:0000186B                 mov     [ebp+var_10], ecx
.text$mn:0000186E                 mov     [ebp+var_4], 0
.text$mn:00001875                 mov     [ebp+var_4], 0FFFFFFFFh
.text$mn:0000187C                 mov     ecx, [ebp+var_10] ; this
.text$mn:0000187F                 call    ??1_Container_base12@std@@QAE@XZ ; std::_Container_base12::~_Container_base12(void)
.text$mn:00001884                 mov     ecx, [ebp+var_C]
.text$mn:00001887                 mov     large fs:0, ecx
.text$mn:0000188E                 pop     ecx
.text$mn:0000188F                 mov     esp, ebp
.text$mn:00001891                 pop     ebp
.text$mn:00001892                 retn
.text$mn:00001892 ??1?$_String_val@U?$_Simple_types@D@std@@@std@@QAE@XZ endp
.text$mn:00001892
.text$mn:00001892 ; ---------------------------------------------------------------------------
.text$mn:00001893                 align 4
.text$mn:00001893 _text$mn        ends
.text$mn:00001893
.text$x:00001894 ; ===========================================================================
.text$x:00001894
.text$x:00001894 ; Segment type: Pure code
.text$x:00001894 ; Segment permissions: Read/Execute
.text$x:00001894 _text$x         segment para public 'CODE' use32
.text$x:00001894                 assume cs:_text$x
.text$x:00001894                 ;org 1894h
.text$x:00001894 ; COMDAT (pick associative to section at 1848)
.text$x:00001894                 assume es:nothing, ss:nothing, ds:_data, fs:nothing, gs:nothing
.text$x:00001894
.text$x:00001894 ; =============== S U B R O U T I N E =======================================
.text$x:00001894
.text$x:00001894
.text$x:00001894 __unwindfunclet$??1?$_String_val@U?$_Simple_types@D@std@@@std@@QAE@XZ$0 proc near
.text$x:00001894                                         ; DATA XREF: .xdata$x:00002BC8o
.text$x:00001894                 mov     ecx, [ebp-10h]  ; this
.text$x:00001897                 jmp     ??1_Container_base12@std@@QAE@XZ ; std::_Container_base12::~_Container_base12(void)
.text$x:00001897 __unwindfunclet$??1?$_String_val@U?$_Simple_types@D@std@@@std@@QAE@XZ$0 endp
.text$x:00001897
.text$x:0000189C
.text$x:0000189C ; =============== S U B R O U T I N E =======================================
.text$x:0000189C
.text$x:0000189C
.text$x:0000189C __ehhandler$??1?$_String_val@U?$_Simple_types@D@std@@@std@@QAE@XZ proc near
.text$x:0000189C                                         ; DATA XREF: std::_String_val<std::_Simple_types<char>>::~_String_val<std::_Simple_types<char>>(void)+5o
.text$x:0000189C
.text$x:0000189C arg_4           = dword ptr  8
.text$x:0000189C
.text$x:0000189C                 mov     edx, [esp+arg_4]
.text$x:000018A0                 lea     eax, [edx+0Ch]
.text$x:000018A3                 mov     ecx, [edx-8]
.text$x:000018A6                 xor     ecx, eax
.text$x:000018A8                 call    @__security_check_cookie@4 ; __security_check_cookie(x)
.text$x:000018AD                 mov     eax, offset __ehfuncinfo$??1?$_String_val@U?$_Simple_types@D@std@@@std@@QAE@XZ
.text$x:000018B2                 jmp     ___CxxFrameHandler3
.text$x:000018B2 __ehhandler$??1?$_String_val@U?$_Simple_types@D@std@@@std@@QAE@XZ endp
.text$x:000018B2
.text$x:000018B2 ; ---------------------------------------------------------------------------
.text$x:000018B7                 align 4
.text$x:000018B7 _text$x         ends
.text$x:000018B7
.text$mn:000018B8 ; ===========================================================================
.text$mn:000018B8
.text$mn:000018B8 ; Segment type: Pure code
.text$mn:000018B8 ; Segment permissions: Read/Execute
.text$mn:000018B8 _text$mn        segment para public 'CODE' use32
.text$mn:000018B8                 assume cs:_text$mn
.text$mn:000018B8                 ;org 18B8h
.text$mn:000018B8 ; COMDAT (pick any)
.text$mn:000018B8                 assume es:nothing, ss:nothing, ds:_data, fs:nothing, gs:nothing
.text$mn:000018B8
.text$mn:000018B8 ; =============== S U B R O U T I N E =======================================
.text$mn:000018B8
.text$mn:000018B8 ; Attributes: bp-based frame
.text$mn:000018B8
.text$mn:000018B8 ; public: __thiscall std::basic_string<char, struct std::char_traits<char>, class std::allocator<char>>::~basic_string<char, struct std::char_traits<char>, class std::allocator<char>>(void)
.text$mn:000018B8                 public ??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ
.text$mn:000018B8 ??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ proc near
.text$mn:000018B8                                         ; CODE XREF: __unwindfunclet$?message@_Generic_error_category@std@@UBE?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@2@H@Z$0+13j
.text$mn:000018B8                                         ; __unwindfunclet$?message@_Iostream_error_category@std@@UBE?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@2@H@Z$0+13j ...
.text$mn:000018B8
.text$mn:000018B8 var_10          = dword ptr -10h
.text$mn:000018B8 var_C           = dword ptr -0Ch
.text$mn:000018B8 var_4           = dword ptr -4
.text$mn:000018B8
.text$mn:000018B8                 push    ebp
.text$mn:000018B9                 mov     ebp, esp
.text$mn:000018BB                 push    0FFFFFFFFh
.text$mn:000018BD                 push    offset __ehhandler$??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ
.text$mn:000018C2                 mov     eax, large fs:0
.text$mn:000018C8                 push    eax
.text$mn:000018C9                 push    ecx
.text$mn:000018CA                 mov     eax, dword ptr ds:___security_cookie
.text$mn:000018CF                 xor     eax, ebp
.text$mn:000018D1                 push    eax
.text$mn:000018D2                 lea     eax, [ebp+var_C]
.text$mn:000018D5                 mov     large fs:0, eax
.text$mn:000018DB                 mov     [ebp+var_10], ecx
.text$mn:000018DE                 mov     [ebp+var_4], 0
.text$mn:000018E5                 push    0               ; Size
.text$mn:000018E7                 push    1               ; char
.text$mn:000018E9                 mov     ecx, [ebp+var_10]
.text$mn:000018EC                 call    ?_Tidy@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEX_NI@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char>>::_Tidy(bool,uint)
.text$mn:000018F1                 mov     [ebp+var_4], 0FFFFFFFFh
.text$mn:000018F8                 mov     ecx, [ebp+var_10]
.text$mn:000018FB                 call    ??1?$_String_alloc@$0A@U?$_String_base_types@DV?$allocator@D@std@@@std@@@std@@QAE@XZ ; std::_String_alloc<0,std::_String_base_types<char,std::allocator<char>>>::~_String_alloc<0,std::_String_base_types<char,std::allocator<char>>>(void)
.text$mn:00001900                 mov     ecx, [ebp+var_C]
.text$mn:00001903                 mov     large fs:0, ecx
.text$mn:0000190A                 pop     ecx
.text$mn:0000190B                 mov     esp, ebp
.text$mn:0000190D                 pop     ebp
.text$mn:0000190E                 retn
.text$mn:0000190E ??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ endp
.text$mn:0000190E
.text$mn:0000190E ; ---------------------------------------------------------------------------
.text$mn:0000190F                 align 10h
.text$mn:0000190F _text$mn        ends
.text$mn:0000190F
.text$x:00001910 ; ===========================================================================
.text$x:00001910
.text$x:00001910 ; Segment type: Pure code
.text$x:00001910 ; Segment permissions: Read/Execute
.text$x:00001910 _text$x         segment para public 'CODE' use32
.text$x:00001910                 assume cs:_text$x
.text$x:00001910                 ;org 1910h
.text$x:00001910 ; COMDAT (pick associative to section at 18B8)
.text$x:00001910                 assume es:nothing, ss:nothing, ds:_data, fs:nothing, gs:nothing
.text$x:00001910
.text$x:00001910 ; =============== S U B R O U T I N E =======================================
.text$x:00001910
.text$x:00001910
.text$x:00001910 __unwindfunclet$??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ$0 proc near
.text$x:00001910                                         ; DATA XREF: .xdata$x:00002C78o
.text$x:00001910                 mov     ecx, [ebp-10h]
.text$x:00001913                 jmp     ??1?$_String_alloc@$0A@U?$_String_base_types@DV?$allocator@D@std@@@std@@@std@@QAE@XZ ; std::_String_alloc<0,std::_String_base_types<char,std::allocator<char>>>::~_String_alloc<0,std::_String_base_types<char,std::allocator<char>>>(void)
.text$x:00001913 __unwindfunclet$??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ$0 endp
.text$x:00001913
.text$x:00001918
.text$x:00001918 ; =============== S U B R O U T I N E =======================================
.text$x:00001918
.text$x:00001918
.text$x:00001918 __ehhandler$??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ proc near
.text$x:00001918                                         ; DATA XREF: std::basic_string<char,std::char_traits<char>,std::allocator<char>>::~basic_string<char,std::char_traits<char>,std::allocator<char>>(void)+5o
.text$x:00001918
.text$x:00001918 arg_4           = dword ptr  8
.text$x:00001918
.text$x:00001918                 mov     edx, [esp+arg_4]
.text$x:0000191C                 lea     eax, [edx+0Ch]
.text$x:0000191F                 mov     ecx, [edx-8]
.text$x:00001922                 xor     ecx, eax
.text$x:00001924                 call    @__security_check_cookie@4 ; __security_check_cookie(x)
.text$x:00001929                 mov     eax, offset __ehfuncinfo$??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ
.text$x:0000192E                 jmp     ___CxxFrameHandler3
.text$x:0000192E __ehhandler$??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ endp
.text$x:0000192E
.text$x:0000192E ; ---------------------------------------------------------------------------
.text$x:00001933                 align 4
.text$x:00001933 _text$x         ends
.text$x:00001933
.text$mn:00001934 ; ===========================================================================
.text$mn:00001934
.text$mn:00001934 ; Segment type: Pure code
.text$mn:00001934 ; Segment permissions: Read/Execute
.text$mn:00001934 _text$mn        segment para public 'CODE' use32
.text$mn:00001934                 assume cs:_text$mn
.text$mn:00001934                 ;org 1934h
.text$mn:00001934 ; COMDAT (pick any)
.text$mn:00001934                 assume es:nothing, ss:nothing, ds:_data, fs:nothing, gs:nothing
.text$mn:00001934
.text$mn:00001934 ; =============== S U B R O U T I N E =======================================
.text$mn:00001934
.text$mn:00001934 ; Attributes: bp-based frame
.text$mn:00001934
.text$mn:00001934 ; _DWORD __thiscall std::_Container_base12::~_Container_base12(std::_Container_base12 *__hidden this)
.text$mn:00001934                 public ??1_Container_base12@std@@QAE@XZ
.text$mn:00001934 ??1_Container_base12@std@@QAE@XZ proc near
.text$mn:00001934                                         ; CODE XREF: __unwindfunclet$??0?$_String_val@U?$_Simple_types@D@std@@@std@@QAE@XZ$0+3j
.text$mn:00001934                                         ; std::_String_val<std::_Simple_types<char>>::~_String_val<std::_Simple_types<char>>(void)+37p ...
.text$mn:00001934
.text$mn:00001934 var_4           = dword ptr -4
.text$mn:00001934
.text$mn:00001934                 push    ebp
.text$mn:00001935                 mov     ebp, esp
.text$mn:00001937                 push    ecx
.text$mn:00001938                 mov     [ebp+var_4], ecx
.text$mn:0000193B                 mov     ecx, [ebp+var_4] ; this
.text$mn:0000193E                 call    ?_Orphan_all@_Container_base12@std@@QAEXXZ ; std::_Container_base12::_Orphan_all(void)
.text$mn:00001943                 mov     esp, ebp
.text$mn:00001945                 pop     ebp
.text$mn:00001946                 retn
.text$mn:00001946 ??1_Container_base12@std@@QAE@XZ endp
.text$mn:00001946
.text$mn:00001946 ; ---------------------------------------------------------------------------
.text$mn:00001947                 align 4
.text$mn:00001947 _text$mn        ends
.text$mn:00001947
.text$mn:00001948 ; ===========================================================================
.text$mn:00001948
.text$mn:00001948 ; Segment type: Pure code
.text$mn:00001948 ; Segment permissions: Read/Execute
.text$mn:00001948 _text$mn        segment para public 'CODE' use32
.text$mn:00001948                 assume cs:_text$mn
.text$mn:00001948                 ;org 1948h
.text$mn:00001948 ; COMDAT (pick any)
.text$mn:00001948                 assume es:nothing, ss:nothing, ds:_data, fs:nothing, gs:nothing
.text$mn:00001948
.text$mn:00001948 ; =============== S U B R O U T I N E =======================================
.text$mn:00001948
.text$mn:00001948 ; Attributes: bp-based frame
.text$mn:00001948
.text$mn:00001948 ; _DWORD __thiscall std::_Generic_error_category::~_Generic_error_category(std::_Generic_error_category *__hidden this)
.text$mn:00001948                 public ??1_Generic_error_category@std@@UAE@XZ
.text$mn:00001948 ??1_Generic_error_category@std@@UAE@XZ proc near
.text$mn:00001948                                         ; CODE XREF: __unwindfunclet$??0_Iostream_error_category@std@@QAE@XZ$0+3j
.text$mn:00001948                                         ; __unwindfunclet$??0_System_error_category@std@@QAE@XZ$0+3j ...
.text$mn:00001948
.text$mn:00001948 var_10          = dword ptr -10h
.text$mn:00001948 var_C           = dword ptr -0Ch
.text$mn:00001948 var_4           = dword ptr -4
.text$mn:00001948
.text$mn:00001948                 push    ebp
.text$mn:00001949                 mov     ebp, esp
.text$mn:0000194B                 push    0FFFFFFFFh
.text$mn:0000194D                 push    offset __ehhandler$??1_Generic_error_category@std@@UAE@XZ
.text$mn:00001952                 mov     eax, large fs:0
.text$mn:00001958                 push    eax
.text$mn:00001959                 push    ecx
.text$mn:0000195A                 mov     eax, dword ptr ds:___security_cookie
.text$mn:0000195F                 xor     eax, ebp
.text$mn:00001961                 push    eax
.text$mn:00001962                 lea     eax, [ebp+var_C]
.text$mn:00001965                 mov     large fs:0, eax
.text$mn:0000196B                 mov     [ebp+var_10], ecx
.text$mn:0000196E                 mov     [ebp+var_4], 0
.text$mn:00001975                 mov     [ebp+var_4], 0FFFFFFFFh
.text$mn:0000197C                 mov     ecx, [ebp+var_10] ; this
.text$mn:0000197F                 call    ??1error_category@std@@UAE@XZ ; std::error_category::~error_category(void)
.text$mn:00001984                 mov     ecx, [ebp+var_C]
.text$mn:00001987                 mov     large fs:0, ecx
.text$mn:0000198E                 pop     ecx
.text$mn:0000198F                 mov     esp, ebp
.text$mn:00001991                 pop     ebp
.text$mn:00001992                 retn
.text$mn:00001992 ??1_Generic_error_category@std@@UAE@XZ endp
.text$mn:00001992
.text$mn:00001992 ; ---------------------------------------------------------------------------
.text$mn:00001993                 align 4
.text$mn:00001993 _text$mn        ends
.text$mn:00001993
.text$x:00001994 ; ===========================================================================
.text$x:00001994
.text$x:00001994 ; Segment type: Pure code
.text$x:00001994 ; Segment permissions: Read/Execute
.text$x:00001994 _text$x         segment para public 'CODE' use32
.text$x:00001994                 assume cs:_text$x
.text$x:00001994                 ;org 1994h
.text$x:00001994 ; COMDAT (pick associative to section at 1948)
.text$x:00001994                 assume es:nothing, ss:nothing, ds:_data, fs:nothing, gs:nothing
.text$x:00001994
.text$x:00001994 ; =============== S U B R O U T I N E =======================================
.text$x:00001994
.text$x:00001994
.text$x:00001994 __unwindfunclet$??1_Generic_error_category@std@@UAE@XZ$0 proc near
.text$x:00001994                                         ; DATA XREF: .xdata$x:00002D88o
.text$x:00001994                 mov     ecx, [ebp-10h]  ; this
.text$x:00001997                 jmp     ??1error_category@std@@UAE@XZ ; std::error_category::~error_category(void)
.text$x:00001997 __unwindfunclet$??1_Generic_error_category@std@@UAE@XZ$0 endp
.text$x:00001997
.text$x:0000199C
.text$x:0000199C ; =============== S U B R O U T I N E =======================================
.text$x:0000199C
.text$x:0000199C
.text$x:0000199C __ehhandler$??1_Generic_error_category@std@@UAE@XZ proc near
.text$x:0000199C                                         ; DATA XREF: std::_Generic_error_category::~_Generic_error_category(void)+5o
.text$x:0000199C
.text$x:0000199C arg_4           = dword ptr  8
.text$x:0000199C
.text$x:0000199C                 mov     edx, [esp+arg_4]
.text$x:000019A0                 lea     eax, [edx+0Ch]
.text$x:000019A3                 mov     ecx, [edx-8]
.text$x:000019A6                 xor     ecx, eax
.text$x:000019A8                 call    @__security_check_cookie@4 ; __security_check_cookie(x)
.text$x:000019AD                 mov     eax, offset __ehfuncinfo$??1_Generic_error_category@std@@UAE@XZ
.text$x:000019B2                 jmp     ___CxxFrameHandler3
.text$x:000019B2 __ehhandler$??1_Generic_error_category@std@@UAE@XZ endp
.text$x:000019B2
.text$x:000019B2 ; ---------------------------------------------------------------------------
.text$x:000019B7                 align 4
.text$x:000019B7 _text$x         ends
.text$x:000019B7
.text$mn:000019B8 ; ===========================================================================
.text$mn:000019B8
.text$mn:000019B8 ; Segment type: Pure code
.text$mn:000019B8 ; Segment permissions: Read/Execute
.text$mn:000019B8 _text$mn        segment para public 'CODE' use32
.text$mn:000019B8                 assume cs:_text$mn
.text$mn:000019B8                 ;org 19B8h
.text$mn:000019B8 ; COMDAT (pick any)
.text$mn:000019B8                 assume es:nothing, ss:nothing, ds:_data, fs:nothing, gs:nothing
.text$mn:000019B8
.text$mn:000019B8 ; =============== S U B R O U T I N E =======================================
.text$mn:000019B8
.text$mn:000019B8 ; Attributes: bp-based frame
.text$mn:000019B8
.text$mn:000019B8 ; _DWORD __thiscall std::_Iostream_error_category::~_Iostream_error_category(std::_Iostream_error_category *__hidden this)
.text$mn:000019B8                 public ??1_Iostream_error_category@std@@UAE@XZ
.text$mn:000019B8 ??1_Iostream_error_category@std@@UAE@XZ proc near
.text$mn:000019B8                                         ; CODE XREF: std::_Iostream_error_category::`scalar deleting destructor'(uint)+Ap
.text$mn:000019B8                                         ; `dynamic atexit destructor for 'std::_Iostream_error_category std::_Error_objects<int>::_Iostream_object''(void)+8p
.text$mn:000019B8
.text$mn:000019B8 var_10          = dword ptr -10h
.text$mn:000019B8 var_C           = dword ptr -0Ch
.text$mn:000019B8 var_4           = dword ptr -4
.text$mn:000019B8
.text$mn:000019B8                 push    ebp
.text$mn:000019B9                 mov     ebp, esp
.text$mn:000019BB                 push    0FFFFFFFFh
.text$mn:000019BD                 push    offset __ehhandler$??1_Iostream_error_category@std@@UAE@XZ
.text$mn:000019C2                 mov     eax, large fs:0
.text$mn:000019C8                 push    eax
.text$mn:000019C9                 push    ecx
.text$mn:000019CA                 mov     eax, dword ptr ds:___security_cookie
.text$mn:000019CF                 xor     eax, ebp
.text$mn:000019D1                 push    eax
.text$mn:000019D2                 lea     eax, [ebp+var_C]
.text$mn:000019D5                 mov     large fs:0, eax
.text$mn:000019DB                 mov     [ebp+var_10], ecx
.text$mn:000019DE                 mov     [ebp+var_4], 0
.text$mn:000019E5                 mov     [ebp+var_4], 0FFFFFFFFh
.text$mn:000019EC                 mov     ecx, [ebp+var_10] ; this
.text$mn:000019EF                 call    ??1_Generic_error_category@std@@UAE@XZ ; std::_Generic_error_category::~_Generic_error_category(void)
.text$mn:000019F4                 mov     ecx, [ebp+var_C]
.text$mn:000019F7                 mov     large fs:0, ecx
.text$mn:000019FE                 pop     ecx
.text$mn:000019FF                 mov     esp, ebp
.text$mn:00001A01                 pop     ebp
.text$mn:00001A02                 retn
.text$mn:00001A02 ??1_Iostream_error_category@std@@UAE@XZ endp
.text$mn:00001A02
.text$mn:00001A02 ; ---------------------------------------------------------------------------
.text$mn:00001A03                 align 4
.text$mn:00001A03 _text$mn        ends
.text$mn:00001A03
.text$x:00001A04 ; ===========================================================================
.text$x:00001A04
.text$x:00001A04 ; Segment type: Pure code
.text$x:00001A04 ; Segment permissions: Read/Execute
.text$x:00001A04 _text$x         segment para public 'CODE' use32
.text$x:00001A04                 assume cs:_text$x
.text$x:00001A04                 ;org 1A04h
.text$x:00001A04 ; COMDAT (pick associative to section at 19B8)
.text$x:00001A04                 assume es:nothing, ss:nothing, ds:_data, fs:nothing, gs:nothing
.text$x:00001A04
.text$x:00001A04 ; =============== S U B R O U T I N E =======================================
.text$x:00001A04
.text$x:00001A04
.text$x:00001A04 __unwindfunclet$??1_Iostream_error_category@std@@UAE@XZ$0 proc near
.text$x:00001A04                                         ; DATA XREF: .xdata$x:00002E0Co
.text$x:00001A04                 mov     ecx, [ebp-10h]  ; this
.text$x:00001A07                 jmp     ??1_Generic_error_category@std@@UAE@XZ ; std::_Generic_error_category::~_Generic_error_category(void)
.text$x:00001A07 __unwindfunclet$??1_Iostream_error_category@std@@UAE@XZ$0 endp
.text$x:00001A07
.text$x:00001A0C
.text$x:00001A0C ; =============== S U B R O U T I N E =======================================
.text$x:00001A0C
.text$x:00001A0C
.text$x:00001A0C __ehhandler$??1_Iostream_error_category@std@@UAE@XZ proc near
.text$x:00001A0C                                         ; DATA XREF: std::_Iostream_error_category::~_Iostream_error_category(void)+5o
.text$x:00001A0C
.text$x:00001A0C arg_4           = dword ptr  8
.text$x:00001A0C
.text$x:00001A0C                 mov     edx, [esp+arg_4]
.text$x:00001A10                 lea     eax, [edx+0Ch]
.text$x:00001A13                 mov     ecx, [edx-8]
.text$x:00001A16                 xor     ecx, eax
.text$x:00001A18                 call    @__security_check_cookie@4 ; __security_check_cookie(x)
.text$x:00001A1D                 mov     eax, offset __ehfuncinfo$??1_Iostream_error_category@std@@UAE@XZ
.text$x:00001A22                 jmp     ___CxxFrameHandler3
.text$x:00001A22 __ehhandler$??1_Iostream_error_category@std@@UAE@XZ endp
.text$x:00001A22
.text$x:00001A22 ; ---------------------------------------------------------------------------
.text$x:00001A27                 align 4
.text$x:00001A27 _text$x         ends
.text$x:00001A27
.text$mn:00001A28 ; ===========================================================================
.text$mn:00001A28
.text$mn:00001A28 ; Segment type: Pure code
.text$mn:00001A28 ; Segment permissions: Read/Execute
.text$mn:00001A28 _text$mn        segment para public 'CODE' use32
.text$mn:00001A28                 assume cs:_text$mn
.text$mn:00001A28                 ;org 1A28h
.text$mn:00001A28 ; COMDAT (pick any)
.text$mn:00001A28                 assume es:nothing, ss:nothing, ds:_data, fs:nothing, gs:nothing
.text$mn:00001A28
.text$mn:00001A28 ; =============== S U B R O U T I N E =======================================
.text$mn:00001A28
.text$mn:00001A28 ; Attributes: bp-based frame
.text$mn:00001A28
.text$mn:00001A28 ; _DWORD __thiscall std::_System_error_category::~_System_error_category(std::_System_error_category *__hidden this)
.text$mn:00001A28                 public ??1_System_error_category@std@@UAE@XZ
.text$mn:00001A28 ??1_System_error_category@std@@UAE@XZ proc near
.text$mn:00001A28                                         ; CODE XREF: std::_System_error_category::`scalar deleting destructor'(uint)+Ap
.text$mn:00001A28                                         ; `dynamic atexit destructor for 'std::_System_error_category std::_Error_objects<int>::_System_object''(void)+8p
.text$mn:00001A28
.text$mn:00001A28 var_10          = dword ptr -10h
.text$mn:00001A28 var_C           = dword ptr -0Ch
.text$mn:00001A28 var_4           = dword ptr -4
.text$mn:00001A28
.text$mn:00001A28                 push    ebp
.text$mn:00001A29                 mov     ebp, esp
.text$mn:00001A2B                 push    0FFFFFFFFh
.text$mn:00001A2D                 push    offset __ehhandler$??1_System_error_category@std@@UAE@XZ
.text$mn:00001A32                 mov     eax, large fs:0
.text$mn:00001A38                 push    eax
.text$mn:00001A39                 push    ecx
.text$mn:00001A3A                 mov     eax, dword ptr ds:___security_cookie
.text$mn:00001A3F                 xor     eax, ebp
.text$mn:00001A41                 push    eax
.text$mn:00001A42                 lea     eax, [ebp+var_C]
.text$mn:00001A45                 mov     large fs:0, eax
.text$mn:00001A4B                 mov     [ebp+var_10], ecx
.text$mn:00001A4E                 mov     [ebp+var_4], 0
.text$mn:00001A55                 mov     [ebp+var_4], 0FFFFFFFFh
.text$mn:00001A5C                 mov     ecx, [ebp+var_10] ; this
.text$mn:00001A5F                 call    ??1_Generic_error_category@std@@UAE@XZ ; std::_Generic_error_category::~_Generic_error_category(void)
.text$mn:00001A64                 mov     ecx, [ebp+var_C]
.text$mn:00001A67                 mov     large fs:0, ecx
.text$mn:00001A6E                 pop     ecx
.text$mn:00001A6F                 mov     esp, ebp
.text$mn:00001A71                 pop     ebp
.text$mn:00001A72                 retn
.text$mn:00001A72 ??1_System_error_category@std@@UAE@XZ endp
.text$mn:00001A72
.text$mn:00001A72 ; ---------------------------------------------------------------------------
.text$mn:00001A73                 align 4
.text$mn:00001A73 _text$mn        ends
.text$mn:00001A73
.text$x:00001A74 ; ===========================================================================
.text$x:00001A74
.text$x:00001A74 ; Segment type: Pure code
.text$x:00001A74 ; Segment permissions: Read/Execute
.text$x:00001A74 _text$x         segment para public 'CODE' use32
.text$x:00001A74                 assume cs:_text$x
.text$x:00001A74                 ;org 1A74h
.text$x:00001A74 ; COMDAT (pick associative to section at 1A28)
.text$x:00001A74                 assume es:nothing, ss:nothing, ds:_data, fs:nothing, gs:nothing
.text$x:00001A74
.text$x:00001A74 ; =============== S U B R O U T I N E =======================================
.text$x:00001A74
.text$x:00001A74
.text$x:00001A74 __unwindfunclet$??1_System_error_category@std@@UAE@XZ$0 proc near
.text$x:00001A74                                         ; DATA XREF: .xdata$x:00002E90o
.text$x:00001A74                 mov     ecx, [ebp-10h]  ; this
.text$x:00001A77                 jmp     ??1_Generic_error_category@std@@UAE@XZ ; std::_Generic_error_category::~_Generic_error_category(void)
.text$x:00001A77 __unwindfunclet$??1_System_error_category@std@@UAE@XZ$0 endp
.text$x:00001A77
.text$x:00001A7C
.text$x:00001A7C ; =============== S U B R O U T I N E =======================================
.text$x:00001A7C
.text$x:00001A7C
.text$x:00001A7C __ehhandler$??1_System_error_category@std@@UAE@XZ proc near
.text$x:00001A7C                                         ; DATA XREF: std::_System_error_category::~_System_error_category(void)+5o
.text$x:00001A7C
.text$x:00001A7C arg_4           = dword ptr  8
.text$x:00001A7C
.text$x:00001A7C                 mov     edx, [esp+arg_4]
.text$x:00001A80                 lea     eax, [edx+0Ch]
.text$x:00001A83                 mov     ecx, [edx-8]
.text$x:00001A86                 xor     ecx, eax
.text$x:00001A88                 call    @__security_check_cookie@4 ; __security_check_cookie(x)
.text$x:00001A8D                 mov     eax, offset __ehfuncinfo$??1_System_error_category@std@@UAE@XZ
.text$x:00001A92                 jmp     ___CxxFrameHandler3
.text$x:00001A92 __ehhandler$??1_System_error_category@std@@UAE@XZ endp
.text$x:00001A92
.text$x:00001A92 ; ---------------------------------------------------------------------------
.text$x:00001A97                 align 4
.text$x:00001A97 _text$x         ends
.text$x:00001A97
.text$mn:00001A98 ; ===========================================================================
.text$mn:00001A98
.text$mn:00001A98 ; Segment type: Pure code
.text$mn:00001A98 ; Segment permissions: Read/Execute
.text$mn:00001A98 _text$mn        segment para public 'CODE' use32
.text$mn:00001A98                 assume cs:_text$mn
.text$mn:00001A98                 ;org 1A98h
.text$mn:00001A98 ; COMDAT (pick any)
.text$mn:00001A98                 assume es:nothing, ss:nothing, ds:_data, fs:nothing, gs:nothing
.text$mn:00001A98
.text$mn:00001A98 ; =============== S U B R O U T I N E =======================================
.text$mn:00001A98
.text$mn:00001A98 ; Attributes: bp-based frame
.text$mn:00001A98
.text$mn:00001A98 ; _DWORD __thiscall std::error_category::~error_category(std::error_category *__hidden this)
.text$mn:00001A98                 public ??1error_category@std@@UAE@XZ
.text$mn:00001A98 ??1error_category@std@@UAE@XZ proc near ; CODE XREF: __unwindfunclet$??0_Generic_error_category@std@@QAE@XZ$0+3j
.text$mn:00001A98                                         ; std::_Generic_error_category::~_Generic_error_category(void)+37p ...
.text$mn:00001A98
.text$mn:00001A98 var_4           = dword ptr -4
.text$mn:00001A98
.text$mn:00001A98                 push    ebp
.text$mn:00001A99                 mov     ebp, esp
.text$mn:00001A9B                 push    ecx
.text$mn:00001A9C                 mov     [ebp+var_4], ecx
.text$mn:00001A9F                 mov     eax, [ebp+var_4]
.text$mn:00001AA2                 mov     dword ptr [eax], offset ??_7error_category@std@@6B@ ; const std::error_category::`vftable'
.text$mn:00001AA8                 mov     esp, ebp
.text$mn:00001AAA                 pop     ebp
.text$mn:00001AAB                 retn
.text$mn:00001AAB ??1error_category@std@@UAE@XZ endp
.text$mn:00001AAB
.text$mn:00001AAB _text$mn        ends
.text$mn:00001AAB
.text$mn:00001AAC ; ===========================================================================
.text$mn:00001AAC
.text$mn:00001AAC ; Segment type: Pure code
.text$mn:00001AAC ; Segment permissions: Read/Execute
.text$mn:00001AAC _text$mn        segment para public 'CODE' use32
.text$mn:00001AAC                 assume cs:_text$mn
.text$mn:00001AAC                 ;org 1AACh
.text$mn:00001AAC ; COMDAT (pick any)
.text$mn:00001AAC                 assume es:nothing, ss:nothing, ds:_data, fs:nothing, gs:nothing
.text$mn:00001AAC
.text$mn:00001AAC ; =============== S U B R O U T I N E =======================================
.text$mn:00001AAC
.text$mn:00001AAC ; Attributes: bp-based frame
.text$mn:00001AAC
.text$mn:00001AAC ; void *__cdecl operator new(unsigned int, void *)
.text$mn:00001AAC                 public ??2@YAPAXIPAX@Z
.text$mn:00001AAC ??2@YAPAXIPAX@Z proc near               ; CODE XREF: std::allocator<char>::construct<char *,char * &>(char * *,char * &)+2Ep
.text$mn:00001AAC                                         ; std::allocator<std::_Container_proxy>::construct<std::_Container_proxy,std::_Container_proxy>(std::_Container_proxy *,std::_Container_proxy &&)+2Ep
.text$mn:00001AAC
.text$mn:00001AAC arg_4           = dword ptr  0Ch
.text$mn:00001AAC
.text$mn:00001AAC                 push    ebp
.text$mn:00001AAD                 mov     ebp, esp
.text$mn:00001AAF                 mov     eax, [ebp+arg_4]
.text$mn:00001AB2                 pop     ebp
.text$mn:00001AB3                 retn
.text$mn:00001AB3 ??2@YAPAXIPAX@Z endp
.text$mn:00001AB3
.text$mn:00001AB3 _text$mn        ends
.text$mn:00001AB3
.text$mn:00001AB4 ; ===========================================================================
.text$mn:00001AB4
.text$mn:00001AB4 ; Segment type: Pure code
.text$mn:00001AB4 ; Segment permissions: Read/Execute
.text$mn:00001AB4 _text$mn        segment para public 'CODE' use32
.text$mn:00001AB4                 assume cs:_text$mn
.text$mn:00001AB4                 ;org 1AB4h
.text$mn:00001AB4 ; COMDAT (pick any)
.text$mn:00001AB4                 assume es:nothing, ss:nothing, ds:_data, fs:nothing, gs:nothing
.text$mn:00001AB4
.text$mn:00001AB4 ; =============== S U B R O U T I N E =======================================
.text$mn:00001AB4
.text$mn:00001AB4 ; Attributes: bp-based frame
.text$mn:00001AB4
.text$mn:00001AB4 ; void __cdecl operator delete(void *)
.text$mn:00001AB4                 public ??3@YAXPAX0@Z
.text$mn:00001AB4 ??3@YAXPAX0@Z   proc near               ; CODE XREF: __unwindfunclet$??$construct@PADAAPAD@?$allocator@D@std@@QAEXPAPADAAPAD@Z$0+8p
.text$mn:00001AB4                                         ; __unwindfunclet$??$construct@U_Container_proxy@std@@U12@@?$allocator@U_Container_proxy@std@@@std@@QAEXPAU_Container_proxy@1@$$QAU21@@Z$0+8p
.text$mn:00001AB4                 push    ebp
.text$mn:00001AB5                 mov     ebp, esp
.text$mn:00001AB7                 pop     ebp
.text$mn:00001AB8                 retn
.text$mn:00001AB8 ??3@YAXPAX0@Z   endp
.text$mn:00001AB8
.text$mn:00001AB8 ; ---------------------------------------------------------------------------
.text$mn:00001AB9                 align 4
.text$mn:00001AB9 _text$mn        ends
.text$mn:00001AB9
.text$mn:00001ABC ; ===========================================================================
.text$mn:00001ABC
.text$mn:00001ABC ; Segment type: Pure code
.text$mn:00001ABC ; Segment permissions: Read/Execute
.text$mn:00001ABC _text$mn        segment para public 'CODE' use32
.text$mn:00001ABC                 assume cs:_text$mn
.text$mn:00001ABC                 ;org 1ABCh
.text$mn:00001ABC ; COMDAT (pick any)
.text$mn:00001ABC                 assume es:nothing, ss:nothing, ds:_data, fs:nothing, gs:nothing
.text$mn:00001ABC
.text$mn:00001ABC ; =============== S U B R O U T I N E =======================================
.text$mn:00001ABC
.text$mn:00001ABC ; Attributes: bp-based frame
.text$mn:00001ABC
.text$mn:00001ABC ; public: bool __thiscall std::error_category::operator==(class std::error_category const &)const
.text$mn:00001ABC                 public ??8error_category@std@@QBE_NABV01@@Z
.text$mn:00001ABC ??8error_category@std@@QBE_NABV01@@Z proc near
.text$mn:00001ABC                                         ; CODE XREF: std::error_condition::operator==(std::error_condition const &)+1Dp
.text$mn:00001ABC                                         ; std::error_category::equivalent(std::error_code const &,int)+15p
.text$mn:00001ABC
.text$mn:00001ABC var_8           = dword ptr -8
.text$mn:00001ABC var_4           = dword ptr -4
.text$mn:00001ABC arg_0           = dword ptr  8
.text$mn:00001ABC
.text$mn:00001ABC                 push    ebp
.text$mn:00001ABD                 mov     ebp, esp
.text$mn:00001ABF                 sub     esp, 8
.text$mn:00001AC2                 mov     [ebp+var_8], ecx
.text$mn:00001AC5                 mov     eax, [ebp+var_8]
.text$mn:00001AC8                 cmp     eax, [ebp+arg_0]
.text$mn:00001ACB                 jnz     short loc_1AD6
.text$mn:00001ACD                 mov     [ebp+var_4], 1
.text$mn:00001AD4                 jmp     short loc_1ADD
.text$mn:00001AD6 ; ---------------------------------------------------------------------------
.text$mn:00001AD6
.text$mn:00001AD6 loc_1AD6:                               ; CODE XREF: std::error_category::operator==(std::error_category const &)+Fj
.text$mn:00001AD6                 mov     [ebp+var_4], 0
.text$mn:00001ADD
.text$mn:00001ADD loc_1ADD:                               ; CODE XREF: std::error_category::operator==(std::error_category const &)+18j
.text$mn:00001ADD                 mov     al, byte ptr [ebp+var_4]
.text$mn:00001AE0                 mov     esp, ebp
.text$mn:00001AE2                 pop     ebp
.text$mn:00001AE3                 retn    4
.text$mn:00001AE3 ??8error_category@std@@QBE_NABV01@@Z endp
.text$mn:00001AE3
.text$mn:00001AE3 ; ---------------------------------------------------------------------------
.text$mn:00001AE6                 align 4
.text$mn:00001AE6 _text$mn        ends
.text$mn:00001AE6
.text$mn:00001AE8 ; ===========================================================================
.text$mn:00001AE8
.text$mn:00001AE8 ; Segment type: Pure code
.text$mn:00001AE8 ; Segment permissions: Read/Execute
.text$mn:00001AE8 _text$mn        segment para public 'CODE' use32
.text$mn:00001AE8                 assume cs:_text$mn
.text$mn:00001AE8                 ;org 1AE8h
.text$mn:00001AE8 ; COMDAT (pick any)
.text$mn:00001AE8                 assume es:nothing, ss:nothing, ds:_data, fs:nothing, gs:nothing
.text$mn:00001AE8
.text$mn:00001AE8 ; =============== S U B R O U T I N E =======================================
.text$mn:00001AE8
.text$mn:00001AE8 ; Attributes: bp-based frame
.text$mn:00001AE8
.text$mn:00001AE8 ; int __stdcall std::error_condition::operator==(std::error_condition *)
.text$mn:00001AE8                 public ??8error_condition@std@@QBE_NABV01@@Z
.text$mn:00001AE8 ??8error_condition@std@@QBE_NABV01@@Z proc near
.text$mn:00001AE8                                         ; CODE XREF: std::error_category::equivalent(int,std::error_condition const &)+24p
.text$mn:00001AE8
.text$mn:00001AE8 var_8           = dword ptr -8
.text$mn:00001AE8 var_4           = dword ptr -4
.text$mn:00001AE8 arg_0           = dword ptr  8
.text$mn:00001AE8
.text$mn:00001AE8                 push    ebp
.text$mn:00001AE9                 mov     ebp, esp
.text$mn:00001AEB                 sub     esp, 8
.text$mn:00001AEE                 push    esi
.text$mn:00001AEF                 mov     [ebp+var_4], ecx
.text$mn:00001AF2                 mov     ecx, [ebp+arg_0] ; this
.text$mn:00001AF5                 call    ?category@error_condition@std@@QBEABVerror_category@2@XZ ; std::error_condition::category(void)
.text$mn:00001AFA                 push    eax
.text$mn:00001AFB                 mov     ecx, [ebp+var_4] ; this
.text$mn:00001AFE                 call    ?category@error_condition@std@@QBEABVerror_category@2@XZ ; std::error_condition::category(void)
.text$mn:00001B03                 mov     ecx, eax
.text$mn:00001B05                 call    ??8error_category@std@@QBE_NABV01@@Z ; std::error_category::operator==(std::error_category const &)
.text$mn:00001B0A                 movzx   eax, al
.text$mn:00001B0D                 test    eax, eax
.text$mn:00001B0F                 jz      short loc_1B30
.text$mn:00001B11                 mov     ecx, [ebp+var_4] ; this
.text$mn:00001B14                 call    ?value@error_condition@std@@QBEHXZ ; std::error_condition::value(void)
.text$mn:00001B19                 mov     esi, eax
.text$mn:00001B1B                 mov     ecx, [ebp+arg_0] ; this
.text$mn:00001B1E                 call    ?value@error_condition@std@@QBEHXZ ; std::error_condition::value(void)
.text$mn:00001B23                 cmp     esi, eax
.text$mn:00001B25                 jnz     short loc_1B30
.text$mn:00001B27                 mov     [ebp+var_8], 1
.text$mn:00001B2E                 jmp     short loc_1B37
.text$mn:00001B30 ; ---------------------------------------------------------------------------
.text$mn:00001B30
.text$mn:00001B30 loc_1B30:                               ; CODE XREF: std::error_condition::operator==(std::error_condition const &)+27j
.text$mn:00001B30                                         ; std::error_condition::operator==(std::error_condition const &)+3Dj
.text$mn:00001B30                 mov     [ebp+var_8], 0
.text$mn:00001B37
.text$mn:00001B37 loc_1B37:                               ; CODE XREF: std::error_condition::operator==(std::error_condition const &)+46j
.text$mn:00001B37                 mov     al, byte ptr [ebp+var_8]
.text$mn:00001B3A                 pop     esi
.text$mn:00001B3B                 mov     esp, ebp
.text$mn:00001B3D                 pop     ebp
.text$mn:00001B3E                 retn    4
.text$mn:00001B3E ??8error_condition@std@@QBE_NABV01@@Z endp
.text$mn:00001B3E
.text$mn:00001B3E ; ---------------------------------------------------------------------------
.text$mn:00001B41                 align 4
.text$mn:00001B41 _text$mn        ends
.text$mn:00001B41
.text$mn:00001B44 ; ===========================================================================
.text$mn:00001B44
.text$mn:00001B44 ; Segment type: Pure code
.text$mn:00001B44 ; Segment permissions: Read/Execute
.text$mn:00001B44 _text$mn        segment para public 'CODE' use32
.text$mn:00001B44                 assume cs:_text$mn
.text$mn:00001B44                 ;org 1B44h
.text$mn:00001B44 ; COMDAT (pick any)
.text$mn:00001B44                 assume es:nothing, ss:nothing, ds:_data, fs:nothing, gs:nothing
.text$mn:00001B44
.text$mn:00001B44 ; =============== S U B R O U T I N E =======================================
.text$mn:00001B44
.text$mn:00001B44 ; Attributes: bp-based frame
.text$mn:00001B44
.text$mn:00001B44 ; public: virtual void * __thiscall std::_Generic_error_category::`scalar deleting destructor'(unsigned int)
.text$mn:00001B44                 public ??_G_Generic_error_category@std@@UAEPAXI@Z
.text$mn:00001B44 ??_G_Generic_error_category@std@@UAEPAXI@Z proc near
.text$mn:00001B44
.text$mn:00001B44 var_4           = dword ptr -4
.text$mn:00001B44 arg_0           = dword ptr  8
.text$mn:00001B44
.text$mn:00001B44                 push    ebp
.text$mn:00001B45                 mov     ebp, esp
.text$mn:00001B47                 push    ecx
.text$mn:00001B48                 mov     [ebp+var_4], ecx
.text$mn:00001B4B                 mov     ecx, [ebp+var_4] ; this
.text$mn:00001B4E                 call    ??1_Generic_error_category@std@@UAE@XZ ; std::_Generic_error_category::~_Generic_error_category(void)
.text$mn:00001B53                 mov     eax, [ebp+arg_0]
.text$mn:00001B56                 and     eax, 1
.text$mn:00001B59                 jz      short loc_1B67
.text$mn:00001B5B                 mov     ecx, [ebp+var_4]
.text$mn:00001B5E                 push    ecx             ; void *
.text$mn:00001B5F                 call    ??3@YAXPAX@Z    ; operator delete(void *)
.text$mn:00001B64                 add     esp, 4
.text$mn:00001B67
.text$mn:00001B67 loc_1B67:                               ; CODE XREF: std::_Generic_error_category::`scalar deleting destructor'(uint)+15j
.text$mn:00001B67                 mov     eax, [ebp+var_4]
.text$mn:00001B6A                 mov     esp, ebp
.text$mn:00001B6C                 pop     ebp
.text$mn:00001B6D                 retn    4
.text$mn:00001B6D ??_G_Generic_error_category@std@@UAEPAXI@Z endp
.text$mn:00001B6D
.text$mn:00001B6D _text$mn        ends
.text$mn:00001B6D
.text$mn:00001B70 ; ===========================================================================
.text$mn:00001B70
.text$mn:00001B70 ; Segment type: Pure code
.text$mn:00001B70 ; Segment permissions: Read/Execute
.text$mn:00001B70 _text$mn        segment para public 'CODE' use32
.text$mn:00001B70                 assume cs:_text$mn
.text$mn:00001B70                 ;org 1B70h
.text$mn:00001B70 ; COMDAT (pick any)
.text$mn:00001B70                 assume es:nothing, ss:nothing, ds:_data, fs:nothing, gs:nothing
.text$mn:00001B70
.text$mn:00001B70 ; =============== S U B R O U T I N E =======================================
.text$mn:00001B70
.text$mn:00001B70 ; Attributes: bp-based frame
.text$mn:00001B70
.text$mn:00001B70 ; public: virtual void * __thiscall std::_Iostream_error_category::`scalar deleting destructor'(unsigned int)
.text$mn:00001B70                 public ??_G_Iostream_error_category@std@@UAEPAXI@Z
.text$mn:00001B70 ??_G_Iostream_error_category@std@@UAEPAXI@Z proc near
.text$mn:00001B70
.text$mn:00001B70 var_4           = dword ptr -4
.text$mn:00001B70 arg_0           = dword ptr  8
.text$mn:00001B70
.text$mn:00001B70                 push    ebp
.text$mn:00001B71                 mov     ebp, esp
.text$mn:00001B73                 push    ecx
.text$mn:00001B74                 mov     [ebp+var_4], ecx
.text$mn:00001B77                 mov     ecx, [ebp+var_4] ; this
.text$mn:00001B7A                 call    ??1_Iostream_error_category@std@@UAE@XZ ; std::_Iostream_error_category::~_Iostream_error_category(void)
.text$mn:00001B7F                 mov     eax, [ebp+arg_0]
.text$mn:00001B82                 and     eax, 1
.text$mn:00001B85                 jz      short loc_1B93
.text$mn:00001B87                 mov     ecx, [ebp+var_4]
.text$mn:00001B8A                 push    ecx             ; void *
.text$mn:00001B8B                 call    ??3@YAXPAX@Z    ; operator delete(void *)
.text$mn:00001B90                 add     esp, 4
.text$mn:00001B93
.text$mn:00001B93 loc_1B93:                               ; CODE XREF: std::_Iostream_error_category::`scalar deleting destructor'(uint)+15j
.text$mn:00001B93                 mov     eax, [ebp+var_4]
.text$mn:00001B96                 mov     esp, ebp
.text$mn:00001B98                 pop     ebp
.text$mn:00001B99                 retn    4
.text$mn:00001B99 ??_G_Iostream_error_category@std@@UAEPAXI@Z endp
.text$mn:00001B99
.text$mn:00001B99 _text$mn        ends
.text$mn:00001B99
.text$mn:00001B9C ; ===========================================================================
.text$mn:00001B9C
.text$mn:00001B9C ; Segment type: Pure code
.text$mn:00001B9C ; Segment permissions: Read/Execute
.text$mn:00001B9C _text$mn        segment para public 'CODE' use32
.text$mn:00001B9C                 assume cs:_text$mn
.text$mn:00001B9C                 ;org 1B9Ch
.text$mn:00001B9C ; COMDAT (pick any)
.text$mn:00001B9C                 assume es:nothing, ss:nothing, ds:_data, fs:nothing, gs:nothing
.text$mn:00001B9C
.text$mn:00001B9C ; =============== S U B R O U T I N E =======================================
.text$mn:00001B9C
.text$mn:00001B9C ; Attributes: bp-based frame
.text$mn:00001B9C
.text$mn:00001B9C ; public: virtual void * __thiscall std::_System_error_category::`scalar deleting destructor'(unsigned int)
.text$mn:00001B9C                 public ??_G_System_error_category@std@@UAEPAXI@Z
.text$mn:00001B9C ??_G_System_error_category@std@@UAEPAXI@Z proc near
.text$mn:00001B9C
.text$mn:00001B9C var_4           = dword ptr -4
.text$mn:00001B9C arg_0           = dword ptr  8
.text$mn:00001B9C
.text$mn:00001B9C                 push    ebp
.text$mn:00001B9D                 mov     ebp, esp
.text$mn:00001B9F                 push    ecx
.text$mn:00001BA0                 mov     [ebp+var_4], ecx
.text$mn:00001BA3                 mov     ecx, [ebp+var_4] ; this
.text$mn:00001BA6                 call    ??1_System_error_category@std@@UAE@XZ ; std::_System_error_category::~_System_error_category(void)
.text$mn:00001BAB                 mov     eax, [ebp+arg_0]
.text$mn:00001BAE                 and     eax, 1
.text$mn:00001BB1                 jz      short loc_1BBF
.text$mn:00001BB3                 mov     ecx, [ebp+var_4]
.text$mn:00001BB6                 push    ecx             ; void *
.text$mn:00001BB7                 call    ??3@YAXPAX@Z    ; operator delete(void *)
.text$mn:00001BBC                 add     esp, 4
.text$mn:00001BBF
.text$mn:00001BBF loc_1BBF:                               ; CODE XREF: std::_System_error_category::`scalar deleting destructor'(uint)+15j
.text$mn:00001BBF                 mov     eax, [ebp+var_4]
.text$mn:00001BC2                 mov     esp, ebp
.text$mn:00001BC4                 pop     ebp
.text$mn:00001BC5                 retn    4
.text$mn:00001BC5 ??_G_System_error_category@std@@UAEPAXI@Z endp
.text$mn:00001BC5
.text$mn:00001BC5 _text$mn        ends
.text$mn:00001BC5
.text$mn:00001BC8 ; ===========================================================================
.text$mn:00001BC8
.text$mn:00001BC8 ; Segment type: Pure code
.text$mn:00001BC8 ; Segment permissions: Read/Execute
.text$mn:00001BC8 _text$mn        segment para public 'CODE' use32
.text$mn:00001BC8                 assume cs:_text$mn
.text$mn:00001BC8                 ;org 1BC8h
.text$mn:00001BC8 ; COMDAT (pick any)
.text$mn:00001BC8                 assume es:nothing, ss:nothing, ds:_data, fs:nothing, gs:nothing
.text$mn:00001BC8
.text$mn:00001BC8 ; =============== S U B R O U T I N E =======================================
.text$mn:00001BC8
.text$mn:00001BC8 ; Attributes: bp-based frame
.text$mn:00001BC8
.text$mn:00001BC8 ; public: virtual void * __thiscall std::error_category::`scalar deleting destructor'(unsigned int)
.text$mn:00001BC8                 public ??_Gerror_category@std@@UAEPAXI@Z
.text$mn:00001BC8 ??_Gerror_category@std@@UAEPAXI@Z proc near
.text$mn:00001BC8
.text$mn:00001BC8 var_4           = dword ptr -4
.text$mn:00001BC8 arg_0           = dword ptr  8
.text$mn:00001BC8
.text$mn:00001BC8                 push    ebp
.text$mn:00001BC9                 mov     ebp, esp
.text$mn:00001BCB                 push    ecx
.text$mn:00001BCC                 mov     [ebp+var_4], ecx
.text$mn:00001BCF                 mov     ecx, [ebp+var_4] ; this
.text$mn:00001BD2                 call    ??1error_category@std@@UAE@XZ ; std::error_category::~error_category(void)
.text$mn:00001BD7                 mov     eax, [ebp+arg_0]
.text$mn:00001BDA                 and     eax, 1
.text$mn:00001BDD                 jz      short loc_1BEB
.text$mn:00001BDF                 mov     ecx, [ebp+var_4]
.text$mn:00001BE2                 push    ecx             ; void *
.text$mn:00001BE3                 call    ??3@YAXPAX@Z    ; operator delete(void *)
.text$mn:00001BE8                 add     esp, 4
.text$mn:00001BEB
.text$mn:00001BEB loc_1BEB:                               ; CODE XREF: std::error_category::`scalar deleting destructor'(uint)+15j
.text$mn:00001BEB                 mov     eax, [ebp+var_4]
.text$mn:00001BEE                 mov     esp, ebp
.text$mn:00001BF0                 pop     ebp
.text$mn:00001BF1                 retn    4
.text$mn:00001BF1 ??_Gerror_category@std@@UAEPAXI@Z endp
.text$mn:00001BF1
.text$mn:00001BF1 _text$mn        ends
.text$mn:00001BF1
.text$di:00001BF4 ; ===========================================================================
.text$di:00001BF4
.text$di:00001BF4 ; Segment type: Pure code
.text$di:00001BF4 ; Segment permissions: Read/Execute
.text$di:00001BF4 _text$di        segment para public 'CODE' use32
.text$di:00001BF4                 assume cs:_text$di
.text$di:00001BF4                 ;org 1BF4h
.text$di:00001BF4 ; COMDAT (pick any)
.text$di:00001BF4                 assume es:nothing, ss:nothing, ds:_data, fs:nothing, gs:nothing
.text$di:00001BF4
.text$di:00001BF4 ; =============== S U B R O U T I N E =======================================
.text$di:00001BF4
.text$di:00001BF4 ; Attributes: bp-based frame
.text$di:00001BF4
.text$di:00001BF4 ; void __cdecl `dynamic initializer for 'public: static class std::_Generic_error_category std::_Error_objects<int>::_Generic_object''(void)
.text$di:00001BF4 ??__E?_Generic_object@?$_Error_objects@H@std@@2V_Generic_error_category@2@A@@YAXXZ proc near
.text$di:00001BF4                                         ; DATA XREF: .CRT$XCU:void (*std::_Error_objects<int>::_Generic_object$initializer$)(void)o
.text$di:00001BF4                 push    ebp
.text$di:00001BF5                 mov     ebp, esp
.text$di:00001BF7                 mov     ecx, offset ?_Generic_object@?$_Error_objects@H@std@@2V_Generic_error_category@2@A ; this
.text$di:00001BFC                 call    ??0_Generic_error_category@std@@QAE@XZ ; std::_Generic_error_category::_Generic_error_category(void)
.text$di:00001C01                 push    offset ??__F?_Generic_object@?$_Error_objects@H@std@@2V_Generic_error_category@2@A@@YAXXZ ; void (__cdecl *)()
.text$di:00001C06                 call    _atexit
.text$di:00001C0B                 add     esp, 4
.text$di:00001C0E                 pop     ebp
.text$di:00001C0F                 retn
.text$di:00001C0F ??__E?_Generic_object@?$_Error_objects@H@std@@2V_Generic_error_category@2@A@@YAXXZ endp
.text$di:00001C0F
.text$di:00001C0F _text$di        ends
.text$di:00001C0F
.text$di:00001C10 ; ===========================================================================
.text$di:00001C10
.text$di:00001C10 ; Segment type: Pure code
.text$di:00001C10 ; Segment permissions: Read/Execute
.text$di:00001C10 _text$di        segment para public 'CODE' use32
.text$di:00001C10                 assume cs:_text$di
.text$di:00001C10                 ;org 1C10h
.text$di:00001C10 ; COMDAT (pick any)
.text$di:00001C10                 assume es:nothing, ss:nothing, ds:_data, fs:nothing, gs:nothing
.text$di:00001C10
.text$di:00001C10 ; =============== S U B R O U T I N E =======================================
.text$di:00001C10
.text$di:00001C10 ; Attributes: bp-based frame
.text$di:00001C10
.text$di:00001C10 ; void __cdecl `dynamic initializer for 'public: static class std::_Iostream_error_category std::_Error_objects<int>::_Iostream_object''(void)
.text$di:00001C10 ??__E?_Iostream_object@?$_Error_objects@H@std@@2V_Iostream_error_category@2@A@@YAXXZ proc near
.text$di:00001C10                                         ; DATA XREF: .CRT$XCU:void (*std::_Error_objects<int>::_Iostream_object$initializer$)(void)o
.text$di:00001C10                 push    ebp
.text$di:00001C11                 mov     ebp, esp
.text$di:00001C13                 mov     ecx, offset ?_Iostream_object@?$_Error_objects@H@std@@2V_Iostream_error_category@2@A ; this
.text$di:00001C18                 call    ??0_Iostream_error_category@std@@QAE@XZ ; std::_Iostream_error_category::_Iostream_error_category(void)
.text$di:00001C1D                 push    offset ??__F?_Iostream_object@?$_Error_objects@H@std@@2V_Iostream_error_category@2@A@@YAXXZ ; void (__cdecl *)()
.text$di:00001C22                 call    _atexit
.text$di:00001C27                 add     esp, 4
.text$di:00001C2A                 pop     ebp
.text$di:00001C2B                 retn
.text$di:00001C2B ??__E?_Iostream_object@?$_Error_objects@H@std@@2V_Iostream_error_category@2@A@@YAXXZ endp
.text$di:00001C2B
.text$di:00001C2B _text$di        ends
.text$di:00001C2B
.text$di:00001C2C ; ===========================================================================
.text$di:00001C2C
.text$di:00001C2C ; Segment type: Pure code
.text$di:00001C2C ; Segment permissions: Read/Execute
.text$di:00001C2C _text$di        segment para public 'CODE' use32
.text$di:00001C2C                 assume cs:_text$di
.text$di:00001C2C                 ;org 1C2Ch
.text$di:00001C2C ; COMDAT (pick any)
.text$di:00001C2C                 assume es:nothing, ss:nothing, ds:_data, fs:nothing, gs:nothing
.text$di:00001C2C
.text$di:00001C2C ; =============== S U B R O U T I N E =======================================
.text$di:00001C2C
.text$di:00001C2C ; Attributes: bp-based frame
.text$di:00001C2C
.text$di:00001C2C ; void __cdecl `dynamic initializer for 'public: static class std::_System_error_category std::_Error_objects<int>::_System_object''(void)
.text$di:00001C2C ??__E?_System_object@?$_Error_objects@H@std@@2V_System_error_category@2@A@@YAXXZ proc near
.text$di:00001C2C                                         ; DATA XREF: .CRT$XCU:void (*std::_Error_objects<int>::_System_object$initializer$)(void)o
.text$di:00001C2C                 push    ebp
.text$di:00001C2D                 mov     ebp, esp
.text$di:00001C2F                 mov     ecx, offset ?_System_object@?$_Error_objects@H@std@@2V_System_error_category@2@A ; this
.text$di:00001C34                 call    ??0_System_error_category@std@@QAE@XZ ; std::_System_error_category::_System_error_category(void)
.text$di:00001C39                 push    offset ??__F?_System_object@?$_Error_objects@H@std@@2V_System_error_category@2@A@@YAXXZ ; void (__cdecl *)()
.text$di:00001C3E                 call    _atexit
.text$di:00001C43                 add     esp, 4
.text$di:00001C46                 pop     ebp
.text$di:00001C47                 retn
.text$di:00001C47 ??__E?_System_object@?$_Error_objects@H@std@@2V_System_error_category@2@A@@YAXXZ endp
.text$di:00001C47
.text$di:00001C47 _text$di        ends
.text$di:00001C47
.text$di:00001C48 ; ===========================================================================
.text$di:00001C48
.text$di:00001C48 ; Segment type: Pure code
.text$di:00001C48 ; Segment permissions: Read/Execute
.text$di:00001C48 _text$di        segment para public 'CODE' use32
.text$di:00001C48                 assume cs:_text$di
.text$di:00001C48                 ;org 1C48h
.text$di:00001C48 ; COMDAT (pick any)
.text$di:00001C48                 assume es:nothing, ss:nothing, ds:_data, fs:nothing, gs:nothing
.text$di:00001C48
.text$di:00001C48 ; =============== S U B R O U T I N E =======================================
.text$di:00001C48
.text$di:00001C48 ; Attributes: bp-based frame
.text$di:00001C48
.text$di:00001C48 ; void __cdecl `dynamic initializer for 'public: static class std::locale::id std::num_put<char, class std::back_insert_iterator<class std::basic_string<char, struct std::char_traits<char>, class std::allocator<char>>>>::id''(void)
.text$di:00001C48 ??__E?id@?$num_put@DV?$back_insert_iterator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@std@@2V0locale@2@A@@YAXXZ proc near
.text$di:00001C48                                         ; DATA XREF: .CRT$XCU:void (*std::num_put<char,std::back_insert_iterator<std::basic_string<char,std::char_traits<char>,std::allocator<char>>>>::id$initializer$)(void)o
.text$di:00001C48                 push    ebp
.text$di:00001C49                 mov     ebp, esp
.text$di:00001C4B                 push    0               ; unsigned int
.text$di:00001C4D                 mov     ecx, offset ?id@?$num_put@DV?$back_insert_iterator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@std@@2V0locale@2@A ; this
.text$di:00001C52                 call    ??0id@locale@std@@QAE@I@Z ; std::locale::id::id(uint)
.text$di:00001C57                 pop     ebp
.text$di:00001C58                 retn
.text$di:00001C58 ??__E?id@?$num_put@DV?$back_insert_iterator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@std@@2V0locale@2@A@@YAXXZ endp
.text$di:00001C58
.text$di:00001C58 ; ---------------------------------------------------------------------------
.text$di:00001C59                 align 4
.text$di:00001C59 _text$di        ends
.text$di:00001C59
.text$di:00001C5C ; ===========================================================================
.text$di:00001C5C
.text$di:00001C5C ; Segment type: Pure code
.text$di:00001C5C ; Segment permissions: Read/Execute
.text$di:00001C5C _text$di        segment para public 'CODE' use32
.text$di:00001C5C                 assume cs:_text$di
.text$di:00001C5C                 ;org 1C5Ch
.text$di:00001C5C ; COMDAT (pick any)
.text$di:00001C5C                 assume es:nothing, ss:nothing, ds:_data, fs:nothing, gs:nothing
.text$di:00001C5C
.text$di:00001C5C ; =============== S U B R O U T I N E =======================================
.text$di:00001C5C
.text$di:00001C5C ; Attributes: bp-based frame
.text$di:00001C5C
.text$di:00001C5C ; void __cdecl `dynamic initializer for 'public: static class std::locale::id std::num_put<wchar_t, class std::back_insert_iterator<class std::basic_string<wchar_t, struct std::char_traits<wchar_t>, class std::allocator<wchar_t>>>>::id''(void)
.text$di:00001C5C ??__E?id@?$num_put@_WV?$back_insert_iterator@V?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@@std@@@std@@2V0locale@2@A@@YAXXZ proc near
.text$di:00001C5C                                         ; DATA XREF: .CRT$XCU:void (*std::num_put<wchar_t,std::back_insert_iterator<std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>>>>::id$initializer$)(void)o
.text$di:00001C5C                 push    ebp
.text$di:00001C5D                 mov     ebp, esp
.text$di:00001C5F                 push    0               ; unsigned int
.text$di:00001C61                 mov     ecx, offset ?id@?$num_put@_WV?$back_insert_iterator@V?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@@std@@@std@@2V0locale@2@A ; this
.text$di:00001C66                 call    ??0id@locale@std@@QAE@I@Z ; std::locale::id::id(uint)
.text$di:00001C6B                 pop     ebp
.text$di:00001C6C                 retn
.text$di:00001C6C ??__E?id@?$num_put@_WV?$back_insert_iterator@V?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@@std@@@std@@2V0locale@2@A@@YAXXZ endp
.text$di:00001C6C
.text$di:00001C6C ; ---------------------------------------------------------------------------
.text$di:00001C6D                 align 10h
.text$di:00001C6D _text$di        ends
.text$di:00001C6D
.text$di:00001C70 ; ===========================================================================
.text$di:00001C70
.text$di:00001C70 ; Segment type: Pure code
.text$di:00001C70 ; Segment permissions: Read/Execute
.text$di:00001C70 _text$di        segment para public 'CODE' use32
.text$di:00001C70                 assume cs:_text$di
.text$di:00001C70                 ;org 1C70h
.text$di:00001C70 ; COMDAT (pick any)
.text$di:00001C70                 assume es:nothing, ss:nothing, ds:_data, fs:nothing, gs:nothing
.text$di:00001C70
.text$di:00001C70 ; =============== S U B R O U T I N E =======================================
.text$di:00001C70
.text$di:00001C70 ; Attributes: bp-based frame
.text$di:00001C70
.text$di:00001C70 ; void __cdecl `dynamic initializer for 'public: static class std::locale::id std::numpunct<char>::id''(void)
.text$di:00001C70 ??__E?id@?$numpunct@D@std@@2V0locale@2@A@@YAXXZ proc near
.text$di:00001C70                                         ; DATA XREF: .CRT$XCU:void (*std::numpunct<char>::id$initializer$)(void)o
.text$di:00001C70                 push    ebp
.text$di:00001C71                 mov     ebp, esp
.text$di:00001C73                 push    0               ; unsigned int
.text$di:00001C75                 mov     ecx, offset ?id@?$numpunct@D@std@@2V0locale@2@A ; this
.text$di:00001C7A                 call    ??0id@locale@std@@QAE@I@Z ; std::locale::id::id(uint)
.text$di:00001C7F                 pop     ebp
.text$di:00001C80                 retn
.text$di:00001C80 ??__E?id@?$numpunct@D@std@@2V0locale@2@A@@YAXXZ endp
.text$di:00001C80
.text$di:00001C80 ; ---------------------------------------------------------------------------
.text$di:00001C81                 align 4
.text$di:00001C81 _text$di        ends
.text$di:00001C81
.text$di:00001C84 ; ===========================================================================
.text$di:00001C84
.text$di:00001C84 ; Segment type: Pure code
.text$di:00001C84 ; Segment permissions: Read/Execute
.text$di:00001C84 _text$di        segment para public 'CODE' use32
.text$di:00001C84                 assume cs:_text$di
.text$di:00001C84                 ;org 1C84h
.text$di:00001C84 ; COMDAT (pick any)
.text$di:00001C84                 assume es:nothing, ss:nothing, ds:_data, fs:nothing, gs:nothing
.text$di:00001C84
.text$di:00001C84 ; =============== S U B R O U T I N E =======================================
.text$di:00001C84
.text$di:00001C84 ; Attributes: bp-based frame
.text$di:00001C84
.text$di:00001C84 ; void __cdecl `dynamic initializer for 'public: static class std::locale::id std::numpunct<wchar_t>::id''(void)
.text$di:00001C84 ??__E?id@?$numpunct@_W@std@@2V0locale@2@A@@YAXXZ proc near
.text$di:00001C84                                         ; DATA XREF: .CRT$XCU:void (*std::numpunct<wchar_t>::id$initializer$)(void)o
.text$di:00001C84                 push    ebp
.text$di:00001C85                 mov     ebp, esp
.text$di:00001C87                 push    0               ; unsigned int
.text$di:00001C89                 mov     ecx, offset ?id@?$numpunct@_W@std@@2V0locale@2@A ; this
.text$di:00001C8E                 call    ??0id@locale@std@@QAE@I@Z ; std::locale::id::id(uint)
.text$di:00001C93                 pop     ebp
.text$di:00001C94                 retn
.text$di:00001C94 ??__E?id@?$numpunct@_W@std@@2V0locale@2@A@@YAXXZ endp
.text$di:00001C94
.text$di:00001C94 ; ---------------------------------------------------------------------------
.text$di:00001C95                 align 4
.text$di:00001C95 _text$di        ends
.text$di:00001C95
.text$di:00001C98 ; ===========================================================================
.text$di:00001C98
.text$di:00001C98 ; Segment type: Pure code
.text$di:00001C98 ; Segment permissions: Read/Execute
.text$di:00001C98 _text$di        segment para public 'CODE' use32
.text$di:00001C98                 assume cs:_text$di
.text$di:00001C98                 ;org 1C98h
.text$di:00001C98 ; COMDAT (pick any)
.text$di:00001C98                 assume es:nothing, ss:nothing, ds:_data, fs:nothing, gs:nothing
.text$di:00001C98
.text$di:00001C98 ; =============== S U B R O U T I N E =======================================
.text$di:00001C98
.text$di:00001C98 ; Attributes: bp-based frame
.text$di:00001C98
.text$di:00001C98 ; void __cdecl std::`dynamic initializer for '_Tuple_alloc''(void)
.text$di:00001C98 ??__E_Tuple_alloc@std@@YAXXZ proc near  ; DATA XREF: .CRT$XCU:__Tuple_alloc$initializer$o
.text$di:00001C98
.text$di:00001C98 var_1           = byte ptr -1
.text$di:00001C98
.text$di:00001C98                 push    ebp
.text$di:00001C99                 mov     ebp, esp
.text$di:00001C9B                 push    ecx
.text$di:00001C9C                 xor     eax, eax
.text$di:00001C9E                 mov     [ebp+var_1], al
.text$di:00001CA1                 mov     esp, ebp
.text$di:00001CA3                 pop     ebp
.text$di:00001CA4                 retn
.text$di:00001CA4 ??__E_Tuple_alloc@std@@YAXXZ endp
.text$di:00001CA4
.text$di:00001CA4 ; ---------------------------------------------------------------------------
.text$di:00001CA5                 align 4
.text$di:00001CA5 _text$di        ends
.text$di:00001CA5
.text$di:00001CA8 ; ===========================================================================
.text$di:00001CA8
.text$di:00001CA8 ; Segment type: Pure code
.text$di:00001CA8 ; Segment permissions: Read/Execute
.text$di:00001CA8 _text$di        segment para public 'CODE' use32
.text$di:00001CA8                 assume cs:_text$di
.text$di:00001CA8                 ;org 1CA8h
.text$di:00001CA8 ; COMDAT (pick any)
.text$di:00001CA8                 assume es:nothing, ss:nothing, ds:_data, fs:nothing, gs:nothing
.text$di:00001CA8
.text$di:00001CA8 ; =============== S U B R O U T I N E =======================================
.text$di:00001CA8
.text$di:00001CA8 ; Attributes: bp-based frame
.text$di:00001CA8
.text$di:00001CA8 ; void __cdecl std::`dynamic initializer for 'allocator_arg''(void)
.text$di:00001CA8 ??__Eallocator_arg@std@@YAXXZ proc near ; DATA XREF: .CRT$XCU:_allocator_arg$initializer$o
.text$di:00001CA8
.text$di:00001CA8 var_1           = byte ptr -1
.text$di:00001CA8
.text$di:00001CA8                 push    ebp
.text$di:00001CA9                 mov     ebp, esp
.text$di:00001CAB                 push    ecx
.text$di:00001CAC                 xor     eax, eax
.text$di:00001CAE                 mov     [ebp+var_1], al
.text$di:00001CB1                 mov     esp, ebp
.text$di:00001CB3                 pop     ebp
.text$di:00001CB4                 retn
.text$di:00001CB4 ??__Eallocator_arg@std@@YAXXZ endp
.text$di:00001CB4
.text$di:00001CB4 ; ---------------------------------------------------------------------------
.text$di:00001CB5                 align 4
.text$di:00001CB5 _text$di        ends
.text$di:00001CB5
.text$di:00001CB8 ; ===========================================================================
.text$di:00001CB8
.text$di:00001CB8 ; Segment type: Pure code
.text$di:00001CB8 ; Segment permissions: Read/Execute
.text$di:00001CB8 _text$di        segment para public 'CODE' use32
.text$di:00001CB8                 assume cs:_text$di
.text$di:00001CB8                 ;org 1CB8h
.text$di:00001CB8 ; COMDAT (pick any)
.text$di:00001CB8                 assume es:nothing, ss:nothing, ds:_data, fs:nothing, gs:nothing
.text$di:00001CB8
.text$di:00001CB8 ; =============== S U B R O U T I N E =======================================
.text$di:00001CB8
.text$di:00001CB8 ; Attributes: bp-based frame
.text$di:00001CB8
.text$di:00001CB8 ; void __cdecl std::`dynamic initializer for 'ignore''(void)
.text$di:00001CB8 ??__Eignore@std@@YAXXZ proc near        ; DATA XREF: .CRT$XCU:_ignore$initializer$o
.text$di:00001CB8                 push    ebp
.text$di:00001CB9                 mov     ebp, esp
.text$di:00001CBB                 mov     ecx, offset _ignore ; this
.text$di:00001CC0                 call    ??0_Ignore@std@@QAE@XZ ; std::_Ignore::_Ignore(void)
.text$di:00001CC5                 pop     ebp
.text$di:00001CC6                 retn
.text$di:00001CC6 ??__Eignore@std@@YAXXZ endp
.text$di:00001CC6
.text$di:00001CC6 ; ---------------------------------------------------------------------------
.text$di:00001CC7                 align 4
.text$di:00001CC7 _text$di        ends
.text$di:00001CC7
.text$di:00001CC8 ; ===========================================================================
.text$di:00001CC8
.text$di:00001CC8 ; Segment type: Pure code
.text$di:00001CC8 ; Segment permissions: Read/Execute
.text$di:00001CC8 _text$di        segment para public 'CODE' use32
.text$di:00001CC8                 assume cs:_text$di
.text$di:00001CC8                 ;org 1CC8h
.text$di:00001CC8 ; COMDAT (pick any)
.text$di:00001CC8                 assume es:nothing, ss:nothing, ds:_data, fs:nothing, gs:nothing
.text$di:00001CC8
.text$di:00001CC8 ; =============== S U B R O U T I N E =======================================
.text$di:00001CC8
.text$di:00001CC8 ; Attributes: bp-based frame
.text$di:00001CC8
.text$di:00001CC8 ; void __cdecl std::`dynamic initializer for 'piecewise_construct''(void)
.text$di:00001CC8 ??__Epiecewise_construct@std@@YAXXZ proc near
.text$di:00001CC8                                         ; DATA XREF: .CRT$XCU:_piecewise_construct$initializer$o
.text$di:00001CC8
.text$di:00001CC8 var_1           = byte ptr -1
.text$di:00001CC8
.text$di:00001CC8                 push    ebp
.text$di:00001CC9                 mov     ebp, esp
.text$di:00001CCB                 push    ecx
.text$di:00001CCC                 xor     eax, eax
.text$di:00001CCE                 mov     [ebp+var_1], al
.text$di:00001CD1                 mov     esp, ebp
.text$di:00001CD3                 pop     ebp
.text$di:00001CD4                 retn
.text$di:00001CD4 ??__Epiecewise_construct@std@@YAXXZ endp
.text$di:00001CD4
.text$di:00001CD4 ; ---------------------------------------------------------------------------
.text$di:00001CD5                 align 4
.text$di:00001CD5 _text$di        ends
.text$di:00001CD5
.text$yd:00001CD8 ; ===========================================================================
.text$yd:00001CD8
.text$yd:00001CD8 ; Segment type: Pure code
.text$yd:00001CD8 ; Segment permissions: Read/Execute
.text$yd:00001CD8 _text$yd        segment para public 'CODE' use32
.text$yd:00001CD8                 assume cs:_text$yd
.text$yd:00001CD8                 ;org 1CD8h
.text$yd:00001CD8 ; COMDAT (pick any)
.text$yd:00001CD8                 assume es:nothing, ss:nothing, ds:_data, fs:nothing, gs:nothing
.text$yd:00001CD8
.text$yd:00001CD8 ; =============== S U B R O U T I N E =======================================
.text$yd:00001CD8
.text$yd:00001CD8 ; Attributes: bp-based frame
.text$yd:00001CD8
.text$yd:00001CD8 ; void __cdecl `dynamic atexit destructor for 'public: static std::_Generic_error_category std::_Error_objects<int>::_Generic_object''()
.text$yd:00001CD8 ??__F?_Generic_object@?$_Error_objects@H@std@@2V_Generic_error_category@2@A@@YAXXZ proc near
.text$yd:00001CD8                                         ; DATA XREF: `dynamic initializer for 'std::_Generic_error_category std::_Error_objects<int>::_Generic_object''(void)+Do
.text$yd:00001CD8                 push    ebp
.text$yd:00001CD9                 mov     ebp, esp
.text$yd:00001CDB                 mov     ecx, offset ?_Generic_object@?$_Error_objects@H@std@@2V_Generic_error_category@2@A ; this
.text$yd:00001CE0                 call    ??1_Generic_error_category@std@@UAE@XZ ; std::_Generic_error_category::~_Generic_error_category(void)
.text$yd:00001CE5                 pop     ebp
.text$yd:00001CE6                 retn
.text$yd:00001CE6 ??__F?_Generic_object@?$_Error_objects@H@std@@2V_Generic_error_category@2@A@@YAXXZ endp
.text$yd:00001CE6
.text$yd:00001CE6 ; ---------------------------------------------------------------------------
.text$yd:00001CE7                 align 4
.text$yd:00001CE7 _text$yd        ends
.text$yd:00001CE7
.text$yd:00001CE8 ; ===========================================================================
.text$yd:00001CE8
.text$yd:00001CE8 ; Segment type: Pure code
.text$yd:00001CE8 ; Segment permissions: Read/Execute
.text$yd:00001CE8 _text$yd        segment para public 'CODE' use32
.text$yd:00001CE8                 assume cs:_text$yd
.text$yd:00001CE8                 ;org 1CE8h
.text$yd:00001CE8 ; COMDAT (pick any)
.text$yd:00001CE8                 assume es:nothing, ss:nothing, ds:_data, fs:nothing, gs:nothing
.text$yd:00001CE8
.text$yd:00001CE8 ; =============== S U B R O U T I N E =======================================
.text$yd:00001CE8
.text$yd:00001CE8 ; Attributes: bp-based frame
.text$yd:00001CE8
.text$yd:00001CE8 ; void __cdecl `dynamic atexit destructor for 'public: static std::_Iostream_error_category std::_Error_objects<int>::_Iostream_object''()
.text$yd:00001CE8 ??__F?_Iostream_object@?$_Error_objects@H@std@@2V_Iostream_error_category@2@A@@YAXXZ proc near
.text$yd:00001CE8                                         ; DATA XREF: `dynamic initializer for 'std::_Iostream_error_category std::_Error_objects<int>::_Iostream_object''(void)+Do
.text$yd:00001CE8                 push    ebp
.text$yd:00001CE9                 mov     ebp, esp
.text$yd:00001CEB                 mov     ecx, offset ?_Iostream_object@?$_Error_objects@H@std@@2V_Iostream_error_category@2@A ; this
.text$yd:00001CF0                 call    ??1_Iostream_error_category@std@@UAE@XZ ; std::_Iostream_error_category::~_Iostream_error_category(void)
.text$yd:00001CF5                 pop     ebp
.text$yd:00001CF6                 retn
.text$yd:00001CF6 ??__F?_Iostream_object@?$_Error_objects@H@std@@2V_Iostream_error_category@2@A@@YAXXZ endp
.text$yd:00001CF6
.text$yd:00001CF6 ; ---------------------------------------------------------------------------
.text$yd:00001CF7                 align 4
.text$yd:00001CF7 _text$yd        ends
.text$yd:00001CF7
.text$yd:00001CF8 ; ===========================================================================
.text$yd:00001CF8
.text$yd:00001CF8 ; Segment type: Pure code
.text$yd:00001CF8 ; Segment permissions: Read/Execute
.text$yd:00001CF8 _text$yd        segment para public 'CODE' use32
.text$yd:00001CF8                 assume cs:_text$yd
.text$yd:00001CF8                 ;org 1CF8h
.text$yd:00001CF8 ; COMDAT (pick any)
.text$yd:00001CF8                 assume es:nothing, ss:nothing, ds:_data, fs:nothing, gs:nothing
.text$yd:00001CF8
.text$yd:00001CF8 ; =============== S U B R O U T I N E =======================================
.text$yd:00001CF8
.text$yd:00001CF8 ; Attributes: bp-based frame
.text$yd:00001CF8
.text$yd:00001CF8 ; void __cdecl `dynamic atexit destructor for 'public: static std::_System_error_category std::_Error_objects<int>::_System_object''()
.text$yd:00001CF8 ??__F?_System_object@?$_Error_objects@H@std@@2V_System_error_category@2@A@@YAXXZ proc near
.text$yd:00001CF8                                         ; DATA XREF: `dynamic initializer for 'std::_System_error_category std::_Error_objects<int>::_System_object''(void)+Do
.text$yd:00001CF8                 push    ebp
.text$yd:00001CF9                 mov     ebp, esp
.text$yd:00001CFB                 mov     ecx, offset ?_System_object@?$_Error_objects@H@std@@2V_System_error_category@2@A ; this
.text$yd:00001D00                 call    ??1_System_error_category@std@@UAE@XZ ; std::_System_error_category::~_System_error_category(void)
.text$yd:00001D05                 pop     ebp
.text$yd:00001D06                 retn
.text$yd:00001D06 ??__F?_System_object@?$_Error_objects@H@std@@2V_System_error_category@2@A@@YAXXZ endp
.text$yd:00001D06
.text$yd:00001D06 ; ---------------------------------------------------------------------------
.text$yd:00001D07                 align 4
.text$yd:00001D07 _text$yd        ends
.text$yd:00001D07
.text$mn:00001D08 ; ===========================================================================
.text$mn:00001D08
.text$mn:00001D08 ; Segment type: Pure code
.text$mn:00001D08 ; Segment permissions: Read/Execute
.text$mn:00001D08 _text$mn        segment para public 'CODE' use32
.text$mn:00001D08                 assume cs:_text$mn
.text$mn:00001D08                 ;org 1D08h
.text$mn:00001D08 ; COMDAT (pick any)
.text$mn:00001D08                 assume es:nothing, ss:nothing, ds:_data, fs:nothing, gs:nothing
.text$mn:00001D08
.text$mn:00001D08 ; =============== S U B R O U T I N E =======================================
.text$mn:00001D08
.text$mn:00001D08 ; Attributes: bp-based frame
.text$mn:00001D08
.text$mn:00001D08 ; public: void __thiscall std::_String_alloc<0, struct std::_String_base_types<char, class std::allocator<char>>>::_Alloc_proxy(void)
.text$mn:00001D08                 public ?_Alloc_proxy@?$_String_alloc@$0A@U?$_String_base_types@DV?$allocator@D@std@@@std@@@std@@QAEXXZ
.text$mn:00001D08 ?_Alloc_proxy@?$_String_alloc@$0A@U?$_String_base_types@DV?$allocator@D@std@@@std@@@std@@QAEXXZ proc near
.text$mn:00001D08                                         ; CODE XREF: std::_String_alloc<0,std::_String_base_types<char,std::allocator<char>>>::_String_alloc<0,std::_String_base_types<char,std::allocator<char>>>(std::allocator<char> const &)+38p
.text$mn:00001D08
.text$mn:00001D08 var_10          = byte ptr -10h
.text$mn:00001D08 var_8           = dword ptr -8
.text$mn:00001D08 var_1           = byte ptr -1
.text$mn:00001D08
.text$mn:00001D08                 push    ebp
.text$mn:00001D09                 mov     ebp, esp
.text$mn:00001D0B                 sub     esp, 10h
.text$mn:00001D0E                 mov     [ebp+var_8], ecx
.text$mn:00001D11                 lea     ecx, [ebp+var_1]
.text$mn:00001D14                 call    ??0?$allocator@U_Container_proxy@std@@@std@@QAE@XZ ; std::allocator<std::_Container_proxy>::allocator<std::_Container_proxy>(void)
.text$mn:00001D19                 push    1
.text$mn:00001D1B                 lea     ecx, [ebp+var_1]
.text$mn:00001D1E                 call    ?allocate@?$allocator@U_Container_proxy@std@@@std@@QAEPAU_Container_proxy@2@I@Z ; std::allocator<std::_Container_proxy>::allocate(uint)
.text$mn:00001D23                 mov     ecx, [ebp+var_8]
.text$mn:00001D26                 mov     [ecx], eax
.text$mn:00001D28                 lea     ecx, [ebp+var_10] ; this
.text$mn:00001D2B                 call    ??0_Container_proxy@std@@QAE@XZ ; std::_Container_proxy::_Container_proxy(void)
.text$mn:00001D30                 push    eax             ; int
.text$mn:00001D31                 mov     edx, [ebp+var_8]
.text$mn:00001D34                 mov     eax, [edx]
.text$mn:00001D36                 push    eax             ; void *
.text$mn:00001D37                 lea     ecx, [ebp+var_1]
.text$mn:00001D3A                 call    ??$construct@U_Container_proxy@std@@U12@@?$allocator@U_Container_proxy@std@@@std@@QAEXPAU_Container_proxy@1@$$QAU21@@Z ; std::allocator<std::_Container_proxy>::construct<std::_Container_proxy,std::_Container_proxy>(std::_Container_proxy *,std::_Container_proxy &&)
.text$mn:00001D3F                 mov     ecx, [ebp+var_8]
.text$mn:00001D42                 mov     edx, [ecx]
.text$mn:00001D44                 mov     eax, [ebp+var_8]
.text$mn:00001D47                 mov     [edx], eax
.text$mn:00001D49                 mov     esp, ebp
.text$mn:00001D4B                 pop     ebp
.text$mn:00001D4C                 retn
.text$mn:00001D4C ?_Alloc_proxy@?$_String_alloc@$0A@U?$_String_base_types@DV?$allocator@D@std@@@std@@@std@@QAEXXZ endp
.text$mn:00001D4C
.text$mn:00001D4C ; ---------------------------------------------------------------------------
.text$mn:00001D4D                 align 10h
.text$mn:00001D4D _text$mn        ends
.text$mn:00001D4D
.text$mn:00001D50 ; ===========================================================================
.text$mn:00001D50
.text$mn:00001D50 ; Segment type: Pure code
.text$mn:00001D50 ; Segment permissions: Read/Execute
.text$mn:00001D50 _text$mn        segment para public 'CODE' use32
.text$mn:00001D50                 assume cs:_text$mn
.text$mn:00001D50                 ;org 1D50h
.text$mn:00001D50 ; COMDAT (pick any)
.text$mn:00001D50                 assume es:nothing, ss:nothing, ds:_data, fs:nothing, gs:nothing
.text$mn:00001D50
.text$mn:00001D50 ; =============== S U B R O U T I N E =======================================
.text$mn:00001D50
.text$mn:00001D50 ; Attributes: bp-based frame
.text$mn:00001D50
.text$mn:00001D50 ; public: void __thiscall std::basic_string<char, struct std::char_traits<char>, class std::allocator<char>>::_Copy(unsigned int, unsigned int)
.text$mn:00001D50                 public ?_Copy@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEXII@Z
.text$mn:00001D50 ?_Copy@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEXII@Z proc near
.text$mn:00001D50                                         ; CODE XREF: std::basic_string<char,std::char_traits<char>,std::allocator<char>>::_Grow(uint,bool)+37p
.text$mn:00001D50
.text$mn:00001D50 var_20          = dword ptr -20h
.text$mn:00001D50 var_1C          = dword ptr -1Ch
.text$mn:00001D50 var_18          = dword ptr -18h
.text$mn:00001D50 var_11          = byte ptr -11h
.text$mn:00001D50 var_10          = dword ptr -10h
.text$mn:00001D50 var_C           = byte ptr -0Ch
.text$mn:00001D50 var_4           = dword ptr -4
.text$mn:00001D50 arg_0           = dword ptr  8
.text$mn:00001D50
.text$mn:00001D50 ; FUNCTION CHUNK AT .text$mn:00001E72 SIZE 00000009 BYTES
.text$mn:00001D50
.text$mn:00001D50                 push    ebp
.text$mn:00001D51                 mov     ebp, esp
.text$mn:00001D53                 push    0FFFFFFFFh
.text$mn:00001D55                 push    offset __ehhandler$?_Copy@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEXII@Z
.text$mn:00001D5A                 mov     eax, large fs:0
.text$mn:00001D60                 push    eax
.text$mn:00001D61                 push    ecx
.text$mn:00001D62                 sub     esp, 10h
.text$mn:00001D65                 push    ebx
.text$mn:00001D66                 push    esi
.text$mn:00001D67                 push    edi
.text$mn:00001D68                 mov     eax, dword ptr ds:___security_cookie
.text$mn:00001D6D                 xor     eax, ebp
.text$mn:00001D6F                 push    eax
.text$mn:00001D70                 lea     eax, [ebp+var_C]
.text$mn:00001D73                 mov     large fs:0, eax
.text$mn:00001D79                 mov     [ebp+var_10], esp
.text$mn:00001D7C                 mov     [ebp+var_18], ecx
.text$mn:00001D7F                 mov     eax, [ebp+arg_0]
.text$mn:00001D82                 or      eax, 0Fh
.text$mn:00001D85                 mov     [ebp+var_1C], eax
.text$mn:00001D88                 mov     ecx, [ebp+var_18]
.text$mn:00001D8B                 call    ?max_size@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QBEIXZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char>>::max_size(void)
.text$mn:00001D90                 cmp     eax, [ebp+var_1C]
.text$mn:00001D93                 jnb     short loc_1D9D
.text$mn:00001D95                 mov     ecx, [ebp+arg_0]
.text$mn:00001D98                 mov     [ebp+var_1C], ecx
.text$mn:00001D9B                 jmp     short loc_1DEF
.text$mn:00001D9D ; ---------------------------------------------------------------------------
.text$mn:00001D9D
.text$mn:00001D9D loc_1D9D:                               ; CODE XREF: std::basic_string<char,std::char_traits<char>,std::allocator<char>>::_Copy(uint,uint)+43j
.text$mn:00001D9D                 mov     edx, [ebp+var_18]
.text$mn:00001DA0                 mov     ecx, [edx+18h]
.text$mn:00001DA3                 shr     ecx, 1
.text$mn:00001DA5                 mov     eax, [ebp+var_1C]
.text$mn:00001DA8                 xor     edx, edx
.text$mn:00001DAA                 mov     esi, 3
.text$mn:00001DAF                 div     esi
.text$mn:00001DB1                 cmp     ecx, eax
.text$mn:00001DB3                 ja      short loc_1DB7
.text$mn:00001DB5                 jmp     short loc_1DEF
.text$mn:00001DB7 ; ---------------------------------------------------------------------------
.text$mn:00001DB7
.text$mn:00001DB7 loc_1DB7:                               ; CODE XREF: std::basic_string<char,std::char_traits<char>,std::allocator<char>>::_Copy(uint,uint)+63j
.text$mn:00001DB7                 mov     ecx, [ebp+var_18]
.text$mn:00001DBA                 call    ?max_size@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QBEIXZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char>>::max_size(void)
.text$mn:00001DBF                 mov     edx, [ebp+var_18]
.text$mn:00001DC2                 mov     ecx, [edx+18h]
.text$mn:00001DC5                 shr     ecx, 1
.text$mn:00001DC7                 sub     eax, ecx
.text$mn:00001DC9                 mov     edx, [ebp+var_18]
.text$mn:00001DCC                 cmp     [edx+18h], eax
.text$mn:00001DCF                 ja      short loc_1DE4
.text$mn:00001DD1                 mov     eax, [ebp+var_18]
.text$mn:00001DD4                 mov     ecx, [eax+18h]
.text$mn:00001DD7                 shr     ecx, 1
.text$mn:00001DD9                 mov     edx, [ebp+var_18]
.text$mn:00001DDC                 add     ecx, [edx+18h]
.text$mn:00001DDF                 mov     [ebp+var_1C], ecx
.text$mn:00001DE2                 jmp     short loc_1DEF
.text$mn:00001DE4 ; ---------------------------------------------------------------------------
.text$mn:00001DE4
.text$mn:00001DE4 loc_1DE4:                               ; CODE XREF: std::basic_string<char,std::char_traits<char>,std::allocator<char>>::_Copy(uint,uint)+7Fj
.text$mn:00001DE4                 mov     ecx, [ebp+var_18]
.text$mn:00001DE7                 call    ?max_size@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QBEIXZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char>>::max_size(void)
.text$mn:00001DEC                 mov     [ebp+var_1C], eax
.text$mn:00001DEF
.text$mn:00001DEF loc_1DEF:                               ; CODE XREF: std::basic_string<char,std::char_traits<char>,std::allocator<char>>::_Copy(uint,uint)+4Bj
.text$mn:00001DEF                                         ; std::basic_string<char,std::char_traits<char>,std::allocator<char>>::_Copy(uint,uint)+65j ...
.text$mn:00001DEF                 mov     [ebp+var_4], 0
.text$mn:00001DF6                 mov     eax, [ebp+var_1C]
.text$mn:00001DF9                 add     eax, 1
.text$mn:00001DFC                 push    eax
.text$mn:00001DFD                 lea     ecx, [ebp+var_11]
.text$mn:00001E00                 push    ecx
.text$mn:00001E01                 mov     ecx, [ebp+var_18]
.text$mn:00001E04                 call    ?_Getal@?$_String_alloc@$0A@U?$_String_base_types@DV?$allocator@D@std@@@std@@@std@@QBE?AU?$_Wrap_alloc@V?$allocator@D@std@@@2@XZ ; std::_String_alloc<0,std::_String_base_types<char,std::allocator<char>>>::_Getal(void)
.text$mn:00001E09                 mov     ecx, eax
.text$mn:00001E0B                 call    ?allocate@?$_Wrap_alloc@V?$allocator@D@std@@@std@@QAEPADI@Z ; std::_Wrap_alloc<std::allocator<char>>::allocate(uint)
.text$mn:00001E10                 mov     [ebp+var_20], eax
.text$mn:00001E13                 jmp     short loc_1E72
.text$mn:00001E13 ?_Copy@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEXII@Z endp
.text$mn:00001E13
.text$mn:00001E15
.text$mn:00001E15 ; =============== S U B R O U T I N E =======================================
.text$mn:00001E15
.text$mn:00001E15
.text$mn:00001E15 __catch$?_Copy@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEXII@Z$0 proc near
.text$mn:00001E15                                         ; DATA XREF: .xdata$x:00002CACo
.text$mn:00001E15
.text$mn:00001E15 ; FUNCTION CHUNK AT .text$mn:00001E5C SIZE 00000009 BYTES
.text$mn:00001E15 ; FUNCTION CHUNK AT .text$mn:00001E6C SIZE 00000006 BYTES
.text$mn:00001E15
.text$mn:00001E15                 mov     [ebp-10h], esp
.text$mn:00001E18                 mov     edx, [ebp+8]
.text$mn:00001E1B                 mov     [ebp-1Ch], edx
.text$mn:00001E1E                 mov     byte ptr [ebp-4], 2
.text$mn:00001E22                 mov     eax, [ebp-1Ch]
.text$mn:00001E25                 add     eax, 1
.text$mn:00001E28                 push    eax
.text$mn:00001E29                 lea     ecx, [ebp-12h]
.text$mn:00001E2C                 push    ecx
.text$mn:00001E2D                 mov     ecx, [ebp-18h]
.text$mn:00001E30                 call    ?_Getal@?$_String_alloc@$0A@U?$_String_base_types@DV?$allocator@D@std@@@std@@@std@@QBE?AU?$_Wrap_alloc@V?$allocator@D@std@@@2@XZ ; std::_String_alloc<0,std::_String_base_types<char,std::allocator<char>>>::_Getal(void)
.text$mn:00001E35                 mov     ecx, eax
.text$mn:00001E37                 call    ?allocate@?$_Wrap_alloc@V?$allocator@D@std@@@std@@QAEPADI@Z ; std::_Wrap_alloc<std::allocator<char>>::allocate(uint)
.text$mn:00001E3C                 mov     [ebp-20h], eax
.text$mn:00001E3F                 jmp     short loc_1E5C
.text$mn:00001E3F __catch$?_Copy@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEXII@Z$0 endp
.text$mn:00001E3F
.text$mn:00001E41
.text$mn:00001E41 ; =============== S U B R O U T I N E =======================================
.text$mn:00001E41
.text$mn:00001E41 ; Attributes: noreturn
.text$mn:00001E41
.text$mn:00001E41 __catch$?_Copy@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEXII@Z$1 proc near
.text$mn:00001E41                                         ; DATA XREF: .xdata$x:00002CBCo
.text$mn:00001E41                 push    0               ; Size
.text$mn:00001E43                 push    1               ; char
.text$mn:00001E45                 mov     ecx, [ebp-18h]
.text$mn:00001E48                 call    ?_Tidy@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEX_NI@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char>>::_Tidy(bool,uint)
.text$mn:00001E4D                 push    0
.text$mn:00001E4F                 push    0
.text$mn:00001E51                 call    __CxxThrowException@8 ; _CxxThrowException(x,x)
.text$mn:00001E51 __catch$?_Copy@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEXII@Z$1 endp
.text$mn:00001E51
.text$mn:00001E56 ; ---------------------------------------------------------------------------
.text$mn:00001E56                 mov     eax, offset $LN17
.text$mn:00001E5B                 retn
.text$mn:00001E5C ; ---------------------------------------------------------------------------
.text$mn:00001E5C ; START OF FUNCTION CHUNK FOR __catch$?_Copy@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEXII@Z$0
.text$mn:00001E5C
.text$mn:00001E5C loc_1E5C:                               ; CODE XREF: __catch$?_Copy@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEXII@Z$0+2Aj
.text$mn:00001E5C                 mov     dword ptr [ebp-4], 1
.text$mn:00001E63                 jmp     short loc_1E6C
.text$mn:00001E63 ; END OF FUNCTION CHUNK FOR __catch$?_Copy@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEXII@Z$0
.text$mn:00001E65
.text$mn:00001E65 ; =============== S U B R O U T I N E =======================================
.text$mn:00001E65
.text$mn:00001E65
.text$mn:00001E65 $LN17           proc near               ; DATA XREF: .text$mn:00001E56o
.text$mn:00001E65                 mov     dword ptr [ebp-4], 1
.text$mn:00001E65 $LN17           endp ; sp-analysis failed
.text$mn:00001E65
.text$mn:00001E6C ; START OF FUNCTION CHUNK FOR __catch$?_Copy@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEXII@Z$0
.text$mn:00001E6C
.text$mn:00001E6C loc_1E6C:                               ; CODE XREF: __catch$?_Copy@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEXII@Z$0+4Ej
.text$mn:00001E6C                 mov     eax, offset $LN19
.text$mn:00001E71                 retn
.text$mn:00001E71 ; END OF FUNCTION CHUNK FOR __catch$?_Copy@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEXII@Z$0
.text$mn:00001E72 ; ---------------------------------------------------------------------------
.text$mn:00001E72 ; START OF FUNCTION CHUNK FOR ?_Copy@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEXII@Z
.text$mn:00001E72
.text$mn:00001E72 loc_1E72:                               ; CODE XREF: std::basic_string<char,std::char_traits<char>,std::allocator<char>>::_Copy(uint,uint)+C3j
.text$mn:00001E72                 mov     [ebp+var_4], 0FFFFFFFFh
.text$mn:00001E79                 jmp     short loc_1E82
.text$mn:00001E79 ; END OF FUNCTION CHUNK FOR ?_Copy@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEXII@Z
.text$mn:00001E7B
.text$mn:00001E7B ; =============== S U B R O U T I N E =======================================
.text$mn:00001E7B
.text$mn:00001E7B
.text$mn:00001E7B $LN19           proc near               ; DATA XREF: __catch$?_Copy@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEXII@Z$0:loc_1E6Co
.text$mn:00001E7B                 mov     dword ptr [ebp-4], 0FFFFFFFFh
.text$mn:00001E82
.text$mn:00001E82 loc_1E82:                               ; CODE XREF: std::basic_string<char,std::char_traits<char>,std::allocator<char>>::_Copy(uint,uint)+129j
.text$mn:00001E82                 cmp     dword ptr [ebp+0Ch], 0
.text$mn:00001E86                 jbe     short loc_1EA1
.text$mn:00001E88                 mov     edx, [ebp+0Ch]
.text$mn:00001E8B                 push    edx             ; Size
.text$mn:00001E8C                 mov     ecx, [ebp-18h]
.text$mn:00001E8F                 call    ?_Myptr@?$_String_val@U?$_Simple_types@D@std@@@std@@QAEPADXZ ; std::_String_val<std::_Simple_types<char>>::_Myptr(void)
.text$mn:00001E94                 push    eax             ; Src
.text$mn:00001E95                 mov     eax, [ebp-20h]
.text$mn:00001E98                 push    eax             ; Dst
.text$mn:00001E99                 call    ?copy@?$char_traits@D@std@@SAPADPADPBDI@Z ; std::char_traits<char>::copy(char *,char const *,uint)
.text$mn:00001E9E                 add     esp, 0Ch
.text$mn:00001EA1
.text$mn:00001EA1 loc_1EA1:                               ; CODE XREF: $LN19+Bj
.text$mn:00001EA1                 push    0               ; Size
.text$mn:00001EA3                 push    1               ; char
.text$mn:00001EA5                 mov     ecx, [ebp-18h]
.text$mn:00001EA8                 call    ?_Tidy@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEX_NI@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char>>::_Tidy(bool,uint)
.text$mn:00001EAD                 lea     ecx, [ebp-20h]
.text$mn:00001EB0                 push    ecx             ; int
.text$mn:00001EB1                 mov     edx, [ebp-18h]
.text$mn:00001EB4                 add     edx, 4
.text$mn:00001EB7                 push    edx             ; void *
.text$mn:00001EB8                 lea     eax, [ebp-13h]
.text$mn:00001EBB                 push    eax
.text$mn:00001EBC                 mov     ecx, [ebp-18h]
.text$mn:00001EBF                 call    ?_Getal@?$_String_alloc@$0A@U?$_String_base_types@DV?$allocator@D@std@@@std@@@std@@QBE?AU?$_Wrap_alloc@V?$allocator@D@std@@@2@XZ ; std::_String_alloc<0,std::_String_base_types<char,std::allocator<char>>>::_Getal(void)
.text$mn:00001EC4                 mov     ecx, eax
.text$mn:00001EC6                 call    ??$construct@PADAAPAD@?$_Wrap_alloc@V?$allocator@D@std@@@std@@QAEXPAPADAAPAD@Z ; std::_Wrap_alloc<std::allocator<char>>::construct<char *,char * &>(char * *,char * &)
.text$mn:00001ECB                 mov     ecx, [ebp-18h]
.text$mn:00001ECE                 mov     edx, [ebp-1Ch]
.text$mn:00001ED1                 mov     [ecx+18h], edx
.text$mn:00001ED4                 mov     eax, [ebp+0Ch]
.text$mn:00001ED7                 push    eax
.text$mn:00001ED8                 mov     ecx, [ebp-18h]
.text$mn:00001EDB                 call    ?_Eos@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEXI@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char>>::_Eos(uint)
.text$mn:00001EE0                 mov     ecx, [ebp-0Ch]
.text$mn:00001EE3                 mov     large fs:0, ecx
.text$mn:00001EEA                 pop     ecx
.text$mn:00001EEB                 pop     edi
.text$mn:00001EEC                 pop     esi
.text$mn:00001EED                 pop     ebx
.text$mn:00001EEE                 mov     esp, ebp
.text$mn:00001EF0                 pop     ebp
.text$mn:00001EF1                 retn    8
.text$mn:00001EF1 $LN19           endp ; sp-analysis failed
.text$mn:00001EF1
.text$mn:00001EF1 _text$mn        ends
.text$mn:00001EF1
.text$x:00001EF4 ; ===========================================================================
.text$x:00001EF4
.text$x:00001EF4 ; Segment type: Pure code
.text$x:00001EF4 ; Segment permissions: Read/Execute
.text$x:00001EF4 _text$x         segment para public 'CODE' use32
.text$x:00001EF4                 assume cs:_text$x
.text$x:00001EF4                 ;org 1EF4h
.text$x:00001EF4 ; COMDAT (pick associative to section at 1D50)
.text$x:00001EF4                 assume es:nothing, ss:nothing, ds:_data, fs:nothing, gs:nothing
.text$x:00001EF4
.text$x:00001EF4 ; =============== S U B R O U T I N E =======================================
.text$x:00001EF4
.text$x:00001EF4
.text$x:00001EF4 __ehhandler$?_Copy@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEXII@Z proc near
.text$x:00001EF4                                         ; DATA XREF: std::basic_string<char,std::char_traits<char>,std::allocator<char>>::_Copy(uint,uint)+5o
.text$x:00001EF4
.text$x:00001EF4 arg_4           = dword ptr  8
.text$x:00001EF4
.text$x:00001EF4                 mov     edx, [esp+arg_4]
.text$x:00001EF8                 lea     eax, [edx+0Ch]
.text$x:00001EFB                 mov     ecx, [edx-24h]
.text$x:00001EFE                 xor     ecx, eax
.text$x:00001F00                 call    @__security_check_cookie@4 ; __security_check_cookie(x)
.text$x:00001F05                 mov     eax, offset __ehfuncinfo$?_Copy@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEXII@Z
.text$x:00001F0A                 jmp     ___CxxFrameHandler3
.text$x:00001F0A __ehhandler$?_Copy@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEXII@Z endp
.text$x:00001F0A
.text$x:00001F0A ; ---------------------------------------------------------------------------
.text$x:00001F0F                 align 10h
.text$x:00001F0F _text$x         ends
.text$x:00001F0F
.text$mn:00001F10 ; ===========================================================================
.text$mn:00001F10
.text$mn:00001F10 ; Segment type: Pure code
.text$mn:00001F10 ; Segment permissions: Read/Execute
.text$mn:00001F10 _text$mn        segment para public 'CODE' use32
.text$mn:00001F10                 assume cs:_text$mn
.text$mn:00001F10                 ;org 1F10h
.text$mn:00001F10 ; COMDAT (pick any)
.text$mn:00001F10                 assume es:nothing, ss:nothing, ds:_data, fs:nothing, gs:nothing
.text$mn:00001F10
.text$mn:00001F10 ; =============== S U B R O U T I N E =======================================
.text$mn:00001F10
.text$mn:00001F10 ; Attributes: bp-based frame
.text$mn:00001F10
.text$mn:00001F10 ; public: void __thiscall std::basic_string<char, struct std::char_traits<char>, class std::allocator<char>>::_Eos(unsigned int)
.text$mn:00001F10                 public ?_Eos@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEXI@Z
.text$mn:00001F10 ?_Eos@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEXI@Z proc near
.text$mn:00001F10                                         ; CODE XREF: $LN19+60p
.text$mn:00001F10                                         ; std::basic_string<char,std::char_traits<char>,std::allocator<char>>::_Grow(uint,bool)+83p ...
.text$mn:00001F10
.text$mn:00001F10 var_8           = dword ptr -8
.text$mn:00001F10 var_1           = byte ptr -1
.text$mn:00001F10 arg_0           = dword ptr  8
.text$mn:00001F10
.text$mn:00001F10                 push    ebp
.text$mn:00001F11                 mov     ebp, esp
.text$mn:00001F13                 sub     esp, 8
.text$mn:00001F16                 mov     [ebp+var_8], ecx
.text$mn:00001F19                 mov     [ebp+var_1], 0
.text$mn:00001F1D                 mov     eax, [ebp+var_8]
.text$mn:00001F20                 mov     ecx, [ebp+arg_0]
.text$mn:00001F23                 mov     [eax+14h], ecx
.text$mn:00001F26                 lea     edx, [ebp+var_1]
.text$mn:00001F29                 push    edx
.text$mn:00001F2A                 mov     ecx, [ebp+var_8]
.text$mn:00001F2D                 call    ?_Myptr@?$_String_val@U?$_Simple_types@D@std@@@std@@QAEPADXZ ; std::_String_val<std::_Simple_types<char>>::_Myptr(void)
.text$mn:00001F32                 add     eax, [ebp+arg_0]
.text$mn:00001F35                 push    eax
.text$mn:00001F36                 call    ?assign@?$char_traits@D@std@@SAXAADABD@Z ; std::char_traits<char>::assign(char &,char const &)
.text$mn:00001F3B                 add     esp, 8
.text$mn:00001F3E                 mov     esp, ebp
.text$mn:00001F40                 pop     ebp
.text$mn:00001F41                 retn    4
.text$mn:00001F41 ?_Eos@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEXI@Z endp
.text$mn:00001F41
.text$mn:00001F41 _text$mn        ends
.text$mn:00001F41
.text$mn:00001F44 ; ===========================================================================
.text$mn:00001F44
.text$mn:00001F44 ; Segment type: Pure code
.text$mn:00001F44 ; Segment permissions: Read/Execute
.text$mn:00001F44 _text$mn        segment para public 'CODE' use32
.text$mn:00001F44                 assume cs:_text$mn
.text$mn:00001F44                 ;org 1F44h
.text$mn:00001F44 ; COMDAT (pick any)
.text$mn:00001F44                 assume es:nothing, ss:nothing, ds:_data, fs:nothing, gs:nothing
.text$mn:00001F44
.text$mn:00001F44 ; =============== S U B R O U T I N E =======================================
.text$mn:00001F44
.text$mn:00001F44 ; Attributes: bp-based frame
.text$mn:00001F44
.text$mn:00001F44 ; public: void __thiscall std::_String_alloc<0, struct std::_String_base_types<char, class std::allocator<char>>>::_Free_proxy(void)
.text$mn:00001F44                 public ?_Free_proxy@?$_String_alloc@$0A@U?$_String_base_types@DV?$allocator@D@std@@@std@@@std@@QAEXXZ
.text$mn:00001F44 ?_Free_proxy@?$_String_alloc@$0A@U?$_String_base_types@DV?$allocator@D@std@@@std@@@std@@QAEXXZ proc near
.text$mn:00001F44                                         ; CODE XREF: std::_String_alloc<0,std::_String_base_types<char,std::allocator<char>>>::~_String_alloc<0,std::_String_base_types<char,std::allocator<char>>>(void)+30p
.text$mn:00001F44
.text$mn:00001F44 var_8           = dword ptr -8
.text$mn:00001F44 var_1           = byte ptr -1
.text$mn:00001F44
.text$mn:00001F44                 push    ebp
.text$mn:00001F45                 mov     ebp, esp
.text$mn:00001F47                 sub     esp, 8
.text$mn:00001F4A                 mov     [ebp+var_8], ecx
.text$mn:00001F4D                 lea     ecx, [ebp+var_1]
.text$mn:00001F50                 call    ??0?$allocator@U_Container_proxy@std@@@std@@QAE@XZ ; std::allocator<std::_Container_proxy>::allocator<std::_Container_proxy>(void)
.text$mn:00001F55                 mov     ecx, [ebp+var_8] ; this
.text$mn:00001F58                 call    ?_Orphan_all@_Container_base12@std@@QAEXXZ ; std::_Container_base12::_Orphan_all(void)
.text$mn:00001F5D                 mov     eax, [ebp+var_8]
.text$mn:00001F60                 mov     ecx, [eax]
.text$mn:00001F62                 push    ecx
.text$mn:00001F63                 lea     ecx, [ebp+var_1]
.text$mn:00001F66                 call    ??$destroy@U_Container_proxy@std@@@?$allocator@U_Container_proxy@std@@@std@@QAEXPAU_Container_proxy@1@@Z ; std::allocator<std::_Container_proxy>::destroy<std::_Container_proxy>(std::_Container_proxy *)
.text$mn:00001F6B                 push    1               ; int
.text$mn:00001F6D                 mov     edx, [ebp+var_8]
.text$mn:00001F70                 mov     eax, [edx]
.text$mn:00001F72                 push    eax             ; void *
.text$mn:00001F73                 lea     ecx, [ebp+var_1]
.text$mn:00001F76                 call    ?deallocate@?$allocator@U_Container_proxy@std@@@std@@QAEXPAU_Container_proxy@2@I@Z ; std::allocator<std::_Container_proxy>::deallocate(std::_Container_proxy *,uint)
.text$mn:00001F7B                 mov     ecx, [ebp+var_8]
.text$mn:00001F7E                 mov     dword ptr [ecx], 0
.text$mn:00001F84                 mov     esp, ebp
.text$mn:00001F86                 pop     ebp
.text$mn:00001F87                 retn
.text$mn:00001F87 ?_Free_proxy@?$_String_alloc@$0A@U?$_String_base_types@DV?$allocator@D@std@@@std@@@std@@QAEXXZ endp
.text$mn:00001F87
.text$mn:00001F87 _text$mn        ends
.text$mn:00001F87
.text$mn:00001F88 ; ===========================================================================
.text$mn:00001F88
.text$mn:00001F88 ; Segment type: Pure code
.text$mn:00001F88 ; Segment permissions: Read/Execute
.text$mn:00001F88 _text$mn        segment para public 'CODE' use32
.text$mn:00001F88                 assume cs:_text$mn
.text$mn:00001F88                 ;org 1F88h
.text$mn:00001F88 ; COMDAT (pick any)
.text$mn:00001F88                 assume es:nothing, ss:nothing, ds:_data, fs:nothing, gs:nothing
.text$mn:00001F88
.text$mn:00001F88 ; =============== S U B R O U T I N E =======================================
.text$mn:00001F88
.text$mn:00001F88 ; Attributes: bp-based frame
.text$mn:00001F88
.text$mn:00001F88 ; public: struct std::_Wrap_alloc<class std::allocator<char>> __thiscall std::_String_alloc<0, struct std::_String_base_types<char, class std::allocator<char>>>::_Getal(void)const
.text$mn:00001F88                 public ?_Getal@?$_String_alloc@$0A@U?$_String_base_types@DV?$allocator@D@std@@@std@@@std@@QBE?AU?$_Wrap_alloc@V?$allocator@D@std@@@2@XZ
.text$mn:00001F88 ?_Getal@?$_String_alloc@$0A@U?$_String_base_types@DV?$allocator@D@std@@@std@@@std@@QBE?AU?$_Wrap_alloc@V?$allocator@D@std@@@2@XZ proc near
.text$mn:00001F88                                         ; CODE XREF: std::basic_string<char,std::char_traits<char>,std::allocator<char>>::_Copy(uint,uint)+B4p
.text$mn:00001F88                                         ; __catch$?_Copy@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEXII@Z$0+1Bp ...
.text$mn:00001F88
.text$mn:00001F88 var_4           = dword ptr -4
.text$mn:00001F88 arg_0           = dword ptr  8
.text$mn:00001F88
.text$mn:00001F88                 push    ebp
.text$mn:00001F89                 mov     ebp, esp
.text$mn:00001F8B                 push    ecx
.text$mn:00001F8C                 mov     [ebp+var_4], ecx
.text$mn:00001F8F                 mov     ecx, [ebp+arg_0]
.text$mn:00001F92                 call    ??0?$_Wrap_alloc@V?$allocator@D@std@@@std@@QAE@XZ ; std::_Wrap_alloc<std::allocator<char>>::_Wrap_alloc<std::allocator<char>>(void)
.text$mn:00001F97                 mov     eax, [ebp+arg_0]
.text$mn:00001F9A                 mov     esp, ebp
.text$mn:00001F9C                 pop     ebp
.text$mn:00001F9D                 retn    4
.text$mn:00001F9D ?_Getal@?$_String_alloc@$0A@U?$_String_base_types@DV?$allocator@D@std@@@std@@@std@@QBE?AU?$_Wrap_alloc@V?$allocator@D@std@@@2@XZ endp
.text$mn:00001F9D
.text$mn:00001F9D _text$mn        ends
.text$mn:00001F9D
.text$mn:00001FA0 ; ===========================================================================
.text$mn:00001FA0
.text$mn:00001FA0 ; Segment type: Pure code
.text$mn:00001FA0 ; Segment permissions: Read/Execute
.text$mn:00001FA0 _text$mn        segment para public 'CODE' use32
.text$mn:00001FA0                 assume cs:_text$mn
.text$mn:00001FA0                 ;org 1FA0h
.text$mn:00001FA0 ; COMDAT (pick any)
.text$mn:00001FA0                 assume es:nothing, ss:nothing, ds:_data, fs:nothing, gs:nothing
.text$mn:00001FA0
.text$mn:00001FA0 ; =============== S U B R O U T I N E =======================================
.text$mn:00001FA0
.text$mn:00001FA0 ; Attributes: bp-based frame
.text$mn:00001FA0
.text$mn:00001FA0 ; public: bool __thiscall std::basic_string<char, struct std::char_traits<char>, class std::allocator<char>>::_Grow(unsigned int, bool)
.text$mn:00001FA0                 public ?_Grow@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE_NI_N@Z
.text$mn:00001FA0 ?_Grow@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE_NI_N@Z proc near
.text$mn:00001FA0                                         ; CODE XREF: std::basic_string<char,std::char_traits<char>,std::allocator<char>>::assign(std::basic_string<char,std::char_traits<char>,std::allocator<char>> const &,uint,uint)+6Ap
.text$mn:00001FA0                                         ; std::basic_string<char,std::char_traits<char>,std::allocator<char>>::assign(char const *,uint)+5Fp
.text$mn:00001FA0
.text$mn:00001FA0 var_C           = dword ptr -0Ch
.text$mn:00001FA0 Size            = dword ptr -8
.text$mn:00001FA0 var_4           = dword ptr -4
.text$mn:00001FA0 arg_0           = dword ptr  8
.text$mn:00001FA0 arg_4           = byte ptr  0Ch
.text$mn:00001FA0
.text$mn:00001FA0                 push    ebp
.text$mn:00001FA1                 mov     ebp, esp
.text$mn:00001FA3                 sub     esp, 0Ch
.text$mn:00001FA6                 mov     [ebp+var_4], ecx
.text$mn:00001FA9                 mov     ecx, [ebp+var_4]
.text$mn:00001FAC                 call    ?max_size@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QBEIXZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char>>::max_size(void)
.text$mn:00001FB1                 cmp     eax, [ebp+arg_0]
.text$mn:00001FB4                 jnb     short loc_1FBE
.text$mn:00001FB6                 mov     ecx, [ebp+var_4]
.text$mn:00001FB9                 call    ?_Xlen@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QBEXXZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char>>::_Xlen(void)
.text$mn:00001FBE
.text$mn:00001FBE loc_1FBE:                               ; CODE XREF: std::basic_string<char,std::char_traits<char>,std::allocator<char>>::_Grow(uint,bool)+14j
.text$mn:00001FBE                 mov     eax, [ebp+var_4]
.text$mn:00001FC1                 mov     ecx, [eax+18h]
.text$mn:00001FC4                 cmp     ecx, [ebp+arg_0]
.text$mn:00001FC7                 jnb     short loc_1FDE
.text$mn:00001FC9                 mov     edx, [ebp+var_4]
.text$mn:00001FCC                 mov     eax, [edx+14h]
.text$mn:00001FCF                 push    eax
.text$mn:00001FD0                 mov     ecx, [ebp+arg_0]
.text$mn:00001FD3                 push    ecx
.text$mn:00001FD4                 mov     ecx, [ebp+var_4]
.text$mn:00001FD7                 call    ?_Copy@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEXII@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char>>::_Copy(uint,uint)
.text$mn:00001FDC                 jmp     short loc_2028
.text$mn:00001FDE ; ---------------------------------------------------------------------------
.text$mn:00001FDE
.text$mn:00001FDE loc_1FDE:                               ; CODE XREF: std::basic_string<char,std::char_traits<char>,std::allocator<char>>::_Grow(uint,bool)+27j
.text$mn:00001FDE                 movzx   edx, [ebp+arg_4]
.text$mn:00001FE2                 test    edx, edx
.text$mn:00001FE4                 jz      short loc_2018
.text$mn:00001FE6                 cmp     [ebp+arg_0], 10h
.text$mn:00001FEA                 jnb     short loc_2018
.text$mn:00001FEC                 mov     eax, [ebp+var_4]
.text$mn:00001FEF                 mov     ecx, [ebp+arg_0]
.text$mn:00001FF2                 cmp     ecx, [eax+14h]
.text$mn:00001FF5                 jnb     short loc_1FFF
.text$mn:00001FF7                 mov     edx, [ebp+arg_0]
.text$mn:00001FFA                 mov     [ebp+Size], edx
.text$mn:00001FFD                 jmp     short loc_2008
.text$mn:00001FFF ; ---------------------------------------------------------------------------
.text$mn:00001FFF
.text$mn:00001FFF loc_1FFF:                               ; CODE XREF: std::basic_string<char,std::char_traits<char>,std::allocator<char>>::_Grow(uint,bool)+55j
.text$mn:00001FFF                 mov     eax, [ebp+var_4]
.text$mn:00002002                 mov     ecx, [eax+14h]
.text$mn:00002005                 mov     [ebp+Size], ecx
.text$mn:00002008
.text$mn:00002008 loc_2008:                               ; CODE XREF: std::basic_string<char,std::char_traits<char>,std::allocator<char>>::_Grow(uint,bool)+5Dj
.text$mn:00002008                 mov     edx, [ebp+Size]
.text$mn:0000200B                 push    edx             ; Size
.text$mn:0000200C                 push    1               ; char
.text$mn:0000200E                 mov     ecx, [ebp+var_4]
.text$mn:00002011                 call    ?_Tidy@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEX_NI@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char>>::_Tidy(bool,uint)
.text$mn:00002016                 jmp     short loc_2028
.text$mn:00002018 ; ---------------------------------------------------------------------------
.text$mn:00002018
.text$mn:00002018 loc_2018:                               ; CODE XREF: std::basic_string<char,std::char_traits<char>,std::allocator<char>>::_Grow(uint,bool)+44j
.text$mn:00002018                                         ; std::basic_string<char,std::char_traits<char>,std::allocator<char>>::_Grow(uint,bool)+4Aj
.text$mn:00002018                 cmp     [ebp+arg_0], 0
.text$mn:0000201C                 jnz     short loc_2028
.text$mn:0000201E                 push    0
.text$mn:00002020                 mov     ecx, [ebp+var_4]
.text$mn:00002023                 call    ?_Eos@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEXI@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char>>::_Eos(uint)
.text$mn:00002028
.text$mn:00002028 loc_2028:                               ; CODE XREF: std::basic_string<char,std::char_traits<char>,std::allocator<char>>::_Grow(uint,bool)+3Cj
.text$mn:00002028                                         ; std::basic_string<char,std::char_traits<char>,std::allocator<char>>::_Grow(uint,bool)+76j ...
.text$mn:00002028                 cmp     [ebp+arg_0], 0
.text$mn:0000202C                 jbe     short loc_2037
.text$mn:0000202E                 mov     [ebp+var_C], 1
.text$mn:00002035                 jmp     short loc_203E
.text$mn:00002037 ; ---------------------------------------------------------------------------
.text$mn:00002037
.text$mn:00002037 loc_2037:                               ; CODE XREF: std::basic_string<char,std::char_traits<char>,std::allocator<char>>::_Grow(uint,bool)+8Cj
.text$mn:00002037                 mov     [ebp+var_C], 0
.text$mn:0000203E
.text$mn:0000203E loc_203E:                               ; CODE XREF: std::basic_string<char,std::char_traits<char>,std::allocator<char>>::_Grow(uint,bool)+95j
.text$mn:0000203E                 mov     al, byte ptr [ebp+var_C]
.text$mn:00002041                 mov     esp, ebp
.text$mn:00002043                 pop     ebp
.text$mn:00002044                 retn    8
.text$mn:00002044 ?_Grow@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE_NI_N@Z endp
.text$mn:00002044
.text$mn:00002044 ; ---------------------------------------------------------------------------
.text$mn:00002047                 align 4
.text$mn:00002047 _text$mn        ends
.text$mn:00002047
.text$mn:00002048 ; ===========================================================================
.text$mn:00002048
.text$mn:00002048 ; Segment type: Pure code
.text$mn:00002048 ; Segment permissions: Read/Execute
.text$mn:00002048 _text$mn        segment para public 'CODE' use32
.text$mn:00002048                 assume cs:_text$mn
.text$mn:00002048                 ;org 2048h
.text$mn:00002048 ; COMDAT (pick any)
.text$mn:00002048                 assume es:nothing, ss:nothing, ds:_data, fs:nothing, gs:nothing
.text$mn:00002048
.text$mn:00002048 ; =============== S U B R O U T I N E =======================================
.text$mn:00002048
.text$mn:00002048 ; Attributes: bp-based frame
.text$mn:00002048
.text$mn:00002048 ; public: bool __thiscall std::basic_string<char, struct std::char_traits<char>, class std::allocator<char>>::_Inside(char const *)
.text$mn:00002048                 public ?_Inside@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE_NPBD@Z
.text$mn:00002048 ?_Inside@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE_NPBD@Z proc near
.text$mn:00002048                                         ; CODE XREF: std::basic_string<char,std::char_traits<char>,std::allocator<char>>::assign(char const *,uint)+2Ap
.text$mn:00002048
.text$mn:00002048 var_4           = dword ptr -4
.text$mn:00002048 arg_0           = dword ptr  8
.text$mn:00002048
.text$mn:00002048                 push    ebp
.text$mn:00002049                 mov     ebp, esp
.text$mn:0000204B                 push    ecx
.text$mn:0000204C                 mov     [ebp+var_4], ecx
.text$mn:0000204F                 cmp     [ebp+arg_0], 0
.text$mn:00002053                 jz      short loc_2075
.text$mn:00002055                 mov     ecx, [ebp+var_4]
.text$mn:00002058                 call    ?_Myptr@?$_String_val@U?$_Simple_types@D@std@@@std@@QAEPADXZ ; std::_String_val<std::_Simple_types<char>>::_Myptr(void)
.text$mn:0000205D                 cmp     [ebp+arg_0], eax
.text$mn:00002060                 jb      short loc_2075
.text$mn:00002062                 mov     ecx, [ebp+var_4]
.text$mn:00002065                 call    ?_Myptr@?$_String_val@U?$_Simple_types@D@std@@@std@@QAEPADXZ ; std::_String_val<std::_Simple_types<char>>::_Myptr(void)
.text$mn:0000206A                 mov     ecx, [ebp+var_4]
.text$mn:0000206D                 add     eax, [ecx+14h]
.text$mn:00002070                 cmp     eax, [ebp+arg_0]
.text$mn:00002073                 ja      short loc_207B
.text$mn:00002075
.text$mn:00002075 loc_2075:                               ; CODE XREF: std::basic_string<char,std::char_traits<char>,std::allocator<char>>::_Inside(char const *)+Bj
.text$mn:00002075                                         ; std::basic_string<char,std::char_traits<char>,std::allocator<char>>::_Inside(char const *)+18j
.text$mn:00002075                 xor     al, al
.text$mn:00002077                 jmp     short loc_207D
.text$mn:00002079 ; ---------------------------------------------------------------------------
.text$mn:00002079                 jmp     short loc_207D
.text$mn:0000207B ; ---------------------------------------------------------------------------
.text$mn:0000207B
.text$mn:0000207B loc_207B:                               ; CODE XREF: std::basic_string<char,std::char_traits<char>,std::allocator<char>>::_Inside(char const *)+2Bj
.text$mn:0000207B                 mov     al, 1
.text$mn:0000207D
.text$mn:0000207D loc_207D:                               ; CODE XREF: std::basic_string<char,std::char_traits<char>,std::allocator<char>>::_Inside(char const *)+2Fj
.text$mn:0000207D                                         ; std::basic_string<char,std::char_traits<char>,std::allocator<char>>::_Inside(char const *)+31j
.text$mn:0000207D                 mov     esp, ebp
.text$mn:0000207F                 pop     ebp
.text$mn:00002080                 retn    4
.text$mn:00002080 ?_Inside@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE_NPBD@Z endp
.text$mn:00002080
.text$mn:00002080 ; ---------------------------------------------------------------------------
.text$mn:00002083                 align 4
.text$mn:00002083 _text$mn        ends
.text$mn:00002083
.text$mn:00002084 ; ===========================================================================
.text$mn:00002084
.text$mn:00002084 ; Segment type: Pure code
.text$mn:00002084 ; Segment permissions: Read/Execute
.text$mn:00002084 _text$mn        segment para public 'CODE' use32
.text$mn:00002084                 assume cs:_text$mn
.text$mn:00002084                 ;org 2084h
.text$mn:00002084 ; COMDAT (pick any)
.text$mn:00002084                 assume es:nothing, ss:nothing, ds:_data, fs:nothing, gs:nothing
.text$mn:00002084
.text$mn:00002084 ; =============== S U B R O U T I N E =======================================
.text$mn:00002084
.text$mn:00002084 ; Attributes: bp-based frame
.text$mn:00002084
.text$mn:00002084 ; public: char * __thiscall std::_String_val<struct std::_Simple_types<char>>::_Myptr(void)
.text$mn:00002084                 public ?_Myptr@?$_String_val@U?$_Simple_types@D@std@@@std@@QAEPADXZ
.text$mn:00002084 ?_Myptr@?$_String_val@U?$_Simple_types@D@std@@@std@@QAEPADXZ proc near
.text$mn:00002084                                         ; CODE XREF: $LN19+14p
.text$mn:00002084                                         ; std::basic_string<char,std::char_traits<char>,std::allocator<char>>::_Eos(uint)+1Dp ...
.text$mn:00002084
.text$mn:00002084 var_8           = dword ptr -8
.text$mn:00002084 var_4           = dword ptr -4
.text$mn:00002084
.text$mn:00002084                 push    ebp
.text$mn:00002085                 mov     ebp, esp
.text$mn:00002087                 sub     esp, 8
.text$mn:0000208A                 mov     [ebp+var_4], ecx
.text$mn:0000208D                 mov     eax, [ebp+var_4]
.text$mn:00002090                 cmp     dword ptr [eax+18h], 10h
.text$mn:00002094                 jb      short loc_20AA
.text$mn:00002096                 mov     ecx, [ebp+var_4]
.text$mn:00002099                 mov     edx, [ecx+4]
.text$mn:0000209C                 push    edx
.text$mn:0000209D                 call    ??$addressof@D@std@@YAPADAAD@Z ; std::addressof<char>(char &)
.text$mn:000020A2                 add     esp, 4
.text$mn:000020A5                 mov     [ebp+var_8], eax
.text$mn:000020A8                 jmp     short loc_20B3
.text$mn:000020AA ; ---------------------------------------------------------------------------
.text$mn:000020AA
.text$mn:000020AA loc_20AA:                               ; CODE XREF: std::_String_val<std::_Simple_types<char>>::_Myptr(void)+10j
.text$mn:000020AA                 mov     eax, [ebp+var_4]
.text$mn:000020AD                 add     eax, 4
.text$mn:000020B0                 mov     [ebp+var_8], eax
.text$mn:000020B3
.text$mn:000020B3 loc_20B3:                               ; CODE XREF: std::_String_val<std::_Simple_types<char>>::_Myptr(void)+24j
.text$mn:000020B3                 mov     eax, [ebp+var_8]
.text$mn:000020B6                 mov     esp, ebp
.text$mn:000020B8                 pop     ebp
.text$mn:000020B9                 retn
.text$mn:000020B9 ?_Myptr@?$_String_val@U?$_Simple_types@D@std@@@std@@QAEPADXZ endp
.text$mn:000020B9
.text$mn:000020B9 ; ---------------------------------------------------------------------------
.text$mn:000020BA                 align 4
.text$mn:000020BA _text$mn        ends
.text$mn:000020BA
.text$mn:000020BC ; ===========================================================================
.text$mn:000020BC
.text$mn:000020BC ; Segment type: Pure code
.text$mn:000020BC ; Segment permissions: Read/Execute
.text$mn:000020BC _text$mn        segment para public 'CODE' use32
.text$mn:000020BC                 assume cs:_text$mn
.text$mn:000020BC                 ;org 20BCh
.text$mn:000020BC ; COMDAT (pick any)
.text$mn:000020BC                 assume es:nothing, ss:nothing, ds:_data, fs:nothing, gs:nothing
.text$mn:000020BC
.text$mn:000020BC ; =============== S U B R O U T I N E =======================================
.text$mn:000020BC
.text$mn:000020BC ; Attributes: bp-based frame
.text$mn:000020BC
.text$mn:000020BC ; public: char const * __thiscall std::_String_val<struct std::_Simple_types<char>>::_Myptr(void)const
.text$mn:000020BC                 public ?_Myptr@?$_String_val@U?$_Simple_types@D@std@@@std@@QBEPBDXZ
.text$mn:000020BC ?_Myptr@?$_String_val@U?$_Simple_types@D@std@@@std@@QBEPBDXZ proc near
.text$mn:000020BC                                         ; CODE XREF: std::basic_string<char,std::char_traits<char>,std::allocator<char>>::assign(std::basic_string<char,std::char_traits<char>,std::allocator<char>> const &,uint,uint)+7Dp
.text$mn:000020BC
.text$mn:000020BC var_8           = dword ptr -8
.text$mn:000020BC var_4           = dword ptr -4
.text$mn:000020BC
.text$mn:000020BC                 push    ebp
.text$mn:000020BD                 mov     ebp, esp
.text$mn:000020BF                 sub     esp, 8
.text$mn:000020C2                 mov     [ebp+var_4], ecx
.text$mn:000020C5                 mov     eax, [ebp+var_4]
.text$mn:000020C8                 cmp     dword ptr [eax+18h], 10h
.text$mn:000020CC                 jb      short loc_20E2
.text$mn:000020CE                 mov     ecx, [ebp+var_4]
.text$mn:000020D1                 mov     edx, [ecx+4]
.text$mn:000020D4                 push    edx
.text$mn:000020D5                 call    ??$addressof@D@std@@YAPADAAD@Z ; std::addressof<char>(char &)
.text$mn:000020DA                 add     esp, 4
.text$mn:000020DD                 mov     [ebp+var_8], eax
.text$mn:000020E0                 jmp     short loc_20EB
.text$mn:000020E2 ; ---------------------------------------------------------------------------
.text$mn:000020E2
.text$mn:000020E2 loc_20E2:                               ; CODE XREF: std::_String_val<std::_Simple_types<char>>::_Myptr(void)+10j
.text$mn:000020E2                 mov     eax, [ebp+var_4]
.text$mn:000020E5                 add     eax, 4
.text$mn:000020E8                 mov     [ebp+var_8], eax
.text$mn:000020EB
.text$mn:000020EB loc_20EB:                               ; CODE XREF: std::_String_val<std::_Simple_types<char>>::_Myptr(void)+24j
.text$mn:000020EB                 mov     eax, [ebp+var_8]
.text$mn:000020EE                 mov     esp, ebp
.text$mn:000020F0                 pop     ebp
.text$mn:000020F1                 retn
.text$mn:000020F1 ?_Myptr@?$_String_val@U?$_Simple_types@D@std@@@std@@QBEPBDXZ endp
.text$mn:000020F1
.text$mn:000020F1 ; ---------------------------------------------------------------------------
.text$mn:000020F2                 align 4
.text$mn:000020F2 _text$mn        ends
.text$mn:000020F2
.text$mn:000020F4 ; ===========================================================================
.text$mn:000020F4
.text$mn:000020F4 ; Segment type: Pure code
.text$mn:000020F4 ; Segment permissions: Read/Execute
.text$mn:000020F4 _text$mn        segment para public 'CODE' use32
.text$mn:000020F4                 assume cs:_text$mn
.text$mn:000020F4                 ;org 20F4h
.text$mn:000020F4 ; COMDAT (pick any)
.text$mn:000020F4                 assume es:nothing, ss:nothing, ds:_data, fs:nothing, gs:nothing
.text$mn:000020F4
.text$mn:000020F4 ; =============== S U B R O U T I N E =======================================
.text$mn:000020F4
.text$mn:000020F4 ; Attributes: bp-based frame
.text$mn:000020F4
.text$mn:000020F4 ; void __thiscall std::_Container_base12::_Orphan_all(std::_Container_base12 *__hidden this)
.text$mn:000020F4                 public ?_Orphan_all@_Container_base12@std@@QAEXXZ
.text$mn:000020F4 ?_Orphan_all@_Container_base12@std@@QAEXXZ proc near
.text$mn:000020F4                                         ; CODE XREF: std::_Container_base12::~_Container_base12(void)+Ap
.text$mn:000020F4                                         ; std::_String_alloc<0,std::_String_base_types<char,std::allocator<char>>>::_Free_proxy(void)+14p
.text$mn:000020F4
.text$mn:000020F4 var_18          = byte ptr -18h
.text$mn:000020F4 var_14          = dword ptr -14h
.text$mn:000020F4 var_10          = dword ptr -10h
.text$mn:000020F4 var_C           = dword ptr -0Ch
.text$mn:000020F4 var_4           = dword ptr -4
.text$mn:000020F4
.text$mn:000020F4                 push    ebp
.text$mn:000020F5                 mov     ebp, esp
.text$mn:000020F7                 push    0FFFFFFFFh
.text$mn:000020F9                 push    offset __ehhandler$?_Orphan_all@_Container_base12@std@@QAEXXZ
.text$mn:000020FE                 mov     eax, large fs:0
.text$mn:00002104                 push    eax
.text$mn:00002105                 sub     esp, 0Ch
.text$mn:00002108                 mov     eax, dword ptr ds:___security_cookie
.text$mn:0000210D                 xor     eax, ebp
.text$mn:0000210F                 push    eax
.text$mn:00002110                 lea     eax, [ebp+var_C]
.text$mn:00002113                 mov     large fs:0, eax
.text$mn:00002119                 mov     [ebp+var_14], ecx
.text$mn:0000211C                 mov     eax, [ebp+var_14]
.text$mn:0000211F                 cmp     dword ptr [eax], 0
.text$mn:00002122                 jz      short loc_217F
.text$mn:00002124                 push    3               ; int
.text$mn:00002126                 lea     ecx, [ebp+var_18] ; this
.text$mn:00002129                 call    ??0_Lockit@std@@QAE@H@Z ; std::_Lockit::_Lockit(int)
.text$mn:0000212E                 mov     [ebp+var_4], 0
.text$mn:00002135                 mov     ecx, [ebp+var_14]
.text$mn:00002138                 mov     edx, [ecx]
.text$mn:0000213A                 add     edx, 4
.text$mn:0000213D                 mov     [ebp+var_10], edx
.text$mn:00002140                 jmp     short loc_214F
.text$mn:00002142 ; ---------------------------------------------------------------------------
.text$mn:00002142
.text$mn:00002142 loc_2142:                               ; CODE XREF: std::_Container_base12::_Orphan_all(void)+6Ej
.text$mn:00002142                 mov     eax, [ebp+var_10]
.text$mn:00002145                 mov     ecx, [eax]
.text$mn:00002147                 mov     edx, [ebp+var_10]
.text$mn:0000214A                 mov     eax, [ecx+4]
.text$mn:0000214D                 mov     [edx], eax
.text$mn:0000214F
.text$mn:0000214F loc_214F:                               ; CODE XREF: std::_Container_base12::_Orphan_all(void)+4Cj
.text$mn:0000214F                 mov     ecx, [ebp+var_10]
.text$mn:00002152                 cmp     dword ptr [ecx], 0
.text$mn:00002155                 jz      short loc_2164
.text$mn:00002157                 mov     edx, [ebp+var_10]
.text$mn:0000215A                 mov     eax, [edx]
.text$mn:0000215C                 mov     dword ptr [eax], 0
.text$mn:00002162                 jmp     short loc_2142
.text$mn:00002164 ; ---------------------------------------------------------------------------
.text$mn:00002164
.text$mn:00002164 loc_2164:                               ; CODE XREF: std::_Container_base12::_Orphan_all(void)+61j
.text$mn:00002164                 mov     ecx, [ebp+var_14]
.text$mn:00002167                 mov     edx, [ecx]
.text$mn:00002169                 mov     dword ptr [edx+4], 0
.text$mn:00002170                 mov     [ebp+var_4], 0FFFFFFFFh
.text$mn:00002177                 lea     ecx, [ebp+var_18] ; this
.text$mn:0000217A                 call    ??1_Lockit@std@@QAE@XZ ; std::_Lockit::~_Lockit(void)
.text$mn:0000217F
.text$mn:0000217F loc_217F:                               ; CODE XREF: std::_Container_base12::_Orphan_all(void)+2Ej
.text$mn:0000217F                 mov     ecx, [ebp+var_C]
.text$mn:00002182                 mov     large fs:0, ecx
.text$mn:00002189                 pop     ecx
.text$mn:0000218A                 mov     esp, ebp
.text$mn:0000218C                 pop     ebp
.text$mn:0000218D                 retn
.text$mn:0000218D ?_Orphan_all@_Container_base12@std@@QAEXXZ endp
.text$mn:0000218D
.text$mn:0000218D ; ---------------------------------------------------------------------------
.text$mn:0000218E                 align 10h
.text$mn:0000218E _text$mn        ends
.text$mn:0000218E
.text$x:00002190 ; ===========================================================================
.text$x:00002190
.text$x:00002190 ; Segment type: Pure code
.text$x:00002190 ; Segment permissions: Read/Execute
.text$x:00002190 _text$x         segment para public 'CODE' use32
.text$x:00002190                 assume cs:_text$x
.text$x:00002190                 ;org 2190h
.text$x:00002190 ; COMDAT (pick associative to section at 20F4)
.text$x:00002190                 assume es:nothing, ss:nothing, ds:_data, fs:nothing, gs:nothing
.text$x:00002190
.text$x:00002190 ; =============== S U B R O U T I N E =======================================
.text$x:00002190
.text$x:00002190
.text$x:00002190 __unwindfunclet$?_Orphan_all@_Container_base12@std@@QAEXXZ$0 proc near
.text$x:00002190                                         ; DATA XREF: .xdata$x:00002B70o
.text$x:00002190                 lea     ecx, [ebp-18h]  ; this
.text$x:00002193                 jmp     ??1_Lockit@std@@QAE@XZ ; std::_Lockit::~_Lockit(void)
.text$x:00002193 __unwindfunclet$?_Orphan_all@_Container_base12@std@@QAEXXZ$0 endp
.text$x:00002193
.text$x:00002198
.text$x:00002198 ; =============== S U B R O U T I N E =======================================
.text$x:00002198
.text$x:00002198
.text$x:00002198 __ehhandler$?_Orphan_all@_Container_base12@std@@QAEXXZ proc near
.text$x:00002198                                         ; DATA XREF: std::_Container_base12::_Orphan_all(void)+5o
.text$x:00002198
.text$x:00002198 arg_4           = dword ptr  8
.text$x:00002198
.text$x:00002198                 mov     edx, [esp+arg_4]
.text$x:0000219C                 lea     eax, [edx+0Ch]
.text$x:0000219F                 mov     ecx, [edx-10h]
.text$x:000021A2                 xor     ecx, eax
.text$x:000021A4                 call    @__security_check_cookie@4 ; __security_check_cookie(x)
.text$x:000021A9                 mov     eax, offset __ehfuncinfo$?_Orphan_all@_Container_base12@std@@QAEXXZ
.text$x:000021AE                 jmp     ___CxxFrameHandler3
.text$x:000021AE __ehhandler$?_Orphan_all@_Container_base12@std@@QAEXXZ endp
.text$x:000021AE
.text$x:000021AE ; ---------------------------------------------------------------------------
.text$x:000021B3                 align 4
.text$x:000021B3 _text$x         ends
.text$x:000021B3
.text$mn:000021B4 ; ===========================================================================
.text$mn:000021B4
.text$mn:000021B4 ; Segment type: Pure code
.text$mn:000021B4 ; Segment permissions: Read/Execute
.text$mn:000021B4 _text$mn        segment para public 'CODE' use32
.text$mn:000021B4                 assume cs:_text$mn
.text$mn:000021B4                 ;org 21B4h
.text$mn:000021B4 ; COMDAT (pick any)
.text$mn:000021B4                 assume es:nothing, ss:nothing, ds:_data, fs:nothing, gs:nothing
.text$mn:000021B4
.text$mn:000021B4 ; =============== S U B R O U T I N E =======================================
.text$mn:000021B4
.text$mn:000021B4 ; Attributes: bp-based frame
.text$mn:000021B4
.text$mn:000021B4 ; int __stdcall std::basic_string<char,std::char_traits<char>,std::allocator<char>>::_Tidy(char, size_t Size)
.text$mn:000021B4                 public ?_Tidy@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEX_NI@Z
.text$mn:000021B4 ?_Tidy@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEX_NI@Z proc near
.text$mn:000021B4                                         ; CODE XREF: std::basic_string<char,std::char_traits<char>,std::allocator<char>>::basic_string<char,std::char_traits<char>,std::allocator<char>>(char const *)+47p
.text$mn:000021B4                                         ; std::basic_string<char,std::char_traits<char>,std::allocator<char>>::~basic_string<char,std::char_traits<char>,std::allocator<char>>(void)+34p ...
.text$mn:000021B4
.text$mn:000021B4 var_C           = dword ptr -0Ch
.text$mn:000021B4 var_8           = dword ptr -8
.text$mn:000021B4 var_2           = byte ptr -2
.text$mn:000021B4 var_1           = byte ptr -1
.text$mn:000021B4 arg_0           = byte ptr  8
.text$mn:000021B4 Size            = dword ptr  0Ch
.text$mn:000021B4
.text$mn:000021B4                 push    ebp
.text$mn:000021B5                 mov     ebp, esp
.text$mn:000021B7                 sub     esp, 0Ch
.text$mn:000021BA                 mov     [ebp+var_8], ecx
.text$mn:000021BD                 movzx   eax, [ebp+arg_0]
.text$mn:000021C1                 test    eax, eax
.text$mn:000021C3                 jnz     short loc_21C7
.text$mn:000021C5                 jmp     short loc_223A
.text$mn:000021C7 ; ---------------------------------------------------------------------------
.text$mn:000021C7
.text$mn:000021C7 loc_21C7:                               ; CODE XREF: std::basic_string<char,std::char_traits<char>,std::allocator<char>>::_Tidy(bool,uint)+Fj
.text$mn:000021C7                 mov     ecx, [ebp+var_8]
.text$mn:000021CA                 cmp     dword ptr [ecx+18h], 10h
.text$mn:000021CE                 jb      short loc_223A
.text$mn:000021D0                 mov     edx, [ebp+var_8]
.text$mn:000021D3                 mov     eax, [edx+4]
.text$mn:000021D6                 mov     [ebp+var_C], eax
.text$mn:000021D9                 mov     ecx, [ebp+var_8]
.text$mn:000021DC                 add     ecx, 4
.text$mn:000021DF                 push    ecx
.text$mn:000021E0                 lea     edx, [ebp+var_1]
.text$mn:000021E3                 push    edx
.text$mn:000021E4                 mov     ecx, [ebp+var_8]
.text$mn:000021E7                 call    ?_Getal@?$_String_alloc@$0A@U?$_String_base_types@DV?$allocator@D@std@@@std@@@std@@QBE?AU?$_Wrap_alloc@V?$allocator@D@std@@@2@XZ ; std::_String_alloc<0,std::_String_base_types<char,std::allocator<char>>>::_Getal(void)
.text$mn:000021EC                 mov     ecx, eax
.text$mn:000021EE                 call    ??$destroy@PAD@?$_Wrap_alloc@V?$allocator@D@std@@@std@@QAEXPAPAD@Z ; std::_Wrap_alloc<std::allocator<char>>::destroy<char *>(char * *)
.text$mn:000021F3                 cmp     [ebp+Size], 0
.text$mn:000021F7                 jbe     short loc_2219
.text$mn:000021F9                 mov     eax, [ebp+Size]
.text$mn:000021FC                 push    eax             ; Size
.text$mn:000021FD                 mov     ecx, [ebp+var_C]
.text$mn:00002200                 push    ecx
.text$mn:00002201                 call    ??$addressof@D@std@@YAPADAAD@Z ; std::addressof<char>(char &)
.text$mn:00002206                 add     esp, 4
.text$mn:00002209                 push    eax             ; Src
.text$mn:0000220A                 mov     edx, [ebp+var_8]
.text$mn:0000220D                 add     edx, 4
.text$mn:00002210                 push    edx             ; Dst
.text$mn:00002211                 call    ?copy@?$char_traits@D@std@@SAPADPADPBDI@Z ; std::char_traits<char>::copy(char *,char const *,uint)
.text$mn:00002216                 add     esp, 0Ch
.text$mn:00002219
.text$mn:00002219 loc_2219:                               ; CODE XREF: std::basic_string<char,std::char_traits<char>,std::allocator<char>>::_Tidy(bool,uint)+43j
.text$mn:00002219                 mov     eax, [ebp+var_8]
.text$mn:0000221C                 mov     ecx, [eax+18h]
.text$mn:0000221F                 add     ecx, 1
.text$mn:00002222                 push    ecx             ; int
.text$mn:00002223                 mov     edx, [ebp+var_C]
.text$mn:00002226                 push    edx             ; void *
.text$mn:00002227                 lea     eax, [ebp+var_2]
.text$mn:0000222A                 push    eax
.text$mn:0000222B                 mov     ecx, [ebp+var_8]
.text$mn:0000222E                 call    ?_Getal@?$_String_alloc@$0A@U?$_String_base_types@DV?$allocator@D@std@@@std@@@std@@QBE?AU?$_Wrap_alloc@V?$allocator@D@std@@@2@XZ ; std::_String_alloc<0,std::_String_base_types<char,std::allocator<char>>>::_Getal(void)
.text$mn:00002233                 mov     ecx, eax
.text$mn:00002235                 call    ?deallocate@?$_Wrap_alloc@V?$allocator@D@std@@@std@@QAEXPADI@Z ; std::_Wrap_alloc<std::allocator<char>>::deallocate(char *,uint)
.text$mn:0000223A
.text$mn:0000223A loc_223A:                               ; CODE XREF: std::basic_string<char,std::char_traits<char>,std::allocator<char>>::_Tidy(bool,uint)+11j
.text$mn:0000223A                                         ; std::basic_string<char,std::char_traits<char>,std::allocator<char>>::_Tidy(bool,uint)+1Aj
.text$mn:0000223A                 mov     ecx, [ebp+var_8]
.text$mn:0000223D                 mov     dword ptr [ecx+18h], 0Fh
.text$mn:00002244                 mov     edx, [ebp+Size]
.text$mn:00002247                 push    edx
.text$mn:00002248                 mov     ecx, [ebp+var_8]
.text$mn:0000224B                 call    ?_Eos@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEXI@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char>>::_Eos(uint)
.text$mn:00002250                 mov     esp, ebp
.text$mn:00002252                 pop     ebp
.text$mn:00002253                 retn    8
.text$mn:00002253 ?_Tidy@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEX_NI@Z endp
.text$mn:00002253
.text$mn:00002253 ; ---------------------------------------------------------------------------
.text$mn:00002256                 align 4
.text$mn:00002256 _text$mn        ends
.text$mn:00002256
.text$mn:00002258 ; ===========================================================================
.text$mn:00002258
.text$mn:00002258 ; Segment type: Pure code
.text$mn:00002258 ; Segment permissions: Read/Execute
.text$mn:00002258 _text$mn        segment para public 'CODE' use32
.text$mn:00002258                 assume cs:_text$mn
.text$mn:00002258                 ;org 2258h
.text$mn:00002258 ; COMDAT (pick any)
.text$mn:00002258                 assume es:nothing, ss:nothing, ds:_data, fs:nothing, gs:nothing
.text$mn:00002258
.text$mn:00002258 ; =============== S U B R O U T I N E =======================================
.text$mn:00002258
.text$mn:00002258 ; Attributes: bp-based frame
.text$mn:00002258
.text$mn:00002258 ; public: void __thiscall std::basic_string<char, struct std::char_traits<char>, class std::allocator<char>>::_Xlen(void)const
.text$mn:00002258                 public ?_Xlen@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QBEXXZ
.text$mn:00002258 ?_Xlen@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QBEXXZ proc near
.text$mn:00002258                                         ; CODE XREF: std::basic_string<char,std::char_traits<char>,std::allocator<char>>::_Grow(uint,bool)+19p
.text$mn:00002258
.text$mn:00002258 var_4           = dword ptr -4
.text$mn:00002258
.text$mn:00002258                 push    ebp
.text$mn:00002259                 mov     ebp, esp
.text$mn:0000225B                 push    ecx
.text$mn:0000225C                 mov     [ebp+var_4], ecx
.text$mn:0000225F                 push    offset ??_C@_0BA@JFNIOLAK@string?5too?5long?$AA@ ; "string too long"
.text$mn:00002264                 call    ?_Xlength_error@std@@YAXPBD@Z ; std::_Xlength_error(char const *)
.text$mn:00002269                 mov     esp, ebp
.text$mn:0000226B                 pop     ebp
.text$mn:0000226C                 retn
.text$mn:0000226C ?_Xlen@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QBEXXZ endp
.text$mn:0000226C
.text$mn:0000226C ; ---------------------------------------------------------------------------
.text$mn:0000226D                 align 10h
.text$mn:0000226D _text$mn        ends
.text$mn:0000226D
.text$mn:00002270 ; ===========================================================================
.text$mn:00002270
.text$mn:00002270 ; Segment type: Pure code
.text$mn:00002270 ; Segment permissions: Read/Execute
.text$mn:00002270 _text$mn        segment para public 'CODE' use32
.text$mn:00002270                 assume cs:_text$mn
.text$mn:00002270                 ;org 2270h
.text$mn:00002270 ; COMDAT (pick any)
.text$mn:00002270                 assume es:nothing, ss:nothing, ds:_data, fs:nothing, gs:nothing
.text$mn:00002270
.text$mn:00002270 ; =============== S U B R O U T I N E =======================================
.text$mn:00002270
.text$mn:00002270 ; Attributes: bp-based frame
.text$mn:00002270
.text$mn:00002270 ; public: void __thiscall std::basic_string<char, struct std::char_traits<char>, class std::allocator<char>>::_Xran(void)const
.text$mn:00002270                 public ?_Xran@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QBEXXZ
.text$mn:00002270 ?_Xran@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QBEXXZ proc near
.text$mn:00002270                                         ; CODE XREF: std::basic_string<char,std::char_traits<char>,std::allocator<char>>::assign(std::basic_string<char,std::char_traits<char>,std::allocator<char>> const &,uint,uint)+19p
.text$mn:00002270                                         ; std::basic_string<char,std::char_traits<char>,std::allocator<char>>::erase(uint)+15p ...
.text$mn:00002270
.text$mn:00002270 var_4           = dword ptr -4
.text$mn:00002270
.text$mn:00002270                 push    ebp
.text$mn:00002271                 mov     ebp, esp
.text$mn:00002273                 push    ecx
.text$mn:00002274                 mov     [ebp+var_4], ecx
.text$mn:00002277                 push    offset ??_C@_0BI@CFPLBAOH@invalid?5string?5position?$AA@ ; "invalid string position"
.text$mn:0000227C                 call    ?_Xout_of_range@std@@YAXPBD@Z ; std::_Xout_of_range(char const *)
.text$mn:00002281                 mov     esp, ebp
.text$mn:00002283                 pop     ebp
.text$mn:00002284                 retn
.text$mn:00002284 ?_Xran@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QBEXXZ endp
.text$mn:00002284
.text$mn:00002284 ; ---------------------------------------------------------------------------
.text$mn:00002285                 align 4
.text$mn:00002285 _text$mn        ends
.text$mn:00002285
.text$mn:00002288 ; ===========================================================================
.text$mn:00002288
.text$mn:00002288 ; Segment type: Pure code
.text$mn:00002288 ; Segment permissions: Read/Execute
.text$mn:00002288 _text$mn        segment para public 'CODE' use32
.text$mn:00002288                 assume cs:_text$mn
.text$mn:00002288                 ;org 2288h
.text$mn:00002288 ; COMDAT (pick any)
.text$mn:00002288                 assume es:nothing, ss:nothing, ds:_data, fs:nothing, gs:nothing
.text$mn:00002288
.text$mn:00002288 ; =============== S U B R O U T I N E =======================================
.text$mn:00002288
.text$mn:00002288 ; Attributes: bp-based frame
.text$mn:00002288
.text$mn:00002288 ; public: char * __thiscall std::_Wrap_alloc<class std::allocator<char>>::allocate(unsigned int)
.text$mn:00002288                 public ?allocate@?$_Wrap_alloc@V?$allocator@D@std@@@std@@QAEPADI@Z
.text$mn:00002288 ?allocate@?$_Wrap_alloc@V?$allocator@D@std@@@std@@QAEPADI@Z proc near
.text$mn:00002288                                         ; CODE XREF: std::basic_string<char,std::char_traits<char>,std::allocator<char>>::_Copy(uint,uint)+BBp
.text$mn:00002288                                         ; __catch$?_Copy@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEXII@Z$0+22p
.text$mn:00002288
.text$mn:00002288 var_4           = dword ptr -4
.text$mn:00002288 arg_0           = dword ptr  8
.text$mn:00002288
.text$mn:00002288                 push    ebp
.text$mn:00002289                 mov     ebp, esp
.text$mn:0000228B                 push    ecx
.text$mn:0000228C                 mov     [ebp+var_4], ecx
.text$mn:0000228F                 mov     eax, [ebp+arg_0]
.text$mn:00002292                 push    eax
.text$mn:00002293                 mov     ecx, [ebp+var_4]
.text$mn:00002296                 call    ?allocate@?$allocator@D@std@@QAEPADI@Z ; std::allocator<char>::allocate(uint)
.text$mn:0000229B                 mov     esp, ebp
.text$mn:0000229D                 pop     ebp
.text$mn:0000229E                 retn    4
.text$mn:0000229E ?allocate@?$_Wrap_alloc@V?$allocator@D@std@@@std@@QAEPADI@Z endp
.text$mn:0000229E
.text$mn:0000229E ; ---------------------------------------------------------------------------
.text$mn:000022A1                 align 4
.text$mn:000022A1 _text$mn        ends
.text$mn:000022A1
.text$mn:000022A4 ; ===========================================================================
.text$mn:000022A4
.text$mn:000022A4 ; Segment type: Pure code
.text$mn:000022A4 ; Segment permissions: Read/Execute
.text$mn:000022A4 _text$mn        segment para public 'CODE' use32
.text$mn:000022A4                 assume cs:_text$mn
.text$mn:000022A4                 ;org 22A4h
.text$mn:000022A4 ; COMDAT (pick any)
.text$mn:000022A4                 assume es:nothing, ss:nothing, ds:_data, fs:nothing, gs:nothing
.text$mn:000022A4
.text$mn:000022A4 ; =============== S U B R O U T I N E =======================================
.text$mn:000022A4
.text$mn:000022A4 ; Attributes: bp-based frame
.text$mn:000022A4
.text$mn:000022A4 ; public: char * __thiscall std::allocator<char>::allocate(unsigned int)
.text$mn:000022A4                 public ?allocate@?$allocator@D@std@@QAEPADI@Z
.text$mn:000022A4 ?allocate@?$allocator@D@std@@QAEPADI@Z proc near
.text$mn:000022A4                                         ; CODE XREF: std::_Wrap_alloc<std::allocator<char>>::allocate(uint)+Ep
.text$mn:000022A4
.text$mn:000022A4 var_4           = dword ptr -4
.text$mn:000022A4 arg_0           = dword ptr  8
.text$mn:000022A4
.text$mn:000022A4                 push    ebp
.text$mn:000022A5                 mov     ebp, esp
.text$mn:000022A7                 push    ecx
.text$mn:000022A8                 mov     [ebp+var_4], ecx
.text$mn:000022AB                 push    0
.text$mn:000022AD                 mov     eax, [ebp+arg_0]
.text$mn:000022B0                 push    eax
.text$mn:000022B1                 call    ??$_Allocate@D@std@@YAPADIPAD@Z ; std::_Allocate<char>(uint,char *)
.text$mn:000022B6                 add     esp, 8
.text$mn:000022B9                 mov     esp, ebp
.text$mn:000022BB                 pop     ebp
.text$mn:000022BC                 retn    4
.text$mn:000022BC ?allocate@?$allocator@D@std@@QAEPADI@Z endp
.text$mn:000022BC
.text$mn:000022BC ; ---------------------------------------------------------------------------
.text$mn:000022BF                 align 10h
.text$mn:000022BF _text$mn        ends
.text$mn:000022BF
.text$mn:000022C0 ; ===========================================================================
.text$mn:000022C0
.text$mn:000022C0 ; Segment type: Pure code
.text$mn:000022C0 ; Segment permissions: Read/Execute
.text$mn:000022C0 _text$mn        segment para public 'CODE' use32
.text$mn:000022C0                 assume cs:_text$mn
.text$mn:000022C0                 ;org 22C0h
.text$mn:000022C0 ; COMDAT (pick any)
.text$mn:000022C0                 assume es:nothing, ss:nothing, ds:_data, fs:nothing, gs:nothing
.text$mn:000022C0
.text$mn:000022C0 ; =============== S U B R O U T I N E =======================================
.text$mn:000022C0
.text$mn:000022C0 ; Attributes: bp-based frame
.text$mn:000022C0
.text$mn:000022C0 ; public: struct std::_Container_proxy * __thiscall std::allocator<struct std::_Container_proxy>::allocate(unsigned int)
.text$mn:000022C0                 public ?allocate@?$allocator@U_Container_proxy@std@@@std@@QAEPAU_Container_proxy@2@I@Z
.text$mn:000022C0 ?allocate@?$allocator@U_Container_proxy@std@@@std@@QAEPAU_Container_proxy@2@I@Z proc near
.text$mn:000022C0                                         ; CODE XREF: std::_String_alloc<0,std::_String_base_types<char,std::allocator<char>>>::_Alloc_proxy(void)+16p
.text$mn:000022C0
.text$mn:000022C0 var_4           = dword ptr -4
.text$mn:000022C0 arg_0           = dword ptr  8
.text$mn:000022C0
.text$mn:000022C0                 push    ebp
.text$mn:000022C1                 mov     ebp, esp
.text$mn:000022C3                 push    ecx
.text$mn:000022C4                 mov     [ebp+var_4], ecx
.text$mn:000022C7                 push    0
.text$mn:000022C9                 mov     eax, [ebp+arg_0]
.text$mn:000022CC                 push    eax
.text$mn:000022CD                 call    ??$_Allocate@U_Container_proxy@std@@@std@@YAPAU_Container_proxy@0@IPAU10@@Z ; std::_Allocate<std::_Container_proxy>(uint,std::_Container_proxy *)
.text$mn:000022D2                 add     esp, 8
.text$mn:000022D5                 mov     esp, ebp
.text$mn:000022D7                 pop     ebp
.text$mn:000022D8                 retn    4
.text$mn:000022D8 ?allocate@?$allocator@U_Container_proxy@std@@@std@@QAEPAU_Container_proxy@2@I@Z endp
.text$mn:000022D8
.text$mn:000022D8 ; ---------------------------------------------------------------------------
.text$mn:000022DB                 align 4
.text$mn:000022DB _text$mn        ends
.text$mn:000022DB
.text$mn:000022DC ; ===========================================================================
.text$mn:000022DC
.text$mn:000022DC ; Segment type: Pure code
.text$mn:000022DC ; Segment permissions: Read/Execute
.text$mn:000022DC _text$mn        segment para public 'CODE' use32
.text$mn:000022DC                 assume cs:_text$mn
.text$mn:000022DC                 ;org 22DCh
.text$mn:000022DC ; COMDAT (pick any)
.text$mn:000022DC                 assume es:nothing, ss:nothing, ds:_data, fs:nothing, gs:nothing
.text$mn:000022DC
.text$mn:000022DC ; =============== S U B R O U T I N E =======================================
.text$mn:000022DC
.text$mn:000022DC ; Attributes: bp-based frame
.text$mn:000022DC
.text$mn:000022DC ; public: class std::basic_string<char, struct std::char_traits<char>, class std::allocator<char>> & __thiscall std::basic_string<char, struct std::char_traits<char>, class std::allocator<char>>::assign(class std::basic_string<char, struct std::char_traits<char>, class std::allocator<char>> const &, unsigned int, unsigned int)
.text$mn:000022DC                 public ?assign@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV12@ABV12@II@Z
.text$mn:000022DC ?assign@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV12@ABV12@II@Z proc near
.text$mn:000022DC                                         ; CODE XREF: std::basic_string<char,std::char_traits<char>,std::allocator<char>>::assign(char const *,uint)+4Fp
.text$mn:000022DC
.text$mn:000022DC Size            = dword ptr -8
.text$mn:000022DC var_4           = dword ptr -4
.text$mn:000022DC arg_0           = dword ptr  8
.text$mn:000022DC arg_4           = dword ptr  0Ch
.text$mn:000022DC arg_8           = dword ptr  10h
.text$mn:000022DC
.text$mn:000022DC                 push    ebp
.text$mn:000022DD                 mov     ebp, esp
.text$mn:000022DF                 sub     esp, 8
.text$mn:000022E2                 mov     [ebp+var_4], ecx
.text$mn:000022E5                 mov     ecx, [ebp+arg_0]
.text$mn:000022E8                 call    ?size@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QBEIXZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char>>::size(void)
.text$mn:000022ED                 cmp     eax, [ebp+arg_4]
.text$mn:000022F0                 jnb     short loc_22FA
.text$mn:000022F2                 mov     ecx, [ebp+var_4]
.text$mn:000022F5                 call    ?_Xran@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QBEXXZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char>>::_Xran(void)
.text$mn:000022FA
.text$mn:000022FA loc_22FA:                               ; CODE XREF: std::basic_string<char,std::char_traits<char>,std::allocator<char>>::assign(std::basic_string<char,std::char_traits<char>,std::allocator<char>> const &,uint,uint)+14j
.text$mn:000022FA                 mov     ecx, [ebp+arg_0]
.text$mn:000022FD                 call    ?size@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QBEIXZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char>>::size(void)
.text$mn:00002302                 sub     eax, [ebp+arg_4]
.text$mn:00002305                 mov     [ebp+Size], eax
.text$mn:00002308                 mov     eax, [ebp+arg_8]
.text$mn:0000230B                 cmp     eax, [ebp+Size]
.text$mn:0000230E                 jnb     short loc_2316
.text$mn:00002310                 mov     ecx, [ebp+arg_8]
.text$mn:00002313                 mov     [ebp+Size], ecx
.text$mn:00002316
.text$mn:00002316 loc_2316:                               ; CODE XREF: std::basic_string<char,std::char_traits<char>,std::allocator<char>>::assign(std::basic_string<char,std::char_traits<char>,std::allocator<char>> const &,uint,uint)+32j
.text$mn:00002316                 mov     edx, [ebp+var_4]
.text$mn:00002319                 cmp     edx, [ebp+arg_0]
.text$mn:0000231C                 jnz     short loc_233D
.text$mn:0000231E                 mov     eax, [ebp+arg_4]
.text$mn:00002321                 add     eax, [ebp+Size]
.text$mn:00002324                 push    eax
.text$mn:00002325                 mov     ecx, [ebp+var_4]
.text$mn:00002328                 call    ?erase@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV12@I@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char>>::erase(uint)
.text$mn:0000232D                 mov     ecx, [ebp+arg_4]
.text$mn:00002330                 push    ecx
.text$mn:00002331                 push    0
.text$mn:00002333                 mov     ecx, [ebp+var_4]
.text$mn:00002336                 call    ?erase@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV12@II@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char>>::erase(uint,uint)
.text$mn:0000233B                 jmp     short loc_237F
.text$mn:0000233D ; ---------------------------------------------------------------------------
.text$mn:0000233D
.text$mn:0000233D loc_233D:                               ; CODE XREF: std::basic_string<char,std::char_traits<char>,std::allocator<char>>::assign(std::basic_string<char,std::char_traits<char>,std::allocator<char>> const &,uint,uint)+40j
.text$mn:0000233D                 push    0
.text$mn:0000233F                 mov     edx, [ebp+Size]
.text$mn:00002342                 push    edx
.text$mn:00002343                 mov     ecx, [ebp+var_4]
.text$mn:00002346                 call    ?_Grow@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE_NI_N@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char>>::_Grow(uint,bool)
.text$mn:0000234B                 movzx   eax, al
.text$mn:0000234E                 test    eax, eax
.text$mn:00002350                 jz      short loc_237F
.text$mn:00002352                 mov     ecx, [ebp+Size]
.text$mn:00002355                 push    ecx             ; Size
.text$mn:00002356                 mov     ecx, [ebp+arg_0]
.text$mn:00002359                 call    ?_Myptr@?$_String_val@U?$_Simple_types@D@std@@@std@@QBEPBDXZ ; std::_String_val<std::_Simple_types<char>>::_Myptr(void)
.text$mn:0000235E                 add     eax, [ebp+arg_4]
.text$mn:00002361                 push    eax             ; Src
.text$mn:00002362                 mov     ecx, [ebp+var_4]
.text$mn:00002365                 call    ?_Myptr@?$_String_val@U?$_Simple_types@D@std@@@std@@QAEPADXZ ; std::_String_val<std::_Simple_types<char>>::_Myptr(void)
.text$mn:0000236A                 push    eax             ; Dst
.text$mn:0000236B                 call    ?copy@?$char_traits@D@std@@SAPADPADPBDI@Z ; std::char_traits<char>::copy(char *,char const *,uint)
.text$mn:00002370                 add     esp, 0Ch
.text$mn:00002373                 mov     edx, [ebp+Size]
.text$mn:00002376                 push    edx
.text$mn:00002377                 mov     ecx, [ebp+var_4]
.text$mn:0000237A                 call    ?_Eos@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEXI@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char>>::_Eos(uint)
.text$mn:0000237F
.text$mn:0000237F loc_237F:                               ; CODE XREF: std::basic_string<char,std::char_traits<char>,std::allocator<char>>::assign(std::basic_string<char,std::char_traits<char>,std::allocator<char>> const &,uint,uint)+5Fj
.text$mn:0000237F                                         ; std::basic_string<char,std::char_traits<char>,std::allocator<char>>::assign(std::basic_string<char,std::char_traits<char>,std::allocator<char>> const &,uint,uint)+74j
.text$mn:0000237F                 mov     eax, [ebp+var_4]
.text$mn:00002382                 mov     esp, ebp
.text$mn:00002384                 pop     ebp
.text$mn:00002385                 retn    0Ch
.text$mn:00002385 ?assign@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV12@ABV12@II@Z endp
.text$mn:00002385
.text$mn:00002385 _text$mn        ends
.text$mn:00002385
.text$mn:00002388 ; ===========================================================================
.text$mn:00002388
.text$mn:00002388 ; Segment type: Pure code
.text$mn:00002388 ; Segment permissions: Read/Execute
.text$mn:00002388 _text$mn        segment para public 'CODE' use32
.text$mn:00002388                 assume cs:_text$mn
.text$mn:00002388                 ;org 2388h
.text$mn:00002388 ; COMDAT (pick any)
.text$mn:00002388                 assume es:nothing, ss:nothing, ds:_data, fs:nothing, gs:nothing
.text$mn:00002388
.text$mn:00002388 ; =============== S U B R O U T I N E =======================================
.text$mn:00002388
.text$mn:00002388 ; Attributes: bp-based frame
.text$mn:00002388
.text$mn:00002388 ; int __stdcall std::basic_string<char,std::char_traits<char>,std::allocator<char>>::assign(char *Str)
.text$mn:00002388                 public ?assign@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV12@PBD@Z
.text$mn:00002388 ?assign@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV12@PBD@Z proc near
.text$mn:00002388                                         ; CODE XREF: std::basic_string<char,std::char_traits<char>,std::allocator<char>>::basic_string<char,std::char_traits<char>,std::allocator<char>>(char const *)+53p
.text$mn:00002388
.text$mn:00002388 var_4           = dword ptr -4
.text$mn:00002388 Str             = dword ptr  8
.text$mn:00002388
.text$mn:00002388                 push    ebp
.text$mn:00002389                 mov     ebp, esp
.text$mn:0000238B                 push    ecx
.text$mn:0000238C                 mov     [ebp+var_4], ecx
.text$mn:0000238F                 push    490h            ; unsigned int
.text$mn:00002394                 push    offset ??_C@_1IO@FEAPGJBD@?$AAC?$AA?3?$AA?2?$AAP?$AAr?$AAo?$AAg?$AAr?$AAa?$AAm?$AA?5?$AAF?$AAi?$AAl?$AAe?$AAs?$AA?5?$AA?$CI?$AAx?$AA8?$AA6?$AA?$CJ?$AA?2?$AAM?$AAi?$AAc?$AAr?$AAo?$AAs?$AAo?$AAf?$AAt@ ; "C:\\Program Files (x86)\\Microsoft Visu"...
.text$mn:00002399                 mov     eax, [ebp+Str]
.text$mn:0000239C                 push    eax             ; int
.text$mn:0000239D                 call    ??$_Debug_pointer@D@std@@YAXPBDPB_WI@Z ; std::_Debug_pointer<char>(char const *,wchar_t const *,uint)
.text$mn:000023A2                 add     esp, 0Ch
.text$mn:000023A5                 mov     ecx, [ebp+Str]
.text$mn:000023A8                 push    ecx             ; Str
.text$mn:000023A9                 call    ?length@?$char_traits@D@std@@SAIPBD@Z ; std::char_traits<char>::length(char const *)
.text$mn:000023AE                 add     esp, 4
.text$mn:000023B1                 push    eax             ; Size
.text$mn:000023B2                 mov     edx, [ebp+Str]
.text$mn:000023B5                 push    edx             ; Src
.text$mn:000023B6                 mov     ecx, [ebp+var_4]
.text$mn:000023B9                 call    ?assign@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV12@PBDI@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char>>::assign(char const *,uint)
.text$mn:000023BE                 mov     esp, ebp
.text$mn:000023C0                 pop     ebp
.text$mn:000023C1                 retn    4
.text$mn:000023C1 ?assign@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV12@PBD@Z endp
.text$mn:000023C1
.text$mn:000023C1 _text$mn        ends
.text$mn:000023C1
.text$mn:000023C4 ; ===========================================================================
.text$mn:000023C4
.text$mn:000023C4 ; Segment type: Pure code
.text$mn:000023C4 ; Segment permissions: Read/Execute
.text$mn:000023C4 _text$mn        segment para public 'CODE' use32
.text$mn:000023C4                 assume cs:_text$mn
.text$mn:000023C4                 ;org 23C4h
.text$mn:000023C4 ; COMDAT (pick any)
.text$mn:000023C4                 assume es:nothing, ss:nothing, ds:_data, fs:nothing, gs:nothing
.text$mn:000023C4
.text$mn:000023C4 ; =============== S U B R O U T I N E =======================================
.text$mn:000023C4
.text$mn:000023C4 ; Attributes: bp-based frame
.text$mn:000023C4
.text$mn:000023C4 ; int __stdcall std::basic_string<char,std::char_traits<char>,std::allocator<char>>::assign(void *Src, size_t Size)
.text$mn:000023C4                 public ?assign@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV12@PBDI@Z
.text$mn:000023C4 ?assign@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV12@PBDI@Z proc near
.text$mn:000023C4                                         ; CODE XREF: std::basic_string<char,std::char_traits<char>,std::allocator<char>>::assign(char const *)+31p
.text$mn:000023C4
.text$mn:000023C4 var_4           = dword ptr -4
.text$mn:000023C4 Src             = dword ptr  8
.text$mn:000023C4 Size            = dword ptr  0Ch
.text$mn:000023C4
.text$mn:000023C4                 push    ebp
.text$mn:000023C5                 mov     ebp, esp
.text$mn:000023C7                 push    ecx
.text$mn:000023C8                 mov     [ebp+var_4], ecx
.text$mn:000023CB                 cmp     [ebp+Size], 0
.text$mn:000023CF                 jz      short loc_23E7
.text$mn:000023D1                 push    47Fh            ; unsigned int
.text$mn:000023D6                 push    offset ??_C@_1IO@FEAPGJBD@?$AAC?$AA?3?$AA?2?$AAP?$AAr?$AAo?$AAg?$AAr?$AAa?$AAm?$AA?5?$AAF?$AAi?$AAl?$AAe?$AAs?$AA?5?$AA?$CI?$AAx?$AA8?$AA6?$AA?$CJ?$AA?2?$AAM?$AAi?$AAc?$AAr?$AAo?$AAs?$AAo?$AAf?$AAt@ ; "C:\\Program Files (x86)\\Microsoft Visu"...
.text$mn:000023DB                 mov     eax, [ebp+Src]
.text$mn:000023DE                 push    eax             ; int
.text$mn:000023DF                 call    ??$_Debug_pointer@D@std@@YAXPBDPB_WI@Z ; std::_Debug_pointer<char>(char const *,wchar_t const *,uint)
.text$mn:000023E4                 add     esp, 0Ch
.text$mn:000023E7
.text$mn:000023E7 loc_23E7:                               ; CODE XREF: std::basic_string<char,std::char_traits<char>,std::allocator<char>>::assign(char const *,uint)+Bj
.text$mn:000023E7                 mov     ecx, [ebp+Src]
.text$mn:000023EA                 push    ecx
.text$mn:000023EB                 mov     ecx, [ebp+var_4]
.text$mn:000023EE                 call    ?_Inside@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE_NPBD@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char>>::_Inside(char const *)
.text$mn:000023F3                 movzx   edx, al
.text$mn:000023F6                 test    edx, edx
.text$mn:000023F8                 jz      short loc_241A
.text$mn:000023FA                 mov     eax, [ebp+Size]
.text$mn:000023FD                 push    eax
.text$mn:000023FE                 mov     ecx, [ebp+var_4]
.text$mn:00002401                 call    ?_Myptr@?$_String_val@U?$_Simple_types@D@std@@@std@@QAEPADXZ ; std::_String_val<std::_Simple_types<char>>::_Myptr(void)
.text$mn:00002406                 mov     ecx, [ebp+Src]
.text$mn:00002409                 sub     ecx, eax
.text$mn:0000240B                 push    ecx
.text$mn:0000240C                 mov     edx, [ebp+var_4]
.text$mn:0000240F                 push    edx
.text$mn:00002410                 mov     ecx, [ebp+var_4]
.text$mn:00002413                 call    ?assign@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV12@ABV12@II@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char>>::assign(std::basic_string<char,std::char_traits<char>,std::allocator<char>> const &,uint,uint)
.text$mn:00002418                 jmp     short loc_2457
.text$mn:0000241A ; ---------------------------------------------------------------------------
.text$mn:0000241A
.text$mn:0000241A loc_241A:                               ; CODE XREF: std::basic_string<char,std::char_traits<char>,std::allocator<char>>::assign(char const *,uint)+34j
.text$mn:0000241A                 push    0
.text$mn:0000241C                 mov     eax, [ebp+Size]
.text$mn:0000241F                 push    eax
.text$mn:00002420                 mov     ecx, [ebp+var_4]
.text$mn:00002423                 call    ?_Grow@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE_NI_N@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char>>::_Grow(uint,bool)
.text$mn:00002428                 movzx   ecx, al
.text$mn:0000242B                 test    ecx, ecx
.text$mn:0000242D                 jz      short loc_2454
.text$mn:0000242F                 mov     edx, [ebp+Size]
.text$mn:00002432                 push    edx             ; Size
.text$mn:00002433                 mov     eax, [ebp+Src]
.text$mn:00002436                 push    eax             ; Src
.text$mn:00002437                 mov     ecx, [ebp+var_4]
.text$mn:0000243A                 call    ?_Myptr@?$_String_val@U?$_Simple_types@D@std@@@std@@QAEPADXZ ; std::_String_val<std::_Simple_types<char>>::_Myptr(void)
.text$mn:0000243F                 push    eax             ; Dst
.text$mn:00002440                 call    ?copy@?$char_traits@D@std@@SAPADPADPBDI@Z ; std::char_traits<char>::copy(char *,char const *,uint)
.text$mn:00002445                 add     esp, 0Ch
.text$mn:00002448                 mov     ecx, [ebp+Size]
.text$mn:0000244B                 push    ecx
.text$mn:0000244C                 mov     ecx, [ebp+var_4]
.text$mn:0000244F                 call    ?_Eos@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEXI@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char>>::_Eos(uint)
.text$mn:00002454
.text$mn:00002454 loc_2454:                               ; CODE XREF: std::basic_string<char,std::char_traits<char>,std::allocator<char>>::assign(char const *,uint)+69j
.text$mn:00002454                 mov     eax, [ebp+var_4]
.text$mn:00002457
.text$mn:00002457 loc_2457:                               ; CODE XREF: std::basic_string<char,std::char_traits<char>,std::allocator<char>>::assign(char const *,uint)+54j
.text$mn:00002457                 mov     esp, ebp
.text$mn:00002459                 pop     ebp
.text$mn:0000245A                 retn    8
.text$mn:0000245A ?assign@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV12@PBDI@Z endp
.text$mn:0000245A
.text$mn:0000245A ; ---------------------------------------------------------------------------
.text$mn:0000245D                 align 10h
.text$mn:0000245D _text$mn        ends
.text$mn:0000245D
.text$mn:00002460 ; ===========================================================================
.text$mn:00002460
.text$mn:00002460 ; Segment type: Pure code
.text$mn:00002460 ; Segment permissions: Read/Execute
.text$mn:00002460 _text$mn        segment para public 'CODE' use32
.text$mn:00002460                 assume cs:_text$mn
.text$mn:00002460                 ;org 2460h
.text$mn:00002460 ; COMDAT (pick any)
.text$mn:00002460                 assume es:nothing, ss:nothing, ds:_data, fs:nothing, gs:nothing
.text$mn:00002460
.text$mn:00002460 ; =============== S U B R O U T I N E =======================================
.text$mn:00002460
.text$mn:00002460 ; Attributes: bp-based frame
.text$mn:00002460
.text$mn:00002460 ; public: static void __cdecl std::char_traits<char>::assign(char &, char const &)
.text$mn:00002460                 public ?assign@?$char_traits@D@std@@SAXAADABD@Z
.text$mn:00002460 ?assign@?$char_traits@D@std@@SAXAADABD@Z proc near
.text$mn:00002460                                         ; CODE XREF: std::basic_string<char,std::char_traits<char>,std::allocator<char>>::_Eos(uint)+26p
.text$mn:00002460
.text$mn:00002460 arg_0           = dword ptr  8
.text$mn:00002460 arg_4           = dword ptr  0Ch
.text$mn:00002460
.text$mn:00002460                 push    ebp
.text$mn:00002461                 mov     ebp, esp
.text$mn:00002463                 mov     eax, [ebp+arg_0]
.text$mn:00002466                 mov     ecx, [ebp+arg_4]
.text$mn:00002469                 mov     dl, [ecx]
.text$mn:0000246B                 mov     [eax], dl
.text$mn:0000246D                 pop     ebp
.text$mn:0000246E                 retn
.text$mn:0000246E ?assign@?$char_traits@D@std@@SAXAADABD@Z endp
.text$mn:0000246E
.text$mn:0000246E ; ---------------------------------------------------------------------------
.text$mn:0000246F                 align 10h
.text$mn:0000246F _text$mn        ends
.text$mn:0000246F
.text$mn:00002470 ; ===========================================================================
.text$mn:00002470
.text$mn:00002470 ; Segment type: Pure code
.text$mn:00002470 ; Segment permissions: Read/Execute
.text$mn:00002470 _text$mn        segment para public 'CODE' use32
.text$mn:00002470                 assume cs:_text$mn
.text$mn:00002470                 ;org 2470h
.text$mn:00002470 ; COMDAT (pick any)
.text$mn:00002470                 assume es:nothing, ss:nothing, ds:_data, fs:nothing, gs:nothing
.text$mn:00002470
.text$mn:00002470 ; =============== S U B R O U T I N E =======================================
.text$mn:00002470
.text$mn:00002470 ; Attributes: bp-based frame
.text$mn:00002470
.text$mn:00002470 ; const struct std::error_category *__thiscall std::error_code::category(std::error_code *__hidden this)
.text$mn:00002470                 public ?category@error_code@std@@QBEABVerror_category@2@XZ
.text$mn:00002470 ?category@error_code@std@@QBEABVerror_category@2@XZ proc near
.text$mn:00002470                                         ; CODE XREF: std::error_category::equivalent(std::error_code const &,int)+Cp
.text$mn:00002470
.text$mn:00002470 var_4           = dword ptr -4
.text$mn:00002470
.text$mn:00002470                 push    ebp
.text$mn:00002471                 mov     ebp, esp
.text$mn:00002473                 push    ecx
.text$mn:00002474                 mov     [ebp+var_4], ecx
.text$mn:00002477                 mov     eax, [ebp+var_4]
.text$mn:0000247A                 mov     eax, [eax+4]
.text$mn:0000247D                 mov     esp, ebp
.text$mn:0000247F                 pop     ebp
.text$mn:00002480                 retn
.text$mn:00002480 ?category@error_code@std@@QBEABVerror_category@2@XZ endp
.text$mn:00002480
.text$mn:00002480 ; ---------------------------------------------------------------------------
.text$mn:00002481                 align 4
.text$mn:00002481 _text$mn        ends
.text$mn:00002481
.text$mn:00002484 ; ===========================================================================
.text$mn:00002484
.text$mn:00002484 ; Segment type: Pure code
.text$mn:00002484 ; Segment permissions: Read/Execute
.text$mn:00002484 _text$mn        segment para public 'CODE' use32
.text$mn:00002484                 assume cs:_text$mn
.text$mn:00002484                 ;org 2484h
.text$mn:00002484 ; COMDAT (pick any)
.text$mn:00002484                 assume es:nothing, ss:nothing, ds:_data, fs:nothing, gs:nothing
.text$mn:00002484
.text$mn:00002484 ; =============== S U B R O U T I N E =======================================
.text$mn:00002484
.text$mn:00002484 ; Attributes: bp-based frame
.text$mn:00002484
.text$mn:00002484 ; const struct std::error_category *__thiscall std::error_condition::category(std::error_condition *__hidden this)
.text$mn:00002484                 public ?category@error_condition@std@@QBEABVerror_category@2@XZ
.text$mn:00002484 ?category@error_condition@std@@QBEABVerror_category@2@XZ proc near
.text$mn:00002484                                         ; CODE XREF: std::error_condition::operator==(std::error_condition const &)+Dp
.text$mn:00002484                                         ; std::error_condition::operator==(std::error_condition const &)+16p
.text$mn:00002484
.text$mn:00002484 var_4           = dword ptr -4
.text$mn:00002484
.text$mn:00002484                 push    ebp
.text$mn:00002485                 mov     ebp, esp
.text$mn:00002487                 push    ecx
.text$mn:00002488                 mov     [ebp+var_4], ecx
.text$mn:0000248B                 mov     eax, [ebp+var_4]
.text$mn:0000248E                 mov     eax, [eax+4]
.text$mn:00002491                 mov     esp, ebp
.text$mn:00002493                 pop     ebp
.text$mn:00002494                 retn
.text$mn:00002494 ?category@error_condition@std@@QBEABVerror_category@2@XZ endp
.text$mn:00002494
.text$mn:00002494 ; ---------------------------------------------------------------------------
.text$mn:00002495                 align 4
.text$mn:00002495 _text$mn        ends
.text$mn:00002495
.text$mn:00002498 ; ===========================================================================
.text$mn:00002498
.text$mn:00002498 ; Segment type: Pure code
.text$mn:00002498 ; Segment permissions: Read/Execute
.text$mn:00002498 _text$mn        segment para public 'CODE' use32
.text$mn:00002498                 assume cs:_text$mn
.text$mn:00002498                 ;org 2498h
.text$mn:00002498 ; COMDAT (pick any)
.text$mn:00002498                 assume es:nothing, ss:nothing, ds:_data, fs:nothing, gs:nothing
.text$mn:00002498
.text$mn:00002498 ; =============== S U B R O U T I N E =======================================
.text$mn:00002498
.text$mn:00002498 ; Attributes: bp-based frame
.text$mn:00002498
.text$mn:00002498 ; int __cdecl std::char_traits<char>::copy(void *Dst, void *Src, size_t Size)
.text$mn:00002498                 public ?copy@?$char_traits@D@std@@SAPADPADPBDI@Z
.text$mn:00002498 ?copy@?$char_traits@D@std@@SAPADPADPBDI@Z proc near ; CODE XREF: $LN19+1Ep
.text$mn:00002498                                         ; std::basic_string<char,std::char_traits<char>,std::allocator<char>>::_Tidy(bool,uint)+5Dp ...
.text$mn:00002498
.text$mn:00002498 var_4           = dword ptr -4
.text$mn:00002498 Dst             = dword ptr  8
.text$mn:00002498 Src             = dword ptr  0Ch
.text$mn:00002498 Size            = dword ptr  10h
.text$mn:00002498
.text$mn:00002498                 push    ebp
.text$mn:00002499                 mov     ebp, esp
.text$mn:0000249B                 push    ecx
.text$mn:0000249C                 cmp     [ebp+Size], 0
.text$mn:000024A0                 jnz     short loc_24AA
.text$mn:000024A2                 mov     eax, [ebp+Dst]
.text$mn:000024A5                 mov     [ebp+var_4], eax
.text$mn:000024A8                 jmp     short loc_24C1
.text$mn:000024AA ; ---------------------------------------------------------------------------
.text$mn:000024AA
.text$mn:000024AA loc_24AA:                               ; CODE XREF: std::char_traits<char>::copy(char *,char const *,uint)+8j
.text$mn:000024AA                 mov     ecx, [ebp+Size]
.text$mn:000024AD                 push    ecx             ; Size
.text$mn:000024AE                 mov     edx, [ebp+Src]
.text$mn:000024B1                 push    edx             ; Src
.text$mn:000024B2                 mov     eax, [ebp+Dst]
.text$mn:000024B5                 push    eax             ; Dst
.text$mn:000024B6                 call    _memcpy
.text$mn:000024BB                 add     esp, 0Ch
.text$mn:000024BE                 mov     [ebp+var_4], eax
.text$mn:000024C1
.text$mn:000024C1 loc_24C1:                               ; CODE XREF: std::char_traits<char>::copy(char *,char const *,uint)+10j
.text$mn:000024C1                 mov     eax, [ebp+var_4]
.text$mn:000024C4                 mov     esp, ebp
.text$mn:000024C6                 pop     ebp
.text$mn:000024C7                 retn
.text$mn:000024C7 ?copy@?$char_traits@D@std@@SAPADPADPBDI@Z endp
.text$mn:000024C7
.text$mn:000024C7 _text$mn        ends
.text$mn:000024C7
.text$mn:000024C8 ; ===========================================================================
.text$mn:000024C8
.text$mn:000024C8 ; Segment type: Pure code
.text$mn:000024C8 ; Segment permissions: Read/Execute
.text$mn:000024C8 _text$mn        segment para public 'CODE' use32
.text$mn:000024C8                 assume cs:_text$mn
.text$mn:000024C8                 ;org 24C8h
.text$mn:000024C8 ; COMDAT (pick any)
.text$mn:000024C8                 assume es:nothing, ss:nothing, ds:_data, fs:nothing, gs:nothing
.text$mn:000024C8
.text$mn:000024C8 ; =============== S U B R O U T I N E =======================================
.text$mn:000024C8
.text$mn:000024C8 ; Attributes: bp-based frame
.text$mn:000024C8
.text$mn:000024C8 ; int __stdcall std::_Wrap_alloc<std::allocator<char>>::deallocate(void *, int)
.text$mn:000024C8                 public ?deallocate@?$_Wrap_alloc@V?$allocator@D@std@@@std@@QAEXPADI@Z
.text$mn:000024C8 ?deallocate@?$_Wrap_alloc@V?$allocator@D@std@@@std@@QAEXPADI@Z proc near
.text$mn:000024C8                                         ; CODE XREF: std::basic_string<char,std::char_traits<char>,std::allocator<char>>::_Tidy(bool,uint)+81p
.text$mn:000024C8
.text$mn:000024C8 var_4           = dword ptr -4
.text$mn:000024C8 arg_0           = dword ptr  8
.text$mn:000024C8 arg_4           = dword ptr  0Ch
.text$mn:000024C8
.text$mn:000024C8                 push    ebp
.text$mn:000024C9                 mov     ebp, esp
.text$mn:000024CB                 push    ecx
.text$mn:000024CC                 mov     [ebp+var_4], ecx
.text$mn:000024CF                 mov     eax, [ebp+arg_4]
.text$mn:000024D2                 push    eax             ; int
.text$mn:000024D3                 mov     ecx, [ebp+arg_0]
.text$mn:000024D6                 push    ecx             ; void *
.text$mn:000024D7                 mov     ecx, [ebp+var_4]
.text$mn:000024DA                 call    ?deallocate@?$allocator@D@std@@QAEXPADI@Z ; std::allocator<char>::deallocate(char *,uint)
.text$mn:000024DF                 mov     esp, ebp
.text$mn:000024E1                 pop     ebp
.text$mn:000024E2                 retn    8
.text$mn:000024E2 ?deallocate@?$_Wrap_alloc@V?$allocator@D@std@@@std@@QAEXPADI@Z endp
.text$mn:000024E2
.text$mn:000024E2 ; ---------------------------------------------------------------------------
.text$mn:000024E5                 align 4
.text$mn:000024E5 _text$mn        ends
.text$mn:000024E5
.text$mn:000024E8 ; ===========================================================================
.text$mn:000024E8
.text$mn:000024E8 ; Segment type: Pure code
.text$mn:000024E8 ; Segment permissions: Read/Execute
.text$mn:000024E8 _text$mn        segment para public 'CODE' use32
.text$mn:000024E8                 assume cs:_text$mn
.text$mn:000024E8                 ;org 24E8h
.text$mn:000024E8 ; COMDAT (pick any)
.text$mn:000024E8                 assume es:nothing, ss:nothing, ds:_data, fs:nothing, gs:nothing
.text$mn:000024E8
.text$mn:000024E8 ; =============== S U B R O U T I N E =======================================
.text$mn:000024E8
.text$mn:000024E8 ; Attributes: bp-based frame
.text$mn:000024E8
.text$mn:000024E8 ; int __stdcall std::allocator<char>::deallocate(void *, int)
.text$mn:000024E8                 public ?deallocate@?$allocator@D@std@@QAEXPADI@Z
.text$mn:000024E8 ?deallocate@?$allocator@D@std@@QAEXPADI@Z proc near
.text$mn:000024E8                                         ; CODE XREF: std::_Wrap_alloc<std::allocator<char>>::deallocate(char *,uint)+12p
.text$mn:000024E8
.text$mn:000024E8 var_4           = dword ptr -4
.text$mn:000024E8 arg_0           = dword ptr  8
.text$mn:000024E8
.text$mn:000024E8                 push    ebp
.text$mn:000024E9                 mov     ebp, esp
.text$mn:000024EB                 push    ecx
.text$mn:000024EC                 mov     [ebp+var_4], ecx
.text$mn:000024EF                 mov     eax, [ebp+arg_0]
.text$mn:000024F2                 push    eax             ; void *
.text$mn:000024F3                 call    ??3@YAXPAX@Z    ; operator delete(void *)
.text$mn:000024F8                 add     esp, 4
.text$mn:000024FB                 mov     esp, ebp
.text$mn:000024FD                 pop     ebp
.text$mn:000024FE                 retn    8
.text$mn:000024FE ?deallocate@?$allocator@D@std@@QAEXPADI@Z endp
.text$mn:000024FE
.text$mn:000024FE ; ---------------------------------------------------------------------------
.text$mn:00002501                 align 4
.text$mn:00002501 _text$mn        ends
.text$mn:00002501
.text$mn:00002504 ; ===========================================================================
.text$mn:00002504
.text$mn:00002504 ; Segment type: Pure code
.text$mn:00002504 ; Segment permissions: Read/Execute
.text$mn:00002504 _text$mn        segment para public 'CODE' use32
.text$mn:00002504                 assume cs:_text$mn
.text$mn:00002504                 ;org 2504h
.text$mn:00002504 ; COMDAT (pick any)
.text$mn:00002504                 assume es:nothing, ss:nothing, ds:_data, fs:nothing, gs:nothing
.text$mn:00002504
.text$mn:00002504 ; =============== S U B R O U T I N E =======================================
.text$mn:00002504
.text$mn:00002504 ; Attributes: bp-based frame
.text$mn:00002504
.text$mn:00002504 ; int __stdcall std::allocator<std::_Container_proxy>::deallocate(void *, int)
.text$mn:00002504                 public ?deallocate@?$allocator@U_Container_proxy@std@@@std@@QAEXPAU_Container_proxy@2@I@Z
.text$mn:00002504 ?deallocate@?$allocator@U_Container_proxy@std@@@std@@QAEXPAU_Container_proxy@2@I@Z proc near
.text$mn:00002504                                         ; CODE XREF: std::_String_alloc<0,std::_String_base_types<char,std::allocator<char>>>::_Free_proxy(void)+32p
.text$mn:00002504
.text$mn:00002504 var_4           = dword ptr -4
.text$mn:00002504 arg_0           = dword ptr  8
.text$mn:00002504
.text$mn:00002504                 push    ebp
.text$mn:00002505                 mov     ebp, esp
.text$mn:00002507                 push    ecx
.text$mn:00002508                 mov     [ebp+var_4], ecx
.text$mn:0000250B                 mov     eax, [ebp+arg_0]
.text$mn:0000250E                 push    eax             ; void *
.text$mn:0000250F                 call    ??3@YAXPAX@Z    ; operator delete(void *)
.text$mn:00002514                 add     esp, 4
.text$mn:00002517                 mov     esp, ebp
.text$mn:00002519                 pop     ebp
.text$mn:0000251A                 retn    8
.text$mn:0000251A ?deallocate@?$allocator@U_Container_proxy@std@@@std@@QAEXPAU_Container_proxy@2@I@Z endp
.text$mn:0000251A
.text$mn:0000251A ; ---------------------------------------------------------------------------
.text$mn:0000251D                 align 10h
.text$mn:0000251D _text$mn        ends
.text$mn:0000251D
.text$mn:00002520 ; ===========================================================================
.text$mn:00002520
.text$mn:00002520 ; Segment type: Pure code
.text$mn:00002520 ; Segment permissions: Read/Execute
.text$mn:00002520 _text$mn        segment para public 'CODE' use32
.text$mn:00002520                 assume cs:_text$mn
.text$mn:00002520                 ;org 2520h
.text$mn:00002520 ; COMDAT (pick any)
.text$mn:00002520                 assume es:nothing, ss:nothing, ds:_data, fs:nothing, gs:nothing
.text$mn:00002520
.text$mn:00002520 ; =============== S U B R O U T I N E =======================================
.text$mn:00002520
.text$mn:00002520 ; Attributes: bp-based frame
.text$mn:00002520
.text$mn:00002520 ; public: virtual class std::error_condition __thiscall std::_System_error_category::default_error_condition(int)const
.text$mn:00002520                 public ?default_error_condition@_System_error_category@std@@UBE?AVerror_condition@2@H@Z
.text$mn:00002520 ?default_error_condition@_System_error_category@std@@UBE?AVerror_condition@2@H@Z proc near
.text$mn:00002520                                         ; DATA XREF: .rdata:00002FB4o
.text$mn:00002520
.text$mn:00002520 var_4           = dword ptr -4
.text$mn:00002520 arg_0           = dword ptr  8
.text$mn:00002520 arg_4           = dword ptr  0Ch
.text$mn:00002520
.text$mn:00002520                 push    ebp
.text$mn:00002521                 mov     ebp, esp
.text$mn:00002523                 push    ecx
.text$mn:00002524                 mov     [ebp+var_4], ecx
.text$mn:00002527                 mov     eax, [ebp+arg_4]
.text$mn:0000252A                 push    eax             ; int
.text$mn:0000252B                 call    ?_Syserror_map@std@@YAPBDH@Z ; std::_Syserror_map(int)
.text$mn:00002530                 add     esp, 4
.text$mn:00002533                 test    eax, eax
.text$mn:00002535                 jz      short loc_2550
.text$mn:00002537                 call    ?generic_category@std@@YAABVerror_category@1@XZ ; std::generic_category(void)
.text$mn:0000253C                 push    eax             ; struct std::error_category *
.text$mn:0000253D                 mov     ecx, [ebp+arg_4]
.text$mn:00002540                 push    ecx             ; int
.text$mn:00002541                 mov     ecx, [ebp+arg_0] ; this
.text$mn:00002544                 call    ??0error_condition@std@@QAE@HABVerror_category@1@@Z ; std::error_condition::error_condition(int,std::error_category const &)
.text$mn:00002549                 mov     eax, [ebp+arg_0]
.text$mn:0000254C                 jmp     short loc_2565
.text$mn:0000254E ; ---------------------------------------------------------------------------
.text$mn:0000254E                 jmp     short loc_2565
.text$mn:00002550 ; ---------------------------------------------------------------------------
.text$mn:00002550
.text$mn:00002550 loc_2550:                               ; CODE XREF: std::_System_error_category::default_error_condition(int)+15j
.text$mn:00002550                 call    ?system_category@std@@YAABVerror_category@1@XZ ; std::system_category(void)
.text$mn:00002555                 push    eax             ; struct std::error_category *
.text$mn:00002556                 mov     edx, [ebp+arg_4]
.text$mn:00002559                 push    edx             ; int
.text$mn:0000255A                 mov     ecx, [ebp+arg_0] ; this
.text$mn:0000255D                 call    ??0error_condition@std@@QAE@HABVerror_category@1@@Z ; std::error_condition::error_condition(int,std::error_category const &)
.text$mn:00002562                 mov     eax, [ebp+arg_0]
.text$mn:00002565
.text$mn:00002565 loc_2565:                               ; CODE XREF: std::_System_error_category::default_error_condition(int)+2Cj
.text$mn:00002565                                         ; std::_System_error_category::default_error_condition(int)+2Ej
.text$mn:00002565                 mov     esp, ebp
.text$mn:00002567                 pop     ebp
.text$mn:00002568                 retn    8
.text$mn:00002568 ?default_error_condition@_System_error_category@std@@UBE?AVerror_condition@2@H@Z endp
.text$mn:00002568
.text$mn:00002568 ; ---------------------------------------------------------------------------
.text$mn:0000256B                 align 4
.text$mn:0000256B _text$mn        ends
.text$mn:0000256B
.text$mn:0000256C ; ===========================================================================
.text$mn:0000256C
.text$mn:0000256C ; Segment type: Pure code
.text$mn:0000256C ; Segment permissions: Read/Execute
.text$mn:0000256C _text$mn        segment para public 'CODE' use32
.text$mn:0000256C                 assume cs:_text$mn
.text$mn:0000256C                 ;org 256Ch
.text$mn:0000256C ; COMDAT (pick any)
.text$mn:0000256C                 assume es:nothing, ss:nothing, ds:_data, fs:nothing, gs:nothing
.text$mn:0000256C
.text$mn:0000256C ; =============== S U B R O U T I N E =======================================
.text$mn:0000256C
.text$mn:0000256C ; Attributes: bp-based frame
.text$mn:0000256C
.text$mn:0000256C ; public: virtual class std::error_condition __thiscall std::error_category::default_error_condition(int)const
.text$mn:0000256C                 public ?default_error_condition@error_category@std@@UBE?AVerror_condition@2@H@Z
.text$mn:0000256C ?default_error_condition@error_category@std@@UBE?AVerror_condition@2@H@Z proc near
.text$mn:0000256C                                         ; DATA XREF: .rdata:00002F24o
.text$mn:0000256C                                         ; .rdata:00002F40o ...
.text$mn:0000256C
.text$mn:0000256C var_4           = dword ptr -4
.text$mn:0000256C arg_0           = dword ptr  8
.text$mn:0000256C arg_4           = dword ptr  0Ch
.text$mn:0000256C
.text$mn:0000256C                 push    ebp
.text$mn:0000256D                 mov     ebp, esp
.text$mn:0000256F                 push    ecx
.text$mn:00002570                 mov     [ebp+var_4], ecx
.text$mn:00002573                 mov     eax, [ebp+var_4]
.text$mn:00002576                 push    eax             ; struct std::error_category *
.text$mn:00002577                 mov     ecx, [ebp+arg_4]
.text$mn:0000257A                 push    ecx             ; int
.text$mn:0000257B                 mov     ecx, [ebp+arg_0] ; this
.text$mn:0000257E                 call    ??0error_condition@std@@QAE@HABVerror_category@1@@Z ; std::error_condition::error_condition(int,std::error_category const &)
.text$mn:00002583                 mov     eax, [ebp+arg_0]
.text$mn:00002586                 mov     esp, ebp
.text$mn:00002588                 pop     ebp
.text$mn:00002589                 retn    8
.text$mn:00002589 ?default_error_condition@error_category@std@@UBE?AVerror_condition@2@H@Z endp
.text$mn:00002589
.text$mn:00002589 _text$mn        ends
.text$mn:00002589
.text$mn:0000258C ; ===========================================================================
.text$mn:0000258C
.text$mn:0000258C ; Segment type: Pure code
.text$mn:0000258C ; Segment permissions: Read/Execute
.text$mn:0000258C _text$mn        segment para public 'CODE' use32
.text$mn:0000258C                 assume cs:_text$mn
.text$mn:0000258C                 ;org 258Ch
.text$mn:0000258C ; COMDAT (pick any)
.text$mn:0000258C                 assume es:nothing, ss:nothing, ds:_data, fs:nothing, gs:nothing
.text$mn:0000258C
.text$mn:0000258C ; =============== S U B R O U T I N E =======================================
.text$mn:0000258C
.text$mn:0000258C ; Attributes: bp-based frame
.text$mn:0000258C
.text$mn:0000258C ; bool __thiscall std::error_category::equivalent(std::error_category *this, const struct std::error_code *, int)
.text$mn:0000258C                 public ?equivalent@error_category@std@@UBE_NABVerror_code@2@H@Z
.text$mn:0000258C ?equivalent@error_category@std@@UBE_NABVerror_code@2@H@Z proc near
.text$mn:0000258C                                         ; DATA XREF: .rdata:00002F28o
.text$mn:0000258C                                         ; .rdata:00002F44o ...
.text$mn:0000258C
.text$mn:0000258C var_8           = dword ptr -8
.text$mn:0000258C var_4           = dword ptr -4
.text$mn:0000258C arg_0           = dword ptr  8
.text$mn:0000258C arg_4           = dword ptr  0Ch
.text$mn:0000258C
.text$mn:0000258C                 push    ebp
.text$mn:0000258D                 mov     ebp, esp
.text$mn:0000258F                 sub     esp, 8
.text$mn:00002592                 mov     [ebp+var_8], ecx
.text$mn:00002595                 mov     ecx, [ebp+arg_0] ; this
.text$mn:00002598                 call    ?category@error_code@std@@QBEABVerror_category@2@XZ ; std::error_code::category(void)
.text$mn:0000259D                 push    eax
.text$mn:0000259E                 mov     ecx, [ebp+var_8]
.text$mn:000025A1                 call    ??8error_category@std@@QBE_NABV01@@Z ; std::error_category::operator==(std::error_category const &)
.text$mn:000025A6                 movzx   eax, al
.text$mn:000025A9                 test    eax, eax
.text$mn:000025AB                 jz      short loc_25C3
.text$mn:000025AD                 mov     ecx, [ebp+arg_0] ; this
.text$mn:000025B0                 call    ?value@error_code@std@@QBEHXZ ; std::error_code::value(void)
.text$mn:000025B5                 cmp     eax, [ebp+arg_4]
.text$mn:000025B8                 jnz     short loc_25C3
.text$mn:000025BA                 mov     [ebp+var_4], 1
.text$mn:000025C1                 jmp     short loc_25CA
.text$mn:000025C3 ; ---------------------------------------------------------------------------
.text$mn:000025C3
.text$mn:000025C3 loc_25C3:                               ; CODE XREF: std::error_category::equivalent(std::error_code const &,int)+1Fj
.text$mn:000025C3                                         ; std::error_category::equivalent(std::error_code const &,int)+2Cj
.text$mn:000025C3                 mov     [ebp+var_4], 0
.text$mn:000025CA
.text$mn:000025CA loc_25CA:                               ; CODE XREF: std::error_category::equivalent(std::error_code const &,int)+35j
.text$mn:000025CA                 mov     al, byte ptr [ebp+var_4]
.text$mn:000025CD                 mov     esp, ebp
.text$mn:000025CF                 pop     ebp
.text$mn:000025D0                 retn    8
.text$mn:000025D0 ?equivalent@error_category@std@@UBE_NABVerror_code@2@H@Z endp
.text$mn:000025D0
.text$mn:000025D0 ; ---------------------------------------------------------------------------
.text$mn:000025D3                 align 4
.text$mn:000025D3 _text$mn        ends
.text$mn:000025D3
.text$mn:000025D4 ; ===========================================================================
.text$mn:000025D4
.text$mn:000025D4 ; Segment type: Pure code
.text$mn:000025D4 ; Segment permissions: Read/Execute
.text$mn:000025D4 _text$mn        segment para public 'CODE' use32
.text$mn:000025D4                 assume cs:_text$mn
.text$mn:000025D4                 ;org 25D4h
.text$mn:000025D4 ; COMDAT (pick any)
.text$mn:000025D4                 assume es:nothing, ss:nothing, ds:_data, fs:nothing, gs:nothing
.text$mn:000025D4
.text$mn:000025D4 ; =============== S U B R O U T I N E =======================================
.text$mn:000025D4
.text$mn:000025D4 ; Attributes: bp-based frame
.text$mn:000025D4
.text$mn:000025D4 ; bool __thiscall std::error_category::equivalent(std::error_category *this, int, const struct std::error_condition *)
.text$mn:000025D4                 public ?equivalent@error_category@std@@UBE_NHABVerror_condition@2@@Z
.text$mn:000025D4 ?equivalent@error_category@std@@UBE_NHABVerror_condition@2@@Z proc near
.text$mn:000025D4                                         ; DATA XREF: .rdata:00002F2Co
.text$mn:000025D4                                         ; .rdata:00002F48o ...
.text$mn:000025D4
.text$mn:000025D4 var_C           = byte ptr -0Ch
.text$mn:000025D4 var_4           = dword ptr -4
.text$mn:000025D4 arg_0           = dword ptr  8
.text$mn:000025D4 arg_4           = dword ptr  0Ch
.text$mn:000025D4
.text$mn:000025D4                 push    ebp
.text$mn:000025D5                 mov     ebp, esp
.text$mn:000025D7                 sub     esp, 0Ch
.text$mn:000025DA                 mov     [ebp+var_4], ecx
.text$mn:000025DD                 mov     eax, [ebp+arg_4]
.text$mn:000025E0                 push    eax             ; std::error_condition *
.text$mn:000025E1                 mov     ecx, [ebp+arg_0]
.text$mn:000025E4                 push    ecx
.text$mn:000025E5                 lea     edx, [ebp+var_C]
.text$mn:000025E8                 push    edx
.text$mn:000025E9                 mov     eax, [ebp+var_4]
.text$mn:000025EC                 mov     edx, [eax]
.text$mn:000025EE                 mov     ecx, [ebp+var_4]
.text$mn:000025F1                 mov     eax, [edx+0Ch]
.text$mn:000025F4                 call    eax
.text$mn:000025F6                 mov     ecx, eax
.text$mn:000025F8                 call    ??8error_condition@std@@QBE_NABV01@@Z ; std::error_condition::operator==(std::error_condition const &)
.text$mn:000025FD                 mov     esp, ebp
.text$mn:000025FF                 pop     ebp
.text$mn:00002600                 retn    8
.text$mn:00002600 ?equivalent@error_category@std@@UBE_NHABVerror_condition@2@@Z endp
.text$mn:00002600
.text$mn:00002600 ; ---------------------------------------------------------------------------
.text$mn:00002603                 align 4
.text$mn:00002603 _text$mn        ends
.text$mn:00002603
.text$mn:00002604 ; ===========================================================================
.text$mn:00002604
.text$mn:00002604 ; Segment type: Pure code
.text$mn:00002604 ; Segment permissions: Read/Execute
.text$mn:00002604 _text$mn        segment para public 'CODE' use32
.text$mn:00002604                 assume cs:_text$mn
.text$mn:00002604                 ;org 2604h
.text$mn:00002604 ; COMDAT (pick any)
.text$mn:00002604                 assume es:nothing, ss:nothing, ds:_data, fs:nothing, gs:nothing
.text$mn:00002604
.text$mn:00002604 ; =============== S U B R O U T I N E =======================================
.text$mn:00002604
.text$mn:00002604 ; Attributes: bp-based frame
.text$mn:00002604
.text$mn:00002604 ; public: class std::basic_string<char, struct std::char_traits<char>, class std::allocator<char>> & __thiscall std::basic_string<char, struct std::char_traits<char>, class std::allocator<char>>::erase(unsigned int)
.text$mn:00002604                 public ?erase@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV12@I@Z
.text$mn:00002604 ?erase@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV12@I@Z proc near
.text$mn:00002604                                         ; CODE XREF: std::basic_string<char,std::char_traits<char>,std::allocator<char>>::assign(std::basic_string<char,std::char_traits<char>,std::allocator<char>> const &,uint,uint)+4Cp
.text$mn:00002604
.text$mn:00002604 var_4           = dword ptr -4
.text$mn:00002604 arg_0           = dword ptr  8
.text$mn:00002604
.text$mn:00002604                 push    ebp
.text$mn:00002605                 mov     ebp, esp
.text$mn:00002607                 push    ecx
.text$mn:00002608                 mov     [ebp+var_4], ecx
.text$mn:0000260B                 mov     eax, [ebp+var_4]
.text$mn:0000260E                 mov     ecx, [eax+14h]
.text$mn:00002611                 cmp     ecx, [ebp+arg_0]
.text$mn:00002614                 jnb     short loc_261E
.text$mn:00002616                 mov     ecx, [ebp+var_4]
.text$mn:00002619                 call    ?_Xran@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QBEXXZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char>>::_Xran(void)
.text$mn:0000261E
.text$mn:0000261E loc_261E:                               ; CODE XREF: std::basic_string<char,std::char_traits<char>,std::allocator<char>>::erase(uint)+10j
.text$mn:0000261E                 mov     edx, [ebp+arg_0]
.text$mn:00002621                 push    edx
.text$mn:00002622                 mov     ecx, [ebp+var_4]
.text$mn:00002625                 call    ?_Eos@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEXI@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char>>::_Eos(uint)
.text$mn:0000262A                 mov     eax, [ebp+var_4]
.text$mn:0000262D                 mov     esp, ebp
.text$mn:0000262F                 pop     ebp
.text$mn:00002630                 retn    4
.text$mn:00002630 ?erase@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV12@I@Z endp
.text$mn:00002630
.text$mn:00002630 ; ---------------------------------------------------------------------------
.text$mn:00002633                 align 4
.text$mn:00002633 _text$mn        ends
.text$mn:00002633
.text$mn:00002634 ; ===========================================================================
.text$mn:00002634
.text$mn:00002634 ; Segment type: Pure code
.text$mn:00002634 ; Segment permissions: Read/Execute
.text$mn:00002634 _text$mn        segment para public 'CODE' use32
.text$mn:00002634                 assume cs:_text$mn
.text$mn:00002634                 ;org 2634h
.text$mn:00002634 ; COMDAT (pick any)
.text$mn:00002634                 assume es:nothing, ss:nothing, ds:_data, fs:nothing, gs:nothing
.text$mn:00002634
.text$mn:00002634 ; =============== S U B R O U T I N E =======================================
.text$mn:00002634
.text$mn:00002634 ; Attributes: bp-based frame
.text$mn:00002634
.text$mn:00002634 ; public: class std::basic_string<char, struct std::char_traits<char>, class std::allocator<char>> & __thiscall std::basic_string<char, struct std::char_traits<char>, class std::allocator<char>>::erase(unsigned int, unsigned int)
.text$mn:00002634                 public ?erase@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV12@II@Z
.text$mn:00002634 ?erase@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV12@II@Z proc near
.text$mn:00002634                                         ; CODE XREF: std::basic_string<char,std::char_traits<char>,std::allocator<char>>::assign(std::basic_string<char,std::char_traits<char>,std::allocator<char>> const &,uint,uint)+5Ap
.text$mn:00002634
.text$mn:00002634 var_C           = dword ptr -0Ch
.text$mn:00002634 Dst             = dword ptr -8
.text$mn:00002634 var_4           = dword ptr -4
.text$mn:00002634 arg_0           = dword ptr  8
.text$mn:00002634 arg_4           = dword ptr  0Ch
.text$mn:00002634
.text$mn:00002634                 push    ebp
.text$mn:00002635                 mov     ebp, esp
.text$mn:00002637                 sub     esp, 0Ch
.text$mn:0000263A                 mov     [ebp+var_4], ecx
.text$mn:0000263D                 mov     eax, [ebp+var_4]
.text$mn:00002640                 mov     ecx, [eax+14h]
.text$mn:00002643                 cmp     ecx, [ebp+arg_0]
.text$mn:00002646                 jnb     short loc_2650
.text$mn:00002648                 mov     ecx, [ebp+var_4]
.text$mn:0000264B                 call    ?_Xran@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QBEXXZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char>>::_Xran(void)
.text$mn:00002650
.text$mn:00002650 loc_2650:                               ; CODE XREF: std::basic_string<char,std::char_traits<char>,std::allocator<char>>::erase(uint,uint)+12j
.text$mn:00002650                 mov     edx, [ebp+var_4]
.text$mn:00002653                 mov     eax, [edx+14h]
.text$mn:00002656                 sub     eax, [ebp+arg_0]
.text$mn:00002659                 cmp     eax, [ebp+arg_4]
.text$mn:0000265C                 ja      short loc_266C
.text$mn:0000265E                 mov     ecx, [ebp+arg_0]
.text$mn:00002661                 push    ecx
.text$mn:00002662                 mov     ecx, [ebp+var_4]
.text$mn:00002665                 call    ?_Eos@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEXI@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char>>::_Eos(uint)
.text$mn:0000266A                 jmp     short loc_26B2
.text$mn:0000266C ; ---------------------------------------------------------------------------
.text$mn:0000266C
.text$mn:0000266C loc_266C:                               ; CODE XREF: std::basic_string<char,std::char_traits<char>,std::allocator<char>>::erase(uint,uint)+28j
.text$mn:0000266C                 cmp     [ebp+arg_4], 0
.text$mn:00002670                 jbe     short loc_26B2
.text$mn:00002672                 mov     ecx, [ebp+var_4]
.text$mn:00002675                 call    ?_Myptr@?$_String_val@U?$_Simple_types@D@std@@@std@@QAEPADXZ ; std::_String_val<std::_Simple_types<char>>::_Myptr(void)
.text$mn:0000267A                 add     eax, [ebp+arg_0]
.text$mn:0000267D                 mov     [ebp+Dst], eax
.text$mn:00002680                 mov     edx, [ebp+var_4]
.text$mn:00002683                 mov     eax, [edx+14h]
.text$mn:00002686                 sub     eax, [ebp+arg_4]
.text$mn:00002689                 mov     [ebp+var_C], eax
.text$mn:0000268C                 mov     ecx, [ebp+var_C]
.text$mn:0000268F                 sub     ecx, [ebp+arg_0]
.text$mn:00002692                 push    ecx             ; Size
.text$mn:00002693                 mov     edx, [ebp+Dst]
.text$mn:00002696                 add     edx, [ebp+arg_4]
.text$mn:00002699                 push    edx             ; Src
.text$mn:0000269A                 mov     eax, [ebp+Dst]
.text$mn:0000269D                 push    eax             ; Dst
.text$mn:0000269E                 call    ?move@?$char_traits@D@std@@SAPADPADPBDI@Z ; std::char_traits<char>::move(char *,char const *,uint)
.text$mn:000026A3                 add     esp, 0Ch
.text$mn:000026A6                 mov     ecx, [ebp+var_C]
.text$mn:000026A9                 push    ecx
.text$mn:000026AA                 mov     ecx, [ebp+var_4]
.text$mn:000026AD                 call    ?_Eos@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEXI@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char>>::_Eos(uint)
.text$mn:000026B2
.text$mn:000026B2 loc_26B2:                               ; CODE XREF: std::basic_string<char,std::char_traits<char>,std::allocator<char>>::erase(uint,uint)+36j
.text$mn:000026B2                                         ; std::basic_string<char,std::char_traits<char>,std::allocator<char>>::erase(uint,uint)+3Cj
.text$mn:000026B2                 mov     eax, [ebp+var_4]
.text$mn:000026B5                 mov     esp, ebp
.text$mn:000026B7                 pop     ebp
.text$mn:000026B8                 retn    8
.text$mn:000026B8 ?erase@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV12@II@Z endp
.text$mn:000026B8
.text$mn:000026B8 ; ---------------------------------------------------------------------------
.text$mn:000026BB                 align 4
.text$mn:000026BB _text$mn        ends
.text$mn:000026BB
.text$mn:000026BC ; ===========================================================================
.text$mn:000026BC
.text$mn:000026BC ; Segment type: Pure code
.text$mn:000026BC ; Segment permissions: Read/Execute
.text$mn:000026BC _text$mn        segment para public 'CODE' use32
.text$mn:000026BC                 assume cs:_text$mn
.text$mn:000026BC                 ;org 26BCh
.text$mn:000026BC ; COMDAT (pick any)
.text$mn:000026BC                 assume es:nothing, ss:nothing, ds:_data, fs:nothing, gs:nothing
.text$mn:000026BC
.text$mn:000026BC ; =============== S U B R O U T I N E =======================================
.text$mn:000026BC
.text$mn:000026BC ; Attributes: bp-based frame
.text$mn:000026BC
.text$mn:000026BC ; __int32 __thiscall ScintillaEditView::execute(ScintillaEditView *this, unsigned int, unsigned int, __int32)
.text$mn:000026BC                 public ?execute@ScintillaEditView@@QBEJIIJ@Z
.text$mn:000026BC ?execute@ScintillaEditView@@QBEJIIJ@Z proc near
.text$mn:000026BC                                         ; CODE XREF: AnsiCharPanel::insertChar(uchar)+70p
.text$mn:000026BC                                         ; AnsiCharPanel::insertChar(uchar)+14Ap ...
.text$mn:000026BC
.text$mn:000026BC var_4           = dword ptr -4
.text$mn:000026BC arg_0           = dword ptr  8
.text$mn:000026BC arg_4           = dword ptr  0Ch
.text$mn:000026BC arg_8           = dword ptr  10h
.text$mn:000026BC
.text$mn:000026BC                 push    ebp
.text$mn:000026BD                 mov     ebp, esp
.text$mn:000026BF                 push    ecx
.text$mn:000026C0                 mov     [ebp+var_4], ecx
.text$mn:000026C3                 mov     eax, [ebp+arg_8]
.text$mn:000026C6                 push    eax
.text$mn:000026C7                 mov     ecx, [ebp+arg_4]
.text$mn:000026CA                 push    ecx
.text$mn:000026CB                 mov     edx, [ebp+arg_0]
.text$mn:000026CE                 push    edx
.text$mn:000026CF                 mov     eax, [ebp+var_4]
.text$mn:000026D2                 mov     ecx, [eax+14h]
.text$mn:000026D5                 push    ecx
.text$mn:000026D6                 mov     edx, [ebp+var_4]
.text$mn:000026D9                 mov     eax, [edx+10h]
.text$mn:000026DC                 call    eax
.text$mn:000026DE                 add     esp, 10h
.text$mn:000026E1                 mov     esp, ebp
.text$mn:000026E3                 pop     ebp
.text$mn:000026E4                 retn    0Ch
.text$mn:000026E4 ?execute@ScintillaEditView@@QBEJIIJ@Z endp
.text$mn:000026E4
.text$mn:000026E4 ; ---------------------------------------------------------------------------
.text$mn:000026E7                 align 4
.text$mn:000026E7 _text$mn        ends
.text$mn:000026E7
.text$mn:000026E8 ; ===========================================================================
.text$mn:000026E8
.text$mn:000026E8 ; Segment type: Pure code
.text$mn:000026E8 ; Segment permissions: Read/Execute
.text$mn:000026E8 _text$mn        segment para public 'CODE' use32
.text$mn:000026E8                 assume cs:_text$mn
.text$mn:000026E8                 ;org 26E8h
.text$mn:000026E8 ; COMDAT (pick any)
.text$mn:000026E8                 assume es:nothing, ss:nothing, ds:_data, fs:nothing, gs:nothing
.text$mn:000026E8
.text$mn:000026E8 ; =============== S U B R O U T I N E =======================================
.text$mn:000026E8
.text$mn:000026E8 ; Attributes: bp-based frame
.text$mn:000026E8
.text$mn:000026E8 ; const struct std::error_category *__cdecl std::generic_category()
.text$mn:000026E8                 public ?generic_category@std@@YAABVerror_category@1@XZ
.text$mn:000026E8 ?generic_category@std@@YAABVerror_category@1@XZ proc near
.text$mn:000026E8                                         ; CODE XREF: std::_System_error_category::default_error_condition(int)+17p
.text$mn:000026E8                 push    ebp
.text$mn:000026E9                 mov     ebp, esp
.text$mn:000026EB                 mov     eax, offset ?_Generic_object@?$_Error_objects@H@std@@2V_Generic_error_category@2@A ; std::_Generic_error_category std::_Error_objects<int>::_Generic_object
.text$mn:000026F0                 pop     ebp
.text$mn:000026F1                 retn
.text$mn:000026F1 ?generic_category@std@@YAABVerror_category@1@XZ endp
.text$mn:000026F1
.text$mn:000026F1 ; ---------------------------------------------------------------------------
.text$mn:000026F2                 align 4
.text$mn:000026F2 _text$mn        ends
.text$mn:000026F2
.text$mn:000026F4 ; ===========================================================================
.text$mn:000026F4
.text$mn:000026F4 ; Segment type: Pure code
.text$mn:000026F4 ; Segment permissions: Read/Execute
.text$mn:000026F4 _text$mn        segment para public 'CODE' use32
.text$mn:000026F4                 assume cs:_text$mn
.text$mn:000026F4                 ;org 26F4h
.text$mn:000026F4 ; COMDAT (pick any)
.text$mn:000026F4                 assume es:nothing, ss:nothing, ds:_data, fs:nothing, gs:nothing
.text$mn:000026F4
.text$mn:000026F4 ; =============== S U B R O U T I N E =======================================
.text$mn:000026F4
.text$mn:000026F4 ; Attributes: bp-based frame
.text$mn:000026F4
.text$mn:000026F4 ; struct Buffer *__thiscall ScintillaEditView::getCurrentBuffer(ScintillaEditView *__hidden this)
.text$mn:000026F4                 public ?getCurrentBuffer@ScintillaEditView@@QAEPAVBuffer@@XZ
.text$mn:000026F4 ?getCurrentBuffer@ScintillaEditView@@QAEPAVBuffer@@XZ proc near
.text$mn:000026F4                                         ; CODE XREF: AnsiCharPanel::switchEncoding(void)+11p
.text$mn:000026F4                                         ; AnsiCharPanel::insertChar(uchar)+46p ...
.text$mn:000026F4
.text$mn:000026F4 var_4           = dword ptr -4
.text$mn:000026F4
.text$mn:000026F4                 push    ebp
.text$mn:000026F5                 mov     ebp, esp
.text$mn:000026F7                 push    ecx
.text$mn:000026F8                 mov     [ebp+var_4], ecx
.text$mn:000026FB                 mov     eax, [ebp+var_4]
.text$mn:000026FE                 mov     eax, [eax+20h]
.text$mn:00002701                 mov     esp, ebp
.text$mn:00002703                 pop     ebp
.text$mn:00002704                 retn
.text$mn:00002704 ?getCurrentBuffer@ScintillaEditView@@QAEPAVBuffer@@XZ endp
.text$mn:00002704
.text$mn:00002704 ; ---------------------------------------------------------------------------
.text$mn:00002705                 align 4
.text$mn:00002705 _text$mn        ends
.text$mn:00002705
.text$mn:00002708 ; ===========================================================================
.text$mn:00002708
.text$mn:00002708 ; Segment type: Pure code
.text$mn:00002708 ; Segment permissions: Read/Execute
.text$mn:00002708 _text$mn        segment para public 'CODE' use32
.text$mn:00002708                 assume cs:_text$mn
.text$mn:00002708                 ;org 2708h
.text$mn:00002708 ; COMDAT (pick any)
.text$mn:00002708                 assume es:nothing, ss:nothing, ds:_data, fs:nothing, gs:nothing
.text$mn:00002708
.text$mn:00002708 ; =============== S U B R O U T I N E =======================================
.text$mn:00002708
.text$mn:00002708 ; Attributes: bp-based frame
.text$mn:00002708
.text$mn:00002708 ; int __thiscall Buffer::getEncoding(Buffer *__hidden this)
.text$mn:00002708                 public ?getEncoding@Buffer@@QBEHXZ
.text$mn:00002708 ?getEncoding@Buffer@@QBEHXZ proc near   ; CODE XREF: AnsiCharPanel::switchEncoding(void)+18p
.text$mn:00002708                                         ; AnsiCharPanel::insertChar(uchar)+4Dp ...
.text$mn:00002708
.text$mn:00002708 var_4           = dword ptr -4
.text$mn:00002708
.text$mn:00002708                 push    ebp
.text$mn:00002709                 mov     ebp, esp
.text$mn:0000270B                 push    ecx
.text$mn:0000270C                 mov     [ebp+var_4], ecx
.text$mn:0000270F                 mov     eax, [ebp+var_4]
.text$mn:00002712                 mov     eax, [eax+40h]
.text$mn:00002715                 mov     esp, ebp
.text$mn:00002717                 pop     ebp
.text$mn:00002718                 retn
.text$mn:00002718 ?getEncoding@Buffer@@QBEHXZ endp
.text$mn:00002718
.text$mn:00002718 ; ---------------------------------------------------------------------------
.text$mn:00002719                 align 4
.text$mn:00002719 _text$mn        ends
.text$mn:00002719
.text$mn:0000271C ; ===========================================================================
.text$mn:0000271C
.text$mn:0000271C ; Segment type: Pure code
.text$mn:0000271C ; Segment permissions: Read/Execute
.text$mn:0000271C _text$mn        segment para public 'CODE' use32
.text$mn:0000271C                 assume cs:_text$mn
.text$mn:0000271C                 ;org 271Ch
.text$mn:0000271C ; COMDAT (pick any)
.text$mn:0000271C                 assume es:nothing, ss:nothing, ds:_data, fs:nothing, gs:nothing
.text$mn:0000271C
.text$mn:0000271C ; =============== S U B R O U T I N E =======================================
.text$mn:0000271C
.text$mn:0000271C ; Attributes: bp-based frame
.text$mn:0000271C
.text$mn:0000271C ; void __thiscall Window::getFocus(Window *__hidden this)
.text$mn:0000271C                 public ?getFocus@Window@@QBEXXZ
.text$mn:0000271C ?getFocus@Window@@QBEXXZ proc near      ; CODE XREF: AnsiCharPanel::insertChar(uchar)+19Bp
.text$mn:0000271C
.text$mn:0000271C var_4           = dword ptr -4
.text$mn:0000271C
.text$mn:0000271C                 push    ebp
.text$mn:0000271D                 mov     ebp, esp
.text$mn:0000271F                 push    ecx
.text$mn:00002720                 mov     [ebp+var_4], ecx
.text$mn:00002723                 mov     eax, [ebp+var_4]
.text$mn:00002726                 mov     ecx, [eax+0Ch]
.text$mn:00002729                 push    ecx             ; hWnd
.text$mn:0000272A                 call    dword ptr ds:__imp__SetFocus@4 ; SetFocus(x)
.text$mn:00002730                 mov     esp, ebp
.text$mn:00002732                 pop     ebp
.text$mn:00002733                 retn
.text$mn:00002733 ?getFocus@Window@@QBEXXZ endp
.text$mn:00002733
.text$mn:00002733 _text$mn        ends
.text$mn:00002733
.text$mn:00002734 ; ===========================================================================
.text$mn:00002734
.text$mn:00002734 ; Segment type: Pure code
.text$mn:00002734 ; Segment permissions: Read/Execute
.text$mn:00002734 _text$mn        segment para public 'CODE' use32
.text$mn:00002734                 assume cs:_text$mn
.text$mn:00002734                 ;org 2734h
.text$mn:00002734 ; COMDAT (pick any)
.text$mn:00002734                 assume es:nothing, ss:nothing, ds:_data, fs:nothing, gs:nothing
.text$mn:00002734
.text$mn:00002734 ; =============== S U B R O U T I N E =======================================
.text$mn:00002734
.text$mn:00002734 ; Attributes: bp-based frame
.text$mn:00002734
.text$mn:00002734 ; HWND __thiscall Window::getHSelf(Window *__hidden this)
.text$mn:00002734                 public ?getHSelf@Window@@QBEPAUHWND__@@XZ
.text$mn:00002734 ?getHSelf@Window@@QBEPAUHWND__@@XZ proc near
.text$mn:00002734                                         ; CODE XREF: AnsiCharPanel::run_dlgProc(uint,uint,long)+119p
.text$mn:00002734                                         ; AnsiCharPanel::run_dlgProc(uint,uint,long)+187p
.text$mn:00002734
.text$mn:00002734 var_4           = dword ptr -4
.text$mn:00002734
.text$mn:00002734                 push    ebp
.text$mn:00002735                 mov     ebp, esp
.text$mn:00002737                 push    ecx
.text$mn:00002738                 mov     [ebp+var_4], ecx
.text$mn:0000273B                 mov     eax, [ebp+var_4]
.text$mn:0000273E                 mov     eax, [eax+0Ch]
.text$mn:00002741                 mov     esp, ebp
.text$mn:00002743                 pop     ebp
.text$mn:00002744                 retn
.text$mn:00002744 ?getHSelf@Window@@QBEPAUHWND__@@XZ endp
.text$mn:00002744
.text$mn:00002744 ; ---------------------------------------------------------------------------
.text$mn:00002745                 align 4
.text$mn:00002745 _text$mn        ends
.text$mn:00002745
.text$mn:00002748 ; ===========================================================================
.text$mn:00002748
.text$mn:00002748 ; Segment type: Pure code
.text$mn:00002748 ; Segment permissions: Read/Execute
.text$mn:00002748 _text$mn        segment para public 'CODE' use32
.text$mn:00002748                 assume cs:_text$mn
.text$mn:00002748                 ;org 2748h
.text$mn:00002748 ; COMDAT (pick any)
.text$mn:00002748                 assume es:nothing, ss:nothing, ds:_data, fs:nothing, gs:nothing
.text$mn:00002748
.text$mn:00002748 ; =============== S U B R O U T I N E =======================================
.text$mn:00002748
.text$mn:00002748 ; Attributes: bp-based frame
.text$mn:00002748
.text$mn:00002748 ; int __cdecl std::char_traits<char>::length(char *Str)
.text$mn:00002748                 public ?length@?$char_traits@D@std@@SAIPBD@Z
.text$mn:00002748 ?length@?$char_traits@D@std@@SAIPBD@Z proc near
.text$mn:00002748                                         ; CODE XREF: std::basic_string<char,std::char_traits<char>,std::allocator<char>>::assign(char const *)+21p
.text$mn:00002748
.text$mn:00002748 var_4           = dword ptr -4
.text$mn:00002748 Str             = dword ptr  8
.text$mn:00002748
.text$mn:00002748                 push    ebp
.text$mn:00002749                 mov     ebp, esp
.text$mn:0000274B                 push    ecx
.text$mn:0000274C                 mov     eax, [ebp+Str]
.text$mn:0000274F                 movsx   ecx, byte ptr [eax]
.text$mn:00002752                 test    ecx, ecx
.text$mn:00002754                 jnz     short loc_275F
.text$mn:00002756                 mov     [ebp+var_4], 0
.text$mn:0000275D                 jmp     short loc_276E
.text$mn:0000275F ; ---------------------------------------------------------------------------
.text$mn:0000275F
.text$mn:0000275F loc_275F:                               ; CODE XREF: std::char_traits<char>::length(char const *)+Cj
.text$mn:0000275F                 mov     edx, [ebp+Str]
.text$mn:00002762                 push    edx             ; Str
.text$mn:00002763                 call    _strlen
.text$mn:00002768                 add     esp, 4
.text$mn:0000276B                 mov     [ebp+var_4], eax
.text$mn:0000276E
.text$mn:0000276E loc_276E:                               ; CODE XREF: std::char_traits<char>::length(char const *)+15j
.text$mn:0000276E                 mov     eax, [ebp+var_4]
.text$mn:00002771                 mov     esp, ebp
.text$mn:00002773                 pop     ebp
.text$mn:00002774                 retn
.text$mn:00002774 ?length@?$char_traits@D@std@@SAIPBD@Z endp
.text$mn:00002774
.text$mn:00002774 ; ---------------------------------------------------------------------------
.text$mn:00002775                 align 4
.text$mn:00002775 _text$mn        ends
.text$mn:00002775
.text$mn:00002778 ; ===========================================================================
.text$mn:00002778
.text$mn:00002778 ; Segment type: Pure code
.text$mn:00002778 ; Segment permissions: Read/Execute
.text$mn:00002778 _text$mn        segment para public 'CODE' use32
.text$mn:00002778                 assume cs:_text$mn
.text$mn:00002778                 ;org 2778h
.text$mn:00002778 ; COMDAT (pick any)
.text$mn:00002778                 assume es:nothing, ss:nothing, ds:_data, fs:nothing, gs:nothing
.text$mn:00002778
.text$mn:00002778 ; =============== S U B R O U T I N E =======================================
.text$mn:00002778
.text$mn:00002778 ; Attributes: bp-based frame
.text$mn:00002778
.text$mn:00002778 ; public: unsigned int __thiscall std::_Wrap_alloc<class std::allocator<char>>::max_size(void)const
.text$mn:00002778                 public ?max_size@?$_Wrap_alloc@V?$allocator@D@std@@@std@@QBEIXZ
.text$mn:00002778 ?max_size@?$_Wrap_alloc@V?$allocator@D@std@@@std@@QBEIXZ proc near
.text$mn:00002778                                         ; CODE XREF: std::basic_string<char,std::char_traits<char>,std::allocator<char>>::max_size(void)+17p
.text$mn:00002778
.text$mn:00002778 var_4           = dword ptr -4
.text$mn:00002778
.text$mn:00002778                 push    ebp
.text$mn:00002779                 mov     ebp, esp
.text$mn:0000277B                 push    ecx
.text$mn:0000277C                 mov     [ebp+var_4], ecx
.text$mn:0000277F                 mov     eax, [ebp+var_4]
.text$mn:00002782                 push    eax
.text$mn:00002783                 call    ?max_size@?$allocator_traits@V?$allocator@D@std@@@std@@SAIABV?$allocator@D@2@@Z ; std::allocator_traits<std::allocator<char>>::max_size(std::allocator<char> const &)
.text$mn:00002788                 add     esp, 4
.text$mn:0000278B                 mov     esp, ebp
.text$mn:0000278D                 pop     ebp
.text$mn:0000278E                 retn
.text$mn:0000278E ?max_size@?$_Wrap_alloc@V?$allocator@D@std@@@std@@QBEIXZ endp
.text$mn:0000278E
.text$mn:0000278E ; ---------------------------------------------------------------------------
.text$mn:0000278F                 align 10h
.text$mn:0000278F _text$mn        ends
.text$mn:0000278F
.text$mn:00002790 ; ===========================================================================
.text$mn:00002790
.text$mn:00002790 ; Segment type: Pure code
.text$mn:00002790 ; Segment permissions: Read/Execute
.text$mn:00002790 _text$mn        segment para public 'CODE' use32
.text$mn:00002790                 assume cs:_text$mn
.text$mn:00002790                 ;org 2790h
.text$mn:00002790 ; COMDAT (pick any)
.text$mn:00002790                 assume es:nothing, ss:nothing, ds:_data, fs:nothing, gs:nothing
.text$mn:00002790
.text$mn:00002790 ; =============== S U B R O U T I N E =======================================
.text$mn:00002790
.text$mn:00002790 ; Attributes: bp-based frame
.text$mn:00002790
.text$mn:00002790 ; public: unsigned int __thiscall std::allocator<char>::max_size(void)const
.text$mn:00002790                 public ?max_size@?$allocator@D@std@@QBEIXZ
.text$mn:00002790 ?max_size@?$allocator@D@std@@QBEIXZ proc near
.text$mn:00002790                                         ; CODE XREF: std::allocator_traits<std::allocator<char>>::max_size(std::allocator<char> const &)+6p
.text$mn:00002790
.text$mn:00002790 var_4           = dword ptr -4
.text$mn:00002790
.text$mn:00002790                 push    ebp
.text$mn:00002791                 mov     ebp, esp
.text$mn:00002793                 push    ecx
.text$mn:00002794                 mov     [ebp+var_4], ecx
.text$mn:00002797                 or      eax, 0FFFFFFFFh
.text$mn:0000279A                 mov     esp, ebp
.text$mn:0000279C                 pop     ebp
.text$mn:0000279D                 retn
.text$mn:0000279D ?max_size@?$allocator@D@std@@QBEIXZ endp
.text$mn:0000279D
.text$mn:0000279D ; ---------------------------------------------------------------------------
.text$mn:0000279E                 align 10h
.text$mn:0000279E _text$mn        ends
.text$mn:0000279E
.text$mn:000027A0 ; ===========================================================================
.text$mn:000027A0
.text$mn:000027A0 ; Segment type: Pure code
.text$mn:000027A0 ; Segment permissions: Read/Execute
.text$mn:000027A0 _text$mn        segment para public 'CODE' use32
.text$mn:000027A0                 assume cs:_text$mn
.text$mn:000027A0                 ;org 27A0h
.text$mn:000027A0 ; COMDAT (pick any)
.text$mn:000027A0                 assume es:nothing, ss:nothing, ds:_data, fs:nothing, gs:nothing
.text$mn:000027A0
.text$mn:000027A0 ; =============== S U B R O U T I N E =======================================
.text$mn:000027A0
.text$mn:000027A0 ; Attributes: bp-based frame
.text$mn:000027A0
.text$mn:000027A0 ; public: static unsigned int __cdecl std::allocator_traits<class std::allocator<char>>::max_size(class std::allocator<char> const &)
.text$mn:000027A0                 public ?max_size@?$allocator_traits@V?$allocator@D@std@@@std@@SAIABV?$allocator@D@2@@Z
.text$mn:000027A0 ?max_size@?$allocator_traits@V?$allocator@D@std@@@std@@SAIABV?$allocator@D@2@@Z proc near
.text$mn:000027A0                                         ; CODE XREF: std::_Wrap_alloc<std::allocator<char>>::max_size(void)+Bp
.text$mn:000027A0
.text$mn:000027A0 arg_0           = dword ptr  8
.text$mn:000027A0
.text$mn:000027A0                 push    ebp
.text$mn:000027A1                 mov     ebp, esp
.text$mn:000027A3                 mov     ecx, [ebp+arg_0]
.text$mn:000027A6                 call    ?max_size@?$allocator@D@std@@QBEIXZ ; std::allocator<char>::max_size(void)
.text$mn:000027AB                 pop     ebp
.text$mn:000027AC                 retn
.text$mn:000027AC ?max_size@?$allocator_traits@V?$allocator@D@std@@@std@@SAIABV?$allocator@D@2@@Z endp
.text$mn:000027AC
.text$mn:000027AC ; ---------------------------------------------------------------------------
.text$mn:000027AD                 align 10h
.text$mn:000027AD _text$mn        ends
.text$mn:000027AD
.text$mn:000027B0 ; ===========================================================================
.text$mn:000027B0
.text$mn:000027B0 ; Segment type: Pure code
.text$mn:000027B0 ; Segment permissions: Read/Execute
.text$mn:000027B0 _text$mn        segment para public 'CODE' use32
.text$mn:000027B0                 assume cs:_text$mn
.text$mn:000027B0                 ;org 27B0h
.text$mn:000027B0 ; COMDAT (pick any)
.text$mn:000027B0                 assume es:nothing, ss:nothing, ds:_data, fs:nothing, gs:nothing
.text$mn:000027B0
.text$mn:000027B0 ; =============== S U B R O U T I N E =======================================
.text$mn:000027B0
.text$mn:000027B0 ; Attributes: bp-based frame
.text$mn:000027B0
.text$mn:000027B0 ; public: unsigned int __thiscall std::basic_string<char, struct std::char_traits<char>, class std::allocator<char>>::max_size(void)const
.text$mn:000027B0                 public ?max_size@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QBEIXZ
.text$mn:000027B0 ?max_size@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QBEIXZ proc near
.text$mn:000027B0                                         ; CODE XREF: std::basic_string<char,std::char_traits<char>,std::allocator<char>>::_Copy(uint,uint)+3Bp
.text$mn:000027B0                                         ; std::basic_string<char,std::char_traits<char>,std::allocator<char>>::_Copy(uint,uint)+6Ap ...
.text$mn:000027B0
.text$mn:000027B0 var_10          = dword ptr -10h
.text$mn:000027B0 var_C           = dword ptr -0Ch
.text$mn:000027B0 var_8           = dword ptr -8
.text$mn:000027B0 var_1           = byte ptr -1
.text$mn:000027B0
.text$mn:000027B0                 push    ebp
.text$mn:000027B1                 mov     ebp, esp
.text$mn:000027B3                 sub     esp, 10h
.text$mn:000027B6                 mov     [ebp+var_10], ecx
.text$mn:000027B9                 lea     eax, [ebp+var_1]
.text$mn:000027BC                 push    eax
.text$mn:000027BD                 mov     ecx, [ebp+var_10]
.text$mn:000027C0                 call    ?_Getal@?$_String_alloc@$0A@U?$_String_base_types@DV?$allocator@D@std@@@std@@@std@@QBE?AU?$_Wrap_alloc@V?$allocator@D@std@@@2@XZ ; std::_String_alloc<0,std::_String_base_types<char,std::allocator<char>>>::_Getal(void)
.text$mn:000027C5                 mov     ecx, eax
.text$mn:000027C7                 call    ?max_size@?$_Wrap_alloc@V?$allocator@D@std@@@std@@QBEIXZ ; std::_Wrap_alloc<std::allocator<char>>::max_size(void)
.text$mn:000027CC                 mov     [ebp+var_8], eax
.text$mn:000027CF                 cmp     [ebp+var_8], 1
.text$mn:000027D3                 ja      short loc_27DE
.text$mn:000027D5                 mov     [ebp+var_C], 1
.text$mn:000027DC                 jmp     short loc_27E7
.text$mn:000027DE ; ---------------------------------------------------------------------------
.text$mn:000027DE
.text$mn:000027DE loc_27DE:                               ; CODE XREF: std::basic_string<char,std::char_traits<char>,std::allocator<char>>::max_size(void)+23j
.text$mn:000027DE                 mov     ecx, [ebp+var_8]
.text$mn:000027E1                 sub     ecx, 1
.text$mn:000027E4                 mov     [ebp+var_C], ecx
.text$mn:000027E7
.text$mn:000027E7 loc_27E7:                               ; CODE XREF: std::basic_string<char,std::char_traits<char>,std::allocator<char>>::max_size(void)+2Cj
.text$mn:000027E7                 mov     eax, [ebp+var_C]
.text$mn:000027EA                 mov     esp, ebp
.text$mn:000027EC                 pop     ebp
.text$mn:000027ED                 retn
.text$mn:000027ED ?max_size@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QBEIXZ endp
.text$mn:000027ED
.text$mn:000027ED ; ---------------------------------------------------------------------------
.text$mn:000027EE                 align 10h
.text$mn:000027EE _text$mn        ends
.text$mn:000027EE
.text$mn:000027F0 ; ===========================================================================
.text$mn:000027F0
.text$mn:000027F0 ; Segment type: Pure code
.text$mn:000027F0 ; Segment permissions: Read/Execute
.text$mn:000027F0 _text$mn        segment para public 'CODE' use32
.text$mn:000027F0                 assume cs:_text$mn
.text$mn:000027F0                 ;org 27F0h
.text$mn:000027F0 ; COMDAT (pick any)
.text$mn:000027F0                 assume es:nothing, ss:nothing, ds:_data, fs:nothing, gs:nothing
.text$mn:000027F0
.text$mn:000027F0 ; =============== S U B R O U T I N E =======================================
.text$mn:000027F0
.text$mn:000027F0 ; Attributes: bp-based frame
.text$mn:000027F0
.text$mn:000027F0 ; public: virtual class std::basic_string<char, struct std::char_traits<char>, class std::allocator<char>> __thiscall std::_Generic_error_category::message(int)const
.text$mn:000027F0                 public ?message@_Generic_error_category@std@@UBE?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@2@H@Z
.text$mn:000027F0 ?message@_Generic_error_category@std@@UBE?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@2@H@Z proc near
.text$mn:000027F0                                         ; CODE XREF: std::_Iostream_error_category::message(int)+64p
.text$mn:000027F0                                         ; DATA XREF: .rdata:00002F3Co
.text$mn:000027F0
.text$mn:000027F0 var_1C          = dword ptr -1Ch
.text$mn:000027F0 var_18          = dword ptr -18h
.text$mn:000027F0 Str             = dword ptr -14h
.text$mn:000027F0 var_10          = dword ptr -10h
.text$mn:000027F0 var_C           = dword ptr -0Ch
.text$mn:000027F0 var_4           = dword ptr -4
.text$mn:000027F0 arg_0           = dword ptr  8
.text$mn:000027F0 arg_4           = dword ptr  0Ch
.text$mn:000027F0
.text$mn:000027F0                 push    ebp
.text$mn:000027F1                 mov     ebp, esp
.text$mn:000027F3                 push    0FFFFFFFFh
.text$mn:000027F5                 push    offset __ehhandler$?message@_Generic_error_category@std@@UBE?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@2@H@Z
.text$mn:000027FA                 mov     eax, large fs:0
.text$mn:00002800                 push    eax
.text$mn:00002801                 sub     esp, 10h
.text$mn:00002804                 mov     eax, dword ptr ds:___security_cookie
.text$mn:00002809                 xor     eax, ebp
.text$mn:0000280B                 push    eax
.text$mn:0000280C                 lea     eax, [ebp+var_C]
.text$mn:0000280F                 mov     large fs:0, eax
.text$mn:00002815                 mov     [ebp+var_1C], ecx
.text$mn:00002818                 mov     [ebp+var_18], 0
.text$mn:0000281F                 mov     eax, [ebp+arg_4]
.text$mn:00002822                 push    eax             ; int
.text$mn:00002823                 call    ?_Syserror_map@std@@YAPBDH@Z ; std::_Syserror_map(int)
.text$mn:00002828                 add     esp, 4
.text$mn:0000282B                 mov     [ebp+var_10], eax
.text$mn:0000282E                 cmp     [ebp+var_10], 0
.text$mn:00002832                 jz      short loc_283C
.text$mn:00002834                 mov     ecx, [ebp+var_10]
.text$mn:00002837                 mov     [ebp+Str], ecx
.text$mn:0000283A                 jmp     short loc_2843
.text$mn:0000283C ; ---------------------------------------------------------------------------
.text$mn:0000283C
.text$mn:0000283C loc_283C:                               ; CODE XREF: std::_Generic_error_category::message(int)+42j
.text$mn:0000283C                 mov     [ebp+Str], offset ??_C@_0O@BFJCFAAK@unknown?5error?$AA@ ; "unknown error"
.text$mn:00002843
.text$mn:00002843 loc_2843:                               ; CODE XREF: std::_Generic_error_category::message(int)+4Aj
.text$mn:00002843                 mov     edx, [ebp+Str]
.text$mn:00002846                 push    edx             ; Str
.text$mn:00002847                 mov     ecx, [ebp+arg_0]
.text$mn:0000284A                 call    ??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@PBD@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char>>::basic_string<char,std::char_traits<char>,std::allocator<char>>(char const *)
.text$mn:0000284F                 mov     [ebp+var_4], 0
.text$mn:00002856                 mov     eax, [ebp+var_18]
.text$mn:00002859                 or      eax, 1
.text$mn:0000285C                 mov     [ebp+var_18], eax
.text$mn:0000285F                 mov     eax, [ebp+arg_0]
.text$mn:00002862                 mov     ecx, [ebp+var_C]
.text$mn:00002865                 mov     large fs:0, ecx
.text$mn:0000286C                 pop     ecx
.text$mn:0000286D                 mov     esp, ebp
.text$mn:0000286F                 pop     ebp
.text$mn:00002870                 retn    8
.text$mn:00002870 ?message@_Generic_error_category@std@@UBE?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@2@H@Z endp
.text$mn:00002870
.text$mn:00002870 ; ---------------------------------------------------------------------------
.text$mn:00002873                 align 4
.text$mn:00002873 _text$mn        ends
.text$mn:00002873
.text$x:00002874 ; ===========================================================================
.text$x:00002874
.text$x:00002874 ; Segment type: Pure code
.text$x:00002874 ; Segment permissions: Read/Execute
.text$x:00002874 _text$x         segment para public 'CODE' use32
.text$x:00002874                 assume cs:_text$x
.text$x:00002874                 ;org 2874h
.text$x:00002874 ; COMDAT (pick associative to section at 27F0)
.text$x:00002874                 assume es:nothing, ss:nothing, ds:_data, fs:nothing, gs:nothing
.text$x:00002874
.text$x:00002874 ; =============== S U B R O U T I N E =======================================
.text$x:00002874
.text$x:00002874
.text$x:00002874 __unwindfunclet$?message@_Generic_error_category@std@@UBE?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@2@H@Z$0 proc near
.text$x:00002874                                         ; DATA XREF: .xdata$x:00002D5Co
.text$x:00002874                 mov     eax, [ebp-18h]
.text$x:00002877                 and     eax, 1
.text$x:0000287A                 jz      $LN6
.text$x:00002880                 and     dword ptr [ebp-18h], 0FFFFFFFEh
.text$x:00002884                 mov     ecx, [ebp+8]
.text$x:00002887                 jmp     ??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char>>::~basic_string<char,std::char_traits<char>,std::allocator<char>>(void)
.text$x:0000288C ; ---------------------------------------------------------------------------
.text$x:0000288C
.text$x:0000288C $LN6:                                   ; CODE XREF: __unwindfunclet$?message@_Generic_error_category@std@@UBE?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@2@H@Z$0+6j
.text$x:0000288C                 retn
.text$x:0000288C __unwindfunclet$?message@_Generic_error_category@std@@UBE?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@2@H@Z$0 endp
.text$x:0000288C
.text$x:0000288D
.text$x:0000288D ; =============== S U B R O U T I N E =======================================
.text$x:0000288D
.text$x:0000288D
.text$x:0000288D __ehhandler$?message@_Generic_error_category@std@@UBE?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@2@H@Z proc near
.text$x:0000288D                                         ; DATA XREF: std::_Generic_error_category::message(int)+5o
.text$x:0000288D
.text$x:0000288D arg_4           = dword ptr  8
.text$x:0000288D
.text$x:0000288D                 mov     edx, [esp+arg_4]
.text$x:00002891                 lea     eax, [edx+0Ch]
.text$x:00002894                 mov     ecx, [edx-14h]
.text$x:00002897                 xor     ecx, eax
.text$x:00002899                 call    @__security_check_cookie@4 ; __security_check_cookie(x)
.text$x:0000289E                 mov     eax, offset __ehfuncinfo$?message@_Generic_error_category@std@@UBE?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@2@H@Z
.text$x:000028A3                 jmp     ___CxxFrameHandler3
.text$x:000028A3 __ehhandler$?message@_Generic_error_category@std@@UBE?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@2@H@Z endp
.text$x:000028A3
.text$x:000028A3 _text$x         ends
.text$x:000028A3
.text$mn:000028A8 ; ===========================================================================
.text$mn:000028A8
.text$mn:000028A8 ; Segment type: Pure code
.text$mn:000028A8 ; Segment permissions: Read/Execute
.text$mn:000028A8 _text$mn        segment para public 'CODE' use32
.text$mn:000028A8                 assume cs:_text$mn
.text$mn:000028A8                 ;org 28A8h
.text$mn:000028A8 ; COMDAT (pick any)
.text$mn:000028A8                 assume es:nothing, ss:nothing, ds:_data, fs:nothing, gs:nothing
.text$mn:000028A8
.text$mn:000028A8 ; =============== S U B R O U T I N E =======================================
.text$mn:000028A8
.text$mn:000028A8 ; Attributes: bp-based frame
.text$mn:000028A8
.text$mn:000028A8 ; public: virtual class std::basic_string<char, struct std::char_traits<char>, class std::allocator<char>> __thiscall std::_Iostream_error_category::message(int)const
.text$mn:000028A8                 public ?message@_Iostream_error_category@std@@UBE?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@2@H@Z
.text$mn:000028A8 ?message@_Iostream_error_category@std@@UBE?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@2@H@Z proc near
.text$mn:000028A8                                         ; DATA XREF: .rdata:00002F70o
.text$mn:000028A8
.text$mn:000028A8 var_14          = dword ptr -14h
.text$mn:000028A8 var_10          = dword ptr -10h
.text$mn:000028A8 var_C           = dword ptr -0Ch
.text$mn:000028A8 var_4           = dword ptr -4
.text$mn:000028A8 arg_0           = dword ptr  8
.text$mn:000028A8 arg_4           = dword ptr  0Ch
.text$mn:000028A8
.text$mn:000028A8                 push    ebp
.text$mn:000028A9                 mov     ebp, esp
.text$mn:000028AB                 push    0FFFFFFFFh
.text$mn:000028AD                 push    offset __ehhandler$?message@_Iostream_error_category@std@@UBE?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@2@H@Z
.text$mn:000028B2                 mov     eax, large fs:0
.text$mn:000028B8                 push    eax
.text$mn:000028B9                 sub     esp, 8
.text$mn:000028BC                 mov     eax, dword ptr ds:___security_cookie
.text$mn:000028C1                 xor     eax, ebp
.text$mn:000028C3                 push    eax
.text$mn:000028C4                 lea     eax, [ebp+var_C]
.text$mn:000028C7                 mov     large fs:0, eax
.text$mn:000028CD                 mov     [ebp+var_14], ecx
.text$mn:000028D0                 mov     [ebp+var_10], 0
.text$mn:000028D7                 cmp     [ebp+arg_4], 1
.text$mn:000028DB                 jnz     short loc_2901
.text$mn:000028DD                 push    offset ??_C@_0BG@PADBLCHM@iostream?5stream?5error?$AA@ ; "iostream stream error"
.text$mn:000028E2                 mov     ecx, [ebp+arg_0]
.text$mn:000028E5                 call    ??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@PBD@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char>>::basic_string<char,std::char_traits<char>,std::allocator<char>>(char const *)
.text$mn:000028EA                 mov     [ebp+var_4], 0
.text$mn:000028F1                 mov     eax, [ebp+var_10]
.text$mn:000028F4                 or      eax, 1
.text$mn:000028F7                 mov     [ebp+var_10], eax
.text$mn:000028FA                 mov     eax, [ebp+arg_0]
.text$mn:000028FD                 jmp     short loc_2924
.text$mn:000028FF ; ---------------------------------------------------------------------------
.text$mn:000028FF                 jmp     short loc_2924
.text$mn:00002901 ; ---------------------------------------------------------------------------
.text$mn:00002901
.text$mn:00002901 loc_2901:                               ; CODE XREF: std::_Iostream_error_category::message(int)+33j
.text$mn:00002901                 mov     ecx, [ebp+arg_4]
.text$mn:00002904                 push    ecx
.text$mn:00002905                 mov     edx, [ebp+arg_0]
.text$mn:00002908                 push    edx
.text$mn:00002909                 mov     ecx, [ebp+var_14]
.text$mn:0000290C                 call    ?message@_Generic_error_category@std@@UBE?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@2@H@Z ; std::_Generic_error_category::message(int)
.text$mn:00002911                 mov     [ebp+var_4], 0
.text$mn:00002918                 mov     eax, [ebp+var_10]
.text$mn:0000291B                 or      eax, 1
.text$mn:0000291E                 mov     [ebp+var_10], eax
.text$mn:00002921                 mov     eax, [ebp+arg_0]
.text$mn:00002924
.text$mn:00002924 loc_2924:                               ; CODE XREF: std::_Iostream_error_category::message(int)+55j
.text$mn:00002924                                         ; std::_Iostream_error_category::message(int)+57j
.text$mn:00002924                 mov     ecx, [ebp+var_C]
.text$mn:00002927                 mov     large fs:0, ecx
.text$mn:0000292E                 pop     ecx
.text$mn:0000292F                 mov     esp, ebp
.text$mn:00002931                 pop     ebp
.text$mn:00002932                 retn    8
.text$mn:00002932 ?message@_Iostream_error_category@std@@UBE?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@2@H@Z endp
.text$mn:00002932
.text$mn:00002932 ; ---------------------------------------------------------------------------
.text$mn:00002935                 align 4
.text$mn:00002935 _text$mn        ends
.text$mn:00002935
.text$x:00002938 ; ===========================================================================
.text$x:00002938
.text$x:00002938 ; Segment type: Pure code
.text$x:00002938 ; Segment permissions: Read/Execute
.text$x:00002938 _text$x         segment para public 'CODE' use32
.text$x:00002938                 assume cs:_text$x
.text$x:00002938                 ;org 2938h
.text$x:00002938 ; COMDAT (pick associative to section at 28A8)
.text$x:00002938                 assume es:nothing, ss:nothing, ds:_data, fs:nothing, gs:nothing
.text$x:00002938
.text$x:00002938 ; =============== S U B R O U T I N E =======================================
.text$x:00002938
.text$x:00002938
.text$x:00002938 __unwindfunclet$?message@_Iostream_error_category@std@@UBE?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@2@H@Z$0 proc near
.text$x:00002938                                         ; DATA XREF: .xdata$x:00002DE0o
.text$x:00002938                 mov     eax, [ebp-10h]
.text$x:0000293B                 and     eax, 1
.text$x:0000293E                 jz      $LN6_0
.text$x:00002944                 and     dword ptr [ebp-10h], 0FFFFFFFEh
.text$x:00002948                 mov     ecx, [ebp+8]
.text$x:0000294B                 jmp     ??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char>>::~basic_string<char,std::char_traits<char>,std::allocator<char>>(void)
.text$x:00002950 ; ---------------------------------------------------------------------------
.text$x:00002950
.text$x:00002950 $LN6_0:                                 ; CODE XREF: __unwindfunclet$?message@_Iostream_error_category@std@@UBE?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@2@H@Z$0+6j
.text$x:00002950                 retn
.text$x:00002950 __unwindfunclet$?message@_Iostream_error_category@std@@UBE?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@2@H@Z$0 endp
.text$x:00002950
.text$x:00002951
.text$x:00002951 ; =============== S U B R O U T I N E =======================================
.text$x:00002951
.text$x:00002951
.text$x:00002951 __ehhandler$?message@_Iostream_error_category@std@@UBE?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@2@H@Z proc near
.text$x:00002951                                         ; DATA XREF: std::_Iostream_error_category::message(int)+5o
.text$x:00002951
.text$x:00002951 arg_4           = dword ptr  8
.text$x:00002951
.text$x:00002951                 mov     edx, [esp+arg_4]
.text$x:00002955                 lea     eax, [edx+0Ch]
.text$x:00002958                 mov     ecx, [edx-0Ch]
.text$x:0000295B                 xor     ecx, eax
.text$x:0000295D                 call    @__security_check_cookie@4 ; __security_check_cookie(x)
.text$x:00002962                 mov     eax, offset __ehfuncinfo$?message@_Iostream_error_category@std@@UBE?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@2@H@Z
.text$x:00002967                 jmp     ___CxxFrameHandler3
.text$x:00002967 __ehhandler$?message@_Iostream_error_category@std@@UBE?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@2@H@Z endp
.text$x:00002967
.text$x:00002967 _text$x         ends
.text$x:00002967
.text$mn:0000296C ; ===========================================================================
.text$mn:0000296C
.text$mn:0000296C ; Segment type: Pure code
.text$mn:0000296C ; Segment permissions: Read/Execute
.text$mn:0000296C _text$mn        segment para public 'CODE' use32
.text$mn:0000296C                 assume cs:_text$mn
.text$mn:0000296C                 ;org 296Ch
.text$mn:0000296C ; COMDAT (pick any)
.text$mn:0000296C                 assume es:nothing, ss:nothing, ds:_data, fs:nothing, gs:nothing
.text$mn:0000296C
.text$mn:0000296C ; =============== S U B R O U T I N E =======================================
.text$mn:0000296C
.text$mn:0000296C ; Attributes: bp-based frame
.text$mn:0000296C
.text$mn:0000296C ; public: virtual class std::basic_string<char, struct std::char_traits<char>, class std::allocator<char>> __thiscall std::_System_error_category::message(int)const
.text$mn:0000296C                 public ?message@_System_error_category@std@@UBE?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@2@H@Z
.text$mn:0000296C ?message@_System_error_category@std@@UBE?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@2@H@Z proc near
.text$mn:0000296C                                         ; DATA XREF: .rdata:00002FB0o
.text$mn:0000296C
.text$mn:0000296C var_1C          = dword ptr -1Ch
.text$mn:0000296C var_18          = dword ptr -18h
.text$mn:0000296C Str             = dword ptr -14h
.text$mn:0000296C var_10          = dword ptr -10h
.text$mn:0000296C var_C           = dword ptr -0Ch
.text$mn:0000296C var_4           = dword ptr -4
.text$mn:0000296C arg_0           = dword ptr  8
.text$mn:0000296C arg_4           = dword ptr  0Ch
.text$mn:0000296C
.text$mn:0000296C                 push    ebp
.text$mn:0000296D                 mov     ebp, esp
.text$mn:0000296F                 push    0FFFFFFFFh
.text$mn:00002971                 push    offset __ehhandler$?message@_System_error_category@std@@UBE?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@2@H@Z
.text$mn:00002976                 mov     eax, large fs:0
.text$mn:0000297C                 push    eax
.text$mn:0000297D                 sub     esp, 10h
.text$mn:00002980                 mov     eax, dword ptr ds:___security_cookie
.text$mn:00002985                 xor     eax, ebp
.text$mn:00002987                 push    eax
.text$mn:00002988                 lea     eax, [ebp+var_C]
.text$mn:0000298B                 mov     large fs:0, eax
.text$mn:00002991                 mov     [ebp+var_1C], ecx
.text$mn:00002994                 mov     [ebp+var_18], 0
.text$mn:0000299B                 mov     eax, [ebp+arg_4]
.text$mn:0000299E                 push    eax             ; int
.text$mn:0000299F                 call    ?_Winerror_map@std@@YAPBDH@Z ; std::_Winerror_map(int)
.text$mn:000029A4                 add     esp, 4
.text$mn:000029A7                 mov     [ebp+var_10], eax
.text$mn:000029AA                 cmp     [ebp+var_10], 0
.text$mn:000029AE                 jz      short loc_29B8
.text$mn:000029B0                 mov     ecx, [ebp+var_10]
.text$mn:000029B3                 mov     [ebp+Str], ecx
.text$mn:000029B6                 jmp     short loc_29BF
.text$mn:000029B8 ; ---------------------------------------------------------------------------
.text$mn:000029B8
.text$mn:000029B8 loc_29B8:                               ; CODE XREF: std::_System_error_category::message(int)+42j
.text$mn:000029B8                 mov     [ebp+Str], offset ??_C@_0O@BFJCFAAK@unknown?5error?$AA@ ; "unknown error"
.text$mn:000029BF
.text$mn:000029BF loc_29BF:                               ; CODE XREF: std::_System_error_category::message(int)+4Aj
.text$mn:000029BF                 mov     edx, [ebp+Str]
.text$mn:000029C2                 push    edx             ; Str
.text$mn:000029C3                 mov     ecx, [ebp+arg_0]
.text$mn:000029C6                 call    ??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@PBD@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char>>::basic_string<char,std::char_traits<char>,std::allocator<char>>(char const *)
.text$mn:000029CB                 mov     [ebp+var_4], 0
.text$mn:000029D2                 mov     eax, [ebp+var_18]
.text$mn:000029D5                 or      eax, 1
.text$mn:000029D8                 mov     [ebp+var_18], eax
.text$mn:000029DB                 mov     eax, [ebp+arg_0]
.text$mn:000029DE                 mov     ecx, [ebp+var_C]
.text$mn:000029E1                 mov     large fs:0, ecx
.text$mn:000029E8                 pop     ecx
.text$mn:000029E9                 mov     esp, ebp
.text$mn:000029EB                 pop     ebp
.text$mn:000029EC                 retn    8
.text$mn:000029EC ?message@_System_error_category@std@@UBE?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@2@H@Z endp
.text$mn:000029EC
.text$mn:000029EC ; ---------------------------------------------------------------------------
.text$mn:000029EF                 align 10h
.text$mn:000029EF _text$mn        ends
.text$mn:000029EF
.text$x:000029F0 ; ===========================================================================
.text$x:000029F0
.text$x:000029F0 ; Segment type: Pure code
.text$x:000029F0 ; Segment permissions: Read/Execute
.text$x:000029F0 _text$x         segment para public 'CODE' use32
.text$x:000029F0                 assume cs:_text$x
.text$x:000029F0                 ;org 29F0h
.text$x:000029F0 ; COMDAT (pick associative to section at 296C)
.text$x:000029F0                 assume es:nothing, ss:nothing, ds:_data, fs:nothing, gs:nothing
.text$x:000029F0
.text$x:000029F0 ; =============== S U B R O U T I N E =======================================
.text$x:000029F0
.text$x:000029F0
.text$x:000029F0 __unwindfunclet$?message@_System_error_category@std@@UBE?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@2@H@Z$0 proc near
.text$x:000029F0                                         ; DATA XREF: .xdata$x:00002E64o
.text$x:000029F0                 mov     eax, [ebp-18h]
.text$x:000029F3                 and     eax, 1
.text$x:000029F6                 jz      $LN6_1
.text$x:000029FC                 and     dword ptr [ebp-18h], 0FFFFFFFEh
.text$x:00002A00                 mov     ecx, [ebp+8]
.text$x:00002A03                 jmp     ??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char>>::~basic_string<char,std::char_traits<char>,std::allocator<char>>(void)
.text$x:00002A08 ; ---------------------------------------------------------------------------
.text$x:00002A08
.text$x:00002A08 $LN6_1:                                 ; CODE XREF: __unwindfunclet$?message@_System_error_category@std@@UBE?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@2@H@Z$0+6j
.text$x:00002A08                 retn
.text$x:00002A08 __unwindfunclet$?message@_System_error_category@std@@UBE?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@2@H@Z$0 endp
.text$x:00002A08
.text$x:00002A09
.text$x:00002A09 ; =============== S U B R O U T I N E =======================================
.text$x:00002A09
.text$x:00002A09
.text$x:00002A09 __ehhandler$?message@_System_error_category@std@@UBE?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@2@H@Z proc near
.text$x:00002A09                                         ; DATA XREF: std::_System_error_category::message(int)+5o
.text$x:00002A09
.text$x:00002A09 arg_4           = dword ptr  8
.text$x:00002A09
.text$x:00002A09                 mov     edx, [esp+arg_4]
.text$x:00002A0D                 lea     eax, [edx+0Ch]
.text$x:00002A10                 mov     ecx, [edx-14h]
.text$x:00002A13                 xor     ecx, eax
.text$x:00002A15                 call    @__security_check_cookie@4 ; __security_check_cookie(x)
.text$x:00002A1A                 mov     eax, offset __ehfuncinfo$?message@_System_error_category@std@@UBE?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@2@H@Z
.text$x:00002A1F                 jmp     ___CxxFrameHandler3
.text$x:00002A1F __ehhandler$?message@_System_error_category@std@@UBE?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@2@H@Z endp
.text$x:00002A1F
.text$x:00002A1F _text$x         ends
.text$x:00002A1F
.text$mn:00002A24 ; ===========================================================================
.text$mn:00002A24
.text$mn:00002A24 ; Segment type: Pure code
.text$mn:00002A24 ; Segment permissions: Read/Execute
.text$mn:00002A24 _text$mn        segment para public 'CODE' use32
.text$mn:00002A24                 assume cs:_text$mn
.text$mn:00002A24                 ;org 2A24h
.text$mn:00002A24 ; COMDAT (pick any)
.text$mn:00002A24                 assume es:nothing, ss:nothing, ds:_data, fs:nothing, gs:nothing
.text$mn:00002A24
.text$mn:00002A24 ; =============== S U B R O U T I N E =======================================
.text$mn:00002A24
.text$mn:00002A24 ; Attributes: bp-based frame
.text$mn:00002A24
.text$mn:00002A24 ; int __cdecl std::char_traits<char>::move(void *Dst, void *Src, size_t Size)
.text$mn:00002A24                 public ?move@?$char_traits@D@std@@SAPADPADPBDI@Z
.text$mn:00002A24 ?move@?$char_traits@D@std@@SAPADPADPBDI@Z proc near
.text$mn:00002A24                                         ; CODE XREF: std::basic_string<char,std::char_traits<char>,std::allocator<char>>::erase(uint,uint)+6Ap
.text$mn:00002A24
.text$mn:00002A24 var_4           = dword ptr -4
.text$mn:00002A24 Dst             = dword ptr  8
.text$mn:00002A24 Src             = dword ptr  0Ch
.text$mn:00002A24 Size            = dword ptr  10h
.text$mn:00002A24
.text$mn:00002A24                 push    ebp
.text$mn:00002A25                 mov     ebp, esp
.text$mn:00002A27                 push    ecx
.text$mn:00002A28                 cmp     [ebp+Size], 0
.text$mn:00002A2C                 jnz     short loc_2A36
.text$mn:00002A2E                 mov     eax, [ebp+Dst]
.text$mn:00002A31                 mov     [ebp+var_4], eax
.text$mn:00002A34                 jmp     short loc_2A4D
.text$mn:00002A36 ; ---------------------------------------------------------------------------
.text$mn:00002A36
.text$mn:00002A36 loc_2A36:                               ; CODE XREF: std::char_traits<char>::move(char *,char const *,uint)+8j
.text$mn:00002A36                 mov     ecx, [ebp+Size]
.text$mn:00002A39                 push    ecx             ; Size
.text$mn:00002A3A                 mov     edx, [ebp+Src]
.text$mn:00002A3D                 push    edx             ; Src
.text$mn:00002A3E                 mov     eax, [ebp+Dst]
.text$mn:00002A41                 push    eax             ; Dst
.text$mn:00002A42                 call    _memmove
.text$mn:00002A47                 add     esp, 0Ch
.text$mn:00002A4A                 mov     [ebp+var_4], eax
.text$mn:00002A4D
.text$mn:00002A4D loc_2A4D:                               ; CODE XREF: std::char_traits<char>::move(char *,char const *,uint)+10j
.text$mn:00002A4D                 mov     eax, [ebp+var_4]
.text$mn:00002A50                 mov     esp, ebp
.text$mn:00002A52                 pop     ebp
.text$mn:00002A53                 retn
.text$mn:00002A53 ?move@?$char_traits@D@std@@SAPADPADPBDI@Z endp
.text$mn:00002A53
.text$mn:00002A53 _text$mn        ends
.text$mn:00002A53
.text$mn:00002A54 ; ===========================================================================
.text$mn:00002A54
.text$mn:00002A54 ; Segment type: Pure code
.text$mn:00002A54 ; Segment permissions: Read/Execute
.text$mn:00002A54 _text$mn        segment para public 'CODE' use32
.text$mn:00002A54                 assume cs:_text$mn
.text$mn:00002A54                 ;org 2A54h
.text$mn:00002A54 ; COMDAT (pick any)
.text$mn:00002A54                 assume es:nothing, ss:nothing, ds:_data, fs:nothing, gs:nothing
.text$mn:00002A54
.text$mn:00002A54 ; =============== S U B R O U T I N E =======================================
.text$mn:00002A54
.text$mn:00002A54 ; Attributes: bp-based frame
.text$mn:00002A54
.text$mn:00002A54 ; const char *__thiscall std::_Generic_error_category::name(std::_Generic_error_category *__hidden this)
.text$mn:00002A54                 public ?name@_Generic_error_category@std@@UBEPBDXZ
.text$mn:00002A54 ?name@_Generic_error_category@std@@UBEPBDXZ proc near
.text$mn:00002A54                                         ; DATA XREF: .rdata:00002F38o
.text$mn:00002A54
.text$mn:00002A54 var_4           = dword ptr -4
.text$mn:00002A54
.text$mn:00002A54                 push    ebp
.text$mn:00002A55                 mov     ebp, esp
.text$mn:00002A57                 push    ecx
.text$mn:00002A58                 mov     [ebp+var_4], ecx
.text$mn:00002A5B                 mov     eax, offset ??_C@_07DCLBNMLN@generic?$AA@ ; "generic"
.text$mn:00002A60                 mov     esp, ebp
.text$mn:00002A62                 pop     ebp
.text$mn:00002A63                 retn
.text$mn:00002A63 ?name@_Generic_error_category@std@@UBEPBDXZ endp
.text$mn:00002A63
.text$mn:00002A63 _text$mn        ends
.text$mn:00002A63
.text$mn:00002A64 ; ===========================================================================
.text$mn:00002A64
.text$mn:00002A64 ; Segment type: Pure code
.text$mn:00002A64 ; Segment permissions: Read/Execute
.text$mn:00002A64 _text$mn        segment para public 'CODE' use32
.text$mn:00002A64                 assume cs:_text$mn
.text$mn:00002A64                 ;org 2A64h
.text$mn:00002A64 ; COMDAT (pick any)
.text$mn:00002A64                 assume es:nothing, ss:nothing, ds:_data, fs:nothing, gs:nothing
.text$mn:00002A64
.text$mn:00002A64 ; =============== S U B R O U T I N E =======================================
.text$mn:00002A64
.text$mn:00002A64 ; Attributes: bp-based frame
.text$mn:00002A64
.text$mn:00002A64 ; const char *__thiscall std::_Iostream_error_category::name(std::_Iostream_error_category *__hidden this)
.text$mn:00002A64                 public ?name@_Iostream_error_category@std@@UBEPBDXZ
.text$mn:00002A64 ?name@_Iostream_error_category@std@@UBEPBDXZ proc near
.text$mn:00002A64                                         ; DATA XREF: .rdata:00002F6Co
.text$mn:00002A64
.text$mn:00002A64 var_4           = dword ptr -4
.text$mn:00002A64
.text$mn:00002A64                 push    ebp
.text$mn:00002A65                 mov     ebp, esp
.text$mn:00002A67                 push    ecx
.text$mn:00002A68                 mov     [ebp+var_4], ecx
.text$mn:00002A6B                 mov     eax, offset ??_C@_08LLGCOLLL@iostream?$AA@ ; "iostream"
.text$mn:00002A70                 mov     esp, ebp
.text$mn:00002A72                 pop     ebp
.text$mn:00002A73                 retn
.text$mn:00002A73 ?name@_Iostream_error_category@std@@UBEPBDXZ endp
.text$mn:00002A73
.text$mn:00002A73 _text$mn        ends
.text$mn:00002A73
.text$mn:00002A74 ; ===========================================================================
.text$mn:00002A74
.text$mn:00002A74 ; Segment type: Pure code
.text$mn:00002A74 ; Segment permissions: Read/Execute
.text$mn:00002A74 _text$mn        segment para public 'CODE' use32
.text$mn:00002A74                 assume cs:_text$mn
.text$mn:00002A74                 ;org 2A74h
.text$mn:00002A74 ; COMDAT (pick any)
.text$mn:00002A74                 assume es:nothing, ss:nothing, ds:_data, fs:nothing, gs:nothing
.text$mn:00002A74
.text$mn:00002A74 ; =============== S U B R O U T I N E =======================================
.text$mn:00002A74
.text$mn:00002A74 ; Attributes: bp-based frame
.text$mn:00002A74
.text$mn:00002A74 ; const char *__thiscall std::_System_error_category::name(std::_System_error_category *__hidden this)
.text$mn:00002A74                 public ?name@_System_error_category@std@@UBEPBDXZ
.text$mn:00002A74 ?name@_System_error_category@std@@UBEPBDXZ proc near
.text$mn:00002A74                                         ; DATA XREF: .rdata:00002FACo
.text$mn:00002A74
.text$mn:00002A74 var_4           = dword ptr -4
.text$mn:00002A74
.text$mn:00002A74                 push    ebp
.text$mn:00002A75                 mov     ebp, esp
.text$mn:00002A77                 push    ecx
.text$mn:00002A78                 mov     [ebp+var_4], ecx
.text$mn:00002A7B                 mov     eax, offset ??_C@_06FHFOAHML@system?$AA@ ; "system"
.text$mn:00002A80                 mov     esp, ebp
.text$mn:00002A82                 pop     ebp
.text$mn:00002A83                 retn
.text$mn:00002A83 ?name@_System_error_category@std@@UBEPBDXZ endp
.text$mn:00002A83
.text$mn:00002A83 _text$mn        ends
.text$mn:00002A83
.text$mn:00002A84 ; ===========================================================================
.text$mn:00002A84
.text$mn:00002A84 ; Segment type: Pure code
.text$mn:00002A84 ; Segment permissions: Read/Execute
.text$mn:00002A84 _text$mn        segment para public 'CODE' use32
.text$mn:00002A84                 assume cs:_text$mn
.text$mn:00002A84                 ;org 2A84h
.text$mn:00002A84 ; COMDAT (pick any)
.text$mn:00002A84                 assume es:nothing, ss:nothing, ds:_data, fs:nothing, gs:nothing
.text$mn:00002A84
.text$mn:00002A84 ; =============== S U B R O U T I N E =======================================
.text$mn:00002A84
.text$mn:00002A84 ; Attributes: bp-based frame
.text$mn:00002A84
.text$mn:00002A84 ; int __stdcall DockingDlgInterface::run_dlgProc(DockingDlgInterface *this, unsigned int, unsigned int, __int32)
.text$mn:00002A84                 public ?run_dlgProc@DockingDlgInterface@@MAGHIIJ@Z
.text$mn:00002A84 ?run_dlgProc@DockingDlgInterface@@MAGHIIJ@Z proc near
.text$mn:00002A84                                         ; CODE XREF: AnsiCharPanel::run_dlgProc(uint,uint,long)+1A5p
.text$mn:00002A84                                         ; AnsiCharPanel::run_dlgProc(uint,uint,long)+1BCp
.text$mn:00002A84
.text$mn:00002A84 var_C           = dword ptr -0Ch
.text$mn:00002A84 var_8           = dword ptr -8
.text$mn:00002A84 var_4           = dword ptr -4
.text$mn:00002A84 this            = dword ptr  8
.text$mn:00002A84 arg_4           = dword ptr  0Ch
.text$mn:00002A84 arg_C           = dword ptr  14h
.text$mn:00002A84
.text$mn:00002A84                 push    ebp
.text$mn:00002A85                 mov     ebp, esp
.text$mn:00002A87                 sub     esp, 0Ch
.text$mn:00002A8A                 mov     eax, [ebp+arg_4]
.text$mn:00002A8D                 mov     [ebp+var_C], eax
.text$mn:00002A90                 cmp     [ebp+var_C], 4Eh ; 'N'
.text$mn:00002A94                 jz      short loc_2A98
.text$mn:00002A96                 jmp     short loc_2AFA
.text$mn:00002A98 ; ---------------------------------------------------------------------------
.text$mn:00002A98
.text$mn:00002A98 loc_2A98:                               ; CODE XREF: DockingDlgInterface::run_dlgProc(uint,uint,long)+10j
.text$mn:00002A98                 mov     ecx, [ebp+arg_C]
.text$mn:00002A9B                 mov     [ebp+var_4], ecx
.text$mn:00002A9E                 mov     edx, [ebp+var_4]
.text$mn:00002AA1                 mov     eax, [ebp+this]
.text$mn:00002AA4                 mov     ecx, [edx]
.text$mn:00002AA6                 cmp     ecx, [eax+8]
.text$mn:00002AA9                 jnz     short loc_2AFA
.text$mn:00002AAB                 mov     edx, [ebp+var_4]
.text$mn:00002AAE                 mov     eax, [edx+8]
.text$mn:00002AB1                 and     eax, 0FFFFh
.text$mn:00002AB6                 movzx   ecx, ax
.text$mn:00002AB9                 mov     [ebp+var_8], ecx
.text$mn:00002ABC                 cmp     [ebp+var_8], 41Ch
.text$mn:00002AC3                 jz      short loc_2ADB
.text$mn:00002AC5                 cmp     [ebp+var_8], 41Dh
.text$mn:00002ACC                 jz      short loc_2AD2
.text$mn:00002ACE                 jmp     short loc_2AFA
.text$mn:00002AD0 ; ---------------------------------------------------------------------------
.text$mn:00002AD0                 jmp     short loc_2AFA
.text$mn:00002AD2 ; ---------------------------------------------------------------------------
.text$mn:00002AD2
.text$mn:00002AD2 loc_2AD2:                               ; CODE XREF: DockingDlgInterface::run_dlgProc(uint,uint,long)+48j
.text$mn:00002AD2                 mov     edx, [ebp+this]
.text$mn:00002AD5                 mov     byte ptr [edx+28h], 1
.text$mn:00002AD9                 jmp     short loc_2AFA
.text$mn:00002ADB ; ---------------------------------------------------------------------------
.text$mn:00002ADB
.text$mn:00002ADB loc_2ADB:                               ; CODE XREF: DockingDlgInterface::run_dlgProc(uint,uint,long)+3Fj
.text$mn:00002ADB                 mov     eax, [ebp+var_4]
.text$mn:00002ADE                 mov     ecx, [eax+8]
.text$mn:00002AE1                 shr     ecx, 10h
.text$mn:00002AE4                 and     ecx, 0FFFFh
.text$mn:00002AEA                 movzx   edx, cx
.text$mn:00002AED                 mov     eax, [ebp+this]
.text$mn:00002AF0                 mov     [eax+2Ch], edx
.text$mn:00002AF3                 mov     ecx, [ebp+this]
.text$mn:00002AF6                 mov     byte ptr [ecx+28h], 0
.text$mn:00002AFA
.text$mn:00002AFA loc_2AFA:                               ; CODE XREF: DockingDlgInterface::run_dlgProc(uint,uint,long)+12j
.text$mn:00002AFA                                         ; DockingDlgInterface::run_dlgProc(uint,uint,long)+25j ...
.text$mn:00002AFA                 xor     eax, eax
.text$mn:00002AFC                 mov     esp, ebp
.text$mn:00002AFE                 pop     ebp
.text$mn:00002AFF                 retn    10h
.text$mn:00002AFF ?run_dlgProc@DockingDlgInterface@@MAGHIIJ@Z endp
.text$mn:00002AFF
.text$mn:00002AFF ; ---------------------------------------------------------------------------
.text$mn:00002B02                 align 4
.text$mn:00002B02 _text$mn        ends
.text$mn:00002B02
.text$mn:00002B04 ; ===========================================================================
.text$mn:00002B04
.text$mn:00002B04 ; Segment type: Pure code
.text$mn:00002B04 ; Segment permissions: Read/Execute
.text$mn:00002B04 _text$mn        segment para public 'CODE' use32
.text$mn:00002B04                 assume cs:_text$mn
.text$mn:00002B04                 ;org 2B04h
.text$mn:00002B04 ; COMDAT (pick any)
.text$mn:00002B04                 assume es:nothing, ss:nothing, ds:_data, fs:nothing, gs:nothing
.text$mn:00002B04
.text$mn:00002B04 ; =============== S U B R O U T I N E =======================================
.text$mn:00002B04
.text$mn:00002B04 ; Attributes: bp-based frame
.text$mn:00002B04
.text$mn:00002B04 ; public: unsigned int __thiscall std::basic_string<char, struct std::char_traits<char>, class std::allocator<char>>::size(void)const
.text$mn:00002B04                 public ?size@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QBEIXZ
.text$mn:00002B04 ?size@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QBEIXZ proc near
.text$mn:00002B04                                         ; CODE XREF: std::basic_string<char,std::char_traits<char>,std::allocator<char>>::assign(std::basic_string<char,std::char_traits<char>,std::allocator<char>> const &,uint,uint)+Cp
.text$mn:00002B04                                         ; std::basic_string<char,std::char_traits<char>,std::allocator<char>>::assign(std::basic_string<char,std::char_traits<char>,std::allocator<char>> const &,uint,uint)+21p
.text$mn:00002B04
.text$mn:00002B04 var_4           = dword ptr -4
.text$mn:00002B04
.text$mn:00002B04                 push    ebp
.text$mn:00002B05                 mov     ebp, esp
.text$mn:00002B07                 push    ecx
.text$mn:00002B08                 mov     [ebp+var_4], ecx
.text$mn:00002B0B                 mov     eax, [ebp+var_4]
.text$mn:00002B0E                 mov     eax, [eax+14h]
.text$mn:00002B11                 mov     esp, ebp
.text$mn:00002B13                 pop     ebp
.text$mn:00002B14                 retn
.text$mn:00002B14 ?size@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QBEIXZ endp
.text$mn:00002B14
.text$mn:00002B14 ; ---------------------------------------------------------------------------
.text$mn:00002B15                 align 4
.text$mn:00002B15 _text$mn        ends
.text$mn:00002B15
.text$mn:00002B18 ; ===========================================================================
.text$mn:00002B18
.text$mn:00002B18 ; Segment type: Pure code
.text$mn:00002B18 ; Segment permissions: Read/Execute
.text$mn:00002B18 _text$mn        segment para public 'CODE' use32
.text$mn:00002B18                 assume cs:_text$mn
.text$mn:00002B18                 ;org 2B18h
.text$mn:00002B18 ; COMDAT (pick any)
.text$mn:00002B18                 assume es:nothing, ss:nothing, ds:_data, fs:nothing, gs:nothing
.text$mn:00002B18
.text$mn:00002B18 ; =============== S U B R O U T I N E =======================================
.text$mn:00002B18
.text$mn:00002B18 ; Attributes: bp-based frame
.text$mn:00002B18
.text$mn:00002B18 ; const struct std::error_category *__cdecl std::system_category()
.text$mn:00002B18                 public ?system_category@std@@YAABVerror_category@1@XZ
.text$mn:00002B18 ?system_category@std@@YAABVerror_category@1@XZ proc near
.text$mn:00002B18                                         ; CODE XREF: std::_System_error_category::default_error_condition(int):loc_2550p
.text$mn:00002B18                 push    ebp
.text$mn:00002B19                 mov     ebp, esp
.text$mn:00002B1B                 mov     eax, offset ?_System_object@?$_Error_objects@H@std@@2V_System_error_category@2@A ; std::_System_error_category std::_Error_objects<int>::_System_object
.text$mn:00002B20                 pop     ebp
.text$mn:00002B21                 retn
.text$mn:00002B21 ?system_category@std@@YAABVerror_category@1@XZ endp
.text$mn:00002B21
.text$mn:00002B21 ; ---------------------------------------------------------------------------
.text$mn:00002B22                 align 4
.text$mn:00002B22 _text$mn        ends
.text$mn:00002B22
.text$mn:00002B24 ; ===========================================================================
.text$mn:00002B24
.text$mn:00002B24 ; Segment type: Pure code
.text$mn:00002B24 ; Segment permissions: Read/Execute
.text$mn:00002B24 _text$mn        segment para public 'CODE' use32
.text$mn:00002B24                 assume cs:_text$mn
.text$mn:00002B24                 ;org 2B24h
.text$mn:00002B24 ; COMDAT (pick any)
.text$mn:00002B24                 assume es:nothing, ss:nothing, ds:_data, fs:nothing, gs:nothing
.text$mn:00002B24
.text$mn:00002B24 ; =============== S U B R O U T I N E =======================================
.text$mn:00002B24
.text$mn:00002B24 ; Attributes: bp-based frame
.text$mn:00002B24
.text$mn:00002B24 ; int __thiscall std::error_code::value(std::error_code *__hidden this)
.text$mn:00002B24                 public ?value@error_code@std@@QBEHXZ
.text$mn:00002B24 ?value@error_code@std@@QBEHXZ proc near ; CODE XREF: std::error_category::equivalent(std::error_code const &,int)+24p
.text$mn:00002B24
.text$mn:00002B24 var_4           = dword ptr -4
.text$mn:00002B24
.text$mn:00002B24                 push    ebp
.text$mn:00002B25                 mov     ebp, esp
.text$mn:00002B27                 push    ecx
.text$mn:00002B28                 mov     [ebp+var_4], ecx
.text$mn:00002B2B                 mov     eax, [ebp+var_4]
.text$mn:00002B2E                 mov     eax, [eax]
.text$mn:00002B30                 mov     esp, ebp
.text$mn:00002B32                 pop     ebp
.text$mn:00002B33                 retn
.text$mn:00002B33 ?value@error_code@std@@QBEHXZ endp
.text$mn:00002B33
.text$mn:00002B33 _text$mn        ends
.text$mn:00002B33
.text$mn:00002B34 ; ===========================================================================
.text$mn:00002B34
.text$mn:00002B34 ; Segment type: Pure code
.text$mn:00002B34 ; Segment permissions: Read/Execute
.text$mn:00002B34 _text$mn        segment para public 'CODE' use32
.text$mn:00002B34                 assume cs:_text$mn
.text$mn:00002B34                 ;org 2B34h
.text$mn:00002B34 ; COMDAT (pick any)
.text$mn:00002B34                 assume es:nothing, ss:nothing, ds:_data, fs:nothing, gs:nothing
.text$mn:00002B34
.text$mn:00002B34 ; =============== S U B R O U T I N E =======================================
.text$mn:00002B34
.text$mn:00002B34 ; Attributes: bp-based frame
.text$mn:00002B34
.text$mn:00002B34 ; int __thiscall std::error_condition::value(std::error_condition *__hidden this)
.text$mn:00002B34                 public ?value@error_condition@std@@QBEHXZ
.text$mn:00002B34 ?value@error_condition@std@@QBEHXZ proc near
.text$mn:00002B34                                         ; CODE XREF: std::error_condition::operator==(std::error_condition const &)+2Cp
.text$mn:00002B34                                         ; std::error_condition::operator==(std::error_condition const &)+36p
.text$mn:00002B34
.text$mn:00002B34 var_4           = dword ptr -4
.text$mn:00002B34
.text$mn:00002B34                 push    ebp
.text$mn:00002B35                 mov     ebp, esp
.text$mn:00002B37                 push    ecx
.text$mn:00002B38                 mov     [ebp+var_4], ecx
.text$mn:00002B3B                 mov     eax, [ebp+var_4]
.text$mn:00002B3E                 mov     eax, [eax]
.text$mn:00002B40                 mov     esp, ebp
.text$mn:00002B42                 pop     ebp
.text$mn:00002B43                 retn
.text$mn:00002B43 ?value@error_condition@std@@QBEHXZ endp
.text$mn:00002B43
.text$mn:00002B43 _text$mn        ends
.text$mn:00002B43
.text$mn:00002B44 ; ===========================================================================
.text$mn:00002B44
.text$mn:00002B44 ; Segment type: Pure code
.text$mn:00002B44 ; Segment permissions: Read/Execute
.text$mn:00002B44 _text$mn        segment para public 'CODE' use32
.text$mn:00002B44                 assume cs:_text$mn
.text$mn:00002B44                 ;org 2B44h
.text$mn:00002B44 ; COMDAT (pick any)
.text$mn:00002B44                 assume es:nothing, ss:nothing, ds:_data, fs:nothing, gs:nothing
.text$mn:00002B44
.text$mn:00002B44 ; =============== S U B R O U T I N E =======================================
.text$mn:00002B44
.text$mn:00002B44 ; Attributes: bp-based frame
.text$mn:00002B44
.text$mn:00002B44                 public _hypot
.text$mn:00002B44 _hypot          proc near
.text$mn:00002B44
.text$mn:00002B44 var_10          = qword ptr -10h
.text$mn:00002B44 var_8           = qword ptr -8
.text$mn:00002B44 arg_0           = qword ptr  8
.text$mn:00002B44 arg_8           = qword ptr  10h
.text$mn:00002B44
.text$mn:00002B44                 push    ebp
.text$mn:00002B45                 mov     ebp, esp
.text$mn:00002B47                 sub     esp, 8
.text$mn:00002B4A                 movsd   xmm0, [ebp+arg_8]
.text$mn:00002B4F                 movsd   [esp+8+var_8], xmm0
.text$mn:00002B54                 sub     esp, 8
.text$mn:00002B57                 movsd   xmm0, [ebp+arg_0]
.text$mn:00002B5C                 movsd   [esp+10h+var_10], xmm0
.text$mn:00002B61                 call    __hypot
.text$mn:00002B66                 add     esp, 10h
.text$mn:00002B69                 pop     ebp
.text$mn:00002B6A                 retn
.text$mn:00002B6A _hypot          endp
.text$mn:00002B6A
.text$mn:00002B6A ; ---------------------------------------------------------------------------
.text$mn:00002B6B                 align 4
.text$mn:00002B6B _text$mn        ends
.text$mn:00002B6B
.xdata$x:00002B6C ; ===========================================================================
.xdata$x:00002B6C
.xdata$x:00002B6C ; Segment type: Pure data
.xdata$x:00002B6C ; Segment permissions: Read
.xdata$x:00002B6C _xdata$x        segment dword public 'DATA' use32
.xdata$x:00002B6C                 assume cs:_xdata$x
.xdata$x:00002B6C                 ;org 2B6Ch
.xdata$x:00002B6C ; COMDAT (pick associative to section at 20F4)
.xdata$x:00002B6C __unwindtable$?_Orphan_all@_Container_base12@std@@QAEXXZ db 0FFh
.xdata$x:00002B6C                                         ; DATA XREF: .xdata$x:00002B7Co
.xdata$x:00002B6D                 db 0FFh
.xdata$x:00002B6E                 db 0FFh
.xdata$x:00002B6F                 db 0FFh
.xdata$x:00002B70                 dd offset __unwindfunclet$?_Orphan_all@_Container_base12@std@@QAEXXZ$0
.xdata$x:00002B74 __ehfuncinfo$?_Orphan_all@_Container_base12@std@@QAEXXZ db  22h ; "
.xdata$x:00002B74                                         ; DATA XREF: __ehhandler$?_Orphan_all@_Container_base12@std@@QAEXXZ+11o
.xdata$x:00002B75                 db    5
.xdata$x:00002B76                 db  93h ; ô
.xdata$x:00002B77                 db  19h
.xdata$x:00002B78                 db    1
.xdata$x:00002B79                 db    0
.xdata$x:00002B7A                 db    0
.xdata$x:00002B7B                 db    0
.xdata$x:00002B7C                 dd offset __unwindtable$?_Orphan_all@_Container_base12@std@@QAEXXZ
.xdata$x:00002B80                 db    0
.xdata$x:00002B81                 db    0
.xdata$x:00002B82                 db    0
.xdata$x:00002B83                 db    0
.xdata$x:00002B84                 db    0
.xdata$x:00002B85                 db    0
.xdata$x:00002B86                 db    0
.xdata$x:00002B87                 db    0
.xdata$x:00002B88                 db    0
.xdata$x:00002B89                 db    0
.xdata$x:00002B8A                 db    0
.xdata$x:00002B8B                 db    0
.xdata$x:00002B8C                 db    0
.xdata$x:00002B8D                 db    0
.xdata$x:00002B8E                 db    0
.xdata$x:00002B8F                 db    0
.xdata$x:00002B90                 db    0
.xdata$x:00002B91                 db    0
.xdata$x:00002B92                 db    0
.xdata$x:00002B93                 db    0
.xdata$x:00002B94                 db    0
.xdata$x:00002B95                 db    0
.xdata$x:00002B96                 db    0
.xdata$x:00002B97                 db    0
.xdata$x:00002B97 _xdata$x        ends
.xdata$x:00002B97
.xdata$x:00002B98 ; ===========================================================================
.xdata$x:00002B98
.xdata$x:00002B98 ; Segment type: Pure data
.xdata$x:00002B98 ; Segment permissions: Read
.xdata$x:00002B98 _xdata$x        segment dword public 'DATA' use32
.xdata$x:00002B98                 assume cs:_xdata$x
.xdata$x:00002B98                 ;org 2B98h
.xdata$x:00002B98 ; COMDAT (pick associative to section at 1464)
.xdata$x:00002B98 __unwindtable$??0?$_String_val@U?$_Simple_types@D@std@@@std@@QAE@XZ db 0FFh
.xdata$x:00002B98                                         ; DATA XREF: .xdata$x:00002BA8o
.xdata$x:00002B99                 db 0FFh
.xdata$x:00002B9A                 db 0FFh
.xdata$x:00002B9B                 db 0FFh
.xdata$x:00002B9C                 dd offset __unwindfunclet$??0?$_String_val@U?$_Simple_types@D@std@@@std@@QAE@XZ$0
.xdata$x:00002BA0 __ehfuncinfo$??0?$_String_val@U?$_Simple_types@D@std@@@std@@QAE@XZ db  22h ; "
.xdata$x:00002BA0                                         ; DATA XREF: __ehhandler$??0?$_String_val@U?$_Simple_types@D@std@@@std@@QAE@XZ+11o
.xdata$x:00002BA1                 db    5
.xdata$x:00002BA2                 db  93h ; ô
.xdata$x:00002BA3                 db  19h
.xdata$x:00002BA4                 db    1
.xdata$x:00002BA5                 db    0
.xdata$x:00002BA6                 db    0
.xdata$x:00002BA7                 db    0
.xdata$x:00002BA8                 dd offset __unwindtable$??0?$_String_val@U?$_Simple_types@D@std@@@std@@QAE@XZ
.xdata$x:00002BAC                 db    0
.xdata$x:00002BAD                 db    0
.xdata$x:00002BAE                 db    0
.xdata$x:00002BAF                 db    0
.xdata$x:00002BB0                 db    0
.xdata$x:00002BB1                 db    0
.xdata$x:00002BB2                 db    0
.xdata$x:00002BB3                 db    0
.xdata$x:00002BB4                 db    0
.xdata$x:00002BB5                 db    0
.xdata$x:00002BB6                 db    0
.xdata$x:00002BB7                 db    0
.xdata$x:00002BB8                 db    0
.xdata$x:00002BB9                 db    0
.xdata$x:00002BBA                 db    0
.xdata$x:00002BBB                 db    0
.xdata$x:00002BBC                 db    0
.xdata$x:00002BBD                 db    0
.xdata$x:00002BBE                 db    0
.xdata$x:00002BBF                 db    0
.xdata$x:00002BC0                 db    0
.xdata$x:00002BC1                 db    0
.xdata$x:00002BC2                 db    0
.xdata$x:00002BC3                 db    0
.xdata$x:00002BC3 _xdata$x        ends
.xdata$x:00002BC3
.xdata$x:00002BC4 ; ===========================================================================
.xdata$x:00002BC4
.xdata$x:00002BC4 ; Segment type: Pure data
.xdata$x:00002BC4 ; Segment permissions: Read
.xdata$x:00002BC4 _xdata$x        segment dword public 'DATA' use32
.xdata$x:00002BC4                 assume cs:_xdata$x
.xdata$x:00002BC4                 ;org 2BC4h
.xdata$x:00002BC4 ; COMDAT (pick associative to section at 1848)
.xdata$x:00002BC4 __unwindtable$??1?$_String_val@U?$_Simple_types@D@std@@@std@@QAE@XZ db 0FFh
.xdata$x:00002BC4                                         ; DATA XREF: .xdata$x:00002BD4o
.xdata$x:00002BC5                 db 0FFh
.xdata$x:00002BC6                 db 0FFh
.xdata$x:00002BC7                 db 0FFh
.xdata$x:00002BC8                 dd offset __unwindfunclet$??1?$_String_val@U?$_Simple_types@D@std@@@std@@QAE@XZ$0
.xdata$x:00002BCC __ehfuncinfo$??1?$_String_val@U?$_Simple_types@D@std@@@std@@QAE@XZ db  22h ; "
.xdata$x:00002BCC                                         ; DATA XREF: __ehhandler$??1?$_String_val@U?$_Simple_types@D@std@@@std@@QAE@XZ+11o
.xdata$x:00002BCD                 db    5
.xdata$x:00002BCE                 db  93h ; ô
.xdata$x:00002BCF                 db  19h
.xdata$x:00002BD0                 db    1
.xdata$x:00002BD1                 db    0
.xdata$x:00002BD2                 db    0
.xdata$x:00002BD3                 db    0
.xdata$x:00002BD4                 dd offset __unwindtable$??1?$_String_val@U?$_Simple_types@D@std@@@std@@QAE@XZ
.xdata$x:00002BD8                 db    0
.xdata$x:00002BD9                 db    0
.xdata$x:00002BDA                 db    0
.xdata$x:00002BDB                 db    0
.xdata$x:00002BDC                 db    0
.xdata$x:00002BDD                 db    0
.xdata$x:00002BDE                 db    0
.xdata$x:00002BDF                 db    0
.xdata$x:00002BE0                 db    0
.xdata$x:00002BE1                 db    0
.xdata$x:00002BE2                 db    0
.xdata$x:00002BE3                 db    0
.xdata$x:00002BE4                 db    0
.xdata$x:00002BE5                 db    0
.xdata$x:00002BE6                 db    0
.xdata$x:00002BE7                 db    0
.xdata$x:00002BE8                 db    0
.xdata$x:00002BE9                 db    0
.xdata$x:00002BEA                 db    0
.xdata$x:00002BEB                 db    0
.xdata$x:00002BEC                 db    0
.xdata$x:00002BED                 db    0
.xdata$x:00002BEE                 db    0
.xdata$x:00002BEF                 db    0
.xdata$x:00002BEF _xdata$x        ends
.xdata$x:00002BEF
.xdata$x:00002BF0 ; ===========================================================================
.xdata$x:00002BF0
.xdata$x:00002BF0 ; Segment type: Pure data
.xdata$x:00002BF0 ; Segment permissions: Read
.xdata$x:00002BF0 _xdata$x        segment dword public 'DATA' use32
.xdata$x:00002BF0                 assume cs:_xdata$x
.xdata$x:00002BF0                 ;org 2BF0h
.xdata$x:00002BF0 ; COMDAT (pick associative to section at 13E8)
.xdata$x:00002BF0 __unwindtable$??0?$_String_alloc@$0A@U?$_String_base_types@DV?$allocator@D@std@@@std@@@std@@QAE@ABV?$allocator@D@1@@Z db 0FFh
.xdata$x:00002BF0                                         ; DATA XREF: .xdata$x:00002C00o
.xdata$x:00002BF1                 db 0FFh
.xdata$x:00002BF2                 db 0FFh
.xdata$x:00002BF3                 db 0FFh
.xdata$x:00002BF4                 dd offset __unwindfunclet$??0?$_String_alloc@$0A@U?$_String_base_types@DV?$allocator@D@std@@@std@@@std@@QAE@ABV?$allocator@D@1@@Z$0
.xdata$x:00002BF8 __ehfuncinfo$??0?$_String_alloc@$0A@U?$_String_base_types@DV?$allocator@D@std@@@std@@@std@@QAE@ABV?$allocator@D@1@@Z db  22h ; "
.xdata$x:00002BF8                                         ; DATA XREF: __ehhandler$??0?$_String_alloc@$0A@U?$_String_base_types@DV?$allocator@D@std@@@std@@@std@@QAE@ABV?$allocator@D@1@@Z+11o
.xdata$x:00002BF9                 db    5
.xdata$x:00002BFA                 db  93h ; ô
.xdata$x:00002BFB                 db  19h
.xdata$x:00002BFC                 db    1
.xdata$x:00002BFD                 db    0
.xdata$x:00002BFE                 db    0
.xdata$x:00002BFF                 db    0
.xdata$x:00002C00                 dd offset __unwindtable$??0?$_String_alloc@$0A@U?$_String_base_types@DV?$allocator@D@std@@@std@@@std@@QAE@ABV?$allocator@D@1@@Z
.xdata$x:00002C04                 db    0
.xdata$x:00002C05                 db    0
.xdata$x:00002C06                 db    0
.xdata$x:00002C07                 db    0
.xdata$x:00002C08                 db    0
.xdata$x:00002C09                 db    0
.xdata$x:00002C0A                 db    0
.xdata$x:00002C0B                 db    0
.xdata$x:00002C0C                 db    0
.xdata$x:00002C0D                 db    0
.xdata$x:00002C0E                 db    0
.xdata$x:00002C0F                 db    0
.xdata$x:00002C10                 db    0
.xdata$x:00002C11                 db    0
.xdata$x:00002C12                 db    0
.xdata$x:00002C13                 db    0
.xdata$x:00002C14                 db    0
.xdata$x:00002C15                 db    0
.xdata$x:00002C16                 db    0
.xdata$x:00002C17                 db    0
.xdata$x:00002C18                 db    0
.xdata$x:00002C19                 db    0
.xdata$x:00002C1A                 db    0
.xdata$x:00002C1B                 db    0
.xdata$x:00002C1B _xdata$x        ends
.xdata$x:00002C1B
.xdata$x:00002C1C ; ===========================================================================
.xdata$x:00002C1C
.xdata$x:00002C1C ; Segment type: Pure data
.xdata$x:00002C1C ; Segment permissions: Read
.xdata$x:00002C1C _xdata$x        segment dword public 'DATA' use32
.xdata$x:00002C1C                 assume cs:_xdata$x
.xdata$x:00002C1C                 ;org 2C1Ch
.xdata$x:00002C1C ; COMDAT (pick associative to section at 17D0)
.xdata$x:00002C1C __unwindtable$??1?$_String_alloc@$0A@U?$_String_base_types@DV?$allocator@D@std@@@std@@@std@@QAE@XZ db 0FFh
.xdata$x:00002C1C                                         ; DATA XREF: .xdata$x:00002C2Co
.xdata$x:00002C1D                 db 0FFh
.xdata$x:00002C1E                 db 0FFh
.xdata$x:00002C1F                 db 0FFh
.xdata$x:00002C20                 dd offset __unwindfunclet$??1?$_String_alloc@$0A@U?$_String_base_types@DV?$allocator@D@std@@@std@@@std@@QAE@XZ$0
.xdata$x:00002C24 __ehfuncinfo$??1?$_String_alloc@$0A@U?$_String_base_types@DV?$allocator@D@std@@@std@@@std@@QAE@XZ db  22h ; "
.xdata$x:00002C24                                         ; DATA XREF: __ehhandler$??1?$_String_alloc@$0A@U?$_String_base_types@DV?$allocator@D@std@@@std@@@std@@QAE@XZ+11o
.xdata$x:00002C25                 db    5
.xdata$x:00002C26                 db  93h ; ô
.xdata$x:00002C27                 db  19h
.xdata$x:00002C28                 db    1
.xdata$x:00002C29                 db    0
.xdata$x:00002C2A                 db    0
.xdata$x:00002C2B                 db    0
.xdata$x:00002C2C                 dd offset __unwindtable$??1?$_String_alloc@$0A@U?$_String_base_types@DV?$allocator@D@std@@@std@@@std@@QAE@XZ
.xdata$x:00002C30                 db    0
.xdata$x:00002C31                 db    0
.xdata$x:00002C32                 db    0
.xdata$x:00002C33                 db    0
.xdata$x:00002C34                 db    0
.xdata$x:00002C35                 db    0
.xdata$x:00002C36                 db    0
.xdata$x:00002C37                 db    0
.xdata$x:00002C38                 db    0
.xdata$x:00002C39                 db    0
.xdata$x:00002C3A                 db    0
.xdata$x:00002C3B                 db    0
.xdata$x:00002C3C                 db    0
.xdata$x:00002C3D                 db    0
.xdata$x:00002C3E                 db    0
.xdata$x:00002C3F                 db    0
.xdata$x:00002C40                 db    0
.xdata$x:00002C41                 db    0
.xdata$x:00002C42                 db    0
.xdata$x:00002C43                 db    0
.xdata$x:00002C44                 db    0
.xdata$x:00002C45                 db    0
.xdata$x:00002C46                 db    0
.xdata$x:00002C47                 db    0
.xdata$x:00002C47 _xdata$x        ends
.xdata$x:00002C47
.xdata$x:00002C48 ; ===========================================================================
.xdata$x:00002C48
.xdata$x:00002C48 ; Segment type: Pure data
.xdata$x:00002C48 ; Segment permissions: Read
.xdata$x:00002C48 _xdata$x        segment dword public 'DATA' use32
.xdata$x:00002C48                 assume cs:_xdata$x
.xdata$x:00002C48                 ;org 2C48h
.xdata$x:00002C48 ; COMDAT (pick associative to section at 1524)
.xdata$x:00002C48 __unwindtable$??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@PBD@Z db 0FFh
.xdata$x:00002C48                                         ; DATA XREF: .xdata$x:00002C58o
.xdata$x:00002C49                 db 0FFh
.xdata$x:00002C4A                 db 0FFh
.xdata$x:00002C4B                 db 0FFh
.xdata$x:00002C4C                 dd offset __unwindfunclet$??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@PBD@Z$0
.xdata$x:00002C50 __ehfuncinfo$??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@PBD@Z db  22h ; "
.xdata$x:00002C50                                         ; DATA XREF: __ehhandler$??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@PBD@Z+11o
.xdata$x:00002C51                 db    5
.xdata$x:00002C52                 db  93h ; ô
.xdata$x:00002C53                 db  19h
.xdata$x:00002C54                 db    1
.xdata$x:00002C55                 db    0
.xdata$x:00002C56                 db    0
.xdata$x:00002C57                 db    0
.xdata$x:00002C58                 dd offset __unwindtable$??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@PBD@Z
.xdata$x:00002C5C                 db    0
.xdata$x:00002C5D                 db    0
.xdata$x:00002C5E                 db    0
.xdata$x:00002C5F                 db    0
.xdata$x:00002C60                 db    0
.xdata$x:00002C61                 db    0
.xdata$x:00002C62                 db    0
.xdata$x:00002C63                 db    0
.xdata$x:00002C64                 db    0
.xdata$x:00002C65                 db    0
.xdata$x:00002C66                 db    0
.xdata$x:00002C67                 db    0
.xdata$x:00002C68                 db    0
.xdata$x:00002C69                 db    0
.xdata$x:00002C6A                 db    0
.xdata$x:00002C6B                 db    0
.xdata$x:00002C6C                 db    0
.xdata$x:00002C6D                 db    0
.xdata$x:00002C6E                 db    0
.xdata$x:00002C6F                 db    0
.xdata$x:00002C70                 db    0
.xdata$x:00002C71                 db    0
.xdata$x:00002C72                 db    0
.xdata$x:00002C73                 db    0
.xdata$x:00002C73 _xdata$x        ends
.xdata$x:00002C73
.xdata$x:00002C74 ; ===========================================================================
.xdata$x:00002C74
.xdata$x:00002C74 ; Segment type: Pure data
.xdata$x:00002C74 ; Segment permissions: Read
.xdata$x:00002C74 _xdata$x        segment dword public 'DATA' use32
.xdata$x:00002C74                 assume cs:_xdata$x
.xdata$x:00002C74                 ;org 2C74h
.xdata$x:00002C74 ; COMDAT (pick associative to section at 18B8)
.xdata$x:00002C74 __unwindtable$??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ db 0FFh
.xdata$x:00002C74                                         ; DATA XREF: .xdata$x:00002C84o
.xdata$x:00002C75                 db 0FFh
.xdata$x:00002C76                 db 0FFh
.xdata$x:00002C77                 db 0FFh
.xdata$x:00002C78                 dd offset __unwindfunclet$??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ$0
.xdata$x:00002C7C __ehfuncinfo$??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ db  22h ; "
.xdata$x:00002C7C                                         ; DATA XREF: __ehhandler$??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ+11o
.xdata$x:00002C7D                 db    5
.xdata$x:00002C7E                 db  93h ; ô
.xdata$x:00002C7F                 db  19h
.xdata$x:00002C80                 db    1
.xdata$x:00002C81                 db    0
.xdata$x:00002C82                 db    0
.xdata$x:00002C83                 db    0
.xdata$x:00002C84                 dd offset __unwindtable$??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ
.xdata$x:00002C88                 align 20h
.xdata$x:00002C88 _xdata$x        ends
.xdata$x:00002C88
.xdata$x:00002CA0 ; ===========================================================================
.xdata$x:00002CA0
.xdata$x:00002CA0 ; Segment type: Pure data
.xdata$x:00002CA0 ; Segment permissions: Read
.xdata$x:00002CA0 _xdata$x        segment dword public 'DATA' use32
.xdata$x:00002CA0                 assume cs:_xdata$x
.xdata$x:00002CA0                 ;org 2CA0h
.xdata$x:00002CA0 ; COMDAT (pick associative to section at 1D50)
.xdata$x:00002CA0 __catchsym$?_Copy@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEXII@Z$5 db    0
.xdata$x:00002CA0                                         ; DATA XREF: .xdata$x:00002D28o
.xdata$x:00002CA1                 db    0
.xdata$x:00002CA2                 db    0
.xdata$x:00002CA3                 db    0
.xdata$x:00002CA4                 db    0
.xdata$x:00002CA5                 db    0
.xdata$x:00002CA6                 db    0
.xdata$x:00002CA7                 db    0
.xdata$x:00002CA8                 db    0
.xdata$x:00002CA9                 db    0
.xdata$x:00002CAA                 db    0
.xdata$x:00002CAB                 db    0
.xdata$x:00002CAC                 dd offset __catch$?_Copy@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEXII@Z$0
.xdata$x:00002CB0 __catchsym$?_Copy@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEXII@Z$4 db    0
.xdata$x:00002CB0                                         ; DATA XREF: .xdata$x:00002D14o
.xdata$x:00002CB1                 db    0
.xdata$x:00002CB2                 db    0
.xdata$x:00002CB3                 db    0
.xdata$x:00002CB4                 db    0
.xdata$x:00002CB5                 db    0
.xdata$x:00002CB6                 db    0
.xdata$x:00002CB7                 db    0
.xdata$x:00002CB8                 db    0
.xdata$x:00002CB9                 db    0
.xdata$x:00002CBA                 db    0
.xdata$x:00002CBB                 db    0
.xdata$x:00002CBC                 dd offset __catch$?_Copy@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEXII@Z$1
.xdata$x:00002CC0 __unwindtable$?_Copy@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEXII@Z db 0FFh
.xdata$x:00002CC0                                         ; DATA XREF: .xdata$x:00002CE8o
.xdata$x:00002CC1                 db 0FFh
.xdata$x:00002CC2                 db 0FFh
.xdata$x:00002CC3                 db 0FFh
.xdata$x:00002CC4                 db    0
.xdata$x:00002CC5                 db    0
.xdata$x:00002CC6                 db    0
.xdata$x:00002CC7                 db    0
.xdata$x:00002CC8                 db 0FFh
.xdata$x:00002CC9                 db 0FFh
.xdata$x:00002CCA                 db 0FFh
.xdata$x:00002CCB                 db 0FFh
.xdata$x:00002CCC                 db    0
.xdata$x:00002CCD                 db    0
.xdata$x:00002CCE                 db    0
.xdata$x:00002CCF                 db    0
.xdata$x:00002CD0                 db    1
.xdata$x:00002CD1                 db    0
.xdata$x:00002CD2                 db    0
.xdata$x:00002CD3                 db    0
.xdata$x:00002CD4                 db    0
.xdata$x:00002CD5                 db    0
.xdata$x:00002CD6                 db    0
.xdata$x:00002CD7                 db    0
.xdata$x:00002CD8                 db    1
.xdata$x:00002CD9                 db    0
.xdata$x:00002CDA                 db    0
.xdata$x:00002CDB                 db    0
.xdata$x:00002CDC                 db    0
.xdata$x:00002CDD                 db    0
.xdata$x:00002CDE                 db    0
.xdata$x:00002CDF                 db    0
.xdata$x:00002CE0 __ehfuncinfo$?_Copy@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEXII@Z db  22h ; "
.xdata$x:00002CE0                                         ; DATA XREF: __ehhandler$?_Copy@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEXII@Z+11o
.xdata$x:00002CE1                 db    5
.xdata$x:00002CE2                 db  93h ; ô
.xdata$x:00002CE3                 db  19h
.xdata$x:00002CE4                 db    4
.xdata$x:00002CE5                 db    0
.xdata$x:00002CE6                 db    0
.xdata$x:00002CE7                 db    0
.xdata$x:00002CE8                 dd offset __unwindtable$?_Copy@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEXII@Z
.xdata$x:00002CEC                 db    2
.xdata$x:00002CED                 db    0
.xdata$x:00002CEE                 db    0
.xdata$x:00002CEF                 db    0
.xdata$x:00002CF0                 dd offset __tryblocktable$?_Copy@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEXII@Z
.xdata$x:00002CF4                 db    0
.xdata$x:00002CF5                 db    0
.xdata$x:00002CF6                 db    0
.xdata$x:00002CF7                 db    0
.xdata$x:00002CF8                 db    0
.xdata$x:00002CF9                 db    0
.xdata$x:00002CFA                 db    0
.xdata$x:00002CFB                 db    0
.xdata$x:00002CFC                 db    0
.xdata$x:00002CFD                 db    0
.xdata$x:00002CFE                 db    0
.xdata$x:00002CFF                 db    0
.xdata$x:00002D00                 db    0
.xdata$x:00002D01                 db    0
.xdata$x:00002D02                 db    0
.xdata$x:00002D03                 db    0
.xdata$x:00002D04 __tryblocktable$?_Copy@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEXII@Z db    2
.xdata$x:00002D04                                         ; DATA XREF: .xdata$x:00002CF0o
.xdata$x:00002D05                 db    0
.xdata$x:00002D06                 db    0
.xdata$x:00002D07                 db    0
.xdata$x:00002D08                 db    2
.xdata$x:00002D09                 db    0
.xdata$x:00002D0A                 db    0
.xdata$x:00002D0B                 db    0
.xdata$x:00002D0C                 db    3
.xdata$x:00002D0D                 db    0
.xdata$x:00002D0E                 db    0
.xdata$x:00002D0F                 db    0
.xdata$x:00002D10                 db    1
.xdata$x:00002D11                 db    0
.xdata$x:00002D12                 db    0
.xdata$x:00002D13                 db    0
.xdata$x:00002D14                 dd offset __catchsym$?_Copy@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEXII@Z$4
.xdata$x:00002D18                 align 10h
.xdata$x:00002D20                 db    3
.xdata$x:00002D21                 db    0
.xdata$x:00002D22                 db    0
.xdata$x:00002D23                 db    0
.xdata$x:00002D24                 db    1
.xdata$x:00002D25                 db    0
.xdata$x:00002D26                 db    0
.xdata$x:00002D27                 db    0
.xdata$x:00002D28                 dd offset __catchsym$?_Copy@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEXII@Z$5
.xdata$x:00002D28 _xdata$x        ends
.xdata$x:00002D28
.xdata$x:00002D2C ; ===========================================================================
.xdata$x:00002D2C
.xdata$x:00002D2C ; Segment type: Pure data
.xdata$x:00002D2C ; Segment permissions: Read
.xdata$x:00002D2C _xdata$x        segment dword public 'DATA' use32
.xdata$x:00002D2C                 assume cs:_xdata$x
.xdata$x:00002D2C                 ;org 2D2Ch
.xdata$x:00002D2C ; COMDAT (pick associative to section at 15F8)
.xdata$x:00002D2C __unwindtable$??0_Generic_error_category@std@@QAE@XZ db 0FFh
.xdata$x:00002D2C                                         ; DATA XREF: .xdata$x:00002D3Co
.xdata$x:00002D2D                 db 0FFh
.xdata$x:00002D2E                 db 0FFh
.xdata$x:00002D2F                 db 0FFh
.xdata$x:00002D30                 dd offset __unwindfunclet$??0_Generic_error_category@std@@QAE@XZ$0
.xdata$x:00002D34 __ehfuncinfo$??0_Generic_error_category@std@@QAE@XZ db  22h ; "
.xdata$x:00002D34                                         ; DATA XREF: __ehhandler$??0_Generic_error_category@std@@QAE@XZ+11o
.xdata$x:00002D35                 db    5
.xdata$x:00002D36                 db  93h ; ô
.xdata$x:00002D37                 db  19h
.xdata$x:00002D38                 db    1
.xdata$x:00002D39                 db    0
.xdata$x:00002D3A                 db    0
.xdata$x:00002D3B                 db    0
.xdata$x:00002D3C                 dd offset __unwindtable$??0_Generic_error_category@std@@QAE@XZ
.xdata$x:00002D40                 db    0
.xdata$x:00002D41                 db    0
.xdata$x:00002D42                 db    0
.xdata$x:00002D43                 db    0
.xdata$x:00002D44                 db    0
.xdata$x:00002D45                 db    0
.xdata$x:00002D46                 db    0
.xdata$x:00002D47                 db    0
.xdata$x:00002D48                 db    0
.xdata$x:00002D49                 db    0
.xdata$x:00002D4A                 db    0
.xdata$x:00002D4B                 db    0
.xdata$x:00002D4C                 db    0
.xdata$x:00002D4D                 db    0
.xdata$x:00002D4E                 db    0
.xdata$x:00002D4F                 db    0
.xdata$x:00002D50                 db    0
.xdata$x:00002D51                 db    0
.xdata$x:00002D52                 db    0
.xdata$x:00002D53                 db    0
.xdata$x:00002D54                 db    0
.xdata$x:00002D55                 db    0
.xdata$x:00002D56                 db    0
.xdata$x:00002D57                 db    0
.xdata$x:00002D57 _xdata$x        ends
.xdata$x:00002D57
.xdata$x:00002D58 ; ===========================================================================
.xdata$x:00002D58
.xdata$x:00002D58 ; Segment type: Pure data
.xdata$x:00002D58 ; Segment permissions: Read
.xdata$x:00002D58 _xdata$x        segment dword public 'DATA' use32
.xdata$x:00002D58                 assume cs:_xdata$x
.xdata$x:00002D58                 ;org 2D58h
.xdata$x:00002D58 ; COMDAT (pick associative to section at 27F0)
.xdata$x:00002D58 __unwindtable$?message@_Generic_error_category@std@@UBE?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@2@H@Z db 0FFh
.xdata$x:00002D58                                         ; DATA XREF: .xdata$x:00002D68o
.xdata$x:00002D59                 db 0FFh
.xdata$x:00002D5A                 db 0FFh
.xdata$x:00002D5B                 db 0FFh
.xdata$x:00002D5C                 dd offset __unwindfunclet$?message@_Generic_error_category@std@@UBE?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@2@H@Z$0
.xdata$x:00002D60 __ehfuncinfo$?message@_Generic_error_category@std@@UBE?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@2@H@Z db  22h ; "
.xdata$x:00002D60                                         ; DATA XREF: __ehhandler$?message@_Generic_error_category@std@@UBE?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@2@H@Z+11o
.xdata$x:00002D61                 db    5
.xdata$x:00002D62                 db  93h ; ô
.xdata$x:00002D63                 db  19h
.xdata$x:00002D64                 db    1
.xdata$x:00002D65                 db    0
.xdata$x:00002D66                 db    0
.xdata$x:00002D67                 db    0
.xdata$x:00002D68                 dd offset __unwindtable$?message@_Generic_error_category@std@@UBE?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@2@H@Z
.xdata$x:00002D6C                 db    0
.xdata$x:00002D6D                 db    0
.xdata$x:00002D6E                 db    0
.xdata$x:00002D6F                 db    0
.xdata$x:00002D70                 db    0
.xdata$x:00002D71                 db    0
.xdata$x:00002D72                 db    0
.xdata$x:00002D73                 db    0
.xdata$x:00002D74                 db    0
.xdata$x:00002D75                 db    0
.xdata$x:00002D76                 db    0
.xdata$x:00002D77                 db    0
.xdata$x:00002D78                 db    0
.xdata$x:00002D79                 db    0
.xdata$x:00002D7A                 db    0
.xdata$x:00002D7B                 db    0
.xdata$x:00002D7C                 db    0
.xdata$x:00002D7D                 db    0
.xdata$x:00002D7E                 db    0
.xdata$x:00002D7F                 db    0
.xdata$x:00002D80                 db    0
.xdata$x:00002D81                 db    0
.xdata$x:00002D82                 db    0
.xdata$x:00002D83                 db    0
.xdata$x:00002D83 _xdata$x        ends
.xdata$x:00002D83
.xdata$x:00002D84 ; ===========================================================================
.xdata$x:00002D84
.xdata$x:00002D84 ; Segment type: Pure data
.xdata$x:00002D84 ; Segment permissions: Read
.xdata$x:00002D84 _xdata$x        segment dword public 'DATA' use32
.xdata$x:00002D84                 assume cs:_xdata$x
.xdata$x:00002D84                 ;org 2D84h
.xdata$x:00002D84 ; COMDAT (pick associative to section at 1948)
.xdata$x:00002D84 __unwindtable$??1_Generic_error_category@std@@UAE@XZ db 0FFh
.xdata$x:00002D84                                         ; DATA XREF: .xdata$x:00002D94o
.xdata$x:00002D85                 db 0FFh
.xdata$x:00002D86                 db 0FFh
.xdata$x:00002D87                 db 0FFh
.xdata$x:00002D88                 dd offset __unwindfunclet$??1_Generic_error_category@std@@UAE@XZ$0
.xdata$x:00002D8C __ehfuncinfo$??1_Generic_error_category@std@@UAE@XZ db  22h ; "
.xdata$x:00002D8C                                         ; DATA XREF: __ehhandler$??1_Generic_error_category@std@@UAE@XZ+11o
.xdata$x:00002D8D                 db    5
.xdata$x:00002D8E                 db  93h ; ô
.xdata$x:00002D8F                 db  19h
.xdata$x:00002D90                 db    1
.xdata$x:00002D91                 db    0
.xdata$x:00002D92                 db    0
.xdata$x:00002D93                 db    0
.xdata$x:00002D94                 dd offset __unwindtable$??1_Generic_error_category@std@@UAE@XZ
.xdata$x:00002D98                 db    0
.xdata$x:00002D99                 db    0
.xdata$x:00002D9A                 db    0
.xdata$x:00002D9B                 db    0
.xdata$x:00002D9C                 db    0
.xdata$x:00002D9D                 db    0
.xdata$x:00002D9E                 db    0
.xdata$x:00002D9F                 db    0
.xdata$x:00002DA0                 db    0
.xdata$x:00002DA1                 db    0
.xdata$x:00002DA2                 db    0
.xdata$x:00002DA3                 db    0
.xdata$x:00002DA4                 db    0
.xdata$x:00002DA5                 db    0
.xdata$x:00002DA6                 db    0
.xdata$x:00002DA7                 db    0
.xdata$x:00002DA8                 db    0
.xdata$x:00002DA9                 db    0
.xdata$x:00002DAA                 db    0
.xdata$x:00002DAB                 db    0
.xdata$x:00002DAC                 db    0
.xdata$x:00002DAD                 db    0
.xdata$x:00002DAE                 db    0
.xdata$x:00002DAF                 db    0
.xdata$x:00002DAF _xdata$x        ends
.xdata$x:00002DAF
.xdata$x:00002DB0 ; ===========================================================================
.xdata$x:00002DB0
.xdata$x:00002DB0 ; Segment type: Pure data
.xdata$x:00002DB0 ; Segment permissions: Read
.xdata$x:00002DB0 _xdata$x        segment dword public 'DATA' use32
.xdata$x:00002DB0                 assume cs:_xdata$x
.xdata$x:00002DB0                 ;org 2DB0h
.xdata$x:00002DB0 ; COMDAT (pick associative to section at 1684)
.xdata$x:00002DB0 __unwindtable$??0_Iostream_error_category@std@@QAE@XZ db 0FFh
.xdata$x:00002DB0                                         ; DATA XREF: .xdata$x:00002DC0o
.xdata$x:00002DB1                 db 0FFh
.xdata$x:00002DB2                 db 0FFh
.xdata$x:00002DB3                 db 0FFh
.xdata$x:00002DB4                 dd offset __unwindfunclet$??0_Iostream_error_category@std@@QAE@XZ$0
.xdata$x:00002DB8 __ehfuncinfo$??0_Iostream_error_category@std@@QAE@XZ db  22h ; "
.xdata$x:00002DB8                                         ; DATA XREF: __ehhandler$??0_Iostream_error_category@std@@QAE@XZ+11o
.xdata$x:00002DB9                 db    5
.xdata$x:00002DBA                 db  93h ; ô
.xdata$x:00002DBB                 db  19h
.xdata$x:00002DBC                 db    1
.xdata$x:00002DBD                 db    0
.xdata$x:00002DBE                 db    0
.xdata$x:00002DBF                 db    0
.xdata$x:00002DC0                 dd offset __unwindtable$??0_Iostream_error_category@std@@QAE@XZ
.xdata$x:00002DC4                 db    0
.xdata$x:00002DC5                 db    0
.xdata$x:00002DC6                 db    0
.xdata$x:00002DC7                 db    0
.xdata$x:00002DC8                 db    0
.xdata$x:00002DC9                 db    0
.xdata$x:00002DCA                 db    0
.xdata$x:00002DCB                 db    0
.xdata$x:00002DCC                 db    0
.xdata$x:00002DCD                 db    0
.xdata$x:00002DCE                 db    0
.xdata$x:00002DCF                 db    0
.xdata$x:00002DD0                 db    0
.xdata$x:00002DD1                 db    0
.xdata$x:00002DD2                 db    0
.xdata$x:00002DD3                 db    0
.xdata$x:00002DD4                 db    0
.xdata$x:00002DD5                 db    0
.xdata$x:00002DD6                 db    0
.xdata$x:00002DD7                 db    0
.xdata$x:00002DD8                 db    0
.xdata$x:00002DD9                 db    0
.xdata$x:00002DDA                 db    0
.xdata$x:00002DDB                 db    0
.xdata$x:00002DDB _xdata$x        ends
.xdata$x:00002DDB
.xdata$x:00002DDC ; ===========================================================================
.xdata$x:00002DDC
.xdata$x:00002DDC ; Segment type: Pure data
.xdata$x:00002DDC ; Segment permissions: Read
.xdata$x:00002DDC _xdata$x        segment dword public 'DATA' use32
.xdata$x:00002DDC                 assume cs:_xdata$x
.xdata$x:00002DDC                 ;org 2DDCh
.xdata$x:00002DDC ; COMDAT (pick associative to section at 28A8)
.xdata$x:00002DDC __unwindtable$?message@_Iostream_error_category@std@@UBE?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@2@H@Z db 0FFh
.xdata$x:00002DDC                                         ; DATA XREF: .xdata$x:00002DECo
.xdata$x:00002DDD                 db 0FFh
.xdata$x:00002DDE                 db 0FFh
.xdata$x:00002DDF                 db 0FFh
.xdata$x:00002DE0                 dd offset __unwindfunclet$?message@_Iostream_error_category@std@@UBE?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@2@H@Z$0
.xdata$x:00002DE4 __ehfuncinfo$?message@_Iostream_error_category@std@@UBE?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@2@H@Z db  22h ; "
.xdata$x:00002DE4                                         ; DATA XREF: __ehhandler$?message@_Iostream_error_category@std@@UBE?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@2@H@Z+11o
.xdata$x:00002DE5                 db    5
.xdata$x:00002DE6                 db  93h ; ô
.xdata$x:00002DE7                 db  19h
.xdata$x:00002DE8                 db    1
.xdata$x:00002DE9                 db    0
.xdata$x:00002DEA                 db    0
.xdata$x:00002DEB                 db    0
.xdata$x:00002DEC                 dd offset __unwindtable$?message@_Iostream_error_category@std@@UBE?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@2@H@Z
.xdata$x:00002DF0                 db    0
.xdata$x:00002DF1                 db    0
.xdata$x:00002DF2                 db    0
.xdata$x:00002DF3                 db    0
.xdata$x:00002DF4                 db    0
.xdata$x:00002DF5                 db    0
.xdata$x:00002DF6                 db    0
.xdata$x:00002DF7                 db    0
.xdata$x:00002DF8                 db    0
.xdata$x:00002DF9                 db    0
.xdata$x:00002DFA                 db    0
.xdata$x:00002DFB                 db    0
.xdata$x:00002DFC                 db    0
.xdata$x:00002DFD                 db    0
.xdata$x:00002DFE                 db    0
.xdata$x:00002DFF                 db    0
.xdata$x:00002E00                 db    0
.xdata$x:00002E01                 db    0
.xdata$x:00002E02                 db    0
.xdata$x:00002E03                 db    0
.xdata$x:00002E04                 db    0
.xdata$x:00002E05                 db    0
.xdata$x:00002E06                 db    0
.xdata$x:00002E07                 db    0
.xdata$x:00002E07 _xdata$x        ends
.xdata$x:00002E07
.xdata$x:00002E08 ; ===========================================================================
.xdata$x:00002E08
.xdata$x:00002E08 ; Segment type: Pure data
.xdata$x:00002E08 ; Segment permissions: Read
.xdata$x:00002E08 _xdata$x        segment dword public 'DATA' use32
.xdata$x:00002E08                 assume cs:_xdata$x
.xdata$x:00002E08                 ;org 2E08h
.xdata$x:00002E08 ; COMDAT (pick associative to section at 19B8)
.xdata$x:00002E08 __unwindtable$??1_Iostream_error_category@std@@UAE@XZ db 0FFh
.xdata$x:00002E08                                         ; DATA XREF: .xdata$x:00002E18o
.xdata$x:00002E09                 db 0FFh
.xdata$x:00002E0A                 db 0FFh
.xdata$x:00002E0B                 db 0FFh
.xdata$x:00002E0C                 dd offset __unwindfunclet$??1_Iostream_error_category@std@@UAE@XZ$0
.xdata$x:00002E10 __ehfuncinfo$??1_Iostream_error_category@std@@UAE@XZ db  22h ; "
.xdata$x:00002E10                                         ; DATA XREF: __ehhandler$??1_Iostream_error_category@std@@UAE@XZ+11o
.xdata$x:00002E11                 db    5
.xdata$x:00002E12                 db  93h ; ô
.xdata$x:00002E13                 db  19h
.xdata$x:00002E14                 db    1
.xdata$x:00002E15                 db    0
.xdata$x:00002E16                 db    0
.xdata$x:00002E17                 db    0
.xdata$x:00002E18                 dd offset __unwindtable$??1_Iostream_error_category@std@@UAE@XZ
.xdata$x:00002E1C                 db    0
.xdata$x:00002E1D                 db    0
.xdata$x:00002E1E                 db    0
.xdata$x:00002E1F                 db    0
.xdata$x:00002E20                 db    0
.xdata$x:00002E21                 db    0
.xdata$x:00002E22                 db    0
.xdata$x:00002E23                 db    0
.xdata$x:00002E24                 db    0
.xdata$x:00002E25                 db    0
.xdata$x:00002E26                 db    0
.xdata$x:00002E27                 db    0
.xdata$x:00002E28                 db    0
.xdata$x:00002E29                 db    0
.xdata$x:00002E2A                 db    0
.xdata$x:00002E2B                 db    0
.xdata$x:00002E2C                 db    0
.xdata$x:00002E2D                 db    0
.xdata$x:00002E2E                 db    0
.xdata$x:00002E2F                 db    0
.xdata$x:00002E30                 db    0
.xdata$x:00002E31                 db    0
.xdata$x:00002E32                 db    0
.xdata$x:00002E33                 db    0
.xdata$x:00002E33 _xdata$x        ends
.xdata$x:00002E33
.xdata$x:00002E34 ; ===========================================================================
.xdata$x:00002E34
.xdata$x:00002E34 ; Segment type: Pure data
.xdata$x:00002E34 ; Segment permissions: Read
.xdata$x:00002E34 _xdata$x        segment dword public 'DATA' use32
.xdata$x:00002E34                 assume cs:_xdata$x
.xdata$x:00002E34                 ;org 2E34h
.xdata$x:00002E34 ; COMDAT (pick associative to section at 1700)
.xdata$x:00002E34 __unwindtable$??0_System_error_category@std@@QAE@XZ db 0FFh
.xdata$x:00002E34                                         ; DATA XREF: .xdata$x:00002E44o
.xdata$x:00002E35                 db 0FFh
.xdata$x:00002E36                 db 0FFh
.xdata$x:00002E37                 db 0FFh
.xdata$x:00002E38                 dd offset __unwindfunclet$??0_System_error_category@std@@QAE@XZ$0
.xdata$x:00002E3C __ehfuncinfo$??0_System_error_category@std@@QAE@XZ db  22h ; "
.xdata$x:00002E3C                                         ; DATA XREF: __ehhandler$??0_System_error_category@std@@QAE@XZ+11o
.xdata$x:00002E3D                 db    5
.xdata$x:00002E3E                 db  93h ; ô
.xdata$x:00002E3F                 db  19h
.xdata$x:00002E40                 db    1
.xdata$x:00002E41                 db    0
.xdata$x:00002E42                 db    0
.xdata$x:00002E43                 db    0
.xdata$x:00002E44                 dd offset __unwindtable$??0_System_error_category@std@@QAE@XZ
.xdata$x:00002E48                 align 20h
.xdata$x:00002E48 _xdata$x        ends
.xdata$x:00002E48
.xdata$x:00002E60 ; ===========================================================================
.xdata$x:00002E60
.xdata$x:00002E60 ; Segment type: Pure data
.xdata$x:00002E60 ; Segment permissions: Read
.xdata$x:00002E60 _xdata$x        segment dword public 'DATA' use32
.xdata$x:00002E60                 assume cs:_xdata$x
.xdata$x:00002E60                 ;org 2E60h
.xdata$x:00002E60 ; COMDAT (pick associative to section at 296C)
.xdata$x:00002E60 __unwindtable$?message@_System_error_category@std@@UBE?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@2@H@Z db 0FFh
.xdata$x:00002E60                                         ; DATA XREF: .xdata$x:00002E70o
.xdata$x:00002E61                 db 0FFh
.xdata$x:00002E62                 db 0FFh
.xdata$x:00002E63                 db 0FFh
.xdata$x:00002E64                 dd offset __unwindfunclet$?message@_System_error_category@std@@UBE?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@2@H@Z$0
.xdata$x:00002E68 __ehfuncinfo$?message@_System_error_category@std@@UBE?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@2@H@Z db  22h ; "
.xdata$x:00002E68                                         ; DATA XREF: __ehhandler$?message@_System_error_category@std@@UBE?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@2@H@Z+11o
.xdata$x:00002E69                 db    5
.xdata$x:00002E6A                 db  93h ; ô
.xdata$x:00002E6B                 db  19h
.xdata$x:00002E6C                 db    1
.xdata$x:00002E6D                 db    0
.xdata$x:00002E6E                 db    0
.xdata$x:00002E6F                 db    0
.xdata$x:00002E70                 dd offset __unwindtable$?message@_System_error_category@std@@UBE?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@2@H@Z
.xdata$x:00002E74                 db    0
.xdata$x:00002E75                 db    0
.xdata$x:00002E76                 db    0
.xdata$x:00002E77                 db    0
.xdata$x:00002E78                 db    0
.xdata$x:00002E79                 db    0
.xdata$x:00002E7A                 db    0
.xdata$x:00002E7B                 db    0
.xdata$x:00002E7C                 db    0
.xdata$x:00002E7D                 db    0
.xdata$x:00002E7E                 db    0
.xdata$x:00002E7F                 db    0
.xdata$x:00002E80                 db    0
.xdata$x:00002E81                 db    0
.xdata$x:00002E82                 db    0
.xdata$x:00002E83                 db    0
.xdata$x:00002E84                 db    0
.xdata$x:00002E85                 db    0
.xdata$x:00002E86                 db    0
.xdata$x:00002E87                 db    0
.xdata$x:00002E88                 db    0
.xdata$x:00002E89                 db    0
.xdata$x:00002E8A                 db    0
.xdata$x:00002E8B                 db    0
.xdata$x:00002E8B _xdata$x        ends
.xdata$x:00002E8B
.xdata$x:00002E8C ; ===========================================================================
.xdata$x:00002E8C
.xdata$x:00002E8C ; Segment type: Pure data
.xdata$x:00002E8C ; Segment permissions: Read
.xdata$x:00002E8C _xdata$x        segment dword public 'DATA' use32
.xdata$x:00002E8C                 assume cs:_xdata$x
.xdata$x:00002E8C                 ;org 2E8Ch
.xdata$x:00002E8C ; COMDAT (pick associative to section at 1A28)
.xdata$x:00002E8C __unwindtable$??1_System_error_category@std@@UAE@XZ db 0FFh
.xdata$x:00002E8C                                         ; DATA XREF: .xdata$x:00002E9Co
.xdata$x:00002E8D                 db 0FFh
.xdata$x:00002E8E                 db 0FFh
.xdata$x:00002E8F                 db 0FFh
.xdata$x:00002E90                 dd offset __unwindfunclet$??1_System_error_category@std@@UAE@XZ$0
.xdata$x:00002E94 __ehfuncinfo$??1_System_error_category@std@@UAE@XZ db  22h ; "
.xdata$x:00002E94                                         ; DATA XREF: __ehhandler$??1_System_error_category@std@@UAE@XZ+11o
.xdata$x:00002E95                 db    5
.xdata$x:00002E96                 db  93h ; ô
.xdata$x:00002E97                 db  19h
.xdata$x:00002E98                 db    1
.xdata$x:00002E99                 db    0
.xdata$x:00002E9A                 db    0
.xdata$x:00002E9B                 db    0
.xdata$x:00002E9C                 dd offset __unwindtable$??1_System_error_category@std@@UAE@XZ
.xdata$x:00002EA0                 db    0
.xdata$x:00002EA1                 db    0
.xdata$x:00002EA2                 db    0
.xdata$x:00002EA3                 db    0
.xdata$x:00002EA4                 db    0
.xdata$x:00002EA5                 db    0
.xdata$x:00002EA6                 db    0
.xdata$x:00002EA7                 db    0
.xdata$x:00002EA8                 db    0
.xdata$x:00002EA9                 db    0
.xdata$x:00002EAA                 db    0
.xdata$x:00002EAB                 db    0
.xdata$x:00002EAC                 db    0
.xdata$x:00002EAD                 db    0
.xdata$x:00002EAE                 db    0
.xdata$x:00002EAF                 db    0
.xdata$x:00002EB0                 db    0
.xdata$x:00002EB1                 db    0
.xdata$x:00002EB2                 db    0
.xdata$x:00002EB3                 db    0
.xdata$x:00002EB4                 db    0
.xdata$x:00002EB5                 db    0
.xdata$x:00002EB6                 db    0
.xdata$x:00002EB7                 db    0
.xdata$x:00002EB7 _xdata$x        ends
.xdata$x:00002EB7
.xdata$x:00002EB8 ; ===========================================================================
.xdata$x:00002EB8
.xdata$x:00002EB8 ; Segment type: Pure data
.xdata$x:00002EB8 ; Segment permissions: Read
.xdata$x:00002EB8 _xdata$x        segment dword public 'DATA' use32
.xdata$x:00002EB8                 assume cs:_xdata$x
.xdata$x:00002EB8                 ;org 2EB8h
.xdata$x:00002EB8 ; COMDAT (pick associative to section at 12CC)
.xdata$x:00002EB8 __unwindtable$??$construct@U_Container_proxy@std@@U12@@?$allocator@U_Container_proxy@std@@@std@@QAEXPAU_Container_proxy@1@$$QAU21@@Z db 0FFh
.xdata$x:00002EB8                                         ; DATA XREF: .xdata$x:00002EC8o
.xdata$x:00002EB9                 db 0FFh
.xdata$x:00002EBA                 db 0FFh
.xdata$x:00002EBB                 db 0FFh
.xdata$x:00002EBC                 dd offset __unwindfunclet$??$construct@U_Container_proxy@std@@U12@@?$allocator@U_Container_proxy@std@@@std@@QAEXPAU_Container_proxy@1@$$QAU21@@Z$0
.xdata$x:00002EC0 __ehfuncinfo$??$construct@U_Container_proxy@std@@U12@@?$allocator@U_Container_proxy@std@@@std@@QAEXPAU_Container_proxy@1@$$QAU21@@Z db  22h ; "
.xdata$x:00002EC0                                         ; DATA XREF: __ehhandler$??$construct@U_Container_proxy@std@@U12@@?$allocator@U_Container_proxy@std@@@std@@QAEXPAU_Container_proxy@1@$$QAU21@@Z+11o
.xdata$x:00002EC1                 db    5
.xdata$x:00002EC2                 db  93h ; ô
.xdata$x:00002EC3                 db  19h
.xdata$x:00002EC4                 db    1
.xdata$x:00002EC5                 db    0
.xdata$x:00002EC6                 db    0
.xdata$x:00002EC7                 db    0
.xdata$x:00002EC8                 dd offset __unwindtable$??$construct@U_Container_proxy@std@@U12@@?$allocator@U_Container_proxy@std@@@std@@QAEXPAU_Container_proxy@1@$$QAU21@@Z
.xdata$x:00002ECC                 db    0
.xdata$x:00002ECD                 db    0
.xdata$x:00002ECE                 db    0
.xdata$x:00002ECF                 db    0
.xdata$x:00002ED0                 db    0
.xdata$x:00002ED1                 db    0
.xdata$x:00002ED2                 db    0
.xdata$x:00002ED3                 db    0
.xdata$x:00002ED4                 db    0
.xdata$x:00002ED5                 db    0
.xdata$x:00002ED6                 db    0
.xdata$x:00002ED7                 db    0
.xdata$x:00002ED8                 db    0
.xdata$x:00002ED9                 db    0
.xdata$x:00002EDA                 db    0
.xdata$x:00002EDB                 db    0
.xdata$x:00002EDC                 db    0
.xdata$x:00002EDD                 db    0
.xdata$x:00002EDE                 db    0
.xdata$x:00002EDF                 db    0
.xdata$x:00002EE0                 db    0
.xdata$x:00002EE1                 db    0
.xdata$x:00002EE2                 db    0
.xdata$x:00002EE3                 db    0
.xdata$x:00002EE3 _xdata$x        ends
.xdata$x:00002EE3
.xdata$x:00002EE4 ; ===========================================================================
.xdata$x:00002EE4
.xdata$x:00002EE4 ; Segment type: Pure data
.xdata$x:00002EE4 ; Segment permissions: Read
.xdata$x:00002EE4 _xdata$x        segment dword public 'DATA' use32
.xdata$x:00002EE4                 assume cs:_xdata$x
.xdata$x:00002EE4                 ;org 2EE4h
.xdata$x:00002EE4 ; COMDAT (pick associative to section at 11F8)
.xdata$x:00002EE4 __unwindtable$??$construct@PADAAPAD@?$allocator@D@std@@QAEXPAPADAAPAD@Z db 0FFh
.xdata$x:00002EE4                                         ; DATA XREF: .xdata$x:00002EF4o
.xdata$x:00002EE5                 db 0FFh
.xdata$x:00002EE6                 db 0FFh
.xdata$x:00002EE7                 db 0FFh
.xdata$x:00002EE8                 dd offset __unwindfunclet$??$construct@PADAAPAD@?$allocator@D@std@@QAEXPAPADAAPAD@Z$0
.xdata$x:00002EEC __ehfuncinfo$??$construct@PADAAPAD@?$allocator@D@std@@QAEXPAPADAAPAD@Z db  22h ; "
.xdata$x:00002EEC                                         ; DATA XREF: __ehhandler$??$construct@PADAAPAD@?$allocator@D@std@@QAEXPAPADAAPAD@Z+11o
.xdata$x:00002EED                 db    5
.xdata$x:00002EEE                 db  93h ; ô
.xdata$x:00002EEF                 db  19h
.xdata$x:00002EF0                 db    1
.xdata$x:00002EF1                 db    0
.xdata$x:00002EF2                 db    0
.xdata$x:00002EF3                 db    0
.xdata$x:00002EF4                 dd offset __unwindtable$??$construct@PADAAPAD@?$allocator@D@std@@QAEXPAPADAAPAD@Z
.xdata$x:00002EF8                 db    0
.xdata$x:00002EF9                 db    0
.xdata$x:00002EFA                 db    0
.xdata$x:00002EFB                 db    0
.xdata$x:00002EFC                 db    0
.xdata$x:00002EFD                 db    0
.xdata$x:00002EFE                 db    0
.xdata$x:00002EFF                 db    0
.xdata$x:00002F00                 db    0
.xdata$x:00002F01                 db    0
.xdata$x:00002F02                 db    0
.xdata$x:00002F03                 db    0
.xdata$x:00002F04                 db    0
.xdata$x:00002F05                 db    0
.xdata$x:00002F06                 db    0
.xdata$x:00002F07                 db    0
.xdata$x:00002F08                 db    0
.xdata$x:00002F09                 db    0
.xdata$x:00002F0A                 db    0
.xdata$x:00002F0B                 db    0
.xdata$x:00002F0C                 db    0
.xdata$x:00002F0D                 db    0
.xdata$x:00002F0E                 db    0
.xdata$x:00002F0F                 db    0
.xdata$x:00002F0F _xdata$x        ends
.xdata$x:00002F0F
.bss:00002F10 ; ===========================================================================
.bss:00002F10
.bss:00002F10 ; Segment type: Uninitialized
.bss:00002F10 ; Segment permissions: Read/Write
.bss:00002F10 _bss            segment byte public 'BSS' use32
.bss:00002F10                 assume cs:_bss
.bss:00002F10                 ;org 2F10h
.bss:00002F10                 assume es:nothing, ss:nothing, ds:_data, fs:nothing, gs:nothing
.bss:00002F10 __Tuple_alloc   db    ? ;
.bss:00002F11 ; std::_Ignore ignore
.bss:00002F11 _ignore         db    ? ;               ; DATA XREF: std::`dynamic initializer for 'ignore''(void)+3o
.bss:00002F12 _allocator_arg  db    ? ;
.bss:00002F13 _piecewise_construct db    ? ;
.bss:00002F13 _bss            ends
.bss:00002F13
.rdata:00002F14 ; ===========================================================================
.rdata:00002F14
.rdata:00002F14 ; Segment type: Pure data
.rdata:00002F14 ; Segment permissions: Read
.rdata:00002F14 _rdata          segment dword public 'DATA' use32
.rdata:00002F14                 assume cs:_rdata
.rdata:00002F14                 ;org 2F14h
.rdata:00002F14 ; COMDAT (pick largest)
.rdata:00002F14                 dd offset ??_R4error_category@std@@6B@ ; const std::error_category::`RTTI Complete Object Locator'
.rdata:00002F18                 public ??_7error_category@std@@6B@
.rdata:00002F18 ; const std::error_category::`vftable'
.rdata:00002F18 ??_7error_category@std@@6B@ dd offset ??_Eerror_category@std@@UAEPAXI@Z
.rdata:00002F18                                         ; DATA XREF: std::error_category::error_category(void)+Ao
.rdata:00002F18                                         ; std::error_category::~error_category(void)+Ao
.rdata:00002F18                                         ; std::error_category::`vector deleting destructor'(uint)
.rdata:00002F1C                 dd offset __purecall
.rdata:00002F20                 dd offset __purecall
.rdata:00002F24                 dd offset ?default_error_condition@error_category@std@@UBE?AVerror_condition@2@H@Z ; std::error_category::default_error_condition(int)
.rdata:00002F28                 dd offset ?equivalent@error_category@std@@UBE_NABVerror_code@2@H@Z ; std::error_category::equivalent(std::error_code const &,int)
.rdata:00002F2C                 dd offset ?equivalent@error_category@std@@UBE_NHABVerror_condition@2@@Z ; std::error_category::equivalent(int,std::error_condition const &)
.rdata:00002F2C _rdata          ends
.rdata:00002F2C
.rdata:00002F30 ; ===========================================================================
.rdata:00002F30
.rdata:00002F30 ; Segment type: Pure data
.rdata:00002F30 ; Segment permissions: Read
.rdata:00002F30 _rdata          segment dword public 'DATA' use32
.rdata:00002F30                 assume cs:_rdata
.rdata:00002F30                 ;org 2F30h
.rdata:00002F30 ; COMDAT (pick largest)
.rdata:00002F30                 dd offset ??_R4_Generic_error_category@std@@6B@ ; const std::_Generic_error_category::`RTTI Complete Object Locator'
.rdata:00002F34                 public ??_7_Generic_error_category@std@@6B@
.rdata:00002F34 ; const std::_Generic_error_category::`vftable'
.rdata:00002F34 ??_7_Generic_error_category@std@@6B@ dd offset ??_E_Generic_error_category@std@@UAEPAXI@Z
.rdata:00002F34                                         ; DATA XREF: std::_Generic_error_category::_Generic_error_category(void)+38o
.rdata:00002F34                                         ; std::_Generic_error_category::`vector deleting destructor'(uint)
.rdata:00002F38                 dd offset ?name@_Generic_error_category@std@@UBEPBDXZ ; std::_Generic_error_category::name(void)
.rdata:00002F3C                 dd offset ?message@_Generic_error_category@std@@UBE?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@2@H@Z ; std::_Generic_error_category::message(int)
.rdata:00002F40                 dd offset ?default_error_condition@error_category@std@@UBE?AVerror_condition@2@H@Z ; std::error_category::default_error_condition(int)
.rdata:00002F44                 dd offset ?equivalent@error_category@std@@UBE_NABVerror_code@2@H@Z ; std::error_category::equivalent(std::error_code const &,int)
.rdata:00002F48                 dd offset ?equivalent@error_category@std@@UBE_NHABVerror_condition@2@@Z ; std::error_category::equivalent(int,std::error_condition const &)
.rdata:00002F48 _rdata          ends
.rdata:00002F48
.rdata:00002F4C ; ===========================================================================
.rdata:00002F4C
.rdata:00002F4C ; Segment type: Pure data
.rdata:00002F4C ; Segment permissions: Read
.rdata:00002F4C _rdata          segment dword public 'DATA' use32
.rdata:00002F4C                 assume cs:_rdata
.rdata:00002F4C                 ;org 2F4Ch
.rdata:00002F4C ; COMDAT (pick any)
.rdata:00002F4C                 public ??_C@_07DCLBNMLN@generic?$AA@
.rdata:00002F4C ; `string'
.rdata:00002F4C ??_C@_07DCLBNMLN@generic?$AA@ db 'generic',0
.rdata:00002F4C                                         ; DATA XREF: std::_Generic_error_category::name(void)+7o
.rdata:00002F4C _rdata          ends
.rdata:00002F4C
.rdata:00002F54 ; ===========================================================================
.rdata:00002F54
.rdata:00002F54 ; Segment type: Pure data
.rdata:00002F54 ; Segment permissions: Read
.rdata:00002F54 _rdata          segment dword public 'DATA' use32
.rdata:00002F54                 assume cs:_rdata
.rdata:00002F54                 ;org 2F54h
.rdata:00002F54 ; COMDAT (pick any)
.rdata:00002F54                 public ??_C@_0O@BFJCFAAK@unknown?5error?$AA@
.rdata:00002F54 ; `string'
.rdata:00002F54 ??_C@_0O@BFJCFAAK@unknown?5error?$AA@ db 'unknown error',0
.rdata:00002F54                                         ; DATA XREF: std::_Generic_error_category::message(int):loc_283Co
.rdata:00002F54                                         ; std::_System_error_category::message(int):loc_29B8o
.rdata:00002F62                 align 4
.rdata:00002F62 _rdata          ends
.rdata:00002F62
.rdata:00002F64 ; ===========================================================================
.rdata:00002F64
.rdata:00002F64 ; Segment type: Pure data
.rdata:00002F64 ; Segment permissions: Read
.rdata:00002F64 _rdata          segment dword public 'DATA' use32
.rdata:00002F64                 assume cs:_rdata
.rdata:00002F64                 ;org 2F64h
.rdata:00002F64 ; COMDAT (pick largest)
.rdata:00002F64                 dd offset ??_R4_Iostream_error_category@std@@6B@ ; const std::_Iostream_error_category::`RTTI Complete Object Locator'
.rdata:00002F68                 public ??_7_Iostream_error_category@std@@6B@
.rdata:00002F68 ; const std::_Iostream_error_category::`vftable'
.rdata:00002F68 ??_7_Iostream_error_category@std@@6B@ dd offset ??_E_Iostream_error_category@std@@UAEPAXI@Z
.rdata:00002F68                                         ; DATA XREF: std::_Iostream_error_category::_Iostream_error_category(void)+38o
.rdata:00002F68                                         ; std::_Iostream_error_category::`vector deleting destructor'(uint)
.rdata:00002F6C                 dd offset ?name@_Iostream_error_category@std@@UBEPBDXZ ; std::_Iostream_error_category::name(void)
.rdata:00002F70                 dd offset ?message@_Iostream_error_category@std@@UBE?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@2@H@Z ; std::_Iostream_error_category::message(int)
.rdata:00002F74                 dd offset ?default_error_condition@error_category@std@@UBE?AVerror_condition@2@H@Z ; std::error_category::default_error_condition(int)
.rdata:00002F78                 dd offset ?equivalent@error_category@std@@UBE_NABVerror_code@2@H@Z ; std::error_category::equivalent(std::error_code const &,int)
.rdata:00002F7C                 dd offset ?equivalent@error_category@std@@UBE_NHABVerror_condition@2@@Z ; std::error_category::equivalent(int,std::error_condition const &)
.rdata:00002F7C _rdata          ends
.rdata:00002F7C
.rdata:00002F80 ; ===========================================================================
.rdata:00002F80
.rdata:00002F80 ; Segment type: Pure data
.rdata:00002F80 ; Segment permissions: Read
.rdata:00002F80 _rdata          segment dword public 'DATA' use32
.rdata:00002F80                 assume cs:_rdata
.rdata:00002F80                 ;org 2F80h
.rdata:00002F80 ; COMDAT (pick any)
.rdata:00002F80                 public ??_C@_08LLGCOLLL@iostream?$AA@
.rdata:00002F80 ; `string'
.rdata:00002F80 ??_C@_08LLGCOLLL@iostream?$AA@ db 'iostream',0
.rdata:00002F80                                         ; DATA XREF: std::_Iostream_error_category::name(void)+7o
.rdata:00002F89                 align 4
.rdata:00002F89 _rdata          ends
.rdata:00002F89
.rdata:00002F8C ; ===========================================================================
.rdata:00002F8C
.rdata:00002F8C ; Segment type: Pure data
.rdata:00002F8C ; Segment permissions: Read
.rdata:00002F8C _rdata          segment dword public 'DATA' use32
.rdata:00002F8C                 assume cs:_rdata
.rdata:00002F8C                 ;org 2F8Ch
.rdata:00002F8C ; COMDAT (pick any)
.rdata:00002F8C                 public ??_C@_0BG@PADBLCHM@iostream?5stream?5error?$AA@
.rdata:00002F8C ; char `string'[]
.rdata:00002F8C ??_C@_0BG@PADBLCHM@iostream?5stream?5error?$AA@ db 'iostream stream error',0
.rdata:00002F8C                                         ; DATA XREF: std::_Iostream_error_category::message(int)+35o
.rdata:00002FA2                 align 4
.rdata:00002FA2 _rdata          ends
.rdata:00002FA2
.rdata:00002FA4 ; ===========================================================================
.rdata:00002FA4
.rdata:00002FA4 ; Segment type: Pure data
.rdata:00002FA4 ; Segment permissions: Read
.rdata:00002FA4 _rdata          segment dword public 'DATA' use32
.rdata:00002FA4                 assume cs:_rdata
.rdata:00002FA4                 ;org 2FA4h
.rdata:00002FA4 ; COMDAT (pick largest)
.rdata:00002FA4                 dd offset ??_R4_System_error_category@std@@6B@ ; const std::_System_error_category::`RTTI Complete Object Locator'
.rdata:00002FA8                 public ??_7_System_error_category@std@@6B@
.rdata:00002FA8 ; const std::_System_error_category::`vftable'
.rdata:00002FA8 ??_7_System_error_category@std@@6B@ dd offset ??_E_System_error_category@std@@UAEPAXI@Z
.rdata:00002FA8                                         ; DATA XREF: std::_System_error_category::_System_error_category(void)+38o
.rdata:00002FA8                                         ; std::_System_error_category::`vector deleting destructor'(uint)
.rdata:00002FAC                 dd offset ?name@_System_error_category@std@@UBEPBDXZ ; std::_System_error_category::name(void)
.rdata:00002FB0                 dd offset ?message@_System_error_category@std@@UBE?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@2@H@Z ; std::_System_error_category::message(int)
.rdata:00002FB4                 dd offset ?default_error_condition@_System_error_category@std@@UBE?AVerror_condition@2@H@Z ; std::_System_error_category::default_error_condition(int)
.rdata:00002FB8                 dd offset ?equivalent@error_category@std@@UBE_NABVerror_code@2@H@Z ; std::error_category::equivalent(std::error_code const &,int)
.rdata:00002FBC                 dd offset ?equivalent@error_category@std@@UBE_NHABVerror_condition@2@@Z ; std::error_category::equivalent(int,std::error_condition const &)
.rdata:00002FBC _rdata          ends
.rdata:00002FBC
.rdata:00002FC0 ; ===========================================================================
.rdata:00002FC0
.rdata:00002FC0 ; Segment type: Pure data
.rdata:00002FC0 ; Segment permissions: Read
.rdata:00002FC0 _rdata          segment dword public 'DATA' use32
.rdata:00002FC0                 assume cs:_rdata
.rdata:00002FC0                 ;org 2FC0h
.rdata:00002FC0 ; COMDAT (pick any)
.rdata:00002FC0                 public ??_C@_06FHFOAHML@system?$AA@
.rdata:00002FC0 ; `string'
.rdata:00002FC0 ??_C@_06FHFOAHML@system?$AA@ db 'system',0
.rdata:00002FC0                                         ; DATA XREF: std::_System_error_category::name(void)+7o
.rdata:00002FC7                 align 4
.rdata:00002FC7 _rdata          ends
.rdata:00002FC7
.bss:00002FC8 ; ===========================================================================
.bss:00002FC8
.bss:00002FC8 ; Segment type: Uninitialized
.bss:00002FC8 ; Segment permissions: Read/Write
.bss:00002FC8 _bss            segment dword public 'BSS' use32
.bss:00002FC8                 assume cs:_bss
.bss:00002FC8                 ;org 2FC8h
.bss:00002FC8 ; COMDAT (pick any)
.bss:00002FC8                 assume es:nothing, ss:nothing, ds:_data, fs:nothing, gs:nothing
.bss:00002FC8                 public ?_Generic_object@?$_Error_objects@H@std@@2V_Generic_error_category@2@A
.bss:00002FC8 ; std::_Generic_error_category std::_Error_objects<int>::_Generic_object
.bss:00002FC8 ?_Generic_object@?$_Error_objects@H@std@@2V_Generic_error_category@2@A db    ? ;
.bss:00002FC8                                         ; DATA XREF: `dynamic initializer for 'std::_Generic_error_category std::_Error_objects<int>::_Generic_object''(void)+3o
.bss:00002FC8                                         ; `dynamic atexit destructor for 'std::_Generic_error_category std::_Error_objects<int>::_Generic_object''(void)+3o ...
.bss:00002FC9                 db    ? ;
.bss:00002FCA                 db    ? ;
.bss:00002FCB                 db    ? ;
.bss:00002FCB _bss            ends
.bss:00002FCB
.bss:00002FCC ; ===========================================================================
.bss:00002FCC
.bss:00002FCC ; Segment type: Uninitialized
.bss:00002FCC ; Segment permissions: Read/Write
.bss:00002FCC _bss            segment dword public 'BSS' use32
.bss:00002FCC                 assume cs:_bss
.bss:00002FCC                 ;org 2FCCh
.bss:00002FCC ; COMDAT (pick any)
.bss:00002FCC                 assume es:nothing, ss:nothing, ds:_data, fs:nothing, gs:nothing
.bss:00002FCC                 public ?_Iostream_object@?$_Error_objects@H@std@@2V_Iostream_error_category@2@A
.bss:00002FCC ; std::_Iostream_error_category std::_Error_objects<int>::_Iostream_object
.bss:00002FCC ?_Iostream_object@?$_Error_objects@H@std@@2V_Iostream_error_category@2@A db    ? ;
.bss:00002FCC                                         ; DATA XREF: `dynamic initializer for 'std::_Iostream_error_category std::_Error_objects<int>::_Iostream_object''(void)+3o
.bss:00002FCC                                         ; `dynamic atexit destructor for 'std::_Iostream_error_category std::_Error_objects<int>::_Iostream_object''(void)+3o
.bss:00002FCD                 db    ? ;
.bss:00002FCE                 db    ? ;
.bss:00002FCF                 db    ? ;
.bss:00002FCF _bss            ends
.bss:00002FCF
.bss:00002FD0 ; ===========================================================================
.bss:00002FD0
.bss:00002FD0 ; Segment type: Uninitialized
.bss:00002FD0 ; Segment permissions: Read/Write
.bss:00002FD0 _bss            segment dword public 'BSS' use32
.bss:00002FD0                 assume cs:_bss
.bss:00002FD0                 ;org 2FD0h
.bss:00002FD0 ; COMDAT (pick any)
.bss:00002FD0                 assume es:nothing, ss:nothing, ds:_data, fs:nothing, gs:nothing
.bss:00002FD0                 public ?_System_object@?$_Error_objects@H@std@@2V_System_error_category@2@A
.bss:00002FD0 ; std::_System_error_category std::_Error_objects<int>::_System_object
.bss:00002FD0 ?_System_object@?$_Error_objects@H@std@@2V_System_error_category@2@A db    ? ;
.bss:00002FD0                                         ; DATA XREF: `dynamic initializer for 'std::_System_error_category std::_Error_objects<int>::_System_object''(void)+3o
.bss:00002FD0                                         ; `dynamic atexit destructor for 'std::_System_error_category std::_Error_objects<int>::_System_object''(void)+3o ...
.bss:00002FD1                 db    ? ;
.bss:00002FD2                 db    ? ;
.bss:00002FD3                 db    ? ;
.bss:00002FD3 _bss            ends
.bss:00002FD3
.bss:00002FD4 ; ===========================================================================
.bss:00002FD4
.bss:00002FD4 ; Segment type: Uninitialized
.bss:00002FD4 ; Segment permissions: Read/Write
.bss:00002FD4 _bss            segment dword public 'BSS' use32
.bss:00002FD4                 assume cs:_bss
.bss:00002FD4                 ;org 2FD4h
.bss:00002FD4 ; COMDAT (pick any)
.bss:00002FD4                 assume es:nothing, ss:nothing, ds:_data, fs:nothing, gs:nothing
.bss:00002FD4                 public ?id@?$num_put@DV?$back_insert_iterator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@std@@2V0locale@2@A
.bss:00002FD4 ; std::locale::id std::num_put<char,std::back_insert_iterator<std::basic_string<char,std::char_traits<char>,std::allocator<char>>>>::id
.bss:00002FD4 ?id@?$num_put@DV?$back_insert_iterator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@std@@2V0locale@2@A db    ? ;
.bss:00002FD4                                         ; DATA XREF: `dynamic initializer for 'std::locale::id std::num_put<char,std::back_insert_iterator<std::basic_string<char,std::char_traits<char>,std::allocator<char>>>>::id''(void)+5o
.bss:00002FD5                 db    ? ;
.bss:00002FD6                 db    ? ;
.bss:00002FD7                 db    ? ;
.bss:00002FD7 _bss            ends
.bss:00002FD7
.bss:00002FD8 ; ===========================================================================
.bss:00002FD8
.bss:00002FD8 ; Segment type: Uninitialized
.bss:00002FD8 ; Segment permissions: Read/Write
.bss:00002FD8 _bss            segment dword public 'BSS' use32
.bss:00002FD8                 assume cs:_bss
.bss:00002FD8                 ;org 2FD8h
.bss:00002FD8 ; COMDAT (pick any)
.bss:00002FD8                 assume es:nothing, ss:nothing, ds:_data, fs:nothing, gs:nothing
.bss:00002FD8                 public ?id@?$num_put@_WV?$back_insert_iterator@V?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@@std@@@std@@2V0locale@2@A
.bss:00002FD8 ; std::locale::id std::num_put<wchar_t,std::back_insert_iterator<std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>>>>::id
.bss:00002FD8 ?id@?$num_put@_WV?$back_insert_iterator@V?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@@std@@@std@@2V0locale@2@A db    ? ;
.bss:00002FD8                                         ; DATA XREF: `dynamic initializer for 'std::locale::id std::num_put<wchar_t,std::back_insert_iterator<std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>>>>::id''(void)+5o
.bss:00002FD9                 db    ? ;
.bss:00002FDA                 db    ? ;
.bss:00002FDB                 db    ? ;
.bss:00002FDB _bss            ends
.bss:00002FDB
.rdata:00002FDC ; ===========================================================================
.rdata:00002FDC
.rdata:00002FDC ; Segment type: Pure data
.rdata:00002FDC ; Segment permissions: Read
.rdata:00002FDC ; Segment alignment 'qword' can not be represented in assembly
.rdata:00002FDC _rdata          segment para public 'DATA' use32
.rdata:00002FDC                 assume cs:_rdata
.rdata:00002FDC                 ;org 2FDCh
.rdata:00002FDC ; COMDAT (pick any)
.rdata:00002FDC                 public ??_C@_1IO@FEAPGJBD@?$AAC?$AA?3?$AA?2?$AAP?$AAr?$AAo?$AAg?$AAr?$AAa?$AAm?$AA?5?$AAF?$AAi?$AAl?$AAe?$AAs?$AA?5?$AA?$CI?$AAx?$AA8?$AA6?$AA?$CJ?$AA?2?$AAM?$AAi?$AAc?$AAr?$AAo?$AAs?$AAo?$AAf?$AAt@
.rdata:00002FDC ; wchar_t `string'
.rdata:00002FDC ??_C@_1IO@FEAPGJBD@?$AAC?$AA?3?$AA?2?$AAP?$AAr?$AAo?$AAg?$AAr?$AAa?$AAm?$AA?5?$AAF?$AAi?$AAl?$AAe?$AAs?$AA?5?$AA?$CI?$AAx?$AA8?$AA6?$AA?$CJ?$AA?2?$AAM?$AAi?$AAc?$AAr?$AAo?$AAs?$AAo?$AAf?$AAt@:
.rdata:00002FDC                                         ; DATA XREF: std::basic_string<char,std::char_traits<char>,std::allocator<char>>::assign(char const *)+Co
.rdata:00002FDC                                         ; std::basic_string<char,std::char_traits<char>,std::allocator<char>>::assign(char const *,uint)+12o
.rdata:00002FDC                 unicode 0, <C:\Program Files (x86)\Microsoft Visual Studio 12.0\VC\in>
.rdata:00002FDC                 unicode 0, <clude\xstring>,0
.rdata:0000306A                 align 4
.rdata:0000306A _rdata          ends
.rdata:0000306A
.bss:0000306C ; ===========================================================================
.bss:0000306C
.bss:0000306C ; Segment type: Uninitialized
.bss:0000306C ; Segment permissions: Read/Write
.bss:0000306C _bss            segment dword public 'BSS' use32
.bss:0000306C                 assume cs:_bss
.bss:0000306C                 ;org 306Ch
.bss:0000306C ; COMDAT (pick any)
.bss:0000306C                 assume es:nothing, ss:nothing, ds:_data, fs:nothing, gs:nothing
.bss:0000306C                 public ?id@?$numpunct@D@std@@2V0locale@2@A
.bss:0000306C ; std::locale::id std::numpunct<char>::id
.bss:0000306C ?id@?$numpunct@D@std@@2V0locale@2@A db    ? ;
.bss:0000306C                                         ; DATA XREF: `dynamic initializer for 'std::locale::id std::numpunct<char>::id''(void)+5o
.bss:0000306D                 db    ? ;
.bss:0000306E                 db    ? ;
.bss:0000306F                 db    ? ;
.bss:0000306F _bss            ends
.bss:0000306F
.bss:00003070 ; ===========================================================================
.bss:00003070
.bss:00003070 ; Segment type: Uninitialized
.bss:00003070 ; Segment permissions: Read/Write
.bss:00003070 _bss            segment dword public 'BSS' use32
.bss:00003070                 assume cs:_bss
.bss:00003070                 ;org 3070h
.bss:00003070 ; COMDAT (pick any)
.bss:00003070                 assume es:nothing, ss:nothing, ds:_data, fs:nothing, gs:nothing
.bss:00003070                 public ?id@?$numpunct@_W@std@@2V0locale@2@A
.bss:00003070 ; std::locale::id std::numpunct<wchar_t>::id
.bss:00003070 ?id@?$numpunct@_W@std@@2V0locale@2@A db    ? ;
.bss:00003070                                         ; DATA XREF: `dynamic initializer for 'std::locale::id std::numpunct<wchar_t>::id''(void)+5o
.bss:00003071                 db    ? ;
.bss:00003072                 db    ? ;
.bss:00003073                 db    ? ;
.bss:00003073 _bss            ends
.bss:00003073
.rdata:00003074 ; ===========================================================================
.rdata:00003074
.rdata:00003074 ; Segment type: Pure data
.rdata:00003074 ; Segment permissions: Read
.rdata:00003074 _rdata          segment dword public 'DATA' use32
.rdata:00003074                 assume cs:_rdata
.rdata:00003074                 ;org 3074h
.rdata:00003074 ; COMDAT (pick any)
.rdata:00003074                 public ??_C@_0BA@JFNIOLAK@string?5too?5long?$AA@
.rdata:00003074 ; char `string'[]
.rdata:00003074 ??_C@_0BA@JFNIOLAK@string?5too?5long?$AA@ db 'string too long',0
.rdata:00003074                                         ; DATA XREF: std::basic_string<char,std::char_traits<char>,std::allocator<char>>::_Xlen(void)+7o
.rdata:00003074 _rdata          ends
.rdata:00003074
.rdata:00003084 ; ===========================================================================
.rdata:00003084
.rdata:00003084 ; Segment type: Pure data
.rdata:00003084 ; Segment permissions: Read
.rdata:00003084 _rdata          segment dword public 'DATA' use32
.rdata:00003084                 assume cs:_rdata
.rdata:00003084                 ;org 3084h
.rdata:00003084 ; COMDAT (pick any)
.rdata:00003084                 public ??_C@_0BI@CFPLBAOH@invalid?5string?5position?$AA@
.rdata:00003084 ; char `string'[]
.rdata:00003084 ??_C@_0BI@CFPLBAOH@invalid?5string?5position?$AA@ db 'invalid string position',0
.rdata:00003084                                         ; DATA XREF: std::basic_string<char,std::char_traits<char>,std::allocator<char>>::_Xran(void)+7o
.rdata:00003084 _rdata          ends
.rdata:00003084
.rdata:0000309C ; ===========================================================================
.rdata:0000309C
.rdata:0000309C ; Segment type: Pure data
.rdata:0000309C ; Segment permissions: Read
.rdata:0000309C _rdata          segment dword public 'DATA' use32
.rdata:0000309C                 assume cs:_rdata
.rdata:0000309C                 ;org 309Ch
.rdata:0000309C ; COMDAT (pick any)
.rdata:0000309C                 public ??_C@_1CK@EOPGIILJ@?$AAi?$AAn?$AAv?$AAa?$AAl?$AAi?$AAd?$AA?5?$AAn?$AAu?$AAl?$AAl?$AA?5?$AAp?$AAo?$AAi?$AAn?$AAt?$AAe?$AAr?$AA?$AA@
.rdata:0000309C ; wchar_t `string'
.rdata:0000309C ??_C@_1CK@EOPGIILJ@?$AAi?$AAn?$AAv?$AAa?$AAl?$AAi?$AAd?$AA?5?$AAn?$AAu?$AAl?$AAl?$AA?5?$AAp?$AAo?$AAi?$AAn?$AAt?$AAe?$AAr?$AA?$AA@:
.rdata:0000309C                                         ; DATA XREF: std::_Debug_pointer<char>(char const *,wchar_t const *,uint)+11o
.rdata:0000309C                 unicode 0, <invalid null pointer>,0
.rdata:000030C6                 align 4
.rdata:000030C6 _rdata          ends
.rdata:000030C6
.rdata$r:000030C8 ; ===========================================================================
.rdata$r:000030C8
.rdata$r:000030C8 ; Segment type: Pure data
.rdata$r:000030C8 ; Segment permissions: Read
.rdata$r:000030C8 _rdata$r        segment dword public 'DATA' use32
.rdata$r:000030C8                 assume cs:_rdata$r
.rdata$r:000030C8                 ;org 30C8h
.rdata$r:000030C8 ; COMDAT (pick any)
.rdata$r:000030C8                 public ??_R4error_category@std@@6B@
.rdata$r:000030C8 ; const std::error_category::`RTTI Complete Object Locator'
.rdata$r:000030C8 ??_R4error_category@std@@6B@ db    0    ; DATA XREF: .rdata:00002F14o
.rdata$r:000030C9                 db    0
.rdata$r:000030CA                 db    0
.rdata$r:000030CB                 db    0
.rdata$r:000030CC                 db    0
.rdata$r:000030CD                 db    0
.rdata$r:000030CE                 db    0
.rdata$r:000030CF                 db    0
.rdata$r:000030D0                 db    0
.rdata$r:000030D1                 db    0
.rdata$r:000030D2                 db    0
.rdata$r:000030D3                 db    0
.rdata$r:000030D4                 dd offset ??_R0?AVerror_category@std@@@8 ; std::error_category `RTTI Type Descriptor'
.rdata$r:000030D8                 dd offset ??_R3error_category@std@@8 ; std::error_category::`RTTI Class Hierarchy Descriptor'
.rdata$r:000030D8 _rdata$r        ends
.rdata$r:000030D8
.data$r:000030DC ; ===========================================================================
.data$r:000030DC
.data$r:000030DC ; Segment type: Pure data
.data$r:000030DC ; Segment permissions: Read/Write
.data$r:000030DC _data$r         segment dword public 'DATA' use32
.data$r:000030DC                 assume cs:_data$r
.data$r:000030DC                 ;org 30DCh
.data$r:000030DC ; COMDAT (pick any)
.data$r:000030DC                 public ??_R0?AVerror_category@std@@@8
.data$r:000030DC ; class std::error_category `RTTI Type Descriptor'
.data$r:000030DC ??_R0?AVerror_category@std@@@8 dd offset ??_7type_info@@6B@
.data$r:000030DC                                         ; DATA XREF: .rdata$r:000030D4o
.data$r:000030DC                                         ; .rdata$r:std::error_category::`RTTI Base Class Descriptor at (0,-1,0,64)'o
.data$r:000030DC                                         ; const type_info::`vftable'
.data$r:000030E0                 db    0
.data$r:000030E1                 db    0
.data$r:000030E2                 db    0
.data$r:000030E3                 db    0
.data$r:000030E4                 db  2Eh ; .
.data$r:000030E5                 db  3Fh ; ?
.data$r:000030E6                 db  41h ; A
.data$r:000030E7                 db  56h ; V
.data$r:000030E8                 db  65h ; e
.data$r:000030E9                 db  72h ; r
.data$r:000030EA                 db  72h ; r
.data$r:000030EB                 db  6Fh ; o
.data$r:000030EC                 db  72h ; r
.data$r:000030ED                 db  5Fh ; _
.data$r:000030EE                 db  63h ; c
.data$r:000030EF                 db  61h ; a
.data$r:000030F0                 db  74h ; t
.data$r:000030F1                 db  65h ; e
.data$r:000030F2                 db  67h ; g
.data$r:000030F3                 db  6Fh ; o
.data$r:000030F4                 db  72h ; r
.data$r:000030F5                 db  79h ; y
.data$r:000030F6                 db  40h ; @
.data$r:000030F7                 db  73h ; s
.data$r:000030F8                 db  74h ; t
.data$r:000030F9                 db  64h ; d
.data$r:000030FA                 db  40h ; @
.data$r:000030FB                 db  40h ; @
.data$r:000030FC                 db    0
.data$r:000030FD                 align 10h
.data$r:000030FD _data$r         ends
.data$r:000030FD
.rdata$r:00003100 ; ===========================================================================
.rdata$r:00003100
.rdata$r:00003100 ; Segment type: Pure data
.rdata$r:00003100 ; Segment permissions: Read
.rdata$r:00003100 _rdata$r        segment dword public 'DATA' use32
.rdata$r:00003100                 assume cs:_rdata$r
.rdata$r:00003100                 ;org 3100h
.rdata$r:00003100 ; COMDAT (pick any)
.rdata$r:00003100                 public ??_R3error_category@std@@8
.rdata$r:00003100 ; std::error_category::`RTTI Class Hierarchy Descriptor'
.rdata$r:00003100 ??_R3error_category@std@@8 db    0      ; DATA XREF: .rdata$r:000030D8o
.rdata$r:00003100                                         ; .rdata$r:00003130o
.rdata$r:00003101                 db    0
.rdata$r:00003102                 db    0
.rdata$r:00003103                 db    0
.rdata$r:00003104                 db    0
.rdata$r:00003105                 db    0
.rdata$r:00003106                 db    0
.rdata$r:00003107                 db    0
.rdata$r:00003108                 db    1
.rdata$r:00003109                 db    0
.rdata$r:0000310A                 db    0
.rdata$r:0000310B                 db    0
.rdata$r:0000310C                 dd offset ??_R2error_category@std@@8 ; std::error_category::`RTTI Base Class Array'
.rdata$r:0000310C _rdata$r        ends
.rdata$r:0000310C
.rdata$r:00003110 ; ===========================================================================
.rdata$r:00003110
.rdata$r:00003110 ; Segment type: Pure data
.rdata$r:00003110 ; Segment permissions: Read
.rdata$r:00003110 _rdata$r        segment dword public 'DATA' use32
.rdata$r:00003110                 assume cs:_rdata$r
.rdata$r:00003110                 ;org 3110h
.rdata$r:00003110 ; COMDAT (pick any)
.rdata$r:00003110                 public ??_R2error_category@std@@8
.rdata$r:00003110 ; std::error_category::`RTTI Base Class Array'
.rdata$r:00003110 ??_R2error_category@std@@8 dd offset ??_R1A@?0A@EA@error_category@std@@8
.rdata$r:00003110                                         ; DATA XREF: .rdata$r:0000310Co
.rdata$r:00003110                                         ; std::error_category::`RTTI Base Class Descriptor at (0,-1,0,64)'
.rdata$r:00003114                 db    0
.rdata$r:00003115                 align 4
.rdata$r:00003115 _rdata$r        ends
.rdata$r:00003115
.rdata$r:00003118 ; ===========================================================================
.rdata$r:00003118
.rdata$r:00003118 ; Segment type: Pure data
.rdata$r:00003118 ; Segment permissions: Read
.rdata$r:00003118 _rdata$r        segment dword public 'DATA' use32
.rdata$r:00003118                 assume cs:_rdata$r
.rdata$r:00003118                 ;org 3118h
.rdata$r:00003118 ; COMDAT (pick any)
.rdata$r:00003118                 public ??_R1A@?0A@EA@error_category@std@@8
.rdata$r:00003118 ; std::error_category::`RTTI Base Class Descriptor at (0, -1, 0, 64)'
.rdata$r:00003118 ??_R1A@?0A@EA@error_category@std@@8 dd offset ??_R0?AVerror_category@std@@@8
.rdata$r:00003118                                         ; DATA XREF: .rdata$r:std::error_category::`RTTI Base Class Array'o
.rdata$r:00003118                                         ; .rdata$r:00003188o ...
.rdata$r:00003118                                         ; std::error_category `RTTI Type Descriptor'
.rdata$r:0000311C                 db    0
.rdata$r:0000311D                 db    0
.rdata$r:0000311E                 db    0
.rdata$r:0000311F                 db    0
.rdata$r:00003120                 db    0
.rdata$r:00003121                 db    0
.rdata$r:00003122                 db    0
.rdata$r:00003123                 db    0
.rdata$r:00003124                 db 0FFh
.rdata$r:00003125                 db 0FFh
.rdata$r:00003126                 db 0FFh
.rdata$r:00003127                 db 0FFh
.rdata$r:00003128                 db    0
.rdata$r:00003129                 db    0
.rdata$r:0000312A                 db    0
.rdata$r:0000312B                 db    0
.rdata$r:0000312C                 db  40h ; @
.rdata$r:0000312D                 db    0
.rdata$r:0000312E                 db    0
.rdata$r:0000312F                 db    0
.rdata$r:00003130                 dd offset ??_R3error_category@std@@8 ; std::error_category::`RTTI Class Hierarchy Descriptor'
.rdata$r:00003130 _rdata$r        ends
.rdata$r:00003130
.rdata$r:00003134 ; ===========================================================================
.rdata$r:00003134
.rdata$r:00003134 ; Segment type: Pure data
.rdata$r:00003134 ; Segment permissions: Read
.rdata$r:00003134 _rdata$r        segment dword public 'DATA' use32
.rdata$r:00003134                 assume cs:_rdata$r
.rdata$r:00003134                 ;org 3134h
.rdata$r:00003134 ; COMDAT (pick any)
.rdata$r:00003134                 public ??_R4_Generic_error_category@std@@6B@
.rdata$r:00003134 ; const std::_Generic_error_category::`RTTI Complete Object Locator'
.rdata$r:00003134 ??_R4_Generic_error_category@std@@6B@ db    0
.rdata$r:00003134                                         ; DATA XREF: .rdata:00002F30o
.rdata$r:00003135                 db    0
.rdata$r:00003136                 db    0
.rdata$r:00003137                 db    0
.rdata$r:00003138                 db    0
.rdata$r:00003139                 db    0
.rdata$r:0000313A                 db    0
.rdata$r:0000313B                 db    0
.rdata$r:0000313C                 db    0
.rdata$r:0000313D                 db    0
.rdata$r:0000313E                 db    0
.rdata$r:0000313F                 db    0
.rdata$r:00003140                 dd offset ??_R0?AV_Generic_error_category@std@@@8 ; std::_Generic_error_category `RTTI Type Descriptor'
.rdata$r:00003144                 dd offset ??_R3_Generic_error_category@std@@8 ; std::_Generic_error_category::`RTTI Class Hierarchy Descriptor'
.rdata$r:00003144 _rdata$r        ends
.rdata$r:00003144
.data$r:00003148 ; ===========================================================================
.data$r:00003148
.data$r:00003148 ; Segment type: Pure data
.data$r:00003148 ; Segment permissions: Read/Write
.data$r:00003148 _data$r         segment dword public 'DATA' use32
.data$r:00003148                 assume cs:_data$r
.data$r:00003148                 ;org 3148h
.data$r:00003148 ; COMDAT (pick any)
.data$r:00003148                 public ??_R0?AV_Generic_error_category@std@@@8
.data$r:00003148 ; class std::_Generic_error_category `RTTI Type Descriptor'
.data$r:00003148 ??_R0?AV_Generic_error_category@std@@@8 dd offset ??_7type_info@@6B@
.data$r:00003148                                         ; DATA XREF: .rdata$r:00003140o
.data$r:00003148                                         ; .rdata$r:std::_Generic_error_category::`RTTI Base Class Descriptor at (0,-1,0,64)'o
.data$r:00003148                                         ; const type_info::`vftable'
.data$r:0000314C                 align 10h
.data$r:00003150 a_?av_generic_e db '.?AV_Generic_error_category@std@@',0
.data$r:00003172                 align 4
.data$r:00003172 _data$r         ends
.data$r:00003172
.rdata$r:00003174 ; ===========================================================================
.rdata$r:00003174
.rdata$r:00003174 ; Segment type: Pure data
.rdata$r:00003174 ; Segment permissions: Read
.rdata$r:00003174 _rdata$r        segment dword public 'DATA' use32
.rdata$r:00003174                 assume cs:_rdata$r
.rdata$r:00003174                 ;org 3174h
.rdata$r:00003174 ; COMDAT (pick any)
.rdata$r:00003174                 public ??_R3_Generic_error_category@std@@8
.rdata$r:00003174 ; std::_Generic_error_category::`RTTI Class Hierarchy Descriptor'
.rdata$r:00003174 ??_R3_Generic_error_category@std@@8 db    0
.rdata$r:00003174                                         ; DATA XREF: .rdata$r:00003144o
.rdata$r:00003174                                         ; .rdata$r:000031A8o
.rdata$r:00003175                 db    0
.rdata$r:00003176                 db    0
.rdata$r:00003177                 db    0
.rdata$r:00003178                 db    0
.rdata$r:00003179                 db    0
.rdata$r:0000317A                 db    0
.rdata$r:0000317B                 db    0
.rdata$r:0000317C                 db    2
.rdata$r:0000317D                 db    0
.rdata$r:0000317E                 db    0
.rdata$r:0000317F                 db    0
.rdata$r:00003180                 dd offset ??_R2_Generic_error_category@std@@8 ; std::_Generic_error_category::`RTTI Base Class Array'
.rdata$r:00003180 _rdata$r        ends
.rdata$r:00003180
.rdata$r:00003184 ; ===========================================================================
.rdata$r:00003184
.rdata$r:00003184 ; Segment type: Pure data
.rdata$r:00003184 ; Segment permissions: Read
.rdata$r:00003184 _rdata$r        segment dword public 'DATA' use32
.rdata$r:00003184                 assume cs:_rdata$r
.rdata$r:00003184                 ;org 3184h
.rdata$r:00003184 ; COMDAT (pick any)
.rdata$r:00003184                 public ??_R2_Generic_error_category@std@@8
.rdata$r:00003184 ; std::_Generic_error_category::`RTTI Base Class Array'
.rdata$r:00003184 ??_R2_Generic_error_category@std@@8 dd offset ??_R1A@?0A@EA@_Generic_error_category@std@@8
.rdata$r:00003184                                         ; DATA XREF: .rdata$r:00003180o
.rdata$r:00003184                                         ; std::_Generic_error_category::`RTTI Base Class Descriptor at (0,-1,0,64)'
.rdata$r:00003188                 dd offset ??_R1A@?0A@EA@error_category@std@@8 ; std::error_category::`RTTI Base Class Descriptor at (0,-1,0,64)'
.rdata$r:0000318C                 db    0
.rdata$r:0000318D                 align 10h
.rdata$r:0000318D _rdata$r        ends
.rdata$r:0000318D
.rdata$r:00003190 ; ===========================================================================
.rdata$r:00003190
.rdata$r:00003190 ; Segment type: Pure data
.rdata$r:00003190 ; Segment permissions: Read
.rdata$r:00003190 _rdata$r        segment dword public 'DATA' use32
.rdata$r:00003190                 assume cs:_rdata$r
.rdata$r:00003190                 ;org 3190h
.rdata$r:00003190 ; COMDAT (pick any)
.rdata$r:00003190                 public ??_R1A@?0A@EA@_Generic_error_category@std@@8
.rdata$r:00003190 ; std::_Generic_error_category::`RTTI Base Class Descriptor at (0, -1, 0, 64)'
.rdata$r:00003190 ??_R1A@?0A@EA@_Generic_error_category@std@@8 dd offset ??_R0?AV_Generic_error_category@std@@@8
.rdata$r:00003190                                         ; DATA XREF: .rdata$r:std::_Generic_error_category::`RTTI Base Class Array'o
.rdata$r:00003190                                         ; .rdata$r:00003200o ...
.rdata$r:00003190                                         ; std::_Generic_error_category `RTTI Type Descriptor'
.rdata$r:00003194                 db    1
.rdata$r:00003195                 db    0
.rdata$r:00003196                 db    0
.rdata$r:00003197                 db    0
.rdata$r:00003198                 db    0
.rdata$r:00003199                 db    0
.rdata$r:0000319A                 db    0
.rdata$r:0000319B                 db    0
.rdata$r:0000319C                 db 0FFh
.rdata$r:0000319D                 db 0FFh
.rdata$r:0000319E                 db 0FFh
.rdata$r:0000319F                 db 0FFh
.rdata$r:000031A0                 db    0
.rdata$r:000031A1                 db    0
.rdata$r:000031A2                 db    0
.rdata$r:000031A3                 db    0
.rdata$r:000031A4                 db  40h ; @
.rdata$r:000031A5                 db    0
.rdata$r:000031A6                 db    0
.rdata$r:000031A7                 db    0
.rdata$r:000031A8                 dd offset ??_R3_Generic_error_category@std@@8 ; std::_Generic_error_category::`RTTI Class Hierarchy Descriptor'
.rdata$r:000031A8 _rdata$r        ends
.rdata$r:000031A8
.rdata$r:000031AC ; ===========================================================================
.rdata$r:000031AC
.rdata$r:000031AC ; Segment type: Pure data
.rdata$r:000031AC ; Segment permissions: Read
.rdata$r:000031AC _rdata$r        segment dword public 'DATA' use32
.rdata$r:000031AC                 assume cs:_rdata$r
.rdata$r:000031AC                 ;org 31ACh
.rdata$r:000031AC ; COMDAT (pick any)
.rdata$r:000031AC                 public ??_R4_Iostream_error_category@std@@6B@
.rdata$r:000031AC ; const std::_Iostream_error_category::`RTTI Complete Object Locator'
.rdata$r:000031AC ??_R4_Iostream_error_category@std@@6B@ db    0
.rdata$r:000031AC                                         ; DATA XREF: .rdata:00002F64o
.rdata$r:000031AD                 db    0
.rdata$r:000031AE                 db    0
.rdata$r:000031AF                 db    0
.rdata$r:000031B0                 db    0
.rdata$r:000031B1                 db    0
.rdata$r:000031B2                 db    0
.rdata$r:000031B3                 db    0
.rdata$r:000031B4                 db    0
.rdata$r:000031B5                 db    0
.rdata$r:000031B6                 db    0
.rdata$r:000031B7                 db    0
.rdata$r:000031B8                 dd offset ??_R0?AV_Iostream_error_category@std@@@8 ; std::_Iostream_error_category `RTTI Type Descriptor'
.rdata$r:000031BC                 dd offset ??_R3_Iostream_error_category@std@@8 ; std::_Iostream_error_category::`RTTI Class Hierarchy Descriptor'
.rdata$r:000031BC _rdata$r        ends
.rdata$r:000031BC
.data$r:000031C0 ; ===========================================================================
.data$r:000031C0
.data$r:000031C0 ; Segment type: Pure data
.data$r:000031C0 ; Segment permissions: Read/Write
.data$r:000031C0 _data$r         segment dword public 'DATA' use32
.data$r:000031C0                 assume cs:_data$r
.data$r:000031C0                 ;org 31C0h
.data$r:000031C0 ; COMDAT (pick any)
.data$r:000031C0                 public ??_R0?AV_Iostream_error_category@std@@@8
.data$r:000031C0 ; class std::_Iostream_error_category `RTTI Type Descriptor'
.data$r:000031C0 ??_R0?AV_Iostream_error_category@std@@@8 dd offset ??_7type_info@@6B@
.data$r:000031C0                                         ; DATA XREF: .rdata$r:000031B8o
.data$r:000031C0                                         ; .rdata$r:std::_Iostream_error_category::`RTTI Base Class Descriptor at (0,-1,0,64)'o
.data$r:000031C0                                         ; const type_info::`vftable'
.data$r:000031C4                 align 8
.data$r:000031C8 a_?av_iostream_ db '.?AV_Iostream_error_category@std@@',0
.data$r:000031EB                 align 4
.data$r:000031EB _data$r         ends
.data$r:000031EB
.rdata$r:000031EC ; ===========================================================================
.rdata$r:000031EC
.rdata$r:000031EC ; Segment type: Pure data
.rdata$r:000031EC ; Segment permissions: Read
.rdata$r:000031EC _rdata$r        segment dword public 'DATA' use32
.rdata$r:000031EC                 assume cs:_rdata$r
.rdata$r:000031EC                 ;org 31ECh
.rdata$r:000031EC ; COMDAT (pick any)
.rdata$r:000031EC                 public ??_R3_Iostream_error_category@std@@8
.rdata$r:000031EC ; std::_Iostream_error_category::`RTTI Class Hierarchy Descriptor'
.rdata$r:000031EC ??_R3_Iostream_error_category@std@@8 db    0
.rdata$r:000031EC                                         ; DATA XREF: .rdata$r:000031BCo
.rdata$r:000031EC                                         ; .rdata$r:00003224o
.rdata$r:000031ED                 db    0
.rdata$r:000031EE                 db    0
.rdata$r:000031EF                 db    0
.rdata$r:000031F0                 db    0
.rdata$r:000031F1                 db    0
.rdata$r:000031F2                 db    0
.rdata$r:000031F3                 db    0
.rdata$r:000031F4                 db    3
.rdata$r:000031F5                 db    0
.rdata$r:000031F6                 db    0
.rdata$r:000031F7                 db    0
.rdata$r:000031F8                 dd offset ??_R2_Iostream_error_category@std@@8 ; std::_Iostream_error_category::`RTTI Base Class Array'
.rdata$r:000031F8 _rdata$r        ends
.rdata$r:000031F8
.rdata$r:000031FC ; ===========================================================================
.rdata$r:000031FC
.rdata$r:000031FC ; Segment type: Pure data
.rdata$r:000031FC ; Segment permissions: Read
.rdata$r:000031FC _rdata$r        segment dword public 'DATA' use32
.rdata$r:000031FC                 assume cs:_rdata$r
.rdata$r:000031FC                 ;org 31FCh
.rdata$r:000031FC ; COMDAT (pick any)
.rdata$r:000031FC                 public ??_R2_Iostream_error_category@std@@8
.rdata$r:000031FC ; std::_Iostream_error_category::`RTTI Base Class Array'
.rdata$r:000031FC ??_R2_Iostream_error_category@std@@8 dd offset ??_R1A@?0A@EA@_Iostream_error_category@std@@8
.rdata$r:000031FC                                         ; DATA XREF: .rdata$r:000031F8o
.rdata$r:000031FC                                         ; std::_Iostream_error_category::`RTTI Base Class Descriptor at (0,-1,0,64)'
.rdata$r:00003200                 dd offset ??_R1A@?0A@EA@_Generic_error_category@std@@8 ; std::_Generic_error_category::`RTTI Base Class Descriptor at (0,-1,0,64)'
.rdata$r:00003204                 dd offset ??_R1A@?0A@EA@error_category@std@@8 ; std::error_category::`RTTI Base Class Descriptor at (0,-1,0,64)'
.rdata$r:00003208                 db    0
.rdata$r:00003209                 align 4
.rdata$r:00003209 _rdata$r        ends
.rdata$r:00003209
.rdata$r:0000320C ; ===========================================================================
.rdata$r:0000320C
.rdata$r:0000320C ; Segment type: Pure data
.rdata$r:0000320C ; Segment permissions: Read
.rdata$r:0000320C _rdata$r        segment dword public 'DATA' use32
.rdata$r:0000320C                 assume cs:_rdata$r
.rdata$r:0000320C                 ;org 320Ch
.rdata$r:0000320C ; COMDAT (pick any)
.rdata$r:0000320C                 public ??_R1A@?0A@EA@_Iostream_error_category@std@@8
.rdata$r:0000320C ; std::_Iostream_error_category::`RTTI Base Class Descriptor at (0, -1, 0, 64)'
.rdata$r:0000320C ??_R1A@?0A@EA@_Iostream_error_category@std@@8 dd offset ??_R0?AV_Iostream_error_category@std@@@8
.rdata$r:0000320C                                         ; DATA XREF: .rdata$r:std::_Iostream_error_category::`RTTI Base Class Array'o
.rdata$r:0000320C                                         ; std::_Iostream_error_category `RTTI Type Descriptor'
.rdata$r:00003210                 db    2
.rdata$r:00003211                 db    0
.rdata$r:00003212                 db    0
.rdata$r:00003213                 db    0
.rdata$r:00003214                 db    0
.rdata$r:00003215                 db    0
.rdata$r:00003216                 db    0
.rdata$r:00003217                 db    0
.rdata$r:00003218                 db 0FFh
.rdata$r:00003219                 db 0FFh
.rdata$r:0000321A                 db 0FFh
.rdata$r:0000321B                 db 0FFh
.rdata$r:0000321C                 db    0
.rdata$r:0000321D                 db    0
.rdata$r:0000321E                 db    0
.rdata$r:0000321F                 db    0
.rdata$r:00003220                 db  40h ; @
.rdata$r:00003221                 db    0
.rdata$r:00003222                 db    0
.rdata$r:00003223                 db    0
.rdata$r:00003224                 dd offset ??_R3_Iostream_error_category@std@@8 ; std::_Iostream_error_category::`RTTI Class Hierarchy Descriptor'
.rdata$r:00003224 _rdata$r        ends
.rdata$r:00003224
.rdata$r:00003228 ; ===========================================================================
.rdata$r:00003228
.rdata$r:00003228 ; Segment type: Pure data
.rdata$r:00003228 ; Segment permissions: Read
.rdata$r:00003228 _rdata$r        segment dword public 'DATA' use32
.rdata$r:00003228                 assume cs:_rdata$r
.rdata$r:00003228                 ;org 3228h
.rdata$r:00003228 ; COMDAT (pick any)
.rdata$r:00003228                 public ??_R4_System_error_category@std@@6B@
.rdata$r:00003228 ; const std::_System_error_category::`RTTI Complete Object Locator'
.rdata$r:00003228 ??_R4_System_error_category@std@@6B@ db    0 ; DATA XREF: .rdata:00002FA4o
.rdata$r:00003229                 db    0
.rdata$r:0000322A                 db    0
.rdata$r:0000322B                 db    0
.rdata$r:0000322C                 db    0
.rdata$r:0000322D                 db    0
.rdata$r:0000322E                 db    0
.rdata$r:0000322F                 db    0
.rdata$r:00003230                 db    0
.rdata$r:00003231                 db    0
.rdata$r:00003232                 db    0
.rdata$r:00003233                 db    0
.rdata$r:00003234                 dd offset ??_R0?AV_System_error_category@std@@@8 ; std::_System_error_category `RTTI Type Descriptor'
.rdata$r:00003238                 dd offset ??_R3_System_error_category@std@@8 ; std::_System_error_category::`RTTI Class Hierarchy Descriptor'
.rdata$r:00003238 _rdata$r        ends
.rdata$r:00003238
.data$r:0000323C ; ===========================================================================
.data$r:0000323C
.data$r:0000323C ; Segment type: Pure data
.data$r:0000323C ; Segment permissions: Read/Write
.data$r:0000323C _data$r         segment dword public 'DATA' use32
.data$r:0000323C                 assume cs:_data$r
.data$r:0000323C                 ;org 323Ch
.data$r:0000323C ; COMDAT (pick any)
.data$r:0000323C                 public ??_R0?AV_System_error_category@std@@@8
.data$r:0000323C ; class std::_System_error_category `RTTI Type Descriptor'
.data$r:0000323C ??_R0?AV_System_error_category@std@@@8 dd offset ??_7type_info@@6B@
.data$r:0000323C                                         ; DATA XREF: .rdata$r:00003234o
.data$r:0000323C                                         ; .rdata$r:std::_System_error_category::`RTTI Base Class Descriptor at (0,-1,0,64)'o
.data$r:0000323C                                         ; const type_info::`vftable'
.data$r:00003240                 db    0
.data$r:00003241                 db    0
.data$r:00003242                 db    0
.data$r:00003243                 db    0
.data$r:00003244                 db  2Eh ; .
.data$r:00003245                 db  3Fh ; ?
.data$r:00003246                 db  41h ; A
.data$r:00003247                 db  56h ; V
.data$r:00003248                 db  5Fh ; _
.data$r:00003249                 db  53h ; S
.data$r:0000324A                 db  79h ; y
.data$r:0000324B                 db  73h ; s
.data$r:0000324C                 db  74h ; t
.data$r:0000324D                 db  65h ; e
.data$r:0000324E                 db  6Dh ; m
.data$r:0000324F                 db  5Fh ; _
.data$r:00003250                 db  65h ; e
.data$r:00003251                 db  72h ; r
.data$r:00003252                 db  72h ; r
.data$r:00003253                 db  6Fh ; o
.data$r:00003254                 db  72h ; r
.data$r:00003255                 db  5Fh ; _
.data$r:00003256                 db  63h ; c
.data$r:00003257                 db  61h ; a
.data$r:00003258                 db  74h ; t
.data$r:00003259                 db  65h ; e
.data$r:0000325A                 db  67h ; g
.data$r:0000325B                 db  6Fh ; o
.data$r:0000325C                 db  72h ; r
.data$r:0000325D                 db  79h ; y
.data$r:0000325E                 db  40h ; @
.data$r:0000325F                 db  73h ; s
.data$r:00003260                 db  74h ; t
.data$r:00003261                 db  64h ; d
.data$r:00003262                 db  40h ; @
.data$r:00003263                 db  40h ; @
.data$r:00003264                 db    0
.data$r:00003265                 align 4
.data$r:00003265 _data$r         ends
.data$r:00003265
.rdata$r:00003268 ; ===========================================================================
.rdata$r:00003268
.rdata$r:00003268 ; Segment type: Pure data
.rdata$r:00003268 ; Segment permissions: Read
.rdata$r:00003268 _rdata$r        segment dword public 'DATA' use32
.rdata$r:00003268                 assume cs:_rdata$r
.rdata$r:00003268                 ;org 3268h
.rdata$r:00003268 ; COMDAT (pick any)
.rdata$r:00003268                 public ??_R3_System_error_category@std@@8
.rdata$r:00003268 ; std::_System_error_category::`RTTI Class Hierarchy Descriptor'
.rdata$r:00003268 ??_R3_System_error_category@std@@8 db    0 ; DATA XREF: .rdata$r:00003238o
.rdata$r:00003268                                         ; .rdata$r:000032A0o
.rdata$r:00003269                 db    0
.rdata$r:0000326A                 db    0
.rdata$r:0000326B                 db    0
.rdata$r:0000326C                 db    0
.rdata$r:0000326D                 db    0
.rdata$r:0000326E                 db    0
.rdata$r:0000326F                 db    0
.rdata$r:00003270                 db    3
.rdata$r:00003271                 db    0
.rdata$r:00003272                 db    0
.rdata$r:00003273                 db    0
.rdata$r:00003274                 dd offset ??_R2_System_error_category@std@@8 ; std::_System_error_category::`RTTI Base Class Array'
.rdata$r:00003274 _rdata$r        ends
.rdata$r:00003274
.rdata$r:00003278 ; ===========================================================================
.rdata$r:00003278
.rdata$r:00003278 ; Segment type: Pure data
.rdata$r:00003278 ; Segment permissions: Read
.rdata$r:00003278 _rdata$r        segment dword public 'DATA' use32
.rdata$r:00003278                 assume cs:_rdata$r
.rdata$r:00003278                 ;org 3278h
.rdata$r:00003278 ; COMDAT (pick any)
.rdata$r:00003278                 public ??_R2_System_error_category@std@@8
.rdata$r:00003278 ; std::_System_error_category::`RTTI Base Class Array'
.rdata$r:00003278 ??_R2_System_error_category@std@@8 dd offset ??_R1A@?0A@EA@_System_error_category@std@@8
.rdata$r:00003278                                         ; DATA XREF: .rdata$r:00003274o
.rdata$r:00003278                                         ; std::_System_error_category::`RTTI Base Class Descriptor at (0,-1,0,64)'
.rdata$r:0000327C                 dd offset ??_R1A@?0A@EA@_Generic_error_category@std@@8 ; std::_Generic_error_category::`RTTI Base Class Descriptor at (0,-1,0,64)'
.rdata$r:00003280                 dd offset ??_R1A@?0A@EA@error_category@std@@8 ; std::error_category::`RTTI Base Class Descriptor at (0,-1,0,64)'
.rdata$r:00003284                 db    0
.rdata$r:00003285                 align 4
.rdata$r:00003285 _rdata$r        ends
.rdata$r:00003285
.rdata$r:00003288 ; ===========================================================================
.rdata$r:00003288
.rdata$r:00003288 ; Segment type: Pure data
.rdata$r:00003288 ; Segment permissions: Read
.rdata$r:00003288 _rdata$r        segment dword public 'DATA' use32
.rdata$r:00003288                 assume cs:_rdata$r
.rdata$r:00003288                 ;org 3288h
.rdata$r:00003288 ; COMDAT (pick any)
.rdata$r:00003288                 public ??_R1A@?0A@EA@_System_error_category@std@@8
.rdata$r:00003288 ; std::_System_error_category::`RTTI Base Class Descriptor at (0, -1, 0, 64)'
.rdata$r:00003288 ??_R1A@?0A@EA@_System_error_category@std@@8 dd offset ??_R0?AV_System_error_category@std@@@8
.rdata$r:00003288                                         ; DATA XREF: .rdata$r:std::_System_error_category::`RTTI Base Class Array'o
.rdata$r:00003288                                         ; std::_System_error_category `RTTI Type Descriptor'
.rdata$r:0000328C                 db    2
.rdata$r:0000328D                 db    0
.rdata$r:0000328E                 db    0
.rdata$r:0000328F                 db    0
.rdata$r:00003290                 db    0
.rdata$r:00003291                 db    0
.rdata$r:00003292                 db    0
.rdata$r:00003293                 db    0
.rdata$r:00003294                 db 0FFh
.rdata$r:00003295                 db 0FFh
.rdata$r:00003296                 db 0FFh
.rdata$r:00003297                 db 0FFh
.rdata$r:00003298                 db    0
.rdata$r:00003299                 db    0
.rdata$r:0000329A                 db    0
.rdata$r:0000329B                 db    0
.rdata$r:0000329C                 db  40h ; @
.rdata$r:0000329D                 db    0
.rdata$r:0000329E                 db    0
.rdata$r:0000329F                 db    0
.rdata$r:000032A0                 dd offset ??_R3_System_error_category@std@@8 ; std::_System_error_category::`RTTI Class Hierarchy Descriptor'
.rdata$r:000032A0 _rdata$r        ends
.rdata$r:000032A0
.CRT$XCU:000032A4 ; ===========================================================================
.CRT$XCU:000032A4
.CRT$XCU:000032A4 ; Segment type: Pure data
.CRT$XCU:000032A4 ; Segment permissions: Read
.CRT$XCU:000032A4 _CRT$XCU        segment dword public 'DATA' use32
.CRT$XCU:000032A4                 assume cs:_CRT$XCU
.CRT$XCU:000032A4                 ;org 32A4h
.CRT$XCU:000032A4 _piecewise_construct$initializer$ dd offset ??__Epiecewise_construct@std@@YAXXZ ; std::`dynamic initializer for 'piecewise_construct''(void)
.CRT$XCU:000032A8 _allocator_arg$initializer$ dd offset ??__Eallocator_arg@std@@YAXXZ ; std::`dynamic initializer for 'allocator_arg''(void)
.CRT$XCU:000032AC _ignore$initializer$ dd offset ??__Eignore@std@@YAXXZ ; std::`dynamic initializer for 'ignore''(void)
.CRT$XCU:000032B0 __Tuple_alloc$initializer$ dd offset ??__E_Tuple_alloc@std@@YAXXZ ; std::`dynamic initializer for '_Tuple_alloc''(void)
.CRT$XCU:000032B0 _CRT$XCU        ends
.CRT$XCU:000032B0
.CRT$XCU:000032B4 ; ===========================================================================
.CRT$XCU:000032B4
.CRT$XCU:000032B4 ; Segment type: Pure data
.CRT$XCU:000032B4 ; Segment permissions: Read
.CRT$XCU:000032B4 _CRT$XCU        segment dword public 'DATA' use32
.CRT$XCU:000032B4                 assume cs:_CRT$XCU
.CRT$XCU:000032B4                 ;org 32B4h
.CRT$XCU:000032B4 ; COMDAT (pick associative to section at 2FC8)
.CRT$XCU:000032B4 ; public: static void (__cdecl *std::_Error_objects<int>::_Generic_object$initializer$)(void)
.CRT$XCU:000032B4 ?_Generic_object$initializer$@?$_Error_objects@H@std@@2P6AXXZA dd offset ??__E?_Generic_object@?$_Error_objects@H@std@@2V_Generic_error_category@2@A@@YAXXZ ; `dynamic initializer for 'std::_Generic_error_category std::_Error_objects<int>::_Generic_object''(void)
.CRT$XCU:000032B4 _CRT$XCU        ends
.CRT$XCU:000032B4
.CRT$XCU:000032B8 ; ===========================================================================
.CRT$XCU:000032B8
.CRT$XCU:000032B8 ; Segment type: Pure data
.CRT$XCU:000032B8 ; Segment permissions: Read
.CRT$XCU:000032B8 _CRT$XCU        segment dword public 'DATA' use32
.CRT$XCU:000032B8                 assume cs:_CRT$XCU
.CRT$XCU:000032B8                 ;org 32B8h
.CRT$XCU:000032B8 ; COMDAT (pick associative to section at 2FCC)
.CRT$XCU:000032B8 ; public: static void (__cdecl *std::_Error_objects<int>::_Iostream_object$initializer$)(void)
.CRT$XCU:000032B8 ?_Iostream_object$initializer$@?$_Error_objects@H@std@@2P6AXXZA dd offset ??__E?_Iostream_object@?$_Error_objects@H@std@@2V_Iostream_error_category@2@A@@YAXXZ ; `dynamic initializer for 'std::_Iostream_error_category std::_Error_objects<int>::_Iostream_object''(void)
.CRT$XCU:000032B8 _CRT$XCU        ends
.CRT$XCU:000032B8
.CRT$XCU:000032BC ; ===========================================================================
.CRT$XCU:000032BC
.CRT$XCU:000032BC ; Segment type: Pure data
.CRT$XCU:000032BC ; Segment permissions: Read
.CRT$XCU:000032BC _CRT$XCU        segment dword public 'DATA' use32
.CRT$XCU:000032BC                 assume cs:_CRT$XCU
.CRT$XCU:000032BC                 ;org 32BCh
.CRT$XCU:000032BC ; COMDAT (pick associative to section at 2FD0)
.CRT$XCU:000032BC ; public: static void (__cdecl *std::_Error_objects<int>::_System_object$initializer$)(void)
.CRT$XCU:000032BC ?_System_object$initializer$@?$_Error_objects@H@std@@2P6AXXZA dd offset ??__E?_System_object@?$_Error_objects@H@std@@2V_System_error_category@2@A@@YAXXZ ; `dynamic initializer for 'std::_System_error_category std::_Error_objects<int>::_System_object''(void)
.CRT$XCU:000032BC _CRT$XCU        ends
.CRT$XCU:000032BC
.CRT$XCU:000032C0 ; ===========================================================================
.CRT$XCU:000032C0
.CRT$XCU:000032C0 ; Segment type: Pure data
.CRT$XCU:000032C0 ; Segment permissions: Read
.CRT$XCU:000032C0 _CRT$XCU        segment dword public 'DATA' use32
.CRT$XCU:000032C0                 assume cs:_CRT$XCU
.CRT$XCU:000032C0                 ;org 32C0h
.CRT$XCU:000032C0 ; COMDAT (pick associative to section at 2FD4)
.CRT$XCU:000032C0 ; public: static void (__cdecl *std::num_put<char, class std::back_insert_iterator<class std::basic_string<char, struct std::char_traits<char>, class std::allocator<char>>>>::id$initializer$)(void)
.CRT$XCU:000032C0 ?id$initializer$@?$num_put@DV?$back_insert_iterator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@std@@2P6AXXZA dd offset ??__E?id@?$num_put@DV?$back_insert_iterator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@std@@2V0locale@2@A@@YAXXZ ; `dynamic initializer for 'std::locale::id std::num_put<char,std::back_insert_iterator<std::basic_string<char,std::char_traits<char>,std::allocator<char>>>>::id''(void)
.CRT$XCU:000032C0 _CRT$XCU        ends
.CRT$XCU:000032C0
.CRT$XCU:000032C4 ; ===========================================================================
.CRT$XCU:000032C4
.CRT$XCU:000032C4 ; Segment type: Pure data
.CRT$XCU:000032C4 ; Segment permissions: Read
.CRT$XCU:000032C4 _CRT$XCU        segment dword public 'DATA' use32
.CRT$XCU:000032C4                 assume cs:_CRT$XCU
.CRT$XCU:000032C4                 ;org 32C4h
.CRT$XCU:000032C4 ; COMDAT (pick associative to section at 2FD8)
.CRT$XCU:000032C4 ; public: static void (__cdecl *std::num_put<wchar_t, class std::back_insert_iterator<class std::basic_string<wchar_t, struct std::char_traits<wchar_t>, class std::allocator<wchar_t>>>>::id$initializer$)(void)
.CRT$XCU:000032C4 ?id$initializer$@?$num_put@_WV?$back_insert_iterator@V?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@@std@@@std@@2P6AXXZA dd offset ??__E?id@?$num_put@_WV?$back_insert_iterator@V?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@@std@@@std@@2V0locale@2@A@@YAXXZ ; `dynamic initializer for 'std::locale::id std::num_put<wchar_t,std::back_insert_iterator<std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>>>>::id''(void)
.CRT$XCU:000032C4 _CRT$XCU        ends
.CRT$XCU:000032C4
.CRT$XCU:000032C8 ; ===========================================================================
.CRT$XCU:000032C8
.CRT$XCU:000032C8 ; Segment type: Pure data
.CRT$XCU:000032C8 ; Segment permissions: Read
.CRT$XCU:000032C8 _CRT$XCU        segment dword public 'DATA' use32
.CRT$XCU:000032C8                 assume cs:_CRT$XCU
.CRT$XCU:000032C8                 ;org 32C8h
.CRT$XCU:000032C8 ; COMDAT (pick associative to section at 306C)
.CRT$XCU:000032C8 ; public: static void (__cdecl *std::numpunct<char>::id$initializer$)(void)
.CRT$XCU:000032C8 ?id$initializer$@?$numpunct@D@std@@2P6AXXZA dd offset ??__E?id@?$numpunct@D@std@@2V0locale@2@A@@YAXXZ ; `dynamic initializer for 'std::locale::id std::numpunct<char>::id''(void)
.CRT$XCU:000032C8 _CRT$XCU        ends
.CRT$XCU:000032C8
.CRT$XCU:000032CC ; ===========================================================================
.CRT$XCU:000032CC
.CRT$XCU:000032CC ; Segment type: Pure data
.CRT$XCU:000032CC ; Segment permissions: Read
.CRT$XCU:000032CC _CRT$XCU        segment dword public 'DATA' use32
.CRT$XCU:000032CC                 assume cs:_CRT$XCU
.CRT$XCU:000032CC                 ;org 32CCh
.CRT$XCU:000032CC ; COMDAT (pick associative to section at 3070)
.CRT$XCU:000032CC ; public: static void (__cdecl *std::numpunct<wchar_t>::id$initializer$)(void)
.CRT$XCU:000032CC ?id$initializer$@?$numpunct@_W@std@@2P6AXXZA dd offset ??__E?id@?$numpunct@_W@std@@2V0locale@2@A@@YAXXZ ; `dynamic initializer for 'std::locale::id std::numpunct<wchar_t>::id''(void)
.CRT$XCU:000032CC _CRT$XCU        ends
.CRT$XCU:000032CC
UNDEF:000032D0 ; ===========================================================================
UNDEF:000032D0
UNDEF:000032D0 ; Segment type: Externs
UNDEF:000032D0 ; UNDEF
UNDEF:000032D0                 extrn __purecall:near   ; DATA XREF: .rdata:00002F1Co
UNDEF:000032D0                                         ; .rdata:00002F20o
UNDEF:000032D4 ; void *__cdecl operator new(unsigned int)
UNDEF:000032D4                 extrn ??2@YAPAXI@Z:near ; CODE XREF: std::_Allocate<char>(uint,char *)+1Dp
UNDEF:000032D4                                         ; std::_Allocate<std::_Container_proxy>(uint,std::_Container_proxy *)+23p
UNDEF:000032D8 ; void __cdecl operator delete(void *)
UNDEF:000032D8                 extrn ??3@YAXPAX@Z:near ; CODE XREF: std::_Generic_error_category::`scalar deleting destructor'(uint)+1Bp
UNDEF:000032D8                                         ; std::_Iostream_error_category::`scalar deleting destructor'(uint)+1Bp ...
UNDEF:000032DC ; int __cdecl atexit(void (__cdecl *)())
UNDEF:000032DC                 extrn _atexit:near      ; CODE XREF: `dynamic initializer for 'std::_Generic_error_category std::_Error_objects<int>::_Generic_object''(void)+12p
UNDEF:000032DC                                         ; `dynamic initializer for 'std::_Iostream_error_category std::_Error_objects<int>::_Iostream_object''(void)+12p ...
UNDEF:000032E0                 extrn ___report_rangecheckfailure:near
UNDEF:000032E0                                         ; CODE XREF: AnsiCharPanel::insertChar(uchar):loc_DE1p
UNDEF:000032E4 ; void *__cdecl memcpy(void *Dst, const void *Src, size_t Size)
UNDEF:000032E4                 extrn _memcpy:near      ; CODE XREF: std::char_traits<char>::copy(char *,char const *,uint)+1Ep
UNDEF:000032E8 ; size_t __cdecl strlen(const char *Str)
UNDEF:000032E8                 extrn _strlen:near      ; CODE XREF: AnsiCharPanel::insertChar(uchar)+168p
UNDEF:000032E8                                         ; std::char_traits<char>::length(char const *)+1Bp
UNDEF:000032EC ; void *__cdecl memmove(void *Dst, const void *Src, size_t Size)
UNDEF:000032EC                 extrn _memmove:near     ; CODE XREF: std::char_traits<char>::move(char *,char const *,uint)+1Ep
UNDEF:000032F0 ; LRESULT __stdcall SendMessageW(HWND hWnd, UINT Msg, WPARAM wParam, LPARAM lParam)
UNDEF:000032F0                 extrn __imp__SendMessageW@16:near
UNDEF:000032F0                                         ; CODE XREF: AnsiCharPanel::run_dlgProc(uint,uint,long)+11Fp
UNDEF:000032F0                                         ; DATA XREF: AnsiCharPanel::run_dlgProc(uint,uint,long)+11Fr
UNDEF:000032F4 ; BOOL __stdcall MoveWindow(HWND hWnd, int X, int Y, int nWidth, int nHeight, BOOL bRepaint)
UNDEF:000032F4                 extrn __imp__MoveWindow@24:near
UNDEF:000032F4                                         ; CODE XREF: AnsiCharPanel::run_dlgProc(uint,uint,long)+18Dp
UNDEF:000032F4                                         ; DATA XREF: AnsiCharPanel::run_dlgProc(uint,uint,long)+18Dr
UNDEF:000032F8 ; HWND __stdcall SetFocus(HWND hWnd)
UNDEF:000032F8                 extrn __imp__SetFocus@4:near
UNDEF:000032F8                                         ; CODE XREF: Window::getFocus(void)+Ep
UNDEF:000032F8                                         ; DATA XREF: Window::getFocus(void)+Er
UNDEF:000032FC ; int __stdcall MultiByteToWideChar(UINT CodePage, DWORD dwFlags, LPCSTR lpMultiByteStr, int cbMultiByte, LPWSTR lpWideCharStr, int cchWideChar)
UNDEF:000032FC                 extrn __imp__MultiByteToWideChar@24:near
UNDEF:000032FC                                         ; CODE XREF: AnsiCharPanel::insertChar(uchar)+AAp
UNDEF:000032FC                                         ; AnsiCharPanel::insertChar(uchar)+113p
UNDEF:000032FC                                         ; DATA XREF: ...
UNDEF:00003300 ; int __stdcall WideCharToMultiByte(UINT CodePage, DWORD dwFlags, LPCWSTR lpWideCharStr, int cchWideChar, LPSTR lpMultiByteStr, int cbMultiByte, LPCSTR lpDefaultChar, LPBOOL lpUsedDefaultChar)
UNDEF:00003300                 extrn __imp__WideCharToMultiByte@32:near
UNDEF:00003300                                         ; CODE XREF: AnsiCharPanel::insertChar(uchar)+C7p
UNDEF:00003300                                         ; AnsiCharPanel::insertChar(uchar)+130p
UNDEF:00003300                                         ; DATA XREF: ...
UNDEF:00003304 ; _DWORD __thiscall std::_Lockit::_Lockit(std::_Lockit *__hidden this, int)
UNDEF:00003304                 extrn ??0_Lockit@std@@QAE@H@Z:near
UNDEF:00003304                                         ; CODE XREF: std::_Container_base12::_Orphan_all(void)+35p
UNDEF:00003308 ; _DWORD __thiscall std::_Lockit::~_Lockit(std::_Lockit *__hidden this)
UNDEF:00003308                 extrn ??1_Lockit@std@@QAE@XZ:near
UNDEF:00003308                                         ; CODE XREF: std::_Container_base12::_Orphan_all(void)+86p
UNDEF:00003308                                         ; __unwindfunclet$?_Orphan_all@_Container_base12@std@@QAEXXZ$0+3j
UNDEF:0000330C                 extrn __hypot:near      ; CODE XREF: _hypot+1Dp
UNDEF:00003310 ; void __cdecl std::_Debug_message(const wchar_t *, const wchar_t *, unsigned int)
UNDEF:00003310                 extrn ?_Debug_message@std@@YAXPB_W0I@Z:near
UNDEF:00003310                                         ; CODE XREF: std::_Debug_pointer<char>(char const *,wchar_t const *,uint)+16p
UNDEF:00003314 ; void __cdecl std::_Xbad_alloc()
UNDEF:00003314                 extrn ?_Xbad_alloc@std@@YAXXZ:near
UNDEF:00003314                                         ; CODE XREF: std::_Allocate<char>(uint,char *):loc_1156p
UNDEF:00003314                                         ; std::_Allocate<std::_Container_proxy>(uint,std::_Container_proxy *):loc_1198p
UNDEF:00003318 ; void __cdecl std::_Xlength_error(const char *)
UNDEF:00003318                 extrn ?_Xlength_error@std@@YAXPBD@Z:near
UNDEF:00003318                                         ; CODE XREF: std::basic_string<char,std::char_traits<char>,std::allocator<char>>::_Xlen(void)+Cp
UNDEF:0000331C ; void __cdecl std::_Xout_of_range(const char *)
UNDEF:0000331C                 extrn ?_Xout_of_range@std@@YAXPBD@Z:near
UNDEF:0000331C                                         ; CODE XREF: std::basic_string<char,std::char_traits<char>,std::allocator<char>>::_Xran(void)+Cp
UNDEF:00003320 ; public: virtual void * __thiscall std::error_category::`vector deleting destructor'(unsigned int)
UNDEF:00003320                 extrn ??_Eerror_category@std@@UAEPAXI@Z:near ; weak
UNDEF:00003320                                         ; DATA XREF: .rdata:const std::error_category::`vftable'o
UNDEF:00003324 ; const char *__cdecl std::_Syserror_map(int)
UNDEF:00003324                 extrn ?_Syserror_map@std@@YAPBDH@Z:near
UNDEF:00003324                                         ; CODE XREF: std::_System_error_category::default_error_condition(int)+Bp
UNDEF:00003324                                         ; std::_Generic_error_category::message(int)+33p
UNDEF:00003328 ; const char *__cdecl std::_Winerror_map(int)
UNDEF:00003328                 extrn ?_Winerror_map@std@@YAPBDH@Z:near
UNDEF:00003328                                         ; CODE XREF: std::_System_error_category::message(int)+33p
UNDEF:0000332C ; public: virtual void * __thiscall std::_Generic_error_category::`vector deleting destructor'(unsigned int)
UNDEF:0000332C                 extrn ??_E_Generic_error_category@std@@UAEPAXI@Z:near ; weak
UNDEF:0000332C                                         ; DATA XREF: .rdata:const std::_Generic_error_category::`vftable'o
UNDEF:00003330 ; public: virtual void * __thiscall std::_Iostream_error_category::`vector deleting destructor'(unsigned int)
UNDEF:00003330                 extrn ??_E_Iostream_error_category@std@@UAEPAXI@Z:near ; weak
UNDEF:00003330                                         ; DATA XREF: .rdata:const std::_Iostream_error_category::`vftable'o
UNDEF:00003334 ; public: virtual void * __thiscall std::_System_error_category::`vector deleting destructor'(unsigned int)
UNDEF:00003334                 extrn ??_E_System_error_category@std@@UAEPAXI@Z:near ; weak
UNDEF:00003334                                         ; DATA XREF: .rdata:const std::_System_error_category::`vftable'o
UNDEF:00003338 ; void __thiscall ListView::setValues(ListView *__hidden this, int)
UNDEF:00003338                 extrn ?setValues@ListView@@QAEXH@Z:near
UNDEF:00003338                                         ; CODE XREF: AnsiCharPanel::run_dlgProc(uint,uint,long)+83p
UNDEF:0000333C ; void __thiscall ListView::resetValues(ListView *__hidden this, int)
UNDEF:0000333C                 extrn ?resetValues@ListView@@QAEXH@Z:near
UNDEF:0000333C                                         ; CODE XREF: AnsiCharPanel::switchEncoding(void)+2Ap
UNDEF:00003340 ; __fastcall __security_check_cookie(x)
UNDEF:00003340                 extrn @__security_check_cookie@4:near
UNDEF:00003340                                         ; CODE XREF: AnsiCharPanel::insertChar(uchar)+1A5p
UNDEF:00003340                                         ; __ehhandler$??$construct@PADAAPAD@?$allocator@D@std@@QAEXPAPADAAPAD@Z+Cp ...
UNDEF:00003344 ; __stdcall _CxxThrowException(x, x)
UNDEF:00003344                 extrn __CxxThrowException@8:near
UNDEF:00003344                                         ; CODE XREF: __catch$?_Copy@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEXII@Z$1+10p
UNDEF:00003348                 extrn ___CxxFrameHandler3:near
UNDEF:00003348                                         ; CODE XREF: __ehhandler$??$construct@PADAAPAD@?$allocator@D@std@@QAEXPAPADAAPAD@Z+16j
UNDEF:00003348                                         ; __ehhandler$??$construct@U_Container_proxy@std@@U12@@?$allocator@U_Container_proxy@std@@@std@@QAEXPAU_Container_proxy@1@$$QAU21@@Z+16j ...
UNDEF:0000334C ; const type_info::`vftable'
UNDEF:0000334C                 extrn ??_7type_info@@6B@:near
UNDEF:0000334C                                         ; DATA XREF: .data$r:std::error_category `RTTI Type Descriptor'o
UNDEF:0000334C                                         ; .data$r:std::_Generic_error_category `RTTI Type Descriptor'o ...
UNDEF:00003350                 extrn ___security_cookie:near
UNDEF:00003350                                         ; DATA XREF: AnsiCharPanel::insertChar(uchar)+6r
UNDEF:00003350                                         ; std::allocator<char>::construct<char *,char * &>(char * *,char * &)+14r ...
UNDEF:00003354                 extrn __fltused:near
UNDEF:00003354
UNDEF:00003354
UNDEF:00003354                 end