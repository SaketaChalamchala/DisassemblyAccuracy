.text$mn:00000000 ;
.text$mn:00000000 ; +-------------------------------------------------------------------------+
.text$mn:00000000 ; |   This file has been generated by The Interactive Disassembler (IDA)    |
.text$mn:00000000 ; |           Copyright (c) 2015 Hex-Rays, <support@hex-rays.com>           |
.text$mn:00000000 ; |                      License info: 48-3677-7074-51                      |
.text$mn:00000000 ; |             Michalis Polychronakis, Stony Brook University              |
.text$mn:00000000 ; +-------------------------------------------------------------------------+
.text$mn:00000000 ;
.text$mn:00000000 ; Input MD5   : 1E2083DAB830270EA1FAF7A6C426EB5C
.text$mn:00000000 ; Input CRC32 : 92DCCBE1
.text$mn:00000000
.text$mn:00000000 ; File Name   : C:\workspace\notepad-plus-plus-6.7.9.2\PowerEditor\visual.net\Unicode Debug\lesDlgs.obj
.text$mn:00000000 ; Format      : COFF (X386MAGIC)
.text$mn:00000000 ; includelib "uuid.lib"
.text$mn:00000000 ; includelib "libcpmtd"
.text$mn:00000000 ; must resolve: ?_Generic_object@?$_Error_objects@H@std@@2V_Generic_error_category@2@A
.text$mn:00000000 ; must resolve: ?_Iostream_object@?$_Error_objects@H@std@@2V_Iostream_error_category@2@A
.text$mn:00000000 ; must resolve: ?_System_object@?$_Error_objects@H@std@@2V_System_error_category@2@A
.text$mn:00000000 ; must resolve: ?id@?$num_put@DV?$back_insert_iterator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@std@@2V0locale@2@A
.text$mn:00000000 ; must resolve: ?id@?$num_put@_WV?$back_insert_iterator@V?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@@std@@@std@@2V0locale@2@A
.text$mn:00000000 ; must resolve: ?id@?$numpunct@D@std@@2V0locale@2@A
.text$mn:00000000 ; must resolve: ?id@?$numpunct@_W@std@@2V0locale@2@A
.text$mn:00000000 ; includelib "LIBCMTD"
.text$mn:00000000 ; includelib "OLDNAMES"
.text$mn:00000000
.text$mn:00000000                 include uni.inc ; see unicode subdir of ida for info on unicode
.text$mn:00000000
.text$mn:00000000                 .686p
.text$mn:00000000                 .mmx
.text$mn:00000000                 .model flat
.text$mn:00000000
.text$mn:00000000 ; ===========================================================================
.text$mn:00000000
.text$mn:00000000 ; Segment type: Pure code
.text$mn:00000000 ; Segment permissions: Read/Execute
.text$mn:00000000 _text$mn        segment para public 'CODE' use32
.text$mn:00000000                 assume cs:_text$mn
.text$mn:00000000                 assume es:nothing, ss:nothing, ds:_xdata$x, fs:nothing, gs:nothing
.text$mn:00000000
.text$mn:00000000 ; =============== S U B R O U T I N E =======================================
.text$mn:00000000
.text$mn:00000000 ; Attributes: bp-based frame
.text$mn:00000000
.text$mn:00000000 ; void __thiscall ValueDlg::init(ValueDlg *this, HINSTANCE, HWND, int, const wchar_t *)
.text$mn:00000000                 public ?init@ValueDlg@@QAEXPAUHINSTANCE__@@PAUHWND__@@HPB_W@Z
.text$mn:00000000 ?init@ValueDlg@@QAEXPAUHINSTANCE__@@PAUHWND__@@HPB_W@Z proc near
.text$mn:00000000
.text$mn:00000000 var_4           = dword ptr -4
.text$mn:00000000 arg_0           = dword ptr  8
.text$mn:00000000 arg_4           = dword ptr  0Ch
.text$mn:00000000 arg_8           = dword ptr  10h
.text$mn:00000000 Str             = dword ptr  14h
.text$mn:00000000
.text$mn:00000000                 push    ebp
.text$mn:00000001                 mov     ebp, esp
.text$mn:00000003                 push    ecx
.text$mn:00000004                 mov     [ebp+var_4], ecx
.text$mn:00000007                 mov     eax, [ebp+arg_4]
.text$mn:0000000A                 push    eax             ; HWND
.text$mn:0000000B                 mov     ecx, [ebp+arg_0]
.text$mn:0000000E                 push    ecx             ; HINSTANCE
.text$mn:0000000F                 mov     ecx, [ebp+var_4] ; this
.text$mn:00000012                 call    ?init@Window@@UAEXPAUHINSTANCE__@@PAUHWND__@@@Z ; Window::init(HINSTANCE__ *,HWND__ *)
.text$mn:00000017                 mov     edx, [ebp+var_4]
.text$mn:0000001A                 mov     eax, [ebp+arg_8]
.text$mn:0000001D                 mov     [edx+24h], eax
.text$mn:00000020                 mov     ecx, [ebp+Str]
.text$mn:00000023                 push    ecx             ; Str
.text$mn:00000024                 mov     ecx, [ebp+var_4]
.text$mn:00000027                 add     ecx, 28h ; '('
.text$mn:0000002A                 call    ??4?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QAEAAV01@PB_W@Z ; std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>>::operator=(wchar_t const *)
.text$mn:0000002F                 mov     esp, ebp
.text$mn:00000031                 pop     ebp
.text$mn:00000032                 retn    10h
.text$mn:00000032 ?init@ValueDlg@@QAEXPAUHINSTANCE__@@PAUHWND__@@HPB_W@Z endp
.text$mn:00000032
.text$mn:00000032 ; ---------------------------------------------------------------------------
.text$mn:00000035                 align 10h
.text$mn:00000040
.text$mn:00000040 ; =============== S U B R O U T I N E =======================================
.text$mn:00000040
.text$mn:00000040 ; Attributes: bp-based frame
.text$mn:00000040
.text$mn:00000040 ; int __thiscall ValueDlg::doDialog(ValueDlg *this, struct tagPOINT, bool)
.text$mn:00000040                 public ?doDialog@ValueDlg@@QAEHUtagPOINT@@_N@Z
.text$mn:00000040 ?doDialog@ValueDlg@@QAEHUtagPOINT@@_N@Z proc near
.text$mn:00000040
.text$mn:00000040 var_10          = dword ptr -10h
.text$mn:00000040 hMem            = dword ptr -0Ch
.text$mn:00000040 hDialogTemplate = dword ptr -8
.text$mn:00000040 dwInitParam     = dword ptr -4
.text$mn:00000040 arg_0           = tagPOINT ptr  8
.text$mn:00000040 arg_8           = byte ptr  10h
.text$mn:00000040
.text$mn:00000040                 push    ebp
.text$mn:00000041                 mov     ebp, esp
.text$mn:00000043                 sub     esp, 10h
.text$mn:00000046                 mov     [ebp+dwInitParam], ecx
.text$mn:00000049                 mov     eax, [ebp+dwInitParam]
.text$mn:0000004C                 mov     ecx, [ebp+arg_0.x]
.text$mn:0000004F                 mov     [eax+44h], ecx
.text$mn:00000052                 mov     edx, [ebp+arg_0.y]
.text$mn:00000055                 mov     [eax+48h], edx
.text$mn:00000058                 movzx   eax, [ebp+arg_8]
.text$mn:0000005C                 test    eax, eax
.text$mn:0000005E                 jz      short loc_AE
.text$mn:00000060                 mov     [ebp+hDialogTemplate], 0
.text$mn:00000067                 lea     ecx, [ebp+hDialogTemplate]
.text$mn:0000006A                 push    ecx             ; struct DLGTEMPLATE **
.text$mn:0000006B                 push    960h            ; int
.text$mn:00000070                 mov     ecx, [ebp+dwInitParam] ; this
.text$mn:00000073                 call    ?makeRTLResource@StaticDialog@@IAEPAXHPAPAUDLGTEMPLATE@@@Z ; StaticDialog::makeRTLResource(int,DLGTEMPLATE * *)
.text$mn:00000078                 mov     [ebp+hMem], eax
.text$mn:0000007B                 mov     edx, [ebp+dwInitParam]
.text$mn:0000007E                 push    edx             ; dwInitParam
.text$mn:0000007F                 push    offset ?dlgProc@StaticDialog@@KGHPAUHWND__@@IIJ@Z ; lpDialogFunc
.text$mn:00000084                 mov     eax, [ebp+dwInitParam]
.text$mn:00000087                 mov     ecx, [eax+8]
.text$mn:0000008A                 push    ecx             ; hWndParent
.text$mn:0000008B                 mov     edx, [ebp+hDialogTemplate]
.text$mn:0000008E                 push    edx             ; hDialogTemplate
.text$mn:0000008F                 mov     eax, [ebp+dwInitParam]
.text$mn:00000092                 mov     ecx, [eax+4]
.text$mn:00000095                 push    ecx             ; hInstance
.text$mn:00000096                 call    dword ptr ds:__imp__DialogBoxIndirectParamW@20 ; DialogBoxIndirectParamW(x,x,x,x,x)
.text$mn:0000009C                 mov     [ebp+var_10], eax
.text$mn:0000009F                 mov     edx, [ebp+hMem]
.text$mn:000000A2                 push    edx             ; hMem
.text$mn:000000A3                 call    dword ptr ds:__imp__GlobalFree@4 ; GlobalFree(x)
.text$mn:000000A9                 mov     eax, [ebp+var_10]
.text$mn:000000AC                 jmp     short loc_D0
.text$mn:000000AE ; ---------------------------------------------------------------------------
.text$mn:000000AE
.text$mn:000000AE loc_AE:                                 ; CODE XREF: ValueDlg::doDialog(tagPOINT,bool)+1Ej
.text$mn:000000AE                 mov     eax, [ebp+dwInitParam]
.text$mn:000000B1                 push    eax             ; dwInitParam
.text$mn:000000B2                 push    offset ?dlgProc@StaticDialog@@KGHPAUHWND__@@IIJ@Z ; lpDialogFunc
.text$mn:000000B7                 mov     ecx, [ebp+dwInitParam]
.text$mn:000000BA                 mov     edx, [ecx+8]
.text$mn:000000BD                 push    edx             ; hWndParent
.text$mn:000000BE                 push    (offset loc_95C+4) ; lpTemplateName
.text$mn:000000C3                 mov     eax, [ebp+dwInitParam]
.text$mn:000000C6                 mov     ecx, [eax+4]
.text$mn:000000C9                 push    ecx             ; hInstance
.text$mn:000000CA                 call    dword ptr ds:__imp__DialogBoxParamW@20 ; DialogBoxParamW(x,x,x,x,x)
.text$mn:000000D0
.text$mn:000000D0 loc_D0:                                 ; CODE XREF: ValueDlg::doDialog(tagPOINT,bool)+6Cj
.text$mn:000000D0                 mov     esp, ebp
.text$mn:000000D2                 pop     ebp
.text$mn:000000D3                 retn    0Ch
.text$mn:000000D3 ?doDialog@ValueDlg@@QAEHUtagPOINT@@_N@Z endp
.text$mn:000000D3
.text$mn:000000D3 ; ---------------------------------------------------------------------------
.text$mn:000000D6                 align 10h
.text$mn:000000E0
.text$mn:000000E0 ; =============== S U B R O U T I N E =======================================
.text$mn:000000E0
.text$mn:000000E0 ; Attributes: bp-based frame
.text$mn:000000E0
.text$mn:000000E0 ; int __thiscall ValueDlg::reSizeValueBox(ValueDlg *__hidden this)
.text$mn:000000E0                 public ?reSizeValueBox@ValueDlg@@QAEHXZ
.text$mn:000000E0 ?reSizeValueBox@ValueDlg@@QAEHXZ proc near
.text$mn:000000E0                                         ; CODE XREF: ValueDlg::run_dlgProc(uint,uint,long)+7Ep
.text$mn:000000E0
.text$mn:000000E0 var_34          = dword ptr -34h
.text$mn:000000E0 nHeight         = dword ptr -30h
.text$mn:000000E0 Point           = tagPOINT ptr -2Ch
.text$mn:000000E0 hWnd            = dword ptr -24h
.text$mn:000000E0 var_20          = dword ptr -20h
.text$mn:000000E0 var_1C          = dword ptr -1Ch
.text$mn:000000E0 var_18          = dword ptr -18h
.text$mn:000000E0 Rect            = tagRECT ptr -14h
.text$mn:000000E0 var_4           = dword ptr -4
.text$mn:000000E0
.text$mn:000000E0                 push    ebp
.text$mn:000000E1                 mov     ebp, esp
.text$mn:000000E3                 sub     esp, 34h
.text$mn:000000E6                 mov     eax, dword ptr ds:___security_cookie
.text$mn:000000EB                 xor     eax, ebp
.text$mn:000000ED                 mov     [ebp+var_4], eax
.text$mn:000000F0                 mov     [ebp+var_18], ecx
.text$mn:000000F3                 mov     eax, [ebp+var_18]
.text$mn:000000F6                 cmp     dword ptr [eax+20h], 2
.text$mn:000000FA                 jnz     short loc_103
.text$mn:000000FC                 xor     eax, eax
.text$mn:000000FE                 jmp     loc_196
.text$mn:00000103 ; ---------------------------------------------------------------------------
.text$mn:00000103
.text$mn:00000103 loc_103:                                ; CODE XREF: ValueDlg::reSizeValueBox(void)+1Aj
.text$mn:00000103                 push    962h            ; nIDDlgItem
.text$mn:00000108                 mov     ecx, [ebp+var_18]
.text$mn:0000010B                 mov     edx, [ecx+0Ch]
.text$mn:0000010E                 push    edx             ; hDlg
.text$mn:0000010F                 call    dword ptr ds:__imp__GetDlgItem@8 ; GetDlgItem(x,x)
.text$mn:00000115                 mov     [ebp+hWnd], eax
.text$mn:00000118                 lea     eax, [ebp+Rect]
.text$mn:0000011B                 push    eax             ; lpRect
.text$mn:0000011C                 mov     ecx, [ebp+hWnd]
.text$mn:0000011F                 push    ecx             ; hWnd
.text$mn:00000120                 call    dword ptr ds:__imp__GetWindowRect@8 ; GetWindowRect(x,x)
.text$mn:00000126                 mov     edx, [ebp+Rect.right]
.text$mn:00000129                 sub     edx, [ebp+Rect.left]
.text$mn:0000012C                 mov     [ebp+var_20], edx
.text$mn:0000012F                 mov     eax, [ebp+Rect.bottom]
.text$mn:00000132                 sub     eax, [ebp+Rect.top]
.text$mn:00000135                 mov     [ebp+nHeight], eax
.text$mn:00000138                 mov     ecx, [ebp+Rect.left]
.text$mn:0000013B                 mov     [ebp+Point.x], ecx
.text$mn:0000013E                 mov     edx, [ebp+Rect.top]
.text$mn:00000141                 mov     [ebp+Point.y], edx
.text$mn:00000144                 lea     eax, [ebp+Point]
.text$mn:00000147                 push    eax             ; lpPoint
.text$mn:00000148                 mov     ecx, [ebp+var_18]
.text$mn:0000014B                 mov     edx, [ecx+0Ch]
.text$mn:0000014E                 push    edx             ; hWnd
.text$mn:0000014F                 call    dword ptr ds:__imp__ScreenToClient@8 ; ScreenToClient(x,x)
.text$mn:00000155                 mov     eax, [ebp+var_20]
.text$mn:00000158                 cdq
.text$mn:00000159                 and     edx, 3
.text$mn:0000015C                 add     eax, edx
.text$mn:0000015E                 sar     eax, 2
.text$mn:00000161                 mov     [ebp+var_34], eax
.text$mn:00000164                 mov     eax, [ebp+var_18]
.text$mn:00000167                 mov     ecx, [eax+20h]
.text$mn:0000016A                 sub     ecx, 2
.text$mn:0000016D                 imul    ecx, [ebp+var_34]
.text$mn:00000171                 mov     [ebp+var_1C], ecx
.text$mn:00000174                 push    0               ; bRepaint
.text$mn:00000176                 mov     edx, [ebp+nHeight]
.text$mn:00000179                 push    edx             ; nHeight
.text$mn:0000017A                 mov     eax, [ebp+var_20]
.text$mn:0000017D                 add     eax, [ebp+var_1C]
.text$mn:00000180                 push    eax             ; nWidth
.text$mn:00000181                 mov     ecx, [ebp+Point.y]
.text$mn:00000184                 push    ecx             ; Y
.text$mn:00000185                 mov     edx, [ebp+Point.x]
.text$mn:00000188                 push    edx             ; X
.text$mn:00000189                 mov     eax, [ebp+hWnd]
.text$mn:0000018C                 push    eax             ; hWnd
.text$mn:0000018D                 call    dword ptr ds:__imp__MoveWindow@24 ; MoveWindow(x,x,x,x,x,x)
.text$mn:00000193                 mov     eax, [ebp+var_1C]
.text$mn:00000196
.text$mn:00000196 loc_196:                                ; CODE XREF: ValueDlg::reSizeValueBox(void)+1Ej
.text$mn:00000196                 mov     ecx, [ebp+var_4]
.text$mn:00000199                 xor     ecx, ebp
.text$mn:0000019B                 call    @__security_check_cookie@4 ; __security_check_cookie(x)
.text$mn:000001A0                 mov     esp, ebp
.text$mn:000001A2                 pop     ebp
.text$mn:000001A3                 retn
.text$mn:000001A3 ?reSizeValueBox@ValueDlg@@QAEHXZ endp
.text$mn:000001A3
.text$mn:000001A3 ; ---------------------------------------------------------------------------
.text$mn:000001A4                 align 10h
.text$mn:000001B0
.text$mn:000001B0 ; =============== S U B R O U T I N E =======================================
.text$mn:000001B0
.text$mn:000001B0 ; Attributes: bp-based frame
.text$mn:000001B0
.text$mn:000001B0 ; int __stdcall ValueDlg::run_dlgProc(ValueDlg *this, unsigned int, unsigned int, __int32)
.text$mn:000001B0                 public ?run_dlgProc@ValueDlg@@MAGHIIJ@Z
.text$mn:000001B0 ?run_dlgProc@ValueDlg@@MAGHIIJ@Z proc near
.text$mn:000001B0
.text$mn:000001B0 nResult         = dword ptr -24h
.text$mn:000001B0 var_20          = dword ptr -20h
.text$mn:000001B0 var_1C          = dword ptr -1Ch
.text$mn:000001B0 var_18          = dword ptr -18h
.text$mn:000001B0 Rect            = tagRECT ptr -14h
.text$mn:000001B0 var_4           = dword ptr -4
.text$mn:000001B0 this            = dword ptr  8
.text$mn:000001B0 arg_4           = dword ptr  0Ch
.text$mn:000001B0 arg_8           = dword ptr  10h
.text$mn:000001B0
.text$mn:000001B0                 push    ebp
.text$mn:000001B1                 mov     ebp, esp
.text$mn:000001B3                 sub     esp, 24h
.text$mn:000001B6                 mov     eax, dword ptr ds:___security_cookie
.text$mn:000001BB                 xor     eax, ebp
.text$mn:000001BD                 mov     [ebp+var_4], eax
.text$mn:000001C0                 mov     eax, [ebp+arg_4]
.text$mn:000001C3                 mov     [ebp+var_1C], eax
.text$mn:000001C6                 cmp     [ebp+var_1C], 110h
.text$mn:000001CD                 jz      short loc_1E1
.text$mn:000001CF                 cmp     [ebp+var_1C], 111h
.text$mn:000001D6                 jz      loc_26E
.text$mn:000001DC                 jmp     loc_2CD
.text$mn:000001E1 ; ---------------------------------------------------------------------------
.text$mn:000001E1
.text$mn:000001E1 loc_1E1:                                ; CODE XREF: ValueDlg::run_dlgProc(uint,uint,long)+1Dj
.text$mn:000001E1                 mov     ecx, [ebp+this]
.text$mn:000001E4                 add     ecx, 28h ; '('
.text$mn:000001E7                 call    ?c_str@?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QBEPB_WXZ ; std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>>::c_str(void)
.text$mn:000001EC                 push    eax             ; lpString
.text$mn:000001ED                 push    961h            ; nIDDlgItem
.text$mn:000001F2                 mov     ecx, [ebp+this]
.text$mn:000001F5                 mov     edx, [ecx+0Ch]
.text$mn:000001F8                 push    edx             ; hDlg
.text$mn:000001F9                 call    dword ptr ds:__imp__SetDlgItemTextW@12 ; SetDlgItemTextW(x,x,x)
.text$mn:000001FF                 push    0               ; bSigned
.text$mn:00000201                 mov     eax, [ebp+this]
.text$mn:00000204                 mov     ecx, [eax+24h]
.text$mn:00000207                 push    ecx             ; uValue
.text$mn:00000208                 push    962h            ; nIDDlgItem
.text$mn:0000020D                 mov     edx, [ebp+this]
.text$mn:00000210                 mov     eax, [edx+0Ch]
.text$mn:00000213                 push    eax             ; hDlg
.text$mn:00000214                 call    dword ptr ds:__imp__SetDlgItemInt@16 ; SetDlgItemInt(x,x,x,x)
.text$mn:0000021A                 lea     ecx, [ebp+Rect]
.text$mn:0000021D                 push    ecx             ; lpRect
.text$mn:0000021E                 mov     edx, [ebp+this]
.text$mn:00000221                 mov     eax, [edx+0Ch]
.text$mn:00000224                 push    eax             ; hWnd
.text$mn:00000225                 call    dword ptr ds:__imp__GetClientRect@8 ; GetClientRect(x,x)
.text$mn:0000022B                 mov     ecx, [ebp+this] ; this
.text$mn:0000022E                 call    ?reSizeValueBox@ValueDlg@@QAEHXZ ; ValueDlg::reSizeValueBox(void)
.text$mn:00000233                 mov     [ebp+var_20], eax
.text$mn:00000236                 push    1               ; bRepaint
.text$mn:00000238                 mov     ecx, [ebp+Rect.bottom]
.text$mn:0000023B                 sub     ecx, [ebp+Rect.top]
.text$mn:0000023E                 add     ecx, 1Eh
.text$mn:00000241                 push    ecx             ; nHeight
.text$mn:00000242                 mov     edx, [ebp+Rect.right]
.text$mn:00000245                 sub     edx, [ebp+Rect.left]
.text$mn:00000248                 add     edx, [ebp+var_20]
.text$mn:0000024B                 push    edx             ; nWidth
.text$mn:0000024C                 mov     eax, [ebp+this]
.text$mn:0000024F                 mov     ecx, [eax+48h]
.text$mn:00000252                 push    ecx             ; Y
.text$mn:00000253                 mov     edx, [ebp+this]
.text$mn:00000256                 mov     eax, [edx+44h]
.text$mn:00000259                 push    eax             ; X
.text$mn:0000025A                 mov     ecx, [ebp+this]
.text$mn:0000025D                 mov     edx, [ecx+0Ch]
.text$mn:00000260                 push    edx             ; hWnd
.text$mn:00000261                 call    dword ptr ds:__imp__MoveWindow@24 ; MoveWindow(x,x,x,x,x,x)
.text$mn:00000267                 mov     eax, 1
.text$mn:0000026C                 jmp     short loc_2CF
.text$mn:0000026E ; ---------------------------------------------------------------------------
.text$mn:0000026E
.text$mn:0000026E loc_26E:                                ; CODE XREF: ValueDlg::run_dlgProc(uint,uint,long)+26j
.text$mn:0000026E                 mov     eax, [ebp+arg_8]
.text$mn:00000271                 mov     [ebp+var_18], eax
.text$mn:00000274                 cmp     [ebp+var_18], 1
.text$mn:00000278                 jz      short loc_282
.text$mn:0000027A                 cmp     [ebp+var_18], 2
.text$mn:0000027E                 jz      short loc_2B3
.text$mn:00000280                 jmp     short loc_2C9
.text$mn:00000282 ; ---------------------------------------------------------------------------
.text$mn:00000282
.text$mn:00000282 loc_282:                                ; CODE XREF: ValueDlg::run_dlgProc(uint,uint,long)+C8j
.text$mn:00000282                 push    0               ; bSigned
.text$mn:00000284                 push    0               ; lpTranslated
.text$mn:00000286                 push    962h            ; nIDDlgItem
.text$mn:0000028B                 mov     ecx, [ebp+this]
.text$mn:0000028E                 mov     edx, [ecx+0Ch]
.text$mn:00000291                 push    edx             ; hDlg
.text$mn:00000292                 call    dword ptr ds:__imp__GetDlgItemInt@16 ; GetDlgItemInt(x,x,x,x)
.text$mn:00000298                 mov     [ebp+nResult], eax
.text$mn:0000029B                 mov     eax, [ebp+nResult]
.text$mn:0000029E                 push    eax             ; nResult
.text$mn:0000029F                 mov     ecx, [ebp+this]
.text$mn:000002A2                 mov     edx, [ecx+0Ch]
.text$mn:000002A5                 push    edx             ; hDlg
.text$mn:000002A6                 call    dword ptr ds:__imp__EndDialog@8 ; EndDialog(x,x)
.text$mn:000002AC                 mov     eax, 1
.text$mn:000002B1                 jmp     short loc_2CF
.text$mn:000002B3 ; ---------------------------------------------------------------------------
.text$mn:000002B3
.text$mn:000002B3 loc_2B3:                                ; CODE XREF: ValueDlg::run_dlgProc(uint,uint,long)+CEj
.text$mn:000002B3                 push    0FFFFFFFFh      ; nResult
.text$mn:000002B5                 mov     eax, [ebp+this]
.text$mn:000002B8                 mov     ecx, [eax+0Ch]
.text$mn:000002BB                 push    ecx             ; hDlg
.text$mn:000002BC                 call    dword ptr ds:__imp__EndDialog@8 ; EndDialog(x,x)
.text$mn:000002C2                 mov     eax, 1
.text$mn:000002C7                 jmp     short loc_2CF
.text$mn:000002C9 ; ---------------------------------------------------------------------------
.text$mn:000002C9
.text$mn:000002C9 loc_2C9:                                ; CODE XREF: ValueDlg::run_dlgProc(uint,uint,long)+D0j
.text$mn:000002C9                 xor     eax, eax
.text$mn:000002CB                 jmp     short loc_2CF
.text$mn:000002CD ; ---------------------------------------------------------------------------
.text$mn:000002CD
.text$mn:000002CD loc_2CD:                                ; CODE XREF: ValueDlg::run_dlgProc(uint,uint,long)+2Cj
.text$mn:000002CD                 xor     eax, eax
.text$mn:000002CF
.text$mn:000002CF loc_2CF:                                ; CODE XREF: ValueDlg::run_dlgProc(uint,uint,long)+BCj
.text$mn:000002CF                                         ; ValueDlg::run_dlgProc(uint,uint,long)+101j ...
.text$mn:000002CF                 mov     ecx, [ebp+var_4]
.text$mn:000002D2                 xor     ecx, ebp
.text$mn:000002D4                 call    @__security_check_cookie@4 ; __security_check_cookie(x)
.text$mn:000002D9                 mov     esp, ebp
.text$mn:000002DB                 pop     ebp
.text$mn:000002DC                 retn    10h
.text$mn:000002DC ?run_dlgProc@ValueDlg@@MAGHIIJ@Z endp
.text$mn:000002DC
.text$mn:000002DC ; ---------------------------------------------------------------------------
.text$mn:000002DF                 align 10h
.text$mn:000002E0
.text$mn:000002E0 ; =============== S U B R O U T I N E =======================================
.text$mn:000002E0
.text$mn:000002E0 ; Attributes: bp-based frame
.text$mn:000002E0
.text$mn:000002E0 ; void __thiscall ButtonDlg::doDialog(ButtonDlg *this, bool)
.text$mn:000002E0                 public ?doDialog@ButtonDlg@@QAEX_N@Z
.text$mn:000002E0 ?doDialog@ButtonDlg@@QAEX_N@Z proc near
.text$mn:000002E0
.text$mn:000002E0 var_4           = dword ptr -4
.text$mn:000002E0 arg_0           = byte ptr  8
.text$mn:000002E0
.text$mn:000002E0                 push    ebp
.text$mn:000002E1                 mov     ebp, esp
.text$mn:000002E3                 push    ecx
.text$mn:000002E4                 mov     [ebp+var_4], ecx
.text$mn:000002E7                 mov     eax, [ebp+var_4]
.text$mn:000002EA                 mov     edx, [eax]
.text$mn:000002EC                 mov     ecx, [ebp+var_4]
.text$mn:000002EF                 mov     eax, [edx+34h]
.text$mn:000002F2                 call    eax
.text$mn:000002F4                 movzx   ecx, al
.text$mn:000002F7                 test    ecx, ecx
.text$mn:000002F9                 jnz     short loc_314
.text$mn:000002FB                 push    1
.text$mn:000002FD                 movzx   edx, [ebp+arg_0]
.text$mn:00000301                 push    edx
.text$mn:00000302                 push    96Ah
.text$mn:00000307                 mov     eax, [ebp+var_4]
.text$mn:0000030A                 mov     edx, [eax]
.text$mn:0000030C                 mov     ecx, [ebp+var_4]
.text$mn:0000030F                 mov     eax, [edx+30h]
.text$mn:00000312                 call    eax
.text$mn:00000314
.text$mn:00000314 loc_314:                                ; CODE XREF: ButtonDlg::doDialog(bool)+19j
.text$mn:00000314                 push    1
.text$mn:00000316                 mov     ecx, [ebp+var_4]
.text$mn:00000319                 mov     edx, [ecx]
.text$mn:0000031B                 mov     ecx, [ebp+var_4]
.text$mn:0000031E                 mov     eax, [edx+0Ch]
.text$mn:00000321                 call    eax
.text$mn:00000323                 mov     esp, ebp
.text$mn:00000325                 pop     ebp
.text$mn:00000326                 retn    4
.text$mn:00000326 ?doDialog@ButtonDlg@@QAEX_N@Z endp
.text$mn:00000326
.text$mn:00000326 ; ---------------------------------------------------------------------------
.text$mn:00000329                 align 10h
.text$mn:00000330
.text$mn:00000330 ; =============== S U B R O U T I N E =======================================
.text$mn:00000330
.text$mn:00000330 ; Attributes: bp-based frame
.text$mn:00000330
.text$mn:00000330 ; int __stdcall ButtonDlg::run_dlgProc(ButtonDlg *this, unsigned int, unsigned int, __int32)
.text$mn:00000330                 public ?run_dlgProc@ButtonDlg@@MAGHIIJ@Z
.text$mn:00000330 ?run_dlgProc@ButtonDlg@@MAGHIIJ@Z proc near
.text$mn:00000330
.text$mn:00000330 var_1C          = dword ptr -1Ch
.text$mn:00000330 var_18          = dword ptr -18h
.text$mn:00000330 var_14          = dword ptr -14h
.text$mn:00000330 var_10          = dword ptr -10h
.text$mn:00000330 var_C           = dword ptr -0Ch
.text$mn:00000330 wParam          = dword ptr -8
.text$mn:00000330 var_2           = byte ptr -2
.text$mn:00000330 var_1           = byte ptr -1
.text$mn:00000330 this            = dword ptr  8
.text$mn:00000330 arg_4           = dword ptr  0Ch
.text$mn:00000330 arg_8           = dword ptr  10h
.text$mn:00000330
.text$mn:00000330                 push    ebp
.text$mn:00000331                 mov     ebp, esp
.text$mn:00000333                 sub     esp, 1Ch
.text$mn:00000336                 mov     eax, [ebp+arg_4]
.text$mn:00000339                 mov     [ebp+var_C], eax
.text$mn:0000033C                 cmp     [ebp+var_C], 110h
.text$mn:00000343                 jz      short loc_353
.text$mn:00000345                 cmp     [ebp+var_C], 111h
.text$mn:0000034C                 jz      short loc_35D
.text$mn:0000034E                 jmp     loc_42A
.text$mn:00000353 ; ---------------------------------------------------------------------------
.text$mn:00000353
.text$mn:00000353 loc_353:                                ; CODE XREF: ButtonDlg::run_dlgProc(uint,uint,long)+13j
.text$mn:00000353                 mov     eax, 1
.text$mn:00000358                 jmp     loc_42C
.text$mn:0000035D ; ---------------------------------------------------------------------------
.text$mn:0000035D
.text$mn:0000035D loc_35D:                                ; CODE XREF: ButtonDlg::run_dlgProc(uint,uint,long)+1Cj
.text$mn:0000035D                 mov     ecx, [ebp+arg_8]
.text$mn:00000360                 mov     [ebp+var_1C], ecx
.text$mn:00000363                 cmp     [ebp+var_1C], 96Bh
.text$mn:0000036A                 jz      short loc_371
.text$mn:0000036C                 jmp     loc_426
.text$mn:00000371 ; ---------------------------------------------------------------------------
.text$mn:00000371
.text$mn:00000371 loc_371:                                ; CODE XREF: ButtonDlg::run_dlgProc(uint,uint,long)+3Aj
.text$mn:00000371                 mov     ecx, [ebp+this] ; this
.text$mn:00000374                 call    ?getButtonStatus@ButtonDlg@@QBEHXZ ; ButtonDlg::getButtonStatus(void)
.text$mn:00000379                 mov     [ebp+var_14], eax
.text$mn:0000037C                 mov     edx, [ebp+var_14]
.text$mn:0000037F                 and     edx, 1
.text$mn:00000382                 jz      short loc_38D
.text$mn:00000384                 mov     [ebp+var_10], 1
.text$mn:0000038B                 jmp     short loc_394
.text$mn:0000038D ; ---------------------------------------------------------------------------
.text$mn:0000038D
.text$mn:0000038D loc_38D:                                ; CODE XREF: ButtonDlg::run_dlgProc(uint,uint,long)+52j
.text$mn:0000038D                 mov     [ebp+var_10], 0
.text$mn:00000394
.text$mn:00000394 loc_394:                                ; CODE XREF: ButtonDlg::run_dlgProc(uint,uint,long)+5Bj
.text$mn:00000394                 mov     al, byte ptr [ebp+var_10]
.text$mn:00000397                 mov     [ebp+var_1], al
.text$mn:0000039A                 mov     ecx, [ebp+var_14]
.text$mn:0000039D                 and     ecx, 2
.text$mn:000003A0                 jz      short loc_3AB
.text$mn:000003A2                 mov     [ebp+var_18], 1
.text$mn:000003A9                 jmp     short loc_3B2
.text$mn:000003AB ; ---------------------------------------------------------------------------
.text$mn:000003AB
.text$mn:000003AB loc_3AB:                                ; CODE XREF: ButtonDlg::run_dlgProc(uint,uint,long)+70j
.text$mn:000003AB                 mov     [ebp+var_18], 0
.text$mn:000003B2
.text$mn:000003B2 loc_3B2:                                ; CODE XREF: ButtonDlg::run_dlgProc(uint,uint,long)+79j
.text$mn:000003B2                 mov     dl, byte ptr [ebp+var_18]
.text$mn:000003B5                 mov     [ebp+var_2], dl
.text$mn:000003B8                 mov     [ebp+wParam], 0
.text$mn:000003BF                 movzx   eax, [ebp+var_1]
.text$mn:000003C3                 test    eax, eax
.text$mn:000003C5                 jz      short loc_3D8
.text$mn:000003C7                 movzx   ecx, [ebp+var_2]
.text$mn:000003CB                 test    ecx, ecx
.text$mn:000003CD                 jz      short loc_3D8
.text$mn:000003CF                 mov     [ebp+wParam], 0ABE9h
.text$mn:000003D6                 jmp     short loc_3F8
.text$mn:000003D8 ; ---------------------------------------------------------------------------
.text$mn:000003D8
.text$mn:000003D8 loc_3D8:                                ; CODE XREF: ButtonDlg::run_dlgProc(uint,uint,long)+95j
.text$mn:000003D8                                         ; ButtonDlg::run_dlgProc(uint,uint,long)+9Dj
.text$mn:000003D8                 movzx   edx, [ebp+var_1]
.text$mn:000003DC                 test    edx, edx
.text$mn:000003DE                 jz      short loc_3E9
.text$mn:000003E0                 mov     [ebp+wParam], 0AC00h
.text$mn:000003E7                 jmp     short loc_3F8
.text$mn:000003E9 ; ---------------------------------------------------------------------------
.text$mn:000003E9
.text$mn:000003E9 loc_3E9:                                ; CODE XREF: ButtonDlg::run_dlgProc(uint,uint,long)+AEj
.text$mn:000003E9                 movzx   eax, [ebp+var_2]
.text$mn:000003ED                 test    eax, eax
.text$mn:000003EF                 jz      short loc_3F8
.text$mn:000003F1                 mov     [ebp+wParam], 0ABE9h
.text$mn:000003F8
.text$mn:000003F8 loc_3F8:                                ; CODE XREF: ButtonDlg::run_dlgProc(uint,uint,long)+A6j
.text$mn:000003F8                                         ; ButtonDlg::run_dlgProc(uint,uint,long)+B7j ...
.text$mn:000003F8                 push    0               ; lParam
.text$mn:000003FA                 mov     ecx, [ebp+wParam]
.text$mn:000003FD                 push    ecx             ; wParam
.text$mn:000003FE                 push    111h            ; Msg
.text$mn:00000403                 mov     edx, [ebp+this]
.text$mn:00000406                 mov     eax, [edx+8]
.text$mn:00000409                 push    eax             ; hWnd
.text$mn:0000040A                 call    dword ptr ds:__imp__SendMessageW@16 ; SendMessageW(x,x,x,x)
.text$mn:00000410                 push    0
.text$mn:00000412                 mov     ecx, [ebp+this]
.text$mn:00000415                 mov     edx, [ecx]
.text$mn:00000417                 mov     ecx, [ebp+this]
.text$mn:0000041A                 mov     eax, [edx+0Ch]
.text$mn:0000041D                 call    eax
.text$mn:0000041F                 mov     eax, 1
.text$mn:00000424                 jmp     short loc_42C
.text$mn:00000426 ; ---------------------------------------------------------------------------
.text$mn:00000426
.text$mn:00000426 loc_426:                                ; CODE XREF: ButtonDlg::run_dlgProc(uint,uint,long)+3Cj
.text$mn:00000426                 xor     eax, eax
.text$mn:00000428                 jmp     short loc_42C
.text$mn:0000042A ; ---------------------------------------------------------------------------
.text$mn:0000042A
.text$mn:0000042A loc_42A:                                ; CODE XREF: ButtonDlg::run_dlgProc(uint,uint,long)+1Ej
.text$mn:0000042A                 xor     eax, eax
.text$mn:0000042C
.text$mn:0000042C loc_42C:                                ; CODE XREF: ButtonDlg::run_dlgProc(uint,uint,long)+28j
.text$mn:0000042C                                         ; ButtonDlg::run_dlgProc(uint,uint,long)+F4j ...
.text$mn:0000042C                 mov     esp, ebp
.text$mn:0000042E                 pop     ebp
.text$mn:0000042F                 retn    10h
.text$mn:0000042F ?run_dlgProc@ButtonDlg@@MAGHIIJ@Z endp
.text$mn:0000042F
.text$mn:0000042F ; ---------------------------------------------------------------------------
.text$mn:00000432                 align 4
.text$mn:00000432 _text$mn        ends
.text$mn:00000432
.text$mn:00000434 ; ===========================================================================
.text$mn:00000434
.text$mn:00000434 ; Segment type: Pure code
.text$mn:00000434 ; Segment permissions: Read/Execute
.text$mn:00000434 _text$mn        segment para public 'CODE' use32
.text$mn:00000434                 assume cs:_text$mn
.text$mn:00000434                 ;org 434h
.text$mn:00000434 ; COMDAT (pick any)
.text$mn:00000434                 assume es:nothing, ss:nothing, ds:_xdata$x, fs:nothing, gs:nothing
.text$mn:00000434
.text$mn:00000434 ; =============== S U B R O U T I N E =======================================
.text$mn:00000434
.text$mn:00000434 ; Attributes: bp-based frame
.text$mn:00000434
.text$mn:00000434 ; char * __cdecl std::_Allocate<char>(unsigned int, char *)
.text$mn:00000434                 public ??$_Allocate@D@std@@YAPADIPAD@Z
.text$mn:00000434 ??$_Allocate@D@std@@YAPADIPAD@Z proc near
.text$mn:00000434                                         ; CODE XREF: std::allocator<char>::allocate(uint)+Dp
.text$mn:00000434
.text$mn:00000434 var_4           = dword ptr -4
.text$mn:00000434 arg_0           = dword ptr  8
.text$mn:00000434
.text$mn:00000434                 push    ebp
.text$mn:00000435                 mov     ebp, esp
.text$mn:00000437                 push    ecx
.text$mn:00000438                 mov     [ebp+var_4], 0
.text$mn:0000043F                 cmp     [ebp+arg_0], 0
.text$mn:00000443                 jnz     short loc_447
.text$mn:00000445                 jmp     short loc_467
.text$mn:00000447 ; ---------------------------------------------------------------------------
.text$mn:00000447
.text$mn:00000447 loc_447:                                ; CODE XREF: std::_Allocate<char>(uint,char *)+Fj
.text$mn:00000447                 cmp     [ebp+arg_0], 0FFFFFFFFh
.text$mn:0000044B                 ja      short loc_462
.text$mn:0000044D                 mov     eax, [ebp+arg_0]
.text$mn:00000450                 push    eax             ; unsigned int
.text$mn:00000451                 call    ??2@YAPAXI@Z    ; operator new(uint)
.text$mn:00000456                 add     esp, 4
.text$mn:00000459                 mov     [ebp+var_4], eax
.text$mn:0000045C                 cmp     [ebp+var_4], 0
.text$mn:00000460                 jnz     short loc_467
.text$mn:00000462
.text$mn:00000462 loc_462:                                ; CODE XREF: std::_Allocate<char>(uint,char *)+17j
.text$mn:00000462                 call    ?_Xbad_alloc@std@@YAXXZ ; std::_Xbad_alloc(void)
.text$mn:00000467
.text$mn:00000467 loc_467:                                ; CODE XREF: std::_Allocate<char>(uint,char *)+11j
.text$mn:00000467                                         ; std::_Allocate<char>(uint,char *)+2Cj
.text$mn:00000467                 mov     eax, [ebp+var_4]
.text$mn:0000046A                 mov     esp, ebp
.text$mn:0000046C                 pop     ebp
.text$mn:0000046D                 retn
.text$mn:0000046D ??$_Allocate@D@std@@YAPADIPAD@Z endp
.text$mn:0000046D
.text$mn:0000046D ; ---------------------------------------------------------------------------
.text$mn:0000046E                 align 10h
.text$mn:0000046E _text$mn        ends
.text$mn:0000046E
.text$mn:00000470 ; ===========================================================================
.text$mn:00000470
.text$mn:00000470 ; Segment type: Pure code
.text$mn:00000470 ; Segment permissions: Read/Execute
.text$mn:00000470 _text$mn        segment para public 'CODE' use32
.text$mn:00000470                 assume cs:_text$mn
.text$mn:00000470                 ;org 470h
.text$mn:00000470 ; COMDAT (pick any)
.text$mn:00000470                 assume es:nothing, ss:nothing, ds:_xdata$x, fs:nothing, gs:nothing
.text$mn:00000470
.text$mn:00000470 ; =============== S U B R O U T I N E =======================================
.text$mn:00000470
.text$mn:00000470 ; Attributes: bp-based frame
.text$mn:00000470
.text$mn:00000470 ; struct std::_Container_proxy * __cdecl std::_Allocate<struct std::_Container_proxy>(unsigned int, struct std::_Container_proxy *)
.text$mn:00000470                 public ??$_Allocate@U_Container_proxy@std@@@std@@YAPAU_Container_proxy@0@IPAU10@@Z
.text$mn:00000470 ??$_Allocate@U_Container_proxy@std@@@std@@YAPAU_Container_proxy@0@IPAU10@@Z proc near
.text$mn:00000470                                         ; CODE XREF: std::allocator<std::_Container_proxy>::allocate(uint)+Dp
.text$mn:00000470
.text$mn:00000470 var_4           = dword ptr -4
.text$mn:00000470 arg_0           = dword ptr  8
.text$mn:00000470
.text$mn:00000470                 push    ebp
.text$mn:00000471                 mov     ebp, esp
.text$mn:00000473                 push    ecx
.text$mn:00000474                 mov     [ebp+var_4], 0
.text$mn:0000047B                 cmp     [ebp+arg_0], 0
.text$mn:0000047F                 jnz     short loc_483
.text$mn:00000481                 jmp     short loc_4A9
.text$mn:00000483 ; ---------------------------------------------------------------------------
.text$mn:00000483
.text$mn:00000483 loc_483:                                ; CODE XREF: std::_Allocate<std::_Container_proxy>(uint,std::_Container_proxy *)+Fj
.text$mn:00000483                 cmp     [ebp+arg_0], 1FFFFFFFh
.text$mn:0000048A                 ja      short loc_4A4
.text$mn:0000048C                 mov     eax, [ebp+arg_0]
.text$mn:0000048F                 shl     eax, 3
.text$mn:00000492                 push    eax             ; unsigned int
.text$mn:00000493                 call    ??2@YAPAXI@Z    ; operator new(uint)
.text$mn:00000498                 add     esp, 4
.text$mn:0000049B                 mov     [ebp+var_4], eax
.text$mn:0000049E                 cmp     [ebp+var_4], 0
.text$mn:000004A2                 jnz     short loc_4A9
.text$mn:000004A4
.text$mn:000004A4 loc_4A4:                                ; CODE XREF: std::_Allocate<std::_Container_proxy>(uint,std::_Container_proxy *)+1Aj
.text$mn:000004A4                 call    ?_Xbad_alloc@std@@YAXXZ ; std::_Xbad_alloc(void)
.text$mn:000004A9
.text$mn:000004A9 loc_4A9:                                ; CODE XREF: std::_Allocate<std::_Container_proxy>(uint,std::_Container_proxy *)+11j
.text$mn:000004A9                                         ; std::_Allocate<std::_Container_proxy>(uint,std::_Container_proxy *)+32j
.text$mn:000004A9                 mov     eax, [ebp+var_4]
.text$mn:000004AC                 mov     esp, ebp
.text$mn:000004AE                 pop     ebp
.text$mn:000004AF                 retn
.text$mn:000004AF ??$_Allocate@U_Container_proxy@std@@@std@@YAPAU_Container_proxy@0@IPAU10@@Z endp
.text$mn:000004AF
.text$mn:000004AF _text$mn        ends
.text$mn:000004AF
.text$mn:000004B0 ; ===========================================================================
.text$mn:000004B0
.text$mn:000004B0 ; Segment type: Pure code
.text$mn:000004B0 ; Segment permissions: Read/Execute
.text$mn:000004B0 _text$mn        segment para public 'CODE' use32
.text$mn:000004B0                 assume cs:_text$mn
.text$mn:000004B0                 ;org 4B0h
.text$mn:000004B0 ; COMDAT (pick any)
.text$mn:000004B0                 assume es:nothing, ss:nothing, ds:_xdata$x, fs:nothing, gs:nothing
.text$mn:000004B0
.text$mn:000004B0 ; =============== S U B R O U T I N E =======================================
.text$mn:000004B0
.text$mn:000004B0 ; Attributes: bp-based frame
.text$mn:000004B0
.text$mn:000004B0 ; wchar_t * __cdecl std::_Allocate<wchar_t>(unsigned int, wchar_t *)
.text$mn:000004B0                 public ??$_Allocate@_W@std@@YAPA_WIPA_W@Z
.text$mn:000004B0 ??$_Allocate@_W@std@@YAPA_WIPA_W@Z proc near
.text$mn:000004B0                                         ; CODE XREF: std::allocator<wchar_t>::allocate(uint)+Dp
.text$mn:000004B0
.text$mn:000004B0 var_4           = dword ptr -4
.text$mn:000004B0 arg_0           = dword ptr  8
.text$mn:000004B0
.text$mn:000004B0                 push    ebp
.text$mn:000004B1                 mov     ebp, esp
.text$mn:000004B3                 push    ecx
.text$mn:000004B4                 mov     [ebp+var_4], 0
.text$mn:000004BB                 cmp     [ebp+arg_0], 0
.text$mn:000004BF                 jnz     short loc_4C3
.text$mn:000004C1                 jmp     short loc_4E8
.text$mn:000004C3 ; ---------------------------------------------------------------------------
.text$mn:000004C3
.text$mn:000004C3 loc_4C3:                                ; CODE XREF: std::_Allocate<wchar_t>(uint,wchar_t *)+Fj
.text$mn:000004C3                 cmp     [ebp+arg_0], 7FFFFFFFh
.text$mn:000004CA                 ja      short loc_4E3
.text$mn:000004CC                 mov     eax, [ebp+arg_0]
.text$mn:000004CF                 shl     eax, 1
.text$mn:000004D1                 push    eax             ; unsigned int
.text$mn:000004D2                 call    ??2@YAPAXI@Z    ; operator new(uint)
.text$mn:000004D7                 add     esp, 4
.text$mn:000004DA                 mov     [ebp+var_4], eax
.text$mn:000004DD                 cmp     [ebp+var_4], 0
.text$mn:000004E1                 jnz     short loc_4E8
.text$mn:000004E3
.text$mn:000004E3 loc_4E3:                                ; CODE XREF: std::_Allocate<wchar_t>(uint,wchar_t *)+1Aj
.text$mn:000004E3                 call    ?_Xbad_alloc@std@@YAXXZ ; std::_Xbad_alloc(void)
.text$mn:000004E8
.text$mn:000004E8 loc_4E8:                                ; CODE XREF: std::_Allocate<wchar_t>(uint,wchar_t *)+11j
.text$mn:000004E8                                         ; std::_Allocate<wchar_t>(uint,wchar_t *)+31j
.text$mn:000004E8                 mov     eax, [ebp+var_4]
.text$mn:000004EB                 mov     esp, ebp
.text$mn:000004ED                 pop     ebp
.text$mn:000004EE                 retn
.text$mn:000004EE ??$_Allocate@_W@std@@YAPA_WIPA_W@Z endp
.text$mn:000004EE
.text$mn:000004EE ; ---------------------------------------------------------------------------
.text$mn:000004EF                 align 10h
.text$mn:000004EF _text$mn        ends
.text$mn:000004EF
.text$mn:000004F0 ; ===========================================================================
.text$mn:000004F0
.text$mn:000004F0 ; Segment type: Pure code
.text$mn:000004F0 ; Segment permissions: Read/Execute
.text$mn:000004F0 _text$mn        segment para public 'CODE' use32
.text$mn:000004F0                 assume cs:_text$mn
.text$mn:000004F0                 ;org 4F0h
.text$mn:000004F0 ; COMDAT (pick any)
.text$mn:000004F0                 assume es:nothing, ss:nothing, ds:_xdata$x, fs:nothing, gs:nothing
.text$mn:000004F0
.text$mn:000004F0 ; =============== S U B R O U T I N E =======================================
.text$mn:000004F0
.text$mn:000004F0 ; Attributes: bp-based frame
.text$mn:000004F0
.text$mn:000004F0 ; int __cdecl std::_Debug_pointer<char>(int, wchar_t *, unsigned int)
.text$mn:000004F0                 public ??$_Debug_pointer@D@std@@YAXPBDPB_WI@Z
.text$mn:000004F0 ??$_Debug_pointer@D@std@@YAXPBDPB_WI@Z proc near
.text$mn:000004F0                                         ; CODE XREF: std::basic_string<char,std::char_traits<char>,std::allocator<char>>::assign(char const *)+15p
.text$mn:000004F0                                         ; std::basic_string<char,std::char_traits<char>,std::allocator<char>>::assign(char const *,uint)+1Bp
.text$mn:000004F0
.text$mn:000004F0 arg_0           = dword ptr  8
.text$mn:000004F0 arg_4           = dword ptr  0Ch
.text$mn:000004F0 arg_8           = dword ptr  10h
.text$mn:000004F0
.text$mn:000004F0                 push    ebp
.text$mn:000004F1                 mov     ebp, esp
.text$mn:000004F3                 cmp     [ebp+arg_0], 0
.text$mn:000004F7                 jnz     short loc_50E
.text$mn:000004F9                 mov     eax, [ebp+arg_8]
.text$mn:000004FC                 push    eax             ; unsigned int
.text$mn:000004FD                 mov     ecx, [ebp+arg_4]
.text$mn:00000500                 push    ecx             ; wchar_t *
.text$mn:00000501                 push    offset ??_C@_1CK@EOPGIILJ@?$AAi?$AAn?$AAv?$AAa?$AAl?$AAi?$AAd?$AA?5?$AAn?$AAu?$AAl?$AAl?$AA?5?$AAp?$AAo?$AAi?$AAn?$AAt?$AAe?$AAr?$AA?$AA@ ; "invalid null pointer"
.text$mn:00000506                 call    ?_Debug_message@std@@YAXPB_W0I@Z ; std::_Debug_message(wchar_t const *,wchar_t const *,uint)
.text$mn:0000050B                 add     esp, 0Ch
.text$mn:0000050E
.text$mn:0000050E loc_50E:                                ; CODE XREF: std::_Debug_pointer<char>(char const *,wchar_t const *,uint)+7j
.text$mn:0000050E                 pop     ebp
.text$mn:0000050F                 retn
.text$mn:0000050F ??$_Debug_pointer@D@std@@YAXPBDPB_WI@Z endp
.text$mn:0000050F
.text$mn:0000050F _text$mn        ends
.text$mn:0000050F
.text$mn:00000510 ; ===========================================================================
.text$mn:00000510
.text$mn:00000510 ; Segment type: Pure code
.text$mn:00000510 ; Segment permissions: Read/Execute
.text$mn:00000510 _text$mn        segment para public 'CODE' use32
.text$mn:00000510                 assume cs:_text$mn
.text$mn:00000510                 ;org 510h
.text$mn:00000510 ; COMDAT (pick any)
.text$mn:00000510                 assume es:nothing, ss:nothing, ds:_xdata$x, fs:nothing, gs:nothing
.text$mn:00000510
.text$mn:00000510 ; =============== S U B R O U T I N E =======================================
.text$mn:00000510
.text$mn:00000510 ; Attributes: bp-based frame
.text$mn:00000510
.text$mn:00000510 ; int __cdecl std::_Debug_pointer<wchar_t>(int, wchar_t *, unsigned int)
.text$mn:00000510                 public ??$_Debug_pointer@_W@std@@YAXPB_W0I@Z
.text$mn:00000510 ??$_Debug_pointer@_W@std@@YAXPB_W0I@Z proc near
.text$mn:00000510                                         ; CODE XREF: std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>>::assign(wchar_t const *)+15p
.text$mn:00000510                                         ; std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>>::assign(wchar_t const *,uint)+1Bp
.text$mn:00000510
.text$mn:00000510 arg_0           = dword ptr  8
.text$mn:00000510 arg_4           = dword ptr  0Ch
.text$mn:00000510 arg_8           = dword ptr  10h
.text$mn:00000510
.text$mn:00000510                 push    ebp
.text$mn:00000511                 mov     ebp, esp
.text$mn:00000513                 cmp     [ebp+arg_0], 0
.text$mn:00000517                 jnz     short loc_52E
.text$mn:00000519                 mov     eax, [ebp+arg_8]
.text$mn:0000051C                 push    eax             ; unsigned int
.text$mn:0000051D                 mov     ecx, [ebp+arg_4]
.text$mn:00000520                 push    ecx             ; wchar_t *
.text$mn:00000521                 push    offset ??_C@_1CK@EOPGIILJ@?$AAi?$AAn?$AAv?$AAa?$AAl?$AAi?$AAd?$AA?5?$AAn?$AAu?$AAl?$AAl?$AA?5?$AAp?$AAo?$AAi?$AAn?$AAt?$AAe?$AAr?$AA?$AA@ ; "invalid null pointer"
.text$mn:00000526                 call    ?_Debug_message@std@@YAXPB_W0I@Z ; std::_Debug_message(wchar_t const *,wchar_t const *,uint)
.text$mn:0000052B                 add     esp, 0Ch
.text$mn:0000052E
.text$mn:0000052E loc_52E:                                ; CODE XREF: std::_Debug_pointer<wchar_t>(wchar_t const *,wchar_t const *,uint)+7j
.text$mn:0000052E                 pop     ebp
.text$mn:0000052F                 retn
.text$mn:0000052F ??$_Debug_pointer@_W@std@@YAXPB_W0I@Z endp
.text$mn:0000052F
.text$mn:0000052F _text$mn        ends
.text$mn:0000052F
.text$mn:00000530 ; ===========================================================================
.text$mn:00000530
.text$mn:00000530 ; Segment type: Pure code
.text$mn:00000530 ; Segment permissions: Read/Execute
.text$mn:00000530 _text$mn        segment para public 'CODE' use32
.text$mn:00000530                 assume cs:_text$mn
.text$mn:00000530                 ;org 530h
.text$mn:00000530 ; COMDAT (pick any)
.text$mn:00000530                 assume es:nothing, ss:nothing, ds:_xdata$x, fs:nothing, gs:nothing
.text$mn:00000530
.text$mn:00000530 ; =============== S U B R O U T I N E =======================================
.text$mn:00000530
.text$mn:00000530 ; Attributes: bp-based frame
.text$mn:00000530
.text$mn:00000530 ; char * __cdecl std::addressof<char>(char &)
.text$mn:00000530                 public ??$addressof@D@std@@YAPADAAD@Z
.text$mn:00000530 ??$addressof@D@std@@YAPADAAD@Z proc near
.text$mn:00000530                                         ; CODE XREF: std::_String_val<std::_Simple_types<char>>::_Myptr(void)+19p
.text$mn:00000530                                         ; std::_String_val<std::_Simple_types<char>>::_Myptr(void)+19p ...
.text$mn:00000530
.text$mn:00000530 arg_0           = dword ptr  8
.text$mn:00000530
.text$mn:00000530                 push    ebp
.text$mn:00000531                 mov     ebp, esp
.text$mn:00000533                 mov     eax, [ebp+arg_0]
.text$mn:00000536                 pop     ebp
.text$mn:00000537                 retn
.text$mn:00000537 ??$addressof@D@std@@YAPADAAD@Z endp
.text$mn:00000537
.text$mn:00000537 _text$mn        ends
.text$mn:00000537
.text$mn:00000538 ; ===========================================================================
.text$mn:00000538
.text$mn:00000538 ; Segment type: Pure code
.text$mn:00000538 ; Segment permissions: Read/Execute
.text$mn:00000538 _text$mn        segment para public 'CODE' use32
.text$mn:00000538                 assume cs:_text$mn
.text$mn:00000538                 ;org 538h
.text$mn:00000538 ; COMDAT (pick any)
.text$mn:00000538                 assume es:nothing, ss:nothing, ds:_xdata$x, fs:nothing, gs:nothing
.text$mn:00000538
.text$mn:00000538 ; =============== S U B R O U T I N E =======================================
.text$mn:00000538
.text$mn:00000538 ; Attributes: bp-based frame
.text$mn:00000538
.text$mn:00000538 ; wchar_t * __cdecl std::addressof<wchar_t>(wchar_t &)
.text$mn:00000538                 public ??$addressof@_W@std@@YAPA_WAA_W@Z
.text$mn:00000538 ??$addressof@_W@std@@YAPA_WAA_W@Z proc near
.text$mn:00000538                                         ; CODE XREF: std::_String_val<std::_Simple_types<wchar_t>>::_Myptr(void)+19p
.text$mn:00000538                                         ; std::_String_val<std::_Simple_types<wchar_t>>::_Myptr(void)+19p ...
.text$mn:00000538
.text$mn:00000538 arg_0           = dword ptr  8
.text$mn:00000538
.text$mn:00000538                 push    ebp
.text$mn:00000539                 mov     ebp, esp
.text$mn:0000053B                 mov     eax, [ebp+arg_0]
.text$mn:0000053E                 pop     ebp
.text$mn:0000053F                 retn
.text$mn:0000053F ??$addressof@_W@std@@YAPA_WAA_W@Z endp
.text$mn:0000053F
.text$mn:0000053F _text$mn        ends
.text$mn:0000053F
.text$mn:00000540 ; ===========================================================================
.text$mn:00000540
.text$mn:00000540 ; Segment type: Pure code
.text$mn:00000540 ; Segment permissions: Read/Execute
.text$mn:00000540 _text$mn        segment para public 'CODE' use32
.text$mn:00000540                 assume cs:_text$mn
.text$mn:00000540                 ;org 540h
.text$mn:00000540 ; COMDAT (pick any)
.text$mn:00000540                 assume es:nothing, ss:nothing, ds:_xdata$x, fs:nothing, gs:nothing
.text$mn:00000540
.text$mn:00000540 ; =============== S U B R O U T I N E =======================================
.text$mn:00000540
.text$mn:00000540 ; Attributes: bp-based frame
.text$mn:00000540
.text$mn:00000540 ; int __stdcall std::_Wrap_alloc<std::allocator<char>>::construct<char *,char * &>(void *, int)
.text$mn:00000540                 public ??$construct@PADAAPAD@?$_Wrap_alloc@V?$allocator@D@std@@@std@@QAEXPAPADAAPAD@Z
.text$mn:00000540 ??$construct@PADAAPAD@?$_Wrap_alloc@V?$allocator@D@std@@@std@@QAEXPAPADAAPAD@Z proc near
.text$mn:00000540                                         ; CODE XREF: $LN19+4Bp
.text$mn:00000540
.text$mn:00000540 var_4           = dword ptr -4
.text$mn:00000540 arg_0           = dword ptr  8
.text$mn:00000540 arg_4           = dword ptr  0Ch
.text$mn:00000540
.text$mn:00000540                 push    ebp
.text$mn:00000541                 mov     ebp, esp
.text$mn:00000543                 push    ecx
.text$mn:00000544                 mov     [ebp+var_4], ecx
.text$mn:00000547                 mov     eax, [ebp+arg_4]
.text$mn:0000054A                 push    eax
.text$mn:0000054B                 call    ??$forward@AAPAD@std@@YAAAPADAAPAD@Z ; std::forward<char * &>(char * &)
.text$mn:00000550                 add     esp, 4
.text$mn:00000553                 push    eax             ; int
.text$mn:00000554                 mov     ecx, [ebp+arg_0]
.text$mn:00000557                 push    ecx             ; void *
.text$mn:00000558                 mov     edx, [ebp+var_4]
.text$mn:0000055B                 push    edx             ; int
.text$mn:0000055C                 call    ??$construct@PADAAPAD@?$allocator_traits@V?$allocator@D@std@@@std@@SAXAAV?$allocator@D@1@PAPADAAPAD@Z ; std::allocator_traits<std::allocator<char>>::construct<char *,char * &>(std::allocator<char> &,char * *,char * &)
.text$mn:00000561                 add     esp, 0Ch
.text$mn:00000564                 mov     esp, ebp
.text$mn:00000566                 pop     ebp
.text$mn:00000567                 retn    8
.text$mn:00000567 ??$construct@PADAAPAD@?$_Wrap_alloc@V?$allocator@D@std@@@std@@QAEXPAPADAAPAD@Z endp
.text$mn:00000567
.text$mn:00000567 ; ---------------------------------------------------------------------------
.text$mn:0000056A                 align 4
.text$mn:0000056A _text$mn        ends
.text$mn:0000056A
.text$mn:0000056C ; ===========================================================================
.text$mn:0000056C
.text$mn:0000056C ; Segment type: Pure code
.text$mn:0000056C ; Segment permissions: Read/Execute
.text$mn:0000056C _text$mn        segment para public 'CODE' use32
.text$mn:0000056C                 assume cs:_text$mn
.text$mn:0000056C                 ;org 56Ch
.text$mn:0000056C ; COMDAT (pick any)
.text$mn:0000056C                 assume es:nothing, ss:nothing, ds:_xdata$x, fs:nothing, gs:nothing
.text$mn:0000056C
.text$mn:0000056C ; =============== S U B R O U T I N E =======================================
.text$mn:0000056C
.text$mn:0000056C ; Attributes: bp-based frame
.text$mn:0000056C
.text$mn:0000056C ; int __stdcall std::allocator<char>::construct<char *,char * &>(void *, int)
.text$mn:0000056C                 public ??$construct@PADAAPAD@?$allocator@D@std@@QAEXPAPADAAPAD@Z
.text$mn:0000056C ??$construct@PADAAPAD@?$allocator@D@std@@QAEXPAPADAAPAD@Z proc near
.text$mn:0000056C                                         ; CODE XREF: std::allocator_traits<std::allocator<char>>::construct<char *,char * &>(std::allocator<char> &,char * *,char * &)+17p
.text$mn:0000056C
.text$mn:0000056C var_1C          = dword ptr -1Ch
.text$mn:0000056C var_18          = dword ptr -18h
.text$mn:0000056C var_14          = dword ptr -14h
.text$mn:0000056C var_10          = dword ptr -10h
.text$mn:0000056C var_C           = dword ptr -0Ch
.text$mn:0000056C var_4           = dword ptr -4
.text$mn:0000056C arg_0           = dword ptr  8
.text$mn:0000056C arg_4           = dword ptr  0Ch
.text$mn:0000056C
.text$mn:0000056C                 push    ebp
.text$mn:0000056D                 mov     ebp, esp
.text$mn:0000056F                 push    0FFFFFFFFh
.text$mn:00000571                 push    offset __ehhandler$??$construct@PADAAPAD@?$allocator@D@std@@QAEXPAPADAAPAD@Z
.text$mn:00000576                 mov     eax, large fs:0
.text$mn:0000057C                 push    eax
.text$mn:0000057D                 sub     esp, 10h
.text$mn:00000580                 mov     eax, dword ptr ds:___security_cookie
.text$mn:00000585                 xor     eax, ebp
.text$mn:00000587                 push    eax
.text$mn:00000588                 lea     eax, [ebp+var_C]
.text$mn:0000058B                 mov     large fs:0, eax
.text$mn:00000591                 mov     [ebp+var_18], ecx
.text$mn:00000594                 mov     eax, [ebp+arg_0]
.text$mn:00000597                 push    eax             ; void *
.text$mn:00000598                 push    4               ; unsigned int
.text$mn:0000059A                 call    ??2@YAPAXIPAX@Z ; operator new(uint,void *)
.text$mn:0000059F                 add     esp, 8
.text$mn:000005A2                 mov     [ebp+var_10], eax
.text$mn:000005A5                 mov     [ebp+var_4], 0
.text$mn:000005AC                 cmp     [ebp+var_10], 0
.text$mn:000005B0                 jz      short loc_5CD
.text$mn:000005B2                 mov     ecx, [ebp+arg_4]
.text$mn:000005B5                 push    ecx
.text$mn:000005B6                 call    ??$forward@AAPAD@std@@YAAAPADAAPAD@Z ; std::forward<char * &>(char * &)
.text$mn:000005BB                 add     esp, 4
.text$mn:000005BE                 mov     edx, [ebp+var_10]
.text$mn:000005C1                 mov     eax, [eax]
.text$mn:000005C3                 mov     [edx], eax
.text$mn:000005C5                 mov     ecx, [ebp+var_10]
.text$mn:000005C8                 mov     [ebp+var_14], ecx
.text$mn:000005CB                 jmp     short loc_5D4
.text$mn:000005CD ; ---------------------------------------------------------------------------
.text$mn:000005CD
.text$mn:000005CD loc_5CD:                                ; CODE XREF: std::allocator<char>::construct<char *,char * &>(char * *,char * &)+44j
.text$mn:000005CD                 mov     [ebp+var_14], 0
.text$mn:000005D4
.text$mn:000005D4 loc_5D4:                                ; CODE XREF: std::allocator<char>::construct<char *,char * &>(char * *,char * &)+5Fj
.text$mn:000005D4                 mov     edx, [ebp+var_14]
.text$mn:000005D7                 mov     [ebp+var_1C], edx
.text$mn:000005DA                 mov     [ebp+var_4], 0FFFFFFFFh
.text$mn:000005E1                 mov     ecx, [ebp+var_C]
.text$mn:000005E4                 mov     large fs:0, ecx
.text$mn:000005EB                 pop     ecx
.text$mn:000005EC                 mov     esp, ebp
.text$mn:000005EE                 pop     ebp
.text$mn:000005EF                 retn    8
.text$mn:000005EF ??$construct@PADAAPAD@?$allocator@D@std@@QAEXPAPADAAPAD@Z endp
.text$mn:000005EF
.text$mn:000005EF ; ---------------------------------------------------------------------------
.text$mn:000005F2                 align 4
.text$mn:000005F2 _text$mn        ends
.text$mn:000005F2
.text$x:000005F4 ; ===========================================================================
.text$x:000005F4
.text$x:000005F4 ; Segment type: Pure code
.text$x:000005F4 ; Segment permissions: Read/Execute
.text$x:000005F4 _text$x         segment para public 'CODE' use32
.text$x:000005F4                 assume cs:_text$x
.text$x:000005F4                 ;org 5F4h
.text$x:000005F4 ; COMDAT (pick associative to section at 56C)
.text$x:000005F4                 assume es:nothing, ss:nothing, ds:_xdata$x, fs:nothing, gs:nothing
.text$x:000005F4
.text$x:000005F4 ; =============== S U B R O U T I N E =======================================
.text$x:000005F4
.text$x:000005F4
.text$x:000005F4 __unwindfunclet$??$construct@PADAAPAD@?$allocator@D@std@@QAEXPAPADAAPAD@Z$0 proc near
.text$x:000005F4                                         ; DATA XREF: .xdata$x:00002BF4o
.text$x:000005F4                 mov     eax, [ebp+8]
.text$x:000005F7                 push    eax
.text$x:000005F8                 mov     eax, [ebp-10h]
.text$x:000005FB                 push    eax             ; void *
.text$x:000005FC                 call    ??3@YAXPAX0@Z   ; operator delete(void *,void *)
.text$x:00000601                 add     esp, 8
.text$x:00000604                 retn
.text$x:00000604 __unwindfunclet$??$construct@PADAAPAD@?$allocator@D@std@@QAEXPAPADAAPAD@Z$0 endp
.text$x:00000604
.text$x:00000605
.text$x:00000605 ; =============== S U B R O U T I N E =======================================
.text$x:00000605
.text$x:00000605
.text$x:00000605 __ehhandler$??$construct@PADAAPAD@?$allocator@D@std@@QAEXPAPADAAPAD@Z proc near
.text$x:00000605                                         ; DATA XREF: std::allocator<char>::construct<char *,char * &>(char * *,char * &)+5o
.text$x:00000605
.text$x:00000605 arg_4           = dword ptr  8
.text$x:00000605
.text$x:00000605                 mov     edx, [esp+arg_4]
.text$x:00000609                 lea     eax, [edx+0Ch]
.text$x:0000060C                 mov     ecx, [edx-14h]
.text$x:0000060F                 xor     ecx, eax
.text$x:00000611                 call    @__security_check_cookie@4 ; __security_check_cookie(x)
.text$x:00000616                 mov     eax, offset __ehfuncinfo$??$construct@PADAAPAD@?$allocator@D@std@@QAEXPAPADAAPAD@Z
.text$x:0000061B                 jmp     ___CxxFrameHandler3
.text$x:0000061B __ehhandler$??$construct@PADAAPAD@?$allocator@D@std@@QAEXPAPADAAPAD@Z endp
.text$x:0000061B
.text$x:0000061B _text$x         ends
.text$x:0000061B
.text$mn:00000620 ; ===========================================================================
.text$mn:00000620
.text$mn:00000620 ; Segment type: Pure code
.text$mn:00000620 ; Segment permissions: Read/Execute
.text$mn:00000620 _text$mn        segment para public 'CODE' use32
.text$mn:00000620                 assume cs:_text$mn
.text$mn:00000620                 ;org 620h
.text$mn:00000620 ; COMDAT (pick any)
.text$mn:00000620                 assume es:nothing, ss:nothing, ds:_xdata$x, fs:nothing, gs:nothing
.text$mn:00000620
.text$mn:00000620 ; =============== S U B R O U T I N E =======================================
.text$mn:00000620
.text$mn:00000620 ; Attributes: bp-based frame
.text$mn:00000620
.text$mn:00000620 ; int __cdecl std::allocator_traits<std::allocator<char>>::construct<char *,char * &>(int, void *, int)
.text$mn:00000620                 public ??$construct@PADAAPAD@?$allocator_traits@V?$allocator@D@std@@@std@@SAXAAV?$allocator@D@1@PAPADAAPAD@Z
.text$mn:00000620 ??$construct@PADAAPAD@?$allocator_traits@V?$allocator@D@std@@@std@@SAXAAV?$allocator@D@1@PAPADAAPAD@Z proc near
.text$mn:00000620                                         ; CODE XREF: std::_Wrap_alloc<std::allocator<char>>::construct<char *,char * &>(char * *,char * &)+1Cp
.text$mn:00000620
.text$mn:00000620 arg_0           = dword ptr  8
.text$mn:00000620 arg_4           = dword ptr  0Ch
.text$mn:00000620 arg_8           = dword ptr  10h
.text$mn:00000620
.text$mn:00000620                 push    ebp
.text$mn:00000621                 mov     ebp, esp
.text$mn:00000623                 mov     eax, [ebp+arg_8]
.text$mn:00000626                 push    eax
.text$mn:00000627                 call    ??$forward@AAPAD@std@@YAAAPADAAPAD@Z ; std::forward<char * &>(char * &)
.text$mn:0000062C                 add     esp, 4
.text$mn:0000062F                 push    eax             ; int
.text$mn:00000630                 mov     ecx, [ebp+arg_4]
.text$mn:00000633                 push    ecx             ; void *
.text$mn:00000634                 mov     ecx, [ebp+arg_0]
.text$mn:00000637                 call    ??$construct@PADAAPAD@?$allocator@D@std@@QAEXPAPADAAPAD@Z ; std::allocator<char>::construct<char *,char * &>(char * *,char * &)
.text$mn:0000063C                 pop     ebp
.text$mn:0000063D                 retn
.text$mn:0000063D ??$construct@PADAAPAD@?$allocator_traits@V?$allocator@D@std@@@std@@SAXAAV?$allocator@D@1@PAPADAAPAD@Z endp
.text$mn:0000063D
.text$mn:0000063D ; ---------------------------------------------------------------------------
.text$mn:0000063E                 align 10h
.text$mn:0000063E _text$mn        ends
.text$mn:0000063E
.text$mn:00000640 ; ===========================================================================
.text$mn:00000640
.text$mn:00000640 ; Segment type: Pure code
.text$mn:00000640 ; Segment permissions: Read/Execute
.text$mn:00000640 _text$mn        segment para public 'CODE' use32
.text$mn:00000640                 assume cs:_text$mn
.text$mn:00000640                 ;org 640h
.text$mn:00000640 ; COMDAT (pick any)
.text$mn:00000640                 assume es:nothing, ss:nothing, ds:_xdata$x, fs:nothing, gs:nothing
.text$mn:00000640
.text$mn:00000640 ; =============== S U B R O U T I N E =======================================
.text$mn:00000640
.text$mn:00000640 ; Attributes: bp-based frame
.text$mn:00000640
.text$mn:00000640 ; int __stdcall std::_Wrap_alloc<std::allocator<wchar_t>>::construct<wchar_t *,wchar_t * &>(void *, int)
.text$mn:00000640                 public ??$construct@PA_WAAPA_W@?$_Wrap_alloc@V?$allocator@_W@std@@@std@@QAEXPAPA_WAAPA_W@Z
.text$mn:00000640 ??$construct@PA_WAAPA_W@?$_Wrap_alloc@V?$allocator@_W@std@@@std@@QAEXPAPA_WAAPA_W@Z proc near
.text$mn:00000640                                         ; CODE XREF: $LN19_0+4Bp
.text$mn:00000640
.text$mn:00000640 var_4           = dword ptr -4
.text$mn:00000640 arg_0           = dword ptr  8
.text$mn:00000640 arg_4           = dword ptr  0Ch
.text$mn:00000640
.text$mn:00000640                 push    ebp
.text$mn:00000641                 mov     ebp, esp
.text$mn:00000643                 push    ecx
.text$mn:00000644                 mov     [ebp+var_4], ecx
.text$mn:00000647                 mov     eax, [ebp+arg_4]
.text$mn:0000064A                 push    eax
.text$mn:0000064B                 call    ??$forward@AAPA_W@std@@YAAAPA_WAAPA_W@Z ; std::forward<wchar_t * &>(wchar_t * &)
.text$mn:00000650                 add     esp, 4
.text$mn:00000653                 push    eax             ; int
.text$mn:00000654                 mov     ecx, [ebp+arg_0]
.text$mn:00000657                 push    ecx             ; void *
.text$mn:00000658                 mov     edx, [ebp+var_4]
.text$mn:0000065B                 push    edx             ; int
.text$mn:0000065C                 call    ??$construct@PA_WAAPA_W@?$allocator_traits@V?$allocator@_W@std@@@std@@SAXAAV?$allocator@_W@1@PAPA_WAAPA_W@Z ; std::allocator_traits<std::allocator<wchar_t>>::construct<wchar_t *,wchar_t * &>(std::allocator<wchar_t> &,wchar_t * *,wchar_t * &)
.text$mn:00000661                 add     esp, 0Ch
.text$mn:00000664                 mov     esp, ebp
.text$mn:00000666                 pop     ebp
.text$mn:00000667                 retn    8
.text$mn:00000667 ??$construct@PA_WAAPA_W@?$_Wrap_alloc@V?$allocator@_W@std@@@std@@QAEXPAPA_WAAPA_W@Z endp
.text$mn:00000667
.text$mn:00000667 ; ---------------------------------------------------------------------------
.text$mn:0000066A                 align 4
.text$mn:0000066A _text$mn        ends
.text$mn:0000066A
.text$mn:0000066C ; ===========================================================================
.text$mn:0000066C
.text$mn:0000066C ; Segment type: Pure code
.text$mn:0000066C ; Segment permissions: Read/Execute
.text$mn:0000066C _text$mn        segment para public 'CODE' use32
.text$mn:0000066C                 assume cs:_text$mn
.text$mn:0000066C                 ;org 66Ch
.text$mn:0000066C ; COMDAT (pick any)
.text$mn:0000066C                 assume es:nothing, ss:nothing, ds:_xdata$x, fs:nothing, gs:nothing
.text$mn:0000066C
.text$mn:0000066C ; =============== S U B R O U T I N E =======================================
.text$mn:0000066C
.text$mn:0000066C ; Attributes: bp-based frame
.text$mn:0000066C
.text$mn:0000066C ; int __stdcall std::allocator<wchar_t>::construct<wchar_t *,wchar_t * &>(void *, int)
.text$mn:0000066C                 public ??$construct@PA_WAAPA_W@?$allocator@_W@std@@QAEXPAPA_WAAPA_W@Z
.text$mn:0000066C ??$construct@PA_WAAPA_W@?$allocator@_W@std@@QAEXPAPA_WAAPA_W@Z proc near
.text$mn:0000066C                                         ; CODE XREF: std::allocator_traits<std::allocator<wchar_t>>::construct<wchar_t *,wchar_t * &>(std::allocator<wchar_t> &,wchar_t * *,wchar_t * &)+17p
.text$mn:0000066C
.text$mn:0000066C var_1C          = dword ptr -1Ch
.text$mn:0000066C var_18          = dword ptr -18h
.text$mn:0000066C var_14          = dword ptr -14h
.text$mn:0000066C var_10          = dword ptr -10h
.text$mn:0000066C var_C           = dword ptr -0Ch
.text$mn:0000066C var_4           = dword ptr -4
.text$mn:0000066C arg_0           = dword ptr  8
.text$mn:0000066C arg_4           = dword ptr  0Ch
.text$mn:0000066C
.text$mn:0000066C                 push    ebp
.text$mn:0000066D                 mov     ebp, esp
.text$mn:0000066F                 push    0FFFFFFFFh
.text$mn:00000671                 push    offset __ehhandler$??$construct@PA_WAAPA_W@?$allocator@_W@std@@QAEXPAPA_WAAPA_W@Z
.text$mn:00000676                 mov     eax, large fs:0
.text$mn:0000067C                 push    eax
.text$mn:0000067D                 sub     esp, 10h
.text$mn:00000680                 mov     eax, dword ptr ds:___security_cookie
.text$mn:00000685                 xor     eax, ebp
.text$mn:00000687                 push    eax
.text$mn:00000688                 lea     eax, [ebp+var_C]
.text$mn:0000068B                 mov     large fs:0, eax
.text$mn:00000691                 mov     [ebp+var_18], ecx
.text$mn:00000694                 mov     eax, [ebp+arg_0]
.text$mn:00000697                 push    eax             ; void *
.text$mn:00000698                 push    4               ; unsigned int
.text$mn:0000069A                 call    ??2@YAPAXIPAX@Z ; operator new(uint,void *)
.text$mn:0000069F                 add     esp, 8
.text$mn:000006A2                 mov     [ebp+var_10], eax
.text$mn:000006A5                 mov     [ebp+var_4], 0
.text$mn:000006AC                 cmp     [ebp+var_10], 0
.text$mn:000006B0                 jz      short loc_6CD
.text$mn:000006B2                 mov     ecx, [ebp+arg_4]
.text$mn:000006B5                 push    ecx
.text$mn:000006B6                 call    ??$forward@AAPA_W@std@@YAAAPA_WAAPA_W@Z ; std::forward<wchar_t * &>(wchar_t * &)
.text$mn:000006BB                 add     esp, 4
.text$mn:000006BE                 mov     edx, [ebp+var_10]
.text$mn:000006C1                 mov     eax, [eax]
.text$mn:000006C3                 mov     [edx], eax
.text$mn:000006C5                 mov     ecx, [ebp+var_10]
.text$mn:000006C8                 mov     [ebp+var_14], ecx
.text$mn:000006CB                 jmp     short loc_6D4
.text$mn:000006CD ; ---------------------------------------------------------------------------
.text$mn:000006CD
.text$mn:000006CD loc_6CD:                                ; CODE XREF: std::allocator<wchar_t>::construct<wchar_t *,wchar_t * &>(wchar_t * *,wchar_t * &)+44j
.text$mn:000006CD                 mov     [ebp+var_14], 0
.text$mn:000006D4
.text$mn:000006D4 loc_6D4:                                ; CODE XREF: std::allocator<wchar_t>::construct<wchar_t *,wchar_t * &>(wchar_t * *,wchar_t * &)+5Fj
.text$mn:000006D4                 mov     edx, [ebp+var_14]
.text$mn:000006D7                 mov     [ebp+var_1C], edx
.text$mn:000006DA                 mov     [ebp+var_4], 0FFFFFFFFh
.text$mn:000006E1                 mov     ecx, [ebp+var_C]
.text$mn:000006E4                 mov     large fs:0, ecx
.text$mn:000006EB                 pop     ecx
.text$mn:000006EC                 mov     esp, ebp
.text$mn:000006EE                 pop     ebp
.text$mn:000006EF                 retn    8
.text$mn:000006EF ??$construct@PA_WAAPA_W@?$allocator@_W@std@@QAEXPAPA_WAAPA_W@Z endp
.text$mn:000006EF
.text$mn:000006EF ; ---------------------------------------------------------------------------
.text$mn:000006F2                 align 4
.text$mn:000006F2 _text$mn        ends
.text$mn:000006F2
.text$x:000006F4 ; ===========================================================================
.text$x:000006F4
.text$x:000006F4 ; Segment type: Pure code
.text$x:000006F4 ; Segment permissions: Read/Execute
.text$x:000006F4 _text$x         segment para public 'CODE' use32
.text$x:000006F4                 assume cs:_text$x
.text$x:000006F4                 ;org 6F4h
.text$x:000006F4 ; COMDAT (pick associative to section at 66C)
.text$x:000006F4                 assume es:nothing, ss:nothing, ds:_xdata$x, fs:nothing, gs:nothing
.text$x:000006F4
.text$x:000006F4 ; =============== S U B R O U T I N E =======================================
.text$x:000006F4
.text$x:000006F4
.text$x:000006F4 __unwindfunclet$??$construct@PA_WAAPA_W@?$allocator@_W@std@@QAEXPAPA_WAAPA_W@Z$0 proc near
.text$x:000006F4                                         ; DATA XREF: .xdata$x:00002C20o
.text$x:000006F4                 mov     eax, [ebp+8]
.text$x:000006F7                 push    eax
.text$x:000006F8                 mov     eax, [ebp-10h]
.text$x:000006FB                 push    eax             ; void *
.text$x:000006FC                 call    ??3@YAXPAX0@Z   ; operator delete(void *,void *)
.text$x:00000701                 add     esp, 8
.text$x:00000704                 retn
.text$x:00000704 __unwindfunclet$??$construct@PA_WAAPA_W@?$allocator@_W@std@@QAEXPAPA_WAAPA_W@Z$0 endp
.text$x:00000704
.text$x:00000705
.text$x:00000705 ; =============== S U B R O U T I N E =======================================
.text$x:00000705
.text$x:00000705
.text$x:00000705 __ehhandler$??$construct@PA_WAAPA_W@?$allocator@_W@std@@QAEXPAPA_WAAPA_W@Z proc near
.text$x:00000705                                         ; DATA XREF: std::allocator<wchar_t>::construct<wchar_t *,wchar_t * &>(wchar_t * *,wchar_t * &)+5o
.text$x:00000705
.text$x:00000705 arg_4           = dword ptr  8
.text$x:00000705
.text$x:00000705                 mov     edx, [esp+arg_4]
.text$x:00000709                 lea     eax, [edx+0Ch]
.text$x:0000070C                 mov     ecx, [edx-14h]
.text$x:0000070F                 xor     ecx, eax
.text$x:00000711                 call    @__security_check_cookie@4 ; __security_check_cookie(x)
.text$x:00000716                 mov     eax, offset __ehfuncinfo$??$construct@PA_WAAPA_W@?$allocator@_W@std@@QAEXPAPA_WAAPA_W@Z
.text$x:0000071B                 jmp     ___CxxFrameHandler3
.text$x:0000071B __ehhandler$??$construct@PA_WAAPA_W@?$allocator@_W@std@@QAEXPAPA_WAAPA_W@Z endp
.text$x:0000071B
.text$x:0000071B _text$x         ends
.text$x:0000071B
.text$mn:00000720 ; ===========================================================================
.text$mn:00000720
.text$mn:00000720 ; Segment type: Pure code
.text$mn:00000720 ; Segment permissions: Read/Execute
.text$mn:00000720 _text$mn        segment para public 'CODE' use32
.text$mn:00000720                 assume cs:_text$mn
.text$mn:00000720                 ;org 720h
.text$mn:00000720 ; COMDAT (pick any)
.text$mn:00000720                 assume es:nothing, ss:nothing, ds:_xdata$x, fs:nothing, gs:nothing
.text$mn:00000720
.text$mn:00000720 ; =============== S U B R O U T I N E =======================================
.text$mn:00000720
.text$mn:00000720 ; Attributes: bp-based frame
.text$mn:00000720
.text$mn:00000720 ; int __cdecl std::allocator_traits<std::allocator<wchar_t>>::construct<wchar_t *,wchar_t * &>(int, void *, int)
.text$mn:00000720                 public ??$construct@PA_WAAPA_W@?$allocator_traits@V?$allocator@_W@std@@@std@@SAXAAV?$allocator@_W@1@PAPA_WAAPA_W@Z
.text$mn:00000720 ??$construct@PA_WAAPA_W@?$allocator_traits@V?$allocator@_W@std@@@std@@SAXAAV?$allocator@_W@1@PAPA_WAAPA_W@Z proc near
.text$mn:00000720                                         ; CODE XREF: std::_Wrap_alloc<std::allocator<wchar_t>>::construct<wchar_t *,wchar_t * &>(wchar_t * *,wchar_t * &)+1Cp
.text$mn:00000720
.text$mn:00000720 arg_0           = dword ptr  8
.text$mn:00000720 arg_4           = dword ptr  0Ch
.text$mn:00000720 arg_8           = dword ptr  10h
.text$mn:00000720
.text$mn:00000720                 push    ebp
.text$mn:00000721                 mov     ebp, esp
.text$mn:00000723                 mov     eax, [ebp+arg_8]
.text$mn:00000726                 push    eax
.text$mn:00000727                 call    ??$forward@AAPA_W@std@@YAAAPA_WAAPA_W@Z ; std::forward<wchar_t * &>(wchar_t * &)
.text$mn:0000072C                 add     esp, 4
.text$mn:0000072F                 push    eax             ; int
.text$mn:00000730                 mov     ecx, [ebp+arg_4]
.text$mn:00000733                 push    ecx             ; void *
.text$mn:00000734                 mov     ecx, [ebp+arg_0]
.text$mn:00000737                 call    ??$construct@PA_WAAPA_W@?$allocator@_W@std@@QAEXPAPA_WAAPA_W@Z ; std::allocator<wchar_t>::construct<wchar_t *,wchar_t * &>(wchar_t * *,wchar_t * &)
.text$mn:0000073C                 pop     ebp
.text$mn:0000073D                 retn
.text$mn:0000073D ??$construct@PA_WAAPA_W@?$allocator_traits@V?$allocator@_W@std@@@std@@SAXAAV?$allocator@_W@1@PAPA_WAAPA_W@Z endp
.text$mn:0000073D
.text$mn:0000073D ; ---------------------------------------------------------------------------
.text$mn:0000073E                 align 10h
.text$mn:0000073E _text$mn        ends
.text$mn:0000073E
.text$mn:00000740 ; ===========================================================================
.text$mn:00000740
.text$mn:00000740 ; Segment type: Pure code
.text$mn:00000740 ; Segment permissions: Read/Execute
.text$mn:00000740 _text$mn        segment para public 'CODE' use32
.text$mn:00000740                 assume cs:_text$mn
.text$mn:00000740                 ;org 740h
.text$mn:00000740 ; COMDAT (pick any)
.text$mn:00000740                 assume es:nothing, ss:nothing, ds:_xdata$x, fs:nothing, gs:nothing
.text$mn:00000740
.text$mn:00000740 ; =============== S U B R O U T I N E =======================================
.text$mn:00000740
.text$mn:00000740 ; Attributes: bp-based frame
.text$mn:00000740
.text$mn:00000740 ; int __stdcall std::allocator<std::_Container_proxy>::construct<std::_Container_proxy,std::_Container_proxy>(void *, int)
.text$mn:00000740                 public ??$construct@U_Container_proxy@std@@U12@@?$allocator@U_Container_proxy@std@@@std@@QAEXPAU_Container_proxy@1@$$QAU21@@Z
.text$mn:00000740 ??$construct@U_Container_proxy@std@@U12@@?$allocator@U_Container_proxy@std@@@std@@QAEXPAU_Container_proxy@1@$$QAU21@@Z proc near
.text$mn:00000740                                         ; CODE XREF: std::_String_alloc<0,std::_String_base_types<char,std::allocator<char>>>::_Alloc_proxy(void)+32p
.text$mn:00000740
.text$mn:00000740 var_1C          = dword ptr -1Ch
.text$mn:00000740 var_18          = dword ptr -18h
.text$mn:00000740 var_14          = dword ptr -14h
.text$mn:00000740 var_10          = dword ptr -10h
.text$mn:00000740 var_C           = dword ptr -0Ch
.text$mn:00000740 var_4           = dword ptr -4
.text$mn:00000740 arg_0           = dword ptr  8
.text$mn:00000740 arg_4           = dword ptr  0Ch
.text$mn:00000740
.text$mn:00000740                 push    ebp
.text$mn:00000741                 mov     ebp, esp
.text$mn:00000743                 push    0FFFFFFFFh
.text$mn:00000745                 push    offset __ehhandler$??$construct@U_Container_proxy@std@@U12@@?$allocator@U_Container_proxy@std@@@std@@QAEXPAU_Container_proxy@1@$$QAU21@@Z
.text$mn:0000074A                 mov     eax, large fs:0
.text$mn:00000750                 push    eax
.text$mn:00000751                 sub     esp, 10h
.text$mn:00000754                 mov     eax, dword ptr ds:___security_cookie
.text$mn:00000759                 xor     eax, ebp
.text$mn:0000075B                 push    eax
.text$mn:0000075C                 lea     eax, [ebp+var_C]
.text$mn:0000075F                 mov     large fs:0, eax
.text$mn:00000765                 mov     [ebp+var_18], ecx
.text$mn:00000768                 mov     eax, [ebp+arg_0]
.text$mn:0000076B                 push    eax             ; void *
.text$mn:0000076C                 push    8               ; unsigned int
.text$mn:0000076E                 call    ??2@YAPAXIPAX@Z ; operator new(uint,void *)
.text$mn:00000773                 add     esp, 8
.text$mn:00000776                 mov     [ebp+var_10], eax
.text$mn:00000779                 mov     [ebp+var_4], 0
.text$mn:00000780                 cmp     [ebp+var_10], 0
.text$mn:00000784                 jz      short loc_7A7
.text$mn:00000786                 mov     ecx, [ebp+arg_4]
.text$mn:00000789                 push    ecx
.text$mn:0000078A                 call    ??$forward@U_Container_proxy@std@@@std@@YA$$QAU_Container_proxy@0@AAU10@@Z ; std::forward<std::_Container_proxy>(std::_Container_proxy &)
.text$mn:0000078F                 add     esp, 4
.text$mn:00000792                 mov     edx, [eax]
.text$mn:00000794                 mov     eax, [eax+4]
.text$mn:00000797                 mov     ecx, [ebp+var_10]
.text$mn:0000079A                 mov     [ecx], edx
.text$mn:0000079C                 mov     [ecx+4], eax
.text$mn:0000079F                 mov     edx, [ebp+var_10]
.text$mn:000007A2                 mov     [ebp+var_14], edx
.text$mn:000007A5                 jmp     short loc_7AE
.text$mn:000007A7 ; ---------------------------------------------------------------------------
.text$mn:000007A7
.text$mn:000007A7 loc_7A7:                                ; CODE XREF: std::allocator<std::_Container_proxy>::construct<std::_Container_proxy,std::_Container_proxy>(std::_Container_proxy *,std::_Container_proxy &&)+44j
.text$mn:000007A7                 mov     [ebp+var_14], 0
.text$mn:000007AE
.text$mn:000007AE loc_7AE:                                ; CODE XREF: std::allocator<std::_Container_proxy>::construct<std::_Container_proxy,std::_Container_proxy>(std::_Container_proxy *,std::_Container_proxy &&)+65j
.text$mn:000007AE                 mov     eax, [ebp+var_14]
.text$mn:000007B1                 mov     [ebp+var_1C], eax
.text$mn:000007B4                 mov     [ebp+var_4], 0FFFFFFFFh
.text$mn:000007BB                 mov     ecx, [ebp+var_C]
.text$mn:000007BE                 mov     large fs:0, ecx
.text$mn:000007C5                 pop     ecx
.text$mn:000007C6                 mov     esp, ebp
.text$mn:000007C8                 pop     ebp
.text$mn:000007C9                 retn    8
.text$mn:000007C9 ??$construct@U_Container_proxy@std@@U12@@?$allocator@U_Container_proxy@std@@@std@@QAEXPAU_Container_proxy@1@$$QAU21@@Z endp
.text$mn:000007C9
.text$mn:000007C9 _text$mn        ends
.text$mn:000007C9
.text$x:000007CC ; ===========================================================================
.text$x:000007CC
.text$x:000007CC ; Segment type: Pure code
.text$x:000007CC ; Segment permissions: Read/Execute
.text$x:000007CC _text$x         segment para public 'CODE' use32
.text$x:000007CC                 assume cs:_text$x
.text$x:000007CC                 ;org 7CCh
.text$x:000007CC ; COMDAT (pick associative to section at 740)
.text$x:000007CC                 assume es:nothing, ss:nothing, ds:_xdata$x, fs:nothing, gs:nothing
.text$x:000007CC
.text$x:000007CC ; =============== S U B R O U T I N E =======================================
.text$x:000007CC
.text$x:000007CC
.text$x:000007CC __unwindfunclet$??$construct@U_Container_proxy@std@@U12@@?$allocator@U_Container_proxy@std@@@std@@QAEXPAU_Container_proxy@1@$$QAU21@@Z$0 proc near
.text$x:000007CC                                         ; DATA XREF: .xdata$x:00002BC8o
.text$x:000007CC                 mov     eax, [ebp+8]
.text$x:000007CF                 push    eax
.text$x:000007D0                 mov     eax, [ebp-10h]
.text$x:000007D3                 push    eax             ; void *
.text$x:000007D4                 call    ??3@YAXPAX0@Z   ; operator delete(void *,void *)
.text$x:000007D9                 add     esp, 8
.text$x:000007DC                 retn
.text$x:000007DC __unwindfunclet$??$construct@U_Container_proxy@std@@U12@@?$allocator@U_Container_proxy@std@@@std@@QAEXPAU_Container_proxy@1@$$QAU21@@Z$0 endp
.text$x:000007DC
.text$x:000007DD
.text$x:000007DD ; =============== S U B R O U T I N E =======================================
.text$x:000007DD
.text$x:000007DD
.text$x:000007DD __ehhandler$??$construct@U_Container_proxy@std@@U12@@?$allocator@U_Container_proxy@std@@@std@@QAEXPAU_Container_proxy@1@$$QAU21@@Z proc near
.text$x:000007DD                                         ; DATA XREF: std::allocator<std::_Container_proxy>::construct<std::_Container_proxy,std::_Container_proxy>(std::_Container_proxy *,std::_Container_proxy &&)+5o
.text$x:000007DD
.text$x:000007DD arg_4           = dword ptr  8
.text$x:000007DD
.text$x:000007DD                 mov     edx, [esp+arg_4]
.text$x:000007E1                 lea     eax, [edx+0Ch]
.text$x:000007E4                 mov     ecx, [edx-14h]
.text$x:000007E7                 xor     ecx, eax
.text$x:000007E9                 call    @__security_check_cookie@4 ; __security_check_cookie(x)
.text$x:000007EE                 mov     eax, offset __ehfuncinfo$??$construct@U_Container_proxy@std@@U12@@?$allocator@U_Container_proxy@std@@@std@@QAEXPAU_Container_proxy@1@$$QAU21@@Z
.text$x:000007F3                 jmp     ___CxxFrameHandler3
.text$x:000007F3 __ehhandler$??$construct@U_Container_proxy@std@@U12@@?$allocator@U_Container_proxy@std@@@std@@QAEXPAU_Container_proxy@1@$$QAU21@@Z endp
.text$x:000007F3
.text$x:000007F3 _text$x         ends
.text$x:000007F3
.text$mn:000007F8 ; ===========================================================================
.text$mn:000007F8
.text$mn:000007F8 ; Segment type: Pure code
.text$mn:000007F8 ; Segment permissions: Read/Execute
.text$mn:000007F8 _text$mn        segment para public 'CODE' use32
.text$mn:000007F8                 assume cs:_text$mn
.text$mn:000007F8                 ;org 7F8h
.text$mn:000007F8 ; COMDAT (pick any)
.text$mn:000007F8                 assume es:nothing, ss:nothing, ds:_xdata$x, fs:nothing, gs:nothing
.text$mn:000007F8
.text$mn:000007F8 ; =============== S U B R O U T I N E =======================================
.text$mn:000007F8
.text$mn:000007F8 ; Attributes: bp-based frame
.text$mn:000007F8
.text$mn:000007F8 ; public: void __thiscall std::_Wrap_alloc<class std::allocator<char>>::destroy<char *>(char * *)
.text$mn:000007F8                 public ??$destroy@PAD@?$_Wrap_alloc@V?$allocator@D@std@@@std@@QAEXPAPAD@Z
.text$mn:000007F8 ??$destroy@PAD@?$_Wrap_alloc@V?$allocator@D@std@@@std@@QAEXPAPAD@Z proc near
.text$mn:000007F8                                         ; CODE XREF: std::basic_string<char,std::char_traits<char>,std::allocator<char>>::_Tidy(bool,uint)+3Ap
.text$mn:000007F8
.text$mn:000007F8 var_4           = dword ptr -4
.text$mn:000007F8 arg_0           = dword ptr  8
.text$mn:000007F8
.text$mn:000007F8                 push    ebp
.text$mn:000007F9                 mov     ebp, esp
.text$mn:000007FB                 push    ecx
.text$mn:000007FC                 mov     [ebp+var_4], ecx
.text$mn:000007FF                 mov     eax, [ebp+arg_0]
.text$mn:00000802                 push    eax
.text$mn:00000803                 mov     ecx, [ebp+var_4]
.text$mn:00000806                 push    ecx
.text$mn:00000807                 call    ??$destroy@PAD@?$allocator_traits@V?$allocator@D@std@@@std@@SAXAAV?$allocator@D@1@PAPAD@Z ; std::allocator_traits<std::allocator<char>>::destroy<char *>(std::allocator<char> &,char * *)
.text$mn:0000080C                 add     esp, 8
.text$mn:0000080F                 mov     esp, ebp
.text$mn:00000811                 pop     ebp
.text$mn:00000812                 retn    4
.text$mn:00000812 ??$destroy@PAD@?$_Wrap_alloc@V?$allocator@D@std@@@std@@QAEXPAPAD@Z endp
.text$mn:00000812
.text$mn:00000812 ; ---------------------------------------------------------------------------
.text$mn:00000815                 align 4
.text$mn:00000815 _text$mn        ends
.text$mn:00000815
.text$mn:00000818 ; ===========================================================================
.text$mn:00000818
.text$mn:00000818 ; Segment type: Pure code
.text$mn:00000818 ; Segment permissions: Read/Execute
.text$mn:00000818 _text$mn        segment para public 'CODE' use32
.text$mn:00000818                 assume cs:_text$mn
.text$mn:00000818                 ;org 818h
.text$mn:00000818 ; COMDAT (pick any)
.text$mn:00000818                 assume es:nothing, ss:nothing, ds:_xdata$x, fs:nothing, gs:nothing
.text$mn:00000818
.text$mn:00000818 ; =============== S U B R O U T I N E =======================================
.text$mn:00000818
.text$mn:00000818 ; Attributes: bp-based frame
.text$mn:00000818
.text$mn:00000818 ; public: void __thiscall std::allocator<char>::destroy<char *>(char * *)
.text$mn:00000818                 public ??$destroy@PAD@?$allocator@D@std@@QAEXPAPAD@Z
.text$mn:00000818 ??$destroy@PAD@?$allocator@D@std@@QAEXPAPAD@Z proc near
.text$mn:00000818                                         ; CODE XREF: std::allocator_traits<std::allocator<char>>::destroy<char *>(std::allocator<char> &,char * *)+Ap
.text$mn:00000818
.text$mn:00000818 var_4           = dword ptr -4
.text$mn:00000818
.text$mn:00000818                 push    ebp
.text$mn:00000819                 mov     ebp, esp
.text$mn:0000081B                 push    ecx
.text$mn:0000081C                 mov     [ebp+var_4], ecx
.text$mn:0000081F                 mov     esp, ebp
.text$mn:00000821                 pop     ebp
.text$mn:00000822                 retn    4
.text$mn:00000822 ??$destroy@PAD@?$allocator@D@std@@QAEXPAPAD@Z endp
.text$mn:00000822
.text$mn:00000822 ; ---------------------------------------------------------------------------
.text$mn:00000825                 align 4
.text$mn:00000825 _text$mn        ends
.text$mn:00000825
.text$mn:00000828 ; ===========================================================================
.text$mn:00000828
.text$mn:00000828 ; Segment type: Pure code
.text$mn:00000828 ; Segment permissions: Read/Execute
.text$mn:00000828 _text$mn        segment para public 'CODE' use32
.text$mn:00000828                 assume cs:_text$mn
.text$mn:00000828                 ;org 828h
.text$mn:00000828 ; COMDAT (pick any)
.text$mn:00000828                 assume es:nothing, ss:nothing, ds:_xdata$x, fs:nothing, gs:nothing
.text$mn:00000828
.text$mn:00000828 ; =============== S U B R O U T I N E =======================================
.text$mn:00000828
.text$mn:00000828 ; Attributes: bp-based frame
.text$mn:00000828
.text$mn:00000828 ; public: static void __cdecl std::allocator_traits<class std::allocator<char>>::destroy<char *>(class std::allocator<char> &, char * *)
.text$mn:00000828                 public ??$destroy@PAD@?$allocator_traits@V?$allocator@D@std@@@std@@SAXAAV?$allocator@D@1@PAPAD@Z
.text$mn:00000828 ??$destroy@PAD@?$allocator_traits@V?$allocator@D@std@@@std@@SAXAAV?$allocator@D@1@PAPAD@Z proc near
.text$mn:00000828                                         ; CODE XREF: std::_Wrap_alloc<std::allocator<char>>::destroy<char *>(char * *)+Fp
.text$mn:00000828
.text$mn:00000828 arg_0           = dword ptr  8
.text$mn:00000828 arg_4           = dword ptr  0Ch
.text$mn:00000828
.text$mn:00000828                 push    ebp
.text$mn:00000829                 mov     ebp, esp
.text$mn:0000082B                 mov     eax, [ebp+arg_4]
.text$mn:0000082E                 push    eax
.text$mn:0000082F                 mov     ecx, [ebp+arg_0]
.text$mn:00000832                 call    ??$destroy@PAD@?$allocator@D@std@@QAEXPAPAD@Z ; std::allocator<char>::destroy<char *>(char * *)
.text$mn:00000837                 pop     ebp
.text$mn:00000838                 retn
.text$mn:00000838 ??$destroy@PAD@?$allocator_traits@V?$allocator@D@std@@@std@@SAXAAV?$allocator@D@1@PAPAD@Z endp
.text$mn:00000838
.text$mn:00000838 ; ---------------------------------------------------------------------------
.text$mn:00000839                 align 4
.text$mn:00000839 _text$mn        ends
.text$mn:00000839
.text$mn:0000083C ; ===========================================================================
.text$mn:0000083C
.text$mn:0000083C ; Segment type: Pure code
.text$mn:0000083C ; Segment permissions: Read/Execute
.text$mn:0000083C _text$mn        segment para public 'CODE' use32
.text$mn:0000083C                 assume cs:_text$mn
.text$mn:0000083C                 ;org 83Ch
.text$mn:0000083C ; COMDAT (pick any)
.text$mn:0000083C                 assume es:nothing, ss:nothing, ds:_xdata$x, fs:nothing, gs:nothing
.text$mn:0000083C
.text$mn:0000083C ; =============== S U B R O U T I N E =======================================
.text$mn:0000083C
.text$mn:0000083C ; Attributes: bp-based frame
.text$mn:0000083C
.text$mn:0000083C ; public: void __thiscall std::_Wrap_alloc<class std::allocator<wchar_t>>::destroy<wchar_t *>(wchar_t * *)
.text$mn:0000083C                 public ??$destroy@PA_W@?$_Wrap_alloc@V?$allocator@_W@std@@@std@@QAEXPAPA_W@Z
.text$mn:0000083C ??$destroy@PA_W@?$_Wrap_alloc@V?$allocator@_W@std@@@std@@QAEXPAPA_W@Z proc near
.text$mn:0000083C                                         ; CODE XREF: std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>>::_Tidy(bool,uint)+3Ap
.text$mn:0000083C
.text$mn:0000083C var_4           = dword ptr -4
.text$mn:0000083C arg_0           = dword ptr  8
.text$mn:0000083C
.text$mn:0000083C                 push    ebp
.text$mn:0000083D                 mov     ebp, esp
.text$mn:0000083F                 push    ecx
.text$mn:00000840                 mov     [ebp+var_4], ecx
.text$mn:00000843                 mov     eax, [ebp+arg_0]
.text$mn:00000846                 push    eax
.text$mn:00000847                 mov     ecx, [ebp+var_4]
.text$mn:0000084A                 push    ecx
.text$mn:0000084B                 call    ??$destroy@PA_W@?$allocator_traits@V?$allocator@_W@std@@@std@@SAXAAV?$allocator@_W@1@PAPA_W@Z ; std::allocator_traits<std::allocator<wchar_t>>::destroy<wchar_t *>(std::allocator<wchar_t> &,wchar_t * *)
.text$mn:00000850                 add     esp, 8
.text$mn:00000853                 mov     esp, ebp
.text$mn:00000855                 pop     ebp
.text$mn:00000856                 retn    4
.text$mn:00000856 ??$destroy@PA_W@?$_Wrap_alloc@V?$allocator@_W@std@@@std@@QAEXPAPA_W@Z endp
.text$mn:00000856
.text$mn:00000856 ; ---------------------------------------------------------------------------
.text$mn:00000859                 align 4
.text$mn:00000859 _text$mn        ends
.text$mn:00000859
.text$mn:0000085C ; ===========================================================================
.text$mn:0000085C
.text$mn:0000085C ; Segment type: Pure code
.text$mn:0000085C ; Segment permissions: Read/Execute
.text$mn:0000085C _text$mn        segment para public 'CODE' use32
.text$mn:0000085C                 assume cs:_text$mn
.text$mn:0000085C                 ;org 85Ch
.text$mn:0000085C ; COMDAT (pick any)
.text$mn:0000085C                 assume es:nothing, ss:nothing, ds:_xdata$x, fs:nothing, gs:nothing
.text$mn:0000085C
.text$mn:0000085C ; =============== S U B R O U T I N E =======================================
.text$mn:0000085C
.text$mn:0000085C ; Attributes: bp-based frame
.text$mn:0000085C
.text$mn:0000085C ; public: void __thiscall std::allocator<wchar_t>::destroy<wchar_t *>(wchar_t * *)
.text$mn:0000085C                 public ??$destroy@PA_W@?$allocator@_W@std@@QAEXPAPA_W@Z
.text$mn:0000085C ??$destroy@PA_W@?$allocator@_W@std@@QAEXPAPA_W@Z proc near
.text$mn:0000085C                                         ; CODE XREF: std::allocator_traits<std::allocator<wchar_t>>::destroy<wchar_t *>(std::allocator<wchar_t> &,wchar_t * *)+Ap
.text$mn:0000085C
.text$mn:0000085C var_4           = dword ptr -4
.text$mn:0000085C
.text$mn:0000085C                 push    ebp
.text$mn:0000085D                 mov     ebp, esp
.text$mn:0000085F                 push    ecx
.text$mn:00000860                 mov     [ebp+var_4], ecx
.text$mn:00000863                 mov     esp, ebp
.text$mn:00000865                 pop     ebp
.text$mn:00000866                 retn    4
.text$mn:00000866 ??$destroy@PA_W@?$allocator@_W@std@@QAEXPAPA_W@Z endp
.text$mn:00000866
.text$mn:00000866 ; ---------------------------------------------------------------------------
.text$mn:00000869                 align 4
.text$mn:00000869 _text$mn        ends
.text$mn:00000869
.text$mn:0000086C ; ===========================================================================
.text$mn:0000086C
.text$mn:0000086C ; Segment type: Pure code
.text$mn:0000086C ; Segment permissions: Read/Execute
.text$mn:0000086C _text$mn        segment para public 'CODE' use32
.text$mn:0000086C                 assume cs:_text$mn
.text$mn:0000086C                 ;org 86Ch
.text$mn:0000086C ; COMDAT (pick any)
.text$mn:0000086C                 assume es:nothing, ss:nothing, ds:_xdata$x, fs:nothing, gs:nothing
.text$mn:0000086C
.text$mn:0000086C ; =============== S U B R O U T I N E =======================================
.text$mn:0000086C
.text$mn:0000086C ; Attributes: bp-based frame
.text$mn:0000086C
.text$mn:0000086C ; public: static void __cdecl std::allocator_traits<class std::allocator<wchar_t>>::destroy<wchar_t *>(class std::allocator<wchar_t> &, wchar_t * *)
.text$mn:0000086C                 public ??$destroy@PA_W@?$allocator_traits@V?$allocator@_W@std@@@std@@SAXAAV?$allocator@_W@1@PAPA_W@Z
.text$mn:0000086C ??$destroy@PA_W@?$allocator_traits@V?$allocator@_W@std@@@std@@SAXAAV?$allocator@_W@1@PAPA_W@Z proc near
.text$mn:0000086C                                         ; CODE XREF: std::_Wrap_alloc<std::allocator<wchar_t>>::destroy<wchar_t *>(wchar_t * *)+Fp
.text$mn:0000086C
.text$mn:0000086C arg_0           = dword ptr  8
.text$mn:0000086C arg_4           = dword ptr  0Ch
.text$mn:0000086C
.text$mn:0000086C                 push    ebp
.text$mn:0000086D                 mov     ebp, esp
.text$mn:0000086F                 mov     eax, [ebp+arg_4]
.text$mn:00000872                 push    eax
.text$mn:00000873                 mov     ecx, [ebp+arg_0]
.text$mn:00000876                 call    ??$destroy@PA_W@?$allocator@_W@std@@QAEXPAPA_W@Z ; std::allocator<wchar_t>::destroy<wchar_t *>(wchar_t * *)
.text$mn:0000087B                 pop     ebp
.text$mn:0000087C                 retn
.text$mn:0000087C ??$destroy@PA_W@?$allocator_traits@V?$allocator@_W@std@@@std@@SAXAAV?$allocator@_W@1@PAPA_W@Z endp
.text$mn:0000087C
.text$mn:0000087C ; ---------------------------------------------------------------------------
.text$mn:0000087D                 align 10h
.text$mn:0000087D _text$mn        ends
.text$mn:0000087D
.text$mn:00000880 ; ===========================================================================
.text$mn:00000880
.text$mn:00000880 ; Segment type: Pure code
.text$mn:00000880 ; Segment permissions: Read/Execute
.text$mn:00000880 _text$mn        segment para public 'CODE' use32
.text$mn:00000880                 assume cs:_text$mn
.text$mn:00000880                 ;org 880h
.text$mn:00000880 ; COMDAT (pick any)
.text$mn:00000880                 assume es:nothing, ss:nothing, ds:_xdata$x, fs:nothing, gs:nothing
.text$mn:00000880
.text$mn:00000880 ; =============== S U B R O U T I N E =======================================
.text$mn:00000880
.text$mn:00000880 ; Attributes: bp-based frame
.text$mn:00000880
.text$mn:00000880 ; public: void __thiscall std::allocator<struct std::_Container_proxy>::destroy<struct std::_Container_proxy>(struct std::_Container_proxy *)
.text$mn:00000880                 public ??$destroy@U_Container_proxy@std@@@?$allocator@U_Container_proxy@std@@@std@@QAEXPAU_Container_proxy@1@@Z
.text$mn:00000880 ??$destroy@U_Container_proxy@std@@@?$allocator@U_Container_proxy@std@@@std@@QAEXPAU_Container_proxy@1@@Z proc near
.text$mn:00000880                                         ; CODE XREF: std::_String_alloc<0,std::_String_base_types<char,std::allocator<char>>>::_Free_proxy(void)+22p
.text$mn:00000880
.text$mn:00000880 var_4           = dword ptr -4
.text$mn:00000880
.text$mn:00000880                 push    ebp
.text$mn:00000881                 mov     ebp, esp
.text$mn:00000883                 push    ecx
.text$mn:00000884                 mov     [ebp+var_4], ecx
.text$mn:00000887                 mov     esp, ebp
.text$mn:00000889                 pop     ebp
.text$mn:0000088A                 retn    4
.text$mn:0000088A ??$destroy@U_Container_proxy@std@@@?$allocator@U_Container_proxy@std@@@std@@QAEXPAU_Container_proxy@1@@Z endp
.text$mn:0000088A
.text$mn:0000088A ; ---------------------------------------------------------------------------
.text$mn:0000088D                 align 10h
.text$mn:0000088D _text$mn        ends
.text$mn:0000088D
.text$mn:00000890 ; ===========================================================================
.text$mn:00000890
.text$mn:00000890 ; Segment type: Pure code
.text$mn:00000890 ; Segment permissions: Read/Execute
.text$mn:00000890 _text$mn        segment para public 'CODE' use32
.text$mn:00000890                 assume cs:_text$mn
.text$mn:00000890                 ;org 890h
.text$mn:00000890 ; COMDAT (pick any)
.text$mn:00000890                 assume es:nothing, ss:nothing, ds:_xdata$x, fs:nothing, gs:nothing
.text$mn:00000890
.text$mn:00000890 ; =============== S U B R O U T I N E =======================================
.text$mn:00000890
.text$mn:00000890 ; Attributes: bp-based frame
.text$mn:00000890
.text$mn:00000890 ; char * & __cdecl std::forward<char * &>(char * &)
.text$mn:00000890                 public ??$forward@AAPAD@std@@YAAAPADAAPAD@Z
.text$mn:00000890 ??$forward@AAPAD@std@@YAAAPADAAPAD@Z proc near
.text$mn:00000890                                         ; CODE XREF: std::_Wrap_alloc<std::allocator<char>>::construct<char *,char * &>(char * *,char * &)+Bp
.text$mn:00000890                                         ; std::allocator<char>::construct<char *,char * &>(char * *,char * &)+4Ap ...
.text$mn:00000890
.text$mn:00000890 arg_0           = dword ptr  8
.text$mn:00000890
.text$mn:00000890                 push    ebp
.text$mn:00000891                 mov     ebp, esp
.text$mn:00000893                 mov     eax, [ebp+arg_0]
.text$mn:00000896                 pop     ebp
.text$mn:00000897                 retn
.text$mn:00000897 ??$forward@AAPAD@std@@YAAAPADAAPAD@Z endp
.text$mn:00000897
.text$mn:00000897 _text$mn        ends
.text$mn:00000897
.text$mn:00000898 ; ===========================================================================
.text$mn:00000898
.text$mn:00000898 ; Segment type: Pure code
.text$mn:00000898 ; Segment permissions: Read/Execute
.text$mn:00000898 _text$mn        segment para public 'CODE' use32
.text$mn:00000898                 assume cs:_text$mn
.text$mn:00000898                 ;org 898h
.text$mn:00000898 ; COMDAT (pick any)
.text$mn:00000898                 assume es:nothing, ss:nothing, ds:_xdata$x, fs:nothing, gs:nothing
.text$mn:00000898
.text$mn:00000898 ; =============== S U B R O U T I N E =======================================
.text$mn:00000898
.text$mn:00000898 ; Attributes: bp-based frame
.text$mn:00000898
.text$mn:00000898 ; wchar_t * & __cdecl std::forward<wchar_t * &>(wchar_t * &)
.text$mn:00000898                 public ??$forward@AAPA_W@std@@YAAAPA_WAAPA_W@Z
.text$mn:00000898 ??$forward@AAPA_W@std@@YAAAPA_WAAPA_W@Z proc near
.text$mn:00000898                                         ; CODE XREF: std::_Wrap_alloc<std::allocator<wchar_t>>::construct<wchar_t *,wchar_t * &>(wchar_t * *,wchar_t * &)+Bp
.text$mn:00000898                                         ; std::allocator<wchar_t>::construct<wchar_t *,wchar_t * &>(wchar_t * *,wchar_t * &)+4Ap ...
.text$mn:00000898
.text$mn:00000898 arg_0           = dword ptr  8
.text$mn:00000898
.text$mn:00000898                 push    ebp
.text$mn:00000899                 mov     ebp, esp
.text$mn:0000089B                 mov     eax, [ebp+arg_0]
.text$mn:0000089E                 pop     ebp
.text$mn:0000089F                 retn
.text$mn:0000089F ??$forward@AAPA_W@std@@YAAAPA_WAAPA_W@Z endp
.text$mn:0000089F
.text$mn:0000089F _text$mn        ends
.text$mn:0000089F
.text$mn:000008A0 ; ===========================================================================
.text$mn:000008A0
.text$mn:000008A0 ; Segment type: Pure code
.text$mn:000008A0 ; Segment permissions: Read/Execute
.text$mn:000008A0 _text$mn        segment para public 'CODE' use32
.text$mn:000008A0                 assume cs:_text$mn
.text$mn:000008A0                 ;org 8A0h
.text$mn:000008A0 ; COMDAT (pick any)
.text$mn:000008A0                 assume es:nothing, ss:nothing, ds:_xdata$x, fs:nothing, gs:nothing
.text$mn:000008A0
.text$mn:000008A0 ; =============== S U B R O U T I N E =======================================
.text$mn:000008A0
.text$mn:000008A0 ; Attributes: bp-based frame
.text$mn:000008A0
.text$mn:000008A0 ; struct std::_Container_proxy && __cdecl std::forward<struct std::_Container_proxy>(struct std::_Container_proxy &)
.text$mn:000008A0                 public ??$forward@U_Container_proxy@std@@@std@@YA$$QAU_Container_proxy@0@AAU10@@Z
.text$mn:000008A0 ??$forward@U_Container_proxy@std@@@std@@YA$$QAU_Container_proxy@0@AAU10@@Z proc near
.text$mn:000008A0                                         ; CODE XREF: std::allocator<std::_Container_proxy>::construct<std::_Container_proxy,std::_Container_proxy>(std::_Container_proxy *,std::_Container_proxy &&)+4Ap
.text$mn:000008A0
.text$mn:000008A0 arg_0           = dword ptr  8
.text$mn:000008A0
.text$mn:000008A0                 push    ebp
.text$mn:000008A1                 mov     ebp, esp
.text$mn:000008A3                 mov     eax, [ebp+arg_0]
.text$mn:000008A6                 pop     ebp
.text$mn:000008A7                 retn
.text$mn:000008A7 ??$forward@U_Container_proxy@std@@@std@@YA$$QAU_Container_proxy@0@AAU10@@Z endp
.text$mn:000008A7
.text$mn:000008A7 _text$mn        ends
.text$mn:000008A7
.text$mn:000008A8 ; ===========================================================================
.text$mn:000008A8
.text$mn:000008A8 ; Segment type: Pure code
.text$mn:000008A8 ; Segment permissions: Read/Execute
.text$mn:000008A8 _text$mn        segment para public 'CODE' use32
.text$mn:000008A8                 assume cs:_text$mn
.text$mn:000008A8                 ;org 8A8h
.text$mn:000008A8 ; COMDAT (pick any)
.text$mn:000008A8                 assume es:nothing, ss:nothing, ds:_xdata$x, fs:nothing, gs:nothing
.text$mn:000008A8
.text$mn:000008A8 ; =============== S U B R O U T I N E =======================================
.text$mn:000008A8
.text$mn:000008A8 ; Attributes: bp-based frame
.text$mn:000008A8
.text$mn:000008A8 ; public: __thiscall std::_String_alloc<0, struct std::_String_base_types<char, class std::allocator<char>>>::_String_alloc<0, struct std::_String_base_types<char, class std::allocator<char>>>(class std::allocator<char> const &)
.text$mn:000008A8                 public ??0?$_String_alloc@$0A@U?$_String_base_types@DV?$allocator@D@std@@@std@@@std@@QAE@ABV?$allocator@D@1@@Z
.text$mn:000008A8 ??0?$_String_alloc@$0A@U?$_String_base_types@DV?$allocator@D@std@@@std@@@std@@QAE@ABV?$allocator@D@1@@Z proc near
.text$mn:000008A8                                         ; CODE XREF: std::basic_string<char,std::char_traits<char>,std::allocator<char>>::basic_string<char,std::char_traits<char>,std::allocator<char>>(char const *)+34p
.text$mn:000008A8
.text$mn:000008A8 var_10          = dword ptr -10h
.text$mn:000008A8 var_C           = dword ptr -0Ch
.text$mn:000008A8 var_4           = dword ptr -4
.text$mn:000008A8
.text$mn:000008A8                 push    ebp
.text$mn:000008A9                 mov     ebp, esp
.text$mn:000008AB                 push    0FFFFFFFFh
.text$mn:000008AD                 push    offset __ehhandler$??0?$_String_alloc@$0A@U?$_String_base_types@DV?$allocator@D@std@@@std@@@std@@QAE@ABV?$allocator@D@1@@Z
.text$mn:000008B2                 mov     eax, large fs:0
.text$mn:000008B8                 push    eax
.text$mn:000008B9                 push    ecx
.text$mn:000008BA                 mov     eax, dword ptr ds:___security_cookie
.text$mn:000008BF                 xor     eax, ebp
.text$mn:000008C1                 push    eax
.text$mn:000008C2                 lea     eax, [ebp+var_C]
.text$mn:000008C5                 mov     large fs:0, eax
.text$mn:000008CB                 mov     [ebp+var_10], ecx
.text$mn:000008CE                 mov     ecx, [ebp+var_10]
.text$mn:000008D1                 call    ??0?$_String_val@U?$_Simple_types@D@std@@@std@@QAE@XZ ; std::_String_val<std::_Simple_types<char>>::_String_val<std::_Simple_types<char>>(void)
.text$mn:000008D6                 mov     [ebp+var_4], 0
.text$mn:000008DD                 mov     ecx, [ebp+var_10]
.text$mn:000008E0                 call    ?_Alloc_proxy@?$_String_alloc@$0A@U?$_String_base_types@DV?$allocator@D@std@@@std@@@std@@QAEXXZ ; std::_String_alloc<0,std::_String_base_types<char,std::allocator<char>>>::_Alloc_proxy(void)
.text$mn:000008E5                 mov     [ebp+var_4], 0FFFFFFFFh
.text$mn:000008EC                 mov     eax, [ebp+var_10]
.text$mn:000008EF                 mov     ecx, [ebp+var_C]
.text$mn:000008F2                 mov     large fs:0, ecx
.text$mn:000008F9                 pop     ecx
.text$mn:000008FA                 mov     esp, ebp
.text$mn:000008FC                 pop     ebp
.text$mn:000008FD                 retn    4
.text$mn:000008FD ??0?$_String_alloc@$0A@U?$_String_base_types@DV?$allocator@D@std@@@std@@@std@@QAE@ABV?$allocator@D@1@@Z endp
.text$mn:000008FD
.text$mn:000008FD _text$mn        ends
.text$mn:000008FD
.text$x:00000900 ; ===========================================================================
.text$x:00000900
.text$x:00000900 ; Segment type: Pure code
.text$x:00000900 ; Segment permissions: Read/Execute
.text$x:00000900 _text$x         segment para public 'CODE' use32
.text$x:00000900                 assume cs:_text$x
.text$x:00000900                 ;org 900h
.text$x:00000900 ; COMDAT (pick associative to section at 8A8)
.text$x:00000900                 assume es:nothing, ss:nothing, ds:_xdata$x, fs:nothing, gs:nothing
.text$x:00000900
.text$x:00000900 ; =============== S U B R O U T I N E =======================================
.text$x:00000900
.text$x:00000900
.text$x:00000900 __unwindfunclet$??0?$_String_alloc@$0A@U?$_String_base_types@DV?$allocator@D@std@@@std@@@std@@QAE@ABV?$allocator@D@1@@Z$0 proc near
.text$x:00000900                                         ; DATA XREF: .xdata$x:00002874o
.text$x:00000900                 mov     ecx, [ebp-10h]
.text$x:00000903                 jmp     ??1?$_String_val@U?$_Simple_types@D@std@@@std@@QAE@XZ ; std::_String_val<std::_Simple_types<char>>::~_String_val<std::_Simple_types<char>>(void)
.text$x:00000903 __unwindfunclet$??0?$_String_alloc@$0A@U?$_String_base_types@DV?$allocator@D@std@@@std@@@std@@QAE@ABV?$allocator@D@1@@Z$0 endp
.text$x:00000903
.text$x:00000908
.text$x:00000908 ; =============== S U B R O U T I N E =======================================
.text$x:00000908
.text$x:00000908
.text$x:00000908 __ehhandler$??0?$_String_alloc@$0A@U?$_String_base_types@DV?$allocator@D@std@@@std@@@std@@QAE@ABV?$allocator@D@1@@Z proc near
.text$x:00000908                                         ; DATA XREF: std::_String_alloc<0,std::_String_base_types<char,std::allocator<char>>>::_String_alloc<0,std::_String_base_types<char,std::allocator<char>>>(std::allocator<char> const &)+5o
.text$x:00000908
.text$x:00000908 arg_4           = dword ptr  8
.text$x:00000908
.text$x:00000908                 mov     edx, [esp+arg_4]
.text$x:0000090C                 lea     eax, [edx+0Ch]
.text$x:0000090F                 mov     ecx, [edx-8]
.text$x:00000912                 xor     ecx, eax
.text$x:00000914                 call    @__security_check_cookie@4 ; __security_check_cookie(x)
.text$x:00000919                 mov     eax, offset __ehfuncinfo$??0?$_String_alloc@$0A@U?$_String_base_types@DV?$allocator@D@std@@@std@@@std@@QAE@ABV?$allocator@D@1@@Z
.text$x:0000091E                 jmp     ___CxxFrameHandler3
.text$x:0000091E __ehhandler$??0?$_String_alloc@$0A@U?$_String_base_types@DV?$allocator@D@std@@@std@@@std@@QAE@ABV?$allocator@D@1@@Z endp
.text$x:0000091E
.text$x:0000091E ; ---------------------------------------------------------------------------
.text$x:00000923                 align 4
.text$x:00000923 _text$x         ends
.text$x:00000923
.text$mn:00000924 ; ===========================================================================
.text$mn:00000924
.text$mn:00000924 ; Segment type: Pure code
.text$mn:00000924 ; Segment permissions: Read/Execute
.text$mn:00000924 _text$mn        segment para public 'CODE' use32
.text$mn:00000924                 assume cs:_text$mn
.text$mn:00000924                 ;org 924h
.text$mn:00000924 ; COMDAT (pick any)
.text$mn:00000924                 assume es:nothing, ss:nothing, ds:_xdata$x, fs:nothing, gs:nothing
.text$mn:00000924
.text$mn:00000924 ; =============== S U B R O U T I N E =======================================
.text$mn:00000924
.text$mn:00000924 ; Attributes: bp-based frame
.text$mn:00000924
.text$mn:00000924 ; public: __thiscall std::_String_val<struct std::_Simple_types<char>>::_String_val<struct std::_Simple_types<char>>(void)
.text$mn:00000924                 public ??0?$_String_val@U?$_Simple_types@D@std@@@std@@QAE@XZ
.text$mn:00000924 ??0?$_String_val@U?$_Simple_types@D@std@@@std@@QAE@XZ proc near
.text$mn:00000924                                         ; CODE XREF: std::_String_alloc<0,std::_String_base_types<char,std::allocator<char>>>::_String_alloc<0,std::_String_base_types<char,std::allocator<char>>>(std::allocator<char> const &)+29p
.text$mn:00000924
.text$mn:00000924 var_10          = dword ptr -10h
.text$mn:00000924 var_C           = dword ptr -0Ch
.text$mn:00000924 var_4           = dword ptr -4
.text$mn:00000924
.text$mn:00000924                 push    ebp
.text$mn:00000925                 mov     ebp, esp
.text$mn:00000927                 push    0FFFFFFFFh
.text$mn:00000929                 push    offset __ehhandler$??0?$_String_val@U?$_Simple_types@D@std@@@std@@QAE@XZ
.text$mn:0000092E                 mov     eax, large fs:0
.text$mn:00000934                 push    eax
.text$mn:00000935                 push    ecx
.text$mn:00000936                 mov     eax, dword ptr ds:___security_cookie
.text$mn:0000093B                 xor     eax, ebp
.text$mn:0000093D                 push    eax
.text$mn:0000093E                 lea     eax, [ebp+var_C]
.text$mn:00000941                 mov     large fs:0, eax
.text$mn:00000947                 mov     [ebp+var_10], ecx
.text$mn:0000094A                 mov     ecx, [ebp+var_10] ; this
.text$mn:0000094D                 call    ??0_Container_base12@std@@QAE@XZ ; std::_Container_base12::_Container_base12(void)
.text$mn:00000952                 mov     [ebp+var_4], 0
.text$mn:00000959                 mov     eax, [ebp+var_10]
.text$mn:0000095C
.text$mn:0000095C loc_95C:                                ; DATA XREF: ValueDlg::doDialog(tagPOINT,bool)+7Eo
.text$mn:0000095C                 mov     dword ptr [eax+14h], 0
.text$mn:00000963                 mov     ecx, [ebp+var_10]
.text$mn:00000966                 mov     dword ptr [ecx+18h], 0
.text$mn:0000096D                 mov     [ebp+var_4], 0FFFFFFFFh
.text$mn:00000974                 mov     eax, [ebp+var_10]
.text$mn:00000977                 mov     ecx, [ebp+var_C]
.text$mn:0000097A                 mov     large fs:0, ecx
.text$mn:00000981                 pop     ecx
.text$mn:00000982                 mov     esp, ebp
.text$mn:00000984                 pop     ebp
.text$mn:00000985                 retn
.text$mn:00000985 ??0?$_String_val@U?$_Simple_types@D@std@@@std@@QAE@XZ endp
.text$mn:00000985
.text$mn:00000985 ; ---------------------------------------------------------------------------
.text$mn:00000986                 align 4
.text$mn:00000986 _text$mn        ends
.text$mn:00000986
.text$x:00000988 ; ===========================================================================
.text$x:00000988
.text$x:00000988 ; Segment type: Pure code
.text$x:00000988 ; Segment permissions: Read/Execute
.text$x:00000988 _text$x         segment para public 'CODE' use32
.text$x:00000988                 assume cs:_text$x
.text$x:00000988                 ;org 988h
.text$x:00000988 ; COMDAT (pick associative to section at 924)
.text$x:00000988                 assume es:nothing, ss:nothing, ds:_xdata$x, fs:nothing, gs:nothing
.text$x:00000988
.text$x:00000988 ; =============== S U B R O U T I N E =======================================
.text$x:00000988
.text$x:00000988
.text$x:00000988 __unwindfunclet$??0?$_String_val@U?$_Simple_types@D@std@@@std@@QAE@XZ$0 proc near
.text$x:00000988                                         ; DATA XREF: .xdata$x:0000281Co
.text$x:00000988                 mov     ecx, [ebp-10h]  ; this
.text$x:0000098B                 jmp     ??1_Container_base12@std@@QAE@XZ ; std::_Container_base12::~_Container_base12(void)
.text$x:0000098B __unwindfunclet$??0?$_String_val@U?$_Simple_types@D@std@@@std@@QAE@XZ$0 endp
.text$x:0000098B
.text$x:00000990
.text$x:00000990 ; =============== S U B R O U T I N E =======================================
.text$x:00000990
.text$x:00000990
.text$x:00000990 __ehhandler$??0?$_String_val@U?$_Simple_types@D@std@@@std@@QAE@XZ proc near
.text$x:00000990                                         ; DATA XREF: std::_String_val<std::_Simple_types<char>>::_String_val<std::_Simple_types<char>>(void)+5o
.text$x:00000990
.text$x:00000990 arg_4           = dword ptr  8
.text$x:00000990
.text$x:00000990                 mov     edx, [esp+arg_4]
.text$x:00000994                 lea     eax, [edx+0Ch]
.text$x:00000997                 mov     ecx, [edx-8]
.text$x:0000099A                 xor     ecx, eax
.text$x:0000099C                 call    @__security_check_cookie@4 ; __security_check_cookie(x)
.text$x:000009A1                 mov     eax, offset __ehfuncinfo$??0?$_String_val@U?$_Simple_types@D@std@@@std@@QAE@XZ
.text$x:000009A6                 jmp     ___CxxFrameHandler3
.text$x:000009A6 __ehhandler$??0?$_String_val@U?$_Simple_types@D@std@@@std@@QAE@XZ endp
.text$x:000009A6
.text$x:000009A6 ; ---------------------------------------------------------------------------
.text$x:000009AB                 align 4
.text$x:000009AB _text$x         ends
.text$x:000009AB
.text$mn:000009AC ; ===========================================================================
.text$mn:000009AC
.text$mn:000009AC ; Segment type: Pure code
.text$mn:000009AC ; Segment permissions: Read/Execute
.text$mn:000009AC _text$mn        segment para public 'CODE' use32
.text$mn:000009AC                 assume cs:_text$mn
.text$mn:000009AC                 ;org 9ACh
.text$mn:000009AC ; COMDAT (pick any)
.text$mn:000009AC                 assume es:nothing, ss:nothing, ds:_xdata$x, fs:nothing, gs:nothing
.text$mn:000009AC
.text$mn:000009AC ; =============== S U B R O U T I N E =======================================
.text$mn:000009AC
.text$mn:000009AC ; Attributes: bp-based frame
.text$mn:000009AC
.text$mn:000009AC ; public: __thiscall std::_Wrap_alloc<class std::allocator<char>>::_Wrap_alloc<class std::allocator<char>>(void)
.text$mn:000009AC                 public ??0?$_Wrap_alloc@V?$allocator@D@std@@@std@@QAE@XZ
.text$mn:000009AC ??0?$_Wrap_alloc@V?$allocator@D@std@@@std@@QAE@XZ proc near
.text$mn:000009AC                                         ; CODE XREF: std::_String_alloc<0,std::_String_base_types<char,std::allocator<char>>>::_Getal(void)+Ap
.text$mn:000009AC
.text$mn:000009AC var_4           = dword ptr -4
.text$mn:000009AC
.text$mn:000009AC                 push    ebp
.text$mn:000009AD                 mov     ebp, esp
.text$mn:000009AF                 push    ecx
.text$mn:000009B0                 mov     [ebp+var_4], ecx
.text$mn:000009B3                 mov     ecx, [ebp+var_4]
.text$mn:000009B6                 call    ??0?$allocator@D@std@@QAE@XZ ; std::allocator<char>::allocator<char>(void)
.text$mn:000009BB                 mov     eax, [ebp+var_4]
.text$mn:000009BE                 mov     esp, ebp
.text$mn:000009C0                 pop     ebp
.text$mn:000009C1                 retn
.text$mn:000009C1 ??0?$_Wrap_alloc@V?$allocator@D@std@@@std@@QAE@XZ endp
.text$mn:000009C1
.text$mn:000009C1 ; ---------------------------------------------------------------------------
.text$mn:000009C2                 align 4
.text$mn:000009C2 _text$mn        ends
.text$mn:000009C2
.text$mn:000009C4 ; ===========================================================================
.text$mn:000009C4
.text$mn:000009C4 ; Segment type: Pure code
.text$mn:000009C4 ; Segment permissions: Read/Execute
.text$mn:000009C4 _text$mn        segment para public 'CODE' use32
.text$mn:000009C4                 assume cs:_text$mn
.text$mn:000009C4                 ;org 9C4h
.text$mn:000009C4 ; COMDAT (pick any)
.text$mn:000009C4                 assume es:nothing, ss:nothing, ds:_xdata$x, fs:nothing, gs:nothing
.text$mn:000009C4
.text$mn:000009C4 ; =============== S U B R O U T I N E =======================================
.text$mn:000009C4
.text$mn:000009C4 ; Attributes: bp-based frame
.text$mn:000009C4
.text$mn:000009C4 ; public: __thiscall std::_Wrap_alloc<class std::allocator<wchar_t>>::_Wrap_alloc<class std::allocator<wchar_t>>(void)
.text$mn:000009C4                 public ??0?$_Wrap_alloc@V?$allocator@_W@std@@@std@@QAE@XZ
.text$mn:000009C4 ??0?$_Wrap_alloc@V?$allocator@_W@std@@@std@@QAE@XZ proc near
.text$mn:000009C4                                         ; CODE XREF: std::_String_alloc<0,std::_String_base_types<wchar_t,std::allocator<wchar_t>>>::_Getal(void)+Ap
.text$mn:000009C4
.text$mn:000009C4 var_4           = dword ptr -4
.text$mn:000009C4
.text$mn:000009C4                 push    ebp
.text$mn:000009C5                 mov     ebp, esp
.text$mn:000009C7                 push    ecx
.text$mn:000009C8                 mov     [ebp+var_4], ecx
.text$mn:000009CB                 mov     ecx, [ebp+var_4]
.text$mn:000009CE                 call    ??0?$allocator@_W@std@@QAE@XZ ; std::allocator<wchar_t>::allocator<wchar_t>(void)
.text$mn:000009D3                 mov     eax, [ebp+var_4]
.text$mn:000009D6                 mov     esp, ebp
.text$mn:000009D8                 pop     ebp
.text$mn:000009D9                 retn
.text$mn:000009D9 ??0?$_Wrap_alloc@V?$allocator@_W@std@@@std@@QAE@XZ endp
.text$mn:000009D9
.text$mn:000009D9 ; ---------------------------------------------------------------------------
.text$mn:000009DA                 align 4
.text$mn:000009DA _text$mn        ends
.text$mn:000009DA
.text$mn:000009DC ; ===========================================================================
.text$mn:000009DC
.text$mn:000009DC ; Segment type: Pure code
.text$mn:000009DC ; Segment permissions: Read/Execute
.text$mn:000009DC _text$mn        segment para public 'CODE' use32
.text$mn:000009DC                 assume cs:_text$mn
.text$mn:000009DC                 ;org 9DCh
.text$mn:000009DC ; COMDAT (pick any)
.text$mn:000009DC                 assume es:nothing, ss:nothing, ds:_xdata$x, fs:nothing, gs:nothing
.text$mn:000009DC
.text$mn:000009DC ; =============== S U B R O U T I N E =======================================
.text$mn:000009DC
.text$mn:000009DC ; Attributes: bp-based frame
.text$mn:000009DC
.text$mn:000009DC ; public: __thiscall std::allocator<char>::allocator<char>(void)
.text$mn:000009DC                 public ??0?$allocator@D@std@@QAE@XZ
.text$mn:000009DC ??0?$allocator@D@std@@QAE@XZ proc near  ; CODE XREF: std::_Wrap_alloc<std::allocator<char>>::_Wrap_alloc<std::allocator<char>>(void)+Ap
.text$mn:000009DC                                         ; std::basic_string<char,std::char_traits<char>,std::allocator<char>>::basic_string<char,std::char_traits<char>,std::allocator<char>>(char const *)+2Bp
.text$mn:000009DC
.text$mn:000009DC var_4           = dword ptr -4
.text$mn:000009DC
.text$mn:000009DC                 push    ebp
.text$mn:000009DD                 mov     ebp, esp
.text$mn:000009DF                 push    ecx
.text$mn:000009E0                 mov     [ebp+var_4], ecx
.text$mn:000009E3                 mov     eax, [ebp+var_4]
.text$mn:000009E6                 mov     esp, ebp
.text$mn:000009E8                 pop     ebp
.text$mn:000009E9                 retn
.text$mn:000009E9 ??0?$allocator@D@std@@QAE@XZ endp
.text$mn:000009E9
.text$mn:000009E9 ; ---------------------------------------------------------------------------
.text$mn:000009EA                 align 4
.text$mn:000009EA _text$mn        ends
.text$mn:000009EA
.text$mn:000009EC ; ===========================================================================
.text$mn:000009EC
.text$mn:000009EC ; Segment type: Pure code
.text$mn:000009EC ; Segment permissions: Read/Execute
.text$mn:000009EC _text$mn        segment para public 'CODE' use32
.text$mn:000009EC                 assume cs:_text$mn
.text$mn:000009EC                 ;org 9ECh
.text$mn:000009EC ; COMDAT (pick any)
.text$mn:000009EC                 assume es:nothing, ss:nothing, ds:_xdata$x, fs:nothing, gs:nothing
.text$mn:000009EC
.text$mn:000009EC ; =============== S U B R O U T I N E =======================================
.text$mn:000009EC
.text$mn:000009EC ; Attributes: bp-based frame
.text$mn:000009EC
.text$mn:000009EC ; public: __thiscall std::allocator<struct std::_Container_proxy>::allocator<struct std::_Container_proxy>(void)
.text$mn:000009EC                 public ??0?$allocator@U_Container_proxy@std@@@std@@QAE@XZ
.text$mn:000009EC ??0?$allocator@U_Container_proxy@std@@@std@@QAE@XZ proc near
.text$mn:000009EC                                         ; CODE XREF: std::_String_alloc<0,std::_String_base_types<char,std::allocator<char>>>::_Alloc_proxy(void)+Cp
.text$mn:000009EC                                         ; std::_String_alloc<0,std::_String_base_types<char,std::allocator<char>>>::_Free_proxy(void)+Cp
.text$mn:000009EC
.text$mn:000009EC var_4           = dword ptr -4
.text$mn:000009EC
.text$mn:000009EC                 push    ebp
.text$mn:000009ED                 mov     ebp, esp
.text$mn:000009EF                 push    ecx
.text$mn:000009F0                 mov     [ebp+var_4], ecx
.text$mn:000009F3                 mov     eax, [ebp+var_4]
.text$mn:000009F6                 mov     esp, ebp
.text$mn:000009F8                 pop     ebp
.text$mn:000009F9                 retn
.text$mn:000009F9 ??0?$allocator@U_Container_proxy@std@@@std@@QAE@XZ endp
.text$mn:000009F9
.text$mn:000009F9 ; ---------------------------------------------------------------------------
.text$mn:000009FA                 align 4
.text$mn:000009FA _text$mn        ends
.text$mn:000009FA
.text$mn:000009FC ; ===========================================================================
.text$mn:000009FC
.text$mn:000009FC ; Segment type: Pure code
.text$mn:000009FC ; Segment permissions: Read/Execute
.text$mn:000009FC _text$mn        segment para public 'CODE' use32
.text$mn:000009FC                 assume cs:_text$mn
.text$mn:000009FC                 ;org 9FCh
.text$mn:000009FC ; COMDAT (pick any)
.text$mn:000009FC                 assume es:nothing, ss:nothing, ds:_xdata$x, fs:nothing, gs:nothing
.text$mn:000009FC
.text$mn:000009FC ; =============== S U B R O U T I N E =======================================
.text$mn:000009FC
.text$mn:000009FC ; Attributes: bp-based frame
.text$mn:000009FC
.text$mn:000009FC ; public: __thiscall std::allocator<wchar_t>::allocator<wchar_t>(void)
.text$mn:000009FC                 public ??0?$allocator@_W@std@@QAE@XZ
.text$mn:000009FC ??0?$allocator@_W@std@@QAE@XZ proc near ; CODE XREF: std::_Wrap_alloc<std::allocator<wchar_t>>::_Wrap_alloc<std::allocator<wchar_t>>(void)+Ap
.text$mn:000009FC
.text$mn:000009FC var_4           = dword ptr -4
.text$mn:000009FC
.text$mn:000009FC                 push    ebp
.text$mn:000009FD                 mov     ebp, esp
.text$mn:000009FF                 push    ecx
.text$mn:00000A00                 mov     [ebp+var_4], ecx
.text$mn:00000A03                 mov     eax, [ebp+var_4]
.text$mn:00000A06                 mov     esp, ebp
.text$mn:00000A08                 pop     ebp
.text$mn:00000A09                 retn
.text$mn:00000A09 ??0?$allocator@_W@std@@QAE@XZ endp
.text$mn:00000A09
.text$mn:00000A09 ; ---------------------------------------------------------------------------
.text$mn:00000A0A                 align 4
.text$mn:00000A0A _text$mn        ends
.text$mn:00000A0A
.text$mn:00000A0C ; ===========================================================================
.text$mn:00000A0C
.text$mn:00000A0C ; Segment type: Pure code
.text$mn:00000A0C ; Segment permissions: Read/Execute
.text$mn:00000A0C _text$mn        segment para public 'CODE' use32
.text$mn:00000A0C                 assume cs:_text$mn
.text$mn:00000A0C                 ;org 0A0Ch
.text$mn:00000A0C ; COMDAT (pick any)
.text$mn:00000A0C                 assume es:nothing, ss:nothing, ds:_xdata$x, fs:nothing, gs:nothing
.text$mn:00000A0C
.text$mn:00000A0C ; =============== S U B R O U T I N E =======================================
.text$mn:00000A0C
.text$mn:00000A0C ; Attributes: bp-based frame
.text$mn:00000A0C
.text$mn:00000A0C ; int __stdcall std::basic_string<char,std::char_traits<char>,std::allocator<char>>::basic_string<char,std::char_traits<char>,std::allocator<char>>(char *Str)
.text$mn:00000A0C                 public ??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@PBD@Z
.text$mn:00000A0C ??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@PBD@Z proc near
.text$mn:00000A0C                                         ; CODE XREF: std::_Generic_error_category::message(int)+5Ap
.text$mn:00000A0C                                         ; std::_Iostream_error_category::message(int)+3Dp ...
.text$mn:00000A0C
.text$mn:00000A0C var_14          = dword ptr -14h
.text$mn:00000A0C var_D           = byte ptr -0Dh
.text$mn:00000A0C var_C           = dword ptr -0Ch
.text$mn:00000A0C var_4           = dword ptr -4
.text$mn:00000A0C Str             = dword ptr  8
.text$mn:00000A0C
.text$mn:00000A0C                 push    ebp
.text$mn:00000A0D                 mov     ebp, esp
.text$mn:00000A0F                 push    0FFFFFFFFh
.text$mn:00000A11                 push    offset __ehhandler$??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@PBD@Z
.text$mn:00000A16                 mov     eax, large fs:0
.text$mn:00000A1C                 push    eax
.text$mn:00000A1D                 sub     esp, 8
.text$mn:00000A20                 mov     eax, dword ptr ds:___security_cookie
.text$mn:00000A25                 xor     eax, ebp
.text$mn:00000A27                 push    eax
.text$mn:00000A28                 lea     eax, [ebp+var_C]
.text$mn:00000A2B                 mov     large fs:0, eax
.text$mn:00000A31                 mov     [ebp+var_14], ecx
.text$mn:00000A34                 lea     ecx, [ebp+var_D]
.text$mn:00000A37                 call    ??0?$allocator@D@std@@QAE@XZ ; std::allocator<char>::allocator<char>(void)
.text$mn:00000A3C                 push    eax
.text$mn:00000A3D                 mov     ecx, [ebp+var_14]
.text$mn:00000A40                 call    ??0?$_String_alloc@$0A@U?$_String_base_types@DV?$allocator@D@std@@@std@@@std@@QAE@ABV?$allocator@D@1@@Z ; std::_String_alloc<0,std::_String_base_types<char,std::allocator<char>>>::_String_alloc<0,std::_String_base_types<char,std::allocator<char>>>(std::allocator<char> const &)
.text$mn:00000A45                 mov     [ebp+var_4], 0
.text$mn:00000A4C                 push    0               ; Size
.text$mn:00000A4E                 push    0               ; char
.text$mn:00000A50                 mov     ecx, [ebp+var_14]
.text$mn:00000A53                 call    ?_Tidy@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEX_NI@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char>>::_Tidy(bool,uint)
.text$mn:00000A58                 mov     eax, [ebp+Str]
.text$mn:00000A5B                 push    eax             ; Str
.text$mn:00000A5C                 mov     ecx, [ebp+var_14]
.text$mn:00000A5F                 call    ?assign@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV12@PBD@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char>>::assign(char const *)
.text$mn:00000A64                 mov     [ebp+var_4], 0FFFFFFFFh
.text$mn:00000A6B                 mov     eax, [ebp+var_14]
.text$mn:00000A6E                 mov     ecx, [ebp+var_C]
.text$mn:00000A71                 mov     large fs:0, ecx
.text$mn:00000A78                 pop     ecx
.text$mn:00000A79                 mov     esp, ebp
.text$mn:00000A7B                 pop     ebp
.text$mn:00000A7C                 retn    4
.text$mn:00000A7C ??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@PBD@Z endp
.text$mn:00000A7C
.text$mn:00000A7C ; ---------------------------------------------------------------------------
.text$mn:00000A7F                 align 10h
.text$mn:00000A7F _text$mn        ends
.text$mn:00000A7F
.text$x:00000A80 ; ===========================================================================
.text$x:00000A80
.text$x:00000A80 ; Segment type: Pure code
.text$x:00000A80 ; Segment permissions: Read/Execute
.text$x:00000A80 _text$x         segment para public 'CODE' use32
.text$x:00000A80                 assume cs:_text$x
.text$x:00000A80                 ;org 0A80h
.text$x:00000A80 ; COMDAT (pick associative to section at A0C)
.text$x:00000A80                 assume es:nothing, ss:nothing, ds:_xdata$x, fs:nothing, gs:nothing
.text$x:00000A80
.text$x:00000A80 ; =============== S U B R O U T I N E =======================================
.text$x:00000A80
.text$x:00000A80
.text$x:00000A80 __unwindfunclet$??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@PBD@Z$0 proc near
.text$x:00000A80                                         ; DATA XREF: .xdata$x:000028CCo
.text$x:00000A80                 mov     ecx, [ebp-14h]
.text$x:00000A83                 jmp     ??1?$_String_alloc@$0A@U?$_String_base_types@DV?$allocator@D@std@@@std@@@std@@QAE@XZ ; std::_String_alloc<0,std::_String_base_types<char,std::allocator<char>>>::~_String_alloc<0,std::_String_base_types<char,std::allocator<char>>>(void)
.text$x:00000A83 __unwindfunclet$??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@PBD@Z$0 endp
.text$x:00000A83
.text$x:00000A88
.text$x:00000A88 ; =============== S U B R O U T I N E =======================================
.text$x:00000A88
.text$x:00000A88
.text$x:00000A88 __ehhandler$??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@PBD@Z proc near
.text$x:00000A88                                         ; DATA XREF: std::basic_string<char,std::char_traits<char>,std::allocator<char>>::basic_string<char,std::char_traits<char>,std::allocator<char>>(char const *)+5o
.text$x:00000A88
.text$x:00000A88 arg_4           = dword ptr  8
.text$x:00000A88
.text$x:00000A88                 mov     edx, [esp+arg_4]
.text$x:00000A8C                 lea     eax, [edx+0Ch]
.text$x:00000A8F                 mov     ecx, [edx-0Ch]
.text$x:00000A92                 xor     ecx, eax
.text$x:00000A94                 call    @__security_check_cookie@4 ; __security_check_cookie(x)
.text$x:00000A99                 mov     eax, offset __ehfuncinfo$??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@PBD@Z
.text$x:00000A9E                 jmp     ___CxxFrameHandler3
.text$x:00000A9E __ehhandler$??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@PBD@Z endp
.text$x:00000A9E
.text$x:00000A9E ; ---------------------------------------------------------------------------
.text$x:00000AA3                 align 4
.text$x:00000AA3 _text$x         ends
.text$x:00000AA3
.text$mn:00000AA4 ; ===========================================================================
.text$mn:00000AA4
.text$mn:00000AA4 ; Segment type: Pure code
.text$mn:00000AA4 ; Segment permissions: Read/Execute
.text$mn:00000AA4 _text$mn        segment para public 'CODE' use32
.text$mn:00000AA4                 assume cs:_text$mn
.text$mn:00000AA4                 ;org 0AA4h
.text$mn:00000AA4 ; COMDAT (pick any)
.text$mn:00000AA4                 assume es:nothing, ss:nothing, ds:_xdata$x, fs:nothing, gs:nothing
.text$mn:00000AA4
.text$mn:00000AA4 ; =============== S U B R O U T I N E =======================================
.text$mn:00000AA4
.text$mn:00000AA4 ; Attributes: bp-based frame
.text$mn:00000AA4
.text$mn:00000AA4 ; _DWORD __thiscall std::_Container_base12::_Container_base12(std::_Container_base12 *__hidden this)
.text$mn:00000AA4                 public ??0_Container_base12@std@@QAE@XZ
.text$mn:00000AA4 ??0_Container_base12@std@@QAE@XZ proc near
.text$mn:00000AA4                                         ; CODE XREF: std::_String_val<std::_Simple_types<char>>::_String_val<std::_Simple_types<char>>(void)+29p
.text$mn:00000AA4
.text$mn:00000AA4 var_4           = dword ptr -4
.text$mn:00000AA4
.text$mn:00000AA4                 push    ebp
.text$mn:00000AA5                 mov     ebp, esp
.text$mn:00000AA7                 push    ecx
.text$mn:00000AA8                 mov     [ebp+var_4], ecx
.text$mn:00000AAB                 mov     eax, [ebp+var_4]
.text$mn:00000AAE                 mov     dword ptr [eax], 0
.text$mn:00000AB4                 mov     eax, [ebp+var_4]
.text$mn:00000AB7                 mov     esp, ebp
.text$mn:00000AB9                 pop     ebp
.text$mn:00000ABA                 retn
.text$mn:00000ABA ??0_Container_base12@std@@QAE@XZ endp
.text$mn:00000ABA
.text$mn:00000ABA ; ---------------------------------------------------------------------------
.text$mn:00000ABB                 align 4
.text$mn:00000ABB _text$mn        ends
.text$mn:00000ABB
.text$mn:00000ABC ; ===========================================================================
.text$mn:00000ABC
.text$mn:00000ABC ; Segment type: Pure code
.text$mn:00000ABC ; Segment permissions: Read/Execute
.text$mn:00000ABC _text$mn        segment para public 'CODE' use32
.text$mn:00000ABC                 assume cs:_text$mn
.text$mn:00000ABC                 ;org 0ABCh
.text$mn:00000ABC ; COMDAT (pick any)
.text$mn:00000ABC                 assume es:nothing, ss:nothing, ds:_xdata$x, fs:nothing, gs:nothing
.text$mn:00000ABC
.text$mn:00000ABC ; =============== S U B R O U T I N E =======================================
.text$mn:00000ABC
.text$mn:00000ABC ; Attributes: bp-based frame
.text$mn:00000ABC
.text$mn:00000ABC ; _DWORD __thiscall std::_Container_proxy::_Container_proxy(std::_Container_proxy *__hidden this)
.text$mn:00000ABC                 public ??0_Container_proxy@std@@QAE@XZ
.text$mn:00000ABC ??0_Container_proxy@std@@QAE@XZ proc near
.text$mn:00000ABC                                         ; CODE XREF: std::_String_alloc<0,std::_String_base_types<char,std::allocator<char>>>::_Alloc_proxy(void)+23p
.text$mn:00000ABC
.text$mn:00000ABC var_4           = dword ptr -4
.text$mn:00000ABC
.text$mn:00000ABC                 push    ebp
.text$mn:00000ABD                 mov     ebp, esp
.text$mn:00000ABF                 push    ecx
.text$mn:00000AC0                 mov     [ebp+var_4], ecx
.text$mn:00000AC3                 mov     eax, [ebp+var_4]
.text$mn:00000AC6                 mov     dword ptr [eax], 0
.text$mn:00000ACC                 mov     ecx, [ebp+var_4]
.text$mn:00000ACF                 mov     dword ptr [ecx+4], 0
.text$mn:00000AD6                 mov     eax, [ebp+var_4]
.text$mn:00000AD9                 mov     esp, ebp
.text$mn:00000ADB                 pop     ebp
.text$mn:00000ADC                 retn
.text$mn:00000ADC ??0_Container_proxy@std@@QAE@XZ endp
.text$mn:00000ADC
.text$mn:00000ADC ; ---------------------------------------------------------------------------
.text$mn:00000ADD                 align 10h
.text$mn:00000ADD _text$mn        ends
.text$mn:00000ADD
.text$mn:00000AE0 ; ===========================================================================
.text$mn:00000AE0
.text$mn:00000AE0 ; Segment type: Pure code
.text$mn:00000AE0 ; Segment permissions: Read/Execute
.text$mn:00000AE0 _text$mn        segment para public 'CODE' use32
.text$mn:00000AE0                 assume cs:_text$mn
.text$mn:00000AE0                 ;org 0AE0h
.text$mn:00000AE0 ; COMDAT (pick any)
.text$mn:00000AE0                 assume es:nothing, ss:nothing, ds:_xdata$x, fs:nothing, gs:nothing
.text$mn:00000AE0
.text$mn:00000AE0 ; =============== S U B R O U T I N E =======================================
.text$mn:00000AE0
.text$mn:00000AE0 ; Attributes: bp-based frame
.text$mn:00000AE0
.text$mn:00000AE0 ; _DWORD __thiscall std::_Generic_error_category::_Generic_error_category(std::_Generic_error_category *__hidden this)
.text$mn:00000AE0                 public ??0_Generic_error_category@std@@QAE@XZ
.text$mn:00000AE0 ??0_Generic_error_category@std@@QAE@XZ proc near
.text$mn:00000AE0                                         ; CODE XREF: std::_Iostream_error_category::_Iostream_error_category(void)+29p
.text$mn:00000AE0                                         ; std::_System_error_category::_System_error_category(void)+29p ...
.text$mn:00000AE0
.text$mn:00000AE0 var_10          = dword ptr -10h
.text$mn:00000AE0 var_C           = dword ptr -0Ch
.text$mn:00000AE0 var_4           = dword ptr -4
.text$mn:00000AE0
.text$mn:00000AE0                 push    ebp
.text$mn:00000AE1                 mov     ebp, esp
.text$mn:00000AE3                 push    0FFFFFFFFh
.text$mn:00000AE5                 push    offset __ehhandler$??0_Generic_error_category@std@@QAE@XZ
.text$mn:00000AEA                 mov     eax, large fs:0
.text$mn:00000AF0                 push    eax
.text$mn:00000AF1                 push    ecx
.text$mn:00000AF2                 mov     eax, dword ptr ds:___security_cookie
.text$mn:00000AF7                 xor     eax, ebp
.text$mn:00000AF9                 push    eax
.text$mn:00000AFA                 lea     eax, [ebp+var_C]
.text$mn:00000AFD                 mov     large fs:0, eax
.text$mn:00000B03                 mov     [ebp+var_10], ecx
.text$mn:00000B06                 mov     ecx, [ebp+var_10] ; this
.text$mn:00000B09                 call    ??0error_category@std@@QAE@XZ ; std::error_category::error_category(void)
.text$mn:00000B0E                 mov     [ebp+var_4], 0
.text$mn:00000B15                 mov     eax, [ebp+var_10]
.text$mn:00000B18                 mov     dword ptr [eax], offset ??_7_Generic_error_category@std@@6B@ ; const std::_Generic_error_category::`vftable'
.text$mn:00000B1E                 mov     [ebp+var_4], 0FFFFFFFFh
.text$mn:00000B25                 mov     eax, [ebp+var_10]
.text$mn:00000B28                 mov     ecx, [ebp+var_C]
.text$mn:00000B2B                 mov     large fs:0, ecx
.text$mn:00000B32                 pop     ecx
.text$mn:00000B33                 mov     esp, ebp
.text$mn:00000B35                 pop     ebp
.text$mn:00000B36                 retn
.text$mn:00000B36 ??0_Generic_error_category@std@@QAE@XZ endp
.text$mn:00000B36
.text$mn:00000B36 ; ---------------------------------------------------------------------------
.text$mn:00000B37                 align 4
.text$mn:00000B37 _text$mn        ends
.text$mn:00000B37
.text$x:00000B38 ; ===========================================================================
.text$x:00000B38
.text$x:00000B38 ; Segment type: Pure code
.text$x:00000B38 ; Segment permissions: Read/Execute
.text$x:00000B38 _text$x         segment para public 'CODE' use32
.text$x:00000B38                 assume cs:_text$x
.text$x:00000B38                 ;org 0B38h
.text$x:00000B38 ; COMDAT (pick associative to section at AE0)
.text$x:00000B38                 assume es:nothing, ss:nothing, ds:_xdata$x, fs:nothing, gs:nothing
.text$x:00000B38
.text$x:00000B38 ; =============== S U B R O U T I N E =======================================
.text$x:00000B38
.text$x:00000B38
.text$x:00000B38 __unwindfunclet$??0_Generic_error_category@std@@QAE@XZ$0 proc near
.text$x:00000B38                                         ; DATA XREF: .xdata$x:000029B0o
.text$x:00000B38                 mov     ecx, [ebp-10h]  ; this
.text$x:00000B3B                 jmp     ??1error_category@std@@UAE@XZ ; std::error_category::~error_category(void)
.text$x:00000B3B __unwindfunclet$??0_Generic_error_category@std@@QAE@XZ$0 endp
.text$x:00000B3B
.text$x:00000B40
.text$x:00000B40 ; =============== S U B R O U T I N E =======================================
.text$x:00000B40
.text$x:00000B40
.text$x:00000B40 __ehhandler$??0_Generic_error_category@std@@QAE@XZ proc near
.text$x:00000B40                                         ; DATA XREF: std::_Generic_error_category::_Generic_error_category(void)+5o
.text$x:00000B40
.text$x:00000B40 arg_4           = dword ptr  8
.text$x:00000B40
.text$x:00000B40                 mov     edx, [esp+arg_4]
.text$x:00000B44                 lea     eax, [edx+0Ch]
.text$x:00000B47                 mov     ecx, [edx-8]
.text$x:00000B4A                 xor     ecx, eax
.text$x:00000B4C                 call    @__security_check_cookie@4 ; __security_check_cookie(x)
.text$x:00000B51                 mov     eax, offset __ehfuncinfo$??0_Generic_error_category@std@@QAE@XZ
.text$x:00000B56                 jmp     ___CxxFrameHandler3
.text$x:00000B56 __ehhandler$??0_Generic_error_category@std@@QAE@XZ endp
.text$x:00000B56
.text$x:00000B56 ; ---------------------------------------------------------------------------
.text$x:00000B5B                 align 4
.text$x:00000B5B _text$x         ends
.text$x:00000B5B
.text$mn:00000B5C ; ===========================================================================
.text$mn:00000B5C
.text$mn:00000B5C ; Segment type: Pure code
.text$mn:00000B5C ; Segment permissions: Read/Execute
.text$mn:00000B5C _text$mn        segment para public 'CODE' use32
.text$mn:00000B5C                 assume cs:_text$mn
.text$mn:00000B5C                 ;org 0B5Ch
.text$mn:00000B5C ; COMDAT (pick any)
.text$mn:00000B5C                 assume es:nothing, ss:nothing, ds:_xdata$x, fs:nothing, gs:nothing
.text$mn:00000B5C
.text$mn:00000B5C ; =============== S U B R O U T I N E =======================================
.text$mn:00000B5C
.text$mn:00000B5C ; Attributes: bp-based frame
.text$mn:00000B5C
.text$mn:00000B5C ; _DWORD __thiscall std::_Iostream_error_category::_Iostream_error_category(std::_Iostream_error_category *__hidden this)
.text$mn:00000B5C                 public ??0_Iostream_error_category@std@@QAE@XZ
.text$mn:00000B5C ??0_Iostream_error_category@std@@QAE@XZ proc near
.text$mn:00000B5C                                         ; CODE XREF: `dynamic initializer for 'std::_Iostream_error_category std::_Error_objects<int>::_Iostream_object''(void)+8p
.text$mn:00000B5C
.text$mn:00000B5C var_10          = dword ptr -10h
.text$mn:00000B5C var_C           = dword ptr -0Ch
.text$mn:00000B5C var_4           = dword ptr -4
.text$mn:00000B5C
.text$mn:00000B5C                 push    ebp
.text$mn:00000B5D                 mov     ebp, esp
.text$mn:00000B5F                 push    0FFFFFFFFh
.text$mn:00000B61                 push    offset __ehhandler$??0_Iostream_error_category@std@@QAE@XZ
.text$mn:00000B66                 mov     eax, large fs:0
.text$mn:00000B6C                 push    eax
.text$mn:00000B6D                 push    ecx
.text$mn:00000B6E                 mov     eax, dword ptr ds:___security_cookie
.text$mn:00000B73                 xor     eax, ebp
.text$mn:00000B75                 push    eax
.text$mn:00000B76                 lea     eax, [ebp+var_C]
.text$mn:00000B79                 mov     large fs:0, eax
.text$mn:00000B7F                 mov     [ebp+var_10], ecx
.text$mn:00000B82                 mov     ecx, [ebp+var_10] ; this
.text$mn:00000B85                 call    ??0_Generic_error_category@std@@QAE@XZ ; std::_Generic_error_category::_Generic_error_category(void)
.text$mn:00000B8A                 mov     [ebp+var_4], 0
.text$mn:00000B91                 mov     eax, [ebp+var_10]
.text$mn:00000B94                 mov     dword ptr [eax], offset ??_7_Iostream_error_category@std@@6B@ ; const std::_Iostream_error_category::`vftable'
.text$mn:00000B9A                 mov     [ebp+var_4], 0FFFFFFFFh
.text$mn:00000BA1                 mov     eax, [ebp+var_10]
.text$mn:00000BA4                 mov     ecx, [ebp+var_C]
.text$mn:00000BA7                 mov     large fs:0, ecx
.text$mn:00000BAE                 pop     ecx
.text$mn:00000BAF                 mov     esp, ebp
.text$mn:00000BB1                 pop     ebp
.text$mn:00000BB2                 retn
.text$mn:00000BB2 ??0_Iostream_error_category@std@@QAE@XZ endp
.text$mn:00000BB2
.text$mn:00000BB2 ; ---------------------------------------------------------------------------
.text$mn:00000BB3                 align 4
.text$mn:00000BB3 _text$mn        ends
.text$mn:00000BB3
.text$x:00000BB4 ; ===========================================================================
.text$x:00000BB4
.text$x:00000BB4 ; Segment type: Pure code
.text$x:00000BB4 ; Segment permissions: Read/Execute
.text$x:00000BB4 _text$x         segment para public 'CODE' use32
.text$x:00000BB4                 assume cs:_text$x
.text$x:00000BB4                 ;org 0BB4h
.text$x:00000BB4 ; COMDAT (pick associative to section at B5C)
.text$x:00000BB4                 assume es:nothing, ss:nothing, ds:_xdata$x, fs:nothing, gs:nothing
.text$x:00000BB4
.text$x:00000BB4 ; =============== S U B R O U T I N E =======================================
.text$x:00000BB4
.text$x:00000BB4
.text$x:00000BB4 __unwindfunclet$??0_Iostream_error_category@std@@QAE@XZ$0 proc near
.text$x:00000BB4                                         ; DATA XREF: .xdata$x:00002A34o
.text$x:00000BB4                 mov     ecx, [ebp-10h]  ; this
.text$x:00000BB7                 jmp     ??1_Generic_error_category@std@@UAE@XZ ; std::_Generic_error_category::~_Generic_error_category(void)
.text$x:00000BB7 __unwindfunclet$??0_Iostream_error_category@std@@QAE@XZ$0 endp
.text$x:00000BB7
.text$x:00000BBC
.text$x:00000BBC ; =============== S U B R O U T I N E =======================================
.text$x:00000BBC
.text$x:00000BBC
.text$x:00000BBC __ehhandler$??0_Iostream_error_category@std@@QAE@XZ proc near
.text$x:00000BBC                                         ; DATA XREF: std::_Iostream_error_category::_Iostream_error_category(void)+5o
.text$x:00000BBC
.text$x:00000BBC arg_4           = dword ptr  8
.text$x:00000BBC
.text$x:00000BBC                 mov     edx, [esp+arg_4]
.text$x:00000BC0                 lea     eax, [edx+0Ch]
.text$x:00000BC3                 mov     ecx, [edx-8]
.text$x:00000BC6                 xor     ecx, eax
.text$x:00000BC8                 call    @__security_check_cookie@4 ; __security_check_cookie(x)
.text$x:00000BCD                 mov     eax, offset __ehfuncinfo$??0_Iostream_error_category@std@@QAE@XZ
.text$x:00000BD2                 jmp     ___CxxFrameHandler3
.text$x:00000BD2 __ehhandler$??0_Iostream_error_category@std@@QAE@XZ endp
.text$x:00000BD2
.text$x:00000BD2 ; ---------------------------------------------------------------------------
.text$x:00000BD7                 align 4
.text$x:00000BD7 _text$x         ends
.text$x:00000BD7
.text$mn:00000BD8 ; ===========================================================================
.text$mn:00000BD8
.text$mn:00000BD8 ; Segment type: Pure code
.text$mn:00000BD8 ; Segment permissions: Read/Execute
.text$mn:00000BD8 _text$mn        segment para public 'CODE' use32
.text$mn:00000BD8                 assume cs:_text$mn
.text$mn:00000BD8                 ;org 0BD8h
.text$mn:00000BD8 ; COMDAT (pick any)
.text$mn:00000BD8                 assume es:nothing, ss:nothing, ds:_xdata$x, fs:nothing, gs:nothing
.text$mn:00000BD8
.text$mn:00000BD8 ; =============== S U B R O U T I N E =======================================
.text$mn:00000BD8
.text$mn:00000BD8 ; Attributes: bp-based frame
.text$mn:00000BD8
.text$mn:00000BD8 ; _DWORD __thiscall std::_System_error_category::_System_error_category(std::_System_error_category *__hidden this)
.text$mn:00000BD8                 public ??0_System_error_category@std@@QAE@XZ
.text$mn:00000BD8 ??0_System_error_category@std@@QAE@XZ proc near
.text$mn:00000BD8                                         ; CODE XREF: `dynamic initializer for 'std::_System_error_category std::_Error_objects<int>::_System_object''(void)+8p
.text$mn:00000BD8
.text$mn:00000BD8 var_10          = dword ptr -10h
.text$mn:00000BD8 var_C           = dword ptr -0Ch
.text$mn:00000BD8 var_4           = dword ptr -4
.text$mn:00000BD8
.text$mn:00000BD8                 push    ebp
.text$mn:00000BD9                 mov     ebp, esp
.text$mn:00000BDB                 push    0FFFFFFFFh
.text$mn:00000BDD                 push    offset __ehhandler$??0_System_error_category@std@@QAE@XZ
.text$mn:00000BE2                 mov     eax, large fs:0
.text$mn:00000BE8                 push    eax
.text$mn:00000BE9                 push    ecx
.text$mn:00000BEA                 mov     eax, dword ptr ds:___security_cookie
.text$mn:00000BEF                 xor     eax, ebp
.text$mn:00000BF1                 push    eax
.text$mn:00000BF2                 lea     eax, [ebp+var_C]
.text$mn:00000BF5                 mov     large fs:0, eax
.text$mn:00000BFB                 mov     [ebp+var_10], ecx
.text$mn:00000BFE                 mov     ecx, [ebp+var_10] ; this
.text$mn:00000C01                 call    ??0_Generic_error_category@std@@QAE@XZ ; std::_Generic_error_category::_Generic_error_category(void)
.text$mn:00000C06                 mov     [ebp+var_4], 0
.text$mn:00000C0D                 mov     eax, [ebp+var_10]
.text$mn:00000C10                 mov     dword ptr [eax], offset ??_7_System_error_category@std@@6B@ ; const std::_System_error_category::`vftable'
.text$mn:00000C16                 mov     [ebp+var_4], 0FFFFFFFFh
.text$mn:00000C1D                 mov     eax, [ebp+var_10]
.text$mn:00000C20                 mov     ecx, [ebp+var_C]
.text$mn:00000C23                 mov     large fs:0, ecx
.text$mn:00000C2A                 pop     ecx
.text$mn:00000C2B                 mov     esp, ebp
.text$mn:00000C2D                 pop     ebp
.text$mn:00000C2E                 retn
.text$mn:00000C2E ??0_System_error_category@std@@QAE@XZ endp
.text$mn:00000C2E
.text$mn:00000C2E ; ---------------------------------------------------------------------------
.text$mn:00000C2F                 align 10h
.text$mn:00000C2F _text$mn        ends
.text$mn:00000C2F
.text$x:00000C30 ; ===========================================================================
.text$x:00000C30
.text$x:00000C30 ; Segment type: Pure code
.text$x:00000C30 ; Segment permissions: Read/Execute
.text$x:00000C30 _text$x         segment para public 'CODE' use32
.text$x:00000C30                 assume cs:_text$x
.text$x:00000C30                 ;org 0C30h
.text$x:00000C30 ; COMDAT (pick associative to section at BD8)
.text$x:00000C30                 assume es:nothing, ss:nothing, ds:_xdata$x, fs:nothing, gs:nothing
.text$x:00000C30
.text$x:00000C30 ; =============== S U B R O U T I N E =======================================
.text$x:00000C30
.text$x:00000C30
.text$x:00000C30 __unwindfunclet$??0_System_error_category@std@@QAE@XZ$0 proc near
.text$x:00000C30                                         ; DATA XREF: .xdata$x:00002AB8o
.text$x:00000C30                 mov     ecx, [ebp-10h]  ; this
.text$x:00000C33                 jmp     ??1_Generic_error_category@std@@UAE@XZ ; std::_Generic_error_category::~_Generic_error_category(void)
.text$x:00000C33 __unwindfunclet$??0_System_error_category@std@@QAE@XZ$0 endp
.text$x:00000C33
.text$x:00000C38
.text$x:00000C38 ; =============== S U B R O U T I N E =======================================
.text$x:00000C38
.text$x:00000C38
.text$x:00000C38 __ehhandler$??0_System_error_category@std@@QAE@XZ proc near
.text$x:00000C38                                         ; DATA XREF: std::_System_error_category::_System_error_category(void)+5o
.text$x:00000C38
.text$x:00000C38 arg_4           = dword ptr  8
.text$x:00000C38
.text$x:00000C38                 mov     edx, [esp+arg_4]
.text$x:00000C3C                 lea     eax, [edx+0Ch]
.text$x:00000C3F                 mov     ecx, [edx-8]
.text$x:00000C42                 xor     ecx, eax
.text$x:00000C44                 call    @__security_check_cookie@4 ; __security_check_cookie(x)
.text$x:00000C49                 mov     eax, offset __ehfuncinfo$??0_System_error_category@std@@QAE@XZ
.text$x:00000C4E                 jmp     ___CxxFrameHandler3
.text$x:00000C4E __ehhandler$??0_System_error_category@std@@QAE@XZ endp
.text$x:00000C4E
.text$x:00000C4E ; ---------------------------------------------------------------------------
.text$x:00000C53                 align 4
.text$x:00000C53 _text$x         ends
.text$x:00000C53
.text$mn:00000C54 ; ===========================================================================
.text$mn:00000C54
.text$mn:00000C54 ; Segment type: Pure code
.text$mn:00000C54 ; Segment permissions: Read/Execute
.text$mn:00000C54 _text$mn        segment para public 'CODE' use32
.text$mn:00000C54                 assume cs:_text$mn
.text$mn:00000C54                 ;org 0C54h
.text$mn:00000C54 ; COMDAT (pick any)
.text$mn:00000C54                 assume es:nothing, ss:nothing, ds:_xdata$x, fs:nothing, gs:nothing
.text$mn:00000C54
.text$mn:00000C54 ; =============== S U B R O U T I N E =======================================
.text$mn:00000C54
.text$mn:00000C54 ; Attributes: bp-based frame
.text$mn:00000C54
.text$mn:00000C54 ; _DWORD __thiscall std::error_category::error_category(std::error_category *__hidden this)
.text$mn:00000C54                 public ??0error_category@std@@QAE@XZ
.text$mn:00000C54 ??0error_category@std@@QAE@XZ proc near ; CODE XREF: std::_Generic_error_category::_Generic_error_category(void)+29p
.text$mn:00000C54
.text$mn:00000C54 var_4           = dword ptr -4
.text$mn:00000C54
.text$mn:00000C54                 push    ebp
.text$mn:00000C55                 mov     ebp, esp
.text$mn:00000C57                 push    ecx
.text$mn:00000C58                 mov     [ebp+var_4], ecx
.text$mn:00000C5B                 mov     eax, [ebp+var_4]
.text$mn:00000C5E                 mov     dword ptr [eax], offset ??_7error_category@std@@6B@ ; const std::error_category::`vftable'
.text$mn:00000C64                 mov     eax, [ebp+var_4]
.text$mn:00000C67                 mov     esp, ebp
.text$mn:00000C69                 pop     ebp
.text$mn:00000C6A                 retn
.text$mn:00000C6A ??0error_category@std@@QAE@XZ endp
.text$mn:00000C6A
.text$mn:00000C6A ; ---------------------------------------------------------------------------
.text$mn:00000C6B                 align 4
.text$mn:00000C6B _text$mn        ends
.text$mn:00000C6B
.text$mn:00000C6C ; ===========================================================================
.text$mn:00000C6C
.text$mn:00000C6C ; Segment type: Pure code
.text$mn:00000C6C ; Segment permissions: Read/Execute
.text$mn:00000C6C _text$mn        segment para public 'CODE' use32
.text$mn:00000C6C                 assume cs:_text$mn
.text$mn:00000C6C                 ;org 0C6Ch
.text$mn:00000C6C ; COMDAT (pick any)
.text$mn:00000C6C                 assume es:nothing, ss:nothing, ds:_xdata$x, fs:nothing, gs:nothing
.text$mn:00000C6C
.text$mn:00000C6C ; =============== S U B R O U T I N E =======================================
.text$mn:00000C6C
.text$mn:00000C6C ; Attributes: bp-based frame
.text$mn:00000C6C
.text$mn:00000C6C ; _DWORD __thiscall std::error_condition::error_condition(std::error_condition *this, int, const struct std::error_category *)
.text$mn:00000C6C                 public ??0error_condition@std@@QAE@HABVerror_category@1@@Z
.text$mn:00000C6C ??0error_condition@std@@QAE@HABVerror_category@1@@Z proc near
.text$mn:00000C6C                                         ; CODE XREF: std::_System_error_category::default_error_condition(int)+24p
.text$mn:00000C6C                                         ; std::_System_error_category::default_error_condition(int)+3Dp ...
.text$mn:00000C6C
.text$mn:00000C6C var_4           = dword ptr -4
.text$mn:00000C6C arg_0           = dword ptr  8
.text$mn:00000C6C arg_4           = dword ptr  0Ch
.text$mn:00000C6C
.text$mn:00000C6C                 push    ebp
.text$mn:00000C6D                 mov     ebp, esp
.text$mn:00000C6F                 push    ecx
.text$mn:00000C70                 mov     [ebp+var_4], ecx
.text$mn:00000C73                 mov     eax, [ebp+var_4]
.text$mn:00000C76                 mov     ecx, [ebp+arg_0]
.text$mn:00000C79                 mov     [eax], ecx
.text$mn:00000C7B                 mov     edx, [ebp+var_4]
.text$mn:00000C7E                 mov     eax, [ebp+arg_4]
.text$mn:00000C81                 mov     [edx+4], eax
.text$mn:00000C84                 mov     eax, [ebp+var_4]
.text$mn:00000C87                 mov     esp, ebp
.text$mn:00000C89                 pop     ebp
.text$mn:00000C8A                 retn    8
.text$mn:00000C8A ??0error_condition@std@@QAE@HABVerror_category@1@@Z endp
.text$mn:00000C8A
.text$mn:00000C8A ; ---------------------------------------------------------------------------
.text$mn:00000C8D                 align 10h
.text$mn:00000C8D _text$mn        ends
.text$mn:00000C8D
.text$mn:00000C90 ; ===========================================================================
.text$mn:00000C90
.text$mn:00000C90 ; Segment type: Pure code
.text$mn:00000C90 ; Segment permissions: Read/Execute
.text$mn:00000C90 _text$mn        segment para public 'CODE' use32
.text$mn:00000C90                 assume cs:_text$mn
.text$mn:00000C90                 ;org 0C90h
.text$mn:00000C90 ; COMDAT (pick any)
.text$mn:00000C90                 assume es:nothing, ss:nothing, ds:_xdata$x, fs:nothing, gs:nothing
.text$mn:00000C90
.text$mn:00000C90 ; =============== S U B R O U T I N E =======================================
.text$mn:00000C90
.text$mn:00000C90 ; Attributes: bp-based frame
.text$mn:00000C90
.text$mn:00000C90 ; _DWORD __thiscall std::locale::id::id(std::locale::id *this, unsigned int)
.text$mn:00000C90                 public ??0id@locale@std@@QAE@I@Z
.text$mn:00000C90 ??0id@locale@std@@QAE@I@Z proc near     ; CODE XREF: `dynamic initializer for 'std::locale::id std::num_put<char,std::back_insert_iterator<std::basic_string<char,std::char_traits<char>,std::allocator<char>>>>::id''(void)+Ap
.text$mn:00000C90                                         ; `dynamic initializer for 'std::locale::id std::num_put<wchar_t,std::back_insert_iterator<std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>>>>::id''(void)+Ap ...
.text$mn:00000C90
.text$mn:00000C90 var_4           = dword ptr -4
.text$mn:00000C90 arg_0           = dword ptr  8
.text$mn:00000C90
.text$mn:00000C90                 push    ebp
.text$mn:00000C91                 mov     ebp, esp
.text$mn:00000C93                 push    ecx
.text$mn:00000C94                 mov     [ebp+var_4], ecx
.text$mn:00000C97                 mov     eax, [ebp+var_4]
.text$mn:00000C9A                 mov     ecx, [ebp+arg_0]
.text$mn:00000C9D                 mov     [eax], ecx
.text$mn:00000C9F                 mov     eax, [ebp+var_4]
.text$mn:00000CA2                 mov     esp, ebp
.text$mn:00000CA4                 pop     ebp
.text$mn:00000CA5                 retn    4
.text$mn:00000CA5 ??0id@locale@std@@QAE@I@Z endp
.text$mn:00000CA5
.text$mn:00000CA5 _text$mn        ends
.text$mn:00000CA5
.text$mn:00000CA8 ; ===========================================================================
.text$mn:00000CA8
.text$mn:00000CA8 ; Segment type: Pure code
.text$mn:00000CA8 ; Segment permissions: Read/Execute
.text$mn:00000CA8 _text$mn        segment para public 'CODE' use32
.text$mn:00000CA8                 assume cs:_text$mn
.text$mn:00000CA8                 ;org 0CA8h
.text$mn:00000CA8 ; COMDAT (pick any)
.text$mn:00000CA8                 assume es:nothing, ss:nothing, ds:_xdata$x, fs:nothing, gs:nothing
.text$mn:00000CA8
.text$mn:00000CA8 ; =============== S U B R O U T I N E =======================================
.text$mn:00000CA8
.text$mn:00000CA8 ; Attributes: bp-based frame
.text$mn:00000CA8
.text$mn:00000CA8 ; public: __thiscall std::_String_alloc<0, struct std::_String_base_types<char, class std::allocator<char>>>::~_String_alloc<0, struct std::_String_base_types<char, class std::allocator<char>>>(void)
.text$mn:00000CA8                 public ??1?$_String_alloc@$0A@U?$_String_base_types@DV?$allocator@D@std@@@std@@@std@@QAE@XZ
.text$mn:00000CA8 ??1?$_String_alloc@$0A@U?$_String_base_types@DV?$allocator@D@std@@@std@@@std@@QAE@XZ proc near
.text$mn:00000CA8                                         ; CODE XREF: __unwindfunclet$??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@PBD@Z$0+3j
.text$mn:00000CA8                                         ; std::basic_string<char,std::char_traits<char>,std::allocator<char>>::~basic_string<char,std::char_traits<char>,std::allocator<char>>(void)+43p ...
.text$mn:00000CA8
.text$mn:00000CA8 var_10          = dword ptr -10h
.text$mn:00000CA8 var_C           = dword ptr -0Ch
.text$mn:00000CA8 var_4           = dword ptr -4
.text$mn:00000CA8
.text$mn:00000CA8                 push    ebp
.text$mn:00000CA9                 mov     ebp, esp
.text$mn:00000CAB                 push    0FFFFFFFFh
.text$mn:00000CAD                 push    offset __ehhandler$??1?$_String_alloc@$0A@U?$_String_base_types@DV?$allocator@D@std@@@std@@@std@@QAE@XZ
.text$mn:00000CB2                 mov     eax, large fs:0
.text$mn:00000CB8                 push    eax
.text$mn:00000CB9                 push    ecx
.text$mn:00000CBA                 mov     eax, dword ptr ds:___security_cookie
.text$mn:00000CBF                 xor     eax, ebp
.text$mn:00000CC1                 push    eax
.text$mn:00000CC2                 lea     eax, [ebp+var_C]
.text$mn:00000CC5                 mov     large fs:0, eax
.text$mn:00000CCB                 mov     [ebp+var_10], ecx
.text$mn:00000CCE                 mov     [ebp+var_4], 0
.text$mn:00000CD5                 mov     ecx, [ebp+var_10]
.text$mn:00000CD8                 call    ?_Free_proxy@?$_String_alloc@$0A@U?$_String_base_types@DV?$allocator@D@std@@@std@@@std@@QAEXXZ ; std::_String_alloc<0,std::_String_base_types<char,std::allocator<char>>>::_Free_proxy(void)
.text$mn:00000CDD                 mov     [ebp+var_4], 0FFFFFFFFh
.text$mn:00000CE4                 mov     ecx, [ebp+var_10]
.text$mn:00000CE7                 call    ??1?$_String_val@U?$_Simple_types@D@std@@@std@@QAE@XZ ; std::_String_val<std::_Simple_types<char>>::~_String_val<std::_Simple_types<char>>(void)
.text$mn:00000CEC                 mov     ecx, [ebp+var_C]
.text$mn:00000CEF                 mov     large fs:0, ecx
.text$mn:00000CF6                 pop     ecx
.text$mn:00000CF7                 mov     esp, ebp
.text$mn:00000CF9                 pop     ebp
.text$mn:00000CFA                 retn
.text$mn:00000CFA ??1?$_String_alloc@$0A@U?$_String_base_types@DV?$allocator@D@std@@@std@@@std@@QAE@XZ endp
.text$mn:00000CFA
.text$mn:00000CFA ; ---------------------------------------------------------------------------
.text$mn:00000CFB                 align 4
.text$mn:00000CFB _text$mn        ends
.text$mn:00000CFB
.text$x:00000CFC ; ===========================================================================
.text$x:00000CFC
.text$x:00000CFC ; Segment type: Pure code
.text$x:00000CFC ; Segment permissions: Read/Execute
.text$x:00000CFC _text$x         segment para public 'CODE' use32
.text$x:00000CFC                 assume cs:_text$x
.text$x:00000CFC                 ;org 0CFCh
.text$x:00000CFC ; COMDAT (pick associative to section at CA8)
.text$x:00000CFC                 assume es:nothing, ss:nothing, ds:_xdata$x, fs:nothing, gs:nothing
.text$x:00000CFC
.text$x:00000CFC ; =============== S U B R O U T I N E =======================================
.text$x:00000CFC
.text$x:00000CFC
.text$x:00000CFC __unwindfunclet$??1?$_String_alloc@$0A@U?$_String_base_types@DV?$allocator@D@std@@@std@@@std@@QAE@XZ$0 proc near
.text$x:00000CFC                                         ; DATA XREF: .xdata$x:000028A0o
.text$x:00000CFC                 mov     ecx, [ebp-10h]
.text$x:00000CFF                 jmp     ??1?$_String_val@U?$_Simple_types@D@std@@@std@@QAE@XZ ; std::_String_val<std::_Simple_types<char>>::~_String_val<std::_Simple_types<char>>(void)
.text$x:00000CFF __unwindfunclet$??1?$_String_alloc@$0A@U?$_String_base_types@DV?$allocator@D@std@@@std@@@std@@QAE@XZ$0 endp
.text$x:00000CFF
.text$x:00000D04
.text$x:00000D04 ; =============== S U B R O U T I N E =======================================
.text$x:00000D04
.text$x:00000D04
.text$x:00000D04 __ehhandler$??1?$_String_alloc@$0A@U?$_String_base_types@DV?$allocator@D@std@@@std@@@std@@QAE@XZ proc near
.text$x:00000D04                                         ; DATA XREF: std::_String_alloc<0,std::_String_base_types<char,std::allocator<char>>>::~_String_alloc<0,std::_String_base_types<char,std::allocator<char>>>(void)+5o
.text$x:00000D04
.text$x:00000D04 arg_4           = dword ptr  8
.text$x:00000D04
.text$x:00000D04                 mov     edx, [esp+arg_4]
.text$x:00000D08                 lea     eax, [edx+0Ch]
.text$x:00000D0B                 mov     ecx, [edx-8]
.text$x:00000D0E                 xor     ecx, eax
.text$x:00000D10                 call    @__security_check_cookie@4 ; __security_check_cookie(x)
.text$x:00000D15                 mov     eax, offset __ehfuncinfo$??1?$_String_alloc@$0A@U?$_String_base_types@DV?$allocator@D@std@@@std@@@std@@QAE@XZ
.text$x:00000D1A                 jmp     ___CxxFrameHandler3
.text$x:00000D1A __ehhandler$??1?$_String_alloc@$0A@U?$_String_base_types@DV?$allocator@D@std@@@std@@@std@@QAE@XZ endp
.text$x:00000D1A
.text$x:00000D1A ; ---------------------------------------------------------------------------
.text$x:00000D1F                 align 10h
.text$x:00000D1F _text$x         ends
.text$x:00000D1F
.text$mn:00000D20 ; ===========================================================================
.text$mn:00000D20
.text$mn:00000D20 ; Segment type: Pure code
.text$mn:00000D20 ; Segment permissions: Read/Execute
.text$mn:00000D20 _text$mn        segment para public 'CODE' use32
.text$mn:00000D20                 assume cs:_text$mn
.text$mn:00000D20                 ;org 0D20h
.text$mn:00000D20 ; COMDAT (pick any)
.text$mn:00000D20                 assume es:nothing, ss:nothing, ds:_xdata$x, fs:nothing, gs:nothing
.text$mn:00000D20
.text$mn:00000D20 ; =============== S U B R O U T I N E =======================================
.text$mn:00000D20
.text$mn:00000D20 ; Attributes: bp-based frame
.text$mn:00000D20
.text$mn:00000D20 ; public: __thiscall std::_String_val<struct std::_Simple_types<char>>::~_String_val<struct std::_Simple_types<char>>(void)
.text$mn:00000D20                 public ??1?$_String_val@U?$_Simple_types@D@std@@@std@@QAE@XZ
.text$mn:00000D20 ??1?$_String_val@U?$_Simple_types@D@std@@@std@@QAE@XZ proc near
.text$mn:00000D20                                         ; CODE XREF: __unwindfunclet$??0?$_String_alloc@$0A@U?$_String_base_types@DV?$allocator@D@std@@@std@@@std@@QAE@ABV?$allocator@D@1@@Z$0+3j
.text$mn:00000D20                                         ; std::_String_alloc<0,std::_String_base_types<char,std::allocator<char>>>::~_String_alloc<0,std::_String_base_types<char,std::allocator<char>>>(void)+3Fp ...
.text$mn:00000D20
.text$mn:00000D20 var_10          = dword ptr -10h
.text$mn:00000D20 var_C           = dword ptr -0Ch
.text$mn:00000D20 var_4           = dword ptr -4
.text$mn:00000D20
.text$mn:00000D20                 push    ebp
.text$mn:00000D21                 mov     ebp, esp
.text$mn:00000D23                 push    0FFFFFFFFh
.text$mn:00000D25                 push    offset __ehhandler$??1?$_String_val@U?$_Simple_types@D@std@@@std@@QAE@XZ
.text$mn:00000D2A                 mov     eax, large fs:0
.text$mn:00000D30                 push    eax
.text$mn:00000D31                 push    ecx
.text$mn:00000D32                 mov     eax, dword ptr ds:___security_cookie
.text$mn:00000D37                 xor     eax, ebp
.text$mn:00000D39                 push    eax
.text$mn:00000D3A                 lea     eax, [ebp+var_C]
.text$mn:00000D3D                 mov     large fs:0, eax
.text$mn:00000D43                 mov     [ebp+var_10], ecx
.text$mn:00000D46                 mov     [ebp+var_4], 0
.text$mn:00000D4D                 mov     [ebp+var_4], 0FFFFFFFFh
.text$mn:00000D54                 mov     ecx, [ebp+var_10] ; this
.text$mn:00000D57                 call    ??1_Container_base12@std@@QAE@XZ ; std::_Container_base12::~_Container_base12(void)
.text$mn:00000D5C                 mov     ecx, [ebp+var_C]
.text$mn:00000D5F                 mov     large fs:0, ecx
.text$mn:00000D66                 pop     ecx
.text$mn:00000D67                 mov     esp, ebp
.text$mn:00000D69                 pop     ebp
.text$mn:00000D6A                 retn
.text$mn:00000D6A ??1?$_String_val@U?$_Simple_types@D@std@@@std@@QAE@XZ endp
.text$mn:00000D6A
.text$mn:00000D6A ; ---------------------------------------------------------------------------
.text$mn:00000D6B                 align 4
.text$mn:00000D6B _text$mn        ends
.text$mn:00000D6B
.text$x:00000D6C ; ===========================================================================
.text$x:00000D6C
.text$x:00000D6C ; Segment type: Pure code
.text$x:00000D6C ; Segment permissions: Read/Execute
.text$x:00000D6C _text$x         segment para public 'CODE' use32
.text$x:00000D6C                 assume cs:_text$x
.text$x:00000D6C                 ;org 0D6Ch
.text$x:00000D6C ; COMDAT (pick associative to section at D20)
.text$x:00000D6C                 assume es:nothing, ss:nothing, ds:_xdata$x, fs:nothing, gs:nothing
.text$x:00000D6C
.text$x:00000D6C ; =============== S U B R O U T I N E =======================================
.text$x:00000D6C
.text$x:00000D6C
.text$x:00000D6C __unwindfunclet$??1?$_String_val@U?$_Simple_types@D@std@@@std@@QAE@XZ$0 proc near
.text$x:00000D6C                                         ; DATA XREF: .xdata$x:00002848o
.text$x:00000D6C                 mov     ecx, [ebp-10h]  ; this
.text$x:00000D6F                 jmp     ??1_Container_base12@std@@QAE@XZ ; std::_Container_base12::~_Container_base12(void)
.text$x:00000D6F __unwindfunclet$??1?$_String_val@U?$_Simple_types@D@std@@@std@@QAE@XZ$0 endp
.text$x:00000D6F
.text$x:00000D74
.text$x:00000D74 ; =============== S U B R O U T I N E =======================================
.text$x:00000D74
.text$x:00000D74
.text$x:00000D74 __ehhandler$??1?$_String_val@U?$_Simple_types@D@std@@@std@@QAE@XZ proc near
.text$x:00000D74                                         ; DATA XREF: std::_String_val<std::_Simple_types<char>>::~_String_val<std::_Simple_types<char>>(void)+5o
.text$x:00000D74
.text$x:00000D74 arg_4           = dword ptr  8
.text$x:00000D74
.text$x:00000D74                 mov     edx, [esp+arg_4]
.text$x:00000D78                 lea     eax, [edx+0Ch]
.text$x:00000D7B                 mov     ecx, [edx-8]
.text$x:00000D7E                 xor     ecx, eax
.text$x:00000D80                 call    @__security_check_cookie@4 ; __security_check_cookie(x)
.text$x:00000D85                 mov     eax, offset __ehfuncinfo$??1?$_String_val@U?$_Simple_types@D@std@@@std@@QAE@XZ
.text$x:00000D8A                 jmp     ___CxxFrameHandler3
.text$x:00000D8A __ehhandler$??1?$_String_val@U?$_Simple_types@D@std@@@std@@QAE@XZ endp
.text$x:00000D8A
.text$x:00000D8A ; ---------------------------------------------------------------------------
.text$x:00000D8F                 align 10h
.text$x:00000D8F _text$x         ends
.text$x:00000D8F
.text$mn:00000D90 ; ===========================================================================
.text$mn:00000D90
.text$mn:00000D90 ; Segment type: Pure code
.text$mn:00000D90 ; Segment permissions: Read/Execute
.text$mn:00000D90 _text$mn        segment para public 'CODE' use32
.text$mn:00000D90                 assume cs:_text$mn
.text$mn:00000D90                 ;org 0D90h
.text$mn:00000D90 ; COMDAT (pick any)
.text$mn:00000D90                 assume es:nothing, ss:nothing, ds:_xdata$x, fs:nothing, gs:nothing
.text$mn:00000D90
.text$mn:00000D90 ; =============== S U B R O U T I N E =======================================
.text$mn:00000D90
.text$mn:00000D90 ; Attributes: bp-based frame
.text$mn:00000D90
.text$mn:00000D90 ; public: __thiscall std::basic_string<char, struct std::char_traits<char>, class std::allocator<char>>::~basic_string<char, struct std::char_traits<char>, class std::allocator<char>>(void)
.text$mn:00000D90                 public ??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ
.text$mn:00000D90 ??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ proc near
.text$mn:00000D90                                         ; CODE XREF: __unwindfunclet$?message@_Generic_error_category@std@@UBE?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@2@H@Z$0+13j
.text$mn:00000D90                                         ; __unwindfunclet$?message@_Iostream_error_category@std@@UBE?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@2@H@Z$0+13j ...
.text$mn:00000D90
.text$mn:00000D90 var_10          = dword ptr -10h
.text$mn:00000D90 var_C           = dword ptr -0Ch
.text$mn:00000D90 var_4           = dword ptr -4
.text$mn:00000D90
.text$mn:00000D90                 push    ebp
.text$mn:00000D91                 mov     ebp, esp
.text$mn:00000D93                 push    0FFFFFFFFh
.text$mn:00000D95                 push    offset __ehhandler$??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ
.text$mn:00000D9A                 mov     eax, large fs:0
.text$mn:00000DA0                 push    eax
.text$mn:00000DA1                 push    ecx
.text$mn:00000DA2                 mov     eax, dword ptr ds:___security_cookie
.text$mn:00000DA7                 xor     eax, ebp
.text$mn:00000DA9                 push    eax
.text$mn:00000DAA                 lea     eax, [ebp+var_C]
.text$mn:00000DAD                 mov     large fs:0, eax
.text$mn:00000DB3                 mov     [ebp+var_10], ecx
.text$mn:00000DB6                 mov     [ebp+var_4], 0
.text$mn:00000DBD                 push    0               ; Size
.text$mn:00000DBF                 push    1               ; char
.text$mn:00000DC1                 mov     ecx, [ebp+var_10]
.text$mn:00000DC4                 call    ?_Tidy@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEX_NI@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char>>::_Tidy(bool,uint)
.text$mn:00000DC9                 mov     [ebp+var_4], 0FFFFFFFFh
.text$mn:00000DD0                 mov     ecx, [ebp+var_10]
.text$mn:00000DD3                 call    ??1?$_String_alloc@$0A@U?$_String_base_types@DV?$allocator@D@std@@@std@@@std@@QAE@XZ ; std::_String_alloc<0,std::_String_base_types<char,std::allocator<char>>>::~_String_alloc<0,std::_String_base_types<char,std::allocator<char>>>(void)
.text$mn:00000DD8                 mov     ecx, [ebp+var_C]
.text$mn:00000DDB                 mov     large fs:0, ecx
.text$mn:00000DE2                 pop     ecx
.text$mn:00000DE3                 mov     esp, ebp
.text$mn:00000DE5                 pop     ebp
.text$mn:00000DE6                 retn
.text$mn:00000DE6 ??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ endp
.text$mn:00000DE6
.text$mn:00000DE6 ; ---------------------------------------------------------------------------
.text$mn:00000DE7                 align 4
.text$mn:00000DE7 _text$mn        ends
.text$mn:00000DE7
.text$x:00000DE8 ; ===========================================================================
.text$x:00000DE8
.text$x:00000DE8 ; Segment type: Pure code
.text$x:00000DE8 ; Segment permissions: Read/Execute
.text$x:00000DE8 _text$x         segment para public 'CODE' use32
.text$x:00000DE8                 assume cs:_text$x
.text$x:00000DE8                 ;org 0DE8h
.text$x:00000DE8 ; COMDAT (pick associative to section at D90)
.text$x:00000DE8                 assume es:nothing, ss:nothing, ds:_xdata$x, fs:nothing, gs:nothing
.text$x:00000DE8
.text$x:00000DE8 ; =============== S U B R O U T I N E =======================================
.text$x:00000DE8
.text$x:00000DE8
.text$x:00000DE8 __unwindfunclet$??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ$0 proc near
.text$x:00000DE8                                         ; DATA XREF: .xdata$x:000028F8o
.text$x:00000DE8                 mov     ecx, [ebp-10h]
.text$x:00000DEB                 jmp     ??1?$_String_alloc@$0A@U?$_String_base_types@DV?$allocator@D@std@@@std@@@std@@QAE@XZ ; std::_String_alloc<0,std::_String_base_types<char,std::allocator<char>>>::~_String_alloc<0,std::_String_base_types<char,std::allocator<char>>>(void)
.text$x:00000DEB __unwindfunclet$??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ$0 endp
.text$x:00000DEB
.text$x:00000DF0
.text$x:00000DF0 ; =============== S U B R O U T I N E =======================================
.text$x:00000DF0
.text$x:00000DF0
.text$x:00000DF0 __ehhandler$??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ proc near
.text$x:00000DF0                                         ; DATA XREF: std::basic_string<char,std::char_traits<char>,std::allocator<char>>::~basic_string<char,std::char_traits<char>,std::allocator<char>>(void)+5o
.text$x:00000DF0
.text$x:00000DF0 arg_4           = dword ptr  8
.text$x:00000DF0
.text$x:00000DF0                 mov     edx, [esp+arg_4]
.text$x:00000DF4                 lea     eax, [edx+0Ch]
.text$x:00000DF7                 mov     ecx, [edx-8]
.text$x:00000DFA                 xor     ecx, eax
.text$x:00000DFC                 call    @__security_check_cookie@4 ; __security_check_cookie(x)
.text$x:00000E01                 mov     eax, offset __ehfuncinfo$??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ
.text$x:00000E06                 jmp     ___CxxFrameHandler3
.text$x:00000E06 __ehhandler$??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ endp
.text$x:00000E06
.text$x:00000E06 ; ---------------------------------------------------------------------------
.text$x:00000E0B                 align 4
.text$x:00000E0B _text$x         ends
.text$x:00000E0B
.text$mn:00000E0C ; ===========================================================================
.text$mn:00000E0C
.text$mn:00000E0C ; Segment type: Pure code
.text$mn:00000E0C ; Segment permissions: Read/Execute
.text$mn:00000E0C _text$mn        segment para public 'CODE' use32
.text$mn:00000E0C                 assume cs:_text$mn
.text$mn:00000E0C                 ;org 0E0Ch
.text$mn:00000E0C ; COMDAT (pick any)
.text$mn:00000E0C                 assume es:nothing, ss:nothing, ds:_xdata$x, fs:nothing, gs:nothing
.text$mn:00000E0C
.text$mn:00000E0C ; =============== S U B R O U T I N E =======================================
.text$mn:00000E0C
.text$mn:00000E0C ; Attributes: bp-based frame
.text$mn:00000E0C
.text$mn:00000E0C ; _DWORD __thiscall std::_Container_base12::~_Container_base12(std::_Container_base12 *__hidden this)
.text$mn:00000E0C                 public ??1_Container_base12@std@@QAE@XZ
.text$mn:00000E0C ??1_Container_base12@std@@QAE@XZ proc near
.text$mn:00000E0C                                         ; CODE XREF: __unwindfunclet$??0?$_String_val@U?$_Simple_types@D@std@@@std@@QAE@XZ$0+3j
.text$mn:00000E0C                                         ; std::_String_val<std::_Simple_types<char>>::~_String_val<std::_Simple_types<char>>(void)+37p ...
.text$mn:00000E0C
.text$mn:00000E0C var_4           = dword ptr -4
.text$mn:00000E0C
.text$mn:00000E0C                 push    ebp
.text$mn:00000E0D                 mov     ebp, esp
.text$mn:00000E0F                 push    ecx
.text$mn:00000E10                 mov     [ebp+var_4], ecx
.text$mn:00000E13                 mov     ecx, [ebp+var_4] ; this
.text$mn:00000E16                 call    ?_Orphan_all@_Container_base12@std@@QAEXXZ ; std::_Container_base12::_Orphan_all(void)
.text$mn:00000E1B                 mov     esp, ebp
.text$mn:00000E1D                 pop     ebp
.text$mn:00000E1E                 retn
.text$mn:00000E1E ??1_Container_base12@std@@QAE@XZ endp
.text$mn:00000E1E
.text$mn:00000E1E ; ---------------------------------------------------------------------------
.text$mn:00000E1F                 align 10h
.text$mn:00000E1F _text$mn        ends
.text$mn:00000E1F
.text$mn:00000E20 ; ===========================================================================
.text$mn:00000E20
.text$mn:00000E20 ; Segment type: Pure code
.text$mn:00000E20 ; Segment permissions: Read/Execute
.text$mn:00000E20 _text$mn        segment para public 'CODE' use32
.text$mn:00000E20                 assume cs:_text$mn
.text$mn:00000E20                 ;org 0E20h
.text$mn:00000E20 ; COMDAT (pick any)
.text$mn:00000E20                 assume es:nothing, ss:nothing, ds:_xdata$x, fs:nothing, gs:nothing
.text$mn:00000E20
.text$mn:00000E20 ; =============== S U B R O U T I N E =======================================
.text$mn:00000E20
.text$mn:00000E20 ; Attributes: bp-based frame
.text$mn:00000E20
.text$mn:00000E20 ; _DWORD __thiscall std::_Generic_error_category::~_Generic_error_category(std::_Generic_error_category *__hidden this)
.text$mn:00000E20                 public ??1_Generic_error_category@std@@UAE@XZ
.text$mn:00000E20 ??1_Generic_error_category@std@@UAE@XZ proc near
.text$mn:00000E20                                         ; CODE XREF: __unwindfunclet$??0_Iostream_error_category@std@@QAE@XZ$0+3j
.text$mn:00000E20                                         ; __unwindfunclet$??0_System_error_category@std@@QAE@XZ$0+3j ...
.text$mn:00000E20
.text$mn:00000E20 var_10          = dword ptr -10h
.text$mn:00000E20 var_C           = dword ptr -0Ch
.text$mn:00000E20 var_4           = dword ptr -4
.text$mn:00000E20
.text$mn:00000E20                 push    ebp
.text$mn:00000E21                 mov     ebp, esp
.text$mn:00000E23                 push    0FFFFFFFFh
.text$mn:00000E25                 push    offset __ehhandler$??1_Generic_error_category@std@@UAE@XZ
.text$mn:00000E2A                 mov     eax, large fs:0
.text$mn:00000E30                 push    eax
.text$mn:00000E31                 push    ecx
.text$mn:00000E32                 mov     eax, dword ptr ds:___security_cookie
.text$mn:00000E37                 xor     eax, ebp
.text$mn:00000E39                 push    eax
.text$mn:00000E3A                 lea     eax, [ebp+var_C]
.text$mn:00000E3D                 mov     large fs:0, eax
.text$mn:00000E43                 mov     [ebp+var_10], ecx
.text$mn:00000E46                 mov     [ebp+var_4], 0
.text$mn:00000E4D                 mov     [ebp+var_4], 0FFFFFFFFh
.text$mn:00000E54                 mov     ecx, [ebp+var_10] ; this
.text$mn:00000E57                 call    ??1error_category@std@@UAE@XZ ; std::error_category::~error_category(void)
.text$mn:00000E5C                 mov     ecx, [ebp+var_C]
.text$mn:00000E5F                 mov     large fs:0, ecx
.text$mn:00000E66                 pop     ecx
.text$mn:00000E67                 mov     esp, ebp
.text$mn:00000E69                 pop     ebp
.text$mn:00000E6A                 retn
.text$mn:00000E6A ??1_Generic_error_category@std@@UAE@XZ endp
.text$mn:00000E6A
.text$mn:00000E6A ; ---------------------------------------------------------------------------
.text$mn:00000E6B                 align 4
.text$mn:00000E6B _text$mn        ends
.text$mn:00000E6B
.text$x:00000E6C ; ===========================================================================
.text$x:00000E6C
.text$x:00000E6C ; Segment type: Pure code
.text$x:00000E6C ; Segment permissions: Read/Execute
.text$x:00000E6C _text$x         segment para public 'CODE' use32
.text$x:00000E6C                 assume cs:_text$x
.text$x:00000E6C                 ;org 0E6Ch
.text$x:00000E6C ; COMDAT (pick associative to section at E20)
.text$x:00000E6C                 assume es:nothing, ss:nothing, ds:_xdata$x, fs:nothing, gs:nothing
.text$x:00000E6C
.text$x:00000E6C ; =============== S U B R O U T I N E =======================================
.text$x:00000E6C
.text$x:00000E6C
.text$x:00000E6C __unwindfunclet$??1_Generic_error_category@std@@UAE@XZ$0 proc near
.text$x:00000E6C                                         ; DATA XREF: .xdata$x:00002A08o
.text$x:00000E6C                 mov     ecx, [ebp-10h]  ; this
.text$x:00000E6F                 jmp     ??1error_category@std@@UAE@XZ ; std::error_category::~error_category(void)
.text$x:00000E6F __unwindfunclet$??1_Generic_error_category@std@@UAE@XZ$0 endp
.text$x:00000E6F
.text$x:00000E74
.text$x:00000E74 ; =============== S U B R O U T I N E =======================================
.text$x:00000E74
.text$x:00000E74
.text$x:00000E74 __ehhandler$??1_Generic_error_category@std@@UAE@XZ proc near
.text$x:00000E74                                         ; DATA XREF: std::_Generic_error_category::~_Generic_error_category(void)+5o
.text$x:00000E74
.text$x:00000E74 arg_4           = dword ptr  8
.text$x:00000E74
.text$x:00000E74                 mov     edx, [esp+arg_4]
.text$x:00000E78                 lea     eax, [edx+0Ch]
.text$x:00000E7B                 mov     ecx, [edx-8]
.text$x:00000E7E                 xor     ecx, eax
.text$x:00000E80                 call    @__security_check_cookie@4 ; __security_check_cookie(x)
.text$x:00000E85                 mov     eax, offset __ehfuncinfo$??1_Generic_error_category@std@@UAE@XZ
.text$x:00000E8A                 jmp     ___CxxFrameHandler3
.text$x:00000E8A __ehhandler$??1_Generic_error_category@std@@UAE@XZ endp
.text$x:00000E8A
.text$x:00000E8A ; ---------------------------------------------------------------------------
.text$x:00000E8F                 align 10h
.text$x:00000E8F _text$x         ends
.text$x:00000E8F
.text$mn:00000E90 ; ===========================================================================
.text$mn:00000E90
.text$mn:00000E90 ; Segment type: Pure code
.text$mn:00000E90 ; Segment permissions: Read/Execute
.text$mn:00000E90 _text$mn        segment para public 'CODE' use32
.text$mn:00000E90                 assume cs:_text$mn
.text$mn:00000E90                 ;org 0E90h
.text$mn:00000E90 ; COMDAT (pick any)
.text$mn:00000E90                 assume es:nothing, ss:nothing, ds:_xdata$x, fs:nothing, gs:nothing
.text$mn:00000E90
.text$mn:00000E90 ; =============== S U B R O U T I N E =======================================
.text$mn:00000E90
.text$mn:00000E90 ; Attributes: bp-based frame
.text$mn:00000E90
.text$mn:00000E90 ; _DWORD __thiscall std::_Iostream_error_category::~_Iostream_error_category(std::_Iostream_error_category *__hidden this)
.text$mn:00000E90                 public ??1_Iostream_error_category@std@@UAE@XZ
.text$mn:00000E90 ??1_Iostream_error_category@std@@UAE@XZ proc near
.text$mn:00000E90                                         ; CODE XREF: std::_Iostream_error_category::`scalar deleting destructor'(uint)+Ap
.text$mn:00000E90                                         ; `dynamic atexit destructor for 'std::_Iostream_error_category std::_Error_objects<int>::_Iostream_object''(void)+8p
.text$mn:00000E90
.text$mn:00000E90 var_10          = dword ptr -10h
.text$mn:00000E90 var_C           = dword ptr -0Ch
.text$mn:00000E90 var_4           = dword ptr -4
.text$mn:00000E90
.text$mn:00000E90                 push    ebp
.text$mn:00000E91                 mov     ebp, esp
.text$mn:00000E93                 push    0FFFFFFFFh
.text$mn:00000E95                 push    offset __ehhandler$??1_Iostream_error_category@std@@UAE@XZ
.text$mn:00000E9A                 mov     eax, large fs:0
.text$mn:00000EA0                 push    eax
.text$mn:00000EA1                 push    ecx
.text$mn:00000EA2                 mov     eax, dword ptr ds:___security_cookie
.text$mn:00000EA7                 xor     eax, ebp
.text$mn:00000EA9                 push    eax
.text$mn:00000EAA                 lea     eax, [ebp+var_C]
.text$mn:00000EAD                 mov     large fs:0, eax
.text$mn:00000EB3                 mov     [ebp+var_10], ecx
.text$mn:00000EB6                 mov     [ebp+var_4], 0
.text$mn:00000EBD                 mov     [ebp+var_4], 0FFFFFFFFh
.text$mn:00000EC4                 mov     ecx, [ebp+var_10] ; this
.text$mn:00000EC7                 call    ??1_Generic_error_category@std@@UAE@XZ ; std::_Generic_error_category::~_Generic_error_category(void)
.text$mn:00000ECC                 mov     ecx, [ebp+var_C]
.text$mn:00000ECF                 mov     large fs:0, ecx
.text$mn:00000ED6                 pop     ecx
.text$mn:00000ED7                 mov     esp, ebp
.text$mn:00000ED9                 pop     ebp
.text$mn:00000EDA                 retn
.text$mn:00000EDA ??1_Iostream_error_category@std@@UAE@XZ endp
.text$mn:00000EDA
.text$mn:00000EDA ; ---------------------------------------------------------------------------
.text$mn:00000EDB                 align 4
.text$mn:00000EDB _text$mn        ends
.text$mn:00000EDB
.text$x:00000EDC ; ===========================================================================
.text$x:00000EDC
.text$x:00000EDC ; Segment type: Pure code
.text$x:00000EDC ; Segment permissions: Read/Execute
.text$x:00000EDC _text$x         segment para public 'CODE' use32
.text$x:00000EDC                 assume cs:_text$x
.text$x:00000EDC                 ;org 0EDCh
.text$x:00000EDC ; COMDAT (pick associative to section at E90)
.text$x:00000EDC                 assume es:nothing, ss:nothing, ds:_xdata$x, fs:nothing, gs:nothing
.text$x:00000EDC
.text$x:00000EDC ; =============== S U B R O U T I N E =======================================
.text$x:00000EDC
.text$x:00000EDC
.text$x:00000EDC __unwindfunclet$??1_Iostream_error_category@std@@UAE@XZ$0 proc near
.text$x:00000EDC                                         ; DATA XREF: .xdata$x:00002A8Co
.text$x:00000EDC                 mov     ecx, [ebp-10h]  ; this
.text$x:00000EDF                 jmp     ??1_Generic_error_category@std@@UAE@XZ ; std::_Generic_error_category::~_Generic_error_category(void)
.text$x:00000EDF __unwindfunclet$??1_Iostream_error_category@std@@UAE@XZ$0 endp
.text$x:00000EDF
.text$x:00000EE4
.text$x:00000EE4 ; =============== S U B R O U T I N E =======================================
.text$x:00000EE4
.text$x:00000EE4
.text$x:00000EE4 __ehhandler$??1_Iostream_error_category@std@@UAE@XZ proc near
.text$x:00000EE4                                         ; DATA XREF: std::_Iostream_error_category::~_Iostream_error_category(void)+5o
.text$x:00000EE4
.text$x:00000EE4 arg_4           = dword ptr  8
.text$x:00000EE4
.text$x:00000EE4                 mov     edx, [esp+arg_4]
.text$x:00000EE8                 lea     eax, [edx+0Ch]
.text$x:00000EEB                 mov     ecx, [edx-8]
.text$x:00000EEE                 xor     ecx, eax
.text$x:00000EF0                 call    @__security_check_cookie@4 ; __security_check_cookie(x)
.text$x:00000EF5                 mov     eax, offset __ehfuncinfo$??1_Iostream_error_category@std@@UAE@XZ
.text$x:00000EFA                 jmp     ___CxxFrameHandler3
.text$x:00000EFA __ehhandler$??1_Iostream_error_category@std@@UAE@XZ endp
.text$x:00000EFA
.text$x:00000EFA ; ---------------------------------------------------------------------------
.text$x:00000EFF                 align 10h
.text$x:00000EFF _text$x         ends
.text$x:00000EFF
.text$mn:00000F00 ; ===========================================================================
.text$mn:00000F00
.text$mn:00000F00 ; Segment type: Pure code
.text$mn:00000F00 ; Segment permissions: Read/Execute
.text$mn:00000F00 _text$mn        segment para public 'CODE' use32
.text$mn:00000F00                 assume cs:_text$mn
.text$mn:00000F00                 ;org 0F00h
.text$mn:00000F00 ; COMDAT (pick any)
.text$mn:00000F00                 assume es:nothing, ss:nothing, ds:_xdata$x, fs:nothing, gs:nothing
.text$mn:00000F00
.text$mn:00000F00 ; =============== S U B R O U T I N E =======================================
.text$mn:00000F00
.text$mn:00000F00 ; Attributes: bp-based frame
.text$mn:00000F00
.text$mn:00000F00 ; _DWORD __thiscall std::_System_error_category::~_System_error_category(std::_System_error_category *__hidden this)
.text$mn:00000F00                 public ??1_System_error_category@std@@UAE@XZ
.text$mn:00000F00 ??1_System_error_category@std@@UAE@XZ proc near
.text$mn:00000F00                                         ; CODE XREF: std::_System_error_category::`scalar deleting destructor'(uint)+Ap
.text$mn:00000F00                                         ; `dynamic atexit destructor for 'std::_System_error_category std::_Error_objects<int>::_System_object''(void)+8p
.text$mn:00000F00
.text$mn:00000F00 var_10          = dword ptr -10h
.text$mn:00000F00 var_C           = dword ptr -0Ch
.text$mn:00000F00 var_4           = dword ptr -4
.text$mn:00000F00
.text$mn:00000F00                 push    ebp
.text$mn:00000F01                 mov     ebp, esp
.text$mn:00000F03                 push    0FFFFFFFFh
.text$mn:00000F05                 push    offset __ehhandler$??1_System_error_category@std@@UAE@XZ
.text$mn:00000F0A                 mov     eax, large fs:0
.text$mn:00000F10                 push    eax
.text$mn:00000F11                 push    ecx
.text$mn:00000F12                 mov     eax, dword ptr ds:___security_cookie
.text$mn:00000F17                 xor     eax, ebp
.text$mn:00000F19                 push    eax
.text$mn:00000F1A                 lea     eax, [ebp+var_C]
.text$mn:00000F1D                 mov     large fs:0, eax
.text$mn:00000F23                 mov     [ebp+var_10], ecx
.text$mn:00000F26                 mov     [ebp+var_4], 0
.text$mn:00000F2D                 mov     [ebp+var_4], 0FFFFFFFFh
.text$mn:00000F34                 mov     ecx, [ebp+var_10] ; this
.text$mn:00000F37                 call    ??1_Generic_error_category@std@@UAE@XZ ; std::_Generic_error_category::~_Generic_error_category(void)
.text$mn:00000F3C                 mov     ecx, [ebp+var_C]
.text$mn:00000F3F                 mov     large fs:0, ecx
.text$mn:00000F46                 pop     ecx
.text$mn:00000F47                 mov     esp, ebp
.text$mn:00000F49                 pop     ebp
.text$mn:00000F4A                 retn
.text$mn:00000F4A ??1_System_error_category@std@@UAE@XZ endp
.text$mn:00000F4A
.text$mn:00000F4A ; ---------------------------------------------------------------------------
.text$mn:00000F4B                 align 4
.text$mn:00000F4B _text$mn        ends
.text$mn:00000F4B
.text$x:00000F4C ; ===========================================================================
.text$x:00000F4C
.text$x:00000F4C ; Segment type: Pure code
.text$x:00000F4C ; Segment permissions: Read/Execute
.text$x:00000F4C _text$x         segment para public 'CODE' use32
.text$x:00000F4C                 assume cs:_text$x
.text$x:00000F4C                 ;org 0F4Ch
.text$x:00000F4C ; COMDAT (pick associative to section at F00)
.text$x:00000F4C                 assume es:nothing, ss:nothing, ds:_xdata$x, fs:nothing, gs:nothing
.text$x:00000F4C
.text$x:00000F4C ; =============== S U B R O U T I N E =======================================
.text$x:00000F4C
.text$x:00000F4C
.text$x:00000F4C __unwindfunclet$??1_System_error_category@std@@UAE@XZ$0 proc near
.text$x:00000F4C                                         ; DATA XREF: .xdata$x:00002B10o
.text$x:00000F4C                 mov     ecx, [ebp-10h]  ; this
.text$x:00000F4F                 jmp     ??1_Generic_error_category@std@@UAE@XZ ; std::_Generic_error_category::~_Generic_error_category(void)
.text$x:00000F4F __unwindfunclet$??1_System_error_category@std@@UAE@XZ$0 endp
.text$x:00000F4F
.text$x:00000F54
.text$x:00000F54 ; =============== S U B R O U T I N E =======================================
.text$x:00000F54
.text$x:00000F54
.text$x:00000F54 __ehhandler$??1_System_error_category@std@@UAE@XZ proc near
.text$x:00000F54                                         ; DATA XREF: std::_System_error_category::~_System_error_category(void)+5o
.text$x:00000F54
.text$x:00000F54 arg_4           = dword ptr  8
.text$x:00000F54
.text$x:00000F54                 mov     edx, [esp+arg_4]
.text$x:00000F58                 lea     eax, [edx+0Ch]
.text$x:00000F5B                 mov     ecx, [edx-8]
.text$x:00000F5E                 xor     ecx, eax
.text$x:00000F60                 call    @__security_check_cookie@4 ; __security_check_cookie(x)
.text$x:00000F65                 mov     eax, offset __ehfuncinfo$??1_System_error_category@std@@UAE@XZ
.text$x:00000F6A                 jmp     ___CxxFrameHandler3
.text$x:00000F6A __ehhandler$??1_System_error_category@std@@UAE@XZ endp
.text$x:00000F6A
.text$x:00000F6A ; ---------------------------------------------------------------------------
.text$x:00000F6F                 align 10h
.text$x:00000F6F _text$x         ends
.text$x:00000F6F
.text$mn:00000F70 ; ===========================================================================
.text$mn:00000F70
.text$mn:00000F70 ; Segment type: Pure code
.text$mn:00000F70 ; Segment permissions: Read/Execute
.text$mn:00000F70 _text$mn        segment para public 'CODE' use32
.text$mn:00000F70                 assume cs:_text$mn
.text$mn:00000F70                 ;org 0F70h
.text$mn:00000F70 ; COMDAT (pick any)
.text$mn:00000F70                 assume es:nothing, ss:nothing, ds:_xdata$x, fs:nothing, gs:nothing
.text$mn:00000F70
.text$mn:00000F70 ; =============== S U B R O U T I N E =======================================
.text$mn:00000F70
.text$mn:00000F70 ; Attributes: bp-based frame
.text$mn:00000F70
.text$mn:00000F70 ; _DWORD __thiscall std::error_category::~error_category(std::error_category *__hidden this)
.text$mn:00000F70                 public ??1error_category@std@@UAE@XZ
.text$mn:00000F70 ??1error_category@std@@UAE@XZ proc near ; CODE XREF: __unwindfunclet$??0_Generic_error_category@std@@QAE@XZ$0+3j
.text$mn:00000F70                                         ; std::_Generic_error_category::~_Generic_error_category(void)+37p ...
.text$mn:00000F70
.text$mn:00000F70 var_4           = dword ptr -4
.text$mn:00000F70
.text$mn:00000F70                 push    ebp
.text$mn:00000F71                 mov     ebp, esp
.text$mn:00000F73                 push    ecx
.text$mn:00000F74                 mov     [ebp+var_4], ecx
.text$mn:00000F77                 mov     eax, [ebp+var_4]
.text$mn:00000F7A                 mov     dword ptr [eax], offset ??_7error_category@std@@6B@ ; const std::error_category::`vftable'
.text$mn:00000F80                 mov     esp, ebp
.text$mn:00000F82                 pop     ebp
.text$mn:00000F83                 retn
.text$mn:00000F83 ??1error_category@std@@UAE@XZ endp
.text$mn:00000F83
.text$mn:00000F83 _text$mn        ends
.text$mn:00000F83
.text$mn:00000F84 ; ===========================================================================
.text$mn:00000F84
.text$mn:00000F84 ; Segment type: Pure code
.text$mn:00000F84 ; Segment permissions: Read/Execute
.text$mn:00000F84 _text$mn        segment para public 'CODE' use32
.text$mn:00000F84                 assume cs:_text$mn
.text$mn:00000F84                 ;org 0F84h
.text$mn:00000F84 ; COMDAT (pick any)
.text$mn:00000F84                 assume es:nothing, ss:nothing, ds:_xdata$x, fs:nothing, gs:nothing
.text$mn:00000F84
.text$mn:00000F84 ; =============== S U B R O U T I N E =======================================
.text$mn:00000F84
.text$mn:00000F84 ; Attributes: bp-based frame
.text$mn:00000F84
.text$mn:00000F84 ; void *__cdecl operator new(unsigned int, void *)
.text$mn:00000F84                 public ??2@YAPAXIPAX@Z
.text$mn:00000F84 ??2@YAPAXIPAX@Z proc near               ; CODE XREF: std::allocator<char>::construct<char *,char * &>(char * *,char * &)+2Ep
.text$mn:00000F84                                         ; std::allocator<wchar_t>::construct<wchar_t *,wchar_t * &>(wchar_t * *,wchar_t * &)+2Ep ...
.text$mn:00000F84
.text$mn:00000F84 arg_4           = dword ptr  0Ch
.text$mn:00000F84
.text$mn:00000F84                 push    ebp
.text$mn:00000F85                 mov     ebp, esp
.text$mn:00000F87                 mov     eax, [ebp+arg_4]
.text$mn:00000F8A                 pop     ebp
.text$mn:00000F8B                 retn
.text$mn:00000F8B ??2@YAPAXIPAX@Z endp
.text$mn:00000F8B
.text$mn:00000F8B _text$mn        ends
.text$mn:00000F8B
.text$mn:00000F8C ; ===========================================================================
.text$mn:00000F8C
.text$mn:00000F8C ; Segment type: Pure code
.text$mn:00000F8C ; Segment permissions: Read/Execute
.text$mn:00000F8C _text$mn        segment para public 'CODE' use32
.text$mn:00000F8C                 assume cs:_text$mn
.text$mn:00000F8C                 ;org 0F8Ch
.text$mn:00000F8C ; COMDAT (pick any)
.text$mn:00000F8C                 assume es:nothing, ss:nothing, ds:_xdata$x, fs:nothing, gs:nothing
.text$mn:00000F8C
.text$mn:00000F8C ; =============== S U B R O U T I N E =======================================
.text$mn:00000F8C
.text$mn:00000F8C ; Attributes: bp-based frame
.text$mn:00000F8C
.text$mn:00000F8C ; void __cdecl operator delete(void *)
.text$mn:00000F8C                 public ??3@YAXPAX0@Z
.text$mn:00000F8C ??3@YAXPAX0@Z   proc near               ; CODE XREF: __unwindfunclet$??$construct@PADAAPAD@?$allocator@D@std@@QAEXPAPADAAPAD@Z$0+8p
.text$mn:00000F8C                                         ; __unwindfunclet$??$construct@PA_WAAPA_W@?$allocator@_W@std@@QAEXPAPA_WAAPA_W@Z$0+8p ...
.text$mn:00000F8C                 push    ebp
.text$mn:00000F8D                 mov     ebp, esp
.text$mn:00000F8F                 pop     ebp
.text$mn:00000F90                 retn
.text$mn:00000F90 ??3@YAXPAX0@Z   endp
.text$mn:00000F90
.text$mn:00000F90 ; ---------------------------------------------------------------------------
.text$mn:00000F91                 align 4
.text$mn:00000F91 _text$mn        ends
.text$mn:00000F91
.text$mn:00000F94 ; ===========================================================================
.text$mn:00000F94
.text$mn:00000F94 ; Segment type: Pure code
.text$mn:00000F94 ; Segment permissions: Read/Execute
.text$mn:00000F94 _text$mn        segment para public 'CODE' use32
.text$mn:00000F94                 assume cs:_text$mn
.text$mn:00000F94                 ;org 0F94h
.text$mn:00000F94 ; COMDAT (pick any)
.text$mn:00000F94                 assume es:nothing, ss:nothing, ds:_xdata$x, fs:nothing, gs:nothing
.text$mn:00000F94
.text$mn:00000F94 ; =============== S U B R O U T I N E =======================================
.text$mn:00000F94
.text$mn:00000F94 ; Attributes: bp-based frame
.text$mn:00000F94
.text$mn:00000F94 ; int __stdcall std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>>::operator=(wchar_t *Str)
.text$mn:00000F94                 public ??4?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QAEAAV01@PB_W@Z
.text$mn:00000F94 ??4?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QAEAAV01@PB_W@Z proc near
.text$mn:00000F94                                         ; CODE XREF: ValueDlg::init(HINSTANCE__ *,HWND__ *,int,wchar_t const *)+2Ap
.text$mn:00000F94
.text$mn:00000F94 var_4           = dword ptr -4
.text$mn:00000F94 Str             = dword ptr  8
.text$mn:00000F94
.text$mn:00000F94                 push    ebp
.text$mn:00000F95                 mov     ebp, esp
.text$mn:00000F97                 push    ecx
.text$mn:00000F98                 mov     [ebp+var_4], ecx
.text$mn:00000F9B                 mov     eax, [ebp+Str]
.text$mn:00000F9E                 push    eax             ; Str
.text$mn:00000F9F                 mov     ecx, [ebp+var_4]
.text$mn:00000FA2                 call    ?assign@?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QAEAAV12@PB_W@Z ; std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>>::assign(wchar_t const *)
.text$mn:00000FA7                 mov     esp, ebp
.text$mn:00000FA9                 pop     ebp
.text$mn:00000FAA                 retn    4
.text$mn:00000FAA ??4?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QAEAAV01@PB_W@Z endp
.text$mn:00000FAA
.text$mn:00000FAA ; ---------------------------------------------------------------------------
.text$mn:00000FAD                 align 10h
.text$mn:00000FAD _text$mn        ends
.text$mn:00000FAD
.text$mn:00000FB0 ; ===========================================================================
.text$mn:00000FB0
.text$mn:00000FB0 ; Segment type: Pure code
.text$mn:00000FB0 ; Segment permissions: Read/Execute
.text$mn:00000FB0 _text$mn        segment para public 'CODE' use32
.text$mn:00000FB0                 assume cs:_text$mn
.text$mn:00000FB0                 ;org 0FB0h
.text$mn:00000FB0 ; COMDAT (pick any)
.text$mn:00000FB0                 assume es:nothing, ss:nothing, ds:_xdata$x, fs:nothing, gs:nothing
.text$mn:00000FB0
.text$mn:00000FB0 ; =============== S U B R O U T I N E =======================================
.text$mn:00000FB0
.text$mn:00000FB0 ; Attributes: bp-based frame
.text$mn:00000FB0
.text$mn:00000FB0 ; public: bool __thiscall std::error_category::operator==(class std::error_category const &)const
.text$mn:00000FB0                 public ??8error_category@std@@QBE_NABV01@@Z
.text$mn:00000FB0 ??8error_category@std@@QBE_NABV01@@Z proc near
.text$mn:00000FB0                                         ; CODE XREF: std::error_condition::operator==(std::error_condition const &)+1Dp
.text$mn:00000FB0                                         ; std::error_category::equivalent(std::error_code const &,int)+15p
.text$mn:00000FB0
.text$mn:00000FB0 var_8           = dword ptr -8
.text$mn:00000FB0 var_4           = dword ptr -4
.text$mn:00000FB0 arg_0           = dword ptr  8
.text$mn:00000FB0
.text$mn:00000FB0                 push    ebp
.text$mn:00000FB1                 mov     ebp, esp
.text$mn:00000FB3                 sub     esp, 8
.text$mn:00000FB6                 mov     [ebp+var_8], ecx
.text$mn:00000FB9                 mov     eax, [ebp+var_8]
.text$mn:00000FBC                 cmp     eax, [ebp+arg_0]
.text$mn:00000FBF                 jnz     short loc_FCA
.text$mn:00000FC1                 mov     [ebp+var_4], 1
.text$mn:00000FC8                 jmp     short loc_FD1
.text$mn:00000FCA ; ---------------------------------------------------------------------------
.text$mn:00000FCA
.text$mn:00000FCA loc_FCA:                                ; CODE XREF: std::error_category::operator==(std::error_category const &)+Fj
.text$mn:00000FCA                 mov     [ebp+var_4], 0
.text$mn:00000FD1
.text$mn:00000FD1 loc_FD1:                                ; CODE XREF: std::error_category::operator==(std::error_category const &)+18j
.text$mn:00000FD1                 mov     al, byte ptr [ebp+var_4]
.text$mn:00000FD4                 mov     esp, ebp
.text$mn:00000FD6                 pop     ebp
.text$mn:00000FD7                 retn    4
.text$mn:00000FD7 ??8error_category@std@@QBE_NABV01@@Z endp
.text$mn:00000FD7
.text$mn:00000FD7 ; ---------------------------------------------------------------------------
.text$mn:00000FDA                 align 4
.text$mn:00000FDA _text$mn        ends
.text$mn:00000FDA
.text$mn:00000FDC ; ===========================================================================
.text$mn:00000FDC
.text$mn:00000FDC ; Segment type: Pure code
.text$mn:00000FDC ; Segment permissions: Read/Execute
.text$mn:00000FDC _text$mn        segment para public 'CODE' use32
.text$mn:00000FDC                 assume cs:_text$mn
.text$mn:00000FDC                 ;org 0FDCh
.text$mn:00000FDC ; COMDAT (pick any)
.text$mn:00000FDC                 assume es:nothing, ss:nothing, ds:_xdata$x, fs:nothing, gs:nothing
.text$mn:00000FDC
.text$mn:00000FDC ; =============== S U B R O U T I N E =======================================
.text$mn:00000FDC
.text$mn:00000FDC ; Attributes: bp-based frame
.text$mn:00000FDC
.text$mn:00000FDC ; int __stdcall std::error_condition::operator==(std::error_condition *)
.text$mn:00000FDC                 public ??8error_condition@std@@QBE_NABV01@@Z
.text$mn:00000FDC ??8error_condition@std@@QBE_NABV01@@Z proc near
.text$mn:00000FDC                                         ; CODE XREF: std::error_category::equivalent(int,std::error_condition const &)+24p
.text$mn:00000FDC
.text$mn:00000FDC var_8           = dword ptr -8
.text$mn:00000FDC var_4           = dword ptr -4
.text$mn:00000FDC arg_0           = dword ptr  8
.text$mn:00000FDC
.text$mn:00000FDC                 push    ebp
.text$mn:00000FDD                 mov     ebp, esp
.text$mn:00000FDF                 sub     esp, 8
.text$mn:00000FE2                 push    esi
.text$mn:00000FE3                 mov     [ebp+var_4], ecx
.text$mn:00000FE6                 mov     ecx, [ebp+arg_0] ; this
.text$mn:00000FE9                 call    ?category@error_condition@std@@QBEABVerror_category@2@XZ ; std::error_condition::category(void)
.text$mn:00000FEE                 push    eax
.text$mn:00000FEF                 mov     ecx, [ebp+var_4] ; this
.text$mn:00000FF2                 call    ?category@error_condition@std@@QBEABVerror_category@2@XZ ; std::error_condition::category(void)
.text$mn:00000FF7                 mov     ecx, eax
.text$mn:00000FF9                 call    ??8error_category@std@@QBE_NABV01@@Z ; std::error_category::operator==(std::error_category const &)
.text$mn:00000FFE                 movzx   eax, al
.text$mn:00001001                 test    eax, eax
.text$mn:00001003                 jz      short loc_1024
.text$mn:00001005                 mov     ecx, [ebp+var_4] ; this
.text$mn:00001008                 call    ?value@error_condition@std@@QBEHXZ ; std::error_condition::value(void)
.text$mn:0000100D                 mov     esi, eax
.text$mn:0000100F                 mov     ecx, [ebp+arg_0] ; this
.text$mn:00001012                 call    ?value@error_condition@std@@QBEHXZ ; std::error_condition::value(void)
.text$mn:00001017                 cmp     esi, eax
.text$mn:00001019                 jnz     short loc_1024
.text$mn:0000101B                 mov     [ebp+var_8], 1
.text$mn:00001022                 jmp     short loc_102B
.text$mn:00001024 ; ---------------------------------------------------------------------------
.text$mn:00001024
.text$mn:00001024 loc_1024:                               ; CODE XREF: std::error_condition::operator==(std::error_condition const &)+27j
.text$mn:00001024                                         ; std::error_condition::operator==(std::error_condition const &)+3Dj
.text$mn:00001024                 mov     [ebp+var_8], 0
.text$mn:0000102B
.text$mn:0000102B loc_102B:                               ; CODE XREF: std::error_condition::operator==(std::error_condition const &)+46j
.text$mn:0000102B                 mov     al, byte ptr [ebp+var_8]
.text$mn:0000102E                 pop     esi
.text$mn:0000102F                 mov     esp, ebp
.text$mn:00001031                 pop     ebp
.text$mn:00001032                 retn    4
.text$mn:00001032 ??8error_condition@std@@QBE_NABV01@@Z endp
.text$mn:00001032
.text$mn:00001032 ; ---------------------------------------------------------------------------
.text$mn:00001035                 align 4
.text$mn:00001035 _text$mn        ends
.text$mn:00001035
.text$mn:00001038 ; ===========================================================================
.text$mn:00001038
.text$mn:00001038 ; Segment type: Pure code
.text$mn:00001038 ; Segment permissions: Read/Execute
.text$mn:00001038 _text$mn        segment para public 'CODE' use32
.text$mn:00001038                 assume cs:_text$mn
.text$mn:00001038                 ;org 1038h
.text$mn:00001038 ; COMDAT (pick any)
.text$mn:00001038                 assume es:nothing, ss:nothing, ds:_xdata$x, fs:nothing, gs:nothing
.text$mn:00001038
.text$mn:00001038 ; =============== S U B R O U T I N E =======================================
.text$mn:00001038
.text$mn:00001038 ; Attributes: bp-based frame
.text$mn:00001038
.text$mn:00001038 ; public: virtual void * __thiscall std::_Generic_error_category::`scalar deleting destructor'(unsigned int)
.text$mn:00001038                 public ??_G_Generic_error_category@std@@UAEPAXI@Z
.text$mn:00001038 ??_G_Generic_error_category@std@@UAEPAXI@Z proc near
.text$mn:00001038
.text$mn:00001038 var_4           = dword ptr -4
.text$mn:00001038 arg_0           = dword ptr  8
.text$mn:00001038
.text$mn:00001038                 push    ebp
.text$mn:00001039                 mov     ebp, esp
.text$mn:0000103B                 push    ecx
.text$mn:0000103C                 mov     [ebp+var_4], ecx
.text$mn:0000103F                 mov     ecx, [ebp+var_4] ; this
.text$mn:00001042                 call    ??1_Generic_error_category@std@@UAE@XZ ; std::_Generic_error_category::~_Generic_error_category(void)
.text$mn:00001047                 mov     eax, [ebp+arg_0]
.text$mn:0000104A                 and     eax, 1
.text$mn:0000104D                 jz      short loc_105B
.text$mn:0000104F                 mov     ecx, [ebp+var_4]
.text$mn:00001052                 push    ecx             ; void *
.text$mn:00001053                 call    ??3@YAXPAX@Z    ; operator delete(void *)
.text$mn:00001058                 add     esp, 4
.text$mn:0000105B
.text$mn:0000105B loc_105B:                               ; CODE XREF: std::_Generic_error_category::`scalar deleting destructor'(uint)+15j
.text$mn:0000105B                 mov     eax, [ebp+var_4]
.text$mn:0000105E                 mov     esp, ebp
.text$mn:00001060                 pop     ebp
.text$mn:00001061                 retn    4
.text$mn:00001061 ??_G_Generic_error_category@std@@UAEPAXI@Z endp
.text$mn:00001061
.text$mn:00001061 _text$mn        ends
.text$mn:00001061
.text$mn:00001064 ; ===========================================================================
.text$mn:00001064
.text$mn:00001064 ; Segment type: Pure code
.text$mn:00001064 ; Segment permissions: Read/Execute
.text$mn:00001064 _text$mn        segment para public 'CODE' use32
.text$mn:00001064                 assume cs:_text$mn
.text$mn:00001064                 ;org 1064h
.text$mn:00001064 ; COMDAT (pick any)
.text$mn:00001064                 assume es:nothing, ss:nothing, ds:_xdata$x, fs:nothing, gs:nothing
.text$mn:00001064
.text$mn:00001064 ; =============== S U B R O U T I N E =======================================
.text$mn:00001064
.text$mn:00001064 ; Attributes: bp-based frame
.text$mn:00001064
.text$mn:00001064 ; public: virtual void * __thiscall std::_Iostream_error_category::`scalar deleting destructor'(unsigned int)
.text$mn:00001064                 public ??_G_Iostream_error_category@std@@UAEPAXI@Z
.text$mn:00001064 ??_G_Iostream_error_category@std@@UAEPAXI@Z proc near
.text$mn:00001064
.text$mn:00001064 var_4           = dword ptr -4
.text$mn:00001064 arg_0           = dword ptr  8
.text$mn:00001064
.text$mn:00001064                 push    ebp
.text$mn:00001065                 mov     ebp, esp
.text$mn:00001067                 push    ecx
.text$mn:00001068                 mov     [ebp+var_4], ecx
.text$mn:0000106B                 mov     ecx, [ebp+var_4] ; this
.text$mn:0000106E                 call    ??1_Iostream_error_category@std@@UAE@XZ ; std::_Iostream_error_category::~_Iostream_error_category(void)
.text$mn:00001073                 mov     eax, [ebp+arg_0]
.text$mn:00001076                 and     eax, 1
.text$mn:00001079                 jz      short loc_1087
.text$mn:0000107B                 mov     ecx, [ebp+var_4]
.text$mn:0000107E                 push    ecx             ; void *
.text$mn:0000107F                 call    ??3@YAXPAX@Z    ; operator delete(void *)
.text$mn:00001084                 add     esp, 4
.text$mn:00001087
.text$mn:00001087 loc_1087:                               ; CODE XREF: std::_Iostream_error_category::`scalar deleting destructor'(uint)+15j
.text$mn:00001087                 mov     eax, [ebp+var_4]
.text$mn:0000108A                 mov     esp, ebp
.text$mn:0000108C                 pop     ebp
.text$mn:0000108D                 retn    4
.text$mn:0000108D ??_G_Iostream_error_category@std@@UAEPAXI@Z endp
.text$mn:0000108D
.text$mn:0000108D _text$mn        ends
.text$mn:0000108D
.text$mn:00001090 ; ===========================================================================
.text$mn:00001090
.text$mn:00001090 ; Segment type: Pure code
.text$mn:00001090 ; Segment permissions: Read/Execute
.text$mn:00001090 _text$mn        segment para public 'CODE' use32
.text$mn:00001090                 assume cs:_text$mn
.text$mn:00001090                 ;org 1090h
.text$mn:00001090 ; COMDAT (pick any)
.text$mn:00001090                 assume es:nothing, ss:nothing, ds:_xdata$x, fs:nothing, gs:nothing
.text$mn:00001090
.text$mn:00001090 ; =============== S U B R O U T I N E =======================================
.text$mn:00001090
.text$mn:00001090 ; Attributes: bp-based frame
.text$mn:00001090
.text$mn:00001090 ; public: virtual void * __thiscall std::_System_error_category::`scalar deleting destructor'(unsigned int)
.text$mn:00001090                 public ??_G_System_error_category@std@@UAEPAXI@Z
.text$mn:00001090 ??_G_System_error_category@std@@UAEPAXI@Z proc near
.text$mn:00001090
.text$mn:00001090 var_4           = dword ptr -4
.text$mn:00001090 arg_0           = dword ptr  8
.text$mn:00001090
.text$mn:00001090                 push    ebp
.text$mn:00001091                 mov     ebp, esp
.text$mn:00001093                 push    ecx
.text$mn:00001094                 mov     [ebp+var_4], ecx
.text$mn:00001097                 mov     ecx, [ebp+var_4] ; this
.text$mn:0000109A                 call    ??1_System_error_category@std@@UAE@XZ ; std::_System_error_category::~_System_error_category(void)
.text$mn:0000109F                 mov     eax, [ebp+arg_0]
.text$mn:000010A2                 and     eax, 1
.text$mn:000010A5                 jz      short loc_10B3
.text$mn:000010A7                 mov     ecx, [ebp+var_4]
.text$mn:000010AA                 push    ecx             ; void *
.text$mn:000010AB                 call    ??3@YAXPAX@Z    ; operator delete(void *)
.text$mn:000010B0                 add     esp, 4
.text$mn:000010B3
.text$mn:000010B3 loc_10B3:                               ; CODE XREF: std::_System_error_category::`scalar deleting destructor'(uint)+15j
.text$mn:000010B3                 mov     eax, [ebp+var_4]
.text$mn:000010B6                 mov     esp, ebp
.text$mn:000010B8                 pop     ebp
.text$mn:000010B9                 retn    4
.text$mn:000010B9 ??_G_System_error_category@std@@UAEPAXI@Z endp
.text$mn:000010B9
.text$mn:000010B9 _text$mn        ends
.text$mn:000010B9
.text$mn:000010BC ; ===========================================================================
.text$mn:000010BC
.text$mn:000010BC ; Segment type: Pure code
.text$mn:000010BC ; Segment permissions: Read/Execute
.text$mn:000010BC _text$mn        segment para public 'CODE' use32
.text$mn:000010BC                 assume cs:_text$mn
.text$mn:000010BC                 ;org 10BCh
.text$mn:000010BC ; COMDAT (pick any)
.text$mn:000010BC                 assume es:nothing, ss:nothing, ds:_xdata$x, fs:nothing, gs:nothing
.text$mn:000010BC
.text$mn:000010BC ; =============== S U B R O U T I N E =======================================
.text$mn:000010BC
.text$mn:000010BC ; Attributes: bp-based frame
.text$mn:000010BC
.text$mn:000010BC ; public: virtual void * __thiscall std::error_category::`scalar deleting destructor'(unsigned int)
.text$mn:000010BC                 public ??_Gerror_category@std@@UAEPAXI@Z
.text$mn:000010BC ??_Gerror_category@std@@UAEPAXI@Z proc near
.text$mn:000010BC
.text$mn:000010BC var_4           = dword ptr -4
.text$mn:000010BC arg_0           = dword ptr  8
.text$mn:000010BC
.text$mn:000010BC                 push    ebp
.text$mn:000010BD                 mov     ebp, esp
.text$mn:000010BF                 push    ecx
.text$mn:000010C0                 mov     [ebp+var_4], ecx
.text$mn:000010C3                 mov     ecx, [ebp+var_4] ; this
.text$mn:000010C6                 call    ??1error_category@std@@UAE@XZ ; std::error_category::~error_category(void)
.text$mn:000010CB                 mov     eax, [ebp+arg_0]
.text$mn:000010CE                 and     eax, 1
.text$mn:000010D1                 jz      short loc_10DF
.text$mn:000010D3                 mov     ecx, [ebp+var_4]
.text$mn:000010D6                 push    ecx             ; void *
.text$mn:000010D7                 call    ??3@YAXPAX@Z    ; operator delete(void *)
.text$mn:000010DC                 add     esp, 4
.text$mn:000010DF
.text$mn:000010DF loc_10DF:                               ; CODE XREF: std::error_category::`scalar deleting destructor'(uint)+15j
.text$mn:000010DF                 mov     eax, [ebp+var_4]
.text$mn:000010E2                 mov     esp, ebp
.text$mn:000010E4                 pop     ebp
.text$mn:000010E5                 retn    4
.text$mn:000010E5 ??_Gerror_category@std@@UAEPAXI@Z endp
.text$mn:000010E5
.text$mn:000010E5 _text$mn        ends
.text$mn:000010E5
.text$di:000010E8 ; ===========================================================================
.text$di:000010E8
.text$di:000010E8 ; Segment type: Pure code
.text$di:000010E8 ; Segment permissions: Read/Execute
.text$di:000010E8 _text$di        segment para public 'CODE' use32
.text$di:000010E8                 assume cs:_text$di
.text$di:000010E8                 ;org 10E8h
.text$di:000010E8 ; COMDAT (pick any)
.text$di:000010E8                 assume es:nothing, ss:nothing, ds:_xdata$x, fs:nothing, gs:nothing
.text$di:000010E8
.text$di:000010E8 ; =============== S U B R O U T I N E =======================================
.text$di:000010E8
.text$di:000010E8 ; Attributes: bp-based frame
.text$di:000010E8
.text$di:000010E8 ; void __cdecl `dynamic initializer for 'public: static class std::_Generic_error_category std::_Error_objects<int>::_Generic_object''(void)
.text$di:000010E8 ??__E?_Generic_object@?$_Error_objects@H@std@@2V_Generic_error_category@2@A@@YAXXZ proc near
.text$di:000010E8                                         ; DATA XREF: .CRT$XCU:void (*std::_Error_objects<int>::_Generic_object$initializer$)(void)o
.text$di:000010E8                 push    ebp
.text$di:000010E9                 mov     ebp, esp
.text$di:000010EB                 mov     ecx, offset ?_Generic_object@?$_Error_objects@H@std@@2V_Generic_error_category@2@A ; this
.text$di:000010F0                 call    ??0_Generic_error_category@std@@QAE@XZ ; std::_Generic_error_category::_Generic_error_category(void)
.text$di:000010F5                 push    offset ??__F?_Generic_object@?$_Error_objects@H@std@@2V_Generic_error_category@2@A@@YAXXZ ; void (__cdecl *)()
.text$di:000010FA                 call    _atexit
.text$di:000010FF                 add     esp, 4
.text$di:00001102                 pop     ebp
.text$di:00001103                 retn
.text$di:00001103 ??__E?_Generic_object@?$_Error_objects@H@std@@2V_Generic_error_category@2@A@@YAXXZ endp
.text$di:00001103
.text$di:00001103 _text$di        ends
.text$di:00001103
.text$di:00001104 ; ===========================================================================
.text$di:00001104
.text$di:00001104 ; Segment type: Pure code
.text$di:00001104 ; Segment permissions: Read/Execute
.text$di:00001104 _text$di        segment para public 'CODE' use32
.text$di:00001104                 assume cs:_text$di
.text$di:00001104                 ;org 1104h
.text$di:00001104 ; COMDAT (pick any)
.text$di:00001104                 assume es:nothing, ss:nothing, ds:_xdata$x, fs:nothing, gs:nothing
.text$di:00001104
.text$di:00001104 ; =============== S U B R O U T I N E =======================================
.text$di:00001104
.text$di:00001104 ; Attributes: bp-based frame
.text$di:00001104
.text$di:00001104 ; void __cdecl `dynamic initializer for 'public: static class std::_Iostream_error_category std::_Error_objects<int>::_Iostream_object''(void)
.text$di:00001104 ??__E?_Iostream_object@?$_Error_objects@H@std@@2V_Iostream_error_category@2@A@@YAXXZ proc near
.text$di:00001104                                         ; DATA XREF: .CRT$XCU:void (*std::_Error_objects<int>::_Iostream_object$initializer$)(void)o
.text$di:00001104                 push    ebp
.text$di:00001105                 mov     ebp, esp
.text$di:00001107                 mov     ecx, offset ?_Iostream_object@?$_Error_objects@H@std@@2V_Iostream_error_category@2@A ; this
.text$di:0000110C                 call    ??0_Iostream_error_category@std@@QAE@XZ ; std::_Iostream_error_category::_Iostream_error_category(void)
.text$di:00001111                 push    offset ??__F?_Iostream_object@?$_Error_objects@H@std@@2V_Iostream_error_category@2@A@@YAXXZ ; void (__cdecl *)()
.text$di:00001116                 call    _atexit
.text$di:0000111B                 add     esp, 4
.text$di:0000111E                 pop     ebp
.text$di:0000111F                 retn
.text$di:0000111F ??__E?_Iostream_object@?$_Error_objects@H@std@@2V_Iostream_error_category@2@A@@YAXXZ endp
.text$di:0000111F
.text$di:0000111F _text$di        ends
.text$di:0000111F
.text$di:00001120 ; ===========================================================================
.text$di:00001120
.text$di:00001120 ; Segment type: Pure code
.text$di:00001120 ; Segment permissions: Read/Execute
.text$di:00001120 _text$di        segment para public 'CODE' use32
.text$di:00001120                 assume cs:_text$di
.text$di:00001120                 ;org 1120h
.text$di:00001120 ; COMDAT (pick any)
.text$di:00001120                 assume es:nothing, ss:nothing, ds:_xdata$x, fs:nothing, gs:nothing
.text$di:00001120
.text$di:00001120 ; =============== S U B R O U T I N E =======================================
.text$di:00001120
.text$di:00001120 ; Attributes: bp-based frame
.text$di:00001120
.text$di:00001120 ; void __cdecl `dynamic initializer for 'public: static class std::_System_error_category std::_Error_objects<int>::_System_object''(void)
.text$di:00001120 ??__E?_System_object@?$_Error_objects@H@std@@2V_System_error_category@2@A@@YAXXZ proc near
.text$di:00001120                                         ; DATA XREF: .CRT$XCU:void (*std::_Error_objects<int>::_System_object$initializer$)(void)o
.text$di:00001120                 push    ebp
.text$di:00001121                 mov     ebp, esp
.text$di:00001123                 mov     ecx, offset ?_System_object@?$_Error_objects@H@std@@2V_System_error_category@2@A ; this
.text$di:00001128                 call    ??0_System_error_category@std@@QAE@XZ ; std::_System_error_category::_System_error_category(void)
.text$di:0000112D                 push    offset ??__F?_System_object@?$_Error_objects@H@std@@2V_System_error_category@2@A@@YAXXZ ; void (__cdecl *)()
.text$di:00001132                 call    _atexit
.text$di:00001137                 add     esp, 4
.text$di:0000113A                 pop     ebp
.text$di:0000113B                 retn
.text$di:0000113B ??__E?_System_object@?$_Error_objects@H@std@@2V_System_error_category@2@A@@YAXXZ endp
.text$di:0000113B
.text$di:0000113B _text$di        ends
.text$di:0000113B
.text$di:0000113C ; ===========================================================================
.text$di:0000113C
.text$di:0000113C ; Segment type: Pure code
.text$di:0000113C ; Segment permissions: Read/Execute
.text$di:0000113C _text$di        segment para public 'CODE' use32
.text$di:0000113C                 assume cs:_text$di
.text$di:0000113C                 ;org 113Ch
.text$di:0000113C ; COMDAT (pick any)
.text$di:0000113C                 assume es:nothing, ss:nothing, ds:_xdata$x, fs:nothing, gs:nothing
.text$di:0000113C
.text$di:0000113C ; =============== S U B R O U T I N E =======================================
.text$di:0000113C
.text$di:0000113C ; Attributes: bp-based frame
.text$di:0000113C
.text$di:0000113C ; void __cdecl `dynamic initializer for 'public: static class std::locale::id std::num_put<char, class std::back_insert_iterator<class std::basic_string<char, struct std::char_traits<char>, class std::allocator<char>>>>::id''(void)
.text$di:0000113C ??__E?id@?$num_put@DV?$back_insert_iterator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@std@@2V0locale@2@A@@YAXXZ proc near
.text$di:0000113C                                         ; DATA XREF: .CRT$XCU:void (*std::num_put<char,std::back_insert_iterator<std::basic_string<char,std::char_traits<char>,std::allocator<char>>>>::id$initializer$)(void)o
.text$di:0000113C                 push    ebp
.text$di:0000113D                 mov     ebp, esp
.text$di:0000113F                 push    0               ; unsigned int
.text$di:00001141                 mov     ecx, offset ?id@?$num_put@DV?$back_insert_iterator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@std@@2V0locale@2@A ; this
.text$di:00001146                 call    ??0id@locale@std@@QAE@I@Z ; std::locale::id::id(uint)
.text$di:0000114B                 pop     ebp
.text$di:0000114C                 retn
.text$di:0000114C ??__E?id@?$num_put@DV?$back_insert_iterator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@std@@2V0locale@2@A@@YAXXZ endp
.text$di:0000114C
.text$di:0000114C ; ---------------------------------------------------------------------------
.text$di:0000114D                 align 10h
.text$di:0000114D _text$di        ends
.text$di:0000114D
.text$di:00001150 ; ===========================================================================
.text$di:00001150
.text$di:00001150 ; Segment type: Pure code
.text$di:00001150 ; Segment permissions: Read/Execute
.text$di:00001150 _text$di        segment para public 'CODE' use32
.text$di:00001150                 assume cs:_text$di
.text$di:00001150                 ;org 1150h
.text$di:00001150 ; COMDAT (pick any)
.text$di:00001150                 assume es:nothing, ss:nothing, ds:_xdata$x, fs:nothing, gs:nothing
.text$di:00001150
.text$di:00001150 ; =============== S U B R O U T I N E =======================================
.text$di:00001150
.text$di:00001150 ; Attributes: bp-based frame
.text$di:00001150
.text$di:00001150 ; void __cdecl `dynamic initializer for 'public: static class std::locale::id std::num_put<wchar_t, class std::back_insert_iterator<class std::basic_string<wchar_t, struct std::char_traits<wchar_t>, class std::allocator<wchar_t>>>>::id''(void)
.text$di:00001150 ??__E?id@?$num_put@_WV?$back_insert_iterator@V?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@@std@@@std@@2V0locale@2@A@@YAXXZ proc near
.text$di:00001150                                         ; DATA XREF: .CRT$XCU:void (*std::num_put<wchar_t,std::back_insert_iterator<std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>>>>::id$initializer$)(void)o
.text$di:00001150                 push    ebp
.text$di:00001151                 mov     ebp, esp
.text$di:00001153                 push    0               ; unsigned int
.text$di:00001155                 mov     ecx, offset ?id@?$num_put@_WV?$back_insert_iterator@V?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@@std@@@std@@2V0locale@2@A ; this
.text$di:0000115A                 call    ??0id@locale@std@@QAE@I@Z ; std::locale::id::id(uint)
.text$di:0000115F                 pop     ebp
.text$di:00001160                 retn
.text$di:00001160 ??__E?id@?$num_put@_WV?$back_insert_iterator@V?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@@std@@@std@@2V0locale@2@A@@YAXXZ endp
.text$di:00001160
.text$di:00001160 ; ---------------------------------------------------------------------------
.text$di:00001161                 align 4
.text$di:00001161 _text$di        ends
.text$di:00001161
.text$di:00001164 ; ===========================================================================
.text$di:00001164
.text$di:00001164 ; Segment type: Pure code
.text$di:00001164 ; Segment permissions: Read/Execute
.text$di:00001164 _text$di        segment para public 'CODE' use32
.text$di:00001164                 assume cs:_text$di
.text$di:00001164                 ;org 1164h
.text$di:00001164 ; COMDAT (pick any)
.text$di:00001164                 assume es:nothing, ss:nothing, ds:_xdata$x, fs:nothing, gs:nothing
.text$di:00001164
.text$di:00001164 ; =============== S U B R O U T I N E =======================================
.text$di:00001164
.text$di:00001164 ; Attributes: bp-based frame
.text$di:00001164
.text$di:00001164 ; void __cdecl `dynamic initializer for 'public: static class std::locale::id std::numpunct<char>::id''(void)
.text$di:00001164 ??__E?id@?$numpunct@D@std@@2V0locale@2@A@@YAXXZ proc near
.text$di:00001164                                         ; DATA XREF: .CRT$XCU:void (*std::numpunct<char>::id$initializer$)(void)o
.text$di:00001164                 push    ebp
.text$di:00001165                 mov     ebp, esp
.text$di:00001167                 push    0               ; unsigned int
.text$di:00001169                 mov     ecx, offset ?id@?$numpunct@D@std@@2V0locale@2@A ; this
.text$di:0000116E                 call    ??0id@locale@std@@QAE@I@Z ; std::locale::id::id(uint)
.text$di:00001173                 pop     ebp
.text$di:00001174                 retn
.text$di:00001174 ??__E?id@?$numpunct@D@std@@2V0locale@2@A@@YAXXZ endp
.text$di:00001174
.text$di:00001174 ; ---------------------------------------------------------------------------
.text$di:00001175                 align 4
.text$di:00001175 _text$di        ends
.text$di:00001175
.text$di:00001178 ; ===========================================================================
.text$di:00001178
.text$di:00001178 ; Segment type: Pure code
.text$di:00001178 ; Segment permissions: Read/Execute
.text$di:00001178 _text$di        segment para public 'CODE' use32
.text$di:00001178                 assume cs:_text$di
.text$di:00001178                 ;org 1178h
.text$di:00001178 ; COMDAT (pick any)
.text$di:00001178                 assume es:nothing, ss:nothing, ds:_xdata$x, fs:nothing, gs:nothing
.text$di:00001178
.text$di:00001178 ; =============== S U B R O U T I N E =======================================
.text$di:00001178
.text$di:00001178 ; Attributes: bp-based frame
.text$di:00001178
.text$di:00001178 ; void __cdecl `dynamic initializer for 'public: static class std::locale::id std::numpunct<wchar_t>::id''(void)
.text$di:00001178 ??__E?id@?$numpunct@_W@std@@2V0locale@2@A@@YAXXZ proc near
.text$di:00001178                                         ; DATA XREF: .CRT$XCU:void (*std::numpunct<wchar_t>::id$initializer$)(void)o
.text$di:00001178                 push    ebp
.text$di:00001179                 mov     ebp, esp
.text$di:0000117B                 push    0               ; unsigned int
.text$di:0000117D                 mov     ecx, offset ?id@?$numpunct@_W@std@@2V0locale@2@A ; this
.text$di:00001182                 call    ??0id@locale@std@@QAE@I@Z ; std::locale::id::id(uint)
.text$di:00001187                 pop     ebp
.text$di:00001188                 retn
.text$di:00001188 ??__E?id@?$numpunct@_W@std@@2V0locale@2@A@@YAXXZ endp
.text$di:00001188
.text$di:00001188 ; ---------------------------------------------------------------------------
.text$di:00001189                 align 4
.text$di:00001189 _text$di        ends
.text$di:00001189
.text$di:0000118C ; ===========================================================================
.text$di:0000118C
.text$di:0000118C ; Segment type: Pure code
.text$di:0000118C ; Segment permissions: Read/Execute
.text$di:0000118C _text$di        segment para public 'CODE' use32
.text$di:0000118C                 assume cs:_text$di
.text$di:0000118C                 ;org 118Ch
.text$di:0000118C ; COMDAT (pick any)
.text$di:0000118C                 assume es:nothing, ss:nothing, ds:_xdata$x, fs:nothing, gs:nothing
.text$di:0000118C
.text$di:0000118C ; =============== S U B R O U T I N E =======================================
.text$di:0000118C
.text$di:0000118C ; Attributes: bp-based frame
.text$di:0000118C
.text$di:0000118C ; void __cdecl std::`dynamic initializer for 'allocator_arg''(void)
.text$di:0000118C ??__Eallocator_arg@std@@YAXXZ proc near ; DATA XREF: .CRT$XCU:_allocator_arg$initializer$o
.text$di:0000118C
.text$di:0000118C var_1           = byte ptr -1
.text$di:0000118C
.text$di:0000118C                 push    ebp
.text$di:0000118D                 mov     ebp, esp
.text$di:0000118F                 push    ecx
.text$di:00001190                 xor     eax, eax
.text$di:00001192                 mov     [ebp+var_1], al
.text$di:00001195                 mov     esp, ebp
.text$di:00001197                 pop     ebp
.text$di:00001198                 retn
.text$di:00001198 ??__Eallocator_arg@std@@YAXXZ endp
.text$di:00001198
.text$di:00001198 ; ---------------------------------------------------------------------------
.text$di:00001199                 align 4
.text$di:00001199 _text$di        ends
.text$di:00001199
.text$di:0000119C ; ===========================================================================
.text$di:0000119C
.text$di:0000119C ; Segment type: Pure code
.text$di:0000119C ; Segment permissions: Read/Execute
.text$di:0000119C _text$di        segment para public 'CODE' use32
.text$di:0000119C                 assume cs:_text$di
.text$di:0000119C                 ;org 119Ch
.text$di:0000119C ; COMDAT (pick any)
.text$di:0000119C                 assume es:nothing, ss:nothing, ds:_xdata$x, fs:nothing, gs:nothing
.text$di:0000119C
.text$di:0000119C ; =============== S U B R O U T I N E =======================================
.text$di:0000119C
.text$di:0000119C ; Attributes: bp-based frame
.text$di:0000119C
.text$di:0000119C ; void __cdecl std::`dynamic initializer for 'piecewise_construct''(void)
.text$di:0000119C ??__Epiecewise_construct@std@@YAXXZ proc near
.text$di:0000119C                                         ; DATA XREF: .CRT$XCU:_piecewise_construct$initializer$o
.text$di:0000119C
.text$di:0000119C var_1           = byte ptr -1
.text$di:0000119C
.text$di:0000119C                 push    ebp
.text$di:0000119D                 mov     ebp, esp
.text$di:0000119F                 push    ecx
.text$di:000011A0                 xor     eax, eax
.text$di:000011A2                 mov     [ebp+var_1], al
.text$di:000011A5                 mov     esp, ebp
.text$di:000011A7                 pop     ebp
.text$di:000011A8                 retn
.text$di:000011A8 ??__Epiecewise_construct@std@@YAXXZ endp
.text$di:000011A8
.text$di:000011A8 ; ---------------------------------------------------------------------------
.text$di:000011A9                 align 4
.text$di:000011A9 _text$di        ends
.text$di:000011A9
.text$yd:000011AC ; ===========================================================================
.text$yd:000011AC
.text$yd:000011AC ; Segment type: Pure code
.text$yd:000011AC ; Segment permissions: Read/Execute
.text$yd:000011AC _text$yd        segment para public 'CODE' use32
.text$yd:000011AC                 assume cs:_text$yd
.text$yd:000011AC                 ;org 11ACh
.text$yd:000011AC ; COMDAT (pick any)
.text$yd:000011AC                 assume es:nothing, ss:nothing, ds:_xdata$x, fs:nothing, gs:nothing
.text$yd:000011AC
.text$yd:000011AC ; =============== S U B R O U T I N E =======================================
.text$yd:000011AC
.text$yd:000011AC ; Attributes: bp-based frame
.text$yd:000011AC
.text$yd:000011AC ; void __cdecl `dynamic atexit destructor for 'public: static std::_Generic_error_category std::_Error_objects<int>::_Generic_object''()
.text$yd:000011AC ??__F?_Generic_object@?$_Error_objects@H@std@@2V_Generic_error_category@2@A@@YAXXZ proc near
.text$yd:000011AC                                         ; DATA XREF: `dynamic initializer for 'std::_Generic_error_category std::_Error_objects<int>::_Generic_object''(void)+Do
.text$yd:000011AC                 push    ebp
.text$yd:000011AD                 mov     ebp, esp
.text$yd:000011AF                 mov     ecx, offset ?_Generic_object@?$_Error_objects@H@std@@2V_Generic_error_category@2@A ; this
.text$yd:000011B4                 call    ??1_Generic_error_category@std@@UAE@XZ ; std::_Generic_error_category::~_Generic_error_category(void)
.text$yd:000011B9                 pop     ebp
.text$yd:000011BA                 retn
.text$yd:000011BA ??__F?_Generic_object@?$_Error_objects@H@std@@2V_Generic_error_category@2@A@@YAXXZ endp
.text$yd:000011BA
.text$yd:000011BA ; ---------------------------------------------------------------------------
.text$yd:000011BB                 align 4
.text$yd:000011BB _text$yd        ends
.text$yd:000011BB
.text$yd:000011BC ; ===========================================================================
.text$yd:000011BC
.text$yd:000011BC ; Segment type: Pure code
.text$yd:000011BC ; Segment permissions: Read/Execute
.text$yd:000011BC _text$yd        segment para public 'CODE' use32
.text$yd:000011BC                 assume cs:_text$yd
.text$yd:000011BC                 ;org 11BCh
.text$yd:000011BC ; COMDAT (pick any)
.text$yd:000011BC                 assume es:nothing, ss:nothing, ds:_xdata$x, fs:nothing, gs:nothing
.text$yd:000011BC
.text$yd:000011BC ; =============== S U B R O U T I N E =======================================
.text$yd:000011BC
.text$yd:000011BC ; Attributes: bp-based frame
.text$yd:000011BC
.text$yd:000011BC ; void __cdecl `dynamic atexit destructor for 'public: static std::_Iostream_error_category std::_Error_objects<int>::_Iostream_object''()
.text$yd:000011BC ??__F?_Iostream_object@?$_Error_objects@H@std@@2V_Iostream_error_category@2@A@@YAXXZ proc near
.text$yd:000011BC                                         ; DATA XREF: `dynamic initializer for 'std::_Iostream_error_category std::_Error_objects<int>::_Iostream_object''(void)+Do
.text$yd:000011BC                 push    ebp
.text$yd:000011BD                 mov     ebp, esp
.text$yd:000011BF                 mov     ecx, offset ?_Iostream_object@?$_Error_objects@H@std@@2V_Iostream_error_category@2@A ; this
.text$yd:000011C4                 call    ??1_Iostream_error_category@std@@UAE@XZ ; std::_Iostream_error_category::~_Iostream_error_category(void)
.text$yd:000011C9                 pop     ebp
.text$yd:000011CA                 retn
.text$yd:000011CA ??__F?_Iostream_object@?$_Error_objects@H@std@@2V_Iostream_error_category@2@A@@YAXXZ endp
.text$yd:000011CA
.text$yd:000011CA ; ---------------------------------------------------------------------------
.text$yd:000011CB                 align 4
.text$yd:000011CB _text$yd        ends
.text$yd:000011CB
.text$yd:000011CC ; ===========================================================================
.text$yd:000011CC
.text$yd:000011CC ; Segment type: Pure code
.text$yd:000011CC ; Segment permissions: Read/Execute
.text$yd:000011CC _text$yd        segment para public 'CODE' use32
.text$yd:000011CC                 assume cs:_text$yd
.text$yd:000011CC                 ;org 11CCh
.text$yd:000011CC ; COMDAT (pick any)
.text$yd:000011CC                 assume es:nothing, ss:nothing, ds:_xdata$x, fs:nothing, gs:nothing
.text$yd:000011CC
.text$yd:000011CC ; =============== S U B R O U T I N E =======================================
.text$yd:000011CC
.text$yd:000011CC ; Attributes: bp-based frame
.text$yd:000011CC
.text$yd:000011CC ; void __cdecl `dynamic atexit destructor for 'public: static std::_System_error_category std::_Error_objects<int>::_System_object''()
.text$yd:000011CC ??__F?_System_object@?$_Error_objects@H@std@@2V_System_error_category@2@A@@YAXXZ proc near
.text$yd:000011CC                                         ; DATA XREF: `dynamic initializer for 'std::_System_error_category std::_Error_objects<int>::_System_object''(void)+Do
.text$yd:000011CC                 push    ebp
.text$yd:000011CD                 mov     ebp, esp
.text$yd:000011CF                 mov     ecx, offset ?_System_object@?$_Error_objects@H@std@@2V_System_error_category@2@A ; this
.text$yd:000011D4                 call    ??1_System_error_category@std@@UAE@XZ ; std::_System_error_category::~_System_error_category(void)
.text$yd:000011D9                 pop     ebp
.text$yd:000011DA                 retn
.text$yd:000011DA ??__F?_System_object@?$_Error_objects@H@std@@2V_System_error_category@2@A@@YAXXZ endp
.text$yd:000011DA
.text$yd:000011DA ; ---------------------------------------------------------------------------
.text$yd:000011DB                 align 4
.text$yd:000011DB _text$yd        ends
.text$yd:000011DB
.text$mn:000011DC ; ===========================================================================
.text$mn:000011DC
.text$mn:000011DC ; Segment type: Pure code
.text$mn:000011DC ; Segment permissions: Read/Execute
.text$mn:000011DC _text$mn        segment para public 'CODE' use32
.text$mn:000011DC                 assume cs:_text$mn
.text$mn:000011DC                 ;org 11DCh
.text$mn:000011DC ; COMDAT (pick any)
.text$mn:000011DC                 assume es:nothing, ss:nothing, ds:_xdata$x, fs:nothing, gs:nothing
.text$mn:000011DC
.text$mn:000011DC ; =============== S U B R O U T I N E =======================================
.text$mn:000011DC
.text$mn:000011DC ; Attributes: bp-based frame
.text$mn:000011DC
.text$mn:000011DC ; public: void __thiscall std::_String_alloc<0, struct std::_String_base_types<char, class std::allocator<char>>>::_Alloc_proxy(void)
.text$mn:000011DC                 public ?_Alloc_proxy@?$_String_alloc@$0A@U?$_String_base_types@DV?$allocator@D@std@@@std@@@std@@QAEXXZ
.text$mn:000011DC ?_Alloc_proxy@?$_String_alloc@$0A@U?$_String_base_types@DV?$allocator@D@std@@@std@@@std@@QAEXXZ proc near
.text$mn:000011DC                                         ; CODE XREF: std::_String_alloc<0,std::_String_base_types<char,std::allocator<char>>>::_String_alloc<0,std::_String_base_types<char,std::allocator<char>>>(std::allocator<char> const &)+38p
.text$mn:000011DC
.text$mn:000011DC var_10          = byte ptr -10h
.text$mn:000011DC var_8           = dword ptr -8
.text$mn:000011DC var_1           = byte ptr -1
.text$mn:000011DC
.text$mn:000011DC                 push    ebp
.text$mn:000011DD                 mov     ebp, esp
.text$mn:000011DF                 sub     esp, 10h
.text$mn:000011E2                 mov     [ebp+var_8], ecx
.text$mn:000011E5                 lea     ecx, [ebp+var_1]
.text$mn:000011E8                 call    ??0?$allocator@U_Container_proxy@std@@@std@@QAE@XZ ; std::allocator<std::_Container_proxy>::allocator<std::_Container_proxy>(void)
.text$mn:000011ED                 push    1
.text$mn:000011EF                 lea     ecx, [ebp+var_1]
.text$mn:000011F2                 call    ?allocate@?$allocator@U_Container_proxy@std@@@std@@QAEPAU_Container_proxy@2@I@Z ; std::allocator<std::_Container_proxy>::allocate(uint)
.text$mn:000011F7                 mov     ecx, [ebp+var_8]
.text$mn:000011FA                 mov     [ecx], eax
.text$mn:000011FC                 lea     ecx, [ebp+var_10] ; this
.text$mn:000011FF                 call    ??0_Container_proxy@std@@QAE@XZ ; std::_Container_proxy::_Container_proxy(void)
.text$mn:00001204                 push    eax             ; int
.text$mn:00001205                 mov     edx, [ebp+var_8]
.text$mn:00001208                 mov     eax, [edx]
.text$mn:0000120A                 push    eax             ; void *
.text$mn:0000120B                 lea     ecx, [ebp+var_1]
.text$mn:0000120E                 call    ??$construct@U_Container_proxy@std@@U12@@?$allocator@U_Container_proxy@std@@@std@@QAEXPAU_Container_proxy@1@$$QAU21@@Z ; std::allocator<std::_Container_proxy>::construct<std::_Container_proxy,std::_Container_proxy>(std::_Container_proxy *,std::_Container_proxy &&)
.text$mn:00001213                 mov     ecx, [ebp+var_8]
.text$mn:00001216                 mov     edx, [ecx]
.text$mn:00001218                 mov     eax, [ebp+var_8]
.text$mn:0000121B                 mov     [edx], eax
.text$mn:0000121D                 mov     esp, ebp
.text$mn:0000121F                 pop     ebp
.text$mn:00001220                 retn
.text$mn:00001220 ?_Alloc_proxy@?$_String_alloc@$0A@U?$_String_base_types@DV?$allocator@D@std@@@std@@@std@@QAEXXZ endp
.text$mn:00001220
.text$mn:00001220 ; ---------------------------------------------------------------------------
.text$mn:00001221                 align 4
.text$mn:00001221 _text$mn        ends
.text$mn:00001221
.text$mn:00001224 ; ===========================================================================
.text$mn:00001224
.text$mn:00001224 ; Segment type: Pure code
.text$mn:00001224 ; Segment permissions: Read/Execute
.text$mn:00001224 _text$mn        segment para public 'CODE' use32
.text$mn:00001224                 assume cs:_text$mn
.text$mn:00001224                 ;org 1224h
.text$mn:00001224 ; COMDAT (pick any)
.text$mn:00001224                 assume es:nothing, ss:nothing, ds:_xdata$x, fs:nothing, gs:nothing
.text$mn:00001224
.text$mn:00001224 ; =============== S U B R O U T I N E =======================================
.text$mn:00001224
.text$mn:00001224 ; Attributes: bp-based frame
.text$mn:00001224
.text$mn:00001224 ; public: void __thiscall std::basic_string<char, struct std::char_traits<char>, class std::allocator<char>>::_Copy(unsigned int, unsigned int)
.text$mn:00001224                 public ?_Copy@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEXII@Z
.text$mn:00001224 ?_Copy@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEXII@Z proc near
.text$mn:00001224                                         ; CODE XREF: std::basic_string<char,std::char_traits<char>,std::allocator<char>>::_Grow(uint,bool)+37p
.text$mn:00001224
.text$mn:00001224 var_20          = dword ptr -20h
.text$mn:00001224 var_1C          = dword ptr -1Ch
.text$mn:00001224 var_18          = dword ptr -18h
.text$mn:00001224 var_11          = byte ptr -11h
.text$mn:00001224 var_10          = dword ptr -10h
.text$mn:00001224 var_C           = byte ptr -0Ch
.text$mn:00001224 var_4           = dword ptr -4
.text$mn:00001224 arg_0           = dword ptr  8
.text$mn:00001224
.text$mn:00001224 ; FUNCTION CHUNK AT .text$mn:00001346 SIZE 00000009 BYTES
.text$mn:00001224
.text$mn:00001224                 push    ebp
.text$mn:00001225                 mov     ebp, esp
.text$mn:00001227                 push    0FFFFFFFFh
.text$mn:00001229                 push    offset __ehhandler$?_Copy@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEXII@Z
.text$mn:0000122E                 mov     eax, large fs:0
.text$mn:00001234                 push    eax
.text$mn:00001235                 push    ecx
.text$mn:00001236                 sub     esp, 10h
.text$mn:00001239                 push    ebx
.text$mn:0000123A                 push    esi
.text$mn:0000123B                 push    edi
.text$mn:0000123C                 mov     eax, dword ptr ds:___security_cookie
.text$mn:00001241                 xor     eax, ebp
.text$mn:00001243                 push    eax
.text$mn:00001244                 lea     eax, [ebp+var_C]
.text$mn:00001247                 mov     large fs:0, eax
.text$mn:0000124D                 mov     [ebp+var_10], esp
.text$mn:00001250                 mov     [ebp+var_18], ecx
.text$mn:00001253                 mov     eax, [ebp+arg_0]
.text$mn:00001256                 or      eax, 0Fh
.text$mn:00001259                 mov     [ebp+var_1C], eax
.text$mn:0000125C                 mov     ecx, [ebp+var_18]
.text$mn:0000125F                 call    ?max_size@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QBEIXZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char>>::max_size(void)
.text$mn:00001264                 cmp     eax, [ebp+var_1C]
.text$mn:00001267                 jnb     short loc_1271
.text$mn:00001269                 mov     ecx, [ebp+arg_0]
.text$mn:0000126C                 mov     [ebp+var_1C], ecx
.text$mn:0000126F                 jmp     short loc_12C3
.text$mn:00001271 ; ---------------------------------------------------------------------------
.text$mn:00001271
.text$mn:00001271 loc_1271:                               ; CODE XREF: std::basic_string<char,std::char_traits<char>,std::allocator<char>>::_Copy(uint,uint)+43j
.text$mn:00001271                 mov     edx, [ebp+var_18]
.text$mn:00001274                 mov     ecx, [edx+18h]
.text$mn:00001277                 shr     ecx, 1
.text$mn:00001279                 mov     eax, [ebp+var_1C]
.text$mn:0000127C                 xor     edx, edx
.text$mn:0000127E                 mov     esi, 3
.text$mn:00001283                 div     esi
.text$mn:00001285                 cmp     ecx, eax
.text$mn:00001287                 ja      short loc_128B
.text$mn:00001289                 jmp     short loc_12C3
.text$mn:0000128B ; ---------------------------------------------------------------------------
.text$mn:0000128B
.text$mn:0000128B loc_128B:                               ; CODE XREF: std::basic_string<char,std::char_traits<char>,std::allocator<char>>::_Copy(uint,uint)+63j
.text$mn:0000128B                 mov     ecx, [ebp+var_18]
.text$mn:0000128E                 call    ?max_size@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QBEIXZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char>>::max_size(void)
.text$mn:00001293                 mov     edx, [ebp+var_18]
.text$mn:00001296                 mov     ecx, [edx+18h]
.text$mn:00001299                 shr     ecx, 1
.text$mn:0000129B                 sub     eax, ecx
.text$mn:0000129D                 mov     edx, [ebp+var_18]
.text$mn:000012A0                 cmp     [edx+18h], eax
.text$mn:000012A3                 ja      short loc_12B8
.text$mn:000012A5                 mov     eax, [ebp+var_18]
.text$mn:000012A8                 mov     ecx, [eax+18h]
.text$mn:000012AB                 shr     ecx, 1
.text$mn:000012AD                 mov     edx, [ebp+var_18]
.text$mn:000012B0                 add     ecx, [edx+18h]
.text$mn:000012B3                 mov     [ebp+var_1C], ecx
.text$mn:000012B6                 jmp     short loc_12C3
.text$mn:000012B8 ; ---------------------------------------------------------------------------
.text$mn:000012B8
.text$mn:000012B8 loc_12B8:                               ; CODE XREF: std::basic_string<char,std::char_traits<char>,std::allocator<char>>::_Copy(uint,uint)+7Fj
.text$mn:000012B8                 mov     ecx, [ebp+var_18]
.text$mn:000012BB                 call    ?max_size@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QBEIXZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char>>::max_size(void)
.text$mn:000012C0                 mov     [ebp+var_1C], eax
.text$mn:000012C3
.text$mn:000012C3 loc_12C3:                               ; CODE XREF: std::basic_string<char,std::char_traits<char>,std::allocator<char>>::_Copy(uint,uint)+4Bj
.text$mn:000012C3                                         ; std::basic_string<char,std::char_traits<char>,std::allocator<char>>::_Copy(uint,uint)+65j ...
.text$mn:000012C3                 mov     [ebp+var_4], 0
.text$mn:000012CA                 mov     eax, [ebp+var_1C]
.text$mn:000012CD                 add     eax, 1
.text$mn:000012D0                 push    eax
.text$mn:000012D1                 lea     ecx, [ebp+var_11]
.text$mn:000012D4                 push    ecx
.text$mn:000012D5                 mov     ecx, [ebp+var_18]
.text$mn:000012D8                 call    ?_Getal@?$_String_alloc@$0A@U?$_String_base_types@DV?$allocator@D@std@@@std@@@std@@QBE?AU?$_Wrap_alloc@V?$allocator@D@std@@@2@XZ ; std::_String_alloc<0,std::_String_base_types<char,std::allocator<char>>>::_Getal(void)
.text$mn:000012DD                 mov     ecx, eax
.text$mn:000012DF                 call    ?allocate@?$_Wrap_alloc@V?$allocator@D@std@@@std@@QAEPADI@Z ; std::_Wrap_alloc<std::allocator<char>>::allocate(uint)
.text$mn:000012E4                 mov     [ebp+var_20], eax
.text$mn:000012E7                 jmp     short loc_1346
.text$mn:000012E7 ?_Copy@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEXII@Z endp
.text$mn:000012E7
.text$mn:000012E9
.text$mn:000012E9 ; =============== S U B R O U T I N E =======================================
.text$mn:000012E9
.text$mn:000012E9
.text$mn:000012E9 __catch$?_Copy@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEXII@Z$0 proc near
.text$mn:000012E9                                         ; DATA XREF: .xdata$x:0000292Co
.text$mn:000012E9
.text$mn:000012E9 ; FUNCTION CHUNK AT .text$mn:00001330 SIZE 00000009 BYTES
.text$mn:000012E9 ; FUNCTION CHUNK AT .text$mn:00001340 SIZE 00000006 BYTES
.text$mn:000012E9
.text$mn:000012E9                 mov     [ebp-10h], esp
.text$mn:000012EC                 mov     edx, [ebp+8]
.text$mn:000012EF                 mov     [ebp-1Ch], edx
.text$mn:000012F2                 mov     byte ptr [ebp-4], 2
.text$mn:000012F6                 mov     eax, [ebp-1Ch]
.text$mn:000012F9                 add     eax, 1
.text$mn:000012FC                 push    eax
.text$mn:000012FD                 lea     ecx, [ebp-12h]
.text$mn:00001300                 push    ecx
.text$mn:00001301                 mov     ecx, [ebp-18h]
.text$mn:00001304                 call    ?_Getal@?$_String_alloc@$0A@U?$_String_base_types@DV?$allocator@D@std@@@std@@@std@@QBE?AU?$_Wrap_alloc@V?$allocator@D@std@@@2@XZ ; std::_String_alloc<0,std::_String_base_types<char,std::allocator<char>>>::_Getal(void)
.text$mn:00001309                 mov     ecx, eax
.text$mn:0000130B                 call    ?allocate@?$_Wrap_alloc@V?$allocator@D@std@@@std@@QAEPADI@Z ; std::_Wrap_alloc<std::allocator<char>>::allocate(uint)
.text$mn:00001310                 mov     [ebp-20h], eax
.text$mn:00001313                 jmp     short loc_1330
.text$mn:00001313 __catch$?_Copy@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEXII@Z$0 endp
.text$mn:00001313
.text$mn:00001315
.text$mn:00001315 ; =============== S U B R O U T I N E =======================================
.text$mn:00001315
.text$mn:00001315 ; Attributes: noreturn
.text$mn:00001315
.text$mn:00001315 __catch$?_Copy@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEXII@Z$1 proc near
.text$mn:00001315                                         ; DATA XREF: .xdata$x:0000293Co
.text$mn:00001315                 push    0               ; Size
.text$mn:00001317                 push    1               ; char
.text$mn:00001319                 mov     ecx, [ebp-18h]
.text$mn:0000131C                 call    ?_Tidy@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEX_NI@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char>>::_Tidy(bool,uint)
.text$mn:00001321                 push    0
.text$mn:00001323                 push    0
.text$mn:00001325                 call    __CxxThrowException@8 ; _CxxThrowException(x,x)
.text$mn:00001325 __catch$?_Copy@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEXII@Z$1 endp
.text$mn:00001325
.text$mn:0000132A ; ---------------------------------------------------------------------------
.text$mn:0000132A                 mov     eax, offset $LN17
.text$mn:0000132F                 retn
.text$mn:00001330 ; ---------------------------------------------------------------------------
.text$mn:00001330 ; START OF FUNCTION CHUNK FOR __catch$?_Copy@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEXII@Z$0
.text$mn:00001330
.text$mn:00001330 loc_1330:                               ; CODE XREF: __catch$?_Copy@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEXII@Z$0+2Aj
.text$mn:00001330                 mov     dword ptr [ebp-4], 1
.text$mn:00001337                 jmp     short loc_1340
.text$mn:00001337 ; END OF FUNCTION CHUNK FOR __catch$?_Copy@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEXII@Z$0
.text$mn:00001339
.text$mn:00001339 ; =============== S U B R O U T I N E =======================================
.text$mn:00001339
.text$mn:00001339
.text$mn:00001339 $LN17           proc near               ; DATA XREF: .text$mn:0000132Ao
.text$mn:00001339                 mov     dword ptr [ebp-4], 1
.text$mn:00001339 $LN17           endp ; sp-analysis failed
.text$mn:00001339
.text$mn:00001340 ; START OF FUNCTION CHUNK FOR __catch$?_Copy@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEXII@Z$0
.text$mn:00001340
.text$mn:00001340 loc_1340:                               ; CODE XREF: __catch$?_Copy@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEXII@Z$0+4Ej
.text$mn:00001340                 mov     eax, offset $LN19
.text$mn:00001345                 retn
.text$mn:00001345 ; END OF FUNCTION CHUNK FOR __catch$?_Copy@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEXII@Z$0
.text$mn:00001346 ; ---------------------------------------------------------------------------
.text$mn:00001346 ; START OF FUNCTION CHUNK FOR ?_Copy@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEXII@Z
.text$mn:00001346
.text$mn:00001346 loc_1346:                               ; CODE XREF: std::basic_string<char,std::char_traits<char>,std::allocator<char>>::_Copy(uint,uint)+C3j
.text$mn:00001346                 mov     [ebp+var_4], 0FFFFFFFFh
.text$mn:0000134D                 jmp     short loc_1356
.text$mn:0000134D ; END OF FUNCTION CHUNK FOR ?_Copy@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEXII@Z
.text$mn:0000134F
.text$mn:0000134F ; =============== S U B R O U T I N E =======================================
.text$mn:0000134F
.text$mn:0000134F
.text$mn:0000134F $LN19           proc near               ; DATA XREF: __catch$?_Copy@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEXII@Z$0:loc_1340o
.text$mn:0000134F                 mov     dword ptr [ebp-4], 0FFFFFFFFh
.text$mn:00001356
.text$mn:00001356 loc_1356:                               ; CODE XREF: std::basic_string<char,std::char_traits<char>,std::allocator<char>>::_Copy(uint,uint)+129j
.text$mn:00001356                 cmp     dword ptr [ebp+0Ch], 0
.text$mn:0000135A                 jbe     short loc_1375
.text$mn:0000135C                 mov     edx, [ebp+0Ch]
.text$mn:0000135F                 push    edx             ; Size
.text$mn:00001360                 mov     ecx, [ebp-18h]
.text$mn:00001363                 call    ?_Myptr@?$_String_val@U?$_Simple_types@D@std@@@std@@QAEPADXZ ; std::_String_val<std::_Simple_types<char>>::_Myptr(void)
.text$mn:00001368                 push    eax             ; Src
.text$mn:00001369                 mov     eax, [ebp-20h]
.text$mn:0000136C                 push    eax             ; Dst
.text$mn:0000136D                 call    ?copy@?$char_traits@D@std@@SAPADPADPBDI@Z ; std::char_traits<char>::copy(char *,char const *,uint)
.text$mn:00001372                 add     esp, 0Ch
.text$mn:00001375
.text$mn:00001375 loc_1375:                               ; CODE XREF: $LN19+Bj
.text$mn:00001375                 push    0               ; Size
.text$mn:00001377                 push    1               ; char
.text$mn:00001379                 mov     ecx, [ebp-18h]
.text$mn:0000137C                 call    ?_Tidy@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEX_NI@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char>>::_Tidy(bool,uint)
.text$mn:00001381                 lea     ecx, [ebp-20h]
.text$mn:00001384                 push    ecx             ; int
.text$mn:00001385                 mov     edx, [ebp-18h]
.text$mn:00001388                 add     edx, 4
.text$mn:0000138B                 push    edx             ; void *
.text$mn:0000138C                 lea     eax, [ebp-13h]
.text$mn:0000138F                 push    eax
.text$mn:00001390                 mov     ecx, [ebp-18h]
.text$mn:00001393                 call    ?_Getal@?$_String_alloc@$0A@U?$_String_base_types@DV?$allocator@D@std@@@std@@@std@@QBE?AU?$_Wrap_alloc@V?$allocator@D@std@@@2@XZ ; std::_String_alloc<0,std::_String_base_types<char,std::allocator<char>>>::_Getal(void)
.text$mn:00001398                 mov     ecx, eax
.text$mn:0000139A                 call    ??$construct@PADAAPAD@?$_Wrap_alloc@V?$allocator@D@std@@@std@@QAEXPAPADAAPAD@Z ; std::_Wrap_alloc<std::allocator<char>>::construct<char *,char * &>(char * *,char * &)
.text$mn:0000139F                 mov     ecx, [ebp-18h]
.text$mn:000013A2                 mov     edx, [ebp-1Ch]
.text$mn:000013A5                 mov     [ecx+18h], edx
.text$mn:000013A8                 mov     eax, [ebp+0Ch]
.text$mn:000013AB                 push    eax
.text$mn:000013AC                 mov     ecx, [ebp-18h]
.text$mn:000013AF                 call    ?_Eos@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEXI@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char>>::_Eos(uint)
.text$mn:000013B4                 mov     ecx, [ebp-0Ch]
.text$mn:000013B7                 mov     large fs:0, ecx
.text$mn:000013BE                 pop     ecx
.text$mn:000013BF                 pop     edi
.text$mn:000013C0                 pop     esi
.text$mn:000013C1                 pop     ebx
.text$mn:000013C2                 mov     esp, ebp
.text$mn:000013C4                 pop     ebp
.text$mn:000013C5                 retn    8
.text$mn:000013C5 $LN19           endp ; sp-analysis failed
.text$mn:000013C5
.text$mn:000013C5 _text$mn        ends
.text$mn:000013C5
.text$x:000013C8 ; ===========================================================================
.text$x:000013C8
.text$x:000013C8 ; Segment type: Pure code
.text$x:000013C8 ; Segment permissions: Read/Execute
.text$x:000013C8 _text$x         segment para public 'CODE' use32
.text$x:000013C8                 assume cs:_text$x
.text$x:000013C8                 ;org 13C8h
.text$x:000013C8 ; COMDAT (pick associative to section at 1224)
.text$x:000013C8                 assume es:nothing, ss:nothing, ds:_xdata$x, fs:nothing, gs:nothing
.text$x:000013C8
.text$x:000013C8 ; =============== S U B R O U T I N E =======================================
.text$x:000013C8
.text$x:000013C8
.text$x:000013C8 __ehhandler$?_Copy@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEXII@Z proc near
.text$x:000013C8                                         ; DATA XREF: std::basic_string<char,std::char_traits<char>,std::allocator<char>>::_Copy(uint,uint)+5o
.text$x:000013C8
.text$x:000013C8 arg_4           = dword ptr  8
.text$x:000013C8
.text$x:000013C8                 mov     edx, [esp+arg_4]
.text$x:000013CC                 lea     eax, [edx+0Ch]
.text$x:000013CF                 mov     ecx, [edx-24h]
.text$x:000013D2                 xor     ecx, eax
.text$x:000013D4                 call    @__security_check_cookie@4 ; __security_check_cookie(x)
.text$x:000013D9                 mov     eax, offset __ehfuncinfo$?_Copy@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEXII@Z
.text$x:000013DE                 jmp     ___CxxFrameHandler3
.text$x:000013DE __ehhandler$?_Copy@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEXII@Z endp
.text$x:000013DE
.text$x:000013DE ; ---------------------------------------------------------------------------
.text$x:000013E3                 align 4
.text$x:000013E3 _text$x         ends
.text$x:000013E3
.text$mn:000013E4 ; ===========================================================================
.text$mn:000013E4
.text$mn:000013E4 ; Segment type: Pure code
.text$mn:000013E4 ; Segment permissions: Read/Execute
.text$mn:000013E4 _text$mn        segment para public 'CODE' use32
.text$mn:000013E4                 assume cs:_text$mn
.text$mn:000013E4                 ;org 13E4h
.text$mn:000013E4 ; COMDAT (pick any)
.text$mn:000013E4                 assume es:nothing, ss:nothing, ds:_xdata$x, fs:nothing, gs:nothing
.text$mn:000013E4
.text$mn:000013E4 ; =============== S U B R O U T I N E =======================================
.text$mn:000013E4
.text$mn:000013E4 ; Attributes: bp-based frame
.text$mn:000013E4
.text$mn:000013E4 ; public: void __thiscall std::basic_string<wchar_t, struct std::char_traits<wchar_t>, class std::allocator<wchar_t>>::_Copy(unsigned int, unsigned int)
.text$mn:000013E4                 public ?_Copy@?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QAEXII@Z
.text$mn:000013E4 ?_Copy@?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QAEXII@Z proc near
.text$mn:000013E4                                         ; CODE XREF: std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>>::_Grow(uint,bool)+37p
.text$mn:000013E4
.text$mn:000013E4 var_20          = dword ptr -20h
.text$mn:000013E4 var_1C          = dword ptr -1Ch
.text$mn:000013E4 var_18          = dword ptr -18h
.text$mn:000013E4 var_11          = byte ptr -11h
.text$mn:000013E4 var_10          = dword ptr -10h
.text$mn:000013E4 var_C           = byte ptr -0Ch
.text$mn:000013E4 var_4           = dword ptr -4
.text$mn:000013E4 arg_0           = dword ptr  8
.text$mn:000013E4
.text$mn:000013E4 ; FUNCTION CHUNK AT .text$mn:00001506 SIZE 00000009 BYTES
.text$mn:000013E4
.text$mn:000013E4                 push    ebp
.text$mn:000013E5                 mov     ebp, esp
.text$mn:000013E7                 push    0FFFFFFFFh
.text$mn:000013E9                 push    offset __ehhandler$?_Copy@?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QAEXII@Z
.text$mn:000013EE                 mov     eax, large fs:0
.text$mn:000013F4                 push    eax
.text$mn:000013F5                 push    ecx
.text$mn:000013F6                 sub     esp, 10h
.text$mn:000013F9                 push    ebx
.text$mn:000013FA                 push    esi
.text$mn:000013FB                 push    edi
.text$mn:000013FC                 mov     eax, dword ptr ds:___security_cookie
.text$mn:00001401                 xor     eax, ebp
.text$mn:00001403                 push    eax
.text$mn:00001404                 lea     eax, [ebp+var_C]
.text$mn:00001407                 mov     large fs:0, eax
.text$mn:0000140D                 mov     [ebp+var_10], esp
.text$mn:00001410                 mov     [ebp+var_18], ecx
.text$mn:00001413                 mov     eax, [ebp+arg_0]
.text$mn:00001416                 or      eax, 7
.text$mn:00001419                 mov     [ebp+var_1C], eax
.text$mn:0000141C                 mov     ecx, [ebp+var_18]
.text$mn:0000141F                 call    ?max_size@?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QBEIXZ ; std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>>::max_size(void)
.text$mn:00001424                 cmp     eax, [ebp+var_1C]
.text$mn:00001427                 jnb     short loc_1431
.text$mn:00001429                 mov     ecx, [ebp+arg_0]
.text$mn:0000142C                 mov     [ebp+var_1C], ecx
.text$mn:0000142F                 jmp     short loc_1483
.text$mn:00001431 ; ---------------------------------------------------------------------------
.text$mn:00001431
.text$mn:00001431 loc_1431:                               ; CODE XREF: std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>>::_Copy(uint,uint)+43j
.text$mn:00001431                 mov     edx, [ebp+var_18]
.text$mn:00001434                 mov     ecx, [edx+18h]
.text$mn:00001437                 shr     ecx, 1
.text$mn:00001439                 mov     eax, [ebp+var_1C]
.text$mn:0000143C                 xor     edx, edx
.text$mn:0000143E                 mov     esi, 3
.text$mn:00001443                 div     esi
.text$mn:00001445                 cmp     ecx, eax
.text$mn:00001447                 ja      short loc_144B
.text$mn:00001449                 jmp     short loc_1483
.text$mn:0000144B ; ---------------------------------------------------------------------------
.text$mn:0000144B
.text$mn:0000144B loc_144B:                               ; CODE XREF: std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>>::_Copy(uint,uint)+63j
.text$mn:0000144B                 mov     ecx, [ebp+var_18]
.text$mn:0000144E                 call    ?max_size@?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QBEIXZ ; std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>>::max_size(void)
.text$mn:00001453                 mov     edx, [ebp+var_18]
.text$mn:00001456                 mov     ecx, [edx+18h]
.text$mn:00001459                 shr     ecx, 1
.text$mn:0000145B                 sub     eax, ecx
.text$mn:0000145D                 mov     edx, [ebp+var_18]
.text$mn:00001460                 cmp     [edx+18h], eax
.text$mn:00001463                 ja      short loc_1478
.text$mn:00001465                 mov     eax, [ebp+var_18]
.text$mn:00001468                 mov     ecx, [eax+18h]
.text$mn:0000146B                 shr     ecx, 1
.text$mn:0000146D                 mov     edx, [ebp+var_18]
.text$mn:00001470                 add     ecx, [edx+18h]
.text$mn:00001473                 mov     [ebp+var_1C], ecx
.text$mn:00001476                 jmp     short loc_1483
.text$mn:00001478 ; ---------------------------------------------------------------------------
.text$mn:00001478
.text$mn:00001478 loc_1478:                               ; CODE XREF: std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>>::_Copy(uint,uint)+7Fj
.text$mn:00001478                 mov     ecx, [ebp+var_18]
.text$mn:0000147B                 call    ?max_size@?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QBEIXZ ; std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>>::max_size(void)
.text$mn:00001480                 mov     [ebp+var_1C], eax
.text$mn:00001483
.text$mn:00001483 loc_1483:                               ; CODE XREF: std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>>::_Copy(uint,uint)+4Bj
.text$mn:00001483                                         ; std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>>::_Copy(uint,uint)+65j ...
.text$mn:00001483                 mov     [ebp+var_4], 0
.text$mn:0000148A                 mov     eax, [ebp+var_1C]
.text$mn:0000148D                 add     eax, 1
.text$mn:00001490                 push    eax
.text$mn:00001491                 lea     ecx, [ebp+var_11]
.text$mn:00001494                 push    ecx
.text$mn:00001495                 mov     ecx, [ebp+var_18]
.text$mn:00001498                 call    ?_Getal@?$_String_alloc@$0A@U?$_String_base_types@_WV?$allocator@_W@std@@@std@@@std@@QBE?AU?$_Wrap_alloc@V?$allocator@_W@std@@@2@XZ ; std::_String_alloc<0,std::_String_base_types<wchar_t,std::allocator<wchar_t>>>::_Getal(void)
.text$mn:0000149D                 mov     ecx, eax
.text$mn:0000149F                 call    ?allocate@?$_Wrap_alloc@V?$allocator@_W@std@@@std@@QAEPA_WI@Z ; std::_Wrap_alloc<std::allocator<wchar_t>>::allocate(uint)
.text$mn:000014A4                 mov     [ebp+var_20], eax
.text$mn:000014A7                 jmp     short loc_1506
.text$mn:000014A7 ?_Copy@?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QAEXII@Z endp
.text$mn:000014A7
.text$mn:000014A9
.text$mn:000014A9 ; =============== S U B R O U T I N E =======================================
.text$mn:000014A9
.text$mn:000014A9
.text$mn:000014A9 __catch$?_Copy@?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QAEXII@Z$0 proc near
.text$mn:000014A9                                         ; DATA XREF: .xdata$x:00002B44o
.text$mn:000014A9
.text$mn:000014A9 ; FUNCTION CHUNK AT .text$mn:000014F0 SIZE 00000009 BYTES
.text$mn:000014A9 ; FUNCTION CHUNK AT .text$mn:00001500 SIZE 00000006 BYTES
.text$mn:000014A9
.text$mn:000014A9                 mov     [ebp-10h], esp
.text$mn:000014AC                 mov     edx, [ebp+8]
.text$mn:000014AF                 mov     [ebp-1Ch], edx
.text$mn:000014B2                 mov     byte ptr [ebp-4], 2
.text$mn:000014B6                 mov     eax, [ebp-1Ch]
.text$mn:000014B9                 add     eax, 1
.text$mn:000014BC                 push    eax
.text$mn:000014BD                 lea     ecx, [ebp-12h]
.text$mn:000014C0                 push    ecx
.text$mn:000014C1                 mov     ecx, [ebp-18h]
.text$mn:000014C4                 call    ?_Getal@?$_String_alloc@$0A@U?$_String_base_types@_WV?$allocator@_W@std@@@std@@@std@@QBE?AU?$_Wrap_alloc@V?$allocator@_W@std@@@2@XZ ; std::_String_alloc<0,std::_String_base_types<wchar_t,std::allocator<wchar_t>>>::_Getal(void)
.text$mn:000014C9                 mov     ecx, eax
.text$mn:000014CB                 call    ?allocate@?$_Wrap_alloc@V?$allocator@_W@std@@@std@@QAEPA_WI@Z ; std::_Wrap_alloc<std::allocator<wchar_t>>::allocate(uint)
.text$mn:000014D0                 mov     [ebp-20h], eax
.text$mn:000014D3                 jmp     short loc_14F0
.text$mn:000014D3 __catch$?_Copy@?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QAEXII@Z$0 endp
.text$mn:000014D3
.text$mn:000014D5
.text$mn:000014D5 ; =============== S U B R O U T I N E =======================================
.text$mn:000014D5
.text$mn:000014D5 ; Attributes: noreturn
.text$mn:000014D5
.text$mn:000014D5 __catch$?_Copy@?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QAEXII@Z$1 proc near
.text$mn:000014D5                                         ; DATA XREF: .xdata$x:00002B54o
.text$mn:000014D5                 push    0
.text$mn:000014D7                 push    1
.text$mn:000014D9                 mov     ecx, [ebp-18h]
.text$mn:000014DC                 call    ?_Tidy@?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QAEX_NI@Z ; std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>>::_Tidy(bool,uint)
.text$mn:000014E1                 push    0
.text$mn:000014E3                 push    0
.text$mn:000014E5                 call    __CxxThrowException@8 ; _CxxThrowException(x,x)
.text$mn:000014E5 __catch$?_Copy@?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QAEXII@Z$1 endp
.text$mn:000014E5
.text$mn:000014EA ; ---------------------------------------------------------------------------
.text$mn:000014EA                 mov     eax, offset $LN17_0
.text$mn:000014EF                 retn
.text$mn:000014F0 ; ---------------------------------------------------------------------------
.text$mn:000014F0 ; START OF FUNCTION CHUNK FOR __catch$?_Copy@?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QAEXII@Z$0
.text$mn:000014F0
.text$mn:000014F0 loc_14F0:                               ; CODE XREF: __catch$?_Copy@?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QAEXII@Z$0+2Aj
.text$mn:000014F0                 mov     dword ptr [ebp-4], 1
.text$mn:000014F7                 jmp     short loc_1500
.text$mn:000014F7 ; END OF FUNCTION CHUNK FOR __catch$?_Copy@?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QAEXII@Z$0
.text$mn:000014F9
.text$mn:000014F9 ; =============== S U B R O U T I N E =======================================
.text$mn:000014F9
.text$mn:000014F9
.text$mn:000014F9 $LN17_0         proc near               ; DATA XREF: .text$mn:000014EAo
.text$mn:000014F9                 mov     dword ptr [ebp-4], 1
.text$mn:000014F9 $LN17_0         endp ; sp-analysis failed
.text$mn:000014F9
.text$mn:00001500 ; START OF FUNCTION CHUNK FOR __catch$?_Copy@?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QAEXII@Z$0
.text$mn:00001500
.text$mn:00001500 loc_1500:                               ; CODE XREF: __catch$?_Copy@?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QAEXII@Z$0+4Ej
.text$mn:00001500                 mov     eax, offset $LN19_0
.text$mn:00001505                 retn
.text$mn:00001505 ; END OF FUNCTION CHUNK FOR __catch$?_Copy@?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QAEXII@Z$0
.text$mn:00001506 ; ---------------------------------------------------------------------------
.text$mn:00001506 ; START OF FUNCTION CHUNK FOR ?_Copy@?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QAEXII@Z
.text$mn:00001506
.text$mn:00001506 loc_1506:                               ; CODE XREF: std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>>::_Copy(uint,uint)+C3j
.text$mn:00001506                 mov     [ebp+var_4], 0FFFFFFFFh
.text$mn:0000150D                 jmp     short loc_1516
.text$mn:0000150D ; END OF FUNCTION CHUNK FOR ?_Copy@?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QAEXII@Z
.text$mn:0000150F
.text$mn:0000150F ; =============== S U B R O U T I N E =======================================
.text$mn:0000150F
.text$mn:0000150F
.text$mn:0000150F $LN19_0         proc near               ; DATA XREF: __catch$?_Copy@?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QAEXII@Z$0:loc_1500o
.text$mn:0000150F                 mov     dword ptr [ebp-4], 0FFFFFFFFh
.text$mn:00001516
.text$mn:00001516 loc_1516:                               ; CODE XREF: std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>>::_Copy(uint,uint)+129j
.text$mn:00001516                 cmp     dword ptr [ebp+0Ch], 0
.text$mn:0000151A                 jbe     short loc_1535
.text$mn:0000151C                 mov     edx, [ebp+0Ch]
.text$mn:0000151F                 push    edx             ; int
.text$mn:00001520                 mov     ecx, [ebp-18h]
.text$mn:00001523                 call    ?_Myptr@?$_String_val@U?$_Simple_types@_W@std@@@std@@QAEPA_WXZ ; std::_String_val<std::_Simple_types<wchar_t>>::_Myptr(void)
.text$mn:00001528                 push    eax             ; Src
.text$mn:00001529                 mov     eax, [ebp-20h]
.text$mn:0000152C                 push    eax             ; Dst
.text$mn:0000152D                 call    ?copy@?$char_traits@_W@std@@SAPA_WPA_WPB_WI@Z ; std::char_traits<wchar_t>::copy(wchar_t *,wchar_t const *,uint)
.text$mn:00001532                 add     esp, 0Ch
.text$mn:00001535
.text$mn:00001535 loc_1535:                               ; CODE XREF: $LN19_0+Bj
.text$mn:00001535                 push    0
.text$mn:00001537                 push    1
.text$mn:00001539                 mov     ecx, [ebp-18h]
.text$mn:0000153C                 call    ?_Tidy@?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QAEX_NI@Z ; std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>>::_Tidy(bool,uint)
.text$mn:00001541                 lea     ecx, [ebp-20h]
.text$mn:00001544                 push    ecx             ; int
.text$mn:00001545                 mov     edx, [ebp-18h]
.text$mn:00001548                 add     edx, 4
.text$mn:0000154B                 push    edx             ; void *
.text$mn:0000154C                 lea     eax, [ebp-13h]
.text$mn:0000154F                 push    eax
.text$mn:00001550                 mov     ecx, [ebp-18h]
.text$mn:00001553                 call    ?_Getal@?$_String_alloc@$0A@U?$_String_base_types@_WV?$allocator@_W@std@@@std@@@std@@QBE?AU?$_Wrap_alloc@V?$allocator@_W@std@@@2@XZ ; std::_String_alloc<0,std::_String_base_types<wchar_t,std::allocator<wchar_t>>>::_Getal(void)
.text$mn:00001558                 mov     ecx, eax
.text$mn:0000155A                 call    ??$construct@PA_WAAPA_W@?$_Wrap_alloc@V?$allocator@_W@std@@@std@@QAEXPAPA_WAAPA_W@Z ; std::_Wrap_alloc<std::allocator<wchar_t>>::construct<wchar_t *,wchar_t * &>(wchar_t * *,wchar_t * &)
.text$mn:0000155F                 mov     ecx, [ebp-18h]
.text$mn:00001562                 mov     edx, [ebp-1Ch]
.text$mn:00001565                 mov     [ecx+18h], edx
.text$mn:00001568                 mov     eax, [ebp+0Ch]
.text$mn:0000156B                 push    eax
.text$mn:0000156C                 mov     ecx, [ebp-18h]
.text$mn:0000156F                 call    ?_Eos@?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QAEXI@Z ; std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>>::_Eos(uint)
.text$mn:00001574                 mov     ecx, [ebp-0Ch]
.text$mn:00001577                 mov     large fs:0, ecx
.text$mn:0000157E                 pop     ecx
.text$mn:0000157F                 pop     edi
.text$mn:00001580                 pop     esi
.text$mn:00001581                 pop     ebx
.text$mn:00001582                 mov     esp, ebp
.text$mn:00001584                 pop     ebp
.text$mn:00001585                 retn    8
.text$mn:00001585 $LN19_0         endp ; sp-analysis failed
.text$mn:00001585
.text$mn:00001585 _text$mn        ends
.text$mn:00001585
.text$x:00001588 ; ===========================================================================
.text$x:00001588
.text$x:00001588 ; Segment type: Pure code
.text$x:00001588 ; Segment permissions: Read/Execute
.text$x:00001588 _text$x         segment para public 'CODE' use32
.text$x:00001588                 assume cs:_text$x
.text$x:00001588                 ;org 1588h
.text$x:00001588 ; COMDAT (pick associative to section at 13E4)
.text$x:00001588                 assume es:nothing, ss:nothing, ds:_xdata$x, fs:nothing, gs:nothing
.text$x:00001588
.text$x:00001588 ; =============== S U B R O U T I N E =======================================
.text$x:00001588
.text$x:00001588
.text$x:00001588 __ehhandler$?_Copy@?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QAEXII@Z proc near
.text$x:00001588                                         ; DATA XREF: std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>>::_Copy(uint,uint)+5o
.text$x:00001588
.text$x:00001588 arg_4           = dword ptr  8
.text$x:00001588
.text$x:00001588                 mov     edx, [esp+arg_4]
.text$x:0000158C                 lea     eax, [edx+0Ch]
.text$x:0000158F                 mov     ecx, [edx-24h]
.text$x:00001592                 xor     ecx, eax
.text$x:00001594                 call    @__security_check_cookie@4 ; __security_check_cookie(x)
.text$x:00001599                 mov     eax, offset __ehfuncinfo$?_Copy@?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QAEXII@Z
.text$x:0000159E                 jmp     ___CxxFrameHandler3
.text$x:0000159E __ehhandler$?_Copy@?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QAEXII@Z endp
.text$x:0000159E
.text$x:0000159E ; ---------------------------------------------------------------------------
.text$x:000015A3                 align 4
.text$x:000015A3 _text$x         ends
.text$x:000015A3
.text$mn:000015A4 ; ===========================================================================
.text$mn:000015A4
.text$mn:000015A4 ; Segment type: Pure code
.text$mn:000015A4 ; Segment permissions: Read/Execute
.text$mn:000015A4 _text$mn        segment para public 'CODE' use32
.text$mn:000015A4                 assume cs:_text$mn
.text$mn:000015A4                 ;org 15A4h
.text$mn:000015A4 ; COMDAT (pick any)
.text$mn:000015A4                 assume es:nothing, ss:nothing, ds:_xdata$x, fs:nothing, gs:nothing
.text$mn:000015A4
.text$mn:000015A4 ; =============== S U B R O U T I N E =======================================
.text$mn:000015A4
.text$mn:000015A4 ; Attributes: bp-based frame
.text$mn:000015A4
.text$mn:000015A4 ; public: void __thiscall std::basic_string<char, struct std::char_traits<char>, class std::allocator<char>>::_Eos(unsigned int)
.text$mn:000015A4                 public ?_Eos@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEXI@Z
.text$mn:000015A4 ?_Eos@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEXI@Z proc near
.text$mn:000015A4                                         ; CODE XREF: $LN19+60p
.text$mn:000015A4                                         ; std::basic_string<char,std::char_traits<char>,std::allocator<char>>::_Grow(uint,bool)+83p ...
.text$mn:000015A4
.text$mn:000015A4 var_8           = dword ptr -8
.text$mn:000015A4 var_1           = byte ptr -1
.text$mn:000015A4 arg_0           = dword ptr  8
.text$mn:000015A4
.text$mn:000015A4                 push    ebp
.text$mn:000015A5                 mov     ebp, esp
.text$mn:000015A7                 sub     esp, 8
.text$mn:000015AA                 mov     [ebp+var_8], ecx
.text$mn:000015AD                 mov     [ebp+var_1], 0
.text$mn:000015B1                 mov     eax, [ebp+var_8]
.text$mn:000015B4                 mov     ecx, [ebp+arg_0]
.text$mn:000015B7                 mov     [eax+14h], ecx
.text$mn:000015BA                 lea     edx, [ebp+var_1]
.text$mn:000015BD                 push    edx
.text$mn:000015BE                 mov     ecx, [ebp+var_8]
.text$mn:000015C1                 call    ?_Myptr@?$_String_val@U?$_Simple_types@D@std@@@std@@QAEPADXZ ; std::_String_val<std::_Simple_types<char>>::_Myptr(void)
.text$mn:000015C6                 add     eax, [ebp+arg_0]
.text$mn:000015C9                 push    eax
.text$mn:000015CA                 call    ?assign@?$char_traits@D@std@@SAXAADABD@Z ; std::char_traits<char>::assign(char &,char const &)
.text$mn:000015CF                 add     esp, 8
.text$mn:000015D2                 mov     esp, ebp
.text$mn:000015D4                 pop     ebp
.text$mn:000015D5                 retn    4
.text$mn:000015D5 ?_Eos@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEXI@Z endp
.text$mn:000015D5
.text$mn:000015D5 _text$mn        ends
.text$mn:000015D5
.text$mn:000015D8 ; ===========================================================================
.text$mn:000015D8
.text$mn:000015D8 ; Segment type: Pure code
.text$mn:000015D8 ; Segment permissions: Read/Execute
.text$mn:000015D8 _text$mn        segment para public 'CODE' use32
.text$mn:000015D8                 assume cs:_text$mn
.text$mn:000015D8                 ;org 15D8h
.text$mn:000015D8 ; COMDAT (pick any)
.text$mn:000015D8                 assume es:nothing, ss:nothing, ds:_xdata$x, fs:nothing, gs:nothing
.text$mn:000015D8
.text$mn:000015D8 ; =============== S U B R O U T I N E =======================================
.text$mn:000015D8
.text$mn:000015D8 ; Attributes: bp-based frame
.text$mn:000015D8
.text$mn:000015D8 ; public: void __thiscall std::basic_string<wchar_t, struct std::char_traits<wchar_t>, class std::allocator<wchar_t>>::_Eos(unsigned int)
.text$mn:000015D8                 public ?_Eos@?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QAEXI@Z
.text$mn:000015D8 ?_Eos@?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QAEXI@Z proc near
.text$mn:000015D8                                         ; CODE XREF: $LN19_0+60p
.text$mn:000015D8                                         ; std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>>::_Grow(uint,bool)+83p ...
.text$mn:000015D8
.text$mn:000015D8 var_8           = dword ptr -8
.text$mn:000015D8 var_2           = word ptr -2
.text$mn:000015D8 arg_0           = dword ptr  8
.text$mn:000015D8
.text$mn:000015D8                 push    ebp
.text$mn:000015D9                 mov     ebp, esp
.text$mn:000015DB                 sub     esp, 8
.text$mn:000015DE                 mov     [ebp+var_8], ecx
.text$mn:000015E1                 xor     eax, eax
.text$mn:000015E3                 mov     [ebp+var_2], ax
.text$mn:000015E7                 mov     ecx, [ebp+var_8]
.text$mn:000015EA                 mov     edx, [ebp+arg_0]
.text$mn:000015ED                 mov     [ecx+14h], edx
.text$mn:000015F0                 lea     eax, [ebp+var_2]
.text$mn:000015F3                 push    eax
.text$mn:000015F4                 mov     ecx, [ebp+var_8]
.text$mn:000015F7                 call    ?_Myptr@?$_String_val@U?$_Simple_types@_W@std@@@std@@QAEPA_WXZ ; std::_String_val<std::_Simple_types<wchar_t>>::_Myptr(void)
.text$mn:000015FC                 mov     ecx, [ebp+arg_0]
.text$mn:000015FF                 lea     edx, [eax+ecx*2]
.text$mn:00001602                 push    edx
.text$mn:00001603                 call    ?assign@?$char_traits@_W@std@@SAXAA_WAB_W@Z ; std::char_traits<wchar_t>::assign(wchar_t &,wchar_t const &)
.text$mn:00001608                 add     esp, 8
.text$mn:0000160B                 mov     esp, ebp
.text$mn:0000160D                 pop     ebp
.text$mn:0000160E                 retn    4
.text$mn:0000160E ?_Eos@?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QAEXI@Z endp
.text$mn:0000160E
.text$mn:0000160E ; ---------------------------------------------------------------------------
.text$mn:00001611                 align 4
.text$mn:00001611 _text$mn        ends
.text$mn:00001611
.text$mn:00001614 ; ===========================================================================
.text$mn:00001614
.text$mn:00001614 ; Segment type: Pure code
.text$mn:00001614 ; Segment permissions: Read/Execute
.text$mn:00001614 _text$mn        segment para public 'CODE' use32
.text$mn:00001614                 assume cs:_text$mn
.text$mn:00001614                 ;org 1614h
.text$mn:00001614 ; COMDAT (pick any)
.text$mn:00001614                 assume es:nothing, ss:nothing, ds:_xdata$x, fs:nothing, gs:nothing
.text$mn:00001614
.text$mn:00001614 ; =============== S U B R O U T I N E =======================================
.text$mn:00001614
.text$mn:00001614 ; Attributes: bp-based frame
.text$mn:00001614
.text$mn:00001614 ; public: void __thiscall std::_String_alloc<0, struct std::_String_base_types<char, class std::allocator<char>>>::_Free_proxy(void)
.text$mn:00001614                 public ?_Free_proxy@?$_String_alloc@$0A@U?$_String_base_types@DV?$allocator@D@std@@@std@@@std@@QAEXXZ
.text$mn:00001614 ?_Free_proxy@?$_String_alloc@$0A@U?$_String_base_types@DV?$allocator@D@std@@@std@@@std@@QAEXXZ proc near
.text$mn:00001614                                         ; CODE XREF: std::_String_alloc<0,std::_String_base_types<char,std::allocator<char>>>::~_String_alloc<0,std::_String_base_types<char,std::allocator<char>>>(void)+30p
.text$mn:00001614
.text$mn:00001614 var_8           = dword ptr -8
.text$mn:00001614 var_1           = byte ptr -1
.text$mn:00001614
.text$mn:00001614                 push    ebp
.text$mn:00001615                 mov     ebp, esp
.text$mn:00001617                 sub     esp, 8
.text$mn:0000161A                 mov     [ebp+var_8], ecx
.text$mn:0000161D                 lea     ecx, [ebp+var_1]
.text$mn:00001620                 call    ??0?$allocator@U_Container_proxy@std@@@std@@QAE@XZ ; std::allocator<std::_Container_proxy>::allocator<std::_Container_proxy>(void)
.text$mn:00001625                 mov     ecx, [ebp+var_8] ; this
.text$mn:00001628                 call    ?_Orphan_all@_Container_base12@std@@QAEXXZ ; std::_Container_base12::_Orphan_all(void)
.text$mn:0000162D                 mov     eax, [ebp+var_8]
.text$mn:00001630                 mov     ecx, [eax]
.text$mn:00001632                 push    ecx
.text$mn:00001633                 lea     ecx, [ebp+var_1]
.text$mn:00001636                 call    ??$destroy@U_Container_proxy@std@@@?$allocator@U_Container_proxy@std@@@std@@QAEXPAU_Container_proxy@1@@Z ; std::allocator<std::_Container_proxy>::destroy<std::_Container_proxy>(std::_Container_proxy *)
.text$mn:0000163B                 push    1               ; int
.text$mn:0000163D                 mov     edx, [ebp+var_8]
.text$mn:00001640                 mov     eax, [edx]
.text$mn:00001642                 push    eax             ; void *
.text$mn:00001643                 lea     ecx, [ebp+var_1]
.text$mn:00001646                 call    ?deallocate@?$allocator@U_Container_proxy@std@@@std@@QAEXPAU_Container_proxy@2@I@Z ; std::allocator<std::_Container_proxy>::deallocate(std::_Container_proxy *,uint)
.text$mn:0000164B                 mov     ecx, [ebp+var_8]
.text$mn:0000164E                 mov     dword ptr [ecx], 0
.text$mn:00001654                 mov     esp, ebp
.text$mn:00001656                 pop     ebp
.text$mn:00001657                 retn
.text$mn:00001657 ?_Free_proxy@?$_String_alloc@$0A@U?$_String_base_types@DV?$allocator@D@std@@@std@@@std@@QAEXXZ endp
.text$mn:00001657
.text$mn:00001657 _text$mn        ends
.text$mn:00001657
.text$mn:00001658 ; ===========================================================================
.text$mn:00001658
.text$mn:00001658 ; Segment type: Pure code
.text$mn:00001658 ; Segment permissions: Read/Execute
.text$mn:00001658 _text$mn        segment para public 'CODE' use32
.text$mn:00001658                 assume cs:_text$mn
.text$mn:00001658                 ;org 1658h
.text$mn:00001658 ; COMDAT (pick any)
.text$mn:00001658                 assume es:nothing, ss:nothing, ds:_xdata$x, fs:nothing, gs:nothing
.text$mn:00001658
.text$mn:00001658 ; =============== S U B R O U T I N E =======================================
.text$mn:00001658
.text$mn:00001658 ; Attributes: bp-based frame
.text$mn:00001658
.text$mn:00001658 ; public: struct std::_Wrap_alloc<class std::allocator<char>> __thiscall std::_String_alloc<0, struct std::_String_base_types<char, class std::allocator<char>>>::_Getal(void)const
.text$mn:00001658                 public ?_Getal@?$_String_alloc@$0A@U?$_String_base_types@DV?$allocator@D@std@@@std@@@std@@QBE?AU?$_Wrap_alloc@V?$allocator@D@std@@@2@XZ
.text$mn:00001658 ?_Getal@?$_String_alloc@$0A@U?$_String_base_types@DV?$allocator@D@std@@@std@@@std@@QBE?AU?$_Wrap_alloc@V?$allocator@D@std@@@2@XZ proc near
.text$mn:00001658                                         ; CODE XREF: std::basic_string<char,std::char_traits<char>,std::allocator<char>>::_Copy(uint,uint)+B4p
.text$mn:00001658                                         ; __catch$?_Copy@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEXII@Z$0+1Bp ...
.text$mn:00001658
.text$mn:00001658 var_4           = dword ptr -4
.text$mn:00001658 arg_0           = dword ptr  8
.text$mn:00001658
.text$mn:00001658                 push    ebp
.text$mn:00001659                 mov     ebp, esp
.text$mn:0000165B                 push    ecx
.text$mn:0000165C                 mov     [ebp+var_4], ecx
.text$mn:0000165F                 mov     ecx, [ebp+arg_0]
.text$mn:00001662                 call    ??0?$_Wrap_alloc@V?$allocator@D@std@@@std@@QAE@XZ ; std::_Wrap_alloc<std::allocator<char>>::_Wrap_alloc<std::allocator<char>>(void)
.text$mn:00001667                 mov     eax, [ebp+arg_0]
.text$mn:0000166A                 mov     esp, ebp
.text$mn:0000166C                 pop     ebp
.text$mn:0000166D                 retn    4
.text$mn:0000166D ?_Getal@?$_String_alloc@$0A@U?$_String_base_types@DV?$allocator@D@std@@@std@@@std@@QBE?AU?$_Wrap_alloc@V?$allocator@D@std@@@2@XZ endp
.text$mn:0000166D
.text$mn:0000166D _text$mn        ends
.text$mn:0000166D
.text$mn:00001670 ; ===========================================================================
.text$mn:00001670
.text$mn:00001670 ; Segment type: Pure code
.text$mn:00001670 ; Segment permissions: Read/Execute
.text$mn:00001670 _text$mn        segment para public 'CODE' use32
.text$mn:00001670                 assume cs:_text$mn
.text$mn:00001670                 ;org 1670h
.text$mn:00001670 ; COMDAT (pick any)
.text$mn:00001670                 assume es:nothing, ss:nothing, ds:_xdata$x, fs:nothing, gs:nothing
.text$mn:00001670
.text$mn:00001670 ; =============== S U B R O U T I N E =======================================
.text$mn:00001670
.text$mn:00001670 ; Attributes: bp-based frame
.text$mn:00001670
.text$mn:00001670 ; public: struct std::_Wrap_alloc<class std::allocator<wchar_t>> __thiscall std::_String_alloc<0, struct std::_String_base_types<wchar_t, class std::allocator<wchar_t>>>::_Getal(void)const
.text$mn:00001670                 public ?_Getal@?$_String_alloc@$0A@U?$_String_base_types@_WV?$allocator@_W@std@@@std@@@std@@QBE?AU?$_Wrap_alloc@V?$allocator@_W@std@@@2@XZ
.text$mn:00001670 ?_Getal@?$_String_alloc@$0A@U?$_String_base_types@_WV?$allocator@_W@std@@@std@@@std@@QBE?AU?$_Wrap_alloc@V?$allocator@_W@std@@@2@XZ proc near
.text$mn:00001670                                         ; CODE XREF: std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>>::_Copy(uint,uint)+B4p
.text$mn:00001670                                         ; __catch$?_Copy@?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QAEXII@Z$0+1Bp ...
.text$mn:00001670
.text$mn:00001670 var_4           = dword ptr -4
.text$mn:00001670 arg_0           = dword ptr  8
.text$mn:00001670
.text$mn:00001670                 push    ebp
.text$mn:00001671                 mov     ebp, esp
.text$mn:00001673                 push    ecx
.text$mn:00001674                 mov     [ebp+var_4], ecx
.text$mn:00001677                 mov     ecx, [ebp+arg_0]
.text$mn:0000167A                 call    ??0?$_Wrap_alloc@V?$allocator@_W@std@@@std@@QAE@XZ ; std::_Wrap_alloc<std::allocator<wchar_t>>::_Wrap_alloc<std::allocator<wchar_t>>(void)
.text$mn:0000167F                 mov     eax, [ebp+arg_0]
.text$mn:00001682                 mov     esp, ebp
.text$mn:00001684                 pop     ebp
.text$mn:00001685                 retn    4
.text$mn:00001685 ?_Getal@?$_String_alloc@$0A@U?$_String_base_types@_WV?$allocator@_W@std@@@std@@@std@@QBE?AU?$_Wrap_alloc@V?$allocator@_W@std@@@2@XZ endp
.text$mn:00001685
.text$mn:00001685 _text$mn        ends
.text$mn:00001685
.text$mn:00001688 ; ===========================================================================
.text$mn:00001688
.text$mn:00001688 ; Segment type: Pure code
.text$mn:00001688 ; Segment permissions: Read/Execute
.text$mn:00001688 _text$mn        segment para public 'CODE' use32
.text$mn:00001688                 assume cs:_text$mn
.text$mn:00001688                 ;org 1688h
.text$mn:00001688 ; COMDAT (pick any)
.text$mn:00001688                 assume es:nothing, ss:nothing, ds:_xdata$x, fs:nothing, gs:nothing
.text$mn:00001688
.text$mn:00001688 ; =============== S U B R O U T I N E =======================================
.text$mn:00001688
.text$mn:00001688 ; Attributes: bp-based frame
.text$mn:00001688
.text$mn:00001688 ; public: bool __thiscall std::basic_string<char, struct std::char_traits<char>, class std::allocator<char>>::_Grow(unsigned int, bool)
.text$mn:00001688                 public ?_Grow@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE_NI_N@Z
.text$mn:00001688 ?_Grow@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE_NI_N@Z proc near
.text$mn:00001688                                         ; CODE XREF: std::basic_string<char,std::char_traits<char>,std::allocator<char>>::assign(std::basic_string<char,std::char_traits<char>,std::allocator<char>> const &,uint,uint)+6Ap
.text$mn:00001688                                         ; std::basic_string<char,std::char_traits<char>,std::allocator<char>>::assign(char const *,uint)+5Fp
.text$mn:00001688
.text$mn:00001688 var_C           = dword ptr -0Ch
.text$mn:00001688 Size            = dword ptr -8
.text$mn:00001688 var_4           = dword ptr -4
.text$mn:00001688 arg_0           = dword ptr  8
.text$mn:00001688 arg_4           = byte ptr  0Ch
.text$mn:00001688
.text$mn:00001688                 push    ebp
.text$mn:00001689                 mov     ebp, esp
.text$mn:0000168B                 sub     esp, 0Ch
.text$mn:0000168E                 mov     [ebp+var_4], ecx
.text$mn:00001691                 mov     ecx, [ebp+var_4]
.text$mn:00001694                 call    ?max_size@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QBEIXZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char>>::max_size(void)
.text$mn:00001699                 cmp     eax, [ebp+arg_0]
.text$mn:0000169C                 jnb     short loc_16A6
.text$mn:0000169E                 mov     ecx, [ebp+var_4]
.text$mn:000016A1                 call    ?_Xlen@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QBEXXZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char>>::_Xlen(void)
.text$mn:000016A6
.text$mn:000016A6 loc_16A6:                               ; CODE XREF: std::basic_string<char,std::char_traits<char>,std::allocator<char>>::_Grow(uint,bool)+14j
.text$mn:000016A6                 mov     eax, [ebp+var_4]
.text$mn:000016A9                 mov     ecx, [eax+18h]
.text$mn:000016AC                 cmp     ecx, [ebp+arg_0]
.text$mn:000016AF                 jnb     short loc_16C6
.text$mn:000016B1                 mov     edx, [ebp+var_4]
.text$mn:000016B4                 mov     eax, [edx+14h]
.text$mn:000016B7                 push    eax
.text$mn:000016B8                 mov     ecx, [ebp+arg_0]
.text$mn:000016BB                 push    ecx
.text$mn:000016BC                 mov     ecx, [ebp+var_4]
.text$mn:000016BF                 call    ?_Copy@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEXII@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char>>::_Copy(uint,uint)
.text$mn:000016C4                 jmp     short loc_1710
.text$mn:000016C6 ; ---------------------------------------------------------------------------
.text$mn:000016C6
.text$mn:000016C6 loc_16C6:                               ; CODE XREF: std::basic_string<char,std::char_traits<char>,std::allocator<char>>::_Grow(uint,bool)+27j
.text$mn:000016C6                 movzx   edx, [ebp+arg_4]
.text$mn:000016CA                 test    edx, edx
.text$mn:000016CC                 jz      short loc_1700
.text$mn:000016CE                 cmp     [ebp+arg_0], 10h
.text$mn:000016D2                 jnb     short loc_1700
.text$mn:000016D4                 mov     eax, [ebp+var_4]
.text$mn:000016D7                 mov     ecx, [ebp+arg_0]
.text$mn:000016DA                 cmp     ecx, [eax+14h]
.text$mn:000016DD                 jnb     short loc_16E7
.text$mn:000016DF                 mov     edx, [ebp+arg_0]
.text$mn:000016E2                 mov     [ebp+Size], edx
.text$mn:000016E5                 jmp     short loc_16F0
.text$mn:000016E7 ; ---------------------------------------------------------------------------
.text$mn:000016E7
.text$mn:000016E7 loc_16E7:                               ; CODE XREF: std::basic_string<char,std::char_traits<char>,std::allocator<char>>::_Grow(uint,bool)+55j
.text$mn:000016E7                 mov     eax, [ebp+var_4]
.text$mn:000016EA                 mov     ecx, [eax+14h]
.text$mn:000016ED                 mov     [ebp+Size], ecx
.text$mn:000016F0
.text$mn:000016F0 loc_16F0:                               ; CODE XREF: std::basic_string<char,std::char_traits<char>,std::allocator<char>>::_Grow(uint,bool)+5Dj
.text$mn:000016F0                 mov     edx, [ebp+Size]
.text$mn:000016F3                 push    edx             ; Size
.text$mn:000016F4                 push    1               ; char
.text$mn:000016F6                 mov     ecx, [ebp+var_4]
.text$mn:000016F9                 call    ?_Tidy@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEX_NI@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char>>::_Tidy(bool,uint)
.text$mn:000016FE                 jmp     short loc_1710
.text$mn:00001700 ; ---------------------------------------------------------------------------
.text$mn:00001700
.text$mn:00001700 loc_1700:                               ; CODE XREF: std::basic_string<char,std::char_traits<char>,std::allocator<char>>::_Grow(uint,bool)+44j
.text$mn:00001700                                         ; std::basic_string<char,std::char_traits<char>,std::allocator<char>>::_Grow(uint,bool)+4Aj
.text$mn:00001700                 cmp     [ebp+arg_0], 0
.text$mn:00001704                 jnz     short loc_1710
.text$mn:00001706                 push    0
.text$mn:00001708                 mov     ecx, [ebp+var_4]
.text$mn:0000170B                 call    ?_Eos@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEXI@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char>>::_Eos(uint)
.text$mn:00001710
.text$mn:00001710 loc_1710:                               ; CODE XREF: std::basic_string<char,std::char_traits<char>,std::allocator<char>>::_Grow(uint,bool)+3Cj
.text$mn:00001710                                         ; std::basic_string<char,std::char_traits<char>,std::allocator<char>>::_Grow(uint,bool)+76j ...
.text$mn:00001710                 cmp     [ebp+arg_0], 0
.text$mn:00001714                 jbe     short loc_171F
.text$mn:00001716                 mov     [ebp+var_C], 1
.text$mn:0000171D                 jmp     short loc_1726
.text$mn:0000171F ; ---------------------------------------------------------------------------
.text$mn:0000171F
.text$mn:0000171F loc_171F:                               ; CODE XREF: std::basic_string<char,std::char_traits<char>,std::allocator<char>>::_Grow(uint,bool)+8Cj
.text$mn:0000171F                 mov     [ebp+var_C], 0
.text$mn:00001726
.text$mn:00001726 loc_1726:                               ; CODE XREF: std::basic_string<char,std::char_traits<char>,std::allocator<char>>::_Grow(uint,bool)+95j
.text$mn:00001726                 mov     al, byte ptr [ebp+var_C]
.text$mn:00001729                 mov     esp, ebp
.text$mn:0000172B                 pop     ebp
.text$mn:0000172C                 retn    8
.text$mn:0000172C ?_Grow@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE_NI_N@Z endp
.text$mn:0000172C
.text$mn:0000172C ; ---------------------------------------------------------------------------
.text$mn:0000172F                 align 10h
.text$mn:0000172F _text$mn        ends
.text$mn:0000172F
.text$mn:00001730 ; ===========================================================================
.text$mn:00001730
.text$mn:00001730 ; Segment type: Pure code
.text$mn:00001730 ; Segment permissions: Read/Execute
.text$mn:00001730 _text$mn        segment para public 'CODE' use32
.text$mn:00001730                 assume cs:_text$mn
.text$mn:00001730                 ;org 1730h
.text$mn:00001730 ; COMDAT (pick any)
.text$mn:00001730                 assume es:nothing, ss:nothing, ds:_xdata$x, fs:nothing, gs:nothing
.text$mn:00001730
.text$mn:00001730 ; =============== S U B R O U T I N E =======================================
.text$mn:00001730
.text$mn:00001730 ; Attributes: bp-based frame
.text$mn:00001730
.text$mn:00001730 ; public: bool __thiscall std::basic_string<wchar_t, struct std::char_traits<wchar_t>, class std::allocator<wchar_t>>::_Grow(unsigned int, bool)
.text$mn:00001730                 public ?_Grow@?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QAE_NI_N@Z
.text$mn:00001730 ?_Grow@?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QAE_NI_N@Z proc near
.text$mn:00001730                                         ; CODE XREF: std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>>::assign(std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>> const &,uint,uint)+6Ap
.text$mn:00001730                                         ; std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>>::assign(wchar_t const *,uint)+61p
.text$mn:00001730
.text$mn:00001730 var_C           = dword ptr -0Ch
.text$mn:00001730 var_8           = dword ptr -8
.text$mn:00001730 var_4           = dword ptr -4
.text$mn:00001730 arg_0           = dword ptr  8
.text$mn:00001730 arg_4           = byte ptr  0Ch
.text$mn:00001730
.text$mn:00001730                 push    ebp
.text$mn:00001731                 mov     ebp, esp
.text$mn:00001733                 sub     esp, 0Ch
.text$mn:00001736                 mov     [ebp+var_4], ecx
.text$mn:00001739                 mov     ecx, [ebp+var_4]
.text$mn:0000173C                 call    ?max_size@?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QBEIXZ ; std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>>::max_size(void)
.text$mn:00001741                 cmp     eax, [ebp+arg_0]
.text$mn:00001744                 jnb     short loc_174E
.text$mn:00001746                 mov     ecx, [ebp+var_4]
.text$mn:00001749                 call    ?_Xlen@?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QBEXXZ ; std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>>::_Xlen(void)
.text$mn:0000174E
.text$mn:0000174E loc_174E:                               ; CODE XREF: std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>>::_Grow(uint,bool)+14j
.text$mn:0000174E                 mov     eax, [ebp+var_4]
.text$mn:00001751                 mov     ecx, [eax+18h]
.text$mn:00001754                 cmp     ecx, [ebp+arg_0]
.text$mn:00001757                 jnb     short loc_176E
.text$mn:00001759                 mov     edx, [ebp+var_4]
.text$mn:0000175C                 mov     eax, [edx+14h]
.text$mn:0000175F                 push    eax
.text$mn:00001760                 mov     ecx, [ebp+arg_0]
.text$mn:00001763                 push    ecx
.text$mn:00001764                 mov     ecx, [ebp+var_4]
.text$mn:00001767                 call    ?_Copy@?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QAEXII@Z ; std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>>::_Copy(uint,uint)
.text$mn:0000176C                 jmp     short loc_17B8
.text$mn:0000176E ; ---------------------------------------------------------------------------
.text$mn:0000176E
.text$mn:0000176E loc_176E:                               ; CODE XREF: std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>>::_Grow(uint,bool)+27j
.text$mn:0000176E                 movzx   edx, [ebp+arg_4]
.text$mn:00001772                 test    edx, edx
.text$mn:00001774                 jz      short loc_17A8
.text$mn:00001776                 cmp     [ebp+arg_0], 8
.text$mn:0000177A                 jnb     short loc_17A8
.text$mn:0000177C                 mov     eax, [ebp+var_4]
.text$mn:0000177F                 mov     ecx, [ebp+arg_0]
.text$mn:00001782                 cmp     ecx, [eax+14h]
.text$mn:00001785                 jnb     short loc_178F
.text$mn:00001787                 mov     edx, [ebp+arg_0]
.text$mn:0000178A                 mov     [ebp+var_8], edx
.text$mn:0000178D                 jmp     short loc_1798
.text$mn:0000178F ; ---------------------------------------------------------------------------
.text$mn:0000178F
.text$mn:0000178F loc_178F:                               ; CODE XREF: std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>>::_Grow(uint,bool)+55j
.text$mn:0000178F                 mov     eax, [ebp+var_4]
.text$mn:00001792                 mov     ecx, [eax+14h]
.text$mn:00001795                 mov     [ebp+var_8], ecx
.text$mn:00001798
.text$mn:00001798 loc_1798:                               ; CODE XREF: std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>>::_Grow(uint,bool)+5Dj
.text$mn:00001798                 mov     edx, [ebp+var_8]
.text$mn:0000179B                 push    edx
.text$mn:0000179C                 push    1
.text$mn:0000179E                 mov     ecx, [ebp+var_4]
.text$mn:000017A1                 call    ?_Tidy@?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QAEX_NI@Z ; std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>>::_Tidy(bool,uint)
.text$mn:000017A6                 jmp     short loc_17B8
.text$mn:000017A8 ; ---------------------------------------------------------------------------
.text$mn:000017A8
.text$mn:000017A8 loc_17A8:                               ; CODE XREF: std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>>::_Grow(uint,bool)+44j
.text$mn:000017A8                                         ; std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>>::_Grow(uint,bool)+4Aj
.text$mn:000017A8                 cmp     [ebp+arg_0], 0
.text$mn:000017AC                 jnz     short loc_17B8
.text$mn:000017AE                 push    0
.text$mn:000017B0                 mov     ecx, [ebp+var_4]
.text$mn:000017B3                 call    ?_Eos@?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QAEXI@Z ; std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>>::_Eos(uint)
.text$mn:000017B8
.text$mn:000017B8 loc_17B8:                               ; CODE XREF: std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>>::_Grow(uint,bool)+3Cj
.text$mn:000017B8                                         ; std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>>::_Grow(uint,bool)+76j ...
.text$mn:000017B8                 cmp     [ebp+arg_0], 0
.text$mn:000017BC                 jbe     short loc_17C7
.text$mn:000017BE                 mov     [ebp+var_C], 1
.text$mn:000017C5                 jmp     short loc_17CE
.text$mn:000017C7 ; ---------------------------------------------------------------------------
.text$mn:000017C7
.text$mn:000017C7 loc_17C7:                               ; CODE XREF: std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>>::_Grow(uint,bool)+8Cj
.text$mn:000017C7                 mov     [ebp+var_C], 0
.text$mn:000017CE
.text$mn:000017CE loc_17CE:                               ; CODE XREF: std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>>::_Grow(uint,bool)+95j
.text$mn:000017CE                 mov     al, byte ptr [ebp+var_C]
.text$mn:000017D1                 mov     esp, ebp
.text$mn:000017D3                 pop     ebp
.text$mn:000017D4                 retn    8
.text$mn:000017D4 ?_Grow@?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QAE_NI_N@Z endp
.text$mn:000017D4
.text$mn:000017D4 ; ---------------------------------------------------------------------------
.text$mn:000017D7                 align 4
.text$mn:000017D7 _text$mn        ends
.text$mn:000017D7
.text$mn:000017D8 ; ===========================================================================
.text$mn:000017D8
.text$mn:000017D8 ; Segment type: Pure code
.text$mn:000017D8 ; Segment permissions: Read/Execute
.text$mn:000017D8 _text$mn        segment para public 'CODE' use32
.text$mn:000017D8                 assume cs:_text$mn
.text$mn:000017D8                 ;org 17D8h
.text$mn:000017D8 ; COMDAT (pick any)
.text$mn:000017D8                 assume es:nothing, ss:nothing, ds:_xdata$x, fs:nothing, gs:nothing
.text$mn:000017D8
.text$mn:000017D8 ; =============== S U B R O U T I N E =======================================
.text$mn:000017D8
.text$mn:000017D8 ; Attributes: bp-based frame
.text$mn:000017D8
.text$mn:000017D8 ; public: bool __thiscall std::basic_string<char, struct std::char_traits<char>, class std::allocator<char>>::_Inside(char const *)
.text$mn:000017D8                 public ?_Inside@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE_NPBD@Z
.text$mn:000017D8 ?_Inside@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE_NPBD@Z proc near
.text$mn:000017D8                                         ; CODE XREF: std::basic_string<char,std::char_traits<char>,std::allocator<char>>::assign(char const *,uint)+2Ap
.text$mn:000017D8
.text$mn:000017D8 var_4           = dword ptr -4
.text$mn:000017D8 arg_0           = dword ptr  8
.text$mn:000017D8
.text$mn:000017D8                 push    ebp
.text$mn:000017D9                 mov     ebp, esp
.text$mn:000017DB                 push    ecx
.text$mn:000017DC                 mov     [ebp+var_4], ecx
.text$mn:000017DF                 cmp     [ebp+arg_0], 0
.text$mn:000017E3                 jz      short loc_1805
.text$mn:000017E5                 mov     ecx, [ebp+var_4]
.text$mn:000017E8                 call    ?_Myptr@?$_String_val@U?$_Simple_types@D@std@@@std@@QAEPADXZ ; std::_String_val<std::_Simple_types<char>>::_Myptr(void)
.text$mn:000017ED                 cmp     [ebp+arg_0], eax
.text$mn:000017F0                 jb      short loc_1805
.text$mn:000017F2                 mov     ecx, [ebp+var_4]
.text$mn:000017F5                 call    ?_Myptr@?$_String_val@U?$_Simple_types@D@std@@@std@@QAEPADXZ ; std::_String_val<std::_Simple_types<char>>::_Myptr(void)
.text$mn:000017FA                 mov     ecx, [ebp+var_4]
.text$mn:000017FD                 add     eax, [ecx+14h]
.text$mn:00001800                 cmp     eax, [ebp+arg_0]
.text$mn:00001803                 ja      short loc_180B
.text$mn:00001805
.text$mn:00001805 loc_1805:                               ; CODE XREF: std::basic_string<char,std::char_traits<char>,std::allocator<char>>::_Inside(char const *)+Bj
.text$mn:00001805                                         ; std::basic_string<char,std::char_traits<char>,std::allocator<char>>::_Inside(char const *)+18j
.text$mn:00001805                 xor     al, al
.text$mn:00001807                 jmp     short loc_180D
.text$mn:00001809 ; ---------------------------------------------------------------------------
.text$mn:00001809                 jmp     short loc_180D
.text$mn:0000180B ; ---------------------------------------------------------------------------
.text$mn:0000180B
.text$mn:0000180B loc_180B:                               ; CODE XREF: std::basic_string<char,std::char_traits<char>,std::allocator<char>>::_Inside(char const *)+2Bj
.text$mn:0000180B                 mov     al, 1
.text$mn:0000180D
.text$mn:0000180D loc_180D:                               ; CODE XREF: std::basic_string<char,std::char_traits<char>,std::allocator<char>>::_Inside(char const *)+2Fj
.text$mn:0000180D                                         ; std::basic_string<char,std::char_traits<char>,std::allocator<char>>::_Inside(char const *)+31j
.text$mn:0000180D                 mov     esp, ebp
.text$mn:0000180F                 pop     ebp
.text$mn:00001810                 retn    4
.text$mn:00001810 ?_Inside@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE_NPBD@Z endp
.text$mn:00001810
.text$mn:00001810 ; ---------------------------------------------------------------------------
.text$mn:00001813                 align 4
.text$mn:00001813 _text$mn        ends
.text$mn:00001813
.text$mn:00001814 ; ===========================================================================
.text$mn:00001814
.text$mn:00001814 ; Segment type: Pure code
.text$mn:00001814 ; Segment permissions: Read/Execute
.text$mn:00001814 _text$mn        segment para public 'CODE' use32
.text$mn:00001814                 assume cs:_text$mn
.text$mn:00001814                 ;org 1814h
.text$mn:00001814 ; COMDAT (pick any)
.text$mn:00001814                 assume es:nothing, ss:nothing, ds:_xdata$x, fs:nothing, gs:nothing
.text$mn:00001814
.text$mn:00001814 ; =============== S U B R O U T I N E =======================================
.text$mn:00001814
.text$mn:00001814 ; Attributes: bp-based frame
.text$mn:00001814
.text$mn:00001814 ; public: bool __thiscall std::basic_string<wchar_t, struct std::char_traits<wchar_t>, class std::allocator<wchar_t>>::_Inside(wchar_t const *)
.text$mn:00001814                 public ?_Inside@?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QAE_NPB_W@Z
.text$mn:00001814 ?_Inside@?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QAE_NPB_W@Z proc near
.text$mn:00001814                                         ; CODE XREF: std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>>::assign(wchar_t const *,uint)+2Ap
.text$mn:00001814
.text$mn:00001814 var_4           = dword ptr -4
.text$mn:00001814 arg_0           = dword ptr  8
.text$mn:00001814
.text$mn:00001814                 push    ebp
.text$mn:00001815                 mov     ebp, esp
.text$mn:00001817                 push    ecx
.text$mn:00001818                 mov     [ebp+var_4], ecx
.text$mn:0000181B                 cmp     [ebp+arg_0], 0
.text$mn:0000181F                 jz      short loc_1844
.text$mn:00001821                 mov     ecx, [ebp+var_4]
.text$mn:00001824                 call    ?_Myptr@?$_String_val@U?$_Simple_types@_W@std@@@std@@QAEPA_WXZ ; std::_String_val<std::_Simple_types<wchar_t>>::_Myptr(void)
.text$mn:00001829                 cmp     [ebp+arg_0], eax
.text$mn:0000182C                 jb      short loc_1844
.text$mn:0000182E                 mov     ecx, [ebp+var_4]
.text$mn:00001831                 call    ?_Myptr@?$_String_val@U?$_Simple_types@_W@std@@@std@@QAEPA_WXZ ; std::_String_val<std::_Simple_types<wchar_t>>::_Myptr(void)
.text$mn:00001836                 mov     ecx, [ebp+var_4]
.text$mn:00001839                 mov     edx, [ecx+14h]
.text$mn:0000183C                 lea     eax, [eax+edx*2]
.text$mn:0000183F                 cmp     eax, [ebp+arg_0]
.text$mn:00001842                 ja      short loc_184A
.text$mn:00001844
.text$mn:00001844 loc_1844:                               ; CODE XREF: std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>>::_Inside(wchar_t const *)+Bj
.text$mn:00001844                                         ; std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>>::_Inside(wchar_t const *)+18j
.text$mn:00001844                 xor     al, al
.text$mn:00001846                 jmp     short loc_184C
.text$mn:00001848 ; ---------------------------------------------------------------------------
.text$mn:00001848                 jmp     short loc_184C
.text$mn:0000184A ; ---------------------------------------------------------------------------
.text$mn:0000184A
.text$mn:0000184A loc_184A:                               ; CODE XREF: std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>>::_Inside(wchar_t const *)+2Ej
.text$mn:0000184A                 mov     al, 1
.text$mn:0000184C
.text$mn:0000184C loc_184C:                               ; CODE XREF: std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>>::_Inside(wchar_t const *)+32j
.text$mn:0000184C                                         ; std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>>::_Inside(wchar_t const *)+34j
.text$mn:0000184C                 mov     esp, ebp
.text$mn:0000184E                 pop     ebp
.text$mn:0000184F                 retn    4
.text$mn:0000184F ?_Inside@?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QAE_NPB_W@Z endp
.text$mn:0000184F
.text$mn:0000184F ; ---------------------------------------------------------------------------
.text$mn:00001852                 align 4
.text$mn:00001852 _text$mn        ends
.text$mn:00001852
.text$mn:00001854 ; ===========================================================================
.text$mn:00001854
.text$mn:00001854 ; Segment type: Pure code
.text$mn:00001854 ; Segment permissions: Read/Execute
.text$mn:00001854 _text$mn        segment para public 'CODE' use32
.text$mn:00001854                 assume cs:_text$mn
.text$mn:00001854                 ;org 1854h
.text$mn:00001854 ; COMDAT (pick any)
.text$mn:00001854                 assume es:nothing, ss:nothing, ds:_xdata$x, fs:nothing, gs:nothing
.text$mn:00001854
.text$mn:00001854 ; =============== S U B R O U T I N E =======================================
.text$mn:00001854
.text$mn:00001854 ; Attributes: bp-based frame
.text$mn:00001854
.text$mn:00001854 ; public: char * __thiscall std::_String_val<struct std::_Simple_types<char>>::_Myptr(void)
.text$mn:00001854                 public ?_Myptr@?$_String_val@U?$_Simple_types@D@std@@@std@@QAEPADXZ
.text$mn:00001854 ?_Myptr@?$_String_val@U?$_Simple_types@D@std@@@std@@QAEPADXZ proc near
.text$mn:00001854                                         ; CODE XREF: $LN19+14p
.text$mn:00001854                                         ; std::basic_string<char,std::char_traits<char>,std::allocator<char>>::_Eos(uint)+1Dp ...
.text$mn:00001854
.text$mn:00001854 var_8           = dword ptr -8
.text$mn:00001854 var_4           = dword ptr -4
.text$mn:00001854
.text$mn:00001854                 push    ebp
.text$mn:00001855                 mov     ebp, esp
.text$mn:00001857                 sub     esp, 8
.text$mn:0000185A                 mov     [ebp+var_4], ecx
.text$mn:0000185D                 mov     eax, [ebp+var_4]
.text$mn:00001860                 cmp     dword ptr [eax+18h], 10h
.text$mn:00001864                 jb      short loc_187A
.text$mn:00001866                 mov     ecx, [ebp+var_4]
.text$mn:00001869                 mov     edx, [ecx+4]
.text$mn:0000186C                 push    edx
.text$mn:0000186D                 call    ??$addressof@D@std@@YAPADAAD@Z ; std::addressof<char>(char &)
.text$mn:00001872                 add     esp, 4
.text$mn:00001875                 mov     [ebp+var_8], eax
.text$mn:00001878                 jmp     short loc_1883
.text$mn:0000187A ; ---------------------------------------------------------------------------
.text$mn:0000187A
.text$mn:0000187A loc_187A:                               ; CODE XREF: std::_String_val<std::_Simple_types<char>>::_Myptr(void)+10j
.text$mn:0000187A                 mov     eax, [ebp+var_4]
.text$mn:0000187D                 add     eax, 4
.text$mn:00001880                 mov     [ebp+var_8], eax
.text$mn:00001883
.text$mn:00001883 loc_1883:                               ; CODE XREF: std::_String_val<std::_Simple_types<char>>::_Myptr(void)+24j
.text$mn:00001883                 mov     eax, [ebp+var_8]
.text$mn:00001886                 mov     esp, ebp
.text$mn:00001888                 pop     ebp
.text$mn:00001889                 retn
.text$mn:00001889 ?_Myptr@?$_String_val@U?$_Simple_types@D@std@@@std@@QAEPADXZ endp
.text$mn:00001889
.text$mn:00001889 ; ---------------------------------------------------------------------------
.text$mn:0000188A                 align 4
.text$mn:0000188A _text$mn        ends
.text$mn:0000188A
.text$mn:0000188C ; ===========================================================================
.text$mn:0000188C
.text$mn:0000188C ; Segment type: Pure code
.text$mn:0000188C ; Segment permissions: Read/Execute
.text$mn:0000188C _text$mn        segment para public 'CODE' use32
.text$mn:0000188C                 assume cs:_text$mn
.text$mn:0000188C                 ;org 188Ch
.text$mn:0000188C ; COMDAT (pick any)
.text$mn:0000188C                 assume es:nothing, ss:nothing, ds:_xdata$x, fs:nothing, gs:nothing
.text$mn:0000188C
.text$mn:0000188C ; =============== S U B R O U T I N E =======================================
.text$mn:0000188C
.text$mn:0000188C ; Attributes: bp-based frame
.text$mn:0000188C
.text$mn:0000188C ; public: char const * __thiscall std::_String_val<struct std::_Simple_types<char>>::_Myptr(void)const
.text$mn:0000188C                 public ?_Myptr@?$_String_val@U?$_Simple_types@D@std@@@std@@QBEPBDXZ
.text$mn:0000188C ?_Myptr@?$_String_val@U?$_Simple_types@D@std@@@std@@QBEPBDXZ proc near
.text$mn:0000188C                                         ; CODE XREF: std::basic_string<char,std::char_traits<char>,std::allocator<char>>::assign(std::basic_string<char,std::char_traits<char>,std::allocator<char>> const &,uint,uint)+7Dp
.text$mn:0000188C
.text$mn:0000188C var_8           = dword ptr -8
.text$mn:0000188C var_4           = dword ptr -4
.text$mn:0000188C
.text$mn:0000188C                 push    ebp
.text$mn:0000188D                 mov     ebp, esp
.text$mn:0000188F                 sub     esp, 8
.text$mn:00001892                 mov     [ebp+var_4], ecx
.text$mn:00001895                 mov     eax, [ebp+var_4]
.text$mn:00001898                 cmp     dword ptr [eax+18h], 10h
.text$mn:0000189C                 jb      short loc_18B2
.text$mn:0000189E                 mov     ecx, [ebp+var_4]
.text$mn:000018A1                 mov     edx, [ecx+4]
.text$mn:000018A4                 push    edx
.text$mn:000018A5                 call    ??$addressof@D@std@@YAPADAAD@Z ; std::addressof<char>(char &)
.text$mn:000018AA                 add     esp, 4
.text$mn:000018AD                 mov     [ebp+var_8], eax
.text$mn:000018B0                 jmp     short loc_18BB
.text$mn:000018B2 ; ---------------------------------------------------------------------------
.text$mn:000018B2
.text$mn:000018B2 loc_18B2:                               ; CODE XREF: std::_String_val<std::_Simple_types<char>>::_Myptr(void)+10j
.text$mn:000018B2                 mov     eax, [ebp+var_4]
.text$mn:000018B5                 add     eax, 4
.text$mn:000018B8                 mov     [ebp+var_8], eax
.text$mn:000018BB
.text$mn:000018BB loc_18BB:                               ; CODE XREF: std::_String_val<std::_Simple_types<char>>::_Myptr(void)+24j
.text$mn:000018BB                 mov     eax, [ebp+var_8]
.text$mn:000018BE                 mov     esp, ebp
.text$mn:000018C0                 pop     ebp
.text$mn:000018C1                 retn
.text$mn:000018C1 ?_Myptr@?$_String_val@U?$_Simple_types@D@std@@@std@@QBEPBDXZ endp
.text$mn:000018C1
.text$mn:000018C1 ; ---------------------------------------------------------------------------
.text$mn:000018C2                 align 4
.text$mn:000018C2 _text$mn        ends
.text$mn:000018C2
.text$mn:000018C4 ; ===========================================================================
.text$mn:000018C4
.text$mn:000018C4 ; Segment type: Pure code
.text$mn:000018C4 ; Segment permissions: Read/Execute
.text$mn:000018C4 _text$mn        segment para public 'CODE' use32
.text$mn:000018C4                 assume cs:_text$mn
.text$mn:000018C4                 ;org 18C4h
.text$mn:000018C4 ; COMDAT (pick any)
.text$mn:000018C4                 assume es:nothing, ss:nothing, ds:_xdata$x, fs:nothing, gs:nothing
.text$mn:000018C4
.text$mn:000018C4 ; =============== S U B R O U T I N E =======================================
.text$mn:000018C4
.text$mn:000018C4 ; Attributes: bp-based frame
.text$mn:000018C4
.text$mn:000018C4 ; public: wchar_t * __thiscall std::_String_val<struct std::_Simple_types<wchar_t>>::_Myptr(void)
.text$mn:000018C4                 public ?_Myptr@?$_String_val@U?$_Simple_types@_W@std@@@std@@QAEPA_WXZ
.text$mn:000018C4 ?_Myptr@?$_String_val@U?$_Simple_types@_W@std@@@std@@QAEPA_WXZ proc near
.text$mn:000018C4                                         ; CODE XREF: $LN19_0+14p
.text$mn:000018C4                                         ; std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>>::_Eos(uint)+1Fp ...
.text$mn:000018C4
.text$mn:000018C4 var_8           = dword ptr -8
.text$mn:000018C4 var_4           = dword ptr -4
.text$mn:000018C4
.text$mn:000018C4                 push    ebp
.text$mn:000018C5                 mov     ebp, esp
.text$mn:000018C7                 sub     esp, 8
.text$mn:000018CA                 mov     [ebp+var_4], ecx
.text$mn:000018CD                 mov     eax, [ebp+var_4]
.text$mn:000018D0                 cmp     dword ptr [eax+18h], 8
.text$mn:000018D4                 jb      short loc_18EA
.text$mn:000018D6                 mov     ecx, [ebp+var_4]
.text$mn:000018D9                 mov     edx, [ecx+4]
.text$mn:000018DC                 push    edx
.text$mn:000018DD                 call    ??$addressof@_W@std@@YAPA_WAA_W@Z ; std::addressof<wchar_t>(wchar_t &)
.text$mn:000018E2                 add     esp, 4
.text$mn:000018E5                 mov     [ebp+var_8], eax
.text$mn:000018E8                 jmp     short loc_18F3
.text$mn:000018EA ; ---------------------------------------------------------------------------
.text$mn:000018EA
.text$mn:000018EA loc_18EA:                               ; CODE XREF: std::_String_val<std::_Simple_types<wchar_t>>::_Myptr(void)+10j
.text$mn:000018EA                 mov     eax, [ebp+var_4]
.text$mn:000018ED                 add     eax, 4
.text$mn:000018F0                 mov     [ebp+var_8], eax
.text$mn:000018F3
.text$mn:000018F3 loc_18F3:                               ; CODE XREF: std::_String_val<std::_Simple_types<wchar_t>>::_Myptr(void)+24j
.text$mn:000018F3                 mov     eax, [ebp+var_8]
.text$mn:000018F6                 mov     esp, ebp
.text$mn:000018F8                 pop     ebp
.text$mn:000018F9                 retn
.text$mn:000018F9 ?_Myptr@?$_String_val@U?$_Simple_types@_W@std@@@std@@QAEPA_WXZ endp
.text$mn:000018F9
.text$mn:000018F9 ; ---------------------------------------------------------------------------
.text$mn:000018FA                 align 4
.text$mn:000018FA _text$mn        ends
.text$mn:000018FA
.text$mn:000018FC ; ===========================================================================
.text$mn:000018FC
.text$mn:000018FC ; Segment type: Pure code
.text$mn:000018FC ; Segment permissions: Read/Execute
.text$mn:000018FC _text$mn        segment para public 'CODE' use32
.text$mn:000018FC                 assume cs:_text$mn
.text$mn:000018FC                 ;org 18FCh
.text$mn:000018FC ; COMDAT (pick any)
.text$mn:000018FC                 assume es:nothing, ss:nothing, ds:_xdata$x, fs:nothing, gs:nothing
.text$mn:000018FC
.text$mn:000018FC ; =============== S U B R O U T I N E =======================================
.text$mn:000018FC
.text$mn:000018FC ; Attributes: bp-based frame
.text$mn:000018FC
.text$mn:000018FC ; public: wchar_t const * __thiscall std::_String_val<struct std::_Simple_types<wchar_t>>::_Myptr(void)const
.text$mn:000018FC                 public ?_Myptr@?$_String_val@U?$_Simple_types@_W@std@@@std@@QBEPB_WXZ
.text$mn:000018FC ?_Myptr@?$_String_val@U?$_Simple_types@_W@std@@@std@@QBEPB_WXZ proc near
.text$mn:000018FC                                         ; CODE XREF: std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>>::assign(std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>> const &,uint,uint)+7Dp
.text$mn:000018FC                                         ; std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>>::c_str(void)+Ap
.text$mn:000018FC
.text$mn:000018FC var_8           = dword ptr -8
.text$mn:000018FC var_4           = dword ptr -4
.text$mn:000018FC
.text$mn:000018FC                 push    ebp
.text$mn:000018FD                 mov     ebp, esp
.text$mn:000018FF                 sub     esp, 8
.text$mn:00001902                 mov     [ebp+var_4], ecx
.text$mn:00001905                 mov     eax, [ebp+var_4]
.text$mn:00001908                 cmp     dword ptr [eax+18h], 8
.text$mn:0000190C                 jb      short loc_1922
.text$mn:0000190E                 mov     ecx, [ebp+var_4]
.text$mn:00001911                 mov     edx, [ecx+4]
.text$mn:00001914                 push    edx
.text$mn:00001915                 call    ??$addressof@_W@std@@YAPA_WAA_W@Z ; std::addressof<wchar_t>(wchar_t &)
.text$mn:0000191A                 add     esp, 4
.text$mn:0000191D                 mov     [ebp+var_8], eax
.text$mn:00001920                 jmp     short loc_192B
.text$mn:00001922 ; ---------------------------------------------------------------------------
.text$mn:00001922
.text$mn:00001922 loc_1922:                               ; CODE XREF: std::_String_val<std::_Simple_types<wchar_t>>::_Myptr(void)+10j
.text$mn:00001922                 mov     eax, [ebp+var_4]
.text$mn:00001925                 add     eax, 4
.text$mn:00001928                 mov     [ebp+var_8], eax
.text$mn:0000192B
.text$mn:0000192B loc_192B:                               ; CODE XREF: std::_String_val<std::_Simple_types<wchar_t>>::_Myptr(void)+24j
.text$mn:0000192B                 mov     eax, [ebp+var_8]
.text$mn:0000192E                 mov     esp, ebp
.text$mn:00001930                 pop     ebp
.text$mn:00001931                 retn
.text$mn:00001931 ?_Myptr@?$_String_val@U?$_Simple_types@_W@std@@@std@@QBEPB_WXZ endp
.text$mn:00001931
.text$mn:00001931 ; ---------------------------------------------------------------------------
.text$mn:00001932                 align 4
.text$mn:00001932 _text$mn        ends
.text$mn:00001932
.text$mn:00001934 ; ===========================================================================
.text$mn:00001934
.text$mn:00001934 ; Segment type: Pure code
.text$mn:00001934 ; Segment permissions: Read/Execute
.text$mn:00001934 _text$mn        segment para public 'CODE' use32
.text$mn:00001934                 assume cs:_text$mn
.text$mn:00001934                 ;org 1934h
.text$mn:00001934 ; COMDAT (pick any)
.text$mn:00001934                 assume es:nothing, ss:nothing, ds:_xdata$x, fs:nothing, gs:nothing
.text$mn:00001934
.text$mn:00001934 ; =============== S U B R O U T I N E =======================================
.text$mn:00001934
.text$mn:00001934 ; Attributes: bp-based frame
.text$mn:00001934
.text$mn:00001934 ; void __thiscall std::_Container_base12::_Orphan_all(std::_Container_base12 *__hidden this)
.text$mn:00001934                 public ?_Orphan_all@_Container_base12@std@@QAEXXZ
.text$mn:00001934 ?_Orphan_all@_Container_base12@std@@QAEXXZ proc near
.text$mn:00001934                                         ; CODE XREF: std::_Container_base12::~_Container_base12(void)+Ap
.text$mn:00001934                                         ; std::_String_alloc<0,std::_String_base_types<char,std::allocator<char>>>::_Free_proxy(void)+14p
.text$mn:00001934
.text$mn:00001934 var_18          = byte ptr -18h
.text$mn:00001934 var_14          = dword ptr -14h
.text$mn:00001934 var_10          = dword ptr -10h
.text$mn:00001934 var_C           = dword ptr -0Ch
.text$mn:00001934 var_4           = dword ptr -4
.text$mn:00001934
.text$mn:00001934                 push    ebp
.text$mn:00001935                 mov     ebp, esp
.text$mn:00001937                 push    0FFFFFFFFh
.text$mn:00001939                 push    offset __ehhandler$?_Orphan_all@_Container_base12@std@@QAEXXZ
.text$mn:0000193E                 mov     eax, large fs:0
.text$mn:00001944                 push    eax
.text$mn:00001945                 sub     esp, 0Ch
.text$mn:00001948                 mov     eax, dword ptr ds:___security_cookie
.text$mn:0000194D                 xor     eax, ebp
.text$mn:0000194F                 push    eax
.text$mn:00001950                 lea     eax, [ebp+var_C]
.text$mn:00001953                 mov     large fs:0, eax
.text$mn:00001959                 mov     [ebp+var_14], ecx
.text$mn:0000195C                 mov     eax, [ebp+var_14]
.text$mn:0000195F                 cmp     dword ptr [eax], 0
.text$mn:00001962                 jz      short loc_19BF
.text$mn:00001964                 push    3               ; int
.text$mn:00001966                 lea     ecx, [ebp+var_18] ; this
.text$mn:00001969                 call    ??0_Lockit@std@@QAE@H@Z ; std::_Lockit::_Lockit(int)
.text$mn:0000196E                 mov     [ebp+var_4], 0
.text$mn:00001975                 mov     ecx, [ebp+var_14]
.text$mn:00001978                 mov     edx, [ecx]
.text$mn:0000197A                 add     edx, 4
.text$mn:0000197D                 mov     [ebp+var_10], edx
.text$mn:00001980                 jmp     short loc_198F
.text$mn:00001982 ; ---------------------------------------------------------------------------
.text$mn:00001982
.text$mn:00001982 loc_1982:                               ; CODE XREF: std::_Container_base12::_Orphan_all(void)+6Ej
.text$mn:00001982                 mov     eax, [ebp+var_10]
.text$mn:00001985                 mov     ecx, [eax]
.text$mn:00001987                 mov     edx, [ebp+var_10]
.text$mn:0000198A                 mov     eax, [ecx+4]
.text$mn:0000198D                 mov     [edx], eax
.text$mn:0000198F
.text$mn:0000198F loc_198F:                               ; CODE XREF: std::_Container_base12::_Orphan_all(void)+4Cj
.text$mn:0000198F                 mov     ecx, [ebp+var_10]
.text$mn:00001992                 cmp     dword ptr [ecx], 0
.text$mn:00001995                 jz      short loc_19A4
.text$mn:00001997                 mov     edx, [ebp+var_10]
.text$mn:0000199A                 mov     eax, [edx]
.text$mn:0000199C                 mov     dword ptr [eax], 0
.text$mn:000019A2                 jmp     short loc_1982
.text$mn:000019A4 ; ---------------------------------------------------------------------------
.text$mn:000019A4
.text$mn:000019A4 loc_19A4:                               ; CODE XREF: std::_Container_base12::_Orphan_all(void)+61j
.text$mn:000019A4                 mov     ecx, [ebp+var_14]
.text$mn:000019A7                 mov     edx, [ecx]
.text$mn:000019A9                 mov     dword ptr [edx+4], 0
.text$mn:000019B0                 mov     [ebp+var_4], 0FFFFFFFFh
.text$mn:000019B7                 lea     ecx, [ebp+var_18] ; this
.text$mn:000019BA                 call    ??1_Lockit@std@@QAE@XZ ; std::_Lockit::~_Lockit(void)
.text$mn:000019BF
.text$mn:000019BF loc_19BF:                               ; CODE XREF: std::_Container_base12::_Orphan_all(void)+2Ej
.text$mn:000019BF                 mov     ecx, [ebp+var_C]
.text$mn:000019C2                 mov     large fs:0, ecx
.text$mn:000019C9                 pop     ecx
.text$mn:000019CA                 mov     esp, ebp
.text$mn:000019CC                 pop     ebp
.text$mn:000019CD                 retn
.text$mn:000019CD ?_Orphan_all@_Container_base12@std@@QAEXXZ endp
.text$mn:000019CD
.text$mn:000019CD ; ---------------------------------------------------------------------------
.text$mn:000019CE                 align 10h
.text$mn:000019CE _text$mn        ends
.text$mn:000019CE
.text$x:000019D0 ; ===========================================================================
.text$x:000019D0
.text$x:000019D0 ; Segment type: Pure code
.text$x:000019D0 ; Segment permissions: Read/Execute
.text$x:000019D0 _text$x         segment para public 'CODE' use32
.text$x:000019D0                 assume cs:_text$x
.text$x:000019D0                 ;org 19D0h
.text$x:000019D0 ; COMDAT (pick associative to section at 1934)
.text$x:000019D0                 assume es:nothing, ss:nothing, ds:_xdata$x, fs:nothing, gs:nothing
.text$x:000019D0
.text$x:000019D0 ; =============== S U B R O U T I N E =======================================
.text$x:000019D0
.text$x:000019D0
.text$x:000019D0 __unwindfunclet$?_Orphan_all@_Container_base12@std@@QAEXXZ$0 proc near
.text$x:000019D0                                         ; DATA XREF: .xdata$x:000027F0o
.text$x:000019D0                 lea     ecx, [ebp-18h]  ; this
.text$x:000019D3                 jmp     ??1_Lockit@std@@QAE@XZ ; std::_Lockit::~_Lockit(void)
.text$x:000019D3 __unwindfunclet$?_Orphan_all@_Container_base12@std@@QAEXXZ$0 endp
.text$x:000019D3
.text$x:000019D8
.text$x:000019D8 ; =============== S U B R O U T I N E =======================================
.text$x:000019D8
.text$x:000019D8
.text$x:000019D8 __ehhandler$?_Orphan_all@_Container_base12@std@@QAEXXZ proc near
.text$x:000019D8                                         ; DATA XREF: std::_Container_base12::_Orphan_all(void)+5o
.text$x:000019D8
.text$x:000019D8 arg_4           = dword ptr  8
.text$x:000019D8
.text$x:000019D8                 mov     edx, [esp+arg_4]
.text$x:000019DC                 lea     eax, [edx+0Ch]
.text$x:000019DF                 mov     ecx, [edx-10h]
.text$x:000019E2                 xor     ecx, eax
.text$x:000019E4                 call    @__security_check_cookie@4 ; __security_check_cookie(x)
.text$x:000019E9                 mov     eax, offset __ehfuncinfo$?_Orphan_all@_Container_base12@std@@QAEXXZ
.text$x:000019EE                 jmp     ___CxxFrameHandler3
.text$x:000019EE __ehhandler$?_Orphan_all@_Container_base12@std@@QAEXXZ endp
.text$x:000019EE
.text$x:000019EE ; ---------------------------------------------------------------------------
.text$x:000019F3                 align 4
.text$x:000019F3 _text$x         ends
.text$x:000019F3
.text$mn:000019F4 ; ===========================================================================
.text$mn:000019F4
.text$mn:000019F4 ; Segment type: Pure code
.text$mn:000019F4 ; Segment permissions: Read/Execute
.text$mn:000019F4 _text$mn        segment para public 'CODE' use32
.text$mn:000019F4                 assume cs:_text$mn
.text$mn:000019F4                 ;org 19F4h
.text$mn:000019F4 ; COMDAT (pick any)
.text$mn:000019F4                 assume es:nothing, ss:nothing, ds:_xdata$x, fs:nothing, gs:nothing
.text$mn:000019F4
.text$mn:000019F4 ; =============== S U B R O U T I N E =======================================
.text$mn:000019F4
.text$mn:000019F4 ; Attributes: bp-based frame
.text$mn:000019F4
.text$mn:000019F4 ; int __stdcall std::basic_string<char,std::char_traits<char>,std::allocator<char>>::_Tidy(char, size_t Size)
.text$mn:000019F4                 public ?_Tidy@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEX_NI@Z
.text$mn:000019F4 ?_Tidy@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEX_NI@Z proc near
.text$mn:000019F4                                         ; CODE XREF: std::basic_string<char,std::char_traits<char>,std::allocator<char>>::basic_string<char,std::char_traits<char>,std::allocator<char>>(char const *)+47p
.text$mn:000019F4                                         ; std::basic_string<char,std::char_traits<char>,std::allocator<char>>::~basic_string<char,std::char_traits<char>,std::allocator<char>>(void)+34p ...
.text$mn:000019F4
.text$mn:000019F4 var_C           = dword ptr -0Ch
.text$mn:000019F4 var_8           = dword ptr -8
.text$mn:000019F4 var_2           = byte ptr -2
.text$mn:000019F4 var_1           = byte ptr -1
.text$mn:000019F4 arg_0           = byte ptr  8
.text$mn:000019F4 Size            = dword ptr  0Ch
.text$mn:000019F4
.text$mn:000019F4                 push    ebp
.text$mn:000019F5                 mov     ebp, esp
.text$mn:000019F7                 sub     esp, 0Ch
.text$mn:000019FA                 mov     [ebp+var_8], ecx
.text$mn:000019FD                 movzx   eax, [ebp+arg_0]
.text$mn:00001A01                 test    eax, eax
.text$mn:00001A03                 jnz     short loc_1A07
.text$mn:00001A05                 jmp     short loc_1A7A
.text$mn:00001A07 ; ---------------------------------------------------------------------------
.text$mn:00001A07
.text$mn:00001A07 loc_1A07:                               ; CODE XREF: std::basic_string<char,std::char_traits<char>,std::allocator<char>>::_Tidy(bool,uint)+Fj
.text$mn:00001A07                 mov     ecx, [ebp+var_8]
.text$mn:00001A0A                 cmp     dword ptr [ecx+18h], 10h
.text$mn:00001A0E                 jb      short loc_1A7A
.text$mn:00001A10                 mov     edx, [ebp+var_8]
.text$mn:00001A13                 mov     eax, [edx+4]
.text$mn:00001A16                 mov     [ebp+var_C], eax
.text$mn:00001A19                 mov     ecx, [ebp+var_8]
.text$mn:00001A1C                 add     ecx, 4
.text$mn:00001A1F                 push    ecx
.text$mn:00001A20                 lea     edx, [ebp+var_1]
.text$mn:00001A23                 push    edx
.text$mn:00001A24                 mov     ecx, [ebp+var_8]
.text$mn:00001A27                 call    ?_Getal@?$_String_alloc@$0A@U?$_String_base_types@DV?$allocator@D@std@@@std@@@std@@QBE?AU?$_Wrap_alloc@V?$allocator@D@std@@@2@XZ ; std::_String_alloc<0,std::_String_base_types<char,std::allocator<char>>>::_Getal(void)
.text$mn:00001A2C                 mov     ecx, eax
.text$mn:00001A2E                 call    ??$destroy@PAD@?$_Wrap_alloc@V?$allocator@D@std@@@std@@QAEXPAPAD@Z ; std::_Wrap_alloc<std::allocator<char>>::destroy<char *>(char * *)
.text$mn:00001A33                 cmp     [ebp+Size], 0
.text$mn:00001A37                 jbe     short loc_1A59
.text$mn:00001A39                 mov     eax, [ebp+Size]
.text$mn:00001A3C                 push    eax             ; Size
.text$mn:00001A3D                 mov     ecx, [ebp+var_C]
.text$mn:00001A40                 push    ecx
.text$mn:00001A41                 call    ??$addressof@D@std@@YAPADAAD@Z ; std::addressof<char>(char &)
.text$mn:00001A46                 add     esp, 4
.text$mn:00001A49                 push    eax             ; Src
.text$mn:00001A4A                 mov     edx, [ebp+var_8]
.text$mn:00001A4D                 add     edx, 4
.text$mn:00001A50                 push    edx             ; Dst
.text$mn:00001A51                 call    ?copy@?$char_traits@D@std@@SAPADPADPBDI@Z ; std::char_traits<char>::copy(char *,char const *,uint)
.text$mn:00001A56                 add     esp, 0Ch
.text$mn:00001A59
.text$mn:00001A59 loc_1A59:                               ; CODE XREF: std::basic_string<char,std::char_traits<char>,std::allocator<char>>::_Tidy(bool,uint)+43j
.text$mn:00001A59                 mov     eax, [ebp+var_8]
.text$mn:00001A5C                 mov     ecx, [eax+18h]
.text$mn:00001A5F                 add     ecx, 1
.text$mn:00001A62                 push    ecx             ; int
.text$mn:00001A63                 mov     edx, [ebp+var_C]
.text$mn:00001A66                 push    edx             ; void *
.text$mn:00001A67                 lea     eax, [ebp+var_2]
.text$mn:00001A6A                 push    eax
.text$mn:00001A6B                 mov     ecx, [ebp+var_8]
.text$mn:00001A6E                 call    ?_Getal@?$_String_alloc@$0A@U?$_String_base_types@DV?$allocator@D@std@@@std@@@std@@QBE?AU?$_Wrap_alloc@V?$allocator@D@std@@@2@XZ ; std::_String_alloc<0,std::_String_base_types<char,std::allocator<char>>>::_Getal(void)
.text$mn:00001A73                 mov     ecx, eax
.text$mn:00001A75                 call    ?deallocate@?$_Wrap_alloc@V?$allocator@D@std@@@std@@QAEXPADI@Z ; std::_Wrap_alloc<std::allocator<char>>::deallocate(char *,uint)
.text$mn:00001A7A
.text$mn:00001A7A loc_1A7A:                               ; CODE XREF: std::basic_string<char,std::char_traits<char>,std::allocator<char>>::_Tidy(bool,uint)+11j
.text$mn:00001A7A                                         ; std::basic_string<char,std::char_traits<char>,std::allocator<char>>::_Tidy(bool,uint)+1Aj
.text$mn:00001A7A                 mov     ecx, [ebp+var_8]
.text$mn:00001A7D                 mov     dword ptr [ecx+18h], 0Fh
.text$mn:00001A84                 mov     edx, [ebp+Size]
.text$mn:00001A87                 push    edx
.text$mn:00001A88                 mov     ecx, [ebp+var_8]
.text$mn:00001A8B                 call    ?_Eos@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEXI@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char>>::_Eos(uint)
.text$mn:00001A90                 mov     esp, ebp
.text$mn:00001A92                 pop     ebp
.text$mn:00001A93                 retn    8
.text$mn:00001A93 ?_Tidy@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEX_NI@Z endp
.text$mn:00001A93
.text$mn:00001A93 ; ---------------------------------------------------------------------------
.text$mn:00001A96                 align 4
.text$mn:00001A96 _text$mn        ends
.text$mn:00001A96
.text$mn:00001A98 ; ===========================================================================
.text$mn:00001A98
.text$mn:00001A98 ; Segment type: Pure code
.text$mn:00001A98 ; Segment permissions: Read/Execute
.text$mn:00001A98 _text$mn        segment para public 'CODE' use32
.text$mn:00001A98                 assume cs:_text$mn
.text$mn:00001A98                 ;org 1A98h
.text$mn:00001A98 ; COMDAT (pick any)
.text$mn:00001A98                 assume es:nothing, ss:nothing, ds:_xdata$x, fs:nothing, gs:nothing
.text$mn:00001A98
.text$mn:00001A98 ; =============== S U B R O U T I N E =======================================
.text$mn:00001A98
.text$mn:00001A98 ; Attributes: bp-based frame
.text$mn:00001A98
.text$mn:00001A98 ; public: void __thiscall std::basic_string<wchar_t, struct std::char_traits<wchar_t>, class std::allocator<wchar_t>>::_Tidy(bool, unsigned int)
.text$mn:00001A98                 public ?_Tidy@?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QAEX_NI@Z
.text$mn:00001A98 ?_Tidy@?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QAEX_NI@Z proc near
.text$mn:00001A98                                         ; CODE XREF: __catch$?_Copy@?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QAEXII@Z$1+7p
.text$mn:00001A98                                         ; $LN19_0+2Dp ...
.text$mn:00001A98
.text$mn:00001A98 var_C           = dword ptr -0Ch
.text$mn:00001A98 var_8           = dword ptr -8
.text$mn:00001A98 var_2           = byte ptr -2
.text$mn:00001A98 var_1           = byte ptr -1
.text$mn:00001A98 arg_0           = byte ptr  8
.text$mn:00001A98 arg_4           = dword ptr  0Ch
.text$mn:00001A98
.text$mn:00001A98                 push    ebp
.text$mn:00001A99                 mov     ebp, esp
.text$mn:00001A9B                 sub     esp, 0Ch
.text$mn:00001A9E                 mov     [ebp+var_8], ecx
.text$mn:00001AA1                 movzx   eax, [ebp+arg_0]
.text$mn:00001AA5                 test    eax, eax
.text$mn:00001AA7                 jnz     short loc_1AAB
.text$mn:00001AA9                 jmp     short loc_1B1E
.text$mn:00001AAB ; ---------------------------------------------------------------------------
.text$mn:00001AAB
.text$mn:00001AAB loc_1AAB:                               ; CODE XREF: std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>>::_Tidy(bool,uint)+Fj
.text$mn:00001AAB                 mov     ecx, [ebp+var_8]
.text$mn:00001AAE                 cmp     dword ptr [ecx+18h], 8
.text$mn:00001AB2                 jb      short loc_1B1E
.text$mn:00001AB4                 mov     edx, [ebp+var_8]
.text$mn:00001AB7                 mov     eax, [edx+4]
.text$mn:00001ABA                 mov     [ebp+var_C], eax
.text$mn:00001ABD                 mov     ecx, [ebp+var_8]
.text$mn:00001AC0                 add     ecx, 4
.text$mn:00001AC3                 push    ecx
.text$mn:00001AC4                 lea     edx, [ebp+var_1]
.text$mn:00001AC7                 push    edx
.text$mn:00001AC8                 mov     ecx, [ebp+var_8]
.text$mn:00001ACB                 call    ?_Getal@?$_String_alloc@$0A@U?$_String_base_types@_WV?$allocator@_W@std@@@std@@@std@@QBE?AU?$_Wrap_alloc@V?$allocator@_W@std@@@2@XZ ; std::_String_alloc<0,std::_String_base_types<wchar_t,std::allocator<wchar_t>>>::_Getal(void)
.text$mn:00001AD0                 mov     ecx, eax
.text$mn:00001AD2                 call    ??$destroy@PA_W@?$_Wrap_alloc@V?$allocator@_W@std@@@std@@QAEXPAPA_W@Z ; std::_Wrap_alloc<std::allocator<wchar_t>>::destroy<wchar_t *>(wchar_t * *)
.text$mn:00001AD7                 cmp     [ebp+arg_4], 0
.text$mn:00001ADB                 jbe     short loc_1AFD
.text$mn:00001ADD                 mov     eax, [ebp+arg_4]
.text$mn:00001AE0                 push    eax             ; int
.text$mn:00001AE1                 mov     ecx, [ebp+var_C]
.text$mn:00001AE4                 push    ecx
.text$mn:00001AE5                 call    ??$addressof@_W@std@@YAPA_WAA_W@Z ; std::addressof<wchar_t>(wchar_t &)
.text$mn:00001AEA                 add     esp, 4
.text$mn:00001AED                 push    eax             ; Src
.text$mn:00001AEE                 mov     edx, [ebp+var_8]
.text$mn:00001AF1                 add     edx, 4
.text$mn:00001AF4                 push    edx             ; Dst
.text$mn:00001AF5                 call    ?copy@?$char_traits@_W@std@@SAPA_WPA_WPB_WI@Z ; std::char_traits<wchar_t>::copy(wchar_t *,wchar_t const *,uint)
.text$mn:00001AFA                 add     esp, 0Ch
.text$mn:00001AFD
.text$mn:00001AFD loc_1AFD:                               ; CODE XREF: std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>>::_Tidy(bool,uint)+43j
.text$mn:00001AFD                 mov     eax, [ebp+var_8]
.text$mn:00001B00                 mov     ecx, [eax+18h]
.text$mn:00001B03                 add     ecx, 1
.text$mn:00001B06                 push    ecx             ; int
.text$mn:00001B07                 mov     edx, [ebp+var_C]
.text$mn:00001B0A                 push    edx             ; void *
.text$mn:00001B0B                 lea     eax, [ebp+var_2]
.text$mn:00001B0E                 push    eax
.text$mn:00001B0F                 mov     ecx, [ebp+var_8]
.text$mn:00001B12                 call    ?_Getal@?$_String_alloc@$0A@U?$_String_base_types@_WV?$allocator@_W@std@@@std@@@std@@QBE?AU?$_Wrap_alloc@V?$allocator@_W@std@@@2@XZ ; std::_String_alloc<0,std::_String_base_types<wchar_t,std::allocator<wchar_t>>>::_Getal(void)
.text$mn:00001B17                 mov     ecx, eax
.text$mn:00001B19                 call    ?deallocate@?$_Wrap_alloc@V?$allocator@_W@std@@@std@@QAEXPA_WI@Z ; std::_Wrap_alloc<std::allocator<wchar_t>>::deallocate(wchar_t *,uint)
.text$mn:00001B1E
.text$mn:00001B1E loc_1B1E:                               ; CODE XREF: std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>>::_Tidy(bool,uint)+11j
.text$mn:00001B1E                                         ; std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>>::_Tidy(bool,uint)+1Aj
.text$mn:00001B1E                 mov     ecx, [ebp+var_8]
.text$mn:00001B21                 mov     dword ptr [ecx+18h], 7
.text$mn:00001B28                 mov     edx, [ebp+arg_4]
.text$mn:00001B2B                 push    edx
.text$mn:00001B2C                 mov     ecx, [ebp+var_8]
.text$mn:00001B2F                 call    ?_Eos@?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QAEXI@Z ; std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>>::_Eos(uint)
.text$mn:00001B34                 mov     esp, ebp
.text$mn:00001B36                 pop     ebp
.text$mn:00001B37                 retn    8
.text$mn:00001B37 ?_Tidy@?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QAEX_NI@Z endp
.text$mn:00001B37
.text$mn:00001B37 ; ---------------------------------------------------------------------------
.text$mn:00001B3A                 align 4
.text$mn:00001B3A _text$mn        ends
.text$mn:00001B3A
.text$mn:00001B3C ; ===========================================================================
.text$mn:00001B3C
.text$mn:00001B3C ; Segment type: Pure code
.text$mn:00001B3C ; Segment permissions: Read/Execute
.text$mn:00001B3C _text$mn        segment para public 'CODE' use32
.text$mn:00001B3C                 assume cs:_text$mn
.text$mn:00001B3C                 ;org 1B3Ch
.text$mn:00001B3C ; COMDAT (pick any)
.text$mn:00001B3C                 assume es:nothing, ss:nothing, ds:_xdata$x, fs:nothing, gs:nothing
.text$mn:00001B3C
.text$mn:00001B3C ; =============== S U B R O U T I N E =======================================
.text$mn:00001B3C
.text$mn:00001B3C ; Attributes: bp-based frame
.text$mn:00001B3C
.text$mn:00001B3C ; public: void __thiscall std::basic_string<char, struct std::char_traits<char>, class std::allocator<char>>::_Xlen(void)const
.text$mn:00001B3C                 public ?_Xlen@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QBEXXZ
.text$mn:00001B3C ?_Xlen@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QBEXXZ proc near
.text$mn:00001B3C                                         ; CODE XREF: std::basic_string<char,std::char_traits<char>,std::allocator<char>>::_Grow(uint,bool)+19p
.text$mn:00001B3C
.text$mn:00001B3C var_4           = dword ptr -4
.text$mn:00001B3C
.text$mn:00001B3C                 push    ebp
.text$mn:00001B3D                 mov     ebp, esp
.text$mn:00001B3F                 push    ecx
.text$mn:00001B40                 mov     [ebp+var_4], ecx
.text$mn:00001B43                 push    offset ??_C@_0BA@JFNIOLAK@string?5too?5long?$AA@ ; "string too long"
.text$mn:00001B48                 call    ?_Xlength_error@std@@YAXPBD@Z ; std::_Xlength_error(char const *)
.text$mn:00001B4D                 mov     esp, ebp
.text$mn:00001B4F                 pop     ebp
.text$mn:00001B50                 retn
.text$mn:00001B50 ?_Xlen@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QBEXXZ endp
.text$mn:00001B50
.text$mn:00001B50 ; ---------------------------------------------------------------------------
.text$mn:00001B51                 align 4
.text$mn:00001B51 _text$mn        ends
.text$mn:00001B51
.text$mn:00001B54 ; ===========================================================================
.text$mn:00001B54
.text$mn:00001B54 ; Segment type: Pure code
.text$mn:00001B54 ; Segment permissions: Read/Execute
.text$mn:00001B54 _text$mn        segment para public 'CODE' use32
.text$mn:00001B54                 assume cs:_text$mn
.text$mn:00001B54                 ;org 1B54h
.text$mn:00001B54 ; COMDAT (pick any)
.text$mn:00001B54                 assume es:nothing, ss:nothing, ds:_xdata$x, fs:nothing, gs:nothing
.text$mn:00001B54
.text$mn:00001B54 ; =============== S U B R O U T I N E =======================================
.text$mn:00001B54
.text$mn:00001B54 ; Attributes: bp-based frame
.text$mn:00001B54
.text$mn:00001B54 ; public: void __thiscall std::basic_string<wchar_t, struct std::char_traits<wchar_t>, class std::allocator<wchar_t>>::_Xlen(void)const
.text$mn:00001B54                 public ?_Xlen@?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QBEXXZ
.text$mn:00001B54 ?_Xlen@?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QBEXXZ proc near
.text$mn:00001B54                                         ; CODE XREF: std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>>::_Grow(uint,bool)+19p
.text$mn:00001B54
.text$mn:00001B54 var_4           = dword ptr -4
.text$mn:00001B54
.text$mn:00001B54                 push    ebp
.text$mn:00001B55                 mov     ebp, esp
.text$mn:00001B57                 push    ecx
.text$mn:00001B58                 mov     [ebp+var_4], ecx
.text$mn:00001B5B                 push    offset ??_C@_0BA@JFNIOLAK@string?5too?5long?$AA@ ; "string too long"
.text$mn:00001B60                 call    ?_Xlength_error@std@@YAXPBD@Z ; std::_Xlength_error(char const *)
.text$mn:00001B65                 mov     esp, ebp
.text$mn:00001B67                 pop     ebp
.text$mn:00001B68                 retn
.text$mn:00001B68 ?_Xlen@?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QBEXXZ endp
.text$mn:00001B68
.text$mn:00001B68 ; ---------------------------------------------------------------------------
.text$mn:00001B69                 align 4
.text$mn:00001B69 _text$mn        ends
.text$mn:00001B69
.text$mn:00001B6C ; ===========================================================================
.text$mn:00001B6C
.text$mn:00001B6C ; Segment type: Pure code
.text$mn:00001B6C ; Segment permissions: Read/Execute
.text$mn:00001B6C _text$mn        segment para public 'CODE' use32
.text$mn:00001B6C                 assume cs:_text$mn
.text$mn:00001B6C                 ;org 1B6Ch
.text$mn:00001B6C ; COMDAT (pick any)
.text$mn:00001B6C                 assume es:nothing, ss:nothing, ds:_xdata$x, fs:nothing, gs:nothing
.text$mn:00001B6C
.text$mn:00001B6C ; =============== S U B R O U T I N E =======================================
.text$mn:00001B6C
.text$mn:00001B6C ; Attributes: bp-based frame
.text$mn:00001B6C
.text$mn:00001B6C ; public: void __thiscall std::basic_string<char, struct std::char_traits<char>, class std::allocator<char>>::_Xran(void)const
.text$mn:00001B6C                 public ?_Xran@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QBEXXZ
.text$mn:00001B6C ?_Xran@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QBEXXZ proc near
.text$mn:00001B6C                                         ; CODE XREF: std::basic_string<char,std::char_traits<char>,std::allocator<char>>::assign(std::basic_string<char,std::char_traits<char>,std::allocator<char>> const &,uint,uint)+19p
.text$mn:00001B6C                                         ; std::basic_string<char,std::char_traits<char>,std::allocator<char>>::erase(uint)+15p ...
.text$mn:00001B6C
.text$mn:00001B6C var_4           = dword ptr -4
.text$mn:00001B6C
.text$mn:00001B6C                 push    ebp
.text$mn:00001B6D                 mov     ebp, esp
.text$mn:00001B6F                 push    ecx
.text$mn:00001B70                 mov     [ebp+var_4], ecx
.text$mn:00001B73                 push    offset ??_C@_0BI@CFPLBAOH@invalid?5string?5position?$AA@ ; "invalid string position"
.text$mn:00001B78                 call    ?_Xout_of_range@std@@YAXPBD@Z ; std::_Xout_of_range(char const *)
.text$mn:00001B7D                 mov     esp, ebp
.text$mn:00001B7F                 pop     ebp
.text$mn:00001B80                 retn
.text$mn:00001B80 ?_Xran@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QBEXXZ endp
.text$mn:00001B80
.text$mn:00001B80 ; ---------------------------------------------------------------------------
.text$mn:00001B81                 align 4
.text$mn:00001B81 _text$mn        ends
.text$mn:00001B81
.text$mn:00001B84 ; ===========================================================================
.text$mn:00001B84
.text$mn:00001B84 ; Segment type: Pure code
.text$mn:00001B84 ; Segment permissions: Read/Execute
.text$mn:00001B84 _text$mn        segment para public 'CODE' use32
.text$mn:00001B84                 assume cs:_text$mn
.text$mn:00001B84                 ;org 1B84h
.text$mn:00001B84 ; COMDAT (pick any)
.text$mn:00001B84                 assume es:nothing, ss:nothing, ds:_xdata$x, fs:nothing, gs:nothing
.text$mn:00001B84
.text$mn:00001B84 ; =============== S U B R O U T I N E =======================================
.text$mn:00001B84
.text$mn:00001B84 ; Attributes: bp-based frame
.text$mn:00001B84
.text$mn:00001B84 ; public: void __thiscall std::basic_string<wchar_t, struct std::char_traits<wchar_t>, class std::allocator<wchar_t>>::_Xran(void)const
.text$mn:00001B84                 public ?_Xran@?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QBEXXZ
.text$mn:00001B84 ?_Xran@?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QBEXXZ proc near
.text$mn:00001B84                                         ; CODE XREF: std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>>::assign(std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>> const &,uint,uint)+19p
.text$mn:00001B84                                         ; std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>>::erase(uint)+15p ...
.text$mn:00001B84
.text$mn:00001B84 var_4           = dword ptr -4
.text$mn:00001B84
.text$mn:00001B84                 push    ebp
.text$mn:00001B85                 mov     ebp, esp
.text$mn:00001B87                 push    ecx
.text$mn:00001B88                 mov     [ebp+var_4], ecx
.text$mn:00001B8B                 push    offset ??_C@_0BI@CFPLBAOH@invalid?5string?5position?$AA@ ; "invalid string position"
.text$mn:00001B90                 call    ?_Xout_of_range@std@@YAXPBD@Z ; std::_Xout_of_range(char const *)
.text$mn:00001B95                 mov     esp, ebp
.text$mn:00001B97                 pop     ebp
.text$mn:00001B98                 retn
.text$mn:00001B98 ?_Xran@?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QBEXXZ endp
.text$mn:00001B98
.text$mn:00001B98 ; ---------------------------------------------------------------------------
.text$mn:00001B99                 align 4
.text$mn:00001B99 _text$mn        ends
.text$mn:00001B99
.text$mn:00001B9C ; ===========================================================================
.text$mn:00001B9C
.text$mn:00001B9C ; Segment type: Pure code
.text$mn:00001B9C ; Segment permissions: Read/Execute
.text$mn:00001B9C _text$mn        segment para public 'CODE' use32
.text$mn:00001B9C                 assume cs:_text$mn
.text$mn:00001B9C                 ;org 1B9Ch
.text$mn:00001B9C ; COMDAT (pick any)
.text$mn:00001B9C                 assume es:nothing, ss:nothing, ds:_xdata$x, fs:nothing, gs:nothing
.text$mn:00001B9C
.text$mn:00001B9C ; =============== S U B R O U T I N E =======================================
.text$mn:00001B9C
.text$mn:00001B9C ; Attributes: bp-based frame
.text$mn:00001B9C
.text$mn:00001B9C ; public: char * __thiscall std::_Wrap_alloc<class std::allocator<char>>::allocate(unsigned int)
.text$mn:00001B9C                 public ?allocate@?$_Wrap_alloc@V?$allocator@D@std@@@std@@QAEPADI@Z
.text$mn:00001B9C ?allocate@?$_Wrap_alloc@V?$allocator@D@std@@@std@@QAEPADI@Z proc near
.text$mn:00001B9C                                         ; CODE XREF: std::basic_string<char,std::char_traits<char>,std::allocator<char>>::_Copy(uint,uint)+BBp
.text$mn:00001B9C                                         ; __catch$?_Copy@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEXII@Z$0+22p
.text$mn:00001B9C
.text$mn:00001B9C var_4           = dword ptr -4
.text$mn:00001B9C arg_0           = dword ptr  8
.text$mn:00001B9C
.text$mn:00001B9C                 push    ebp
.text$mn:00001B9D                 mov     ebp, esp
.text$mn:00001B9F                 push    ecx
.text$mn:00001BA0                 mov     [ebp+var_4], ecx
.text$mn:00001BA3                 mov     eax, [ebp+arg_0]
.text$mn:00001BA6                 push    eax
.text$mn:00001BA7                 mov     ecx, [ebp+var_4]
.text$mn:00001BAA                 call    ?allocate@?$allocator@D@std@@QAEPADI@Z ; std::allocator<char>::allocate(uint)
.text$mn:00001BAF                 mov     esp, ebp
.text$mn:00001BB1                 pop     ebp
.text$mn:00001BB2                 retn    4
.text$mn:00001BB2 ?allocate@?$_Wrap_alloc@V?$allocator@D@std@@@std@@QAEPADI@Z endp
.text$mn:00001BB2
.text$mn:00001BB2 ; ---------------------------------------------------------------------------
.text$mn:00001BB5                 align 4
.text$mn:00001BB5 _text$mn        ends
.text$mn:00001BB5
.text$mn:00001BB8 ; ===========================================================================
.text$mn:00001BB8
.text$mn:00001BB8 ; Segment type: Pure code
.text$mn:00001BB8 ; Segment permissions: Read/Execute
.text$mn:00001BB8 _text$mn        segment para public 'CODE' use32
.text$mn:00001BB8                 assume cs:_text$mn
.text$mn:00001BB8                 ;org 1BB8h
.text$mn:00001BB8 ; COMDAT (pick any)
.text$mn:00001BB8                 assume es:nothing, ss:nothing, ds:_xdata$x, fs:nothing, gs:nothing
.text$mn:00001BB8
.text$mn:00001BB8 ; =============== S U B R O U T I N E =======================================
.text$mn:00001BB8
.text$mn:00001BB8 ; Attributes: bp-based frame
.text$mn:00001BB8
.text$mn:00001BB8 ; public: wchar_t * __thiscall std::_Wrap_alloc<class std::allocator<wchar_t>>::allocate(unsigned int)
.text$mn:00001BB8                 public ?allocate@?$_Wrap_alloc@V?$allocator@_W@std@@@std@@QAEPA_WI@Z
.text$mn:00001BB8 ?allocate@?$_Wrap_alloc@V?$allocator@_W@std@@@std@@QAEPA_WI@Z proc near
.text$mn:00001BB8                                         ; CODE XREF: std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>>::_Copy(uint,uint)+BBp
.text$mn:00001BB8                                         ; __catch$?_Copy@?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QAEXII@Z$0+22p
.text$mn:00001BB8
.text$mn:00001BB8 var_4           = dword ptr -4
.text$mn:00001BB8 arg_0           = dword ptr  8
.text$mn:00001BB8
.text$mn:00001BB8                 push    ebp
.text$mn:00001BB9                 mov     ebp, esp
.text$mn:00001BBB                 push    ecx
.text$mn:00001BBC                 mov     [ebp+var_4], ecx
.text$mn:00001BBF                 mov     eax, [ebp+arg_0]
.text$mn:00001BC2                 push    eax
.text$mn:00001BC3                 mov     ecx, [ebp+var_4]
.text$mn:00001BC6                 call    ?allocate@?$allocator@_W@std@@QAEPA_WI@Z ; std::allocator<wchar_t>::allocate(uint)
.text$mn:00001BCB                 mov     esp, ebp
.text$mn:00001BCD                 pop     ebp
.text$mn:00001BCE                 retn    4
.text$mn:00001BCE ?allocate@?$_Wrap_alloc@V?$allocator@_W@std@@@std@@QAEPA_WI@Z endp
.text$mn:00001BCE
.text$mn:00001BCE ; ---------------------------------------------------------------------------
.text$mn:00001BD1                 align 4
.text$mn:00001BD1 _text$mn        ends
.text$mn:00001BD1
.text$mn:00001BD4 ; ===========================================================================
.text$mn:00001BD4
.text$mn:00001BD4 ; Segment type: Pure code
.text$mn:00001BD4 ; Segment permissions: Read/Execute
.text$mn:00001BD4 _text$mn        segment para public 'CODE' use32
.text$mn:00001BD4                 assume cs:_text$mn
.text$mn:00001BD4                 ;org 1BD4h
.text$mn:00001BD4 ; COMDAT (pick any)
.text$mn:00001BD4                 assume es:nothing, ss:nothing, ds:_xdata$x, fs:nothing, gs:nothing
.text$mn:00001BD4
.text$mn:00001BD4 ; =============== S U B R O U T I N E =======================================
.text$mn:00001BD4
.text$mn:00001BD4 ; Attributes: bp-based frame
.text$mn:00001BD4
.text$mn:00001BD4 ; public: char * __thiscall std::allocator<char>::allocate(unsigned int)
.text$mn:00001BD4                 public ?allocate@?$allocator@D@std@@QAEPADI@Z
.text$mn:00001BD4 ?allocate@?$allocator@D@std@@QAEPADI@Z proc near
.text$mn:00001BD4                                         ; CODE XREF: std::_Wrap_alloc<std::allocator<char>>::allocate(uint)+Ep
.text$mn:00001BD4
.text$mn:00001BD4 var_4           = dword ptr -4
.text$mn:00001BD4 arg_0           = dword ptr  8
.text$mn:00001BD4
.text$mn:00001BD4                 push    ebp
.text$mn:00001BD5                 mov     ebp, esp
.text$mn:00001BD7                 push    ecx
.text$mn:00001BD8                 mov     [ebp+var_4], ecx
.text$mn:00001BDB                 push    0
.text$mn:00001BDD                 mov     eax, [ebp+arg_0]
.text$mn:00001BE0                 push    eax
.text$mn:00001BE1                 call    ??$_Allocate@D@std@@YAPADIPAD@Z ; std::_Allocate<char>(uint,char *)
.text$mn:00001BE6                 add     esp, 8
.text$mn:00001BE9                 mov     esp, ebp
.text$mn:00001BEB                 pop     ebp
.text$mn:00001BEC                 retn    4
.text$mn:00001BEC ?allocate@?$allocator@D@std@@QAEPADI@Z endp
.text$mn:00001BEC
.text$mn:00001BEC ; ---------------------------------------------------------------------------
.text$mn:00001BEF                 align 10h
.text$mn:00001BEF _text$mn        ends
.text$mn:00001BEF
.text$mn:00001BF0 ; ===========================================================================
.text$mn:00001BF0
.text$mn:00001BF0 ; Segment type: Pure code
.text$mn:00001BF0 ; Segment permissions: Read/Execute
.text$mn:00001BF0 _text$mn        segment para public 'CODE' use32
.text$mn:00001BF0                 assume cs:_text$mn
.text$mn:00001BF0                 ;org 1BF0h
.text$mn:00001BF0 ; COMDAT (pick any)
.text$mn:00001BF0                 assume es:nothing, ss:nothing, ds:_xdata$x, fs:nothing, gs:nothing
.text$mn:00001BF0
.text$mn:00001BF0 ; =============== S U B R O U T I N E =======================================
.text$mn:00001BF0
.text$mn:00001BF0 ; Attributes: bp-based frame
.text$mn:00001BF0
.text$mn:00001BF0 ; public: struct std::_Container_proxy * __thiscall std::allocator<struct std::_Container_proxy>::allocate(unsigned int)
.text$mn:00001BF0                 public ?allocate@?$allocator@U_Container_proxy@std@@@std@@QAEPAU_Container_proxy@2@I@Z
.text$mn:00001BF0 ?allocate@?$allocator@U_Container_proxy@std@@@std@@QAEPAU_Container_proxy@2@I@Z proc near
.text$mn:00001BF0                                         ; CODE XREF: std::_String_alloc<0,std::_String_base_types<char,std::allocator<char>>>::_Alloc_proxy(void)+16p
.text$mn:00001BF0
.text$mn:00001BF0 var_4           = dword ptr -4
.text$mn:00001BF0 arg_0           = dword ptr  8
.text$mn:00001BF0
.text$mn:00001BF0                 push    ebp
.text$mn:00001BF1                 mov     ebp, esp
.text$mn:00001BF3                 push    ecx
.text$mn:00001BF4                 mov     [ebp+var_4], ecx
.text$mn:00001BF7                 push    0
.text$mn:00001BF9                 mov     eax, [ebp+arg_0]
.text$mn:00001BFC                 push    eax
.text$mn:00001BFD                 call    ??$_Allocate@U_Container_proxy@std@@@std@@YAPAU_Container_proxy@0@IPAU10@@Z ; std::_Allocate<std::_Container_proxy>(uint,std::_Container_proxy *)
.text$mn:00001C02                 add     esp, 8
.text$mn:00001C05                 mov     esp, ebp
.text$mn:00001C07                 pop     ebp
.text$mn:00001C08                 retn    4
.text$mn:00001C08 ?allocate@?$allocator@U_Container_proxy@std@@@std@@QAEPAU_Container_proxy@2@I@Z endp
.text$mn:00001C08
.text$mn:00001C08 ; ---------------------------------------------------------------------------
.text$mn:00001C0B                 align 4
.text$mn:00001C0B _text$mn        ends
.text$mn:00001C0B
.text$mn:00001C0C ; ===========================================================================
.text$mn:00001C0C
.text$mn:00001C0C ; Segment type: Pure code
.text$mn:00001C0C ; Segment permissions: Read/Execute
.text$mn:00001C0C _text$mn        segment para public 'CODE' use32
.text$mn:00001C0C                 assume cs:_text$mn
.text$mn:00001C0C                 ;org 1C0Ch
.text$mn:00001C0C ; COMDAT (pick any)
.text$mn:00001C0C                 assume es:nothing, ss:nothing, ds:_xdata$x, fs:nothing, gs:nothing
.text$mn:00001C0C
.text$mn:00001C0C ; =============== S U B R O U T I N E =======================================
.text$mn:00001C0C
.text$mn:00001C0C ; Attributes: bp-based frame
.text$mn:00001C0C
.text$mn:00001C0C ; public: wchar_t * __thiscall std::allocator<wchar_t>::allocate(unsigned int)
.text$mn:00001C0C                 public ?allocate@?$allocator@_W@std@@QAEPA_WI@Z
.text$mn:00001C0C ?allocate@?$allocator@_W@std@@QAEPA_WI@Z proc near
.text$mn:00001C0C                                         ; CODE XREF: std::_Wrap_alloc<std::allocator<wchar_t>>::allocate(uint)+Ep
.text$mn:00001C0C
.text$mn:00001C0C var_4           = dword ptr -4
.text$mn:00001C0C arg_0           = dword ptr  8
.text$mn:00001C0C
.text$mn:00001C0C                 push    ebp
.text$mn:00001C0D                 mov     ebp, esp
.text$mn:00001C0F                 push    ecx
.text$mn:00001C10                 mov     [ebp+var_4], ecx
.text$mn:00001C13                 push    0
.text$mn:00001C15                 mov     eax, [ebp+arg_0]
.text$mn:00001C18                 push    eax
.text$mn:00001C19                 call    ??$_Allocate@_W@std@@YAPA_WIPA_W@Z ; std::_Allocate<wchar_t>(uint,wchar_t *)
.text$mn:00001C1E                 add     esp, 8
.text$mn:00001C21                 mov     esp, ebp
.text$mn:00001C23                 pop     ebp
.text$mn:00001C24                 retn    4
.text$mn:00001C24 ?allocate@?$allocator@_W@std@@QAEPA_WI@Z endp
.text$mn:00001C24
.text$mn:00001C24 ; ---------------------------------------------------------------------------
.text$mn:00001C27                 align 4
.text$mn:00001C27 _text$mn        ends
.text$mn:00001C27
.text$mn:00001C28 ; ===========================================================================
.text$mn:00001C28
.text$mn:00001C28 ; Segment type: Pure code
.text$mn:00001C28 ; Segment permissions: Read/Execute
.text$mn:00001C28 _text$mn        segment para public 'CODE' use32
.text$mn:00001C28                 assume cs:_text$mn
.text$mn:00001C28                 ;org 1C28h
.text$mn:00001C28 ; COMDAT (pick any)
.text$mn:00001C28                 assume es:nothing, ss:nothing, ds:_xdata$x, fs:nothing, gs:nothing
.text$mn:00001C28
.text$mn:00001C28 ; =============== S U B R O U T I N E =======================================
.text$mn:00001C28
.text$mn:00001C28 ; Attributes: bp-based frame
.text$mn:00001C28
.text$mn:00001C28 ; public: class std::basic_string<char, struct std::char_traits<char>, class std::allocator<char>> & __thiscall std::basic_string<char, struct std::char_traits<char>, class std::allocator<char>>::assign(class std::basic_string<char, struct std::char_traits<char>, class std::allocator<char>> const &, unsigned int, unsigned int)
.text$mn:00001C28                 public ?assign@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV12@ABV12@II@Z
.text$mn:00001C28 ?assign@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV12@ABV12@II@Z proc near
.text$mn:00001C28                                         ; CODE XREF: std::basic_string<char,std::char_traits<char>,std::allocator<char>>::assign(char const *,uint)+4Fp
.text$mn:00001C28
.text$mn:00001C28 Size            = dword ptr -8
.text$mn:00001C28 var_4           = dword ptr -4
.text$mn:00001C28 arg_0           = dword ptr  8
.text$mn:00001C28 arg_4           = dword ptr  0Ch
.text$mn:00001C28 arg_8           = dword ptr  10h
.text$mn:00001C28
.text$mn:00001C28                 push    ebp
.text$mn:00001C29                 mov     ebp, esp
.text$mn:00001C2B                 sub     esp, 8
.text$mn:00001C2E                 mov     [ebp+var_4], ecx
.text$mn:00001C31                 mov     ecx, [ebp+arg_0]
.text$mn:00001C34                 call    ?size@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QBEIXZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char>>::size(void)
.text$mn:00001C39                 cmp     eax, [ebp+arg_4]
.text$mn:00001C3C                 jnb     short loc_1C46
.text$mn:00001C3E                 mov     ecx, [ebp+var_4]
.text$mn:00001C41                 call    ?_Xran@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QBEXXZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char>>::_Xran(void)
.text$mn:00001C46
.text$mn:00001C46 loc_1C46:                               ; CODE XREF: std::basic_string<char,std::char_traits<char>,std::allocator<char>>::assign(std::basic_string<char,std::char_traits<char>,std::allocator<char>> const &,uint,uint)+14j
.text$mn:00001C46                 mov     ecx, [ebp+arg_0]
.text$mn:00001C49                 call    ?size@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QBEIXZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char>>::size(void)
.text$mn:00001C4E                 sub     eax, [ebp+arg_4]
.text$mn:00001C51                 mov     [ebp+Size], eax
.text$mn:00001C54                 mov     eax, [ebp+arg_8]
.text$mn:00001C57                 cmp     eax, [ebp+Size]
.text$mn:00001C5A                 jnb     short loc_1C62
.text$mn:00001C5C                 mov     ecx, [ebp+arg_8]
.text$mn:00001C5F                 mov     [ebp+Size], ecx
.text$mn:00001C62
.text$mn:00001C62 loc_1C62:                               ; CODE XREF: std::basic_string<char,std::char_traits<char>,std::allocator<char>>::assign(std::basic_string<char,std::char_traits<char>,std::allocator<char>> const &,uint,uint)+32j
.text$mn:00001C62                 mov     edx, [ebp+var_4]
.text$mn:00001C65                 cmp     edx, [ebp+arg_0]
.text$mn:00001C68                 jnz     short loc_1C89
.text$mn:00001C6A                 mov     eax, [ebp+arg_4]
.text$mn:00001C6D                 add     eax, [ebp+Size]
.text$mn:00001C70                 push    eax
.text$mn:00001C71                 mov     ecx, [ebp+var_4]
.text$mn:00001C74                 call    ?erase@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV12@I@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char>>::erase(uint)
.text$mn:00001C79                 mov     ecx, [ebp+arg_4]
.text$mn:00001C7C                 push    ecx
.text$mn:00001C7D                 push    0
.text$mn:00001C7F                 mov     ecx, [ebp+var_4]
.text$mn:00001C82                 call    ?erase@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV12@II@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char>>::erase(uint,uint)
.text$mn:00001C87                 jmp     short loc_1CCB
.text$mn:00001C89 ; ---------------------------------------------------------------------------
.text$mn:00001C89
.text$mn:00001C89 loc_1C89:                               ; CODE XREF: std::basic_string<char,std::char_traits<char>,std::allocator<char>>::assign(std::basic_string<char,std::char_traits<char>,std::allocator<char>> const &,uint,uint)+40j
.text$mn:00001C89                 push    0
.text$mn:00001C8B                 mov     edx, [ebp+Size]
.text$mn:00001C8E                 push    edx
.text$mn:00001C8F                 mov     ecx, [ebp+var_4]
.text$mn:00001C92                 call    ?_Grow@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE_NI_N@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char>>::_Grow(uint,bool)
.text$mn:00001C97                 movzx   eax, al
.text$mn:00001C9A                 test    eax, eax
.text$mn:00001C9C                 jz      short loc_1CCB
.text$mn:00001C9E                 mov     ecx, [ebp+Size]
.text$mn:00001CA1                 push    ecx             ; Size
.text$mn:00001CA2                 mov     ecx, [ebp+arg_0]
.text$mn:00001CA5                 call    ?_Myptr@?$_String_val@U?$_Simple_types@D@std@@@std@@QBEPBDXZ ; std::_String_val<std::_Simple_types<char>>::_Myptr(void)
.text$mn:00001CAA                 add     eax, [ebp+arg_4]
.text$mn:00001CAD                 push    eax             ; Src
.text$mn:00001CAE                 mov     ecx, [ebp+var_4]
.text$mn:00001CB1                 call    ?_Myptr@?$_String_val@U?$_Simple_types@D@std@@@std@@QAEPADXZ ; std::_String_val<std::_Simple_types<char>>::_Myptr(void)
.text$mn:00001CB6                 push    eax             ; Dst
.text$mn:00001CB7                 call    ?copy@?$char_traits@D@std@@SAPADPADPBDI@Z ; std::char_traits<char>::copy(char *,char const *,uint)
.text$mn:00001CBC                 add     esp, 0Ch
.text$mn:00001CBF                 mov     edx, [ebp+Size]
.text$mn:00001CC2                 push    edx
.text$mn:00001CC3                 mov     ecx, [ebp+var_4]
.text$mn:00001CC6                 call    ?_Eos@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEXI@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char>>::_Eos(uint)
.text$mn:00001CCB
.text$mn:00001CCB loc_1CCB:                               ; CODE XREF: std::basic_string<char,std::char_traits<char>,std::allocator<char>>::assign(std::basic_string<char,std::char_traits<char>,std::allocator<char>> const &,uint,uint)+5Fj
.text$mn:00001CCB                                         ; std::basic_string<char,std::char_traits<char>,std::allocator<char>>::assign(std::basic_string<char,std::char_traits<char>,std::allocator<char>> const &,uint,uint)+74j
.text$mn:00001CCB                 mov     eax, [ebp+var_4]
.text$mn:00001CCE                 mov     esp, ebp
.text$mn:00001CD0                 pop     ebp
.text$mn:00001CD1                 retn    0Ch
.text$mn:00001CD1 ?assign@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV12@ABV12@II@Z endp
.text$mn:00001CD1
.text$mn:00001CD1 _text$mn        ends
.text$mn:00001CD1
.text$mn:00001CD4 ; ===========================================================================
.text$mn:00001CD4
.text$mn:00001CD4 ; Segment type: Pure code
.text$mn:00001CD4 ; Segment permissions: Read/Execute
.text$mn:00001CD4 _text$mn        segment para public 'CODE' use32
.text$mn:00001CD4                 assume cs:_text$mn
.text$mn:00001CD4                 ;org 1CD4h
.text$mn:00001CD4 ; COMDAT (pick any)
.text$mn:00001CD4                 assume es:nothing, ss:nothing, ds:_xdata$x, fs:nothing, gs:nothing
.text$mn:00001CD4
.text$mn:00001CD4 ; =============== S U B R O U T I N E =======================================
.text$mn:00001CD4
.text$mn:00001CD4 ; Attributes: bp-based frame
.text$mn:00001CD4
.text$mn:00001CD4 ; int __stdcall std::basic_string<char,std::char_traits<char>,std::allocator<char>>::assign(char *Str)
.text$mn:00001CD4                 public ?assign@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV12@PBD@Z
.text$mn:00001CD4 ?assign@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV12@PBD@Z proc near
.text$mn:00001CD4                                         ; CODE XREF: std::basic_string<char,std::char_traits<char>,std::allocator<char>>::basic_string<char,std::char_traits<char>,std::allocator<char>>(char const *)+53p
.text$mn:00001CD4
.text$mn:00001CD4 var_4           = dword ptr -4
.text$mn:00001CD4 Str             = dword ptr  8
.text$mn:00001CD4
.text$mn:00001CD4                 push    ebp
.text$mn:00001CD5                 mov     ebp, esp
.text$mn:00001CD7                 push    ecx
.text$mn:00001CD8                 mov     [ebp+var_4], ecx
.text$mn:00001CDB                 push    490h            ; unsigned int
.text$mn:00001CE0                 push    offset ??_C@_1IO@FEAPGJBD@?$AAC?$AA?3?$AA?2?$AAP?$AAr?$AAo?$AAg?$AAr?$AAa?$AAm?$AA?5?$AAF?$AAi?$AAl?$AAe?$AAs?$AA?5?$AA?$CI?$AAx?$AA8?$AA6?$AA?$CJ?$AA?2?$AAM?$AAi?$AAc?$AAr?$AAo?$AAs?$AAo?$AAf?$AAt@ ; "C:\\Program Files (x86)\\Microsoft Visu"...
.text$mn:00001CE5                 mov     eax, [ebp+Str]
.text$mn:00001CE8                 push    eax             ; int
.text$mn:00001CE9                 call    ??$_Debug_pointer@D@std@@YAXPBDPB_WI@Z ; std::_Debug_pointer<char>(char const *,wchar_t const *,uint)
.text$mn:00001CEE                 add     esp, 0Ch
.text$mn:00001CF1                 mov     ecx, [ebp+Str]
.text$mn:00001CF4                 push    ecx             ; Str
.text$mn:00001CF5                 call    ?length@?$char_traits@D@std@@SAIPBD@Z ; std::char_traits<char>::length(char const *)
.text$mn:00001CFA                 add     esp, 4
.text$mn:00001CFD                 push    eax             ; Size
.text$mn:00001CFE                 mov     edx, [ebp+Str]
.text$mn:00001D01                 push    edx             ; Src
.text$mn:00001D02                 mov     ecx, [ebp+var_4]
.text$mn:00001D05                 call    ?assign@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV12@PBDI@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char>>::assign(char const *,uint)
.text$mn:00001D0A                 mov     esp, ebp
.text$mn:00001D0C                 pop     ebp
.text$mn:00001D0D                 retn    4
.text$mn:00001D0D ?assign@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV12@PBD@Z endp
.text$mn:00001D0D
.text$mn:00001D0D _text$mn        ends
.text$mn:00001D0D
.text$mn:00001D10 ; ===========================================================================
.text$mn:00001D10
.text$mn:00001D10 ; Segment type: Pure code
.text$mn:00001D10 ; Segment permissions: Read/Execute
.text$mn:00001D10 _text$mn        segment para public 'CODE' use32
.text$mn:00001D10                 assume cs:_text$mn
.text$mn:00001D10                 ;org 1D10h
.text$mn:00001D10 ; COMDAT (pick any)
.text$mn:00001D10                 assume es:nothing, ss:nothing, ds:_xdata$x, fs:nothing, gs:nothing
.text$mn:00001D10
.text$mn:00001D10 ; =============== S U B R O U T I N E =======================================
.text$mn:00001D10
.text$mn:00001D10 ; Attributes: bp-based frame
.text$mn:00001D10
.text$mn:00001D10 ; int __stdcall std::basic_string<char,std::char_traits<char>,std::allocator<char>>::assign(void *Src, size_t Size)
.text$mn:00001D10                 public ?assign@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV12@PBDI@Z
.text$mn:00001D10 ?assign@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV12@PBDI@Z proc near
.text$mn:00001D10                                         ; CODE XREF: std::basic_string<char,std::char_traits<char>,std::allocator<char>>::assign(char const *)+31p
.text$mn:00001D10
.text$mn:00001D10 var_4           = dword ptr -4
.text$mn:00001D10 Src             = dword ptr  8
.text$mn:00001D10 Size            = dword ptr  0Ch
.text$mn:00001D10
.text$mn:00001D10                 push    ebp
.text$mn:00001D11                 mov     ebp, esp
.text$mn:00001D13                 push    ecx
.text$mn:00001D14                 mov     [ebp+var_4], ecx
.text$mn:00001D17                 cmp     [ebp+Size], 0
.text$mn:00001D1B                 jz      short loc_1D33
.text$mn:00001D1D                 push    47Fh            ; unsigned int
.text$mn:00001D22                 push    offset ??_C@_1IO@FEAPGJBD@?$AAC?$AA?3?$AA?2?$AAP?$AAr?$AAo?$AAg?$AAr?$AAa?$AAm?$AA?5?$AAF?$AAi?$AAl?$AAe?$AAs?$AA?5?$AA?$CI?$AAx?$AA8?$AA6?$AA?$CJ?$AA?2?$AAM?$AAi?$AAc?$AAr?$AAo?$AAs?$AAo?$AAf?$AAt@ ; "C:\\Program Files (x86)\\Microsoft Visu"...
.text$mn:00001D27                 mov     eax, [ebp+Src]
.text$mn:00001D2A                 push    eax             ; int
.text$mn:00001D2B                 call    ??$_Debug_pointer@D@std@@YAXPBDPB_WI@Z ; std::_Debug_pointer<char>(char const *,wchar_t const *,uint)
.text$mn:00001D30                 add     esp, 0Ch
.text$mn:00001D33
.text$mn:00001D33 loc_1D33:                               ; CODE XREF: std::basic_string<char,std::char_traits<char>,std::allocator<char>>::assign(char const *,uint)+Bj
.text$mn:00001D33                 mov     ecx, [ebp+Src]
.text$mn:00001D36                 push    ecx
.text$mn:00001D37                 mov     ecx, [ebp+var_4]
.text$mn:00001D3A                 call    ?_Inside@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE_NPBD@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char>>::_Inside(char const *)
.text$mn:00001D3F                 movzx   edx, al
.text$mn:00001D42                 test    edx, edx
.text$mn:00001D44                 jz      short loc_1D66
.text$mn:00001D46                 mov     eax, [ebp+Size]
.text$mn:00001D49                 push    eax
.text$mn:00001D4A                 mov     ecx, [ebp+var_4]
.text$mn:00001D4D                 call    ?_Myptr@?$_String_val@U?$_Simple_types@D@std@@@std@@QAEPADXZ ; std::_String_val<std::_Simple_types<char>>::_Myptr(void)
.text$mn:00001D52                 mov     ecx, [ebp+Src]
.text$mn:00001D55                 sub     ecx, eax
.text$mn:00001D57                 push    ecx
.text$mn:00001D58                 mov     edx, [ebp+var_4]
.text$mn:00001D5B                 push    edx
.text$mn:00001D5C                 mov     ecx, [ebp+var_4]
.text$mn:00001D5F                 call    ?assign@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV12@ABV12@II@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char>>::assign(std::basic_string<char,std::char_traits<char>,std::allocator<char>> const &,uint,uint)
.text$mn:00001D64                 jmp     short loc_1DA3
.text$mn:00001D66 ; ---------------------------------------------------------------------------
.text$mn:00001D66
.text$mn:00001D66 loc_1D66:                               ; CODE XREF: std::basic_string<char,std::char_traits<char>,std::allocator<char>>::assign(char const *,uint)+34j
.text$mn:00001D66                 push    0
.text$mn:00001D68                 mov     eax, [ebp+Size]
.text$mn:00001D6B                 push    eax
.text$mn:00001D6C                 mov     ecx, [ebp+var_4]
.text$mn:00001D6F                 call    ?_Grow@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE_NI_N@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char>>::_Grow(uint,bool)
.text$mn:00001D74                 movzx   ecx, al
.text$mn:00001D77                 test    ecx, ecx
.text$mn:00001D79                 jz      short loc_1DA0
.text$mn:00001D7B                 mov     edx, [ebp+Size]
.text$mn:00001D7E                 push    edx             ; Size
.text$mn:00001D7F                 mov     eax, [ebp+Src]
.text$mn:00001D82                 push    eax             ; Src
.text$mn:00001D83                 mov     ecx, [ebp+var_4]
.text$mn:00001D86                 call    ?_Myptr@?$_String_val@U?$_Simple_types@D@std@@@std@@QAEPADXZ ; std::_String_val<std::_Simple_types<char>>::_Myptr(void)
.text$mn:00001D8B                 push    eax             ; Dst
.text$mn:00001D8C                 call    ?copy@?$char_traits@D@std@@SAPADPADPBDI@Z ; std::char_traits<char>::copy(char *,char const *,uint)
.text$mn:00001D91                 add     esp, 0Ch
.text$mn:00001D94                 mov     ecx, [ebp+Size]
.text$mn:00001D97                 push    ecx
.text$mn:00001D98                 mov     ecx, [ebp+var_4]
.text$mn:00001D9B                 call    ?_Eos@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEXI@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char>>::_Eos(uint)
.text$mn:00001DA0
.text$mn:00001DA0 loc_1DA0:                               ; CODE XREF: std::basic_string<char,std::char_traits<char>,std::allocator<char>>::assign(char const *,uint)+69j
.text$mn:00001DA0                 mov     eax, [ebp+var_4]
.text$mn:00001DA3
.text$mn:00001DA3 loc_1DA3:                               ; CODE XREF: std::basic_string<char,std::char_traits<char>,std::allocator<char>>::assign(char const *,uint)+54j
.text$mn:00001DA3                 mov     esp, ebp
.text$mn:00001DA5                 pop     ebp
.text$mn:00001DA6                 retn    8
.text$mn:00001DA6 ?assign@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV12@PBDI@Z endp
.text$mn:00001DA6
.text$mn:00001DA6 ; ---------------------------------------------------------------------------
.text$mn:00001DA9                 align 4
.text$mn:00001DA9 _text$mn        ends
.text$mn:00001DA9
.text$mn:00001DAC ; ===========================================================================
.text$mn:00001DAC
.text$mn:00001DAC ; Segment type: Pure code
.text$mn:00001DAC ; Segment permissions: Read/Execute
.text$mn:00001DAC _text$mn        segment para public 'CODE' use32
.text$mn:00001DAC                 assume cs:_text$mn
.text$mn:00001DAC                 ;org 1DACh
.text$mn:00001DAC ; COMDAT (pick any)
.text$mn:00001DAC                 assume es:nothing, ss:nothing, ds:_xdata$x, fs:nothing, gs:nothing
.text$mn:00001DAC
.text$mn:00001DAC ; =============== S U B R O U T I N E =======================================
.text$mn:00001DAC
.text$mn:00001DAC ; Attributes: bp-based frame
.text$mn:00001DAC
.text$mn:00001DAC ; public: class std::basic_string<wchar_t, struct std::char_traits<wchar_t>, class std::allocator<wchar_t>> & __thiscall std::basic_string<wchar_t, struct std::char_traits<wchar_t>, class std::allocator<wchar_t>>::assign(class std::basic_string<wchar_t, struct std::char_traits<wchar_t>, class std::allocator<wchar_t>> const &, unsigned int, unsigned int)
.text$mn:00001DAC                 public ?assign@?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QAEAAV12@ABV12@II@Z
.text$mn:00001DAC ?assign@?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QAEAAV12@ABV12@II@Z proc near
.text$mn:00001DAC                                         ; CODE XREF: std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>>::assign(wchar_t const *,uint)+51p
.text$mn:00001DAC
.text$mn:00001DAC var_8           = dword ptr -8
.text$mn:00001DAC var_4           = dword ptr -4
.text$mn:00001DAC arg_0           = dword ptr  8
.text$mn:00001DAC arg_4           = dword ptr  0Ch
.text$mn:00001DAC arg_8           = dword ptr  10h
.text$mn:00001DAC
.text$mn:00001DAC                 push    ebp
.text$mn:00001DAD                 mov     ebp, esp
.text$mn:00001DAF                 sub     esp, 8
.text$mn:00001DB2                 mov     [ebp+var_4], ecx
.text$mn:00001DB5                 mov     ecx, [ebp+arg_0]
.text$mn:00001DB8                 call    ?size@?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QBEIXZ ; std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>>::size(void)
.text$mn:00001DBD                 cmp     eax, [ebp+arg_4]
.text$mn:00001DC0                 jnb     short loc_1DCA
.text$mn:00001DC2                 mov     ecx, [ebp+var_4]
.text$mn:00001DC5                 call    ?_Xran@?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QBEXXZ ; std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>>::_Xran(void)
.text$mn:00001DCA
.text$mn:00001DCA loc_1DCA:                               ; CODE XREF: std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>>::assign(std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>> const &,uint,uint)+14j
.text$mn:00001DCA                 mov     ecx, [ebp+arg_0]
.text$mn:00001DCD                 call    ?size@?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QBEIXZ ; std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>>::size(void)
.text$mn:00001DD2                 sub     eax, [ebp+arg_4]
.text$mn:00001DD5                 mov     [ebp+var_8], eax
.text$mn:00001DD8                 mov     eax, [ebp+arg_8]
.text$mn:00001DDB                 cmp     eax, [ebp+var_8]
.text$mn:00001DDE                 jnb     short loc_1DE6
.text$mn:00001DE0                 mov     ecx, [ebp+arg_8]
.text$mn:00001DE3                 mov     [ebp+var_8], ecx
.text$mn:00001DE6
.text$mn:00001DE6 loc_1DE6:                               ; CODE XREF: std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>>::assign(std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>> const &,uint,uint)+32j
.text$mn:00001DE6                 mov     edx, [ebp+var_4]
.text$mn:00001DE9                 cmp     edx, [ebp+arg_0]
.text$mn:00001DEC                 jnz     short loc_1E0D
.text$mn:00001DEE                 mov     eax, [ebp+arg_4]
.text$mn:00001DF1                 add     eax, [ebp+var_8]
.text$mn:00001DF4                 push    eax
.text$mn:00001DF5                 mov     ecx, [ebp+var_4]
.text$mn:00001DF8                 call    ?erase@?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QAEAAV12@I@Z ; std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>>::erase(uint)
.text$mn:00001DFD                 mov     ecx, [ebp+arg_4]
.text$mn:00001E00                 push    ecx
.text$mn:00001E01                 push    0
.text$mn:00001E03                 mov     ecx, [ebp+var_4]
.text$mn:00001E06                 call    ?erase@?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QAEAAV12@II@Z ; std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>>::erase(uint,uint)
.text$mn:00001E0B                 jmp     short loc_1E52
.text$mn:00001E0D ; ---------------------------------------------------------------------------
.text$mn:00001E0D
.text$mn:00001E0D loc_1E0D:                               ; CODE XREF: std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>>::assign(std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>> const &,uint,uint)+40j
.text$mn:00001E0D                 push    0
.text$mn:00001E0F                 mov     edx, [ebp+var_8]
.text$mn:00001E12                 push    edx
.text$mn:00001E13                 mov     ecx, [ebp+var_4]
.text$mn:00001E16                 call    ?_Grow@?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QAE_NI_N@Z ; std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>>::_Grow(uint,bool)
.text$mn:00001E1B                 movzx   eax, al
.text$mn:00001E1E                 test    eax, eax
.text$mn:00001E20                 jz      short loc_1E52
.text$mn:00001E22                 mov     ecx, [ebp+var_8]
.text$mn:00001E25                 push    ecx             ; int
.text$mn:00001E26                 mov     ecx, [ebp+arg_0]
.text$mn:00001E29                 call    ?_Myptr@?$_String_val@U?$_Simple_types@_W@std@@@std@@QBEPB_WXZ ; std::_String_val<std::_Simple_types<wchar_t>>::_Myptr(void)
.text$mn:00001E2E                 mov     edx, [ebp+arg_4]
.text$mn:00001E31                 lea     eax, [eax+edx*2]
.text$mn:00001E34                 push    eax             ; Src
.text$mn:00001E35                 mov     ecx, [ebp+var_4]
.text$mn:00001E38                 call    ?_Myptr@?$_String_val@U?$_Simple_types@_W@std@@@std@@QAEPA_WXZ ; std::_String_val<std::_Simple_types<wchar_t>>::_Myptr(void)
.text$mn:00001E3D                 push    eax             ; Dst
.text$mn:00001E3E                 call    ?copy@?$char_traits@_W@std@@SAPA_WPA_WPB_WI@Z ; std::char_traits<wchar_t>::copy(wchar_t *,wchar_t const *,uint)
.text$mn:00001E43                 add     esp, 0Ch
.text$mn:00001E46                 mov     ecx, [ebp+var_8]
.text$mn:00001E49                 push    ecx
.text$mn:00001E4A                 mov     ecx, [ebp+var_4]
.text$mn:00001E4D                 call    ?_Eos@?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QAEXI@Z ; std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>>::_Eos(uint)
.text$mn:00001E52
.text$mn:00001E52 loc_1E52:                               ; CODE XREF: std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>>::assign(std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>> const &,uint,uint)+5Fj
.text$mn:00001E52                                         ; std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>>::assign(std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>> const &,uint,uint)+74j
.text$mn:00001E52                 mov     eax, [ebp+var_4]
.text$mn:00001E55                 mov     esp, ebp
.text$mn:00001E57                 pop     ebp
.text$mn:00001E58                 retn    0Ch
.text$mn:00001E58 ?assign@?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QAEAAV12@ABV12@II@Z endp
.text$mn:00001E58
.text$mn:00001E58 ; ---------------------------------------------------------------------------
.text$mn:00001E5B                 align 4
.text$mn:00001E5B _text$mn        ends
.text$mn:00001E5B
.text$mn:00001E5C ; ===========================================================================
.text$mn:00001E5C
.text$mn:00001E5C ; Segment type: Pure code
.text$mn:00001E5C ; Segment permissions: Read/Execute
.text$mn:00001E5C _text$mn        segment para public 'CODE' use32
.text$mn:00001E5C                 assume cs:_text$mn
.text$mn:00001E5C                 ;org 1E5Ch
.text$mn:00001E5C ; COMDAT (pick any)
.text$mn:00001E5C                 assume es:nothing, ss:nothing, ds:_xdata$x, fs:nothing, gs:nothing
.text$mn:00001E5C
.text$mn:00001E5C ; =============== S U B R O U T I N E =======================================
.text$mn:00001E5C
.text$mn:00001E5C ; Attributes: bp-based frame
.text$mn:00001E5C
.text$mn:00001E5C ; int __stdcall std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>>::assign(wchar_t *Str)
.text$mn:00001E5C                 public ?assign@?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QAEAAV12@PB_W@Z
.text$mn:00001E5C ?assign@?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QAEAAV12@PB_W@Z proc near
.text$mn:00001E5C                                         ; CODE XREF: std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>>::operator=(wchar_t const *)+Ep
.text$mn:00001E5C
.text$mn:00001E5C var_4           = dword ptr -4
.text$mn:00001E5C Str             = dword ptr  8
.text$mn:00001E5C
.text$mn:00001E5C                 push    ebp
.text$mn:00001E5D                 mov     ebp, esp
.text$mn:00001E5F                 push    ecx
.text$mn:00001E60                 mov     [ebp+var_4], ecx
.text$mn:00001E63                 push    490h            ; unsigned int
.text$mn:00001E68                 push    offset ??_C@_1IO@FEAPGJBD@?$AAC?$AA?3?$AA?2?$AAP?$AAr?$AAo?$AAg?$AAr?$AAa?$AAm?$AA?5?$AAF?$AAi?$AAl?$AAe?$AAs?$AA?5?$AA?$CI?$AAx?$AA8?$AA6?$AA?$CJ?$AA?2?$AAM?$AAi?$AAc?$AAr?$AAo?$AAs?$AAo?$AAf?$AAt@ ; "C:\\Program Files (x86)\\Microsoft Visu"...
.text$mn:00001E6D                 mov     eax, [ebp+Str]
.text$mn:00001E70                 push    eax             ; int
.text$mn:00001E71                 call    ??$_Debug_pointer@_W@std@@YAXPB_W0I@Z ; std::_Debug_pointer<wchar_t>(wchar_t const *,wchar_t const *,uint)
.text$mn:00001E76                 add     esp, 0Ch
.text$mn:00001E79                 mov     ecx, [ebp+Str]
.text$mn:00001E7C                 push    ecx             ; Str
.text$mn:00001E7D                 call    ?length@?$char_traits@_W@std@@SAIPB_W@Z ; std::char_traits<wchar_t>::length(wchar_t const *)
.text$mn:00001E82                 add     esp, 4
.text$mn:00001E85                 push    eax             ; int
.text$mn:00001E86                 mov     edx, [ebp+Str]
.text$mn:00001E89                 push    edx             ; Src
.text$mn:00001E8A                 mov     ecx, [ebp+var_4]
.text$mn:00001E8D                 call    ?assign@?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QAEAAV12@PB_WI@Z ; std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>>::assign(wchar_t const *,uint)
.text$mn:00001E92                 mov     esp, ebp
.text$mn:00001E94                 pop     ebp
.text$mn:00001E95                 retn    4
.text$mn:00001E95 ?assign@?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QAEAAV12@PB_W@Z endp
.text$mn:00001E95
.text$mn:00001E95 _text$mn        ends
.text$mn:00001E95
.text$mn:00001E98 ; ===========================================================================
.text$mn:00001E98
.text$mn:00001E98 ; Segment type: Pure code
.text$mn:00001E98 ; Segment permissions: Read/Execute
.text$mn:00001E98 _text$mn        segment para public 'CODE' use32
.text$mn:00001E98                 assume cs:_text$mn
.text$mn:00001E98                 ;org 1E98h
.text$mn:00001E98 ; COMDAT (pick any)
.text$mn:00001E98                 assume es:nothing, ss:nothing, ds:_xdata$x, fs:nothing, gs:nothing
.text$mn:00001E98
.text$mn:00001E98 ; =============== S U B R O U T I N E =======================================
.text$mn:00001E98
.text$mn:00001E98 ; Attributes: bp-based frame
.text$mn:00001E98
.text$mn:00001E98 ; int __stdcall std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>>::assign(void *Src, int)
.text$mn:00001E98                 public ?assign@?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QAEAAV12@PB_WI@Z
.text$mn:00001E98 ?assign@?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QAEAAV12@PB_WI@Z proc near
.text$mn:00001E98                                         ; CODE XREF: std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>>::assign(wchar_t const *)+31p
.text$mn:00001E98
.text$mn:00001E98 var_4           = dword ptr -4
.text$mn:00001E98 Src             = dword ptr  8
.text$mn:00001E98 arg_4           = dword ptr  0Ch
.text$mn:00001E98
.text$mn:00001E98                 push    ebp
.text$mn:00001E99                 mov     ebp, esp
.text$mn:00001E9B                 push    ecx
.text$mn:00001E9C                 mov     [ebp+var_4], ecx
.text$mn:00001E9F                 cmp     [ebp+arg_4], 0
.text$mn:00001EA3                 jz      short loc_1EBB
.text$mn:00001EA5                 push    47Fh            ; unsigned int
.text$mn:00001EAA                 push    offset ??_C@_1IO@FEAPGJBD@?$AAC?$AA?3?$AA?2?$AAP?$AAr?$AAo?$AAg?$AAr?$AAa?$AAm?$AA?5?$AAF?$AAi?$AAl?$AAe?$AAs?$AA?5?$AA?$CI?$AAx?$AA8?$AA6?$AA?$CJ?$AA?2?$AAM?$AAi?$AAc?$AAr?$AAo?$AAs?$AAo?$AAf?$AAt@ ; "C:\\Program Files (x86)\\Microsoft Visu"...
.text$mn:00001EAF                 mov     eax, [ebp+Src]
.text$mn:00001EB2                 push    eax             ; int
.text$mn:00001EB3                 call    ??$_Debug_pointer@_W@std@@YAXPB_W0I@Z ; std::_Debug_pointer<wchar_t>(wchar_t const *,wchar_t const *,uint)
.text$mn:00001EB8                 add     esp, 0Ch
.text$mn:00001EBB
.text$mn:00001EBB loc_1EBB:                               ; CODE XREF: std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>>::assign(wchar_t const *,uint)+Bj
.text$mn:00001EBB                 mov     ecx, [ebp+Src]
.text$mn:00001EBE                 push    ecx
.text$mn:00001EBF                 mov     ecx, [ebp+var_4]
.text$mn:00001EC2                 call    ?_Inside@?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QAE_NPB_W@Z ; std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>>::_Inside(wchar_t const *)
.text$mn:00001EC7                 movzx   edx, al
.text$mn:00001ECA                 test    edx, edx
.text$mn:00001ECC                 jz      short loc_1EF0
.text$mn:00001ECE                 mov     eax, [ebp+arg_4]
.text$mn:00001ED1                 push    eax
.text$mn:00001ED2                 mov     ecx, [ebp+var_4]
.text$mn:00001ED5                 call    ?_Myptr@?$_String_val@U?$_Simple_types@_W@std@@@std@@QAEPA_WXZ ; std::_String_val<std::_Simple_types<wchar_t>>::_Myptr(void)
.text$mn:00001EDA                 mov     ecx, [ebp+Src]
.text$mn:00001EDD                 sub     ecx, eax
.text$mn:00001EDF                 sar     ecx, 1
.text$mn:00001EE1                 push    ecx
.text$mn:00001EE2                 mov     edx, [ebp+var_4]
.text$mn:00001EE5                 push    edx
.text$mn:00001EE6                 mov     ecx, [ebp+var_4]
.text$mn:00001EE9                 call    ?assign@?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QAEAAV12@ABV12@II@Z ; std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>>::assign(std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>> const &,uint,uint)
.text$mn:00001EEE                 jmp     short loc_1F2D
.text$mn:00001EF0 ; ---------------------------------------------------------------------------
.text$mn:00001EF0
.text$mn:00001EF0 loc_1EF0:                               ; CODE XREF: std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>>::assign(wchar_t const *,uint)+34j
.text$mn:00001EF0                 push    0
.text$mn:00001EF2                 mov     eax, [ebp+arg_4]
.text$mn:00001EF5                 push    eax
.text$mn:00001EF6                 mov     ecx, [ebp+var_4]
.text$mn:00001EF9                 call    ?_Grow@?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QAE_NI_N@Z ; std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>>::_Grow(uint,bool)
.text$mn:00001EFE                 movzx   ecx, al
.text$mn:00001F01                 test    ecx, ecx
.text$mn:00001F03                 jz      short loc_1F2A
.text$mn:00001F05                 mov     edx, [ebp+arg_4]
.text$mn:00001F08                 push    edx             ; int
.text$mn:00001F09                 mov     eax, [ebp+Src]
.text$mn:00001F0C                 push    eax             ; Src
.text$mn:00001F0D                 mov     ecx, [ebp+var_4]
.text$mn:00001F10                 call    ?_Myptr@?$_String_val@U?$_Simple_types@_W@std@@@std@@QAEPA_WXZ ; std::_String_val<std::_Simple_types<wchar_t>>::_Myptr(void)
.text$mn:00001F15                 push    eax             ; Dst
.text$mn:00001F16                 call    ?copy@?$char_traits@_W@std@@SAPA_WPA_WPB_WI@Z ; std::char_traits<wchar_t>::copy(wchar_t *,wchar_t const *,uint)
.text$mn:00001F1B                 add     esp, 0Ch
.text$mn:00001F1E                 mov     ecx, [ebp+arg_4]
.text$mn:00001F21                 push    ecx
.text$mn:00001F22                 mov     ecx, [ebp+var_4]
.text$mn:00001F25                 call    ?_Eos@?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QAEXI@Z ; std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>>::_Eos(uint)
.text$mn:00001F2A
.text$mn:00001F2A loc_1F2A:                               ; CODE XREF: std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>>::assign(wchar_t const *,uint)+6Bj
.text$mn:00001F2A                 mov     eax, [ebp+var_4]
.text$mn:00001F2D
.text$mn:00001F2D loc_1F2D:                               ; CODE XREF: std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>>::assign(wchar_t const *,uint)+56j
.text$mn:00001F2D                 mov     esp, ebp
.text$mn:00001F2F                 pop     ebp
.text$mn:00001F30                 retn    8
.text$mn:00001F30 ?assign@?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QAEAAV12@PB_WI@Z endp
.text$mn:00001F30
.text$mn:00001F30 ; ---------------------------------------------------------------------------
.text$mn:00001F33                 align 4
.text$mn:00001F33 _text$mn        ends
.text$mn:00001F33
.text$mn:00001F34 ; ===========================================================================
.text$mn:00001F34
.text$mn:00001F34 ; Segment type: Pure code
.text$mn:00001F34 ; Segment permissions: Read/Execute
.text$mn:00001F34 _text$mn        segment para public 'CODE' use32
.text$mn:00001F34                 assume cs:_text$mn
.text$mn:00001F34                 ;org 1F34h
.text$mn:00001F34 ; COMDAT (pick any)
.text$mn:00001F34                 assume es:nothing, ss:nothing, ds:_xdata$x, fs:nothing, gs:nothing
.text$mn:00001F34
.text$mn:00001F34 ; =============== S U B R O U T I N E =======================================
.text$mn:00001F34
.text$mn:00001F34 ; Attributes: bp-based frame
.text$mn:00001F34
.text$mn:00001F34 ; public: static void __cdecl std::char_traits<char>::assign(char &, char const &)
.text$mn:00001F34                 public ?assign@?$char_traits@D@std@@SAXAADABD@Z
.text$mn:00001F34 ?assign@?$char_traits@D@std@@SAXAADABD@Z proc near
.text$mn:00001F34                                         ; CODE XREF: std::basic_string<char,std::char_traits<char>,std::allocator<char>>::_Eos(uint)+26p
.text$mn:00001F34
.text$mn:00001F34 arg_0           = dword ptr  8
.text$mn:00001F34 arg_4           = dword ptr  0Ch
.text$mn:00001F34
.text$mn:00001F34                 push    ebp
.text$mn:00001F35                 mov     ebp, esp
.text$mn:00001F37                 mov     eax, [ebp+arg_0]
.text$mn:00001F3A                 mov     ecx, [ebp+arg_4]
.text$mn:00001F3D                 mov     dl, [ecx]
.text$mn:00001F3F                 mov     [eax], dl
.text$mn:00001F41                 pop     ebp
.text$mn:00001F42                 retn
.text$mn:00001F42 ?assign@?$char_traits@D@std@@SAXAADABD@Z endp
.text$mn:00001F42
.text$mn:00001F42 ; ---------------------------------------------------------------------------
.text$mn:00001F43                 align 4
.text$mn:00001F43 _text$mn        ends
.text$mn:00001F43
.text$mn:00001F44 ; ===========================================================================
.text$mn:00001F44
.text$mn:00001F44 ; Segment type: Pure code
.text$mn:00001F44 ; Segment permissions: Read/Execute
.text$mn:00001F44 _text$mn        segment para public 'CODE' use32
.text$mn:00001F44                 assume cs:_text$mn
.text$mn:00001F44                 ;org 1F44h
.text$mn:00001F44 ; COMDAT (pick any)
.text$mn:00001F44                 assume es:nothing, ss:nothing, ds:_xdata$x, fs:nothing, gs:nothing
.text$mn:00001F44
.text$mn:00001F44 ; =============== S U B R O U T I N E =======================================
.text$mn:00001F44
.text$mn:00001F44 ; Attributes: bp-based frame
.text$mn:00001F44
.text$mn:00001F44 ; public: static void __cdecl std::char_traits<wchar_t>::assign(wchar_t &, wchar_t const &)
.text$mn:00001F44                 public ?assign@?$char_traits@_W@std@@SAXAA_WAB_W@Z
.text$mn:00001F44 ?assign@?$char_traits@_W@std@@SAXAA_WAB_W@Z proc near
.text$mn:00001F44                                         ; CODE XREF: std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>>::_Eos(uint)+2Bp
.text$mn:00001F44
.text$mn:00001F44 arg_0           = dword ptr  8
.text$mn:00001F44 arg_4           = dword ptr  0Ch
.text$mn:00001F44
.text$mn:00001F44                 push    ebp
.text$mn:00001F45                 mov     ebp, esp
.text$mn:00001F47                 mov     eax, [ebp+arg_0]
.text$mn:00001F4A                 mov     ecx, [ebp+arg_4]
.text$mn:00001F4D                 mov     dx, [ecx]
.text$mn:00001F50                 mov     [eax], dx
.text$mn:00001F53                 pop     ebp
.text$mn:00001F54                 retn
.text$mn:00001F54 ?assign@?$char_traits@_W@std@@SAXAA_WAB_W@Z endp
.text$mn:00001F54
.text$mn:00001F54 ; ---------------------------------------------------------------------------
.text$mn:00001F55                 align 4
.text$mn:00001F55 _text$mn        ends
.text$mn:00001F55
.text$mn:00001F58 ; ===========================================================================
.text$mn:00001F58
.text$mn:00001F58 ; Segment type: Pure code
.text$mn:00001F58 ; Segment permissions: Read/Execute
.text$mn:00001F58 _text$mn        segment para public 'CODE' use32
.text$mn:00001F58                 assume cs:_text$mn
.text$mn:00001F58                 ;org 1F58h
.text$mn:00001F58 ; COMDAT (pick any)
.text$mn:00001F58                 assume es:nothing, ss:nothing, ds:_xdata$x, fs:nothing, gs:nothing
.text$mn:00001F58
.text$mn:00001F58 ; =============== S U B R O U T I N E =======================================
.text$mn:00001F58
.text$mn:00001F58 ; Attributes: bp-based frame
.text$mn:00001F58
.text$mn:00001F58 ; public: wchar_t const * __thiscall std::basic_string<wchar_t, struct std::char_traits<wchar_t>, class std::allocator<wchar_t>>::c_str(void)const
.text$mn:00001F58                 public ?c_str@?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QBEPB_WXZ
.text$mn:00001F58 ?c_str@?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QBEPB_WXZ proc near
.text$mn:00001F58                                         ; CODE XREF: ValueDlg::run_dlgProc(uint,uint,long)+37p
.text$mn:00001F58
.text$mn:00001F58 var_4           = dword ptr -4
.text$mn:00001F58
.text$mn:00001F58                 push    ebp
.text$mn:00001F59                 mov     ebp, esp
.text$mn:00001F5B                 push    ecx
.text$mn:00001F5C                 mov     [ebp+var_4], ecx
.text$mn:00001F5F                 mov     ecx, [ebp+var_4]
.text$mn:00001F62                 call    ?_Myptr@?$_String_val@U?$_Simple_types@_W@std@@@std@@QBEPB_WXZ ; std::_String_val<std::_Simple_types<wchar_t>>::_Myptr(void)
.text$mn:00001F67                 mov     esp, ebp
.text$mn:00001F69                 pop     ebp
.text$mn:00001F6A                 retn
.text$mn:00001F6A ?c_str@?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QBEPB_WXZ endp
.text$mn:00001F6A
.text$mn:00001F6A ; ---------------------------------------------------------------------------
.text$mn:00001F6B                 align 4
.text$mn:00001F6B _text$mn        ends
.text$mn:00001F6B
.text$mn:00001F6C ; ===========================================================================
.text$mn:00001F6C
.text$mn:00001F6C ; Segment type: Pure code
.text$mn:00001F6C ; Segment permissions: Read/Execute
.text$mn:00001F6C _text$mn        segment para public 'CODE' use32
.text$mn:00001F6C                 assume cs:_text$mn
.text$mn:00001F6C                 ;org 1F6Ch
.text$mn:00001F6C ; COMDAT (pick any)
.text$mn:00001F6C                 assume es:nothing, ss:nothing, ds:_xdata$x, fs:nothing, gs:nothing
.text$mn:00001F6C
.text$mn:00001F6C ; =============== S U B R O U T I N E =======================================
.text$mn:00001F6C
.text$mn:00001F6C ; Attributes: bp-based frame
.text$mn:00001F6C
.text$mn:00001F6C ; const struct std::error_category *__thiscall std::error_code::category(std::error_code *__hidden this)
.text$mn:00001F6C                 public ?category@error_code@std@@QBEABVerror_category@2@XZ
.text$mn:00001F6C ?category@error_code@std@@QBEABVerror_category@2@XZ proc near
.text$mn:00001F6C                                         ; CODE XREF: std::error_category::equivalent(std::error_code const &,int)+Cp
.text$mn:00001F6C
.text$mn:00001F6C var_4           = dword ptr -4
.text$mn:00001F6C
.text$mn:00001F6C                 push    ebp
.text$mn:00001F6D                 mov     ebp, esp
.text$mn:00001F6F                 push    ecx
.text$mn:00001F70                 mov     [ebp+var_4], ecx
.text$mn:00001F73                 mov     eax, [ebp+var_4]
.text$mn:00001F76                 mov     eax, [eax+4]
.text$mn:00001F79                 mov     esp, ebp
.text$mn:00001F7B                 pop     ebp
.text$mn:00001F7C                 retn
.text$mn:00001F7C ?category@error_code@std@@QBEABVerror_category@2@XZ endp
.text$mn:00001F7C
.text$mn:00001F7C ; ---------------------------------------------------------------------------
.text$mn:00001F7D                 align 10h
.text$mn:00001F7D _text$mn        ends
.text$mn:00001F7D
.text$mn:00001F80 ; ===========================================================================
.text$mn:00001F80
.text$mn:00001F80 ; Segment type: Pure code
.text$mn:00001F80 ; Segment permissions: Read/Execute
.text$mn:00001F80 _text$mn        segment para public 'CODE' use32
.text$mn:00001F80                 assume cs:_text$mn
.text$mn:00001F80                 ;org 1F80h
.text$mn:00001F80 ; COMDAT (pick any)
.text$mn:00001F80                 assume es:nothing, ss:nothing, ds:_xdata$x, fs:nothing, gs:nothing
.text$mn:00001F80
.text$mn:00001F80 ; =============== S U B R O U T I N E =======================================
.text$mn:00001F80
.text$mn:00001F80 ; Attributes: bp-based frame
.text$mn:00001F80
.text$mn:00001F80 ; const struct std::error_category *__thiscall std::error_condition::category(std::error_condition *__hidden this)
.text$mn:00001F80                 public ?category@error_condition@std@@QBEABVerror_category@2@XZ
.text$mn:00001F80 ?category@error_condition@std@@QBEABVerror_category@2@XZ proc near
.text$mn:00001F80                                         ; CODE XREF: std::error_condition::operator==(std::error_condition const &)+Dp
.text$mn:00001F80                                         ; std::error_condition::operator==(std::error_condition const &)+16p
.text$mn:00001F80
.text$mn:00001F80 var_4           = dword ptr -4
.text$mn:00001F80
.text$mn:00001F80                 push    ebp
.text$mn:00001F81                 mov     ebp, esp
.text$mn:00001F83                 push    ecx
.text$mn:00001F84                 mov     [ebp+var_4], ecx
.text$mn:00001F87                 mov     eax, [ebp+var_4]
.text$mn:00001F8A                 mov     eax, [eax+4]
.text$mn:00001F8D                 mov     esp, ebp
.text$mn:00001F8F                 pop     ebp
.text$mn:00001F90                 retn
.text$mn:00001F90 ?category@error_condition@std@@QBEABVerror_category@2@XZ endp
.text$mn:00001F90
.text$mn:00001F90 ; ---------------------------------------------------------------------------
.text$mn:00001F91                 align 4
.text$mn:00001F91 _text$mn        ends
.text$mn:00001F91
.text$mn:00001F94 ; ===========================================================================
.text$mn:00001F94
.text$mn:00001F94 ; Segment type: Pure code
.text$mn:00001F94 ; Segment permissions: Read/Execute
.text$mn:00001F94 _text$mn        segment para public 'CODE' use32
.text$mn:00001F94                 assume cs:_text$mn
.text$mn:00001F94                 ;org 1F94h
.text$mn:00001F94 ; COMDAT (pick any)
.text$mn:00001F94                 assume es:nothing, ss:nothing, ds:_xdata$x, fs:nothing, gs:nothing
.text$mn:00001F94
.text$mn:00001F94 ; =============== S U B R O U T I N E =======================================
.text$mn:00001F94
.text$mn:00001F94 ; Attributes: bp-based frame
.text$mn:00001F94
.text$mn:00001F94 ; int __cdecl std::char_traits<char>::copy(void *Dst, void *Src, size_t Size)
.text$mn:00001F94                 public ?copy@?$char_traits@D@std@@SAPADPADPBDI@Z
.text$mn:00001F94 ?copy@?$char_traits@D@std@@SAPADPADPBDI@Z proc near ; CODE XREF: $LN19+1Ep
.text$mn:00001F94                                         ; std::basic_string<char,std::char_traits<char>,std::allocator<char>>::_Tidy(bool,uint)+5Dp ...
.text$mn:00001F94
.text$mn:00001F94 var_4           = dword ptr -4
.text$mn:00001F94 Dst             = dword ptr  8
.text$mn:00001F94 Src             = dword ptr  0Ch
.text$mn:00001F94 Size            = dword ptr  10h
.text$mn:00001F94
.text$mn:00001F94                 push    ebp
.text$mn:00001F95                 mov     ebp, esp
.text$mn:00001F97                 push    ecx
.text$mn:00001F98                 cmp     [ebp+Size], 0
.text$mn:00001F9C                 jnz     short loc_1FA6
.text$mn:00001F9E                 mov     eax, [ebp+Dst]
.text$mn:00001FA1                 mov     [ebp+var_4], eax
.text$mn:00001FA4                 jmp     short loc_1FBD
.text$mn:00001FA6 ; ---------------------------------------------------------------------------
.text$mn:00001FA6
.text$mn:00001FA6 loc_1FA6:                               ; CODE XREF: std::char_traits<char>::copy(char *,char const *,uint)+8j
.text$mn:00001FA6                 mov     ecx, [ebp+Size]
.text$mn:00001FA9                 push    ecx             ; Size
.text$mn:00001FAA                 mov     edx, [ebp+Src]
.text$mn:00001FAD                 push    edx             ; Src
.text$mn:00001FAE                 mov     eax, [ebp+Dst]
.text$mn:00001FB1                 push    eax             ; Dst
.text$mn:00001FB2                 call    _memcpy
.text$mn:00001FB7                 add     esp, 0Ch
.text$mn:00001FBA                 mov     [ebp+var_4], eax
.text$mn:00001FBD
.text$mn:00001FBD loc_1FBD:                               ; CODE XREF: std::char_traits<char>::copy(char *,char const *,uint)+10j
.text$mn:00001FBD                 mov     eax, [ebp+var_4]
.text$mn:00001FC0                 mov     esp, ebp
.text$mn:00001FC2                 pop     ebp
.text$mn:00001FC3                 retn
.text$mn:00001FC3 ?copy@?$char_traits@D@std@@SAPADPADPBDI@Z endp
.text$mn:00001FC3
.text$mn:00001FC3 _text$mn        ends
.text$mn:00001FC3
.text$mn:00001FC4 ; ===========================================================================
.text$mn:00001FC4
.text$mn:00001FC4 ; Segment type: Pure code
.text$mn:00001FC4 ; Segment permissions: Read/Execute
.text$mn:00001FC4 _text$mn        segment para public 'CODE' use32
.text$mn:00001FC4                 assume cs:_text$mn
.text$mn:00001FC4                 ;org 1FC4h
.text$mn:00001FC4 ; COMDAT (pick any)
.text$mn:00001FC4                 assume es:nothing, ss:nothing, ds:_xdata$x, fs:nothing, gs:nothing
.text$mn:00001FC4
.text$mn:00001FC4 ; =============== S U B R O U T I N E =======================================
.text$mn:00001FC4
.text$mn:00001FC4 ; Attributes: bp-based frame
.text$mn:00001FC4
.text$mn:00001FC4 ; int __cdecl std::char_traits<wchar_t>::copy(void *Dst, void *Src, int)
.text$mn:00001FC4                 public ?copy@?$char_traits@_W@std@@SAPA_WPA_WPB_WI@Z
.text$mn:00001FC4 ?copy@?$char_traits@_W@std@@SAPA_WPA_WPB_WI@Z proc near
.text$mn:00001FC4                                         ; CODE XREF: $LN19_0+1Ep
.text$mn:00001FC4                                         ; std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>>::_Tidy(bool,uint)+5Dp ...
.text$mn:00001FC4
.text$mn:00001FC4 var_4           = dword ptr -4
.text$mn:00001FC4 Dst             = dword ptr  8
.text$mn:00001FC4 Src             = dword ptr  0Ch
.text$mn:00001FC4 arg_8           = dword ptr  10h
.text$mn:00001FC4
.text$mn:00001FC4                 push    ebp
.text$mn:00001FC5                 mov     ebp, esp
.text$mn:00001FC7                 push    ecx
.text$mn:00001FC8                 cmp     [ebp+arg_8], 0
.text$mn:00001FCC                 jnz     short loc_1FD6
.text$mn:00001FCE                 mov     eax, [ebp+Dst]
.text$mn:00001FD1                 mov     [ebp+var_4], eax
.text$mn:00001FD4                 jmp     short loc_1FED
.text$mn:00001FD6 ; ---------------------------------------------------------------------------
.text$mn:00001FD6
.text$mn:00001FD6 loc_1FD6:                               ; CODE XREF: std::char_traits<wchar_t>::copy(wchar_t *,wchar_t const *,uint)+8j
.text$mn:00001FD6                 mov     ecx, [ebp+arg_8]
.text$mn:00001FD9                 push    ecx             ; int
.text$mn:00001FDA                 mov     edx, [ebp+Src]
.text$mn:00001FDD                 push    edx             ; Src
.text$mn:00001FDE                 mov     eax, [ebp+Dst]
.text$mn:00001FE1                 push    eax             ; Dst
.text$mn:00001FE2                 call    _wmemcpy
.text$mn:00001FE7                 add     esp, 0Ch
.text$mn:00001FEA                 mov     [ebp+var_4], eax
.text$mn:00001FED
.text$mn:00001FED loc_1FED:                               ; CODE XREF: std::char_traits<wchar_t>::copy(wchar_t *,wchar_t const *,uint)+10j
.text$mn:00001FED                 mov     eax, [ebp+var_4]
.text$mn:00001FF0                 mov     esp, ebp
.text$mn:00001FF2                 pop     ebp
.text$mn:00001FF3                 retn
.text$mn:00001FF3 ?copy@?$char_traits@_W@std@@SAPA_WPA_WPB_WI@Z endp
.text$mn:00001FF3
.text$mn:00001FF3 _text$mn        ends
.text$mn:00001FF3
.text$mn:00001FF4 ; ===========================================================================
.text$mn:00001FF4
.text$mn:00001FF4 ; Segment type: Pure code
.text$mn:00001FF4 ; Segment permissions: Read/Execute
.text$mn:00001FF4 _text$mn        segment para public 'CODE' use32
.text$mn:00001FF4                 assume cs:_text$mn
.text$mn:00001FF4                 ;org 1FF4h
.text$mn:00001FF4 ; COMDAT (pick any)
.text$mn:00001FF4                 assume es:nothing, ss:nothing, ds:_xdata$x, fs:nothing, gs:nothing
.text$mn:00001FF4
.text$mn:00001FF4 ; =============== S U B R O U T I N E =======================================
.text$mn:00001FF4
.text$mn:00001FF4 ; Attributes: bp-based frame
.text$mn:00001FF4
.text$mn:00001FF4 ; int __stdcall std::_Wrap_alloc<std::allocator<char>>::deallocate(void *, int)
.text$mn:00001FF4                 public ?deallocate@?$_Wrap_alloc@V?$allocator@D@std@@@std@@QAEXPADI@Z
.text$mn:00001FF4 ?deallocate@?$_Wrap_alloc@V?$allocator@D@std@@@std@@QAEXPADI@Z proc near
.text$mn:00001FF4                                         ; CODE XREF: std::basic_string<char,std::char_traits<char>,std::allocator<char>>::_Tidy(bool,uint)+81p
.text$mn:00001FF4
.text$mn:00001FF4 var_4           = dword ptr -4
.text$mn:00001FF4 arg_0           = dword ptr  8
.text$mn:00001FF4 arg_4           = dword ptr  0Ch
.text$mn:00001FF4
.text$mn:00001FF4                 push    ebp
.text$mn:00001FF5                 mov     ebp, esp
.text$mn:00001FF7                 push    ecx
.text$mn:00001FF8                 mov     [ebp+var_4], ecx
.text$mn:00001FFB                 mov     eax, [ebp+arg_4]
.text$mn:00001FFE                 push    eax             ; int
.text$mn:00001FFF                 mov     ecx, [ebp+arg_0]
.text$mn:00002002                 push    ecx             ; void *
.text$mn:00002003                 mov     ecx, [ebp+var_4]
.text$mn:00002006                 call    ?deallocate@?$allocator@D@std@@QAEXPADI@Z ; std::allocator<char>::deallocate(char *,uint)
.text$mn:0000200B                 mov     esp, ebp
.text$mn:0000200D                 pop     ebp
.text$mn:0000200E                 retn    8
.text$mn:0000200E ?deallocate@?$_Wrap_alloc@V?$allocator@D@std@@@std@@QAEXPADI@Z endp
.text$mn:0000200E
.text$mn:0000200E ; ---------------------------------------------------------------------------
.text$mn:00002011                 align 4
.text$mn:00002011 _text$mn        ends
.text$mn:00002011
.text$mn:00002014 ; ===========================================================================
.text$mn:00002014
.text$mn:00002014 ; Segment type: Pure code
.text$mn:00002014 ; Segment permissions: Read/Execute
.text$mn:00002014 _text$mn        segment para public 'CODE' use32
.text$mn:00002014                 assume cs:_text$mn
.text$mn:00002014                 ;org 2014h
.text$mn:00002014 ; COMDAT (pick any)
.text$mn:00002014                 assume es:nothing, ss:nothing, ds:_xdata$x, fs:nothing, gs:nothing
.text$mn:00002014
.text$mn:00002014 ; =============== S U B R O U T I N E =======================================
.text$mn:00002014
.text$mn:00002014 ; Attributes: bp-based frame
.text$mn:00002014
.text$mn:00002014 ; int __stdcall std::_Wrap_alloc<std::allocator<wchar_t>>::deallocate(void *, int)
.text$mn:00002014                 public ?deallocate@?$_Wrap_alloc@V?$allocator@_W@std@@@std@@QAEXPA_WI@Z
.text$mn:00002014 ?deallocate@?$_Wrap_alloc@V?$allocator@_W@std@@@std@@QAEXPA_WI@Z proc near
.text$mn:00002014                                         ; CODE XREF: std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>>::_Tidy(bool,uint)+81p
.text$mn:00002014
.text$mn:00002014 var_4           = dword ptr -4
.text$mn:00002014 arg_0           = dword ptr  8
.text$mn:00002014 arg_4           = dword ptr  0Ch
.text$mn:00002014
.text$mn:00002014                 push    ebp
.text$mn:00002015                 mov     ebp, esp
.text$mn:00002017                 push    ecx
.text$mn:00002018                 mov     [ebp+var_4], ecx
.text$mn:0000201B                 mov     eax, [ebp+arg_4]
.text$mn:0000201E                 push    eax             ; int
.text$mn:0000201F                 mov     ecx, [ebp+arg_0]
.text$mn:00002022                 push    ecx             ; void *
.text$mn:00002023                 mov     ecx, [ebp+var_4]
.text$mn:00002026                 call    ?deallocate@?$allocator@_W@std@@QAEXPA_WI@Z ; std::allocator<wchar_t>::deallocate(wchar_t *,uint)
.text$mn:0000202B                 mov     esp, ebp
.text$mn:0000202D                 pop     ebp
.text$mn:0000202E                 retn    8
.text$mn:0000202E ?deallocate@?$_Wrap_alloc@V?$allocator@_W@std@@@std@@QAEXPA_WI@Z endp
.text$mn:0000202E
.text$mn:0000202E ; ---------------------------------------------------------------------------
.text$mn:00002031                 align 4
.text$mn:00002031 _text$mn        ends
.text$mn:00002031
.text$mn:00002034 ; ===========================================================================
.text$mn:00002034
.text$mn:00002034 ; Segment type: Pure code
.text$mn:00002034 ; Segment permissions: Read/Execute
.text$mn:00002034 _text$mn        segment para public 'CODE' use32
.text$mn:00002034                 assume cs:_text$mn
.text$mn:00002034                 ;org 2034h
.text$mn:00002034 ; COMDAT (pick any)
.text$mn:00002034                 assume es:nothing, ss:nothing, ds:_xdata$x, fs:nothing, gs:nothing
.text$mn:00002034
.text$mn:00002034 ; =============== S U B R O U T I N E =======================================
.text$mn:00002034
.text$mn:00002034 ; Attributes: bp-based frame
.text$mn:00002034
.text$mn:00002034 ; int __stdcall std::allocator<char>::deallocate(void *, int)
.text$mn:00002034                 public ?deallocate@?$allocator@D@std@@QAEXPADI@Z
.text$mn:00002034 ?deallocate@?$allocator@D@std@@QAEXPADI@Z proc near
.text$mn:00002034                                         ; CODE XREF: std::_Wrap_alloc<std::allocator<char>>::deallocate(char *,uint)+12p
.text$mn:00002034
.text$mn:00002034 var_4           = dword ptr -4
.text$mn:00002034 arg_0           = dword ptr  8
.text$mn:00002034
.text$mn:00002034                 push    ebp
.text$mn:00002035                 mov     ebp, esp
.text$mn:00002037                 push    ecx
.text$mn:00002038                 mov     [ebp+var_4], ecx
.text$mn:0000203B                 mov     eax, [ebp+arg_0]
.text$mn:0000203E                 push    eax             ; void *
.text$mn:0000203F                 call    ??3@YAXPAX@Z    ; operator delete(void *)
.text$mn:00002044                 add     esp, 4
.text$mn:00002047                 mov     esp, ebp
.text$mn:00002049                 pop     ebp
.text$mn:0000204A                 retn    8
.text$mn:0000204A ?deallocate@?$allocator@D@std@@QAEXPADI@Z endp
.text$mn:0000204A
.text$mn:0000204A ; ---------------------------------------------------------------------------
.text$mn:0000204D                 align 10h
.text$mn:0000204D _text$mn        ends
.text$mn:0000204D
.text$mn:00002050 ; ===========================================================================
.text$mn:00002050
.text$mn:00002050 ; Segment type: Pure code
.text$mn:00002050 ; Segment permissions: Read/Execute
.text$mn:00002050 _text$mn        segment para public 'CODE' use32
.text$mn:00002050                 assume cs:_text$mn
.text$mn:00002050                 ;org 2050h
.text$mn:00002050 ; COMDAT (pick any)
.text$mn:00002050                 assume es:nothing, ss:nothing, ds:_xdata$x, fs:nothing, gs:nothing
.text$mn:00002050
.text$mn:00002050 ; =============== S U B R O U T I N E =======================================
.text$mn:00002050
.text$mn:00002050 ; Attributes: bp-based frame
.text$mn:00002050
.text$mn:00002050 ; int __stdcall std::allocator<std::_Container_proxy>::deallocate(void *, int)
.text$mn:00002050                 public ?deallocate@?$allocator@U_Container_proxy@std@@@std@@QAEXPAU_Container_proxy@2@I@Z
.text$mn:00002050 ?deallocate@?$allocator@U_Container_proxy@std@@@std@@QAEXPAU_Container_proxy@2@I@Z proc near
.text$mn:00002050                                         ; CODE XREF: std::_String_alloc<0,std::_String_base_types<char,std::allocator<char>>>::_Free_proxy(void)+32p
.text$mn:00002050
.text$mn:00002050 var_4           = dword ptr -4
.text$mn:00002050 arg_0           = dword ptr  8
.text$mn:00002050
.text$mn:00002050                 push    ebp
.text$mn:00002051                 mov     ebp, esp
.text$mn:00002053                 push    ecx
.text$mn:00002054                 mov     [ebp+var_4], ecx
.text$mn:00002057                 mov     eax, [ebp+arg_0]
.text$mn:0000205A                 push    eax             ; void *
.text$mn:0000205B                 call    ??3@YAXPAX@Z    ; operator delete(void *)
.text$mn:00002060                 add     esp, 4
.text$mn:00002063                 mov     esp, ebp
.text$mn:00002065                 pop     ebp
.text$mn:00002066                 retn    8
.text$mn:00002066 ?deallocate@?$allocator@U_Container_proxy@std@@@std@@QAEXPAU_Container_proxy@2@I@Z endp
.text$mn:00002066
.text$mn:00002066 ; ---------------------------------------------------------------------------
.text$mn:00002069                 align 4
.text$mn:00002069 _text$mn        ends
.text$mn:00002069
.text$mn:0000206C ; ===========================================================================
.text$mn:0000206C
.text$mn:0000206C ; Segment type: Pure code
.text$mn:0000206C ; Segment permissions: Read/Execute
.text$mn:0000206C _text$mn        segment para public 'CODE' use32
.text$mn:0000206C                 assume cs:_text$mn
.text$mn:0000206C                 ;org 206Ch
.text$mn:0000206C ; COMDAT (pick any)
.text$mn:0000206C                 assume es:nothing, ss:nothing, ds:_xdata$x, fs:nothing, gs:nothing
.text$mn:0000206C
.text$mn:0000206C ; =============== S U B R O U T I N E =======================================
.text$mn:0000206C
.text$mn:0000206C ; Attributes: bp-based frame
.text$mn:0000206C
.text$mn:0000206C ; int __stdcall std::allocator<wchar_t>::deallocate(void *, int)
.text$mn:0000206C                 public ?deallocate@?$allocator@_W@std@@QAEXPA_WI@Z
.text$mn:0000206C ?deallocate@?$allocator@_W@std@@QAEXPA_WI@Z proc near
.text$mn:0000206C                                         ; CODE XREF: std::_Wrap_alloc<std::allocator<wchar_t>>::deallocate(wchar_t *,uint)+12p
.text$mn:0000206C
.text$mn:0000206C var_4           = dword ptr -4
.text$mn:0000206C arg_0           = dword ptr  8
.text$mn:0000206C
.text$mn:0000206C                 push    ebp
.text$mn:0000206D                 mov     ebp, esp
.text$mn:0000206F                 push    ecx
.text$mn:00002070                 mov     [ebp+var_4], ecx
.text$mn:00002073                 mov     eax, [ebp+arg_0]
.text$mn:00002076                 push    eax             ; void *
.text$mn:00002077                 call    ??3@YAXPAX@Z    ; operator delete(void *)
.text$mn:0000207C                 add     esp, 4
.text$mn:0000207F                 mov     esp, ebp
.text$mn:00002081                 pop     ebp
.text$mn:00002082                 retn    8
.text$mn:00002082 ?deallocate@?$allocator@_W@std@@QAEXPA_WI@Z endp
.text$mn:00002082
.text$mn:00002082 ; ---------------------------------------------------------------------------
.text$mn:00002085                 align 4
.text$mn:00002085 _text$mn        ends
.text$mn:00002085
.text$mn:00002088 ; ===========================================================================
.text$mn:00002088
.text$mn:00002088 ; Segment type: Pure code
.text$mn:00002088 ; Segment permissions: Read/Execute
.text$mn:00002088 _text$mn        segment para public 'CODE' use32
.text$mn:00002088                 assume cs:_text$mn
.text$mn:00002088                 ;org 2088h
.text$mn:00002088 ; COMDAT (pick any)
.text$mn:00002088                 assume es:nothing, ss:nothing, ds:_xdata$x, fs:nothing, gs:nothing
.text$mn:00002088
.text$mn:00002088 ; =============== S U B R O U T I N E =======================================
.text$mn:00002088
.text$mn:00002088 ; Attributes: bp-based frame
.text$mn:00002088
.text$mn:00002088 ; public: virtual class std::error_condition __thiscall std::_System_error_category::default_error_condition(int)const
.text$mn:00002088                 public ?default_error_condition@_System_error_category@std@@UBE?AVerror_condition@2@H@Z
.text$mn:00002088 ?default_error_condition@_System_error_category@std@@UBE?AVerror_condition@2@H@Z proc near
.text$mn:00002088                                         ; DATA XREF: .rdata:00002CECo
.text$mn:00002088
.text$mn:00002088 var_4           = dword ptr -4
.text$mn:00002088 arg_0           = dword ptr  8
.text$mn:00002088 arg_4           = dword ptr  0Ch
.text$mn:00002088
.text$mn:00002088                 push    ebp
.text$mn:00002089                 mov     ebp, esp
.text$mn:0000208B                 push    ecx
.text$mn:0000208C                 mov     [ebp+var_4], ecx
.text$mn:0000208F                 mov     eax, [ebp+arg_4]
.text$mn:00002092                 push    eax             ; int
.text$mn:00002093                 call    ?_Syserror_map@std@@YAPBDH@Z ; std::_Syserror_map(int)
.text$mn:00002098                 add     esp, 4
.text$mn:0000209B                 test    eax, eax
.text$mn:0000209D                 jz      short loc_20B8
.text$mn:0000209F                 call    ?generic_category@std@@YAABVerror_category@1@XZ ; std::generic_category(void)
.text$mn:000020A4                 push    eax             ; struct std::error_category *
.text$mn:000020A5                 mov     ecx, [ebp+arg_4]
.text$mn:000020A8                 push    ecx             ; int
.text$mn:000020A9                 mov     ecx, [ebp+arg_0] ; this
.text$mn:000020AC                 call    ??0error_condition@std@@QAE@HABVerror_category@1@@Z ; std::error_condition::error_condition(int,std::error_category const &)
.text$mn:000020B1                 mov     eax, [ebp+arg_0]
.text$mn:000020B4                 jmp     short loc_20CD
.text$mn:000020B6 ; ---------------------------------------------------------------------------
.text$mn:000020B6                 jmp     short loc_20CD
.text$mn:000020B8 ; ---------------------------------------------------------------------------
.text$mn:000020B8
.text$mn:000020B8 loc_20B8:                               ; CODE XREF: std::_System_error_category::default_error_condition(int)+15j
.text$mn:000020B8                 call    ?system_category@std@@YAABVerror_category@1@XZ ; std::system_category(void)
.text$mn:000020BD                 push    eax             ; struct std::error_category *
.text$mn:000020BE                 mov     edx, [ebp+arg_4]
.text$mn:000020C1                 push    edx             ; int
.text$mn:000020C2                 mov     ecx, [ebp+arg_0] ; this
.text$mn:000020C5                 call    ??0error_condition@std@@QAE@HABVerror_category@1@@Z ; std::error_condition::error_condition(int,std::error_category const &)
.text$mn:000020CA                 mov     eax, [ebp+arg_0]
.text$mn:000020CD
.text$mn:000020CD loc_20CD:                               ; CODE XREF: std::_System_error_category::default_error_condition(int)+2Cj
.text$mn:000020CD                                         ; std::_System_error_category::default_error_condition(int)+2Ej
.text$mn:000020CD                 mov     esp, ebp
.text$mn:000020CF                 pop     ebp
.text$mn:000020D0                 retn    8
.text$mn:000020D0 ?default_error_condition@_System_error_category@std@@UBE?AVerror_condition@2@H@Z endp
.text$mn:000020D0
.text$mn:000020D0 ; ---------------------------------------------------------------------------
.text$mn:000020D3                 align 4
.text$mn:000020D3 _text$mn        ends
.text$mn:000020D3
.text$mn:000020D4 ; ===========================================================================
.text$mn:000020D4
.text$mn:000020D4 ; Segment type: Pure code
.text$mn:000020D4 ; Segment permissions: Read/Execute
.text$mn:000020D4 _text$mn        segment para public 'CODE' use32
.text$mn:000020D4                 assume cs:_text$mn
.text$mn:000020D4                 ;org 20D4h
.text$mn:000020D4 ; COMDAT (pick any)
.text$mn:000020D4                 assume es:nothing, ss:nothing, ds:_xdata$x, fs:nothing, gs:nothing
.text$mn:000020D4
.text$mn:000020D4 ; =============== S U B R O U T I N E =======================================
.text$mn:000020D4
.text$mn:000020D4 ; Attributes: bp-based frame
.text$mn:000020D4
.text$mn:000020D4 ; public: virtual class std::error_condition __thiscall std::error_category::default_error_condition(int)const
.text$mn:000020D4                 public ?default_error_condition@error_category@std@@UBE?AVerror_condition@2@H@Z
.text$mn:000020D4 ?default_error_condition@error_category@std@@UBE?AVerror_condition@2@H@Z proc near
.text$mn:000020D4                                         ; DATA XREF: .rdata:00002C5Co
.text$mn:000020D4                                         ; .rdata:00002C78o ...
.text$mn:000020D4
.text$mn:000020D4 var_4           = dword ptr -4
.text$mn:000020D4 arg_0           = dword ptr  8
.text$mn:000020D4 arg_4           = dword ptr  0Ch
.text$mn:000020D4
.text$mn:000020D4                 push    ebp
.text$mn:000020D5                 mov     ebp, esp
.text$mn:000020D7                 push    ecx
.text$mn:000020D8                 mov     [ebp+var_4], ecx
.text$mn:000020DB                 mov     eax, [ebp+var_4]
.text$mn:000020DE                 push    eax             ; struct std::error_category *
.text$mn:000020DF                 mov     ecx, [ebp+arg_4]
.text$mn:000020E2                 push    ecx             ; int
.text$mn:000020E3                 mov     ecx, [ebp+arg_0] ; this
.text$mn:000020E6                 call    ??0error_condition@std@@QAE@HABVerror_category@1@@Z ; std::error_condition::error_condition(int,std::error_category const &)
.text$mn:000020EB                 mov     eax, [ebp+arg_0]
.text$mn:000020EE                 mov     esp, ebp
.text$mn:000020F0                 pop     ebp
.text$mn:000020F1                 retn    8
.text$mn:000020F1 ?default_error_condition@error_category@std@@UBE?AVerror_condition@2@H@Z endp
.text$mn:000020F1
.text$mn:000020F1 _text$mn        ends
.text$mn:000020F1
.text$mn:000020F4 ; ===========================================================================
.text$mn:000020F4
.text$mn:000020F4 ; Segment type: Pure code
.text$mn:000020F4 ; Segment permissions: Read/Execute
.text$mn:000020F4 _text$mn        segment para public 'CODE' use32
.text$mn:000020F4                 assume cs:_text$mn
.text$mn:000020F4                 ;org 20F4h
.text$mn:000020F4 ; COMDAT (pick any)
.text$mn:000020F4                 assume es:nothing, ss:nothing, ds:_xdata$x, fs:nothing, gs:nothing
.text$mn:000020F4
.text$mn:000020F4 ; =============== S U B R O U T I N E =======================================
.text$mn:000020F4
.text$mn:000020F4 ; Attributes: bp-based frame
.text$mn:000020F4
.text$mn:000020F4 ; bool __thiscall std::error_category::equivalent(std::error_category *this, const struct std::error_code *, int)
.text$mn:000020F4                 public ?equivalent@error_category@std@@UBE_NABVerror_code@2@H@Z
.text$mn:000020F4 ?equivalent@error_category@std@@UBE_NABVerror_code@2@H@Z proc near
.text$mn:000020F4                                         ; DATA XREF: .rdata:00002C60o
.text$mn:000020F4                                         ; .rdata:00002C7Co ...
.text$mn:000020F4
.text$mn:000020F4 var_8           = dword ptr -8
.text$mn:000020F4 var_4           = dword ptr -4
.text$mn:000020F4 arg_0           = dword ptr  8
.text$mn:000020F4 arg_4           = dword ptr  0Ch
.text$mn:000020F4
.text$mn:000020F4                 push    ebp
.text$mn:000020F5                 mov     ebp, esp
.text$mn:000020F7                 sub     esp, 8
.text$mn:000020FA                 mov     [ebp+var_8], ecx
.text$mn:000020FD                 mov     ecx, [ebp+arg_0] ; this
.text$mn:00002100                 call    ?category@error_code@std@@QBEABVerror_category@2@XZ ; std::error_code::category(void)
.text$mn:00002105                 push    eax
.text$mn:00002106                 mov     ecx, [ebp+var_8]
.text$mn:00002109                 call    ??8error_category@std@@QBE_NABV01@@Z ; std::error_category::operator==(std::error_category const &)
.text$mn:0000210E                 movzx   eax, al
.text$mn:00002111                 test    eax, eax
.text$mn:00002113                 jz      short loc_212B
.text$mn:00002115                 mov     ecx, [ebp+arg_0] ; this
.text$mn:00002118                 call    ?value@error_code@std@@QBEHXZ ; std::error_code::value(void)
.text$mn:0000211D                 cmp     eax, [ebp+arg_4]
.text$mn:00002120                 jnz     short loc_212B
.text$mn:00002122                 mov     [ebp+var_4], 1
.text$mn:00002129                 jmp     short loc_2132
.text$mn:0000212B ; ---------------------------------------------------------------------------
.text$mn:0000212B
.text$mn:0000212B loc_212B:                               ; CODE XREF: std::error_category::equivalent(std::error_code const &,int)+1Fj
.text$mn:0000212B                                         ; std::error_category::equivalent(std::error_code const &,int)+2Cj
.text$mn:0000212B                 mov     [ebp+var_4], 0
.text$mn:00002132
.text$mn:00002132 loc_2132:                               ; CODE XREF: std::error_category::equivalent(std::error_code const &,int)+35j
.text$mn:00002132                 mov     al, byte ptr [ebp+var_4]
.text$mn:00002135                 mov     esp, ebp
.text$mn:00002137                 pop     ebp
.text$mn:00002138                 retn    8
.text$mn:00002138 ?equivalent@error_category@std@@UBE_NABVerror_code@2@H@Z endp
.text$mn:00002138
.text$mn:00002138 ; ---------------------------------------------------------------------------
.text$mn:0000213B                 align 4
.text$mn:0000213B _text$mn        ends
.text$mn:0000213B
.text$mn:0000213C ; ===========================================================================
.text$mn:0000213C
.text$mn:0000213C ; Segment type: Pure code
.text$mn:0000213C ; Segment permissions: Read/Execute
.text$mn:0000213C _text$mn        segment para public 'CODE' use32
.text$mn:0000213C                 assume cs:_text$mn
.text$mn:0000213C                 ;org 213Ch
.text$mn:0000213C ; COMDAT (pick any)
.text$mn:0000213C                 assume es:nothing, ss:nothing, ds:_xdata$x, fs:nothing, gs:nothing
.text$mn:0000213C
.text$mn:0000213C ; =============== S U B R O U T I N E =======================================
.text$mn:0000213C
.text$mn:0000213C ; Attributes: bp-based frame
.text$mn:0000213C
.text$mn:0000213C ; bool __thiscall std::error_category::equivalent(std::error_category *this, int, const struct std::error_condition *)
.text$mn:0000213C                 public ?equivalent@error_category@std@@UBE_NHABVerror_condition@2@@Z
.text$mn:0000213C ?equivalent@error_category@std@@UBE_NHABVerror_condition@2@@Z proc near
.text$mn:0000213C                                         ; DATA XREF: .rdata:00002C64o
.text$mn:0000213C                                         ; .rdata:00002C80o ...
.text$mn:0000213C
.text$mn:0000213C var_C           = byte ptr -0Ch
.text$mn:0000213C var_4           = dword ptr -4
.text$mn:0000213C arg_0           = dword ptr  8
.text$mn:0000213C arg_4           = dword ptr  0Ch
.text$mn:0000213C
.text$mn:0000213C                 push    ebp
.text$mn:0000213D                 mov     ebp, esp
.text$mn:0000213F                 sub     esp, 0Ch
.text$mn:00002142                 mov     [ebp+var_4], ecx
.text$mn:00002145                 mov     eax, [ebp+arg_4]
.text$mn:00002148                 push    eax             ; std::error_condition *
.text$mn:00002149                 mov     ecx, [ebp+arg_0]
.text$mn:0000214C                 push    ecx
.text$mn:0000214D                 lea     edx, [ebp+var_C]
.text$mn:00002150                 push    edx
.text$mn:00002151                 mov     eax, [ebp+var_4]
.text$mn:00002154                 mov     edx, [eax]
.text$mn:00002156                 mov     ecx, [ebp+var_4]
.text$mn:00002159                 mov     eax, [edx+0Ch]
.text$mn:0000215C                 call    eax
.text$mn:0000215E                 mov     ecx, eax
.text$mn:00002160                 call    ??8error_condition@std@@QBE_NABV01@@Z ; std::error_condition::operator==(std::error_condition const &)
.text$mn:00002165                 mov     esp, ebp
.text$mn:00002167                 pop     ebp
.text$mn:00002168                 retn    8
.text$mn:00002168 ?equivalent@error_category@std@@UBE_NHABVerror_condition@2@@Z endp
.text$mn:00002168
.text$mn:00002168 ; ---------------------------------------------------------------------------
.text$mn:0000216B                 align 4
.text$mn:0000216B _text$mn        ends
.text$mn:0000216B
.text$mn:0000216C ; ===========================================================================
.text$mn:0000216C
.text$mn:0000216C ; Segment type: Pure code
.text$mn:0000216C ; Segment permissions: Read/Execute
.text$mn:0000216C _text$mn        segment para public 'CODE' use32
.text$mn:0000216C                 assume cs:_text$mn
.text$mn:0000216C                 ;org 216Ch
.text$mn:0000216C ; COMDAT (pick any)
.text$mn:0000216C                 assume es:nothing, ss:nothing, ds:_xdata$x, fs:nothing, gs:nothing
.text$mn:0000216C
.text$mn:0000216C ; =============== S U B R O U T I N E =======================================
.text$mn:0000216C
.text$mn:0000216C ; Attributes: bp-based frame
.text$mn:0000216C
.text$mn:0000216C ; public: class std::basic_string<char, struct std::char_traits<char>, class std::allocator<char>> & __thiscall std::basic_string<char, struct std::char_traits<char>, class std::allocator<char>>::erase(unsigned int)
.text$mn:0000216C                 public ?erase@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV12@I@Z
.text$mn:0000216C ?erase@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV12@I@Z proc near
.text$mn:0000216C                                         ; CODE XREF: std::basic_string<char,std::char_traits<char>,std::allocator<char>>::assign(std::basic_string<char,std::char_traits<char>,std::allocator<char>> const &,uint,uint)+4Cp
.text$mn:0000216C
.text$mn:0000216C var_4           = dword ptr -4
.text$mn:0000216C arg_0           = dword ptr  8
.text$mn:0000216C
.text$mn:0000216C                 push    ebp
.text$mn:0000216D                 mov     ebp, esp
.text$mn:0000216F                 push    ecx
.text$mn:00002170                 mov     [ebp+var_4], ecx
.text$mn:00002173                 mov     eax, [ebp+var_4]
.text$mn:00002176                 mov     ecx, [eax+14h]
.text$mn:00002179                 cmp     ecx, [ebp+arg_0]
.text$mn:0000217C                 jnb     short loc_2186
.text$mn:0000217E                 mov     ecx, [ebp+var_4]
.text$mn:00002181                 call    ?_Xran@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QBEXXZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char>>::_Xran(void)
.text$mn:00002186
.text$mn:00002186 loc_2186:                               ; CODE XREF: std::basic_string<char,std::char_traits<char>,std::allocator<char>>::erase(uint)+10j
.text$mn:00002186                 mov     edx, [ebp+arg_0]
.text$mn:00002189                 push    edx
.text$mn:0000218A                 mov     ecx, [ebp+var_4]
.text$mn:0000218D                 call    ?_Eos@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEXI@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char>>::_Eos(uint)
.text$mn:00002192                 mov     eax, [ebp+var_4]
.text$mn:00002195                 mov     esp, ebp
.text$mn:00002197                 pop     ebp
.text$mn:00002198                 retn    4
.text$mn:00002198 ?erase@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV12@I@Z endp
.text$mn:00002198
.text$mn:00002198 ; ---------------------------------------------------------------------------
.text$mn:0000219B                 align 4
.text$mn:0000219B _text$mn        ends
.text$mn:0000219B
.text$mn:0000219C ; ===========================================================================
.text$mn:0000219C
.text$mn:0000219C ; Segment type: Pure code
.text$mn:0000219C ; Segment permissions: Read/Execute
.text$mn:0000219C _text$mn        segment para public 'CODE' use32
.text$mn:0000219C                 assume cs:_text$mn
.text$mn:0000219C                 ;org 219Ch
.text$mn:0000219C ; COMDAT (pick any)
.text$mn:0000219C                 assume es:nothing, ss:nothing, ds:_xdata$x, fs:nothing, gs:nothing
.text$mn:0000219C
.text$mn:0000219C ; =============== S U B R O U T I N E =======================================
.text$mn:0000219C
.text$mn:0000219C ; Attributes: bp-based frame
.text$mn:0000219C
.text$mn:0000219C ; public: class std::basic_string<char, struct std::char_traits<char>, class std::allocator<char>> & __thiscall std::basic_string<char, struct std::char_traits<char>, class std::allocator<char>>::erase(unsigned int, unsigned int)
.text$mn:0000219C                 public ?erase@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV12@II@Z
.text$mn:0000219C ?erase@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV12@II@Z proc near
.text$mn:0000219C                                         ; CODE XREF: std::basic_string<char,std::char_traits<char>,std::allocator<char>>::assign(std::basic_string<char,std::char_traits<char>,std::allocator<char>> const &,uint,uint)+5Ap
.text$mn:0000219C
.text$mn:0000219C var_C           = dword ptr -0Ch
.text$mn:0000219C Dst             = dword ptr -8
.text$mn:0000219C var_4           = dword ptr -4
.text$mn:0000219C arg_0           = dword ptr  8
.text$mn:0000219C arg_4           = dword ptr  0Ch
.text$mn:0000219C
.text$mn:0000219C                 push    ebp
.text$mn:0000219D                 mov     ebp, esp
.text$mn:0000219F                 sub     esp, 0Ch
.text$mn:000021A2                 mov     [ebp+var_4], ecx
.text$mn:000021A5                 mov     eax, [ebp+var_4]
.text$mn:000021A8                 mov     ecx, [eax+14h]
.text$mn:000021AB                 cmp     ecx, [ebp+arg_0]
.text$mn:000021AE                 jnb     short loc_21B8
.text$mn:000021B0                 mov     ecx, [ebp+var_4]
.text$mn:000021B3                 call    ?_Xran@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QBEXXZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char>>::_Xran(void)
.text$mn:000021B8
.text$mn:000021B8 loc_21B8:                               ; CODE XREF: std::basic_string<char,std::char_traits<char>,std::allocator<char>>::erase(uint,uint)+12j
.text$mn:000021B8                 mov     edx, [ebp+var_4]
.text$mn:000021BB                 mov     eax, [edx+14h]
.text$mn:000021BE                 sub     eax, [ebp+arg_0]
.text$mn:000021C1                 cmp     eax, [ebp+arg_4]
.text$mn:000021C4                 ja      short loc_21D4
.text$mn:000021C6                 mov     ecx, [ebp+arg_0]
.text$mn:000021C9                 push    ecx
.text$mn:000021CA                 mov     ecx, [ebp+var_4]
.text$mn:000021CD                 call    ?_Eos@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEXI@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char>>::_Eos(uint)
.text$mn:000021D2                 jmp     short loc_221A
.text$mn:000021D4 ; ---------------------------------------------------------------------------
.text$mn:000021D4
.text$mn:000021D4 loc_21D4:                               ; CODE XREF: std::basic_string<char,std::char_traits<char>,std::allocator<char>>::erase(uint,uint)+28j
.text$mn:000021D4                 cmp     [ebp+arg_4], 0
.text$mn:000021D8                 jbe     short loc_221A
.text$mn:000021DA                 mov     ecx, [ebp+var_4]
.text$mn:000021DD                 call    ?_Myptr@?$_String_val@U?$_Simple_types@D@std@@@std@@QAEPADXZ ; std::_String_val<std::_Simple_types<char>>::_Myptr(void)
.text$mn:000021E2                 add     eax, [ebp+arg_0]
.text$mn:000021E5                 mov     [ebp+Dst], eax
.text$mn:000021E8                 mov     edx, [ebp+var_4]
.text$mn:000021EB                 mov     eax, [edx+14h]
.text$mn:000021EE                 sub     eax, [ebp+arg_4]
.text$mn:000021F1                 mov     [ebp+var_C], eax
.text$mn:000021F4                 mov     ecx, [ebp+var_C]
.text$mn:000021F7                 sub     ecx, [ebp+arg_0]
.text$mn:000021FA                 push    ecx             ; Size
.text$mn:000021FB                 mov     edx, [ebp+Dst]
.text$mn:000021FE                 add     edx, [ebp+arg_4]
.text$mn:00002201                 push    edx             ; Src
.text$mn:00002202                 mov     eax, [ebp+Dst]
.text$mn:00002205                 push    eax             ; Dst
.text$mn:00002206                 call    ?move@?$char_traits@D@std@@SAPADPADPBDI@Z ; std::char_traits<char>::move(char *,char const *,uint)
.text$mn:0000220B                 add     esp, 0Ch
.text$mn:0000220E                 mov     ecx, [ebp+var_C]
.text$mn:00002211                 push    ecx
.text$mn:00002212                 mov     ecx, [ebp+var_4]
.text$mn:00002215                 call    ?_Eos@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEXI@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char>>::_Eos(uint)
.text$mn:0000221A
.text$mn:0000221A loc_221A:                               ; CODE XREF: std::basic_string<char,std::char_traits<char>,std::allocator<char>>::erase(uint,uint)+36j
.text$mn:0000221A                                         ; std::basic_string<char,std::char_traits<char>,std::allocator<char>>::erase(uint,uint)+3Cj
.text$mn:0000221A                 mov     eax, [ebp+var_4]
.text$mn:0000221D                 mov     esp, ebp
.text$mn:0000221F                 pop     ebp
.text$mn:00002220                 retn    8
.text$mn:00002220 ?erase@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV12@II@Z endp
.text$mn:00002220
.text$mn:00002220 ; ---------------------------------------------------------------------------
.text$mn:00002223                 align 4
.text$mn:00002223 _text$mn        ends
.text$mn:00002223
.text$mn:00002224 ; ===========================================================================
.text$mn:00002224
.text$mn:00002224 ; Segment type: Pure code
.text$mn:00002224 ; Segment permissions: Read/Execute
.text$mn:00002224 _text$mn        segment para public 'CODE' use32
.text$mn:00002224                 assume cs:_text$mn
.text$mn:00002224                 ;org 2224h
.text$mn:00002224 ; COMDAT (pick any)
.text$mn:00002224                 assume es:nothing, ss:nothing, ds:_xdata$x, fs:nothing, gs:nothing
.text$mn:00002224
.text$mn:00002224 ; =============== S U B R O U T I N E =======================================
.text$mn:00002224
.text$mn:00002224 ; Attributes: bp-based frame
.text$mn:00002224
.text$mn:00002224 ; public: class std::basic_string<wchar_t, struct std::char_traits<wchar_t>, class std::allocator<wchar_t>> & __thiscall std::basic_string<wchar_t, struct std::char_traits<wchar_t>, class std::allocator<wchar_t>>::erase(unsigned int)
.text$mn:00002224                 public ?erase@?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QAEAAV12@I@Z
.text$mn:00002224 ?erase@?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QAEAAV12@I@Z proc near
.text$mn:00002224                                         ; CODE XREF: std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>>::assign(std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>> const &,uint,uint)+4Cp
.text$mn:00002224
.text$mn:00002224 var_4           = dword ptr -4
.text$mn:00002224 arg_0           = dword ptr  8
.text$mn:00002224
.text$mn:00002224                 push    ebp
.text$mn:00002225                 mov     ebp, esp
.text$mn:00002227                 push    ecx
.text$mn:00002228                 mov     [ebp+var_4], ecx
.text$mn:0000222B                 mov     eax, [ebp+var_4]
.text$mn:0000222E                 mov     ecx, [eax+14h]
.text$mn:00002231                 cmp     ecx, [ebp+arg_0]
.text$mn:00002234                 jnb     short loc_223E
.text$mn:00002236                 mov     ecx, [ebp+var_4]
.text$mn:00002239                 call    ?_Xran@?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QBEXXZ ; std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>>::_Xran(void)
.text$mn:0000223E
.text$mn:0000223E loc_223E:                               ; CODE XREF: std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>>::erase(uint)+10j
.text$mn:0000223E                 mov     edx, [ebp+arg_0]
.text$mn:00002241                 push    edx
.text$mn:00002242                 mov     ecx, [ebp+var_4]
.text$mn:00002245                 call    ?_Eos@?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QAEXI@Z ; std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>>::_Eos(uint)
.text$mn:0000224A                 mov     eax, [ebp+var_4]
.text$mn:0000224D                 mov     esp, ebp
.text$mn:0000224F                 pop     ebp
.text$mn:00002250                 retn    4
.text$mn:00002250 ?erase@?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QAEAAV12@I@Z endp
.text$mn:00002250
.text$mn:00002250 ; ---------------------------------------------------------------------------
.text$mn:00002253                 align 4
.text$mn:00002253 _text$mn        ends
.text$mn:00002253
.text$mn:00002254 ; ===========================================================================
.text$mn:00002254
.text$mn:00002254 ; Segment type: Pure code
.text$mn:00002254 ; Segment permissions: Read/Execute
.text$mn:00002254 _text$mn        segment para public 'CODE' use32
.text$mn:00002254                 assume cs:_text$mn
.text$mn:00002254                 ;org 2254h
.text$mn:00002254 ; COMDAT (pick any)
.text$mn:00002254                 assume es:nothing, ss:nothing, ds:_xdata$x, fs:nothing, gs:nothing
.text$mn:00002254
.text$mn:00002254 ; =============== S U B R O U T I N E =======================================
.text$mn:00002254
.text$mn:00002254 ; Attributes: bp-based frame
.text$mn:00002254
.text$mn:00002254 ; public: class std::basic_string<wchar_t, struct std::char_traits<wchar_t>, class std::allocator<wchar_t>> & __thiscall std::basic_string<wchar_t, struct std::char_traits<wchar_t>, class std::allocator<wchar_t>>::erase(unsigned int, unsigned int)
.text$mn:00002254                 public ?erase@?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QAEAAV12@II@Z
.text$mn:00002254 ?erase@?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QAEAAV12@II@Z proc near
.text$mn:00002254                                         ; CODE XREF: std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>>::assign(std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>> const &,uint,uint)+5Ap
.text$mn:00002254
.text$mn:00002254 var_C           = dword ptr -0Ch
.text$mn:00002254 Dst             = dword ptr -8
.text$mn:00002254 var_4           = dword ptr -4
.text$mn:00002254 arg_0           = dword ptr  8
.text$mn:00002254 arg_4           = dword ptr  0Ch
.text$mn:00002254
.text$mn:00002254                 push    ebp
.text$mn:00002255                 mov     ebp, esp
.text$mn:00002257                 sub     esp, 0Ch
.text$mn:0000225A                 mov     [ebp+var_4], ecx
.text$mn:0000225D                 mov     eax, [ebp+var_4]
.text$mn:00002260                 mov     ecx, [eax+14h]
.text$mn:00002263                 cmp     ecx, [ebp+arg_0]
.text$mn:00002266                 jnb     short loc_2270
.text$mn:00002268                 mov     ecx, [ebp+var_4]
.text$mn:0000226B                 call    ?_Xran@?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QBEXXZ ; std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>>::_Xran(void)
.text$mn:00002270
.text$mn:00002270 loc_2270:                               ; CODE XREF: std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>>::erase(uint,uint)+12j
.text$mn:00002270                 mov     edx, [ebp+var_4]
.text$mn:00002273                 mov     eax, [edx+14h]
.text$mn:00002276                 sub     eax, [ebp+arg_0]
.text$mn:00002279                 cmp     eax, [ebp+arg_4]
.text$mn:0000227C                 ja      short loc_228C
.text$mn:0000227E                 mov     ecx, [ebp+arg_0]
.text$mn:00002281                 push    ecx
.text$mn:00002282                 mov     ecx, [ebp+var_4]
.text$mn:00002285                 call    ?_Eos@?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QAEXI@Z ; std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>>::_Eos(uint)
.text$mn:0000228A                 jmp     short loc_22D8
.text$mn:0000228C ; ---------------------------------------------------------------------------
.text$mn:0000228C
.text$mn:0000228C loc_228C:                               ; CODE XREF: std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>>::erase(uint,uint)+28j
.text$mn:0000228C                 cmp     [ebp+arg_4], 0
.text$mn:00002290                 jbe     short loc_22D8
.text$mn:00002292                 mov     ecx, [ebp+var_4]
.text$mn:00002295                 call    ?_Myptr@?$_String_val@U?$_Simple_types@_W@std@@@std@@QAEPA_WXZ ; std::_String_val<std::_Simple_types<wchar_t>>::_Myptr(void)
.text$mn:0000229A                 mov     edx, [ebp+arg_0]
.text$mn:0000229D                 lea     eax, [eax+edx*2]
.text$mn:000022A0                 mov     [ebp+Dst], eax
.text$mn:000022A3                 mov     ecx, [ebp+var_4]
.text$mn:000022A6                 mov     edx, [ecx+14h]
.text$mn:000022A9                 sub     edx, [ebp+arg_4]
.text$mn:000022AC                 mov     [ebp+var_C], edx
.text$mn:000022AF                 mov     eax, [ebp+var_C]
.text$mn:000022B2                 sub     eax, [ebp+arg_0]
.text$mn:000022B5                 push    eax             ; int
.text$mn:000022B6                 mov     ecx, [ebp+arg_4]
.text$mn:000022B9                 mov     edx, [ebp+Dst]
.text$mn:000022BC                 lea     eax, [edx+ecx*2]
.text$mn:000022BF                 push    eax             ; Src
.text$mn:000022C0                 mov     ecx, [ebp+Dst]
.text$mn:000022C3                 push    ecx             ; Dst
.text$mn:000022C4                 call    ?move@?$char_traits@_W@std@@SAPA_WPA_WPB_WI@Z ; std::char_traits<wchar_t>::move(wchar_t *,wchar_t const *,uint)
.text$mn:000022C9                 add     esp, 0Ch
.text$mn:000022CC                 mov     edx, [ebp+var_C]
.text$mn:000022CF                 push    edx
.text$mn:000022D0                 mov     ecx, [ebp+var_4]
.text$mn:000022D3                 call    ?_Eos@?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QAEXI@Z ; std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>>::_Eos(uint)
.text$mn:000022D8
.text$mn:000022D8 loc_22D8:                               ; CODE XREF: std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>>::erase(uint,uint)+36j
.text$mn:000022D8                                         ; std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>>::erase(uint,uint)+3Cj
.text$mn:000022D8                 mov     eax, [ebp+var_4]
.text$mn:000022DB                 mov     esp, ebp
.text$mn:000022DD                 pop     ebp
.text$mn:000022DE                 retn    8
.text$mn:000022DE ?erase@?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QAEAAV12@II@Z endp
.text$mn:000022DE
.text$mn:000022DE ; ---------------------------------------------------------------------------
.text$mn:000022E1                 align 4
.text$mn:000022E1 _text$mn        ends
.text$mn:000022E1
.text$mn:000022E4 ; ===========================================================================
.text$mn:000022E4
.text$mn:000022E4 ; Segment type: Pure code
.text$mn:000022E4 ; Segment permissions: Read/Execute
.text$mn:000022E4 _text$mn        segment para public 'CODE' use32
.text$mn:000022E4                 assume cs:_text$mn
.text$mn:000022E4                 ;org 22E4h
.text$mn:000022E4 ; COMDAT (pick any)
.text$mn:000022E4                 assume es:nothing, ss:nothing, ds:_xdata$x, fs:nothing, gs:nothing
.text$mn:000022E4
.text$mn:000022E4 ; =============== S U B R O U T I N E =======================================
.text$mn:000022E4
.text$mn:000022E4 ; Attributes: bp-based frame
.text$mn:000022E4
.text$mn:000022E4 ; const struct std::error_category *__cdecl std::generic_category()
.text$mn:000022E4                 public ?generic_category@std@@YAABVerror_category@1@XZ
.text$mn:000022E4 ?generic_category@std@@YAABVerror_category@1@XZ proc near
.text$mn:000022E4                                         ; CODE XREF: std::_System_error_category::default_error_condition(int)+17p
.text$mn:000022E4                 push    ebp
.text$mn:000022E5                 mov     ebp, esp
.text$mn:000022E7                 mov     eax, offset ?_Generic_object@?$_Error_objects@H@std@@2V_Generic_error_category@2@A ; std::_Generic_error_category std::_Error_objects<int>::_Generic_object
.text$mn:000022EC                 pop     ebp
.text$mn:000022ED                 retn
.text$mn:000022ED ?generic_category@std@@YAABVerror_category@1@XZ endp
.text$mn:000022ED
.text$mn:000022ED ; ---------------------------------------------------------------------------
.text$mn:000022EE                 align 10h
.text$mn:000022EE _text$mn        ends
.text$mn:000022EE
.text$mn:000022F0 ; ===========================================================================
.text$mn:000022F0
.text$mn:000022F0 ; Segment type: Pure code
.text$mn:000022F0 ; Segment permissions: Read/Execute
.text$mn:000022F0 _text$mn        segment para public 'CODE' use32
.text$mn:000022F0                 assume cs:_text$mn
.text$mn:000022F0                 ;org 22F0h
.text$mn:000022F0 ; COMDAT (pick any)
.text$mn:000022F0                 assume es:nothing, ss:nothing, ds:_xdata$x, fs:nothing, gs:nothing
.text$mn:000022F0
.text$mn:000022F0 ; =============== S U B R O U T I N E =======================================
.text$mn:000022F0
.text$mn:000022F0 ; Attributes: bp-based frame
.text$mn:000022F0
.text$mn:000022F0 ; int __thiscall ButtonDlg::getButtonStatus(ButtonDlg *__hidden this)
.text$mn:000022F0                 public ?getButtonStatus@ButtonDlg@@QBEHXZ
.text$mn:000022F0 ?getButtonStatus@ButtonDlg@@QBEHXZ proc near
.text$mn:000022F0                                         ; CODE XREF: ButtonDlg::run_dlgProc(uint,uint,long)+44p
.text$mn:000022F0
.text$mn:000022F0 var_4           = dword ptr -4
.text$mn:000022F0
.text$mn:000022F0                 push    ebp
.text$mn:000022F1                 mov     ebp, esp
.text$mn:000022F3                 push    ecx
.text$mn:000022F4                 mov     [ebp+var_4], ecx
.text$mn:000022F7                 mov     eax, [ebp+var_4]
.text$mn:000022FA                 mov     eax, [eax+20h]
.text$mn:000022FD                 mov     esp, ebp
.text$mn:000022FF                 pop     ebp
.text$mn:00002300                 retn
.text$mn:00002300 ?getButtonStatus@ButtonDlg@@QBEHXZ endp
.text$mn:00002300
.text$mn:00002300 ; ---------------------------------------------------------------------------
.text$mn:00002301                 align 4
.text$mn:00002301 _text$mn        ends
.text$mn:00002301
.text$mn:00002304 ; ===========================================================================
.text$mn:00002304
.text$mn:00002304 ; Segment type: Pure code
.text$mn:00002304 ; Segment permissions: Read/Execute
.text$mn:00002304 _text$mn        segment para public 'CODE' use32
.text$mn:00002304                 assume cs:_text$mn
.text$mn:00002304                 ;org 2304h
.text$mn:00002304 ; COMDAT (pick any)
.text$mn:00002304                 assume es:nothing, ss:nothing, ds:_xdata$x, fs:nothing, gs:nothing
.text$mn:00002304
.text$mn:00002304 ; =============== S U B R O U T I N E =======================================
.text$mn:00002304
.text$mn:00002304 ; Attributes: bp-based frame
.text$mn:00002304
.text$mn:00002304 ; void __thiscall Window::init(Window *this, HINSTANCE, HWND)
.text$mn:00002304                 public ?init@Window@@UAEXPAUHINSTANCE__@@PAUHWND__@@@Z
.text$mn:00002304 ?init@Window@@UAEXPAUHINSTANCE__@@PAUHWND__@@@Z proc near
.text$mn:00002304                                         ; CODE XREF: ValueDlg::init(HINSTANCE__ *,HWND__ *,int,wchar_t const *)+12p
.text$mn:00002304
.text$mn:00002304 var_4           = dword ptr -4
.text$mn:00002304 arg_0           = dword ptr  8
.text$mn:00002304 arg_4           = dword ptr  0Ch
.text$mn:00002304
.text$mn:00002304                 push    ebp
.text$mn:00002305                 mov     ebp, esp
.text$mn:00002307                 push    ecx
.text$mn:00002308                 mov     [ebp+var_4], ecx
.text$mn:0000230B                 mov     eax, [ebp+var_4]
.text$mn:0000230E                 mov     ecx, [ebp+arg_0]
.text$mn:00002311                 mov     [eax+4], ecx
.text$mn:00002314                 mov     edx, [ebp+var_4]
.text$mn:00002317                 mov     eax, [ebp+arg_4]
.text$mn:0000231A                 mov     [edx+8], eax
.text$mn:0000231D                 mov     esp, ebp
.text$mn:0000231F                 pop     ebp
.text$mn:00002320                 retn    8
.text$mn:00002320 ?init@Window@@UAEXPAUHINSTANCE__@@PAUHWND__@@@Z endp
.text$mn:00002320
.text$mn:00002320 ; ---------------------------------------------------------------------------
.text$mn:00002323                 align 4
.text$mn:00002323 _text$mn        ends
.text$mn:00002323
.text$mn:00002324 ; ===========================================================================
.text$mn:00002324
.text$mn:00002324 ; Segment type: Pure code
.text$mn:00002324 ; Segment permissions: Read/Execute
.text$mn:00002324 _text$mn        segment para public 'CODE' use32
.text$mn:00002324                 assume cs:_text$mn
.text$mn:00002324                 ;org 2324h
.text$mn:00002324 ; COMDAT (pick any)
.text$mn:00002324                 assume es:nothing, ss:nothing, ds:_xdata$x, fs:nothing, gs:nothing
.text$mn:00002324
.text$mn:00002324 ; =============== S U B R O U T I N E =======================================
.text$mn:00002324
.text$mn:00002324 ; Attributes: bp-based frame
.text$mn:00002324
.text$mn:00002324 ; int __cdecl std::char_traits<char>::length(char *Str)
.text$mn:00002324                 public ?length@?$char_traits@D@std@@SAIPBD@Z
.text$mn:00002324 ?length@?$char_traits@D@std@@SAIPBD@Z proc near
.text$mn:00002324                                         ; CODE XREF: std::basic_string<char,std::char_traits<char>,std::allocator<char>>::assign(char const *)+21p
.text$mn:00002324
.text$mn:00002324 var_4           = dword ptr -4
.text$mn:00002324 Str             = dword ptr  8
.text$mn:00002324
.text$mn:00002324                 push    ebp
.text$mn:00002325                 mov     ebp, esp
.text$mn:00002327                 push    ecx
.text$mn:00002328                 mov     eax, [ebp+Str]
.text$mn:0000232B                 movsx   ecx, byte ptr [eax]
.text$mn:0000232E                 test    ecx, ecx
.text$mn:00002330                 jnz     short loc_233B
.text$mn:00002332                 mov     [ebp+var_4], 0
.text$mn:00002339                 jmp     short loc_234A
.text$mn:0000233B ; ---------------------------------------------------------------------------
.text$mn:0000233B
.text$mn:0000233B loc_233B:                               ; CODE XREF: std::char_traits<char>::length(char const *)+Cj
.text$mn:0000233B                 mov     edx, [ebp+Str]
.text$mn:0000233E                 push    edx             ; Str
.text$mn:0000233F                 call    _strlen
.text$mn:00002344                 add     esp, 4
.text$mn:00002347                 mov     [ebp+var_4], eax
.text$mn:0000234A
.text$mn:0000234A loc_234A:                               ; CODE XREF: std::char_traits<char>::length(char const *)+15j
.text$mn:0000234A                 mov     eax, [ebp+var_4]
.text$mn:0000234D                 mov     esp, ebp
.text$mn:0000234F                 pop     ebp
.text$mn:00002350                 retn
.text$mn:00002350 ?length@?$char_traits@D@std@@SAIPBD@Z endp
.text$mn:00002350
.text$mn:00002350 ; ---------------------------------------------------------------------------
.text$mn:00002351                 align 4
.text$mn:00002351 _text$mn        ends
.text$mn:00002351
.text$mn:00002354 ; ===========================================================================
.text$mn:00002354
.text$mn:00002354 ; Segment type: Pure code
.text$mn:00002354 ; Segment permissions: Read/Execute
.text$mn:00002354 _text$mn        segment para public 'CODE' use32
.text$mn:00002354                 assume cs:_text$mn
.text$mn:00002354                 ;org 2354h
.text$mn:00002354 ; COMDAT (pick any)
.text$mn:00002354                 assume es:nothing, ss:nothing, ds:_xdata$x, fs:nothing, gs:nothing
.text$mn:00002354
.text$mn:00002354 ; =============== S U B R O U T I N E =======================================
.text$mn:00002354
.text$mn:00002354 ; Attributes: bp-based frame
.text$mn:00002354
.text$mn:00002354 ; int __cdecl std::char_traits<wchar_t>::length(wchar_t *Str)
.text$mn:00002354                 public ?length@?$char_traits@_W@std@@SAIPB_W@Z
.text$mn:00002354 ?length@?$char_traits@_W@std@@SAIPB_W@Z proc near
.text$mn:00002354                                         ; CODE XREF: std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>>::assign(wchar_t const *)+21p
.text$mn:00002354
.text$mn:00002354 var_4           = dword ptr -4
.text$mn:00002354 Str             = dword ptr  8
.text$mn:00002354
.text$mn:00002354                 push    ebp
.text$mn:00002355                 mov     ebp, esp
.text$mn:00002357                 push    ecx
.text$mn:00002358                 mov     eax, [ebp+Str]
.text$mn:0000235B                 movzx   ecx, word ptr [eax]
.text$mn:0000235E                 test    ecx, ecx
.text$mn:00002360                 jnz     short loc_236B
.text$mn:00002362                 mov     [ebp+var_4], 0
.text$mn:00002369                 jmp     short loc_237A
.text$mn:0000236B ; ---------------------------------------------------------------------------
.text$mn:0000236B
.text$mn:0000236B loc_236B:                               ; CODE XREF: std::char_traits<wchar_t>::length(wchar_t const *)+Cj
.text$mn:0000236B                 mov     edx, [ebp+Str]
.text$mn:0000236E                 push    edx             ; Str
.text$mn:0000236F                 call    _wcslen
.text$mn:00002374                 add     esp, 4
.text$mn:00002377                 mov     [ebp+var_4], eax
.text$mn:0000237A
.text$mn:0000237A loc_237A:                               ; CODE XREF: std::char_traits<wchar_t>::length(wchar_t const *)+15j
.text$mn:0000237A                 mov     eax, [ebp+var_4]
.text$mn:0000237D                 mov     esp, ebp
.text$mn:0000237F                 pop     ebp
.text$mn:00002380                 retn
.text$mn:00002380 ?length@?$char_traits@_W@std@@SAIPB_W@Z endp
.text$mn:00002380
.text$mn:00002380 ; ---------------------------------------------------------------------------
.text$mn:00002381                 align 4
.text$mn:00002381 _text$mn        ends
.text$mn:00002381
.text$mn:00002384 ; ===========================================================================
.text$mn:00002384
.text$mn:00002384 ; Segment type: Pure code
.text$mn:00002384 ; Segment permissions: Read/Execute
.text$mn:00002384 _text$mn        segment para public 'CODE' use32
.text$mn:00002384                 assume cs:_text$mn
.text$mn:00002384                 ;org 2384h
.text$mn:00002384 ; COMDAT (pick any)
.text$mn:00002384                 assume es:nothing, ss:nothing, ds:_xdata$x, fs:nothing, gs:nothing
.text$mn:00002384
.text$mn:00002384 ; =============== S U B R O U T I N E =======================================
.text$mn:00002384
.text$mn:00002384 ; Attributes: bp-based frame
.text$mn:00002384
.text$mn:00002384 ; public: unsigned int __thiscall std::_Wrap_alloc<class std::allocator<char>>::max_size(void)const
.text$mn:00002384                 public ?max_size@?$_Wrap_alloc@V?$allocator@D@std@@@std@@QBEIXZ
.text$mn:00002384 ?max_size@?$_Wrap_alloc@V?$allocator@D@std@@@std@@QBEIXZ proc near
.text$mn:00002384                                         ; CODE XREF: std::basic_string<char,std::char_traits<char>,std::allocator<char>>::max_size(void)+17p
.text$mn:00002384
.text$mn:00002384 var_4           = dword ptr -4
.text$mn:00002384
.text$mn:00002384                 push    ebp
.text$mn:00002385                 mov     ebp, esp
.text$mn:00002387                 push    ecx
.text$mn:00002388                 mov     [ebp+var_4], ecx
.text$mn:0000238B                 mov     eax, [ebp+var_4]
.text$mn:0000238E                 push    eax
.text$mn:0000238F                 call    ?max_size@?$allocator_traits@V?$allocator@D@std@@@std@@SAIABV?$allocator@D@2@@Z ; std::allocator_traits<std::allocator<char>>::max_size(std::allocator<char> const &)
.text$mn:00002394                 add     esp, 4
.text$mn:00002397                 mov     esp, ebp
.text$mn:00002399                 pop     ebp
.text$mn:0000239A                 retn
.text$mn:0000239A ?max_size@?$_Wrap_alloc@V?$allocator@D@std@@@std@@QBEIXZ endp
.text$mn:0000239A
.text$mn:0000239A ; ---------------------------------------------------------------------------
.text$mn:0000239B                 align 4
.text$mn:0000239B _text$mn        ends
.text$mn:0000239B
.text$mn:0000239C ; ===========================================================================
.text$mn:0000239C
.text$mn:0000239C ; Segment type: Pure code
.text$mn:0000239C ; Segment permissions: Read/Execute
.text$mn:0000239C _text$mn        segment para public 'CODE' use32
.text$mn:0000239C                 assume cs:_text$mn
.text$mn:0000239C                 ;org 239Ch
.text$mn:0000239C ; COMDAT (pick any)
.text$mn:0000239C                 assume es:nothing, ss:nothing, ds:_xdata$x, fs:nothing, gs:nothing
.text$mn:0000239C
.text$mn:0000239C ; =============== S U B R O U T I N E =======================================
.text$mn:0000239C
.text$mn:0000239C ; Attributes: bp-based frame
.text$mn:0000239C
.text$mn:0000239C ; public: unsigned int __thiscall std::_Wrap_alloc<class std::allocator<wchar_t>>::max_size(void)const
.text$mn:0000239C                 public ?max_size@?$_Wrap_alloc@V?$allocator@_W@std@@@std@@QBEIXZ
.text$mn:0000239C ?max_size@?$_Wrap_alloc@V?$allocator@_W@std@@@std@@QBEIXZ proc near
.text$mn:0000239C                                         ; CODE XREF: std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>>::max_size(void)+17p
.text$mn:0000239C
.text$mn:0000239C var_4           = dword ptr -4
.text$mn:0000239C
.text$mn:0000239C                 push    ebp
.text$mn:0000239D                 mov     ebp, esp
.text$mn:0000239F                 push    ecx
.text$mn:000023A0                 mov     [ebp+var_4], ecx
.text$mn:000023A3                 mov     eax, [ebp+var_4]
.text$mn:000023A6                 push    eax
.text$mn:000023A7                 call    ?max_size@?$allocator_traits@V?$allocator@_W@std@@@std@@SAIABV?$allocator@_W@2@@Z ; std::allocator_traits<std::allocator<wchar_t>>::max_size(std::allocator<wchar_t> const &)
.text$mn:000023AC                 add     esp, 4
.text$mn:000023AF                 mov     esp, ebp
.text$mn:000023B1                 pop     ebp
.text$mn:000023B2                 retn
.text$mn:000023B2 ?max_size@?$_Wrap_alloc@V?$allocator@_W@std@@@std@@QBEIXZ endp
.text$mn:000023B2
.text$mn:000023B2 ; ---------------------------------------------------------------------------
.text$mn:000023B3                 align 4
.text$mn:000023B3 _text$mn        ends
.text$mn:000023B3
.text$mn:000023B4 ; ===========================================================================
.text$mn:000023B4
.text$mn:000023B4 ; Segment type: Pure code
.text$mn:000023B4 ; Segment permissions: Read/Execute
.text$mn:000023B4 _text$mn        segment para public 'CODE' use32
.text$mn:000023B4                 assume cs:_text$mn
.text$mn:000023B4                 ;org 23B4h
.text$mn:000023B4 ; COMDAT (pick any)
.text$mn:000023B4                 assume es:nothing, ss:nothing, ds:_xdata$x, fs:nothing, gs:nothing
.text$mn:000023B4
.text$mn:000023B4 ; =============== S U B R O U T I N E =======================================
.text$mn:000023B4
.text$mn:000023B4 ; Attributes: bp-based frame
.text$mn:000023B4
.text$mn:000023B4 ; public: unsigned int __thiscall std::allocator<char>::max_size(void)const
.text$mn:000023B4                 public ?max_size@?$allocator@D@std@@QBEIXZ
.text$mn:000023B4 ?max_size@?$allocator@D@std@@QBEIXZ proc near
.text$mn:000023B4                                         ; CODE XREF: std::allocator_traits<std::allocator<char>>::max_size(std::allocator<char> const &)+6p
.text$mn:000023B4
.text$mn:000023B4 var_4           = dword ptr -4
.text$mn:000023B4
.text$mn:000023B4                 push    ebp
.text$mn:000023B5                 mov     ebp, esp
.text$mn:000023B7                 push    ecx
.text$mn:000023B8                 mov     [ebp+var_4], ecx
.text$mn:000023BB                 or      eax, 0FFFFFFFFh
.text$mn:000023BE                 mov     esp, ebp
.text$mn:000023C0                 pop     ebp
.text$mn:000023C1                 retn
.text$mn:000023C1 ?max_size@?$allocator@D@std@@QBEIXZ endp
.text$mn:000023C1
.text$mn:000023C1 ; ---------------------------------------------------------------------------
.text$mn:000023C2                 align 4
.text$mn:000023C2 _text$mn        ends
.text$mn:000023C2
.text$mn:000023C4 ; ===========================================================================
.text$mn:000023C4
.text$mn:000023C4 ; Segment type: Pure code
.text$mn:000023C4 ; Segment permissions: Read/Execute
.text$mn:000023C4 _text$mn        segment para public 'CODE' use32
.text$mn:000023C4                 assume cs:_text$mn
.text$mn:000023C4                 ;org 23C4h
.text$mn:000023C4 ; COMDAT (pick any)
.text$mn:000023C4                 assume es:nothing, ss:nothing, ds:_xdata$x, fs:nothing, gs:nothing
.text$mn:000023C4
.text$mn:000023C4 ; =============== S U B R O U T I N E =======================================
.text$mn:000023C4
.text$mn:000023C4 ; Attributes: bp-based frame
.text$mn:000023C4
.text$mn:000023C4 ; public: unsigned int __thiscall std::allocator<wchar_t>::max_size(void)const
.text$mn:000023C4                 public ?max_size@?$allocator@_W@std@@QBEIXZ
.text$mn:000023C4 ?max_size@?$allocator@_W@std@@QBEIXZ proc near
.text$mn:000023C4                                         ; CODE XREF: std::allocator_traits<std::allocator<wchar_t>>::max_size(std::allocator<wchar_t> const &)+6p
.text$mn:000023C4
.text$mn:000023C4 var_4           = dword ptr -4
.text$mn:000023C4
.text$mn:000023C4                 push    ebp
.text$mn:000023C5                 mov     ebp, esp
.text$mn:000023C7                 push    ecx
.text$mn:000023C8                 mov     [ebp+var_4], ecx
.text$mn:000023CB                 mov     eax, 7FFFFFFFh
.text$mn:000023D0                 mov     esp, ebp
.text$mn:000023D2                 pop     ebp
.text$mn:000023D3                 retn
.text$mn:000023D3 ?max_size@?$allocator@_W@std@@QBEIXZ endp
.text$mn:000023D3
.text$mn:000023D3 _text$mn        ends
.text$mn:000023D3
.text$mn:000023D4 ; ===========================================================================
.text$mn:000023D4
.text$mn:000023D4 ; Segment type: Pure code
.text$mn:000023D4 ; Segment permissions: Read/Execute
.text$mn:000023D4 _text$mn        segment para public 'CODE' use32
.text$mn:000023D4                 assume cs:_text$mn
.text$mn:000023D4                 ;org 23D4h
.text$mn:000023D4 ; COMDAT (pick any)
.text$mn:000023D4                 assume es:nothing, ss:nothing, ds:_xdata$x, fs:nothing, gs:nothing
.text$mn:000023D4
.text$mn:000023D4 ; =============== S U B R O U T I N E =======================================
.text$mn:000023D4
.text$mn:000023D4 ; Attributes: bp-based frame
.text$mn:000023D4
.text$mn:000023D4 ; public: static unsigned int __cdecl std::allocator_traits<class std::allocator<char>>::max_size(class std::allocator<char> const &)
.text$mn:000023D4                 public ?max_size@?$allocator_traits@V?$allocator@D@std@@@std@@SAIABV?$allocator@D@2@@Z
.text$mn:000023D4 ?max_size@?$allocator_traits@V?$allocator@D@std@@@std@@SAIABV?$allocator@D@2@@Z proc near
.text$mn:000023D4                                         ; CODE XREF: std::_Wrap_alloc<std::allocator<char>>::max_size(void)+Bp
.text$mn:000023D4
.text$mn:000023D4 arg_0           = dword ptr  8
.text$mn:000023D4
.text$mn:000023D4                 push    ebp
.text$mn:000023D5                 mov     ebp, esp
.text$mn:000023D7                 mov     ecx, [ebp+arg_0]
.text$mn:000023DA                 call    ?max_size@?$allocator@D@std@@QBEIXZ ; std::allocator<char>::max_size(void)
.text$mn:000023DF                 pop     ebp
.text$mn:000023E0                 retn
.text$mn:000023E0 ?max_size@?$allocator_traits@V?$allocator@D@std@@@std@@SAIABV?$allocator@D@2@@Z endp
.text$mn:000023E0
.text$mn:000023E0 ; ---------------------------------------------------------------------------
.text$mn:000023E1                 align 4
.text$mn:000023E1 _text$mn        ends
.text$mn:000023E1
.text$mn:000023E4 ; ===========================================================================
.text$mn:000023E4
.text$mn:000023E4 ; Segment type: Pure code
.text$mn:000023E4 ; Segment permissions: Read/Execute
.text$mn:000023E4 _text$mn        segment para public 'CODE' use32
.text$mn:000023E4                 assume cs:_text$mn
.text$mn:000023E4                 ;org 23E4h
.text$mn:000023E4 ; COMDAT (pick any)
.text$mn:000023E4                 assume es:nothing, ss:nothing, ds:_xdata$x, fs:nothing, gs:nothing
.text$mn:000023E4
.text$mn:000023E4 ; =============== S U B R O U T I N E =======================================
.text$mn:000023E4
.text$mn:000023E4 ; Attributes: bp-based frame
.text$mn:000023E4
.text$mn:000023E4 ; public: static unsigned int __cdecl std::allocator_traits<class std::allocator<wchar_t>>::max_size(class std::allocator<wchar_t> const &)
.text$mn:000023E4                 public ?max_size@?$allocator_traits@V?$allocator@_W@std@@@std@@SAIABV?$allocator@_W@2@@Z
.text$mn:000023E4 ?max_size@?$allocator_traits@V?$allocator@_W@std@@@std@@SAIABV?$allocator@_W@2@@Z proc near
.text$mn:000023E4                                         ; CODE XREF: std::_Wrap_alloc<std::allocator<wchar_t>>::max_size(void)+Bp
.text$mn:000023E4
.text$mn:000023E4 arg_0           = dword ptr  8
.text$mn:000023E4
.text$mn:000023E4                 push    ebp
.text$mn:000023E5                 mov     ebp, esp
.text$mn:000023E7                 mov     ecx, [ebp+arg_0]
.text$mn:000023EA                 call    ?max_size@?$allocator@_W@std@@QBEIXZ ; std::allocator<wchar_t>::max_size(void)
.text$mn:000023EF                 pop     ebp
.text$mn:000023F0                 retn
.text$mn:000023F0 ?max_size@?$allocator_traits@V?$allocator@_W@std@@@std@@SAIABV?$allocator@_W@2@@Z endp
.text$mn:000023F0
.text$mn:000023F0 ; ---------------------------------------------------------------------------
.text$mn:000023F1                 align 4
.text$mn:000023F1 _text$mn        ends
.text$mn:000023F1
.text$mn:000023F4 ; ===========================================================================
.text$mn:000023F4
.text$mn:000023F4 ; Segment type: Pure code
.text$mn:000023F4 ; Segment permissions: Read/Execute
.text$mn:000023F4 _text$mn        segment para public 'CODE' use32
.text$mn:000023F4                 assume cs:_text$mn
.text$mn:000023F4                 ;org 23F4h
.text$mn:000023F4 ; COMDAT (pick any)
.text$mn:000023F4                 assume es:nothing, ss:nothing, ds:_xdata$x, fs:nothing, gs:nothing
.text$mn:000023F4
.text$mn:000023F4 ; =============== S U B R O U T I N E =======================================
.text$mn:000023F4
.text$mn:000023F4 ; Attributes: bp-based frame
.text$mn:000023F4
.text$mn:000023F4 ; public: unsigned int __thiscall std::basic_string<char, struct std::char_traits<char>, class std::allocator<char>>::max_size(void)const
.text$mn:000023F4                 public ?max_size@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QBEIXZ
.text$mn:000023F4 ?max_size@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QBEIXZ proc near
.text$mn:000023F4                                         ; CODE XREF: std::basic_string<char,std::char_traits<char>,std::allocator<char>>::_Copy(uint,uint)+3Bp
.text$mn:000023F4                                         ; std::basic_string<char,std::char_traits<char>,std::allocator<char>>::_Copy(uint,uint)+6Ap ...
.text$mn:000023F4
.text$mn:000023F4 var_10          = dword ptr -10h
.text$mn:000023F4 var_C           = dword ptr -0Ch
.text$mn:000023F4 var_8           = dword ptr -8
.text$mn:000023F4 var_1           = byte ptr -1
.text$mn:000023F4
.text$mn:000023F4                 push    ebp
.text$mn:000023F5                 mov     ebp, esp
.text$mn:000023F7                 sub     esp, 10h
.text$mn:000023FA                 mov     [ebp+var_10], ecx
.text$mn:000023FD                 lea     eax, [ebp+var_1]
.text$mn:00002400                 push    eax
.text$mn:00002401                 mov     ecx, [ebp+var_10]
.text$mn:00002404                 call    ?_Getal@?$_String_alloc@$0A@U?$_String_base_types@DV?$allocator@D@std@@@std@@@std@@QBE?AU?$_Wrap_alloc@V?$allocator@D@std@@@2@XZ ; std::_String_alloc<0,std::_String_base_types<char,std::allocator<char>>>::_Getal(void)
.text$mn:00002409                 mov     ecx, eax
.text$mn:0000240B                 call    ?max_size@?$_Wrap_alloc@V?$allocator@D@std@@@std@@QBEIXZ ; std::_Wrap_alloc<std::allocator<char>>::max_size(void)
.text$mn:00002410                 mov     [ebp+var_8], eax
.text$mn:00002413                 cmp     [ebp+var_8], 1
.text$mn:00002417                 ja      short loc_2422
.text$mn:00002419                 mov     [ebp+var_C], 1
.text$mn:00002420                 jmp     short loc_242B
.text$mn:00002422 ; ---------------------------------------------------------------------------
.text$mn:00002422
.text$mn:00002422 loc_2422:                               ; CODE XREF: std::basic_string<char,std::char_traits<char>,std::allocator<char>>::max_size(void)+23j
.text$mn:00002422                 mov     ecx, [ebp+var_8]
.text$mn:00002425                 sub     ecx, 1
.text$mn:00002428                 mov     [ebp+var_C], ecx
.text$mn:0000242B
.text$mn:0000242B loc_242B:                               ; CODE XREF: std::basic_string<char,std::char_traits<char>,std::allocator<char>>::max_size(void)+2Cj
.text$mn:0000242B                 mov     eax, [ebp+var_C]
.text$mn:0000242E                 mov     esp, ebp
.text$mn:00002430                 pop     ebp
.text$mn:00002431                 retn
.text$mn:00002431 ?max_size@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QBEIXZ endp
.text$mn:00002431
.text$mn:00002431 ; ---------------------------------------------------------------------------
.text$mn:00002432                 align 4
.text$mn:00002432 _text$mn        ends
.text$mn:00002432
.text$mn:00002434 ; ===========================================================================
.text$mn:00002434
.text$mn:00002434 ; Segment type: Pure code
.text$mn:00002434 ; Segment permissions: Read/Execute
.text$mn:00002434 _text$mn        segment para public 'CODE' use32
.text$mn:00002434                 assume cs:_text$mn
.text$mn:00002434                 ;org 2434h
.text$mn:00002434 ; COMDAT (pick any)
.text$mn:00002434                 assume es:nothing, ss:nothing, ds:_xdata$x, fs:nothing, gs:nothing
.text$mn:00002434
.text$mn:00002434 ; =============== S U B R O U T I N E =======================================
.text$mn:00002434
.text$mn:00002434 ; Attributes: bp-based frame
.text$mn:00002434
.text$mn:00002434 ; public: unsigned int __thiscall std::basic_string<wchar_t, struct std::char_traits<wchar_t>, class std::allocator<wchar_t>>::max_size(void)const
.text$mn:00002434                 public ?max_size@?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QBEIXZ
.text$mn:00002434 ?max_size@?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QBEIXZ proc near
.text$mn:00002434                                         ; CODE XREF: std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>>::_Copy(uint,uint)+3Bp
.text$mn:00002434                                         ; std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>>::_Copy(uint,uint)+6Ap ...
.text$mn:00002434
.text$mn:00002434 var_10          = dword ptr -10h
.text$mn:00002434 var_C           = dword ptr -0Ch
.text$mn:00002434 var_8           = dword ptr -8
.text$mn:00002434 var_1           = byte ptr -1
.text$mn:00002434
.text$mn:00002434                 push    ebp
.text$mn:00002435                 mov     ebp, esp
.text$mn:00002437                 sub     esp, 10h
.text$mn:0000243A                 mov     [ebp+var_10], ecx
.text$mn:0000243D                 lea     eax, [ebp+var_1]
.text$mn:00002440                 push    eax
.text$mn:00002441                 mov     ecx, [ebp+var_10]
.text$mn:00002444                 call    ?_Getal@?$_String_alloc@$0A@U?$_String_base_types@_WV?$allocator@_W@std@@@std@@@std@@QBE?AU?$_Wrap_alloc@V?$allocator@_W@std@@@2@XZ ; std::_String_alloc<0,std::_String_base_types<wchar_t,std::allocator<wchar_t>>>::_Getal(void)
.text$mn:00002449                 mov     ecx, eax
.text$mn:0000244B                 call    ?max_size@?$_Wrap_alloc@V?$allocator@_W@std@@@std@@QBEIXZ ; std::_Wrap_alloc<std::allocator<wchar_t>>::max_size(void)
.text$mn:00002450                 mov     [ebp+var_8], eax
.text$mn:00002453                 cmp     [ebp+var_8], 1
.text$mn:00002457                 ja      short loc_2462
.text$mn:00002459                 mov     [ebp+var_C], 1
.text$mn:00002460                 jmp     short loc_246B
.text$mn:00002462 ; ---------------------------------------------------------------------------
.text$mn:00002462
.text$mn:00002462 loc_2462:                               ; CODE XREF: std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>>::max_size(void)+23j
.text$mn:00002462                 mov     ecx, [ebp+var_8]
.text$mn:00002465                 sub     ecx, 1
.text$mn:00002468                 mov     [ebp+var_C], ecx
.text$mn:0000246B
.text$mn:0000246B loc_246B:                               ; CODE XREF: std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>>::max_size(void)+2Cj
.text$mn:0000246B                 mov     eax, [ebp+var_C]
.text$mn:0000246E                 mov     esp, ebp
.text$mn:00002470                 pop     ebp
.text$mn:00002471                 retn
.text$mn:00002471 ?max_size@?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QBEIXZ endp
.text$mn:00002471
.text$mn:00002471 ; ---------------------------------------------------------------------------
.text$mn:00002472                 align 4
.text$mn:00002472 _text$mn        ends
.text$mn:00002472
.text$mn:00002474 ; ===========================================================================
.text$mn:00002474
.text$mn:00002474 ; Segment type: Pure code
.text$mn:00002474 ; Segment permissions: Read/Execute
.text$mn:00002474 _text$mn        segment para public 'CODE' use32
.text$mn:00002474                 assume cs:_text$mn
.text$mn:00002474                 ;org 2474h
.text$mn:00002474 ; COMDAT (pick any)
.text$mn:00002474                 assume es:nothing, ss:nothing, ds:_xdata$x, fs:nothing, gs:nothing
.text$mn:00002474
.text$mn:00002474 ; =============== S U B R O U T I N E =======================================
.text$mn:00002474
.text$mn:00002474 ; Attributes: bp-based frame
.text$mn:00002474
.text$mn:00002474 ; public: virtual class std::basic_string<char, struct std::char_traits<char>, class std::allocator<char>> __thiscall std::_Generic_error_category::message(int)const
.text$mn:00002474                 public ?message@_Generic_error_category@std@@UBE?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@2@H@Z
.text$mn:00002474 ?message@_Generic_error_category@std@@UBE?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@2@H@Z proc near
.text$mn:00002474                                         ; CODE XREF: std::_Iostream_error_category::message(int)+64p
.text$mn:00002474                                         ; DATA XREF: .rdata:00002C74o
.text$mn:00002474
.text$mn:00002474 var_1C          = dword ptr -1Ch
.text$mn:00002474 var_18          = dword ptr -18h
.text$mn:00002474 Str             = dword ptr -14h
.text$mn:00002474 var_10          = dword ptr -10h
.text$mn:00002474 var_C           = dword ptr -0Ch
.text$mn:00002474 var_4           = dword ptr -4
.text$mn:00002474 arg_0           = dword ptr  8
.text$mn:00002474 arg_4           = dword ptr  0Ch
.text$mn:00002474
.text$mn:00002474                 push    ebp
.text$mn:00002475                 mov     ebp, esp
.text$mn:00002477                 push    0FFFFFFFFh
.text$mn:00002479                 push    offset __ehhandler$?message@_Generic_error_category@std@@UBE?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@2@H@Z
.text$mn:0000247E                 mov     eax, large fs:0
.text$mn:00002484                 push    eax
.text$mn:00002485                 sub     esp, 10h
.text$mn:00002488                 mov     eax, dword ptr ds:___security_cookie
.text$mn:0000248D                 xor     eax, ebp
.text$mn:0000248F                 push    eax
.text$mn:00002490                 lea     eax, [ebp+var_C]
.text$mn:00002493                 mov     large fs:0, eax
.text$mn:00002499                 mov     [ebp+var_1C], ecx
.text$mn:0000249C                 mov     [ebp+var_18], 0
.text$mn:000024A3                 mov     eax, [ebp+arg_4]
.text$mn:000024A6                 push    eax             ; int
.text$mn:000024A7                 call    ?_Syserror_map@std@@YAPBDH@Z ; std::_Syserror_map(int)
.text$mn:000024AC                 add     esp, 4
.text$mn:000024AF                 mov     [ebp+var_10], eax
.text$mn:000024B2                 cmp     [ebp+var_10], 0
.text$mn:000024B6                 jz      short loc_24C0
.text$mn:000024B8                 mov     ecx, [ebp+var_10]
.text$mn:000024BB                 mov     [ebp+Str], ecx
.text$mn:000024BE                 jmp     short loc_24C7
.text$mn:000024C0 ; ---------------------------------------------------------------------------
.text$mn:000024C0
.text$mn:000024C0 loc_24C0:                               ; CODE XREF: std::_Generic_error_category::message(int)+42j
.text$mn:000024C0                 mov     [ebp+Str], offset ??_C@_0O@BFJCFAAK@unknown?5error?$AA@ ; "unknown error"
.text$mn:000024C7
.text$mn:000024C7 loc_24C7:                               ; CODE XREF: std::_Generic_error_category::message(int)+4Aj
.text$mn:000024C7                 mov     edx, [ebp+Str]
.text$mn:000024CA                 push    edx             ; Str
.text$mn:000024CB                 mov     ecx, [ebp+arg_0]
.text$mn:000024CE                 call    ??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@PBD@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char>>::basic_string<char,std::char_traits<char>,std::allocator<char>>(char const *)
.text$mn:000024D3                 mov     [ebp+var_4], 0
.text$mn:000024DA                 mov     eax, [ebp+var_18]
.text$mn:000024DD                 or      eax, 1
.text$mn:000024E0                 mov     [ebp+var_18], eax
.text$mn:000024E3                 mov     eax, [ebp+arg_0]
.text$mn:000024E6                 mov     ecx, [ebp+var_C]
.text$mn:000024E9                 mov     large fs:0, ecx
.text$mn:000024F0                 pop     ecx
.text$mn:000024F1                 mov     esp, ebp
.text$mn:000024F3                 pop     ebp
.text$mn:000024F4                 retn    8
.text$mn:000024F4 ?message@_Generic_error_category@std@@UBE?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@2@H@Z endp
.text$mn:000024F4
.text$mn:000024F4 ; ---------------------------------------------------------------------------
.text$mn:000024F7                 align 4
.text$mn:000024F7 _text$mn        ends
.text$mn:000024F7
.text$x:000024F8 ; ===========================================================================
.text$x:000024F8
.text$x:000024F8 ; Segment type: Pure code
.text$x:000024F8 ; Segment permissions: Read/Execute
.text$x:000024F8 _text$x         segment para public 'CODE' use32
.text$x:000024F8                 assume cs:_text$x
.text$x:000024F8                 ;org 24F8h
.text$x:000024F8 ; COMDAT (pick associative to section at 2474)
.text$x:000024F8                 assume es:nothing, ss:nothing, ds:_xdata$x, fs:nothing, gs:nothing
.text$x:000024F8
.text$x:000024F8 ; =============== S U B R O U T I N E =======================================
.text$x:000024F8
.text$x:000024F8
.text$x:000024F8 __unwindfunclet$?message@_Generic_error_category@std@@UBE?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@2@H@Z$0 proc near
.text$x:000024F8                                         ; DATA XREF: .xdata$x:000029DCo
.text$x:000024F8                 mov     eax, [ebp-18h]
.text$x:000024FB                 and     eax, 1
.text$x:000024FE                 jz      $LN6
.text$x:00002504                 and     dword ptr [ebp-18h], 0FFFFFFFEh
.text$x:00002508                 mov     ecx, [ebp+8]
.text$x:0000250B                 jmp     ??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char>>::~basic_string<char,std::char_traits<char>,std::allocator<char>>(void)
.text$x:00002510 ; ---------------------------------------------------------------------------
.text$x:00002510
.text$x:00002510 $LN6:                                   ; CODE XREF: __unwindfunclet$?message@_Generic_error_category@std@@UBE?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@2@H@Z$0+6j
.text$x:00002510                 retn
.text$x:00002510 __unwindfunclet$?message@_Generic_error_category@std@@UBE?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@2@H@Z$0 endp
.text$x:00002510
.text$x:00002511
.text$x:00002511 ; =============== S U B R O U T I N E =======================================
.text$x:00002511
.text$x:00002511
.text$x:00002511 __ehhandler$?message@_Generic_error_category@std@@UBE?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@2@H@Z proc near
.text$x:00002511                                         ; DATA XREF: std::_Generic_error_category::message(int)+5o
.text$x:00002511
.text$x:00002511 arg_4           = dword ptr  8
.text$x:00002511
.text$x:00002511                 mov     edx, [esp+arg_4]
.text$x:00002515                 lea     eax, [edx+0Ch]
.text$x:00002518                 mov     ecx, [edx-14h]
.text$x:0000251B                 xor     ecx, eax
.text$x:0000251D                 call    @__security_check_cookie@4 ; __security_check_cookie(x)
.text$x:00002522                 mov     eax, offset __ehfuncinfo$?message@_Generic_error_category@std@@UBE?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@2@H@Z
.text$x:00002527                 jmp     ___CxxFrameHandler3
.text$x:00002527 __ehhandler$?message@_Generic_error_category@std@@UBE?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@2@H@Z endp
.text$x:00002527
.text$x:00002527 _text$x         ends
.text$x:00002527
.text$mn:0000252C ; ===========================================================================
.text$mn:0000252C
.text$mn:0000252C ; Segment type: Pure code
.text$mn:0000252C ; Segment permissions: Read/Execute
.text$mn:0000252C _text$mn        segment para public 'CODE' use32
.text$mn:0000252C                 assume cs:_text$mn
.text$mn:0000252C                 ;org 252Ch
.text$mn:0000252C ; COMDAT (pick any)
.text$mn:0000252C                 assume es:nothing, ss:nothing, ds:_xdata$x, fs:nothing, gs:nothing
.text$mn:0000252C
.text$mn:0000252C ; =============== S U B R O U T I N E =======================================
.text$mn:0000252C
.text$mn:0000252C ; Attributes: bp-based frame
.text$mn:0000252C
.text$mn:0000252C ; public: virtual class std::basic_string<char, struct std::char_traits<char>, class std::allocator<char>> __thiscall std::_Iostream_error_category::message(int)const
.text$mn:0000252C                 public ?message@_Iostream_error_category@std@@UBE?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@2@H@Z
.text$mn:0000252C ?message@_Iostream_error_category@std@@UBE?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@2@H@Z proc near
.text$mn:0000252C                                         ; DATA XREF: .rdata:00002CA8o
.text$mn:0000252C
.text$mn:0000252C var_14          = dword ptr -14h
.text$mn:0000252C var_10          = dword ptr -10h
.text$mn:0000252C var_C           = dword ptr -0Ch
.text$mn:0000252C var_4           = dword ptr -4
.text$mn:0000252C arg_0           = dword ptr  8
.text$mn:0000252C arg_4           = dword ptr  0Ch
.text$mn:0000252C
.text$mn:0000252C                 push    ebp
.text$mn:0000252D                 mov     ebp, esp
.text$mn:0000252F                 push    0FFFFFFFFh
.text$mn:00002531                 push    offset __ehhandler$?message@_Iostream_error_category@std@@UBE?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@2@H@Z
.text$mn:00002536                 mov     eax, large fs:0
.text$mn:0000253C                 push    eax
.text$mn:0000253D                 sub     esp, 8
.text$mn:00002540                 mov     eax, dword ptr ds:___security_cookie
.text$mn:00002545                 xor     eax, ebp
.text$mn:00002547                 push    eax
.text$mn:00002548                 lea     eax, [ebp+var_C]
.text$mn:0000254B                 mov     large fs:0, eax
.text$mn:00002551                 mov     [ebp+var_14], ecx
.text$mn:00002554                 mov     [ebp+var_10], 0
.text$mn:0000255B                 cmp     [ebp+arg_4], 1
.text$mn:0000255F                 jnz     short loc_2585
.text$mn:00002561                 push    offset ??_C@_0BG@PADBLCHM@iostream?5stream?5error?$AA@ ; "iostream stream error"
.text$mn:00002566                 mov     ecx, [ebp+arg_0]
.text$mn:00002569                 call    ??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@PBD@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char>>::basic_string<char,std::char_traits<char>,std::allocator<char>>(char const *)
.text$mn:0000256E                 mov     [ebp+var_4], 0
.text$mn:00002575                 mov     eax, [ebp+var_10]
.text$mn:00002578                 or      eax, 1
.text$mn:0000257B                 mov     [ebp+var_10], eax
.text$mn:0000257E                 mov     eax, [ebp+arg_0]
.text$mn:00002581                 jmp     short loc_25A8
.text$mn:00002583 ; ---------------------------------------------------------------------------
.text$mn:00002583                 jmp     short loc_25A8
.text$mn:00002585 ; ---------------------------------------------------------------------------
.text$mn:00002585
.text$mn:00002585 loc_2585:                               ; CODE XREF: std::_Iostream_error_category::message(int)+33j
.text$mn:00002585                 mov     ecx, [ebp+arg_4]
.text$mn:00002588                 push    ecx
.text$mn:00002589                 mov     edx, [ebp+arg_0]
.text$mn:0000258C                 push    edx
.text$mn:0000258D                 mov     ecx, [ebp+var_14]
.text$mn:00002590                 call    ?message@_Generic_error_category@std@@UBE?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@2@H@Z ; std::_Generic_error_category::message(int)
.text$mn:00002595                 mov     [ebp+var_4], 0
.text$mn:0000259C                 mov     eax, [ebp+var_10]
.text$mn:0000259F                 or      eax, 1
.text$mn:000025A2                 mov     [ebp+var_10], eax
.text$mn:000025A5                 mov     eax, [ebp+arg_0]
.text$mn:000025A8
.text$mn:000025A8 loc_25A8:                               ; CODE XREF: std::_Iostream_error_category::message(int)+55j
.text$mn:000025A8                                         ; std::_Iostream_error_category::message(int)+57j
.text$mn:000025A8                 mov     ecx, [ebp+var_C]
.text$mn:000025AB                 mov     large fs:0, ecx
.text$mn:000025B2                 pop     ecx
.text$mn:000025B3                 mov     esp, ebp
.text$mn:000025B5                 pop     ebp
.text$mn:000025B6                 retn    8
.text$mn:000025B6 ?message@_Iostream_error_category@std@@UBE?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@2@H@Z endp
.text$mn:000025B6
.text$mn:000025B6 ; ---------------------------------------------------------------------------
.text$mn:000025B9                 align 4
.text$mn:000025B9 _text$mn        ends
.text$mn:000025B9
.text$x:000025BC ; ===========================================================================
.text$x:000025BC
.text$x:000025BC ; Segment type: Pure code
.text$x:000025BC ; Segment permissions: Read/Execute
.text$x:000025BC _text$x         segment para public 'CODE' use32
.text$x:000025BC                 assume cs:_text$x
.text$x:000025BC                 ;org 25BCh
.text$x:000025BC ; COMDAT (pick associative to section at 252C)
.text$x:000025BC                 assume es:nothing, ss:nothing, ds:_xdata$x, fs:nothing, gs:nothing
.text$x:000025BC
.text$x:000025BC ; =============== S U B R O U T I N E =======================================
.text$x:000025BC
.text$x:000025BC
.text$x:000025BC __unwindfunclet$?message@_Iostream_error_category@std@@UBE?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@2@H@Z$0 proc near
.text$x:000025BC                                         ; DATA XREF: .xdata$x:00002A60o
.text$x:000025BC                 mov     eax, [ebp-10h]
.text$x:000025BF                 and     eax, 1
.text$x:000025C2                 jz      $LN6_0
.text$x:000025C8                 and     dword ptr [ebp-10h], 0FFFFFFFEh
.text$x:000025CC                 mov     ecx, [ebp+8]
.text$x:000025CF                 jmp     ??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char>>::~basic_string<char,std::char_traits<char>,std::allocator<char>>(void)
.text$x:000025D4 ; ---------------------------------------------------------------------------
.text$x:000025D4
.text$x:000025D4 $LN6_0:                                 ; CODE XREF: __unwindfunclet$?message@_Iostream_error_category@std@@UBE?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@2@H@Z$0+6j
.text$x:000025D4                 retn
.text$x:000025D4 __unwindfunclet$?message@_Iostream_error_category@std@@UBE?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@2@H@Z$0 endp
.text$x:000025D4
.text$x:000025D5
.text$x:000025D5 ; =============== S U B R O U T I N E =======================================
.text$x:000025D5
.text$x:000025D5
.text$x:000025D5 __ehhandler$?message@_Iostream_error_category@std@@UBE?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@2@H@Z proc near
.text$x:000025D5                                         ; DATA XREF: std::_Iostream_error_category::message(int)+5o
.text$x:000025D5
.text$x:000025D5 arg_4           = dword ptr  8
.text$x:000025D5
.text$x:000025D5                 mov     edx, [esp+arg_4]
.text$x:000025D9                 lea     eax, [edx+0Ch]
.text$x:000025DC                 mov     ecx, [edx-0Ch]
.text$x:000025DF                 xor     ecx, eax
.text$x:000025E1                 call    @__security_check_cookie@4 ; __security_check_cookie(x)
.text$x:000025E6                 mov     eax, offset __ehfuncinfo$?message@_Iostream_error_category@std@@UBE?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@2@H@Z
.text$x:000025EB                 jmp     ___CxxFrameHandler3
.text$x:000025EB __ehhandler$?message@_Iostream_error_category@std@@UBE?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@2@H@Z endp
.text$x:000025EB
.text$x:000025EB _text$x         ends
.text$x:000025EB
.text$mn:000025F0 ; ===========================================================================
.text$mn:000025F0
.text$mn:000025F0 ; Segment type: Pure code
.text$mn:000025F0 ; Segment permissions: Read/Execute
.text$mn:000025F0 _text$mn        segment para public 'CODE' use32
.text$mn:000025F0                 assume cs:_text$mn
.text$mn:000025F0                 ;org 25F0h
.text$mn:000025F0 ; COMDAT (pick any)
.text$mn:000025F0                 assume es:nothing, ss:nothing, ds:_xdata$x, fs:nothing, gs:nothing
.text$mn:000025F0
.text$mn:000025F0 ; =============== S U B R O U T I N E =======================================
.text$mn:000025F0
.text$mn:000025F0 ; Attributes: bp-based frame
.text$mn:000025F0
.text$mn:000025F0 ; public: virtual class std::basic_string<char, struct std::char_traits<char>, class std::allocator<char>> __thiscall std::_System_error_category::message(int)const
.text$mn:000025F0                 public ?message@_System_error_category@std@@UBE?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@2@H@Z
.text$mn:000025F0 ?message@_System_error_category@std@@UBE?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@2@H@Z proc near
.text$mn:000025F0                                         ; DATA XREF: .rdata:00002CE8o
.text$mn:000025F0
.text$mn:000025F0 var_1C          = dword ptr -1Ch
.text$mn:000025F0 var_18          = dword ptr -18h
.text$mn:000025F0 Str             = dword ptr -14h
.text$mn:000025F0 var_10          = dword ptr -10h
.text$mn:000025F0 var_C           = dword ptr -0Ch
.text$mn:000025F0 var_4           = dword ptr -4
.text$mn:000025F0 arg_0           = dword ptr  8
.text$mn:000025F0 arg_4           = dword ptr  0Ch
.text$mn:000025F0
.text$mn:000025F0                 push    ebp
.text$mn:000025F1                 mov     ebp, esp
.text$mn:000025F3                 push    0FFFFFFFFh
.text$mn:000025F5                 push    offset __ehhandler$?message@_System_error_category@std@@UBE?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@2@H@Z
.text$mn:000025FA                 mov     eax, large fs:0
.text$mn:00002600                 push    eax
.text$mn:00002601                 sub     esp, 10h
.text$mn:00002604                 mov     eax, dword ptr ds:___security_cookie
.text$mn:00002609                 xor     eax, ebp
.text$mn:0000260B                 push    eax
.text$mn:0000260C                 lea     eax, [ebp+var_C]
.text$mn:0000260F                 mov     large fs:0, eax
.text$mn:00002615                 mov     [ebp+var_1C], ecx
.text$mn:00002618                 mov     [ebp+var_18], 0
.text$mn:0000261F                 mov     eax, [ebp+arg_4]
.text$mn:00002622                 push    eax             ; int
.text$mn:00002623                 call    ?_Winerror_map@std@@YAPBDH@Z ; std::_Winerror_map(int)
.text$mn:00002628                 add     esp, 4
.text$mn:0000262B                 mov     [ebp+var_10], eax
.text$mn:0000262E                 cmp     [ebp+var_10], 0
.text$mn:00002632                 jz      short loc_263C
.text$mn:00002634                 mov     ecx, [ebp+var_10]
.text$mn:00002637                 mov     [ebp+Str], ecx
.text$mn:0000263A                 jmp     short loc_2643
.text$mn:0000263C ; ---------------------------------------------------------------------------
.text$mn:0000263C
.text$mn:0000263C loc_263C:                               ; CODE XREF: std::_System_error_category::message(int)+42j
.text$mn:0000263C                 mov     [ebp+Str], offset ??_C@_0O@BFJCFAAK@unknown?5error?$AA@ ; "unknown error"
.text$mn:00002643
.text$mn:00002643 loc_2643:                               ; CODE XREF: std::_System_error_category::message(int)+4Aj
.text$mn:00002643                 mov     edx, [ebp+Str]
.text$mn:00002646                 push    edx             ; Str
.text$mn:00002647                 mov     ecx, [ebp+arg_0]
.text$mn:0000264A                 call    ??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@PBD@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char>>::basic_string<char,std::char_traits<char>,std::allocator<char>>(char const *)
.text$mn:0000264F                 mov     [ebp+var_4], 0
.text$mn:00002656                 mov     eax, [ebp+var_18]
.text$mn:00002659                 or      eax, 1
.text$mn:0000265C                 mov     [ebp+var_18], eax
.text$mn:0000265F                 mov     eax, [ebp+arg_0]
.text$mn:00002662                 mov     ecx, [ebp+var_C]
.text$mn:00002665                 mov     large fs:0, ecx
.text$mn:0000266C                 pop     ecx
.text$mn:0000266D                 mov     esp, ebp
.text$mn:0000266F                 pop     ebp
.text$mn:00002670                 retn    8
.text$mn:00002670 ?message@_System_error_category@std@@UBE?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@2@H@Z endp
.text$mn:00002670
.text$mn:00002670 ; ---------------------------------------------------------------------------
.text$mn:00002673                 align 4
.text$mn:00002673 _text$mn        ends
.text$mn:00002673
.text$x:00002674 ; ===========================================================================
.text$x:00002674
.text$x:00002674 ; Segment type: Pure code
.text$x:00002674 ; Segment permissions: Read/Execute
.text$x:00002674 _text$x         segment para public 'CODE' use32
.text$x:00002674                 assume cs:_text$x
.text$x:00002674                 ;org 2674h
.text$x:00002674 ; COMDAT (pick associative to section at 25F0)
.text$x:00002674                 assume es:nothing, ss:nothing, ds:_xdata$x, fs:nothing, gs:nothing
.text$x:00002674
.text$x:00002674 ; =============== S U B R O U T I N E =======================================
.text$x:00002674
.text$x:00002674
.text$x:00002674 __unwindfunclet$?message@_System_error_category@std@@UBE?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@2@H@Z$0 proc near
.text$x:00002674                                         ; DATA XREF: .xdata$x:00002AE4o
.text$x:00002674                 mov     eax, [ebp-18h]
.text$x:00002677                 and     eax, 1
.text$x:0000267A                 jz      $LN6_1
.text$x:00002680                 and     dword ptr [ebp-18h], 0FFFFFFFEh
.text$x:00002684                 mov     ecx, [ebp+8]
.text$x:00002687                 jmp     ??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char>>::~basic_string<char,std::char_traits<char>,std::allocator<char>>(void)
.text$x:0000268C ; ---------------------------------------------------------------------------
.text$x:0000268C
.text$x:0000268C $LN6_1:                                 ; CODE XREF: __unwindfunclet$?message@_System_error_category@std@@UBE?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@2@H@Z$0+6j
.text$x:0000268C                 retn
.text$x:0000268C __unwindfunclet$?message@_System_error_category@std@@UBE?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@2@H@Z$0 endp
.text$x:0000268C
.text$x:0000268D
.text$x:0000268D ; =============== S U B R O U T I N E =======================================
.text$x:0000268D
.text$x:0000268D
.text$x:0000268D __ehhandler$?message@_System_error_category@std@@UBE?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@2@H@Z proc near
.text$x:0000268D                                         ; DATA XREF: std::_System_error_category::message(int)+5o
.text$x:0000268D
.text$x:0000268D arg_4           = dword ptr  8
.text$x:0000268D
.text$x:0000268D                 mov     edx, [esp+arg_4]
.text$x:00002691                 lea     eax, [edx+0Ch]
.text$x:00002694                 mov     ecx, [edx-14h]
.text$x:00002697                 xor     ecx, eax
.text$x:00002699                 call    @__security_check_cookie@4 ; __security_check_cookie(x)
.text$x:0000269E                 mov     eax, offset __ehfuncinfo$?message@_System_error_category@std@@UBE?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@2@H@Z
.text$x:000026A3                 jmp     ___CxxFrameHandler3
.text$x:000026A3 __ehhandler$?message@_System_error_category@std@@UBE?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@2@H@Z endp
.text$x:000026A3
.text$x:000026A3 _text$x         ends
.text$x:000026A3
.text$mn:000026A8 ; ===========================================================================
.text$mn:000026A8
.text$mn:000026A8 ; Segment type: Pure code
.text$mn:000026A8 ; Segment permissions: Read/Execute
.text$mn:000026A8 _text$mn        segment para public 'CODE' use32
.text$mn:000026A8                 assume cs:_text$mn
.text$mn:000026A8                 ;org 26A8h
.text$mn:000026A8 ; COMDAT (pick any)
.text$mn:000026A8                 assume es:nothing, ss:nothing, ds:_xdata$x, fs:nothing, gs:nothing
.text$mn:000026A8
.text$mn:000026A8 ; =============== S U B R O U T I N E =======================================
.text$mn:000026A8
.text$mn:000026A8 ; Attributes: bp-based frame
.text$mn:000026A8
.text$mn:000026A8 ; int __cdecl std::char_traits<char>::move(void *Dst, void *Src, size_t Size)
.text$mn:000026A8                 public ?move@?$char_traits@D@std@@SAPADPADPBDI@Z
.text$mn:000026A8 ?move@?$char_traits@D@std@@SAPADPADPBDI@Z proc near
.text$mn:000026A8                                         ; CODE XREF: std::basic_string<char,std::char_traits<char>,std::allocator<char>>::erase(uint,uint)+6Ap
.text$mn:000026A8
.text$mn:000026A8 var_4           = dword ptr -4
.text$mn:000026A8 Dst             = dword ptr  8
.text$mn:000026A8 Src             = dword ptr  0Ch
.text$mn:000026A8 Size            = dword ptr  10h
.text$mn:000026A8
.text$mn:000026A8                 push    ebp
.text$mn:000026A9                 mov     ebp, esp
.text$mn:000026AB                 push    ecx
.text$mn:000026AC                 cmp     [ebp+Size], 0
.text$mn:000026B0                 jnz     short loc_26BA
.text$mn:000026B2                 mov     eax, [ebp+Dst]
.text$mn:000026B5                 mov     [ebp+var_4], eax
.text$mn:000026B8                 jmp     short loc_26D1
.text$mn:000026BA ; ---------------------------------------------------------------------------
.text$mn:000026BA
.text$mn:000026BA loc_26BA:                               ; CODE XREF: std::char_traits<char>::move(char *,char const *,uint)+8j
.text$mn:000026BA                 mov     ecx, [ebp+Size]
.text$mn:000026BD                 push    ecx             ; Size
.text$mn:000026BE                 mov     edx, [ebp+Src]
.text$mn:000026C1                 push    edx             ; Src
.text$mn:000026C2                 mov     eax, [ebp+Dst]
.text$mn:000026C5                 push    eax             ; Dst
.text$mn:000026C6                 call    _memmove
.text$mn:000026CB                 add     esp, 0Ch
.text$mn:000026CE                 mov     [ebp+var_4], eax
.text$mn:000026D1
.text$mn:000026D1 loc_26D1:                               ; CODE XREF: std::char_traits<char>::move(char *,char const *,uint)+10j
.text$mn:000026D1                 mov     eax, [ebp+var_4]
.text$mn:000026D4                 mov     esp, ebp
.text$mn:000026D6                 pop     ebp
.text$mn:000026D7                 retn
.text$mn:000026D7 ?move@?$char_traits@D@std@@SAPADPADPBDI@Z endp
.text$mn:000026D7
.text$mn:000026D7 _text$mn        ends
.text$mn:000026D7
.text$mn:000026D8 ; ===========================================================================
.text$mn:000026D8
.text$mn:000026D8 ; Segment type: Pure code
.text$mn:000026D8 ; Segment permissions: Read/Execute
.text$mn:000026D8 _text$mn        segment para public 'CODE' use32
.text$mn:000026D8                 assume cs:_text$mn
.text$mn:000026D8                 ;org 26D8h
.text$mn:000026D8 ; COMDAT (pick any)
.text$mn:000026D8                 assume es:nothing, ss:nothing, ds:_xdata$x, fs:nothing, gs:nothing
.text$mn:000026D8
.text$mn:000026D8 ; =============== S U B R O U T I N E =======================================
.text$mn:000026D8
.text$mn:000026D8 ; Attributes: bp-based frame
.text$mn:000026D8
.text$mn:000026D8 ; int __cdecl std::char_traits<wchar_t>::move(void *Dst, void *Src, int)
.text$mn:000026D8                 public ?move@?$char_traits@_W@std@@SAPA_WPA_WPB_WI@Z
.text$mn:000026D8 ?move@?$char_traits@_W@std@@SAPA_WPA_WPB_WI@Z proc near
.text$mn:000026D8                                         ; CODE XREF: std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>>::erase(uint,uint)+70p
.text$mn:000026D8
.text$mn:000026D8 var_4           = dword ptr -4
.text$mn:000026D8 Dst             = dword ptr  8
.text$mn:000026D8 Src             = dword ptr  0Ch
.text$mn:000026D8 arg_8           = dword ptr  10h
.text$mn:000026D8
.text$mn:000026D8                 push    ebp
.text$mn:000026D9                 mov     ebp, esp
.text$mn:000026DB                 push    ecx
.text$mn:000026DC                 cmp     [ebp+arg_8], 0
.text$mn:000026E0                 jnz     short loc_26EA
.text$mn:000026E2                 mov     eax, [ebp+Dst]
.text$mn:000026E5                 mov     [ebp+var_4], eax
.text$mn:000026E8                 jmp     short loc_2701
.text$mn:000026EA ; ---------------------------------------------------------------------------
.text$mn:000026EA
.text$mn:000026EA loc_26EA:                               ; CODE XREF: std::char_traits<wchar_t>::move(wchar_t *,wchar_t const *,uint)+8j
.text$mn:000026EA                 mov     ecx, [ebp+arg_8]
.text$mn:000026ED                 push    ecx             ; int
.text$mn:000026EE                 mov     edx, [ebp+Src]
.text$mn:000026F1                 push    edx             ; Src
.text$mn:000026F2                 mov     eax, [ebp+Dst]
.text$mn:000026F5                 push    eax             ; Dst
.text$mn:000026F6                 call    _wmemmove
.text$mn:000026FB                 add     esp, 0Ch
.text$mn:000026FE                 mov     [ebp+var_4], eax
.text$mn:00002701
.text$mn:00002701 loc_2701:                               ; CODE XREF: std::char_traits<wchar_t>::move(wchar_t *,wchar_t const *,uint)+10j
.text$mn:00002701                 mov     eax, [ebp+var_4]
.text$mn:00002704                 mov     esp, ebp
.text$mn:00002706                 pop     ebp
.text$mn:00002707                 retn
.text$mn:00002707 ?move@?$char_traits@_W@std@@SAPA_WPA_WPB_WI@Z endp
.text$mn:00002707
.text$mn:00002707 _text$mn        ends
.text$mn:00002707
.text$mn:00002708 ; ===========================================================================
.text$mn:00002708
.text$mn:00002708 ; Segment type: Pure code
.text$mn:00002708 ; Segment permissions: Read/Execute
.text$mn:00002708 _text$mn        segment para public 'CODE' use32
.text$mn:00002708                 assume cs:_text$mn
.text$mn:00002708                 ;org 2708h
.text$mn:00002708 ; COMDAT (pick any)
.text$mn:00002708                 assume es:nothing, ss:nothing, ds:_xdata$x, fs:nothing, gs:nothing
.text$mn:00002708
.text$mn:00002708 ; =============== S U B R O U T I N E =======================================
.text$mn:00002708
.text$mn:00002708 ; Attributes: bp-based frame
.text$mn:00002708
.text$mn:00002708 ; const char *__thiscall std::_Generic_error_category::name(std::_Generic_error_category *__hidden this)
.text$mn:00002708                 public ?name@_Generic_error_category@std@@UBEPBDXZ
.text$mn:00002708 ?name@_Generic_error_category@std@@UBEPBDXZ proc near
.text$mn:00002708                                         ; DATA XREF: .rdata:00002C70o
.text$mn:00002708
.text$mn:00002708 var_4           = dword ptr -4
.text$mn:00002708
.text$mn:00002708                 push    ebp
.text$mn:00002709                 mov     ebp, esp
.text$mn:0000270B                 push    ecx
.text$mn:0000270C                 mov     [ebp+var_4], ecx
.text$mn:0000270F                 mov     eax, offset ??_C@_07DCLBNMLN@generic?$AA@ ; "generic"
.text$mn:00002714                 mov     esp, ebp
.text$mn:00002716                 pop     ebp
.text$mn:00002717                 retn
.text$mn:00002717 ?name@_Generic_error_category@std@@UBEPBDXZ endp
.text$mn:00002717
.text$mn:00002717 _text$mn        ends
.text$mn:00002717
.text$mn:00002718 ; ===========================================================================
.text$mn:00002718
.text$mn:00002718 ; Segment type: Pure code
.text$mn:00002718 ; Segment permissions: Read/Execute
.text$mn:00002718 _text$mn        segment para public 'CODE' use32
.text$mn:00002718                 assume cs:_text$mn
.text$mn:00002718                 ;org 2718h
.text$mn:00002718 ; COMDAT (pick any)
.text$mn:00002718                 assume es:nothing, ss:nothing, ds:_xdata$x, fs:nothing, gs:nothing
.text$mn:00002718
.text$mn:00002718 ; =============== S U B R O U T I N E =======================================
.text$mn:00002718
.text$mn:00002718 ; Attributes: bp-based frame
.text$mn:00002718
.text$mn:00002718 ; const char *__thiscall std::_Iostream_error_category::name(std::_Iostream_error_category *__hidden this)
.text$mn:00002718                 public ?name@_Iostream_error_category@std@@UBEPBDXZ
.text$mn:00002718 ?name@_Iostream_error_category@std@@UBEPBDXZ proc near
.text$mn:00002718                                         ; DATA XREF: .rdata:00002CA4o
.text$mn:00002718
.text$mn:00002718 var_4           = dword ptr -4
.text$mn:00002718
.text$mn:00002718                 push    ebp
.text$mn:00002719                 mov     ebp, esp
.text$mn:0000271B                 push    ecx
.text$mn:0000271C                 mov     [ebp+var_4], ecx
.text$mn:0000271F                 mov     eax, offset ??_C@_08LLGCOLLL@iostream?$AA@ ; "iostream"
.text$mn:00002724                 mov     esp, ebp
.text$mn:00002726                 pop     ebp
.text$mn:00002727                 retn
.text$mn:00002727 ?name@_Iostream_error_category@std@@UBEPBDXZ endp
.text$mn:00002727
.text$mn:00002727 _text$mn        ends
.text$mn:00002727
.text$mn:00002728 ; ===========================================================================
.text$mn:00002728
.text$mn:00002728 ; Segment type: Pure code
.text$mn:00002728 ; Segment permissions: Read/Execute
.text$mn:00002728 _text$mn        segment para public 'CODE' use32
.text$mn:00002728                 assume cs:_text$mn
.text$mn:00002728                 ;org 2728h
.text$mn:00002728 ; COMDAT (pick any)
.text$mn:00002728                 assume es:nothing, ss:nothing, ds:_xdata$x, fs:nothing, gs:nothing
.text$mn:00002728
.text$mn:00002728 ; =============== S U B R O U T I N E =======================================
.text$mn:00002728
.text$mn:00002728 ; Attributes: bp-based frame
.text$mn:00002728
.text$mn:00002728 ; const char *__thiscall std::_System_error_category::name(std::_System_error_category *__hidden this)
.text$mn:00002728                 public ?name@_System_error_category@std@@UBEPBDXZ
.text$mn:00002728 ?name@_System_error_category@std@@UBEPBDXZ proc near
.text$mn:00002728                                         ; DATA XREF: .rdata:00002CE4o
.text$mn:00002728
.text$mn:00002728 var_4           = dword ptr -4
.text$mn:00002728
.text$mn:00002728                 push    ebp
.text$mn:00002729                 mov     ebp, esp
.text$mn:0000272B                 push    ecx
.text$mn:0000272C                 mov     [ebp+var_4], ecx
.text$mn:0000272F                 mov     eax, offset ??_C@_06FHFOAHML@system?$AA@ ; "system"
.text$mn:00002734                 mov     esp, ebp
.text$mn:00002736                 pop     ebp
.text$mn:00002737                 retn
.text$mn:00002737 ?name@_System_error_category@std@@UBEPBDXZ endp
.text$mn:00002737
.text$mn:00002737 _text$mn        ends
.text$mn:00002737
.text$mn:00002738 ; ===========================================================================
.text$mn:00002738
.text$mn:00002738 ; Segment type: Pure code
.text$mn:00002738 ; Segment permissions: Read/Execute
.text$mn:00002738 _text$mn        segment para public 'CODE' use32
.text$mn:00002738                 assume cs:_text$mn
.text$mn:00002738                 ;org 2738h
.text$mn:00002738 ; COMDAT (pick any)
.text$mn:00002738                 assume es:nothing, ss:nothing, ds:_xdata$x, fs:nothing, gs:nothing
.text$mn:00002738
.text$mn:00002738 ; =============== S U B R O U T I N E =======================================
.text$mn:00002738
.text$mn:00002738 ; Attributes: bp-based frame
.text$mn:00002738
.text$mn:00002738 ; public: unsigned int __thiscall std::basic_string<char, struct std::char_traits<char>, class std::allocator<char>>::size(void)const
.text$mn:00002738                 public ?size@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QBEIXZ
.text$mn:00002738 ?size@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QBEIXZ proc near
.text$mn:00002738                                         ; CODE XREF: std::basic_string<char,std::char_traits<char>,std::allocator<char>>::assign(std::basic_string<char,std::char_traits<char>,std::allocator<char>> const &,uint,uint)+Cp
.text$mn:00002738                                         ; std::basic_string<char,std::char_traits<char>,std::allocator<char>>::assign(std::basic_string<char,std::char_traits<char>,std::allocator<char>> const &,uint,uint)+21p
.text$mn:00002738
.text$mn:00002738 var_4           = dword ptr -4
.text$mn:00002738
.text$mn:00002738                 push    ebp
.text$mn:00002739                 mov     ebp, esp
.text$mn:0000273B                 push    ecx
.text$mn:0000273C                 mov     [ebp+var_4], ecx
.text$mn:0000273F                 mov     eax, [ebp+var_4]
.text$mn:00002742                 mov     eax, [eax+14h]
.text$mn:00002745                 mov     esp, ebp
.text$mn:00002747                 pop     ebp
.text$mn:00002748                 retn
.text$mn:00002748 ?size@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QBEIXZ endp
.text$mn:00002748
.text$mn:00002748 ; ---------------------------------------------------------------------------
.text$mn:00002749                 align 4
.text$mn:00002749 _text$mn        ends
.text$mn:00002749
.text$mn:0000274C ; ===========================================================================
.text$mn:0000274C
.text$mn:0000274C ; Segment type: Pure code
.text$mn:0000274C ; Segment permissions: Read/Execute
.text$mn:0000274C _text$mn        segment para public 'CODE' use32
.text$mn:0000274C                 assume cs:_text$mn
.text$mn:0000274C                 ;org 274Ch
.text$mn:0000274C ; COMDAT (pick any)
.text$mn:0000274C                 assume es:nothing, ss:nothing, ds:_xdata$x, fs:nothing, gs:nothing
.text$mn:0000274C
.text$mn:0000274C ; =============== S U B R O U T I N E =======================================
.text$mn:0000274C
.text$mn:0000274C ; Attributes: bp-based frame
.text$mn:0000274C
.text$mn:0000274C ; public: unsigned int __thiscall std::basic_string<wchar_t, struct std::char_traits<wchar_t>, class std::allocator<wchar_t>>::size(void)const
.text$mn:0000274C                 public ?size@?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QBEIXZ
.text$mn:0000274C ?size@?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QBEIXZ proc near
.text$mn:0000274C                                         ; CODE XREF: std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>>::assign(std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>> const &,uint,uint)+Cp
.text$mn:0000274C                                         ; std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>>::assign(std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>> const &,uint,uint)+21p
.text$mn:0000274C
.text$mn:0000274C var_4           = dword ptr -4
.text$mn:0000274C
.text$mn:0000274C                 push    ebp
.text$mn:0000274D                 mov     ebp, esp
.text$mn:0000274F                 push    ecx
.text$mn:00002750                 mov     [ebp+var_4], ecx
.text$mn:00002753                 mov     eax, [ebp+var_4]
.text$mn:00002756                 mov     eax, [eax+14h]
.text$mn:00002759                 mov     esp, ebp
.text$mn:0000275B                 pop     ebp
.text$mn:0000275C                 retn
.text$mn:0000275C ?size@?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QBEIXZ endp
.text$mn:0000275C
.text$mn:0000275C ; ---------------------------------------------------------------------------
.text$mn:0000275D                 align 10h
.text$mn:0000275D _text$mn        ends
.text$mn:0000275D
.text$mn:00002760 ; ===========================================================================
.text$mn:00002760
.text$mn:00002760 ; Segment type: Pure code
.text$mn:00002760 ; Segment permissions: Read/Execute
.text$mn:00002760 _text$mn        segment para public 'CODE' use32
.text$mn:00002760                 assume cs:_text$mn
.text$mn:00002760                 ;org 2760h
.text$mn:00002760 ; COMDAT (pick any)
.text$mn:00002760                 assume es:nothing, ss:nothing, ds:_xdata$x, fs:nothing, gs:nothing
.text$mn:00002760
.text$mn:00002760 ; =============== S U B R O U T I N E =======================================
.text$mn:00002760
.text$mn:00002760 ; Attributes: bp-based frame
.text$mn:00002760
.text$mn:00002760 ; const struct std::error_category *__cdecl std::system_category()
.text$mn:00002760                 public ?system_category@std@@YAABVerror_category@1@XZ
.text$mn:00002760 ?system_category@std@@YAABVerror_category@1@XZ proc near
.text$mn:00002760                                         ; CODE XREF: std::_System_error_category::default_error_condition(int):loc_20B8p
.text$mn:00002760                 push    ebp
.text$mn:00002761                 mov     ebp, esp
.text$mn:00002763                 mov     eax, offset ?_System_object@?$_Error_objects@H@std@@2V_System_error_category@2@A ; std::_System_error_category std::_Error_objects<int>::_System_object
.text$mn:00002768                 pop     ebp
.text$mn:00002769                 retn
.text$mn:00002769 ?system_category@std@@YAABVerror_category@1@XZ endp
.text$mn:00002769
.text$mn:00002769 ; ---------------------------------------------------------------------------
.text$mn:0000276A                 align 4
.text$mn:0000276A _text$mn        ends
.text$mn:0000276A
.text$mn:0000276C ; ===========================================================================
.text$mn:0000276C
.text$mn:0000276C ; Segment type: Pure code
.text$mn:0000276C ; Segment permissions: Read/Execute
.text$mn:0000276C _text$mn        segment para public 'CODE' use32
.text$mn:0000276C                 assume cs:_text$mn
.text$mn:0000276C                 ;org 276Ch
.text$mn:0000276C ; COMDAT (pick any)
.text$mn:0000276C                 assume es:nothing, ss:nothing, ds:_xdata$x, fs:nothing, gs:nothing
.text$mn:0000276C
.text$mn:0000276C ; =============== S U B R O U T I N E =======================================
.text$mn:0000276C
.text$mn:0000276C ; Attributes: bp-based frame
.text$mn:0000276C
.text$mn:0000276C ; int __thiscall std::error_code::value(std::error_code *__hidden this)
.text$mn:0000276C                 public ?value@error_code@std@@QBEHXZ
.text$mn:0000276C ?value@error_code@std@@QBEHXZ proc near ; CODE XREF: std::error_category::equivalent(std::error_code const &,int)+24p
.text$mn:0000276C
.text$mn:0000276C var_4           = dword ptr -4
.text$mn:0000276C
.text$mn:0000276C                 push    ebp
.text$mn:0000276D                 mov     ebp, esp
.text$mn:0000276F                 push    ecx
.text$mn:00002770                 mov     [ebp+var_4], ecx
.text$mn:00002773                 mov     eax, [ebp+var_4]
.text$mn:00002776                 mov     eax, [eax]
.text$mn:00002778                 mov     esp, ebp
.text$mn:0000277A                 pop     ebp
.text$mn:0000277B                 retn
.text$mn:0000277B ?value@error_code@std@@QBEHXZ endp
.text$mn:0000277B
.text$mn:0000277B _text$mn        ends
.text$mn:0000277B
.text$mn:0000277C ; ===========================================================================
.text$mn:0000277C
.text$mn:0000277C ; Segment type: Pure code
.text$mn:0000277C ; Segment permissions: Read/Execute
.text$mn:0000277C _text$mn        segment para public 'CODE' use32
.text$mn:0000277C                 assume cs:_text$mn
.text$mn:0000277C                 ;org 277Ch
.text$mn:0000277C ; COMDAT (pick any)
.text$mn:0000277C                 assume es:nothing, ss:nothing, ds:_xdata$x, fs:nothing, gs:nothing
.text$mn:0000277C
.text$mn:0000277C ; =============== S U B R O U T I N E =======================================
.text$mn:0000277C
.text$mn:0000277C ; Attributes: bp-based frame
.text$mn:0000277C
.text$mn:0000277C ; int __thiscall std::error_condition::value(std::error_condition *__hidden this)
.text$mn:0000277C                 public ?value@error_condition@std@@QBEHXZ
.text$mn:0000277C ?value@error_condition@std@@QBEHXZ proc near
.text$mn:0000277C                                         ; CODE XREF: std::error_condition::operator==(std::error_condition const &)+2Cp
.text$mn:0000277C                                         ; std::error_condition::operator==(std::error_condition const &)+36p
.text$mn:0000277C
.text$mn:0000277C var_4           = dword ptr -4
.text$mn:0000277C
.text$mn:0000277C                 push    ebp
.text$mn:0000277D                 mov     ebp, esp
.text$mn:0000277F                 push    ecx
.text$mn:00002780                 mov     [ebp+var_4], ecx
.text$mn:00002783                 mov     eax, [ebp+var_4]
.text$mn:00002786                 mov     eax, [eax]
.text$mn:00002788                 mov     esp, ebp
.text$mn:0000278A                 pop     ebp
.text$mn:0000278B                 retn
.text$mn:0000278B ?value@error_condition@std@@QBEHXZ endp
.text$mn:0000278B
.text$mn:0000278B _text$mn        ends
.text$mn:0000278B
.text$mn:0000278C ; ===========================================================================
.text$mn:0000278C
.text$mn:0000278C ; Segment type: Pure code
.text$mn:0000278C ; Segment permissions: Read/Execute
.text$mn:0000278C _text$mn        segment para public 'CODE' use32
.text$mn:0000278C                 assume cs:_text$mn
.text$mn:0000278C                 ;org 278Ch
.text$mn:0000278C ; COMDAT (pick any)
.text$mn:0000278C                 assume es:nothing, ss:nothing, ds:_xdata$x, fs:nothing, gs:nothing
.text$mn:0000278C
.text$mn:0000278C ; =============== S U B R O U T I N E =======================================
.text$mn:0000278C
.text$mn:0000278C ; Attributes: bp-based frame
.text$mn:0000278C
.text$mn:0000278C                 public _hypot
.text$mn:0000278C _hypot          proc near
.text$mn:0000278C
.text$mn:0000278C var_10          = qword ptr -10h
.text$mn:0000278C var_8           = qword ptr -8
.text$mn:0000278C arg_0           = qword ptr  8
.text$mn:0000278C arg_8           = qword ptr  10h
.text$mn:0000278C
.text$mn:0000278C                 push    ebp
.text$mn:0000278D                 mov     ebp, esp
.text$mn:0000278F                 sub     esp, 8
.text$mn:00002792                 movsd   xmm0, [ebp+arg_8]
.text$mn:00002797                 movsd   [esp+8+var_8], xmm0
.text$mn:0000279C                 sub     esp, 8
.text$mn:0000279F                 movsd   xmm0, [ebp+arg_0]
.text$mn:000027A4                 movsd   [esp+10h+var_10], xmm0
.text$mn:000027A9                 call    __hypot
.text$mn:000027AE                 add     esp, 10h
.text$mn:000027B1                 pop     ebp
.text$mn:000027B2                 retn
.text$mn:000027B2 _hypot          endp
.text$mn:000027B2
.text$mn:000027B2 ; ---------------------------------------------------------------------------
.text$mn:000027B3                 align 4
.text$mn:000027B3 _text$mn        ends
.text$mn:000027B3
.text$mn:000027B4 ; ===========================================================================
.text$mn:000027B4
.text$mn:000027B4 ; Segment type: Pure code
.text$mn:000027B4 ; Segment permissions: Read/Execute
.text$mn:000027B4 _text$mn        segment para public 'CODE' use32
.text$mn:000027B4                 assume cs:_text$mn
.text$mn:000027B4                 ;org 27B4h
.text$mn:000027B4 ; COMDAT (pick any)
.text$mn:000027B4                 assume es:nothing, ss:nothing, ds:_xdata$x, fs:nothing, gs:nothing
.text$mn:000027B4
.text$mn:000027B4 ; =============== S U B R O U T I N E =======================================
.text$mn:000027B4
.text$mn:000027B4 ; Attributes: bp-based frame
.text$mn:000027B4
.text$mn:000027B4 ; int __cdecl wmemcpy(void *Dst, void *Src, int)
.text$mn:000027B4                 public _wmemcpy
.text$mn:000027B4 _wmemcpy        proc near               ; CODE XREF: std::char_traits<wchar_t>::copy(wchar_t *,wchar_t const *,uint)+1Ep
.text$mn:000027B4
.text$mn:000027B4 Dst             = dword ptr  8
.text$mn:000027B4 Src             = dword ptr  0Ch
.text$mn:000027B4 arg_8           = dword ptr  10h
.text$mn:000027B4
.text$mn:000027B4                 push    ebp
.text$mn:000027B5                 mov     ebp, esp
.text$mn:000027B7                 mov     eax, [ebp+arg_8]
.text$mn:000027BA                 shl     eax, 1
.text$mn:000027BC                 push    eax             ; Size
.text$mn:000027BD                 mov     ecx, [ebp+Src]
.text$mn:000027C0                 push    ecx             ; Src
.text$mn:000027C1                 mov     edx, [ebp+Dst]
.text$mn:000027C4                 push    edx             ; Dst
.text$mn:000027C5                 call    _memcpy
.text$mn:000027CA                 add     esp, 0Ch
.text$mn:000027CD                 pop     ebp
.text$mn:000027CE                 retn
.text$mn:000027CE _wmemcpy        endp
.text$mn:000027CE
.text$mn:000027CE ; ---------------------------------------------------------------------------
.text$mn:000027CF                 align 10h
.text$mn:000027CF _text$mn        ends
.text$mn:000027CF
.text$mn:000027D0 ; ===========================================================================
.text$mn:000027D0
.text$mn:000027D0 ; Segment type: Pure code
.text$mn:000027D0 ; Segment permissions: Read/Execute
.text$mn:000027D0 _text$mn        segment para public 'CODE' use32
.text$mn:000027D0                 assume cs:_text$mn
.text$mn:000027D0                 ;org 27D0h
.text$mn:000027D0 ; COMDAT (pick any)
.text$mn:000027D0                 assume es:nothing, ss:nothing, ds:_xdata$x, fs:nothing, gs:nothing
.text$mn:000027D0
.text$mn:000027D0 ; =============== S U B R O U T I N E =======================================
.text$mn:000027D0
.text$mn:000027D0 ; Attributes: bp-based frame
.text$mn:000027D0
.text$mn:000027D0 ; int __cdecl wmemmove(void *Dst, void *Src, int)
.text$mn:000027D0                 public _wmemmove
.text$mn:000027D0 _wmemmove       proc near               ; CODE XREF: std::char_traits<wchar_t>::move(wchar_t *,wchar_t const *,uint)+1Ep
.text$mn:000027D0
.text$mn:000027D0 Dst             = dword ptr  8
.text$mn:000027D0 Src             = dword ptr  0Ch
.text$mn:000027D0 arg_8           = dword ptr  10h
.text$mn:000027D0
.text$mn:000027D0                 push    ebp
.text$mn:000027D1                 mov     ebp, esp
.text$mn:000027D3                 mov     eax, [ebp+arg_8]
.text$mn:000027D6                 shl     eax, 1
.text$mn:000027D8                 push    eax             ; Size
.text$mn:000027D9                 mov     ecx, [ebp+Src]
.text$mn:000027DC                 push    ecx             ; Src
.text$mn:000027DD                 mov     edx, [ebp+Dst]
.text$mn:000027E0                 push    edx             ; Dst
.text$mn:000027E1                 call    _memmove
.text$mn:000027E6                 add     esp, 0Ch
.text$mn:000027E9                 pop     ebp
.text$mn:000027EA                 retn
.text$mn:000027EA _wmemmove       endp
.text$mn:000027EA
.text$mn:000027EA ; ---------------------------------------------------------------------------
.text$mn:000027EB                 align 4
.text$mn:000027EB _text$mn        ends
.text$mn:000027EB
.xdata$x:000027EC ; ===========================================================================
.xdata$x:000027EC
.xdata$x:000027EC ; Segment type: Pure data
.xdata$x:000027EC ; Segment permissions: Read
.xdata$x:000027EC _xdata$x        segment dword public 'DATA' use32
.xdata$x:000027EC                 assume cs:_xdata$x
.xdata$x:000027EC                 ;org 27ECh
.xdata$x:000027EC ; COMDAT (pick associative to section at 1934)
.xdata$x:000027EC __unwindtable$?_Orphan_all@_Container_base12@std@@QAEXXZ db 0FFh
.xdata$x:000027EC                                         ; DATA XREF: .xdata$x:000027FCo
.xdata$x:000027ED                 db 0FFh
.xdata$x:000027EE                 db 0FFh
.xdata$x:000027EF                 db 0FFh
.xdata$x:000027F0                 dd offset __unwindfunclet$?_Orphan_all@_Container_base12@std@@QAEXXZ$0
.xdata$x:000027F4 __ehfuncinfo$?_Orphan_all@_Container_base12@std@@QAEXXZ db  22h ; "
.xdata$x:000027F4                                         ; DATA XREF: __ehhandler$?_Orphan_all@_Container_base12@std@@QAEXXZ+11o
.xdata$x:000027F5                 db    5
.xdata$x:000027F6                 db  93h ; 
.xdata$x:000027F7                 db  19h
.xdata$x:000027F8                 db    1
.xdata$x:000027F9                 db    0
.xdata$x:000027FA                 db    0
.xdata$x:000027FB                 db    0
.xdata$x:000027FC                 dd offset __unwindtable$?_Orphan_all@_Container_base12@std@@QAEXXZ
.xdata$x:00002800                 db    0
.xdata$x:00002801                 db    0
.xdata$x:00002802                 db    0
.xdata$x:00002803                 db    0
.xdata$x:00002804                 db    0
.xdata$x:00002805                 db    0
.xdata$x:00002806                 db    0
.xdata$x:00002807                 db    0
.xdata$x:00002808                 db    0
.xdata$x:00002809                 db    0
.xdata$x:0000280A                 db    0
.xdata$x:0000280B                 db    0
.xdata$x:0000280C                 db    0
.xdata$x:0000280D                 db    0
.xdata$x:0000280E                 db    0
.xdata$x:0000280F                 db    0
.xdata$x:00002810                 db    0
.xdata$x:00002811                 db    0
.xdata$x:00002812                 db    0
.xdata$x:00002813                 db    0
.xdata$x:00002814                 db    0
.xdata$x:00002815                 db    0
.xdata$x:00002816                 db    0
.xdata$x:00002817                 db    0
.xdata$x:00002817 _xdata$x        ends
.xdata$x:00002817
.xdata$x:00002818 ; ===========================================================================
.xdata$x:00002818
.xdata$x:00002818 ; Segment type: Pure data
.xdata$x:00002818 ; Segment permissions: Read
.xdata$x:00002818 _xdata$x        segment dword public 'DATA' use32
.xdata$x:00002818                 assume cs:_xdata$x
.xdata$x:00002818                 ;org 2818h
.xdata$x:00002818 ; COMDAT (pick associative to section at 924)
.xdata$x:00002818 __unwindtable$??0?$_String_val@U?$_Simple_types@D@std@@@std@@QAE@XZ db 0FFh
.xdata$x:00002818                                         ; DATA XREF: .xdata$x:00002828o
.xdata$x:00002819                 db 0FFh
.xdata$x:0000281A                 db 0FFh
.xdata$x:0000281B                 db 0FFh
.xdata$x:0000281C                 dd offset __unwindfunclet$??0?$_String_val@U?$_Simple_types@D@std@@@std@@QAE@XZ$0
.xdata$x:00002820 __ehfuncinfo$??0?$_String_val@U?$_Simple_types@D@std@@@std@@QAE@XZ db  22h ; "
.xdata$x:00002820                                         ; DATA XREF: __ehhandler$??0?$_String_val@U?$_Simple_types@D@std@@@std@@QAE@XZ+11o
.xdata$x:00002821                 db    5
.xdata$x:00002822                 db  93h ; 
.xdata$x:00002823                 db  19h
.xdata$x:00002824                 db    1
.xdata$x:00002825                 db    0
.xdata$x:00002826                 db    0
.xdata$x:00002827                 db    0
.xdata$x:00002828                 dd offset __unwindtable$??0?$_String_val@U?$_Simple_types@D@std@@@std@@QAE@XZ
.xdata$x:0000282C                 db    0
.xdata$x:0000282D                 db    0
.xdata$x:0000282E                 db    0
.xdata$x:0000282F                 db    0
.xdata$x:00002830                 db    0
.xdata$x:00002831                 db    0
.xdata$x:00002832                 db    0
.xdata$x:00002833                 db    0
.xdata$x:00002834                 db    0
.xdata$x:00002835                 db    0
.xdata$x:00002836                 db    0
.xdata$x:00002837                 db    0
.xdata$x:00002838                 db    0
.xdata$x:00002839                 db    0
.xdata$x:0000283A                 db    0
.xdata$x:0000283B                 db    0
.xdata$x:0000283C                 db    0
.xdata$x:0000283D                 db    0
.xdata$x:0000283E                 db    0
.xdata$x:0000283F                 db    0
.xdata$x:00002840                 db    0
.xdata$x:00002841                 db    0
.xdata$x:00002842                 db    0
.xdata$x:00002843                 db    0
.xdata$x:00002843 _xdata$x        ends
.xdata$x:00002843
.xdata$x:00002844 ; ===========================================================================
.xdata$x:00002844
.xdata$x:00002844 ; Segment type: Pure data
.xdata$x:00002844 ; Segment permissions: Read
.xdata$x:00002844 _xdata$x        segment dword public 'DATA' use32
.xdata$x:00002844                 assume cs:_xdata$x
.xdata$x:00002844                 ;org 2844h
.xdata$x:00002844 ; COMDAT (pick associative to section at D20)
.xdata$x:00002844 __unwindtable$??1?$_String_val@U?$_Simple_types@D@std@@@std@@QAE@XZ db 0FFh
.xdata$x:00002844                                         ; DATA XREF: .xdata$x:00002854o
.xdata$x:00002845                 db 0FFh
.xdata$x:00002846                 db 0FFh
.xdata$x:00002847                 db 0FFh
.xdata$x:00002848                 dd offset __unwindfunclet$??1?$_String_val@U?$_Simple_types@D@std@@@std@@QAE@XZ$0
.xdata$x:0000284C __ehfuncinfo$??1?$_String_val@U?$_Simple_types@D@std@@@std@@QAE@XZ db  22h ; "
.xdata$x:0000284C                                         ; DATA XREF: __ehhandler$??1?$_String_val@U?$_Simple_types@D@std@@@std@@QAE@XZ+11o
.xdata$x:0000284D                 db    5
.xdata$x:0000284E                 db  93h ; 
.xdata$x:0000284F                 db  19h
.xdata$x:00002850                 db    1
.xdata$x:00002851                 db    0
.xdata$x:00002852                 db    0
.xdata$x:00002853                 db    0
.xdata$x:00002854                 dd offset __unwindtable$??1?$_String_val@U?$_Simple_types@D@std@@@std@@QAE@XZ
.xdata$x:00002858                 db    0
.xdata$x:00002859                 db    0
.xdata$x:0000285A                 db    0
.xdata$x:0000285B                 db    0
.xdata$x:0000285C                 db    0
.xdata$x:0000285D                 db    0
.xdata$x:0000285E                 db    0
.xdata$x:0000285F                 db    0
.xdata$x:00002860                 db    0
.xdata$x:00002861                 db    0
.xdata$x:00002862                 db    0
.xdata$x:00002863                 db    0
.xdata$x:00002864                 db    0
.xdata$x:00002865                 db    0
.xdata$x:00002866                 db    0
.xdata$x:00002867                 db    0
.xdata$x:00002868                 db    0
.xdata$x:00002869                 db    0
.xdata$x:0000286A                 db    0
.xdata$x:0000286B                 db    0
.xdata$x:0000286C                 db    0
.xdata$x:0000286D                 db    0
.xdata$x:0000286E                 db    0
.xdata$x:0000286F                 db    0
.xdata$x:0000286F _xdata$x        ends
.xdata$x:0000286F
.xdata$x:00002870 ; ===========================================================================
.xdata$x:00002870
.xdata$x:00002870 ; Segment type: Pure data
.xdata$x:00002870 ; Segment permissions: Read
.xdata$x:00002870 _xdata$x        segment dword public 'DATA' use32
.xdata$x:00002870                 assume cs:_xdata$x
.xdata$x:00002870                 ;org 2870h
.xdata$x:00002870 ; COMDAT (pick associative to section at 8A8)
.xdata$x:00002870 __unwindtable$??0?$_String_alloc@$0A@U?$_String_base_types@DV?$allocator@D@std@@@std@@@std@@QAE@ABV?$allocator@D@1@@Z db 0FFh
.xdata$x:00002870                                         ; DATA XREF: .xdata$x:00002880o
.xdata$x:00002871                 db 0FFh
.xdata$x:00002872                 db 0FFh
.xdata$x:00002873                 db 0FFh
.xdata$x:00002874                 dd offset __unwindfunclet$??0?$_String_alloc@$0A@U?$_String_base_types@DV?$allocator@D@std@@@std@@@std@@QAE@ABV?$allocator@D@1@@Z$0
.xdata$x:00002878 __ehfuncinfo$??0?$_String_alloc@$0A@U?$_String_base_types@DV?$allocator@D@std@@@std@@@std@@QAE@ABV?$allocator@D@1@@Z db  22h ; "
.xdata$x:00002878                                         ; DATA XREF: __ehhandler$??0?$_String_alloc@$0A@U?$_String_base_types@DV?$allocator@D@std@@@std@@@std@@QAE@ABV?$allocator@D@1@@Z+11o
.xdata$x:00002879                 db    5
.xdata$x:0000287A                 db  93h ; 
.xdata$x:0000287B                 db  19h
.xdata$x:0000287C                 db    1
.xdata$x:0000287D                 db    0
.xdata$x:0000287E                 db    0
.xdata$x:0000287F                 db    0
.xdata$x:00002880                 dd offset __unwindtable$??0?$_String_alloc@$0A@U?$_String_base_types@DV?$allocator@D@std@@@std@@@std@@QAE@ABV?$allocator@D@1@@Z
.xdata$x:00002884                 db    0
.xdata$x:00002885                 db    0
.xdata$x:00002886                 db    0
.xdata$x:00002887                 db    0
.xdata$x:00002888                 db    0
.xdata$x:00002889                 db    0
.xdata$x:0000288A                 db    0
.xdata$x:0000288B                 db    0
.xdata$x:0000288C                 db    0
.xdata$x:0000288D                 db    0
.xdata$x:0000288E                 db    0
.xdata$x:0000288F                 db    0
.xdata$x:00002890                 db    0
.xdata$x:00002891                 db    0
.xdata$x:00002892                 db    0
.xdata$x:00002893                 db    0
.xdata$x:00002894                 db    0
.xdata$x:00002895                 db    0
.xdata$x:00002896                 db    0
.xdata$x:00002897                 db    0
.xdata$x:00002898                 db    0
.xdata$x:00002899                 db    0
.xdata$x:0000289A                 db    0
.xdata$x:0000289B                 db    0
.xdata$x:0000289B _xdata$x        ends
.xdata$x:0000289B
.xdata$x:0000289C ; ===========================================================================
.xdata$x:0000289C
.xdata$x:0000289C ; Segment type: Pure data
.xdata$x:0000289C ; Segment permissions: Read
.xdata$x:0000289C _xdata$x        segment dword public 'DATA' use32
.xdata$x:0000289C                 assume cs:_xdata$x
.xdata$x:0000289C                 ;org 289Ch
.xdata$x:0000289C ; COMDAT (pick associative to section at CA8)
.xdata$x:0000289C __unwindtable$??1?$_String_alloc@$0A@U?$_String_base_types@DV?$allocator@D@std@@@std@@@std@@QAE@XZ db 0FFh
.xdata$x:0000289C                                         ; DATA XREF: .xdata$x:000028ACo
.xdata$x:0000289D                 db 0FFh
.xdata$x:0000289E                 db 0FFh
.xdata$x:0000289F                 db 0FFh
.xdata$x:000028A0                 dd offset __unwindfunclet$??1?$_String_alloc@$0A@U?$_String_base_types@DV?$allocator@D@std@@@std@@@std@@QAE@XZ$0
.xdata$x:000028A4 __ehfuncinfo$??1?$_String_alloc@$0A@U?$_String_base_types@DV?$allocator@D@std@@@std@@@std@@QAE@XZ db  22h ; "
.xdata$x:000028A4                                         ; DATA XREF: __ehhandler$??1?$_String_alloc@$0A@U?$_String_base_types@DV?$allocator@D@std@@@std@@@std@@QAE@XZ+11o
.xdata$x:000028A5                 db    5
.xdata$x:000028A6                 db  93h ; 
.xdata$x:000028A7                 db  19h
.xdata$x:000028A8                 db    1
.xdata$x:000028A9                 db    0
.xdata$x:000028AA                 db    0
.xdata$x:000028AB                 db    0
.xdata$x:000028AC                 dd offset __unwindtable$??1?$_String_alloc@$0A@U?$_String_base_types@DV?$allocator@D@std@@@std@@@std@@QAE@XZ
.xdata$x:000028B0                 db    0
.xdata$x:000028B1                 db    0
.xdata$x:000028B2                 db    0
.xdata$x:000028B3                 db    0
.xdata$x:000028B4                 db    0
.xdata$x:000028B5                 db    0
.xdata$x:000028B6                 db    0
.xdata$x:000028B7                 db    0
.xdata$x:000028B8                 db    0
.xdata$x:000028B9                 db    0
.xdata$x:000028BA                 db    0
.xdata$x:000028BB                 db    0
.xdata$x:000028BC                 db    0
.xdata$x:000028BD                 db    0
.xdata$x:000028BE                 db    0
.xdata$x:000028BF                 db    0
.xdata$x:000028C0                 db    0
.xdata$x:000028C1                 db    0
.xdata$x:000028C2                 db    0
.xdata$x:000028C3                 db    0
.xdata$x:000028C4                 db    0
.xdata$x:000028C5                 db    0
.xdata$x:000028C6                 db    0
.xdata$x:000028C7                 db    0
.xdata$x:000028C7 _xdata$x        ends
.xdata$x:000028C7
.xdata$x:000028C8 ; ===========================================================================
.xdata$x:000028C8
.xdata$x:000028C8 ; Segment type: Pure data
.xdata$x:000028C8 ; Segment permissions: Read
.xdata$x:000028C8 _xdata$x        segment dword public 'DATA' use32
.xdata$x:000028C8                 assume cs:_xdata$x
.xdata$x:000028C8                 ;org 28C8h
.xdata$x:000028C8 ; COMDAT (pick associative to section at A0C)
.xdata$x:000028C8 __unwindtable$??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@PBD@Z db 0FFh
.xdata$x:000028C8                                         ; DATA XREF: .xdata$x:000028D8o
.xdata$x:000028C9                 db 0FFh
.xdata$x:000028CA                 db 0FFh
.xdata$x:000028CB                 db 0FFh
.xdata$x:000028CC                 dd offset __unwindfunclet$??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@PBD@Z$0
.xdata$x:000028D0 __ehfuncinfo$??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@PBD@Z db  22h ; "
.xdata$x:000028D0                                         ; DATA XREF: __ehhandler$??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@PBD@Z+11o
.xdata$x:000028D1                 db    5
.xdata$x:000028D2                 db  93h ; 
.xdata$x:000028D3                 db  19h
.xdata$x:000028D4                 db    1
.xdata$x:000028D5                 db    0
.xdata$x:000028D6                 db    0
.xdata$x:000028D7                 db    0
.xdata$x:000028D8                 dd offset __unwindtable$??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@PBD@Z
.xdata$x:000028DC                 db    0
.xdata$x:000028DD                 db    0
.xdata$x:000028DE                 db    0
.xdata$x:000028DF                 db    0
.xdata$x:000028E0                 db    0
.xdata$x:000028E1                 db    0
.xdata$x:000028E2                 db    0
.xdata$x:000028E3                 db    0
.xdata$x:000028E4                 db    0
.xdata$x:000028E5                 db    0
.xdata$x:000028E6                 db    0
.xdata$x:000028E7                 db    0
.xdata$x:000028E8                 db    0
.xdata$x:000028E9                 db    0
.xdata$x:000028EA                 db    0
.xdata$x:000028EB                 db    0
.xdata$x:000028EC                 db    0
.xdata$x:000028ED                 db    0
.xdata$x:000028EE                 db    0
.xdata$x:000028EF                 db    0
.xdata$x:000028F0                 db    0
.xdata$x:000028F1                 db    0
.xdata$x:000028F2                 db    0
.xdata$x:000028F3                 db    0
.xdata$x:000028F3 _xdata$x        ends
.xdata$x:000028F3
.xdata$x:000028F4 ; ===========================================================================
.xdata$x:000028F4
.xdata$x:000028F4 ; Segment type: Pure data
.xdata$x:000028F4 ; Segment permissions: Read
.xdata$x:000028F4 _xdata$x        segment dword public 'DATA' use32
.xdata$x:000028F4                 assume cs:_xdata$x
.xdata$x:000028F4                 ;org 28F4h
.xdata$x:000028F4 ; COMDAT (pick associative to section at D90)
.xdata$x:000028F4 __unwindtable$??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ db 0FFh
.xdata$x:000028F4                                         ; DATA XREF: .xdata$x:00002904o
.xdata$x:000028F5                 db 0FFh
.xdata$x:000028F6                 db 0FFh
.xdata$x:000028F7                 db 0FFh
.xdata$x:000028F8                 dd offset __unwindfunclet$??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ$0
.xdata$x:000028FC __ehfuncinfo$??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ db  22h ; "
.xdata$x:000028FC                                         ; DATA XREF: __ehhandler$??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ+11o
.xdata$x:000028FD                 db    5
.xdata$x:000028FE                 db  93h ; 
.xdata$x:000028FF                 db  19h
.xdata$x:00002900                 db    1
.xdata$x:00002901                 db    0
.xdata$x:00002902                 db    0
.xdata$x:00002903                 db    0
.xdata$x:00002904                 dd offset __unwindtable$??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ
.xdata$x:00002908                 align 20h
.xdata$x:00002908 _xdata$x        ends
.xdata$x:00002908
.xdata$x:00002920 ; ===========================================================================
.xdata$x:00002920
.xdata$x:00002920 ; Segment type: Pure data
.xdata$x:00002920 ; Segment permissions: Read
.xdata$x:00002920 _xdata$x        segment dword public 'DATA' use32
.xdata$x:00002920                 assume cs:_xdata$x
.xdata$x:00002920                 ;org 2920h
.xdata$x:00002920 ; COMDAT (pick associative to section at 1224)
.xdata$x:00002920 __catchsym$?_Copy@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEXII@Z$5 db    0
.xdata$x:00002920                                         ; DATA XREF: .xdata$x:000029A8o
.xdata$x:00002921                 db    0
.xdata$x:00002922                 db    0
.xdata$x:00002923                 db    0
.xdata$x:00002924                 db    0
.xdata$x:00002925                 db    0
.xdata$x:00002926                 db    0
.xdata$x:00002927                 db    0
.xdata$x:00002928                 db    0
.xdata$x:00002929                 db    0
.xdata$x:0000292A                 db    0
.xdata$x:0000292B                 db    0
.xdata$x:0000292C                 dd offset __catch$?_Copy@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEXII@Z$0
.xdata$x:00002930 __catchsym$?_Copy@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEXII@Z$4 db    0
.xdata$x:00002930                                         ; DATA XREF: .xdata$x:00002994o
.xdata$x:00002931                 db    0
.xdata$x:00002932                 db    0
.xdata$x:00002933                 db    0
.xdata$x:00002934                 db    0
.xdata$x:00002935                 db    0
.xdata$x:00002936                 db    0
.xdata$x:00002937                 db    0
.xdata$x:00002938                 db    0
.xdata$x:00002939                 db    0
.xdata$x:0000293A                 db    0
.xdata$x:0000293B                 db    0
.xdata$x:0000293C                 dd offset __catch$?_Copy@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEXII@Z$1
.xdata$x:00002940 __unwindtable$?_Copy@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEXII@Z db 0FFh
.xdata$x:00002940                                         ; DATA XREF: .xdata$x:00002968o
.xdata$x:00002941                 db 0FFh
.xdata$x:00002942                 db 0FFh
.xdata$x:00002943                 db 0FFh
.xdata$x:00002944                 db    0
.xdata$x:00002945                 db    0
.xdata$x:00002946                 db    0
.xdata$x:00002947                 db    0
.xdata$x:00002948                 db 0FFh
.xdata$x:00002949                 db 0FFh
.xdata$x:0000294A                 db 0FFh
.xdata$x:0000294B                 db 0FFh
.xdata$x:0000294C                 db    0
.xdata$x:0000294D                 db    0
.xdata$x:0000294E                 db    0
.xdata$x:0000294F                 db    0
.xdata$x:00002950                 db    1
.xdata$x:00002951                 db    0
.xdata$x:00002952                 db    0
.xdata$x:00002953                 db    0
.xdata$x:00002954                 db    0
.xdata$x:00002955                 db    0
.xdata$x:00002956                 db    0
.xdata$x:00002957                 db    0
.xdata$x:00002958                 db    1
.xdata$x:00002959                 db    0
.xdata$x:0000295A                 db    0
.xdata$x:0000295B                 db    0
.xdata$x:0000295C                 db    0
.xdata$x:0000295D                 db    0
.xdata$x:0000295E                 db    0
.xdata$x:0000295F                 db    0
.xdata$x:00002960 __ehfuncinfo$?_Copy@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEXII@Z db  22h ; "
.xdata$x:00002960                                         ; DATA XREF: __ehhandler$?_Copy@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEXII@Z+11o
.xdata$x:00002961                 db    5
.xdata$x:00002962                 db  93h ; 
.xdata$x:00002963                 db  19h
.xdata$x:00002964                 db    4
.xdata$x:00002965                 db    0
.xdata$x:00002966                 db    0
.xdata$x:00002967                 db    0
.xdata$x:00002968                 dd offset __unwindtable$?_Copy@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEXII@Z
.xdata$x:0000296C                 db    2
.xdata$x:0000296D                 db    0
.xdata$x:0000296E                 db    0
.xdata$x:0000296F                 db    0
.xdata$x:00002970                 dd offset __tryblocktable$?_Copy@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEXII@Z
.xdata$x:00002974                 db    0
.xdata$x:00002975                 db    0
.xdata$x:00002976                 db    0
.xdata$x:00002977                 db    0
.xdata$x:00002978                 db    0
.xdata$x:00002979                 db    0
.xdata$x:0000297A                 db    0
.xdata$x:0000297B                 db    0
.xdata$x:0000297C                 db    0
.xdata$x:0000297D                 db    0
.xdata$x:0000297E                 db    0
.xdata$x:0000297F                 db    0
.xdata$x:00002980                 db    0
.xdata$x:00002981                 db    0
.xdata$x:00002982                 db    0
.xdata$x:00002983                 db    0
.xdata$x:00002984 __tryblocktable$?_Copy@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEXII@Z db    2
.xdata$x:00002984                                         ; DATA XREF: .xdata$x:00002970o
.xdata$x:00002985                 db    0
.xdata$x:00002986                 db    0
.xdata$x:00002987                 db    0
.xdata$x:00002988                 db    2
.xdata$x:00002989                 db    0
.xdata$x:0000298A                 db    0
.xdata$x:0000298B                 db    0
.xdata$x:0000298C                 db    3
.xdata$x:0000298D                 db    0
.xdata$x:0000298E                 db    0
.xdata$x:0000298F                 db    0
.xdata$x:00002990                 db    1
.xdata$x:00002991                 db    0
.xdata$x:00002992                 db    0
.xdata$x:00002993                 db    0
.xdata$x:00002994                 dd offset __catchsym$?_Copy@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEXII@Z$4
.xdata$x:00002998                 align 10h
.xdata$x:000029A0                 db    3
.xdata$x:000029A1                 db    0
.xdata$x:000029A2                 db    0
.xdata$x:000029A3                 db    0
.xdata$x:000029A4                 db    1
.xdata$x:000029A5                 db    0
.xdata$x:000029A6                 db    0
.xdata$x:000029A7                 db    0
.xdata$x:000029A8                 dd offset __catchsym$?_Copy@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEXII@Z$5
.xdata$x:000029A8 _xdata$x        ends
.xdata$x:000029A8
.xdata$x:000029AC ; ===========================================================================
.xdata$x:000029AC
.xdata$x:000029AC ; Segment type: Pure data
.xdata$x:000029AC ; Segment permissions: Read
.xdata$x:000029AC _xdata$x        segment dword public 'DATA' use32
.xdata$x:000029AC                 assume cs:_xdata$x
.xdata$x:000029AC                 ;org 29ACh
.xdata$x:000029AC ; COMDAT (pick associative to section at AE0)
.xdata$x:000029AC __unwindtable$??0_Generic_error_category@std@@QAE@XZ db 0FFh
.xdata$x:000029AC                                         ; DATA XREF: .xdata$x:000029BCo
.xdata$x:000029AD                 db 0FFh
.xdata$x:000029AE                 db 0FFh
.xdata$x:000029AF                 db 0FFh
.xdata$x:000029B0                 dd offset __unwindfunclet$??0_Generic_error_category@std@@QAE@XZ$0
.xdata$x:000029B4 __ehfuncinfo$??0_Generic_error_category@std@@QAE@XZ db  22h ; "
.xdata$x:000029B4                                         ; DATA XREF: __ehhandler$??0_Generic_error_category@std@@QAE@XZ+11o
.xdata$x:000029B5                 db    5
.xdata$x:000029B6                 db  93h ; 
.xdata$x:000029B7                 db  19h
.xdata$x:000029B8                 db    1
.xdata$x:000029B9                 db    0
.xdata$x:000029BA                 db    0
.xdata$x:000029BB                 db    0
.xdata$x:000029BC                 dd offset __unwindtable$??0_Generic_error_category@std@@QAE@XZ
.xdata$x:000029C0                 db    0
.xdata$x:000029C1                 db    0
.xdata$x:000029C2                 db    0
.xdata$x:000029C3                 db    0
.xdata$x:000029C4                 db    0
.xdata$x:000029C5                 db    0
.xdata$x:000029C6                 db    0
.xdata$x:000029C7                 db    0
.xdata$x:000029C8                 db    0
.xdata$x:000029C9                 db    0
.xdata$x:000029CA                 db    0
.xdata$x:000029CB                 db    0
.xdata$x:000029CC                 db    0
.xdata$x:000029CD                 db    0
.xdata$x:000029CE                 db    0
.xdata$x:000029CF                 db    0
.xdata$x:000029D0                 db    0
.xdata$x:000029D1                 db    0
.xdata$x:000029D2                 db    0
.xdata$x:000029D3                 db    0
.xdata$x:000029D4                 db    0
.xdata$x:000029D5                 db    0
.xdata$x:000029D6                 db    0
.xdata$x:000029D7                 db    0
.xdata$x:000029D7 _xdata$x        ends
.xdata$x:000029D7
.xdata$x:000029D8 ; ===========================================================================
.xdata$x:000029D8
.xdata$x:000029D8 ; Segment type: Pure data
.xdata$x:000029D8 ; Segment permissions: Read
.xdata$x:000029D8 _xdata$x        segment dword public 'DATA' use32
.xdata$x:000029D8                 assume cs:_xdata$x
.xdata$x:000029D8                 ;org 29D8h
.xdata$x:000029D8 ; COMDAT (pick associative to section at 2474)
.xdata$x:000029D8 __unwindtable$?message@_Generic_error_category@std@@UBE?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@2@H@Z db 0FFh
.xdata$x:000029D8                                         ; DATA XREF: .xdata$x:000029E8o
.xdata$x:000029D9                 db 0FFh
.xdata$x:000029DA                 db 0FFh
.xdata$x:000029DB                 db 0FFh
.xdata$x:000029DC                 dd offset __unwindfunclet$?message@_Generic_error_category@std@@UBE?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@2@H@Z$0
.xdata$x:000029E0 __ehfuncinfo$?message@_Generic_error_category@std@@UBE?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@2@H@Z db  22h ; "
.xdata$x:000029E0                                         ; DATA XREF: __ehhandler$?message@_Generic_error_category@std@@UBE?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@2@H@Z+11o
.xdata$x:000029E1                 db    5
.xdata$x:000029E2                 db  93h ; 
.xdata$x:000029E3                 db  19h
.xdata$x:000029E4                 db    1
.xdata$x:000029E5                 db    0
.xdata$x:000029E6                 db    0
.xdata$x:000029E7                 db    0
.xdata$x:000029E8                 dd offset __unwindtable$?message@_Generic_error_category@std@@UBE?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@2@H@Z
.xdata$x:000029EC                 db    0
.xdata$x:000029ED                 db    0
.xdata$x:000029EE                 db    0
.xdata$x:000029EF                 db    0
.xdata$x:000029F0                 db    0
.xdata$x:000029F1                 db    0
.xdata$x:000029F2                 db    0
.xdata$x:000029F3                 db    0
.xdata$x:000029F4                 db    0
.xdata$x:000029F5                 db    0
.xdata$x:000029F6                 db    0
.xdata$x:000029F7                 db    0
.xdata$x:000029F8                 db    0
.xdata$x:000029F9                 db    0
.xdata$x:000029FA                 db    0
.xdata$x:000029FB                 db    0
.xdata$x:000029FC                 db    0
.xdata$x:000029FD                 db    0
.xdata$x:000029FE                 db    0
.xdata$x:000029FF                 db    0
.xdata$x:00002A00                 db    0
.xdata$x:00002A01                 db    0
.xdata$x:00002A02                 db    0
.xdata$x:00002A03                 db    0
.xdata$x:00002A03 _xdata$x        ends
.xdata$x:00002A03
.xdata$x:00002A04 ; ===========================================================================
.xdata$x:00002A04
.xdata$x:00002A04 ; Segment type: Pure data
.xdata$x:00002A04 ; Segment permissions: Read
.xdata$x:00002A04 _xdata$x        segment dword public 'DATA' use32
.xdata$x:00002A04                 assume cs:_xdata$x
.xdata$x:00002A04                 ;org 2A04h
.xdata$x:00002A04 ; COMDAT (pick associative to section at E20)
.xdata$x:00002A04 __unwindtable$??1_Generic_error_category@std@@UAE@XZ db 0FFh
.xdata$x:00002A04                                         ; DATA XREF: .xdata$x:00002A14o
.xdata$x:00002A05                 db 0FFh
.xdata$x:00002A06                 db 0FFh
.xdata$x:00002A07                 db 0FFh
.xdata$x:00002A08                 dd offset __unwindfunclet$??1_Generic_error_category@std@@UAE@XZ$0
.xdata$x:00002A0C __ehfuncinfo$??1_Generic_error_category@std@@UAE@XZ db  22h ; "
.xdata$x:00002A0C                                         ; DATA XREF: __ehhandler$??1_Generic_error_category@std@@UAE@XZ+11o
.xdata$x:00002A0D                 db    5
.xdata$x:00002A0E                 db  93h ; 
.xdata$x:00002A0F                 db  19h
.xdata$x:00002A10                 db    1
.xdata$x:00002A11                 db    0
.xdata$x:00002A12                 db    0
.xdata$x:00002A13                 db    0
.xdata$x:00002A14                 dd offset __unwindtable$??1_Generic_error_category@std@@UAE@XZ
.xdata$x:00002A18                 db    0
.xdata$x:00002A19                 db    0
.xdata$x:00002A1A                 db    0
.xdata$x:00002A1B                 db    0
.xdata$x:00002A1C                 db    0
.xdata$x:00002A1D                 db    0
.xdata$x:00002A1E                 db    0
.xdata$x:00002A1F                 db    0
.xdata$x:00002A20                 db    0
.xdata$x:00002A21                 db    0
.xdata$x:00002A22                 db    0
.xdata$x:00002A23                 db    0
.xdata$x:00002A24                 db    0
.xdata$x:00002A25                 db    0
.xdata$x:00002A26                 db    0
.xdata$x:00002A27                 db    0
.xdata$x:00002A28                 db    0
.xdata$x:00002A29                 db    0
.xdata$x:00002A2A                 db    0
.xdata$x:00002A2B                 db    0
.xdata$x:00002A2C                 db    0
.xdata$x:00002A2D                 db    0
.xdata$x:00002A2E                 db    0
.xdata$x:00002A2F                 db    0
.xdata$x:00002A2F _xdata$x        ends
.xdata$x:00002A2F
.xdata$x:00002A30 ; ===========================================================================
.xdata$x:00002A30
.xdata$x:00002A30 ; Segment type: Pure data
.xdata$x:00002A30 ; Segment permissions: Read
.xdata$x:00002A30 _xdata$x        segment dword public 'DATA' use32
.xdata$x:00002A30                 assume cs:_xdata$x
.xdata$x:00002A30                 ;org 2A30h
.xdata$x:00002A30 ; COMDAT (pick associative to section at B5C)
.xdata$x:00002A30 __unwindtable$??0_Iostream_error_category@std@@QAE@XZ db 0FFh
.xdata$x:00002A30                                         ; DATA XREF: .xdata$x:00002A40o
.xdata$x:00002A31                 db 0FFh
.xdata$x:00002A32                 db 0FFh
.xdata$x:00002A33                 db 0FFh
.xdata$x:00002A34                 dd offset __unwindfunclet$??0_Iostream_error_category@std@@QAE@XZ$0
.xdata$x:00002A38 __ehfuncinfo$??0_Iostream_error_category@std@@QAE@XZ db  22h ; "
.xdata$x:00002A38                                         ; DATA XREF: __ehhandler$??0_Iostream_error_category@std@@QAE@XZ+11o
.xdata$x:00002A39                 db    5
.xdata$x:00002A3A                 db  93h ; 
.xdata$x:00002A3B                 db  19h
.xdata$x:00002A3C                 db    1
.xdata$x:00002A3D                 db    0
.xdata$x:00002A3E                 db    0
.xdata$x:00002A3F                 db    0
.xdata$x:00002A40                 dd offset __unwindtable$??0_Iostream_error_category@std@@QAE@XZ
.xdata$x:00002A44                 db    0
.xdata$x:00002A45                 db    0
.xdata$x:00002A46                 db    0
.xdata$x:00002A47                 db    0
.xdata$x:00002A48                 db    0
.xdata$x:00002A49                 db    0
.xdata$x:00002A4A                 db    0
.xdata$x:00002A4B                 db    0
.xdata$x:00002A4C                 db    0
.xdata$x:00002A4D                 db    0
.xdata$x:00002A4E                 db    0
.xdata$x:00002A4F                 db    0
.xdata$x:00002A50                 db    0
.xdata$x:00002A51                 db    0
.xdata$x:00002A52                 db    0
.xdata$x:00002A53                 db    0
.xdata$x:00002A54                 db    0
.xdata$x:00002A55                 db    0
.xdata$x:00002A56                 db    0
.xdata$x:00002A57                 db    0
.xdata$x:00002A58                 db    0
.xdata$x:00002A59                 db    0
.xdata$x:00002A5A                 db    0
.xdata$x:00002A5B                 db    0
.xdata$x:00002A5B _xdata$x        ends
.xdata$x:00002A5B
.xdata$x:00002A5C ; ===========================================================================
.xdata$x:00002A5C
.xdata$x:00002A5C ; Segment type: Pure data
.xdata$x:00002A5C ; Segment permissions: Read
.xdata$x:00002A5C _xdata$x        segment dword public 'DATA' use32
.xdata$x:00002A5C                 assume cs:_xdata$x
.xdata$x:00002A5C                 ;org 2A5Ch
.xdata$x:00002A5C ; COMDAT (pick associative to section at 252C)
.xdata$x:00002A5C __unwindtable$?message@_Iostream_error_category@std@@UBE?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@2@H@Z db 0FFh
.xdata$x:00002A5C                                         ; DATA XREF: .xdata$x:00002A6Co
.xdata$x:00002A5D                 db 0FFh
.xdata$x:00002A5E                 db 0FFh
.xdata$x:00002A5F                 db 0FFh
.xdata$x:00002A60                 dd offset __unwindfunclet$?message@_Iostream_error_category@std@@UBE?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@2@H@Z$0
.xdata$x:00002A64 __ehfuncinfo$?message@_Iostream_error_category@std@@UBE?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@2@H@Z db  22h ; "
.xdata$x:00002A64                                         ; DATA XREF: __ehhandler$?message@_Iostream_error_category@std@@UBE?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@2@H@Z+11o
.xdata$x:00002A65                 db    5
.xdata$x:00002A66                 db  93h ; 
.xdata$x:00002A67                 db  19h
.xdata$x:00002A68                 db    1
.xdata$x:00002A69                 db    0
.xdata$x:00002A6A                 db    0
.xdata$x:00002A6B                 db    0
.xdata$x:00002A6C                 dd offset __unwindtable$?message@_Iostream_error_category@std@@UBE?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@2@H@Z
.xdata$x:00002A70                 db    0
.xdata$x:00002A71                 db    0
.xdata$x:00002A72                 db    0
.xdata$x:00002A73                 db    0
.xdata$x:00002A74                 db    0
.xdata$x:00002A75                 db    0
.xdata$x:00002A76                 db    0
.xdata$x:00002A77                 db    0
.xdata$x:00002A78                 db    0
.xdata$x:00002A79                 db    0
.xdata$x:00002A7A                 db    0
.xdata$x:00002A7B                 db    0
.xdata$x:00002A7C                 db    0
.xdata$x:00002A7D                 db    0
.xdata$x:00002A7E                 db    0
.xdata$x:00002A7F                 db    0
.xdata$x:00002A80                 db    0
.xdata$x:00002A81                 db    0
.xdata$x:00002A82                 db    0
.xdata$x:00002A83                 db    0
.xdata$x:00002A84                 db    0
.xdata$x:00002A85                 db    0
.xdata$x:00002A86                 db    0
.xdata$x:00002A87                 db    0
.xdata$x:00002A87 _xdata$x        ends
.xdata$x:00002A87
.xdata$x:00002A88 ; ===========================================================================
.xdata$x:00002A88
.xdata$x:00002A88 ; Segment type: Pure data
.xdata$x:00002A88 ; Segment permissions: Read
.xdata$x:00002A88 _xdata$x        segment dword public 'DATA' use32
.xdata$x:00002A88                 assume cs:_xdata$x
.xdata$x:00002A88                 ;org 2A88h
.xdata$x:00002A88 ; COMDAT (pick associative to section at E90)
.xdata$x:00002A88 __unwindtable$??1_Iostream_error_category@std@@UAE@XZ db 0FFh
.xdata$x:00002A88                                         ; DATA XREF: .xdata$x:00002A98o
.xdata$x:00002A89                 db 0FFh
.xdata$x:00002A8A                 db 0FFh
.xdata$x:00002A8B                 db 0FFh
.xdata$x:00002A8C                 dd offset __unwindfunclet$??1_Iostream_error_category@std@@UAE@XZ$0
.xdata$x:00002A90 __ehfuncinfo$??1_Iostream_error_category@std@@UAE@XZ db  22h ; "
.xdata$x:00002A90                                         ; DATA XREF: __ehhandler$??1_Iostream_error_category@std@@UAE@XZ+11o
.xdata$x:00002A91                 db    5
.xdata$x:00002A92                 db  93h ; 
.xdata$x:00002A93                 db  19h
.xdata$x:00002A94                 db    1
.xdata$x:00002A95                 db    0
.xdata$x:00002A96                 db    0
.xdata$x:00002A97                 db    0
.xdata$x:00002A98                 dd offset __unwindtable$??1_Iostream_error_category@std@@UAE@XZ
.xdata$x:00002A9C                 db    0
.xdata$x:00002A9D                 db    0
.xdata$x:00002A9E                 db    0
.xdata$x:00002A9F                 db    0
.xdata$x:00002AA0                 db    0
.xdata$x:00002AA1                 db    0
.xdata$x:00002AA2                 db    0
.xdata$x:00002AA3                 db    0
.xdata$x:00002AA4                 db    0
.xdata$x:00002AA5                 db    0
.xdata$x:00002AA6                 db    0
.xdata$x:00002AA7                 db    0
.xdata$x:00002AA8                 db    0
.xdata$x:00002AA9                 db    0
.xdata$x:00002AAA                 db    0
.xdata$x:00002AAB                 db    0
.xdata$x:00002AAC                 db    0
.xdata$x:00002AAD                 db    0
.xdata$x:00002AAE                 db    0
.xdata$x:00002AAF                 db    0
.xdata$x:00002AB0                 db    0
.xdata$x:00002AB1                 db    0
.xdata$x:00002AB2                 db    0
.xdata$x:00002AB3                 db    0
.xdata$x:00002AB3 _xdata$x        ends
.xdata$x:00002AB3
.xdata$x:00002AB4 ; ===========================================================================
.xdata$x:00002AB4
.xdata$x:00002AB4 ; Segment type: Pure data
.xdata$x:00002AB4 ; Segment permissions: Read
.xdata$x:00002AB4 _xdata$x        segment dword public 'DATA' use32
.xdata$x:00002AB4                 assume cs:_xdata$x
.xdata$x:00002AB4                 ;org 2AB4h
.xdata$x:00002AB4 ; COMDAT (pick associative to section at BD8)
.xdata$x:00002AB4 __unwindtable$??0_System_error_category@std@@QAE@XZ db 0FFh
.xdata$x:00002AB4                                         ; DATA XREF: .xdata$x:00002AC4o
.xdata$x:00002AB5                 db 0FFh
.xdata$x:00002AB6                 db 0FFh
.xdata$x:00002AB7                 db 0FFh
.xdata$x:00002AB8                 dd offset __unwindfunclet$??0_System_error_category@std@@QAE@XZ$0
.xdata$x:00002ABC __ehfuncinfo$??0_System_error_category@std@@QAE@XZ db  22h ; "
.xdata$x:00002ABC                                         ; DATA XREF: __ehhandler$??0_System_error_category@std@@QAE@XZ+11o
.xdata$x:00002ABD                 db    5
.xdata$x:00002ABE                 db  93h ; 
.xdata$x:00002ABF                 db  19h
.xdata$x:00002AC0                 db    1
.xdata$x:00002AC1                 db    0
.xdata$x:00002AC2                 db    0
.xdata$x:00002AC3                 db    0
.xdata$x:00002AC4                 dd offset __unwindtable$??0_System_error_category@std@@QAE@XZ
.xdata$x:00002AC8                 align 20h
.xdata$x:00002AC8 _xdata$x        ends
.xdata$x:00002AC8
.xdata$x:00002AE0 ; ===========================================================================
.xdata$x:00002AE0
.xdata$x:00002AE0 ; Segment type: Pure data
.xdata$x:00002AE0 ; Segment permissions: Read
.xdata$x:00002AE0 _xdata$x        segment dword public 'DATA' use32
.xdata$x:00002AE0                 assume cs:_xdata$x
.xdata$x:00002AE0                 ;org 2AE0h
.xdata$x:00002AE0 ; COMDAT (pick associative to section at 25F0)
.xdata$x:00002AE0 __unwindtable$?message@_System_error_category@std@@UBE?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@2@H@Z db 0FFh
.xdata$x:00002AE0                                         ; DATA XREF: .xdata$x:00002AF0o
.xdata$x:00002AE1                 db 0FFh
.xdata$x:00002AE2                 db 0FFh
.xdata$x:00002AE3                 db 0FFh
.xdata$x:00002AE4                 dd offset __unwindfunclet$?message@_System_error_category@std@@UBE?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@2@H@Z$0
.xdata$x:00002AE8 __ehfuncinfo$?message@_System_error_category@std@@UBE?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@2@H@Z db  22h ; "
.xdata$x:00002AE8                                         ; DATA XREF: __ehhandler$?message@_System_error_category@std@@UBE?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@2@H@Z+11o
.xdata$x:00002AE9                 db    5
.xdata$x:00002AEA                 db  93h ; 
.xdata$x:00002AEB                 db  19h
.xdata$x:00002AEC                 db    1
.xdata$x:00002AED                 db    0
.xdata$x:00002AEE                 db    0
.xdata$x:00002AEF                 db    0
.xdata$x:00002AF0                 dd offset __unwindtable$?message@_System_error_category@std@@UBE?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@2@H@Z
.xdata$x:00002AF4                 db    0
.xdata$x:00002AF5                 db    0
.xdata$x:00002AF6                 db    0
.xdata$x:00002AF7                 db    0
.xdata$x:00002AF8                 db    0
.xdata$x:00002AF9                 db    0
.xdata$x:00002AFA                 db    0
.xdata$x:00002AFB                 db    0
.xdata$x:00002AFC                 db    0
.xdata$x:00002AFD                 db    0
.xdata$x:00002AFE                 db    0
.xdata$x:00002AFF                 db    0
.xdata$x:00002B00                 db    0
.xdata$x:00002B01                 db    0
.xdata$x:00002B02                 db    0
.xdata$x:00002B03                 db    0
.xdata$x:00002B04                 db    0
.xdata$x:00002B05                 db    0
.xdata$x:00002B06                 db    0
.xdata$x:00002B07                 db    0
.xdata$x:00002B08                 db    0
.xdata$x:00002B09                 db    0
.xdata$x:00002B0A                 db    0
.xdata$x:00002B0B                 db    0
.xdata$x:00002B0B _xdata$x        ends
.xdata$x:00002B0B
.xdata$x:00002B0C ; ===========================================================================
.xdata$x:00002B0C
.xdata$x:00002B0C ; Segment type: Pure data
.xdata$x:00002B0C ; Segment permissions: Read
.xdata$x:00002B0C _xdata$x        segment dword public 'DATA' use32
.xdata$x:00002B0C                 assume cs:_xdata$x
.xdata$x:00002B0C                 ;org 2B0Ch
.xdata$x:00002B0C ; COMDAT (pick associative to section at F00)
.xdata$x:00002B0C __unwindtable$??1_System_error_category@std@@UAE@XZ db 0FFh
.xdata$x:00002B0C                                         ; DATA XREF: .xdata$x:00002B1Co
.xdata$x:00002B0D                 db 0FFh
.xdata$x:00002B0E                 db 0FFh
.xdata$x:00002B0F                 db 0FFh
.xdata$x:00002B10                 dd offset __unwindfunclet$??1_System_error_category@std@@UAE@XZ$0
.xdata$x:00002B14 __ehfuncinfo$??1_System_error_category@std@@UAE@XZ db  22h ; "
.xdata$x:00002B14                                         ; DATA XREF: __ehhandler$??1_System_error_category@std@@UAE@XZ+11o
.xdata$x:00002B15                 db    5
.xdata$x:00002B16                 db  93h ; 
.xdata$x:00002B17                 db  19h
.xdata$x:00002B18                 db    1
.xdata$x:00002B19                 db    0
.xdata$x:00002B1A                 db    0
.xdata$x:00002B1B                 db    0
.xdata$x:00002B1C                 dd offset __unwindtable$??1_System_error_category@std@@UAE@XZ
.xdata$x:00002B20                 db    0
.xdata$x:00002B21                 db    0
.xdata$x:00002B22                 db    0
.xdata$x:00002B23                 db    0
.xdata$x:00002B24                 db    0
.xdata$x:00002B25                 db    0
.xdata$x:00002B26                 db    0
.xdata$x:00002B27                 db    0
.xdata$x:00002B28                 db    0
.xdata$x:00002B29                 db    0
.xdata$x:00002B2A                 db    0
.xdata$x:00002B2B                 db    0
.xdata$x:00002B2C                 db    0
.xdata$x:00002B2D                 db    0
.xdata$x:00002B2E                 db    0
.xdata$x:00002B2F                 db    0
.xdata$x:00002B30                 db    0
.xdata$x:00002B31                 db    0
.xdata$x:00002B32                 db    0
.xdata$x:00002B33                 db    0
.xdata$x:00002B34                 db    0
.xdata$x:00002B35                 db    0
.xdata$x:00002B36                 db    0
.xdata$x:00002B37                 db    0
.xdata$x:00002B37 _xdata$x        ends
.xdata$x:00002B37
.xdata$x:00002B38 ; ===========================================================================
.xdata$x:00002B38
.xdata$x:00002B38 ; Segment type: Pure data
.xdata$x:00002B38 ; Segment permissions: Read
.xdata$x:00002B38 _xdata$x        segment dword public 'DATA' use32
.xdata$x:00002B38                 assume cs:_xdata$x
.xdata$x:00002B38                 ;org 2B38h
.xdata$x:00002B38 ; COMDAT (pick associative to section at 13E4)
.xdata$x:00002B38 __catchsym$?_Copy@?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QAEXII@Z$5 db    0
.xdata$x:00002B38                                         ; DATA XREF: .xdata$x:00002BC0o
.xdata$x:00002B39                 db    0
.xdata$x:00002B3A                 db    0
.xdata$x:00002B3B                 db    0
.xdata$x:00002B3C                 db    0
.xdata$x:00002B3D                 db    0
.xdata$x:00002B3E                 db    0
.xdata$x:00002B3F                 db    0
.xdata$x:00002B40                 db    0
.xdata$x:00002B41                 db    0
.xdata$x:00002B42                 db    0
.xdata$x:00002B43                 db    0
.xdata$x:00002B44                 dd offset __catch$?_Copy@?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QAEXII@Z$0
.xdata$x:00002B48 __catchsym$?_Copy@?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QAEXII@Z$4 db    0
.xdata$x:00002B48                                         ; DATA XREF: .xdata$x:00002BACo
.xdata$x:00002B49                 db    0
.xdata$x:00002B4A                 db    0
.xdata$x:00002B4B                 db    0
.xdata$x:00002B4C                 db    0
.xdata$x:00002B4D                 db    0
.xdata$x:00002B4E                 db    0
.xdata$x:00002B4F                 db    0
.xdata$x:00002B50                 db    0
.xdata$x:00002B51                 db    0
.xdata$x:00002B52                 db    0
.xdata$x:00002B53                 db    0
.xdata$x:00002B54                 dd offset __catch$?_Copy@?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QAEXII@Z$1
.xdata$x:00002B58 __unwindtable$?_Copy@?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QAEXII@Z db 0FFh
.xdata$x:00002B58                                         ; DATA XREF: .xdata$x:00002B80o
.xdata$x:00002B59                 db 0FFh
.xdata$x:00002B5A                 db 0FFh
.xdata$x:00002B5B                 db 0FFh
.xdata$x:00002B5C                 db    0
.xdata$x:00002B5D                 db    0
.xdata$x:00002B5E                 db    0
.xdata$x:00002B5F                 db    0
.xdata$x:00002B60                 db 0FFh
.xdata$x:00002B61                 db 0FFh
.xdata$x:00002B62                 db 0FFh
.xdata$x:00002B63                 db 0FFh
.xdata$x:00002B64                 db    0
.xdata$x:00002B65                 db    0
.xdata$x:00002B66                 db    0
.xdata$x:00002B67                 db    0
.xdata$x:00002B68                 db    1
.xdata$x:00002B69                 db    0
.xdata$x:00002B6A                 db    0
.xdata$x:00002B6B                 db    0
.xdata$x:00002B6C                 db    0
.xdata$x:00002B6D                 db    0
.xdata$x:00002B6E                 db    0
.xdata$x:00002B6F                 db    0
.xdata$x:00002B70                 db    1
.xdata$x:00002B71                 db    0
.xdata$x:00002B72                 db    0
.xdata$x:00002B73                 db    0
.xdata$x:00002B74                 db    0
.xdata$x:00002B75                 db    0
.xdata$x:00002B76                 db    0
.xdata$x:00002B77                 db    0
.xdata$x:00002B78 __ehfuncinfo$?_Copy@?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QAEXII@Z db  22h ; "
.xdata$x:00002B78                                         ; DATA XREF: __ehhandler$?_Copy@?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QAEXII@Z+11o
.xdata$x:00002B79                 db    5
.xdata$x:00002B7A                 db  93h ; 
.xdata$x:00002B7B                 db  19h
.xdata$x:00002B7C                 db    4
.xdata$x:00002B7D                 db    0
.xdata$x:00002B7E                 db    0
.xdata$x:00002B7F                 db    0
.xdata$x:00002B80                 dd offset __unwindtable$?_Copy@?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QAEXII@Z
.xdata$x:00002B84                 db    2
.xdata$x:00002B85                 db    0
.xdata$x:00002B86                 db    0
.xdata$x:00002B87                 db    0
.xdata$x:00002B88                 dd offset __tryblocktable$?_Copy@?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QAEXII@Z
.xdata$x:00002B8C                 db    0
.xdata$x:00002B8D                 db    0
.xdata$x:00002B8E                 db    0
.xdata$x:00002B8F                 db    0
.xdata$x:00002B90                 db    0
.xdata$x:00002B91                 db    0
.xdata$x:00002B92                 db    0
.xdata$x:00002B93                 db    0
.xdata$x:00002B94                 db    0
.xdata$x:00002B95                 db    0
.xdata$x:00002B96                 db    0
.xdata$x:00002B97                 db    0
.xdata$x:00002B98                 db    0
.xdata$x:00002B99                 db    0
.xdata$x:00002B9A                 db    0
.xdata$x:00002B9B                 db    0
.xdata$x:00002B9C __tryblocktable$?_Copy@?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QAEXII@Z db    2
.xdata$x:00002B9C                                         ; DATA XREF: .xdata$x:00002B88o
.xdata$x:00002B9D                 db    0
.xdata$x:00002B9E                 db    0
.xdata$x:00002B9F                 db    0
.xdata$x:00002BA0                 db    2
.xdata$x:00002BA1                 db    0
.xdata$x:00002BA2                 db    0
.xdata$x:00002BA3                 db    0
.xdata$x:00002BA4                 db    3
.xdata$x:00002BA5                 db    0
.xdata$x:00002BA6                 db    0
.xdata$x:00002BA7                 db    0
.xdata$x:00002BA8                 db    1
.xdata$x:00002BA9                 db    0
.xdata$x:00002BAA                 db    0
.xdata$x:00002BAB                 db    0
.xdata$x:00002BAC                 dd offset __catchsym$?_Copy@?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QAEXII@Z$4
.xdata$x:00002BB0                 db    0
.xdata$x:00002BB1                 db    0
.xdata$x:00002BB2                 db    0
.xdata$x:00002BB3                 db    0
.xdata$x:00002BB4                 db    0
.xdata$x:00002BB5                 db    0
.xdata$x:00002BB6                 db    0
.xdata$x:00002BB7                 db    0
.xdata$x:00002BB8                 db    3
.xdata$x:00002BB9                 db    0
.xdata$x:00002BBA                 db    0
.xdata$x:00002BBB                 db    0
.xdata$x:00002BBC                 db    1
.xdata$x:00002BBD                 db    0
.xdata$x:00002BBE                 db    0
.xdata$x:00002BBF                 db    0
.xdata$x:00002BC0                 dd offset __catchsym$?_Copy@?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QAEXII@Z$5
.xdata$x:00002BC0 _xdata$x        ends
.xdata$x:00002BC0
.xdata$x:00002BC4 ; ===========================================================================
.xdata$x:00002BC4
.xdata$x:00002BC4 ; Segment type: Pure data
.xdata$x:00002BC4 ; Segment permissions: Read
.xdata$x:00002BC4 _xdata$x        segment dword public 'DATA' use32
.xdata$x:00002BC4                 assume cs:_xdata$x
.xdata$x:00002BC4                 ;org 2BC4h
.xdata$x:00002BC4 ; COMDAT (pick associative to section at 740)
.xdata$x:00002BC4 __unwindtable$??$construct@U_Container_proxy@std@@U12@@?$allocator@U_Container_proxy@std@@@std@@QAEXPAU_Container_proxy@1@$$QAU21@@Z db 0FFh
.xdata$x:00002BC4                                         ; DATA XREF: .xdata$x:00002BD4o
.xdata$x:00002BC5                 db 0FFh
.xdata$x:00002BC6                 db 0FFh
.xdata$x:00002BC7                 db 0FFh
.xdata$x:00002BC8                 dd offset __unwindfunclet$??$construct@U_Container_proxy@std@@U12@@?$allocator@U_Container_proxy@std@@@std@@QAEXPAU_Container_proxy@1@$$QAU21@@Z$0
.xdata$x:00002BCC __ehfuncinfo$??$construct@U_Container_proxy@std@@U12@@?$allocator@U_Container_proxy@std@@@std@@QAEXPAU_Container_proxy@1@$$QAU21@@Z db  22h ; "
.xdata$x:00002BCC                                         ; DATA XREF: __ehhandler$??$construct@U_Container_proxy@std@@U12@@?$allocator@U_Container_proxy@std@@@std@@QAEXPAU_Container_proxy@1@$$QAU21@@Z+11o
.xdata$x:00002BCD                 db    5
.xdata$x:00002BCE                 db  93h ; 
.xdata$x:00002BCF                 db  19h
.xdata$x:00002BD0                 db    1
.xdata$x:00002BD1                 db    0
.xdata$x:00002BD2                 db    0
.xdata$x:00002BD3                 db    0
.xdata$x:00002BD4                 dd offset __unwindtable$??$construct@U_Container_proxy@std@@U12@@?$allocator@U_Container_proxy@std@@@std@@QAEXPAU_Container_proxy@1@$$QAU21@@Z
.xdata$x:00002BD8                 db    0
.xdata$x:00002BD9                 db    0
.xdata$x:00002BDA                 db    0
.xdata$x:00002BDB                 db    0
.xdata$x:00002BDC                 db    0
.xdata$x:00002BDD                 db    0
.xdata$x:00002BDE                 db    0
.xdata$x:00002BDF                 db    0
.xdata$x:00002BE0                 db    0
.xdata$x:00002BE1                 db    0
.xdata$x:00002BE2                 db    0
.xdata$x:00002BE3                 db    0
.xdata$x:00002BE4                 db    0
.xdata$x:00002BE5                 db    0
.xdata$x:00002BE6                 db    0
.xdata$x:00002BE7                 db    0
.xdata$x:00002BE8                 db    0
.xdata$x:00002BE9                 db    0
.xdata$x:00002BEA                 db    0
.xdata$x:00002BEB                 db    0
.xdata$x:00002BEC                 db    0
.xdata$x:00002BED                 db    0
.xdata$x:00002BEE                 db    0
.xdata$x:00002BEF                 db    0
.xdata$x:00002BEF _xdata$x        ends
.xdata$x:00002BEF
.xdata$x:00002BF0 ; ===========================================================================
.xdata$x:00002BF0
.xdata$x:00002BF0 ; Segment type: Pure data
.xdata$x:00002BF0 ; Segment permissions: Read
.xdata$x:00002BF0 _xdata$x        segment dword public 'DATA' use32
.xdata$x:00002BF0                 assume cs:_xdata$x
.xdata$x:00002BF0                 ;org 2BF0h
.xdata$x:00002BF0 ; COMDAT (pick associative to section at 56C)
.xdata$x:00002BF0 __unwindtable$??$construct@PADAAPAD@?$allocator@D@std@@QAEXPAPADAAPAD@Z db 0FFh
.xdata$x:00002BF0                                         ; DATA XREF: .xdata$x:00002C00o
.xdata$x:00002BF1                 db 0FFh
.xdata$x:00002BF2                 db 0FFh
.xdata$x:00002BF3                 db 0FFh
.xdata$x:00002BF4                 dd offset __unwindfunclet$??$construct@PADAAPAD@?$allocator@D@std@@QAEXPAPADAAPAD@Z$0
.xdata$x:00002BF8 __ehfuncinfo$??$construct@PADAAPAD@?$allocator@D@std@@QAEXPAPADAAPAD@Z db  22h ; "
.xdata$x:00002BF8                                         ; DATA XREF: __ehhandler$??$construct@PADAAPAD@?$allocator@D@std@@QAEXPAPADAAPAD@Z+11o
.xdata$x:00002BF9                 db    5
.xdata$x:00002BFA                 db  93h ; 
.xdata$x:00002BFB                 db  19h
.xdata$x:00002BFC                 db    1
.xdata$x:00002BFD                 db    0
.xdata$x:00002BFE                 db    0
.xdata$x:00002BFF                 db    0
.xdata$x:00002C00                 dd offset __unwindtable$??$construct@PADAAPAD@?$allocator@D@std@@QAEXPAPADAAPAD@Z
.xdata$x:00002C04                 db    0
.xdata$x:00002C05                 db    0
.xdata$x:00002C06                 db    0
.xdata$x:00002C07                 db    0
.xdata$x:00002C08                 db    0
.xdata$x:00002C09                 db    0
.xdata$x:00002C0A                 db    0
.xdata$x:00002C0B                 db    0
.xdata$x:00002C0C                 db    0
.xdata$x:00002C0D                 db    0
.xdata$x:00002C0E                 db    0
.xdata$x:00002C0F                 db    0
.xdata$x:00002C10                 db    0
.xdata$x:00002C11                 db    0
.xdata$x:00002C12                 db    0
.xdata$x:00002C13                 db    0
.xdata$x:00002C14                 db    0
.xdata$x:00002C15                 db    0
.xdata$x:00002C16                 db    0
.xdata$x:00002C17                 db    0
.xdata$x:00002C18                 db    0
.xdata$x:00002C19                 db    0
.xdata$x:00002C1A                 db    0
.xdata$x:00002C1B                 db    0
.xdata$x:00002C1B _xdata$x        ends
.xdata$x:00002C1B
.xdata$x:00002C1C ; ===========================================================================
.xdata$x:00002C1C
.xdata$x:00002C1C ; Segment type: Pure data
.xdata$x:00002C1C ; Segment permissions: Read
.xdata$x:00002C1C _xdata$x        segment dword public 'DATA' use32
.xdata$x:00002C1C                 assume cs:_xdata$x
.xdata$x:00002C1C                 ;org 2C1Ch
.xdata$x:00002C1C ; COMDAT (pick associative to section at 66C)
.xdata$x:00002C1C __unwindtable$??$construct@PA_WAAPA_W@?$allocator@_W@std@@QAEXPAPA_WAAPA_W@Z db 0FFh
.xdata$x:00002C1C                                         ; DATA XREF: .xdata$x:00002C2Co
.xdata$x:00002C1D                 db 0FFh
.xdata$x:00002C1E                 db 0FFh
.xdata$x:00002C1F                 db 0FFh
.xdata$x:00002C20                 dd offset __unwindfunclet$??$construct@PA_WAAPA_W@?$allocator@_W@std@@QAEXPAPA_WAAPA_W@Z$0
.xdata$x:00002C24 __ehfuncinfo$??$construct@PA_WAAPA_W@?$allocator@_W@std@@QAEXPAPA_WAAPA_W@Z db  22h ; "
.xdata$x:00002C24                                         ; DATA XREF: __ehhandler$??$construct@PA_WAAPA_W@?$allocator@_W@std@@QAEXPAPA_WAAPA_W@Z+11o
.xdata$x:00002C25                 db    5
.xdata$x:00002C26                 db  93h ; 
.xdata$x:00002C27                 db  19h
.xdata$x:00002C28                 db    1
.xdata$x:00002C29                 db    0
.xdata$x:00002C2A                 db    0
.xdata$x:00002C2B                 db    0
.xdata$x:00002C2C                 dd offset __unwindtable$??$construct@PA_WAAPA_W@?$allocator@_W@std@@QAEXPAPA_WAAPA_W@Z
.xdata$x:00002C30                 db    0
.xdata$x:00002C31                 db    0
.xdata$x:00002C32                 db    0
.xdata$x:00002C33                 db    0
.xdata$x:00002C34                 db    0
.xdata$x:00002C35                 db    0
.xdata$x:00002C36                 db    0
.xdata$x:00002C37                 db    0
.xdata$x:00002C38                 db    0
.xdata$x:00002C39                 db    0
.xdata$x:00002C3A                 db    0
.xdata$x:00002C3B                 db    0
.xdata$x:00002C3C                 db    0
.xdata$x:00002C3D                 db    0
.xdata$x:00002C3E                 db    0
.xdata$x:00002C3F                 db    0
.xdata$x:00002C40                 db    0
.xdata$x:00002C41                 db    0
.xdata$x:00002C42                 db    0
.xdata$x:00002C43                 db    0
.xdata$x:00002C44                 db    0
.xdata$x:00002C45                 db    0
.xdata$x:00002C46                 db    0
.xdata$x:00002C47                 db    0
.xdata$x:00002C47 _xdata$x        ends
.xdata$x:00002C47
.bss:00002C48 ; ===========================================================================
.bss:00002C48
.bss:00002C48 ; Segment type: Uninitialized
.bss:00002C48 ; Segment permissions: Read/Write
.bss:00002C48 _bss            segment byte public 'BSS' use32
.bss:00002C48                 assume cs:_bss
.bss:00002C48                 ;org 2C48h
.bss:00002C48                 assume es:nothing, ss:nothing, ds:_xdata$x, fs:nothing, gs:nothing
.bss:00002C48 _allocator_arg  db    ? ;
.bss:00002C49 _piecewise_construct db    ? ;
.bss:00002C4A                 align 4
.bss:00002C4A _bss            ends
.bss:00002C4A
.rdata:00002C4C ; ===========================================================================
.rdata:00002C4C
.rdata:00002C4C ; Segment type: Pure data
.rdata:00002C4C ; Segment permissions: Read
.rdata:00002C4C _rdata          segment dword public 'DATA' use32
.rdata:00002C4C                 assume cs:_rdata
.rdata:00002C4C                 ;org 2C4Ch
.rdata:00002C4C ; COMDAT (pick largest)
.rdata:00002C4C                 dd offset ??_R4error_category@std@@6B@ ; const std::error_category::`RTTI Complete Object Locator'
.rdata:00002C50                 public ??_7error_category@std@@6B@
.rdata:00002C50 ; const std::error_category::`vftable'
.rdata:00002C50 ??_7error_category@std@@6B@ dd offset ??_Eerror_category@std@@UAEPAXI@Z
.rdata:00002C50                                         ; DATA XREF: std::error_category::error_category(void)+Ao
.rdata:00002C50                                         ; std::error_category::~error_category(void)+Ao
.rdata:00002C50                                         ; std::error_category::`vector deleting destructor'(uint)
.rdata:00002C54                 dd offset __purecall
.rdata:00002C58                 dd offset __purecall
.rdata:00002C5C                 dd offset ?default_error_condition@error_category@std@@UBE?AVerror_condition@2@H@Z ; std::error_category::default_error_condition(int)
.rdata:00002C60                 dd offset ?equivalent@error_category@std@@UBE_NABVerror_code@2@H@Z ; std::error_category::equivalent(std::error_code const &,int)
.rdata:00002C64                 dd offset ?equivalent@error_category@std@@UBE_NHABVerror_condition@2@@Z ; std::error_category::equivalent(int,std::error_condition const &)
.rdata:00002C64 _rdata          ends
.rdata:00002C64
.rdata:00002C68 ; ===========================================================================
.rdata:00002C68
.rdata:00002C68 ; Segment type: Pure data
.rdata:00002C68 ; Segment permissions: Read
.rdata:00002C68 _rdata          segment dword public 'DATA' use32
.rdata:00002C68                 assume cs:_rdata
.rdata:00002C68                 ;org 2C68h
.rdata:00002C68 ; COMDAT (pick largest)
.rdata:00002C68                 dd offset ??_R4_Generic_error_category@std@@6B@ ; const std::_Generic_error_category::`RTTI Complete Object Locator'
.rdata:00002C6C                 public ??_7_Generic_error_category@std@@6B@
.rdata:00002C6C ; const std::_Generic_error_category::`vftable'
.rdata:00002C6C ??_7_Generic_error_category@std@@6B@ dd offset ??_E_Generic_error_category@std@@UAEPAXI@Z
.rdata:00002C6C                                         ; DATA XREF: std::_Generic_error_category::_Generic_error_category(void)+38o
.rdata:00002C6C                                         ; std::_Generic_error_category::`vector deleting destructor'(uint)
.rdata:00002C70                 dd offset ?name@_Generic_error_category@std@@UBEPBDXZ ; std::_Generic_error_category::name(void)
.rdata:00002C74                 dd offset ?message@_Generic_error_category@std@@UBE?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@2@H@Z ; std::_Generic_error_category::message(int)
.rdata:00002C78                 dd offset ?default_error_condition@error_category@std@@UBE?AVerror_condition@2@H@Z ; std::error_category::default_error_condition(int)
.rdata:00002C7C                 dd offset ?equivalent@error_category@std@@UBE_NABVerror_code@2@H@Z ; std::error_category::equivalent(std::error_code const &,int)
.rdata:00002C80                 dd offset ?equivalent@error_category@std@@UBE_NHABVerror_condition@2@@Z ; std::error_category::equivalent(int,std::error_condition const &)
.rdata:00002C80 _rdata          ends
.rdata:00002C80
.rdata:00002C84 ; ===========================================================================
.rdata:00002C84
.rdata:00002C84 ; Segment type: Pure data
.rdata:00002C84 ; Segment permissions: Read
.rdata:00002C84 _rdata          segment dword public 'DATA' use32
.rdata:00002C84                 assume cs:_rdata
.rdata:00002C84                 ;org 2C84h
.rdata:00002C84 ; COMDAT (pick any)
.rdata:00002C84                 public ??_C@_07DCLBNMLN@generic?$AA@
.rdata:00002C84 ; `string'
.rdata:00002C84 ??_C@_07DCLBNMLN@generic?$AA@ db 'generic',0
.rdata:00002C84                                         ; DATA XREF: std::_Generic_error_category::name(void)+7o
.rdata:00002C84 _rdata          ends
.rdata:00002C84
.rdata:00002C8C ; ===========================================================================
.rdata:00002C8C
.rdata:00002C8C ; Segment type: Pure data
.rdata:00002C8C ; Segment permissions: Read
.rdata:00002C8C _rdata          segment dword public 'DATA' use32
.rdata:00002C8C                 assume cs:_rdata
.rdata:00002C8C                 ;org 2C8Ch
.rdata:00002C8C ; COMDAT (pick any)
.rdata:00002C8C                 public ??_C@_0O@BFJCFAAK@unknown?5error?$AA@
.rdata:00002C8C ; `string'
.rdata:00002C8C ??_C@_0O@BFJCFAAK@unknown?5error?$AA@ db 'unknown error',0
.rdata:00002C8C                                         ; DATA XREF: std::_Generic_error_category::message(int):loc_24C0o
.rdata:00002C8C                                         ; std::_System_error_category::message(int):loc_263Co
.rdata:00002C9A                 align 4
.rdata:00002C9A _rdata          ends
.rdata:00002C9A
.rdata:00002C9C ; ===========================================================================
.rdata:00002C9C
.rdata:00002C9C ; Segment type: Pure data
.rdata:00002C9C ; Segment permissions: Read
.rdata:00002C9C _rdata          segment dword public 'DATA' use32
.rdata:00002C9C                 assume cs:_rdata
.rdata:00002C9C                 ;org 2C9Ch
.rdata:00002C9C ; COMDAT (pick largest)
.rdata:00002C9C                 dd offset ??_R4_Iostream_error_category@std@@6B@ ; const std::_Iostream_error_category::`RTTI Complete Object Locator'
.rdata:00002CA0                 public ??_7_Iostream_error_category@std@@6B@
.rdata:00002CA0 ; const std::_Iostream_error_category::`vftable'
.rdata:00002CA0 ??_7_Iostream_error_category@std@@6B@ dd offset ??_E_Iostream_error_category@std@@UAEPAXI@Z
.rdata:00002CA0                                         ; DATA XREF: std::_Iostream_error_category::_Iostream_error_category(void)+38o
.rdata:00002CA0                                         ; std::_Iostream_error_category::`vector deleting destructor'(uint)
.rdata:00002CA4                 dd offset ?name@_Iostream_error_category@std@@UBEPBDXZ ; std::_Iostream_error_category::name(void)
.rdata:00002CA8                 dd offset ?message@_Iostream_error_category@std@@UBE?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@2@H@Z ; std::_Iostream_error_category::message(int)
.rdata:00002CAC                 dd offset ?default_error_condition@error_category@std@@UBE?AVerror_condition@2@H@Z ; std::error_category::default_error_condition(int)
.rdata:00002CB0                 dd offset ?equivalent@error_category@std@@UBE_NABVerror_code@2@H@Z ; std::error_category::equivalent(std::error_code const &,int)
.rdata:00002CB4                 dd offset ?equivalent@error_category@std@@UBE_NHABVerror_condition@2@@Z ; std::error_category::equivalent(int,std::error_condition const &)
.rdata:00002CB4 _rdata          ends
.rdata:00002CB4
.rdata:00002CB8 ; ===========================================================================
.rdata:00002CB8
.rdata:00002CB8 ; Segment type: Pure data
.rdata:00002CB8 ; Segment permissions: Read
.rdata:00002CB8 _rdata          segment dword public 'DATA' use32
.rdata:00002CB8                 assume cs:_rdata
.rdata:00002CB8                 ;org 2CB8h
.rdata:00002CB8 ; COMDAT (pick any)
.rdata:00002CB8                 public ??_C@_08LLGCOLLL@iostream?$AA@
.rdata:00002CB8 ; `string'
.rdata:00002CB8 ??_C@_08LLGCOLLL@iostream?$AA@ db 'iostream',0
.rdata:00002CB8                                         ; DATA XREF: std::_Iostream_error_category::name(void)+7o
.rdata:00002CC1                 align 4
.rdata:00002CC1 _rdata          ends
.rdata:00002CC1
.rdata:00002CC4 ; ===========================================================================
.rdata:00002CC4
.rdata:00002CC4 ; Segment type: Pure data
.rdata:00002CC4 ; Segment permissions: Read
.rdata:00002CC4 _rdata          segment dword public 'DATA' use32
.rdata:00002CC4                 assume cs:_rdata
.rdata:00002CC4                 ;org 2CC4h
.rdata:00002CC4 ; COMDAT (pick any)
.rdata:00002CC4                 public ??_C@_0BG@PADBLCHM@iostream?5stream?5error?$AA@
.rdata:00002CC4 ; char `string'[]
.rdata:00002CC4 ??_C@_0BG@PADBLCHM@iostream?5stream?5error?$AA@ db 'iostream stream error',0
.rdata:00002CC4                                         ; DATA XREF: std::_Iostream_error_category::message(int)+35o
.rdata:00002CDA                 align 4
.rdata:00002CDA _rdata          ends
.rdata:00002CDA
.rdata:00002CDC ; ===========================================================================
.rdata:00002CDC
.rdata:00002CDC ; Segment type: Pure data
.rdata:00002CDC ; Segment permissions: Read
.rdata:00002CDC _rdata          segment dword public 'DATA' use32
.rdata:00002CDC                 assume cs:_rdata
.rdata:00002CDC                 ;org 2CDCh
.rdata:00002CDC ; COMDAT (pick largest)
.rdata:00002CDC                 dd offset ??_R4_System_error_category@std@@6B@ ; const std::_System_error_category::`RTTI Complete Object Locator'
.rdata:00002CE0                 public ??_7_System_error_category@std@@6B@
.rdata:00002CE0 ; const std::_System_error_category::`vftable'
.rdata:00002CE0 ??_7_System_error_category@std@@6B@ dd offset ??_E_System_error_category@std@@UAEPAXI@Z
.rdata:00002CE0                                         ; DATA XREF: std::_System_error_category::_System_error_category(void)+38o
.rdata:00002CE0                                         ; std::_System_error_category::`vector deleting destructor'(uint)
.rdata:00002CE4                 dd offset ?name@_System_error_category@std@@UBEPBDXZ ; std::_System_error_category::name(void)
.rdata:00002CE8                 dd offset ?message@_System_error_category@std@@UBE?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@2@H@Z ; std::_System_error_category::message(int)
.rdata:00002CEC                 dd offset ?default_error_condition@_System_error_category@std@@UBE?AVerror_condition@2@H@Z ; std::_System_error_category::default_error_condition(int)
.rdata:00002CF0                 dd offset ?equivalent@error_category@std@@UBE_NABVerror_code@2@H@Z ; std::error_category::equivalent(std::error_code const &,int)
.rdata:00002CF4                 dd offset ?equivalent@error_category@std@@UBE_NHABVerror_condition@2@@Z ; std::error_category::equivalent(int,std::error_condition const &)
.rdata:00002CF4 _rdata          ends
.rdata:00002CF4
.rdata:00002CF8 ; ===========================================================================
.rdata:00002CF8
.rdata:00002CF8 ; Segment type: Pure data
.rdata:00002CF8 ; Segment permissions: Read
.rdata:00002CF8 _rdata          segment dword public 'DATA' use32
.rdata:00002CF8                 assume cs:_rdata
.rdata:00002CF8                 ;org 2CF8h
.rdata:00002CF8 ; COMDAT (pick any)
.rdata:00002CF8                 public ??_C@_06FHFOAHML@system?$AA@
.rdata:00002CF8 ; `string'
.rdata:00002CF8 ??_C@_06FHFOAHML@system?$AA@ db 'system',0
.rdata:00002CF8                                         ; DATA XREF: std::_System_error_category::name(void)+7o
.rdata:00002CFF                 align 10h
.rdata:00002CFF _rdata          ends
.rdata:00002CFF
.bss:00002D00 ; ===========================================================================
.bss:00002D00
.bss:00002D00 ; Segment type: Uninitialized
.bss:00002D00 ; Segment permissions: Read/Write
.bss:00002D00 _bss            segment dword public 'BSS' use32
.bss:00002D00                 assume cs:_bss
.bss:00002D00                 ;org 2D00h
.bss:00002D00 ; COMDAT (pick any)
.bss:00002D00                 assume es:nothing, ss:nothing, ds:_xdata$x, fs:nothing, gs:nothing
.bss:00002D00                 public ?_Generic_object@?$_Error_objects@H@std@@2V_Generic_error_category@2@A
.bss:00002D00 ; std::_Generic_error_category std::_Error_objects<int>::_Generic_object
.bss:00002D00 ?_Generic_object@?$_Error_objects@H@std@@2V_Generic_error_category@2@A db    ? ;
.bss:00002D00                                         ; DATA XREF: `dynamic initializer for 'std::_Generic_error_category std::_Error_objects<int>::_Generic_object''(void)+3o
.bss:00002D00                                         ; `dynamic atexit destructor for 'std::_Generic_error_category std::_Error_objects<int>::_Generic_object''(void)+3o ...
.bss:00002D01                 db    ? ;
.bss:00002D02                 db    ? ;
.bss:00002D03                 db    ? ;
.bss:00002D03 _bss            ends
.bss:00002D03
.bss:00002D04 ; ===========================================================================
.bss:00002D04
.bss:00002D04 ; Segment type: Uninitialized
.bss:00002D04 ; Segment permissions: Read/Write
.bss:00002D04 _bss            segment dword public 'BSS' use32
.bss:00002D04                 assume cs:_bss
.bss:00002D04                 ;org 2D04h
.bss:00002D04 ; COMDAT (pick any)
.bss:00002D04                 assume es:nothing, ss:nothing, ds:_xdata$x, fs:nothing, gs:nothing
.bss:00002D04                 public ?_Iostream_object@?$_Error_objects@H@std@@2V_Iostream_error_category@2@A
.bss:00002D04 ; std::_Iostream_error_category std::_Error_objects<int>::_Iostream_object
.bss:00002D04 ?_Iostream_object@?$_Error_objects@H@std@@2V_Iostream_error_category@2@A db    ? ;
.bss:00002D04                                         ; DATA XREF: `dynamic initializer for 'std::_Iostream_error_category std::_Error_objects<int>::_Iostream_object''(void)+3o
.bss:00002D04                                         ; `dynamic atexit destructor for 'std::_Iostream_error_category std::_Error_objects<int>::_Iostream_object''(void)+3o
.bss:00002D05                 db    ? ;
.bss:00002D06                 db    ? ;
.bss:00002D07                 db    ? ;
.bss:00002D07 _bss            ends
.bss:00002D07
.bss:00002D08 ; ===========================================================================
.bss:00002D08
.bss:00002D08 ; Segment type: Uninitialized
.bss:00002D08 ; Segment permissions: Read/Write
.bss:00002D08 _bss            segment dword public 'BSS' use32
.bss:00002D08                 assume cs:_bss
.bss:00002D08                 ;org 2D08h
.bss:00002D08 ; COMDAT (pick any)
.bss:00002D08                 assume es:nothing, ss:nothing, ds:_xdata$x, fs:nothing, gs:nothing
.bss:00002D08                 public ?_System_object@?$_Error_objects@H@std@@2V_System_error_category@2@A
.bss:00002D08 ; std::_System_error_category std::_Error_objects<int>::_System_object
.bss:00002D08 ?_System_object@?$_Error_objects@H@std@@2V_System_error_category@2@A db    ? ;
.bss:00002D08                                         ; DATA XREF: `dynamic initializer for 'std::_System_error_category std::_Error_objects<int>::_System_object''(void)+3o
.bss:00002D08                                         ; `dynamic atexit destructor for 'std::_System_error_category std::_Error_objects<int>::_System_object''(void)+3o ...
.bss:00002D09                 db    ? ;
.bss:00002D0A                 db    ? ;
.bss:00002D0B                 db    ? ;
.bss:00002D0B _bss            ends
.bss:00002D0B
.bss:00002D0C ; ===========================================================================
.bss:00002D0C
.bss:00002D0C ; Segment type: Uninitialized
.bss:00002D0C ; Segment permissions: Read/Write
.bss:00002D0C _bss            segment dword public 'BSS' use32
.bss:00002D0C                 assume cs:_bss
.bss:00002D0C                 ;org 2D0Ch
.bss:00002D0C ; COMDAT (pick any)
.bss:00002D0C                 assume es:nothing, ss:nothing, ds:_xdata$x, fs:nothing, gs:nothing
.bss:00002D0C                 public ?id@?$num_put@DV?$back_insert_iterator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@std@@2V0locale@2@A
.bss:00002D0C ; std::locale::id std::num_put<char,std::back_insert_iterator<std::basic_string<char,std::char_traits<char>,std::allocator<char>>>>::id
.bss:00002D0C ?id@?$num_put@DV?$back_insert_iterator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@std@@2V0locale@2@A db    ? ;
.bss:00002D0C                                         ; DATA XREF: `dynamic initializer for 'std::locale::id std::num_put<char,std::back_insert_iterator<std::basic_string<char,std::char_traits<char>,std::allocator<char>>>>::id''(void)+5o
.bss:00002D0D                 db    ? ;
.bss:00002D0E                 db    ? ;
.bss:00002D0F                 db    ? ;
.bss:00002D0F _bss            ends
.bss:00002D0F
.bss:00002D10 ; ===========================================================================
.bss:00002D10
.bss:00002D10 ; Segment type: Uninitialized
.bss:00002D10 ; Segment permissions: Read/Write
.bss:00002D10 _bss            segment dword public 'BSS' use32
.bss:00002D10                 assume cs:_bss
.bss:00002D10                 ;org 2D10h
.bss:00002D10 ; COMDAT (pick any)
.bss:00002D10                 assume es:nothing, ss:nothing, ds:_xdata$x, fs:nothing, gs:nothing
.bss:00002D10                 public ?id@?$num_put@_WV?$back_insert_iterator@V?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@@std@@@std@@2V0locale@2@A
.bss:00002D10 ; std::locale::id std::num_put<wchar_t,std::back_insert_iterator<std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>>>>::id
.bss:00002D10 ?id@?$num_put@_WV?$back_insert_iterator@V?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@@std@@@std@@2V0locale@2@A db    ? ;
.bss:00002D10                                         ; DATA XREF: `dynamic initializer for 'std::locale::id std::num_put<wchar_t,std::back_insert_iterator<std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>>>>::id''(void)+5o
.bss:00002D11                 db    ? ;
.bss:00002D12                 db    ? ;
.bss:00002D13                 db    ? ;
.bss:00002D13 _bss            ends
.bss:00002D13
.rdata:00002D14 ; ===========================================================================
.rdata:00002D14
.rdata:00002D14 ; Segment type: Pure data
.rdata:00002D14 ; Segment permissions: Read
.rdata:00002D14 ; Segment alignment 'qword' can not be represented in assembly
.rdata:00002D14 _rdata          segment para public 'DATA' use32
.rdata:00002D14                 assume cs:_rdata
.rdata:00002D14                 ;org 2D14h
.rdata:00002D14 ; COMDAT (pick any)
.rdata:00002D14                 public ??_C@_1IO@FEAPGJBD@?$AAC?$AA?3?$AA?2?$AAP?$AAr?$AAo?$AAg?$AAr?$AAa?$AAm?$AA?5?$AAF?$AAi?$AAl?$AAe?$AAs?$AA?5?$AA?$CI?$AAx?$AA8?$AA6?$AA?$CJ?$AA?2?$AAM?$AAi?$AAc?$AAr?$AAo?$AAs?$AAo?$AAf?$AAt@
.rdata:00002D14 ; wchar_t `string'
.rdata:00002D14 ??_C@_1IO@FEAPGJBD@?$AAC?$AA?3?$AA?2?$AAP?$AAr?$AAo?$AAg?$AAr?$AAa?$AAm?$AA?5?$AAF?$AAi?$AAl?$AAe?$AAs?$AA?5?$AA?$CI?$AAx?$AA8?$AA6?$AA?$CJ?$AA?2?$AAM?$AAi?$AAc?$AAr?$AAo?$AAs?$AAo?$AAf?$AAt@:
.rdata:00002D14                                         ; DATA XREF: std::basic_string<char,std::char_traits<char>,std::allocator<char>>::assign(char const *)+Co
.rdata:00002D14                                         ; std::basic_string<char,std::char_traits<char>,std::allocator<char>>::assign(char const *,uint)+12o ...
.rdata:00002D14                 unicode 0, <C:\Program Files (x86)\Microsoft Visual Studio 12.0\VC\in>
.rdata:00002D14                 unicode 0, <clude\xstring>,0
.rdata:00002DA2                 align 4
.rdata:00002DA2 _rdata          ends
.rdata:00002DA2
.bss:00002DA4 ; ===========================================================================
.bss:00002DA4
.bss:00002DA4 ; Segment type: Uninitialized
.bss:00002DA4 ; Segment permissions: Read/Write
.bss:00002DA4 _bss            segment dword public 'BSS' use32
.bss:00002DA4                 assume cs:_bss
.bss:00002DA4                 ;org 2DA4h
.bss:00002DA4 ; COMDAT (pick any)
.bss:00002DA4                 assume es:nothing, ss:nothing, ds:_xdata$x, fs:nothing, gs:nothing
.bss:00002DA4                 public ?id@?$numpunct@D@std@@2V0locale@2@A
.bss:00002DA4 ; std::locale::id std::numpunct<char>::id
.bss:00002DA4 ?id@?$numpunct@D@std@@2V0locale@2@A db    ? ;
.bss:00002DA4                                         ; DATA XREF: `dynamic initializer for 'std::locale::id std::numpunct<char>::id''(void)+5o
.bss:00002DA5                 db    ? ;
.bss:00002DA6                 db    ? ;
.bss:00002DA7                 db    ? ;
.bss:00002DA7 _bss            ends
.bss:00002DA7
.bss:00002DA8 ; ===========================================================================
.bss:00002DA8
.bss:00002DA8 ; Segment type: Uninitialized
.bss:00002DA8 ; Segment permissions: Read/Write
.bss:00002DA8 _bss            segment dword public 'BSS' use32
.bss:00002DA8                 assume cs:_bss
.bss:00002DA8                 ;org 2DA8h
.bss:00002DA8 ; COMDAT (pick any)
.bss:00002DA8                 assume es:nothing, ss:nothing, ds:_xdata$x, fs:nothing, gs:nothing
.bss:00002DA8                 public ?id@?$numpunct@_W@std@@2V0locale@2@A
.bss:00002DA8 ; std::locale::id std::numpunct<wchar_t>::id
.bss:00002DA8 ?id@?$numpunct@_W@std@@2V0locale@2@A db    ? ;
.bss:00002DA8                                         ; DATA XREF: `dynamic initializer for 'std::locale::id std::numpunct<wchar_t>::id''(void)+5o
.bss:00002DA9                 db    ? ;
.bss:00002DAA                 db    ? ;
.bss:00002DAB                 db    ? ;
.bss:00002DAB _bss            ends
.bss:00002DAB
.rdata:00002DAC ; ===========================================================================
.rdata:00002DAC
.rdata:00002DAC ; Segment type: Pure data
.rdata:00002DAC ; Segment permissions: Read
.rdata:00002DAC _rdata          segment dword public 'DATA' use32
.rdata:00002DAC                 assume cs:_rdata
.rdata:00002DAC                 ;org 2DACh
.rdata:00002DAC ; COMDAT (pick any)
.rdata:00002DAC                 public ??_C@_0BA@JFNIOLAK@string?5too?5long?$AA@
.rdata:00002DAC ; char `string'[]
.rdata:00002DAC ??_C@_0BA@JFNIOLAK@string?5too?5long?$AA@ db 'string too long',0
.rdata:00002DAC                                         ; DATA XREF: std::basic_string<char,std::char_traits<char>,std::allocator<char>>::_Xlen(void)+7o
.rdata:00002DAC                                         ; std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>>::_Xlen(void)+7o
.rdata:00002DAC _rdata          ends
.rdata:00002DAC
.rdata:00002DBC ; ===========================================================================
.rdata:00002DBC
.rdata:00002DBC ; Segment type: Pure data
.rdata:00002DBC ; Segment permissions: Read
.rdata:00002DBC _rdata          segment dword public 'DATA' use32
.rdata:00002DBC                 assume cs:_rdata
.rdata:00002DBC                 ;org 2DBCh
.rdata:00002DBC ; COMDAT (pick any)
.rdata:00002DBC                 public ??_C@_0BI@CFPLBAOH@invalid?5string?5position?$AA@
.rdata:00002DBC ; char `string'[]
.rdata:00002DBC ??_C@_0BI@CFPLBAOH@invalid?5string?5position?$AA@ db 'invalid string position',0
.rdata:00002DBC                                         ; DATA XREF: std::basic_string<char,std::char_traits<char>,std::allocator<char>>::_Xran(void)+7o
.rdata:00002DBC                                         ; std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>>::_Xran(void)+7o
.rdata:00002DBC _rdata          ends
.rdata:00002DBC
.rdata:00002DD4 ; ===========================================================================
.rdata:00002DD4
.rdata:00002DD4 ; Segment type: Pure data
.rdata:00002DD4 ; Segment permissions: Read
.rdata:00002DD4 _rdata          segment dword public 'DATA' use32
.rdata:00002DD4                 assume cs:_rdata
.rdata:00002DD4                 ;org 2DD4h
.rdata:00002DD4 ; COMDAT (pick any)
.rdata:00002DD4                 public ??_C@_1CK@EOPGIILJ@?$AAi?$AAn?$AAv?$AAa?$AAl?$AAi?$AAd?$AA?5?$AAn?$AAu?$AAl?$AAl?$AA?5?$AAp?$AAo?$AAi?$AAn?$AAt?$AAe?$AAr?$AA?$AA@
.rdata:00002DD4 ; wchar_t `string'
.rdata:00002DD4 ??_C@_1CK@EOPGIILJ@?$AAi?$AAn?$AAv?$AAa?$AAl?$AAi?$AAd?$AA?5?$AAn?$AAu?$AAl?$AAl?$AA?5?$AAp?$AAo?$AAi?$AAn?$AAt?$AAe?$AAr?$AA?$AA@:
.rdata:00002DD4                                         ; DATA XREF: std::_Debug_pointer<char>(char const *,wchar_t const *,uint)+11o
.rdata:00002DD4                                         ; std::_Debug_pointer<wchar_t>(wchar_t const *,wchar_t const *,uint)+11o
.rdata:00002DD4                 unicode 0, <invalid null pointer>,0
.rdata:00002DFE                 align 10h
.rdata:00002DFE _rdata          ends
.rdata:00002DFE
.rdata$r:00002E00 ; ===========================================================================
.rdata$r:00002E00
.rdata$r:00002E00 ; Segment type: Pure data
.rdata$r:00002E00 ; Segment permissions: Read
.rdata$r:00002E00 _rdata$r        segment dword public 'DATA' use32
.rdata$r:00002E00                 assume cs:_rdata$r
.rdata$r:00002E00                 ;org 2E00h
.rdata$r:00002E00 ; COMDAT (pick any)
.rdata$r:00002E00                 public ??_R4error_category@std@@6B@
.rdata$r:00002E00 ; const std::error_category::`RTTI Complete Object Locator'
.rdata$r:00002E00 ??_R4error_category@std@@6B@ db    0    ; DATA XREF: .rdata:00002C4Co
.rdata$r:00002E01                 db    0
.rdata$r:00002E02                 db    0
.rdata$r:00002E03                 db    0
.rdata$r:00002E04                 db    0
.rdata$r:00002E05                 db    0
.rdata$r:00002E06                 db    0
.rdata$r:00002E07                 db    0
.rdata$r:00002E08                 db    0
.rdata$r:00002E09                 db    0
.rdata$r:00002E0A                 db    0
.rdata$r:00002E0B                 db    0
.rdata$r:00002E0C                 dd offset ??_R0?AVerror_category@std@@@8 ; std::error_category `RTTI Type Descriptor'
.rdata$r:00002E10                 dd offset ??_R3error_category@std@@8 ; std::error_category::`RTTI Class Hierarchy Descriptor'
.rdata$r:00002E10 _rdata$r        ends
.rdata$r:00002E10
.data$r:00002E14 ; ===========================================================================
.data$r:00002E14
.data$r:00002E14 ; Segment type: Pure data
.data$r:00002E14 ; Segment permissions: Read/Write
.data$r:00002E14 _data$r         segment dword public 'DATA' use32
.data$r:00002E14                 assume cs:_data$r
.data$r:00002E14                 ;org 2E14h
.data$r:00002E14 ; COMDAT (pick any)
.data$r:00002E14                 public ??_R0?AVerror_category@std@@@8
.data$r:00002E14 ; class std::error_category `RTTI Type Descriptor'
.data$r:00002E14 ??_R0?AVerror_category@std@@@8 dd offset ??_7type_info@@6B@
.data$r:00002E14                                         ; DATA XREF: .rdata$r:00002E0Co
.data$r:00002E14                                         ; .rdata$r:std::error_category::`RTTI Base Class Descriptor at (0,-1,0,64)'o
.data$r:00002E14                                         ; const type_info::`vftable'
.data$r:00002E18                 db    0
.data$r:00002E19                 db    0
.data$r:00002E1A                 db    0
.data$r:00002E1B                 db    0
.data$r:00002E1C                 db  2Eh ; .
.data$r:00002E1D                 db  3Fh ; ?
.data$r:00002E1E                 db  41h ; A
.data$r:00002E1F                 db  56h ; V
.data$r:00002E20                 db  65h ; e
.data$r:00002E21                 db  72h ; r
.data$r:00002E22                 db  72h ; r
.data$r:00002E23                 db  6Fh ; o
.data$r:00002E24                 db  72h ; r
.data$r:00002E25                 db  5Fh ; _
.data$r:00002E26                 db  63h ; c
.data$r:00002E27                 db  61h ; a
.data$r:00002E28                 db  74h ; t
.data$r:00002E29                 db  65h ; e
.data$r:00002E2A                 db  67h ; g
.data$r:00002E2B                 db  6Fh ; o
.data$r:00002E2C                 db  72h ; r
.data$r:00002E2D                 db  79h ; y
.data$r:00002E2E                 db  40h ; @
.data$r:00002E2F                 db  73h ; s
.data$r:00002E30                 db  74h ; t
.data$r:00002E31                 db  64h ; d
.data$r:00002E32                 db  40h ; @
.data$r:00002E33                 db  40h ; @
.data$r:00002E34                 db    0
.data$r:00002E35                 align 4
.data$r:00002E35 _data$r         ends
.data$r:00002E35
.rdata$r:00002E38 ; ===========================================================================
.rdata$r:00002E38
.rdata$r:00002E38 ; Segment type: Pure data
.rdata$r:00002E38 ; Segment permissions: Read
.rdata$r:00002E38 _rdata$r        segment dword public 'DATA' use32
.rdata$r:00002E38                 assume cs:_rdata$r
.rdata$r:00002E38                 ;org 2E38h
.rdata$r:00002E38 ; COMDAT (pick any)
.rdata$r:00002E38                 public ??_R3error_category@std@@8
.rdata$r:00002E38 ; std::error_category::`RTTI Class Hierarchy Descriptor'
.rdata$r:00002E38 ??_R3error_category@std@@8 db    0      ; DATA XREF: .rdata$r:00002E10o
.rdata$r:00002E38                                         ; .rdata$r:00002E68o
.rdata$r:00002E39                 db    0
.rdata$r:00002E3A                 db    0
.rdata$r:00002E3B                 db    0
.rdata$r:00002E3C                 db    0
.rdata$r:00002E3D                 db    0
.rdata$r:00002E3E                 db    0
.rdata$r:00002E3F                 db    0
.rdata$r:00002E40                 db    1
.rdata$r:00002E41                 db    0
.rdata$r:00002E42                 db    0
.rdata$r:00002E43                 db    0
.rdata$r:00002E44                 dd offset ??_R2error_category@std@@8 ; std::error_category::`RTTI Base Class Array'
.rdata$r:00002E44 _rdata$r        ends
.rdata$r:00002E44
.rdata$r:00002E48 ; ===========================================================================
.rdata$r:00002E48
.rdata$r:00002E48 ; Segment type: Pure data
.rdata$r:00002E48 ; Segment permissions: Read
.rdata$r:00002E48 _rdata$r        segment dword public 'DATA' use32
.rdata$r:00002E48                 assume cs:_rdata$r
.rdata$r:00002E48                 ;org 2E48h
.rdata$r:00002E48 ; COMDAT (pick any)
.rdata$r:00002E48                 public ??_R2error_category@std@@8
.rdata$r:00002E48 ; std::error_category::`RTTI Base Class Array'
.rdata$r:00002E48 ??_R2error_category@std@@8 dd offset ??_R1A@?0A@EA@error_category@std@@8
.rdata$r:00002E48                                         ; DATA XREF: .rdata$r:00002E44o
.rdata$r:00002E48                                         ; std::error_category::`RTTI Base Class Descriptor at (0,-1,0,64)'
.rdata$r:00002E4C                 db    0
.rdata$r:00002E4D                 align 10h
.rdata$r:00002E4D _rdata$r        ends
.rdata$r:00002E4D
.rdata$r:00002E50 ; ===========================================================================
.rdata$r:00002E50
.rdata$r:00002E50 ; Segment type: Pure data
.rdata$r:00002E50 ; Segment permissions: Read
.rdata$r:00002E50 _rdata$r        segment dword public 'DATA' use32
.rdata$r:00002E50                 assume cs:_rdata$r
.rdata$r:00002E50                 ;org 2E50h
.rdata$r:00002E50 ; COMDAT (pick any)
.rdata$r:00002E50                 public ??_R1A@?0A@EA@error_category@std@@8
.rdata$r:00002E50 ; std::error_category::`RTTI Base Class Descriptor at (0, -1, 0, 64)'
.rdata$r:00002E50 ??_R1A@?0A@EA@error_category@std@@8 dd offset ??_R0?AVerror_category@std@@@8
.rdata$r:00002E50                                         ; DATA XREF: .rdata$r:std::error_category::`RTTI Base Class Array'o
.rdata$r:00002E50                                         ; .rdata$r:00002EC0o ...
.rdata$r:00002E50                                         ; std::error_category `RTTI Type Descriptor'
.rdata$r:00002E54                 db    0
.rdata$r:00002E55                 db    0
.rdata$r:00002E56                 db    0
.rdata$r:00002E57                 db    0
.rdata$r:00002E58                 db    0
.rdata$r:00002E59                 db    0
.rdata$r:00002E5A                 db    0
.rdata$r:00002E5B                 db    0
.rdata$r:00002E5C                 db 0FFh
.rdata$r:00002E5D                 db 0FFh
.rdata$r:00002E5E                 db 0FFh
.rdata$r:00002E5F                 db 0FFh
.rdata$r:00002E60                 db    0
.rdata$r:00002E61                 db    0
.rdata$r:00002E62                 db    0
.rdata$r:00002E63                 db    0
.rdata$r:00002E64                 db  40h ; @
.rdata$r:00002E65                 db    0
.rdata$r:00002E66                 db    0
.rdata$r:00002E67                 db    0
.rdata$r:00002E68                 dd offset ??_R3error_category@std@@8 ; std::error_category::`RTTI Class Hierarchy Descriptor'
.rdata$r:00002E68 _rdata$r        ends
.rdata$r:00002E68
.rdata$r:00002E6C ; ===========================================================================
.rdata$r:00002E6C
.rdata$r:00002E6C ; Segment type: Pure data
.rdata$r:00002E6C ; Segment permissions: Read
.rdata$r:00002E6C _rdata$r        segment dword public 'DATA' use32
.rdata$r:00002E6C                 assume cs:_rdata$r
.rdata$r:00002E6C                 ;org 2E6Ch
.rdata$r:00002E6C ; COMDAT (pick any)
.rdata$r:00002E6C                 public ??_R4_Generic_error_category@std@@6B@
.rdata$r:00002E6C ; const std::_Generic_error_category::`RTTI Complete Object Locator'
.rdata$r:00002E6C ??_R4_Generic_error_category@std@@6B@ db    0
.rdata$r:00002E6C                                         ; DATA XREF: .rdata:00002C68o
.rdata$r:00002E6D                 db    0
.rdata$r:00002E6E                 db    0
.rdata$r:00002E6F                 db    0
.rdata$r:00002E70                 db    0
.rdata$r:00002E71                 db    0
.rdata$r:00002E72                 db    0
.rdata$r:00002E73                 db    0
.rdata$r:00002E74                 db    0
.rdata$r:00002E75                 db    0
.rdata$r:00002E76                 db    0
.rdata$r:00002E77                 db    0
.rdata$r:00002E78                 dd offset ??_R0?AV_Generic_error_category@std@@@8 ; std::_Generic_error_category `RTTI Type Descriptor'
.rdata$r:00002E7C                 dd offset ??_R3_Generic_error_category@std@@8 ; std::_Generic_error_category::`RTTI Class Hierarchy Descriptor'
.rdata$r:00002E7C _rdata$r        ends
.rdata$r:00002E7C
.data$r:00002E80 ; ===========================================================================
.data$r:00002E80
.data$r:00002E80 ; Segment type: Pure data
.data$r:00002E80 ; Segment permissions: Read/Write
.data$r:00002E80 _data$r         segment dword public 'DATA' use32
.data$r:00002E80                 assume cs:_data$r
.data$r:00002E80                 ;org 2E80h
.data$r:00002E80 ; COMDAT (pick any)
.data$r:00002E80                 public ??_R0?AV_Generic_error_category@std@@@8
.data$r:00002E80 ; class std::_Generic_error_category `RTTI Type Descriptor'
.data$r:00002E80 ??_R0?AV_Generic_error_category@std@@@8 dd offset ??_7type_info@@6B@
.data$r:00002E80                                         ; DATA XREF: .rdata$r:00002E78o
.data$r:00002E80                                         ; .rdata$r:std::_Generic_error_category::`RTTI Base Class Descriptor at (0,-1,0,64)'o
.data$r:00002E80                                         ; const type_info::`vftable'
.data$r:00002E84                 align 8
.data$r:00002E88 a_?av_generic_e db '.?AV_Generic_error_category@std@@',0
.data$r:00002EAA                 align 4
.data$r:00002EAA _data$r         ends
.data$r:00002EAA
.rdata$r:00002EAC ; ===========================================================================
.rdata$r:00002EAC
.rdata$r:00002EAC ; Segment type: Pure data
.rdata$r:00002EAC ; Segment permissions: Read
.rdata$r:00002EAC _rdata$r        segment dword public 'DATA' use32
.rdata$r:00002EAC                 assume cs:_rdata$r
.rdata$r:00002EAC                 ;org 2EACh
.rdata$r:00002EAC ; COMDAT (pick any)
.rdata$r:00002EAC                 public ??_R3_Generic_error_category@std@@8
.rdata$r:00002EAC ; std::_Generic_error_category::`RTTI Class Hierarchy Descriptor'
.rdata$r:00002EAC ??_R3_Generic_error_category@std@@8 db    0
.rdata$r:00002EAC                                         ; DATA XREF: .rdata$r:00002E7Co
.rdata$r:00002EAC                                         ; .rdata$r:00002EE0o
.rdata$r:00002EAD                 db    0
.rdata$r:00002EAE                 db    0
.rdata$r:00002EAF                 db    0
.rdata$r:00002EB0                 db    0
.rdata$r:00002EB1                 db    0
.rdata$r:00002EB2                 db    0
.rdata$r:00002EB3                 db    0
.rdata$r:00002EB4                 db    2
.rdata$r:00002EB5                 db    0
.rdata$r:00002EB6                 db    0
.rdata$r:00002EB7                 db    0
.rdata$r:00002EB8                 dd offset ??_R2_Generic_error_category@std@@8 ; std::_Generic_error_category::`RTTI Base Class Array'
.rdata$r:00002EB8 _rdata$r        ends
.rdata$r:00002EB8
.rdata$r:00002EBC ; ===========================================================================
.rdata$r:00002EBC
.rdata$r:00002EBC ; Segment type: Pure data
.rdata$r:00002EBC ; Segment permissions: Read
.rdata$r:00002EBC _rdata$r        segment dword public 'DATA' use32
.rdata$r:00002EBC                 assume cs:_rdata$r
.rdata$r:00002EBC                 ;org 2EBCh
.rdata$r:00002EBC ; COMDAT (pick any)
.rdata$r:00002EBC                 public ??_R2_Generic_error_category@std@@8
.rdata$r:00002EBC ; std::_Generic_error_category::`RTTI Base Class Array'
.rdata$r:00002EBC ??_R2_Generic_error_category@std@@8 dd offset ??_R1A@?0A@EA@_Generic_error_category@std@@8
.rdata$r:00002EBC                                         ; DATA XREF: .rdata$r:00002EB8o
.rdata$r:00002EBC                                         ; std::_Generic_error_category::`RTTI Base Class Descriptor at (0,-1,0,64)'
.rdata$r:00002EC0                 dd offset ??_R1A@?0A@EA@error_category@std@@8 ; std::error_category::`RTTI Base Class Descriptor at (0,-1,0,64)'
.rdata$r:00002EC4                 db    0
.rdata$r:00002EC5                 align 4
.rdata$r:00002EC5 _rdata$r        ends
.rdata$r:00002EC5
.rdata$r:00002EC8 ; ===========================================================================
.rdata$r:00002EC8
.rdata$r:00002EC8 ; Segment type: Pure data
.rdata$r:00002EC8 ; Segment permissions: Read
.rdata$r:00002EC8 _rdata$r        segment dword public 'DATA' use32
.rdata$r:00002EC8                 assume cs:_rdata$r
.rdata$r:00002EC8                 ;org 2EC8h
.rdata$r:00002EC8 ; COMDAT (pick any)
.rdata$r:00002EC8                 public ??_R1A@?0A@EA@_Generic_error_category@std@@8
.rdata$r:00002EC8 ; std::_Generic_error_category::`RTTI Base Class Descriptor at (0, -1, 0, 64)'
.rdata$r:00002EC8 ??_R1A@?0A@EA@_Generic_error_category@std@@8 dd offset ??_R0?AV_Generic_error_category@std@@@8
.rdata$r:00002EC8                                         ; DATA XREF: .rdata$r:std::_Generic_error_category::`RTTI Base Class Array'o
.rdata$r:00002EC8                                         ; .rdata$r:00002F38o ...
.rdata$r:00002EC8                                         ; std::_Generic_error_category `RTTI Type Descriptor'
.rdata$r:00002ECC                 db    1
.rdata$r:00002ECD                 db    0
.rdata$r:00002ECE                 db    0
.rdata$r:00002ECF                 db    0
.rdata$r:00002ED0                 db    0
.rdata$r:00002ED1                 db    0
.rdata$r:00002ED2                 db    0
.rdata$r:00002ED3                 db    0
.rdata$r:00002ED4                 db 0FFh
.rdata$r:00002ED5                 db 0FFh
.rdata$r:00002ED6                 db 0FFh
.rdata$r:00002ED7                 db 0FFh
.rdata$r:00002ED8                 db    0
.rdata$r:00002ED9                 db    0
.rdata$r:00002EDA                 db    0
.rdata$r:00002EDB                 db    0
.rdata$r:00002EDC                 db  40h ; @
.rdata$r:00002EDD                 db    0
.rdata$r:00002EDE                 db    0
.rdata$r:00002EDF                 db    0
.rdata$r:00002EE0                 dd offset ??_R3_Generic_error_category@std@@8 ; std::_Generic_error_category::`RTTI Class Hierarchy Descriptor'
.rdata$r:00002EE0 _rdata$r        ends
.rdata$r:00002EE0
.rdata$r:00002EE4 ; ===========================================================================
.rdata$r:00002EE4
.rdata$r:00002EE4 ; Segment type: Pure data
.rdata$r:00002EE4 ; Segment permissions: Read
.rdata$r:00002EE4 _rdata$r        segment dword public 'DATA' use32
.rdata$r:00002EE4                 assume cs:_rdata$r
.rdata$r:00002EE4                 ;org 2EE4h
.rdata$r:00002EE4 ; COMDAT (pick any)
.rdata$r:00002EE4                 public ??_R4_Iostream_error_category@std@@6B@
.rdata$r:00002EE4 ; const std::_Iostream_error_category::`RTTI Complete Object Locator'
.rdata$r:00002EE4 ??_R4_Iostream_error_category@std@@6B@ db    0
.rdata$r:00002EE4                                         ; DATA XREF: .rdata:00002C9Co
.rdata$r:00002EE5                 db    0
.rdata$r:00002EE6                 db    0
.rdata$r:00002EE7                 db    0
.rdata$r:00002EE8                 db    0
.rdata$r:00002EE9                 db    0
.rdata$r:00002EEA                 db    0
.rdata$r:00002EEB                 db    0
.rdata$r:00002EEC                 db    0
.rdata$r:00002EED                 db    0
.rdata$r:00002EEE                 db    0
.rdata$r:00002EEF                 db    0
.rdata$r:00002EF0                 dd offset ??_R0?AV_Iostream_error_category@std@@@8 ; std::_Iostream_error_category `RTTI Type Descriptor'
.rdata$r:00002EF4                 dd offset ??_R3_Iostream_error_category@std@@8 ; std::_Iostream_error_category::`RTTI Class Hierarchy Descriptor'
.rdata$r:00002EF4 _rdata$r        ends
.rdata$r:00002EF4
.data$r:00002EF8 ; ===========================================================================
.data$r:00002EF8
.data$r:00002EF8 ; Segment type: Pure data
.data$r:00002EF8 ; Segment permissions: Read/Write
.data$r:00002EF8 _data$r         segment dword public 'DATA' use32
.data$r:00002EF8                 assume cs:_data$r
.data$r:00002EF8                 ;org 2EF8h
.data$r:00002EF8 ; COMDAT (pick any)
.data$r:00002EF8                 public ??_R0?AV_Iostream_error_category@std@@@8
.data$r:00002EF8 ; class std::_Iostream_error_category `RTTI Type Descriptor'
.data$r:00002EF8 ??_R0?AV_Iostream_error_category@std@@@8 dd offset ??_7type_info@@6B@
.data$r:00002EF8                                         ; DATA XREF: .rdata$r:00002EF0o
.data$r:00002EF8                                         ; .rdata$r:std::_Iostream_error_category::`RTTI Base Class Descriptor at (0,-1,0,64)'o
.data$r:00002EF8                                         ; const type_info::`vftable'
.data$r:00002EFC                 align 10h
.data$r:00002F00 a_?av_iostream_ db '.?AV_Iostream_error_category@std@@',0
.data$r:00002F23                 align 4
.data$r:00002F23 _data$r         ends
.data$r:00002F23
.rdata$r:00002F24 ; ===========================================================================
.rdata$r:00002F24
.rdata$r:00002F24 ; Segment type: Pure data
.rdata$r:00002F24 ; Segment permissions: Read
.rdata$r:00002F24 _rdata$r        segment dword public 'DATA' use32
.rdata$r:00002F24                 assume cs:_rdata$r
.rdata$r:00002F24                 ;org 2F24h
.rdata$r:00002F24 ; COMDAT (pick any)
.rdata$r:00002F24                 public ??_R3_Iostream_error_category@std@@8
.rdata$r:00002F24 ; std::_Iostream_error_category::`RTTI Class Hierarchy Descriptor'
.rdata$r:00002F24 ??_R3_Iostream_error_category@std@@8 db    0
.rdata$r:00002F24                                         ; DATA XREF: .rdata$r:00002EF4o
.rdata$r:00002F24                                         ; .rdata$r:00002F5Co
.rdata$r:00002F25                 db    0
.rdata$r:00002F26                 db    0
.rdata$r:00002F27                 db    0
.rdata$r:00002F28                 db    0
.rdata$r:00002F29                 db    0
.rdata$r:00002F2A                 db    0
.rdata$r:00002F2B                 db    0
.rdata$r:00002F2C                 db    3
.rdata$r:00002F2D                 db    0
.rdata$r:00002F2E                 db    0
.rdata$r:00002F2F                 db    0
.rdata$r:00002F30                 dd offset ??_R2_Iostream_error_category@std@@8 ; std::_Iostream_error_category::`RTTI Base Class Array'
.rdata$r:00002F30 _rdata$r        ends
.rdata$r:00002F30
.rdata$r:00002F34 ; ===========================================================================
.rdata$r:00002F34
.rdata$r:00002F34 ; Segment type: Pure data
.rdata$r:00002F34 ; Segment permissions: Read
.rdata$r:00002F34 _rdata$r        segment dword public 'DATA' use32
.rdata$r:00002F34                 assume cs:_rdata$r
.rdata$r:00002F34                 ;org 2F34h
.rdata$r:00002F34 ; COMDAT (pick any)
.rdata$r:00002F34                 public ??_R2_Iostream_error_category@std@@8
.rdata$r:00002F34 ; std::_Iostream_error_category::`RTTI Base Class Array'
.rdata$r:00002F34 ??_R2_Iostream_error_category@std@@8 dd offset ??_R1A@?0A@EA@_Iostream_error_category@std@@8
.rdata$r:00002F34                                         ; DATA XREF: .rdata$r:00002F30o
.rdata$r:00002F34                                         ; std::_Iostream_error_category::`RTTI Base Class Descriptor at (0,-1,0,64)'
.rdata$r:00002F38                 dd offset ??_R1A@?0A@EA@_Generic_error_category@std@@8 ; std::_Generic_error_category::`RTTI Base Class Descriptor at (0,-1,0,64)'
.rdata$r:00002F3C                 dd offset ??_R1A@?0A@EA@error_category@std@@8 ; std::error_category::`RTTI Base Class Descriptor at (0,-1,0,64)'
.rdata$r:00002F40                 db    0
.rdata$r:00002F41                 align 4
.rdata$r:00002F41 _rdata$r        ends
.rdata$r:00002F41
.rdata$r:00002F44 ; ===========================================================================
.rdata$r:00002F44
.rdata$r:00002F44 ; Segment type: Pure data
.rdata$r:00002F44 ; Segment permissions: Read
.rdata$r:00002F44 _rdata$r        segment dword public 'DATA' use32
.rdata$r:00002F44                 assume cs:_rdata$r
.rdata$r:00002F44                 ;org 2F44h
.rdata$r:00002F44 ; COMDAT (pick any)
.rdata$r:00002F44                 public ??_R1A@?0A@EA@_Iostream_error_category@std@@8
.rdata$r:00002F44 ; std::_Iostream_error_category::`RTTI Base Class Descriptor at (0, -1, 0, 64)'
.rdata$r:00002F44 ??_R1A@?0A@EA@_Iostream_error_category@std@@8 dd offset ??_R0?AV_Iostream_error_category@std@@@8
.rdata$r:00002F44                                         ; DATA XREF: .rdata$r:std::_Iostream_error_category::`RTTI Base Class Array'o
.rdata$r:00002F44                                         ; std::_Iostream_error_category `RTTI Type Descriptor'
.rdata$r:00002F48                 db    2
.rdata$r:00002F49                 db    0
.rdata$r:00002F4A                 db    0
.rdata$r:00002F4B                 db    0
.rdata$r:00002F4C                 db    0
.rdata$r:00002F4D                 db    0
.rdata$r:00002F4E                 db    0
.rdata$r:00002F4F                 db    0
.rdata$r:00002F50                 db 0FFh
.rdata$r:00002F51                 db 0FFh
.rdata$r:00002F52                 db 0FFh
.rdata$r:00002F53                 db 0FFh
.rdata$r:00002F54                 db    0
.rdata$r:00002F55                 db    0
.rdata$r:00002F56                 db    0
.rdata$r:00002F57                 db    0
.rdata$r:00002F58                 db  40h ; @
.rdata$r:00002F59                 db    0
.rdata$r:00002F5A                 db    0
.rdata$r:00002F5B                 db    0
.rdata$r:00002F5C                 dd offset ??_R3_Iostream_error_category@std@@8 ; std::_Iostream_error_category::`RTTI Class Hierarchy Descriptor'
.rdata$r:00002F5C _rdata$r        ends
.rdata$r:00002F5C
.rdata$r:00002F60 ; ===========================================================================
.rdata$r:00002F60
.rdata$r:00002F60 ; Segment type: Pure data
.rdata$r:00002F60 ; Segment permissions: Read
.rdata$r:00002F60 _rdata$r        segment dword public 'DATA' use32
.rdata$r:00002F60                 assume cs:_rdata$r
.rdata$r:00002F60                 ;org 2F60h
.rdata$r:00002F60 ; COMDAT (pick any)
.rdata$r:00002F60                 public ??_R4_System_error_category@std@@6B@
.rdata$r:00002F60 ; const std::_System_error_category::`RTTI Complete Object Locator'
.rdata$r:00002F60 ??_R4_System_error_category@std@@6B@ db    0 ; DATA XREF: .rdata:00002CDCo
.rdata$r:00002F61                 db    0
.rdata$r:00002F62                 db    0
.rdata$r:00002F63                 db    0
.rdata$r:00002F64                 db    0
.rdata$r:00002F65                 db    0
.rdata$r:00002F66                 db    0
.rdata$r:00002F67                 db    0
.rdata$r:00002F68                 db    0
.rdata$r:00002F69                 db    0
.rdata$r:00002F6A                 db    0
.rdata$r:00002F6B                 db    0
.rdata$r:00002F6C                 dd offset ??_R0?AV_System_error_category@std@@@8 ; std::_System_error_category `RTTI Type Descriptor'
.rdata$r:00002F70                 dd offset ??_R3_System_error_category@std@@8 ; std::_System_error_category::`RTTI Class Hierarchy Descriptor'
.rdata$r:00002F70 _rdata$r        ends
.rdata$r:00002F70
.data$r:00002F74 ; ===========================================================================
.data$r:00002F74
.data$r:00002F74 ; Segment type: Pure data
.data$r:00002F74 ; Segment permissions: Read/Write
.data$r:00002F74 _data$r         segment dword public 'DATA' use32
.data$r:00002F74                 assume cs:_data$r
.data$r:00002F74                 ;org 2F74h
.data$r:00002F74 ; COMDAT (pick any)
.data$r:00002F74                 public ??_R0?AV_System_error_category@std@@@8
.data$r:00002F74 ; class std::_System_error_category `RTTI Type Descriptor'
.data$r:00002F74 ??_R0?AV_System_error_category@std@@@8 dd offset ??_7type_info@@6B@
.data$r:00002F74                                         ; DATA XREF: .rdata$r:00002F6Co
.data$r:00002F74                                         ; .rdata$r:std::_System_error_category::`RTTI Base Class Descriptor at (0,-1,0,64)'o
.data$r:00002F74                                         ; const type_info::`vftable'
.data$r:00002F78                 db    0
.data$r:00002F79                 db    0
.data$r:00002F7A                 db    0
.data$r:00002F7B                 db    0
.data$r:00002F7C                 db  2Eh ; .
.data$r:00002F7D                 db  3Fh ; ?
.data$r:00002F7E                 db  41h ; A
.data$r:00002F7F                 db  56h ; V
.data$r:00002F80                 db  5Fh ; _
.data$r:00002F81                 db  53h ; S
.data$r:00002F82                 db  79h ; y
.data$r:00002F83                 db  73h ; s
.data$r:00002F84                 db  74h ; t
.data$r:00002F85                 db  65h ; e
.data$r:00002F86                 db  6Dh ; m
.data$r:00002F87                 db  5Fh ; _
.data$r:00002F88                 db  65h ; e
.data$r:00002F89                 db  72h ; r
.data$r:00002F8A                 db  72h ; r
.data$r:00002F8B                 db  6Fh ; o
.data$r:00002F8C                 db  72h ; r
.data$r:00002F8D                 db  5Fh ; _
.data$r:00002F8E                 db  63h ; c
.data$r:00002F8F                 db  61h ; a
.data$r:00002F90                 db  74h ; t
.data$r:00002F91                 db  65h ; e
.data$r:00002F92                 db  67h ; g
.data$r:00002F93                 db  6Fh ; o
.data$r:00002F94                 db  72h ; r
.data$r:00002F95                 db  79h ; y
.data$r:00002F96                 db  40h ; @
.data$r:00002F97                 db  73h ; s
.data$r:00002F98                 db  74h ; t
.data$r:00002F99                 db  64h ; d
.data$r:00002F9A                 db  40h ; @
.data$r:00002F9B                 db  40h ; @
.data$r:00002F9C                 db    0
.data$r:00002F9D                 align 10h
.data$r:00002F9D _data$r         ends
.data$r:00002F9D
.rdata$r:00002FA0 ; ===========================================================================
.rdata$r:00002FA0
.rdata$r:00002FA0 ; Segment type: Pure data
.rdata$r:00002FA0 ; Segment permissions: Read
.rdata$r:00002FA0 _rdata$r        segment dword public 'DATA' use32
.rdata$r:00002FA0                 assume cs:_rdata$r
.rdata$r:00002FA0                 ;org 2FA0h
.rdata$r:00002FA0 ; COMDAT (pick any)
.rdata$r:00002FA0                 public ??_R3_System_error_category@std@@8
.rdata$r:00002FA0 ; std::_System_error_category::`RTTI Class Hierarchy Descriptor'
.rdata$r:00002FA0 ??_R3_System_error_category@std@@8 db    0 ; DATA XREF: .rdata$r:00002F70o
.rdata$r:00002FA0                                         ; .rdata$r:00002FD8o
.rdata$r:00002FA1                 db    0
.rdata$r:00002FA2                 db    0
.rdata$r:00002FA3                 db    0
.rdata$r:00002FA4                 db    0
.rdata$r:00002FA5                 db    0
.rdata$r:00002FA6                 db    0
.rdata$r:00002FA7                 db    0
.rdata$r:00002FA8                 db    3
.rdata$r:00002FA9                 db    0
.rdata$r:00002FAA                 db    0
.rdata$r:00002FAB                 db    0
.rdata$r:00002FAC                 dd offset ??_R2_System_error_category@std@@8 ; std::_System_error_category::`RTTI Base Class Array'
.rdata$r:00002FAC _rdata$r        ends
.rdata$r:00002FAC
.rdata$r:00002FB0 ; ===========================================================================
.rdata$r:00002FB0
.rdata$r:00002FB0 ; Segment type: Pure data
.rdata$r:00002FB0 ; Segment permissions: Read
.rdata$r:00002FB0 _rdata$r        segment dword public 'DATA' use32
.rdata$r:00002FB0                 assume cs:_rdata$r
.rdata$r:00002FB0                 ;org 2FB0h
.rdata$r:00002FB0 ; COMDAT (pick any)
.rdata$r:00002FB0                 public ??_R2_System_error_category@std@@8
.rdata$r:00002FB0 ; std::_System_error_category::`RTTI Base Class Array'
.rdata$r:00002FB0 ??_R2_System_error_category@std@@8 dd offset ??_R1A@?0A@EA@_System_error_category@std@@8
.rdata$r:00002FB0                                         ; DATA XREF: .rdata$r:00002FACo
.rdata$r:00002FB0                                         ; std::_System_error_category::`RTTI Base Class Descriptor at (0,-1,0,64)'
.rdata$r:00002FB4                 dd offset ??_R1A@?0A@EA@_Generic_error_category@std@@8 ; std::_Generic_error_category::`RTTI Base Class Descriptor at (0,-1,0,64)'
.rdata$r:00002FB8                 dd offset ??_R1A@?0A@EA@error_category@std@@8 ; std::error_category::`RTTI Base Class Descriptor at (0,-1,0,64)'
.rdata$r:00002FBC                 db    0
.rdata$r:00002FBD                 align 10h
.rdata$r:00002FBD _rdata$r        ends
.rdata$r:00002FBD
.rdata$r:00002FC0 ; ===========================================================================
.rdata$r:00002FC0
.rdata$r:00002FC0 ; Segment type: Pure data
.rdata$r:00002FC0 ; Segment permissions: Read
.rdata$r:00002FC0 _rdata$r        segment dword public 'DATA' use32
.rdata$r:00002FC0                 assume cs:_rdata$r
.rdata$r:00002FC0                 ;org 2FC0h
.rdata$r:00002FC0 ; COMDAT (pick any)
.rdata$r:00002FC0                 public ??_R1A@?0A@EA@_System_error_category@std@@8
.rdata$r:00002FC0 ; std::_System_error_category::`RTTI Base Class Descriptor at (0, -1, 0, 64)'
.rdata$r:00002FC0 ??_R1A@?0A@EA@_System_error_category@std@@8 dd offset ??_R0?AV_System_error_category@std@@@8
.rdata$r:00002FC0                                         ; DATA XREF: .rdata$r:std::_System_error_category::`RTTI Base Class Array'o
.rdata$r:00002FC0                                         ; std::_System_error_category `RTTI Type Descriptor'
.rdata$r:00002FC4                 db    2
.rdata$r:00002FC5                 db    0
.rdata$r:00002FC6                 db    0
.rdata$r:00002FC7                 db    0
.rdata$r:00002FC8                 db    0
.rdata$r:00002FC9                 db    0
.rdata$r:00002FCA                 db    0
.rdata$r:00002FCB                 db    0
.rdata$r:00002FCC                 db 0FFh
.rdata$r:00002FCD                 db 0FFh
.rdata$r:00002FCE                 db 0FFh
.rdata$r:00002FCF                 db 0FFh
.rdata$r:00002FD0                 db    0
.rdata$r:00002FD1                 db    0
.rdata$r:00002FD2                 db    0
.rdata$r:00002FD3                 db    0
.rdata$r:00002FD4                 db  40h ; @
.rdata$r:00002FD5                 db    0
.rdata$r:00002FD6                 db    0
.rdata$r:00002FD7                 db    0
.rdata$r:00002FD8                 dd offset ??_R3_System_error_category@std@@8 ; std::_System_error_category::`RTTI Class Hierarchy Descriptor'
.rdata$r:00002FD8 _rdata$r        ends
.rdata$r:00002FD8
.CRT$XCU:00002FDC ; ===========================================================================
.CRT$XCU:00002FDC
.CRT$XCU:00002FDC ; Segment type: Pure data
.CRT$XCU:00002FDC ; Segment permissions: Read
.CRT$XCU:00002FDC _CRT$XCU        segment dword public 'DATA' use32
.CRT$XCU:00002FDC                 assume cs:_CRT$XCU
.CRT$XCU:00002FDC                 ;org 2FDCh
.CRT$XCU:00002FDC _piecewise_construct$initializer$ dd offset ??__Epiecewise_construct@std@@YAXXZ ; std::`dynamic initializer for 'piecewise_construct''(void)
.CRT$XCU:00002FE0 _allocator_arg$initializer$ dd offset ??__Eallocator_arg@std@@YAXXZ ; std::`dynamic initializer for 'allocator_arg''(void)
.CRT$XCU:00002FE0 _CRT$XCU        ends
.CRT$XCU:00002FE0
.CRT$XCU:00002FE4 ; ===========================================================================
.CRT$XCU:00002FE4
.CRT$XCU:00002FE4 ; Segment type: Pure data
.CRT$XCU:00002FE4 ; Segment permissions: Read
.CRT$XCU:00002FE4 _CRT$XCU        segment dword public 'DATA' use32
.CRT$XCU:00002FE4                 assume cs:_CRT$XCU
.CRT$XCU:00002FE4                 ;org 2FE4h
.CRT$XCU:00002FE4 ; COMDAT (pick associative to section at 2D00)
.CRT$XCU:00002FE4 ; public: static void (__cdecl *std::_Error_objects<int>::_Generic_object$initializer$)(void)
.CRT$XCU:00002FE4 ?_Generic_object$initializer$@?$_Error_objects@H@std@@2P6AXXZA dd offset ??__E?_Generic_object@?$_Error_objects@H@std@@2V_Generic_error_category@2@A@@YAXXZ ; `dynamic initializer for 'std::_Generic_error_category std::_Error_objects<int>::_Generic_object''(void)
.CRT$XCU:00002FE4 _CRT$XCU        ends
.CRT$XCU:00002FE4
.CRT$XCU:00002FE8 ; ===========================================================================
.CRT$XCU:00002FE8
.CRT$XCU:00002FE8 ; Segment type: Pure data
.CRT$XCU:00002FE8 ; Segment permissions: Read
.CRT$XCU:00002FE8 _CRT$XCU        segment dword public 'DATA' use32
.CRT$XCU:00002FE8                 assume cs:_CRT$XCU
.CRT$XCU:00002FE8                 ;org 2FE8h
.CRT$XCU:00002FE8 ; COMDAT (pick associative to section at 2D04)
.CRT$XCU:00002FE8 ; public: static void (__cdecl *std::_Error_objects<int>::_Iostream_object$initializer$)(void)
.CRT$XCU:00002FE8 ?_Iostream_object$initializer$@?$_Error_objects@H@std@@2P6AXXZA dd offset ??__E?_Iostream_object@?$_Error_objects@H@std@@2V_Iostream_error_category@2@A@@YAXXZ ; `dynamic initializer for 'std::_Iostream_error_category std::_Error_objects<int>::_Iostream_object''(void)
.CRT$XCU:00002FE8 _CRT$XCU        ends
.CRT$XCU:00002FE8
.CRT$XCU:00002FEC ; ===========================================================================
.CRT$XCU:00002FEC
.CRT$XCU:00002FEC ; Segment type: Pure data
.CRT$XCU:00002FEC ; Segment permissions: Read
.CRT$XCU:00002FEC _CRT$XCU        segment dword public 'DATA' use32
.CRT$XCU:00002FEC                 assume cs:_CRT$XCU
.CRT$XCU:00002FEC                 ;org 2FECh
.CRT$XCU:00002FEC ; COMDAT (pick associative to section at 2D08)
.CRT$XCU:00002FEC ; public: static void (__cdecl *std::_Error_objects<int>::_System_object$initializer$)(void)
.CRT$XCU:00002FEC ?_System_object$initializer$@?$_Error_objects@H@std@@2P6AXXZA dd offset ??__E?_System_object@?$_Error_objects@H@std@@2V_System_error_category@2@A@@YAXXZ ; `dynamic initializer for 'std::_System_error_category std::_Error_objects<int>::_System_object''(void)
.CRT$XCU:00002FEC _CRT$XCU        ends
.CRT$XCU:00002FEC
.CRT$XCU:00002FF0 ; ===========================================================================
.CRT$XCU:00002FF0
.CRT$XCU:00002FF0 ; Segment type: Pure data
.CRT$XCU:00002FF0 ; Segment permissions: Read
.CRT$XCU:00002FF0 _CRT$XCU        segment dword public 'DATA' use32
.CRT$XCU:00002FF0                 assume cs:_CRT$XCU
.CRT$XCU:00002FF0                 ;org 2FF0h
.CRT$XCU:00002FF0 ; COMDAT (pick associative to section at 2D0C)
.CRT$XCU:00002FF0 ; public: static void (__cdecl *std::num_put<char, class std::back_insert_iterator<class std::basic_string<char, struct std::char_traits<char>, class std::allocator<char>>>>::id$initializer$)(void)
.CRT$XCU:00002FF0 ?id$initializer$@?$num_put@DV?$back_insert_iterator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@std@@2P6AXXZA dd offset ??__E?id@?$num_put@DV?$back_insert_iterator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@std@@2V0locale@2@A@@YAXXZ ; `dynamic initializer for 'std::locale::id std::num_put<char,std::back_insert_iterator<std::basic_string<char,std::char_traits<char>,std::allocator<char>>>>::id''(void)
.CRT$XCU:00002FF0 _CRT$XCU        ends
.CRT$XCU:00002FF0
.CRT$XCU:00002FF4 ; ===========================================================================
.CRT$XCU:00002FF4
.CRT$XCU:00002FF4 ; Segment type: Pure data
.CRT$XCU:00002FF4 ; Segment permissions: Read
.CRT$XCU:00002FF4 _CRT$XCU        segment dword public 'DATA' use32
.CRT$XCU:00002FF4                 assume cs:_CRT$XCU
.CRT$XCU:00002FF4                 ;org 2FF4h
.CRT$XCU:00002FF4 ; COMDAT (pick associative to section at 2D10)
.CRT$XCU:00002FF4 ; public: static void (__cdecl *std::num_put<wchar_t, class std::back_insert_iterator<class std::basic_string<wchar_t, struct std::char_traits<wchar_t>, class std::allocator<wchar_t>>>>::id$initializer$)(void)
.CRT$XCU:00002FF4 ?id$initializer$@?$num_put@_WV?$back_insert_iterator@V?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@@std@@@std@@2P6AXXZA dd offset ??__E?id@?$num_put@_WV?$back_insert_iterator@V?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@@std@@@std@@2V0locale@2@A@@YAXXZ ; `dynamic initializer for 'std::locale::id std::num_put<wchar_t,std::back_insert_iterator<std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>>>>::id''(void)
.CRT$XCU:00002FF4 _CRT$XCU        ends
.CRT$XCU:00002FF4
.CRT$XCU:00002FF8 ; ===========================================================================
.CRT$XCU:00002FF8
.CRT$XCU:00002FF8 ; Segment type: Pure data
.CRT$XCU:00002FF8 ; Segment permissions: Read
.CRT$XCU:00002FF8 _CRT$XCU        segment dword public 'DATA' use32
.CRT$XCU:00002FF8                 assume cs:_CRT$XCU
.CRT$XCU:00002FF8                 ;org 2FF8h
.CRT$XCU:00002FF8 ; COMDAT (pick associative to section at 2DA4)
.CRT$XCU:00002FF8 ; public: static void (__cdecl *std::numpunct<char>::id$initializer$)(void)
.CRT$XCU:00002FF8 ?id$initializer$@?$numpunct@D@std@@2P6AXXZA dd offset ??__E?id@?$numpunct@D@std@@2V0locale@2@A@@YAXXZ ; `dynamic initializer for 'std::locale::id std::numpunct<char>::id''(void)
.CRT$XCU:00002FF8 _CRT$XCU        ends
.CRT$XCU:00002FF8
.CRT$XCU:00002FFC ; ===========================================================================
.CRT$XCU:00002FFC
.CRT$XCU:00002FFC ; Segment type: Pure data
.CRT$XCU:00002FFC ; Segment permissions: Read
.CRT$XCU:00002FFC _CRT$XCU        segment dword public 'DATA' use32
.CRT$XCU:00002FFC                 assume cs:_CRT$XCU
.CRT$XCU:00002FFC                 ;org 2FFCh
.CRT$XCU:00002FFC ; COMDAT (pick associative to section at 2DA8)
.CRT$XCU:00002FFC ; public: static void (__cdecl *std::numpunct<wchar_t>::id$initializer$)(void)
.CRT$XCU:00002FFC ?id$initializer$@?$numpunct@_W@std@@2P6AXXZA dd offset ??__E?id@?$numpunct@_W@std@@2V0locale@2@A@@YAXXZ ; `dynamic initializer for 'std::locale::id std::numpunct<wchar_t>::id''(void)
.CRT$XCU:00002FFC _CRT$XCU        ends
.CRT$XCU:00002FFC
UNDEF:00003000 ; ===========================================================================
UNDEF:00003000
UNDEF:00003000 ; Segment type: Externs
UNDEF:00003000 ; UNDEF
UNDEF:00003000                 extrn __purecall:near   ; DATA XREF: .rdata:00002C54o
UNDEF:00003000                                         ; .rdata:00002C58o
UNDEF:00003004 ; void *__cdecl operator new(unsigned int)
UNDEF:00003004                 extrn ??2@YAPAXI@Z:near ; CODE XREF: std::_Allocate<char>(uint,char *)+1Dp
UNDEF:00003004                                         ; std::_Allocate<std::_Container_proxy>(uint,std::_Container_proxy *)+23p ...
UNDEF:00003008 ; void __cdecl operator delete(void *)
UNDEF:00003008                 extrn ??3@YAXPAX@Z:near ; CODE XREF: std::_Generic_error_category::`scalar deleting destructor'(uint)+1Bp
UNDEF:00003008                                         ; std::_Iostream_error_category::`scalar deleting destructor'(uint)+1Bp ...
UNDEF:0000300C ; int __cdecl atexit(void (__cdecl *)())
UNDEF:0000300C                 extrn _atexit:near      ; CODE XREF: `dynamic initializer for 'std::_Generic_error_category std::_Error_objects<int>::_Generic_object''(void)+12p
UNDEF:0000300C                                         ; `dynamic initializer for 'std::_Iostream_error_category std::_Error_objects<int>::_Iostream_object''(void)+12p ...
UNDEF:00003010 ; void *__cdecl memcpy(void *Dst, const void *Src, size_t Size)
UNDEF:00003010                 extrn _memcpy:near      ; CODE XREF: std::char_traits<char>::copy(char *,char const *,uint)+1Ep
UNDEF:00003010                                         ; _wmemcpy+11p
UNDEF:00003014 ; size_t __cdecl strlen(const char *Str)
UNDEF:00003014                 extrn _strlen:near      ; CODE XREF: std::char_traits<char>::length(char const *)+1Bp
UNDEF:00003018 ; void *__cdecl memmove(void *Dst, const void *Src, size_t Size)
UNDEF:00003018                 extrn _memmove:near     ; CODE XREF: std::char_traits<char>::move(char *,char const *,uint)+1Ep
UNDEF:00003018                                         ; _wmemmove+11p
UNDEF:0000301C ; size_t __cdecl wcslen(const wchar_t *Str)
UNDEF:0000301C                 extrn _wcslen:near      ; CODE XREF: std::char_traits<wchar_t>::length(wchar_t const *)+1Bp
UNDEF:00003020 ; HGLOBAL __stdcall GlobalFree(HGLOBAL hMem)
UNDEF:00003020                 extrn __imp__GlobalFree@4:near
UNDEF:00003020                                         ; CODE XREF: ValueDlg::doDialog(tagPOINT,bool)+63p
UNDEF:00003020                                         ; DATA XREF: ValueDlg::doDialog(tagPOINT,bool)+63r
UNDEF:00003024 ; LRESULT __stdcall SendMessageW(HWND hWnd, UINT Msg, WPARAM wParam, LPARAM lParam)
UNDEF:00003024                 extrn __imp__SendMessageW@16:near
UNDEF:00003024                                         ; CODE XREF: ButtonDlg::run_dlgProc(uint,uint,long)+DAp
UNDEF:00003024                                         ; DATA XREF: ButtonDlg::run_dlgProc(uint,uint,long)+DAr
UNDEF:00003028 ; BOOL __stdcall MoveWindow(HWND hWnd, int X, int Y, int nWidth, int nHeight, BOOL bRepaint)
UNDEF:00003028                 extrn __imp__MoveWindow@24:near
UNDEF:00003028                                         ; CODE XREF: ValueDlg::reSizeValueBox(void)+ADp
UNDEF:00003028                                         ; ValueDlg::run_dlgProc(uint,uint,long)+B1p
UNDEF:00003028                                         ; DATA XREF: ...
UNDEF:0000302C ; INT_PTR __stdcall DialogBoxParamW(HINSTANCE hInstance, LPCWSTR lpTemplateName, HWND hWndParent, DLGPROC lpDialogFunc, LPARAM dwInitParam)
UNDEF:0000302C                 extrn __imp__DialogBoxParamW@20:near
UNDEF:0000302C                                         ; CODE XREF: ValueDlg::doDialog(tagPOINT,bool)+8Ap
UNDEF:0000302C                                         ; DATA XREF: ValueDlg::doDialog(tagPOINT,bool)+8Ar
UNDEF:00003030 ; INT_PTR __stdcall DialogBoxIndirectParamW(HINSTANCE hInstance, LPCDLGTEMPLATEW hDialogTemplate, HWND hWndParent, DLGPROC lpDialogFunc, LPARAM dwInitParam)
UNDEF:00003030                 extrn __imp__DialogBoxIndirectParamW@20:near
UNDEF:00003030                                         ; CODE XREF: ValueDlg::doDialog(tagPOINT,bool)+56p
UNDEF:00003030                                         ; DATA XREF: ValueDlg::doDialog(tagPOINT,bool)+56r
UNDEF:00003034 ; BOOL __stdcall EndDialog(HWND hDlg, INT_PTR nResult)
UNDEF:00003034                 extrn __imp__EndDialog@8:near
UNDEF:00003034                                         ; CODE XREF: ValueDlg::run_dlgProc(uint,uint,long)+F6p
UNDEF:00003034                                         ; ValueDlg::run_dlgProc(uint,uint,long)+10Cp
UNDEF:00003034                                         ; DATA XREF: ...
UNDEF:00003038 ; HWND __stdcall GetDlgItem(HWND hDlg, int nIDDlgItem)
UNDEF:00003038                 extrn __imp__GetDlgItem@8:near
UNDEF:00003038                                         ; CODE XREF: ValueDlg::reSizeValueBox(void)+2Fp
UNDEF:00003038                                         ; DATA XREF: ValueDlg::reSizeValueBox(void)+2Fr
UNDEF:0000303C ; BOOL __stdcall SetDlgItemInt(HWND hDlg, int nIDDlgItem, UINT uValue, BOOL bSigned)
UNDEF:0000303C                 extrn __imp__SetDlgItemInt@16:near
UNDEF:0000303C                                         ; CODE XREF: ValueDlg::run_dlgProc(uint,uint,long)+64p
UNDEF:0000303C                                         ; DATA XREF: ValueDlg::run_dlgProc(uint,uint,long)+64r
UNDEF:00003040 ; UINT __stdcall GetDlgItemInt(HWND hDlg, int nIDDlgItem, BOOL *lpTranslated, BOOL bSigned)
UNDEF:00003040                 extrn __imp__GetDlgItemInt@16:near
UNDEF:00003040                                         ; CODE XREF: ValueDlg::run_dlgProc(uint,uint,long)+E2p
UNDEF:00003040                                         ; DATA XREF: ValueDlg::run_dlgProc(uint,uint,long)+E2r
UNDEF:00003044 ; BOOL __stdcall SetDlgItemTextW(HWND hDlg, int nIDDlgItem, LPCWSTR lpString)
UNDEF:00003044                 extrn __imp__SetDlgItemTextW@12:near
UNDEF:00003044                                         ; CODE XREF: ValueDlg::run_dlgProc(uint,uint,long)+49p
UNDEF:00003044                                         ; DATA XREF: ValueDlg::run_dlgProc(uint,uint,long)+49r
UNDEF:00003048 ; BOOL __stdcall GetClientRect(HWND hWnd, LPRECT lpRect)
UNDEF:00003048                 extrn __imp__GetClientRect@8:near
UNDEF:00003048                                         ; CODE XREF: ValueDlg::run_dlgProc(uint,uint,long)+75p
UNDEF:00003048                                         ; DATA XREF: ValueDlg::run_dlgProc(uint,uint,long)+75r
UNDEF:0000304C ; BOOL __stdcall GetWindowRect(HWND hWnd, LPRECT lpRect)
UNDEF:0000304C                 extrn __imp__GetWindowRect@8:near
UNDEF:0000304C                                         ; CODE XREF: ValueDlg::reSizeValueBox(void)+40p
UNDEF:0000304C                                         ; DATA XREF: ValueDlg::reSizeValueBox(void)+40r
UNDEF:00003050 ; BOOL __stdcall ScreenToClient(HWND hWnd, LPPOINT lpPoint)
UNDEF:00003050                 extrn __imp__ScreenToClient@8:near
UNDEF:00003050                                         ; CODE XREF: ValueDlg::reSizeValueBox(void)+6Fp
UNDEF:00003050                                         ; DATA XREF: ValueDlg::reSizeValueBox(void)+6Fr
UNDEF:00003054 ; INT_PTR __stdcall StaticDialog::dlgProc(HWND, UINT, WPARAM, LPARAM)
UNDEF:00003054                 extrn ?dlgProc@StaticDialog@@KGHPAUHWND__@@IIJ@Z:near
UNDEF:00003054                                         ; DATA XREF: ValueDlg::doDialog(tagPOINT,bool)+3Fo
UNDEF:00003054                                         ; ValueDlg::doDialog(tagPOINT,bool)+72o
UNDEF:00003058 ; void *__thiscall StaticDialog::makeRTLResource(StaticDialog *__hidden this, int, struct DLGTEMPLATE **)
UNDEF:00003058                 extrn ?makeRTLResource@StaticDialog@@IAEPAXHPAPAUDLGTEMPLATE@@@Z:near
UNDEF:00003058                                         ; CODE XREF: ValueDlg::doDialog(tagPOINT,bool)+33p
UNDEF:0000305C ; _DWORD __thiscall std::_Lockit::_Lockit(std::_Lockit *__hidden this, int)
UNDEF:0000305C                 extrn ??0_Lockit@std@@QAE@H@Z:near
UNDEF:0000305C                                         ; CODE XREF: std::_Container_base12::_Orphan_all(void)+35p
UNDEF:00003060 ; _DWORD __thiscall std::_Lockit::~_Lockit(std::_Lockit *__hidden this)
UNDEF:00003060                 extrn ??1_Lockit@std@@QAE@XZ:near
UNDEF:00003060                                         ; CODE XREF: std::_Container_base12::_Orphan_all(void)+86p
UNDEF:00003060                                         ; __unwindfunclet$?_Orphan_all@_Container_base12@std@@QAEXXZ$0+3j
UNDEF:00003064                 extrn __hypot:near      ; CODE XREF: _hypot+1Dp
UNDEF:00003068 ; void __cdecl std::_Debug_message(const wchar_t *, const wchar_t *, unsigned int)
UNDEF:00003068                 extrn ?_Debug_message@std@@YAXPB_W0I@Z:near
UNDEF:00003068                                         ; CODE XREF: std::_Debug_pointer<char>(char const *,wchar_t const *,uint)+16p
UNDEF:00003068                                         ; std::_Debug_pointer<wchar_t>(wchar_t const *,wchar_t const *,uint)+16p
UNDEF:0000306C ; void __cdecl std::_Xbad_alloc()
UNDEF:0000306C                 extrn ?_Xbad_alloc@std@@YAXXZ:near
UNDEF:0000306C                                         ; CODE XREF: std::_Allocate<char>(uint,char *):loc_462p
UNDEF:0000306C                                         ; std::_Allocate<std::_Container_proxy>(uint,std::_Container_proxy *):loc_4A4p ...
UNDEF:00003070 ; void __cdecl std::_Xlength_error(const char *)
UNDEF:00003070                 extrn ?_Xlength_error@std@@YAXPBD@Z:near
UNDEF:00003070                                         ; CODE XREF: std::basic_string<char,std::char_traits<char>,std::allocator<char>>::_Xlen(void)+Cp
UNDEF:00003070                                         ; std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>>::_Xlen(void)+Cp
UNDEF:00003074 ; void __cdecl std::_Xout_of_range(const char *)
UNDEF:00003074                 extrn ?_Xout_of_range@std@@YAXPBD@Z:near
UNDEF:00003074                                         ; CODE XREF: std::basic_string<char,std::char_traits<char>,std::allocator<char>>::_Xran(void)+Cp
UNDEF:00003074                                         ; std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>>::_Xran(void)+Cp
UNDEF:00003078 ; public: virtual void * __thiscall std::error_category::`vector deleting destructor'(unsigned int)
UNDEF:00003078                 extrn ??_Eerror_category@std@@UAEPAXI@Z:near ; weak
UNDEF:00003078                                         ; DATA XREF: .rdata:const std::error_category::`vftable'o
UNDEF:0000307C ; const char *__cdecl std::_Syserror_map(int)
UNDEF:0000307C                 extrn ?_Syserror_map@std@@YAPBDH@Z:near
UNDEF:0000307C                                         ; CODE XREF: std::_System_error_category::default_error_condition(int)+Bp
UNDEF:0000307C                                         ; std::_Generic_error_category::message(int)+33p
UNDEF:00003080 ; const char *__cdecl std::_Winerror_map(int)
UNDEF:00003080                 extrn ?_Winerror_map@std@@YAPBDH@Z:near
UNDEF:00003080                                         ; CODE XREF: std::_System_error_category::message(int)+33p
UNDEF:00003084 ; public: virtual void * __thiscall std::_Generic_error_category::`vector deleting destructor'(unsigned int)
UNDEF:00003084                 extrn ??_E_Generic_error_category@std@@UAEPAXI@Z:near ; weak
UNDEF:00003084                                         ; DATA XREF: .rdata:const std::_Generic_error_category::`vftable'o
UNDEF:00003088 ; public: virtual void * __thiscall std::_Iostream_error_category::`vector deleting destructor'(unsigned int)
UNDEF:00003088                 extrn ??_E_Iostream_error_category@std@@UAEPAXI@Z:near ; weak
UNDEF:00003088                                         ; DATA XREF: .rdata:const std::_Iostream_error_category::`vftable'o
UNDEF:0000308C ; public: virtual void * __thiscall std::_System_error_category::`vector deleting destructor'(unsigned int)
UNDEF:0000308C                 extrn ??_E_System_error_category@std@@UAEPAXI@Z:near ; weak
UNDEF:0000308C                                         ; DATA XREF: .rdata:const std::_System_error_category::`vftable'o
UNDEF:00003090 ; __fastcall __security_check_cookie(x)
UNDEF:00003090                 extrn @__security_check_cookie@4:near
UNDEF:00003090                                         ; CODE XREF: ValueDlg::reSizeValueBox(void)+BBp
UNDEF:00003090                                         ; ValueDlg::run_dlgProc(uint,uint,long)+124p ...
UNDEF:00003094 ; __stdcall _CxxThrowException(x, x)
UNDEF:00003094                 extrn __CxxThrowException@8:near
UNDEF:00003094                                         ; CODE XREF: __catch$?_Copy@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEXII@Z$1+10p
UNDEF:00003094                                         ; __catch$?_Copy@?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QAEXII@Z$1+10p
UNDEF:00003098                 extrn ___CxxFrameHandler3:near
UNDEF:00003098                                         ; CODE XREF: __ehhandler$??$construct@PADAAPAD@?$allocator@D@std@@QAEXPAPADAAPAD@Z+16j
UNDEF:00003098                                         ; __ehhandler$??$construct@PA_WAAPA_W@?$allocator@_W@std@@QAEXPAPA_WAAPA_W@Z+16j ...
UNDEF:0000309C ; const type_info::`vftable'
UNDEF:0000309C                 extrn ??_7type_info@@6B@:near
UNDEF:0000309C                                         ; DATA XREF: .data$r:std::error_category `RTTI Type Descriptor'o
UNDEF:0000309C                                         ; .data$r:std::_Generic_error_category `RTTI Type Descriptor'o ...
UNDEF:000030A0                 extrn ___security_cookie:near
UNDEF:000030A0                                         ; DATA XREF: ValueDlg::reSizeValueBox(void)+6r
UNDEF:000030A0                                         ; ValueDlg::run_dlgProc(uint,uint,long)+6r ...
UNDEF:000030A4                 extrn __fltused:near
UNDEF:000030A4
UNDEF:000030A4
UNDEF:000030A4                 end