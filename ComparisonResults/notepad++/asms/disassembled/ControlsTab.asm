text$mn:00000000 ;
.text$mn:00000000 ; +-------------------------------------------------------------------------+
.text$mn:00000000 ; |   This file has been generated by The Interactive Disassembler (IDA)    |
.text$mn:00000000 ; |           Copyright (c) 2015 Hex-Rays, <support@hex-rays.com>           |
.text$mn:00000000 ; |                      License info: 48-3677-7074-51                      |
.text$mn:00000000 ; |             Michalis Polychronakis, Stony Brook University              |
.text$mn:00000000 ; +-------------------------------------------------------------------------+
.text$mn:00000000 ;
.text$mn:00000000 ; Input MD5   : FDC2DD0207FA329AC8C8464EA243F07C
.text$mn:00000000 ; Input CRC32 : C74A497F
.text$mn:00000000
.text$mn:00000000 ; File Name   : C:\workspace\notepad-plus-plus-6.7.9.2\PowerEditor\visual.net\Unicode Debug\ControlsTab.obj
.text$mn:00000000 ; Format      : COFF (X386MAGIC)
.text$mn:00000000 ; includelib "uuid.lib"
.text$mn:00000000 ; includelib "libcpmtd"
.text$mn:00000000 ; must resolve: ?_Generic_object@?$_Error_objects@H@std@@2V_Generic_error_category@2@A
.text$mn:00000000 ; must resolve: ?_Iostream_object@?$_Error_objects@H@std@@2V_Iostream_error_category@2@A
.text$mn:00000000 ; must resolve: ?_System_object@?$_Error_objects@H@std@@2V_System_error_category@2@A
.text$mn:00000000 ; must resolve: ?id@?$num_put@DV?$back_insert_iterator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@std@@2V0locale@2@A
.text$mn:00000000 ; must resolve: ?id@?$num_put@_WV?$back_insert_iterator@V?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@@std@@@std@@2V0locale@2@A
.text$mn:00000000 ; must resolve: ?id@?$numpunct@D@std@@2V0locale@2@A
.text$mn:00000000 ; must resolve: ?id@?$numpunct@_W@std@@2V0locale@2@A
.text$mn:00000000 ; includelib "LIBCMTD"
.text$mn:00000000 ; includelib "OLDNAMES"
.text$mn:00000000
.text$mn:00000000                 include uni.inc ; see unicode subdir of ida for info on unicode
.text$mn:00000000
.text$mn:00000000                 .686p
.text$mn:00000000                 .mmx
.text$mn:00000000                 .model flat
.text$mn:00000000
.text$mn:00000000 ; ===========================================================================
.text$mn:00000000
.text$mn:00000000 ; Segment type: Pure code
.text$mn:00000000 ; Segment permissions: Read/Execute
.text$mn:00000000 _text$mn        segment para public 'CODE' use32
.text$mn:00000000                 assume cs:_text$mn
.text$mn:00000000                 assume es:nothing, ss:nothing, ds:_xdata$x, fs:nothing, gs:nothing
.text$mn:00000000
.text$mn:00000000 ; =============== S U B R O U T I N E =======================================
.text$mn:00000000
.text$mn:00000000 ; Attributes: bp-based frame
.text$mn:00000000
.text$mn:00000000 ; public: void __thiscall ControlsTab::createTabs(class std::vector<struct DlgInfo, class std::allocator<struct DlgInfo>> &)
.text$mn:00000000                 public ?createTabs@ControlsTab@@QAEXAAV?$vector@UDlgInfo@@V?$allocator@UDlgInfo@@@std@@@std@@@Z
.text$mn:00000000 ?createTabs@ControlsTab@@QAEXAAV?$vector@UDlgInfo@@V?$allocator@UDlgInfo@@@std@@@std@@@Z proc near
.text$mn:00000000
.text$mn:00000000 var_C           = dword ptr -0Ch
.text$mn:00000000 var_8           = dword ptr -8
.text$mn:00000000 var_4           = dword ptr -4
.text$mn:00000000 arg_0           = dword ptr  8
.text$mn:00000000
.text$mn:00000000                 push    ebp
.text$mn:00000001                 mov     ebp, esp
.text$mn:00000003                 sub     esp, 0Ch
.text$mn:00000006                 mov     [ebp+var_8], ecx
.text$mn:00000009                 mov     eax, [ebp+var_8]
.text$mn:0000000C                 mov     ecx, [ebp+arg_0]
.text$mn:0000000F                 mov     [eax+30h], ecx
.text$mn:00000012                 mov     [ebp+var_4], 0
.text$mn:00000019                 mov     ecx, [ebp+arg_0]
.text$mn:0000001C                 call    ?size@?$vector@UDlgInfo@@V?$allocator@UDlgInfo@@@std@@@std@@QBEIXZ ; std::vector<DlgInfo,std::allocator<DlgInfo>>::size(void)
.text$mn:00000021                 mov     [ebp+var_C], eax
.text$mn:00000024                 jmp     short loc_2F
.text$mn:00000026 ; ---------------------------------------------------------------------------
.text$mn:00000026
.text$mn:00000026 loc_26:                                 ; CODE XREF: ControlsTab::createTabs(std::vector<DlgInfo,std::allocator<DlgInfo>> &)+56j
.text$mn:00000026                 mov     edx, [ebp+var_4]
.text$mn:00000029                 add     edx, 1
.text$mn:0000002C                 mov     [ebp+var_4], edx
.text$mn:0000002F
.text$mn:0000002F loc_2F:                                 ; CODE XREF: ControlsTab::createTabs(std::vector<DlgInfo,std::allocator<DlgInfo>> &)+24j
.text$mn:0000002F                 mov     eax, [ebp+var_4]
.text$mn:00000032                 cmp     eax, [ebp+var_C]
.text$mn:00000035                 jnb     short loc_58
.text$mn:00000037                 mov     ecx, [ebp+var_4]
.text$mn:0000003A                 push    ecx
.text$mn:0000003B                 mov     ecx, [ebp+arg_0]
.text$mn:0000003E                 call    ??A?$vector@UDlgInfo@@V?$allocator@UDlgInfo@@@std@@@std@@QAEAAUDlgInfo@@I@Z ; std::vector<DlgInfo,std::allocator<DlgInfo>>::operator[](uint)
.text$mn:00000043                 add     eax, 4
.text$mn:00000046                 mov     ecx, eax
.text$mn:00000048                 call    ?c_str@?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QBEPB_WXZ ; std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>>::c_str(void)
.text$mn:0000004D                 push    eax             ; wchar_t *
.text$mn:0000004E                 mov     ecx, [ebp+var_8] ; this
.text$mn:00000051                 call    ?insertAtEnd@TabBar@@QAEHPB_W@Z ; TabBar::insertAtEnd(wchar_t const *)
.text$mn:00000056                 jmp     short loc_26
.text$mn:00000058 ; ---------------------------------------------------------------------------
.text$mn:00000058
.text$mn:00000058 loc_58:                                 ; CODE XREF: ControlsTab::createTabs(std::vector<DlgInfo,std::allocator<DlgInfo>> &)+35j
.text$mn:00000058                 push    0               ; int
.text$mn:0000005A                 mov     ecx, [ebp+var_8] ; this
.text$mn:0000005D                 call    ?activateAt@TabBar@@QBEXH@Z ; TabBar::activateAt(int)
.text$mn:00000062                 push    0               ; int
.text$mn:00000064                 mov     ecx, [ebp+var_8] ; this
.text$mn:00000067                 call    ?activateWindowAt@ControlsTab@@QAEXH@Z ; ControlsTab::activateWindowAt(int)
.text$mn:0000006C                 mov     esp, ebp
.text$mn:0000006E                 pop     ebp
.text$mn:0000006F                 retn    4
.text$mn:0000006F ?createTabs@ControlsTab@@QAEXAAV?$vector@UDlgInfo@@V?$allocator@UDlgInfo@@@std@@@std@@@Z endp
.text$mn:0000006F
.text$mn:0000006F ; ---------------------------------------------------------------------------
.text$mn:00000072                 align 10h
.text$mn:00000080
.text$mn:00000080 ; =============== S U B R O U T I N E =======================================
.text$mn:00000080
.text$mn:00000080 ; Attributes: bp-based frame
.text$mn:00000080
.text$mn:00000080 ; void __thiscall ControlsTab::reSizeTo(ControlsTab *this, struct tagRECT *)
.text$mn:00000080                 public ?reSizeTo@ControlsTab@@UAEXAAUtagRECT@@@Z
.text$mn:00000080 ?reSizeTo@ControlsTab@@UAEXAAUtagRECT@@@Z proc near
.text$mn:00000080
.text$mn:00000080 var_C           = dword ptr -0Ch
.text$mn:00000080 var_8           = dword ptr -8
.text$mn:00000080 var_4           = dword ptr -4
.text$mn:00000080 arg_0           = dword ptr  8
.text$mn:00000080
.text$mn:00000080                 push    ebp
.text$mn:00000081                 mov     ebp, esp
.text$mn:00000083                 sub     esp, 0Ch
.text$mn:00000086                 mov     [ebp+var_4], ecx
.text$mn:00000089                 mov     eax, [ebp+arg_0]
.text$mn:0000008C                 push    eax             ; struct tagRECT *
.text$mn:0000008D                 mov     ecx, [ebp+var_4] ; this
.text$mn:00000090                 call    ?reSizeTo@TabBar@@UAEXAAUtagRECT@@@Z ; TabBar::reSizeTo(tagRECT &)
.text$mn:00000095                 mov     ecx, [ebp+arg_0]
.text$mn:00000098                 mov     edx, [ecx]
.text$mn:0000009A                 add     edx, 8
.text$mn:0000009D                 mov     eax, [ebp+arg_0]
.text$mn:000000A0                 mov     [eax], edx
.text$mn:000000A2                 mov     ecx, [ebp+arg_0]
.text$mn:000000A5                 mov     edx, [ecx+4]
.text$mn:000000A8                 add     edx, 8
.text$mn:000000AB                 mov     eax, [ebp+arg_0]
.text$mn:000000AE                 mov     [eax+4], edx
.text$mn:000000B1                 mov     ecx, [ebp+var_4]
.text$mn:000000B4                 movzx   edx, byte ptr [ecx+38h]
.text$mn:000000B8                 test    edx, edx
.text$mn:000000BA                 jz      short loc_F6
.text$mn:000000BC                 mov     eax, [ebp+arg_0]
.text$mn:000000BF                 mov     ecx, [eax+8]
.text$mn:000000C2                 sub     ecx, 28h ; '('
.text$mn:000000C5                 mov     edx, [ebp+arg_0]
.text$mn:000000C8                 mov     [edx+8], ecx
.text$mn:000000CB                 mov     eax, [ebp+arg_0]
.text$mn:000000CE                 mov     ecx, [eax+0Ch]
.text$mn:000000D1                 sub     ecx, 14h
.text$mn:000000D4                 mov     edx, [ebp+arg_0]
.text$mn:000000D7                 mov     [edx+0Ch], ecx
.text$mn:000000DA                 mov     ecx, [ebp+var_4] ; this
.text$mn:000000DD                 call    ?getRowCount@TabBar@@IBEJXZ ; TabBar::getRowCount(void)
.text$mn:000000E2                 cmp     eax, 2
.text$mn:000000E5                 jnz     short loc_F6
.text$mn:000000E7                 mov     eax, [ebp+arg_0]
.text$mn:000000EA                 mov     ecx, [eax+8]
.text$mn:000000ED                 sub     ecx, 14h
.text$mn:000000F0                 mov     edx, [ebp+arg_0]
.text$mn:000000F3                 mov     [edx+8], ecx
.text$mn:000000F6
.text$mn:000000F6 loc_F6:                                 ; CODE XREF: ControlsTab::reSizeTo(tagRECT &)+3Aj
.text$mn:000000F6                                         ; ControlsTab::reSizeTo(tagRECT &)+65j
.text$mn:000000F6                 mov     eax, [ebp+arg_0]
.text$mn:000000F9                 mov     ecx, [eax+0Ch]
.text$mn:000000FC                 sub     ecx, 37h ; '7'
.text$mn:000000FF                 mov     edx, [ebp+arg_0]
.text$mn:00000102                 mov     [edx+0Ch], ecx
.text$mn:00000105                 mov     eax, [ebp+arg_0]
.text$mn:00000108                 mov     ecx, [eax+8]
.text$mn:0000010B                 sub     ecx, 14h
.text$mn:0000010E                 mov     edx, [ebp+arg_0]
.text$mn:00000111                 mov     [edx+8], ecx
.text$mn:00000114                 mov     eax, [ebp+var_4]
.text$mn:00000117                 mov     ecx, [eax+34h]
.text$mn:0000011A                 push    ecx
.text$mn:0000011B                 mov     edx, [ebp+var_4]
.text$mn:0000011E                 mov     ecx, [edx+30h]
.text$mn:00000121                 call    ??A?$vector@UDlgInfo@@V?$allocator@UDlgInfo@@@std@@@std@@QAEAAUDlgInfo@@I@Z ; std::vector<DlgInfo,std::allocator<DlgInfo>>::operator[](uint)
.text$mn:00000126                 mov     eax, [eax]
.text$mn:00000128                 mov     [ebp+var_8], eax
.text$mn:0000012B                 mov     ecx, [ebp+arg_0]
.text$mn:0000012E                 push    ecx
.text$mn:0000012F                 mov     edx, [ebp+var_8]
.text$mn:00000132                 mov     eax, [edx]
.text$mn:00000134                 mov     ecx, [ebp+var_8]
.text$mn:00000137                 mov     edx, [eax+10h]
.text$mn:0000013A                 call    edx
.text$mn:0000013C                 mov     eax, [ebp+var_4]
.text$mn:0000013F                 mov     ecx, [eax+34h]
.text$mn:00000142                 push    ecx
.text$mn:00000143                 mov     edx, [ebp+var_4]
.text$mn:00000146                 mov     ecx, [edx+30h]
.text$mn:00000149                 call    ??A?$vector@UDlgInfo@@V?$allocator@UDlgInfo@@@std@@@std@@QAEAAUDlgInfo@@I@Z ; std::vector<DlgInfo,std::allocator<DlgInfo>>::operator[](uint)
.text$mn:0000014E                 mov     eax, [eax]
.text$mn:00000150                 mov     [ebp+var_C], eax
.text$mn:00000153                 push    0
.text$mn:00000155                 mov     ecx, [ebp+var_C]
.text$mn:00000158                 mov     edx, [ecx]
.text$mn:0000015A                 mov     ecx, [ebp+var_C]
.text$mn:0000015D                 mov     eax, [edx+18h]
.text$mn:00000160                 call    eax
.text$mn:00000162                 mov     esp, ebp
.text$mn:00000164                 pop     ebp
.text$mn:00000165                 retn    4
.text$mn:00000165 ?reSizeTo@ControlsTab@@UAEXAAUtagRECT@@@Z endp
.text$mn:00000165
.text$mn:00000165 ; ---------------------------------------------------------------------------
.text$mn:00000168                 align 10h
.text$mn:00000170
.text$mn:00000170 ; =============== S U B R O U T I N E =======================================
.text$mn:00000170
.text$mn:00000170 ; Attributes: bp-based frame
.text$mn:00000170
.text$mn:00000170 ; void __thiscall ControlsTab::activateWindowAt(ControlsTab *this, int)
.text$mn:00000170                 public ?activateWindowAt@ControlsTab@@QAEXH@Z
.text$mn:00000170 ?activateWindowAt@ControlsTab@@QAEXH@Z proc near
.text$mn:00000170                                         ; CODE XREF: ControlsTab::createTabs(std::vector<DlgInfo,std::allocator<DlgInfo>> &)+67p
.text$mn:00000170
.text$mn:00000170 var_C           = dword ptr -0Ch
.text$mn:00000170 var_8           = dword ptr -8
.text$mn:00000170 var_4           = dword ptr -4
.text$mn:00000170 arg_0           = dword ptr  8
.text$mn:00000170
.text$mn:00000170                 push    ebp
.text$mn:00000171                 mov     ebp, esp
.text$mn:00000173                 sub     esp, 0Ch
.text$mn:00000176                 mov     [ebp+var_4], ecx
.text$mn:00000179                 mov     eax, [ebp+var_4]
.text$mn:0000017C                 mov     ecx, [ebp+arg_0]
.text$mn:0000017F                 cmp     ecx, [eax+34h]
.text$mn:00000182                 jnz     short loc_186
.text$mn:00000184                 jmp     short loc_1D8
.text$mn:00000186 ; ---------------------------------------------------------------------------
.text$mn:00000186
.text$mn:00000186 loc_186:                                ; CODE XREF: ControlsTab::activateWindowAt(int)+12j
.text$mn:00000186                 mov     edx, [ebp+var_4]
.text$mn:00000189                 mov     eax, [edx+34h]
.text$mn:0000018C                 push    eax
.text$mn:0000018D                 mov     ecx, [ebp+var_4]
.text$mn:00000190                 mov     ecx, [ecx+30h]
.text$mn:00000193                 call    ??A?$vector@UDlgInfo@@V?$allocator@UDlgInfo@@@std@@@std@@QAEAAUDlgInfo@@I@Z ; std::vector<DlgInfo,std::allocator<DlgInfo>>::operator[](uint)
.text$mn:00000198                 mov     edx, [eax]
.text$mn:0000019A                 mov     [ebp+var_8], edx
.text$mn:0000019D                 push    0
.text$mn:0000019F                 mov     eax, [ebp+var_8]
.text$mn:000001A2                 mov     edx, [eax]
.text$mn:000001A4                 mov     ecx, [ebp+var_8]
.text$mn:000001A7                 mov     eax, [edx+0Ch]
.text$mn:000001AA                 call    eax
.text$mn:000001AC                 mov     ecx, [ebp+arg_0]
.text$mn:000001AF                 push    ecx
.text$mn:000001B0                 mov     edx, [ebp+var_4]
.text$mn:000001B3                 mov     ecx, [edx+30h]
.text$mn:000001B6                 call    ??A?$vector@UDlgInfo@@V?$allocator@UDlgInfo@@@std@@@std@@QAEAAUDlgInfo@@I@Z ; std::vector<DlgInfo,std::allocator<DlgInfo>>::operator[](uint)
.text$mn:000001BB                 mov     eax, [eax]
.text$mn:000001BD                 mov     [ebp+var_C], eax
.text$mn:000001C0                 push    1
.text$mn:000001C2                 mov     ecx, [ebp+var_C]
.text$mn:000001C5                 mov     edx, [ecx]
.text$mn:000001C7                 mov     ecx, [ebp+var_C]
.text$mn:000001CA                 mov     eax, [edx+0Ch]
.text$mn:000001CD                 call    eax
.text$mn:000001CF                 mov     ecx, [ebp+var_4]
.text$mn:000001D2                 mov     edx, [ebp+arg_0]
.text$mn:000001D5                 mov     [ecx+34h], edx
.text$mn:000001D8
.text$mn:000001D8 loc_1D8:                                ; CODE XREF: ControlsTab::activateWindowAt(int)+14j
.text$mn:000001D8                 mov     esp, ebp
.text$mn:000001DA                 pop     ebp
.text$mn:000001DB                 retn    4
.text$mn:000001DB ?activateWindowAt@ControlsTab@@QAEXH@Z endp
.text$mn:000001DB
.text$mn:000001DB ; ---------------------------------------------------------------------------
.text$mn:000001DE                 align 10h
.text$mn:000001E0
.text$mn:000001E0 ; =============== S U B R O U T I N E =======================================
.text$mn:000001E0
.text$mn:000001E0 ; Attributes: bp-based frame
.text$mn:000001E0
.text$mn:000001E0 ; void __thiscall ControlsTab::renameTab(ControlsTab *this, WPARAM wParam, const wchar_t *)
.text$mn:000001E0                 public ?renameTab@ControlsTab@@QAEXHPB_W@Z
.text$mn:000001E0 ?renameTab@ControlsTab@@QAEXHPB_W@Z proc near
.text$mn:000001E0                                         ; CODE XREF: ControlsTab::renameTab(wchar_t const *,wchar_t const *)+7Ap
.text$mn:000001E0
.text$mn:000001E0 lParam          = dword ptr -20h
.text$mn:000001E0 var_14          = dword ptr -14h
.text$mn:000001E0 var_4           = dword ptr -4
.text$mn:000001E0 wParam          = dword ptr  8
.text$mn:000001E0 arg_4           = dword ptr  0Ch
.text$mn:000001E0
.text$mn:000001E0                 push    ebp
.text$mn:000001E1                 mov     ebp, esp
.text$mn:000001E3                 sub     esp, 20h
.text$mn:000001E6                 mov     [ebp+var_4], ecx
.text$mn:000001E9                 mov     [ebp+lParam], 1
.text$mn:000001F0                 mov     eax, [ebp+arg_4]
.text$mn:000001F3                 mov     [ebp+var_14], eax
.text$mn:000001F6                 lea     ecx, [ebp+lParam]
.text$mn:000001F9                 push    ecx             ; lParam
.text$mn:000001FA                 mov     edx, [ebp+wParam]
.text$mn:000001FD                 push    edx             ; wParam
.text$mn:000001FE                 push    133Dh           ; Msg
.text$mn:00000203                 mov     eax, [ebp+var_4]
.text$mn:00000206                 mov     ecx, [eax+0Ch]
.text$mn:00000209                 push    ecx             ; hWnd
.text$mn:0000020A                 call    dword ptr ds:__imp__SendMessageW@16 ; SendMessageW(x,x,x,x)
.text$mn:00000210                 mov     esp, ebp
.text$mn:00000212                 pop     ebp
.text$mn:00000213                 retn    8
.text$mn:00000213 ?renameTab@ControlsTab@@QAEXHPB_W@Z endp
.text$mn:00000213
.text$mn:00000213 ; ---------------------------------------------------------------------------
.text$mn:00000216                 align 10h
.text$mn:00000220
.text$mn:00000220 ; =============== S U B R O U T I N E =======================================
.text$mn:00000220
.text$mn:00000220 ; Attributes: bp-based frame
.text$mn:00000220
.text$mn:00000220 ; bool __thiscall ControlsTab::renameTab(ControlsTab *this, const wchar_t *Str, const wchar_t *)
.text$mn:00000220                 public ?renameTab@ControlsTab@@QAE_NPB_W0@Z
.text$mn:00000220 ?renameTab@ControlsTab@@QAE_NPB_W0@Z proc near
.text$mn:00000220
.text$mn:00000220 var_10          = dword ptr -10h
.text$mn:00000220 var_C           = dword ptr -0Ch
.text$mn:00000220 wParam          = dword ptr -8
.text$mn:00000220 var_1           = byte ptr -1
.text$mn:00000220 Str             = dword ptr  8
.text$mn:00000220 arg_4           = dword ptr  0Ch
.text$mn:00000220
.text$mn:00000220                 push    ebp
.text$mn:00000221                 mov     ebp, esp
.text$mn:00000223                 sub     esp, 10h
.text$mn:00000226                 mov     [ebp+var_C], ecx
.text$mn:00000229                 mov     [ebp+var_1], 0
.text$mn:0000022D                 mov     [ebp+wParam], 0
.text$mn:00000234                 mov     eax, [ebp+var_C]
.text$mn:00000237                 mov     ecx, [eax+30h]
.text$mn:0000023A                 call    ?size@?$vector@UDlgInfo@@V?$allocator@UDlgInfo@@@std@@@std@@QBEIXZ ; std::vector<DlgInfo,std::allocator<DlgInfo>>::size(void)
.text$mn:0000023F                 mov     [ebp+var_10], eax
.text$mn:00000242                 jmp     short loc_24D
.text$mn:00000244 ; ---------------------------------------------------------------------------
.text$mn:00000244
.text$mn:00000244 loc_244:                                ; CODE XREF: ControlsTab::renameTab(wchar_t const *,wchar_t const *):loc_281j
.text$mn:00000244                 mov     ecx, [ebp+wParam]
.text$mn:00000247                 add     ecx, 1
.text$mn:0000024A                 mov     [ebp+wParam], ecx
.text$mn:0000024D
.text$mn:0000024D loc_24D:                                ; CODE XREF: ControlsTab::renameTab(wchar_t const *,wchar_t const *)+22j
.text$mn:0000024D                 mov     edx, [ebp+wParam]
.text$mn:00000250                 cmp     edx, [ebp+var_10]
.text$mn:00000253                 jnb     short loc_283
.text$mn:00000255                 mov     eax, [ebp+Str]
.text$mn:00000258                 push    eax             ; Str
.text$mn:00000259                 mov     ecx, [ebp+wParam]
.text$mn:0000025C                 push    ecx
.text$mn:0000025D                 mov     edx, [ebp+var_C]
.text$mn:00000260                 mov     ecx, [edx+30h]
.text$mn:00000263                 call    ??A?$vector@UDlgInfo@@V?$allocator@UDlgInfo@@@std@@@std@@QAEAAUDlgInfo@@I@Z ; std::vector<DlgInfo,std::allocator<DlgInfo>>::operator[](uint)
.text$mn:00000268                 add     eax, 20h ; ' '
.text$mn:0000026B                 push    eax             ; int
.text$mn:0000026C                 call    ??$?8_WU?$char_traits@_W@std@@V?$allocator@_W@1@@std@@YA_NABV?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@0@PB_W@Z ; std::operator==<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>>(std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>> const &,wchar_t const *)
.text$mn:00000271                 add     esp, 8
.text$mn:00000274                 movzx   eax, al
.text$mn:00000277                 test    eax, eax
.text$mn:00000279                 jz      short loc_281
.text$mn:0000027B                 mov     [ebp+var_1], 1
.text$mn:0000027F                 jmp     short loc_283
.text$mn:00000281 ; ---------------------------------------------------------------------------
.text$mn:00000281
.text$mn:00000281 loc_281:                                ; CODE XREF: ControlsTab::renameTab(wchar_t const *,wchar_t const *)+59j
.text$mn:00000281                 jmp     short loc_244
.text$mn:00000283 ; ---------------------------------------------------------------------------
.text$mn:00000283
.text$mn:00000283 loc_283:                                ; CODE XREF: ControlsTab::renameTab(wchar_t const *,wchar_t const *)+33j
.text$mn:00000283                                         ; ControlsTab::renameTab(wchar_t const *,wchar_t const *)+5Fj
.text$mn:00000283                 movzx   ecx, [ebp+var_1]
.text$mn:00000287                 test    ecx, ecx
.text$mn:00000289                 jnz     short loc_28F
.text$mn:0000028B                 xor     al, al
.text$mn:0000028D                 jmp     short loc_2A1
.text$mn:0000028F ; ---------------------------------------------------------------------------
.text$mn:0000028F
.text$mn:0000028F loc_28F:                                ; CODE XREF: ControlsTab::renameTab(wchar_t const *,wchar_t const *)+69j
.text$mn:0000028F                 mov     edx, [ebp+arg_4]
.text$mn:00000292                 push    edx             ; wchar_t *
.text$mn:00000293                 mov     eax, [ebp+wParam]
.text$mn:00000296                 push    eax             ; wParam
.text$mn:00000297                 mov     ecx, [ebp+var_C] ; this
.text$mn:0000029A                 call    ?renameTab@ControlsTab@@QAEXHPB_W@Z ; ControlsTab::renameTab(int,wchar_t const *)
.text$mn:0000029F                 mov     al, 1
.text$mn:000002A1
.text$mn:000002A1 loc_2A1:                                ; CODE XREF: ControlsTab::renameTab(wchar_t const *,wchar_t const *)+6Dj
.text$mn:000002A1                 mov     esp, ebp
.text$mn:000002A3                 pop     ebp
.text$mn:000002A4                 retn    8
.text$mn:000002A4 ?renameTab@ControlsTab@@QAE_NPB_W0@Z endp
.text$mn:000002A4
.text$mn:000002A4 ; ---------------------------------------------------------------------------
.text$mn:000002A7                 align 4
.text$mn:000002A7 _text$mn        ends
.text$mn:000002A7
.text$mn:000002A8 ; ===========================================================================
.text$mn:000002A8
.text$mn:000002A8 ; Segment type: Pure code
.text$mn:000002A8 ; Segment permissions: Read/Execute
.text$mn:000002A8 _text$mn        segment para public 'CODE' use32
.text$mn:000002A8                 assume cs:_text$mn
.text$mn:000002A8                 ;org 2A8h
.text$mn:000002A8 ; COMDAT (pick any)
.text$mn:000002A8                 assume es:nothing, ss:nothing, ds:_xdata$x, fs:nothing, gs:nothing
.text$mn:000002A8
.text$mn:000002A8 ; =============== S U B R O U T I N E =======================================
.text$mn:000002A8
.text$mn:000002A8 ; Attributes: bp-based frame
.text$mn:000002A8
.text$mn:000002A8 ; int __cdecl std::operator==<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>>(int, wchar_t *Str)
.text$mn:000002A8                 public ??$?8_WU?$char_traits@_W@std@@V?$allocator@_W@1@@std@@YA_NABV?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@0@PB_W@Z
.text$mn:000002A8 ??$?8_WU?$char_traits@_W@std@@V?$allocator@_W@1@@std@@YA_NABV?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@0@PB_W@Z proc near
.text$mn:000002A8                                         ; CODE XREF: ControlsTab::renameTab(wchar_t const *,wchar_t const *)+4Cp
.text$mn:000002A8
.text$mn:000002A8 var_4           = dword ptr -4
.text$mn:000002A8 arg_0           = dword ptr  8
.text$mn:000002A8 Str             = dword ptr  0Ch
.text$mn:000002A8
.text$mn:000002A8                 push    ebp
.text$mn:000002A9                 mov     ebp, esp
.text$mn:000002AB                 push    ecx
.text$mn:000002AC                 mov     eax, [ebp+Str]
.text$mn:000002AF                 push    eax             ; Str
.text$mn:000002B0                 mov     ecx, [ebp+arg_0]
.text$mn:000002B3                 call    ?compare@?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QBEHPB_W@Z ; std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>>::compare(wchar_t const *)
.text$mn:000002B8                 test    eax, eax
.text$mn:000002BA                 jnz     short loc_2C5
.text$mn:000002BC                 mov     [ebp+var_4], 1
.text$mn:000002C3                 jmp     short loc_2CC
.text$mn:000002C5 ; ---------------------------------------------------------------------------
.text$mn:000002C5
.text$mn:000002C5 loc_2C5:                                ; CODE XREF: std::operator==<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>>(std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>> const &,wchar_t const *)+12j
.text$mn:000002C5                 mov     [ebp+var_4], 0
.text$mn:000002CC
.text$mn:000002CC loc_2CC:                                ; CODE XREF: std::operator==<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>>(std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>> const &,wchar_t const *)+1Bj
.text$mn:000002CC                 mov     al, byte ptr [ebp+var_4]
.text$mn:000002CF                 mov     esp, ebp
.text$mn:000002D1                 pop     ebp
.text$mn:000002D2                 retn
.text$mn:000002D2 ??$?8_WU?$char_traits@_W@std@@V?$allocator@_W@1@@std@@YA_NABV?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@0@PB_W@Z endp
.text$mn:000002D2
.text$mn:000002D2 ; ---------------------------------------------------------------------------
.text$mn:000002D3                 align 4
.text$mn:000002D3 _text$mn        ends
.text$mn:000002D3
.text$mn:000002D4 ; ===========================================================================
.text$mn:000002D4
.text$mn:000002D4 ; Segment type: Pure code
.text$mn:000002D4 ; Segment permissions: Read/Execute
.text$mn:000002D4 _text$mn        segment para public 'CODE' use32
.text$mn:000002D4                 assume cs:_text$mn
.text$mn:000002D4                 ;org 2D4h
.text$mn:000002D4 ; COMDAT (pick any)
.text$mn:000002D4                 assume es:nothing, ss:nothing, ds:_xdata$x, fs:nothing, gs:nothing
.text$mn:000002D4
.text$mn:000002D4 ; =============== S U B R O U T I N E =======================================
.text$mn:000002D4
.text$mn:000002D4 ; Attributes: bp-based frame
.text$mn:000002D4
.text$mn:000002D4 ; char * __cdecl std::_Allocate<char>(unsigned int, char *)
.text$mn:000002D4                 public ??$_Allocate@D@std@@YAPADIPAD@Z
.text$mn:000002D4 ??$_Allocate@D@std@@YAPADIPAD@Z proc near
.text$mn:000002D4                                         ; CODE XREF: std::allocator<char>::allocate(uint)+Dp
.text$mn:000002D4
.text$mn:000002D4 var_4           = dword ptr -4
.text$mn:000002D4 arg_0           = dword ptr  8
.text$mn:000002D4
.text$mn:000002D4                 push    ebp
.text$mn:000002D5                 mov     ebp, esp
.text$mn:000002D7                 push    ecx
.text$mn:000002D8                 mov     [ebp+var_4], 0
.text$mn:000002DF                 cmp     [ebp+arg_0], 0
.text$mn:000002E3                 jnz     short loc_2E7
.text$mn:000002E5                 jmp     short loc_307
.text$mn:000002E7 ; ---------------------------------------------------------------------------
.text$mn:000002E7
.text$mn:000002E7 loc_2E7:                                ; CODE XREF: std::_Allocate<char>(uint,char *)+Fj
.text$mn:000002E7                 cmp     [ebp+arg_0], 0FFFFFFFFh
.text$mn:000002EB                 ja      short loc_302
.text$mn:000002ED                 mov     eax, [ebp+arg_0]
.text$mn:000002F0                 push    eax             ; unsigned int
.text$mn:000002F1                 call    ??2@YAPAXI@Z    ; operator new(uint)
.text$mn:000002F6                 add     esp, 4
.text$mn:000002F9                 mov     [ebp+var_4], eax
.text$mn:000002FC                 cmp     [ebp+var_4], 0
.text$mn:00000300                 jnz     short loc_307
.text$mn:00000302
.text$mn:00000302 loc_302:                                ; CODE XREF: std::_Allocate<char>(uint,char *)+17j
.text$mn:00000302                 call    ?_Xbad_alloc@std@@YAXXZ ; std::_Xbad_alloc(void)
.text$mn:00000307
.text$mn:00000307 loc_307:                                ; CODE XREF: std::_Allocate<char>(uint,char *)+11j
.text$mn:00000307                                         ; std::_Allocate<char>(uint,char *)+2Cj
.text$mn:00000307                 mov     eax, [ebp+var_4]
.text$mn:0000030A                 mov     esp, ebp
.text$mn:0000030C                 pop     ebp
.text$mn:0000030D                 retn
.text$mn:0000030D ??$_Allocate@D@std@@YAPADIPAD@Z endp
.text$mn:0000030D
.text$mn:0000030D ; ---------------------------------------------------------------------------
.text$mn:0000030E                 align 10h
.text$mn:0000030E _text$mn        ends
.text$mn:0000030E
.text$mn:00000310 ; ===========================================================================
.text$mn:00000310
.text$mn:00000310 ; Segment type: Pure code
.text$mn:00000310 ; Segment permissions: Read/Execute
.text$mn:00000310 _text$mn        segment para public 'CODE' use32
.text$mn:00000310                 assume cs:_text$mn
.text$mn:00000310                 ;org 310h
.text$mn:00000310 ; COMDAT (pick any)
.text$mn:00000310                 assume es:nothing, ss:nothing, ds:_xdata$x, fs:nothing, gs:nothing
.text$mn:00000310
.text$mn:00000310 ; =============== S U B R O U T I N E =======================================
.text$mn:00000310
.text$mn:00000310 ; Attributes: bp-based frame
.text$mn:00000310
.text$mn:00000310 ; struct std::_Container_proxy * __cdecl std::_Allocate<struct std::_Container_proxy>(unsigned int, struct std::_Container_proxy *)
.text$mn:00000310                 public ??$_Allocate@U_Container_proxy@std@@@std@@YAPAU_Container_proxy@0@IPAU10@@Z
.text$mn:00000310 ??$_Allocate@U_Container_proxy@std@@@std@@YAPAU_Container_proxy@0@IPAU10@@Z proc near
.text$mn:00000310                                         ; CODE XREF: std::allocator<std::_Container_proxy>::allocate(uint)+Dp
.text$mn:00000310
.text$mn:00000310 var_4           = dword ptr -4
.text$mn:00000310 arg_0           = dword ptr  8
.text$mn:00000310
.text$mn:00000310                 push    ebp
.text$mn:00000311                 mov     ebp, esp
.text$mn:00000313                 push    ecx
.text$mn:00000314                 mov     [ebp+var_4], 0
.text$mn:0000031B                 cmp     [ebp+arg_0], 0
.text$mn:0000031F                 jnz     short loc_323
.text$mn:00000321                 jmp     short loc_349
.text$mn:00000323 ; ---------------------------------------------------------------------------
.text$mn:00000323
.text$mn:00000323 loc_323:                                ; CODE XREF: std::_Allocate<std::_Container_proxy>(uint,std::_Container_proxy *)+Fj
.text$mn:00000323                 cmp     [ebp+arg_0], 1FFFFFFFh
.text$mn:0000032A                 ja      short loc_344
.text$mn:0000032C                 mov     eax, [ebp+arg_0]
.text$mn:0000032F                 shl     eax, 3
.text$mn:00000332                 push    eax             ; unsigned int
.text$mn:00000333                 call    ??2@YAPAXI@Z    ; operator new(uint)
.text$mn:00000338                 add     esp, 4
.text$mn:0000033B                 mov     [ebp+var_4], eax
.text$mn:0000033E                 cmp     [ebp+var_4], 0
.text$mn:00000342                 jnz     short loc_349
.text$mn:00000344
.text$mn:00000344 loc_344:                                ; CODE XREF: std::_Allocate<std::_Container_proxy>(uint,std::_Container_proxy *)+1Aj
.text$mn:00000344                 call    ?_Xbad_alloc@std@@YAXXZ ; std::_Xbad_alloc(void)
.text$mn:00000349
.text$mn:00000349 loc_349:                                ; CODE XREF: std::_Allocate<std::_Container_proxy>(uint,std::_Container_proxy *)+11j
.text$mn:00000349                                         ; std::_Allocate<std::_Container_proxy>(uint,std::_Container_proxy *)+32j
.text$mn:00000349                 mov     eax, [ebp+var_4]
.text$mn:0000034C                 mov     esp, ebp
.text$mn:0000034E                 pop     ebp
.text$mn:0000034F                 retn
.text$mn:0000034F ??$_Allocate@U_Container_proxy@std@@@std@@YAPAU_Container_proxy@0@IPAU10@@Z endp
.text$mn:0000034F
.text$mn:0000034F _text$mn        ends
.text$mn:0000034F
.text$mn:00000350 ; ===========================================================================
.text$mn:00000350
.text$mn:00000350 ; Segment type: Pure code
.text$mn:00000350 ; Segment permissions: Read/Execute
.text$mn:00000350 _text$mn        segment para public 'CODE' use32
.text$mn:00000350                 assume cs:_text$mn
.text$mn:00000350                 ;org 350h
.text$mn:00000350 ; COMDAT (pick any)
.text$mn:00000350                 assume es:nothing, ss:nothing, ds:_xdata$x, fs:nothing, gs:nothing
.text$mn:00000350
.text$mn:00000350 ; =============== S U B R O U T I N E =======================================
.text$mn:00000350
.text$mn:00000350 ; Attributes: bp-based frame
.text$mn:00000350
.text$mn:00000350 ; int __cdecl std::_Debug_pointer<char>(int, wchar_t *, unsigned int)
.text$mn:00000350                 public ??$_Debug_pointer@D@std@@YAXPBDPB_WI@Z
.text$mn:00000350 ??$_Debug_pointer@D@std@@YAXPBDPB_WI@Z proc near
.text$mn:00000350                                         ; CODE XREF: std::basic_string<char,std::char_traits<char>,std::allocator<char>>::assign(char const *)+15p
.text$mn:00000350                                         ; std::basic_string<char,std::char_traits<char>,std::allocator<char>>::assign(char const *,uint)+1Bp
.text$mn:00000350
.text$mn:00000350 arg_0           = dword ptr  8
.text$mn:00000350 arg_4           = dword ptr  0Ch
.text$mn:00000350 arg_8           = dword ptr  10h
.text$mn:00000350
.text$mn:00000350                 push    ebp
.text$mn:00000351                 mov     ebp, esp
.text$mn:00000353                 cmp     [ebp+arg_0], 0
.text$mn:00000357                 jnz     short loc_36E
.text$mn:00000359                 mov     eax, [ebp+arg_8]
.text$mn:0000035C                 push    eax             ; unsigned int
.text$mn:0000035D                 mov     ecx, [ebp+arg_4]
.text$mn:00000360                 push    ecx             ; wchar_t *
.text$mn:00000361                 push    offset ??_C@_1CK@EOPGIILJ@?$AAi?$AAn?$AAv?$AAa?$AAl?$AAi?$AAd?$AA?5?$AAn?$AAu?$AAl?$AAl?$AA?5?$AAp?$AAo?$AAi?$AAn?$AAt?$AAe?$AAr?$AA?$AA@ ; "invalid null pointer"
.text$mn:00000366                 call    ?_Debug_message@std@@YAXPB_W0I@Z ; std::_Debug_message(wchar_t const *,wchar_t const *,uint)
.text$mn:0000036B                 add     esp, 0Ch
.text$mn:0000036E
.text$mn:0000036E loc_36E:                                ; CODE XREF: std::_Debug_pointer<char>(char const *,wchar_t const *,uint)+7j
.text$mn:0000036E                 pop     ebp
.text$mn:0000036F                 retn
.text$mn:0000036F ??$_Debug_pointer@D@std@@YAXPBDPB_WI@Z endp
.text$mn:0000036F
.text$mn:0000036F _text$mn        ends
.text$mn:0000036F
.text$mn:00000370 ; ===========================================================================
.text$mn:00000370
.text$mn:00000370 ; Segment type: Pure code
.text$mn:00000370 ; Segment permissions: Read/Execute
.text$mn:00000370 _text$mn        segment para public 'CODE' use32
.text$mn:00000370                 assume cs:_text$mn
.text$mn:00000370                 ;org 370h
.text$mn:00000370 ; COMDAT (pick any)
.text$mn:00000370                 assume es:nothing, ss:nothing, ds:_xdata$x, fs:nothing, gs:nothing
.text$mn:00000370
.text$mn:00000370 ; =============== S U B R O U T I N E =======================================
.text$mn:00000370
.text$mn:00000370 ; Attributes: bp-based frame
.text$mn:00000370
.text$mn:00000370 ; int __cdecl std::_Debug_pointer<wchar_t>(int, wchar_t *, unsigned int)
.text$mn:00000370                 public ??$_Debug_pointer@_W@std@@YAXPB_W0I@Z
.text$mn:00000370 ??$_Debug_pointer@_W@std@@YAXPB_W0I@Z proc near
.text$mn:00000370                                         ; CODE XREF: std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>>::compare(uint,uint,wchar_t const *,uint)+1Dp
.text$mn:00000370                                         ; std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>>::compare(wchar_t const *)+15p
.text$mn:00000370
.text$mn:00000370 arg_0           = dword ptr  8
.text$mn:00000370 arg_4           = dword ptr  0Ch
.text$mn:00000370 arg_8           = dword ptr  10h
.text$mn:00000370
.text$mn:00000370                 push    ebp
.text$mn:00000371                 mov     ebp, esp
.text$mn:00000373                 cmp     [ebp+arg_0], 0
.text$mn:00000377                 jnz     short loc_38E
.text$mn:00000379                 mov     eax, [ebp+arg_8]
.text$mn:0000037C                 push    eax             ; unsigned int
.text$mn:0000037D                 mov     ecx, [ebp+arg_4]
.text$mn:00000380                 push    ecx             ; wchar_t *
.text$mn:00000381                 push    offset ??_C@_1CK@EOPGIILJ@?$AAi?$AAn?$AAv?$AAa?$AAl?$AAi?$AAd?$AA?5?$AAn?$AAu?$AAl?$AAl?$AA?5?$AAp?$AAo?$AAi?$AAn?$AAt?$AAe?$AAr?$AA?$AA@ ; "invalid null pointer"
.text$mn:00000386                 call    ?_Debug_message@std@@YAXPB_W0I@Z ; std::_Debug_message(wchar_t const *,wchar_t const *,uint)
.text$mn:0000038B                 add     esp, 0Ch
.text$mn:0000038E
.text$mn:0000038E loc_38E:                                ; CODE XREF: std::_Debug_pointer<wchar_t>(wchar_t const *,wchar_t const *,uint)+7j
.text$mn:0000038E                 pop     ebp
.text$mn:0000038F                 retn
.text$mn:0000038F ??$_Debug_pointer@_W@std@@YAXPB_W0I@Z endp
.text$mn:0000038F
.text$mn:0000038F _text$mn        ends
.text$mn:0000038F
.text$mn:00000390 ; ===========================================================================
.text$mn:00000390
.text$mn:00000390 ; Segment type: Pure code
.text$mn:00000390 ; Segment permissions: Read/Execute
.text$mn:00000390 _text$mn        segment para public 'CODE' use32
.text$mn:00000390                 assume cs:_text$mn
.text$mn:00000390                 ;org 390h
.text$mn:00000390 ; COMDAT (pick any)
.text$mn:00000390                 assume es:nothing, ss:nothing, ds:_xdata$x, fs:nothing, gs:nothing
.text$mn:00000390
.text$mn:00000390 ; =============== S U B R O U T I N E =======================================
.text$mn:00000390
.text$mn:00000390 ; Attributes: bp-based frame
.text$mn:00000390
.text$mn:00000390 ; char * __cdecl std::addressof<char>(char &)
.text$mn:00000390                 public ??$addressof@D@std@@YAPADAAD@Z
.text$mn:00000390 ??$addressof@D@std@@YAPADAAD@Z proc near
.text$mn:00000390                                         ; CODE XREF: std::_String_val<std::_Simple_types<char>>::_Myptr(void)+19p
.text$mn:00000390                                         ; std::_String_val<std::_Simple_types<char>>::_Myptr(void)+19p ...
.text$mn:00000390
.text$mn:00000390 arg_0           = dword ptr  8
.text$mn:00000390
.text$mn:00000390                 push    ebp
.text$mn:00000391                 mov     ebp, esp
.text$mn:00000393                 mov     eax, [ebp+arg_0]
.text$mn:00000396                 pop     ebp
.text$mn:00000397                 retn
.text$mn:00000397 ??$addressof@D@std@@YAPADAAD@Z endp
.text$mn:00000397
.text$mn:00000397 _text$mn        ends
.text$mn:00000397
.text$mn:00000398 ; ===========================================================================
.text$mn:00000398
.text$mn:00000398 ; Segment type: Pure code
.text$mn:00000398 ; Segment permissions: Read/Execute
.text$mn:00000398 _text$mn        segment para public 'CODE' use32
.text$mn:00000398                 assume cs:_text$mn
.text$mn:00000398                 ;org 398h
.text$mn:00000398 ; COMDAT (pick any)
.text$mn:00000398                 assume es:nothing, ss:nothing, ds:_xdata$x, fs:nothing, gs:nothing
.text$mn:00000398
.text$mn:00000398 ; =============== S U B R O U T I N E =======================================
.text$mn:00000398
.text$mn:00000398 ; Attributes: bp-based frame
.text$mn:00000398
.text$mn:00000398 ; wchar_t * __cdecl std::addressof<wchar_t>(wchar_t &)
.text$mn:00000398                 public ??$addressof@_W@std@@YAPA_WAA_W@Z
.text$mn:00000398 ??$addressof@_W@std@@YAPA_WAA_W@Z proc near
.text$mn:00000398                                         ; CODE XREF: std::_String_val<std::_Simple_types<wchar_t>>::_Myptr(void)+19p
.text$mn:00000398
.text$mn:00000398 arg_0           = dword ptr  8
.text$mn:00000398
.text$mn:00000398                 push    ebp
.text$mn:00000399                 mov     ebp, esp
.text$mn:0000039B                 mov     eax, [ebp+arg_0]
.text$mn:0000039E                 pop     ebp
.text$mn:0000039F                 retn
.text$mn:0000039F ??$addressof@_W@std@@YAPA_WAA_W@Z endp
.text$mn:0000039F
.text$mn:0000039F _text$mn        ends
.text$mn:0000039F
.text$mn:000003A0 ; ===========================================================================
.text$mn:000003A0
.text$mn:000003A0 ; Segment type: Pure code
.text$mn:000003A0 ; Segment permissions: Read/Execute
.text$mn:000003A0 _text$mn        segment para public 'CODE' use32
.text$mn:000003A0                 assume cs:_text$mn
.text$mn:000003A0                 ;org 3A0h
.text$mn:000003A0 ; COMDAT (pick any)
.text$mn:000003A0                 assume es:nothing, ss:nothing, ds:_xdata$x, fs:nothing, gs:nothing
.text$mn:000003A0
.text$mn:000003A0 ; =============== S U B R O U T I N E =======================================
.text$mn:000003A0
.text$mn:000003A0 ; Attributes: bp-based frame
.text$mn:000003A0
.text$mn:000003A0 ; int __stdcall std::_Wrap_alloc<std::allocator<char>>::construct<char *,char * &>(void *, int)
.text$mn:000003A0                 public ??$construct@PADAAPAD@?$_Wrap_alloc@V?$allocator@D@std@@@std@@QAEXPAPADAAPAD@Z
.text$mn:000003A0 ??$construct@PADAAPAD@?$_Wrap_alloc@V?$allocator@D@std@@@std@@QAEXPAPADAAPAD@Z proc near
.text$mn:000003A0                                         ; CODE XREF: $LN19+4Bp
.text$mn:000003A0
.text$mn:000003A0 var_4           = dword ptr -4
.text$mn:000003A0 arg_0           = dword ptr  8
.text$mn:000003A0 arg_4           = dword ptr  0Ch
.text$mn:000003A0
.text$mn:000003A0                 push    ebp
.text$mn:000003A1                 mov     ebp, esp
.text$mn:000003A3                 push    ecx
.text$mn:000003A4                 mov     [ebp+var_4], ecx
.text$mn:000003A7                 mov     eax, [ebp+arg_4]
.text$mn:000003AA                 push    eax
.text$mn:000003AB                 call    ??$forward@AAPAD@std@@YAAAPADAAPAD@Z ; std::forward<char * &>(char * &)
.text$mn:000003B0                 add     esp, 4
.text$mn:000003B3                 push    eax             ; int
.text$mn:000003B4                 mov     ecx, [ebp+arg_0]
.text$mn:000003B7                 push    ecx             ; void *
.text$mn:000003B8                 mov     edx, [ebp+var_4]
.text$mn:000003BB                 push    edx             ; int
.text$mn:000003BC                 call    ??$construct@PADAAPAD@?$allocator_traits@V?$allocator@D@std@@@std@@SAXAAV?$allocator@D@1@PAPADAAPAD@Z ; std::allocator_traits<std::allocator<char>>::construct<char *,char * &>(std::allocator<char> &,char * *,char * &)
.text$mn:000003C1                 add     esp, 0Ch
.text$mn:000003C4                 mov     esp, ebp
.text$mn:000003C6                 pop     ebp
.text$mn:000003C7                 retn    8
.text$mn:000003C7 ??$construct@PADAAPAD@?$_Wrap_alloc@V?$allocator@D@std@@@std@@QAEXPAPADAAPAD@Z endp
.text$mn:000003C7
.text$mn:000003C7 ; ---------------------------------------------------------------------------
.text$mn:000003CA                 align 4
.text$mn:000003CA _text$mn        ends
.text$mn:000003CA
.text$mn:000003CC ; ===========================================================================
.text$mn:000003CC
.text$mn:000003CC ; Segment type: Pure code
.text$mn:000003CC ; Segment permissions: Read/Execute
.text$mn:000003CC _text$mn        segment para public 'CODE' use32
.text$mn:000003CC                 assume cs:_text$mn
.text$mn:000003CC                 ;org 3CCh
.text$mn:000003CC ; COMDAT (pick any)
.text$mn:000003CC                 assume es:nothing, ss:nothing, ds:_xdata$x, fs:nothing, gs:nothing
.text$mn:000003CC
.text$mn:000003CC ; =============== S U B R O U T I N E =======================================
.text$mn:000003CC
.text$mn:000003CC ; Attributes: bp-based frame
.text$mn:000003CC
.text$mn:000003CC ; int __stdcall std::allocator<char>::construct<char *,char * &>(void *, int)
.text$mn:000003CC                 public ??$construct@PADAAPAD@?$allocator@D@std@@QAEXPAPADAAPAD@Z
.text$mn:000003CC ??$construct@PADAAPAD@?$allocator@D@std@@QAEXPAPADAAPAD@Z proc near
.text$mn:000003CC                                         ; CODE XREF: std::allocator_traits<std::allocator<char>>::construct<char *,char * &>(std::allocator<char> &,char * *,char * &)+17p
.text$mn:000003CC
.text$mn:000003CC var_1C          = dword ptr -1Ch
.text$mn:000003CC var_18          = dword ptr -18h
.text$mn:000003CC var_14          = dword ptr -14h
.text$mn:000003CC var_10          = dword ptr -10h
.text$mn:000003CC var_C           = dword ptr -0Ch
.text$mn:000003CC var_4           = dword ptr -4
.text$mn:000003CC arg_0           = dword ptr  8
.text$mn:000003CC arg_4           = dword ptr  0Ch
.text$mn:000003CC
.text$mn:000003CC                 push    ebp
.text$mn:000003CD                 mov     ebp, esp
.text$mn:000003CF                 push    0FFFFFFFFh
.text$mn:000003D1                 push    offset __ehhandler$??$construct@PADAAPAD@?$allocator@D@std@@QAEXPAPADAAPAD@Z
.text$mn:000003D6                 mov     eax, large fs:0
.text$mn:000003DC                 push    eax
.text$mn:000003DD                 sub     esp, 10h
.text$mn:000003E0                 mov     eax, dword ptr ds:___security_cookie
.text$mn:000003E5                 xor     eax, ebp
.text$mn:000003E7                 push    eax
.text$mn:000003E8                 lea     eax, [ebp+var_C]
.text$mn:000003EB                 mov     large fs:0, eax
.text$mn:000003F1                 mov     [ebp+var_18], ecx
.text$mn:000003F4                 mov     eax, [ebp+arg_0]
.text$mn:000003F7                 push    eax             ; void *
.text$mn:000003F8                 push    4               ; unsigned int
.text$mn:000003FA                 call    ??2@YAPAXIPAX@Z ; operator new(uint,void *)
.text$mn:000003FF                 add     esp, 8
.text$mn:00000402                 mov     [ebp+var_10], eax
.text$mn:00000405                 mov     [ebp+var_4], 0
.text$mn:0000040C                 cmp     [ebp+var_10], 0
.text$mn:00000410                 jz      short loc_42D
.text$mn:00000412                 mov     ecx, [ebp+arg_4]
.text$mn:00000415                 push    ecx
.text$mn:00000416                 call    ??$forward@AAPAD@std@@YAAAPADAAPAD@Z ; std::forward<char * &>(char * &)
.text$mn:0000041B                 add     esp, 4
.text$mn:0000041E                 mov     edx, [ebp+var_10]
.text$mn:00000421                 mov     eax, [eax]
.text$mn:00000423                 mov     [edx], eax
.text$mn:00000425                 mov     ecx, [ebp+var_10]
.text$mn:00000428                 mov     [ebp+var_14], ecx
.text$mn:0000042B                 jmp     short loc_434
.text$mn:0000042D ; ---------------------------------------------------------------------------
.text$mn:0000042D
.text$mn:0000042D loc_42D:                                ; CODE XREF: std::allocator<char>::construct<char *,char * &>(char * *,char * &)+44j
.text$mn:0000042D                 mov     [ebp+var_14], 0
.text$mn:00000434
.text$mn:00000434 loc_434:                                ; CODE XREF: std::allocator<char>::construct<char *,char * &>(char * *,char * &)+5Fj
.text$mn:00000434                 mov     edx, [ebp+var_14]
.text$mn:00000437                 mov     [ebp+var_1C], edx
.text$mn:0000043A                 mov     [ebp+var_4], 0FFFFFFFFh
.text$mn:00000441                 mov     ecx, [ebp+var_C]
.text$mn:00000444                 mov     large fs:0, ecx
.text$mn:0000044B                 pop     ecx
.text$mn:0000044C                 mov     esp, ebp
.text$mn:0000044E                 pop     ebp
.text$mn:0000044F                 retn    8
.text$mn:0000044F ??$construct@PADAAPAD@?$allocator@D@std@@QAEXPAPADAAPAD@Z endp
.text$mn:0000044F
.text$mn:0000044F ; ---------------------------------------------------------------------------
.text$mn:00000452                 align 4
.text$mn:00000452 _text$mn        ends
.text$mn:00000452
.text$x:00000454 ; ===========================================================================
.text$x:00000454
.text$x:00000454 ; Segment type: Pure code
.text$x:00000454 ; Segment permissions: Read/Execute
.text$x:00000454 _text$x         segment para public 'CODE' use32
.text$x:00000454                 assume cs:_text$x
.text$x:00000454                 ;org 454h
.text$x:00000454 ; COMDAT (pick associative to section at 3CC)
.text$x:00000454                 assume es:nothing, ss:nothing, ds:_xdata$x, fs:nothing, gs:nothing
.text$x:00000454
.text$x:00000454 ; =============== S U B R O U T I N E =======================================
.text$x:00000454
.text$x:00000454
.text$x:00000454 __unwindfunclet$??$construct@PADAAPAD@?$allocator@D@std@@QAEXPAPADAAPAD@Z$0 proc near
.text$x:00000454                                         ; DATA XREF: .xdata$x:000022A8o
.text$x:00000454                 mov     eax, [ebp+8]
.text$x:00000457                 push    eax
.text$x:00000458                 mov     eax, [ebp-10h]
.text$x:0000045B                 push    eax             ; void *
.text$x:0000045C                 call    ??3@YAXPAX0@Z   ; operator delete(void *,void *)
.text$x:00000461                 add     esp, 8
.text$x:00000464                 retn
.text$x:00000464 __unwindfunclet$??$construct@PADAAPAD@?$allocator@D@std@@QAEXPAPADAAPAD@Z$0 endp
.text$x:00000464
.text$x:00000465
.text$x:00000465 ; =============== S U B R O U T I N E =======================================
.text$x:00000465
.text$x:00000465
.text$x:00000465 __ehhandler$??$construct@PADAAPAD@?$allocator@D@std@@QAEXPAPADAAPAD@Z proc near
.text$x:00000465                                         ; DATA XREF: std::allocator<char>::construct<char *,char * &>(char * *,char * &)+5o
.text$x:00000465
.text$x:00000465 arg_4           = dword ptr  8
.text$x:00000465
.text$x:00000465                 mov     edx, [esp+arg_4]
.text$x:00000469                 lea     eax, [edx+0Ch]
.text$x:0000046C                 mov     ecx, [edx-14h]
.text$x:0000046F                 xor     ecx, eax
.text$x:00000471                 call    @__security_check_cookie@4 ; __security_check_cookie(x)
.text$x:00000476                 mov     eax, offset __ehfuncinfo$??$construct@PADAAPAD@?$allocator@D@std@@QAEXPAPADAAPAD@Z
.text$x:0000047B                 jmp     ___CxxFrameHandler3
.text$x:0000047B __ehhandler$??$construct@PADAAPAD@?$allocator@D@std@@QAEXPAPADAAPAD@Z endp
.text$x:0000047B
.text$x:0000047B _text$x         ends
.text$x:0000047B
.text$mn:00000480 ; ===========================================================================
.text$mn:00000480
.text$mn:00000480 ; Segment type: Pure code
.text$mn:00000480 ; Segment permissions: Read/Execute
.text$mn:00000480 _text$mn        segment para public 'CODE' use32
.text$mn:00000480                 assume cs:_text$mn
.text$mn:00000480                 ;org 480h
.text$mn:00000480 ; COMDAT (pick any)
.text$mn:00000480                 assume es:nothing, ss:nothing, ds:_xdata$x, fs:nothing, gs:nothing
.text$mn:00000480
.text$mn:00000480 ; =============== S U B R O U T I N E =======================================
.text$mn:00000480
.text$mn:00000480 ; Attributes: bp-based frame
.text$mn:00000480
.text$mn:00000480 ; int __cdecl std::allocator_traits<std::allocator<char>>::construct<char *,char * &>(int, void *, int)
.text$mn:00000480                 public ??$construct@PADAAPAD@?$allocator_traits@V?$allocator@D@std@@@std@@SAXAAV?$allocator@D@1@PAPADAAPAD@Z
.text$mn:00000480 ??$construct@PADAAPAD@?$allocator_traits@V?$allocator@D@std@@@std@@SAXAAV?$allocator@D@1@PAPADAAPAD@Z proc near
.text$mn:00000480                                         ; CODE XREF: std::_Wrap_alloc<std::allocator<char>>::construct<char *,char * &>(char * *,char * &)+1Cp
.text$mn:00000480
.text$mn:00000480 arg_0           = dword ptr  8
.text$mn:00000480 arg_4           = dword ptr  0Ch
.text$mn:00000480 arg_8           = dword ptr  10h
.text$mn:00000480
.text$mn:00000480                 push    ebp
.text$mn:00000481                 mov     ebp, esp
.text$mn:00000483                 mov     eax, [ebp+arg_8]
.text$mn:00000486                 push    eax
.text$mn:00000487                 call    ??$forward@AAPAD@std@@YAAAPADAAPAD@Z ; std::forward<char * &>(char * &)
.text$mn:0000048C                 add     esp, 4
.text$mn:0000048F                 push    eax             ; int
.text$mn:00000490                 mov     ecx, [ebp+arg_4]
.text$mn:00000493                 push    ecx             ; void *
.text$mn:00000494                 mov     ecx, [ebp+arg_0]
.text$mn:00000497                 call    ??$construct@PADAAPAD@?$allocator@D@std@@QAEXPAPADAAPAD@Z ; std::allocator<char>::construct<char *,char * &>(char * *,char * &)
.text$mn:0000049C                 pop     ebp
.text$mn:0000049D                 retn
.text$mn:0000049D ??$construct@PADAAPAD@?$allocator_traits@V?$allocator@D@std@@@std@@SAXAAV?$allocator@D@1@PAPADAAPAD@Z endp
.text$mn:0000049D
.text$mn:0000049D ; ---------------------------------------------------------------------------
.text$mn:0000049E                 align 10h
.text$mn:0000049E _text$mn        ends
.text$mn:0000049E
.text$mn:000004A0 ; ===========================================================================
.text$mn:000004A0
.text$mn:000004A0 ; Segment type: Pure code
.text$mn:000004A0 ; Segment permissions: Read/Execute
.text$mn:000004A0 _text$mn        segment para public 'CODE' use32
.text$mn:000004A0                 assume cs:_text$mn
.text$mn:000004A0                 ;org 4A0h
.text$mn:000004A0 ; COMDAT (pick any)
.text$mn:000004A0                 assume es:nothing, ss:nothing, ds:_xdata$x, fs:nothing, gs:nothing
.text$mn:000004A0
.text$mn:000004A0 ; =============== S U B R O U T I N E =======================================
.text$mn:000004A0
.text$mn:000004A0 ; Attributes: bp-based frame
.text$mn:000004A0
.text$mn:000004A0 ; int __stdcall std::allocator<std::_Container_proxy>::construct<std::_Container_proxy,std::_Container_proxy>(void *, int)
.text$mn:000004A0                 public ??$construct@U_Container_proxy@std@@U12@@?$allocator@U_Container_proxy@std@@@std@@QAEXPAU_Container_proxy@1@$$QAU21@@Z
.text$mn:000004A0 ??$construct@U_Container_proxy@std@@U12@@?$allocator@U_Container_proxy@std@@@std@@QAEXPAU_Container_proxy@1@$$QAU21@@Z proc near
.text$mn:000004A0                                         ; CODE XREF: std::_String_alloc<0,std::_String_base_types<char,std::allocator<char>>>::_Alloc_proxy(void)+32p
.text$mn:000004A0
.text$mn:000004A0 var_1C          = dword ptr -1Ch
.text$mn:000004A0 var_18          = dword ptr -18h
.text$mn:000004A0 var_14          = dword ptr -14h
.text$mn:000004A0 var_10          = dword ptr -10h
.text$mn:000004A0 var_C           = dword ptr -0Ch
.text$mn:000004A0 var_4           = dword ptr -4
.text$mn:000004A0 arg_0           = dword ptr  8
.text$mn:000004A0 arg_4           = dword ptr  0Ch
.text$mn:000004A0
.text$mn:000004A0                 push    ebp
.text$mn:000004A1                 mov     ebp, esp
.text$mn:000004A3                 push    0FFFFFFFFh
.text$mn:000004A5                 push    offset __ehhandler$??$construct@U_Container_proxy@std@@U12@@?$allocator@U_Container_proxy@std@@@std@@QAEXPAU_Container_proxy@1@$$QAU21@@Z
.text$mn:000004AA                 mov     eax, large fs:0
.text$mn:000004B0                 push    eax
.text$mn:000004B1                 sub     esp, 10h
.text$mn:000004B4                 mov     eax, dword ptr ds:___security_cookie
.text$mn:000004B9                 xor     eax, ebp
.text$mn:000004BB                 push    eax
.text$mn:000004BC                 lea     eax, [ebp+var_C]
.text$mn:000004BF                 mov     large fs:0, eax
.text$mn:000004C5                 mov     [ebp+var_18], ecx
.text$mn:000004C8                 mov     eax, [ebp+arg_0]
.text$mn:000004CB                 push    eax             ; void *
.text$mn:000004CC                 push    8               ; unsigned int
.text$mn:000004CE                 call    ??2@YAPAXIPAX@Z ; operator new(uint,void *)
.text$mn:000004D3                 add     esp, 8
.text$mn:000004D6                 mov     [ebp+var_10], eax
.text$mn:000004D9                 mov     [ebp+var_4], 0
.text$mn:000004E0                 cmp     [ebp+var_10], 0
.text$mn:000004E4                 jz      short loc_507
.text$mn:000004E6                 mov     ecx, [ebp+arg_4]
.text$mn:000004E9                 push    ecx
.text$mn:000004EA                 call    ??$forward@U_Container_proxy@std@@@std@@YA$$QAU_Container_proxy@0@AAU10@@Z ; std::forward<std::_Container_proxy>(std::_Container_proxy &)
.text$mn:000004EF                 add     esp, 4
.text$mn:000004F2                 mov     edx, [eax]
.text$mn:000004F4                 mov     eax, [eax+4]
.text$mn:000004F7                 mov     ecx, [ebp+var_10]
.text$mn:000004FA                 mov     [ecx], edx
.text$mn:000004FC                 mov     [ecx+4], eax
.text$mn:000004FF                 mov     edx, [ebp+var_10]
.text$mn:00000502                 mov     [ebp+var_14], edx
.text$mn:00000505                 jmp     short loc_50E
.text$mn:00000507 ; ---------------------------------------------------------------------------
.text$mn:00000507
.text$mn:00000507 loc_507:                                ; CODE XREF: std::allocator<std::_Container_proxy>::construct<std::_Container_proxy,std::_Container_proxy>(std::_Container_proxy *,std::_Container_proxy &&)+44j
.text$mn:00000507                 mov     [ebp+var_14], 0
.text$mn:0000050E
.text$mn:0000050E loc_50E:                                ; CODE XREF: std::allocator<std::_Container_proxy>::construct<std::_Container_proxy,std::_Container_proxy>(std::_Container_proxy *,std::_Container_proxy &&)+65j
.text$mn:0000050E                 mov     eax, [ebp+var_14]
.text$mn:00000511                 mov     [ebp+var_1C], eax
.text$mn:00000514                 mov     [ebp+var_4], 0FFFFFFFFh
.text$mn:0000051B                 mov     ecx, [ebp+var_C]
.text$mn:0000051E                 mov     large fs:0, ecx
.text$mn:00000525                 pop     ecx
.text$mn:00000526                 mov     esp, ebp
.text$mn:00000528                 pop     ebp
.text$mn:00000529                 retn    8
.text$mn:00000529 ??$construct@U_Container_proxy@std@@U12@@?$allocator@U_Container_proxy@std@@@std@@QAEXPAU_Container_proxy@1@$$QAU21@@Z endp
.text$mn:00000529
.text$mn:00000529 _text$mn        ends
.text$mn:00000529
.text$x:0000052C ; ===========================================================================
.text$x:0000052C
.text$x:0000052C ; Segment type: Pure code
.text$x:0000052C ; Segment permissions: Read/Execute
.text$x:0000052C _text$x         segment para public 'CODE' use32
.text$x:0000052C                 assume cs:_text$x
.text$x:0000052C                 ;org 52Ch
.text$x:0000052C ; COMDAT (pick associative to section at 4A0)
.text$x:0000052C                 assume es:nothing, ss:nothing, ds:_xdata$x, fs:nothing, gs:nothing
.text$x:0000052C
.text$x:0000052C ; =============== S U B R O U T I N E =======================================
.text$x:0000052C
.text$x:0000052C
.text$x:0000052C __unwindfunclet$??$construct@U_Container_proxy@std@@U12@@?$allocator@U_Container_proxy@std@@@std@@QAEXPAU_Container_proxy@1@$$QAU21@@Z$0 proc near
.text$x:0000052C                                         ; DATA XREF: .xdata$x:0000227Co
.text$x:0000052C                 mov     eax, [ebp+8]
.text$x:0000052F                 push    eax
.text$x:00000530                 mov     eax, [ebp-10h]
.text$x:00000533                 push    eax             ; void *
.text$x:00000534                 call    ??3@YAXPAX0@Z   ; operator delete(void *,void *)
.text$x:00000539                 add     esp, 8
.text$x:0000053C                 retn
.text$x:0000053C __unwindfunclet$??$construct@U_Container_proxy@std@@U12@@?$allocator@U_Container_proxy@std@@@std@@QAEXPAU_Container_proxy@1@$$QAU21@@Z$0 endp
.text$x:0000053C
.text$x:0000053D
.text$x:0000053D ; =============== S U B R O U T I N E =======================================
.text$x:0000053D
.text$x:0000053D
.text$x:0000053D __ehhandler$??$construct@U_Container_proxy@std@@U12@@?$allocator@U_Container_proxy@std@@@std@@QAEXPAU_Container_proxy@1@$$QAU21@@Z proc near
.text$x:0000053D                                         ; DATA XREF: std::allocator<std::_Container_proxy>::construct<std::_Container_proxy,std::_Container_proxy>(std::_Container_proxy *,std::_Container_proxy &&)+5o
.text$x:0000053D
.text$x:0000053D arg_4           = dword ptr  8
.text$x:0000053D
.text$x:0000053D                 mov     edx, [esp+arg_4]
.text$x:00000541                 lea     eax, [edx+0Ch]
.text$x:00000544                 mov     ecx, [edx-14h]
.text$x:00000547                 xor     ecx, eax
.text$x:00000549                 call    @__security_check_cookie@4 ; __security_check_cookie(x)
.text$x:0000054E                 mov     eax, offset __ehfuncinfo$??$construct@U_Container_proxy@std@@U12@@?$allocator@U_Container_proxy@std@@@std@@QAEXPAU_Container_proxy@1@$$QAU21@@Z
.text$x:00000553                 jmp     ___CxxFrameHandler3
.text$x:00000553 __ehhandler$??$construct@U_Container_proxy@std@@U12@@?$allocator@U_Container_proxy@std@@@std@@QAEXPAU_Container_proxy@1@$$QAU21@@Z endp
.text$x:00000553
.text$x:00000553 _text$x         ends
.text$x:00000553
.text$mn:00000558 ; ===========================================================================
.text$mn:00000558
.text$mn:00000558 ; Segment type: Pure code
.text$mn:00000558 ; Segment permissions: Read/Execute
.text$mn:00000558 _text$mn        segment para public 'CODE' use32
.text$mn:00000558                 assume cs:_text$mn
.text$mn:00000558                 ;org 558h
.text$mn:00000558 ; COMDAT (pick any)
.text$mn:00000558                 assume es:nothing, ss:nothing, ds:_xdata$x, fs:nothing, gs:nothing
.text$mn:00000558
.text$mn:00000558 ; =============== S U B R O U T I N E =======================================
.text$mn:00000558
.text$mn:00000558 ; Attributes: bp-based frame
.text$mn:00000558
.text$mn:00000558 ; public: void __thiscall std::_Wrap_alloc<class std::allocator<char>>::destroy<char *>(char * *)
.text$mn:00000558                 public ??$destroy@PAD@?$_Wrap_alloc@V?$allocator@D@std@@@std@@QAEXPAPAD@Z
.text$mn:00000558 ??$destroy@PAD@?$_Wrap_alloc@V?$allocator@D@std@@@std@@QAEXPAPAD@Z proc near
.text$mn:00000558                                         ; CODE XREF: std::basic_string<char,std::char_traits<char>,std::allocator<char>>::_Tidy(bool,uint)+3Ap
.text$mn:00000558
.text$mn:00000558 var_4           = dword ptr -4
.text$mn:00000558 arg_0           = dword ptr  8
.text$mn:00000558
.text$mn:00000558                 push    ebp
.text$mn:00000559                 mov     ebp, esp
.text$mn:0000055B                 push    ecx
.text$mn:0000055C                 mov     [ebp+var_4], ecx
.text$mn:0000055F                 mov     eax, [ebp+arg_0]
.text$mn:00000562                 push    eax
.text$mn:00000563                 mov     ecx, [ebp+var_4]
.text$mn:00000566                 push    ecx
.text$mn:00000567                 call    ??$destroy@PAD@?$allocator_traits@V?$allocator@D@std@@@std@@SAXAAV?$allocator@D@1@PAPAD@Z ; std::allocator_traits<std::allocator<char>>::destroy<char *>(std::allocator<char> &,char * *)
.text$mn:0000056C                 add     esp, 8
.text$mn:0000056F                 mov     esp, ebp
.text$mn:00000571                 pop     ebp
.text$mn:00000572                 retn    4
.text$mn:00000572 ??$destroy@PAD@?$_Wrap_alloc@V?$allocator@D@std@@@std@@QAEXPAPAD@Z endp
.text$mn:00000572
.text$mn:00000572 ; ---------------------------------------------------------------------------
.text$mn:00000575                 align 4
.text$mn:00000575 _text$mn        ends
.text$mn:00000575
.text$mn:00000578 ; ===========================================================================
.text$mn:00000578
.text$mn:00000578 ; Segment type: Pure code
.text$mn:00000578 ; Segment permissions: Read/Execute
.text$mn:00000578 _text$mn        segment para public 'CODE' use32
.text$mn:00000578                 assume cs:_text$mn
.text$mn:00000578                 ;org 578h
.text$mn:00000578 ; COMDAT (pick any)
.text$mn:00000578                 assume es:nothing, ss:nothing, ds:_xdata$x, fs:nothing, gs:nothing
.text$mn:00000578
.text$mn:00000578 ; =============== S U B R O U T I N E =======================================
.text$mn:00000578
.text$mn:00000578 ; Attributes: bp-based frame
.text$mn:00000578
.text$mn:00000578 ; public: void __thiscall std::allocator<char>::destroy<char *>(char * *)
.text$mn:00000578                 public ??$destroy@PAD@?$allocator@D@std@@QAEXPAPAD@Z
.text$mn:00000578 ??$destroy@PAD@?$allocator@D@std@@QAEXPAPAD@Z proc near
.text$mn:00000578                                         ; CODE XREF: std::allocator_traits<std::allocator<char>>::destroy<char *>(std::allocator<char> &,char * *)+Ap
.text$mn:00000578
.text$mn:00000578 var_4           = dword ptr -4
.text$mn:00000578
.text$mn:00000578                 push    ebp
.text$mn:00000579                 mov     ebp, esp
.text$mn:0000057B                 push    ecx
.text$mn:0000057C                 mov     [ebp+var_4], ecx
.text$mn:0000057F                 mov     esp, ebp
.text$mn:00000581                 pop     ebp
.text$mn:00000582                 retn    4
.text$mn:00000582 ??$destroy@PAD@?$allocator@D@std@@QAEXPAPAD@Z endp
.text$mn:00000582
.text$mn:00000582 ; ---------------------------------------------------------------------------
.text$mn:00000585                 align 4
.text$mn:00000585 _text$mn        ends
.text$mn:00000585
.text$mn:00000588 ; ===========================================================================
.text$mn:00000588
.text$mn:00000588 ; Segment type: Pure code
.text$mn:00000588 ; Segment permissions: Read/Execute
.text$mn:00000588 _text$mn        segment para public 'CODE' use32
.text$mn:00000588                 assume cs:_text$mn
.text$mn:00000588                 ;org 588h
.text$mn:00000588 ; COMDAT (pick any)
.text$mn:00000588                 assume es:nothing, ss:nothing, ds:_xdata$x, fs:nothing, gs:nothing
.text$mn:00000588
.text$mn:00000588 ; =============== S U B R O U T I N E =======================================
.text$mn:00000588
.text$mn:00000588 ; Attributes: bp-based frame
.text$mn:00000588
.text$mn:00000588 ; public: static void __cdecl std::allocator_traits<class std::allocator<char>>::destroy<char *>(class std::allocator<char> &, char * *)
.text$mn:00000588                 public ??$destroy@PAD@?$allocator_traits@V?$allocator@D@std@@@std@@SAXAAV?$allocator@D@1@PAPAD@Z
.text$mn:00000588 ??$destroy@PAD@?$allocator_traits@V?$allocator@D@std@@@std@@SAXAAV?$allocator@D@1@PAPAD@Z proc near
.text$mn:00000588                                         ; CODE XREF: std::_Wrap_alloc<std::allocator<char>>::destroy<char *>(char * *)+Fp
.text$mn:00000588
.text$mn:00000588 arg_0           = dword ptr  8
.text$mn:00000588 arg_4           = dword ptr  0Ch
.text$mn:00000588
.text$mn:00000588                 push    ebp
.text$mn:00000589                 mov     ebp, esp
.text$mn:0000058B                 mov     eax, [ebp+arg_4]
.text$mn:0000058E                 push    eax
.text$mn:0000058F                 mov     ecx, [ebp+arg_0]
.text$mn:00000592                 call    ??$destroy@PAD@?$allocator@D@std@@QAEXPAPAD@Z ; std::allocator<char>::destroy<char *>(char * *)
.text$mn:00000597                 pop     ebp
.text$mn:00000598                 retn
.text$mn:00000598 ??$destroy@PAD@?$allocator_traits@V?$allocator@D@std@@@std@@SAXAAV?$allocator@D@1@PAPAD@Z endp
.text$mn:00000598
.text$mn:00000598 ; ---------------------------------------------------------------------------
.text$mn:00000599                 align 4
.text$mn:00000599 _text$mn        ends
.text$mn:00000599
.text$mn:0000059C ; ===========================================================================
.text$mn:0000059C
.text$mn:0000059C ; Segment type: Pure code
.text$mn:0000059C ; Segment permissions: Read/Execute
.text$mn:0000059C _text$mn        segment para public 'CODE' use32
.text$mn:0000059C                 assume cs:_text$mn
.text$mn:0000059C                 ;org 59Ch
.text$mn:0000059C ; COMDAT (pick any)
.text$mn:0000059C                 assume es:nothing, ss:nothing, ds:_xdata$x, fs:nothing, gs:nothing
.text$mn:0000059C
.text$mn:0000059C ; =============== S U B R O U T I N E =======================================
.text$mn:0000059C
.text$mn:0000059C ; Attributes: bp-based frame
.text$mn:0000059C
.text$mn:0000059C ; public: void __thiscall std::allocator<struct std::_Container_proxy>::destroy<struct std::_Container_proxy>(struct std::_Container_proxy *)
.text$mn:0000059C                 public ??$destroy@U_Container_proxy@std@@@?$allocator@U_Container_proxy@std@@@std@@QAEXPAU_Container_proxy@1@@Z
.text$mn:0000059C ??$destroy@U_Container_proxy@std@@@?$allocator@U_Container_proxy@std@@@std@@QAEXPAU_Container_proxy@1@@Z proc near
.text$mn:0000059C                                         ; CODE XREF: std::_String_alloc<0,std::_String_base_types<char,std::allocator<char>>>::_Free_proxy(void)+22p
.text$mn:0000059C
.text$mn:0000059C var_4           = dword ptr -4
.text$mn:0000059C
.text$mn:0000059C                 push    ebp
.text$mn:0000059D                 mov     ebp, esp
.text$mn:0000059F                 push    ecx
.text$mn:000005A0                 mov     [ebp+var_4], ecx
.text$mn:000005A3                 mov     esp, ebp
.text$mn:000005A5                 pop     ebp
.text$mn:000005A6                 retn    4
.text$mn:000005A6 ??$destroy@U_Container_proxy@std@@@?$allocator@U_Container_proxy@std@@@std@@QAEXPAU_Container_proxy@1@@Z endp
.text$mn:000005A6
.text$mn:000005A6 ; ---------------------------------------------------------------------------
.text$mn:000005A9                 align 4
.text$mn:000005A9 _text$mn        ends
.text$mn:000005A9
.text$mn:000005AC ; ===========================================================================
.text$mn:000005AC
.text$mn:000005AC ; Segment type: Pure code
.text$mn:000005AC ; Segment permissions: Read/Execute
.text$mn:000005AC _text$mn        segment para public 'CODE' use32
.text$mn:000005AC                 assume cs:_text$mn
.text$mn:000005AC                 ;org 5ACh
.text$mn:000005AC ; COMDAT (pick any)
.text$mn:000005AC                 assume es:nothing, ss:nothing, ds:_xdata$x, fs:nothing, gs:nothing
.text$mn:000005AC
.text$mn:000005AC ; =============== S U B R O U T I N E =======================================
.text$mn:000005AC
.text$mn:000005AC ; Attributes: bp-based frame
.text$mn:000005AC
.text$mn:000005AC ; char * & __cdecl std::forward<char * &>(char * &)
.text$mn:000005AC                 public ??$forward@AAPAD@std@@YAAAPADAAPAD@Z
.text$mn:000005AC ??$forward@AAPAD@std@@YAAAPADAAPAD@Z proc near
.text$mn:000005AC                                         ; CODE XREF: std::_Wrap_alloc<std::allocator<char>>::construct<char *,char * &>(char * *,char * &)+Bp
.text$mn:000005AC                                         ; std::allocator<char>::construct<char *,char * &>(char * *,char * &)+4Ap ...
.text$mn:000005AC
.text$mn:000005AC arg_0           = dword ptr  8
.text$mn:000005AC
.text$mn:000005AC                 push    ebp
.text$mn:000005AD                 mov     ebp, esp
.text$mn:000005AF                 mov     eax, [ebp+arg_0]
.text$mn:000005B2                 pop     ebp
.text$mn:000005B3                 retn
.text$mn:000005B3 ??$forward@AAPAD@std@@YAAAPADAAPAD@Z endp
.text$mn:000005B3
.text$mn:000005B3 _text$mn        ends
.text$mn:000005B3
.text$mn:000005B4 ; ===========================================================================
.text$mn:000005B4
.text$mn:000005B4 ; Segment type: Pure code
.text$mn:000005B4 ; Segment permissions: Read/Execute
.text$mn:000005B4 _text$mn        segment para public 'CODE' use32
.text$mn:000005B4                 assume cs:_text$mn
.text$mn:000005B4                 ;org 5B4h
.text$mn:000005B4 ; COMDAT (pick any)
.text$mn:000005B4                 assume es:nothing, ss:nothing, ds:_xdata$x, fs:nothing, gs:nothing
.text$mn:000005B4
.text$mn:000005B4 ; =============== S U B R O U T I N E =======================================
.text$mn:000005B4
.text$mn:000005B4 ; Attributes: bp-based frame
.text$mn:000005B4
.text$mn:000005B4 ; struct std::_Container_proxy && __cdecl std::forward<struct std::_Container_proxy>(struct std::_Container_proxy &)
.text$mn:000005B4                 public ??$forward@U_Container_proxy@std@@@std@@YA$$QAU_Container_proxy@0@AAU10@@Z
.text$mn:000005B4 ??$forward@U_Container_proxy@std@@@std@@YA$$QAU_Container_proxy@0@AAU10@@Z proc near
.text$mn:000005B4                                         ; CODE XREF: std::allocator<std::_Container_proxy>::construct<std::_Container_proxy,std::_Container_proxy>(std::_Container_proxy *,std::_Container_proxy &&)+4Ap
.text$mn:000005B4
.text$mn:000005B4 arg_0           = dword ptr  8
.text$mn:000005B4
.text$mn:000005B4                 push    ebp
.text$mn:000005B5                 mov     ebp, esp
.text$mn:000005B7                 mov     eax, [ebp+arg_0]
.text$mn:000005BA                 pop     ebp
.text$mn:000005BB                 retn
.text$mn:000005BB ??$forward@U_Container_proxy@std@@@std@@YA$$QAU_Container_proxy@0@AAU10@@Z endp
.text$mn:000005BB
.text$mn:000005BB _text$mn        ends
.text$mn:000005BB
.text$mn:000005BC ; ===========================================================================
.text$mn:000005BC
.text$mn:000005BC ; Segment type: Pure code
.text$mn:000005BC ; Segment permissions: Read/Execute
.text$mn:000005BC _text$mn        segment para public 'CODE' use32
.text$mn:000005BC                 assume cs:_text$mn
.text$mn:000005BC                 ;org 5BCh
.text$mn:000005BC ; COMDAT (pick any)
.text$mn:000005BC                 assume es:nothing, ss:nothing, ds:_xdata$x, fs:nothing, gs:nothing
.text$mn:000005BC
.text$mn:000005BC ; =============== S U B R O U T I N E =======================================
.text$mn:000005BC
.text$mn:000005BC ; Attributes: bp-based frame
.text$mn:000005BC
.text$mn:000005BC ; public: __thiscall std::_String_alloc<0, struct std::_String_base_types<char, class std::allocator<char>>>::_String_alloc<0, struct std::_String_base_types<char, class std::allocator<char>>>(class std::allocator<char> const &)
.text$mn:000005BC                 public ??0?$_String_alloc@$0A@U?$_String_base_types@DV?$allocator@D@std@@@std@@@std@@QAE@ABV?$allocator@D@1@@Z
.text$mn:000005BC ??0?$_String_alloc@$0A@U?$_String_base_types@DV?$allocator@D@std@@@std@@@std@@QAE@ABV?$allocator@D@1@@Z proc near
.text$mn:000005BC                                         ; CODE XREF: std::basic_string<char,std::char_traits<char>,std::allocator<char>>::basic_string<char,std::char_traits<char>,std::allocator<char>>(char const *)+34p
.text$mn:000005BC
.text$mn:000005BC var_10          = dword ptr -10h
.text$mn:000005BC var_C           = dword ptr -0Ch
.text$mn:000005BC var_4           = dword ptr -4
.text$mn:000005BC
.text$mn:000005BC                 push    ebp
.text$mn:000005BD                 mov     ebp, esp
.text$mn:000005BF                 push    0FFFFFFFFh
.text$mn:000005C1                 push    offset __ehhandler$??0?$_String_alloc@$0A@U?$_String_base_types@DV?$allocator@D@std@@@std@@@std@@QAE@ABV?$allocator@D@1@@Z
.text$mn:000005C6                 mov     eax, large fs:0
.text$mn:000005CC                 push    eax
.text$mn:000005CD                 push    ecx
.text$mn:000005CE                 mov     eax, dword ptr ds:___security_cookie
.text$mn:000005D3                 xor     eax, ebp
.text$mn:000005D5                 push    eax
.text$mn:000005D6                 lea     eax, [ebp+var_C]
.text$mn:000005D9                 mov     large fs:0, eax
.text$mn:000005DF                 mov     [ebp+var_10], ecx
.text$mn:000005E2                 mov     ecx, [ebp+var_10]
.text$mn:000005E5                 call    ??0?$_String_val@U?$_Simple_types@D@std@@@std@@QAE@XZ ; std::_String_val<std::_Simple_types<char>>::_String_val<std::_Simple_types<char>>(void)
.text$mn:000005EA                 mov     [ebp+var_4], 0
.text$mn:000005F1                 mov     ecx, [ebp+var_10]
.text$mn:000005F4                 call    ?_Alloc_proxy@?$_String_alloc@$0A@U?$_String_base_types@DV?$allocator@D@std@@@std@@@std@@QAEXXZ ; std::_String_alloc<0,std::_String_base_types<char,std::allocator<char>>>::_Alloc_proxy(void)
.text$mn:000005F9                 mov     [ebp+var_4], 0FFFFFFFFh
.text$mn:00000600                 mov     eax, [ebp+var_10]
.text$mn:00000603                 mov     ecx, [ebp+var_C]
.text$mn:00000606                 mov     large fs:0, ecx
.text$mn:0000060D                 pop     ecx
.text$mn:0000060E                 mov     esp, ebp
.text$mn:00000610                 pop     ebp
.text$mn:00000611                 retn    4
.text$mn:00000611 ??0?$_String_alloc@$0A@U?$_String_base_types@DV?$allocator@D@std@@@std@@@std@@QAE@ABV?$allocator@D@1@@Z endp
.text$mn:00000611
.text$mn:00000611 _text$mn        ends
.text$mn:00000611
.text$x:00000614 ; ===========================================================================
.text$x:00000614
.text$x:00000614 ; Segment type: Pure code
.text$x:00000614 ; Segment permissions: Read/Execute
.text$x:00000614 _text$x         segment para public 'CODE' use32
.text$x:00000614                 assume cs:_text$x
.text$x:00000614                 ;org 614h
.text$x:00000614 ; COMDAT (pick associative to section at 5BC)
.text$x:00000614                 assume es:nothing, ss:nothing, ds:_xdata$x, fs:nothing, gs:nothing
.text$x:00000614
.text$x:00000614 ; =============== S U B R O U T I N E =======================================
.text$x:00000614
.text$x:00000614
.text$x:00000614 __unwindfunclet$??0?$_String_alloc@$0A@U?$_String_base_types@DV?$allocator@D@std@@@std@@@std@@QAE@ABV?$allocator@D@1@@Z$0 proc near
.text$x:00000614                                         ; DATA XREF: .xdata$x:00001FB4o
.text$x:00000614                 mov     ecx, [ebp-10h]
.text$x:00000617                 jmp     ??1?$_String_val@U?$_Simple_types@D@std@@@std@@QAE@XZ ; std::_String_val<std::_Simple_types<char>>::~_String_val<std::_Simple_types<char>>(void)
.text$x:00000617 __unwindfunclet$??0?$_String_alloc@$0A@U?$_String_base_types@DV?$allocator@D@std@@@std@@@std@@QAE@ABV?$allocator@D@1@@Z$0 endp
.text$x:00000617
.text$x:0000061C
.text$x:0000061C ; =============== S U B R O U T I N E =======================================
.text$x:0000061C
.text$x:0000061C
.text$x:0000061C __ehhandler$??0?$_String_alloc@$0A@U?$_String_base_types@DV?$allocator@D@std@@@std@@@std@@QAE@ABV?$allocator@D@1@@Z proc near
.text$x:0000061C                                         ; DATA XREF: std::_String_alloc<0,std::_String_base_types<char,std::allocator<char>>>::_String_alloc<0,std::_String_base_types<char,std::allocator<char>>>(std::allocator<char> const &)+5o
.text$x:0000061C
.text$x:0000061C arg_4           = dword ptr  8
.text$x:0000061C
.text$x:0000061C                 mov     edx, [esp+arg_4]
.text$x:00000620                 lea     eax, [edx+0Ch]
.text$x:00000623                 mov     ecx, [edx-8]
.text$x:00000626                 xor     ecx, eax
.text$x:00000628                 call    @__security_check_cookie@4 ; __security_check_cookie(x)
.text$x:0000062D                 mov     eax, offset __ehfuncinfo$??0?$_String_alloc@$0A@U?$_String_base_types@DV?$allocator@D@std@@@std@@@std@@QAE@ABV?$allocator@D@1@@Z
.text$x:00000632                 jmp     ___CxxFrameHandler3
.text$x:00000632 __ehhandler$??0?$_String_alloc@$0A@U?$_String_base_types@DV?$allocator@D@std@@@std@@@std@@QAE@ABV?$allocator@D@1@@Z endp
.text$x:00000632
.text$x:00000632 ; ---------------------------------------------------------------------------
.text$x:00000637                 align 4
.text$x:00000637 _text$x         ends
.text$x:00000637
.text$mn:00000638 ; ===========================================================================
.text$mn:00000638
.text$mn:00000638 ; Segment type: Pure code
.text$mn:00000638 ; Segment permissions: Read/Execute
.text$mn:00000638 _text$mn        segment para public 'CODE' use32
.text$mn:00000638                 assume cs:_text$mn
.text$mn:00000638                 ;org 638h
.text$mn:00000638 ; COMDAT (pick any)
.text$mn:00000638                 assume es:nothing, ss:nothing, ds:_xdata$x, fs:nothing, gs:nothing
.text$mn:00000638
.text$mn:00000638 ; =============== S U B R O U T I N E =======================================
.text$mn:00000638
.text$mn:00000638 ; Attributes: bp-based frame
.text$mn:00000638
.text$mn:00000638 ; public: __thiscall std::_String_val<struct std::_Simple_types<char>>::_String_val<struct std::_Simple_types<char>>(void)
.text$mn:00000638                 public ??0?$_String_val@U?$_Simple_types@D@std@@@std@@QAE@XZ
.text$mn:00000638 ??0?$_String_val@U?$_Simple_types@D@std@@@std@@QAE@XZ proc near
.text$mn:00000638                                         ; CODE XREF: std::_String_alloc<0,std::_String_base_types<char,std::allocator<char>>>::_String_alloc<0,std::_String_base_types<char,std::allocator<char>>>(std::allocator<char> const &)+29p
.text$mn:00000638
.text$mn:00000638 var_10          = dword ptr -10h
.text$mn:00000638 var_C           = dword ptr -0Ch
.text$mn:00000638 var_4           = dword ptr -4
.text$mn:00000638
.text$mn:00000638                 push    ebp
.text$mn:00000639                 mov     ebp, esp
.text$mn:0000063B                 push    0FFFFFFFFh
.text$mn:0000063D                 push    offset __ehhandler$??0?$_String_val@U?$_Simple_types@D@std@@@std@@QAE@XZ
.text$mn:00000642                 mov     eax, large fs:0
.text$mn:00000648                 push    eax
.text$mn:00000649                 push    ecx
.text$mn:0000064A                 mov     eax, dword ptr ds:___security_cookie
.text$mn:0000064F                 xor     eax, ebp
.text$mn:00000651                 push    eax
.text$mn:00000652                 lea     eax, [ebp+var_C]
.text$mn:00000655                 mov     large fs:0, eax
.text$mn:0000065B                 mov     [ebp+var_10], ecx
.text$mn:0000065E                 mov     ecx, [ebp+var_10] ; this
.text$mn:00000661                 call    ??0_Container_base12@std@@QAE@XZ ; std::_Container_base12::_Container_base12(void)
.text$mn:00000666                 mov     [ebp+var_4], 0
.text$mn:0000066D                 mov     eax, [ebp+var_10]
.text$mn:00000670                 mov     dword ptr [eax+14h], 0
.text$mn:00000677                 mov     ecx, [ebp+var_10]
.text$mn:0000067A                 mov     dword ptr [ecx+18h], 0
.text$mn:00000681                 mov     [ebp+var_4], 0FFFFFFFFh
.text$mn:00000688                 mov     eax, [ebp+var_10]
.text$mn:0000068B                 mov     ecx, [ebp+var_C]
.text$mn:0000068E                 mov     large fs:0, ecx
.text$mn:00000695                 pop     ecx
.text$mn:00000696                 mov     esp, ebp
.text$mn:00000698                 pop     ebp
.text$mn:00000699                 retn
.text$mn:00000699 ??0?$_String_val@U?$_Simple_types@D@std@@@std@@QAE@XZ endp
.text$mn:00000699
.text$mn:00000699 ; ---------------------------------------------------------------------------
.text$mn:0000069A                 align 4
.text$mn:0000069A _text$mn        ends
.text$mn:0000069A
.text$x:0000069C ; ===========================================================================
.text$x:0000069C
.text$x:0000069C ; Segment type: Pure code
.text$x:0000069C ; Segment permissions: Read/Execute
.text$x:0000069C _text$x         segment para public 'CODE' use32
.text$x:0000069C                 assume cs:_text$x
.text$x:0000069C                 ;org 69Ch
.text$x:0000069C ; COMDAT (pick associative to section at 638)
.text$x:0000069C                 assume es:nothing, ss:nothing, ds:_xdata$x, fs:nothing, gs:nothing
.text$x:0000069C
.text$x:0000069C ; =============== S U B R O U T I N E =======================================
.text$x:0000069C
.text$x:0000069C
.text$x:0000069C __unwindfunclet$??0?$_String_val@U?$_Simple_types@D@std@@@std@@QAE@XZ$0 proc near
.text$x:0000069C                                         ; DATA XREF: .xdata$x:00001F5Co
.text$x:0000069C                 mov     ecx, [ebp-10h]  ; this
.text$x:0000069F                 jmp     ??1_Container_base12@std@@QAE@XZ ; std::_Container_base12::~_Container_base12(void)
.text$x:0000069F __unwindfunclet$??0?$_String_val@U?$_Simple_types@D@std@@@std@@QAE@XZ$0 endp
.text$x:0000069F
.text$x:000006A4
.text$x:000006A4 ; =============== S U B R O U T I N E =======================================
.text$x:000006A4
.text$x:000006A4
.text$x:000006A4 __ehhandler$??0?$_String_val@U?$_Simple_types@D@std@@@std@@QAE@XZ proc near
.text$x:000006A4                                         ; DATA XREF: std::_String_val<std::_Simple_types<char>>::_String_val<std::_Simple_types<char>>(void)+5o
.text$x:000006A4
.text$x:000006A4 arg_4           = dword ptr  8
.text$x:000006A4
.text$x:000006A4                 mov     edx, [esp+arg_4]
.text$x:000006A8                 lea     eax, [edx+0Ch]
.text$x:000006AB                 mov     ecx, [edx-8]
.text$x:000006AE                 xor     ecx, eax
.text$x:000006B0                 call    @__security_check_cookie@4 ; __security_check_cookie(x)
.text$x:000006B5                 mov     eax, offset __ehfuncinfo$??0?$_String_val@U?$_Simple_types@D@std@@@std@@QAE@XZ
.text$x:000006BA                 jmp     ___CxxFrameHandler3
.text$x:000006BA __ehhandler$??0?$_String_val@U?$_Simple_types@D@std@@@std@@QAE@XZ endp
.text$x:000006BA
.text$x:000006BA ; ---------------------------------------------------------------------------
.text$x:000006BF                 align 10h
.text$x:000006BF _text$x         ends
.text$x:000006BF
.text$mn:000006C0 ; ===========================================================================
.text$mn:000006C0
.text$mn:000006C0 ; Segment type: Pure code
.text$mn:000006C0 ; Segment permissions: Read/Execute
.text$mn:000006C0 _text$mn        segment para public 'CODE' use32
.text$mn:000006C0                 assume cs:_text$mn
.text$mn:000006C0                 ;org 6C0h
.text$mn:000006C0 ; COMDAT (pick any)
.text$mn:000006C0                 assume es:nothing, ss:nothing, ds:_xdata$x, fs:nothing, gs:nothing
.text$mn:000006C0
.text$mn:000006C0 ; =============== S U B R O U T I N E =======================================
.text$mn:000006C0
.text$mn:000006C0 ; Attributes: bp-based frame
.text$mn:000006C0
.text$mn:000006C0 ; public: __thiscall std::_Wrap_alloc<class std::allocator<char>>::_Wrap_alloc<class std::allocator<char>>(void)
.text$mn:000006C0                 public ??0?$_Wrap_alloc@V?$allocator@D@std@@@std@@QAE@XZ
.text$mn:000006C0 ??0?$_Wrap_alloc@V?$allocator@D@std@@@std@@QAE@XZ proc near
.text$mn:000006C0                                         ; CODE XREF: std::_String_alloc<0,std::_String_base_types<char,std::allocator<char>>>::_Getal(void)+Ap
.text$mn:000006C0
.text$mn:000006C0 var_4           = dword ptr -4
.text$mn:000006C0
.text$mn:000006C0                 push    ebp
.text$mn:000006C1                 mov     ebp, esp
.text$mn:000006C3                 push    ecx
.text$mn:000006C4                 mov     [ebp+var_4], ecx
.text$mn:000006C7                 mov     ecx, [ebp+var_4]
.text$mn:000006CA                 call    ??0?$allocator@D@std@@QAE@XZ ; std::allocator<char>::allocator<char>(void)
.text$mn:000006CF                 mov     eax, [ebp+var_4]
.text$mn:000006D2                 mov     esp, ebp
.text$mn:000006D4                 pop     ebp
.text$mn:000006D5                 retn
.text$mn:000006D5 ??0?$_Wrap_alloc@V?$allocator@D@std@@@std@@QAE@XZ endp
.text$mn:000006D5
.text$mn:000006D5 ; ---------------------------------------------------------------------------
.text$mn:000006D6                 align 4
.text$mn:000006D6 _text$mn        ends
.text$mn:000006D6
.text$mn:000006D8 ; ===========================================================================
.text$mn:000006D8
.text$mn:000006D8 ; Segment type: Pure code
.text$mn:000006D8 ; Segment permissions: Read/Execute
.text$mn:000006D8 _text$mn        segment para public 'CODE' use32
.text$mn:000006D8                 assume cs:_text$mn
.text$mn:000006D8                 ;org 6D8h
.text$mn:000006D8 ; COMDAT (pick any)
.text$mn:000006D8                 assume es:nothing, ss:nothing, ds:_xdata$x, fs:nothing, gs:nothing
.text$mn:000006D8
.text$mn:000006D8 ; =============== S U B R O U T I N E =======================================
.text$mn:000006D8
.text$mn:000006D8 ; Attributes: bp-based frame
.text$mn:000006D8
.text$mn:000006D8 ; public: __thiscall std::allocator<char>::allocator<char>(void)
.text$mn:000006D8                 public ??0?$allocator@D@std@@QAE@XZ
.text$mn:000006D8 ??0?$allocator@D@std@@QAE@XZ proc near  ; CODE XREF: std::_Wrap_alloc<std::allocator<char>>::_Wrap_alloc<std::allocator<char>>(void)+Ap
.text$mn:000006D8                                         ; std::basic_string<char,std::char_traits<char>,std::allocator<char>>::basic_string<char,std::char_traits<char>,std::allocator<char>>(char const *)+2Bp
.text$mn:000006D8
.text$mn:000006D8 var_4           = dword ptr -4
.text$mn:000006D8
.text$mn:000006D8                 push    ebp
.text$mn:000006D9                 mov     ebp, esp
.text$mn:000006DB                 push    ecx
.text$mn:000006DC                 mov     [ebp+var_4], ecx
.text$mn:000006DF                 mov     eax, [ebp+var_4]
.text$mn:000006E2                 mov     esp, ebp
.text$mn:000006E4                 pop     ebp
.text$mn:000006E5                 retn
.text$mn:000006E5 ??0?$allocator@D@std@@QAE@XZ endp
.text$mn:000006E5
.text$mn:000006E5 ; ---------------------------------------------------------------------------
.text$mn:000006E6                 align 4
.text$mn:000006E6 _text$mn        ends
.text$mn:000006E6
.text$mn:000006E8 ; ===========================================================================
.text$mn:000006E8
.text$mn:000006E8 ; Segment type: Pure code
.text$mn:000006E8 ; Segment permissions: Read/Execute
.text$mn:000006E8 _text$mn        segment para public 'CODE' use32
.text$mn:000006E8                 assume cs:_text$mn
.text$mn:000006E8                 ;org 6E8h
.text$mn:000006E8 ; COMDAT (pick any)
.text$mn:000006E8                 assume es:nothing, ss:nothing, ds:_xdata$x, fs:nothing, gs:nothing
.text$mn:000006E8
.text$mn:000006E8 ; =============== S U B R O U T I N E =======================================
.text$mn:000006E8
.text$mn:000006E8 ; Attributes: bp-based frame
.text$mn:000006E8
.text$mn:000006E8 ; public: __thiscall std::allocator<struct std::_Container_proxy>::allocator<struct std::_Container_proxy>(void)
.text$mn:000006E8                 public ??0?$allocator@U_Container_proxy@std@@@std@@QAE@XZ
.text$mn:000006E8 ??0?$allocator@U_Container_proxy@std@@@std@@QAE@XZ proc near
.text$mn:000006E8                                         ; CODE XREF: std::_String_alloc<0,std::_String_base_types<char,std::allocator<char>>>::_Alloc_proxy(void)+Cp
.text$mn:000006E8                                         ; std::_String_alloc<0,std::_String_base_types<char,std::allocator<char>>>::_Free_proxy(void)+Cp
.text$mn:000006E8
.text$mn:000006E8 var_4           = dword ptr -4
.text$mn:000006E8
.text$mn:000006E8                 push    ebp
.text$mn:000006E9                 mov     ebp, esp
.text$mn:000006EB                 push    ecx
.text$mn:000006EC                 mov     [ebp+var_4], ecx
.text$mn:000006EF                 mov     eax, [ebp+var_4]
.text$mn:000006F2                 mov     esp, ebp
.text$mn:000006F4                 pop     ebp
.text$mn:000006F5                 retn
.text$mn:000006F5 ??0?$allocator@U_Container_proxy@std@@@std@@QAE@XZ endp
.text$mn:000006F5
.text$mn:000006F5 ; ---------------------------------------------------------------------------
.text$mn:000006F6                 align 4
.text$mn:000006F6 _text$mn        ends
.text$mn:000006F6
.text$mn:000006F8 ; ===========================================================================
.text$mn:000006F8
.text$mn:000006F8 ; Segment type: Pure code
.text$mn:000006F8 ; Segment permissions: Read/Execute
.text$mn:000006F8 _text$mn        segment para public 'CODE' use32
.text$mn:000006F8                 assume cs:_text$mn
.text$mn:000006F8                 ;org 6F8h
.text$mn:000006F8 ; COMDAT (pick any)
.text$mn:000006F8                 assume es:nothing, ss:nothing, ds:_xdata$x, fs:nothing, gs:nothing
.text$mn:000006F8
.text$mn:000006F8 ; =============== S U B R O U T I N E =======================================
.text$mn:000006F8
.text$mn:000006F8 ; Attributes: bp-based frame
.text$mn:000006F8
.text$mn:000006F8 ; int __stdcall std::basic_string<char,std::char_traits<char>,std::allocator<char>>::basic_string<char,std::char_traits<char>,std::allocator<char>>(char *Str)
.text$mn:000006F8                 public ??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@PBD@Z
.text$mn:000006F8 ??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@PBD@Z proc near
.text$mn:000006F8                                         ; CODE XREF: std::_Generic_error_category::message(int)+5Ap
.text$mn:000006F8                                         ; std::_Iostream_error_category::message(int)+3Dp ...
.text$mn:000006F8
.text$mn:000006F8 var_14          = dword ptr -14h
.text$mn:000006F8 var_D           = byte ptr -0Dh
.text$mn:000006F8 var_C           = dword ptr -0Ch
.text$mn:000006F8 var_4           = dword ptr -4
.text$mn:000006F8 Str             = dword ptr  8
.text$mn:000006F8
.text$mn:000006F8                 push    ebp
.text$mn:000006F9                 mov     ebp, esp
.text$mn:000006FB                 push    0FFFFFFFFh
.text$mn:000006FD                 push    offset __ehhandler$??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@PBD@Z
.text$mn:00000702                 mov     eax, large fs:0
.text$mn:00000708                 push    eax
.text$mn:00000709                 sub     esp, 8
.text$mn:0000070C                 mov     eax, dword ptr ds:___security_cookie
.text$mn:00000711                 xor     eax, ebp
.text$mn:00000713                 push    eax
.text$mn:00000714                 lea     eax, [ebp+var_C]
.text$mn:00000717                 mov     large fs:0, eax
.text$mn:0000071D                 mov     [ebp+var_14], ecx
.text$mn:00000720                 lea     ecx, [ebp+var_D]
.text$mn:00000723                 call    ??0?$allocator@D@std@@QAE@XZ ; std::allocator<char>::allocator<char>(void)
.text$mn:00000728                 push    eax
.text$mn:00000729                 mov     ecx, [ebp+var_14]
.text$mn:0000072C                 call    ??0?$_String_alloc@$0A@U?$_String_base_types@DV?$allocator@D@std@@@std@@@std@@QAE@ABV?$allocator@D@1@@Z ; std::_String_alloc<0,std::_String_base_types<char,std::allocator<char>>>::_String_alloc<0,std::_String_base_types<char,std::allocator<char>>>(std::allocator<char> const &)
.text$mn:00000731                 mov     [ebp+var_4], 0
.text$mn:00000738                 push    0               ; Size
.text$mn:0000073A                 push    0               ; char
.text$mn:0000073C                 mov     ecx, [ebp+var_14]
.text$mn:0000073F                 call    ?_Tidy@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEX_NI@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char>>::_Tidy(bool,uint)
.text$mn:00000744                 mov     eax, [ebp+Str]
.text$mn:00000747                 push    eax             ; Str
.text$mn:00000748                 mov     ecx, [ebp+var_14]
.text$mn:0000074B                 call    ?assign@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV12@PBD@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char>>::assign(char const *)
.text$mn:00000750                 mov     [ebp+var_4], 0FFFFFFFFh
.text$mn:00000757                 mov     eax, [ebp+var_14]
.text$mn:0000075A                 mov     ecx, [ebp+var_C]
.text$mn:0000075D                 mov     large fs:0, ecx
.text$mn:00000764                 pop     ecx
.text$mn:00000765                 mov     esp, ebp
.text$mn:00000767                 pop     ebp
.text$mn:00000768                 retn    4
.text$mn:00000768 ??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@PBD@Z endp
.text$mn:00000768
.text$mn:00000768 ; ---------------------------------------------------------------------------
.text$mn:0000076B                 align 4
.text$mn:0000076B _text$mn        ends
.text$mn:0000076B
.text$x:0000076C ; ===========================================================================
.text$x:0000076C
.text$x:0000076C ; Segment type: Pure code
.text$x:0000076C ; Segment permissions: Read/Execute
.text$x:0000076C _text$x         segment para public 'CODE' use32
.text$x:0000076C                 assume cs:_text$x
.text$x:0000076C                 ;org 76Ch
.text$x:0000076C ; COMDAT (pick associative to section at 6F8)
.text$x:0000076C                 assume es:nothing, ss:nothing, ds:_xdata$x, fs:nothing, gs:nothing
.text$x:0000076C
.text$x:0000076C ; =============== S U B R O U T I N E =======================================
.text$x:0000076C
.text$x:0000076C
.text$x:0000076C __unwindfunclet$??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@PBD@Z$0 proc near
.text$x:0000076C                                         ; DATA XREF: .xdata$x:0000200Co
.text$x:0000076C                 mov     ecx, [ebp-14h]
.text$x:0000076F                 jmp     ??1?$_String_alloc@$0A@U?$_String_base_types@DV?$allocator@D@std@@@std@@@std@@QAE@XZ ; std::_String_alloc<0,std::_String_base_types<char,std::allocator<char>>>::~_String_alloc<0,std::_String_base_types<char,std::allocator<char>>>(void)
.text$x:0000076F __unwindfunclet$??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@PBD@Z$0 endp
.text$x:0000076F
.text$x:00000774
.text$x:00000774 ; =============== S U B R O U T I N E =======================================
.text$x:00000774
.text$x:00000774
.text$x:00000774 __ehhandler$??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@PBD@Z proc near
.text$x:00000774                                         ; DATA XREF: std::basic_string<char,std::char_traits<char>,std::allocator<char>>::basic_string<char,std::char_traits<char>,std::allocator<char>>(char const *)+5o
.text$x:00000774
.text$x:00000774 arg_4           = dword ptr  8
.text$x:00000774
.text$x:00000774                 mov     edx, [esp+arg_4]
.text$x:00000778                 lea     eax, [edx+0Ch]
.text$x:0000077B                 mov     ecx, [edx-0Ch]
.text$x:0000077E                 xor     ecx, eax
.text$x:00000780                 call    @__security_check_cookie@4 ; __security_check_cookie(x)
.text$x:00000785                 mov     eax, offset __ehfuncinfo$??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@PBD@Z
.text$x:0000078A                 jmp     ___CxxFrameHandler3
.text$x:0000078A __ehhandler$??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@PBD@Z endp
.text$x:0000078A
.text$x:0000078A ; ---------------------------------------------------------------------------
.text$x:0000078F                 align 10h
.text$x:0000078F _text$x         ends
.text$x:0000078F
.text$mn:00000790 ; ===========================================================================
.text$mn:00000790
.text$mn:00000790 ; Segment type: Pure code
.text$mn:00000790 ; Segment permissions: Read/Execute
.text$mn:00000790 _text$mn        segment para public 'CODE' use32
.text$mn:00000790                 assume cs:_text$mn
.text$mn:00000790                 ;org 790h
.text$mn:00000790 ; COMDAT (pick any)
.text$mn:00000790                 assume es:nothing, ss:nothing, ds:_xdata$x, fs:nothing, gs:nothing
.text$mn:00000790
.text$mn:00000790 ; =============== S U B R O U T I N E =======================================
.text$mn:00000790
.text$mn:00000790 ; Attributes: bp-based frame
.text$mn:00000790
.text$mn:00000790 ; _DWORD __thiscall std::_Container_base12::_Container_base12(std::_Container_base12 *__hidden this)
.text$mn:00000790                 public ??0_Container_base12@std@@QAE@XZ
.text$mn:00000790 ??0_Container_base12@std@@QAE@XZ proc near
.text$mn:00000790                                         ; CODE XREF: std::_String_val<std::_Simple_types<char>>::_String_val<std::_Simple_types<char>>(void)+29p
.text$mn:00000790
.text$mn:00000790 var_4           = dword ptr -4
.text$mn:00000790
.text$mn:00000790                 push    ebp
.text$mn:00000791                 mov     ebp, esp
.text$mn:00000793                 push    ecx
.text$mn:00000794                 mov     [ebp+var_4], ecx
.text$mn:00000797                 mov     eax, [ebp+var_4]
.text$mn:0000079A                 mov     dword ptr [eax], 0
.text$mn:000007A0                 mov     eax, [ebp+var_4]
.text$mn:000007A3                 mov     esp, ebp
.text$mn:000007A5                 pop     ebp
.text$mn:000007A6                 retn
.text$mn:000007A6 ??0_Container_base12@std@@QAE@XZ endp
.text$mn:000007A6
.text$mn:000007A6 ; ---------------------------------------------------------------------------
.text$mn:000007A7                 align 4
.text$mn:000007A7 _text$mn        ends
.text$mn:000007A7
.text$mn:000007A8 ; ===========================================================================
.text$mn:000007A8
.text$mn:000007A8 ; Segment type: Pure code
.text$mn:000007A8 ; Segment permissions: Read/Execute
.text$mn:000007A8 _text$mn        segment para public 'CODE' use32
.text$mn:000007A8                 assume cs:_text$mn
.text$mn:000007A8                 ;org 7A8h
.text$mn:000007A8 ; COMDAT (pick any)
.text$mn:000007A8                 assume es:nothing, ss:nothing, ds:_xdata$x, fs:nothing, gs:nothing
.text$mn:000007A8
.text$mn:000007A8 ; =============== S U B R O U T I N E =======================================
.text$mn:000007A8
.text$mn:000007A8 ; Attributes: bp-based frame
.text$mn:000007A8
.text$mn:000007A8 ; _DWORD __thiscall std::_Container_proxy::_Container_proxy(std::_Container_proxy *__hidden this)
.text$mn:000007A8                 public ??0_Container_proxy@std@@QAE@XZ
.text$mn:000007A8 ??0_Container_proxy@std@@QAE@XZ proc near
.text$mn:000007A8                                         ; CODE XREF: std::_String_alloc<0,std::_String_base_types<char,std::allocator<char>>>::_Alloc_proxy(void)+23p
.text$mn:000007A8
.text$mn:000007A8 var_4           = dword ptr -4
.text$mn:000007A8
.text$mn:000007A8                 push    ebp
.text$mn:000007A9                 mov     ebp, esp
.text$mn:000007AB                 push    ecx
.text$mn:000007AC                 mov     [ebp+var_4], ecx
.text$mn:000007AF                 mov     eax, [ebp+var_4]
.text$mn:000007B2                 mov     dword ptr [eax], 0
.text$mn:000007B8                 mov     ecx, [ebp+var_4]
.text$mn:000007BB                 mov     dword ptr [ecx+4], 0
.text$mn:000007C2                 mov     eax, [ebp+var_4]
.text$mn:000007C5                 mov     esp, ebp
.text$mn:000007C7                 pop     ebp
.text$mn:000007C8                 retn
.text$mn:000007C8 ??0_Container_proxy@std@@QAE@XZ endp
.text$mn:000007C8
.text$mn:000007C8 ; ---------------------------------------------------------------------------
.text$mn:000007C9                 align 4
.text$mn:000007C9 _text$mn        ends
.text$mn:000007C9
.text$mn:000007CC ; ===========================================================================
.text$mn:000007CC
.text$mn:000007CC ; Segment type: Pure code
.text$mn:000007CC ; Segment permissions: Read/Execute
.text$mn:000007CC _text$mn        segment para public 'CODE' use32
.text$mn:000007CC                 assume cs:_text$mn
.text$mn:000007CC                 ;org 7CCh
.text$mn:000007CC ; COMDAT (pick any)
.text$mn:000007CC                 assume es:nothing, ss:nothing, ds:_xdata$x, fs:nothing, gs:nothing
.text$mn:000007CC
.text$mn:000007CC ; =============== S U B R O U T I N E =======================================
.text$mn:000007CC
.text$mn:000007CC ; Attributes: bp-based frame
.text$mn:000007CC
.text$mn:000007CC ; _DWORD __thiscall std::_Generic_error_category::_Generic_error_category(std::_Generic_error_category *__hidden this)
.text$mn:000007CC                 public ??0_Generic_error_category@std@@QAE@XZ
.text$mn:000007CC ??0_Generic_error_category@std@@QAE@XZ proc near
.text$mn:000007CC                                         ; CODE XREF: std::_Iostream_error_category::_Iostream_error_category(void)+29p
.text$mn:000007CC                                         ; std::_System_error_category::_System_error_category(void)+29p ...
.text$mn:000007CC
.text$mn:000007CC var_10          = dword ptr -10h
.text$mn:000007CC var_C           = dword ptr -0Ch
.text$mn:000007CC var_4           = dword ptr -4
.text$mn:000007CC
.text$mn:000007CC                 push    ebp
.text$mn:000007CD                 mov     ebp, esp
.text$mn:000007CF                 push    0FFFFFFFFh
.text$mn:000007D1                 push    offset __ehhandler$??0_Generic_error_category@std@@QAE@XZ
.text$mn:000007D6                 mov     eax, large fs:0
.text$mn:000007DC                 push    eax
.text$mn:000007DD                 push    ecx
.text$mn:000007DE                 mov     eax, dword ptr ds:___security_cookie
.text$mn:000007E3                 xor     eax, ebp
.text$mn:000007E5                 push    eax
.text$mn:000007E6                 lea     eax, [ebp+var_C]
.text$mn:000007E9                 mov     large fs:0, eax
.text$mn:000007EF                 mov     [ebp+var_10], ecx
.text$mn:000007F2                 mov     ecx, [ebp+var_10] ; this
.text$mn:000007F5                 call    ??0error_category@std@@QAE@XZ ; std::error_category::error_category(void)
.text$mn:000007FA                 mov     [ebp+var_4], 0
.text$mn:00000801                 mov     eax, [ebp+var_10]
.text$mn:00000804                 mov     dword ptr [eax], offset ??_7_Generic_error_category@std@@6B@ ; const std::_Generic_error_category::`vftable'
.text$mn:0000080A                 mov     [ebp+var_4], 0FFFFFFFFh
.text$mn:00000811                 mov     eax, [ebp+var_10]
.text$mn:00000814                 mov     ecx, [ebp+var_C]
.text$mn:00000817                 mov     large fs:0, ecx
.text$mn:0000081E                 pop     ecx
.text$mn:0000081F                 mov     esp, ebp
.text$mn:00000821                 pop     ebp
.text$mn:00000822                 retn
.text$mn:00000822 ??0_Generic_error_category@std@@QAE@XZ endp
.text$mn:00000822
.text$mn:00000822 ; ---------------------------------------------------------------------------
.text$mn:00000823                 align 4
.text$mn:00000823 _text$mn        ends
.text$mn:00000823
.text$x:00000824 ; ===========================================================================
.text$x:00000824
.text$x:00000824 ; Segment type: Pure code
.text$x:00000824 ; Segment permissions: Read/Execute
.text$x:00000824 _text$x         segment para public 'CODE' use32
.text$x:00000824                 assume cs:_text$x
.text$x:00000824                 ;org 824h
.text$x:00000824 ; COMDAT (pick associative to section at 7CC)
.text$x:00000824                 assume es:nothing, ss:nothing, ds:_xdata$x, fs:nothing, gs:nothing
.text$x:00000824
.text$x:00000824 ; =============== S U B R O U T I N E =======================================
.text$x:00000824
.text$x:00000824
.text$x:00000824 __unwindfunclet$??0_Generic_error_category@std@@QAE@XZ$0 proc near
.text$x:00000824                                         ; DATA XREF: .xdata$x:000020F0o
.text$x:00000824                 mov     ecx, [ebp-10h]  ; this
.text$x:00000827                 jmp     ??1error_category@std@@UAE@XZ ; std::error_category::~error_category(void)
.text$x:00000827 __unwindfunclet$??0_Generic_error_category@std@@QAE@XZ$0 endp
.text$x:00000827
.text$x:0000082C
.text$x:0000082C ; =============== S U B R O U T I N E =======================================
.text$x:0000082C
.text$x:0000082C
.text$x:0000082C __ehhandler$??0_Generic_error_category@std@@QAE@XZ proc near
.text$x:0000082C                                         ; DATA XREF: std::_Generic_error_category::_Generic_error_category(void)+5o
.text$x:0000082C
.text$x:0000082C arg_4           = dword ptr  8
.text$x:0000082C
.text$x:0000082C                 mov     edx, [esp+arg_4]
.text$x:00000830                 lea     eax, [edx+0Ch]
.text$x:00000833                 mov     ecx, [edx-8]
.text$x:00000836                 xor     ecx, eax
.text$x:00000838                 call    @__security_check_cookie@4 ; __security_check_cookie(x)
.text$x:0000083D                 mov     eax, offset __ehfuncinfo$??0_Generic_error_category@std@@QAE@XZ
.text$x:00000842                 jmp     ___CxxFrameHandler3
.text$x:00000842 __ehhandler$??0_Generic_error_category@std@@QAE@XZ endp
.text$x:00000842
.text$x:00000842 ; ---------------------------------------------------------------------------
.text$x:00000847                 align 4
.text$x:00000847 _text$x         ends
.text$x:00000847
.text$mn:00000848 ; ===========================================================================
.text$mn:00000848
.text$mn:00000848 ; Segment type: Pure code
.text$mn:00000848 ; Segment permissions: Read/Execute
.text$mn:00000848 _text$mn        segment para public 'CODE' use32
.text$mn:00000848                 assume cs:_text$mn
.text$mn:00000848                 ;org 848h
.text$mn:00000848 ; COMDAT (pick any)
.text$mn:00000848                 assume es:nothing, ss:nothing, ds:_xdata$x, fs:nothing, gs:nothing
.text$mn:00000848
.text$mn:00000848 ; =============== S U B R O U T I N E =======================================
.text$mn:00000848
.text$mn:00000848 ; Attributes: bp-based frame
.text$mn:00000848
.text$mn:00000848 ; _DWORD __thiscall std::_Iostream_error_category::_Iostream_error_category(std::_Iostream_error_category *__hidden this)
.text$mn:00000848                 public ??0_Iostream_error_category@std@@QAE@XZ
.text$mn:00000848 ??0_Iostream_error_category@std@@QAE@XZ proc near
.text$mn:00000848                                         ; CODE XREF: `dynamic initializer for 'std::_Iostream_error_category std::_Error_objects<int>::_Iostream_object''(void)+8p
.text$mn:00000848
.text$mn:00000848 var_10          = dword ptr -10h
.text$mn:00000848 var_C           = dword ptr -0Ch
.text$mn:00000848 var_4           = dword ptr -4
.text$mn:00000848
.text$mn:00000848                 push    ebp
.text$mn:00000849                 mov     ebp, esp
.text$mn:0000084B                 push    0FFFFFFFFh
.text$mn:0000084D                 push    offset __ehhandler$??0_Iostream_error_category@std@@QAE@XZ
.text$mn:00000852                 mov     eax, large fs:0
.text$mn:00000858                 push    eax
.text$mn:00000859                 push    ecx
.text$mn:0000085A                 mov     eax, dword ptr ds:___security_cookie
.text$mn:0000085F                 xor     eax, ebp
.text$mn:00000861                 push    eax
.text$mn:00000862                 lea     eax, [ebp+var_C]
.text$mn:00000865                 mov     large fs:0, eax
.text$mn:0000086B                 mov     [ebp+var_10], ecx
.text$mn:0000086E                 mov     ecx, [ebp+var_10] ; this
.text$mn:00000871                 call    ??0_Generic_error_category@std@@QAE@XZ ; std::_Generic_error_category::_Generic_error_category(void)
.text$mn:00000876                 mov     [ebp+var_4], 0
.text$mn:0000087D                 mov     eax, [ebp+var_10]
.text$mn:00000880                 mov     dword ptr [eax], offset ??_7_Iostream_error_category@std@@6B@ ; const std::_Iostream_error_category::`vftable'
.text$mn:00000886                 mov     [ebp+var_4], 0FFFFFFFFh
.text$mn:0000088D                 mov     eax, [ebp+var_10]
.text$mn:00000890                 mov     ecx, [ebp+var_C]
.text$mn:00000893                 mov     large fs:0, ecx
.text$mn:0000089A                 pop     ecx
.text$mn:0000089B                 mov     esp, ebp
.text$mn:0000089D                 pop     ebp
.text$mn:0000089E                 retn
.text$mn:0000089E ??0_Iostream_error_category@std@@QAE@XZ endp
.text$mn:0000089E
.text$mn:0000089E ; ---------------------------------------------------------------------------
.text$mn:0000089F                 align 10h
.text$mn:0000089F _text$mn        ends
.text$mn:0000089F
.text$x:000008A0 ; ===========================================================================
.text$x:000008A0
.text$x:000008A0 ; Segment type: Pure code
.text$x:000008A0 ; Segment permissions: Read/Execute
.text$x:000008A0 _text$x         segment para public 'CODE' use32
.text$x:000008A0                 assume cs:_text$x
.text$x:000008A0                 ;org 8A0h
.text$x:000008A0 ; COMDAT (pick associative to section at 848)
.text$x:000008A0                 assume es:nothing, ss:nothing, ds:_xdata$x, fs:nothing, gs:nothing
.text$x:000008A0
.text$x:000008A0 ; =============== S U B R O U T I N E =======================================
.text$x:000008A0
.text$x:000008A0
.text$x:000008A0 __unwindfunclet$??0_Iostream_error_category@std@@QAE@XZ$0 proc near
.text$x:000008A0                                         ; DATA XREF: .xdata$x:00002174o
.text$x:000008A0                 mov     ecx, [ebp-10h]  ; this
.text$x:000008A3                 jmp     ??1_Generic_error_category@std@@UAE@XZ ; std::_Generic_error_category::~_Generic_error_category(void)
.text$x:000008A3 __unwindfunclet$??0_Iostream_error_category@std@@QAE@XZ$0 endp
.text$x:000008A3
.text$x:000008A8
.text$x:000008A8 ; =============== S U B R O U T I N E =======================================
.text$x:000008A8
.text$x:000008A8
.text$x:000008A8 __ehhandler$??0_Iostream_error_category@std@@QAE@XZ proc near
.text$x:000008A8                                         ; DATA XREF: std::_Iostream_error_category::_Iostream_error_category(void)+5o
.text$x:000008A8
.text$x:000008A8 arg_4           = dword ptr  8
.text$x:000008A8
.text$x:000008A8                 mov     edx, [esp+arg_4]
.text$x:000008AC                 lea     eax, [edx+0Ch]
.text$x:000008AF                 mov     ecx, [edx-8]
.text$x:000008B2                 xor     ecx, eax
.text$x:000008B4                 call    @__security_check_cookie@4 ; __security_check_cookie(x)
.text$x:000008B9                 mov     eax, offset __ehfuncinfo$??0_Iostream_error_category@std@@QAE@XZ
.text$x:000008BE                 jmp     ___CxxFrameHandler3
.text$x:000008BE __ehhandler$??0_Iostream_error_category@std@@QAE@XZ endp
.text$x:000008BE
.text$x:000008BE ; ---------------------------------------------------------------------------
.text$x:000008C3                 align 4
.text$x:000008C3 _text$x         ends
.text$x:000008C3
.text$mn:000008C4 ; ===========================================================================
.text$mn:000008C4
.text$mn:000008C4 ; Segment type: Pure code
.text$mn:000008C4 ; Segment permissions: Read/Execute
.text$mn:000008C4 _text$mn        segment para public 'CODE' use32
.text$mn:000008C4                 assume cs:_text$mn
.text$mn:000008C4                 ;org 8C4h
.text$mn:000008C4 ; COMDAT (pick any)
.text$mn:000008C4                 assume es:nothing, ss:nothing, ds:_xdata$x, fs:nothing, gs:nothing
.text$mn:000008C4
.text$mn:000008C4 ; =============== S U B R O U T I N E =======================================
.text$mn:000008C4
.text$mn:000008C4 ; Attributes: bp-based frame
.text$mn:000008C4
.text$mn:000008C4 ; _DWORD __thiscall std::_System_error_category::_System_error_category(std::_System_error_category *__hidden this)
.text$mn:000008C4                 public ??0_System_error_category@std@@QAE@XZ
.text$mn:000008C4 ??0_System_error_category@std@@QAE@XZ proc near
.text$mn:000008C4                                         ; CODE XREF: `dynamic initializer for 'std::_System_error_category std::_Error_objects<int>::_System_object''(void)+8p
.text$mn:000008C4
.text$mn:000008C4 var_10          = dword ptr -10h
.text$mn:000008C4 var_C           = dword ptr -0Ch
.text$mn:000008C4 var_4           = dword ptr -4
.text$mn:000008C4
.text$mn:000008C4                 push    ebp
.text$mn:000008C5                 mov     ebp, esp
.text$mn:000008C7                 push    0FFFFFFFFh
.text$mn:000008C9                 push    offset __ehhandler$??0_System_error_category@std@@QAE@XZ
.text$mn:000008CE                 mov     eax, large fs:0
.text$mn:000008D4                 push    eax
.text$mn:000008D5                 push    ecx
.text$mn:000008D6                 mov     eax, dword ptr ds:___security_cookie
.text$mn:000008DB                 xor     eax, ebp
.text$mn:000008DD                 push    eax
.text$mn:000008DE                 lea     eax, [ebp+var_C]
.text$mn:000008E1                 mov     large fs:0, eax
.text$mn:000008E7                 mov     [ebp+var_10], ecx
.text$mn:000008EA                 mov     ecx, [ebp+var_10] ; this
.text$mn:000008ED                 call    ??0_Generic_error_category@std@@QAE@XZ ; std::_Generic_error_category::_Generic_error_category(void)
.text$mn:000008F2                 mov     [ebp+var_4], 0
.text$mn:000008F9                 mov     eax, [ebp+var_10]
.text$mn:000008FC                 mov     dword ptr [eax], offset ??_7_System_error_category@std@@6B@ ; const std::_System_error_category::`vftable'
.text$mn:00000902                 mov     [ebp+var_4], 0FFFFFFFFh
.text$mn:00000909                 mov     eax, [ebp+var_10]
.text$mn:0000090C                 mov     ecx, [ebp+var_C]
.text$mn:0000090F                 mov     large fs:0, ecx
.text$mn:00000916                 pop     ecx
.text$mn:00000917                 mov     esp, ebp
.text$mn:00000919                 pop     ebp
.text$mn:0000091A                 retn
.text$mn:0000091A ??0_System_error_category@std@@QAE@XZ endp
.text$mn:0000091A
.text$mn:0000091A ; ---------------------------------------------------------------------------
.text$mn:0000091B                 align 4
.text$mn:0000091B _text$mn        ends
.text$mn:0000091B
.text$x:0000091C ; ===========================================================================
.text$x:0000091C
.text$x:0000091C ; Segment type: Pure code
.text$x:0000091C ; Segment permissions: Read/Execute
.text$x:0000091C _text$x         segment para public 'CODE' use32
.text$x:0000091C                 assume cs:_text$x
.text$x:0000091C                 ;org 91Ch
.text$x:0000091C ; COMDAT (pick associative to section at 8C4)
.text$x:0000091C                 assume es:nothing, ss:nothing, ds:_xdata$x, fs:nothing, gs:nothing
.text$x:0000091C
.text$x:0000091C ; =============== S U B R O U T I N E =======================================
.text$x:0000091C
.text$x:0000091C
.text$x:0000091C __unwindfunclet$??0_System_error_category@std@@QAE@XZ$0 proc near
.text$x:0000091C                                         ; DATA XREF: .xdata$x:000021F8o
.text$x:0000091C                 mov     ecx, [ebp-10h]  ; this
.text$x:0000091F                 jmp     ??1_Generic_error_category@std@@UAE@XZ ; std::_Generic_error_category::~_Generic_error_category(void)
.text$x:0000091F __unwindfunclet$??0_System_error_category@std@@QAE@XZ$0 endp
.text$x:0000091F
.text$x:00000924
.text$x:00000924 ; =============== S U B R O U T I N E =======================================
.text$x:00000924
.text$x:00000924
.text$x:00000924 __ehhandler$??0_System_error_category@std@@QAE@XZ proc near
.text$x:00000924                                         ; DATA XREF: std::_System_error_category::_System_error_category(void)+5o
.text$x:00000924
.text$x:00000924 arg_4           = dword ptr  8
.text$x:00000924
.text$x:00000924                 mov     edx, [esp+arg_4]
.text$x:00000928                 lea     eax, [edx+0Ch]
.text$x:0000092B                 mov     ecx, [edx-8]
.text$x:0000092E                 xor     ecx, eax
.text$x:00000930                 call    @__security_check_cookie@4 ; __security_check_cookie(x)
.text$x:00000935                 mov     eax, offset __ehfuncinfo$??0_System_error_category@std@@QAE@XZ
.text$x:0000093A                 jmp     ___CxxFrameHandler3
.text$x:0000093A __ehhandler$??0_System_error_category@std@@QAE@XZ endp
.text$x:0000093A
.text$x:0000093A ; ---------------------------------------------------------------------------
.text$x:0000093F                 align 10h
.text$x:0000093F _text$x         ends
.text$x:0000093F
.text$mn:00000940 ; ===========================================================================
.text$mn:00000940
.text$mn:00000940 ; Segment type: Pure code
.text$mn:00000940 ; Segment permissions: Read/Execute
.text$mn:00000940 _text$mn        segment para public 'CODE' use32
.text$mn:00000940                 assume cs:_text$mn
.text$mn:00000940                 ;org 940h
.text$mn:00000940 ; COMDAT (pick any)
.text$mn:00000940                 assume es:nothing, ss:nothing, ds:_xdata$x, fs:nothing, gs:nothing
.text$mn:00000940
.text$mn:00000940 ; =============== S U B R O U T I N E =======================================
.text$mn:00000940
.text$mn:00000940 ; Attributes: bp-based frame
.text$mn:00000940
.text$mn:00000940 ; _DWORD __thiscall std::error_category::error_category(std::error_category *__hidden this)
.text$mn:00000940                 public ??0error_category@std@@QAE@XZ
.text$mn:00000940 ??0error_category@std@@QAE@XZ proc near ; CODE XREF: std::_Generic_error_category::_Generic_error_category(void)+29p
.text$mn:00000940
.text$mn:00000940 var_4           = dword ptr -4
.text$mn:00000940
.text$mn:00000940                 push    ebp
.text$mn:00000941                 mov     ebp, esp
.text$mn:00000943                 push    ecx
.text$mn:00000944                 mov     [ebp+var_4], ecx
.text$mn:00000947                 mov     eax, [ebp+var_4]
.text$mn:0000094A                 mov     dword ptr [eax], offset ??_7error_category@std@@6B@ ; const std::error_category::`vftable'
.text$mn:00000950                 mov     eax, [ebp+var_4]
.text$mn:00000953                 mov     esp, ebp
.text$mn:00000955                 pop     ebp
.text$mn:00000956                 retn
.text$mn:00000956 ??0error_category@std@@QAE@XZ endp
.text$mn:00000956
.text$mn:00000956 ; ---------------------------------------------------------------------------
.text$mn:00000957                 align 4
.text$mn:00000957 _text$mn        ends
.text$mn:00000957
.text$mn:00000958 ; ===========================================================================
.text$mn:00000958
.text$mn:00000958 ; Segment type: Pure code
.text$mn:00000958 ; Segment permissions: Read/Execute
.text$mn:00000958 _text$mn        segment para public 'CODE' use32
.text$mn:00000958                 assume cs:_text$mn
.text$mn:00000958                 ;org 958h
.text$mn:00000958 ; COMDAT (pick any)
.text$mn:00000958                 assume es:nothing, ss:nothing, ds:_xdata$x, fs:nothing, gs:nothing
.text$mn:00000958
.text$mn:00000958 ; =============== S U B R O U T I N E =======================================
.text$mn:00000958
.text$mn:00000958 ; Attributes: bp-based frame
.text$mn:00000958
.text$mn:00000958 ; _DWORD __thiscall std::error_condition::error_condition(std::error_condition *this, int, const struct std::error_category *)
.text$mn:00000958                 public ??0error_condition@std@@QAE@HABVerror_category@1@@Z
.text$mn:00000958 ??0error_condition@std@@QAE@HABVerror_category@1@@Z proc near
.text$mn:00000958                                         ; CODE XREF: std::_System_error_category::default_error_condition(int)+24p
.text$mn:00000958                                         ; std::_System_error_category::default_error_condition(int)+3Dp ...
.text$mn:00000958
.text$mn:00000958 var_4           = dword ptr -4
.text$mn:00000958 arg_0           = dword ptr  8
.text$mn:00000958 arg_4           = dword ptr  0Ch
.text$mn:00000958
.text$mn:00000958                 push    ebp
.text$mn:00000959                 mov     ebp, esp
.text$mn:0000095B                 push    ecx
.text$mn:0000095C                 mov     [ebp+var_4], ecx
.text$mn:0000095F                 mov     eax, [ebp+var_4]
.text$mn:00000962                 mov     ecx, [ebp+arg_0]
.text$mn:00000965                 mov     [eax], ecx
.text$mn:00000967                 mov     edx, [ebp+var_4]
.text$mn:0000096A                 mov     eax, [ebp+arg_4]
.text$mn:0000096D                 mov     [edx+4], eax
.text$mn:00000970                 mov     eax, [ebp+var_4]
.text$mn:00000973                 mov     esp, ebp
.text$mn:00000975                 pop     ebp
.text$mn:00000976                 retn    8
.text$mn:00000976 ??0error_condition@std@@QAE@HABVerror_category@1@@Z endp
.text$mn:00000976
.text$mn:00000976 ; ---------------------------------------------------------------------------
.text$mn:00000979                 align 4
.text$mn:00000979 _text$mn        ends
.text$mn:00000979
.text$mn:0000097C ; ===========================================================================
.text$mn:0000097C
.text$mn:0000097C ; Segment type: Pure code
.text$mn:0000097C ; Segment permissions: Read/Execute
.text$mn:0000097C _text$mn        segment para public 'CODE' use32
.text$mn:0000097C                 assume cs:_text$mn
.text$mn:0000097C                 ;org 97Ch
.text$mn:0000097C ; COMDAT (pick any)
.text$mn:0000097C                 assume es:nothing, ss:nothing, ds:_xdata$x, fs:nothing, gs:nothing
.text$mn:0000097C
.text$mn:0000097C ; =============== S U B R O U T I N E =======================================
.text$mn:0000097C
.text$mn:0000097C ; Attributes: bp-based frame
.text$mn:0000097C
.text$mn:0000097C ; _DWORD __thiscall std::locale::id::id(std::locale::id *this, unsigned int)
.text$mn:0000097C                 public ??0id@locale@std@@QAE@I@Z
.text$mn:0000097C ??0id@locale@std@@QAE@I@Z proc near     ; CODE XREF: `dynamic initializer for 'std::locale::id std::num_put<char,std::back_insert_iterator<std::basic_string<char,std::char_traits<char>,std::allocator<char>>>>::id''(void)+Ap
.text$mn:0000097C                                         ; `dynamic initializer for 'std::locale::id std::num_put<wchar_t,std::back_insert_iterator<std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>>>>::id''(void)+Ap ...
.text$mn:0000097C
.text$mn:0000097C var_4           = dword ptr -4
.text$mn:0000097C arg_0           = dword ptr  8
.text$mn:0000097C
.text$mn:0000097C                 push    ebp
.text$mn:0000097D                 mov     ebp, esp
.text$mn:0000097F                 push    ecx
.text$mn:00000980                 mov     [ebp+var_4], ecx
.text$mn:00000983                 mov     eax, [ebp+var_4]
.text$mn:00000986                 mov     ecx, [ebp+arg_0]
.text$mn:00000989                 mov     [eax], ecx
.text$mn:0000098B                 mov     eax, [ebp+var_4]
.text$mn:0000098E                 mov     esp, ebp
.text$mn:00000990                 pop     ebp
.text$mn:00000991                 retn    4
.text$mn:00000991 ??0id@locale@std@@QAE@I@Z endp
.text$mn:00000991
.text$mn:00000991 _text$mn        ends
.text$mn:00000991
.text$mn:00000994 ; ===========================================================================
.text$mn:00000994
.text$mn:00000994 ; Segment type: Pure code
.text$mn:00000994 ; Segment permissions: Read/Execute
.text$mn:00000994 _text$mn        segment para public 'CODE' use32
.text$mn:00000994                 assume cs:_text$mn
.text$mn:00000994                 ;org 994h
.text$mn:00000994 ; COMDAT (pick any)
.text$mn:00000994                 assume es:nothing, ss:nothing, ds:_xdata$x, fs:nothing, gs:nothing
.text$mn:00000994
.text$mn:00000994 ; =============== S U B R O U T I N E =======================================
.text$mn:00000994
.text$mn:00000994 ; Attributes: bp-based frame
.text$mn:00000994
.text$mn:00000994 ; public: __thiscall std::_String_alloc<0, struct std::_String_base_types<char, class std::allocator<char>>>::~_String_alloc<0, struct std::_String_base_types<char, class std::allocator<char>>>(void)
.text$mn:00000994                 public ??1?$_String_alloc@$0A@U?$_String_base_types@DV?$allocator@D@std@@@std@@@std@@QAE@XZ
.text$mn:00000994 ??1?$_String_alloc@$0A@U?$_String_base_types@DV?$allocator@D@std@@@std@@@std@@QAE@XZ proc near
.text$mn:00000994                                         ; CODE XREF: __unwindfunclet$??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@PBD@Z$0+3j
.text$mn:00000994                                         ; std::basic_string<char,std::char_traits<char>,std::allocator<char>>::~basic_string<char,std::char_traits<char>,std::allocator<char>>(void)+43p ...
.text$mn:00000994
.text$mn:00000994 var_10          = dword ptr -10h
.text$mn:00000994 var_C           = dword ptr -0Ch
.text$mn:00000994 var_4           = dword ptr -4
.text$mn:00000994
.text$mn:00000994                 push    ebp
.text$mn:00000995                 mov     ebp, esp
.text$mn:00000997                 push    0FFFFFFFFh
.text$mn:00000999                 push    offset __ehhandler$??1?$_String_alloc@$0A@U?$_String_base_types@DV?$allocator@D@std@@@std@@@std@@QAE@XZ
.text$mn:0000099E                 mov     eax, large fs:0
.text$mn:000009A4                 push    eax
.text$mn:000009A5                 push    ecx
.text$mn:000009A6                 mov     eax, dword ptr ds:___security_cookie
.text$mn:000009AB                 xor     eax, ebp
.text$mn:000009AD                 push    eax
.text$mn:000009AE                 lea     eax, [ebp+var_C]
.text$mn:000009B1                 mov     large fs:0, eax
.text$mn:000009B7                 mov     [ebp+var_10], ecx
.text$mn:000009BA                 mov     [ebp+var_4], 0
.text$mn:000009C1                 mov     ecx, [ebp+var_10]
.text$mn:000009C4                 call    ?_Free_proxy@?$_String_alloc@$0A@U?$_String_base_types@DV?$allocator@D@std@@@std@@@std@@QAEXXZ ; std::_String_alloc<0,std::_String_base_types<char,std::allocator<char>>>::_Free_proxy(void)
.text$mn:000009C9                 mov     [ebp+var_4], 0FFFFFFFFh
.text$mn:000009D0                 mov     ecx, [ebp+var_10]
.text$mn:000009D3                 call    ??1?$_String_val@U?$_Simple_types@D@std@@@std@@QAE@XZ ; std::_String_val<std::_Simple_types<char>>::~_String_val<std::_Simple_types<char>>(void)
.text$mn:000009D8                 mov     ecx, [ebp+var_C]
.text$mn:000009DB                 mov     large fs:0, ecx
.text$mn:000009E2                 pop     ecx
.text$mn:000009E3                 mov     esp, ebp
.text$mn:000009E5                 pop     ebp
.text$mn:000009E6                 retn
.text$mn:000009E6 ??1?$_String_alloc@$0A@U?$_String_base_types@DV?$allocator@D@std@@@std@@@std@@QAE@XZ endp
.text$mn:000009E6
.text$mn:000009E6 ; ---------------------------------------------------------------------------
.text$mn:000009E7                 align 4
.text$mn:000009E7 _text$mn        ends
.text$mn:000009E7
.text$x:000009E8 ; ===========================================================================
.text$x:000009E8
.text$x:000009E8 ; Segment type: Pure code
.text$x:000009E8 ; Segment permissions: Read/Execute
.text$x:000009E8 _text$x         segment para public 'CODE' use32
.text$x:000009E8                 assume cs:_text$x
.text$x:000009E8                 ;org 9E8h
.text$x:000009E8 ; COMDAT (pick associative to section at 994)
.text$x:000009E8                 assume es:nothing, ss:nothing, ds:_xdata$x, fs:nothing, gs:nothing
.text$x:000009E8
.text$x:000009E8 ; =============== S U B R O U T I N E =======================================
.text$x:000009E8
.text$x:000009E8
.text$x:000009E8 __unwindfunclet$??1?$_String_alloc@$0A@U?$_String_base_types@DV?$allocator@D@std@@@std@@@std@@QAE@XZ$0 proc near
.text$x:000009E8                                         ; DATA XREF: .xdata$x:00001FE0o
.text$x:000009E8                 mov     ecx, [ebp-10h]
.text$x:000009EB                 jmp     ??1?$_String_val@U?$_Simple_types@D@std@@@std@@QAE@XZ ; std::_String_val<std::_Simple_types<char>>::~_String_val<std::_Simple_types<char>>(void)
.text$x:000009EB __unwindfunclet$??1?$_String_alloc@$0A@U?$_String_base_types@DV?$allocator@D@std@@@std@@@std@@QAE@XZ$0 endp
.text$x:000009EB
.text$x:000009F0
.text$x:000009F0 ; =============== S U B R O U T I N E =======================================
.text$x:000009F0
.text$x:000009F0
.text$x:000009F0 __ehhandler$??1?$_String_alloc@$0A@U?$_String_base_types@DV?$allocator@D@std@@@std@@@std@@QAE@XZ proc near
.text$x:000009F0                                         ; DATA XREF: std::_String_alloc<0,std::_String_base_types<char,std::allocator<char>>>::~_String_alloc<0,std::_String_base_types<char,std::allocator<char>>>(void)+5o
.text$x:000009F0
.text$x:000009F0 arg_4           = dword ptr  8
.text$x:000009F0
.text$x:000009F0                 mov     edx, [esp+arg_4]
.text$x:000009F4                 lea     eax, [edx+0Ch]
.text$x:000009F7                 mov     ecx, [edx-8]
.text$x:000009FA                 xor     ecx, eax
.text$x:000009FC                 call    @__security_check_cookie@4 ; __security_check_cookie(x)
.text$x:00000A01                 mov     eax, offset __ehfuncinfo$??1?$_String_alloc@$0A@U?$_String_base_types@DV?$allocator@D@std@@@std@@@std@@QAE@XZ
.text$x:00000A06                 jmp     ___CxxFrameHandler3
.text$x:00000A06 __ehhandler$??1?$_String_alloc@$0A@U?$_String_base_types@DV?$allocator@D@std@@@std@@@std@@QAE@XZ endp
.text$x:00000A06
.text$x:00000A06 ; ---------------------------------------------------------------------------
.text$x:00000A0B                 align 4
.text$x:00000A0B _text$x         ends
.text$x:00000A0B
.text$mn:00000A0C ; ===========================================================================
.text$mn:00000A0C
.text$mn:00000A0C ; Segment type: Pure code
.text$mn:00000A0C ; Segment permissions: Read/Execute
.text$mn:00000A0C _text$mn        segment para public 'CODE' use32
.text$mn:00000A0C                 assume cs:_text$mn
.text$mn:00000A0C                 ;org 0A0Ch
.text$mn:00000A0C ; COMDAT (pick any)
.text$mn:00000A0C                 assume es:nothing, ss:nothing, ds:_xdata$x, fs:nothing, gs:nothing
.text$mn:00000A0C
.text$mn:00000A0C ; =============== S U B R O U T I N E =======================================
.text$mn:00000A0C
.text$mn:00000A0C ; Attributes: bp-based frame
.text$mn:00000A0C
.text$mn:00000A0C ; public: __thiscall std::_String_val<struct std::_Simple_types<char>>::~_String_val<struct std::_Simple_types<char>>(void)
.text$mn:00000A0C                 public ??1?$_String_val@U?$_Simple_types@D@std@@@std@@QAE@XZ
.text$mn:00000A0C ??1?$_String_val@U?$_Simple_types@D@std@@@std@@QAE@XZ proc near
.text$mn:00000A0C                                         ; CODE XREF: __unwindfunclet$??0?$_String_alloc@$0A@U?$_String_base_types@DV?$allocator@D@std@@@std@@@std@@QAE@ABV?$allocator@D@1@@Z$0+3j
.text$mn:00000A0C                                         ; std::_String_alloc<0,std::_String_base_types<char,std::allocator<char>>>::~_String_alloc<0,std::_String_base_types<char,std::allocator<char>>>(void)+3Fp ...
.text$mn:00000A0C
.text$mn:00000A0C var_10          = dword ptr -10h
.text$mn:00000A0C var_C           = dword ptr -0Ch
.text$mn:00000A0C var_4           = dword ptr -4
.text$mn:00000A0C
.text$mn:00000A0C                 push    ebp
.text$mn:00000A0D                 mov     ebp, esp
.text$mn:00000A0F                 push    0FFFFFFFFh
.text$mn:00000A11                 push    offset __ehhandler$??1?$_String_val@U?$_Simple_types@D@std@@@std@@QAE@XZ
.text$mn:00000A16                 mov     eax, large fs:0
.text$mn:00000A1C                 push    eax
.text$mn:00000A1D                 push    ecx
.text$mn:00000A1E                 mov     eax, dword ptr ds:___security_cookie
.text$mn:00000A23                 xor     eax, ebp
.text$mn:00000A25                 push    eax
.text$mn:00000A26                 lea     eax, [ebp+var_C]
.text$mn:00000A29                 mov     large fs:0, eax
.text$mn:00000A2F                 mov     [ebp+var_10], ecx
.text$mn:00000A32                 mov     [ebp+var_4], 0
.text$mn:00000A39                 mov     [ebp+var_4], 0FFFFFFFFh
.text$mn:00000A40                 mov     ecx, [ebp+var_10] ; this
.text$mn:00000A43                 call    ??1_Container_base12@std@@QAE@XZ ; std::_Container_base12::~_Container_base12(void)
.text$mn:00000A48                 mov     ecx, [ebp+var_C]
.text$mn:00000A4B                 mov     large fs:0, ecx
.text$mn:00000A52                 pop     ecx
.text$mn:00000A53                 mov     esp, ebp
.text$mn:00000A55                 pop     ebp
.text$mn:00000A56                 retn
.text$mn:00000A56 ??1?$_String_val@U?$_Simple_types@D@std@@@std@@QAE@XZ endp
.text$mn:00000A56
.text$mn:00000A56 ; ---------------------------------------------------------------------------
.text$mn:00000A57                 align 4
.text$mn:00000A57 _text$mn        ends
.text$mn:00000A57
.text$x:00000A58 ; ===========================================================================
.text$x:00000A58
.text$x:00000A58 ; Segment type: Pure code
.text$x:00000A58 ; Segment permissions: Read/Execute
.text$x:00000A58 _text$x         segment para public 'CODE' use32
.text$x:00000A58                 assume cs:_text$x
.text$x:00000A58                 ;org 0A58h
.text$x:00000A58 ; COMDAT (pick associative to section at A0C)
.text$x:00000A58                 assume es:nothing, ss:nothing, ds:_xdata$x, fs:nothing, gs:nothing
.text$x:00000A58
.text$x:00000A58 ; =============== S U B R O U T I N E =======================================
.text$x:00000A58
.text$x:00000A58
.text$x:00000A58 __unwindfunclet$??1?$_String_val@U?$_Simple_types@D@std@@@std@@QAE@XZ$0 proc near
.text$x:00000A58                                         ; DATA XREF: .xdata$x:00001F88o
.text$x:00000A58                 mov     ecx, [ebp-10h]  ; this
.text$x:00000A5B                 jmp     ??1_Container_base12@std@@QAE@XZ ; std::_Container_base12::~_Container_base12(void)
.text$x:00000A5B __unwindfunclet$??1?$_String_val@U?$_Simple_types@D@std@@@std@@QAE@XZ$0 endp
.text$x:00000A5B
.text$x:00000A60
.text$x:00000A60 ; =============== S U B R O U T I N E =======================================
.text$x:00000A60
.text$x:00000A60
.text$x:00000A60 __ehhandler$??1?$_String_val@U?$_Simple_types@D@std@@@std@@QAE@XZ proc near
.text$x:00000A60                                         ; DATA XREF: std::_String_val<std::_Simple_types<char>>::~_String_val<std::_Simple_types<char>>(void)+5o
.text$x:00000A60
.text$x:00000A60 arg_4           = dword ptr  8
.text$x:00000A60
.text$x:00000A60                 mov     edx, [esp+arg_4]
.text$x:00000A64                 lea     eax, [edx+0Ch]
.text$x:00000A67                 mov     ecx, [edx-8]
.text$x:00000A6A                 xor     ecx, eax
.text$x:00000A6C                 call    @__security_check_cookie@4 ; __security_check_cookie(x)
.text$x:00000A71                 mov     eax, offset __ehfuncinfo$??1?$_String_val@U?$_Simple_types@D@std@@@std@@QAE@XZ
.text$x:00000A76                 jmp     ___CxxFrameHandler3
.text$x:00000A76 __ehhandler$??1?$_String_val@U?$_Simple_types@D@std@@@std@@QAE@XZ endp
.text$x:00000A76
.text$x:00000A76 ; ---------------------------------------------------------------------------
.text$x:00000A7B                 align 4
.text$x:00000A7B _text$x         ends
.text$x:00000A7B
.text$mn:00000A7C ; ===========================================================================
.text$mn:00000A7C
.text$mn:00000A7C ; Segment type: Pure code
.text$mn:00000A7C ; Segment permissions: Read/Execute
.text$mn:00000A7C _text$mn        segment para public 'CODE' use32
.text$mn:00000A7C                 assume cs:_text$mn
.text$mn:00000A7C                 ;org 0A7Ch
.text$mn:00000A7C ; COMDAT (pick any)
.text$mn:00000A7C                 assume es:nothing, ss:nothing, ds:_xdata$x, fs:nothing, gs:nothing
.text$mn:00000A7C
.text$mn:00000A7C ; =============== S U B R O U T I N E =======================================
.text$mn:00000A7C
.text$mn:00000A7C ; Attributes: bp-based frame
.text$mn:00000A7C
.text$mn:00000A7C ; public: __thiscall std::basic_string<char, struct std::char_traits<char>, class std::allocator<char>>::~basic_string<char, struct std::char_traits<char>, class std::allocator<char>>(void)
.text$mn:00000A7C                 public ??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ
.text$mn:00000A7C ??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ proc near
.text$mn:00000A7C                                         ; CODE XREF: __unwindfunclet$?message@_Generic_error_category@std@@UBE?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@2@H@Z$0+13j
.text$mn:00000A7C                                         ; __unwindfunclet$?message@_Iostream_error_category@std@@UBE?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@2@H@Z$0+13j ...
.text$mn:00000A7C
.text$mn:00000A7C var_10          = dword ptr -10h
.text$mn:00000A7C var_C           = dword ptr -0Ch
.text$mn:00000A7C var_4           = dword ptr -4
.text$mn:00000A7C
.text$mn:00000A7C                 push    ebp
.text$mn:00000A7D                 mov     ebp, esp
.text$mn:00000A7F                 push    0FFFFFFFFh
.text$mn:00000A81                 push    offset __ehhandler$??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ
.text$mn:00000A86                 mov     eax, large fs:0
.text$mn:00000A8C                 push    eax
.text$mn:00000A8D                 push    ecx
.text$mn:00000A8E                 mov     eax, dword ptr ds:___security_cookie
.text$mn:00000A93                 xor     eax, ebp
.text$mn:00000A95                 push    eax
.text$mn:00000A96                 lea     eax, [ebp+var_C]
.text$mn:00000A99                 mov     large fs:0, eax
.text$mn:00000A9F                 mov     [ebp+var_10], ecx
.text$mn:00000AA2                 mov     [ebp+var_4], 0
.text$mn:00000AA9                 push    0               ; Size
.text$mn:00000AAB                 push    1               ; char
.text$mn:00000AAD                 mov     ecx, [ebp+var_10]
.text$mn:00000AB0                 call    ?_Tidy@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEX_NI@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char>>::_Tidy(bool,uint)
.text$mn:00000AB5                 mov     [ebp+var_4], 0FFFFFFFFh
.text$mn:00000ABC                 mov     ecx, [ebp+var_10]
.text$mn:00000ABF                 call    ??1?$_String_alloc@$0A@U?$_String_base_types@DV?$allocator@D@std@@@std@@@std@@QAE@XZ ; std::_String_alloc<0,std::_String_base_types<char,std::allocator<char>>>::~_String_alloc<0,std::_String_base_types<char,std::allocator<char>>>(void)
.text$mn:00000AC4                 mov     ecx, [ebp+var_C]
.text$mn:00000AC7                 mov     large fs:0, ecx
.text$mn:00000ACE                 pop     ecx
.text$mn:00000ACF                 mov     esp, ebp
.text$mn:00000AD1                 pop     ebp
.text$mn:00000AD2                 retn
.text$mn:00000AD2 ??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ endp
.text$mn:00000AD2
.text$mn:00000AD2 ; ---------------------------------------------------------------------------
.text$mn:00000AD3                 align 4
.text$mn:00000AD3 _text$mn        ends
.text$mn:00000AD3
.text$x:00000AD4 ; ===========================================================================
.text$x:00000AD4
.text$x:00000AD4 ; Segment type: Pure code
.text$x:00000AD4 ; Segment permissions: Read/Execute
.text$x:00000AD4 _text$x         segment para public 'CODE' use32
.text$x:00000AD4                 assume cs:_text$x
.text$x:00000AD4                 ;org 0AD4h
.text$x:00000AD4 ; COMDAT (pick associative to section at A7C)
.text$x:00000AD4                 assume es:nothing, ss:nothing, ds:_xdata$x, fs:nothing, gs:nothing
.text$x:00000AD4
.text$x:00000AD4 ; =============== S U B R O U T I N E =======================================
.text$x:00000AD4
.text$x:00000AD4
.text$x:00000AD4 __unwindfunclet$??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ$0 proc near
.text$x:00000AD4                                         ; DATA XREF: .xdata$x:00002038o
.text$x:00000AD4                 mov     ecx, [ebp-10h]
.text$x:00000AD7                 jmp     ??1?$_String_alloc@$0A@U?$_String_base_types@DV?$allocator@D@std@@@std@@@std@@QAE@XZ ; std::_String_alloc<0,std::_String_base_types<char,std::allocator<char>>>::~_String_alloc<0,std::_String_base_types<char,std::allocator<char>>>(void)
.text$x:00000AD7 __unwindfunclet$??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ$0 endp
.text$x:00000AD7
.text$x:00000ADC
.text$x:00000ADC ; =============== S U B R O U T I N E =======================================
.text$x:00000ADC
.text$x:00000ADC
.text$x:00000ADC __ehhandler$??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ proc near
.text$x:00000ADC                                         ; DATA XREF: std::basic_string<char,std::char_traits<char>,std::allocator<char>>::~basic_string<char,std::char_traits<char>,std::allocator<char>>(void)+5o
.text$x:00000ADC
.text$x:00000ADC arg_4           = dword ptr  8
.text$x:00000ADC
.text$x:00000ADC                 mov     edx, [esp+arg_4]
.text$x:00000AE0                 lea     eax, [edx+0Ch]
.text$x:00000AE3                 mov     ecx, [edx-8]
.text$x:00000AE6                 xor     ecx, eax
.text$x:00000AE8                 call    @__security_check_cookie@4 ; __security_check_cookie(x)
.text$x:00000AED                 mov     eax, offset __ehfuncinfo$??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ
.text$x:00000AF2                 jmp     ___CxxFrameHandler3
.text$x:00000AF2 __ehhandler$??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ endp
.text$x:00000AF2
.text$x:00000AF2 ; ---------------------------------------------------------------------------
.text$x:00000AF7                 align 4
.text$x:00000AF7 _text$x         ends
.text$x:00000AF7
.text$mn:00000AF8 ; ===========================================================================
.text$mn:00000AF8
.text$mn:00000AF8 ; Segment type: Pure code
.text$mn:00000AF8 ; Segment permissions: Read/Execute
.text$mn:00000AF8 _text$mn        segment para public 'CODE' use32
.text$mn:00000AF8                 assume cs:_text$mn
.text$mn:00000AF8                 ;org 0AF8h
.text$mn:00000AF8 ; COMDAT (pick any)
.text$mn:00000AF8                 assume es:nothing, ss:nothing, ds:_xdata$x, fs:nothing, gs:nothing
.text$mn:00000AF8
.text$mn:00000AF8 ; =============== S U B R O U T I N E =======================================
.text$mn:00000AF8
.text$mn:00000AF8 ; Attributes: bp-based frame
.text$mn:00000AF8
.text$mn:00000AF8 ; _DWORD __thiscall std::_Container_base12::~_Container_base12(std::_Container_base12 *__hidden this)
.text$mn:00000AF8                 public ??1_Container_base12@std@@QAE@XZ
.text$mn:00000AF8 ??1_Container_base12@std@@QAE@XZ proc near
.text$mn:00000AF8                                         ; CODE XREF: __unwindfunclet$??0?$_String_val@U?$_Simple_types@D@std@@@std@@QAE@XZ$0+3j
.text$mn:00000AF8                                         ; std::_String_val<std::_Simple_types<char>>::~_String_val<std::_Simple_types<char>>(void)+37p ...
.text$mn:00000AF8
.text$mn:00000AF8 var_4           = dword ptr -4
.text$mn:00000AF8
.text$mn:00000AF8                 push    ebp
.text$mn:00000AF9                 mov     ebp, esp
.text$mn:00000AFB                 push    ecx
.text$mn:00000AFC                 mov     [ebp+var_4], ecx
.text$mn:00000AFF                 mov     ecx, [ebp+var_4] ; this
.text$mn:00000B02                 call    ?_Orphan_all@_Container_base12@std@@QAEXXZ ; std::_Container_base12::_Orphan_all(void)
.text$mn:00000B07                 mov     esp, ebp
.text$mn:00000B09                 pop     ebp
.text$mn:00000B0A                 retn
.text$mn:00000B0A ??1_Container_base12@std@@QAE@XZ endp
.text$mn:00000B0A
.text$mn:00000B0A ; ---------------------------------------------------------------------------
.text$mn:00000B0B                 align 4
.text$mn:00000B0B _text$mn        ends
.text$mn:00000B0B
.text$mn:00000B0C ; ===========================================================================
.text$mn:00000B0C
.text$mn:00000B0C ; Segment type: Pure code
.text$mn:00000B0C ; Segment permissions: Read/Execute
.text$mn:00000B0C _text$mn        segment para public 'CODE' use32
.text$mn:00000B0C                 assume cs:_text$mn
.text$mn:00000B0C                 ;org 0B0Ch
.text$mn:00000B0C ; COMDAT (pick any)
.text$mn:00000B0C                 assume es:nothing, ss:nothing, ds:_xdata$x, fs:nothing, gs:nothing
.text$mn:00000B0C
.text$mn:00000B0C ; =============== S U B R O U T I N E =======================================
.text$mn:00000B0C
.text$mn:00000B0C ; Attributes: bp-based frame
.text$mn:00000B0C
.text$mn:00000B0C ; _DWORD __thiscall std::_Generic_error_category::~_Generic_error_category(std::_Generic_error_category *__hidden this)
.text$mn:00000B0C                 public ??1_Generic_error_category@std@@UAE@XZ
.text$mn:00000B0C ??1_Generic_error_category@std@@UAE@XZ proc near
.text$mn:00000B0C                                         ; CODE XREF: __unwindfunclet$??0_Iostream_error_category@std@@QAE@XZ$0+3j
.text$mn:00000B0C                                         ; __unwindfunclet$??0_System_error_category@std@@QAE@XZ$0+3j ...
.text$mn:00000B0C
.text$mn:00000B0C var_10          = dword ptr -10h
.text$mn:00000B0C var_C           = dword ptr -0Ch
.text$mn:00000B0C var_4           = dword ptr -4
.text$mn:00000B0C
.text$mn:00000B0C                 push    ebp
.text$mn:00000B0D                 mov     ebp, esp
.text$mn:00000B0F                 push    0FFFFFFFFh
.text$mn:00000B11                 push    offset __ehhandler$??1_Generic_error_category@std@@UAE@XZ
.text$mn:00000B16                 mov     eax, large fs:0
.text$mn:00000B1C                 push    eax
.text$mn:00000B1D                 push    ecx
.text$mn:00000B1E                 mov     eax, dword ptr ds:___security_cookie
.text$mn:00000B23                 xor     eax, ebp
.text$mn:00000B25                 push    eax
.text$mn:00000B26                 lea     eax, [ebp+var_C]
.text$mn:00000B29                 mov     large fs:0, eax
.text$mn:00000B2F                 mov     [ebp+var_10], ecx
.text$mn:00000B32                 mov     [ebp+var_4], 0
.text$mn:00000B39                 mov     [ebp+var_4], 0FFFFFFFFh
.text$mn:00000B40                 mov     ecx, [ebp+var_10] ; this
.text$mn:00000B43                 call    ??1error_category@std@@UAE@XZ ; std::error_category::~error_category(void)
.text$mn:00000B48                 mov     ecx, [ebp+var_C]
.text$mn:00000B4B                 mov     large fs:0, ecx
.text$mn:00000B52                 pop     ecx
.text$mn:00000B53                 mov     esp, ebp
.text$mn:00000B55                 pop     ebp
.text$mn:00000B56                 retn
.text$mn:00000B56 ??1_Generic_error_category@std@@UAE@XZ endp
.text$mn:00000B56
.text$mn:00000B56 ; ---------------------------------------------------------------------------
.text$mn:00000B57                 align 4
.text$mn:00000B57 _text$mn        ends
.text$mn:00000B57
.text$x:00000B58 ; ===========================================================================
.text$x:00000B58
.text$x:00000B58 ; Segment type: Pure code
.text$x:00000B58 ; Segment permissions: Read/Execute
.text$x:00000B58 _text$x         segment para public 'CODE' use32
.text$x:00000B58                 assume cs:_text$x
.text$x:00000B58                 ;org 0B58h
.text$x:00000B58 ; COMDAT (pick associative to section at B0C)
.text$x:00000B58                 assume es:nothing, ss:nothing, ds:_xdata$x, fs:nothing, gs:nothing
.text$x:00000B58
.text$x:00000B58 ; =============== S U B R O U T I N E =======================================
.text$x:00000B58
.text$x:00000B58
.text$x:00000B58 __unwindfunclet$??1_Generic_error_category@std@@UAE@XZ$0 proc near
.text$x:00000B58                                         ; DATA XREF: .xdata$x:00002148o
.text$x:00000B58                 mov     ecx, [ebp-10h]  ; this
.text$x:00000B5B                 jmp     ??1error_category@std@@UAE@XZ ; std::error_category::~error_category(void)
.text$x:00000B5B __unwindfunclet$??1_Generic_error_category@std@@UAE@XZ$0 endp
.text$x:00000B5B
.text$x:00000B60
.text$x:00000B60 ; =============== S U B R O U T I N E =======================================
.text$x:00000B60
.text$x:00000B60
.text$x:00000B60 __ehhandler$??1_Generic_error_category@std@@UAE@XZ proc near
.text$x:00000B60                                         ; DATA XREF: std::_Generic_error_category::~_Generic_error_category(void)+5o
.text$x:00000B60
.text$x:00000B60 arg_4           = dword ptr  8
.text$x:00000B60
.text$x:00000B60                 mov     edx, [esp+arg_4]
.text$x:00000B64                 lea     eax, [edx+0Ch]
.text$x:00000B67                 mov     ecx, [edx-8]
.text$x:00000B6A                 xor     ecx, eax
.text$x:00000B6C                 call    @__security_check_cookie@4 ; __security_check_cookie(x)
.text$x:00000B71                 mov     eax, offset __ehfuncinfo$??1_Generic_error_category@std@@UAE@XZ
.text$x:00000B76                 jmp     ___CxxFrameHandler3
.text$x:00000B76 __ehhandler$??1_Generic_error_category@std@@UAE@XZ endp
.text$x:00000B76
.text$x:00000B76 ; ---------------------------------------------------------------------------
.text$x:00000B7B                 align 4
.text$x:00000B7B _text$x         ends
.text$x:00000B7B
.text$mn:00000B7C ; ===========================================================================
.text$mn:00000B7C
.text$mn:00000B7C ; Segment type: Pure code
.text$mn:00000B7C ; Segment permissions: Read/Execute
.text$mn:00000B7C _text$mn        segment para public 'CODE' use32
.text$mn:00000B7C                 assume cs:_text$mn
.text$mn:00000B7C                 ;org 0B7Ch
.text$mn:00000B7C ; COMDAT (pick any)
.text$mn:00000B7C                 assume es:nothing, ss:nothing, ds:_xdata$x, fs:nothing, gs:nothing
.text$mn:00000B7C
.text$mn:00000B7C ; =============== S U B R O U T I N E =======================================
.text$mn:00000B7C
.text$mn:00000B7C ; Attributes: bp-based frame
.text$mn:00000B7C
.text$mn:00000B7C ; _DWORD __thiscall std::_Iostream_error_category::~_Iostream_error_category(std::_Iostream_error_category *__hidden this)
.text$mn:00000B7C                 public ??1_Iostream_error_category@std@@UAE@XZ
.text$mn:00000B7C ??1_Iostream_error_category@std@@UAE@XZ proc near
.text$mn:00000B7C                                         ; CODE XREF: std::_Iostream_error_category::`scalar deleting destructor'(uint)+Ap
.text$mn:00000B7C                                         ; `dynamic atexit destructor for 'std::_Iostream_error_category std::_Error_objects<int>::_Iostream_object''(void)+8p
.text$mn:00000B7C
.text$mn:00000B7C var_10          = dword ptr -10h
.text$mn:00000B7C var_C           = dword ptr -0Ch
.text$mn:00000B7C var_4           = dword ptr -4
.text$mn:00000B7C
.text$mn:00000B7C                 push    ebp
.text$mn:00000B7D                 mov     ebp, esp
.text$mn:00000B7F                 push    0FFFFFFFFh
.text$mn:00000B81                 push    offset __ehhandler$??1_Iostream_error_category@std@@UAE@XZ
.text$mn:00000B86                 mov     eax, large fs:0
.text$mn:00000B8C                 push    eax
.text$mn:00000B8D                 push    ecx
.text$mn:00000B8E                 mov     eax, dword ptr ds:___security_cookie
.text$mn:00000B93                 xor     eax, ebp
.text$mn:00000B95                 push    eax
.text$mn:00000B96                 lea     eax, [ebp+var_C]
.text$mn:00000B99                 mov     large fs:0, eax
.text$mn:00000B9F                 mov     [ebp+var_10], ecx
.text$mn:00000BA2                 mov     [ebp+var_4], 0
.text$mn:00000BA9                 mov     [ebp+var_4], 0FFFFFFFFh
.text$mn:00000BB0                 mov     ecx, [ebp+var_10] ; this
.text$mn:00000BB3                 call    ??1_Generic_error_category@std@@UAE@XZ ; std::_Generic_error_category::~_Generic_error_category(void)
.text$mn:00000BB8                 mov     ecx, [ebp+var_C]
.text$mn:00000BBB                 mov     large fs:0, ecx
.text$mn:00000BC2                 pop     ecx
.text$mn:00000BC3                 mov     esp, ebp
.text$mn:00000BC5                 pop     ebp
.text$mn:00000BC6                 retn
.text$mn:00000BC6 ??1_Iostream_error_category@std@@UAE@XZ endp
.text$mn:00000BC6
.text$mn:00000BC6 ; ---------------------------------------------------------------------------
.text$mn:00000BC7                 align 4
.text$mn:00000BC7 _text$mn        ends
.text$mn:00000BC7
.text$x:00000BC8 ; ===========================================================================
.text$x:00000BC8
.text$x:00000BC8 ; Segment type: Pure code
.text$x:00000BC8 ; Segment permissions: Read/Execute
.text$x:00000BC8 _text$x         segment para public 'CODE' use32
.text$x:00000BC8                 assume cs:_text$x
.text$x:00000BC8                 ;org 0BC8h
.text$x:00000BC8 ; COMDAT (pick associative to section at B7C)
.text$x:00000BC8                 assume es:nothing, ss:nothing, ds:_xdata$x, fs:nothing, gs:nothing
.text$x:00000BC8
.text$x:00000BC8 ; =============== S U B R O U T I N E =======================================
.text$x:00000BC8
.text$x:00000BC8
.text$x:00000BC8 __unwindfunclet$??1_Iostream_error_category@std@@UAE@XZ$0 proc near
.text$x:00000BC8                                         ; DATA XREF: .xdata$x:000021CCo
.text$x:00000BC8                 mov     ecx, [ebp-10h]  ; this
.text$x:00000BCB                 jmp     ??1_Generic_error_category@std@@UAE@XZ ; std::_Generic_error_category::~_Generic_error_category(void)
.text$x:00000BCB __unwindfunclet$??1_Iostream_error_category@std@@UAE@XZ$0 endp
.text$x:00000BCB
.text$x:00000BD0
.text$x:00000BD0 ; =============== S U B R O U T I N E =======================================
.text$x:00000BD0
.text$x:00000BD0
.text$x:00000BD0 __ehhandler$??1_Iostream_error_category@std@@UAE@XZ proc near
.text$x:00000BD0                                         ; DATA XREF: std::_Iostream_error_category::~_Iostream_error_category(void)+5o
.text$x:00000BD0
.text$x:00000BD0 arg_4           = dword ptr  8
.text$x:00000BD0
.text$x:00000BD0                 mov     edx, [esp+arg_4]
.text$x:00000BD4                 lea     eax, [edx+0Ch]
.text$x:00000BD7                 mov     ecx, [edx-8]
.text$x:00000BDA                 xor     ecx, eax
.text$x:00000BDC                 call    @__security_check_cookie@4 ; __security_check_cookie(x)
.text$x:00000BE1                 mov     eax, offset __ehfuncinfo$??1_Iostream_error_category@std@@UAE@XZ
.text$x:00000BE6                 jmp     ___CxxFrameHandler3
.text$x:00000BE6 __ehhandler$??1_Iostream_error_category@std@@UAE@XZ endp
.text$x:00000BE6
.text$x:00000BE6 ; ---------------------------------------------------------------------------
.text$x:00000BEB                 align 4
.text$x:00000BEB _text$x         ends
.text$x:00000BEB
.text$mn:00000BEC ; ===========================================================================
.text$mn:00000BEC
.text$mn:00000BEC ; Segment type: Pure code
.text$mn:00000BEC ; Segment permissions: Read/Execute
.text$mn:00000BEC _text$mn        segment para public 'CODE' use32
.text$mn:00000BEC                 assume cs:_text$mn
.text$mn:00000BEC                 ;org 0BECh
.text$mn:00000BEC ; COMDAT (pick any)
.text$mn:00000BEC                 assume es:nothing, ss:nothing, ds:_xdata$x, fs:nothing, gs:nothing
.text$mn:00000BEC
.text$mn:00000BEC ; =============== S U B R O U T I N E =======================================
.text$mn:00000BEC
.text$mn:00000BEC ; Attributes: bp-based frame
.text$mn:00000BEC
.text$mn:00000BEC ; _DWORD __thiscall std::_System_error_category::~_System_error_category(std::_System_error_category *__hidden this)
.text$mn:00000BEC                 public ??1_System_error_category@std@@UAE@XZ
.text$mn:00000BEC ??1_System_error_category@std@@UAE@XZ proc near
.text$mn:00000BEC                                         ; CODE XREF: std::_System_error_category::`scalar deleting destructor'(uint)+Ap
.text$mn:00000BEC                                         ; `dynamic atexit destructor for 'std::_System_error_category std::_Error_objects<int>::_System_object''(void)+8p
.text$mn:00000BEC
.text$mn:00000BEC var_10          = dword ptr -10h
.text$mn:00000BEC var_C           = dword ptr -0Ch
.text$mn:00000BEC var_4           = dword ptr -4
.text$mn:00000BEC
.text$mn:00000BEC                 push    ebp
.text$mn:00000BED                 mov     ebp, esp
.text$mn:00000BEF                 push    0FFFFFFFFh
.text$mn:00000BF1                 push    offset __ehhandler$??1_System_error_category@std@@UAE@XZ
.text$mn:00000BF6                 mov     eax, large fs:0
.text$mn:00000BFC                 push    eax
.text$mn:00000BFD                 push    ecx
.text$mn:00000BFE                 mov     eax, dword ptr ds:___security_cookie
.text$mn:00000C03                 xor     eax, ebp
.text$mn:00000C05                 push    eax
.text$mn:00000C06                 lea     eax, [ebp+var_C]
.text$mn:00000C09                 mov     large fs:0, eax
.text$mn:00000C0F                 mov     [ebp+var_10], ecx
.text$mn:00000C12                 mov     [ebp+var_4], 0
.text$mn:00000C19                 mov     [ebp+var_4], 0FFFFFFFFh
.text$mn:00000C20                 mov     ecx, [ebp+var_10] ; this
.text$mn:00000C23                 call    ??1_Generic_error_category@std@@UAE@XZ ; std::_Generic_error_category::~_Generic_error_category(void)
.text$mn:00000C28                 mov     ecx, [ebp+var_C]
.text$mn:00000C2B                 mov     large fs:0, ecx
.text$mn:00000C32                 pop     ecx
.text$mn:00000C33                 mov     esp, ebp
.text$mn:00000C35                 pop     ebp
.text$mn:00000C36                 retn
.text$mn:00000C36 ??1_System_error_category@std@@UAE@XZ endp
.text$mn:00000C36
.text$mn:00000C36 ; ---------------------------------------------------------------------------
.text$mn:00000C37                 align 4
.text$mn:00000C37 _text$mn        ends
.text$mn:00000C37
.text$x:00000C38 ; ===========================================================================
.text$x:00000C38
.text$x:00000C38 ; Segment type: Pure code
.text$x:00000C38 ; Segment permissions: Read/Execute
.text$x:00000C38 _text$x         segment para public 'CODE' use32
.text$x:00000C38                 assume cs:_text$x
.text$x:00000C38                 ;org 0C38h
.text$x:00000C38 ; COMDAT (pick associative to section at BEC)
.text$x:00000C38                 assume es:nothing, ss:nothing, ds:_xdata$x, fs:nothing, gs:nothing
.text$x:00000C38
.text$x:00000C38 ; =============== S U B R O U T I N E =======================================
.text$x:00000C38
.text$x:00000C38
.text$x:00000C38 __unwindfunclet$??1_System_error_category@std@@UAE@XZ$0 proc near
.text$x:00000C38                                         ; DATA XREF: .xdata$x:00002250o
.text$x:00000C38                 mov     ecx, [ebp-10h]  ; this
.text$x:00000C3B                 jmp     ??1_Generic_error_category@std@@UAE@XZ ; std::_Generic_error_category::~_Generic_error_category(void)
.text$x:00000C3B __unwindfunclet$??1_System_error_category@std@@UAE@XZ$0 endp
.text$x:00000C3B
.text$x:00000C40
.text$x:00000C40 ; =============== S U B R O U T I N E =======================================
.text$x:00000C40
.text$x:00000C40
.text$x:00000C40 __ehhandler$??1_System_error_category@std@@UAE@XZ proc near
.text$x:00000C40                                         ; DATA XREF: std::_System_error_category::~_System_error_category(void)+5o
.text$x:00000C40
.text$x:00000C40 arg_4           = dword ptr  8
.text$x:00000C40
.text$x:00000C40                 mov     edx, [esp+arg_4]
.text$x:00000C44                 lea     eax, [edx+0Ch]
.text$x:00000C47                 mov     ecx, [edx-8]
.text$x:00000C4A                 xor     ecx, eax
.text$x:00000C4C                 call    @__security_check_cookie@4 ; __security_check_cookie(x)
.text$x:00000C51                 mov     eax, offset __ehfuncinfo$??1_System_error_category@std@@UAE@XZ
.text$x:00000C56                 jmp     ___CxxFrameHandler3
.text$x:00000C56 __ehhandler$??1_System_error_category@std@@UAE@XZ endp
.text$x:00000C56
.text$x:00000C56 ; ---------------------------------------------------------------------------
.text$x:00000C5B                 align 4
.text$x:00000C5B _text$x         ends
.text$x:00000C5B
.text$mn:00000C5C ; ===========================================================================
.text$mn:00000C5C
.text$mn:00000C5C ; Segment type: Pure code
.text$mn:00000C5C ; Segment permissions: Read/Execute
.text$mn:00000C5C _text$mn        segment para public 'CODE' use32
.text$mn:00000C5C                 assume cs:_text$mn
.text$mn:00000C5C                 ;org 0C5Ch
.text$mn:00000C5C ; COMDAT (pick any)
.text$mn:00000C5C                 assume es:nothing, ss:nothing, ds:_xdata$x, fs:nothing, gs:nothing
.text$mn:00000C5C
.text$mn:00000C5C ; =============== S U B R O U T I N E =======================================
.text$mn:00000C5C
.text$mn:00000C5C ; Attributes: bp-based frame
.text$mn:00000C5C
.text$mn:00000C5C ; _DWORD __thiscall std::error_category::~error_category(std::error_category *__hidden this)
.text$mn:00000C5C                 public ??1error_category@std@@UAE@XZ
.text$mn:00000C5C ??1error_category@std@@UAE@XZ proc near ; CODE XREF: __unwindfunclet$??0_Generic_error_category@std@@QAE@XZ$0+3j
.text$mn:00000C5C                                         ; std::_Generic_error_category::~_Generic_error_category(void)+37p ...
.text$mn:00000C5C
.text$mn:00000C5C var_4           = dword ptr -4
.text$mn:00000C5C
.text$mn:00000C5C                 push    ebp
.text$mn:00000C5D                 mov     ebp, esp
.text$mn:00000C5F                 push    ecx
.text$mn:00000C60                 mov     [ebp+var_4], ecx
.text$mn:00000C63                 mov     eax, [ebp+var_4]
.text$mn:00000C66                 mov     dword ptr [eax], offset ??_7error_category@std@@6B@ ; const std::error_category::`vftable'
.text$mn:00000C6C                 mov     esp, ebp
.text$mn:00000C6E                 pop     ebp
.text$mn:00000C6F                 retn
.text$mn:00000C6F ??1error_category@std@@UAE@XZ endp
.text$mn:00000C6F
.text$mn:00000C6F _text$mn        ends
.text$mn:00000C6F
.text$mn:00000C70 ; ===========================================================================
.text$mn:00000C70
.text$mn:00000C70 ; Segment type: Pure code
.text$mn:00000C70 ; Segment permissions: Read/Execute
.text$mn:00000C70 _text$mn        segment para public 'CODE' use32
.text$mn:00000C70                 assume cs:_text$mn
.text$mn:00000C70                 ;org 0C70h
.text$mn:00000C70 ; COMDAT (pick any)
.text$mn:00000C70                 assume es:nothing, ss:nothing, ds:_xdata$x, fs:nothing, gs:nothing
.text$mn:00000C70
.text$mn:00000C70 ; =============== S U B R O U T I N E =======================================
.text$mn:00000C70
.text$mn:00000C70 ; Attributes: bp-based frame
.text$mn:00000C70
.text$mn:00000C70 ; void *__cdecl operator new(unsigned int, void *)
.text$mn:00000C70                 public ??2@YAPAXIPAX@Z
.text$mn:00000C70 ??2@YAPAXIPAX@Z proc near               ; CODE XREF: std::allocator<char>::construct<char *,char * &>(char * *,char * &)+2Ep
.text$mn:00000C70                                         ; std::allocator<std::_Container_proxy>::construct<std::_Container_proxy,std::_Container_proxy>(std::_Container_proxy *,std::_Container_proxy &&)+2Ep
.text$mn:00000C70
.text$mn:00000C70 arg_4           = dword ptr  0Ch
.text$mn:00000C70
.text$mn:00000C70                 push    ebp
.text$mn:00000C71                 mov     ebp, esp
.text$mn:00000C73                 mov     eax, [ebp+arg_4]
.text$mn:00000C76                 pop     ebp
.text$mn:00000C77                 retn
.text$mn:00000C77 ??2@YAPAXIPAX@Z endp
.text$mn:00000C77
.text$mn:00000C77 _text$mn        ends
.text$mn:00000C77
.text$mn:00000C78 ; ===========================================================================
.text$mn:00000C78
.text$mn:00000C78 ; Segment type: Pure code
.text$mn:00000C78 ; Segment permissions: Read/Execute
.text$mn:00000C78 _text$mn        segment para public 'CODE' use32
.text$mn:00000C78                 assume cs:_text$mn
.text$mn:00000C78                 ;org 0C78h
.text$mn:00000C78 ; COMDAT (pick any)
.text$mn:00000C78                 assume es:nothing, ss:nothing, ds:_xdata$x, fs:nothing, gs:nothing
.text$mn:00000C78
.text$mn:00000C78 ; =============== S U B R O U T I N E =======================================
.text$mn:00000C78
.text$mn:00000C78 ; Attributes: bp-based frame
.text$mn:00000C78
.text$mn:00000C78 ; void __cdecl operator delete(void *)
.text$mn:00000C78                 public ??3@YAXPAX0@Z
.text$mn:00000C78 ??3@YAXPAX0@Z   proc near               ; CODE XREF: __unwindfunclet$??$construct@PADAAPAD@?$allocator@D@std@@QAEXPAPADAAPAD@Z$0+8p
.text$mn:00000C78                                         ; __unwindfunclet$??$construct@U_Container_proxy@std@@U12@@?$allocator@U_Container_proxy@std@@@std@@QAEXPAU_Container_proxy@1@$$QAU21@@Z$0+8p
.text$mn:00000C78                 push    ebp
.text$mn:00000C79                 mov     ebp, esp
.text$mn:00000C7B                 pop     ebp
.text$mn:00000C7C                 retn
.text$mn:00000C7C ??3@YAXPAX0@Z   endp
.text$mn:00000C7C
.text$mn:00000C7C ; ---------------------------------------------------------------------------
.text$mn:00000C7D                 align 10h
.text$mn:00000C7D _text$mn        ends
.text$mn:00000C7D
.text$mn:00000C80 ; ===========================================================================
.text$mn:00000C80
.text$mn:00000C80 ; Segment type: Pure code
.text$mn:00000C80 ; Segment permissions: Read/Execute
.text$mn:00000C80 _text$mn        segment para public 'CODE' use32
.text$mn:00000C80                 assume cs:_text$mn
.text$mn:00000C80                 ;org 0C80h
.text$mn:00000C80 ; COMDAT (pick any)
.text$mn:00000C80                 assume es:nothing, ss:nothing, ds:_xdata$x, fs:nothing, gs:nothing
.text$mn:00000C80
.text$mn:00000C80 ; =============== S U B R O U T I N E =======================================
.text$mn:00000C80
.text$mn:00000C80 ; Attributes: bp-based frame
.text$mn:00000C80
.text$mn:00000C80 ; public: bool __thiscall std::error_category::operator==(class std::error_category const &)const
.text$mn:00000C80                 public ??8error_category@std@@QBE_NABV01@@Z
.text$mn:00000C80 ??8error_category@std@@QBE_NABV01@@Z proc near
.text$mn:00000C80                                         ; CODE XREF: std::error_condition::operator==(std::error_condition const &)+1Dp
.text$mn:00000C80                                         ; std::error_category::equivalent(std::error_code const &,int)+15p
.text$mn:00000C80
.text$mn:00000C80 var_8           = dword ptr -8
.text$mn:00000C80 var_4           = dword ptr -4
.text$mn:00000C80 arg_0           = dword ptr  8
.text$mn:00000C80
.text$mn:00000C80                 push    ebp
.text$mn:00000C81                 mov     ebp, esp
.text$mn:00000C83                 sub     esp, 8
.text$mn:00000C86                 mov     [ebp+var_8], ecx
.text$mn:00000C89                 mov     eax, [ebp+var_8]
.text$mn:00000C8C                 cmp     eax, [ebp+arg_0]
.text$mn:00000C8F                 jnz     short loc_C9A
.text$mn:00000C91                 mov     [ebp+var_4], 1
.text$mn:00000C98                 jmp     short loc_CA1
.text$mn:00000C9A ; ---------------------------------------------------------------------------
.text$mn:00000C9A
.text$mn:00000C9A loc_C9A:                                ; CODE XREF: std::error_category::operator==(std::error_category const &)+Fj
.text$mn:00000C9A                 mov     [ebp+var_4], 0
.text$mn:00000CA1
.text$mn:00000CA1 loc_CA1:                                ; CODE XREF: std::error_category::operator==(std::error_category const &)+18j
.text$mn:00000CA1                 mov     al, byte ptr [ebp+var_4]
.text$mn:00000CA4                 mov     esp, ebp
.text$mn:00000CA6                 pop     ebp
.text$mn:00000CA7                 retn    4
.text$mn:00000CA7 ??8error_category@std@@QBE_NABV01@@Z endp
.text$mn:00000CA7
.text$mn:00000CA7 ; ---------------------------------------------------------------------------
.text$mn:00000CAA                 align 4
.text$mn:00000CAA _text$mn        ends
.text$mn:00000CAA
.text$mn:00000CAC ; ===========================================================================
.text$mn:00000CAC
.text$mn:00000CAC ; Segment type: Pure code
.text$mn:00000CAC ; Segment permissions: Read/Execute
.text$mn:00000CAC _text$mn        segment para public 'CODE' use32
.text$mn:00000CAC                 assume cs:_text$mn
.text$mn:00000CAC                 ;org 0CACh
.text$mn:00000CAC ; COMDAT (pick any)
.text$mn:00000CAC                 assume es:nothing, ss:nothing, ds:_xdata$x, fs:nothing, gs:nothing
.text$mn:00000CAC
.text$mn:00000CAC ; =============== S U B R O U T I N E =======================================
.text$mn:00000CAC
.text$mn:00000CAC ; Attributes: bp-based frame
.text$mn:00000CAC
.text$mn:00000CAC ; int __stdcall std::error_condition::operator==(std::error_condition *)
.text$mn:00000CAC                 public ??8error_condition@std@@QBE_NABV01@@Z
.text$mn:00000CAC ??8error_condition@std@@QBE_NABV01@@Z proc near
.text$mn:00000CAC                                         ; CODE XREF: std::error_category::equivalent(int,std::error_condition const &)+24p
.text$mn:00000CAC
.text$mn:00000CAC var_8           = dword ptr -8
.text$mn:00000CAC var_4           = dword ptr -4
.text$mn:00000CAC arg_0           = dword ptr  8
.text$mn:00000CAC
.text$mn:00000CAC                 push    ebp
.text$mn:00000CAD                 mov     ebp, esp
.text$mn:00000CAF                 sub     esp, 8
.text$mn:00000CB2                 push    esi
.text$mn:00000CB3                 mov     [ebp+var_4], ecx
.text$mn:00000CB6                 mov     ecx, [ebp+arg_0] ; this
.text$mn:00000CB9                 call    ?category@error_condition@std@@QBEABVerror_category@2@XZ ; std::error_condition::category(void)
.text$mn:00000CBE                 push    eax
.text$mn:00000CBF                 mov     ecx, [ebp+var_4] ; this
.text$mn:00000CC2                 call    ?category@error_condition@std@@QBEABVerror_category@2@XZ ; std::error_condition::category(void)
.text$mn:00000CC7                 mov     ecx, eax
.text$mn:00000CC9                 call    ??8error_category@std@@QBE_NABV01@@Z ; std::error_category::operator==(std::error_category const &)
.text$mn:00000CCE                 movzx   eax, al
.text$mn:00000CD1                 test    eax, eax
.text$mn:00000CD3                 jz      short loc_CF4
.text$mn:00000CD5                 mov     ecx, [ebp+var_4] ; this
.text$mn:00000CD8                 call    ?value@error_condition@std@@QBEHXZ ; std::error_condition::value(void)
.text$mn:00000CDD                 mov     esi, eax
.text$mn:00000CDF                 mov     ecx, [ebp+arg_0] ; this
.text$mn:00000CE2                 call    ?value@error_condition@std@@QBEHXZ ; std::error_condition::value(void)
.text$mn:00000CE7                 cmp     esi, eax
.text$mn:00000CE9                 jnz     short loc_CF4
.text$mn:00000CEB                 mov     [ebp+var_8], 1
.text$mn:00000CF2                 jmp     short loc_CFB
.text$mn:00000CF4 ; ---------------------------------------------------------------------------
.text$mn:00000CF4
.text$mn:00000CF4 loc_CF4:                                ; CODE XREF: std::error_condition::operator==(std::error_condition const &)+27j
.text$mn:00000CF4                                         ; std::error_condition::operator==(std::error_condition const &)+3Dj
.text$mn:00000CF4                 mov     [ebp+var_8], 0
.text$mn:00000CFB
.text$mn:00000CFB loc_CFB:                                ; CODE XREF: std::error_condition::operator==(std::error_condition const &)+46j
.text$mn:00000CFB                 mov     al, byte ptr [ebp+var_8]
.text$mn:00000CFE                 pop     esi
.text$mn:00000CFF                 mov     esp, ebp
.text$mn:00000D01                 pop     ebp
.text$mn:00000D02                 retn    4
.text$mn:00000D02 ??8error_condition@std@@QBE_NABV01@@Z endp
.text$mn:00000D02
.text$mn:00000D02 ; ---------------------------------------------------------------------------
.text$mn:00000D05                 align 4
.text$mn:00000D05 _text$mn        ends
.text$mn:00000D05
.text$mn:00000D08 ; ===========================================================================
.text$mn:00000D08
.text$mn:00000D08 ; Segment type: Pure code
.text$mn:00000D08 ; Segment permissions: Read/Execute
.text$mn:00000D08 _text$mn        segment para public 'CODE' use32
.text$mn:00000D08                 assume cs:_text$mn
.text$mn:00000D08                 ;org 0D08h
.text$mn:00000D08 ; COMDAT (pick any)
.text$mn:00000D08                 assume es:nothing, ss:nothing, ds:_xdata$x, fs:nothing, gs:nothing
.text$mn:00000D08
.text$mn:00000D08 ; =============== S U B R O U T I N E =======================================
.text$mn:00000D08
.text$mn:00000D08 ; Attributes: bp-based frame
.text$mn:00000D08
.text$mn:00000D08 ; public: struct DlgInfo & __thiscall std::vector<struct DlgInfo, class std::allocator<struct DlgInfo>>::operator[](unsigned int)
.text$mn:00000D08                 public ??A?$vector@UDlgInfo@@V?$allocator@UDlgInfo@@@std@@@std@@QAEAAUDlgInfo@@I@Z
.text$mn:00000D08 ??A?$vector@UDlgInfo@@V?$allocator@UDlgInfo@@@std@@@std@@QAEAAUDlgInfo@@I@Z proc near
.text$mn:00000D08                                         ; CODE XREF: ControlsTab::createTabs(std::vector<DlgInfo,std::allocator<DlgInfo>> &)+3Ep
.text$mn:00000D08                                         ; ControlsTab::reSizeTo(tagRECT &)+A1p ...
.text$mn:00000D08
.text$mn:00000D08 var_4           = dword ptr -4
.text$mn:00000D08 arg_0           = dword ptr  8
.text$mn:00000D08
.text$mn:00000D08                 push    ebp
.text$mn:00000D09                 mov     ebp, esp
.text$mn:00000D0B                 push    ecx
.text$mn:00000D0C                 mov     [ebp+var_4], ecx
.text$mn:00000D0F                 mov     ecx, [ebp+var_4]
.text$mn:00000D12                 call    ?size@?$vector@UDlgInfo@@V?$allocator@UDlgInfo@@@std@@@std@@QBEIXZ ; std::vector<DlgInfo,std::allocator<DlgInfo>>::size(void)
.text$mn:00000D17                 cmp     eax, [ebp+arg_0]
.text$mn:00000D1A                 ja      short loc_D84
.text$mn:00000D1C                 push    4B1h            ; unsigned int
.text$mn:00000D21                 push    offset ??_C@_1IM@EINEHPHE@?$AAC?$AA?3?$AA?2?$AAP?$AAr?$AAo?$AAg?$AAr?$AAa?$AAm?$AA?5?$AAF?$AAi?$AAl?$AAe?$AAs?$AA?5?$AA?$CI?$AAx?$AA8?$AA6?$AA?$CJ?$AA?2?$AAM?$AAi?$AAc?$AAr?$AAo?$AAs?$AAo?$AAf?$AAt@ ; "C:\\Program Files (x86)\\Microsoft Visu"...
.text$mn:00000D26                 push    offset ??_C@_1DM@LHGCHCBA@?$AAv?$AAe?$AAc?$AAt?$AAo?$AAr?$AA?5?$AAs?$AAu?$AAb?$AAs?$AAc?$AAr?$AAi?$AAp?$AAt?$AA?5?$AAo?$AAu?$AAt?$AA?5?$AAo?$AAf?$AA?5?$AAr?$AAa?$AAn?$AAg?$AAe?$AA?$AA@ ; "vector subscript out of range"
.text$mn:00000D2B                 call    ?_Debug_message@std@@YAXPB_W0I@Z ; std::_Debug_message(wchar_t const *,wchar_t const *,uint)
.text$mn:00000D30                 add     esp, 0Ch
.text$mn:00000D33                 mov     eax, offset ??_C@_0CE@OFMIGAMM@Standard?5C?$CL?$CL?5Libraries?5Out?5of?5Ra@ ; "Standard C++ Libraries Out of Range"
.text$mn:00000D38                 test    eax, eax
.text$mn:00000D3A                 jz      short loc_D40
.text$mn:00000D3C                 xor     ecx, ecx
.text$mn:00000D3E                 jnz     short loc_D66
.text$mn:00000D40
.text$mn:00000D40 loc_D40:                                ; CODE XREF: std::vector<DlgInfo,std::allocator<DlgInfo>>::operator[](uint)+32j
.text$mn:00000D40                 push    offset ??_C@_1FG@IBPIFFN@?$AA?$CC?$AAS?$AAt?$AAa?$AAn?$AAd?$AAa?$AAr?$AAd?$AA?5?$AAC?$AA?$CL?$AA?$CL?$AA?5?$AAL?$AAi?$AAb?$AAr?$AAa?$AAr?$AAi?$AAe?$AAs?$AA?5?$AAO?$AAu?$AAt?$AA?5?$AAo?$AAf?$AA?5?$AAR@ ; "\"Standard C++ Libraries Out of Range\""...
.text$mn:00000D45                 push    offset ??_C@_15GANGMFKL@?$AA?$CF?$AAs?$AA?$AA@ ; "%s"
.text$mn:00000D4A                 push    0
.text$mn:00000D4C                 push    4B2h
.text$mn:00000D51                 push    offset ??_C@_1IM@EINEHPHE@?$AAC?$AA?3?$AA?2?$AAP?$AAr?$AAo?$AAg?$AAr?$AAa?$AAm?$AA?5?$AAF?$AAi?$AAl?$AAe?$AAs?$AA?5?$AA?$CI?$AAx?$AA8?$AA6?$AA?$CJ?$AA?2?$AAM?$AAi?$AAc?$AAr?$AAo?$AAs?$AAo?$AAf?$AAt@ ; "C:\\Program Files (x86)\\Microsoft Visu"...
.text$mn:00000D56                 push    2
.text$mn:00000D58                 call    __CrtDbgReportW
.text$mn:00000D5D                 add     esp, 18h
.text$mn:00000D60                 cmp     eax, 1
.text$mn:00000D63                 jnz     short loc_D66
.text$mn:00000D65                 int     3               ; Trap to Debugger
.text$mn:00000D66
.text$mn:00000D66 loc_D66:                                ; CODE XREF: std::vector<DlgInfo,std::allocator<DlgInfo>>::operator[](uint)+36j
.text$mn:00000D66                                         ; std::vector<DlgInfo,std::allocator<DlgInfo>>::operator[](uint)+5Bj
.text$mn:00000D66                 push    0
.text$mn:00000D68                 push    4B2h
.text$mn:00000D6D                 push    offset ??_C@_1IM@EINEHPHE@?$AAC?$AA?3?$AA?2?$AAP?$AAr?$AAo?$AAg?$AAr?$AAa?$AAm?$AA?5?$AAF?$AAi?$AAl?$AAe?$AAs?$AA?5?$AA?$CI?$AAx?$AA8?$AA6?$AA?$CJ?$AA?2?$AAM?$AAi?$AAc?$AAr?$AAo?$AAs?$AAo?$AAf?$AAt@ ; "C:\\Program Files (x86)\\Microsoft Visu"...
.text$mn:00000D72                 push    offset ??_C@_1JO@EEMIOACN@?$AAs?$AAt?$AAd?$AA?3?$AA?3?$AAv?$AAe?$AAc?$AAt?$AAo?$AAr?$AA?$DM?$AAs?$AAt?$AAr?$AAu?$AAc?$AAt?$AA?5?$AAD?$AAl?$AAg?$AAI?$AAn?$AAf?$AAo?$AA?0?$AAc?$AAl?$AAa?$AAs?$AAs@ ; "std::vector<struct DlgInfo,class std::a"...
.text$mn:00000D77                 push    offset ??_C@_1BO@MEPPHOO@?$AA?$CC?$AAo?$AAu?$AAt?$AA?5?$AAo?$AAf?$AA?5?$AAr?$AAa?$AAn?$AAg?$AAe?$AA?$CC?$AA?$AA@ ; "\"out of range\""
.text$mn:00000D7C                 call    __invalid_parameter
.text$mn:00000D81                 add     esp, 14h
.text$mn:00000D84
.text$mn:00000D84 loc_D84:                                ; CODE XREF: std::vector<DlgInfo,std::allocator<DlgInfo>>::operator[](uint)+12j
.text$mn:00000D84                 imul    eax, [ebp+arg_0], 3Ch
.text$mn:00000D88                 mov     ecx, [ebp+var_4]
.text$mn:00000D8B                 add     eax, [ecx+4]
.text$mn:00000D8E                 mov     esp, ebp
.text$mn:00000D90                 pop     ebp
.text$mn:00000D91                 retn    4
.text$mn:00000D91 ??A?$vector@UDlgInfo@@V?$allocator@UDlgInfo@@@std@@@std@@QAEAAUDlgInfo@@I@Z endp
.text$mn:00000D91
.text$mn:00000D91 _text$mn        ends
.text$mn:00000D91
.text$mn:00000D94 ; ===========================================================================
.text$mn:00000D94
.text$mn:00000D94 ; Segment type: Pure code
.text$mn:00000D94 ; Segment permissions: Read/Execute
.text$mn:00000D94 _text$mn        segment para public 'CODE' use32
.text$mn:00000D94                 assume cs:_text$mn
.text$mn:00000D94                 ;org 0D94h
.text$mn:00000D94 ; COMDAT (pick any)
.text$mn:00000D94                 assume es:nothing, ss:nothing, ds:_xdata$x, fs:nothing, gs:nothing
.text$mn:00000D94
.text$mn:00000D94 ; =============== S U B R O U T I N E =======================================
.text$mn:00000D94
.text$mn:00000D94 ; Attributes: bp-based frame
.text$mn:00000D94
.text$mn:00000D94 ; public: virtual void * __thiscall std::_Generic_error_category::`scalar deleting destructor'(unsigned int)
.text$mn:00000D94                 public ??_G_Generic_error_category@std@@UAEPAXI@Z
.text$mn:00000D94 ??_G_Generic_error_category@std@@UAEPAXI@Z proc near
.text$mn:00000D94
.text$mn:00000D94 var_4           = dword ptr -4
.text$mn:00000D94 arg_0           = dword ptr  8
.text$mn:00000D94
.text$mn:00000D94                 push    ebp
.text$mn:00000D95                 mov     ebp, esp
.text$mn:00000D97                 push    ecx
.text$mn:00000D98                 mov     [ebp+var_4], ecx
.text$mn:00000D9B                 mov     ecx, [ebp+var_4] ; this
.text$mn:00000D9E                 call    ??1_Generic_error_category@std@@UAE@XZ ; std::_Generic_error_category::~_Generic_error_category(void)
.text$mn:00000DA3                 mov     eax, [ebp+arg_0]
.text$mn:00000DA6                 and     eax, 1
.text$mn:00000DA9                 jz      short loc_DB7
.text$mn:00000DAB                 mov     ecx, [ebp+var_4]
.text$mn:00000DAE                 push    ecx             ; void *
.text$mn:00000DAF                 call    ??3@YAXPAX@Z    ; operator delete(void *)
.text$mn:00000DB4                 add     esp, 4
.text$mn:00000DB7
.text$mn:00000DB7 loc_DB7:                                ; CODE XREF: std::_Generic_error_category::`scalar deleting destructor'(uint)+15j
.text$mn:00000DB7                 mov     eax, [ebp+var_4]
.text$mn:00000DBA                 mov     esp, ebp
.text$mn:00000DBC                 pop     ebp
.text$mn:00000DBD                 retn    4
.text$mn:00000DBD ??_G_Generic_error_category@std@@UAEPAXI@Z endp
.text$mn:00000DBD
.text$mn:00000DBD _text$mn        ends
.text$mn:00000DBD
.text$mn:00000DC0 ; ===========================================================================
.text$mn:00000DC0
.text$mn:00000DC0 ; Segment type: Pure code
.text$mn:00000DC0 ; Segment permissions: Read/Execute
.text$mn:00000DC0 _text$mn        segment para public 'CODE' use32
.text$mn:00000DC0                 assume cs:_text$mn
.text$mn:00000DC0                 ;org 0DC0h
.text$mn:00000DC0 ; COMDAT (pick any)
.text$mn:00000DC0                 assume es:nothing, ss:nothing, ds:_xdata$x, fs:nothing, gs:nothing
.text$mn:00000DC0
.text$mn:00000DC0 ; =============== S U B R O U T I N E =======================================
.text$mn:00000DC0
.text$mn:00000DC0 ; Attributes: bp-based frame
.text$mn:00000DC0
.text$mn:00000DC0 ; public: virtual void * __thiscall std::_Iostream_error_category::`scalar deleting destructor'(unsigned int)
.text$mn:00000DC0                 public ??_G_Iostream_error_category@std@@UAEPAXI@Z
.text$mn:00000DC0 ??_G_Iostream_error_category@std@@UAEPAXI@Z proc near
.text$mn:00000DC0
.text$mn:00000DC0 var_4           = dword ptr -4
.text$mn:00000DC0 arg_0           = dword ptr  8
.text$mn:00000DC0
.text$mn:00000DC0                 push    ebp
.text$mn:00000DC1                 mov     ebp, esp
.text$mn:00000DC3                 push    ecx
.text$mn:00000DC4                 mov     [ebp+var_4], ecx
.text$mn:00000DC7                 mov     ecx, [ebp+var_4] ; this
.text$mn:00000DCA                 call    ??1_Iostream_error_category@std@@UAE@XZ ; std::_Iostream_error_category::~_Iostream_error_category(void)
.text$mn:00000DCF                 mov     eax, [ebp+arg_0]
.text$mn:00000DD2                 and     eax, 1
.text$mn:00000DD5                 jz      short loc_DE3
.text$mn:00000DD7                 mov     ecx, [ebp+var_4]
.text$mn:00000DDA                 push    ecx             ; void *
.text$mn:00000DDB                 call    ??3@YAXPAX@Z    ; operator delete(void *)
.text$mn:00000DE0                 add     esp, 4
.text$mn:00000DE3
.text$mn:00000DE3 loc_DE3:                                ; CODE XREF: std::_Iostream_error_category::`scalar deleting destructor'(uint)+15j
.text$mn:00000DE3                 mov     eax, [ebp+var_4]
.text$mn:00000DE6                 mov     esp, ebp
.text$mn:00000DE8                 pop     ebp
.text$mn:00000DE9                 retn    4
.text$mn:00000DE9 ??_G_Iostream_error_category@std@@UAEPAXI@Z endp
.text$mn:00000DE9
.text$mn:00000DE9 _text$mn        ends
.text$mn:00000DE9
.text$mn:00000DEC ; ===========================================================================
.text$mn:00000DEC
.text$mn:00000DEC ; Segment type: Pure code
.text$mn:00000DEC ; Segment permissions: Read/Execute
.text$mn:00000DEC _text$mn        segment para public 'CODE' use32
.text$mn:00000DEC                 assume cs:_text$mn
.text$mn:00000DEC                 ;org 0DECh
.text$mn:00000DEC ; COMDAT (pick any)
.text$mn:00000DEC                 assume es:nothing, ss:nothing, ds:_xdata$x, fs:nothing, gs:nothing
.text$mn:00000DEC
.text$mn:00000DEC ; =============== S U B R O U T I N E =======================================
.text$mn:00000DEC
.text$mn:00000DEC ; Attributes: bp-based frame
.text$mn:00000DEC
.text$mn:00000DEC ; public: virtual void * __thiscall std::_System_error_category::`scalar deleting destructor'(unsigned int)
.text$mn:00000DEC                 public ??_G_System_error_category@std@@UAEPAXI@Z
.text$mn:00000DEC ??_G_System_error_category@std@@UAEPAXI@Z proc near
.text$mn:00000DEC
.text$mn:00000DEC var_4           = dword ptr -4
.text$mn:00000DEC arg_0           = dword ptr  8
.text$mn:00000DEC
.text$mn:00000DEC                 push    ebp
.text$mn:00000DED                 mov     ebp, esp
.text$mn:00000DEF                 push    ecx
.text$mn:00000DF0                 mov     [ebp+var_4], ecx
.text$mn:00000DF3                 mov     ecx, [ebp+var_4] ; this
.text$mn:00000DF6                 call    ??1_System_error_category@std@@UAE@XZ ; std::_System_error_category::~_System_error_category(void)
.text$mn:00000DFB                 mov     eax, [ebp+arg_0]
.text$mn:00000DFE                 and     eax, 1
.text$mn:00000E01                 jz      short loc_E0F
.text$mn:00000E03                 mov     ecx, [ebp+var_4]
.text$mn:00000E06                 push    ecx             ; void *
.text$mn:00000E07                 call    ??3@YAXPAX@Z    ; operator delete(void *)
.text$mn:00000E0C                 add     esp, 4
.text$mn:00000E0F
.text$mn:00000E0F loc_E0F:                                ; CODE XREF: std::_System_error_category::`scalar deleting destructor'(uint)+15j
.text$mn:00000E0F                 mov     eax, [ebp+var_4]
.text$mn:00000E12                 mov     esp, ebp
.text$mn:00000E14                 pop     ebp
.text$mn:00000E15                 retn    4
.text$mn:00000E15 ??_G_System_error_category@std@@UAEPAXI@Z endp
.text$mn:00000E15
.text$mn:00000E15 _text$mn        ends
.text$mn:00000E15
.text$mn:00000E18 ; ===========================================================================
.text$mn:00000E18
.text$mn:00000E18 ; Segment type: Pure code
.text$mn:00000E18 ; Segment permissions: Read/Execute
.text$mn:00000E18 _text$mn        segment para public 'CODE' use32
.text$mn:00000E18                 assume cs:_text$mn
.text$mn:00000E18                 ;org 0E18h
.text$mn:00000E18 ; COMDAT (pick any)
.text$mn:00000E18                 assume es:nothing, ss:nothing, ds:_xdata$x, fs:nothing, gs:nothing
.text$mn:00000E18
.text$mn:00000E18 ; =============== S U B R O U T I N E =======================================
.text$mn:00000E18
.text$mn:00000E18 ; Attributes: bp-based frame
.text$mn:00000E18
.text$mn:00000E18 ; public: virtual void * __thiscall std::error_category::`scalar deleting destructor'(unsigned int)
.text$mn:00000E18                 public ??_Gerror_category@std@@UAEPAXI@Z
.text$mn:00000E18 ??_Gerror_category@std@@UAEPAXI@Z proc near
.text$mn:00000E18
.text$mn:00000E18 var_4           = dword ptr -4
.text$mn:00000E18 arg_0           = dword ptr  8
.text$mn:00000E18
.text$mn:00000E18                 push    ebp
.text$mn:00000E19                 mov     ebp, esp
.text$mn:00000E1B                 push    ecx
.text$mn:00000E1C                 mov     [ebp+var_4], ecx
.text$mn:00000E1F                 mov     ecx, [ebp+var_4] ; this
.text$mn:00000E22                 call    ??1error_category@std@@UAE@XZ ; std::error_category::~error_category(void)
.text$mn:00000E27                 mov     eax, [ebp+arg_0]
.text$mn:00000E2A                 and     eax, 1
.text$mn:00000E2D                 jz      short loc_E3B
.text$mn:00000E2F                 mov     ecx, [ebp+var_4]
.text$mn:00000E32                 push    ecx             ; void *
.text$mn:00000E33                 call    ??3@YAXPAX@Z    ; operator delete(void *)
.text$mn:00000E38                 add     esp, 4
.text$mn:00000E3B
.text$mn:00000E3B loc_E3B:                                ; CODE XREF: std::error_category::`scalar deleting destructor'(uint)+15j
.text$mn:00000E3B                 mov     eax, [ebp+var_4]
.text$mn:00000E3E                 mov     esp, ebp
.text$mn:00000E40                 pop     ebp
.text$mn:00000E41                 retn    4
.text$mn:00000E41 ??_Gerror_category@std@@UAEPAXI@Z endp
.text$mn:00000E41
.text$mn:00000E41 _text$mn        ends
.text$mn:00000E41
.text$di:00000E44 ; ===========================================================================
.text$di:00000E44
.text$di:00000E44 ; Segment type: Pure code
.text$di:00000E44 ; Segment permissions: Read/Execute
.text$di:00000E44 _text$di        segment para public 'CODE' use32
.text$di:00000E44                 assume cs:_text$di
.text$di:00000E44                 ;org 0E44h
.text$di:00000E44 ; COMDAT (pick any)
.text$di:00000E44                 assume es:nothing, ss:nothing, ds:_xdata$x, fs:nothing, gs:nothing
.text$di:00000E44
.text$di:00000E44 ; =============== S U B R O U T I N E =======================================
.text$di:00000E44
.text$di:00000E44 ; Attributes: bp-based frame
.text$di:00000E44
.text$di:00000E44 ; void __cdecl `dynamic initializer for 'public: static class std::_Generic_error_category std::_Error_objects<int>::_Generic_object''(void)
.text$di:00000E44 ??__E?_Generic_object@?$_Error_objects@H@std@@2V_Generic_error_category@2@A@@YAXXZ proc near
.text$di:00000E44                                         ; DATA XREF: .CRT$XCU:void (*std::_Error_objects<int>::_Generic_object$initializer$)(void)o
.text$di:00000E44                 push    ebp
.text$di:00000E45                 mov     ebp, esp
.text$di:00000E47                 mov     ecx, offset ?_Generic_object@?$_Error_objects@H@std@@2V_Generic_error_category@2@A ; this
.text$di:00000E4C                 call    ??0_Generic_error_category@std@@QAE@XZ ; std::_Generic_error_category::_Generic_error_category(void)
.text$di:00000E51                 push    offset ??__F?_Generic_object@?$_Error_objects@H@std@@2V_Generic_error_category@2@A@@YAXXZ ; void (__cdecl *)()
.text$di:00000E56                 call    _atexit
.text$di:00000E5B                 add     esp, 4
.text$di:00000E5E                 pop     ebp
.text$di:00000E5F                 retn
.text$di:00000E5F ??__E?_Generic_object@?$_Error_objects@H@std@@2V_Generic_error_category@2@A@@YAXXZ endp
.text$di:00000E5F
.text$di:00000E5F _text$di        ends
.text$di:00000E5F
.text$di:00000E60 ; ===========================================================================
.text$di:00000E60
.text$di:00000E60 ; Segment type: Pure code
.text$di:00000E60 ; Segment permissions: Read/Execute
.text$di:00000E60 _text$di        segment para public 'CODE' use32
.text$di:00000E60                 assume cs:_text$di
.text$di:00000E60                 ;org 0E60h
.text$di:00000E60 ; COMDAT (pick any)
.text$di:00000E60                 assume es:nothing, ss:nothing, ds:_xdata$x, fs:nothing, gs:nothing
.text$di:00000E60
.text$di:00000E60 ; =============== S U B R O U T I N E =======================================
.text$di:00000E60
.text$di:00000E60 ; Attributes: bp-based frame
.text$di:00000E60
.text$di:00000E60 ; void __cdecl `dynamic initializer for 'public: static class std::_Iostream_error_category std::_Error_objects<int>::_Iostream_object''(void)
.text$di:00000E60 ??__E?_Iostream_object@?$_Error_objects@H@std@@2V_Iostream_error_category@2@A@@YAXXZ proc near
.text$di:00000E60                                         ; DATA XREF: .CRT$XCU:void (*std::_Error_objects<int>::_Iostream_object$initializer$)(void)o
.text$di:00000E60                 push    ebp
.text$di:00000E61                 mov     ebp, esp
.text$di:00000E63                 mov     ecx, offset ?_Iostream_object@?$_Error_objects@H@std@@2V_Iostream_error_category@2@A ; this
.text$di:00000E68                 call    ??0_Iostream_error_category@std@@QAE@XZ ; std::_Iostream_error_category::_Iostream_error_category(void)
.text$di:00000E6D                 push    offset ??__F?_Iostream_object@?$_Error_objects@H@std@@2V_Iostream_error_category@2@A@@YAXXZ ; void (__cdecl *)()
.text$di:00000E72                 call    _atexit
.text$di:00000E77                 add     esp, 4
.text$di:00000E7A                 pop     ebp
.text$di:00000E7B                 retn
.text$di:00000E7B ??__E?_Iostream_object@?$_Error_objects@H@std@@2V_Iostream_error_category@2@A@@YAXXZ endp
.text$di:00000E7B
.text$di:00000E7B _text$di        ends
.text$di:00000E7B
.text$di:00000E7C ; ===========================================================================
.text$di:00000E7C
.text$di:00000E7C ; Segment type: Pure code
.text$di:00000E7C ; Segment permissions: Read/Execute
.text$di:00000E7C _text$di        segment para public 'CODE' use32
.text$di:00000E7C                 assume cs:_text$di
.text$di:00000E7C                 ;org 0E7Ch
.text$di:00000E7C ; COMDAT (pick any)
.text$di:00000E7C                 assume es:nothing, ss:nothing, ds:_xdata$x, fs:nothing, gs:nothing
.text$di:00000E7C
.text$di:00000E7C ; =============== S U B R O U T I N E =======================================
.text$di:00000E7C
.text$di:00000E7C ; Attributes: bp-based frame
.text$di:00000E7C
.text$di:00000E7C ; void __cdecl `dynamic initializer for 'public: static class std::_System_error_category std::_Error_objects<int>::_System_object''(void)
.text$di:00000E7C ??__E?_System_object@?$_Error_objects@H@std@@2V_System_error_category@2@A@@YAXXZ proc near
.text$di:00000E7C                                         ; DATA XREF: .CRT$XCU:void (*std::_Error_objects<int>::_System_object$initializer$)(void)o
.text$di:00000E7C                 push    ebp
.text$di:00000E7D                 mov     ebp, esp
.text$di:00000E7F                 mov     ecx, offset ?_System_object@?$_Error_objects@H@std@@2V_System_error_category@2@A ; this
.text$di:00000E84                 call    ??0_System_error_category@std@@QAE@XZ ; std::_System_error_category::_System_error_category(void)
.text$di:00000E89                 push    offset ??__F?_System_object@?$_Error_objects@H@std@@2V_System_error_category@2@A@@YAXXZ ; void (__cdecl *)()
.text$di:00000E8E                 call    _atexit
.text$di:00000E93                 add     esp, 4
.text$di:00000E96                 pop     ebp
.text$di:00000E97                 retn
.text$di:00000E97 ??__E?_System_object@?$_Error_objects@H@std@@2V_System_error_category@2@A@@YAXXZ endp
.text$di:00000E97
.text$di:00000E97 _text$di        ends
.text$di:00000E97
.text$di:00000E98 ; ===========================================================================
.text$di:00000E98
.text$di:00000E98 ; Segment type: Pure code
.text$di:00000E98 ; Segment permissions: Read/Execute
.text$di:00000E98 _text$di        segment para public 'CODE' use32
.text$di:00000E98                 assume cs:_text$di
.text$di:00000E98                 ;org 0E98h
.text$di:00000E98 ; COMDAT (pick any)
.text$di:00000E98                 assume es:nothing, ss:nothing, ds:_xdata$x, fs:nothing, gs:nothing
.text$di:00000E98
.text$di:00000E98 ; =============== S U B R O U T I N E =======================================
.text$di:00000E98
.text$di:00000E98 ; Attributes: bp-based frame
.text$di:00000E98
.text$di:00000E98 ; void __cdecl `dynamic initializer for 'public: static class std::locale::id std::num_put<char, class std::back_insert_iterator<class std::basic_string<char, struct std::char_traits<char>, class std::allocator<char>>>>::id''(void)
.text$di:00000E98 ??__E?id@?$num_put@DV?$back_insert_iterator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@std@@2V0locale@2@A@@YAXXZ proc near
.text$di:00000E98                                         ; DATA XREF: .CRT$XCU:void (*std::num_put<char,std::back_insert_iterator<std::basic_string<char,std::char_traits<char>,std::allocator<char>>>>::id$initializer$)(void)o
.text$di:00000E98                 push    ebp
.text$di:00000E99                 mov     ebp, esp
.text$di:00000E9B                 push    0               ; unsigned int
.text$di:00000E9D                 mov     ecx, offset ?id@?$num_put@DV?$back_insert_iterator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@std@@2V0locale@2@A ; this
.text$di:00000EA2                 call    ??0id@locale@std@@QAE@I@Z ; std::locale::id::id(uint)
.text$di:00000EA7                 pop     ebp
.text$di:00000EA8                 retn
.text$di:00000EA8 ??__E?id@?$num_put@DV?$back_insert_iterator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@std@@2V0locale@2@A@@YAXXZ endp
.text$di:00000EA8
.text$di:00000EA8 ; ---------------------------------------------------------------------------
.text$di:00000EA9                 align 4
.text$di:00000EA9 _text$di        ends
.text$di:00000EA9
.text$di:00000EAC ; ===========================================================================
.text$di:00000EAC
.text$di:00000EAC ; Segment type: Pure code
.text$di:00000EAC ; Segment permissions: Read/Execute
.text$di:00000EAC _text$di        segment para public 'CODE' use32
.text$di:00000EAC                 assume cs:_text$di
.text$di:00000EAC                 ;org 0EACh
.text$di:00000EAC ; COMDAT (pick any)
.text$di:00000EAC                 assume es:nothing, ss:nothing, ds:_xdata$x, fs:nothing, gs:nothing
.text$di:00000EAC
.text$di:00000EAC ; =============== S U B R O U T I N E =======================================
.text$di:00000EAC
.text$di:00000EAC ; Attributes: bp-based frame
.text$di:00000EAC
.text$di:00000EAC ; void __cdecl `dynamic initializer for 'public: static class std::locale::id std::num_put<wchar_t, class std::back_insert_iterator<class std::basic_string<wchar_t, struct std::char_traits<wchar_t>, class std::allocator<wchar_t>>>>::id''(void)
.text$di:00000EAC ??__E?id@?$num_put@_WV?$back_insert_iterator@V?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@@std@@@std@@2V0locale@2@A@@YAXXZ proc near
.text$di:00000EAC                                         ; DATA XREF: .CRT$XCU:void (*std::num_put<wchar_t,std::back_insert_iterator<std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>>>>::id$initializer$)(void)o
.text$di:00000EAC                 push    ebp
.text$di:00000EAD                 mov     ebp, esp
.text$di:00000EAF                 push    0               ; unsigned int
.text$di:00000EB1                 mov     ecx, offset ?id@?$num_put@_WV?$back_insert_iterator@V?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@@std@@@std@@2V0locale@2@A ; this
.text$di:00000EB6                 call    ??0id@locale@std@@QAE@I@Z ; std::locale::id::id(uint)
.text$di:00000EBB                 pop     ebp
.text$di:00000EBC                 retn
.text$di:00000EBC ??__E?id@?$num_put@_WV?$back_insert_iterator@V?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@@std@@@std@@2V0locale@2@A@@YAXXZ endp
.text$di:00000EBC
.text$di:00000EBC ; ---------------------------------------------------------------------------
.text$di:00000EBD                 align 10h
.text$di:00000EBD _text$di        ends
.text$di:00000EBD
.text$di:00000EC0 ; ===========================================================================
.text$di:00000EC0
.text$di:00000EC0 ; Segment type: Pure code
.text$di:00000EC0 ; Segment permissions: Read/Execute
.text$di:00000EC0 _text$di        segment para public 'CODE' use32
.text$di:00000EC0                 assume cs:_text$di
.text$di:00000EC0                 ;org 0EC0h
.text$di:00000EC0 ; COMDAT (pick any)
.text$di:00000EC0                 assume es:nothing, ss:nothing, ds:_xdata$x, fs:nothing, gs:nothing
.text$di:00000EC0
.text$di:00000EC0 ; =============== S U B R O U T I N E =======================================
.text$di:00000EC0
.text$di:00000EC0 ; Attributes: bp-based frame
.text$di:00000EC0
.text$di:00000EC0 ; void __cdecl `dynamic initializer for 'public: static class std::locale::id std::numpunct<char>::id''(void)
.text$di:00000EC0 ??__E?id@?$numpunct@D@std@@2V0locale@2@A@@YAXXZ proc near
.text$di:00000EC0                                         ; DATA XREF: .CRT$XCU:void (*std::numpunct<char>::id$initializer$)(void)o
.text$di:00000EC0                 push    ebp
.text$di:00000EC1                 mov     ebp, esp
.text$di:00000EC3                 push    0               ; unsigned int
.text$di:00000EC5                 mov     ecx, offset ?id@?$numpunct@D@std@@2V0locale@2@A ; this
.text$di:00000ECA                 call    ??0id@locale@std@@QAE@I@Z ; std::locale::id::id(uint)
.text$di:00000ECF                 pop     ebp
.text$di:00000ED0                 retn
.text$di:00000ED0 ??__E?id@?$numpunct@D@std@@2V0locale@2@A@@YAXXZ endp
.text$di:00000ED0
.text$di:00000ED0 ; ---------------------------------------------------------------------------
.text$di:00000ED1                 align 4
.text$di:00000ED1 _text$di        ends
.text$di:00000ED1
.text$di:00000ED4 ; ===========================================================================
.text$di:00000ED4
.text$di:00000ED4 ; Segment type: Pure code
.text$di:00000ED4 ; Segment permissions: Read/Execute
.text$di:00000ED4 _text$di        segment para public 'CODE' use32
.text$di:00000ED4                 assume cs:_text$di
.text$di:00000ED4                 ;org 0ED4h
.text$di:00000ED4 ; COMDAT (pick any)
.text$di:00000ED4                 assume es:nothing, ss:nothing, ds:_xdata$x, fs:nothing, gs:nothing
.text$di:00000ED4
.text$di:00000ED4 ; =============== S U B R O U T I N E =======================================
.text$di:00000ED4
.text$di:00000ED4 ; Attributes: bp-based frame
.text$di:00000ED4
.text$di:00000ED4 ; void __cdecl `dynamic initializer for 'public: static class std::locale::id std::numpunct<wchar_t>::id''(void)
.text$di:00000ED4 ??__E?id@?$numpunct@_W@std@@2V0locale@2@A@@YAXXZ proc near
.text$di:00000ED4                                         ; DATA XREF: .CRT$XCU:void (*std::numpunct<wchar_t>::id$initializer$)(void)o
.text$di:00000ED4                 push    ebp
.text$di:00000ED5                 mov     ebp, esp
.text$di:00000ED7                 push    0               ; unsigned int
.text$di:00000ED9                 mov     ecx, offset ?id@?$numpunct@_W@std@@2V0locale@2@A ; this
.text$di:00000EDE                 call    ??0id@locale@std@@QAE@I@Z ; std::locale::id::id(uint)
.text$di:00000EE3                 pop     ebp
.text$di:00000EE4                 retn
.text$di:00000EE4 ??__E?id@?$numpunct@_W@std@@2V0locale@2@A@@YAXXZ endp
.text$di:00000EE4
.text$di:00000EE4 ; ---------------------------------------------------------------------------
.text$di:00000EE5                 align 4
.text$di:00000EE5 _text$di        ends
.text$di:00000EE5
.text$di:00000EE8 ; ===========================================================================
.text$di:00000EE8
.text$di:00000EE8 ; Segment type: Pure code
.text$di:00000EE8 ; Segment permissions: Read/Execute
.text$di:00000EE8 _text$di        segment para public 'CODE' use32
.text$di:00000EE8                 assume cs:_text$di
.text$di:00000EE8                 ;org 0EE8h
.text$di:00000EE8 ; COMDAT (pick any)
.text$di:00000EE8                 assume es:nothing, ss:nothing, ds:_xdata$x, fs:nothing, gs:nothing
.text$di:00000EE8
.text$di:00000EE8 ; =============== S U B R O U T I N E =======================================
.text$di:00000EE8
.text$di:00000EE8 ; Attributes: bp-based frame
.text$di:00000EE8
.text$di:00000EE8 ; void __cdecl std::`dynamic initializer for 'allocator_arg''(void)
.text$di:00000EE8 ??__Eallocator_arg@std@@YAXXZ proc near ; DATA XREF: .CRT$XCU:_allocator_arg$initializer$o
.text$di:00000EE8
.text$di:00000EE8 var_1           = byte ptr -1
.text$di:00000EE8
.text$di:00000EE8                 push    ebp
.text$di:00000EE9                 mov     ebp, esp
.text$di:00000EEB                 push    ecx
.text$di:00000EEC                 xor     eax, eax
.text$di:00000EEE                 mov     [ebp+var_1], al
.text$di:00000EF1                 mov     esp, ebp
.text$di:00000EF3                 pop     ebp
.text$di:00000EF4                 retn
.text$di:00000EF4 ??__Eallocator_arg@std@@YAXXZ endp
.text$di:00000EF4
.text$di:00000EF4 ; ---------------------------------------------------------------------------
.text$di:00000EF5                 align 4
.text$di:00000EF5 _text$di        ends
.text$di:00000EF5
.text$di:00000EF8 ; ===========================================================================
.text$di:00000EF8
.text$di:00000EF8 ; Segment type: Pure code
.text$di:00000EF8 ; Segment permissions: Read/Execute
.text$di:00000EF8 _text$di        segment para public 'CODE' use32
.text$di:00000EF8                 assume cs:_text$di
.text$di:00000EF8                 ;org 0EF8h
.text$di:00000EF8 ; COMDAT (pick any)
.text$di:00000EF8                 assume es:nothing, ss:nothing, ds:_xdata$x, fs:nothing, gs:nothing
.text$di:00000EF8
.text$di:00000EF8 ; =============== S U B R O U T I N E =======================================
.text$di:00000EF8
.text$di:00000EF8 ; Attributes: bp-based frame
.text$di:00000EF8
.text$di:00000EF8 ; void __cdecl std::`dynamic initializer for 'piecewise_construct''(void)
.text$di:00000EF8 ??__Epiecewise_construct@std@@YAXXZ proc near
.text$di:00000EF8                                         ; DATA XREF: .CRT$XCU:_piecewise_construct$initializer$o
.text$di:00000EF8
.text$di:00000EF8 var_1           = byte ptr -1
.text$di:00000EF8
.text$di:00000EF8                 push    ebp
.text$di:00000EF9                 mov     ebp, esp
.text$di:00000EFB                 push    ecx
.text$di:00000EFC                 xor     eax, eax
.text$di:00000EFE                 mov     [ebp+var_1], al
.text$di:00000F01                 mov     esp, ebp
.text$di:00000F03                 pop     ebp
.text$di:00000F04                 retn
.text$di:00000F04 ??__Epiecewise_construct@std@@YAXXZ endp
.text$di:00000F04
.text$di:00000F04 ; ---------------------------------------------------------------------------
.text$di:00000F05                 align 4
.text$di:00000F05 _text$di        ends
.text$di:00000F05
.text$yd:00000F08 ; ===========================================================================
.text$yd:00000F08
.text$yd:00000F08 ; Segment type: Pure code
.text$yd:00000F08 ; Segment permissions: Read/Execute
.text$yd:00000F08 _text$yd        segment para public 'CODE' use32
.text$yd:00000F08                 assume cs:_text$yd
.text$yd:00000F08                 ;org 0F08h
.text$yd:00000F08 ; COMDAT (pick any)
.text$yd:00000F08                 assume es:nothing, ss:nothing, ds:_xdata$x, fs:nothing, gs:nothing
.text$yd:00000F08
.text$yd:00000F08 ; =============== S U B R O U T I N E =======================================
.text$yd:00000F08
.text$yd:00000F08 ; Attributes: bp-based frame
.text$yd:00000F08
.text$yd:00000F08 ; void __cdecl `dynamic atexit destructor for 'public: static std::_Generic_error_category std::_Error_objects<int>::_Generic_object''()
.text$yd:00000F08 ??__F?_Generic_object@?$_Error_objects@H@std@@2V_Generic_error_category@2@A@@YAXXZ proc near
.text$yd:00000F08                                         ; DATA XREF: `dynamic initializer for 'std::_Generic_error_category std::_Error_objects<int>::_Generic_object''(void)+Do
.text$yd:00000F08                 push    ebp
.text$yd:00000F09                 mov     ebp, esp
.text$yd:00000F0B                 mov     ecx, offset ?_Generic_object@?$_Error_objects@H@std@@2V_Generic_error_category@2@A ; this
.text$yd:00000F10                 call    ??1_Generic_error_category@std@@UAE@XZ ; std::_Generic_error_category::~_Generic_error_category(void)
.text$yd:00000F15                 pop     ebp
.text$yd:00000F16                 retn
.text$yd:00000F16 ??__F?_Generic_object@?$_Error_objects@H@std@@2V_Generic_error_category@2@A@@YAXXZ endp
.text$yd:00000F16
.text$yd:00000F16 ; ---------------------------------------------------------------------------
.text$yd:00000F17                 align 4
.text$yd:00000F17 _text$yd        ends
.text$yd:00000F17
.text$yd:00000F18 ; ===========================================================================
.text$yd:00000F18
.text$yd:00000F18 ; Segment type: Pure code
.text$yd:00000F18 ; Segment permissions: Read/Execute
.text$yd:00000F18 _text$yd        segment para public 'CODE' use32
.text$yd:00000F18                 assume cs:_text$yd
.text$yd:00000F18                 ;org 0F18h
.text$yd:00000F18 ; COMDAT (pick any)
.text$yd:00000F18                 assume es:nothing, ss:nothing, ds:_xdata$x, fs:nothing, gs:nothing
.text$yd:00000F18
.text$yd:00000F18 ; =============== S U B R O U T I N E =======================================
.text$yd:00000F18
.text$yd:00000F18 ; Attributes: bp-based frame
.text$yd:00000F18
.text$yd:00000F18 ; void __cdecl `dynamic atexit destructor for 'public: static std::_Iostream_error_category std::_Error_objects<int>::_Iostream_object''()
.text$yd:00000F18 ??__F?_Iostream_object@?$_Error_objects@H@std@@2V_Iostream_error_category@2@A@@YAXXZ proc near
.text$yd:00000F18                                         ; DATA XREF: `dynamic initializer for 'std::_Iostream_error_category std::_Error_objects<int>::_Iostream_object''(void)+Do
.text$yd:00000F18                 push    ebp
.text$yd:00000F19                 mov     ebp, esp
.text$yd:00000F1B                 mov     ecx, offset ?_Iostream_object@?$_Error_objects@H@std@@2V_Iostream_error_category@2@A ; this
.text$yd:00000F20                 call    ??1_Iostream_error_category@std@@UAE@XZ ; std::_Iostream_error_category::~_Iostream_error_category(void)
.text$yd:00000F25                 pop     ebp
.text$yd:00000F26                 retn
.text$yd:00000F26 ??__F?_Iostream_object@?$_Error_objects@H@std@@2V_Iostream_error_category@2@A@@YAXXZ endp
.text$yd:00000F26
.text$yd:00000F26 ; ---------------------------------------------------------------------------
.text$yd:00000F27                 align 4
.text$yd:00000F27 _text$yd        ends
.text$yd:00000F27
.text$yd:00000F28 ; ===========================================================================
.text$yd:00000F28
.text$yd:00000F28 ; Segment type: Pure code
.text$yd:00000F28 ; Segment permissions: Read/Execute
.text$yd:00000F28 _text$yd        segment para public 'CODE' use32
.text$yd:00000F28                 assume cs:_text$yd
.text$yd:00000F28                 ;org 0F28h
.text$yd:00000F28 ; COMDAT (pick any)
.text$yd:00000F28                 assume es:nothing, ss:nothing, ds:_xdata$x, fs:nothing, gs:nothing
.text$yd:00000F28
.text$yd:00000F28 ; =============== S U B R O U T I N E =======================================
.text$yd:00000F28
.text$yd:00000F28 ; Attributes: bp-based frame
.text$yd:00000F28
.text$yd:00000F28 ; void __cdecl `dynamic atexit destructor for 'public: static std::_System_error_category std::_Error_objects<int>::_System_object''()
.text$yd:00000F28 ??__F?_System_object@?$_Error_objects@H@std@@2V_System_error_category@2@A@@YAXXZ proc near
.text$yd:00000F28                                         ; DATA XREF: `dynamic initializer for 'std::_System_error_category std::_Error_objects<int>::_System_object''(void)+Do
.text$yd:00000F28                 push    ebp
.text$yd:00000F29                 mov     ebp, esp
.text$yd:00000F2B                 mov     ecx, offset ?_System_object@?$_Error_objects@H@std@@2V_System_error_category@2@A ; this
.text$yd:00000F30                 call    ??1_System_error_category@std@@UAE@XZ ; std::_System_error_category::~_System_error_category(void)
.text$yd:00000F35                 pop     ebp
.text$yd:00000F36                 retn
.text$yd:00000F36 ??__F?_System_object@?$_Error_objects@H@std@@2V_System_error_category@2@A@@YAXXZ endp
.text$yd:00000F36
.text$yd:00000F36 ; ---------------------------------------------------------------------------
.text$yd:00000F37                 align 4
.text$yd:00000F37 _text$yd        ends
.text$yd:00000F37
.text$mn:00000F38 ; ===========================================================================
.text$mn:00000F38
.text$mn:00000F38 ; Segment type: Pure code
.text$mn:00000F38 ; Segment permissions: Read/Execute
.text$mn:00000F38 _text$mn        segment para public 'CODE' use32
.text$mn:00000F38                 assume cs:_text$mn
.text$mn:00000F38                 ;org 0F38h
.text$mn:00000F38 ; COMDAT (pick any)
.text$mn:00000F38                 assume es:nothing, ss:nothing, ds:_xdata$x, fs:nothing, gs:nothing
.text$mn:00000F38
.text$mn:00000F38 ; =============== S U B R O U T I N E =======================================
.text$mn:00000F38
.text$mn:00000F38 ; Attributes: bp-based frame
.text$mn:00000F38
.text$mn:00000F38 ; public: void __thiscall std::_String_alloc<0, struct std::_String_base_types<char, class std::allocator<char>>>::_Alloc_proxy(void)
.text$mn:00000F38                 public ?_Alloc_proxy@?$_String_alloc@$0A@U?$_String_base_types@DV?$allocator@D@std@@@std@@@std@@QAEXXZ
.text$mn:00000F38 ?_Alloc_proxy@?$_String_alloc@$0A@U?$_String_base_types@DV?$allocator@D@std@@@std@@@std@@QAEXXZ proc near
.text$mn:00000F38                                         ; CODE XREF: std::_String_alloc<0,std::_String_base_types<char,std::allocator<char>>>::_String_alloc<0,std::_String_base_types<char,std::allocator<char>>>(std::allocator<char> const &)+38p
.text$mn:00000F38
.text$mn:00000F38 var_10          = byte ptr -10h
.text$mn:00000F38 var_8           = dword ptr -8
.text$mn:00000F38 var_1           = byte ptr -1
.text$mn:00000F38
.text$mn:00000F38                 push    ebp
.text$mn:00000F39                 mov     ebp, esp
.text$mn:00000F3B                 sub     esp, 10h
.text$mn:00000F3E                 mov     [ebp+var_8], ecx
.text$mn:00000F41                 lea     ecx, [ebp+var_1]
.text$mn:00000F44                 call    ??0?$allocator@U_Container_proxy@std@@@std@@QAE@XZ ; std::allocator<std::_Container_proxy>::allocator<std::_Container_proxy>(void)
.text$mn:00000F49                 push    1
.text$mn:00000F4B                 lea     ecx, [ebp+var_1]
.text$mn:00000F4E                 call    ?allocate@?$allocator@U_Container_proxy@std@@@std@@QAEPAU_Container_proxy@2@I@Z ; std::allocator<std::_Container_proxy>::allocate(uint)
.text$mn:00000F53                 mov     ecx, [ebp+var_8]
.text$mn:00000F56                 mov     [ecx], eax
.text$mn:00000F58                 lea     ecx, [ebp+var_10] ; this
.text$mn:00000F5B                 call    ??0_Container_proxy@std@@QAE@XZ ; std::_Container_proxy::_Container_proxy(void)
.text$mn:00000F60                 push    eax             ; int
.text$mn:00000F61                 mov     edx, [ebp+var_8]
.text$mn:00000F64                 mov     eax, [edx]
.text$mn:00000F66                 push    eax             ; void *
.text$mn:00000F67                 lea     ecx, [ebp+var_1]
.text$mn:00000F6A                 call    ??$construct@U_Container_proxy@std@@U12@@?$allocator@U_Container_proxy@std@@@std@@QAEXPAU_Container_proxy@1@$$QAU21@@Z ; std::allocator<std::_Container_proxy>::construct<std::_Container_proxy,std::_Container_proxy>(std::_Container_proxy *,std::_Container_proxy &&)
.text$mn:00000F6F                 mov     ecx, [ebp+var_8]
.text$mn:00000F72                 mov     edx, [ecx]
.text$mn:00000F74                 mov     eax, [ebp+var_8]
.text$mn:00000F77                 mov     [edx], eax
.text$mn:00000F79                 mov     esp, ebp
.text$mn:00000F7B                 pop     ebp
.text$mn:00000F7C                 retn
.text$mn:00000F7C ?_Alloc_proxy@?$_String_alloc@$0A@U?$_String_base_types@DV?$allocator@D@std@@@std@@@std@@QAEXXZ endp
.text$mn:00000F7C
.text$mn:00000F7C ; ---------------------------------------------------------------------------
.text$mn:00000F7D                 align 10h
.text$mn:00000F7D _text$mn        ends
.text$mn:00000F7D
.text$mn:00000F80 ; ===========================================================================
.text$mn:00000F80
.text$mn:00000F80 ; Segment type: Pure code
.text$mn:00000F80 ; Segment permissions: Read/Execute
.text$mn:00000F80 _text$mn        segment para public 'CODE' use32
.text$mn:00000F80                 assume cs:_text$mn
.text$mn:00000F80                 ;org 0F80h
.text$mn:00000F80 ; COMDAT (pick any)
.text$mn:00000F80                 assume es:nothing, ss:nothing, ds:_xdata$x, fs:nothing, gs:nothing
.text$mn:00000F80
.text$mn:00000F80 ; =============== S U B R O U T I N E =======================================
.text$mn:00000F80
.text$mn:00000F80 ; Attributes: bp-based frame
.text$mn:00000F80
.text$mn:00000F80 ; public: void __thiscall std::basic_string<char, struct std::char_traits<char>, class std::allocator<char>>::_Copy(unsigned int, unsigned int)
.text$mn:00000F80                 public ?_Copy@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEXII@Z
.text$mn:00000F80 ?_Copy@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEXII@Z proc near
.text$mn:00000F80                                         ; CODE XREF: std::basic_string<char,std::char_traits<char>,std::allocator<char>>::_Grow(uint,bool)+37p
.text$mn:00000F80
.text$mn:00000F80 var_20          = dword ptr -20h
.text$mn:00000F80 var_1C          = dword ptr -1Ch
.text$mn:00000F80 var_18          = dword ptr -18h
.text$mn:00000F80 var_11          = byte ptr -11h
.text$mn:00000F80 var_10          = dword ptr -10h
.text$mn:00000F80 var_C           = byte ptr -0Ch
.text$mn:00000F80 var_4           = dword ptr -4
.text$mn:00000F80 arg_0           = dword ptr  8
.text$mn:00000F80
.text$mn:00000F80 ; FUNCTION CHUNK AT .text$mn:000010A2 SIZE 00000009 BYTES
.text$mn:00000F80
.text$mn:00000F80                 push    ebp
.text$mn:00000F81                 mov     ebp, esp
.text$mn:00000F83                 push    0FFFFFFFFh
.text$mn:00000F85                 push    offset __ehhandler$?_Copy@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEXII@Z
.text$mn:00000F8A                 mov     eax, large fs:0
.text$mn:00000F90                 push    eax
.text$mn:00000F91                 push    ecx
.text$mn:00000F92                 sub     esp, 10h
.text$mn:00000F95                 push    ebx
.text$mn:00000F96                 push    esi
.text$mn:00000F97                 push    edi
.text$mn:00000F98                 mov     eax, dword ptr ds:___security_cookie
.text$mn:00000F9D                 xor     eax, ebp
.text$mn:00000F9F                 push    eax
.text$mn:00000FA0                 lea     eax, [ebp+var_C]
.text$mn:00000FA3                 mov     large fs:0, eax
.text$mn:00000FA9                 mov     [ebp+var_10], esp
.text$mn:00000FAC                 mov     [ebp+var_18], ecx
.text$mn:00000FAF                 mov     eax, [ebp+arg_0]
.text$mn:00000FB2                 or      eax, 0Fh
.text$mn:00000FB5                 mov     [ebp+var_1C], eax
.text$mn:00000FB8                 mov     ecx, [ebp+var_18]
.text$mn:00000FBB                 call    ?max_size@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QBEIXZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char>>::max_size(void)
.text$mn:00000FC0                 cmp     eax, [ebp+var_1C]
.text$mn:00000FC3                 jnb     short loc_FCD
.text$mn:00000FC5                 mov     ecx, [ebp+arg_0]
.text$mn:00000FC8                 mov     [ebp+var_1C], ecx
.text$mn:00000FCB                 jmp     short loc_101F
.text$mn:00000FCD ; ---------------------------------------------------------------------------
.text$mn:00000FCD
.text$mn:00000FCD loc_FCD:                                ; CODE XREF: std::basic_string<char,std::char_traits<char>,std::allocator<char>>::_Copy(uint,uint)+43j
.text$mn:00000FCD                 mov     edx, [ebp+var_18]
.text$mn:00000FD0                 mov     ecx, [edx+18h]
.text$mn:00000FD3                 shr     ecx, 1
.text$mn:00000FD5                 mov     eax, [ebp+var_1C]
.text$mn:00000FD8                 xor     edx, edx
.text$mn:00000FDA                 mov     esi, 3
.text$mn:00000FDF                 div     esi
.text$mn:00000FE1                 cmp     ecx, eax
.text$mn:00000FE3                 ja      short loc_FE7
.text$mn:00000FE5                 jmp     short loc_101F
.text$mn:00000FE7 ; ---------------------------------------------------------------------------
.text$mn:00000FE7
.text$mn:00000FE7 loc_FE7:                                ; CODE XREF: std::basic_string<char,std::char_traits<char>,std::allocator<char>>::_Copy(uint,uint)+63j
.text$mn:00000FE7                 mov     ecx, [ebp+var_18]
.text$mn:00000FEA                 call    ?max_size@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QBEIXZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char>>::max_size(void)
.text$mn:00000FEF                 mov     edx, [ebp+var_18]
.text$mn:00000FF2                 mov     ecx, [edx+18h]
.text$mn:00000FF5                 shr     ecx, 1
.text$mn:00000FF7                 sub     eax, ecx
.text$mn:00000FF9                 mov     edx, [ebp+var_18]
.text$mn:00000FFC                 cmp     [edx+18h], eax
.text$mn:00000FFF                 ja      short loc_1014
.text$mn:00001001                 mov     eax, [ebp+var_18]
.text$mn:00001004                 mov     ecx, [eax+18h]
.text$mn:00001007                 shr     ecx, 1
.text$mn:00001009                 mov     edx, [ebp+var_18]
.text$mn:0000100C                 add     ecx, [edx+18h]
.text$mn:0000100F                 mov     [ebp+var_1C], ecx
.text$mn:00001012                 jmp     short loc_101F
.text$mn:00001014 ; ---------------------------------------------------------------------------
.text$mn:00001014
.text$mn:00001014 loc_1014:                               ; CODE XREF: std::basic_string<char,std::char_traits<char>,std::allocator<char>>::_Copy(uint,uint)+7Fj
.text$mn:00001014                 mov     ecx, [ebp+var_18]
.text$mn:00001017                 call    ?max_size@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QBEIXZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char>>::max_size(void)
.text$mn:0000101C                 mov     [ebp+var_1C], eax
.text$mn:0000101F
.text$mn:0000101F loc_101F:                               ; CODE XREF: std::basic_string<char,std::char_traits<char>,std::allocator<char>>::_Copy(uint,uint)+4Bj
.text$mn:0000101F                                         ; std::basic_string<char,std::char_traits<char>,std::allocator<char>>::_Copy(uint,uint)+65j ...
.text$mn:0000101F                 mov     [ebp+var_4], 0
.text$mn:00001026                 mov     eax, [ebp+var_1C]
.text$mn:00001029                 add     eax, 1
.text$mn:0000102C                 push    eax
.text$mn:0000102D                 lea     ecx, [ebp+var_11]
.text$mn:00001030                 push    ecx
.text$mn:00001031                 mov     ecx, [ebp+var_18]
.text$mn:00001034                 call    ?_Getal@?$_String_alloc@$0A@U?$_String_base_types@DV?$allocator@D@std@@@std@@@std@@QBE?AU?$_Wrap_alloc@V?$allocator@D@std@@@2@XZ ; std::_String_alloc<0,std::_String_base_types<char,std::allocator<char>>>::_Getal(void)
.text$mn:00001039                 mov     ecx, eax
.text$mn:0000103B                 call    ?allocate@?$_Wrap_alloc@V?$allocator@D@std@@@std@@QAEPADI@Z ; std::_Wrap_alloc<std::allocator<char>>::allocate(uint)
.text$mn:00001040                 mov     [ebp+var_20], eax
.text$mn:00001043                 jmp     short loc_10A2
.text$mn:00001043 ?_Copy@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEXII@Z endp
.text$mn:00001043
.text$mn:00001045
.text$mn:00001045 ; =============== S U B R O U T I N E =======================================
.text$mn:00001045
.text$mn:00001045
.text$mn:00001045 __catch$?_Copy@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEXII@Z$0 proc near
.text$mn:00001045                                         ; DATA XREF: .xdata$x:0000206Co
.text$mn:00001045
.text$mn:00001045 ; FUNCTION CHUNK AT .text$mn:0000108C SIZE 00000009 BYTES
.text$mn:00001045 ; FUNCTION CHUNK AT .text$mn:0000109C SIZE 00000006 BYTES
.text$mn:00001045
.text$mn:00001045                 mov     [ebp-10h], esp
.text$mn:00001048                 mov     edx, [ebp+8]
.text$mn:0000104B                 mov     [ebp-1Ch], edx
.text$mn:0000104E                 mov     byte ptr [ebp-4], 2
.text$mn:00001052                 mov     eax, [ebp-1Ch]
.text$mn:00001055                 add     eax, 1
.text$mn:00001058                 push    eax
.text$mn:00001059                 lea     ecx, [ebp-12h]
.text$mn:0000105C                 push    ecx
.text$mn:0000105D                 mov     ecx, [ebp-18h]
.text$mn:00001060                 call    ?_Getal@?$_String_alloc@$0A@U?$_String_base_types@DV?$allocator@D@std@@@std@@@std@@QBE?AU?$_Wrap_alloc@V?$allocator@D@std@@@2@XZ ; std::_String_alloc<0,std::_String_base_types<char,std::allocator<char>>>::_Getal(void)
.text$mn:00001065                 mov     ecx, eax
.text$mn:00001067                 call    ?allocate@?$_Wrap_alloc@V?$allocator@D@std@@@std@@QAEPADI@Z ; std::_Wrap_alloc<std::allocator<char>>::allocate(uint)
.text$mn:0000106C                 mov     [ebp-20h], eax
.text$mn:0000106F                 jmp     short loc_108C
.text$mn:0000106F __catch$?_Copy@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEXII@Z$0 endp
.text$mn:0000106F
.text$mn:00001071
.text$mn:00001071 ; =============== S U B R O U T I N E =======================================
.text$mn:00001071
.text$mn:00001071 ; Attributes: noreturn
.text$mn:00001071
.text$mn:00001071 __catch$?_Copy@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEXII@Z$1 proc near
.text$mn:00001071                                         ; DATA XREF: .xdata$x:0000207Co
.text$mn:00001071                 push    0               ; Size
.text$mn:00001073                 push    1               ; char
.text$mn:00001075                 mov     ecx, [ebp-18h]
.text$mn:00001078                 call    ?_Tidy@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEX_NI@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char>>::_Tidy(bool,uint)
.text$mn:0000107D                 push    0
.text$mn:0000107F                 push    0
.text$mn:00001081                 call    __CxxThrowException@8 ; _CxxThrowException(x,x)
.text$mn:00001081 __catch$?_Copy@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEXII@Z$1 endp
.text$mn:00001081
.text$mn:00001086 ; ---------------------------------------------------------------------------
.text$mn:00001086                 mov     eax, offset $LN17
.text$mn:0000108B                 retn
.text$mn:0000108C ; ---------------------------------------------------------------------------
.text$mn:0000108C ; START OF FUNCTION CHUNK FOR __catch$?_Copy@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEXII@Z$0
.text$mn:0000108C
.text$mn:0000108C loc_108C:                               ; CODE XREF: __catch$?_Copy@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEXII@Z$0+2Aj
.text$mn:0000108C                 mov     dword ptr [ebp-4], 1
.text$mn:00001093                 jmp     short loc_109C
.text$mn:00001093 ; END OF FUNCTION CHUNK FOR __catch$?_Copy@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEXII@Z$0
.text$mn:00001095
.text$mn:00001095 ; =============== S U B R O U T I N E =======================================
.text$mn:00001095
.text$mn:00001095
.text$mn:00001095 $LN17           proc near               ; DATA XREF: .text$mn:00001086o
.text$mn:00001095                 mov     dword ptr [ebp-4], 1
.text$mn:00001095 $LN17           endp ; sp-analysis failed
.text$mn:00001095
.text$mn:0000109C ; START OF FUNCTION CHUNK FOR __catch$?_Copy@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEXII@Z$0
.text$mn:0000109C
.text$mn:0000109C loc_109C:                               ; CODE XREF: __catch$?_Copy@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEXII@Z$0+4Ej
.text$mn:0000109C                 mov     eax, offset $LN19
.text$mn:000010A1                 retn
.text$mn:000010A1 ; END OF FUNCTION CHUNK FOR __catch$?_Copy@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEXII@Z$0
.text$mn:000010A2 ; ---------------------------------------------------------------------------
.text$mn:000010A2 ; START OF FUNCTION CHUNK FOR ?_Copy@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEXII@Z
.text$mn:000010A2
.text$mn:000010A2 loc_10A2:                               ; CODE XREF: std::basic_string<char,std::char_traits<char>,std::allocator<char>>::_Copy(uint,uint)+C3j
.text$mn:000010A2                 mov     [ebp+var_4], 0FFFFFFFFh
.text$mn:000010A9                 jmp     short loc_10B2
.text$mn:000010A9 ; END OF FUNCTION CHUNK FOR ?_Copy@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEXII@Z
.text$mn:000010AB
.text$mn:000010AB ; =============== S U B R O U T I N E =======================================
.text$mn:000010AB
.text$mn:000010AB
.text$mn:000010AB $LN19           proc near               ; DATA XREF: __catch$?_Copy@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEXII@Z$0:loc_109Co
.text$mn:000010AB                 mov     dword ptr [ebp-4], 0FFFFFFFFh
.text$mn:000010B2
.text$mn:000010B2 loc_10B2:                               ; CODE XREF: std::basic_string<char,std::char_traits<char>,std::allocator<char>>::_Copy(uint,uint)+129j
.text$mn:000010B2                 cmp     dword ptr [ebp+0Ch], 0
.text$mn:000010B6                 jbe     short loc_10D1
.text$mn:000010B8                 mov     edx, [ebp+0Ch]
.text$mn:000010BB                 push    edx             ; Size
.text$mn:000010BC                 mov     ecx, [ebp-18h]
.text$mn:000010BF                 call    ?_Myptr@?$_String_val@U?$_Simple_types@D@std@@@std@@QAEPADXZ ; std::_String_val<std::_Simple_types<char>>::_Myptr(void)
.text$mn:000010C4                 push    eax             ; Src
.text$mn:000010C5                 mov     eax, [ebp-20h]
.text$mn:000010C8                 push    eax             ; Dst
.text$mn:000010C9                 call    ?copy@?$char_traits@D@std@@SAPADPADPBDI@Z ; std::char_traits<char>::copy(char *,char const *,uint)
.text$mn:000010CE                 add     esp, 0Ch
.text$mn:000010D1
.text$mn:000010D1 loc_10D1:                               ; CODE XREF: $LN19+Bj
.text$mn:000010D1                 push    0               ; Size
.text$mn:000010D3                 push    1               ; char
.text$mn:000010D5                 mov     ecx, [ebp-18h]
.text$mn:000010D8                 call    ?_Tidy@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEX_NI@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char>>::_Tidy(bool,uint)
.text$mn:000010DD                 lea     ecx, [ebp-20h]
.text$mn:000010E0                 push    ecx             ; int
.text$mn:000010E1                 mov     edx, [ebp-18h]
.text$mn:000010E4                 add     edx, 4
.text$mn:000010E7                 push    edx             ; void *
.text$mn:000010E8                 lea     eax, [ebp-13h]
.text$mn:000010EB                 push    eax
.text$mn:000010EC                 mov     ecx, [ebp-18h]
.text$mn:000010EF                 call    ?_Getal@?$_String_alloc@$0A@U?$_String_base_types@DV?$allocator@D@std@@@std@@@std@@QBE?AU?$_Wrap_alloc@V?$allocator@D@std@@@2@XZ ; std::_String_alloc<0,std::_String_base_types<char,std::allocator<char>>>::_Getal(void)
.text$mn:000010F4                 mov     ecx, eax
.text$mn:000010F6                 call    ??$construct@PADAAPAD@?$_Wrap_alloc@V?$allocator@D@std@@@std@@QAEXPAPADAAPAD@Z ; std::_Wrap_alloc<std::allocator<char>>::construct<char *,char * &>(char * *,char * &)
.text$mn:000010FB                 mov     ecx, [ebp-18h]
.text$mn:000010FE                 mov     edx, [ebp-1Ch]
.text$mn:00001101                 mov     [ecx+18h], edx
.text$mn:00001104                 mov     eax, [ebp+0Ch]
.text$mn:00001107                 push    eax
.text$mn:00001108                 mov     ecx, [ebp-18h]
.text$mn:0000110B                 call    ?_Eos@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEXI@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char>>::_Eos(uint)
.text$mn:00001110                 mov     ecx, [ebp-0Ch]
.text$mn:00001113                 mov     large fs:0, ecx
.text$mn:0000111A                 pop     ecx
.text$mn:0000111B                 pop     edi
.text$mn:0000111C                 pop     esi
.text$mn:0000111D                 pop     ebx
.text$mn:0000111E                 mov     esp, ebp
.text$mn:00001120                 pop     ebp
.text$mn:00001121                 retn    8
.text$mn:00001121 $LN19           endp ; sp-analysis failed
.text$mn:00001121
.text$mn:00001121 _text$mn        ends
.text$mn:00001121
.text$x:00001124 ; ===========================================================================
.text$x:00001124
.text$x:00001124 ; Segment type: Pure code
.text$x:00001124 ; Segment permissions: Read/Execute
.text$x:00001124 _text$x         segment para public 'CODE' use32
.text$x:00001124                 assume cs:_text$x
.text$x:00001124                 ;org 1124h
.text$x:00001124 ; COMDAT (pick associative to section at F80)
.text$x:00001124                 assume es:nothing, ss:nothing, ds:_xdata$x, fs:nothing, gs:nothing
.text$x:00001124
.text$x:00001124 ; =============== S U B R O U T I N E =======================================
.text$x:00001124
.text$x:00001124
.text$x:00001124 __ehhandler$?_Copy@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEXII@Z proc near
.text$x:00001124                                         ; DATA XREF: std::basic_string<char,std::char_traits<char>,std::allocator<char>>::_Copy(uint,uint)+5o
.text$x:00001124
.text$x:00001124 arg_4           = dword ptr  8
.text$x:00001124
.text$x:00001124                 mov     edx, [esp+arg_4]
.text$x:00001128                 lea     eax, [edx+0Ch]
.text$x:0000112B                 mov     ecx, [edx-24h]
.text$x:0000112E                 xor     ecx, eax
.text$x:00001130                 call    @__security_check_cookie@4 ; __security_check_cookie(x)
.text$x:00001135                 mov     eax, offset __ehfuncinfo$?_Copy@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEXII@Z
.text$x:0000113A                 jmp     ___CxxFrameHandler3
.text$x:0000113A __ehhandler$?_Copy@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEXII@Z endp
.text$x:0000113A
.text$x:0000113A ; ---------------------------------------------------------------------------
.text$x:0000113F                 align 10h
.text$x:0000113F _text$x         ends
.text$x:0000113F
.text$mn:00001140 ; ===========================================================================
.text$mn:00001140
.text$mn:00001140 ; Segment type: Pure code
.text$mn:00001140 ; Segment permissions: Read/Execute
.text$mn:00001140 _text$mn        segment para public 'CODE' use32
.text$mn:00001140                 assume cs:_text$mn
.text$mn:00001140                 ;org 1140h
.text$mn:00001140 ; COMDAT (pick any)
.text$mn:00001140                 assume es:nothing, ss:nothing, ds:_xdata$x, fs:nothing, gs:nothing
.text$mn:00001140
.text$mn:00001140 ; =============== S U B R O U T I N E =======================================
.text$mn:00001140
.text$mn:00001140 ; Attributes: bp-based frame
.text$mn:00001140
.text$mn:00001140 ; public: void __thiscall std::basic_string<char, struct std::char_traits<char>, class std::allocator<char>>::_Eos(unsigned int)
.text$mn:00001140                 public ?_Eos@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEXI@Z
.text$mn:00001140 ?_Eos@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEXI@Z proc near
.text$mn:00001140                                         ; CODE XREF: $LN19+60p
.text$mn:00001140                                         ; std::basic_string<char,std::char_traits<char>,std::allocator<char>>::_Grow(uint,bool)+83p ...
.text$mn:00001140
.text$mn:00001140 var_8           = dword ptr -8
.text$mn:00001140 var_1           = byte ptr -1
.text$mn:00001140 arg_0           = dword ptr  8
.text$mn:00001140
.text$mn:00001140                 push    ebp
.text$mn:00001141                 mov     ebp, esp
.text$mn:00001143                 sub     esp, 8
.text$mn:00001146                 mov     [ebp+var_8], ecx
.text$mn:00001149                 mov     [ebp+var_1], 0
.text$mn:0000114D                 mov     eax, [ebp+var_8]
.text$mn:00001150                 mov     ecx, [ebp+arg_0]
.text$mn:00001153                 mov     [eax+14h], ecx
.text$mn:00001156                 lea     edx, [ebp+var_1]
.text$mn:00001159                 push    edx
.text$mn:0000115A                 mov     ecx, [ebp+var_8]
.text$mn:0000115D                 call    ?_Myptr@?$_String_val@U?$_Simple_types@D@std@@@std@@QAEPADXZ ; std::_String_val<std::_Simple_types<char>>::_Myptr(void)
.text$mn:00001162                 add     eax, [ebp+arg_0]
.text$mn:00001165                 push    eax
.text$mn:00001166                 call    ?assign@?$char_traits@D@std@@SAXAADABD@Z ; std::char_traits<char>::assign(char &,char const &)
.text$mn:0000116B                 add     esp, 8
.text$mn:0000116E                 mov     esp, ebp
.text$mn:00001170                 pop     ebp
.text$mn:00001171                 retn    4
.text$mn:00001171 ?_Eos@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEXI@Z endp
.text$mn:00001171
.text$mn:00001171 _text$mn        ends
.text$mn:00001171
.text$mn:00001174 ; ===========================================================================
.text$mn:00001174
.text$mn:00001174 ; Segment type: Pure code
.text$mn:00001174 ; Segment permissions: Read/Execute
.text$mn:00001174 _text$mn        segment para public 'CODE' use32
.text$mn:00001174                 assume cs:_text$mn
.text$mn:00001174                 ;org 1174h
.text$mn:00001174 ; COMDAT (pick any)
.text$mn:00001174                 assume es:nothing, ss:nothing, ds:_xdata$x, fs:nothing, gs:nothing
.text$mn:00001174
.text$mn:00001174 ; =============== S U B R O U T I N E =======================================
.text$mn:00001174
.text$mn:00001174 ; Attributes: bp-based frame
.text$mn:00001174
.text$mn:00001174 ; public: void __thiscall std::_String_alloc<0, struct std::_String_base_types<char, class std::allocator<char>>>::_Free_proxy(void)
.text$mn:00001174                 public ?_Free_proxy@?$_String_alloc@$0A@U?$_String_base_types@DV?$allocator@D@std@@@std@@@std@@QAEXXZ
.text$mn:00001174 ?_Free_proxy@?$_String_alloc@$0A@U?$_String_base_types@DV?$allocator@D@std@@@std@@@std@@QAEXXZ proc near
.text$mn:00001174                                         ; CODE XREF: std::_String_alloc<0,std::_String_base_types<char,std::allocator<char>>>::~_String_alloc<0,std::_String_base_types<char,std::allocator<char>>>(void)+30p
.text$mn:00001174
.text$mn:00001174 var_8           = dword ptr -8
.text$mn:00001174 var_1           = byte ptr -1
.text$mn:00001174
.text$mn:00001174                 push    ebp
.text$mn:00001175                 mov     ebp, esp
.text$mn:00001177                 sub     esp, 8
.text$mn:0000117A                 mov     [ebp+var_8], ecx
.text$mn:0000117D                 lea     ecx, [ebp+var_1]
.text$mn:00001180                 call    ??0?$allocator@U_Container_proxy@std@@@std@@QAE@XZ ; std::allocator<std::_Container_proxy>::allocator<std::_Container_proxy>(void)
.text$mn:00001185                 mov     ecx, [ebp+var_8] ; this
.text$mn:00001188                 call    ?_Orphan_all@_Container_base12@std@@QAEXXZ ; std::_Container_base12::_Orphan_all(void)
.text$mn:0000118D                 mov     eax, [ebp+var_8]
.text$mn:00001190                 mov     ecx, [eax]
.text$mn:00001192                 push    ecx
.text$mn:00001193                 lea     ecx, [ebp+var_1]
.text$mn:00001196                 call    ??$destroy@U_Container_proxy@std@@@?$allocator@U_Container_proxy@std@@@std@@QAEXPAU_Container_proxy@1@@Z ; std::allocator<std::_Container_proxy>::destroy<std::_Container_proxy>(std::_Container_proxy *)
.text$mn:0000119B                 push    1               ; int
.text$mn:0000119D                 mov     edx, [ebp+var_8]
.text$mn:000011A0                 mov     eax, [edx]
.text$mn:000011A2                 push    eax             ; void *
.text$mn:000011A3                 lea     ecx, [ebp+var_1]
.text$mn:000011A6                 call    ?deallocate@?$allocator@U_Container_proxy@std@@@std@@QAEXPAU_Container_proxy@2@I@Z ; std::allocator<std::_Container_proxy>::deallocate(std::_Container_proxy *,uint)
.text$mn:000011AB                 mov     ecx, [ebp+var_8]
.text$mn:000011AE                 mov     dword ptr [ecx], 0
.text$mn:000011B4                 mov     esp, ebp
.text$mn:000011B6                 pop     ebp
.text$mn:000011B7                 retn
.text$mn:000011B7 ?_Free_proxy@?$_String_alloc@$0A@U?$_String_base_types@DV?$allocator@D@std@@@std@@@std@@QAEXXZ endp
.text$mn:000011B7
.text$mn:000011B7 _text$mn        ends
.text$mn:000011B7
.text$mn:000011B8 ; ===========================================================================
.text$mn:000011B8
.text$mn:000011B8 ; Segment type: Pure code
.text$mn:000011B8 ; Segment permissions: Read/Execute
.text$mn:000011B8 _text$mn        segment para public 'CODE' use32
.text$mn:000011B8                 assume cs:_text$mn
.text$mn:000011B8                 ;org 11B8h
.text$mn:000011B8 ; COMDAT (pick any)
.text$mn:000011B8                 assume es:nothing, ss:nothing, ds:_xdata$x, fs:nothing, gs:nothing
.text$mn:000011B8
.text$mn:000011B8 ; =============== S U B R O U T I N E =======================================
.text$mn:000011B8
.text$mn:000011B8 ; Attributes: bp-based frame
.text$mn:000011B8
.text$mn:000011B8 ; public: struct std::_Wrap_alloc<class std::allocator<char>> __thiscall std::_String_alloc<0, struct std::_String_base_types<char, class std::allocator<char>>>::_Getal(void)const
.text$mn:000011B8                 public ?_Getal@?$_String_alloc@$0A@U?$_String_base_types@DV?$allocator@D@std@@@std@@@std@@QBE?AU?$_Wrap_alloc@V?$allocator@D@std@@@2@XZ
.text$mn:000011B8 ?_Getal@?$_String_alloc@$0A@U?$_String_base_types@DV?$allocator@D@std@@@std@@@std@@QBE?AU?$_Wrap_alloc@V?$allocator@D@std@@@2@XZ proc near
.text$mn:000011B8                                         ; CODE XREF: std::basic_string<char,std::char_traits<char>,std::allocator<char>>::_Copy(uint,uint)+B4p
.text$mn:000011B8                                         ; __catch$?_Copy@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEXII@Z$0+1Bp ...
.text$mn:000011B8
.text$mn:000011B8 var_4           = dword ptr -4
.text$mn:000011B8 arg_0           = dword ptr  8
.text$mn:000011B8
.text$mn:000011B8                 push    ebp
.text$mn:000011B9                 mov     ebp, esp
.text$mn:000011BB                 push    ecx
.text$mn:000011BC                 mov     [ebp+var_4], ecx
.text$mn:000011BF                 mov     ecx, [ebp+arg_0]
.text$mn:000011C2                 call    ??0?$_Wrap_alloc@V?$allocator@D@std@@@std@@QAE@XZ ; std::_Wrap_alloc<std::allocator<char>>::_Wrap_alloc<std::allocator<char>>(void)
.text$mn:000011C7                 mov     eax, [ebp+arg_0]
.text$mn:000011CA                 mov     esp, ebp
.text$mn:000011CC                 pop     ebp
.text$mn:000011CD                 retn    4
.text$mn:000011CD ?_Getal@?$_String_alloc@$0A@U?$_String_base_types@DV?$allocator@D@std@@@std@@@std@@QBE?AU?$_Wrap_alloc@V?$allocator@D@std@@@2@XZ endp
.text$mn:000011CD
.text$mn:000011CD _text$mn        ends
.text$mn:000011CD
.text$mn:000011D0 ; ===========================================================================
.text$mn:000011D0
.text$mn:000011D0 ; Segment type: Pure code
.text$mn:000011D0 ; Segment permissions: Read/Execute
.text$mn:000011D0 _text$mn        segment para public 'CODE' use32
.text$mn:000011D0                 assume cs:_text$mn
.text$mn:000011D0                 ;org 11D0h
.text$mn:000011D0 ; COMDAT (pick any)
.text$mn:000011D0                 assume es:nothing, ss:nothing, ds:_xdata$x, fs:nothing, gs:nothing
.text$mn:000011D0
.text$mn:000011D0 ; =============== S U B R O U T I N E =======================================
.text$mn:000011D0
.text$mn:000011D0 ; Attributes: bp-based frame
.text$mn:000011D0
.text$mn:000011D0 ; public: bool __thiscall std::basic_string<char, struct std::char_traits<char>, class std::allocator<char>>::_Grow(unsigned int, bool)
.text$mn:000011D0                 public ?_Grow@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE_NI_N@Z
.text$mn:000011D0 ?_Grow@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE_NI_N@Z proc near
.text$mn:000011D0                                         ; CODE XREF: std::basic_string<char,std::char_traits<char>,std::allocator<char>>::assign(std::basic_string<char,std::char_traits<char>,std::allocator<char>> const &,uint,uint)+6Ap
.text$mn:000011D0                                         ; std::basic_string<char,std::char_traits<char>,std::allocator<char>>::assign(char const *,uint)+5Fp
.text$mn:000011D0
.text$mn:000011D0 var_C           = dword ptr -0Ch
.text$mn:000011D0 Size            = dword ptr -8
.text$mn:000011D0 var_4           = dword ptr -4
.text$mn:000011D0 arg_0           = dword ptr  8
.text$mn:000011D0 arg_4           = byte ptr  0Ch
.text$mn:000011D0
.text$mn:000011D0                 push    ebp
.text$mn:000011D1                 mov     ebp, esp
.text$mn:000011D3                 sub     esp, 0Ch
.text$mn:000011D6                 mov     [ebp+var_4], ecx
.text$mn:000011D9                 mov     ecx, [ebp+var_4]
.text$mn:000011DC                 call    ?max_size@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QBEIXZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char>>::max_size(void)
.text$mn:000011E1                 cmp     eax, [ebp+arg_0]
.text$mn:000011E4                 jnb     short loc_11EE
.text$mn:000011E6                 mov     ecx, [ebp+var_4]
.text$mn:000011E9                 call    ?_Xlen@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QBEXXZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char>>::_Xlen(void)
.text$mn:000011EE
.text$mn:000011EE loc_11EE:                               ; CODE XREF: std::basic_string<char,std::char_traits<char>,std::allocator<char>>::_Grow(uint,bool)+14j
.text$mn:000011EE                 mov     eax, [ebp+var_4]
.text$mn:000011F1                 mov     ecx, [eax+18h]
.text$mn:000011F4                 cmp     ecx, [ebp+arg_0]
.text$mn:000011F7                 jnb     short loc_120E
.text$mn:000011F9                 mov     edx, [ebp+var_4]
.text$mn:000011FC                 mov     eax, [edx+14h]
.text$mn:000011FF                 push    eax
.text$mn:00001200                 mov     ecx, [ebp+arg_0]
.text$mn:00001203                 push    ecx
.text$mn:00001204                 mov     ecx, [ebp+var_4]
.text$mn:00001207                 call    ?_Copy@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEXII@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char>>::_Copy(uint,uint)
.text$mn:0000120C                 jmp     short loc_1258
.text$mn:0000120E ; ---------------------------------------------------------------------------
.text$mn:0000120E
.text$mn:0000120E loc_120E:                               ; CODE XREF: std::basic_string<char,std::char_traits<char>,std::allocator<char>>::_Grow(uint,bool)+27j
.text$mn:0000120E                 movzx   edx, [ebp+arg_4]
.text$mn:00001212                 test    edx, edx
.text$mn:00001214                 jz      short loc_1248
.text$mn:00001216                 cmp     [ebp+arg_0], 10h
.text$mn:0000121A                 jnb     short loc_1248
.text$mn:0000121C                 mov     eax, [ebp+var_4]
.text$mn:0000121F                 mov     ecx, [ebp+arg_0]
.text$mn:00001222                 cmp     ecx, [eax+14h]
.text$mn:00001225                 jnb     short loc_122F
.text$mn:00001227                 mov     edx, [ebp+arg_0]
.text$mn:0000122A                 mov     [ebp+Size], edx
.text$mn:0000122D                 jmp     short loc_1238
.text$mn:0000122F ; ---------------------------------------------------------------------------
.text$mn:0000122F
.text$mn:0000122F loc_122F:                               ; CODE XREF: std::basic_string<char,std::char_traits<char>,std::allocator<char>>::_Grow(uint,bool)+55j
.text$mn:0000122F                 mov     eax, [ebp+var_4]
.text$mn:00001232                 mov     ecx, [eax+14h]
.text$mn:00001235                 mov     [ebp+Size], ecx
.text$mn:00001238
.text$mn:00001238 loc_1238:                               ; CODE XREF: std::basic_string<char,std::char_traits<char>,std::allocator<char>>::_Grow(uint,bool)+5Dj
.text$mn:00001238                 mov     edx, [ebp+Size]
.text$mn:0000123B                 push    edx             ; Size
.text$mn:0000123C                 push    1               ; char
.text$mn:0000123E                 mov     ecx, [ebp+var_4]
.text$mn:00001241                 call    ?_Tidy@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEX_NI@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char>>::_Tidy(bool,uint)
.text$mn:00001246                 jmp     short loc_1258
.text$mn:00001248 ; ---------------------------------------------------------------------------
.text$mn:00001248
.text$mn:00001248 loc_1248:                               ; CODE XREF: std::basic_string<char,std::char_traits<char>,std::allocator<char>>::_Grow(uint,bool)+44j
.text$mn:00001248                                         ; std::basic_string<char,std::char_traits<char>,std::allocator<char>>::_Grow(uint,bool)+4Aj
.text$mn:00001248                 cmp     [ebp+arg_0], 0
.text$mn:0000124C                 jnz     short loc_1258
.text$mn:0000124E                 push    0
.text$mn:00001250                 mov     ecx, [ebp+var_4]
.text$mn:00001253                 call    ?_Eos@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEXI@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char>>::_Eos(uint)
.text$mn:00001258
.text$mn:00001258 loc_1258:                               ; CODE XREF: std::basic_string<char,std::char_traits<char>,std::allocator<char>>::_Grow(uint,bool)+3Cj
.text$mn:00001258                                         ; std::basic_string<char,std::char_traits<char>,std::allocator<char>>::_Grow(uint,bool)+76j ...
.text$mn:00001258                 cmp     [ebp+arg_0], 0
.text$mn:0000125C                 jbe     short loc_1267
.text$mn:0000125E                 mov     [ebp+var_C], 1
.text$mn:00001265                 jmp     short loc_126E
.text$mn:00001267 ; ---------------------------------------------------------------------------
.text$mn:00001267
.text$mn:00001267 loc_1267:                               ; CODE XREF: std::basic_string<char,std::char_traits<char>,std::allocator<char>>::_Grow(uint,bool)+8Cj
.text$mn:00001267                 mov     [ebp+var_C], 0
.text$mn:0000126E
.text$mn:0000126E loc_126E:                               ; CODE XREF: std::basic_string<char,std::char_traits<char>,std::allocator<char>>::_Grow(uint,bool)+95j
.text$mn:0000126E                 mov     al, byte ptr [ebp+var_C]
.text$mn:00001271                 mov     esp, ebp
.text$mn:00001273                 pop     ebp
.text$mn:00001274                 retn    8
.text$mn:00001274 ?_Grow@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE_NI_N@Z endp
.text$mn:00001274
.text$mn:00001274 ; ---------------------------------------------------------------------------
.text$mn:00001277                 align 4
.text$mn:00001277 _text$mn        ends
.text$mn:00001277
.text$mn:00001278 ; ===========================================================================
.text$mn:00001278
.text$mn:00001278 ; Segment type: Pure code
.text$mn:00001278 ; Segment permissions: Read/Execute
.text$mn:00001278 _text$mn        segment para public 'CODE' use32
.text$mn:00001278                 assume cs:_text$mn
.text$mn:00001278                 ;org 1278h
.text$mn:00001278 ; COMDAT (pick any)
.text$mn:00001278                 assume es:nothing, ss:nothing, ds:_xdata$x, fs:nothing, gs:nothing
.text$mn:00001278
.text$mn:00001278 ; =============== S U B R O U T I N E =======================================
.text$mn:00001278
.text$mn:00001278 ; Attributes: bp-based frame
.text$mn:00001278
.text$mn:00001278 ; public: bool __thiscall std::basic_string<char, struct std::char_traits<char>, class std::allocator<char>>::_Inside(char const *)
.text$mn:00001278                 public ?_Inside@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE_NPBD@Z
.text$mn:00001278 ?_Inside@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE_NPBD@Z proc near
.text$mn:00001278                                         ; CODE XREF: std::basic_string<char,std::char_traits<char>,std::allocator<char>>::assign(char const *,uint)+2Ap
.text$mn:00001278
.text$mn:00001278 var_4           = dword ptr -4
.text$mn:00001278 arg_0           = dword ptr  8
.text$mn:00001278
.text$mn:00001278                 push    ebp
.text$mn:00001279                 mov     ebp, esp
.text$mn:0000127B                 push    ecx
.text$mn:0000127C                 mov     [ebp+var_4], ecx
.text$mn:0000127F                 cmp     [ebp+arg_0], 0
.text$mn:00001283                 jz      short loc_12A5
.text$mn:00001285                 mov     ecx, [ebp+var_4]
.text$mn:00001288                 call    ?_Myptr@?$_String_val@U?$_Simple_types@D@std@@@std@@QAEPADXZ ; std::_String_val<std::_Simple_types<char>>::_Myptr(void)
.text$mn:0000128D                 cmp     [ebp+arg_0], eax
.text$mn:00001290                 jb      short loc_12A5
.text$mn:00001292                 mov     ecx, [ebp+var_4]
.text$mn:00001295                 call    ?_Myptr@?$_String_val@U?$_Simple_types@D@std@@@std@@QAEPADXZ ; std::_String_val<std::_Simple_types<char>>::_Myptr(void)
.text$mn:0000129A                 mov     ecx, [ebp+var_4]
.text$mn:0000129D                 add     eax, [ecx+14h]
.text$mn:000012A0                 cmp     eax, [ebp+arg_0]
.text$mn:000012A3                 ja      short loc_12AB
.text$mn:000012A5
.text$mn:000012A5 loc_12A5:                               ; CODE XREF: std::basic_string<char,std::char_traits<char>,std::allocator<char>>::_Inside(char const *)+Bj
.text$mn:000012A5                                         ; std::basic_string<char,std::char_traits<char>,std::allocator<char>>::_Inside(char const *)+18j
.text$mn:000012A5                 xor     al, al
.text$mn:000012A7                 jmp     short loc_12AD
.text$mn:000012A9 ; ---------------------------------------------------------------------------
.text$mn:000012A9                 jmp     short loc_12AD
.text$mn:000012AB ; ---------------------------------------------------------------------------
.text$mn:000012AB
.text$mn:000012AB loc_12AB:                               ; CODE XREF: std::basic_string<char,std::char_traits<char>,std::allocator<char>>::_Inside(char const *)+2Bj
.text$mn:000012AB                 mov     al, 1
.text$mn:000012AD
.text$mn:000012AD loc_12AD:                               ; CODE XREF: std::basic_string<char,std::char_traits<char>,std::allocator<char>>::_Inside(char const *)+2Fj
.text$mn:000012AD                                         ; std::basic_string<char,std::char_traits<char>,std::allocator<char>>::_Inside(char const *)+31j
.text$mn:000012AD                 mov     esp, ebp
.text$mn:000012AF                 pop     ebp
.text$mn:000012B0                 retn    4
.text$mn:000012B0 ?_Inside@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE_NPBD@Z endp
.text$mn:000012B0
.text$mn:000012B0 ; ---------------------------------------------------------------------------
.text$mn:000012B3                 align 4
.text$mn:000012B3 _text$mn        ends
.text$mn:000012B3
.text$mn:000012B4 ; ===========================================================================
.text$mn:000012B4
.text$mn:000012B4 ; Segment type: Pure code
.text$mn:000012B4 ; Segment permissions: Read/Execute
.text$mn:000012B4 _text$mn        segment para public 'CODE' use32
.text$mn:000012B4                 assume cs:_text$mn
.text$mn:000012B4                 ;org 12B4h
.text$mn:000012B4 ; COMDAT (pick any)
.text$mn:000012B4                 assume es:nothing, ss:nothing, ds:_xdata$x, fs:nothing, gs:nothing
.text$mn:000012B4
.text$mn:000012B4 ; =============== S U B R O U T I N E =======================================
.text$mn:000012B4
.text$mn:000012B4 ; Attributes: bp-based frame
.text$mn:000012B4
.text$mn:000012B4 ; public: char * __thiscall std::_String_val<struct std::_Simple_types<char>>::_Myptr(void)
.text$mn:000012B4                 public ?_Myptr@?$_String_val@U?$_Simple_types@D@std@@@std@@QAEPADXZ
.text$mn:000012B4 ?_Myptr@?$_String_val@U?$_Simple_types@D@std@@@std@@QAEPADXZ proc near
.text$mn:000012B4                                         ; CODE XREF: $LN19+14p
.text$mn:000012B4                                         ; std::basic_string<char,std::char_traits<char>,std::allocator<char>>::_Eos(uint)+1Dp ...
.text$mn:000012B4
.text$mn:000012B4 var_8           = dword ptr -8
.text$mn:000012B4 var_4           = dword ptr -4
.text$mn:000012B4
.text$mn:000012B4                 push    ebp
.text$mn:000012B5                 mov     ebp, esp
.text$mn:000012B7                 sub     esp, 8
.text$mn:000012BA                 mov     [ebp+var_4], ecx
.text$mn:000012BD                 mov     eax, [ebp+var_4]
.text$mn:000012C0                 cmp     dword ptr [eax+18h], 10h
.text$mn:000012C4                 jb      short loc_12DA
.text$mn:000012C6                 mov     ecx, [ebp+var_4]
.text$mn:000012C9                 mov     edx, [ecx+4]
.text$mn:000012CC                 push    edx
.text$mn:000012CD                 call    ??$addressof@D@std@@YAPADAAD@Z ; std::addressof<char>(char &)
.text$mn:000012D2                 add     esp, 4
.text$mn:000012D5                 mov     [ebp+var_8], eax
.text$mn:000012D8                 jmp     short loc_12E3
.text$mn:000012DA ; ---------------------------------------------------------------------------
.text$mn:000012DA
.text$mn:000012DA loc_12DA:                               ; CODE XREF: std::_String_val<std::_Simple_types<char>>::_Myptr(void)+10j
.text$mn:000012DA                 mov     eax, [ebp+var_4]
.text$mn:000012DD                 add     eax, 4
.text$mn:000012E0                 mov     [ebp+var_8], eax
.text$mn:000012E3
.text$mn:000012E3 loc_12E3:                               ; CODE XREF: std::_String_val<std::_Simple_types<char>>::_Myptr(void)+24j
.text$mn:000012E3                 mov     eax, [ebp+var_8]
.text$mn:000012E6                 mov     esp, ebp
.text$mn:000012E8                 pop     ebp
.text$mn:000012E9                 retn
.text$mn:000012E9 ?_Myptr@?$_String_val@U?$_Simple_types@D@std@@@std@@QAEPADXZ endp
.text$mn:000012E9
.text$mn:000012E9 ; ---------------------------------------------------------------------------
.text$mn:000012EA                 align 4
.text$mn:000012EA _text$mn        ends
.text$mn:000012EA
.text$mn:000012EC ; ===========================================================================
.text$mn:000012EC
.text$mn:000012EC ; Segment type: Pure code
.text$mn:000012EC ; Segment permissions: Read/Execute
.text$mn:000012EC _text$mn        segment para public 'CODE' use32
.text$mn:000012EC                 assume cs:_text$mn
.text$mn:000012EC                 ;org 12ECh
.text$mn:000012EC ; COMDAT (pick any)
.text$mn:000012EC                 assume es:nothing, ss:nothing, ds:_xdata$x, fs:nothing, gs:nothing
.text$mn:000012EC
.text$mn:000012EC ; =============== S U B R O U T I N E =======================================
.text$mn:000012EC
.text$mn:000012EC ; Attributes: bp-based frame
.text$mn:000012EC
.text$mn:000012EC ; public: char const * __thiscall std::_String_val<struct std::_Simple_types<char>>::_Myptr(void)const
.text$mn:000012EC                 public ?_Myptr@?$_String_val@U?$_Simple_types@D@std@@@std@@QBEPBDXZ
.text$mn:000012EC ?_Myptr@?$_String_val@U?$_Simple_types@D@std@@@std@@QBEPBDXZ proc near
.text$mn:000012EC                                         ; CODE XREF: std::basic_string<char,std::char_traits<char>,std::allocator<char>>::assign(std::basic_string<char,std::char_traits<char>,std::allocator<char>> const &,uint,uint)+7Dp
.text$mn:000012EC
.text$mn:000012EC var_8           = dword ptr -8
.text$mn:000012EC var_4           = dword ptr -4
.text$mn:000012EC
.text$mn:000012EC                 push    ebp
.text$mn:000012ED                 mov     ebp, esp
.text$mn:000012EF                 sub     esp, 8
.text$mn:000012F2                 mov     [ebp+var_4], ecx
.text$mn:000012F5                 mov     eax, [ebp+var_4]
.text$mn:000012F8                 cmp     dword ptr [eax+18h], 10h
.text$mn:000012FC                 jb      short loc_1312
.text$mn:000012FE                 mov     ecx, [ebp+var_4]
.text$mn:00001301                 mov     edx, [ecx+4]
.text$mn:00001304                 push    edx
.text$mn:00001305                 call    ??$addressof@D@std@@YAPADAAD@Z ; std::addressof<char>(char &)
.text$mn:0000130A                 add     esp, 4
.text$mn:0000130D                 mov     [ebp+var_8], eax
.text$mn:00001310                 jmp     short loc_131B
.text$mn:00001312 ; ---------------------------------------------------------------------------
.text$mn:00001312
.text$mn:00001312 loc_1312:                               ; CODE XREF: std::_String_val<std::_Simple_types<char>>::_Myptr(void)+10j
.text$mn:00001312                 mov     eax, [ebp+var_4]
.text$mn:00001315                 add     eax, 4
.text$mn:00001318                 mov     [ebp+var_8], eax
.text$mn:0000131B
.text$mn:0000131B loc_131B:                               ; CODE XREF: std::_String_val<std::_Simple_types<char>>::_Myptr(void)+24j
.text$mn:0000131B                 mov     eax, [ebp+var_8]
.text$mn:0000131E                 mov     esp, ebp
.text$mn:00001320                 pop     ebp
.text$mn:00001321                 retn
.text$mn:00001321 ?_Myptr@?$_String_val@U?$_Simple_types@D@std@@@std@@QBEPBDXZ endp
.text$mn:00001321
.text$mn:00001321 ; ---------------------------------------------------------------------------
.text$mn:00001322                 align 4
.text$mn:00001322 _text$mn        ends
.text$mn:00001322
.text$mn:00001324 ; ===========================================================================
.text$mn:00001324
.text$mn:00001324 ; Segment type: Pure code
.text$mn:00001324 ; Segment permissions: Read/Execute
.text$mn:00001324 _text$mn        segment para public 'CODE' use32
.text$mn:00001324                 assume cs:_text$mn
.text$mn:00001324                 ;org 1324h
.text$mn:00001324 ; COMDAT (pick any)
.text$mn:00001324                 assume es:nothing, ss:nothing, ds:_xdata$x, fs:nothing, gs:nothing
.text$mn:00001324
.text$mn:00001324 ; =============== S U B R O U T I N E =======================================
.text$mn:00001324
.text$mn:00001324 ; Attributes: bp-based frame
.text$mn:00001324
.text$mn:00001324 ; public: wchar_t const * __thiscall std::_String_val<struct std::_Simple_types<wchar_t>>::_Myptr(void)const
.text$mn:00001324                 public ?_Myptr@?$_String_val@U?$_Simple_types@_W@std@@@std@@QBEPB_WXZ
.text$mn:00001324 ?_Myptr@?$_String_val@U?$_Simple_types@_W@std@@@std@@QBEPB_WXZ proc near
.text$mn:00001324                                         ; CODE XREF: std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>>::c_str(void)+Ap
.text$mn:00001324                                         ; std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>>::compare(uint,uint,wchar_t const *,uint)+73p
.text$mn:00001324
.text$mn:00001324 var_8           = dword ptr -8
.text$mn:00001324 var_4           = dword ptr -4
.text$mn:00001324
.text$mn:00001324                 push    ebp
.text$mn:00001325                 mov     ebp, esp
.text$mn:00001327                 sub     esp, 8
.text$mn:0000132A                 mov     [ebp+var_4], ecx
.text$mn:0000132D                 mov     eax, [ebp+var_4]
.text$mn:00001330                 cmp     dword ptr [eax+18h], 8
.text$mn:00001334                 jb      short loc_134A
.text$mn:00001336                 mov     ecx, [ebp+var_4]
.text$mn:00001339                 mov     edx, [ecx+4]
.text$mn:0000133C                 push    edx
.text$mn:0000133D                 call    ??$addressof@_W@std@@YAPA_WAA_W@Z ; std::addressof<wchar_t>(wchar_t &)
.text$mn:00001342                 add     esp, 4
.text$mn:00001345                 mov     [ebp+var_8], eax
.text$mn:00001348                 jmp     short loc_1353
.text$mn:0000134A ; ---------------------------------------------------------------------------
.text$mn:0000134A
.text$mn:0000134A loc_134A:                               ; CODE XREF: std::_String_val<std::_Simple_types<wchar_t>>::_Myptr(void)+10j
.text$mn:0000134A                 mov     eax, [ebp+var_4]
.text$mn:0000134D                 add     eax, 4
.text$mn:00001350                 mov     [ebp+var_8], eax
.text$mn:00001353
.text$mn:00001353 loc_1353:                               ; CODE XREF: std::_String_val<std::_Simple_types<wchar_t>>::_Myptr(void)+24j
.text$mn:00001353                 mov     eax, [ebp+var_8]
.text$mn:00001356                 mov     esp, ebp
.text$mn:00001358                 pop     ebp
.text$mn:00001359                 retn
.text$mn:00001359 ?_Myptr@?$_String_val@U?$_Simple_types@_W@std@@@std@@QBEPB_WXZ endp
.text$mn:00001359
.text$mn:00001359 ; ---------------------------------------------------------------------------
.text$mn:0000135A                 align 4
.text$mn:0000135A _text$mn        ends
.text$mn:0000135A
.text$mn:0000135C ; ===========================================================================
.text$mn:0000135C
.text$mn:0000135C ; Segment type: Pure code
.text$mn:0000135C ; Segment permissions: Read/Execute
.text$mn:0000135C _text$mn        segment para public 'CODE' use32
.text$mn:0000135C                 assume cs:_text$mn
.text$mn:0000135C                 ;org 135Ch
.text$mn:0000135C ; COMDAT (pick any)
.text$mn:0000135C                 assume es:nothing, ss:nothing, ds:_xdata$x, fs:nothing, gs:nothing
.text$mn:0000135C
.text$mn:0000135C ; =============== S U B R O U T I N E =======================================
.text$mn:0000135C
.text$mn:0000135C ; Attributes: bp-based frame
.text$mn:0000135C
.text$mn:0000135C ; void __thiscall std::_Container_base12::_Orphan_all(std::_Container_base12 *__hidden this)
.text$mn:0000135C                 public ?_Orphan_all@_Container_base12@std@@QAEXXZ
.text$mn:0000135C ?_Orphan_all@_Container_base12@std@@QAEXXZ proc near
.text$mn:0000135C                                         ; CODE XREF: std::_Container_base12::~_Container_base12(void)+Ap
.text$mn:0000135C                                         ; std::_String_alloc<0,std::_String_base_types<char,std::allocator<char>>>::_Free_proxy(void)+14p
.text$mn:0000135C
.text$mn:0000135C var_18          = byte ptr -18h
.text$mn:0000135C var_14          = dword ptr -14h
.text$mn:0000135C var_10          = dword ptr -10h
.text$mn:0000135C var_C           = dword ptr -0Ch
.text$mn:0000135C var_4           = dword ptr -4
.text$mn:0000135C
.text$mn:0000135C                 push    ebp
.text$mn:0000135D                 mov     ebp, esp
.text$mn:0000135F                 push    0FFFFFFFFh
.text$mn:00001361                 push    offset __ehhandler$?_Orphan_all@_Container_base12@std@@QAEXXZ
.text$mn:00001366                 mov     eax, large fs:0
.text$mn:0000136C                 push    eax
.text$mn:0000136D                 sub     esp, 0Ch
.text$mn:00001370                 mov     eax, dword ptr ds:___security_cookie
.text$mn:00001375                 xor     eax, ebp
.text$mn:00001377                 push    eax
.text$mn:00001378                 lea     eax, [ebp+var_C]
.text$mn:0000137B                 mov     large fs:0, eax
.text$mn:00001381                 mov     [ebp+var_14], ecx
.text$mn:00001384                 mov     eax, [ebp+var_14]
.text$mn:00001387                 cmp     dword ptr [eax], 0
.text$mn:0000138A                 jz      short loc_13E7
.text$mn:0000138C                 push    3               ; int
.text$mn:0000138E                 lea     ecx, [ebp+var_18] ; this
.text$mn:00001391                 call    ??0_Lockit@std@@QAE@H@Z ; std::_Lockit::_Lockit(int)
.text$mn:00001396                 mov     [ebp+var_4], 0
.text$mn:0000139D                 mov     ecx, [ebp+var_14]
.text$mn:000013A0                 mov     edx, [ecx]
.text$mn:000013A2                 add     edx, 4
.text$mn:000013A5                 mov     [ebp+var_10], edx
.text$mn:000013A8                 jmp     short loc_13B7
.text$mn:000013AA ; ---------------------------------------------------------------------------
.text$mn:000013AA
.text$mn:000013AA loc_13AA:                               ; CODE XREF: std::_Container_base12::_Orphan_all(void)+6Ej
.text$mn:000013AA                 mov     eax, [ebp+var_10]
.text$mn:000013AD                 mov     ecx, [eax]
.text$mn:000013AF                 mov     edx, [ebp+var_10]
.text$mn:000013B2                 mov     eax, [ecx+4]
.text$mn:000013B5                 mov     [edx], eax
.text$mn:000013B7
.text$mn:000013B7 loc_13B7:                               ; CODE XREF: std::_Container_base12::_Orphan_all(void)+4Cj
.text$mn:000013B7                 mov     ecx, [ebp+var_10]
.text$mn:000013BA                 cmp     dword ptr [ecx], 0
.text$mn:000013BD                 jz      short loc_13CC
.text$mn:000013BF                 mov     edx, [ebp+var_10]
.text$mn:000013C2                 mov     eax, [edx]
.text$mn:000013C4                 mov     dword ptr [eax], 0
.text$mn:000013CA                 jmp     short loc_13AA
.text$mn:000013CC ; ---------------------------------------------------------------------------
.text$mn:000013CC
.text$mn:000013CC loc_13CC:                               ; CODE XREF: std::_Container_base12::_Orphan_all(void)+61j
.text$mn:000013CC                 mov     ecx, [ebp+var_14]
.text$mn:000013CF                 mov     edx, [ecx]
.text$mn:000013D1                 mov     dword ptr [edx+4], 0
.text$mn:000013D8                 mov     [ebp+var_4], 0FFFFFFFFh
.text$mn:000013DF                 lea     ecx, [ebp+var_18] ; this
.text$mn:000013E2                 call    ??1_Lockit@std@@QAE@XZ ; std::_Lockit::~_Lockit(void)
.text$mn:000013E7
.text$mn:000013E7 loc_13E7:                               ; CODE XREF: std::_Container_base12::_Orphan_all(void)+2Ej
.text$mn:000013E7                 mov     ecx, [ebp+var_C]
.text$mn:000013EA                 mov     large fs:0, ecx
.text$mn:000013F1                 pop     ecx
.text$mn:000013F2                 mov     esp, ebp
.text$mn:000013F4                 pop     ebp
.text$mn:000013F5                 retn
.text$mn:000013F5 ?_Orphan_all@_Container_base12@std@@QAEXXZ endp
.text$mn:000013F5
.text$mn:000013F5 ; ---------------------------------------------------------------------------
.text$mn:000013F6                 align 4
.text$mn:000013F6 _text$mn        ends
.text$mn:000013F6
.text$x:000013F8 ; ===========================================================================
.text$x:000013F8
.text$x:000013F8 ; Segment type: Pure code
.text$x:000013F8 ; Segment permissions: Read/Execute
.text$x:000013F8 _text$x         segment para public 'CODE' use32
.text$x:000013F8                 assume cs:_text$x
.text$x:000013F8                 ;org 13F8h
.text$x:000013F8 ; COMDAT (pick associative to section at 135C)
.text$x:000013F8                 assume es:nothing, ss:nothing, ds:_xdata$x, fs:nothing, gs:nothing
.text$x:000013F8
.text$x:000013F8 ; =============== S U B R O U T I N E =======================================
.text$x:000013F8
.text$x:000013F8
.text$x:000013F8 __unwindfunclet$?_Orphan_all@_Container_base12@std@@QAEXXZ$0 proc near
.text$x:000013F8                                         ; DATA XREF: .xdata$x:00001F30o
.text$x:000013F8                 lea     ecx, [ebp-18h]  ; this
.text$x:000013FB                 jmp     ??1_Lockit@std@@QAE@XZ ; std::_Lockit::~_Lockit(void)
.text$x:000013FB __unwindfunclet$?_Orphan_all@_Container_base12@std@@QAEXXZ$0 endp
.text$x:000013FB
.text$x:00001400
.text$x:00001400 ; =============== S U B R O U T I N E =======================================
.text$x:00001400
.text$x:00001400
.text$x:00001400 __ehhandler$?_Orphan_all@_Container_base12@std@@QAEXXZ proc near
.text$x:00001400                                         ; DATA XREF: std::_Container_base12::_Orphan_all(void)+5o
.text$x:00001400
.text$x:00001400 arg_4           = dword ptr  8
.text$x:00001400
.text$x:00001400                 mov     edx, [esp+arg_4]
.text$x:00001404                 lea     eax, [edx+0Ch]
.text$x:00001407                 mov     ecx, [edx-10h]
.text$x:0000140A                 xor     ecx, eax
.text$x:0000140C                 call    @__security_check_cookie@4 ; __security_check_cookie(x)
.text$x:00001411                 mov     eax, offset __ehfuncinfo$?_Orphan_all@_Container_base12@std@@QAEXXZ
.text$x:00001416                 jmp     ___CxxFrameHandler3
.text$x:00001416 __ehhandler$?_Orphan_all@_Container_base12@std@@QAEXXZ endp
.text$x:00001416
.text$x:00001416 ; ---------------------------------------------------------------------------
.text$x:0000141B                 align 4
.text$x:0000141B _text$x         ends
.text$x:0000141B
.text$mn:0000141C ; ===========================================================================
.text$mn:0000141C
.text$mn:0000141C ; Segment type: Pure code
.text$mn:0000141C ; Segment permissions: Read/Execute
.text$mn:0000141C _text$mn        segment para public 'CODE' use32
.text$mn:0000141C                 assume cs:_text$mn
.text$mn:0000141C                 ;org 141Ch
.text$mn:0000141C ; COMDAT (pick any)
.text$mn:0000141C                 assume es:nothing, ss:nothing, ds:_xdata$x, fs:nothing, gs:nothing
.text$mn:0000141C
.text$mn:0000141C ; =============== S U B R O U T I N E =======================================
.text$mn:0000141C
.text$mn:0000141C ; Attributes: bp-based frame
.text$mn:0000141C
.text$mn:0000141C ; int __stdcall std::basic_string<char,std::char_traits<char>,std::allocator<char>>::_Tidy(char, size_t Size)
.text$mn:0000141C                 public ?_Tidy@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEX_NI@Z
.text$mn:0000141C ?_Tidy@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEX_NI@Z proc near
.text$mn:0000141C                                         ; CODE XREF: std::basic_string<char,std::char_traits<char>,std::allocator<char>>::basic_string<char,std::char_traits<char>,std::allocator<char>>(char const *)+47p
.text$mn:0000141C                                         ; std::basic_string<char,std::char_traits<char>,std::allocator<char>>::~basic_string<char,std::char_traits<char>,std::allocator<char>>(void)+34p ...
.text$mn:0000141C
.text$mn:0000141C var_C           = dword ptr -0Ch
.text$mn:0000141C var_8           = dword ptr -8
.text$mn:0000141C var_2           = byte ptr -2
.text$mn:0000141C var_1           = byte ptr -1
.text$mn:0000141C arg_0           = byte ptr  8
.text$mn:0000141C Size            = dword ptr  0Ch
.text$mn:0000141C
.text$mn:0000141C                 push    ebp
.text$mn:0000141D                 mov     ebp, esp
.text$mn:0000141F                 sub     esp, 0Ch
.text$mn:00001422                 mov     [ebp+var_8], ecx
.text$mn:00001425                 movzx   eax, [ebp+arg_0]
.text$mn:00001429                 test    eax, eax
.text$mn:0000142B                 jnz     short loc_142F
.text$mn:0000142D                 jmp     short loc_14A2
.text$mn:0000142F ; ---------------------------------------------------------------------------
.text$mn:0000142F
.text$mn:0000142F loc_142F:                               ; CODE XREF: std::basic_string<char,std::char_traits<char>,std::allocator<char>>::_Tidy(bool,uint)+Fj
.text$mn:0000142F                 mov     ecx, [ebp+var_8]
.text$mn:00001432                 cmp     dword ptr [ecx+18h], 10h
.text$mn:00001436                 jb      short loc_14A2
.text$mn:00001438                 mov     edx, [ebp+var_8]
.text$mn:0000143B                 mov     eax, [edx+4]
.text$mn:0000143E                 mov     [ebp+var_C], eax
.text$mn:00001441                 mov     ecx, [ebp+var_8]
.text$mn:00001444                 add     ecx, 4
.text$mn:00001447                 push    ecx
.text$mn:00001448                 lea     edx, [ebp+var_1]
.text$mn:0000144B                 push    edx
.text$mn:0000144C                 mov     ecx, [ebp+var_8]
.text$mn:0000144F                 call    ?_Getal@?$_String_alloc@$0A@U?$_String_base_types@DV?$allocator@D@std@@@std@@@std@@QBE?AU?$_Wrap_alloc@V?$allocator@D@std@@@2@XZ ; std::_String_alloc<0,std::_String_base_types<char,std::allocator<char>>>::_Getal(void)
.text$mn:00001454                 mov     ecx, eax
.text$mn:00001456                 call    ??$destroy@PAD@?$_Wrap_alloc@V?$allocator@D@std@@@std@@QAEXPAPAD@Z ; std::_Wrap_alloc<std::allocator<char>>::destroy<char *>(char * *)
.text$mn:0000145B                 cmp     [ebp+Size], 0
.text$mn:0000145F                 jbe     short loc_1481
.text$mn:00001461                 mov     eax, [ebp+Size]
.text$mn:00001464                 push    eax             ; Size
.text$mn:00001465                 mov     ecx, [ebp+var_C]
.text$mn:00001468                 push    ecx
.text$mn:00001469                 call    ??$addressof@D@std@@YAPADAAD@Z ; std::addressof<char>(char &)
.text$mn:0000146E                 add     esp, 4
.text$mn:00001471                 push    eax             ; Src
.text$mn:00001472                 mov     edx, [ebp+var_8]
.text$mn:00001475                 add     edx, 4
.text$mn:00001478                 push    edx             ; Dst
.text$mn:00001479                 call    ?copy@?$char_traits@D@std@@SAPADPADPBDI@Z ; std::char_traits<char>::copy(char *,char const *,uint)
.text$mn:0000147E                 add     esp, 0Ch
.text$mn:00001481
.text$mn:00001481 loc_1481:                               ; CODE XREF: std::basic_string<char,std::char_traits<char>,std::allocator<char>>::_Tidy(bool,uint)+43j
.text$mn:00001481                 mov     eax, [ebp+var_8]
.text$mn:00001484                 mov     ecx, [eax+18h]
.text$mn:00001487                 add     ecx, 1
.text$mn:0000148A                 push    ecx             ; int
.text$mn:0000148B                 mov     edx, [ebp+var_C]
.text$mn:0000148E                 push    edx             ; void *
.text$mn:0000148F                 lea     eax, [ebp+var_2]
.text$mn:00001492                 push    eax
.text$mn:00001493                 mov     ecx, [ebp+var_8]
.text$mn:00001496                 call    ?_Getal@?$_String_alloc@$0A@U?$_String_base_types@DV?$allocator@D@std@@@std@@@std@@QBE?AU?$_Wrap_alloc@V?$allocator@D@std@@@2@XZ ; std::_String_alloc<0,std::_String_base_types<char,std::allocator<char>>>::_Getal(void)
.text$mn:0000149B                 mov     ecx, eax
.text$mn:0000149D                 call    ?deallocate@?$_Wrap_alloc@V?$allocator@D@std@@@std@@QAEXPADI@Z ; std::_Wrap_alloc<std::allocator<char>>::deallocate(char *,uint)
.text$mn:000014A2
.text$mn:000014A2 loc_14A2:                               ; CODE XREF: std::basic_string<char,std::char_traits<char>,std::allocator<char>>::_Tidy(bool,uint)+11j
.text$mn:000014A2                                         ; std::basic_string<char,std::char_traits<char>,std::allocator<char>>::_Tidy(bool,uint)+1Aj
.text$mn:000014A2                 mov     ecx, [ebp+var_8]
.text$mn:000014A5                 mov     dword ptr [ecx+18h], 0Fh
.text$mn:000014AC                 mov     edx, [ebp+Size]
.text$mn:000014AF                 push    edx
.text$mn:000014B0                 mov     ecx, [ebp+var_8]
.text$mn:000014B3                 call    ?_Eos@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEXI@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char>>::_Eos(uint)
.text$mn:000014B8                 mov     esp, ebp
.text$mn:000014BA                 pop     ebp
.text$mn:000014BB                 retn    8
.text$mn:000014BB ?_Tidy@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEX_NI@Z endp
.text$mn:000014BB
.text$mn:000014BB ; ---------------------------------------------------------------------------
.text$mn:000014BE                 align 10h
.text$mn:000014BE _text$mn        ends
.text$mn:000014BE
.text$mn:000014C0 ; ===========================================================================
.text$mn:000014C0
.text$mn:000014C0 ; Segment type: Pure code
.text$mn:000014C0 ; Segment permissions: Read/Execute
.text$mn:000014C0 _text$mn        segment para public 'CODE' use32
.text$mn:000014C0                 assume cs:_text$mn
.text$mn:000014C0                 ;org 14C0h
.text$mn:000014C0 ; COMDAT (pick any)
.text$mn:000014C0                 assume es:nothing, ss:nothing, ds:_xdata$x, fs:nothing, gs:nothing
.text$mn:000014C0
.text$mn:000014C0 ; =============== S U B R O U T I N E =======================================
.text$mn:000014C0
.text$mn:000014C0 ; Attributes: bp-based frame
.text$mn:000014C0
.text$mn:000014C0 ; public: void __thiscall std::basic_string<char, struct std::char_traits<char>, class std::allocator<char>>::_Xlen(void)const
.text$mn:000014C0                 public ?_Xlen@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QBEXXZ
.text$mn:000014C0 ?_Xlen@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QBEXXZ proc near
.text$mn:000014C0                                         ; CODE XREF: std::basic_string<char,std::char_traits<char>,std::allocator<char>>::_Grow(uint,bool)+19p
.text$mn:000014C0
.text$mn:000014C0 var_4           = dword ptr -4
.text$mn:000014C0
.text$mn:000014C0                 push    ebp
.text$mn:000014C1                 mov     ebp, esp
.text$mn:000014C3                 push    ecx
.text$mn:000014C4                 mov     [ebp+var_4], ecx
.text$mn:000014C7                 push    offset ??_C@_0BA@JFNIOLAK@string?5too?5long?$AA@ ; "string too long"
.text$mn:000014CC                 call    ?_Xlength_error@std@@YAXPBD@Z ; std::_Xlength_error(char const *)
.text$mn:000014D1                 mov     esp, ebp
.text$mn:000014D3                 pop     ebp
.text$mn:000014D4                 retn
.text$mn:000014D4 ?_Xlen@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QBEXXZ endp
.text$mn:000014D4
.text$mn:000014D4 ; ---------------------------------------------------------------------------
.text$mn:000014D5                 align 4
.text$mn:000014D5 _text$mn        ends
.text$mn:000014D5
.text$mn:000014D8 ; ===========================================================================
.text$mn:000014D8
.text$mn:000014D8 ; Segment type: Pure code
.text$mn:000014D8 ; Segment permissions: Read/Execute
.text$mn:000014D8 _text$mn        segment para public 'CODE' use32
.text$mn:000014D8                 assume cs:_text$mn
.text$mn:000014D8                 ;org 14D8h
.text$mn:000014D8 ; COMDAT (pick any)
.text$mn:000014D8                 assume es:nothing, ss:nothing, ds:_xdata$x, fs:nothing, gs:nothing
.text$mn:000014D8
.text$mn:000014D8 ; =============== S U B R O U T I N E =======================================
.text$mn:000014D8
.text$mn:000014D8 ; Attributes: bp-based frame
.text$mn:000014D8
.text$mn:000014D8 ; public: void __thiscall std::basic_string<char, struct std::char_traits<char>, class std::allocator<char>>::_Xran(void)const
.text$mn:000014D8                 public ?_Xran@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QBEXXZ
.text$mn:000014D8 ?_Xran@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QBEXXZ proc near
.text$mn:000014D8                                         ; CODE XREF: std::basic_string<char,std::char_traits<char>,std::allocator<char>>::assign(std::basic_string<char,std::char_traits<char>,std::allocator<char>> const &,uint,uint)+19p
.text$mn:000014D8                                         ; std::basic_string<char,std::char_traits<char>,std::allocator<char>>::erase(uint)+15p ...
.text$mn:000014D8
.text$mn:000014D8 var_4           = dword ptr -4
.text$mn:000014D8
.text$mn:000014D8                 push    ebp
.text$mn:000014D9                 mov     ebp, esp
.text$mn:000014DB                 push    ecx
.text$mn:000014DC                 mov     [ebp+var_4], ecx
.text$mn:000014DF                 push    offset ??_C@_0BI@CFPLBAOH@invalid?5string?5position?$AA@ ; "invalid string position"
.text$mn:000014E4                 call    ?_Xout_of_range@std@@YAXPBD@Z ; std::_Xout_of_range(char const *)
.text$mn:000014E9                 mov     esp, ebp
.text$mn:000014EB                 pop     ebp
.text$mn:000014EC                 retn
.text$mn:000014EC ?_Xran@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QBEXXZ endp
.text$mn:000014EC
.text$mn:000014EC ; ---------------------------------------------------------------------------
.text$mn:000014ED                 align 10h
.text$mn:000014ED _text$mn        ends
.text$mn:000014ED
.text$mn:000014F0 ; ===========================================================================
.text$mn:000014F0
.text$mn:000014F0 ; Segment type: Pure code
.text$mn:000014F0 ; Segment permissions: Read/Execute
.text$mn:000014F0 _text$mn        segment para public 'CODE' use32
.text$mn:000014F0                 assume cs:_text$mn
.text$mn:000014F0                 ;org 14F0h
.text$mn:000014F0 ; COMDAT (pick any)
.text$mn:000014F0                 assume es:nothing, ss:nothing, ds:_xdata$x, fs:nothing, gs:nothing
.text$mn:000014F0
.text$mn:000014F0 ; =============== S U B R O U T I N E =======================================
.text$mn:000014F0
.text$mn:000014F0 ; Attributes: bp-based frame
.text$mn:000014F0
.text$mn:000014F0 ; public: void __thiscall std::basic_string<wchar_t, struct std::char_traits<wchar_t>, class std::allocator<wchar_t>>::_Xran(void)const
.text$mn:000014F0                 public ?_Xran@?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QBEXXZ
.text$mn:000014F0 ?_Xran@?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QBEXXZ proc near
.text$mn:000014F0                                         ; CODE XREF: std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>>::compare(uint,uint,wchar_t const *,uint)+33p
.text$mn:000014F0
.text$mn:000014F0 var_4           = dword ptr -4
.text$mn:000014F0
.text$mn:000014F0                 push    ebp
.text$mn:000014F1                 mov     ebp, esp
.text$mn:000014F3                 push    ecx
.text$mn:000014F4                 mov     [ebp+var_4], ecx
.text$mn:000014F7                 push    offset ??_C@_0BI@CFPLBAOH@invalid?5string?5position?$AA@ ; "invalid string position"
.text$mn:000014FC                 call    ?_Xout_of_range@std@@YAXPBD@Z ; std::_Xout_of_range(char const *)
.text$mn:00001501                 mov     esp, ebp
.text$mn:00001503                 pop     ebp
.text$mn:00001504                 retn
.text$mn:00001504 ?_Xran@?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QBEXXZ endp
.text$mn:00001504
.text$mn:00001504 ; ---------------------------------------------------------------------------
.text$mn:00001505                 align 4
.text$mn:00001505 _text$mn        ends
.text$mn:00001505
.text$mn:00001508 ; ===========================================================================
.text$mn:00001508
.text$mn:00001508 ; Segment type: Pure code
.text$mn:00001508 ; Segment permissions: Read/Execute
.text$mn:00001508 _text$mn        segment para public 'CODE' use32
.text$mn:00001508                 assume cs:_text$mn
.text$mn:00001508                 ;org 1508h
.text$mn:00001508 ; COMDAT (pick any)
.text$mn:00001508                 assume es:nothing, ss:nothing, ds:_xdata$x, fs:nothing, gs:nothing
.text$mn:00001508
.text$mn:00001508 ; =============== S U B R O U T I N E =======================================
.text$mn:00001508
.text$mn:00001508 ; Attributes: bp-based frame
.text$mn:00001508
.text$mn:00001508 ; public: char * __thiscall std::_Wrap_alloc<class std::allocator<char>>::allocate(unsigned int)
.text$mn:00001508                 public ?allocate@?$_Wrap_alloc@V?$allocator@D@std@@@std@@QAEPADI@Z
.text$mn:00001508 ?allocate@?$_Wrap_alloc@V?$allocator@D@std@@@std@@QAEPADI@Z proc near
.text$mn:00001508                                         ; CODE XREF: std::basic_string<char,std::char_traits<char>,std::allocator<char>>::_Copy(uint,uint)+BBp
.text$mn:00001508                                         ; __catch$?_Copy@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEXII@Z$0+22p
.text$mn:00001508
.text$mn:00001508 var_4           = dword ptr -4
.text$mn:00001508 arg_0           = dword ptr  8
.text$mn:00001508
.text$mn:00001508                 push    ebp
.text$mn:00001509                 mov     ebp, esp
.text$mn:0000150B                 push    ecx
.text$mn:0000150C                 mov     [ebp+var_4], ecx
.text$mn:0000150F                 mov     eax, [ebp+arg_0]
.text$mn:00001512                 push    eax
.text$mn:00001513                 mov     ecx, [ebp+var_4]
.text$mn:00001516                 call    ?allocate@?$allocator@D@std@@QAEPADI@Z ; std::allocator<char>::allocate(uint)
.text$mn:0000151B                 mov     esp, ebp
.text$mn:0000151D                 pop     ebp
.text$mn:0000151E                 retn    4
.text$mn:0000151E ?allocate@?$_Wrap_alloc@V?$allocator@D@std@@@std@@QAEPADI@Z endp
.text$mn:0000151E
.text$mn:0000151E ; ---------------------------------------------------------------------------
.text$mn:00001521                 align 4
.text$mn:00001521 _text$mn        ends
.text$mn:00001521
.text$mn:00001524 ; ===========================================================================
.text$mn:00001524
.text$mn:00001524 ; Segment type: Pure code
.text$mn:00001524 ; Segment permissions: Read/Execute
.text$mn:00001524 _text$mn        segment para public 'CODE' use32
.text$mn:00001524                 assume cs:_text$mn
.text$mn:00001524                 ;org 1524h
.text$mn:00001524 ; COMDAT (pick any)
.text$mn:00001524                 assume es:nothing, ss:nothing, ds:_xdata$x, fs:nothing, gs:nothing
.text$mn:00001524
.text$mn:00001524 ; =============== S U B R O U T I N E =======================================
.text$mn:00001524
.text$mn:00001524 ; Attributes: bp-based frame
.text$mn:00001524
.text$mn:00001524 ; public: char * __thiscall std::allocator<char>::allocate(unsigned int)
.text$mn:00001524                 public ?allocate@?$allocator@D@std@@QAEPADI@Z
.text$mn:00001524 ?allocate@?$allocator@D@std@@QAEPADI@Z proc near
.text$mn:00001524                                         ; CODE XREF: std::_Wrap_alloc<std::allocator<char>>::allocate(uint)+Ep
.text$mn:00001524
.text$mn:00001524 var_4           = dword ptr -4
.text$mn:00001524 arg_0           = dword ptr  8
.text$mn:00001524
.text$mn:00001524                 push    ebp
.text$mn:00001525                 mov     ebp, esp
.text$mn:00001527                 push    ecx
.text$mn:00001528                 mov     [ebp+var_4], ecx
.text$mn:0000152B                 push    0
.text$mn:0000152D                 mov     eax, [ebp+arg_0]
.text$mn:00001530                 push    eax
.text$mn:00001531                 call    ??$_Allocate@D@std@@YAPADIPAD@Z ; std::_Allocate<char>(uint,char *)
.text$mn:00001536                 add     esp, 8
.text$mn:00001539                 mov     esp, ebp
.text$mn:0000153B                 pop     ebp
.text$mn:0000153C                 retn    4
.text$mn:0000153C ?allocate@?$allocator@D@std@@QAEPADI@Z endp
.text$mn:0000153C
.text$mn:0000153C ; ---------------------------------------------------------------------------
.text$mn:0000153F                 align 10h
.text$mn:0000153F _text$mn        ends
.text$mn:0000153F
.text$mn:00001540 ; ===========================================================================
.text$mn:00001540
.text$mn:00001540 ; Segment type: Pure code
.text$mn:00001540 ; Segment permissions: Read/Execute
.text$mn:00001540 _text$mn        segment para public 'CODE' use32
.text$mn:00001540                 assume cs:_text$mn
.text$mn:00001540                 ;org 1540h
.text$mn:00001540 ; COMDAT (pick any)
.text$mn:00001540                 assume es:nothing, ss:nothing, ds:_xdata$x, fs:nothing, gs:nothing
.text$mn:00001540
.text$mn:00001540 ; =============== S U B R O U T I N E =======================================
.text$mn:00001540
.text$mn:00001540 ; Attributes: bp-based frame
.text$mn:00001540
.text$mn:00001540 ; public: struct std::_Container_proxy * __thiscall std::allocator<struct std::_Container_proxy>::allocate(unsigned int)
.text$mn:00001540                 public ?allocate@?$allocator@U_Container_proxy@std@@@std@@QAEPAU_Container_proxy@2@I@Z
.text$mn:00001540 ?allocate@?$allocator@U_Container_proxy@std@@@std@@QAEPAU_Container_proxy@2@I@Z proc near
.text$mn:00001540                                         ; CODE XREF: std::_String_alloc<0,std::_String_base_types<char,std::allocator<char>>>::_Alloc_proxy(void)+16p
.text$mn:00001540
.text$mn:00001540 var_4           = dword ptr -4
.text$mn:00001540 arg_0           = dword ptr  8
.text$mn:00001540
.text$mn:00001540                 push    ebp
.text$mn:00001541                 mov     ebp, esp
.text$mn:00001543                 push    ecx
.text$mn:00001544                 mov     [ebp+var_4], ecx
.text$mn:00001547                 push    0
.text$mn:00001549                 mov     eax, [ebp+arg_0]
.text$mn:0000154C                 push    eax
.text$mn:0000154D                 call    ??$_Allocate@U_Container_proxy@std@@@std@@YAPAU_Container_proxy@0@IPAU10@@Z ; std::_Allocate<std::_Container_proxy>(uint,std::_Container_proxy *)
.text$mn:00001552                 add     esp, 8
.text$mn:00001555                 mov     esp, ebp
.text$mn:00001557                 pop     ebp
.text$mn:00001558                 retn    4
.text$mn:00001558 ?allocate@?$allocator@U_Container_proxy@std@@@std@@QAEPAU_Container_proxy@2@I@Z endp
.text$mn:00001558
.text$mn:00001558 ; ---------------------------------------------------------------------------
.text$mn:0000155B                 align 4
.text$mn:0000155B _text$mn        ends
.text$mn:0000155B
.text$mn:0000155C ; ===========================================================================
.text$mn:0000155C
.text$mn:0000155C ; Segment type: Pure code
.text$mn:0000155C ; Segment permissions: Read/Execute
.text$mn:0000155C _text$mn        segment para public 'CODE' use32
.text$mn:0000155C                 assume cs:_text$mn
.text$mn:0000155C                 ;org 155Ch
.text$mn:0000155C ; COMDAT (pick any)
.text$mn:0000155C                 assume es:nothing, ss:nothing, ds:_xdata$x, fs:nothing, gs:nothing
.text$mn:0000155C
.text$mn:0000155C ; =============== S U B R O U T I N E =======================================
.text$mn:0000155C
.text$mn:0000155C ; Attributes: bp-based frame
.text$mn:0000155C
.text$mn:0000155C ; public: class std::basic_string<char, struct std::char_traits<char>, class std::allocator<char>> & __thiscall std::basic_string<char, struct std::char_traits<char>, class std::allocator<char>>::assign(class std::basic_string<char, struct std::char_traits<char>, class std::allocator<char>> const &, unsigned int, unsigned int)
.text$mn:0000155C                 public ?assign@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV12@ABV12@II@Z
.text$mn:0000155C ?assign@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV12@ABV12@II@Z proc near
.text$mn:0000155C                                         ; CODE XREF: std::basic_string<char,std::char_traits<char>,std::allocator<char>>::assign(char const *,uint)+4Fp
.text$mn:0000155C
.text$mn:0000155C Size            = dword ptr -8
.text$mn:0000155C var_4           = dword ptr -4
.text$mn:0000155C arg_0           = dword ptr  8
.text$mn:0000155C arg_4           = dword ptr  0Ch
.text$mn:0000155C arg_8           = dword ptr  10h
.text$mn:0000155C
.text$mn:0000155C                 push    ebp
.text$mn:0000155D                 mov     ebp, esp
.text$mn:0000155F                 sub     esp, 8
.text$mn:00001562                 mov     [ebp+var_4], ecx
.text$mn:00001565                 mov     ecx, [ebp+arg_0]
.text$mn:00001568                 call    ?size@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QBEIXZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char>>::size(void)
.text$mn:0000156D                 cmp     eax, [ebp+arg_4]
.text$mn:00001570                 jnb     short loc_157A
.text$mn:00001572                 mov     ecx, [ebp+var_4]
.text$mn:00001575                 call    ?_Xran@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QBEXXZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char>>::_Xran(void)
.text$mn:0000157A
.text$mn:0000157A loc_157A:                               ; CODE XREF: std::basic_string<char,std::char_traits<char>,std::allocator<char>>::assign(std::basic_string<char,std::char_traits<char>,std::allocator<char>> const &,uint,uint)+14j
.text$mn:0000157A                 mov     ecx, [ebp+arg_0]
.text$mn:0000157D                 call    ?size@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QBEIXZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char>>::size(void)
.text$mn:00001582                 sub     eax, [ebp+arg_4]
.text$mn:00001585                 mov     [ebp+Size], eax
.text$mn:00001588                 mov     eax, [ebp+arg_8]
.text$mn:0000158B                 cmp     eax, [ebp+Size]
.text$mn:0000158E                 jnb     short loc_1596
.text$mn:00001590                 mov     ecx, [ebp+arg_8]
.text$mn:00001593                 mov     [ebp+Size], ecx
.text$mn:00001596
.text$mn:00001596 loc_1596:                               ; CODE XREF: std::basic_string<char,std::char_traits<char>,std::allocator<char>>::assign(std::basic_string<char,std::char_traits<char>,std::allocator<char>> const &,uint,uint)+32j
.text$mn:00001596                 mov     edx, [ebp+var_4]
.text$mn:00001599                 cmp     edx, [ebp+arg_0]
.text$mn:0000159C                 jnz     short loc_15BD
.text$mn:0000159E                 mov     eax, [ebp+arg_4]
.text$mn:000015A1                 add     eax, [ebp+Size]
.text$mn:000015A4                 push    eax
.text$mn:000015A5                 mov     ecx, [ebp+var_4]
.text$mn:000015A8                 call    ?erase@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV12@I@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char>>::erase(uint)
.text$mn:000015AD                 mov     ecx, [ebp+arg_4]
.text$mn:000015B0                 push    ecx
.text$mn:000015B1                 push    0
.text$mn:000015B3                 mov     ecx, [ebp+var_4]
.text$mn:000015B6                 call    ?erase@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV12@II@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char>>::erase(uint,uint)
.text$mn:000015BB                 jmp     short loc_15FF
.text$mn:000015BD ; ---------------------------------------------------------------------------
.text$mn:000015BD
.text$mn:000015BD loc_15BD:                               ; CODE XREF: std::basic_string<char,std::char_traits<char>,std::allocator<char>>::assign(std::basic_string<char,std::char_traits<char>,std::allocator<char>> const &,uint,uint)+40j
.text$mn:000015BD                 push    0
.text$mn:000015BF                 mov     edx, [ebp+Size]
.text$mn:000015C2                 push    edx
.text$mn:000015C3                 mov     ecx, [ebp+var_4]
.text$mn:000015C6                 call    ?_Grow@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE_NI_N@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char>>::_Grow(uint,bool)
.text$mn:000015CB                 movzx   eax, al
.text$mn:000015CE                 test    eax, eax
.text$mn:000015D0                 jz      short loc_15FF
.text$mn:000015D2                 mov     ecx, [ebp+Size]
.text$mn:000015D5                 push    ecx             ; Size
.text$mn:000015D6                 mov     ecx, [ebp+arg_0]
.text$mn:000015D9                 call    ?_Myptr@?$_String_val@U?$_Simple_types@D@std@@@std@@QBEPBDXZ ; std::_String_val<std::_Simple_types<char>>::_Myptr(void)
.text$mn:000015DE                 add     eax, [ebp+arg_4]
.text$mn:000015E1                 push    eax             ; Src
.text$mn:000015E2                 mov     ecx, [ebp+var_4]
.text$mn:000015E5                 call    ?_Myptr@?$_String_val@U?$_Simple_types@D@std@@@std@@QAEPADXZ ; std::_String_val<std::_Simple_types<char>>::_Myptr(void)
.text$mn:000015EA                 push    eax             ; Dst
.text$mn:000015EB                 call    ?copy@?$char_traits@D@std@@SAPADPADPBDI@Z ; std::char_traits<char>::copy(char *,char const *,uint)
.text$mn:000015F0                 add     esp, 0Ch
.text$mn:000015F3                 mov     edx, [ebp+Size]
.text$mn:000015F6                 push    edx
.text$mn:000015F7                 mov     ecx, [ebp+var_4]
.text$mn:000015FA                 call    ?_Eos@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEXI@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char>>::_Eos(uint)
.text$mn:000015FF
.text$mn:000015FF loc_15FF:                               ; CODE XREF: std::basic_string<char,std::char_traits<char>,std::allocator<char>>::assign(std::basic_string<char,std::char_traits<char>,std::allocator<char>> const &,uint,uint)+5Fj
.text$mn:000015FF                                         ; std::basic_string<char,std::char_traits<char>,std::allocator<char>>::assign(std::basic_string<char,std::char_traits<char>,std::allocator<char>> const &,uint,uint)+74j
.text$mn:000015FF                 mov     eax, [ebp+var_4]
.text$mn:00001602                 mov     esp, ebp
.text$mn:00001604                 pop     ebp
.text$mn:00001605                 retn    0Ch
.text$mn:00001605 ?assign@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV12@ABV12@II@Z endp
.text$mn:00001605
.text$mn:00001605 _text$mn        ends
.text$mn:00001605
.text$mn:00001608 ; ===========================================================================
.text$mn:00001608
.text$mn:00001608 ; Segment type: Pure code
.text$mn:00001608 ; Segment permissions: Read/Execute
.text$mn:00001608 _text$mn        segment para public 'CODE' use32
.text$mn:00001608                 assume cs:_text$mn
.text$mn:00001608                 ;org 1608h
.text$mn:00001608 ; COMDAT (pick any)
.text$mn:00001608                 assume es:nothing, ss:nothing, ds:_xdata$x, fs:nothing, gs:nothing
.text$mn:00001608
.text$mn:00001608 ; =============== S U B R O U T I N E =======================================
.text$mn:00001608
.text$mn:00001608 ; Attributes: bp-based frame
.text$mn:00001608
.text$mn:00001608 ; int __stdcall std::basic_string<char,std::char_traits<char>,std::allocator<char>>::assign(char *Str)
.text$mn:00001608                 public ?assign@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV12@PBD@Z
.text$mn:00001608 ?assign@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV12@PBD@Z proc near
.text$mn:00001608                                         ; CODE XREF: std::basic_string<char,std::char_traits<char>,std::allocator<char>>::basic_string<char,std::char_traits<char>,std::allocator<char>>(char const *)+53p
.text$mn:00001608
.text$mn:00001608 var_4           = dword ptr -4
.text$mn:00001608 Str             = dword ptr  8
.text$mn:00001608
.text$mn:00001608                 push    ebp
.text$mn:00001609                 mov     ebp, esp
.text$mn:0000160B                 push    ecx
.text$mn:0000160C                 mov     [ebp+var_4], ecx
.text$mn:0000160F                 push    490h            ; unsigned int
.text$mn:00001614                 push    offset ??_C@_1IO@FEAPGJBD@?$AAC?$AA?3?$AA?2?$AAP?$AAr?$AAo?$AAg?$AAr?$AAa?$AAm?$AA?5?$AAF?$AAi?$AAl?$AAe?$AAs?$AA?5?$AA?$CI?$AAx?$AA8?$AA6?$AA?$CJ?$AA?2?$AAM?$AAi?$AAc?$AAr?$AAo?$AAs?$AAo?$AAf?$AAt@ ; "C:\\Program Files (x86)\\Microsoft Visu"...
.text$mn:00001619                 mov     eax, [ebp+Str]
.text$mn:0000161C                 push    eax             ; int
.text$mn:0000161D                 call    ??$_Debug_pointer@D@std@@YAXPBDPB_WI@Z ; std::_Debug_pointer<char>(char const *,wchar_t const *,uint)
.text$mn:00001622                 add     esp, 0Ch
.text$mn:00001625                 mov     ecx, [ebp+Str]
.text$mn:00001628                 push    ecx             ; Str
.text$mn:00001629                 call    ?length@?$char_traits@D@std@@SAIPBD@Z ; std::char_traits<char>::length(char const *)
.text$mn:0000162E                 add     esp, 4
.text$mn:00001631                 push    eax             ; Size
.text$mn:00001632                 mov     edx, [ebp+Str]
.text$mn:00001635                 push    edx             ; Src
.text$mn:00001636                 mov     ecx, [ebp+var_4]
.text$mn:00001639                 call    ?assign@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV12@PBDI@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char>>::assign(char const *,uint)
.text$mn:0000163E                 mov     esp, ebp
.text$mn:00001640                 pop     ebp
.text$mn:00001641                 retn    4
.text$mn:00001641 ?assign@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV12@PBD@Z endp
.text$mn:00001641
.text$mn:00001641 _text$mn        ends
.text$mn:00001641
.text$mn:00001644 ; ===========================================================================
.text$mn:00001644
.text$mn:00001644 ; Segment type: Pure code
.text$mn:00001644 ; Segment permissions: Read/Execute
.text$mn:00001644 _text$mn        segment para public 'CODE' use32
.text$mn:00001644                 assume cs:_text$mn
.text$mn:00001644                 ;org 1644h
.text$mn:00001644 ; COMDAT (pick any)
.text$mn:00001644                 assume es:nothing, ss:nothing, ds:_xdata$x, fs:nothing, gs:nothing
.text$mn:00001644
.text$mn:00001644 ; =============== S U B R O U T I N E =======================================
.text$mn:00001644
.text$mn:00001644 ; Attributes: bp-based frame
.text$mn:00001644
.text$mn:00001644 ; int __stdcall std::basic_string<char,std::char_traits<char>,std::allocator<char>>::assign(void *Src, size_t Size)
.text$mn:00001644                 public ?assign@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV12@PBDI@Z
.text$mn:00001644 ?assign@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV12@PBDI@Z proc near
.text$mn:00001644                                         ; CODE XREF: std::basic_string<char,std::char_traits<char>,std::allocator<char>>::assign(char const *)+31p
.text$mn:00001644
.text$mn:00001644 var_4           = dword ptr -4
.text$mn:00001644 Src             = dword ptr  8
.text$mn:00001644 Size            = dword ptr  0Ch
.text$mn:00001644
.text$mn:00001644                 push    ebp
.text$mn:00001645                 mov     ebp, esp
.text$mn:00001647                 push    ecx
.text$mn:00001648                 mov     [ebp+var_4], ecx
.text$mn:0000164B                 cmp     [ebp+Size], 0
.text$mn:0000164F                 jz      short loc_1667
.text$mn:00001651                 push    47Fh            ; unsigned int
.text$mn:00001656                 push    offset ??_C@_1IO@FEAPGJBD@?$AAC?$AA?3?$AA?2?$AAP?$AAr?$AAo?$AAg?$AAr?$AAa?$AAm?$AA?5?$AAF?$AAi?$AAl?$AAe?$AAs?$AA?5?$AA?$CI?$AAx?$AA8?$AA6?$AA?$CJ?$AA?2?$AAM?$AAi?$AAc?$AAr?$AAo?$AAs?$AAo?$AAf?$AAt@ ; "C:\\Program Files (x86)\\Microsoft Visu"...
.text$mn:0000165B                 mov     eax, [ebp+Src]
.text$mn:0000165E                 push    eax             ; int
.text$mn:0000165F                 call    ??$_Debug_pointer@D@std@@YAXPBDPB_WI@Z ; std::_Debug_pointer<char>(char const *,wchar_t const *,uint)
.text$mn:00001664                 add     esp, 0Ch
.text$mn:00001667
.text$mn:00001667 loc_1667:                               ; CODE XREF: std::basic_string<char,std::char_traits<char>,std::allocator<char>>::assign(char const *,uint)+Bj
.text$mn:00001667                 mov     ecx, [ebp+Src]
.text$mn:0000166A                 push    ecx
.text$mn:0000166B                 mov     ecx, [ebp+var_4]
.text$mn:0000166E                 call    ?_Inside@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE_NPBD@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char>>::_Inside(char const *)
.text$mn:00001673                 movzx   edx, al
.text$mn:00001676                 test    edx, edx
.text$mn:00001678                 jz      short loc_169A
.text$mn:0000167A                 mov     eax, [ebp+Size]
.text$mn:0000167D                 push    eax
.text$mn:0000167E                 mov     ecx, [ebp+var_4]
.text$mn:00001681                 call    ?_Myptr@?$_String_val@U?$_Simple_types@D@std@@@std@@QAEPADXZ ; std::_String_val<std::_Simple_types<char>>::_Myptr(void)
.text$mn:00001686                 mov     ecx, [ebp+Src]
.text$mn:00001689                 sub     ecx, eax
.text$mn:0000168B                 push    ecx
.text$mn:0000168C                 mov     edx, [ebp+var_4]
.text$mn:0000168F                 push    edx
.text$mn:00001690                 mov     ecx, [ebp+var_4]
.text$mn:00001693                 call    ?assign@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV12@ABV12@II@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char>>::assign(std::basic_string<char,std::char_traits<char>,std::allocator<char>> const &,uint,uint)
.text$mn:00001698                 jmp     short loc_16D7
.text$mn:0000169A ; ---------------------------------------------------------------------------
.text$mn:0000169A
.text$mn:0000169A loc_169A:                               ; CODE XREF: std::basic_string<char,std::char_traits<char>,std::allocator<char>>::assign(char const *,uint)+34j
.text$mn:0000169A                 push    0
.text$mn:0000169C                 mov     eax, [ebp+Size]
.text$mn:0000169F                 push    eax
.text$mn:000016A0                 mov     ecx, [ebp+var_4]
.text$mn:000016A3                 call    ?_Grow@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE_NI_N@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char>>::_Grow(uint,bool)
.text$mn:000016A8                 movzx   ecx, al
.text$mn:000016AB                 test    ecx, ecx
.text$mn:000016AD                 jz      short loc_16D4
.text$mn:000016AF                 mov     edx, [ebp+Size]
.text$mn:000016B2                 push    edx             ; Size
.text$mn:000016B3                 mov     eax, [ebp+Src]
.text$mn:000016B6                 push    eax             ; Src
.text$mn:000016B7                 mov     ecx, [ebp+var_4]
.text$mn:000016BA                 call    ?_Myptr@?$_String_val@U?$_Simple_types@D@std@@@std@@QAEPADXZ ; std::_String_val<std::_Simple_types<char>>::_Myptr(void)
.text$mn:000016BF                 push    eax             ; Dst
.text$mn:000016C0                 call    ?copy@?$char_traits@D@std@@SAPADPADPBDI@Z ; std::char_traits<char>::copy(char *,char const *,uint)
.text$mn:000016C5                 add     esp, 0Ch
.text$mn:000016C8                 mov     ecx, [ebp+Size]
.text$mn:000016CB                 push    ecx
.text$mn:000016CC                 mov     ecx, [ebp+var_4]
.text$mn:000016CF                 call    ?_Eos@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEXI@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char>>::_Eos(uint)
.text$mn:000016D4
.text$mn:000016D4 loc_16D4:                               ; CODE XREF: std::basic_string<char,std::char_traits<char>,std::allocator<char>>::assign(char const *,uint)+69j
.text$mn:000016D4                 mov     eax, [ebp+var_4]
.text$mn:000016D7
.text$mn:000016D7 loc_16D7:                               ; CODE XREF: std::basic_string<char,std::char_traits<char>,std::allocator<char>>::assign(char const *,uint)+54j
.text$mn:000016D7                 mov     esp, ebp
.text$mn:000016D9                 pop     ebp
.text$mn:000016DA                 retn    8
.text$mn:000016DA ?assign@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV12@PBDI@Z endp
.text$mn:000016DA
.text$mn:000016DA ; ---------------------------------------------------------------------------
.text$mn:000016DD                 align 10h
.text$mn:000016DD _text$mn        ends
.text$mn:000016DD
.text$mn:000016E0 ; ===========================================================================
.text$mn:000016E0
.text$mn:000016E0 ; Segment type: Pure code
.text$mn:000016E0 ; Segment permissions: Read/Execute
.text$mn:000016E0 _text$mn        segment para public 'CODE' use32
.text$mn:000016E0                 assume cs:_text$mn
.text$mn:000016E0                 ;org 16E0h
.text$mn:000016E0 ; COMDAT (pick any)
.text$mn:000016E0                 assume es:nothing, ss:nothing, ds:_xdata$x, fs:nothing, gs:nothing
.text$mn:000016E0
.text$mn:000016E0 ; =============== S U B R O U T I N E =======================================
.text$mn:000016E0
.text$mn:000016E0 ; Attributes: bp-based frame
.text$mn:000016E0
.text$mn:000016E0 ; public: static void __cdecl std::char_traits<char>::assign(char &, char const &)
.text$mn:000016E0                 public ?assign@?$char_traits@D@std@@SAXAADABD@Z
.text$mn:000016E0 ?assign@?$char_traits@D@std@@SAXAADABD@Z proc near
.text$mn:000016E0                                         ; CODE XREF: std::basic_string<char,std::char_traits<char>,std::allocator<char>>::_Eos(uint)+26p
.text$mn:000016E0
.text$mn:000016E0 arg_0           = dword ptr  8
.text$mn:000016E0 arg_4           = dword ptr  0Ch
.text$mn:000016E0
.text$mn:000016E0                 push    ebp
.text$mn:000016E1                 mov     ebp, esp
.text$mn:000016E3                 mov     eax, [ebp+arg_0]
.text$mn:000016E6                 mov     ecx, [ebp+arg_4]
.text$mn:000016E9                 mov     dl, [ecx]
.text$mn:000016EB                 mov     [eax], dl
.text$mn:000016ED                 pop     ebp
.text$mn:000016EE                 retn
.text$mn:000016EE ?assign@?$char_traits@D@std@@SAXAADABD@Z endp
.text$mn:000016EE
.text$mn:000016EE ; ---------------------------------------------------------------------------
.text$mn:000016EF                 align 10h
.text$mn:000016EF _text$mn        ends
.text$mn:000016EF
.text$mn:000016F0 ; ===========================================================================
.text$mn:000016F0
.text$mn:000016F0 ; Segment type: Pure code
.text$mn:000016F0 ; Segment permissions: Read/Execute
.text$mn:000016F0 _text$mn        segment para public 'CODE' use32
.text$mn:000016F0                 assume cs:_text$mn
.text$mn:000016F0                 ;org 16F0h
.text$mn:000016F0 ; COMDAT (pick any)
.text$mn:000016F0                 assume es:nothing, ss:nothing, ds:_xdata$x, fs:nothing, gs:nothing
.text$mn:000016F0
.text$mn:000016F0 ; =============== S U B R O U T I N E =======================================
.text$mn:000016F0
.text$mn:000016F0 ; Attributes: bp-based frame
.text$mn:000016F0
.text$mn:000016F0 ; public: wchar_t const * __thiscall std::basic_string<wchar_t, struct std::char_traits<wchar_t>, class std::allocator<wchar_t>>::c_str(void)const
.text$mn:000016F0                 public ?c_str@?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QBEPB_WXZ
.text$mn:000016F0 ?c_str@?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QBEPB_WXZ proc near
.text$mn:000016F0                                         ; CODE XREF: ControlsTab::createTabs(std::vector<DlgInfo,std::allocator<DlgInfo>> &)+48p
.text$mn:000016F0
.text$mn:000016F0 var_4           = dword ptr -4
.text$mn:000016F0
.text$mn:000016F0                 push    ebp
.text$mn:000016F1                 mov     ebp, esp
.text$mn:000016F3                 push    ecx
.text$mn:000016F4                 mov     [ebp+var_4], ecx
.text$mn:000016F7                 mov     ecx, [ebp+var_4]
.text$mn:000016FA                 call    ?_Myptr@?$_String_val@U?$_Simple_types@_W@std@@@std@@QBEPB_WXZ ; std::_String_val<std::_Simple_types<wchar_t>>::_Myptr(void)
.text$mn:000016FF                 mov     esp, ebp
.text$mn:00001701                 pop     ebp
.text$mn:00001702                 retn
.text$mn:00001702 ?c_str@?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QBEPB_WXZ endp
.text$mn:00001702
.text$mn:00001702 ; ---------------------------------------------------------------------------
.text$mn:00001703                 align 4
.text$mn:00001703 _text$mn        ends
.text$mn:00001703
.text$mn:00001704 ; ===========================================================================
.text$mn:00001704
.text$mn:00001704 ; Segment type: Pure code
.text$mn:00001704 ; Segment permissions: Read/Execute
.text$mn:00001704 _text$mn        segment para public 'CODE' use32
.text$mn:00001704                 assume cs:_text$mn
.text$mn:00001704                 ;org 1704h
.text$mn:00001704 ; COMDAT (pick any)
.text$mn:00001704                 assume es:nothing, ss:nothing, ds:_xdata$x, fs:nothing, gs:nothing
.text$mn:00001704
.text$mn:00001704 ; =============== S U B R O U T I N E =======================================
.text$mn:00001704
.text$mn:00001704 ; Attributes: bp-based frame
.text$mn:00001704
.text$mn:00001704 ; const struct std::error_category *__thiscall std::error_code::category(std::error_code *__hidden this)
.text$mn:00001704                 public ?category@error_code@std@@QBEABVerror_category@2@XZ
.text$mn:00001704 ?category@error_code@std@@QBEABVerror_category@2@XZ proc near
.text$mn:00001704                                         ; CODE XREF: std::error_category::equivalent(std::error_code const &,int)+Cp
.text$mn:00001704
.text$mn:00001704 var_4           = dword ptr -4
.text$mn:00001704
.text$mn:00001704                 push    ebp
.text$mn:00001705                 mov     ebp, esp
.text$mn:00001707                 push    ecx
.text$mn:00001708                 mov     [ebp+var_4], ecx
.text$mn:0000170B                 mov     eax, [ebp+var_4]
.text$mn:0000170E                 mov     eax, [eax+4]
.text$mn:00001711                 mov     esp, ebp
.text$mn:00001713                 pop     ebp
.text$mn:00001714                 retn
.text$mn:00001714 ?category@error_code@std@@QBEABVerror_category@2@XZ endp
.text$mn:00001714
.text$mn:00001714 ; ---------------------------------------------------------------------------
.text$mn:00001715                 align 4
.text$mn:00001715 _text$mn        ends
.text$mn:00001715
.text$mn:00001718 ; ===========================================================================
.text$mn:00001718
.text$mn:00001718 ; Segment type: Pure code
.text$mn:00001718 ; Segment permissions: Read/Execute
.text$mn:00001718 _text$mn        segment para public 'CODE' use32
.text$mn:00001718                 assume cs:_text$mn
.text$mn:00001718                 ;org 1718h
.text$mn:00001718 ; COMDAT (pick any)
.text$mn:00001718                 assume es:nothing, ss:nothing, ds:_xdata$x, fs:nothing, gs:nothing
.text$mn:00001718
.text$mn:00001718 ; =============== S U B R O U T I N E =======================================
.text$mn:00001718
.text$mn:00001718 ; Attributes: bp-based frame
.text$mn:00001718
.text$mn:00001718 ; const struct std::error_category *__thiscall std::error_condition::category(std::error_condition *__hidden this)
.text$mn:00001718                 public ?category@error_condition@std@@QBEABVerror_category@2@XZ
.text$mn:00001718 ?category@error_condition@std@@QBEABVerror_category@2@XZ proc near
.text$mn:00001718                                         ; CODE XREF: std::error_condition::operator==(std::error_condition const &)+Dp
.text$mn:00001718                                         ; std::error_condition::operator==(std::error_condition const &)+16p
.text$mn:00001718
.text$mn:00001718 var_4           = dword ptr -4
.text$mn:00001718
.text$mn:00001718                 push    ebp
.text$mn:00001719                 mov     ebp, esp
.text$mn:0000171B                 push    ecx
.text$mn:0000171C                 mov     [ebp+var_4], ecx
.text$mn:0000171F                 mov     eax, [ebp+var_4]
.text$mn:00001722                 mov     eax, [eax+4]
.text$mn:00001725                 mov     esp, ebp
.text$mn:00001727                 pop     ebp
.text$mn:00001728                 retn
.text$mn:00001728 ?category@error_condition@std@@QBEABVerror_category@2@XZ endp
.text$mn:00001728
.text$mn:00001728 ; ---------------------------------------------------------------------------
.text$mn:00001729                 align 4
.text$mn:00001729 _text$mn        ends
.text$mn:00001729
.text$mn:0000172C ; ===========================================================================
.text$mn:0000172C
.text$mn:0000172C ; Segment type: Pure code
.text$mn:0000172C ; Segment permissions: Read/Execute
.text$mn:0000172C _text$mn        segment para public 'CODE' use32
.text$mn:0000172C                 assume cs:_text$mn
.text$mn:0000172C                 ;org 172Ch
.text$mn:0000172C ; COMDAT (pick any)
.text$mn:0000172C                 assume es:nothing, ss:nothing, ds:_xdata$x, fs:nothing, gs:nothing
.text$mn:0000172C
.text$mn:0000172C ; =============== S U B R O U T I N E =======================================
.text$mn:0000172C
.text$mn:0000172C ; Attributes: bp-based frame
.text$mn:0000172C
.text$mn:0000172C ; public: int __thiscall std::basic_string<wchar_t, struct std::char_traits<wchar_t>, class std::allocator<wchar_t>>::compare(unsigned int, unsigned int, wchar_t const *, unsigned int)const
.text$mn:0000172C                 public ?compare@?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QBEHIIPB_WI@Z
.text$mn:0000172C ?compare@?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QBEHIIPB_WI@Z proc near
.text$mn:0000172C                                         ; CODE XREF: std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>>::compare(wchar_t const *)+3Ap
.text$mn:0000172C
.text$mn:0000172C var_18          = dword ptr -18h
.text$mn:0000172C var_14          = dword ptr -14h
.text$mn:0000172C var_10          = dword ptr -10h
.text$mn:0000172C var_C           = dword ptr -0Ch
.text$mn:0000172C var_8           = dword ptr -8
.text$mn:0000172C var_4           = dword ptr -4
.text$mn:0000172C arg_0           = dword ptr  8
.text$mn:0000172C arg_4           = dword ptr  0Ch
.text$mn:0000172C arg_8           = dword ptr  10h
.text$mn:0000172C arg_C           = dword ptr  14h
.text$mn:0000172C
.text$mn:0000172C                 push    ebp
.text$mn:0000172D                 mov     ebp, esp
.text$mn:0000172F                 sub     esp, 18h
.text$mn:00001732                 mov     [ebp+var_4], ecx
.text$mn:00001735                 cmp     [ebp+arg_C], 0
.text$mn:00001739                 jz      short loc_1751
.text$mn:0000173B                 push    87Dh            ; unsigned int
.text$mn:00001740                 push    offset ??_C@_1IO@FEAPGJBD@?$AAC?$AA?3?$AA?2?$AAP?$AAr?$AAo?$AAg?$AAr?$AAa?$AAm?$AA?5?$AAF?$AAi?$AAl?$AAe?$AAs?$AA?5?$AA?$CI?$AAx?$AA8?$AA6?$AA?$CJ?$AA?2?$AAM?$AAi?$AAc?$AAr?$AAo?$AAs?$AAo?$AAf?$AAt@ ; "C:\\Program Files (x86)\\Microsoft Visu"...
.text$mn:00001745                 mov     eax, [ebp+arg_8]
.text$mn:00001748                 push    eax             ; int
.text$mn:00001749                 call    ??$_Debug_pointer@_W@std@@YAXPB_W0I@Z ; std::_Debug_pointer<wchar_t>(wchar_t const *,wchar_t const *,uint)
.text$mn:0000174E                 add     esp, 0Ch
.text$mn:00001751
.text$mn:00001751 loc_1751:                               ; CODE XREF: std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>>::compare(uint,uint,wchar_t const *,uint)+Dj
.text$mn:00001751                 mov     ecx, [ebp+var_4]
.text$mn:00001754                 mov     edx, [ecx+14h]
.text$mn:00001757                 cmp     edx, [ebp+arg_0]
.text$mn:0000175A                 jnb     short loc_1764
.text$mn:0000175C                 mov     ecx, [ebp+var_4]
.text$mn:0000175F                 call    ?_Xran@?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QBEXXZ ; std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>>::_Xran(void)
.text$mn:00001764
.text$mn:00001764 loc_1764:                               ; CODE XREF: std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>>::compare(uint,uint,wchar_t const *,uint)+2Ej
.text$mn:00001764                 mov     eax, [ebp+var_4]
.text$mn:00001767                 mov     ecx, [eax+14h]
.text$mn:0000176A                 sub     ecx, [ebp+arg_0]
.text$mn:0000176D                 cmp     ecx, [ebp+arg_4]
.text$mn:00001770                 jnb     short loc_177E
.text$mn:00001772                 mov     edx, [ebp+var_4]
.text$mn:00001775                 mov     eax, [edx+14h]
.text$mn:00001778                 sub     eax, [ebp+arg_0]
.text$mn:0000177B                 mov     [ebp+arg_4], eax
.text$mn:0000177E
.text$mn:0000177E loc_177E:                               ; CODE XREF: std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>>::compare(uint,uint,wchar_t const *,uint)+44j
.text$mn:0000177E                 mov     ecx, [ebp+arg_4]
.text$mn:00001781                 cmp     ecx, [ebp+arg_C]
.text$mn:00001784                 jnb     short loc_178E
.text$mn:00001786                 mov     edx, [ebp+arg_4]
.text$mn:00001789                 mov     [ebp+var_8], edx
.text$mn:0000178C                 jmp     short loc_1794
.text$mn:0000178E ; ---------------------------------------------------------------------------
.text$mn:0000178E
.text$mn:0000178E loc_178E:                               ; CODE XREF: std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>>::compare(uint,uint,wchar_t const *,uint)+58j
.text$mn:0000178E                 mov     eax, [ebp+arg_C]
.text$mn:00001791                 mov     [ebp+var_8], eax
.text$mn:00001794
.text$mn:00001794 loc_1794:                               ; CODE XREF: std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>>::compare(uint,uint,wchar_t const *,uint)+60j
.text$mn:00001794                 mov     ecx, [ebp+var_8]
.text$mn:00001797                 push    ecx
.text$mn:00001798                 mov     edx, [ebp+arg_8]
.text$mn:0000179B                 push    edx
.text$mn:0000179C                 mov     ecx, [ebp+var_4]
.text$mn:0000179F                 call    ?_Myptr@?$_String_val@U?$_Simple_types@_W@std@@@std@@QBEPB_WXZ ; std::_String_val<std::_Simple_types<wchar_t>>::_Myptr(void)
.text$mn:000017A4                 mov     ecx, [ebp+arg_0]
.text$mn:000017A7                 lea     edx, [eax+ecx*2]
.text$mn:000017AA                 push    edx
.text$mn:000017AB                 call    ?compare@?$char_traits@_W@std@@SAHPB_W0I@Z ; std::char_traits<wchar_t>::compare(wchar_t const *,wchar_t const *,uint)
.text$mn:000017B0                 add     esp, 0Ch
.text$mn:000017B3                 mov     [ebp+var_C], eax
.text$mn:000017B6                 cmp     [ebp+var_C], 0
.text$mn:000017BA                 jz      short loc_17C4
.text$mn:000017BC                 mov     eax, [ebp+var_C]
.text$mn:000017BF                 mov     [ebp+var_18], eax
.text$mn:000017C2                 jmp     short loc_17F9
.text$mn:000017C4 ; ---------------------------------------------------------------------------
.text$mn:000017C4
.text$mn:000017C4 loc_17C4:                               ; CODE XREF: std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>>::compare(uint,uint,wchar_t const *,uint)+8Ej
.text$mn:000017C4                 mov     ecx, [ebp+arg_4]
.text$mn:000017C7                 cmp     ecx, [ebp+arg_C]
.text$mn:000017CA                 jnb     short loc_17D5
.text$mn:000017CC                 mov     [ebp+var_14], 0FFFFFFFFh
.text$mn:000017D3                 jmp     short loc_17F3
.text$mn:000017D5 ; ---------------------------------------------------------------------------
.text$mn:000017D5
.text$mn:000017D5 loc_17D5:                               ; CODE XREF: std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>>::compare(uint,uint,wchar_t const *,uint)+9Ej
.text$mn:000017D5                 mov     edx, [ebp+arg_4]
.text$mn:000017D8                 cmp     edx, [ebp+arg_C]
.text$mn:000017DB                 jnz     short loc_17E6
.text$mn:000017DD                 mov     [ebp+var_10], 0
.text$mn:000017E4                 jmp     short loc_17ED
.text$mn:000017E6 ; ---------------------------------------------------------------------------
.text$mn:000017E6
.text$mn:000017E6 loc_17E6:                               ; CODE XREF: std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>>::compare(uint,uint,wchar_t const *,uint)+AFj
.text$mn:000017E6                 mov     [ebp+var_10], 1
.text$mn:000017ED
.text$mn:000017ED loc_17ED:                               ; CODE XREF: std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>>::compare(uint,uint,wchar_t const *,uint)+B8j
.text$mn:000017ED                 mov     eax, [ebp+var_10]
.text$mn:000017F0                 mov     [ebp+var_14], eax
.text$mn:000017F3
.text$mn:000017F3 loc_17F3:                               ; CODE XREF: std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>>::compare(uint,uint,wchar_t const *,uint)+A7j
.text$mn:000017F3                 mov     ecx, [ebp+var_14]
.text$mn:000017F6                 mov     [ebp+var_18], ecx
.text$mn:000017F9
.text$mn:000017F9 loc_17F9:                               ; CODE XREF: std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>>::compare(uint,uint,wchar_t const *,uint)+96j
.text$mn:000017F9                 mov     eax, [ebp+var_18]
.text$mn:000017FC                 mov     esp, ebp
.text$mn:000017FE                 pop     ebp
.text$mn:000017FF                 retn    10h
.text$mn:000017FF ?compare@?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QBEHIIPB_WI@Z endp
.text$mn:000017FF
.text$mn:000017FF ; ---------------------------------------------------------------------------
.text$mn:00001802                 align 4
.text$mn:00001802 _text$mn        ends
.text$mn:00001802
.text$mn:00001804 ; ===========================================================================
.text$mn:00001804
.text$mn:00001804 ; Segment type: Pure code
.text$mn:00001804 ; Segment permissions: Read/Execute
.text$mn:00001804 _text$mn        segment para public 'CODE' use32
.text$mn:00001804                 assume cs:_text$mn
.text$mn:00001804                 ;org 1804h
.text$mn:00001804 ; COMDAT (pick any)
.text$mn:00001804                 assume es:nothing, ss:nothing, ds:_xdata$x, fs:nothing, gs:nothing
.text$mn:00001804
.text$mn:00001804 ; =============== S U B R O U T I N E =======================================
.text$mn:00001804
.text$mn:00001804 ; Attributes: bp-based frame
.text$mn:00001804
.text$mn:00001804 ; int __stdcall std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>>::compare(wchar_t *Str)
.text$mn:00001804                 public ?compare@?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QBEHPB_W@Z
.text$mn:00001804 ?compare@?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QBEHPB_W@Z proc near
.text$mn:00001804                                         ; CODE XREF: std::operator==<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>>(std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>> const &,wchar_t const *)+Bp
.text$mn:00001804
.text$mn:00001804 var_4           = dword ptr -4
.text$mn:00001804 Str             = dword ptr  8
.text$mn:00001804
.text$mn:00001804                 push    ebp
.text$mn:00001805                 mov     ebp, esp
.text$mn:00001807                 push    ecx
.text$mn:00001808                 mov     [ebp+var_4], ecx
.text$mn:0000180B                 push    86Eh            ; unsigned int
.text$mn:00001810                 push    offset ??_C@_1IO@FEAPGJBD@?$AAC?$AA?3?$AA?2?$AAP?$AAr?$AAo?$AAg?$AAr?$AAa?$AAm?$AA?5?$AAF?$AAi?$AAl?$AAe?$AAs?$AA?5?$AA?$CI?$AAx?$AA8?$AA6?$AA?$CJ?$AA?2?$AAM?$AAi?$AAc?$AAr?$AAo?$AAs?$AAo?$AAf?$AAt@ ; "C:\\Program Files (x86)\\Microsoft Visu"...
.text$mn:00001815                 mov     eax, [ebp+Str]
.text$mn:00001818                 push    eax             ; int
.text$mn:00001819                 call    ??$_Debug_pointer@_W@std@@YAXPB_W0I@Z ; std::_Debug_pointer<wchar_t>(wchar_t const *,wchar_t const *,uint)
.text$mn:0000181E                 add     esp, 0Ch
.text$mn:00001821                 mov     ecx, [ebp+Str]
.text$mn:00001824                 push    ecx             ; Str
.text$mn:00001825                 call    ?length@?$char_traits@_W@std@@SAIPB_W@Z ; std::char_traits<wchar_t>::length(wchar_t const *)
.text$mn:0000182A                 add     esp, 4
.text$mn:0000182D                 push    eax
.text$mn:0000182E                 mov     edx, [ebp+Str]
.text$mn:00001831                 push    edx
.text$mn:00001832                 mov     eax, [ebp+var_4]
.text$mn:00001835                 mov     ecx, [eax+14h]
.text$mn:00001838                 push    ecx
.text$mn:00001839                 push    0
.text$mn:0000183B                 mov     ecx, [ebp+var_4]
.text$mn:0000183E                 call    ?compare@?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QBEHIIPB_WI@Z ; std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>>::compare(uint,uint,wchar_t const *,uint)
.text$mn:00001843                 mov     esp, ebp
.text$mn:00001845                 pop     ebp
.text$mn:00001846                 retn    4
.text$mn:00001846 ?compare@?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QBEHPB_W@Z endp
.text$mn:00001846
.text$mn:00001846 ; ---------------------------------------------------------------------------
.text$mn:00001849                 align 4
.text$mn:00001849 _text$mn        ends
.text$mn:00001849
.text$mn:0000184C ; ===========================================================================
.text$mn:0000184C
.text$mn:0000184C ; Segment type: Pure code
.text$mn:0000184C ; Segment permissions: Read/Execute
.text$mn:0000184C _text$mn        segment para public 'CODE' use32
.text$mn:0000184C                 assume cs:_text$mn
.text$mn:0000184C                 ;org 184Ch
.text$mn:0000184C ; COMDAT (pick any)
.text$mn:0000184C                 assume es:nothing, ss:nothing, ds:_xdata$x, fs:nothing, gs:nothing
.text$mn:0000184C
.text$mn:0000184C ; =============== S U B R O U T I N E =======================================
.text$mn:0000184C
.text$mn:0000184C ; Attributes: bp-based frame
.text$mn:0000184C
.text$mn:0000184C ; public: static int __cdecl std::char_traits<wchar_t>::compare(wchar_t const *, wchar_t const *, unsigned int)
.text$mn:0000184C                 public ?compare@?$char_traits@_W@std@@SAHPB_W0I@Z
.text$mn:0000184C ?compare@?$char_traits@_W@std@@SAHPB_W0I@Z proc near
.text$mn:0000184C                                         ; CODE XREF: std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>>::compare(uint,uint,wchar_t const *,uint)+7Fp
.text$mn:0000184C
.text$mn:0000184C var_4           = dword ptr -4
.text$mn:0000184C arg_0           = dword ptr  8
.text$mn:0000184C arg_4           = dword ptr  0Ch
.text$mn:0000184C arg_8           = dword ptr  10h
.text$mn:0000184C
.text$mn:0000184C                 push    ebp
.text$mn:0000184D                 mov     ebp, esp
.text$mn:0000184F                 push    ecx
.text$mn:00001850                 cmp     [ebp+arg_8], 0
.text$mn:00001854                 jnz     short loc_185F
.text$mn:00001856                 mov     [ebp+var_4], 0
.text$mn:0000185D                 jmp     short loc_1876
.text$mn:0000185F ; ---------------------------------------------------------------------------
.text$mn:0000185F
.text$mn:0000185F loc_185F:                               ; CODE XREF: std::char_traits<wchar_t>::compare(wchar_t const *,wchar_t const *,uint)+8j
.text$mn:0000185F                 mov     eax, [ebp+arg_8]
.text$mn:00001862                 push    eax
.text$mn:00001863                 mov     ecx, [ebp+arg_4]
.text$mn:00001866                 push    ecx
.text$mn:00001867                 mov     edx, [ebp+arg_0]
.text$mn:0000186A                 push    edx
.text$mn:0000186B                 call    _wmemcmp
.text$mn:00001870                 add     esp, 0Ch
.text$mn:00001873                 mov     [ebp+var_4], eax
.text$mn:00001876
.text$mn:00001876 loc_1876:                               ; CODE XREF: std::char_traits<wchar_t>::compare(wchar_t const *,wchar_t const *,uint)+11j
.text$mn:00001876                 mov     eax, [ebp+var_4]
.text$mn:00001879                 mov     esp, ebp
.text$mn:0000187B                 pop     ebp
.text$mn:0000187C                 retn
.text$mn:0000187C ?compare@?$char_traits@_W@std@@SAHPB_W0I@Z endp
.text$mn:0000187C
.text$mn:0000187C ; ---------------------------------------------------------------------------
.text$mn:0000187D                 align 10h
.text$mn:0000187D _text$mn        ends
.text$mn:0000187D
.text$mn:00001880 ; ===========================================================================
.text$mn:00001880
.text$mn:00001880 ; Segment type: Pure code
.text$mn:00001880 ; Segment permissions: Read/Execute
.text$mn:00001880 _text$mn        segment para public 'CODE' use32
.text$mn:00001880                 assume cs:_text$mn
.text$mn:00001880                 ;org 1880h
.text$mn:00001880 ; COMDAT (pick any)
.text$mn:00001880                 assume es:nothing, ss:nothing, ds:_xdata$x, fs:nothing, gs:nothing
.text$mn:00001880
.text$mn:00001880 ; =============== S U B R O U T I N E =======================================
.text$mn:00001880
.text$mn:00001880 ; Attributes: bp-based frame
.text$mn:00001880
.text$mn:00001880 ; int __cdecl std::char_traits<char>::copy(void *Dst, void *Src, size_t Size)
.text$mn:00001880                 public ?copy@?$char_traits@D@std@@SAPADPADPBDI@Z
.text$mn:00001880 ?copy@?$char_traits@D@std@@SAPADPADPBDI@Z proc near ; CODE XREF: $LN19+1Ep
.text$mn:00001880                                         ; std::basic_string<char,std::char_traits<char>,std::allocator<char>>::_Tidy(bool,uint)+5Dp ...
.text$mn:00001880
.text$mn:00001880 var_4           = dword ptr -4
.text$mn:00001880 Dst             = dword ptr  8
.text$mn:00001880 Src             = dword ptr  0Ch
.text$mn:00001880 Size            = dword ptr  10h
.text$mn:00001880
.text$mn:00001880                 push    ebp
.text$mn:00001881                 mov     ebp, esp
.text$mn:00001883                 push    ecx
.text$mn:00001884                 cmp     [ebp+Size], 0
.text$mn:00001888                 jnz     short loc_1892
.text$mn:0000188A                 mov     eax, [ebp+Dst]
.text$mn:0000188D                 mov     [ebp+var_4], eax
.text$mn:00001890                 jmp     short loc_18A9
.text$mn:00001892 ; ---------------------------------------------------------------------------
.text$mn:00001892
.text$mn:00001892 loc_1892:                               ; CODE XREF: std::char_traits<char>::copy(char *,char const *,uint)+8j
.text$mn:00001892                 mov     ecx, [ebp+Size]
.text$mn:00001895                 push    ecx             ; Size
.text$mn:00001896                 mov     edx, [ebp+Src]
.text$mn:00001899                 push    edx             ; Src
.text$mn:0000189A                 mov     eax, [ebp+Dst]
.text$mn:0000189D                 push    eax             ; Dst
.text$mn:0000189E                 call    _memcpy
.text$mn:000018A3                 add     esp, 0Ch
.text$mn:000018A6                 mov     [ebp+var_4], eax
.text$mn:000018A9
.text$mn:000018A9 loc_18A9:                               ; CODE XREF: std::char_traits<char>::copy(char *,char const *,uint)+10j
.text$mn:000018A9                 mov     eax, [ebp+var_4]
.text$mn:000018AC                 mov     esp, ebp
.text$mn:000018AE                 pop     ebp
.text$mn:000018AF                 retn
.text$mn:000018AF ?copy@?$char_traits@D@std@@SAPADPADPBDI@Z endp
.text$mn:000018AF
.text$mn:000018AF _text$mn        ends
.text$mn:000018AF
.text$mn:000018B0 ; ===========================================================================
.text$mn:000018B0
.text$mn:000018B0 ; Segment type: Pure code
.text$mn:000018B0 ; Segment permissions: Read/Execute
.text$mn:000018B0 _text$mn        segment para public 'CODE' use32
.text$mn:000018B0                 assume cs:_text$mn
.text$mn:000018B0                 ;org 18B0h
.text$mn:000018B0 ; COMDAT (pick any)
.text$mn:000018B0                 assume es:nothing, ss:nothing, ds:_xdata$x, fs:nothing, gs:nothing
.text$mn:000018B0
.text$mn:000018B0 ; =============== S U B R O U T I N E =======================================
.text$mn:000018B0
.text$mn:000018B0 ; Attributes: bp-based frame
.text$mn:000018B0
.text$mn:000018B0 ; int __stdcall std::_Wrap_alloc<std::allocator<char>>::deallocate(void *, int)
.text$mn:000018B0                 public ?deallocate@?$_Wrap_alloc@V?$allocator@D@std@@@std@@QAEXPADI@Z
.text$mn:000018B0 ?deallocate@?$_Wrap_alloc@V?$allocator@D@std@@@std@@QAEXPADI@Z proc near
.text$mn:000018B0                                         ; CODE XREF: std::basic_string<char,std::char_traits<char>,std::allocator<char>>::_Tidy(bool,uint)+81p
.text$mn:000018B0
.text$mn:000018B0 var_4           = dword ptr -4
.text$mn:000018B0 arg_0           = dword ptr  8
.text$mn:000018B0 arg_4           = dword ptr  0Ch
.text$mn:000018B0
.text$mn:000018B0                 push    ebp
.text$mn:000018B1                 mov     ebp, esp
.text$mn:000018B3                 push    ecx
.text$mn:000018B4                 mov     [ebp+var_4], ecx
.text$mn:000018B7                 mov     eax, [ebp+arg_4]
.text$mn:000018BA                 push    eax             ; int
.text$mn:000018BB                 mov     ecx, [ebp+arg_0]
.text$mn:000018BE                 push    ecx             ; void *
.text$mn:000018BF                 mov     ecx, [ebp+var_4]
.text$mn:000018C2                 call    ?deallocate@?$allocator@D@std@@QAEXPADI@Z ; std::allocator<char>::deallocate(char *,uint)
.text$mn:000018C7                 mov     esp, ebp
.text$mn:000018C9                 pop     ebp
.text$mn:000018CA                 retn    8
.text$mn:000018CA ?deallocate@?$_Wrap_alloc@V?$allocator@D@std@@@std@@QAEXPADI@Z endp
.text$mn:000018CA
.text$mn:000018CA ; ---------------------------------------------------------------------------
.text$mn:000018CD                 align 10h
.text$mn:000018CD _text$mn        ends
.text$mn:000018CD
.text$mn:000018D0 ; ===========================================================================
.text$mn:000018D0
.text$mn:000018D0 ; Segment type: Pure code
.text$mn:000018D0 ; Segment permissions: Read/Execute
.text$mn:000018D0 _text$mn        segment para public 'CODE' use32
.text$mn:000018D0                 assume cs:_text$mn
.text$mn:000018D0                 ;org 18D0h
.text$mn:000018D0 ; COMDAT (pick any)
.text$mn:000018D0                 assume es:nothing, ss:nothing, ds:_xdata$x, fs:nothing, gs:nothing
.text$mn:000018D0
.text$mn:000018D0 ; =============== S U B R O U T I N E =======================================
.text$mn:000018D0
.text$mn:000018D0 ; Attributes: bp-based frame
.text$mn:000018D0
.text$mn:000018D0 ; int __stdcall std::allocator<char>::deallocate(void *, int)
.text$mn:000018D0                 public ?deallocate@?$allocator@D@std@@QAEXPADI@Z
.text$mn:000018D0 ?deallocate@?$allocator@D@std@@QAEXPADI@Z proc near
.text$mn:000018D0                                         ; CODE XREF: std::_Wrap_alloc<std::allocator<char>>::deallocate(char *,uint)+12p
.text$mn:000018D0
.text$mn:000018D0 var_4           = dword ptr -4
.text$mn:000018D0 arg_0           = dword ptr  8
.text$mn:000018D0
.text$mn:000018D0                 push    ebp
.text$mn:000018D1                 mov     ebp, esp
.text$mn:000018D3                 push    ecx
.text$mn:000018D4                 mov     [ebp+var_4], ecx
.text$mn:000018D7                 mov     eax, [ebp+arg_0]
.text$mn:000018DA                 push    eax             ; void *
.text$mn:000018DB                 call    ??3@YAXPAX@Z    ; operator delete(void *)
.text$mn:000018E0                 add     esp, 4
.text$mn:000018E3                 mov     esp, ebp
.text$mn:000018E5                 pop     ebp
.text$mn:000018E6                 retn    8
.text$mn:000018E6 ?deallocate@?$allocator@D@std@@QAEXPADI@Z endp
.text$mn:000018E6
.text$mn:000018E6 ; ---------------------------------------------------------------------------
.text$mn:000018E9                 align 4
.text$mn:000018E9 _text$mn        ends
.text$mn:000018E9
.text$mn:000018EC ; ===========================================================================
.text$mn:000018EC
.text$mn:000018EC ; Segment type: Pure code
.text$mn:000018EC ; Segment permissions: Read/Execute
.text$mn:000018EC _text$mn        segment para public 'CODE' use32
.text$mn:000018EC                 assume cs:_text$mn
.text$mn:000018EC                 ;org 18ECh
.text$mn:000018EC ; COMDAT (pick any)
.text$mn:000018EC                 assume es:nothing, ss:nothing, ds:_xdata$x, fs:nothing, gs:nothing
.text$mn:000018EC
.text$mn:000018EC ; =============== S U B R O U T I N E =======================================
.text$mn:000018EC
.text$mn:000018EC ; Attributes: bp-based frame
.text$mn:000018EC
.text$mn:000018EC ; int __stdcall std::allocator<std::_Container_proxy>::deallocate(void *, int)
.text$mn:000018EC                 public ?deallocate@?$allocator@U_Container_proxy@std@@@std@@QAEXPAU_Container_proxy@2@I@Z
.text$mn:000018EC ?deallocate@?$allocator@U_Container_proxy@std@@@std@@QAEXPAU_Container_proxy@2@I@Z proc near
.text$mn:000018EC                                         ; CODE XREF: std::_String_alloc<0,std::_String_base_types<char,std::allocator<char>>>::_Free_proxy(void)+32p
.text$mn:000018EC
.text$mn:000018EC var_4           = dword ptr -4
.text$mn:000018EC arg_0           = dword ptr  8
.text$mn:000018EC
.text$mn:000018EC                 push    ebp
.text$mn:000018ED                 mov     ebp, esp
.text$mn:000018EF                 push    ecx
.text$mn:000018F0                 mov     [ebp+var_4], ecx
.text$mn:000018F3                 mov     eax, [ebp+arg_0]
.text$mn:000018F6                 push    eax             ; void *
.text$mn:000018F7                 call    ??3@YAXPAX@Z    ; operator delete(void *)
.text$mn:000018FC                 add     esp, 4
.text$mn:000018FF                 mov     esp, ebp
.text$mn:00001901                 pop     ebp
.text$mn:00001902                 retn    8
.text$mn:00001902 ?deallocate@?$allocator@U_Container_proxy@std@@@std@@QAEXPAU_Container_proxy@2@I@Z endp
.text$mn:00001902
.text$mn:00001902 ; ---------------------------------------------------------------------------
.text$mn:00001905                 align 4
.text$mn:00001905 _text$mn        ends
.text$mn:00001905
.text$mn:00001908 ; ===========================================================================
.text$mn:00001908
.text$mn:00001908 ; Segment type: Pure code
.text$mn:00001908 ; Segment permissions: Read/Execute
.text$mn:00001908 _text$mn        segment para public 'CODE' use32
.text$mn:00001908                 assume cs:_text$mn
.text$mn:00001908                 ;org 1908h
.text$mn:00001908 ; COMDAT (pick any)
.text$mn:00001908                 assume es:nothing, ss:nothing, ds:_xdata$x, fs:nothing, gs:nothing
.text$mn:00001908
.text$mn:00001908 ; =============== S U B R O U T I N E =======================================
.text$mn:00001908
.text$mn:00001908 ; Attributes: bp-based frame
.text$mn:00001908
.text$mn:00001908 ; public: virtual class std::error_condition __thiscall std::_System_error_category::default_error_condition(int)const
.text$mn:00001908                 public ?default_error_condition@_System_error_category@std@@UBE?AVerror_condition@2@H@Z
.text$mn:00001908 ?default_error_condition@_System_error_category@std@@UBE?AVerror_condition@2@H@Z proc near
.text$mn:00001908                                         ; DATA XREF: .rdata:00002374o
.text$mn:00001908
.text$mn:00001908 var_4           = dword ptr -4
.text$mn:00001908 arg_0           = dword ptr  8
.text$mn:00001908 arg_4           = dword ptr  0Ch
.text$mn:00001908
.text$mn:00001908                 push    ebp
.text$mn:00001909                 mov     ebp, esp
.text$mn:0000190B                 push    ecx
.text$mn:0000190C                 mov     [ebp+var_4], ecx
.text$mn:0000190F                 mov     eax, [ebp+arg_4]
.text$mn:00001912                 push    eax             ; int
.text$mn:00001913                 call    ?_Syserror_map@std@@YAPBDH@Z ; std::_Syserror_map(int)
.text$mn:00001918                 add     esp, 4
.text$mn:0000191B                 test    eax, eax
.text$mn:0000191D                 jz      short loc_1938
.text$mn:0000191F                 call    ?generic_category@std@@YAABVerror_category@1@XZ ; std::generic_category(void)
.text$mn:00001924                 push    eax             ; struct std::error_category *
.text$mn:00001925                 mov     ecx, [ebp+arg_4]
.text$mn:00001928                 push    ecx             ; int
.text$mn:00001929                 mov     ecx, [ebp+arg_0] ; this
.text$mn:0000192C                 call    ??0error_condition@std@@QAE@HABVerror_category@1@@Z ; std::error_condition::error_condition(int,std::error_category const &)
.text$mn:00001931                 mov     eax, [ebp+arg_0]
.text$mn:00001934                 jmp     short loc_194D
.text$mn:00001936 ; ---------------------------------------------------------------------------
.text$mn:00001936                 jmp     short loc_194D
.text$mn:00001938 ; ---------------------------------------------------------------------------
.text$mn:00001938
.text$mn:00001938 loc_1938:                               ; CODE XREF: std::_System_error_category::default_error_condition(int)+15j
.text$mn:00001938                 call    ?system_category@std@@YAABVerror_category@1@XZ ; std::system_category(void)
.text$mn:0000193D                 push    eax             ; struct std::error_category *
.text$mn:0000193E                 mov     edx, [ebp+arg_4]
.text$mn:00001941                 push    edx             ; int
.text$mn:00001942                 mov     ecx, [ebp+arg_0] ; this
.text$mn:00001945                 call    ??0error_condition@std@@QAE@HABVerror_category@1@@Z ; std::error_condition::error_condition(int,std::error_category const &)
.text$mn:0000194A                 mov     eax, [ebp+arg_0]
.text$mn:0000194D
.text$mn:0000194D loc_194D:                               ; CODE XREF: std::_System_error_category::default_error_condition(int)+2Cj
.text$mn:0000194D                                         ; std::_System_error_category::default_error_condition(int)+2Ej
.text$mn:0000194D                 mov     esp, ebp
.text$mn:0000194F                 pop     ebp
.text$mn:00001950                 retn    8
.text$mn:00001950 ?default_error_condition@_System_error_category@std@@UBE?AVerror_condition@2@H@Z endp
.text$mn:00001950
.text$mn:00001950 ; ---------------------------------------------------------------------------
.text$mn:00001953                 align 4
.text$mn:00001953 _text$mn        ends
.text$mn:00001953
.text$mn:00001954 ; ===========================================================================
.text$mn:00001954
.text$mn:00001954 ; Segment type: Pure code
.text$mn:00001954 ; Segment permissions: Read/Execute
.text$mn:00001954 _text$mn        segment para public 'CODE' use32
.text$mn:00001954                 assume cs:_text$mn
.text$mn:00001954                 ;org 1954h
.text$mn:00001954 ; COMDAT (pick any)
.text$mn:00001954                 assume es:nothing, ss:nothing, ds:_xdata$x, fs:nothing, gs:nothing
.text$mn:00001954
.text$mn:00001954 ; =============== S U B R O U T I N E =======================================
.text$mn:00001954
.text$mn:00001954 ; Attributes: bp-based frame
.text$mn:00001954
.text$mn:00001954 ; public: virtual class std::error_condition __thiscall std::error_category::default_error_condition(int)const
.text$mn:00001954                 public ?default_error_condition@error_category@std@@UBE?AVerror_condition@2@H@Z
.text$mn:00001954 ?default_error_condition@error_category@std@@UBE?AVerror_condition@2@H@Z proc near
.text$mn:00001954                                         ; DATA XREF: .rdata:000022E4o
.text$mn:00001954                                         ; .rdata:00002300o ...
.text$mn:00001954
.text$mn:00001954 var_4           = dword ptr -4
.text$mn:00001954 arg_0           = dword ptr  8
.text$mn:00001954 arg_4           = dword ptr  0Ch
.text$mn:00001954
.text$mn:00001954                 push    ebp
.text$mn:00001955                 mov     ebp, esp
.text$mn:00001957                 push    ecx
.text$mn:00001958                 mov     [ebp+var_4], ecx
.text$mn:0000195B                 mov     eax, [ebp+var_4]
.text$mn:0000195E                 push    eax             ; struct std::error_category *
.text$mn:0000195F                 mov     ecx, [ebp+arg_4]
.text$mn:00001962                 push    ecx             ; int
.text$mn:00001963                 mov     ecx, [ebp+arg_0] ; this
.text$mn:00001966                 call    ??0error_condition@std@@QAE@HABVerror_category@1@@Z ; std::error_condition::error_condition(int,std::error_category const &)
.text$mn:0000196B                 mov     eax, [ebp+arg_0]
.text$mn:0000196E                 mov     esp, ebp
.text$mn:00001970                 pop     ebp
.text$mn:00001971                 retn    8
.text$mn:00001971 ?default_error_condition@error_category@std@@UBE?AVerror_condition@2@H@Z endp
.text$mn:00001971
.text$mn:00001971 _text$mn        ends
.text$mn:00001971
.text$mn:00001974 ; ===========================================================================
.text$mn:00001974
.text$mn:00001974 ; Segment type: Pure code
.text$mn:00001974 ; Segment permissions: Read/Execute
.text$mn:00001974 _text$mn        segment para public 'CODE' use32
.text$mn:00001974                 assume cs:_text$mn
.text$mn:00001974                 ;org 1974h
.text$mn:00001974 ; COMDAT (pick any)
.text$mn:00001974                 assume es:nothing, ss:nothing, ds:_xdata$x, fs:nothing, gs:nothing
.text$mn:00001974
.text$mn:00001974 ; =============== S U B R O U T I N E =======================================
.text$mn:00001974
.text$mn:00001974 ; Attributes: bp-based frame
.text$mn:00001974
.text$mn:00001974 ; bool __thiscall std::error_category::equivalent(std::error_category *this, const struct std::error_code *, int)
.text$mn:00001974                 public ?equivalent@error_category@std@@UBE_NABVerror_code@2@H@Z
.text$mn:00001974 ?equivalent@error_category@std@@UBE_NABVerror_code@2@H@Z proc near
.text$mn:00001974                                         ; DATA XREF: .rdata:000022E8o
.text$mn:00001974                                         ; .rdata:00002304o ...
.text$mn:00001974
.text$mn:00001974 var_8           = dword ptr -8
.text$mn:00001974 var_4           = dword ptr -4
.text$mn:00001974 arg_0           = dword ptr  8
.text$mn:00001974 arg_4           = dword ptr  0Ch
.text$mn:00001974
.text$mn:00001974                 push    ebp
.text$mn:00001975                 mov     ebp, esp
.text$mn:00001977                 sub     esp, 8
.text$mn:0000197A                 mov     [ebp+var_8], ecx
.text$mn:0000197D                 mov     ecx, [ebp+arg_0] ; this
.text$mn:00001980                 call    ?category@error_code@std@@QBEABVerror_category@2@XZ ; std::error_code::category(void)
.text$mn:00001985                 push    eax
.text$mn:00001986                 mov     ecx, [ebp+var_8]
.text$mn:00001989                 call    ??8error_category@std@@QBE_NABV01@@Z ; std::error_category::operator==(std::error_category const &)
.text$mn:0000198E                 movzx   eax, al
.text$mn:00001991                 test    eax, eax
.text$mn:00001993                 jz      short loc_19AB
.text$mn:00001995                 mov     ecx, [ebp+arg_0] ; this
.text$mn:00001998                 call    ?value@error_code@std@@QBEHXZ ; std::error_code::value(void)
.text$mn:0000199D                 cmp     eax, [ebp+arg_4]
.text$mn:000019A0                 jnz     short loc_19AB
.text$mn:000019A2                 mov     [ebp+var_4], 1
.text$mn:000019A9                 jmp     short loc_19B2
.text$mn:000019AB ; ---------------------------------------------------------------------------
.text$mn:000019AB
.text$mn:000019AB loc_19AB:                               ; CODE XREF: std::error_category::equivalent(std::error_code const &,int)+1Fj
.text$mn:000019AB                                         ; std::error_category::equivalent(std::error_code const &,int)+2Cj
.text$mn:000019AB                 mov     [ebp+var_4], 0
.text$mn:000019B2
.text$mn:000019B2 loc_19B2:                               ; CODE XREF: std::error_category::equivalent(std::error_code const &,int)+35j
.text$mn:000019B2                 mov     al, byte ptr [ebp+var_4]
.text$mn:000019B5                 mov     esp, ebp
.text$mn:000019B7                 pop     ebp
.text$mn:000019B8                 retn    8
.text$mn:000019B8 ?equivalent@error_category@std@@UBE_NABVerror_code@2@H@Z endp
.text$mn:000019B8
.text$mn:000019B8 ; ---------------------------------------------------------------------------
.text$mn:000019BB                 align 4
.text$mn:000019BB _text$mn        ends
.text$mn:000019BB
.text$mn:000019BC ; ===========================================================================
.text$mn:000019BC
.text$mn:000019BC ; Segment type: Pure code
.text$mn:000019BC ; Segment permissions: Read/Execute
.text$mn:000019BC _text$mn        segment para public 'CODE' use32
.text$mn:000019BC                 assume cs:_text$mn
.text$mn:000019BC                 ;org 19BCh
.text$mn:000019BC ; COMDAT (pick any)
.text$mn:000019BC                 assume es:nothing, ss:nothing, ds:_xdata$x, fs:nothing, gs:nothing
.text$mn:000019BC
.text$mn:000019BC ; =============== S U B R O U T I N E =======================================
.text$mn:000019BC
.text$mn:000019BC ; Attributes: bp-based frame
.text$mn:000019BC
.text$mn:000019BC ; bool __thiscall std::error_category::equivalent(std::error_category *this, int, const struct std::error_condition *)
.text$mn:000019BC                 public ?equivalent@error_category@std@@UBE_NHABVerror_condition@2@@Z
.text$mn:000019BC ?equivalent@error_category@std@@UBE_NHABVerror_condition@2@@Z proc near
.text$mn:000019BC                                         ; DATA XREF: .rdata:000022ECo
.text$mn:000019BC                                         ; .rdata:00002308o ...
.text$mn:000019BC
.text$mn:000019BC var_C           = byte ptr -0Ch
.text$mn:000019BC var_4           = dword ptr -4
.text$mn:000019BC arg_0           = dword ptr  8
.text$mn:000019BC arg_4           = dword ptr  0Ch
.text$mn:000019BC
.text$mn:000019BC                 push    ebp
.text$mn:000019BD                 mov     ebp, esp
.text$mn:000019BF                 sub     esp, 0Ch
.text$mn:000019C2                 mov     [ebp+var_4], ecx
.text$mn:000019C5                 mov     eax, [ebp+arg_4]
.text$mn:000019C8                 push    eax             ; std::error_condition *
.text$mn:000019C9                 mov     ecx, [ebp+arg_0]
.text$mn:000019CC                 push    ecx
.text$mn:000019CD                 lea     edx, [ebp+var_C]
.text$mn:000019D0                 push    edx
.text$mn:000019D1                 mov     eax, [ebp+var_4]
.text$mn:000019D4                 mov     edx, [eax]
.text$mn:000019D6                 mov     ecx, [ebp+var_4]
.text$mn:000019D9                 mov     eax, [edx+0Ch]
.text$mn:000019DC                 call    eax
.text$mn:000019DE                 mov     ecx, eax
.text$mn:000019E0                 call    ??8error_condition@std@@QBE_NABV01@@Z ; std::error_condition::operator==(std::error_condition const &)
.text$mn:000019E5                 mov     esp, ebp
.text$mn:000019E7                 pop     ebp
.text$mn:000019E8                 retn    8
.text$mn:000019E8 ?equivalent@error_category@std@@UBE_NHABVerror_condition@2@@Z endp
.text$mn:000019E8
.text$mn:000019E8 ; ---------------------------------------------------------------------------
.text$mn:000019EB                 align 4
.text$mn:000019EB _text$mn        ends
.text$mn:000019EB
.text$mn:000019EC ; ===========================================================================
.text$mn:000019EC
.text$mn:000019EC ; Segment type: Pure code
.text$mn:000019EC ; Segment permissions: Read/Execute
.text$mn:000019EC _text$mn        segment para public 'CODE' use32
.text$mn:000019EC                 assume cs:_text$mn
.text$mn:000019EC                 ;org 19ECh
.text$mn:000019EC ; COMDAT (pick any)
.text$mn:000019EC                 assume es:nothing, ss:nothing, ds:_xdata$x, fs:nothing, gs:nothing
.text$mn:000019EC
.text$mn:000019EC ; =============== S U B R O U T I N E =======================================
.text$mn:000019EC
.text$mn:000019EC ; Attributes: bp-based frame
.text$mn:000019EC
.text$mn:000019EC ; public: class std::basic_string<char, struct std::char_traits<char>, class std::allocator<char>> & __thiscall std::basic_string<char, struct std::char_traits<char>, class std::allocator<char>>::erase(unsigned int)
.text$mn:000019EC                 public ?erase@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV12@I@Z
.text$mn:000019EC ?erase@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV12@I@Z proc near
.text$mn:000019EC                                         ; CODE XREF: std::basic_string<char,std::char_traits<char>,std::allocator<char>>::assign(std::basic_string<char,std::char_traits<char>,std::allocator<char>> const &,uint,uint)+4Cp
.text$mn:000019EC
.text$mn:000019EC var_4           = dword ptr -4
.text$mn:000019EC arg_0           = dword ptr  8
.text$mn:000019EC
.text$mn:000019EC                 push    ebp
.text$mn:000019ED                 mov     ebp, esp
.text$mn:000019EF                 push    ecx
.text$mn:000019F0                 mov     [ebp+var_4], ecx
.text$mn:000019F3                 mov     eax, [ebp+var_4]
.text$mn:000019F6                 mov     ecx, [eax+14h]
.text$mn:000019F9                 cmp     ecx, [ebp+arg_0]
.text$mn:000019FC                 jnb     short loc_1A06
.text$mn:000019FE                 mov     ecx, [ebp+var_4]
.text$mn:00001A01                 call    ?_Xran@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QBEXXZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char>>::_Xran(void)
.text$mn:00001A06
.text$mn:00001A06 loc_1A06:                               ; CODE XREF: std::basic_string<char,std::char_traits<char>,std::allocator<char>>::erase(uint)+10j
.text$mn:00001A06                 mov     edx, [ebp+arg_0]
.text$mn:00001A09                 push    edx
.text$mn:00001A0A                 mov     ecx, [ebp+var_4]
.text$mn:00001A0D                 call    ?_Eos@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEXI@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char>>::_Eos(uint)
.text$mn:00001A12                 mov     eax, [ebp+var_4]
.text$mn:00001A15                 mov     esp, ebp
.text$mn:00001A17                 pop     ebp
.text$mn:00001A18                 retn    4
.text$mn:00001A18 ?erase@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV12@I@Z endp
.text$mn:00001A18
.text$mn:00001A18 ; ---------------------------------------------------------------------------
.text$mn:00001A1B                 align 4
.text$mn:00001A1B _text$mn        ends
.text$mn:00001A1B
.text$mn:00001A1C ; ===========================================================================
.text$mn:00001A1C
.text$mn:00001A1C ; Segment type: Pure code
.text$mn:00001A1C ; Segment permissions: Read/Execute
.text$mn:00001A1C _text$mn        segment para public 'CODE' use32
.text$mn:00001A1C                 assume cs:_text$mn
.text$mn:00001A1C                 ;org 1A1Ch
.text$mn:00001A1C ; COMDAT (pick any)
.text$mn:00001A1C                 assume es:nothing, ss:nothing, ds:_xdata$x, fs:nothing, gs:nothing
.text$mn:00001A1C
.text$mn:00001A1C ; =============== S U B R O U T I N E =======================================
.text$mn:00001A1C
.text$mn:00001A1C ; Attributes: bp-based frame
.text$mn:00001A1C
.text$mn:00001A1C ; public: class std::basic_string<char, struct std::char_traits<char>, class std::allocator<char>> & __thiscall std::basic_string<char, struct std::char_traits<char>, class std::allocator<char>>::erase(unsigned int, unsigned int)
.text$mn:00001A1C                 public ?erase@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV12@II@Z
.text$mn:00001A1C ?erase@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV12@II@Z proc near
.text$mn:00001A1C                                         ; CODE XREF: std::basic_string<char,std::char_traits<char>,std::allocator<char>>::assign(std::basic_string<char,std::char_traits<char>,std::allocator<char>> const &,uint,uint)+5Ap
.text$mn:00001A1C
.text$mn:00001A1C var_C           = dword ptr -0Ch
.text$mn:00001A1C Dst             = dword ptr -8
.text$mn:00001A1C var_4           = dword ptr -4
.text$mn:00001A1C arg_0           = dword ptr  8
.text$mn:00001A1C arg_4           = dword ptr  0Ch
.text$mn:00001A1C
.text$mn:00001A1C                 push    ebp
.text$mn:00001A1D                 mov     ebp, esp
.text$mn:00001A1F                 sub     esp, 0Ch
.text$mn:00001A22                 mov     [ebp+var_4], ecx
.text$mn:00001A25                 mov     eax, [ebp+var_4]
.text$mn:00001A28                 mov     ecx, [eax+14h]
.text$mn:00001A2B                 cmp     ecx, [ebp+arg_0]
.text$mn:00001A2E                 jnb     short loc_1A38
.text$mn:00001A30                 mov     ecx, [ebp+var_4]
.text$mn:00001A33                 call    ?_Xran@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QBEXXZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char>>::_Xran(void)
.text$mn:00001A38
.text$mn:00001A38 loc_1A38:                               ; CODE XREF: std::basic_string<char,std::char_traits<char>,std::allocator<char>>::erase(uint,uint)+12j
.text$mn:00001A38                 mov     edx, [ebp+var_4]
.text$mn:00001A3B                 mov     eax, [edx+14h]
.text$mn:00001A3E                 sub     eax, [ebp+arg_0]
.text$mn:00001A41                 cmp     eax, [ebp+arg_4]
.text$mn:00001A44                 ja      short loc_1A54
.text$mn:00001A46                 mov     ecx, [ebp+arg_0]
.text$mn:00001A49                 push    ecx
.text$mn:00001A4A                 mov     ecx, [ebp+var_4]
.text$mn:00001A4D                 call    ?_Eos@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEXI@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char>>::_Eos(uint)
.text$mn:00001A52                 jmp     short loc_1A9A
.text$mn:00001A54 ; ---------------------------------------------------------------------------
.text$mn:00001A54
.text$mn:00001A54 loc_1A54:                               ; CODE XREF: std::basic_string<char,std::char_traits<char>,std::allocator<char>>::erase(uint,uint)+28j
.text$mn:00001A54                 cmp     [ebp+arg_4], 0
.text$mn:00001A58                 jbe     short loc_1A9A
.text$mn:00001A5A                 mov     ecx, [ebp+var_4]
.text$mn:00001A5D                 call    ?_Myptr@?$_String_val@U?$_Simple_types@D@std@@@std@@QAEPADXZ ; std::_String_val<std::_Simple_types<char>>::_Myptr(void)
.text$mn:00001A62                 add     eax, [ebp+arg_0]
.text$mn:00001A65                 mov     [ebp+Dst], eax
.text$mn:00001A68                 mov     edx, [ebp+var_4]
.text$mn:00001A6B                 mov     eax, [edx+14h]
.text$mn:00001A6E                 sub     eax, [ebp+arg_4]
.text$mn:00001A71                 mov     [ebp+var_C], eax
.text$mn:00001A74                 mov     ecx, [ebp+var_C]
.text$mn:00001A77                 sub     ecx, [ebp+arg_0]
.text$mn:00001A7A                 push    ecx             ; Size
.text$mn:00001A7B                 mov     edx, [ebp+Dst]
.text$mn:00001A7E                 add     edx, [ebp+arg_4]
.text$mn:00001A81                 push    edx             ; Src
.text$mn:00001A82                 mov     eax, [ebp+Dst]
.text$mn:00001A85                 push    eax             ; Dst
.text$mn:00001A86                 call    ?move@?$char_traits@D@std@@SAPADPADPBDI@Z ; std::char_traits<char>::move(char *,char const *,uint)
.text$mn:00001A8B                 add     esp, 0Ch
.text$mn:00001A8E                 mov     ecx, [ebp+var_C]
.text$mn:00001A91                 push    ecx
.text$mn:00001A92                 mov     ecx, [ebp+var_4]
.text$mn:00001A95                 call    ?_Eos@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEXI@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char>>::_Eos(uint)
.text$mn:00001A9A
.text$mn:00001A9A loc_1A9A:                               ; CODE XREF: std::basic_string<char,std::char_traits<char>,std::allocator<char>>::erase(uint,uint)+36j
.text$mn:00001A9A                                         ; std::basic_string<char,std::char_traits<char>,std::allocator<char>>::erase(uint,uint)+3Cj
.text$mn:00001A9A                 mov     eax, [ebp+var_4]
.text$mn:00001A9D                 mov     esp, ebp
.text$mn:00001A9F                 pop     ebp
.text$mn:00001AA0                 retn    8
.text$mn:00001AA0 ?erase@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV12@II@Z endp
.text$mn:00001AA0
.text$mn:00001AA0 ; ---------------------------------------------------------------------------
.text$mn:00001AA3                 align 4
.text$mn:00001AA3 _text$mn        ends
.text$mn:00001AA3
.text$mn:00001AA4 ; ===========================================================================
.text$mn:00001AA4
.text$mn:00001AA4 ; Segment type: Pure code
.text$mn:00001AA4 ; Segment permissions: Read/Execute
.text$mn:00001AA4 _text$mn        segment para public 'CODE' use32
.text$mn:00001AA4                 assume cs:_text$mn
.text$mn:00001AA4                 ;org 1AA4h
.text$mn:00001AA4 ; COMDAT (pick any)
.text$mn:00001AA4                 assume es:nothing, ss:nothing, ds:_xdata$x, fs:nothing, gs:nothing
.text$mn:00001AA4
.text$mn:00001AA4 ; =============== S U B R O U T I N E =======================================
.text$mn:00001AA4
.text$mn:00001AA4 ; Attributes: bp-based frame
.text$mn:00001AA4
.text$mn:00001AA4 ; const struct std::error_category *__cdecl std::generic_category()
.text$mn:00001AA4                 public ?generic_category@std@@YAABVerror_category@1@XZ
.text$mn:00001AA4 ?generic_category@std@@YAABVerror_category@1@XZ proc near
.text$mn:00001AA4                                         ; CODE XREF: std::_System_error_category::default_error_condition(int)+17p
.text$mn:00001AA4                 push    ebp
.text$mn:00001AA5                 mov     ebp, esp
.text$mn:00001AA7                 mov     eax, offset ?_Generic_object@?$_Error_objects@H@std@@2V_Generic_error_category@2@A ; std::_Generic_error_category std::_Error_objects<int>::_Generic_object
.text$mn:00001AAC                 pop     ebp
.text$mn:00001AAD                 retn
.text$mn:00001AAD ?generic_category@std@@YAABVerror_category@1@XZ endp
.text$mn:00001AAD
.text$mn:00001AAD ; ---------------------------------------------------------------------------
.text$mn:00001AAE                 align 10h
.text$mn:00001AAE _text$mn        ends
.text$mn:00001AAE
.text$mn:00001AB0 ; ===========================================================================
.text$mn:00001AB0
.text$mn:00001AB0 ; Segment type: Pure code
.text$mn:00001AB0 ; Segment permissions: Read/Execute
.text$mn:00001AB0 _text$mn        segment para public 'CODE' use32
.text$mn:00001AB0                 assume cs:_text$mn
.text$mn:00001AB0                 ;org 1AB0h
.text$mn:00001AB0 ; COMDAT (pick any)
.text$mn:00001AB0                 assume es:nothing, ss:nothing, ds:_xdata$x, fs:nothing, gs:nothing
.text$mn:00001AB0
.text$mn:00001AB0 ; =============== S U B R O U T I N E =======================================
.text$mn:00001AB0
.text$mn:00001AB0 ; Attributes: bp-based frame
.text$mn:00001AB0
.text$mn:00001AB0 ; __int32 __thiscall TabBar::getRowCount(TabBar *__hidden this)
.text$mn:00001AB0                 public ?getRowCount@TabBar@@IBEJXZ
.text$mn:00001AB0 ?getRowCount@TabBar@@IBEJXZ proc near   ; CODE XREF: ControlsTab::reSizeTo(tagRECT &)+5Dp
.text$mn:00001AB0
.text$mn:00001AB0 var_4           = dword ptr -4
.text$mn:00001AB0
.text$mn:00001AB0                 push    ebp
.text$mn:00001AB1                 mov     ebp, esp
.text$mn:00001AB3                 push    ecx
.text$mn:00001AB4                 mov     [ebp+var_4], ecx
.text$mn:00001AB7                 push    0               ; lParam
.text$mn:00001AB9                 push    0               ; wParam
.text$mn:00001ABB                 push    132Ch           ; Msg
.text$mn:00001AC0                 mov     eax, [ebp+var_4]
.text$mn:00001AC3                 mov     ecx, [eax+0Ch]
.text$mn:00001AC6                 push    ecx             ; hWnd
.text$mn:00001AC7                 call    dword ptr ds:__imp__SendMessageW@16 ; SendMessageW(x,x,x,x)
.text$mn:00001ACD                 mov     esp, ebp
.text$mn:00001ACF                 pop     ebp
.text$mn:00001AD0                 retn
.text$mn:00001AD0 ?getRowCount@TabBar@@IBEJXZ endp
.text$mn:00001AD0
.text$mn:00001AD0 ; ---------------------------------------------------------------------------
.text$mn:00001AD1                 align 4
.text$mn:00001AD1 _text$mn        ends
.text$mn:00001AD1
.text$mn:00001AD4 ; ===========================================================================
.text$mn:00001AD4
.text$mn:00001AD4 ; Segment type: Pure code
.text$mn:00001AD4 ; Segment permissions: Read/Execute
.text$mn:00001AD4 _text$mn        segment para public 'CODE' use32
.text$mn:00001AD4                 assume cs:_text$mn
.text$mn:00001AD4                 ;org 1AD4h
.text$mn:00001AD4 ; COMDAT (pick any)
.text$mn:00001AD4                 assume es:nothing, ss:nothing, ds:_xdata$x, fs:nothing, gs:nothing
.text$mn:00001AD4
.text$mn:00001AD4 ; =============== S U B R O U T I N E =======================================
.text$mn:00001AD4
.text$mn:00001AD4 ; Attributes: bp-based frame
.text$mn:00001AD4
.text$mn:00001AD4 ; int __cdecl std::char_traits<char>::length(char *Str)
.text$mn:00001AD4                 public ?length@?$char_traits@D@std@@SAIPBD@Z
.text$mn:00001AD4 ?length@?$char_traits@D@std@@SAIPBD@Z proc near
.text$mn:00001AD4                                         ; CODE XREF: std::basic_string<char,std::char_traits<char>,std::allocator<char>>::assign(char const *)+21p
.text$mn:00001AD4
.text$mn:00001AD4 var_4           = dword ptr -4
.text$mn:00001AD4 Str             = dword ptr  8
.text$mn:00001AD4
.text$mn:00001AD4                 push    ebp
.text$mn:00001AD5                 mov     ebp, esp
.text$mn:00001AD7                 push    ecx
.text$mn:00001AD8                 mov     eax, [ebp+Str]
.text$mn:00001ADB                 movsx   ecx, byte ptr [eax]
.text$mn:00001ADE                 test    ecx, ecx
.text$mn:00001AE0                 jnz     short loc_1AEB
.text$mn:00001AE2                 mov     [ebp+var_4], 0
.text$mn:00001AE9                 jmp     short loc_1AFA
.text$mn:00001AEB ; ---------------------------------------------------------------------------
.text$mn:00001AEB
.text$mn:00001AEB loc_1AEB:                               ; CODE XREF: std::char_traits<char>::length(char const *)+Cj
.text$mn:00001AEB                 mov     edx, [ebp+Str]
.text$mn:00001AEE                 push    edx             ; Str
.text$mn:00001AEF                 call    _strlen
.text$mn:00001AF4                 add     esp, 4
.text$mn:00001AF7                 mov     [ebp+var_4], eax
.text$mn:00001AFA
.text$mn:00001AFA loc_1AFA:                               ; CODE XREF: std::char_traits<char>::length(char const *)+15j
.text$mn:00001AFA                 mov     eax, [ebp+var_4]
.text$mn:00001AFD                 mov     esp, ebp
.text$mn:00001AFF                 pop     ebp
.text$mn:00001B00                 retn
.text$mn:00001B00 ?length@?$char_traits@D@std@@SAIPBD@Z endp
.text$mn:00001B00
.text$mn:00001B00 ; ---------------------------------------------------------------------------
.text$mn:00001B01                 align 4
.text$mn:00001B01 _text$mn        ends
.text$mn:00001B01
.text$mn:00001B04 ; ===========================================================================
.text$mn:00001B04
.text$mn:00001B04 ; Segment type: Pure code
.text$mn:00001B04 ; Segment permissions: Read/Execute
.text$mn:00001B04 _text$mn        segment para public 'CODE' use32
.text$mn:00001B04                 assume cs:_text$mn
.text$mn:00001B04                 ;org 1B04h
.text$mn:00001B04 ; COMDAT (pick any)
.text$mn:00001B04                 assume es:nothing, ss:nothing, ds:_xdata$x, fs:nothing, gs:nothing
.text$mn:00001B04
.text$mn:00001B04 ; =============== S U B R O U T I N E =======================================
.text$mn:00001B04
.text$mn:00001B04 ; Attributes: bp-based frame
.text$mn:00001B04
.text$mn:00001B04 ; int __cdecl std::char_traits<wchar_t>::length(wchar_t *Str)
.text$mn:00001B04                 public ?length@?$char_traits@_W@std@@SAIPB_W@Z
.text$mn:00001B04 ?length@?$char_traits@_W@std@@SAIPB_W@Z proc near
.text$mn:00001B04                                         ; CODE XREF: std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>>::compare(wchar_t const *)+21p
.text$mn:00001B04
.text$mn:00001B04 var_4           = dword ptr -4
.text$mn:00001B04 Str             = dword ptr  8
.text$mn:00001B04
.text$mn:00001B04                 push    ebp
.text$mn:00001B05                 mov     ebp, esp
.text$mn:00001B07                 push    ecx
.text$mn:00001B08                 mov     eax, [ebp+Str]
.text$mn:00001B0B                 movzx   ecx, word ptr [eax]
.text$mn:00001B0E                 test    ecx, ecx
.text$mn:00001B10                 jnz     short loc_1B1B
.text$mn:00001B12                 mov     [ebp+var_4], 0
.text$mn:00001B19                 jmp     short loc_1B2A
.text$mn:00001B1B ; ---------------------------------------------------------------------------
.text$mn:00001B1B
.text$mn:00001B1B loc_1B1B:                               ; CODE XREF: std::char_traits<wchar_t>::length(wchar_t const *)+Cj
.text$mn:00001B1B                 mov     edx, [ebp+Str]
.text$mn:00001B1E                 push    edx             ; Str
.text$mn:00001B1F                 call    _wcslen
.text$mn:00001B24                 add     esp, 4
.text$mn:00001B27                 mov     [ebp+var_4], eax
.text$mn:00001B2A
.text$mn:00001B2A loc_1B2A:                               ; CODE XREF: std::char_traits<wchar_t>::length(wchar_t const *)+15j
.text$mn:00001B2A                 mov     eax, [ebp+var_4]
.text$mn:00001B2D                 mov     esp, ebp
.text$mn:00001B2F                 pop     ebp
.text$mn:00001B30                 retn
.text$mn:00001B30 ?length@?$char_traits@_W@std@@SAIPB_W@Z endp
.text$mn:00001B30
.text$mn:00001B30 ; ---------------------------------------------------------------------------
.text$mn:00001B31                 align 4
.text$mn:00001B31 _text$mn        ends
.text$mn:00001B31
.text$mn:00001B34 ; ===========================================================================
.text$mn:00001B34
.text$mn:00001B34 ; Segment type: Pure code
.text$mn:00001B34 ; Segment permissions: Read/Execute
.text$mn:00001B34 _text$mn        segment para public 'CODE' use32
.text$mn:00001B34                 assume cs:_text$mn
.text$mn:00001B34                 ;org 1B34h
.text$mn:00001B34 ; COMDAT (pick any)
.text$mn:00001B34                 assume es:nothing, ss:nothing, ds:_xdata$x, fs:nothing, gs:nothing
.text$mn:00001B34
.text$mn:00001B34 ; =============== S U B R O U T I N E =======================================
.text$mn:00001B34
.text$mn:00001B34 ; Attributes: bp-based frame
.text$mn:00001B34
.text$mn:00001B34 ; public: unsigned int __thiscall std::_Wrap_alloc<class std::allocator<char>>::max_size(void)const
.text$mn:00001B34                 public ?max_size@?$_Wrap_alloc@V?$allocator@D@std@@@std@@QBEIXZ
.text$mn:00001B34 ?max_size@?$_Wrap_alloc@V?$allocator@D@std@@@std@@QBEIXZ proc near
.text$mn:00001B34                                         ; CODE XREF: std::basic_string<char,std::char_traits<char>,std::allocator<char>>::max_size(void)+17p
.text$mn:00001B34
.text$mn:00001B34 var_4           = dword ptr -4
.text$mn:00001B34
.text$mn:00001B34                 push    ebp
.text$mn:00001B35                 mov     ebp, esp
.text$mn:00001B37                 push    ecx
.text$mn:00001B38                 mov     [ebp+var_4], ecx
.text$mn:00001B3B                 mov     eax, [ebp+var_4]
.text$mn:00001B3E                 push    eax
.text$mn:00001B3F                 call    ?max_size@?$allocator_traits@V?$allocator@D@std@@@std@@SAIABV?$allocator@D@2@@Z ; std::allocator_traits<std::allocator<char>>::max_size(std::allocator<char> const &)
.text$mn:00001B44                 add     esp, 4
.text$mn:00001B47                 mov     esp, ebp
.text$mn:00001B49                 pop     ebp
.text$mn:00001B4A                 retn
.text$mn:00001B4A ?max_size@?$_Wrap_alloc@V?$allocator@D@std@@@std@@QBEIXZ endp
.text$mn:00001B4A
.text$mn:00001B4A ; ---------------------------------------------------------------------------
.text$mn:00001B4B                 align 4
.text$mn:00001B4B _text$mn        ends
.text$mn:00001B4B
.text$mn:00001B4C ; ===========================================================================
.text$mn:00001B4C
.text$mn:00001B4C ; Segment type: Pure code
.text$mn:00001B4C ; Segment permissions: Read/Execute
.text$mn:00001B4C _text$mn        segment para public 'CODE' use32
.text$mn:00001B4C                 assume cs:_text$mn
.text$mn:00001B4C                 ;org 1B4Ch
.text$mn:00001B4C ; COMDAT (pick any)
.text$mn:00001B4C                 assume es:nothing, ss:nothing, ds:_xdata$x, fs:nothing, gs:nothing
.text$mn:00001B4C
.text$mn:00001B4C ; =============== S U B R O U T I N E =======================================
.text$mn:00001B4C
.text$mn:00001B4C ; Attributes: bp-based frame
.text$mn:00001B4C
.text$mn:00001B4C ; public: unsigned int __thiscall std::allocator<char>::max_size(void)const
.text$mn:00001B4C                 public ?max_size@?$allocator@D@std@@QBEIXZ
.text$mn:00001B4C ?max_size@?$allocator@D@std@@QBEIXZ proc near
.text$mn:00001B4C                                         ; CODE XREF: std::allocator_traits<std::allocator<char>>::max_size(std::allocator<char> const &)+6p
.text$mn:00001B4C
.text$mn:00001B4C var_4           = dword ptr -4
.text$mn:00001B4C
.text$mn:00001B4C                 push    ebp
.text$mn:00001B4D                 mov     ebp, esp
.text$mn:00001B4F                 push    ecx
.text$mn:00001B50                 mov     [ebp+var_4], ecx
.text$mn:00001B53                 or      eax, 0FFFFFFFFh
.text$mn:00001B56                 mov     esp, ebp
.text$mn:00001B58                 pop     ebp
.text$mn:00001B59                 retn
.text$mn:00001B59 ?max_size@?$allocator@D@std@@QBEIXZ endp
.text$mn:00001B59
.text$mn:00001B59 ; ---------------------------------------------------------------------------
.text$mn:00001B5A                 align 4
.text$mn:00001B5A _text$mn        ends
.text$mn:00001B5A
.text$mn:00001B5C ; ===========================================================================
.text$mn:00001B5C
.text$mn:00001B5C ; Segment type: Pure code
.text$mn:00001B5C ; Segment permissions: Read/Execute
.text$mn:00001B5C _text$mn        segment para public 'CODE' use32
.text$mn:00001B5C                 assume cs:_text$mn
.text$mn:00001B5C                 ;org 1B5Ch
.text$mn:00001B5C ; COMDAT (pick any)
.text$mn:00001B5C                 assume es:nothing, ss:nothing, ds:_xdata$x, fs:nothing, gs:nothing
.text$mn:00001B5C
.text$mn:00001B5C ; =============== S U B R O U T I N E =======================================
.text$mn:00001B5C
.text$mn:00001B5C ; Attributes: bp-based frame
.text$mn:00001B5C
.text$mn:00001B5C ; public: static unsigned int __cdecl std::allocator_traits<class std::allocator<char>>::max_size(class std::allocator<char> const &)
.text$mn:00001B5C                 public ?max_size@?$allocator_traits@V?$allocator@D@std@@@std@@SAIABV?$allocator@D@2@@Z
.text$mn:00001B5C ?max_size@?$allocator_traits@V?$allocator@D@std@@@std@@SAIABV?$allocator@D@2@@Z proc near
.text$mn:00001B5C                                         ; CODE XREF: std::_Wrap_alloc<std::allocator<char>>::max_size(void)+Bp
.text$mn:00001B5C
.text$mn:00001B5C arg_0           = dword ptr  8
.text$mn:00001B5C
.text$mn:00001B5C                 push    ebp
.text$mn:00001B5D                 mov     ebp, esp
.text$mn:00001B5F                 mov     ecx, [ebp+arg_0]
.text$mn:00001B62                 call    ?max_size@?$allocator@D@std@@QBEIXZ ; std::allocator<char>::max_size(void)
.text$mn:00001B67                 pop     ebp
.text$mn:00001B68                 retn
.text$mn:00001B68 ?max_size@?$allocator_traits@V?$allocator@D@std@@@std@@SAIABV?$allocator@D@2@@Z endp
.text$mn:00001B68
.text$mn:00001B68 ; ---------------------------------------------------------------------------
.text$mn:00001B69                 align 4
.text$mn:00001B69 _text$mn        ends
.text$mn:00001B69
.text$mn:00001B6C ; ===========================================================================
.text$mn:00001B6C
.text$mn:00001B6C ; Segment type: Pure code
.text$mn:00001B6C ; Segment permissions: Read/Execute
.text$mn:00001B6C _text$mn        segment para public 'CODE' use32
.text$mn:00001B6C                 assume cs:_text$mn
.text$mn:00001B6C                 ;org 1B6Ch
.text$mn:00001B6C ; COMDAT (pick any)
.text$mn:00001B6C                 assume es:nothing, ss:nothing, ds:_xdata$x, fs:nothing, gs:nothing
.text$mn:00001B6C
.text$mn:00001B6C ; =============== S U B R O U T I N E =======================================
.text$mn:00001B6C
.text$mn:00001B6C ; Attributes: bp-based frame
.text$mn:00001B6C
.text$mn:00001B6C ; public: unsigned int __thiscall std::basic_string<char, struct std::char_traits<char>, class std::allocator<char>>::max_size(void)const
.text$mn:00001B6C                 public ?max_size@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QBEIXZ
.text$mn:00001B6C ?max_size@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QBEIXZ proc near
.text$mn:00001B6C                                         ; CODE XREF: std::basic_string<char,std::char_traits<char>,std::allocator<char>>::_Copy(uint,uint)+3Bp
.text$mn:00001B6C                                         ; std::basic_string<char,std::char_traits<char>,std::allocator<char>>::_Copy(uint,uint)+6Ap ...
.text$mn:00001B6C
.text$mn:00001B6C var_10          = dword ptr -10h
.text$mn:00001B6C var_C           = dword ptr -0Ch
.text$mn:00001B6C var_8           = dword ptr -8
.text$mn:00001B6C var_1           = byte ptr -1
.text$mn:00001B6C
.text$mn:00001B6C                 push    ebp
.text$mn:00001B6D                 mov     ebp, esp
.text$mn:00001B6F                 sub     esp, 10h
.text$mn:00001B72                 mov     [ebp+var_10], ecx
.text$mn:00001B75                 lea     eax, [ebp+var_1]
.text$mn:00001B78                 push    eax
.text$mn:00001B79                 mov     ecx, [ebp+var_10]
.text$mn:00001B7C                 call    ?_Getal@?$_String_alloc@$0A@U?$_String_base_types@DV?$allocator@D@std@@@std@@@std@@QBE?AU?$_Wrap_alloc@V?$allocator@D@std@@@2@XZ ; std::_String_alloc<0,std::_String_base_types<char,std::allocator<char>>>::_Getal(void)
.text$mn:00001B81                 mov     ecx, eax
.text$mn:00001B83                 call    ?max_size@?$_Wrap_alloc@V?$allocator@D@std@@@std@@QBEIXZ ; std::_Wrap_alloc<std::allocator<char>>::max_size(void)
.text$mn:00001B88                 mov     [ebp+var_8], eax
.text$mn:00001B8B                 cmp     [ebp+var_8], 1
.text$mn:00001B8F                 ja      short loc_1B9A
.text$mn:00001B91                 mov     [ebp+var_C], 1
.text$mn:00001B98                 jmp     short loc_1BA3
.text$mn:00001B9A ; ---------------------------------------------------------------------------
.text$mn:00001B9A
.text$mn:00001B9A loc_1B9A:                               ; CODE XREF: std::basic_string<char,std::char_traits<char>,std::allocator<char>>::max_size(void)+23j
.text$mn:00001B9A                 mov     ecx, [ebp+var_8]
.text$mn:00001B9D                 sub     ecx, 1
.text$mn:00001BA0                 mov     [ebp+var_C], ecx
.text$mn:00001BA3
.text$mn:00001BA3 loc_1BA3:                               ; CODE XREF: std::basic_string<char,std::char_traits<char>,std::allocator<char>>::max_size(void)+2Cj
.text$mn:00001BA3                 mov     eax, [ebp+var_C]
.text$mn:00001BA6                 mov     esp, ebp
.text$mn:00001BA8                 pop     ebp
.text$mn:00001BA9                 retn
.text$mn:00001BA9 ?max_size@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QBEIXZ endp
.text$mn:00001BA9
.text$mn:00001BA9 ; ---------------------------------------------------------------------------
.text$mn:00001BAA                 align 4
.text$mn:00001BAA _text$mn        ends
.text$mn:00001BAA
.text$mn:00001BAC ; ===========================================================================
.text$mn:00001BAC
.text$mn:00001BAC ; Segment type: Pure code
.text$mn:00001BAC ; Segment permissions: Read/Execute
.text$mn:00001BAC _text$mn        segment para public 'CODE' use32
.text$mn:00001BAC                 assume cs:_text$mn
.text$mn:00001BAC                 ;org 1BACh
.text$mn:00001BAC ; COMDAT (pick any)
.text$mn:00001BAC                 assume es:nothing, ss:nothing, ds:_xdata$x, fs:nothing, gs:nothing
.text$mn:00001BAC
.text$mn:00001BAC ; =============== S U B R O U T I N E =======================================
.text$mn:00001BAC
.text$mn:00001BAC ; Attributes: bp-based frame
.text$mn:00001BAC
.text$mn:00001BAC ; public: virtual class std::basic_string<char, struct std::char_traits<char>, class std::allocator<char>> __thiscall std::_Generic_error_category::message(int)const
.text$mn:00001BAC                 public ?message@_Generic_error_category@std@@UBE?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@2@H@Z
.text$mn:00001BAC ?message@_Generic_error_category@std@@UBE?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@2@H@Z proc near
.text$mn:00001BAC                                         ; CODE XREF: std::_Iostream_error_category::message(int)+64p
.text$mn:00001BAC                                         ; DATA XREF: .rdata:000022FCo
.text$mn:00001BAC
.text$mn:00001BAC var_1C          = dword ptr -1Ch
.text$mn:00001BAC var_18          = dword ptr -18h
.text$mn:00001BAC Str             = dword ptr -14h
.text$mn:00001BAC var_10          = dword ptr -10h
.text$mn:00001BAC var_C           = dword ptr -0Ch
.text$mn:00001BAC var_4           = dword ptr -4
.text$mn:00001BAC arg_0           = dword ptr  8
.text$mn:00001BAC arg_4           = dword ptr  0Ch
.text$mn:00001BAC
.text$mn:00001BAC                 push    ebp
.text$mn:00001BAD                 mov     ebp, esp
.text$mn:00001BAF                 push    0FFFFFFFFh
.text$mn:00001BB1                 push    offset __ehhandler$?message@_Generic_error_category@std@@UBE?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@2@H@Z
.text$mn:00001BB6                 mov     eax, large fs:0
.text$mn:00001BBC                 push    eax
.text$mn:00001BBD                 sub     esp, 10h
.text$mn:00001BC0                 mov     eax, dword ptr ds:___security_cookie
.text$mn:00001BC5                 xor     eax, ebp
.text$mn:00001BC7                 push    eax
.text$mn:00001BC8                 lea     eax, [ebp+var_C]
.text$mn:00001BCB                 mov     large fs:0, eax
.text$mn:00001BD1                 mov     [ebp+var_1C], ecx
.text$mn:00001BD4                 mov     [ebp+var_18], 0
.text$mn:00001BDB                 mov     eax, [ebp+arg_4]
.text$mn:00001BDE                 push    eax             ; int
.text$mn:00001BDF                 call    ?_Syserror_map@std@@YAPBDH@Z ; std::_Syserror_map(int)
.text$mn:00001BE4                 add     esp, 4
.text$mn:00001BE7                 mov     [ebp+var_10], eax
.text$mn:00001BEA                 cmp     [ebp+var_10], 0
.text$mn:00001BEE                 jz      short loc_1BF8
.text$mn:00001BF0                 mov     ecx, [ebp+var_10]
.text$mn:00001BF3                 mov     [ebp+Str], ecx
.text$mn:00001BF6                 jmp     short loc_1BFF
.text$mn:00001BF8 ; ---------------------------------------------------------------------------
.text$mn:00001BF8
.text$mn:00001BF8 loc_1BF8:                               ; CODE XREF: std::_Generic_error_category::message(int)+42j
.text$mn:00001BF8                 mov     [ebp+Str], offset ??_C@_0O@BFJCFAAK@unknown?5error?$AA@ ; "unknown error"
.text$mn:00001BFF
.text$mn:00001BFF loc_1BFF:                               ; CODE XREF: std::_Generic_error_category::message(int)+4Aj
.text$mn:00001BFF                 mov     edx, [ebp+Str]
.text$mn:00001C02                 push    edx             ; Str
.text$mn:00001C03                 mov     ecx, [ebp+arg_0]
.text$mn:00001C06                 call    ??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@PBD@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char>>::basic_string<char,std::char_traits<char>,std::allocator<char>>(char const *)
.text$mn:00001C0B                 mov     [ebp+var_4], 0
.text$mn:00001C12                 mov     eax, [ebp+var_18]
.text$mn:00001C15                 or      eax, 1
.text$mn:00001C18                 mov     [ebp+var_18], eax
.text$mn:00001C1B                 mov     eax, [ebp+arg_0]
.text$mn:00001C1E                 mov     ecx, [ebp+var_C]
.text$mn:00001C21                 mov     large fs:0, ecx
.text$mn:00001C28                 pop     ecx
.text$mn:00001C29                 mov     esp, ebp
.text$mn:00001C2B                 pop     ebp
.text$mn:00001C2C                 retn    8
.text$mn:00001C2C ?message@_Generic_error_category@std@@UBE?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@2@H@Z endp
.text$mn:00001C2C
.text$mn:00001C2C ; ---------------------------------------------------------------------------
.text$mn:00001C2F                 align 10h
.text$mn:00001C2F _text$mn        ends
.text$mn:00001C2F
.text$x:00001C30 ; ===========================================================================
.text$x:00001C30
.text$x:00001C30 ; Segment type: Pure code
.text$x:00001C30 ; Segment permissions: Read/Execute
.text$x:00001C30 _text$x         segment para public 'CODE' use32
.text$x:00001C30                 assume cs:_text$x
.text$x:00001C30                 ;org 1C30h
.text$x:00001C30 ; COMDAT (pick associative to section at 1BAC)
.text$x:00001C30                 assume es:nothing, ss:nothing, ds:_xdata$x, fs:nothing, gs:nothing
.text$x:00001C30
.text$x:00001C30 ; =============== S U B R O U T I N E =======================================
.text$x:00001C30
.text$x:00001C30
.text$x:00001C30 __unwindfunclet$?message@_Generic_error_category@std@@UBE?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@2@H@Z$0 proc near
.text$x:00001C30                                         ; DATA XREF: .xdata$x:0000211Co
.text$x:00001C30                 mov     eax, [ebp-18h]
.text$x:00001C33                 and     eax, 1
.text$x:00001C36                 jz      $LN6
.text$x:00001C3C                 and     dword ptr [ebp-18h], 0FFFFFFFEh
.text$x:00001C40                 mov     ecx, [ebp+8]
.text$x:00001C43                 jmp     ??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char>>::~basic_string<char,std::char_traits<char>,std::allocator<char>>(void)
.text$x:00001C48 ; ---------------------------------------------------------------------------
.text$x:00001C48
.text$x:00001C48 $LN6:                                   ; CODE XREF: __unwindfunclet$?message@_Generic_error_category@std@@UBE?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@2@H@Z$0+6j
.text$x:00001C48                 retn
.text$x:00001C48 __unwindfunclet$?message@_Generic_error_category@std@@UBE?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@2@H@Z$0 endp
.text$x:00001C48
.text$x:00001C49
.text$x:00001C49 ; =============== S U B R O U T I N E =======================================
.text$x:00001C49
.text$x:00001C49
.text$x:00001C49 __ehhandler$?message@_Generic_error_category@std@@UBE?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@2@H@Z proc near
.text$x:00001C49                                         ; DATA XREF: std::_Generic_error_category::message(int)+5o
.text$x:00001C49
.text$x:00001C49 arg_4           = dword ptr  8
.text$x:00001C49
.text$x:00001C49                 mov     edx, [esp+arg_4]
.text$x:00001C4D                 lea     eax, [edx+0Ch]
.text$x:00001C50                 mov     ecx, [edx-14h]
.text$x:00001C53                 xor     ecx, eax
.text$x:00001C55                 call    @__security_check_cookie@4 ; __security_check_cookie(x)
.text$x:00001C5A                 mov     eax, offset __ehfuncinfo$?message@_Generic_error_category@std@@UBE?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@2@H@Z
.text$x:00001C5F                 jmp     ___CxxFrameHandler3
.text$x:00001C5F __ehhandler$?message@_Generic_error_category@std@@UBE?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@2@H@Z endp
.text$x:00001C5F
.text$x:00001C5F _text$x         ends
.text$x:00001C5F
.text$mn:00001C64 ; ===========================================================================
.text$mn:00001C64
.text$mn:00001C64 ; Segment type: Pure code
.text$mn:00001C64 ; Segment permissions: Read/Execute
.text$mn:00001C64 _text$mn        segment para public 'CODE' use32
.text$mn:00001C64                 assume cs:_text$mn
.text$mn:00001C64                 ;org 1C64h
.text$mn:00001C64 ; COMDAT (pick any)
.text$mn:00001C64                 assume es:nothing, ss:nothing, ds:_xdata$x, fs:nothing, gs:nothing
.text$mn:00001C64
.text$mn:00001C64 ; =============== S U B R O U T I N E =======================================
.text$mn:00001C64
.text$mn:00001C64 ; Attributes: bp-based frame
.text$mn:00001C64
.text$mn:00001C64 ; public: virtual class std::basic_string<char, struct std::char_traits<char>, class std::allocator<char>> __thiscall std::_Iostream_error_category::message(int)const
.text$mn:00001C64                 public ?message@_Iostream_error_category@std@@UBE?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@2@H@Z
.text$mn:00001C64 ?message@_Iostream_error_category@std@@UBE?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@2@H@Z proc near
.text$mn:00001C64                                         ; DATA XREF: .rdata:00002330o
.text$mn:00001C64
.text$mn:00001C64 var_14          = dword ptr -14h
.text$mn:00001C64 var_10          = dword ptr -10h
.text$mn:00001C64 var_C           = dword ptr -0Ch
.text$mn:00001C64 var_4           = dword ptr -4
.text$mn:00001C64 arg_0           = dword ptr  8
.text$mn:00001C64 arg_4           = dword ptr  0Ch
.text$mn:00001C64
.text$mn:00001C64                 push    ebp
.text$mn:00001C65                 mov     ebp, esp
.text$mn:00001C67                 push    0FFFFFFFFh
.text$mn:00001C69                 push    offset __ehhandler$?message@_Iostream_error_category@std@@UBE?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@2@H@Z
.text$mn:00001C6E                 mov     eax, large fs:0
.text$mn:00001C74                 push    eax
.text$mn:00001C75                 sub     esp, 8
.text$mn:00001C78                 mov     eax, dword ptr ds:___security_cookie
.text$mn:00001C7D                 xor     eax, ebp
.text$mn:00001C7F                 push    eax
.text$mn:00001C80                 lea     eax, [ebp+var_C]
.text$mn:00001C83                 mov     large fs:0, eax
.text$mn:00001C89                 mov     [ebp+var_14], ecx
.text$mn:00001C8C                 mov     [ebp+var_10], 0
.text$mn:00001C93                 cmp     [ebp+arg_4], 1
.text$mn:00001C97                 jnz     short loc_1CBD
.text$mn:00001C99                 push    offset ??_C@_0BG@PADBLCHM@iostream?5stream?5error?$AA@ ; "iostream stream error"
.text$mn:00001C9E                 mov     ecx, [ebp+arg_0]
.text$mn:00001CA1                 call    ??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@PBD@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char>>::basic_string<char,std::char_traits<char>,std::allocator<char>>(char const *)
.text$mn:00001CA6                 mov     [ebp+var_4], 0
.text$mn:00001CAD                 mov     eax, [ebp+var_10]
.text$mn:00001CB0                 or      eax, 1
.text$mn:00001CB3                 mov     [ebp+var_10], eax
.text$mn:00001CB6                 mov     eax, [ebp+arg_0]
.text$mn:00001CB9                 jmp     short loc_1CE0
.text$mn:00001CBB ; ---------------------------------------------------------------------------
.text$mn:00001CBB                 jmp     short loc_1CE0
.text$mn:00001CBD ; ---------------------------------------------------------------------------
.text$mn:00001CBD
.text$mn:00001CBD loc_1CBD:                               ; CODE XREF: std::_Iostream_error_category::message(int)+33j
.text$mn:00001CBD                 mov     ecx, [ebp+arg_4]
.text$mn:00001CC0                 push    ecx
.text$mn:00001CC1                 mov     edx, [ebp+arg_0]
.text$mn:00001CC4                 push    edx
.text$mn:00001CC5                 mov     ecx, [ebp+var_14]
.text$mn:00001CC8                 call    ?message@_Generic_error_category@std@@UBE?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@2@H@Z ; std::_Generic_error_category::message(int)
.text$mn:00001CCD                 mov     [ebp+var_4], 0
.text$mn:00001CD4                 mov     eax, [ebp+var_10]
.text$mn:00001CD7                 or      eax, 1
.text$mn:00001CDA                 mov     [ebp+var_10], eax
.text$mn:00001CDD                 mov     eax, [ebp+arg_0]
.text$mn:00001CE0
.text$mn:00001CE0 loc_1CE0:                               ; CODE XREF: std::_Iostream_error_category::message(int)+55j
.text$mn:00001CE0                                         ; std::_Iostream_error_category::message(int)+57j
.text$mn:00001CE0                 mov     ecx, [ebp+var_C]
.text$mn:00001CE3                 mov     large fs:0, ecx
.text$mn:00001CEA                 pop     ecx
.text$mn:00001CEB                 mov     esp, ebp
.text$mn:00001CED                 pop     ebp
.text$mn:00001CEE                 retn    8
.text$mn:00001CEE ?message@_Iostream_error_category@std@@UBE?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@2@H@Z endp
.text$mn:00001CEE
.text$mn:00001CEE ; ---------------------------------------------------------------------------
.text$mn:00001CF1                 align 4
.text$mn:00001CF1 _text$mn        ends
.text$mn:00001CF1
.text$x:00001CF4 ; ===========================================================================
.text$x:00001CF4
.text$x:00001CF4 ; Segment type: Pure code
.text$x:00001CF4 ; Segment permissions: Read/Execute
.text$x:00001CF4 _text$x         segment para public 'CODE' use32
.text$x:00001CF4                 assume cs:_text$x
.text$x:00001CF4                 ;org 1CF4h
.text$x:00001CF4 ; COMDAT (pick associative to section at 1C64)
.text$x:00001CF4                 assume es:nothing, ss:nothing, ds:_xdata$x, fs:nothing, gs:nothing
.text$x:00001CF4
.text$x:00001CF4 ; =============== S U B R O U T I N E =======================================
.text$x:00001CF4
.text$x:00001CF4
.text$x:00001CF4 __unwindfunclet$?message@_Iostream_error_category@std@@UBE?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@2@H@Z$0 proc near
.text$x:00001CF4                                         ; DATA XREF: .xdata$x:000021A0o
.text$x:00001CF4                 mov     eax, [ebp-10h]
.text$x:00001CF7                 and     eax, 1
.text$x:00001CFA                 jz      $LN6_0
.text$x:00001D00                 and     dword ptr [ebp-10h], 0FFFFFFFEh
.text$x:00001D04                 mov     ecx, [ebp+8]
.text$x:00001D07                 jmp     ??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char>>::~basic_string<char,std::char_traits<char>,std::allocator<char>>(void)
.text$x:00001D0C ; ---------------------------------------------------------------------------
.text$x:00001D0C
.text$x:00001D0C $LN6_0:                                 ; CODE XREF: __unwindfunclet$?message@_Iostream_error_category@std@@UBE?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@2@H@Z$0+6j
.text$x:00001D0C                 retn
.text$x:00001D0C __unwindfunclet$?message@_Iostream_error_category@std@@UBE?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@2@H@Z$0 endp
.text$x:00001D0C
.text$x:00001D0D
.text$x:00001D0D ; =============== S U B R O U T I N E =======================================
.text$x:00001D0D
.text$x:00001D0D
.text$x:00001D0D __ehhandler$?message@_Iostream_error_category@std@@UBE?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@2@H@Z proc near
.text$x:00001D0D                                         ; DATA XREF: std::_Iostream_error_category::message(int)+5o
.text$x:00001D0D
.text$x:00001D0D arg_4           = dword ptr  8
.text$x:00001D0D
.text$x:00001D0D                 mov     edx, [esp+arg_4]
.text$x:00001D11                 lea     eax, [edx+0Ch]
.text$x:00001D14                 mov     ecx, [edx-0Ch]
.text$x:00001D17                 xor     ecx, eax
.text$x:00001D19                 call    @__security_check_cookie@4 ; __security_check_cookie(x)
.text$x:00001D1E                 mov     eax, offset __ehfuncinfo$?message@_Iostream_error_category@std@@UBE?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@2@H@Z
.text$x:00001D23                 jmp     ___CxxFrameHandler3
.text$x:00001D23 __ehhandler$?message@_Iostream_error_category@std@@UBE?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@2@H@Z endp
.text$x:00001D23
.text$x:00001D23 _text$x         ends
.text$x:00001D23
.text$mn:00001D28 ; ===========================================================================
.text$mn:00001D28
.text$mn:00001D28 ; Segment type: Pure code
.text$mn:00001D28 ; Segment permissions: Read/Execute
.text$mn:00001D28 _text$mn        segment para public 'CODE' use32
.text$mn:00001D28                 assume cs:_text$mn
.text$mn:00001D28                 ;org 1D28h
.text$mn:00001D28 ; COMDAT (pick any)
.text$mn:00001D28                 assume es:nothing, ss:nothing, ds:_xdata$x, fs:nothing, gs:nothing
.text$mn:00001D28
.text$mn:00001D28 ; =============== S U B R O U T I N E =======================================
.text$mn:00001D28
.text$mn:00001D28 ; Attributes: bp-based frame
.text$mn:00001D28
.text$mn:00001D28 ; public: virtual class std::basic_string<char, struct std::char_traits<char>, class std::allocator<char>> __thiscall std::_System_error_category::message(int)const
.text$mn:00001D28                 public ?message@_System_error_category@std@@UBE?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@2@H@Z
.text$mn:00001D28 ?message@_System_error_category@std@@UBE?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@2@H@Z proc near
.text$mn:00001D28                                         ; DATA XREF: .rdata:00002370o
.text$mn:00001D28
.text$mn:00001D28 var_1C          = dword ptr -1Ch
.text$mn:00001D28 var_18          = dword ptr -18h
.text$mn:00001D28 Str             = dword ptr -14h
.text$mn:00001D28 var_10          = dword ptr -10h
.text$mn:00001D28 var_C           = dword ptr -0Ch
.text$mn:00001D28 var_4           = dword ptr -4
.text$mn:00001D28 arg_0           = dword ptr  8
.text$mn:00001D28 arg_4           = dword ptr  0Ch
.text$mn:00001D28
.text$mn:00001D28                 push    ebp
.text$mn:00001D29                 mov     ebp, esp
.text$mn:00001D2B                 push    0FFFFFFFFh
.text$mn:00001D2D                 push    offset __ehhandler$?message@_System_error_category@std@@UBE?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@2@H@Z
.text$mn:00001D32                 mov     eax, large fs:0
.text$mn:00001D38                 push    eax
.text$mn:00001D39                 sub     esp, 10h
.text$mn:00001D3C                 mov     eax, dword ptr ds:___security_cookie
.text$mn:00001D41                 xor     eax, ebp
.text$mn:00001D43                 push    eax
.text$mn:00001D44                 lea     eax, [ebp+var_C]
.text$mn:00001D47                 mov     large fs:0, eax
.text$mn:00001D4D                 mov     [ebp+var_1C], ecx
.text$mn:00001D50                 mov     [ebp+var_18], 0
.text$mn:00001D57                 mov     eax, [ebp+arg_4]
.text$mn:00001D5A                 push    eax             ; int
.text$mn:00001D5B                 call    ?_Winerror_map@std@@YAPBDH@Z ; std::_Winerror_map(int)
.text$mn:00001D60                 add     esp, 4
.text$mn:00001D63                 mov     [ebp+var_10], eax
.text$mn:00001D66                 cmp     [ebp+var_10], 0
.text$mn:00001D6A                 jz      short loc_1D74
.text$mn:00001D6C                 mov     ecx, [ebp+var_10]
.text$mn:00001D6F                 mov     [ebp+Str], ecx
.text$mn:00001D72                 jmp     short loc_1D7B
.text$mn:00001D74 ; ---------------------------------------------------------------------------
.text$mn:00001D74
.text$mn:00001D74 loc_1D74:                               ; CODE XREF: std::_System_error_category::message(int)+42j
.text$mn:00001D74                 mov     [ebp+Str], offset ??_C@_0O@BFJCFAAK@unknown?5error?$AA@ ; "unknown error"
.text$mn:00001D7B
.text$mn:00001D7B loc_1D7B:                               ; CODE XREF: std::_System_error_category::message(int)+4Aj
.text$mn:00001D7B                 mov     edx, [ebp+Str]
.text$mn:00001D7E                 push    edx             ; Str
.text$mn:00001D7F                 mov     ecx, [ebp+arg_0]
.text$mn:00001D82                 call    ??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@PBD@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char>>::basic_string<char,std::char_traits<char>,std::allocator<char>>(char const *)
.text$mn:00001D87                 mov     [ebp+var_4], 0
.text$mn:00001D8E                 mov     eax, [ebp+var_18]
.text$mn:00001D91                 or      eax, 1
.text$mn:00001D94                 mov     [ebp+var_18], eax
.text$mn:00001D97                 mov     eax, [ebp+arg_0]
.text$mn:00001D9A                 mov     ecx, [ebp+var_C]
.text$mn:00001D9D                 mov     large fs:0, ecx
.text$mn:00001DA4                 pop     ecx
.text$mn:00001DA5                 mov     esp, ebp
.text$mn:00001DA7                 pop     ebp
.text$mn:00001DA8                 retn    8
.text$mn:00001DA8 ?message@_System_error_category@std@@UBE?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@2@H@Z endp
.text$mn:00001DA8
.text$mn:00001DA8 ; ---------------------------------------------------------------------------
.text$mn:00001DAB                 align 4
.text$mn:00001DAB _text$mn        ends
.text$mn:00001DAB
.text$x:00001DAC ; ===========================================================================
.text$x:00001DAC
.text$x:00001DAC ; Segment type: Pure code
.text$x:00001DAC ; Segment permissions: Read/Execute
.text$x:00001DAC _text$x         segment para public 'CODE' use32
.text$x:00001DAC                 assume cs:_text$x
.text$x:00001DAC                 ;org 1DACh
.text$x:00001DAC ; COMDAT (pick associative to section at 1D28)
.text$x:00001DAC                 assume es:nothing, ss:nothing, ds:_xdata$x, fs:nothing, gs:nothing
.text$x:00001DAC
.text$x:00001DAC ; =============== S U B R O U T I N E =======================================
.text$x:00001DAC
.text$x:00001DAC
.text$x:00001DAC __unwindfunclet$?message@_System_error_category@std@@UBE?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@2@H@Z$0 proc near
.text$x:00001DAC                                         ; DATA XREF: .xdata$x:00002224o
.text$x:00001DAC                 mov     eax, [ebp-18h]
.text$x:00001DAF                 and     eax, 1
.text$x:00001DB2                 jz      $LN6_1
.text$x:00001DB8                 and     dword ptr [ebp-18h], 0FFFFFFFEh
.text$x:00001DBC                 mov     ecx, [ebp+8]
.text$x:00001DBF                 jmp     ??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char>>::~basic_string<char,std::char_traits<char>,std::allocator<char>>(void)
.text$x:00001DC4 ; ---------------------------------------------------------------------------
.text$x:00001DC4
.text$x:00001DC4 $LN6_1:                                 ; CODE XREF: __unwindfunclet$?message@_System_error_category@std@@UBE?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@2@H@Z$0+6j
.text$x:00001DC4                 retn
.text$x:00001DC4 __unwindfunclet$?message@_System_error_category@std@@UBE?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@2@H@Z$0 endp
.text$x:00001DC4
.text$x:00001DC5
.text$x:00001DC5 ; =============== S U B R O U T I N E =======================================
.text$x:00001DC5
.text$x:00001DC5
.text$x:00001DC5 __ehhandler$?message@_System_error_category@std@@UBE?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@2@H@Z proc near
.text$x:00001DC5                                         ; DATA XREF: std::_System_error_category::message(int)+5o
.text$x:00001DC5
.text$x:00001DC5 arg_4           = dword ptr  8
.text$x:00001DC5
.text$x:00001DC5                 mov     edx, [esp+arg_4]
.text$x:00001DC9                 lea     eax, [edx+0Ch]
.text$x:00001DCC                 mov     ecx, [edx-14h]
.text$x:00001DCF                 xor     ecx, eax
.text$x:00001DD1                 call    @__security_check_cookie@4 ; __security_check_cookie(x)
.text$x:00001DD6                 mov     eax, offset __ehfuncinfo$?message@_System_error_category@std@@UBE?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@2@H@Z
.text$x:00001DDB                 jmp     ___CxxFrameHandler3
.text$x:00001DDB __ehhandler$?message@_System_error_category@std@@UBE?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@2@H@Z endp
.text$x:00001DDB
.text$x:00001DDB _text$x         ends
.text$x:00001DDB
.text$mn:00001DE0 ; ===========================================================================
.text$mn:00001DE0
.text$mn:00001DE0 ; Segment type: Pure code
.text$mn:00001DE0 ; Segment permissions: Read/Execute
.text$mn:00001DE0 _text$mn        segment para public 'CODE' use32
.text$mn:00001DE0                 assume cs:_text$mn
.text$mn:00001DE0                 ;org 1DE0h
.text$mn:00001DE0 ; COMDAT (pick any)
.text$mn:00001DE0                 assume es:nothing, ss:nothing, ds:_xdata$x, fs:nothing, gs:nothing
.text$mn:00001DE0
.text$mn:00001DE0 ; =============== S U B R O U T I N E =======================================
.text$mn:00001DE0
.text$mn:00001DE0 ; Attributes: bp-based frame
.text$mn:00001DE0
.text$mn:00001DE0 ; int __cdecl std::char_traits<char>::move(void *Dst, void *Src, size_t Size)
.text$mn:00001DE0                 public ?move@?$char_traits@D@std@@SAPADPADPBDI@Z
.text$mn:00001DE0 ?move@?$char_traits@D@std@@SAPADPADPBDI@Z proc near
.text$mn:00001DE0                                         ; CODE XREF: std::basic_string<char,std::char_traits<char>,std::allocator<char>>::erase(uint,uint)+6Ap
.text$mn:00001DE0
.text$mn:00001DE0 var_4           = dword ptr -4
.text$mn:00001DE0 Dst             = dword ptr  8
.text$mn:00001DE0 Src             = dword ptr  0Ch
.text$mn:00001DE0 Size            = dword ptr  10h
.text$mn:00001DE0
.text$mn:00001DE0                 push    ebp
.text$mn:00001DE1                 mov     ebp, esp
.text$mn:00001DE3                 push    ecx
.text$mn:00001DE4                 cmp     [ebp+Size], 0
.text$mn:00001DE8                 jnz     short loc_1DF2
.text$mn:00001DEA                 mov     eax, [ebp+Dst]
.text$mn:00001DED                 mov     [ebp+var_4], eax
.text$mn:00001DF0                 jmp     short loc_1E09
.text$mn:00001DF2 ; ---------------------------------------------------------------------------
.text$mn:00001DF2
.text$mn:00001DF2 loc_1DF2:                               ; CODE XREF: std::char_traits<char>::move(char *,char const *,uint)+8j
.text$mn:00001DF2                 mov     ecx, [ebp+Size]
.text$mn:00001DF5                 push    ecx             ; Size
.text$mn:00001DF6                 mov     edx, [ebp+Src]
.text$mn:00001DF9                 push    edx             ; Src
.text$mn:00001DFA                 mov     eax, [ebp+Dst]
.text$mn:00001DFD                 push    eax             ; Dst
.text$mn:00001DFE                 call    _memmove
.text$mn:00001E03                 add     esp, 0Ch
.text$mn:00001E06                 mov     [ebp+var_4], eax
.text$mn:00001E09
.text$mn:00001E09 loc_1E09:                               ; CODE XREF: std::char_traits<char>::move(char *,char const *,uint)+10j
.text$mn:00001E09                 mov     eax, [ebp+var_4]
.text$mn:00001E0C                 mov     esp, ebp
.text$mn:00001E0E                 pop     ebp
.text$mn:00001E0F                 retn
.text$mn:00001E0F ?move@?$char_traits@D@std@@SAPADPADPBDI@Z endp
.text$mn:00001E0F
.text$mn:00001E0F _text$mn        ends
.text$mn:00001E0F
.text$mn:00001E10 ; ===========================================================================
.text$mn:00001E10
.text$mn:00001E10 ; Segment type: Pure code
.text$mn:00001E10 ; Segment permissions: Read/Execute
.text$mn:00001E10 _text$mn        segment para public 'CODE' use32
.text$mn:00001E10                 assume cs:_text$mn
.text$mn:00001E10                 ;org 1E10h
.text$mn:00001E10 ; COMDAT (pick any)
.text$mn:00001E10                 assume es:nothing, ss:nothing, ds:_xdata$x, fs:nothing, gs:nothing
.text$mn:00001E10
.text$mn:00001E10 ; =============== S U B R O U T I N E =======================================
.text$mn:00001E10
.text$mn:00001E10 ; Attributes: bp-based frame
.text$mn:00001E10
.text$mn:00001E10 ; const char *__thiscall std::_Generic_error_category::name(std::_Generic_error_category *__hidden this)
.text$mn:00001E10                 public ?name@_Generic_error_category@std@@UBEPBDXZ
.text$mn:00001E10 ?name@_Generic_error_category@std@@UBEPBDXZ proc near
.text$mn:00001E10                                         ; DATA XREF: .rdata:000022F8o
.text$mn:00001E10
.text$mn:00001E10 var_4           = dword ptr -4
.text$mn:00001E10
.text$mn:00001E10                 push    ebp
.text$mn:00001E11                 mov     ebp, esp
.text$mn:00001E13                 push    ecx
.text$mn:00001E14                 mov     [ebp+var_4], ecx
.text$mn:00001E17                 mov     eax, offset ??_C@_07DCLBNMLN@generic?$AA@ ; "generic"
.text$mn:00001E1C                 mov     esp, ebp
.text$mn:00001E1E                 pop     ebp
.text$mn:00001E1F                 retn
.text$mn:00001E1F ?name@_Generic_error_category@std@@UBEPBDXZ endp
.text$mn:00001E1F
.text$mn:00001E1F _text$mn        ends
.text$mn:00001E1F
.text$mn:00001E20 ; ===========================================================================
.text$mn:00001E20
.text$mn:00001E20 ; Segment type: Pure code
.text$mn:00001E20 ; Segment permissions: Read/Execute
.text$mn:00001E20 _text$mn        segment para public 'CODE' use32
.text$mn:00001E20                 assume cs:_text$mn
.text$mn:00001E20                 ;org 1E20h
.text$mn:00001E20 ; COMDAT (pick any)
.text$mn:00001E20                 assume es:nothing, ss:nothing, ds:_xdata$x, fs:nothing, gs:nothing
.text$mn:00001E20
.text$mn:00001E20 ; =============== S U B R O U T I N E =======================================
.text$mn:00001E20
.text$mn:00001E20 ; Attributes: bp-based frame
.text$mn:00001E20
.text$mn:00001E20 ; const char *__thiscall std::_Iostream_error_category::name(std::_Iostream_error_category *__hidden this)
.text$mn:00001E20                 public ?name@_Iostream_error_category@std@@UBEPBDXZ
.text$mn:00001E20 ?name@_Iostream_error_category@std@@UBEPBDXZ proc near
.text$mn:00001E20                                         ; DATA XREF: .rdata:0000232Co
.text$mn:00001E20
.text$mn:00001E20 var_4           = dword ptr -4
.text$mn:00001E20
.text$mn:00001E20                 push    ebp
.text$mn:00001E21                 mov     ebp, esp
.text$mn:00001E23                 push    ecx
.text$mn:00001E24                 mov     [ebp+var_4], ecx
.text$mn:00001E27                 mov     eax, offset ??_C@_08LLGCOLLL@iostream?$AA@ ; "iostream"
.text$mn:00001E2C                 mov     esp, ebp
.text$mn:00001E2E                 pop     ebp
.text$mn:00001E2F                 retn
.text$mn:00001E2F ?name@_Iostream_error_category@std@@UBEPBDXZ endp
.text$mn:00001E2F
.text$mn:00001E2F _text$mn        ends
.text$mn:00001E2F
.text$mn:00001E30 ; ===========================================================================
.text$mn:00001E30
.text$mn:00001E30 ; Segment type: Pure code
.text$mn:00001E30 ; Segment permissions: Read/Execute
.text$mn:00001E30 _text$mn        segment para public 'CODE' use32
.text$mn:00001E30                 assume cs:_text$mn
.text$mn:00001E30                 ;org 1E30h
.text$mn:00001E30 ; COMDAT (pick any)
.text$mn:00001E30                 assume es:nothing, ss:nothing, ds:_xdata$x, fs:nothing, gs:nothing
.text$mn:00001E30
.text$mn:00001E30 ; =============== S U B R O U T I N E =======================================
.text$mn:00001E30
.text$mn:00001E30 ; Attributes: bp-based frame
.text$mn:00001E30
.text$mn:00001E30 ; const char *__thiscall std::_System_error_category::name(std::_System_error_category *__hidden this)
.text$mn:00001E30                 public ?name@_System_error_category@std@@UBEPBDXZ
.text$mn:00001E30 ?name@_System_error_category@std@@UBEPBDXZ proc near
.text$mn:00001E30                                         ; DATA XREF: .rdata:0000236Co
.text$mn:00001E30
.text$mn:00001E30 var_4           = dword ptr -4
.text$mn:00001E30
.text$mn:00001E30                 push    ebp
.text$mn:00001E31                 mov     ebp, esp
.text$mn:00001E33                 push    ecx
.text$mn:00001E34                 mov     [ebp+var_4], ecx
.text$mn:00001E37                 mov     eax, offset ??_C@_06FHFOAHML@system?$AA@ ; "system"
.text$mn:00001E3C                 mov     esp, ebp
.text$mn:00001E3E                 pop     ebp
.text$mn:00001E3F                 retn
.text$mn:00001E3F ?name@_System_error_category@std@@UBEPBDXZ endp
.text$mn:00001E3F
.text$mn:00001E3F _text$mn        ends
.text$mn:00001E3F
.text$mn:00001E40 ; ===========================================================================
.text$mn:00001E40
.text$mn:00001E40 ; Segment type: Pure code
.text$mn:00001E40 ; Segment permissions: Read/Execute
.text$mn:00001E40 _text$mn        segment para public 'CODE' use32
.text$mn:00001E40                 assume cs:_text$mn
.text$mn:00001E40                 ;org 1E40h
.text$mn:00001E40 ; COMDAT (pick any)
.text$mn:00001E40                 assume es:nothing, ss:nothing, ds:_xdata$x, fs:nothing, gs:nothing
.text$mn:00001E40
.text$mn:00001E40 ; =============== S U B R O U T I N E =======================================
.text$mn:00001E40
.text$mn:00001E40 ; Attributes: bp-based frame
.text$mn:00001E40
.text$mn:00001E40 ; public: unsigned int __thiscall std::basic_string<char, struct std::char_traits<char>, class std::allocator<char>>::size(void)const
.text$mn:00001E40                 public ?size@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QBEIXZ
.text$mn:00001E40 ?size@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QBEIXZ proc near
.text$mn:00001E40                                         ; CODE XREF: std::basic_string<char,std::char_traits<char>,std::allocator<char>>::assign(std::basic_string<char,std::char_traits<char>,std::allocator<char>> const &,uint,uint)+Cp
.text$mn:00001E40                                         ; std::basic_string<char,std::char_traits<char>,std::allocator<char>>::assign(std::basic_string<char,std::char_traits<char>,std::allocator<char>> const &,uint,uint)+21p
.text$mn:00001E40
.text$mn:00001E40 var_4           = dword ptr -4
.text$mn:00001E40
.text$mn:00001E40                 push    ebp
.text$mn:00001E41                 mov     ebp, esp
.text$mn:00001E43                 push    ecx
.text$mn:00001E44                 mov     [ebp+var_4], ecx
.text$mn:00001E47                 mov     eax, [ebp+var_4]
.text$mn:00001E4A                 mov     eax, [eax+14h]
.text$mn:00001E4D                 mov     esp, ebp
.text$mn:00001E4F                 pop     ebp
.text$mn:00001E50                 retn
.text$mn:00001E50 ?size@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QBEIXZ endp
.text$mn:00001E50
.text$mn:00001E50 ; ---------------------------------------------------------------------------
.text$mn:00001E51                 align 4
.text$mn:00001E51 _text$mn        ends
.text$mn:00001E51
.text$mn:00001E54 ; ===========================================================================
.text$mn:00001E54
.text$mn:00001E54 ; Segment type: Pure code
.text$mn:00001E54 ; Segment permissions: Read/Execute
.text$mn:00001E54 _text$mn        segment para public 'CODE' use32
.text$mn:00001E54                 assume cs:_text$mn
.text$mn:00001E54                 ;org 1E54h
.text$mn:00001E54 ; COMDAT (pick any)
.text$mn:00001E54                 assume es:nothing, ss:nothing, ds:_xdata$x, fs:nothing, gs:nothing
.text$mn:00001E54
.text$mn:00001E54 ; =============== S U B R O U T I N E =======================================
.text$mn:00001E54
.text$mn:00001E54 ; Attributes: bp-based frame
.text$mn:00001E54
.text$mn:00001E54 ; public: unsigned int __thiscall std::vector<struct DlgInfo, class std::allocator<struct DlgInfo>>::size(void)const
.text$mn:00001E54                 public ?size@?$vector@UDlgInfo@@V?$allocator@UDlgInfo@@@std@@@std@@QBEIXZ
.text$mn:00001E54 ?size@?$vector@UDlgInfo@@V?$allocator@UDlgInfo@@@std@@@std@@QBEIXZ proc near
.text$mn:00001E54                                         ; CODE XREF: ControlsTab::createTabs(std::vector<DlgInfo,std::allocator<DlgInfo>> &)+1Cp
.text$mn:00001E54                                         ; ControlsTab::renameTab(wchar_t const *,wchar_t const *)+1Ap ...
.text$mn:00001E54
.text$mn:00001E54 var_4           = dword ptr -4
.text$mn:00001E54
.text$mn:00001E54                 push    ebp
.text$mn:00001E55                 mov     ebp, esp
.text$mn:00001E57                 push    ecx
.text$mn:00001E58                 mov     [ebp+var_4], ecx
.text$mn:00001E5B                 mov     eax, [ebp+var_4]
.text$mn:00001E5E                 mov     ecx, [ebp+var_4]
.text$mn:00001E61                 mov     eax, [eax+8]
.text$mn:00001E64                 sub     eax, [ecx+4]
.text$mn:00001E67                 cdq
.text$mn:00001E68                 mov     ecx, 3Ch ; '<'
.text$mn:00001E6D                 idiv    ecx
.text$mn:00001E6F                 mov     esp, ebp
.text$mn:00001E71                 pop     ebp
.text$mn:00001E72                 retn
.text$mn:00001E72 ?size@?$vector@UDlgInfo@@V?$allocator@UDlgInfo@@@std@@@std@@QBEIXZ endp
.text$mn:00001E72
.text$mn:00001E72 ; ---------------------------------------------------------------------------
.text$mn:00001E73                 align 4
.text$mn:00001E73 _text$mn        ends
.text$mn:00001E73
.text$mn:00001E74 ; ===========================================================================
.text$mn:00001E74
.text$mn:00001E74 ; Segment type: Pure code
.text$mn:00001E74 ; Segment permissions: Read/Execute
.text$mn:00001E74 _text$mn        segment para public 'CODE' use32
.text$mn:00001E74                 assume cs:_text$mn
.text$mn:00001E74                 ;org 1E74h
.text$mn:00001E74 ; COMDAT (pick any)
.text$mn:00001E74                 assume es:nothing, ss:nothing, ds:_xdata$x, fs:nothing, gs:nothing
.text$mn:00001E74
.text$mn:00001E74 ; =============== S U B R O U T I N E =======================================
.text$mn:00001E74
.text$mn:00001E74 ; Attributes: bp-based frame
.text$mn:00001E74
.text$mn:00001E74 ; const struct std::error_category *__cdecl std::system_category()
.text$mn:00001E74                 public ?system_category@std@@YAABVerror_category@1@XZ
.text$mn:00001E74 ?system_category@std@@YAABVerror_category@1@XZ proc near
.text$mn:00001E74                                         ; CODE XREF: std::_System_error_category::default_error_condition(int):loc_1938p
.text$mn:00001E74                 push    ebp
.text$mn:00001E75                 mov     ebp, esp
.text$mn:00001E77                 mov     eax, offset ?_System_object@?$_Error_objects@H@std@@2V_System_error_category@2@A ; std::_System_error_category std::_Error_objects<int>::_System_object
.text$mn:00001E7C                 pop     ebp
.text$mn:00001E7D                 retn
.text$mn:00001E7D ?system_category@std@@YAABVerror_category@1@XZ endp
.text$mn:00001E7D
.text$mn:00001E7D ; ---------------------------------------------------------------------------
.text$mn:00001E7E                 align 10h
.text$mn:00001E7E _text$mn        ends
.text$mn:00001E7E
.text$mn:00001E80 ; ===========================================================================
.text$mn:00001E80
.text$mn:00001E80 ; Segment type: Pure code
.text$mn:00001E80 ; Segment permissions: Read/Execute
.text$mn:00001E80 _text$mn        segment para public 'CODE' use32
.text$mn:00001E80                 assume cs:_text$mn
.text$mn:00001E80                 ;org 1E80h
.text$mn:00001E80 ; COMDAT (pick any)
.text$mn:00001E80                 assume es:nothing, ss:nothing, ds:_xdata$x, fs:nothing, gs:nothing
.text$mn:00001E80
.text$mn:00001E80 ; =============== S U B R O U T I N E =======================================
.text$mn:00001E80
.text$mn:00001E80 ; Attributes: bp-based frame
.text$mn:00001E80
.text$mn:00001E80 ; int __thiscall std::error_code::value(std::error_code *__hidden this)
.text$mn:00001E80                 public ?value@error_code@std@@QBEHXZ
.text$mn:00001E80 ?value@error_code@std@@QBEHXZ proc near ; CODE XREF: std::error_category::equivalent(std::error_code const &,int)+24p
.text$mn:00001E80
.text$mn:00001E80 var_4           = dword ptr -4
.text$mn:00001E80
.text$mn:00001E80                 push    ebp
.text$mn:00001E81                 mov     ebp, esp
.text$mn:00001E83                 push    ecx
.text$mn:00001E84                 mov     [ebp+var_4], ecx
.text$mn:00001E87                 mov     eax, [ebp+var_4]
.text$mn:00001E8A                 mov     eax, [eax]
.text$mn:00001E8C                 mov     esp, ebp
.text$mn:00001E8E                 pop     ebp
.text$mn:00001E8F                 retn
.text$mn:00001E8F ?value@error_code@std@@QBEHXZ endp
.text$mn:00001E8F
.text$mn:00001E8F _text$mn        ends
.text$mn:00001E8F
.text$mn:00001E90 ; ===========================================================================
.text$mn:00001E90
.text$mn:00001E90 ; Segment type: Pure code
.text$mn:00001E90 ; Segment permissions: Read/Execute
.text$mn:00001E90 _text$mn        segment para public 'CODE' use32
.text$mn:00001E90                 assume cs:_text$mn
.text$mn:00001E90                 ;org 1E90h
.text$mn:00001E90 ; COMDAT (pick any)
.text$mn:00001E90                 assume es:nothing, ss:nothing, ds:_xdata$x, fs:nothing, gs:nothing
.text$mn:00001E90
.text$mn:00001E90 ; =============== S U B R O U T I N E =======================================
.text$mn:00001E90
.text$mn:00001E90 ; Attributes: bp-based frame
.text$mn:00001E90
.text$mn:00001E90 ; int __thiscall std::error_condition::value(std::error_condition *__hidden this)
.text$mn:00001E90                 public ?value@error_condition@std@@QBEHXZ
.text$mn:00001E90 ?value@error_condition@std@@QBEHXZ proc near
.text$mn:00001E90                                         ; CODE XREF: std::error_condition::operator==(std::error_condition const &)+2Cp
.text$mn:00001E90                                         ; std::error_condition::operator==(std::error_condition const &)+36p
.text$mn:00001E90
.text$mn:00001E90 var_4           = dword ptr -4
.text$mn:00001E90
.text$mn:00001E90                 push    ebp
.text$mn:00001E91                 mov     ebp, esp
.text$mn:00001E93                 push    ecx
.text$mn:00001E94                 mov     [ebp+var_4], ecx
.text$mn:00001E97                 mov     eax, [ebp+var_4]
.text$mn:00001E9A                 mov     eax, [eax]
.text$mn:00001E9C                 mov     esp, ebp
.text$mn:00001E9E                 pop     ebp
.text$mn:00001E9F                 retn
.text$mn:00001E9F ?value@error_condition@std@@QBEHXZ endp
.text$mn:00001E9F
.text$mn:00001E9F _text$mn        ends
.text$mn:00001E9F
.text$mn:00001EA0 ; ===========================================================================
.text$mn:00001EA0
.text$mn:00001EA0 ; Segment type: Pure code
.text$mn:00001EA0 ; Segment permissions: Read/Execute
.text$mn:00001EA0 _text$mn        segment para public 'CODE' use32
.text$mn:00001EA0                 assume cs:_text$mn
.text$mn:00001EA0                 ;org 1EA0h
.text$mn:00001EA0 ; COMDAT (pick any)
.text$mn:00001EA0                 assume es:nothing, ss:nothing, ds:_xdata$x, fs:nothing, gs:nothing
.text$mn:00001EA0
.text$mn:00001EA0 ; =============== S U B R O U T I N E =======================================
.text$mn:00001EA0
.text$mn:00001EA0 ; Attributes: bp-based frame
.text$mn:00001EA0
.text$mn:00001EA0                 public _hypot
.text$mn:00001EA0 _hypot          proc near
.text$mn:00001EA0
.text$mn:00001EA0 var_10          = qword ptr -10h
.text$mn:00001EA0 var_8           = qword ptr -8
.text$mn:00001EA0 arg_0           = qword ptr  8
.text$mn:00001EA0 arg_8           = qword ptr  10h
.text$mn:00001EA0
.text$mn:00001EA0                 push    ebp
.text$mn:00001EA1                 mov     ebp, esp
.text$mn:00001EA3                 sub     esp, 8
.text$mn:00001EA6                 movsd   xmm0, [ebp+arg_8]
.text$mn:00001EAB                 movsd   [esp+8+var_8], xmm0
.text$mn:00001EB0                 sub     esp, 8
.text$mn:00001EB3                 movsd   xmm0, [ebp+arg_0]
.text$mn:00001EB8                 movsd   [esp+10h+var_10], xmm0
.text$mn:00001EBD                 call    __hypot
.text$mn:00001EC2                 add     esp, 10h
.text$mn:00001EC5                 pop     ebp
.text$mn:00001EC6                 retn
.text$mn:00001EC6 _hypot          endp
.text$mn:00001EC6
.text$mn:00001EC6 ; ---------------------------------------------------------------------------
.text$mn:00001EC7                 align 4
.text$mn:00001EC7 _text$mn        ends
.text$mn:00001EC7
.text$mn:00001EC8 ; ===========================================================================
.text$mn:00001EC8
.text$mn:00001EC8 ; Segment type: Pure code
.text$mn:00001EC8 ; Segment permissions: Read/Execute
.text$mn:00001EC8 _text$mn        segment para public 'CODE' use32
.text$mn:00001EC8                 assume cs:_text$mn
.text$mn:00001EC8                 ;org 1EC8h
.text$mn:00001EC8 ; COMDAT (pick any)
.text$mn:00001EC8                 assume es:nothing, ss:nothing, ds:_xdata$x, fs:nothing, gs:nothing
.text$mn:00001EC8
.text$mn:00001EC8 ; =============== S U B R O U T I N E =======================================
.text$mn:00001EC8
.text$mn:00001EC8 ; Attributes: bp-based frame
.text$mn:00001EC8
.text$mn:00001EC8                 public _wmemcmp
.text$mn:00001EC8 _wmemcmp        proc near               ; CODE XREF: std::char_traits<wchar_t>::compare(wchar_t const *,wchar_t const *,uint)+1Fp
.text$mn:00001EC8
.text$mn:00001EC8 var_4           = dword ptr -4
.text$mn:00001EC8 arg_0           = dword ptr  8
.text$mn:00001EC8 arg_4           = dword ptr  0Ch
.text$mn:00001EC8 arg_8           = dword ptr  10h
.text$mn:00001EC8
.text$mn:00001EC8                 push    ebp
.text$mn:00001EC9                 mov     ebp, esp
.text$mn:00001ECB                 push    ecx
.text$mn:00001ECC                 jmp     short loc_1EE9
.text$mn:00001ECE ; ---------------------------------------------------------------------------
.text$mn:00001ECE
.text$mn:00001ECE loc_1ECE:                               ; CODE XREF: _wmemcmp:loc_1F24j
.text$mn:00001ECE                 mov     eax, [ebp+arg_0]
.text$mn:00001ED1                 add     eax, 2
.text$mn:00001ED4                 mov     [ebp+arg_0], eax
.text$mn:00001ED7                 mov     ecx, [ebp+arg_4]
.text$mn:00001EDA                 add     ecx, 2
.text$mn:00001EDD                 mov     [ebp+arg_4], ecx
.text$mn:00001EE0                 mov     edx, [ebp+arg_8]
.text$mn:00001EE3                 sub     edx, 1
.text$mn:00001EE6                 mov     [ebp+arg_8], edx
.text$mn:00001EE9
.text$mn:00001EE9 loc_1EE9:                               ; CODE XREF: _wmemcmp+4j
.text$mn:00001EE9                 cmp     [ebp+arg_8], 0
.text$mn:00001EED                 jbe     short loc_1F26
.text$mn:00001EEF                 mov     eax, [ebp+arg_0]
.text$mn:00001EF2                 movzx   ecx, word ptr [eax]
.text$mn:00001EF5                 mov     edx, [ebp+arg_4]
.text$mn:00001EF8                 movzx   eax, word ptr [edx]
.text$mn:00001EFB                 cmp     ecx, eax
.text$mn:00001EFD                 jz      short loc_1F24
.text$mn:00001EFF                 mov     ecx, [ebp+arg_0]
.text$mn:00001F02                 movzx   edx, word ptr [ecx]
.text$mn:00001F05                 mov     eax, [ebp+arg_4]
.text$mn:00001F08                 movzx   ecx, word ptr [eax]
.text$mn:00001F0B                 cmp     edx, ecx
.text$mn:00001F0D                 jge     short loc_1F18
.text$mn:00001F0F                 mov     [ebp+var_4], 0FFFFFFFFh
.text$mn:00001F16                 jmp     short loc_1F1F
.text$mn:00001F18 ; ---------------------------------------------------------------------------
.text$mn:00001F18
.text$mn:00001F18 loc_1F18:                               ; CODE XREF: _wmemcmp+45j
.text$mn:00001F18                 mov     [ebp+var_4], 1
.text$mn:00001F1F
.text$mn:00001F1F loc_1F1F:                               ; CODE XREF: _wmemcmp+4Ej
.text$mn:00001F1F                 mov     eax, [ebp+var_4]
.text$mn:00001F22                 jmp     short loc_1F28
.text$mn:00001F24 ; ---------------------------------------------------------------------------
.text$mn:00001F24
.text$mn:00001F24 loc_1F24:                               ; CODE XREF: _wmemcmp+35j
.text$mn:00001F24                 jmp     short loc_1ECE
.text$mn:00001F26 ; ---------------------------------------------------------------------------
.text$mn:00001F26
.text$mn:00001F26 loc_1F26:                               ; CODE XREF: _wmemcmp+25j
.text$mn:00001F26                 xor     eax, eax
.text$mn:00001F28
.text$mn:00001F28 loc_1F28:                               ; CODE XREF: _wmemcmp+5Aj
.text$mn:00001F28                 mov     esp, ebp
.text$mn:00001F2A                 pop     ebp
.text$mn:00001F2B                 retn
.text$mn:00001F2B _wmemcmp        endp
.text$mn:00001F2B
.text$mn:00001F2B _text$mn        ends
.text$mn:00001F2B
.xdata$x:00001F2C ; ===========================================================================
.xdata$x:00001F2C
.xdata$x:00001F2C ; Segment type: Pure data
.xdata$x:00001F2C ; Segment permissions: Read
.xdata$x:00001F2C _xdata$x        segment dword public 'DATA' use32
.xdata$x:00001F2C                 assume cs:_xdata$x
.xdata$x:00001F2C                 ;org 1F2Ch
.xdata$x:00001F2C ; COMDAT (pick associative to section at 135C)
.xdata$x:00001F2C __unwindtable$?_Orphan_all@_Container_base12@std@@QAEXXZ db 0FFh
.xdata$x:00001F2C                                         ; DATA XREF: .xdata$x:00001F3Co
.xdata$x:00001F2D                 db 0FFh
.xdata$x:00001F2E                 db 0FFh
.xdata$x:00001F2F                 db 0FFh
.xdata$x:00001F30                 dd offset __unwindfunclet$?_Orphan_all@_Container_base12@std@@QAEXXZ$0
.xdata$x:00001F34 __ehfuncinfo$?_Orphan_all@_Container_base12@std@@QAEXXZ db  22h ; "
.xdata$x:00001F34                                         ; DATA XREF: __ehhandler$?_Orphan_all@_Container_base12@std@@QAEXXZ+11o
.xdata$x:00001F35                 db    5
.xdata$x:00001F36                 db  93h ; 
.xdata$x:00001F37                 db  19h
.xdata$x:00001F38                 db    1
.xdata$x:00001F39                 db    0
.xdata$x:00001F3A                 db    0
.xdata$x:00001F3B                 db    0
.xdata$x:00001F3C                 dd offset __unwindtable$?_Orphan_all@_Container_base12@std@@QAEXXZ
.xdata$x:00001F40                 db    0
.xdata$x:00001F41                 db    0
.xdata$x:00001F42                 db    0
.xdata$x:00001F43                 db    0
.xdata$x:00001F44                 db    0
.xdata$x:00001F45                 db    0
.xdata$x:00001F46                 db    0
.xdata$x:00001F47                 db    0
.xdata$x:00001F48                 db    0
.xdata$x:00001F49                 db    0
.xdata$x:00001F4A                 db    0
.xdata$x:00001F4B                 db    0
.xdata$x:00001F4C                 db    0
.xdata$x:00001F4D                 db    0
.xdata$x:00001F4E                 db    0
.xdata$x:00001F4F                 db    0
.xdata$x:00001F50                 db    0
.xdata$x:00001F51                 db    0
.xdata$x:00001F52                 db    0
.xdata$x:00001F53                 db    0
.xdata$x:00001F54                 db    0
.xdata$x:00001F55                 db    0
.xdata$x:00001F56                 db    0
.xdata$x:00001F57                 db    0
.xdata$x:00001F57 _xdata$x        ends
.xdata$x:00001F57
.xdata$x:00001F58 ; ===========================================================================
.xdata$x:00001F58
.xdata$x:00001F58 ; Segment type: Pure data
.xdata$x:00001F58 ; Segment permissions: Read
.xdata$x:00001F58 _xdata$x        segment dword public 'DATA' use32
.xdata$x:00001F58                 assume cs:_xdata$x
.xdata$x:00001F58                 ;org 1F58h
.xdata$x:00001F58 ; COMDAT (pick associative to section at 638)
.xdata$x:00001F58 __unwindtable$??0?$_String_val@U?$_Simple_types@D@std@@@std@@QAE@XZ db 0FFh
.xdata$x:00001F58                                         ; DATA XREF: .xdata$x:00001F68o
.xdata$x:00001F59                 db 0FFh
.xdata$x:00001F5A                 db 0FFh
.xdata$x:00001F5B                 db 0FFh
.xdata$x:00001F5C                 dd offset __unwindfunclet$??0?$_String_val@U?$_Simple_types@D@std@@@std@@QAE@XZ$0
.xdata$x:00001F60 __ehfuncinfo$??0?$_String_val@U?$_Simple_types@D@std@@@std@@QAE@XZ db  22h ; "
.xdata$x:00001F60                                         ; DATA XREF: __ehhandler$??0?$_String_val@U?$_Simple_types@D@std@@@std@@QAE@XZ+11o
.xdata$x:00001F61                 db    5
.xdata$x:00001F62                 db  93h ; 
.xdata$x:00001F63                 db  19h
.xdata$x:00001F64                 db    1
.xdata$x:00001F65                 db    0
.xdata$x:00001F66                 db    0
.xdata$x:00001F67                 db    0
.xdata$x:00001F68                 dd offset __unwindtable$??0?$_String_val@U?$_Simple_types@D@std@@@std@@QAE@XZ
.xdata$x:00001F6C                 db    0
.xdata$x:00001F6D                 db    0
.xdata$x:00001F6E                 db    0
.xdata$x:00001F6F                 db    0
.xdata$x:00001F70                 db    0
.xdata$x:00001F71                 db    0
.xdata$x:00001F72                 db    0
.xdata$x:00001F73                 db    0
.xdata$x:00001F74                 db    0
.xdata$x:00001F75                 db    0
.xdata$x:00001F76                 db    0
.xdata$x:00001F77                 db    0
.xdata$x:00001F78                 db    0
.xdata$x:00001F79                 db    0
.xdata$x:00001F7A                 db    0
.xdata$x:00001F7B                 db    0
.xdata$x:00001F7C                 db    0
.xdata$x:00001F7D                 db    0
.xdata$x:00001F7E                 db    0
.xdata$x:00001F7F                 db    0
.xdata$x:00001F80                 db    0
.xdata$x:00001F81                 db    0
.xdata$x:00001F82                 db    0
.xdata$x:00001F83                 db    0
.xdata$x:00001F83 _xdata$x        ends
.xdata$x:00001F83
.xdata$x:00001F84 ; ===========================================================================
.xdata$x:00001F84
.xdata$x:00001F84 ; Segment type: Pure data
.xdata$x:00001F84 ; Segment permissions: Read
.xdata$x:00001F84 _xdata$x        segment dword public 'DATA' use32
.xdata$x:00001F84                 assume cs:_xdata$x
.xdata$x:00001F84                 ;org 1F84h
.xdata$x:00001F84 ; COMDAT (pick associative to section at A0C)
.xdata$x:00001F84 __unwindtable$??1?$_String_val@U?$_Simple_types@D@std@@@std@@QAE@XZ db 0FFh
.xdata$x:00001F84                                         ; DATA XREF: .xdata$x:00001F94o
.xdata$x:00001F85                 db 0FFh
.xdata$x:00001F86                 db 0FFh
.xdata$x:00001F87                 db 0FFh
.xdata$x:00001F88                 dd offset __unwindfunclet$??1?$_String_val@U?$_Simple_types@D@std@@@std@@QAE@XZ$0
.xdata$x:00001F8C __ehfuncinfo$??1?$_String_val@U?$_Simple_types@D@std@@@std@@QAE@XZ db  22h ; "
.xdata$x:00001F8C                                         ; DATA XREF: __ehhandler$??1?$_String_val@U?$_Simple_types@D@std@@@std@@QAE@XZ+11o
.xdata$x:00001F8D                 db    5
.xdata$x:00001F8E                 db  93h ; 
.xdata$x:00001F8F                 db  19h
.xdata$x:00001F90                 db    1
.xdata$x:00001F91                 db    0
.xdata$x:00001F92                 db    0
.xdata$x:00001F93                 db    0
.xdata$x:00001F94                 dd offset __unwindtable$??1?$_String_val@U?$_Simple_types@D@std@@@std@@QAE@XZ
.xdata$x:00001F98                 db    0
.xdata$x:00001F99                 db    0
.xdata$x:00001F9A                 db    0
.xdata$x:00001F9B                 db    0
.xdata$x:00001F9C                 db    0
.xdata$x:00001F9D                 db    0
.xdata$x:00001F9E                 db    0
.xdata$x:00001F9F                 db    0
.xdata$x:00001FA0                 db    0
.xdata$x:00001FA1                 db    0
.xdata$x:00001FA2                 db    0
.xdata$x:00001FA3                 db    0
.xdata$x:00001FA4                 db    0
.xdata$x:00001FA5                 db    0
.xdata$x:00001FA6                 db    0
.xdata$x:00001FA7                 db    0
.xdata$x:00001FA8                 db    0
.xdata$x:00001FA9                 db    0
.xdata$x:00001FAA                 db    0
.xdata$x:00001FAB                 db    0
.xdata$x:00001FAC                 db    0
.xdata$x:00001FAD                 db    0
.xdata$x:00001FAE                 db    0
.xdata$x:00001FAF                 db    0
.xdata$x:00001FAF _xdata$x        ends
.xdata$x:00001FAF
.xdata$x:00001FB0 ; ===========================================================================
.xdata$x:00001FB0
.xdata$x:00001FB0 ; Segment type: Pure data
.xdata$x:00001FB0 ; Segment permissions: Read
.xdata$x:00001FB0 _xdata$x        segment dword public 'DATA' use32
.xdata$x:00001FB0                 assume cs:_xdata$x
.xdata$x:00001FB0                 ;org 1FB0h
.xdata$x:00001FB0 ; COMDAT (pick associative to section at 5BC)
.xdata$x:00001FB0 __unwindtable$??0?$_String_alloc@$0A@U?$_String_base_types@DV?$allocator@D@std@@@std@@@std@@QAE@ABV?$allocator@D@1@@Z db 0FFh
.xdata$x:00001FB0                                         ; DATA XREF: .xdata$x:00001FC0o
.xdata$x:00001FB1                 db 0FFh
.xdata$x:00001FB2                 db 0FFh
.xdata$x:00001FB3                 db 0FFh
.xdata$x:00001FB4                 dd offset __unwindfunclet$??0?$_String_alloc@$0A@U?$_String_base_types@DV?$allocator@D@std@@@std@@@std@@QAE@ABV?$allocator@D@1@@Z$0
.xdata$x:00001FB8 __ehfuncinfo$??0?$_String_alloc@$0A@U?$_String_base_types@DV?$allocator@D@std@@@std@@@std@@QAE@ABV?$allocator@D@1@@Z db  22h ; "
.xdata$x:00001FB8                                         ; DATA XREF: __ehhandler$??0?$_String_alloc@$0A@U?$_String_base_types@DV?$allocator@D@std@@@std@@@std@@QAE@ABV?$allocator@D@1@@Z+11o
.xdata$x:00001FB9                 db    5
.xdata$x:00001FBA                 db  93h ; 
.xdata$x:00001FBB                 db  19h
.xdata$x:00001FBC                 db    1
.xdata$x:00001FBD                 db    0
.xdata$x:00001FBE                 db    0
.xdata$x:00001FBF                 db    0
.xdata$x:00001FC0                 dd offset __unwindtable$??0?$_String_alloc@$0A@U?$_String_base_types@DV?$allocator@D@std@@@std@@@std@@QAE@ABV?$allocator@D@1@@Z
.xdata$x:00001FC4                 db    0
.xdata$x:00001FC5                 db    0
.xdata$x:00001FC6                 db    0
.xdata$x:00001FC7                 db    0
.xdata$x:00001FC8                 db    0
.xdata$x:00001FC9                 db    0
.xdata$x:00001FCA                 db    0
.xdata$x:00001FCB                 db    0
.xdata$x:00001FCC                 db    0
.xdata$x:00001FCD                 db    0
.xdata$x:00001FCE                 db    0
.xdata$x:00001FCF                 db    0
.xdata$x:00001FD0                 db    0
.xdata$x:00001FD1                 db    0
.xdata$x:00001FD2                 db    0
.xdata$x:00001FD3                 db    0
.xdata$x:00001FD4                 db    0
.xdata$x:00001FD5                 db    0
.xdata$x:00001FD6                 db    0
.xdata$x:00001FD7                 db    0
.xdata$x:00001FD8                 db    0
.xdata$x:00001FD9                 db    0
.xdata$x:00001FDA                 db    0
.xdata$x:00001FDB                 db    0
.xdata$x:00001FDB _xdata$x        ends
.xdata$x:00001FDB
.xdata$x:00001FDC ; ===========================================================================
.xdata$x:00001FDC
.xdata$x:00001FDC ; Segment type: Pure data
.xdata$x:00001FDC ; Segment permissions: Read
.xdata$x:00001FDC _xdata$x        segment dword public 'DATA' use32
.xdata$x:00001FDC                 assume cs:_xdata$x
.xdata$x:00001FDC                 ;org 1FDCh
.xdata$x:00001FDC ; COMDAT (pick associative to section at 994)
.xdata$x:00001FDC __unwindtable$??1?$_String_alloc@$0A@U?$_String_base_types@DV?$allocator@D@std@@@std@@@std@@QAE@XZ db 0FFh
.xdata$x:00001FDC                                         ; DATA XREF: .xdata$x:00001FECo
.xdata$x:00001FDD                 db 0FFh
.xdata$x:00001FDE                 db 0FFh
.xdata$x:00001FDF                 db 0FFh
.xdata$x:00001FE0                 dd offset __unwindfunclet$??1?$_String_alloc@$0A@U?$_String_base_types@DV?$allocator@D@std@@@std@@@std@@QAE@XZ$0
.xdata$x:00001FE4 __ehfuncinfo$??1?$_String_alloc@$0A@U?$_String_base_types@DV?$allocator@D@std@@@std@@@std@@QAE@XZ db  22h ; "
.xdata$x:00001FE4                                         ; DATA XREF: __ehhandler$??1?$_String_alloc@$0A@U?$_String_base_types@DV?$allocator@D@std@@@std@@@std@@QAE@XZ+11o
.xdata$x:00001FE5                 db    5
.xdata$x:00001FE6                 db  93h ; 
.xdata$x:00001FE7                 db  19h
.xdata$x:00001FE8                 db    1
.xdata$x:00001FE9                 db    0
.xdata$x:00001FEA                 db    0
.xdata$x:00001FEB                 db    0
.xdata$x:00001FEC                 dd offset __unwindtable$??1?$_String_alloc@$0A@U?$_String_base_types@DV?$allocator@D@std@@@std@@@std@@QAE@XZ
.xdata$x:00001FF0                 db    0
.xdata$x:00001FF1                 db    0
.xdata$x:00001FF2                 db    0
.xdata$x:00001FF3                 db    0
.xdata$x:00001FF4                 db    0
.xdata$x:00001FF5                 db    0
.xdata$x:00001FF6                 db    0
.xdata$x:00001FF7                 db    0
.xdata$x:00001FF8                 db    0
.xdata$x:00001FF9                 db    0
.xdata$x:00001FFA                 db    0
.xdata$x:00001FFB                 db    0
.xdata$x:00001FFC                 db    0
.xdata$x:00001FFD                 db    0
.xdata$x:00001FFE                 db    0
.xdata$x:00001FFF                 db    0
.xdata$x:00002000                 db    0
.xdata$x:00002001                 db    0
.xdata$x:00002002                 db    0
.xdata$x:00002003                 db    0
.xdata$x:00002004                 db    0
.xdata$x:00002005                 db    0
.xdata$x:00002006                 db    0
.xdata$x:00002007                 db    0
.xdata$x:00002007 _xdata$x        ends
.xdata$x:00002007
.xdata$x:00002008 ; ===========================================================================
.xdata$x:00002008
.xdata$x:00002008 ; Segment type: Pure data
.xdata$x:00002008 ; Segment permissions: Read
.xdata$x:00002008 _xdata$x        segment dword public 'DATA' use32
.xdata$x:00002008                 assume cs:_xdata$x
.xdata$x:00002008                 ;org 2008h
.xdata$x:00002008 ; COMDAT (pick associative to section at 6F8)
.xdata$x:00002008 __unwindtable$??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@PBD@Z db 0FFh
.xdata$x:00002008                                         ; DATA XREF: .xdata$x:00002018o
.xdata$x:00002009                 db 0FFh
.xdata$x:0000200A                 db 0FFh
.xdata$x:0000200B                 db 0FFh
.xdata$x:0000200C                 dd offset __unwindfunclet$??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@PBD@Z$0
.xdata$x:00002010 __ehfuncinfo$??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@PBD@Z db  22h ; "
.xdata$x:00002010                                         ; DATA XREF: __ehhandler$??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@PBD@Z+11o
.xdata$x:00002011                 db    5
.xdata$x:00002012                 db  93h ; 
.xdata$x:00002013                 db  19h
.xdata$x:00002014                 db    1
.xdata$x:00002015                 db    0
.xdata$x:00002016                 db    0
.xdata$x:00002017                 db    0
.xdata$x:00002018                 dd offset __unwindtable$??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@PBD@Z
.xdata$x:0000201C                 db    0
.xdata$x:0000201D                 db    0
.xdata$x:0000201E                 db    0
.xdata$x:0000201F                 db    0
.xdata$x:00002020                 db    0
.xdata$x:00002021                 db    0
.xdata$x:00002022                 db    0
.xdata$x:00002023                 db    0
.xdata$x:00002024                 db    0
.xdata$x:00002025                 db    0
.xdata$x:00002026                 db    0
.xdata$x:00002027                 db    0
.xdata$x:00002028                 db    0
.xdata$x:00002029                 db    0
.xdata$x:0000202A                 db    0
.xdata$x:0000202B                 db    0
.xdata$x:0000202C                 db    0
.xdata$x:0000202D                 db    0
.xdata$x:0000202E                 db    0
.xdata$x:0000202F                 db    0
.xdata$x:00002030                 db    0
.xdata$x:00002031                 db    0
.xdata$x:00002032                 db    0
.xdata$x:00002033                 db    0
.xdata$x:00002033 _xdata$x        ends
.xdata$x:00002033
.xdata$x:00002034 ; ===========================================================================
.xdata$x:00002034
.xdata$x:00002034 ; Segment type: Pure data
.xdata$x:00002034 ; Segment permissions: Read
.xdata$x:00002034 _xdata$x        segment dword public 'DATA' use32
.xdata$x:00002034                 assume cs:_xdata$x
.xdata$x:00002034                 ;org 2034h
.xdata$x:00002034 ; COMDAT (pick associative to section at A7C)
.xdata$x:00002034 __unwindtable$??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ db 0FFh
.xdata$x:00002034                                         ; DATA XREF: .xdata$x:00002044o
.xdata$x:00002035                 db 0FFh
.xdata$x:00002036                 db 0FFh
.xdata$x:00002037                 db 0FFh
.xdata$x:00002038                 dd offset __unwindfunclet$??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ$0
.xdata$x:0000203C __ehfuncinfo$??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ db  22h ; "
.xdata$x:0000203C                                         ; DATA XREF: __ehhandler$??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ+11o
.xdata$x:0000203D                 db    5
.xdata$x:0000203E                 db  93h ; 
.xdata$x:0000203F                 db  19h
.xdata$x:00002040                 db    1
.xdata$x:00002041                 db    0
.xdata$x:00002042                 db    0
.xdata$x:00002043                 db    0
.xdata$x:00002044                 dd offset __unwindtable$??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ
.xdata$x:00002048                 align 20h
.xdata$x:00002048 _xdata$x        ends
.xdata$x:00002048
.xdata$x:00002060 ; ===========================================================================
.xdata$x:00002060
.xdata$x:00002060 ; Segment type: Pure data
.xdata$x:00002060 ; Segment permissions: Read
.xdata$x:00002060 _xdata$x        segment dword public 'DATA' use32
.xdata$x:00002060                 assume cs:_xdata$x
.xdata$x:00002060                 ;org 2060h
.xdata$x:00002060 ; COMDAT (pick associative to section at F80)
.xdata$x:00002060 __catchsym$?_Copy@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEXII@Z$5 db    0
.xdata$x:00002060                                         ; DATA XREF: .xdata$x:000020E8o
.xdata$x:00002061                 db    0
.xdata$x:00002062                 db    0
.xdata$x:00002063                 db    0
.xdata$x:00002064                 db    0
.xdata$x:00002065                 db    0
.xdata$x:00002066                 db    0
.xdata$x:00002067                 db    0
.xdata$x:00002068                 db    0
.xdata$x:00002069                 db    0
.xdata$x:0000206A                 db    0
.xdata$x:0000206B                 db    0
.xdata$x:0000206C                 dd offset __catch$?_Copy@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEXII@Z$0
.xdata$x:00002070 __catchsym$?_Copy@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEXII@Z$4 db    0
.xdata$x:00002070                                         ; DATA XREF: .xdata$x:000020D4o
.xdata$x:00002071                 db    0
.xdata$x:00002072                 db    0
.xdata$x:00002073                 db    0
.xdata$x:00002074                 db    0
.xdata$x:00002075                 db    0
.xdata$x:00002076                 db    0
.xdata$x:00002077                 db    0
.xdata$x:00002078                 db    0
.xdata$x:00002079                 db    0
.xdata$x:0000207A                 db    0
.xdata$x:0000207B                 db    0
.xdata$x:0000207C                 dd offset __catch$?_Copy@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEXII@Z$1
.xdata$x:00002080 __unwindtable$?_Copy@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEXII@Z db 0FFh
.xdata$x:00002080                                         ; DATA XREF: .xdata$x:000020A8o
.xdata$x:00002081                 db 0FFh
.xdata$x:00002082                 db 0FFh
.xdata$x:00002083                 db 0FFh
.xdata$x:00002084                 db    0
.xdata$x:00002085                 db    0
.xdata$x:00002086                 db    0
.xdata$x:00002087                 db    0
.xdata$x:00002088                 db 0FFh
.xdata$x:00002089                 db 0FFh
.xdata$x:0000208A                 db 0FFh
.xdata$x:0000208B                 db 0FFh
.xdata$x:0000208C                 db    0
.xdata$x:0000208D                 db    0
.xdata$x:0000208E                 db    0
.xdata$x:0000208F                 db    0
.xdata$x:00002090                 db    1
.xdata$x:00002091                 db    0
.xdata$x:00002092                 db    0
.xdata$x:00002093                 db    0
.xdata$x:00002094                 db    0
.xdata$x:00002095                 db    0
.xdata$x:00002096                 db    0
.xdata$x:00002097                 db    0
.xdata$x:00002098                 db    1
.xdata$x:00002099                 db    0
.xdata$x:0000209A                 db    0
.xdata$x:0000209B                 db    0
.xdata$x:0000209C                 db    0
.xdata$x:0000209D                 db    0
.xdata$x:0000209E                 db    0
.xdata$x:0000209F                 db    0
.xdata$x:000020A0 __ehfuncinfo$?_Copy@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEXII@Z db  22h ; "
.xdata$x:000020A0                                         ; DATA XREF: __ehhandler$?_Copy@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEXII@Z+11o
.xdata$x:000020A1                 db    5
.xdata$x:000020A2                 db  93h ; 
.xdata$x:000020A3                 db  19h
.xdata$x:000020A4                 db    4
.xdata$x:000020A5                 db    0
.xdata$x:000020A6                 db    0
.xdata$x:000020A7                 db    0
.xdata$x:000020A8                 dd offset __unwindtable$?_Copy@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEXII@Z
.xdata$x:000020AC                 db    2
.xdata$x:000020AD                 db    0
.xdata$x:000020AE                 db    0
.xdata$x:000020AF                 db    0
.xdata$x:000020B0                 dd offset __tryblocktable$?_Copy@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEXII@Z
.xdata$x:000020B4                 db    0
.xdata$x:000020B5                 db    0
.xdata$x:000020B6                 db    0
.xdata$x:000020B7                 db    0
.xdata$x:000020B8                 db    0
.xdata$x:000020B9                 db    0
.xdata$x:000020BA                 db    0
.xdata$x:000020BB                 db    0
.xdata$x:000020BC                 db    0
.xdata$x:000020BD                 db    0
.xdata$x:000020BE                 db    0
.xdata$x:000020BF                 db    0
.xdata$x:000020C0                 db    0
.xdata$x:000020C1                 db    0
.xdata$x:000020C2                 db    0
.xdata$x:000020C3                 db    0
.xdata$x:000020C4 __tryblocktable$?_Copy@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEXII@Z db    2
.xdata$x:000020C4                                         ; DATA XREF: .xdata$x:000020B0o
.xdata$x:000020C5                 db    0
.xdata$x:000020C6                 db    0
.xdata$x:000020C7                 db    0
.xdata$x:000020C8                 db    2
.xdata$x:000020C9                 db    0
.xdata$x:000020CA                 db    0
.xdata$x:000020CB                 db    0
.xdata$x:000020CC                 db    3
.xdata$x:000020CD                 db    0
.xdata$x:000020CE                 db    0
.xdata$x:000020CF                 db    0
.xdata$x:000020D0                 db    1
.xdata$x:000020D1                 db    0
.xdata$x:000020D2                 db    0
.xdata$x:000020D3                 db    0
.xdata$x:000020D4                 dd offset __catchsym$?_Copy@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEXII@Z$4
.xdata$x:000020D8                 align 10h
.xdata$x:000020E0                 db    3
.xdata$x:000020E1                 db    0
.xdata$x:000020E2                 db    0
.xdata$x:000020E3                 db    0
.xdata$x:000020E4                 db    1
.xdata$x:000020E5                 db    0
.xdata$x:000020E6                 db    0
.xdata$x:000020E7                 db    0
.xdata$x:000020E8                 dd offset __catchsym$?_Copy@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEXII@Z$5
.xdata$x:000020E8 _xdata$x        ends
.xdata$x:000020E8
.xdata$x:000020EC ; ===========================================================================
.xdata$x:000020EC
.xdata$x:000020EC ; Segment type: Pure data
.xdata$x:000020EC ; Segment permissions: Read
.xdata$x:000020EC _xdata$x        segment dword public 'DATA' use32
.xdata$x:000020EC                 assume cs:_xdata$x
.xdata$x:000020EC                 ;org 20ECh
.xdata$x:000020EC ; COMDAT (pick associative to section at 7CC)
.xdata$x:000020EC __unwindtable$??0_Generic_error_category@std@@QAE@XZ db 0FFh
.xdata$x:000020EC                                         ; DATA XREF: .xdata$x:000020FCo
.xdata$x:000020ED                 db 0FFh
.xdata$x:000020EE                 db 0FFh
.xdata$x:000020EF                 db 0FFh
.xdata$x:000020F0                 dd offset __unwindfunclet$??0_Generic_error_category@std@@QAE@XZ$0
.xdata$x:000020F4 __ehfuncinfo$??0_Generic_error_category@std@@QAE@XZ db  22h ; "
.xdata$x:000020F4                                         ; DATA XREF: __ehhandler$??0_Generic_error_category@std@@QAE@XZ+11o
.xdata$x:000020F5                 db    5
.xdata$x:000020F6                 db  93h ; 
.xdata$x:000020F7                 db  19h
.xdata$x:000020F8                 db    1
.xdata$x:000020F9                 db    0
.xdata$x:000020FA                 db    0
.xdata$x:000020FB                 db    0
.xdata$x:000020FC                 dd offset __unwindtable$??0_Generic_error_category@std@@QAE@XZ
.xdata$x:00002100                 db    0
.xdata$x:00002101                 db    0
.xdata$x:00002102                 db    0
.xdata$x:00002103                 db    0
.xdata$x:00002104                 db    0
.xdata$x:00002105                 db    0
.xdata$x:00002106                 db    0
.xdata$x:00002107                 db    0
.xdata$x:00002108                 db    0
.xdata$x:00002109                 db    0
.xdata$x:0000210A                 db    0
.xdata$x:0000210B                 db    0
.xdata$x:0000210C                 db    0
.xdata$x:0000210D                 db    0
.xdata$x:0000210E                 db    0
.xdata$x:0000210F                 db    0
.xdata$x:00002110                 db    0
.xdata$x:00002111                 db    0
.xdata$x:00002112                 db    0
.xdata$x:00002113                 db    0
.xdata$x:00002114                 db    0
.xdata$x:00002115                 db    0
.xdata$x:00002116                 db    0
.xdata$x:00002117                 db    0
.xdata$x:00002117 _xdata$x        ends
.xdata$x:00002117
.xdata$x:00002118 ; ===========================================================================
.xdata$x:00002118
.xdata$x:00002118 ; Segment type: Pure data
.xdata$x:00002118 ; Segment permissions: Read
.xdata$x:00002118 _xdata$x        segment dword public 'DATA' use32
.xdata$x:00002118                 assume cs:_xdata$x
.xdata$x:00002118                 ;org 2118h
.xdata$x:00002118 ; COMDAT (pick associative to section at 1BAC)
.xdata$x:00002118 __unwindtable$?message@_Generic_error_category@std@@UBE?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@2@H@Z db 0FFh
.xdata$x:00002118                                         ; DATA XREF: .xdata$x:00002128o
.xdata$x:00002119                 db 0FFh
.xdata$x:0000211A                 db 0FFh
.xdata$x:0000211B                 db 0FFh
.xdata$x:0000211C                 dd offset __unwindfunclet$?message@_Generic_error_category@std@@UBE?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@2@H@Z$0
.xdata$x:00002120 __ehfuncinfo$?message@_Generic_error_category@std@@UBE?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@2@H@Z db  22h ; "
.xdata$x:00002120                                         ; DATA XREF: __ehhandler$?message@_Generic_error_category@std@@UBE?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@2@H@Z+11o
.xdata$x:00002121                 db    5
.xdata$x:00002122                 db  93h ; 
.xdata$x:00002123                 db  19h
.xdata$x:00002124                 db    1
.xdata$x:00002125                 db    0
.xdata$x:00002126                 db    0
.xdata$x:00002127                 db    0
.xdata$x:00002128                 dd offset __unwindtable$?message@_Generic_error_category@std@@UBE?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@2@H@Z
.xdata$x:0000212C                 db    0
.xdata$x:0000212D                 db    0
.xdata$x:0000212E                 db    0
.xdata$x:0000212F                 db    0
.xdata$x:00002130                 db    0
.xdata$x:00002131                 db    0
.xdata$x:00002132                 db    0
.xdata$x:00002133                 db    0
.xdata$x:00002134                 db    0
.xdata$x:00002135                 db    0
.xdata$x:00002136                 db    0
.xdata$x:00002137                 db    0
.xdata$x:00002138                 db    0
.xdata$x:00002139                 db    0
.xdata$x:0000213A                 db    0
.xdata$x:0000213B                 db    0
.xdata$x:0000213C                 db    0
.xdata$x:0000213D                 db    0
.xdata$x:0000213E                 db    0
.xdata$x:0000213F                 db    0
.xdata$x:00002140                 db    0
.xdata$x:00002141                 db    0
.xdata$x:00002142                 db    0
.xdata$x:00002143                 db    0
.xdata$x:00002143 _xdata$x        ends
.xdata$x:00002143
.xdata$x:00002144 ; ===========================================================================
.xdata$x:00002144
.xdata$x:00002144 ; Segment type: Pure data
.xdata$x:00002144 ; Segment permissions: Read
.xdata$x:00002144 _xdata$x        segment dword public 'DATA' use32
.xdata$x:00002144                 assume cs:_xdata$x
.xdata$x:00002144                 ;org 2144h
.xdata$x:00002144 ; COMDAT (pick associative to section at B0C)
.xdata$x:00002144 __unwindtable$??1_Generic_error_category@std@@UAE@XZ db 0FFh
.xdata$x:00002144                                         ; DATA XREF: .xdata$x:00002154o
.xdata$x:00002145                 db 0FFh
.xdata$x:00002146                 db 0FFh
.xdata$x:00002147                 db 0FFh
.xdata$x:00002148                 dd offset __unwindfunclet$??1_Generic_error_category@std@@UAE@XZ$0
.xdata$x:0000214C __ehfuncinfo$??1_Generic_error_category@std@@UAE@XZ db  22h ; "
.xdata$x:0000214C                                         ; DATA XREF: __ehhandler$??1_Generic_error_category@std@@UAE@XZ+11o
.xdata$x:0000214D                 db    5
.xdata$x:0000214E                 db  93h ; 
.xdata$x:0000214F                 db  19h
.xdata$x:00002150                 db    1
.xdata$x:00002151                 db    0
.xdata$x:00002152                 db    0
.xdata$x:00002153                 db    0
.xdata$x:00002154                 dd offset __unwindtable$??1_Generic_error_category@std@@UAE@XZ
.xdata$x:00002158                 db    0
.xdata$x:00002159                 db    0
.xdata$x:0000215A                 db    0
.xdata$x:0000215B                 db    0
.xdata$x:0000215C                 db    0
.xdata$x:0000215D                 db    0
.xdata$x:0000215E                 db    0
.xdata$x:0000215F                 db    0
.xdata$x:00002160                 db    0
.xdata$x:00002161                 db    0
.xdata$x:00002162                 db    0
.xdata$x:00002163                 db    0
.xdata$x:00002164                 db    0
.xdata$x:00002165                 db    0
.xdata$x:00002166                 db    0
.xdata$x:00002167                 db    0
.xdata$x:00002168                 db    0
.xdata$x:00002169                 db    0
.xdata$x:0000216A                 db    0
.xdata$x:0000216B                 db    0
.xdata$x:0000216C                 db    0
.xdata$x:0000216D                 db    0
.xdata$x:0000216E                 db    0
.xdata$x:0000216F                 db    0
.xdata$x:0000216F _xdata$x        ends
.xdata$x:0000216F
.xdata$x:00002170 ; ===========================================================================
.xdata$x:00002170
.xdata$x:00002170 ; Segment type: Pure data
.xdata$x:00002170 ; Segment permissions: Read
.xdata$x:00002170 _xdata$x        segment dword public 'DATA' use32
.xdata$x:00002170                 assume cs:_xdata$x
.xdata$x:00002170                 ;org 2170h
.xdata$x:00002170 ; COMDAT (pick associative to section at 848)
.xdata$x:00002170 __unwindtable$??0_Iostream_error_category@std@@QAE@XZ db 0FFh
.xdata$x:00002170                                         ; DATA XREF: .xdata$x:00002180o
.xdata$x:00002171                 db 0FFh
.xdata$x:00002172                 db 0FFh
.xdata$x:00002173                 db 0FFh
.xdata$x:00002174                 dd offset __unwindfunclet$??0_Iostream_error_category@std@@QAE@XZ$0
.xdata$x:00002178 __ehfuncinfo$??0_Iostream_error_category@std@@QAE@XZ db  22h ; "
.xdata$x:00002178                                         ; DATA XREF: __ehhandler$??0_Iostream_error_category@std@@QAE@XZ+11o
.xdata$x:00002179                 db    5
.xdata$x:0000217A                 db  93h ; 
.xdata$x:0000217B                 db  19h
.xdata$x:0000217C                 db    1
.xdata$x:0000217D                 db    0
.xdata$x:0000217E                 db    0
.xdata$x:0000217F                 db    0
.xdata$x:00002180                 dd offset __unwindtable$??0_Iostream_error_category@std@@QAE@XZ
.xdata$x:00002184                 db    0
.xdata$x:00002185                 db    0
.xdata$x:00002186                 db    0
.xdata$x:00002187                 db    0
.xdata$x:00002188                 db    0
.xdata$x:00002189                 db    0
.xdata$x:0000218A                 db    0
.xdata$x:0000218B                 db    0
.xdata$x:0000218C                 db    0
.xdata$x:0000218D                 db    0
.xdata$x:0000218E                 db    0
.xdata$x:0000218F                 db    0
.xdata$x:00002190                 db    0
.xdata$x:00002191                 db    0
.xdata$x:00002192                 db    0
.xdata$x:00002193                 db    0
.xdata$x:00002194                 db    0
.xdata$x:00002195                 db    0
.xdata$x:00002196                 db    0
.xdata$x:00002197                 db    0
.xdata$x:00002198                 db    0
.xdata$x:00002199                 db    0
.xdata$x:0000219A                 db    0
.xdata$x:0000219B                 db    0
.xdata$x:0000219B _xdata$x        ends
.xdata$x:0000219B
.xdata$x:0000219C ; ===========================================================================
.xdata$x:0000219C
.xdata$x:0000219C ; Segment type: Pure data
.xdata$x:0000219C ; Segment permissions: Read
.xdata$x:0000219C _xdata$x        segment dword public 'DATA' use32
.xdata$x:0000219C                 assume cs:_xdata$x
.xdata$x:0000219C                 ;org 219Ch
.xdata$x:0000219C ; COMDAT (pick associative to section at 1C64)
.xdata$x:0000219C __unwindtable$?message@_Iostream_error_category@std@@UBE?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@2@H@Z db 0FFh
.xdata$x:0000219C                                         ; DATA XREF: .xdata$x:000021ACo
.xdata$x:0000219D                 db 0FFh
.xdata$x:0000219E                 db 0FFh
.xdata$x:0000219F                 db 0FFh
.xdata$x:000021A0                 dd offset __unwindfunclet$?message@_Iostream_error_category@std@@UBE?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@2@H@Z$0
.xdata$x:000021A4 __ehfuncinfo$?message@_Iostream_error_category@std@@UBE?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@2@H@Z db  22h ; "
.xdata$x:000021A4                                         ; DATA XREF: __ehhandler$?message@_Iostream_error_category@std@@UBE?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@2@H@Z+11o
.xdata$x:000021A5                 db    5
.xdata$x:000021A6                 db  93h ; 
.xdata$x:000021A7                 db  19h
.xdata$x:000021A8                 db    1
.xdata$x:000021A9                 db    0
.xdata$x:000021AA                 db    0
.xdata$x:000021AB                 db    0
.xdata$x:000021AC                 dd offset __unwindtable$?message@_Iostream_error_category@std@@UBE?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@2@H@Z
.xdata$x:000021B0                 db    0
.xdata$x:000021B1                 db    0
.xdata$x:000021B2                 db    0
.xdata$x:000021B3                 db    0
.xdata$x:000021B4                 db    0
.xdata$x:000021B5                 db    0
.xdata$x:000021B6                 db    0
.xdata$x:000021B7                 db    0
.xdata$x:000021B8                 db    0
.xdata$x:000021B9                 db    0
.xdata$x:000021BA                 db    0
.xdata$x:000021BB                 db    0
.xdata$x:000021BC                 db    0
.xdata$x:000021BD                 db    0
.xdata$x:000021BE                 db    0
.xdata$x:000021BF                 db    0
.xdata$x:000021C0                 db    0
.xdata$x:000021C1                 db    0
.xdata$x:000021C2                 db    0
.xdata$x:000021C3                 db    0
.xdata$x:000021C4                 db    0
.xdata$x:000021C5                 db    0
.xdata$x:000021C6                 db    0
.xdata$x:000021C7                 db    0
.xdata$x:000021C7 _xdata$x        ends
.xdata$x:000021C7
.xdata$x:000021C8 ; ===========================================================================
.xdata$x:000021C8
.xdata$x:000021C8 ; Segment type: Pure data
.xdata$x:000021C8 ; Segment permissions: Read
.xdata$x:000021C8 _xdata$x        segment dword public 'DATA' use32
.xdata$x:000021C8                 assume cs:_xdata$x
.xdata$x:000021C8                 ;org 21C8h
.xdata$x:000021C8 ; COMDAT (pick associative to section at B7C)
.xdata$x:000021C8 __unwindtable$??1_Iostream_error_category@std@@UAE@XZ db 0FFh
.xdata$x:000021C8                                         ; DATA XREF: .xdata$x:000021D8o
.xdata$x:000021C9                 db 0FFh
.xdata$x:000021CA                 db 0FFh
.xdata$x:000021CB                 db 0FFh
.xdata$x:000021CC                 dd offset __unwindfunclet$??1_Iostream_error_category@std@@UAE@XZ$0
.xdata$x:000021D0 __ehfuncinfo$??1_Iostream_error_category@std@@UAE@XZ db  22h ; "
.xdata$x:000021D0                                         ; DATA XREF: __ehhandler$??1_Iostream_error_category@std@@UAE@XZ+11o
.xdata$x:000021D1                 db    5
.xdata$x:000021D2                 db  93h ; 
.xdata$x:000021D3                 db  19h
.xdata$x:000021D4                 db    1
.xdata$x:000021D5                 db    0
.xdata$x:000021D6                 db    0
.xdata$x:000021D7                 db    0
.xdata$x:000021D8                 dd offset __unwindtable$??1_Iostream_error_category@std@@UAE@XZ
.xdata$x:000021DC                 db    0
.xdata$x:000021DD                 db    0
.xdata$x:000021DE                 db    0
.xdata$x:000021DF                 db    0
.xdata$x:000021E0                 db    0
.xdata$x:000021E1                 db    0
.xdata$x:000021E2                 db    0
.xdata$x:000021E3                 db    0
.xdata$x:000021E4                 db    0
.xdata$x:000021E5                 db    0
.xdata$x:000021E6                 db    0
.xdata$x:000021E7                 db    0
.xdata$x:000021E8                 db    0
.xdata$x:000021E9                 db    0
.xdata$x:000021EA                 db    0
.xdata$x:000021EB                 db    0
.xdata$x:000021EC                 db    0
.xdata$x:000021ED                 db    0
.xdata$x:000021EE                 db    0
.xdata$x:000021EF                 db    0
.xdata$x:000021F0                 db    0
.xdata$x:000021F1                 db    0
.xdata$x:000021F2                 db    0
.xdata$x:000021F3                 db    0
.xdata$x:000021F3 _xdata$x        ends
.xdata$x:000021F3
.xdata$x:000021F4 ; ===========================================================================
.xdata$x:000021F4
.xdata$x:000021F4 ; Segment type: Pure data
.xdata$x:000021F4 ; Segment permissions: Read
.xdata$x:000021F4 _xdata$x        segment dword public 'DATA' use32
.xdata$x:000021F4                 assume cs:_xdata$x
.xdata$x:000021F4                 ;org 21F4h
.xdata$x:000021F4 ; COMDAT (pick associative to section at 8C4)
.xdata$x:000021F4 __unwindtable$??0_System_error_category@std@@QAE@XZ db 0FFh
.xdata$x:000021F4                                         ; DATA XREF: .xdata$x:00002204o
.xdata$x:000021F5                 db 0FFh
.xdata$x:000021F6                 db 0FFh
.xdata$x:000021F7                 db 0FFh
.xdata$x:000021F8                 dd offset __unwindfunclet$??0_System_error_category@std@@QAE@XZ$0
.xdata$x:000021FC __ehfuncinfo$??0_System_error_category@std@@QAE@XZ db  22h ; "
.xdata$x:000021FC                                         ; DATA XREF: __ehhandler$??0_System_error_category@std@@QAE@XZ+11o
.xdata$x:000021FD                 db    5
.xdata$x:000021FE                 db  93h ; 
.xdata$x:000021FF                 db  19h
.xdata$x:00002200                 db    1
.xdata$x:00002201                 db    0
.xdata$x:00002202                 db    0
.xdata$x:00002203                 db    0
.xdata$x:00002204                 dd offset __unwindtable$??0_System_error_category@std@@QAE@XZ
.xdata$x:00002208                 align 20h
.xdata$x:00002208 _xdata$x        ends
.xdata$x:00002208
.xdata$x:00002220 ; ===========================================================================
.xdata$x:00002220
.xdata$x:00002220 ; Segment type: Pure data
.xdata$x:00002220 ; Segment permissions: Read
.xdata$x:00002220 _xdata$x        segment dword public 'DATA' use32
.xdata$x:00002220                 assume cs:_xdata$x
.xdata$x:00002220                 ;org 2220h
.xdata$x:00002220 ; COMDAT (pick associative to section at 1D28)
.xdata$x:00002220 __unwindtable$?message@_System_error_category@std@@UBE?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@2@H@Z db 0FFh
.xdata$x:00002220                                         ; DATA XREF: .xdata$x:00002230o
.xdata$x:00002221                 db 0FFh
.xdata$x:00002222                 db 0FFh
.xdata$x:00002223                 db 0FFh
.xdata$x:00002224                 dd offset __unwindfunclet$?message@_System_error_category@std@@UBE?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@2@H@Z$0
.xdata$x:00002228 __ehfuncinfo$?message@_System_error_category@std@@UBE?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@2@H@Z db  22h ; "
.xdata$x:00002228                                         ; DATA XREF: __ehhandler$?message@_System_error_category@std@@UBE?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@2@H@Z+11o
.xdata$x:00002229                 db    5
.xdata$x:0000222A                 db  93h ; 
.xdata$x:0000222B                 db  19h
.xdata$x:0000222C                 db    1
.xdata$x:0000222D                 db    0
.xdata$x:0000222E                 db    0
.xdata$x:0000222F                 db    0
.xdata$x:00002230                 dd offset __unwindtable$?message@_System_error_category@std@@UBE?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@2@H@Z
.xdata$x:00002234                 db    0
.xdata$x:00002235                 db    0
.xdata$x:00002236                 db    0
.xdata$x:00002237                 db    0
.xdata$x:00002238                 db    0
.xdata$x:00002239                 db    0
.xdata$x:0000223A                 db    0
.xdata$x:0000223B                 db    0
.xdata$x:0000223C                 db    0
.xdata$x:0000223D                 db    0
.xdata$x:0000223E                 db    0
.xdata$x:0000223F                 db    0
.xdata$x:00002240                 db    0
.xdata$x:00002241                 db    0
.xdata$x:00002242                 db    0
.xdata$x:00002243                 db    0
.xdata$x:00002244                 db    0
.xdata$x:00002245                 db    0
.xdata$x:00002246                 db    0
.xdata$x:00002247                 db    0
.xdata$x:00002248                 db    0
.xdata$x:00002249                 db    0
.xdata$x:0000224A                 db    0
.xdata$x:0000224B                 db    0
.xdata$x:0000224B _xdata$x        ends
.xdata$x:0000224B
.xdata$x:0000224C ; ===========================================================================
.xdata$x:0000224C
.xdata$x:0000224C ; Segment type: Pure data
.xdata$x:0000224C ; Segment permissions: Read
.xdata$x:0000224C _xdata$x        segment dword public 'DATA' use32
.xdata$x:0000224C                 assume cs:_xdata$x
.xdata$x:0000224C                 ;org 224Ch
.xdata$x:0000224C ; COMDAT (pick associative to section at BEC)
.xdata$x:0000224C __unwindtable$??1_System_error_category@std@@UAE@XZ db 0FFh
.xdata$x:0000224C                                         ; DATA XREF: .xdata$x:0000225Co
.xdata$x:0000224D                 db 0FFh
.xdata$x:0000224E                 db 0FFh
.xdata$x:0000224F                 db 0FFh
.xdata$x:00002250                 dd offset __unwindfunclet$??1_System_error_category@std@@UAE@XZ$0
.xdata$x:00002254 __ehfuncinfo$??1_System_error_category@std@@UAE@XZ db  22h ; "
.xdata$x:00002254                                         ; DATA XREF: __ehhandler$??1_System_error_category@std@@UAE@XZ+11o
.xdata$x:00002255                 db    5
.xdata$x:00002256                 db  93h ; 
.xdata$x:00002257                 db  19h
.xdata$x:00002258                 db    1
.xdata$x:00002259                 db    0
.xdata$x:0000225A                 db    0
.xdata$x:0000225B                 db    0
.xdata$x:0000225C                 dd offset __unwindtable$??1_System_error_category@std@@UAE@XZ
.xdata$x:00002260                 db    0
.xdata$x:00002261                 db    0
.xdata$x:00002262                 db    0
.xdata$x:00002263                 db    0
.xdata$x:00002264                 db    0
.xdata$x:00002265                 db    0
.xdata$x:00002266                 db    0
.xdata$x:00002267                 db    0
.xdata$x:00002268                 db    0
.xdata$x:00002269                 db    0
.xdata$x:0000226A                 db    0
.xdata$x:0000226B                 db    0
.xdata$x:0000226C                 db    0
.xdata$x:0000226D                 db    0
.xdata$x:0000226E                 db    0
.xdata$x:0000226F                 db    0
.xdata$x:00002270                 db    0
.xdata$x:00002271                 db    0
.xdata$x:00002272                 db    0
.xdata$x:00002273                 db    0
.xdata$x:00002274                 db    0
.xdata$x:00002275                 db    0
.xdata$x:00002276                 db    0
.xdata$x:00002277                 db    0
.xdata$x:00002277 _xdata$x        ends
.xdata$x:00002277
.xdata$x:00002278 ; ===========================================================================
.xdata$x:00002278
.xdata$x:00002278 ; Segment type: Pure data
.xdata$x:00002278 ; Segment permissions: Read
.xdata$x:00002278 _xdata$x        segment dword public 'DATA' use32
.xdata$x:00002278                 assume cs:_xdata$x
.xdata$x:00002278                 ;org 2278h
.xdata$x:00002278 ; COMDAT (pick associative to section at 4A0)
.xdata$x:00002278 __unwindtable$??$construct@U_Container_proxy@std@@U12@@?$allocator@U_Container_proxy@std@@@std@@QAEXPAU_Container_proxy@1@$$QAU21@@Z db 0FFh
.xdata$x:00002278                                         ; DATA XREF: .xdata$x:00002288o
.xdata$x:00002279                 db 0FFh
.xdata$x:0000227A                 db 0FFh
.xdata$x:0000227B                 db 0FFh
.xdata$x:0000227C                 dd offset __unwindfunclet$??$construct@U_Container_proxy@std@@U12@@?$allocator@U_Container_proxy@std@@@std@@QAEXPAU_Container_proxy@1@$$QAU21@@Z$0
.xdata$x:00002280 __ehfuncinfo$??$construct@U_Container_proxy@std@@U12@@?$allocator@U_Container_proxy@std@@@std@@QAEXPAU_Container_proxy@1@$$QAU21@@Z db  22h ; "
.xdata$x:00002280                                         ; DATA XREF: __ehhandler$??$construct@U_Container_proxy@std@@U12@@?$allocator@U_Container_proxy@std@@@std@@QAEXPAU_Container_proxy@1@$$QAU21@@Z+11o
.xdata$x:00002281                 db    5
.xdata$x:00002282                 db  93h ; 
.xdata$x:00002283                 db  19h
.xdata$x:00002284                 db    1
.xdata$x:00002285                 db    0
.xdata$x:00002286                 db    0
.xdata$x:00002287                 db    0
.xdata$x:00002288                 dd offset __unwindtable$??$construct@U_Container_proxy@std@@U12@@?$allocator@U_Container_proxy@std@@@std@@QAEXPAU_Container_proxy@1@$$QAU21@@Z
.xdata$x:0000228C                 db    0
.xdata$x:0000228D                 db    0
.xdata$x:0000228E                 db    0
.xdata$x:0000228F                 db    0
.xdata$x:00002290                 db    0
.xdata$x:00002291                 db    0
.xdata$x:00002292                 db    0
.xdata$x:00002293                 db    0
.xdata$x:00002294                 db    0
.xdata$x:00002295                 db    0
.xdata$x:00002296                 db    0
.xdata$x:00002297                 db    0
.xdata$x:00002298                 db    0
.xdata$x:00002299                 db    0
.xdata$x:0000229A                 db    0
.xdata$x:0000229B                 db    0
.xdata$x:0000229C                 db    0
.xdata$x:0000229D                 db    0
.xdata$x:0000229E                 db    0
.xdata$x:0000229F                 db    0
.xdata$x:000022A0                 db    0
.xdata$x:000022A1                 db    0
.xdata$x:000022A2                 db    0
.xdata$x:000022A3                 db    0
.xdata$x:000022A3 _xdata$x        ends
.xdata$x:000022A3
.xdata$x:000022A4 ; ===========================================================================
.xdata$x:000022A4
.xdata$x:000022A4 ; Segment type: Pure data
.xdata$x:000022A4 ; Segment permissions: Read
.xdata$x:000022A4 _xdata$x        segment dword public 'DATA' use32
.xdata$x:000022A4                 assume cs:_xdata$x
.xdata$x:000022A4                 ;org 22A4h
.xdata$x:000022A4 ; COMDAT (pick associative to section at 3CC)
.xdata$x:000022A4 __unwindtable$??$construct@PADAAPAD@?$allocator@D@std@@QAEXPAPADAAPAD@Z db 0FFh
.xdata$x:000022A4                                         ; DATA XREF: .xdata$x:000022B4o
.xdata$x:000022A5                 db 0FFh
.xdata$x:000022A6                 db 0FFh
.xdata$x:000022A7                 db 0FFh
.xdata$x:000022A8                 dd offset __unwindfunclet$??$construct@PADAAPAD@?$allocator@D@std@@QAEXPAPADAAPAD@Z$0
.xdata$x:000022AC __ehfuncinfo$??$construct@PADAAPAD@?$allocator@D@std@@QAEXPAPADAAPAD@Z db  22h ; "
.xdata$x:000022AC                                         ; DATA XREF: __ehhandler$??$construct@PADAAPAD@?$allocator@D@std@@QAEXPAPADAAPAD@Z+11o
.xdata$x:000022AD                 db    5
.xdata$x:000022AE                 db  93h ; 
.xdata$x:000022AF                 db  19h
.xdata$x:000022B0                 db    1
.xdata$x:000022B1                 db    0
.xdata$x:000022B2                 db    0
.xdata$x:000022B3                 db    0
.xdata$x:000022B4                 dd offset __unwindtable$??$construct@PADAAPAD@?$allocator@D@std@@QAEXPAPADAAPAD@Z
.xdata$x:000022B8                 db    0
.xdata$x:000022B9                 db    0
.xdata$x:000022BA                 db    0
.xdata$x:000022BB                 db    0
.xdata$x:000022BC                 db    0
.xdata$x:000022BD                 db    0
.xdata$x:000022BE                 db    0
.xdata$x:000022BF                 db    0
.xdata$x:000022C0                 db    0
.xdata$x:000022C1                 db    0
.xdata$x:000022C2                 db    0
.xdata$x:000022C3                 db    0
.xdata$x:000022C4                 db    0
.xdata$x:000022C5                 db    0
.xdata$x:000022C6                 db    0
.xdata$x:000022C7                 db    0
.xdata$x:000022C8                 db    0
.xdata$x:000022C9                 db    0
.xdata$x:000022CA                 db    0
.xdata$x:000022CB                 db    0
.xdata$x:000022CC                 db    0
.xdata$x:000022CD                 db    0
.xdata$x:000022CE                 db    0
.xdata$x:000022CF                 db    0
.xdata$x:000022CF _xdata$x        ends
.xdata$x:000022CF
.bss:000022D0 ; ===========================================================================
.bss:000022D0
.bss:000022D0 ; Segment type: Uninitialized
.bss:000022D0 ; Segment permissions: Read/Write
.bss:000022D0 _bss            segment byte public 'BSS' use32
.bss:000022D0                 assume cs:_bss
.bss:000022D0                 ;org 22D0h
.bss:000022D0                 assume es:nothing, ss:nothing, ds:_xdata$x, fs:nothing, gs:nothing
.bss:000022D0 _allocator_arg  db    ? ;
.bss:000022D1 _piecewise_construct db    ? ;
.bss:000022D2                 align 4
.bss:000022D2 _bss            ends
.bss:000022D2
.rdata:000022D4 ; ===========================================================================
.rdata:000022D4
.rdata:000022D4 ; Segment type: Pure data
.rdata:000022D4 ; Segment permissions: Read
.rdata:000022D4 _rdata          segment dword public 'DATA' use32
.rdata:000022D4                 assume cs:_rdata
.rdata:000022D4                 ;org 22D4h
.rdata:000022D4 ; COMDAT (pick largest)
.rdata:000022D4                 dd offset ??_R4error_category@std@@6B@ ; const std::error_category::`RTTI Complete Object Locator'
.rdata:000022D8                 public ??_7error_category@std@@6B@
.rdata:000022D8 ; const std::error_category::`vftable'
.rdata:000022D8 ??_7error_category@std@@6B@ dd offset ??_Eerror_category@std@@UAEPAXI@Z
.rdata:000022D8                                         ; DATA XREF: std::error_category::error_category(void)+Ao
.rdata:000022D8                                         ; std::error_category::~error_category(void)+Ao
.rdata:000022D8                                         ; std::error_category::`vector deleting destructor'(uint)
.rdata:000022DC                 dd offset __purecall
.rdata:000022E0                 dd offset __purecall
.rdata:000022E4                 dd offset ?default_error_condition@error_category@std@@UBE?AVerror_condition@2@H@Z ; std::error_category::default_error_condition(int)
.rdata:000022E8                 dd offset ?equivalent@error_category@std@@UBE_NABVerror_code@2@H@Z ; std::error_category::equivalent(std::error_code const &,int)
.rdata:000022EC                 dd offset ?equivalent@error_category@std@@UBE_NHABVerror_condition@2@@Z ; std::error_category::equivalent(int,std::error_condition const &)
.rdata:000022EC _rdata          ends
.rdata:000022EC
.rdata:000022F0 ; ===========================================================================
.rdata:000022F0
.rdata:000022F0 ; Segment type: Pure data
.rdata:000022F0 ; Segment permissions: Read
.rdata:000022F0 _rdata          segment dword public 'DATA' use32
.rdata:000022F0                 assume cs:_rdata
.rdata:000022F0                 ;org 22F0h
.rdata:000022F0 ; COMDAT (pick largest)
.rdata:000022F0                 dd offset ??_R4_Generic_error_category@std@@6B@ ; const std::_Generic_error_category::`RTTI Complete Object Locator'
.rdata:000022F4                 public ??_7_Generic_error_category@std@@6B@
.rdata:000022F4 ; const std::_Generic_error_category::`vftable'
.rdata:000022F4 ??_7_Generic_error_category@std@@6B@ dd offset ??_E_Generic_error_category@std@@UAEPAXI@Z
.rdata:000022F4                                         ; DATA XREF: std::_Generic_error_category::_Generic_error_category(void)+38o
.rdata:000022F4                                         ; std::_Generic_error_category::`vector deleting destructor'(uint)
.rdata:000022F8                 dd offset ?name@_Generic_error_category@std@@UBEPBDXZ ; std::_Generic_error_category::name(void)
.rdata:000022FC                 dd offset ?message@_Generic_error_category@std@@UBE?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@2@H@Z ; std::_Generic_error_category::message(int)
.rdata:00002300                 dd offset ?default_error_condition@error_category@std@@UBE?AVerror_condition@2@H@Z ; std::error_category::default_error_condition(int)
.rdata:00002304                 dd offset ?equivalent@error_category@std@@UBE_NABVerror_code@2@H@Z ; std::error_category::equivalent(std::error_code const &,int)
.rdata:00002308                 dd offset ?equivalent@error_category@std@@UBE_NHABVerror_condition@2@@Z ; std::error_category::equivalent(int,std::error_condition const &)
.rdata:00002308 _rdata          ends
.rdata:00002308
.rdata:0000230C ; ===========================================================================
.rdata:0000230C
.rdata:0000230C ; Segment type: Pure data
.rdata:0000230C ; Segment permissions: Read
.rdata:0000230C _rdata          segment dword public 'DATA' use32
.rdata:0000230C                 assume cs:_rdata
.rdata:0000230C                 ;org 230Ch
.rdata:0000230C ; COMDAT (pick any)
.rdata:0000230C                 public ??_C@_07DCLBNMLN@generic?$AA@
.rdata:0000230C ; `string'
.rdata:0000230C ??_C@_07DCLBNMLN@generic?$AA@ db 'generic',0
.rdata:0000230C                                         ; DATA XREF: std::_Generic_error_category::name(void)+7o
.rdata:0000230C _rdata          ends
.rdata:0000230C
.rdata:00002314 ; ===========================================================================
.rdata:00002314
.rdata:00002314 ; Segment type: Pure data
.rdata:00002314 ; Segment permissions: Read
.rdata:00002314 _rdata          segment dword public 'DATA' use32
.rdata:00002314                 assume cs:_rdata
.rdata:00002314                 ;org 2314h
.rdata:00002314 ; COMDAT (pick any)
.rdata:00002314                 public ??_C@_0O@BFJCFAAK@unknown?5error?$AA@
.rdata:00002314 ; `string'
.rdata:00002314 ??_C@_0O@BFJCFAAK@unknown?5error?$AA@ db 'unknown error',0
.rdata:00002314                                         ; DATA XREF: std::_Generic_error_category::message(int):loc_1BF8o
.rdata:00002314                                         ; std::_System_error_category::message(int):loc_1D74o
.rdata:00002322                 align 4
.rdata:00002322 _rdata          ends
.rdata:00002322
.rdata:00002324 ; ===========================================================================
.rdata:00002324
.rdata:00002324 ; Segment type: Pure data
.rdata:00002324 ; Segment permissions: Read
.rdata:00002324 _rdata          segment dword public 'DATA' use32
.rdata:00002324                 assume cs:_rdata
.rdata:00002324                 ;org 2324h
.rdata:00002324 ; COMDAT (pick largest)
.rdata:00002324                 dd offset ??_R4_Iostream_error_category@std@@6B@ ; const std::_Iostream_error_category::`RTTI Complete Object Locator'
.rdata:00002328                 public ??_7_Iostream_error_category@std@@6B@
.rdata:00002328 ; const std::_Iostream_error_category::`vftable'
.rdata:00002328 ??_7_Iostream_error_category@std@@6B@ dd offset ??_E_Iostream_error_category@std@@UAEPAXI@Z
.rdata:00002328                                         ; DATA XREF: std::_Iostream_error_category::_Iostream_error_category(void)+38o
.rdata:00002328                                         ; std::_Iostream_error_category::`vector deleting destructor'(uint)
.rdata:0000232C                 dd offset ?name@_Iostream_error_category@std@@UBEPBDXZ ; std::_Iostream_error_category::name(void)
.rdata:00002330                 dd offset ?message@_Iostream_error_category@std@@UBE?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@2@H@Z ; std::_Iostream_error_category::message(int)
.rdata:00002334                 dd offset ?default_error_condition@error_category@std@@UBE?AVerror_condition@2@H@Z ; std::error_category::default_error_condition(int)
.rdata:00002338                 dd offset ?equivalent@error_category@std@@UBE_NABVerror_code@2@H@Z ; std::error_category::equivalent(std::error_code const &,int)
.rdata:0000233C                 dd offset ?equivalent@error_category@std@@UBE_NHABVerror_condition@2@@Z ; std::error_category::equivalent(int,std::error_condition const &)
.rdata:0000233C _rdata          ends
.rdata:0000233C
.rdata:00002340 ; ===========================================================================
.rdata:00002340
.rdata:00002340 ; Segment type: Pure data
.rdata:00002340 ; Segment permissions: Read
.rdata:00002340 _rdata          segment dword public 'DATA' use32
.rdata:00002340                 assume cs:_rdata
.rdata:00002340                 ;org 2340h
.rdata:00002340 ; COMDAT (pick any)
.rdata:00002340                 public ??_C@_08LLGCOLLL@iostream?$AA@
.rdata:00002340 ; `string'
.rdata:00002340 ??_C@_08LLGCOLLL@iostream?$AA@ db 'iostream',0
.rdata:00002340                                         ; DATA XREF: std::_Iostream_error_category::name(void)+7o
.rdata:00002349                 align 4
.rdata:00002349 _rdata          ends
.rdata:00002349
.rdata:0000234C ; ===========================================================================
.rdata:0000234C
.rdata:0000234C ; Segment type: Pure data
.rdata:0000234C ; Segment permissions: Read
.rdata:0000234C _rdata          segment dword public 'DATA' use32
.rdata:0000234C                 assume cs:_rdata
.rdata:0000234C                 ;org 234Ch
.rdata:0000234C ; COMDAT (pick any)
.rdata:0000234C                 public ??_C@_0BG@PADBLCHM@iostream?5stream?5error?$AA@
.rdata:0000234C ; char `string'[]
.rdata:0000234C ??_C@_0BG@PADBLCHM@iostream?5stream?5error?$AA@ db 'iostream stream error',0
.rdata:0000234C                                         ; DATA XREF: std::_Iostream_error_category::message(int)+35o
.rdata:00002362                 align 4
.rdata:00002362 _rdata          ends
.rdata:00002362
.rdata:00002364 ; ===========================================================================
.rdata:00002364
.rdata:00002364 ; Segment type: Pure data
.rdata:00002364 ; Segment permissions: Read
.rdata:00002364 _rdata          segment dword public 'DATA' use32
.rdata:00002364                 assume cs:_rdata
.rdata:00002364                 ;org 2364h
.rdata:00002364 ; COMDAT (pick largest)
.rdata:00002364                 dd offset ??_R4_System_error_category@std@@6B@ ; const std::_System_error_category::`RTTI Complete Object Locator'
.rdata:00002368                 public ??_7_System_error_category@std@@6B@
.rdata:00002368 ; const std::_System_error_category::`vftable'
.rdata:00002368 ??_7_System_error_category@std@@6B@ dd offset ??_E_System_error_category@std@@UAEPAXI@Z
.rdata:00002368                                         ; DATA XREF: std::_System_error_category::_System_error_category(void)+38o
.rdata:00002368                                         ; std::_System_error_category::`vector deleting destructor'(uint)
.rdata:0000236C                 dd offset ?name@_System_error_category@std@@UBEPBDXZ ; std::_System_error_category::name(void)
.rdata:00002370                 dd offset ?message@_System_error_category@std@@UBE?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@2@H@Z ; std::_System_error_category::message(int)
.rdata:00002374                 dd offset ?default_error_condition@_System_error_category@std@@UBE?AVerror_condition@2@H@Z ; std::_System_error_category::default_error_condition(int)
.rdata:00002378                 dd offset ?equivalent@error_category@std@@UBE_NABVerror_code@2@H@Z ; std::error_category::equivalent(std::error_code const &,int)
.rdata:0000237C                 dd offset ?equivalent@error_category@std@@UBE_NHABVerror_condition@2@@Z ; std::error_category::equivalent(int,std::error_condition const &)
.rdata:0000237C _rdata          ends
.rdata:0000237C
.rdata:00002380 ; ===========================================================================
.rdata:00002380
.rdata:00002380 ; Segment type: Pure data
.rdata:00002380 ; Segment permissions: Read
.rdata:00002380 _rdata          segment dword public 'DATA' use32
.rdata:00002380                 assume cs:_rdata
.rdata:00002380                 ;org 2380h
.rdata:00002380 ; COMDAT (pick any)
.rdata:00002380                 public ??_C@_06FHFOAHML@system?$AA@
.rdata:00002380 ; `string'
.rdata:00002380 ??_C@_06FHFOAHML@system?$AA@ db 'system',0
.rdata:00002380                                         ; DATA XREF: std::_System_error_category::name(void)+7o
.rdata:00002387                 align 4
.rdata:00002387 _rdata          ends
.rdata:00002387
.bss:00002388 ; ===========================================================================
.bss:00002388
.bss:00002388 ; Segment type: Uninitialized
.bss:00002388 ; Segment permissions: Read/Write
.bss:00002388 _bss            segment dword public 'BSS' use32
.bss:00002388                 assume cs:_bss
.bss:00002388                 ;org 2388h
.bss:00002388 ; COMDAT (pick any)
.bss:00002388                 assume es:nothing, ss:nothing, ds:_xdata$x, fs:nothing, gs:nothing
.bss:00002388                 public ?_Generic_object@?$_Error_objects@H@std@@2V_Generic_error_category@2@A
.bss:00002388 ; std::_Generic_error_category std::_Error_objects<int>::_Generic_object
.bss:00002388 ?_Generic_object@?$_Error_objects@H@std@@2V_Generic_error_category@2@A db    ? ;
.bss:00002388                                         ; DATA XREF: `dynamic initializer for 'std::_Generic_error_category std::_Error_objects<int>::_Generic_object''(void)+3o
.bss:00002388                                         ; `dynamic atexit destructor for 'std::_Generic_error_category std::_Error_objects<int>::_Generic_object''(void)+3o ...
.bss:00002389                 db    ? ;
.bss:0000238A                 db    ? ;
.bss:0000238B                 db    ? ;
.bss:0000238B _bss            ends
.bss:0000238B
.bss:0000238C ; ===========================================================================
.bss:0000238C
.bss:0000238C ; Segment type: Uninitialized
.bss:0000238C ; Segment permissions: Read/Write
.bss:0000238C _bss            segment dword public 'BSS' use32
.bss:0000238C                 assume cs:_bss
.bss:0000238C                 ;org 238Ch
.bss:0000238C ; COMDAT (pick any)
.bss:0000238C                 assume es:nothing, ss:nothing, ds:_xdata$x, fs:nothing, gs:nothing
.bss:0000238C                 public ?_Iostream_object@?$_Error_objects@H@std@@2V_Iostream_error_category@2@A
.bss:0000238C ; std::_Iostream_error_category std::_Error_objects<int>::_Iostream_object
.bss:0000238C ?_Iostream_object@?$_Error_objects@H@std@@2V_Iostream_error_category@2@A db    ? ;
.bss:0000238C                                         ; DATA XREF: `dynamic initializer for 'std::_Iostream_error_category std::_Error_objects<int>::_Iostream_object''(void)+3o
.bss:0000238C                                         ; `dynamic atexit destructor for 'std::_Iostream_error_category std::_Error_objects<int>::_Iostream_object''(void)+3o
.bss:0000238D                 db    ? ;
.bss:0000238E                 db    ? ;
.bss:0000238F                 db    ? ;
.bss:0000238F _bss            ends
.bss:0000238F
.bss:00002390 ; ===========================================================================
.bss:00002390
.bss:00002390 ; Segment type: Uninitialized
.bss:00002390 ; Segment permissions: Read/Write
.bss:00002390 _bss            segment dword public 'BSS' use32
.bss:00002390                 assume cs:_bss
.bss:00002390                 ;org 2390h
.bss:00002390 ; COMDAT (pick any)
.bss:00002390                 assume es:nothing, ss:nothing, ds:_xdata$x, fs:nothing, gs:nothing
.bss:00002390                 public ?_System_object@?$_Error_objects@H@std@@2V_System_error_category@2@A
.bss:00002390 ; std::_System_error_category std::_Error_objects<int>::_System_object
.bss:00002390 ?_System_object@?$_Error_objects@H@std@@2V_System_error_category@2@A db    ? ;
.bss:00002390                                         ; DATA XREF: `dynamic initializer for 'std::_System_error_category std::_Error_objects<int>::_System_object''(void)+3o
.bss:00002390                                         ; `dynamic atexit destructor for 'std::_System_error_category std::_Error_objects<int>::_System_object''(void)+3o ...
.bss:00002391                 db    ? ;
.bss:00002392                 db    ? ;
.bss:00002393                 db    ? ;
.bss:00002393 _bss            ends
.bss:00002393
.bss:00002394 ; ===========================================================================
.bss:00002394
.bss:00002394 ; Segment type: Uninitialized
.bss:00002394 ; Segment permissions: Read/Write
.bss:00002394 _bss            segment dword public 'BSS' use32
.bss:00002394                 assume cs:_bss
.bss:00002394                 ;org 2394h
.bss:00002394 ; COMDAT (pick any)
.bss:00002394                 assume es:nothing, ss:nothing, ds:_xdata$x, fs:nothing, gs:nothing
.bss:00002394                 public ?id@?$num_put@DV?$back_insert_iterator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@std@@2V0locale@2@A
.bss:00002394 ; std::locale::id std::num_put<char,std::back_insert_iterator<std::basic_string<char,std::char_traits<char>,std::allocator<char>>>>::id
.bss:00002394 ?id@?$num_put@DV?$back_insert_iterator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@std@@2V0locale@2@A db    ? ;
.bss:00002394                                         ; DATA XREF: `dynamic initializer for 'std::locale::id std::num_put<char,std::back_insert_iterator<std::basic_string<char,std::char_traits<char>,std::allocator<char>>>>::id''(void)+5o
.bss:00002395                 db    ? ;
.bss:00002396                 db    ? ;
.bss:00002397                 db    ? ;
.bss:00002397 _bss            ends
.bss:00002397
.bss:00002398 ; ===========================================================================
.bss:00002398
.bss:00002398 ; Segment type: Uninitialized
.bss:00002398 ; Segment permissions: Read/Write
.bss:00002398 _bss            segment dword public 'BSS' use32
.bss:00002398                 assume cs:_bss
.bss:00002398                 ;org 2398h
.bss:00002398 ; COMDAT (pick any)
.bss:00002398                 assume es:nothing, ss:nothing, ds:_xdata$x, fs:nothing, gs:nothing
.bss:00002398                 public ?id@?$num_put@_WV?$back_insert_iterator@V?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@@std@@@std@@2V0locale@2@A
.bss:00002398 ; std::locale::id std::num_put<wchar_t,std::back_insert_iterator<std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>>>>::id
.bss:00002398 ?id@?$num_put@_WV?$back_insert_iterator@V?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@@std@@@std@@2V0locale@2@A db    ? ;
.bss:00002398                                         ; DATA XREF: `dynamic initializer for 'std::locale::id std::num_put<wchar_t,std::back_insert_iterator<std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>>>>::id''(void)+5o
.bss:00002399                 db    ? ;
.bss:0000239A                 db    ? ;
.bss:0000239B                 db    ? ;
.bss:0000239B _bss            ends
.bss:0000239B
.rdata:0000239C ; ===========================================================================
.rdata:0000239C
.rdata:0000239C ; Segment type: Pure data
.rdata:0000239C ; Segment permissions: Read
.rdata:0000239C ; Segment alignment 'qword' can not be represented in assembly
.rdata:0000239C _rdata          segment para public 'DATA' use32
.rdata:0000239C                 assume cs:_rdata
.rdata:0000239C                 ;org 239Ch
.rdata:0000239C ; COMDAT (pick any)
.rdata:0000239C                 public ??_C@_1IO@FEAPGJBD@?$AAC?$AA?3?$AA?2?$AAP?$AAr?$AAo?$AAg?$AAr?$AAa?$AAm?$AA?5?$AAF?$AAi?$AAl?$AAe?$AAs?$AA?5?$AA?$CI?$AAx?$AA8?$AA6?$AA?$CJ?$AA?2?$AAM?$AAi?$AAc?$AAr?$AAo?$AAs?$AAo?$AAf?$AAt@
.rdata:0000239C ; wchar_t `string'
.rdata:0000239C ??_C@_1IO@FEAPGJBD@?$AAC?$AA?3?$AA?2?$AAP?$AAr?$AAo?$AAg?$AAr?$AAa?$AAm?$AA?5?$AAF?$AAi?$AAl?$AAe?$AAs?$AA?5?$AA?$CI?$AAx?$AA8?$AA6?$AA?$CJ?$AA?2?$AAM?$AAi?$AAc?$AAr?$AAo?$AAs?$AAo?$AAf?$AAt@:
.rdata:0000239C                                         ; DATA XREF: std::basic_string<char,std::char_traits<char>,std::allocator<char>>::assign(char const *)+Co
.rdata:0000239C                                         ; std::basic_string<char,std::char_traits<char>,std::allocator<char>>::assign(char const *,uint)+12o ...
.rdata:0000239C                 unicode 0, <C:\Program Files (x86)\Microsoft Visual Studio 12.0\VC\in>
.rdata:0000239C                 unicode 0, <clude\xstring>,0
.rdata:0000242A                 align 4
.rdata:0000242A _rdata          ends
.rdata:0000242A
.bss:0000242C ; ===========================================================================
.bss:0000242C
.bss:0000242C ; Segment type: Uninitialized
.bss:0000242C ; Segment permissions: Read/Write
.bss:0000242C _bss            segment dword public 'BSS' use32
.bss:0000242C                 assume cs:_bss
.bss:0000242C                 ;org 242Ch
.bss:0000242C ; COMDAT (pick any)
.bss:0000242C                 assume es:nothing, ss:nothing, ds:_xdata$x, fs:nothing, gs:nothing
.bss:0000242C                 public ?id@?$numpunct@D@std@@2V0locale@2@A
.bss:0000242C ; std::locale::id std::numpunct<char>::id
.bss:0000242C ?id@?$numpunct@D@std@@2V0locale@2@A db    ? ;
.bss:0000242C                                         ; DATA XREF: `dynamic initializer for 'std::locale::id std::numpunct<char>::id''(void)+5o
.bss:0000242D                 db    ? ;
.bss:0000242E                 db    ? ;
.bss:0000242F                 db    ? ;
.bss:0000242F _bss            ends
.bss:0000242F
.bss:00002430 ; ===========================================================================
.bss:00002430
.bss:00002430 ; Segment type: Uninitialized
.bss:00002430 ; Segment permissions: Read/Write
.bss:00002430 _bss            segment dword public 'BSS' use32
.bss:00002430                 assume cs:_bss
.bss:00002430                 ;org 2430h
.bss:00002430 ; COMDAT (pick any)
.bss:00002430                 assume es:nothing, ss:nothing, ds:_xdata$x, fs:nothing, gs:nothing
.bss:00002430                 public ?id@?$numpunct@_W@std@@2V0locale@2@A
.bss:00002430 ; std::locale::id std::numpunct<wchar_t>::id
.bss:00002430 ?id@?$numpunct@_W@std@@2V0locale@2@A db    ? ;
.bss:00002430                                         ; DATA XREF: `dynamic initializer for 'std::locale::id std::numpunct<wchar_t>::id''(void)+5o
.bss:00002431                 db    ? ;
.bss:00002432                 db    ? ;
.bss:00002433                 db    ? ;
.bss:00002433 _bss            ends
.bss:00002433
.rdata:00002434 ; ===========================================================================
.rdata:00002434
.rdata:00002434 ; Segment type: Pure data
.rdata:00002434 ; Segment permissions: Read
.rdata:00002434 ; Segment alignment 'qword' can not be represented in assembly
.rdata:00002434 _rdata          segment para public 'DATA' use32
.rdata:00002434                 assume cs:_rdata
.rdata:00002434                 ;org 2434h
.rdata:00002434 ; COMDAT (pick any)
.rdata:00002434                 public ??_C@_1IM@EINEHPHE@?$AAC?$AA?3?$AA?2?$AAP?$AAr?$AAo?$AAg?$AAr?$AAa?$AAm?$AA?5?$AAF?$AAi?$AAl?$AAe?$AAs?$AA?5?$AA?$CI?$AAx?$AA8?$AA6?$AA?$CJ?$AA?2?$AAM?$AAi?$AAc?$AAr?$AAo?$AAs?$AAo?$AAf?$AAt@
.rdata:00002434 ; wchar_t `string'
.rdata:00002434 ??_C@_1IM@EINEHPHE@?$AAC?$AA?3?$AA?2?$AAP?$AAr?$AAo?$AAg?$AAr?$AAa?$AAm?$AA?5?$AAF?$AAi?$AAl?$AAe?$AAs?$AA?5?$AA?$CI?$AAx?$AA8?$AA6?$AA?$CJ?$AA?2?$AAM?$AAi?$AAc?$AAr?$AAo?$AAs?$AAo?$AAf?$AAt@:
.rdata:00002434                                         ; DATA XREF: std::vector<DlgInfo,std::allocator<DlgInfo>>::operator[](uint)+19o
.rdata:00002434                                         ; std::vector<DlgInfo,std::allocator<DlgInfo>>::operator[](uint)+49o ...
.rdata:00002434                 unicode 0, <C:\Program Files (x86)\Microsoft Visual Studio 12.0\VC\in>
.rdata:00002434                 unicode 0, <clude\vector>,0
.rdata:00002434 _rdata          ends
.rdata:00002434
.rdata:000024C0 ; ===========================================================================
.rdata:000024C0
.rdata:000024C0 ; Segment type: Pure data
.rdata:000024C0 ; Segment permissions: Read
.rdata:000024C0 _rdata          segment dword public 'DATA' use32
.rdata:000024C0                 assume cs:_rdata
.rdata:000024C0                 ;org 24C0h
.rdata:000024C0 ; COMDAT (pick any)
.rdata:000024C0                 public ??_C@_1DM@LHGCHCBA@?$AAv?$AAe?$AAc?$AAt?$AAo?$AAr?$AA?5?$AAs?$AAu?$AAb?$AAs?$AAc?$AAr?$AAi?$AAp?$AAt?$AA?5?$AAo?$AAu?$AAt?$AA?5?$AAo?$AAf?$AA?5?$AAr?$AAa?$AAn?$AAg?$AAe?$AA?$AA@
.rdata:000024C0 ; wchar_t `string'
.rdata:000024C0 ??_C@_1DM@LHGCHCBA@?$AAv?$AAe?$AAc?$AAt?$AAo?$AAr?$AA?5?$AAs?$AAu?$AAb?$AAs?$AAc?$AAr?$AAi?$AAp?$AAt?$AA?5?$AAo?$AAu?$AAt?$AA?5?$AAo?$AAf?$AA?5?$AAr?$AAa?$AAn?$AAg?$AAe?$AA?$AA@:
.rdata:000024C0                                         ; DATA XREF: std::vector<DlgInfo,std::allocator<DlgInfo>>::operator[](uint)+1Eo
.rdata:000024C0                 unicode 0, <vector subscript out of range>,0
.rdata:000024C0 _rdata          ends
.rdata:000024C0
.rdata:000024FC ; ===========================================================================
.rdata:000024FC
.rdata:000024FC ; Segment type: Pure data
.rdata:000024FC ; Segment permissions: Read
.rdata:000024FC _rdata          segment dword public 'DATA' use32
.rdata:000024FC                 assume cs:_rdata
.rdata:000024FC                 ;org 24FCh
.rdata:000024FC ; COMDAT (pick any)
.rdata:000024FC                 public ??_C@_0CE@OFMIGAMM@Standard?5C?$CL?$CL?5Libraries?5Out?5of?5Ra@
.rdata:000024FC ; `string'
.rdata:000024FC ??_C@_0CE@OFMIGAMM@Standard?5C?$CL?$CL?5Libraries?5Out?5of?5Ra@ db 'Standard C++ Libraries Out of Range',0
.rdata:000024FC                                         ; DATA XREF: std::vector<DlgInfo,std::allocator<DlgInfo>>::operator[](uint)+2Bo
.rdata:000024FC _rdata          ends
.rdata:000024FC
.rdata:00002520 ; ===========================================================================
.rdata:00002520
.rdata:00002520 ; Segment type: Pure data
.rdata:00002520 ; Segment permissions: Read
.rdata:00002520 ; Segment alignment 'qword' can not be represented in assembly
.rdata:00002520 _rdata          segment para public 'DATA' use32
.rdata:00002520                 assume cs:_rdata
.rdata:00002520                 ;org 2520h
.rdata:00002520 ; COMDAT (pick any)
.rdata:00002520                 public ??_C@_1FG@IBPIFFN@?$AA?$CC?$AAS?$AAt?$AAa?$AAn?$AAd?$AAa?$AAr?$AAd?$AA?5?$AAC?$AA?$CL?$AA?$CL?$AA?5?$AAL?$AAi?$AAb?$AAr?$AAa?$AAr?$AAi?$AAe?$AAs?$AA?5?$AAO?$AAu?$AAt?$AA?5?$AAo?$AAf?$AA?5?$AAR@
.rdata:00002520 ; `string'
.rdata:00002520 ??_C@_1FG@IBPIFFN@?$AA?$CC?$AAS?$AAt?$AAa?$AAn?$AAd?$AAa?$AAr?$AAd?$AA?5?$AAC?$AA?$CL?$AA?$CL?$AA?5?$AAL?$AAi?$AAb?$AAr?$AAa?$AAr?$AAi?$AAe?$AAs?$AA?5?$AAO?$AAu?$AAt?$AA?5?$AAo?$AAf?$AA?5?$AAR@:
.rdata:00002520                                         ; DATA XREF: std::vector<DlgInfo,std::allocator<DlgInfo>>::operator[](uint):loc_D40o
.rdata:00002520                 unicode 0, <"Standard C++ Libraries Out of Range" && 0>,0
.rdata:00002576                 align 4
.rdata:00002576 _rdata          ends
.rdata:00002576
.rdata:00002578 ; ===========================================================================
.rdata:00002578
.rdata:00002578 ; Segment type: Pure data
.rdata:00002578 ; Segment permissions: Read
.rdata:00002578 _rdata          segment dword public 'DATA' use32
.rdata:00002578                 assume cs:_rdata
.rdata:00002578                 ;org 2578h
.rdata:00002578 ; COMDAT (pick any)
.rdata:00002578                 public ??_C@_15GANGMFKL@?$AA?$CF?$AAs?$AA?$AA@
.rdata:00002578 ; `string'
.rdata:00002578 ??_C@_15GANGMFKL@?$AA?$CF?$AAs?$AA?$AA@:
.rdata:00002578                                         ; DATA XREF: std::vector<DlgInfo,std::allocator<DlgInfo>>::operator[](uint)+3Do
.rdata:00002578                 unicode 0, <%s>,0
.rdata:0000257E                 align 10h
.rdata:0000257E _rdata          ends
.rdata:0000257E
.rdata:00002580 ; ===========================================================================
.rdata:00002580
.rdata:00002580 ; Segment type: Pure data
.rdata:00002580 ; Segment permissions: Read
.rdata:00002580 ; Segment alignment 'qword' can not be represented in assembly
.rdata:00002580 _rdata          segment para public 'DATA' use32
.rdata:00002580                 assume cs:_rdata
.rdata:00002580                 ;org 2580h
.rdata:00002580 ; COMDAT (pick any)
.rdata:00002580                 public ??_C@_1JO@EEMIOACN@?$AAs?$AAt?$AAd?$AA?3?$AA?3?$AAv?$AAe?$AAc?$AAt?$AAo?$AAr?$AA?$DM?$AAs?$AAt?$AAr?$AAu?$AAc?$AAt?$AA?5?$AAD?$AAl?$AAg?$AAI?$AAn?$AAf?$AAo?$AA?0?$AAc?$AAl?$AAa?$AAs?$AAs@
.rdata:00002580 ; `string'
.rdata:00002580 ??_C@_1JO@EEMIOACN@?$AAs?$AAt?$AAd?$AA?3?$AA?3?$AAv?$AAe?$AAc?$AAt?$AAo?$AAr?$AA?$DM?$AAs?$AAt?$AAr?$AAu?$AAc?$AAt?$AA?5?$AAD?$AAl?$AAg?$AAI?$AAn?$AAf?$AAo?$AA?0?$AAc?$AAl?$AAa?$AAs?$AAs@:
.rdata:00002580                                         ; DATA XREF: std::vector<DlgInfo,std::allocator<DlgInfo>>::operator[](uint)+6Ao
.rdata:00002580                 unicode 0, <std::vector>
.rdata:00002580                 dw 3Ch
.rdata:00002580                 unicode 0, <struct DlgInfo,class std::allocator>
.rdata:00002580                 dw 3Ch
.rdata:00002580                 unicode 0, <struct DlgInfo>
.rdata:00002580                 dw 3Eh
.rdata:00002580                 unicode 0, < >
.rdata:00002580                 dw 3Eh
.rdata:00002580                 unicode 0, <::operator []>,0
.rdata:0000261E                 align 10h
.rdata:0000261E _rdata          ends
.rdata:0000261E
.rdata:00002620 ; ===========================================================================
.rdata:00002620
.rdata:00002620 ; Segment type: Pure data
.rdata:00002620 ; Segment permissions: Read
.rdata:00002620 _rdata          segment dword public 'DATA' use32
.rdata:00002620                 assume cs:_rdata
.rdata:00002620                 ;org 2620h
.rdata:00002620 ; COMDAT (pick any)
.rdata:00002620                 public ??_C@_1BO@MEPPHOO@?$AA?$CC?$AAo?$AAu?$AAt?$AA?5?$AAo?$AAf?$AA?5?$AAr?$AAa?$AAn?$AAg?$AAe?$AA?$CC?$AA?$AA@
.rdata:00002620 ; `string'
.rdata:00002620 ??_C@_1BO@MEPPHOO@?$AA?$CC?$AAo?$AAu?$AAt?$AA?5?$AAo?$AAf?$AA?5?$AAr?$AAa?$AAn?$AAg?$AAe?$AA?$CC?$AA?$AA@:
.rdata:00002620                                         ; DATA XREF: std::vector<DlgInfo,std::allocator<DlgInfo>>::operator[](uint)+6Fo
.rdata:00002620                 unicode 0, <"out of range">,0
.rdata:0000263E                 align 10h
.rdata:0000263E _rdata          ends
.rdata:0000263E
.rdata:00002640 ; ===========================================================================
.rdata:00002640
.rdata:00002640 ; Segment type: Pure data
.rdata:00002640 ; Segment permissions: Read
.rdata:00002640 _rdata          segment dword public 'DATA' use32
.rdata:00002640                 assume cs:_rdata
.rdata:00002640                 ;org 2640h
.rdata:00002640 ; COMDAT (pick any)
.rdata:00002640                 public ??_C@_0BA@JFNIOLAK@string?5too?5long?$AA@
.rdata:00002640 ; char `string'[]
.rdata:00002640 ??_C@_0BA@JFNIOLAK@string?5too?5long?$AA@ db 'string too long',0
.rdata:00002640                                         ; DATA XREF: std::basic_string<char,std::char_traits<char>,std::allocator<char>>::_Xlen(void)+7o
.rdata:00002640 _rdata          ends
.rdata:00002640
.rdata:00002650 ; ===========================================================================
.rdata:00002650
.rdata:00002650 ; Segment type: Pure data
.rdata:00002650 ; Segment permissions: Read
.rdata:00002650 _rdata          segment dword public 'DATA' use32
.rdata:00002650                 assume cs:_rdata
.rdata:00002650                 ;org 2650h
.rdata:00002650 ; COMDAT (pick any)
.rdata:00002650                 public ??_C@_0BI@CFPLBAOH@invalid?5string?5position?$AA@
.rdata:00002650 ; char `string'[]
.rdata:00002650 ??_C@_0BI@CFPLBAOH@invalid?5string?5position?$AA@ db 'invalid string position',0
.rdata:00002650                                         ; DATA XREF: std::basic_string<char,std::char_traits<char>,std::allocator<char>>::_Xran(void)+7o
.rdata:00002650                                         ; std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>>::_Xran(void)+7o
.rdata:00002650 _rdata          ends
.rdata:00002650
.rdata:00002668 ; ===========================================================================
.rdata:00002668
.rdata:00002668 ; Segment type: Pure data
.rdata:00002668 ; Segment permissions: Read
.rdata:00002668 _rdata          segment dword public 'DATA' use32
.rdata:00002668                 assume cs:_rdata
.rdata:00002668                 ;org 2668h
.rdata:00002668 ; COMDAT (pick any)
.rdata:00002668                 public ??_C@_1CK@EOPGIILJ@?$AAi?$AAn?$AAv?$AAa?$AAl?$AAi?$AAd?$AA?5?$AAn?$AAu?$AAl?$AAl?$AA?5?$AAp?$AAo?$AAi?$AAn?$AAt?$AAe?$AAr?$AA?$AA@
.rdata:00002668 ; wchar_t `string'
.rdata:00002668 ??_C@_1CK@EOPGIILJ@?$AAi?$AAn?$AAv?$AAa?$AAl?$AAi?$AAd?$AA?5?$AAn?$AAu?$AAl?$AAl?$AA?5?$AAp?$AAo?$AAi?$AAn?$AAt?$AAe?$AAr?$AA?$AA@:
.rdata:00002668                                         ; DATA XREF: std::_Debug_pointer<char>(char const *,wchar_t const *,uint)+11o
.rdata:00002668                                         ; std::_Debug_pointer<wchar_t>(wchar_t const *,wchar_t const *,uint)+11o
.rdata:00002668                 unicode 0, <invalid null pointer>,0
.rdata:00002692                 align 4
.rdata:00002692 _rdata          ends
.rdata:00002692
.rdata$r:00002694 ; ===========================================================================
.rdata$r:00002694
.rdata$r:00002694 ; Segment type: Pure data
.rdata$r:00002694 ; Segment permissions: Read
.rdata$r:00002694 _rdata$r        segment dword public 'DATA' use32
.rdata$r:00002694                 assume cs:_rdata$r
.rdata$r:00002694                 ;org 2694h
.rdata$r:00002694 ; COMDAT (pick any)
.rdata$r:00002694                 public ??_R4error_category@std@@6B@
.rdata$r:00002694 ; const std::error_category::`RTTI Complete Object Locator'
.rdata$r:00002694 ??_R4error_category@std@@6B@ db    0    ; DATA XREF: .rdata:000022D4o
.rdata$r:00002695                 db    0
.rdata$r:00002696                 db    0
.rdata$r:00002697                 db    0
.rdata$r:00002698                 db    0
.rdata$r:00002699                 db    0
.rdata$r:0000269A                 db    0
.rdata$r:0000269B                 db    0
.rdata$r:0000269C                 db    0
.rdata$r:0000269D                 db    0
.rdata$r:0000269E                 db    0
.rdata$r:0000269F                 db    0
.rdata$r:000026A0                 dd offset ??_R0?AVerror_category@std@@@8 ; std::error_category `RTTI Type Descriptor'
.rdata$r:000026A4                 dd offset ??_R3error_category@std@@8 ; std::error_category::`RTTI Class Hierarchy Descriptor'
.rdata$r:000026A4 _rdata$r        ends
.rdata$r:000026A4
.data$r:000026A8 ; ===========================================================================
.data$r:000026A8
.data$r:000026A8 ; Segment type: Pure data
.data$r:000026A8 ; Segment permissions: Read/Write
.data$r:000026A8 _data$r         segment dword public 'DATA' use32
.data$r:000026A8                 assume cs:_data$r
.data$r:000026A8                 ;org 26A8h
.data$r:000026A8 ; COMDAT (pick any)
.data$r:000026A8                 public ??_R0?AVerror_category@std@@@8
.data$r:000026A8 ; class std::error_category `RTTI Type Descriptor'
.data$r:000026A8 ??_R0?AVerror_category@std@@@8 dd offset ??_7type_info@@6B@
.data$r:000026A8                                         ; DATA XREF: .rdata$r:000026A0o
.data$r:000026A8                                         ; .rdata$r:std::error_category::`RTTI Base Class Descriptor at (0,-1,0,64)'o
.data$r:000026A8                                         ; const type_info::`vftable'
.data$r:000026AC                 align 10h
.data$r:000026B0 a_?averror_cate db '.?AVerror_category@std@@',0
.data$r:000026C9                 align 4
.data$r:000026C9 _data$r         ends
.data$r:000026C9
.rdata$r:000026CC ; ===========================================================================
.rdata$r:000026CC
.rdata$r:000026CC ; Segment type: Pure data
.rdata$r:000026CC ; Segment permissions: Read
.rdata$r:000026CC _rdata$r        segment dword public 'DATA' use32
.rdata$r:000026CC                 assume cs:_rdata$r
.rdata$r:000026CC                 ;org 26CCh
.rdata$r:000026CC ; COMDAT (pick any)
.rdata$r:000026CC                 public ??_R3error_category@std@@8
.rdata$r:000026CC ; std::error_category::`RTTI Class Hierarchy Descriptor'
.rdata$r:000026CC ??_R3error_category@std@@8 db    0      ; DATA XREF: .rdata$r:000026A4o
.rdata$r:000026CC                                         ; .rdata$r:000026FCo
.rdata$r:000026CD                 db    0
.rdata$r:000026CE                 db    0
.rdata$r:000026CF                 db    0
.rdata$r:000026D0                 db    0
.rdata$r:000026D1                 db    0
.rdata$r:000026D2                 db    0
.rdata$r:000026D3                 db    0
.rdata$r:000026D4                 db    1
.rdata$r:000026D5                 db    0
.rdata$r:000026D6                 db    0
.rdata$r:000026D7                 db    0
.rdata$r:000026D8                 dd offset ??_R2error_category@std@@8 ; std::error_category::`RTTI Base Class Array'
.rdata$r:000026D8 _rdata$r        ends
.rdata$r:000026D8
.rdata$r:000026DC ; ===========================================================================
.rdata$r:000026DC
.rdata$r:000026DC ; Segment type: Pure data
.rdata$r:000026DC ; Segment permissions: Read
.rdata$r:000026DC _rdata$r        segment dword public 'DATA' use32
.rdata$r:000026DC                 assume cs:_rdata$r
.rdata$r:000026DC                 ;org 26DCh
.rdata$r:000026DC ; COMDAT (pick any)
.rdata$r:000026DC                 public ??_R2error_category@std@@8
.rdata$r:000026DC ; std::error_category::`RTTI Base Class Array'
.rdata$r:000026DC ??_R2error_category@std@@8 dd offset ??_R1A@?0A@EA@error_category@std@@8
.rdata$r:000026DC                                         ; DATA XREF: .rdata$r:000026D8o
.rdata$r:000026DC                                         ; std::error_category::`RTTI Base Class Descriptor at (0,-1,0,64)'
.rdata$r:000026E0                 db    0
.rdata$r:000026E1                 align 4
.rdata$r:000026E1 _rdata$r        ends
.rdata$r:000026E1
.rdata$r:000026E4 ; ===========================================================================
.rdata$r:000026E4
.rdata$r:000026E4 ; Segment type: Pure data
.rdata$r:000026E4 ; Segment permissions: Read
.rdata$r:000026E4 _rdata$r        segment dword public 'DATA' use32
.rdata$r:000026E4                 assume cs:_rdata$r
.rdata$r:000026E4                 ;org 26E4h
.rdata$r:000026E4 ; COMDAT (pick any)
.rdata$r:000026E4                 public ??_R1A@?0A@EA@error_category@std@@8
.rdata$r:000026E4 ; std::error_category::`RTTI Base Class Descriptor at (0, -1, 0, 64)'
.rdata$r:000026E4 ??_R1A@?0A@EA@error_category@std@@8 dd offset ??_R0?AVerror_category@std@@@8
.rdata$r:000026E4                                         ; DATA XREF: .rdata$r:std::error_category::`RTTI Base Class Array'o
.rdata$r:000026E4                                         ; .rdata$r:00002754o ...
.rdata$r:000026E4                                         ; std::error_category `RTTI Type Descriptor'
.rdata$r:000026E8                 align 10h
.rdata$r:000026F0                 db 0FFh
.rdata$r:000026F1                 db 0FFh
.rdata$r:000026F2                 db 0FFh
.rdata$r:000026F3                 db 0FFh
.rdata$r:000026F4                 db    0
.rdata$r:000026F5                 db    0
.rdata$r:000026F6                 db    0
.rdata$r:000026F7                 db    0
.rdata$r:000026F8                 db  40h ; @
.rdata$r:000026F9                 db    0
.rdata$r:000026FA                 db    0
.rdata$r:000026FB                 db    0
.rdata$r:000026FC                 dd offset ??_R3error_category@std@@8 ; std::error_category::`RTTI Class Hierarchy Descriptor'
.rdata$r:000026FC _rdata$r        ends
.rdata$r:000026FC
.rdata$r:00002700 ; ===========================================================================
.rdata$r:00002700
.rdata$r:00002700 ; Segment type: Pure data
.rdata$r:00002700 ; Segment permissions: Read
.rdata$r:00002700 _rdata$r        segment dword public 'DATA' use32
.rdata$r:00002700                 assume cs:_rdata$r
.rdata$r:00002700                 ;org 2700h
.rdata$r:00002700 ; COMDAT (pick any)
.rdata$r:00002700                 public ??_R4_Generic_error_category@std@@6B@
.rdata$r:00002700 ; const std::_Generic_error_category::`RTTI Complete Object Locator'
.rdata$r:00002700 ??_R4_Generic_error_category@std@@6B@ db    0
.rdata$r:00002700                                         ; DATA XREF: .rdata:000022F0o
.rdata$r:00002701                 db    0
.rdata$r:00002702                 db    0
.rdata$r:00002703                 db    0
.rdata$r:00002704                 db    0
.rdata$r:00002705                 db    0
.rdata$r:00002706                 db    0
.rdata$r:00002707                 db    0
.rdata$r:00002708                 db    0
.rdata$r:00002709                 db    0
.rdata$r:0000270A                 db    0
.rdata$r:0000270B                 db    0
.rdata$r:0000270C                 dd offset ??_R0?AV_Generic_error_category@std@@@8 ; std::_Generic_error_category `RTTI Type Descriptor'
.rdata$r:00002710                 dd offset ??_R3_Generic_error_category@std@@8 ; std::_Generic_error_category::`RTTI Class Hierarchy Descriptor'
.rdata$r:00002710 _rdata$r        ends
.rdata$r:00002710
.data$r:00002714 ; ===========================================================================
.data$r:00002714
.data$r:00002714 ; Segment type: Pure data
.data$r:00002714 ; Segment permissions: Read/Write
.data$r:00002714 _data$r         segment dword public 'DATA' use32
.data$r:00002714                 assume cs:_data$r
.data$r:00002714                 ;org 2714h
.data$r:00002714 ; COMDAT (pick any)
.data$r:00002714                 public ??_R0?AV_Generic_error_category@std@@@8
.data$r:00002714 ; class std::_Generic_error_category `RTTI Type Descriptor'
.data$r:00002714 ??_R0?AV_Generic_error_category@std@@@8 dd offset ??_7type_info@@6B@
.data$r:00002714                                         ; DATA XREF: .rdata$r:0000270Co
.data$r:00002714                                         ; .rdata$r:std::_Generic_error_category::`RTTI Base Class Descriptor at (0,-1,0,64)'o
.data$r:00002714                                         ; const type_info::`vftable'
.data$r:00002718                 db    0
.data$r:00002719                 db    0
.data$r:0000271A                 db    0
.data$r:0000271B                 db    0
.data$r:0000271C                 db  2Eh ; .
.data$r:0000271D                 db  3Fh ; ?
.data$r:0000271E                 db  41h ; A
.data$r:0000271F                 db  56h ; V
.data$r:00002720                 db  5Fh ; _
.data$r:00002721                 db  47h ; G
.data$r:00002722                 db  65h ; e
.data$r:00002723                 db  6Eh ; n
.data$r:00002724                 db  65h ; e
.data$r:00002725                 db  72h ; r
.data$r:00002726                 db  69h ; i
.data$r:00002727                 db  63h ; c
.data$r:00002728                 db  5Fh ; _
.data$r:00002729                 db  65h ; e
.data$r:0000272A                 db  72h ; r
.data$r:0000272B                 db  72h ; r
.data$r:0000272C                 db  6Fh ; o
.data$r:0000272D                 db  72h ; r
.data$r:0000272E                 db  5Fh ; _
.data$r:0000272F                 db  63h ; c
.data$r:00002730                 db  61h ; a
.data$r:00002731                 db  74h ; t
.data$r:00002732                 db  65h ; e
.data$r:00002733                 db  67h ; g
.data$r:00002734                 db  6Fh ; o
.data$r:00002735                 db  72h ; r
.data$r:00002736                 db  79h ; y
.data$r:00002737                 db  40h ; @
.data$r:00002738                 db  73h ; s
.data$r:00002739                 db  74h ; t
.data$r:0000273A                 db  64h ; d
.data$r:0000273B                 db  40h ; @
.data$r:0000273C                 db  40h ; @
.data$r:0000273D                 db    0
.data$r:0000273E                 align 10h
.data$r:0000273E _data$r         ends
.data$r:0000273E
.rdata$r:00002740 ; ===========================================================================
.rdata$r:00002740
.rdata$r:00002740 ; Segment type: Pure data
.rdata$r:00002740 ; Segment permissions: Read
.rdata$r:00002740 _rdata$r        segment dword public 'DATA' use32
.rdata$r:00002740                 assume cs:_rdata$r
.rdata$r:00002740                 ;org 2740h
.rdata$r:00002740 ; COMDAT (pick any)
.rdata$r:00002740                 public ??_R3_Generic_error_category@std@@8
.rdata$r:00002740 ; std::_Generic_error_category::`RTTI Class Hierarchy Descriptor'
.rdata$r:00002740 ??_R3_Generic_error_category@std@@8 db    0
.rdata$r:00002740                                         ; DATA XREF: .rdata$r:00002710o
.rdata$r:00002740                                         ; .rdata$r:00002774o
.rdata$r:00002741                 db    0
.rdata$r:00002742                 db    0
.rdata$r:00002743                 db    0
.rdata$r:00002744                 db    0
.rdata$r:00002745                 db    0
.rdata$r:00002746                 db    0
.rdata$r:00002747                 db    0
.rdata$r:00002748                 db    2
.rdata$r:00002749                 db    0
.rdata$r:0000274A                 db    0
.rdata$r:0000274B                 db    0
.rdata$r:0000274C                 dd offset ??_R2_Generic_error_category@std@@8 ; std::_Generic_error_category::`RTTI Base Class Array'
.rdata$r:0000274C _rdata$r        ends
.rdata$r:0000274C
.rdata$r:00002750 ; ===========================================================================
.rdata$r:00002750
.rdata$r:00002750 ; Segment type: Pure data
.rdata$r:00002750 ; Segment permissions: Read
.rdata$r:00002750 _rdata$r        segment dword public 'DATA' use32
.rdata$r:00002750                 assume cs:_rdata$r
.rdata$r:00002750                 ;org 2750h
.rdata$r:00002750 ; COMDAT (pick any)
.rdata$r:00002750                 public ??_R2_Generic_error_category@std@@8
.rdata$r:00002750 ; std::_Generic_error_category::`RTTI Base Class Array'
.rdata$r:00002750 ??_R2_Generic_error_category@std@@8 dd offset ??_R1A@?0A@EA@_Generic_error_category@std@@8
.rdata$r:00002750                                         ; DATA XREF: .rdata$r:0000274Co
.rdata$r:00002750                                         ; std::_Generic_error_category::`RTTI Base Class Descriptor at (0,-1,0,64)'
.rdata$r:00002754                 dd offset ??_R1A@?0A@EA@error_category@std@@8 ; std::error_category::`RTTI Base Class Descriptor at (0,-1,0,64)'
.rdata$r:00002758                 db    0
.rdata$r:00002759                 align 4
.rdata$r:00002759 _rdata$r        ends
.rdata$r:00002759
.rdata$r:0000275C ; ===========================================================================
.rdata$r:0000275C
.rdata$r:0000275C ; Segment type: Pure data
.rdata$r:0000275C ; Segment permissions: Read
.rdata$r:0000275C _rdata$r        segment dword public 'DATA' use32
.rdata$r:0000275C                 assume cs:_rdata$r
.rdata$r:0000275C                 ;org 275Ch
.rdata$r:0000275C ; COMDAT (pick any)
.rdata$r:0000275C                 public ??_R1A@?0A@EA@_Generic_error_category@std@@8
.rdata$r:0000275C ; std::_Generic_error_category::`RTTI Base Class Descriptor at (0, -1, 0, 64)'
.rdata$r:0000275C ??_R1A@?0A@EA@_Generic_error_category@std@@8 dd offset ??_R0?AV_Generic_error_category@std@@@8
.rdata$r:0000275C                                         ; DATA XREF: .rdata$r:std::_Generic_error_category::`RTTI Base Class Array'o
.rdata$r:0000275C                                         ; .rdata$r:000027CCo ...
.rdata$r:0000275C                                         ; std::_Generic_error_category `RTTI Type Descriptor'
.rdata$r:00002760                 db    1
.rdata$r:00002761                 db    0
.rdata$r:00002762                 db    0
.rdata$r:00002763                 db    0
.rdata$r:00002764                 db    0
.rdata$r:00002765                 db    0
.rdata$r:00002766                 db    0
.rdata$r:00002767                 db    0
.rdata$r:00002768                 db 0FFh
.rdata$r:00002769                 db 0FFh
.rdata$r:0000276A                 db 0FFh
.rdata$r:0000276B                 db 0FFh
.rdata$r:0000276C                 db    0
.rdata$r:0000276D                 db    0
.rdata$r:0000276E                 db    0
.rdata$r:0000276F                 db    0
.rdata$r:00002770                 db  40h ; @
.rdata$r:00002771                 db    0
.rdata$r:00002772                 db    0
.rdata$r:00002773                 db    0
.rdata$r:00002774                 dd offset ??_R3_Generic_error_category@std@@8 ; std::_Generic_error_category::`RTTI Class Hierarchy Descriptor'
.rdata$r:00002774 _rdata$r        ends
.rdata$r:00002774
.rdata$r:00002778 ; ===========================================================================
.rdata$r:00002778
.rdata$r:00002778 ; Segment type: Pure data
.rdata$r:00002778 ; Segment permissions: Read
.rdata$r:00002778 _rdata$r        segment dword public 'DATA' use32
.rdata$r:00002778                 assume cs:_rdata$r
.rdata$r:00002778                 ;org 2778h
.rdata$r:00002778 ; COMDAT (pick any)
.rdata$r:00002778                 public ??_R4_Iostream_error_category@std@@6B@
.rdata$r:00002778 ; const std::_Iostream_error_category::`RTTI Complete Object Locator'
.rdata$r:00002778 ??_R4_Iostream_error_category@std@@6B@ db    0
.rdata$r:00002778                                         ; DATA XREF: .rdata:00002324o
.rdata$r:00002779                 db    0
.rdata$r:0000277A                 db    0
.rdata$r:0000277B                 db    0
.rdata$r:0000277C                 db    0
.rdata$r:0000277D                 db    0
.rdata$r:0000277E                 db    0
.rdata$r:0000277F                 db    0
.rdata$r:00002780                 db    0
.rdata$r:00002781                 db    0
.rdata$r:00002782                 db    0
.rdata$r:00002783                 db    0
.rdata$r:00002784                 dd offset ??_R0?AV_Iostream_error_category@std@@@8 ; std::_Iostream_error_category `RTTI Type Descriptor'
.rdata$r:00002788                 dd offset ??_R3_Iostream_error_category@std@@8 ; std::_Iostream_error_category::`RTTI Class Hierarchy Descriptor'
.rdata$r:00002788 _rdata$r        ends
.rdata$r:00002788
.data$r:0000278C ; ===========================================================================
.data$r:0000278C
.data$r:0000278C ; Segment type: Pure data
.data$r:0000278C ; Segment permissions: Read/Write
.data$r:0000278C _data$r         segment dword public 'DATA' use32
.data$r:0000278C                 assume cs:_data$r
.data$r:0000278C                 ;org 278Ch
.data$r:0000278C ; COMDAT (pick any)
.data$r:0000278C                 public ??_R0?AV_Iostream_error_category@std@@@8
.data$r:0000278C ; class std::_Iostream_error_category `RTTI Type Descriptor'
.data$r:0000278C ??_R0?AV_Iostream_error_category@std@@@8 dd offset ??_7type_info@@6B@
.data$r:0000278C                                         ; DATA XREF: .rdata$r:00002784o
.data$r:0000278C                                         ; .rdata$r:std::_Iostream_error_category::`RTTI Base Class Descriptor at (0,-1,0,64)'o
.data$r:0000278C                                         ; const type_info::`vftable'
.data$r:00002790                 db    0
.data$r:00002791                 db    0
.data$r:00002792                 db    0
.data$r:00002793                 db    0
.data$r:00002794                 db  2Eh ; .
.data$r:00002795                 db  3Fh ; ?
.data$r:00002796                 db  41h ; A
.data$r:00002797                 db  56h ; V
.data$r:00002798                 db  5Fh ; _
.data$r:00002799                 db  49h ; I
.data$r:0000279A                 db  6Fh ; o
.data$r:0000279B                 db  73h ; s
.data$r:0000279C                 db  74h ; t
.data$r:0000279D                 db  72h ; r
.data$r:0000279E                 db  65h ; e
.data$r:0000279F                 db  61h ; a
.data$r:000027A0                 db  6Dh ; m
.data$r:000027A1                 db  5Fh ; _
.data$r:000027A2                 db  65h ; e
.data$r:000027A3                 db  72h ; r
.data$r:000027A4                 db  72h ; r
.data$r:000027A5                 db  6Fh ; o
.data$r:000027A6                 db  72h ; r
.data$r:000027A7                 db  5Fh ; _
.data$r:000027A8                 db  63h ; c
.data$r:000027A9                 db  61h ; a
.data$r:000027AA                 db  74h ; t
.data$r:000027AB                 db  65h ; e
.data$r:000027AC                 db  67h ; g
.data$r:000027AD                 db  6Fh ; o
.data$r:000027AE                 db  72h ; r
.data$r:000027AF                 db  79h ; y
.data$r:000027B0                 db  40h ; @
.data$r:000027B1                 db  73h ; s
.data$r:000027B2                 db  74h ; t
.data$r:000027B3                 db  64h ; d
.data$r:000027B4                 db  40h ; @
.data$r:000027B5                 db  40h ; @
.data$r:000027B6                 db    0
.data$r:000027B7                 align 4
.data$r:000027B7 _data$r         ends
.data$r:000027B7
.rdata$r:000027B8 ; ===========================================================================
.rdata$r:000027B8
.rdata$r:000027B8 ; Segment type: Pure data
.rdata$r:000027B8 ; Segment permissions: Read
.rdata$r:000027B8 _rdata$r        segment dword public 'DATA' use32
.rdata$r:000027B8                 assume cs:_rdata$r
.rdata$r:000027B8                 ;org 27B8h
.rdata$r:000027B8 ; COMDAT (pick any)
.rdata$r:000027B8                 public ??_R3_Iostream_error_category@std@@8
.rdata$r:000027B8 ; std::_Iostream_error_category::`RTTI Class Hierarchy Descriptor'
.rdata$r:000027B8 ??_R3_Iostream_error_category@std@@8 db    0
.rdata$r:000027B8                                         ; DATA XREF: .rdata$r:00002788o
.rdata$r:000027B8                                         ; .rdata$r:000027F0o
.rdata$r:000027B9                 db    0
.rdata$r:000027BA                 db    0
.rdata$r:000027BB                 db    0
.rdata$r:000027BC                 db    0
.rdata$r:000027BD                 db    0
.rdata$r:000027BE                 db    0
.rdata$r:000027BF                 db    0
.rdata$r:000027C0                 db    3
.rdata$r:000027C1                 db    0
.rdata$r:000027C2                 db    0
.rdata$r:000027C3                 db    0
.rdata$r:000027C4                 dd offset ??_R2_Iostream_error_category@std@@8 ; std::_Iostream_error_category::`RTTI Base Class Array'
.rdata$r:000027C4 _rdata$r        ends
.rdata$r:000027C4
.rdata$r:000027C8 ; ===========================================================================
.rdata$r:000027C8
.rdata$r:000027C8 ; Segment type: Pure data
.rdata$r:000027C8 ; Segment permissions: Read
.rdata$r:000027C8 _rdata$r        segment dword public 'DATA' use32
.rdata$r:000027C8                 assume cs:_rdata$r
.rdata$r:000027C8                 ;org 27C8h
.rdata$r:000027C8 ; COMDAT (pick any)
.rdata$r:000027C8                 public ??_R2_Iostream_error_category@std@@8
.rdata$r:000027C8 ; std::_Iostream_error_category::`RTTI Base Class Array'
.rdata$r:000027C8 ??_R2_Iostream_error_category@std@@8 dd offset ??_R1A@?0A@EA@_Iostream_error_category@std@@8
.rdata$r:000027C8                                         ; DATA XREF: .rdata$r:000027C4o
.rdata$r:000027C8                                         ; std::_Iostream_error_category::`RTTI Base Class Descriptor at (0,-1,0,64)'
.rdata$r:000027CC                 dd offset ??_R1A@?0A@EA@_Generic_error_category@std@@8 ; std::_Generic_error_category::`RTTI Base Class Descriptor at (0,-1,0,64)'
.rdata$r:000027D0                 dd offset ??_R1A@?0A@EA@error_category@std@@8 ; std::error_category::`RTTI Base Class Descriptor at (0,-1,0,64)'
.rdata$r:000027D4                 db    0
.rdata$r:000027D5                 align 4
.rdata$r:000027D5 _rdata$r        ends
.rdata$r:000027D5
.rdata$r:000027D8 ; ===========================================================================
.rdata$r:000027D8
.rdata$r:000027D8 ; Segment type: Pure data
.rdata$r:000027D8 ; Segment permissions: Read
.rdata$r:000027D8 _rdata$r        segment dword public 'DATA' use32
.rdata$r:000027D8                 assume cs:_rdata$r
.rdata$r:000027D8                 ;org 27D8h
.rdata$r:000027D8 ; COMDAT (pick any)
.rdata$r:000027D8                 public ??_R1A@?0A@EA@_Iostream_error_category@std@@8
.rdata$r:000027D8 ; std::_Iostream_error_category::`RTTI Base Class Descriptor at (0, -1, 0, 64)'
.rdata$r:000027D8 ??_R1A@?0A@EA@_Iostream_error_category@std@@8 dd offset ??_R0?AV_Iostream_error_category@std@@@8
.rdata$r:000027D8                                         ; DATA XREF: .rdata$r:std::_Iostream_error_category::`RTTI Base Class Array'o
.rdata$r:000027D8                                         ; std::_Iostream_error_category `RTTI Type Descriptor'
.rdata$r:000027DC                 db    2
.rdata$r:000027DD                 db    0
.rdata$r:000027DE                 db    0
.rdata$r:000027DF                 db    0
.rdata$r:000027E0                 db    0
.rdata$r:000027E1                 db    0
.rdata$r:000027E2                 db    0
.rdata$r:000027E3                 db    0
.rdata$r:000027E4                 db 0FFh
.rdata$r:000027E5                 db 0FFh
.rdata$r:000027E6                 db 0FFh
.rdata$r:000027E7                 db 0FFh
.rdata$r:000027E8                 db    0
.rdata$r:000027E9                 db    0
.rdata$r:000027EA                 db    0
.rdata$r:000027EB                 db    0
.rdata$r:000027EC                 db  40h ; @
.rdata$r:000027ED                 db    0
.rdata$r:000027EE                 db    0
.rdata$r:000027EF                 db    0
.rdata$r:000027F0                 dd offset ??_R3_Iostream_error_category@std@@8 ; std::_Iostream_error_category::`RTTI Class Hierarchy Descriptor'
.rdata$r:000027F0 _rdata$r        ends
.rdata$r:000027F0
.rdata$r:000027F4 ; ===========================================================================
.rdata$r:000027F4
.rdata$r:000027F4 ; Segment type: Pure data
.rdata$r:000027F4 ; Segment permissions: Read
.rdata$r:000027F4 _rdata$r        segment dword public 'DATA' use32
.rdata$r:000027F4                 assume cs:_rdata$r
.rdata$r:000027F4                 ;org 27F4h
.rdata$r:000027F4 ; COMDAT (pick any)
.rdata$r:000027F4                 public ??_R4_System_error_category@std@@6B@
.rdata$r:000027F4 ; const std::_System_error_category::`RTTI Complete Object Locator'
.rdata$r:000027F4 ??_R4_System_error_category@std@@6B@ db    0 ; DATA XREF: .rdata:00002364o
.rdata$r:000027F5                 db    0
.rdata$r:000027F6                 db    0
.rdata$r:000027F7                 db    0
.rdata$r:000027F8                 db    0
.rdata$r:000027F9                 db    0
.rdata$r:000027FA                 db    0
.rdata$r:000027FB                 db    0
.rdata$r:000027FC                 db    0
.rdata$r:000027FD                 db    0
.rdata$r:000027FE                 db    0
.rdata$r:000027FF                 db    0
.rdata$r:00002800                 dd offset ??_R0?AV_System_error_category@std@@@8 ; std::_System_error_category `RTTI Type Descriptor'
.rdata$r:00002804                 dd offset ??_R3_System_error_category@std@@8 ; std::_System_error_category::`RTTI Class Hierarchy Descriptor'
.rdata$r:00002804 _rdata$r        ends
.rdata$r:00002804
.data$r:00002808 ; ===========================================================================
.data$r:00002808
.data$r:00002808 ; Segment type: Pure data
.data$r:00002808 ; Segment permissions: Read/Write
.data$r:00002808 _data$r         segment dword public 'DATA' use32
.data$r:00002808                 assume cs:_data$r
.data$r:00002808                 ;org 2808h
.data$r:00002808 ; COMDAT (pick any)
.data$r:00002808                 public ??_R0?AV_System_error_category@std@@@8
.data$r:00002808 ; class std::_System_error_category `RTTI Type Descriptor'
.data$r:00002808 ??_R0?AV_System_error_category@std@@@8 dd offset ??_7type_info@@6B@
.data$r:00002808                                         ; DATA XREF: .rdata$r:00002800o
.data$r:00002808                                         ; .rdata$r:std::_System_error_category::`RTTI Base Class Descriptor at (0,-1,0,64)'o
.data$r:00002808                                         ; const type_info::`vftable'
.data$r:0000280C                 align 10h
.data$r:00002810 a_?av_system_er db '.?AV_System_error_category@std@@',0
.data$r:00002831                 align 4
.data$r:00002831 _data$r         ends
.data$r:00002831
.rdata$r:00002834 ; ===========================================================================
.rdata$r:00002834
.rdata$r:00002834 ; Segment type: Pure data
.rdata$r:00002834 ; Segment permissions: Read
.rdata$r:00002834 _rdata$r        segment dword public 'DATA' use32
.rdata$r:00002834                 assume cs:_rdata$r
.rdata$r:00002834                 ;org 2834h
.rdata$r:00002834 ; COMDAT (pick any)
.rdata$r:00002834                 public ??_R3_System_error_category@std@@8
.rdata$r:00002834 ; std::_System_error_category::`RTTI Class Hierarchy Descriptor'
.rdata$r:00002834 ??_R3_System_error_category@std@@8 db    0 ; DATA XREF: .rdata$r:00002804o
.rdata$r:00002834                                         ; .rdata$r:0000286Co
.rdata$r:00002835                 db    0
.rdata$r:00002836                 db    0
.rdata$r:00002837                 db    0
.rdata$r:00002838                 db    0
.rdata$r:00002839                 db    0
.rdata$r:0000283A                 db    0
.rdata$r:0000283B                 db    0
.rdata$r:0000283C                 db    3
.rdata$r:0000283D                 db    0
.rdata$r:0000283E                 db    0
.rdata$r:0000283F                 db    0
.rdata$r:00002840                 dd offset ??_R2_System_error_category@std@@8 ; std::_System_error_category::`RTTI Base Class Array'
.rdata$r:00002840 _rdata$r        ends
.rdata$r:00002840
.rdata$r:00002844 ; ===========================================================================
.rdata$r:00002844
.rdata$r:00002844 ; Segment type: Pure data
.rdata$r:00002844 ; Segment permissions: Read
.rdata$r:00002844 _rdata$r        segment dword public 'DATA' use32
.rdata$r:00002844                 assume cs:_rdata$r
.rdata$r:00002844                 ;org 2844h
.rdata$r:00002844 ; COMDAT (pick any)
.rdata$r:00002844                 public ??_R2_System_error_category@std@@8
.rdata$r:00002844 ; std::_System_error_category::`RTTI Base Class Array'
.rdata$r:00002844 ??_R2_System_error_category@std@@8 dd offset ??_R1A@?0A@EA@_System_error_category@std@@8
.rdata$r:00002844                                         ; DATA XREF: .rdata$r:00002840o
.rdata$r:00002844                                         ; std::_System_error_category::`RTTI Base Class Descriptor at (0,-1,0,64)'
.rdata$r:00002848                 dd offset ??_R1A@?0A@EA@_Generic_error_category@std@@8 ; std::_Generic_error_category::`RTTI Base Class Descriptor at (0,-1,0,64)'
.rdata$r:0000284C                 dd offset ??_R1A@?0A@EA@error_category@std@@8 ; std::error_category::`RTTI Base Class Descriptor at (0,-1,0,64)'
.rdata$r:00002850                 db    0
.rdata$r:00002851                 align 4
.rdata$r:00002851 _rdata$r        ends
.rdata$r:00002851
.rdata$r:00002854 ; ===========================================================================
.rdata$r:00002854
.rdata$r:00002854 ; Segment type: Pure data
.rdata$r:00002854 ; Segment permissions: Read
.rdata$r:00002854 _rdata$r        segment dword public 'DATA' use32
.rdata$r:00002854                 assume cs:_rdata$r
.rdata$r:00002854                 ;org 2854h
.rdata$r:00002854 ; COMDAT (pick any)
.rdata$r:00002854                 public ??_R1A@?0A@EA@_System_error_category@std@@8
.rdata$r:00002854 ; std::_System_error_category::`RTTI Base Class Descriptor at (0, -1, 0, 64)'
.rdata$r:00002854 ??_R1A@?0A@EA@_System_error_category@std@@8 dd offset ??_R0?AV_System_error_category@std@@@8
.rdata$r:00002854                                         ; DATA XREF: .rdata$r:std::_System_error_category::`RTTI Base Class Array'o
.rdata$r:00002854                                         ; std::_System_error_category `RTTI Type Descriptor'
.rdata$r:00002858                 db    2
.rdata$r:00002859                 db    0
.rdata$r:0000285A                 db    0
.rdata$r:0000285B                 db    0
.rdata$r:0000285C                 db    0
.rdata$r:0000285D                 db    0
.rdata$r:0000285E                 db    0
.rdata$r:0000285F                 db    0
.rdata$r:00002860                 db 0FFh
.rdata$r:00002861                 db 0FFh
.rdata$r:00002862                 db 0FFh
.rdata$r:00002863                 db 0FFh
.rdata$r:00002864                 db    0
.rdata$r:00002865                 db    0
.rdata$r:00002866                 db    0
.rdata$r:00002867                 db    0
.rdata$r:00002868                 db  40h ; @
.rdata$r:00002869                 db    0
.rdata$r:0000286A                 db    0
.rdata$r:0000286B                 db    0
.rdata$r:0000286C                 dd offset ??_R3_System_error_category@std@@8 ; std::_System_error_category::`RTTI Class Hierarchy Descriptor'
.rdata$r:0000286C _rdata$r        ends
.rdata$r:0000286C
.CRT$XCU:00002870 ; ===========================================================================
.CRT$XCU:00002870
.CRT$XCU:00002870 ; Segment type: Pure data
.CRT$XCU:00002870 ; Segment permissions: Read
.CRT$XCU:00002870 _CRT$XCU        segment dword public 'DATA' use32
.CRT$XCU:00002870                 assume cs:_CRT$XCU
.CRT$XCU:00002870                 ;org 2870h
.CRT$XCU:00002870 _piecewise_construct$initializer$ dd offset ??__Epiecewise_construct@std@@YAXXZ ; std::`dynamic initializer for 'piecewise_construct''(void)
.CRT$XCU:00002874 _allocator_arg$initializer$ dd offset ??__Eallocator_arg@std@@YAXXZ ; std::`dynamic initializer for 'allocator_arg''(void)
.CRT$XCU:00002874 _CRT$XCU        ends
.CRT$XCU:00002874
.CRT$XCU:00002878 ; ===========================================================================
.CRT$XCU:00002878
.CRT$XCU:00002878 ; Segment type: Pure data
.CRT$XCU:00002878 ; Segment permissions: Read
.CRT$XCU:00002878 _CRT$XCU        segment dword public 'DATA' use32
.CRT$XCU:00002878                 assume cs:_CRT$XCU
.CRT$XCU:00002878                 ;org 2878h
.CRT$XCU:00002878 ; COMDAT (pick associative to section at 2388)
.CRT$XCU:00002878 ; public: static void (__cdecl *std::_Error_objects<int>::_Generic_object$initializer$)(void)
.CRT$XCU:00002878 ?_Generic_object$initializer$@?$_Error_objects@H@std@@2P6AXXZA dd offset ??__E?_Generic_object@?$_Error_objects@H@std@@2V_Generic_error_category@2@A@@YAXXZ ; `dynamic initializer for 'std::_Generic_error_category std::_Error_objects<int>::_Generic_object''(void)
.CRT$XCU:00002878 _CRT$XCU        ends
.CRT$XCU:00002878
.CRT$XCU:0000287C ; ===========================================================================
.CRT$XCU:0000287C
.CRT$XCU:0000287C ; Segment type: Pure data
.CRT$XCU:0000287C ; Segment permissions: Read
.CRT$XCU:0000287C _CRT$XCU        segment dword public 'DATA' use32
.CRT$XCU:0000287C                 assume cs:_CRT$XCU
.CRT$XCU:0000287C                 ;org 287Ch
.CRT$XCU:0000287C ; COMDAT (pick associative to section at 238C)
.CRT$XCU:0000287C ; public: static void (__cdecl *std::_Error_objects<int>::_Iostream_object$initializer$)(void)
.CRT$XCU:0000287C ?_Iostream_object$initializer$@?$_Error_objects@H@std@@2P6AXXZA dd offset ??__E?_Iostream_object@?$_Error_objects@H@std@@2V_Iostream_error_category@2@A@@YAXXZ ; `dynamic initializer for 'std::_Iostream_error_category std::_Error_objects<int>::_Iostream_object''(void)
.CRT$XCU:0000287C _CRT$XCU        ends
.CRT$XCU:0000287C
.CRT$XCU:00002880 ; ===========================================================================
.CRT$XCU:00002880
.CRT$XCU:00002880 ; Segment type: Pure data
.CRT$XCU:00002880 ; Segment permissions: Read
.CRT$XCU:00002880 _CRT$XCU        segment dword public 'DATA' use32
.CRT$XCU:00002880                 assume cs:_CRT$XCU
.CRT$XCU:00002880                 ;org 2880h
.CRT$XCU:00002880 ; COMDAT (pick associative to section at 2390)
.CRT$XCU:00002880 ; public: static void (__cdecl *std::_Error_objects<int>::_System_object$initializer$)(void)
.CRT$XCU:00002880 ?_System_object$initializer$@?$_Error_objects@H@std@@2P6AXXZA dd offset ??__E?_System_object@?$_Error_objects@H@std@@2V_System_error_category@2@A@@YAXXZ ; `dynamic initializer for 'std::_System_error_category std::_Error_objects<int>::_System_object''(void)
.CRT$XCU:00002880 _CRT$XCU        ends
.CRT$XCU:00002880
.CRT$XCU:00002884 ; ===========================================================================
.CRT$XCU:00002884
.CRT$XCU:00002884 ; Segment type: Pure data
.CRT$XCU:00002884 ; Segment permissions: Read
.CRT$XCU:00002884 _CRT$XCU        segment dword public 'DATA' use32
.CRT$XCU:00002884                 assume cs:_CRT$XCU
.CRT$XCU:00002884                 ;org 2884h
.CRT$XCU:00002884 ; COMDAT (pick associative to section at 2394)
.CRT$XCU:00002884 ; public: static void (__cdecl *std::num_put<char, class std::back_insert_iterator<class std::basic_string<char, struct std::char_traits<char>, class std::allocator<char>>>>::id$initializer$)(void)
.CRT$XCU:00002884 ?id$initializer$@?$num_put@DV?$back_insert_iterator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@std@@2P6AXXZA dd offset ??__E?id@?$num_put@DV?$back_insert_iterator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@std@@2V0locale@2@A@@YAXXZ ; `dynamic initializer for 'std::locale::id std::num_put<char,std::back_insert_iterator<std::basic_string<char,std::char_traits<char>,std::allocator<char>>>>::id''(void)
.CRT$XCU:00002884 _CRT$XCU        ends
.CRT$XCU:00002884
.CRT$XCU:00002888 ; ===========================================================================
.CRT$XCU:00002888
.CRT$XCU:00002888 ; Segment type: Pure data
.CRT$XCU:00002888 ; Segment permissions: Read
.CRT$XCU:00002888 _CRT$XCU        segment dword public 'DATA' use32
.CRT$XCU:00002888                 assume cs:_CRT$XCU
.CRT$XCU:00002888                 ;org 2888h
.CRT$XCU:00002888 ; COMDAT (pick associative to section at 2398)
.CRT$XCU:00002888 ; public: static void (__cdecl *std::num_put<wchar_t, class std::back_insert_iterator<class std::basic_string<wchar_t, struct std::char_traits<wchar_t>, class std::allocator<wchar_t>>>>::id$initializer$)(void)
.CRT$XCU:00002888 ?id$initializer$@?$num_put@_WV?$back_insert_iterator@V?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@@std@@@std@@2P6AXXZA dd offset ??__E?id@?$num_put@_WV?$back_insert_iterator@V?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@@std@@@std@@2V0locale@2@A@@YAXXZ ; `dynamic initializer for 'std::locale::id std::num_put<wchar_t,std::back_insert_iterator<std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>>>>::id''(void)
.CRT$XCU:00002888 _CRT$XCU        ends
.CRT$XCU:00002888
.CRT$XCU:0000288C ; ===========================================================================
.CRT$XCU:0000288C
.CRT$XCU:0000288C ; Segment type: Pure data
.CRT$XCU:0000288C ; Segment permissions: Read
.CRT$XCU:0000288C _CRT$XCU        segment dword public 'DATA' use32
.CRT$XCU:0000288C                 assume cs:_CRT$XCU
.CRT$XCU:0000288C                 ;org 288Ch
.CRT$XCU:0000288C ; COMDAT (pick associative to section at 242C)
.CRT$XCU:0000288C ; public: static void (__cdecl *std::numpunct<char>::id$initializer$)(void)
.CRT$XCU:0000288C ?id$initializer$@?$numpunct@D@std@@2P6AXXZA dd offset ??__E?id@?$numpunct@D@std@@2V0locale@2@A@@YAXXZ ; `dynamic initializer for 'std::locale::id std::numpunct<char>::id''(void)
.CRT$XCU:0000288C _CRT$XCU        ends
.CRT$XCU:0000288C
.CRT$XCU:00002890 ; ===========================================================================
.CRT$XCU:00002890
.CRT$XCU:00002890 ; Segment type: Pure data
.CRT$XCU:00002890 ; Segment permissions: Read
.CRT$XCU:00002890 _CRT$XCU        segment dword public 'DATA' use32
.CRT$XCU:00002890                 assume cs:_CRT$XCU
.CRT$XCU:00002890                 ;org 2890h
.CRT$XCU:00002890 ; COMDAT (pick associative to section at 2430)
.CRT$XCU:00002890 ; public: static void (__cdecl *std::numpunct<wchar_t>::id$initializer$)(void)
.CRT$XCU:00002890 ?id$initializer$@?$numpunct@_W@std@@2P6AXXZA dd offset ??__E?id@?$numpunct@_W@std@@2V0locale@2@A@@YAXXZ ; `dynamic initializer for 'std::locale::id std::numpunct<wchar_t>::id''(void)
.CRT$XCU:00002890 _CRT$XCU        ends
.CRT$XCU:00002890
UNDEF:000028A0 ; ===========================================================================
UNDEF:000028A0
UNDEF:000028A0 ; Segment type: Externs
UNDEF:000028A0 ; UNDEF
UNDEF:000028A0                 extrn __purecall:near   ; DATA XREF: .rdata:000022DCo
UNDEF:000028A0                                         ; .rdata:000022E0o
UNDEF:000028A4 ; void *__cdecl operator new(unsigned int)
UNDEF:000028A4                 extrn ??2@YAPAXI@Z:near ; CODE XREF: std::_Allocate<char>(uint,char *)+1Dp
UNDEF:000028A4                                         ; std::_Allocate<std::_Container_proxy>(uint,std::_Container_proxy *)+23p
UNDEF:000028A8 ; void __cdecl operator delete(void *)
UNDEF:000028A8                 extrn ??3@YAXPAX@Z:near ; CODE XREF: std::_Generic_error_category::`scalar deleting destructor'(uint)+1Bp
UNDEF:000028A8                                         ; std::_Iostream_error_category::`scalar deleting destructor'(uint)+1Bp ...
UNDEF:000028AC ; int __cdecl atexit(void (__cdecl *)())
UNDEF:000028AC                 extrn _atexit:near      ; CODE XREF: `dynamic initializer for 'std::_Generic_error_category std::_Error_objects<int>::_Generic_object''(void)+12p
UNDEF:000028AC                                         ; `dynamic initializer for 'std::_Iostream_error_category std::_Error_objects<int>::_Iostream_object''(void)+12p ...
UNDEF:000028B0                 extrn __invalid_parameter:near
UNDEF:000028B0                                         ; CODE XREF: std::vector<DlgInfo,std::allocator<DlgInfo>>::operator[](uint)+74p
UNDEF:000028B4 ; void *__cdecl memcpy(void *Dst, const void *Src, size_t Size)
UNDEF:000028B4                 extrn _memcpy:near      ; CODE XREF: std::char_traits<char>::copy(char *,char const *,uint)+1Ep
UNDEF:000028B8 ; size_t __cdecl strlen(const char *Str)
UNDEF:000028B8                 extrn _strlen:near      ; CODE XREF: std::char_traits<char>::length(char const *)+1Bp
UNDEF:000028BC ; void *__cdecl memmove(void *Dst, const void *Src, size_t Size)
UNDEF:000028BC                 extrn _memmove:near     ; CODE XREF: std::char_traits<char>::move(char *,char const *,uint)+1Ep
UNDEF:000028C0 ; size_t __cdecl wcslen(const wchar_t *Str)
UNDEF:000028C0                 extrn _wcslen:near      ; CODE XREF: std::char_traits<wchar_t>::length(wchar_t const *)+1Bp
UNDEF:000028C4 ; LRESULT __stdcall SendMessageW(HWND hWnd, UINT Msg, WPARAM wParam, LPARAM lParam)
UNDEF:000028C4                 extrn __imp__SendMessageW@16:near
UNDEF:000028C4                                         ; CODE XREF: ControlsTab::renameTab(int,wchar_t const *)+2Ap
UNDEF:000028C4                                         ; TabBar::getRowCount(void)+17p
UNDEF:000028C4                                         ; DATA XREF: ...
UNDEF:000028C8 ; void __thiscall TabBar::reSizeTo(TabBar *__hidden this, struct tagRECT *)
UNDEF:000028C8                 extrn ?reSizeTo@TabBar@@UAEXAAUtagRECT@@@Z:near
UNDEF:000028C8                                         ; CODE XREF: ControlsTab::reSizeTo(tagRECT &)+10p
UNDEF:000028CC ; int __thiscall TabBar::insertAtEnd(TabBar *__hidden this, const wchar_t *)
UNDEF:000028CC                 extrn ?insertAtEnd@TabBar@@QAEHPB_W@Z:near
UNDEF:000028CC                                         ; CODE XREF: ControlsTab::createTabs(std::vector<DlgInfo,std::allocator<DlgInfo>> &)+51p
UNDEF:000028D0 ; void __thiscall TabBar::activateAt(TabBar *__hidden this, int)
UNDEF:000028D0                 extrn ?activateAt@TabBar@@QBEXH@Z:near
UNDEF:000028D0                                         ; CODE XREF: ControlsTab::createTabs(std::vector<DlgInfo,std::allocator<DlgInfo>> &)+5Dp
UNDEF:000028D4 ; _DWORD __thiscall std::_Lockit::_Lockit(std::_Lockit *__hidden this, int)
UNDEF:000028D4                 extrn ??0_Lockit@std@@QAE@H@Z:near
UNDEF:000028D4                                         ; CODE XREF: std::_Container_base12::_Orphan_all(void)+35p
UNDEF:000028D8 ; _DWORD __thiscall std::_Lockit::~_Lockit(std::_Lockit *__hidden this)
UNDEF:000028D8                 extrn ??1_Lockit@std@@QAE@XZ:near
UNDEF:000028D8                                         ; CODE XREF: std::_Container_base12::_Orphan_all(void)+86p
UNDEF:000028D8                                         ; __unwindfunclet$?_Orphan_all@_Container_base12@std@@QAEXXZ$0+3j
UNDEF:000028DC                 extrn __hypot:near      ; CODE XREF: _hypot+1Dp
UNDEF:000028E0                 extrn __CrtDbgReportW:near
UNDEF:000028E0                                         ; CODE XREF: std::vector<DlgInfo,std::allocator<DlgInfo>>::operator[](uint)+50p
UNDEF:000028E4 ; void __cdecl std::_Debug_message(const wchar_t *, const wchar_t *, unsigned int)
UNDEF:000028E4                 extrn ?_Debug_message@std@@YAXPB_W0I@Z:near
UNDEF:000028E4                                         ; CODE XREF: std::_Debug_pointer<char>(char const *,wchar_t const *,uint)+16p
UNDEF:000028E4                                         ; std::_Debug_pointer<wchar_t>(wchar_t const *,wchar_t const *,uint)+16p ...
UNDEF:000028E8 ; void __cdecl std::_Xbad_alloc()
UNDEF:000028E8                 extrn ?_Xbad_alloc@std@@YAXXZ:near
UNDEF:000028E8                                         ; CODE XREF: std::_Allocate<char>(uint,char *):loc_302p
UNDEF:000028E8                                         ; std::_Allocate<std::_Container_proxy>(uint,std::_Container_proxy *):loc_344p
UNDEF:000028EC ; void __cdecl std::_Xlength_error(const char *)
UNDEF:000028EC                 extrn ?_Xlength_error@std@@YAXPBD@Z:near
UNDEF:000028EC                                         ; CODE XREF: std::basic_string<char,std::char_traits<char>,std::allocator<char>>::_Xlen(void)+Cp
UNDEF:000028F0 ; void __cdecl std::_Xout_of_range(const char *)
UNDEF:000028F0                 extrn ?_Xout_of_range@std@@YAXPBD@Z:near
UNDEF:000028F0                                         ; CODE XREF: std::basic_string<char,std::char_traits<char>,std::allocator<char>>::_Xran(void)+Cp
UNDEF:000028F0                                         ; std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>>::_Xran(void)+Cp
UNDEF:000028F4 ; public: virtual void * __thiscall std::error_category::`vector deleting destructor'(unsigned int)
UNDEF:000028F4                 extrn ??_Eerror_category@std@@UAEPAXI@Z:near ; weak
UNDEF:000028F4                                         ; DATA XREF: .rdata:const std::error_category::`vftable'o
UNDEF:000028F8 ; const char *__cdecl std::_Syserror_map(int)
UNDEF:000028F8                 extrn ?_Syserror_map@std@@YAPBDH@Z:near
UNDEF:000028F8                                         ; CODE XREF: std::_System_error_category::default_error_condition(int)+Bp
UNDEF:000028F8                                         ; std::_Generic_error_category::message(int)+33p
UNDEF:000028FC ; const char *__cdecl std::_Winerror_map(int)
UNDEF:000028FC                 extrn ?_Winerror_map@std@@YAPBDH@Z:near
UNDEF:000028FC                                         ; CODE XREF: std::_System_error_category::message(int)+33p
UNDEF:00002900 ; public: virtual void * __thiscall std::_Generic_error_category::`vector deleting destructor'(unsigned int)
UNDEF:00002900                 extrn ??_E_Generic_error_category@std@@UAEPAXI@Z:near ; weak
UNDEF:00002900                                         ; DATA XREF: .rdata:const std::_Generic_error_category::`vftable'o
UNDEF:00002904 ; public: virtual void * __thiscall std::_Iostream_error_category::`vector deleting destructor'(unsigned int)
UNDEF:00002904                 extrn ??_E_Iostream_error_category@std@@UAEPAXI@Z:near ; weak
UNDEF:00002904                                         ; DATA XREF: .rdata:const std::_Iostream_error_category::`vftable'o
UNDEF:00002908 ; public: virtual void * __thiscall std::_System_error_category::`vector deleting destructor'(unsigned int)
UNDEF:00002908                 extrn ??_E_System_error_category@std@@UAEPAXI@Z:near ; weak
UNDEF:00002908                                         ; DATA XREF: .rdata:const std::_System_error_category::`vftable'o
UNDEF:0000290C ; __fastcall __security_check_cookie(x)
UNDEF:0000290C                 extrn @__security_check_cookie@4:near
UNDEF:0000290C                                         ; CODE XREF: __ehhandler$??$construct@PADAAPAD@?$allocator@D@std@@QAEXPAPADAAPAD@Z+Cp
UNDEF:0000290C                                         ; __ehhandler$??$construct@U_Container_proxy@std@@U12@@?$allocator@U_Container_proxy@std@@@std@@QAEXPAU_Container_proxy@1@$$QAU21@@Z+Cp ...
UNDEF:00002910 ; __stdcall _CxxThrowException(x, x)
UNDEF:00002910                 extrn __CxxThrowException@8:near
UNDEF:00002910                                         ; CODE XREF: __catch$?_Copy@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEXII@Z$1+10p
UNDEF:00002914                 extrn ___CxxFrameHandler3:near
UNDEF:00002914                                         ; CODE XREF: __ehhandler$??$construct@PADAAPAD@?$allocator@D@std@@QAEXPAPADAAPAD@Z+16j
UNDEF:00002914                                         ; __ehhandler$??$construct@U_Container_proxy@std@@U12@@?$allocator@U_Container_proxy@std@@@std@@QAEXPAU_Container_proxy@1@$$QAU21@@Z+16j ...
UNDEF:00002918 ; const type_info::`vftable'
UNDEF:00002918                 extrn ??_7type_info@@6B@:near
UNDEF:00002918                                         ; DATA XREF: .data$r:std::error_category `RTTI Type Descriptor'o
UNDEF:00002918                                         ; .data$r:std::_Generic_error_category `RTTI Type Descriptor'o ...
UNDEF:0000291C                 extrn ___security_cookie:near
UNDEF:0000291C                                         ; DATA XREF: std::allocator<char>::construct<char *,char * &>(char * *,char * &)+14r
UNDEF:0000291C                                         ; std::allocator<std::_Container_proxy>::construct<std::_Container_proxy,std::_Container_proxy>(std::_Container_proxy *,std::_Container_proxy &&)+14r ...
UNDEF:00002920                 extrn __fltused:near
UNDEF:00002920
UNDEF:00002920
UNDEF:00002920                 end